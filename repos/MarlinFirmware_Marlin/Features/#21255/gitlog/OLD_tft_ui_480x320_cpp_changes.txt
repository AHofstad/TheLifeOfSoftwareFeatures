commit 244de2458ac6fd48f3031d0179ca1bcad6808583
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Mon Jul 17 10:53:36 2023 +0300

    üßë‚Äçüíª Improve TFT Color UI layout / theme (#26077)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
deleted file mode 100644
index 8e554cf413..0000000000
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ /dev/null
@@ -1,1196 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-#include "../../inc/MarlinConfigPre.h"
-
-#if HAS_UI_480x320 || HAS_UI_480x272
-
-#include "ui_common.h"
-
-#include "../marlinui.h"
-#include "../menu/menu.h"
-#include "../../libs/numtostr.h"
-
-#include "../../sd/cardreader.h"
-#include "../../module/temperature.h"
-#include "../../module/printcounter.h"
-#include "../../module/planner.h"
-#include "../../module/motion.h"
-
-#if DISABLED(LCD_PROGRESS_BAR) && ALL(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
-  #include "../../feature/filwidth.h"
-  #include "../../gcode/parser.h"
-#endif
-
-#if ENABLED(AUTO_BED_LEVELING_UBL)
-  #include "../../feature/bedlevel/bedlevel.h"
-#endif
-
-void MarlinUI::tft_idle() {
-  #if ENABLED(TOUCH_SCREEN)
-    if (TERN0(HAS_TOUCH_SLEEP, lcd_sleep_task())) return;
-    if (draw_menu_navigation) {
-      add_control(TFT_WIDTH / 6 - 16, TFT_HEIGHT - 34, PAGE_UP, imgPageUp, encoderTopLine > 0);
-      add_control(TFT_WIDTH / 2 - 16, TFT_HEIGHT - 34, PAGE_DOWN, imgPageDown, encoderTopLine + LCD_HEIGHT < screen_items);
-      add_control(5 * TFT_WIDTH / 6 - 16, TFT_HEIGHT - 34, BACK, imgBack);
-      draw_menu_navigation = false;
-    }
-  #endif
-
-  tft.queue.async();
-
-  TERN_(TOUCH_SCREEN, if (tft.queue.is_empty()) touch.idle()); // Touch driver is not DMA-aware, so only check for touch controls after screen drawing is completed
-}
-
-#if ENABLED(SHOW_BOOTSCREEN)
-
-  void MarlinUI::show_bootscreen() {
-    tft.queue.reset();
-
-    tft.canvas(0, 0, TFT_WIDTH, TFT_HEIGHT);
-    #if ENABLED(BOOT_MARLIN_LOGO_SMALL)
-      #define BOOT_LOGO_W 195   // MarlinLogo195x59x16
-      #define BOOT_LOGO_H  59
-      #define SITE_URL_Y (TFT_HEIGHT - 70)
-      tft.set_background(COLOR_BACKGROUND);
-    #else
-      #define BOOT_LOGO_W TFT_WIDTH   // MarlinLogo480x320x16
-      #define BOOT_LOGO_H TFT_HEIGHT
-      #define SITE_URL_Y (TFT_HEIGHT - 90)
-    #endif
-    tft.add_image((TFT_WIDTH - BOOT_LOGO_W) / 2, (TFT_HEIGHT - BOOT_LOGO_H) / 2, imgBootScreen);
-    #ifdef WEBSITE_URL
-      tft_string.set(WEBSITE_URL);
-      tft.add_text(tft_string.center(TFT_WIDTH), SITE_URL_Y, COLOR_WEBSITE_URL, tft_string);
-    #endif
-
-    tft.queue.sync();
-  }
-
-  void MarlinUI::bootscreen_completion(const millis_t sofar) {
-    if ((BOOTSCREEN_TIMEOUT) > sofar) safe_delay((BOOTSCREEN_TIMEOUT) - sofar);
-    clear_lcd();
-  }
-
-#endif
-
-void MarlinUI::draw_kill_screen() {
-  tft.queue.reset();
-  tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_KILL_SCREEN_BG);
-
-  uint16_t line = 2;
-
-  menu_line(line++, COLOR_KILL_SCREEN_BG);
-  tft_string.set(status_message);
-  tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
-
-  line++;
-  menu_line(line++, COLOR_KILL_SCREEN_BG);
-  tft_string.set(GET_TEXT(MSG_HALTED));
-  tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
-
-  menu_line(line++, COLOR_KILL_SCREEN_BG);
-  tft_string.set(GET_TEXT(MSG_PLEASE_RESET));
-  tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
-
-  tft.queue.sync();
-}
-
-void draw_heater_status(uint16_t x, uint16_t y, const int8_t heater) {
-  MarlinImage image = imgHotEnd;
-  celsius_t currentTemperature, targetTemperature;
-
-  if (heater >= 0) { // HotEnd
-    #if HAS_EXTRUDERS
-      currentTemperature = thermalManager.wholeDegHotend(heater);
-      targetTemperature = thermalManager.degTargetHotend(heater);
-    #else
-      return;
-    #endif
-  }
-  #if HAS_HEATED_BED
-    else if (heater == H_BED) {
-      currentTemperature = thermalManager.wholeDegBed();
-      targetTemperature = thermalManager.degTargetBed();
-    }
-  #endif
-  #if HAS_TEMP_CHAMBER
-    else if (heater == H_CHAMBER) {
-      currentTemperature = thermalManager.wholeDegChamber();
-      #if HAS_HEATED_CHAMBER
-        targetTemperature = thermalManager.degTargetChamber();
-      #else
-        targetTemperature = ABSOLUTE_ZERO;
-      #endif
-    }
-  #endif
-  #if HAS_TEMP_COOLER
-    else if (heater == H_COOLER) {
-      currentTemperature = thermalManager.wholeDegCooler();
-      targetTemperature = TERN(HAS_COOLER, thermalManager.degTargetCooler(), ABSOLUTE_ZERO);
-    }
-  #endif
-  else return;
-
-  TERN_(TOUCH_SCREEN, if (targetTemperature >= 0) touch.add_control(HEATER, x, y, 80, 120, heater));
-  tft.canvas(x, y, 80, 120);
-  tft.set_background(COLOR_BACKGROUND);
-
-  uint16_t color = currentTemperature < 0 ? COLOR_INACTIVE : COLOR_COLD;
-
-  if (heater >= 0) { // HotEnd
-    if (currentTemperature >= 50) color = COLOR_HOTEND;
-  }
-  #if HAS_HEATED_BED
-    else if (heater == H_BED) {
-      if (currentTemperature >= 50) color = COLOR_HEATED_BED;
-      image = targetTemperature > 0 ? imgBedHeated : imgBed;
-    }
-  #endif
-  #if HAS_TEMP_CHAMBER
-    else if (heater == H_CHAMBER) {
-      if (currentTemperature >= 50) color = COLOR_CHAMBER;
-      image = targetTemperature > 0 ? imgChamberHeated : imgChamber;
-    }
-  #endif
-  #if HAS_TEMP_COOLER
-    else if (heater == H_COOLER) {
-      if (currentTemperature <= 26) color = COLOR_COLD;
-      if (currentTemperature > 26) color = COLOR_RED;
-      image = targetTemperature > 26 ? imgCoolerHot : imgCooler;
-    }
-  #endif
-
-  tft.add_image(8, 28, image, color);
-
-  tft_string.set(i16tostr3rj(currentTemperature));
-  tft_string.add(LCD_STR_DEGREE);
-  tft_string.trim();
-  tft.add_text(tft_string.center(80) + 2, 80 + tft_string.vcenter(FONT_LINE_HEIGHT), color, tft_string);
-
-  if (targetTemperature >= 0) {
-    tft_string.set(i16tostr3rj(targetTemperature));
-    tft_string.add(LCD_STR_DEGREE);
-    tft_string.trim();
-    tft.add_text(tft_string.center(80) + 2, 6 + tft_string.vcenter(FONT_LINE_HEIGHT), color, tft_string);
-  }
-}
-
-void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
-  TERN_(TOUCH_SCREEN, touch.add_control(FAN, x, y, 80, 120));
-  tft.canvas(x, y, 80, 120);
-  tft.set_background(COLOR_BACKGROUND);
-
-  uint8_t fanSpeed = thermalManager.fan_speed[0];
-  MarlinImage image;
-
-  if (fanSpeed >= 127)
-    image = blink ? imgFanFast1 : imgFanFast0;
-  else if (fanSpeed > 0)
-    image = blink ? imgFanSlow1 : imgFanSlow0;
-  else
-    image = imgFanIdle;
-
-  tft.add_image(8, 20, image, COLOR_FAN);
-
-  tft_string.set(ui8tostr4pctrj(thermalManager.fan_speed[0]));
-  tft_string.trim();
-  tft.add_text(tft_string.center(80) + 6, 80 + tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_FAN, tft_string);
-}
-
-void MarlinUI::draw_status_screen() {
-  const bool blink = get_blink();
-
-  TERN_(TOUCH_SCREEN, touch.clear());
-
-  // Statuses of heaters and fans
-  uint16_t y = STATUS_MARGIN_SIZE;
-  for (uint16_t i = 0; i < ITEMS_COUNT; i++) {
-    uint16_t x = (TFT_WIDTH / ITEMS_COUNT - 80) / 2  + (TFT_WIDTH * i / ITEMS_COUNT);
-    switch (i) {
-      #if HAS_EXTRUDERS
-        case ITEM_E0: draw_heater_status(x, y, H_E0); break;
-      #endif
-      #if HAS_MULTI_HOTEND
-        case ITEM_E1: draw_heater_status(x, y, H_E1); break;
-      #endif
-      #if HOTENDS > 2
-        case ITEM_E2: draw_heater_status(x, y, H_E2); break;
-      #endif
-      #if HAS_HEATED_BED
-        case ITEM_BED: draw_heater_status(x, y, H_BED); break;
-      #endif
-      #if HAS_TEMP_CHAMBER
-        case ITEM_CHAMBER: draw_heater_status(x, y, H_CHAMBER); break;
-      #endif
-      #if HAS_TEMP_COOLER
-        case ITEM_COOLER: draw_heater_status(x, y, H_COOLER); break;
-      #endif
-      #if HAS_FAN
-        case ITEM_FAN: draw_fan_status(x, y, blink); break;
-      #endif
-    }
-  }
-
-  y += STATUS_MARGIN_SIZE + 114;
-
-  // Coordinates
-  constexpr uint16_t coords_width = TFT_WIDTH - 8;
-  tft.canvas((TFT_WIDTH - coords_width) / 2, y, coords_width, FONT_LINE_HEIGHT);
-  tft.set_background(COLOR_BACKGROUND);
-  tft.add_rectangle(0, 0, coords_width, FONT_LINE_HEIGHT, COLOR_AXIS_HOMED);
-
-  if (TERN0(LCD_SHOW_E_TOTAL, printingIsActive())) {
-    #if ENABLED(LCD_SHOW_E_TOTAL)
-      tft.add_text(16, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "E");
-      const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
-      tft_string.set(ftostr4sign(e_move_accumulator / escale));
-      tft_string.add(escale == 10 ? 'c' : 'm');
-      tft_string.add('m');
-      tft.add_text(192 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
-    #endif
-  }
-  else {
-    // Coords in mask "X____Y____Z____"
-    #if HAS_X_AXIS
-      tft_string.set("X");
-      tft.add_text(coords_width / 30 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
-
-      const bool nhx = axis_should_home(X_AXIS);
-      tft_string.set(blink && nhx ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
-      tft_string.ltrim();
-      tft.add_text(coords_width / 5 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
-    #endif
-
-    #if HAS_Y_AXIS
-      tft_string.set("Y");
-      tft.add_text(11 * coords_width / 30 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
-
-      const bool nhy = axis_should_home(Y_AXIS);
-      tft_string.set(blink && nhy ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
-      tft_string.ltrim();
-      tft.add_text(8 * coords_width / 15 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
-    #endif
-  }
-
-  #if HAS_Z_AXIS
-    tft_string.set("Z");
-    tft.add_text(7 * coords_width / 10 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
-
-    const bool nhz = axis_should_home(Z_AXIS);
-    tft_string.set(blink && nhz ? "?" : ftostr52sp(LOGICAL_Z_POSITION(current_position.z)));
-    tft_string.ltrim();
-    tft_string.rtrim();
-    tft.add_text(13 * coords_width / 15 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
-  #endif
-
-  TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 4, y, TFT_WIDTH - 8, FONT_LINE_HEIGHT));
-
-  y += STATUS_MARGIN_SIZE + 34;
-
-  // Feed rate (preparing)
-  tft_string.set(i16tostr3rj(feedrate_percentage));
-  tft_string.add("%");
-  uint16_t component_width = 36 + tft_string.width(); // 32px icon size + 4px margin before text
-  uint16_t color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
-  uint16_t x = FEEDRATE_X(component_width);
-
-  // Feed rate (drawing)
-  tft.canvas(x, y, component_width, 32);
-  tft.set_background(COLOR_BACKGROUND);
-  tft.add_image(0, 0, imgFeedRate, color);
-  tft.add_text(36, tft_string.vcenter(30), color, tft_string);
-  TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE, x, y, component_width, 32));
-
-  #if HAS_EXTRUDERS
-    // Flow rate (preparing)
-    tft_string.set(i16tostr3rj(planner.flow_percentage[active_extruder]));
-    tft_string.add('%');
-    component_width = 36 + tft_string.width();
-    color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
-    x = FLOWRATE_X(component_width);
-
-    // Flow rate (drawing)
-    tft.canvas(x, y, component_width, 32);
-    tft.set_background(COLOR_BACKGROUND);
-    tft.add_image(0, 0, imgFlowRate, color);
-    tft.add_text(36, tft_string.vcenter(30), color, tft_string);
-    TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE, x, y, component_width, 32, active_extruder));
-  #endif
-
-  y += TERN(HAS_UI_480x272, 36, 44);
-
-  const progress_t progress = TERN(HAS_PRINT_PROGRESS_PERMYRIAD, get_progress_permyriad, get_progress_percent)();
-  #if ENABLED(SHOW_ELAPSED_TIME) && DISABLED(SHOW_REMAINING_TIME)
-    // Print duration so far (time elapsed) - centered
-    char elapsed_str[22];
-    duration_t elapsed = print_job_timer.duration();
-    elapsed.toString(elapsed_str);
-
-    // Same width constraints as feedrate/flowrate controls
-    constexpr uint16_t time_str_width = 288, image_width = 36;
-
-    tft.canvas((TFT_WIDTH - time_str_width) / 2, y, time_str_width, 32);
-    tft.set_background(COLOR_BACKGROUND);
-    tft_string.set(elapsed_str);
-    uint16_t text_pos_x = tft_string.center(time_str_width - image_width);
-    tft.add_image(text_pos_x, 0, imgTimeElapsed, COLOR_PRINT_TIME);
-    tft.add_text(text_pos_x + image_width, tft_string.vcenter(29), COLOR_PRINT_TIME, tft_string);
-
-  #elif DISABLED(SHOW_ELAPSED_TIME) && ENABLED(SHOW_REMAINING_TIME)
-    // Print time remaining estimation - centered
-    char estimate_str[22];
-    duration_t elapsed = print_job_timer.duration();
-
-    // Get the estimate, first from M73
-    uint32_t estimate_remaining = (0
-      #if ALL(SET_PROGRESS_MANUALLY, SET_REMAINING_TIME)
-        + get_remaining_time()
-      #endif
-    );
-    // If no M73 estimate is available but we have progress data, calculate time remaining assuming time elapsed is linear with progress
-    if (!estimate_remaining && progress > 0)
-      estimate_remaining = elapsed.value * (100 * (PROGRESS_SCALE) - progress) / progress;
-
-    // Generate estimate string
-    if (!estimate_remaining)
-      tft_string.set("-");
-    else {
-      duration_t estimation = estimate_remaining;
-      estimation.toString(estimate_str);
-      tft_string.set(estimate_str);
-    }
-
-    // Same width constraints as feedrate/flowrate controls
-    constexpr uint16_t time_str_width = 288, image_width = 36;
-
-    tft.canvas((TFT_WIDTH - time_str_width) / 2, y, time_str_width, 32);
-    tft.set_background(COLOR_BACKGROUND);
-    color = printingIsActive() ? COLOR_PRINT_TIME : COLOR_INACTIVE;
-    uint16_t text_pos_x = tft_string.center(time_str_width - image_width);
-    tft.add_image(text_pos_x, 0, imgTimeRemaining, color);
-    tft.add_text(text_pos_x + image_width, tft_string.vcenter(29), color, tft_string);
-
-  #elif ALL(SHOW_REMAINING_TIME, SHOW_ELAPSED_TIME)
-    // Print duration so far (time elapsed) - aligned under feed rate
-    char elapsed_str[18];
-    duration_t elapsed = print_job_timer.duration();
-    elapsed.toCompactString(elapsed_str);
-
-    tft.canvas(96, y, 144, 32);
-    tft.set_background(COLOR_BACKGROUND);
-    tft.add_image(0, 0, imgTimeElapsed, COLOR_PRINT_TIME);
-    tft_string.set(elapsed_str);
-    tft.add_text(36, tft_string.vcenter(29), COLOR_PRINT_TIME, tft_string);
-
-    // Print time remaining estimation - aligned under flow rate
-    char estimate_str[18];
-
-    // Get the estimate, first from M73
-    uint32_t estimate_remaining = (0
-      #if ALL(SET_PROGRESS_MANUALLY, SET_REMAINING_TIME)
-        + get_remaining_time()
-      #endif
-    );
-    // If no M73 estimate is available but we have progress data, calculate time remaining assuming time elapsed is linear with progress
-    if (!estimate_remaining && progress > 0)
-      estimate_remaining = elapsed.value * (100 * (PROGRESS_SCALE) - progress) / progress;
-
-    // Generate estimate string
-    if (!estimate_remaining)
-      tft_string.set("-");
-    else {
-      duration_t estimation = estimate_remaining;
-      estimation.toCompactString(estimate_str);
-      tft_string.set(estimate_str);
-    }
-
-    // Push out the estimate to the screen
-    tft.canvas(256, y, 144, 32);
-    tft.set_background(COLOR_BACKGROUND);
-    color = printingIsActive() ? COLOR_PRINT_TIME : COLOR_INACTIVE;
-    tft.add_image(0, 0, imgTimeRemaining, color);
-    tft.add_text(36, tft_string.vcenter(29), color, tft_string);
-  #endif
-
-  y += TERN(HAS_UI_480x272, 36, 44);
-
-  // Progress bar
-  // TODO: print percentage text for SHOW_PROGRESS_PERCENT
-  tft.canvas(4, y, TFT_WIDTH - 8, 9);
-  tft.set_background(COLOR_PROGRESS_BG);
-  tft.add_rectangle(0, 0, TFT_WIDTH - 8, 9, COLOR_PROGRESS_FRAME);
-  if (progress)
-    tft.add_bar(1, 1, ((TFT_WIDTH - 10) * progress / (PROGRESS_SCALE)) / 100, 7, COLOR_PROGRESS_BAR);
-
-  y += 12;
-  // Status message
-  // Canvas height should be 40px on 480x320 and 28 on 480x272
-  const uint16_t status_height = TFT_HEIGHT - y;
-  tft.canvas(0, y, TFT_WIDTH, status_height);
-  tft.set_background(COLOR_BACKGROUND);
-  tft_string.set(status_message);
-  tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_STATUS_MESSAGE, tft_string);
-}
-
-// Low-level draw_edit_screen can be used to draw an edit screen from anyplace
-void MenuEditItemBase::draw_edit_screen(FSTR_P const fstr, const char * const value/*=nullptr*/) {
-  ui.encoder_direction_normal();
-  TERN_(TOUCH_SCREEN, touch.clear());
-
-  uint16_t line = 1;
-
-  menu_line(line++);
-  tft_string.set(fstr, itemIndex, itemStringC, itemStringF);
-  tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-
-  TERN_(AUTO_BED_LEVELING_UBL, if (ui.external_control) line++);  // ftostr52() will overwrite *value so *value has to be displayed first
-
-  menu_line(line);
-  tft_string.set(value);
-  tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-    if (ui.external_control) {
-      menu_line(line - 1);
-
-      tft_string.set(X_LBL);
-      tft.add_text((TFT_WIDTH / 2 - 120), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-      tft_string.set(ftostr52(LOGICAL_X_POSITION(current_position.x)));
-      tft_string.trim();
-      tft.add_text((TFT_WIDTH / 2 - 16) - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-
-      tft_string.set(Y_LBL);
-      tft.add_text((TFT_WIDTH / 2 + 16), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-      tft_string.set(ftostr52(LOGICAL_X_POSITION(current_position.y)));
-      tft_string.trim();
-      tft.add_text((TFT_WIDTH / 2 + 120) - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-    }
-  #endif
-
-  if (ui.can_show_slider()) {
-
-    #define SLIDER_LENGTH TFT_WIDTH * 0.7
-    #define SLIDER_Y_POSITION 186
-
-    tft.canvas((TFT_WIDTH - SLIDER_LENGTH) / 2, SLIDER_Y_POSITION, SLIDER_LENGTH, 16);
-    tft.set_background(COLOR_BACKGROUND);
-
-    int16_t position = (SLIDER_LENGTH - 2) * ui.encoderPosition / maxEditValue;
-    tft.add_bar(0, 7, 1, 2, ui.encoderPosition == 0 ? COLOR_SLIDER_INACTIVE : COLOR_SLIDER);
-    tft.add_bar(1, 6, position, 4, COLOR_SLIDER);
-    tft.add_bar(position + 1, 6, SLIDER_LENGTH - 2 - position, 4, COLOR_SLIDER_INACTIVE);
-    tft.add_bar(SLIDER_LENGTH - 1, 7, 1, 2, int32_t(ui.encoderPosition) == maxEditValue ? COLOR_SLIDER : COLOR_SLIDER_INACTIVE);
-
-    #if ENABLED(TOUCH_SCREEN)
-      tft.add_image((SLIDER_LENGTH - 8) * ui.encoderPosition / maxEditValue, 0, imgSlider, COLOR_SLIDER);
-      touch.add_control(SLIDER, (TFT_WIDTH - SLIDER_LENGTH) / 2, SLIDER_Y_POSITION - 8, SLIDER_LENGTH, 32, maxEditValue);
-    #endif
-  }
-
-  tft.draw_edit_screen_buttons();
-}
-
-void TFT::draw_edit_screen_buttons() {
-  #if ENABLED(TOUCH_SCREEN)
-    add_control((TFT_WIDTH - 3 * 64) / 6, TFT_HEIGHT - 64, DECREASE, imgDecrease);
-    add_control((TFT_WIDTH - 64) / 2, TFT_HEIGHT - 64, INCREASE, imgIncrease);
-    add_control((TFT_WIDTH * 5 - 3 * 64) / 6, TFT_HEIGHT - 64, CLICK, imgConfirm);
-  #endif
-}
-
-// The Select Screen presents a prompt and two "buttons"
-void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, const bool yesno, FSTR_P const pref, const char * const string/*=nullptr*/, FSTR_P const suff/*=nullptr*/) {
-  uint16_t line = 1;
-
-  if (!string) line++;
-
-  menu_line(line++);
-  tft_string.set(pref);
-  tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
-
-  if (string) {
-    menu_line(line++);
-    tft_string.set(string);
-    tft_string.trim();
-    tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
-  }
-
-  if (suff) {
-    menu_line(line);
-    tft_string.set(suff);
-    tft_string.trim();
-    tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
-  }
-  #if ENABLED(TOUCH_SCREEN)
-    if (no)  add_control(TFT_WIDTH / 4 - 32, TFT_HEIGHT - 64, CANCEL,  imgCancel,  true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
-    if (yes) add_control(TFT_WIDTH * 3 / 4 - 32, TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
-  #endif
-}
-
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-
-  void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
-    #if ENABLED(TOUCH_SCREEN)
-      touch.clear();
-      draw_menu_navigation = false;
-      touch.add_control(RESUME_CONTINUE, 0, 0, TFT_WIDTH, TFT_HEIGHT);
-    #endif
-
-    menu_line(row);
-    tft_string.set(GET_TEXT(MSG_FILAMENT_CHANGE_NOZZLE));
-    tft_string.add('E');
-    tft_string.add((char)('1' + extruder));
-    tft_string.add(' ');
-    tft_string.add(i16tostr3rj(thermalManager.wholeDegHotend(extruder)));
-    tft_string.add(LCD_STR_DEGREE);
-    tft_string.add(F(" / "));
-    tft_string.add(i16tostr3rj(thermalManager.degTargetHotend(extruder)));
-    tft_string.add(LCD_STR_DEGREE);
-    tft_string.trim();
-    tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
-  }
-
-#endif // ADVANCED_PAUSE_FEATURE
-
-#if ENABLED(AUTO_BED_LEVELING_UBL)
-  #define GRID_OFFSET_X   8
-  #define GRID_OFFSET_Y   8
-  #define GRID_WIDTH      192
-  #define GRID_HEIGHT     192
-  #define CONTROL_OFFSET  16
-
-  void MarlinUI::ubl_plot(const uint8_t x_plot, const uint8_t y_plot) {
-
-    tft.canvas(GRID_OFFSET_X, GRID_OFFSET_Y, GRID_WIDTH, GRID_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft.add_rectangle(0, 0, GRID_WIDTH, GRID_HEIGHT, COLOR_WHITE);
-
-    for (uint16_t x = 0; x < (GRID_MAX_POINTS_X); x++)
-      for (uint16_t y = 0; y < (GRID_MAX_POINTS_Y); y++)
-        if (position_is_reachable({ bedlevel.get_mesh_x(x), bedlevel.get_mesh_y(y) }))
-          tft.add_bar(1 + (x * 2 + 1) * (GRID_WIDTH - 4) / (GRID_MAX_POINTS_X) / 2, GRID_HEIGHT - 3 - ((y * 2 + 1) * (GRID_HEIGHT - 4) / (GRID_MAX_POINTS_Y) / 2), 2, 2, COLOR_UBL);
-
-    tft.add_rectangle((x_plot * 2 + 1) * (GRID_WIDTH - 4) / (GRID_MAX_POINTS_X) / 2 - 1, GRID_HEIGHT - 5 - ((y_plot * 2 + 1) * (GRID_HEIGHT - 4) / (GRID_MAX_POINTS_Y) / 2), 6, 6, COLOR_UBL);
-
-    const xy_pos_t pos = { bedlevel.get_mesh_x(x_plot), bedlevel.get_mesh_y(y_plot) },
-                   lpos = pos.asLogical();
-
-    tft.canvas(320, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2 - MENU_ITEM_HEIGHT, 120, MENU_ITEM_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft_string.set(X_LBL);
-    tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-    tft_string.set(ftostr52(lpos.x));
-    tft_string.trim();
-    tft.add_text(120 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-
-    tft.canvas(320, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2, 120, MENU_ITEM_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft_string.set(Y_LBL);
-    tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-    tft_string.set(ftostr52(lpos.y));
-    tft_string.trim();
-    tft.add_text(120 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-
-    tft.canvas(320, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2 + MENU_ITEM_HEIGHT, 120, MENU_ITEM_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft_string.set(Z_LBL);
-    tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-    tft_string.set(isnan(bedlevel.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(bedlevel.z_values[x_plot][y_plot]));
-    tft_string.trim();
-    tft.add_text(120 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-
-    constexpr uint8_t w = (TFT_WIDTH) / 10;
-    tft.canvas(GRID_OFFSET_X + (GRID_WIDTH - w) / 2, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET - 5, w, MENU_ITEM_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft_string.set(ui8tostr3rj(x_plot));
-    tft_string.trim();
-    tft.add_text(tft_string.center(w), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-
-    tft.canvas(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET + 16 - 24, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2, w, MENU_ITEM_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft_string.set(ui8tostr3rj(y_plot));
-    tft_string.trim();
-    tft.add_text(tft_string.center(w), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-
-    #if ENABLED(TOUCH_SCREEN)
-      touch.clear();
-      draw_menu_navigation = false;
-      add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + CONTROL_OFFSET,                    UBL,  (ENCODER_STEPS_PER_MENU_ITEM) * (GRID_MAX_POINTS_X), imgUp);
-      add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + GRID_HEIGHT - CONTROL_OFFSET - 32, UBL, -(ENCODER_STEPS_PER_MENU_ITEM) * (GRID_MAX_POINTS_X), imgDown);
-      add_control(GRID_OFFSET_X + CONTROL_OFFSET,                   GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL, -(ENCODER_STEPS_PER_MENU_ITEM), imgLeft);
-      add_control(GRID_OFFSET_X + GRID_WIDTH - CONTROL_OFFSET - 32, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL,   ENCODER_STEPS_PER_MENU_ITEM, imgRight);
-      add_control(320, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET, CLICK, imgLeveling);
-      add_control(224, TFT_HEIGHT - 34, BACK, imgBack);
-    #endif
-  }
-#endif // AUTO_BED_LEVELING_UBL
-
-#if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-  #include "../../feature/babystep.h"
-#endif
-
-#if HAS_BED_PROBE
-  #include "../../module/probe.h"
-#endif
-
-#define Z_SELECTION_Z 1
-#define Z_SELECTION_Z_PROBE -1
-
-struct {
-  #if HAS_X_AXIS
-    xy_int_t xValuePos;
-  #endif
-  #if HAS_Y_AXIS
-    xy_int_t yValuePos;
-  #endif
-  #if HAS_Z_AXIS
-    xy_int_t zValuePos, zTypePos;
-    int z_selection = Z_SELECTION_Z;
-  #endif
-  #if HAS_EXTRUDERS
-    xy_int_t eValuePos, eNamePos;
-    uint8_t e_selection = 0;
-  #endif
-  xy_int_t stepValuePos;
-  float currentStepSize = 10.0;
-  bool blocked = false;
-  char message[32];
-} motionAxisState;
-
-#define BTN_WIDTH 64
-#define BTN_HEIGHT 52
-#define X_MARGIN 20
-#define Y_MARGIN 15
-#define Y_OFFSET TERN(HAS_UI_480x272, 28, 34)
-
-static void quick_feedback() {
-  #if HAS_CHIRP
-    ui.chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
-    #if ALL(HAS_MARLINUI_MENU, HAS_BEEPER)
-      for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
-    #elif HAS_MARLINUI_MENU
-      delay(10);
-    #endif
-  #endif
-}
-
-#define CUR_STEP_VALUE_WIDTH 104
-static void drawCurStepValue() {
-  tft_string.set(ftostr52sp(motionAxisState.currentStepSize));
-  tft_string.trim();
-  tft_string.add(F("mm"));
-  tft.canvas(motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT);
-  tft.set_background(COLOR_BACKGROUND);
-  tft.add_text(0, 0, COLOR_AXIS_HOMED, tft_string);
-}
-
-#if HAS_Z_AXIS
-  static void drawCurZSelection() {
-    tft_string.set('Z');
-    tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y, tft_string.width(), FONT_LINE_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
-
-    tft.queue.sync();
-
-    tft_string.set(F("Offset"));
-    tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y + Y_OFFSET, tft_string.width(), Y_OFFSET TERN_(HAS_UI_480x272, - 10));
-    tft.set_background(COLOR_BACKGROUND);
-    #if HAS_BED_PROBE
-      if (motionAxisState.z_selection == Z_SELECTION_Z_PROBE)
-        tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
-    #endif
-  }
-#endif
-
-#if HAS_EXTRUDERS
-  static void drawCurESelection() {
-    tft.canvas(motionAxisState.eNamePos.x, motionAxisState.eNamePos.y, BTN_WIDTH, BTN_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft_string.set('E');
-    tft_string.add(utostr3(motionAxisState.e_selection));
-    tft.add_text(tft_string.center(BTN_WIDTH), 0, E_BTN_COLOR, tft_string);
-  }
-#endif
-
-static void drawMessage(PGM_P const msg) {
-  #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-    tft.canvas(X_MARGIN, TFT_HEIGHT - 2 * MOVE_AXIS_MARGIN_SIZE - BTN_HEIGHT - FONT_LINE_HEIGHT, TFT_WIDTH - X_MARGIN * 2, FONT_LINE_HEIGHT);
-  #else
-    tft.canvas(X_MARGIN, TFT_HEIGHT - Y_MARGIN - Y_OFFSET, TFT_HEIGHT / 2, Y_OFFSET);
-  #endif
-  tft.set_background(COLOR_BACKGROUND);
-  tft.add_text(0, 0, COLOR_YELLOW, msg);
-}
-
-static void drawMessage(FSTR_P const fmsg) { drawMessage(FTOP(fmsg)); }
-
-static void drawAxisValue(const AxisEnum axis) {
-  const float value = (
-    TERN_(HAS_BED_PROBE, axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE ? probe.offset.z :)
-    ui.manual_move.axis_value(axis)
-  );
-  xy_int_t pos;
-  uint16_t color;
-  switch (axis) {
-    #if HAS_X_AXIS
-      case X_AXIS: pos = motionAxisState.xValuePos; color = X_BTN_COLOR; break;
-    #endif
-    #if HAS_Y_AXIS
-      case Y_AXIS: pos = motionAxisState.yValuePos; color = Y_BTN_COLOR; break;
-    #endif
-    #if HAS_Z_AXIS
-      case Z_AXIS: pos = motionAxisState.zValuePos; color = Z_BTN_COLOR; break;
-    #endif
-    #if HAS_EXTRUDERS
-      case E_AXIS: pos = motionAxisState.eValuePos; color = E_BTN_COLOR; break;
-    #endif
-    default: return;
-  }
-  tft.canvas(pos.x, pos.y, BTN_WIDTH + X_MARGIN, BTN_HEIGHT TERN_(HAS_UI_480x272, / 2));
-  tft.set_background(COLOR_BACKGROUND);
-  tft_string.set(ftostr52sp(value));
-  tft_string.trim();
-  tft.add_text(tft_string.center(BTN_WIDTH + X_MARGIN), 0, color, tft_string);
-}
-
-static void moveAxis(const AxisEnum axis, const int8_t direction) {
-  quick_feedback();
-
-  #if HAS_EXTRUDERS
-    if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
-      drawMessage(F("Too cold"));
-      return;
-    }
-  #endif
-
-  const float diff = motionAxisState.currentStepSize * direction;
-
-  #if HAS_BED_PROBE
-
-    if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
-      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-        const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
-        const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
-        const float bsDiff = planner.mm_per_step[Z_AXIS] * babystep_increment,
-                    new_probe_offset = probe.offset.z + bsDiff,
-                    new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
-                      , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff
-                      , new_probe_offset
-                    );
-        if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
-          babystep.add_steps(Z_AXIS, babystep_increment);
-          if (do_probe)
-            probe.offset.z = new_offs;
-          else
-            TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
-          drawMessage(NUL_STR); // Clear the error
-          drawAxisValue(axis);
-        }
-        else
-          drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
-
-      #else
-        // Only change probe.offset.z
-        probe.offset.z += diff;
-        if (direction < 0 && current_position.z < Z_PROBE_OFFSET_RANGE_MIN) {
-          current_position.z = Z_PROBE_OFFSET_RANGE_MIN;
-          drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
-        }
-        else if (direction > 0 && current_position.z > Z_PROBE_OFFSET_RANGE_MAX) {
-          current_position.z = Z_PROBE_OFFSET_RANGE_MAX;
-          drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
-        }
-        else
-          drawMessage(NUL_STR); // Clear the error
-
-        drawAxisValue(axis);
-      #endif
-    }
-
-  #endif // HAS_BED_PROBE
-
-  if (!ui.manual_move.processing) {
-    // Get motion limit from software endstops, if any
-    float min, max;
-    soft_endstop.get_manual_axis_limits(axis, min, max);
-
-    // Delta limits XY based on the current offset from center
-    // This assumes the center is 0,0
-    #if ENABLED(DELTA)
-      if (axis != Z_AXIS && TERN1(HAS_EXTRUDERS, axis != E_AXIS)) {
-        max = SQRT(sq(float(PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
-        min = -max;
-      }
-    #endif
-
-    // Get the new position
-    const bool limited = ui.manual_move.apply_diff(axis, diff, min, max);
-    #if IS_KINEMATIC
-      UNUSED(limited);
-    #else
-      PGM_P const msg = limited ? GET_TEXT(MSG_LCD_SOFT_ENDSTOPS) : NUL_STR;
-      drawMessage(msg);
-    #endif
-
-    ui.manual_move.soon(axis OPTARG(MULTI_E_MANUAL, motionAxisState.e_selection));
-  }
-
-  drawAxisValue(axis);
-}
-
-#if HAS_EXTRUDERS
-  static void e_plus()  { moveAxis(E_AXIS, 1);  }
-  static void e_minus() { moveAxis(E_AXIS, -1); }
-#endif
-#if HAS_X_AXIS
-  static void x_minus() { moveAxis(X_AXIS, -1); }
-  static void x_plus()  { moveAxis(X_AXIS, 1);  }
-#endif
-#if HAS_Y_AXIS
-  static void y_plus()  { moveAxis(Y_AXIS, 1);  }
-  static void y_minus() { moveAxis(Y_AXIS, -1); }
-#endif
-#if HAS_Z_AXIS
-  static void z_plus()  { moveAxis(Z_AXIS, 1);  }
-  static void z_minus() { moveAxis(Z_AXIS, -1); }
-#endif
-
-#if ENABLED(TOUCH_SCREEN)
-  #if HAS_EXTRUDERS
-    static void e_select() {
-      if (++motionAxisState.e_selection >= EXTRUDERS)
-        motionAxisState.e_selection = 0;
-      quick_feedback();
-      drawCurESelection();
-      drawAxisValue(E_AXIS);
-    }
-  #endif
-
-  static void do_home() {
-    quick_feedback();
-    drawMessage(GET_TEXT_F(MSG_LEVEL_BED_HOMING));
-    queue.inject_P(G28_STR);
-    // Disable touch until home is done
-    touch.disable();
-    TERN_(HAS_EXTRUDERS, drawAxisValue(E_AXIS));
-    TERN_(HAS_X_AXIS, drawAxisValue(X_AXIS));
-    TERN_(HAS_Y_AXIS, drawAxisValue(Y_AXIS));
-    TERN_(HAS_Z_AXIS, drawAxisValue(Z_AXIS));
-  }
-
-  static void step_size() {
-    motionAxisState.currentStepSize = motionAxisState.currentStepSize / 10.0;
-    if (motionAxisState.currentStepSize < 0.0015) motionAxisState.currentStepSize = 10.0;
-    quick_feedback();
-    drawCurStepValue();
-  }
-#endif // TOUCH_SCREEN
-
-#if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
-  static void z_select() {
-    motionAxisState.z_selection *= -1;
-    quick_feedback();
-    drawCurZSelection();
-    drawAxisValue(Z_AXIS);
-  }
-#endif
-
-static void disable_steppers() {
-  quick_feedback();
-  queue.inject(F("M84"));
-}
-
-static void drawBtn(const int x, const int y, const char *label, intptr_t data, const MarlinImage img, uint16_t bgColor, const bool enabled=true) {
-  const uint16_t width = images[imgBtn52Rounded].width,
-                height = images[imgBtn52Rounded].height;
-
-  if (!enabled) bgColor = COLOR_CONTROL_DISABLED;
-
-  tft.canvas(x, y, width, height);
-  tft.set_background(COLOR_BACKGROUND);
-  tft.add_image(0, 0, imgBtn52Rounded, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
-
-  // TODO: Make an add_text() taking a font arg
-  if (label) {
-    tft_string.set(label);
-    tft_string.trim();
-    tft.add_text(tft_string.center(width), height / 2 - tft_string.font_height() / 2, bgColor, tft_string);
-  }
-  else
-    tft.add_image(0, 0, img, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
-
-  TERN_(TOUCH_SCREEN, if (enabled) touch.add_control(BUTTON, x, y, width, height, data));
-}
-
-void MarlinUI::move_axis_screen() {
-  // Reset
-  defer_status_screen(true);
-  motionAxisState.blocked = false;
-  TERN_(TOUCH_SCREEN, touch.enable());
-
-  ui.clear_lcd();
-
-  TERN_(TOUCH_SCREEN, touch.clear());
-
-  const bool busy = printingIsActive();
-
-  // Babysteps during printing? Select babystep for Z probe offset
-  #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-    if (busy) motionAxisState.z_selection = Z_SELECTION_Z_PROBE;
-  #endif
-
-  #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-
-    int y = MOVE_AXIS_MARGIN_SIZE;
-
-    /**************************************************************************
-     * 1st: | Button "E+" | Button "Y+" | Button "Z+" |
-     *************************************************************************/
-
-    TERN_(HAS_EXTRUDERS, drawBtn(TFT_WIDTH / 6     - BTN_WIDTH / 2, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy));
-    TERN_(HAS_Y_AXIS,    drawBtn(TFT_WIDTH / 2     - BTN_WIDTH / 2, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy));
-    TERN_(HAS_Z_AXIS,    drawBtn(TFT_WIDTH * 5 / 6 - BTN_WIDTH / 2, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)));
-
-    y += BTN_HEIGHT + 4;
-
-    /**************************************************************************
-     * 2nd: | Label "Ex" (E0, E1, etc.) | Y value | Label "Z" |
-     *************************************************************************/
-
-    // Label "Ex" (E0, E1, etc.)
-    #if HAS_EXTRUDERS
-      motionAxisState.eNamePos.set(TFT_WIDTH / 6 - BTN_WIDTH / 2, y);
-      drawCurESelection();
-      #if ENABLED(TOUCH_SCREEN)
-        if (!busy) touch.add_control(BUTTON, motionAxisState.eNamePos.x, motionAxisState.eNamePos.y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select);
-      #endif
-    #endif
-
-    // Y value
-    #if HAS_Y_AXIS
-      motionAxisState.yValuePos.set(TFT_WIDTH / 2 - (BTN_WIDTH + X_MARGIN) / 2, y);
-      drawAxisValue(Y_AXIS);
-    #endif
-
-    // Label "Z"
-    #ifdef HAS_Z_AXIS
-      motionAxisState.zTypePos.set(TFT_WIDTH * 5 / 6 - BTN_WIDTH / 2, y);
-      drawCurZSelection();
-      #if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
-        if (!busy) touch.add_control(BUTTON, motionAxisState.zTypePos.x, motionAxisState.zTypePos.y, BTN_WIDTH, FONT_LINE_HEIGHT * 2, (intptr_t)z_select);
-      #endif
-    #endif
-
-    y += BTN_HEIGHT + MOVE_AXIS_MARGIN_SIZE;
-
-    /**************************************************************************
-     * 3rd: | Button "X-" | Button "Homing" | Button "X+" |
-     *************************************************************************/
-
-    #if HAS_X_AXIS
-      drawBtn(TFT_WIDTH / 6 - BTN_WIDTH / 2, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
-      TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH / 2 - images[imgHome].width / 2, y - (images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
-      drawBtn(TFT_WIDTH * 5 / 6 - BTN_WIDTH / 2, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
-    #endif
-
-    y += BTN_HEIGHT + 4;
-
-    /**************************************************************************
-     * 4th: | X value |
-     *************************************************************************/
-
-    #ifdef HAS_X_AXIS
-      motionAxisState.xValuePos.set(TFT_WIDTH / 6 - (BTN_WIDTH + X_MARGIN) / 2, y);
-      drawAxisValue(X_AXIS);
-    #endif
-
-    y += BTN_HEIGHT + MOVE_AXIS_MARGIN_SIZE;
-
-    /**************************************************************************
-     * 5th: | Button "E-" | Button "Y-" | Button "Z-"
-     *************************************************************************/
-
-    TERN_(HAS_EXTRUDERS, drawBtn(TFT_WIDTH / 6 - BTN_WIDTH / 2, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy));
-    TERN_(HAS_Y_AXIS, drawBtn(TFT_WIDTH / 2 - BTN_WIDTH / 2, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy));
-    TERN_(HAS_Z_AXIS, drawBtn(TFT_WIDTH * 5 / 6 - BTN_WIDTH / 2, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)));
-
-    y += BTN_HEIGHT + 4;
-
-    /**************************************************************************
-     * 6th: | Current Ex value | Z value |
-     *************************************************************************/
-
-    // Current Ex value
-    #ifdef HAS_EXTRUDERS
-      motionAxisState.eValuePos.set(TFT_WIDTH / 6 - (BTN_WIDTH + X_MARGIN) / 2, y);
-      drawAxisValue(E_AXIS);
-    #endif
-
-    #ifdef HAS_Z_AXIS
-      motionAxisState.zValuePos.set(TFT_WIDTH * 5 / 6 - (BTN_WIDTH + X_MARGIN) / 2, y);
-      drawAxisValue(Z_AXIS);
-    #endif
-
-    y += BTN_HEIGHT + MOVE_AXIS_MARGIN_SIZE;
-
-    /**************************************************************************
-     * 7th: | Message - drawMessage(...) function |
-     *************************************************************************/
-
-    y += FONT_LINE_HEIGHT + MOVE_AXIS_MARGIN_SIZE;
-
-    /**************************************************************************
-     * 8th: | Step size | Button "Disable steppers" | Button "Back" |
-     *************************************************************************/
-
-    // Step size
-    motionAxisState.stepValuePos.set(X_MARGIN, y + 12);
-    if (!busy) {
-      drawCurStepValue();
-      TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y + 12, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
-    }
-
-    // Button "Disable steppers"
-    drawBtn(TFT_WIDTH / 2, y, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
-
-    // Button "Back"
-    TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH * 5 / 6 - images[imgBack].width / 2, y + 12, BACK, imgBack));
-
-  #else // !TFT_COLOR_UI_PORTRAIT
-
-    // ROW 1 -> E- Y- CurY Z+
-    int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
-
-    TERN_(HAS_EXTRUDERS, drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy));
-
-    spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
-    x += BTN_WIDTH + spacing;
-
-    TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy));
-
-    x += BTN_WIDTH;
-
-    // Cur Y
-    #if HAS_Y_AXIS
-      motionAxisState.yValuePos.set(x + 2, y);
-      drawAxisValue(Y_AXIS);
-    #endif
-
-    x += spacing;
-    #if HAS_Z_AXIS
-      drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); // Only enabled when not busy or have baby step
-    #endif
-
-    // ROW 2 -> "Ex"  X-  HOME X+  "Z"
-    y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
-    x = X_MARGIN;
-    spacing = (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4;
-
-    #if HAS_EXTRUDERS
-      motionAxisState.eNamePos.set(x, y);
-      drawCurESelection();
-      TERN_(TOUCH_SCREEN, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
-    #endif
-
-    x += BTN_WIDTH + spacing;
-
-    TERN_(HAS_X_AXIS, drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy));
-
-    x += BTN_WIDTH + spacing; //imgHome is 64x64
-
-    #if ALL(HAS_X_AXIS, TOUCH_SCREEN)
-      add_control(TFT_WIDTH / 2 - images[imgHome].width / 2, y - (images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy);
-    #endif
-
-    x += BTN_WIDTH + spacing;
-    const uint16_t xplus_x = x;
-
-    TERN_(HAS_X_AXIS, drawBtn(x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy));
-
-    x += BTN_WIDTH + spacing;
-
-    #if HAS_Z_AXIS
-      motionAxisState.zTypePos.set(x, y);
-      drawCurZSelection();
-      #if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
-        if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, Y_OFFSET * 2, (intptr_t)z_select);
-      #endif
-    #endif
-
-    // ROW 3 -> E- CurX Y-  Z-
-    y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
-    x = X_MARGIN;
-    spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
-
-    #if HAS_EXTRUDERS
-      drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
-      motionAxisState.eValuePos.set(x, y + BTN_HEIGHT + 2);
-      drawAxisValue(E_AXIS);
-    #endif
-
-    // Cur X
-    #if HAS_X_AXIS
-      motionAxisState.xValuePos.set(BTN_WIDTH + (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4, y - 10);
-      TERN_(HAS_X_AXIS, drawAxisValue(X_AXIS));
-    #endif
-
-    x += BTN_WIDTH + spacing;
-
-    // Cur Y
-    TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy));
-
-    x += BTN_WIDTH + spacing;
-
-    // Cur Z
-    #if HAS_Z_AXIS
-      drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
-      motionAxisState.zValuePos.set(x, y + BTN_HEIGHT + 2);
-      drawAxisValue(Z_AXIS);
-    #endif
-
-    // ROW 4 -> step_size  disable steppers back
-    y = TFT_HEIGHT - Y_MARGIN - TERN(HAS_UI_480x272, BTN_WIDTH / 2, 32);
-    x = TFT_WIDTH / 2 - CUR_STEP_VALUE_WIDTH / 2;
-    motionAxisState.stepValuePos.set(x, y);
-    if (!busy) {
-      drawCurStepValue();
-      TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
-    }
-
-    // Aligned with x+
-    drawBtn(xplus_x, TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
-
-    TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));
-
-  #endif // !TFT_COLOR_UI_PORTRAIT
-}
-
-#endif // HAS_UI_480x320 || HAS_UI_480x272

commit 2218bab542c839f4d1d09640f7c7a1444e38a23b
Author: mjbogusz <mjbogusz@users.noreply.github.com>
Date:   Fri Jun 23 11:56:34 2023 +0200

    üö∏ Color UI remaining time (#24843)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 14d7da7ee4..8e554cf413 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -340,50 +340,116 @@ void MarlinUI::draw_status_screen() {
     TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE, x, y, component_width, 32, active_extruder));
   #endif
 
-  #if TFT_COLOR_UI_PORTRAIT || DISABLED(TOUCH_SCREEN)
-    y += STATUS_MARGIN_SIZE + 32;
-  #endif
+  y += TERN(HAS_UI_480x272, 36, 44);
 
-  #if ENABLED(TOUCH_SCREEN)
-    // Settings button
-    add_control(SETTINGS_X, y, menu_main, imgSettings);
-
-    // SD-card button / Cancel button
-    #if HAS_MEDIA
-      const bool cm = card.isMounted(), pa = printingIsActive();
-      if (cm && pa)
-        add_control(SDCARD_X, y, STOP, imgCancel, true, COLOR_CONTROL_CANCEL);
-      else
-        add_control(SDCARD_X, y, menu_media, imgSD, cm && !pa, COLOR_CONTROL_ENABLED, COLOR_CONTROL_DISABLED); // 64px icon size
-    #endif
+  const progress_t progress = TERN(HAS_PRINT_PROGRESS_PERMYRIAD, get_progress_permyriad, get_progress_percent)();
+  #if ENABLED(SHOW_ELAPSED_TIME) && DISABLED(SHOW_REMAINING_TIME)
+    // Print duration so far (time elapsed) - centered
+    char elapsed_str[22];
+    duration_t elapsed = print_job_timer.duration();
+    elapsed.toString(elapsed_str);
 
-    y += STATUS_MARGIN_SIZE + TERN(TFT_COLOR_UI_PORTRAIT, 64, 44);
-  #endif
+    // Same width constraints as feedrate/flowrate controls
+    constexpr uint16_t time_str_width = 288, image_width = 36;
 
-  // Print duration
-  char buffer[14];
-  duration_t elapsed = print_job_timer.duration();
-  elapsed.toDigital(buffer);
+    tft.canvas((TFT_WIDTH - time_str_width) / 2, y, time_str_width, 32);
+    tft.set_background(COLOR_BACKGROUND);
+    tft_string.set(elapsed_str);
+    uint16_t text_pos_x = tft_string.center(time_str_width - image_width);
+    tft.add_image(text_pos_x, 0, imgTimeElapsed, COLOR_PRINT_TIME);
+    tft.add_text(text_pos_x + image_width, tft_string.vcenter(29), COLOR_PRINT_TIME, tft_string);
+
+  #elif DISABLED(SHOW_ELAPSED_TIME) && ENABLED(SHOW_REMAINING_TIME)
+    // Print time remaining estimation - centered
+    char estimate_str[22];
+    duration_t elapsed = print_job_timer.duration();
+
+    // Get the estimate, first from M73
+    uint32_t estimate_remaining = (0
+      #if ALL(SET_PROGRESS_MANUALLY, SET_REMAINING_TIME)
+        + get_remaining_time()
+      #endif
+    );
+    // If no M73 estimate is available but we have progress data, calculate time remaining assuming time elapsed is linear with progress
+    if (!estimate_remaining && progress > 0)
+      estimate_remaining = elapsed.value * (100 * (PROGRESS_SCALE) - progress) / progress;
+
+    // Generate estimate string
+    if (!estimate_remaining)
+      tft_string.set("-");
+    else {
+      duration_t estimation = estimate_remaining;
+      estimation.toString(estimate_str);
+      tft_string.set(estimate_str);
+    }
 
-  tft.canvas((TFT_WIDTH - 128) / 2, y, 128, 29);
-  tft.set_background(COLOR_BACKGROUND);
-  tft_string.set(buffer);
-  tft.add_text(tft_string.center(128), tft_string.vcenter(29), COLOR_PRINT_TIME, tft_string);
+    // Same width constraints as feedrate/flowrate controls
+    constexpr uint16_t time_str_width = 288, image_width = 36;
+
+    tft.canvas((TFT_WIDTH - time_str_width) / 2, y, time_str_width, 32);
+    tft.set_background(COLOR_BACKGROUND);
+    color = printingIsActive() ? COLOR_PRINT_TIME : COLOR_INACTIVE;
+    uint16_t text_pos_x = tft_string.center(time_str_width - image_width);
+    tft.add_image(text_pos_x, 0, imgTimeRemaining, color);
+    tft.add_text(text_pos_x + image_width, tft_string.vcenter(29), color, tft_string);
+
+  #elif ALL(SHOW_REMAINING_TIME, SHOW_ELAPSED_TIME)
+    // Print duration so far (time elapsed) - aligned under feed rate
+    char elapsed_str[18];
+    duration_t elapsed = print_job_timer.duration();
+    elapsed.toCompactString(elapsed_str);
+
+    tft.canvas(96, y, 144, 32);
+    tft.set_background(COLOR_BACKGROUND);
+    tft.add_image(0, 0, imgTimeElapsed, COLOR_PRINT_TIME);
+    tft_string.set(elapsed_str);
+    tft.add_text(36, tft_string.vcenter(29), COLOR_PRINT_TIME, tft_string);
 
-  y += STATUS_MARGIN_SIZE + 29;
+    // Print time remaining estimation - aligned under flow rate
+    char estimate_str[18];
+
+    // Get the estimate, first from M73
+    uint32_t estimate_remaining = (0
+      #if ALL(SET_PROGRESS_MANUALLY, SET_REMAINING_TIME)
+        + get_remaining_time()
+      #endif
+    );
+    // If no M73 estimate is available but we have progress data, calculate time remaining assuming time elapsed is linear with progress
+    if (!estimate_remaining && progress > 0)
+      estimate_remaining = elapsed.value * (100 * (PROGRESS_SCALE) - progress) / progress;
+
+    // Generate estimate string
+    if (!estimate_remaining)
+      tft_string.set("-");
+    else {
+      duration_t estimation = estimate_remaining;
+      estimation.toCompactString(estimate_str);
+      tft_string.set(estimate_str);
+    }
+
+    // Push out the estimate to the screen
+    tft.canvas(256, y, 144, 32);
+    tft.set_background(COLOR_BACKGROUND);
+    color = printingIsActive() ? COLOR_PRINT_TIME : COLOR_INACTIVE;
+    tft.add_image(0, 0, imgTimeRemaining, color);
+    tft.add_text(36, tft_string.vcenter(29), color, tft_string);
+  #endif
+
+  y += TERN(HAS_UI_480x272, 36, 44);
 
   // Progress bar
-  const uint8_t progress = ui.get_progress_percent();
+  // TODO: print percentage text for SHOW_PROGRESS_PERCENT
   tft.canvas(4, y, TFT_WIDTH - 8, 9);
   tft.set_background(COLOR_PROGRESS_BG);
   tft.add_rectangle(0, 0, TFT_WIDTH - 8, 9, COLOR_PROGRESS_FRAME);
   if (progress)
-    tft.add_bar(1, 1, ((TFT_WIDTH - 10) * progress) / 100, 7, COLOR_PROGRESS_BAR);
-
-  y += STATUS_MARGIN_SIZE + 7;
+    tft.add_bar(1, 1, ((TFT_WIDTH - 10) * progress / (PROGRESS_SCALE)) / 100, 7, COLOR_PROGRESS_BAR);
 
+  y += 12;
   // Status message
-  tft.canvas(0, y, TFT_WIDTH, FONT_LINE_HEIGHT);
+  // Canvas height should be 40px on 480x320 and 28 on 480x272
+  const uint16_t status_height = TFT_HEIGHT - y;
+  tft.canvas(0, y, TFT_WIDTH, status_height);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(status_message);
   tft_string.trim();
@@ -878,9 +944,8 @@ static void drawBtn(const int x, const int y, const char *label, intptr_t data,
     tft_string.trim();
     tft.add_text(tft_string.center(width), height / 2 - tft_string.font_height() / 2, bgColor, tft_string);
   }
-  else {
+  else
     tft.add_image(0, 0, img, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
-  }
 
   TERN_(TOUCH_SCREEN, if (enabled) touch.add_control(BUTTON, x, y, width, height, data));
 }

commit 1fbeac7b5255634bb5aca209a3d3dcb6b5e43193
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 23 00:15:54 2023 -0500

    üé® Adjust TFT code/comments

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 9b23577c46..14d7da7ee4 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -264,7 +264,7 @@ void MarlinUI::draw_status_screen() {
 
   if (TERN0(LCD_SHOW_E_TOTAL, printingIsActive())) {
     #if ENABLED(LCD_SHOW_E_TOTAL)
-      tft.add_text( 16, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "E");
+      tft.add_text(16, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "E");
       const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
       tft_string.set(ftostr4sign(e_move_accumulator / escale));
       tft_string.add(escale == 10 ? 'c' : 'm');
@@ -745,29 +745,28 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
             probe.offset.z = new_offs;
           else
             TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
-          drawMessage(NUL_STR); // clear the error
+          drawMessage(NUL_STR); // Clear the error
           drawAxisValue(axis);
         }
         else
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
 
       #else
-        // only change probe.offset.z
+        // Only change probe.offset.z
         probe.offset.z += diff;
-        if (direction < 0 && current_position[axis] < Z_PROBE_OFFSET_RANGE_MIN) {
-          current_position[axis] = Z_PROBE_OFFSET_RANGE_MIN;
+        if (direction < 0 && current_position.z < Z_PROBE_OFFSET_RANGE_MIN) {
+          current_position.z = Z_PROBE_OFFSET_RANGE_MIN;
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
         }
-        else if (direction > 0 && current_position[axis] > Z_PROBE_OFFSET_RANGE_MAX) {
-          current_position[axis] = Z_PROBE_OFFSET_RANGE_MAX;
+        else if (direction > 0 && current_position.z > Z_PROBE_OFFSET_RANGE_MAX) {
+          current_position.z = Z_PROBE_OFFSET_RANGE_MAX;
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
         }
         else
-          drawMessage(NUL_STR); // clear the error
+          drawMessage(NUL_STR); // Clear the error
 
         drawAxisValue(axis);
       #endif
-      return;
     }
 
   #endif // HAS_BED_PROBE
@@ -863,9 +862,9 @@ static void disable_steppers() {
   queue.inject(F("M84"));
 }
 
-static void drawBtn(int x, int y, const char *label, intptr_t data, MarlinImage img, uint16_t bgColor, bool enabled = true) {
-  const uint16_t width = Images[imgBtn52Rounded].width,
-                height = Images[imgBtn52Rounded].height;
+static void drawBtn(const int x, const int y, const char *label, intptr_t data, const MarlinImage img, uint16_t bgColor, const bool enabled=true) {
+  const uint16_t width = images[imgBtn52Rounded].width,
+                height = images[imgBtn52Rounded].height;
 
   if (!enabled) bgColor = COLOR_CONTROL_DISABLED;
 
@@ -953,7 +952,7 @@ void MarlinUI::move_axis_screen() {
 
     #if HAS_X_AXIS
       drawBtn(TFT_WIDTH / 6 - BTN_WIDTH / 2, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
-      TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
+      TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH / 2 - images[imgHome].width / 2, y - (images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
       drawBtn(TFT_WIDTH * 5 / 6 - BTN_WIDTH / 2, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
     #endif
 
@@ -1018,7 +1017,7 @@ void MarlinUI::move_axis_screen() {
     drawBtn(TFT_WIDTH / 2, y, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
 
     // Button "Back"
-    TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH * 5 / 6 - Images[imgBack].width / 2, y + 12, BACK, imgBack));
+    TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH * 5 / 6 - images[imgBack].width / 2, y + 12, BACK, imgBack));
 
   #else // !TFT_COLOR_UI_PORTRAIT
 
@@ -1042,7 +1041,7 @@ void MarlinUI::move_axis_screen() {
 
     x += spacing;
     #if HAS_Z_AXIS
-      drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+      drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); // Only enabled when not busy or have baby step
     #endif
 
     // ROW 2 -> "Ex"  X-  HOME X+  "Z"
@@ -1063,11 +1062,11 @@ void MarlinUI::move_axis_screen() {
     x += BTN_WIDTH + spacing; //imgHome is 64x64
 
     #if ALL(HAS_X_AXIS, TOUCH_SCREEN)
-      add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy);
+      add_control(TFT_WIDTH / 2 - images[imgHome].width / 2, y - (images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy);
     #endif
 
     x += BTN_WIDTH + spacing;
-    uint16_t xplus_x = x;
+    const uint16_t xplus_x = x;
 
     TERN_(HAS_X_AXIS, drawBtn(x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy));
 
@@ -1092,21 +1091,22 @@ void MarlinUI::move_axis_screen() {
       drawAxisValue(E_AXIS);
     #endif
 
+    // Cur X
     #if HAS_X_AXIS
       motionAxisState.xValuePos.set(BTN_WIDTH + (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4, y - 10);
       TERN_(HAS_X_AXIS, drawAxisValue(X_AXIS));
     #endif
 
     x += BTN_WIDTH + spacing;
+
+    // Cur Y
     TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy));
 
     x += BTN_WIDTH + spacing;
-    #if HAS_Z_AXIS
-      drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
-    #endif
 
     // Cur Z
     #if HAS_Z_AXIS
+      drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
       motionAxisState.zValuePos.set(x, y + BTN_HEIGHT + 2);
       drawAxisValue(Z_AXIS);
     #endif
@@ -1120,7 +1120,7 @@ void MarlinUI::move_axis_screen() {
       TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
     }
 
-    // aligned with x+
+    // Aligned with x+
     drawBtn(xplus_x, TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
 
     TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));

commit c3694f1c038fa20ad749118b0a1c7aa88e3dd5f2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 14 17:24:50 2023 -0500

    üé® Lowercase methods, functions, data members (#25939)
    
    For: TFT, DGUS, MarlinUI, Anycubic, JyersUI, CrealityUI

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index edf75dabbd..9b23577c46 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -118,27 +118,26 @@ void MarlinUI::draw_kill_screen() {
   tft.queue.sync();
 }
 
-void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
+void draw_heater_status(uint16_t x, uint16_t y, const int8_t heater) {
   MarlinImage image = imgHotEnd;
-  uint16_t Color;
   celsius_t currentTemperature, targetTemperature;
 
-  if (Heater >= 0) { // HotEnd
+  if (heater >= 0) { // HotEnd
     #if HAS_EXTRUDERS
-      currentTemperature = thermalManager.wholeDegHotend(Heater);
-      targetTemperature = thermalManager.degTargetHotend(Heater);
+      currentTemperature = thermalManager.wholeDegHotend(heater);
+      targetTemperature = thermalManager.degTargetHotend(heater);
     #else
       return;
     #endif
   }
   #if HAS_HEATED_BED
-    else if (Heater == H_BED) {
+    else if (heater == H_BED) {
       currentTemperature = thermalManager.wholeDegBed();
       targetTemperature = thermalManager.degTargetBed();
     }
   #endif
   #if HAS_TEMP_CHAMBER
-    else if (Heater == H_CHAMBER) {
+    else if (heater == H_CHAMBER) {
       currentTemperature = thermalManager.wholeDegChamber();
       #if HAS_HEATED_CHAMBER
         targetTemperature = thermalManager.degTargetChamber();
@@ -148,54 +147,54 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
     }
   #endif
   #if HAS_TEMP_COOLER
-    else if (Heater == H_COOLER) {
+    else if (heater == H_COOLER) {
       currentTemperature = thermalManager.wholeDegCooler();
       targetTemperature = TERN(HAS_COOLER, thermalManager.degTargetCooler(), ABSOLUTE_ZERO);
     }
   #endif
   else return;
 
-  TERN_(TOUCH_SCREEN, if (targetTemperature >= 0) touch.add_control(HEATER, x, y, 80, 120, Heater));
+  TERN_(TOUCH_SCREEN, if (targetTemperature >= 0) touch.add_control(HEATER, x, y, 80, 120, heater));
   tft.canvas(x, y, 80, 120);
   tft.set_background(COLOR_BACKGROUND);
 
-  Color = currentTemperature < 0 ? COLOR_INACTIVE : COLOR_COLD;
+  uint16_t color = currentTemperature < 0 ? COLOR_INACTIVE : COLOR_COLD;
 
-  if (Heater >= 0) { // HotEnd
-    if (currentTemperature >= 50) Color = COLOR_HOTEND;
+  if (heater >= 0) { // HotEnd
+    if (currentTemperature >= 50) color = COLOR_HOTEND;
   }
   #if HAS_HEATED_BED
-    else if (Heater == H_BED) {
-      if (currentTemperature >= 50) Color = COLOR_HEATED_BED;
+    else if (heater == H_BED) {
+      if (currentTemperature >= 50) color = COLOR_HEATED_BED;
       image = targetTemperature > 0 ? imgBedHeated : imgBed;
     }
   #endif
   #if HAS_TEMP_CHAMBER
-    else if (Heater == H_CHAMBER) {
-      if (currentTemperature >= 50) Color = COLOR_CHAMBER;
+    else if (heater == H_CHAMBER) {
+      if (currentTemperature >= 50) color = COLOR_CHAMBER;
       image = targetTemperature > 0 ? imgChamberHeated : imgChamber;
     }
   #endif
   #if HAS_TEMP_COOLER
-    else if (Heater == H_COOLER) {
-      if (currentTemperature <= 26) Color = COLOR_COLD;
-      if (currentTemperature > 26) Color = COLOR_RED;
+    else if (heater == H_COOLER) {
+      if (currentTemperature <= 26) color = COLOR_COLD;
+      if (currentTemperature > 26) color = COLOR_RED;
       image = targetTemperature > 26 ? imgCoolerHot : imgCooler;
     }
   #endif
 
-  tft.add_image(8, 28, image, Color);
+  tft.add_image(8, 28, image, color);
 
   tft_string.set(i16tostr3rj(currentTemperature));
   tft_string.add(LCD_STR_DEGREE);
   tft_string.trim();
-  tft.add_text(tft_string.center(80) + 2, 80 + tft_string.vcenter(FONT_LINE_HEIGHT), Color, tft_string);
+  tft.add_text(tft_string.center(80) + 2, 80 + tft_string.vcenter(FONT_LINE_HEIGHT), color, tft_string);
 
   if (targetTemperature >= 0) {
     tft_string.set(i16tostr3rj(targetTemperature));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.trim();
-    tft.add_text(tft_string.center(80) + 2, 6 + tft_string.vcenter(FONT_LINE_HEIGHT), Color, tft_string);
+    tft.add_text(tft_string.center(80) + 2, 6 + tft_string.vcenter(FONT_LINE_HEIGHT), color, tft_string);
   }
 }
 

commit 683916e17a6fe35c9726ad7e57e73c519fc96222
Author: Dmitry Plastinin <Uncellon@yandex.ru>
Date:   Thu Jun 8 07:14:34 2023 +0300

    üö∏ Portrait TS35 move axis screen (#25945)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 38a706ea1b..edf75dabbd 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -639,16 +639,17 @@ static void quick_feedback() {
 #define CUR_STEP_VALUE_WIDTH 104
 static void drawCurStepValue() {
   tft_string.set(ftostr52sp(motionAxisState.currentStepSize));
+  tft_string.trim();
   tft_string.add(F("mm"));
   tft.canvas(motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);
-  tft.add_text(tft_string.center(CUR_STEP_VALUE_WIDTH), 0, COLOR_AXIS_HOMED, tft_string);
+  tft.add_text(0, 0, COLOR_AXIS_HOMED, tft_string);
 }
 
 #if HAS_Z_AXIS
   static void drawCurZSelection() {
     tft_string.set('Z');
-    tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y, tft_string.width(), 34);
+    tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y, tft_string.width(), FONT_LINE_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
 
@@ -669,13 +670,17 @@ static void drawCurStepValue() {
     tft.canvas(motionAxisState.eNamePos.x, motionAxisState.eNamePos.y, BTN_WIDTH, BTN_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set('E');
-    tft.add_text(0, 0, E_BTN_COLOR , tft_string);
-    tft.add_text(tft_string.width(), 0, E_BTN_COLOR, ui8tostr3rj(motionAxisState.e_selection));
+    tft_string.add(utostr3(motionAxisState.e_selection));
+    tft.add_text(tft_string.center(BTN_WIDTH), 0, E_BTN_COLOR, tft_string);
   }
 #endif
 
 static void drawMessage(PGM_P const msg) {
-  tft.canvas(X_MARGIN, TFT_HEIGHT - Y_MARGIN - Y_OFFSET, TFT_HEIGHT / 2, Y_OFFSET);
+  #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+    tft.canvas(X_MARGIN, TFT_HEIGHT - 2 * MOVE_AXIS_MARGIN_SIZE - BTN_HEIGHT - FONT_LINE_HEIGHT, TFT_WIDTH - X_MARGIN * 2, FONT_LINE_HEIGHT);
+  #else
+    tft.canvas(X_MARGIN, TFT_HEIGHT - Y_MARGIN - Y_OFFSET, TFT_HEIGHT / 2, Y_OFFSET);
+  #endif
   tft.set_background(COLOR_BACKGROUND);
   tft.add_text(0, 0, COLOR_YELLOW, msg);
 }
@@ -707,7 +712,8 @@ static void drawAxisValue(const AxisEnum axis) {
   tft.canvas(pos.x, pos.y, BTN_WIDTH + X_MARGIN, BTN_HEIGHT TERN_(HAS_UI_480x272, / 2));
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(ftostr52sp(value));
-  tft.add_text(0, 0, color, tft_string);
+  tft_string.trim();
+  tft.add_text(tft_string.center(BTN_WIDTH + X_MARGIN), 0, color, tft_string);
 }
 
 static void moveAxis(const AxisEnum axis, const int8_t direction) {
@@ -898,108 +904,229 @@ void MarlinUI::move_axis_screen() {
     if (busy) motionAxisState.z_selection = Z_SELECTION_Z_PROBE;
   #endif
 
-  // ROW 1 -> E+ Y+ CurY Z+
-  int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
+  #if ENABLED(TFT_COLOR_UI_PORTRAIT)
 
-  TERN_(HAS_EXTRUDERS, drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy));
+    int y = MOVE_AXIS_MARGIN_SIZE;
 
-  spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
-  x += BTN_WIDTH + spacing;
+    /**************************************************************************
+     * 1st: | Button "E+" | Button "Y+" | Button "Z+" |
+     *************************************************************************/
 
-  TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy));
+    TERN_(HAS_EXTRUDERS, drawBtn(TFT_WIDTH / 6     - BTN_WIDTH / 2, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy));
+    TERN_(HAS_Y_AXIS,    drawBtn(TFT_WIDTH / 2     - BTN_WIDTH / 2, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy));
+    TERN_(HAS_Z_AXIS,    drawBtn(TFT_WIDTH * 5 / 6 - BTN_WIDTH / 2, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)));
 
-  x += BTN_WIDTH;
+    y += BTN_HEIGHT + 4;
 
-  // Cur Y
-  #if HAS_Y_AXIS
-    motionAxisState.yValuePos.set(x + 2, y);
-    drawAxisValue(Y_AXIS);
-  #endif
+    /**************************************************************************
+     * 2nd: | Label "Ex" (E0, E1, etc.) | Y value | Label "Z" |
+     *************************************************************************/
 
-  x += spacing;
-  #if HAS_Z_AXIS
-    drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
-  #endif
+    // Label "Ex" (E0, E1, etc.)
+    #if HAS_EXTRUDERS
+      motionAxisState.eNamePos.set(TFT_WIDTH / 6 - BTN_WIDTH / 2, y);
+      drawCurESelection();
+      #if ENABLED(TOUCH_SCREEN)
+        if (!busy) touch.add_control(BUTTON, motionAxisState.eNamePos.x, motionAxisState.eNamePos.y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select);
+      #endif
+    #endif
 
-  // ROW 2 -> "Ex"  X-  HOME X+  "Z"
-  y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
-  x = X_MARGIN;
-  spacing = (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4;
+    // Y value
+    #if HAS_Y_AXIS
+      motionAxisState.yValuePos.set(TFT_WIDTH / 2 - (BTN_WIDTH + X_MARGIN) / 2, y);
+      drawAxisValue(Y_AXIS);
+    #endif
 
-  #if HAS_EXTRUDERS
-    motionAxisState.eNamePos.set(x, y);
-    drawCurESelection();
-    TERN_(TOUCH_SCREEN, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
-  #endif
+    // Label "Z"
+    #ifdef HAS_Z_AXIS
+      motionAxisState.zTypePos.set(TFT_WIDTH * 5 / 6 - BTN_WIDTH / 2, y);
+      drawCurZSelection();
+      #if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
+        if (!busy) touch.add_control(BUTTON, motionAxisState.zTypePos.x, motionAxisState.zTypePos.y, BTN_WIDTH, FONT_LINE_HEIGHT * 2, (intptr_t)z_select);
+      #endif
+    #endif
 
-  x += BTN_WIDTH + spacing;
+    y += BTN_HEIGHT + MOVE_AXIS_MARGIN_SIZE;
 
-  TERN_(HAS_X_AXIS, drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy));
+    /**************************************************************************
+     * 3rd: | Button "X-" | Button "Homing" | Button "X+" |
+     *************************************************************************/
 
-  x += BTN_WIDTH + spacing; //imgHome is 64x64
+    #if HAS_X_AXIS
+      drawBtn(TFT_WIDTH / 6 - BTN_WIDTH / 2, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
+      TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
+      drawBtn(TFT_WIDTH * 5 / 6 - BTN_WIDTH / 2, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
+    #endif
 
-  #if ALL(HAS_X_AXIS, TOUCH_SCREEN)
-    add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy);
-  #endif
+    y += BTN_HEIGHT + 4;
 
-  x += BTN_WIDTH + spacing;
-  uint16_t xplus_x = x;
+    /**************************************************************************
+     * 4th: | X value |
+     *************************************************************************/
 
-  TERN_(HAS_X_AXIS, drawBtn(x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy));
+    #ifdef HAS_X_AXIS
+      motionAxisState.xValuePos.set(TFT_WIDTH / 6 - (BTN_WIDTH + X_MARGIN) / 2, y);
+      drawAxisValue(X_AXIS);
+    #endif
 
-  x += BTN_WIDTH + spacing;
+    y += BTN_HEIGHT + MOVE_AXIS_MARGIN_SIZE;
 
-  #if HAS_Z_AXIS
-    motionAxisState.zTypePos.set(x, y);
-    drawCurZSelection();
-    #if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
-      if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, Y_OFFSET * 2, (intptr_t)z_select);
+    /**************************************************************************
+     * 5th: | Button "E-" | Button "Y-" | Button "Z-"
+     *************************************************************************/
+
+    TERN_(HAS_EXTRUDERS, drawBtn(TFT_WIDTH / 6 - BTN_WIDTH / 2, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy));
+    TERN_(HAS_Y_AXIS, drawBtn(TFT_WIDTH / 2 - BTN_WIDTH / 2, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy));
+    TERN_(HAS_Z_AXIS, drawBtn(TFT_WIDTH * 5 / 6 - BTN_WIDTH / 2, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)));
+
+    y += BTN_HEIGHT + 4;
+
+    /**************************************************************************
+     * 6th: | Current Ex value | Z value |
+     *************************************************************************/
+
+    // Current Ex value
+    #ifdef HAS_EXTRUDERS
+      motionAxisState.eValuePos.set(TFT_WIDTH / 6 - (BTN_WIDTH + X_MARGIN) / 2, y);
+      drawAxisValue(E_AXIS);
     #endif
-  #endif
 
-  // ROW 3 -> E- CurX Y-  Z-
-  y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
-  x = X_MARGIN;
-  spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
+    #ifdef HAS_Z_AXIS
+      motionAxisState.zValuePos.set(TFT_WIDTH * 5 / 6 - (BTN_WIDTH + X_MARGIN) / 2, y);
+      drawAxisValue(Z_AXIS);
+    #endif
 
-  #if HAS_EXTRUDERS
-    drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
-    motionAxisState.eValuePos.set(x, y + BTN_HEIGHT + 2);
-    drawAxisValue(E_AXIS);
-  #endif
+    y += BTN_HEIGHT + MOVE_AXIS_MARGIN_SIZE;
 
-  #if HAS_X_AXIS
-    motionAxisState.xValuePos.set(BTN_WIDTH + (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4, y - 10);
-    TERN_(HAS_X_AXIS, drawAxisValue(X_AXIS));
-  #endif
+    /**************************************************************************
+     * 7th: | Message - drawMessage(...) function |
+     *************************************************************************/
 
-  x += BTN_WIDTH + spacing;
-  TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy));
+    y += FONT_LINE_HEIGHT + MOVE_AXIS_MARGIN_SIZE;
 
-  x += BTN_WIDTH + spacing;
-  #if HAS_Z_AXIS
-    drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
-  #endif
+    /**************************************************************************
+     * 8th: | Step size | Button "Disable steppers" | Button "Back" |
+     *************************************************************************/
 
-  // Cur Z
-  #if HAS_Z_AXIS
-    motionAxisState.zValuePos.set(x, y + BTN_HEIGHT + 2);
-    drawAxisValue(Z_AXIS);
-  #endif
+    // Step size
+    motionAxisState.stepValuePos.set(X_MARGIN, y + 12);
+    if (!busy) {
+      drawCurStepValue();
+      TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y + 12, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
+    }
 
-  // ROW 4 -> step_size  disable steppers back
-  y = TFT_HEIGHT - Y_MARGIN - TERN(HAS_UI_480x272, BTN_WIDTH / 2, 32);
-  x = TFT_WIDTH / 2 - CUR_STEP_VALUE_WIDTH / 2;
-  motionAxisState.stepValuePos.set(x, y);
-  if (!busy) {
-    drawCurStepValue();
-    TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
-  }
+    // Button "Disable steppers"
+    drawBtn(TFT_WIDTH / 2, y, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
+
+    // Button "Back"
+    TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH * 5 / 6 - Images[imgBack].width / 2, y + 12, BACK, imgBack));
+
+  #else // !TFT_COLOR_UI_PORTRAIT
+
+    // ROW 1 -> E- Y- CurY Z+
+    int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
+
+    TERN_(HAS_EXTRUDERS, drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy));
+
+    spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
+    x += BTN_WIDTH + spacing;
+
+    TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy));
+
+    x += BTN_WIDTH;
+
+    // Cur Y
+    #if HAS_Y_AXIS
+      motionAxisState.yValuePos.set(x + 2, y);
+      drawAxisValue(Y_AXIS);
+    #endif
+
+    x += spacing;
+    #if HAS_Z_AXIS
+      drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+    #endif
+
+    // ROW 2 -> "Ex"  X-  HOME X+  "Z"
+    y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
+    x = X_MARGIN;
+    spacing = (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4;
+
+    #if HAS_EXTRUDERS
+      motionAxisState.eNamePos.set(x, y);
+      drawCurESelection();
+      TERN_(TOUCH_SCREEN, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
+    #endif
+
+    x += BTN_WIDTH + spacing;
+
+    TERN_(HAS_X_AXIS, drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy));
+
+    x += BTN_WIDTH + spacing; //imgHome is 64x64
+
+    #if ALL(HAS_X_AXIS, TOUCH_SCREEN)
+      add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy);
+    #endif
+
+    x += BTN_WIDTH + spacing;
+    uint16_t xplus_x = x;
+
+    TERN_(HAS_X_AXIS, drawBtn(x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy));
+
+    x += BTN_WIDTH + spacing;
+
+    #if HAS_Z_AXIS
+      motionAxisState.zTypePos.set(x, y);
+      drawCurZSelection();
+      #if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
+        if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, Y_OFFSET * 2, (intptr_t)z_select);
+      #endif
+    #endif
+
+    // ROW 3 -> E- CurX Y-  Z-
+    y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
+    x = X_MARGIN;
+    spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
+
+    #if HAS_EXTRUDERS
+      drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
+      motionAxisState.eValuePos.set(x, y + BTN_HEIGHT + 2);
+      drawAxisValue(E_AXIS);
+    #endif
+
+    #if HAS_X_AXIS
+      motionAxisState.xValuePos.set(BTN_WIDTH + (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4, y - 10);
+      TERN_(HAS_X_AXIS, drawAxisValue(X_AXIS));
+    #endif
+
+    x += BTN_WIDTH + spacing;
+    TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy));
+
+    x += BTN_WIDTH + spacing;
+    #if HAS_Z_AXIS
+      drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+    #endif
+
+    // Cur Z
+    #if HAS_Z_AXIS
+      motionAxisState.zValuePos.set(x, y + BTN_HEIGHT + 2);
+      drawAxisValue(Z_AXIS);
+    #endif
+
+    // ROW 4 -> step_size  disable steppers back
+    y = TFT_HEIGHT - Y_MARGIN - TERN(HAS_UI_480x272, BTN_WIDTH / 2, 32);
+    x = TFT_WIDTH / 2 - CUR_STEP_VALUE_WIDTH / 2;
+    motionAxisState.stepValuePos.set(x, y);
+    if (!busy) {
+      drawCurStepValue();
+      TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
+    }
+
+    // aligned with x+
+    drawBtn(xplus_x, TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
 
-  // aligned with x+
-  drawBtn(xplus_x, TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
+    TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));
 
-  TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));
+  #endif // !TFT_COLOR_UI_PORTRAIT
 }
 
 #endif // HAS_UI_480x320 || HAS_UI_480x272

commit 9360e13cdd1e21799eb3aedcd23015469da6798d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 7 22:37:16 2023 -0500

    üö∏ General TFT cleanup

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 2a6f50c93b..38a706ea1b 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -195,7 +195,7 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
     tft_string.set(i16tostr3rj(targetTemperature));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.trim();
-    tft.add_text(tft_string.center(80) + 2, 6 + tft_string.vcenter(FONT_LINE_HEIGHT) , Color, tft_string);
+    tft.add_text(tft_string.center(80) + 2, 6 + tft_string.vcenter(FONT_LINE_HEIGHT), Color, tft_string);
   }
 }
 
@@ -265,7 +265,7 @@ void MarlinUI::draw_status_screen() {
 
   if (TERN0(LCD_SHOW_E_TOTAL, printingIsActive())) {
     #if ENABLED(LCD_SHOW_E_TOTAL)
-      tft.add_text( 16, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "E");
+      tft.add_text( 16, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "E");
       const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
       tft_string.set(ftostr4sign(e_move_accumulator / escale));
       tft_string.add(escale == 10 ? 'c' : 'm');
@@ -322,7 +322,7 @@ void MarlinUI::draw_status_screen() {
   tft.canvas(x, y, component_width, 32);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_image(0, 0, imgFeedRate, color);
-  tft.add_text(36, tft_string.vcenter(30), color , tft_string);
+  tft.add_text(36, tft_string.vcenter(30), color, tft_string);
   TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE, x, y, component_width, 32));
 
   #if HAS_EXTRUDERS
@@ -337,7 +337,7 @@ void MarlinUI::draw_status_screen() {
     tft.canvas(x, y, component_width, 32);
     tft.set_background(COLOR_BACKGROUND);
     tft.add_image(0, 0, imgFlowRate, color);
-    tft.add_text(36, tft_string.vcenter(30), color , tft_string);
+    tft.add_text(36, tft_string.vcenter(30), color, tft_string);
     TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE, x, y, component_width, 32, active_extruder));
   #endif
 
@@ -495,7 +495,7 @@ void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, con
     #if ENABLED(TOUCH_SCREEN)
       touch.clear();
       draw_menu_navigation = false;
-      touch.add_control(RESUME_CONTINUE , 0, 0, TFT_WIDTH, TFT_HEIGHT);
+      touch.add_control(RESUME_CONTINUE, 0, 0, TFT_WIDTH, TFT_HEIGHT);
     #endif
 
     menu_line(row);
@@ -651,12 +651,16 @@ static void drawCurStepValue() {
     tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y, tft_string.width(), 34);
     tft.set_background(COLOR_BACKGROUND);
     tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
+
     tft.queue.sync();
+
     tft_string.set(F("Offset"));
     tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y + Y_OFFSET, tft_string.width(), Y_OFFSET TERN_(HAS_UI_480x272, - 10));
     tft.set_background(COLOR_BACKGROUND);
-    if (motionAxisState.z_selection == Z_SELECTION_Z_PROBE)
-      tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
+    #if HAS_BED_PROBE
+      if (motionAxisState.z_selection == Z_SELECTION_Z_PROBE)
+        tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
+    #endif
   }
 #endif
 
@@ -718,7 +722,8 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
 
   const float diff = motionAxisState.currentStepSize * direction;
 
-  #if HAS_Z_AXIS
+  #if HAS_BED_PROBE
+
     if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
       #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
         const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
@@ -738,10 +743,10 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
           drawMessage(NUL_STR); // clear the error
           drawAxisValue(axis);
         }
-        else {
+        else
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
-        }
-      #elif HAS_BED_PROBE
+
+      #else
         // only change probe.offset.z
         probe.offset.z += diff;
         if (direction < 0 && current_position[axis] < Z_PROBE_OFFSET_RANGE_MIN) {
@@ -752,14 +757,15 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
           current_position[axis] = Z_PROBE_OFFSET_RANGE_MAX;
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
         }
-        else {
+        else
           drawMessage(NUL_STR); // clear the error
-        }
+
         drawAxisValue(axis);
       #endif
       return;
     }
-  #endif // HAS_Z_AXIS
+
+  #endif // HAS_BED_PROBE
 
   if (!ui.manual_move.processing) {
     // Get motion limit from software endstops, if any
@@ -853,8 +859,8 @@ static void disable_steppers() {
 }
 
 static void drawBtn(int x, int y, const char *label, intptr_t data, MarlinImage img, uint16_t bgColor, bool enabled = true) {
-  uint16_t width = Images[imgBtn52Rounded].width,
-           height = Images[imgBtn52Rounded].height;
+  const uint16_t width = Images[imgBtn52Rounded].width,
+                height = Images[imgBtn52Rounded].height;
 
   if (!enabled) bgColor = COLOR_CONTROL_DISABLED;
 
@@ -888,9 +894,9 @@ void MarlinUI::move_axis_screen() {
   const bool busy = printingIsActive();
 
   // Babysteps during printing? Select babystep for Z probe offset
-  if (busy && ENABLED(BABYSTEP_ZPROBE_OFFSET))
-
-    TERN_(HAS_Z_AXIS, motionAxisState.z_selection = Z_SELECTION_Z_PROBE);
+  #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+    if (busy) motionAxisState.z_selection = Z_SELECTION_Z_PROBE;
+  #endif
 
   // ROW 1 -> E+ Y+ CurY Z+
   int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
@@ -902,11 +908,11 @@ void MarlinUI::move_axis_screen() {
 
   TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy));
 
-  // Cur Y
   x += BTN_WIDTH;
+
+  // Cur Y
   #if HAS_Y_AXIS
-    motionAxisState.yValuePos.x = x + 2;
-    motionAxisState.yValuePos.y = y;
+    motionAxisState.yValuePos.set(x + 2, y);
     drawAxisValue(Y_AXIS);
   #endif
 
@@ -920,29 +926,35 @@ void MarlinUI::move_axis_screen() {
   x = X_MARGIN;
   spacing = (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4;
 
-  motionAxisState.eNamePos.x = x;
-  motionAxisState.eNamePos.y = y;
   #if HAS_EXTRUDERS
+    motionAxisState.eNamePos.set(x, y);
     drawCurESelection();
     TERN_(TOUCH_SCREEN, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
   #endif
 
   x += BTN_WIDTH + spacing;
-  drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
+
+  TERN_(HAS_X_AXIS, drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy));
 
   x += BTN_WIDTH + spacing; //imgHome is 64x64
-  TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
+
+  #if ALL(HAS_X_AXIS, TOUCH_SCREEN)
+    add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy);
+  #endif
 
   x += BTN_WIDTH + spacing;
   uint16_t xplus_x = x;
-  drawBtn(x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
+
+  TERN_(HAS_X_AXIS, drawBtn(x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy));
 
   x += BTN_WIDTH + spacing;
-  motionAxisState.zTypePos.x = x;
-  motionAxisState.zTypePos.y = y;
-  TERN_(HAS_Z_AXIS, drawCurZSelection());
-  #if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
-    if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, Y_OFFSET * 2, (intptr_t)z_select);
+
+  #if HAS_Z_AXIS
+    motionAxisState.zTypePos.set(x, y);
+    drawCurZSelection();
+    #if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
+      if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, Y_OFFSET * 2, (intptr_t)z_select);
+    #endif
   #endif
 
   // ROW 3 -> E- CurX Y-  Z-
@@ -950,20 +962,19 @@ void MarlinUI::move_axis_screen() {
   x = X_MARGIN;
   spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
 
-  TERN_(HAS_EXTRUDERS, drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy));
-
-  // Cur E
-  motionAxisState.eValuePos.x = x;
-  motionAxisState.eValuePos.y = y + BTN_HEIGHT + 2;
-  TERN_(HAS_EXTRUDERS, drawAxisValue(E_AXIS));
+  #if HAS_EXTRUDERS
+    drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
+    motionAxisState.eValuePos.set(x, y + BTN_HEIGHT + 2);
+    drawAxisValue(E_AXIS);
+  #endif
 
-  // Cur X
-  motionAxisState.xValuePos.x = BTN_WIDTH + (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4; //X- pos
-  motionAxisState.xValuePos.y = y - 10;
-  TERN_(HAS_X_AXIS, drawAxisValue(X_AXIS));
+  #if HAS_X_AXIS
+    motionAxisState.xValuePos.set(BTN_WIDTH + (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4, y - 10);
+    TERN_(HAS_X_AXIS, drawAxisValue(X_AXIS));
+  #endif
 
   x += BTN_WIDTH + spacing;
-  drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy);
+  TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy));
 
   x += BTN_WIDTH + spacing;
   #if HAS_Z_AXIS
@@ -971,15 +982,15 @@ void MarlinUI::move_axis_screen() {
   #endif
 
   // Cur Z
-  motionAxisState.zValuePos.x = x;
-  motionAxisState.zValuePos.y = y + BTN_HEIGHT + 2;
-  TERN_(HAS_Z_AXIS, drawAxisValue(Z_AXIS));
+  #if HAS_Z_AXIS
+    motionAxisState.zValuePos.set(x, y + BTN_HEIGHT + 2);
+    drawAxisValue(Z_AXIS);
+  #endif
 
   // ROW 4 -> step_size  disable steppers back
   y = TFT_HEIGHT - Y_MARGIN - TERN(HAS_UI_480x272, BTN_WIDTH / 2, 32);
   x = TFT_WIDTH / 2 - CUR_STEP_VALUE_WIDTH / 2;
-  motionAxisState.stepValuePos.x = x;
-  motionAxisState.stepValuePos.y = y;
+  motionAxisState.stepValuePos.set(x, y);
   if (!busy) {
     drawCurStepValue();
     TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));

commit 54a82b4337a5e65e53ef8b28749546c18d05ba79
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 7 20:58:55 2023 -0500

    üö∏ Fix TFT menu positioning (#25942)
    
    Co-authored-by: Ed <751406+helakejr@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 75ec50adc2..2a6f50c93b 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -623,6 +623,7 @@ struct {
 #define BTN_HEIGHT 52
 #define X_MARGIN 20
 #define Y_MARGIN 15
+#define Y_OFFSET TERN(HAS_UI_480x272, 28, 34)
 
 static void quick_feedback() {
   #if HAS_CHIRP
@@ -652,7 +653,7 @@ static void drawCurStepValue() {
     tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
     tft.queue.sync();
     tft_string.set(F("Offset"));
-    tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y + 34, tft_string.width(), 34);
+    tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y + Y_OFFSET, tft_string.width(), Y_OFFSET TERN_(HAS_UI_480x272, - 10));
     tft.set_background(COLOR_BACKGROUND);
     if (motionAxisState.z_selection == Z_SELECTION_Z_PROBE)
       tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
@@ -670,7 +671,7 @@ static void drawCurStepValue() {
 #endif
 
 static void drawMessage(PGM_P const msg) {
-  tft.canvas(X_MARGIN, TFT_HEIGHT - Y_MARGIN - 34, TFT_HEIGHT / 2, 34);
+  tft.canvas(X_MARGIN, TFT_HEIGHT - Y_MARGIN - Y_OFFSET, TFT_HEIGHT / 2, Y_OFFSET);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_text(0, 0, COLOR_YELLOW, msg);
 }
@@ -699,7 +700,7 @@ static void drawAxisValue(const AxisEnum axis) {
     #endif
     default: return;
   }
-  tft.canvas(pos.x, pos.y, BTN_WIDTH + X_MARGIN, BTN_HEIGHT);
+  tft.canvas(pos.x, pos.y, BTN_WIDTH + X_MARGIN, BTN_HEIGHT TERN_(HAS_UI_480x272, / 2));
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(ftostr52sp(value));
   tft.add_text(0, 0, color, tft_string);
@@ -891,7 +892,7 @@ void MarlinUI::move_axis_screen() {
 
     TERN_(HAS_Z_AXIS, motionAxisState.z_selection = Z_SELECTION_Z_PROBE);
 
-  // ROW 1 -> E- Y- CurY Z+
+  // ROW 1 -> E+ Y+ CurY Z+
   int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
 
   TERN_(HAS_EXTRUDERS, drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy));
@@ -941,7 +942,7 @@ void MarlinUI::move_axis_screen() {
   motionAxisState.zTypePos.y = y;
   TERN_(HAS_Z_AXIS, drawCurZSelection());
   #if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
-    if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
+    if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, Y_OFFSET * 2, (intptr_t)z_select);
   #endif
 
   // ROW 3 -> E- CurX Y-  Z-
@@ -975,7 +976,7 @@ void MarlinUI::move_axis_screen() {
   TERN_(HAS_Z_AXIS, drawAxisValue(Z_AXIS));
 
   // ROW 4 -> step_size  disable steppers back
-  y = TFT_HEIGHT - Y_MARGIN - 32;
+  y = TFT_HEIGHT - Y_MARGIN - TERN(HAS_UI_480x272, BTN_WIDTH / 2, 32);
   x = TFT_WIDTH / 2 - CUR_STEP_VALUE_WIDTH / 2;
   motionAxisState.stepValuePos.x = x;
   motionAxisState.stepValuePos.y = y;
@@ -990,4 +991,4 @@ void MarlinUI::move_axis_screen() {
   TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));
 }
 
-#endif // HAS_UI_480x320
+#endif // HAS_UI_480x320 || HAS_UI_480x272

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index e1ddfe5e1a..75ec50adc2 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -36,7 +36,7 @@
 #include "../../module/planner.h"
 #include "../../module/motion.h"
 
-#if DISABLED(LCD_PROGRESS_BAR) && BOTH(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
+#if DISABLED(LCD_PROGRESS_BAR) && ALL(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
   #include "../../feature/filwidth.h"
   #include "../../gcode/parser.h"
 #endif
@@ -627,7 +627,7 @@ struct {
 static void quick_feedback() {
   #if HAS_CHIRP
     ui.chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
-    #if BOTH(HAS_MARLINUI_MENU, HAS_BEEPER)
+    #if ALL(HAS_MARLINUI_MENU, HAS_BEEPER)
       for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
     #elif HAS_MARLINUI_MENU
       delay(10);
@@ -837,7 +837,7 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
   }
 #endif // TOUCH_SCREEN
 
-#if BOTH(HAS_BED_PROBE, TOUCH_SCREEN)
+#if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
   static void z_select() {
     motionAxisState.z_selection *= -1;
     quick_feedback();
@@ -940,7 +940,7 @@ void MarlinUI::move_axis_screen() {
   motionAxisState.zTypePos.x = x;
   motionAxisState.zTypePos.y = y;
   TERN_(HAS_Z_AXIS, drawCurZSelection());
-  #if BOTH(HAS_BED_PROBE, TOUCH_SCREEN)
+  #if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
     if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
   #endif
 

commit d5fdbb89ea55a19815c6997d47f1268a96d2cac9
Author: Alexey D. Filimonov <alexey@filimonic.net>
Date:   Sun May 14 00:25:36 2023 +0300

    üö∏ TFT optional axes/extruder (#25624)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index bc4ea0e5e2..e1ddfe5e1a 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -124,8 +124,12 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
   celsius_t currentTemperature, targetTemperature;
 
   if (Heater >= 0) { // HotEnd
-    currentTemperature = thermalManager.wholeDegHotend(Heater);
-    targetTemperature = thermalManager.degTargetHotend(Heater);
+    #if HAS_EXTRUDERS
+      currentTemperature = thermalManager.wholeDegHotend(Heater);
+      targetTemperature = thermalManager.degTargetHotend(Heater);
+    #else
+      return;
+    #endif
   }
   #if HAS_HEATED_BED
     else if (Heater == H_BED) {
@@ -271,31 +275,37 @@ void MarlinUI::draw_status_screen() {
   }
   else {
     // Coords in mask "X____Y____Z____"
-    tft_string.set("X");
-    tft.add_text(coords_width / 30 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
-
-    const bool nhx = axis_should_home(X_AXIS);
-    tft_string.set(blink && nhx ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
-    tft_string.ltrim();
-    tft.add_text(coords_width / 5 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+    #if HAS_X_AXIS
+      tft_string.set("X");
+      tft.add_text(coords_width / 30 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
+
+      const bool nhx = axis_should_home(X_AXIS);
+      tft_string.set(blink && nhx ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
+      tft_string.ltrim();
+      tft.add_text(coords_width / 5 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+    #endif
 
-    tft_string.set("Y");
-    tft.add_text(11 * coords_width / 30 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
+    #if HAS_Y_AXIS
+      tft_string.set("Y");
+      tft.add_text(11 * coords_width / 30 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
 
-    const bool nhy = axis_should_home(Y_AXIS);
-    tft_string.set(blink && nhy ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
-    tft_string.ltrim();
-    tft.add_text(8 * coords_width / 15 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+      const bool nhy = axis_should_home(Y_AXIS);
+      tft_string.set(blink && nhy ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
+      tft_string.ltrim();
+      tft.add_text(8 * coords_width / 15 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+    #endif
   }
 
-  tft_string.set("Z");
-  tft.add_text(7 * coords_width / 10 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
+  #if HAS_Z_AXIS
+    tft_string.set("Z");
+    tft.add_text(7 * coords_width / 10 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
 
-  const bool nhz = axis_should_home(Z_AXIS);
-  tft_string.set(blink && nhz ? "?" : ftostr52sp(LOGICAL_Z_POSITION(current_position.z)));
-  tft_string.ltrim();
-  tft_string.rtrim();
-  tft.add_text(13 * coords_width / 15 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+    const bool nhz = axis_should_home(Z_AXIS);
+    tft_string.set(blink && nhz ? "?" : ftostr52sp(LOGICAL_Z_POSITION(current_position.z)));
+    tft_string.ltrim();
+    tft_string.rtrim();
+    tft.add_text(13 * coords_width / 15 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+  #endif
 
   TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 4, y, TFT_WIDTH - 8, FONT_LINE_HEIGHT));
 
@@ -315,19 +325,21 @@ void MarlinUI::draw_status_screen() {
   tft.add_text(36, tft_string.vcenter(30), color , tft_string);
   TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE, x, y, component_width, 32));
 
-  // Flow rate (preparing)
-  tft_string.set(i16tostr3rj(planner.flow_percentage[active_extruder]));
-  tft_string.add('%');
-  component_width = 36 + tft_string.width();
-  color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
-  x = FLOWRATE_X(component_width);
+  #if HAS_EXTRUDERS
+    // Flow rate (preparing)
+    tft_string.set(i16tostr3rj(planner.flow_percentage[active_extruder]));
+    tft_string.add('%');
+    component_width = 36 + tft_string.width();
+    color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
+    x = FLOWRATE_X(component_width);
 
-  // Flow rate (drawing)
-  tft.canvas(x, y, component_width, 32);
-  tft.set_background(COLOR_BACKGROUND);
-  tft.add_image(0, 0, imgFlowRate, color);
-  tft.add_text(36, tft_string.vcenter(30), color , tft_string);
-  TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE, x, y, component_width, 32, active_extruder));
+    // Flow rate (drawing)
+    tft.canvas(x, y, component_width, 32);
+    tft.set_background(COLOR_BACKGROUND);
+    tft.add_image(0, 0, imgFlowRate, color);
+    tft.add_text(36, tft_string.vcenter(30), color , tft_string);
+    TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE, x, y, component_width, 32, active_extruder));
+  #endif
 
   #if TFT_COLOR_UI_PORTRAIT || DISABLED(TOUCH_SCREEN)
     y += STATUS_MARGIN_SIZE + 32;
@@ -586,16 +598,26 @@ void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, con
 #define Z_SELECTION_Z 1
 #define Z_SELECTION_Z_PROBE -1
 
-struct MotionAxisState {
-  xy_int_t xValuePos, yValuePos, zValuePos, eValuePos, stepValuePos, zTypePos, eNamePos;
+struct {
+  #if HAS_X_AXIS
+    xy_int_t xValuePos;
+  #endif
+  #if HAS_Y_AXIS
+    xy_int_t yValuePos;
+  #endif
+  #if HAS_Z_AXIS
+    xy_int_t zValuePos, zTypePos;
+    int z_selection = Z_SELECTION_Z;
+  #endif
+  #if HAS_EXTRUDERS
+    xy_int_t eValuePos, eNamePos;
+    uint8_t e_selection = 0;
+  #endif
+  xy_int_t stepValuePos;
   float currentStepSize = 10.0;
-  int z_selection = Z_SELECTION_Z;
-  uint8_t e_selection = 0;
   bool blocked = false;
   char message[32];
-};
-
-MotionAxisState motionAxisState;
+} motionAxisState;
 
 #define BTN_WIDTH 64
 #define BTN_HEIGHT 52
@@ -622,27 +644,30 @@ static void drawCurStepValue() {
   tft.add_text(tft_string.center(CUR_STEP_VALUE_WIDTH), 0, COLOR_AXIS_HOMED, tft_string);
 }
 
-static void drawCurZSelection() {
-  tft_string.set('Z');
-  tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y, tft_string.width(), 34);
-  tft.set_background(COLOR_BACKGROUND);
-  tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
-  tft.queue.sync();
-  tft_string.set(F("Offset"));
-  tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y + 34, tft_string.width(), 34);
-  tft.set_background(COLOR_BACKGROUND);
-  if (motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
+#if HAS_Z_AXIS
+  static void drawCurZSelection() {
+    tft_string.set('Z');
+    tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y, tft_string.width(), 34);
+    tft.set_background(COLOR_BACKGROUND);
     tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
+    tft.queue.sync();
+    tft_string.set(F("Offset"));
+    tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y + 34, tft_string.width(), 34);
+    tft.set_background(COLOR_BACKGROUND);
+    if (motionAxisState.z_selection == Z_SELECTION_Z_PROBE)
+      tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
   }
-}
+#endif
 
-static void drawCurESelection() {
-  tft.canvas(motionAxisState.eNamePos.x, motionAxisState.eNamePos.y, BTN_WIDTH, BTN_HEIGHT);
-  tft.set_background(COLOR_BACKGROUND);
-  tft_string.set('E');
-  tft.add_text(0, 0, E_BTN_COLOR , tft_string);
-  tft.add_text(tft_string.width(), 0, E_BTN_COLOR, ui8tostr3rj(motionAxisState.e_selection));
-}
+#if HAS_EXTRUDERS
+  static void drawCurESelection() {
+    tft.canvas(motionAxisState.eNamePos.x, motionAxisState.eNamePos.y, BTN_WIDTH, BTN_HEIGHT);
+    tft.set_background(COLOR_BACKGROUND);
+    tft_string.set('E');
+    tft.add_text(0, 0, E_BTN_COLOR , tft_string);
+    tft.add_text(tft_string.width(), 0, E_BTN_COLOR, ui8tostr3rj(motionAxisState.e_selection));
+  }
+#endif
 
 static void drawMessage(PGM_P const msg) {
   tft.canvas(X_MARGIN, TFT_HEIGHT - Y_MARGIN - 34, TFT_HEIGHT / 2, 34);
@@ -660,10 +685,18 @@ static void drawAxisValue(const AxisEnum axis) {
   xy_int_t pos;
   uint16_t color;
   switch (axis) {
-    case X_AXIS: pos = motionAxisState.xValuePos; color = X_BTN_COLOR; break;
-    case Y_AXIS: pos = motionAxisState.yValuePos; color = Y_BTN_COLOR; break;
-    case Z_AXIS: pos = motionAxisState.zValuePos; color = Z_BTN_COLOR; break;
-    case E_AXIS: pos = motionAxisState.eValuePos; color = E_BTN_COLOR; break;
+    #if HAS_X_AXIS
+      case X_AXIS: pos = motionAxisState.xValuePos; color = X_BTN_COLOR; break;
+    #endif
+    #if HAS_Y_AXIS
+      case Y_AXIS: pos = motionAxisState.yValuePos; color = Y_BTN_COLOR; break;
+    #endif
+    #if HAS_Z_AXIS
+      case Z_AXIS: pos = motionAxisState.zValuePos; color = Z_BTN_COLOR; break;
+    #endif
+    #if HAS_EXTRUDERS
+      case E_AXIS: pos = motionAxisState.eValuePos; color = E_BTN_COLOR; break;
+    #endif
     default: return;
   }
   tft.canvas(pos.x, pos.y, BTN_WIDTH + X_MARGIN, BTN_HEIGHT);
@@ -675,53 +708,57 @@ static void drawAxisValue(const AxisEnum axis) {
 static void moveAxis(const AxisEnum axis, const int8_t direction) {
   quick_feedback();
 
-  if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
-    drawMessage(F("Too cold"));
-    return;
-  }
+  #if HAS_EXTRUDERS
+    if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
+      drawMessage(F("Too cold"));
+      return;
+    }
+  #endif
 
   const float diff = motionAxisState.currentStepSize * direction;
 
-  if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
-    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-      const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
-      const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
-      const float bsDiff = planner.mm_per_step[Z_AXIS] * babystep_increment,
-                  new_probe_offset = probe.offset.z + bsDiff,
-                  new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
-                    , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff
-                    , new_probe_offset
-                  );
-      if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
-        babystep.add_steps(Z_AXIS, babystep_increment);
-        if (do_probe)
-          probe.offset.z = new_offs;
-        else
-          TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
-        drawMessage(NUL_STR); // clear the error
+  #if HAS_Z_AXIS
+    if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
+      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+        const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
+        const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
+        const float bsDiff = planner.mm_per_step[Z_AXIS] * babystep_increment,
+                    new_probe_offset = probe.offset.z + bsDiff,
+                    new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
+                      , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff
+                      , new_probe_offset
+                    );
+        if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
+          babystep.add_steps(Z_AXIS, babystep_increment);
+          if (do_probe)
+            probe.offset.z = new_offs;
+          else
+            TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
+          drawMessage(NUL_STR); // clear the error
+          drawAxisValue(axis);
+        }
+        else {
+          drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
+        }
+      #elif HAS_BED_PROBE
+        // only change probe.offset.z
+        probe.offset.z += diff;
+        if (direction < 0 && current_position[axis] < Z_PROBE_OFFSET_RANGE_MIN) {
+          current_position[axis] = Z_PROBE_OFFSET_RANGE_MIN;
+          drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
+        }
+        else if (direction > 0 && current_position[axis] > Z_PROBE_OFFSET_RANGE_MAX) {
+          current_position[axis] = Z_PROBE_OFFSET_RANGE_MAX;
+          drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
+        }
+        else {
+          drawMessage(NUL_STR); // clear the error
+        }
         drawAxisValue(axis);
-      }
-      else {
-        drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
-      }
-    #elif HAS_BED_PROBE
-      // only change probe.offset.z
-      probe.offset.z += diff;
-      if (direction < 0 && current_position[axis] < Z_PROBE_OFFSET_RANGE_MIN) {
-        current_position[axis] = Z_PROBE_OFFSET_RANGE_MIN;
-        drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
-      }
-      else if (direction > 0 && current_position[axis] > Z_PROBE_OFFSET_RANGE_MAX) {
-        current_position[axis] = Z_PROBE_OFFSET_RANGE_MAX;
-        drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
-      }
-      else {
-        drawMessage(NUL_STR); // clear the error
-      }
-      drawAxisValue(axis);
-    #endif
-    return;
-  }
+      #endif
+      return;
+    }
+  #endif // HAS_Z_AXIS
 
   if (!ui.manual_move.processing) {
     // Get motion limit from software endstops, if any
@@ -731,7 +768,7 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
     // Delta limits XY based on the current offset from center
     // This assumes the center is 0,0
     #if ENABLED(DELTA)
-      if (axis != Z_AXIS && axis != E_AXIS) {
+      if (axis != Z_AXIS && TERN1(HAS_EXTRUDERS, axis != E_AXIS)) {
         max = SQRT(sq(float(PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
         min = -max;
       }
@@ -752,35 +789,44 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
   drawAxisValue(axis);
 }
 
-static void e_plus()  { moveAxis(E_AXIS, 1);  }
-static void e_minus() { moveAxis(E_AXIS, -1); }
-static void x_minus() { moveAxis(X_AXIS, -1); }
-static void x_plus()  { moveAxis(X_AXIS, 1);  }
-static void y_plus()  { moveAxis(Y_AXIS, 1);  }
-static void y_minus() { moveAxis(Y_AXIS, -1); }
-static void z_plus()  { moveAxis(Z_AXIS, 1);  }
-static void z_minus() { moveAxis(Z_AXIS, -1); }
+#if HAS_EXTRUDERS
+  static void e_plus()  { moveAxis(E_AXIS, 1);  }
+  static void e_minus() { moveAxis(E_AXIS, -1); }
+#endif
+#if HAS_X_AXIS
+  static void x_minus() { moveAxis(X_AXIS, -1); }
+  static void x_plus()  { moveAxis(X_AXIS, 1);  }
+#endif
+#if HAS_Y_AXIS
+  static void y_plus()  { moveAxis(Y_AXIS, 1);  }
+  static void y_minus() { moveAxis(Y_AXIS, -1); }
+#endif
+#if HAS_Z_AXIS
+  static void z_plus()  { moveAxis(Z_AXIS, 1);  }
+  static void z_minus() { moveAxis(Z_AXIS, -1); }
+#endif
 
 #if ENABLED(TOUCH_SCREEN)
-  static void e_select() {
-    if (++motionAxisState.e_selection >= EXTRUDERS)
-      motionAxisState.e_selection = 0;
-
-    quick_feedback();
-    drawCurESelection();
-    drawAxisValue(E_AXIS);
-  }
+  #if HAS_EXTRUDERS
+    static void e_select() {
+      if (++motionAxisState.e_selection >= EXTRUDERS)
+        motionAxisState.e_selection = 0;
+      quick_feedback();
+      drawCurESelection();
+      drawAxisValue(E_AXIS);
+    }
+  #endif
 
   static void do_home() {
     quick_feedback();
     drawMessage(GET_TEXT_F(MSG_LEVEL_BED_HOMING));
     queue.inject_P(G28_STR);
     // Disable touch until home is done
-    TERN_(HAS_TFT_XPT2046, touch.disable());
-    drawAxisValue(E_AXIS);
-    drawAxisValue(X_AXIS);
-    drawAxisValue(Y_AXIS);
-    drawAxisValue(Z_AXIS);
+    touch.disable();
+    TERN_(HAS_EXTRUDERS, drawAxisValue(E_AXIS));
+    TERN_(HAS_X_AXIS, drawAxisValue(X_AXIS));
+    TERN_(HAS_Y_AXIS, drawAxisValue(Y_AXIS));
+    TERN_(HAS_Z_AXIS, drawAxisValue(Z_AXIS));
   }
 
   static void step_size() {
@@ -789,7 +835,7 @@ static void z_minus() { moveAxis(Z_AXIS, -1); }
     quick_feedback();
     drawCurStepValue();
   }
-#endif
+#endif // TOUCH_SCREEN
 
 #if BOTH(HAS_BED_PROBE, TOUCH_SCREEN)
   static void z_select() {
@@ -825,14 +871,14 @@ static void drawBtn(int x, int y, const char *label, intptr_t data, MarlinImage
     tft.add_image(0, 0, img, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
   }
 
-  TERN_(HAS_TFT_XPT2046, if (enabled) touch.add_control(BUTTON, x, y, width, height, data));
+  TERN_(TOUCH_SCREEN, if (enabled) touch.add_control(BUTTON, x, y, width, height, data));
 }
 
 void MarlinUI::move_axis_screen() {
   // Reset
   defer_status_screen(true);
   motionAxisState.blocked = false;
-  TERN_(HAS_TFT_XPT2046, touch.enable());
+  TERN_(TOUCH_SCREEN, touch.enable());
 
   ui.clear_lcd();
 
@@ -842,25 +888,31 @@ void MarlinUI::move_axis_screen() {
 
   // Babysteps during printing? Select babystep for Z probe offset
   if (busy && ENABLED(BABYSTEP_ZPROBE_OFFSET))
-    motionAxisState.z_selection = Z_SELECTION_Z_PROBE;
+
+    TERN_(HAS_Z_AXIS, motionAxisState.z_selection = Z_SELECTION_Z_PROBE);
 
   // ROW 1 -> E- Y- CurY Z+
   int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
 
-  drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy);
+  TERN_(HAS_EXTRUDERS, drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy));
 
   spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
   x += BTN_WIDTH + spacing;
-  drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy);
+
+  TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy));
 
   // Cur Y
   x += BTN_WIDTH;
-  motionAxisState.yValuePos.x = x + 2;
-  motionAxisState.yValuePos.y = y;
-  drawAxisValue(Y_AXIS);
+  #if HAS_Y_AXIS
+    motionAxisState.yValuePos.x = x + 2;
+    motionAxisState.yValuePos.y = y;
+    drawAxisValue(Y_AXIS);
+  #endif
 
   x += spacing;
-  drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+  #if HAS_Z_AXIS
+    drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+  #endif
 
   // ROW 2 -> "Ex"  X-  HOME X+  "Z"
   y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
@@ -869,14 +921,16 @@ void MarlinUI::move_axis_screen() {
 
   motionAxisState.eNamePos.x = x;
   motionAxisState.eNamePos.y = y;
-  drawCurESelection();
-  TERN_(HAS_TFT_XPT2046, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
+  #if HAS_EXTRUDERS
+    drawCurESelection();
+    TERN_(TOUCH_SCREEN, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
+  #endif
 
   x += BTN_WIDTH + spacing;
   drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
 
   x += BTN_WIDTH + spacing; //imgHome is 64x64
-  TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
+  TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
 
   x += BTN_WIDTH + spacing;
   uint16_t xplus_x = x;
@@ -885,7 +939,7 @@ void MarlinUI::move_axis_screen() {
   x += BTN_WIDTH + spacing;
   motionAxisState.zTypePos.x = x;
   motionAxisState.zTypePos.y = y;
-  drawCurZSelection();
+  TERN_(HAS_Z_AXIS, drawCurZSelection());
   #if BOTH(HAS_BED_PROBE, TOUCH_SCREEN)
     if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
   #endif
@@ -895,28 +949,30 @@ void MarlinUI::move_axis_screen() {
   x = X_MARGIN;
   spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
 
-  drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
+  TERN_(HAS_EXTRUDERS, drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy));
 
   // Cur E
   motionAxisState.eValuePos.x = x;
   motionAxisState.eValuePos.y = y + BTN_HEIGHT + 2;
-  drawAxisValue(E_AXIS);
+  TERN_(HAS_EXTRUDERS, drawAxisValue(E_AXIS));
 
   // Cur X
   motionAxisState.xValuePos.x = BTN_WIDTH + (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4; //X- pos
   motionAxisState.xValuePos.y = y - 10;
-  drawAxisValue(X_AXIS);
+  TERN_(HAS_X_AXIS, drawAxisValue(X_AXIS));
 
   x += BTN_WIDTH + spacing;
   drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy);
 
   x += BTN_WIDTH + spacing;
-  drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+  #if HAS_Z_AXIS
+    drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+  #endif
 
   // Cur Z
   motionAxisState.zValuePos.x = x;
   motionAxisState.zValuePos.y = y + BTN_HEIGHT + 2;
-  drawAxisValue(Z_AXIS);
+  TERN_(HAS_Z_AXIS, drawAxisValue(Z_AXIS));
 
   // ROW 4 -> step_size  disable steppers back
   y = TFT_HEIGHT - Y_MARGIN - 32;
@@ -925,13 +981,13 @@ void MarlinUI::move_axis_screen() {
   motionAxisState.stepValuePos.y = y;
   if (!busy) {
     drawCurStepValue();
-    TERN_(HAS_TFT_XPT2046, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
+    TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
   }
 
   // aligned with x+
   drawBtn(xplus_x, TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
 
-  TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));
+  TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));
 }
 
 #endif // HAS_UI_480x320

commit 9cc16f87e225d4f9f4ca002b2c33a6fda3da5c25
Author: Dmitry Plastinin <Uncellon@yandex.ru>
Date:   Sat May 6 00:05:30 2023 +0300

    üö∏ TS35 portrait display (#25629)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index efb58754c7..bc4ea0e5e2 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -49,9 +49,9 @@ void MarlinUI::tft_idle() {
   #if ENABLED(TOUCH_SCREEN)
     if (TERN0(HAS_TOUCH_SLEEP, lcd_sleep_task())) return;
     if (draw_menu_navigation) {
-      add_control(104, TFT_HEIGHT - 34, PAGE_UP, imgPageUp, encoderTopLine > 0);
-      add_control(344, TFT_HEIGHT - 34, PAGE_DOWN, imgPageDown, encoderTopLine + LCD_HEIGHT < screen_items);
-      add_control(224, TFT_HEIGHT - 34, BACK, imgBack);
+      add_control(TFT_WIDTH / 6 - 16, TFT_HEIGHT - 34, PAGE_UP, imgPageUp, encoderTopLine > 0);
+      add_control(TFT_WIDTH / 2 - 16, TFT_HEIGHT - 34, PAGE_DOWN, imgPageDown, encoderTopLine + LCD_HEIGHT < screen_items);
+      add_control(5 * TFT_WIDTH / 6 - 16, TFT_HEIGHT - 34, BACK, imgBack);
       draw_menu_navigation = false;
     }
   #endif
@@ -222,11 +222,10 @@ void MarlinUI::draw_status_screen() {
 
   TERN_(TOUCH_SCREEN, touch.clear());
 
-  // heaters and fan
-  uint16_t i, x, y = TFT_STATUS_TOP_Y;
-
-  for (i = 0 ; i < ITEMS_COUNT; i++) {
-    x = (TFT_WIDTH / ITEMS_COUNT - 80) / 2  + (TFT_WIDTH * i / ITEMS_COUNT);
+  // Statuses of heaters and fans
+  uint16_t y = STATUS_MARGIN_SIZE;
+  for (uint16_t i = 0; i < ITEMS_COUNT; i++) {
+    uint16_t x = (TFT_WIDTH / ITEMS_COUNT - 80) / 2  + (TFT_WIDTH * i / ITEMS_COUNT);
     switch (i) {
       #if HAS_EXTRUDERS
         case ITEM_E0: draw_heater_status(x, y, H_E0); break;
@@ -252,12 +251,13 @@ void MarlinUI::draw_status_screen() {
     }
   }
 
-  y += TERN(HAS_UI_480x272, 120, 128);
+  y += STATUS_MARGIN_SIZE + 114;
 
-  // coordinates
-  tft.canvas(4, y, TFT_WIDTH - 8, FONT_LINE_HEIGHT);
+  // Coordinates
+  constexpr uint16_t coords_width = TFT_WIDTH - 8;
+  tft.canvas((TFT_WIDTH - coords_width) / 2, y, coords_width, FONT_LINE_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);
-  tft.add_rectangle(0, 0, TFT_WIDTH - 8, FONT_LINE_HEIGHT, COLOR_AXIS_HOMED);
+  tft.add_rectangle(0, 0, coords_width, FONT_LINE_HEIGHT, COLOR_AXIS_HOMED);
 
   if (TERN0(LCD_SHOW_E_TOTAL, printingIsActive())) {
     #if ENABLED(LCD_SHOW_E_TOTAL)
@@ -270,67 +270,86 @@ void MarlinUI::draw_status_screen() {
     #endif
   }
   else {
-    tft.add_text( 16, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "X");
+    // Coords in mask "X____Y____Z____"
+    tft_string.set("X");
+    tft.add_text(coords_width / 30 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
+
     const bool nhx = axis_should_home(X_AXIS);
     tft_string.set(blink && nhx ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
-    tft.add_text(102 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT), nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+    tft_string.ltrim();
+    tft.add_text(coords_width / 5 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+
+    tft_string.set("Y");
+    tft.add_text(11 * coords_width / 30 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
 
-    tft.add_text(192, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "Y");
     const bool nhy = axis_should_home(Y_AXIS);
     tft_string.set(blink && nhy ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
-    tft.add_text(280 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT), nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+    tft_string.ltrim();
+    tft.add_text(8 * coords_width / 15 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
   }
-  tft.add_text(330, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "Z");
-  uint16_t offset = 32;
+
+  tft_string.set("Z");
+  tft.add_text(7 * coords_width / 10 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
+
   const bool nhz = axis_should_home(Z_AXIS);
-  if (blink && nhz)
-    tft_string.set('?');
-  else {
-    const float z = LOGICAL_Z_POSITION(current_position.z);
-    tft_string.set(ftostr52sp((int16_t)z));
-    tft_string.rtrim();
-    offset += tft_string.width();
+  tft_string.set(blink && nhz ? "?" : ftostr52sp(LOGICAL_Z_POSITION(current_position.z)));
+  tft_string.ltrim();
+  tft_string.rtrim();
+  tft.add_text(13 * coords_width / 15 - tft_string.width() / 2, tft_string.vcenter(FONT_LINE_HEIGHT), nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
 
-    tft_string.set(ftostr52sp(z));
-    offset -= tft_string.width();
-  }
-  tft.add_text(455 - tft_string.width() - offset, tft_string.vcenter(FONT_LINE_HEIGHT), nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
   TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 4, y, TFT_WIDTH - 8, FONT_LINE_HEIGHT));
 
-  y += TERN(HAS_UI_480x272, 34, 48);
-  // feed rate
-  tft.canvas(96, y, 128, 32);
-  tft.set_background(COLOR_BACKGROUND);
+  y += STATUS_MARGIN_SIZE + 34;
+
+  // Feed rate (preparing)
+  tft_string.set(i16tostr3rj(feedrate_percentage));
+  tft_string.add("%");
+  uint16_t component_width = 36 + tft_string.width(); // 32px icon size + 4px margin before text
   uint16_t color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
+  uint16_t x = FEEDRATE_X(component_width);
+
+  // Feed rate (drawing)
+  tft.canvas(x, y, component_width, 32);
+  tft.set_background(COLOR_BACKGROUND);
   tft.add_image(0, 0, imgFeedRate, color);
-  tft_string.set(i16tostr3rj(feedrate_percentage));
-  tft_string.add('%');
   tft.add_text(36, tft_string.vcenter(30), color , tft_string);
-  TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE, 96, y, 128, 32));
+  TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE, x, y, component_width, 32));
 
-  // flow rate
-  tft.canvas(284, y, 128, 32);
-  tft.set_background(COLOR_BACKGROUND);
-  color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
-  tft.add_image(0, 0, imgFlowRate, color);
+  // Flow rate (preparing)
   tft_string.set(i16tostr3rj(planner.flow_percentage[active_extruder]));
   tft_string.add('%');
+  component_width = 36 + tft_string.width();
+  color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
+  x = FLOWRATE_X(component_width);
+
+  // Flow rate (drawing)
+  tft.canvas(x, y, component_width, 32);
+  tft.set_background(COLOR_BACKGROUND);
+  tft.add_image(0, 0, imgFlowRate, color);
   tft.add_text(36, tft_string.vcenter(30), color , tft_string);
-  TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE, 284, y, 128, 32, active_extruder));
+  TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE, x, y, component_width, 32, active_extruder));
+
+  #if TFT_COLOR_UI_PORTRAIT || DISABLED(TOUCH_SCREEN)
+    y += STATUS_MARGIN_SIZE + 32;
+  #endif
 
   #if ENABLED(TOUCH_SCREEN)
-    add_control(404, y, menu_main, imgSettings);
+    // Settings button
+    add_control(SETTINGS_X, y, menu_main, imgSettings);
+
+    // SD-card button / Cancel button
     #if HAS_MEDIA
       const bool cm = card.isMounted(), pa = printingIsActive();
       if (cm && pa)
-        add_control(12, y, STOP, imgCancel, true, COLOR_CONTROL_CANCEL);
+        add_control(SDCARD_X, y, STOP, imgCancel, true, COLOR_CONTROL_CANCEL);
       else
-        add_control(12, y, menu_media, imgSD, cm && !pa, COLOR_CONTROL_ENABLED, COLOR_CONTROL_DISABLED);
+        add_control(SDCARD_X, y, menu_media, imgSD, cm && !pa, COLOR_CONTROL_ENABLED, COLOR_CONTROL_DISABLED); // 64px icon size
     #endif
+
+    y += STATUS_MARGIN_SIZE + TERN(TFT_COLOR_UI_PORTRAIT, 64, 44);
   #endif
 
-  y += TERN(HAS_UI_480x272, 39, 44);
-  // print duration
+  // Print duration
   char buffer[14];
   duration_t elapsed = print_job_timer.duration();
   elapsed.toDigital(buffer);
@@ -340,8 +359,9 @@ void MarlinUI::draw_status_screen() {
   tft_string.set(buffer);
   tft.add_text(tft_string.center(128), tft_string.vcenter(29), COLOR_PRINT_TIME, tft_string);
 
-  y += TERN(HAS_UI_480x272, 29, 36);
-  // progress bar
+  y += STATUS_MARGIN_SIZE + 29;
+
+  // Progress bar
   const uint8_t progress = ui.get_progress_percent();
   tft.canvas(4, y, TFT_WIDTH - 8, 9);
   tft.set_background(COLOR_PROGRESS_BG);
@@ -349,8 +369,9 @@ void MarlinUI::draw_status_screen() {
   if (progress)
     tft.add_bar(1, 1, ((TFT_WIDTH - 10) * progress) / 100, 7, COLOR_PROGRESS_BAR);
 
-  y += 15;
-  // status message
+  y += STATUS_MARGIN_SIZE + 7;
+
+  // Status message
   tft.canvas(0, y, TFT_WIDTH, FONT_LINE_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(status_message);
@@ -397,7 +418,7 @@ void MenuEditItemBase::draw_edit_screen(FSTR_P const fstr, const char * const va
 
   if (ui.can_show_slider()) {
 
-    #define SLIDER_LENGTH 336
+    #define SLIDER_LENGTH TFT_WIDTH * 0.7
     #define SLIDER_Y_POSITION 186
 
     tft.canvas((TFT_WIDTH - SLIDER_LENGTH) / 2, SLIDER_Y_POSITION, SLIDER_LENGTH, 16);
@@ -420,9 +441,9 @@ void MenuEditItemBase::draw_edit_screen(FSTR_P const fstr, const char * const va
 
 void TFT::draw_edit_screen_buttons() {
   #if ENABLED(TOUCH_SCREEN)
-    add_control(64, TFT_HEIGHT - 64, DECREASE, imgDecrease);
-    add_control(352, TFT_HEIGHT - 64, INCREASE, imgIncrease);
-    add_control(208, TFT_HEIGHT - 64, CLICK, imgConfirm);
+    add_control((TFT_WIDTH - 3 * 64) / 6, TFT_HEIGHT - 64, DECREASE, imgDecrease);
+    add_control((TFT_WIDTH - 64) / 2, TFT_HEIGHT - 64, INCREASE, imgIncrease);
+    add_control((TFT_WIDTH * 5 - 3 * 64) / 6, TFT_HEIGHT - 64, CLICK, imgConfirm);
   #endif
 }
 
@@ -451,8 +472,8 @@ void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, con
     tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
   }
   #if ENABLED(TOUCH_SCREEN)
-    if (no)  add_control( 88, TFT_HEIGHT - 64, CANCEL,  imgCancel,  true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
-    if (yes) add_control(328, TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
+    if (no)  add_control(TFT_WIDTH / 4 - 32, TFT_HEIGHT - 64, CANCEL,  imgCancel,  true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
+    if (yes) add_control(TFT_WIDTH * 3 / 4 - 32, TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
   #endif
 }
 
@@ -898,7 +919,7 @@ void MarlinUI::move_axis_screen() {
   drawAxisValue(Z_AXIS);
 
   // ROW 4 -> step_size  disable steppers back
-  y = TFT_HEIGHT - Y_MARGIN - 32; //
+  y = TFT_HEIGHT - Y_MARGIN - 32;
   x = TFT_WIDTH / 2 - CUR_STEP_VALUE_WIDTH / 2;
   motionAxisState.stepValuePos.x = x;
   motionAxisState.stepValuePos.y = y;

commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    üßë‚Äçüíª Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index edc3d321f2..efb58754c7 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -36,7 +36,7 @@
 #include "../../module/planner.h"
 #include "../../module/motion.h"
 
-#if DISABLED(LCD_PROGRESS_BAR) && BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+#if DISABLED(LCD_PROGRESS_BAR) && BOTH(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
   #include "../../feature/filwidth.h"
   #include "../../gcode/parser.h"
 #endif
@@ -320,7 +320,7 @@ void MarlinUI::draw_status_screen() {
 
   #if ENABLED(TOUCH_SCREEN)
     add_control(404, y, menu_main, imgSettings);
-    #if ENABLED(SDSUPPORT)
+    #if HAS_MEDIA
       const bool cm = card.isMounted(), pa = printingIsActive();
       if (cm && pa)
         add_control(12, y, STOP, imgCancel, true, COLOR_CONTROL_CANCEL);

commit 89ccede139963091768985eeb4ca5a6e3111647c
Author: Alexey D. Filimonov <alexey@filimonic.net>
Date:   Sat Apr 22 12:06:19 2023 +0300

    üé® Clean up TFT Color UI display items (#25712)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 54762da671..edc3d321f2 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -228,25 +228,25 @@ void MarlinUI::draw_status_screen() {
   for (i = 0 ; i < ITEMS_COUNT; i++) {
     x = (TFT_WIDTH / ITEMS_COUNT - 80) / 2  + (TFT_WIDTH * i / ITEMS_COUNT);
     switch (i) {
-      #ifdef ITEM_E0
+      #if HAS_EXTRUDERS
         case ITEM_E0: draw_heater_status(x, y, H_E0); break;
       #endif
-      #ifdef ITEM_E1
+      #if HAS_MULTI_HOTEND
         case ITEM_E1: draw_heater_status(x, y, H_E1); break;
       #endif
-      #ifdef ITEM_E2
+      #if HOTENDS > 2
         case ITEM_E2: draw_heater_status(x, y, H_E2); break;
       #endif
-      #ifdef ITEM_BED
+      #if HAS_HEATED_BED
         case ITEM_BED: draw_heater_status(x, y, H_BED); break;
       #endif
-      #ifdef ITEM_CHAMBER
+      #if HAS_TEMP_CHAMBER
         case ITEM_CHAMBER: draw_heater_status(x, y, H_CHAMBER); break;
       #endif
-      #ifdef ITEM_COOLER
+      #if HAS_TEMP_COOLER
         case ITEM_COOLER: draw_heater_status(x, y, H_COOLER); break;
       #endif
-      #ifdef ITEM_FAN
+      #if HAS_FAN
         case ITEM_FAN: draw_fan_status(x, y, blink); break;
       #endif
     }

commit 196f403dd6be59e1bcfd24f31895a1ebc551caac
Author: alexgrach <gav@bmstu.ru>
Date:   Wed Feb 15 09:40:26 2023 +0300

    üö∏ Stop button for Touch UI (#25379)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index c4395460d5..54762da671 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -322,7 +322,10 @@ void MarlinUI::draw_status_screen() {
     add_control(404, y, menu_main, imgSettings);
     #if ENABLED(SDSUPPORT)
       const bool cm = card.isMounted(), pa = printingIsActive();
-      add_control(12, y, menu_media, imgSD, cm && !pa, COLOR_CONTROL_ENABLED, cm && pa ? COLOR_BUSY : COLOR_CONTROL_DISABLED);
+      if (cm && pa)
+        add_control(12, y, STOP, imgCancel, true, COLOR_CONTROL_CANCEL);
+      else
+        add_control(12, y, menu_media, imgSD, cm && !pa, COLOR_CONTROL_ENABLED, COLOR_CONTROL_DISABLED);
     #endif
   #endif
 

commit fbe9237a6c934b8c16e39b879b04973063c3988c
Author: alexgrach <gav@bmstu.ru>
Date:   Wed Feb 1 10:40:13 2023 +0300

    üêõ Fix TFT touch buttons, button colors (#25300)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 5bf50a5818..c4395460d5 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -573,11 +573,6 @@ struct MotionAxisState {
 
 MotionAxisState motionAxisState;
 
-#define E_BTN_COLOR COLOR_YELLOW
-#define X_BTN_COLOR COLOR_CORAL_RED
-#define Y_BTN_COLOR COLOR_VIVID_GREEN
-#define Z_BTN_COLOR COLOR_LIGHT_BLUE
-
 #define BTN_WIDTH 64
 #define BTN_HEIGHT 52
 #define X_MARGIN 20

commit b7c23631c5840e2338cae531b171459e9e9c5301
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sun Jan 22 15:08:37 2023 +1300

    üêõ Fix misc. UI issues (#25252)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 02e9ca196a..5bf50a5818 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -656,12 +656,10 @@ static void drawAxisValue(const AxisEnum axis) {
 static void moveAxis(const AxisEnum axis, const int8_t direction) {
   quick_feedback();
 
-  #if ENABLED(PREVENT_COLD_EXTRUSION)
-    if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
-      drawMessage(F("Too cold"));
-      return;
-    }
-  #endif
+  if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
+    drawMessage(F("Too cold"));
+    return;
+  }
 
   const float diff = motionAxisState.currentStepSize * direction;
 

commit 99d1b04a1f1d66aef78994fd98189a9ba9acbcb1
Author: alexgrach <gav@bmstu.ru>
Date:   Wed Jan 18 02:37:19 2023 +0300

    ‚ú® TFT 320x240 portrait (#25207)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index e8d51d89a1..02e9ca196a 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -746,10 +746,8 @@ static void z_minus() { moveAxis(Z_AXIS, -1); }
 
 #if ENABLED(TOUCH_SCREEN)
   static void e_select() {
-    motionAxisState.e_selection++;
-    if (motionAxisState.e_selection >= EXTRUDERS) {
+    if (++motionAxisState.e_selection >= EXTRUDERS)
       motionAxisState.e_selection = 0;
-    }
 
     quick_feedback();
     drawCurESelection();
@@ -791,8 +789,8 @@ static void disable_steppers() {
 }
 
 static void drawBtn(int x, int y, const char *label, intptr_t data, MarlinImage img, uint16_t bgColor, bool enabled = true) {
-  uint16_t width = Images[imgBtn52Rounded].width;
-  uint16_t height = Images[imgBtn52Rounded].height;
+  uint16_t width = Images[imgBtn52Rounded].width,
+           height = Images[imgBtn52Rounded].height;
 
   if (!enabled) bgColor = COLOR_CONTROL_DISABLED;
 

commit 7717beb79362522b8239d5af62b32ff3d0e2d748
Author: kadir ilkimen <kadirilkimen@gmail.com>
Date:   Wed Jan 11 06:29:38 2023 +0200

    ‚ú® Polar Kinematics (#25214)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index c5e03566a9..e8d51d89a1 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -715,7 +715,7 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
     // This assumes the center is 0,0
     #if ENABLED(DELTA)
       if (axis != Z_AXIS && axis != E_AXIS) {
-        max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
+        max = SQRT(sq(float(PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
         min = -max;
       }
     #endif

commit fca1929beb6a5f7dd21d17bdefcbc97511869e27
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Sat Dec 31 08:44:55 2022 +0300

    ‚ú®‚ö°Ô∏è UTF support for TFT Color UI (#25073)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 682ea3e380..c5e03566a9 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -185,13 +185,13 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
   tft_string.set(i16tostr3rj(currentTemperature));
   tft_string.add(LCD_STR_DEGREE);
   tft_string.trim();
-  tft.add_text(tft_string.center(80) + 2, 82, Color, tft_string);
+  tft.add_text(tft_string.center(80) + 2, 80 + tft_string.vcenter(FONT_LINE_HEIGHT), Color, tft_string);
 
   if (targetTemperature >= 0) {
     tft_string.set(i16tostr3rj(targetTemperature));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.trim();
-    tft.add_text(tft_string.center(80) + 2, 8, Color, tft_string);
+    tft.add_text(tft_string.center(80) + 2, 6 + tft_string.vcenter(FONT_LINE_HEIGHT) , Color, tft_string);
   }
 }
 
@@ -214,7 +214,7 @@ void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
 
   tft_string.set(ui8tostr4pctrj(thermalManager.fan_speed[0]));
   tft_string.trim();
-  tft.add_text(tft_string.center(80) + 6, 82, COLOR_FAN, tft_string);
+  tft.add_text(tft_string.center(80) + 6, 80 + tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_FAN, tft_string);
 }
 
 void MarlinUI::draw_status_screen() {
@@ -252,7 +252,7 @@ void MarlinUI::draw_status_screen() {
     }
   }
 
-  y += TERN(HAS_UI_480x272, 118, 128);
+  y += TERN(HAS_UI_480x272, 120, 128);
 
   // coordinates
   tft.canvas(4, y, TFT_WIDTH - 8, FONT_LINE_HEIGHT);
@@ -261,26 +261,26 @@ void MarlinUI::draw_status_screen() {
 
   if (TERN0(LCD_SHOW_E_TOTAL, printingIsActive())) {
     #if ENABLED(LCD_SHOW_E_TOTAL)
-      tft.add_text( 16, 3, COLOR_AXIS_HOMED , "E");
+      tft.add_text( 16, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "E");
       const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
       tft_string.set(ftostr4sign(e_move_accumulator / escale));
       tft_string.add(escale == 10 ? 'c' : 'm');
       tft_string.add('m');
-      tft.add_text(192 - tft_string.width(), 3, COLOR_AXIS_HOMED, tft_string);
+      tft.add_text(192 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
     #endif
   }
   else {
-    tft.add_text( 16, 3, COLOR_AXIS_HOMED , "X");
+    tft.add_text( 16, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "X");
     const bool nhx = axis_should_home(X_AXIS);
     tft_string.set(blink && nhx ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
-    tft.add_text(102 - tft_string.width(), 3, nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+    tft.add_text(102 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT), nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
 
-    tft.add_text(192, 3, COLOR_AXIS_HOMED , "Y");
+    tft.add_text(192, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "Y");
     const bool nhy = axis_should_home(Y_AXIS);
     tft_string.set(blink && nhy ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
-    tft.add_text(280 - tft_string.width(), 3, nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+    tft.add_text(280 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT), nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
   }
-  tft.add_text(330, 3, COLOR_AXIS_HOMED , "Z");
+  tft.add_text(330, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "Z");
   uint16_t offset = 32;
   const bool nhz = axis_should_home(Z_AXIS);
   if (blink && nhz)
@@ -294,29 +294,29 @@ void MarlinUI::draw_status_screen() {
     tft_string.set(ftostr52sp(z));
     offset -= tft_string.width();
   }
-  tft.add_text(455 - tft_string.width() - offset, 3, nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+  tft.add_text(455 - tft_string.width() - offset, tft_string.vcenter(FONT_LINE_HEIGHT), nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
   TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 4, y, TFT_WIDTH - 8, FONT_LINE_HEIGHT));
 
-  y += TERN(HAS_UI_480x272, 38, 48);
+  y += TERN(HAS_UI_480x272, 34, 48);
   // feed rate
-  tft.canvas(96, y, 100, 32);
+  tft.canvas(96, y, 128, 32);
   tft.set_background(COLOR_BACKGROUND);
   uint16_t color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
   tft.add_image(0, 0, imgFeedRate, color);
   tft_string.set(i16tostr3rj(feedrate_percentage));
   tft_string.add('%');
-  tft.add_text(36, 1, color , tft_string);
-  TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE, 96, 176, 100, 32));
+  tft.add_text(36, tft_string.vcenter(30), color , tft_string);
+  TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE, 96, y, 128, 32));
 
   // flow rate
-  tft.canvas(284, y, 100, 32);
+  tft.canvas(284, y, 128, 32);
   tft.set_background(COLOR_BACKGROUND);
   color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
   tft.add_image(0, 0, imgFlowRate, color);
   tft_string.set(i16tostr3rj(planner.flow_percentage[active_extruder]));
   tft_string.add('%');
-  tft.add_text(36, 1, color , tft_string);
-  TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE, 284, 176, 100, 32, active_extruder));
+  tft.add_text(36, tft_string.vcenter(30), color , tft_string);
+  TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE, 284, y, 128, 32, active_extruder));
 
   #if ENABLED(TOUCH_SCREEN)
     add_control(404, y, menu_main, imgSettings);
@@ -326,7 +326,7 @@ void MarlinUI::draw_status_screen() {
     #endif
   #endif
 
-  y += TERN(HAS_UI_480x272, 36, 44);
+  y += TERN(HAS_UI_480x272, 39, 44);
   // print duration
   char buffer[14];
   duration_t elapsed = print_job_timer.duration();
@@ -335,9 +335,9 @@ void MarlinUI::draw_status_screen() {
   tft.canvas((TFT_WIDTH - 128) / 2, y, 128, 29);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(buffer);
-  tft.add_text(tft_string.center(128), 0, COLOR_PRINT_TIME, tft_string);
+  tft.add_text(tft_string.center(128), tft_string.vcenter(29), COLOR_PRINT_TIME, tft_string);
 
-  y += TERN(HAS_UI_480x272, 28, 36);
+  y += TERN(HAS_UI_480x272, 29, 36);
   // progress bar
   const uint8_t progress = ui.get_progress_percent();
   tft.canvas(4, y, TFT_WIDTH - 8, 9);
@@ -346,13 +346,13 @@ void MarlinUI::draw_status_screen() {
   if (progress)
     tft.add_bar(1, 1, ((TFT_WIDTH - 10) * progress) / 100, 7, COLOR_PROGRESS_BAR);
 
-  y += 20;
+  y += 15;
   // status message
-  tft.canvas(0, y, TFT_WIDTH, FONT_LINE_HEIGHT - 5);
+  tft.canvas(0, y, TFT_WIDTH, FONT_LINE_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(status_message);
   tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_STATUS_MESSAGE, tft_string);
+  tft.add_text(tft_string.center(TFT_WIDTH), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_STATUS_MESSAGE, tft_string);
 }
 
 // Low-level draw_edit_screen can be used to draw an edit screen from anyplace

commit aaae56a6501fd617cdc1216e0d1bfec39538da61
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Tue Dec 13 00:13:31 2022 +0300

    ‚ú® TFT_COLOR_UI async DMA SPI (#24980)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 04a121a0e0..682ea3e380 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -57,7 +57,8 @@ void MarlinUI::tft_idle() {
   #endif
 
   tft.queue.async();
-  TERN_(TOUCH_SCREEN, touch.idle());
+
+  TERN_(TOUCH_SCREEN, if (tft.queue.is_empty()) touch.idle()); // Touch driver is not DMA-aware, so only check for touch controls after screen drawing is completed
 }
 
 #if ENABLED(SHOW_BOOTSCREEN)
@@ -319,7 +320,10 @@ void MarlinUI::draw_status_screen() {
 
   #if ENABLED(TOUCH_SCREEN)
     add_control(404, y, menu_main, imgSettings);
-    TERN_(SDSUPPORT, add_control(12, y, menu_media, imgSD, !printingIsActive(), COLOR_CONTROL_ENABLED, card.isMounted() && printingIsActive() ? COLOR_BUSY : COLOR_CONTROL_DISABLED));
+    #if ENABLED(SDSUPPORT)
+      const bool cm = card.isMounted(), pa = printingIsActive();
+      add_control(12, y, menu_media, imgSD, cm && !pa, COLOR_CONTROL_ENABLED, cm && pa ? COLOR_BUSY : COLOR_CONTROL_DISABLED);
+    #endif
   #endif
 
   y += TERN(HAS_UI_480x272, 36, 44);

commit 4ffa2e80e4db3413425a575aed14be30bbf2bb24
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Mon Jul 25 12:02:37 2022 -0700

    üì∫ Fix TFT Classic UI non-Touchscreen 1024x600 (#24541)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index d4a04d6900..04a121a0e0 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -772,7 +772,7 @@ static void z_minus() { moveAxis(Z_AXIS, -1); }
   }
 #endif
 
-#if HAS_BED_PROBE
+#if BOTH(HAS_BED_PROBE, TOUCH_SCREEN)
   static void z_select() {
     motionAxisState.z_selection *= -1;
     quick_feedback();

commit d8545551fed8498f1c420ec3b301d4d77d0de8b5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 26 05:47:18 2022 -0500

    üêõ Fix Manual Move axis selection (#24404)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 8a5fa63354..d4a04d6900 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -388,8 +388,7 @@ void MenuEditItemBase::draw_edit_screen(FSTR_P const fstr, const char * const va
     }
   #endif
 
-  extern screenFunc_t _manual_move_func_ptr;
-  if (ui.currentScreen != _manual_move_func_ptr && !ui.external_control) {
+  if (ui.can_show_slider()) {
 
     #define SLIDER_LENGTH 336
     #define SLIDER_Y_POSITION 186

commit 640282b8dc5de4ccdfb607b99e795d3eaa1334a7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 13 20:43:23 2022 -0500

    üßë‚Äçüíª Apply F() to some LCD / TFT strings
    
    Followup to #24228

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 5a964525ec..8a5fa63354 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -283,7 +283,7 @@ void MarlinUI::draw_status_screen() {
   uint16_t offset = 32;
   const bool nhz = axis_should_home(Z_AXIS);
   if (blink && nhz)
-    tft_string.set("?");
+    tft_string.set('?');
   else {
     const float z = LOGICAL_Z_POSITION(current_position.z);
     tft_string.set(ftostr52sp((int16_t)z));
@@ -466,7 +466,7 @@ void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, con
     tft_string.add(' ');
     tft_string.add(i16tostr3rj(thermalManager.wholeDegHotend(extruder)));
     tft_string.add(LCD_STR_DEGREE);
-    tft_string.add(" / ");
+    tft_string.add(F(" / "));
     tft_string.add(i16tostr3rj(thermalManager.degTargetHotend(extruder)));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.trim();
@@ -594,19 +594,19 @@ static void quick_feedback() {
 #define CUR_STEP_VALUE_WIDTH 104
 static void drawCurStepValue() {
   tft_string.set(ftostr52sp(motionAxisState.currentStepSize));
-  tft_string.add("mm");
+  tft_string.add(F("mm"));
   tft.canvas(motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_text(tft_string.center(CUR_STEP_VALUE_WIDTH), 0, COLOR_AXIS_HOMED, tft_string);
 }
 
 static void drawCurZSelection() {
-  tft_string.set("Z");
+  tft_string.set('Z');
   tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y, tft_string.width(), 34);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
   tft.queue.sync();
-  tft_string.set("Offset");
+  tft_string.set(F("Offset"));
   tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y + 34, tft_string.width(), 34);
   tft.set_background(COLOR_BACKGROUND);
   if (motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
@@ -617,7 +617,7 @@ static void drawCurZSelection() {
 static void drawCurESelection() {
   tft.canvas(motionAxisState.eNamePos.x, motionAxisState.eNamePos.y, BTN_WIDTH, BTN_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);
-  tft_string.set("E");
+  tft_string.set('E');
   tft.add_text(0, 0, E_BTN_COLOR , tft_string);
   tft.add_text(tft_string.width(), 0, E_BTN_COLOR, ui8tostr3rj(motionAxisState.e_selection));
 }
@@ -628,6 +628,8 @@ static void drawMessage(PGM_P const msg) {
   tft.add_text(0, 0, COLOR_YELLOW, msg);
 }
 
+static void drawMessage(FSTR_P const fmsg) { drawMessage(FTOP(fmsg)); }
+
 static void drawAxisValue(const AxisEnum axis) {
   const float value = (
     TERN_(HAS_BED_PROBE, axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE ? probe.offset.z :)
@@ -653,7 +655,7 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
 
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
-      drawMessage(PSTR("Too cold"));
+      drawMessage(F("Too cold"));
       return;
     }
   #endif
@@ -680,18 +682,18 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
         drawAxisValue(axis);
       }
       else {
-        drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
+        drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
       }
     #elif HAS_BED_PROBE
       // only change probe.offset.z
       probe.offset.z += diff;
       if (direction < 0 && current_position[axis] < Z_PROBE_OFFSET_RANGE_MIN) {
         current_position[axis] = Z_PROBE_OFFSET_RANGE_MIN;
-        drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
+        drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
       }
       else if (direction > 0 && current_position[axis] > Z_PROBE_OFFSET_RANGE_MAX) {
         current_position[axis] = Z_PROBE_OFFSET_RANGE_MAX;
-        drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
+        drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
       }
       else {
         drawMessage(NUL_STR); // clear the error
@@ -753,7 +755,7 @@ static void z_minus() { moveAxis(Z_AXIS, -1); }
 
   static void do_home() {
     quick_feedback();
-    drawMessage(GET_TEXT(MSG_LEVEL_BED_HOMING));
+    drawMessage(GET_TEXT_F(MSG_LEVEL_BED_HOMING));
     queue.inject_P(G28_STR);
     // Disable touch until home is done
     TERN_(HAS_TFT_XPT2046, touch.disable());

commit 8aca38351cd6d33a1202bf9a13890dc8e5eadd49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 3 22:56:38 2022 -0500

    üßë‚Äçüíª Extend LCD string substitution (#24278)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 34502df540..5a964525ec 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -181,13 +181,13 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
 
   tft.add_image(8, 28, image, Color);
 
-  tft_string.set((uint8_t *)i16tostr3rj(currentTemperature));
+  tft_string.set(i16tostr3rj(currentTemperature));
   tft_string.add(LCD_STR_DEGREE);
   tft_string.trim();
   tft.add_text(tft_string.center(80) + 2, 82, Color, tft_string);
 
   if (targetTemperature >= 0) {
-    tft_string.set((uint8_t *)i16tostr3rj(targetTemperature));
+    tft_string.set(i16tostr3rj(targetTemperature));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.trim();
     tft.add_text(tft_string.center(80) + 2, 8, Color, tft_string);
@@ -211,7 +211,7 @@ void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
 
   tft.add_image(8, 20, image, COLOR_FAN);
 
-  tft_string.set((uint8_t *)ui8tostr4pctrj(thermalManager.fan_speed[0]));
+  tft_string.set(ui8tostr4pctrj(thermalManager.fan_speed[0]));
   tft_string.trim();
   tft.add_text(tft_string.center(80) + 6, 82, COLOR_FAN, tft_string);
 }
@@ -359,7 +359,7 @@ void MenuEditItemBase::draw_edit_screen(FSTR_P const fstr, const char * const va
   uint16_t line = 1;
 
   menu_line(line++);
-  tft_string.set(FTOP(fstr), itemIndex, FTOP(itemString));
+  tft_string.set(fstr, itemIndex, itemStringC, itemStringF);
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
 
@@ -593,7 +593,7 @@ static void quick_feedback() {
 
 #define CUR_STEP_VALUE_WIDTH 104
 static void drawCurStepValue() {
-  tft_string.set((uint8_t *)ftostr52sp(motionAxisState.currentStepSize));
+  tft_string.set(ftostr52sp(motionAxisState.currentStepSize));
   tft_string.add("mm");
   tft.canvas(motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);

commit a5e1d4c50ae40c8203d8490be83ef86e16ebf1c2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 22 19:56:46 2022 -0500

    ‚ôªÔ∏è Apply F() to more LCD code (#24228)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 6f7327f1e8..34502df540 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -352,14 +352,14 @@ void MarlinUI::draw_status_screen() {
 }
 
 // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
-void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char * const value/*=nullptr*/) {
+void MenuEditItemBase::draw_edit_screen(FSTR_P const fstr, const char * const value/*=nullptr*/) {
   ui.encoder_direction_normal();
   TERN_(TOUCH_SCREEN, touch.clear());
 
   uint16_t line = 1;
 
   menu_line(line++);
-  tft_string.set(pstr, itemIndex, itemString);
+  tft_string.set(FTOP(fstr), itemIndex, FTOP(itemString));
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
 
@@ -421,7 +421,7 @@ void TFT::draw_edit_screen_buttons() {
 }
 
 // The Select Screen presents a prompt and two "buttons"
-void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const bool yesno, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
+void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, const bool yesno, FSTR_P const pref, const char * const string/*=nullptr*/, FSTR_P const suff/*=nullptr*/) {
   uint16_t line = 1;
 
   if (!string) line++;
@@ -622,7 +622,7 @@ static void drawCurESelection() {
   tft.add_text(tft_string.width(), 0, E_BTN_COLOR, ui8tostr3rj(motionAxisState.e_selection));
 }
 
-static void drawMessage(const char *msg) {
+static void drawMessage(PGM_P const msg) {
   tft.canvas(X_MARGIN, TFT_HEIGHT - Y_MARGIN - 34, TFT_HEIGHT / 2, 34);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_text(0, 0, COLOR_YELLOW, msg);
@@ -653,7 +653,7 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
 
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
-      drawMessage("Too cold");
+      drawMessage(PSTR("Too cold"));
       return;
     }
   #endif
@@ -676,7 +676,7 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
           probe.offset.z = new_offs;
         else
           TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
-        drawMessage(""); // clear the error
+        drawMessage(NUL_STR); // clear the error
         drawAxisValue(axis);
       }
       else {
@@ -694,7 +694,7 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
         drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
       }
       else {
-        drawMessage(""); // clear the error
+        drawMessage(NUL_STR); // clear the error
       }
       drawAxisValue(axis);
     #endif

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ‚ôªÔ∏è Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 7952ba30cf..6f7327f1e8 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -490,12 +490,12 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
 
     for (uint16_t x = 0; x < (GRID_MAX_POINTS_X); x++)
       for (uint16_t y = 0; y < (GRID_MAX_POINTS_Y); y++)
-        if (position_is_reachable({ ubl.mesh_index_to_xpos(x), ubl.mesh_index_to_ypos(y) }))
+        if (position_is_reachable({ bedlevel.get_mesh_x(x), bedlevel.get_mesh_y(y) }))
           tft.add_bar(1 + (x * 2 + 1) * (GRID_WIDTH - 4) / (GRID_MAX_POINTS_X) / 2, GRID_HEIGHT - 3 - ((y * 2 + 1) * (GRID_HEIGHT - 4) / (GRID_MAX_POINTS_Y) / 2), 2, 2, COLOR_UBL);
 
     tft.add_rectangle((x_plot * 2 + 1) * (GRID_WIDTH - 4) / (GRID_MAX_POINTS_X) / 2 - 1, GRID_HEIGHT - 5 - ((y_plot * 2 + 1) * (GRID_HEIGHT - 4) / (GRID_MAX_POINTS_Y) / 2), 6, 6, COLOR_UBL);
 
-    const xy_pos_t pos = { ubl.mesh_index_to_xpos(x_plot), ubl.mesh_index_to_ypos(y_plot) },
+    const xy_pos_t pos = { bedlevel.get_mesh_x(x_plot), bedlevel.get_mesh_y(y_plot) },
                    lpos = pos.asLogical();
 
     tft.canvas(320, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2 - MENU_ITEM_HEIGHT, 120, MENU_ITEM_HEIGHT);
@@ -518,7 +518,7 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(Z_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-    tft_string.set(isnan(ubl.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(ubl.z_values[x_plot][y_plot]));
+    tft_string.set(isnan(bedlevel.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(bedlevel.z_values[x_plot][y_plot]));
     tft_string.trim();
     tft.add_text(120 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 

commit 04fe50936e23a8aca7a400591e700c1220f68b3f
Author: Pauli Jokela <pauli.jokela@didstopia.com>
Date:   Thu May 12 05:23:16 2022 +0300

    ‚ú® SOUND_ON_DEFAULT option (#24102)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index f142dbbc06..7952ba30cf 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -583,7 +583,7 @@ MotionAxisState motionAxisState;
 static void quick_feedback() {
   #if HAS_CHIRP
     ui.chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
-    #if BOTH(HAS_MARLINUI_MENU, USE_BEEPER)
+    #if BOTH(HAS_MARLINUI_MENU, HAS_BEEPER)
       for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
     #elif HAS_MARLINUI_MENU
       delay(10);

commit 5b35f3a95582a477e879be5cc7d1406a42d3e740
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed Jan 26 10:33:10 2022 -0800

    üö∏ Better "Bed Tramming Done" dialog (#23616)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 286879a6e0..f142dbbc06 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -445,8 +445,8 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
   }
   #if ENABLED(TOUCH_SCREEN)
-    add_control(88, TFT_HEIGHT - 64, CANCEL, imgCancel, true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
-    add_control(328, TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
+    if (no)  add_control( 88, TFT_HEIGHT - 64, CANCEL,  imgCancel,  true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
+    if (yes) add_control(328, TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
   #endif
 }
 

commit ab46b7e2f298826a5512569d6e79bb59a7a6b8ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 25 15:33:03 2022 -0600

    üßë‚Äçüíª HAS_MARLINUI_MENU, HAS_MANUAL_MOVE_MENU

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index ff14a9d588..286879a6e0 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -583,9 +583,9 @@ MotionAxisState motionAxisState;
 static void quick_feedback() {
   #if HAS_CHIRP
     ui.chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
-    #if BOTH(HAS_LCD_MENU, USE_BEEPER)
+    #if BOTH(HAS_MARLINUI_MENU, USE_BEEPER)
       for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
-    #elif HAS_LCD_MENU
+    #elif HAS_MARLINUI_MENU
       delay(10);
     #endif
   #endif

commit 36b2650f65e036ce1b02da568364230201a22b80
Author: Mikhail Basov <github@basov.net>
Date:   Mon Nov 15 07:46:34 2021 +0300

    üö∏ LCD_SHOW_E_TOTAL for TFT_COLOR_UI (#23127)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index f6591d682d..ff14a9d588 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -258,21 +258,31 @@ void MarlinUI::draw_status_screen() {
   tft.set_background(COLOR_BACKGROUND);
   tft.add_rectangle(0, 0, TFT_WIDTH - 8, FONT_LINE_HEIGHT, COLOR_AXIS_HOMED);
 
-  tft.add_text( 16, 3, COLOR_AXIS_HOMED , "X");
-  tft.add_text(192, 3, COLOR_AXIS_HOMED , "Y");
+  if (TERN0(LCD_SHOW_E_TOTAL, printingIsActive())) {
+    #if ENABLED(LCD_SHOW_E_TOTAL)
+      tft.add_text( 16, 3, COLOR_AXIS_HOMED , "E");
+      const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
+      tft_string.set(ftostr4sign(e_move_accumulator / escale));
+      tft_string.add(escale == 10 ? 'c' : 'm');
+      tft_string.add('m');
+      tft.add_text(192 - tft_string.width(), 3, COLOR_AXIS_HOMED, tft_string);
+    #endif
+  }
+  else {
+    tft.add_text( 16, 3, COLOR_AXIS_HOMED , "X");
+    const bool nhx = axis_should_home(X_AXIS);
+    tft_string.set(blink && nhx ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
+    tft.add_text(102 - tft_string.width(), 3, nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+
+    tft.add_text(192, 3, COLOR_AXIS_HOMED , "Y");
+    const bool nhy = axis_should_home(Y_AXIS);
+    tft_string.set(blink && nhy ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
+    tft.add_text(280 - tft_string.width(), 3, nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+  }
   tft.add_text(330, 3, COLOR_AXIS_HOMED , "Z");
-
-  bool not_homed = axis_should_home(X_AXIS);
-  tft_string.set(blink && not_homed ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
-  tft.add_text(102 - tft_string.width(), 3, not_homed ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
-
-  not_homed = axis_should_home(Y_AXIS);
-  tft_string.set(blink && not_homed ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
-  tft.add_text(280 - tft_string.width(), 3, not_homed ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
-
   uint16_t offset = 32;
-  not_homed = axis_should_home(Z_AXIS);
-  if (blink && not_homed)
+  const bool nhz = axis_should_home(Z_AXIS);
+  if (blink && nhz)
     tft_string.set("?");
   else {
     const float z = LOGICAL_Z_POSITION(current_position.z);
@@ -283,7 +293,7 @@ void MarlinUI::draw_status_screen() {
     tft_string.set(ftostr52sp(z));
     offset -= tft_string.width();
   }
-  tft.add_text(455 - tft_string.width() - offset, 3, not_homed ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+  tft.add_text(455 - tft_string.width() - offset, 3, nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
   TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 4, y, TFT_WIDTH - 8, FONT_LINE_HEIGHT));
 
   y += TERN(HAS_UI_480x272, 38, 48);

commit 417e2530ebc5b6c74ac34adaba8be552b407383a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 21:11:31 2021 -0500

    üé® Apply F() to G-code suite and queue

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 424f29a182..f6591d682d 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -772,7 +772,7 @@ static void z_minus() { moveAxis(Z_AXIS, -1); }
 
 static void disable_steppers() {
   quick_feedback();
-  queue.inject_P(PSTR("M84"));
+  queue.inject(F("M84"));
 }
 
 static void drawBtn(int x, int y, const char *label, intptr_t data, MarlinImage img, uint16_t bgColor, bool enabled = true) {

commit 228eb9c404fcbcebb507bbfe781ebe3ca0a1ccdf
Author: espr14 <espr14@gmail.com>
Date:   Mon Sep 27 21:05:52 2021 +0200

    üé® steps_to_mm => mm_per_step (#22847)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index c8333f7e4b..424f29a182 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -654,7 +654,7 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
       const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
       const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
-      const float bsDiff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
+      const float bsDiff = planner.mm_per_step[Z_AXIS] * babystep_increment,
                   new_probe_offset = probe.offset.z + bsDiff,
                   new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
                     , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff

commit c2e4b1626f0cce82a55e8de9dc98ed9381e1d9ad
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Tue Sep 14 04:07:08 2021 +0200

    ‚ú® TFT Screen/Backlight Sleep (#22617)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 02e3354d93..c8333f7e4b 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -47,6 +47,7 @@
 
 void MarlinUI::tft_idle() {
   #if ENABLED(TOUCH_SCREEN)
+    if (TERN0(HAS_TOUCH_SLEEP, lcd_sleep_task())) return;
     if (draw_menu_navigation) {
       add_control(104, TFT_HEIGHT - 34, PAGE_UP, imgPageUp, encoderTopLine > 0);
       add_control(344, TFT_HEIGHT - 34, PAGE_DOWN, imgPageDown, encoderTopLine + LCD_HEIGHT < screen_items);

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 93df6eb961..02e3354d93 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -640,10 +640,12 @@ static void drawAxisValue(const AxisEnum axis) {
 static void moveAxis(const AxisEnum axis, const int8_t direction) {
   quick_feedback();
 
-  if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
-    drawMessage("Too cold");
-    return;
-  }
+  #if ENABLED(PREVENT_COLD_EXTRUSION)
+    if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
+      drawMessage("Too cold");
+      return;
+    }
+  #endif
 
   const float diff = motionAxisState.currentStepSize * direction;
 

commit 84fd0eff17d089e3f75f6585d4bba47f15c00ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 23 21:33:22 2021 -0500

    üé® Macros for optional arguments (#21969)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 6923bdd71c..93df6eb961 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -711,11 +711,7 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
       drawMessage(msg);
     #endif
 
-    ui.manual_move.soon(axis
-      #if MULTI_E_MANUAL
-        , motionAxisState.e_selection
-      #endif
-    );
+    ui.manual_move.soon(axis OPTARG(MULTI_E_MANUAL, motionAxisState.e_selection));
   }
 
   drawAxisValue(axis);

commit 000388b1d9e38a2678e8235a5d4dc3163f853c02
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 20 17:12:18 2021 -0500

    üé® MULTI_MANUAL => MULTI_E_MANUAL

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index a5539990d5..6923bdd71c 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -712,7 +712,7 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
     #endif
 
     ui.manual_move.soon(axis
-      #if MULTI_MANUAL
+      #if MULTI_E_MANUAL
         , motionAxisState.e_selection
       #endif
     );

commit 2e0a1f1afff71a29e5fb5eb99c509d0de5384087
Author: David <davidtgbe@hotmail.com>
Date:   Wed Apr 28 11:08:21 2021 +0200

    Color UI Move Screen for 320x240 TFT (#21708)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index e9ea4b0827..a5539990d5 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -170,6 +170,13 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
       image = targetTemperature > 0 ? imgChamberHeated : imgChamber;
     }
   #endif
+  #if HAS_TEMP_COOLER
+    else if (Heater == H_COOLER) {
+      if (currentTemperature <= 26) Color = COLOR_COLD;
+      if (currentTemperature > 26) Color = COLOR_RED;
+      image = targetTemperature > 26 ? imgCoolerHot : imgCooler;
+    }
+  #endif
 
   tft.add_image(8, 28, image, Color);
 
@@ -234,6 +241,9 @@ void MarlinUI::draw_status_screen() {
       #ifdef ITEM_CHAMBER
         case ITEM_CHAMBER: draw_heater_status(x, y, H_CHAMBER); break;
       #endif
+      #ifdef ITEM_COOLER
+        case ITEM_COOLER: draw_heater_status(x, y, H_COOLER); break;
+      #endif
       #ifdef ITEM_FAN
         case ITEM_FAN: draw_fan_status(x, y, blink); break;
       #endif
@@ -543,7 +553,6 @@ struct MotionAxisState {
   float currentStepSize = 10.0;
   int z_selection = Z_SELECTION_Z;
   uint8_t e_selection = 0;
-  bool homming = false;
   bool blocked = false;
   char message[32];
 };
@@ -608,16 +617,11 @@ static void drawMessage(const char *msg) {
   tft.add_text(0, 0, COLOR_YELLOW, msg);
 }
 
-static void drawAxisValue(AxisEnum axis) {
-  const float value =
-    #if HAS_BED_PROBE
-      axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE ?
-      probe.offset.z :
-    #endif
-    NATIVE_TO_LOGICAL(
-      ui.manual_move.processing ? destination[axis] : SUM_TERN(IS_KINEMATIC, current_position[axis], ui.manual_move.offset),
-      axis
-    );
+static void drawAxisValue(const AxisEnum axis) {
+  const float value = (
+    TERN_(HAS_BED_PROBE, axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE ? probe.offset.z :)
+    ui.manual_move.axis_value(axis)
+  );
   xy_int_t pos;
   uint16_t color;
   switch (axis) {
@@ -633,7 +637,7 @@ static void drawAxisValue(AxisEnum axis) {
   tft.add_text(0, 0, color, tft_string);
 }
 
-static void moveAxis(AxisEnum axis, const int8_t direction) {
+static void moveAxis(const AxisEnum axis, const int8_t direction) {
   quick_feedback();
 
   if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
@@ -699,23 +703,11 @@ static void moveAxis(AxisEnum axis, const int8_t direction) {
     #endif
 
     // Get the new position
+    const bool limited = ui.manual_move.apply_diff(axis, diff, min, max);
     #if IS_KINEMATIC
-      ui.manual_move.offset += diff;
-      if (direction < 0)
-        NOLESS(ui.manual_move.offset, min - current_position[axis]);
-      else
-        NOMORE(ui.manual_move.offset, max - current_position[axis]);
+      UNUSED(limited);
     #else
-      current_position[axis] += diff;
-      const char *msg = NUL_STR; // clear the error
-      if (direction < 0 && current_position[axis] < min) {
-        current_position[axis] = min;
-        msg = GET_TEXT(MSG_LCD_SOFT_ENDSTOPS);
-      }
-      else if (direction > 0 && current_position[axis] > max) {
-        current_position[axis] = max;
-        msg = GET_TEXT(MSG_LCD_SOFT_ENDSTOPS);
-      }
+      PGM_P const msg = limited ? GET_TEXT(MSG_LCD_SOFT_ENDSTOPS) : NUL_STR;
       drawMessage(msg);
     #endif
 
@@ -913,7 +905,4 @@ void MarlinUI::move_axis_screen() {
   TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));
 }
 
-#undef BTN_WIDTH
-#undef BTN_HEIGHT
-
 #endif // HAS_UI_480x320

commit dfcccb63a1f3d8098ebfef8c64753f735bcf0b0d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 24 05:20:55 2021 -0500

    Use temperature accessors

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 0d7e01683f..e9ea4b0827 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -636,7 +636,7 @@ static void drawAxisValue(AxisEnum axis) {
 static void moveAxis(AxisEnum axis, const int8_t direction) {
   quick_feedback();
 
-  if (axis == E_AXIS && thermalManager.temp_hotend[motionAxisState.e_selection].celsius < EXTRUDE_MINTEMP) {
+  if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
     drawMessage("Too cold");
     return;
   }

commit a29aefc9c0c02c23862fded29e3f950ead339238
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 24 01:29:30 2021 -0500

    Move last bootscreen delay to end of setup (#21665)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 3150aff058..0d7e01683f 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -60,6 +60,7 @@ void MarlinUI::tft_idle() {
 }
 
 #if ENABLED(SHOW_BOOTSCREEN)
+
   void MarlinUI::show_bootscreen() {
     tft.queue.reset();
 
@@ -81,9 +82,13 @@ void MarlinUI::tft_idle() {
     #endif
 
     tft.queue.sync();
-    safe_delay(BOOTSCREEN_TIMEOUT);
+  }
+
+  void MarlinUI::bootscreen_completion(const millis_t sofar) {
+    if ((BOOTSCREEN_TIMEOUT) > sofar) safe_delay((BOOTSCREEN_TIMEOUT) - sofar);
     clear_lcd();
   }
+
 #endif
 
 void MarlinUI::draw_kill_screen() {

commit c4620bb5285438e41fa4c39229aa2a39859877ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 23 20:19:23 2021 -0500

    Add whole-degree accessors, simplify some temperature-related features (#21685)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 4d5a0b4fda..3150aff058 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -117,18 +117,18 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
   celsius_t currentTemperature, targetTemperature;
 
   if (Heater >= 0) { // HotEnd
-    currentTemperature = thermalManager.degHotend(Heater);
+    currentTemperature = thermalManager.wholeDegHotend(Heater);
     targetTemperature = thermalManager.degTargetHotend(Heater);
   }
   #if HAS_HEATED_BED
     else if (Heater == H_BED) {
-      currentTemperature = thermalManager.degBed();
+      currentTemperature = thermalManager.wholeDegBed();
       targetTemperature = thermalManager.degTargetBed();
     }
   #endif
   #if HAS_TEMP_CHAMBER
     else if (Heater == H_CHAMBER) {
-      currentTemperature = thermalManager.degChamber();
+      currentTemperature = thermalManager.wholeDegChamber();
       #if HAS_HEATED_CHAMBER
         targetTemperature = thermalManager.degTargetChamber();
       #else
@@ -138,7 +138,7 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
   #endif
   #if HAS_TEMP_COOLER
     else if (Heater == H_COOLER) {
-      currentTemperature = thermalManager.degCooler();
+      currentTemperature = thermalManager.wholeDegCooler();
       targetTemperature = TERN(HAS_COOLER, thermalManager.degTargetCooler(), ABSOLUTE_ZERO);
     }
   #endif
@@ -438,7 +438,7 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft_string.add('E');
     tft_string.add((char)('1' + extruder));
     tft_string.add(' ');
-    tft_string.add(i16tostr3rj(thermalManager.degHotend(extruder)));
+    tft_string.add(i16tostr3rj(thermalManager.wholeDegHotend(extruder)));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.add(" / ");
     tft_string.add(i16tostr3rj(thermalManager.degTargetHotend(extruder)));

commit 528b9bd8729656d7ebcd3dc7898ceddc2f377354
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 16 02:43:59 2021 -0500

    Revert experimental NAN patch
    
    Hold changes from #21575 (24a095c) for more testing.

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 4b02b21ea6..4d5a0b4fda 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -492,7 +492,7 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(Z_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-    tft_string.set(ISNAN(ubl.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(ubl.z_values[x_plot][y_plot]));
+    tft_string.set(isnan(ubl.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(ubl.z_values[x_plot][y_plot]));
     tft_string.trim();
     tft.add_text(120 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 

commit 24a095c5c14b60bcbffc2807d2c8cc8e9af46e90
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 12 16:49:53 2021 -0500

    Reduce math library code size by 3.4KB (#21575)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 4d5a0b4fda..4b02b21ea6 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -492,7 +492,7 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(Z_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-    tft_string.set(isnan(ubl.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(ubl.z_values[x_plot][y_plot]));
+    tft_string.set(ISNAN(ubl.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(ubl.z_values[x_plot][y_plot]));
     tft_string.trim();
     tft.add_text(120 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 

commit 1a2cbe100c279b0dd12a70f5e9179a6f9b555e32
Author: Ramiro Polla <ramiropolla@users.noreply.github.com>
Date:   Fri Apr 9 04:03:34 2021 +0200

    Macros to eliminate 'f + 0.0' (#21568)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 21b280ac75..4d5a0b4fda 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -610,7 +610,7 @@ static void drawAxisValue(AxisEnum axis) {
       probe.offset.z :
     #endif
     NATIVE_TO_LOGICAL(
-      ui.manual_move.processing ? destination[axis] : current_position[axis] + TERN0(IS_KINEMATIC, ui.manual_move.offset),
+      ui.manual_move.processing ? destination[axis] : SUM_TERN(IS_KINEMATIC, current_position[axis], ui.manual_move.offset),
       axis
     );
   xy_int_t pos;

commit 45c1432946547cef4cbe9ac832394ff68526687d
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Thu Apr 1 18:12:00 2021 -0600

    G26 Hilbert Curve followup (#21480)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index a8979d0ca6..21b280ac75 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -462,12 +462,12 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft.set_background(COLOR_BACKGROUND);
     tft.add_rectangle(0, 0, GRID_WIDTH, GRID_HEIGHT, COLOR_WHITE);
 
-    for (uint16_t x = 0; x < GRID_MAX_POINTS_X ; x++)
-      for (uint16_t y = 0; y < GRID_MAX_POINTS_Y ; y++)
+    for (uint16_t x = 0; x < (GRID_MAX_POINTS_X); x++)
+      for (uint16_t y = 0; y < (GRID_MAX_POINTS_Y); y++)
         if (position_is_reachable({ ubl.mesh_index_to_xpos(x), ubl.mesh_index_to_ypos(y) }))
-          tft.add_bar(1 + (x * 2 + 1) * (GRID_WIDTH - 4) / GRID_MAX_POINTS_X / 2, GRID_HEIGHT - 3 - ((y * 2 + 1) * (GRID_HEIGHT - 4) / GRID_MAX_POINTS_Y / 2), 2, 2, COLOR_UBL);
+          tft.add_bar(1 + (x * 2 + 1) * (GRID_WIDTH - 4) / (GRID_MAX_POINTS_X) / 2, GRID_HEIGHT - 3 - ((y * 2 + 1) * (GRID_HEIGHT - 4) / (GRID_MAX_POINTS_Y) / 2), 2, 2, COLOR_UBL);
 
-    tft.add_rectangle((x_plot * 2 + 1) * (GRID_WIDTH - 4) / GRID_MAX_POINTS_X / 2 - 1, GRID_HEIGHT - 5 - ((y_plot * 2 + 1) * (GRID_HEIGHT - 4) / GRID_MAX_POINTS_Y / 2), 6, 6, COLOR_UBL);
+    tft.add_rectangle((x_plot * 2 + 1) * (GRID_WIDTH - 4) / (GRID_MAX_POINTS_X) / 2 - 1, GRID_HEIGHT - 5 - ((y_plot * 2 + 1) * (GRID_HEIGHT - 4) / (GRID_MAX_POINTS_Y) / 2), 6, 6, COLOR_UBL);
 
     const xy_pos_t pos = { ubl.mesh_index_to_xpos(x_plot), ubl.mesh_index_to_ypos(y_plot) },
                    lpos = pos.asLogical();
@@ -512,9 +512,9 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     #if ENABLED(TOUCH_SCREEN)
       touch.clear();
       draw_menu_navigation = false;
-      add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + CONTROL_OFFSET,                    UBL,   ENCODER_STEPS_PER_MENU_ITEM * GRID_MAX_POINTS_X, imgUp);
-      add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + GRID_HEIGHT - CONTROL_OFFSET - 32, UBL, - ENCODER_STEPS_PER_MENU_ITEM * GRID_MAX_POINTS_X, imgDown);
-      add_control(GRID_OFFSET_X + CONTROL_OFFSET,                   GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL, - ENCODER_STEPS_PER_MENU_ITEM, imgLeft);
+      add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + CONTROL_OFFSET,                    UBL,  (ENCODER_STEPS_PER_MENU_ITEM) * (GRID_MAX_POINTS_X), imgUp);
+      add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + GRID_HEIGHT - CONTROL_OFFSET - 32, UBL, -(ENCODER_STEPS_PER_MENU_ITEM) * (GRID_MAX_POINTS_X), imgDown);
+      add_control(GRID_OFFSET_X + CONTROL_OFFSET,                   GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL, -(ENCODER_STEPS_PER_MENU_ITEM), imgLeft);
       add_control(GRID_OFFSET_X + GRID_WIDTH - CONTROL_OFFSET - 32, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL,   ENCODER_STEPS_PER_MENU_ITEM, imgRight);
       add_control(320, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET, CLICK, imgLeveling);
       add_control(224, TFT_HEIGHT - 34, BACK, imgBack);

commit 3b73b115ca9366f0155986b717d4c85c31ed2f80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 29 20:36:37 2021 -0500

    Apply pointer formatting

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 81e4603ea4..a8979d0ca6 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -326,7 +326,7 @@ void MarlinUI::draw_status_screen() {
 }
 
 // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
-void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
+void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char * const value/*=nullptr*/) {
   ui.encoder_direction_normal();
   TERN_(TOUCH_SCREEN, touch.clear());
 
@@ -779,7 +779,7 @@ static void disable_steppers() {
   queue.inject_P(PSTR("M84"));
 }
 
-static void drawBtn(int x, int y, const char* label, intptr_t data, MarlinImage img, uint16_t bgColor, bool enabled = true) {
+static void drawBtn(int x, int y, const char *label, intptr_t data, MarlinImage img, uint16_t bgColor, bool enabled = true) {
   uint16_t width = Images[imgBtn52Rounded].width;
   uint16_t height = Images[imgBtn52Rounded].height;
 

commit e5ff55a1be7646b6159e6dedac50bfbe57e6dfa0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 24 04:11:43 2021 -0500

    Add typedef celsius_t (#21374)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 164785a229..81e4603ea4 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -114,7 +114,7 @@ void MarlinUI::draw_kill_screen() {
 void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
   MarlinImage image = imgHotEnd;
   uint16_t Color;
-  float currentTemperature, targetTemperature;
+  celsius_t currentTemperature, targetTemperature;
 
   if (Heater >= 0) { // HotEnd
     currentTemperature = thermalManager.degHotend(Heater);
@@ -168,13 +168,13 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
 
   tft.add_image(8, 28, image, Color);
 
-  tft_string.set((uint8_t *)i16tostr3rj(currentTemperature + 0.5));
+  tft_string.set((uint8_t *)i16tostr3rj(currentTemperature));
   tft_string.add(LCD_STR_DEGREE);
   tft_string.trim();
   tft.add_text(tft_string.center(80) + 2, 82, Color, tft_string);
 
   if (targetTemperature >= 0) {
-    tft_string.set((uint8_t *)i16tostr3rj(targetTemperature + 0.5));
+    tft_string.set((uint8_t *)i16tostr3rj(targetTemperature));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.trim();
     tft.add_text(tft_string.center(80) + 2, 8, Color, tft_string);

commit b95e548ddbcbc1c088eabc17992d0a06f82ac167
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Sat Mar 6 14:13:28 2021 -0600

    Cooler (for Laser) - M143, M193 (#21255)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 5000aedc39..164785a229 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -136,6 +136,12 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
       #endif
     }
   #endif
+  #if HAS_TEMP_COOLER
+    else if (Heater == H_COOLER) {
+      currentTemperature = thermalManager.degCooler();
+      targetTemperature = TERN(HAS_COOLER, thermalManager.degTargetCooler(), ABSOLUTE_ZERO);
+    }
+  #endif
   else return;
 
   TERN_(TOUCH_SCREEN, if (targetTemperature >= 0) touch.add_control(HEATER, x, y, 80, 120, Heater));

commit c12be1f98cf1efdc6fc1e66c528d5975adc6626c
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Mon Jan 25 08:44:39 2021 +0100

    Graphical TFT fixes, cleanup (#20861)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 4165c3990c..5000aedc39 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -24,7 +24,7 @@
 
 #if HAS_UI_480x320 || HAS_UI_480x272
 
-#include "ui_480x320.h"
+#include "ui_common.h"
 
 #include "../marlinui.h"
 #include "../menu/menu.h"
@@ -45,14 +45,6 @@
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
-#if !HAS_LCD_MENU
-  #error "Seriously? High resolution TFT screen without menu?"
-#endif
-
-#if ENABLED(TOUCH_SCREEN)
-  static bool draw_menu_navigation = false;
-#endif
-
 void MarlinUI::tft_idle() {
   #if ENABLED(TOUCH_SCREEN)
     if (draw_menu_navigation) {
@@ -67,28 +59,6 @@ void MarlinUI::tft_idle() {
   TERN_(TOUCH_SCREEN, touch.idle());
 }
 
-void MarlinUI::init_lcd() {
-  tft.init();
-  tft.set_font(MENU_FONT_NAME);
-  #ifdef SYMBOLS_FONT_NAME
-    tft.add_glyphs(SYMBOLS_FONT_NAME);
-  #endif
-  TERN_(TOUCH_SCREEN, touch.init());
-  clear_lcd();
-}
-
-bool MarlinUI::detected() { return true; }
-
-void MarlinUI::clear_lcd() {
-  #if ENABLED(TOUCH_SCREEN)
-    touch.reset();
-    draw_menu_navigation = false;
-  #endif
-
-  tft.queue.reset();
-  tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_BACKGROUND);
-}
-
 #if ENABLED(SHOW_BOOTSCREEN)
   void MarlinUI::show_bootscreen() {
     tft.queue.reset();
@@ -100,8 +70,8 @@ void MarlinUI::clear_lcd() {
       #define SITE_URL_Y (TFT_HEIGHT - 70)
       tft.set_background(COLOR_BACKGROUND);
     #else
-      #define BOOT_LOGO_W 480   // MarlinLogo480x320x16
-      #define BOOT_LOGO_H 320
+      #define BOOT_LOGO_W TFT_WIDTH   // MarlinLogo480x320x16
+      #define BOOT_LOGO_H TFT_HEIGHT
       #define SITE_URL_Y (TFT_HEIGHT - 90)
     #endif
     tft.add_image((TFT_WIDTH - BOOT_LOGO_W) / 2, (TFT_HEIGHT - BOOT_LOGO_H) / 2, imgBootScreen);
@@ -150,22 +120,22 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
     currentTemperature = thermalManager.degHotend(Heater);
     targetTemperature = thermalManager.degTargetHotend(Heater);
   }
-#if HAS_HEATED_BED
-  else if (Heater == H_BED) {
-    currentTemperature = thermalManager.degBed();
-    targetTemperature = thermalManager.degTargetBed();
-  }
-#endif // HAS_HEATED_BED
-#if HAS_TEMP_CHAMBER
-  else if (Heater == H_CHAMBER) {
-    currentTemperature = thermalManager.degChamber();
-    #if HAS_HEATED_CHAMBER
-      targetTemperature = thermalManager.degTargetChamber();
-    #else
-      targetTemperature = ABSOLUTE_ZERO;
-    #endif
-  }
-#endif // HAS_TEMP_CHAMBER
+  #if HAS_HEATED_BED
+    else if (Heater == H_BED) {
+      currentTemperature = thermalManager.degBed();
+      targetTemperature = thermalManager.degTargetBed();
+    }
+  #endif
+  #if HAS_TEMP_CHAMBER
+    else if (Heater == H_CHAMBER) {
+      currentTemperature = thermalManager.degChamber();
+      #if HAS_HEATED_CHAMBER
+        targetTemperature = thermalManager.degTargetChamber();
+      #else
+        targetTemperature = ABSOLUTE_ZERO;
+      #endif
+    }
+  #endif
   else return;
 
   TERN_(TOUCH_SCREEN, if (targetTemperature >= 0) touch.add_control(HEATER, x, y, 80, 120, Heater));
@@ -178,17 +148,17 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
     if (currentTemperature >= 50) Color = COLOR_HOTEND;
   }
   #if HAS_HEATED_BED
-  else if (Heater == H_BED) {
-    if (currentTemperature >= 50) Color = COLOR_HEATED_BED;
-    image = targetTemperature > 0 ? imgBedHeated : imgBed;
-  }
-  #endif // HAS_HEATED_BED
+    else if (Heater == H_BED) {
+      if (currentTemperature >= 50) Color = COLOR_HEATED_BED;
+      image = targetTemperature > 0 ? imgBedHeated : imgBed;
+    }
+  #endif
   #if HAS_TEMP_CHAMBER
-  else if (Heater == H_CHAMBER) {
-    if (currentTemperature >= 50) Color = COLOR_CHAMBER;
-    image = targetTemperature > 0 ? imgChamberHeated : imgChamber;
-  }
-  #endif // HAS_TEMP_CHAMBER
+    else if (Heater == H_CHAMBER) {
+      if (currentTemperature >= 50) Color = COLOR_CHAMBER;
+      image = targetTemperature > 0 ? imgChamberHeated : imgChamber;
+    }
+  #endif
 
   tft.add_image(8, 28, image, Color);
 
@@ -233,7 +203,7 @@ void MarlinUI::draw_status_screen() {
   TERN_(TOUCH_SCREEN, touch.clear());
 
   // heaters and fan
-  uint16_t i, x, y = POS_Y;
+  uint16_t i, x, y = TFT_STATUS_TOP_Y;
 
   for (i = 0 ; i < ITEMS_COUNT; i++) {
     x = (TFT_WIDTH / ITEMS_COUNT - 80) / 2  + (TFT_WIDTH * i / ITEMS_COUNT);
@@ -349,49 +319,6 @@ void MarlinUI::draw_status_screen() {
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_STATUS_MESSAGE, tft_string);
 }
 
-// Draw a static item with no left-right margin required. Centered by default.
-void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
-  menu_item(row);
-  tft_string.set(pstr, itemIndex, itemString);
-  if (vstr)
-    tft_string.add(vstr);
-  tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
-}
-
-// Draw a generic menu item with pre_char (if selected) and post_char
-void MenuItemBase::_draw(const bool sel, const uint8_t row, PGM_P const pstr, const char pre_char, const char post_char) {
-  menu_item(row, sel);
-
-  uint8_t *string = (uint8_t *)pstr;
-  MarlinImage image = noImage;
-  switch (*string) {
-    case 0x01: image = imgRefresh; break;  // LCD_STR_REFRESH
-    case 0x02: image = imgDirectory; break;  // LCD_STR_FOLDER
-  }
-
-  uint8_t offset = MENU_TEXT_X_OFFSET;
-  if (image != noImage) {
-    string++;
-    offset = 42;
-    tft.add_image(5, 5, image, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
-  }
-
-  tft_string.set(string, itemIndex, itemString);
-  tft.add_text(offset, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-}
-
-// Draw a menu item with a (potentially) editable value
-void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr, const char* const data, const bool pgm) {
-  menu_item(row, sel);
-
-  tft_string.set(pstr, itemIndex, itemString);
-  tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-  if (data) {
-    tft_string.set(data);
-    tft.add_text(TFT_WIDTH - MENU_TEXT_X_OFFSET - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-  }
-}
-
 // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
 void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
   ui.encoder_direction_normal();
@@ -491,16 +418,8 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
   #endif
 }
 
-#if ENABLED(SDSUPPORT)
-  void MenuItem_sdbase::draw(const bool sel, const uint8_t row, PGM_P const, CardReader &theCard, const bool isDir) {
-    menu_item(row, sel);
-    if (isDir)
-      tft.add_image(5, 5, imgDirectory, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
-    tft.add_text(42, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, theCard.longest_filename());
-  }
-#endif
-
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
+
   void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
     #if ENABLED(TOUCH_SCREEN)
       touch.clear();
@@ -521,6 +440,7 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft_string.trim();
     tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
   }
+
 #endif // ADVANCED_PAUSE_FEATURE
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
@@ -570,18 +490,18 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft_string.trim();
     tft.add_text(120 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
-
-    tft.canvas(GRID_OFFSET_X + (GRID_WIDTH - 48) / 2, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET - 5, 48, MENU_ITEM_HEIGHT);
+    constexpr uint8_t w = (TFT_WIDTH) / 10;
+    tft.canvas(GRID_OFFSET_X + (GRID_WIDTH - w) / 2, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET - 5, w, MENU_ITEM_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(ui8tostr3rj(x_plot));
     tft_string.trim();
-    tft.add_text(tft_string.center(48), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+    tft.add_text(tft_string.center(w), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
-    tft.canvas(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET + 16 - 24, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2, 48, MENU_ITEM_HEIGHT);
+    tft.canvas(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET + 16 - 24, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2, w, MENU_ITEM_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(ui8tostr3rj(y_plot));
     tft_string.trim();
-    tft.add_text(tft_string.center(48), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+    tft.add_text(tft_string.center(w), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
     #if ENABLED(TOUCH_SCREEN)
       touch.clear();
@@ -596,97 +516,6 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
   }
 #endif // AUTO_BED_LEVELING_UBL
 
-#if ENABLED(TOUCH_SCREEN_CALIBRATION)
-  void MarlinUI::touch_calibration_screen() {
-    uint16_t x, y;
-
-    calibrationState calibration_stage = touch_calibration.get_calibration_state();
-
-    if (calibration_stage == CALIBRATION_NONE) {
-      defer_status_screen(true);
-      clear_lcd();
-      calibration_stage = touch_calibration.calibration_start();
-    }
-    else {
-      x = touch_calibration.calibration_points[_MIN(calibration_stage - 1, CALIBRATION_BOTTOM_RIGHT)].x;
-      y = touch_calibration.calibration_points[_MIN(calibration_stage - 1, CALIBRATION_BOTTOM_RIGHT)].y;
-      tft.canvas(x - 15, y - 15, 31, 31);
-      tft.set_background(COLOR_BACKGROUND);
-    }
-
-    touch.clear();
-
-    if (calibration_stage < CALIBRATION_SUCCESS) {
-      switch (calibration_stage) {
-        case CALIBRATION_TOP_LEFT: tft_string.set(GET_TEXT(MSG_TOP_LEFT)); break;
-        case CALIBRATION_BOTTOM_LEFT: tft_string.set(GET_TEXT(MSG_BOTTOM_LEFT)); break;
-        case CALIBRATION_TOP_RIGHT: tft_string.set(GET_TEXT(MSG_TOP_RIGHT)); break;
-        case CALIBRATION_BOTTOM_RIGHT: tft_string.set(GET_TEXT(MSG_BOTTOM_RIGHT)); break;
-        default: break;
-      }
-
-      x = touch_calibration.calibration_points[calibration_stage].x;
-      y = touch_calibration.calibration_points[calibration_stage].y;
-
-      tft.canvas(x - 15, y - 15, 31, 31);
-      tft.set_background(COLOR_BACKGROUND);
-      tft.add_bar(0, 15, 31, 1, COLOR_TOUCH_CALIBRATION);
-      tft.add_bar(15, 0, 1, 31, COLOR_TOUCH_CALIBRATION);
-
-      touch.add_control(CALIBRATE, 0, 0, TFT_WIDTH, TFT_HEIGHT, uint32_t(x) << 16 | uint32_t(y));
-    }
-    else {
-      tft_string.set(calibration_stage == CALIBRATION_SUCCESS ? GET_TEXT(MSG_CALIBRATION_COMPLETED) : GET_TEXT(MSG_CALIBRATION_FAILED));
-      defer_status_screen(false);
-      touch_calibration.calibration_end();
-      touch.add_control(BACK, 0, 0, TFT_WIDTH, TFT_HEIGHT);
-    }
-
-    tft.canvas(0, (TFT_HEIGHT - tft_string.font_height()) >> 1, TFT_WIDTH, tft_string.font_height());
-    tft.set_background(COLOR_BACKGROUND);
-    tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
-  }
-#endif // TOUCH_SCREEN_CALIBRATION
-
-void menu_line(const uint8_t row, uint16_t color) {
-  tft.canvas(0, 4 + (MENU_ITEM_HEIGHT + 2) * row, TFT_WIDTH, MENU_ITEM_HEIGHT);
-  tft.set_background(color);
-}
-
-void menu_pause_option();
-
-void menu_item(const uint8_t row, bool sel ) {
-  #if ENABLED(TOUCH_SCREEN)
-    if (row == 0) {
-      touch.clear();
-      draw_menu_navigation = TERN(ADVANCED_PAUSE_FEATURE, ui.currentScreen != menu_pause_option, true);
-    }
-  #endif
-
-  menu_line(row, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
-  #if ENABLED(TOUCH_SCREEN)
-    const TouchControlType tct = TERN(SINGLE_TOUCH_NAVIGATION, true, sel) ? MENU_CLICK : MENU_ITEM;
-    touch.add_control(tct, 0, 4 + (MENU_ITEM_HEIGHT + 2) * row, TFT_WIDTH, MENU_ITEM_HEIGHT, encoderTopLine + row);
-  #endif
-}
-
-void lcd_moveto(const lcd_uint_t col, const lcd_uint_t row) {
-  #define TFT_COL_WIDTH ((TFT_WIDTH) / (LCD_WIDTH))
-  tft.canvas(col * TFT_COL_WIDTH, 4 + 45 * row, TFT_WIDTH - (col * TFT_COL_WIDTH), 43);
-  tft.set_background(COLOR_BACKGROUND);
-}
-
-int lcd_put_u8str_max_P(PGM_P utf8_str_P, pixel_len_t max_length) {
-  tft_string.set(utf8_str_P);
-  tft_string.trim();
-  tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-  return tft_string.width();
-}
-
-int lcd_put_u8str_max(const char * utf8_str, pixel_len_t max_length) {
-  return lcd_put_u8str_max_P(utf8_str, max_length);
-}
-
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "../../feature/babystep.h"
 #endif
@@ -889,37 +718,14 @@ static void moveAxis(AxisEnum axis, const int8_t direction) {
   drawAxisValue(axis);
 }
 
-static void e_plus() {
-  moveAxis(E_AXIS, 1);
-}
-
-static void e_minus() {
-  moveAxis(E_AXIS, -1);
-}
-
-static void x_minus() {
-  moveAxis(X_AXIS, -1);
-}
-
-static void x_plus() {
-  moveAxis(X_AXIS, 1);
-}
-
-static void y_plus() {
-  moveAxis(Y_AXIS, 1);
-}
-
-static void y_minus() {
-  moveAxis(Y_AXIS, -1);
-}
-
-static void z_plus() {
-  moveAxis(Z_AXIS, 1);
-}
-
-static void z_minus() {
-  moveAxis(Z_AXIS, -1);
-}
+static void e_plus()  { moveAxis(E_AXIS, 1);  }
+static void e_minus() { moveAxis(E_AXIS, -1); }
+static void x_minus() { moveAxis(X_AXIS, -1); }
+static void x_plus()  { moveAxis(X_AXIS, 1);  }
+static void y_plus()  { moveAxis(Y_AXIS, 1);  }
+static void y_minus() { moveAxis(Y_AXIS, -1); }
+static void z_plus()  { moveAxis(Z_AXIS, 1);  }
+static void z_minus() { moveAxis(Z_AXIS, -1); }
 
 #if ENABLED(TOUCH_SCREEN)
   static void e_select() {
@@ -1002,8 +808,9 @@ void MarlinUI::move_axis_screen() {
 
   const bool busy = printingIsActive();
 
-  // if we have baby step and we are printing, select baby step
-  if (busy && ENABLED(BABYSTEP_ZPROBE_OFFSET)) motionAxisState.z_selection = Z_SELECTION_Z_PROBE;
+  // Babysteps during printing? Select babystep for Z probe offset
+  if (busy && ENABLED(BABYSTEP_ZPROBE_OFFSET))
+    motionAxisState.z_selection = Z_SELECTION_Z_PROBE;
 
   // ROW 1 -> E- Y- CurY Z+
   int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
@@ -1089,7 +896,7 @@ void MarlinUI::move_axis_screen() {
     TERN_(HAS_TFT_XPT2046, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
   }
 
-  // alinged with x+
+  // aligned with x+
   drawBtn(xplus_x, TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
 
   TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));

commit d33fe2378c25d258b02440aef6cc31e36753f98f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 22 15:01:19 2021 -0600

    Move common strings (#20846)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index b6ffb4592f..4165c3990c 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -867,7 +867,7 @@ static void moveAxis(AxisEnum axis, const int8_t direction) {
         NOMORE(ui.manual_move.offset, max - current_position[axis]);
     #else
       current_position[axis] += diff;
-      const char *msg = PSTR(""); // clear the error
+      const char *msg = NUL_STR; // clear the error
       if (direction < 0 && current_position[axis] < min) {
         current_position[axis] = min;
         msg = GET_TEXT(MSG_LCD_SOFT_ENDSTOPS);

commit 9f53738339db172635d38e7a78c87890d7b5a636
Author: Jason Smith <jason.inet@gmail.com>
Date:   Fri Jan 1 18:08:10 2021 -0800

    Fix UBL mesh edit delta moves (#20620)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index f7955fb1bd..b6ffb4592f 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -867,17 +867,16 @@ static void moveAxis(AxisEnum axis, const int8_t direction) {
         NOMORE(ui.manual_move.offset, max - current_position[axis]);
     #else
       current_position[axis] += diff;
+      const char *msg = PSTR(""); // clear the error
       if (direction < 0 && current_position[axis] < min) {
         current_position[axis] = min;
-        drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
+        msg = GET_TEXT(MSG_LCD_SOFT_ENDSTOPS);
       }
       else if (direction > 0 && current_position[axis] > max) {
         current_position[axis] = max;
-        drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
-      }
-      else {
-        drawMessage(""); // clear the error
+        msg = GET_TEXT(MSG_LCD_SOFT_ENDSTOPS);
       }
+      drawMessage(msg);
     #endif
 
     ui.manual_move.soon(axis

commit 41e4124af9cba37f1e7cd598f47bf21c51d00488
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Dec 29 02:26:35 2020 -0300

    Support 4.3" (480x272) Color UI display (#20334)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index ddd08e4d0d..f7955fb1bd 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -22,7 +22,7 @@
 
 #include "../../inc/MarlinConfigPre.h"
 
-#if HAS_UI_480x320
+#if HAS_UI_480x320 || HAS_UI_480x272
 
 #include "ui_480x320.h"
 
@@ -56,9 +56,9 @@
 void MarlinUI::tft_idle() {
   #if ENABLED(TOUCH_SCREEN)
     if (draw_menu_navigation) {
-      add_control(104, 286, PAGE_UP, imgPageUp, encoderTopLine > 0);
-      add_control(344, 286, PAGE_DOWN, imgPageDown, encoderTopLine + LCD_HEIGHT < screen_items);
-      add_control(224, 286, BACK, imgBack);
+      add_control(104, TFT_HEIGHT - 34, PAGE_UP, imgPageUp, encoderTopLine > 0);
+      add_control(344, TFT_HEIGHT - 34, PAGE_DOWN, imgPageDown, encoderTopLine + LCD_HEIGHT < screen_items);
+      add_control(224, TFT_HEIGHT - 34, BACK, imgBack);
       draw_menu_navigation = false;
     }
   #endif
@@ -259,10 +259,12 @@ void MarlinUI::draw_status_screen() {
     }
   }
 
+  y += TERN(HAS_UI_480x272, 118, 128);
+
   // coordinates
-  tft.canvas(4, 132, TFT_WIDTH - 8, 34);
+  tft.canvas(4, y, TFT_WIDTH - 8, FONT_LINE_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);
-  tft.add_rectangle(0, 0, TFT_WIDTH - 8, 34, COLOR_AXIS_HOMED);
+  tft.add_rectangle(0, 0, TFT_WIDTH - 8, FONT_LINE_HEIGHT, COLOR_AXIS_HOMED);
 
   tft.add_text( 16, 3, COLOR_AXIS_HOMED , "X");
   tft.add_text(192, 3, COLOR_AXIS_HOMED , "Y");
@@ -290,10 +292,11 @@ void MarlinUI::draw_status_screen() {
     offset -= tft_string.width();
   }
   tft.add_text(455 - tft_string.width() - offset, 3, not_homed ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
-  TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 4, 132, TFT_WIDTH - 8, 34));
+  TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 4, y, TFT_WIDTH - 8, FONT_LINE_HEIGHT));
 
+  y += TERN(HAS_UI_480x272, 38, 48);
   // feed rate
-  tft.canvas(96, 180, 100, 32);
+  tft.canvas(96, y, 100, 32);
   tft.set_background(COLOR_BACKGROUND);
   uint16_t color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
   tft.add_image(0, 0, imgFeedRate, color);
@@ -303,7 +306,7 @@ void MarlinUI::draw_status_screen() {
   TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE, 96, 176, 100, 32));
 
   // flow rate
-  tft.canvas(284, 180, 100, 32);
+  tft.canvas(284, y, 100, 32);
   tft.set_background(COLOR_BACKGROUND);
   color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
   tft.add_image(0, 0, imgFlowRate, color);
@@ -312,36 +315,38 @@ void MarlinUI::draw_status_screen() {
   tft.add_text(36, 1, color , tft_string);
   TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE, 284, 176, 100, 32, active_extruder));
 
+  #if ENABLED(TOUCH_SCREEN)
+    add_control(404, y, menu_main, imgSettings);
+    TERN_(SDSUPPORT, add_control(12, y, menu_media, imgSD, !printingIsActive(), COLOR_CONTROL_ENABLED, card.isMounted() && printingIsActive() ? COLOR_BUSY : COLOR_CONTROL_DISABLED));
+  #endif
+
+  y += TERN(HAS_UI_480x272, 36, 44);
   // print duration
   char buffer[14];
   duration_t elapsed = print_job_timer.duration();
   elapsed.toDigital(buffer);
 
-  tft.canvas((TFT_WIDTH - 128) / 2, 224, 128, 29);
+  tft.canvas((TFT_WIDTH - 128) / 2, y, 128, 29);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(buffer);
   tft.add_text(tft_string.center(128), 0, COLOR_PRINT_TIME, tft_string);
 
+  y += TERN(HAS_UI_480x272, 28, 36);
   // progress bar
   const uint8_t progress = ui.get_progress_percent();
-  tft.canvas(4, 260, TFT_WIDTH - 8, 9);
+  tft.canvas(4, y, TFT_WIDTH - 8, 9);
   tft.set_background(COLOR_PROGRESS_BG);
   tft.add_rectangle(0, 0, TFT_WIDTH - 8, 9, COLOR_PROGRESS_FRAME);
   if (progress)
     tft.add_bar(1, 1, ((TFT_WIDTH - 10) * progress) / 100, 7, COLOR_PROGRESS_BAR);
 
+  y += 20;
   // status message
-  tft.canvas(0, 280, TFT_WIDTH, 29);
+  tft.canvas(0, y, TFT_WIDTH, FONT_LINE_HEIGHT - 5);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(status_message);
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_STATUS_MESSAGE, tft_string);
-
-
-  #if ENABLED(TOUCH_SCREEN)
-    add_control(404, 180, menu_main, imgSettings);
-    TERN_(SDSUPPORT, add_control(12, 180, menu_media, imgSD, !printingIsActive(), COLOR_CONTROL_ENABLED, card.isMounted() && printingIsActive() ? COLOR_BUSY : COLOR_CONTROL_DISABLED));
-  #endif
 }
 
 // Draw a static item with no left-right margin required. Centered by default.
@@ -450,9 +455,9 @@ void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const valu
 
 void TFT::draw_edit_screen_buttons() {
   #if ENABLED(TOUCH_SCREEN)
-    add_control(64, 256, DECREASE, imgDecrease);
-    add_control(352, 256, INCREASE, imgIncrease);
-    add_control(208, 256, CLICK, imgConfirm);
+    add_control(64, TFT_HEIGHT - 64, DECREASE, imgDecrease);
+    add_control(352, TFT_HEIGHT - 64, INCREASE, imgIncrease);
+    add_control(208, TFT_HEIGHT - 64, CLICK, imgConfirm);
   #endif
 }
 
@@ -481,8 +486,8 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
   }
   #if ENABLED(TOUCH_SCREEN)
-    add_control(88, 256, CANCEL, imgCancel, true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
-    add_control(328, 256, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
+    add_control(88, TFT_HEIGHT - 64, CANCEL, imgCancel, true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
+    add_control(328, TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
   #endif
 }
 
@@ -541,7 +546,7 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     const xy_pos_t pos = { ubl.mesh_index_to_xpos(x_plot), ubl.mesh_index_to_ypos(y_plot) },
                    lpos = pos.asLogical();
 
-    tft.canvas(320, GRID_OFFSET_Y + (GRID_HEIGHT - 43) / 2 - 43, 120, 43);
+    tft.canvas(320, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2 - MENU_ITEM_HEIGHT, 120, MENU_ITEM_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(X_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
@@ -549,7 +554,7 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft_string.trim();
     tft.add_text(120 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
-    tft.canvas(320, GRID_OFFSET_Y + (GRID_HEIGHT - 43) / 2, 120, 43);
+    tft.canvas(320, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2, 120, MENU_ITEM_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(Y_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
@@ -557,7 +562,7 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft_string.trim();
     tft.add_text(120 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
-    tft.canvas(320, GRID_OFFSET_Y + (GRID_HEIGHT - 43) / 2 + 43, 120, 43);
+    tft.canvas(320, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2 + MENU_ITEM_HEIGHT, 120, MENU_ITEM_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(Z_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
@@ -566,13 +571,13 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft.add_text(120 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
 
-    tft.canvas(GRID_OFFSET_X + (GRID_WIDTH - 48) / 2, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET - 5, 48, 43);
+    tft.canvas(GRID_OFFSET_X + (GRID_WIDTH - 48) / 2, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET - 5, 48, MENU_ITEM_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(ui8tostr3rj(x_plot));
     tft_string.trim();
     tft.add_text(tft_string.center(48), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
-    tft.canvas(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET + 16 - 24, GRID_OFFSET_Y + (GRID_HEIGHT - 43) / 2, 48, 43);
+    tft.canvas(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET + 16 - 24, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2, 48, MENU_ITEM_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(ui8tostr3rj(y_plot));
     tft_string.trim();
@@ -586,7 +591,7 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
       add_control(GRID_OFFSET_X + CONTROL_OFFSET,                   GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL, - ENCODER_STEPS_PER_MENU_ITEM, imgLeft);
       add_control(GRID_OFFSET_X + GRID_WIDTH - CONTROL_OFFSET - 32, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL,   ENCODER_STEPS_PER_MENU_ITEM, imgRight);
       add_control(320, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET, CLICK, imgLeveling);
-      add_control(224, 286, BACK, imgBack);
+      add_control(224, TFT_HEIGHT - 34, BACK, imgBack);
     #endif
   }
 #endif // AUTO_BED_LEVELING_UBL
@@ -644,7 +649,7 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
 #endif // TOUCH_SCREEN_CALIBRATION
 
 void menu_line(const uint8_t row, uint16_t color) {
-  tft.canvas(0, 4 + 45 * row, TFT_WIDTH, 43);
+  tft.canvas(0, 4 + (MENU_ITEM_HEIGHT + 2) * row, TFT_WIDTH, MENU_ITEM_HEIGHT);
   tft.set_background(color);
 }
 
@@ -661,7 +666,7 @@ void menu_item(const uint8_t row, bool sel ) {
   menu_line(row, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
   #if ENABLED(TOUCH_SCREEN)
     const TouchControlType tct = TERN(SINGLE_TOUCH_NAVIGATION, true, sel) ? MENU_CLICK : MENU_ITEM;
-    touch.add_control(tct, 0, 4 + 45 * row, TFT_WIDTH, 43, encoderTopLine + row);
+    touch.add_control(tct, 0, 4 + (MENU_ITEM_HEIGHT + 2) * row, TFT_WIDTH, MENU_ITEM_HEIGHT, encoderTopLine + row);
   #endif
 }
 

commit 185e31d322bb699e171d4c6a6fc5d6f34b40cfd3
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Mon Dec 28 02:11:36 2020 -0300

    Fix Menu Mixer for Color UI (#20566)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 8d05ab7df4..ddd08e4d0d 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -445,6 +445,10 @@ void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const valu
     #endif
   }
 
+  tft.draw_edit_screen_buttons();
+}
+
+void TFT::draw_edit_screen_buttons() {
   #if ENABLED(TOUCH_SCREEN)
     add_control(64, 256, DECREASE, imgDecrease);
     add_control(352, 256, INCREASE, imgIncrease);
@@ -661,6 +665,23 @@ void menu_item(const uint8_t row, bool sel ) {
   #endif
 }
 
+void lcd_moveto(const lcd_uint_t col, const lcd_uint_t row) {
+  #define TFT_COL_WIDTH ((TFT_WIDTH) / (LCD_WIDTH))
+  tft.canvas(col * TFT_COL_WIDTH, 4 + 45 * row, TFT_WIDTH - (col * TFT_COL_WIDTH), 43);
+  tft.set_background(COLOR_BACKGROUND);
+}
+
+int lcd_put_u8str_max_P(PGM_P utf8_str_P, pixel_len_t max_length) {
+  tft_string.set(utf8_str_P);
+  tft_string.trim();
+  tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+  return tft_string.width();
+}
+
+int lcd_put_u8str_max(const char * utf8_str, pixel_len_t max_length) {
+  return lcd_put_u8str_max_P(utf8_str, max_length);
+}
+
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "../../feature/babystep.h"
 #endif

commit cfcfc8047afb09bd3da8d3e7bb49f066a977e6d6
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sun Dec 27 19:10:53 2020 -0800

    Small / Large Boot Screen option for TFT_COLOR_UI (#20578)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 9e387b2402..8d05ab7df4 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -90,18 +90,24 @@ void MarlinUI::clear_lcd() {
 }
 
 #if ENABLED(SHOW_BOOTSCREEN)
-  #undef BOOTSCREEN_TIMEOUT
-  #define BOOTSCREEN_TIMEOUT 5000
-
   void MarlinUI::show_bootscreen() {
     tft.queue.reset();
 
     tft.canvas(0, 0, TFT_WIDTH, TFT_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft.add_image(142, 130, imgBootScreen);  // MarlinLogo195x59x16
-
+    #if ENABLED(BOOT_MARLIN_LOGO_SMALL)
+      #define BOOT_LOGO_W 195   // MarlinLogo195x59x16
+      #define BOOT_LOGO_H  59
+      #define SITE_URL_Y (TFT_HEIGHT - 70)
+      tft.set_background(COLOR_BACKGROUND);
+    #else
+      #define BOOT_LOGO_W 480   // MarlinLogo480x320x16
+      #define BOOT_LOGO_H 320
+      #define SITE_URL_Y (TFT_HEIGHT - 90)
+    #endif
+    tft.add_image((TFT_WIDTH - BOOT_LOGO_W) / 2, (TFT_HEIGHT - BOOT_LOGO_H) / 2, imgBootScreen);
     #ifdef WEBSITE_URL
-      tft.add_text(8, 250, COLOR_WEBSITE_URL, WEBSITE_URL);
+      tft_string.set(WEBSITE_URL);
+      tft.add_text(tft_string.center(TFT_WIDTH), SITE_URL_Y, COLOR_WEBSITE_URL, tft_string);
     #endif
 
     tft.queue.sync();

commit 9c9113e225d746a0391528ee1d1ff4a08a07b28c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 11 18:21:56 2020 -0600

    Better animated boot screen

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 343d187d26..9e387b2402 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -90,10 +90,6 @@ void MarlinUI::clear_lcd() {
 }
 
 #if ENABLED(SHOW_BOOTSCREEN)
-  #ifndef BOOTSCREEN_TIMEOUT
-    #define BOOTSCREEN_TIMEOUT 1500
-  #endif
-
   #undef BOOTSCREEN_TIMEOUT
   #define BOOTSCREEN_TIMEOUT 5000
 
@@ -112,7 +108,7 @@ void MarlinUI::clear_lcd() {
     safe_delay(BOOTSCREEN_TIMEOUT);
     clear_lcd();
   }
-#endif // SHOW_BOOTSCREEN
+#endif
 
 void MarlinUI::draw_kill_screen() {
   tft.queue.reset();

commit 8fd8772a6fffe63d99d0b88aec7a77d283df8584
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 29 19:06:40 2020 -0600

    Adjust axis homed / trusted methods (#20323)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index d152acdf77..343d187d26 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -262,43 +262,38 @@ void MarlinUI::draw_status_screen() {
   tft.set_background(COLOR_BACKGROUND);
   tft.add_rectangle(0, 0, TFT_WIDTH - 8, 34, COLOR_AXIS_HOMED);
 
-  uint16_t color;
-  uint16_t offset;
-  bool is_homed;
-
   tft.add_text( 16, 3, COLOR_AXIS_HOMED , "X");
   tft.add_text(192, 3, COLOR_AXIS_HOMED , "Y");
   tft.add_text(330, 3, COLOR_AXIS_HOMED , "Z");
 
-  is_homed = TEST(axis_homed, X_AXIS);
-  tft_string.set(blink & !is_homed ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
-  tft.add_text(102 - tft_string.width(), 3, is_homed ? COLOR_AXIS_HOMED : COLOR_AXIS_NOT_HOMED, tft_string);
+  bool not_homed = axis_should_home(X_AXIS);
+  tft_string.set(blink && not_homed ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
+  tft.add_text(102 - tft_string.width(), 3, not_homed ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
 
-  is_homed = TEST(axis_homed, Y_AXIS);
-  tft_string.set(blink & !is_homed ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
-  tft.add_text(280 - tft_string.width(), 3, is_homed ? COLOR_AXIS_HOMED : COLOR_AXIS_NOT_HOMED, tft_string);
+  not_homed = axis_should_home(Y_AXIS);
+  tft_string.set(blink && not_homed ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
+  tft.add_text(280 - tft_string.width(), 3, not_homed ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
 
-  is_homed = TEST(axis_homed, Z_AXIS);
-  if (blink & !is_homed) {
+  uint16_t offset = 32;
+  not_homed = axis_should_home(Z_AXIS);
+  if (blink && not_homed)
     tft_string.set("?");
-    offset = 32; // ".00"
-  }
   else {
     const float z = LOGICAL_Z_POSITION(current_position.z);
     tft_string.set(ftostr52sp((int16_t)z));
     tft_string.rtrim();
-    offset = tft_string.width();
+    offset += tft_string.width();
 
     tft_string.set(ftostr52sp(z));
-    offset += 32 - tft_string.width();
+    offset -= tft_string.width();
   }
-  tft.add_text(455 - tft_string.width() - offset, 3, is_homed ? COLOR_AXIS_HOMED : COLOR_AXIS_NOT_HOMED, tft_string);
+  tft.add_text(455 - tft_string.width() - offset, 3, not_homed ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
   TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 4, 132, TFT_WIDTH - 8, 34));
 
   // feed rate
   tft.canvas(96, 180, 100, 32);
   tft.set_background(COLOR_BACKGROUND);
-  color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
+  uint16_t color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
   tft.add_image(0, 0, imgFeedRate, color);
   tft_string.set(i16tostr3rj(feedrate_percentage));
   tft_string.add('%');

commit 28e315cd69ba3b5c2049f31937b5876abb1a0578
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Nov 20 10:46:18 2020 -0300

    SINGLE_TOUCH_NAVIGATION Follow Up (#20213)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 285e55631a..d152acdf77 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -659,7 +659,7 @@ void menu_item(const uint8_t row, bool sel ) {
 
   menu_line(row, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
   #if ENABLED(TOUCH_SCREEN)
-    const TouchControlType tct = TERN(SINGLE_TOUCH_NAVIGATION, true, sel) ? CLICK : MENU_ITEM;
+    const TouchControlType tct = TERN(SINGLE_TOUCH_NAVIGATION, true, sel) ? MENU_CLICK : MENU_ITEM;
     touch.add_control(tct, 0, 4 + 45 * row, TFT_WIDTH, 43, encoderTopLine + row);
   #endif
 }

commit 75924edcf8e129e90119b86ec8a61176bff12c95
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Nov 17 23:07:34 2020 -0300

    COLOR_UI without TOUCH_SCREEN üëçüèª (#20178)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 6d1043068d..285e55631a 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -49,7 +49,9 @@
   #error "Seriously? High resolution TFT screen without menu?"
 #endif
 
-static bool draw_menu_navigation = false;
+#if ENABLED(TOUCH_SCREEN)
+  static bool draw_menu_navigation = false;
+#endif
 
 void MarlinUI::tft_idle() {
   #if ENABLED(TOUCH_SCREEN)
@@ -897,35 +899,37 @@ static void z_minus() {
   moveAxis(Z_AXIS, -1);
 }
 
-static void e_select() {
-  motionAxisState.e_selection++;
-  if (motionAxisState.e_selection >= EXTRUDERS) {
-    motionAxisState.e_selection = 0;
-  }
+#if ENABLED(TOUCH_SCREEN)
+  static void e_select() {
+    motionAxisState.e_selection++;
+    if (motionAxisState.e_selection >= EXTRUDERS) {
+      motionAxisState.e_selection = 0;
+    }
 
-  quick_feedback();
-  drawCurESelection();
-  drawAxisValue(E_AXIS);
-}
+    quick_feedback();
+    drawCurESelection();
+    drawAxisValue(E_AXIS);
+  }
 
-static void do_home() {
-  quick_feedback();
-  drawMessage(GET_TEXT(MSG_LEVEL_BED_HOMING));
-  queue.inject_P(G28_STR);
-  // Disable touch until home is done
-  TERN_(HAS_TFT_XPT2046, touch.disable());
-  drawAxisValue(E_AXIS);
-  drawAxisValue(X_AXIS);
-  drawAxisValue(Y_AXIS);
-  drawAxisValue(Z_AXIS);
-}
+  static void do_home() {
+    quick_feedback();
+    drawMessage(GET_TEXT(MSG_LEVEL_BED_HOMING));
+    queue.inject_P(G28_STR);
+    // Disable touch until home is done
+    TERN_(HAS_TFT_XPT2046, touch.disable());
+    drawAxisValue(E_AXIS);
+    drawAxisValue(X_AXIS);
+    drawAxisValue(Y_AXIS);
+    drawAxisValue(Z_AXIS);
+  }
 
-static void step_size() {
-  motionAxisState.currentStepSize = motionAxisState.currentStepSize / 10.0;
-  if (motionAxisState.currentStepSize < 0.0015) motionAxisState.currentStepSize = 10.0;
-  quick_feedback();
-  drawCurStepValue();
-}
+  static void step_size() {
+    motionAxisState.currentStepSize = motionAxisState.currentStepSize / 10.0;
+    if (motionAxisState.currentStepSize < 0.0015) motionAxisState.currentStepSize = 10.0;
+    quick_feedback();
+    drawCurStepValue();
+  }
+#endif
 
 #if HAS_BED_PROBE
   static void z_select() {
@@ -1021,7 +1025,7 @@ void MarlinUI::move_axis_screen() {
   motionAxisState.zTypePos.x = x;
   motionAxisState.zTypePos.y = y;
   drawCurZSelection();
-  #if HAS_BED_PROBE
+  #if BOTH(HAS_BED_PROBE, TOUCH_SCREEN)
     if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
   #endif
 

commit 7930fd9ce8409034cf4227c6da53d7f2e7db663a
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Nov 17 05:45:01 2020 -0300

    Use  intptr types (simulator) (#20142)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index ac76e81c93..6d1043068d 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -941,7 +941,7 @@ static void disable_steppers() {
   queue.inject_P(PSTR("M84"));
 }
 
-static void drawBtn(int x, int y, const char* label, int32_t data, MarlinImage img, uint16_t bgColor, bool enabled = true) {
+static void drawBtn(int x, int y, const char* label, intptr_t data, MarlinImage img, uint16_t bgColor, bool enabled = true) {
   uint16_t width = Images[imgBtn52Rounded].width;
   uint16_t height = Images[imgBtn52Rounded].height;
 
@@ -982,11 +982,11 @@ void MarlinUI::move_axis_screen() {
   // ROW 1 -> E- Y- CurY Z+
   int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
 
-  drawBtn(x, y, "E+", (int32_t)e_plus, imgUp, E_BTN_COLOR, !busy);
+  drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy);
 
   spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
   x += BTN_WIDTH + spacing;
-  drawBtn(x, y, "Y+", (int32_t)y_plus, imgUp, Y_BTN_COLOR, !busy);
+  drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy);
 
   // Cur Y
   x += BTN_WIDTH;
@@ -995,7 +995,7 @@ void MarlinUI::move_axis_screen() {
   drawAxisValue(Y_AXIS);
 
   x += spacing;
-  drawBtn(x, y, "Z+", (int32_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+  drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
 
   // ROW 2 -> "Ex"  X-  HOME X+  "Z"
   y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
@@ -1005,24 +1005,24 @@ void MarlinUI::move_axis_screen() {
   motionAxisState.eNamePos.x = x;
   motionAxisState.eNamePos.y = y;
   drawCurESelection();
-  TERN_(HAS_TFT_XPT2046, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (int32_t)e_select));
+  TERN_(HAS_TFT_XPT2046, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
 
   x += BTN_WIDTH + spacing;
-  drawBtn(x, y, "X-", (int32_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
+  drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
 
   x += BTN_WIDTH + spacing; //imgHome is 64x64
-  TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (int32_t)do_home, imgHome, !busy));
+  TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
 
   x += BTN_WIDTH + spacing;
   uint16_t xplus_x = x;
-  drawBtn(x, y, "X+", (int32_t)x_plus, imgRight, X_BTN_COLOR, !busy);
+  drawBtn(x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
 
   x += BTN_WIDTH + spacing;
   motionAxisState.zTypePos.x = x;
   motionAxisState.zTypePos.y = y;
   drawCurZSelection();
   #if HAS_BED_PROBE
-    if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (int32_t)z_select);
+    if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
   #endif
 
   // ROW 3 -> E- CurX Y-  Z-
@@ -1030,7 +1030,7 @@ void MarlinUI::move_axis_screen() {
   x = X_MARGIN;
   spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
 
-  drawBtn(x, y, "E-", (int32_t)e_minus, imgDown, E_BTN_COLOR, !busy);
+  drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
 
   // Cur E
   motionAxisState.eValuePos.x = x;
@@ -1043,10 +1043,10 @@ void MarlinUI::move_axis_screen() {
   drawAxisValue(X_AXIS);
 
   x += BTN_WIDTH + spacing;
-  drawBtn(x, y, "Y-", (int32_t)y_minus, imgDown, Y_BTN_COLOR, !busy);
+  drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy);
 
   x += BTN_WIDTH + spacing;
-  drawBtn(x, y, "Z-", (int32_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+  drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
 
   // Cur Z
   motionAxisState.zValuePos.x = x;
@@ -1060,11 +1060,11 @@ void MarlinUI::move_axis_screen() {
   motionAxisState.stepValuePos.y = y;
   if (!busy) {
     drawCurStepValue();
-    TERN_(HAS_TFT_XPT2046, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (int32_t)step_size));
+    TERN_(HAS_TFT_XPT2046, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
   }
 
   // alinged with x+
-  drawBtn(xplus_x, TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT, "off", (int32_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
+  drawBtn(xplus_x, TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
 
   TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));
 }

commit ea371618da71dc43e6aee95a8e479c8797867e04
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sun Nov 15 19:39:58 2020 -0300

    Add Touch Calibration screen (#20049)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index e2bbdcde7f..ac76e81c93 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -589,33 +589,37 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
 #endif // AUTO_BED_LEVELING_UBL
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
-  void MarlinUI::touch_calibration() {
-    static uint16_t x, y;
+  void MarlinUI::touch_calibration_screen() {
+    uint16_t x, y;
 
-    calibrationState calibration_stage = touch.get_calibration_state();
+    calibrationState calibration_stage = touch_calibration.get_calibration_state();
 
     if (calibration_stage == CALIBRATION_NONE) {
       defer_status_screen(true);
       clear_lcd();
-      calibration_stage = touch.calibration_start();
+      calibration_stage = touch_calibration.calibration_start();
     }
     else {
+      x = touch_calibration.calibration_points[_MIN(calibration_stage - 1, CALIBRATION_BOTTOM_RIGHT)].x;
+      y = touch_calibration.calibration_points[_MIN(calibration_stage - 1, CALIBRATION_BOTTOM_RIGHT)].y;
       tft.canvas(x - 15, y - 15, 31, 31);
       tft.set_background(COLOR_BACKGROUND);
     }
 
-    x = 20; y = 20;
     touch.clear();
 
     if (calibration_stage < CALIBRATION_SUCCESS) {
       switch (calibration_stage) {
-        case CALIBRATION_POINT_1: tft_string.set("Top Left"); break;
-        case CALIBRATION_POINT_2: y = TFT_HEIGHT - 21; tft_string.set("Bottom Left"); break;
-        case CALIBRATION_POINT_3: x = TFT_WIDTH  - 21; tft_string.set("Top Right"); break;
-        case CALIBRATION_POINT_4: x = TFT_WIDTH  - 21; y = TFT_HEIGHT - 21; tft_string.set("Bottom Right"); break;
+        case CALIBRATION_TOP_LEFT: tft_string.set(GET_TEXT(MSG_TOP_LEFT)); break;
+        case CALIBRATION_BOTTOM_LEFT: tft_string.set(GET_TEXT(MSG_BOTTOM_LEFT)); break;
+        case CALIBRATION_TOP_RIGHT: tft_string.set(GET_TEXT(MSG_TOP_RIGHT)); break;
+        case CALIBRATION_BOTTOM_RIGHT: tft_string.set(GET_TEXT(MSG_BOTTOM_RIGHT)); break;
         default: break;
       }
 
+      x = touch_calibration.calibration_points[calibration_stage].x;
+      y = touch_calibration.calibration_points[calibration_stage].y;
+
       tft.canvas(x - 15, y - 15, 31, 31);
       tft.set_background(COLOR_BACKGROUND);
       tft.add_bar(0, 15, 31, 1, COLOR_TOUCH_CALIBRATION);
@@ -624,9 +628,9 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
       touch.add_control(CALIBRATE, 0, 0, TFT_WIDTH, TFT_HEIGHT, uint32_t(x) << 16 | uint32_t(y));
     }
     else {
-      tft_string.set(calibration_stage == CALIBRATION_SUCCESS ? "Calibration Completed" : "Calibration Failed");
+      tft_string.set(calibration_stage == CALIBRATION_SUCCESS ? GET_TEXT(MSG_CALIBRATION_COMPLETED) : GET_TEXT(MSG_CALIBRATION_FAILED));
       defer_status_screen(false);
-      touch.calibration_end();
+      touch_calibration.calibration_end();
       touch.add_control(BACK, 0, 0, TFT_WIDTH, TFT_HEIGHT);
     }
 

commit b5ef6995233f4166a726bbda7d53aa9e2eecc472
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 7 16:20:19 2020 -0600

    TFT cleanup

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 9ba5c1b157..e2bbdcde7f 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -428,21 +428,21 @@ void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const valu
   extern screenFunc_t _manual_move_func_ptr;
   if (ui.currentScreen != _manual_move_func_ptr && !ui.external_control) {
 
-    #define SLIDER_LENGHT 336
+    #define SLIDER_LENGTH 336
     #define SLIDER_Y_POSITION 186
 
-    tft.canvas((TFT_WIDTH - SLIDER_LENGHT) / 2, SLIDER_Y_POSITION, SLIDER_LENGHT, 16);
+    tft.canvas((TFT_WIDTH - SLIDER_LENGTH) / 2, SLIDER_Y_POSITION, SLIDER_LENGTH, 16);
     tft.set_background(COLOR_BACKGROUND);
 
-    int16_t position = (SLIDER_LENGHT - 2) * ui.encoderPosition / maxEditValue;
+    int16_t position = (SLIDER_LENGTH - 2) * ui.encoderPosition / maxEditValue;
     tft.add_bar(0, 7, 1, 2, ui.encoderPosition == 0 ? COLOR_SLIDER_INACTIVE : COLOR_SLIDER);
     tft.add_bar(1, 6, position, 4, COLOR_SLIDER);
-    tft.add_bar(position + 1, 6, SLIDER_LENGHT - 2 - position, 4, COLOR_SLIDER_INACTIVE);
-    tft.add_bar(SLIDER_LENGHT - 1, 7, 1, 2, int32_t(ui.encoderPosition) == maxEditValue ? COLOR_SLIDER : COLOR_SLIDER_INACTIVE);
+    tft.add_bar(position + 1, 6, SLIDER_LENGTH - 2 - position, 4, COLOR_SLIDER_INACTIVE);
+    tft.add_bar(SLIDER_LENGTH - 1, 7, 1, 2, int32_t(ui.encoderPosition) == maxEditValue ? COLOR_SLIDER : COLOR_SLIDER_INACTIVE);
 
     #if ENABLED(TOUCH_SCREEN)
-      tft.add_image((SLIDER_LENGHT - 8) * ui.encoderPosition / maxEditValue, 0, imgSlider, COLOR_SLIDER);
-      touch.add_control(SLIDER, (TFT_WIDTH - SLIDER_LENGHT) / 2, SLIDER_Y_POSITION - 8, SLIDER_LENGHT, 32, maxEditValue);
+      tft.add_image((SLIDER_LENGTH - 8) * ui.encoderPosition / maxEditValue, 0, imgSlider, COLOR_SLIDER);
+      touch.add_control(SLIDER, (TFT_WIDTH - SLIDER_LENGTH) / 2, SLIDER_Y_POSITION - 8, SLIDER_LENGTH, 32, maxEditValue);
     #endif
   }
 

commit 2fdeceda58808015a93d1cb2a1137c0528668a3e
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Nov 7 06:00:29 2020 -0300

    Color UI single touch menu navigation (#20053)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 0c44a3151b..9ba5c1b157 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -652,7 +652,10 @@ void menu_item(const uint8_t row, bool sel ) {
   #endif
 
   menu_line(row, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
-  TERN_(TOUCH_SCREEN, touch.add_control(sel ? CLICK : MENU_ITEM, 0, 4 + 45 * row, TFT_WIDTH, 43, encoderTopLine + row));
+  #if ENABLED(TOUCH_SCREEN)
+    const TouchControlType tct = TERN(SINGLE_TOUCH_NAVIGATION, true, sel) ? CLICK : MENU_ITEM;
+    touch.add_control(tct, 0, 4 + 45 * row, TFT_WIDTH, 43, encoderTopLine + row);
+  #endif
 }
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)

commit 0be276482ebd5545dc11d97fd7a50c7673ad584d
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Nov 3 20:21:15 2020 -0300

    Show un-mounted media slot (#20005)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 1003f32e7c..0c44a3151b 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -341,7 +341,7 @@ void MarlinUI::draw_status_screen() {
 
   #if ENABLED(TOUCH_SCREEN)
     add_control(404, 180, menu_main, imgSettings);
-    TERN_(SDSUPPORT, add_control(12, 180, menu_media, imgSD, card.isMounted() && !printingIsActive(), COLOR_CONTROL_ENABLED, card.isMounted() && printingIsActive() ? COLOR_BUSY : COLOR_CONTROL_DISABLED));
+    TERN_(SDSUPPORT, add_control(12, 180, menu_media, imgSD, !printingIsActive(), COLOR_CONTROL_ENABLED, card.isMounted() && printingIsActive() ? COLOR_BUSY : COLOR_CONTROL_DISABLED));
   #endif
 }
 

commit ec23e37a4a31d12febc06922d3fa68446f58d7fb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Oct 24 17:13:10 2020 -0500

    Clean up comments, USB flash, NULLs

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index b67e041349..1003f32e7c 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -457,7 +457,7 @@ void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const valu
 void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const bool yesno, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
   uint16_t line = 1;
 
-  if (string == NULL) line++;
+  if (!string) line++;
 
   menu_line(line++);
   tft_string.set(pref);
@@ -945,7 +945,7 @@ static void drawBtn(int x, int y, const char* label, int32_t data, MarlinImage i
   tft.add_image(0, 0, imgBtn52Rounded, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
 
   // TODO: Make an add_text() taking a font arg
-  if (label != NULL) {
+  if (label) {
     tft_string.set(label);
     tft_string.trim();
     tft.add_text(tft_string.center(width), height / 2 - tft_string.font_height() / 2, bgColor, tft_string);

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 3dab9418f5..b67e041349 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -26,7 +26,7 @@
 
 #include "ui_480x320.h"
 
-#include "../ultralcd.h"
+#include "../marlinui.h"
 #include "../menu/menu.h"
 #include "../../libs/numtostr.h"
 

commit 193c0a52d9f1fbd31e42a29734f551aa26ed269a
Author: Earle F. Philhower, III <earlephilhower@yahoo.com>
Date:   Mon Oct 12 14:48:04 2020 -0700

    Add loose soft endstop state, apply to UBL fine-tune (#19681)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 549cbc4d9b..3dab9418f5 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -813,27 +813,9 @@ static void moveAxis(AxisEnum axis, const int8_t direction) {
   }
 
   if (!ui.manual_move.processing) {
-    // Start with no limits to movement
-    float min = current_position[axis] - 1000,
-          max = current_position[axis] + 1000;
-
-    // Limit to software endstops, if enabled
-    #if HAS_SOFTWARE_ENDSTOPS
-      if (soft_endstops_enabled) switch (axis) {
-        case X_AXIS:
-          TERN_(MIN_SOFTWARE_ENDSTOP_X, min = soft_endstop.min.x);
-          TERN_(MAX_SOFTWARE_ENDSTOP_X, max = soft_endstop.max.x);
-          break;
-        case Y_AXIS:
-          TERN_(MIN_SOFTWARE_ENDSTOP_Y, min = soft_endstop.min.y);
-          TERN_(MAX_SOFTWARE_ENDSTOP_Y, max = soft_endstop.max.y);
-          break;
-        case Z_AXIS:
-          TERN_(MIN_SOFTWARE_ENDSTOP_Z, min = soft_endstop.min.z);
-          TERN_(MAX_SOFTWARE_ENDSTOP_Z, max = soft_endstop.max.z);
-        default: break;
-      }
-    #endif // HAS_SOFTWARE_ENDSTOPS
+    // Get motion limit from software endstops, if any
+    float min, max;
+    soft_endstop.get_manual_axis_limits(axis, min, max);
 
     // Delta limits XY based on the current offset from center
     // This assumes the center is 0,0

commit ea78514ff3551ff9570d07530c7c0a48d3fc2354
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Wed Sep 30 22:06:32 2020 -0300

    Fix Move Screen with disabled Touch (#19558)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index ffc619e8dc..549cbc4d9b 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -924,7 +924,7 @@ static void do_home() {
   drawMessage(GET_TEXT(MSG_LEVEL_BED_HOMING));
   queue.inject_P(G28_STR);
   // Disable touch until home is done
-  touch.disable();
+  TERN_(HAS_TFT_XPT2046, touch.disable());
   drawAxisValue(E_AXIS);
   drawAxisValue(X_AXIS);
   drawAxisValue(Y_AXIS);
@@ -972,14 +972,14 @@ static void drawBtn(int x, int y, const char* label, int32_t data, MarlinImage i
     tft.add_image(0, 0, img, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
   }
 
-  if (enabled) touch.add_control(BUTTON, x, y, width, height, data);
+  TERN_(HAS_TFT_XPT2046, if (enabled) touch.add_control(BUTTON, x, y, width, height, data));
 }
 
 void MarlinUI::move_axis_screen() {
   // Reset
   defer_status_screen(true);
   motionAxisState.blocked = false;
-  touch.enable();
+  TERN_(HAS_TFT_XPT2046, touch.enable());
 
   ui.clear_lcd();
 
@@ -1016,13 +1016,13 @@ void MarlinUI::move_axis_screen() {
   motionAxisState.eNamePos.x = x;
   motionAxisState.eNamePos.y = y;
   drawCurESelection();
-  if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (int32_t)e_select);
+  TERN_(HAS_TFT_XPT2046, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (int32_t)e_select));
 
   x += BTN_WIDTH + spacing;
   drawBtn(x, y, "X-", (int32_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
 
   x += BTN_WIDTH + spacing; //imgHome is 64x64
-  add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (int32_t)do_home, imgHome, !busy);
+  TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (int32_t)do_home, imgHome, !busy));
 
   x += BTN_WIDTH + spacing;
   uint16_t xplus_x = x;
@@ -1071,13 +1071,13 @@ void MarlinUI::move_axis_screen() {
   motionAxisState.stepValuePos.y = y;
   if (!busy) {
     drawCurStepValue();
-    touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (int32_t)step_size);
+    TERN_(HAS_TFT_XPT2046, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (int32_t)step_size));
   }
 
   // alinged with x+
   drawBtn(xplus_x, TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT, "off", (int32_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
 
-  add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack);
+  TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));
 }
 
 #undef BTN_WIDTH

commit 178a1da165162f59a8a4a98d038ac4d2eef6c674
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Sep 25 16:58:28 2020 -0300

    TFT: No timeout on Move Screen (#19426)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index b5b332910b..ffc619e8dc 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -956,24 +956,17 @@ static void drawBtn(int x, int y, const char* label, int32_t data, MarlinImage i
   uint16_t width = Images[imgBtn52Rounded].width;
   uint16_t height = Images[imgBtn52Rounded].height;
 
-  tft.queue.sync(); //need sync to change font
-
   if (!enabled) bgColor = COLOR_CONTROL_DISABLED;
 
   tft.canvas(x, y, width, height);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_image(0, 0, imgBtn52Rounded, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
 
+  // TODO: Make an add_text() taking a font arg
   if (label != NULL) {
-    tft.set_font(Helvetica12Bold);
-    tft_string.set_font(Helvetica12Bold);
     tft_string.set(label);
     tft_string.trim();
     tft.add_text(tft_string.center(width), height / 2 - tft_string.font_height() / 2, bgColor, tft_string);
-
-    tft.queue.sync();
-    tft_string.set_font(Helvetica18);
-    tft.set_font(Helvetica18);
   }
   else {
     tft.add_image(0, 0, img, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
@@ -984,6 +977,7 @@ static void drawBtn(int x, int y, const char* label, int32_t data, MarlinImage i
 
 void MarlinUI::move_axis_screen() {
   // Reset
+  defer_status_screen(true);
   motionAxisState.blocked = false;
   touch.enable();
 

commit 8e0fac897b2ab0352059d5f9bd2d6293ae7d9bbf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 20 18:24:05 2020 -0500

    Whitespace cleanup

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index d6409c1dca..b5b332910b 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -608,7 +608,7 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     touch.clear();
 
     if (calibration_stage < CALIBRATION_SUCCESS) {
-      switch(calibration_stage) {
+      switch (calibration_stage) {
         case CALIBRATION_POINT_1: tft_string.set("Top Left"); break;
         case CALIBRATION_POINT_2: y = TFT_HEIGHT - 21; tft_string.set("Bottom Left"); break;
         case CALIBRATION_POINT_3: x = TFT_WIDTH  - 21; tft_string.set("Top Right"); break;

commit 5b56d6698a2a9b78a5dd40446bcb606cbfff010d
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Thu Sep 17 08:52:21 2020 -0300

    Move screen for Color UI (#19386)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index c9f0bfd0e9..d6409c1dca 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -291,6 +291,7 @@ void MarlinUI::draw_status_screen() {
     offset += 32 - tft_string.width();
   }
   tft.add_text(455 - tft_string.width() - offset, 3, is_homed ? COLOR_AXIS_HOMED : COLOR_AXIS_NOT_HOMED, tft_string);
+  TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 4, 132, TFT_WIDTH - 8, 34));
 
   // feed rate
   tft.canvas(96, 180, 100, 32);
@@ -654,4 +655,438 @@ void menu_item(const uint8_t row, bool sel ) {
   TERN_(TOUCH_SCREEN, touch.add_control(sel ? CLICK : MENU_ITEM, 0, 4 + 45 * row, TFT_WIDTH, 43, encoderTopLine + row));
 }
 
+#if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+  #include "../../feature/babystep.h"
+#endif
+
+#if HAS_BED_PROBE
+  #include "../../module/probe.h"
+#endif
+
+#define Z_SELECTION_Z 1
+#define Z_SELECTION_Z_PROBE -1
+
+struct MotionAxisState {
+  xy_int_t xValuePos, yValuePos, zValuePos, eValuePos, stepValuePos, zTypePos, eNamePos;
+  float currentStepSize = 10.0;
+  int z_selection = Z_SELECTION_Z;
+  uint8_t e_selection = 0;
+  bool homming = false;
+  bool blocked = false;
+  char message[32];
+};
+
+MotionAxisState motionAxisState;
+
+#define E_BTN_COLOR COLOR_YELLOW
+#define X_BTN_COLOR COLOR_CORAL_RED
+#define Y_BTN_COLOR COLOR_VIVID_GREEN
+#define Z_BTN_COLOR COLOR_LIGHT_BLUE
+
+#define BTN_WIDTH 64
+#define BTN_HEIGHT 52
+#define X_MARGIN 20
+#define Y_MARGIN 15
+
+static void quick_feedback() {
+  #if HAS_CHIRP
+    ui.chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
+    #if BOTH(HAS_LCD_MENU, USE_BEEPER)
+      for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
+    #elif HAS_LCD_MENU
+      delay(10);
+    #endif
+  #endif
+}
+
+#define CUR_STEP_VALUE_WIDTH 104
+static void drawCurStepValue() {
+  tft_string.set((uint8_t *)ftostr52sp(motionAxisState.currentStepSize));
+  tft_string.add("mm");
+  tft.canvas(motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT);
+  tft.set_background(COLOR_BACKGROUND);
+  tft.add_text(tft_string.center(CUR_STEP_VALUE_WIDTH), 0, COLOR_AXIS_HOMED, tft_string);
+}
+
+static void drawCurZSelection() {
+  tft_string.set("Z");
+  tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y, tft_string.width(), 34);
+  tft.set_background(COLOR_BACKGROUND);
+  tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
+  tft.queue.sync();
+  tft_string.set("Offset");
+  tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y + 34, tft_string.width(), 34);
+  tft.set_background(COLOR_BACKGROUND);
+  if (motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
+    tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
+  }
+}
+
+static void drawCurESelection() {
+  tft.canvas(motionAxisState.eNamePos.x, motionAxisState.eNamePos.y, BTN_WIDTH, BTN_HEIGHT);
+  tft.set_background(COLOR_BACKGROUND);
+  tft_string.set("E");
+  tft.add_text(0, 0, E_BTN_COLOR , tft_string);
+  tft.add_text(tft_string.width(), 0, E_BTN_COLOR, ui8tostr3rj(motionAxisState.e_selection));
+}
+
+static void drawMessage(const char *msg) {
+  tft.canvas(X_MARGIN, TFT_HEIGHT - Y_MARGIN - 34, TFT_HEIGHT / 2, 34);
+  tft.set_background(COLOR_BACKGROUND);
+  tft.add_text(0, 0, COLOR_YELLOW, msg);
+}
+
+static void drawAxisValue(AxisEnum axis) {
+  const float value =
+    #if HAS_BED_PROBE
+      axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE ?
+      probe.offset.z :
+    #endif
+    NATIVE_TO_LOGICAL(
+      ui.manual_move.processing ? destination[axis] : current_position[axis] + TERN0(IS_KINEMATIC, ui.manual_move.offset),
+      axis
+    );
+  xy_int_t pos;
+  uint16_t color;
+  switch (axis) {
+    case X_AXIS: pos = motionAxisState.xValuePos; color = X_BTN_COLOR; break;
+    case Y_AXIS: pos = motionAxisState.yValuePos; color = Y_BTN_COLOR; break;
+    case Z_AXIS: pos = motionAxisState.zValuePos; color = Z_BTN_COLOR; break;
+    case E_AXIS: pos = motionAxisState.eValuePos; color = E_BTN_COLOR; break;
+    default: return;
+  }
+  tft.canvas(pos.x, pos.y, BTN_WIDTH + X_MARGIN, BTN_HEIGHT);
+  tft.set_background(COLOR_BACKGROUND);
+  tft_string.set(ftostr52sp(value));
+  tft.add_text(0, 0, color, tft_string);
+}
+
+static void moveAxis(AxisEnum axis, const int8_t direction) {
+  quick_feedback();
+
+  if (axis == E_AXIS && thermalManager.temp_hotend[motionAxisState.e_selection].celsius < EXTRUDE_MINTEMP) {
+    drawMessage("Too cold");
+    return;
+  }
+
+  const float diff = motionAxisState.currentStepSize * direction;
+
+  if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
+    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+      const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
+      const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
+      const float bsDiff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
+                  new_probe_offset = probe.offset.z + bsDiff,
+                  new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
+                    , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff
+                    , new_probe_offset
+                  );
+      if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
+        babystep.add_steps(Z_AXIS, babystep_increment);
+        if (do_probe)
+          probe.offset.z = new_offs;
+        else
+          TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
+        drawMessage(""); // clear the error
+        drawAxisValue(axis);
+      }
+      else {
+        drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
+      }
+    #elif HAS_BED_PROBE
+      // only change probe.offset.z
+      probe.offset.z += diff;
+      if (direction < 0 && current_position[axis] < Z_PROBE_OFFSET_RANGE_MIN) {
+        current_position[axis] = Z_PROBE_OFFSET_RANGE_MIN;
+        drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
+      }
+      else if (direction > 0 && current_position[axis] > Z_PROBE_OFFSET_RANGE_MAX) {
+        current_position[axis] = Z_PROBE_OFFSET_RANGE_MAX;
+        drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
+      }
+      else {
+        drawMessage(""); // clear the error
+      }
+      drawAxisValue(axis);
+    #endif
+    return;
+  }
+
+  if (!ui.manual_move.processing) {
+    // Start with no limits to movement
+    float min = current_position[axis] - 1000,
+          max = current_position[axis] + 1000;
+
+    // Limit to software endstops, if enabled
+    #if HAS_SOFTWARE_ENDSTOPS
+      if (soft_endstops_enabled) switch (axis) {
+        case X_AXIS:
+          TERN_(MIN_SOFTWARE_ENDSTOP_X, min = soft_endstop.min.x);
+          TERN_(MAX_SOFTWARE_ENDSTOP_X, max = soft_endstop.max.x);
+          break;
+        case Y_AXIS:
+          TERN_(MIN_SOFTWARE_ENDSTOP_Y, min = soft_endstop.min.y);
+          TERN_(MAX_SOFTWARE_ENDSTOP_Y, max = soft_endstop.max.y);
+          break;
+        case Z_AXIS:
+          TERN_(MIN_SOFTWARE_ENDSTOP_Z, min = soft_endstop.min.z);
+          TERN_(MAX_SOFTWARE_ENDSTOP_Z, max = soft_endstop.max.z);
+        default: break;
+      }
+    #endif // HAS_SOFTWARE_ENDSTOPS
+
+    // Delta limits XY based on the current offset from center
+    // This assumes the center is 0,0
+    #if ENABLED(DELTA)
+      if (axis != Z_AXIS && axis != E_AXIS) {
+        max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
+        min = -max;
+      }
+    #endif
+
+    // Get the new position
+    #if IS_KINEMATIC
+      ui.manual_move.offset += diff;
+      if (direction < 0)
+        NOLESS(ui.manual_move.offset, min - current_position[axis]);
+      else
+        NOMORE(ui.manual_move.offset, max - current_position[axis]);
+    #else
+      current_position[axis] += diff;
+      if (direction < 0 && current_position[axis] < min) {
+        current_position[axis] = min;
+        drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
+      }
+      else if (direction > 0 && current_position[axis] > max) {
+        current_position[axis] = max;
+        drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
+      }
+      else {
+        drawMessage(""); // clear the error
+      }
+    #endif
+
+    ui.manual_move.soon(axis
+      #if MULTI_MANUAL
+        , motionAxisState.e_selection
+      #endif
+    );
+  }
+
+  drawAxisValue(axis);
+}
+
+static void e_plus() {
+  moveAxis(E_AXIS, 1);
+}
+
+static void e_minus() {
+  moveAxis(E_AXIS, -1);
+}
+
+static void x_minus() {
+  moveAxis(X_AXIS, -1);
+}
+
+static void x_plus() {
+  moveAxis(X_AXIS, 1);
+}
+
+static void y_plus() {
+  moveAxis(Y_AXIS, 1);
+}
+
+static void y_minus() {
+  moveAxis(Y_AXIS, -1);
+}
+
+static void z_plus() {
+  moveAxis(Z_AXIS, 1);
+}
+
+static void z_minus() {
+  moveAxis(Z_AXIS, -1);
+}
+
+static void e_select() {
+  motionAxisState.e_selection++;
+  if (motionAxisState.e_selection >= EXTRUDERS) {
+    motionAxisState.e_selection = 0;
+  }
+
+  quick_feedback();
+  drawCurESelection();
+  drawAxisValue(E_AXIS);
+}
+
+static void do_home() {
+  quick_feedback();
+  drawMessage(GET_TEXT(MSG_LEVEL_BED_HOMING));
+  queue.inject_P(G28_STR);
+  // Disable touch until home is done
+  touch.disable();
+  drawAxisValue(E_AXIS);
+  drawAxisValue(X_AXIS);
+  drawAxisValue(Y_AXIS);
+  drawAxisValue(Z_AXIS);
+}
+
+static void step_size() {
+  motionAxisState.currentStepSize = motionAxisState.currentStepSize / 10.0;
+  if (motionAxisState.currentStepSize < 0.0015) motionAxisState.currentStepSize = 10.0;
+  quick_feedback();
+  drawCurStepValue();
+}
+
+#if HAS_BED_PROBE
+  static void z_select() {
+    motionAxisState.z_selection *= -1;
+    quick_feedback();
+    drawCurZSelection();
+    drawAxisValue(Z_AXIS);
+  }
+#endif
+
+static void disable_steppers() {
+  quick_feedback();
+  queue.inject_P(PSTR("M84"));
+}
+
+static void drawBtn(int x, int y, const char* label, int32_t data, MarlinImage img, uint16_t bgColor, bool enabled = true) {
+  uint16_t width = Images[imgBtn52Rounded].width;
+  uint16_t height = Images[imgBtn52Rounded].height;
+
+  tft.queue.sync(); //need sync to change font
+
+  if (!enabled) bgColor = COLOR_CONTROL_DISABLED;
+
+  tft.canvas(x, y, width, height);
+  tft.set_background(COLOR_BACKGROUND);
+  tft.add_image(0, 0, imgBtn52Rounded, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
+
+  if (label != NULL) {
+    tft.set_font(Helvetica12Bold);
+    tft_string.set_font(Helvetica12Bold);
+    tft_string.set(label);
+    tft_string.trim();
+    tft.add_text(tft_string.center(width), height / 2 - tft_string.font_height() / 2, bgColor, tft_string);
+
+    tft.queue.sync();
+    tft_string.set_font(Helvetica18);
+    tft.set_font(Helvetica18);
+  }
+  else {
+    tft.add_image(0, 0, img, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
+  }
+
+  if (enabled) touch.add_control(BUTTON, x, y, width, height, data);
+}
+
+void MarlinUI::move_axis_screen() {
+  // Reset
+  motionAxisState.blocked = false;
+  touch.enable();
+
+  ui.clear_lcd();
+
+  TERN_(TOUCH_SCREEN, touch.clear());
+
+  const bool busy = printingIsActive();
+
+  // if we have baby step and we are printing, select baby step
+  if (busy && ENABLED(BABYSTEP_ZPROBE_OFFSET)) motionAxisState.z_selection = Z_SELECTION_Z_PROBE;
+
+  // ROW 1 -> E- Y- CurY Z+
+  int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
+
+  drawBtn(x, y, "E+", (int32_t)e_plus, imgUp, E_BTN_COLOR, !busy);
+
+  spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
+  x += BTN_WIDTH + spacing;
+  drawBtn(x, y, "Y+", (int32_t)y_plus, imgUp, Y_BTN_COLOR, !busy);
+
+  // Cur Y
+  x += BTN_WIDTH;
+  motionAxisState.yValuePos.x = x + 2;
+  motionAxisState.yValuePos.y = y;
+  drawAxisValue(Y_AXIS);
+
+  x += spacing;
+  drawBtn(x, y, "Z+", (int32_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+
+  // ROW 2 -> "Ex"  X-  HOME X+  "Z"
+  y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
+  x = X_MARGIN;
+  spacing = (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4;
+
+  motionAxisState.eNamePos.x = x;
+  motionAxisState.eNamePos.y = y;
+  drawCurESelection();
+  if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (int32_t)e_select);
+
+  x += BTN_WIDTH + spacing;
+  drawBtn(x, y, "X-", (int32_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
+
+  x += BTN_WIDTH + spacing; //imgHome is 64x64
+  add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (int32_t)do_home, imgHome, !busy);
+
+  x += BTN_WIDTH + spacing;
+  uint16_t xplus_x = x;
+  drawBtn(x, y, "X+", (int32_t)x_plus, imgRight, X_BTN_COLOR, !busy);
+
+  x += BTN_WIDTH + spacing;
+  motionAxisState.zTypePos.x = x;
+  motionAxisState.zTypePos.y = y;
+  drawCurZSelection();
+  #if HAS_BED_PROBE
+    if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (int32_t)z_select);
+  #endif
+
+  // ROW 3 -> E- CurX Y-  Z-
+  y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
+  x = X_MARGIN;
+  spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
+
+  drawBtn(x, y, "E-", (int32_t)e_minus, imgDown, E_BTN_COLOR, !busy);
+
+  // Cur E
+  motionAxisState.eValuePos.x = x;
+  motionAxisState.eValuePos.y = y + BTN_HEIGHT + 2;
+  drawAxisValue(E_AXIS);
+
+  // Cur X
+  motionAxisState.xValuePos.x = BTN_WIDTH + (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4; //X- pos
+  motionAxisState.xValuePos.y = y - 10;
+  drawAxisValue(X_AXIS);
+
+  x += BTN_WIDTH + spacing;
+  drawBtn(x, y, "Y-", (int32_t)y_minus, imgDown, Y_BTN_COLOR, !busy);
+
+  x += BTN_WIDTH + spacing;
+  drawBtn(x, y, "Z-", (int32_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+
+  // Cur Z
+  motionAxisState.zValuePos.x = x;
+  motionAxisState.zValuePos.y = y + BTN_HEIGHT + 2;
+  drawAxisValue(Z_AXIS);
+
+  // ROW 4 -> step_size  disable steppers back
+  y = TFT_HEIGHT - Y_MARGIN - 32; //
+  x = TFT_WIDTH / 2 - CUR_STEP_VALUE_WIDTH / 2;
+  motionAxisState.stepValuePos.x = x;
+  motionAxisState.stepValuePos.y = y;
+  if (!busy) {
+    drawCurStepValue();
+    touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (int32_t)step_size);
+  }
+
+  // alinged with x+
+  drawBtn(xplus_x, TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT, "off", (int32_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
+
+  add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack);
+}
+
+#undef BTN_WIDTH
+#undef BTN_HEIGHT
+
 #endif // HAS_UI_480x320

commit c2d5b63a9882dc02f41017a5b2f24363a55fef8d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 8 18:21:44 2020 -0500

    Fix up STATIC_ITEM (#18962)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
index 3eeed903cb..c9f0bfd0e9 100644
--- a/Marlin/src/lcd/tft/ui_480x320.cpp
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -345,11 +345,11 @@ void MarlinUI::draw_status_screen() {
 }
 
 // Draw a static item with no left-right margin required. Centered by default.
-void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const valstr/*=nullptr*/) {
+void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
   menu_item(row);
   tft_string.set(pstr, itemIndex, itemString);
-  if (valstr)
-    tft_string.add(valstr);
+  if (vstr)
+    tft_string.add(vstr);
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
 }
 

commit 117df87d193994f6fbcd46c45573095adf921784
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Thu Jul 30 09:43:19 2020 +0300

    Support for TFT & Touch Screens (#18130)

diff --git a/Marlin/src/lcd/tft/ui_480x320.cpp b/Marlin/src/lcd/tft/ui_480x320.cpp
new file mode 100644
index 0000000000..3eeed903cb
--- /dev/null
+++ b/Marlin/src/lcd/tft/ui_480x320.cpp
@@ -0,0 +1,657 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfigPre.h"
+
+#if HAS_UI_480x320
+
+#include "ui_480x320.h"
+
+#include "../ultralcd.h"
+#include "../menu/menu.h"
+#include "../../libs/numtostr.h"
+
+#include "../../sd/cardreader.h"
+#include "../../module/temperature.h"
+#include "../../module/printcounter.h"
+#include "../../module/planner.h"
+#include "../../module/motion.h"
+
+#if DISABLED(LCD_PROGRESS_BAR) && BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+  #include "../../feature/filwidth.h"
+  #include "../../gcode/parser.h"
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+  #include "../../feature/bedlevel/bedlevel.h"
+#endif
+
+#if !HAS_LCD_MENU
+  #error "Seriously? High resolution TFT screen without menu?"
+#endif
+
+static bool draw_menu_navigation = false;
+
+void MarlinUI::tft_idle() {
+  #if ENABLED(TOUCH_SCREEN)
+    if (draw_menu_navigation) {
+      add_control(104, 286, PAGE_UP, imgPageUp, encoderTopLine > 0);
+      add_control(344, 286, PAGE_DOWN, imgPageDown, encoderTopLine + LCD_HEIGHT < screen_items);
+      add_control(224, 286, BACK, imgBack);
+      draw_menu_navigation = false;
+    }
+  #endif
+
+  tft.queue.async();
+  TERN_(TOUCH_SCREEN, touch.idle());
+}
+
+void MarlinUI::init_lcd() {
+  tft.init();
+  tft.set_font(MENU_FONT_NAME);
+  #ifdef SYMBOLS_FONT_NAME
+    tft.add_glyphs(SYMBOLS_FONT_NAME);
+  #endif
+  TERN_(TOUCH_SCREEN, touch.init());
+  clear_lcd();
+}
+
+bool MarlinUI::detected() { return true; }
+
+void MarlinUI::clear_lcd() {
+  #if ENABLED(TOUCH_SCREEN)
+    touch.reset();
+    draw_menu_navigation = false;
+  #endif
+
+  tft.queue.reset();
+  tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_BACKGROUND);
+}
+
+#if ENABLED(SHOW_BOOTSCREEN)
+  #ifndef BOOTSCREEN_TIMEOUT
+    #define BOOTSCREEN_TIMEOUT 1500
+  #endif
+
+  #undef BOOTSCREEN_TIMEOUT
+  #define BOOTSCREEN_TIMEOUT 5000
+
+  void MarlinUI::show_bootscreen() {
+    tft.queue.reset();
+
+    tft.canvas(0, 0, TFT_WIDTH, TFT_HEIGHT);
+    tft.set_background(COLOR_BACKGROUND);
+    tft.add_image(142, 130, imgBootScreen);  // MarlinLogo195x59x16
+
+    #ifdef WEBSITE_URL
+      tft.add_text(8, 250, COLOR_WEBSITE_URL, WEBSITE_URL);
+    #endif
+
+    tft.queue.sync();
+    safe_delay(BOOTSCREEN_TIMEOUT);
+    clear_lcd();
+  }
+#endif // SHOW_BOOTSCREEN
+
+void MarlinUI::draw_kill_screen() {
+  tft.queue.reset();
+  tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_KILL_SCREEN_BG);
+
+  uint16_t line = 2;
+
+  menu_line(line++, COLOR_KILL_SCREEN_BG);
+  tft_string.set(status_message);
+  tft_string.trim();
+  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
+
+  line++;
+  menu_line(line++, COLOR_KILL_SCREEN_BG);
+  tft_string.set(GET_TEXT(MSG_HALTED));
+  tft_string.trim();
+  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
+
+  menu_line(line++, COLOR_KILL_SCREEN_BG);
+  tft_string.set(GET_TEXT(MSG_PLEASE_RESET));
+  tft_string.trim();
+  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
+
+  tft.queue.sync();
+}
+
+void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
+  MarlinImage image = imgHotEnd;
+  uint16_t Color;
+  float currentTemperature, targetTemperature;
+
+  if (Heater >= 0) { // HotEnd
+    currentTemperature = thermalManager.degHotend(Heater);
+    targetTemperature = thermalManager.degTargetHotend(Heater);
+  }
+#if HAS_HEATED_BED
+  else if (Heater == H_BED) {
+    currentTemperature = thermalManager.degBed();
+    targetTemperature = thermalManager.degTargetBed();
+  }
+#endif // HAS_HEATED_BED
+#if HAS_TEMP_CHAMBER
+  else if (Heater == H_CHAMBER) {
+    currentTemperature = thermalManager.degChamber();
+    #if HAS_HEATED_CHAMBER
+      targetTemperature = thermalManager.degTargetChamber();
+    #else
+      targetTemperature = ABSOLUTE_ZERO;
+    #endif
+  }
+#endif // HAS_TEMP_CHAMBER
+  else return;
+
+  TERN_(TOUCH_SCREEN, if (targetTemperature >= 0) touch.add_control(HEATER, x, y, 80, 120, Heater));
+  tft.canvas(x, y, 80, 120);
+  tft.set_background(COLOR_BACKGROUND);
+
+  Color = currentTemperature < 0 ? COLOR_INACTIVE : COLOR_COLD;
+
+  if (Heater >= 0) { // HotEnd
+    if (currentTemperature >= 50) Color = COLOR_HOTEND;
+  }
+  #if HAS_HEATED_BED
+  else if (Heater == H_BED) {
+    if (currentTemperature >= 50) Color = COLOR_HEATED_BED;
+    image = targetTemperature > 0 ? imgBedHeated : imgBed;
+  }
+  #endif // HAS_HEATED_BED
+  #if HAS_TEMP_CHAMBER
+  else if (Heater == H_CHAMBER) {
+    if (currentTemperature >= 50) Color = COLOR_CHAMBER;
+    image = targetTemperature > 0 ? imgChamberHeated : imgChamber;
+  }
+  #endif // HAS_TEMP_CHAMBER
+
+  tft.add_image(8, 28, image, Color);
+
+  tft_string.set((uint8_t *)i16tostr3rj(currentTemperature + 0.5));
+  tft_string.add(LCD_STR_DEGREE);
+  tft_string.trim();
+  tft.add_text(tft_string.center(80) + 2, 82, Color, tft_string);
+
+  if (targetTemperature >= 0) {
+    tft_string.set((uint8_t *)i16tostr3rj(targetTemperature + 0.5));
+    tft_string.add(LCD_STR_DEGREE);
+    tft_string.trim();
+    tft.add_text(tft_string.center(80) + 2, 8, Color, tft_string);
+  }
+}
+
+void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
+  TERN_(TOUCH_SCREEN, touch.add_control(FAN, x, y, 80, 120));
+  tft.canvas(x, y, 80, 120);
+  tft.set_background(COLOR_BACKGROUND);
+
+  uint8_t fanSpeed = thermalManager.fan_speed[0];
+  MarlinImage image;
+
+  if (fanSpeed >= 127)
+    image = blink ? imgFanFast1 : imgFanFast0;
+  else if (fanSpeed > 0)
+    image = blink ? imgFanSlow1 : imgFanSlow0;
+  else
+    image = imgFanIdle;
+
+  tft.add_image(8, 20, image, COLOR_FAN);
+
+  tft_string.set((uint8_t *)ui8tostr4pctrj(thermalManager.fan_speed[0]));
+  tft_string.trim();
+  tft.add_text(tft_string.center(80) + 6, 82, COLOR_FAN, tft_string);
+}
+
+void MarlinUI::draw_status_screen() {
+  const bool blink = get_blink();
+
+  TERN_(TOUCH_SCREEN, touch.clear());
+
+  // heaters and fan
+  uint16_t i, x, y = POS_Y;
+
+  for (i = 0 ; i < ITEMS_COUNT; i++) {
+    x = (TFT_WIDTH / ITEMS_COUNT - 80) / 2  + (TFT_WIDTH * i / ITEMS_COUNT);
+    switch (i) {
+      #ifdef ITEM_E0
+        case ITEM_E0: draw_heater_status(x, y, H_E0); break;
+      #endif
+      #ifdef ITEM_E1
+        case ITEM_E1: draw_heater_status(x, y, H_E1); break;
+      #endif
+      #ifdef ITEM_E2
+        case ITEM_E2: draw_heater_status(x, y, H_E2); break;
+      #endif
+      #ifdef ITEM_BED
+        case ITEM_BED: draw_heater_status(x, y, H_BED); break;
+      #endif
+      #ifdef ITEM_CHAMBER
+        case ITEM_CHAMBER: draw_heater_status(x, y, H_CHAMBER); break;
+      #endif
+      #ifdef ITEM_FAN
+        case ITEM_FAN: draw_fan_status(x, y, blink); break;
+      #endif
+    }
+  }
+
+  // coordinates
+  tft.canvas(4, 132, TFT_WIDTH - 8, 34);
+  tft.set_background(COLOR_BACKGROUND);
+  tft.add_rectangle(0, 0, TFT_WIDTH - 8, 34, COLOR_AXIS_HOMED);
+
+  uint16_t color;
+  uint16_t offset;
+  bool is_homed;
+
+  tft.add_text( 16, 3, COLOR_AXIS_HOMED , "X");
+  tft.add_text(192, 3, COLOR_AXIS_HOMED , "Y");
+  tft.add_text(330, 3, COLOR_AXIS_HOMED , "Z");
+
+  is_homed = TEST(axis_homed, X_AXIS);
+  tft_string.set(blink & !is_homed ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
+  tft.add_text(102 - tft_string.width(), 3, is_homed ? COLOR_AXIS_HOMED : COLOR_AXIS_NOT_HOMED, tft_string);
+
+  is_homed = TEST(axis_homed, Y_AXIS);
+  tft_string.set(blink & !is_homed ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
+  tft.add_text(280 - tft_string.width(), 3, is_homed ? COLOR_AXIS_HOMED : COLOR_AXIS_NOT_HOMED, tft_string);
+
+  is_homed = TEST(axis_homed, Z_AXIS);
+  if (blink & !is_homed) {
+    tft_string.set("?");
+    offset = 32; // ".00"
+  }
+  else {
+    const float z = LOGICAL_Z_POSITION(current_position.z);
+    tft_string.set(ftostr52sp((int16_t)z));
+    tft_string.rtrim();
+    offset = tft_string.width();
+
+    tft_string.set(ftostr52sp(z));
+    offset += 32 - tft_string.width();
+  }
+  tft.add_text(455 - tft_string.width() - offset, 3, is_homed ? COLOR_AXIS_HOMED : COLOR_AXIS_NOT_HOMED, tft_string);
+
+  // feed rate
+  tft.canvas(96, 180, 100, 32);
+  tft.set_background(COLOR_BACKGROUND);
+  color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
+  tft.add_image(0, 0, imgFeedRate, color);
+  tft_string.set(i16tostr3rj(feedrate_percentage));
+  tft_string.add('%');
+  tft.add_text(36, 1, color , tft_string);
+  TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE, 96, 176, 100, 32));
+
+  // flow rate
+  tft.canvas(284, 180, 100, 32);
+  tft.set_background(COLOR_BACKGROUND);
+  color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
+  tft.add_image(0, 0, imgFlowRate, color);
+  tft_string.set(i16tostr3rj(planner.flow_percentage[active_extruder]));
+  tft_string.add('%');
+  tft.add_text(36, 1, color , tft_string);
+  TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE, 284, 176, 100, 32, active_extruder));
+
+  // print duration
+  char buffer[14];
+  duration_t elapsed = print_job_timer.duration();
+  elapsed.toDigital(buffer);
+
+  tft.canvas((TFT_WIDTH - 128) / 2, 224, 128, 29);
+  tft.set_background(COLOR_BACKGROUND);
+  tft_string.set(buffer);
+  tft.add_text(tft_string.center(128), 0, COLOR_PRINT_TIME, tft_string);
+
+  // progress bar
+  const uint8_t progress = ui.get_progress_percent();
+  tft.canvas(4, 260, TFT_WIDTH - 8, 9);
+  tft.set_background(COLOR_PROGRESS_BG);
+  tft.add_rectangle(0, 0, TFT_WIDTH - 8, 9, COLOR_PROGRESS_FRAME);
+  if (progress)
+    tft.add_bar(1, 1, ((TFT_WIDTH - 10) * progress) / 100, 7, COLOR_PROGRESS_BAR);
+
+  // status message
+  tft.canvas(0, 280, TFT_WIDTH, 29);
+  tft.set_background(COLOR_BACKGROUND);
+  tft_string.set(status_message);
+  tft_string.trim();
+  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_STATUS_MESSAGE, tft_string);
+
+
+  #if ENABLED(TOUCH_SCREEN)
+    add_control(404, 180, menu_main, imgSettings);
+    TERN_(SDSUPPORT, add_control(12, 180, menu_media, imgSD, card.isMounted() && !printingIsActive(), COLOR_CONTROL_ENABLED, card.isMounted() && printingIsActive() ? COLOR_BUSY : COLOR_CONTROL_DISABLED));
+  #endif
+}
+
+// Draw a static item with no left-right margin required. Centered by default.
+void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const valstr/*=nullptr*/) {
+  menu_item(row);
+  tft_string.set(pstr, itemIndex, itemString);
+  if (valstr)
+    tft_string.add(valstr);
+  tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
+}
+
+// Draw a generic menu item with pre_char (if selected) and post_char
+void MenuItemBase::_draw(const bool sel, const uint8_t row, PGM_P const pstr, const char pre_char, const char post_char) {
+  menu_item(row, sel);
+
+  uint8_t *string = (uint8_t *)pstr;
+  MarlinImage image = noImage;
+  switch (*string) {
+    case 0x01: image = imgRefresh; break;  // LCD_STR_REFRESH
+    case 0x02: image = imgDirectory; break;  // LCD_STR_FOLDER
+  }
+
+  uint8_t offset = MENU_TEXT_X_OFFSET;
+  if (image != noImage) {
+    string++;
+    offset = 42;
+    tft.add_image(5, 5, image, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
+  }
+
+  tft_string.set(string, itemIndex, itemString);
+  tft.add_text(offset, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+}
+
+// Draw a menu item with a (potentially) editable value
+void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr, const char* const data, const bool pgm) {
+  menu_item(row, sel);
+
+  tft_string.set(pstr, itemIndex, itemString);
+  tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+  if (data) {
+    tft_string.set(data);
+    tft.add_text(TFT_WIDTH - MENU_TEXT_X_OFFSET - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+  }
+}
+
+// Low-level draw_edit_screen can be used to draw an edit screen from anyplace
+void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
+  ui.encoder_direction_normal();
+  TERN_(TOUCH_SCREEN, touch.clear());
+
+  uint16_t line = 1;
+
+  menu_line(line++);
+  tft_string.set(pstr, itemIndex, itemString);
+  tft_string.trim();
+  tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+
+  TERN_(AUTO_BED_LEVELING_UBL, if (ui.external_control) line++);  // ftostr52() will overwrite *value so *value has to be displayed first
+
+  menu_line(line);
+  tft_string.set(value);
+  tft_string.trim();
+  tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+    if (ui.external_control) {
+      menu_line(line - 1);
+
+      tft_string.set(X_LBL);
+      tft.add_text((TFT_WIDTH / 2 - 120), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+      tft_string.set(ftostr52(LOGICAL_X_POSITION(current_position.x)));
+      tft_string.trim();
+      tft.add_text((TFT_WIDTH / 2 - 16) - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+
+      tft_string.set(Y_LBL);
+      tft.add_text((TFT_WIDTH / 2 + 16), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+      tft_string.set(ftostr52(LOGICAL_X_POSITION(current_position.y)));
+      tft_string.trim();
+      tft.add_text((TFT_WIDTH / 2 + 120) - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+    }
+  #endif
+
+  extern screenFunc_t _manual_move_func_ptr;
+  if (ui.currentScreen != _manual_move_func_ptr && !ui.external_control) {
+
+    #define SLIDER_LENGHT 336
+    #define SLIDER_Y_POSITION 186
+
+    tft.canvas((TFT_WIDTH - SLIDER_LENGHT) / 2, SLIDER_Y_POSITION, SLIDER_LENGHT, 16);
+    tft.set_background(COLOR_BACKGROUND);
+
+    int16_t position = (SLIDER_LENGHT - 2) * ui.encoderPosition / maxEditValue;
+    tft.add_bar(0, 7, 1, 2, ui.encoderPosition == 0 ? COLOR_SLIDER_INACTIVE : COLOR_SLIDER);
+    tft.add_bar(1, 6, position, 4, COLOR_SLIDER);
+    tft.add_bar(position + 1, 6, SLIDER_LENGHT - 2 - position, 4, COLOR_SLIDER_INACTIVE);
+    tft.add_bar(SLIDER_LENGHT - 1, 7, 1, 2, int32_t(ui.encoderPosition) == maxEditValue ? COLOR_SLIDER : COLOR_SLIDER_INACTIVE);
+
+    #if ENABLED(TOUCH_SCREEN)
+      tft.add_image((SLIDER_LENGHT - 8) * ui.encoderPosition / maxEditValue, 0, imgSlider, COLOR_SLIDER);
+      touch.add_control(SLIDER, (TFT_WIDTH - SLIDER_LENGHT) / 2, SLIDER_Y_POSITION - 8, SLIDER_LENGHT, 32, maxEditValue);
+    #endif
+  }
+
+  #if ENABLED(TOUCH_SCREEN)
+    add_control(64, 256, DECREASE, imgDecrease);
+    add_control(352, 256, INCREASE, imgIncrease);
+    add_control(208, 256, CLICK, imgConfirm);
+  #endif
+}
+
+// The Select Screen presents a prompt and two "buttons"
+void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const bool yesno, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
+  uint16_t line = 1;
+
+  if (string == NULL) line++;
+
+  menu_line(line++);
+  tft_string.set(pref);
+  tft_string.trim();
+  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
+
+  if (string) {
+    menu_line(line++);
+    tft_string.set(string);
+    tft_string.trim();
+    tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
+  }
+
+  if (suff) {
+    menu_line(line);
+    tft_string.set(suff);
+    tft_string.trim();
+    tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
+  }
+  #if ENABLED(TOUCH_SCREEN)
+    add_control(88, 256, CANCEL, imgCancel, true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
+    add_control(328, 256, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
+  #endif
+}
+
+#if ENABLED(SDSUPPORT)
+  void MenuItem_sdbase::draw(const bool sel, const uint8_t row, PGM_P const, CardReader &theCard, const bool isDir) {
+    menu_item(row, sel);
+    if (isDir)
+      tft.add_image(5, 5, imgDirectory, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
+    tft.add_text(42, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, theCard.longest_filename());
+  }
+#endif
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
+    #if ENABLED(TOUCH_SCREEN)
+      touch.clear();
+      draw_menu_navigation = false;
+      touch.add_control(RESUME_CONTINUE , 0, 0, TFT_WIDTH, TFT_HEIGHT);
+    #endif
+
+    menu_line(row);
+    tft_string.set(GET_TEXT(MSG_FILAMENT_CHANGE_NOZZLE));
+    tft_string.add('E');
+    tft_string.add((char)('1' + extruder));
+    tft_string.add(' ');
+    tft_string.add(i16tostr3rj(thermalManager.degHotend(extruder)));
+    tft_string.add(LCD_STR_DEGREE);
+    tft_string.add(" / ");
+    tft_string.add(i16tostr3rj(thermalManager.degTargetHotend(extruder)));
+    tft_string.add(LCD_STR_DEGREE);
+    tft_string.trim();
+    tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
+  }
+#endif // ADVANCED_PAUSE_FEATURE
+
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+  #define GRID_OFFSET_X   8
+  #define GRID_OFFSET_Y   8
+  #define GRID_WIDTH      192
+  #define GRID_HEIGHT     192
+  #define CONTROL_OFFSET  16
+
+  void MarlinUI::ubl_plot(const uint8_t x_plot, const uint8_t y_plot) {
+
+    tft.canvas(GRID_OFFSET_X, GRID_OFFSET_Y, GRID_WIDTH, GRID_HEIGHT);
+    tft.set_background(COLOR_BACKGROUND);
+    tft.add_rectangle(0, 0, GRID_WIDTH, GRID_HEIGHT, COLOR_WHITE);
+
+    for (uint16_t x = 0; x < GRID_MAX_POINTS_X ; x++)
+      for (uint16_t y = 0; y < GRID_MAX_POINTS_Y ; y++)
+        if (position_is_reachable({ ubl.mesh_index_to_xpos(x), ubl.mesh_index_to_ypos(y) }))
+          tft.add_bar(1 + (x * 2 + 1) * (GRID_WIDTH - 4) / GRID_MAX_POINTS_X / 2, GRID_HEIGHT - 3 - ((y * 2 + 1) * (GRID_HEIGHT - 4) / GRID_MAX_POINTS_Y / 2), 2, 2, COLOR_UBL);
+
+    tft.add_rectangle((x_plot * 2 + 1) * (GRID_WIDTH - 4) / GRID_MAX_POINTS_X / 2 - 1, GRID_HEIGHT - 5 - ((y_plot * 2 + 1) * (GRID_HEIGHT - 4) / GRID_MAX_POINTS_Y / 2), 6, 6, COLOR_UBL);
+
+    const xy_pos_t pos = { ubl.mesh_index_to_xpos(x_plot), ubl.mesh_index_to_ypos(y_plot) },
+                   lpos = pos.asLogical();
+
+    tft.canvas(320, GRID_OFFSET_Y + (GRID_HEIGHT - 43) / 2 - 43, 120, 43);
+    tft.set_background(COLOR_BACKGROUND);
+    tft_string.set(X_LBL);
+    tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+    tft_string.set(ftostr52(lpos.x));
+    tft_string.trim();
+    tft.add_text(120 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+
+    tft.canvas(320, GRID_OFFSET_Y + (GRID_HEIGHT - 43) / 2, 120, 43);
+    tft.set_background(COLOR_BACKGROUND);
+    tft_string.set(Y_LBL);
+    tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+    tft_string.set(ftostr52(lpos.y));
+    tft_string.trim();
+    tft.add_text(120 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+
+    tft.canvas(320, GRID_OFFSET_Y + (GRID_HEIGHT - 43) / 2 + 43, 120, 43);
+    tft.set_background(COLOR_BACKGROUND);
+    tft_string.set(Z_LBL);
+    tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+    tft_string.set(isnan(ubl.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(ubl.z_values[x_plot][y_plot]));
+    tft_string.trim();
+    tft.add_text(120 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+
+
+    tft.canvas(GRID_OFFSET_X + (GRID_WIDTH - 48) / 2, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET - 5, 48, 43);
+    tft.set_background(COLOR_BACKGROUND);
+    tft_string.set(ui8tostr3rj(x_plot));
+    tft_string.trim();
+    tft.add_text(tft_string.center(48), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+
+    tft.canvas(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET + 16 - 24, GRID_OFFSET_Y + (GRID_HEIGHT - 43) / 2, 48, 43);
+    tft.set_background(COLOR_BACKGROUND);
+    tft_string.set(ui8tostr3rj(y_plot));
+    tft_string.trim();
+    tft.add_text(tft_string.center(48), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+
+    #if ENABLED(TOUCH_SCREEN)
+      touch.clear();
+      draw_menu_navigation = false;
+      add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + CONTROL_OFFSET,                    UBL,   ENCODER_STEPS_PER_MENU_ITEM * GRID_MAX_POINTS_X, imgUp);
+      add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + GRID_HEIGHT - CONTROL_OFFSET - 32, UBL, - ENCODER_STEPS_PER_MENU_ITEM * GRID_MAX_POINTS_X, imgDown);
+      add_control(GRID_OFFSET_X + CONTROL_OFFSET,                   GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL, - ENCODER_STEPS_PER_MENU_ITEM, imgLeft);
+      add_control(GRID_OFFSET_X + GRID_WIDTH - CONTROL_OFFSET - 32, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL,   ENCODER_STEPS_PER_MENU_ITEM, imgRight);
+      add_control(320, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET, CLICK, imgLeveling);
+      add_control(224, 286, BACK, imgBack);
+    #endif
+  }
+#endif // AUTO_BED_LEVELING_UBL
+
+#if ENABLED(TOUCH_SCREEN_CALIBRATION)
+  void MarlinUI::touch_calibration() {
+    static uint16_t x, y;
+
+    calibrationState calibration_stage = touch.get_calibration_state();
+
+    if (calibration_stage == CALIBRATION_NONE) {
+      defer_status_screen(true);
+      clear_lcd();
+      calibration_stage = touch.calibration_start();
+    }
+    else {
+      tft.canvas(x - 15, y - 15, 31, 31);
+      tft.set_background(COLOR_BACKGROUND);
+    }
+
+    x = 20; y = 20;
+    touch.clear();
+
+    if (calibration_stage < CALIBRATION_SUCCESS) {
+      switch(calibration_stage) {
+        case CALIBRATION_POINT_1: tft_string.set("Top Left"); break;
+        case CALIBRATION_POINT_2: y = TFT_HEIGHT - 21; tft_string.set("Bottom Left"); break;
+        case CALIBRATION_POINT_3: x = TFT_WIDTH  - 21; tft_string.set("Top Right"); break;
+        case CALIBRATION_POINT_4: x = TFT_WIDTH  - 21; y = TFT_HEIGHT - 21; tft_string.set("Bottom Right"); break;
+        default: break;
+      }
+
+      tft.canvas(x - 15, y - 15, 31, 31);
+      tft.set_background(COLOR_BACKGROUND);
+      tft.add_bar(0, 15, 31, 1, COLOR_TOUCH_CALIBRATION);
+      tft.add_bar(15, 0, 1, 31, COLOR_TOUCH_CALIBRATION);
+
+      touch.add_control(CALIBRATE, 0, 0, TFT_WIDTH, TFT_HEIGHT, uint32_t(x) << 16 | uint32_t(y));
+    }
+    else {
+      tft_string.set(calibration_stage == CALIBRATION_SUCCESS ? "Calibration Completed" : "Calibration Failed");
+      defer_status_screen(false);
+      touch.calibration_end();
+      touch.add_control(BACK, 0, 0, TFT_WIDTH, TFT_HEIGHT);
+    }
+
+    tft.canvas(0, (TFT_HEIGHT - tft_string.font_height()) >> 1, TFT_WIDTH, tft_string.font_height());
+    tft.set_background(COLOR_BACKGROUND);
+    tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
+  }
+#endif // TOUCH_SCREEN_CALIBRATION
+
+void menu_line(const uint8_t row, uint16_t color) {
+  tft.canvas(0, 4 + 45 * row, TFT_WIDTH, 43);
+  tft.set_background(color);
+}
+
+void menu_pause_option();
+
+void menu_item(const uint8_t row, bool sel ) {
+  #if ENABLED(TOUCH_SCREEN)
+    if (row == 0) {
+      touch.clear();
+      draw_menu_navigation = TERN(ADVANCED_PAUSE_FEATURE, ui.currentScreen != menu_pause_option, true);
+    }
+  #endif
+
+  menu_line(row, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
+  TERN_(TOUCH_SCREEN, touch.add_control(sel ? CLICK : MENU_ITEM, 0, 4 + 45 * row, TFT_WIDTH, 43, encoderTopLine + row));
+}
+
+#endif // HAS_UI_480x320
