commit 2d9262cc5a9b24d5900126f3498da7f3a8f31e66
Author: Erkan Ozgur Yilmaz <eoyilmaz@gmail.com>
Date:   Thu Nov 23 02:39:40 2023 +0000

    ‚ö°Ô∏è Fix MMU2 sscanf bug, optimize (#26449)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index dbf8171a27..5ef56c7eac 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -76,7 +76,7 @@ MMU2 mmu2;
 #define MMU2_NO_TOOL 99
 #define MMU_BAUD    115200
 
-bool MMU2::_enabled, MMU2::ready, MMU2::mmu_print_saved;
+bool MMU2::_enabled, MMU2::ready;
 #if HAS_PRUSA_MMU2S
   bool MMU2::mmu2s_triggered;
 #endif
@@ -84,7 +84,6 @@ uint8_t MMU2::cmd, MMU2::cmd_arg, MMU2::last_cmd, MMU2::extruder;
 int8_t MMU2::state = 0;
 volatile int8_t MMU2::finda = 1;
 volatile bool MMU2::finda_runout_valid;
-uint16_t MMU2::version = 0, MMU2::buildnr = 0;
 millis_t MMU2::prev_request, MMU2::prev_P0_request;
 char MMU2::rx_buffer[MMU_RX_SIZE], MMU2::tx_buffer[MMU_TX_SIZE];
 
@@ -146,6 +145,7 @@ void mmu2_attn_buzz(const bool two=false) {
   if (two) { BUZZ(10, 0); BUZZ(200, 404); }
 }
 
+// Avoiding sscanf significantly reduces build size
 void MMU2::mmu_loop() {
 
   switch (state) {
@@ -168,7 +168,7 @@ void MMU2::mmu_loop() {
 
     case -2:
       if (rx_ok()) {
-        sscanf(rx_buffer, "%huok\n", &version);
+        const uint16_t version = uint16_t(strtoul(rx_buffer, nullptr, 10));
         DEBUG_ECHOLNPGM("MMU => ", version, "\nMMU <= 'S2'");
         MMU2_SEND("S2");    // Read Build Number
         state = -3;
@@ -177,17 +177,15 @@ void MMU2::mmu_loop() {
 
     case -3:
       if (rx_ok()) {
-        sscanf(rx_buffer, "%huok\n", &buildnr);
-
+        const uint16_t buildnr = uint16_t(strtoul(rx_buffer, nullptr, 10));
         DEBUG_ECHOLNPGM("MMU => ", buildnr);
 
-        check_version();
+        check_version(buildnr);
 
         #if ENABLED(MMU2_MODE_12V)
           DEBUG_ECHOLNPGM("MMU <= 'M1'");
           MMU2_SEND("M1");    // Stealth Mode
           state = -5;
-
         #else
           DEBUG_ECHOLNPGM("MMU <= 'P0'");
           MMU2_SEND("P0");    // Read FINDA
@@ -210,7 +208,8 @@ void MMU2::mmu_loop() {
 
     case -4:
       if (rx_ok()) {
-        sscanf(rx_buffer, "%hhuok\n", &finda);
+        const uint8_t findex = uint8_t(rx_buffer[0] - '0');
+        if (findex <= 1) finda = findex;
 
         DEBUG_ECHOLNPGM("MMU => ", finda, "\nMMU - ENABLED");
 
@@ -283,7 +282,8 @@ void MMU2::mmu_loop() {
 
     case 2:   // response to command P0
       if (rx_ok()) {
-        sscanf(rx_buffer, "%hhuok\n", &finda);
+        const uint8_t findex = uint8_t(rx_buffer[0] - '0');
+        if (findex <= 1) finda = findex;
 
         // This is super annoying. Only activate if necessary
         //if (finda_runout_valid) DEBUG_ECHOLNPGM("MMU <= 'P0'\nMMU => ", p_float_t(finda, 6));
@@ -439,7 +439,7 @@ bool MMU2::rx_ok() {
 /**
  * Check if MMU has compatible firmware
  */
-void MMU2::check_version() {
+void MMU2::check_version(const uint16_t buildnr) {
   if (buildnr < MMU_REQUIRED_FW_BUILDNR) {
     SERIAL_ERROR_MSG("Invalid MMU2 firmware. Version >= " STRINGIFY(MMU_REQUIRED_FW_BUILDNR) " required.");
     kill(GET_TEXT_F(MSG_KILL_MMU2_FIRMWARE));
@@ -801,8 +801,7 @@ bool MMU2::get_response() {
 void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
 
   constexpr xyz_pos_t park_point = NOZZLE_PARK_POINT;
-  bool response = false;
-  mmu_print_saved = false;
+  bool response = false, mmu_print_saved = false;
   xyz_pos_t resume_position;
   celsius_t resume_hotend_temp = thermalManager.degTargetHotend(active_extruder);
 

commit e68320ee2b10ae5c7bf3bf816e80c3621a20fcd2
Author: Erkan Ozgur Yilmaz <eoyilmaz@gmail.com>
Date:   Sun Oct 8 21:39:46 2023 +0100

    üêõ Fix MMU late init (#26331)

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 19aae7b7d7..dbf8171a27 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -160,7 +160,7 @@ void MMU2::mmu_loop() {
         MMU2_SEND("S1");    // Read Version
         state = -2;
       }
-      else if (millis() > 30000) { // 30sec after reset disable MMU
+      else if (ELAPSED(millis(), prev_request + 30000)) { // 30sec after reset disable MMU
         SERIAL_ECHOLNPGM("MMU not responding - DISABLED");
         state = 0;
       }

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ‚ôªÔ∏è Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index ea1a33ddaa..19aae7b7d7 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -286,7 +286,7 @@ void MMU2::mmu_loop() {
         sscanf(rx_buffer, "%hhuok\n", &finda);
 
         // This is super annoying. Only activate if necessary
-        // if (finda_runout_valid) DEBUG_ECHOLNPAIR_F("MMU <= 'P0'\nMMU => ", finda, 6);
+        //if (finda_runout_valid) DEBUG_ECHOLNPGM("MMU <= 'P0'\nMMU => ", p_float_t(finda, 6));
 
         if (!finda && finda_runout_valid) filament_runout();
         if (cmd == MMU_CMD_NONE) ready = true;

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index fbfcf3fd3f..ea1a33ddaa 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -403,7 +403,7 @@ void MMU2::tx_str(FSTR_P fstr) {
 void MMU2::tx_printf(FSTR_P format, int argument = -1) {
   clear_rx_buffer();
   const uint8_t len = sprintf_P(tx_buffer, FTOP(format), argument);
-  LOOP_L_N(i, len) MMU2_SERIAL.write(tx_buffer[i]);
+  for (uint8_t i = 0; i < len; ++i) MMU2_SERIAL.write(tx_buffer[i]);
   prev_request = millis();
 }
 
@@ -413,7 +413,7 @@ void MMU2::tx_printf(FSTR_P format, int argument = -1) {
 void MMU2::tx_printf(FSTR_P format, int argument1, int argument2) {
   clear_rx_buffer();
   const uint8_t len = sprintf_P(tx_buffer, FTOP(format), argument1, argument2);
-  LOOP_L_N(i, len) MMU2_SERIAL.write(tx_buffer[i]);
+  for (uint8_t i = 0; i < len; ++i) MMU2_SERIAL.write(tx_buffer[i]);
   prev_request = millis();
 }
 
@@ -467,7 +467,7 @@ inline void beep_bad_cmd() { BUZZ(400, 40); }
   bool MMU2::load_to_gears() {
     command(MMU_CMD_C0);
     manage_response(true, true);
-    LOOP_L_N(i, MMU2_C0_RETRY) {  // Keep loading until filament reaches gears
+    for (uint8_t i = 0; i < MMU2_C0_RETRY; ++i) {  // Keep loading until filament reaches gears
       if (mmu2s_triggered) break;
       command(MMU_CMD_C0);
       manage_response(true, true);
@@ -900,7 +900,7 @@ void MMU2::filament_runout() {
     int filament_detected_count = 0;
     const int steps = (MMU2_CAN_LOAD_RETRACT) / (MMU2_CAN_LOAD_INCREMENT);
     DEBUG_ECHOLNPGM("MMU can_load:");
-    LOOP_L_N(i, steps) {
+    for (uint8_t i = 0; i < steps; ++i) {
       execute_extruder_sequence(can_load_increment_sequence, COUNT(can_load_increment_sequence));
       check_filament(); // Don't trust the idle function
       DEBUG_CHAR(mmu2s_triggered ? 'O' : 'o');
@@ -1047,7 +1047,7 @@ void MMU2::execute_extruder_sequence(const E_Step * sequence, int steps) {
 
   const E_Step *step = sequence;
 
-  LOOP_L_N(i, steps) {
+  for (uint8_t i = 0; i < steps; ++i) {
     const float es = pgm_read_float(&(step->extrude));
     const feedRate_t fr_mm_m = pgm_read_float(&(step->feedRate));
     DEBUG_ECHO_MSG("E step ", es, "/", fr_mm_m);

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 8aec1dc1db..fbfcf3fd3f 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -135,7 +135,7 @@ void MMU2::reset() {
 
 int8_t MMU2::get_current_tool() { return extruder == MMU2_NO_TOOL ? -1 : extruder; }
 
-#if EITHER(HAS_PRUSA_MMU2S, MMU_EXTRUDER_SENSOR)
+#if ANY(HAS_PRUSA_MMU2S, MMU_EXTRUDER_SENSOR)
   #define FILAMENT_PRESENT() (READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE)
 #else
   #define FILAMENT_PRESENT() true

commit 001d1fd7cb86306cf6e25c11a91d0b2e478007bd
Author: Thomas Niccolo Reyes <niccoreyes@gmail.com>
Date:   Fri May 5 07:09:36 2023 +0800

    üö∏ Improve MMU2 unload (like original MMU2S) (#20147)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index ea58c2859b..8aec1dc1db 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -84,7 +84,7 @@ uint8_t MMU2::cmd, MMU2::cmd_arg, MMU2::last_cmd, MMU2::extruder;
 int8_t MMU2::state = 0;
 volatile int8_t MMU2::finda = 1;
 volatile bool MMU2::finda_runout_valid;
-int16_t MMU2::version = -1, MMU2::buildnr = -1;
+uint16_t MMU2::version = 0, MMU2::buildnr = 0;
 millis_t MMU2::prev_request, MMU2::prev_P0_request;
 char MMU2::rx_buffer[MMU_RX_SIZE], MMU2::tx_buffer[MMU_TX_SIZE];
 
@@ -93,14 +93,11 @@ struct E_Step {
   feedRate_t feedRate;  //!< feed rate in mm/s
 };
 
-static constexpr E_Step
-    ramming_sequence[] PROGMEM = { MMU2_RAMMING_SEQUENCE }
-  , load_to_nozzle_sequence[] PROGMEM = { MMU2_LOAD_TO_NOZZLE_SEQUENCE }
-  #if HAS_PRUSA_MMU2S
-    , can_load_sequence[] PROGMEM = { MMU2_CAN_LOAD_SEQUENCE }
-    , can_load_increment_sequence[] PROGMEM = { MMU2_CAN_LOAD_INCREMENT_SEQUENCE }
-  #endif
-;
+inline void unscaled_mmu2_e_move(const float &dist, const feedRate_t fr_mm_s, const bool sync=true) {
+  current_position.e += dist / planner.e_factor[active_extruder];
+  line_to_current_position(fr_mm_s);
+  if (sync) planner.synchronize();
+}
 
 MMU2::MMU2() {
   rx_buffer[0] = '\0';
@@ -136,12 +133,12 @@ void MMU2::reset() {
   #endif
 }
 
-uint8_t MMU2::get_current_tool() {
-  return extruder == MMU2_NO_TOOL ? -1 : extruder;
-}
+int8_t MMU2::get_current_tool() { return extruder == MMU2_NO_TOOL ? -1 : extruder; }
 
 #if EITHER(HAS_PRUSA_MMU2S, MMU_EXTRUDER_SENSOR)
   #define FILAMENT_PRESENT() (READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE)
+#else
+  #define FILAMENT_PRESENT() true
 #endif
 
 void mmu2_attn_buzz(const bool two=false) {
@@ -200,15 +197,15 @@ void MMU2::mmu_loop() {
       break;
 
     #if ENABLED(MMU2_MODE_12V)
-    case -5:
-      // response to M1
-      if (rx_ok()) {
-        DEBUG_ECHOLNPGM("MMU => ok");
-        DEBUG_ECHOLNPGM("MMU <= 'P0'");
-        MMU2_SEND("P0");    // Read FINDA
-        state = -4;
-      }
-      break;
+      case -5:
+        // response to M1
+        if (rx_ok()) {
+          DEBUG_ECHOLNPGM("MMU => ok");
+          DEBUG_ECHOLNPGM("MMU <= 'P0'");
+          MMU2_SEND("P0");    // Read FINDA
+          state = -4;
+        }
+        break;
     #endif
 
     case -4:
@@ -458,8 +455,15 @@ static void mmu2_not_responding() {
   BUZZ(100, 659);
 }
 
+inline void beep_bad_cmd() { BUZZ(400, 40); }
+
 #if HAS_PRUSA_MMU2S
 
+  /**
+   * Load filament until the sensor at the gears is triggered
+   * and give up after a number of attempts set with MMU2_C0_RETRY.
+   * Each try has a timeout before returning a fail state.
+   */
   bool MMU2::load_to_gears() {
     command(MMU_CMD_C0);
     manage_response(true, true);
@@ -484,6 +488,11 @@ static void mmu2_not_responding() {
     set_runout_valid(false);
 
     if (index != extruder) {
+      if (ENABLED(MMU_IR_UNLOAD_MOVE) && FILAMENT_PRESENT()) {
+        DEBUG_ECHOLNPGM("Unloading\n");
+        while (FILAMENT_PRESENT())                      // Filament present? Keep unloading.
+          unscaled_mmu2_e_move(-0.25, MMM_TO_MMS(120)); // 0.25mm is a guessed value. Adjust to preference.
+      }
 
       stepper.disable_extruder();
       ui.status_printf(0, GET_TEXT_F(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
@@ -520,9 +529,9 @@ static void mmu2_not_responding() {
           #if ENABLED(MMU2_MENUS)
             const uint8_t index = mmu2_choose_filament();
             while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
-            load_filament_to_nozzle(index);
+            load_to_nozzle(index);
           #else
-            ERR_BUZZ();
+            beep_bad_cmd();
           #endif
         } break;
 
@@ -541,13 +550,13 @@ static void mmu2_not_responding() {
               active_extruder = 0;
             }
           #else
-            ERR_BUZZ();
+            beep_bad_cmd();
           #endif
         } break;
 
         case 'c': {
           while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
-          load_to_nozzle();
+          load_to_nozzle_sequence();
         } break;
       }
 
@@ -608,9 +617,9 @@ static void mmu2_not_responding() {
         #if ENABLED(MMU2_MENUS)
           uint8_t index = mmu2_choose_filament();
           while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
-          load_filament_to_nozzle(index);
+          load_to_nozzle(index);
         #else
-          ERR_BUZZ();
+          beep_bad_cmd();
         #endif
       } break;
 
@@ -630,14 +639,14 @@ static void mmu2_not_responding() {
           extruder = index;
           active_extruder = 0;
         #else
-          ERR_BUZZ();
+          beep_bad_cmd();
         #endif
       } break;
 
       case 'c': {
         DEBUG_ECHOLNPGM("case c\n");
         while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
-        execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
+        load_to_nozzle_sequence();
       } break;
     }
 
@@ -723,9 +732,9 @@ static void mmu2_not_responding() {
         #if ENABLED(MMU2_MENUS)
           uint8_t index = mmu2_choose_filament();
           while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
-          load_filament_to_nozzle(index);
+          load_to_nozzle(index);
         #else
-          ERR_BUZZ();
+          beep_bad_cmd();
         #endif
       } break;
 
@@ -744,14 +753,14 @@ static void mmu2_not_responding() {
           extruder = index;
           active_extruder = 0;
         #else
-          ERR_BUZZ();
+          beep_bad_cmd();
         #endif
       } break;
 
       case 'c': {
         DEBUG_ECHOLNPGM("case c\n");
         while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
-        execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
+        load_to_nozzle_sequence();
       } break;
     }
 
@@ -823,13 +832,12 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
       }
     }
     else if (mmu_print_saved) {
-      SERIAL_ECHOLNPGM("MMU starts responding\n");
+      SERIAL_ECHOLNPGM("\nMMU starts responding");
 
       if (turn_off_nozzle && resume_hotend_temp) {
         thermalManager.setTargetHotend(resume_hotend_temp, active_extruder);
         LCD_MESSAGE(MSG_HEATING);
         ERR_BUZZ();
-
         while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(1000);
       }
 
@@ -842,7 +850,6 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
       if (move_axes && all_axes_homed()) {
         // Move XY to starting position, then Z
         do_blocking_move_to_xy(resume_position, feedRate_t(NOZZLE_PARK_XY_FEEDRATE));
-
         // Move Z_AXIS to saved position
         do_blocking_move_to_z(resume_position.z, feedRate_t(NOZZLE_PARK_Z_FEEDRATE));
       }
@@ -877,23 +884,24 @@ void MMU2::filament_runout() {
       }
       // Slowly spin the extruder during C0
       else {
-        while (planner.movesplanned() < 3) {
-          current_position.e += 0.25;
-          line_to_current_position(MMM_TO_MMS(120));
-        }
+        while (planner.movesplanned() < 3)
+          unscaled_mmu2_e_move(0.25, MMM_TO_MMS(120), false);
       }
     }
     mmu2s_triggered = present;
   }
 
   bool MMU2::can_load() {
-    execute_extruder_sequence((const E_Step *)can_load_sequence, COUNT(can_load_sequence));
+    static const E_Step can_load_sequence[] PROGMEM = { MMU2_CAN_LOAD_SEQUENCE },
+                        can_load_increment_sequence[] PROGMEM = { MMU2_CAN_LOAD_INCREMENT_SEQUENCE };
+
+    execute_extruder_sequence(can_load_sequence, COUNT(can_load_sequence));
 
     int filament_detected_count = 0;
     const int steps = (MMU2_CAN_LOAD_RETRACT) / (MMU2_CAN_LOAD_INCREMENT);
     DEBUG_ECHOLNPGM("MMU can_load:");
     LOOP_L_N(i, steps) {
-      execute_extruder_sequence((const E_Step *)can_load_increment_sequence, COUNT(can_load_increment_sequence));
+      execute_extruder_sequence(can_load_increment_sequence, COUNT(can_load_increment_sequence));
       check_filament(); // Don't trust the idle function
       DEBUG_CHAR(mmu2s_triggered ? 'O' : 'o');
       if (mmu2s_triggered) ++filament_detected_count;
@@ -911,7 +919,7 @@ void MMU2::filament_runout() {
 #endif
 
 // Load filament into MMU2
-void MMU2::load_filament(const uint8_t index) {
+void MMU2::load_to_feeder(const uint8_t index) {
   if (!_enabled) return;
 
   command(MMU_CMD_L0 + index);
@@ -922,8 +930,7 @@ void MMU2::load_filament(const uint8_t index) {
 /**
  * Switch material and load to nozzle
  */
-bool MMU2::load_filament_to_nozzle(const uint8_t index) {
-
+bool MMU2::load_to_nozzle(const uint8_t index) {
   if (!_enabled) return false;
 
   if (thermalManager.tooColdToExtrude(active_extruder)) {
@@ -932,6 +939,13 @@ bool MMU2::load_filament_to_nozzle(const uint8_t index) {
     return false;
   }
 
+  if (TERN0(MMU_IR_UNLOAD_MOVE, index != extruder) && FILAMENT_PRESENT()) {
+    DEBUG_ECHOLNPGM("Unloading\n");
+    ramming_sequence();                             // Unloading instructions from printer side when operating LCD
+    while (FILAMENT_PRESENT())                      // Filament present? Keep unloading.
+      unscaled_mmu2_e_move(-0.25, MMM_TO_MMS(120)); // 0.25mm is a guessed value. Adjust to preference.
+  }
+
   stepper.disable_extruder();
   command(MMU_CMD_T0 + index);
   manage_response(true, true);
@@ -941,23 +955,12 @@ bool MMU2::load_filament_to_nozzle(const uint8_t index) {
     mmu_loop();
     extruder = index;
     active_extruder = 0;
-    load_to_nozzle();
+    load_to_nozzle_sequence();
     mmu2_attn_buzz();
   }
   return success;
 }
 
-/**
- * Load filament to nozzle of multimaterial printer
- *
- * This function is used only after T? (user select filament) and M600 (change filament).
- * It is not used after T0 .. T4 command (select filament), in such case, G-code is responsible for loading
- * filament to nozzle.
- */
-void MMU2::load_to_nozzle() {
-  execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
-}
-
 bool MMU2::eject_filament(const uint8_t index, const bool recover) {
 
   if (!_enabled) return false;
@@ -970,10 +973,7 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
 
   LCD_MESSAGE(MSG_MMU2_EJECTING_FILAMENT);
 
-  stepper.enable_extruder();
-  current_position.e -= MMU2_FILAMENTCHANGE_EJECT_FEED;
-  line_to_current_position(MMM_TO_MMS(2500));
-  planner.synchronize();
+  unscaled_mmu2_e_move(-(MMU2_FILAMENTCHANGE_EJECT_FEED), MMM_TO_MMS(2500));
   command(MMU_CMD_E0 + index);
   manage_response(false, false);
 
@@ -983,7 +983,7 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
     TERN_(HOST_PROMPT_SUPPORT, hostui.continue_prompt(GET_TEXT_F(MSG_MMU2_EJECT_RECOVER)));
     TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_MMU2_EJECT_RECOVER)));
     TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
-    mmu2_attn_buzz(true);
+    mmu2_attn_buzz();
 
     command(MMU_CMD_R0);
     manage_response(false, false);
@@ -1017,7 +1017,7 @@ bool MMU2::unload() {
   }
 
   // Unload sequence to optimize shape of the tip of the unloaded filament
-  execute_extruder_sequence((const E_Step *)ramming_sequence, sizeof(ramming_sequence) / sizeof(E_Step));
+  ramming_sequence();
 
   command(MMU_CMD_U0);
   manage_response(false, true);
@@ -1032,23 +1032,26 @@ bool MMU2::unload() {
   return true;
 }
 
-void MMU2::execute_extruder_sequence(const E_Step * sequence, int steps) {
+void MMU2::ramming_sequence() {
+  static const E_Step sequence[] PROGMEM = { MMU2_RAMMING_SEQUENCE };
+  execute_extruder_sequence(sequence, COUNT(sequence));
+}
+
+void MMU2::load_to_nozzle_sequence() {
+  static const E_Step sequence[] PROGMEM = { MMU2_LOAD_TO_NOZZLE_SEQUENCE };
+  execute_extruder_sequence(sequence, COUNT(sequence));
+}
 
+void MMU2::execute_extruder_sequence(const E_Step * sequence, int steps) {
   planner.synchronize();
-  stepper.enable_extruder();
 
-  const E_Step* step = sequence;
+  const E_Step *step = sequence;
 
   LOOP_L_N(i, steps) {
     const float es = pgm_read_float(&(step->extrude));
     const feedRate_t fr_mm_m = pgm_read_float(&(step->feedRate));
-
     DEBUG_ECHO_MSG("E step ", es, "/", fr_mm_m);
-
-    current_position.e += es;
-    line_to_current_position(MMM_TO_MMS(fr_mm_m));
-    planner.synchronize();
-
+    unscaled_mmu2_e_move(es, MMM_TO_MMS(fr_mm_m));
     step++;
   }
 

commit 78bdf34b7bc56a0a8aa193cfd824ad2841ed25dc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 14 18:06:56 2023 -0500

    üßë‚Äçüíª HostUI::continue_prompt method

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index b56e3d9c29..ea58c2859b 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -980,7 +980,7 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
   if (recover)  {
     LCD_MESSAGE(MSG_MMU2_REMOVE_AND_CLICK);
     mmu2_attn_buzz();
-    TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_do(PROMPT_USER_CONTINUE, GET_TEXT_F(MSG_MMU2_EJECT_RECOVER), FPSTR(CONTINUE_STR)));
+    TERN_(HOST_PROMPT_SUPPORT, hostui.continue_prompt(GET_TEXT_F(MSG_MMU2_EJECT_RECOVER)));
     TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_MMU2_EJECT_RECOVER)));
     TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
     mmu2_attn_buzz(true);

commit 9a1c02591ba4c3d5b41f4c64edd819ea1860b75b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 14 17:51:45 2023 -0500

    üßë‚Äçüíª Status Message cleanup

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 7b6a48954b..b56e3d9c29 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -978,10 +978,10 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
   manage_response(false, false);
 
   if (recover)  {
-    LCD_MESSAGE(MSG_MMU2_EJECT_RECOVER);
+    LCD_MESSAGE(MSG_MMU2_REMOVE_AND_CLICK);
     mmu2_attn_buzz();
-    TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_do(PROMPT_USER_CONTINUE, F("MMU2 Eject Recover"), FPSTR(CONTINUE_STR)));
-    TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(F("MMU2 Eject Recover")));
+    TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_do(PROMPT_USER_CONTINUE, GET_TEXT_F(MSG_MMU2_EJECT_RECOVER), FPSTR(CONTINUE_STR)));
+    TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_MMU2_EJECT_RECOVER)));
     TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
     mmu2_attn_buzz(true);
 

commit 3156595078c4d6ecdae5a5976ef0dbba060fa603
Author: jbubik <jbubik@centrum.cz>
Date:   Tue Mar 14 02:19:24 2023 +0100

    üêõ Fix Polargraph without Z (#25514)

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 4f86578a60..7b6a48954b 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -815,8 +815,7 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
         resume_hotend_temp = thermalManager.degTargetHotend(active_extruder);
         resume_position = current_position;
 
-        if (move_axes && all_axes_homed())
-          nozzle.park(0, park_point /*= NOZZLE_PARK_POINT*/);
+        if (move_axes && all_axes_homed()) nozzle.park(0, park_point);
 
         if (turn_off_nozzle) thermalManager.setTargetHotend(0, active_extruder);
 

commit 54a5bf5edf9a7f2de205d3038db2d6f406fca7ef
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 14 13:15:37 2022 -0500

    üé® MMU2 cleanup

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 54553a4f2d..4f86578a60 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -54,7 +54,8 @@ MMU2 mmu2;
 #define MMU_CMD_TIMEOUT 45000UL // 45s timeout for mmu commands (except P0)
 #define MMU_P0_TIMEOUT 3000UL   // Timeout for P0 command: 3seconds
 
-#define MMU2_COMMAND(S) tx_str(F(S "\n"))
+#define MMU2_SEND(S) tx_str(F(S "\n"))
+#define MMU2_RECV(S) rx_str(F(S "\n"))
 
 #if ENABLED(MMU_EXTRUDER_SENSOR)
   uint8_t mmu_idl_sens = 0;
@@ -131,7 +132,7 @@ void MMU2::reset() {
     safe_delay(20);
     WRITE(MMU2_RST_PIN, HIGH);
   #else
-    MMU2_COMMAND("X0"); // Send soft reset
+    MMU2_SEND("X0");  // Send soft reset
   #endif
 }
 
@@ -157,11 +158,9 @@ void MMU2::mmu_loop() {
     case -1:
       if (rx_start()) {
         prev_P0_request = millis();   // Initialize finda sensor timeout
-
         DEBUG_ECHOLNPGM("MMU => 'start'");
         DEBUG_ECHOLNPGM("MMU <= 'S1'");
-
-        MMU2_COMMAND("S1");   // Read Version
+        MMU2_SEND("S1");    // Read Version
         state = -2;
       }
       else if (millis() > 30000) { // 30sec after reset disable MMU
@@ -173,10 +172,8 @@ void MMU2::mmu_loop() {
     case -2:
       if (rx_ok()) {
         sscanf(rx_buffer, "%huok\n", &version);
-
         DEBUG_ECHOLNPGM("MMU => ", version, "\nMMU <= 'S2'");
-
-        MMU2_COMMAND("S2");   // Read Build Number
+        MMU2_SEND("S2");    // Read Build Number
         state = -3;
       }
       break;
@@ -191,14 +188,12 @@ void MMU2::mmu_loop() {
 
         #if ENABLED(MMU2_MODE_12V)
           DEBUG_ECHOLNPGM("MMU <= 'M1'");
-
-          MMU2_COMMAND("M1");   // Stealth Mode
+          MMU2_SEND("M1");    // Stealth Mode
           state = -5;
 
         #else
           DEBUG_ECHOLNPGM("MMU <= 'P0'");
-
-          MMU2_COMMAND("P0");   // Read FINDA
+          MMU2_SEND("P0");    // Read FINDA
           state = -4;
         #endif
       }
@@ -209,10 +204,8 @@ void MMU2::mmu_loop() {
       // response to M1
       if (rx_ok()) {
         DEBUG_ECHOLNPGM("MMU => ok");
-
         DEBUG_ECHOLNPGM("MMU <= 'P0'");
-
-        MMU2_COMMAND("P0");   // Read FINDA
+        MMU2_SEND("P0");    // Read FINDA
         state = -4;
       }
       break;
@@ -250,14 +243,13 @@ void MMU2::mmu_loop() {
         else if (cmd == MMU_CMD_C0) {
           // continue loading
           DEBUG_ECHOLNPGM("MMU <= 'C0'");
-          MMU2_COMMAND("C0");
+          MMU2_SEND("C0");
           state = 3; // wait for response
         }
         else if (cmd == MMU_CMD_U0) {
           // unload current
           DEBUG_ECHOLNPGM("MMU <= 'U0'");
-
-          MMU2_COMMAND("U0");
+          MMU2_SEND("U0");
           state = 3; // wait for response
         }
         else if (WITHIN(cmd, MMU_CMD_E0, MMU_CMD_E0 + EXTRUDERS - 1)) {
@@ -270,7 +262,7 @@ void MMU2::mmu_loop() {
         else if (cmd == MMU_CMD_R0) {
           // recover after eject
           DEBUG_ECHOLNPGM("MMU <= 'R0'");
-          MMU2_COMMAND("R0");
+          MMU2_SEND("R0");
           state = 3; // wait for response
         }
         else if (WITHIN(cmd, MMU_CMD_F0, MMU_CMD_F0 + EXTRUDERS - 1)) {
@@ -285,7 +277,7 @@ void MMU2::mmu_loop() {
         cmd = MMU_CMD_NONE;
       }
       else if (ELAPSED(millis(), prev_P0_request + 300)) {
-        MMU2_COMMAND("P0"); // Read FINDA
+        MMU2_SEND("P0");  // Read FINDA
         state = 2; // wait for response
       }
 
@@ -314,7 +306,7 @@ void MMU2::mmu_loop() {
         if (mmu_idl_sens) {
           if (FILAMENT_PRESENT() && mmu_loading_flag) {
             DEBUG_ECHOLNPGM("MMU <= 'A'");
-            MMU2_COMMAND("A"); // send 'abort' request
+            MMU2_SEND("A");   // send 'abort' request
             mmu_idl_sens = 0;
             DEBUG_ECHOLNPGM("MMU IDLER_SENSOR = 0 - ABORT");
           }
@@ -327,9 +319,9 @@ void MMU2::mmu_loop() {
           const bool keep_trying = !mmu2s_triggered && last_cmd == MMU_CMD_C0;
           if (keep_trying) {
             // MMU ok received but filament sensor not triggered, retrying...
-            DEBUG_ECHOLNPGM("MMU => 'ok' (filament not present in gears)");
+            DEBUG_ECHOLNPGM("MMU => 'ok' (no filament in gears)");
             DEBUG_ECHOLNPGM("MMU <= 'C0' (keep trying)");
-            MMU2_COMMAND("C0");
+            MMU2_SEND("C0");
           }
         #else
           constexpr bool keep_trying = false;
@@ -361,7 +353,7 @@ void MMU2::mmu_loop() {
  */
 bool MMU2::rx_start() {
   // check for start message
-  return rx_str(F("start\n"));
+  return MMU2_RECV("start");
 }
 
 /**
@@ -440,7 +432,7 @@ void MMU2::clear_rx_buffer() {
  * Check if we received 'ok' from MMU
  */
 bool MMU2::rx_ok() {
-  if (rx_str(F("ok\n"))) {
+  if (MMU2_RECV("ok")) {
     prev_P0_request = millis();
     return true;
   }
@@ -673,7 +665,7 @@ static void mmu2_not_responding() {
         // When (T0 rx->ok) load is ready, but in fact it did not load
         // successfully or an overload created pressure in the extruder.
         // Send (C0) to load more and move E_AXIS a little to release pressure.
-        if ((fil_present = FILAMENT_PRESENT())) MMU2_COMMAND("A");
+        if ((fil_present = FILAMENT_PRESENT())) MMU2_SEND("A");
       } while (!fil_present && PENDING(millis(), expire_ms));
       stepper.disable_extruder();
       manage_response(true, true);
@@ -882,7 +874,7 @@ void MMU2::filament_runout() {
     if (cmd == MMU_CMD_NONE && last_cmd == MMU_CMD_C0) {
       if (present && !mmu2s_triggered) {
         DEBUG_ECHOLNPGM("MMU <= 'A'");
-        tx_str(F("A\n"));
+        MMU2_SEND("A");
       }
       // Slowly spin the extruder during C0
       else {

commit 6fdf9bf2ea7be0ebd993b3cd26613c366c5d7499
Author: FBN <62633887+fBn0523@users.noreply.github.com>
Date:   Sun Sep 18 09:53:07 2022 +0800

    ‚úèÔ∏è MMU2 followup (#24770)
    
    Followup to #24750

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index c3bc2114b9..54553a4f2d 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -654,11 +654,12 @@ static void mmu2_not_responding() {
 
   void MMU2::mmu_continue_loading() {
     // Try to load the filament a limited number of times
+    bool fil_present = 0;
     for (uint8_t i = 0; i < MMU_LOADING_ATTEMPTS_NR; i++) {
       DEBUG_ECHOLNPGM("Load attempt #", i + 1);
 
       // Done as soon as filament is present
-      bool fil_present = FILAMENT_PRESENT();
+      fil_present = FILAMENT_PRESENT();
       if (fil_present) break;
 
       // Attempt to load the filament, 1mm at a time, for 3s

commit d0e7c2c20821d2d96e3c8e18f116b55cacfe0252
Author: FBN <62633887+fBn0523@users.noreply.github.com>
Date:   Fri Sep 16 07:02:08 2022 +0800

    üö∏ More automatic MMU2 load (#24750)

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index a4718b53d9..c3bc2114b9 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -585,7 +585,7 @@ static void mmu2_not_responding() {
       command(MMU_CMD_T0 + index);
       manage_response(true, true);
       mmu_continue_loading();
-      command(MMU_CMD_C0);
+      //command(MMU_CMD_C0);
       extruder = index;
       active_extruder = 0;
 
@@ -653,13 +653,33 @@ static void mmu2_not_responding() {
   }
 
   void MMU2::mmu_continue_loading() {
+    // Try to load the filament a limited number of times
     for (uint8_t i = 0; i < MMU_LOADING_ATTEMPTS_NR; i++) {
-      DEBUG_ECHOLNPGM("Additional load attempt #", i);
-      if (FILAMENT_PRESENT()) break;
+      DEBUG_ECHOLNPGM("Load attempt #", i + 1);
+
+      // Done as soon as filament is present
+      bool fil_present = FILAMENT_PRESENT();
+      if (fil_present) break;
+
+      // Attempt to load the filament, 1mm at a time, for 3s
       command(MMU_CMD_C0);
+      stepper.enable_extruder();
+      const millis_t expire_ms = millis() + 3000;
+      do {
+        current_position.e += 1;
+        line_to_current_position(MMU_LOAD_FEEDRATE);
+        planner.synchronize();
+        // When (T0 rx->ok) load is ready, but in fact it did not load
+        // successfully or an overload created pressure in the extruder.
+        // Send (C0) to load more and move E_AXIS a little to release pressure.
+        if ((fil_present = FILAMENT_PRESENT())) MMU2_COMMAND("A");
+      } while (!fil_present && PENDING(millis(), expire_ms));
+      stepper.disable_extruder();
       manage_response(true, true);
     }
-    if (!FILAMENT_PRESENT()) {
+
+    // Was the filament still missing in the last check?
+    if (!fil_present) {
       DEBUG_ECHOLNPGM("Filament never reached sensor, runout");
       filament_runout();
     }
@@ -682,7 +702,7 @@ static void mmu2_not_responding() {
       command(MMU_CMD_T0 + index);
       manage_response(true, true);
       command(MMU_CMD_C0);
-      extruder = index; //filament change is finished
+      extruder = index; // Filament change is finished
       active_extruder = 0;
       stepper.enable_extruder();
       SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, extruder);

commit 58ce5182c2ea93e79ccaef4c912c68aa554e637e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 31 12:43:44 2022 -0500

    üé® Fix spelling, whitespace

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 2544995c6d..a4718b53d9 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -939,7 +939,7 @@ bool MMU2::load_filament_to_nozzle(const uint8_t index) {
  * Load filament to nozzle of multimaterial printer
  *
  * This function is used only after T? (user select filament) and M600 (change filament).
- * It is not used after T0 .. T4 command (select filament), in such case, gcode is responsible for loading
+ * It is not used after T0 .. T4 command (select filament), in such case, G-code is responsible for loading
  * filament to nozzle.
  */
 void MMU2::load_to_nozzle() {

commit 1d4f928342a104ba97538ab68697f83c00c05a69
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 26 18:18:41 2022 -0500

    üé® Combine serial echos

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index a469c988c9..2544995c6d 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -1031,8 +1031,7 @@ void MMU2::execute_extruder_sequence(const E_Step * sequence, int steps) {
     const float es = pgm_read_float(&(step->extrude));
     const feedRate_t fr_mm_m = pgm_read_float(&(step->feedRate));
 
-    DEBUG_ECHO_START();
-    DEBUG_ECHOLNPGM("E step ", es, "/", fr_mm_m);
+    DEBUG_ECHO_MSG("E step ", es, "/", fr_mm_m);
 
     current_position.e += es;
     line_to_current_position(MMM_TO_MMS(fr_mm_m));

commit f1471c1549f8143b171b7decc7646ba2e09a6aee
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Mar 26 14:03:43 2022 +1300

    üêõ Fix MMU2 buzz (#23943)
    
    Followup to 89a9c3a391

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 7a7e27f287..a469c988c9 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -143,7 +143,10 @@ uint8_t MMU2::get_current_tool() {
   #define FILAMENT_PRESENT() (READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE)
 #endif
 
-inline void ATTN_BUZZ(const bool two=false) { BUZZ(200, 404); if (two) { BUZZ(10, 0); BUZZ(200, 404); } }
+void mmu2_attn_buzz(const bool two=false) {
+  BUZZ(200, 404);
+  if (two) { BUZZ(10, 0); BUZZ(200, 404); }
+}
 
 void MMU2::mmu_loop() {
 
@@ -819,7 +822,7 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
       }
 
       LCD_MESSAGE(MSG_MMU2_RESUMING);
-      ATTN_BUZZ(true);
+      mmu2_attn_buzz(true);
 
       #pragma GCC diagnostic push
       #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
@@ -901,7 +904,7 @@ void MMU2::load_filament(const uint8_t index) {
 
   command(MMU_CMD_L0 + index);
   manage_response(false, false);
-  ATTN_BUZZ();
+  mmu2_attn_buzz();
 }
 
 /**
@@ -912,7 +915,7 @@ bool MMU2::load_filament_to_nozzle(const uint8_t index) {
   if (!_enabled) return false;
 
   if (thermalManager.tooColdToExtrude(active_extruder)) {
-    ATTN_BUZZ();
+    mmu2_attn_buzz();
     LCD_ALERTMESSAGE(MSG_HOTEND_TOO_COLD);
     return false;
   }
@@ -927,7 +930,7 @@ bool MMU2::load_filament_to_nozzle(const uint8_t index) {
     extruder = index;
     active_extruder = 0;
     load_to_nozzle();
-    ATTN_BUZZ();
+    mmu2_attn_buzz();
   }
   return success;
 }
@@ -948,7 +951,7 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
   if (!_enabled) return false;
 
   if (thermalManager.tooColdToExtrude(active_extruder)) {
-    ATTN_BUZZ();
+    mmu2_attn_buzz();
     LCD_ALERTMESSAGE(MSG_HOTEND_TOO_COLD);
     return false;
   }
@@ -964,11 +967,11 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
 
   if (recover)  {
     LCD_MESSAGE(MSG_MMU2_EJECT_RECOVER);
-    ATTN_BUZZ();
+    mmu2_attn_buzz();
     TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_do(PROMPT_USER_CONTINUE, F("MMU2 Eject Recover"), FPSTR(CONTINUE_STR)));
     TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(F("MMU2 Eject Recover")));
     TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
-    ATTN_BUZZ(true);
+    mmu2_attn_buzz(true);
 
     command(MMU_CMD_R0);
     manage_response(false, false);
@@ -981,7 +984,7 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
 
   set_runout_valid(false);
 
-  ATTN_BUZZ();
+  mmu2_attn_buzz();
 
   stepper.disable_extruder();
 
@@ -996,7 +999,7 @@ bool MMU2::unload() {
   if (!_enabled) return false;
 
   if (thermalManager.tooColdToExtrude(active_extruder)) {
-    ATTN_BUZZ();
+    mmu2_attn_buzz();
     LCD_ALERTMESSAGE(MSG_HOTEND_TOO_COLD);
     return false;
   }
@@ -1007,7 +1010,7 @@ bool MMU2::unload() {
   command(MMU_CMD_U0);
   manage_response(false, true);
 
-  ATTN_BUZZ();
+  mmu2_attn_buzz();
 
   // no active tool
   extruder = MMU2_NO_TOOL;

commit 98dcb9e614a4cc81d7f33d91f02de1d55bc7b3e6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 22 19:20:19 2022 -0500

    üî® Suppress MMU2 resume_position warning

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 28dea681ef..7a7e27f287 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -821,6 +821,9 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
       LCD_MESSAGE(MSG_MMU2_RESUMING);
       ATTN_BUZZ(true);
 
+      #pragma GCC diagnostic push
+      #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
+
       if (move_axes && all_axes_homed()) {
         // Move XY to starting position, then Z
         do_blocking_move_to_xy(resume_position, feedRate_t(NOZZLE_PARK_XY_FEEDRATE));
@@ -828,6 +831,8 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
         // Move Z_AXIS to saved position
         do_blocking_move_to_z(resume_position.z, feedRate_t(NOZZLE_PARK_Z_FEEDRATE));
       }
+
+      #pragma GCC diagnostic pop
     }
   }
 }

commit 89a9c3a391101e4d2d8dbfbf0cdb261ad2d9592b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 12 16:34:58 2022 -0600

    üßë‚Äçüíª  Add standard BUZZ types

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 2813337c63..28dea681ef 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -143,6 +143,8 @@ uint8_t MMU2::get_current_tool() {
   #define FILAMENT_PRESENT() (READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE)
 #endif
 
+inline void ATTN_BUZZ(const bool two=false) { BUZZ(200, 404); if (two) { BUZZ(10, 0); BUZZ(200, 404); } }
+
 void MMU2::mmu_loop() {
 
   switch (state) {
@@ -525,7 +527,7 @@ static void mmu2_not_responding() {
             while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
             load_filament_to_nozzle(index);
           #else
-            BUZZ(400, 40);
+            ERR_BUZZ();
           #endif
         } break;
 
@@ -544,7 +546,7 @@ static void mmu2_not_responding() {
               active_extruder = 0;
             }
           #else
-            BUZZ(400, 40);
+            ERR_BUZZ();
           #endif
         } break;
 
@@ -613,7 +615,7 @@ static void mmu2_not_responding() {
           while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
           load_filament_to_nozzle(index);
         #else
-          BUZZ(400, 40);
+          ERR_BUZZ();
         #endif
       } break;
 
@@ -633,7 +635,7 @@ static void mmu2_not_responding() {
           extruder = index;
           active_extruder = 0;
         #else
-          BUZZ(400, 40);
+          ERR_BUZZ();
         #endif
       } break;
 
@@ -707,7 +709,7 @@ static void mmu2_not_responding() {
           while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
           load_filament_to_nozzle(index);
         #else
-          BUZZ(400, 40);
+          ERR_BUZZ();
         #endif
       } break;
 
@@ -726,7 +728,7 @@ static void mmu2_not_responding() {
           extruder = index;
           active_extruder = 0;
         #else
-          BUZZ(400, 40);
+          ERR_BUZZ();
         #endif
       } break;
 
@@ -811,25 +813,21 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
       if (turn_off_nozzle && resume_hotend_temp) {
         thermalManager.setTargetHotend(resume_hotend_temp, active_extruder);
         LCD_MESSAGE(MSG_HEATING);
-        BUZZ(200, 40);
+        ERR_BUZZ();
 
         while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(1000);
       }
 
-      if (move_axes && all_axes_homed()) {
-        LCD_MESSAGE(MSG_MMU2_RESUMING);
-        BUZZ(198, 404); BUZZ(4, 0); BUZZ(198, 404);
+      LCD_MESSAGE(MSG_MMU2_RESUMING);
+      ATTN_BUZZ(true);
 
+      if (move_axes && all_axes_homed()) {
         // Move XY to starting position, then Z
         do_blocking_move_to_xy(resume_position, feedRate_t(NOZZLE_PARK_XY_FEEDRATE));
 
         // Move Z_AXIS to saved position
         do_blocking_move_to_z(resume_position.z, feedRate_t(NOZZLE_PARK_Z_FEEDRATE));
       }
-      else {
-        BUZZ(198, 404); BUZZ(4, 0); BUZZ(198, 404);
-        LCD_MESSAGE(MSG_MMU2_RESUMING);
-      }
     }
   }
 }
@@ -898,7 +896,7 @@ void MMU2::load_filament(const uint8_t index) {
 
   command(MMU_CMD_L0 + index);
   manage_response(false, false);
-  BUZZ(200, 404);
+  ATTN_BUZZ();
 }
 
 /**
@@ -909,7 +907,7 @@ bool MMU2::load_filament_to_nozzle(const uint8_t index) {
   if (!_enabled) return false;
 
   if (thermalManager.tooColdToExtrude(active_extruder)) {
-    BUZZ(200, 404);
+    ATTN_BUZZ();
     LCD_ALERTMESSAGE(MSG_HOTEND_TOO_COLD);
     return false;
   }
@@ -924,7 +922,7 @@ bool MMU2::load_filament_to_nozzle(const uint8_t index) {
     extruder = index;
     active_extruder = 0;
     load_to_nozzle();
-    BUZZ(200, 404);
+    ATTN_BUZZ();
   }
   return success;
 }
@@ -945,7 +943,7 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
   if (!_enabled) return false;
 
   if (thermalManager.tooColdToExtrude(active_extruder)) {
-    BUZZ(200, 404);
+    ATTN_BUZZ();
     LCD_ALERTMESSAGE(MSG_HOTEND_TOO_COLD);
     return false;
   }
@@ -961,12 +959,11 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
 
   if (recover)  {
     LCD_MESSAGE(MSG_MMU2_EJECT_RECOVER);
-    BUZZ(200, 404);
+    ATTN_BUZZ();
     TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_do(PROMPT_USER_CONTINUE, F("MMU2 Eject Recover"), FPSTR(CONTINUE_STR)));
     TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(F("MMU2 Eject Recover")));
     TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
-    BUZZ(200, 404);
-    BUZZ(200, 404);
+    ATTN_BUZZ(true);
 
     command(MMU_CMD_R0);
     manage_response(false, false);
@@ -979,7 +976,7 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
 
   set_runout_valid(false);
 
-  BUZZ(200, 404);
+  ATTN_BUZZ();
 
   stepper.disable_extruder();
 
@@ -994,7 +991,7 @@ bool MMU2::unload() {
   if (!_enabled) return false;
 
   if (thermalManager.tooColdToExtrude(active_extruder)) {
-    BUZZ(200, 404);
+    ATTN_BUZZ();
     LCD_ALERTMESSAGE(MSG_HOTEND_TOO_COLD);
     return false;
   }
@@ -1005,7 +1002,7 @@ bool MMU2::unload() {
   command(MMU_CMD_U0);
   manage_response(false, true);
 
-  BUZZ(200, 404);
+  ATTN_BUZZ();
 
   // no active tool
   extruder = MMU2_NO_TOOL;

commit ee28a14e8e7f6b33fe5813dbedcd85380207c345
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 15 00:24:08 2021 -0500

    üé® Refactor Host Actions as singleton

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 56e6e6150b..2813337c63 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -962,7 +962,7 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
   if (recover)  {
     LCD_MESSAGE(MSG_MMU2_EJECT_RECOVER);
     BUZZ(200, 404);
-    TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, F("MMU2 Eject Recover"), FPSTR(CONTINUE_STR)));
+    TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_do(PROMPT_USER_CONTINUE, F("MMU2 Eject Recover"), FPSTR(CONTINUE_STR)));
     TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(F("MMU2 Eject Recover")));
     TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
     BUZZ(200, 404);

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    üé® Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index b2835dc3ce..56e6e6150b 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -448,7 +448,7 @@ bool MMU2::rx_ok() {
 void MMU2::check_version() {
   if (buildnr < MMU_REQUIRED_FW_BUILDNR) {
     SERIAL_ERROR_MSG("Invalid MMU2 firmware. Version >= " STRINGIFY(MMU_REQUIRED_FW_BUILDNR) " required.");
-    kill(GET_TEXT(MSG_KILL_MMU2_FIRMWARE));
+    kill(GET_TEXT_F(MSG_KILL_MMU2_FIRMWARE));
   }
 }
 

commit eeffac697c5d7b69e01e38ed1602dbd21a366e93
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 25 23:52:41 2021 -0500

    üé® Apply F() to UTF-8/MMU2 string put

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 363e4d5505..b2835dc3ce 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -54,7 +54,7 @@ MMU2 mmu2;
 #define MMU_CMD_TIMEOUT 45000UL // 45s timeout for mmu commands (except P0)
 #define MMU_P0_TIMEOUT 3000UL   // Timeout for P0 command: 3seconds
 
-#define MMU2_COMMAND(S) tx_str_P(PSTR(S "\n"))
+#define MMU2_COMMAND(S) tx_str(F(S "\n"))
 
 #if ENABLED(MMU_EXTRUDER_SENSOR)
   uint8_t mmu_idl_sens = 0;
@@ -229,17 +229,17 @@ void MMU2::mmu_loop() {
       if (cmd) {
         if (WITHIN(cmd, MMU_CMD_T0, MMU_CMD_T0 + EXTRUDERS - 1)) {
           // tool change
-          int filament = cmd - MMU_CMD_T0;
+          const int filament = cmd - MMU_CMD_T0;
           DEBUG_ECHOLNPGM("MMU <= T", filament);
-          tx_printf_P(PSTR("T%d\n"), filament);
+          tx_printf(F("T%d\n"), filament);
           TERN_(MMU_EXTRUDER_SENSOR, mmu_idl_sens = 1); // enable idler sensor, if any
           state = 3; // wait for response
         }
         else if (WITHIN(cmd, MMU_CMD_L0, MMU_CMD_L0 + EXTRUDERS - 1)) {
           // load
-          int filament = cmd - MMU_CMD_L0;
+          const int filament = cmd - MMU_CMD_L0;
           DEBUG_ECHOLNPGM("MMU <= L", filament);
-          tx_printf_P(PSTR("L%d\n"), filament);
+          tx_printf(F("L%d\n"), filament);
           state = 3; // wait for response
         }
         else if (cmd == MMU_CMD_C0) {
@@ -257,9 +257,9 @@ void MMU2::mmu_loop() {
         }
         else if (WITHIN(cmd, MMU_CMD_E0, MMU_CMD_E0 + EXTRUDERS - 1)) {
           // eject filament
-          int filament = cmd - MMU_CMD_E0;
+          const int filament = cmd - MMU_CMD_E0;
           DEBUG_ECHOLNPGM("MMU <= E", filament);
-          tx_printf_P(PSTR("E%d\n"), filament);
+          tx_printf(F("E%d\n"), filament);
           state = 3; // wait for response
         }
         else if (cmd == MMU_CMD_R0) {
@@ -270,9 +270,9 @@ void MMU2::mmu_loop() {
         }
         else if (WITHIN(cmd, MMU_CMD_F0, MMU_CMD_F0 + EXTRUDERS - 1)) {
           // filament type
-          int filament = cmd - MMU_CMD_F0;
+          const int filament = cmd - MMU_CMD_F0;
           DEBUG_ECHOLNPGM("MMU <= F", filament, " ", cmd_arg);
-          tx_printf_P(PSTR("F%d %d\n"), filament, cmd_arg);
+          tx_printf(F("F%d %d\n"), filament, cmd_arg);
           state = 3; // wait for response
         }
 
@@ -356,13 +356,15 @@ void MMU2::mmu_loop() {
  */
 bool MMU2::rx_start() {
   // check for start message
-  return rx_str_P(PSTR("start\n"));
+  return rx_str(F("start\n"));
 }
 
 /**
  * Check if the data received ends with the given string.
  */
-bool MMU2::rx_str_P(const char *str) {
+bool MMU2::rx_str(FSTR_P fstr) {
+  PGM_P pstr = FTOP(fstr);
+
   uint8_t i = strlen(rx_buffer);
 
   while (MMU2_SERIAL.available()) {
@@ -375,14 +377,14 @@ bool MMU2::rx_str_P(const char *str) {
   }
   rx_buffer[i] = '\0';
 
-  uint8_t len = strlen_P(str);
+  uint8_t len = strlen_P(pstr);
 
   if (i < len) return false;
 
-  str += len;
+  pstr += len;
 
   while (len--) {
-    char c0 = pgm_read_byte(str--), c1 = rx_buffer[i--];
+    char c0 = pgm_read_byte(pstr--), c1 = rx_buffer[i--];
     if (c0 == c1) continue;
     if (c0 == '\r' && c1 == '\n') continue;  // match cr as lf
     if (c0 == '\n' && c1 == '\r') continue;  // match lf as cr
@@ -394,19 +396,19 @@ bool MMU2::rx_str_P(const char *str) {
 /**
  * Transfer data to MMU, no argument
  */
-void MMU2::tx_str_P(const char *str) {
+void MMU2::tx_str(FSTR_P fstr) {
   clear_rx_buffer();
-  uint8_t len = strlen_P(str);
-  LOOP_L_N(i, len) MMU2_SERIAL.write(pgm_read_byte(str++));
+  PGM_P pstr = FTOP(fstr);
+  while (const char c = pgm_read_byte(pstr)) { MMU2_SERIAL.write(c); pstr++; }
   prev_request = millis();
 }
 
 /**
  * Transfer data to MMU, single argument
  */
-void MMU2::tx_printf_P(const char *format, int argument = -1) {
+void MMU2::tx_printf(FSTR_P format, int argument = -1) {
   clear_rx_buffer();
-  uint8_t len = sprintf_P(tx_buffer, format, argument);
+  const uint8_t len = sprintf_P(tx_buffer, FTOP(format), argument);
   LOOP_L_N(i, len) MMU2_SERIAL.write(tx_buffer[i]);
   prev_request = millis();
 }
@@ -414,9 +416,9 @@ void MMU2::tx_printf_P(const char *format, int argument = -1) {
 /**
  * Transfer data to MMU, two arguments
  */
-void MMU2::tx_printf_P(const char *format, int argument1, int argument2) {
+void MMU2::tx_printf(FSTR_P format, int argument1, int argument2) {
   clear_rx_buffer();
-  uint8_t len = sprintf_P(tx_buffer, format, argument1, argument2);
+  const uint8_t len = sprintf_P(tx_buffer, FTOP(format), argument1, argument2);
   LOOP_L_N(i, len) MMU2_SERIAL.write(tx_buffer[i]);
   prev_request = millis();
 }
@@ -433,7 +435,7 @@ void MMU2::clear_rx_buffer() {
  * Check if we received 'ok' from MMU
  */
 bool MMU2::rx_ok() {
-  if (rx_str_P(PSTR("ok\n"))) {
+  if (rx_str(F("ok\n"))) {
     prev_P0_request = millis();
     return true;
   }
@@ -853,7 +855,7 @@ void MMU2::filament_runout() {
     if (cmd == MMU_CMD_NONE && last_cmd == MMU_CMD_C0) {
       if (present && !mmu2s_triggered) {
         DEBUG_ECHOLNPGM("MMU <= 'A'");
-        tx_str_P(PSTR("A\n"));
+        tx_str(F("A\n"));
       }
       // Slowly spin the extruder during C0
       else {

commit 12b5d997a2cee538e5026a68f8e0cfdd53248986
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 25 22:11:48 2021 -0500

    üé® Apply F() to some ExtUI functions

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 14f2623e14..363e4d5505 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -961,7 +961,7 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
     LCD_MESSAGE(MSG_MMU2_EJECT_RECOVER);
     BUZZ(200, 404);
     TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, F("MMU2 Eject Recover"), FPSTR(CONTINUE_STR)));
-    TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired_P(PSTR("MMU2 Eject Recover")));
+    TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired(F("MMU2 Eject Recover")));
     TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
     BUZZ(200, 404);
     BUZZ(200, 404);

commit 008bf1bcaef181cd1b74638692e2465bb9e07a4d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 11:55:08 2021 -0500

    üé® Apply F() to Host Actions strings

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 7362530e35..14f2623e14 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -960,7 +960,7 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
   if (recover)  {
     LCD_MESSAGE(MSG_MMU2_EJECT_RECOVER);
     BUZZ(200, 404);
-    TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, PSTR("MMU2 Eject Recover"), CONTINUE_STR));
+    TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, F("MMU2 Eject Recover"), FPSTR(CONTINUE_STR)));
     TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired_P(PSTR("MMU2 Eject Recover")));
     TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
     BUZZ(200, 404);

commit 7f1286a11f87065c4e666985e679cf9c77d668bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 17:05:11 2021 -0500

    üé® Apply F() to status message

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index d9a4c07d57..7362530e35 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -451,7 +451,7 @@ void MMU2::check_version() {
 }
 
 static void mmu2_not_responding() {
-  LCD_MESSAGEPGM(MSG_MMU2_NOT_RESPONDING);
+  LCD_MESSAGE(MSG_MMU2_NOT_RESPONDING);
   BUZZ(100, 659);
   BUZZ(200, 698);
   BUZZ(100, 659);
@@ -487,7 +487,7 @@ static void mmu2_not_responding() {
     if (index != extruder) {
 
       stepper.disable_extruder();
-      ui.status_printf_P(0, GET_TEXT(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
+      ui.status_printf(0, GET_TEXT_F(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
 
       command(MMU_CMD_T0 + index);
       manage_response(true, true);
@@ -573,7 +573,7 @@ static void mmu2_not_responding() {
         command(MMU_CMD_U0);
         manage_response(true, true);
       }
-      ui.status_printf_P(0, GET_TEXT(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
+      ui.status_printf(0, GET_TEXT_F(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
       mmu_loading_flag = true;
       command(MMU_CMD_T0 + index);
       manage_response(true, true);
@@ -671,7 +671,7 @@ static void mmu2_not_responding() {
 
     if (index != extruder) {
       stepper.disable_extruder();
-      ui.status_printf_P(0, GET_TEXT(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
+      ui.status_printf(0, GET_TEXT_F(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
       command(MMU_CMD_T0 + index);
       manage_response(true, true);
       command(MMU_CMD_C0);
@@ -808,14 +808,14 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
 
       if (turn_off_nozzle && resume_hotend_temp) {
         thermalManager.setTargetHotend(resume_hotend_temp, active_extruder);
-        LCD_MESSAGEPGM(MSG_HEATING);
+        LCD_MESSAGE(MSG_HEATING);
         BUZZ(200, 40);
 
         while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(1000);
       }
 
       if (move_axes && all_axes_homed()) {
-        LCD_MESSAGEPGM(MSG_MMU2_RESUMING);
+        LCD_MESSAGE(MSG_MMU2_RESUMING);
         BUZZ(198, 404); BUZZ(4, 0); BUZZ(198, 404);
 
         // Move XY to starting position, then Z
@@ -826,7 +826,7 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
       }
       else {
         BUZZ(198, 404); BUZZ(4, 0); BUZZ(198, 404);
-        LCD_MESSAGEPGM(MSG_MMU2_RESUMING);
+        LCD_MESSAGE(MSG_MMU2_RESUMING);
       }
     }
   }
@@ -908,7 +908,7 @@ bool MMU2::load_filament_to_nozzle(const uint8_t index) {
 
   if (thermalManager.tooColdToExtrude(active_extruder)) {
     BUZZ(200, 404);
-    LCD_ALERTMESSAGEPGM(MSG_HOTEND_TOO_COLD);
+    LCD_ALERTMESSAGE(MSG_HOTEND_TOO_COLD);
     return false;
   }
 
@@ -944,11 +944,11 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
 
   if (thermalManager.tooColdToExtrude(active_extruder)) {
     BUZZ(200, 404);
-    LCD_ALERTMESSAGEPGM(MSG_HOTEND_TOO_COLD);
+    LCD_ALERTMESSAGE(MSG_HOTEND_TOO_COLD);
     return false;
   }
 
-  LCD_MESSAGEPGM(MSG_MMU2_EJECTING_FILAMENT);
+  LCD_MESSAGE(MSG_MMU2_EJECTING_FILAMENT);
 
   stepper.enable_extruder();
   current_position.e -= MMU2_FILAMENTCHANGE_EJECT_FEED;
@@ -958,7 +958,7 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
   manage_response(false, false);
 
   if (recover)  {
-    LCD_MESSAGEPGM(MSG_MMU2_EJECT_RECOVER);
+    LCD_MESSAGE(MSG_MMU2_EJECT_RECOVER);
     BUZZ(200, 404);
     TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, PSTR("MMU2 Eject Recover"), CONTINUE_STR));
     TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired_P(PSTR("MMU2 Eject Recover")));
@@ -993,7 +993,7 @@ bool MMU2::unload() {
 
   if (thermalManager.tooColdToExtrude(active_extruder)) {
     BUZZ(200, 404);
-    LCD_ALERTMESSAGEPGM(MSG_HOTEND_TOO_COLD);
+    LCD_ALERTMESSAGE(MSG_HOTEND_TOO_COLD);
     return false;
   }
 

commit 417e2530ebc5b6c74ac34adaba8be552b407383a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 21:11:31 2021 -0500

    üé® Apply F() to G-code suite and queue

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 3727c8c86d..d9a4c07d57 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -842,7 +842,7 @@ void MMU2::set_filament_type(const uint8_t index, const uint8_t filamentType) {
 }
 
 void MMU2::filament_runout() {
-  queue.inject_P(PSTR(MMU2_FILAMENT_RUNOUT_SCRIPT));
+  queue.inject(F(MMU2_FILAMENT_RUNOUT_SCRIPT));
   planner.synchronize();
 }
 

commit 33e0855e2c173680865aaa6c6aa93047d63fc469
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 01:07:51 2021 -0500

    ‚ö°Ô∏è Handle shared enable pins (#22824)

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index cf03eaf7f6..3727c8c86d 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -35,7 +35,7 @@ MMU2 mmu2;
 #include "../../libs/nozzle.h"
 #include "../../module/temperature.h"
 #include "../../module/planner.h"
-#include "../../module/stepper/indirection.h"
+#include "../../module/stepper.h"
 #include "../../MarlinCore.h"
 
 #if ENABLED(HOST_PROMPT_SUPPORT)
@@ -486,7 +486,7 @@ static void mmu2_not_responding() {
 
     if (index != extruder) {
 
-      DISABLE_AXIS_E0();
+      stepper.disable_extruder();
       ui.status_printf_P(0, GET_TEXT(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
 
       command(MMU_CMD_T0 + index);
@@ -495,7 +495,7 @@ static void mmu2_not_responding() {
       if (load_to_gears()) {
         extruder = index; // filament change is finished
         active_extruder = 0;
-        ENABLE_AXIS_E0();
+        stepper.enable_extruder();
         SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, extruder);
       }
       ui.reset_status();
@@ -531,13 +531,13 @@ static void mmu2_not_responding() {
           #if ENABLED(MMU2_MENUS)
             planner.synchronize();
             const uint8_t index = mmu2_choose_filament();
-            DISABLE_AXIS_E0();
+            stepper.disable_extruder();
             command(MMU_CMD_T0 + index);
             manage_response(true, true);
 
             if (load_to_gears()) {
               mmu_loop();
-              ENABLE_AXIS_E0();
+              stepper.enable_extruder();
               extruder = index;
               active_extruder = 0;
             }
@@ -566,7 +566,7 @@ static void mmu2_not_responding() {
     set_runout_valid(false);
 
     if (index != extruder) {
-      DISABLE_AXIS_E0();
+      stepper.disable_extruder();
       if (FILAMENT_PRESENT()) {
         DEBUG_ECHOLNPGM("Unloading\n");
         mmu_loading_flag = false;
@@ -582,7 +582,7 @@ static void mmu2_not_responding() {
       extruder = index;
       active_extruder = 0;
 
-      ENABLE_AXIS_E0();
+      stepper.enable_extruder();
       SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, extruder);
 
       ui.reset_status();
@@ -620,14 +620,14 @@ static void mmu2_not_responding() {
         #if ENABLED(MMU2_MENUS)
           planner.synchronize();
           uint8_t index = mmu2_choose_filament();
-          DISABLE_AXIS_E0();
+          stepper.disable_extruder();
           command(MMU_CMD_T0 + index);
           manage_response(true, true);
           mmu_continue_loading();
           command(MMU_CMD_C0);
           mmu_loop();
 
-          ENABLE_AXIS_E0();
+          stepper.enable_extruder();
           extruder = index;
           active_extruder = 0;
         #else
@@ -670,14 +670,14 @@ static void mmu2_not_responding() {
     set_runout_valid(false);
 
     if (index != extruder) {
-      DISABLE_AXIS_E0();
+      stepper.disable_extruder();
       ui.status_printf_P(0, GET_TEXT(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
       command(MMU_CMD_T0 + index);
       manage_response(true, true);
       command(MMU_CMD_C0);
       extruder = index; //filament change is finished
       active_extruder = 0;
-      ENABLE_AXIS_E0();
+      stepper.enable_extruder();
       SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, extruder);
       ui.reset_status();
     }
@@ -714,13 +714,13 @@ static void mmu2_not_responding() {
         #if ENABLED(MMU2_MENUS)
           planner.synchronize();
           uint8_t index = mmu2_choose_filament();
-          DISABLE_AXIS_E0();
+          stepper.disable_extruder();
           command(MMU_CMD_T0 + index);
           manage_response(true, true);
           command(MMU_CMD_C0);
           mmu_loop();
 
-          ENABLE_AXIS_E0();
+          stepper.enable_extruder();
           extruder = index;
           active_extruder = 0;
         #else
@@ -912,7 +912,7 @@ bool MMU2::load_filament_to_nozzle(const uint8_t index) {
     return false;
   }
 
-  DISABLE_AXIS_E0();
+  stepper.disable_extruder();
   command(MMU_CMD_T0 + index);
   manage_response(true, true);
 
@@ -950,7 +950,7 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
 
   LCD_MESSAGEPGM(MSG_MMU2_EJECTING_FILAMENT);
 
-  ENABLE_AXIS_E0();
+  stepper.enable_extruder();
   current_position.e -= MMU2_FILAMENTCHANGE_EJECT_FEED;
   line_to_current_position(MMM_TO_MMS(2500));
   planner.synchronize();
@@ -979,7 +979,7 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
 
   BUZZ(200, 404);
 
-  DISABLE_AXIS_E0();
+  stepper.disable_extruder();
 
   return true;
 }
@@ -1016,7 +1016,7 @@ bool MMU2::unload() {
 void MMU2::execute_extruder_sequence(const E_Step * sequence, int steps) {
 
   planner.synchronize();
-  ENABLE_AXIS_E0();
+  stepper.enable_extruder();
 
   const E_Step* step = sequence;
 
@@ -1034,7 +1034,7 @@ void MMU2::execute_extruder_sequence(const E_Step * sequence, int steps) {
     step++;
   }
 
-  DISABLE_AXIS_E0();
+  stepper.disable_extruder();
 }
 
 #endif // HAS_PRUSA_MMU2

commit 6b9b2c5d7382b30dabc2f1fb360d62a819f5ec3d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 11 02:15:05 2021 -0500

    ü©π Warn about user feedback requirement

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 31e64f4953..cf03eaf7f6 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -962,7 +962,7 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
     BUZZ(200, 404);
     TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, PSTR("MMU2 Eject Recover"), CONTINUE_STR));
     TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired_P(PSTR("MMU2 Eject Recover")));
-    wait_for_user_response();
+    TERN_(HAS_RESUME_CONTINUE, wait_for_user_response());
     BUZZ(200, 404);
     BUZZ(200, 404);
 

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 1acd26f331..31e64f4953 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -169,7 +169,7 @@ void MMU2::mmu_loop() {
       if (rx_ok()) {
         sscanf(rx_buffer, "%huok\n", &version);
 
-        DEBUG_ECHOLNPAIR("MMU => ", version, "\nMMU <= 'S2'");
+        DEBUG_ECHOLNPGM("MMU => ", version, "\nMMU <= 'S2'");
 
         MMU2_COMMAND("S2");   // Read Build Number
         state = -3;
@@ -180,7 +180,7 @@ void MMU2::mmu_loop() {
       if (rx_ok()) {
         sscanf(rx_buffer, "%huok\n", &buildnr);
 
-        DEBUG_ECHOLNPAIR("MMU => ", buildnr);
+        DEBUG_ECHOLNPGM("MMU => ", buildnr);
 
         check_version();
 
@@ -217,7 +217,7 @@ void MMU2::mmu_loop() {
       if (rx_ok()) {
         sscanf(rx_buffer, "%hhuok\n", &finda);
 
-        DEBUG_ECHOLNPAIR("MMU => ", finda, "\nMMU - ENABLED");
+        DEBUG_ECHOLNPGM("MMU => ", finda, "\nMMU - ENABLED");
 
         _enabled = true;
         state = 1;
@@ -230,7 +230,7 @@ void MMU2::mmu_loop() {
         if (WITHIN(cmd, MMU_CMD_T0, MMU_CMD_T0 + EXTRUDERS - 1)) {
           // tool change
           int filament = cmd - MMU_CMD_T0;
-          DEBUG_ECHOLNPAIR("MMU <= T", filament);
+          DEBUG_ECHOLNPGM("MMU <= T", filament);
           tx_printf_P(PSTR("T%d\n"), filament);
           TERN_(MMU_EXTRUDER_SENSOR, mmu_idl_sens = 1); // enable idler sensor, if any
           state = 3; // wait for response
@@ -238,7 +238,7 @@ void MMU2::mmu_loop() {
         else if (WITHIN(cmd, MMU_CMD_L0, MMU_CMD_L0 + EXTRUDERS - 1)) {
           // load
           int filament = cmd - MMU_CMD_L0;
-          DEBUG_ECHOLNPAIR("MMU <= L", filament);
+          DEBUG_ECHOLNPGM("MMU <= L", filament);
           tx_printf_P(PSTR("L%d\n"), filament);
           state = 3; // wait for response
         }
@@ -258,7 +258,7 @@ void MMU2::mmu_loop() {
         else if (WITHIN(cmd, MMU_CMD_E0, MMU_CMD_E0 + EXTRUDERS - 1)) {
           // eject filament
           int filament = cmd - MMU_CMD_E0;
-          DEBUG_ECHOLNPAIR("MMU <= E", filament);
+          DEBUG_ECHOLNPGM("MMU <= E", filament);
           tx_printf_P(PSTR("E%d\n"), filament);
           state = 3; // wait for response
         }
@@ -271,7 +271,7 @@ void MMU2::mmu_loop() {
         else if (WITHIN(cmd, MMU_CMD_F0, MMU_CMD_F0 + EXTRUDERS - 1)) {
           // filament type
           int filament = cmd - MMU_CMD_F0;
-          DEBUG_ECHOLNPAIR("MMU <= F", filament, " ", cmd_arg);
+          DEBUG_ECHOLNPGM("MMU <= F", filament, " ", cmd_arg);
           tx_printf_P(PSTR("F%d %d\n"), filament, cmd_arg);
           state = 3; // wait for response
         }
@@ -647,7 +647,7 @@ static void mmu2_not_responding() {
 
   void MMU2::mmu_continue_loading() {
     for (uint8_t i = 0; i < MMU_LOADING_ATTEMPTS_NR; i++) {
-      DEBUG_ECHOLNPAIR("Additional load attempt #", i);
+      DEBUG_ECHOLNPGM("Additional load attempt #", i);
       if (FILAMENT_PRESENT()) break;
       command(MMU_CMD_C0);
       manage_response(true, true);
@@ -1025,7 +1025,7 @@ void MMU2::execute_extruder_sequence(const E_Step * sequence, int steps) {
     const feedRate_t fr_mm_m = pgm_read_float(&(step->feedRate));
 
     DEBUG_ECHO_START();
-    DEBUG_ECHOLNPAIR("E step ", es, "/", fr_mm_m);
+    DEBUG_ECHOLNPGM("E step ", es, "/", fr_mm_m);
 
     current_position.e += es;
     line_to_current_position(MMM_TO_MMS(fr_mm_m));

commit be1801703c4510dcd523de811e9dcff576b4caad
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jul 17 03:10:54 2021 -0500

    üé® Add MMU2 enabled() accessor

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 8a4f5ae071..1acd26f331 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -75,7 +75,7 @@ MMU2 mmu2;
 #define MMU2_NO_TOOL 99
 #define MMU_BAUD    115200
 
-bool MMU2::enabled, MMU2::ready, MMU2::mmu_print_saved;
+bool MMU2::_enabled, MMU2::ready, MMU2::mmu_print_saved;
 #if HAS_PRUSA_MMU2S
   bool MMU2::mmu2s_triggered;
 #endif
@@ -219,7 +219,7 @@ void MMU2::mmu_loop() {
 
         DEBUG_ECHOLNPAIR("MMU => ", finda, "\nMMU - ENABLED");
 
-        enabled = true;
+        _enabled = true;
         state = 1;
         TERN_(HAS_PRUSA_MMU2S, mmu2s_triggered = false);
       }
@@ -480,7 +480,7 @@ static void mmu2_not_responding() {
    */
   void MMU2::tool_change(const uint8_t index) {
 
-    if (!enabled) return;
+    if (!_enabled) return;
 
     set_runout_valid(false);
 
@@ -512,7 +512,7 @@ static void mmu2_not_responding() {
    * Tc Load to nozzle after filament was prepared by Tx and extruder nozzle is already heated.
    */
   void MMU2::tool_change(const char *special) {
-      if (!enabled) return;
+      if (!_enabled) return;
 
       set_runout_valid(false);
 
@@ -561,7 +561,7 @@ static void mmu2_not_responding() {
    * Handle tool change
    */
   void MMU2::tool_change(const uint8_t index) {
-    if (!enabled) return;
+    if (!_enabled) return;
 
     set_runout_valid(false);
 
@@ -599,7 +599,7 @@ static void mmu2_not_responding() {
    * Tc Load to nozzle after filament was prepared by Tx and extruder nozzle is already heated.
    */
   void MMU2::tool_change(const char *special) {
-    if (!enabled) return;
+    if (!_enabled) return;
 
     set_runout_valid(false);
 
@@ -665,7 +665,7 @@ static void mmu2_not_responding() {
    * Handle tool change
    */
   void MMU2::tool_change(const uint8_t index) {
-    if (!enabled) return;
+    if (!_enabled) return;
 
     set_runout_valid(false);
 
@@ -693,7 +693,7 @@ static void mmu2_not_responding() {
    * Tc Load to nozzle after filament was prepared by Tx and extruder nozzle is already heated.
    */
   void MMU2::tool_change(const char *special) {
-    if (!enabled) return;
+    if (!_enabled) return;
 
     set_runout_valid(false);
 
@@ -744,7 +744,7 @@ static void mmu2_not_responding() {
  * Set next command
  */
 void MMU2::command(const uint8_t mmu_cmd) {
-  if (!enabled) return;
+  if (!_enabled) return;
   cmd = mmu_cmd;
   ready = false;
 }
@@ -833,7 +833,7 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
 }
 
 void MMU2::set_filament_type(const uint8_t index, const uint8_t filamentType) {
-  if (!enabled) return;
+  if (!_enabled) return;
 
   cmd_arg = filamentType;
   command(MMU_CMD_F0 + index);
@@ -892,7 +892,7 @@ void MMU2::filament_runout() {
 
 // Load filament into MMU2
 void MMU2::load_filament(const uint8_t index) {
-  if (!enabled) return;
+  if (!_enabled) return;
 
   command(MMU_CMD_L0 + index);
   manage_response(false, false);
@@ -904,7 +904,7 @@ void MMU2::load_filament(const uint8_t index) {
  */
 bool MMU2::load_filament_to_nozzle(const uint8_t index) {
 
-  if (!enabled) return false;
+  if (!_enabled) return false;
 
   if (thermalManager.tooColdToExtrude(active_extruder)) {
     BUZZ(200, 404);
@@ -940,7 +940,7 @@ void MMU2::load_to_nozzle() {
 
 bool MMU2::eject_filament(const uint8_t index, const bool recover) {
 
-  if (!enabled) return false;
+  if (!_enabled) return false;
 
   if (thermalManager.tooColdToExtrude(active_extruder)) {
     BUZZ(200, 404);
@@ -989,7 +989,7 @@ bool MMU2::eject_filament(const uint8_t index, const bool recover) {
  */
 bool MMU2::unload() {
 
-  if (!enabled) return false;
+  if (!_enabled) return false;
 
   if (thermalManager.tooColdToExtrude(active_extruder)) {
     BUZZ(200, 404);

commit fff5e9ba4a45bbb9c4c99da9b2c5998548f925a7
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun May 9 22:58:36 2021 +0200

    Fix insane mmu2 timeout (#21855)
    
    * Fix insane mmu2 timeout
    
    Fix insane timeout value. Now match original Prusa firmware.
    
    * Update mmu2.cpp
    
    Co-authored-by: Luu Lac <45380455+shitcreek@users.noreply.github.com>

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index c1c34f8eee..8a4f5ae071 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -159,7 +159,7 @@ void MMU2::mmu_loop() {
         MMU2_COMMAND("S1");   // Read Version
         state = -2;
       }
-      else if (millis() > 3000000) {
+      else if (millis() > 30000) { // 30sec after reset disable MMU
         SERIAL_ECHOLNPGM("MMU not responding - DISABLED");
         state = 0;
       }

commit 3b73b115ca9366f0155986b717d4c85c31ed2f80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 29 20:36:37 2021 -0500

    Apply pointer formatting

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index d4238400c7..c1c34f8eee 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -362,7 +362,7 @@ bool MMU2::rx_start() {
 /**
  * Check if the data received ends with the given string.
  */
-bool MMU2::rx_str_P(const char* str) {
+bool MMU2::rx_str_P(const char *str) {
   uint8_t i = strlen(rx_buffer);
 
   while (MMU2_SERIAL.available()) {
@@ -394,7 +394,7 @@ bool MMU2::rx_str_P(const char* str) {
 /**
  * Transfer data to MMU, no argument
  */
-void MMU2::tx_str_P(const char* str) {
+void MMU2::tx_str_P(const char *str) {
   clear_rx_buffer();
   uint8_t len = strlen_P(str);
   LOOP_L_N(i, len) MMU2_SERIAL.write(pgm_read_byte(str++));
@@ -404,7 +404,7 @@ void MMU2::tx_str_P(const char* str) {
 /**
  * Transfer data to MMU, single argument
  */
-void MMU2::tx_printf_P(const char* format, int argument = -1) {
+void MMU2::tx_printf_P(const char *format, int argument = -1) {
   clear_rx_buffer();
   uint8_t len = sprintf_P(tx_buffer, format, argument);
   LOOP_L_N(i, len) MMU2_SERIAL.write(tx_buffer[i]);
@@ -414,7 +414,7 @@ void MMU2::tx_printf_P(const char* format, int argument = -1) {
 /**
  * Transfer data to MMU, two arguments
  */
-void MMU2::tx_printf_P(const char* format, int argument1, int argument2) {
+void MMU2::tx_printf_P(const char *format, int argument1, int argument2) {
   clear_rx_buffer();
   uint8_t len = sprintf_P(tx_buffer, format, argument1, argument2);
   LOOP_L_N(i, len) MMU2_SERIAL.write(tx_buffer[i]);
@@ -511,7 +511,7 @@ static void mmu2_not_responding() {
    * Tx Same as T?, except nozzle doesn't have to be preheated. Tc must be placed after extruder nozzle is preheated to finish filament load.
    * Tc Load to nozzle after filament was prepared by Tx and extruder nozzle is already heated.
    */
-  void MMU2::tool_change(const char* special) {
+  void MMU2::tool_change(const char *special) {
       if (!enabled) return;
 
       set_runout_valid(false);
@@ -598,7 +598,7 @@ static void mmu2_not_responding() {
    * Tx Same as T?, except nozzle doesn't have to be preheated. Tc must be placed after extruder nozzle is preheated to finish filament load.
    * Tc Load to nozzle after filament was prepared by Tx and extruder nozzle is already heated.
    */
-  void MMU2::tool_change(const char* special) {
+  void MMU2::tool_change(const char *special) {
     if (!enabled) return;
 
     set_runout_valid(false);
@@ -692,7 +692,7 @@ static void mmu2_not_responding() {
    * Tx Same as T?, except nozzle doesn't have to be preheated. Tc must be placed after extruder nozzle is preheated to finish filament load.
    * Tc Load to nozzle after filament was prepared by Tx and extruder nozzle is already heated.
    */
-  void MMU2::tool_change(const char* special) {
+  void MMU2::tool_change(const char *special) {
     if (!enabled) return;
 
     set_runout_valid(false);

commit e5ff55a1be7646b6159e6dedac50bfbe57e6dfa0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 24 04:11:43 2021 -0500

    Add typedef celsius_t (#21374)

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index a1bec36e45..d4238400c7 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -775,7 +775,7 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
   bool response = false;
   mmu_print_saved = false;
   xyz_pos_t resume_position;
-  int16_t resume_hotend_temp = thermalManager.degTargetHotend(active_extruder);
+  celsius_t resume_hotend_temp = thermalManager.degTargetHotend(active_extruder);
 
   KEEPALIVE_STATE(PAUSED_FOR_USER);
 

commit 4f840c211c02f4ccf4cb50ebe7a0371a9fcdc55b
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sat Feb 27 20:23:00 2021 +0100

    [SMUFF] Use EXTRUDERS for extended commands (#21212)

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 7c3ab05851..a1bec36e45 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -62,29 +62,13 @@ MMU2 mmu2;
 #endif
 
 #define MMU_CMD_NONE 0
-#define MMU_CMD_T0   0x10
-#define MMU_CMD_T1   0x11
-#define MMU_CMD_T2   0x12
-#define MMU_CMD_T3   0x13
-#define MMU_CMD_T4   0x14
-#define MMU_CMD_L0   0x20
-#define MMU_CMD_L1   0x21
-#define MMU_CMD_L2   0x22
-#define MMU_CMD_L3   0x23
-#define MMU_CMD_L4   0x24
+#define MMU_CMD_T0   0x10  // up to supported filaments
+#define MMU_CMD_L0   0x20  // up to supported filaments
 #define MMU_CMD_C0   0x30
 #define MMU_CMD_U0   0x40
-#define MMU_CMD_E0   0x50
-#define MMU_CMD_E1   0x51
-#define MMU_CMD_E2   0x52
-#define MMU_CMD_E3   0x53
-#define MMU_CMD_E4   0x54
+#define MMU_CMD_E0   0x50  // up to supported filaments
 #define MMU_CMD_R0   0x60
-#define MMU_CMD_F0   0x70
-#define MMU_CMD_F1   0x71
-#define MMU_CMD_F2   0x72
-#define MMU_CMD_F3   0x73
-#define MMU_CMD_F4   0x74
+#define MMU_CMD_F0   0x70  // up to supported filaments
 
 #define MMU_REQUIRED_FW_BUILDNR TERN(MMU2_MODE_12V, 132, 126)
 
@@ -243,7 +227,7 @@ void MMU2::mmu_loop() {
 
     case 1:
       if (cmd) {
-        if (WITHIN(cmd, MMU_CMD_T0, MMU_CMD_T4)) {
+        if (WITHIN(cmd, MMU_CMD_T0, MMU_CMD_T0 + EXTRUDERS - 1)) {
           // tool change
           int filament = cmd - MMU_CMD_T0;
           DEBUG_ECHOLNPAIR("MMU <= T", filament);
@@ -251,7 +235,7 @@ void MMU2::mmu_loop() {
           TERN_(MMU_EXTRUDER_SENSOR, mmu_idl_sens = 1); // enable idler sensor, if any
           state = 3; // wait for response
         }
-        else if (WITHIN(cmd, MMU_CMD_L0, MMU_CMD_L4)) {
+        else if (WITHIN(cmd, MMU_CMD_L0, MMU_CMD_L0 + EXTRUDERS - 1)) {
           // load
           int filament = cmd - MMU_CMD_L0;
           DEBUG_ECHOLNPAIR("MMU <= L", filament);
@@ -271,7 +255,7 @@ void MMU2::mmu_loop() {
           MMU2_COMMAND("U0");
           state = 3; // wait for response
         }
-        else if (WITHIN(cmd, MMU_CMD_E0, MMU_CMD_E4)) {
+        else if (WITHIN(cmd, MMU_CMD_E0, MMU_CMD_E0 + EXTRUDERS - 1)) {
           // eject filament
           int filament = cmd - MMU_CMD_E0;
           DEBUG_ECHOLNPAIR("MMU <= E", filament);
@@ -284,7 +268,7 @@ void MMU2::mmu_loop() {
           MMU2_COMMAND("R0");
           state = 3; // wait for response
         }
-        else if (WITHIN(cmd, MMU_CMD_F0, MMU_CMD_F4)) {
+        else if (WITHIN(cmd, MMU_CMD_F0, MMU_CMD_F0 + EXTRUDERS - 1)) {
           // filament type
           int filament = cmd - MMU_CMD_F0;
           DEBUG_ECHOLNPAIR("MMU <= F", filament, " ", cmd_arg);

commit 9e0fc442105b6d23827bd767a811552a1804e9ed
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Mon Feb 15 11:45:38 2021 +0100

    Fix MMU2 compile error (#21065)

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 1aa53ef5eb..7c3ab05851 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -287,9 +287,7 @@ void MMU2::mmu_loop() {
         else if (WITHIN(cmd, MMU_CMD_F0, MMU_CMD_F4)) {
           // filament type
           int filament = cmd - MMU_CMD_F0;
-          DEBUG_ECHOPAIR("MMU <= F", filament, " ");
-          DEBUG_ECHO_F(cmd_arg, DEC);
-          DEBUG_EOL();
+          DEBUG_ECHOLNPAIR("MMU <= F", filament, " ", cmd_arg);
           tx_printf_P(PSTR("F%d %d\n"), filament, cmd_arg);
           state = 3; // wait for response
         }

commit e7c711996bd3080f5e343eff5556736cbf2e2416
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 8 07:37:24 2021 +0100

    Serial refactor. Default 8-bit ECHO to int, not char (#20985)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 3bff73e956..1aa53ef5eb 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -514,7 +514,7 @@ static void mmu2_not_responding() {
         extruder = index; // filament change is finished
         active_extruder = 0;
         ENABLE_AXIS_E0();
-        SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, int(extruder));
+        SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, extruder);
       }
       ui.reset_status();
     }
@@ -601,7 +601,7 @@ static void mmu2_not_responding() {
       active_extruder = 0;
 
       ENABLE_AXIS_E0();
-      SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, int(extruder));
+      SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, extruder);
 
       ui.reset_status();
     }
@@ -696,7 +696,7 @@ static void mmu2_not_responding() {
       extruder = index; //filament change is finished
       active_extruder = 0;
       ENABLE_AXIS_E0();
-      SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, int(extruder));
+      SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, extruder);
       ui.reset_status();
     }
 

commit 708ea3d0bb82f067424c75636c28a549aa3d3b06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 4 23:22:42 2021 -0600

    Use serial shorthand

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index e3036947d5..3bff73e956 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -514,8 +514,7 @@ static void mmu2_not_responding() {
         extruder = index; // filament change is finished
         active_extruder = 0;
         ENABLE_AXIS_E0();
-        SERIAL_ECHO_START();
-        SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(extruder));
+        SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, int(extruder));
       }
       ui.reset_status();
     }
@@ -602,8 +601,7 @@ static void mmu2_not_responding() {
       active_extruder = 0;
 
       ENABLE_AXIS_E0();
-      SERIAL_ECHO_START();
-      SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(extruder));
+      SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, int(extruder));
 
       ui.reset_status();
     }
@@ -698,8 +696,7 @@ static void mmu2_not_responding() {
       extruder = index; //filament change is finished
       active_extruder = 0;
       ENABLE_AXIS_E0();
-      SERIAL_ECHO_START();
-      SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(extruder));
+      SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, int(extruder));
       ui.reset_status();
     }
 

commit 876c2586b9146dd123af4c7b21138b8239ef5d39
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Mon Jan 25 15:58:52 2021 +0100

    Clean up MMU2 code (#20794)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index a4b7f257a9..e3036947d5 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -167,6 +167,8 @@ void MMU2::mmu_loop() {
 
     case -1:
       if (rx_start()) {
+        prev_P0_request = millis();   // Initialize finda sensor timeout
+
         DEBUG_ECHOLNPGM("MMU => 'start'");
         DEBUG_ECHOLNPGM("MMU <= 'S1'");
 
@@ -311,7 +313,7 @@ void MMU2::mmu_loop() {
         // if (finda_runout_valid) DEBUG_ECHOLNPAIR_F("MMU <= 'P0'\nMMU => ", finda, 6);
 
         if (!finda && finda_runout_valid) filament_runout();
-        if (cmd == 0) ready = true;
+        if (cmd == MMU_CMD_NONE) ready = true;
         state = 1;
       }
       else if (ELAPSED(millis(), prev_request + MMU_P0_TIMEOUT)) // Resend request after timeout (3s)
@@ -333,18 +335,20 @@ void MMU2::mmu_loop() {
       #endif
 
       if (rx_ok()) {
-        // Response to C0 mmu command in MMU2S model
-        bool can_reset = true;
         #if HAS_PRUSA_MMU2S
-          if (!mmu2s_triggered && last_cmd == MMU_CMD_C0) {
-            can_reset = false;
+          // Respond to C0 MMU command in MMU2S model
+          const bool keep_trying = !mmu2s_triggered && last_cmd == MMU_CMD_C0;
+          if (keep_trying) {
             // MMU ok received but filament sensor not triggered, retrying...
             DEBUG_ECHOLNPGM("MMU => 'ok' (filament not present in gears)");
             DEBUG_ECHOLNPGM("MMU <= 'C0' (keep trying)");
             MMU2_COMMAND("C0");
           }
+        #else
+          constexpr bool keep_trying = false;
         #endif
-        if (can_reset) {
+
+        if (!keep_trying) {
           DEBUG_ECHOLNPGM("MMU => 'ok'");
           ready = true;
           state = 1;
@@ -370,11 +374,7 @@ void MMU2::mmu_loop() {
  */
 bool MMU2::rx_start() {
   // check for start message
-  if (rx_str_P(PSTR("start\n"))) {
-    prev_P0_request = millis();
-    return true;
-  }
-  return false;
+  return rx_str_P(PSTR("start\n"));
 }
 
 /**
@@ -385,13 +385,13 @@ bool MMU2::rx_str_P(const char* str) {
 
   while (MMU2_SERIAL.available()) {
     rx_buffer[i++] = MMU2_SERIAL.read();
-    rx_buffer[i] = '\0';
 
     if (i == sizeof(rx_buffer) - 1) {
       DEBUG_ECHOLNPGM("rx buffer overrun");
       break;
     }
   }
+  rx_buffer[i] = '\0';
 
   uint8_t len = strlen_P(str);
 
@@ -416,7 +416,6 @@ void MMU2::tx_str_P(const char* str) {
   clear_rx_buffer();
   uint8_t len = strlen_P(str);
   LOOP_L_N(i, len) MMU2_SERIAL.write(pgm_read_byte(str++));
-  rx_buffer[0] = '\0';
   prev_request = millis();
 }
 
@@ -427,7 +426,6 @@ void MMU2::tx_printf_P(const char* format, int argument = -1) {
   clear_rx_buffer();
   uint8_t len = sprintf_P(tx_buffer, format, argument);
   LOOP_L_N(i, len) MMU2_SERIAL.write(tx_buffer[i]);
-  rx_buffer[0] = '\0';
   prev_request = millis();
 }
 
@@ -438,7 +436,6 @@ void MMU2::tx_printf_P(const char* format, int argument1, int argument2) {
   clear_rx_buffer();
   uint8_t len = sprintf_P(tx_buffer, format, argument1, argument2);
   LOOP_L_N(i, len) MMU2_SERIAL.write(tx_buffer[i]);
-  rx_buffer[0] = '\0';
   prev_request = millis();
 }
 
@@ -570,7 +567,7 @@ static void mmu2_not_responding() {
 
         case 'c': {
           while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
-          execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
+          load_to_nozzle();
         } break;
       }
 
@@ -791,7 +788,7 @@ bool MMU2::get_response() {
 }
 
 /**
- * Wait for response and deal with timeout if nexcessary
+ * Wait for response and deal with timeout if necessary
  */
 void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
 
@@ -917,6 +914,7 @@ void MMU2::filament_runout() {
 // Load filament into MMU2
 void MMU2::load_filament(const uint8_t index) {
   if (!enabled) return;
+
   command(MMU_CMD_L0 + index);
   manage_response(false, false);
   BUZZ(200, 404);
@@ -935,6 +933,7 @@ bool MMU2::load_filament_to_nozzle(const uint8_t index) {
     return false;
   }
 
+  DISABLE_AXIS_E0();
   command(MMU_CMD_T0 + index);
   manage_response(true, true);
 
@@ -957,7 +956,6 @@ bool MMU2::load_filament_to_nozzle(const uint8_t index) {
  * filament to nozzle.
  */
 void MMU2::load_to_nozzle() {
-  if (!enabled) return;
   execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
 }
 
@@ -1020,7 +1018,8 @@ bool MMU2::unload() {
     return false;
   }
 
-  filament_ramming();
+  // Unload sequence to optimize shape of the tip of the unloaded filament
+  execute_extruder_sequence((const E_Step *)ramming_sequence, sizeof(ramming_sequence) / sizeof(E_Step));
 
   command(MMU_CMD_U0);
   manage_response(false, true);
@@ -1035,13 +1034,6 @@ bool MMU2::unload() {
   return true;
 }
 
-/**
- * Unload sequence to optimize shape of the tip of the unloaded filament
- */
-void MMU2::filament_ramming() {
-  execute_extruder_sequence((const E_Step *)ramming_sequence, sizeof(ramming_sequence) / sizeof(E_Step));
-}
-
 void MMU2::execute_extruder_sequence(const E_Step * sequence, int steps) {
 
   planner.synchronize();

commit 1d5862a39b07f0a59039109c4121ef504ee2b2c3
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sat Jan 16 03:38:34 2021 +0100

    MMU2 as standard serial device (#20771)

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 9e93f95086..a4b7f257a9 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -91,8 +91,6 @@ MMU2 mmu2;
 #define MMU2_NO_TOOL 99
 #define MMU_BAUD    115200
 
-#define mmuSerial   MMU2_SERIAL
-
 bool MMU2::enabled, MMU2::ready, MMU2::mmu_print_saved;
 #if HAS_PRUSA_MMU2S
   bool MMU2::mmu2s_triggered;
@@ -132,7 +130,7 @@ void MMU2::init() {
     SET_OUTPUT(MMU2_RST_PIN);
   #endif
 
-  mmuSerial.begin(MMU_BAUD);
+  MMU2_SERIAL.begin(MMU_BAUD);
   extruder = MMU2_NO_TOOL;
 
   safe_delay(10);
@@ -385,8 +383,8 @@ bool MMU2::rx_start() {
 bool MMU2::rx_str_P(const char* str) {
   uint8_t i = strlen(rx_buffer);
 
-  while (mmuSerial.available()) {
-    rx_buffer[i++] = mmuSerial.read();
+  while (MMU2_SERIAL.available()) {
+    rx_buffer[i++] = MMU2_SERIAL.read();
     rx_buffer[i] = '\0';
 
     if (i == sizeof(rx_buffer) - 1) {
@@ -417,7 +415,7 @@ bool MMU2::rx_str_P(const char* str) {
 void MMU2::tx_str_P(const char* str) {
   clear_rx_buffer();
   uint8_t len = strlen_P(str);
-  LOOP_L_N(i, len) mmuSerial.write(pgm_read_byte(str++));
+  LOOP_L_N(i, len) MMU2_SERIAL.write(pgm_read_byte(str++));
   rx_buffer[0] = '\0';
   prev_request = millis();
 }
@@ -428,7 +426,7 @@ void MMU2::tx_str_P(const char* str) {
 void MMU2::tx_printf_P(const char* format, int argument = -1) {
   clear_rx_buffer();
   uint8_t len = sprintf_P(tx_buffer, format, argument);
-  LOOP_L_N(i, len) mmuSerial.write(tx_buffer[i]);
+  LOOP_L_N(i, len) MMU2_SERIAL.write(tx_buffer[i]);
   rx_buffer[0] = '\0';
   prev_request = millis();
 }
@@ -439,7 +437,7 @@ void MMU2::tx_printf_P(const char* format, int argument = -1) {
 void MMU2::tx_printf_P(const char* format, int argument1, int argument2) {
   clear_rx_buffer();
   uint8_t len = sprintf_P(tx_buffer, format, argument1, argument2);
-  LOOP_L_N(i, len) mmuSerial.write(tx_buffer[i]);
+  LOOP_L_N(i, len) MMU2_SERIAL.write(tx_buffer[i]);
   rx_buffer[0] = '\0';
   prev_request = millis();
 }
@@ -448,7 +446,7 @@ void MMU2::tx_printf_P(const char* format, int argument1, int argument2) {
  * Empty the rx buffer
  */
 void MMU2::clear_rx_buffer() {
-  while (mmuSerial.available()) mmuSerial.read();
+  while (MMU2_SERIAL.available()) MMU2_SERIAL.read();
   rx_buffer[0] = '\0';
 }
 

commit 2b928b475419be018d9ba990f28d9cd5aecb69d0
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Wed Jan 13 02:38:51 2021 +0100

    Fix comments (#20759)

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
index 61adcfca72..9e93f95086 100644
--- a/Marlin/src/feature/mmu/mmu2.cpp
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -128,7 +128,6 @@ void MMU2::init() {
   set_runout_valid(false);
 
   #if PIN_EXISTS(MMU2_RST)
-    // TODO use macros for this
     WRITE(MMU2_RST_PIN, HIGH);
     SET_OUTPUT(MMU2_RST_PIN);
   #endif
@@ -955,7 +954,7 @@ bool MMU2::load_filament_to_nozzle(const uint8_t index) {
 /**
  * Load filament to nozzle of multimaterial printer
  *
- * This function is used only only after T? (user select filament) and M600 (change filament).
+ * This function is used only after T? (user select filament) and M600 (change filament).
  * It is not used after T0 .. T4 command (select filament), in such case, gcode is responsible for loading
  * filament to nozzle.
  */

commit 41529b65988a58ba512977e0fe1692aaeeb6c811
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Wed Nov 18 08:27:21 2020 +0100

    SMUFF (MMU2 clone) support (#19912)

diff --git a/Marlin/src/feature/mmu/mmu2.cpp b/Marlin/src/feature/mmu/mmu2.cpp
new file mode 100644
index 0000000000..61adcfca72
--- /dev/null
+++ b/Marlin/src/feature/mmu/mmu2.cpp
@@ -0,0 +1,1072 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfig.h"
+
+#if HAS_PRUSA_MMU2
+
+#include "mmu2.h"
+#include "../../lcd/menu/menu_mmu2.h"
+
+MMU2 mmu2;
+
+#include "../../gcode/gcode.h"
+#include "../../lcd/marlinui.h"
+#include "../../libs/buzzer.h"
+#include "../../libs/nozzle.h"
+#include "../../module/temperature.h"
+#include "../../module/planner.h"
+#include "../../module/stepper/indirection.h"
+#include "../../MarlinCore.h"
+
+#if ENABLED(HOST_PROMPT_SUPPORT)
+  #include "../../feature/host_actions.h"
+#endif
+
+#if ENABLED(EXTENSIBLE_UI)
+  #include "../../lcd/extui/ui_api.h"
+#endif
+
+#define DEBUG_OUT ENABLED(MMU2_DEBUG)
+#include "../../core/debug_out.h"
+
+#define MMU_TODELAY 100
+#define MMU_TIMEOUT 10
+#define MMU_CMD_TIMEOUT 45000UL // 45s timeout for mmu commands (except P0)
+#define MMU_P0_TIMEOUT 3000UL   // Timeout for P0 command: 3seconds
+
+#define MMU2_COMMAND(S) tx_str_P(PSTR(S "\n"))
+
+#if ENABLED(MMU_EXTRUDER_SENSOR)
+  uint8_t mmu_idl_sens = 0;
+  static bool mmu_loading_flag = false;
+#endif
+
+#define MMU_CMD_NONE 0
+#define MMU_CMD_T0   0x10
+#define MMU_CMD_T1   0x11
+#define MMU_CMD_T2   0x12
+#define MMU_CMD_T3   0x13
+#define MMU_CMD_T4   0x14
+#define MMU_CMD_L0   0x20
+#define MMU_CMD_L1   0x21
+#define MMU_CMD_L2   0x22
+#define MMU_CMD_L3   0x23
+#define MMU_CMD_L4   0x24
+#define MMU_CMD_C0   0x30
+#define MMU_CMD_U0   0x40
+#define MMU_CMD_E0   0x50
+#define MMU_CMD_E1   0x51
+#define MMU_CMD_E2   0x52
+#define MMU_CMD_E3   0x53
+#define MMU_CMD_E4   0x54
+#define MMU_CMD_R0   0x60
+#define MMU_CMD_F0   0x70
+#define MMU_CMD_F1   0x71
+#define MMU_CMD_F2   0x72
+#define MMU_CMD_F3   0x73
+#define MMU_CMD_F4   0x74
+
+#define MMU_REQUIRED_FW_BUILDNR TERN(MMU2_MODE_12V, 132, 126)
+
+#define MMU2_NO_TOOL 99
+#define MMU_BAUD    115200
+
+#define mmuSerial   MMU2_SERIAL
+
+bool MMU2::enabled, MMU2::ready, MMU2::mmu_print_saved;
+#if HAS_PRUSA_MMU2S
+  bool MMU2::mmu2s_triggered;
+#endif
+uint8_t MMU2::cmd, MMU2::cmd_arg, MMU2::last_cmd, MMU2::extruder;
+int8_t MMU2::state = 0;
+volatile int8_t MMU2::finda = 1;
+volatile bool MMU2::finda_runout_valid;
+int16_t MMU2::version = -1, MMU2::buildnr = -1;
+millis_t MMU2::prev_request, MMU2::prev_P0_request;
+char MMU2::rx_buffer[MMU_RX_SIZE], MMU2::tx_buffer[MMU_TX_SIZE];
+
+struct E_Step {
+  float extrude;        //!< extrude distance in mm
+  feedRate_t feedRate;  //!< feed rate in mm/s
+};
+
+static constexpr E_Step
+    ramming_sequence[] PROGMEM = { MMU2_RAMMING_SEQUENCE }
+  , load_to_nozzle_sequence[] PROGMEM = { MMU2_LOAD_TO_NOZZLE_SEQUENCE }
+  #if HAS_PRUSA_MMU2S
+    , can_load_sequence[] PROGMEM = { MMU2_CAN_LOAD_SEQUENCE }
+    , can_load_increment_sequence[] PROGMEM = { MMU2_CAN_LOAD_INCREMENT_SEQUENCE }
+  #endif
+;
+
+MMU2::MMU2() {
+  rx_buffer[0] = '\0';
+}
+
+void MMU2::init() {
+
+  set_runout_valid(false);
+
+  #if PIN_EXISTS(MMU2_RST)
+    // TODO use macros for this
+    WRITE(MMU2_RST_PIN, HIGH);
+    SET_OUTPUT(MMU2_RST_PIN);
+  #endif
+
+  mmuSerial.begin(MMU_BAUD);
+  extruder = MMU2_NO_TOOL;
+
+  safe_delay(10);
+  reset();
+  rx_buffer[0] = '\0';
+  state = -1;
+}
+
+void MMU2::reset() {
+  DEBUG_ECHOLNPGM("MMU <= reset");
+
+  #if PIN_EXISTS(MMU2_RST)
+    WRITE(MMU2_RST_PIN, LOW);
+    safe_delay(20);
+    WRITE(MMU2_RST_PIN, HIGH);
+  #else
+    MMU2_COMMAND("X0"); // Send soft reset
+  #endif
+}
+
+uint8_t MMU2::get_current_tool() {
+  return extruder == MMU2_NO_TOOL ? -1 : extruder;
+}
+
+#if EITHER(HAS_PRUSA_MMU2S, MMU_EXTRUDER_SENSOR)
+  #define FILAMENT_PRESENT() (READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE)
+#endif
+
+void MMU2::mmu_loop() {
+
+  switch (state) {
+
+    case 0: break;
+
+    case -1:
+      if (rx_start()) {
+        DEBUG_ECHOLNPGM("MMU => 'start'");
+        DEBUG_ECHOLNPGM("MMU <= 'S1'");
+
+        MMU2_COMMAND("S1");   // Read Version
+        state = -2;
+      }
+      else if (millis() > 3000000) {
+        SERIAL_ECHOLNPGM("MMU not responding - DISABLED");
+        state = 0;
+      }
+      break;
+
+    case -2:
+      if (rx_ok()) {
+        sscanf(rx_buffer, "%huok\n", &version);
+
+        DEBUG_ECHOLNPAIR("MMU => ", version, "\nMMU <= 'S2'");
+
+        MMU2_COMMAND("S2");   // Read Build Number
+        state = -3;
+      }
+      break;
+
+    case -3:
+      if (rx_ok()) {
+        sscanf(rx_buffer, "%huok\n", &buildnr);
+
+        DEBUG_ECHOLNPAIR("MMU => ", buildnr);
+
+        check_version();
+
+        #if ENABLED(MMU2_MODE_12V)
+          DEBUG_ECHOLNPGM("MMU <= 'M1'");
+
+          MMU2_COMMAND("M1");   // Stealth Mode
+          state = -5;
+
+        #else
+          DEBUG_ECHOLNPGM("MMU <= 'P0'");
+
+          MMU2_COMMAND("P0");   // Read FINDA
+          state = -4;
+        #endif
+      }
+      break;
+
+    #if ENABLED(MMU2_MODE_12V)
+    case -5:
+      // response to M1
+      if (rx_ok()) {
+        DEBUG_ECHOLNPGM("MMU => ok");
+
+        DEBUG_ECHOLNPGM("MMU <= 'P0'");
+
+        MMU2_COMMAND("P0");   // Read FINDA
+        state = -4;
+      }
+      break;
+    #endif
+
+    case -4:
+      if (rx_ok()) {
+        sscanf(rx_buffer, "%hhuok\n", &finda);
+
+        DEBUG_ECHOLNPAIR("MMU => ", finda, "\nMMU - ENABLED");
+
+        enabled = true;
+        state = 1;
+        TERN_(HAS_PRUSA_MMU2S, mmu2s_triggered = false);
+      }
+      break;
+
+    case 1:
+      if (cmd) {
+        if (WITHIN(cmd, MMU_CMD_T0, MMU_CMD_T4)) {
+          // tool change
+          int filament = cmd - MMU_CMD_T0;
+          DEBUG_ECHOLNPAIR("MMU <= T", filament);
+          tx_printf_P(PSTR("T%d\n"), filament);
+          TERN_(MMU_EXTRUDER_SENSOR, mmu_idl_sens = 1); // enable idler sensor, if any
+          state = 3; // wait for response
+        }
+        else if (WITHIN(cmd, MMU_CMD_L0, MMU_CMD_L4)) {
+          // load
+          int filament = cmd - MMU_CMD_L0;
+          DEBUG_ECHOLNPAIR("MMU <= L", filament);
+          tx_printf_P(PSTR("L%d\n"), filament);
+          state = 3; // wait for response
+        }
+        else if (cmd == MMU_CMD_C0) {
+          // continue loading
+          DEBUG_ECHOLNPGM("MMU <= 'C0'");
+          MMU2_COMMAND("C0");
+          state = 3; // wait for response
+        }
+        else if (cmd == MMU_CMD_U0) {
+          // unload current
+          DEBUG_ECHOLNPGM("MMU <= 'U0'");
+
+          MMU2_COMMAND("U0");
+          state = 3; // wait for response
+        }
+        else if (WITHIN(cmd, MMU_CMD_E0, MMU_CMD_E4)) {
+          // eject filament
+          int filament = cmd - MMU_CMD_E0;
+          DEBUG_ECHOLNPAIR("MMU <= E", filament);
+          tx_printf_P(PSTR("E%d\n"), filament);
+          state = 3; // wait for response
+        }
+        else if (cmd == MMU_CMD_R0) {
+          // recover after eject
+          DEBUG_ECHOLNPGM("MMU <= 'R0'");
+          MMU2_COMMAND("R0");
+          state = 3; // wait for response
+        }
+        else if (WITHIN(cmd, MMU_CMD_F0, MMU_CMD_F4)) {
+          // filament type
+          int filament = cmd - MMU_CMD_F0;
+          DEBUG_ECHOPAIR("MMU <= F", filament, " ");
+          DEBUG_ECHO_F(cmd_arg, DEC);
+          DEBUG_EOL();
+          tx_printf_P(PSTR("F%d %d\n"), filament, cmd_arg);
+          state = 3; // wait for response
+        }
+
+        last_cmd = cmd;
+        cmd = MMU_CMD_NONE;
+      }
+      else if (ELAPSED(millis(), prev_P0_request + 300)) {
+        MMU2_COMMAND("P0"); // Read FINDA
+        state = 2; // wait for response
+      }
+
+      TERN_(HAS_PRUSA_MMU2S, check_filament());
+      break;
+
+    case 2:   // response to command P0
+      if (rx_ok()) {
+        sscanf(rx_buffer, "%hhuok\n", &finda);
+
+        // This is super annoying. Only activate if necessary
+        // if (finda_runout_valid) DEBUG_ECHOLNPAIR_F("MMU <= 'P0'\nMMU => ", finda, 6);
+
+        if (!finda && finda_runout_valid) filament_runout();
+        if (cmd == 0) ready = true;
+        state = 1;
+      }
+      else if (ELAPSED(millis(), prev_request + MMU_P0_TIMEOUT)) // Resend request after timeout (3s)
+        state = 1;
+
+      TERN_(HAS_PRUSA_MMU2S, check_filament());
+      break;
+
+    case 3:   // response to mmu commands
+      #if ENABLED(MMU_EXTRUDER_SENSOR)
+        if (mmu_idl_sens) {
+          if (FILAMENT_PRESENT() && mmu_loading_flag) {
+            DEBUG_ECHOLNPGM("MMU <= 'A'");
+            MMU2_COMMAND("A"); // send 'abort' request
+            mmu_idl_sens = 0;
+            DEBUG_ECHOLNPGM("MMU IDLER_SENSOR = 0 - ABORT");
+          }
+        }
+      #endif
+
+      if (rx_ok()) {
+        // Response to C0 mmu command in MMU2S model
+        bool can_reset = true;
+        #if HAS_PRUSA_MMU2S
+          if (!mmu2s_triggered && last_cmd == MMU_CMD_C0) {
+            can_reset = false;
+            // MMU ok received but filament sensor not triggered, retrying...
+            DEBUG_ECHOLNPGM("MMU => 'ok' (filament not present in gears)");
+            DEBUG_ECHOLNPGM("MMU <= 'C0' (keep trying)");
+            MMU2_COMMAND("C0");
+          }
+        #endif
+        if (can_reset) {
+          DEBUG_ECHOLNPGM("MMU => 'ok'");
+          ready = true;
+          state = 1;
+          last_cmd = MMU_CMD_NONE;
+        }
+      }
+      else if (ELAPSED(millis(), prev_request + MMU_CMD_TIMEOUT)) {
+        // resend request after timeout
+        if (last_cmd) {
+          DEBUG_ECHOLNPGM("MMU retry");
+          cmd = last_cmd;
+          last_cmd = MMU_CMD_NONE;
+        }
+        state = 1;
+      }
+      TERN_(HAS_PRUSA_MMU2S, check_filament());
+      break;
+  }
+}
+
+/**
+ * Check if MMU was started
+ */
+bool MMU2::rx_start() {
+  // check for start message
+  if (rx_str_P(PSTR("start\n"))) {
+    prev_P0_request = millis();
+    return true;
+  }
+  return false;
+}
+
+/**
+ * Check if the data received ends with the given string.
+ */
+bool MMU2::rx_str_P(const char* str) {
+  uint8_t i = strlen(rx_buffer);
+
+  while (mmuSerial.available()) {
+    rx_buffer[i++] = mmuSerial.read();
+    rx_buffer[i] = '\0';
+
+    if (i == sizeof(rx_buffer) - 1) {
+      DEBUG_ECHOLNPGM("rx buffer overrun");
+      break;
+    }
+  }
+
+  uint8_t len = strlen_P(str);
+
+  if (i < len) return false;
+
+  str += len;
+
+  while (len--) {
+    char c0 = pgm_read_byte(str--), c1 = rx_buffer[i--];
+    if (c0 == c1) continue;
+    if (c0 == '\r' && c1 == '\n') continue;  // match cr as lf
+    if (c0 == '\n' && c1 == '\r') continue;  // match lf as cr
+    return false;
+  }
+  return true;
+}
+
+/**
+ * Transfer data to MMU, no argument
+ */
+void MMU2::tx_str_P(const char* str) {
+  clear_rx_buffer();
+  uint8_t len = strlen_P(str);
+  LOOP_L_N(i, len) mmuSerial.write(pgm_read_byte(str++));
+  rx_buffer[0] = '\0';
+  prev_request = millis();
+}
+
+/**
+ * Transfer data to MMU, single argument
+ */
+void MMU2::tx_printf_P(const char* format, int argument = -1) {
+  clear_rx_buffer();
+  uint8_t len = sprintf_P(tx_buffer, format, argument);
+  LOOP_L_N(i, len) mmuSerial.write(tx_buffer[i]);
+  rx_buffer[0] = '\0';
+  prev_request = millis();
+}
+
+/**
+ * Transfer data to MMU, two arguments
+ */
+void MMU2::tx_printf_P(const char* format, int argument1, int argument2) {
+  clear_rx_buffer();
+  uint8_t len = sprintf_P(tx_buffer, format, argument1, argument2);
+  LOOP_L_N(i, len) mmuSerial.write(tx_buffer[i]);
+  rx_buffer[0] = '\0';
+  prev_request = millis();
+}
+
+/**
+ * Empty the rx buffer
+ */
+void MMU2::clear_rx_buffer() {
+  while (mmuSerial.available()) mmuSerial.read();
+  rx_buffer[0] = '\0';
+}
+
+/**
+ * Check if we received 'ok' from MMU
+ */
+bool MMU2::rx_ok() {
+  if (rx_str_P(PSTR("ok\n"))) {
+    prev_P0_request = millis();
+    return true;
+  }
+  return false;
+}
+
+/**
+ * Check if MMU has compatible firmware
+ */
+void MMU2::check_version() {
+  if (buildnr < MMU_REQUIRED_FW_BUILDNR) {
+    SERIAL_ERROR_MSG("Invalid MMU2 firmware. Version >= " STRINGIFY(MMU_REQUIRED_FW_BUILDNR) " required.");
+    kill(GET_TEXT(MSG_KILL_MMU2_FIRMWARE));
+  }
+}
+
+static void mmu2_not_responding() {
+  LCD_MESSAGEPGM(MSG_MMU2_NOT_RESPONDING);
+  BUZZ(100, 659);
+  BUZZ(200, 698);
+  BUZZ(100, 659);
+  BUZZ(300, 440);
+  BUZZ(100, 659);
+}
+
+#if HAS_PRUSA_MMU2S
+
+  bool MMU2::load_to_gears() {
+    command(MMU_CMD_C0);
+    manage_response(true, true);
+    LOOP_L_N(i, MMU2_C0_RETRY) {  // Keep loading until filament reaches gears
+      if (mmu2s_triggered) break;
+      command(MMU_CMD_C0);
+      manage_response(true, true);
+      check_filament();
+    }
+    const bool success = mmu2s_triggered && can_load();
+    if (!success) mmu2_not_responding();
+    return success;
+  }
+
+  /**
+   * Handle tool change
+   */
+  void MMU2::tool_change(const uint8_t index) {
+
+    if (!enabled) return;
+
+    set_runout_valid(false);
+
+    if (index != extruder) {
+
+      DISABLE_AXIS_E0();
+      ui.status_printf_P(0, GET_TEXT(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
+
+      command(MMU_CMD_T0 + index);
+      manage_response(true, true);
+
+      if (load_to_gears()) {
+        extruder = index; // filament change is finished
+        active_extruder = 0;
+        ENABLE_AXIS_E0();
+        SERIAL_ECHO_START();
+        SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(extruder));
+      }
+      ui.reset_status();
+    }
+
+    set_runout_valid(true);
+  }
+
+  /**
+   * Handle special T?/Tx/Tc commands
+   *
+   * T? Gcode to extrude shouldn't have to follow, load to extruder wheels is done automatically
+   * Tx Same as T?, except nozzle doesn't have to be preheated. Tc must be placed after extruder nozzle is preheated to finish filament load.
+   * Tc Load to nozzle after filament was prepared by Tx and extruder nozzle is already heated.
+   */
+  void MMU2::tool_change(const char* special) {
+      if (!enabled) return;
+
+      set_runout_valid(false);
+
+      switch (*special) {
+        case '?': {
+          #if ENABLED(MMU2_MENUS)
+            const uint8_t index = mmu2_choose_filament();
+            while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
+            load_filament_to_nozzle(index);
+          #else
+            BUZZ(400, 40);
+          #endif
+        } break;
+
+        case 'x': {
+          #if ENABLED(MMU2_MENUS)
+            planner.synchronize();
+            const uint8_t index = mmu2_choose_filament();
+            DISABLE_AXIS_E0();
+            command(MMU_CMD_T0 + index);
+            manage_response(true, true);
+
+            if (load_to_gears()) {
+              mmu_loop();
+              ENABLE_AXIS_E0();
+              extruder = index;
+              active_extruder = 0;
+            }
+          #else
+            BUZZ(400, 40);
+          #endif
+        } break;
+
+        case 'c': {
+          while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
+          execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
+        } break;
+      }
+
+      set_runout_valid(true);
+  }
+
+#elif ENABLED(MMU_EXTRUDER_SENSOR)
+
+  /**
+   * Handle tool change
+   */
+  void MMU2::tool_change(const uint8_t index) {
+    if (!enabled) return;
+
+    set_runout_valid(false);
+
+    if (index != extruder) {
+      DISABLE_AXIS_E0();
+      if (FILAMENT_PRESENT()) {
+        DEBUG_ECHOLNPGM("Unloading\n");
+        mmu_loading_flag = false;
+        command(MMU_CMD_U0);
+        manage_response(true, true);
+      }
+      ui.status_printf_P(0, GET_TEXT(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
+      mmu_loading_flag = true;
+      command(MMU_CMD_T0 + index);
+      manage_response(true, true);
+      mmu_continue_loading();
+      command(MMU_CMD_C0);
+      extruder = index;
+      active_extruder = 0;
+
+      ENABLE_AXIS_E0();
+      SERIAL_ECHO_START();
+      SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(extruder));
+
+      ui.reset_status();
+    }
+
+    set_runout_valid(true);
+  }
+
+  /**
+   * Handle special T?/Tx/Tc commands
+   *
+   * T? Gcode to extrude shouldn't have to follow, load to extruder wheels is done automatically
+   * Tx Same as T?, except nozzle doesn't have to be preheated. Tc must be placed after extruder nozzle is preheated to finish filament load.
+   * Tc Load to nozzle after filament was prepared by Tx and extruder nozzle is already heated.
+   */
+  void MMU2::tool_change(const char* special) {
+    if (!enabled) return;
+
+    set_runout_valid(false);
+
+    switch (*special) {
+      case '?': {
+        DEBUG_ECHOLNPGM("case ?\n");
+        #if ENABLED(MMU2_MENUS)
+          uint8_t index = mmu2_choose_filament();
+          while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
+          load_filament_to_nozzle(index);
+        #else
+          BUZZ(400, 40);
+        #endif
+      } break;
+
+      case 'x': {
+        DEBUG_ECHOLNPGM("case x\n");
+        #if ENABLED(MMU2_MENUS)
+          planner.synchronize();
+          uint8_t index = mmu2_choose_filament();
+          DISABLE_AXIS_E0();
+          command(MMU_CMD_T0 + index);
+          manage_response(true, true);
+          mmu_continue_loading();
+          command(MMU_CMD_C0);
+          mmu_loop();
+
+          ENABLE_AXIS_E0();
+          extruder = index;
+          active_extruder = 0;
+        #else
+          BUZZ(400, 40);
+        #endif
+      } break;
+
+      case 'c': {
+        DEBUG_ECHOLNPGM("case c\n");
+        while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
+        execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
+      } break;
+    }
+
+    set_runout_valid(true);
+  }
+
+  void MMU2::mmu_continue_loading() {
+    for (uint8_t i = 0; i < MMU_LOADING_ATTEMPTS_NR; i++) {
+      DEBUG_ECHOLNPAIR("Additional load attempt #", i);
+      if (FILAMENT_PRESENT()) break;
+      command(MMU_CMD_C0);
+      manage_response(true, true);
+    }
+    if (!FILAMENT_PRESENT()) {
+      DEBUG_ECHOLNPGM("Filament never reached sensor, runout");
+      filament_runout();
+    }
+    mmu_idl_sens = 0;
+  }
+
+#else // !HAS_PRUSA_MMU2S && !MMU_EXTRUDER_SENSOR
+
+  /**
+   * Handle tool change
+   */
+  void MMU2::tool_change(const uint8_t index) {
+    if (!enabled) return;
+
+    set_runout_valid(false);
+
+    if (index != extruder) {
+      DISABLE_AXIS_E0();
+      ui.status_printf_P(0, GET_TEXT(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
+      command(MMU_CMD_T0 + index);
+      manage_response(true, true);
+      command(MMU_CMD_C0);
+      extruder = index; //filament change is finished
+      active_extruder = 0;
+      ENABLE_AXIS_E0();
+      SERIAL_ECHO_START();
+      SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(extruder));
+      ui.reset_status();
+    }
+
+    set_runout_valid(true);
+  }
+
+  /**
+   * Handle special T?/Tx/Tc commands
+   *
+   * T? Gcode to extrude shouldn't have to follow, load to extruder wheels is done automatically
+   * Tx Same as T?, except nozzle doesn't have to be preheated. Tc must be placed after extruder nozzle is preheated to finish filament load.
+   * Tc Load to nozzle after filament was prepared by Tx and extruder nozzle is already heated.
+   */
+  void MMU2::tool_change(const char* special) {
+    if (!enabled) return;
+
+    set_runout_valid(false);
+
+    switch (*special) {
+      case '?': {
+        DEBUG_ECHOLNPGM("case ?\n");
+        #if ENABLED(MMU2_MENUS)
+          uint8_t index = mmu2_choose_filament();
+          while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
+          load_filament_to_nozzle(index);
+        #else
+          BUZZ(400, 40);
+        #endif
+      } break;
+
+      case 'x': {
+        DEBUG_ECHOLNPGM("case x\n");
+        #if ENABLED(MMU2_MENUS)
+          planner.synchronize();
+          uint8_t index = mmu2_choose_filament();
+          DISABLE_AXIS_E0();
+          command(MMU_CMD_T0 + index);
+          manage_response(true, true);
+          command(MMU_CMD_C0);
+          mmu_loop();
+
+          ENABLE_AXIS_E0();
+          extruder = index;
+          active_extruder = 0;
+        #else
+          BUZZ(400, 40);
+        #endif
+      } break;
+
+      case 'c': {
+        DEBUG_ECHOLNPGM("case c\n");
+        while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
+        execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
+      } break;
+    }
+
+    set_runout_valid(true);
+  }
+
+#endif // HAS_PRUSA_MMU2S
+
+/**
+ * Set next command
+ */
+void MMU2::command(const uint8_t mmu_cmd) {
+  if (!enabled) return;
+  cmd = mmu_cmd;
+  ready = false;
+}
+
+/**
+ * Wait for response from MMU
+ */
+bool MMU2::get_response() {
+  while (cmd != MMU_CMD_NONE) idle();
+
+  while (!ready) {
+    idle();
+    if (state != 3) break;
+  }
+
+  const bool ret = ready;
+  ready = false;
+
+  return ret;
+}
+
+/**
+ * Wait for response and deal with timeout if nexcessary
+ */
+void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
+
+  constexpr xyz_pos_t park_point = NOZZLE_PARK_POINT;
+  bool response = false;
+  mmu_print_saved = false;
+  xyz_pos_t resume_position;
+  int16_t resume_hotend_temp = thermalManager.degTargetHotend(active_extruder);
+
+  KEEPALIVE_STATE(PAUSED_FOR_USER);
+
+  while (!response) {
+
+    response = get_response(); // wait for "ok" from mmu
+
+    if (!response) {          // No "ok" was received in reserved time frame, user will fix the issue on mmu unit
+      if (!mmu_print_saved) { // First occurrence. Save current position, park print head, disable nozzle heater.
+
+        planner.synchronize();
+
+        mmu_print_saved = true;
+
+        SERIAL_ECHOLNPGM("MMU not responding");
+
+        resume_hotend_temp = thermalManager.degTargetHotend(active_extruder);
+        resume_position = current_position;
+
+        if (move_axes && all_axes_homed())
+          nozzle.park(0, park_point /*= NOZZLE_PARK_POINT*/);
+
+        if (turn_off_nozzle) thermalManager.setTargetHotend(0, active_extruder);
+
+        mmu2_not_responding();
+      }
+    }
+    else if (mmu_print_saved) {
+      SERIAL_ECHOLNPGM("MMU starts responding\n");
+
+      if (turn_off_nozzle && resume_hotend_temp) {
+        thermalManager.setTargetHotend(resume_hotend_temp, active_extruder);
+        LCD_MESSAGEPGM(MSG_HEATING);
+        BUZZ(200, 40);
+
+        while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(1000);
+      }
+
+      if (move_axes && all_axes_homed()) {
+        LCD_MESSAGEPGM(MSG_MMU2_RESUMING);
+        BUZZ(198, 404); BUZZ(4, 0); BUZZ(198, 404);
+
+        // Move XY to starting position, then Z
+        do_blocking_move_to_xy(resume_position, feedRate_t(NOZZLE_PARK_XY_FEEDRATE));
+
+        // Move Z_AXIS to saved position
+        do_blocking_move_to_z(resume_position.z, feedRate_t(NOZZLE_PARK_Z_FEEDRATE));
+      }
+      else {
+        BUZZ(198, 404); BUZZ(4, 0); BUZZ(198, 404);
+        LCD_MESSAGEPGM(MSG_MMU2_RESUMING);
+      }
+    }
+  }
+}
+
+void MMU2::set_filament_type(const uint8_t index, const uint8_t filamentType) {
+  if (!enabled) return;
+
+  cmd_arg = filamentType;
+  command(MMU_CMD_F0 + index);
+
+  manage_response(true, true);
+}
+
+void MMU2::filament_runout() {
+  queue.inject_P(PSTR(MMU2_FILAMENT_RUNOUT_SCRIPT));
+  planner.synchronize();
+}
+
+#if HAS_PRUSA_MMU2S
+
+  void MMU2::check_filament() {
+    const bool present = FILAMENT_PRESENT();
+    if (cmd == MMU_CMD_NONE && last_cmd == MMU_CMD_C0) {
+      if (present && !mmu2s_triggered) {
+        DEBUG_ECHOLNPGM("MMU <= 'A'");
+        tx_str_P(PSTR("A\n"));
+      }
+      // Slowly spin the extruder during C0
+      else {
+        while (planner.movesplanned() < 3) {
+          current_position.e += 0.25;
+          line_to_current_position(MMM_TO_MMS(120));
+        }
+      }
+    }
+    mmu2s_triggered = present;
+  }
+
+  bool MMU2::can_load() {
+    execute_extruder_sequence((const E_Step *)can_load_sequence, COUNT(can_load_sequence));
+
+    int filament_detected_count = 0;
+    const int steps = (MMU2_CAN_LOAD_RETRACT) / (MMU2_CAN_LOAD_INCREMENT);
+    DEBUG_ECHOLNPGM("MMU can_load:");
+    LOOP_L_N(i, steps) {
+      execute_extruder_sequence((const E_Step *)can_load_increment_sequence, COUNT(can_load_increment_sequence));
+      check_filament(); // Don't trust the idle function
+      DEBUG_CHAR(mmu2s_triggered ? 'O' : 'o');
+      if (mmu2s_triggered) ++filament_detected_count;
+    }
+
+    if (filament_detected_count <= steps - (MMU2_CAN_LOAD_DEVIATION) / (MMU2_CAN_LOAD_INCREMENT)) {
+      DEBUG_ECHOLNPGM(" failed.");
+      return false;
+    }
+
+    DEBUG_ECHOLNPGM(" succeeded.");
+    return true;
+  }
+
+#endif
+
+// Load filament into MMU2
+void MMU2::load_filament(const uint8_t index) {
+  if (!enabled) return;
+  command(MMU_CMD_L0 + index);
+  manage_response(false, false);
+  BUZZ(200, 404);
+}
+
+/**
+ * Switch material and load to nozzle
+ */
+bool MMU2::load_filament_to_nozzle(const uint8_t index) {
+
+  if (!enabled) return false;
+
+  if (thermalManager.tooColdToExtrude(active_extruder)) {
+    BUZZ(200, 404);
+    LCD_ALERTMESSAGEPGM(MSG_HOTEND_TOO_COLD);
+    return false;
+  }
+
+  command(MMU_CMD_T0 + index);
+  manage_response(true, true);
+
+  const bool success = load_to_gears();
+  if (success) {
+    mmu_loop();
+    extruder = index;
+    active_extruder = 0;
+    load_to_nozzle();
+    BUZZ(200, 404);
+  }
+  return success;
+}
+
+/**
+ * Load filament to nozzle of multimaterial printer
+ *
+ * This function is used only only after T? (user select filament) and M600 (change filament).
+ * It is not used after T0 .. T4 command (select filament), in such case, gcode is responsible for loading
+ * filament to nozzle.
+ */
+void MMU2::load_to_nozzle() {
+  if (!enabled) return;
+  execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
+}
+
+bool MMU2::eject_filament(const uint8_t index, const bool recover) {
+
+  if (!enabled) return false;
+
+  if (thermalManager.tooColdToExtrude(active_extruder)) {
+    BUZZ(200, 404);
+    LCD_ALERTMESSAGEPGM(MSG_HOTEND_TOO_COLD);
+    return false;
+  }
+
+  LCD_MESSAGEPGM(MSG_MMU2_EJECTING_FILAMENT);
+
+  ENABLE_AXIS_E0();
+  current_position.e -= MMU2_FILAMENTCHANGE_EJECT_FEED;
+  line_to_current_position(MMM_TO_MMS(2500));
+  planner.synchronize();
+  command(MMU_CMD_E0 + index);
+  manage_response(false, false);
+
+  if (recover)  {
+    LCD_MESSAGEPGM(MSG_MMU2_EJECT_RECOVER);
+    BUZZ(200, 404);
+    TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, PSTR("MMU2 Eject Recover"), CONTINUE_STR));
+    TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired_P(PSTR("MMU2 Eject Recover")));
+    wait_for_user_response();
+    BUZZ(200, 404);
+    BUZZ(200, 404);
+
+    command(MMU_CMD_R0);
+    manage_response(false, false);
+  }
+
+  ui.reset_status();
+
+  // no active tool
+  extruder = MMU2_NO_TOOL;
+
+  set_runout_valid(false);
+
+  BUZZ(200, 404);
+
+  DISABLE_AXIS_E0();
+
+  return true;
+}
+
+/**
+ * Unload from hotend and retract to MMU
+ */
+bool MMU2::unload() {
+
+  if (!enabled) return false;
+
+  if (thermalManager.tooColdToExtrude(active_extruder)) {
+    BUZZ(200, 404);
+    LCD_ALERTMESSAGEPGM(MSG_HOTEND_TOO_COLD);
+    return false;
+  }
+
+  filament_ramming();
+
+  command(MMU_CMD_U0);
+  manage_response(false, true);
+
+  BUZZ(200, 404);
+
+  // no active tool
+  extruder = MMU2_NO_TOOL;
+
+  set_runout_valid(false);
+
+  return true;
+}
+
+/**
+ * Unload sequence to optimize shape of the tip of the unloaded filament
+ */
+void MMU2::filament_ramming() {
+  execute_extruder_sequence((const E_Step *)ramming_sequence, sizeof(ramming_sequence) / sizeof(E_Step));
+}
+
+void MMU2::execute_extruder_sequence(const E_Step * sequence, int steps) {
+
+  planner.synchronize();
+  ENABLE_AXIS_E0();
+
+  const E_Step* step = sequence;
+
+  LOOP_L_N(i, steps) {
+    const float es = pgm_read_float(&(step->extrude));
+    const feedRate_t fr_mm_m = pgm_read_float(&(step->feedRate));
+
+    DEBUG_ECHO_START();
+    DEBUG_ECHOLNPAIR("E step ", es, "/", fr_mm_m);
+
+    current_position.e += es;
+    line_to_current_position(MMM_TO_MMS(fr_mm_m));
+    planner.synchronize();
+
+    step++;
+  }
+
+  DISABLE_AXIS_E0();
+}
+
+#endif // HAS_PRUSA_MMU2
