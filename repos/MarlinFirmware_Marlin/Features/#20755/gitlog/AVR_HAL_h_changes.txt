commit ab0173b7e6843f1a6328658e2de742b3bc52ce1b
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jun 2 15:45:19 2024 -0400

    üö∏ ExtUI: Shaping, Probing limits (#26754)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 3c883b645c..d131985916 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -141,7 +141,7 @@ typedef Servo hal_servo_t;
     #error "LCD_SERIAL_PORT must be from 0 to 3."
   #endif
   #define LCD_SERIAL lcdSerial
-  #if HAS_DGUS_LCD
+  #if ANY(HAS_DGUS_LCD, EXTENSIBLE_UI)
     #define LCD_SERIAL_TX_BUFFER_FREE() LCD_SERIAL.get_tx_buffer_free()
   #endif
 #endif

commit 9a12f06f199e86ca18ff2d40119805330c4ff6c6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 25 21:17:18 2023 -0600

    üé® Update file headers
    
    Marlin is collectively ¬© by the Organization, with individual contributors having ¬© on their original work as documented in the commit history.

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 7d5e1000d7..3c883b645c 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -1,7 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit 3baa318ec737a67cec6087194ab04fb2242279e0
Author: Martin Turski <turningtides@outlook.de>
Date:   Fri Aug 4 05:56:40 2023 +0200

    üßë‚Äçüíª Option to reset AVR pin states (#25364)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 16878a8ab8..7d5e1000d7 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -187,7 +187,7 @@ class MarlinHAL {
 public:
 
   // Earliest possible init, before setup()
-  MarlinHAL() {}
+  MarlinHAL();
 
   // Watchdog
   static void watchdog_init()    IF_DISABLED(USE_WATCHDOG, {});

commit 6474773555274527ac4a24162dfdd9ea4b2b59da
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Thu Jun 29 00:06:50 2023 +0200

    üêõ Fix AD4985 with 5V input, add AD595 3.3V warning (#26021)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 6d98dff080..16878a8ab8 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -147,8 +147,8 @@ typedef Servo hal_servo_t;
 //
 // ADC
 //
-#define HAL_ADC_VREF        5.0
-#define HAL_ADC_RESOLUTION 10
+#define HAL_ADC_VREF_MV   5000
+#define HAL_ADC_RESOLUTION  10
 
 //
 // Pin Mapping for M42, M43, M226

commit 37d0f49a82cd2e4d91dce4e62671b266924eb2a7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 24 01:05:55 2023 -0500

    üßë‚Äçüíª Misc. ExtUI LCD cleanup (#25872)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index d458790979..6d98dff080 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -140,7 +140,7 @@ typedef Servo hal_servo_t;
   #endif
   #define LCD_SERIAL lcdSerial
   #if HAS_DGUS_LCD
-    #define SERIAL_GET_TX_BUFFER_FREE() LCD_SERIAL.get_tx_buffer_free()
+    #define LCD_SERIAL_TX_BUFFER_FREE() LCD_SERIAL.get_tx_buffer_free()
   #endif
 #endif
 

commit 437cc484707cba8f8da5898bf7274e2254989cbe
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Thu Oct 20 14:29:15 2022 +1300

    üîß No Native USB on AVR (#24906)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 1491867721..d458790979 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -32,6 +32,7 @@
   #include <HardwareSerial.h>
 #else
   #include "MarlinSerial.h"
+  #define BOARD_NO_NATIVE_USB
 #endif
 
 #include <stdint.h>
@@ -106,36 +107,36 @@ typedef Servo hal_servo_t;
 
   #define MYSERIAL1 TERN(BLUETOOTH, btSerial, MSerial0)
 #else
-  #if !WITHIN(SERIAL_PORT, -1, 3)
-    #error "SERIAL_PORT must be from 0 to 3, or -1 for USB Serial."
+  #if !WITHIN(SERIAL_PORT, 0, 3)
+    #error "SERIAL_PORT must be from 0 to 3."
   #endif
   #define MYSERIAL1 customizedSerial1
 
   #ifdef SERIAL_PORT_2
-    #if !WITHIN(SERIAL_PORT_2, -1, 3)
-      #error "SERIAL_PORT_2 must be from 0 to 3, or -1 for USB Serial."
+    #if !WITHIN(SERIAL_PORT_2, 0, 3)
+      #error "SERIAL_PORT_2 must be from 0 to 3."
     #endif
     #define MYSERIAL2 customizedSerial2
   #endif
 
   #ifdef SERIAL_PORT_3
-    #if !WITHIN(SERIAL_PORT_3, -1, 3)
-      #error "SERIAL_PORT_3 must be from 0 to 3, or -1 for USB Serial."
+    #if !WITHIN(SERIAL_PORT_3, 0, 3)
+      #error "SERIAL_PORT_3 must be from 0 to 3."
     #endif
     #define MYSERIAL3 customizedSerial3
   #endif
 #endif
 
 #ifdef MMU2_SERIAL_PORT
-  #if !WITHIN(MMU2_SERIAL_PORT, -1, 3)
-    #error "MMU2_SERIAL_PORT must be from 0 to 3, or -1 for USB Serial."
+  #if !WITHIN(MMU2_SERIAL_PORT, 0, 3)
+    #error "MMU2_SERIAL_PORT must be from 0 to 3"
   #endif
   #define MMU2_SERIAL mmuSerial
 #endif
 
 #ifdef LCD_SERIAL_PORT
-  #if !WITHIN(LCD_SERIAL_PORT, -1, 3)
-    #error "LCD_SERIAL_PORT must be from 0 to 3, or -1 for USB Serial."
+  #if !WITHIN(LCD_SERIAL_PORT, 0, 3)
+    #error "LCD_SERIAL_PORT must be from 0 to 3."
   #endif
   #define LCD_SERIAL lcdSerial
   #if HAS_DGUS_LCD

commit 52eefa90e1c18616f127cdf43798907880e05ee5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 11:36:13 2022 -0500

    ‚ôªÔ∏è Move watchdog to MarlinHAL

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index b2995b90cf..1491867721 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -26,7 +26,6 @@
 #include "../shared/Marduino.h"
 #include "../shared/HAL_SPI.h"
 #include "fastio.h"
-#include "watchdog.h"
 #include "math.h"
 
 #ifdef USBCON
@@ -189,6 +188,10 @@ public:
   // Earliest possible init, before setup()
   MarlinHAL() {}
 
+  // Watchdog
+  static void watchdog_init()    IF_DISABLED(USE_WATCHDOG, {});
+  static void watchdog_refresh() IF_DISABLED(USE_WATCHDOG, {});
+
   static void init();          // Called early in setup()
   static void init_board() {}  // Called less early in setup()
   static void reboot();        // Restart the firmware from 0x0

commit 12da2e92882a67d29456f02882ff1ee747191939
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 14 15:31:51 2022 -0500

    üé® Minor HAL cleanup

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index b96169b2ed..b2995b90cf 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -167,7 +167,7 @@ typedef Servo hal_servo_t;
 #define strtof strtod
 
 // ------------------------
-// Class Utilities
+// Free Memory Accessor
 // ------------------------
 
 #pragma GCC diagnostic push

commit 66e32cb0fa1ed6cfae482bec31dfbb834340a408
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri May 13 19:31:07 2022 -0500

    üßë‚Äçüíª Clarify MSerialUSB, drop HardwareSerial workaround

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index a2062775c4..b96169b2ed 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -32,7 +32,6 @@
 #ifdef USBCON
   #include <HardwareSerial.h>
 #else
-  #define HardwareSerial_h // Hack to prevent HardwareSerial.h header inclusion
   #include "MarlinSerial.h"
 #endif
 

commit 80810f1b187661860a2ded43e2a0c4cc356edebe
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 1 17:49:54 2022 -0600

    üö® Fix some compiler warnings

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index c7454a5234..a2062775c4 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -19,6 +19,10 @@
  */
 #pragma once
 
+/**
+ * HAL for Arduino AVR
+ */
+
 #include "../shared/Marduino.h"
 #include "../shared/HAL_SPI.h"
 #include "fastio.h"

commit f7fff4d455411f639cc05f68b56376d6b1afeea1
Author: John Robertson <john@cirtech.co.uk>
Date:   Mon Apr 4 00:47:55 2022 +0100

    üßë‚Äçüíª Define isr_float_t to assert a non-FPU float (#23969)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index e825b4def3..c7454a5234 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -229,7 +229,7 @@ public:
     SBI(DIDR0, ch);
   }
 
-  // Begin ADC sampling on the given channel
+  // Begin ADC sampling on the given channel. Called from Temperature::isr!
   static void adc_start(const uint8_t ch) {
     #ifdef MUX5
       ADCSRB = ch > 7 ? _BV(MUX5) : 0;

commit 44eff9a23348dcc117fd1ea9b4b1ef0b54061808
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Feb 17 18:50:31 2022 -0600

    ‚ôªÔ∏è Refactor HAL as singleton (#23357)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index f5cbcc9d51..e825b4def3 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -74,9 +74,9 @@
   #define CRITICAL_SECTION_START()  unsigned char _sreg = SREG; cli()
   #define CRITICAL_SECTION_END()    SREG = _sreg
 #endif
-#define ISRS_ENABLED() TEST(SREG, SREG_I)
-#define ENABLE_ISRS()  sei()
-#define DISABLE_ISRS() cli()
+
+#define HAL_CAN_SET_PWM_FREQ   // This HAL supports PWM Frequency adjustment
+#define PWM_FREQUENCY 1000     // Default PWM frequency when set_pwm_duty() is called without set_pwm_frequency()
 
 // ------------------------
 // Types
@@ -84,16 +84,15 @@
 
 typedef int8_t pin_t;
 
-#define SHARED_SERVOS HAS_SERVOS
-#define HAL_SERVO_LIB Servo
+#define SHARED_SERVOS HAS_SERVOS  // Use shared/servos.cpp
+
+class Servo;
+typedef Servo hal_servo_t;
 
 // ------------------------
-// Public Variables
+// Serial ports
 // ------------------------
 
-extern uint8_t reset_reason;
-
-// Serial ports
 #ifdef USBCON
   #include "../../core/serial_hook.h"
   typedef ForwardSerial1Class< decltype(Serial) > DefaultSerial1;
@@ -142,20 +141,31 @@ extern uint8_t reset_reason;
   #endif
 #endif
 
-// ------------------------
-// Public functions
-// ------------------------
+//
+// ADC
+//
+#define HAL_ADC_VREF        5.0
+#define HAL_ADC_RESOLUTION 10
 
-void HAL_init();
+//
+// Pin Mapping for M42, M43, M226
+//
+#define GET_PIN_MAP_PIN(index) index
+#define GET_PIN_MAP_INDEX(pin) pin
+#define PARSED_PIN_INDEX(code, dval) parser.intval(code, dval)
 
-//void cli();
+#define HAL_SENSITIVE_PINS 0, 1,
 
-//void _delay_ms(const int delay);
+#ifdef __AVR_AT90USB1286__
+  #define JTAG_DISABLE() do{ MCUCR = 0x80; MCUCR = 0x80; }while(0)
+#endif
 
-inline void HAL_clear_reset_source() { }
-inline uint8_t HAL_get_reset_source() { return reset_reason; }
+// AVR compatibility
+#define strtof strtod
 
-void HAL_reboot();
+// ------------------------
+// Class Utilities
+// ------------------------
 
 #pragma GCC diagnostic push
 #if GCC_VERSION <= 50000
@@ -166,70 +176,96 @@ extern "C" int freeMemory();
 
 #pragma GCC diagnostic pop
 
-// ADC
-#ifdef DIDR2
-  #define HAL_ANALOG_SELECT(ind) do{ if (ind < 8) SBI(DIDR0, ind); else SBI(DIDR2, ind & 0x07); }while(0)
-#else
-  #define HAL_ANALOG_SELECT(ind) SBI(DIDR0, ind);
-#endif
+// ------------------------
+// MarlinHAL Class
+// ------------------------
 
-inline void HAL_adc_init() {
-  ADCSRA = _BV(ADEN) | _BV(ADSC) | _BV(ADIF) | 0x07;
-  DIDR0 = 0;
-  #ifdef DIDR2
-    DIDR2 = 0;
-  #endif
-}
+class MarlinHAL {
+public:
 
-#define SET_ADMUX_ADCSRA(ch) ADMUX = _BV(REFS0) | (ch & 0x07); SBI(ADCSRA, ADSC)
-#ifdef MUX5
-  #define HAL_START_ADC(ch) if (ch > 7) ADCSRB = _BV(MUX5); else ADCSRB = 0; SET_ADMUX_ADCSRA(ch)
-#else
-  #define HAL_START_ADC(ch) ADCSRB = 0; SET_ADMUX_ADCSRA(ch)
-#endif
+  // Earliest possible init, before setup()
+  MarlinHAL() {}
 
-#define HAL_ADC_VREF        5.0
-#define HAL_ADC_RESOLUTION 10
-#define HAL_READ_ADC()  ADC
-#define HAL_ADC_READY() !TEST(ADCSRA, ADSC)
+  static void init();          // Called early in setup()
+  static void init_board() {}  // Called less early in setup()
+  static void reboot();        // Restart the firmware from 0x0
 
-#define GET_PIN_MAP_PIN(index) index
-#define GET_PIN_MAP_INDEX(pin) pin
-#define PARSED_PIN_INDEX(code, dval) parser.intval(code, dval)
+  // Interrupts
+  static bool isr_state() { return TEST(SREG, SREG_I); }
+  static void isr_on()  { sei(); }
+  static void isr_off() { cli(); }
 
-#define HAL_SENSITIVE_PINS 0, 1,
+  static void delay_ms(const int ms) { _delay_ms(ms); }
 
-#ifdef __AVR_AT90USB1286__
-  #define JTAG_DISABLE() do{ MCUCR = 0x80; MCUCR = 0x80; }while(0)
-#endif
+  // Tasks, called from idle()
+  static void idletask() {}
 
-// AVR compatibility
-#define strtof strtod
+  // Reset
+  static uint8_t reset_reason;
+  static uint8_t get_reset_source() { return reset_reason; }
+  static void clear_reset_source() { MCUSR = 0; }
 
-#define HAL_CAN_SET_PWM_FREQ   // This HAL supports PWM Frequency adjustment
-#define PWM_FREQUENCY 1000     // Default PWM frequency when set_pwm_duty() is called without set_pwm_frequency()
+  // Free SRAM
+  static int freeMemory() { return ::freeMemory(); }
 
-/**
- *  set_pwm_frequency
- *  Sets the frequency of the timer corresponding to the provided pin
- *  as close as possible to the provided desired frequency. Internally
- *  calculates the required waveform generation mode, prescaler and
- *  resolution values required and sets the timer registers accordingly.
- *  NOTE that the frequency is applied to all pins on the timer (Ex OC3A, OC3B and OC3B)
- *  NOTE that there are limitations, particularly if using TIMER2. (see Configuration_adv.h -> FAST FAN PWM Settings)
- */
-void set_pwm_frequency(const pin_t pin, const uint16_t f_desired);
+  //
+  // ADC Methods
+  //
 
-/**
- * set_pwm_duty
- *  Set the PWM duty cycle of the provided pin to the provided value
- *  Optionally allows inverting the duty cycle [default = false]
- *  Optionally allows changing the maximum size of the provided value to enable finer PWM duty control [default = 255]
- */
-void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size=255, const bool invert=false);
+  // Called by Temperature::init once at startup
+  static void adc_init() {
+    ADCSRA = _BV(ADEN) | _BV(ADSC) | _BV(ADIF) | 0x07;
+    DIDR0 = 0;
+    #ifdef DIDR2
+      DIDR2 = 0;
+    #endif
+  }
 
-/*
- * init_pwm_timers
- * sets the default frequency for timers 2-5 to 1000HZ
- */
-void init_pwm_timers();
+  // Called by Temperature::init for each sensor at startup
+  static void adc_enable(const uint8_t ch) {
+    #ifdef DIDR2
+      if (ch > 7) { SBI(DIDR2, ch & 0x07); return; }
+    #endif
+    SBI(DIDR0, ch);
+  }
+
+  // Begin ADC sampling on the given channel
+  static void adc_start(const uint8_t ch) {
+    #ifdef MUX5
+      ADCSRB = ch > 7 ? _BV(MUX5) : 0;
+    #else
+      ADCSRB = 0;
+    #endif
+    ADMUX = _BV(REFS0) | (ch & 0x07);
+    SBI(ADCSRA, ADSC);
+  }
+
+  // Is the ADC ready for reading?
+  static bool adc_ready() { return !TEST(ADCSRA, ADSC); }
+
+  // The current value of the ADC register
+  static __typeof__(ADC) adc_value() { return ADC; }
+
+  /**
+   * init_pwm_timers
+   * Set the default frequency for timers 2-5 to 1000HZ
+   */
+  static void init_pwm_timers();
+
+  /**
+   * Set the PWM duty cycle for the pin to the given value.
+   * Optionally invert the duty cycle [default = false]
+   * Optionally change the scale of the provided value to enable finer PWM duty control [default = 255]
+   */
+  static void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size=255, const bool invert=false);
+
+  /**
+   * Set the frequency of the timer for the given pin as close as
+   * possible to the provided desired frequency. Internally calculate
+   * the required waveform generation mode, prescaler, and resolution
+   * values and set timer registers accordingly.
+   * NOTE that the frequency is applied to all pins on the timer (Ex OC3A, OC3B and OC3B)
+   * NOTE that there are limitations, particularly if using TIMER2. (see Configuration_adv.h -> FAST_PWM_FAN Settings)
+   */
+  static void set_pwm_frequency(const pin_t pin, const uint16_t f_desired);
+};

commit 2cfde39ecac13eb75f8ce933d2116d1b75db3e4b
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Wed Jan 12 17:28:53 2022 -0600

    üêõ Fix, improve PWM on AVR (#23463)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 451ed1ee9f..f5cbcc9d51 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -207,6 +207,7 @@ inline void HAL_adc_init() {
 #define strtof strtod
 
 #define HAL_CAN_SET_PWM_FREQ   // This HAL supports PWM Frequency adjustment
+#define PWM_FREQUENCY 1000     // Default PWM frequency when set_pwm_duty() is called without set_pwm_frequency()
 
 /**
  *  set_pwm_frequency
@@ -226,3 +227,9 @@ void set_pwm_frequency(const pin_t pin, const uint16_t f_desired);
  *  Optionally allows changing the maximum size of the provided value to enable finer PWM duty control [default = 255]
  */
 void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size=255, const bool invert=false);
+
+/*
+ * init_pwm_timers
+ * sets the default frequency for timers 2-5 to 1000HZ
+ */
+void init_pwm_timers();

commit 07bffdf4bc451ad95ba0f5c196d7c3c9adcaf1cd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 10 19:49:54 2022 -0600

    üßë‚Äçüíª Adjust FastIO AVR timer enums, macros

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 2217f239d6..451ed1ee9f 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -217,7 +217,7 @@ inline void HAL_adc_init() {
  *  NOTE that the frequency is applied to all pins on the timer (Ex OC3A, OC3B and OC3B)
  *  NOTE that there are limitations, particularly if using TIMER2. (see Configuration_adv.h -> FAST FAN PWM Settings)
  */
-void set_pwm_frequency(const pin_t pin, int f_desired);
+void set_pwm_frequency(const pin_t pin, const uint16_t f_desired);
 
 /**
  * set_pwm_duty

commit 6a8b9274a31d11c396ce1bc44b3a0b872a4606dc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Dec 25 23:15:17 2021 -0600

    ‚è™Ô∏è Refactor still needs work
    
    Reverting #23295

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 3dade7fa15..2217f239d6 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -74,8 +74,9 @@
   #define CRITICAL_SECTION_START()  unsigned char _sreg = SREG; cli()
   #define CRITICAL_SECTION_END()    SREG = _sreg
 #endif
-
-#define HAL_CAN_SET_PWM_FREQ   // This HAL supports PWM Frequency adjustment
+#define ISRS_ENABLED() TEST(SREG, SREG_I)
+#define ENABLE_ISRS()  sei()
+#define DISABLE_ISRS() cli()
 
 // ------------------------
 // Types
@@ -83,16 +84,16 @@
 
 typedef int8_t pin_t;
 
-// Use shared/servos.cpp
 #define SHARED_SERVOS HAS_SERVOS
-
-class Servo;
-typedef Servo hal_servo_t;
+#define HAL_SERVO_LIB Servo
 
 // ------------------------
-// Serial ports
+// Public Variables
 // ------------------------
 
+extern uint8_t reset_reason;
+
+// Serial ports
 #ifdef USBCON
   #include "../../core/serial_hook.h"
   typedef ForwardSerial1Class< decltype(Serial) > DefaultSerial1;
@@ -141,31 +142,20 @@ typedef Servo hal_servo_t;
   #endif
 #endif
 
-//
-// ADC
-//
-#define HAL_ADC_VREF        5.0
-#define HAL_ADC_RESOLUTION 10
+// ------------------------
+// Public functions
+// ------------------------
 
-//
-// Pin Mapping for M42, M43, M226
-//
-#define GET_PIN_MAP_PIN(index) index
-#define GET_PIN_MAP_INDEX(pin) pin
-#define PARSED_PIN_INDEX(code, dval) parser.intval(code, dval)
+void HAL_init();
 
-#define HAL_SENSITIVE_PINS 0, 1,
+//void cli();
 
-#ifdef __AVR_AT90USB1286__
-  #define JTAG_DISABLE() do{ MCUCR = 0x80; MCUCR = 0x80; }while(0)
-#endif
+//void _delay_ms(const int delay);
 
-// AVR compatibility
-#define strtof strtod
+inline void HAL_clear_reset_source() { }
+inline uint8_t HAL_get_reset_source() { return reset_reason; }
 
-// ------------------------
-// Class Utilities
-// ------------------------
+void HAL_reboot();
 
 #pragma GCC diagnostic push
 #if GCC_VERSION <= 50000
@@ -176,91 +166,63 @@ extern "C" int freeMemory();
 
 #pragma GCC diagnostic pop
 
-// ------------------------
-// MarlinHAL Class
-// ------------------------
-
-class MarlinHAL {
-public:
+// ADC
+#ifdef DIDR2
+  #define HAL_ANALOG_SELECT(ind) do{ if (ind < 8) SBI(DIDR0, ind); else SBI(DIDR2, ind & 0x07); }while(0)
+#else
+  #define HAL_ANALOG_SELECT(ind) SBI(DIDR0, ind);
+#endif
 
-  // Earliest possible init, before setup()
-  MarlinHAL() {}
+inline void HAL_adc_init() {
+  ADCSRA = _BV(ADEN) | _BV(ADSC) | _BV(ADIF) | 0x07;
+  DIDR0 = 0;
+  #ifdef DIDR2
+    DIDR2 = 0;
+  #endif
+}
 
-  static void init();                 // Called early in setup()
-  static inline void init_board() {}  // Called less early in setup()
-  static void reboot();               // Restart the firmware from 0x0
+#define SET_ADMUX_ADCSRA(ch) ADMUX = _BV(REFS0) | (ch & 0x07); SBI(ADCSRA, ADSC)
+#ifdef MUX5
+  #define HAL_START_ADC(ch) if (ch > 7) ADCSRB = _BV(MUX5); else ADCSRB = 0; SET_ADMUX_ADCSRA(ch)
+#else
+  #define HAL_START_ADC(ch) ADCSRB = 0; SET_ADMUX_ADCSRA(ch)
+#endif
 
-  static inline bool isr_state() { return TEST(SREG, SREG_I); }
-  static inline void isr_on()  { sei(); }
-  static inline void isr_off() { cli(); }
+#define HAL_ADC_VREF        5.0
+#define HAL_ADC_RESOLUTION 10
+#define HAL_READ_ADC()  ADC
+#define HAL_ADC_READY() !TEST(ADCSRA, ADSC)
 
-  static inline void delay_ms(const int ms) { _delay_ms(ms); }
+#define GET_PIN_MAP_PIN(index) index
+#define GET_PIN_MAP_INDEX(pin) pin
+#define PARSED_PIN_INDEX(code, dval) parser.intval(code, dval)
 
-  // Tasks, called from idle()
-  static inline void idletask() {}
+#define HAL_SENSITIVE_PINS 0, 1,
 
-  // Reset
-  static uint8_t reset_reason;
-  static inline uint8_t get_reset_source() { return reset_reason; }
-  static inline void clear_reset_source() { MCUSR = 0; }
+#ifdef __AVR_AT90USB1286__
+  #define JTAG_DISABLE() do{ MCUCR = 0x80; MCUCR = 0x80; }while(0)
+#endif
 
-  // Free SRAM
-  static inline int freeMemory() { return ::freeMemory(); }
+// AVR compatibility
+#define strtof strtod
 
-  //
-  // ADC Methods
-  //
+#define HAL_CAN_SET_PWM_FREQ   // This HAL supports PWM Frequency adjustment
 
-  // Called by Temperature::init once at startup
-  static inline void adc_init() {
-    ADCSRA = _BV(ADEN) | _BV(ADSC) | _BV(ADIF) | 0x07;
-    DIDR0 = 0;
-    #ifdef DIDR2
-      DIDR2 = 0;
-    #endif
-  }
+/**
+ *  set_pwm_frequency
+ *  Sets the frequency of the timer corresponding to the provided pin
+ *  as close as possible to the provided desired frequency. Internally
+ *  calculates the required waveform generation mode, prescaler and
+ *  resolution values required and sets the timer registers accordingly.
+ *  NOTE that the frequency is applied to all pins on the timer (Ex OC3A, OC3B and OC3B)
+ *  NOTE that there are limitations, particularly if using TIMER2. (see Configuration_adv.h -> FAST FAN PWM Settings)
+ */
+void set_pwm_frequency(const pin_t pin, int f_desired);
 
-  // Called by Temperature::init for each sensor at startup
-  static inline void adc_enable(const uint8_t ch) {
-    #ifdef DIDR2
-      if (ch > 7) { SBI(DIDR2, ch & 0x07); return; }
-    #endif
-    SBI(DIDR0, ch);
-  }
-
-  // Begin ADC sampling on the given channel
-  static inline void adc_start(const uint8_t ch) {
-    #ifdef MUX5
-      ADCSRB = ch > 7 ? _BV(MUX5) : 0;
-    #else
-      ADCSRB = 0;
-    #endif
-    ADMUX = _BV(REFS0) | (ch & 0x07);
-    SBI(ADCSRA, ADSC);
-  }
-
-  // Is the ADC ready for reading?
-  static inline bool adc_ready() { return !TEST(ADCSRA, ADSC); }
-
-  // The current value of the ADC register
-  static inline __typeof__(ADC) adc_value() { return ADC; }
-
-  /**
-   * Set the PWM duty cycle for the pin to the given value.
-   * Optionally invert the duty cycle [default = false]
-   * Optionally change the scale of the provided value to enable finer PWM duty control [default = 255]
-   */
-  static void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size=255, const bool invert=false);
-
-  /**
-   * Set the frequency of the timer for the given pin as close as
-   * possible to the provided desired frequency. Internally calculate
-   * the required waveform generation mode, prescaler, and resolution
-   * values and set timer registers accordingly.
-   * NOTE that the frequency is applied to all pins on the timer (Ex OC3A, OC3B and OC3B)
-   * NOTE that there are limitations, particularly if using TIMER2. (see Configuration_adv.h -> FAST FAN PWM Settings)
-   */
-  static void set_pwm_frequency(const pin_t pin, int f_desired);
-};
-
-extern MarlinHAL hal;
+/**
+ * set_pwm_duty
+ *  Set the PWM duty cycle of the provided pin to the provided value
+ *  Optionally allows inverting the duty cycle [default = false]
+ *  Optionally allows changing the maximum size of the provided value to enable finer PWM duty control [default = 255]
+ */
+void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size=255, const bool invert=false);

commit 00e6e90648012ca0b954139f867a9a0201319209
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Dec 25 22:10:47 2021 -0600

    üêõ Fix adc_start for AVR, native
    
    Followup to #23295

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 682374b4ac..3dade7fa15 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -229,12 +229,14 @@ public:
   }
 
   // Begin ADC sampling on the given channel
-  static inline void adc_start(const pin_t ch) {
+  static inline void adc_start(const uint8_t ch) {
     #ifdef MUX5
-      if (ch > 7) { ADCSRB = _BV(MUX5); return; }
+      ADCSRB = ch > 7 ? _BV(MUX5) : 0;
+    #else
+      ADCSRB = 0;
     #endif
-    ADCSRB = 0;
-    ADMUX = _BV(REFS0) | (ch & 0x07); SBI(ADCSRA, ADSC);
+    ADMUX = _BV(REFS0) | (ch & 0x07);
+    SBI(ADCSRA, ADSC);
   }
 
   // Is the ADC ready for reading?

commit 4f0932e5c1647b00efff22a2a5f30a1fdd57cc19
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Dec 25 20:00:48 2021 -0600

    üêõ Fix `freeMemory` endless loop
    
    Followup to #23295

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 9babe2d603..682374b4ac 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -205,7 +205,7 @@ public:
   static inline void clear_reset_source() { MCUSR = 0; }
 
   // Free SRAM
-  static inline int freeMemory() { return freeMemory(); }
+  static inline int freeMemory() { return ::freeMemory(); }
 
   //
   // ADC Methods

commit e211ff148c39bf5dace72de7cffbb83f19d3f1bf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 24 21:33:59 2021 -0600

    ‚ôªÔ∏è Refactor HAL as singleton (#23295)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 2217f239d6..9babe2d603 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -74,9 +74,8 @@
   #define CRITICAL_SECTION_START()  unsigned char _sreg = SREG; cli()
   #define CRITICAL_SECTION_END()    SREG = _sreg
 #endif
-#define ISRS_ENABLED() TEST(SREG, SREG_I)
-#define ENABLE_ISRS()  sei()
-#define DISABLE_ISRS() cli()
+
+#define HAL_CAN_SET_PWM_FREQ   // This HAL supports PWM Frequency adjustment
 
 // ------------------------
 // Types
@@ -84,16 +83,16 @@
 
 typedef int8_t pin_t;
 
+// Use shared/servos.cpp
 #define SHARED_SERVOS HAS_SERVOS
-#define HAL_SERVO_LIB Servo
+
+class Servo;
+typedef Servo hal_servo_t;
 
 // ------------------------
-// Public Variables
+// Serial ports
 // ------------------------
 
-extern uint8_t reset_reason;
-
-// Serial ports
 #ifdef USBCON
   #include "../../core/serial_hook.h"
   typedef ForwardSerial1Class< decltype(Serial) > DefaultSerial1;
@@ -142,20 +141,31 @@ extern uint8_t reset_reason;
   #endif
 #endif
 
-// ------------------------
-// Public functions
-// ------------------------
+//
+// ADC
+//
+#define HAL_ADC_VREF        5.0
+#define HAL_ADC_RESOLUTION 10
 
-void HAL_init();
+//
+// Pin Mapping for M42, M43, M226
+//
+#define GET_PIN_MAP_PIN(index) index
+#define GET_PIN_MAP_INDEX(pin) pin
+#define PARSED_PIN_INDEX(code, dval) parser.intval(code, dval)
 
-//void cli();
+#define HAL_SENSITIVE_PINS 0, 1,
 
-//void _delay_ms(const int delay);
+#ifdef __AVR_AT90USB1286__
+  #define JTAG_DISABLE() do{ MCUCR = 0x80; MCUCR = 0x80; }while(0)
+#endif
 
-inline void HAL_clear_reset_source() { }
-inline uint8_t HAL_get_reset_source() { return reset_reason; }
+// AVR compatibility
+#define strtof strtod
 
-void HAL_reboot();
+// ------------------------
+// Class Utilities
+// ------------------------
 
 #pragma GCC diagnostic push
 #if GCC_VERSION <= 50000
@@ -166,63 +176,89 @@ extern "C" int freeMemory();
 
 #pragma GCC diagnostic pop
 
-// ADC
-#ifdef DIDR2
-  #define HAL_ANALOG_SELECT(ind) do{ if (ind < 8) SBI(DIDR0, ind); else SBI(DIDR2, ind & 0x07); }while(0)
-#else
-  #define HAL_ANALOG_SELECT(ind) SBI(DIDR0, ind);
-#endif
+// ------------------------
+// MarlinHAL Class
+// ------------------------
 
-inline void HAL_adc_init() {
-  ADCSRA = _BV(ADEN) | _BV(ADSC) | _BV(ADIF) | 0x07;
-  DIDR0 = 0;
-  #ifdef DIDR2
-    DIDR2 = 0;
-  #endif
-}
+class MarlinHAL {
+public:
 
-#define SET_ADMUX_ADCSRA(ch) ADMUX = _BV(REFS0) | (ch & 0x07); SBI(ADCSRA, ADSC)
-#ifdef MUX5
-  #define HAL_START_ADC(ch) if (ch > 7) ADCSRB = _BV(MUX5); else ADCSRB = 0; SET_ADMUX_ADCSRA(ch)
-#else
-  #define HAL_START_ADC(ch) ADCSRB = 0; SET_ADMUX_ADCSRA(ch)
-#endif
+  // Earliest possible init, before setup()
+  MarlinHAL() {}
 
-#define HAL_ADC_VREF        5.0
-#define HAL_ADC_RESOLUTION 10
-#define HAL_READ_ADC()  ADC
-#define HAL_ADC_READY() !TEST(ADCSRA, ADSC)
+  static void init();                 // Called early in setup()
+  static inline void init_board() {}  // Called less early in setup()
+  static void reboot();               // Restart the firmware from 0x0
 
-#define GET_PIN_MAP_PIN(index) index
-#define GET_PIN_MAP_INDEX(pin) pin
-#define PARSED_PIN_INDEX(code, dval) parser.intval(code, dval)
+  static inline bool isr_state() { return TEST(SREG, SREG_I); }
+  static inline void isr_on()  { sei(); }
+  static inline void isr_off() { cli(); }
 
-#define HAL_SENSITIVE_PINS 0, 1,
+  static inline void delay_ms(const int ms) { _delay_ms(ms); }
 
-#ifdef __AVR_AT90USB1286__
-  #define JTAG_DISABLE() do{ MCUCR = 0x80; MCUCR = 0x80; }while(0)
-#endif
+  // Tasks, called from idle()
+  static inline void idletask() {}
 
-// AVR compatibility
-#define strtof strtod
+  // Reset
+  static uint8_t reset_reason;
+  static inline uint8_t get_reset_source() { return reset_reason; }
+  static inline void clear_reset_source() { MCUSR = 0; }
 
-#define HAL_CAN_SET_PWM_FREQ   // This HAL supports PWM Frequency adjustment
+  // Free SRAM
+  static inline int freeMemory() { return freeMemory(); }
 
-/**
- *  set_pwm_frequency
- *  Sets the frequency of the timer corresponding to the provided pin
- *  as close as possible to the provided desired frequency. Internally
- *  calculates the required waveform generation mode, prescaler and
- *  resolution values required and sets the timer registers accordingly.
- *  NOTE that the frequency is applied to all pins on the timer (Ex OC3A, OC3B and OC3B)
- *  NOTE that there are limitations, particularly if using TIMER2. (see Configuration_adv.h -> FAST FAN PWM Settings)
- */
-void set_pwm_frequency(const pin_t pin, int f_desired);
+  //
+  // ADC Methods
+  //
 
-/**
- * set_pwm_duty
- *  Set the PWM duty cycle of the provided pin to the provided value
- *  Optionally allows inverting the duty cycle [default = false]
- *  Optionally allows changing the maximum size of the provided value to enable finer PWM duty control [default = 255]
- */
-void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size=255, const bool invert=false);
+  // Called by Temperature::init once at startup
+  static inline void adc_init() {
+    ADCSRA = _BV(ADEN) | _BV(ADSC) | _BV(ADIF) | 0x07;
+    DIDR0 = 0;
+    #ifdef DIDR2
+      DIDR2 = 0;
+    #endif
+  }
+
+  // Called by Temperature::init for each sensor at startup
+  static inline void adc_enable(const uint8_t ch) {
+    #ifdef DIDR2
+      if (ch > 7) { SBI(DIDR2, ch & 0x07); return; }
+    #endif
+    SBI(DIDR0, ch);
+  }
+
+  // Begin ADC sampling on the given channel
+  static inline void adc_start(const pin_t ch) {
+    #ifdef MUX5
+      if (ch > 7) { ADCSRB = _BV(MUX5); return; }
+    #endif
+    ADCSRB = 0;
+    ADMUX = _BV(REFS0) | (ch & 0x07); SBI(ADCSRA, ADSC);
+  }
+
+  // Is the ADC ready for reading?
+  static inline bool adc_ready() { return !TEST(ADCSRA, ADSC); }
+
+  // The current value of the ADC register
+  static inline __typeof__(ADC) adc_value() { return ADC; }
+
+  /**
+   * Set the PWM duty cycle for the pin to the given value.
+   * Optionally invert the duty cycle [default = false]
+   * Optionally change the scale of the provided value to enable finer PWM duty control [default = 255]
+   */
+  static void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size=255, const bool invert=false);
+
+  /**
+   * Set the frequency of the timer for the given pin as close as
+   * possible to the provided desired frequency. Internally calculate
+   * the required waveform generation mode, prescaler, and resolution
+   * values and set timer registers accordingly.
+   * NOTE that the frequency is applied to all pins on the timer (Ex OC3A, OC3B and OC3B)
+   * NOTE that there are limitations, particularly if using TIMER2. (see Configuration_adv.h -> FAST FAN PWM Settings)
+   */
+  static void set_pwm_frequency(const pin_t pin, int f_desired);
+};
+
+extern MarlinHAL hal;

commit f53d627750ab0cf377ea1738bdcf792f2ef37de9
Author: Skruppy <skruppy@onmars.eu>
Date:   Thu Nov 4 18:11:57 2021 +0100

    üêõ Prevent AVR watchdogpile (#23075)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index ad1f47a4e6..2217f239d6 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -91,7 +91,7 @@ typedef int8_t pin_t;
 // Public Variables
 // ------------------------
 
-//extern uint8_t MCUSR;
+extern uint8_t reset_reason;
 
 // Serial ports
 #ifdef USBCON
@@ -152,8 +152,8 @@ void HAL_init();
 
 //void _delay_ms(const int delay);
 
-inline void HAL_clear_reset_source() { MCUSR = 0; }
-inline uint8_t HAL_get_reset_source() { return MCUSR; }
+inline void HAL_clear_reset_source() { }
+inline uint8_t HAL_get_reset_source() { return reset_reason; }
 
 void HAL_reboot();
 

commit da830e6ced7f7c7e509e748104245064d1c1b265
Author: Andrei M <22990561+andrei-moraru@users.noreply.github.com>
Date:   Tue Nov 2 01:47:16 2021 -0400

    ‚öóÔ∏è Use pwm_set_duty over analogWrite to set PWM (#23048)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index ecb566ed46..ad1f47a4e6 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -221,7 +221,7 @@ void set_pwm_frequency(const pin_t pin, int f_desired);
 
 /**
  * set_pwm_duty
- *  Sets the PWM duty cycle of the provided pin to the provided value
+ *  Set the PWM duty cycle of the provided pin to the provided value
  *  Optionally allows inverting the duty cycle [default = false]
  *  Optionally allows changing the maximum size of the provided value to enable finer PWM duty control [default = 255]
  */

commit 1f3f9cb68ce9c9adad55a98ccea07e491d7b9785
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 19 05:52:41 2021 -0500

    üé® Pragma GCC cleanup

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index a22daf9b5c..ecb566ed46 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -157,16 +157,14 @@ inline uint8_t HAL_get_reset_source() { return MCUSR; }
 
 void HAL_reboot();
 
+#pragma GCC diagnostic push
 #if GCC_VERSION <= 50000
-  #pragma GCC diagnostic push
   #pragma GCC diagnostic ignored "-Wunused-function"
 #endif
 
 extern "C" int freeMemory();
 
-#if GCC_VERSION <= 50000
-  #pragma GCC diagnostic pop
-#endif
+#pragma GCC diagnostic pop
 
 // ADC
 #ifdef DIDR2

commit c881fab1280f338e32015e1556890d647ee967fb
Author: dotdash32 <dotdash32@gmail.com>
Date:   Sun Sep 5 17:21:25 2021 -0700

    üé® Use largest default ST9720 delays (#22713)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index dc0a4f2074..a22daf9b5c 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -43,13 +43,13 @@
 // Default graphical display delays
 //
 #if F_CPU >= 20000000
-  #define CPU_ST7920_DELAY_1 DELAY_NS(150)
-  #define CPU_ST7920_DELAY_2 DELAY_NS(  0)
-  #define CPU_ST7920_DELAY_3 DELAY_NS(150)
+  #define CPU_ST7920_DELAY_1 150
+  #define CPU_ST7920_DELAY_2   0
+  #define CPU_ST7920_DELAY_3 150
 #elif F_CPU == 16000000
-  #define CPU_ST7920_DELAY_1 DELAY_NS(125)
-  #define CPU_ST7920_DELAY_2 DELAY_NS(  0)
-  #define CPU_ST7920_DELAY_3 DELAY_NS(188)
+  #define CPU_ST7920_DELAY_1 125
+  #define CPU_ST7920_DELAY_2   0
+  #define CPU_ST7920_DELAY_3 188
 #endif
 
 #ifndef pgm_read_ptr

commit d818a019c5d80e8b2238f0ea8311ad53154be4ec
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 28 15:27:52 2021 -0500

    üé® EXP headers, ST7920 delays (#22641)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index a5896a0e97..dc0a4f2074 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -39,6 +39,19 @@
 #include <avr/interrupt.h>
 #include <avr/io.h>
 
+//
+// Default graphical display delays
+//
+#if F_CPU >= 20000000
+  #define CPU_ST7920_DELAY_1 DELAY_NS(150)
+  #define CPU_ST7920_DELAY_2 DELAY_NS(  0)
+  #define CPU_ST7920_DELAY_3 DELAY_NS(150)
+#elif F_CPU == 16000000
+  #define CPU_ST7920_DELAY_1 DELAY_NS(125)
+  #define CPU_ST7920_DELAY_2 DELAY_NS(  0)
+  #define CPU_ST7920_DELAY_3 DELAY_NS(188)
+#endif
+
 #ifndef pgm_read_ptr
   // Compatibility for avr-libc 1.8.0-4.1 included with Ubuntu for
   // Windows Subsystem for Linux on Windows 10 as of 10/18/2019

commit 77496c8235dab5182312652b4dc0b6d0f182cf30
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 8 19:55:27 2021 -0500

    ‚ö°Ô∏è Optimize Sensitive Pins array (except STM32) (#22080)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index e24b923ef0..a5896a0e97 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -186,7 +186,7 @@ inline void HAL_adc_init() {
 #define GET_PIN_MAP_INDEX(pin) pin
 #define PARSED_PIN_INDEX(code, dval) parser.intval(code, dval)
 
-#define HAL_SENSITIVE_PINS 0, 1
+#define HAL_SENSITIVE_PINS 0, 1,
 
 #ifdef __AVR_AT90USB1286__
   #define JTAG_DISABLE() do{ MCUCR = 0x80; MCUCR = 0x80; }while(0)

commit 02405add76e722701ab49434549e7d8bf5690162
Author: ellensp <ellensp@hotmail.com>
Date:   Fri May 7 17:31:45 2021 +1200

    Support a third serial port (#21784)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 64e4f764dc..e24b923ef0 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -103,6 +103,13 @@ typedef int8_t pin_t;
     #endif
     #define MYSERIAL2 customizedSerial2
   #endif
+
+  #ifdef SERIAL_PORT_3
+    #if !WITHIN(SERIAL_PORT_3, -1, 3)
+      #error "SERIAL_PORT_3 must be from 0 to 3, or -1 for USB Serial."
+    #endif
+    #define MYSERIAL3 customizedSerial3
+  #endif
 #endif
 
 #ifdef MMU2_SERIAL_PORT

commit be6fbc76a1ab1618421315958480f6a1d6093533
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 6 22:39:34 2021 -0500

    Serial and pins debug cleanup
    
    - Rename some AVR / DUE / ESP32 serial types
    - Reduce two #error to one static_assert
    - Update AVR/DUE error messages

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 7adf1aad49..64e4f764dc 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -93,13 +93,13 @@ typedef int8_t pin_t;
   #define MYSERIAL1 TERN(BLUETOOTH, btSerial, MSerial0)
 #else
   #if !WITHIN(SERIAL_PORT, -1, 3)
-    #error "SERIAL_PORT must be from 0 to 3. You can also use -1 if the board supports Native USB."
+    #error "SERIAL_PORT must be from 0 to 3, or -1 for USB Serial."
   #endif
   #define MYSERIAL1 customizedSerial1
 
   #ifdef SERIAL_PORT_2
     #if !WITHIN(SERIAL_PORT_2, -1, 3)
-      #error "SERIAL_PORT_2 must be from 0 to 3. You can also use -1 if the board supports Native USB."
+      #error "SERIAL_PORT_2 must be from 0 to 3, or -1 for USB Serial."
     #endif
     #define MYSERIAL2 customizedSerial2
   #endif
@@ -107,14 +107,14 @@ typedef int8_t pin_t;
 
 #ifdef MMU2_SERIAL_PORT
   #if !WITHIN(MMU2_SERIAL_PORT, -1, 3)
-    #error "MMU2_SERIAL_PORT must be from 0 to 3. You can also use -1 if the board supports Native USB."
+    #error "MMU2_SERIAL_PORT must be from 0 to 3, or -1 for USB Serial."
   #endif
   #define MMU2_SERIAL mmuSerial
 #endif
 
 #ifdef LCD_SERIAL_PORT
   #if !WITHIN(LCD_SERIAL_PORT, -1, 3)
-    #error "LCD_SERIAL_PORT must be from 0 to 3. You can also use -1 if the board supports Native USB."
+    #error "LCD_SERIAL_PORT must be from 0 to 3, or -1 for USB Serial."
   #endif
   #define LCD_SERIAL lcdSerial
   #if HAS_DGUS_LCD

commit d3a2c6a0b47fba8f560ff9ea60e73eb2610ff527
Author: fedetony <45215920+fedetony@users.noreply.github.com>
Date:   Sat Apr 24 09:53:52 2021 +0200

    Soft Reset via Serial or post-kill button click (#21652)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 890798a719..7adf1aad49 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -135,7 +135,7 @@ void HAL_init();
 inline void HAL_clear_reset_source() { MCUSR = 0; }
 inline uint8_t HAL_get_reset_source() { return MCUSR; }
 
-inline void HAL_reboot() {}  // reboot the board or restart the bootloader
+void HAL_reboot();
 
 #if GCC_VERSION <= 50000
   #pragma GCC diagnostic push

commit 550a806d77201e9a228efd587a92af4adaf648b7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 18 18:24:08 2021 -0500

    More detailed serial config error

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index f6adf1bd31..890798a719 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -93,13 +93,13 @@ typedef int8_t pin_t;
   #define MYSERIAL1 TERN(BLUETOOTH, btSerial, MSerial0)
 #else
   #if !WITHIN(SERIAL_PORT, -1, 3)
-    #error "SERIAL_PORT must be from -1 to 3. Please update your configuration."
+    #error "SERIAL_PORT must be from 0 to 3. You can also use -1 if the board supports Native USB."
   #endif
   #define MYSERIAL1 customizedSerial1
 
   #ifdef SERIAL_PORT_2
     #if !WITHIN(SERIAL_PORT_2, -1, 3)
-      #error "SERIAL_PORT_2 must be from -1 to 3. Please update your configuration."
+      #error "SERIAL_PORT_2 must be from 0 to 3. You can also use -1 if the board supports Native USB."
     #endif
     #define MYSERIAL2 customizedSerial2
   #endif
@@ -107,14 +107,14 @@ typedef int8_t pin_t;
 
 #ifdef MMU2_SERIAL_PORT
   #if !WITHIN(MMU2_SERIAL_PORT, -1, 3)
-    #error "MMU2_SERIAL_PORT must be from -1 to 3. Please update your configuration."
+    #error "MMU2_SERIAL_PORT must be from 0 to 3. You can also use -1 if the board supports Native USB."
   #endif
   #define MMU2_SERIAL mmuSerial
 #endif
 
 #ifdef LCD_SERIAL_PORT
   #if !WITHIN(LCD_SERIAL_PORT, -1, 3)
-    #error "LCD_SERIAL_PORT must be from -1 to 3. Please update your configuration."
+    #error "LCD_SERIAL_PORT must be from 0 to 3. You can also use -1 if the board supports Native USB."
   #endif
   #define LCD_SERIAL lcdSerial
   #if HAS_DGUS_LCD

commit dbd28eecc9cd4b5954a4fd1ed0c02bd9788c279b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 10 12:05:05 2021 -0600

    Number serial from 1 to match settings

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 5e22ac0836..f6adf1bd31 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -83,25 +83,25 @@ typedef int8_t pin_t;
 // Serial ports
 #ifdef USBCON
   #include "../../core/serial_hook.h"
-  typedef ForwardSerial0Type< decltype(Serial) > DefaultSerial;
-  extern DefaultSerial MSerial;
+  typedef ForwardSerial1Class< decltype(Serial) > DefaultSerial1;
+  extern DefaultSerial1 MSerial0;
   #ifdef BLUETOOTH
-    typedef ForwardSerial0Type< decltype(bluetoothSerial) > BTSerial;
+    typedef ForwardSerial1Class< decltype(bluetoothSerial) > BTSerial;
     extern BTSerial btSerial;
   #endif
 
-  #define MYSERIAL0 TERN(BLUETOOTH, btSerial, MSerial)
+  #define MYSERIAL1 TERN(BLUETOOTH, btSerial, MSerial0)
 #else
   #if !WITHIN(SERIAL_PORT, -1, 3)
     #error "SERIAL_PORT must be from -1 to 3. Please update your configuration."
   #endif
-  #define MYSERIAL0 customizedSerial1
+  #define MYSERIAL1 customizedSerial1
 
   #ifdef SERIAL_PORT_2
     #if !WITHIN(SERIAL_PORT_2, -1, 3)
       #error "SERIAL_PORT_2 must be from -1 to 3. Please update your configuration."
     #endif
-    #define MYSERIAL1 customizedSerial2
+    #define MYSERIAL2 customizedSerial2
   #endif
 #endif
 

commit c74f972627ab8dcf69a637268cf86682959bd18e
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 1 01:18:39 2021 +0100

    LVGL UI G-code console (#20755)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 2b565bbe13..5e22ac0836 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -82,14 +82,14 @@ typedef int8_t pin_t;
 
 // Serial ports
 #ifdef USBCON
-  #include "../../core/serial_hook.h" 
+  #include "../../core/serial_hook.h"
   typedef ForwardSerial0Type< decltype(Serial) > DefaultSerial;
   extern DefaultSerial MSerial;
   #ifdef BLUETOOTH
     typedef ForwardSerial0Type< decltype(bluetoothSerial) > BTSerial;
     extern BTSerial btSerial;
   #endif
-  
+
   #define MYSERIAL0 TERN(BLUETOOTH, btSerial, MSerial)
 #else
   #if !WITHIN(SERIAL_PORT, -1, 3)

commit 3f01b222b2b4f77cff66096dd5a18a64828e1fa4
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Thu Jan 28 09:02:06 2021 +0100

    Refactor serial class with templates (#20783)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 8b95acb0ac..2b565bbe13 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -82,7 +82,15 @@ typedef int8_t pin_t;
 
 // Serial ports
 #ifdef USBCON
-  #define MYSERIAL0 TERN(BLUETOOTH, bluetoothSerial, Serial)
+  #include "../../core/serial_hook.h" 
+  typedef ForwardSerial0Type< decltype(Serial) > DefaultSerial;
+  extern DefaultSerial MSerial;
+  #ifdef BLUETOOTH
+    typedef ForwardSerial0Type< decltype(bluetoothSerial) > BTSerial;
+    extern BTSerial btSerial;
+  #endif
+  
+  #define MYSERIAL0 TERN(BLUETOOTH, btSerial, MSerial)
 #else
   #if !WITHIN(SERIAL_PORT, -1, 3)
     #error "SERIAL_PORT must be from -1 to 3. Please update your configuration."

commit 1d5862a39b07f0a59039109c4121ef504ee2b2c3
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sat Jan 16 03:38:34 2021 +0100

    MMU2 as standard serial device (#20771)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index aa6a321320..8b95acb0ac 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -97,6 +97,13 @@ typedef int8_t pin_t;
   #endif
 #endif
 
+#ifdef MMU2_SERIAL_PORT
+  #if !WITHIN(MMU2_SERIAL_PORT, -1, 3)
+    #error "MMU2_SERIAL_PORT must be from -1 to 3. Please update your configuration."
+  #endif
+  #define MMU2_SERIAL mmuSerial
+#endif
+
 #ifdef LCD_SERIAL_PORT
   #if !WITHIN(LCD_SERIAL_PORT, -1, 3)
     #error "LCD_SERIAL_PORT must be from -1 to 3. Please update your configuration."

commit 18853defdd2189ee595c6f8c2e4d8a16e41f9ce1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 25 21:40:56 2020 -0600

    Reduce warnings, extern "C" cleanup (#20279)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index ce15ed29fb..aa6a321320 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -122,12 +122,16 @@ inline uint8_t HAL_get_reset_source() { return MCUSR; }
 
 inline void HAL_reboot() {}  // reboot the board or restart the bootloader
 
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wunused-function"
-extern "C" {
-  int freeMemory();
-}
-#pragma GCC diagnostic pop
+#if GCC_VERSION <= 50000
+  #pragma GCC diagnostic push
+  #pragma GCC diagnostic ignored "-Wunused-function"
+#endif
+
+extern "C" int freeMemory();
+
+#if GCC_VERSION <= 50000
+  #pragma GCC diagnostic pop
+#endif
 
 // ADC
 #ifdef DIDR2

commit 90d364fc37de5880582aec9537da11f4b125d660
Author: Jason Smith <jason.inet@gmail.com>
Date:   Wed Oct 14 11:48:46 2020 -0700

    Revert at90usb1286 conditional (#19733)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 6e0afa8f10..ce15ed29fb 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -25,7 +25,7 @@
 #include "watchdog.h"
 #include "math.h"
 
-#ifdef IS_AT90USB
+#ifdef USBCON
   #include <HardwareSerial.h>
 #else
   #define HardwareSerial_h // Hack to prevent HardwareSerial.h header inclusion
@@ -81,7 +81,7 @@ typedef int8_t pin_t;
 //extern uint8_t MCUSR;
 
 // Serial ports
-#ifdef IS_AT90USB
+#ifdef USBCON
   #define MYSERIAL0 TERN(BLUETOOTH, bluetoothSerial, Serial)
 #else
   #if !WITHIN(SERIAL_PORT, -1, 3)

commit 45731bd0221beee768e009195ee3aa9a0b0f2a88
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Oct 11 16:13:01 2020 -0700

    Fix at90usb1286 build (#19687)
    
    * Skip check for USBCON during dependency detection
    * Ignore incompatible Teensy_ADC library, which requires Teensy >= 3
    * Add IS_AT90USB
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index ce15ed29fb..6e0afa8f10 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -25,7 +25,7 @@
 #include "watchdog.h"
 #include "math.h"
 
-#ifdef USBCON
+#ifdef IS_AT90USB
   #include <HardwareSerial.h>
 #else
   #define HardwareSerial_h // Hack to prevent HardwareSerial.h header inclusion
@@ -81,7 +81,7 @@ typedef int8_t pin_t;
 //extern uint8_t MCUSR;
 
 // Serial ports
-#ifdef USBCON
+#ifdef IS_AT90USB
   #define MYSERIAL0 TERN(BLUETOOTH, bluetoothSerial, Serial)
 #else
   #if !WITHIN(SERIAL_PORT, -1, 3)

commit 631457ffea46debd43079137e09bc2d36b5d4fe4
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Oct 9 08:25:23 2020 -0300

    Support for Debug Codes - Dnnn (#19225)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index b606d0c231..ce15ed29fb 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -120,6 +120,8 @@ void HAL_init();
 inline void HAL_clear_reset_source() { MCUSR = 0; }
 inline uint8_t HAL_get_reset_source() { return MCUSR; }
 
+inline void HAL_reboot() {}  // reboot the board or restart the bootloader
+
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wunused-function"
 extern "C" {

commit 4424645e04c9e75462d36de8f7a82e67cc9c262e
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Mon Sep 28 21:53:50 2020 +0200

    Multi-line comments cleanup (#19535)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 41f1acd32f..b606d0c231 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -15,6 +15,7 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
  */
 #pragma once
 

commit da6c8317a7e7483fcb823c06f9cf953a764eacb0
Author: Jason Smith <jason.inet@gmail.com>
Date:   Thu Sep 24 18:28:48 2020 -0700

    Fix and improve STM32F1 serial (#19464)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index af7e142679..41f1acd32f 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -96,19 +96,14 @@ typedef int8_t pin_t;
   #endif
 #endif
 
-#ifdef DGUS_SERIAL_PORT
-  #if !WITHIN(DGUS_SERIAL_PORT, -1, 3)
-    #error "DGUS_SERIAL_PORT must be from -1 to 3. Please update your configuration."
+#ifdef LCD_SERIAL_PORT
+  #if !WITHIN(LCD_SERIAL_PORT, -1, 3)
+    #error "LCD_SERIAL_PORT must be from -1 to 3. Please update your configuration."
   #endif
-  #define DGUS_SERIAL internalDgusSerial
-  #define DGUS_SERIAL_GET_TX_BUFFER_FREE DGUS_SERIAL.get_tx_buffer_free
-#endif
-
-#ifdef ANYCUBIC_LCD_SERIAL_PORT
-  #if !WITHIN(ANYCUBIC_LCD_SERIAL_PORT, -1, 3)
-    #error "ANYCUBIC_LCD_SERIAL_PORT must be from -1 to 3. Please update your configuration."
+  #define LCD_SERIAL lcdSerial
+  #if HAS_DGUS_LCD
+    #define SERIAL_GET_TX_BUFFER_FREE() LCD_SERIAL.get_tx_buffer_free()
   #endif
-  #define ANYCUBIC_LCD_SERIAL anycubicLcdSerial
 #endif
 
 // ------------------------

commit 568f292883d422bdd226d7faf2d2eba16a4a0ed9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Sep 23 21:36:31 2020 -0500

    HAL/serial followup

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index fcaaf75c4a..af7e142679 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -86,7 +86,6 @@ typedef int8_t pin_t;
   #if !WITHIN(SERIAL_PORT, -1, 3)
     #error "SERIAL_PORT must be from -1 to 3. Please update your configuration."
   #endif
-
   #define MYSERIAL0 customizedSerial1
 
   #ifdef SERIAL_PORT_2

commit 4b928b2da8ae26bd4a949debe470a914e23545ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Sep 23 19:45:33 2020 -0500

    HAL and serial cleanup
    
    Co-Authored-By: Jason Smith <20053467+sjasonsmith@users.noreply.github.com>

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 609375e386..fcaaf75c4a 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -81,12 +81,7 @@ typedef int8_t pin_t;
 
 // Serial ports
 #ifdef USBCON
-  #if ENABLED(BLUETOOTH)
-    #define MYSERIAL0 bluetoothSerial
-  #else
-    #define MYSERIAL0 Serial
-  #endif
-  #define NUM_SERIAL 1
+  #define MYSERIAL0 TERN(BLUETOOTH, bluetoothSerial, Serial)
 #else
   #if !WITHIN(SERIAL_PORT, -1, 3)
     #error "SERIAL_PORT must be from -1 to 3. Please update your configuration."
@@ -97,36 +92,22 @@ typedef int8_t pin_t;
   #ifdef SERIAL_PORT_2
     #if !WITHIN(SERIAL_PORT_2, -1, 3)
       #error "SERIAL_PORT_2 must be from -1 to 3. Please update your configuration."
-    #elif SERIAL_PORT_2 == SERIAL_PORT
-      #error "SERIAL_PORT_2 must be different than SERIAL_PORT. Please update your configuration."
     #endif
     #define MYSERIAL1 customizedSerial2
-    #define NUM_SERIAL 2
-  #else
-    #define NUM_SERIAL 1
   #endif
 #endif
 
 #ifdef DGUS_SERIAL_PORT
   #if !WITHIN(DGUS_SERIAL_PORT, -1, 3)
     #error "DGUS_SERIAL_PORT must be from -1 to 3. Please update your configuration."
-  #elif DGUS_SERIAL_PORT == SERIAL_PORT
-    #error "DGUS_SERIAL_PORT must be different than SERIAL_PORT. Please update your configuration."
-  #elif defined(SERIAL_PORT_2) && DGUS_SERIAL_PORT == SERIAL_PORT_2
-    #error "DGUS_SERIAL_PORT must be different than SERIAL_PORT_2. Please update your configuration."
   #endif
   #define DGUS_SERIAL internalDgusSerial
-
   #define DGUS_SERIAL_GET_TX_BUFFER_FREE DGUS_SERIAL.get_tx_buffer_free
 #endif
 
 #ifdef ANYCUBIC_LCD_SERIAL_PORT
   #if !WITHIN(ANYCUBIC_LCD_SERIAL_PORT, -1, 3)
     #error "ANYCUBIC_LCD_SERIAL_PORT must be from -1 to 3. Please update your configuration."
-  #elif ANYCUBIC_LCD_SERIAL_PORT == SERIAL_PORT
-    #error "ANYCUBIC_LCD_SERIAL_PORT must be different than SERIAL_PORT. Please update your configuration."
-  #elif defined(SERIAL_PORT_2) && ANYCUBIC_LCD_SERIAL_PORT == SERIAL_PORT_2
-    #error "ANYCUBIC_LCD_SERIAL_PORT must be different than SERIAL_PORT_2. Please update your configuration."
   #endif
   #define ANYCUBIC_LCD_SERIAL anycubicLcdSerial
 #endif

commit 6bcfb58cd4b208cf042fa4a66faf14f382d33d07
Author: Marco Burato <zmaster.adsl@gmail.com>
Date:   Thu Aug 6 12:38:18 2020 +0200

    More Anycubic + Trigorilla mappings, ExtUI (#18903)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index b0e0674c73..609375e386 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -120,6 +120,17 @@ typedef int8_t pin_t;
   #define DGUS_SERIAL_GET_TX_BUFFER_FREE DGUS_SERIAL.get_tx_buffer_free
 #endif
 
+#ifdef ANYCUBIC_LCD_SERIAL_PORT
+  #if !WITHIN(ANYCUBIC_LCD_SERIAL_PORT, -1, 3)
+    #error "ANYCUBIC_LCD_SERIAL_PORT must be from -1 to 3. Please update your configuration."
+  #elif ANYCUBIC_LCD_SERIAL_PORT == SERIAL_PORT
+    #error "ANYCUBIC_LCD_SERIAL_PORT must be different than SERIAL_PORT. Please update your configuration."
+  #elif defined(SERIAL_PORT_2) && ANYCUBIC_LCD_SERIAL_PORT == SERIAL_PORT_2
+    #error "ANYCUBIC_LCD_SERIAL_PORT must be different than SERIAL_PORT_2. Please update your configuration."
+  #endif
+  #define ANYCUBIC_LCD_SERIAL anycubicLcdSerial
+#endif
+
 // ------------------------
 // Public functions
 // ------------------------

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 63cb3949aa..b0e0674c73 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -14,7 +14,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  */
 #pragma once
 

commit 424569b4c4bf112a3939724b30bad528a76a2b08
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 18 15:23:03 2020 -0500

    Power monitor and display (#17437)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index b7e05a956d..63cb3949aa 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -162,6 +162,7 @@ inline void HAL_adc_init() {
   #define HAL_START_ADC(ch) ADCSRB = 0; SET_ADMUX_ADCSRA(ch)
 #endif
 
+#define HAL_ADC_VREF        5.0
 #define HAL_ADC_RESOLUTION 10
 #define HAL_READ_ADC()  ADC
 #define HAL_ADC_READY() !TEST(ADCSRA, ADSC)

commit 33d1e77e2e252f3a3825941630718ea7d8f67451
Author: ellensp <ellensp@hotmail.com>
Date:   Tue Jun 2 11:33:30 2020 +1200

    Allow pins override of *_TIMER_NUM and HAL_*_TIMER_ISR (#18128)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index e96193651b..b7e05a956d 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -68,9 +68,6 @@
 // Types
 // ------------------------
 
-typedef uint16_t hal_timer_t;
-#define HAL_TIMER_TYPE_MAX 0xFFFF
-
 typedef int8_t pin_t;
 
 #define SHARED_SERVOS HAS_SERVOS
@@ -143,220 +140,6 @@ extern "C" {
 }
 #pragma GCC diagnostic pop
 
-// timers
-#define HAL_TIMER_RATE          ((F_CPU) / 8)    // i.e., 2MHz or 2.5MHz
-
-#define STEP_TIMER_NUM          1
-#define TEMP_TIMER_NUM          0
-#define PULSE_TIMER_NUM         STEP_TIMER_NUM
-
-#define TEMP_TIMER_FREQUENCY    ((F_CPU) / 64.0 / 256.0)
-
-#define STEPPER_TIMER_RATE      HAL_TIMER_RATE
-#define STEPPER_TIMER_PRESCALE  8
-#define STEPPER_TIMER_TICKS_PER_US ((STEPPER_TIMER_RATE) / 1000000) // Cannot be of type double
-
-#define PULSE_TIMER_RATE       STEPPER_TIMER_RATE   // frequency of pulse timer
-#define PULSE_TIMER_PRESCALE   STEPPER_TIMER_PRESCALE
-#define PULSE_TIMER_TICKS_PER_US STEPPER_TIMER_TICKS_PER_US
-
-#define ENABLE_STEPPER_DRIVER_INTERRUPT()  SBI(TIMSK1, OCIE1A)
-#define DISABLE_STEPPER_DRIVER_INTERRUPT() CBI(TIMSK1, OCIE1A)
-#define STEPPER_ISR_ENABLED()             TEST(TIMSK1, OCIE1A)
-
-#define ENABLE_TEMPERATURE_INTERRUPT()     SBI(TIMSK0, OCIE0B)
-#define DISABLE_TEMPERATURE_INTERRUPT()    CBI(TIMSK0, OCIE0B)
-#define TEMPERATURE_ISR_ENABLED()         TEST(TIMSK0, OCIE0B)
-
-FORCE_INLINE void HAL_timer_start(const uint8_t timer_num, const uint32_t) {
-  switch (timer_num) {
-    case STEP_TIMER_NUM:
-      // waveform generation = 0100 = CTC
-      SET_WGM(1, CTC_OCRnA);
-
-      // output mode = 00 (disconnected)
-      SET_COMA(1, NORMAL);
-
-      // Set the timer pre-scaler
-      // Generally we use a divider of 8, resulting in a 2MHz timer
-      // frequency on a 16MHz MCU. If you are going to change this, be
-      // sure to regenerate speed_lookuptable.h with
-      // create_speed_lookuptable.py
-      SET_CS(1, PRESCALER_8);  //  CS 2 = 1/8 prescaler
-
-      // Init Stepper ISR to 122 Hz for quick starting
-      // (F_CPU) / (STEPPER_TIMER_PRESCALE) / frequency
-      OCR1A = 0x4000;
-      TCNT1 = 0;
-      break;
-
-    case TEMP_TIMER_NUM:
-      // Use timer0 for temperature measurement
-      // Interleave temperature interrupt with millies interrupt
-      OCR0B = 128;
-      break;
-  }
-}
-
-#define TIMER_OCR_1             OCR1A
-#define TIMER_COUNTER_1         TCNT1
-
-#define TIMER_OCR_0             OCR0A
-#define TIMER_COUNTER_0         TCNT0
-
-#define _CAT(a,V...) a##V
-#define HAL_timer_set_compare(timer, compare) (_CAT(TIMER_OCR_, timer) = compare)
-#define HAL_timer_get_compare(timer) _CAT(TIMER_OCR_, timer)
-#define HAL_timer_get_count(timer) _CAT(TIMER_COUNTER_, timer)
-
-/**
- * On AVR there is no hardware prioritization and preemption of
- * interrupts, so this emulates it. The UART has first priority
- * (otherwise, characters will be lost due to UART overflow).
- * Then: Stepper, Endstops, Temperature, and -finally- all others.
- */
-#define HAL_timer_isr_prologue(TIMER_NUM)
-#define HAL_timer_isr_epilogue(TIMER_NUM)
-
-/* 18 cycles maximum latency */
-#define HAL_STEP_TIMER_ISR() \
-extern "C" void TIMER1_COMPA_vect() __attribute__ ((signal, naked, used, externally_visible)); \
-extern "C" void TIMER1_COMPA_vect_bottom() asm ("TIMER1_COMPA_vect_bottom") __attribute__ ((used, externally_visible, noinline)); \
-void TIMER1_COMPA_vect() { \
-  __asm__ __volatile__ ( \
-    A("push r16")                      /* 2 Save R16 */ \
-    A("in r16, __SREG__")              /* 1 Get SREG */ \
-    A("push r16")                      /* 2 Save SREG into stack */ \
-    A("lds r16, %[timsk0]")            /* 2 Load into R0 the Temperature timer Interrupt mask register */ \
-    A("push r16")                      /* 2 Save TIMSK0 into the stack */ \
-    A("andi r16,~%[msk0]")             /* 1 Disable the temperature ISR */ \
-    A("sts %[timsk0], r16")            /* 2 And set the new value */ \
-    A("lds r16, %[timsk1]")            /* 2 Load into R0 the stepper timer Interrupt mask register [TIMSK1] */ \
-    A("andi r16,~%[msk1]")             /* 1 Disable the stepper ISR */ \
-    A("sts %[timsk1], r16")            /* 2 And set the new value */ \
-    A("push r16")                      /* 2 Save TIMSK1 into stack */ \
-    A("in r16, 0x3B")                  /* 1 Get RAMPZ register */ \
-    A("push r16")                      /* 2 Save RAMPZ into stack */ \
-    A("in r16, 0x3C")                  /* 1 Get EIND register */ \
-    A("push r0")                       /* C runtime can modify all the following registers without restoring them */ \
-    A("push r1")                       \
-    A("push r18")                      \
-    A("push r19")                      \
-    A("push r20")                      \
-    A("push r21")                      \
-    A("push r22")                      \
-    A("push r23")                      \
-    A("push r24")                      \
-    A("push r25")                      \
-    A("push r26")                      \
-    A("push r27")                      \
-    A("push r30")                      \
-    A("push r31")                      \
-    A("clr r1")                        /* C runtime expects this register to be 0 */ \
-    A("call TIMER1_COMPA_vect_bottom") /* Call the bottom handler - No inlining allowed, otherwise registers used are not saved */   \
-    A("pop r31")                       \
-    A("pop r30")                       \
-    A("pop r27")                       \
-    A("pop r26")                       \
-    A("pop r25")                       \
-    A("pop r24")                       \
-    A("pop r23")                       \
-    A("pop r22")                       \
-    A("pop r21")                       \
-    A("pop r20")                       \
-    A("pop r19")                       \
-    A("pop r18")                       \
-    A("pop r1")                        \
-    A("pop r0")                        \
-    A("out 0x3C, r16")                 /* 1 Restore EIND register */ \
-    A("pop r16")                       /* 2 Get the original RAMPZ register value */ \
-    A("out 0x3B, r16")                 /* 1 Restore RAMPZ register to its original value */ \
-    A("pop r16")                       /* 2 Get the original TIMSK1 value but with stepper ISR disabled */ \
-    A("ori r16,%[msk1]")               /* 1 Reenable the stepper ISR */ \
-    A("cli")                           /* 1 Disable global interrupts - Reenabling Stepper ISR can reenter amd temperature can reenter, and we want that, if it happens, after this ISR has ended */ \
-    A("sts %[timsk1], r16")            /* 2 And restore the old value - This reenables the stepper ISR */ \
-    A("pop r16")                       /* 2 Get the temperature timer Interrupt mask register [TIMSK0] */ \
-    A("sts %[timsk0], r16")            /* 2 And restore the old value - This reenables the temperature ISR */ \
-    A("pop r16")                       /* 2 Get the old SREG value */ \
-    A("out __SREG__, r16")             /* 1 And restore the SREG value */ \
-    A("pop r16")                       /* 2 Restore R16 value */ \
-    A("reti")                          /* 4 Return from interrupt */ \
-    :                                   \
-    : [timsk0] "i" ((uint16_t)&TIMSK0), \
-      [timsk1] "i" ((uint16_t)&TIMSK1), \
-      [msk0] "M" ((uint8_t)(1<<OCIE0B)),\
-      [msk1] "M" ((uint8_t)(1<<OCIE1A)) \
-    : \
-  ); \
-} \
-void TIMER1_COMPA_vect_bottom()
-
-/* 14 cycles maximum latency */
-#define HAL_TEMP_TIMER_ISR() \
-extern "C" void TIMER0_COMPB_vect() __attribute__ ((signal, naked, used, externally_visible)); \
-extern "C" void TIMER0_COMPB_vect_bottom()  asm ("TIMER0_COMPB_vect_bottom") __attribute__ ((used, externally_visible, noinline)); \
-void TIMER0_COMPB_vect() { \
-  __asm__ __volatile__ ( \
-    A("push r16")                       /* 2 Save R16 */ \
-    A("in r16, __SREG__")               /* 1 Get SREG */ \
-    A("push r16")                       /* 2 Save SREG into stack */ \
-    A("lds r16, %[timsk0]")             /* 2 Load into R0 the Temperature timer Interrupt mask register */ \
-    A("andi r16,~%[msk0]")              /* 1 Disable the temperature ISR */ \
-    A("sts %[timsk0], r16")             /* 2 And set the new value */ \
-    A("sei")                            /* 1 Enable global interrupts - It is safe, as the temperature ISR is disabled, so we cannot reenter it */    \
-    A("push r16")                       /* 2 Save TIMSK0 into stack */ \
-    A("in r16, 0x3B")                   /* 1 Get RAMPZ register */ \
-    A("push r16")                       /* 2 Save RAMPZ into stack */ \
-    A("in r16, 0x3C")                   /* 1 Get EIND register */ \
-    A("push r0")                        /* C runtime can modify all the following registers without restoring them */ \
-    A("push r1")                        \
-    A("push r18")                       \
-    A("push r19")                       \
-    A("push r20")                       \
-    A("push r21")                       \
-    A("push r22")                       \
-    A("push r23")                       \
-    A("push r24")                       \
-    A("push r25")                       \
-    A("push r26")                       \
-    A("push r27")                       \
-    A("push r30")                       \
-    A("push r31")                       \
-    A("clr r1")                         /* C runtime expects this register to be 0 */ \
-    A("call TIMER0_COMPB_vect_bottom")  /* Call the bottom handler - No inlining allowed, otherwise registers used are not saved */   \
-    A("pop r31")                        \
-    A("pop r30")                        \
-    A("pop r27")                        \
-    A("pop r26")                        \
-    A("pop r25")                        \
-    A("pop r24")                        \
-    A("pop r23")                        \
-    A("pop r22")                        \
-    A("pop r21")                        \
-    A("pop r20")                        \
-    A("pop r19")                        \
-    A("pop r18")                        \
-    A("pop r1")                         \
-    A("pop r0")                         \
-    A("out 0x3C, r16")                  /* 1 Restore EIND register */ \
-    A("pop r16")                        /* 2 Get the original RAMPZ register value */ \
-    A("out 0x3B, r16")                  /* 1 Restore RAMPZ register to its original value */ \
-    A("pop r16")                        /* 2 Get the original TIMSK0 value but with temperature ISR disabled */ \
-    A("ori r16,%[msk0]")                /* 1 Enable temperature ISR */ \
-    A("cli")                            /* 1 Disable global interrupts - We must do this, as we will reenable the temperature ISR, and we don't want to reenter this handler until the current one is done */ \
-    A("sts %[timsk0], r16")             /* 2 And restore the old value */ \
-    A("pop r16")                        /* 2 Get the old SREG */ \
-    A("out __SREG__, r16")              /* 1 And restore the SREG value */ \
-    A("pop r16")                        /* 2 Restore R16 */ \
-    A("reti")                           /* 4 Return from interrupt */ \
-    :                                   \
-    : [timsk0] "i"((uint16_t)&TIMSK0),  \
-      [msk0] "M" ((uint8_t)(1<<OCIE0B)) \
-    : \
-  ); \
-} \
-void TIMER0_COMPB_vect_bottom()
-
 // ADC
 #ifdef DIDR2
   #define HAL_ANALOG_SELECT(ind) do{ if (ind < 8) SBI(DIDR0, ind); else SBI(DIDR2, ind & 0x07); }while(0)

commit a4c981469e317b30ff21fba109e1b126e5dcafcf
Author: Gurmeet Athwal <gurmeet.athwal@gmail.com>
Date:   Wed May 6 10:04:04 2020 +0530

    Extended reporting options (#16741)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index f319868e36..e96193651b 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -53,6 +53,9 @@
 // AVR PROGMEM extension for sprintf_P
 #define S_FMT "%S"
 
+// AVR PROGMEM extension for string define
+#define PGMSTR(NAM,STR) const char NAM[] PROGMEM = STR
+
 #ifndef CRITICAL_SECTION_START
   #define CRITICAL_SECTION_START()  unsigned char _sreg = SREG; cli()
   #define CRITICAL_SECTION_END()    SREG = _sreg

commit 39f703310b8da3b95ad08c3eecd642d76e88fd78
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 5 17:55:35 2020 -0500

    Move S_FMT to HAL, apply to mixer

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index f715295d0a..f319868e36 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -50,7 +50,8 @@
 // Defines
 // ------------------------
 
-//#define analogInputToDigitalPin(IO) IO
+// AVR PROGMEM extension for sprintf_P
+#define S_FMT "%S"
 
 #ifndef CRITICAL_SECTION_START
   #define CRITICAL_SECTION_START()  unsigned char _sreg = SREG; cli()
@@ -60,9 +61,6 @@
 #define ENABLE_ISRS()  sei()
 #define DISABLE_ISRS() cli()
 
-// On AVR this is in math.h?
-//#define square(x) ((x)*(x))
-
 // ------------------------
 // Types
 // ------------------------

commit df8b7dfc406be095a62b5445b69c40034d418823
Author: Ben <jediminer543@users.noreply.github.com>
Date:   Fri Apr 3 01:31:08 2020 +0100

    Various Laser / Spindle improvements (#15335)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
index 0255169819..f715295d0a 100644
--- a/Marlin/src/HAL/AVR/HAL.h
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -395,6 +395,8 @@ inline void HAL_adc_init() {
 // AVR compatibility
 #define strtof strtod
 
+#define HAL_CAN_SET_PWM_FREQ   // This HAL supports PWM Frequency adjustment
+
 /**
  *  set_pwm_frequency
  *  Sets the frequency of the timer corresponding to the provided pin

commit 6bead0c1b04152f6a291d851f6cd4029fe0fc616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 16:29:29 2020 -0500

    Shorter paths to HAL, ExtUI (#17156)

diff --git a/Marlin/src/HAL/AVR/HAL.h b/Marlin/src/HAL/AVR/HAL.h
new file mode 100644
index 0000000000..0255169819
--- /dev/null
+++ b/Marlin/src/HAL/AVR/HAL.h
@@ -0,0 +1,415 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#pragma once
+
+#include "../shared/Marduino.h"
+#include "../shared/HAL_SPI.h"
+#include "fastio.h"
+#include "watchdog.h"
+#include "math.h"
+
+#ifdef USBCON
+  #include <HardwareSerial.h>
+#else
+  #define HardwareSerial_h // Hack to prevent HardwareSerial.h header inclusion
+  #include "MarlinSerial.h"
+#endif
+
+#include <stdint.h>
+#include <util/delay.h>
+#include <avr/eeprom.h>
+#include <avr/pgmspace.h>
+#include <avr/interrupt.h>
+#include <avr/io.h>
+
+#ifndef pgm_read_ptr
+  // Compatibility for avr-libc 1.8.0-4.1 included with Ubuntu for
+  // Windows Subsystem for Linux on Windows 10 as of 10/18/2019
+  #define pgm_read_ptr_far(address_long) (void*)__ELPM_word((uint32_t)(address_long))
+  #define pgm_read_ptr_near(address_short) (void*)__LPM_word((uint16_t)(address_short))
+  #define pgm_read_ptr(address_short) pgm_read_ptr_near(address_short)
+#endif
+
+// ------------------------
+// Defines
+// ------------------------
+
+//#define analogInputToDigitalPin(IO) IO
+
+#ifndef CRITICAL_SECTION_START
+  #define CRITICAL_SECTION_START()  unsigned char _sreg = SREG; cli()
+  #define CRITICAL_SECTION_END()    SREG = _sreg
+#endif
+#define ISRS_ENABLED() TEST(SREG, SREG_I)
+#define ENABLE_ISRS()  sei()
+#define DISABLE_ISRS() cli()
+
+// On AVR this is in math.h?
+//#define square(x) ((x)*(x))
+
+// ------------------------
+// Types
+// ------------------------
+
+typedef uint16_t hal_timer_t;
+#define HAL_TIMER_TYPE_MAX 0xFFFF
+
+typedef int8_t pin_t;
+
+#define SHARED_SERVOS HAS_SERVOS
+#define HAL_SERVO_LIB Servo
+
+// ------------------------
+// Public Variables
+// ------------------------
+
+//extern uint8_t MCUSR;
+
+// Serial ports
+#ifdef USBCON
+  #if ENABLED(BLUETOOTH)
+    #define MYSERIAL0 bluetoothSerial
+  #else
+    #define MYSERIAL0 Serial
+  #endif
+  #define NUM_SERIAL 1
+#else
+  #if !WITHIN(SERIAL_PORT, -1, 3)
+    #error "SERIAL_PORT must be from -1 to 3. Please update your configuration."
+  #endif
+
+  #define MYSERIAL0 customizedSerial1
+
+  #ifdef SERIAL_PORT_2
+    #if !WITHIN(SERIAL_PORT_2, -1, 3)
+      #error "SERIAL_PORT_2 must be from -1 to 3. Please update your configuration."
+    #elif SERIAL_PORT_2 == SERIAL_PORT
+      #error "SERIAL_PORT_2 must be different than SERIAL_PORT. Please update your configuration."
+    #endif
+    #define MYSERIAL1 customizedSerial2
+    #define NUM_SERIAL 2
+  #else
+    #define NUM_SERIAL 1
+  #endif
+#endif
+
+#ifdef DGUS_SERIAL_PORT
+  #if !WITHIN(DGUS_SERIAL_PORT, -1, 3)
+    #error "DGUS_SERIAL_PORT must be from -1 to 3. Please update your configuration."
+  #elif DGUS_SERIAL_PORT == SERIAL_PORT
+    #error "DGUS_SERIAL_PORT must be different than SERIAL_PORT. Please update your configuration."
+  #elif defined(SERIAL_PORT_2) && DGUS_SERIAL_PORT == SERIAL_PORT_2
+    #error "DGUS_SERIAL_PORT must be different than SERIAL_PORT_2. Please update your configuration."
+  #endif
+  #define DGUS_SERIAL internalDgusSerial
+
+  #define DGUS_SERIAL_GET_TX_BUFFER_FREE DGUS_SERIAL.get_tx_buffer_free
+#endif
+
+// ------------------------
+// Public functions
+// ------------------------
+
+void HAL_init();
+
+//void cli();
+
+//void _delay_ms(const int delay);
+
+inline void HAL_clear_reset_source() { MCUSR = 0; }
+inline uint8_t HAL_get_reset_source() { return MCUSR; }
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wunused-function"
+extern "C" {
+  int freeMemory();
+}
+#pragma GCC diagnostic pop
+
+// timers
+#define HAL_TIMER_RATE          ((F_CPU) / 8)    // i.e., 2MHz or 2.5MHz
+
+#define STEP_TIMER_NUM          1
+#define TEMP_TIMER_NUM          0
+#define PULSE_TIMER_NUM         STEP_TIMER_NUM
+
+#define TEMP_TIMER_FREQUENCY    ((F_CPU) / 64.0 / 256.0)
+
+#define STEPPER_TIMER_RATE      HAL_TIMER_RATE
+#define STEPPER_TIMER_PRESCALE  8
+#define STEPPER_TIMER_TICKS_PER_US ((STEPPER_TIMER_RATE) / 1000000) // Cannot be of type double
+
+#define PULSE_TIMER_RATE       STEPPER_TIMER_RATE   // frequency of pulse timer
+#define PULSE_TIMER_PRESCALE   STEPPER_TIMER_PRESCALE
+#define PULSE_TIMER_TICKS_PER_US STEPPER_TIMER_TICKS_PER_US
+
+#define ENABLE_STEPPER_DRIVER_INTERRUPT()  SBI(TIMSK1, OCIE1A)
+#define DISABLE_STEPPER_DRIVER_INTERRUPT() CBI(TIMSK1, OCIE1A)
+#define STEPPER_ISR_ENABLED()             TEST(TIMSK1, OCIE1A)
+
+#define ENABLE_TEMPERATURE_INTERRUPT()     SBI(TIMSK0, OCIE0B)
+#define DISABLE_TEMPERATURE_INTERRUPT()    CBI(TIMSK0, OCIE0B)
+#define TEMPERATURE_ISR_ENABLED()         TEST(TIMSK0, OCIE0B)
+
+FORCE_INLINE void HAL_timer_start(const uint8_t timer_num, const uint32_t) {
+  switch (timer_num) {
+    case STEP_TIMER_NUM:
+      // waveform generation = 0100 = CTC
+      SET_WGM(1, CTC_OCRnA);
+
+      // output mode = 00 (disconnected)
+      SET_COMA(1, NORMAL);
+
+      // Set the timer pre-scaler
+      // Generally we use a divider of 8, resulting in a 2MHz timer
+      // frequency on a 16MHz MCU. If you are going to change this, be
+      // sure to regenerate speed_lookuptable.h with
+      // create_speed_lookuptable.py
+      SET_CS(1, PRESCALER_8);  //  CS 2 = 1/8 prescaler
+
+      // Init Stepper ISR to 122 Hz for quick starting
+      // (F_CPU) / (STEPPER_TIMER_PRESCALE) / frequency
+      OCR1A = 0x4000;
+      TCNT1 = 0;
+      break;
+
+    case TEMP_TIMER_NUM:
+      // Use timer0 for temperature measurement
+      // Interleave temperature interrupt with millies interrupt
+      OCR0B = 128;
+      break;
+  }
+}
+
+#define TIMER_OCR_1             OCR1A
+#define TIMER_COUNTER_1         TCNT1
+
+#define TIMER_OCR_0             OCR0A
+#define TIMER_COUNTER_0         TCNT0
+
+#define _CAT(a,V...) a##V
+#define HAL_timer_set_compare(timer, compare) (_CAT(TIMER_OCR_, timer) = compare)
+#define HAL_timer_get_compare(timer) _CAT(TIMER_OCR_, timer)
+#define HAL_timer_get_count(timer) _CAT(TIMER_COUNTER_, timer)
+
+/**
+ * On AVR there is no hardware prioritization and preemption of
+ * interrupts, so this emulates it. The UART has first priority
+ * (otherwise, characters will be lost due to UART overflow).
+ * Then: Stepper, Endstops, Temperature, and -finally- all others.
+ */
+#define HAL_timer_isr_prologue(TIMER_NUM)
+#define HAL_timer_isr_epilogue(TIMER_NUM)
+
+/* 18 cycles maximum latency */
+#define HAL_STEP_TIMER_ISR() \
+extern "C" void TIMER1_COMPA_vect() __attribute__ ((signal, naked, used, externally_visible)); \
+extern "C" void TIMER1_COMPA_vect_bottom() asm ("TIMER1_COMPA_vect_bottom") __attribute__ ((used, externally_visible, noinline)); \
+void TIMER1_COMPA_vect() { \
+  __asm__ __volatile__ ( \
+    A("push r16")                      /* 2 Save R16 */ \
+    A("in r16, __SREG__")              /* 1 Get SREG */ \
+    A("push r16")                      /* 2 Save SREG into stack */ \
+    A("lds r16, %[timsk0]")            /* 2 Load into R0 the Temperature timer Interrupt mask register */ \
+    A("push r16")                      /* 2 Save TIMSK0 into the stack */ \
+    A("andi r16,~%[msk0]")             /* 1 Disable the temperature ISR */ \
+    A("sts %[timsk0], r16")            /* 2 And set the new value */ \
+    A("lds r16, %[timsk1]")            /* 2 Load into R0 the stepper timer Interrupt mask register [TIMSK1] */ \
+    A("andi r16,~%[msk1]")             /* 1 Disable the stepper ISR */ \
+    A("sts %[timsk1], r16")            /* 2 And set the new value */ \
+    A("push r16")                      /* 2 Save TIMSK1 into stack */ \
+    A("in r16, 0x3B")                  /* 1 Get RAMPZ register */ \
+    A("push r16")                      /* 2 Save RAMPZ into stack */ \
+    A("in r16, 0x3C")                  /* 1 Get EIND register */ \
+    A("push r0")                       /* C runtime can modify all the following registers without restoring them */ \
+    A("push r1")                       \
+    A("push r18")                      \
+    A("push r19")                      \
+    A("push r20")                      \
+    A("push r21")                      \
+    A("push r22")                      \
+    A("push r23")                      \
+    A("push r24")                      \
+    A("push r25")                      \
+    A("push r26")                      \
+    A("push r27")                      \
+    A("push r30")                      \
+    A("push r31")                      \
+    A("clr r1")                        /* C runtime expects this register to be 0 */ \
+    A("call TIMER1_COMPA_vect_bottom") /* Call the bottom handler - No inlining allowed, otherwise registers used are not saved */   \
+    A("pop r31")                       \
+    A("pop r30")                       \
+    A("pop r27")                       \
+    A("pop r26")                       \
+    A("pop r25")                       \
+    A("pop r24")                       \
+    A("pop r23")                       \
+    A("pop r22")                       \
+    A("pop r21")                       \
+    A("pop r20")                       \
+    A("pop r19")                       \
+    A("pop r18")                       \
+    A("pop r1")                        \
+    A("pop r0")                        \
+    A("out 0x3C, r16")                 /* 1 Restore EIND register */ \
+    A("pop r16")                       /* 2 Get the original RAMPZ register value */ \
+    A("out 0x3B, r16")                 /* 1 Restore RAMPZ register to its original value */ \
+    A("pop r16")                       /* 2 Get the original TIMSK1 value but with stepper ISR disabled */ \
+    A("ori r16,%[msk1]")               /* 1 Reenable the stepper ISR */ \
+    A("cli")                           /* 1 Disable global interrupts - Reenabling Stepper ISR can reenter amd temperature can reenter, and we want that, if it happens, after this ISR has ended */ \
+    A("sts %[timsk1], r16")            /* 2 And restore the old value - This reenables the stepper ISR */ \
+    A("pop r16")                       /* 2 Get the temperature timer Interrupt mask register [TIMSK0] */ \
+    A("sts %[timsk0], r16")            /* 2 And restore the old value - This reenables the temperature ISR */ \
+    A("pop r16")                       /* 2 Get the old SREG value */ \
+    A("out __SREG__, r16")             /* 1 And restore the SREG value */ \
+    A("pop r16")                       /* 2 Restore R16 value */ \
+    A("reti")                          /* 4 Return from interrupt */ \
+    :                                   \
+    : [timsk0] "i" ((uint16_t)&TIMSK0), \
+      [timsk1] "i" ((uint16_t)&TIMSK1), \
+      [msk0] "M" ((uint8_t)(1<<OCIE0B)),\
+      [msk1] "M" ((uint8_t)(1<<OCIE1A)) \
+    : \
+  ); \
+} \
+void TIMER1_COMPA_vect_bottom()
+
+/* 14 cycles maximum latency */
+#define HAL_TEMP_TIMER_ISR() \
+extern "C" void TIMER0_COMPB_vect() __attribute__ ((signal, naked, used, externally_visible)); \
+extern "C" void TIMER0_COMPB_vect_bottom()  asm ("TIMER0_COMPB_vect_bottom") __attribute__ ((used, externally_visible, noinline)); \
+void TIMER0_COMPB_vect() { \
+  __asm__ __volatile__ ( \
+    A("push r16")                       /* 2 Save R16 */ \
+    A("in r16, __SREG__")               /* 1 Get SREG */ \
+    A("push r16")                       /* 2 Save SREG into stack */ \
+    A("lds r16, %[timsk0]")             /* 2 Load into R0 the Temperature timer Interrupt mask register */ \
+    A("andi r16,~%[msk0]")              /* 1 Disable the temperature ISR */ \
+    A("sts %[timsk0], r16")             /* 2 And set the new value */ \
+    A("sei")                            /* 1 Enable global interrupts - It is safe, as the temperature ISR is disabled, so we cannot reenter it */    \
+    A("push r16")                       /* 2 Save TIMSK0 into stack */ \
+    A("in r16, 0x3B")                   /* 1 Get RAMPZ register */ \
+    A("push r16")                       /* 2 Save RAMPZ into stack */ \
+    A("in r16, 0x3C")                   /* 1 Get EIND register */ \
+    A("push r0")                        /* C runtime can modify all the following registers without restoring them */ \
+    A("push r1")                        \
+    A("push r18")                       \
+    A("push r19")                       \
+    A("push r20")                       \
+    A("push r21")                       \
+    A("push r22")                       \
+    A("push r23")                       \
+    A("push r24")                       \
+    A("push r25")                       \
+    A("push r26")                       \
+    A("push r27")                       \
+    A("push r30")                       \
+    A("push r31")                       \
+    A("clr r1")                         /* C runtime expects this register to be 0 */ \
+    A("call TIMER0_COMPB_vect_bottom")  /* Call the bottom handler - No inlining allowed, otherwise registers used are not saved */   \
+    A("pop r31")                        \
+    A("pop r30")                        \
+    A("pop r27")                        \
+    A("pop r26")                        \
+    A("pop r25")                        \
+    A("pop r24")                        \
+    A("pop r23")                        \
+    A("pop r22")                        \
+    A("pop r21")                        \
+    A("pop r20")                        \
+    A("pop r19")                        \
+    A("pop r18")                        \
+    A("pop r1")                         \
+    A("pop r0")                         \
+    A("out 0x3C, r16")                  /* 1 Restore EIND register */ \
+    A("pop r16")                        /* 2 Get the original RAMPZ register value */ \
+    A("out 0x3B, r16")                  /* 1 Restore RAMPZ register to its original value */ \
+    A("pop r16")                        /* 2 Get the original TIMSK0 value but with temperature ISR disabled */ \
+    A("ori r16,%[msk0]")                /* 1 Enable temperature ISR */ \
+    A("cli")                            /* 1 Disable global interrupts - We must do this, as we will reenable the temperature ISR, and we don't want to reenter this handler until the current one is done */ \
+    A("sts %[timsk0], r16")             /* 2 And restore the old value */ \
+    A("pop r16")                        /* 2 Get the old SREG */ \
+    A("out __SREG__, r16")              /* 1 And restore the SREG value */ \
+    A("pop r16")                        /* 2 Restore R16 */ \
+    A("reti")                           /* 4 Return from interrupt */ \
+    :                                   \
+    : [timsk0] "i"((uint16_t)&TIMSK0),  \
+      [msk0] "M" ((uint8_t)(1<<OCIE0B)) \
+    : \
+  ); \
+} \
+void TIMER0_COMPB_vect_bottom()
+
+// ADC
+#ifdef DIDR2
+  #define HAL_ANALOG_SELECT(ind) do{ if (ind < 8) SBI(DIDR0, ind); else SBI(DIDR2, ind & 0x07); }while(0)
+#else
+  #define HAL_ANALOG_SELECT(ind) SBI(DIDR0, ind);
+#endif
+
+inline void HAL_adc_init() {
+  ADCSRA = _BV(ADEN) | _BV(ADSC) | _BV(ADIF) | 0x07;
+  DIDR0 = 0;
+  #ifdef DIDR2
+    DIDR2 = 0;
+  #endif
+}
+
+#define SET_ADMUX_ADCSRA(ch) ADMUX = _BV(REFS0) | (ch & 0x07); SBI(ADCSRA, ADSC)
+#ifdef MUX5
+  #define HAL_START_ADC(ch) if (ch > 7) ADCSRB = _BV(MUX5); else ADCSRB = 0; SET_ADMUX_ADCSRA(ch)
+#else
+  #define HAL_START_ADC(ch) ADCSRB = 0; SET_ADMUX_ADCSRA(ch)
+#endif
+
+#define HAL_ADC_RESOLUTION 10
+#define HAL_READ_ADC()  ADC
+#define HAL_ADC_READY() !TEST(ADCSRA, ADSC)
+
+#define GET_PIN_MAP_PIN(index) index
+#define GET_PIN_MAP_INDEX(pin) pin
+#define PARSED_PIN_INDEX(code, dval) parser.intval(code, dval)
+
+#define HAL_SENSITIVE_PINS 0, 1
+
+#ifdef __AVR_AT90USB1286__
+  #define JTAG_DISABLE() do{ MCUCR = 0x80; MCUCR = 0x80; }while(0)
+#endif
+
+// AVR compatibility
+#define strtof strtod
+
+/**
+ *  set_pwm_frequency
+ *  Sets the frequency of the timer corresponding to the provided pin
+ *  as close as possible to the provided desired frequency. Internally
+ *  calculates the required waveform generation mode, prescaler and
+ *  resolution values required and sets the timer registers accordingly.
+ *  NOTE that the frequency is applied to all pins on the timer (Ex OC3A, OC3B and OC3B)
+ *  NOTE that there are limitations, particularly if using TIMER2. (see Configuration_adv.h -> FAST FAN PWM Settings)
+ */
+void set_pwm_frequency(const pin_t pin, int f_desired);
+
+/**
+ * set_pwm_duty
+ *  Sets the PWM duty cycle of the provided pin to the provided value
+ *  Optionally allows inverting the duty cycle [default = false]
+ *  Optionally allows changing the maximum size of the provided value to enable finer PWM duty control [default = 255]
+ */
+void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size=255, const bool invert=false);
