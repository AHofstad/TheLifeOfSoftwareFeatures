commit f3473495d0ecc61e4d768e88759e9a7f9a263770
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Wed Nov 22 03:19:29 2023 -0500

    üö∏ Fixes for ProUI popup, abort (#26308)

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index 65c553c702..06efce1dc5 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -179,7 +179,7 @@ struct RuntimeSerial : public SerialBase< RuntimeSerial<SerialT> >, public Seria
   // Append Hookable for this class
   SerialFeature features(serial_index_t index) const  { return SerialFeature::Hookable | CALL_IF_EXISTS(SerialFeature, static_cast<const SerialT*>(this), features, index);  }
 
-  void setHook(WriteHook writeHook = 0, EndOfMessageHook eofHook = 0, void * userPointer = 0) {
+  void setHook(WriteHook writeHook=0, EndOfMessageHook eofHook=0, void * userPointer=0) {
     // Order is important here as serial code can be called inside interrupts
     // When setting a hook, the user pointer must be set first so if writeHook is called as soon as it's set, it'll be valid
     if (userPointer) this->userPointer = userPointer;
@@ -292,7 +292,7 @@ struct MultiSerial : public SerialBase< MultiSerial< REPEAT(NUM_SERIAL, _S_NAME)
   #define _S_REFS(N) Serial##N##T & serial##N,
   #define _S_INIT(N) ,serial##N (serial##N)
 
-  MultiSerial(REPEAT(NUM_SERIAL, _S_REFS) const SerialMask mask = ALL, const bool e = false)
+  MultiSerial(REPEAT(NUM_SERIAL, _S_REFS) const SerialMask mask=ALL, const bool e=false)
     : BaseClassT(e), portMask(mask) REPEAT(NUM_SERIAL, _S_INIT) {}
 
 };

commit 66e32cb0fa1ed6cfae482bec31dfbb834340a408
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri May 13 19:31:07 2022 -0500

    üßë‚Äçüíª Clarify MSerialUSB, drop HardwareSerial workaround

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index 2e3c31b208..65c553c702 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -300,7 +300,7 @@ struct MultiSerial : public SerialBase< MultiSerial< REPEAT(NUM_SERIAL, _S_NAME)
 // Build the actual serial object depending on current configuration
 #define Serial1Class TERN(SERIAL_RUNTIME_HOOK, RuntimeSerial, BaseSerial)
 #define ForwardSerial1Class TERN(SERIAL_RUNTIME_HOOK, RuntimeSerial, ForwardSerial)
-#ifdef HAS_MULTI_SERIAL
+#if HAS_MULTI_SERIAL
   #define Serial2Class ConditionalSerial
   #if NUM_SERIAL >= 3
     #define Serial3Class ConditionalSerial

commit 80810f1b187661860a2ded43e2a0c4cc356edebe
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 1 17:49:54 2022 -0600

    üö® Fix some compiler warnings

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index 9b9fa8fa38..2e3c31b208 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -43,7 +43,9 @@ public:
   }
 
   constexpr SerialMask(const uint8_t mask) : mask(mask) {}
-  constexpr SerialMask(const SerialMask & other) : mask(other.mask) {} // Can't use = default here since not all framework support this
+  constexpr SerialMask(const SerialMask &rs) : mask(rs.mask) {} // Can't use = default here since not all frameworks support this
+
+  SerialMask& operator=(const SerialMask &rs) { mask = rs.mask; return *this; }
 
   static constexpr uint8_t All = 0xFF;
 };

commit 6fb2d8a25f096d084348a6f6930f515d947474d4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Dec 28 02:57:24 2021 -0600

    üßë‚Äçüíª Remove extraneous 'inline' hints

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index 2019b389e4..9b9fa8fa38 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -37,7 +37,7 @@ public:
   inline constexpr bool enabled(const SerialMask PortMask) const    { return mask & PortMask.mask; }
   inline constexpr SerialMask combine(const SerialMask other) const { return SerialMask(mask | other.mask); }
   inline constexpr SerialMask operator<< (const int offset) const   { return SerialMask(mask << offset); }
-  static inline SerialMask from(const serial_index_t index) {
+  static SerialMask from(const serial_index_t index) {
     if (index.valid()) return SerialMask(_BV(index.index));
     return SerialMask(0); // A invalid index mean no output
   }

commit afca6e745932d295b88d37fa9bd4274e22705b0b
Author: luzpaz <luzpaz@users.noreply.github.com>
Date:   Tue Aug 3 20:02:34 2021 -0400

    üêõ Spellcheck comments (#22496)
    
    codespell -q 3 --builtin=clear,rare,informal,code -S ./Marlin/src/lcd/language -L alo,amin,endcode,stdio,uint

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index d56cb55a66..2019b389e4 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -109,7 +109,7 @@ struct ConditionalSerial : public SerialBase< ConditionalSerial<SerialT> > {
   ConditionalSerial(bool & conditionVariable, SerialT & out, const bool e) : BaseClassT(e), condition(conditionVariable), out(out) {}
 };
 
-// A simple foward class that taking a reference to an existing serial instance (likely created in their respective framework)
+// A simple forward class that taking a reference to an existing serial instance (likely created in their respective framework)
 template <class SerialT>
 struct ForwardSerial : public SerialBase< ForwardSerial<SerialT> > {
   typedef SerialBase< ForwardSerial<SerialT> > BaseClassT;

commit 02405add76e722701ab49434549e7d8bf5690162
Author: ellensp <ellensp@hotmail.com>
Date:   Fri May 7 17:31:45 2021 +1200

    Support a third serial port (#21784)

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index 45cdcd35ed..d56cb55a66 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -195,54 +195,71 @@ struct RuntimeSerial : public SerialBase< RuntimeSerial<SerialT> >, public Seria
   RuntimeSerial(const bool e, Args... args) : BaseClassT(e), SerialT(args...), writeHook(0), eofHook(0), userPointer(0) {}
 };
 
-// A class that duplicates its output conditionally to 2 serial interfaces
-template <class Serial0T, class Serial1T, const uint8_t offset = 0, const uint8_t step = 1>
-struct MultiSerial : public SerialBase< MultiSerial<Serial0T, Serial1T, offset, step> > {
-  typedef SerialBase< MultiSerial<Serial0T, Serial1T, offset, step> > BaseClassT;
+#define _S_CLASS(N) class Serial##N##T,
+#define _S_NAME(N) Serial##N##T,
+
+template < REPEAT(NUM_SERIAL, _S_CLASS) const uint8_t offset=0, const uint8_t step=1 >
+struct MultiSerial : public SerialBase< MultiSerial< REPEAT(NUM_SERIAL, _S_NAME) offset, step > > {
+  typedef SerialBase< MultiSerial< REPEAT(NUM_SERIAL, _S_NAME) offset, step > > BaseClassT;
+
+  #undef _S_CLASS
+  #undef _S_NAME
 
   SerialMask portMask;
-  Serial0T & serial0;
-  Serial1T & serial1;
 
-  static constexpr uint8_t Usage         =  ((1 << step) - 1); // A bit mask containing as many bits as step
-  static constexpr uint8_t FirstOutput   = (Usage << offset);
-  static constexpr uint8_t SecondOutput  = (Usage << (offset + step));
-  static constexpr uint8_t Both          = FirstOutput | SecondOutput;
+  #define _S_DECLARE(N) Serial##N##T & serial##N;
+  REPEAT(NUM_SERIAL, _S_DECLARE);
+  #undef _S_DECLARE
+
+  static constexpr uint8_t Usage = _BV(step) - 1; // A bit mask containing 'step' bits
+
+  #define _OUT_PORT(N) (Usage << (offset + (step * N))),
+  static constexpr uint8_t output[] = { REPEAT(NUM_SERIAL, _OUT_PORT) };
+  #undef _OUT_PORT
+
+  #define _OUT_MASK(N) | output[N]
+  static constexpr uint8_t ALL = 0 REPEAT(NUM_SERIAL, _OUT_MASK);
+  #undef _OUT_MASK
 
   NO_INLINE void write(uint8_t c) {
-    if (portMask.enabled(FirstOutput))   serial0.write(c);
-    if (portMask.enabled(SecondOutput))  serial1.write(c);
+    #define _S_WRITE(N) if (portMask.enabled(output[N])) serial##N.write(c);
+    REPEAT(NUM_SERIAL, _S_WRITE);
+    #undef _S_WRITE
   }
   NO_INLINE void msgDone() {
-    if (portMask.enabled(FirstOutput))   serial0.msgDone();
-    if (portMask.enabled(SecondOutput))  serial1.msgDone();
+    #define _S_DONE(N) if (portMask.enabled(output[N])) serial##N.msgDone();
+    REPEAT(NUM_SERIAL, _S_DONE);
+    #undef _S_DONE
   }
   int available(serial_index_t index) {
-    if (index.within(0 + offset, step + offset - 1))
-      return serial0.available(index);
-    else if (index.within(step + offset, 2 * step + offset - 1))
-      return serial1.available(index);
+    uint8_t pos = offset;
+    #define _S_AVAILABLE(N) if (index.within(pos, pos + step - 1)) return serial##N.available(index); else pos += step;
+    REPEAT(NUM_SERIAL, _S_AVAILABLE);
+    #undef _S_AVAILABLE
     return false;
   }
   int read(serial_index_t index) {
-    if (index.within(0 + offset, step + offset - 1))
-      return serial0.read(index);
-    else if (index.within(step + offset, 2 * step + offset - 1))
-      return serial1.read(index);
+    uint8_t pos = offset;
+    #define _S_READ(N) if (index.within(pos, pos + step - 1)) return serial##N.read(index); else pos += step;
+    REPEAT(NUM_SERIAL, _S_READ);
+    #undef _S_READ
     return -1;
   }
   void begin(const long br) {
-    if (portMask.enabled(FirstOutput))   serial0.begin(br);
-    if (portMask.enabled(SecondOutput))  serial1.begin(br);
+    #define _S_BEGIN(N) if (portMask.enabled(output[N])) serial##N.begin(br);
+    REPEAT(NUM_SERIAL, _S_BEGIN);
+    #undef _S_BEGIN
   }
   void end() {
-    if (portMask.enabled(FirstOutput))   serial0.end();
-    if (portMask.enabled(SecondOutput))  serial1.end();
+    #define _S_END(N) if (portMask.enabled(output[N])) serial##N.end();
+    REPEAT(NUM_SERIAL, _S_END);
+    #undef _S_END
   }
   bool connected() {
     bool ret = true;
-    if (portMask.enabled(FirstOutput))   ret = CALL_IF_EXISTS(bool, &serial0, connected);
-    if (portMask.enabled(SecondOutput))  ret = ret && CALL_IF_EXISTS(bool, &serial1, connected);
+    #define _S_CONNECTED(N) if (portMask.enabled(output[N]) && !CALL_IF_EXISTS(bool, &serial##N, connected)) ret = false;
+    REPEAT(NUM_SERIAL, _S_CONNECTED);
+    #undef _S_CONNECTED
     return ret;
   }
 
@@ -250,27 +267,32 @@ struct MultiSerial : public SerialBase< MultiSerial<Serial0T, Serial1T, offset,
   using BaseClassT::read;
 
   // Redirect flush
-  NO_INLINE void flush()      {
-    if (portMask.enabled(FirstOutput))   serial0.flush();
-    if (portMask.enabled(SecondOutput))  serial1.flush();
+  NO_INLINE void flush() {
+    #define _S_FLUSH(N) if (portMask.enabled(output[N])) serial##N.flush();
+    REPEAT(NUM_SERIAL, _S_FLUSH);
+    #undef _S_FLUSH
   }
-  NO_INLINE void flushTX()    {
-    if (portMask.enabled(FirstOutput))   CALL_IF_EXISTS(void, &serial0, flushTX);
-    if (portMask.enabled(SecondOutput))  CALL_IF_EXISTS(void, &serial1, flushTX);
+  NO_INLINE void flushTX() {
+    #define _S_FLUSHTX(N) if (portMask.enabled(output[N])) CALL_IF_EXISTS(void, &serial0, flushTX);
+    REPEAT(NUM_SERIAL, _S_FLUSHTX);
+    #undef _S_FLUSHTX
   }
 
   // Forward feature queries
-  SerialFeature features(serial_index_t index) const  {
-    if (index.within(0 + offset, step + offset - 1))
-      return serial0.features(index);
-    else if (index.within(step + offset, 2 * step + offset - 1))
-      return serial1.features(index);
+  SerialFeature features(serial_index_t index) const {
+    uint8_t pos = offset;
+    #define _S_FEATURES(N) if (index.within(pos, pos + step - 1)) return serial##N.features(index); else pos += step;
+    REPEAT(NUM_SERIAL, _S_FEATURES);
+    #undef _S_FEATURES
     return SerialFeature::None;
   }
 
-  MultiSerial(Serial0T & serial0, Serial1T & serial1, const SerialMask mask = Both, const bool e = false) :
-    BaseClassT(e),
-    portMask(mask), serial0(serial0), serial1(serial1) {}
+  #define _S_REFS(N) Serial##N##T & serial##N,
+  #define _S_INIT(N) ,serial##N (serial##N)
+
+  MultiSerial(REPEAT(NUM_SERIAL, _S_REFS) const SerialMask mask = ALL, const bool e = false)
+    : BaseClassT(e), portMask(mask) REPEAT(NUM_SERIAL, _S_INIT) {}
+
 };
 
 // Build the actual serial object depending on current configuration
@@ -278,4 +300,7 @@ struct MultiSerial : public SerialBase< MultiSerial<Serial0T, Serial1T, offset,
 #define ForwardSerial1Class TERN(SERIAL_RUNTIME_HOOK, RuntimeSerial, ForwardSerial)
 #ifdef HAS_MULTI_SERIAL
   #define Serial2Class ConditionalSerial
+  #if NUM_SERIAL >= 3
+    #define Serial3Class ConditionalSerial
+  #endif
 #endif

commit fccfcfbe5fc222bc53dd52f7a9effa8e305fafbf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 5 06:32:54 2021 -0500

    Cleanup, hex formatting, includes

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index 512ebdec97..45cdcd35ed 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -67,7 +67,7 @@ struct BaseSerial : public SerialBase< BaseSerial<SerialT> >, public SerialT {
 
   SerialFeature features(serial_index_t index) const { return CALL_IF_EXISTS(SerialFeature, static_cast<const SerialT*>(this), features, index);  }
 
-  // We have 2 implementation of the same method in both base class, let's say which one we want
+  // Two implementations of the same method exist in both base classes so indicate the right one
   using SerialT::available;
   using SerialT::read;
   using SerialT::begin;
@@ -134,7 +134,7 @@ struct ForwardSerial : public SerialBase< ForwardSerial<SerialT> > {
   ForwardSerial(const bool e, SerialT & out) : BaseClassT(e), out(out) {}
 };
 
-// A class that's can be hooked and unhooked at runtime, useful to capturing the output of the serial interface
+// A class that can be hooked and unhooked at runtime, useful to capture the output of the serial interface
 template <class SerialT>
 struct RuntimeSerial : public SerialBase< RuntimeSerial<SerialT> >, public SerialT {
   typedef SerialBase< RuntimeSerial<SerialT> > BaseClassT;

commit 62f992af23b0dd3160db049aa83e541fe164630a
Author: ellensp <ellensp@hotmail.com>
Date:   Sun Apr 11 08:35:45 2021 +1200

    Followup to "no status for serial::write" (#21577)

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index 7bc04a5e88..512ebdec97 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -209,11 +209,9 @@ struct MultiSerial : public SerialBase< MultiSerial<Serial0T, Serial1T, offset,
   static constexpr uint8_t SecondOutput  = (Usage << (offset + step));
   static constexpr uint8_t Both          = FirstOutput | SecondOutput;
 
-  NO_INLINE size_t write(uint8_t c) {
-    size_t ret = 0;
-    if (portMask.enabled(FirstOutput))   ret = serial0.write(c);
-    if (portMask.enabled(SecondOutput))  ret = serial1.write(c) | ret;
-    return ret;
+  NO_INLINE void write(uint8_t c) {
+    if (portMask.enabled(FirstOutput))   serial0.write(c);
+    if (portMask.enabled(SecondOutput))  serial1.write(c);
   }
   NO_INLINE void msgDone() {
     if (portMask.enabled(FirstOutput))   serial0.msgDone();

commit 139c14948621adcaa227bcef67765a5228039cd3
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Tue Mar 30 04:36:01 2021 +0200

    Flags for MarlinSerial instance features (#21318)

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index c687891fb4..7bc04a5e88 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -65,6 +65,8 @@ struct BaseSerial : public SerialBase< BaseSerial<SerialT> >, public SerialT {
   bool connected()              { return CALL_IF_EXISTS(bool, static_cast<SerialT*>(this), connected);; }
   void flushTX()                { CALL_IF_EXISTS(void, static_cast<SerialT*>(this), flushTX); }
 
+  SerialFeature features(serial_index_t index) const { return CALL_IF_EXISTS(SerialFeature, static_cast<const SerialT*>(this), features, index);  }
+
   // We have 2 implementation of the same method in both base class, let's say which one we want
   using SerialT::available;
   using SerialT::read;
@@ -98,10 +100,11 @@ struct ConditionalSerial : public SerialBase< ConditionalSerial<SerialT> > {
   bool connected()          { return CALL_IF_EXISTS(bool, &out, connected); }
   void flushTX()            { CALL_IF_EXISTS(void, &out, flushTX); }
 
-  int available(serial_index_t )  { return (int)out.available(); }
-  int read(serial_index_t )       { return (int)out.read(); }
+  int available(serial_index_t)   { return (int)out.available(); }
+  int read(serial_index_t)        { return (int)out.read(); }
   int available()                 { return (int)out.available(); }
   int read()                      { return (int)out.read(); }
+  SerialFeature features(serial_index_t index) const  { return CALL_IF_EXISTS(SerialFeature, &out, features, index);  }
 
   ConditionalSerial(bool & conditionVariable, SerialT & out, const bool e) : BaseClassT(e), condition(conditionVariable), out(out) {}
 };
@@ -126,6 +129,7 @@ struct ForwardSerial : public SerialBase< ForwardSerial<SerialT> > {
   int read(serial_index_t)      { return (int)out.read(); }
   int available()               { return (int)out.available(); }
   int read()                    { return (int)out.read(); }
+  SerialFeature features(serial_index_t index) const  { return CALL_IF_EXISTS(SerialFeature, &out, features, index);  }
 
   ForwardSerial(const bool e, SerialT & out) : BaseClassT(e), out(out) {}
 };
@@ -163,9 +167,15 @@ struct RuntimeSerial : public SerialBase< RuntimeSerial<SerialT> >, public Seria
 
   // Underlying implementation might use Arduino's bool operator
   bool connected() {
-    return Private::HasMember_connected<SerialT>::value ? CALL_IF_EXISTS(bool, static_cast<SerialT*>(this), connected) : static_cast<SerialT*>(this)->operator bool();
+    return Private::HasMember_connected<SerialT>::value
+      ? CALL_IF_EXISTS(bool, static_cast<SerialT*>(this), connected)
+      : static_cast<SerialT*>(this)->operator bool();
   }
-  void flushTX()                { CALL_IF_EXISTS(void, static_cast<SerialT*>(this), flushTX); }
+
+  void flushTX() { CALL_IF_EXISTS(void, static_cast<SerialT*>(this), flushTX); }
+
+  // Append Hookable for this class
+  SerialFeature features(serial_index_t index) const  { return SerialFeature::Hookable | CALL_IF_EXISTS(SerialFeature, static_cast<const SerialT*>(this), features, index);  }
 
   void setHook(WriteHook writeHook = 0, EndOfMessageHook eofHook = 0, void * userPointer = 0) {
     // Order is important here as serial code can be called inside interrupts
@@ -251,6 +261,15 @@ struct MultiSerial : public SerialBase< MultiSerial<Serial0T, Serial1T, offset,
     if (portMask.enabled(SecondOutput))  CALL_IF_EXISTS(void, &serial1, flushTX);
   }
 
+  // Forward feature queries
+  SerialFeature features(serial_index_t index) const  {
+    if (index.within(0 + offset, step + offset - 1))
+      return serial0.features(index);
+    else if (index.within(step + offset, 2 * step + offset - 1))
+      return serial1.features(index);
+    return SerialFeature::None;
+  }
+
   MultiSerial(Serial0T & serial0, Serial1T & serial1, const SerialMask mask = Both, const bool e = false) :
     BaseClassT(e),
     portMask(mask), serial0(serial0), serial1(serial1) {}

commit dbd28eecc9cd4b5954a4fd1ed0c02bd9788c279b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 10 12:05:05 2021 -0600

    Number serial from 1 to match settings

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index 5e81e9e0e4..c687891fb4 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -257,8 +257,8 @@ struct MultiSerial : public SerialBase< MultiSerial<Serial0T, Serial1T, offset,
 };
 
 // Build the actual serial object depending on current configuration
-#define Serial0Type TERN(SERIAL_RUNTIME_HOOK, RuntimeSerial, BaseSerial)
-#define ForwardSerial0Type TERN(SERIAL_RUNTIME_HOOK, RuntimeSerial, ForwardSerial)
+#define Serial1Class TERN(SERIAL_RUNTIME_HOOK, RuntimeSerial, BaseSerial)
+#define ForwardSerial1Class TERN(SERIAL_RUNTIME_HOOK, RuntimeSerial, ForwardSerial)
 #ifdef HAS_MULTI_SERIAL
-  #define Serial1Type ConditionalSerial
+  #define Serial2Class ConditionalSerial
 #endif

commit 55c31fbe9a70710c6a209d40b7d0165d081dcdd0
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Tue Mar 9 10:20:37 2021 +0100

    Distinguish serial index from mask (#21287)

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index dc2da13501..5e81e9e0e4 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -21,11 +21,32 @@
  */
 #pragma once
 
-#include "macros.h"
 #include "serial_base.h"
 
-// Used in multiple places
-typedef int8_t serial_index_t;
+// A mask containing a bitmap of the serial port to act upon
+// This is written to ensure a serial index is never used as a serial mask
+class SerialMask {
+  uint8_t mask;
+
+  // This constructor is private to ensure you can't convert an index to a mask
+  // The compiler will stop here if you are mixing index and mask in your code.
+  // If you need to, you'll have to use the explicit static "from" method here
+  SerialMask(const serial_index_t);
+
+public:
+  inline constexpr bool enabled(const SerialMask PortMask) const    { return mask & PortMask.mask; }
+  inline constexpr SerialMask combine(const SerialMask other) const { return SerialMask(mask | other.mask); }
+  inline constexpr SerialMask operator<< (const int offset) const   { return SerialMask(mask << offset); }
+  static inline SerialMask from(const serial_index_t index) {
+    if (index.valid()) return SerialMask(_BV(index.index));
+    return SerialMask(0); // A invalid index mean no output
+  }
+
+  constexpr SerialMask(const uint8_t mask) : mask(mask) {}
+  constexpr SerialMask(const SerialMask & other) : mask(other.mask) {} // Can't use = default here since not all framework support this
+
+  static constexpr uint8_t All = 0xFF;
+};
 
 // The most basic serial class: it dispatch to the base serial class with no hook whatsoever. This will compile to nothing but the base serial class
 template <class SerialT>
@@ -39,10 +60,10 @@ struct BaseSerial : public SerialBase< BaseSerial<SerialT> >, public SerialT {
   void msgDone() {}
 
   // We don't care about indices here, since if one can call us, it's the right index anyway
-  int available(uint8_t)  { return (int)SerialT::available(); }
-  int read(uint8_t)       { return (int)SerialT::read(); }
-  bool connected()        { return CALL_IF_EXISTS(bool, static_cast<SerialT*>(this), connected);; }
-  void flushTX()          { CALL_IF_EXISTS(void, static_cast<SerialT*>(this), flushTX); }
+  int available(serial_index_t) { return (int)SerialT::available(); }
+  int read(serial_index_t)      { return (int)SerialT::read(); }
+  bool connected()              { return CALL_IF_EXISTS(bool, static_cast<SerialT*>(this), connected);; }
+  void flushTX()                { CALL_IF_EXISTS(void, static_cast<SerialT*>(this), flushTX); }
 
   // We have 2 implementation of the same method in both base class, let's say which one we want
   using SerialT::available;
@@ -77,11 +98,10 @@ struct ConditionalSerial : public SerialBase< ConditionalSerial<SerialT> > {
   bool connected()          { return CALL_IF_EXISTS(bool, &out, connected); }
   void flushTX()            { CALL_IF_EXISTS(void, &out, flushTX); }
 
-  int available(uint8_t )   { return (int)out.available(); }
-  int read(uint8_t )        { return (int)out.read(); }
-  int available()           { return (int)out.available(); }
-  int read()                { return (int)out.read(); }
-
+  int available(serial_index_t )  { return (int)out.available(); }
+  int read(serial_index_t )       { return (int)out.read(); }
+  int available()                 { return (int)out.available(); }
+  int read()                      { return (int)out.read(); }
 
   ConditionalSerial(bool & conditionVariable, SerialT & out, const bool e) : BaseClassT(e), condition(conditionVariable), out(out) {}
 };
@@ -102,8 +122,8 @@ struct ForwardSerial : public SerialBase< ForwardSerial<SerialT> > {
   bool connected()              { return Private::HasMember_connected<SerialT>::value ? CALL_IF_EXISTS(bool, &out, connected) : (bool)out; }
   void flushTX()                { CALL_IF_EXISTS(void, &out, flushTX); }
 
-  int available(uint8_t)        { return (int)out.available(); }
-  int read(uint8_t)             { return (int)out.read(); }
+  int available(serial_index_t) { return (int)out.available(); }
+  int read(serial_index_t)      { return (int)out.read(); }
   int available()               { return (int)out.available(); }
   int read()                    { return (int)out.read(); }
 
@@ -130,8 +150,8 @@ struct RuntimeSerial : public SerialBase< RuntimeSerial<SerialT> >, public Seria
     if (eofHook) eofHook(userPointer);
   }
 
-  int available(uint8_t)  { return (int)SerialT::available(); }
-  int read(uint8_t)       { return (int)SerialT::read(); }
+  int available(serial_index_t)  { return (int)SerialT::available(); }
+  int read(serial_index_t)       { return (int)SerialT::read(); }
   using SerialT::available;
   using SerialT::read;
   using SerialT::flush;
@@ -170,53 +190,51 @@ template <class Serial0T, class Serial1T, const uint8_t offset = 0, const uint8_
 struct MultiSerial : public SerialBase< MultiSerial<Serial0T, Serial1T, offset, step> > {
   typedef SerialBase< MultiSerial<Serial0T, Serial1T, offset, step> > BaseClassT;
 
-  uint8_t    portMask;
+  SerialMask portMask;
   Serial0T & serial0;
   Serial1T & serial1;
 
-  enum Masks {
-    UsageMask         =  ((1 << step) - 1), // A bit mask containing as many bits as step
-    FirstOutputMask   =  (UsageMask << offset),
-    SecondOutputMask  =  (UsageMask << (offset + step)),
-    AllMask           = FirstOutputMask | SecondOutputMask,
-  };
+  static constexpr uint8_t Usage         =  ((1 << step) - 1); // A bit mask containing as many bits as step
+  static constexpr uint8_t FirstOutput   = (Usage << offset);
+  static constexpr uint8_t SecondOutput  = (Usage << (offset + step));
+  static constexpr uint8_t Both          = FirstOutput | SecondOutput;
 
   NO_INLINE size_t write(uint8_t c) {
     size_t ret = 0;
-    if (portMask & FirstOutputMask)   ret = serial0.write(c);
-    if (portMask & SecondOutputMask)  ret = serial1.write(c) | ret;
+    if (portMask.enabled(FirstOutput))   ret = serial0.write(c);
+    if (portMask.enabled(SecondOutput))  ret = serial1.write(c) | ret;
     return ret;
   }
   NO_INLINE void msgDone() {
-    if (portMask & FirstOutputMask)   serial0.msgDone();
-    if (portMask & SecondOutputMask)  serial1.msgDone();
+    if (portMask.enabled(FirstOutput))   serial0.msgDone();
+    if (portMask.enabled(SecondOutput))  serial1.msgDone();
   }
-  int available(uint8_t index) {
-    if (index >= 0 + offset && index < step + offset)
+  int available(serial_index_t index) {
+    if (index.within(0 + offset, step + offset - 1))
       return serial0.available(index);
-    else if (index >= step + offset && index < 2 * step + offset)
+    else if (index.within(step + offset, 2 * step + offset - 1))
       return serial1.available(index);
     return false;
   }
-  int read(uint8_t index) {
-    if (index >= 0 + offset && index < step + offset)
+  int read(serial_index_t index) {
+    if (index.within(0 + offset, step + offset - 1))
       return serial0.read(index);
-    else if (index >= step + offset && index < 2 * step + offset)
+    else if (index.within(step + offset, 2 * step + offset - 1))
       return serial1.read(index);
     return -1;
   }
   void begin(const long br) {
-    if (portMask & FirstOutputMask)   serial0.begin(br);
-    if (portMask & SecondOutputMask)  serial1.begin(br);
+    if (portMask.enabled(FirstOutput))   serial0.begin(br);
+    if (portMask.enabled(SecondOutput))  serial1.begin(br);
   }
   void end() {
-    if (portMask & FirstOutputMask)   serial0.end();
-    if (portMask & SecondOutputMask)  serial1.end();
+    if (portMask.enabled(FirstOutput))   serial0.end();
+    if (portMask.enabled(SecondOutput))  serial1.end();
   }
   bool connected() {
     bool ret = true;
-    if (portMask & FirstOutputMask)   ret = CALL_IF_EXISTS(bool, &serial0, connected);
-    if (portMask & SecondOutputMask)  ret = ret && CALL_IF_EXISTS(bool, &serial1, connected);
+    if (portMask.enabled(FirstOutput))   ret = CALL_IF_EXISTS(bool, &serial0, connected);
+    if (portMask.enabled(SecondOutput))  ret = ret && CALL_IF_EXISTS(bool, &serial1, connected);
     return ret;
   }
 
@@ -225,15 +243,15 @@ struct MultiSerial : public SerialBase< MultiSerial<Serial0T, Serial1T, offset,
 
   // Redirect flush
   NO_INLINE void flush()      {
-    if (portMask & FirstOutputMask)   serial0.flush();
-    if (portMask & SecondOutputMask)  serial1.flush();
+    if (portMask.enabled(FirstOutput))   serial0.flush();
+    if (portMask.enabled(SecondOutput))  serial1.flush();
   }
   NO_INLINE void flushTX()    {
-    if (portMask & FirstOutputMask)   CALL_IF_EXISTS(void, &serial0, flushTX);
-    if (portMask & SecondOutputMask)  CALL_IF_EXISTS(void, &serial1, flushTX);
+    if (portMask.enabled(FirstOutput))   CALL_IF_EXISTS(void, &serial0, flushTX);
+    if (portMask.enabled(SecondOutput))  CALL_IF_EXISTS(void, &serial1, flushTX);
   }
 
-  MultiSerial(Serial0T & serial0, Serial1T & serial1, int8_t mask = AllMask, const bool e = false) :
+  MultiSerial(Serial0T & serial0, Serial1T & serial1, const SerialMask mask = Both, const bool e = false) :
     BaseClassT(e),
     portMask(mask), serial0(serial0), serial1(serial1) {}
 };

commit 1b9ff68f8ce59a2b142bbabd0fad3d3b377b5997
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Mon Mar 8 04:11:37 2021 -0300

    Fix Host Keepalive serial target (#21283)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index afd43892c7..dc2da13501 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -165,7 +165,7 @@ struct RuntimeSerial : public SerialBase< RuntimeSerial<SerialT> >, public Seria
   RuntimeSerial(const bool e, Args... args) : BaseClassT(e), SerialT(args...), writeHook(0), eofHook(0), userPointer(0) {}
 };
 
-// A class that's duplicating its output conditionally to 2 serial interface
+// A class that duplicates its output conditionally to 2 serial interfaces
 template <class Serial0T, class Serial1T, const uint8_t offset = 0, const uint8_t step = 1>
 struct MultiSerial : public SerialBase< MultiSerial<Serial0T, Serial1T, offset, step> > {
   typedef SerialBase< MultiSerial<Serial0T, Serial1T, offset, step> > BaseClassT;

commit f003e52009ba649f95463a115253d6dadcf361e6
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Thu Feb 25 08:23:29 2021 +0100

    Combined LPC / Serial fixes (#21178)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index ad8ec12b6e..afd43892c7 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -24,6 +24,9 @@
 #include "macros.h"
 #include "serial_base.h"
 
+// Used in multiple places
+typedef int8_t serial_index_t;
+
 // The most basic serial class: it dispatch to the base serial class with no hook whatsoever. This will compile to nothing but the base serial class
 template <class SerialT>
 struct BaseSerial : public SerialBase< BaseSerial<SerialT> >, public SerialT {
@@ -35,10 +38,11 @@ struct BaseSerial : public SerialBase< BaseSerial<SerialT> >, public SerialT {
 
   void msgDone() {}
 
-  bool available(uint8_t index) { return index == 0 && SerialT::available(); }
-  int read(uint8_t index)       { return index == 0 ? SerialT::read() : -1; }
-  bool connected()              { return CALL_IF_EXISTS(bool, static_cast<SerialT*>(this), connected);; }
-  void flushTX()                { CALL_IF_EXISTS(void, static_cast<SerialT*>(this), flushTX); }
+  // We don't care about indices here, since if one can call us, it's the right index anyway
+  int available(uint8_t)  { return (int)SerialT::available(); }
+  int read(uint8_t)       { return (int)SerialT::read(); }
+  bool connected()        { return CALL_IF_EXISTS(bool, static_cast<SerialT*>(this), connected);; }
+  void flushTX()          { CALL_IF_EXISTS(void, static_cast<SerialT*>(this), flushTX); }
 
   // We have 2 implementation of the same method in both base class, let's say which one we want
   using SerialT::available;
@@ -65,18 +69,19 @@ struct ConditionalSerial : public SerialBase< ConditionalSerial<SerialT> > {
   bool    & condition;
   SerialT & out;
   NO_INLINE size_t write(uint8_t c) { if (condition) return out.write(c); return 0; }
-  void flush()            { if (condition) out.flush();  }
-  void begin(long br)     { out.begin(br); }
-  void end()              { out.end(); }
+  void flush()                      { if (condition) out.flush();  }
+  void begin(long br)               { out.begin(br); }
+  void end()                        { out.end(); }
 
   void msgDone() {}
-  bool connected()              { return CALL_IF_EXISTS(bool, &out, connected); }
-  void flushTX()                { CALL_IF_EXISTS(void, &out, flushTX); }
+  bool connected()          { return CALL_IF_EXISTS(bool, &out, connected); }
+  void flushTX()            { CALL_IF_EXISTS(void, &out, flushTX); }
+
+  int available(uint8_t )   { return (int)out.available(); }
+  int read(uint8_t )        { return (int)out.read(); }
+  int available()           { return (int)out.available(); }
+  int read()                { return (int)out.read(); }
 
-  bool available(uint8_t index) { return index == 0 && out.available(); }
-  int read(uint8_t index)       { return index == 0 ? out.read() : -1; }
-  using BaseClassT::available;
-  using BaseClassT::read;
 
   ConditionalSerial(bool & conditionVariable, SerialT & out, const bool e) : BaseClassT(e), condition(conditionVariable), out(out) {}
 };
@@ -97,10 +102,10 @@ struct ForwardSerial : public SerialBase< ForwardSerial<SerialT> > {
   bool connected()              { return Private::HasMember_connected<SerialT>::value ? CALL_IF_EXISTS(bool, &out, connected) : (bool)out; }
   void flushTX()                { CALL_IF_EXISTS(void, &out, flushTX); }
 
-  bool available(uint8_t index) { return index == 0 && out.available(); }
-  int read(uint8_t index)       { return index == 0 ? out.read() : -1; }
-  bool available()              { return out.available(); }
-  int read()                    { return out.read(); }
+  int available(uint8_t)        { return (int)out.available(); }
+  int read(uint8_t)             { return (int)out.read(); }
+  int available()               { return (int)out.available(); }
+  int read()                    { return (int)out.read(); }
 
   ForwardSerial(const bool e, SerialT & out) : BaseClassT(e), out(out) {}
 };
@@ -125,8 +130,8 @@ struct RuntimeSerial : public SerialBase< RuntimeSerial<SerialT> >, public Seria
     if (eofHook) eofHook(userPointer);
   }
 
-  bool available(uint8_t index) { return index == 0 && SerialT::available(); }
-  int read(uint8_t index)       { return index == 0 ? SerialT::read() : -1; }
+  int available(uint8_t)  { return (int)SerialT::available(); }
+  int read(uint8_t)       { return (int)SerialT::read(); }
   using SerialT::available;
   using SerialT::read;
   using SerialT::flush;
@@ -157,21 +162,22 @@ struct RuntimeSerial : public SerialBase< RuntimeSerial<SerialT> >, public Seria
 
   // Forward constructor
   template <typename... Args>
-  RuntimeSerial(const bool e, Args... args) : BaseClassT(e), SerialT(args...) {}
+  RuntimeSerial(const bool e, Args... args) : BaseClassT(e), SerialT(args...), writeHook(0), eofHook(0), userPointer(0) {}
 };
 
 // A class that's duplicating its output conditionally to 2 serial interface
-template <class Serial0T, class Serial1T, const uint8_t offset = 0>
-struct MultiSerial : public SerialBase< MultiSerial<Serial0T, Serial1T, offset> > {
-  typedef SerialBase< MultiSerial<Serial0T, Serial1T, offset> > BaseClassT;
+template <class Serial0T, class Serial1T, const uint8_t offset = 0, const uint8_t step = 1>
+struct MultiSerial : public SerialBase< MultiSerial<Serial0T, Serial1T, offset, step> > {
+  typedef SerialBase< MultiSerial<Serial0T, Serial1T, offset, step> > BaseClassT;
 
   uint8_t    portMask;
   Serial0T & serial0;
   Serial1T & serial1;
 
   enum Masks {
-    FirstOutputMask   =  (1 << offset),
-    SecondOutputMask  =  (1 << (offset + 1)),
+    UsageMask         =  ((1 << step) - 1), // A bit mask containing as many bits as step
+    FirstOutputMask   =  (UsageMask << offset),
+    SecondOutputMask  =  (UsageMask << (offset + step)),
     AllMask           = FirstOutputMask | SecondOutputMask,
   };
 
@@ -185,19 +191,19 @@ struct MultiSerial : public SerialBase< MultiSerial<Serial0T, Serial1T, offset>
     if (portMask & FirstOutputMask)   serial0.msgDone();
     if (portMask & SecondOutputMask)  serial1.msgDone();
   }
-  bool available(uint8_t index) {
-    switch(index) {
-      case 0 + offset: return serial0.available();
-      case 1 + offset: return serial1.available();
-      default: return false;
-    }
+  int available(uint8_t index) {
+    if (index >= 0 + offset && index < step + offset)
+      return serial0.available(index);
+    else if (index >= step + offset && index < 2 * step + offset)
+      return serial1.available(index);
+    return false;
   }
-  NO_INLINE int read(uint8_t index) {
-    switch(index) {
-      case 0 + offset: return serial0.read();
-      case 1 + offset: return serial1.read();
-      default: return -1;
-    }
+  int read(uint8_t index) {
+    if (index >= 0 + offset && index < step + offset)
+      return serial0.read(index);
+    else if (index >= step + offset && index < 2 * step + offset)
+      return serial1.read(index);
+    return -1;
   }
   void begin(const long br) {
     if (portMask & FirstOutputMask)   serial0.begin(br);

commit e7c711996bd3080f5e343eff5556736cbf2e2416
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 8 07:37:24 2021 +0100

    Serial refactor. Default 8-bit ECHO to int, not char (#20985)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index 45e64d7793..ad8ec12b6e 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -21,6 +21,7 @@
  */
 #pragma once
 
+#include "macros.h"
 #include "serial_base.h"
 
 // The most basic serial class: it dispatch to the base serial class with no hook whatsoever. This will compile to nothing but the base serial class
@@ -37,6 +38,8 @@ struct BaseSerial : public SerialBase< BaseSerial<SerialT> >, public SerialT {
   bool available(uint8_t index) { return index == 0 && SerialT::available(); }
   int read(uint8_t index)       { return index == 0 ? SerialT::read() : -1; }
   bool connected()              { return CALL_IF_EXISTS(bool, static_cast<SerialT*>(this), connected);; }
+  void flushTX()                { CALL_IF_EXISTS(void, static_cast<SerialT*>(this), flushTX); }
+
   // We have 2 implementation of the same method in both base class, let's say which one we want
   using SerialT::available;
   using SerialT::read;
@@ -68,6 +71,7 @@ struct ConditionalSerial : public SerialBase< ConditionalSerial<SerialT> > {
 
   void msgDone() {}
   bool connected()              { return CALL_IF_EXISTS(bool, &out, connected); }
+  void flushTX()                { CALL_IF_EXISTS(void, &out, flushTX); }
 
   bool available(uint8_t index) { return index == 0 && out.available(); }
   int read(uint8_t index)       { return index == 0 ? out.read() : -1; }
@@ -91,6 +95,7 @@ struct ForwardSerial : public SerialBase< ForwardSerial<SerialT> > {
   void msgDone() {}
   // Existing instances implement Arduino's operator bool, so use that if it's available
   bool connected()              { return Private::HasMember_connected<SerialT>::value ? CALL_IF_EXISTS(bool, &out, connected) : (bool)out; }
+  void flushTX()                { CALL_IF_EXISTS(void, &out, flushTX); }
 
   bool available(uint8_t index) { return index == 0 && out.available(); }
   int read(uint8_t index)       { return index == 0 ? out.read() : -1; }
@@ -131,11 +136,11 @@ struct RuntimeSerial : public SerialBase< RuntimeSerial<SerialT> >, public Seria
   using BaseClassT::print;
   using BaseClassT::println;
 
-
   // Underlying implementation might use Arduino's bool operator
   bool connected() {
     return Private::HasMember_connected<SerialT>::value ? CALL_IF_EXISTS(bool, static_cast<SerialT*>(this), connected) : static_cast<SerialT*>(this)->operator bool();
   }
+  void flushTX()                { CALL_IF_EXISTS(void, static_cast<SerialT*>(this), flushTX); }
 
   void setHook(WriteHook writeHook = 0, EndOfMessageHook eofHook = 0, void * userPointer = 0) {
     // Order is important here as serial code can be called inside interrupts

commit c74f972627ab8dcf69a637268cf86682959bd18e
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 1 01:18:39 2021 +0100

    LVGL UI G-code console (#20755)

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index e14b821a9c..45e64d7793 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -131,10 +131,11 @@ struct RuntimeSerial : public SerialBase< RuntimeSerial<SerialT> >, public Seria
   using BaseClassT::print;
   using BaseClassT::println;
 
+
   // Underlying implementation might use Arduino's bool operator
-  bool connected() { 
-    return Private::HasMember_connected<SerialT>::value ? CALL_IF_EXISTS(bool, static_cast<SerialT*>(this), connected) : static_cast<SerialT*>(this)->operator bool(); 
-  }  
+  bool connected() {
+    return Private::HasMember_connected<SerialT>::value ? CALL_IF_EXISTS(bool, static_cast<SerialT*>(this), connected) : static_cast<SerialT*>(this)->operator bool();
+  }
 
   void setHook(WriteHook writeHook = 0, EndOfMessageHook eofHook = 0, void * userPointer = 0) {
     // Order is important here as serial code can be called inside interrupts

commit 9e004a94963771167bb3f5d6fa51ccd671a27a19
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Fri Jan 29 02:59:16 2021 +0100

    Optimize serial output code for size (#20911)

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index 17cf8bdd7d..e14b821a9c 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -61,7 +61,7 @@ struct ConditionalSerial : public SerialBase< ConditionalSerial<SerialT> > {
 
   bool    & condition;
   SerialT & out;
-  size_t write(uint8_t c) { if (condition) return out.write(c); return 0; }
+  NO_INLINE size_t write(uint8_t c) { if (condition) return out.write(c); return 0; }
   void flush()            { if (condition) out.flush();  }
   void begin(long br)     { out.begin(br); }
   void end()              { out.end(); }
@@ -83,7 +83,7 @@ struct ForwardSerial : public SerialBase< ForwardSerial<SerialT> > {
   typedef SerialBase< ForwardSerial<SerialT> > BaseClassT;
 
   SerialT & out;
-  size_t write(uint8_t c) { return out.write(c); }
+  NO_INLINE size_t write(uint8_t c) { return out.write(c); }
   void flush()            { out.flush();  }
   void begin(long br)     { out.begin(br); }
   void end()              { out.end(); }
@@ -111,12 +111,12 @@ struct RuntimeSerial : public SerialBase< RuntimeSerial<SerialT> >, public Seria
   EndOfMessageHook eofHook;
   void *           userPointer;
 
-  size_t write(uint8_t c) {
+  NO_INLINE size_t write(uint8_t c) {
     if (writeHook) writeHook(userPointer, c);
     return SerialT::write(c);
   }
 
-  void msgDone() {
+  NO_INLINE void msgDone() {
     if (eofHook) eofHook(userPointer);
   }
 
@@ -130,7 +130,11 @@ struct RuntimeSerial : public SerialBase< RuntimeSerial<SerialT> >, public Seria
 
   using BaseClassT::print;
   using BaseClassT::println;
-  
+
+  // Underlying implementation might use Arduino's bool operator
+  bool connected() { 
+    return Private::HasMember_connected<SerialT>::value ? CALL_IF_EXISTS(bool, static_cast<SerialT*>(this), connected) : static_cast<SerialT*>(this)->operator bool(); 
+  }  
 
   void setHook(WriteHook writeHook = 0, EndOfMessageHook eofHook = 0, void * userPointer = 0) {
     // Order is important here as serial code can be called inside interrupts
@@ -165,13 +169,13 @@ struct MultiSerial : public SerialBase< MultiSerial<Serial0T, Serial1T, offset>
     AllMask           = FirstOutputMask | SecondOutputMask,
   };
 
-  size_t write(uint8_t c) {
+  NO_INLINE size_t write(uint8_t c) {
     size_t ret = 0;
     if (portMask & FirstOutputMask)   ret = serial0.write(c);
     if (portMask & SecondOutputMask)  ret = serial1.write(c) | ret;
     return ret;
   }
-  void msgDone() {
+  NO_INLINE void msgDone() {
     if (portMask & FirstOutputMask)   serial0.msgDone();
     if (portMask & SecondOutputMask)  serial1.msgDone();
   }
@@ -182,7 +186,7 @@ struct MultiSerial : public SerialBase< MultiSerial<Serial0T, Serial1T, offset>
       default: return false;
     }
   }
-  int read(uint8_t index) {
+  NO_INLINE int read(uint8_t index) {
     switch(index) {
       case 0 + offset: return serial0.read();
       case 1 + offset: return serial1.read();
@@ -208,11 +212,11 @@ struct MultiSerial : public SerialBase< MultiSerial<Serial0T, Serial1T, offset>
   using BaseClassT::read;
 
   // Redirect flush
-  void flush()      {
+  NO_INLINE void flush()      {
     if (portMask & FirstOutputMask)   serial0.flush();
     if (portMask & SecondOutputMask)  serial1.flush();
   }
-  void flushTX()    {
+  NO_INLINE void flushTX()    {
     if (portMask & FirstOutputMask)   CALL_IF_EXISTS(void, &serial0, flushTX);
     if (portMask & SecondOutputMask)  CALL_IF_EXISTS(void, &serial1, flushTX);
   }

commit 3f01b222b2b4f77cff66096dd5a18a64828e1fa4
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Thu Jan 28 09:02:06 2021 +0100

    Refactor serial class with templates (#20783)

diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
new file mode 100644
index 0000000000..17cf8bdd7d
--- /dev/null
+++ b/Marlin/src/core/serial_hook.h
@@ -0,0 +1,230 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "serial_base.h"
+
+// The most basic serial class: it dispatch to the base serial class with no hook whatsoever. This will compile to nothing but the base serial class
+template <class SerialT>
+struct BaseSerial : public SerialBase< BaseSerial<SerialT> >, public SerialT {
+  typedef SerialBase< BaseSerial<SerialT> > BaseClassT;
+
+  // It's required to implement a write method here to help compiler disambiguate what method to call
+  using SerialT::write;
+  using SerialT::flush;
+
+  void msgDone() {}
+
+  bool available(uint8_t index) { return index == 0 && SerialT::available(); }
+  int read(uint8_t index)       { return index == 0 ? SerialT::read() : -1; }
+  bool connected()              { return CALL_IF_EXISTS(bool, static_cast<SerialT*>(this), connected);; }
+  // We have 2 implementation of the same method in both base class, let's say which one we want
+  using SerialT::available;
+  using SerialT::read;
+  using SerialT::begin;
+  using SerialT::end;
+
+  using BaseClassT::print;
+  using BaseClassT::println;
+
+  BaseSerial(const bool e) : BaseClassT(e) {}
+
+  // Forward constructor
+  template <typename... Args>
+  BaseSerial(const bool e, Args... args) : BaseClassT(e), SerialT(args...) {}
+};
+
+// A serial with a condition checked at runtime for its output
+// A bit less efficient than static dispatching but since it's only used for ethernet's serial output right now, it's ok.
+template <class SerialT>
+struct ConditionalSerial : public SerialBase< ConditionalSerial<SerialT> > {
+  typedef SerialBase< ConditionalSerial<SerialT> > BaseClassT;
+
+  bool    & condition;
+  SerialT & out;
+  size_t write(uint8_t c) { if (condition) return out.write(c); return 0; }
+  void flush()            { if (condition) out.flush();  }
+  void begin(long br)     { out.begin(br); }
+  void end()              { out.end(); }
+
+  void msgDone() {}
+  bool connected()              { return CALL_IF_EXISTS(bool, &out, connected); }
+
+  bool available(uint8_t index) { return index == 0 && out.available(); }
+  int read(uint8_t index)       { return index == 0 ? out.read() : -1; }
+  using BaseClassT::available;
+  using BaseClassT::read;
+
+  ConditionalSerial(bool & conditionVariable, SerialT & out, const bool e) : BaseClassT(e), condition(conditionVariable), out(out) {}
+};
+
+// A simple foward class that taking a reference to an existing serial instance (likely created in their respective framework)
+template <class SerialT>
+struct ForwardSerial : public SerialBase< ForwardSerial<SerialT> > {
+  typedef SerialBase< ForwardSerial<SerialT> > BaseClassT;
+
+  SerialT & out;
+  size_t write(uint8_t c) { return out.write(c); }
+  void flush()            { out.flush();  }
+  void begin(long br)     { out.begin(br); }
+  void end()              { out.end(); }
+
+  void msgDone() {}
+  // Existing instances implement Arduino's operator bool, so use that if it's available
+  bool connected()              { return Private::HasMember_connected<SerialT>::value ? CALL_IF_EXISTS(bool, &out, connected) : (bool)out; }
+
+  bool available(uint8_t index) { return index == 0 && out.available(); }
+  int read(uint8_t index)       { return index == 0 ? out.read() : -1; }
+  bool available()              { return out.available(); }
+  int read()                    { return out.read(); }
+
+  ForwardSerial(const bool e, SerialT & out) : BaseClassT(e), out(out) {}
+};
+
+// A class that's can be hooked and unhooked at runtime, useful to capturing the output of the serial interface
+template <class SerialT>
+struct RuntimeSerial : public SerialBase< RuntimeSerial<SerialT> >, public SerialT {
+  typedef SerialBase< RuntimeSerial<SerialT> > BaseClassT;
+  typedef void (*WriteHook)(void * userPointer, uint8_t c);
+  typedef void (*EndOfMessageHook)(void * userPointer);
+
+  WriteHook        writeHook;
+  EndOfMessageHook eofHook;
+  void *           userPointer;
+
+  size_t write(uint8_t c) {
+    if (writeHook) writeHook(userPointer, c);
+    return SerialT::write(c);
+  }
+
+  void msgDone() {
+    if (eofHook) eofHook(userPointer);
+  }
+
+  bool available(uint8_t index) { return index == 0 && SerialT::available(); }
+  int read(uint8_t index)       { return index == 0 ? SerialT::read() : -1; }
+  using SerialT::available;
+  using SerialT::read;
+  using SerialT::flush;
+  using SerialT::begin;
+  using SerialT::end;
+
+  using BaseClassT::print;
+  using BaseClassT::println;
+  
+
+  void setHook(WriteHook writeHook = 0, EndOfMessageHook eofHook = 0, void * userPointer = 0) {
+    // Order is important here as serial code can be called inside interrupts
+    // When setting a hook, the user pointer must be set first so if writeHook is called as soon as it's set, it'll be valid
+    if (userPointer) this->userPointer = userPointer;
+    this->writeHook = writeHook;
+    this->eofHook = eofHook;
+    // Order is important here because of asynchronous access here
+    // When unsetting a hook, the user pointer must be unset last so that any pending writeHook is still using the old pointer
+    if (!userPointer) this->userPointer = 0;
+  }
+
+  RuntimeSerial(const bool e) : BaseClassT(e), writeHook(0), eofHook(0), userPointer(0) {}
+
+  // Forward constructor
+  template <typename... Args>
+  RuntimeSerial(const bool e, Args... args) : BaseClassT(e), SerialT(args...) {}
+};
+
+// A class that's duplicating its output conditionally to 2 serial interface
+template <class Serial0T, class Serial1T, const uint8_t offset = 0>
+struct MultiSerial : public SerialBase< MultiSerial<Serial0T, Serial1T, offset> > {
+  typedef SerialBase< MultiSerial<Serial0T, Serial1T, offset> > BaseClassT;
+
+  uint8_t    portMask;
+  Serial0T & serial0;
+  Serial1T & serial1;
+
+  enum Masks {
+    FirstOutputMask   =  (1 << offset),
+    SecondOutputMask  =  (1 << (offset + 1)),
+    AllMask           = FirstOutputMask | SecondOutputMask,
+  };
+
+  size_t write(uint8_t c) {
+    size_t ret = 0;
+    if (portMask & FirstOutputMask)   ret = serial0.write(c);
+    if (portMask & SecondOutputMask)  ret = serial1.write(c) | ret;
+    return ret;
+  }
+  void msgDone() {
+    if (portMask & FirstOutputMask)   serial0.msgDone();
+    if (portMask & SecondOutputMask)  serial1.msgDone();
+  }
+  bool available(uint8_t index) {
+    switch(index) {
+      case 0 + offset: return serial0.available();
+      case 1 + offset: return serial1.available();
+      default: return false;
+    }
+  }
+  int read(uint8_t index) {
+    switch(index) {
+      case 0 + offset: return serial0.read();
+      case 1 + offset: return serial1.read();
+      default: return -1;
+    }
+  }
+  void begin(const long br) {
+    if (portMask & FirstOutputMask)   serial0.begin(br);
+    if (portMask & SecondOutputMask)  serial1.begin(br);
+  }
+  void end() {
+    if (portMask & FirstOutputMask)   serial0.end();
+    if (portMask & SecondOutputMask)  serial1.end();
+  }
+  bool connected() {
+    bool ret = true;
+    if (portMask & FirstOutputMask)   ret = CALL_IF_EXISTS(bool, &serial0, connected);
+    if (portMask & SecondOutputMask)  ret = ret && CALL_IF_EXISTS(bool, &serial1, connected);
+    return ret;
+  }
+
+  using BaseClassT::available;
+  using BaseClassT::read;
+
+  // Redirect flush
+  void flush()      {
+    if (portMask & FirstOutputMask)   serial0.flush();
+    if (portMask & SecondOutputMask)  serial1.flush();
+  }
+  void flushTX()    {
+    if (portMask & FirstOutputMask)   CALL_IF_EXISTS(void, &serial0, flushTX);
+    if (portMask & SecondOutputMask)  CALL_IF_EXISTS(void, &serial1, flushTX);
+  }
+
+  MultiSerial(Serial0T & serial0, Serial1T & serial1, int8_t mask = AllMask, const bool e = false) :
+    BaseClassT(e),
+    portMask(mask), serial0(serial0), serial1(serial1) {}
+};
+
+// Build the actual serial object depending on current configuration
+#define Serial0Type TERN(SERIAL_RUNTIME_HOOK, RuntimeSerial, BaseSerial)
+#define ForwardSerial0Type TERN(SERIAL_RUNTIME_HOOK, RuntimeSerial, ForwardSerial)
+#ifdef HAS_MULTI_SERIAL
+  #define Serial1Type ConditionalSerial
+#endif
