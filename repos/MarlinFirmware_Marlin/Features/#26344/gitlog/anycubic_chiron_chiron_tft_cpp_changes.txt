commit 521e7eafce4921a36532e0a89f2cc7417c2c4e21
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 21 15:42:56 2024 -0500

    üßë‚Äçüíª Clarify media "mounted"

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 5e80b79acf..9e38face6f 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -564,8 +564,8 @@ void ChironTFT::panelInfo(uint8_t req) {
     } break;
 
     case 8:   // A8 Get SD Card list A8 S0
-      if (!isMediaInserted()) safe_delay(500);
-      if (!isMediaInserted())   // Make sure the card is removed
+      if (!isMediaMounted()) safe_delay(500);
+      if (!isMediaMounted())   // Make sure the card is removed
         tftSendLn(AC_msg_no_sd_card);
       else if (panel_command[3] == 'S')
         sendFileList( atoi( &panel_command[4] ) );

commit f5f6c37c17edd6e710bc48578aa325f317d47d51
Author: Alexander Thomas Julian <ajulian@hawk.iit.edu>
Date:   Sun May 12 13:25:14 2024 -0500

    üêõ LCD Bed Tramming fixes (#26962)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 63b1ef9c19..5e80b79acf 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -780,11 +780,11 @@ void ChironTFT::panelProcess(uint8_t req) {
               DEBUG_ECHOLNPGM("Moving to mesh point at x: ", pos.x, " y: ", pos.y, " z: ", pos_z);
             #endif
             // Go up before moving
-            setAxisPosition_mm(3.0,Z);
+            setAxisPosition_mm(3.0f, Z);
 
-            setAxisPosition_mm(17 + (93 * pos.x), X);
-            setAxisPosition_mm(20 + (93 * pos.y), Y);
-            setAxisPosition_mm(0.0, Z);
+            setAxisPosition_mm(17.0f + (93.0f * pos.x), X);
+            setAxisPosition_mm(20.0f + (93.0f * pos.y), Y);
+            setAxisPosition_mm(0.0f, Z);
             #if ACDEBUG(AC_INFO)
               DEBUG_ECHOLNPGM("Current Z: ", getAxisPosition_mm(Z));
             #endif

commit dfec58e5dced9fd794cc4a8e7a88a4d34f0cacda
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 8 00:47:18 2023 -0600

    ‚ö°Ô∏è Use strlcpy with buffer size (#26513)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index df0c4df30d..63b1ef9c19 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -433,12 +433,12 @@ void ChironTFT::sendFileList(int8_t startindex) {
 }
 
 void ChironTFT::selectFile() {
-  const size_t namelen = command_len - 4 + (panel_type <= AC_panel_new);
-  strncpy(selectedfile, panel_command + 4, namelen);
-  selectedfile[namelen] = '\0';
+  const size_t fnlen = command_len - 4 + (panel_type <= AC_panel_new);
+  strlcpy(selectedfile, panel_command + 4, fnlen + 1);
   #if ACDEBUG(AC_FILE)
     DEBUG_ECHOLNPGM(" Selected File: ", selectedfile);
   #endif
+
   switch (selectedfile[0]) {
     case '/':   // Valid file selected
       tftSendLn(AC_msg_sd_file_open_success);
@@ -449,10 +449,9 @@ void ChironTFT::selectFile() {
       tftSendLn(AC_msg_sd_file_open_failed);
       sendFileList( 0 );
       break;
-    default:   // enter sub folder
-      // for new panel remove the '.GCO' tag that was added to the end of the path
-      if (panel_type <= AC_panel_new)
-        selectedfile[strlen(selectedfile) - 4] = '\0';
+    default:    // enter subfolder
+      // For new panel remove the '.GCO' tag that was added to the end of the path
+      if (panel_type <= AC_panel_new) selectedfile[fnlen - 4] = '\0';
       filenavigator.changeDIR(selectedfile);
       tftSendLn(AC_msg_sd_file_open_failed);
       sendFileList( 0 );

commit 36e66bdd9ff22ddfdcaa36ac8a9b9448c78ca44c
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Nov 18 09:11:59 2023 +1300

    üîß Define MarlinUI axis moves with lists (#26344)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 6c8c3aa3a5..df0c4df30d 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -433,14 +433,9 @@ void ChironTFT::sendFileList(int8_t startindex) {
 }
 
 void ChironTFT::selectFile() {
-  if (panel_type <= AC_panel_new) {
-    strncpy(selectedfile, panel_command + 4, command_len - 3);
-    selectedfile[command_len - 4] = '\0';
-  }
-  else {
-    strncpy(selectedfile, panel_command + 4, command_len - 4);
-    selectedfile[command_len - 5] = '\0';
-  }
+  const size_t namelen = command_len - 4 + (panel_type <= AC_panel_new);
+  strncpy(selectedfile, panel_command + 4, namelen);
+  selectedfile[namelen] = '\0';
   #if ACDEBUG(AC_FILE)
     DEBUG_ECHOLNPGM(" Selected File: ", selectedfile);
   #endif

commit c3694f1c038fa20ad749118b0a1c7aa88e3dd5f2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 14 17:24:50 2023 -0500

    üé® Lowercase methods, functions, data members (#25939)
    
    For: TFT, DGUS, MarlinUI, Anycubic, JyersUI, CrealityUI

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 7d44e63537..6c8c3aa3a5 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -103,7 +103,7 @@ void ChironTFT::startup() {
   injectCommands(AC_cmnd_enable_leveling);
 
   // startup tunes are defined in Tunes.h
-  PlayTune(TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn));
+  playTune(TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn));
 
   #if ACDEBUGLEVEL
     DEBUG_ECHOLNPGM("AC Debug Level ", ACDEBUGLEVEL);
@@ -191,7 +191,7 @@ void ChironTFT::filamentRunout()  {
   // 1 Signal filament out
   last_error = AC_error_filament_runout;
   tftSendLn(isPrintingFromMedia() ? AC_msg_filament_out_alert : AC_msg_filament_out_block);
-  PlayTune(FilamentOut);
+  playTune(FilamentOut);
 }
 
 void ChironTFT::confirmationRequest(const char * const msg)  {
@@ -214,7 +214,7 @@ void ChironTFT::confirmationRequest(const char * const msg)  {
       if (strcmp_P(msg, MARLIN_msg_heater_timeout) == 0) {
         pause_state = AC_paused_heater_timed_out;
         tftSendLn(AC_msg_paused); // enable continue button
-        PlayTune(HeaterTimeout);
+        playTune(HeaterTimeout);
       }
       // Reheat finished, send acknowledgement
       else if (strcmp_P(msg, MARLIN_msg_reheat_done) == 0) {
@@ -252,7 +252,7 @@ void ChironTFT::statusChange(const char * const msg)  {
       }
       // If probing fails don't save the mesh raise the probe above the bad point
       if (strcmp_P(msg, MARLIN_msg_probing_failed) == 0) {
-        PlayTune(BeepBeepBeeep);
+        playTune(BeepBeepBeeep);
         injectCommands(F("G1 Z50 F500"));
         tftSendLn(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
@@ -306,7 +306,7 @@ void ChironTFT::statusChange(const char * const msg)  {
 void ChironTFT::powerLossRecovery()  {
   printer_state = AC_printer_resuming_from_power_outage; // Play tune to notify user we can recover.
   last_error = AC_error_powerloss;
-  PlayTune(SOS);
+  playTune(SOS);
   SERIAL_ECHOLN(AC_msg_powerloss_recovery);
 }
 

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ‚ôªÔ∏è Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index bcf78746a2..7d44e63537 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -88,14 +88,9 @@ void ChironTFT::startup() {
   // So we need to know what we are working with.
   // Panel type can be defined otherwise detect it automatically
   switch (panel_type) {
-    case AC_panel_new:
-      SERIAL_ECHOLNF(AC_msg_new_panel_set);
-      break;
-    case AC_panel_standard:
-      SERIAL_ECHOLNF(AC_msg_old_panel_set);
-      break;
-    default:
-      SERIAL_ECHOLNF(AC_msg_auto_panel_detection);
+    case AC_panel_new: SERIAL_ECHOLN(AC_msg_new_panel_set); break;
+    case AC_panel_standard: SERIAL_ECHOLN(AC_msg_old_panel_set); break;
+    default: SERIAL_ECHOLN(AC_msg_auto_panel_detection);
       detectPanelType();
       break;
   }
@@ -312,7 +307,7 @@ void ChironTFT::powerLossRecovery()  {
   printer_state = AC_printer_resuming_from_power_outage; // Play tune to notify user we can recover.
   last_error = AC_error_powerloss;
   PlayTune(SOS);
-  SERIAL_ECHOLNF(AC_msg_powerloss_recovery);
+  SERIAL_ECHOLN(AC_msg_powerloss_recovery);
 }
 
 void ChironTFT::printComplete() {
@@ -323,7 +318,7 @@ void ChironTFT::printComplete() {
 
 void ChironTFT::tftSend(FSTR_P const fstr/*=nullptr*/) {  // A helper to print PROGMEM string to the panel
   #if ACDEBUG(AC_SOME)
-    DEBUG_ECHOF(fstr);
+    DEBUG_ECHO(fstr);
   #endif
   PGM_P str = FTOP(fstr);
   while (const char c = pgm_read_byte(str++)) TFTSer.write(c);
@@ -447,7 +442,7 @@ void ChironTFT::selectFile() {
     selectedfile[command_len - 5] = '\0';
   }
   #if ACDEBUG(AC_FILE)
-    DEBUG_ECHOLNPGM(" Selected File: ",selectedfile);
+    DEBUG_ECHOLNPGM(" Selected File: ", selectedfile);
   #endif
   switch (selectedfile[0]) {
     case '/':   // Valid file selected
@@ -494,7 +489,7 @@ void ChironTFT::processPanelRequest() {
         if (tpos >= 0) {
           if (panel_command[tpos + 1] == 'X' && panel_command[tpos + 2] =='Y') {
             panel_type = AC_panel_standard;
-            SERIAL_ECHOLNF(AC_msg_old_panel_detected);
+            SERIAL_ECHOLN(AC_msg_old_panel_detected);
           }
         }
         else {
@@ -504,7 +499,7 @@ void ChironTFT::processPanelRequest() {
           if (tpos >= 0) {
             if (panel_command[tpos + 1] == '0' && panel_command[tpos + 2] ==']') {
               panel_type = AC_panel_new;
-              SERIAL_ECHOLNF(AC_msg_new_panel_detected);
+              SERIAL_ECHOLN(AC_msg_new_panel_detected);
             }
           }
         }
@@ -828,7 +823,7 @@ void ChironTFT::panelProcess(uint8_t req) {
         if (!isPrinting()) {
           injectCommands(F("M501\nM420 S1"));
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
-          SERIAL_ECHOLNF(AC_msg_mesh_changes_abandoned);
+          SERIAL_ECHOLN(AC_msg_mesh_changes_abandoned);
         }
       }
 
@@ -836,7 +831,7 @@ void ChironTFT::panelProcess(uint8_t req) {
         if (!isPrinting()) {
           setAxisPosition_mm(1.0,Z); // Lift nozzle before any further movements are made
           injectCommands(F("M500"));
-          SERIAL_ECHOLNF(AC_msg_mesh_changes_saved);
+          SERIAL_ECHOLN(AC_msg_mesh_changes_saved);
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
         }
       }

commit 37d0f49a82cd2e4d91dce4e62671b266924eb2a7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 24 01:05:55 2023 -0500

    üßë‚Äçüíª Misc. ExtUI LCD cleanup (#25872)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index f3bc64a024..bcf78746a2 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -42,9 +42,13 @@
 #include "../../../libs/numtostr.h"
 #include "../../../MarlinCore.h"
 
+#define DEBUG_OUT ACDEBUGLEVEL
+#include "../../../core/debug_out.h"
+
 namespace Anycubic {
 
-ChironTFT Chiron;
+ChironTFT chiron;
+
 #if AUTO_DETECT_CHIRON_TFT
   panel_type_t   ChironTFT::panel_type = AC_panel_unknown;
 #endif
@@ -60,7 +64,7 @@ uint8_t          ChironTFT::command_len;
 float            ChironTFT::live_Zoffset;
 file_menu_t      ChironTFT::file_menu;
 
-void ChironTFT::Startup() {
+void ChironTFT::startup() {
   selectedfile[0]   = '\0';
   panel_command[0]  = '\0';
   command_len       = 0;
@@ -92,73 +96,73 @@ void ChironTFT::Startup() {
       break;
     default:
       SERIAL_ECHOLNF(AC_msg_auto_panel_detection);
-      DetectPanelType();
+      detectPanelType();
       break;
   }
 
   // Signal Board has reset
-  SendtoTFTLN(AC_msg_main_board_has_reset);
+  tftSendLn(AC_msg_main_board_has_reset);
 
   // Enable leveling and Disable end stops during print
   // as Z home places nozzle above the bed so we need to allow it past the end stops
   injectCommands(AC_cmnd_enable_leveling);
 
-  // Startup tunes are defined in Tunes.h
+  // startup tunes are defined in Tunes.h
   PlayTune(TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn));
 
   #if ACDEBUGLEVEL
-    SERIAL_ECHOLNPGM("AC Debug Level ", ACDEBUGLEVEL);
+    DEBUG_ECHOLNPGM("AC Debug Level ", ACDEBUGLEVEL);
   #endif
-  SendtoTFTLN(AC_msg_ready);
+  tftSendLn(AC_msg_ready);
 }
 
-void ChironTFT::DetectPanelType() {
+void ChironTFT::detectPanelType() {
   #if AUTO_DETECT_CHIRON_TFT
     // Send a query to the TFT
-    SendtoTFTLN(AC_Test_for_OldPanel); // The panel will respond with 'SXY 480 320'
-    SendtoTFTLN(AC_Test_for_NewPanel); // the panel will respond with '[0]=0   ' to '[19]=0   '
+    tftSendLn(AC_Test_for_OldPanel); // The panel will respond with 'SXY 480 320'
+    tftSendLn(AC_Test_for_NewPanel); // the panel will respond with '[0]=0   ' to '[19]=0   '
   #endif
 }
 
-void ChironTFT::IdleLoop()  {
-  if (ReadTFTCommand()) {
-    ProcessPanelRequest();
+void ChironTFT::idleLoop()  {
+  if (readTFTCommand()) {
+    processPanelRequest();
     command_len = 0;
   }
-  CheckHeaters();
+  checkHeaters();
 }
 
-void ChironTFT::PrinterKilled(FSTR_P const error, FSTR_P const component)  {
-  SendtoTFTLN(AC_msg_kill_lcd);
+void ChironTFT::printerKilled(FSTR_P const error, FSTR_P const component)  {
+  tftSendLn(AC_msg_kill_lcd);
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPGM("PrinterKilled()\nerror: ", error , "\ncomponent: ", component);
+    DEBUG_ECHOLNPGM("printerKilled()\nerror: ", error , "\ncomponent: ", component);
   #endif
 }
 
-void ChironTFT::MediaEvent(media_event_t event)  {
+void ChironTFT::mediaEvent(media_event_t event)  {
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPGM("ProcessMediaStatus() ", event);
+    DEBUG_ECHOLNPGM("ProcessMediaStatus() ", event);
   #endif
   switch (event) {
     case AC_media_inserted:
-      SendtoTFTLN(AC_msg_sd_card_inserted);
+      tftSendLn(AC_msg_sd_card_inserted);
       break;
 
     case AC_media_removed:
-      SendtoTFTLN(AC_msg_sd_card_removed);
+      tftSendLn(AC_msg_sd_card_removed);
       break;
 
     case AC_media_error:
       last_error = AC_error_noSD;
-      SendtoTFTLN(AC_msg_no_sd_card);
+      tftSendLn(AC_msg_no_sd_card);
       break;
   }
 }
 
-void ChironTFT::TimerEvent(timer_event_t event)  {
+void ChironTFT::timerEvent(timer_event_t event)  {
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPGM("TimerEvent() ", event);
-    SERIAL_ECHOLNPGM("Printer State: ", printer_state);
+    DEBUG_ECHOLNPGM("timerEvent() ", event);
+    DEBUG_ECHOLNPGM("Printer State: ", printer_state);
   #endif
 
   switch (event) {
@@ -166,44 +170,44 @@ void ChironTFT::TimerEvent(timer_event_t event)  {
       live_Zoffset = 0.0; // reset print offset
       setSoftEndstopState(false);  // disable endstops to print
       printer_state = AC_printer_printing;
-      SendtoTFTLN(AC_msg_print_from_sd_card);
+      tftSendLn(AC_msg_print_from_sd_card);
     } break;
 
     case AC_timer_paused: {
       printer_state = AC_printer_paused;
       pause_state   = AC_paused_idle;
-      SendtoTFTLN(AC_msg_paused);
+      tftSendLn(AC_msg_paused);
     } break;
 
     case AC_timer_stopped: {
       if (printer_state != AC_printer_idle) {
         printer_state = AC_printer_stopping;
-        SendtoTFTLN(AC_msg_print_complete);
+        tftSendLn(AC_msg_print_complete);
       }
       setSoftEndstopState(true); // enable endstops
     } break;
   }
 }
 
-void ChironTFT::FilamentRunout()  {
+void ChironTFT::filamentRunout()  {
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPGM("FilamentRunout() printer_state ", printer_state);
+    DEBUG_ECHOLNPGM("filamentRunout() printer_state ", printer_state);
   #endif
   // 1 Signal filament out
   last_error = AC_error_filament_runout;
-  SendtoTFTLN(isPrintingFromMedia() ? AC_msg_filament_out_alert : AC_msg_filament_out_block);
+  tftSendLn(isPrintingFromMedia() ? AC_msg_filament_out_alert : AC_msg_filament_out_block);
   PlayTune(FilamentOut);
 }
 
-void ChironTFT::ConfirmationRequest(const char * const msg)  {
+void ChironTFT::confirmationRequest(const char * const msg)  {
   // M108 continue
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPGM("ConfirmationRequest() ", msg, " printer_state:", printer_state);
+    DEBUG_ECHOLNPGM("confirmationRequest() ", msg, " printer_state:", printer_state);
   #endif
   switch (printer_state) {
     case AC_printer_pausing: {
       if (strcmp_P(msg, MARLIN_msg_print_paused) == 0 || strcmp_P(msg, MARLIN_msg_nozzle_parked) == 0) {
-        SendtoTFTLN(AC_msg_paused); // enable continue button
+        tftSendLn(AC_msg_paused); // enable continue button
         printer_state = AC_printer_paused;
       }
     } break;
@@ -214,18 +218,18 @@ void ChironTFT::ConfirmationRequest(const char * const msg)  {
       // Heater timeout, send acknowledgement
       if (strcmp_P(msg, MARLIN_msg_heater_timeout) == 0) {
         pause_state = AC_paused_heater_timed_out;
-        SendtoTFTLN(AC_msg_paused); // enable continue button
+        tftSendLn(AC_msg_paused); // enable continue button
         PlayTune(HeaterTimeout);
       }
       // Reheat finished, send acknowledgement
       else if (strcmp_P(msg, MARLIN_msg_reheat_done) == 0) {
         pause_state = AC_paused_idle;
-        SendtoTFTLN(AC_msg_paused); // enable continue button
+        tftSendLn(AC_msg_paused); // enable continue button
       }
       // Filament Purging, send acknowledgement enter run mode
       else if (strcmp_P(msg, MARLIN_msg_filament_purging) == 0) {
         pause_state = AC_paused_purging_filament;
-        SendtoTFTLN(AC_msg_paused); // enable continue button
+        tftSendLn(AC_msg_paused); // enable continue button
       }
     } break;
     default:
@@ -233,10 +237,10 @@ void ChironTFT::ConfirmationRequest(const char * const msg)  {
   }
 }
 
-void ChironTFT::StatusChange(const char * const msg)  {
+void ChironTFT::statusChange(const char * const msg)  {
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPGM("StatusChange() ", msg);
-    SERIAL_ECHOLNPGM("printer_state:", printer_state);
+    DEBUG_ECHOLNPGM("statusChange() ", msg);
+    DEBUG_ECHOLNPGM("printer_state:", printer_state);
   #endif
   bool msg_matched = false;
   // The only way to get printer status is to parse messages
@@ -247,7 +251,7 @@ void ChironTFT::StatusChange(const char * const msg)  {
       // Ignore the custom machine name
       if (strcmp_P(msg + strlen(MACHINE_NAME), MARLIN_msg_ready) == 0) {
         injectCommands(F("M500\nG27"));
-        SendtoTFTLN(AC_msg_probing_complete);
+        tftSendLn(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
@@ -255,7 +259,7 @@ void ChironTFT::StatusChange(const char * const msg)  {
       if (strcmp_P(msg, MARLIN_msg_probing_failed) == 0) {
         PlayTune(BeepBeepBeeep);
         injectCommands(F("G1 Z50 F500"));
-        SendtoTFTLN(AC_msg_probing_complete);
+        tftSendLn(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
@@ -263,14 +267,14 @@ void ChironTFT::StatusChange(const char * const msg)  {
 
     case AC_printer_printing: {
       if (strcmp_P(msg, MARLIN_msg_reheating) == 0) {
-        SendtoTFTLN(AC_msg_paused); // enable continue button
+        tftSendLn(AC_msg_paused); // enable continue button
         msg_matched = true;
        }
     } break;
 
     case AC_printer_pausing: {
       if (strcmp_P(msg, MARLIN_msg_print_paused) == 0) {
-        SendtoTFTLN(AC_msg_paused);
+        tftSendLn(AC_msg_paused);
         printer_state = AC_printer_paused;
         pause_state = AC_paused_idle;
         msg_matched = true;
@@ -279,7 +283,7 @@ void ChironTFT::StatusChange(const char * const msg)  {
 
     case AC_printer_stopping: {
       if (strcmp_P(msg, MARLIN_msg_print_aborted) == 0) {
-        SendtoTFTLN(AC_msg_stop);
+        tftSendLn(AC_msg_stop);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
@@ -291,11 +295,11 @@ void ChironTFT::StatusChange(const char * const msg)  {
   // If not matched earlier see if this was a heater message
   if (!msg_matched) {
     if (strcmp_P(msg, MARLIN_msg_extruder_heating) == 0) {
-      SendtoTFTLN(AC_msg_nozzle_heating);
+      tftSendLn(AC_msg_nozzle_heating);
       hotend_state = AC_heater_temp_set;
     }
     else if (strcmp_P(msg, MARLIN_msg_bed_heating) == 0) {
-      SendtoTFTLN(AC_msg_bed_heating);
+      tftSendLn(AC_msg_bed_heating);
       hotbed_state = AC_heater_temp_set;
     }
     else if (strcmp_P(msg, MARLIN_msg_EEPROM_version) == 0) {
@@ -304,33 +308,33 @@ void ChironTFT::StatusChange(const char * const msg)  {
   }
 }
 
-void ChironTFT::PowerLossRecovery()  {
+void ChironTFT::powerLossRecovery()  {
   printer_state = AC_printer_resuming_from_power_outage; // Play tune to notify user we can recover.
   last_error = AC_error_powerloss;
   PlayTune(SOS);
   SERIAL_ECHOLNF(AC_msg_powerloss_recovery);
 }
 
-void ChironTFT::PrintComplete() {
-  SendtoTFT(AC_msg_print_complete);
+void ChironTFT::printComplete() {
+  tftSend(AC_msg_print_complete);
   printer_state = AC_printer_idle;
   setSoftEndstopState(true); // enable endstops
 }
 
-void ChironTFT::SendtoTFT(FSTR_P const fstr/*=nullptr*/) {  // A helper to print PROGMEM string to the panel
+void ChironTFT::tftSend(FSTR_P const fstr/*=nullptr*/) {  // A helper to print PROGMEM string to the panel
   #if ACDEBUG(AC_SOME)
-    SERIAL_ECHOF(fstr);
+    DEBUG_ECHOF(fstr);
   #endif
   PGM_P str = FTOP(fstr);
   while (const char c = pgm_read_byte(str++)) TFTSer.write(c);
 }
 
-void ChironTFT::SendtoTFTLN(FSTR_P const fstr/*=nullptr*/) {
+void ChironTFT::tftSendLn(FSTR_P const fstr/*=nullptr*/) {
   if (fstr) {
     #if ACDEBUG(AC_SOME)
-      SERIAL_ECHOPGM("> ");
+      DEBUG_ECHOPGM("> ");
     #endif
-    SendtoTFT(fstr);
+    tftSend(fstr);
     #if ACDEBUG(AC_SOME)
       SERIAL_EOL();
     #endif
@@ -338,7 +342,7 @@ void ChironTFT::SendtoTFTLN(FSTR_P const fstr/*=nullptr*/) {
   TFTSer.println();
 }
 
-bool ChironTFT::ReadTFTCommand() {
+bool ChironTFT::readTFTCommand() {
   bool command_ready = false;
   while (TFTSer.available() > 0 && command_len < MAX_CMND_LEN) {
     panel_command[command_len] = TFTSer.read();
@@ -352,29 +356,29 @@ bool ChironTFT::ReadTFTCommand() {
   if (command_ready || command_len == MAX_CMND_LEN) {
     panel_command[command_len] = '\0';
     #if ACDEBUG(AC_ALL)
-      SERIAL_ECHOLNPGM("len(",command_len,") < ", panel_command);
+      DEBUG_ECHOLNPGM("len(",command_len,") < ", panel_command);
     #endif
     command_ready = true;
   }
   return command_ready;
 }
 
-int8_t ChironTFT::FindToken(char c) {
+int8_t ChironTFT::findToken(char c) {
   for (int8_t pos = 0; pos < command_len; pos++) {
     if (panel_command[pos] == c) {
       #if ACDEBUG(AC_INFO)
-        SERIAL_ECHOLNPGM("Tpos:", pos, " ", c);
+        DEBUG_ECHOLNPGM("Tpos:", pos, " ", c);
       #endif
       return pos;
     }
   }
   #if ACDEBUG(AC_INFO)
-    SERIAL_ECHOLNPGM("Not found: ", c);
+    DEBUG_ECHOLNPGM("Not found: ", c);
   #endif
   return -1;
 }
 
-void ChironTFT::CheckHeaters() {
+void ChironTFT::checkHeaters() {
   uint8_t faultDuration = 0;
 
   // if the hotend temp is abnormal, confirm state before signalling panel
@@ -382,7 +386,7 @@ void ChironTFT::CheckHeaters() {
   while (!WITHIN(temp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP)) {
     faultDuration++;
     if (faultDuration >= AC_HEATER_FAULT_VALIDATION_TIME) {
-      SendtoTFTLN(AC_msg_nozzle_temp_abnormal);
+      tftSendLn(AC_msg_nozzle_temp_abnormal);
       last_error = AC_error_abnormal_temp_t0;
       SERIAL_ECHOLNPGM("Extruder temp abnormal! : ", temp);
       break;
@@ -397,7 +401,7 @@ void ChironTFT::CheckHeaters() {
   while (!WITHIN(temp, BED_MINTEMP, BED_MAXTEMP)) {
     faultDuration++;
     if (faultDuration >= AC_HEATER_FAULT_VALIDATION_TIME) {
-      SendtoTFTLN(AC_msg_nozzle_temp_abnormal);
+      tftSendLn(AC_msg_nozzle_temp_abnormal);
       last_error = AC_error_abnormal_temp_bed;
       SERIAL_ECHOLNPGM("Bed temp abnormal! : ", temp);
       break;
@@ -409,7 +413,7 @@ void ChironTFT::CheckHeaters() {
   // Update panel with hotend heater status
   if (hotend_state != AC_heater_temp_reached) {
     if (WITHIN(getActualTemp_celsius(E0) - getTargetTemp_celsius(E0), -(TEMP_WINDOW), TEMP_WINDOW)) {
-      SendtoTFTLN(AC_msg_nozzle_heating_done);
+      tftSendLn(AC_msg_nozzle_heating_done);
       hotend_state = AC_heater_temp_reached;
     }
   }
@@ -417,23 +421,23 @@ void ChironTFT::CheckHeaters() {
   // Update panel with bed heater status
   if (hotbed_state != AC_heater_temp_reached) {
     if (WITHIN(getActualTemp_celsius(BED) - getTargetTemp_celsius(BED), -(TEMP_BED_WINDOW), TEMP_BED_WINDOW)) {
-      SendtoTFTLN(AC_msg_bed_heating_done);
+      tftSendLn(AC_msg_bed_heating_done);
       hotbed_state = AC_heater_temp_reached;
     }
   }
 }
 
-void ChironTFT::SendFileList(int8_t startindex) {
+void ChironTFT::sendFileList(int8_t startindex) {
   // Respond to panel request for 4 files starting at index
   #if ACDEBUG(AC_INFO)
-    SERIAL_ECHOLNPGM("## SendFileList ## ", startindex);
+    DEBUG_ECHOLNPGM("## sendFileList ## ", startindex);
   #endif
-  SendtoTFTLN(F("FN "));
+  tftSendLn(F("FN "));
   filenavigator.getFiles(startindex, panel_type, 4);
-  SendtoTFTLN(F("END"));
+  tftSendLn(F("END"));
 }
 
-void ChironTFT::SelectFile() {
+void ChironTFT::selectFile() {
   if (panel_type <= AC_panel_new) {
     strncpy(selectedfile, panel_command + 4, command_len - 3);
     selectedfile[command_len - 4] = '\0';
@@ -443,50 +447,50 @@ void ChironTFT::SelectFile() {
     selectedfile[command_len - 5] = '\0';
   }
   #if ACDEBUG(AC_FILE)
-    SERIAL_ECHOLNPGM(" Selected File: ",selectedfile);
+    DEBUG_ECHOLNPGM(" Selected File: ",selectedfile);
   #endif
   switch (selectedfile[0]) {
     case '/':   // Valid file selected
-      SendtoTFTLN(AC_msg_sd_file_open_success);
+      tftSendLn(AC_msg_sd_file_open_success);
       break;
 
     case '<':   // .. (go up folder level)
       filenavigator.upDIR();
-      SendtoTFTLN(AC_msg_sd_file_open_failed);
-      SendFileList( 0 );
+      tftSendLn(AC_msg_sd_file_open_failed);
+      sendFileList( 0 );
       break;
     default:   // enter sub folder
       // for new panel remove the '.GCO' tag that was added to the end of the path
       if (panel_type <= AC_panel_new)
         selectedfile[strlen(selectedfile) - 4] = '\0';
       filenavigator.changeDIR(selectedfile);
-      SendtoTFTLN(AC_msg_sd_file_open_failed);
-      SendFileList( 0 );
+      tftSendLn(AC_msg_sd_file_open_failed);
+      sendFileList( 0 );
       break;
   }
 }
 
-void ChironTFT::ProcessPanelRequest() {
+void ChironTFT::processPanelRequest() {
   // Break these up into logical blocks // as its easier to navigate than one huge switch case!
-  int8_t tpos = FindToken('A');
+  int8_t tpos = findToken('A');
   // Panel request are 'A0' - 'A36'
   if (tpos >= 0) {
     const int8_t req = atoi(&panel_command[tpos + 1]);
 
     // Information requests A0 - A8 and A33
-    if (req <= 8 || req == 33) PanelInfo(req);
+    if (req <= 8 || req == 33) panelInfo(req);
 
     // Simple Actions A9 - A28
-    else if (req <= 28) PanelAction(req);
+    else if (req <= 28) panelAction(req);
 
     // Process Initiation
-    else if (req <= 36) PanelProcess(req);
+    else if (req <= 36) panelProcess(req);
   }
   else {
     #if AUTO_DETECT_CHIRON_TFT
       // This may be a response to a panel type detection query
       if (panel_type == AC_panel_unknown) {
-        tpos = FindToken('S'); // old panel will respond to 'SIZE' with 'SXY 480 320'
+        tpos = findToken('S'); // old panel will respond to 'SIZE' with 'SXY 480 320'
         if (tpos >= 0) {
           if (panel_command[tpos + 1] == 'X' && panel_command[tpos + 2] =='Y') {
             panel_type = AC_panel_standard;
@@ -496,7 +500,7 @@ void ChironTFT::ProcessPanelRequest() {
         else {
           // new panel will respond to 'J200' with '[0]=0'
           // it seems only after a power cycle so detection assumes a new panel
-          tpos = FindToken('[');
+          tpos = findToken('[');
           if (tpos >= 0) {
             if (panel_command[tpos + 1] == '0' && panel_command[tpos + 2] ==']') {
               panel_type = AC_panel_new;
@@ -508,94 +512,94 @@ void ChironTFT::ProcessPanelRequest() {
       }
     #endif
 
-    SendtoTFTLN(); // Ignore unknown requests
+    tftSendLn(); // Ignore unknown requests
   }
 }
 
-void ChironTFT::PanelInfo(uint8_t req) {
+void ChironTFT::panelInfo(uint8_t req) {
   // information requests A0-A8 and A33
   switch (req) {
     case 0:   // A0 Get HOTEND Temp
-      SendtoTFT(F("A0V "));
+      tftSend(F("A0V "));
       TFTSer.println(getActualTemp_celsius(E0));
       break;
 
     case 1:   // A1 Get HOTEND Target Temp
-      SendtoTFT(F("A1V "));
+      tftSend(F("A1V "));
       TFTSer.println(getTargetTemp_celsius(E0));
       break;
 
     case 2:   // A2 Get BED Temp
-      SendtoTFT(F("A2V "));
+      tftSend(F("A2V "));
       TFTSer.println(getActualTemp_celsius(BED));
       break;
 
     case 3:   // A3 Get BED Target Temp
-      SendtoTFT(F("A3V "));
+      tftSend(F("A3V "));
       TFTSer.println(getTargetTemp_celsius(BED));
       break;
 
     case 4:   // A4 Get FAN Speed
-      SendtoTFT(F("A4V "));
+      tftSend(F("A4V "));
       TFTSer.println(getActualFan_percent(FAN0));
       break;
 
     case 5:   // A5 Get Current Coordinates
-      SendtoTFT(F("A5V X: "));
+      tftSend(F("A5V X: "));
       TFTSer.print(getAxisPosition_mm(X));
-      SendtoTFT(F(" Y: "));
+      tftSend(F(" Y: "));
       TFTSer.print(getAxisPosition_mm(Y));
-      SendtoTFT(F(" Z: "));
+      tftSend(F(" Z: "));
       TFTSer.println(getAxisPosition_mm(Z));
       break;
 
     case 6:   // A6 Get printing progress
       if (isPrintingFromMedia()) {
-        SendtoTFT(F("A6V "));
+        tftSend(F("A6V "));
         TFTSer.println(ui8tostr2(getProgress_percent()));
       }
       else
-        SendtoTFTLN(F("A6V ---"));
+        tftSendLn(F("A6V ---"));
       break;
 
     case 7: { // A7 Get Printing Time
       uint32_t time = getProgress_seconds_elapsed() / 60;
-      SendtoTFT(F("A7V "));
+      tftSend(F("A7V "));
       TFTSer.print(ui8tostr2(time / 60));
-      SendtoTFT(F(" H "));
+      tftSend(F(" H "));
       TFTSer.print(ui8tostr2(time % 60));
-      SendtoTFT(F(" M"));
+      tftSend(F(" M"));
       #if ACDEBUG(AC_ALL)
-        SERIAL_ECHOLNPGM("Print time ", ui8tostr2(time / 60), ":", ui8tostr2(time % 60));
+        DEBUG_ECHOLNPGM("Print time ", ui8tostr2(time / 60), ":", ui8tostr2(time % 60));
       #endif
     } break;
 
     case 8:   // A8 Get SD Card list A8 S0
       if (!isMediaInserted()) safe_delay(500);
       if (!isMediaInserted())   // Make sure the card is removed
-        SendtoTFTLN(AC_msg_no_sd_card);
+        tftSendLn(AC_msg_no_sd_card);
       else if (panel_command[3] == 'S')
-        SendFileList( atoi( &panel_command[4] ) );
+        sendFileList( atoi( &panel_command[4] ) );
       break;
 
     case 33:   // A33 Get firmware info
-      SendtoTFT(F("J33 "));
+      tftSend(F("J33 "));
       // If there is an error recorded, show that instead of the FW version
-      if (!GetLastError()) SendtoTFTLN(F(SHORT_BUILD_VERSION));
+      if (!getLastError()) tftSendLn(F(SHORT_BUILD_VERSION));
       break;
   }
 }
 
-void ChironTFT::PanelAction(uint8_t req) {
+void ChironTFT::panelAction(uint8_t req) {
   switch (req) {
     case  9:   // A9 Pause SD print
       if (isPrintingFromMedia()) {
-        SendtoTFTLN(AC_msg_pause);
+        tftSendLn(AC_msg_pause);
         pausePrint();
         printer_state = AC_printer_pausing;
       }
       else
-        SendtoTFTLN(AC_msg_stop);
+        tftSendLn(AC_msg_stop);
       break;
 
     case 10: // A10 Resume SD Print
@@ -613,7 +617,7 @@ void ChironTFT::PanelAction(uint8_t req) {
       else {
         if (printer_state == AC_printer_resuming_from_power_outage)
           injectCommands(F("M1000 C")); // Cancel recovery
-        SendtoTFTLN(AC_msg_stop);
+        tftSendLn(AC_msg_stop);
         printer_state = AC_printer_idle;
       }
       break;
@@ -623,7 +627,7 @@ void ChironTFT::PanelAction(uint8_t req) {
       break;
 
     case 13:   // A13 Select file
-      SelectFile();
+      selectFile();
       break;
 
     case 14:   // A14 Start Printing
@@ -632,11 +636,9 @@ void ChironTFT::PanelAction(uint8_t req) {
         injectCommands(F("M1000 C")); // Cancel recovery
         printer_state = AC_printer_idle;
       }
-      #if ACDebugLevel >= 1
-        SERIAL_ECHOLNPGM("Print: ", selectedfile);
-      #endif
+      DEBUG_ECHOLNPGM("Print: ", selectedfile);
       printFile(selectedfile);
-      SendtoTFTLN(AC_msg_print_from_sd_card);
+      tftSendLn(AC_msg_print_from_sd_card);
       break;
 
     case 15:   // A15 Resuming from outage
@@ -671,7 +673,7 @@ void ChironTFT::PanelAction(uint8_t req) {
     case 19:   // A19 Motors off
       if (!isPrinting()) {
         stepper.disable_all_steppers();
-        SendtoTFTLN(AC_msg_ready);
+        tftSendLn(AC_msg_ready);
       }
       break;
 
@@ -679,7 +681,7 @@ void ChironTFT::PanelAction(uint8_t req) {
       if (panel_command[4] == 'S')
         setFeedrate_percent(atoi(&panel_command[5]));
       else {
-        SendtoTFT(F("A20V "));
+        tftSend(F("A20V "));
         TFTSer.println(getFeedrate_percent());
       }
       break;
@@ -707,7 +709,7 @@ void ChironTFT::PanelAction(uint8_t req) {
         char MoveCmnd[30];
         sprintf_P(MoveCmnd, PSTR("G91\nG0%s\nG90"), panel_command + 3);
         #if ACDEBUG(AC_ACTION)
-          SERIAL_ECHOLNPGM("Move: ", MoveCmnd);
+          DEBUG_ECHOLNPGM("Move: ", MoveCmnd);
         #endif
         setSoftEndstopState(true);  // enable endstops
         injectCommands(MoveCmnd);
@@ -720,7 +722,7 @@ void ChironTFT::PanelAction(uint8_t req) {
         // Temps defined in configuration.h
         setTargetTemp_celsius(PREHEAT_1_TEMP_BED, BED);
         setTargetTemp_celsius(PREHEAT_1_TEMP_HOTEND, E0);
-        SendtoTFTLN();
+        tftSendLn();
         hotbed_state = AC_heater_temp_set;
         hotend_state = AC_heater_temp_set;
       }
@@ -731,7 +733,7 @@ void ChironTFT::PanelAction(uint8_t req) {
       if (!isPrinting()) {
         setTargetTemp_celsius(PREHEAT_2_TEMP_BED, BED);
         setTargetTemp_celsius(PREHEAT_2_TEMP_HOTEND, E0);
-        SendtoTFTLN();
+        tftSendLn();
         hotbed_state = AC_heater_temp_set;
         hotend_state = AC_heater_temp_set;
       }
@@ -742,7 +744,7 @@ void ChironTFT::PanelAction(uint8_t req) {
       if (!isPrinting()) {
         setTargetTemp_celsius(0, E0);
         setTargetTemp_celsius(0, BED);
-        SendtoTFTLN(AC_msg_ready);
+        tftSendLn(AC_msg_ready);
         hotbed_state = AC_heater_off;
         hotend_state = AC_heater_off;
       }
@@ -761,21 +763,21 @@ void ChironTFT::PanelAction(uint8_t req) {
     case 28:   // A28 Filament set A28 O/C
       // Ignore request if printing
       if (isPrinting()) break;
-      SendtoTFTLN();
+      tftSendLn();
       break;
   }
 }
 
-void ChironTFT::PanelProcess(uint8_t req) {
+void ChironTFT::panelProcess(uint8_t req) {
   switch (req) {
     case 29: { // A29 Read Mesh Point A29 X1 Y1
       xy_uint8_t pos;
       float pos_z;
-      pos.x = atoi(&panel_command[FindToken('X')+1]);
-      pos.y = atoi(&panel_command[FindToken('Y')+1]);
+      pos.x = atoi(&panel_command[findToken('X')+1]);
+      pos.y = atoi(&panel_command[findToken('Y')+1]);
       pos_z = getMeshPoint(pos);
 
-      SendtoTFT(F("A29V "));
+      tftSend(F("A29V "));
       TFTSer.println(pos_z * 100);
       if (!isPrinting()) {
         setSoftEndstopState(true);  // disable endstops
@@ -786,7 +788,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
 
           if (isPositionKnown()) {
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPGM("Moving to mesh point at x: ", pos.x, " y: ", pos.y, " z: ", pos_z);
+              DEBUG_ECHOLNPGM("Moving to mesh point at x: ", pos.x, " y: ", pos.y, " z: ", pos_z);
             #endif
             // Go up before moving
             setAxisPosition_mm(3.0,Z);
@@ -795,7 +797,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
             setAxisPosition_mm(20 + (93 * pos.y), Y);
             setAxisPosition_mm(0.0, Z);
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPGM("Current Z: ", getAxisPosition_mm(Z));
+              DEBUG_ECHOLNPGM("Current Z: ", getAxisPosition_mm(Z));
             #endif
           }
         }
@@ -805,24 +807,24 @@ void ChironTFT::PanelProcess(uint8_t req) {
     } break;
 
     case 30:     // A30 Auto leveling
-      if (FindToken('S') >= 0) { // Start probing New panel adds spaces..
+      if (findToken('S') >= 0) { // Start probing New panel adds spaces..
         // Ignore request if printing
         if (isPrinting())
-          SendtoTFTLN(AC_msg_probing_not_allowed); // forbid auto leveling
+          tftSendLn(AC_msg_probing_not_allowed); // forbid auto leveling
         else {
-          SendtoTFTLN(AC_msg_start_probing);
+          tftSendLn(AC_msg_start_probing);
           injectCommands(F("G28\nG29"));
           printer_state = AC_printer_probing;
         }
       }
       else
-        SendtoTFTLN(AC_msg_start_probing); // Just enter levelling menu
+        tftSendLn(AC_msg_start_probing); // Just enter levelling menu
       break;
 
     case 31:   // A31 Adjust all Probe Points
       // The tokens can occur in different places on the new panel so we need to find it.
 
-      if (FindToken('C') >= 0) { // Restore and apply original offsets
+      if (findToken('C') >= 0) { // Restore and apply original offsets
         if (!isPrinting()) {
           injectCommands(F("M501\nM420 S1"));
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
@@ -830,7 +832,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
         }
       }
 
-      else if (FindToken('D') >= 0) { // Save Z Offset tables and restore leveling state
+      else if (findToken('D') >= 0) { // Save Z Offset tables and restore leveling state
         if (!isPrinting()) {
           setAxisPosition_mm(1.0,Z); // Lift nozzle before any further movements are made
           injectCommands(F("M500"));
@@ -839,8 +841,8 @@ void ChironTFT::PanelProcess(uint8_t req) {
         }
       }
 
-      else if (FindToken('G') >= 0) { // Get current offset
-        SendtoTFT(F("A31V "));
+      else if (findToken('G') >= 0) { // Get current offset
+        tftSend(F("A31V "));
         // When printing use the live z Offset position
         // we will use babystepping to move the print head
         if (isPrinting())
@@ -852,7 +854,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
       }
 
       else {
-        int8_t tokenpos = FindToken('S');
+        int8_t tokenpos = findToken('S');
         if (tokenpos >= 0) { // Set offset (adjusts all points by value)
           float Zshift = atof(&panel_command[tokenpos+1]);
           setSoftEndstopState(false);  // disable endstops
@@ -860,22 +862,22 @@ void ChironTFT::PanelProcess(uint8_t req) {
           // From the leveling panel use the all points UI to adjust the print pos.
           if (isPrinting()) {
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPGM("Change Zoffset from:", live_Zoffset, " to ", live_Zoffset + Zshift);
+              DEBUG_ECHOLNPGM("Change Zoffset from:", live_Zoffset, " to ", live_Zoffset + Zshift);
             #endif
             if (isAxisPositionKnown(Z)) {
               #if ACDEBUG(AC_INFO)
                 const float currZpos = getAxisPosition_mm(Z);
-                SERIAL_ECHOLNPGM("Nudge Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
+                DEBUG_ECHOLNPGM("Nudge Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
               #endif
               // Use babystepping to adjust the head position
               int16_t steps = mmToWholeSteps(constrain(Zshift,-0.05,0.05), Z);
               #if ACDEBUG(AC_INFO)
-                SERIAL_ECHOLNPGM("Steps to move Z: ", steps);
+                DEBUG_ECHOLNPGM("Steps to move Z: ", steps);
               #endif
               babystepAxis_steps(steps, Z);
               live_Zoffset += Zshift;
             }
-            SendtoTFT(F("A31V "));
+            tftSend(F("A31V "));
             TFTSer.println(live_Zoffset);
           }
           else {
@@ -884,23 +886,23 @@ void ChironTFT::PanelProcess(uint8_t req) {
               const float currval = getMeshPoint(pos);
               setMeshPoint(pos, constrain(currval + Zshift, AC_LOWEST_MESHPOINT_VAL, 2));
               #if ACDEBUG(AC_INFO)
-                SERIAL_ECHOLNPGM("Change mesh point X", x," Y",y ," from ", currval, " to ", getMeshPoint(pos) );
+                DEBUG_ECHOLNPGM("Change mesh point X", x," Y",y ," from ", currval, " to ", getMeshPoint(pos) );
               #endif
             }
             const float currZOffset = getZOffset_mm();
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPGM("Change probe offset from ", currZOffset, " to  ", currZOffset + Zshift);
+              DEBUG_ECHOLNPGM("Change probe offset from ", currZOffset, " to  ", currZOffset + Zshift);
             #endif
 
             setZOffset_mm(currZOffset + Zshift);
-            SendtoTFT(F("A31V "));
+            tftSend(F("A31V "));
             TFTSer.println(getZOffset_mm());
 
             if (isAxisPositionKnown(Z)) {
               // Move Z axis
               const float currZpos = getAxisPosition_mm(Z);
               #if ACDEBUG(AC_INFO)
-                SERIAL_ECHOLNPGM("Move Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
+                DEBUG_ECHOLNPGM("Move Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
               #endif
               setAxisPosition_mm(currZpos+constrain(Zshift,-0.05,0.05),Z);
             }
@@ -916,7 +918,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
       //TFTSer.println();
       break;
 
-    // A33 firmware info request see PanelInfo()
+    // A33 firmware info request see panelInfo()
 
     case 34:    // A34 Adjust single mesh point A34 C/S X1 Y1 V123
       if (panel_command[3] == 'C') { // Restore original offsets
@@ -932,8 +934,8 @@ void ChironTFT::PanelProcess(uint8_t req) {
         float currmesh = getMeshPoint(pos);
         float newval   = atof(&panel_command[11])/100;
         #if ACDEBUG(AC_INFO)
-          SERIAL_ECHOLNPGM("Change mesh point x:", pos.x, " y:", pos.y);
-          SERIAL_ECHOLNPGM("from ", currmesh, " to ", newval);
+          DEBUG_ECHOLNPGM("Change mesh point x:", pos.x, " y:", pos.y);
+          DEBUG_ECHOLNPGM("from ", currmesh, " to ", newval);
         #endif
         // Update Meshpoint
         setMeshPoint(pos,newval);
@@ -944,7 +946,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
             setSoftEndstopState(false);
             float currZpos = getAxisPosition_mm(Z);
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPGM("Move Z pos from ", currZpos, " to ", currZpos + constrain(newval - currmesh, -0.05, 0.05));
+              DEBUG_ECHOLNPGM("Move Z pos from ", currZpos, " to ", currZpos + constrain(newval - currmesh, -0.05, 0.05));
             #endif
             setAxisPosition_mm(currZpos + constrain(newval - currmesh, -0.05, 0.05), Z);
           }
@@ -953,19 +955,19 @@ void ChironTFT::PanelProcess(uint8_t req) {
       break;
 
     case 36:    // A36 Auto leveling for new TFT bet that was a typo in the panel code!
-      SendtoTFTLN(AC_msg_start_probing);
+      tftSendLn(AC_msg_start_probing);
       break;
   }
 }
 
-bool ChironTFT::GetLastError() {
+bool ChironTFT::getLastError() {
   switch (last_error) {
-    case AC_error_abnormal_temp_bed: SendtoTFTLN(AC_msg_error_bed_temp);    break;
-    case AC_error_abnormal_temp_t0:  SendtoTFTLN(AC_msg_error_hotend_temp); break;
-    case AC_error_noSD:              SendtoTFTLN(AC_msg_error_sd_card);     break;
-    case AC_error_powerloss:         SendtoTFTLN(AC_msg_power_loss);        break;
-    case AC_error_EEPROM:            SendtoTFTLN(AC_msg_eeprom_version);    break;
-    case AC_error_filament_runout:   SendtoTFTLN(AC_msg_filament_out);      break;
+    case AC_error_abnormal_temp_bed: tftSendLn(AC_msg_error_bed_temp);    break;
+    case AC_error_abnormal_temp_t0:  tftSendLn(AC_msg_error_hotend_temp); break;
+    case AC_error_noSD:              tftSendLn(AC_msg_error_sd_card);     break;
+    case AC_error_powerloss:         tftSendLn(AC_msg_power_loss);        break;
+    case AC_error_EEPROM:            tftSendLn(AC_msg_eeprom_version);    break;
+    case AC_error_filament_runout:   tftSendLn(AC_msg_filament_out);      break;
     default: return false;
   }
   last_error = AC_error_none;

commit 743903b96fd64ef8cbe23d84eed7de1e29b1abed
Author: Nick <nick@n-wells.co.uk>
Date:   Mon Apr 24 01:50:39 2023 +0100

    ü©π Fix Anycubic PlayTune (#25735)
    
    Followup to #25690
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 45fb73c02f..f3bc64a024 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -104,7 +104,7 @@ void ChironTFT::Startup() {
   injectCommands(AC_cmnd_enable_leveling);
 
   // Startup tunes are defined in Tunes.h
-  PlayTune(TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn), 1);
+  PlayTune(TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn));
 
   #if ACDEBUGLEVEL
     SERIAL_ECHOLNPGM("AC Debug Level ", ACDEBUGLEVEL);
@@ -192,7 +192,7 @@ void ChironTFT::FilamentRunout()  {
   // 1 Signal filament out
   last_error = AC_error_filament_runout;
   SendtoTFTLN(isPrintingFromMedia() ? AC_msg_filament_out_alert : AC_msg_filament_out_block);
-  PlayTune(FilamentOut, 1);
+  PlayTune(FilamentOut);
 }
 
 void ChironTFT::ConfirmationRequest(const char * const msg)  {
@@ -215,7 +215,7 @@ void ChironTFT::ConfirmationRequest(const char * const msg)  {
       if (strcmp_P(msg, MARLIN_msg_heater_timeout) == 0) {
         pause_state = AC_paused_heater_timed_out;
         SendtoTFTLN(AC_msg_paused); // enable continue button
-        PlayTune(BEEPER_PIN,Heater_Timedout,1);
+        PlayTune(HeaterTimeout);
       }
       // Reheat finished, send acknowledgement
       else if (strcmp_P(msg, MARLIN_msg_reheat_done) == 0) {
@@ -253,7 +253,7 @@ void ChironTFT::StatusChange(const char * const msg)  {
       }
       // If probing fails don't save the mesh raise the probe above the bad point
       if (strcmp_P(msg, MARLIN_msg_probing_failed) == 0) {
-        PlayTune(BeepBeepBeeep, 1);
+        PlayTune(BeepBeepBeeep);
         injectCommands(F("G1 Z50 F500"));
         SendtoTFTLN(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
@@ -307,7 +307,7 @@ void ChironTFT::StatusChange(const char * const msg)  {
 void ChironTFT::PowerLossRecovery()  {
   printer_state = AC_printer_resuming_from_power_outage; // Play tune to notify user we can recover.
   last_error = AC_error_powerloss;
-  PlayTune(SOS, 1);
+  PlayTune(SOS);
   SERIAL_ECHOLNF(AC_msg_powerloss_recovery);
 }
 

commit 6e3b58d76a00e861a9945f3073719f82473a0faf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 15 22:24:14 2023 -0500

    üßë‚Äçüíª Anycubic shared code (#25690)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index dce503776b..45fb73c02f 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -33,7 +33,7 @@
 #if ENABLED(ANYCUBIC_LCD_CHIRON)
 
 #include "chiron_tft.h"
-#include "Tunes.h"
+#include "../anycubic/Tunes.h"
 #include "FileNavigator.h"
 
 #include "../../../gcode/queue.h"
@@ -104,7 +104,7 @@ void ChironTFT::Startup() {
   injectCommands(AC_cmnd_enable_leveling);
 
   // Startup tunes are defined in Tunes.h
-  PlayTune(BEEPER_PIN, TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn), 1);
+  PlayTune(TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn), 1);
 
   #if ACDEBUGLEVEL
     SERIAL_ECHOLNPGM("AC Debug Level ", ACDEBUGLEVEL);
@@ -192,7 +192,7 @@ void ChironTFT::FilamentRunout()  {
   // 1 Signal filament out
   last_error = AC_error_filament_runout;
   SendtoTFTLN(isPrintingFromMedia() ? AC_msg_filament_out_alert : AC_msg_filament_out_block);
-  PlayTune(BEEPER_PIN, FilamentOut, 1);
+  PlayTune(FilamentOut, 1);
 }
 
 void ChironTFT::ConfirmationRequest(const char * const msg)  {
@@ -253,7 +253,7 @@ void ChironTFT::StatusChange(const char * const msg)  {
       }
       // If probing fails don't save the mesh raise the probe above the bad point
       if (strcmp_P(msg, MARLIN_msg_probing_failed) == 0) {
-        PlayTune(BEEPER_PIN, BeepBeepBeeep, 1);
+        PlayTune(BeepBeepBeeep, 1);
         injectCommands(F("G1 Z50 F500"));
         SendtoTFTLN(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
@@ -307,7 +307,7 @@ void ChironTFT::StatusChange(const char * const msg)  {
 void ChironTFT::PowerLossRecovery()  {
   printer_state = AC_printer_resuming_from_power_outage; // Play tune to notify user we can recover.
   last_error = AC_error_powerloss;
-  PlayTune(BEEPER_PIN, SOS, 1);
+  PlayTune(SOS, 1);
   SERIAL_ECHOLNF(AC_msg_powerloss_recovery);
 }
 

commit 0021a58943721a81b1ef23fa5e7366cfd80a3d28
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Sun Mar 26 04:07:25 2023 -0500

    ‚ú® AnyCubic Vyper / Vyper LCD (#25405)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 285729cc15..dce503776b 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -72,14 +72,6 @@ void ChironTFT::Startup() {
   live_Zoffset      = 0.0;
   file_menu         = AC_menu_file;
 
-  // Setup pins for powerloss detection
-  // Two IO pins are connected on the Trigorilla Board
-  // On a power interruption the OUTAGECON_PIN goes low.
-
-  #if ENABLED(POWER_LOSS_RECOVERY)
-    OUT_WRITE(OUTAGECON_PIN, HIGH);
-  #endif
-
   // Filament runout is handled by Marlin settings in Configuration.h
   // opt_set    FIL_RUNOUT_STATE HIGH  // Pin state indicating that filament is NOT present.
   // opt_enable FIL_RUNOUT_PULLUP

commit 049cfe659c8e4af282c50169ebbed98638a013fa
Author: Bart Meijer <brupje@gmail.com>
Date:   Mon Dec 12 22:36:50 2022 +0100

    ‚ú® SAMD21 HAL / Minitronics v2.0 (#24976)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 4be023df0a..285729cc15 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -72,6 +72,17 @@ void ChironTFT::Startup() {
   live_Zoffset      = 0.0;
   file_menu         = AC_menu_file;
 
+  // Setup pins for powerloss detection
+  // Two IO pins are connected on the Trigorilla Board
+  // On a power interruption the OUTAGECON_PIN goes low.
+
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    OUT_WRITE(OUTAGECON_PIN, HIGH);
+  #endif
+
+  // Filament runout is handled by Marlin settings in Configuration.h
+  // opt_set    FIL_RUNOUT_STATE HIGH  // Pin state indicating that filament is NOT present.
+  // opt_enable FIL_RUNOUT_PULLUP
   TFTSer.begin(115200);
 
   // Wait for the TFT panel to initialize and finish the animation

commit 739556905575e967e10b1e164ae549be28772964
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 11 20:35:07 2022 -0600

    üêõ Fix Anycubic / Trigorilla pins, etc. (#24971)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 285729cc15..4be023df0a 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -72,17 +72,6 @@ void ChironTFT::Startup() {
   live_Zoffset      = 0.0;
   file_menu         = AC_menu_file;
 
-  // Setup pins for powerloss detection
-  // Two IO pins are connected on the Trigorilla Board
-  // On a power interruption the OUTAGECON_PIN goes low.
-
-  #if ENABLED(POWER_LOSS_RECOVERY)
-    OUT_WRITE(OUTAGECON_PIN, HIGH);
-  #endif
-
-  // Filament runout is handled by Marlin settings in Configuration.h
-  // opt_set    FIL_RUNOUT_STATE HIGH  // Pin state indicating that filament is NOT present.
-  // opt_enable FIL_RUNOUT_PULLUP
   TFTSer.begin(115200);
 
   // Wait for the TFT panel to initialize and finish the animation

commit 58ce5182c2ea93e79ccaef4c912c68aa554e637e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 31 12:43:44 2022 -0500

    üé® Fix spelling, whitespace

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 7561c89d79..285729cc15 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -708,7 +708,7 @@ void ChironTFT::PanelAction(uint8_t req) {
       // Old TFT A22 X -1F1500      A22 X +1F1500
       // New TFT A22 X-1.0 F1500    A22 X1.0 F1500
 
-      // lets just wrap this in a gcode relative nonprint move and let the controller deal with it
+      // Send a G-code-relative non-print move and let the controller deal with it
       // G91 G0 <panel command> G90
 
       if (!isPrinting()) { // Ignore request if printing

commit 72b2e2b2c7230245dea9fcb46b9b8a92bcb11bcc
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Apr 1 08:14:14 2022 +0100

    ‚öóÔ∏è Temperature Model Predictive Control (#23751)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index fa85de2a8e..7561c89d79 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -85,7 +85,7 @@ void ChironTFT::Startup() {
   // opt_enable FIL_RUNOUT_PULLUP
   TFTSer.begin(115200);
 
-  // wait for the TFT panel to initialise and finish the animation
+  // Wait for the TFT panel to initialize and finish the animation
   safe_delay(1000);
 
   // There are different panels for the Chiron with slightly different commands

commit 9c9300ff9dfa3f6b16c9a87be6ff1136ccc7e880
Author: Nick <nick@n-wells.co.uk>
Date:   Sat Mar 12 23:47:47 2022 +0000

    üêõ Fix Chiron new TFT SD print after reset (#23855)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index fac0615cd6..fa85de2a8e 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -442,7 +442,7 @@ void ChironTFT::SendFileList(int8_t startindex) {
 }
 
 void ChironTFT::SelectFile() {
-  if (panel_type == AC_panel_new) {
+  if (panel_type <= AC_panel_new) {
     strncpy(selectedfile, panel_command + 4, command_len - 3);
     selectedfile[command_len - 4] = '\0';
   }
@@ -465,7 +465,7 @@ void ChironTFT::SelectFile() {
       break;
     default:   // enter sub folder
       // for new panel remove the '.GCO' tag that was added to the end of the path
-      if (panel_type == AC_panel_new)
+      if (panel_type <= AC_panel_new)
         selectedfile[strlen(selectedfile) - 4] = '\0';
       filenavigator.changeDIR(selectedfile);
       SendtoTFTLN(AC_msg_sd_file_open_failed);
@@ -478,8 +478,8 @@ void ChironTFT::ProcessPanelRequest() {
   // Break these up into logical blocks // as its easier to navigate than one huge switch case!
   int8_t tpos = FindToken('A');
   // Panel request are 'A0' - 'A36'
-  if (tpos != -1) {
-    const int8_t req = atoi(&panel_command[tpos+1]);
+  if (tpos >= 0) {
+    const int8_t req = atoi(&panel_command[tpos + 1]);
 
     // Information requests A0 - A8 and A33
     if (req <= 8 || req == 33) PanelInfo(req);
@@ -495,16 +495,18 @@ void ChironTFT::ProcessPanelRequest() {
       // This may be a response to a panel type detection query
       if (panel_type == AC_panel_unknown) {
         tpos = FindToken('S'); // old panel will respond to 'SIZE' with 'SXY 480 320'
-        if (tpos != -1) {
-          if (panel_command[tpos+1]== 'X' && panel_command[tpos+2]=='Y') {
+        if (tpos >= 0) {
+          if (panel_command[tpos + 1] == 'X' && panel_command[tpos + 2] =='Y') {
             panel_type = AC_panel_standard;
             SERIAL_ECHOLNF(AC_msg_old_panel_detected);
           }
         }
         else {
-          tpos = FindToken('['); // new panel will respond to 'J200' with '[0]=0'
-          if (tpos != -1) {
-            if (panel_command[tpos+1]== '0' && panel_command[tpos+2]==']') {
+          // new panel will respond to 'J200' with '[0]=0'
+          // it seems only after a power cycle so detection assumes a new panel
+          tpos = FindToken('[');
+          if (tpos >= 0) {
+            if (panel_command[tpos + 1] == '0' && panel_command[tpos + 2] ==']') {
               panel_type = AC_panel_new;
               SERIAL_ECHOLNF(AC_msg_new_panel_detected);
             }
@@ -811,7 +813,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
     } break;
 
     case 30:     // A30 Auto leveling
-      if (FindToken('S') != -1) { // Start probing New panel adds spaces..
+      if (FindToken('S') >= 0) { // Start probing New panel adds spaces..
         // Ignore request if printing
         if (isPrinting())
           SendtoTFTLN(AC_msg_probing_not_allowed); // forbid auto leveling
@@ -828,7 +830,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
     case 31:   // A31 Adjust all Probe Points
       // The tokens can occur in different places on the new panel so we need to find it.
 
-      if (FindToken('C') != -1) { // Restore and apply original offsets
+      if (FindToken('C') >= 0) { // Restore and apply original offsets
         if (!isPrinting()) {
           injectCommands(F("M501\nM420 S1"));
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
@@ -836,7 +838,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
         }
       }
 
-      else if (FindToken('D') != -1) { // Save Z Offset tables and restore leveling state
+      else if (FindToken('D') >= 0) { // Save Z Offset tables and restore leveling state
         if (!isPrinting()) {
           setAxisPosition_mm(1.0,Z); // Lift nozzle before any further movements are made
           injectCommands(F("M500"));
@@ -845,7 +847,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
         }
       }
 
-      else if (FindToken('G') != -1) { // Get current offset
+      else if (FindToken('G') >= 0) { // Get current offset
         SendtoTFT(F("A31V "));
         // When printing use the live z Offset position
         // we will use babystepping to move the print head
@@ -859,7 +861,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
 
       else {
         int8_t tokenpos = FindToken('S');
-        if (tokenpos != -1) { // Set offset (adjusts all points by value)
+        if (tokenpos >= 0) { // Set offset (adjusts all points by value)
           float Zshift = atof(&panel_command[tokenpos+1]);
           setSoftEndstopState(false);  // disable endstops
           // Allow temporary Z position nudging during print

commit 623c6b720b0d9b14934fb8ccb895d421ab043cc9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 12 15:58:28 2022 -0600

    üßë‚Äçüíª Add ExtUI::onLevelingDone, match DWIN to ExtUI

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index c56d8aa7fb..fac0615cd6 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -86,13 +86,23 @@ void ChironTFT::Startup() {
   TFTSer.begin(115200);
 
   // wait for the TFT panel to initialise and finish the animation
-  delay_ms(250);
+  safe_delay(1000);
 
   // There are different panels for the Chiron with slightly different commands
   // So we need to know what we are working with.
-
   // Panel type can be defined otherwise detect it automatically
-  if (panel_type == AC_panel_unknown) DetectPanelType();
+  switch (panel_type) {
+    case AC_panel_new:
+      SERIAL_ECHOLNF(AC_msg_new_panel_set);
+      break;
+    case AC_panel_standard:
+      SERIAL_ECHOLNF(AC_msg_old_panel_set);
+      break;
+    default:
+      SERIAL_ECHOLNF(AC_msg_auto_panel_detection);
+      DetectPanelType();
+      break;
+  }
 
   // Signal Board has reset
   SendtoTFTLN(AC_msg_main_board_has_reset);
@@ -358,15 +368,14 @@ bool ChironTFT::ReadTFTCommand() {
 }
 
 int8_t ChironTFT::FindToken(char c) {
-  int8_t pos = 0;
-  do {
+  for (int8_t pos = 0; pos < command_len; pos++) {
     if (panel_command[pos] == c) {
       #if ACDEBUG(AC_INFO)
         SERIAL_ECHOLNPGM("Tpos:", pos, " ", c);
       #endif
       return pos;
     }
-  } while (++pos < command_len);
+  }
   #if ACDEBUG(AC_INFO)
     SERIAL_ECHOLNPGM("Not found: ", c);
   #endif
@@ -623,18 +632,18 @@ void ChironTFT::PanelAction(uint8_t req) {
       SelectFile();
       break;
 
-    case 14: { // A14 Start Printing
+    case 14:   // A14 Start Printing
       // Allows printer to restart the job if we don't want to recover
       if (printer_state == AC_printer_resuming_from_power_outage) {
         injectCommands(F("M1000 C")); // Cancel recovery
         printer_state = AC_printer_idle;
       }
       #if ACDebugLevel >= 1
-        SERIAL_ECHOLNPAIR_F("Print: ", selectedfile);
+        SERIAL_ECHOLNPGM("Print: ", selectedfile);
       #endif
       printFile(selectedfile);
       SendtoTFTLN(AC_msg_print_from_sd_card);
-    } break;
+      break;
 
     case 15:   // A15 Resuming from outage
       if (printer_state == AC_printer_resuming_from_power_outage) {
@@ -801,25 +810,22 @@ void ChironTFT::PanelProcess(uint8_t req) {
       }
     } break;
 
-    case 30: {   // A30 Auto leveling
+    case 30:     // A30 Auto leveling
       if (FindToken('S') != -1) { // Start probing New panel adds spaces..
         // Ignore request if printing
         if (isPrinting())
           SendtoTFTLN(AC_msg_probing_not_allowed); // forbid auto leveling
         else {
-
-
           SendtoTFTLN(AC_msg_start_probing);
           injectCommands(F("G28\nG29"));
           printer_state = AC_printer_probing;
         }
       }
-      else {
+      else
         SendtoTFTLN(AC_msg_start_probing); // Just enter levelling menu
-      }
-    } break;
+      break;
 
-    case 31: { // A31 Adjust all Probe Points
+    case 31:   // A31 Adjust all Probe Points
       // The tokens can occur in different places on the new panel so we need to find it.
 
       if (FindToken('C') != -1) { // Restore and apply original offsets
@@ -907,18 +913,18 @@ void ChironTFT::PanelProcess(uint8_t req) {
           }
         }
       }
-    } break;
+      break;
 
-    case 32: { // A32 clean leveling beep flag
+    case 32:   // A32 clean leveling beep flag
       // Ignore request if printing
       //if (isPrinting()) break;
       //injectCommands(F("M500\nM420 S1\nG1 Z10 F240\nG1 X0 Y0 F6000"));
       //TFTSer.println();
-    } break;
+      break;
 
     // A33 firmware info request see PanelInfo()
 
-    case 34: {  // A34 Adjust single mesh point A34 C/S X1 Y1 V123
+    case 34:    // A34 Adjust single mesh point A34 C/S X1 Y1 V123
       if (panel_command[3] == 'C') { // Restore original offsets
         injectCommands(F("M501\nM420 S1"));
         selectedmeshpoint.x = selectedmeshpoint.y = 99;
@@ -950,7 +956,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
           }
         }
       }
-    }  break;
+      break;
 
     case 36:    // A36 Auto leveling for new TFT bet that was a typo in the panel code!
       SendtoTFTLN(AC_msg_start_probing);

commit 13ce5aa1ed4ab4f8fc01f7ff6f7ad7884fc28ea9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Dec 21 22:15:48 2021 -0600

    üé® Misc. cleanup

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 6db5972fa7..c56d8aa7fb 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -366,7 +366,7 @@ int8_t ChironTFT::FindToken(char c) {
       #endif
       return pos;
     }
-  } while(++pos < command_len);
+  } while (++pos < command_len);
   #if ACDEBUG(AC_INFO)
     SERIAL_ECHOLNPGM("Not found: ", c);
   #endif

commit 7762df7251f1da3be2933670084b416d4a06c89f
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Sun Dec 26 09:46:13 2021 +0300

    üîß Check Chiron LCD requirements (#23353)
    
    Co-Authored-By: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 9f558e3a98..6db5972fa7 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -243,7 +243,7 @@ void ChironTFT::StatusChange(const char * const msg)  {
     case AC_printer_probing: {
       // If probing completes ok save the mesh and park
       // Ignore the custom machine name
-      if (strcmp_P(msg + strlen(CUSTOM_MACHINE_NAME), MARLIN_msg_ready) == 0) {
+      if (strcmp_P(msg + strlen(MACHINE_NAME), MARLIN_msg_ready) == 0) {
         injectCommands(F("M500\nG27"));
         SendtoTFTLN(AC_msg_probing_complete);
         printer_state = AC_printer_idle;

commit e8459ae63c8290123827b4e45bbe051c95060783
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 4 19:50:14 2021 -0500

    üêõ ExtUI F() followups
    
    Followup to 12b5d997a2

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index c3fc6aa96e..9f558e3a98 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -315,7 +315,7 @@ void ChironTFT::PrintComplete() {
   setSoftEndstopState(true); // enable endstops
 }
 
-void ChironTFT::SendtoTFT(FSTR_P const fstr) {  // A helper to print PROGMEM string to the panel
+void ChironTFT::SendtoTFT(FSTR_P const fstr/*=nullptr*/) {  // A helper to print PROGMEM string to the panel
   #if ACDEBUG(AC_SOME)
     SERIAL_ECHOF(fstr);
   #endif
@@ -323,7 +323,7 @@ void ChironTFT::SendtoTFT(FSTR_P const fstr) {  // A helper to print PROGMEM str
   while (const char c = pgm_read_byte(str++)) TFTSer.write(c);
 }
 
-void ChironTFT::SendtoTFTLN(FSTR_P const fstr) {
+void ChironTFT::SendtoTFTLN(FSTR_P const fstr/*=nullptr*/) {
   if (fstr) {
     #if ACDEBUG(AC_SOME)
       SERIAL_ECHOPGM("> ");

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    üé® Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 483da200e8..c3fc6aa96e 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -126,7 +126,7 @@ void ChironTFT::IdleLoop()  {
   CheckHeaters();
 }
 
-void ChironTFT::PrinterKilled(PGM_P error,PGM_P component)  {
+void ChironTFT::PrinterKilled(FSTR_P const error, FSTR_P const component)  {
   SendtoTFTLN(AC_msg_kill_lcd);
   #if ACDEBUG(AC_MARLIN)
     SERIAL_ECHOLNPGM("PrinterKilled()\nerror: ", error , "\ncomponent: ", component);

commit 12b5d997a2cee538e5026a68f8e0cfdd53248986
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 25 22:11:48 2021 -0500

    üé® Apply F() to some ExtUI functions

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index e7b3941928..483da200e8 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -99,7 +99,7 @@ void ChironTFT::Startup() {
 
   // Enable leveling and Disable end stops during print
   // as Z home places nozzle above the bed so we need to allow it past the end stops
-  injectCommands_P(AC_cmnd_enable_leveling);
+  injectCommands(AC_cmnd_enable_leveling);
 
   // Startup tunes are defined in Tunes.h
   PlayTune(BEEPER_PIN, TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn), 1);
@@ -244,7 +244,7 @@ void ChironTFT::StatusChange(const char * const msg)  {
       // If probing completes ok save the mesh and park
       // Ignore the custom machine name
       if (strcmp_P(msg + strlen(CUSTOM_MACHINE_NAME), MARLIN_msg_ready) == 0) {
-        injectCommands_P(PSTR("M500\nG27"));
+        injectCommands(F("M500\nG27"));
         SendtoTFTLN(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
@@ -252,7 +252,7 @@ void ChironTFT::StatusChange(const char * const msg)  {
       // If probing fails don't save the mesh raise the probe above the bad point
       if (strcmp_P(msg, MARLIN_msg_probing_failed) == 0) {
         PlayTune(BEEPER_PIN, BeepBeepBeeep, 1);
-        injectCommands_P(PSTR("G1 Z50 F500"));
+        injectCommands(F("G1 Z50 F500"));
         SendtoTFTLN(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
@@ -315,19 +315,20 @@ void ChironTFT::PrintComplete() {
   setSoftEndstopState(true); // enable endstops
 }
 
-void ChironTFT::SendtoTFT(PGM_P str) {  // A helper to print PROGMEM string to the panel
+void ChironTFT::SendtoTFT(FSTR_P const fstr) {  // A helper to print PROGMEM string to the panel
   #if ACDEBUG(AC_SOME)
-    SERIAL_ECHOPGM_P(str);
+    SERIAL_ECHOF(fstr);
   #endif
+  PGM_P str = FTOP(fstr);
   while (const char c = pgm_read_byte(str++)) TFTSer.write(c);
 }
 
-void ChironTFT::SendtoTFTLN(PGM_P str = nullptr) {
-  if (str) {
+void ChironTFT::SendtoTFTLN(FSTR_P const fstr) {
+  if (fstr) {
     #if ACDEBUG(AC_SOME)
       SERIAL_ECHOPGM("> ");
     #endif
-    SendtoTFT(str);
+    SendtoTFT(fstr);
     #if ACDEBUG(AC_SOME)
       SERIAL_EOL();
     #endif
@@ -426,9 +427,9 @@ void ChironTFT::SendFileList(int8_t startindex) {
   #if ACDEBUG(AC_INFO)
     SERIAL_ECHOLNPGM("## SendFileList ## ", startindex);
   #endif
-  SendtoTFTLN(PSTR("FN "));
+  SendtoTFTLN(F("FN "));
   filenavigator.getFiles(startindex, panel_type, 4);
-  SendtoTFTLN(PSTR("END"));
+  SendtoTFTLN(F("END"));
 }
 
 void ChironTFT::SelectFile() {
@@ -512,55 +513,55 @@ void ChironTFT::PanelInfo(uint8_t req) {
   // information requests A0-A8 and A33
   switch (req) {
     case 0:   // A0 Get HOTEND Temp
-      SendtoTFT(PSTR("A0V "));
+      SendtoTFT(F("A0V "));
       TFTSer.println(getActualTemp_celsius(E0));
       break;
 
     case 1:   // A1 Get HOTEND Target Temp
-      SendtoTFT(PSTR("A1V "));
+      SendtoTFT(F("A1V "));
       TFTSer.println(getTargetTemp_celsius(E0));
       break;
 
     case 2:   // A2 Get BED Temp
-      SendtoTFT(PSTR("A2V "));
+      SendtoTFT(F("A2V "));
       TFTSer.println(getActualTemp_celsius(BED));
       break;
 
     case 3:   // A3 Get BED Target Temp
-      SendtoTFT(PSTR("A3V "));
+      SendtoTFT(F("A3V "));
       TFTSer.println(getTargetTemp_celsius(BED));
       break;
 
     case 4:   // A4 Get FAN Speed
-      SendtoTFT(PSTR("A4V "));
+      SendtoTFT(F("A4V "));
       TFTSer.println(getActualFan_percent(FAN0));
       break;
 
     case 5:   // A5 Get Current Coordinates
-      SendtoTFT(PSTR("A5V X: "));
+      SendtoTFT(F("A5V X: "));
       TFTSer.print(getAxisPosition_mm(X));
-      SendtoTFT(PSTR(" Y: "));
+      SendtoTFT(F(" Y: "));
       TFTSer.print(getAxisPosition_mm(Y));
-      SendtoTFT(PSTR(" Z: "));
+      SendtoTFT(F(" Z: "));
       TFTSer.println(getAxisPosition_mm(Z));
       break;
 
     case 6:   // A6 Get printing progress
       if (isPrintingFromMedia()) {
-        SendtoTFT(PSTR("A6V "));
+        SendtoTFT(F("A6V "));
         TFTSer.println(ui8tostr2(getProgress_percent()));
       }
       else
-        SendtoTFTLN(PSTR("A6V ---"));
+        SendtoTFTLN(F("A6V ---"));
       break;
 
     case 7: { // A7 Get Printing Time
       uint32_t time = getProgress_seconds_elapsed() / 60;
-      SendtoTFT(PSTR("A7V "));
+      SendtoTFT(F("A7V "));
       TFTSer.print(ui8tostr2(time / 60));
-      SendtoTFT(PSTR(" H "));
+      SendtoTFT(F(" H "));
       TFTSer.print(ui8tostr2(time % 60));
-      SendtoTFT(PSTR(" M"));
+      SendtoTFT(F(" M"));
       #if ACDEBUG(AC_ALL)
         SERIAL_ECHOLNPGM("Print time ", ui8tostr2(time / 60), ":", ui8tostr2(time % 60));
       #endif
@@ -575,9 +576,9 @@ void ChironTFT::PanelInfo(uint8_t req) {
       break;
 
     case 33:   // A33 Get firmware info
-      SendtoTFT(PSTR("J33 "));
+      SendtoTFT(F("J33 "));
       // If there is an error recorded, show that instead of the FW version
-      if (!GetLastError()) SendtoTFTLN(PSTR(SHORT_BUILD_VERSION));
+      if (!GetLastError()) SendtoTFTLN(F(SHORT_BUILD_VERSION));
       break;
   }
 }
@@ -608,7 +609,7 @@ void ChironTFT::PanelAction(uint8_t req) {
       }
       else {
         if (printer_state == AC_printer_resuming_from_power_outage)
-          injectCommands_P(PSTR("M1000 C")); // Cancel recovery
+          injectCommands(F("M1000 C")); // Cancel recovery
         SendtoTFTLN(AC_msg_stop);
         printer_state = AC_printer_idle;
       }
@@ -625,7 +626,7 @@ void ChironTFT::PanelAction(uint8_t req) {
     case 14: { // A14 Start Printing
       // Allows printer to restart the job if we don't want to recover
       if (printer_state == AC_printer_resuming_from_power_outage) {
-        injectCommands_P(PSTR("M1000 C")); // Cancel recovery
+        injectCommands(F("M1000 C")); // Cancel recovery
         printer_state = AC_printer_idle;
       }
       #if ACDebugLevel >= 1
@@ -638,8 +639,8 @@ void ChironTFT::PanelAction(uint8_t req) {
     case 15:   // A15 Resuming from outage
       if (printer_state == AC_printer_resuming_from_power_outage) {
         // Need to home here to restore the Z position
-        injectCommands_P(AC_cmnd_power_loss_recovery);
-        injectCommands_P(PSTR("M1000"));  // home and start recovery
+        injectCommands(AC_cmnd_power_loss_recovery);
+        injectCommands(F("M1000"));  // home and start recovery
       }
       break;
 
@@ -675,7 +676,7 @@ void ChironTFT::PanelAction(uint8_t req) {
       if (panel_command[4] == 'S')
         setFeedrate_percent(atoi(&panel_command[5]));
       else {
-        SendtoTFT(PSTR("A20V "));
+        SendtoTFT(F("A20V "));
         TFTSer.println(getFeedrate_percent());
       }
       break;
@@ -683,9 +684,9 @@ void ChironTFT::PanelAction(uint8_t req) {
     case 21:   // A21 Home Axis  A21 X
       if (!isPrinting()) {
         switch ((char)panel_command[4]) {
-          case 'X': injectCommands_P(PSTR("G28X")); break;
-          case 'Y': injectCommands_P(PSTR("G28Y")); break;
-          case 'Z': injectCommands_P(PSTR("G28Z")); break;
+          case 'X': injectCommands(F("G28X")); break;
+          case 'Y': injectCommands(F("G28Y")); break;
+          case 'Z': injectCommands(F("G28Z")); break;
           case 'C': injectCommands_P(G28_STR); break;
         }
       }
@@ -771,7 +772,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
       pos.y = atoi(&panel_command[FindToken('Y')+1]);
       pos_z = getMeshPoint(pos);
 
-      SendtoTFT(PSTR("A29V "));
+      SendtoTFT(F("A29V "));
       TFTSer.println(pos_z * 100);
       if (!isPrinting()) {
         setSoftEndstopState(true);  // disable endstops
@@ -809,7 +810,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
 
 
           SendtoTFTLN(AC_msg_start_probing);
-          injectCommands_P(PSTR("G28\nG29"));
+          injectCommands(F("G28\nG29"));
           printer_state = AC_printer_probing;
         }
       }
@@ -823,7 +824,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
 
       if (FindToken('C') != -1) { // Restore and apply original offsets
         if (!isPrinting()) {
-          injectCommands_P(PSTR("M501\nM420 S1"));
+          injectCommands(F("M501\nM420 S1"));
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
           SERIAL_ECHOLNF(AC_msg_mesh_changes_abandoned);
         }
@@ -832,14 +833,14 @@ void ChironTFT::PanelProcess(uint8_t req) {
       else if (FindToken('D') != -1) { // Save Z Offset tables and restore leveling state
         if (!isPrinting()) {
           setAxisPosition_mm(1.0,Z); // Lift nozzle before any further movements are made
-          injectCommands_P(PSTR("M500"));
+          injectCommands(F("M500"));
           SERIAL_ECHOLNF(AC_msg_mesh_changes_saved);
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
         }
       }
 
       else if (FindToken('G') != -1) { // Get current offset
-        SendtoTFT(PSTR("A31V "));
+        SendtoTFT(F("A31V "));
         // When printing use the live z Offset position
         // we will use babystepping to move the print head
         if (isPrinting())
@@ -874,7 +875,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
               babystepAxis_steps(steps, Z);
               live_Zoffset += Zshift;
             }
-            SendtoTFT(PSTR("A31V "));
+            SendtoTFT(F("A31V "));
             TFTSer.println(live_Zoffset);
           }
           else {
@@ -892,7 +893,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
             #endif
 
             setZOffset_mm(currZOffset + Zshift);
-            SendtoTFT(PSTR("A31V "));
+            SendtoTFT(F("A31V "));
             TFTSer.println(getZOffset_mm());
 
             if (isAxisPositionKnown(Z)) {
@@ -911,7 +912,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
     case 32: { // A32 clean leveling beep flag
       // Ignore request if printing
       //if (isPrinting()) break;
-      //injectCommands_P(PSTR("M500\nM420 S1\nG1 Z10 F240\nG1 X0 Y0 F6000"));
+      //injectCommands(F("M500\nM420 S1\nG1 Z10 F240\nG1 X0 Y0 F6000"));
       //TFTSer.println();
     } break;
 
@@ -919,7 +920,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
 
     case 34: {  // A34 Adjust single mesh point A34 C/S X1 Y1 V123
       if (panel_command[3] == 'C') { // Restore original offsets
-        injectCommands_P(PSTR("M501\nM420 S1"));
+        injectCommands(F("M501\nM420 S1"));
         selectedmeshpoint.x = selectedmeshpoint.y = 99;
         //printer_state = AC_printer_idle;
       }

commit 520b97083e52efdd47ab434b97823e48d85ade62
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 11:03:07 2021 -0500

    üé® Apply F() to serial macros

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 1b572367f2..e7b3941928 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -306,7 +306,7 @@ void ChironTFT::PowerLossRecovery()  {
   printer_state = AC_printer_resuming_from_power_outage; // Play tune to notify user we can recover.
   last_error = AC_error_powerloss;
   PlayTune(BEEPER_PIN, SOS, 1);
-  SERIAL_ECHOLNPGM_P(AC_msg_powerloss_recovery);
+  SERIAL_ECHOLNF(AC_msg_powerloss_recovery);
 }
 
 void ChironTFT::PrintComplete() {
@@ -488,7 +488,7 @@ void ChironTFT::ProcessPanelRequest() {
         if (tpos != -1) {
           if (panel_command[tpos+1]== 'X' && panel_command[tpos+2]=='Y') {
             panel_type = AC_panel_standard;
-            SERIAL_ECHOLNPGM_P(AC_msg_old_panel_detected);
+            SERIAL_ECHOLNF(AC_msg_old_panel_detected);
           }
         }
         else {
@@ -496,7 +496,7 @@ void ChironTFT::ProcessPanelRequest() {
           if (tpos != -1) {
             if (panel_command[tpos+1]== '0' && panel_command[tpos+2]==']') {
               panel_type = AC_panel_new;
-              SERIAL_ECHOLNPGM_P(AC_msg_new_panel_detected);
+              SERIAL_ECHOLNF(AC_msg_new_panel_detected);
             }
           }
         }
@@ -825,7 +825,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
         if (!isPrinting()) {
           injectCommands_P(PSTR("M501\nM420 S1"));
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
-          SERIAL_ECHOLNPGM_P(AC_msg_mesh_changes_abandoned);
+          SERIAL_ECHOLNF(AC_msg_mesh_changes_abandoned);
         }
       }
 
@@ -833,7 +833,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
         if (!isPrinting()) {
           setAxisPosition_mm(1.0,Z); // Lift nozzle before any further movements are made
           injectCommands_P(PSTR("M500"));
-          SERIAL_ECHOLNPGM_P(AC_msg_mesh_changes_saved);
+          SERIAL_ECHOLNF(AC_msg_mesh_changes_saved);
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
         }
       }

commit 33e0855e2c173680865aaa6c6aa93047d63fc469
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 01:07:51 2021 -0500

    ‚ö°Ô∏è Handle shared enable pins (#22824)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 42364f2890..1b572367f2 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -37,6 +37,7 @@
 #include "FileNavigator.h"
 
 #include "../../../gcode/queue.h"
+#include "../../../module/stepper.h"
 #include "../../../sd/cardreader.h"
 #include "../../../libs/numtostr.h"
 #include "../../../MarlinCore.h"
@@ -665,7 +666,7 @@ void ChironTFT::PanelAction(uint8_t req) {
 
     case 19:   // A19 Motors off
       if (!isPrinting()) {
-        disable_all_steppers(); // from marlincore.h
+        stepper.disable_all_steppers();
         SendtoTFTLN(AC_msg_ready);
       }
       break;

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 0ecb138bd5..42364f2890 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -104,7 +104,7 @@ void ChironTFT::Startup() {
   PlayTune(BEEPER_PIN, TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn), 1);
 
   #if ACDEBUGLEVEL
-    SERIAL_ECHOLNPAIR("AC Debug Level ", ACDEBUGLEVEL);
+    SERIAL_ECHOLNPGM("AC Debug Level ", ACDEBUGLEVEL);
   #endif
   SendtoTFTLN(AC_msg_ready);
 }
@@ -128,13 +128,13 @@ void ChironTFT::IdleLoop()  {
 void ChironTFT::PrinterKilled(PGM_P error,PGM_P component)  {
   SendtoTFTLN(AC_msg_kill_lcd);
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPAIR("PrinterKilled()\nerror: ", error , "\ncomponent: ", component);
+    SERIAL_ECHOLNPGM("PrinterKilled()\nerror: ", error , "\ncomponent: ", component);
   #endif
 }
 
 void ChironTFT::MediaEvent(media_event_t event)  {
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPAIR("ProcessMediaStatus() ", event);
+    SERIAL_ECHOLNPGM("ProcessMediaStatus() ", event);
   #endif
   switch (event) {
     case AC_media_inserted:
@@ -154,8 +154,8 @@ void ChironTFT::MediaEvent(media_event_t event)  {
 
 void ChironTFT::TimerEvent(timer_event_t event)  {
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPAIR("TimerEvent() ", event);
-    SERIAL_ECHOLNPAIR("Printer State: ", printer_state);
+    SERIAL_ECHOLNPGM("TimerEvent() ", event);
+    SERIAL_ECHOLNPGM("Printer State: ", printer_state);
   #endif
 
   switch (event) {
@@ -184,7 +184,7 @@ void ChironTFT::TimerEvent(timer_event_t event)  {
 
 void ChironTFT::FilamentRunout()  {
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPAIR("FilamentRunout() printer_state ", printer_state);
+    SERIAL_ECHOLNPGM("FilamentRunout() printer_state ", printer_state);
   #endif
   // 1 Signal filament out
   last_error = AC_error_filament_runout;
@@ -195,7 +195,7 @@ void ChironTFT::FilamentRunout()  {
 void ChironTFT::ConfirmationRequest(const char * const msg)  {
   // M108 continue
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPAIR("ConfirmationRequest() ", msg, " printer_state:", printer_state);
+    SERIAL_ECHOLNPGM("ConfirmationRequest() ", msg, " printer_state:", printer_state);
   #endif
   switch (printer_state) {
     case AC_printer_pausing: {
@@ -232,8 +232,8 @@ void ChironTFT::ConfirmationRequest(const char * const msg)  {
 
 void ChironTFT::StatusChange(const char * const msg)  {
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPAIR("StatusChange() ", msg);
-    SERIAL_ECHOLNPAIR("printer_state:", printer_state);
+    SERIAL_ECHOLNPGM("StatusChange() ", msg);
+    SERIAL_ECHOLNPGM("printer_state:", printer_state);
   #endif
   bool msg_matched = false;
   // The only way to get printer status is to parse messages
@@ -348,7 +348,7 @@ bool ChironTFT::ReadTFTCommand() {
   if (command_ready || command_len == MAX_CMND_LEN) {
     panel_command[command_len] = '\0';
     #if ACDEBUG(AC_ALL)
-      SERIAL_ECHOLNPAIR("len(",command_len,") < ", panel_command);
+      SERIAL_ECHOLNPGM("len(",command_len,") < ", panel_command);
     #endif
     command_ready = true;
   }
@@ -360,13 +360,13 @@ int8_t ChironTFT::FindToken(char c) {
   do {
     if (panel_command[pos] == c) {
       #if ACDEBUG(AC_INFO)
-        SERIAL_ECHOLNPAIR("Tpos:", pos, " ", c);
+        SERIAL_ECHOLNPGM("Tpos:", pos, " ", c);
       #endif
       return pos;
     }
   } while(++pos < command_len);
   #if ACDEBUG(AC_INFO)
-    SERIAL_ECHOLNPAIR("Not found: ", c);
+    SERIAL_ECHOLNPGM("Not found: ", c);
   #endif
   return -1;
 }
@@ -381,7 +381,7 @@ void ChironTFT::CheckHeaters() {
     if (faultDuration >= AC_HEATER_FAULT_VALIDATION_TIME) {
       SendtoTFTLN(AC_msg_nozzle_temp_abnormal);
       last_error = AC_error_abnormal_temp_t0;
-      SERIAL_ECHOLNPAIR("Extruder temp abnormal! : ", temp);
+      SERIAL_ECHOLNPGM("Extruder temp abnormal! : ", temp);
       break;
     }
     delay_ms(500);
@@ -396,7 +396,7 @@ void ChironTFT::CheckHeaters() {
     if (faultDuration >= AC_HEATER_FAULT_VALIDATION_TIME) {
       SendtoTFTLN(AC_msg_nozzle_temp_abnormal);
       last_error = AC_error_abnormal_temp_bed;
-      SERIAL_ECHOLNPAIR("Bed temp abnormal! : ", temp);
+      SERIAL_ECHOLNPGM("Bed temp abnormal! : ", temp);
       break;
     }
     delay_ms(500);
@@ -423,7 +423,7 @@ void ChironTFT::CheckHeaters() {
 void ChironTFT::SendFileList(int8_t startindex) {
   // Respond to panel request for 4 files starting at index
   #if ACDEBUG(AC_INFO)
-    SERIAL_ECHOLNPAIR("## SendFileList ## ", startindex);
+    SERIAL_ECHOLNPGM("## SendFileList ## ", startindex);
   #endif
   SendtoTFTLN(PSTR("FN "));
   filenavigator.getFiles(startindex, panel_type, 4);
@@ -440,7 +440,7 @@ void ChironTFT::SelectFile() {
     selectedfile[command_len - 5] = '\0';
   }
   #if ACDEBUG(AC_FILE)
-    SERIAL_ECHOLNPAIR(" Selected File: ",selectedfile);
+    SERIAL_ECHOLNPGM(" Selected File: ",selectedfile);
   #endif
   switch (selectedfile[0]) {
     case '/':   // Valid file selected
@@ -561,7 +561,7 @@ void ChironTFT::PanelInfo(uint8_t req) {
       TFTSer.print(ui8tostr2(time % 60));
       SendtoTFT(PSTR(" M"));
       #if ACDEBUG(AC_ALL)
-        SERIAL_ECHOLNPAIR("Print time ", ui8tostr2(time / 60), ":", ui8tostr2(time % 60));
+        SERIAL_ECHOLNPGM("Print time ", ui8tostr2(time / 60), ":", ui8tostr2(time % 60));
       #endif
     } break;
 
@@ -702,7 +702,7 @@ void ChironTFT::PanelAction(uint8_t req) {
         char MoveCmnd[30];
         sprintf_P(MoveCmnd, PSTR("G91\nG0%s\nG90"), panel_command + 3);
         #if ACDEBUG(AC_ACTION)
-          SERIAL_ECHOLNPAIR("Move: ", MoveCmnd);
+          SERIAL_ECHOLNPGM("Move: ", MoveCmnd);
         #endif
         setSoftEndstopState(true);  // enable endstops
         injectCommands(MoveCmnd);
@@ -781,7 +781,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
 
           if (isPositionKnown()) {
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPAIR("Moving to mesh point at x: ", pos.x, " y: ", pos.y, " z: ", pos_z);
+              SERIAL_ECHOLNPGM("Moving to mesh point at x: ", pos.x, " y: ", pos.y, " z: ", pos_z);
             #endif
             // Go up before moving
             setAxisPosition_mm(3.0,Z);
@@ -790,7 +790,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
             setAxisPosition_mm(20 + (93 * pos.y), Y);
             setAxisPosition_mm(0.0, Z);
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPAIR("Current Z: ", getAxisPosition_mm(Z));
+              SERIAL_ECHOLNPGM("Current Z: ", getAxisPosition_mm(Z));
             #endif
           }
         }
@@ -858,17 +858,17 @@ void ChironTFT::PanelProcess(uint8_t req) {
           // From the leveling panel use the all points UI to adjust the print pos.
           if (isPrinting()) {
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPAIR("Change Zoffset from:", live_Zoffset, " to ", live_Zoffset + Zshift);
+              SERIAL_ECHOLNPGM("Change Zoffset from:", live_Zoffset, " to ", live_Zoffset + Zshift);
             #endif
             if (isAxisPositionKnown(Z)) {
               #if ACDEBUG(AC_INFO)
                 const float currZpos = getAxisPosition_mm(Z);
-                SERIAL_ECHOLNPAIR("Nudge Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
+                SERIAL_ECHOLNPGM("Nudge Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
               #endif
               // Use babystepping to adjust the head position
               int16_t steps = mmToWholeSteps(constrain(Zshift,-0.05,0.05), Z);
               #if ACDEBUG(AC_INFO)
-                SERIAL_ECHOLNPAIR("Steps to move Z: ", steps);
+                SERIAL_ECHOLNPGM("Steps to move Z: ", steps);
               #endif
               babystepAxis_steps(steps, Z);
               live_Zoffset += Zshift;
@@ -882,12 +882,12 @@ void ChironTFT::PanelProcess(uint8_t req) {
               const float currval = getMeshPoint(pos);
               setMeshPoint(pos, constrain(currval + Zshift, AC_LOWEST_MESHPOINT_VAL, 2));
               #if ACDEBUG(AC_INFO)
-                SERIAL_ECHOLNPAIR("Change mesh point X", x," Y",y ," from ", currval, " to ", getMeshPoint(pos) );
+                SERIAL_ECHOLNPGM("Change mesh point X", x," Y",y ," from ", currval, " to ", getMeshPoint(pos) );
               #endif
             }
             const float currZOffset = getZOffset_mm();
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPAIR("Change probe offset from ", currZOffset, " to  ", currZOffset + Zshift);
+              SERIAL_ECHOLNPGM("Change probe offset from ", currZOffset, " to  ", currZOffset + Zshift);
             #endif
 
             setZOffset_mm(currZOffset + Zshift);
@@ -898,7 +898,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
               // Move Z axis
               const float currZpos = getAxisPosition_mm(Z);
               #if ACDEBUG(AC_INFO)
-                SERIAL_ECHOLNPAIR("Move Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
+                SERIAL_ECHOLNPGM("Move Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
               #endif
               setAxisPosition_mm(currZpos+constrain(Zshift,-0.05,0.05),Z);
             }
@@ -930,8 +930,8 @@ void ChironTFT::PanelProcess(uint8_t req) {
         float currmesh = getMeshPoint(pos);
         float newval   = atof(&panel_command[11])/100;
         #if ACDEBUG(AC_INFO)
-          SERIAL_ECHOLNPAIR("Change mesh point x:", pos.x, " y:", pos.y);
-          SERIAL_ECHOLNPAIR("from ", currmesh, " to ", newval);
+          SERIAL_ECHOLNPGM("Change mesh point x:", pos.x, " y:", pos.y);
+          SERIAL_ECHOLNPGM("from ", currmesh, " to ", newval);
         #endif
         // Update Meshpoint
         setMeshPoint(pos,newval);
@@ -942,7 +942,7 @@ void ChironTFT::PanelProcess(uint8_t req) {
             setSoftEndstopState(false);
             float currZpos = getAxisPosition_mm(Z);
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPAIR("Move Z pos from ", currZpos, " to ", currZpos + constrain(newval - currmesh, -0.05, 0.05));
+              SERIAL_ECHOLNPGM("Move Z pos from ", currZpos, " to ", currZpos + constrain(newval - currmesh, -0.05, 0.05));
             #endif
             setAxisPosition_mm(currZpos + constrain(newval - currmesh, -0.05, 0.05), Z);
           }

commit afca6e745932d295b88d37fa9bd4274e22705b0b
Author: luzpaz <luzpaz@users.noreply.github.com>
Date:   Tue Aug 3 20:02:34 2021 -0400

    üêõ Spellcheck comments (#22496)
    
    codespell -q 3 --builtin=clear,rare,informal,code -S ./Marlin/src/lcd/language -L alo,amin,endcode,stdio,uint

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 14d394db72..0ecb138bd5 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -208,7 +208,7 @@ void ChironTFT::ConfirmationRequest(const char * const msg)  {
     case AC_printer_resuming_from_power_outage:
     case AC_printer_printing:
     case AC_printer_paused: {
-      // Heater timout, send acknowledgement
+      // Heater timeout, send acknowledgement
       if (strcmp_P(msg, MARLIN_msg_heater_timeout) == 0) {
         pause_state = AC_paused_heater_timed_out;
         SendtoTFTLN(AC_msg_paused); // enable continue button
@@ -248,7 +248,7 @@ void ChironTFT::StatusChange(const char * const msg)  {
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
-      // If probing fails dont save the mesh raise the probe above the bad point
+      // If probing fails don't save the mesh raise the probe above the bad point
       if (strcmp_P(msg, MARLIN_msg_probing_failed) == 0) {
         PlayTune(BEEPER_PIN, BeepBeepBeeep, 1);
         injectCommands_P(PSTR("G1 Z50 F500"));
@@ -622,7 +622,7 @@ void ChironTFT::PanelAction(uint8_t req) {
       break;
 
     case 14: { // A14 Start Printing
-      // Allows printer to restart the job if we dont want to recover
+      // Allows printer to restart the job if we don't want to recover
       if (printer_state == AC_printer_resuming_from_power_outage) {
         injectCommands_P(PSTR("M1000 C")); // Cancel recovery
         printer_state = AC_printer_idle;

commit 8d9021e8069c0550e9a31107adf44b9112b87471
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 6 04:17:59 2021 -0500

    Move ExtUI subfolders up a level (#21820)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
new file mode 100644
index 0000000000..14d394db72
--- /dev/null
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -0,0 +1,975 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * lcd/extui/anycubic_chiron/chiron_tft.cpp
+ *
+ * Extensible_UI implementation for Anycubic Chiron
+ * Written By Nick Wells, 2020 [https://github.com/SwiftNick]
+ *  (not affiliated with Anycubic, Ltd.)
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if ENABLED(ANYCUBIC_LCD_CHIRON)
+
+#include "chiron_tft.h"
+#include "Tunes.h"
+#include "FileNavigator.h"
+
+#include "../../../gcode/queue.h"
+#include "../../../sd/cardreader.h"
+#include "../../../libs/numtostr.h"
+#include "../../../MarlinCore.h"
+
+namespace Anycubic {
+
+ChironTFT Chiron;
+#if AUTO_DETECT_CHIRON_TFT
+  panel_type_t   ChironTFT::panel_type = AC_panel_unknown;
+#endif
+last_error_t     ChironTFT::last_error;
+printer_state_t  ChironTFT::printer_state;
+paused_state_t   ChironTFT::pause_state;
+heater_state_t   ChironTFT::hotend_state;
+heater_state_t   ChironTFT::hotbed_state;
+xy_uint8_t       ChironTFT::selectedmeshpoint;
+char             ChironTFT::selectedfile[MAX_PATH_LEN + 1];
+char             ChironTFT::panel_command[MAX_CMND_LEN + 1];
+uint8_t          ChironTFT::command_len;
+float            ChironTFT::live_Zoffset;
+file_menu_t      ChironTFT::file_menu;
+
+void ChironTFT::Startup() {
+  selectedfile[0]   = '\0';
+  panel_command[0]  = '\0';
+  command_len       = 0;
+  last_error        = AC_error_none;
+  printer_state     = AC_printer_idle;
+  pause_state       = AC_paused_idle;
+  hotend_state      = AC_heater_off;
+  hotbed_state      = AC_heater_off;
+  live_Zoffset      = 0.0;
+  file_menu         = AC_menu_file;
+
+  // Setup pins for powerloss detection
+  // Two IO pins are connected on the Trigorilla Board
+  // On a power interruption the OUTAGECON_PIN goes low.
+
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    OUT_WRITE(OUTAGECON_PIN, HIGH);
+  #endif
+
+  // Filament runout is handled by Marlin settings in Configuration.h
+  // opt_set    FIL_RUNOUT_STATE HIGH  // Pin state indicating that filament is NOT present.
+  // opt_enable FIL_RUNOUT_PULLUP
+  TFTSer.begin(115200);
+
+  // wait for the TFT panel to initialise and finish the animation
+  delay_ms(250);
+
+  // There are different panels for the Chiron with slightly different commands
+  // So we need to know what we are working with.
+
+  // Panel type can be defined otherwise detect it automatically
+  if (panel_type == AC_panel_unknown) DetectPanelType();
+
+  // Signal Board has reset
+  SendtoTFTLN(AC_msg_main_board_has_reset);
+
+  // Enable leveling and Disable end stops during print
+  // as Z home places nozzle above the bed so we need to allow it past the end stops
+  injectCommands_P(AC_cmnd_enable_leveling);
+
+  // Startup tunes are defined in Tunes.h
+  PlayTune(BEEPER_PIN, TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn), 1);
+
+  #if ACDEBUGLEVEL
+    SERIAL_ECHOLNPAIR("AC Debug Level ", ACDEBUGLEVEL);
+  #endif
+  SendtoTFTLN(AC_msg_ready);
+}
+
+void ChironTFT::DetectPanelType() {
+  #if AUTO_DETECT_CHIRON_TFT
+    // Send a query to the TFT
+    SendtoTFTLN(AC_Test_for_OldPanel); // The panel will respond with 'SXY 480 320'
+    SendtoTFTLN(AC_Test_for_NewPanel); // the panel will respond with '[0]=0   ' to '[19]=0   '
+  #endif
+}
+
+void ChironTFT::IdleLoop()  {
+  if (ReadTFTCommand()) {
+    ProcessPanelRequest();
+    command_len = 0;
+  }
+  CheckHeaters();
+}
+
+void ChironTFT::PrinterKilled(PGM_P error,PGM_P component)  {
+  SendtoTFTLN(AC_msg_kill_lcd);
+  #if ACDEBUG(AC_MARLIN)
+    SERIAL_ECHOLNPAIR("PrinterKilled()\nerror: ", error , "\ncomponent: ", component);
+  #endif
+}
+
+void ChironTFT::MediaEvent(media_event_t event)  {
+  #if ACDEBUG(AC_MARLIN)
+    SERIAL_ECHOLNPAIR("ProcessMediaStatus() ", event);
+  #endif
+  switch (event) {
+    case AC_media_inserted:
+      SendtoTFTLN(AC_msg_sd_card_inserted);
+      break;
+
+    case AC_media_removed:
+      SendtoTFTLN(AC_msg_sd_card_removed);
+      break;
+
+    case AC_media_error:
+      last_error = AC_error_noSD;
+      SendtoTFTLN(AC_msg_no_sd_card);
+      break;
+  }
+}
+
+void ChironTFT::TimerEvent(timer_event_t event)  {
+  #if ACDEBUG(AC_MARLIN)
+    SERIAL_ECHOLNPAIR("TimerEvent() ", event);
+    SERIAL_ECHOLNPAIR("Printer State: ", printer_state);
+  #endif
+
+  switch (event) {
+    case AC_timer_started: {
+      live_Zoffset = 0.0; // reset print offset
+      setSoftEndstopState(false);  // disable endstops to print
+      printer_state = AC_printer_printing;
+      SendtoTFTLN(AC_msg_print_from_sd_card);
+    } break;
+
+    case AC_timer_paused: {
+      printer_state = AC_printer_paused;
+      pause_state   = AC_paused_idle;
+      SendtoTFTLN(AC_msg_paused);
+    } break;
+
+    case AC_timer_stopped: {
+      if (printer_state != AC_printer_idle) {
+        printer_state = AC_printer_stopping;
+        SendtoTFTLN(AC_msg_print_complete);
+      }
+      setSoftEndstopState(true); // enable endstops
+    } break;
+  }
+}
+
+void ChironTFT::FilamentRunout()  {
+  #if ACDEBUG(AC_MARLIN)
+    SERIAL_ECHOLNPAIR("FilamentRunout() printer_state ", printer_state);
+  #endif
+  // 1 Signal filament out
+  last_error = AC_error_filament_runout;
+  SendtoTFTLN(isPrintingFromMedia() ? AC_msg_filament_out_alert : AC_msg_filament_out_block);
+  PlayTune(BEEPER_PIN, FilamentOut, 1);
+}
+
+void ChironTFT::ConfirmationRequest(const char * const msg)  {
+  // M108 continue
+  #if ACDEBUG(AC_MARLIN)
+    SERIAL_ECHOLNPAIR("ConfirmationRequest() ", msg, " printer_state:", printer_state);
+  #endif
+  switch (printer_state) {
+    case AC_printer_pausing: {
+      if (strcmp_P(msg, MARLIN_msg_print_paused) == 0 || strcmp_P(msg, MARLIN_msg_nozzle_parked) == 0) {
+        SendtoTFTLN(AC_msg_paused); // enable continue button
+        printer_state = AC_printer_paused;
+      }
+    } break;
+
+    case AC_printer_resuming_from_power_outage:
+    case AC_printer_printing:
+    case AC_printer_paused: {
+      // Heater timout, send acknowledgement
+      if (strcmp_P(msg, MARLIN_msg_heater_timeout) == 0) {
+        pause_state = AC_paused_heater_timed_out;
+        SendtoTFTLN(AC_msg_paused); // enable continue button
+        PlayTune(BEEPER_PIN,Heater_Timedout,1);
+      }
+      // Reheat finished, send acknowledgement
+      else if (strcmp_P(msg, MARLIN_msg_reheat_done) == 0) {
+        pause_state = AC_paused_idle;
+        SendtoTFTLN(AC_msg_paused); // enable continue button
+      }
+      // Filament Purging, send acknowledgement enter run mode
+      else if (strcmp_P(msg, MARLIN_msg_filament_purging) == 0) {
+        pause_state = AC_paused_purging_filament;
+        SendtoTFTLN(AC_msg_paused); // enable continue button
+      }
+    } break;
+    default:
+    break;
+  }
+}
+
+void ChironTFT::StatusChange(const char * const msg)  {
+  #if ACDEBUG(AC_MARLIN)
+    SERIAL_ECHOLNPAIR("StatusChange() ", msg);
+    SERIAL_ECHOLNPAIR("printer_state:", printer_state);
+  #endif
+  bool msg_matched = false;
+  // The only way to get printer status is to parse messages
+  // Use the state to minimise the work we do here.
+  switch (printer_state) {
+    case AC_printer_probing: {
+      // If probing completes ok save the mesh and park
+      // Ignore the custom machine name
+      if (strcmp_P(msg + strlen(CUSTOM_MACHINE_NAME), MARLIN_msg_ready) == 0) {
+        injectCommands_P(PSTR("M500\nG27"));
+        SendtoTFTLN(AC_msg_probing_complete);
+        printer_state = AC_printer_idle;
+        msg_matched = true;
+      }
+      // If probing fails dont save the mesh raise the probe above the bad point
+      if (strcmp_P(msg, MARLIN_msg_probing_failed) == 0) {
+        PlayTune(BEEPER_PIN, BeepBeepBeeep, 1);
+        injectCommands_P(PSTR("G1 Z50 F500"));
+        SendtoTFTLN(AC_msg_probing_complete);
+        printer_state = AC_printer_idle;
+        msg_matched = true;
+      }
+    } break;
+
+    case AC_printer_printing: {
+      if (strcmp_P(msg, MARLIN_msg_reheating) == 0) {
+        SendtoTFTLN(AC_msg_paused); // enable continue button
+        msg_matched = true;
+       }
+    } break;
+
+    case AC_printer_pausing: {
+      if (strcmp_P(msg, MARLIN_msg_print_paused) == 0) {
+        SendtoTFTLN(AC_msg_paused);
+        printer_state = AC_printer_paused;
+        pause_state = AC_paused_idle;
+        msg_matched = true;
+       }
+    } break;
+
+    case AC_printer_stopping: {
+      if (strcmp_P(msg, MARLIN_msg_print_aborted) == 0) {
+        SendtoTFTLN(AC_msg_stop);
+        printer_state = AC_printer_idle;
+        msg_matched = true;
+      }
+    } break;
+    default:
+    break;
+  }
+
+  // If not matched earlier see if this was a heater message
+  if (!msg_matched) {
+    if (strcmp_P(msg, MARLIN_msg_extruder_heating) == 0) {
+      SendtoTFTLN(AC_msg_nozzle_heating);
+      hotend_state = AC_heater_temp_set;
+    }
+    else if (strcmp_P(msg, MARLIN_msg_bed_heating) == 0) {
+      SendtoTFTLN(AC_msg_bed_heating);
+      hotbed_state = AC_heater_temp_set;
+    }
+    else if (strcmp_P(msg, MARLIN_msg_EEPROM_version) == 0) {
+      last_error = AC_error_EEPROM;
+    }
+  }
+}
+
+void ChironTFT::PowerLossRecovery()  {
+  printer_state = AC_printer_resuming_from_power_outage; // Play tune to notify user we can recover.
+  last_error = AC_error_powerloss;
+  PlayTune(BEEPER_PIN, SOS, 1);
+  SERIAL_ECHOLNPGM_P(AC_msg_powerloss_recovery);
+}
+
+void ChironTFT::PrintComplete() {
+  SendtoTFT(AC_msg_print_complete);
+  printer_state = AC_printer_idle;
+  setSoftEndstopState(true); // enable endstops
+}
+
+void ChironTFT::SendtoTFT(PGM_P str) {  // A helper to print PROGMEM string to the panel
+  #if ACDEBUG(AC_SOME)
+    SERIAL_ECHOPGM_P(str);
+  #endif
+  while (const char c = pgm_read_byte(str++)) TFTSer.write(c);
+}
+
+void ChironTFT::SendtoTFTLN(PGM_P str = nullptr) {
+  if (str) {
+    #if ACDEBUG(AC_SOME)
+      SERIAL_ECHOPGM("> ");
+    #endif
+    SendtoTFT(str);
+    #if ACDEBUG(AC_SOME)
+      SERIAL_EOL();
+    #endif
+  }
+  TFTSer.println();
+}
+
+bool ChironTFT::ReadTFTCommand() {
+  bool command_ready = false;
+  while (TFTSer.available() > 0 && command_len < MAX_CMND_LEN) {
+    panel_command[command_len] = TFTSer.read();
+    if (panel_command[command_len] == '\n') {
+      command_ready = true;
+      break;
+    }
+    command_len++;
+  }
+
+  if (command_ready || command_len == MAX_CMND_LEN) {
+    panel_command[command_len] = '\0';
+    #if ACDEBUG(AC_ALL)
+      SERIAL_ECHOLNPAIR("len(",command_len,") < ", panel_command);
+    #endif
+    command_ready = true;
+  }
+  return command_ready;
+}
+
+int8_t ChironTFT::FindToken(char c) {
+  int8_t pos = 0;
+  do {
+    if (panel_command[pos] == c) {
+      #if ACDEBUG(AC_INFO)
+        SERIAL_ECHOLNPAIR("Tpos:", pos, " ", c);
+      #endif
+      return pos;
+    }
+  } while(++pos < command_len);
+  #if ACDEBUG(AC_INFO)
+    SERIAL_ECHOLNPAIR("Not found: ", c);
+  #endif
+  return -1;
+}
+
+void ChironTFT::CheckHeaters() {
+  uint8_t faultDuration = 0;
+
+  // if the hotend temp is abnormal, confirm state before signalling panel
+  celsius_float_t temp = getActualTemp_celsius(E0);
+  while (!WITHIN(temp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP)) {
+    faultDuration++;
+    if (faultDuration >= AC_HEATER_FAULT_VALIDATION_TIME) {
+      SendtoTFTLN(AC_msg_nozzle_temp_abnormal);
+      last_error = AC_error_abnormal_temp_t0;
+      SERIAL_ECHOLNPAIR("Extruder temp abnormal! : ", temp);
+      break;
+    }
+    delay_ms(500);
+    temp = getActualTemp_celsius(E0);
+  }
+
+  // If the hotbed temp is abnormal, confirm state before signaling panel
+  faultDuration = 0;
+  temp = getActualTemp_celsius(BED);
+  while (!WITHIN(temp, BED_MINTEMP, BED_MAXTEMP)) {
+    faultDuration++;
+    if (faultDuration >= AC_HEATER_FAULT_VALIDATION_TIME) {
+      SendtoTFTLN(AC_msg_nozzle_temp_abnormal);
+      last_error = AC_error_abnormal_temp_bed;
+      SERIAL_ECHOLNPAIR("Bed temp abnormal! : ", temp);
+      break;
+    }
+    delay_ms(500);
+    temp = getActualTemp_celsius(E0);
+  }
+
+  // Update panel with hotend heater status
+  if (hotend_state != AC_heater_temp_reached) {
+    if (WITHIN(getActualTemp_celsius(E0) - getTargetTemp_celsius(E0), -(TEMP_WINDOW), TEMP_WINDOW)) {
+      SendtoTFTLN(AC_msg_nozzle_heating_done);
+      hotend_state = AC_heater_temp_reached;
+    }
+  }
+
+  // Update panel with bed heater status
+  if (hotbed_state != AC_heater_temp_reached) {
+    if (WITHIN(getActualTemp_celsius(BED) - getTargetTemp_celsius(BED), -(TEMP_BED_WINDOW), TEMP_BED_WINDOW)) {
+      SendtoTFTLN(AC_msg_bed_heating_done);
+      hotbed_state = AC_heater_temp_reached;
+    }
+  }
+}
+
+void ChironTFT::SendFileList(int8_t startindex) {
+  // Respond to panel request for 4 files starting at index
+  #if ACDEBUG(AC_INFO)
+    SERIAL_ECHOLNPAIR("## SendFileList ## ", startindex);
+  #endif
+  SendtoTFTLN(PSTR("FN "));
+  filenavigator.getFiles(startindex, panel_type, 4);
+  SendtoTFTLN(PSTR("END"));
+}
+
+void ChironTFT::SelectFile() {
+  if (panel_type == AC_panel_new) {
+    strncpy(selectedfile, panel_command + 4, command_len - 3);
+    selectedfile[command_len - 4] = '\0';
+  }
+  else {
+    strncpy(selectedfile, panel_command + 4, command_len - 4);
+    selectedfile[command_len - 5] = '\0';
+  }
+  #if ACDEBUG(AC_FILE)
+    SERIAL_ECHOLNPAIR(" Selected File: ",selectedfile);
+  #endif
+  switch (selectedfile[0]) {
+    case '/':   // Valid file selected
+      SendtoTFTLN(AC_msg_sd_file_open_success);
+      break;
+
+    case '<':   // .. (go up folder level)
+      filenavigator.upDIR();
+      SendtoTFTLN(AC_msg_sd_file_open_failed);
+      SendFileList( 0 );
+      break;
+    default:   // enter sub folder
+      // for new panel remove the '.GCO' tag that was added to the end of the path
+      if (panel_type == AC_panel_new)
+        selectedfile[strlen(selectedfile) - 4] = '\0';
+      filenavigator.changeDIR(selectedfile);
+      SendtoTFTLN(AC_msg_sd_file_open_failed);
+      SendFileList( 0 );
+      break;
+  }
+}
+
+void ChironTFT::ProcessPanelRequest() {
+  // Break these up into logical blocks // as its easier to navigate than one huge switch case!
+  int8_t tpos = FindToken('A');
+  // Panel request are 'A0' - 'A36'
+  if (tpos != -1) {
+    const int8_t req = atoi(&panel_command[tpos+1]);
+
+    // Information requests A0 - A8 and A33
+    if (req <= 8 || req == 33) PanelInfo(req);
+
+    // Simple Actions A9 - A28
+    else if (req <= 28) PanelAction(req);
+
+    // Process Initiation
+    else if (req <= 36) PanelProcess(req);
+  }
+  else {
+    #if AUTO_DETECT_CHIRON_TFT
+      // This may be a response to a panel type detection query
+      if (panel_type == AC_panel_unknown) {
+        tpos = FindToken('S'); // old panel will respond to 'SIZE' with 'SXY 480 320'
+        if (tpos != -1) {
+          if (panel_command[tpos+1]== 'X' && panel_command[tpos+2]=='Y') {
+            panel_type = AC_panel_standard;
+            SERIAL_ECHOLNPGM_P(AC_msg_old_panel_detected);
+          }
+        }
+        else {
+          tpos = FindToken('['); // new panel will respond to 'J200' with '[0]=0'
+          if (tpos != -1) {
+            if (panel_command[tpos+1]== '0' && panel_command[tpos+2]==']') {
+              panel_type = AC_panel_new;
+              SERIAL_ECHOLNPGM_P(AC_msg_new_panel_detected);
+            }
+          }
+        }
+        return;
+      }
+    #endif
+
+    SendtoTFTLN(); // Ignore unknown requests
+  }
+}
+
+void ChironTFT::PanelInfo(uint8_t req) {
+  // information requests A0-A8 and A33
+  switch (req) {
+    case 0:   // A0 Get HOTEND Temp
+      SendtoTFT(PSTR("A0V "));
+      TFTSer.println(getActualTemp_celsius(E0));
+      break;
+
+    case 1:   // A1 Get HOTEND Target Temp
+      SendtoTFT(PSTR("A1V "));
+      TFTSer.println(getTargetTemp_celsius(E0));
+      break;
+
+    case 2:   // A2 Get BED Temp
+      SendtoTFT(PSTR("A2V "));
+      TFTSer.println(getActualTemp_celsius(BED));
+      break;
+
+    case 3:   // A3 Get BED Target Temp
+      SendtoTFT(PSTR("A3V "));
+      TFTSer.println(getTargetTemp_celsius(BED));
+      break;
+
+    case 4:   // A4 Get FAN Speed
+      SendtoTFT(PSTR("A4V "));
+      TFTSer.println(getActualFan_percent(FAN0));
+      break;
+
+    case 5:   // A5 Get Current Coordinates
+      SendtoTFT(PSTR("A5V X: "));
+      TFTSer.print(getAxisPosition_mm(X));
+      SendtoTFT(PSTR(" Y: "));
+      TFTSer.print(getAxisPosition_mm(Y));
+      SendtoTFT(PSTR(" Z: "));
+      TFTSer.println(getAxisPosition_mm(Z));
+      break;
+
+    case 6:   // A6 Get printing progress
+      if (isPrintingFromMedia()) {
+        SendtoTFT(PSTR("A6V "));
+        TFTSer.println(ui8tostr2(getProgress_percent()));
+      }
+      else
+        SendtoTFTLN(PSTR("A6V ---"));
+      break;
+
+    case 7: { // A7 Get Printing Time
+      uint32_t time = getProgress_seconds_elapsed() / 60;
+      SendtoTFT(PSTR("A7V "));
+      TFTSer.print(ui8tostr2(time / 60));
+      SendtoTFT(PSTR(" H "));
+      TFTSer.print(ui8tostr2(time % 60));
+      SendtoTFT(PSTR(" M"));
+      #if ACDEBUG(AC_ALL)
+        SERIAL_ECHOLNPAIR("Print time ", ui8tostr2(time / 60), ":", ui8tostr2(time % 60));
+      #endif
+    } break;
+
+    case 8:   // A8 Get SD Card list A8 S0
+      if (!isMediaInserted()) safe_delay(500);
+      if (!isMediaInserted())   // Make sure the card is removed
+        SendtoTFTLN(AC_msg_no_sd_card);
+      else if (panel_command[3] == 'S')
+        SendFileList( atoi( &panel_command[4] ) );
+      break;
+
+    case 33:   // A33 Get firmware info
+      SendtoTFT(PSTR("J33 "));
+      // If there is an error recorded, show that instead of the FW version
+      if (!GetLastError()) SendtoTFTLN(PSTR(SHORT_BUILD_VERSION));
+      break;
+  }
+}
+
+void ChironTFT::PanelAction(uint8_t req) {
+  switch (req) {
+    case  9:   // A9 Pause SD print
+      if (isPrintingFromMedia()) {
+        SendtoTFTLN(AC_msg_pause);
+        pausePrint();
+        printer_state = AC_printer_pausing;
+      }
+      else
+        SendtoTFTLN(AC_msg_stop);
+      break;
+
+    case 10: // A10 Resume SD Print
+      if (pause_state == AC_paused_idle || printer_state == AC_printer_resuming_from_power_outage)
+        resumePrint();
+      else
+        setUserConfirmed();
+      break;
+
+    case 11:   // A11 Stop SD print
+      if (isPrintingFromMedia()) {
+        printer_state = AC_printer_stopping;
+        stopPrint();
+      }
+      else {
+        if (printer_state == AC_printer_resuming_from_power_outage)
+          injectCommands_P(PSTR("M1000 C")); // Cancel recovery
+        SendtoTFTLN(AC_msg_stop);
+        printer_state = AC_printer_idle;
+      }
+      break;
+
+    case 12:   // A12 Kill printer
+      kill();  // from marlincore.h
+      break;
+
+    case 13:   // A13 Select file
+      SelectFile();
+      break;
+
+    case 14: { // A14 Start Printing
+      // Allows printer to restart the job if we dont want to recover
+      if (printer_state == AC_printer_resuming_from_power_outage) {
+        injectCommands_P(PSTR("M1000 C")); // Cancel recovery
+        printer_state = AC_printer_idle;
+      }
+      #if ACDebugLevel >= 1
+        SERIAL_ECHOLNPAIR_F("Print: ", selectedfile);
+      #endif
+      printFile(selectedfile);
+      SendtoTFTLN(AC_msg_print_from_sd_card);
+    } break;
+
+    case 15:   // A15 Resuming from outage
+      if (printer_state == AC_printer_resuming_from_power_outage) {
+        // Need to home here to restore the Z position
+        injectCommands_P(AC_cmnd_power_loss_recovery);
+        injectCommands_P(PSTR("M1000"));  // home and start recovery
+      }
+      break;
+
+    case 16: { // A16 Set HotEnd temp  A17 S170
+      const float set_Htemp = atof(&panel_command[5]);
+      hotend_state = set_Htemp ? AC_heater_temp_set : AC_heater_off;
+      switch ((char)panel_command[4]) {
+        // Set Temp
+        case 'S': case 'C': setTargetTemp_celsius(set_Htemp, E0);
+      }
+    } break;
+
+    case 17: { // A17 Set bed temp
+      const float set_Btemp = atof(&panel_command[5]);
+      hotbed_state = set_Btemp ? AC_heater_temp_set : AC_heater_off;
+      if (panel_command[4] == 'S')
+        setTargetTemp_celsius(set_Btemp, BED);
+    } break;
+
+    case 18:   // A18 Set Fan Speed
+      if (panel_command[4] == 'S')
+        setTargetFan_percent(atof(&panel_command[5]), FAN0);
+      break;
+
+    case 19:   // A19 Motors off
+      if (!isPrinting()) {
+        disable_all_steppers(); // from marlincore.h
+        SendtoTFTLN(AC_msg_ready);
+      }
+      break;
+
+    case 20:   // A20 Read/write print speed
+      if (panel_command[4] == 'S')
+        setFeedrate_percent(atoi(&panel_command[5]));
+      else {
+        SendtoTFT(PSTR("A20V "));
+        TFTSer.println(getFeedrate_percent());
+      }
+      break;
+
+    case 21:   // A21 Home Axis  A21 X
+      if (!isPrinting()) {
+        switch ((char)panel_command[4]) {
+          case 'X': injectCommands_P(PSTR("G28X")); break;
+          case 'Y': injectCommands_P(PSTR("G28Y")); break;
+          case 'Z': injectCommands_P(PSTR("G28Z")); break;
+          case 'C': injectCommands_P(G28_STR); break;
+        }
+      }
+      break;
+
+    case 22: {   // A22 Move Axis
+      // The commands have changed on the new panel
+      // Old TFT A22 X -1F1500      A22 X +1F1500
+      // New TFT A22 X-1.0 F1500    A22 X1.0 F1500
+
+      // lets just wrap this in a gcode relative nonprint move and let the controller deal with it
+      // G91 G0 <panel command> G90
+
+      if (!isPrinting()) { // Ignore request if printing
+        char MoveCmnd[30];
+        sprintf_P(MoveCmnd, PSTR("G91\nG0%s\nG90"), panel_command + 3);
+        #if ACDEBUG(AC_ACTION)
+          SERIAL_ECHOLNPAIR("Move: ", MoveCmnd);
+        #endif
+        setSoftEndstopState(true);  // enable endstops
+        injectCommands(MoveCmnd);
+      }
+    } break;
+
+    case 23:   // A23 Preheat PLA
+      // Ignore request if printing
+      if (!isPrinting()) {
+        // Temps defined in configuration.h
+        setTargetTemp_celsius(PREHEAT_1_TEMP_BED, BED);
+        setTargetTemp_celsius(PREHEAT_1_TEMP_HOTEND, E0);
+        SendtoTFTLN();
+        hotbed_state = AC_heater_temp_set;
+        hotend_state = AC_heater_temp_set;
+      }
+      break;
+
+    case 24:   // A24 Preheat ABS
+      // Ignore request if printing
+      if (!isPrinting()) {
+        setTargetTemp_celsius(PREHEAT_2_TEMP_BED, BED);
+        setTargetTemp_celsius(PREHEAT_2_TEMP_HOTEND, E0);
+        SendtoTFTLN();
+        hotbed_state = AC_heater_temp_set;
+        hotend_state = AC_heater_temp_set;
+      }
+      break;
+
+    case 25:   // A25 Cool Down
+      // Ignore request if printing
+      if (!isPrinting()) {
+        setTargetTemp_celsius(0, E0);
+        setTargetTemp_celsius(0, BED);
+        SendtoTFTLN(AC_msg_ready);
+        hotbed_state = AC_heater_off;
+        hotend_state = AC_heater_off;
+      }
+      break;
+
+    case 26:   // A26 Refresh SD
+      if (card.isMounted())card.release();
+      card.mount();
+      safe_delay(500);
+      filenavigator.reset();
+      break;
+
+    case 27:   // A27 Servo Angles adjust
+      break;
+
+    case 28:   // A28 Filament set A28 O/C
+      // Ignore request if printing
+      if (isPrinting()) break;
+      SendtoTFTLN();
+      break;
+  }
+}
+
+void ChironTFT::PanelProcess(uint8_t req) {
+  switch (req) {
+    case 29: { // A29 Read Mesh Point A29 X1 Y1
+      xy_uint8_t pos;
+      float pos_z;
+      pos.x = atoi(&panel_command[FindToken('X')+1]);
+      pos.y = atoi(&panel_command[FindToken('Y')+1]);
+      pos_z = getMeshPoint(pos);
+
+      SendtoTFT(PSTR("A29V "));
+      TFTSer.println(pos_z * 100);
+      if (!isPrinting()) {
+        setSoftEndstopState(true);  // disable endstops
+        // If the same meshpoint is selected twice in a row, move the head to that ready for adjustment
+        if ((selectedmeshpoint.x == pos.x) && (selectedmeshpoint.y == pos.y)) {
+          if (!isPositionKnown())
+            injectCommands_P(G28_STR); // home
+
+          if (isPositionKnown()) {
+            #if ACDEBUG(AC_INFO)
+              SERIAL_ECHOLNPAIR("Moving to mesh point at x: ", pos.x, " y: ", pos.y, " z: ", pos_z);
+            #endif
+            // Go up before moving
+            setAxisPosition_mm(3.0,Z);
+
+            setAxisPosition_mm(17 + (93 * pos.x), X);
+            setAxisPosition_mm(20 + (93 * pos.y), Y);
+            setAxisPosition_mm(0.0, Z);
+            #if ACDEBUG(AC_INFO)
+              SERIAL_ECHOLNPAIR("Current Z: ", getAxisPosition_mm(Z));
+            #endif
+          }
+        }
+        selectedmeshpoint.x = pos.x;
+        selectedmeshpoint.y = pos.y;
+      }
+    } break;
+
+    case 30: {   // A30 Auto leveling
+      if (FindToken('S') != -1) { // Start probing New panel adds spaces..
+        // Ignore request if printing
+        if (isPrinting())
+          SendtoTFTLN(AC_msg_probing_not_allowed); // forbid auto leveling
+        else {
+
+
+          SendtoTFTLN(AC_msg_start_probing);
+          injectCommands_P(PSTR("G28\nG29"));
+          printer_state = AC_printer_probing;
+        }
+      }
+      else {
+        SendtoTFTLN(AC_msg_start_probing); // Just enter levelling menu
+      }
+    } break;
+
+    case 31: { // A31 Adjust all Probe Points
+      // The tokens can occur in different places on the new panel so we need to find it.
+
+      if (FindToken('C') != -1) { // Restore and apply original offsets
+        if (!isPrinting()) {
+          injectCommands_P(PSTR("M501\nM420 S1"));
+          selectedmeshpoint.x = selectedmeshpoint.y = 99;
+          SERIAL_ECHOLNPGM_P(AC_msg_mesh_changes_abandoned);
+        }
+      }
+
+      else if (FindToken('D') != -1) { // Save Z Offset tables and restore leveling state
+        if (!isPrinting()) {
+          setAxisPosition_mm(1.0,Z); // Lift nozzle before any further movements are made
+          injectCommands_P(PSTR("M500"));
+          SERIAL_ECHOLNPGM_P(AC_msg_mesh_changes_saved);
+          selectedmeshpoint.x = selectedmeshpoint.y = 99;
+        }
+      }
+
+      else if (FindToken('G') != -1) { // Get current offset
+        SendtoTFT(PSTR("A31V "));
+        // When printing use the live z Offset position
+        // we will use babystepping to move the print head
+        if (isPrinting())
+          TFTSer.println(live_Zoffset);
+        else {
+          TFTSer.println(getZOffset_mm());
+          selectedmeshpoint.x = selectedmeshpoint.y = 99;
+        }
+      }
+
+      else {
+        int8_t tokenpos = FindToken('S');
+        if (tokenpos != -1) { // Set offset (adjusts all points by value)
+          float Zshift = atof(&panel_command[tokenpos+1]);
+          setSoftEndstopState(false);  // disable endstops
+          // Allow temporary Z position nudging during print
+          // From the leveling panel use the all points UI to adjust the print pos.
+          if (isPrinting()) {
+            #if ACDEBUG(AC_INFO)
+              SERIAL_ECHOLNPAIR("Change Zoffset from:", live_Zoffset, " to ", live_Zoffset + Zshift);
+            #endif
+            if (isAxisPositionKnown(Z)) {
+              #if ACDEBUG(AC_INFO)
+                const float currZpos = getAxisPosition_mm(Z);
+                SERIAL_ECHOLNPAIR("Nudge Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
+              #endif
+              // Use babystepping to adjust the head position
+              int16_t steps = mmToWholeSteps(constrain(Zshift,-0.05,0.05), Z);
+              #if ACDEBUG(AC_INFO)
+                SERIAL_ECHOLNPAIR("Steps to move Z: ", steps);
+              #endif
+              babystepAxis_steps(steps, Z);
+              live_Zoffset += Zshift;
+            }
+            SendtoTFT(PSTR("A31V "));
+            TFTSer.println(live_Zoffset);
+          }
+          else {
+            GRID_LOOP(x, y) {
+              const xy_uint8_t pos { x, y };
+              const float currval = getMeshPoint(pos);
+              setMeshPoint(pos, constrain(currval + Zshift, AC_LOWEST_MESHPOINT_VAL, 2));
+              #if ACDEBUG(AC_INFO)
+                SERIAL_ECHOLNPAIR("Change mesh point X", x," Y",y ," from ", currval, " to ", getMeshPoint(pos) );
+              #endif
+            }
+            const float currZOffset = getZOffset_mm();
+            #if ACDEBUG(AC_INFO)
+              SERIAL_ECHOLNPAIR("Change probe offset from ", currZOffset, " to  ", currZOffset + Zshift);
+            #endif
+
+            setZOffset_mm(currZOffset + Zshift);
+            SendtoTFT(PSTR("A31V "));
+            TFTSer.println(getZOffset_mm());
+
+            if (isAxisPositionKnown(Z)) {
+              // Move Z axis
+              const float currZpos = getAxisPosition_mm(Z);
+              #if ACDEBUG(AC_INFO)
+                SERIAL_ECHOLNPAIR("Move Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
+              #endif
+              setAxisPosition_mm(currZpos+constrain(Zshift,-0.05,0.05),Z);
+            }
+          }
+        }
+      }
+    } break;
+
+    case 32: { // A32 clean leveling beep flag
+      // Ignore request if printing
+      //if (isPrinting()) break;
+      //injectCommands_P(PSTR("M500\nM420 S1\nG1 Z10 F240\nG1 X0 Y0 F6000"));
+      //TFTSer.println();
+    } break;
+
+    // A33 firmware info request see PanelInfo()
+
+    case 34: {  // A34 Adjust single mesh point A34 C/S X1 Y1 V123
+      if (panel_command[3] == 'C') { // Restore original offsets
+        injectCommands_P(PSTR("M501\nM420 S1"));
+        selectedmeshpoint.x = selectedmeshpoint.y = 99;
+        //printer_state = AC_printer_idle;
+      }
+      else {
+        xy_uint8_t pos;
+        pos.x = atoi(&panel_command[5]);
+        pos.y = atoi(&panel_command[8]);
+
+        float currmesh = getMeshPoint(pos);
+        float newval   = atof(&panel_command[11])/100;
+        #if ACDEBUG(AC_INFO)
+          SERIAL_ECHOLNPAIR("Change mesh point x:", pos.x, " y:", pos.y);
+          SERIAL_ECHOLNPAIR("from ", currmesh, " to ", newval);
+        #endif
+        // Update Meshpoint
+        setMeshPoint(pos,newval);
+        if (printer_state == AC_printer_idle || printer_state == AC_printer_probing /*!isPrinting()*/) {
+          // if we are at the current mesh point indicated on the panel Move Z pos +/- 0.05mm
+          // (The panel changes the mesh value by +/- 0.05mm on each button press)
+          if (selectedmeshpoint.x == pos.x && selectedmeshpoint.y == pos.y) {
+            setSoftEndstopState(false);
+            float currZpos = getAxisPosition_mm(Z);
+            #if ACDEBUG(AC_INFO)
+              SERIAL_ECHOLNPAIR("Move Z pos from ", currZpos, " to ", currZpos + constrain(newval - currmesh, -0.05, 0.05));
+            #endif
+            setAxisPosition_mm(currZpos + constrain(newval - currmesh, -0.05, 0.05), Z);
+          }
+        }
+      }
+    }  break;
+
+    case 36:    // A36 Auto leveling for new TFT bet that was a typo in the panel code!
+      SendtoTFTLN(AC_msg_start_probing);
+      break;
+  }
+}
+
+bool ChironTFT::GetLastError() {
+  switch (last_error) {
+    case AC_error_abnormal_temp_bed: SendtoTFTLN(AC_msg_error_bed_temp);    break;
+    case AC_error_abnormal_temp_t0:  SendtoTFTLN(AC_msg_error_hotend_temp); break;
+    case AC_error_noSD:              SendtoTFTLN(AC_msg_error_sd_card);     break;
+    case AC_error_powerloss:         SendtoTFTLN(AC_msg_power_loss);        break;
+    case AC_error_EEPROM:            SendtoTFTLN(AC_msg_eeprom_version);    break;
+    case AC_error_filament_runout:   SendtoTFTLN(AC_msg_filament_out);      break;
+    default: return false;
+  }
+  last_error = AC_error_none;
+  return true;
+}
+
+} // Anycubic namespace
+
+#endif // ANYCUBIC_LCD_CHIRON
