commit dd3b5a10a09e2a83918af1cf6f8782fd0c473f98
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 21 22:00:37 2024 -0600

    Misc. aesthetic adjustments
    
    Co-Authored-By: Andrew <18502096+classicrocker883@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/menus.cpp b/Marlin/src/lcd/e3v2/proui/menus.cpp
index 9f48ff03b7..88fbf60001 100644
--- a/Marlin/src/lcd/e3v2/proui/menus.cpp
+++ b/Marlin/src/lcd/e3v2/proui/menus.cpp
@@ -263,7 +263,7 @@ void setPFloatOnClick(const float lo, const float hi, uint8_t dp, void (*apply)(
 
 // Generic menu control using the encoder
 void hmiMenu() {
-  EncoderState encoder_diffState = get_encoder_state();
+  const EncoderState encoder_diffState = get_encoder_state();
   if (currentMenu) {
     if (encoder_diffState == ENCODER_DIFF_NO) return;
     if (encoder_diffState == ENCODER_DIFF_ENTER)
@@ -280,10 +280,8 @@ void hmiMenu() {
 //  1 : live change
 //  2 : apply change
 int8_t hmiGet(bool draw) {
-  const int32_t lo = menuData.minValue;
-  const int32_t hi = menuData.maxValue;
-  const int32_t cval = menuData.value;
-  EncoderState encoder_diffState = TERN(SMOOTH_ENCODER_MENUITEMS, get_encoder_state(), encoderReceiveAnalyze());
+  const int32_t lo = menuData.minValue, hi = menuData.maxValue, cval = menuData.value;
+  const EncoderState encoder_diffState = TERN(SMOOTH_ENCODER_MENUITEMS, get_encoder_state(), encoderReceiveAnalyze());
   if (encoder_diffState != ENCODER_DIFF_NO) {
     if (applyEncoder(encoder_diffState, menuData.value)) {
       encoderRate.enabled = false;
@@ -300,7 +298,7 @@ int8_t hmiGet(bool draw) {
 
 // Set and draw a value using the encoder
 void hmiSetDraw() {
-  int8_t val = hmiGet(true);
+  const int8_t val = hmiGet(true);
   switch (val) {
     case 0: return;
     case 1: if (menuData.liveUpdate) menuData.liveUpdate(); break;
@@ -310,7 +308,7 @@ void hmiSetDraw() {
 
 // Set an value without drawing
 void hmiSetNoDraw() {
-  int8_t val = hmiGet(false);
+  const int8_t val = hmiGet(false);
   switch (val) {
     case 0: return;
     case 1: if (menuData.liveUpdate) menuData.liveUpdate(); break;
@@ -320,7 +318,7 @@ void hmiSetNoDraw() {
 
 // Set an integer pointer variable using the encoder
 void hmiSetPInt() {
-  int8_t val = hmiGet(true);
+  const int8_t val = hmiGet(true);
   switch (val) {
     case 0: return;
     case 1: if (menuData.liveUpdate) menuData.liveUpdate(); break;

commit a41e16ffee0ae828ecb73eeea3caab2f4aed82a8
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Wed Dec 6 00:11:41 2023 -0500

    ‚ú® Voxelab Aquila N32 (via Maple) (#26470)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/menus.cpp b/Marlin/src/lcd/e3v2/proui/menus.cpp
index d537bc5ae6..9f48ff03b7 100644
--- a/Marlin/src/lcd/e3v2/proui/menus.cpp
+++ b/Marlin/src/lcd/e3v2/proui/menus.cpp
@@ -107,7 +107,7 @@ void onDrawMenuItem(MenuItem* menuitem, int8_t line) {
   if (menuitem->icon) DWINUI::drawIcon(menuitem->icon, ICOX, MBASE(line) - 3);
   if (menuitem->frameid)
     dwinFrameAreaCopy(menuitem->frameid, menuitem->frame.left, menuitem->frame.top, menuitem->frame.right, menuitem->frame.bottom, LBLX, MBASE(line));
-  else if (menuitem->caption)
+  else
     DWINUI::drawString(LBLX, MBASE(line) - 1, menuitem->caption);
   dwinDrawHLine(hmiData.colorSplitLine, 16, MYPOS(line + 1), 240);
 }

commit f7d5188b2f0a59b752fbabf6b96ff1ed4aed8112
Author: GHGiampy <83699429+GHGiampy@users.noreply.github.com>
Date:   Sat Aug 19 22:53:45 2023 +0200

    üêõ Fixes for ProUI, build rename (#26177)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/menus.cpp b/Marlin/src/lcd/e3v2/proui/menus.cpp
index 347130743c..d537bc5ae6 100644
--- a/Marlin/src/lcd/e3v2/proui/menus.cpp
+++ b/Marlin/src/lcd/e3v2/proui/menus.cpp
@@ -507,25 +507,25 @@ void initMenu() {
 
 bool setMenu(Menu* &menu, FSTR_P fTitle, int8_t totalitems) {
   if (!menu) menu = new Menu();
-  const bool NotCurrent = (currentMenu != menu);
-  if (NotCurrent) {
+  const bool notCurrent = (currentMenu != menu);
+  if (notCurrent) {
     menu->menuTitle.setCaption(fTitle);
     menuItemsPrepare(totalitems);
   }
-  return NotCurrent;
+  return notCurrent;
 }
 
 bool setMenu(Menu* &menu, frame_rect_t cn, FSTR_P fTitle, int8_t totalitems) {
   if (!menu) menu = new Menu();
-  const bool NotCurrent = (currentMenu != menu);
-  if (NotCurrent) {
+  const bool notCurrent = (currentMenu != menu);
+  if (notCurrent) {
     if (cn.w != 0)
       menu->menuTitle.setFrame(cn.x, cn.y, cn.w, cn.h);
     else
       menu->menuTitle.setCaption(fTitle);
     menuItemsPrepare(totalitems);
   }
-  return NotCurrent;
+  return notCurrent;
 }
 
 void resetMenu(Menu* &menu) {

commit f14f1be168ebf252dd458c935271aed1a57cfa0b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 30 19:16:00 2023 -0500

    üé® Standardize naming (ProUI) (#25982)

diff --git a/Marlin/src/lcd/e3v2/proui/menus.cpp b/Marlin/src/lcd/e3v2/proui/menus.cpp
index 54892b6acb..347130743c 100644
--- a/Marlin/src/lcd/e3v2/proui/menus.cpp
+++ b/Marlin/src/lcd/e3v2/proui/menus.cpp
@@ -37,135 +37,135 @@
 
 int8_t MenuItemTotal = 0;
 int8_t MenuItemCount = 0;
-CustomMenuItemClass** MenuItems = nullptr;
-MenuClass *CurrentMenu = nullptr;
-MenuClass *PreviousMenu = nullptr;
-MenuData_t MenuData;
+CustomMenuItem** menuItems = nullptr;
+Menu *currentMenu = nullptr;
+Menu *previousMenu = nullptr;
+MenuData_t menuData;
 
 // Menuitem Drawing functions =================================================
 
-void Draw_Title(TitleClass* title) {
-  dwinDrawRectangle(1, HMI_data.TitleBg_Color, 0, 0, DWIN_WIDTH - 1, TITLE_HEIGHT - 1);
-  if (title->frameid)
-    DWIN_Frame_AreaCopy(title->frameid, title->frame.left, title->frame.top, title->frame.right, title->frame.bottom, 14, (TITLE_HEIGHT - (title->frame.bottom - title->frame.top)) / 2 - 1);
+void drawTitle(Title* aTitle) {
+  dwinDrawRectangle(1, hmiData.colorTitleBg, 0, 0, DWIN_WIDTH - 1, TITLE_HEIGHT - 1);
+  if (aTitle->frameid)
+    dwinFrameAreaCopy(aTitle->frameid, aTitle->frame.left, aTitle->frame.top, aTitle->frame.right, aTitle->frame.bottom, 14, (TITLE_HEIGHT - (aTitle->frame.bottom - aTitle->frame.top)) / 2 - 1);
   else
     #if ENABLED(TITLE_CENTERED)
-      DWINUI::Draw_CenteredString(false, DWIN_FONT_HEAD, HMI_data.TitleTxt_Color, HMI_data.TitleBg_Color, (TITLE_HEIGHT - DWINUI::fontHeight(DWIN_FONT_HEAD)) / 2 - 1, title->caption);
+      DWINUI::drawCenteredString(false, DWIN_FONT_HEAD, hmiData.colorTitleTxt, hmiData.colorTitleBg, (TITLE_HEIGHT - DWINUI::fontHeight(DWIN_FONT_HEAD)) / 2 - 1, aTitle->caption);
     #else
-      dwinDrawString(false, DWIN_FONT_HEAD, HMI_data.TitleTxt_Color, HMI_data.TitleBg_Color, 14, (TITLE_HEIGHT - DWINUI::fontHeight(DWIN_FONT_HEAD)) / 2 - 1, title->caption);
+      dwinDrawString(false, DWIN_FONT_HEAD, hmiData.colorTitleTxt, hmiData.colorTitleBg, 14, (TITLE_HEIGHT - DWINUI::fontHeight(DWIN_FONT_HEAD)) / 2 - 1, aTitle->caption);
     #endif
 }
 
-void Draw_Menu_Cursor(const int8_t line) {
+void drawMenuCursor(const int8_t line) {
   const uint16_t ypos = MYPOS(line);
-  DWINUI::Draw_Box(1, HMI_data.Cursor_Color, {0, ypos, 15, MLINE - 1});
+  DWINUI::drawBox(1, hmiData.colorCursor, {0, ypos, 15, MLINE - 1});
 }
 
-void Erase_Menu_Cursor(const int8_t line) {
+void eraseMenuCursor(const int8_t line) {
   const uint16_t ypos = MYPOS(line);
-  DWINUI::Draw_Box(1, HMI_data.Background_Color, {0, ypos, 15, MLINE - 1});
+  DWINUI::drawBox(1, hmiData.colorBackground, {0, ypos, 15, MLINE - 1});
 }
 
-void Erase_Menu_Text(const int8_t line) {
+void eraseMenuText(const int8_t line) {
   if (line < 0 || line >= TROWS) return;
   const uint16_t ypos = MYPOS(line) + 1;
-  DWINUI::Draw_Box(1, HMI_data.Background_Color, {LBLX, ypos, DWIN_WIDTH - LBLX, MLINE - 2});
+  DWINUI::drawBox(1, hmiData.colorBackground, {LBLX, ypos, DWIN_WIDTH - LBLX, MLINE - 2});
 }
 
-void Draw_Menu_Line(const uint8_t line, const uint8_t icon/*=0*/, const char * const label/*=nullptr*/, bool more/*=false*/, bool selected/*=false*/) {
-  if (icon)  DWINUI::Draw_Icon(icon, ICOX, MBASE(line) - 3);
-  if (label) DWINUI::Draw_String(LBLX, MBASE(line) - 1, (char*)label);
-  if (more)  DWINUI::Draw_Icon(ICON_More, VALX + 16, MBASE(line) - 3);
-  if (selected) Draw_Menu_Cursor(line);
-  dwinDrawHLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
+void drawMenuLine(const uint8_t line, const uint8_t icon/*=0*/, const char * const label/*=nullptr*/, bool more/*=false*/, bool selected/*=false*/) {
+  if (icon)  DWINUI::drawIcon(icon, ICOX, MBASE(line) - 3);
+  if (label) DWINUI::drawString(LBLX, MBASE(line) - 1, (char*)label);
+  if (more)  DWINUI::drawIcon(ICON_More, VALX + 16, MBASE(line) - 3);
+  if (selected) drawMenuCursor(line);
+  dwinDrawHLine(hmiData.colorSplitLine, 16, MYPOS(line + 1), 240);
 }
 
-void Draw_Menu_Line(const uint8_t line, const uint8_t icon/*=0*/, FSTR_P label/*=nullptr*/, bool more/*=false*/, bool selected/*=false*/) {
-  Draw_Menu_Line(line, icon, FTOP(label), more, selected);
+void drawMenuLine(const uint8_t line, const uint8_t icon/*=0*/, FSTR_P label/*=nullptr*/, bool more/*=false*/, bool selected/*=false*/) {
+  drawMenuLine(line, icon, FTOP(label), more, selected);
 }
 
-void Draw_Chkb_Line(const uint8_t line, const bool checked) {
-  DWINUI::Draw_Checkbox(HMI_data.Text_Color, HMI_data.Background_Color, VALX + 3 * DWINUI::fontWidth(), MBASE(line) - 1, checked);
+void drawCheckboxLine(const uint8_t line, const bool checked) {
+  DWINUI::drawCheckbox(hmiData.colorText, hmiData.colorBackground, VALX + 3 * DWINUI::fontWidth(), MBASE(line) - 1, checked);
 }
 
-void Show_Chkb_Line(const bool checked) {
-  const uint8_t line = CurrentMenu->line();
-  DWINUI::Draw_Checkbox(HMI_data.Text_Color, HMI_data.Background_Color, VALX + 3 * DWINUI::fontWidth(), MBASE(line) - 1, checked);
+void showCheckboxLine(const bool checked) {
+  const uint8_t line = currentMenu->line();
+  DWINUI::drawCheckbox(hmiData.colorText, hmiData.colorBackground, VALX + 3 * DWINUI::fontWidth(), MBASE(line) - 1, checked);
   dwinUpdateLCD();
 }
 
-void Toggle_Chkb_Line(bool &checked) {
+void toggleCheckboxLine(bool &checked) {
   checked = !checked;
-  Show_Chkb_Line(checked);
+  showCheckboxLine(checked);
 }
 
-void Draw_Menu_IntValue(uint16_t bcolor, const uint8_t line, uint8_t iNum, const int32_t value/*=0*/) {
-  DWINUI::Draw_Signed_Int(HMI_data.Text_Color, bcolor, iNum , VALX, MBASE(line) - 1, value);
+void drawMenuIntValue(uint16_t bcolor, const uint8_t line, uint8_t iNum, const int32_t value/*=0*/) {
+  DWINUI::drawSignedInt(hmiData.colorText, bcolor, iNum , VALX, MBASE(line) - 1, value);
 }
 
-void onDrawMenuItem(MenuItemClass* menuitem, int8_t line) {
-  if (menuitem->icon) DWINUI::Draw_Icon(menuitem->icon, ICOX, MBASE(line) - 3);
+void onDrawMenuItem(MenuItem* menuitem, int8_t line) {
+  if (menuitem->icon) DWINUI::drawIcon(menuitem->icon, ICOX, MBASE(line) - 3);
   if (menuitem->frameid)
-    DWIN_Frame_AreaCopy(menuitem->frameid, menuitem->frame.left, menuitem->frame.top, menuitem->frame.right, menuitem->frame.bottom, LBLX, MBASE(line));
+    dwinFrameAreaCopy(menuitem->frameid, menuitem->frame.left, menuitem->frame.top, menuitem->frame.right, menuitem->frame.bottom, LBLX, MBASE(line));
   else if (menuitem->caption)
-    DWINUI::Draw_String(LBLX, MBASE(line) - 1, menuitem->caption);
-  dwinDrawHLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
+    DWINUI::drawString(LBLX, MBASE(line) - 1, menuitem->caption);
+  dwinDrawHLine(hmiData.colorSplitLine, 16, MYPOS(line + 1), 240);
 }
 
-void onDrawSubMenu(MenuItemClass* menuitem, int8_t line) {
+void onDrawSubMenu(MenuItem* menuitem, int8_t line) {
   onDrawMenuItem(menuitem, line);
-  DWINUI::Draw_Icon(ICON_More, VALX + 16, MBASE(line) - 3);
+  DWINUI::drawIcon(ICON_More, VALX + 16, MBASE(line) - 3);
 }
 
-void onDrawIntMenu(MenuItemClass* menuitem, int8_t line, int32_t value) {
+void onDrawIntMenu(MenuItem* menuitem, int8_t line, int32_t value) {
   onDrawMenuItem(menuitem, line);
-  Draw_Menu_IntValue(HMI_data.Background_Color, line, 4, value);
+  drawMenuIntValue(hmiData.colorBackground, line, 4, value);
 }
 
-void onDrawPIntMenu(MenuItemClass* menuitem, int8_t line) {
-  const int16_t value = *(int16_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+void onDrawPIntMenu(MenuItem* menuitem, int8_t line) {
+  const int16_t value = *(int16_t*)static_cast<MenuItemPtr*>(menuitem)->value;
   onDrawIntMenu(menuitem, line, value);
 }
 
-void onDrawPInt8Menu(MenuItemClass* menuitem, int8_t line) {
-  const uint8_t value = *(uint8_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+void onDrawPInt8Menu(MenuItem* menuitem, int8_t line) {
+  const uint8_t value = *(uint8_t*)static_cast<MenuItemPtr*>(menuitem)->value;
   onDrawIntMenu(menuitem, line, value);
 }
 
-void onDrawPInt32Menu(MenuItemClass* menuitem, int8_t line) {
-  const uint32_t value = *(uint32_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+void onDrawPInt32Menu(MenuItem* menuitem, int8_t line) {
+  const uint32_t value = *(uint32_t*)static_cast<MenuItemPtr*>(menuitem)->value;
   onDrawIntMenu(menuitem, line, value);
 }
 
-void onDrawFloatMenu(MenuItemClass* menuitem, int8_t line, uint8_t dp, const float value) {
+void onDrawFloatMenu(MenuItem* menuitem, int8_t line, uint8_t dp, const float value) {
   onDrawMenuItem(menuitem, line);
-  DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(line), value);
+  DWINUI::drawSignedFloat(hmiData.colorText, hmiData.colorBackground, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(line), value);
 }
 
-void onDrawPFloatMenu(MenuItemClass* menuitem, int8_t line, uint8_t dp) {
-  const float value = *(float*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+void onDrawPFloatMenu(MenuItem* menuitem, int8_t line, uint8_t dp) {
+  const float value = *(float*)static_cast<MenuItemPtr*>(menuitem)->value;
   onDrawFloatMenu(menuitem, line, dp, value);
 }
 
-void onDrawChkbMenu(MenuItemClass* menuitem, int8_t line, bool checked) {
+void onDrawChkbMenu(MenuItem* menuitem, int8_t line, bool checked) {
   onDrawMenuItem(menuitem, line);
-  Draw_Chkb_Line(line, checked);
+  drawCheckboxLine(line, checked);
 }
 
-void onDrawChkbMenu(MenuItemClass* menuitem, int8_t line) {
-  const bool val = *(bool*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+void onDrawChkbMenu(MenuItem* menuitem, int8_t line) {
+  const bool val = *(bool*)static_cast<MenuItemPtr*>(menuitem)->value;
   onDrawChkbMenu(menuitem, line, val);
 }
 
 void DrawItemEdit(const bool selected) {
-  const uint16_t bcolor = selected ? HMI_data.Selected_Color : HMI_data.Background_Color;
-  const uint8_t iNum = 4 - ((MenuData.dp > 0) ? (MenuData.dp - 1) : 0);
+  const uint16_t bcolor = selected ? hmiData.colorSelected : hmiData.colorBackground;
+  const uint8_t iNum = 4 - ((menuData.dp > 0) ? (menuData.dp - 1) : 0);
   switch (checkkey) {
-    case SetIntNoDraw:  if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
-    case SetInt:
-    case SetPInt:       DWINUI::Draw_Signed_Int(HMI_data.Text_Color, bcolor, iNum , VALX, MBASE(CurrentMenu->line()) - 1, MenuData.Value); break;
-    case SetFloat:
-    case SetPFloat:     DWINUI::Draw_Signed_Float(HMI_data.Text_Color, bcolor, iNum, MenuData.dp, VALX - 2 * DWINUI::fontWidth(), MBASE(CurrentMenu->line()), MenuData.Value / POW(10, MenuData.dp)); break;
+    case ID_SetIntNoDraw: if (menuData.liveUpdate) menuData.liveUpdate(); break;
+    case ID_SetInt:
+    case ID_SetPInt:    DWINUI::drawSignedInt(hmiData.colorText, bcolor, iNum , VALX, MBASE(currentMenu->line()) - 1, menuData.value); break;
+    case ID_SetFloat:
+    case ID_SetPFloat:  DWINUI::drawSignedFloat(hmiData.colorText, bcolor, iNum, menuData.dp, VALX - 2 * DWINUI::fontWidth(), MBASE(currentMenu->line()), menuData.value / POW(10, menuData.dp)); break;
     default: break;
   }
 }
@@ -180,16 +180,16 @@ void DrawItemEdit(const bool selected) {
 //  hi: high limit
 //  dp: decimal places, 0 for integers
 //  val: value / scaled value
-//  LiveUpdate: live update function when the encoder changes
-//  Apply: update function when the encoder is pressed
-void SetOnClick(uint8_t process, const int32_t lo, const int32_t hi, uint8_t dp, const int32_t val, void (*Apply)()/*=nullptr*/, void (*LiveUpdate)()/*=nullptr*/) {
+//  liveUpdate: live update function when the encoder changes
+//  apply: update function when the encoder is pressed
+void setOnClick(uint8_t process, const int32_t lo, const int32_t hi, uint8_t dp, const int32_t val, void (*apply)()/*=nullptr*/, void (*liveUpdate)()/*=nullptr*/) {
   checkkey = process;
-  MenuData.MinValue = lo;
-  MenuData.MaxValue = hi;
-  MenuData.dp = dp;
-  MenuData.Apply = Apply;
-  MenuData.LiveUpdate = LiveUpdate;
-  MenuData.Value = constrain(val, lo, hi);
+  menuData.minValue = lo;
+  menuData.maxValue = hi;
+  menuData.dp = dp;
+  menuData.apply = apply;
+  menuData.liveUpdate = liveUpdate;
+  menuData.value = constrain(val, lo, hi);
   encoderRate.enabled = true;
 }
 
@@ -198,10 +198,10 @@ void SetOnClick(uint8_t process, const int32_t lo, const int32_t hi, uint8_t dp,
 //  lo: scaled low limit
 //  hi: scaled high limit
 //  val: value
-//  LiveUpdate: live update function when the encoder changes
-//  Apply: update function when the encoder is pressed
-void SetValueOnClick(uint8_t process, const int32_t lo, const int32_t hi, const int32_t val, void (*Apply)()/*=nullptr*/, void (*LiveUpdate)()/*=nullptr*/) {
-  SetOnClick(process, lo, hi, 0, val, Apply, LiveUpdate);
+//  liveUpdate: live update function when the encoder changes
+//  apply: update function when the encoder is pressed
+void setValueOnClick(uint8_t process, const int32_t lo, const int32_t hi, const int32_t val, void (*apply)()/*=nullptr*/, void (*liveUpdate)()/*=nullptr*/) {
+  setOnClick(process, lo, hi, 0, val, apply, liveUpdate);
   DrawItemEdit(true);
 }
 
@@ -210,11 +210,11 @@ void SetValueOnClick(uint8_t process, const int32_t lo, const int32_t hi, const
 //  lo: scaled low limit
 //  hi: scaled high limit
 //  val: value
-//  LiveUpdate: live update function when the encoder changes
-//  Apply: update function when the encoder is pressed
-void SetValueOnClick(uint8_t process, const float lo, const float hi, uint8_t dp, const float val, void (*Apply)()/*=nullptr*/, void (*LiveUpdate)()/*=nullptr*/) {
+//  liveUpdate: live update function when the encoder changes
+//  apply: update function when the encoder is pressed
+void setValueOnClick(uint8_t process, const float lo, const float hi, uint8_t dp, const float val, void (*apply)()/*=nullptr*/, void (*liveUpdate)()/*=nullptr*/) {
   const int32_t value =  round(val * POW(10, dp));
-  SetOnClick(process, lo * POW(10, dp), hi * POW(10, dp), dp, value, Apply, LiveUpdate);
+  setOnClick(process, lo * POW(10, dp), hi * POW(10, dp), dp, value, apply, liveUpdate);
   DrawItemEdit(true);
 }
 
@@ -222,21 +222,21 @@ void SetValueOnClick(uint8_t process, const float lo, const float hi, uint8_t dp
 //  lo: scaled low limit
 //  hi: scaled high limit
 //  val: value
-//  LiveUpdate: live update function when the encoder changes
-//  Apply: update function when the encoder is pressed
-void SetIntOnClick(const int32_t lo, const int32_t hi, const int32_t val, void (*Apply)()/*=nullptr*/, void (*LiveUpdate)()/*=nullptr*/) {
-  SetValueOnClick(SetInt, lo, hi, val, Apply, LiveUpdate);
+//  liveUpdate: live update function when the encoder changes
+//  apply: update function when the encoder is pressed
+void setIntOnClick(const int32_t lo, const int32_t hi, const int32_t val, void (*apply)()/*=nullptr*/, void (*liveUpdate)()/*=nullptr*/) {
+  setValueOnClick(ID_SetInt, lo, hi, val, apply, liveUpdate);
 }
 
 // Generic onclick event for set pointer to 16 bit uinteger values
 //  lo: low limit
 //  hi: high limit
-//  LiveUpdate: live update function when the encoder changes
-//  Apply: update function when the encoder is pressed
-void SetPIntOnClick(const int32_t lo, const int32_t hi, void (*Apply)()/*=nullptr*/, void (*LiveUpdate)()/*=nullptr*/) {
-  MenuData.P_Int = (int16_t*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
-  const int32_t value = *MenuData.P_Int;
-  SetValueOnClick(SetPInt, lo, hi, value, Apply, LiveUpdate);
+//  liveUpdate: live update function when the encoder changes
+//  apply: update function when the encoder is pressed
+void setPIntOnClick(const int32_t lo, const int32_t hi, void (*apply)()/*=nullptr*/, void (*liveUpdate)()/*=nullptr*/) {
+  menuData.intPtr = (int16_t*)static_cast<MenuItemPtr*>(currentMenu->selectedItem())->value;
+  const int32_t value = *menuData.intPtr;
+  setValueOnClick(ID_SetPInt, lo, hi, value, apply, liveUpdate);
 }
 
 // Generic onclick event for float values
@@ -245,31 +245,31 @@ void SetPIntOnClick(const int32_t lo, const int32_t hi, void (*Apply)()/*=nullpt
 //  hi: high limit
 //  dp: decimal places
 //  val: value
-void SetFloatOnClick(const float lo, const float hi, uint8_t dp, const float val, void (*Apply)()/*=nullptr*/, void (*LiveUpdate)()/*=nullptr*/) {
-  SetValueOnClick(SetFloat, lo, hi, dp, val, Apply, LiveUpdate);
+void setFloatOnClick(const float lo, const float hi, uint8_t dp, const float val, void (*apply)()/*=nullptr*/, void (*liveUpdate)()/*=nullptr*/) {
+  setValueOnClick(ID_SetFloat, lo, hi, dp, val, apply, liveUpdate);
 }
 
 // Generic onclick event for set pointer to float values
 //  lo: low limit
 //  hi: high limit
-//  LiveUpdate: live update function when the encoder changes
-//  Apply: update function when the encoder is pressed
-void SetPFloatOnClick(const float lo, const float hi, uint8_t dp, void (*Apply)()/*=nullptr*/, void (*LiveUpdate)()/*=nullptr*/) {
-  MenuData.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
-  SetValueOnClick(SetPFloat, lo, hi, dp, *MenuData.P_Float, Apply, LiveUpdate);
+//  liveUpdate: live update function when the encoder changes
+//  apply: update function when the encoder is pressed
+void setPFloatOnClick(const float lo, const float hi, uint8_t dp, void (*apply)()/*=nullptr*/, void (*liveUpdate)()/*=nullptr*/) {
+  menuData.floatPtr = (float*)static_cast<MenuItemPtr*>(currentMenu->selectedItem())->value;
+  setValueOnClick(ID_SetPFloat, lo, hi, dp, *menuData.floatPtr, apply, liveUpdate);
 }
 
 // HMI Control functions ======================================================
 
 // Generic menu control using the encoder
-void HMI_Menu() {
+void hmiMenu() {
   EncoderState encoder_diffState = get_encoder_state();
-  if (CurrentMenu) {
+  if (currentMenu) {
     if (encoder_diffState == ENCODER_DIFF_NO) return;
     if (encoder_diffState == ENCODER_DIFF_ENTER)
-      CurrentMenu->onClick();
+      currentMenu->onClick();
     else
-      CurrentMenu->onScroll(encoder_diffState == ENCODER_DIFF_CW);
+      currentMenu->onScroll(encoder_diffState == ENCODER_DIFF_CW);
   }
 }
 
@@ -279,283 +279,283 @@ void HMI_Menu() {
 //  0 : no change
 //  1 : live change
 //  2 : apply change
-int8_t HMI_Get(bool draw) {
-  const int32_t lo = MenuData.MinValue;
-  const int32_t hi = MenuData.MaxValue;
-  const int32_t cval = MenuData.Value;
+int8_t hmiGet(bool draw) {
+  const int32_t lo = menuData.minValue;
+  const int32_t hi = menuData.maxValue;
+  const int32_t cval = menuData.value;
   EncoderState encoder_diffState = TERN(SMOOTH_ENCODER_MENUITEMS, get_encoder_state(), encoderReceiveAnalyze());
   if (encoder_diffState != ENCODER_DIFF_NO) {
-    if (applyEncoder(encoder_diffState, MenuData.Value)) {
+    if (applyEncoder(encoder_diffState, menuData.value)) {
       encoderRate.enabled = false;
       if (draw) DrawItemEdit(false);
-      checkkey = Menu;
+      checkkey = ID_Menu;
       return 2;
     }
-    LIMIT(MenuData.Value, lo, hi);
+    LIMIT(menuData.value, lo, hi);
   }
-  const bool change = cval != MenuData.Value;
+  const bool change = cval != menuData.value;
   if (change) DrawItemEdit(true);
   return int8_t(change);
 }
 
 // Set and draw a value using the encoder
-void HMI_SetDraw() {
-  int8_t val = HMI_Get(true);
+void hmiSetDraw() {
+  int8_t val = hmiGet(true);
   switch (val) {
     case 0: return;
-    case 1: if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
-    case 2: if (MenuData.Apply) MenuData.Apply(); break;
+    case 1: if (menuData.liveUpdate) menuData.liveUpdate(); break;
+    case 2: if (menuData.apply) menuData.apply(); break;
   }
 }
 
 // Set an value without drawing
-void HMI_SetNoDraw() {
-  int8_t val = HMI_Get(false);
+void hmiSetNoDraw() {
+  int8_t val = hmiGet(false);
   switch (val) {
     case 0: return;
-    case 1: if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
-    case 2: if (MenuData.Apply) MenuData.Apply(); break;
+    case 1: if (menuData.liveUpdate) menuData.liveUpdate(); break;
+    case 2: if (menuData.apply) menuData.apply(); break;
   }
 }
 
 // Set an integer pointer variable using the encoder
-void HMI_SetPInt() {
-  int8_t val = HMI_Get(true);
+void hmiSetPInt() {
+  int8_t val = hmiGet(true);
   switch (val) {
     case 0: return;
-    case 1: if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
-    case 2: *MenuData.P_Int = MenuData.Value; if (MenuData.Apply) MenuData.Apply(); break;
+    case 1: if (menuData.liveUpdate) menuData.liveUpdate(); break;
+    case 2: *menuData.intPtr = menuData.value; if (menuData.apply) menuData.apply(); break;
   }
 }
 
 // Set a scaled float pointer variable using the encoder
-void HMI_SetPFloat() {
-  const int8_t val = HMI_Get(true);
+void hmiSetPFloat() {
+  const int8_t val = hmiGet(true);
   switch (val) {
     case 0: return;
-    case 1: if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
-    case 2: *MenuData.P_Float = MenuData.Value / POW(10, MenuData.dp); if (MenuData.Apply) MenuData.Apply(); break;
+    case 1: if (menuData.liveUpdate) menuData.liveUpdate(); break;
+    case 2: *menuData.floatPtr = menuData.value / POW(10, menuData.dp); if (menuData.apply) menuData.apply(); break;
   }
 }
 
 // Menu Class ===============================================================
 
-MenuClass::MenuClass() {
+Menu::Menu() {
   selected = 0;
   topline = 0;
 }
 
-void MenuClass::draw() {
-  MenuTitle.draw();
-  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
-  dwinDrawRectangle(1, DWINUI::backcolor, 0, TITLE_HEIGHT, DWIN_WIDTH - 1, STATUS_Y - 1);
+void Menu::draw() {
+  menuTitle.draw();
+  DWINUI::setColors(hmiData.colorText, hmiData.colorBackground, hmiData.colorStatusBg);
+  dwinDrawRectangle(1, DWINUI::backColor, 0, TITLE_HEIGHT, DWIN_WIDTH - 1, STATUS_Y - 1);
   for (int8_t i = 0; i < MenuItemCount; i++)
-    MenuItems[i]->draw(i - topline);
-  Draw_Menu_Cursor(line());
+    menuItems[i]->draw(i - topline);
+  drawMenuCursor(line());
   dwinUpdateLCD();
 }
 
-void MenuClass::onScroll(bool dir) {
+void Menu::onScroll(bool dir) {
   int8_t sel = selected;
   if (dir) sel++; else sel--;
   LIMIT(sel, 0, MenuItemCount - 1);
   if (sel != selected) {
-    Erase_Menu_Cursor(line());
+    eraseMenuCursor(line());
     dwinUpdateLCD();
     if ((sel - topline) == TROWS) {
-      dwinFrameAreaMove(1, DWIN_SCROLL_UP, MLINE, DWINUI::backcolor, 0, TITLE_HEIGHT + 1, DWIN_WIDTH, STATUS_Y - 1);
+      dwinFrameAreaMove(1, DWIN_SCROLL_UP, MLINE, DWINUI::backColor, 0, TITLE_HEIGHT + 1, DWIN_WIDTH, STATUS_Y - 1);
       topline++;
-      MenuItems[sel]->draw(TROWS - 1);
+      menuItems[sel]->draw(TROWS - 1);
     }
     if ((sel < topline)) {
-      dwinFrameAreaMove(1, DWIN_SCROLL_DOWN, MLINE, DWINUI::backcolor, 0, TITLE_HEIGHT + 1, DWIN_WIDTH, STATUS_Y - 1);
+      dwinFrameAreaMove(1, DWIN_SCROLL_DOWN, MLINE, DWINUI::backColor, 0, TITLE_HEIGHT + 1, DWIN_WIDTH, STATUS_Y - 1);
       topline--;
-      MenuItems[sel]->draw(0);
+      menuItems[sel]->draw(0);
     }
     selected = sel;
-    Draw_Menu_Cursor(line());
+    drawMenuCursor(line());
     dwinUpdateLCD();
   }
 }
 
-void MenuClass::onClick() {
-  if (MenuItems[selected]->onClick != nullptr) (*MenuItems[selected]->onClick)();
+void Menu::onClick() {
+  if (menuItems[selected]->onClick != nullptr) (*menuItems[selected]->onClick)();
 }
 
-CustomMenuItemClass *MenuClass::SelectedItem() {
-  return MenuItems[selected];
+CustomMenuItem *Menu::selectedItem() {
+  return menuItems[selected];
 }
 
-CustomMenuItemClass** MenuClass::Items() {
-  return MenuItems;
+CustomMenuItem** Menu::items() {
+  return menuItems;
 }
 
-int8_t MenuClass::count() {
+int8_t Menu::count() {
   return MenuItemCount;
 };
 
 /* MenuItem Class ===========================================================*/
 
-void CustomMenuItemClass::draw(int8_t line) {
+void CustomMenuItem::draw(int8_t line) {
   if (line < 0 || line >= TROWS) return;
-  if (onDraw != nullptr) (*onDraw)(static_cast<MenuItemClass*>(this), line);
+  if (onDraw != nullptr) (*onDraw)(static_cast<MenuItem*>(this), line);
 };
 
-void CustomMenuItemClass::redraw(bool erase/*=false*/) {
-  const int8_t line = CurrentMenu->line(this->pos);
-  if (erase) Erase_Menu_Text(line);
+void CustomMenuItem::redraw(bool erase/*=false*/) {
+  const int8_t line = currentMenu->line(this->pos);
+  if (erase) eraseMenuText(line);
   draw(line);
 }
 
-CustomMenuItemClass::CustomMenuItemClass(OnDrawItem ondraw, OnClickItem onclick) {
+CustomMenuItem::CustomMenuItem(OnDrawItem ondraw, OnClickItem onclick) {
   onClick = onclick;
   onDraw =  ondraw;
 }
 
-MenuItemClass::MenuItemClass(uint8_t cicon, const char * const text, OnDrawItem ondraw, OnClickItem onclick) : CustomMenuItemClass(ondraw, onclick) {
+MenuItem::MenuItem(uint8_t cicon, const char * const text, OnDrawItem ondraw, OnClickItem onclick) : CustomMenuItem(ondraw, onclick) {
   icon = cicon;
-  SetCaption(text);
+  setCaption(text);
 }
 
-MenuItemClass::MenuItemClass(uint8_t cicon, uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, OnDrawItem ondraw, OnClickItem onclick) : CustomMenuItemClass(ondraw, onclick) {
+MenuItem::MenuItem(uint8_t cicon, uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, OnDrawItem ondraw, OnClickItem onclick) : CustomMenuItem(ondraw, onclick) {
   icon = cicon;
   caption[0] = '\0';
   frameid = id;
   frame = { x1, y1, x2, y2 };
 }
 
-void MenuItemClass::SetCaption(const char * const text) {
+void MenuItem::setCaption(const char * const text) {
   const uint8_t len = _MIN(sizeof(caption) - 1, strlen(text));
   memcpy(&caption[0], text, len);
   caption[len] = '\0';
 }
 
-void MenuItemClass::SetFrame(uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2) {
+void MenuItem::setFrame(uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2) {
   caption[0] = '\0';
   frameid = id;
   frame = { x1, y1, x2, y2 };
 }
 
-MenuItemPtrClass::MenuItemPtrClass(uint8_t cicon, const char * const text, OnDrawItem ondraw, OnClickItem onclick, void* val) : MenuItemClass(cicon, text, ondraw, onclick) {
+MenuItemPtr::MenuItemPtr(uint8_t cicon, const char * const text, OnDrawItem ondraw, OnClickItem onclick, void* val) : MenuItem(cicon, text, ondraw, onclick) {
   value = val;
 };
 
 // Menu auxiliary functions ===================================================
 
-void MenuItemsClear() {
-  if (MenuItems == nullptr) return;
-  for (int8_t i = 0; i < MenuItemCount; i++) delete MenuItems[i];
-  delete[] MenuItems;
-  MenuItems = nullptr;
+void menuItemsClear() {
+  if (menuItems == nullptr) return;
+  for (int8_t i = 0; i < MenuItemCount; i++) delete menuItems[i];
+  delete[] menuItems;
+  menuItems = nullptr;
   MenuItemCount = 0;
   MenuItemTotal = 0;
 }
 
-void MenuItemsPrepare(int8_t totalitems) {
-  MenuItemsClear();
+void menuItemsPrepare(int8_t totalitems) {
+  menuItemsClear();
   MenuItemTotal = _MIN(totalitems, MENU_MAX_ITEMS);
-  MenuItems = new CustomMenuItemClass*[totalitems];
+  menuItems = new CustomMenuItem*[totalitems];
 }
 
-bool IsMenu(MenuClass* _menu) {
-  return ((checkkey == Menu) && !!CurrentMenu && (CurrentMenu == _menu));
+bool isMenu(Menu* _menu) {
+  return ((checkkey == ID_Menu) && !!currentMenu && (currentMenu == _menu));
 }
 
 template<typename T>
-T* MenuItemAdd(T* menuitem) {
-  MenuItems[MenuItemCount] = menuitem;
+T* menuItemAdd(T* menuitem) {
+  menuItems[MenuItemCount] = menuitem;
   menuitem->pos = MenuItemCount++;
   return menuitem;
 }
 
-CustomMenuItemClass* MenuItemAdd(OnDrawItem ondraw/*=nullptr*/, OnClickItem onclick/*=nullptr*/) {
+CustomMenuItem* menuItemAdd(OnDrawItem ondraw/*=nullptr*/, OnClickItem onclick/*=nullptr*/) {
   if (MenuItemCount < MenuItemTotal) {
-    CustomMenuItemClass* menuitem = new CustomMenuItemClass(ondraw, onclick);
-    return MenuItemAdd(menuitem);
+    CustomMenuItem* menuitem = new CustomMenuItem(ondraw, onclick);
+    return menuItemAdd(menuitem);
   }
   else return nullptr;
 }
 
-MenuItemClass* MenuItemAdd(uint8_t cicon, const char * const text/*=nullptr*/, OnDrawItem ondraw/*=nullptr*/, OnClickItem onclick/*=nullptr*/) {
+MenuItem* menuItemAdd(uint8_t cicon, const char * const text/*=nullptr*/, OnDrawItem ondraw/*=nullptr*/, OnClickItem onclick/*=nullptr*/) {
   if (MenuItemCount < MenuItemTotal) {
-    MenuItemClass* menuitem = new MenuItemClass(cicon, text, ondraw, onclick);
-    return MenuItemAdd(menuitem);
+    MenuItem* menuitem = new MenuItem(cicon, text, ondraw, onclick);
+    return menuItemAdd(menuitem);
   }
   else return nullptr;
 }
 
-MenuItemClass* MenuItemAdd(uint8_t cicon, uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, OnDrawItem ondraw/*=nullptr*/, OnClickItem onclick/*=nullptr*/) {
+MenuItem* menuItemAdd(uint8_t cicon, uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, OnDrawItem ondraw/*=nullptr*/, OnClickItem onclick/*=nullptr*/) {
   if (MenuItemCount < MenuItemTotal) {
-    MenuItemClass* menuitem = new MenuItemClass(cicon, id, x1, y1, x2, y2, ondraw, onclick);
-    return MenuItemAdd(menuitem);
+    MenuItem* menuitem = new MenuItem(cicon, id, x1, y1, x2, y2, ondraw, onclick);
+    return menuItemAdd(menuitem);
   }
   else return nullptr;
 }
 
-MenuItemClass* EditItemAdd(uint8_t cicon, const char * const text, OnDrawItem ondraw, OnClickItem onclick, void* val) {
+MenuItem* editItemAdd(uint8_t cicon, const char * const text, OnDrawItem ondraw, OnClickItem onclick, void* val) {
   if (MenuItemCount < MenuItemTotal) {
-    MenuItemClass* menuitem = new MenuItemPtrClass(cicon, text, ondraw, onclick, val);
-    return MenuItemAdd(menuitem);
+    MenuItem* menuitem = new MenuItemPtr(cicon, text, ondraw, onclick, val);
+    return menuItemAdd(menuitem);
   }
   else return nullptr;
 }
 
-void InitMenu() {
-  CurrentMenu = nullptr;
-  PreviousMenu = nullptr;
+void initMenu() {
+  currentMenu = nullptr;
+  previousMenu = nullptr;
 }
 
-bool SetMenu(MenuClass* &menu, FSTR_P title, int8_t totalitems) {
-  if (!menu) menu = new MenuClass();
-  const bool NotCurrent = (CurrentMenu != menu);
+bool setMenu(Menu* &menu, FSTR_P fTitle, int8_t totalitems) {
+  if (!menu) menu = new Menu();
+  const bool NotCurrent = (currentMenu != menu);
   if (NotCurrent) {
-    menu->MenuTitle.SetCaption(title);
-    MenuItemsPrepare(totalitems);
+    menu->menuTitle.setCaption(fTitle);
+    menuItemsPrepare(totalitems);
   }
   return NotCurrent;
 }
 
-bool SetMenu(MenuClass* &menu, frame_rect_t cn, FSTR_P title, int8_t totalitems) {
-  if (!menu) menu = new MenuClass();
-  const bool NotCurrent = (CurrentMenu != menu);
+bool setMenu(Menu* &menu, frame_rect_t cn, FSTR_P fTitle, int8_t totalitems) {
+  if (!menu) menu = new Menu();
+  const bool NotCurrent = (currentMenu != menu);
   if (NotCurrent) {
     if (cn.w != 0)
-      menu->MenuTitle.SetFrame(cn.x, cn.y, cn.w, cn.h);
+      menu->menuTitle.setFrame(cn.x, cn.y, cn.w, cn.h);
     else
-      menu->MenuTitle.SetCaption(title);
-    MenuItemsPrepare(totalitems);
+      menu->menuTitle.setCaption(fTitle);
+    menuItemsPrepare(totalitems);
   }
   return NotCurrent;
 }
 
-void ResetMenu(MenuClass* &menu) {
+void resetMenu(Menu* &menu) {
   if (menu) {
     menu->topline = 0;
     menu->selected = 0;
   }
 }
 
-void InvalidateMenu() {
-  ResetMenu(CurrentMenu);
-  CurrentMenu = nullptr;
+void invalidateMenu() {
+  resetMenu(currentMenu);
+  currentMenu = nullptr;
 }
 
-void UpdateMenu(MenuClass* &menu) {
+void updateMenu(Menu* &menu) {
   if (!menu) return;
-  if (CurrentMenu != menu) {
-    PreviousMenu = CurrentMenu;
-    CurrentMenu = menu;
+  if (currentMenu != menu) {
+    previousMenu = currentMenu;
+    currentMenu = menu;
   }
   menu->draw();
 }
 
 void ReDrawMenu(bool force/*=false*/) {
-  if (CurrentMenu && (force || checkkey == Menu)) CurrentMenu->draw();
+  if (currentMenu && (force || checkkey == ID_Menu)) currentMenu->draw();
   if (force) DrawItemEdit(true);
 }
 
 void ReDrawItem() {
-  static_cast<MenuItemClass*>(CurrentMenu->SelectedItem())->redraw(false);
+  static_cast<MenuItem*>(currentMenu->selectedItem())->redraw(false);
 }
 
 #endif // DWIN_LCD_PROUI

commit 858916d628526b5d56c34c5c9663e3535bfc7788
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Fri Jun 23 04:57:22 2023 -0500

    üö∏ Update DWIN ProUI (#26003)

diff --git a/Marlin/src/lcd/e3v2/proui/menus.cpp b/Marlin/src/lcd/e3v2/proui/menus.cpp
index 870a4248ce..54892b6acb 100644
--- a/Marlin/src/lcd/e3v2/proui/menus.cpp
+++ b/Marlin/src/lcd/e3v2/proui/menus.cpp
@@ -23,8 +23,8 @@
 /**
  * Menu functions for ProUI
  * Author: Miguel A. Risco-Castillo
- * Version: 1.9.1
- * Date: 2022/12/02
+ * Version: 1.10.1
+ * Date: 2022/05/01
  */
 
 #include "../../../inc/MarlinConfigPre.h"
@@ -32,8 +32,6 @@
 #if ENABLED(DWIN_LCD_PROUI)
 
 #include "../common/encoder.h"
-#include "dwin_lcd.h"
-#include "dwinui.h"
 #include "dwin.h"
 #include "menus.h"
 
@@ -58,11 +56,6 @@ void Draw_Title(TitleClass* title) {
     #endif
 }
 
-void Draw_Menu(MenuClass* menu) {
-  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
-  dwinDrawRectangle(1, DWINUI::backcolor, 0, TITLE_HEIGHT, DWIN_WIDTH - 1, STATUS_Y - 1);
-}
-
 void Draw_Menu_Cursor(const int8_t line) {
   const uint16_t ypos = MYPOS(line);
   DWINUI::Draw_Box(1, HMI_data.Cursor_Color, {0, ypos, 15, MLINE - 1});
@@ -79,7 +72,7 @@ void Erase_Menu_Text(const int8_t line) {
   DWINUI::Draw_Box(1, HMI_data.Background_Color, {LBLX, ypos, DWIN_WIDTH - LBLX, MLINE - 2});
 }
 
-void Draw_Menu_Line(const uint8_t line, const uint8_t icon /*=0*/, const char * const label /*=nullptr*/, bool more /*=false*/, bool selected /*=false*/) {
+void Draw_Menu_Line(const uint8_t line, const uint8_t icon/*=0*/, const char * const label/*=nullptr*/, bool more/*=false*/, bool selected/*=false*/) {
   if (icon)  DWINUI::Draw_Icon(icon, ICOX, MBASE(line) - 3);
   if (label) DWINUI::Draw_String(LBLX, MBASE(line) - 1, (char*)label);
   if (more)  DWINUI::Draw_Icon(ICON_More, VALX + 16, MBASE(line) - 3);
@@ -87,7 +80,7 @@ void Draw_Menu_Line(const uint8_t line, const uint8_t icon /*=0*/, const char *
   dwinDrawHLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
 }
 
-void Draw_Menu_Line(const uint8_t line, const uint8_t icon /*=0*/, FSTR_P label /*=nullptr*/, bool more /*=false*/, bool selected /*=false*/) {
+void Draw_Menu_Line(const uint8_t line, const uint8_t icon/*=0*/, FSTR_P label/*=nullptr*/, bool more/*=false*/, bool selected/*=false*/) {
   Draw_Menu_Line(line, icon, FTOP(label), more, selected);
 }
 
@@ -106,7 +99,7 @@ void Toggle_Chkb_Line(bool &checked) {
   Show_Chkb_Line(checked);
 }
 
-void Draw_Menu_IntValue(uint16_t bcolor, const uint8_t line, uint8_t iNum, const int32_t value /*=0*/) {
+void Draw_Menu_IntValue(uint16_t bcolor, const uint8_t line, uint8_t iNum, const int32_t value/*=0*/) {
   DWINUI::Draw_Signed_Int(HMI_data.Text_Color, bcolor, iNum , VALX, MBASE(line) - 1, value);
 }
 
@@ -189,7 +182,7 @@ void DrawItemEdit(const bool selected) {
 //  val: value / scaled value
 //  LiveUpdate: live update function when the encoder changes
 //  Apply: update function when the encoder is pressed
-void SetOnClick(uint8_t process, const int32_t lo, const int32_t hi, uint8_t dp, const int32_t val, void (*Apply)() /*= nullptr*/, void (*LiveUpdate)() /*= nullptr*/) {
+void SetOnClick(uint8_t process, const int32_t lo, const int32_t hi, uint8_t dp, const int32_t val, void (*Apply)()/*=nullptr*/, void (*LiveUpdate)()/*=nullptr*/) {
   checkkey = process;
   MenuData.MinValue = lo;
   MenuData.MaxValue = hi;
@@ -207,7 +200,7 @@ void SetOnClick(uint8_t process, const int32_t lo, const int32_t hi, uint8_t dp,
 //  val: value
 //  LiveUpdate: live update function when the encoder changes
 //  Apply: update function when the encoder is pressed
-void SetValueOnClick(uint8_t process, const int32_t lo, const int32_t hi, const int32_t val, void (*Apply)() /*= nullptr*/, void (*LiveUpdate)() /*= nullptr*/) {
+void SetValueOnClick(uint8_t process, const int32_t lo, const int32_t hi, const int32_t val, void (*Apply)()/*=nullptr*/, void (*LiveUpdate)()/*=nullptr*/) {
   SetOnClick(process, lo, hi, 0, val, Apply, LiveUpdate);
   DrawItemEdit(true);
 }
@@ -219,7 +212,7 @@ void SetValueOnClick(uint8_t process, const int32_t lo, const int32_t hi, const
 //  val: value
 //  LiveUpdate: live update function when the encoder changes
 //  Apply: update function when the encoder is pressed
-void SetValueOnClick(uint8_t process, const float lo, const float hi, uint8_t dp, const float val, void (*Apply)() /*= nullptr*/, void (*LiveUpdate)() /*= nullptr*/) {
+void SetValueOnClick(uint8_t process, const float lo, const float hi, uint8_t dp, const float val, void (*Apply)()/*=nullptr*/, void (*LiveUpdate)()/*=nullptr*/) {
   const int32_t value =  round(val * POW(10, dp));
   SetOnClick(process, lo * POW(10, dp), hi * POW(10, dp), dp, value, Apply, LiveUpdate);
   DrawItemEdit(true);
@@ -231,7 +224,7 @@ void SetValueOnClick(uint8_t process, const float lo, const float hi, uint8_t dp
 //  val: value
 //  LiveUpdate: live update function when the encoder changes
 //  Apply: update function when the encoder is pressed
-void SetIntOnClick(const int32_t lo, const int32_t hi, const int32_t val, void (*Apply)() /*= nullptr*/, void (*LiveUpdate)() /*= nullptr*/) {
+void SetIntOnClick(const int32_t lo, const int32_t hi, const int32_t val, void (*Apply)()/*=nullptr*/, void (*LiveUpdate)()/*=nullptr*/) {
   SetValueOnClick(SetInt, lo, hi, val, Apply, LiveUpdate);
 }
 
@@ -240,7 +233,7 @@ void SetIntOnClick(const int32_t lo, const int32_t hi, const int32_t val, void (
 //  hi: high limit
 //  LiveUpdate: live update function when the encoder changes
 //  Apply: update function when the encoder is pressed
-void SetPIntOnClick(const int32_t lo, const int32_t hi, void (*Apply)() /*= nullptr*/, void (*LiveUpdate)() /*= nullptr*/) {
+void SetPIntOnClick(const int32_t lo, const int32_t hi, void (*Apply)()/*=nullptr*/, void (*LiveUpdate)()/*=nullptr*/) {
   MenuData.P_Int = (int16_t*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
   const int32_t value = *MenuData.P_Int;
   SetValueOnClick(SetPInt, lo, hi, value, Apply, LiveUpdate);
@@ -252,7 +245,7 @@ void SetPIntOnClick(const int32_t lo, const int32_t hi, void (*Apply)() /*= null
 //  hi: high limit
 //  dp: decimal places
 //  val: value
-void SetFloatOnClick(const float lo, const float hi, uint8_t dp, const float val, void (*Apply)() /*= nullptr*/, void (*LiveUpdate)() /*= nullptr*/) {
+void SetFloatOnClick(const float lo, const float hi, uint8_t dp, const float val, void (*Apply)()/*=nullptr*/, void (*LiveUpdate)()/*=nullptr*/) {
   SetValueOnClick(SetFloat, lo, hi, dp, val, Apply, LiveUpdate);
 }
 
@@ -261,7 +254,7 @@ void SetFloatOnClick(const float lo, const float hi, uint8_t dp, const float val
 //  hi: high limit
 //  LiveUpdate: live update function when the encoder changes
 //  Apply: update function when the encoder is pressed
-void SetPFloatOnClick(const float lo, const float hi, uint8_t dp, void (*Apply)() /*= nullptr*/, void (*LiveUpdate)() /*= nullptr*/) {
+void SetPFloatOnClick(const float lo, const float hi, uint8_t dp, void (*Apply)()/*=nullptr*/, void (*LiveUpdate)()/*=nullptr*/) {
   MenuData.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
   SetValueOnClick(SetPFloat, lo, hi, dp, *MenuData.P_Float, Apply, LiveUpdate);
 }
@@ -290,7 +283,7 @@ int8_t HMI_Get(bool draw) {
   const int32_t lo = MenuData.MinValue;
   const int32_t hi = MenuData.MaxValue;
   const int32_t cval = MenuData.Value;
-  EncoderState encoder_diffState = get_encoder_state();
+  EncoderState encoder_diffState = TERN(SMOOTH_ENCODER_MENUITEMS, get_encoder_state(), encoderReceiveAnalyze());
   if (encoder_diffState != ENCODER_DIFF_NO) {
     if (applyEncoder(encoder_diffState, MenuData.Value)) {
       encoderRate.enabled = false;
@@ -354,7 +347,8 @@ MenuClass::MenuClass() {
 
 void MenuClass::draw() {
   MenuTitle.draw();
-  Draw_Menu(this);
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
+  dwinDrawRectangle(1, DWINUI::backcolor, 0, TITLE_HEIGHT, DWIN_WIDTH - 1, STATUS_Y - 1);
   for (int8_t i = 0; i < MenuItemCount; i++)
     MenuItems[i]->draw(i - topline);
   Draw_Menu_Cursor(line());
@@ -407,7 +401,7 @@ void CustomMenuItemClass::draw(int8_t line) {
   if (onDraw != nullptr) (*onDraw)(static_cast<MenuItemClass*>(this), line);
 };
 
-void CustomMenuItemClass::redraw(bool erase /*=false*/) {
+void CustomMenuItemClass::redraw(bool erase/*=false*/) {
   const int8_t line = CurrentMenu->line(this->pos);
   if (erase) Erase_Menu_Text(line);
   draw(line);
@@ -507,8 +501,8 @@ MenuItemClass* EditItemAdd(uint8_t cicon, const char * const text, OnDrawItem on
 }
 
 void InitMenu() {
+  CurrentMenu = nullptr;
   PreviousMenu = nullptr;
-  InvalidateMenu();
 }
 
 bool SetMenu(MenuClass* &menu, FSTR_P title, int8_t totalitems) {
@@ -534,14 +528,18 @@ bool SetMenu(MenuClass* &menu, frame_rect_t cn, FSTR_P title, int8_t totalitems)
   return NotCurrent;
 }
 
-void InvalidateMenu() {
-  if (CurrentMenu) {
-    CurrentMenu->topline = 0;
-    CurrentMenu->selected = 0;
-    CurrentMenu = nullptr;
+void ResetMenu(MenuClass* &menu) {
+  if (menu) {
+    menu->topline = 0;
+    menu->selected = 0;
   }
 }
 
+void InvalidateMenu() {
+  ResetMenu(CurrentMenu);
+  CurrentMenu = nullptr;
+}
+
 void UpdateMenu(MenuClass* &menu) {
   if (!menu) return;
   if (CurrentMenu != menu) {
@@ -551,9 +549,13 @@ void UpdateMenu(MenuClass* &menu) {
   menu->draw();
 }
 
-void ReDrawMenu(bool force /*= false*/) {
-  if (CurrentMenu && (force || checkkey==Menu)) CurrentMenu->draw();
+void ReDrawMenu(bool force/*=false*/) {
+  if (CurrentMenu && (force || checkkey == Menu)) CurrentMenu->draw();
   if (force) DrawItemEdit(true);
 }
 
+void ReDrawItem() {
+  static_cast<MenuItemClass*>(CurrentMenu->SelectedItem())->redraw(false);
+}
+
 #endif // DWIN_LCD_PROUI

commit 238951a966204ce9bc109e06fdb4027125b28feb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 16 18:08:59 2023 -0500

    üé® More more lowercase (partial ProUI)
    
    Followup to #25939

diff --git a/Marlin/src/lcd/e3v2/proui/menus.cpp b/Marlin/src/lcd/e3v2/proui/menus.cpp
index dfcfaa7bbc..870a4248ce 100644
--- a/Marlin/src/lcd/e3v2/proui/menus.cpp
+++ b/Marlin/src/lcd/e3v2/proui/menus.cpp
@@ -47,20 +47,20 @@ MenuData_t MenuData;
 // Menuitem Drawing functions =================================================
 
 void Draw_Title(TitleClass* title) {
-  DWIN_Draw_Rectangle(1, HMI_data.TitleBg_Color, 0, 0, DWIN_WIDTH - 1, TITLE_HEIGHT - 1);
+  dwinDrawRectangle(1, HMI_data.TitleBg_Color, 0, 0, DWIN_WIDTH - 1, TITLE_HEIGHT - 1);
   if (title->frameid)
     DWIN_Frame_AreaCopy(title->frameid, title->frame.left, title->frame.top, title->frame.right, title->frame.bottom, 14, (TITLE_HEIGHT - (title->frame.bottom - title->frame.top)) / 2 - 1);
   else
     #if ENABLED(TITLE_CENTERED)
       DWINUI::Draw_CenteredString(false, DWIN_FONT_HEAD, HMI_data.TitleTxt_Color, HMI_data.TitleBg_Color, (TITLE_HEIGHT - DWINUI::fontHeight(DWIN_FONT_HEAD)) / 2 - 1, title->caption);
     #else
-      DWIN_Draw_String(false, DWIN_FONT_HEAD, HMI_data.TitleTxt_Color, HMI_data.TitleBg_Color, 14, (TITLE_HEIGHT - DWINUI::fontHeight(DWIN_FONT_HEAD)) / 2 - 1, title->caption);
+      dwinDrawString(false, DWIN_FONT_HEAD, HMI_data.TitleTxt_Color, HMI_data.TitleBg_Color, 14, (TITLE_HEIGHT - DWINUI::fontHeight(DWIN_FONT_HEAD)) / 2 - 1, title->caption);
     #endif
 }
 
 void Draw_Menu(MenuClass* menu) {
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
-  DWIN_Draw_Rectangle(1, DWINUI::backcolor, 0, TITLE_HEIGHT, DWIN_WIDTH - 1, STATUS_Y - 1);
+  dwinDrawRectangle(1, DWINUI::backcolor, 0, TITLE_HEIGHT, DWIN_WIDTH - 1, STATUS_Y - 1);
 }
 
 void Draw_Menu_Cursor(const int8_t line) {
@@ -84,7 +84,7 @@ void Draw_Menu_Line(const uint8_t line, const uint8_t icon /*=0*/, const char *
   if (label) DWINUI::Draw_String(LBLX, MBASE(line) - 1, (char*)label);
   if (more)  DWINUI::Draw_Icon(ICON_More, VALX + 16, MBASE(line) - 3);
   if (selected) Draw_Menu_Cursor(line);
-  DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
+  dwinDrawHLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
 }
 
 void Draw_Menu_Line(const uint8_t line, const uint8_t icon /*=0*/, FSTR_P label /*=nullptr*/, bool more /*=false*/, bool selected /*=false*/) {
@@ -98,7 +98,7 @@ void Draw_Chkb_Line(const uint8_t line, const bool checked) {
 void Show_Chkb_Line(const bool checked) {
   const uint8_t line = CurrentMenu->line();
   DWINUI::Draw_Checkbox(HMI_data.Text_Color, HMI_data.Background_Color, VALX + 3 * DWINUI::fontWidth(), MBASE(line) - 1, checked);
-  DWIN_UpdateLCD();
+  dwinUpdateLCD();
 }
 
 void Toggle_Chkb_Line(bool &checked) {
@@ -116,7 +116,7 @@ void onDrawMenuItem(MenuItemClass* menuitem, int8_t line) {
     DWIN_Frame_AreaCopy(menuitem->frameid, menuitem->frame.left, menuitem->frame.top, menuitem->frame.right, menuitem->frame.bottom, LBLX, MBASE(line));
   else if (menuitem->caption)
     DWINUI::Draw_String(LBLX, MBASE(line) - 1, menuitem->caption);
-  DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
+  dwinDrawHLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
 }
 
 void onDrawSubMenu(MenuItemClass* menuitem, int8_t line) {
@@ -197,7 +197,7 @@ void SetOnClick(uint8_t process, const int32_t lo, const int32_t hi, uint8_t dp,
   MenuData.Apply = Apply;
   MenuData.LiveUpdate = LiveUpdate;
   MenuData.Value = constrain(val, lo, hi);
-  EncoderRate.enabled = true;
+  encoderRate.enabled = true;
 }
 
 // Generic onclick event for integer values
@@ -292,8 +292,8 @@ int8_t HMI_Get(bool draw) {
   const int32_t cval = MenuData.Value;
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState != ENCODER_DIFF_NO) {
-    if (Apply_Encoder(encoder_diffState, MenuData.Value)) {
-      EncoderRate.enabled = false;
+    if (applyEncoder(encoder_diffState, MenuData.Value)) {
+      encoderRate.enabled = false;
       if (draw) DrawItemEdit(false);
       checkkey = Menu;
       return 2;
@@ -358,7 +358,7 @@ void MenuClass::draw() {
   for (int8_t i = 0; i < MenuItemCount; i++)
     MenuItems[i]->draw(i - topline);
   Draw_Menu_Cursor(line());
-  DWIN_UpdateLCD();
+  dwinUpdateLCD();
 }
 
 void MenuClass::onScroll(bool dir) {
@@ -367,20 +367,20 @@ void MenuClass::onScroll(bool dir) {
   LIMIT(sel, 0, MenuItemCount - 1);
   if (sel != selected) {
     Erase_Menu_Cursor(line());
-    DWIN_UpdateLCD();
+    dwinUpdateLCD();
     if ((sel - topline) == TROWS) {
-      DWIN_Frame_AreaMove(1, DWIN_SCROLL_UP, MLINE, DWINUI::backcolor, 0, TITLE_HEIGHT + 1, DWIN_WIDTH, STATUS_Y - 1);
+      dwinFrameAreaMove(1, DWIN_SCROLL_UP, MLINE, DWINUI::backcolor, 0, TITLE_HEIGHT + 1, DWIN_WIDTH, STATUS_Y - 1);
       topline++;
       MenuItems[sel]->draw(TROWS - 1);
     }
     if ((sel < topline)) {
-      DWIN_Frame_AreaMove(1, DWIN_SCROLL_DOWN, MLINE, DWINUI::backcolor, 0, TITLE_HEIGHT + 1, DWIN_WIDTH, STATUS_Y - 1);
+      dwinFrameAreaMove(1, DWIN_SCROLL_DOWN, MLINE, DWINUI::backcolor, 0, TITLE_HEIGHT + 1, DWIN_WIDTH, STATUS_Y - 1);
       topline--;
       MenuItems[sel]->draw(0);
     }
     selected = sel;
     Draw_Menu_Cursor(line());
-    DWIN_UpdateLCD();
+    dwinUpdateLCD();
   }
 }
 

commit b3f65b674f23db5c32e4d7e96ad2dff97c77c717
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Tue Jan 17 18:41:36 2023 -0500

    üö∏ ProUI MPC menu (#25232)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/menus.cpp b/Marlin/src/lcd/e3v2/proui/menus.cpp
index 540f9e1f41..dfcfaa7bbc 100644
--- a/Marlin/src/lcd/e3v2/proui/menus.cpp
+++ b/Marlin/src/lcd/e3v2/proui/menus.cpp
@@ -25,20 +25,6 @@
  * Author: Miguel A. Risco-Castillo
  * Version: 1.9.1
  * Date: 2022/12/02
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as
- * published by the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
  */
 
 #include "../../../inc/MarlinConfigPre.h"

commit 5fd5cb02f6b26f32fd9b49fb37e53a93531da98c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 14 07:44:57 2023 -0600

    ‚úèÔ∏è  ProUI followup

diff --git a/Marlin/src/lcd/e3v2/proui/menus.cpp b/Marlin/src/lcd/e3v2/proui/menus.cpp
index 3267eec60d..540f9e1f41 100644
--- a/Marlin/src/lcd/e3v2/proui/menus.cpp
+++ b/Marlin/src/lcd/e3v2/proui/menus.cpp
@@ -115,7 +115,7 @@ void Show_Chkb_Line(const bool checked) {
   DWIN_UpdateLCD();
 }
 
-void Toogle_Chkb_Line(bool &checked) {
+void Toggle_Chkb_Line(bool &checked) {
   checked = !checked;
   Show_Chkb_Line(checked);
 }

commit 290a55ced1071eaf9daf6f8191902f48f1b2ea4d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 8 04:18:24 2023 -0600

    üé® ProUI cleanup

diff --git a/Marlin/src/lcd/e3v2/proui/menus.cpp b/Marlin/src/lcd/e3v2/proui/menus.cpp
index 32c19acb69..3267eec60d 100644
--- a/Marlin/src/lcd/e3v2/proui/menus.cpp
+++ b/Marlin/src/lcd/e3v2/proui/menus.cpp
@@ -399,7 +399,7 @@ void MenuClass::onScroll(bool dir) {
 }
 
 void MenuClass::onClick() {
-  if (MenuItems[selected]->onClick != nullptr) (*MenuItems[selected]->onClick)(); 
+  if (MenuItems[selected]->onClick != nullptr) (*MenuItems[selected]->onClick)();
 }
 
 CustomMenuItemClass *MenuClass::SelectedItem() {
@@ -410,8 +410,8 @@ CustomMenuItemClass** MenuClass::Items() {
   return MenuItems;
 }
 
-int8_t MenuClass::count() { 
-  return MenuItemCount; 
+int8_t MenuClass::count() {
+  return MenuItemCount;
 };
 
 /* MenuItem Class ===========================================================*/
@@ -510,7 +510,7 @@ MenuItemClass* MenuItemAdd(uint8_t cicon, uint8_t id, uint16_t x1, uint16_t y1,
     return MenuItemAdd(menuitem);
   }
   else return nullptr;
-}  
+}
 
 MenuItemClass* EditItemAdd(uint8_t cicon, const char * const text, OnDrawItem ondraw, OnClickItem onclick, void* val) {
   if (MenuItemCount < MenuItemTotal) {

commit c66b3cf8a429c427c014f33171407c634da735f1
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Sun Jan 8 04:22:21 2023 -0500

    üö∏ ProUI updates (#25176)

diff --git a/Marlin/src/lcd/e3v2/proui/menus.cpp b/Marlin/src/lcd/e3v2/proui/menus.cpp
index 85594fecdb..32c19acb69 100644
--- a/Marlin/src/lcd/e3v2/proui/menus.cpp
+++ b/Marlin/src/lcd/e3v2/proui/menus.cpp
@@ -23,8 +23,8 @@
 /**
  * Menu functions for ProUI
  * Author: Miguel A. Risco-Castillo
- * Version: 1.5.1
- * Date: 2022/05/23
+ * Version: 1.9.1
+ * Date: 2022/12/02
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as
@@ -53,22 +53,23 @@
 
 int8_t MenuItemTotal = 0;
 int8_t MenuItemCount = 0;
-MenuItemClass** MenuItems = nullptr;
+CustomMenuItemClass** MenuItems = nullptr;
 MenuClass *CurrentMenu = nullptr;
 MenuClass *PreviousMenu = nullptr;
-void (*onMenuDraw)(MenuClass* menu) = nullptr;
-void (*onCursorErase)(const int8_t line) = nullptr;
-void (*onCursorDraw)(const int8_t line) = nullptr;
 MenuData_t MenuData;
 
 // Menuitem Drawing functions =================================================
 
 void Draw_Title(TitleClass* title) {
-  DWIN_Draw_Rectangle(1, HMI_data.TitleBg_color, 0, 0, DWIN_WIDTH - 1, TITLE_HEIGHT - 1);
+  DWIN_Draw_Rectangle(1, HMI_data.TitleBg_Color, 0, 0, DWIN_WIDTH - 1, TITLE_HEIGHT - 1);
   if (title->frameid)
     DWIN_Frame_AreaCopy(title->frameid, title->frame.left, title->frame.top, title->frame.right, title->frame.bottom, 14, (TITLE_HEIGHT - (title->frame.bottom - title->frame.top)) / 2 - 1);
   else
-    DWIN_Draw_String(false, DWIN_FONT_HEAD, HMI_data.TitleTxt_color, HMI_data.TitleBg_color, 14, (TITLE_HEIGHT - DWINUI::fontHeight(DWIN_FONT_HEAD)) / 2 - 1, title->caption);
+    #if ENABLED(TITLE_CENTERED)
+      DWINUI::Draw_CenteredString(false, DWIN_FONT_HEAD, HMI_data.TitleTxt_Color, HMI_data.TitleBg_Color, (TITLE_HEIGHT - DWINUI::fontHeight(DWIN_FONT_HEAD)) / 2 - 1, title->caption);
+    #else
+      DWIN_Draw_String(false, DWIN_FONT_HEAD, HMI_data.TitleTxt_Color, HMI_data.TitleBg_Color, 14, (TITLE_HEIGHT - DWINUI::fontHeight(DWIN_FONT_HEAD)) / 2 - 1, title->caption);
+    #endif
 }
 
 void Draw_Menu(MenuClass* menu) {
@@ -78,7 +79,7 @@ void Draw_Menu(MenuClass* menu) {
 
 void Draw_Menu_Cursor(const int8_t line) {
   const uint16_t ypos = MYPOS(line);
-  DWINUI::Draw_Box(1, HMI_data.Cursor_color, {0, ypos, 15, MLINE - 1});
+  DWINUI::Draw_Box(1, HMI_data.Cursor_Color, {0, ypos, 15, MLINE - 1});
 }
 
 void Erase_Menu_Cursor(const int8_t line) {
@@ -86,17 +87,39 @@ void Erase_Menu_Cursor(const int8_t line) {
   DWINUI::Draw_Box(1, HMI_data.Background_Color, {0, ypos, 15, MLINE - 1});
 }
 
-void Draw_Menu_Line(const uint8_t line, const uint8_t icon /*=0*/, const char * const label /*=nullptr*/, bool more /*=false*/) {
+void Erase_Menu_Text(const int8_t line) {
+  if (line < 0 || line >= TROWS) return;
+  const uint16_t ypos = MYPOS(line) + 1;
+  DWINUI::Draw_Box(1, HMI_data.Background_Color, {LBLX, ypos, DWIN_WIDTH - LBLX, MLINE - 2});
+}
+
+void Draw_Menu_Line(const uint8_t line, const uint8_t icon /*=0*/, const char * const label /*=nullptr*/, bool more /*=false*/, bool selected /*=false*/) {
   if (icon)  DWINUI::Draw_Icon(icon, ICOX, MBASE(line) - 3);
   if (label) DWINUI::Draw_String(LBLX, MBASE(line) - 1, (char*)label);
   if (more)  DWINUI::Draw_Icon(ICON_More, VALX + 16, MBASE(line) - 3);
+  if (selected) Draw_Menu_Cursor(line);
   DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
 }
 
+void Draw_Menu_Line(const uint8_t line, const uint8_t icon /*=0*/, FSTR_P label /*=nullptr*/, bool more /*=false*/, bool selected /*=false*/) {
+  Draw_Menu_Line(line, icon, FTOP(label), more, selected);
+}
+
 void Draw_Chkb_Line(const uint8_t line, const bool checked) {
   DWINUI::Draw_Checkbox(HMI_data.Text_Color, HMI_data.Background_Color, VALX + 3 * DWINUI::fontWidth(), MBASE(line) - 1, checked);
 }
 
+void Show_Chkb_Line(const bool checked) {
+  const uint8_t line = CurrentMenu->line();
+  DWINUI::Draw_Checkbox(HMI_data.Text_Color, HMI_data.Background_Color, VALX + 3 * DWINUI::fontWidth(), MBASE(line) - 1, checked);
+  DWIN_UpdateLCD();
+}
+
+void Toogle_Chkb_Line(bool &checked) {
+  checked = !checked;
+  Show_Chkb_Line(checked);
+}
+
 void Draw_Menu_IntValue(uint16_t bcolor, const uint8_t line, uint8_t iNum, const int32_t value /*=0*/) {
   DWINUI::Draw_Signed_Int(HMI_data.Text_Color, bcolor, iNum , VALX, MBASE(line) - 1, value);
 }
@@ -140,22 +163,11 @@ void onDrawFloatMenu(MenuItemClass* menuitem, int8_t line, uint8_t dp, const flo
   DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(line), value);
 }
 
-void onDrawPFloatMenu(MenuItemClass* menuitem, int8_t line) {
+void onDrawPFloatMenu(MenuItemClass* menuitem, int8_t line, uint8_t dp) {
   const float value = *(float*)static_cast<MenuItemPtrClass*>(menuitem)->value;
-  const int8_t dp = UNITFDIGITS;
   onDrawFloatMenu(menuitem, line, dp, value);
 }
 
-void onDrawPFloat2Menu(MenuItemClass* menuitem, int8_t line) {
-  const float value = *(float*)static_cast<MenuItemPtrClass*>(menuitem)->value;
-  onDrawFloatMenu(menuitem, line, 2, value);
-}
-
-void onDrawPFloat3Menu(MenuItemClass* menuitem, int8_t line) {
-  const float value = *(float*)static_cast<MenuItemPtrClass*>(menuitem)->value;
-  onDrawFloatMenu(menuitem, line, 3, value);
-}
-
 void onDrawChkbMenu(MenuItemClass* menuitem, int8_t line, bool checked) {
   onDrawMenuItem(menuitem, line);
   Draw_Chkb_Line(line, checked);
@@ -166,13 +178,15 @@ void onDrawChkbMenu(MenuItemClass* menuitem, int8_t line) {
   onDrawChkbMenu(menuitem, line, val);
 }
 
-void DrawItemEdit() {
+void DrawItemEdit(const bool selected) {
+  const uint16_t bcolor = selected ? HMI_data.Selected_Color : HMI_data.Background_Color;
+  const uint8_t iNum = 4 - ((MenuData.dp > 0) ? (MenuData.dp - 1) : 0);
   switch (checkkey) {
     case SetIntNoDraw:  if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
     case SetInt:
-    case SetPInt:       DWINUI::Draw_Signed_Int(HMI_data.Text_Color, HMI_data.Selected_Color, 4 , VALX, MBASE(CurrentMenu->line()) - 1, MenuData.Value); break;
+    case SetPInt:       DWINUI::Draw_Signed_Int(HMI_data.Text_Color, bcolor, iNum , VALX, MBASE(CurrentMenu->line()) - 1, MenuData.Value); break;
     case SetFloat:
-    case SetPFloat:     DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Selected_Color, 3, MenuData.dp, VALX - MenuData.dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), MenuData.Value / POW(10, MenuData.dp)); break;
+    case SetPFloat:     DWINUI::Draw_Signed_Float(HMI_data.Text_Color, bcolor, iNum, MenuData.dp, VALX - 2 * DWINUI::fontWidth(), MBASE(CurrentMenu->line()), MenuData.Value / POW(10, MenuData.dp)); break;
     default: break;
   }
 }
@@ -209,7 +223,7 @@ void SetOnClick(uint8_t process, const int32_t lo, const int32_t hi, uint8_t dp,
 //  Apply: update function when the encoder is pressed
 void SetValueOnClick(uint8_t process, const int32_t lo, const int32_t hi, const int32_t val, void (*Apply)() /*= nullptr*/, void (*LiveUpdate)() /*= nullptr*/) {
   SetOnClick(process, lo, hi, 0, val, Apply, LiveUpdate);
-  Draw_Menu_IntValue(HMI_data.Selected_Color, CurrentMenu->line(), 4, MenuData.Value);
+  DrawItemEdit(true);
 }
 
 // Generic onclick event for float values
@@ -222,7 +236,7 @@ void SetValueOnClick(uint8_t process, const int32_t lo, const int32_t hi, const
 void SetValueOnClick(uint8_t process, const float lo, const float hi, uint8_t dp, const float val, void (*Apply)() /*= nullptr*/, void (*LiveUpdate)() /*= nullptr*/) {
   const int32_t value =  round(val * POW(10, dp));
   SetOnClick(process, lo * POW(10, dp), hi * POW(10, dp), dp, value, Apply, LiveUpdate);
-  DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Selected_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), val);
+  DrawItemEdit(true);
 }
 
 // Generic onclick event for integer values
@@ -271,8 +285,8 @@ void SetPFloatOnClick(const float lo, const float hi, uint8_t dp, void (*Apply)(
 // Generic menu control using the encoder
 void HMI_Menu() {
   EncoderState encoder_diffState = get_encoder_state();
-  if (encoder_diffState == ENCODER_DIFF_NO) return;
   if (CurrentMenu) {
+    if (encoder_diffState == ENCODER_DIFF_NO) return;
     if (encoder_diffState == ENCODER_DIFF_ENTER)
       CurrentMenu->onClick();
     else
@@ -280,65 +294,46 @@ void HMI_Menu() {
   }
 }
 
-// Get an integer value using the encoder without draw anything
-//  lo: low limit
-//  hi: high limit
+// Get a value using the encoder
+// draw : draw the value
 // Return value:
 //  0 : no change
 //  1 : live change
 //  2 : apply change
-int8_t HMI_GetIntNoDraw(const int32_t lo, const int32_t hi) {
+int8_t HMI_Get(bool draw) {
+  const int32_t lo = MenuData.MinValue;
+  const int32_t hi = MenuData.MaxValue;
   const int32_t cval = MenuData.Value;
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
-  if (encoder_diffState != ENCODER_DIFF_NO) {
-    if (Apply_Encoder(encoder_diffState, MenuData.Value)) {
-      EncoderRate.enabled = false;
-      checkkey = Menu;
-      return 2;
-    }
-    LIMIT(MenuData.Value, lo, hi);
-  }
-  return int8_t(cval != MenuData.Value);
-}
-
-// Get an integer value using the encoder
-//  lo: low limit
-//  hi: high limit
-// Return value:
-//  0 : no change
-//  1 : live change
-//  2 : apply change
-int8_t HMI_GetInt(const int32_t lo, const int32_t hi) {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState != ENCODER_DIFF_NO) {
     if (Apply_Encoder(encoder_diffState, MenuData.Value)) {
       EncoderRate.enabled = false;
-      DWINUI::Draw_Signed_Int(HMI_data.Text_Color, HMI_data.Background_Color, 4 , VALX, MBASE(CurrentMenu->line()) - 1, MenuData.Value);
+      if (draw) DrawItemEdit(false);
       checkkey = Menu;
       return 2;
     }
     LIMIT(MenuData.Value, lo, hi);
-    DrawItemEdit();
-    return 1;
   }
-  return 0;
+  const bool change = cval != MenuData.Value;
+  if (change) DrawItemEdit(true);
+  return int8_t(change);
 }
 
-// Set an integer using the encoder
-void HMI_SetInt() {
-  int8_t val = HMI_GetInt(MenuData.MinValue, MenuData.MaxValue);
+// Set and draw a value using the encoder
+void HMI_SetDraw() {
+  int8_t val = HMI_Get(true);
   switch (val) {
-    case 0: return; break;
+    case 0: return;
     case 1: if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
     case 2: if (MenuData.Apply) MenuData.Apply(); break;
   }
 }
 
-// Set an integer without drawing
-void HMI_SetIntNoDraw() {
-  int8_t val = HMI_GetIntNoDraw(MenuData.MinValue, MenuData.MaxValue);
+// Set an value without drawing
+void HMI_SetNoDraw() {
+  int8_t val = HMI_Get(false);
   switch (val) {
-    case 0: return; break;
+    case 0: return;
     case 1: if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
     case 2: if (MenuData.Apply) MenuData.Apply(); break;
   }
@@ -346,7 +341,7 @@ void HMI_SetIntNoDraw() {
 
 // Set an integer pointer variable using the encoder
 void HMI_SetPInt() {
-  int8_t val = HMI_GetInt(MenuData.MinValue, MenuData.MaxValue);
+  int8_t val = HMI_Get(true);
   switch (val) {
     case 0: return;
     case 1: if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
@@ -354,43 +349,9 @@ void HMI_SetPInt() {
   }
 }
 
-// Get a scaled float value using the encoder
-//  dp: decimal places
-//  lo: scaled low limit
-//  hi: scaled high limit
-// Return value:
-//  0 : no change
-//  1 : live change
-//  2 : apply change
-int8_t HMI_GetFloat(uint8_t dp, int32_t lo, int32_t hi) {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
-  if (encoder_diffState != ENCODER_DIFF_NO) {
-    if (Apply_Encoder(encoder_diffState, MenuData.Value)) {
-      EncoderRate.enabled = false;
-      DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), MenuData.Value / POW(10, dp));
-      checkkey = Menu;
-      return 2;
-    }
-    LIMIT(MenuData.Value, lo, hi);
-    DrawItemEdit();
-    return 1;
-  }
-  return 0;
-}
-
-// Set a scaled float using the encoder
-void HMI_SetFloat() {
-  const int8_t val = HMI_GetFloat(MenuData.dp, MenuData.MinValue, MenuData.MaxValue);
-  switch (val) {
-    case 0: return;
-    case 1: if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
-    case 2: if (MenuData.Apply) MenuData.Apply(); break;
-  }
-}
-
 // Set a scaled float pointer variable using the encoder
 void HMI_SetPFloat() {
-  const int8_t val = HMI_GetFloat(MenuData.dp, MenuData.MinValue, MenuData.MaxValue);
+  const int8_t val = HMI_Get(true);
   switch (val) {
     case 0: return;
     case 1: if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
@@ -398,7 +359,7 @@ void HMI_SetPFloat() {
   }
 }
 
-// Menu Classes ===============================================================
+// Menu Class ===============================================================
 
 MenuClass::MenuClass() {
   selected = 0;
@@ -407,10 +368,10 @@ MenuClass::MenuClass() {
 
 void MenuClass::draw() {
   MenuTitle.draw();
-  if (onMenuDraw != nullptr) onMenuDraw(this);
+  Draw_Menu(this);
   for (int8_t i = 0; i < MenuItemCount; i++)
     MenuItems[i]->draw(i - topline);
-  if (onCursorDraw != nullptr) onCursorDraw(line());
+  Draw_Menu_Cursor(line());
   DWIN_UpdateLCD();
 }
 
@@ -419,7 +380,7 @@ void MenuClass::onScroll(bool dir) {
   if (dir) sel++; else sel--;
   LIMIT(sel, 0, MenuItemCount - 1);
   if (sel != selected) {
-    if (onCursorErase != nullptr) onCursorErase(line());
+    Erase_Menu_Cursor(line());
     DWIN_UpdateLCD();
     if ((sel - topline) == TROWS) {
       DWIN_Frame_AreaMove(1, DWIN_SCROLL_UP, MLINE, DWINUI::backcolor, 0, TITLE_HEIGHT + 1, DWIN_WIDTH, STATUS_Y - 1);
@@ -432,63 +393,70 @@ void MenuClass::onScroll(bool dir) {
       MenuItems[sel]->draw(0);
     }
     selected = sel;
-    if (onCursorDraw != nullptr) onCursorDraw(line());
+    Draw_Menu_Cursor(line());
     DWIN_UpdateLCD();
   }
 }
 
 void MenuClass::onClick() {
-  if (MenuItems[selected]->onClick != nullptr) (*MenuItems[selected]->onClick)();
+  if (MenuItems[selected]->onClick != nullptr) (*MenuItems[selected]->onClick)(); 
 }
 
-MenuItemClass *MenuClass::SelectedItem() {
+CustomMenuItemClass *MenuClass::SelectedItem() {
   return MenuItems[selected];
 }
 
-MenuItemClass** MenuClass::Items() {
+CustomMenuItemClass** MenuClass::Items() {
   return MenuItems;
 }
 
-int8_t MenuClass::count() {
-  return MenuItemCount;
+int8_t MenuClass::count() { 
+  return MenuItemCount; 
 };
 
 /* MenuItem Class ===========================================================*/
 
-MenuItemClass::MenuItemClass(uint8_t cicon, const char * const text, void (*ondraw)(MenuItemClass* menuitem, int8_t line), void (*onclick)()) {
-  icon = cicon;
+void CustomMenuItemClass::draw(int8_t line) {
+  if (line < 0 || line >= TROWS) return;
+  if (onDraw != nullptr) (*onDraw)(static_cast<MenuItemClass*>(this), line);
+};
+
+void CustomMenuItemClass::redraw(bool erase /*=false*/) {
+  const int8_t line = CurrentMenu->line(this->pos);
+  if (erase) Erase_Menu_Text(line);
+  draw(line);
+}
+
+CustomMenuItemClass::CustomMenuItemClass(OnDrawItem ondraw, OnClickItem onclick) {
   onClick = onclick;
-  onDraw = ondraw;
-  const uint8_t len = _MIN(sizeof(caption) - 1, strlen(text));
-  memcpy(&caption[0], text, len);
-  caption[len] = '\0';
+  onDraw =  ondraw;
 }
 
-MenuItemClass::MenuItemClass(uint8_t cicon, uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, void (*ondraw)(MenuItemClass* menuitem, int8_t line), void (*onclick)()) {
+MenuItemClass::MenuItemClass(uint8_t cicon, const char * const text, OnDrawItem ondraw, OnClickItem onclick) : CustomMenuItemClass(ondraw, onclick) {
+  icon = cicon;
+  SetCaption(text);
+}
+
+MenuItemClass::MenuItemClass(uint8_t cicon, uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, OnDrawItem ondraw, OnClickItem onclick) : CustomMenuItemClass(ondraw, onclick) {
   icon = cicon;
-  onClick = onclick;
-  onDraw = ondraw;
   caption[0] = '\0';
   frameid = id;
   frame = { x1, y1, x2, y2 };
 }
 
+void MenuItemClass::SetCaption(const char * const text) {
+  const uint8_t len = _MIN(sizeof(caption) - 1, strlen(text));
+  memcpy(&caption[0], text, len);
+  caption[len] = '\0';
+}
+
 void MenuItemClass::SetFrame(uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2) {
   caption[0] = '\0';
   frameid = id;
   frame = { x1, y1, x2, y2 };
 }
 
-void MenuItemClass::draw(int8_t line) {
-  if (!WITHIN(line, 0, TROWS - 1)) return;
-  if (onDraw != nullptr) (*onDraw)(this, line);
-};
-
-void MenuItemClass::redraw() {
-  draw(CurrentMenu->line(this->pos));
-}
-
-MenuItemPtrClass::MenuItemPtrClass(uint8_t cicon, const char * const text, void (*ondraw)(MenuItemClass* menuitem, int8_t line), void (*onclick)(), void* val) : MenuItemClass(cicon, text, ondraw, onclick) {
+MenuItemPtrClass::MenuItemPtrClass(uint8_t cicon, const char * const text, OnDrawItem ondraw, OnClickItem onclick, void* val) : MenuItemClass(cicon, text, ondraw, onclick) {
   value = val;
 };
 
@@ -505,40 +473,58 @@ void MenuItemsClear() {
 
 void MenuItemsPrepare(int8_t totalitems) {
   MenuItemsClear();
-  MenuItemTotal = totalitems;
-  MenuItems = new MenuItemClass*[totalitems];
+  MenuItemTotal = _MIN(totalitems, MENU_MAX_ITEMS);
+  MenuItems = new CustomMenuItemClass*[totalitems];
 }
 
-MenuItemClass* MenuItemsAdd(MenuItemClass* menuitem) {
+bool IsMenu(MenuClass* _menu) {
+  return ((checkkey == Menu) && !!CurrentMenu && (CurrentMenu == _menu));
+}
+
+template<typename T>
+T* MenuItemAdd(T* menuitem) {
   MenuItems[MenuItemCount] = menuitem;
   menuitem->pos = MenuItemCount++;
   return menuitem;
 }
 
-MenuItemClass* MenuItemsAdd(uint8_t cicon, const char * const text/*=nullptr*/, void (*ondraw)(MenuItemClass* menuitem, int8_t line)/*=nullptr*/, void (*onclick)()/*=nullptr*/) {
+CustomMenuItemClass* MenuItemAdd(OnDrawItem ondraw/*=nullptr*/, OnClickItem onclick/*=nullptr*/) {
+  if (MenuItemCount < MenuItemTotal) {
+    CustomMenuItemClass* menuitem = new CustomMenuItemClass(ondraw, onclick);
+    return MenuItemAdd(menuitem);
+  }
+  else return nullptr;
+}
+
+MenuItemClass* MenuItemAdd(uint8_t cicon, const char * const text/*=nullptr*/, OnDrawItem ondraw/*=nullptr*/, OnClickItem onclick/*=nullptr*/) {
   if (MenuItemCount < MenuItemTotal) {
     MenuItemClass* menuitem = new MenuItemClass(cicon, text, ondraw, onclick);
-    return MenuItemsAdd(menuitem);
+    return MenuItemAdd(menuitem);
   }
   else return nullptr;
 }
 
-MenuItemClass* MenuItemsAdd(uint8_t cicon, uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, void (*ondraw)(MenuItemClass* menuitem, int8_t line)/*=nullptr*/, void (*onclick)()/*=nullptr*/) {
+MenuItemClass* MenuItemAdd(uint8_t cicon, uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, OnDrawItem ondraw/*=nullptr*/, OnClickItem onclick/*=nullptr*/) {
   if (MenuItemCount < MenuItemTotal) {
     MenuItemClass* menuitem = new MenuItemClass(cicon, id, x1, y1, x2, y2, ondraw, onclick);
-    return MenuItemsAdd(menuitem);
+    return MenuItemAdd(menuitem);
   }
   else return nullptr;
-}
+}  
 
-MenuItemClass* MenuItemsAdd(uint8_t cicon, const char * const text, void (*ondraw)(MenuItemClass* menuitem, int8_t line), void (*onclick)(), void* val) {
+MenuItemClass* EditItemAdd(uint8_t cicon, const char * const text, OnDrawItem ondraw, OnClickItem onclick, void* val) {
   if (MenuItemCount < MenuItemTotal) {
     MenuItemClass* menuitem = new MenuItemPtrClass(cicon, text, ondraw, onclick, val);
-    return MenuItemsAdd(menuitem);
+    return MenuItemAdd(menuitem);
   }
   else return nullptr;
 }
 
+void InitMenu() {
+  PreviousMenu = nullptr;
+  InvalidateMenu();
+}
+
 bool SetMenu(MenuClass* &menu, FSTR_P title, int8_t totalitems) {
   if (!menu) menu = new MenuClass();
   const bool NotCurrent = (CurrentMenu != menu);
@@ -549,6 +535,27 @@ bool SetMenu(MenuClass* &menu, FSTR_P title, int8_t totalitems) {
   return NotCurrent;
 }
 
+bool SetMenu(MenuClass* &menu, frame_rect_t cn, FSTR_P title, int8_t totalitems) {
+  if (!menu) menu = new MenuClass();
+  const bool NotCurrent = (CurrentMenu != menu);
+  if (NotCurrent) {
+    if (cn.w != 0)
+      menu->MenuTitle.SetFrame(cn.x, cn.y, cn.w, cn.h);
+    else
+      menu->MenuTitle.SetCaption(title);
+    MenuItemsPrepare(totalitems);
+  }
+  return NotCurrent;
+}
+
+void InvalidateMenu() {
+  if (CurrentMenu) {
+    CurrentMenu->topline = 0;
+    CurrentMenu->selected = 0;
+    CurrentMenu = nullptr;
+  }
+}
+
 void UpdateMenu(MenuClass* &menu) {
   if (!menu) return;
   if (CurrentMenu != menu) {
@@ -558,9 +565,9 @@ void UpdateMenu(MenuClass* &menu) {
   menu->draw();
 }
 
-void ReDrawMenu(const bool force/*=false*/) {
-  if (CurrentMenu && (force || checkkey == Menu)) CurrentMenu->draw();
-  if (force) DrawItemEdit();
+void ReDrawMenu(bool force /*= false*/) {
+  if (CurrentMenu && (force || checkkey==Menu)) CurrentMenu->draw();
+  if (force) DrawItemEdit(true);
 }
 
 #endif // DWIN_LCD_PROUI

commit 8fb54d4621c5f571d613fca2943393d4a95cb8e4
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Thu Jul 14 00:00:33 2022 -0500

    üö∏ Fix and update ProUI (#24477)

diff --git a/Marlin/src/lcd/e3v2/proui/menus.cpp b/Marlin/src/lcd/e3v2/proui/menus.cpp
index 6438545cb2..85594fecdb 100644
--- a/Marlin/src/lcd/e3v2/proui/menus.cpp
+++ b/Marlin/src/lcd/e3v2/proui/menus.cpp
@@ -23,8 +23,8 @@
 /**
  * Menu functions for ProUI
  * Author: Miguel A. Risco-Castillo
- * Version: 1.4.1
- * Date: 2022/04/14
+ * Version: 1.5.1
+ * Date: 2022/05/23
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as
@@ -166,6 +166,17 @@ void onDrawChkbMenu(MenuItemClass* menuitem, int8_t line) {
   onDrawChkbMenu(menuitem, line, val);
 }
 
+void DrawItemEdit() {
+  switch (checkkey) {
+    case SetIntNoDraw:  if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
+    case SetInt:
+    case SetPInt:       DWINUI::Draw_Signed_Int(HMI_data.Text_Color, HMI_data.Selected_Color, 4 , VALX, MBASE(CurrentMenu->line()) - 1, MenuData.Value); break;
+    case SetFloat:
+    case SetPFloat:     DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Selected_Color, 3, MenuData.dp, VALX - MenuData.dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), MenuData.Value / POW(10, MenuData.dp)); break;
+    default: break;
+  }
+}
+
 //-----------------------------------------------------------------------------
 // On click functions
 //-----------------------------------------------------------------------------
@@ -307,7 +318,7 @@ int8_t HMI_GetInt(const int32_t lo, const int32_t hi) {
       return 2;
     }
     LIMIT(MenuData.Value, lo, hi);
-    DWINUI::Draw_Signed_Int(HMI_data.Text_Color, HMI_data.Selected_Color, 4 , VALX, MBASE(CurrentMenu->line()) - 1, MenuData.Value);
+    DrawItemEdit();
     return 1;
   }
   return 0;
@@ -361,7 +372,7 @@ int8_t HMI_GetFloat(uint8_t dp, int32_t lo, int32_t hi) {
       return 2;
     }
     LIMIT(MenuData.Value, lo, hi);
-    DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Selected_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), MenuData.Value / POW(10, dp));
+    DrawItemEdit();
     return 1;
   }
   return 0;
@@ -469,7 +480,7 @@ void MenuItemClass::SetFrame(uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2,
 }
 
 void MenuItemClass::draw(int8_t line) {
-  if (line < 0 || line >= TROWS) return;
+  if (!WITHIN(line, 0, TROWS - 1)) return;
   if (onDraw != nullptr) (*onDraw)(this, line);
 };
 
@@ -547,6 +558,9 @@ void UpdateMenu(MenuClass* &menu) {
   menu->draw();
 }
 
-void ReDrawMenu() { if (CurrentMenu && checkkey==Menu) CurrentMenu->draw(); }
+void ReDrawMenu(const bool force/*=false*/) {
+  if (CurrentMenu && (force || checkkey == Menu)) CurrentMenu->draw();
+  if (force) DrawItemEdit();
+}
 
 #endif // DWIN_LCD_PROUI

commit a65e4edb1c794dcd22980f3cce9bf2993da1514b
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Tue May 17 15:44:30 2022 -0500

    üö∏ ProUI APRIL2022 updates (#24084)

diff --git a/Marlin/src/lcd/e3v2/proui/menus.cpp b/Marlin/src/lcd/e3v2/proui/menus.cpp
index 6dfcb8595c..6438545cb2 100644
--- a/Marlin/src/lcd/e3v2/proui/menus.cpp
+++ b/Marlin/src/lcd/e3v2/proui/menus.cpp
@@ -23,8 +23,8 @@
 /**
  * Menu functions for ProUI
  * Author: Miguel A. Risco-Castillo
- * Version: 1.2.1
- * Date: 2022/02/25
+ * Version: 1.4.1
+ * Date: 2022/04/14
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as
@@ -51,6 +51,14 @@
 #include "dwin.h"
 #include "menus.h"
 
+int8_t MenuItemTotal = 0;
+int8_t MenuItemCount = 0;
+MenuItemClass** MenuItems = nullptr;
+MenuClass *CurrentMenu = nullptr;
+MenuClass *PreviousMenu = nullptr;
+void (*onMenuDraw)(MenuClass* menu) = nullptr;
+void (*onCursorErase)(const int8_t line) = nullptr;
+void (*onCursorDraw)(const int8_t line) = nullptr;
 MenuData_t MenuData;
 
 // Menuitem Drawing functions =================================================
@@ -69,11 +77,13 @@ void Draw_Menu(MenuClass* menu) {
 }
 
 void Draw_Menu_Cursor(const int8_t line) {
-  DWIN_Draw_Rectangle(1, HMI_data.Cursor_color, 0, MBASE(line) - 18, 14, MBASE(line + 1) - 20);
+  const uint16_t ypos = MYPOS(line);
+  DWINUI::Draw_Box(1, HMI_data.Cursor_color, {0, ypos, 15, MLINE - 1});
 }
 
 void Erase_Menu_Cursor(const int8_t line) {
-  DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, MBASE(line) - 18, 14, MBASE(line + 1) - 20);
+  const uint16_t ypos = MYPOS(line);
+  DWINUI::Draw_Box(1, HMI_data.Background_Color, {0, ypos, 15, MLINE - 1});
 }
 
 void Draw_Menu_Line(const uint8_t line, const uint8_t icon /*=0*/, const char * const label /*=nullptr*/, bool more /*=false*/) {
@@ -84,7 +94,7 @@ void Draw_Menu_Line(const uint8_t line, const uint8_t icon /*=0*/, const char *
 }
 
 void Draw_Chkb_Line(const uint8_t line, const bool checked) {
-  DWINUI::Draw_Checkbox(HMI_data.Text_Color, HMI_data.Background_Color, VALX + 16, MBASE(line) - 1, checked);
+  DWINUI::Draw_Checkbox(HMI_data.Text_Color, HMI_data.Background_Color, VALX + 3 * DWINUI::fontWidth(), MBASE(line) - 1, checked);
 }
 
 void Draw_Menu_IntValue(uint16_t bcolor, const uint8_t line, uint8_t iNum, const int32_t value /*=0*/) {
@@ -141,11 +151,21 @@ void onDrawPFloat2Menu(MenuItemClass* menuitem, int8_t line) {
   onDrawFloatMenu(menuitem, line, 2, value);
 }
 
+void onDrawPFloat3Menu(MenuItemClass* menuitem, int8_t line) {
+  const float value = *(float*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  onDrawFloatMenu(menuitem, line, 3, value);
+}
+
 void onDrawChkbMenu(MenuItemClass* menuitem, int8_t line, bool checked) {
   onDrawMenuItem(menuitem, line);
   Draw_Chkb_Line(line, checked);
 }
 
+void onDrawChkbMenu(MenuItemClass* menuitem, int8_t line) {
+  const bool val = *(bool*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  onDrawChkbMenu(menuitem, line, val);
+}
+
 //-----------------------------------------------------------------------------
 // On click functions
 //-----------------------------------------------------------------------------
@@ -165,7 +185,7 @@ void SetOnClick(uint8_t process, const int32_t lo, const int32_t hi, uint8_t dp,
   MenuData.dp = dp;
   MenuData.Apply = Apply;
   MenuData.LiveUpdate = LiveUpdate;
-  MenuData.Value = val;
+  MenuData.Value = constrain(val, lo, hi);
   EncoderRate.enabled = true;
 }
 
@@ -257,6 +277,7 @@ void HMI_Menu() {
 //  1 : live change
 //  2 : apply change
 int8_t HMI_GetIntNoDraw(const int32_t lo, const int32_t hi) {
+  const int32_t cval = MenuData.Value;
   EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
   if (encoder_diffState != ENCODER_DIFF_NO) {
     if (Apply_Encoder(encoder_diffState, MenuData.Value)) {
@@ -265,9 +286,8 @@ int8_t HMI_GetIntNoDraw(const int32_t lo, const int32_t hi) {
       return 2;
     }
     LIMIT(MenuData.Value, lo, hi);
-    return 1;
   }
-  return 0;
+  return int8_t(cval != MenuData.Value);
 }
 
 // Get an integer value using the encoder
@@ -367,4 +387,166 @@ void HMI_SetPFloat() {
   }
 }
 
+// Menu Classes ===============================================================
+
+MenuClass::MenuClass() {
+  selected = 0;
+  topline = 0;
+}
+
+void MenuClass::draw() {
+  MenuTitle.draw();
+  if (onMenuDraw != nullptr) onMenuDraw(this);
+  for (int8_t i = 0; i < MenuItemCount; i++)
+    MenuItems[i]->draw(i - topline);
+  if (onCursorDraw != nullptr) onCursorDraw(line());
+  DWIN_UpdateLCD();
+}
+
+void MenuClass::onScroll(bool dir) {
+  int8_t sel = selected;
+  if (dir) sel++; else sel--;
+  LIMIT(sel, 0, MenuItemCount - 1);
+  if (sel != selected) {
+    if (onCursorErase != nullptr) onCursorErase(line());
+    DWIN_UpdateLCD();
+    if ((sel - topline) == TROWS) {
+      DWIN_Frame_AreaMove(1, DWIN_SCROLL_UP, MLINE, DWINUI::backcolor, 0, TITLE_HEIGHT + 1, DWIN_WIDTH, STATUS_Y - 1);
+      topline++;
+      MenuItems[sel]->draw(TROWS - 1);
+    }
+    if ((sel < topline)) {
+      DWIN_Frame_AreaMove(1, DWIN_SCROLL_DOWN, MLINE, DWINUI::backcolor, 0, TITLE_HEIGHT + 1, DWIN_WIDTH, STATUS_Y - 1);
+      topline--;
+      MenuItems[sel]->draw(0);
+    }
+    selected = sel;
+    if (onCursorDraw != nullptr) onCursorDraw(line());
+    DWIN_UpdateLCD();
+  }
+}
+
+void MenuClass::onClick() {
+  if (MenuItems[selected]->onClick != nullptr) (*MenuItems[selected]->onClick)();
+}
+
+MenuItemClass *MenuClass::SelectedItem() {
+  return MenuItems[selected];
+}
+
+MenuItemClass** MenuClass::Items() {
+  return MenuItems;
+}
+
+int8_t MenuClass::count() {
+  return MenuItemCount;
+};
+
+/* MenuItem Class ===========================================================*/
+
+MenuItemClass::MenuItemClass(uint8_t cicon, const char * const text, void (*ondraw)(MenuItemClass* menuitem, int8_t line), void (*onclick)()) {
+  icon = cicon;
+  onClick = onclick;
+  onDraw = ondraw;
+  const uint8_t len = _MIN(sizeof(caption) - 1, strlen(text));
+  memcpy(&caption[0], text, len);
+  caption[len] = '\0';
+}
+
+MenuItemClass::MenuItemClass(uint8_t cicon, uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, void (*ondraw)(MenuItemClass* menuitem, int8_t line), void (*onclick)()) {
+  icon = cicon;
+  onClick = onclick;
+  onDraw = ondraw;
+  caption[0] = '\0';
+  frameid = id;
+  frame = { x1, y1, x2, y2 };
+}
+
+void MenuItemClass::SetFrame(uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2) {
+  caption[0] = '\0';
+  frameid = id;
+  frame = { x1, y1, x2, y2 };
+}
+
+void MenuItemClass::draw(int8_t line) {
+  if (line < 0 || line >= TROWS) return;
+  if (onDraw != nullptr) (*onDraw)(this, line);
+};
+
+void MenuItemClass::redraw() {
+  draw(CurrentMenu->line(this->pos));
+}
+
+MenuItemPtrClass::MenuItemPtrClass(uint8_t cicon, const char * const text, void (*ondraw)(MenuItemClass* menuitem, int8_t line), void (*onclick)(), void* val) : MenuItemClass(cicon, text, ondraw, onclick) {
+  value = val;
+};
+
+// Menu auxiliary functions ===================================================
+
+void MenuItemsClear() {
+  if (MenuItems == nullptr) return;
+  for (int8_t i = 0; i < MenuItemCount; i++) delete MenuItems[i];
+  delete[] MenuItems;
+  MenuItems = nullptr;
+  MenuItemCount = 0;
+  MenuItemTotal = 0;
+}
+
+void MenuItemsPrepare(int8_t totalitems) {
+  MenuItemsClear();
+  MenuItemTotal = totalitems;
+  MenuItems = new MenuItemClass*[totalitems];
+}
+
+MenuItemClass* MenuItemsAdd(MenuItemClass* menuitem) {
+  MenuItems[MenuItemCount] = menuitem;
+  menuitem->pos = MenuItemCount++;
+  return menuitem;
+}
+
+MenuItemClass* MenuItemsAdd(uint8_t cicon, const char * const text/*=nullptr*/, void (*ondraw)(MenuItemClass* menuitem, int8_t line)/*=nullptr*/, void (*onclick)()/*=nullptr*/) {
+  if (MenuItemCount < MenuItemTotal) {
+    MenuItemClass* menuitem = new MenuItemClass(cicon, text, ondraw, onclick);
+    return MenuItemsAdd(menuitem);
+  }
+  else return nullptr;
+}
+
+MenuItemClass* MenuItemsAdd(uint8_t cicon, uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, void (*ondraw)(MenuItemClass* menuitem, int8_t line)/*=nullptr*/, void (*onclick)()/*=nullptr*/) {
+  if (MenuItemCount < MenuItemTotal) {
+    MenuItemClass* menuitem = new MenuItemClass(cicon, id, x1, y1, x2, y2, ondraw, onclick);
+    return MenuItemsAdd(menuitem);
+  }
+  else return nullptr;
+}
+
+MenuItemClass* MenuItemsAdd(uint8_t cicon, const char * const text, void (*ondraw)(MenuItemClass* menuitem, int8_t line), void (*onclick)(), void* val) {
+  if (MenuItemCount < MenuItemTotal) {
+    MenuItemClass* menuitem = new MenuItemPtrClass(cicon, text, ondraw, onclick, val);
+    return MenuItemsAdd(menuitem);
+  }
+  else return nullptr;
+}
+
+bool SetMenu(MenuClass* &menu, FSTR_P title, int8_t totalitems) {
+  if (!menu) menu = new MenuClass();
+  const bool NotCurrent = (CurrentMenu != menu);
+  if (NotCurrent) {
+    menu->MenuTitle.SetCaption(title);
+    MenuItemsPrepare(totalitems);
+  }
+  return NotCurrent;
+}
+
+void UpdateMenu(MenuClass* &menu) {
+  if (!menu) return;
+  if (CurrentMenu != menu) {
+    PreviousMenu = CurrentMenu;
+    CurrentMenu = menu;
+  }
+  menu->draw();
+}
+
+void ReDrawMenu() { if (CurrentMenu && checkkey==Menu) CurrentMenu->draw(); }
+
 #endif // DWIN_LCD_PROUI

commit 79b38e0e14074b52e0aeb98b08a686a99a9b1aad
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Fri Mar 11 15:06:49 2022 -0500

    üö∏ Update Ender3 V2/S1 Pro UI (#23878)

diff --git a/Marlin/src/lcd/e3v2/proui/menus.cpp b/Marlin/src/lcd/e3v2/proui/menus.cpp
new file mode 100644
index 0000000000..6dfcb8595c
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/proui/menus.cpp
@@ -0,0 +1,370 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2022 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * Menu functions for ProUI
+ * Author: Miguel A. Risco-Castillo
+ * Version: 1.2.1
+ * Date: 2022/02/25
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if ENABLED(DWIN_LCD_PROUI)
+
+#include "../common/encoder.h"
+#include "dwin_lcd.h"
+#include "dwinui.h"
+#include "dwin.h"
+#include "menus.h"
+
+MenuData_t MenuData;
+
+// Menuitem Drawing functions =================================================
+
+void Draw_Title(TitleClass* title) {
+  DWIN_Draw_Rectangle(1, HMI_data.TitleBg_color, 0, 0, DWIN_WIDTH - 1, TITLE_HEIGHT - 1);
+  if (title->frameid)
+    DWIN_Frame_AreaCopy(title->frameid, title->frame.left, title->frame.top, title->frame.right, title->frame.bottom, 14, (TITLE_HEIGHT - (title->frame.bottom - title->frame.top)) / 2 - 1);
+  else
+    DWIN_Draw_String(false, DWIN_FONT_HEAD, HMI_data.TitleTxt_color, HMI_data.TitleBg_color, 14, (TITLE_HEIGHT - DWINUI::fontHeight(DWIN_FONT_HEAD)) / 2 - 1, title->caption);
+}
+
+void Draw_Menu(MenuClass* menu) {
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
+  DWIN_Draw_Rectangle(1, DWINUI::backcolor, 0, TITLE_HEIGHT, DWIN_WIDTH - 1, STATUS_Y - 1);
+}
+
+void Draw_Menu_Cursor(const int8_t line) {
+  DWIN_Draw_Rectangle(1, HMI_data.Cursor_color, 0, MBASE(line) - 18, 14, MBASE(line + 1) - 20);
+}
+
+void Erase_Menu_Cursor(const int8_t line) {
+  DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, MBASE(line) - 18, 14, MBASE(line + 1) - 20);
+}
+
+void Draw_Menu_Line(const uint8_t line, const uint8_t icon /*=0*/, const char * const label /*=nullptr*/, bool more /*=false*/) {
+  if (icon)  DWINUI::Draw_Icon(icon, ICOX, MBASE(line) - 3);
+  if (label) DWINUI::Draw_String(LBLX, MBASE(line) - 1, (char*)label);
+  if (more)  DWINUI::Draw_Icon(ICON_More, VALX + 16, MBASE(line) - 3);
+  DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
+}
+
+void Draw_Chkb_Line(const uint8_t line, const bool checked) {
+  DWINUI::Draw_Checkbox(HMI_data.Text_Color, HMI_data.Background_Color, VALX + 16, MBASE(line) - 1, checked);
+}
+
+void Draw_Menu_IntValue(uint16_t bcolor, const uint8_t line, uint8_t iNum, const int32_t value /*=0*/) {
+  DWINUI::Draw_Signed_Int(HMI_data.Text_Color, bcolor, iNum , VALX, MBASE(line) - 1, value);
+}
+
+void onDrawMenuItem(MenuItemClass* menuitem, int8_t line) {
+  if (menuitem->icon) DWINUI::Draw_Icon(menuitem->icon, ICOX, MBASE(line) - 3);
+  if (menuitem->frameid)
+    DWIN_Frame_AreaCopy(menuitem->frameid, menuitem->frame.left, menuitem->frame.top, menuitem->frame.right, menuitem->frame.bottom, LBLX, MBASE(line));
+  else if (menuitem->caption)
+    DWINUI::Draw_String(LBLX, MBASE(line) - 1, menuitem->caption);
+  DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
+}
+
+void onDrawSubMenu(MenuItemClass* menuitem, int8_t line) {
+  onDrawMenuItem(menuitem, line);
+  DWINUI::Draw_Icon(ICON_More, VALX + 16, MBASE(line) - 3);
+}
+
+void onDrawIntMenu(MenuItemClass* menuitem, int8_t line, int32_t value) {
+  onDrawMenuItem(menuitem, line);
+  Draw_Menu_IntValue(HMI_data.Background_Color, line, 4, value);
+}
+
+void onDrawPIntMenu(MenuItemClass* menuitem, int8_t line) {
+  const int16_t value = *(int16_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  onDrawIntMenu(menuitem, line, value);
+}
+
+void onDrawPInt8Menu(MenuItemClass* menuitem, int8_t line) {
+  const uint8_t value = *(uint8_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  onDrawIntMenu(menuitem, line, value);
+}
+
+void onDrawPInt32Menu(MenuItemClass* menuitem, int8_t line) {
+  const uint32_t value = *(uint32_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  onDrawIntMenu(menuitem, line, value);
+}
+
+void onDrawFloatMenu(MenuItemClass* menuitem, int8_t line, uint8_t dp, const float value) {
+  onDrawMenuItem(menuitem, line);
+  DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(line), value);
+}
+
+void onDrawPFloatMenu(MenuItemClass* menuitem, int8_t line) {
+  const float value = *(float*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  const int8_t dp = UNITFDIGITS;
+  onDrawFloatMenu(menuitem, line, dp, value);
+}
+
+void onDrawPFloat2Menu(MenuItemClass* menuitem, int8_t line) {
+  const float value = *(float*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  onDrawFloatMenu(menuitem, line, 2, value);
+}
+
+void onDrawChkbMenu(MenuItemClass* menuitem, int8_t line, bool checked) {
+  onDrawMenuItem(menuitem, line);
+  Draw_Chkb_Line(line, checked);
+}
+
+//-----------------------------------------------------------------------------
+// On click functions
+//-----------------------------------------------------------------------------
+
+// Generic onclick event without draw
+//  process: process id HMI destiny
+//  lo: low limit
+//  hi: high limit
+//  dp: decimal places, 0 for integers
+//  val: value / scaled value
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+void SetOnClick(uint8_t process, const int32_t lo, const int32_t hi, uint8_t dp, const int32_t val, void (*Apply)() /*= nullptr*/, void (*LiveUpdate)() /*= nullptr*/) {
+  checkkey = process;
+  MenuData.MinValue = lo;
+  MenuData.MaxValue = hi;
+  MenuData.dp = dp;
+  MenuData.Apply = Apply;
+  MenuData.LiveUpdate = LiveUpdate;
+  MenuData.Value = val;
+  EncoderRate.enabled = true;
+}
+
+// Generic onclick event for integer values
+//  process: process id HMI destiny
+//  lo: scaled low limit
+//  hi: scaled high limit
+//  val: value
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+void SetValueOnClick(uint8_t process, const int32_t lo, const int32_t hi, const int32_t val, void (*Apply)() /*= nullptr*/, void (*LiveUpdate)() /*= nullptr*/) {
+  SetOnClick(process, lo, hi, 0, val, Apply, LiveUpdate);
+  Draw_Menu_IntValue(HMI_data.Selected_Color, CurrentMenu->line(), 4, MenuData.Value);
+}
+
+// Generic onclick event for float values
+//  process: process id HMI destiny
+//  lo: scaled low limit
+//  hi: scaled high limit
+//  val: value
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+void SetValueOnClick(uint8_t process, const float lo, const float hi, uint8_t dp, const float val, void (*Apply)() /*= nullptr*/, void (*LiveUpdate)() /*= nullptr*/) {
+  const int32_t value =  round(val * POW(10, dp));
+  SetOnClick(process, lo * POW(10, dp), hi * POW(10, dp), dp, value, Apply, LiveUpdate);
+  DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Selected_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), val);
+}
+
+// Generic onclick event for integer values
+//  lo: scaled low limit
+//  hi: scaled high limit
+//  val: value
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+void SetIntOnClick(const int32_t lo, const int32_t hi, const int32_t val, void (*Apply)() /*= nullptr*/, void (*LiveUpdate)() /*= nullptr*/) {
+  SetValueOnClick(SetInt, lo, hi, val, Apply, LiveUpdate);
+}
+
+// Generic onclick event for set pointer to 16 bit uinteger values
+//  lo: low limit
+//  hi: high limit
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+void SetPIntOnClick(const int32_t lo, const int32_t hi, void (*Apply)() /*= nullptr*/, void (*LiveUpdate)() /*= nullptr*/) {
+  MenuData.P_Int = (int16_t*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+  const int32_t value = *MenuData.P_Int;
+  SetValueOnClick(SetPInt, lo, hi, value, Apply, LiveUpdate);
+}
+
+// Generic onclick event for float values
+//  process: process id HMI destiny
+//  lo: low limit
+//  hi: high limit
+//  dp: decimal places
+//  val: value
+void SetFloatOnClick(const float lo, const float hi, uint8_t dp, const float val, void (*Apply)() /*= nullptr*/, void (*LiveUpdate)() /*= nullptr*/) {
+  SetValueOnClick(SetFloat, lo, hi, dp, val, Apply, LiveUpdate);
+}
+
+// Generic onclick event for set pointer to float values
+//  lo: low limit
+//  hi: high limit
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+void SetPFloatOnClick(const float lo, const float hi, uint8_t dp, void (*Apply)() /*= nullptr*/, void (*LiveUpdate)() /*= nullptr*/) {
+  MenuData.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+  SetValueOnClick(SetPFloat, lo, hi, dp, *MenuData.P_Float, Apply, LiveUpdate);
+}
+
+// HMI Control functions ======================================================
+
+// Generic menu control using the encoder
+void HMI_Menu() {
+  EncoderState encoder_diffState = get_encoder_state();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (CurrentMenu) {
+    if (encoder_diffState == ENCODER_DIFF_ENTER)
+      CurrentMenu->onClick();
+    else
+      CurrentMenu->onScroll(encoder_diffState == ENCODER_DIFF_CW);
+  }
+}
+
+// Get an integer value using the encoder without draw anything
+//  lo: low limit
+//  hi: high limit
+// Return value:
+//  0 : no change
+//  1 : live change
+//  2 : apply change
+int8_t HMI_GetIntNoDraw(const int32_t lo, const int32_t hi) {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState != ENCODER_DIFF_NO) {
+    if (Apply_Encoder(encoder_diffState, MenuData.Value)) {
+      EncoderRate.enabled = false;
+      checkkey = Menu;
+      return 2;
+    }
+    LIMIT(MenuData.Value, lo, hi);
+    return 1;
+  }
+  return 0;
+}
+
+// Get an integer value using the encoder
+//  lo: low limit
+//  hi: high limit
+// Return value:
+//  0 : no change
+//  1 : live change
+//  2 : apply change
+int8_t HMI_GetInt(const int32_t lo, const int32_t hi) {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState != ENCODER_DIFF_NO) {
+    if (Apply_Encoder(encoder_diffState, MenuData.Value)) {
+      EncoderRate.enabled = false;
+      DWINUI::Draw_Signed_Int(HMI_data.Text_Color, HMI_data.Background_Color, 4 , VALX, MBASE(CurrentMenu->line()) - 1, MenuData.Value);
+      checkkey = Menu;
+      return 2;
+    }
+    LIMIT(MenuData.Value, lo, hi);
+    DWINUI::Draw_Signed_Int(HMI_data.Text_Color, HMI_data.Selected_Color, 4 , VALX, MBASE(CurrentMenu->line()) - 1, MenuData.Value);
+    return 1;
+  }
+  return 0;
+}
+
+// Set an integer using the encoder
+void HMI_SetInt() {
+  int8_t val = HMI_GetInt(MenuData.MinValue, MenuData.MaxValue);
+  switch (val) {
+    case 0: return; break;
+    case 1: if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
+    case 2: if (MenuData.Apply) MenuData.Apply(); break;
+  }
+}
+
+// Set an integer without drawing
+void HMI_SetIntNoDraw() {
+  int8_t val = HMI_GetIntNoDraw(MenuData.MinValue, MenuData.MaxValue);
+  switch (val) {
+    case 0: return; break;
+    case 1: if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
+    case 2: if (MenuData.Apply) MenuData.Apply(); break;
+  }
+}
+
+// Set an integer pointer variable using the encoder
+void HMI_SetPInt() {
+  int8_t val = HMI_GetInt(MenuData.MinValue, MenuData.MaxValue);
+  switch (val) {
+    case 0: return;
+    case 1: if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
+    case 2: *MenuData.P_Int = MenuData.Value; if (MenuData.Apply) MenuData.Apply(); break;
+  }
+}
+
+// Get a scaled float value using the encoder
+//  dp: decimal places
+//  lo: scaled low limit
+//  hi: scaled high limit
+// Return value:
+//  0 : no change
+//  1 : live change
+//  2 : apply change
+int8_t HMI_GetFloat(uint8_t dp, int32_t lo, int32_t hi) {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState != ENCODER_DIFF_NO) {
+    if (Apply_Encoder(encoder_diffState, MenuData.Value)) {
+      EncoderRate.enabled = false;
+      DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), MenuData.Value / POW(10, dp));
+      checkkey = Menu;
+      return 2;
+    }
+    LIMIT(MenuData.Value, lo, hi);
+    DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Selected_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), MenuData.Value / POW(10, dp));
+    return 1;
+  }
+  return 0;
+}
+
+// Set a scaled float using the encoder
+void HMI_SetFloat() {
+  const int8_t val = HMI_GetFloat(MenuData.dp, MenuData.MinValue, MenuData.MaxValue);
+  switch (val) {
+    case 0: return;
+    case 1: if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
+    case 2: if (MenuData.Apply) MenuData.Apply(); break;
+  }
+}
+
+// Set a scaled float pointer variable using the encoder
+void HMI_SetPFloat() {
+  const int8_t val = HMI_GetFloat(MenuData.dp, MenuData.MinValue, MenuData.MaxValue);
+  switch (val) {
+    case 0: return;
+    case 1: if (MenuData.LiveUpdate) MenuData.LiveUpdate(); break;
+    case 2: *MenuData.P_Float = MenuData.Value / POW(10, MenuData.dp); if (MenuData.Apply) MenuData.Apply(); break;
+  }
+}
+
+#endif // DWIN_LCD_PROUI
