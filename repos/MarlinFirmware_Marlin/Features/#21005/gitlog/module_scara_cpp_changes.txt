commit afc2dd6cab2c50ddca1506350a8845b82a4ffce7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 25 22:09:06 2024 -0600

    üé® Misc. cleanup 25-01

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 9c149670e9..0f00ab5643 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -229,9 +229,7 @@ float segments_per_second = DEFAULT_SEGMENTS_PER_SECOND;
     // Move all carriages together linearly until an endstop is hit.
     //do_blocking_move_to_xy_z(pos, mlz, homing_feedrate(Z_AXIS));
 
-    current_position.x = 0 ;
-    current_position.y = 0 ;
-    current_position.z = max_length(Z_AXIS) ;
+    current_position.set(0, 0, max_length(Z_AXIS));
     line_to_current_position(homing_feedrate(Z_AXIS));
     planner.synchronize();
 

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 4c42ace884..9c149670e9 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -39,7 +39,7 @@
 
 float segments_per_second = DEFAULT_SEGMENTS_PER_SECOND;
 
-#if EITHER(MORGAN_SCARA, MP_SCARA)
+#if ANY(MORGAN_SCARA, MP_SCARA)
 
   static constexpr xy_pos_t scara_offset = { SCARA_OFFSET_X, SCARA_OFFSET_Y };
 

commit 74474c8a818745f1324aa5e22e59c361b4dff609
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Nov 26 19:21:47 2022 +1300

    üîß Fix TPARA (‚Ä¶SCARA, DELTA) settings (#25016)

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index bc42b85fbe..4c42ace884 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -37,7 +37,7 @@
   #include "../MarlinCore.h"
 #endif
 
-float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SEGMENTS_PER_SECOND);
+float segments_per_second = DEFAULT_SEGMENTS_PER_SECOND;
 
 #if EITHER(MORGAN_SCARA, MP_SCARA)
 

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 2527292e16..bc42b85fbe 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -254,7 +254,7 @@ float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SE
     // Do this here all at once for Delta, because
     // XYZ isn't ABC. Applying this per-tower would
     // give the impression that they are the same.
-    LOOP_LINEAR_AXES(i) set_axis_is_at_home((AxisEnum)i);
+    LOOP_NUM_AXES(i) set_axis_is_at_home((AxisEnum)i);
 
     sync_plan_position();
   }

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 07f714a997..2527292e16 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -58,7 +58,7 @@ float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SE
     cartes.y = a_sin + b_sin + scara_offset.y;  // phi
 
     /*
-      DEBUG_ECHOLNPAIR(
+      DEBUG_ECHOLNPGM(
         "SCARA FK Angle a=", a,
         " b=", b,
         " a_sin=", a_sin,
@@ -66,7 +66,7 @@ float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SE
         " b_sin=", b_sin,
         " b_cos=", b_cos
       );
-      DEBUG_ECHOLNPAIR(" cartes (X,Y) = "(cartes.x, ", ", cartes.y, ")");
+      DEBUG_ECHOLNPGM(" cartes (X,Y) = "(cartes.x, ", ", cartes.y, ")");
     //*/
   }
 
@@ -80,13 +80,13 @@ float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SE
     else {
       // MORGAN_SCARA uses a Cartesian XY home position
       xyz_pos_t homeposition = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
-      //DEBUG_ECHOLNPAIR_P(PSTR("homeposition X"), homeposition.x, SP_Y_LBL, homeposition.y);
+      //DEBUG_ECHOLNPGM_P(PSTR("homeposition X"), homeposition.x, SP_Y_LBL, homeposition.y);
 
       delta = homeposition;
       forward_kinematics(delta.a, delta.b);
       current_position[axis] = cartes[axis];
 
-      //DEBUG_ECHOLNPAIR_P(PSTR("Cartesian X"), current_position.x, SP_Y_LBL, current_position.y);
+      //DEBUG_ECHOLNPGM_P(PSTR("Cartesian X"), current_position.x, SP_Y_LBL, current_position.y);
       update_software_endstops(axis);
     }
   }
@@ -132,7 +132,7 @@ float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SE
     /*
       DEBUG_POS("SCARA IK", raw);
       DEBUG_POS("SCARA IK", delta);
-      DEBUG_ECHOLNPAIR("  SCARA (x,y) ", sx, ",", sy, " C2=", C2, " S2=", S2, " Theta=", THETA, " Psi=", PSI);
+      DEBUG_ECHOLNPGM("  SCARA (x,y) ", sx, ",", sy, " C2=", C2, " S2=", S2, " Theta=", THETA, " Psi=", PSI);
     //*/
   }
 
@@ -150,13 +150,13 @@ float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SE
         #define SCARA_OFFSET_THETA2 131 // degrees
       #endif
       ab_float_t homeposition = { SCARA_OFFSET_THETA1, SCARA_OFFSET_THETA2 };
-      //DEBUG_ECHOLNPAIR("homeposition A:", homeposition.a, " B:", homeposition.b);
+      //DEBUG_ECHOLNPGM("homeposition A:", homeposition.a, " B:", homeposition.b);
 
       inverse_kinematics(homeposition);
       forward_kinematics(delta.a, delta.b);
       current_position[axis] = cartes[axis];
 
-      //DEBUG_ECHOLNPAIR_P(PSTR("Cartesian X"), current_position.x, SP_Y_LBL, current_position.y);
+      //DEBUG_ECHOLNPGM_P(PSTR("Cartesian X"), current_position.x, SP_Y_LBL, current_position.y);
       update_software_endstops(axis);
     }
   }
@@ -172,7 +172,7 @@ float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SE
     /*
       DEBUG_POS("SCARA IK", raw);
       DEBUG_POS("SCARA IK", delta);
-      SERIAL_ECHOLNPAIR("  SCARA (x,y) ", x, ",", y," Theta1=", THETA1, " Theta2=", THETA2);
+      SERIAL_ECHOLNPGM("  SCARA (x,y) ", x, ",", y," Theta1=", THETA1, " Theta2=", THETA2);
     //*/
   }
 
@@ -185,13 +185,13 @@ float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SE
       current_position.z = Z_HOME_POS;
     else {
       xyz_pos_t homeposition = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
-      //DEBUG_ECHOLNPAIR_P(PSTR("homeposition X"), homeposition.x, SP_Y_LBL, homeposition.y, SP_Z_LBL, homeposition.z);
+      //DEBUG_ECHOLNPGM_P(PSTR("homeposition X"), homeposition.x, SP_Y_LBL, homeposition.y, SP_Z_LBL, homeposition.z);
 
       inverse_kinematics(homeposition);
       forward_kinematics(delta.a, delta.b, delta.c);
       current_position[axis] = cartes[axis];
 
-      //DEBUG_ECHOLNPAIR_P(PSTR("Cartesian X"), current_position.x, SP_Y_LBL, current_position.y);
+      //DEBUG_ECHOLNPGM_P(PSTR("Cartesian X"), current_position.x, SP_Y_LBL, current_position.y);
       update_software_endstops(axis);
     }
   }
@@ -289,13 +289,13 @@ float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SE
 
     delta.set(DEGREES(THETA), DEGREES(PHI), DEGREES(PSI));
 
-    //SERIAL_ECHOLNPAIR(" SCARA (x,y,z) ", spos.x , ",", spos.y, ",", spos.z, " Rho=", RHO, " Rho2=", RHO2, " Theta=", THETA, " Phi=", PHI, " Psi=", PSI, " Gamma=", GAMMA);
+    //SERIAL_ECHOLNPGM(" SCARA (x,y,z) ", spos.x , ",", spos.y, ",", spos.z, " Rho=", RHO, " Rho2=", RHO2, " Theta=", THETA, " Phi=", PHI, " Psi=", PSI, " Gamma=", GAMMA);
   }
 
 #endif
 
 void scara_report_positions() {
-  SERIAL_ECHOLNPAIR("SCARA Theta:", planner.get_axis_position_degrees(A_AXIS)
+  SERIAL_ECHOLNPGM("SCARA Theta:", planner.get_axis_position_degrees(A_AXIS)
     #if ENABLED(AXEL_TPARA)
       , "  Phi:", planner.get_axis_position_degrees(B_AXIS)
       , "  Psi:", planner.get_axis_position_degrees(C_AXIS)

commit 49771c4a9ed2afa1e572f82a24b5edb3de120f78
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 19 00:21:34 2021 -0500

    üé® Flags for homing directions

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index b0544c7791..07f714a997 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -221,10 +221,10 @@ float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SE
       TERN_(Z_SENSORLESS, sensorless_t stealth_states_z = start_sensorless_homing_per_axis(Z_AXIS));
     #endif
 
-    // const int x_axis_home_dir = x_home_dir(active_extruder);
+    //const int x_axis_home_dir = TOOL_X_HOME_DIR(active_extruder);
 
-    // const xy_pos_t pos { max_length(X_AXIS) , max_length(Y_AXIS) };
-    // const float mlz = max_length(X_AXIS),
+    //const xy_pos_t pos { max_length(X_AXIS) , max_length(Y_AXIS) };
+    //const float mlz = max_length(X_AXIS),
 
     // Move all carriages together linearly until an endstop is hit.
     //do_blocking_move_to_xy_z(pos, mlz, homing_feedrate(Z_AXIS));

commit a6e5492b088add3589aeac168136369f21614e60
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:51:19 2021 -0500

    ‚ôªÔ∏è Refactor axis counts and loops

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index e058804c90..b0544c7791 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -254,7 +254,7 @@ float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SE
     // Do this here all at once for Delta, because
     // XYZ isn't ABC. Applying this per-tower would
     // give the impression that they are the same.
-    LOOP_XYZ(i) set_axis_is_at_home((AxisEnum)i);
+    LOOP_LINEAR_AXES(i) set_axis_is_at_home((AxisEnum)i);
 
     sync_plan_position();
   }

commit 1595fdb54b1f10f2e3e01393d6b7aceb09f96b6d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 13 23:23:06 2021 -0500

    Use sq

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index cc177f76c2..e058804c90 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -204,7 +204,7 @@ float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SE
                 y = r  * sin(RADIANS(a)),
                 rho2 = L1_2 + L2_2 - 2.0f * L1 * L2 * cos(RADIANS(w));
 
-    cartes = robot_offset + xyz_pos_t({ x, y, SQRT(rho2 - x * x - y * y) });
+    cartes = robot_offset + xyz_pos_t({ x, y, SQRT(rho2 - sq(x) - sq(y)) });
   }
 
   // Home YZ together, then X (or all at once). Based on quick_home_xy & home_delta

commit 1a2cbe100c279b0dd12a70f5e9179a6f9b555e32
Author: Ramiro Polla <ramiropolla@users.noreply.github.com>
Date:   Fri Apr 9 04:03:34 2021 +0200

    Macros to eliminate 'f + 0.0' (#21568)

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index d02136039a..cc177f76c2 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -51,8 +51,8 @@ float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SE
   void forward_kinematics(const_float_t a, const_float_t b) {
     const float a_sin = sin(RADIANS(a)) * L1,
                 a_cos = cos(RADIANS(a)) * L1,
-                b_sin = sin(RADIANS(b + TERN0(MP_SCARA, a))) * L2,
-                b_cos = cos(RADIANS(b + TERN0(MP_SCARA, a))) * L2;
+                b_sin = sin(RADIANS(SUM_TERN(MP_SCARA, b, a))) * L2,
+                b_cos = cos(RADIANS(SUM_TERN(MP_SCARA, b, a))) * L2;
 
     cartes.x = a_cos + b_cos + scara_offset.x;  // theta
     cartes.y = a_sin + b_sin + scara_offset.y;  // phi
@@ -127,7 +127,7 @@ float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SE
     // Angle of Arm2
     PSI = ATAN2(S2, C2);
 
-    delta.set(DEGREES(THETA), DEGREES(PSI + TERN0(MORGAN_SCARA, THETA)), raw.z);
+    delta.set(DEGREES(THETA), DEGREES(SUM_TERN(MORGAN_SCARA, PSI, THETA)), raw.z);
 
     /*
       DEBUG_POS("SCARA IK", raw);

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 1767e230c1..d02136039a 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -48,7 +48,7 @@ float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SE
    * Maths and first version by QHARLEY.
    * Integrated into Marlin and slightly restructured by Joachim Cerny.
    */
-  void forward_kinematics(const float &a, const float &b) {
+  void forward_kinematics(const_float_t a, const_float_t b) {
     const float a_sin = sin(RADIANS(a)) * L1,
                 a_cos = cos(RADIANS(a)) * L1,
                 b_sin = sin(RADIANS(b + TERN0(MP_SCARA, a))) * L2,
@@ -197,7 +197,7 @@ float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SE
   }
 
   // Convert ABC inputs in degrees to XYZ outputs in mm
-  void forward_kinematics(const float &a, const float &b, const float &c) {
+  void forward_kinematics(const_float_t a, const_float_t b, const_float_t c) {
     const float w = c - b,
                 r = L1 * cos(RADIANS(b)) + L2 * sin(RADIANS(w - (90 - b))),
                 x = r  * cos(RADIANS(a)),

commit a0d312396adb089d31b1d4c1379d86dcd5b734ee
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Fri Mar 5 00:34:38 2021 +0100

    Followup to MP_SCARA/TPARA patches (#21248)

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 7586b8136f..1767e230c1 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -37,46 +37,7 @@
   #include "../MarlinCore.h"
 #endif
 
-float delta_segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SEGMENTS_PER_SECOND);
-
-void scara_set_axis_is_at_home(const AxisEnum axis) {
-  if (axis == Z_AXIS)
-    current_position.z = Z_HOME_POS;
-  else {
-    #if ENABLED(MORGAN_SCARA)
-      // MORGAN_SCARA uses arm angles for AB home position
-      ab_float_t homeposition = { SCARA_OFFSET_THETA1, SCARA_OFFSET_THETA2 };
-      //DEBUG_ECHOLNPAIR("homeposition A:", homeposition.a, " B:", homeposition.b);
-    #elif ENABLED(MP_SCARA)
-      // MP_SCARA uses a Cartesian XY home position
-      xyz_pos_t homeposition = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
-      //DEBUG_ECHOPGM("homeposition");
-      //DEBUG_ECHOLNPAIR_P(SP_X_LBL, homeposition.x, SP_Y_LBL, homeposition.y);
-    #elif ENABLED(AXEL_TPARA)
-      xyz_pos_t homeposition = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
-      //DEBUG_ECHOPGM("homeposition");
-      //DEBUG_ECHOLNPAIR_P(SP_X_LBL, homeposition.x, SP_Y_LBL, homeposition.y, SP_Z_LBL, homeposition.z);
-    #endif
-
-    #if ENABLED(MORGAN_SCARA)
-      delta = homeposition;
-    #else
-      inverse_kinematics(homeposition);
-    #endif
-
-    #if EITHER(MORGAN_SCARA, MP_SCARA)
-      forward_kinematics(delta.a, delta.b);
-    #elif ENABLED(AXEL_TPARA)
-      forward_kinematics(delta.a, delta.b, delta.c);
-    #endif
-
-    current_position[axis] = cartes[axis];
-
-    //DEBUG_ECHOPGM("Cartesian");
-    //DEBUG_ECHOLNPAIR_P(SP_X_LBL, current_position.x, SP_Y_LBL, current_position.y);
-    update_software_endstops(axis);
-  }
-}
+float segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SEGMENTS_PER_SECOND);
 
 #if EITHER(MORGAN_SCARA, MP_SCARA)
 
@@ -109,6 +70,27 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
     //*/
   }
 
+#endif
+
+#if ENABLED(MORGAN_SCARA)
+
+  void scara_set_axis_is_at_home(const AxisEnum axis) {
+    if (axis == Z_AXIS)
+      current_position.z = Z_HOME_POS;
+    else {
+      // MORGAN_SCARA uses a Cartesian XY home position
+      xyz_pos_t homeposition = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
+      //DEBUG_ECHOLNPAIR_P(PSTR("homeposition X"), homeposition.x, SP_Y_LBL, homeposition.y);
+
+      delta = homeposition;
+      forward_kinematics(delta.a, delta.b);
+      current_position[axis] = cartes[axis];
+
+      //DEBUG_ECHOLNPAIR_P(PSTR("Cartesian X"), current_position.x, SP_Y_LBL, current_position.y);
+      update_software_endstops(axis);
+    }
+  }
+
   /**
    * Morgan SCARA Inverse Kinematics. Results are stored in 'delta'.
    *
@@ -156,6 +138,29 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
 
 #elif ENABLED(MP_SCARA)
 
+  void scara_set_axis_is_at_home(const AxisEnum axis) {
+    if (axis == Z_AXIS)
+      current_position.z = Z_HOME_POS;
+    else {
+      // MP_SCARA uses arm angles for AB home position
+      #ifndef SCARA_OFFSET_THETA1
+        #define SCARA_OFFSET_THETA1  12 // degrees
+      #endif
+      #ifndef SCARA_OFFSET_THETA2
+        #define SCARA_OFFSET_THETA2 131 // degrees
+      #endif
+      ab_float_t homeposition = { SCARA_OFFSET_THETA1, SCARA_OFFSET_THETA2 };
+      //DEBUG_ECHOLNPAIR("homeposition A:", homeposition.a, " B:", homeposition.b);
+
+      inverse_kinematics(homeposition);
+      forward_kinematics(delta.a, delta.b);
+      current_position[axis] = cartes[axis];
+
+      //DEBUG_ECHOLNPAIR_P(PSTR("Cartesian X"), current_position.x, SP_Y_LBL, current_position.y);
+      update_software_endstops(axis);
+    }
+  }
+
   void inverse_kinematics(const xyz_pos_t &raw) {
     const float x = raw.x, y = raw.y, c = HYPOT(x, y),
                 THETA3 = ATAN2(y, x),
@@ -175,6 +180,22 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
 
   static constexpr xyz_pos_t robot_offset = { TPARA_OFFSET_X, TPARA_OFFSET_Y, TPARA_OFFSET_Z };
 
+  void scara_set_axis_is_at_home(const AxisEnum axis) {
+    if (axis == Z_AXIS)
+      current_position.z = Z_HOME_POS;
+    else {
+      xyz_pos_t homeposition = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
+      //DEBUG_ECHOLNPAIR_P(PSTR("homeposition X"), homeposition.x, SP_Y_LBL, homeposition.y, SP_Z_LBL, homeposition.z);
+
+      inverse_kinematics(homeposition);
+      forward_kinematics(delta.a, delta.b, delta.c);
+      current_position[axis] = cartes[axis];
+
+      //DEBUG_ECHOLNPAIR_P(PSTR("Cartesian X"), current_position.x, SP_Y_LBL, current_position.y);
+      update_software_endstops(axis);
+    }
+  }
+
   // Convert ABC inputs in degrees to XYZ outputs in mm
   void forward_kinematics(const float &a, const float &b, const float &c) {
     const float w = c - b,

commit dd388aedfda25796c86b532605b26b1e598ce410
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 3 17:57:24 2021 -0600

    TPARA followup

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index a8a3acf0f8..7586b8136f 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -33,10 +33,7 @@
 #include "planner.h"
 
 #if ENABLED(AXEL_TPARA)
-  // For homing, as in delta
-  #include "planner.h"
   #include "endstops.h"
-  #include "../lcd/marlinui.h"
   #include "../MarlinCore.h"
 #endif
 
@@ -46,30 +43,35 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
   if (axis == Z_AXIS)
     current_position.z = Z_HOME_POS;
   else {
-    xyz_pos_t homeposition;
-    LOOP_XYZ(i) homeposition[i] = base_home_pos((AxisEnum)i);
     #if ENABLED(MORGAN_SCARA)
       // MORGAN_SCARA uses arm angles for AB home position
+      ab_float_t homeposition = { SCARA_OFFSET_THETA1, SCARA_OFFSET_THETA2 };
       //DEBUG_ECHOLNPAIR("homeposition A:", homeposition.a, " B:", homeposition.b);
-      inverse_kinematics(homeposition);
-      forward_kinematics_SCARA(delta.a, delta.b);
-      current_position[axis] = cartes[axis];
     #elif ENABLED(MP_SCARA)
       // MP_SCARA uses a Cartesian XY home position
+      xyz_pos_t homeposition = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
       //DEBUG_ECHOPGM("homeposition");
       //DEBUG_ECHOLNPAIR_P(SP_X_LBL, homeposition.x, SP_Y_LBL, homeposition.y);
-      delta.a = SCARA_OFFSET_THETA1;
-      delta.b = SCARA_OFFSET_THETA2;
-      forward_kinematics_SCARA(delta.a, delta.b);
-      current_position[axis] = cartes[axis];
     #elif ENABLED(AXEL_TPARA)
+      xyz_pos_t homeposition = { X_HOME_POS, Y_HOME_POS, Z_HOME_POS };
       //DEBUG_ECHOPGM("homeposition");
       //DEBUG_ECHOLNPAIR_P(SP_X_LBL, homeposition.x, SP_Y_LBL, homeposition.y, SP_Z_LBL, homeposition.z);
+    #endif
+
+    #if ENABLED(MORGAN_SCARA)
+      delta = homeposition;
+    #else
       inverse_kinematics(homeposition);
-      forward_kinematics_TPARA(delta.a, delta.b, delta.c);
-      current_position[axis] = cartes[axis];
     #endif
 
+    #if EITHER(MORGAN_SCARA, MP_SCARA)
+      forward_kinematics(delta.a, delta.b);
+    #elif ENABLED(AXEL_TPARA)
+      forward_kinematics(delta.a, delta.b, delta.c);
+    #endif
+
+    current_position[axis] = cartes[axis];
+
     //DEBUG_ECHOPGM("Cartesian");
     //DEBUG_ECHOLNPAIR_P(SP_X_LBL, current_position.x, SP_Y_LBL, current_position.y);
     update_software_endstops(axis);
@@ -85,7 +87,7 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
    * Maths and first version by QHARLEY.
    * Integrated into Marlin and slightly restructured by Joachim Cerny.
    */
-  void forward_kinematics_SCARA(const float &a, const float &b) {
+  void forward_kinematics(const float &a, const float &b) {
     const float a_sin = sin(RADIANS(a)) * L1,
                 a_cos = cos(RADIANS(a)) * L1,
                 b_sin = sin(RADIANS(b + TERN0(MP_SCARA, a))) * L2,
@@ -174,7 +176,7 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
   static constexpr xyz_pos_t robot_offset = { TPARA_OFFSET_X, TPARA_OFFSET_Y, TPARA_OFFSET_Z };
 
   // Convert ABC inputs in degrees to XYZ outputs in mm
-  void forward_kinematics_TPARA(const float &a, const float &b, const float &c) {
+  void forward_kinematics(const float &a, const float &b, const float &c) {
     const float w = c - b,
                 r = L1 * cos(RADIANS(b)) + L2 * sin(RADIANS(w - (90 - b))),
                 x = r  * cos(RADIANS(a)),
@@ -227,7 +229,6 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
     homeaxis(C_AXIS);
     homeaxis(B_AXIS);
 
-
     // Set all carriages to their home positions
     // Do this here all at once for Delta, because
     // XYZ isn't ABC. Applying this per-tower would

commit a46e0257252bcd50f4c7acb04215f3ad2a92047c
Author: Axel <ansepulveda@uc.cl>
Date:   Wed Mar 3 20:46:32 2021 -0300

    TPARA - 3DOF robot arm IK (#21005)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 565a502d5b..a8a3acf0f8 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -32,26 +32,29 @@
 #include "motion.h"
 #include "planner.h"
 
-float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND;
+#if ENABLED(AXEL_TPARA)
+  // For homing, as in delta
+  #include "planner.h"
+  #include "endstops.h"
+  #include "../lcd/marlinui.h"
+  #include "../MarlinCore.h"
+#endif
+
+float delta_segments_per_second = TERN(AXEL_TPARA, TPARA_SEGMENTS_PER_SECOND, SCARA_SEGMENTS_PER_SECOND);
 
 void scara_set_axis_is_at_home(const AxisEnum axis) {
   if (axis == Z_AXIS)
     current_position.z = Z_HOME_POS;
   else {
-
-    /**
-     * SCARA homes XY at the same time
-     */
     xyz_pos_t homeposition;
     LOOP_XYZ(i) homeposition[i] = base_home_pos((AxisEnum)i);
-
     #if ENABLED(MORGAN_SCARA)
       // MORGAN_SCARA uses arm angles for AB home position
       //DEBUG_ECHOLNPAIR("homeposition A:", homeposition.a, " B:", homeposition.b);
       inverse_kinematics(homeposition);
       forward_kinematics_SCARA(delta.a, delta.b);
       current_position[axis] = cartes[axis];
-    #else
+    #elif ENABLED(MP_SCARA)
       // MP_SCARA uses a Cartesian XY home position
       //DEBUG_ECHOPGM("homeposition");
       //DEBUG_ECHOLNPAIR_P(SP_X_LBL, homeposition.x, SP_Y_LBL, homeposition.y);
@@ -59,6 +62,12 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
       delta.b = SCARA_OFFSET_THETA2;
       forward_kinematics_SCARA(delta.a, delta.b);
       current_position[axis] = cartes[axis];
+    #elif ENABLED(AXEL_TPARA)
+      //DEBUG_ECHOPGM("homeposition");
+      //DEBUG_ECHOLNPAIR_P(SP_X_LBL, homeposition.x, SP_Y_LBL, homeposition.y, SP_Z_LBL, homeposition.z);
+      inverse_kinematics(homeposition);
+      forward_kinematics_TPARA(delta.a, delta.b, delta.c);
+      current_position[axis] = cartes[axis];
     #endif
 
     //DEBUG_ECHOPGM("Cartesian");
@@ -67,85 +76,210 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
   }
 }
 
-static constexpr xy_pos_t scara_offset = { SCARA_OFFSET_X, SCARA_OFFSET_Y };
+#if EITHER(MORGAN_SCARA, MP_SCARA)
 
-/**
- * Morgan SCARA Forward Kinematics. Results in 'cartes'.
- * Maths and first version by QHARLEY.
- * Integrated into Marlin and slightly restructured by Joachim Cerny.
- */
-void forward_kinematics_SCARA(const float &a, const float &b) {
-
-  const float a_sin = sin(RADIANS(a)) * L1,
-              a_cos = cos(RADIANS(a)) * L1,
-              b_sin = sin(RADIANS(b + TERN0(MP_SCARA, a))) * L2,
-              b_cos = cos(RADIANS(b + TERN0(MP_SCARA, a))) * L2;
-
-  cartes.set(a_cos + b_cos + scara_offset.x,  // theta
-             a_sin + b_sin + scara_offset.y); // phi
-
-  /*
-    DEBUG_ECHOLNPAIR(
-      "SCARA FK Angle a=", a,
-      " b=", b,
-      " a_sin=", a_sin,
-      " a_cos=", a_cos,
-      " b_sin=", b_sin,
-      " b_cos=", b_cos
-    );
-    DEBUG_ECHOLNPAIR(" cartes (X,Y) = "(cartes.x, ", ", cartes.y, ")");
-  //*/
-}
+  static constexpr xy_pos_t scara_offset = { SCARA_OFFSET_X, SCARA_OFFSET_Y };
 
-/**
- * SCARA Inverse Kinematics. Results in 'delta'.
- *
- * See https://reprap.org/forum/read.php?185,283327
- *
- * Maths and first version by QHARLEY.
- * Integrated into Marlin and slightly restructured by Joachim Cerny.
- */
-void inverse_kinematics(const xyz_pos_t &raw) {
-  float C2, S2, SK1, SK2, THETA, PSI;
+  /**
+   * Morgan SCARA Forward Kinematics. Results in 'cartes'.
+   * Maths and first version by QHARLEY.
+   * Integrated into Marlin and slightly restructured by Joachim Cerny.
+   */
+  void forward_kinematics_SCARA(const float &a, const float &b) {
+    const float a_sin = sin(RADIANS(a)) * L1,
+                a_cos = cos(RADIANS(a)) * L1,
+                b_sin = sin(RADIANS(b + TERN0(MP_SCARA, a))) * L2,
+                b_cos = cos(RADIANS(b + TERN0(MP_SCARA, a))) * L2;
 
-  // Translate SCARA to standard XY with scaling factor
-  const xy_pos_t spos = raw - scara_offset;
+    cartes.x = a_cos + b_cos + scara_offset.x;  // theta
+    cartes.y = a_sin + b_sin + scara_offset.y;  // phi
 
-  const float H2 = HYPOT2(spos.x, spos.y);
-  if (L1 == L2)
-    C2 = H2 / L1_2_2 - 1;
-  else
-    C2 = (H2 - (L1_2 + L2_2)) / (2.0f * L1 * L2);
+    /*
+      DEBUG_ECHOLNPAIR(
+        "SCARA FK Angle a=", a,
+        " b=", b,
+        " a_sin=", a_sin,
+        " a_cos=", a_cos,
+        " b_sin=", b_sin,
+        " b_cos=", b_cos
+      );
+      DEBUG_ECHOLNPAIR(" cartes (X,Y) = "(cartes.x, ", ", cartes.y, ")");
+    //*/
+  }
 
-  LIMIT(C2, -1, 1);
+  /**
+   * Morgan SCARA Inverse Kinematics. Results are stored in 'delta'.
+   *
+   * See https://reprap.org/forum/read.php?185,283327
+   *
+   * Maths and first version by QHARLEY.
+   * Integrated into Marlin and slightly restructured by Joachim Cerny.
+   */
+  void inverse_kinematics(const xyz_pos_t &raw) {
+    float C2, S2, SK1, SK2, THETA, PSI;
 
-  S2 = SQRT(1.0f - sq(C2));
+    // Translate SCARA to standard XY with scaling factor
+    const xy_pos_t spos = raw - scara_offset;
 
-  // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
-  SK1 = L1 + L2 * C2;
+    const float H2 = HYPOT2(spos.x, spos.y);
+    if (L1 == L2)
+      C2 = H2 / L1_2_2 - 1;
+    else
+      C2 = (H2 - (L1_2 + L2_2)) / (2.0f * L1 * L2);
 
-  // Rotated Arm2 gives the distance from Arm1 to Arm2
-  SK2 = L2 * S2;
+    LIMIT(C2, -1, 1);
 
-  // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
-  THETA = ATAN2(SK1, SK2) - ATAN2(spos.x, spos.y);
+    S2 = SQRT(1.0f - sq(C2));
 
-  // Angle of Arm2
-  PSI = ATAN2(S2, C2);
+    // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
+    SK1 = L1 + L2 * C2;
 
-  delta.set(DEGREES(THETA), DEGREES(PSI + TERN0(MORGAN_SCARA, THETA)), raw.z);
+    // Rotated Arm2 gives the distance from Arm1 to Arm2
+    SK2 = L2 * S2;
 
-  /*
-    DEBUG_POS("SCARA IK", raw);
-    DEBUG_POS("SCARA IK", delta);
-    DEBUG_ECHOLNPAIR("  SCARA (x,y) ", sx, ",", sy, " C2=", C2, " S2=", S2, " Theta=", THETA, " Psi=", PSI);
-  //*/
-}
+    // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
+    THETA = ATAN2(SK1, SK2) - ATAN2(spos.x, spos.y);
+
+    // Angle of Arm2
+    PSI = ATAN2(S2, C2);
+
+    delta.set(DEGREES(THETA), DEGREES(PSI + TERN0(MORGAN_SCARA, THETA)), raw.z);
+
+    /*
+      DEBUG_POS("SCARA IK", raw);
+      DEBUG_POS("SCARA IK", delta);
+      DEBUG_ECHOLNPAIR("  SCARA (x,y) ", sx, ",", sy, " C2=", C2, " S2=", S2, " Theta=", THETA, " Psi=", PSI);
+    //*/
+  }
+
+#elif ENABLED(MP_SCARA)
+
+  void inverse_kinematics(const xyz_pos_t &raw) {
+    const float x = raw.x, y = raw.y, c = HYPOT(x, y),
+                THETA3 = ATAN2(y, x),
+                THETA1 = THETA3 + ACOS((sq(c) + sq(L1) - sq(L2)) / (2.0f * c * L1)),
+                THETA2 = THETA3 - ACOS((sq(c) + sq(L2) - sq(L1)) / (2.0f * c * L2));
+
+    delta.set(DEGREES(THETA1), DEGREES(THETA2), raw.z);
+
+    /*
+      DEBUG_POS("SCARA IK", raw);
+      DEBUG_POS("SCARA IK", delta);
+      SERIAL_ECHOLNPAIR("  SCARA (x,y) ", x, ",", y," Theta1=", THETA1, " Theta2=", THETA2);
+    //*/
+  }
+
+#elif ENABLED(AXEL_TPARA)
+
+  static constexpr xyz_pos_t robot_offset = { TPARA_OFFSET_X, TPARA_OFFSET_Y, TPARA_OFFSET_Z };
+
+  // Convert ABC inputs in degrees to XYZ outputs in mm
+  void forward_kinematics_TPARA(const float &a, const float &b, const float &c) {
+    const float w = c - b,
+                r = L1 * cos(RADIANS(b)) + L2 * sin(RADIANS(w - (90 - b))),
+                x = r  * cos(RADIANS(a)),
+                y = r  * sin(RADIANS(a)),
+                rho2 = L1_2 + L2_2 - 2.0f * L1 * L2 * cos(RADIANS(w));
+
+    cartes = robot_offset + xyz_pos_t({ x, y, SQRT(rho2 - x * x - y * y) });
+  }
+
+  // Home YZ together, then X (or all at once). Based on quick_home_xy & home_delta
+  void home_TPARA() {
+    // Init the current position of all carriages to 0,0,0
+    current_position.reset();
+    destination.reset();
+    sync_plan_position();
+
+    // Disable stealthChop if used. Enable diag1 pin on driver.
+    #if ENABLED(SENSORLESS_HOMING)
+      TERN_(X_SENSORLESS, sensorless_t stealth_states_x = start_sensorless_homing_per_axis(X_AXIS));
+      TERN_(Y_SENSORLESS, sensorless_t stealth_states_y = start_sensorless_homing_per_axis(Y_AXIS));
+      TERN_(Z_SENSORLESS, sensorless_t stealth_states_z = start_sensorless_homing_per_axis(Z_AXIS));
+    #endif
+
+    // const int x_axis_home_dir = x_home_dir(active_extruder);
+
+    // const xy_pos_t pos { max_length(X_AXIS) , max_length(Y_AXIS) };
+    // const float mlz = max_length(X_AXIS),
+
+    // Move all carriages together linearly until an endstop is hit.
+    //do_blocking_move_to_xy_z(pos, mlz, homing_feedrate(Z_AXIS));
+
+    current_position.x = 0 ;
+    current_position.y = 0 ;
+    current_position.z = max_length(Z_AXIS) ;
+    line_to_current_position(homing_feedrate(Z_AXIS));
+    planner.synchronize();
+
+    // Re-enable stealthChop if used. Disable diag1 pin on driver.
+    #if ENABLED(SENSORLESS_HOMING)
+      TERN_(X_SENSORLESS, end_sensorless_homing_per_axis(X_AXIS, stealth_states_x));
+      TERN_(Y_SENSORLESS, end_sensorless_homing_per_axis(Y_AXIS, stealth_states_y));
+      TERN_(Z_SENSORLESS, end_sensorless_homing_per_axis(Z_AXIS, stealth_states_z));
+    #endif
+
+    endstops.validate_homing_move();
+
+    // At least one motor has reached its endstop.
+    // Now re-home each motor separately.
+    homeaxis(A_AXIS);
+    homeaxis(C_AXIS);
+    homeaxis(B_AXIS);
+
+
+    // Set all carriages to their home positions
+    // Do this here all at once for Delta, because
+    // XYZ isn't ABC. Applying this per-tower would
+    // give the impression that they are the same.
+    LOOP_XYZ(i) set_axis_is_at_home((AxisEnum)i);
+
+    sync_plan_position();
+  }
+
+  void inverse_kinematics(const xyz_pos_t &raw) {
+    const xyz_pos_t spos = raw - robot_offset;
+
+    const float RXY = SQRT(HYPOT2(spos.x, spos.y)),
+                RHO2 = NORMSQ(spos.x, spos.y, spos.z),
+                //RHO = SQRT(RHO2),
+                LSS = L1_2 + L2_2,
+                LM = 2.0f * L1 * L2,
+
+                CG = (LSS - RHO2) / LM,
+                SG = SQRT(1 - POW(CG, 2)), // Method 2
+                K1 = L1 - L2 * CG,
+                K2 = L2 * SG,
+
+                // Angle of Body Joint
+                THETA = ATAN2(spos.y, spos.x),
+
+                // Angle of Elbow Joint
+                //GAMMA = ACOS(CG),
+                GAMMA = ATAN2(SG, CG), // Method 2
+
+                // Angle of Shoulder Joint, elevation angle measured from horizontal (r+)
+                //PHI = asin(spos.z/RHO) + asin(L2 * sin(GAMMA) / RHO),
+                PHI = ATAN2(spos.z, RXY) + ATAN2(K2, K1),   // Method 2
+
+                // Elbow motor angle measured from horizontal, same frame as shoulder  (r+)
+                PSI = PHI + GAMMA;
+
+    delta.set(DEGREES(THETA), DEGREES(PHI), DEGREES(PSI));
+
+    //SERIAL_ECHOLNPAIR(" SCARA (x,y,z) ", spos.x , ",", spos.y, ",", spos.z, " Rho=", RHO, " Rho2=", RHO2, " Theta=", THETA, " Phi=", PHI, " Psi=", PSI, " Gamma=", GAMMA);
+  }
+
+#endif
 
 void scara_report_positions() {
-  SERIAL_ECHOLNPAIR(
-    "SCARA Theta:", planner.get_axis_position_degrees(A_AXIS),
-    "  Psi" TERN_(MORGAN_SCARA, "+Theta") ":", planner.get_axis_position_degrees(B_AXIS)
+  SERIAL_ECHOLNPAIR("SCARA Theta:", planner.get_axis_position_degrees(A_AXIS)
+    #if ENABLED(AXEL_TPARA)
+      , "  Phi:", planner.get_axis_position_degrees(B_AXIS)
+      , "  Psi:", planner.get_axis_position_degrees(C_AXIS)
+    #else
+      , "  Psi" TERN_(MORGAN_SCARA, "+Theta") ":", planner.get_axis_position_degrees(B_AXIS)
+    #endif
   );
   SERIAL_EOL();
 }

commit 65e24f812f2c0d038434fb312fc531d664c123da
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 17 17:04:51 2021 -0600

    Fixes for MP_SCARA (#21113)
    
    Co-Authored-By: svsergo <52426708+svsergo@users.noreply.github.com>

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index e4b2f0b75c..565a502d5b 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -47,19 +47,22 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
 
     #if ENABLED(MORGAN_SCARA)
       // MORGAN_SCARA uses arm angles for AB home position
-      // SERIAL_ECHOLNPAIR("homeposition A:", homeposition.a, " B:", homeposition.b);
+      //DEBUG_ECHOLNPAIR("homeposition A:", homeposition.a, " B:", homeposition.b);
       inverse_kinematics(homeposition);
       forward_kinematics_SCARA(delta.a, delta.b);
       current_position[axis] = cartes[axis];
     #else
       // MP_SCARA uses a Cartesian XY home position
-      // SERIAL_ECHOPGM("homeposition");
-      // SERIAL_ECHOLNPAIR_P(SP_X_LBL, homeposition.x, SP_Y_LBL, homeposition.y);
-      current_position[axis] = homeposition[axis];
+      //DEBUG_ECHOPGM("homeposition");
+      //DEBUG_ECHOLNPAIR_P(SP_X_LBL, homeposition.x, SP_Y_LBL, homeposition.y);
+      delta.a = SCARA_OFFSET_THETA1;
+      delta.b = SCARA_OFFSET_THETA2;
+      forward_kinematics_SCARA(delta.a, delta.b);
+      current_position[axis] = cartes[axis];
     #endif
 
-    // SERIAL_ECHOPGM("Cartesian");
-    // SERIAL_ECHOLNPAIR_P(SP_X_LBL, current_position.x, SP_Y_LBL, current_position.y);
+    //DEBUG_ECHOPGM("Cartesian");
+    //DEBUG_ECHOLNPAIR_P(SP_X_LBL, current_position.x, SP_Y_LBL, current_position.y);
     update_software_endstops(axis);
   }
 }
@@ -75,14 +78,14 @@ void forward_kinematics_SCARA(const float &a, const float &b) {
 
   const float a_sin = sin(RADIANS(a)) * L1,
               a_cos = cos(RADIANS(a)) * L1,
-              b_sin = sin(RADIANS(b)) * L2,
-              b_cos = cos(RADIANS(b)) * L2;
+              b_sin = sin(RADIANS(b + TERN0(MP_SCARA, a))) * L2,
+              b_cos = cos(RADIANS(b + TERN0(MP_SCARA, a))) * L2;
 
   cartes.set(a_cos + b_cos + scara_offset.x,  // theta
-             a_sin + b_sin + scara_offset.y); // theta+phi
+             a_sin + b_sin + scara_offset.y); // phi
 
   /*
-    SERIAL_ECHOLNPAIR(
+    DEBUG_ECHOLNPAIR(
       "SCARA FK Angle a=", a,
       " b=", b,
       " a_sin=", a_sin,
@@ -90,74 +93,60 @@ void forward_kinematics_SCARA(const float &a, const float &b) {
       " b_sin=", b_sin,
       " b_cos=", b_cos
     );
-    SERIAL_ECHOLNPAIR(" cartes (X,Y) = "(cartes.x, ", ", cartes.y, ")");
+    DEBUG_ECHOLNPAIR(" cartes (X,Y) = "(cartes.x, ", ", cartes.y, ")");
   //*/
 }
 
+/**
+ * SCARA Inverse Kinematics. Results in 'delta'.
+ *
+ * See https://reprap.org/forum/read.php?185,283327
+ *
+ * Maths and first version by QHARLEY.
+ * Integrated into Marlin and slightly restructured by Joachim Cerny.
+ */
 void inverse_kinematics(const xyz_pos_t &raw) {
+  float C2, S2, SK1, SK2, THETA, PSI;
 
-  #if ENABLED(MORGAN_SCARA)
-    /**
-     * Morgan SCARA Inverse Kinematics. Results in 'delta'.
-     *
-     * See https://reprap.org/forum/read.php?185,283327
-     *
-     * Maths and first version by QHARLEY.
-     * Integrated into Marlin and slightly restructured by Joachim Cerny.
-     */
-    float C2, S2, SK1, SK2, THETA, PSI;
-
-    // Translate SCARA to standard XY with scaling factor
-    const xy_pos_t spos = raw - scara_offset;
-
-    const float H2 = HYPOT2(spos.x, spos.y);
-    if (L1 == L2)
-      C2 = H2 / L1_2_2 - 1;
-    else
-      C2 = (H2 - (L1_2 + L2_2)) / (2.0f * L1 * L2);
-
-    S2 = SQRT(1.0f - sq(C2));
+  // Translate SCARA to standard XY with scaling factor
+  const xy_pos_t spos = raw - scara_offset;
 
-    // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
-    SK1 = L1 + L2 * C2;
+  const float H2 = HYPOT2(spos.x, spos.y);
+  if (L1 == L2)
+    C2 = H2 / L1_2_2 - 1;
+  else
+    C2 = (H2 - (L1_2 + L2_2)) / (2.0f * L1 * L2);
 
-    // Rotated Arm2 gives the distance from Arm1 to Arm2
-    SK2 = L2 * S2;
+  LIMIT(C2, -1, 1);
 
-    // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
-    THETA = ATAN2(SK1, SK2) - ATAN2(spos.x, spos.y);
+  S2 = SQRT(1.0f - sq(C2));
 
-    // Angle of Arm2
-    PSI = ATAN2(S2, C2);
+  // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
+  SK1 = L1 + L2 * C2;
 
-    delta.set(DEGREES(THETA), DEGREES(THETA + PSI), raw.z);
+  // Rotated Arm2 gives the distance from Arm1 to Arm2
+  SK2 = L2 * S2;
 
-    /*
-      DEBUG_POS("SCARA IK", raw);
-      DEBUG_POS("SCARA IK", delta);
-      SERIAL_ECHOLNPAIR("  SCARA (x,y) ", sx, ",", sy, " C2=", C2, " S2=", S2, " Theta=", THETA, " Phi=", PHI);
-    //*/
+  // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
+  THETA = ATAN2(SK1, SK2) - ATAN2(spos.x, spos.y);
 
-  #else // MP_SCARA
+  // Angle of Arm2
+  PSI = ATAN2(S2, C2);
 
-    const float x = raw.x, y = raw.y, c = HYPOT(x, y),
-                THETA3 = ATAN2(y, x),
-                THETA1 = THETA3 + ACOS((sq(c) + sq(L1) - sq(L2)) / (2.0f * c * L1)),
-                THETA2 = THETA3 - ACOS((sq(c) + sq(L2) - sq(L1)) / (2.0f * c * L2));
+  delta.set(DEGREES(THETA), DEGREES(PSI + TERN0(MORGAN_SCARA, THETA)), raw.z);
 
-    delta.set(DEGREES(THETA1), DEGREES(THETA2), raw.z);
-
-    /*
-      DEBUG_POS("SCARA IK", raw);
-      DEBUG_POS("SCARA IK", delta);
-      SERIAL_ECHOLNPAIR("  SCARA (x,y) ", x, ",", y," Theta1=", THETA1, " Theta2=", THETA2);
-    //*/
-
-  #endif // MP_SCARA
+  /*
+    DEBUG_POS("SCARA IK", raw);
+    DEBUG_POS("SCARA IK", delta);
+    DEBUG_ECHOLNPAIR("  SCARA (x,y) ", sx, ",", sy, " C2=", C2, " S2=", S2, " Theta=", THETA, " Psi=", PSI);
+  //*/
 }
 
 void scara_report_positions() {
-  SERIAL_ECHOLNPAIR("SCARA Theta:", planner.get_axis_position_degrees(A_AXIS), "  Psi+Theta:", planner.get_axis_position_degrees(B_AXIS));
+  SERIAL_ECHOLNPAIR(
+    "SCARA Theta:", planner.get_axis_position_degrees(A_AXIS),
+    "  Psi" TERN_(MORGAN_SCARA, "+Theta") ":", planner.get_axis_position_degrees(B_AXIS)
+  );
   SERIAL_EOL();
 }
 

commit d1e20eb29f15c0dc4faa21769251709c455d18b8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jul 23 20:46:11 2020 -0500

    Update links, README, contributing, etc.

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 6c961827c7..e4b2f0b75c 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -100,7 +100,7 @@ void inverse_kinematics(const xyz_pos_t &raw) {
     /**
      * Morgan SCARA Inverse Kinematics. Results in 'delta'.
      *
-     * See http://forums.reprap.org/read.php?185,283327
+     * See https://reprap.org/forum/read.php?185,283327
      *
      * Maths and first version by QHARLEY.
      * Integrated into Marlin and slightly restructured by Joachim Cerny.

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 5fbbfd65a6..6c961827c7 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit 5e9a10dbaeaa885a670af0bd7ef3e7c068f5a7b8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 1 07:36:25 2020 -0600

    Use PSTR for common labels

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index f7eb8d192b..5fbbfd65a6 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -53,11 +53,13 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
       current_position[axis] = cartes[axis];
     #else
       // MP_SCARA uses a Cartesian XY home position
-      // SERIAL_ECHOLNPAIR("homeposition X:", homeposition.x, " Y:", homeposition.y);
+      // SERIAL_ECHOPGM("homeposition");
+      // SERIAL_ECHOLNPAIR_P(SP_X_LBL, homeposition.x, SP_Y_LBL, homeposition.y);
       current_position[axis] = homeposition[axis];
     #endif
 
-    // SERIAL_ECHOLNPAIR("Cartesian X:", current_position.x, " Y:", current_position.y);
+    // SERIAL_ECHOPGM("Cartesian");
+    // SERIAL_ECHOLNPAIR_P(SP_X_LBL, current_position.x, SP_Y_LBL, current_position.y);
     update_software_endstops(axis);
   }
 }

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 3a82ef47fd..f7eb8d192b 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit bbe0ffb2fafad854457390540ca47165e62986b9
Author: BigTreeTech <38851044+bigtreetech@users.noreply.github.com>
Date:   Thu Dec 19 16:41:35 2019 +0800

    BigTreeTech SKR v1.4 support (#16236)

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index de7880e2d3..3a82ef47fd 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -95,7 +95,6 @@ void forward_kinematics_SCARA(const float &a, const float &b) {
 void inverse_kinematics(const xyz_pos_t &raw) {
 
   #if ENABLED(MORGAN_SCARA)
-
     /**
      * Morgan SCARA Inverse Kinematics. Results in 'delta'.
      *

commit 0832a60db377a41c0aa8c6e81d256461b64cf2c4
Author: Vertabreaker <opyrus@hotmail.com>
Date:   Tue Dec 3 07:52:38 2019 -0500

    EXP3D Imprimante Multifonction (#16079)

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 0dc31c3a33..de7880e2d3 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -95,7 +95,7 @@ void forward_kinematics_SCARA(const float &a, const float &b) {
 void inverse_kinematics(const xyz_pos_t &raw) {
 
   #if ENABLED(MORGAN_SCARA)
-  
+
     /**
      * Morgan SCARA Inverse Kinematics. Results in 'delta'.
      *

commit b258cc85bfb5ee95ba61533ba501b7c0fdf370e2
Author: brian park <gouache95@gmail.com>
Date:   Sat Nov 30 23:57:34 2019 +0900

    Mostly Printed SCARA (MPSCARA) support (#15573)

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 768e311812..0dc31c3a33 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -45,19 +45,19 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
     xyz_pos_t homeposition;
     LOOP_XYZ(i) homeposition[i] = base_home_pos((AxisEnum)i);
 
-    // SERIAL_ECHOLNPAIR("homeposition X:", homeposition.x, " Y:", homeposition.y);
-
-    /**
-     * Get Home position SCARA arm angles using inverse kinematics,
-     * and calculate homing offset using forward kinematics
-     */
-    inverse_kinematics(homeposition);
-    forward_kinematics_SCARA(delta.a, delta.b);
-
-    // SERIAL_ECHOLNPAIR("Cartesian X:", cartes.x, " Y:", cartes.y);
-
-    current_position[axis] = cartes[axis];
-
+    #if ENABLED(MORGAN_SCARA)
+      // MORGAN_SCARA uses arm angles for AB home position
+      // SERIAL_ECHOLNPAIR("homeposition A:", homeposition.a, " B:", homeposition.b);
+      inverse_kinematics(homeposition);
+      forward_kinematics_SCARA(delta.a, delta.b);
+      current_position[axis] = cartes[axis];
+    #else
+      // MP_SCARA uses a Cartesian XY home position
+      // SERIAL_ECHOLNPAIR("homeposition X:", homeposition.x, " Y:", homeposition.y);
+      current_position[axis] = homeposition[axis];
+    #endif
+
+    // SERIAL_ECHOLNPAIR("Cartesian X:", current_position.x, " Y:", current_position.y);
     update_software_endstops(axis);
   }
 }
@@ -92,48 +92,67 @@ void forward_kinematics_SCARA(const float &a, const float &b) {
   //*/
 }
 
-/**
- * Morgan SCARA Inverse Kinematics. Results in 'delta'.
- *
- * See http://forums.reprap.org/read.php?185,283327
- *
- * Maths and first version by QHARLEY.
- * Integrated into Marlin and slightly restructured by Joachim Cerny.
- */
 void inverse_kinematics(const xyz_pos_t &raw) {
 
-  float C2, S2, SK1, SK2, THETA, PSI;
+  #if ENABLED(MORGAN_SCARA)
+  
+    /**
+     * Morgan SCARA Inverse Kinematics. Results in 'delta'.
+     *
+     * See http://forums.reprap.org/read.php?185,283327
+     *
+     * Maths and first version by QHARLEY.
+     * Integrated into Marlin and slightly restructured by Joachim Cerny.
+     */
+    float C2, S2, SK1, SK2, THETA, PSI;
 
-  // Translate SCARA to standard XY with scaling factor
-  const xy_pos_t spos = raw - scara_offset;
+    // Translate SCARA to standard XY with scaling factor
+    const xy_pos_t spos = raw - scara_offset;
 
-  const float H2 = HYPOT2(spos.x, spos.y);
-  if (L1 == L2)
-    C2 = H2 / L1_2_2 - 1;
-  else
-    C2 = (H2 - (L1_2 + L2_2)) / (2.0 * L1 * L2);
+    const float H2 = HYPOT2(spos.x, spos.y);
+    if (L1 == L2)
+      C2 = H2 / L1_2_2 - 1;
+    else
+      C2 = (H2 - (L1_2 + L2_2)) / (2.0f * L1 * L2);
 
-  S2 = SQRT(1.0f - sq(C2));
+    S2 = SQRT(1.0f - sq(C2));
 
-  // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
-  SK1 = L1 + L2 * C2;
+    // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
+    SK1 = L1 + L2 * C2;
 
-  // Rotated Arm2 gives the distance from Arm1 to Arm2
-  SK2 = L2 * S2;
+    // Rotated Arm2 gives the distance from Arm1 to Arm2
+    SK2 = L2 * S2;
 
-  // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
-  THETA = ATAN2(SK1, SK2) - ATAN2(spos.x, spos.y);
+    // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
+    THETA = ATAN2(SK1, SK2) - ATAN2(spos.x, spos.y);
 
-  // Angle of Arm2
-  PSI = ATAN2(S2, C2);
+    // Angle of Arm2
+    PSI = ATAN2(S2, C2);
 
-  delta.set(DEGREES(THETA), DEGREES(THETA + PSI), raw.z);
+    delta.set(DEGREES(THETA), DEGREES(THETA + PSI), raw.z);
 
-  /*
-    DEBUG_POS("SCARA IK", raw);
-    DEBUG_POS("SCARA IK", delta);
-    SERIAL_ECHOLNPAIR("  SCARA (x,y) ", sx, ",", sy, " C2=", C2, " S2=", S2, " Theta=", THETA, " Phi=", PHI);
-  //*/
+    /*
+      DEBUG_POS("SCARA IK", raw);
+      DEBUG_POS("SCARA IK", delta);
+      SERIAL_ECHOLNPAIR("  SCARA (x,y) ", sx, ",", sy, " C2=", C2, " S2=", S2, " Theta=", THETA, " Phi=", PHI);
+    //*/
+
+  #else // MP_SCARA
+
+    const float x = raw.x, y = raw.y, c = HYPOT(x, y),
+                THETA3 = ATAN2(y, x),
+                THETA1 = THETA3 + ACOS((sq(c) + sq(L1) - sq(L2)) / (2.0f * c * L1)),
+                THETA2 = THETA3 - ACOS((sq(c) + sq(L2) - sq(L1)) / (2.0f * c * L2));
+
+    delta.set(DEGREES(THETA1), DEGREES(THETA2), raw.z);
+
+    /*
+      DEBUG_POS("SCARA IK", raw);
+      DEBUG_POS("SCARA IK", delta);
+      SERIAL_ECHOLNPAIR("  SCARA (x,y) ", x, ",", y," Theta1=", THETA1, " Theta2=", THETA2);
+    //*/
+
+  #endif // MP_SCARA
 }
 
 void scara_report_positions() {

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index fe98df46bf..768e311812 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -36,25 +36,25 @@ float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND;
 
 void scara_set_axis_is_at_home(const AxisEnum axis) {
   if (axis == Z_AXIS)
-    current_position[Z_AXIS] = Z_HOME_POS;
+    current_position.z = Z_HOME_POS;
   else {
 
     /**
      * SCARA homes XY at the same time
      */
-    float homeposition[XYZ];
+    xyz_pos_t homeposition;
     LOOP_XYZ(i) homeposition[i] = base_home_pos((AxisEnum)i);
 
-    // SERIAL_ECHOLNPAIR("homeposition X:", homeposition[X_AXIS], " Y:", homeposition[Y_AXIS]);
+    // SERIAL_ECHOLNPAIR("homeposition X:", homeposition.x, " Y:", homeposition.y);
 
     /**
      * Get Home position SCARA arm angles using inverse kinematics,
      * and calculate homing offset using forward kinematics
      */
     inverse_kinematics(homeposition);
-    forward_kinematics_SCARA(delta[A_AXIS], delta[B_AXIS]);
+    forward_kinematics_SCARA(delta.a, delta.b);
 
-    // SERIAL_ECHOLNPAIR("Cartesian X:", cartes[X_AXIS], " Y:", cartes[Y_AXIS]);
+    // SERIAL_ECHOLNPAIR("Cartesian X:", cartes.x, " Y:", cartes.y);
 
     current_position[axis] = cartes[axis];
 
@@ -62,8 +62,10 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
   }
 }
 
+static constexpr xy_pos_t scara_offset = { SCARA_OFFSET_X, SCARA_OFFSET_Y };
+
 /**
- * Morgan SCARA Forward Kinematics. Results in cartes[].
+ * Morgan SCARA Forward Kinematics. Results in 'cartes'.
  * Maths and first version by QHARLEY.
  * Integrated into Marlin and slightly restructured by Joachim Cerny.
  */
@@ -74,8 +76,8 @@ void forward_kinematics_SCARA(const float &a, const float &b) {
               b_sin = sin(RADIANS(b)) * L2,
               b_cos = cos(RADIANS(b)) * L2;
 
-  cartes[X_AXIS] = a_cos + b_cos + SCARA_OFFSET_X;  //theta
-  cartes[Y_AXIS] = a_sin + b_sin + SCARA_OFFSET_Y;  //theta+phi
+  cartes.set(a_cos + b_cos + scara_offset.x,  // theta
+             a_sin + b_sin + scara_offset.y); // theta+phi
 
   /*
     SERIAL_ECHOLNPAIR(
@@ -86,31 +88,32 @@ void forward_kinematics_SCARA(const float &a, const float &b) {
       " b_sin=", b_sin,
       " b_cos=", b_cos
     );
-    SERIAL_ECHOLNPAIR(" cartes (X,Y) = "(cartes[X_AXIS], ", ", cartes[Y_AXIS], ")");
+    SERIAL_ECHOLNPAIR(" cartes (X,Y) = "(cartes.x, ", ", cartes.y, ")");
   //*/
 }
 
 /**
- * Morgan SCARA Inverse Kinematics. Results in delta[].
+ * Morgan SCARA Inverse Kinematics. Results in 'delta'.
  *
  * See http://forums.reprap.org/read.php?185,283327
  *
  * Maths and first version by QHARLEY.
  * Integrated into Marlin and slightly restructured by Joachim Cerny.
  */
-void inverse_kinematics(const float (&raw)[XYZ]) {
+void inverse_kinematics(const xyz_pos_t &raw) {
 
-  static float C2, S2, SK1, SK2, THETA, PSI;
+  float C2, S2, SK1, SK2, THETA, PSI;
 
-  float sx = raw[X_AXIS] - SCARA_OFFSET_X,  // Translate SCARA to standard X Y
-        sy = raw[Y_AXIS] - SCARA_OFFSET_Y;  // With scaling factor.
+  // Translate SCARA to standard XY with scaling factor
+  const xy_pos_t spos = raw - scara_offset;
 
+  const float H2 = HYPOT2(spos.x, spos.y);
   if (L1 == L2)
-    C2 = HYPOT2(sx, sy) / L1_2_2 - 1;
+    C2 = H2 / L1_2_2 - 1;
   else
-    C2 = (HYPOT2(sx, sy) - (L1_2 + L2_2)) / (2.0 * L1 * L2);
+    C2 = (H2 - (L1_2 + L2_2)) / (2.0 * L1 * L2);
 
-  S2 = SQRT(1 - sq(C2));
+  S2 = SQRT(1.0f - sq(C2));
 
   // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
   SK1 = L1 + L2 * C2;
@@ -119,14 +122,12 @@ void inverse_kinematics(const float (&raw)[XYZ]) {
   SK2 = L2 * S2;
 
   // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
-  THETA = ATAN2(SK1, SK2) - ATAN2(sx, sy);
+  THETA = ATAN2(SK1, SK2) - ATAN2(spos.x, spos.y);
 
   // Angle of Arm2
   PSI = ATAN2(S2, C2);
 
-  delta[A_AXIS] = DEGREES(THETA);        // theta is support arm angle
-  delta[B_AXIS] = DEGREES(THETA + PSI);  // equal to sub arm angle (inverted motor)
-  delta[C_AXIS] = raw[Z_AXIS];
+  delta.set(DEGREES(THETA), DEGREES(THETA + PSI), raw.z);
 
   /*
     DEBUG_POS("SCARA IK", raw);

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 19b9c7343c..fe98df46bf 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit cfdb38eda4b4d993bac4a0e8600e776429b42b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 5 06:46:19 2019 -0600

    Allow SERIAL_ECHOPAIR to take up to 12 pairs (#13311)

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 75c6f97eb8..19b9c7343c 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -45,8 +45,7 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
     float homeposition[XYZ];
     LOOP_XYZ(i) homeposition[i] = base_home_pos((AxisEnum)i);
 
-    // SERIAL_ECHOPAIR("homeposition X:", homeposition[X_AXIS]);
-    // SERIAL_ECHOLNPAIR(" Y:", homeposition[Y_AXIS]);
+    // SERIAL_ECHOLNPAIR("homeposition X:", homeposition[X_AXIS], " Y:", homeposition[Y_AXIS]);
 
     /**
      * Get Home position SCARA arm angles using inverse kinematics,
@@ -55,8 +54,7 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
     inverse_kinematics(homeposition);
     forward_kinematics_SCARA(delta[A_AXIS], delta[B_AXIS]);
 
-    // SERIAL_ECHOPAIR("Cartesian X:", cartes[X_AXIS]);
-    // SERIAL_ECHOLNPAIR(" Y:", cartes[Y_AXIS]);
+    // SERIAL_ECHOLNPAIR("Cartesian X:", cartes[X_AXIS], " Y:", cartes[Y_AXIS]);
 
     current_position[axis] = cartes[axis];
 
@@ -80,14 +78,15 @@ void forward_kinematics_SCARA(const float &a, const float &b) {
   cartes[Y_AXIS] = a_sin + b_sin + SCARA_OFFSET_Y;  //theta+phi
 
   /*
-    SERIAL_ECHOPAIR("SCARA FK Angle a=", a);
-    SERIAL_ECHOPAIR(" b=", b);
-    SERIAL_ECHOPAIR(" a_sin=", a_sin);
-    SERIAL_ECHOPAIR(" a_cos=", a_cos);
-    SERIAL_ECHOPAIR(" b_sin=", b_sin);
-    SERIAL_ECHOLNPAIR(" b_cos=", b_cos);
-    SERIAL_ECHOPAIR(" cartes[X_AXIS]=", cartes[X_AXIS]);
-    SERIAL_ECHOLNPAIR(" cartes[Y_AXIS]=", cartes[Y_AXIS]);
+    SERIAL_ECHOLNPAIR(
+      "SCARA FK Angle a=", a,
+      " b=", b,
+      " a_sin=", a_sin,
+      " a_cos=", a_cos,
+      " b_sin=", b_sin,
+      " b_cos=", b_cos
+    );
+    SERIAL_ECHOLNPAIR(" cartes (X,Y) = "(cartes[X_AXIS], ", ", cartes[Y_AXIS], ")");
   //*/
 }
 
@@ -132,18 +131,12 @@ void inverse_kinematics(const float (&raw)[XYZ]) {
   /*
     DEBUG_POS("SCARA IK", raw);
     DEBUG_POS("SCARA IK", delta);
-    SERIAL_ECHOPAIR("  SCARA (x,y) ", sx);
-    SERIAL_ECHOPAIR(",", sy);
-    SERIAL_ECHOPAIR(" C2=", C2);
-    SERIAL_ECHOPAIR(" S2=", S2);
-    SERIAL_ECHOPAIR(" Theta=", THETA);
-    SERIAL_ECHOLNPAIR(" Phi=", PHI);
+    SERIAL_ECHOLNPAIR("  SCARA (x,y) ", sx, ",", sy, " C2=", C2, " S2=", S2, " Theta=", THETA, " Phi=", PHI);
   //*/
 }
 
 void scara_report_positions() {
-  SERIAL_ECHOPAIR("SCARA Theta:", planner.get_axis_position_degrees(A_AXIS));
-  SERIAL_ECHOLNPAIR("   Psi+Theta:", planner.get_axis_position_degrees(B_AXIS));
+  SERIAL_ECHOLNPAIR("SCARA Theta:", planner.get_axis_position_degrees(A_AXIS), "  Psi+Theta:", planner.get_axis_position_degrees(B_AXIS));
   SERIAL_EOL();
 }
 

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index febdaaf641..75c6f97eb8 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 8063c44443..febdaaf641 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -142,8 +142,8 @@ void inverse_kinematics(const float (&raw)[XYZ]) {
 }
 
 void scara_report_positions() {
-  SERIAL_PROTOCOLPAIR("SCARA Theta:", planner.get_axis_position_degrees(A_AXIS));
-  SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", planner.get_axis_position_degrees(B_AXIS));
+  SERIAL_ECHOPAIR("SCARA Theta:", planner.get_axis_position_degrees(A_AXIS));
+  SERIAL_ECHOLNPAIR("   Psi+Theta:", planner.get_axis_position_degrees(B_AXIS));
   SERIAL_EOL();
 }
 

commit d1ff22b9830bbb94efea52f4233b2f11ad0a0c4a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 3 03:56:33 2018 -0500

    Revive SCARA's home offset (unimplemented)

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 225e4a25d8..8063c44443 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -60,12 +60,7 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
 
     current_position[axis] = cartes[axis];
 
-    /**
-     * SCARA home positions are based on configuration since the actual
-     * limits are determined by the inverse kinematic transform.
-     */
-    soft_endstop_min[axis] = base_min_pos(axis); // + (cartes[axis] - base_home_pos(axis));
-    soft_endstop_max[axis] = base_max_pos(axis); // + (cartes[axis] - base_home_pos(axis));
+    update_software_endstops(axis);
   }
 }
 

commit c437bb08f12f1c0535cc78a761b49a18f2dc2a12
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Sep 16 22:24:15 2018 -0400

    Overhaul of the planner (#11578)
    
    - Move FWRETRACT to the planner
    - Combine leveling, skew, etc. in a single modifier method
    - Have kinematic and non-kinematic moves call one planner method

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 222bf9cbe4..225e4a25d8 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -104,7 +104,7 @@ void forward_kinematics_SCARA(const float &a, const float &b) {
  * Maths and first version by QHARLEY.
  * Integrated into Marlin and slightly restructured by Joachim Cerny.
  */
-void inverse_kinematics(const float raw[XYZ]) {
+void inverse_kinematics(const float (&raw)[XYZ]) {
 
   static float C2, S2, SK1, SK2, THETA, PSI;
 

commit 8f8c6a9bc4f1c8b2d927e74339a48217d9b48ec7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 09:59:11 2018 -0500

    Move get_axis_position_mm to Planner (#10718)

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 8206388a40..222bf9cbe4 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -30,7 +30,7 @@
 
 #include "scara.h"
 #include "motion.h"
-#include "stepper.h"
+#include "planner.h"
 
 float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND;
 
@@ -147,8 +147,8 @@ void inverse_kinematics(const float raw[XYZ]) {
 }
 
 void scara_report_positions() {
-  SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
-  SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
+  SERIAL_PROTOCOLPAIR("SCARA Theta:", planner.get_axis_position_degrees(A_AXIS));
+  SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", planner.get_axis_position_degrees(B_AXIS));
   SERIAL_EOL();
 }
 

commit f8393a09086f01eafbb8563411da3b237c96b982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 2 23:59:42 2017 -0500

    Operate in Native Machine Space

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
index 830a435188..8206388a40 100644
--- a/Marlin/src/module/scara.cpp
+++ b/Marlin/src/module/scara.cpp
@@ -36,14 +36,14 @@ float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND;
 
 void scara_set_axis_is_at_home(const AxisEnum axis) {
   if (axis == Z_AXIS)
-    current_position[Z_AXIS] = LOGICAL_POSITION(Z_HOME_POS, Z_AXIS);
+    current_position[Z_AXIS] = Z_HOME_POS;
   else {
 
     /**
      * SCARA homes XY at the same time
      */
     float homeposition[XYZ];
-    LOOP_XYZ(i) homeposition[i] = LOGICAL_POSITION(base_home_pos((AxisEnum)i), i);
+    LOOP_XYZ(i) homeposition[i] = base_home_pos((AxisEnum)i);
 
     // SERIAL_ECHOPAIR("homeposition X:", homeposition[X_AXIS]);
     // SERIAL_ECHOLNPAIR(" Y:", homeposition[Y_AXIS]);
@@ -58,7 +58,7 @@ void scara_set_axis_is_at_home(const AxisEnum axis) {
     // SERIAL_ECHOPAIR("Cartesian X:", cartes[X_AXIS]);
     // SERIAL_ECHOLNPAIR(" Y:", cartes[Y_AXIS]);
 
-    current_position[axis] = LOGICAL_POSITION(cartes[axis], axis);
+    current_position[axis] = cartes[axis];
 
     /**
      * SCARA home positions are based on configuration since the actual
@@ -104,12 +104,12 @@ void forward_kinematics_SCARA(const float &a, const float &b) {
  * Maths and first version by QHARLEY.
  * Integrated into Marlin and slightly restructured by Joachim Cerny.
  */
-void inverse_kinematics(const float logical[XYZ]) {
+void inverse_kinematics(const float raw[XYZ]) {
 
   static float C2, S2, SK1, SK2, THETA, PSI;
 
-  float sx = RAW_X_POSITION(logical[X_AXIS]) - SCARA_OFFSET_X,  // Translate SCARA to standard X Y
-        sy = RAW_Y_POSITION(logical[Y_AXIS]) - SCARA_OFFSET_Y;  // With scaling factor.
+  float sx = raw[X_AXIS] - SCARA_OFFSET_X,  // Translate SCARA to standard X Y
+        sy = raw[Y_AXIS] - SCARA_OFFSET_Y;  // With scaling factor.
 
   if (L1 == L2)
     C2 = HYPOT2(sx, sy) / L1_2_2 - 1;
@@ -132,10 +132,10 @@ void inverse_kinematics(const float logical[XYZ]) {
 
   delta[A_AXIS] = DEGREES(THETA);        // theta is support arm angle
   delta[B_AXIS] = DEGREES(THETA + PSI);  // equal to sub arm angle (inverted motor)
-  delta[C_AXIS] = logical[Z_AXIS];
+  delta[C_AXIS] = raw[Z_AXIS];
 
   /*
-    DEBUG_POS("SCARA IK", logical);
+    DEBUG_POS("SCARA IK", raw);
     DEBUG_POS("SCARA IK", delta);
     SERIAL_ECHOPAIR("  SCARA (x,y) ", sx);
     SERIAL_ECHOPAIR(",", sy);

commit 551752eac73a6f60de45b6465e2f224b2b2dca24
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 15:35:25 2017 -0500

    Consolidate "bedlevel" code

diff --git a/Marlin/src/module/scara.cpp b/Marlin/src/module/scara.cpp
new file mode 100644
index 0000000000..830a435188
--- /dev/null
+++ b/Marlin/src/module/scara.cpp
@@ -0,0 +1,155 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * scara.cpp
+ */
+
+#include "../inc/MarlinConfig.h"
+
+#if IS_SCARA
+
+#include "scara.h"
+#include "motion.h"
+#include "stepper.h"
+
+float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND;
+
+void scara_set_axis_is_at_home(const AxisEnum axis) {
+  if (axis == Z_AXIS)
+    current_position[Z_AXIS] = LOGICAL_POSITION(Z_HOME_POS, Z_AXIS);
+  else {
+
+    /**
+     * SCARA homes XY at the same time
+     */
+    float homeposition[XYZ];
+    LOOP_XYZ(i) homeposition[i] = LOGICAL_POSITION(base_home_pos((AxisEnum)i), i);
+
+    // SERIAL_ECHOPAIR("homeposition X:", homeposition[X_AXIS]);
+    // SERIAL_ECHOLNPAIR(" Y:", homeposition[Y_AXIS]);
+
+    /**
+     * Get Home position SCARA arm angles using inverse kinematics,
+     * and calculate homing offset using forward kinematics
+     */
+    inverse_kinematics(homeposition);
+    forward_kinematics_SCARA(delta[A_AXIS], delta[B_AXIS]);
+
+    // SERIAL_ECHOPAIR("Cartesian X:", cartes[X_AXIS]);
+    // SERIAL_ECHOLNPAIR(" Y:", cartes[Y_AXIS]);
+
+    current_position[axis] = LOGICAL_POSITION(cartes[axis], axis);
+
+    /**
+     * SCARA home positions are based on configuration since the actual
+     * limits are determined by the inverse kinematic transform.
+     */
+    soft_endstop_min[axis] = base_min_pos(axis); // + (cartes[axis] - base_home_pos(axis));
+    soft_endstop_max[axis] = base_max_pos(axis); // + (cartes[axis] - base_home_pos(axis));
+  }
+}
+
+/**
+ * Morgan SCARA Forward Kinematics. Results in cartes[].
+ * Maths and first version by QHARLEY.
+ * Integrated into Marlin and slightly restructured by Joachim Cerny.
+ */
+void forward_kinematics_SCARA(const float &a, const float &b) {
+
+  const float a_sin = sin(RADIANS(a)) * L1,
+              a_cos = cos(RADIANS(a)) * L1,
+              b_sin = sin(RADIANS(b)) * L2,
+              b_cos = cos(RADIANS(b)) * L2;
+
+  cartes[X_AXIS] = a_cos + b_cos + SCARA_OFFSET_X;  //theta
+  cartes[Y_AXIS] = a_sin + b_sin + SCARA_OFFSET_Y;  //theta+phi
+
+  /*
+    SERIAL_ECHOPAIR("SCARA FK Angle a=", a);
+    SERIAL_ECHOPAIR(" b=", b);
+    SERIAL_ECHOPAIR(" a_sin=", a_sin);
+    SERIAL_ECHOPAIR(" a_cos=", a_cos);
+    SERIAL_ECHOPAIR(" b_sin=", b_sin);
+    SERIAL_ECHOLNPAIR(" b_cos=", b_cos);
+    SERIAL_ECHOPAIR(" cartes[X_AXIS]=", cartes[X_AXIS]);
+    SERIAL_ECHOLNPAIR(" cartes[Y_AXIS]=", cartes[Y_AXIS]);
+  //*/
+}
+
+/**
+ * Morgan SCARA Inverse Kinematics. Results in delta[].
+ *
+ * See http://forums.reprap.org/read.php?185,283327
+ *
+ * Maths and first version by QHARLEY.
+ * Integrated into Marlin and slightly restructured by Joachim Cerny.
+ */
+void inverse_kinematics(const float logical[XYZ]) {
+
+  static float C2, S2, SK1, SK2, THETA, PSI;
+
+  float sx = RAW_X_POSITION(logical[X_AXIS]) - SCARA_OFFSET_X,  // Translate SCARA to standard X Y
+        sy = RAW_Y_POSITION(logical[Y_AXIS]) - SCARA_OFFSET_Y;  // With scaling factor.
+
+  if (L1 == L2)
+    C2 = HYPOT2(sx, sy) / L1_2_2 - 1;
+  else
+    C2 = (HYPOT2(sx, sy) - (L1_2 + L2_2)) / (2.0 * L1 * L2);
+
+  S2 = SQRT(1 - sq(C2));
+
+  // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
+  SK1 = L1 + L2 * C2;
+
+  // Rotated Arm2 gives the distance from Arm1 to Arm2
+  SK2 = L2 * S2;
+
+  // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
+  THETA = ATAN2(SK1, SK2) - ATAN2(sx, sy);
+
+  // Angle of Arm2
+  PSI = ATAN2(S2, C2);
+
+  delta[A_AXIS] = DEGREES(THETA);        // theta is support arm angle
+  delta[B_AXIS] = DEGREES(THETA + PSI);  // equal to sub arm angle (inverted motor)
+  delta[C_AXIS] = logical[Z_AXIS];
+
+  /*
+    DEBUG_POS("SCARA IK", logical);
+    DEBUG_POS("SCARA IK", delta);
+    SERIAL_ECHOPAIR("  SCARA (x,y) ", sx);
+    SERIAL_ECHOPAIR(",", sy);
+    SERIAL_ECHOPAIR(" C2=", C2);
+    SERIAL_ECHOPAIR(" S2=", S2);
+    SERIAL_ECHOPAIR(" Theta=", THETA);
+    SERIAL_ECHOLNPAIR(" Phi=", PHI);
+  //*/
+}
+
+void scara_report_positions() {
+  SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
+  SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
+  SERIAL_EOL();
+}
+
+#endif // IS_SCARA
