commit 87e94f456348e944ba4487aed436c762dd718966
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon Apr 1 16:05:11 2024 -0400

    üö∏ Update ProUI Plot graph - part 2 (#26563)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index a0a72058aa..7ed070c9b8 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -137,29 +137,27 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC::sgt(sgt_val);
         TERN_(HAS_MARLINUI_MENU, this->stored.homing_thrs = sgt_val);
       }
       #if ENABLED(SPI_ENDSTOPS)
         bool test_stall_status();
       #endif
     #endif
 
-    #if ANY(HAS_MARLINUI_MENU, DWIN_LCD_PROUI)
-      void refresh_stepper_current() { rms_current(this->val_mA); }
+    void refresh_stepper_current() { rms_current(this->val_mA); }
 
-      #if ENABLED(HYBRID_THRESHOLD)
-        void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
-      #endif
-      #if USE_SENSORLESS
-        void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
-      #endif
+    #if ENABLED(HYBRID_THRESHOLD)
+      void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
+    #endif
+    #if USE_SENSORLESS
+      void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
     #endif
 
     static constexpr int8_t sgt_min = -64,
                             sgt_max =  63;
 };
 
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2208Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(Stream * SerialPort, const float RS, const uint8_t) :
@@ -200,26 +198,24 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2208Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         TERN_(HAS_MARLINUI_MENU, this->stored.hybrid_thrs = thrs);
       }
     #endif
 
-    #if ANY(HAS_MARLINUI_MENU, DWIN_LCD_PROUI)
-      void refresh_stepper_current() { rms_current(this->val_mA); }
+    void refresh_stepper_current() { rms_current(this->val_mA); }
 
-      #if ENABLED(HYBRID_THRESHOLD)
-        void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
-      #endif
+    #if ENABLED(HYBRID_THRESHOLD)
+      void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
     #endif
 };
 
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2209Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(Stream * SerialPort, const float RS, const uint8_t addr) :
       TMC2209Stepper(SerialPort, RS, addr)
       {}
     TMCMarlin(const uint16_t RX, const uint16_t TX, const float RS, const uint8_t addr) :
@@ -262,29 +258,27 @@ class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
     #endif
     #if USE_SENSORLESS
       int16_t homing_threshold() { return TMC2209Stepper::SGTHRS(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC2209Stepper::SGTHRS(sgt_val);
         TERN_(HAS_MARLINUI_MENU, this->stored.homing_thrs = sgt_val);
       }
     #endif
 
-    #if ANY(HAS_MARLINUI_MENU, DWIN_LCD_PROUI)
-      void refresh_stepper_current() { rms_current(this->val_mA); }
+    void refresh_stepper_current() { rms_current(this->val_mA); }
 
-      #if ENABLED(HYBRID_THRESHOLD)
-        void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
-      #endif
-      #if USE_SENSORLESS
-        void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
-      #endif
+    #if ENABLED(HYBRID_THRESHOLD)
+      void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
+    #endif
+    #if USE_SENSORLESS
+      void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
     #endif
 
     static constexpr uint8_t sgt_min = 0,
                              sgt_max = 255;
 };
 
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2660Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(const uint16_t cs_pin, const float RS, const uint8_t) :
@@ -308,26 +302,24 @@ class TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC266
 
     #if USE_SENSORLESS
       int16_t homing_threshold() { return TMC2660Stepper::sgt(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC2660Stepper::sgt(sgt_val);
         TERN_(HAS_MARLINUI_MENU, this->stored.homing_thrs = sgt_val);
       }
     #endif
 
-    #if ANY(HAS_MARLINUI_MENU, DWIN_LCD_PROUI)
-      void refresh_stepper_current() { rms_current(this->val_mA); }
+    void refresh_stepper_current() { rms_current(this->val_mA); }
 
-      #if USE_SENSORLESS
-        void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
-      #endif
+    #if USE_SENSORLESS
+      void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
     #endif
 
     static constexpr int8_t sgt_min = -64,
                             sgt_max =  63;
 };
 
 void monitor_tmc_drivers();
 void test_tmc_connection(LOGICAL_AXIS_DECL(const bool, true));
 
 #if ENABLED(TMC_DEBUG)

commit 858916d628526b5d56c34c5c9663e3535bfc7788
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Fri Jun 23 04:57:22 2023 -0500

    üö∏ Update DWIN ProUI (#26003)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 4ba3835906..a0a72058aa 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -137,21 +137,21 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC::sgt(sgt_val);
         TERN_(HAS_MARLINUI_MENU, this->stored.homing_thrs = sgt_val);
       }
       #if ENABLED(SPI_ENDSTOPS)
         bool test_stall_status();
       #endif
     #endif
 
-    #if HAS_MARLINUI_MENU
+    #if ANY(HAS_MARLINUI_MENU, DWIN_LCD_PROUI)
       void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
         void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
       #if USE_SENSORLESS
         void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
 
@@ -200,21 +200,21 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2208Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         TERN_(HAS_MARLINUI_MENU, this->stored.hybrid_thrs = thrs);
       }
     #endif
 
-    #if HAS_MARLINUI_MENU
+    #if ANY(HAS_MARLINUI_MENU, DWIN_LCD_PROUI)
       void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
         void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
     #endif
 };
 
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2209Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
@@ -262,21 +262,21 @@ class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
     #endif
     #if USE_SENSORLESS
       int16_t homing_threshold() { return TMC2209Stepper::SGTHRS(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC2209Stepper::SGTHRS(sgt_val);
         TERN_(HAS_MARLINUI_MENU, this->stored.homing_thrs = sgt_val);
       }
     #endif
 
-    #if HAS_MARLINUI_MENU
+    #if ANY(HAS_MARLINUI_MENU, DWIN_LCD_PROUI)
       void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
         void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
       #if USE_SENSORLESS
         void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
 
@@ -308,21 +308,21 @@ class TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC266
 
     #if USE_SENSORLESS
       int16_t homing_threshold() { return TMC2660Stepper::sgt(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC2660Stepper::sgt(sgt_val);
         TERN_(HAS_MARLINUI_MENU, this->stored.homing_thrs = sgt_val);
       }
     #endif
 
-    #if HAS_MARLINUI_MENU
+    #if ANY(HAS_MARLINUI_MENU, DWIN_LCD_PROUI)
       void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if USE_SENSORLESS
         void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
 
     static constexpr int8_t sgt_min = -64,
                             sgt_max =  63;
 };

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    üö∏ Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index fffa748f93..4ba3835906 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -341,21 +341,21 @@ void test_tmc_connection(LOGICAL_AXIS_DECL(const bool, true));
 /**
  * TMC2130-specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually-exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if USE_SENSORLESS
 
   // Track enabled status of stealthChop and only re-enable where applicable
-  struct sensorless_t { bool NUM_AXIS_ARGS(), x2, y2, z2, z3, z4; };
+  struct sensorless_t { bool NUM_AXIS_ARGS_() x2, y2, z2, z3, z4; };
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     extern millis_t sg_guard_period;
     constexpr uint16_t default_sg_guard_duration = 400;
   #endif
 
   bool tmc_enable_stallguard(TMC2130Stepper &st);
   void tmc_disable_stallguard(TMC2130Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2209Stepper &st);

commit 85325f585ac4a9bb667423561540b5d58bdc3b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 19:37:13 2023 -0500

    üßë‚Äçüíª Endstops preliminary work (#25780)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index c10bab6274..fffa748f93 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -371,19 +371,20 @@ void test_tmc_connection(LOGICAL_AXIS_DECL(const bool, true));
       this->switchCSpin(LOW);
 
       // read stallGuard flag from TMC library, will handle HW and SW SPI
       TMC2130_n::DRV_STATUS_t drv_status{0};
       drv_status.sr = this->DRV_STATUS();
 
       this->switchCSpin(HIGH);
 
       return drv_status.stallGuard;
     }
+
   #endif // SPI_ENDSTOPS
 
 #endif // USE_SENSORLESS
 
 #endif // HAS_TRINAMIC_CONFIG
 
 #if HAS_TMC_SPI
   void tmc_init_cs_pins();
 #endif

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index fc333b09dd..c10bab6274 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -341,21 +341,21 @@ void test_tmc_connection(LOGICAL_AXIS_DECL(const bool, true));
 /**
  * TMC2130-specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually-exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if USE_SENSORLESS
 
   // Track enabled status of stealthChop and only re-enable where applicable
-  struct sensorless_t { bool LINEAR_AXIS_ARGS(), x2, y2, z2, z3, z4; };
+  struct sensorless_t { bool NUM_AXIS_ARGS(), x2, y2, z2, z3, z4; };
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     extern millis_t sg_guard_period;
     constexpr uint16_t default_sg_guard_duration = 400;
   #endif
 
   bool tmc_enable_stallguard(TMC2130Stepper &st);
   void tmc_disable_stallguard(TMC2130Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2209Stepper &st);

commit f03c3677394126e72fb7c2679891a67f1efe0332
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Tue Feb 22 16:16:57 2022 +1300

    üêõ Fix TMC26X CS pins init (#23778)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 892d33768b..fc333b09dd 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -375,15 +375,15 @@ void test_tmc_connection(LOGICAL_AXIS_DECL(const bool, true));
       drv_status.sr = this->DRV_STATUS();
 
       this->switchCSpin(HIGH);
 
       return drv_status.stallGuard;
     }
   #endif // SPI_ENDSTOPS
 
 #endif // USE_SENSORLESS
 
+#endif // HAS_TRINAMIC_CONFIG
+
 #if HAS_TMC_SPI
   void tmc_init_cs_pins();
 #endif
-
-#endif // HAS_TRINAMIC_CONFIG

commit ab46b7e2f298826a5512569d6e79bb59a7a6b8ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 25 15:33:03 2022 -0600

    üßë‚Äçüíª HAS_MARLINUI_MENU, HAS_MANUAL_MOVE_MENU

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 44cde9c763..892d33768b 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -121,37 +121,37 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
       TMC::hysteresis_end(ct.hend);
       TMC::hysteresis_start(ct.hstrt);
     }
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
-        TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
+        TERN_(HAS_MARLINUI_MENU, this->stored.hybrid_thrs = thrs);
       }
     #endif
 
     #if USE_SENSORLESS
       int16_t homing_threshold() { return TMC::sgt(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC::sgt(sgt_val);
-        TERN_(HAS_LCD_MENU, this->stored.homing_thrs = sgt_val);
+        TERN_(HAS_MARLINUI_MENU, this->stored.homing_thrs = sgt_val);
       }
       #if ENABLED(SPI_ENDSTOPS)
         bool test_stall_status();
       #endif
     #endif
 
-    #if HAS_LCD_MENU
+    #if HAS_MARLINUI_MENU
       void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
         void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
       #if USE_SENSORLESS
         void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
 
@@ -196,25 +196,25 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
       TMC2208Stepper::hysteresis_end(ct.hend);
       TMC2208Stepper::hysteresis_start(ct.hstrt);
     }
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2208Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
-        TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
+        TERN_(HAS_MARLINUI_MENU, this->stored.hybrid_thrs = thrs);
       }
     #endif
 
-    #if HAS_LCD_MENU
+    #if HAS_MARLINUI_MENU
       void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
         void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
     #endif
 };
 
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2209Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
@@ -250,33 +250,33 @@ class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
       TMC2209Stepper::hysteresis_end(ct.hend);
       TMC2209Stepper::hysteresis_start(ct.hstrt);
     }
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2209Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
-        TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
+        TERN_(HAS_MARLINUI_MENU, this->stored.hybrid_thrs = thrs);
       }
     #endif
     #if USE_SENSORLESS
       int16_t homing_threshold() { return TMC2209Stepper::SGTHRS(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC2209Stepper::SGTHRS(sgt_val);
-        TERN_(HAS_LCD_MENU, this->stored.homing_thrs = sgt_val);
+        TERN_(HAS_MARLINUI_MENU, this->stored.homing_thrs = sgt_val);
       }
     #endif
 
-    #if HAS_LCD_MENU
+    #if HAS_MARLINUI_MENU
       void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
         void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
       #if USE_SENSORLESS
         void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
 
@@ -304,25 +304,25 @@ class TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC266
       TMC2660Stepper::toff(ct.toff);
       TMC2660Stepper::hysteresis_end(ct.hend);
       TMC2660Stepper::hysteresis_start(ct.hstrt);
     }
 
     #if USE_SENSORLESS
       int16_t homing_threshold() { return TMC2660Stepper::sgt(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC2660Stepper::sgt(sgt_val);
-        TERN_(HAS_LCD_MENU, this->stored.homing_thrs = sgt_val);
+        TERN_(HAS_MARLINUI_MENU, this->stored.homing_thrs = sgt_val);
       }
     #endif
 
-    #if HAS_LCD_MENU
+    #if HAS_MARLINUI_MENU
       void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if USE_SENSORLESS
         void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
 
     static constexpr int8_t sgt_min = -64,
                             sgt_max =  63;
 };

commit 6fbfeb68010e63c76b545e2c27aeb48ee73be68b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 1 22:54:27 2022 -0600

    ‚ú® M919 : Chopper Timing (#23400)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 2da425170f..44cde9c763 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -57,27 +57,27 @@ class TMCStorage {
     // Only a child class has access to constructor => Don't create on its own! "Poor man's abstract class"
     TMCStorage() {}
 
   public:
     uint16_t val_mA = 0;
 
     #if ENABLED(MONITOR_DRIVER_STATUS)
       uint8_t otpw_count = 0,
               error_count = 0;
       bool flag_otpw = false;
-      inline bool getOTPW() { return flag_otpw; }
-      inline void clear_otpw() { flag_otpw = 0; }
+      bool getOTPW() { return flag_otpw; }
+      void clear_otpw() { flag_otpw = 0; }
     #endif
 
-    inline uint16_t getMilliamps() { return val_mA; }
+    uint16_t getMilliamps() { return val_mA; }
 
-    inline void printLabel() {
+    void printLabel() {
       SERIAL_CHAR(AXIS_LETTER);
       if (DRIVER_ID > '0') SERIAL_CHAR(DRIVER_ID);
     }
 
     struct {
       OPTCODE(HAS_STEALTHCHOP,  bool stealthChop_enabled = false)
       OPTCODE(HYBRID_THRESHOLD, uint8_t hybrid_thrs = 0)
       OPTCODE(USE_SENSORLESS,   int16_t homing_thrs = 0)
     } stored;
 };
@@ -90,69 +90,75 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
       {}
     TMCMarlin(const uint16_t cs_pin, const float RS, const uint8_t axis_chain_index) :
       TMC(cs_pin, RS, axis_chain_index)
       {}
     TMCMarlin(const uint16_t CS, const float RS, const uint16_t pinMOSI, const uint16_t pinMISO, const uint16_t pinSCK) :
       TMC(CS, RS, pinMOSI, pinMISO, pinSCK)
       {}
     TMCMarlin(const uint16_t CS, const float RS, const uint16_t pinMOSI, const uint16_t pinMISO, const uint16_t pinSCK, const uint8_t axis_chain_index) :
       TMC(CS, RS, pinMOSI, pinMISO, pinSCK,  axis_chain_index)
       {}
-    inline uint16_t rms_current() { return TMC::rms_current(); }
-    inline void rms_current(uint16_t mA) {
+    uint16_t rms_current() { return TMC::rms_current(); }
+    void rms_current(uint16_t mA) {
       this->val_mA = mA;
       TMC::rms_current(mA);
     }
-    inline void rms_current(const uint16_t mA, const float mult) {
+    void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC::rms_current(mA, mult);
     }
-    inline uint16_t get_microstep_counter() { return TMC::MSCNT(); }
+    uint16_t get_microstep_counter() { return TMC::MSCNT(); }
 
     #if HAS_STEALTHCHOP
-      inline bool get_stealthChop()                { return this->en_pwm_mode(); }
-      inline bool get_stored_stealthChop()         { return this->stored.stealthChop_enabled; }
-      inline void refresh_stepping_mode()          { this->en_pwm_mode(this->stored.stealthChop_enabled); }
-      inline void set_stealthChop(const bool stch) { this->stored.stealthChop_enabled = stch; refresh_stepping_mode(); }
-      inline bool toggle_stepping_mode()           { set_stealthChop(!this->stored.stealthChop_enabled); return get_stealthChop(); }
+      bool get_stealthChop()                { return this->en_pwm_mode(); }
+      bool get_stored_stealthChop()         { return this->stored.stealthChop_enabled; }
+      void refresh_stepping_mode()          { this->en_pwm_mode(this->stored.stealthChop_enabled); }
+      void set_stealthChop(const bool stch) { this->stored.stealthChop_enabled = stch; refresh_stepping_mode(); }
+      bool toggle_stepping_mode()           { set_stealthChop(!this->stored.stealthChop_enabled); return get_stealthChop(); }
     #endif
 
+    void set_chopper_times(const chopper_timing_t &ct) {
+      TMC::toff(ct.toff);
+      TMC::hysteresis_end(ct.hend);
+      TMC::hysteresis_start(ct.hstrt);
+    }
+
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
       }
     #endif
 
     #if USE_SENSORLESS
-      inline int16_t homing_threshold() { return TMC::sgt(); }
+      int16_t homing_threshold() { return TMC::sgt(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC::sgt(sgt_val);
         TERN_(HAS_LCD_MENU, this->stored.homing_thrs = sgt_val);
       }
       #if ENABLED(SPI_ENDSTOPS)
         bool test_stall_status();
       #endif
     #endif
 
     #if HAS_LCD_MENU
-      inline void refresh_stepper_current() { rms_current(this->val_mA); }
+      void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
-        inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
+        void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
       #if USE_SENSORLESS
-        inline void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
+        void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
 
     static constexpr int8_t sgt_min = -64,
                             sgt_max =  63;
 };
 
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2208Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
@@ -160,149 +166,167 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
       TMC2208Stepper(SerialPort, RS)
       {}
     TMCMarlin(Stream * SerialPort, const float RS, uint8_t addr, const uint16_t mul_pin1, const uint16_t mul_pin2) :
       TMC2208Stepper(SerialPort, RS, addr, mul_pin1, mul_pin2)
      {}
     TMCMarlin(const uint16_t RX, const uint16_t TX, const float RS, const uint8_t) :
       TMC2208Stepper(RX, TX, RS)
       {}
 
     uint16_t rms_current() { return TMC2208Stepper::rms_current(); }
-    inline void rms_current(const uint16_t mA) {
+    void rms_current(const uint16_t mA) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA);
     }
-    inline void rms_current(const uint16_t mA, const float mult) {
+    void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA, mult);
     }
-    inline uint16_t get_microstep_counter() { return TMC2208Stepper::MSCNT(); }
+    uint16_t get_microstep_counter() { return TMC2208Stepper::MSCNT(); }
 
     #if HAS_STEALTHCHOP
-      inline bool get_stealthChop()                { return !this->en_spreadCycle(); }
-      inline bool get_stored_stealthChop()         { return this->stored.stealthChop_enabled; }
-      inline void refresh_stepping_mode()          { this->en_spreadCycle(!this->stored.stealthChop_enabled); }
-      inline void set_stealthChop(const bool stch) { this->stored.stealthChop_enabled = stch; refresh_stepping_mode(); }
-      inline bool toggle_stepping_mode()           { set_stealthChop(!this->stored.stealthChop_enabled); return get_stealthChop(); }
+      bool get_stealthChop()                { return !this->en_spreadCycle(); }
+      bool get_stored_stealthChop()         { return this->stored.stealthChop_enabled; }
+      void refresh_stepping_mode()          { this->en_spreadCycle(!this->stored.stealthChop_enabled); }
+      void set_stealthChop(const bool stch) { this->stored.stealthChop_enabled = stch; refresh_stepping_mode(); }
+      bool toggle_stepping_mode()           { set_stealthChop(!this->stored.stealthChop_enabled); return get_stealthChop(); }
     #endif
 
+    void set_chopper_times(const chopper_timing_t &ct) {
+      TMC2208Stepper::toff(ct.toff);
+      TMC2208Stepper::hysteresis_end(ct.hend);
+      TMC2208Stepper::hysteresis_start(ct.hstrt);
+    }
+
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2208Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
       }
     #endif
 
     #if HAS_LCD_MENU
-      inline void refresh_stepper_current() { rms_current(this->val_mA); }
+      void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
-        inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
+        void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
     #endif
 };
 
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2209Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(Stream * SerialPort, const float RS, const uint8_t addr) :
       TMC2209Stepper(SerialPort, RS, addr)
       {}
     TMCMarlin(const uint16_t RX, const uint16_t TX, const float RS, const uint8_t addr) :
       TMC2209Stepper(RX, TX, RS, addr)
       {}
     uint8_t get_address() { return slave_address; }
     uint16_t rms_current() { return TMC2209Stepper::rms_current(); }
-    inline void rms_current(const uint16_t mA) {
+    void rms_current(const uint16_t mA) {
       this->val_mA = mA;
       TMC2209Stepper::rms_current(mA);
     }
-    inline void rms_current(const uint16_t mA, const float mult) {
+    void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC2209Stepper::rms_current(mA, mult);
     }
-    inline uint16_t get_microstep_counter() { return TMC2209Stepper::MSCNT(); }
+    uint16_t get_microstep_counter() { return TMC2209Stepper::MSCNT(); }
 
     #if HAS_STEALTHCHOP
-      inline bool get_stealthChop()                { return !this->en_spreadCycle(); }
-      inline bool get_stored_stealthChop()         { return this->stored.stealthChop_enabled; }
-      inline void refresh_stepping_mode()          { this->en_spreadCycle(!this->stored.stealthChop_enabled); }
-      inline void set_stealthChop(const bool stch) { this->stored.stealthChop_enabled = stch; refresh_stepping_mode(); }
-      inline bool toggle_stepping_mode()           { set_stealthChop(!this->stored.stealthChop_enabled); return get_stealthChop(); }
+      bool get_stealthChop()                { return !this->en_spreadCycle(); }
+      bool get_stored_stealthChop()         { return this->stored.stealthChop_enabled; }
+      void refresh_stepping_mode()          { this->en_spreadCycle(!this->stored.stealthChop_enabled); }
+      void set_stealthChop(const bool stch) { this->stored.stealthChop_enabled = stch; refresh_stepping_mode(); }
+      bool toggle_stepping_mode()           { set_stealthChop(!this->stored.stealthChop_enabled); return get_stealthChop(); }
     #endif
 
+    void set_chopper_times(const chopper_timing_t &ct) {
+      TMC2209Stepper::toff(ct.toff);
+      TMC2209Stepper::hysteresis_end(ct.hend);
+      TMC2209Stepper::hysteresis_start(ct.hstrt);
+    }
+
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2209Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
       }
     #endif
     #if USE_SENSORLESS
-      inline int16_t homing_threshold() { return TMC2209Stepper::SGTHRS(); }
+      int16_t homing_threshold() { return TMC2209Stepper::SGTHRS(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC2209Stepper::SGTHRS(sgt_val);
         TERN_(HAS_LCD_MENU, this->stored.homing_thrs = sgt_val);
       }
     #endif
 
     #if HAS_LCD_MENU
-      inline void refresh_stepper_current() { rms_current(this->val_mA); }
+      void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
-        inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
+        void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
       #if USE_SENSORLESS
-        inline void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
+        void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
 
     static constexpr uint8_t sgt_min = 0,
                              sgt_max = 255;
 };
 
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2660Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(const uint16_t cs_pin, const float RS, const uint8_t) :
       TMC2660Stepper(cs_pin, RS)
       {}
     TMCMarlin(const uint16_t CS, const float RS, const uint16_t pinMOSI, const uint16_t pinMISO, const uint16_t pinSCK, const uint8_t) :
       TMC2660Stepper(CS, RS, pinMOSI, pinMISO, pinSCK)
       {}
-    inline uint16_t rms_current() { return TMC2660Stepper::rms_current(); }
-    inline void rms_current(const uint16_t mA) {
+    uint16_t rms_current() { return TMC2660Stepper::rms_current(); }
+    void rms_current(const uint16_t mA) {
       this->val_mA = mA;
       TMC2660Stepper::rms_current(mA);
     }
-    inline uint16_t get_microstep_counter() { return TMC2660Stepper::mstep(); }
+    uint16_t get_microstep_counter() { return TMC2660Stepper::mstep(); }
+
+    void set_chopper_times(const chopper_timing_t &ct) {
+      TMC2660Stepper::toff(ct.toff);
+      TMC2660Stepper::hysteresis_end(ct.hend);
+      TMC2660Stepper::hysteresis_start(ct.hstrt);
+    }
 
     #if USE_SENSORLESS
-      inline int16_t homing_threshold() { return TMC2660Stepper::sgt(); }
+      int16_t homing_threshold() { return TMC2660Stepper::sgt(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC2660Stepper::sgt(sgt_val);
         TERN_(HAS_LCD_MENU, this->stored.homing_thrs = sgt_val);
       }
     #endif
 
     #if HAS_LCD_MENU
-      inline void refresh_stepper_current() { rms_current(this->val_mA); }
+      void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if USE_SENSORLESS
-        inline void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
+        void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
 
     static constexpr int8_t sgt_min = -64,
                             sgt_max =  63;
 };
 
 void monitor_tmc_drivers();
 void test_tmc_connection(LOGICAL_AXIS_DECL(const bool, true));
 

commit 02b4e48c6df1604d3de09cbef072f685fe956e92
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Dec 28 05:43:10 2021 -0600

    üö∏ Refine stepper-driver-related G-codes (#23372)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 1f7d5cf1a5..2da425170f 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -38,20 +38,26 @@
 #define CHOPPER_09STEP_24V   { 3, -1, 5 }
 
 #if ENABLED(MONITOR_DRIVER_STATUS) && !defined(MONITOR_DRIVER_STATUS_INTERVAL_MS)
   #define MONITOR_DRIVER_STATUS_INTERVAL_MS 500U
 #endif
 
 constexpr uint16_t _tmc_thrs(const uint16_t msteps, const uint32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
 
+typedef struct {
+  uint8_t toff;
+  int8_t hend;
+  uint8_t hstrt;
+} chopper_timing_t;
+
 template<char AXIS_LETTER, char DRIVER_ID>
 class TMCStorage {
   protected:
     // Only a child class has access to constructor => Don't create on its own! "Poor man's abstract class"
     TMCStorage() {}
 
   public:
     uint16_t val_mA = 0;
 
     #if ENABLED(MONITOR_DRIVER_STATUS)
@@ -290,57 +296,20 @@ class TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC266
 
       #if USE_SENSORLESS
         inline void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
 
     static constexpr int8_t sgt_min = -64,
                             sgt_max =  63;
 };
 
-template<typename TMC>
-void tmc_print_current(TMC &st) {
-  st.printLabel();
-  SERIAL_ECHOLNPGM(" driver current: ", st.getMilliamps());
-}
-
-#if ENABLED(MONITOR_DRIVER_STATUS)
-  template<typename TMC>
-  void tmc_report_otpw(TMC &st) {
-    st.printLabel();
-    SERIAL_ECHOPGM(" temperature prewarn triggered: ");
-    serialprint_truefalse(st.getOTPW());
-    SERIAL_EOL();
-  }
-  template<typename TMC>
-  void tmc_clear_otpw(TMC &st) {
-    st.clear_otpw();
-    st.printLabel();
-    SERIAL_ECHOLNPGM(" prewarn flag cleared");
-  }
-#endif
-#if ENABLED(HYBRID_THRESHOLD)
-  template<typename TMC>
-  void tmc_print_pwmthrs(TMC &st) {
-    st.printLabel();
-    SERIAL_ECHOLNPGM(" stealthChop max speed: ", st.get_pwm_thrs());
-  }
-#endif
-#if USE_SENSORLESS
-  template<typename TMC>
-  void tmc_print_sgt(TMC &st) {
-    st.printLabel();
-    SERIAL_ECHOPGM(" homing sensitivity: ");
-    SERIAL_PRINTLN(st.homing_threshold(), PrintBase::Dec);
-  }
-#endif
-
 void monitor_tmc_drivers();
 void test_tmc_connection(LOGICAL_AXIS_DECL(const bool, true));
 
 #if ENABLED(TMC_DEBUG)
   #if ENABLED(MONITOR_DRIVER_STATUS)
     void tmc_set_report_interval(const uint16_t update_interval);
   #endif
   void tmc_report_all(LOGICAL_AXIS_DECL(const bool, true));
   void tmc_get_registers(LOGICAL_AXIS_ARGS(const bool));
 #endif

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 87780486eb..1f7d5cf1a5 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -293,21 +293,21 @@ class TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC266
       #endif
     #endif
 
     static constexpr int8_t sgt_min = -64,
                             sgt_max =  63;
 };
 
 template<typename TMC>
 void tmc_print_current(TMC &st) {
   st.printLabel();
-  SERIAL_ECHOLNPAIR(" driver current: ", st.getMilliamps());
+  SERIAL_ECHOLNPGM(" driver current: ", st.getMilliamps());
 }
 
 #if ENABLED(MONITOR_DRIVER_STATUS)
   template<typename TMC>
   void tmc_report_otpw(TMC &st) {
     st.printLabel();
     SERIAL_ECHOPGM(" temperature prewarn triggered: ");
     serialprint_truefalse(st.getOTPW());
     SERIAL_EOL();
   }
@@ -315,21 +315,21 @@ void tmc_print_current(TMC &st) {
   void tmc_clear_otpw(TMC &st) {
     st.clear_otpw();
     st.printLabel();
     SERIAL_ECHOLNPGM(" prewarn flag cleared");
   }
 #endif
 #if ENABLED(HYBRID_THRESHOLD)
   template<typename TMC>
   void tmc_print_pwmthrs(TMC &st) {
     st.printLabel();
-    SERIAL_ECHOLNPAIR(" stealthChop max speed: ", st.get_pwm_thrs());
+    SERIAL_ECHOLNPGM(" stealthChop max speed: ", st.get_pwm_thrs());
   }
 #endif
 #if USE_SENSORLESS
   template<typename TMC>
   void tmc_print_sgt(TMC &st) {
     st.printLabel();
     SERIAL_ECHOPGM(" homing sensitivity: ");
     SERIAL_PRINTLN(st.homing_threshold(), PrintBase::Dec);
   }
 #endif

commit 331cc5fd6a044e568dbe789ecd0b732b6eba454f
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Aug 8 19:25:17 2021 -0700

    üêõ Fix some Simulator on Windows issues (#22516)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index c878d86fae..87780486eb 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -323,21 +323,21 @@ void tmc_print_current(TMC &st) {
   void tmc_print_pwmthrs(TMC &st) {
     st.printLabel();
     SERIAL_ECHOLNPAIR(" stealthChop max speed: ", st.get_pwm_thrs());
   }
 #endif
 #if USE_SENSORLESS
   template<typename TMC>
   void tmc_print_sgt(TMC &st) {
     st.printLabel();
     SERIAL_ECHOPGM(" homing sensitivity: ");
-    SERIAL_PRINTLN(st.homing_threshold(), DEC);
+    SERIAL_PRINTLN(st.homing_threshold(), PrintBase::Dec);
   }
 #endif
 
 void monitor_tmc_drivers();
 void test_tmc_connection(LOGICAL_AXIS_DECL(const bool, true));
 
 #if ENABLED(TMC_DEBUG)
   #if ENABLED(MONITOR_DRIVER_STATUS)
     void tmc_set_report_interval(const uint16_t update_interval);
   #endif

commit 05ebde38127ca6c3bc056cb4068a414bade766b4
Author: lujios <83166168+lujios@users.noreply.github.com>
Date:   Tue Jul 13 02:19:29 2021 +0200

    ‚ö°Ô∏è Improve Sensorless homing/probing for G28, G33 (#21899)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 4753f78d91..c878d86fae 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -353,27 +353,20 @@ void test_tmc_connection(LOGICAL_AXIS_DECL(const bool, true));
  * Defined here because of limitations with templates and headers.
  */
 #if USE_SENSORLESS
 
   // Track enabled status of stealthChop and only re-enable where applicable
   struct sensorless_t { bool LINEAR_AXIS_ARGS(), x2, y2, z2, z3, z4; };
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     extern millis_t sg_guard_period;
     constexpr uint16_t default_sg_guard_duration = 400;
-
-    struct motion_state_t {
-      xy_ulong_t acceleration;
-      #if HAS_CLASSIC_JERK
-        xy_float_t jerk_state;
-      #endif
-    };
   #endif
 
   bool tmc_enable_stallguard(TMC2130Stepper &st);
   void tmc_disable_stallguard(TMC2130Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2209Stepper &st);
   void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2660Stepper);
   void tmc_disable_stallguard(TMC2660Stepper, const bool);

commit 26bfc267977ddc444513c793c18f76847e23310e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 9 17:09:58 2021 -0500

    üé® Check flags without ENABLED

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 741b840ec7..4753f78d91 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -356,21 +356,21 @@ void test_tmc_connection(LOGICAL_AXIS_DECL(const bool, true));
 
   // Track enabled status of stealthChop and only re-enable where applicable
   struct sensorless_t { bool LINEAR_AXIS_ARGS(), x2, y2, z2, z3, z4; };
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     extern millis_t sg_guard_period;
     constexpr uint16_t default_sg_guard_duration = 400;
 
     struct motion_state_t {
       xy_ulong_t acceleration;
-      #if ENABLED(HAS_CLASSIC_JERK)
+      #if HAS_CLASSIC_JERK
         xy_float_t jerk_state;
       #endif
     };
   #endif
 
   bool tmc_enable_stallguard(TMC2130Stepper &st);
   void tmc_disable_stallguard(TMC2130Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2209Stepper &st);
   void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth);

commit 5ce6d8aa1f81178fc25a12abff63ca1a6c88e42c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 19 14:09:09 2021 -0500

    Cosmetic changes for G28

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 3a856b3af8..741b840ec7 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -354,24 +354,24 @@ void test_tmc_connection(LOGICAL_AXIS_DECL(const bool, true));
  */
 #if USE_SENSORLESS
 
   // Track enabled status of stealthChop and only re-enable where applicable
   struct sensorless_t { bool LINEAR_AXIS_ARGS(), x2, y2, z2, z3, z4; };
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     extern millis_t sg_guard_period;
     constexpr uint16_t default_sg_guard_duration = 400;
 
-    struct slow_homing_t {
+    struct motion_state_t {
       xy_ulong_t acceleration;
       #if ENABLED(HAS_CLASSIC_JERK)
-        xy_float_t jerk_xy;
+        xy_float_t jerk_state;
       #endif
     };
   #endif
 
   bool tmc_enable_stallguard(TMC2130Stepper &st);
   void tmc_disable_stallguard(TMC2130Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2209Stepper &st);
   void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth);
 

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index a07d6ce0ee..3a856b3af8 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -328,47 +328,41 @@ void tmc_print_current(TMC &st) {
 #if USE_SENSORLESS
   template<typename TMC>
   void tmc_print_sgt(TMC &st) {
     st.printLabel();
     SERIAL_ECHOPGM(" homing sensitivity: ");
     SERIAL_PRINTLN(st.homing_threshold(), DEC);
   }
 #endif
 
 void monitor_tmc_drivers();
-void test_tmc_connection(
-  LOGICAL_AXIS_LIST(const bool test_e=true, const bool test_x=true, const bool test_y=true, const bool test_z=true)
-);
+void test_tmc_connection(LOGICAL_AXIS_DECL(const bool, true));
 
 #if ENABLED(TMC_DEBUG)
   #if ENABLED(MONITOR_DRIVER_STATUS)
     void tmc_set_report_interval(const uint16_t update_interval);
   #endif
-  void tmc_report_all(
-    LOGICAL_AXIS_LIST(const bool print_e=true, const bool print_x=true, const bool print_y=true, const bool print_z=true)
-  );
-  void tmc_get_registers(
-    LOGICAL_AXIS_LIST(const bool print_e, const bool print_x, const bool print_y, const bool print_z)
-  );
+  void tmc_report_all(LOGICAL_AXIS_DECL(const bool, true));
+  void tmc_get_registers(LOGICAL_AXIS_ARGS(const bool));
 #endif
 
 /**
  * TMC2130-specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually-exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if USE_SENSORLESS
 
   // Track enabled status of stealthChop and only re-enable where applicable
-  struct sensorless_t { bool LINEAR_AXIS_LIST(x, y, z), x2, y2, z2, z3, z4; };
+  struct sensorless_t { bool LINEAR_AXIS_ARGS(), x2, y2, z2, z3, z4; };
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     extern millis_t sg_guard_period;
     constexpr uint16_t default_sg_guard_duration = 400;
 
     struct slow_homing_t {
       xy_ulong_t acceleration;
       #if ENABLED(HAS_CLASSIC_JERK)
         xy_float_t jerk_xy;
       #endif

commit dd4990252e891cdfe56cb7d6e3bbe1e6289be649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 24 16:38:57 2021 -0500

    ‚ôªÔ∏è Refactor Linear / Logical / Distinct Axes (#21953)
    
    * More patches supporting EXTRUDERS 0
    * Extend types in prep for more axes

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 179f38f729..a07d6ce0ee 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -328,41 +328,47 @@ void tmc_print_current(TMC &st) {
 #if USE_SENSORLESS
   template<typename TMC>
   void tmc_print_sgt(TMC &st) {
     st.printLabel();
     SERIAL_ECHOPGM(" homing sensitivity: ");
     SERIAL_PRINTLN(st.homing_threshold(), DEC);
   }
 #endif
 
 void monitor_tmc_drivers();
-void test_tmc_connection(const bool test_x=true, const bool test_y=true, const bool test_z=true, const bool test_e=true);
+void test_tmc_connection(
+  LOGICAL_AXIS_LIST(const bool test_e=true, const bool test_x=true, const bool test_y=true, const bool test_z=true)
+);
 
 #if ENABLED(TMC_DEBUG)
   #if ENABLED(MONITOR_DRIVER_STATUS)
     void tmc_set_report_interval(const uint16_t update_interval);
   #endif
-  void tmc_report_all(const bool print_x=true, const bool print_y=true, const bool print_z=true, const bool print_e=true);
-  void tmc_get_registers(const bool print_x, const bool print_y, const bool print_z, const bool print_e);
+  void tmc_report_all(
+    LOGICAL_AXIS_LIST(const bool print_e=true, const bool print_x=true, const bool print_y=true, const bool print_z=true)
+  );
+  void tmc_get_registers(
+    LOGICAL_AXIS_LIST(const bool print_e, const bool print_x, const bool print_y, const bool print_z)
+  );
 #endif
 
 /**
  * TMC2130-specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually-exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if USE_SENSORLESS
 
   // Track enabled status of stealthChop and only re-enable where applicable
-  struct sensorless_t { bool x, y, z, x2, y2, z2, z3, z4; };
+  struct sensorless_t { bool LINEAR_AXIS_LIST(x, y, z), x2, y2, z2, z3, z4; };
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     extern millis_t sg_guard_period;
     constexpr uint16_t default_sg_guard_duration = 400;
 
     struct slow_homing_t {
       xy_ulong_t acceleration;
       #if ENABLED(HAS_CLASSIC_JERK)
         xy_float_t jerk_xy;
       #endif

commit 84fd0eff17d089e3f75f6585d4bba47f15c00ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 23 21:33:22 2021 -0500

    üé® Macros for optional arguments (#21969)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index a0e07ab8a8..179f38f729 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -63,29 +63,23 @@ class TMCStorage {
     #endif
 
     inline uint16_t getMilliamps() { return val_mA; }
 
     inline void printLabel() {
       SERIAL_CHAR(AXIS_LETTER);
       if (DRIVER_ID > '0') SERIAL_CHAR(DRIVER_ID);
     }
 
     struct {
-      #if ENABLED(HAS_STEALTHCHOP)
-        bool stealthChop_enabled = false;
-      #endif
-      #if ENABLED(HYBRID_THRESHOLD)
-        uint8_t hybrid_thrs = 0;
-      #endif
-      #if ENABLED(USE_SENSORLESS)
-        int16_t homing_thrs = 0;
-      #endif
+      OPTCODE(HAS_STEALTHCHOP,  bool stealthChop_enabled = false)
+      OPTCODE(HYBRID_THRESHOLD, uint8_t hybrid_thrs = 0)
+      OPTCODE(USE_SENSORLESS,   int16_t homing_thrs = 0)
     } stored;
 };
 
 template<class TMC, char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(const uint16_t cs_pin, const float RS) :
       TMC(cs_pin, RS)
       {}
     TMCMarlin(const uint16_t cs_pin, const float RS, const uint8_t axis_chain_index) :

commit 926a7f27c66e777b5a838a87ee8931d35095fd03
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:52:10 2021 -0500

    ‚ôªÔ∏è Simplify TMC utilities for more axes

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 1767313ba2..a0e07ab8a8 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -334,27 +334,27 @@ void tmc_print_current(TMC &st) {
 #if USE_SENSORLESS
   template<typename TMC>
   void tmc_print_sgt(TMC &st) {
     st.printLabel();
     SERIAL_ECHOPGM(" homing sensitivity: ");
     SERIAL_PRINTLN(st.homing_threshold(), DEC);
   }
 #endif
 
 void monitor_tmc_drivers();
-void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z, const bool test_e);
+void test_tmc_connection(const bool test_x=true, const bool test_y=true, const bool test_z=true, const bool test_e=true);
 
 #if ENABLED(TMC_DEBUG)
   #if ENABLED(MONITOR_DRIVER_STATUS)
     void tmc_set_report_interval(const uint16_t update_interval);
   #endif
-  void tmc_report_all(const bool print_x, const bool print_y, const bool print_z, const bool print_e);
+  void tmc_report_all(const bool print_x=true, const bool print_y=true, const bool print_z=true, const bool print_e=true);
   void tmc_get_registers(const bool print_x, const bool print_y, const bool print_z, const bool print_e);
 #endif
 
 /**
  * TMC2130-specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually-exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */

commit bca4652c5e48415cf478da229a253a2106da3e59
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 17 02:03:16 2021 -0500

    Leave Hybrid Threshold as-is for now
    
    Reverting 253ee0c407

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 0d6105358d..1767313ba2 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -113,29 +113,26 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
       inline bool get_stored_stealthChop()         { return this->stored.stealthChop_enabled; }
       inline void refresh_stepping_mode()          { this->en_pwm_mode(this->stored.stealthChop_enabled); }
       inline void set_stealthChop(const bool stch) { this->stored.stealthChop_enabled = stch; refresh_stepping_mode(); }
       inline bool toggle_stepping_mode()           { set_stealthChop(!this->stored.stealthChop_enabled); return get_stealthChop(); }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
+      void set_pwm_thrs(const uint32_t thrs) {
+        TMC::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
+        TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
+      }
     #endif
 
-    void set_pwm_thrs(const uint32_t thrs) {
-      TMC::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
-      #if BOTH(HYBRID_THRESHOLD, HAS_LCD_MENU)
-        this->stored.hybrid_thrs = thrs;
-      #endif
-    }
-
     #if USE_SENSORLESS
       inline int16_t homing_threshold() { return TMC::sgt(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC::sgt(sgt_val);
         TERN_(HAS_LCD_MENU, this->stored.homing_thrs = sgt_val);
       }
       #if ENABLED(SPI_ENDSTOPS)
         bool test_stall_status();
       #endif
@@ -181,35 +178,33 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
     inline uint16_t get_microstep_counter() { return TMC2208Stepper::MSCNT(); }
 
     #if HAS_STEALTHCHOP
       inline bool get_stealthChop()                { return !this->en_spreadCycle(); }
       inline bool get_stored_stealthChop()         { return this->stored.stealthChop_enabled; }
       inline void refresh_stepping_mode()          { this->en_spreadCycle(!this->stored.stealthChop_enabled); }
       inline void set_stealthChop(const bool stch) { this->stored.stealthChop_enabled = stch; refresh_stepping_mode(); }
       inline bool toggle_stepping_mode()           { set_stealthChop(!this->stored.stealthChop_enabled); return get_stealthChop(); }
     #endif
 
-    void set_pwm_thrs(const uint32_t thrs) {
-      TMC2208Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
-      #if BOTH(HYBRID_THRESHOLD, HAS_LCD_MENU)
-        this->stored.hybrid_thrs = thrs;
-      #endif
-    }
-
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
+      void set_pwm_thrs(const uint32_t thrs) {
+        TMC2208Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
+        TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
+      }
     #endif
 
     #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
+
       #if ENABLED(HYBRID_THRESHOLD)
         inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
     #endif
 };
 
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2209Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(Stream * SerialPort, const float RS, const uint8_t addr) :
@@ -235,29 +230,25 @@ class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
       inline bool get_stored_stealthChop()         { return this->stored.stealthChop_enabled; }
       inline void refresh_stepping_mode()          { this->en_spreadCycle(!this->stored.stealthChop_enabled); }
       inline void set_stealthChop(const bool stch) { this->stored.stealthChop_enabled = stch; refresh_stepping_mode(); }
       inline bool toggle_stepping_mode()           { set_stealthChop(!this->stored.stealthChop_enabled); return get_stealthChop(); }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
+      void set_pwm_thrs(const uint32_t thrs) {
+        TMC2209Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
+        TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
+      }
     #endif
-
-    void set_pwm_thrs(const uint32_t thrs) {
-      TMC2209Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
-      #if BOTH(HYBRID_THRESHOLD, HAS_LCD_MENU)
-        this->stored.hybrid_thrs = thrs;
-      #endif
-    }
-
     #if USE_SENSORLESS
       inline int16_t homing_threshold() { return TMC2209Stepper::SGTHRS(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC2209Stepper::SGTHRS(sgt_val);
         TERN_(HAS_LCD_MENU, this->stored.homing_thrs = sgt_val);
       }
     #endif
 
     #if HAS_LCD_MENU

commit 253ee0c407120526b821c0f3251bda0afb69d934
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 16 04:04:07 2021 -0500

    Init pwm_thrs to 0 when HYBRID_THRESHOLD is off (#21623)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 1767313ba2..0d6105358d 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -113,26 +113,29 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
       inline bool get_stored_stealthChop()         { return this->stored.stealthChop_enabled; }
       inline void refresh_stepping_mode()          { this->en_pwm_mode(this->stored.stealthChop_enabled); }
       inline void set_stealthChop(const bool stch) { this->stored.stealthChop_enabled = stch; refresh_stepping_mode(); }
       inline bool toggle_stepping_mode()           { set_stealthChop(!this->stored.stealthChop_enabled); return get_stealthChop(); }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
-      void set_pwm_thrs(const uint32_t thrs) {
-        TMC::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
-        TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
-      }
     #endif
 
+    void set_pwm_thrs(const uint32_t thrs) {
+      TMC::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
+      #if BOTH(HYBRID_THRESHOLD, HAS_LCD_MENU)
+        this->stored.hybrid_thrs = thrs;
+      #endif
+    }
+
     #if USE_SENSORLESS
       inline int16_t homing_threshold() { return TMC::sgt(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC::sgt(sgt_val);
         TERN_(HAS_LCD_MENU, this->stored.homing_thrs = sgt_val);
       }
       #if ENABLED(SPI_ENDSTOPS)
         bool test_stall_status();
       #endif
@@ -178,33 +181,35 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
     inline uint16_t get_microstep_counter() { return TMC2208Stepper::MSCNT(); }
 
     #if HAS_STEALTHCHOP
       inline bool get_stealthChop()                { return !this->en_spreadCycle(); }
       inline bool get_stored_stealthChop()         { return this->stored.stealthChop_enabled; }
       inline void refresh_stepping_mode()          { this->en_spreadCycle(!this->stored.stealthChop_enabled); }
       inline void set_stealthChop(const bool stch) { this->stored.stealthChop_enabled = stch; refresh_stepping_mode(); }
       inline bool toggle_stepping_mode()           { set_stealthChop(!this->stored.stealthChop_enabled); return get_stealthChop(); }
     #endif
 
+    void set_pwm_thrs(const uint32_t thrs) {
+      TMC2208Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
+      #if BOTH(HYBRID_THRESHOLD, HAS_LCD_MENU)
+        this->stored.hybrid_thrs = thrs;
+      #endif
+    }
+
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
-      void set_pwm_thrs(const uint32_t thrs) {
-        TMC2208Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
-        TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
-      }
     #endif
 
     #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
-
       #if ENABLED(HYBRID_THRESHOLD)
         inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
     #endif
 };
 
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2209Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(Stream * SerialPort, const float RS, const uint8_t addr) :
@@ -230,25 +235,29 @@ class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
       inline bool get_stored_stealthChop()         { return this->stored.stealthChop_enabled; }
       inline void refresh_stepping_mode()          { this->en_spreadCycle(!this->stored.stealthChop_enabled); }
       inline void set_stealthChop(const bool stch) { this->stored.stealthChop_enabled = stch; refresh_stepping_mode(); }
       inline bool toggle_stepping_mode()           { set_stealthChop(!this->stored.stealthChop_enabled); return get_stealthChop(); }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
-      void set_pwm_thrs(const uint32_t thrs) {
-        TMC2209Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
-        TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
-      }
     #endif
+
+    void set_pwm_thrs(const uint32_t thrs) {
+      TMC2209Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
+      #if BOTH(HYBRID_THRESHOLD, HAS_LCD_MENU)
+        this->stored.hybrid_thrs = thrs;
+      #endif
+    }
+
     #if USE_SENSORLESS
       inline int16_t homing_threshold() { return TMC2209Stepper::SGTHRS(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC2209Stepper::SGTHRS(sgt_val);
         TERN_(HAS_LCD_MENU, this->stored.homing_thrs = sgt_val);
       }
     #endif
 
     #if HAS_LCD_MENU

commit 2d2291d00eab6159de24eb7ff74001b1d6dd29e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 24 05:40:28 2021 -0500

    More IntelliSense-friendly declarations

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index b21b89f68b..1767313ba2 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -63,23 +63,29 @@ class TMCStorage {
     #endif
 
     inline uint16_t getMilliamps() { return val_mA; }
 
     inline void printLabel() {
       SERIAL_CHAR(AXIS_LETTER);
       if (DRIVER_ID > '0') SERIAL_CHAR(DRIVER_ID);
     }
 
     struct {
-      TERN_(HAS_STEALTHCHOP, bool stealthChop_enabled = false);
-      TERN_(HYBRID_THRESHOLD, uint8_t hybrid_thrs = 0);
-      TERN_(USE_SENSORLESS, int16_t homing_thrs = 0);
+      #if ENABLED(HAS_STEALTHCHOP)
+        bool stealthChop_enabled = false;
+      #endif
+      #if ENABLED(HYBRID_THRESHOLD)
+        uint8_t hybrid_thrs = 0;
+      #endif
+      #if ENABLED(USE_SENSORLESS)
+        int16_t homing_thrs = 0;
+      #endif
     } stored;
 };
 
 template<class TMC, char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(const uint16_t cs_pin, const float RS) :
       TMC(cs_pin, RS)
       {}
     TMCMarlin(const uint16_t cs_pin, const float RS, const uint8_t axis_chain_index) :
@@ -356,21 +362,23 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
 
   // Track enabled status of stealthChop and only re-enable where applicable
   struct sensorless_t { bool x, y, z, x2, y2, z2, z3, z4; };
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     extern millis_t sg_guard_period;
     constexpr uint16_t default_sg_guard_duration = 400;
 
     struct slow_homing_t {
       xy_ulong_t acceleration;
-      TERN_(HAS_CLASSIC_JERK, xy_float_t jerk_xy);
+      #if ENABLED(HAS_CLASSIC_JERK)
+        xy_float_t jerk_xy;
+      #endif
     };
   #endif
 
   bool tmc_enable_stallguard(TMC2130Stepper &st);
   void tmc_disable_stallguard(TMC2130Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2209Stepper &st);
   void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2660Stepper);

commit 9630c2683c39468bf885c560a1768d8b377d9462
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Oct 24 01:37:45 2020 -0300

    More MKS UI cleanup, optimization (#19869)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index abde342307..b21b89f68b 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -96,23 +96,25 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
       this->val_mA = mA;
       TMC::rms_current(mA);
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC::rms_current(mA, mult);
     }
     inline uint16_t get_microstep_counter() { return TMC::MSCNT(); }
 
     #if HAS_STEALTHCHOP
-      inline void refresh_stepping_mode() { this->en_pwm_mode(this->stored.stealthChop_enabled); }
-      inline bool get_stealthChop() { return this->en_pwm_mode(); }
-      inline bool get_stored_stealthChop() { return this->stored.stealthChop_enabled; }
+      inline bool get_stealthChop()                { return this->en_pwm_mode(); }
+      inline bool get_stored_stealthChop()         { return this->stored.stealthChop_enabled; }
+      inline void refresh_stepping_mode()          { this->en_pwm_mode(this->stored.stealthChop_enabled); }
+      inline void set_stealthChop(const bool stch) { this->stored.stealthChop_enabled = stch; refresh_stepping_mode(); }
+      inline bool toggle_stepping_mode()           { set_stealthChop(!this->stored.stealthChop_enabled); return get_stealthChop(); }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
       }
@@ -163,23 +165,25 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA);
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA, mult);
     }
     inline uint16_t get_microstep_counter() { return TMC2208Stepper::MSCNT(); }
 
     #if HAS_STEALTHCHOP
-      inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
-      inline bool get_stealthChop() { return !this->en_spreadCycle(); }
-      inline bool get_stored_stealthChop() { return this->stored.stealthChop_enabled; }
+      inline bool get_stealthChop()                { return !this->en_spreadCycle(); }
+      inline bool get_stored_stealthChop()         { return this->stored.stealthChop_enabled; }
+      inline void refresh_stepping_mode()          { this->en_spreadCycle(!this->stored.stealthChop_enabled); }
+      inline void set_stealthChop(const bool stch) { this->stored.stealthChop_enabled = stch; refresh_stepping_mode(); }
+      inline bool toggle_stepping_mode()           { set_stealthChop(!this->stored.stealthChop_enabled); return get_stealthChop(); }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2208Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
       }
@@ -209,23 +213,25 @@ class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
       this->val_mA = mA;
       TMC2209Stepper::rms_current(mA);
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC2209Stepper::rms_current(mA, mult);
     }
     inline uint16_t get_microstep_counter() { return TMC2209Stepper::MSCNT(); }
 
     #if HAS_STEALTHCHOP
-      inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
-      inline bool get_stealthChop() { return !this->en_spreadCycle(); }
-      inline bool get_stored_stealthChop() { return this->stored.stealthChop_enabled; }
+      inline bool get_stealthChop()                { return !this->en_spreadCycle(); }
+      inline bool get_stored_stealthChop()         { return this->stored.stealthChop_enabled; }
+      inline void refresh_stepping_mode()          { this->en_spreadCycle(!this->stored.stealthChop_enabled); }
+      inline void set_stealthChop(const bool stch) { this->stored.stealthChop_enabled = stch; refresh_stepping_mode(); }
+      inline bool toggle_stepping_mode()           { set_stealthChop(!this->stored.stealthChop_enabled); return get_stealthChop(); }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2209Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
       }

commit c75e98dc846d9662a7f4a234a6a73215a48e9833
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 22 20:54:11 2020 -0500

    Shorten a method name

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 187cfda483..abde342307 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -97,22 +97,22 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
       TMC::rms_current(mA);
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC::rms_current(mA, mult);
     }
     inline uint16_t get_microstep_counter() { return TMC::MSCNT(); }
 
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { this->en_pwm_mode(this->stored.stealthChop_enabled); }
-      inline bool get_stealthChop_status() { return this->en_pwm_mode(); }
-      inline bool get_stored_stealthChop_status() { return this->stored.stealthChop_enabled; }
+      inline bool get_stealthChop() { return this->en_pwm_mode(); }
+      inline bool get_stored_stealthChop() { return this->stored.stealthChop_enabled; }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
       }
@@ -164,22 +164,22 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
       TMC2208Stepper::rms_current(mA);
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA, mult);
     }
     inline uint16_t get_microstep_counter() { return TMC2208Stepper::MSCNT(); }
 
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
-      inline bool get_stealthChop_status() { return !this->en_spreadCycle(); }
-      inline bool get_stored_stealthChop_status() { return this->stored.stealthChop_enabled; }
+      inline bool get_stealthChop() { return !this->en_spreadCycle(); }
+      inline bool get_stored_stealthChop() { return this->stored.stealthChop_enabled; }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2208Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
       }
@@ -210,22 +210,22 @@ class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
       TMC2209Stepper::rms_current(mA);
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC2209Stepper::rms_current(mA, mult);
     }
     inline uint16_t get_microstep_counter() { return TMC2209Stepper::MSCNT(); }
 
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
-      inline bool get_stealthChop_status() { return !this->en_spreadCycle(); }
-      inline bool get_stored_stealthChop_status() { return this->stored.stealthChop_enabled; }
+      inline bool get_stealthChop() { return !this->en_spreadCycle(); }
+      inline bool get_stored_stealthChop() { return this->stored.stealthChop_enabled; }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2209Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
       }

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index b65a1254c6..187cfda483 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -15,21 +15,21 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 #pragma once
 
 #include "../inc/MarlinConfig.h"
-#include "../lcd/ultralcd.h"
+#include "../lcd/marlinui.h"
 
 #if HAS_TRINAMIC_CONFIG
 
 #include <TMCStepper.h>
 #include "../module/planner.h"
 
 #define CHOPPER_DEFAULT_12V  { 3, -1, 1 }
 #define CHOPPER_DEFAULT_19V  { 4,  1, 1 }
 #define CHOPPER_DEFAULT_24V  { 4,  2, 1 }
 #define CHOPPER_DEFAULT_36V  { 5,  2, 4 }

commit 6831341ab483a49d7daad4c704bb684d3cbbf075
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 9 16:50:17 2020 -0500

    Batch appercase hex values

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index d96939c916..b65a1254c6 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -31,21 +31,21 @@
 
 #define CHOPPER_DEFAULT_12V  { 3, -1, 1 }
 #define CHOPPER_DEFAULT_19V  { 4,  1, 1 }
 #define CHOPPER_DEFAULT_24V  { 4,  2, 1 }
 #define CHOPPER_DEFAULT_36V  { 5,  2, 4 }
 #define CHOPPER_PRUSAMK3_24V { 3, -2, 6 }
 #define CHOPPER_MARLIN_119   { 5,  2, 3 }
 #define CHOPPER_09STEP_24V   { 3, -1, 5 }
 
 #if ENABLED(MONITOR_DRIVER_STATUS) && !defined(MONITOR_DRIVER_STATUS_INTERVAL_MS)
-  #define MONITOR_DRIVER_STATUS_INTERVAL_MS 500u
+  #define MONITOR_DRIVER_STATUS_INTERVAL_MS 500U
 #endif
 
 constexpr uint16_t _tmc_thrs(const uint16_t msteps, const uint32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
 
 template<char AXIS_LETTER, char DRIVER_ID>
 class TMCStorage {
   protected:
     // Only a child class has access to constructor => Don't create on its own! "Poor man's abstract class"

commit c04d5624da568c1069065902373f1abce11e03ba
Author: ManuelMcLure <manuel@mclure.org>
Date:   Sat Sep 12 20:59:20 2020 -0700

    Read from backup TMC StealthChop state (#19364)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 2779ae4ef4..d96939c916 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -98,20 +98,21 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC::rms_current(mA, mult);
     }
     inline uint16_t get_microstep_counter() { return TMC::MSCNT(); }
 
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { this->en_pwm_mode(this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return this->en_pwm_mode(); }
+      inline bool get_stored_stealthChop_status() { return this->stored.stealthChop_enabled; }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
       }
@@ -164,20 +165,21 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA, mult);
     }
     inline uint16_t get_microstep_counter() { return TMC2208Stepper::MSCNT(); }
 
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return !this->en_spreadCycle(); }
+      inline bool get_stored_stealthChop_status() { return this->stored.stealthChop_enabled; }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2208Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
       }
@@ -209,20 +211,21 @@ class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC2209Stepper::rms_current(mA, mult);
     }
     inline uint16_t get_microstep_counter() { return TMC2209Stepper::MSCNT(); }
 
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return !this->en_spreadCycle(); }
+      inline bool get_stored_stealthChop_status() { return this->stored.stealthChop_enabled; }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2209Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
       }

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 6b7501723c..2779ae4ef4 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 #pragma once
 
 #include "../inc/MarlinConfig.h"
 #include "../lcd/ultralcd.h"
 
 #if HAS_TRINAMIC_CONFIG
 
 #include <TMCStepper.h>

commit 0ddef5544a12847eff9163996844c5cd329cecc0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jul 18 18:54:44 2020 -0500

    Misc formatting, cleanup

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index de19ddf00a..6b7501723c 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -28,21 +28,21 @@
 
 #include <TMCStepper.h>
 #include "../module/planner.h"
 
 #define CHOPPER_DEFAULT_12V  { 3, -1, 1 }
 #define CHOPPER_DEFAULT_19V  { 4,  1, 1 }
 #define CHOPPER_DEFAULT_24V  { 4,  2, 1 }
 #define CHOPPER_DEFAULT_36V  { 5,  2, 4 }
 #define CHOPPER_PRUSAMK3_24V { 3, -2, 6 }
 #define CHOPPER_MARLIN_119   { 5,  2, 3 }
-#define CHOPPER_09STEP_24V   { 3, -1, 5 } 
+#define CHOPPER_09STEP_24V   { 3, -1, 5 }
 
 #if ENABLED(MONITOR_DRIVER_STATUS) && !defined(MONITOR_DRIVER_STATUS_INTERVAL_MS)
   #define MONITOR_DRIVER_STATUS_INTERVAL_MS 500u
 #endif
 
 constexpr uint16_t _tmc_thrs(const uint16_t msteps, const uint32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
 
 template<char AXIS_LETTER, char DRIVER_ID>

commit 1d6868852ba0f05312bb2594073a807ae98ead42
Author: Evgeny Z <Evg33@users.noreply.github.com>
Date:   Fri Jul 17 05:40:56 2020 +0300

    Chopper Timing Preset for 24V 0.9¬∞ (#18662)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 4bf68c4745..de19ddf00a 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -28,20 +28,21 @@
 
 #include <TMCStepper.h>
 #include "../module/planner.h"
 
 #define CHOPPER_DEFAULT_12V  { 3, -1, 1 }
 #define CHOPPER_DEFAULT_19V  { 4,  1, 1 }
 #define CHOPPER_DEFAULT_24V  { 4,  2, 1 }
 #define CHOPPER_DEFAULT_36V  { 5,  2, 4 }
 #define CHOPPER_PRUSAMK3_24V { 3, -2, 6 }
 #define CHOPPER_MARLIN_119   { 5,  2, 3 }
+#define CHOPPER_09STEP_24V   { 3, -1, 5 } 
 
 #if ENABLED(MONITOR_DRIVER_STATUS) && !defined(MONITOR_DRIVER_STATUS_INTERVAL_MS)
   #define MONITOR_DRIVER_STATUS_INTERVAL_MS 500u
 #endif
 
 constexpr uint16_t _tmc_thrs(const uint16_t msteps, const uint32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
 
 template<char AXIS_LETTER, char DRIVER_ID>

commit b6cd8b230eec8e700b533c2912092a6bf9bf325c
Author: Jason Smith <jason.inet@gmail.com>
Date:   Mon Jun 22 12:25:46 2020 -0700

    TMCStepper 0.7.0 followup (#18388)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 805385f23f..4bf68c4745 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -190,21 +190,21 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
       #endif
     #endif
 };
 
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2209Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(Stream * SerialPort, const float RS, const uint8_t addr) :
       TMC2209Stepper(SerialPort, RS, addr)
       {}
-    TMCMarlin(const uint16_t RX, const uint16_t TX, const float RS, const uint8_t addr, const bool) :
+    TMCMarlin(const uint16_t RX, const uint16_t TX, const float RS, const uint8_t addr) :
       TMC2209Stepper(RX, TX, RS, addr)
       {}
     uint8_t get_address() { return slave_address; }
     uint16_t rms_current() { return TMC2209Stepper::rms_current(); }
     inline void rms_current(const uint16_t mA) {
       this->val_mA = mA;
       TMC2209Stepper::rms_current(mA);
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;

commit 31167c158b6ed7fc7a5105c7f7848ae85058c11a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jun 21 22:10:29 2020 -0500

    TMCStepper 0.7.0

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 77e4ce517c..805385f23f 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -145,22 +145,22 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
 
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2208Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(Stream * SerialPort, const float RS, const uint8_t) :
       TMC2208Stepper(SerialPort, RS)
       {}
     TMCMarlin(Stream * SerialPort, const float RS, uint8_t addr, const uint16_t mul_pin1, const uint16_t mul_pin2) :
       TMC2208Stepper(SerialPort, RS, addr, mul_pin1, mul_pin2)
      {}
-    TMCMarlin(const uint16_t RX, const uint16_t TX, const float RS, const uint8_t, const bool has_rx=true) :
-      TMC2208Stepper(RX, TX, RS, has_rx)
+    TMCMarlin(const uint16_t RX, const uint16_t TX, const float RS, const uint8_t) :
+      TMC2208Stepper(RX, TX, RS)
       {}
 
     uint16_t rms_current() { return TMC2208Stepper::rms_current(); }
     inline void rms_current(const uint16_t mA) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA);
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA, mult);

commit fe7452c5cbc9086abfdaeac316351cfa17de61c4
Author: George Fu <nailao_5918@163.com>
Date:   Tue May 26 04:48:33 2020 +0800

    TMC serial multiplexer, FYSETC AIO-II (#18080)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 73e9109ea2..77e4ce517c 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -142,23 +142,27 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
     static constexpr int8_t sgt_min = -64,
                             sgt_max =  63;
 };
 
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2208Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(Stream * SerialPort, const float RS, const uint8_t) :
       TMC2208Stepper(SerialPort, RS)
       {}
+    TMCMarlin(Stream * SerialPort, const float RS, uint8_t addr, const uint16_t mul_pin1, const uint16_t mul_pin2) :
+      TMC2208Stepper(SerialPort, RS, addr, mul_pin1, mul_pin2)
+     {}
     TMCMarlin(const uint16_t RX, const uint16_t TX, const float RS, const uint8_t, const bool has_rx=true) :
       TMC2208Stepper(RX, TX, RS, has_rx)
       {}
+
     uint16_t rms_current() { return TMC2208Stepper::rms_current(); }
     inline void rms_current(const uint16_t mA) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA);
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA, mult);
     }
     inline uint16_t get_microstep_counter() { return TMC2208Stepper::MSCNT(); }

commit 2c959123e5972920bfb40ac519bfaa5b0b7c6d67
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 28 04:31:59 2020 -0500

    Clean up whitespace

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index d7b6a944df..73e9109ea2 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -93,21 +93,21 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
     inline uint16_t rms_current() { return TMC::rms_current(); }
     inline void rms_current(uint16_t mA) {
       this->val_mA = mA;
       TMC::rms_current(mA);
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC::rms_current(mA, mult);
     }
     inline uint16_t get_microstep_counter() { return TMC::MSCNT(); }
- 
+
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { this->en_pwm_mode(this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return this->en_pwm_mode(); }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 6838aa433c..d7b6a944df 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -62,29 +62,23 @@ class TMCStorage {
     #endif
 
     inline uint16_t getMilliamps() { return val_mA; }
 
     inline void printLabel() {
       SERIAL_CHAR(AXIS_LETTER);
       if (DRIVER_ID > '0') SERIAL_CHAR(DRIVER_ID);
     }
 
     struct {
-      #if HAS_STEALTHCHOP
-        bool stealthChop_enabled = false;
-      #endif
-      #if ENABLED(HYBRID_THRESHOLD)
-        uint8_t hybrid_thrs = 0;
-      #endif
-      #if USE_SENSORLESS
-        int16_t homing_thrs = 0;
-      #endif
+      TERN_(HAS_STEALTHCHOP, bool stealthChop_enabled = false);
+      TERN_(HYBRID_THRESHOLD, uint8_t hybrid_thrs = 0);
+      TERN_(USE_SENSORLESS, int16_t homing_thrs = 0);
     } stored;
 };
 
 template<class TMC, char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(const uint16_t cs_pin, const float RS) :
       TMC(cs_pin, RS)
       {}
     TMCMarlin(const uint16_t cs_pin, const float RS, const uint8_t axis_chain_index) :
@@ -111,34 +105,30 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
       inline void refresh_stepping_mode() { this->en_pwm_mode(this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return this->en_pwm_mode(); }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
-        #if HAS_LCD_MENU
-          this->stored.hybrid_thrs = thrs;
-        #endif
+        TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
       }
     #endif
 
     #if USE_SENSORLESS
       inline int16_t homing_threshold() { return TMC::sgt(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC::sgt(sgt_val);
-        #if HAS_LCD_MENU
-          this->stored.homing_thrs = sgt_val;
-        #endif
+        TERN_(HAS_LCD_MENU, this->stored.homing_thrs = sgt_val);
       }
       #if ENABLED(SPI_ENDSTOPS)
         bool test_stall_status();
       #endif
     #endif
 
     #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
@@ -177,23 +167,21 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
       inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return !this->en_spreadCycle(); }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2208Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
-        #if HAS_LCD_MENU
-          this->stored.hybrid_thrs = thrs;
-        #endif
+        TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
       }
     #endif
 
     #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
         inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
     #endif
@@ -224,33 +212,29 @@ class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
       inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return !this->en_spreadCycle(); }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2209Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
-        #if HAS_LCD_MENU
-          this->stored.hybrid_thrs = thrs;
-        #endif
+        TERN_(HAS_LCD_MENU, this->stored.hybrid_thrs = thrs);
       }
     #endif
     #if USE_SENSORLESS
       inline int16_t homing_threshold() { return TMC2209Stepper::SGTHRS(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC2209Stepper::SGTHRS(sgt_val);
-        #if HAS_LCD_MENU
-          this->stored.homing_thrs = sgt_val;
-        #endif
+        TERN_(HAS_LCD_MENU, this->stored.homing_thrs = sgt_val);
       }
     #endif
 
     #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
         inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
       #if USE_SENSORLESS
@@ -276,23 +260,21 @@ class TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC266
       this->val_mA = mA;
       TMC2660Stepper::rms_current(mA);
     }
     inline uint16_t get_microstep_counter() { return TMC2660Stepper::mstep(); }
 
     #if USE_SENSORLESS
       inline int16_t homing_threshold() { return TMC2660Stepper::sgt(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC2660Stepper::sgt(sgt_val);
-        #if HAS_LCD_MENU
-          this->stored.homing_thrs = sgt_val;
-        #endif
+        TERN_(HAS_LCD_MENU, this->stored.homing_thrs = sgt_val);
       }
     #endif
 
     #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if USE_SENSORLESS
         inline void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
@@ -360,23 +342,21 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
 
   // Track enabled status of stealthChop and only re-enable where applicable
   struct sensorless_t { bool x, y, z, x2, y2, z2, z3, z4; };
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     extern millis_t sg_guard_period;
     constexpr uint16_t default_sg_guard_duration = 400;
 
     struct slow_homing_t {
       xy_ulong_t acceleration;
-      #if HAS_CLASSIC_JERK
-        xy_float_t jerk_xy;
-      #endif
+      TERN_(HAS_CLASSIC_JERK, xy_float_t jerk_xy);
     };
   #endif
 
   bool tmc_enable_stallguard(TMC2130Stepper &st);
   void tmc_disable_stallguard(TMC2130Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2209Stepper &st);
   void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2660Stepper);

commit ccfd5c1010270493f0c7ddc7a5ab62dc5e09def3
Author: Fabio Santos <fabiosan@live.com>
Date:   Mon Apr 20 06:08:00 2020 -0700

    Trinamic steppers Homing Phase (#17299)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index ccae8b660c..6838aa433c 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -98,21 +98,22 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
       {}
     inline uint16_t rms_current() { return TMC::rms_current(); }
     inline void rms_current(uint16_t mA) {
       this->val_mA = mA;
       TMC::rms_current(mA);
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC::rms_current(mA, mult);
     }
-
+    inline uint16_t get_microstep_counter() { return TMC::MSCNT(); }
+ 
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { this->en_pwm_mode(this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return this->en_pwm_mode(); }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
@@ -163,20 +164,21 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
       {}
     uint16_t rms_current() { return TMC2208Stepper::rms_current(); }
     inline void rms_current(const uint16_t mA) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA);
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA, mult);
     }
+    inline uint16_t get_microstep_counter() { return TMC2208Stepper::MSCNT(); }
 
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return !this->en_spreadCycle(); }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
@@ -209,20 +211,21 @@ class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
     uint8_t get_address() { return slave_address; }
     uint16_t rms_current() { return TMC2209Stepper::rms_current(); }
     inline void rms_current(const uint16_t mA) {
       this->val_mA = mA;
       TMC2209Stepper::rms_current(mA);
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC2209Stepper::rms_current(mA, mult);
     }
+    inline uint16_t get_microstep_counter() { return TMC2209Stepper::MSCNT(); }
 
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return !this->en_spreadCycle(); }
     #endif
 
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
@@ -266,20 +269,21 @@ class TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC266
       TMC2660Stepper(cs_pin, RS)
       {}
     TMCMarlin(const uint16_t CS, const float RS, const uint16_t pinMOSI, const uint16_t pinMISO, const uint16_t pinSCK, const uint8_t) :
       TMC2660Stepper(CS, RS, pinMOSI, pinMISO, pinSCK)
       {}
     inline uint16_t rms_current() { return TMC2660Stepper::rms_current(); }
     inline void rms_current(const uint16_t mA) {
       this->val_mA = mA;
       TMC2660Stepper::rms_current(mA);
     }
+    inline uint16_t get_microstep_counter() { return TMC2660Stepper::mstep(); }
 
     #if USE_SENSORLESS
       inline int16_t homing_threshold() { return TMC2660Stepper::sgt(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC2660Stepper::sgt(sgt_val);
         #if HAS_LCD_MENU
           this->stored.homing_thrs = sgt_val;
         #endif
       }

commit b1a50d54e2a6f8e415a72e0e2d275304029d8ada
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 2 12:03:43 2020 -0600

    HAS_TRINAMIC => HAS_TRINAMIC_CONFIG

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 5102a9d5bf..ccae8b660c 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -17,21 +17,21 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 #pragma once
 
 #include "../inc/MarlinConfig.h"
 #include "../lcd/ultralcd.h"
 
-#if HAS_TRINAMIC
+#if HAS_TRINAMIC_CONFIG
 
 #include <TMCStepper.h>
 #include "../module/planner.h"
 
 #define CHOPPER_DEFAULT_12V  { 3, -1, 1 }
 #define CHOPPER_DEFAULT_19V  { 4,  1, 1 }
 #define CHOPPER_DEFAULT_24V  { 4,  2, 1 }
 #define CHOPPER_DEFAULT_36V  { 5,  2, 4 }
 #define CHOPPER_PRUSAMK3_24V { 3, -2, 6 }
 #define CHOPPER_MARLIN_119   { 5,  2, 3 }
@@ -393,11 +393,11 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
       return drv_status.stallGuard;
     }
   #endif // SPI_ENDSTOPS
 
 #endif // USE_SENSORLESS
 
 #if HAS_TMC_SPI
   void tmc_init_cs_pins();
 #endif
 
-#endif // HAS_TRINAMIC
+#endif // HAS_TRINAMIC_CONFIG

commit 18a7276909a3e2aa1761ba0c46577a8f6e7baedb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 9 21:22:26 2020 -0600

    Revert "Coolstep for TMC2130, 2209, 5130, 5160"
    
    Reverting #16790 as not ready for primetime.

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 584076e478..5102a9d5bf 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -130,27 +130,20 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
         TMC::sgt(sgt_val);
         #if HAS_LCD_MENU
           this->stored.homing_thrs = sgt_val;
         #endif
       }
       #if ENABLED(SPI_ENDSTOPS)
         bool test_stall_status();
       #endif
     #endif
 
-    uint32_t get_cool_thrs() {
-      return _tmc_thrs(this->microsteps(), this->TCOOLTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
-    }
-    void set_cool_thrs(const uint32_t thrs) {
-      TMC::TCOOLTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
-    }
-
     #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
         inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
       #if USE_SENSORLESS
         inline void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
@@ -233,41 +226,34 @@ class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2209Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         #if HAS_LCD_MENU
           this->stored.hybrid_thrs = thrs;
         #endif
       }
     #endif
-
-    uint32_t get_cool_thrs() {
-      return _tmc_thrs(this->microsteps(), this->TCOOLTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
-    }
-    void set_cool_thrs(const uint32_t thrs) {
-      TMC2209Stepper::TCOOLTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
-    }
-
     #if USE_SENSORLESS
       inline int16_t homing_threshold() { return TMC2209Stepper::SGTHRS(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC2209Stepper::SGTHRS(sgt_val);
         #if HAS_LCD_MENU
           this->stored.homing_thrs = sgt_val;
         #endif
       }
     #endif
 
     #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
+
       #if ENABLED(HYBRID_THRESHOLD)
         inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
       #if USE_SENSORLESS
         inline void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
 
     static constexpr uint8_t sgt_min = 0,
                              sgt_max = 255;

commit 894762259b072407504ee584103680b103310026
Author: Fabio Santos <fabiosan@live.com>
Date:   Sat Feb 8 19:01:57 2020 -0800

    Coolstep for TMC2130, 2209, 5130, 5160 (#16790)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 2c0a87703e..584076e478 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -103,59 +103,69 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC::rms_current(mA, mult);
     }
 
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { this->en_pwm_mode(this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return this->en_pwm_mode(); }
     #endif
+
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         #if HAS_LCD_MENU
           this->stored.hybrid_thrs = thrs;
         #endif
       }
     #endif
+
     #if USE_SENSORLESS
       inline int16_t homing_threshold() { return TMC::sgt(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC::sgt(sgt_val);
         #if HAS_LCD_MENU
           this->stored.homing_thrs = sgt_val;
         #endif
       }
       #if ENABLED(SPI_ENDSTOPS)
         bool test_stall_status();
       #endif
     #endif
 
+    uint32_t get_cool_thrs() {
+      return _tmc_thrs(this->microsteps(), this->TCOOLTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
+    }
+    void set_cool_thrs(const uint32_t thrs) {
+      TMC::TCOOLTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
+    }
+
     #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
         inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
       #if USE_SENSORLESS
         inline void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
 
     static constexpr int8_t sgt_min = -64,
                             sgt_max =  63;
 };
+
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2208Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(Stream * SerialPort, const float RS, const uint8_t) :
       TMC2208Stepper(SerialPort, RS)
       {}
     TMCMarlin(const uint16_t RX, const uint16_t TX, const float RS, const uint8_t, const bool has_rx=true) :
       TMC2208Stepper(RX, TX, RS, has_rx)
       {}
     uint16_t rms_current() { return TMC2208Stepper::rms_current(); }
@@ -165,20 +175,21 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA, mult);
     }
 
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return !this->en_spreadCycle(); }
     #endif
+
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2208Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         #if HAS_LCD_MENU
           this->stored.hybrid_thrs = thrs;
         #endif
       }
@@ -210,45 +221,53 @@ class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC2209Stepper::rms_current(mA, mult);
     }
 
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return !this->en_spreadCycle(); }
     #endif
+
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC2209Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         #if HAS_LCD_MENU
           this->stored.hybrid_thrs = thrs;
         #endif
       }
     #endif
+
+    uint32_t get_cool_thrs() {
+      return _tmc_thrs(this->microsteps(), this->TCOOLTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
+    }
+    void set_cool_thrs(const uint32_t thrs) {
+      TMC2209Stepper::TCOOLTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
+    }
+
     #if USE_SENSORLESS
       inline int16_t homing_threshold() { return TMC2209Stepper::SGTHRS(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC2209Stepper::SGTHRS(sgt_val);
         #if HAS_LCD_MENU
           this->stored.homing_thrs = sgt_val;
         #endif
       }
     #endif
 
     #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
-
       #if ENABLED(HYBRID_THRESHOLD)
         inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
       #if USE_SENSORLESS
         inline void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
 
     static constexpr uint8_t sgt_min = 0,
                              sgt_max = 255;
@@ -384,15 +403,15 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
       drv_status.sr = this->DRV_STATUS();
 
       this->switchCSpin(HIGH);
 
       return drv_status.stallGuard;
     }
   #endif // SPI_ENDSTOPS
 
 #endif // USE_SENSORLESS
 
-#if TMC_HAS_SPI
+#if HAS_TMC_SPI
   void tmc_init_cs_pins();
 #endif
 
 #endif // HAS_TRINAMIC

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index a6d4447d45..2c0a87703e 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 0fcf2b1110d9f0d362e5aab9cc73d963710e9865
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jan 20 00:35:07 2020 -0500

    Quad Z stepper support (#16277)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 35b3328a03..a6d4447d45 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -343,21 +343,21 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
 /**
  * TMC2130-specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually-exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if USE_SENSORLESS
 
   // Track enabled status of stealthChop and only re-enable where applicable
-  struct sensorless_t { bool x, y, z, x2, y2, z2, z3; };
+  struct sensorless_t { bool x, y, z, x2, y2, z2, z3, z4; };
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     extern millis_t sg_guard_period;
     constexpr uint16_t default_sg_guard_duration = 400;
 
     struct slow_homing_t {
       xy_ulong_t acceleration;
       #if HAS_CLASSIC_JERK
         xy_float_t jerk_xy;
       #endif

commit 1d0452c41e95f94f78453f293475d4fb3e9c0061
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 3 17:11:36 2020 -0600

    Standardize drivers.h values, add class indirection (#16448)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 8fa143387a..35b3328a03 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -22,36 +22,20 @@
 #pragma once
 
 #include "../inc/MarlinConfig.h"
 #include "../lcd/ultralcd.h"
 
 #if HAS_TRINAMIC
 
 #include <TMCStepper.h>
 #include "../module/planner.h"
 
-#define TMC_X_LABEL 'X', '0'
-#define TMC_Y_LABEL 'Y', '0'
-#define TMC_Z_LABEL 'Z', '0'
-
-#define TMC_X2_LABEL 'X', '2'
-#define TMC_Y2_LABEL 'Y', '2'
-#define TMC_Z2_LABEL 'Z', '2'
-#define TMC_Z3_LABEL 'Z', '3'
-
-#define TMC_E0_LABEL 'E', '0'
-#define TMC_E1_LABEL 'E', '1'
-#define TMC_E2_LABEL 'E', '2'
-#define TMC_E3_LABEL 'E', '3'
-#define TMC_E4_LABEL 'E', '4'
-#define TMC_E5_LABEL 'E', '5'
-
 #define CHOPPER_DEFAULT_12V  { 3, -1, 1 }
 #define CHOPPER_DEFAULT_19V  { 4,  1, 1 }
 #define CHOPPER_DEFAULT_24V  { 4,  2, 1 }
 #define CHOPPER_DEFAULT_36V  { 5,  2, 4 }
 #define CHOPPER_PRUSAMK3_24V { 3, -2, 6 }
 #define CHOPPER_MARLIN_119   { 5,  2, 3 }
 
 #if ENABLED(MONITOR_DRIVER_STATUS) && !defined(MONITOR_DRIVER_STATUS_INTERVAL_MS)
   #define MONITOR_DRIVER_STATUS_INTERVAL_MS 500u
 #endif

commit 27943f9e31a4c16d981e437447f143972c92f835
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 30 06:59:44 2019 -0600

    Multiple axis TMC OTPW step down (#16044)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 3e02288714..8fa143387a 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -338,21 +338,21 @@ void tmc_print_current(TMC &st) {
 #endif
 #if USE_SENSORLESS
   template<typename TMC>
   void tmc_print_sgt(TMC &st) {
     st.printLabel();
     SERIAL_ECHOPGM(" homing sensitivity: ");
     SERIAL_PRINTLN(st.homing_threshold(), DEC);
   }
 #endif
 
-void monitor_tmc_driver();
+void monitor_tmc_drivers();
 void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z, const bool test_e);
 
 #if ENABLED(TMC_DEBUG)
   #if ENABLED(MONITOR_DRIVER_STATUS)
     void tmc_set_report_interval(const uint16_t update_interval);
   #endif
   void tmc_report_all(const bool print_x, const bool print_y, const bool print_z, const bool print_e);
   void tmc_get_registers(const bool print_x, const bool print_y, const bool print_z, const bool print_e);
 #endif
 

commit d9b0b964be23eccc42cf1a1564ea774fab19139f
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Thu Nov 7 00:57:48 2019 +0200

    Fix TMC2208 HW Serial constructor (#15782)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index e0c9170ae5..3e02288714 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -162,21 +162,21 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
       #endif
     #endif
 
     static constexpr int8_t sgt_min = -64,
                             sgt_max =  63;
 };
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2208Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(Stream * SerialPort, const float RS, const uint8_t) :
-      TMC2208Stepper(SerialPort, RS, /*has_rx=*/true)
+      TMC2208Stepper(SerialPort, RS)
       {}
     TMCMarlin(const uint16_t RX, const uint16_t TX, const float RS, const uint8_t, const bool has_rx=true) :
       TMC2208Stepper(RX, TX, RS, has_rx)
       {}
     uint16_t rms_current() { return TMC2208Stepper::rms_current(); }
     inline void rms_current(const uint16_t mA) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA);
     }
     inline void rms_current(const uint16_t mA, const float mult) {

commit 437978d349d48a575b923eb4a6e020e5b42dadd5
Author: Markus Towara <towara@stce.rwth-aachen.de>
Date:   Tue Oct 15 18:34:45 2019 +0200

    Bring SPI_SENSORLESS code up to date (#15560)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 8d0435b4a6..e0c9170ae5 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -386,47 +386,29 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
   bool tmc_enable_stallguard(TMC2209Stepper &st);
   void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2660Stepper);
   void tmc_disable_stallguard(TMC2660Stepper, const bool);
 
   #if ENABLED(SPI_ENDSTOPS)
 
     template<class TMC, char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
     bool TMCMarlin<TMC, AXIS_LETTER, DRIVER_ID, AXIS_ID>::test_stall_status() {
-      uint16_t sg_result = 0;
-
       this->switchCSpin(LOW);
 
-      if (this->TMC_SW_SPI != nullptr) {
-        this->TMC_SW_SPI->transfer(TMC2130_n::DRV_STATUS_t::address);
-        this->TMC_SW_SPI->transfer16(0);
-        // We only care about the last 10 bits
-        sg_result = this->TMC_SW_SPI->transfer(0);
-        sg_result <<= 8;
-        sg_result |= this->TMC_SW_SPI->transfer(0);
-      }
-      else {
-        SPI.beginTransaction(SPISettings(16000000/8, MSBFIRST, SPI_MODE3));
-        // Read DRV_STATUS
-        SPI.transfer(TMC2130_n::DRV_STATUS_t::address);
-        SPI.transfer16(0);
-        // We only care about the last 10 bits
-        sg_result = SPI.transfer(0);
-        sg_result <<= 8;
-        sg_result |= SPI.transfer(0);
-        SPI.endTransaction();
-      }
+      // read stallGuard flag from TMC library, will handle HW and SW SPI
+      TMC2130_n::DRV_STATUS_t drv_status{0};
+      drv_status.sr = this->DRV_STATUS();
+
       this->switchCSpin(HIGH);
 
-      return (sg_result & 0x3FF) == 0;
+      return drv_status.stallGuard;
     }
-
   #endif // SPI_ENDSTOPS
 
 #endif // USE_SENSORLESS
 
 #if TMC_HAS_SPI
   void tmc_init_cs_pins();
 #endif
 
 #endif // HAS_TRINAMIC

commit 178dcd6fd8ce1d2eea0cbb79b7f384e48b5ed6e5
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Sun Sep 29 05:47:20 2019 -0500

    SPI chaining with TMCStepper simplified interface (#15179)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index bea5e14e9a..8d0435b4a6 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -96,23 +96,29 @@ class TMCStorage {
       #endif
     } stored;
 };
 
 template<class TMC, char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(const uint16_t cs_pin, const float RS) :
       TMC(cs_pin, RS)
       {}
+    TMCMarlin(const uint16_t cs_pin, const float RS, const uint8_t axis_chain_index) :
+      TMC(cs_pin, RS, axis_chain_index)
+      {}
     TMCMarlin(const uint16_t CS, const float RS, const uint16_t pinMOSI, const uint16_t pinMISO, const uint16_t pinSCK) :
       TMC(CS, RS, pinMOSI, pinMISO, pinSCK)
       {}
+    TMCMarlin(const uint16_t CS, const float RS, const uint16_t pinMOSI, const uint16_t pinMISO, const uint16_t pinSCK, const uint8_t axis_chain_index) :
+      TMC(CS, RS, pinMOSI, pinMISO, pinSCK,  axis_chain_index)
+      {}
     inline uint16_t rms_current() { return TMC::rms_current(); }
     inline void rms_current(uint16_t mA) {
       this->val_mA = mA;
       TMC::rms_current(mA);
     }
     inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC::rms_current(mA, mult);
     }
 
@@ -260,24 +266,24 @@ class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
       #endif
     #endif
 
     static constexpr uint8_t sgt_min = 0,
                              sgt_max = 255;
 };
 
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2660Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
-    TMCMarlin(const uint16_t cs_pin, const float RS) :
+    TMCMarlin(const uint16_t cs_pin, const float RS, const uint8_t) :
       TMC2660Stepper(cs_pin, RS)
       {}
-    TMCMarlin(const uint16_t CS, const float RS, const uint16_t pinMOSI, const uint16_t pinMISO, const uint16_t pinSCK) :
+    TMCMarlin(const uint16_t CS, const float RS, const uint16_t pinMOSI, const uint16_t pinMISO, const uint16_t pinSCK, const uint8_t) :
       TMC2660Stepper(CS, RS, pinMOSI, pinMISO, pinSCK)
       {}
     inline uint16_t rms_current() { return TMC2660Stepper::rms_current(); }
     inline void rms_current(const uint16_t mA) {
       this->val_mA = mA;
       TMC2660Stepper::rms_current(mA);
     }
 
     #if USE_SENSORLESS
       inline int16_t homing_threshold() { return TMC2660Stepper::sgt(); }

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index b5b45089b9..bea5e14e9a 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -360,23 +360,23 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
 #if USE_SENSORLESS
 
   // Track enabled status of stealthChop and only re-enable where applicable
   struct sensorless_t { bool x, y, z, x2, y2, z2, z3; };
 
   #if ENABLED(IMPROVE_HOMING_RELIABILITY)
     extern millis_t sg_guard_period;
     constexpr uint16_t default_sg_guard_duration = 400;
 
     struct slow_homing_t {
-      struct { uint32_t x, y; } acceleration;
+      xy_ulong_t acceleration;
       #if HAS_CLASSIC_JERK
-        struct { float x, y; } jerk;
+        xy_float_t jerk_xy;
       #endif
     };
   #endif
 
   bool tmc_enable_stallguard(TMC2130Stepper &st);
   void tmc_disable_stallguard(TMC2130Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2209Stepper &st);
   void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth);
 

commit d4974ea719ceba2d76a678f77942d0b92e8fecb8
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Mon Aug 5 06:22:58 2019 +0300

    TMC SPI Endstops and Improved Sensorless Homing (#14044)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index a3eb49a1e0..b5b45089b9 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -133,20 +133,23 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
     #endif
     #if USE_SENSORLESS
       inline int16_t homing_threshold() { return TMC::sgt(); }
       void homing_threshold(int16_t sgt_val) {
         sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC::sgt(sgt_val);
         #if HAS_LCD_MENU
           this->stored.homing_thrs = sgt_val;
         #endif
       }
+      #if ENABLED(SPI_ENDSTOPS)
+        bool test_stall_status();
+      #endif
     #endif
 
     #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
         inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
       #if USE_SENSORLESS
         inline void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
@@ -348,28 +351,76 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
 #endif
 
 /**
  * TMC2130-specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually-exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if USE_SENSORLESS
+
   // Track enabled status of stealthChop and only re-enable where applicable
   struct sensorless_t { bool x, y, z, x2, y2, z2, z3; };
 
+  #if ENABLED(IMPROVE_HOMING_RELIABILITY)
+    extern millis_t sg_guard_period;
+    constexpr uint16_t default_sg_guard_duration = 400;
+
+    struct slow_homing_t {
+      struct { uint32_t x, y; } acceleration;
+      #if HAS_CLASSIC_JERK
+        struct { float x, y; } jerk;
+      #endif
+    };
+  #endif
+
   bool tmc_enable_stallguard(TMC2130Stepper &st);
   void tmc_disable_stallguard(TMC2130Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2209Stepper &st);
   void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2660Stepper);
   void tmc_disable_stallguard(TMC2660Stepper, const bool);
-#endif
+
+  #if ENABLED(SPI_ENDSTOPS)
+
+    template<class TMC, char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+    bool TMCMarlin<TMC, AXIS_LETTER, DRIVER_ID, AXIS_ID>::test_stall_status() {
+      uint16_t sg_result = 0;
+
+      this->switchCSpin(LOW);
+
+      if (this->TMC_SW_SPI != nullptr) {
+        this->TMC_SW_SPI->transfer(TMC2130_n::DRV_STATUS_t::address);
+        this->TMC_SW_SPI->transfer16(0);
+        // We only care about the last 10 bits
+        sg_result = this->TMC_SW_SPI->transfer(0);
+        sg_result <<= 8;
+        sg_result |= this->TMC_SW_SPI->transfer(0);
+      }
+      else {
+        SPI.beginTransaction(SPISettings(16000000/8, MSBFIRST, SPI_MODE3));
+        // Read DRV_STATUS
+        SPI.transfer(TMC2130_n::DRV_STATUS_t::address);
+        SPI.transfer16(0);
+        // We only care about the last 10 bits
+        sg_result = SPI.transfer(0);
+        sg_result <<= 8;
+        sg_result |= SPI.transfer(0);
+        SPI.endTransaction();
+      }
+      this->switchCSpin(HIGH);
+
+      return (sg_result & 0x3FF) == 0;
+    }
+
+  #endif // SPI_ENDSTOPS
+
+#endif // USE_SENSORLESS
 
 #if TMC_HAS_SPI
   void tmc_init_cs_pins();
 #endif
 
 #endif // HAS_TRINAMIC

commit 1088846caef6f660d5af65e1725a6a6deeef16fd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 24 01:52:36 2019 -0500

    Cosmetic updates from 14044

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 1df9a1a3b3..a3eb49a1e0 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -341,31 +341,29 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
 
 #if ENABLED(TMC_DEBUG)
   #if ENABLED(MONITOR_DRIVER_STATUS)
     void tmc_set_report_interval(const uint16_t update_interval);
   #endif
   void tmc_report_all(const bool print_x, const bool print_y, const bool print_z, const bool print_e);
   void tmc_get_registers(const bool print_x, const bool print_y, const bool print_z, const bool print_e);
 #endif
 
 /**
- * TMC2130 specific sensorless homing using stallGuard2.
+ * TMC2130-specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
- * spreadCycle and stealthChop are mutually exclusive.
+ * spreadCycle and stealthChop are mutually-exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if USE_SENSORLESS
   // Track enabled status of stealthChop and only re-enable where applicable
-  struct sensorless_t {
-    bool x, y, z, x2, y2, z2, z3;
-  };
+  struct sensorless_t { bool x, y, z, x2, y2, z2, z3; };
 
   bool tmc_enable_stallguard(TMC2130Stepper &st);
   void tmc_disable_stallguard(TMC2130Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2209Stepper &st);
   void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2660Stepper);
   void tmc_disable_stallguard(TMC2660Stepper, const bool);
 #endif

commit 8aad29fb6ecb9d10a833f6d45e49de3051ed9e87
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Mar 22 20:03:36 2019 +0200

    Fix Prusa chopper timing preset

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index d7eacee8cb..1df9a1a3b3 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -42,21 +42,21 @@
 #define TMC_E1_LABEL 'E', '1'
 #define TMC_E2_LABEL 'E', '2'
 #define TMC_E3_LABEL 'E', '3'
 #define TMC_E4_LABEL 'E', '4'
 #define TMC_E5_LABEL 'E', '5'
 
 #define CHOPPER_DEFAULT_12V  { 3, -1, 1 }
 #define CHOPPER_DEFAULT_19V  { 4,  1, 1 }
 #define CHOPPER_DEFAULT_24V  { 4,  2, 1 }
 #define CHOPPER_DEFAULT_36V  { 5,  2, 4 }
-#define CHOPPER_PRUSAMK3_24V { 4,  1, 4 }
+#define CHOPPER_PRUSAMK3_24V { 3, -2, 6 }
 #define CHOPPER_MARLIN_119   { 5,  2, 3 }
 
 #if ENABLED(MONITOR_DRIVER_STATUS) && !defined(MONITOR_DRIVER_STATUS_INTERVAL_MS)
   #define MONITOR_DRIVER_STATUS_INTERVAL_MS 500u
 #endif
 
 constexpr uint16_t _tmc_thrs(const uint16_t msteps, const uint32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
 

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index eda702db79..d7eacee8cb 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit 4df4c47994f248428ae30218800803e467327b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 20 15:47:50 2019 -0500

    Add TMC2209 support (#14249)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 1e73a02c20..eda702db79 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -85,95 +85,99 @@ class TMCStorage {
     }
 
     struct {
       #if HAS_STEALTHCHOP
         bool stealthChop_enabled = false;
       #endif
       #if ENABLED(HYBRID_THRESHOLD)
         uint8_t hybrid_thrs = 0;
       #endif
       #if USE_SENSORLESS
-        int8_t homing_thrs = 0;
+        int16_t homing_thrs = 0;
       #endif
     } stored;
 };
 
 template<class TMC, char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
-    TMCMarlin(uint16_t cs_pin, float RS) :
+    TMCMarlin(const uint16_t cs_pin, const float RS) :
       TMC(cs_pin, RS)
       {}
-    TMCMarlin(uint16_t CS, float RS, uint16_t pinMOSI, uint16_t pinMISO, uint16_t pinSCK) :
+    TMCMarlin(const uint16_t CS, const float RS, const uint16_t pinMOSI, const uint16_t pinMISO, const uint16_t pinSCK) :
       TMC(CS, RS, pinMOSI, pinMISO, pinSCK)
       {}
     inline uint16_t rms_current() { return TMC::rms_current(); }
     inline void rms_current(uint16_t mA) {
       this->val_mA = mA;
       TMC::rms_current(mA);
     }
-    inline void rms_current(uint16_t mA, float mult) {
+    inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC::rms_current(mA, mult);
     }
 
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { this->en_pwm_mode(this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return this->en_pwm_mode(); }
     #endif
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
         return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
       }
       void set_pwm_thrs(const uint32_t thrs) {
         TMC::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
         #if HAS_LCD_MENU
           this->stored.hybrid_thrs = thrs;
         #endif
       }
     #endif
     #if USE_SENSORLESS
-      inline int8_t sgt() { return TMC::sgt(); }
-      void sgt(const int8_t sgt_val) {
+      inline int16_t homing_threshold() { return TMC::sgt(); }
+      void homing_threshold(int16_t sgt_val) {
+        sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC::sgt(sgt_val);
         #if HAS_LCD_MENU
           this->stored.homing_thrs = sgt_val;
         #endif
       }
     #endif
 
     #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
         inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
       #if USE_SENSORLESS
-        inline void refresh_homing_thrs() { sgt(this->stored.homing_thrs); }
+        inline void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
+
+    static constexpr int8_t sgt_min = -64,
+                            sgt_max =  63;
 };
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2208Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
-    TMCMarlin(Stream * SerialPort, float RS, bool has_rx=true) :
-      TMC2208Stepper(SerialPort, RS, has_rx=true)
+    TMCMarlin(Stream * SerialPort, const float RS, const uint8_t) :
+      TMC2208Stepper(SerialPort, RS, /*has_rx=*/true)
       {}
-    TMCMarlin(uint16_t RX, uint16_t TX, float RS, bool has_rx=true) :
-      TMC2208Stepper(RX, TX, RS, has_rx=true)
+    TMCMarlin(const uint16_t RX, const uint16_t TX, const float RS, const uint8_t, const bool has_rx=true) :
+      TMC2208Stepper(RX, TX, RS, has_rx)
       {}
     uint16_t rms_current() { return TMC2208Stepper::rms_current(); }
-    inline void rms_current(uint16_t mA) {
+    inline void rms_current(const uint16_t mA) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA);
     }
-    inline void rms_current(uint16_t mA, float mult) {
+    inline void rms_current(const uint16_t mA, const float mult) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA, mult);
     }
 
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return !this->en_spreadCycle(); }
     #endif
     #if ENABLED(HYBRID_THRESHOLD)
       uint32_t get_pwm_thrs() {
@@ -188,52 +192,118 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC220
     #endif
 
     #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
         inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
     #endif
 };
+
+template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+class TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2209Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
+  public:
+    TMCMarlin(Stream * SerialPort, const float RS, const uint8_t addr) :
+      TMC2209Stepper(SerialPort, RS, addr)
+      {}
+    TMCMarlin(const uint16_t RX, const uint16_t TX, const float RS, const uint8_t addr, const bool) :
+      TMC2209Stepper(RX, TX, RS, addr)
+      {}
+    uint8_t get_address() { return slave_address; }
+    uint16_t rms_current() { return TMC2209Stepper::rms_current(); }
+    inline void rms_current(const uint16_t mA) {
+      this->val_mA = mA;
+      TMC2209Stepper::rms_current(mA);
+    }
+    inline void rms_current(const uint16_t mA, const float mult) {
+      this->val_mA = mA;
+      TMC2209Stepper::rms_current(mA, mult);
+    }
+
+    #if HAS_STEALTHCHOP
+      inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
+      inline bool get_stealthChop_status() { return !this->en_spreadCycle(); }
+    #endif
+    #if ENABLED(HYBRID_THRESHOLD)
+      uint32_t get_pwm_thrs() {
+        return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
+      }
+      void set_pwm_thrs(const uint32_t thrs) {
+        TMC2209Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
+        #if HAS_LCD_MENU
+          this->stored.hybrid_thrs = thrs;
+        #endif
+      }
+    #endif
+    #if USE_SENSORLESS
+      inline int16_t homing_threshold() { return TMC2209Stepper::SGTHRS(); }
+      void homing_threshold(int16_t sgt_val) {
+        sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
+        TMC2209Stepper::SGTHRS(sgt_val);
+        #if HAS_LCD_MENU
+          this->stored.homing_thrs = sgt_val;
+        #endif
+      }
+    #endif
+
+    #if HAS_LCD_MENU
+      inline void refresh_stepper_current() { rms_current(this->val_mA); }
+
+      #if ENABLED(HYBRID_THRESHOLD)
+        inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
+      #endif
+      #if USE_SENSORLESS
+        inline void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
+      #endif
+    #endif
+
+    static constexpr uint8_t sgt_min = 0,
+                             sgt_max = 255;
+};
+
 template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2660Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
-    TMCMarlin(uint16_t cs_pin, float RS) :
+    TMCMarlin(const uint16_t cs_pin, const float RS) :
       TMC2660Stepper(cs_pin, RS)
       {}
-    TMCMarlin(uint16_t CS, float RS, uint16_t pinMOSI, uint16_t pinMISO, uint16_t pinSCK) :
+    TMCMarlin(const uint16_t CS, const float RS, const uint16_t pinMOSI, const uint16_t pinMISO, const uint16_t pinSCK) :
       TMC2660Stepper(CS, RS, pinMOSI, pinMISO, pinSCK)
       {}
     inline uint16_t rms_current() { return TMC2660Stepper::rms_current(); }
-    inline void rms_current(uint16_t mA) {
+    inline void rms_current(const uint16_t mA) {
       this->val_mA = mA;
       TMC2660Stepper::rms_current(mA);
     }
 
     #if USE_SENSORLESS
-      inline int8_t sgt() { return TMC2660Stepper::sgt(); }
-      void sgt(const int8_t sgt_val) {
+      inline int16_t homing_threshold() { return TMC2660Stepper::sgt(); }
+      void homing_threshold(int16_t sgt_val) {
+        sgt_val = (int16_t)constrain(sgt_val, sgt_min, sgt_max);
         TMC2660Stepper::sgt(sgt_val);
         #if HAS_LCD_MENU
           this->stored.homing_thrs = sgt_val;
         #endif
       }
     #endif
 
     #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if USE_SENSORLESS
-        inline void refresh_homing_thrs() { sgt(this->stored.homing_thrs); }
+        inline void refresh_homing_thrs() { homing_threshold(this->stored.homing_thrs); }
       #endif
     #endif
+
+    static constexpr int8_t sgt_min = -64,
+                            sgt_max =  63;
 };
 
 template<typename TMC>
 void tmc_print_current(TMC &st) {
   st.printLabel();
   SERIAL_ECHOLNPAIR(" driver current: ", st.getMilliamps());
 }
 
 #if ENABLED(MONITOR_DRIVER_STATUS)
   template<typename TMC>
@@ -255,21 +325,21 @@ void tmc_print_current(TMC &st) {
   void tmc_print_pwmthrs(TMC &st) {
     st.printLabel();
     SERIAL_ECHOLNPAIR(" stealthChop max speed: ", st.get_pwm_thrs());
   }
 #endif
 #if USE_SENSORLESS
   template<typename TMC>
   void tmc_print_sgt(TMC &st) {
     st.printLabel();
     SERIAL_ECHOPGM(" homing sensitivity: ");
-    SERIAL_PRINTLN(st.sgt(), DEC);
+    SERIAL_PRINTLN(st.homing_threshold(), DEC);
   }
 #endif
 
 void monitor_tmc_driver();
 void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z, const bool test_e);
 
 #if ENABLED(TMC_DEBUG)
   #if ENABLED(MONITOR_DRIVER_STATUS)
     void tmc_set_report_interval(const uint16_t update_interval);
   #endif
@@ -286,19 +356,22 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
  */
 #if USE_SENSORLESS
   // Track enabled status of stealthChop and only re-enable where applicable
   struct sensorless_t {
     bool x, y, z, x2, y2, z2, z3;
   };
 
   bool tmc_enable_stallguard(TMC2130Stepper &st);
   void tmc_disable_stallguard(TMC2130Stepper &st, const bool restore_stealth);
 
+  bool tmc_enable_stallguard(TMC2209Stepper &st);
+  void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth);
+
   bool tmc_enable_stallguard(TMC2660Stepper);
   void tmc_disable_stallguard(TMC2660Stepper, const bool);
 #endif
 
 #if TMC_HAS_SPI
   void tmc_init_cs_pins();
 #endif
 
 #endif // HAS_TRINAMIC

commit 1c86fbc60bad74957c872cbd6bc87900a3f127d8
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sun May 26 02:22:12 2019 +0300

    TMC updates, capture LCD changes (#14074)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 132efbb79e..1e73a02c20 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -16,26 +16,25 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 #pragma once
 
 #include "../inc/MarlinConfig.h"
 #include "../lcd/ultralcd.h"
+
 #if HAS_TRINAMIC
-  #include <TMCStepper.h>
-#endif
-#if HAS_LCD_MENU
-  #include "../module/planner.h"
-#endif
+
+#include <TMCStepper.h>
+#include "../module/planner.h"
 
 #define TMC_X_LABEL 'X', '0'
 #define TMC_Y_LABEL 'Y', '0'
 #define TMC_Z_LABEL 'Z', '0'
 
 #define TMC_X2_LABEL 'X', '2'
 #define TMC_Y2_LABEL 'Y', '2'
 #define TMC_Z2_LABEL 'Z', '2'
 #define TMC_Z3_LABEL 'Z', '3'
 
@@ -50,21 +49,21 @@
 #define CHOPPER_DEFAULT_19V  { 4,  1, 1 }
 #define CHOPPER_DEFAULT_24V  { 4,  2, 1 }
 #define CHOPPER_DEFAULT_36V  { 5,  2, 4 }
 #define CHOPPER_PRUSAMK3_24V { 4,  1, 4 }
 #define CHOPPER_MARLIN_119   { 5,  2, 3 }
 
 #if ENABLED(MONITOR_DRIVER_STATUS) && !defined(MONITOR_DRIVER_STATUS_INTERVAL_MS)
   #define MONITOR_DRIVER_STATUS_INTERVAL_MS 500u
 #endif
 
-constexpr uint16_t _tmc_thrs(const uint16_t msteps, const int32_t thrs, const uint32_t spmm) {
+constexpr uint16_t _tmc_thrs(const uint16_t msteps, const uint32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
 
 template<char AXIS_LETTER, char DRIVER_ID>
 class TMCStorage {
   protected:
     // Only a child class has access to constructor => Don't create on its own! "Poor man's abstract class"
     TMCStorage() {}
 
   public:
@@ -85,27 +84,27 @@ class TMCStorage {
       if (DRIVER_ID > '0') SERIAL_CHAR(DRIVER_ID);
     }
 
     struct {
       #if HAS_STEALTHCHOP
         bool stealthChop_enabled = false;
       #endif
       #if ENABLED(HYBRID_THRESHOLD)
         uint8_t hybrid_thrs = 0;
       #endif
-      #if ENABLED(SENSORLESS_HOMING)
+      #if USE_SENSORLESS
         int8_t homing_thrs = 0;
       #endif
     } stored;
 };
 
-template<class TMC, char AXIS_LETTER, char DRIVER_ID>
+template<class TMC, char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
 class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(uint16_t cs_pin, float RS) :
       TMC(cs_pin, RS)
       {}
     TMCMarlin(uint16_t CS, float RS, uint16_t pinMOSI, uint16_t pinMISO, uint16_t pinSCK) :
       TMC(CS, RS, pinMOSI, pinMISO, pinSCK)
       {}
     inline uint16_t rms_current() { return TMC::rms_current(); }
     inline void rms_current(uint16_t mA) {
@@ -114,44 +113,54 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
     }
     inline void rms_current(uint16_t mA, float mult) {
       this->val_mA = mA;
       TMC::rms_current(mA, mult);
     }
 
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { this->en_pwm_mode(this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return this->en_pwm_mode(); }
     #endif
-
-    #if HAS_LCD_MENU
-
-      inline void init_lcd_variables(const AxisEnum spmm_id) {
-        #if ENABLED(HYBRID_THRESHOLD)
-          this->stored.hybrid_thrs = _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[spmm_id]);
+    #if ENABLED(HYBRID_THRESHOLD)
+      uint32_t get_pwm_thrs() {
+        return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
+      }
+      void set_pwm_thrs(const uint32_t thrs) {
+        TMC::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
+        #if HAS_LCD_MENU
+          this->stored.hybrid_thrs = thrs;
         #endif
-        #if ENABLED(SENSORLESS_HOMING)
-          this->stored.homing_thrs = this->sgt();
+      }
+    #endif
+    #if USE_SENSORLESS
+      inline int8_t sgt() { return TMC::sgt(); }
+      void sgt(const int8_t sgt_val) {
+        TMC::sgt(sgt_val);
+        #if HAS_LCD_MENU
+          this->stored.homing_thrs = sgt_val;
         #endif
       }
+    #endif
 
+    #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
-        inline void refresh_hybrid_thrs(float spmm) { this->TPWMTHRS(_tmc_thrs(this->microsteps(), this->stored.hybrid_thrs, spmm)); }
+        inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
-      #if ENABLED(SENSORLESS_HOMING)
-        inline void refresh_homing_thrs() { this->sgt(this->stored.homing_thrs); }
+      #if USE_SENSORLESS
+        inline void refresh_homing_thrs() { sgt(this->stored.homing_thrs); }
       #endif
     #endif
 };
-template<char AXIS_LETTER, char DRIVER_ID>
-class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID> : public TMC2208Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
+template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2208Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(Stream * SerialPort, float RS, bool has_rx=true) :
       TMC2208Stepper(SerialPort, RS, has_rx=true)
       {}
     TMCMarlin(uint16_t RX, uint16_t TX, float RS, bool has_rx=true) :
       TMC2208Stepper(RX, TX, RS, has_rx=true)
       {}
     uint16_t rms_current() { return TMC2208Stepper::rms_current(); }
     inline void rms_current(uint16_t mA) {
       this->val_mA = mA;
@@ -159,126 +168,122 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID> : public TMC2208Stepper,
     }
     inline void rms_current(uint16_t mA, float mult) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA, mult);
     }
 
     #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return !this->en_spreadCycle(); }
     #endif
-
-    #if HAS_LCD_MENU
-
-      inline void init_lcd_variables(const AxisEnum spmm_id) {
-        #if ENABLED(HYBRID_THRESHOLD)
-          this->stored.hybrid_thrs = _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[spmm_id]);
+    #if ENABLED(HYBRID_THRESHOLD)
+      uint32_t get_pwm_thrs() {
+        return _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[AXIS_ID]);
+      }
+      void set_pwm_thrs(const uint32_t thrs) {
+        TMC2208Stepper::TPWMTHRS(_tmc_thrs(this->microsteps(), thrs, planner.settings.axis_steps_per_mm[AXIS_ID]));
+        #if HAS_LCD_MENU
+          this->stored.hybrid_thrs = thrs;
         #endif
       }
+    #endif
 
+    #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
-        inline void refresh_hybrid_thrs(float spmm) { this->TPWMTHRS(_tmc_thrs(this->microsteps(), this->stored.hybrid_thrs, spmm)); }
+        inline void refresh_hybrid_thrs() { set_pwm_thrs(this->stored.hybrid_thrs); }
       #endif
     #endif
 };
-template<char AXIS_LETTER, char DRIVER_ID>
-class TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID> : public TMC2660Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
+template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+class TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> : public TMC2660Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(uint16_t cs_pin, float RS) :
       TMC2660Stepper(cs_pin, RS)
       {}
     TMCMarlin(uint16_t CS, float RS, uint16_t pinMOSI, uint16_t pinMISO, uint16_t pinSCK) :
       TMC2660Stepper(CS, RS, pinMOSI, pinMISO, pinSCK)
       {}
     inline uint16_t rms_current() { return TMC2660Stepper::rms_current(); }
     inline void rms_current(uint16_t mA) {
       this->val_mA = mA;
       TMC2660Stepper::rms_current(mA);
     }
 
-    #if HAS_LCD_MENU
-      inline void init_lcd_variables(const AxisEnum spmm_id) {
-        #if ENABLED(SENSORLESS_HOMING)
-          this->stored.homing_thrs = this->sgt();
+    #if USE_SENSORLESS
+      inline int8_t sgt() { return TMC2660Stepper::sgt(); }
+      void sgt(const int8_t sgt_val) {
+        TMC2660Stepper::sgt(sgt_val);
+        #if HAS_LCD_MENU
+          this->stored.homing_thrs = sgt_val;
         #endif
       }
+    #endif
 
+    #if HAS_LCD_MENU
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
 
-      #if ENABLED(SENSORLESS_HOMING)
-        inline void refresh_homing_thrs() { this->sgt(this->stored.homing_thrs); }
+      #if USE_SENSORLESS
+        inline void refresh_homing_thrs() { sgt(this->stored.homing_thrs); }
       #endif
     #endif
 };
 
 template<typename TMC>
-void tmc_get_current(TMC &st) {
+void tmc_print_current(TMC &st) {
   st.printLabel();
   SERIAL_ECHOLNPAIR(" driver current: ", st.getMilliamps());
 }
-template<typename TMC>
-void tmc_set_current(TMC &st, const int mA) {
-  st.rms_current(mA);
-}
 
 #if ENABLED(MONITOR_DRIVER_STATUS)
   template<typename TMC>
   void tmc_report_otpw(TMC &st) {
     st.printLabel();
     SERIAL_ECHOPGM(" temperature prewarn triggered: ");
     serialprint_truefalse(st.getOTPW());
     SERIAL_EOL();
   }
   template<typename TMC>
   void tmc_clear_otpw(TMC &st) {
     st.clear_otpw();
     st.printLabel();
     SERIAL_ECHOLNPGM(" prewarn flag cleared");
   }
 #endif
-template<typename TMC>
-void tmc_get_pwmthrs(TMC &st, const uint16_t spmm) {
-  st.printLabel();
-  SERIAL_ECHOLNPAIR(" stealthChop max speed: ", _tmc_thrs(st.microsteps(), st.TPWMTHRS(), spmm));
-}
-template<typename TMC>
-void tmc_set_pwmthrs(TMC &st, const int32_t thrs, const uint32_t spmm) {
-  st.TPWMTHRS(_tmc_thrs(st.microsteps(), thrs, spmm));
-}
-template<typename TMC>
-void tmc_get_sgt(TMC &st) {
-  st.printLabel();
-  SERIAL_ECHOPGM(" homing sensitivity: ");
-  SERIAL_PRINTLN(st.sgt(), DEC);
-}
-template<typename TMC>
-void tmc_set_sgt(TMC &st, const int8_t sgt_val) {
-  st.sgt(sgt_val);
-}
+#if ENABLED(HYBRID_THRESHOLD)
+  template<typename TMC>
+  void tmc_print_pwmthrs(TMC &st) {
+    st.printLabel();
+    SERIAL_ECHOLNPAIR(" stealthChop max speed: ", st.get_pwm_thrs());
+  }
+#endif
+#if USE_SENSORLESS
+  template<typename TMC>
+  void tmc_print_sgt(TMC &st) {
+    st.printLabel();
+    SERIAL_ECHOPGM(" homing sensitivity: ");
+    SERIAL_PRINTLN(st.sgt(), DEC);
+  }
+#endif
 
 void monitor_tmc_driver();
 void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z, const bool test_e);
 
 #if ENABLED(TMC_DEBUG)
   #if ENABLED(MONITOR_DRIVER_STATUS)
     void tmc_set_report_interval(const uint16_t update_interval);
   #endif
   void tmc_report_all(const bool print_x, const bool print_y, const bool print_z, const bool print_e);
   void tmc_get_registers(const bool print_x, const bool print_y, const bool print_z, const bool print_e);
 #endif
 
-#if HAS_LCD_MENU
-  void init_tmc_section();
-#endif
-
 /**
  * TMC2130 specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if USE_SENSORLESS
   // Track enabled status of stealthChop and only re-enable where applicable
   struct sensorless_t {
@@ -288,10 +293,12 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
   bool tmc_enable_stallguard(TMC2130Stepper &st);
   void tmc_disable_stallguard(TMC2130Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2660Stepper);
   void tmc_disable_stallguard(TMC2660Stepper, const bool);
 #endif
 
 #if TMC_HAS_SPI
   void tmc_init_cs_pins();
 #endif
+
+#endif // HAS_TRINAMIC

commit cf12fc8366f2ffbc3811173769d5428236af0dd9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 5 20:02:46 2019 -0500

    Expand on serial debugging (#13577)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 81ef2e06a5..132efbb79e 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -220,21 +220,21 @@ void tmc_get_current(TMC &st) {
 template<typename TMC>
 void tmc_set_current(TMC &st, const int mA) {
   st.rms_current(mA);
 }
 
 #if ENABLED(MONITOR_DRIVER_STATUS)
   template<typename TMC>
   void tmc_report_otpw(TMC &st) {
     st.printLabel();
     SERIAL_ECHOPGM(" temperature prewarn triggered: ");
-    serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
+    serialprint_truefalse(st.getOTPW());
     SERIAL_EOL();
   }
   template<typename TMC>
   void tmc_clear_otpw(TMC &st) {
     st.clear_otpw();
     st.printLabel();
     SERIAL_ECHOLNPGM(" prewarn flag cleared");
   }
 #endif
 template<typename TMC>

commit ba39186364b69f7399f33b7ddb1115db42c6eabc
Author: LinFor <linfor@gmail.com>
Date:   Wed Feb 20 11:22:42 2019 +0300

    TMC_DEBUG optimization and improvements (#13135)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 44ed033e72..81ef2e06a5 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -46,20 +46,24 @@
 #define TMC_E4_LABEL 'E', '4'
 #define TMC_E5_LABEL 'E', '5'
 
 #define CHOPPER_DEFAULT_12V  { 3, -1, 1 }
 #define CHOPPER_DEFAULT_19V  { 4,  1, 1 }
 #define CHOPPER_DEFAULT_24V  { 4,  2, 1 }
 #define CHOPPER_DEFAULT_36V  { 5,  2, 4 }
 #define CHOPPER_PRUSAMK3_24V { 4,  1, 4 }
 #define CHOPPER_MARLIN_119   { 5,  2, 3 }
 
+#if ENABLED(MONITOR_DRIVER_STATUS) && !defined(MONITOR_DRIVER_STATUS_INTERVAL_MS)
+  #define MONITOR_DRIVER_STATUS_INTERVAL_MS 500u
+#endif
+
 constexpr uint16_t _tmc_thrs(const uint16_t msteps, const int32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
 
 template<char AXIS_LETTER, char DRIVER_ID>
 class TMCStorage {
   protected:
     // Only a child class has access to constructor => Don't create on its own! "Poor man's abstract class"
     TMCStorage() {}
 
@@ -251,21 +255,21 @@ void tmc_get_sgt(TMC &st) {
 template<typename TMC>
 void tmc_set_sgt(TMC &st, const int8_t sgt_val) {
   st.sgt(sgt_val);
 }
 
 void monitor_tmc_driver();
 void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z, const bool test_e);
 
 #if ENABLED(TMC_DEBUG)
   #if ENABLED(MONITOR_DRIVER_STATUS)
-    void tmc_set_report_status(const bool status);
+    void tmc_set_report_interval(const uint16_t update_interval);
   #endif
   void tmc_report_all(const bool print_x, const bool print_y, const bool print_z, const bool print_e);
   void tmc_get_registers(const bool print_x, const bool print_y, const bool print_z, const bool print_e);
 #endif
 
 #if HAS_LCD_MENU
   void init_tmc_section();
 #endif
 
 /**

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index a5cd94a0ab..44ed033e72 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit c3cb449990e037ca02826596d4b54aafa51db55c
Author: mattfredwill <mattfredwill@gmail.com>
Date:   Sat Feb 2 08:09:01 2019 +0800

    TMC2130 dual-stepper Sensorless Homing (#13061)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index aa0962a2a2..a5cd94a0ab 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -271,21 +271,21 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
 /**
  * TMC2130 specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if USE_SENSORLESS
   // Track enabled status of stealthChop and only re-enable where applicable
   struct sensorless_t {
-    bool x, y, z;
+    bool x, y, z, x2, y2, z2, z3;
   };
 
   bool tmc_enable_stallguard(TMC2130Stepper &st);
   void tmc_disable_stallguard(TMC2130Stepper &st, const bool restore_stealth);
 
   bool tmc_enable_stallguard(TMC2660Stepper);
   void tmc_disable_stallguard(TMC2660Stepper, const bool);
 #endif
 
 #if TMC_HAS_SPI

commit e5801b75f89254d088b423499719b5ccbc48cb0d
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Mon Jan 21 07:54:57 2019 +0200

    Fix TMC-related compile issues. (#12971)
    
    - `STEALTHOP_[XYZE]` configuration options now set the default state.

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 6b5ca8daa5..aa0962a2a2 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -75,21 +75,21 @@ class TMCStorage {
     #endif
 
     inline uint16_t getMilliamps() { return val_mA; }
 
     inline void printLabel() {
       SERIAL_CHAR(AXIS_LETTER);
       if (DRIVER_ID > '0') SERIAL_CHAR(DRIVER_ID);
     }
 
     struct {
-      #if STEALTHCHOP_ENABLED
+      #if HAS_STEALTHCHOP
         bool stealthChop_enabled = false;
       #endif
       #if ENABLED(HYBRID_THRESHOLD)
         uint8_t hybrid_thrs = 0;
       #endif
       #if ENABLED(SENSORLESS_HOMING)
         int8_t homing_thrs = 0;
       #endif
     } stored;
 };
@@ -106,21 +106,21 @@ class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
     inline uint16_t rms_current() { return TMC::rms_current(); }
     inline void rms_current(uint16_t mA) {
       this->val_mA = mA;
       TMC::rms_current(mA);
     }
     inline void rms_current(uint16_t mA, float mult) {
       this->val_mA = mA;
       TMC::rms_current(mA, mult);
     }
 
-    #if STEALTHCHOP_ENABLED
+    #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { this->en_pwm_mode(this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return this->en_pwm_mode(); }
     #endif
 
     #if HAS_LCD_MENU
 
       inline void init_lcd_variables(const AxisEnum spmm_id) {
         #if ENABLED(HYBRID_THRESHOLD)
           this->stored.hybrid_thrs = _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[spmm_id]);
         #endif
@@ -151,34 +151,31 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID> : public TMC2208Stepper,
     uint16_t rms_current() { return TMC2208Stepper::rms_current(); }
     inline void rms_current(uint16_t mA) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA);
     }
     inline void rms_current(uint16_t mA, float mult) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA, mult);
     }
 
-    #if STEALTHCHOP_ENABLED
+    #if HAS_STEALTHCHOP
       inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
       inline bool get_stealthChop_status() { return !this->en_spreadCycle(); }
     #endif
 
     #if HAS_LCD_MENU
 
       inline void init_lcd_variables(const AxisEnum spmm_id) {
         #if ENABLED(HYBRID_THRESHOLD)
           this->stored.hybrid_thrs = _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[spmm_id]);
         #endif
-        #if STEALTHCHOP_ENABLED
-          this->stored.stealthChop_enabled = !this->en_spreadCycle();
-        #endif
       }
 
       inline void refresh_stepper_current() { rms_current(this->val_mA); }
 
       #if ENABLED(HYBRID_THRESHOLD)
         inline void refresh_hybrid_thrs(float spmm) { this->TPWMTHRS(_tmc_thrs(this->microsteps(), this->stored.hybrid_thrs, spmm)); }
       #endif
     #endif
 };
 template<char AXIS_LETTER, char DRIVER_ID>

commit f4c16e683b63f4be505638212455f13cb4215537
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu Jan 17 17:48:29 2019 -0700

    Follow up fixes to #12884 (#12940)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index d90efba6bb..6b5ca8daa5 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -153,21 +153,21 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID> : public TMC2208Stepper,
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA);
     }
     inline void rms_current(uint16_t mA, float mult) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA, mult);
     }
 
     #if STEALTHCHOP_ENABLED
       inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
-      inline bool get_stealthChop_status() { !this->en_spreadCycle(); }
+      inline bool get_stealthChop_status() { return !this->en_spreadCycle(); }
     #endif
 
     #if HAS_LCD_MENU
 
       inline void init_lcd_variables(const AxisEnum spmm_id) {
         #if ENABLED(HYBRID_THRESHOLD)
           this->stored.hybrid_thrs = _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[spmm_id]);
         #endif
         #if STEALTHCHOP_ENABLED
           this->stored.stealthChop_enabled = !this->en_spreadCycle();

commit e6805582a67b106691423a35ab580bd6b0895949
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Thu Jan 17 21:17:16 2019 +0200

    M569 to change stepping mode. Add new TMC section to LCD. (#12884)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 3acfdc9cbc..d90efba6bb 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -19,20 +19,23 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 #pragma once
 
 #include "../inc/MarlinConfig.h"
 #include "../lcd/ultralcd.h"
 #if HAS_TRINAMIC
   #include <TMCStepper.h>
 #endif
+#if HAS_LCD_MENU
+  #include "../module/planner.h"
+#endif
 
 #define TMC_X_LABEL 'X', '0'
 #define TMC_Y_LABEL 'Y', '0'
 #define TMC_Z_LABEL 'Z', '0'
 
 #define TMC_X2_LABEL 'X', '2'
 #define TMC_Y2_LABEL 'Y', '2'
 #define TMC_Z2_LABEL 'Z', '2'
 #define TMC_Z3_LABEL 'Z', '3'
 
@@ -43,97 +46,188 @@
 #define TMC_E4_LABEL 'E', '4'
 #define TMC_E5_LABEL 'E', '5'
 
 #define CHOPPER_DEFAULT_12V  { 3, -1, 1 }
 #define CHOPPER_DEFAULT_19V  { 4,  1, 1 }
 #define CHOPPER_DEFAULT_24V  { 4,  2, 1 }
 #define CHOPPER_DEFAULT_36V  { 5,  2, 4 }
 #define CHOPPER_PRUSAMK3_24V { 4,  1, 4 }
 #define CHOPPER_MARLIN_119   { 5,  2, 3 }
 
+constexpr uint16_t _tmc_thrs(const uint16_t msteps, const int32_t thrs, const uint32_t spmm) {
+  return 12650000UL * msteps / (256 * thrs * spmm);
+}
+
 template<char AXIS_LETTER, char DRIVER_ID>
 class TMCStorage {
   protected:
     // Only a child class has access to constructor => Don't create on its own! "Poor man's abstract class"
     TMCStorage() {}
 
+  public:
     uint16_t val_mA = 0;
 
-  public:
     #if ENABLED(MONITOR_DRIVER_STATUS)
       uint8_t otpw_count = 0,
               error_count = 0;
       bool flag_otpw = false;
-      bool getOTPW() { return flag_otpw; }
-      void clear_otpw() { flag_otpw = 0; }
+      inline bool getOTPW() { return flag_otpw; }
+      inline void clear_otpw() { flag_otpw = 0; }
     #endif
 
-    uint16_t getMilliamps() { return val_mA; }
+    inline uint16_t getMilliamps() { return val_mA; }
 
-    void printLabel() {
+    inline void printLabel() {
       SERIAL_CHAR(AXIS_LETTER);
       if (DRIVER_ID > '0') SERIAL_CHAR(DRIVER_ID);
     }
+
+    struct {
+      #if STEALTHCHOP_ENABLED
+        bool stealthChop_enabled = false;
+      #endif
+      #if ENABLED(HYBRID_THRESHOLD)
+        uint8_t hybrid_thrs = 0;
+      #endif
+      #if ENABLED(SENSORLESS_HOMING)
+        int8_t homing_thrs = 0;
+      #endif
+    } stored;
 };
 
 template<class TMC, char AXIS_LETTER, char DRIVER_ID>
 class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(uint16_t cs_pin, float RS) :
       TMC(cs_pin, RS)
       {}
     TMCMarlin(uint16_t CS, float RS, uint16_t pinMOSI, uint16_t pinMISO, uint16_t pinSCK) :
       TMC(CS, RS, pinMOSI, pinMISO, pinSCK)
       {}
-    uint16_t rms_current() { return TMC::rms_current(); }
-    void rms_current(uint16_t mA) {
+    inline uint16_t rms_current() { return TMC::rms_current(); }
+    inline void rms_current(uint16_t mA) {
       this->val_mA = mA;
       TMC::rms_current(mA);
     }
-    void rms_current(uint16_t mA, float mult) {
+    inline void rms_current(uint16_t mA, float mult) {
       this->val_mA = mA;
       TMC::rms_current(mA, mult);
     }
+
+    #if STEALTHCHOP_ENABLED
+      inline void refresh_stepping_mode() { this->en_pwm_mode(this->stored.stealthChop_enabled); }
+      inline bool get_stealthChop_status() { return this->en_pwm_mode(); }
+    #endif
+
+    #if HAS_LCD_MENU
+
+      inline void init_lcd_variables(const AxisEnum spmm_id) {
+        #if ENABLED(HYBRID_THRESHOLD)
+          this->stored.hybrid_thrs = _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[spmm_id]);
+        #endif
+        #if ENABLED(SENSORLESS_HOMING)
+          this->stored.homing_thrs = this->sgt();
+        #endif
+      }
+
+      inline void refresh_stepper_current() { rms_current(this->val_mA); }
+
+      #if ENABLED(HYBRID_THRESHOLD)
+        inline void refresh_hybrid_thrs(float spmm) { this->TPWMTHRS(_tmc_thrs(this->microsteps(), this->stored.hybrid_thrs, spmm)); }
+      #endif
+      #if ENABLED(SENSORLESS_HOMING)
+        inline void refresh_homing_thrs() { this->sgt(this->stored.homing_thrs); }
+      #endif
+    #endif
 };
 template<char AXIS_LETTER, char DRIVER_ID>
 class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID> : public TMC2208Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
   public:
     TMCMarlin(Stream * SerialPort, float RS, bool has_rx=true) :
       TMC2208Stepper(SerialPort, RS, has_rx=true)
       {}
     TMCMarlin(uint16_t RX, uint16_t TX, float RS, bool has_rx=true) :
       TMC2208Stepper(RX, TX, RS, has_rx=true)
       {}
     uint16_t rms_current() { return TMC2208Stepper::rms_current(); }
-    void rms_current(uint16_t mA) {
+    inline void rms_current(uint16_t mA) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA);
     }
-    void rms_current(uint16_t mA, float mult) {
+    inline void rms_current(uint16_t mA, float mult) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA, mult);
     }
+
+    #if STEALTHCHOP_ENABLED
+      inline void refresh_stepping_mode() { en_spreadCycle(!this->stored.stealthChop_enabled); }
+      inline bool get_stealthChop_status() { !this->en_spreadCycle(); }
+    #endif
+
+    #if HAS_LCD_MENU
+
+      inline void init_lcd_variables(const AxisEnum spmm_id) {
+        #if ENABLED(HYBRID_THRESHOLD)
+          this->stored.hybrid_thrs = _tmc_thrs(this->microsteps(), this->TPWMTHRS(), planner.settings.axis_steps_per_mm[spmm_id]);
+        #endif
+        #if STEALTHCHOP_ENABLED
+          this->stored.stealthChop_enabled = !this->en_spreadCycle();
+        #endif
+      }
+
+      inline void refresh_stepper_current() { rms_current(this->val_mA); }
+
+      #if ENABLED(HYBRID_THRESHOLD)
+        inline void refresh_hybrid_thrs(float spmm) { this->TPWMTHRS(_tmc_thrs(this->microsteps(), this->stored.hybrid_thrs, spmm)); }
+      #endif
+    #endif
 };
+template<char AXIS_LETTER, char DRIVER_ID>
+class TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID> : public TMC2660Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
+  public:
+    TMCMarlin(uint16_t cs_pin, float RS) :
+      TMC2660Stepper(cs_pin, RS)
+      {}
+    TMCMarlin(uint16_t CS, float RS, uint16_t pinMOSI, uint16_t pinMISO, uint16_t pinSCK) :
+      TMC2660Stepper(CS, RS, pinMOSI, pinMISO, pinSCK)
+      {}
+    inline uint16_t rms_current() { return TMC2660Stepper::rms_current(); }
+    inline void rms_current(uint16_t mA) {
+      this->val_mA = mA;
+      TMC2660Stepper::rms_current(mA);
+    }
 
-constexpr uint16_t _tmc_thrs(const uint16_t msteps, const int32_t thrs, const uint32_t spmm) {
-  return 12650000UL * msteps / (256 * thrs * spmm);
-}
+    #if HAS_LCD_MENU
+      inline void init_lcd_variables(const AxisEnum spmm_id) {
+        #if ENABLED(SENSORLESS_HOMING)
+          this->stored.homing_thrs = this->sgt();
+        #endif
+      }
+
+      inline void refresh_stepper_current() { rms_current(this->val_mA); }
+
+      #if ENABLED(SENSORLESS_HOMING)
+        inline void refresh_homing_thrs() { this->sgt(this->stored.homing_thrs); }
+      #endif
+    #endif
+};
 
 template<typename TMC>
 void tmc_get_current(TMC &st) {
   st.printLabel();
   SERIAL_ECHOLNPAIR(" driver current: ", st.getMilliamps());
 }
 template<typename TMC>
 void tmc_set_current(TMC &st, const int mA) {
   st.rms_current(mA);
 }
+
 #if ENABLED(MONITOR_DRIVER_STATUS)
   template<typename TMC>
   void tmc_report_otpw(TMC &st) {
     st.printLabel();
     SERIAL_ECHOPGM(" temperature prewarn triggered: ");
     serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
     SERIAL_EOL();
   }
   template<typename TMC>
   void tmc_clear_otpw(TMC &st) {
@@ -166,20 +260,24 @@ void monitor_tmc_driver();
 void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z, const bool test_e);
 
 #if ENABLED(TMC_DEBUG)
   #if ENABLED(MONITOR_DRIVER_STATUS)
     void tmc_set_report_status(const bool status);
   #endif
   void tmc_report_all(const bool print_x, const bool print_y, const bool print_z, const bool print_e);
   void tmc_get_registers(const bool print_x, const bool print_y, const bool print_z, const bool print_e);
 #endif
 
+#if HAS_LCD_MENU
+  void init_tmc_section();
+#endif
+
 /**
  * TMC2130 specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if USE_SENSORLESS
   // Track enabled status of stealthChop and only re-enable where applicable
   struct sensorless_t {

commit 7a5e637a3750e2ac27dc5fe5b5793bc6b348413b
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Tue Dec 18 20:42:14 2018 +0200

    Add spreadCycle parameter sets (#12645)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index d9bf8143f6..3acfdc9cbc 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -36,20 +36,27 @@
 #define TMC_Z2_LABEL 'Z', '2'
 #define TMC_Z3_LABEL 'Z', '3'
 
 #define TMC_E0_LABEL 'E', '0'
 #define TMC_E1_LABEL 'E', '1'
 #define TMC_E2_LABEL 'E', '2'
 #define TMC_E3_LABEL 'E', '3'
 #define TMC_E4_LABEL 'E', '4'
 #define TMC_E5_LABEL 'E', '5'
 
+#define CHOPPER_DEFAULT_12V  { 3, -1, 1 }
+#define CHOPPER_DEFAULT_19V  { 4,  1, 1 }
+#define CHOPPER_DEFAULT_24V  { 4,  2, 1 }
+#define CHOPPER_DEFAULT_36V  { 5,  2, 4 }
+#define CHOPPER_PRUSAMK3_24V { 4,  1, 4 }
+#define CHOPPER_MARLIN_119   { 5,  2, 3 }
+
 template<char AXIS_LETTER, char DRIVER_ID>
 class TMCStorage {
   protected:
     // Only a child class has access to constructor => Don't create on its own! "Poor man's abstract class"
     TMCStorage() {}
 
     uint16_t val_mA = 0;
 
   public:
     #if ENABLED(MONITOR_DRIVER_STATUS)

commit 55144284c2578dccca7a6a5fa472a3d927ff09f2
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Mon Dec 10 04:54:48 2018 +0200

    TMC connection test, spreadCycle parameters, improved debugging (#12616)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 7e075cd454..d9bf8143f6 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -15,20 +15,21 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 #pragma once
 
 #include "../inc/MarlinConfig.h"
+#include "../lcd/ultralcd.h"
 #if HAS_TRINAMIC
   #include <TMCStepper.h>
 #endif
 
 #define TMC_X_LABEL 'X', '0'
 #define TMC_Y_LABEL 'Y', '0'
 #define TMC_Z_LABEL 'Z', '0'
 
 #define TMC_X2_LABEL 'X', '2'
 #define TMC_Y2_LABEL 'Y', '2'
@@ -148,26 +149,28 @@ void tmc_get_sgt(TMC &st) {
   st.printLabel();
   SERIAL_ECHOPGM(" homing sensitivity: ");
   SERIAL_PRINTLN(st.sgt(), DEC);
 }
 template<typename TMC>
 void tmc_set_sgt(TMC &st, const int8_t sgt_val) {
   st.sgt(sgt_val);
 }
 
 void monitor_tmc_driver();
+void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z, const bool test_e);
 
 #if ENABLED(TMC_DEBUG)
   #if ENABLED(MONITOR_DRIVER_STATUS)
     void tmc_set_report_status(const bool status);
   #endif
-  void tmc_report_all();
+  void tmc_report_all(const bool print_x, const bool print_y, const bool print_z, const bool print_e);
+  void tmc_get_registers(const bool print_x, const bool print_y, const bool print_z, const bool print_e);
 #endif
 
 /**
  * TMC2130 specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if USE_SENSORLESS

commit 50b2fbd03140d21076b8dd3015219ffed0f761c9
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 7 23:34:21 2018 +0200

    Trinamic: Split stealthChop, improve driver monitoring, etc. (#12582)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 015c82c499..7e075cd454 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -45,21 +45,22 @@
 template<char AXIS_LETTER, char DRIVER_ID>
 class TMCStorage {
   protected:
     // Only a child class has access to constructor => Don't create on its own! "Poor man's abstract class"
     TMCStorage() {}
 
     uint16_t val_mA = 0;
 
   public:
     #if ENABLED(MONITOR_DRIVER_STATUS)
-      uint8_t otpw_count = 0;
+      uint8_t otpw_count = 0,
+              error_count = 0;
       bool flag_otpw = false;
       bool getOTPW() { return flag_otpw; }
       void clear_otpw() { flag_otpw = 0; }
     #endif
 
     uint16_t getMilliamps() { return val_mA; }
 
     void printLabel() {
       SERIAL_CHAR(AXIS_LETTER);
       if (DRIVER_ID > '0') SERIAL_CHAR(DRIVER_ID);
@@ -98,21 +99,21 @@ class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID> : public TMC2208Stepper,
     void rms_current(uint16_t mA) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA);
     }
     void rms_current(uint16_t mA, float mult) {
       this->val_mA = mA;
       TMC2208Stepper::rms_current(mA, mult);
     }
 };
 
-constexpr uint32_t _tmc_thrs(const uint16_t msteps, const int32_t thrs, const uint32_t spmm) {
+constexpr uint16_t _tmc_thrs(const uint16_t msteps, const int32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
 
 template<typename TMC>
 void tmc_get_current(TMC &st) {
   st.printLabel();
   SERIAL_ECHOLNPAIR(" driver current: ", st.getMilliamps());
 }
 template<typename TMC>
 void tmc_set_current(TMC &st, const int mA) {
@@ -163,17 +164,25 @@ void monitor_tmc_driver();
 #endif
 
 /**
  * TMC2130 specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if USE_SENSORLESS
-  void tmc_stallguard(TMC2130Stepper &st, const bool enable=true);
-  void tmc_stallguard(TMC2660Stepper &st, const bool enable=true);
+  // Track enabled status of stealthChop and only re-enable where applicable
+  struct sensorless_t {
+    bool x, y, z;
+  };
+
+  bool tmc_enable_stallguard(TMC2130Stepper &st);
+  void tmc_disable_stallguard(TMC2130Stepper &st, const bool restore_stealth);
+
+  bool tmc_enable_stallguard(TMC2660Stepper);
+  void tmc_disable_stallguard(TMC2660Stepper, const bool);
 #endif
 
 #if TMC_HAS_SPI
   void tmc_init_cs_pins();
 #endif

commit f5eab912ed6d336f2c37a688a0ec822ed3d42fcc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 4 02:25:55 2018 -0600

    Apply #pragma once, misc cleanup (#12322)
    
    * Apply #pragma once in headers
    * Adjust some thermistors formatting
    * Misc cleanup and formatting

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 84f9cf94ee..015c82c499 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -12,23 +12,21 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
-
-#ifndef _TMC_UTIL_H_
-#define _TMC_UTIL_H_
+#pragma once
 
 #include "../inc/MarlinConfig.h"
 #if HAS_TRINAMIC
   #include <TMCStepper.h>
 #endif
 
 #define TMC_X_LABEL 'X', '0'
 #define TMC_Y_LABEL 'Y', '0'
 #define TMC_Z_LABEL 'Z', '0'
 
@@ -172,12 +170,10 @@ void monitor_tmc_driver();
  * Defined here because of limitations with templates and headers.
  */
 #if USE_SENSORLESS
   void tmc_stallguard(TMC2130Stepper &st, const bool enable=true);
   void tmc_stallguard(TMC2660Stepper &st, const bool enable=true);
 #endif
 
 #if TMC_HAS_SPI
   void tmc_init_cs_pins();
 #endif
-
-#endif // _TMC_UTIL_H_

commit c447d759167bb118c2f26febdae71dd60c64977a
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sun Oct 7 01:18:10 2018 +0300

    Add support for TMC2660 (#11998)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 19050569e2..84f9cf94ee 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -151,30 +151,33 @@ void tmc_get_sgt(TMC &st) {
   SERIAL_PRINTLN(st.sgt(), DEC);
 }
 template<typename TMC>
 void tmc_set_sgt(TMC &st, const int8_t sgt_val) {
   st.sgt(sgt_val);
 }
 
 void monitor_tmc_driver();
 
 #if ENABLED(TMC_DEBUG)
-  void tmc_set_report_status(const bool status);
+  #if ENABLED(MONITOR_DRIVER_STATUS)
+    void tmc_set_report_status(const bool status);
+  #endif
   void tmc_report_all();
 #endif
 
 /**
  * TMC2130 specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if USE_SENSORLESS
   void tmc_stallguard(TMC2130Stepper &st, const bool enable=true);
+  void tmc_stallguard(TMC2660Stepper &st, const bool enable=true);
 #endif
 
-#if HAS_DRIVER(TMC2130)
+#if TMC_HAS_SPI
   void tmc_init_cs_pins();
 #endif
 
 #endif // _TMC_UTIL_H_

commit c3229e1b3461b6da8373e7a24a7eeb131912a15b
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Wed Oct 3 10:48:49 2018 +0300

    Migrate to a new TMC library (#11943)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index b32da5aa3d..19050569e2 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -16,105 +16,146 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #ifndef _TMC_UTIL_H_
 #define _TMC_UTIL_H_
 
-#include "../inc/MarlinConfigPre.h"
-
-#if HAS_DRIVER(TMC2130)
-  #include <TMC2130Stepper.h>
+#include "../inc/MarlinConfig.h"
+#if HAS_TRINAMIC
+  #include <TMCStepper.h>
 #endif
 
-#if HAS_DRIVER(TMC2208)
-  #include <TMC2208Stepper.h>
-#endif
+#define TMC_X_LABEL 'X', '0'
+#define TMC_Y_LABEL 'Y', '0'
+#define TMC_Z_LABEL 'Z', '0'
+
+#define TMC_X2_LABEL 'X', '2'
+#define TMC_Y2_LABEL 'Y', '2'
+#define TMC_Z2_LABEL 'Z', '2'
+#define TMC_Z3_LABEL 'Z', '3'
+
+#define TMC_E0_LABEL 'E', '0'
+#define TMC_E1_LABEL 'E', '1'
+#define TMC_E2_LABEL 'E', '2'
+#define TMC_E3_LABEL 'E', '3'
+#define TMC_E4_LABEL 'E', '4'
+#define TMC_E5_LABEL 'E', '5'
+
+template<char AXIS_LETTER, char DRIVER_ID>
+class TMCStorage {
+  protected:
+    // Only a child class has access to constructor => Don't create on its own! "Poor man's abstract class"
+    TMCStorage() {}
+
+    uint16_t val_mA = 0;
+
+  public:
+    #if ENABLED(MONITOR_DRIVER_STATUS)
+      uint8_t otpw_count = 0;
+      bool flag_otpw = false;
+      bool getOTPW() { return flag_otpw; }
+      void clear_otpw() { flag_otpw = 0; }
+    #endif
+
+    uint16_t getMilliamps() { return val_mA; }
 
-extern bool report_tmc_status;
-
-enum TMC_AxisEnum : char {
-  TMC_X, TMC_Y, TMC_Z
-  #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(X_DUAL_STEPPER_DRIVERS)
-    , TMC_X2
-  #endif
-  #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-    , TMC_Y2
-  #endif
-  #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
-    , TMC_Z2
-  #endif
-  #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
-    , TMC_Z3
-  #endif
-  #if E_STEPPERS
-    , TMC_E0
-    #if E_STEPPERS > 1
-      , TMC_E1
-      #if E_STEPPERS > 2
-        , TMC_E2
-        #if E_STEPPERS > 3
-          , TMC_E3
-          #if E_STEPPERS > 4
-            , TMC_E4
-            #if E_STEPPERS > 5
-              , TMC_E5
-            #endif // E_STEPPERS > 5
-          #endif // E_STEPPERS > 4
-        #endif // E_STEPPERS > 3
-      #endif // E_STEPPERS > 2
-    #endif // E_STEPPERS > 1
-  #endif // E_STEPPERS
+    void printLabel() {
+      SERIAL_CHAR(AXIS_LETTER);
+      if (DRIVER_ID > '0') SERIAL_CHAR(DRIVER_ID);
+    }
+};
+
+template<class TMC, char AXIS_LETTER, char DRIVER_ID>
+class TMCMarlin : public TMC, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
+  public:
+    TMCMarlin(uint16_t cs_pin, float RS) :
+      TMC(cs_pin, RS)
+      {}
+    TMCMarlin(uint16_t CS, float RS, uint16_t pinMOSI, uint16_t pinMISO, uint16_t pinSCK) :
+      TMC(CS, RS, pinMOSI, pinMISO, pinSCK)
+      {}
+    uint16_t rms_current() { return TMC::rms_current(); }
+    void rms_current(uint16_t mA) {
+      this->val_mA = mA;
+      TMC::rms_current(mA);
+    }
+    void rms_current(uint16_t mA, float mult) {
+      this->val_mA = mA;
+      TMC::rms_current(mA, mult);
+    }
+};
+template<char AXIS_LETTER, char DRIVER_ID>
+class TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID> : public TMC2208Stepper, public TMCStorage<AXIS_LETTER, DRIVER_ID> {
+  public:
+    TMCMarlin(Stream * SerialPort, float RS, bool has_rx=true) :
+      TMC2208Stepper(SerialPort, RS, has_rx=true)
+      {}
+    TMCMarlin(uint16_t RX, uint16_t TX, float RS, bool has_rx=true) :
+      TMC2208Stepper(RX, TX, RS, has_rx=true)
+      {}
+    uint16_t rms_current() { return TMC2208Stepper::rms_current(); }
+    void rms_current(uint16_t mA) {
+      this->val_mA = mA;
+      TMC2208Stepper::rms_current(mA);
+    }
+    void rms_current(uint16_t mA, float mult) {
+      this->val_mA = mA;
+      TMC2208Stepper::rms_current(mA, mult);
+    }
 };
 
 constexpr uint32_t _tmc_thrs(const uint16_t msteps, const int32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
 
-void _tmc_say_axis(const TMC_AxisEnum axis);
-void _tmc_say_current(const TMC_AxisEnum axis, const uint16_t curr);
-void _tmc_say_otpw(const TMC_AxisEnum axis, const bool otpw);
-void _tmc_say_otpw_cleared(const TMC_AxisEnum axis);
-void _tmc_say_pwmthrs(const TMC_AxisEnum axis, const uint32_t thrs);
-void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt);
-
 template<typename TMC>
-void tmc_get_current(TMC &st, const TMC_AxisEnum axis) {
-  _tmc_say_current(axis, st.getCurrent());
+void tmc_get_current(TMC &st) {
+  st.printLabel();
+  SERIAL_ECHOLNPAIR(" driver current: ", st.getMilliamps());
 }
 template<typename TMC>
 void tmc_set_current(TMC &st, const int mA) {
-  st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
-}
-template<typename TMC>
-void tmc_report_otpw(TMC &st, const TMC_AxisEnum axis) {
-  _tmc_say_otpw(axis, st.getOTPW());
-}
-template<typename TMC>
-void tmc_clear_otpw(TMC &st, const TMC_AxisEnum axis) {
-  st.clear_otpw();
-  _tmc_say_otpw_cleared(axis);
+  st.rms_current(mA);
 }
+#if ENABLED(MONITOR_DRIVER_STATUS)
+  template<typename TMC>
+  void tmc_report_otpw(TMC &st) {
+    st.printLabel();
+    SERIAL_ECHOPGM(" temperature prewarn triggered: ");
+    serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
+    SERIAL_EOL();
+  }
+  template<typename TMC>
+  void tmc_clear_otpw(TMC &st) {
+    st.clear_otpw();
+    st.printLabel();
+    SERIAL_ECHOLNPGM(" prewarn flag cleared");
+  }
+#endif
 template<typename TMC>
-void tmc_get_pwmthrs(TMC &st, const TMC_AxisEnum axis, const uint16_t spmm) {
-  _tmc_say_pwmthrs(axis, _tmc_thrs(st.microsteps(), st.TPWMTHRS(), spmm));
+void tmc_get_pwmthrs(TMC &st, const uint16_t spmm) {
+  st.printLabel();
+  SERIAL_ECHOLNPAIR(" stealthChop max speed: ", _tmc_thrs(st.microsteps(), st.TPWMTHRS(), spmm));
 }
 template<typename TMC>
 void tmc_set_pwmthrs(TMC &st, const int32_t thrs, const uint32_t spmm) {
   st.TPWMTHRS(_tmc_thrs(st.microsteps(), thrs, spmm));
 }
 template<typename TMC>
-void tmc_get_sgt(TMC &st, const TMC_AxisEnum axis) {
-  _tmc_say_sgt(axis, st.sgt());
+void tmc_get_sgt(TMC &st) {
+  st.printLabel();
+  SERIAL_ECHOPGM(" homing sensitivity: ");
+  SERIAL_PRINTLN(st.sgt(), DEC);
 }
 template<typename TMC>
 void tmc_set_sgt(TMC &st, const int8_t sgt_val) {
   st.sgt(sgt_val);
 }
 
 void monitor_tmc_driver();
 
 #if ENABLED(TMC_DEBUG)
   void tmc_set_report_status(const bool status);

commit 3286325044a7788f12ceb3f3d6cef00dc8b32433
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sun Sep 9 15:59:12 2018 -0400

    Add TMC2130 sensorless probing

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 514f603f18..b32da5aa3d 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -121,19 +121,19 @@ void monitor_tmc_driver();
   void tmc_report_all();
 #endif
 
 /**
  * TMC2130 specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
-#if ENABLED(SENSORLESS_HOMING)
-  void tmc_sensorless_homing(TMC2130Stepper &st, const bool enable=true);
+#if USE_SENSORLESS
+  void tmc_stallguard(TMC2130Stepper &st, const bool enable=true);
 #endif
 
 #if HAS_DRIVER(TMC2130)
   void tmc_init_cs_pins();
 #endif
 
 #endif // _TMC_UTIL_H_

commit 1718eff54adefc7cc95851f28df0c7e02eae3a36
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 13 01:35:55 2018 -0500

    Code changes supporting up to 6 extruders

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index f50919b3c9..514f603f18 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -42,33 +42,38 @@ enum TMC_AxisEnum : char {
   #endif
   #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
     , TMC_Y2
   #endif
   #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
     , TMC_Z2
   #endif
   #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
     , TMC_Z3
   #endif
-  , TMC_E0
-  #if E_STEPPERS > 1
-    , TMC_E1
-    #if E_STEPPERS > 2
-      , TMC_E2
-      #if E_STEPPERS > 3
-        , TMC_E3
-        #if E_STEPPERS > 4
-          , TMC_E4
-        #endif
-      #endif
-    #endif
-  #endif
+  #if E_STEPPERS
+    , TMC_E0
+    #if E_STEPPERS > 1
+      , TMC_E1
+      #if E_STEPPERS > 2
+        , TMC_E2
+        #if E_STEPPERS > 3
+          , TMC_E3
+          #if E_STEPPERS > 4
+            , TMC_E4
+            #if E_STEPPERS > 5
+              , TMC_E5
+            #endif // E_STEPPERS > 5
+          #endif // E_STEPPERS > 4
+        #endif // E_STEPPERS > 3
+      #endif // E_STEPPERS > 2
+    #endif // E_STEPPERS > 1
+  #endif // E_STEPPERS
 };
 
 constexpr uint32_t _tmc_thrs(const uint16_t msteps, const int32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
 
 void _tmc_say_axis(const TMC_AxisEnum axis);
 void _tmc_say_current(const TMC_AxisEnum axis, const uint16_t curr);
 void _tmc_say_otpw(const TMC_AxisEnum axis, const bool otpw);
 void _tmc_say_otpw_cleared(const TMC_AxisEnum axis);

commit 1a6f2b29b8dd3bc8e6ef56d4f376f49cacfc8785
Author: Holger MuÃàller <holger@mueller-gelff.de>
Date:   Tue Jun 19 18:55:49 2018 +0200

    Add support for Triple-Z steppers/endstops

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 6f11955ac5..f50919b3c9 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -28,21 +28,48 @@
 #if HAS_DRIVER(TMC2130)
   #include <TMC2130Stepper.h>
 #endif
 
 #if HAS_DRIVER(TMC2208)
   #include <TMC2208Stepper.h>
 #endif
 
 extern bool report_tmc_status;
 
-enum TMC_AxisEnum : char { TMC_X, TMC_Y, TMC_Z, TMC_X2, TMC_Y2, TMC_Z2, TMC_E0, TMC_E1, TMC_E2, TMC_E3, TMC_E4 };
+enum TMC_AxisEnum : char {
+  TMC_X, TMC_Y, TMC_Z
+  #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(X_DUAL_STEPPER_DRIVERS)
+    , TMC_X2
+  #endif
+  #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+    , TMC_Y2
+  #endif
+  #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
+    , TMC_Z2
+  #endif
+  #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+    , TMC_Z3
+  #endif
+  , TMC_E0
+  #if E_STEPPERS > 1
+    , TMC_E1
+    #if E_STEPPERS > 2
+      , TMC_E2
+      #if E_STEPPERS > 3
+        , TMC_E3
+        #if E_STEPPERS > 4
+          , TMC_E4
+        #endif
+      #endif
+    #endif
+  #endif
+};
 
 constexpr uint32_t _tmc_thrs(const uint16_t msteps, const int32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
 
 void _tmc_say_axis(const TMC_AxisEnum axis);
 void _tmc_say_current(const TMC_AxisEnum axis, const uint16_t curr);
 void _tmc_say_otpw(const TMC_AxisEnum axis, const bool otpw);
 void _tmc_say_otpw_cleared(const TMC_AxisEnum axis);
 void _tmc_say_pwmthrs(const TMC_AxisEnum axis, const uint32_t thrs);

commit fbcdf5eaeb4f2265fd43097ab6c652a89842d8e7
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sat Jul 14 14:13:06 2018 +0300

    Simplify stepper driver per-axis selection

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 094b65e9b7..6f11955ac5 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -18,25 +18,25 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #ifndef _TMC_UTIL_H_
 #define _TMC_UTIL_H_
 
 #include "../inc/MarlinConfigPre.h"
 
-#if ENABLED(HAVE_TMC2130)
+#if HAS_DRIVER(TMC2130)
   #include <TMC2130Stepper.h>
 #endif
 
-#if ENABLED(HAVE_TMC2208)
+#if HAS_DRIVER(TMC2208)
   #include <TMC2208Stepper.h>
 #endif
 
 extern bool report_tmc_status;
 
 enum TMC_AxisEnum : char { TMC_X, TMC_Y, TMC_Z, TMC_X2, TMC_Y2, TMC_Z2, TMC_E0, TMC_E1, TMC_E2, TMC_E3, TMC_E4 };
 
 constexpr uint32_t _tmc_thrs(const uint16_t msteps, const int32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
@@ -93,15 +93,15 @@ void monitor_tmc_driver();
  * TMC2130 specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if ENABLED(SENSORLESS_HOMING)
   void tmc_sensorless_homing(TMC2130Stepper &st, const bool enable=true);
 #endif
 
-#if ENABLED(HAVE_TMC2130)
+#if HAS_DRIVER(TMC2130)
   void tmc_init_cs_pins();
 #endif
 
 #endif // _TMC_UTIL_H_

commit b76344c080ce0b7f651290dcfeecc6b815fea916
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 10 00:05:15 2018 -0500

    More Trinamic cleanup

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 00560d0ef9..094b65e9b7 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -46,46 +46,46 @@ void _tmc_say_current(const TMC_AxisEnum axis, const uint16_t curr);
 void _tmc_say_otpw(const TMC_AxisEnum axis, const bool otpw);
 void _tmc_say_otpw_cleared(const TMC_AxisEnum axis);
 void _tmc_say_pwmthrs(const TMC_AxisEnum axis, const uint32_t thrs);
 void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt);
 
 template<typename TMC>
 void tmc_get_current(TMC &st, const TMC_AxisEnum axis) {
   _tmc_say_current(axis, st.getCurrent());
 }
 template<typename TMC>
-void tmc_set_current(TMC &st, const TMC_AxisEnum axis, const int mA) {
+void tmc_set_current(TMC &st, const int mA) {
   st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
 }
 template<typename TMC>
 void tmc_report_otpw(TMC &st, const TMC_AxisEnum axis) {
   _tmc_say_otpw(axis, st.getOTPW());
 }
 template<typename TMC>
 void tmc_clear_otpw(TMC &st, const TMC_AxisEnum axis) {
   st.clear_otpw();
   _tmc_say_otpw_cleared(axis);
 }
 template<typename TMC>
 void tmc_get_pwmthrs(TMC &st, const TMC_AxisEnum axis, const uint16_t spmm) {
   _tmc_say_pwmthrs(axis, _tmc_thrs(st.microsteps(), st.TPWMTHRS(), spmm));
 }
 template<typename TMC>
-void tmc_set_pwmthrs(TMC &st, const TMC_AxisEnum axis, const int32_t thrs, const uint32_t spmm) {
+void tmc_set_pwmthrs(TMC &st, const int32_t thrs, const uint32_t spmm) {
   st.TPWMTHRS(_tmc_thrs(st.microsteps(), thrs, spmm));
 }
 template<typename TMC>
 void tmc_get_sgt(TMC &st, const TMC_AxisEnum axis) {
   _tmc_say_sgt(axis, st.sgt());
 }
 template<typename TMC>
-void tmc_set_sgt(TMC &st, const TMC_AxisEnum axis, const int8_t sgt_val) {
+void tmc_set_sgt(TMC &st, const int8_t sgt_val) {
   st.sgt(sgt_val);
 }
 
 void monitor_tmc_driver();
 
 #if ENABLED(TMC_DEBUG)
   void tmc_set_report_status(const bool status);
   void tmc_report_all();
 #endif
 

commit f83361a814df875b3a5bdaadcbcba6732419c4dc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 27 00:51:28 2018 -0500

    Apply const to tmc_sensorless_homing

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 5ddbad2329..00560d0ef9 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -90,18 +90,18 @@ void monitor_tmc_driver();
 #endif
 
 /**
  * TMC2130 specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if ENABLED(SENSORLESS_HOMING)
-  void tmc_sensorless_homing(TMC2130Stepper &st, bool enable=true);
+  void tmc_sensorless_homing(TMC2130Stepper &st, const bool enable=true);
 #endif
 
 #if ENABLED(HAVE_TMC2130)
   void tmc_init_cs_pins();
 #endif
 
 #endif // _TMC_UTIL_H_

commit cfc13ed7f3fd20d2d07d64602e39e732a1cb982a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 14 05:43:18 2018 -0500

    Quiet M906/M913/M914 with axes. Patch for DISTINCT_E_FACTORS.

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 544eaa07a4..5ddbad2329 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -48,48 +48,45 @@ void _tmc_say_otpw_cleared(const TMC_AxisEnum axis);
 void _tmc_say_pwmthrs(const TMC_AxisEnum axis, const uint32_t thrs);
 void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt);
 
 template<typename TMC>
 void tmc_get_current(TMC &st, const TMC_AxisEnum axis) {
   _tmc_say_current(axis, st.getCurrent());
 }
 template<typename TMC>
 void tmc_set_current(TMC &st, const TMC_AxisEnum axis, const int mA) {
   st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
-  tmc_get_current(st, axis);
 }
 template<typename TMC>
 void tmc_report_otpw(TMC &st, const TMC_AxisEnum axis) {
   _tmc_say_otpw(axis, st.getOTPW());
 }
 template<typename TMC>
 void tmc_clear_otpw(TMC &st, const TMC_AxisEnum axis) {
   st.clear_otpw();
   _tmc_say_otpw_cleared(axis);
 }
 template<typename TMC>
 void tmc_get_pwmthrs(TMC &st, const TMC_AxisEnum axis, const uint16_t spmm) {
   _tmc_say_pwmthrs(axis, _tmc_thrs(st.microsteps(), st.TPWMTHRS(), spmm));
 }
 template<typename TMC>
 void tmc_set_pwmthrs(TMC &st, const TMC_AxisEnum axis, const int32_t thrs, const uint32_t spmm) {
   st.TPWMTHRS(_tmc_thrs(st.microsteps(), thrs, spmm));
-  tmc_get_pwmthrs(st, axis, spmm);
 }
 template<typename TMC>
 void tmc_get_sgt(TMC &st, const TMC_AxisEnum axis) {
   _tmc_say_sgt(axis, st.sgt());
 }
 template<typename TMC>
 void tmc_set_sgt(TMC &st, const TMC_AxisEnum axis, const int8_t sgt_val) {
   st.sgt(sgt_val);
-  tmc_get_sgt(st, axis);
 }
 
 void monitor_tmc_driver();
 
 #if ENABLED(TMC_DEBUG)
   void tmc_set_report_status(const bool status);
   void tmc_report_all();
 #endif
 
 /**

commit c95450016b1f42c09ae54a3b293b41de9ff15102
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 14 22:03:53 2018 -0500

    Improve Trinamic support in the EEPROM

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 8ea7a862b9..544eaa07a4 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -28,21 +28,21 @@
 #if ENABLED(HAVE_TMC2130)
   #include <TMC2130Stepper.h>
 #endif
 
 #if ENABLED(HAVE_TMC2208)
   #include <TMC2208Stepper.h>
 #endif
 
 extern bool report_tmc_status;
 
-enum TMC_AxisEnum : char { TMC_X, TMC_X2, TMC_Y, TMC_Y2, TMC_Z, TMC_Z2, TMC_E0, TMC_E1, TMC_E2, TMC_E3, TMC_E4 };
+enum TMC_AxisEnum : char { TMC_X, TMC_Y, TMC_Z, TMC_X2, TMC_Y2, TMC_Z2, TMC_E0, TMC_E1, TMC_E2, TMC_E3, TMC_E4 };
 
 constexpr uint32_t _tmc_thrs(const uint16_t msteps, const int32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
 
 void _tmc_say_axis(const TMC_AxisEnum axis);
 void _tmc_say_current(const TMC_AxisEnum axis, const uint16_t curr);
 void _tmc_say_otpw(const TMC_AxisEnum axis, const bool otpw);
 void _tmc_say_otpw_cleared(const TMC_AxisEnum axis);
 void _tmc_say_pwmthrs(const TMC_AxisEnum axis, const uint32_t thrs);

commit 34f656decd0bd32a221c14b635f2cb1a73c66a61
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 13 02:01:41 2018 -0500

    Add TMC2208 include in tmc_util.h

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 63312f7581..8ea7a862b9 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -16,23 +16,29 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #ifndef _TMC_UTIL_H_
 #define _TMC_UTIL_H_
 
-#include <TMC2130Stepper.h>
+#include "../inc/MarlinConfigPre.h"
 
-#include "../inc/MarlinConfig.h"
+#if ENABLED(HAVE_TMC2130)
+  #include <TMC2130Stepper.h>
+#endif
+
+#if ENABLED(HAVE_TMC2208)
+  #include <TMC2208Stepper.h>
+#endif
 
 extern bool report_tmc_status;
 
 enum TMC_AxisEnum : char { TMC_X, TMC_X2, TMC_Y, TMC_Y2, TMC_Z, TMC_Z2, TMC_E0, TMC_E1, TMC_E2, TMC_E3, TMC_E4 };
 
 constexpr uint32_t _tmc_thrs(const uint16_t msteps, const int32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
 
 void _tmc_say_axis(const TMC_AxisEnum axis);

commit 20571771848e2d8d3bb4f216c25c3d610c7e47cb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 6 22:35:22 2018 -0600

    Make enums into implicit char

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 63848e9703..63312f7581 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -22,21 +22,21 @@
 
 #ifndef _TMC_UTIL_H_
 #define _TMC_UTIL_H_
 
 #include <TMC2130Stepper.h>
 
 #include "../inc/MarlinConfig.h"
 
 extern bool report_tmc_status;
 
-enum TMC_AxisEnum { TMC_X, TMC_X2, TMC_Y, TMC_Y2, TMC_Z, TMC_Z2, TMC_E0, TMC_E1, TMC_E2, TMC_E3, TMC_E4 };
+enum TMC_AxisEnum : char { TMC_X, TMC_X2, TMC_Y, TMC_Y2, TMC_Z, TMC_Z2, TMC_E0, TMC_E1, TMC_E2, TMC_E3, TMC_E4 };
 
 constexpr uint32_t _tmc_thrs(const uint16_t msteps, const int32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
 
 void _tmc_say_axis(const TMC_AxisEnum axis);
 void _tmc_say_current(const TMC_AxisEnum axis, const uint16_t curr);
 void _tmc_say_otpw(const TMC_AxisEnum axis, const bool otpw);
 void _tmc_say_otpw_cleared(const TMC_AxisEnum axis);
 void _tmc_say_pwmthrs(const TMC_AxisEnum axis, const uint32_t thrs);

commit e28e3bb5327ccd6dcf5f87258e3c0a7cfc2175f9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 6 22:16:19 2018 -0600

    Move extended_axis_codes to PROGMEM

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 2265fb9d9a..63848e9703 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -21,72 +21,69 @@
  */
 
 #ifndef _TMC_UTIL_H_
 #define _TMC_UTIL_H_
 
 #include <TMC2130Stepper.h>
 
 #include "../inc/MarlinConfig.h"
 
 extern bool report_tmc_status;
-extern char extended_axis_codes[11][3];
 
-enum TMC_AxisEnum {
-  TMC_X, TMC_X2, TMC_Y, TMC_Y2, TMC_Z, TMC_Z2,
-  TMC_E0, TMC_E1, TMC_E2, TMC_E3, TMC_E4
-};
+enum TMC_AxisEnum { TMC_X, TMC_X2, TMC_Y, TMC_Y2, TMC_Z, TMC_Z2, TMC_E0, TMC_E1, TMC_E2, TMC_E3, TMC_E4 };
 
 constexpr uint32_t _tmc_thrs(const uint16_t msteps, const int32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
 
-void _tmc_say_current(const char name[], const uint16_t curr);
-void _tmc_say_otpw(const char name[], const bool otpw);
-void _tmc_say_otpw_cleared(const char name[]);
-void _tmc_say_pwmthrs(const char name[], const uint32_t thrs);
-void _tmc_say_sgt(const char name[], const int8_t sgt);
+void _tmc_say_axis(const TMC_AxisEnum axis);
+void _tmc_say_current(const TMC_AxisEnum axis, const uint16_t curr);
+void _tmc_say_otpw(const TMC_AxisEnum axis, const bool otpw);
+void _tmc_say_otpw_cleared(const TMC_AxisEnum axis);
+void _tmc_say_pwmthrs(const TMC_AxisEnum axis, const uint32_t thrs);
+void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt);
 
 template<typename TMC>
-void tmc_get_current(TMC &st, const char name[]) {
-  _tmc_say_current(name, st.getCurrent());
+void tmc_get_current(TMC &st, const TMC_AxisEnum axis) {
+  _tmc_say_current(axis, st.getCurrent());
 }
 template<typename TMC>
-void tmc_set_current(TMC &st, const char name[], const int mA) {
+void tmc_set_current(TMC &st, const TMC_AxisEnum axis, const int mA) {
   st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
-  tmc_get_current(st, name);
+  tmc_get_current(st, axis);
 }
 template<typename TMC>
-void tmc_report_otpw(TMC &st, const char name[]) {
-  _tmc_say_otpw(name, st.getOTPW());
+void tmc_report_otpw(TMC &st, const TMC_AxisEnum axis) {
+  _tmc_say_otpw(axis, st.getOTPW());
 }
 template<typename TMC>
-void tmc_clear_otpw(TMC &st, const char name[]) {
+void tmc_clear_otpw(TMC &st, const TMC_AxisEnum axis) {
   st.clear_otpw();
-  _tmc_say_otpw_cleared(name);
+  _tmc_say_otpw_cleared(axis);
 }
 template<typename TMC>
-void tmc_get_pwmthrs(TMC &st, const char name[], const uint16_t spmm) {
-  _tmc_say_pwmthrs(name, _tmc_thrs(st.microsteps(), st.TPWMTHRS(), spmm));
+void tmc_get_pwmthrs(TMC &st, const TMC_AxisEnum axis, const uint16_t spmm) {
+  _tmc_say_pwmthrs(axis, _tmc_thrs(st.microsteps(), st.TPWMTHRS(), spmm));
 }
 template<typename TMC>
-void tmc_set_pwmthrs(TMC &st, const char name[], const int32_t thrs, const uint32_t spmm) {
+void tmc_set_pwmthrs(TMC &st, const TMC_AxisEnum axis, const int32_t thrs, const uint32_t spmm) {
   st.TPWMTHRS(_tmc_thrs(st.microsteps(), thrs, spmm));
-  tmc_get_pwmthrs(st, name, spmm);
+  tmc_get_pwmthrs(st, axis, spmm);
 }
 template<typename TMC>
-void tmc_get_sgt(TMC &st, const char name[]) {
-  _tmc_say_sgt(name, st.sgt());
+void tmc_get_sgt(TMC &st, const TMC_AxisEnum axis) {
+  _tmc_say_sgt(axis, st.sgt());
 }
 template<typename TMC>
-void tmc_set_sgt(TMC &st, const char name[], const int8_t sgt_val) {
+void tmc_set_sgt(TMC &st, const TMC_AxisEnum axis, const int8_t sgt_val) {
   st.sgt(sgt_val);
-  tmc_get_sgt(st, name);
+  tmc_get_sgt(st, axis);
 }
 
 void monitor_tmc_driver();
 
 #if ENABLED(TMC_DEBUG)
   void tmc_set_report_status(const bool status);
   void tmc_report_all();
 #endif
 
 /**

commit 749bc42aa944fe59f012c30571429dab13468c8f
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Feb 16 10:19:33 2018 +0200

    TMC SGT is int8 (#9651)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 46d5b4f286..2265fb9d9a 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -36,21 +36,21 @@ enum TMC_AxisEnum {
 };
 
 constexpr uint32_t _tmc_thrs(const uint16_t msteps, const int32_t thrs, const uint32_t spmm) {
   return 12650000UL * msteps / (256 * thrs * spmm);
 }
 
 void _tmc_say_current(const char name[], const uint16_t curr);
 void _tmc_say_otpw(const char name[], const bool otpw);
 void _tmc_say_otpw_cleared(const char name[]);
 void _tmc_say_pwmthrs(const char name[], const uint32_t thrs);
-void _tmc_say_sgt(const char name[], const uint32_t sgt);
+void _tmc_say_sgt(const char name[], const int8_t sgt);
 
 template<typename TMC>
 void tmc_get_current(TMC &st, const char name[]) {
   _tmc_say_current(name, st.getCurrent());
 }
 template<typename TMC>
 void tmc_set_current(TMC &st, const char name[], const int mA) {
   st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
   tmc_get_current(st, name);
 }

commit 5990266724eb79536cb6d0d72b6130aebba2cbba
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sat Feb 10 22:08:53 2018 +0200

    Init CS pins before loading settings (#9566)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index abe44e9dbc..46d5b4f286 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -93,11 +93,15 @@ void monitor_tmc_driver();
  * TMC2130 specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if ENABLED(SENSORLESS_HOMING)
   void tmc_sensorless_homing(TMC2130Stepper &st, bool enable=true);
 #endif
 
+#if ENABLED(HAVE_TMC2130)
+  void tmc_init_cs_pins();
+#endif
+
 #endif // _TMC_UTIL_H_

commit 6a043eee558695e91f64b6f4a48fcd1816a5f130
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 9 19:14:07 2018 -0600

    Various updates for TMC support

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 7741c7b449..abe44e9dbc 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -28,86 +28,76 @@
 #include "../inc/MarlinConfig.h"
 
 extern bool report_tmc_status;
 extern char extended_axis_codes[11][3];
 
 enum TMC_AxisEnum {
   TMC_X, TMC_X2, TMC_Y, TMC_Y2, TMC_Z, TMC_Z2,
   TMC_E0, TMC_E1, TMC_E2, TMC_E3, TMC_E4
 };
 
+constexpr uint32_t _tmc_thrs(const uint16_t msteps, const int32_t thrs, const uint32_t spmm) {
+  return 12650000UL * msteps / (256 * thrs * spmm);
+}
+
+void _tmc_say_current(const char name[], const uint16_t curr);
+void _tmc_say_otpw(const char name[], const bool otpw);
+void _tmc_say_otpw_cleared(const char name[]);
+void _tmc_say_pwmthrs(const char name[], const uint32_t thrs);
+void _tmc_say_sgt(const char name[], const uint32_t sgt);
+
 template<typename TMC>
 void tmc_get_current(TMC &st, const char name[]) {
-  SERIAL_ECHO(name);
-  SERIAL_ECHOPGM(" axis driver current: ");
-  SERIAL_ECHOLN(st.getCurrent());
+  _tmc_say_current(name, st.getCurrent());
 }
 template<typename TMC>
 void tmc_set_current(TMC &st, const char name[], const int mA) {
   st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
   tmc_get_current(st, name);
 }
 template<typename TMC>
 void tmc_report_otpw(TMC &st, const char name[]) {
-  SERIAL_ECHO(name);
-  SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
-  serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
-  SERIAL_EOL();
+  _tmc_say_otpw(name, st.getOTPW());
 }
 template<typename TMC>
 void tmc_clear_otpw(TMC &st, const char name[]) {
   st.clear_otpw();
-  SERIAL_ECHO(name);
-  SERIAL_ECHOLNPGM(" prewarn flag cleared");
+  _tmc_say_otpw_cleared(name);
 }
 template<typename TMC>
 void tmc_get_pwmthrs(TMC &st, const char name[], const uint16_t spmm) {
-  SERIAL_ECHO(name);
-  SERIAL_ECHOPGM(" stealthChop max speed set to ");
-  SERIAL_ECHOLN(12650000UL * st.microsteps() / (256 * st.TPWMTHRS() * spmm));
+  _tmc_say_pwmthrs(name, _tmc_thrs(st.microsteps(), st.TPWMTHRS(), spmm));
 }
 template<typename TMC>
 void tmc_set_pwmthrs(TMC &st, const char name[], const int32_t thrs, const uint32_t spmm) {
-  st.TPWMTHRS(12650000UL * st.microsteps() / (256 * thrs * spmm));
+  st.TPWMTHRS(_tmc_thrs(st.microsteps(), thrs, spmm));
   tmc_get_pwmthrs(st, name, spmm);
 }
 template<typename TMC>
 void tmc_get_sgt(TMC &st, const char name[]) {
-  SERIAL_ECHO(name);
-  SERIAL_ECHOPGM(" driver homing sensitivity set to ");
-  MYSERIAL.println(st.sgt(), DEC);
+  _tmc_say_sgt(name, st.sgt());
 }
 template<typename TMC>
 void tmc_set_sgt(TMC &st, const char name[], const int8_t sgt_val) {
   st.sgt(sgt_val);
   tmc_get_sgt(st, name);
 }
 
-void _M122();
 void monitor_tmc_driver();
 
+#if ENABLED(TMC_DEBUG)
+  void tmc_set_report_status(const bool status);
+  void tmc_report_all();
+#endif
+
 /**
  * TMC2130 specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually exclusive.
  *
  * Defined here because of limitations with templates and headers.
  */
 #if ENABLED(SENSORLESS_HOMING)
-  template<typename TMC>
-  void tmc_sensorless_homing(TMC &st, bool enable=true) {
-    #if ENABLED(STEALTHCHOP)
-      if (enable) {
-        st.coolstep_min_speed(1024UL * 1024UL - 1UL);
-        st.stealthChop(0);
-      }
-      else {
-        st.coolstep_min_speed(0);
-        st.stealthChop(1);
-      }
-    #endif
-
-    st.diag1_stall(enable ? 1 : 0);
-  }
+  void tmc_sensorless_homing(TMC2130Stepper &st, bool enable=true);
 #endif
 
 #endif // _TMC_UTIL_H_

commit 9d923c6c03e87cc8b66882ed9325ac47ddf9c3a0
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 29 21:38:08 2017 +0200

    Fix TMC gcode commands

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 72d3b15bb5..7741c7b449 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -22,41 +22,72 @@
 
 #ifndef _TMC_UTIL_H_
 #define _TMC_UTIL_H_
 
 #include <TMC2130Stepper.h>
 
 #include "../inc/MarlinConfig.h"
 
 extern bool report_tmc_status;
 extern char extended_axis_codes[11][3];
+
 enum TMC_AxisEnum {
   TMC_X, TMC_X2, TMC_Y, TMC_Y2, TMC_Z, TMC_Z2,
   TMC_E0, TMC_E1, TMC_E2, TMC_E3, TMC_E4
 };
 
 template<typename TMC>
-void tmc_get_current(TMC &st, const char name[]);
+void tmc_get_current(TMC &st, const char name[]) {
+  SERIAL_ECHO(name);
+  SERIAL_ECHOPGM(" axis driver current: ");
+  SERIAL_ECHOLN(st.getCurrent());
+}
 template<typename TMC>
-void tmc_set_current(TMC &st, const char name[], const int mA);
+void tmc_set_current(TMC &st, const char name[], const int mA) {
+  st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
+  tmc_get_current(st, name);
+}
 template<typename TMC>
-void tmc_report_otpw(TMC &st, const char name[]);
+void tmc_report_otpw(TMC &st, const char name[]) {
+  SERIAL_ECHO(name);
+  SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
+  serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
+  SERIAL_EOL();
+}
 template<typename TMC>
-void tmc_clear_otpw(TMC &st, const char name[]);
+void tmc_clear_otpw(TMC &st, const char name[]) {
+  st.clear_otpw();
+  SERIAL_ECHO(name);
+  SERIAL_ECHOLNPGM(" prewarn flag cleared");
+}
 template<typename TMC>
-void tmc_get_pwmthrs(TMC &st, const char name[], const uint16_t spmm);
+void tmc_get_pwmthrs(TMC &st, const char name[], const uint16_t spmm) {
+  SERIAL_ECHO(name);
+  SERIAL_ECHOPGM(" stealthChop max speed set to ");
+  SERIAL_ECHOLN(12650000UL * st.microsteps() / (256 * st.TPWMTHRS() * spmm));
+}
 template<typename TMC>
-void tmc_set_pwmthrs(TMC &st, const char name[], const int32_t thrs, const uint32_t spmm);
+void tmc_set_pwmthrs(TMC &st, const char name[], const int32_t thrs, const uint32_t spmm) {
+  st.TPWMTHRS(12650000UL * st.microsteps() / (256 * thrs * spmm));
+  tmc_get_pwmthrs(st, name, spmm);
+}
 template<typename TMC>
-void tmc_get_sgt(TMC &st, const char name[]);
+void tmc_get_sgt(TMC &st, const char name[]) {
+  SERIAL_ECHO(name);
+  SERIAL_ECHOPGM(" driver homing sensitivity set to ");
+  MYSERIAL.println(st.sgt(), DEC);
+}
 template<typename TMC>
-void tmc_set_sgt(TMC &st, const char name[], const int8_t sgt_val);
+void tmc_set_sgt(TMC &st, const char name[], const int8_t sgt_val) {
+  st.sgt(sgt_val);
+  tmc_get_sgt(st, name);
+}
 
 void _M122();
 void monitor_tmc_driver();
 
 /**
  * TMC2130 specific sensorless homing using stallGuard2.
  * stallGuard2 only works when in spreadCycle mode.
  * spreadCycle and stealthChop are mutually exclusive.
  *
  * Defined here because of limitations with templates and headers.

commit b259bb46706fbd5034ddf1881d46159cd79232ef
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Dec 25 09:05:31 2017 -0600

    Fix tmc_util global vars

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
index 5ccd7560fa..72d3b15bb5 100644
--- a/Marlin/src/feature/tmc_util.h
+++ b/Marlin/src/feature/tmc_util.h
@@ -20,22 +20,22 @@
  *
  */
 
 #ifndef _TMC_UTIL_H_
 #define _TMC_UTIL_H_
 
 #include <TMC2130Stepper.h>
 
 #include "../inc/MarlinConfig.h"
 
-static bool report_tmc_status = false;
-const char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1", "E2", "E3", "E4" };
+extern bool report_tmc_status;
+extern char extended_axis_codes[11][3];
 enum TMC_AxisEnum {
   TMC_X, TMC_X2, TMC_Y, TMC_Y2, TMC_Z, TMC_Z2,
   TMC_E0, TMC_E1, TMC_E2, TMC_E3, TMC_E4
 };
 
 template<typename TMC>
 void tmc_get_current(TMC &st, const char name[]);
 template<typename TMC>
 void tmc_set_current(TMC &st, const char name[], const int mA);
 template<typename TMC>

commit 0cd1e91056213d6a0bd422848ccff7cd1191d001
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 15 23:03:14 2017 +0200

    [2.0.x] TMC driver update (#8769)

diff --git a/Marlin/src/feature/tmc_util.h b/Marlin/src/feature/tmc_util.h
new file mode 100644
index 0000000000..5ccd7560fa
--- /dev/null
+++ b/Marlin/src/feature/tmc_util.h
@@ -0,0 +1,82 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef _TMC_UTIL_H_
+#define _TMC_UTIL_H_
+
+#include <TMC2130Stepper.h>
+
+#include "../inc/MarlinConfig.h"
+
+static bool report_tmc_status = false;
+const char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1", "E2", "E3", "E4" };
+enum TMC_AxisEnum {
+  TMC_X, TMC_X2, TMC_Y, TMC_Y2, TMC_Z, TMC_Z2,
+  TMC_E0, TMC_E1, TMC_E2, TMC_E3, TMC_E4
+};
+
+template<typename TMC>
+void tmc_get_current(TMC &st, const char name[]);
+template<typename TMC>
+void tmc_set_current(TMC &st, const char name[], const int mA);
+template<typename TMC>
+void tmc_report_otpw(TMC &st, const char name[]);
+template<typename TMC>
+void tmc_clear_otpw(TMC &st, const char name[]);
+template<typename TMC>
+void tmc_get_pwmthrs(TMC &st, const char name[], const uint16_t spmm);
+template<typename TMC>
+void tmc_set_pwmthrs(TMC &st, const char name[], const int32_t thrs, const uint32_t spmm);
+template<typename TMC>
+void tmc_get_sgt(TMC &st, const char name[]);
+template<typename TMC>
+void tmc_set_sgt(TMC &st, const char name[], const int8_t sgt_val);
+
+void _M122();
+void monitor_tmc_driver();
+
+/**
+ * TMC2130 specific sensorless homing using stallGuard2.
+ * stallGuard2 only works when in spreadCycle mode.
+ * spreadCycle and stealthChop are mutually exclusive.
+ *
+ * Defined here because of limitations with templates and headers.
+ */
+#if ENABLED(SENSORLESS_HOMING)
+  template<typename TMC>
+  void tmc_sensorless_homing(TMC &st, bool enable=true) {
+    #if ENABLED(STEALTHCHOP)
+      if (enable) {
+        st.coolstep_min_speed(1024UL * 1024UL - 1UL);
+        st.stealthChop(0);
+      }
+      else {
+        st.coolstep_min_speed(0);
+        st.stealthChop(1);
+      }
+    #endif
+
+    st.diag1_stall(enable ? 1 : 0);
+  }
+#endif
+
+#endif // _TMC_UTIL_H_
