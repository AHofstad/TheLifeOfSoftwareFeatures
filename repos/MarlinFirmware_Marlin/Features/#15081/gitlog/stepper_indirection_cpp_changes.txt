commit 586b334c2ab61240607e878390ed1d53af86da69
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 31 19:44:45 2019 -0500

    Split up stepper indirection (#15111)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
deleted file mode 100644
index 80d7978e33..0000000000
--- a/Marlin/src/module/stepper_indirection.cpp
+++ /dev/null
@@ -1,1066 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * stepper_indirection.cpp
- *
- * Stepper motor driver indirection to allow some stepper functions to
- * be done via SPI/I2c instead of direct pin manipulation.
- *
- * Copyright (c) 2015 Dominik Wenger
- */
-
-#include "stepper_indirection.h"
-
-#include "../inc/MarlinConfig.h"
-
-#include "stepper.h"
-
-#if HAS_DRIVER(L6470)
-  #include "L6470/L6470_Marlin.h"
-#endif
-
-//
-// TMC26X Driver objects and inits
-//
-#if HAS_DRIVER(TMC26X)
-  #include <SPI.h>
-
-  #if defined(STM32GENERIC) && defined(STM32F7)
-    #include "../HAL/HAL_STM32_F4_F7/STM32F7/TMC2660.h"
-  #else
-    #include <TMC26XStepper.h>
-  #endif
-
-  #define _TMC26X_DEFINE(ST) TMC26XStepper stepper##ST(200, ST##_CS_PIN, ST##_STEP_PIN, ST##_DIR_PIN, ST##_MAX_CURRENT, ST##_SENSE_RESISTOR)
-
-  #if AXIS_DRIVER_TYPE_X(TMC26X)
-    _TMC26X_DEFINE(X);
-  #endif
-  #if AXIS_DRIVER_TYPE_X2(TMC26X)
-    _TMC26X_DEFINE(X2);
-  #endif
-  #if AXIS_DRIVER_TYPE_Y(TMC26X)
-    _TMC26X_DEFINE(Y);
-  #endif
-  #if AXIS_DRIVER_TYPE_Y2(TMC26X)
-    _TMC26X_DEFINE(Y2);
-  #endif
-  #if AXIS_DRIVER_TYPE_Z(TMC26X)
-    _TMC26X_DEFINE(Z);
-  #endif
-  #if AXIS_DRIVER_TYPE_Z2(TMC26X)
-    _TMC26X_DEFINE(Z2);
-  #endif
-  #if AXIS_DRIVER_TYPE_Z3(TMC26X)
-    _TMC26X_DEFINE(Z3);
-  #endif
-  #if AXIS_DRIVER_TYPE_E0(TMC26X)
-    _TMC26X_DEFINE(E0);
-  #endif
-  #if AXIS_DRIVER_TYPE_E1(TMC26X)
-    _TMC26X_DEFINE(E1);
-  #endif
-  #if AXIS_DRIVER_TYPE_E2(TMC26X)
-    _TMC26X_DEFINE(E2);
-  #endif
-  #if AXIS_DRIVER_TYPE_E3(TMC26X)
-    _TMC26X_DEFINE(E3);
-  #endif
-  #if AXIS_DRIVER_TYPE_E4(TMC26X)
-    _TMC26X_DEFINE(E4);
-  #endif
-  #if AXIS_DRIVER_TYPE_E5(TMC26X)
-    _TMC26X_DEFINE(E5);
-  #endif
-
-  #define _TMC26X_INIT(A) do{ \
-    stepper##A.setMicrosteps(A##_MICROSTEPS); \
-    stepper##A.start(); \
-  }while(0)
-
-  void tmc26x_init_to_defaults() {
-    #if AXIS_DRIVER_TYPE_X(TMC26X)
-      _TMC26X_INIT(X);
-    #endif
-    #if AXIS_DRIVER_TYPE_X2(TMC26X)
-      _TMC26X_INIT(X2);
-    #endif
-    #if AXIS_DRIVER_TYPE_Y(TMC26X)
-      _TMC26X_INIT(Y);
-    #endif
-    #if AXIS_DRIVER_TYPE_Y2(TMC26X)
-      _TMC26X_INIT(Y2);
-    #endif
-    #if AXIS_DRIVER_TYPE_Z(TMC26X)
-      _TMC26X_INIT(Z);
-    #endif
-    #if AXIS_DRIVER_TYPE_Z2(TMC26X)
-      _TMC26X_INIT(Z2);
-    #endif
-    #if AXIS_DRIVER_TYPE_Z3(TMC26X)
-      _TMC26X_INIT(Z3);
-    #endif
-    #if AXIS_DRIVER_TYPE_E0(TMC26X)
-      _TMC26X_INIT(E0);
-    #endif
-    #if AXIS_DRIVER_TYPE_E1(TMC26X)
-      _TMC26X_INIT(E1);
-    #endif
-    #if AXIS_DRIVER_TYPE_E2(TMC26X)
-      _TMC26X_INIT(E2);
-    #endif
-    #if AXIS_DRIVER_TYPE_E3(TMC26X)
-      _TMC26X_INIT(E3);
-    #endif
-    #if AXIS_DRIVER_TYPE_E4(TMC26X)
-      _TMC26X_INIT(E4);
-    #endif
-    #if AXIS_DRIVER_TYPE_E5(TMC26X)
-      _TMC26X_INIT(E5);
-    #endif
-  }
-#endif // TMC26X
-
-#if HAS_TRINAMIC
-  #include <HardwareSerial.h>
-  #include <SPI.h>
-  #include "planner.h"
-  #include "../core/enum.h"
-
-  enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
-  #define _TMC_INIT(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, stealthchop_by_axis[STEALTH_INDEX])
-
-  //   IC = TMC model number
-  //   ST = Stepper object letter
-  //   L  = Label characters
-  //   AI = Axis Enum Index
-  // SWHW = SW/SH UART selection
-  #if ENABLED(TMC_USE_SW_SPI)
-    #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, ST##_RSENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
-  #else
-    #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, ST##_RSENSE)
-  #endif
-
-  #define TMC_UART_HW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(&ST##_HARDWARE_SERIAL, ST##_RSENSE, ST##_SLAVE_ADDRESS)
-  #define TMC_UART_SW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN, ST##_RSENSE, ST##_SLAVE_ADDRESS, ST##_SERIAL_RX_PIN > -1)
-
-  #define _TMC_SPI_DEFINE(IC, ST, AI) __TMC_SPI_DEFINE(IC, ST, TMC_##ST##_LABEL, AI)
-  #define TMC_SPI_DEFINE(ST, AI) _TMC_SPI_DEFINE(ST##_DRIVER_TYPE, ST, AI##_AXIS)
-
-  #define _TMC_UART_DEFINE(SWHW, IC, ST, AI) TMC_UART_##SWHW##_DEFINE(IC, ST, TMC_##ST##_LABEL, AI)
-  #define TMC_UART_DEFINE(SWHW, ST, AI) _TMC_UART_DEFINE(SWHW, ST##_DRIVER_TYPE, ST, AI##_AXIS)
-
-  #if ENABLED(DISTINCT_E_FACTORS) && E_STEPPERS > 1
-    #define TMC_SPI_DEFINE_E(AI) TMC_SPI_DEFINE(E##AI, E##AI)
-    #define TMC_UART_DEFINE_E(SWHW, AI) TMC_UART_DEFINE(SWHW, E##AI, E##AI)
-  #else
-    #define TMC_SPI_DEFINE_E(AI) TMC_SPI_DEFINE(E##AI, E)
-    #define TMC_UART_DEFINE_E(SWHW, AI) TMC_UART_DEFINE(SWHW, E##AI, E)
-  #endif
-
-  // Stepper objects of TMC2130/TMC2160/TMC2660/TMC5130/TMC5160 steppers used
-  #if AXIS_HAS_SPI(X)
-    TMC_SPI_DEFINE(X, X);
-  #endif
-  #if AXIS_HAS_SPI(X2)
-    TMC_SPI_DEFINE(X2, X);
-  #endif
-  #if AXIS_HAS_SPI(Y)
-    TMC_SPI_DEFINE(Y, Y);
-  #endif
-  #if AXIS_HAS_SPI(Y2)
-    TMC_SPI_DEFINE(Y2, Y);
-  #endif
-  #if AXIS_HAS_SPI(Z)
-    TMC_SPI_DEFINE(Z, Z);
-  #endif
-  #if AXIS_HAS_SPI(Z2)
-    TMC_SPI_DEFINE(Z2, Z);
-  #endif
-  #if AXIS_HAS_SPI(Z3)
-    TMC_SPI_DEFINE(Z3, Z);
-  #endif
-  #if AXIS_HAS_SPI(E0)
-    TMC_SPI_DEFINE_E(0);
-  #endif
-  #if AXIS_HAS_SPI(E1)
-    TMC_SPI_DEFINE_E(1);
-  #endif
-  #if AXIS_HAS_SPI(E2)
-    TMC_SPI_DEFINE_E(2);
-  #endif
-  #if AXIS_HAS_SPI(E3)
-    TMC_SPI_DEFINE_E(3);
-  #endif
-  #if AXIS_HAS_SPI(E4)
-    TMC_SPI_DEFINE_E(4);
-  #endif
-  #if AXIS_HAS_SPI(E5)
-    TMC_SPI_DEFINE_E(5);
-  #endif
-
-#endif
-
-#if HAS_DRIVER(TMC2130)
-  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
-    st.begin();
-
-    CHOPCONF_t chopconf{0};
-    chopconf.tbl = 1;
-    chopconf.toff = chopper_timing.toff;
-    chopconf.intpol = INTERPOLATE;
-    chopconf.hend = chopper_timing.hend + 3;
-    chopconf.hstrt = chopper_timing.hstrt - 1;
-    #if ENABLED(SQUARE_WAVE_STEPPING)
-      chopconf.dedge = true;
-    #endif
-    st.CHOPCONF(chopconf.sr);
-
-    st.rms_current(mA, HOLD_MULTIPLIER);
-    st.microsteps(microsteps);
-    st.iholddelay(10);
-    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
-
-    st.en_pwm_mode(stealth);
-    st.stored.stealthChop_enabled = stealth;
-
-    PWMCONF_t pwmconf{0};
-    pwmconf.pwm_freq = 0b01; // f_pwm = 2/683 f_clk
-    pwmconf.pwm_autoscale = true;
-    pwmconf.pwm_grad = 5;
-    pwmconf.pwm_ampl = 180;
-    st.PWMCONF(pwmconf.sr);
-
-    #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(thrs);
-    #else
-      UNUSED(thrs);
-    #endif
-
-    st.GSTAT(); // Clear GSTAT
-  }
-#endif // TMC2130
-
-#if HAS_DRIVER(TMC2160)
-  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
-    st.begin();
-
-    CHOPCONF_t chopconf{0};
-    chopconf.tbl = 1;
-    chopconf.toff = chopper_timing.toff;
-    chopconf.intpol = INTERPOLATE;
-    chopconf.hend = chopper_timing.hend + 3;
-    chopconf.hstrt = chopper_timing.hstrt - 1;
-    #if ENABLED(SQUARE_WAVE_STEPPING)
-      chopconf.dedge = true;
-    #endif
-    st.CHOPCONF(chopconf.sr);
-
-    st.rms_current(mA, HOLD_MULTIPLIER);
-    st.microsteps(microsteps);
-    st.iholddelay(10);
-    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
-
-    st.en_pwm_mode(stealth);
-    st.stored.stealthChop_enabled = stealth;
-
-    TMC2160_n::PWMCONF_t pwmconf{0};
-    pwmconf.pwm_lim = 12;
-    pwmconf.pwm_reg = 8;
-    pwmconf.pwm_autograd = true;
-    pwmconf.pwm_autoscale = true;
-    pwmconf.pwm_freq = 0b01;
-    pwmconf.pwm_grad = 14;
-    pwmconf.pwm_ofs = 36;
-    st.PWMCONF(pwmconf.sr);
-
-    #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(thrs);
-    #else
-      UNUSED(thrs);
-    #endif
-
-    st.GSTAT(); // Clear GSTAT
-  }
-#endif // TMC2160
-
-//
-// TMC2208/2209 Driver objects and inits
-//
-#if HAS_TMC220x
-  #if AXIS_HAS_UART(X)
-    #ifdef X_HARDWARE_SERIAL
-      TMC_UART_DEFINE(HW, X, X);
-    #else
-      TMC_UART_DEFINE(SW, X, X);
-    #endif
-  #endif
-  #if AXIS_HAS_UART(X2)
-    #ifdef X2_HARDWARE_SERIAL
-      TMC_UART_DEFINE(HW, X2, X);
-    #else
-      TMC_UART_DEFINE(SW, X2, X);
-    #endif
-  #endif
-  #if AXIS_HAS_UART(Y)
-    #ifdef Y_HARDWARE_SERIAL
-      TMC_UART_DEFINE(HW, Y, Y);
-    #else
-      TMC_UART_DEFINE(SW, Y, Y);
-    #endif
-  #endif
-  #if AXIS_HAS_UART(Y2)
-    #ifdef Y2_HARDWARE_SERIAL
-      TMC_UART_DEFINE(HW, Y2, Y);
-    #else
-      TMC_UART_DEFINE(SW, Y2, Y);
-    #endif
-  #endif
-  #if AXIS_HAS_UART(Z)
-    #ifdef Z_HARDWARE_SERIAL
-      TMC_UART_DEFINE(HW, Z, Z);
-    #else
-      TMC_UART_DEFINE(SW, Z, Z);
-    #endif
-  #endif
-  #if AXIS_HAS_UART(Z2)
-    #ifdef Z2_HARDWARE_SERIAL
-      TMC_UART_DEFINE(HW, Z2, Z);
-    #else
-      TMC_UART_DEFINE(SW, Z2, Z);
-    #endif
-  #endif
-  #if AXIS_HAS_UART(Z3)
-    #ifdef Z3_HARDWARE_SERIAL
-      TMC_UART_DEFINE(HW, Z3, Z);
-    #else
-      TMC_UART_DEFINE(SW, Z3, Z);
-    #endif
-  #endif
-  #if AXIS_HAS_UART(E0)
-    #ifdef E0_HARDWARE_SERIAL
-      TMC_UART_DEFINE_E(HW, 0);
-    #else
-      TMC_UART_DEFINE_E(SW, 0);
-    #endif
-  #endif
-  #if AXIS_HAS_UART(E1)
-    #ifdef E1_HARDWARE_SERIAL
-      TMC_UART_DEFINE_E(HW, 1);
-    #else
-      TMC_UART_DEFINE_E(SW, 1);
-    #endif
-  #endif
-  #if AXIS_HAS_UART(E2)
-    #ifdef E2_HARDWARE_SERIAL
-      TMC_UART_DEFINE_E(HW, 2);
-    #else
-      TMC_UART_DEFINE_E(SW, 2);
-    #endif
-  #endif
-  #if AXIS_HAS_UART(E3)
-    #ifdef E3_HARDWARE_SERIAL
-      TMC_UART_DEFINE_E(HW, 3);
-    #else
-      TMC_UART_DEFINE_E(SW, 3);
-    #endif
-  #endif
-  #if AXIS_HAS_UART(E4)
-    #ifdef E4_HARDWARE_SERIAL
-      TMC_UART_DEFINE_E(HW, 4);
-    #else
-      TMC_UART_DEFINE_E(SW, 4);
-    #endif
-  #endif
-  #if AXIS_HAS_UART(E5)
-    #ifdef E5_HARDWARE_SERIAL
-      TMC_UART_DEFINE_E(HW, 5);
-    #else
-      TMC_UART_DEFINE_E(SW, 5);
-    #endif
-  #endif
-
-  void tmc_serial_begin() {
-    #if AXIS_HAS_UART(X)
-      #ifdef X_HARDWARE_SERIAL
-        X_HARDWARE_SERIAL.begin(115200);
-      #else
-        stepperX.beginSerial(115200);
-      #endif
-    #endif
-    #if AXIS_HAS_UART(X2)
-      #ifdef X2_HARDWARE_SERIAL
-        X2_HARDWARE_SERIAL.begin(115200);
-      #else
-        stepperX2.beginSerial(115200);
-      #endif
-    #endif
-    #if AXIS_HAS_UART(Y)
-      #ifdef Y_HARDWARE_SERIAL
-        Y_HARDWARE_SERIAL.begin(115200);
-      #else
-        stepperY.beginSerial(115200);
-      #endif
-    #endif
-    #if AXIS_HAS_UART(Y2)
-      #ifdef Y2_HARDWARE_SERIAL
-        Y2_HARDWARE_SERIAL.begin(115200);
-      #else
-        stepperY2.beginSerial(115200);
-      #endif
-    #endif
-    #if AXIS_HAS_UART(Z)
-      #ifdef Z_HARDWARE_SERIAL
-        Z_HARDWARE_SERIAL.begin(115200);
-      #else
-        stepperZ.beginSerial(115200);
-      #endif
-    #endif
-    #if AXIS_HAS_UART(Z2)
-      #ifdef Z2_HARDWARE_SERIAL
-        Z2_HARDWARE_SERIAL.begin(115200);
-      #else
-        stepperZ2.beginSerial(115200);
-      #endif
-    #endif
-    #if AXIS_HAS_UART(Z3)
-      #ifdef Z3_HARDWARE_SERIAL
-        Z3_HARDWARE_SERIAL.begin(115200);
-      #else
-        stepperZ3.beginSerial(115200);
-      #endif
-    #endif
-    #if AXIS_HAS_UART(E0)
-      #ifdef E0_HARDWARE_SERIAL
-        E0_HARDWARE_SERIAL.begin(115200);
-      #else
-        stepperE0.beginSerial(115200);
-      #endif
-    #endif
-    #if AXIS_HAS_UART(E1)
-      #ifdef E1_HARDWARE_SERIAL
-        E1_HARDWARE_SERIAL.begin(115200);
-      #else
-        stepperE1.beginSerial(115200);
-      #endif
-    #endif
-    #if AXIS_HAS_UART(E2)
-      #ifdef E2_HARDWARE_SERIAL
-        E2_HARDWARE_SERIAL.begin(115200);
-      #else
-        stepperE2.beginSerial(115200);
-      #endif
-    #endif
-    #if AXIS_HAS_UART(E3)
-      #ifdef E3_HARDWARE_SERIAL
-        E3_HARDWARE_SERIAL.begin(115200);
-      #else
-        stepperE3.beginSerial(115200);
-      #endif
-    #endif
-    #if AXIS_HAS_UART(E4)
-      #ifdef E4_HARDWARE_SERIAL
-        E4_HARDWARE_SERIAL.begin(115200);
-      #else
-        stepperE4.beginSerial(115200);
-      #endif
-    #endif
-    #if AXIS_HAS_UART(E5)
-      #ifdef E5_HARDWARE_SERIAL
-        E5_HARDWARE_SERIAL.begin(115200);
-      #else
-        stepperE5.beginSerial(115200);
-      #endif
-    #endif
-  }
-#endif
-
-#if HAS_DRIVER(TMC2208)
-  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
-    TMC2208_n::GCONF_t gconf{0};
-    gconf.pdn_disable = true; // Use UART
-    gconf.mstep_reg_select = true; // Select microsteps with UART
-    gconf.i_scale_analog = false;
-    gconf.en_spreadcycle = !stealth;
-    st.GCONF(gconf.sr);
-    st.stored.stealthChop_enabled = stealth;
-
-    TMC2208_n::CHOPCONF_t chopconf{0};
-    chopconf.tbl = 0b01; // blank_time = 24
-    chopconf.toff = chopper_timing.toff;
-    chopconf.intpol = INTERPOLATE;
-    chopconf.hend = chopper_timing.hend + 3;
-    chopconf.hstrt = chopper_timing.hstrt - 1;
-    #if ENABLED(SQUARE_WAVE_STEPPING)
-      chopconf.dedge = true;
-    #endif
-    st.CHOPCONF(chopconf.sr);
-
-    st.rms_current(mA, HOLD_MULTIPLIER);
-    st.microsteps(microsteps);
-    st.iholddelay(10);
-    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
-
-    TMC2208_n::PWMCONF_t pwmconf{0};
-    pwmconf.pwm_lim = 12;
-    pwmconf.pwm_reg = 8;
-    pwmconf.pwm_autograd = true;
-    pwmconf.pwm_autoscale = true;
-    pwmconf.pwm_freq = 0b01;
-    pwmconf.pwm_grad = 14;
-    pwmconf.pwm_ofs = 36;
-    st.PWMCONF(pwmconf.sr);
-
-    #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(thrs);
-    #else
-      UNUSED(thrs);
-    #endif
-
-    st.GSTAT(0b111); // Clear
-    delay(200);
-  }
-#endif // TMC2208
-
-#if HAS_DRIVER(TMC2209)
-  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
-    TMC2208_n::GCONF_t gconf{0};
-    gconf.pdn_disable = true; // Use UART
-    gconf.mstep_reg_select = true; // Select microsteps with UART
-    gconf.i_scale_analog = false;
-    gconf.en_spreadcycle = !stealth;
-    st.GCONF(gconf.sr);
-    st.stored.stealthChop_enabled = stealth;
-
-    TMC2208_n::CHOPCONF_t chopconf{0};
-    chopconf.tbl = 0b01; // blank_time = 24
-    chopconf.toff = chopper_timing.toff;
-    chopconf.intpol = INTERPOLATE;
-    chopconf.hend = chopper_timing.hend + 3;
-    chopconf.hstrt = chopper_timing.hstrt - 1;
-    #if ENABLED(SQUARE_WAVE_STEPPING)
-      chopconf.dedge = true;
-    #endif
-    st.CHOPCONF(chopconf.sr);
-
-    st.rms_current(mA, HOLD_MULTIPLIER);
-    st.microsteps(microsteps);
-    st.iholddelay(10);
-    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
-
-    TMC2208_n::PWMCONF_t pwmconf{0};
-    pwmconf.pwm_lim = 12;
-    pwmconf.pwm_reg = 8;
-    pwmconf.pwm_autograd = true;
-    pwmconf.pwm_autoscale = true;
-    pwmconf.pwm_freq = 0b01;
-    pwmconf.pwm_grad = 14;
-    pwmconf.pwm_ofs = 36;
-    st.PWMCONF(pwmconf.sr);
-
-    #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(thrs);
-    #else
-      UNUSED(thrs);
-    #endif
-
-    st.GSTAT(0b111); // Clear
-    delay(200);
-  }
-#endif // TMC2209
-
-#if HAS_DRIVER(TMC2660)
-  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const bool) {
-    st.begin();
-
-    TMC2660_n::CHOPCONF_t chopconf{0};
-    chopconf.tbl = 1;
-    chopconf.toff = chopper_timing.toff;
-    chopconf.hend = chopper_timing.hend + 3;
-    chopconf.hstrt = chopper_timing.hstrt - 1;
-    st.CHOPCONF(chopconf.sr);
-
-    st.sdoff(0);
-    st.rms_current(mA);
-    st.microsteps(microsteps);
-    #if ENABLED(SQUARE_WAVE_STEPPING)
-      st.dedge(true);
-    #endif
-    st.intpol(INTERPOLATE);
-    st.diss2g(true); // Disable short to ground protection. Too many false readings?
-
-    #if ENABLED(TMC_DEBUG)
-      st.rdsel(0b01);
-    #endif
-  }
-#endif // TMC2660
-
-#if HAS_DRIVER(TMC5130)
-  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC5130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
-    st.begin();
-
-    CHOPCONF_t chopconf{0};
-    chopconf.tbl = 1;
-    chopconf.toff = chopper_timing.toff;
-    chopconf.intpol = INTERPOLATE;
-    chopconf.hend = chopper_timing.hend + 3;
-    chopconf.hstrt = chopper_timing.hstrt - 1;
-    #if ENABLED(SQUARE_WAVE_STEPPING)
-      chopconf.dedge = true;
-    #endif
-    st.CHOPCONF(chopconf.sr);
-
-    st.rms_current(mA, HOLD_MULTIPLIER);
-    st.microsteps(microsteps);
-    st.iholddelay(10);
-    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
-
-    st.en_pwm_mode(stealth);
-    st.stored.stealthChop_enabled = stealth;
-
-    PWMCONF_t pwmconf{0};
-    pwmconf.pwm_freq = 0b01; // f_pwm = 2/683 f_clk
-    pwmconf.pwm_autoscale = true;
-    pwmconf.pwm_grad = 5;
-    pwmconf.pwm_ampl = 180;
-    st.PWMCONF(pwmconf.sr);
-
-    #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(thrs);
-    #else
-      UNUSED(thrs);
-    #endif
-
-    st.GSTAT(); // Clear GSTAT
-  }
-#endif // TMC5130
-
-#if HAS_DRIVER(TMC5160)
-  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
-    st.begin();
-
-    CHOPCONF_t chopconf{0};
-    chopconf.tbl = 1;
-    chopconf.toff = chopper_timing.toff;
-    chopconf.intpol = INTERPOLATE;
-    chopconf.hend = chopper_timing.hend + 3;
-    chopconf.hstrt = chopper_timing.hstrt - 1;
-    #if ENABLED(SQUARE_WAVE_STEPPING)
-      chopconf.dedge = true;
-    #endif
-    st.CHOPCONF(chopconf.sr);
-
-    st.rms_current(mA, HOLD_MULTIPLIER);
-    st.microsteps(microsteps);
-    st.iholddelay(10);
-    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
-
-    st.en_pwm_mode(stealth);
-    st.stored.stealthChop_enabled = stealth;
-
-    TMC2160_n::PWMCONF_t pwmconf{0};
-    pwmconf.pwm_lim = 12;
-    pwmconf.pwm_reg = 8;
-    pwmconf.pwm_autograd = true;
-    pwmconf.pwm_autoscale = true;
-    pwmconf.pwm_freq = 0b01;
-    pwmconf.pwm_grad = 14;
-    pwmconf.pwm_ofs = 36;
-    st.PWMCONF(pwmconf.sr);
-
-    #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(thrs);
-    #else
-      UNUSED(thrs);
-    #endif
-    st.GSTAT(); // Clear GSTAT
-  }
-#endif // TMC5160
-
-void restore_stepper_drivers() {
-  #if AXIS_IS_TMC(X)
-    stepperX.push();
-  #endif
-  #if AXIS_IS_TMC(X2)
-    stepperX2.push();
-  #endif
-  #if AXIS_IS_TMC(Y)
-    stepperY.push();
-  #endif
-  #if AXIS_IS_TMC(Y2)
-    stepperY2.push();
-  #endif
-  #if AXIS_IS_TMC(Z)
-    stepperZ.push();
-  #endif
-  #if AXIS_IS_TMC(Z2)
-    stepperZ2.push();
-  #endif
-  #if AXIS_IS_TMC(Z3)
-    stepperZ3.push();
-  #endif
-  #if AXIS_IS_TMC(E0)
-    stepperE0.push();
-  #endif
-  #if AXIS_IS_TMC(E1)
-    stepperE1.push();
-  #endif
-  #if AXIS_IS_TMC(E2)
-    stepperE2.push();
-  #endif
-  #if AXIS_IS_TMC(E3)
-    stepperE3.push();
-  #endif
-  #if AXIS_IS_TMC(E4)
-    stepperE4.push();
-  #endif
-  #if AXIS_IS_TMC(E5)
-    stepperE5.push();
-  #endif
-}
-
-void reset_stepper_drivers() {
-
-  #if HAS_DRIVER(TMC26X)
-    tmc26x_init_to_defaults();
-  #endif
-
-  #if HAS_DRIVER(L6470)
-    L6470.init_to_defaults();
-  #endif
-
-  #if HAS_TRINAMIC
-    static constexpr bool stealthchop_by_axis[] = {
-      #if ENABLED(STEALTHCHOP_XY)
-        true
-      #else
-        false
-      #endif
-      ,
-      #if ENABLED(STEALTHCHOP_Z)
-        true
-      #else
-        false
-      #endif
-      ,
-      #if ENABLED(STEALTHCHOP_E)
-        true
-      #else
-        false
-      #endif
-    };
-  #endif
-
- #if TMC_USE_CHAIN
-
-    enum TMC_axis_enum : unsigned char { _, X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5 };
-    #define __TMC_CHAIN(Q,V) do{ stepper##Q.set_chain_info(Q,V); }while(0)
-    #define _TMC_CHAIN(Q) __TMC_CHAIN(Q, Q##_CHAIN_POS)
-
-    #if AXIS_HAS_SPI(X)                  // First set chain array to uninitialized
-      __TMC_CHAIN(X, 0);
-    #endif
-    #if AXIS_HAS_SPI(X2)
-      __TMC_CHAIN(X2, 0);
-    #endif
-    #if AXIS_HAS_SPI(Y)
-      __TMC_CHAIN(Y, 0);
-    #endif
-    #if AXIS_HAS_SPI(Y2)
-      __TMC_CHAIN(Y2, 0);
-    #endif
-    #if AXIS_HAS_SPI(Z)
-      __TMC_CHAIN(Z, 0);
-    #endif
-    #if AXIS_HAS_SPI(Z2)
-      __TMC_CHAIN(Z2, 0);
-    #endif
-    #if AXIS_HAS_SPI(Z3)
-      __TMC_CHAIN(Z3, 0);
-    #endif
-    #if AXIS_HAS_SPI(E0)
-      __TMC_CHAIN(E0, 0);
-    #endif
-    #if AXIS_HAS_SPI(E1)
-      __TMC_CHAIN(E1, 0);
-    #endif
-    #if AXIS_HAS_SPI(E2)
-      __TMC_CHAIN(E2, 0);
-    #endif
-    #if AXIS_HAS_SPI(E3)
-      __TMC_CHAIN(E3, 0);
-    #endif
-    #if AXIS_HAS_SPI(E4)
-      __TMC_CHAIN(E4, 0);
-    #endif
-    #if AXIS_HAS_SPI(E5)
-      __TMC_CHAIN(E5, 0);
-    #endif
-
-    #if AXIS_HAS_SPI(X) && X_CHAIN_POS             // Now set up the SPI chain
-      _TMC_CHAIN(X);
-    #endif
-    #if AXIS_HAS_SPI(X2) && X2_CHAIN_POS
-      _TMC_CHAIN(X2);
-    #endif
-    #if AXIS_HAS_SPI(Y) && Y_CHAIN_POS
-      _TMC_CHAIN(Y);
-    #endif
-    #if AXIS_HAS_SPI(Y2) && Y2_CHAIN_POS
-      _TMC_CHAIN(Y2);
-    #endif
-    #if AXIS_HAS_SPI(Z) && Z_CHAIN_POS
-      _TMC_CHAIN(Z);
-    #endif
-    #if AXIS_HAS_SPI(Z2) && Z2_CHAIN_POS
-      _TMC_CHAIN(Z2);
-    #endif
-    #if AXIS_HAS_SPI(Z3) && Z3_CHAIN_POS
-      _TMC_CHAIN(Z3);
-    #endif
-    #if AXIS_HAS_SPI(E0) && E0_CHAIN_POS
-      _TMC_CHAIN(E0);
-    #endif
-    #if AXIS_HAS_SPI(E1) && E1_CHAIN_POS
-      _TMC_CHAIN(E1);
-    #endif
-    #if AXIS_HAS_SPI(E2) && E2_CHAIN_POS
-      _TMC_CHAIN(E2);
-    #endif
-    #if AXIS_HAS_SPI(E3) && E3_CHAIN_POS
-      _TMC_CHAIN(E3);
-    #endif
-    #if AXIS_HAS_SPI(E4) && E4_CHAIN_POS
-      _TMC_CHAIN(E4);
-    #endif
-    #if AXIS_HAS_SPI(E5) && E5_CHAIN_POS
-      _TMC_CHAIN(E5);
-    #endif
-  #endif // TMC_USE_CHAIN
-
-  #if AXIS_IS_TMC(X)
-    _TMC_INIT(X, STEALTH_AXIS_XY);
-  #endif
-  #if AXIS_IS_TMC(X2)
-    _TMC_INIT(X2, STEALTH_AXIS_XY);
-  #endif
-  #if AXIS_IS_TMC(Y)
-    _TMC_INIT(Y, STEALTH_AXIS_XY);
-  #endif
-  #if AXIS_IS_TMC(Y2)
-    _TMC_INIT(Y2, STEALTH_AXIS_XY);
-  #endif
-  #if AXIS_IS_TMC(Z)
-    _TMC_INIT(Z, STEALTH_AXIS_Z);
-  #endif
-  #if AXIS_IS_TMC(Z2)
-    _TMC_INIT(Z2, STEALTH_AXIS_Z);
-  #endif
-  #if AXIS_IS_TMC(Z3)
-    _TMC_INIT(Z3, STEALTH_AXIS_Z);
-  #endif
-  #if AXIS_IS_TMC(E0)
-    _TMC_INIT(E0, STEALTH_AXIS_E);
-  #endif
-  #if AXIS_IS_TMC(E1)
-    _TMC_INIT(E1, STEALTH_AXIS_E);
-  #endif
-  #if AXIS_IS_TMC(E2)
-    _TMC_INIT(E2, STEALTH_AXIS_E);
-  #endif
-  #if AXIS_IS_TMC(E3)
-    _TMC_INIT(E3, STEALTH_AXIS_E);
-  #endif
-  #if AXIS_IS_TMC(E4)
-    _TMC_INIT(E4, STEALTH_AXIS_E);
-  #endif
-  #if AXIS_IS_TMC(E5)
-    _TMC_INIT(E5, STEALTH_AXIS_E);
-  #endif
-
-  #if USE_SENSORLESS
-    #if X_SENSORLESS
-      #if AXIS_HAS_STALLGUARD(X)
-        stepperX.homing_threshold(X_STALL_SENSITIVITY);
-      #endif
-      #if AXIS_HAS_STALLGUARD(X2) && !X2_SENSORLESS
-        stepperX2.homing_threshold(X_STALL_SENSITIVITY);
-      #endif
-    #endif
-    #if X2_SENSORLESS
-      stepperX2.homing_threshold(X2_STALL_SENSITIVITY);
-    #endif
-    #if Y_SENSORLESS
-      #if AXIS_HAS_STALLGUARD(Y)
-        stepperY.homing_threshold(Y_STALL_SENSITIVITY);
-      #endif
-      #if AXIS_HAS_STALLGUARD(Y2)
-        stepperY2.homing_threshold(Y_STALL_SENSITIVITY);
-      #endif
-    #endif
-    #if Z_SENSORLESS
-      #if AXIS_HAS_STALLGUARD(Z)
-        stepperZ.homing_threshold(Z_STALL_SENSITIVITY);
-      #endif
-      #if AXIS_HAS_STALLGUARD(Z2)
-        stepperZ2.homing_threshold(Z_STALL_SENSITIVITY);
-      #endif
-      #if AXIS_HAS_STALLGUARD(Z3)
-        stepperZ3.homing_threshold(Z_STALL_SENSITIVITY);
-      #endif
-    #endif
-  #endif
-
-  #ifdef TMC_ADV
-    TMC_ADV()
-  #endif
-
-  #if HAS_TRINAMIC
-    stepper.set_directions();
-  #endif
-}
-
-//
-// L6470 Driver objects and inits
-//
-#if HAS_DRIVER(L6470)
-
-  // create stepper objects
-
-  #define _L6470_DEFINE(ST) L6470 stepper##ST((const int)L6470_CHAIN_SS_PIN)
-
-  // L6470 Stepper objects
-  #if AXIS_DRIVER_TYPE_X(L6470)
-    _L6470_DEFINE(X);
-  #endif
-  #if AXIS_DRIVER_TYPE_X2(L6470)
-    _L6470_DEFINE(X2);
-  #endif
-  #if AXIS_DRIVER_TYPE_Y(L6470)
-    _L6470_DEFINE(Y);
-  #endif
-  #if AXIS_DRIVER_TYPE_Y2(L6470)
-    _L6470_DEFINE(Y2);
-  #endif
-  #if AXIS_DRIVER_TYPE_Z(L6470)
-    _L6470_DEFINE(Z);
-  #endif
-  #if AXIS_DRIVER_TYPE_Z2(L6470)
-    _L6470_DEFINE(Z2);
-  #endif
-  #if AXIS_DRIVER_TYPE_Z3(L6470)
-    _L6470_DEFINE(Z3);
-  #endif
-  #if AXIS_DRIVER_TYPE_E0(L6470)
-    _L6470_DEFINE(E0);
-  #endif
-  #if AXIS_DRIVER_TYPE_E1(L6470)
-    _L6470_DEFINE(E1);
-  #endif
-  #if AXIS_DRIVER_TYPE_E2(L6470)
-    _L6470_DEFINE(E2);
-  #endif
-  #if AXIS_DRIVER_TYPE_E3(L6470)
-    _L6470_DEFINE(E3);
-  #endif
-  #if AXIS_DRIVER_TYPE_E4(L6470)
-    _L6470_DEFINE(E4);
-  #endif
-  #if AXIS_DRIVER_TYPE_E5(L6470)
-    _L6470_DEFINE(E5);
-  #endif
-
-  // not using L6470 library's init command because it
-  // briefly sends power to the steppers
-
-  #define _L6470_INIT_CHIP(Q) do{                             \
-    stepper##Q.resetDev();                                    \
-    stepper##Q.softFree();                                    \
-    stepper##Q.SetParam(L6470_CONFIG, CONFIG_PWM_DIV_1        \
-                                    | CONFIG_PWM_MUL_2        \
-                                    | CONFIG_SR_290V_us       \
-                                    | CONFIG_OC_SD_DISABLE    \
-                                    | CONFIG_VS_COMP_DISABLE  \
-                                    | CONFIG_SW_HARD_STOP     \
-                                    | CONFIG_INT_16MHZ);      \
-    stepper##Q.SetParam(L6470_KVAL_RUN, 0xFF);                \
-    stepper##Q.SetParam(L6470_KVAL_ACC, 0xFF);                \
-    stepper##Q.SetParam(L6470_KVAL_DEC, 0xFF);                \
-    stepper##Q.setMicroSteps(Q##_MICROSTEPS);                 \
-    stepper##Q.setOverCurrent(Q##_OVERCURRENT);               \
-    stepper##Q.setStallCurrent(Q##_STALLCURRENT);             \
-    stepper##Q.SetParam(L6470_KVAL_HOLD, Q##_MAX_VOLTAGE);    \
-    stepper##Q.SetParam(L6470_ABS_POS, 0);                    \
-    stepper##Q.getStatus();                                   \
-  }while(0)
-
-  void L6470_Marlin::init_to_defaults() {
-    #if AXIS_DRIVER_TYPE_X(L6470)
-      _L6470_INIT_CHIP(X);
-    #endif
-    #if AXIS_DRIVER_TYPE_X2(L6470)
-      _L6470_INIT_CHIP(X2);
-    #endif
-    #if AXIS_DRIVER_TYPE_Y(L6470)
-      _L6470_INIT_CHIP(Y);
-    #endif
-    #if AXIS_DRIVER_TYPE_Y2(L6470)
-      _L6470_INIT_CHIP(Y2);
-    #endif
-    #if AXIS_DRIVER_TYPE_Z(L6470)
-      _L6470_INIT_CHIP(Z);
-    #endif
-    #if AXIS_DRIVER_TYPE_Z2(L6470)
-      _L6470_INIT_CHIP(Z2);
-    #endif
-    #if AXIS_DRIVER_TYPE_Z3(L6470)
-      _L6470_INIT_CHIP(Z3);
-    #endif
-    #if AXIS_DRIVER_TYPE_E0(L6470)
-      _L6470_INIT_CHIP(E0);
-    #endif
-    #if AXIS_DRIVER_TYPE_E1(L6470)
-      _L6470_INIT_CHIP(E1);
-    #endif
-    #if AXIS_DRIVER_TYPE_E2(L6470)
-      _L6470_INIT_CHIP(E2);
-    #endif
-    #if AXIS_DRIVER_TYPE_E3(L6470)
-      _L6470_INIT_CHIP(E3);
-    #endif
-    #if AXIS_DRIVER_TYPE_E4(L6470)
-      _L6470_INIT_CHIP(E4);
-    #endif
-    #if AXIS_DRIVER_TYPE_E5(L6470)
-      _L6470_INIT_CHIP(E5);
-    #endif
-  }
-
-#endif // L6470

commit ba91bca1eb0b5fe0d45c273e57b5853386944c27
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Fri Aug 30 17:39:45 2019 -0500

    TMC SPI daisy chain support (experimental) (#15081)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index df9bf45f05..80d7978e33 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -778,6 +778,93 @@ void reset_stepper_drivers() {
     };
   #endif
 
+ #if TMC_USE_CHAIN
+
+    enum TMC_axis_enum : unsigned char { _, X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5 };
+    #define __TMC_CHAIN(Q,V) do{ stepper##Q.set_chain_info(Q,V); }while(0)
+    #define _TMC_CHAIN(Q) __TMC_CHAIN(Q, Q##_CHAIN_POS)
+
+    #if AXIS_HAS_SPI(X)                  // First set chain array to uninitialized
+      __TMC_CHAIN(X, 0);
+    #endif
+    #if AXIS_HAS_SPI(X2)
+      __TMC_CHAIN(X2, 0);
+    #endif
+    #if AXIS_HAS_SPI(Y)
+      __TMC_CHAIN(Y, 0);
+    #endif
+    #if AXIS_HAS_SPI(Y2)
+      __TMC_CHAIN(Y2, 0);
+    #endif
+    #if AXIS_HAS_SPI(Z)
+      __TMC_CHAIN(Z, 0);
+    #endif
+    #if AXIS_HAS_SPI(Z2)
+      __TMC_CHAIN(Z2, 0);
+    #endif
+    #if AXIS_HAS_SPI(Z3)
+      __TMC_CHAIN(Z3, 0);
+    #endif
+    #if AXIS_HAS_SPI(E0)
+      __TMC_CHAIN(E0, 0);
+    #endif
+    #if AXIS_HAS_SPI(E1)
+      __TMC_CHAIN(E1, 0);
+    #endif
+    #if AXIS_HAS_SPI(E2)
+      __TMC_CHAIN(E2, 0);
+    #endif
+    #if AXIS_HAS_SPI(E3)
+      __TMC_CHAIN(E3, 0);
+    #endif
+    #if AXIS_HAS_SPI(E4)
+      __TMC_CHAIN(E4, 0);
+    #endif
+    #if AXIS_HAS_SPI(E5)
+      __TMC_CHAIN(E5, 0);
+    #endif
+
+    #if AXIS_HAS_SPI(X) && X_CHAIN_POS             // Now set up the SPI chain
+      _TMC_CHAIN(X);
+    #endif
+    #if AXIS_HAS_SPI(X2) && X2_CHAIN_POS
+      _TMC_CHAIN(X2);
+    #endif
+    #if AXIS_HAS_SPI(Y) && Y_CHAIN_POS
+      _TMC_CHAIN(Y);
+    #endif
+    #if AXIS_HAS_SPI(Y2) && Y2_CHAIN_POS
+      _TMC_CHAIN(Y2);
+    #endif
+    #if AXIS_HAS_SPI(Z) && Z_CHAIN_POS
+      _TMC_CHAIN(Z);
+    #endif
+    #if AXIS_HAS_SPI(Z2) && Z2_CHAIN_POS
+      _TMC_CHAIN(Z2);
+    #endif
+    #if AXIS_HAS_SPI(Z3) && Z3_CHAIN_POS
+      _TMC_CHAIN(Z3);
+    #endif
+    #if AXIS_HAS_SPI(E0) && E0_CHAIN_POS
+      _TMC_CHAIN(E0);
+    #endif
+    #if AXIS_HAS_SPI(E1) && E1_CHAIN_POS
+      _TMC_CHAIN(E1);
+    #endif
+    #if AXIS_HAS_SPI(E2) && E2_CHAIN_POS
+      _TMC_CHAIN(E2);
+    #endif
+    #if AXIS_HAS_SPI(E3) && E3_CHAIN_POS
+      _TMC_CHAIN(E3);
+    #endif
+    #if AXIS_HAS_SPI(E4) && E4_CHAIN_POS
+      _TMC_CHAIN(E4);
+    #endif
+    #if AXIS_HAS_SPI(E5) && E5_CHAIN_POS
+      _TMC_CHAIN(E5);
+    #endif
+  #endif // TMC_USE_CHAIN
+
   #if AXIS_IS_TMC(X)
     _TMC_INIT(X, STEALTH_AXIS_XY);
   #endif

commit 0ebaea94be98b7ae27f9e2daf34e59f65436bd26
Author: AlexandrZloy <49792082+AlexandrZloy@users.noreply.github.com>
Date:   Thu Aug 29 12:15:31 2019 +0700

    Add stallGuard threshold for X2 (#15042)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 786cb1db8f..df9bf45f05 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -823,10 +823,13 @@ void reset_stepper_drivers() {
       #if AXIS_HAS_STALLGUARD(X)
         stepperX.homing_threshold(X_STALL_SENSITIVITY);
       #endif
-      #if AXIS_HAS_STALLGUARD(X2)
+      #if AXIS_HAS_STALLGUARD(X2) && !X2_SENSORLESS
         stepperX2.homing_threshold(X_STALL_SENSITIVITY);
       #endif
     #endif
+    #if X2_SENSORLESS
+      stepperX2.homing_threshold(X2_STALL_SENSITIVITY);
+    #endif
     #if Y_SENSORLESS
       #if AXIS_HAS_STALLGUARD(Y)
         stepperY.homing_threshold(Y_STALL_SENSITIVITY);

commit ad1c061e7b4522f30e8bc4deac565baa0c4b6568
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 9 23:54:34 2019 -0500

    Bring STM32F4/F7 together

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index a97402b948..786cb1db8f 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -45,8 +45,8 @@
 #if HAS_DRIVER(TMC26X)
   #include <SPI.h>
 
-  #ifdef STM32F7
-    #include "../HAL/HAL_STM32F7/TMC2660.h"
+  #if defined(STM32GENERIC) && defined(STM32F7)
+    #include "../HAL/HAL_STM32_F4_F7/STM32F7/TMC2660.h"
   #else
     #include <TMC26XStepper.h>
   #endif

commit 1a349c75229604c113c83d29c2ff06f61153b44a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jul 8 22:59:51 2019 -0500

    Add HAS_TMC220x

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 362ed01ba9..a97402b948 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -309,7 +309,7 @@
 //
 // TMC2208/2209 Driver objects and inits
 //
-#if HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
+#if HAS_TMC220x
   #if AXIS_HAS_UART(X)
     #ifdef X_HARDWARE_SERIAL
       TMC_UART_DEFINE(HW, X, X);

commit dab2f0c89c848de5b745b7a70576b5fd2e9bccbd
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Mon Jul 1 05:29:33 2019 +0200

    Mask unused var, update (c) comments (#14455)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 3668acbf8d..362ed01ba9 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -26,8 +26,6 @@
  * Stepper motor driver indirection to allow some stepper functions to
  * be done via SPI/I2c instead of direct pin manipulation.
  *
- * Part of Marlin
- *
  * Copyright (c) 2015 Dominik Wenger
  */
 

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 9c72d8f7a1..3668acbf8d 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit 8934b32f1b9bd388eae25f0372ed62b57200bab8
Author: Eric Ptak <trouch@trouch.com>
Date:   Wed Jun 26 07:40:29 2019 +0200

    Fysetc AIO II / Cheetah STM32F1 (#14407)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 3dacfc7cfb..9c72d8f7a1 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -591,6 +591,7 @@
     #endif
 
     st.GSTAT(0b111); // Clear
+    delay(200);
   }
 #endif // TMC2209
 

commit 2247bf1ba5f1a62a7433aa1b2764a91af1a80e2a
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sun Jun 23 01:00:15 2019 +0300

    Add missing dedge init for TMC2209 (#14370)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index b5575cfbba..3dacfc7cfb 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -269,14 +269,12 @@
   void tmc_init(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
     st.begin();
 
-    static constexpr int8_t timings[] = CHOPPER_TIMING; // Default 4, -2, 1
-
     CHOPCONF_t chopconf{0};
     chopconf.tbl = 1;
-    chopconf.toff = timings[0];
+    chopconf.toff = chopper_timing.toff;
     chopconf.intpol = INTERPOLATE;
-    chopconf.hend = timings[1] + 3;
-    chopconf.hstrt = timings[2] - 1;
+    chopconf.hend = chopper_timing.hend + 3;
+    chopconf.hstrt = chopper_timing.hstrt - 1;
     #if ENABLED(SQUARE_WAVE_STEPPING)
       chopconf.dedge = true;
     #endif
@@ -286,16 +284,9 @@
     st.microsteps(microsteps);
     st.iholddelay(10);
     st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
-    st.TCOOLTHRS(0xFFFFF);
-
-    #if ENABLED(ADAPTIVE_CURRENT)
-      COOLCONF_t coolconf{0};
-      coolconf.semin = INCREASE_CURRENT_THRS;
-      coolconf.semax = REDUCE_CURRENT_THRS;
-      st.COOLCONF(coolconf.sr);
-    #endif
 
     st.en_pwm_mode(stealth);
+    st.stored.stealthChop_enabled = stealth;
 
     TMC2160_n::PWMCONF_t pwmconf{0};
     pwmconf.pwm_lim = 12;
@@ -573,6 +564,9 @@
     chopconf.intpol = INTERPOLATE;
     chopconf.hend = chopper_timing.hend + 3;
     chopconf.hstrt = chopper_timing.hstrt - 1;
+    #if ENABLED(SQUARE_WAVE_STEPPING)
+      chopconf.dedge = true;
+    #endif
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);
@@ -673,14 +667,12 @@
   void tmc_init(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
     st.begin();
 
-    int8_t timings[] = CHOPPER_TIMING; // Default 4, -2, 1
-
     CHOPCONF_t chopconf{0};
     chopconf.tbl = 1;
-    chopconf.toff = timings[0];
+    chopconf.toff = chopper_timing.toff;
     chopconf.intpol = INTERPOLATE;
-    chopconf.hend = timings[1] + 3;
-    chopconf.hstrt = timings[2] - 1;
+    chopconf.hend = chopper_timing.hend + 3;
+    chopconf.hstrt = chopper_timing.hstrt - 1;
     #if ENABLED(SQUARE_WAVE_STEPPING)
       chopconf.dedge = true;
     #endif
@@ -691,14 +683,8 @@
     st.iholddelay(10);
     st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
 
-    #if ENABLED(ADAPTIVE_CURRENT)
-      COOLCONF_t coolconf{0};
-      coolconf.semin = INCREASE_CURRENT_THRS;
-      coolconf.semax = REDUCE_CURRENT_THRS;
-      st.COOLCONF(coolconf.sr);
-    #endif
-
     st.en_pwm_mode(stealth);
+    st.stored.stealthChop_enabled = stealth;
 
     TMC2160_n::PWMCONF_t pwmconf{0};
     pwmconf.pwm_lim = 12;

commit 4df4c47994f248428ae30218800803e467327b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 20 15:47:50 2019 -0500

    Add TMC2209 support (#14249)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index dd40457949..b5575cfbba 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -163,8 +163,8 @@
     #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, ST##_RSENSE)
   #endif
 
-  #define TMC_UART_HW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(&ST##_HARDWARE_SERIAL, ST##_RSENSE)
-  #define TMC_UART_SW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN, ST##_RSENSE, ST##_SERIAL_RX_PIN > -1)
+  #define TMC_UART_HW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(&ST##_HARDWARE_SERIAL, ST##_RSENSE, ST##_SLAVE_ADDRESS)
+  #define TMC_UART_SW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN, ST##_RSENSE, ST##_SLAVE_ADDRESS, ST##_SERIAL_RX_PIN > -1)
 
   #define _TMC_SPI_DEFINE(IC, ST, AI) __TMC_SPI_DEFINE(IC, ST, TMC_##ST##_LABEL, AI)
   #define TMC_SPI_DEFINE(ST, AI) _TMC_SPI_DEFINE(ST##_DRIVER_TYPE, ST, AI##_AXIS)
@@ -318,95 +318,94 @@
 #endif // TMC2160
 
 //
-// TMC2208 Driver objects and inits
+// TMC2208/2209 Driver objects and inits
 //
-#if HAS_DRIVER(TMC2208)
-  // Stepper objects of TMC2208 steppers used
-  #if AXIS_DRIVER_TYPE_X(TMC2208)
+#if HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
+  #if AXIS_HAS_UART(X)
     #ifdef X_HARDWARE_SERIAL
       TMC_UART_DEFINE(HW, X, X);
     #else
       TMC_UART_DEFINE(SW, X, X);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE_X2(TMC2208)
+  #if AXIS_HAS_UART(X2)
     #ifdef X2_HARDWARE_SERIAL
       TMC_UART_DEFINE(HW, X2, X);
     #else
       TMC_UART_DEFINE(SW, X2, X);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE_Y(TMC2208)
+  #if AXIS_HAS_UART(Y)
     #ifdef Y_HARDWARE_SERIAL
       TMC_UART_DEFINE(HW, Y, Y);
     #else
       TMC_UART_DEFINE(SW, Y, Y);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE_Y2(TMC2208)
+  #if AXIS_HAS_UART(Y2)
     #ifdef Y2_HARDWARE_SERIAL
       TMC_UART_DEFINE(HW, Y2, Y);
     #else
       TMC_UART_DEFINE(SW, Y2, Y);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE_Z(TMC2208)
+  #if AXIS_HAS_UART(Z)
     #ifdef Z_HARDWARE_SERIAL
       TMC_UART_DEFINE(HW, Z, Z);
     #else
       TMC_UART_DEFINE(SW, Z, Z);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE_Z2(TMC2208)
+  #if AXIS_HAS_UART(Z2)
     #ifdef Z2_HARDWARE_SERIAL
       TMC_UART_DEFINE(HW, Z2, Z);
     #else
       TMC_UART_DEFINE(SW, Z2, Z);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE_Z3(TMC2208)
+  #if AXIS_HAS_UART(Z3)
     #ifdef Z3_HARDWARE_SERIAL
       TMC_UART_DEFINE(HW, Z3, Z);
     #else
       TMC_UART_DEFINE(SW, Z3, Z);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE_E0(TMC2208)
+  #if AXIS_HAS_UART(E0)
     #ifdef E0_HARDWARE_SERIAL
       TMC_UART_DEFINE_E(HW, 0);
     #else
       TMC_UART_DEFINE_E(SW, 0);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE_E1(TMC2208)
+  #if AXIS_HAS_UART(E1)
     #ifdef E1_HARDWARE_SERIAL
       TMC_UART_DEFINE_E(HW, 1);
     #else
       TMC_UART_DEFINE_E(SW, 1);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE_E2(TMC2208)
+  #if AXIS_HAS_UART(E2)
     #ifdef E2_HARDWARE_SERIAL
       TMC_UART_DEFINE_E(HW, 2);
     #else
       TMC_UART_DEFINE_E(SW, 2);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE_E3(TMC2208)
+  #if AXIS_HAS_UART(E3)
     #ifdef E3_HARDWARE_SERIAL
       TMC_UART_DEFINE_E(HW, 3);
     #else
       TMC_UART_DEFINE_E(SW, 3);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE_E4(TMC2208)
+  #if AXIS_HAS_UART(E4)
     #ifdef E4_HARDWARE_SERIAL
       TMC_UART_DEFINE_E(HW, 4);
     #else
       TMC_UART_DEFINE_E(SW, 4);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE_E5(TMC2208)
+  #if AXIS_HAS_UART(E5)
     #ifdef E5_HARDWARE_SERIAL
       TMC_UART_DEFINE_E(HW, 5);
     #else
@@ -414,92 +413,92 @@
     #endif
   #endif
 
-  void tmc2208_serial_begin() {
-    #if AXIS_DRIVER_TYPE_X(TMC2208)
+  void tmc_serial_begin() {
+    #if AXIS_HAS_UART(X)
       #ifdef X_HARDWARE_SERIAL
         X_HARDWARE_SERIAL.begin(115200);
       #else
         stepperX.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE_X2(TMC2208)
+    #if AXIS_HAS_UART(X2)
       #ifdef X2_HARDWARE_SERIAL
         X2_HARDWARE_SERIAL.begin(115200);
       #else
         stepperX2.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE_Y(TMC2208)
+    #if AXIS_HAS_UART(Y)
       #ifdef Y_HARDWARE_SERIAL
         Y_HARDWARE_SERIAL.begin(115200);
       #else
         stepperY.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE_Y2(TMC2208)
+    #if AXIS_HAS_UART(Y2)
       #ifdef Y2_HARDWARE_SERIAL
         Y2_HARDWARE_SERIAL.begin(115200);
       #else
         stepperY2.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE_Z(TMC2208)
+    #if AXIS_HAS_UART(Z)
       #ifdef Z_HARDWARE_SERIAL
         Z_HARDWARE_SERIAL.begin(115200);
       #else
         stepperZ.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE_Z2(TMC2208)
+    #if AXIS_HAS_UART(Z2)
       #ifdef Z2_HARDWARE_SERIAL
         Z2_HARDWARE_SERIAL.begin(115200);
       #else
         stepperZ2.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE_Z3(TMC2208)
+    #if AXIS_HAS_UART(Z3)
       #ifdef Z3_HARDWARE_SERIAL
         Z3_HARDWARE_SERIAL.begin(115200);
       #else
         stepperZ3.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE_E0(TMC2208)
+    #if AXIS_HAS_UART(E0)
       #ifdef E0_HARDWARE_SERIAL
         E0_HARDWARE_SERIAL.begin(115200);
       #else
         stepperE0.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE_E1(TMC2208)
+    #if AXIS_HAS_UART(E1)
       #ifdef E1_HARDWARE_SERIAL
         E1_HARDWARE_SERIAL.begin(115200);
       #else
         stepperE1.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE_E2(TMC2208)
+    #if AXIS_HAS_UART(E2)
       #ifdef E2_HARDWARE_SERIAL
         E2_HARDWARE_SERIAL.begin(115200);
       #else
         stepperE2.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE_E3(TMC2208)
+    #if AXIS_HAS_UART(E3)
       #ifdef E3_HARDWARE_SERIAL
         E3_HARDWARE_SERIAL.begin(115200);
       #else
         stepperE3.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE_E4(TMC2208)
+    #if AXIS_HAS_UART(E4)
       #ifdef E4_HARDWARE_SERIAL
         E4_HARDWARE_SERIAL.begin(115200);
       #else
         stepperE4.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE_E5(TMC2208)
+    #if AXIS_HAS_UART(E5)
       #ifdef E5_HARDWARE_SERIAL
         E5_HARDWARE_SERIAL.begin(115200);
       #else
@@ -507,7 +506,9 @@
       #endif
     #endif
   }
+#endif
 
+#if HAS_DRIVER(TMC2208)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
   void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
     TMC2208_n::GCONF_t gconf{0};
@@ -555,6 +556,50 @@
   }
 #endif // TMC2208
 
+#if HAS_DRIVER(TMC2209)
+  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+  void tmc_init(TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
+    TMC2208_n::GCONF_t gconf{0};
+    gconf.pdn_disable = true; // Use UART
+    gconf.mstep_reg_select = true; // Select microsteps with UART
+    gconf.i_scale_analog = false;
+    gconf.en_spreadcycle = !stealth;
+    st.GCONF(gconf.sr);
+    st.stored.stealthChop_enabled = stealth;
+
+    TMC2208_n::CHOPCONF_t chopconf{0};
+    chopconf.tbl = 0b01; // blank_time = 24
+    chopconf.toff = chopper_timing.toff;
+    chopconf.intpol = INTERPOLATE;
+    chopconf.hend = chopper_timing.hend + 3;
+    chopconf.hstrt = chopper_timing.hstrt - 1;
+    st.CHOPCONF(chopconf.sr);
+
+    st.rms_current(mA, HOLD_MULTIPLIER);
+    st.microsteps(microsteps);
+    st.iholddelay(10);
+    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
+
+    TMC2208_n::PWMCONF_t pwmconf{0};
+    pwmconf.pwm_lim = 12;
+    pwmconf.pwm_reg = 8;
+    pwmconf.pwm_autograd = true;
+    pwmconf.pwm_autoscale = true;
+    pwmconf.pwm_freq = 0b01;
+    pwmconf.pwm_grad = 14;
+    pwmconf.pwm_ofs = 36;
+    st.PWMCONF(pwmconf.sr);
+
+    #if ENABLED(HYBRID_THRESHOLD)
+      st.set_pwm_thrs(thrs);
+    #else
+      UNUSED(thrs);
+    #endif
+
+    st.GSTAT(0b111); // Clear
+  }
+#endif // TMC2209
+
 #if HAS_DRIVER(TMC2660)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
   void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const bool) {
@@ -791,29 +836,29 @@ void reset_stepper_drivers() {
   #if USE_SENSORLESS
     #if X_SENSORLESS
       #if AXIS_HAS_STALLGUARD(X)
-        stepperX.sgt(X_STALL_SENSITIVITY);
+        stepperX.homing_threshold(X_STALL_SENSITIVITY);
       #endif
       #if AXIS_HAS_STALLGUARD(X2)
-        stepperX2.sgt(X_STALL_SENSITIVITY);
+        stepperX2.homing_threshold(X_STALL_SENSITIVITY);
       #endif
     #endif
     #if Y_SENSORLESS
       #if AXIS_HAS_STALLGUARD(Y)
-        stepperY.sgt(Y_STALL_SENSITIVITY);
+        stepperY.homing_threshold(Y_STALL_SENSITIVITY);
       #endif
       #if AXIS_HAS_STALLGUARD(Y2)
-        stepperY2.sgt(Y_STALL_SENSITIVITY);
+        stepperY2.homing_threshold(Y_STALL_SENSITIVITY);
       #endif
     #endif
     #if Z_SENSORLESS
       #if AXIS_HAS_STALLGUARD(Z)
-        stepperZ.sgt(Z_STALL_SENSITIVITY);
+        stepperZ.homing_threshold(Z_STALL_SENSITIVITY);
       #endif
       #if AXIS_HAS_STALLGUARD(Z2)
-        stepperZ2.sgt(Z_STALL_SENSITIVITY);
+        stepperZ2.homing_threshold(Z_STALL_SENSITIVITY);
       #endif
       #if AXIS_HAS_STALLGUARD(Z3)
-        stepperZ3.sgt(Z_STALL_SENSITIVITY);
+        stepperZ3.homing_threshold(Z_STALL_SENSITIVITY);
       #endif
     #endif
   #endif

commit 29afd11cbff20240eb69b4f7cb9374b290f1bbaa
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Jun 14 07:16:10 2019 +0300

    Updates for TMC2660 init (#14245)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index b50383a1cf..dd40457949 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -565,13 +565,14 @@
     chopconf.toff = chopper_timing.toff;
     chopconf.hend = chopper_timing.hend + 3;
     chopconf.hstrt = chopper_timing.hstrt - 1;
-    #if ENABLED(SQUARE_WAVE_STEPPING)
-      chopconf.dedge = true;
-    #endif
     st.CHOPCONF(chopconf.sr);
 
+    st.sdoff(0);
     st.rms_current(mA);
     st.microsteps(microsteps);
+    #if ENABLED(SQUARE_WAVE_STEPPING)
+      st.dedge(true);
+    #endif
     st.intpol(INTERPOLATE);
     st.diss2g(true); // Disable short to ground protection. Too many false readings?
 

commit 12a270fd2964c088acb93b4ecfe1b35c3df97654
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sat Jun 8 22:34:50 2019 +0300

    Fix TMC5160 and TMC2160 PWMCONF init

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 02b6af60f2..b50383a1cf 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -297,11 +297,14 @@
 
     st.en_pwm_mode(stealth);
 
-    PWMCONF_t pwmconf{0};
-    pwmconf.pwm_freq = 0b01; // f_pwm = 2/683 f_clk
+    TMC2160_n::PWMCONF_t pwmconf{0};
+    pwmconf.pwm_lim = 12;
+    pwmconf.pwm_reg = 8;
+    pwmconf.pwm_autograd = true;
     pwmconf.pwm_autoscale = true;
-    pwmconf.pwm_grad = 5;
-    pwmconf.pwm_ampl = 180;
+    pwmconf.pwm_freq = 0b01;
+    pwmconf.pwm_grad = 14;
+    pwmconf.pwm_ofs = 36;
     st.PWMCONF(pwmconf.sr);
 
     #if ENABLED(HYBRID_THRESHOLD)
@@ -651,11 +654,14 @@
 
     st.en_pwm_mode(stealth);
 
-    PWMCONF_t pwmconf{0};
-    pwmconf.pwm_freq = 0b01; // f_pwm = 2/683 f_clk
+    TMC2160_n::PWMCONF_t pwmconf{0};
+    pwmconf.pwm_lim = 12;
+    pwmconf.pwm_reg = 8;
+    pwmconf.pwm_autograd = true;
     pwmconf.pwm_autoscale = true;
-    pwmconf.pwm_grad = 5;
-    pwmconf.pwm_ampl = 180;
+    pwmconf.pwm_freq = 0b01;
+    pwmconf.pwm_grad = 14;
+    pwmconf.pwm_ofs = 36;
     st.PWMCONF(pwmconf.sr);
 
     #if ENABLED(HYBRID_THRESHOLD)

commit cccc51ee0e583ed4719b84870de53756c3a44e95
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sun Jun 9 13:08:05 2019 +0300

    TMC Square Wave Stepping mode (#14195)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index cb1b4113e1..02b6af60f2 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -234,6 +234,9 @@
     chopconf.intpol = INTERPOLATE;
     chopconf.hend = chopper_timing.hend + 3;
     chopconf.hstrt = chopper_timing.hstrt - 1;
+    #if ENABLED(SQUARE_WAVE_STEPPING)
+      chopconf.dedge = true;
+    #endif
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);
@@ -274,6 +277,9 @@
     chopconf.intpol = INTERPOLATE;
     chopconf.hend = timings[1] + 3;
     chopconf.hstrt = timings[2] - 1;
+    #if ENABLED(SQUARE_WAVE_STEPPING)
+      chopconf.dedge = true;
+    #endif
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);
@@ -515,6 +521,9 @@
     chopconf.intpol = INTERPOLATE;
     chopconf.hend = chopper_timing.hend + 3;
     chopconf.hstrt = chopper_timing.hstrt - 1;
+    #if ENABLED(SQUARE_WAVE_STEPPING)
+      chopconf.dedge = true;
+    #endif
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);
@@ -553,6 +562,9 @@
     chopconf.toff = chopper_timing.toff;
     chopconf.hend = chopper_timing.hend + 3;
     chopconf.hstrt = chopper_timing.hstrt - 1;
+    #if ENABLED(SQUARE_WAVE_STEPPING)
+      chopconf.dedge = true;
+    #endif
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA);
@@ -577,6 +589,9 @@
     chopconf.intpol = INTERPOLATE;
     chopconf.hend = chopper_timing.hend + 3;
     chopconf.hstrt = chopper_timing.hstrt - 1;
+    #if ENABLED(SQUARE_WAVE_STEPPING)
+      chopconf.dedge = true;
+    #endif
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);
@@ -617,6 +632,9 @@
     chopconf.intpol = INTERPOLATE;
     chopconf.hend = timings[1] + 3;
     chopconf.hstrt = timings[2] - 1;
+    #if ENABLED(SQUARE_WAVE_STEPPING)
+      chopconf.dedge = true;
+    #endif
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);

commit 1c86fbc60bad74957c872cbd6bc87900a3f127d8
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sun May 26 02:22:12 2019 +0300

    TMC updates, capture LCD changes (#14074)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 2e25b11afd..cb1b4113e1 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -144,69 +144,88 @@
 #endif // TMC26X
 
 #if HAS_TRINAMIC
-  enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
-  #define _TMC_INIT(ST, SPMM_INDEX, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, planner.settings.axis_steps_per_mm[SPMM_INDEX], stealthchop_by_axis[STEALTH_INDEX])
-#endif
-
-//
-// TMC2130 Driver objects and inits
-//
-#if HAS_DRIVER(TMC2130)
-
+  #include <HardwareSerial.h>
   #include <SPI.h>
   #include "planner.h"
   #include "../core/enum.h"
 
+  enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
+  #define _TMC_INIT(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, stealthchop_by_axis[STEALTH_INDEX])
+
+  //   IC = TMC model number
+  //   ST = Stepper object letter
+  //   L  = Label characters
+  //   AI = Axis Enum Index
+  // SWHW = SW/SH UART selection
   #if ENABLED(TMC_USE_SW_SPI)
-    #define _TMC2130_DEFINE(ST, L) TMCMarlin<TMC2130Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
-    #define TMC2130_DEFINE(ST) _TMC2130_DEFINE(ST, TMC_##ST##_LABEL)
+    #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, ST##_RSENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
   #else
-    #define _TMC2130_DEFINE(ST, L) TMCMarlin<TMC2130Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE)
-    #define TMC2130_DEFINE(ST) _TMC2130_DEFINE(ST, TMC_##ST##_LABEL)
+    #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, ST##_RSENSE)
   #endif
-  // Stepper objects of TMC2130 steppers used
-  #if AXIS_DRIVER_TYPE_X(TMC2130)
-    TMC2130_DEFINE(X);
+
+  #define TMC_UART_HW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(&ST##_HARDWARE_SERIAL, ST##_RSENSE)
+  #define TMC_UART_SW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN, ST##_RSENSE, ST##_SERIAL_RX_PIN > -1)
+
+  #define _TMC_SPI_DEFINE(IC, ST, AI) __TMC_SPI_DEFINE(IC, ST, TMC_##ST##_LABEL, AI)
+  #define TMC_SPI_DEFINE(ST, AI) _TMC_SPI_DEFINE(ST##_DRIVER_TYPE, ST, AI##_AXIS)
+
+  #define _TMC_UART_DEFINE(SWHW, IC, ST, AI) TMC_UART_##SWHW##_DEFINE(IC, ST, TMC_##ST##_LABEL, AI)
+  #define TMC_UART_DEFINE(SWHW, ST, AI) _TMC_UART_DEFINE(SWHW, ST##_DRIVER_TYPE, ST, AI##_AXIS)
+
+  #if ENABLED(DISTINCT_E_FACTORS) && E_STEPPERS > 1
+    #define TMC_SPI_DEFINE_E(AI) TMC_SPI_DEFINE(E##AI, E##AI)
+    #define TMC_UART_DEFINE_E(SWHW, AI) TMC_UART_DEFINE(SWHW, E##AI, E##AI)
+  #else
+    #define TMC_SPI_DEFINE_E(AI) TMC_SPI_DEFINE(E##AI, E)
+    #define TMC_UART_DEFINE_E(SWHW, AI) TMC_UART_DEFINE(SWHW, E##AI, E)
   #endif
-  #if AXIS_DRIVER_TYPE_X2(TMC2130)
-    TMC2130_DEFINE(X2);
+
+  // Stepper objects of TMC2130/TMC2160/TMC2660/TMC5130/TMC5160 steppers used
+  #if AXIS_HAS_SPI(X)
+    TMC_SPI_DEFINE(X, X);
   #endif
-  #if AXIS_DRIVER_TYPE_Y(TMC2130)
-    TMC2130_DEFINE(Y);
+  #if AXIS_HAS_SPI(X2)
+    TMC_SPI_DEFINE(X2, X);
   #endif
-  #if AXIS_DRIVER_TYPE_Y2(TMC2130)
-    TMC2130_DEFINE(Y2);
+  #if AXIS_HAS_SPI(Y)
+    TMC_SPI_DEFINE(Y, Y);
   #endif
-  #if AXIS_DRIVER_TYPE_Z(TMC2130)
-    TMC2130_DEFINE(Z);
+  #if AXIS_HAS_SPI(Y2)
+    TMC_SPI_DEFINE(Y2, Y);
   #endif
-  #if AXIS_DRIVER_TYPE_Z2(TMC2130)
-    TMC2130_DEFINE(Z2);
+  #if AXIS_HAS_SPI(Z)
+    TMC_SPI_DEFINE(Z, Z);
   #endif
-  #if AXIS_DRIVER_TYPE_Z3(TMC2130)
-    TMC2130_DEFINE(Z3);
+  #if AXIS_HAS_SPI(Z2)
+    TMC_SPI_DEFINE(Z2, Z);
   #endif
-  #if AXIS_DRIVER_TYPE_E0(TMC2130)
-    TMC2130_DEFINE(E0);
+  #if AXIS_HAS_SPI(Z3)
+    TMC_SPI_DEFINE(Z3, Z);
   #endif
-  #if AXIS_DRIVER_TYPE_E1(TMC2130)
-    TMC2130_DEFINE(E1);
+  #if AXIS_HAS_SPI(E0)
+    TMC_SPI_DEFINE_E(0);
   #endif
-  #if AXIS_DRIVER_TYPE_E2(TMC2130)
-    TMC2130_DEFINE(E2);
+  #if AXIS_HAS_SPI(E1)
+    TMC_SPI_DEFINE_E(1);
   #endif
-  #if AXIS_DRIVER_TYPE_E3(TMC2130)
-    TMC2130_DEFINE(E3);
+  #if AXIS_HAS_SPI(E2)
+    TMC_SPI_DEFINE_E(2);
   #endif
-  #if AXIS_DRIVER_TYPE_E4(TMC2130)
-    TMC2130_DEFINE(E4);
+  #if AXIS_HAS_SPI(E3)
+    TMC_SPI_DEFINE_E(3);
   #endif
-  #if AXIS_DRIVER_TYPE_E5(TMC2130)
-    TMC2130_DEFINE(E5);
+  #if AXIS_HAS_SPI(E4)
+    TMC_SPI_DEFINE_E(4);
   #endif
+  #if AXIS_HAS_SPI(E5)
+    TMC_SPI_DEFINE_E(5);
+  #endif
+
+#endif
 
-  template<char AXIS_LETTER, char DRIVER_ID>
-  void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm, const bool stealth) {
+#if HAS_DRIVER(TMC2130)
+  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+  void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
@@ -233,75 +252,18 @@
     st.PWMCONF(pwmconf.sr);
 
     #if ENABLED(HYBRID_THRESHOLD)
-      st.TPWMTHRS(12650000UL*microsteps/(256*thrs*spmm));
+      st.set_pwm_thrs(thrs);
     #else
       UNUSED(thrs);
-      UNUSED(spmm);
     #endif
 
     st.GSTAT(); // Clear GSTAT
   }
 #endif // TMC2130
 
-//
-// TMC2160 Driver objects and inits
-//
 #if HAS_DRIVER(TMC2160)
-
-  #include <SPI.h>
-  #include "planner.h"
-  #include "../core/enum.h"
-
-  #if ENABLED(TMC_USE_SW_SPI)
-    #define _TMC2160_DEFINE(ST, L) TMCMarlin<TMC2160Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
-    #define TMC2160_DEFINE(ST) _TMC2160_DEFINE(ST, TMC_##ST##_LABEL)
-  #else
-    #define _TMC2160_DEFINE(ST, L) TMCMarlin<TMC2160Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE)
-    #define TMC2160_DEFINE(ST) _TMC2160_DEFINE(ST, TMC_##ST##_LABEL)
-  #endif
-  // Stepper objects of TMC2160 steppers used
-  #if AXIS_DRIVER_TYPE(X, TMC2160)
-    TMC2160_DEFINE(X);
-  #endif
-  #if AXIS_DRIVER_TYPE(X2, TMC2160)
-    TMC2160_DEFINE(X2);
-  #endif
-  #if AXIS_DRIVER_TYPE(Y, TMC2160)
-    TMC2160_DEFINE(Y);
-  #endif
-  #if AXIS_DRIVER_TYPE(Y2, TMC2160)
-    TMC2160_DEFINE(Y2);
-  #endif
-  #if AXIS_DRIVER_TYPE(Z, TMC2160)
-    TMC2160_DEFINE(Z);
-  #endif
-  #if AXIS_DRIVER_TYPE(Z2, TMC2160)
-    TMC2160_DEFINE(Z2);
-  #endif
-  #if AXIS_DRIVER_TYPE(Z3, TMC2160)
-    TMC2160_DEFINE(Z3);
-  #endif
-  #if AXIS_DRIVER_TYPE(E0, TMC2160)
-    TMC2160_DEFINE(E0);
-  #endif
-  #if AXIS_DRIVER_TYPE(E1, TMC2160)
-    TMC2160_DEFINE(E1);
-  #endif
-  #if AXIS_DRIVER_TYPE(E2, TMC2160)
-    TMC2160_DEFINE(E2);
-  #endif
-  #if AXIS_DRIVER_TYPE(E3, TMC2160)
-    TMC2160_DEFINE(E3);
-  #endif
-  #if AXIS_DRIVER_TYPE(E4, TMC2160)
-    TMC2160_DEFINE(E4);
-  #endif
-  #if AXIS_DRIVER_TYPE(E5, TMC2160)
-    TMC2160_DEFINE(E5);
-  #endif
-
-  template<char AXIS_LETTER, char DRIVER_ID>
-  void tmc_init(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm, const bool stealth) {
+  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+  void tmc_init(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
     st.begin();
 
     static constexpr int8_t timings[] = CHOPPER_TIMING; // Default 4, -2, 1
@@ -337,10 +299,9 @@
     st.PWMCONF(pwmconf.sr);
 
     #if ENABLED(HYBRID_THRESHOLD)
-      st.TPWMTHRS(12650000UL*microsteps/(256*thrs*spmm));
+      st.set_pwm_thrs(thrs);
     #else
       UNUSED(thrs);
-      UNUSED(spmm);
     #endif
 
     st.GSTAT(); // Clear GSTAT
@@ -351,105 +312,96 @@
 // TMC2208 Driver objects and inits
 //
 #if HAS_DRIVER(TMC2208)
-  #include <HardwareSerial.h>
-  #include "planner.h"
-
-  #define _TMC2208_DEFINE_HARDWARE(ST, L) TMCMarlin<TMC2208Stepper, L> stepper##ST(&ST##_HARDWARE_SERIAL, ST##_RSENSE)
-  #define TMC2208_DEFINE_HARDWARE(ST) _TMC2208_DEFINE_HARDWARE(ST, TMC_##ST##_LABEL)
-
-  #define _TMC2208_DEFINE_SOFTWARE(ST, L) TMCMarlin<TMC2208Stepper, L> stepper##ST(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN, ST##_RSENSE, ST##_SERIAL_RX_PIN > -1)
-  #define TMC2208_DEFINE_SOFTWARE(ST) _TMC2208_DEFINE_SOFTWARE(ST, TMC_##ST##_LABEL)
-
   // Stepper objects of TMC2208 steppers used
   #if AXIS_DRIVER_TYPE_X(TMC2208)
     #ifdef X_HARDWARE_SERIAL
-      TMC2208_DEFINE_HARDWARE(X);
+      TMC_UART_DEFINE(HW, X, X);
     #else
-      TMC2208_DEFINE_SOFTWARE(X);
+      TMC_UART_DEFINE(SW, X, X);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE_X2(TMC2208)
     #ifdef X2_HARDWARE_SERIAL
-      TMC2208_DEFINE_HARDWARE(X2);
+      TMC_UART_DEFINE(HW, X2, X);
     #else
-      TMC2208_DEFINE_SOFTWARE(X2);
+      TMC_UART_DEFINE(SW, X2, X);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE_Y(TMC2208)
     #ifdef Y_HARDWARE_SERIAL
-      TMC2208_DEFINE_HARDWARE(Y);
+      TMC_UART_DEFINE(HW, Y, Y);
     #else
-      TMC2208_DEFINE_SOFTWARE(Y);
+      TMC_UART_DEFINE(SW, Y, Y);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE_Y2(TMC2208)
     #ifdef Y2_HARDWARE_SERIAL
-      TMC2208_DEFINE_HARDWARE(Y2);
+      TMC_UART_DEFINE(HW, Y2, Y);
     #else
-      TMC2208_DEFINE_SOFTWARE(Y2);
+      TMC_UART_DEFINE(SW, Y2, Y);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE_Z(TMC2208)
     #ifdef Z_HARDWARE_SERIAL
-      TMC2208_DEFINE_HARDWARE(Z);
+      TMC_UART_DEFINE(HW, Z, Z);
     #else
-      TMC2208_DEFINE_SOFTWARE(Z);
+      TMC_UART_DEFINE(SW, Z, Z);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE_Z2(TMC2208)
     #ifdef Z2_HARDWARE_SERIAL
-      TMC2208_DEFINE_HARDWARE(Z2);
+      TMC_UART_DEFINE(HW, Z2, Z);
     #else
-      TMC2208_DEFINE_SOFTWARE(Z2);
+      TMC_UART_DEFINE(SW, Z2, Z);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE_Z3(TMC2208)
     #ifdef Z3_HARDWARE_SERIAL
-      TMC2208_DEFINE_HARDWARE(Z3);
+      TMC_UART_DEFINE(HW, Z3, Z);
     #else
-      TMC2208_DEFINE_SOFTWARE(Z3);
+      TMC_UART_DEFINE(SW, Z3, Z);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE_E0(TMC2208)
     #ifdef E0_HARDWARE_SERIAL
-      TMC2208_DEFINE_HARDWARE(E0);
+      TMC_UART_DEFINE_E(HW, 0);
     #else
-      TMC2208_DEFINE_SOFTWARE(E0);
+      TMC_UART_DEFINE_E(SW, 0);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE_E1(TMC2208)
     #ifdef E1_HARDWARE_SERIAL
-      TMC2208_DEFINE_HARDWARE(E1);
+      TMC_UART_DEFINE_E(HW, 1);
     #else
-      TMC2208_DEFINE_SOFTWARE(E1);
+      TMC_UART_DEFINE_E(SW, 1);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE_E2(TMC2208)
     #ifdef E2_HARDWARE_SERIAL
-      TMC2208_DEFINE_HARDWARE(E2);
+      TMC_UART_DEFINE_E(HW, 2);
     #else
-      TMC2208_DEFINE_SOFTWARE(E2);
+      TMC_UART_DEFINE_E(SW, 2);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE_E3(TMC2208)
     #ifdef E3_HARDWARE_SERIAL
-      TMC2208_DEFINE_HARDWARE(E3);
+      TMC_UART_DEFINE_E(HW, 3);
     #else
-      TMC2208_DEFINE_SOFTWARE(E3);
+      TMC_UART_DEFINE_E(SW, 3);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE_E4(TMC2208)
     #ifdef E4_HARDWARE_SERIAL
-      TMC2208_DEFINE_HARDWARE(E4);
+      TMC_UART_DEFINE_E(HW, 4);
     #else
-      TMC2208_DEFINE_SOFTWARE(E4);
+      TMC_UART_DEFINE_E(SW, 4);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE_E5(TMC2208)
     #ifdef E5_HARDWARE_SERIAL
-      TMC2208_DEFINE_HARDWARE(E5);
+      TMC_UART_DEFINE_E(HW, 5);
     #else
-      TMC2208_DEFINE_SOFTWARE(E5);
+      TMC_UART_DEFINE_E(SW, 5);
     #endif
   #endif
 
@@ -547,8 +499,8 @@
     #endif
   }
 
-  template<char AXIS_LETTER, char DRIVER_ID>
-  void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm, const bool stealth) {
+  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+  void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
     TMC2208_n::GCONF_t gconf{0};
     gconf.pdn_disable = true; // Use UART
     gconf.mstep_reg_select = true; // Select microsteps with UART
@@ -581,10 +533,9 @@
     st.PWMCONF(pwmconf.sr);
 
     #if ENABLED(HYBRID_THRESHOLD)
-      st.TPWMTHRS(12650000UL*microsteps/(256*thrs*spmm));
+      st.set_pwm_thrs(thrs);
     #else
       UNUSED(thrs);
-      UNUSED(spmm);
     #endif
 
     st.GSTAT(0b111); // Clear
@@ -592,63 +543,9 @@
   }
 #endif // TMC2208
 
-//
-// TMC2660 Driver objects and inits
-//
 #if HAS_DRIVER(TMC2660)
-
-  #include <SPI.h>
-  #include "planner.h"
-  #include "../core/enum.h"
-
-  #if ENABLED(TMC_USE_SW_SPI)
-    #define _TMC2660_DEFINE(ST, L) TMCMarlin<TMC2660Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
-    #define TMC2660_DEFINE(ST) _TMC2660_DEFINE(ST, TMC_##ST##_LABEL)
-  #else
-    #define _TMC2660_DEFINE(ST, L) TMCMarlin<TMC2660Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE)
-    #define TMC2660_DEFINE(ST) _TMC2660_DEFINE(ST, TMC_##ST##_LABEL)
-  #endif
-
-  // Stepper objects of TMC2660 steppers used
-  #if AXIS_DRIVER_TYPE_X(TMC2660)
-    TMC2660_DEFINE(X);
-  #endif
-  #if AXIS_DRIVER_TYPE_X2(TMC2660)
-    TMC2660_DEFINE(X2);
-  #endif
-  #if AXIS_DRIVER_TYPE_Y(TMC2660)
-    TMC2660_DEFINE(Y);
-  #endif
-  #if AXIS_DRIVER_TYPE_Y2(TMC2660)
-    TMC2660_DEFINE(Y2);
-  #endif
-  #if AXIS_DRIVER_TYPE_Z(TMC2660)
-    TMC2660_DEFINE(Z);
-  #endif
-  #if AXIS_DRIVER_TYPE_Z2(TMC2660)
-    TMC2660_DEFINE(Z2);
-  #endif
-  #if AXIS_DRIVER_TYPE_E0(TMC2660)
-    TMC2660_DEFINE(E0);
-  #endif
-  #if AXIS_DRIVER_TYPE_E1(TMC2660)
-    TMC2660_DEFINE(E1);
-  #endif
-  #if AXIS_DRIVER_TYPE_E2(TMC2660)
-    TMC2660_DEFINE(E2);
-  #endif
-  #if AXIS_DRIVER_TYPE_E3(TMC2660)
-    TMC2660_DEFINE(E3);
-  #endif
-  #if AXIS_DRIVER_TYPE_E4(TMC2660)
-    TMC2660_DEFINE(E4);
-  #endif
-  #if AXIS_DRIVER_TYPE_E5(TMC2660)
-    TMC2660_DEFINE(E5);
-  #endif
-
-  template<char AXIS_LETTER, char DRIVER_ID>
-  void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const float, const bool) {
+  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+  void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const bool) {
     st.begin();
 
     TMC2660_n::CHOPCONF_t chopconf{0};
@@ -669,65 +566,9 @@
   }
 #endif // TMC2660
 
-//
-// TMC5130 Driver objects and inits
-//
 #if HAS_DRIVER(TMC5130)
-
-  #include <SPI.h>
-  #include "planner.h"
-  #include "../core/enum.h"
-
-  #if ENABLED(TMC_USE_SW_SPI)
-    #define _TMC5130_DEFINE(ST, L) TMCMarlin<TMC5130Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
-    #define TMC5130_DEFINE(ST) _TMC5130_DEFINE(ST, TMC_##ST##_LABEL)
-  #else
-    #define _TMC5130_DEFINE(ST, L) TMCMarlin<TMC5130Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE)
-    #define TMC5130_DEFINE(ST) _TMC5130_DEFINE(ST, TMC_##ST##_LABEL)
-  #endif
-  // Stepper objects of TMC5130 steppers used
-  #if AXIS_DRIVER_TYPE_X(TMC5130)
-    TMC5130_DEFINE(X);
-  #endif
-  #if AXIS_DRIVER_TYPE_X2(TMC5130)
-    TMC5130_DEFINE(X2);
-  #endif
-  #if AXIS_DRIVER_TYPE_Y(TMC5130)
-    TMC5130_DEFINE(Y);
-  #endif
-  #if AXIS_DRIVER_TYPE_Y2(TMC5130)
-    TMC5130_DEFINE(Y2);
-  #endif
-  #if AXIS_DRIVER_TYPE_Z(TMC5130)
-    TMC5130_DEFINE(Z);
-  #endif
-  #if AXIS_DRIVER_TYPE_Z2(TMC5130)
-    TMC5130_DEFINE(Z2);
-  #endif
-  #if AXIS_DRIVER_TYPE_Z3(TMC5130)
-    TMC5130_DEFINE(Z3);
-  #endif
-  #if AXIS_DRIVER_TYPE_E0(TMC5130)
-    TMC5130_DEFINE(E0);
-  #endif
-  #if AXIS_DRIVER_TYPE_E1(TMC5130)
-    TMC5130_DEFINE(E1);
-  #endif
-  #if AXIS_DRIVER_TYPE_E2(TMC5130)
-    TMC5130_DEFINE(E2);
-  #endif
-  #if AXIS_DRIVER_TYPE_E3(TMC5130)
-    TMC5130_DEFINE(E3);
-  #endif
-  #if AXIS_DRIVER_TYPE_E4(TMC5130)
-    TMC5130_DEFINE(E4);
-  #endif
-  #if AXIS_DRIVER_TYPE_E5(TMC5130)
-    TMC5130_DEFINE(E5);
-  #endif
-
-  template<char AXIS_LETTER, char DRIVER_ID>
-  void tmc_init(TMCMarlin<TMC5130Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm, const bool stealth) {
+  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+  void tmc_init(TMCMarlin<TMC5130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
@@ -754,75 +595,18 @@
     st.PWMCONF(pwmconf.sr);
 
     #if ENABLED(HYBRID_THRESHOLD)
-      st.TPWMTHRS(12650000UL*microsteps/(256*thrs*spmm));
+      st.set_pwm_thrs(thrs);
     #else
       UNUSED(thrs);
-      UNUSED(spmm);
     #endif
 
     st.GSTAT(); // Clear GSTAT
   }
 #endif // TMC5130
 
-//
-// TMC5160 Driver objects and inits
-//
 #if HAS_DRIVER(TMC5160)
-
-  #include <SPI.h>
-  #include "planner.h"
-  #include "../core/enum.h"
-
-  #if ENABLED(TMC_USE_SW_SPI)
-    #define _TMC5160_DEFINE(ST, L) TMCMarlin<TMC5160Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
-    #define TMC5160_DEFINE(ST) _TMC5160_DEFINE(ST, TMC_##ST##_LABEL)
-  #else
-    #define _TMC5160_DEFINE(ST, L) TMCMarlin<TMC5160Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE)
-    #define TMC5160_DEFINE(ST) _TMC5160_DEFINE(ST, TMC_##ST##_LABEL)
-  #endif
-  // Stepper objects of TMC5160 steppers used
-  #if AXIS_DRIVER_TYPE(X, TMC5160)
-    TMC5160_DEFINE(X);
-  #endif
-  #if AXIS_DRIVER_TYPE(X2, TMC5160)
-    TMC5160_DEFINE(X2);
-  #endif
-  #if AXIS_DRIVER_TYPE(Y, TMC5160)
-    TMC5160_DEFINE(Y);
-  #endif
-  #if AXIS_DRIVER_TYPE(Y2, TMC5160)
-    TMC5160_DEFINE(Y2);
-  #endif
-  #if AXIS_DRIVER_TYPE(Z, TMC5160)
-    TMC5160_DEFINE(Z);
-  #endif
-  #if AXIS_DRIVER_TYPE(Z2, TMC5160)
-    TMC5160_DEFINE(Z2);
-  #endif
-  #if AXIS_DRIVER_TYPE(Z3, TMC5160)
-    TMC5160_DEFINE(Z3);
-  #endif
-  #if AXIS_DRIVER_TYPE(E0, TMC5160)
-    TMC5160_DEFINE(E0);
-  #endif
-  #if AXIS_DRIVER_TYPE(E1, TMC5160)
-    TMC5160_DEFINE(E1);
-  #endif
-  #if AXIS_DRIVER_TYPE(E2, TMC5160)
-    TMC5160_DEFINE(E2);
-  #endif
-  #if AXIS_DRIVER_TYPE(E3, TMC5160)
-    TMC5160_DEFINE(E3);
-  #endif
-  #if AXIS_DRIVER_TYPE(E4, TMC5160)
-    TMC5160_DEFINE(E4);
-  #endif
-  #if AXIS_DRIVER_TYPE(E5, TMC5160)
-    TMC5160_DEFINE(E5);
-  #endif
-
-  template<char AXIS_LETTER, char DRIVER_ID>
-  void tmc_init(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm, const bool stealth) {
+  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+  void tmc_init(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
     st.begin();
 
     int8_t timings[] = CHOPPER_TIMING; // Default 4, -2, 1
@@ -857,10 +641,9 @@
     st.PWMCONF(pwmconf.sr);
 
     #if ENABLED(HYBRID_THRESHOLD)
-      st.TPWMTHRS(12650000UL*microsteps/(256*thrs*spmm));
+      st.set_pwm_thrs(thrs);
     #else
       UNUSED(thrs);
-      UNUSED(spmm);
     #endif
     st.GSTAT(); // Clear GSTAT
   }
@@ -941,43 +724,43 @@ void reset_stepper_drivers() {
   #endif
 
   #if AXIS_IS_TMC(X)
-    _TMC_INIT(X, X_AXIS, STEALTH_AXIS_XY);
+    _TMC_INIT(X, STEALTH_AXIS_XY);
   #endif
   #if AXIS_IS_TMC(X2)
-    _TMC_INIT(X2, X_AXIS, STEALTH_AXIS_XY);
+    _TMC_INIT(X2, STEALTH_AXIS_XY);
   #endif
   #if AXIS_IS_TMC(Y)
-    _TMC_INIT(Y, Y_AXIS, STEALTH_AXIS_XY);
+    _TMC_INIT(Y, STEALTH_AXIS_XY);
   #endif
   #if AXIS_IS_TMC(Y2)
-    _TMC_INIT(Y2, Y_AXIS, STEALTH_AXIS_XY);
+    _TMC_INIT(Y2, STEALTH_AXIS_XY);
   #endif
   #if AXIS_IS_TMC(Z)
-    _TMC_INIT(Z, Z_AXIS, STEALTH_AXIS_Z);
+    _TMC_INIT(Z, STEALTH_AXIS_Z);
   #endif
   #if AXIS_IS_TMC(Z2)
-    _TMC_INIT(Z2, Z_AXIS, STEALTH_AXIS_Z);
+    _TMC_INIT(Z2, STEALTH_AXIS_Z);
   #endif
   #if AXIS_IS_TMC(Z3)
-    _TMC_INIT(Z3, Z_AXIS, STEALTH_AXIS_Z);
+    _TMC_INIT(Z3, STEALTH_AXIS_Z);
   #endif
   #if AXIS_IS_TMC(E0)
-    _TMC_INIT(E0, E_AXIS, STEALTH_AXIS_E);
+    _TMC_INIT(E0, STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E1)
-    _TMC_INIT(E1, E_AXIS_N(1), STEALTH_AXIS_E);
+    _TMC_INIT(E1, STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E2)
-    _TMC_INIT(E2, E_AXIS_N(2), STEALTH_AXIS_E);
+    _TMC_INIT(E2, STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E3)
-    _TMC_INIT(E3, E_AXIS_N(3), STEALTH_AXIS_E);
+    _TMC_INIT(E3, STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E4)
-    _TMC_INIT(E4, E_AXIS_N(4), STEALTH_AXIS_E);
+    _TMC_INIT(E4, STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E5)
-    _TMC_INIT(E5, E_AXIS_N(5), STEALTH_AXIS_E);
+    _TMC_INIT(E5, STEALTH_AXIS_E);
   #endif
 
   #if USE_SENSORLESS

commit ba39186364b69f7399f33b7ddb1115db42c6eabc
Author: LinFor <linfor@gmail.com>
Date:   Wed Feb 20 11:22:42 2019 +0300

    TMC_DEBUG optimization and improvements (#13135)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 7414894995..2e25b11afd 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -662,6 +662,10 @@
     st.microsteps(microsteps);
     st.intpol(INTERPOLATE);
     st.diss2g(true); // Disable short to ground protection. Too many false readings?
+
+    #if ENABLED(TMC_DEBUG)
+      st.rdsel(0b01);
+    #endif
   }
 #endif // TMC2660
 

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 597880e830..7414894995 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit d81342254a1fb8b12ce7d86cde574d7d96cc9871
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Wed Feb 6 14:33:14 2019 +0200

    Support new TMC drivers (#13026)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index e8d9888a72..597880e830 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -158,10 +158,10 @@
   #include "../core/enum.h"
 
   #if ENABLED(TMC_USE_SW_SPI)
-    #define _TMC2130_DEFINE(ST, L) TMCMarlin<TMC2130Stepper, L> stepper##ST(ST##_CS_PIN, R_SENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
+    #define _TMC2130_DEFINE(ST, L) TMCMarlin<TMC2130Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
     #define TMC2130_DEFINE(ST) _TMC2130_DEFINE(ST, TMC_##ST##_LABEL)
   #else
-    #define _TMC2130_DEFINE(ST, L) TMCMarlin<TMC2130Stepper, L> stepper##ST(ST##_CS_PIN, R_SENSE)
+    #define _TMC2130_DEFINE(ST, L) TMCMarlin<TMC2130Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE)
     #define TMC2130_DEFINE(ST) _TMC2130_DEFINE(ST, TMC_##ST##_LABEL)
   #endif
   // Stepper objects of TMC2130 steppers used
@@ -243,6 +243,110 @@
   }
 #endif // TMC2130
 
+//
+// TMC2160 Driver objects and inits
+//
+#if HAS_DRIVER(TMC2160)
+
+  #include <SPI.h>
+  #include "planner.h"
+  #include "../core/enum.h"
+
+  #if ENABLED(TMC_USE_SW_SPI)
+    #define _TMC2160_DEFINE(ST, L) TMCMarlin<TMC2160Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
+    #define TMC2160_DEFINE(ST) _TMC2160_DEFINE(ST, TMC_##ST##_LABEL)
+  #else
+    #define _TMC2160_DEFINE(ST, L) TMCMarlin<TMC2160Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE)
+    #define TMC2160_DEFINE(ST) _TMC2160_DEFINE(ST, TMC_##ST##_LABEL)
+  #endif
+  // Stepper objects of TMC2160 steppers used
+  #if AXIS_DRIVER_TYPE(X, TMC2160)
+    TMC2160_DEFINE(X);
+  #endif
+  #if AXIS_DRIVER_TYPE(X2, TMC2160)
+    TMC2160_DEFINE(X2);
+  #endif
+  #if AXIS_DRIVER_TYPE(Y, TMC2160)
+    TMC2160_DEFINE(Y);
+  #endif
+  #if AXIS_DRIVER_TYPE(Y2, TMC2160)
+    TMC2160_DEFINE(Y2);
+  #endif
+  #if AXIS_DRIVER_TYPE(Z, TMC2160)
+    TMC2160_DEFINE(Z);
+  #endif
+  #if AXIS_DRIVER_TYPE(Z2, TMC2160)
+    TMC2160_DEFINE(Z2);
+  #endif
+  #if AXIS_DRIVER_TYPE(Z3, TMC2160)
+    TMC2160_DEFINE(Z3);
+  #endif
+  #if AXIS_DRIVER_TYPE(E0, TMC2160)
+    TMC2160_DEFINE(E0);
+  #endif
+  #if AXIS_DRIVER_TYPE(E1, TMC2160)
+    TMC2160_DEFINE(E1);
+  #endif
+  #if AXIS_DRIVER_TYPE(E2, TMC2160)
+    TMC2160_DEFINE(E2);
+  #endif
+  #if AXIS_DRIVER_TYPE(E3, TMC2160)
+    TMC2160_DEFINE(E3);
+  #endif
+  #if AXIS_DRIVER_TYPE(E4, TMC2160)
+    TMC2160_DEFINE(E4);
+  #endif
+  #if AXIS_DRIVER_TYPE(E5, TMC2160)
+    TMC2160_DEFINE(E5);
+  #endif
+
+  template<char AXIS_LETTER, char DRIVER_ID>
+  void tmc_init(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm, const bool stealth) {
+    st.begin();
+
+    static constexpr int8_t timings[] = CHOPPER_TIMING; // Default 4, -2, 1
+
+    CHOPCONF_t chopconf{0};
+    chopconf.tbl = 1;
+    chopconf.toff = timings[0];
+    chopconf.intpol = INTERPOLATE;
+    chopconf.hend = timings[1] + 3;
+    chopconf.hstrt = timings[2] - 1;
+    st.CHOPCONF(chopconf.sr);
+
+    st.rms_current(mA, HOLD_MULTIPLIER);
+    st.microsteps(microsteps);
+    st.iholddelay(10);
+    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
+    st.TCOOLTHRS(0xFFFFF);
+
+    #if ENABLED(ADAPTIVE_CURRENT)
+      COOLCONF_t coolconf{0};
+      coolconf.semin = INCREASE_CURRENT_THRS;
+      coolconf.semax = REDUCE_CURRENT_THRS;
+      st.COOLCONF(coolconf.sr);
+    #endif
+
+    st.en_pwm_mode(stealth);
+
+    PWMCONF_t pwmconf{0};
+    pwmconf.pwm_freq = 0b01; // f_pwm = 2/683 f_clk
+    pwmconf.pwm_autoscale = true;
+    pwmconf.pwm_grad = 5;
+    pwmconf.pwm_ampl = 180;
+    st.PWMCONF(pwmconf.sr);
+
+    #if ENABLED(HYBRID_THRESHOLD)
+      st.TPWMTHRS(12650000UL*microsteps/(256*thrs*spmm));
+    #else
+      UNUSED(thrs);
+      UNUSED(spmm);
+    #endif
+
+    st.GSTAT(); // Clear GSTAT
+  }
+#endif // TMC2160
+
 //
 // TMC2208 Driver objects and inits
 //
@@ -250,10 +354,10 @@
   #include <HardwareSerial.h>
   #include "planner.h"
 
-  #define _TMC2208_DEFINE_HARDWARE(ST, L) TMCMarlin<TMC2208Stepper, L> stepper##ST(&ST##_HARDWARE_SERIAL, R_SENSE)
+  #define _TMC2208_DEFINE_HARDWARE(ST, L) TMCMarlin<TMC2208Stepper, L> stepper##ST(&ST##_HARDWARE_SERIAL, ST##_RSENSE)
   #define TMC2208_DEFINE_HARDWARE(ST) _TMC2208_DEFINE_HARDWARE(ST, TMC_##ST##_LABEL)
 
-  #define _TMC2208_DEFINE_SOFTWARE(ST, L) TMCMarlin<TMC2208Stepper, L> stepper##ST(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN, R_SENSE, ST##_SERIAL_RX_PIN > -1)
+  #define _TMC2208_DEFINE_SOFTWARE(ST, L) TMCMarlin<TMC2208Stepper, L> stepper##ST(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN, ST##_RSENSE, ST##_SERIAL_RX_PIN > -1)
   #define TMC2208_DEFINE_SOFTWARE(ST) _TMC2208_DEFINE_SOFTWARE(ST, TMC_##ST##_LABEL)
 
   // Stepper objects of TMC2208 steppers used
@@ -498,10 +602,10 @@
   #include "../core/enum.h"
 
   #if ENABLED(TMC_USE_SW_SPI)
-    #define _TMC2660_DEFINE(ST, L) TMCMarlin<TMC2660Stepper, L> stepper##ST(ST##_CS_PIN, R_SENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
+    #define _TMC2660_DEFINE(ST, L) TMCMarlin<TMC2660Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
     #define TMC2660_DEFINE(ST) _TMC2660_DEFINE(ST, TMC_##ST##_LABEL)
   #else
-    #define _TMC2660_DEFINE(ST, L) TMCMarlin<TMC2660Stepper, L> stepper##ST(ST##_CS_PIN, R_SENSE)
+    #define _TMC2660_DEFINE(ST, L) TMCMarlin<TMC2660Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE)
     #define TMC2660_DEFINE(ST) _TMC2660_DEFINE(ST, TMC_##ST##_LABEL)
   #endif
 
@@ -561,6 +665,203 @@
   }
 #endif // TMC2660
 
+//
+// TMC5130 Driver objects and inits
+//
+#if HAS_DRIVER(TMC5130)
+
+  #include <SPI.h>
+  #include "planner.h"
+  #include "../core/enum.h"
+
+  #if ENABLED(TMC_USE_SW_SPI)
+    #define _TMC5130_DEFINE(ST, L) TMCMarlin<TMC5130Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
+    #define TMC5130_DEFINE(ST) _TMC5130_DEFINE(ST, TMC_##ST##_LABEL)
+  #else
+    #define _TMC5130_DEFINE(ST, L) TMCMarlin<TMC5130Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE)
+    #define TMC5130_DEFINE(ST) _TMC5130_DEFINE(ST, TMC_##ST##_LABEL)
+  #endif
+  // Stepper objects of TMC5130 steppers used
+  #if AXIS_DRIVER_TYPE_X(TMC5130)
+    TMC5130_DEFINE(X);
+  #endif
+  #if AXIS_DRIVER_TYPE_X2(TMC5130)
+    TMC5130_DEFINE(X2);
+  #endif
+  #if AXIS_DRIVER_TYPE_Y(TMC5130)
+    TMC5130_DEFINE(Y);
+  #endif
+  #if AXIS_DRIVER_TYPE_Y2(TMC5130)
+    TMC5130_DEFINE(Y2);
+  #endif
+  #if AXIS_DRIVER_TYPE_Z(TMC5130)
+    TMC5130_DEFINE(Z);
+  #endif
+  #if AXIS_DRIVER_TYPE_Z2(TMC5130)
+    TMC5130_DEFINE(Z2);
+  #endif
+  #if AXIS_DRIVER_TYPE_Z3(TMC5130)
+    TMC5130_DEFINE(Z3);
+  #endif
+  #if AXIS_DRIVER_TYPE_E0(TMC5130)
+    TMC5130_DEFINE(E0);
+  #endif
+  #if AXIS_DRIVER_TYPE_E1(TMC5130)
+    TMC5130_DEFINE(E1);
+  #endif
+  #if AXIS_DRIVER_TYPE_E2(TMC5130)
+    TMC5130_DEFINE(E2);
+  #endif
+  #if AXIS_DRIVER_TYPE_E3(TMC5130)
+    TMC5130_DEFINE(E3);
+  #endif
+  #if AXIS_DRIVER_TYPE_E4(TMC5130)
+    TMC5130_DEFINE(E4);
+  #endif
+  #if AXIS_DRIVER_TYPE_E5(TMC5130)
+    TMC5130_DEFINE(E5);
+  #endif
+
+  template<char AXIS_LETTER, char DRIVER_ID>
+  void tmc_init(TMCMarlin<TMC5130Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm, const bool stealth) {
+    st.begin();
+
+    CHOPCONF_t chopconf{0};
+    chopconf.tbl = 1;
+    chopconf.toff = chopper_timing.toff;
+    chopconf.intpol = INTERPOLATE;
+    chopconf.hend = chopper_timing.hend + 3;
+    chopconf.hstrt = chopper_timing.hstrt - 1;
+    st.CHOPCONF(chopconf.sr);
+
+    st.rms_current(mA, HOLD_MULTIPLIER);
+    st.microsteps(microsteps);
+    st.iholddelay(10);
+    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
+
+    st.en_pwm_mode(stealth);
+    st.stored.stealthChop_enabled = stealth;
+
+    PWMCONF_t pwmconf{0};
+    pwmconf.pwm_freq = 0b01; // f_pwm = 2/683 f_clk
+    pwmconf.pwm_autoscale = true;
+    pwmconf.pwm_grad = 5;
+    pwmconf.pwm_ampl = 180;
+    st.PWMCONF(pwmconf.sr);
+
+    #if ENABLED(HYBRID_THRESHOLD)
+      st.TPWMTHRS(12650000UL*microsteps/(256*thrs*spmm));
+    #else
+      UNUSED(thrs);
+      UNUSED(spmm);
+    #endif
+
+    st.GSTAT(); // Clear GSTAT
+  }
+#endif // TMC5130
+
+//
+// TMC5160 Driver objects and inits
+//
+#if HAS_DRIVER(TMC5160)
+
+  #include <SPI.h>
+  #include "planner.h"
+  #include "../core/enum.h"
+
+  #if ENABLED(TMC_USE_SW_SPI)
+    #define _TMC5160_DEFINE(ST, L) TMCMarlin<TMC5160Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
+    #define TMC5160_DEFINE(ST) _TMC5160_DEFINE(ST, TMC_##ST##_LABEL)
+  #else
+    #define _TMC5160_DEFINE(ST, L) TMCMarlin<TMC5160Stepper, L> stepper##ST(ST##_CS_PIN, ST##_RSENSE)
+    #define TMC5160_DEFINE(ST) _TMC5160_DEFINE(ST, TMC_##ST##_LABEL)
+  #endif
+  // Stepper objects of TMC5160 steppers used
+  #if AXIS_DRIVER_TYPE(X, TMC5160)
+    TMC5160_DEFINE(X);
+  #endif
+  #if AXIS_DRIVER_TYPE(X2, TMC5160)
+    TMC5160_DEFINE(X2);
+  #endif
+  #if AXIS_DRIVER_TYPE(Y, TMC5160)
+    TMC5160_DEFINE(Y);
+  #endif
+  #if AXIS_DRIVER_TYPE(Y2, TMC5160)
+    TMC5160_DEFINE(Y2);
+  #endif
+  #if AXIS_DRIVER_TYPE(Z, TMC5160)
+    TMC5160_DEFINE(Z);
+  #endif
+  #if AXIS_DRIVER_TYPE(Z2, TMC5160)
+    TMC5160_DEFINE(Z2);
+  #endif
+  #if AXIS_DRIVER_TYPE(Z3, TMC5160)
+    TMC5160_DEFINE(Z3);
+  #endif
+  #if AXIS_DRIVER_TYPE(E0, TMC5160)
+    TMC5160_DEFINE(E0);
+  #endif
+  #if AXIS_DRIVER_TYPE(E1, TMC5160)
+    TMC5160_DEFINE(E1);
+  #endif
+  #if AXIS_DRIVER_TYPE(E2, TMC5160)
+    TMC5160_DEFINE(E2);
+  #endif
+  #if AXIS_DRIVER_TYPE(E3, TMC5160)
+    TMC5160_DEFINE(E3);
+  #endif
+  #if AXIS_DRIVER_TYPE(E4, TMC5160)
+    TMC5160_DEFINE(E4);
+  #endif
+  #if AXIS_DRIVER_TYPE(E5, TMC5160)
+    TMC5160_DEFINE(E5);
+  #endif
+
+  template<char AXIS_LETTER, char DRIVER_ID>
+  void tmc_init(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm, const bool stealth) {
+    st.begin();
+
+    int8_t timings[] = CHOPPER_TIMING; // Default 4, -2, 1
+
+    CHOPCONF_t chopconf{0};
+    chopconf.tbl = 1;
+    chopconf.toff = timings[0];
+    chopconf.intpol = INTERPOLATE;
+    chopconf.hend = timings[1] + 3;
+    chopconf.hstrt = timings[2] - 1;
+    st.CHOPCONF(chopconf.sr);
+
+    st.rms_current(mA, HOLD_MULTIPLIER);
+    st.microsteps(microsteps);
+    st.iholddelay(10);
+    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
+
+    #if ENABLED(ADAPTIVE_CURRENT)
+      COOLCONF_t coolconf{0};
+      coolconf.semin = INCREASE_CURRENT_THRS;
+      coolconf.semax = REDUCE_CURRENT_THRS;
+      st.COOLCONF(coolconf.sr);
+    #endif
+
+    st.en_pwm_mode(stealth);
+
+    PWMCONF_t pwmconf{0};
+    pwmconf.pwm_freq = 0b01; // f_pwm = 2/683 f_clk
+    pwmconf.pwm_autoscale = true;
+    pwmconf.pwm_grad = 5;
+    pwmconf.pwm_ampl = 180;
+    st.PWMCONF(pwmconf.sr);
+
+    #if ENABLED(HYBRID_THRESHOLD)
+      st.TPWMTHRS(12650000UL*microsteps/(256*thrs*spmm));
+    #else
+      UNUSED(thrs);
+      UNUSED(spmm);
+    #endif
+    st.GSTAT(); // Clear GSTAT
+  }
+#endif // TMC5160
+
 void restore_stepper_drivers() {
   #if AXIS_IS_TMC(X)
     stepperX.push();

commit d4d1b28a06caa57d26e300c1b814b2b8b62120cd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 4 03:41:55 2019 -0600

    Fix some include paths

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index a85d275658..e8d9888a72 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -35,7 +35,7 @@
 
 #include "../inc/MarlinConfig.h"
 
-#include "../module/stepper.h"
+#include "stepper.h"
 
 #if HAS_DRIVER(L6470)
   #include "L6470/L6470_Marlin.h"

commit 2f35747f294c4b3dc3e6920b34e208f89bd4841d
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Wed Jan 23 19:06:54 2019 -0600

    L6470 SPI daisy chain support (#12895)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 74d5aa0c12..a85d275658 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -37,6 +37,10 @@
 
 #include "../module/stepper.h"
 
+#if HAS_DRIVER(L6470)
+  #include "L6470/L6470_Marlin.h"
+#endif
+
 //
 // TMC26X Driver objects and inits
 //
@@ -51,43 +55,43 @@
 
   #define _TMC26X_DEFINE(ST) TMC26XStepper stepper##ST(200, ST##_CS_PIN, ST##_STEP_PIN, ST##_DIR_PIN, ST##_MAX_CURRENT, ST##_SENSE_RESISTOR)
 
-  #if AXIS_DRIVER_TYPE(X, TMC26X)
+  #if AXIS_DRIVER_TYPE_X(TMC26X)
     _TMC26X_DEFINE(X);
   #endif
-  #if AXIS_DRIVER_TYPE(X2, TMC26X)
+  #if AXIS_DRIVER_TYPE_X2(TMC26X)
     _TMC26X_DEFINE(X2);
   #endif
-  #if AXIS_DRIVER_TYPE(Y, TMC26X)
+  #if AXIS_DRIVER_TYPE_Y(TMC26X)
     _TMC26X_DEFINE(Y);
   #endif
-  #if AXIS_DRIVER_TYPE(Y2, TMC26X)
+  #if AXIS_DRIVER_TYPE_Y2(TMC26X)
     _TMC26X_DEFINE(Y2);
   #endif
-  #if AXIS_DRIVER_TYPE(Z, TMC26X)
+  #if AXIS_DRIVER_TYPE_Z(TMC26X)
     _TMC26X_DEFINE(Z);
   #endif
-  #if AXIS_DRIVER_TYPE(Z2, TMC26X)
+  #if AXIS_DRIVER_TYPE_Z2(TMC26X)
     _TMC26X_DEFINE(Z2);
   #endif
-  #if AXIS_DRIVER_TYPE(Z3, TMC26X)
+  #if AXIS_DRIVER_TYPE_Z3(TMC26X)
     _TMC26X_DEFINE(Z3);
   #endif
-  #if AXIS_DRIVER_TYPE(E0, TMC26X)
+  #if AXIS_DRIVER_TYPE_E0(TMC26X)
     _TMC26X_DEFINE(E0);
   #endif
-  #if AXIS_DRIVER_TYPE(E1, TMC26X)
+  #if AXIS_DRIVER_TYPE_E1(TMC26X)
     _TMC26X_DEFINE(E1);
   #endif
-  #if AXIS_DRIVER_TYPE(E2, TMC26X)
+  #if AXIS_DRIVER_TYPE_E2(TMC26X)
     _TMC26X_DEFINE(E2);
   #endif
-  #if AXIS_DRIVER_TYPE(E3, TMC26X)
+  #if AXIS_DRIVER_TYPE_E3(TMC26X)
     _TMC26X_DEFINE(E3);
   #endif
-  #if AXIS_DRIVER_TYPE(E4, TMC26X)
+  #if AXIS_DRIVER_TYPE_E4(TMC26X)
     _TMC26X_DEFINE(E4);
   #endif
-  #if AXIS_DRIVER_TYPE(E5, TMC26X)
+  #if AXIS_DRIVER_TYPE_E5(TMC26X)
     _TMC26X_DEFINE(E5);
   #endif
 
@@ -97,43 +101,43 @@
   }while(0)
 
   void tmc26x_init_to_defaults() {
-    #if AXIS_DRIVER_TYPE(X, TMC26X)
+    #if AXIS_DRIVER_TYPE_X(TMC26X)
       _TMC26X_INIT(X);
     #endif
-    #if AXIS_DRIVER_TYPE(X2, TMC26X)
+    #if AXIS_DRIVER_TYPE_X2(TMC26X)
       _TMC26X_INIT(X2);
     #endif
-    #if AXIS_DRIVER_TYPE(Y, TMC26X)
+    #if AXIS_DRIVER_TYPE_Y(TMC26X)
       _TMC26X_INIT(Y);
     #endif
-    #if AXIS_DRIVER_TYPE(Y2, TMC26X)
+    #if AXIS_DRIVER_TYPE_Y2(TMC26X)
       _TMC26X_INIT(Y2);
     #endif
-    #if AXIS_DRIVER_TYPE(Z, TMC26X)
+    #if AXIS_DRIVER_TYPE_Z(TMC26X)
       _TMC26X_INIT(Z);
     #endif
-    #if AXIS_DRIVER_TYPE(Z2, TMC26X)
+    #if AXIS_DRIVER_TYPE_Z2(TMC26X)
       _TMC26X_INIT(Z2);
     #endif
-    #if AXIS_DRIVER_TYPE(Z3, TMC26X)
+    #if AXIS_DRIVER_TYPE_Z3(TMC26X)
       _TMC26X_INIT(Z3);
     #endif
-    #if AXIS_DRIVER_TYPE(E0, TMC26X)
+    #if AXIS_DRIVER_TYPE_E0(TMC26X)
       _TMC26X_INIT(E0);
     #endif
-    #if AXIS_DRIVER_TYPE(E1, TMC26X)
+    #if AXIS_DRIVER_TYPE_E1(TMC26X)
       _TMC26X_INIT(E1);
     #endif
-    #if AXIS_DRIVER_TYPE(E2, TMC26X)
+    #if AXIS_DRIVER_TYPE_E2(TMC26X)
       _TMC26X_INIT(E2);
     #endif
-    #if AXIS_DRIVER_TYPE(E3, TMC26X)
+    #if AXIS_DRIVER_TYPE_E3(TMC26X)
       _TMC26X_INIT(E3);
     #endif
-    #if AXIS_DRIVER_TYPE(E4, TMC26X)
+    #if AXIS_DRIVER_TYPE_E4(TMC26X)
       _TMC26X_INIT(E4);
     #endif
-    #if AXIS_DRIVER_TYPE(E5, TMC26X)
+    #if AXIS_DRIVER_TYPE_E5(TMC26X)
       _TMC26X_INIT(E5);
     #endif
   }
@@ -161,43 +165,43 @@
     #define TMC2130_DEFINE(ST) _TMC2130_DEFINE(ST, TMC_##ST##_LABEL)
   #endif
   // Stepper objects of TMC2130 steppers used
-  #if AXIS_DRIVER_TYPE(X, TMC2130)
+  #if AXIS_DRIVER_TYPE_X(TMC2130)
     TMC2130_DEFINE(X);
   #endif
-  #if AXIS_DRIVER_TYPE(X2, TMC2130)
+  #if AXIS_DRIVER_TYPE_X2(TMC2130)
     TMC2130_DEFINE(X2);
   #endif
-  #if AXIS_DRIVER_TYPE(Y, TMC2130)
+  #if AXIS_DRIVER_TYPE_Y(TMC2130)
     TMC2130_DEFINE(Y);
   #endif
-  #if AXIS_DRIVER_TYPE(Y2, TMC2130)
+  #if AXIS_DRIVER_TYPE_Y2(TMC2130)
     TMC2130_DEFINE(Y2);
   #endif
-  #if AXIS_DRIVER_TYPE(Z, TMC2130)
+  #if AXIS_DRIVER_TYPE_Z(TMC2130)
     TMC2130_DEFINE(Z);
   #endif
-  #if AXIS_DRIVER_TYPE(Z2, TMC2130)
+  #if AXIS_DRIVER_TYPE_Z2(TMC2130)
     TMC2130_DEFINE(Z2);
   #endif
-  #if AXIS_DRIVER_TYPE(Z3, TMC2130)
+  #if AXIS_DRIVER_TYPE_Z3(TMC2130)
     TMC2130_DEFINE(Z3);
   #endif
-  #if AXIS_DRIVER_TYPE(E0, TMC2130)
+  #if AXIS_DRIVER_TYPE_E0(TMC2130)
     TMC2130_DEFINE(E0);
   #endif
-  #if AXIS_DRIVER_TYPE(E1, TMC2130)
+  #if AXIS_DRIVER_TYPE_E1(TMC2130)
     TMC2130_DEFINE(E1);
   #endif
-  #if AXIS_DRIVER_TYPE(E2, TMC2130)
+  #if AXIS_DRIVER_TYPE_E2(TMC2130)
     TMC2130_DEFINE(E2);
   #endif
-  #if AXIS_DRIVER_TYPE(E3, TMC2130)
+  #if AXIS_DRIVER_TYPE_E3(TMC2130)
     TMC2130_DEFINE(E3);
   #endif
-  #if AXIS_DRIVER_TYPE(E4, TMC2130)
+  #if AXIS_DRIVER_TYPE_E4(TMC2130)
     TMC2130_DEFINE(E4);
   #endif
-  #if AXIS_DRIVER_TYPE(E5, TMC2130)
+  #if AXIS_DRIVER_TYPE_E5(TMC2130)
     TMC2130_DEFINE(E5);
   #endif
 
@@ -253,91 +257,91 @@
   #define TMC2208_DEFINE_SOFTWARE(ST) _TMC2208_DEFINE_SOFTWARE(ST, TMC_##ST##_LABEL)
 
   // Stepper objects of TMC2208 steppers used
-  #if AXIS_DRIVER_TYPE(X, TMC2208)
+  #if AXIS_DRIVER_TYPE_X(TMC2208)
     #ifdef X_HARDWARE_SERIAL
       TMC2208_DEFINE_HARDWARE(X);
     #else
       TMC2208_DEFINE_SOFTWARE(X);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE(X2, TMC2208)
+  #if AXIS_DRIVER_TYPE_X2(TMC2208)
     #ifdef X2_HARDWARE_SERIAL
       TMC2208_DEFINE_HARDWARE(X2);
     #else
       TMC2208_DEFINE_SOFTWARE(X2);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE(Y, TMC2208)
+  #if AXIS_DRIVER_TYPE_Y(TMC2208)
     #ifdef Y_HARDWARE_SERIAL
       TMC2208_DEFINE_HARDWARE(Y);
     #else
       TMC2208_DEFINE_SOFTWARE(Y);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE(Y2, TMC2208)
+  #if AXIS_DRIVER_TYPE_Y2(TMC2208)
     #ifdef Y2_HARDWARE_SERIAL
       TMC2208_DEFINE_HARDWARE(Y2);
     #else
       TMC2208_DEFINE_SOFTWARE(Y2);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE(Z, TMC2208)
+  #if AXIS_DRIVER_TYPE_Z(TMC2208)
     #ifdef Z_HARDWARE_SERIAL
       TMC2208_DEFINE_HARDWARE(Z);
     #else
       TMC2208_DEFINE_SOFTWARE(Z);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE(Z2, TMC2208)
+  #if AXIS_DRIVER_TYPE_Z2(TMC2208)
     #ifdef Z2_HARDWARE_SERIAL
       TMC2208_DEFINE_HARDWARE(Z2);
     #else
       TMC2208_DEFINE_SOFTWARE(Z2);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE(Z3, TMC2208)
+  #if AXIS_DRIVER_TYPE_Z3(TMC2208)
     #ifdef Z3_HARDWARE_SERIAL
       TMC2208_DEFINE_HARDWARE(Z3);
     #else
       TMC2208_DEFINE_SOFTWARE(Z3);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE(E0, TMC2208)
+  #if AXIS_DRIVER_TYPE_E0(TMC2208)
     #ifdef E0_HARDWARE_SERIAL
       TMC2208_DEFINE_HARDWARE(E0);
     #else
       TMC2208_DEFINE_SOFTWARE(E0);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE(E1, TMC2208)
+  #if AXIS_DRIVER_TYPE_E1(TMC2208)
     #ifdef E1_HARDWARE_SERIAL
       TMC2208_DEFINE_HARDWARE(E1);
     #else
       TMC2208_DEFINE_SOFTWARE(E1);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE(E2, TMC2208)
+  #if AXIS_DRIVER_TYPE_E2(TMC2208)
     #ifdef E2_HARDWARE_SERIAL
       TMC2208_DEFINE_HARDWARE(E2);
     #else
       TMC2208_DEFINE_SOFTWARE(E2);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE(E3, TMC2208)
+  #if AXIS_DRIVER_TYPE_E3(TMC2208)
     #ifdef E3_HARDWARE_SERIAL
       TMC2208_DEFINE_HARDWARE(E3);
     #else
       TMC2208_DEFINE_SOFTWARE(E3);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE(E4, TMC2208)
+  #if AXIS_DRIVER_TYPE_E4(TMC2208)
     #ifdef E4_HARDWARE_SERIAL
       TMC2208_DEFINE_HARDWARE(E4);
     #else
       TMC2208_DEFINE_SOFTWARE(E4);
     #endif
   #endif
-  #if AXIS_DRIVER_TYPE(E5, TMC2208)
+  #if AXIS_DRIVER_TYPE_E5(TMC2208)
     #ifdef E5_HARDWARE_SERIAL
       TMC2208_DEFINE_HARDWARE(E5);
     #else
@@ -346,91 +350,91 @@
   #endif
 
   void tmc2208_serial_begin() {
-    #if AXIS_DRIVER_TYPE(X, TMC2208)
+    #if AXIS_DRIVER_TYPE_X(TMC2208)
       #ifdef X_HARDWARE_SERIAL
         X_HARDWARE_SERIAL.begin(115200);
       #else
         stepperX.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE(X2, TMC2208)
+    #if AXIS_DRIVER_TYPE_X2(TMC2208)
       #ifdef X2_HARDWARE_SERIAL
         X2_HARDWARE_SERIAL.begin(115200);
       #else
         stepperX2.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE(Y, TMC2208)
+    #if AXIS_DRIVER_TYPE_Y(TMC2208)
       #ifdef Y_HARDWARE_SERIAL
         Y_HARDWARE_SERIAL.begin(115200);
       #else
         stepperY.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE(Y2, TMC2208)
+    #if AXIS_DRIVER_TYPE_Y2(TMC2208)
       #ifdef Y2_HARDWARE_SERIAL
         Y2_HARDWARE_SERIAL.begin(115200);
       #else
         stepperY2.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE(Z, TMC2208)
+    #if AXIS_DRIVER_TYPE_Z(TMC2208)
       #ifdef Z_HARDWARE_SERIAL
         Z_HARDWARE_SERIAL.begin(115200);
       #else
         stepperZ.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE(Z2, TMC2208)
+    #if AXIS_DRIVER_TYPE_Z2(TMC2208)
       #ifdef Z2_HARDWARE_SERIAL
         Z2_HARDWARE_SERIAL.begin(115200);
       #else
         stepperZ2.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE(Z3, TMC2208)
+    #if AXIS_DRIVER_TYPE_Z3(TMC2208)
       #ifdef Z3_HARDWARE_SERIAL
         Z3_HARDWARE_SERIAL.begin(115200);
       #else
         stepperZ3.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE(E0, TMC2208)
+    #if AXIS_DRIVER_TYPE_E0(TMC2208)
       #ifdef E0_HARDWARE_SERIAL
         E0_HARDWARE_SERIAL.begin(115200);
       #else
         stepperE0.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE(E1, TMC2208)
+    #if AXIS_DRIVER_TYPE_E1(TMC2208)
       #ifdef E1_HARDWARE_SERIAL
         E1_HARDWARE_SERIAL.begin(115200);
       #else
         stepperE1.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE(E2, TMC2208)
+    #if AXIS_DRIVER_TYPE_E2(TMC2208)
       #ifdef E2_HARDWARE_SERIAL
         E2_HARDWARE_SERIAL.begin(115200);
       #else
         stepperE2.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE(E3, TMC2208)
+    #if AXIS_DRIVER_TYPE_E3(TMC2208)
       #ifdef E3_HARDWARE_SERIAL
         E3_HARDWARE_SERIAL.begin(115200);
       #else
         stepperE3.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE(E4, TMC2208)
+    #if AXIS_DRIVER_TYPE_E4(TMC2208)
       #ifdef E4_HARDWARE_SERIAL
         E4_HARDWARE_SERIAL.begin(115200);
       #else
         stepperE4.beginSerial(115200);
       #endif
     #endif
-    #if AXIS_DRIVER_TYPE(E5, TMC2208)
+    #if AXIS_DRIVER_TYPE_E5(TMC2208)
       #ifdef E5_HARDWARE_SERIAL
         E5_HARDWARE_SERIAL.begin(115200);
       #else
@@ -502,40 +506,40 @@
   #endif
 
   // Stepper objects of TMC2660 steppers used
-  #if AXIS_DRIVER_TYPE(X, TMC2660)
+  #if AXIS_DRIVER_TYPE_X(TMC2660)
     TMC2660_DEFINE(X);
   #endif
-  #if AXIS_DRIVER_TYPE(X2, TMC2660)
+  #if AXIS_DRIVER_TYPE_X2(TMC2660)
     TMC2660_DEFINE(X2);
   #endif
-  #if AXIS_DRIVER_TYPE(Y, TMC2660)
+  #if AXIS_DRIVER_TYPE_Y(TMC2660)
     TMC2660_DEFINE(Y);
   #endif
-  #if AXIS_DRIVER_TYPE(Y2, TMC2660)
+  #if AXIS_DRIVER_TYPE_Y2(TMC2660)
     TMC2660_DEFINE(Y2);
   #endif
-  #if AXIS_DRIVER_TYPE(Z, TMC2660)
+  #if AXIS_DRIVER_TYPE_Z(TMC2660)
     TMC2660_DEFINE(Z);
   #endif
-  #if AXIS_DRIVER_TYPE(Z2, TMC2660)
+  #if AXIS_DRIVER_TYPE_Z2(TMC2660)
     TMC2660_DEFINE(Z2);
   #endif
-  #if AXIS_DRIVER_TYPE(E0, TMC2660)
+  #if AXIS_DRIVER_TYPE_E0(TMC2660)
     TMC2660_DEFINE(E0);
   #endif
-  #if AXIS_DRIVER_TYPE(E1, TMC2660)
+  #if AXIS_DRIVER_TYPE_E1(TMC2660)
     TMC2660_DEFINE(E1);
   #endif
-  #if AXIS_DRIVER_TYPE(E2, TMC2660)
+  #if AXIS_DRIVER_TYPE_E2(TMC2660)
     TMC2660_DEFINE(E2);
   #endif
-  #if AXIS_DRIVER_TYPE(E3, TMC2660)
+  #if AXIS_DRIVER_TYPE_E3(TMC2660)
     TMC2660_DEFINE(E3);
   #endif
-  #if AXIS_DRIVER_TYPE(E4, TMC2660)
+  #if AXIS_DRIVER_TYPE_E4(TMC2660)
     TMC2660_DEFINE(E4);
   #endif
-  #if AXIS_DRIVER_TYPE(E5, TMC2660)
+  #if AXIS_DRIVER_TYPE_E5(TMC2660)
     TMC2660_DEFINE(E5);
   #endif
 
@@ -600,11 +604,13 @@ void restore_stepper_drivers() {
 }
 
 void reset_stepper_drivers() {
+
   #if HAS_DRIVER(TMC26X)
     tmc26x_init_to_defaults();
   #endif
-  #if ENABLED(HAVE_L6470DRIVER)
-    L6470_init_to_defaults();
+
+  #if HAS_DRIVER(L6470)
+    L6470.init_to_defaults();
   #endif
 
   #if HAS_TRINAMIC
@@ -703,7 +709,9 @@ void reset_stepper_drivers() {
     TMC_ADV()
   #endif
 
-  stepper.set_directions();
+  #if HAS_TRINAMIC
+    stepper.set_directions();
+  #endif
 }
 
 //
@@ -711,99 +719,114 @@ void reset_stepper_drivers() {
 //
 #if HAS_DRIVER(L6470)
 
-  #include <SPI.h>
-  #include <L6470.h>
+  // create stepper objects
 
-  #define _L6470_DEFINE(ST) L6470 stepper##ST(ST##_ENABLE_PIN)
+  #define _L6470_DEFINE(ST) L6470 stepper##ST((const int)L6470_CHAIN_SS_PIN)
 
   // L6470 Stepper objects
-  #if AXIS_DRIVER_TYPE(X, L6470)
+  #if AXIS_DRIVER_TYPE_X(L6470)
     _L6470_DEFINE(X);
   #endif
-  #if AXIS_DRIVER_TYPE(X2, L6470)
+  #if AXIS_DRIVER_TYPE_X2(L6470)
     _L6470_DEFINE(X2);
   #endif
-  #if AXIS_DRIVER_TYPE(Y, L6470)
+  #if AXIS_DRIVER_TYPE_Y(L6470)
     _L6470_DEFINE(Y);
   #endif
-  #if AXIS_DRIVER_TYPE(Y2, L6470)
+  #if AXIS_DRIVER_TYPE_Y2(L6470)
     _L6470_DEFINE(Y2);
   #endif
-  #if AXIS_DRIVER_TYPE(Z, L6470)
+  #if AXIS_DRIVER_TYPE_Z(L6470)
     _L6470_DEFINE(Z);
   #endif
-  #if AXIS_DRIVER_TYPE(Z2, L6470)
+  #if AXIS_DRIVER_TYPE_Z2(L6470)
     _L6470_DEFINE(Z2);
   #endif
-  #if AXIS_DRIVER_TYPE(Z3, L6470)
+  #if AXIS_DRIVER_TYPE_Z3(L6470)
     _L6470_DEFINE(Z3);
   #endif
-  #if AXIS_DRIVER_TYPE(E0, L6470)
+  #if AXIS_DRIVER_TYPE_E0(L6470)
     _L6470_DEFINE(E0);
   #endif
-  #if AXIS_DRIVER_TYPE(E1, L6470)
+  #if AXIS_DRIVER_TYPE_E1(L6470)
     _L6470_DEFINE(E1);
   #endif
-  #if AXIS_DRIVER_TYPE(E2, L6470)
+  #if AXIS_DRIVER_TYPE_E2(L6470)
     _L6470_DEFINE(E2);
   #endif
-  #if AXIS_DRIVER_TYPE(E3, L6470)
+  #if AXIS_DRIVER_TYPE_E3(L6470)
     _L6470_DEFINE(E3);
   #endif
-  #if AXIS_DRIVER_TYPE(E4, L6470)
+  #if AXIS_DRIVER_TYPE_E4(L6470)
     _L6470_DEFINE(E4);
   #endif
-  #if AXIS_DRIVER_TYPE(E5, L6470)
+  #if AXIS_DRIVER_TYPE_E5(L6470)
     _L6470_DEFINE(E5);
   #endif
 
-  #define _L6470_INIT(A) do{ \
-    stepper##A.init(); \
-    stepper##A.softFree(); \
-    stepper##A.setMicroSteps(A##_MICROSTEPS); \
-    stepper##A.setOverCurrent(A##_OVERCURRENT); \
-    stepper##A.setStallCurrent(A##_STALLCURRENT); \
+  // not using L6470 library's init command because it
+  // briefly sends power to the steppers
+
+  #define _L6470_INIT_CHIP(Q) do{                             \
+    stepper##Q.resetDev();                                    \
+    stepper##Q.softFree();                                    \
+    stepper##Q.SetParam(L6470_CONFIG, CONFIG_PWM_DIV_1        \
+                                    | CONFIG_PWM_MUL_2        \
+                                    | CONFIG_SR_290V_us       \
+                                    | CONFIG_OC_SD_DISABLE    \
+                                    | CONFIG_VS_COMP_DISABLE  \
+                                    | CONFIG_SW_HARD_STOP     \
+                                    | CONFIG_INT_16MHZ);      \
+    stepper##Q.SetParam(L6470_KVAL_RUN, 0xFF);                \
+    stepper##Q.SetParam(L6470_KVAL_ACC, 0xFF);                \
+    stepper##Q.SetParam(L6470_KVAL_DEC, 0xFF);                \
+    stepper##Q.setMicroSteps(Q##_MICROSTEPS);                 \
+    stepper##Q.setOverCurrent(Q##_OVERCURRENT);               \
+    stepper##Q.setStallCurrent(Q##_STALLCURRENT);             \
+    stepper##Q.SetParam(L6470_KVAL_HOLD, Q##_MAX_VOLTAGE);    \
+    stepper##Q.SetParam(L6470_ABS_POS, 0);                    \
+    stepper##Q.getStatus();                                   \
   }while(0)
 
-  void L6470_init_to_defaults() {
-    #if AXIS_DRIVER_TYPE(X, L6470)
-      _L6470_INIT(X);
+  void L6470_Marlin::init_to_defaults() {
+    #if AXIS_DRIVER_TYPE_X(L6470)
+      _L6470_INIT_CHIP(X);
     #endif
-    #if AXIS_DRIVER_TYPE(X2, L6470)
-      _L6470_INIT(X2);
+    #if AXIS_DRIVER_TYPE_X2(L6470)
+      _L6470_INIT_CHIP(X2);
     #endif
-    #if AXIS_DRIVER_TYPE(Y, L6470)
-      _L6470_INIT(Y);
+    #if AXIS_DRIVER_TYPE_Y(L6470)
+      _L6470_INIT_CHIP(Y);
     #endif
-    #if AXIS_DRIVER_TYPE(Y2, L6470)
-      _L6470_INIT(Y2);
+    #if AXIS_DRIVER_TYPE_Y2(L6470)
+      _L6470_INIT_CHIP(Y2);
     #endif
-    #if AXIS_DRIVER_TYPE(Z, L6470)
-      _L6470_INIT(Z);
+    #if AXIS_DRIVER_TYPE_Z(L6470)
+      _L6470_INIT_CHIP(Z);
     #endif
-    #if AXIS_DRIVER_TYPE(Z2, L6470)
-      _L6470_INIT(Z2);
+    #if AXIS_DRIVER_TYPE_Z2(L6470)
+      _L6470_INIT_CHIP(Z2);
     #endif
-    #if AXIS_DRIVER_TYPE(Z3, L6470)
-      _L6470_INIT(Z3);
+    #if AXIS_DRIVER_TYPE_Z3(L6470)
+      _L6470_INIT_CHIP(Z3);
     #endif
-    #if AXIS_DRIVER_TYPE(E0, L6470)
-      _L6470_INIT(E0);
+    #if AXIS_DRIVER_TYPE_E0(L6470)
+      _L6470_INIT_CHIP(E0);
     #endif
-    #if AXIS_DRIVER_TYPE(E1, L6470)
-      _L6470_INIT(E1);
+    #if AXIS_DRIVER_TYPE_E1(L6470)
+      _L6470_INIT_CHIP(E1);
     #endif
-    #if AXIS_DRIVER_TYPE(E2, L6470)
-      _L6470_INIT(E2);
+    #if AXIS_DRIVER_TYPE_E2(L6470)
+      _L6470_INIT_CHIP(E2);
     #endif
-    #if AXIS_DRIVER_TYPE(E3, L6470)
-      _L6470_INIT(E3);
+    #if AXIS_DRIVER_TYPE_E3(L6470)
+      _L6470_INIT_CHIP(E3);
     #endif
-    #if AXIS_DRIVER_TYPE(E4, L6470)
-      _L6470_INIT(E4);
+    #if AXIS_DRIVER_TYPE_E4(L6470)
+      _L6470_INIT_CHIP(E4);
     #endif
-    #if AXIS_DRIVER_TYPE(E5, L6470)
-      _L6470_INIT(E5);
+    #if AXIS_DRIVER_TYPE_E5(L6470)
+      _L6470_INIT_CHIP(E5);
     #endif
   }
 

commit 8a3f1d693281b11c957ff4d213bc28d666eaeebd
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sun Jan 20 02:57:02 2019 +0200

    Fix chopper timing struct and initialization (#12943)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index fe07d554b2..74d5aa0c12 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -209,8 +209,8 @@
     chopconf.tbl = 1;
     chopconf.toff = chopper_timing.toff;
     chopconf.intpol = INTERPOLATE;
-    chopconf.hend = chopper_timing.hstrt + 3;
-    chopconf.hstrt = chopper_timing.hend - 1;
+    chopconf.hend = chopper_timing.hend + 3;
+    chopconf.hstrt = chopper_timing.hstrt - 1;
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);
@@ -453,8 +453,8 @@
     chopconf.tbl = 0b01; // blank_time = 24
     chopconf.toff = chopper_timing.toff;
     chopconf.intpol = INTERPOLATE;
-    chopconf.hend = chopper_timing.hstrt + 3;
-    chopconf.hstrt = chopper_timing.hend - 1;
+    chopconf.hend = chopper_timing.hend + 3;
+    chopconf.hstrt = chopper_timing.hstrt - 1;
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);
@@ -546,8 +546,8 @@
     TMC2660_n::CHOPCONF_t chopconf{0};
     chopconf.tbl = 1;
     chopconf.toff = chopper_timing.toff;
-    chopconf.hend = chopper_timing.hstrt + 3;
-    chopconf.hstrt = chopper_timing.hend - 1;
+    chopconf.hend = chopper_timing.hend + 3;
+    chopconf.hstrt = chopper_timing.hstrt - 1;
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA);

commit e6805582a67b106691423a35ab580bd6b0895949
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Thu Jan 17 21:17:16 2019 +0200

    M569 to change stepping mode. Add new TMC section to LCD. (#12884)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 248582ce95..fe07d554b2 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -205,14 +205,12 @@
   void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm, const bool stealth) {
     st.begin();
 
-    static constexpr int8_t timings[] = CHOPPER_TIMING; // Default 4, -2, 1
-
     CHOPCONF_t chopconf{0};
     chopconf.tbl = 1;
-    chopconf.toff = timings[0];
+    chopconf.toff = chopper_timing.toff;
     chopconf.intpol = INTERPOLATE;
-    chopconf.hend = timings[1] + 3;
-    chopconf.hstrt = timings[2] - 1;
+    chopconf.hend = chopper_timing.hstrt + 3;
+    chopconf.hstrt = chopper_timing.hend - 1;
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);
@@ -221,6 +219,7 @@
     st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
 
     st.en_pwm_mode(stealth);
+    st.stored.stealthChop_enabled = stealth;
 
     PWMCONF_t pwmconf{0};
     pwmconf.pwm_freq = 0b01; // f_pwm = 2/683 f_clk
@@ -442,21 +441,20 @@
 
   template<char AXIS_LETTER, char DRIVER_ID>
   void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm, const bool stealth) {
-    static constexpr int8_t timings[] = CHOPPER_TIMING; // Default 4, -2, 1
-
     TMC2208_n::GCONF_t gconf{0};
     gconf.pdn_disable = true; // Use UART
     gconf.mstep_reg_select = true; // Select microsteps with UART
     gconf.i_scale_analog = false;
     gconf.en_spreadcycle = !stealth;
     st.GCONF(gconf.sr);
+    st.stored.stealthChop_enabled = stealth;
 
     TMC2208_n::CHOPCONF_t chopconf{0};
     chopconf.tbl = 0b01; // blank_time = 24
-    chopconf.toff = timings[0];
+    chopconf.toff = chopper_timing.toff;
     chopconf.intpol = INTERPOLATE;
-    chopconf.hend = timings[1] + 3;
-    chopconf.hstrt = timings[2] - 1;
+    chopconf.hend = chopper_timing.hstrt + 3;
+    chopconf.hstrt = chopper_timing.hend - 1;
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);
@@ -545,13 +543,11 @@
   void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const float, const bool) {
     st.begin();
 
-    static constexpr int8_t timings[] = CHOPPER_TIMING; // Default 4, -2, 1
-
     TMC2660_n::CHOPCONF_t chopconf{0};
     chopconf.tbl = 1;
-    chopconf.toff = timings[0];
-    chopconf.hend = timings[1] + 3;
-    chopconf.hstrt = timings[2] - 1;
+    chopconf.toff = chopper_timing.toff;
+    chopconf.hend = chopper_timing.hstrt + 3;
+    chopconf.hstrt = chopper_timing.hend - 1;
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA);

commit 55144284c2578dccca7a6a5fa472a3d927ff09f2
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Mon Dec 10 04:54:48 2018 +0200

    TMC connection test, spreadCycle parameters, improved debugging (#12616)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index b64e646379..248582ce95 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -205,12 +205,14 @@
   void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm, const bool stealth) {
     st.begin();
 
+    static constexpr int8_t timings[] = CHOPPER_TIMING; // Default 4, -2, 1
+
     CHOPCONF_t chopconf{0};
     chopconf.tbl = 1;
-    chopconf.toff = 3;
+    chopconf.toff = timings[0];
     chopconf.intpol = INTERPOLATE;
-    chopconf.hstrt = 2;
-    chopconf.hend = 5;
+    chopconf.hend = timings[1] + 3;
+    chopconf.hstrt = timings[2] - 1;
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);
@@ -440,6 +442,8 @@
 
   template<char AXIS_LETTER, char DRIVER_ID>
   void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm, const bool stealth) {
+    static constexpr int8_t timings[] = CHOPPER_TIMING; // Default 4, -2, 1
+
     TMC2208_n::GCONF_t gconf{0};
     gconf.pdn_disable = true; // Use UART
     gconf.mstep_reg_select = true; // Select microsteps with UART
@@ -449,10 +453,10 @@
 
     TMC2208_n::CHOPCONF_t chopconf{0};
     chopconf.tbl = 0b01; // blank_time = 24
-    chopconf.toff = 5;
+    chopconf.toff = timings[0];
     chopconf.intpol = INTERPOLATE;
-    chopconf.hstrt = 2;
-    chopconf.hend = 5;
+    chopconf.hend = timings[1] + 3;
+    chopconf.hstrt = timings[2] - 1;
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);
@@ -540,13 +544,20 @@
   template<char AXIS_LETTER, char DRIVER_ID>
   void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const float, const bool) {
     st.begin();
+
+    static constexpr int8_t timings[] = CHOPPER_TIMING; // Default 4, -2, 1
+
+    TMC2660_n::CHOPCONF_t chopconf{0};
+    chopconf.tbl = 1;
+    chopconf.toff = timings[0];
+    chopconf.hend = timings[1] + 3;
+    chopconf.hstrt = timings[2] - 1;
+    st.CHOPCONF(chopconf.sr);
+
     st.rms_current(mA);
     st.microsteps(microsteps);
-    st.blank_time(24);
-    st.toff(5); // Only enables the driver if used with stealthChop
     st.intpol(INTERPOLATE);
-    //st.hysteresis_start(3);
-    //st.hysteresis_end(2);
+    st.diss2g(true); // Disable short to ground protection. Too many false readings?
   }
 #endif // TMC2660
 

commit 50b2fbd03140d21076b8dd3015219ffed0f761c9
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 7 23:34:21 2018 +0200

    Trinamic: Split stealthChop, improve driver monitoring, etc. (#12582)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index bf0cb7f681..b64e646379 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -140,7 +140,8 @@
 #endif // TMC26X
 
 #if HAS_TRINAMIC
-  #define _TMC_INIT(ST, SPMM) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, SPMM)
+  enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
+  #define _TMC_INIT(ST, SPMM_INDEX, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, planner.settings.axis_steps_per_mm[SPMM_INDEX], stealthchop_by_axis[STEALTH_INDEX])
 #endif
 
 //
@@ -201,11 +202,7 @@
   #endif
 
   template<char AXIS_LETTER, char DRIVER_ID>
-  void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm) {
-    #if DISABLED(STEALTHCHOP) || DISABLED(HYBRID_THRESHOLD)
-      UNUSED(thrs);
-      UNUSED(spmm);
-    #endif
+  void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm, const bool stealth) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
@@ -221,20 +218,22 @@
     st.iholddelay(10);
     st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
 
-    #if ENABLED(STEALTHCHOP)
-      st.en_pwm_mode(true);
+    st.en_pwm_mode(stealth);
 
-      PWMCONF_t pwmconf{0};
-      pwmconf.pwm_freq = 0b01; // f_pwm = 2/683 f_clk
-      pwmconf.pwm_autoscale = true;
-      pwmconf.pwm_grad = 5;
-      pwmconf.pwm_ampl = 180;
-      st.PWMCONF(pwmconf.sr);
+    PWMCONF_t pwmconf{0};
+    pwmconf.pwm_freq = 0b01; // f_pwm = 2/683 f_clk
+    pwmconf.pwm_autoscale = true;
+    pwmconf.pwm_grad = 5;
+    pwmconf.pwm_ampl = 180;
+    st.PWMCONF(pwmconf.sr);
 
-      #if ENABLED(HYBRID_THRESHOLD)
-        st.TPWMTHRS(12650000UL*microsteps/(256*thrs*spmm));
-      #endif
+    #if ENABLED(HYBRID_THRESHOLD)
+      st.TPWMTHRS(12650000UL*microsteps/(256*thrs*spmm));
+    #else
+      UNUSED(thrs);
+      UNUSED(spmm);
     #endif
+
     st.GSTAT(); // Clear GSTAT
   }
 #endif // TMC2130
@@ -440,16 +439,13 @@
   }
 
   template<char AXIS_LETTER, char DRIVER_ID>
-  void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm) {
-    #if DISABLED(STEALTHCHOP) || DISABLED(HYBRID_THRESHOLD)
-      UNUSED(thrs);
-      UNUSED(spmm);
-    #endif
-
+  void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm, const bool stealth) {
     TMC2208_n::GCONF_t gconf{0};
     gconf.pdn_disable = true; // Use UART
     gconf.mstep_reg_select = true; // Select microsteps with UART
     gconf.i_scale_analog = false;
+    gconf.en_spreadcycle = !stealth;
+    st.GCONF(gconf.sr);
 
     TMC2208_n::CHOPCONF_t chopconf{0};
     chopconf.tbl = 0b01; // blank_time = 24
@@ -463,25 +459,24 @@
     st.microsteps(microsteps);
     st.iholddelay(10);
     st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
-    #if ENABLED(STEALTHCHOP)
-      gconf.en_spreadcycle = false;
-
-      TMC2208_n::PWMCONF_t pwmconf{0};
-      pwmconf.pwm_lim = 12;
-      pwmconf.pwm_reg = 8;
-      pwmconf.pwm_autograd = true;
-      pwmconf.pwm_autoscale = true;
-      pwmconf.pwm_freq = 0b01;
-      pwmconf.pwm_grad = 14;
-      pwmconf.pwm_ofs = 36;
-      st.PWMCONF(pwmconf.sr);
-      #if ENABLED(HYBRID_THRESHOLD)
-        st.TPWMTHRS(12650000UL*microsteps/(256*thrs*spmm));
-      #endif
+
+    TMC2208_n::PWMCONF_t pwmconf{0};
+    pwmconf.pwm_lim = 12;
+    pwmconf.pwm_reg = 8;
+    pwmconf.pwm_autograd = true;
+    pwmconf.pwm_autoscale = true;
+    pwmconf.pwm_freq = 0b01;
+    pwmconf.pwm_grad = 14;
+    pwmconf.pwm_ofs = 36;
+    st.PWMCONF(pwmconf.sr);
+
+    #if ENABLED(HYBRID_THRESHOLD)
+      st.TPWMTHRS(12650000UL*microsteps/(256*thrs*spmm));
     #else
-      gconf.en_spreadcycle = true;
+      UNUSED(thrs);
+      UNUSED(spmm);
     #endif
-    st.GCONF(gconf.sr);
+
     st.GSTAT(0b111); // Clear
     delay(200);
   }
@@ -543,7 +538,7 @@
   #endif
 
   template<char AXIS_LETTER, char DRIVER_ID>
-  void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const float) {
+  void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const float, const bool) {
     st.begin();
     st.rms_current(mA);
     st.microsteps(microsteps);
@@ -605,44 +600,66 @@ void reset_stepper_drivers() {
     L6470_init_to_defaults();
   #endif
 
+  #if HAS_TRINAMIC
+    static constexpr bool stealthchop_by_axis[] = {
+      #if ENABLED(STEALTHCHOP_XY)
+        true
+      #else
+        false
+      #endif
+      ,
+      #if ENABLED(STEALTHCHOP_Z)
+        true
+      #else
+        false
+      #endif
+      ,
+      #if ENABLED(STEALTHCHOP_E)
+        true
+      #else
+        false
+      #endif
+    };
+  #endif
+
   #if AXIS_IS_TMC(X)
-    _TMC_INIT(X, planner.settings.axis_steps_per_mm[X_AXIS]);
+    _TMC_INIT(X, X_AXIS, STEALTH_AXIS_XY);
   #endif
   #if AXIS_IS_TMC(X2)
-    _TMC_INIT(X2, planner.settings.axis_steps_per_mm[X_AXIS]);
+    _TMC_INIT(X2, X_AXIS, STEALTH_AXIS_XY);
   #endif
   #if AXIS_IS_TMC(Y)
-    _TMC_INIT(Y, planner.settings.axis_steps_per_mm[Y_AXIS]);
+    _TMC_INIT(Y, Y_AXIS, STEALTH_AXIS_XY);
   #endif
   #if AXIS_IS_TMC(Y2)
-    _TMC_INIT(Y2, planner.settings.axis_steps_per_mm[Y_AXIS]);
+    _TMC_INIT(Y2, Y_AXIS, STEALTH_AXIS_XY);
   #endif
   #if AXIS_IS_TMC(Z)
-    _TMC_INIT(Z, planner.settings.axis_steps_per_mm[Z_AXIS]);
+    _TMC_INIT(Z, Z_AXIS, STEALTH_AXIS_Z);
   #endif
   #if AXIS_IS_TMC(Z2)
-    _TMC_INIT(Z2, planner.settings.axis_steps_per_mm[Z_AXIS]);
+    _TMC_INIT(Z2, Z_AXIS, STEALTH_AXIS_Z);
   #endif
   #if AXIS_IS_TMC(Z3)
-    _TMC_INIT(Z3, planner.settings.axis_steps_per_mm[Z_AXIS]);
+    _TMC_INIT(Z3, Z_AXIS, STEALTH_AXIS_Z);
   #endif
   #if AXIS_IS_TMC(E0)
-    _TMC_INIT(E0, planner.settings.axis_steps_per_mm[E_AXIS_N(0)]);
+    _TMC_INIT(E0, E_AXIS, STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E1)
-    _TMC_INIT(E1, planner.settings.axis_steps_per_mm[E_AXIS_N(1)]);
+    _TMC_INIT(E1, E_AXIS_N(1), STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E2)
-    _TMC_INIT(E2, planner.settings.axis_steps_per_mm[E_AXIS_N(2)]);
+    _TMC_INIT(E2, E_AXIS_N(2), STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E3)
-    _TMC_INIT(E3, planner.settings.axis_steps_per_mm[E_AXIS_N(3)]);
+    _TMC_INIT(E3, E_AXIS_N(3), STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E4)
-    _TMC_INIT(E4, planner.settings.axis_steps_per_mm[E_AXIS_N(4)]);
+    _TMC_INIT(E4, E_AXIS_N(4), STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E5)
-    _TMC_INIT(E5, planner.settings.axis_steps_per_mm[E_AXIS_N(5)]);
+    _TMC_INIT(E5, E_AXIS_N(5), STEALTH_AXIS_E);
   #endif
 
   #if USE_SENSORLESS

commit d556dc18650e2185791834d7fe70b4acf45254bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 10 09:45:20 2018 -0500

    Fix and improve EEPROM storage (#12054)
    
    * Clean up Temperature PID
    * Improve EEPROM read/write/validate
    * Group `SINGLENOZZLE` saved settings
    * Group planner saved settings
    * Group filament change saved settings
    * Group skew saved settings
    * Group `FWRETRACT` saved settings

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index d0e829624a..bf0cb7f681 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -606,43 +606,43 @@ void reset_stepper_drivers() {
   #endif
 
   #if AXIS_IS_TMC(X)
-    _TMC_INIT(X, planner.axis_steps_per_mm[X_AXIS]);
+    _TMC_INIT(X, planner.settings.axis_steps_per_mm[X_AXIS]);
   #endif
   #if AXIS_IS_TMC(X2)
-    _TMC_INIT(X2, planner.axis_steps_per_mm[X_AXIS]);
+    _TMC_INIT(X2, planner.settings.axis_steps_per_mm[X_AXIS]);
   #endif
   #if AXIS_IS_TMC(Y)
-    _TMC_INIT(Y, planner.axis_steps_per_mm[Y_AXIS]);
+    _TMC_INIT(Y, planner.settings.axis_steps_per_mm[Y_AXIS]);
   #endif
   #if AXIS_IS_TMC(Y2)
-    _TMC_INIT(Y2, planner.axis_steps_per_mm[Y_AXIS]);
+    _TMC_INIT(Y2, planner.settings.axis_steps_per_mm[Y_AXIS]);
   #endif
   #if AXIS_IS_TMC(Z)
-    _TMC_INIT(Z, planner.axis_steps_per_mm[Z_AXIS]);
+    _TMC_INIT(Z, planner.settings.axis_steps_per_mm[Z_AXIS]);
   #endif
   #if AXIS_IS_TMC(Z2)
-    _TMC_INIT(Z2, planner.axis_steps_per_mm[Z_AXIS]);
+    _TMC_INIT(Z2, planner.settings.axis_steps_per_mm[Z_AXIS]);
   #endif
   #if AXIS_IS_TMC(Z3)
-    _TMC_INIT(Z3, planner.axis_steps_per_mm[Z_AXIS]);
+    _TMC_INIT(Z3, planner.settings.axis_steps_per_mm[Z_AXIS]);
   #endif
   #if AXIS_IS_TMC(E0)
-    _TMC_INIT(E0, planner.axis_steps_per_mm[E_AXIS_N(0)]);
+    _TMC_INIT(E0, planner.settings.axis_steps_per_mm[E_AXIS_N(0)]);
   #endif
   #if AXIS_IS_TMC(E1)
-    _TMC_INIT(E1, planner.axis_steps_per_mm[E_AXIS_N(1)]);
+    _TMC_INIT(E1, planner.settings.axis_steps_per_mm[E_AXIS_N(1)]);
   #endif
   #if AXIS_IS_TMC(E2)
-    _TMC_INIT(E2, planner.axis_steps_per_mm[E_AXIS_N(2)]);
+    _TMC_INIT(E2, planner.settings.axis_steps_per_mm[E_AXIS_N(2)]);
   #endif
   #if AXIS_IS_TMC(E3)
-    _TMC_INIT(E3, planner.axis_steps_per_mm[E_AXIS_N(3)]);
+    _TMC_INIT(E3, planner.settings.axis_steps_per_mm[E_AXIS_N(3)]);
   #endif
   #if AXIS_IS_TMC(E4)
-    _TMC_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N(4)]);
+    _TMC_INIT(E4, planner.settings.axis_steps_per_mm[E_AXIS_N(4)]);
   #endif
   #if AXIS_IS_TMC(E5)
-    _TMC_INIT(E5, planner.axis_steps_per_mm[E_AXIS_N(5)]);
+    _TMC_INIT(E5, planner.settings.axis_steps_per_mm[E_AXIS_N(5)]);
   #endif
 
   #if USE_SENSORLESS

commit 7db0113b53632946ad85836b309190ae2d98f9c4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 7 18:19:52 2018 -0500

    Improve E_AXIS_N macro

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 084a6c7e46..d0e829624a 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -627,22 +627,22 @@ void reset_stepper_drivers() {
     _TMC_INIT(Z3, planner.axis_steps_per_mm[Z_AXIS]);
   #endif
   #if AXIS_IS_TMC(E0)
-    _TMC_INIT(E0, planner.axis_steps_per_mm[E_AXIS]);
+    _TMC_INIT(E0, planner.axis_steps_per_mm[E_AXIS_N(0)]);
   #endif
   #if AXIS_IS_TMC(E1)
-    { constexpr uint8_t extruder = 1; _TMC_INIT(E1, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
+    _TMC_INIT(E1, planner.axis_steps_per_mm[E_AXIS_N(1)]);
   #endif
   #if AXIS_IS_TMC(E2)
-    { constexpr uint8_t extruder = 2; _TMC_INIT(E2, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
+    _TMC_INIT(E2, planner.axis_steps_per_mm[E_AXIS_N(2)]);
   #endif
   #if AXIS_IS_TMC(E3)
-    { constexpr uint8_t extruder = 3; _TMC_INIT(E3, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
+    _TMC_INIT(E3, planner.axis_steps_per_mm[E_AXIS_N(3)]);
   #endif
   #if AXIS_IS_TMC(E4)
-    { constexpr uint8_t extruder = 4; _TMC_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
+    _TMC_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N(4)]);
   #endif
   #if AXIS_IS_TMC(E5)
-    { constexpr uint8_t extruder = 5; _TMC_INIT(E5, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
+    _TMC_INIT(E5, planner.axis_steps_per_mm[E_AXIS_N(5)]);
   #endif
 
   #if USE_SENSORLESS

commit dffb4c63dca4da7f2c248cdace62c475479ca117
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sun Oct 7 23:37:44 2018 +0300

    [2.0.x] TMC2660 followup (#12029)
    
    * Don't react to s2g on TMC2660. False positives
    * Init with sensorless probing as well

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index ebf84453df..084a6c7e46 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -645,7 +645,7 @@ void reset_stepper_drivers() {
     { constexpr uint8_t extruder = 5; _TMC_INIT(E5, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
   #endif
 
-  #if ENABLED(SENSORLESS_HOMING)
+  #if USE_SENSORLESS
     #if X_SENSORLESS
       #if AXIS_HAS_STALLGUARD(X)
         stepperX.sgt(X_STALL_SENSITIVITY);

commit c447d759167bb118c2f26febdae71dd60c64977a
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sun Oct 7 01:18:10 2018 +0300

    Add support for TMC2660 (#11998)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index c6b641e933..ebf84453df 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -487,6 +487,74 @@
   }
 #endif // TMC2208
 
+//
+// TMC2660 Driver objects and inits
+//
+#if HAS_DRIVER(TMC2660)
+
+  #include <SPI.h>
+  #include "planner.h"
+  #include "../core/enum.h"
+
+  #if ENABLED(TMC_USE_SW_SPI)
+    #define _TMC2660_DEFINE(ST, L) TMCMarlin<TMC2660Stepper, L> stepper##ST(ST##_CS_PIN, R_SENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
+    #define TMC2660_DEFINE(ST) _TMC2660_DEFINE(ST, TMC_##ST##_LABEL)
+  #else
+    #define _TMC2660_DEFINE(ST, L) TMCMarlin<TMC2660Stepper, L> stepper##ST(ST##_CS_PIN, R_SENSE)
+    #define TMC2660_DEFINE(ST) _TMC2660_DEFINE(ST, TMC_##ST##_LABEL)
+  #endif
+
+  // Stepper objects of TMC2660 steppers used
+  #if AXIS_DRIVER_TYPE(X, TMC2660)
+    TMC2660_DEFINE(X);
+  #endif
+  #if AXIS_DRIVER_TYPE(X2, TMC2660)
+    TMC2660_DEFINE(X2);
+  #endif
+  #if AXIS_DRIVER_TYPE(Y, TMC2660)
+    TMC2660_DEFINE(Y);
+  #endif
+  #if AXIS_DRIVER_TYPE(Y2, TMC2660)
+    TMC2660_DEFINE(Y2);
+  #endif
+  #if AXIS_DRIVER_TYPE(Z, TMC2660)
+    TMC2660_DEFINE(Z);
+  #endif
+  #if AXIS_DRIVER_TYPE(Z2, TMC2660)
+    TMC2660_DEFINE(Z2);
+  #endif
+  #if AXIS_DRIVER_TYPE(E0, TMC2660)
+    TMC2660_DEFINE(E0);
+  #endif
+  #if AXIS_DRIVER_TYPE(E1, TMC2660)
+    TMC2660_DEFINE(E1);
+  #endif
+  #if AXIS_DRIVER_TYPE(E2, TMC2660)
+    TMC2660_DEFINE(E2);
+  #endif
+  #if AXIS_DRIVER_TYPE(E3, TMC2660)
+    TMC2660_DEFINE(E3);
+  #endif
+  #if AXIS_DRIVER_TYPE(E4, TMC2660)
+    TMC2660_DEFINE(E4);
+  #endif
+  #if AXIS_DRIVER_TYPE(E5, TMC2660)
+    TMC2660_DEFINE(E5);
+  #endif
+
+  template<char AXIS_LETTER, char DRIVER_ID>
+  void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const float) {
+    st.begin();
+    st.rms_current(mA);
+    st.microsteps(microsteps);
+    st.blank_time(24);
+    st.toff(5); // Only enables the driver if used with stealthChop
+    st.intpol(INTERPOLATE);
+    //st.hysteresis_start(3);
+    //st.hysteresis_end(2);
+  }
+#endif // TMC2660
+
 void restore_stepper_drivers() {
   #if AXIS_IS_TMC(X)
     stepperX.push();

commit c3229e1b3461b6da8373e7a24a7eeb131912a15b
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Wed Oct 3 10:48:49 2018 +0300

    Migrate to a new TMC library (#11943)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 86cd7c3832..c6b641e933 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -139,170 +139,103 @@
   }
 #endif // TMC26X
 
+#if HAS_TRINAMIC
+  #define _TMC_INIT(ST, SPMM) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, SPMM)
+#endif
+
 //
 // TMC2130 Driver objects and inits
 //
 #if HAS_DRIVER(TMC2130)
 
   #include <SPI.h>
-  #include <TMC2130Stepper.h>
   #include "planner.h"
   #include "../core/enum.h"
 
-  #if TMC2130STEPPER_VERSION < 0x020201
-    #error "Update TMC2130Stepper library to 2.2.1 or newer."
-  #endif
-
   #if ENABLED(TMC_USE_SW_SPI)
-    #define _TMC2130_DEFINE(ST) TMC2130Stepper stepper##ST(ST##_ENABLE_PIN, ST##_DIR_PIN, ST##_STEP_PIN, ST##_CS_PIN, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
+    #define _TMC2130_DEFINE(ST, L) TMCMarlin<TMC2130Stepper, L> stepper##ST(ST##_CS_PIN, R_SENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
+    #define TMC2130_DEFINE(ST) _TMC2130_DEFINE(ST, TMC_##ST##_LABEL)
   #else
-    #define _TMC2130_DEFINE(ST) TMC2130Stepper stepper##ST(ST##_ENABLE_PIN, ST##_DIR_PIN, ST##_STEP_PIN, ST##_CS_PIN)
+    #define _TMC2130_DEFINE(ST, L) TMCMarlin<TMC2130Stepper, L> stepper##ST(ST##_CS_PIN, R_SENSE)
+    #define TMC2130_DEFINE(ST) _TMC2130_DEFINE(ST, TMC_##ST##_LABEL)
   #endif
-
   // Stepper objects of TMC2130 steppers used
   #if AXIS_DRIVER_TYPE(X, TMC2130)
-    _TMC2130_DEFINE(X);
+    TMC2130_DEFINE(X);
   #endif
   #if AXIS_DRIVER_TYPE(X2, TMC2130)
-    _TMC2130_DEFINE(X2);
+    TMC2130_DEFINE(X2);
   #endif
   #if AXIS_DRIVER_TYPE(Y, TMC2130)
-    _TMC2130_DEFINE(Y);
+    TMC2130_DEFINE(Y);
   #endif
   #if AXIS_DRIVER_TYPE(Y2, TMC2130)
-    _TMC2130_DEFINE(Y2);
+    TMC2130_DEFINE(Y2);
   #endif
   #if AXIS_DRIVER_TYPE(Z, TMC2130)
-    _TMC2130_DEFINE(Z);
+    TMC2130_DEFINE(Z);
   #endif
   #if AXIS_DRIVER_TYPE(Z2, TMC2130)
-    _TMC2130_DEFINE(Z2);
+    TMC2130_DEFINE(Z2);
   #endif
   #if AXIS_DRIVER_TYPE(Z3, TMC2130)
-    _TMC2130_DEFINE(Z3);
+    TMC2130_DEFINE(Z3);
   #endif
   #if AXIS_DRIVER_TYPE(E0, TMC2130)
-    _TMC2130_DEFINE(E0);
+    TMC2130_DEFINE(E0);
   #endif
   #if AXIS_DRIVER_TYPE(E1, TMC2130)
-    _TMC2130_DEFINE(E1);
+    TMC2130_DEFINE(E1);
   #endif
   #if AXIS_DRIVER_TYPE(E2, TMC2130)
-    _TMC2130_DEFINE(E2);
+    TMC2130_DEFINE(E2);
   #endif
   #if AXIS_DRIVER_TYPE(E3, TMC2130)
-    _TMC2130_DEFINE(E3);
+    TMC2130_DEFINE(E3);
   #endif
   #if AXIS_DRIVER_TYPE(E4, TMC2130)
-    _TMC2130_DEFINE(E4);
+    TMC2130_DEFINE(E4);
   #endif
   #if AXIS_DRIVER_TYPE(E5, TMC2130)
-    _TMC2130_DEFINE(E5);
+    TMC2130_DEFINE(E5);
   #endif
 
-  // Use internal reference voltage for current calculations. This is the default.
-  // Following values from Trinamic's spreadsheet with values for a NEMA17 (42BYGHW609)
-  // https://www.trinamic.com/products/integrated-circuits/details/tmc2130/
-  void tmc2130_init(TMC2130Stepper &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm) {
+  template<char AXIS_LETTER, char DRIVER_ID>
+  void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm) {
     #if DISABLED(STEALTHCHOP) || DISABLED(HYBRID_THRESHOLD)
       UNUSED(thrs);
       UNUSED(spmm);
     #endif
     st.begin();
-    st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
+
+    CHOPCONF_t chopconf{0};
+    chopconf.tbl = 1;
+    chopconf.toff = 3;
+    chopconf.intpol = INTERPOLATE;
+    chopconf.hstrt = 2;
+    chopconf.hend = 5;
+    st.CHOPCONF(chopconf.sr);
+
+    st.rms_current(mA, HOLD_MULTIPLIER);
     st.microsteps(microsteps);
-    st.blank_time(24);
-    st.off_time(5); // Only enables the driver if used with stealthChop
-    st.interpolate(INTERPOLATE);
-    st.power_down_delay(128); // ~2s until driver lowers to hold current
-    st.hysteresis_start(3);
-    st.hysteresis_end(2);
+    st.iholddelay(10);
+    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
+
     #if ENABLED(STEALTHCHOP)
-      st.stealth_freq(1); // f_pwm = 2/683 f_clk
-      st.stealth_autoscale(1);
-      st.stealth_gradient(5);
-      st.stealth_amplitude(255);
-      st.stealthChop(1);
-      #if ENABLED(HYBRID_THRESHOLD)
-        st.stealth_max_speed(12650000UL*microsteps/(256*thrs*spmm));
-      #endif
-    #endif
-    st.GSTAT(); // Clear GSTAT
-  }
+      st.en_pwm_mode(true);
 
-  #define _TMC2130_INIT(ST, SPMM) tmc2130_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, SPMM)
+      PWMCONF_t pwmconf{0};
+      pwmconf.pwm_freq = 0b01; // f_pwm = 2/683 f_clk
+      pwmconf.pwm_autoscale = true;
+      pwmconf.pwm_grad = 5;
+      pwmconf.pwm_ampl = 180;
+      st.PWMCONF(pwmconf.sr);
 
-  void tmc2130_init_to_defaults() {
-    #if AXIS_DRIVER_TYPE(X, TMC2130)
-      _TMC2130_INIT( X, planner.axis_steps_per_mm[X_AXIS]);
-    #endif
-    #if AXIS_DRIVER_TYPE(X2, TMC2130)
-      _TMC2130_INIT(X2, planner.axis_steps_per_mm[X_AXIS]);
-    #endif
-    #if AXIS_DRIVER_TYPE(Y, TMC2130)
-      _TMC2130_INIT( Y, planner.axis_steps_per_mm[Y_AXIS]);
-    #endif
-    #if AXIS_DRIVER_TYPE(Y2, TMC2130)
-      _TMC2130_INIT(Y2, planner.axis_steps_per_mm[Y_AXIS]);
-    #endif
-    #if AXIS_DRIVER_TYPE(Z, TMC2130)
-      _TMC2130_INIT( Z, planner.axis_steps_per_mm[Z_AXIS]);
-    #endif
-    #if AXIS_DRIVER_TYPE(Z2, TMC2130)
-      _TMC2130_INIT(Z2, planner.axis_steps_per_mm[Z_AXIS]);
-    #endif
-    #if AXIS_DRIVER_TYPE(Z3, TMC2130)
-      _TMC2130_INIT(Z3, planner.axis_steps_per_mm[Z_AXIS]);
-    #endif
-    #if AXIS_DRIVER_TYPE(E0, TMC2130)
-      _TMC2130_INIT(E0, planner.axis_steps_per_mm[E_AXIS]);
-    #endif
-    #if AXIS_DRIVER_TYPE(E1, TMC2130)
-      { constexpr uint8_t extruder = 1; _TMC2130_INIT(E1, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
-    #endif
-    #if AXIS_DRIVER_TYPE(E2, TMC2130)
-      { constexpr uint8_t extruder = 2; _TMC2130_INIT(E2, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
-    #endif
-    #if AXIS_DRIVER_TYPE(E3, TMC2130)
-      { constexpr uint8_t extruder = 3; _TMC2130_INIT(E3, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
-    #endif
-    #if AXIS_DRIVER_TYPE(E4, TMC2130)
-      { constexpr uint8_t extruder = 4; _TMC2130_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
-    #endif
-    #if AXIS_DRIVER_TYPE(E5, TMC2130)
-      { constexpr uint8_t extruder = 5; _TMC2130_INIT(E5, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
-    #endif
-
-    #if USE_SENSORLESS
-      #define TMC_INIT_SGT(P,Q) stepper##Q.sgt(P##_STALL_SENSITIVITY);
-      #if X_SENSORLESS
-        #if AXIS_DRIVER_TYPE(X, TMC2130)
-          stepperX.sgt(X_STALL_SENSITIVITY);
-        #endif
-        #if AXIS_DRIVER_TYPE(X2, TMC2130)
-          stepperX2.sgt(X_STALL_SENSITIVITY);
-        #endif
-      #endif
-      #if Y_SENSORLESS
-        #if AXIS_DRIVER_TYPE(Y, TMC2130)
-          stepperY.sgt(Y_STALL_SENSITIVITY);
-        #endif
-        #if AXIS_DRIVER_TYPE(Y2, TMC2130)
-          stepperY2.sgt(Y_STALL_SENSITIVITY);
-        #endif
-      #endif
-      #if Z_SENSORLESS
-        #if AXIS_DRIVER_TYPE(Z, TMC2130)
-          stepperZ.sgt(Z_STALL_SENSITIVITY);
-        #endif
-        #if AXIS_DRIVER_TYPE(Z2, TMC2130)
-          stepperZ2.sgt(Z_STALL_SENSITIVITY);
-        #endif
-        #if ENABLED(Z3_IS_TMC2130)
-          stepperZ3.sgt(Z_STALL_SENSITIVITY);
-        #endif
+      #if ENABLED(HYBRID_THRESHOLD)
+        st.TPWMTHRS(12650000UL*microsteps/(256*thrs*spmm));
       #endif
     #endif
+    st.GSTAT(); // Clear GSTAT
   }
 #endif // TMC2130
 
@@ -311,106 +244,104 @@
 //
 #if HAS_DRIVER(TMC2208)
   #include <HardwareSerial.h>
-  #include <TMC2208Stepper.h>
   #include "planner.h"
 
-  #if TMC2208STEPPER_VERSION < 0x000101
-    #error "Update TMC2208Stepper library to 0.1.1 or newer."
-  #endif
+  #define _TMC2208_DEFINE_HARDWARE(ST, L) TMCMarlin<TMC2208Stepper, L> stepper##ST(&ST##_HARDWARE_SERIAL, R_SENSE)
+  #define TMC2208_DEFINE_HARDWARE(ST) _TMC2208_DEFINE_HARDWARE(ST, TMC_##ST##_LABEL)
 
-  #define _TMC2208_DEFINE_HARDWARE(ST) TMC2208Stepper stepper##ST(&ST##_HARDWARE_SERIAL)
-  #define _TMC2208_DEFINE_SOFTWARE(ST) TMC2208Stepper stepper##ST(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN, ST##_SERIAL_RX_PIN > -1)
+  #define _TMC2208_DEFINE_SOFTWARE(ST, L) TMCMarlin<TMC2208Stepper, L> stepper##ST(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN, R_SENSE, ST##_SERIAL_RX_PIN > -1)
+  #define TMC2208_DEFINE_SOFTWARE(ST) _TMC2208_DEFINE_SOFTWARE(ST, TMC_##ST##_LABEL)
 
   // Stepper objects of TMC2208 steppers used
   #if AXIS_DRIVER_TYPE(X, TMC2208)
     #ifdef X_HARDWARE_SERIAL
-      _TMC2208_DEFINE_HARDWARE(X);
+      TMC2208_DEFINE_HARDWARE(X);
     #else
-      _TMC2208_DEFINE_SOFTWARE(X);
+      TMC2208_DEFINE_SOFTWARE(X);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE(X2, TMC2208)
     #ifdef X2_HARDWARE_SERIAL
-      _TMC2208_DEFINE_HARDWARE(X2);
+      TMC2208_DEFINE_HARDWARE(X2);
     #else
-      _TMC2208_DEFINE_SOFTWARE(X2);
+      TMC2208_DEFINE_SOFTWARE(X2);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE(Y, TMC2208)
     #ifdef Y_HARDWARE_SERIAL
-      _TMC2208_DEFINE_HARDWARE(Y);
+      TMC2208_DEFINE_HARDWARE(Y);
     #else
-      _TMC2208_DEFINE_SOFTWARE(Y);
+      TMC2208_DEFINE_SOFTWARE(Y);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE(Y2, TMC2208)
     #ifdef Y2_HARDWARE_SERIAL
-      _TMC2208_DEFINE_HARDWARE(Y2);
+      TMC2208_DEFINE_HARDWARE(Y2);
     #else
-      _TMC2208_DEFINE_SOFTWARE(Y2);
+      TMC2208_DEFINE_SOFTWARE(Y2);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE(Z, TMC2208)
     #ifdef Z_HARDWARE_SERIAL
-      _TMC2208_DEFINE_HARDWARE(Z);
+      TMC2208_DEFINE_HARDWARE(Z);
     #else
-      _TMC2208_DEFINE_SOFTWARE(Z);
+      TMC2208_DEFINE_SOFTWARE(Z);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE(Z2, TMC2208)
     #ifdef Z2_HARDWARE_SERIAL
-      _TMC2208_DEFINE_HARDWARE(Z2);
+      TMC2208_DEFINE_HARDWARE(Z2);
     #else
-      _TMC2208_DEFINE_SOFTWARE(Z2);
+      TMC2208_DEFINE_SOFTWARE(Z2);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE(Z3, TMC2208)
     #ifdef Z3_HARDWARE_SERIAL
-      _TMC2208_DEFINE_HARDWARE(Z3);
+      TMC2208_DEFINE_HARDWARE(Z3);
     #else
-      _TMC2208_DEFINE_SOFTWARE(Z3);
+      TMC2208_DEFINE_SOFTWARE(Z3);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE(E0, TMC2208)
     #ifdef E0_HARDWARE_SERIAL
-      _TMC2208_DEFINE_HARDWARE(E0);
+      TMC2208_DEFINE_HARDWARE(E0);
     #else
-      _TMC2208_DEFINE_SOFTWARE(E0);
+      TMC2208_DEFINE_SOFTWARE(E0);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE(E1, TMC2208)
     #ifdef E1_HARDWARE_SERIAL
-      _TMC2208_DEFINE_HARDWARE(E1);
+      TMC2208_DEFINE_HARDWARE(E1);
     #else
-      _TMC2208_DEFINE_SOFTWARE(E1);
+      TMC2208_DEFINE_SOFTWARE(E1);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE(E2, TMC2208)
     #ifdef E2_HARDWARE_SERIAL
-      _TMC2208_DEFINE_HARDWARE(E2);
+      TMC2208_DEFINE_HARDWARE(E2);
     #else
-      _TMC2208_DEFINE_SOFTWARE(E2);
+      TMC2208_DEFINE_SOFTWARE(E2);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE(E3, TMC2208)
     #ifdef E3_HARDWARE_SERIAL
-      _TMC2208_DEFINE_HARDWARE(E3);
+      TMC2208_DEFINE_HARDWARE(E3);
     #else
-      _TMC2208_DEFINE_SOFTWARE(E3);
+      TMC2208_DEFINE_SOFTWARE(E3);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE(E4, TMC2208)
     #ifdef E4_HARDWARE_SERIAL
-      _TMC2208_DEFINE_HARDWARE(E4);
+      TMC2208_DEFINE_HARDWARE(E4);
     #else
-      _TMC2208_DEFINE_SOFTWARE(E4);
+      TMC2208_DEFINE_SOFTWARE(E4);
     #endif
   #endif
   #if AXIS_DRIVER_TYPE(E5, TMC2208)
     #ifdef E5_HARDWARE_SERIAL
-      _TMC2208_DEFINE_HARDWARE(E5);
+      TMC2208_DEFINE_HARDWARE(E5);
     #else
-      _TMC2208_DEFINE_SOFTWARE(E5);
+      TMC2208_DEFINE_SOFTWARE(E5);
     #endif
   #endif
 
@@ -508,85 +439,52 @@
     #endif
   }
 
-  // Use internal reference voltage for current calculations. This is the default.
-  // Following values from Trinamic's spreadsheet with values for a NEMA17 (42BYGHW609)
-  void tmc2208_init(TMC2208Stepper &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm) {
-    st.pdn_disable(true); // Use UART
-    st.mstep_reg_select(true); // Select microsteps with UART
-    st.I_scale_analog(false);
-    st.rms_current(mA, HOLD_MULTIPLIER, R_SENSE);
+  template<char AXIS_LETTER, char DRIVER_ID>
+  void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm) {
+    #if DISABLED(STEALTHCHOP) || DISABLED(HYBRID_THRESHOLD)
+      UNUSED(thrs);
+      UNUSED(spmm);
+    #endif
+
+    TMC2208_n::GCONF_t gconf{0};
+    gconf.pdn_disable = true; // Use UART
+    gconf.mstep_reg_select = true; // Select microsteps with UART
+    gconf.i_scale_analog = false;
+
+    TMC2208_n::CHOPCONF_t chopconf{0};
+    chopconf.tbl = 0b01; // blank_time = 24
+    chopconf.toff = 5;
+    chopconf.intpol = INTERPOLATE;
+    chopconf.hstrt = 2;
+    chopconf.hend = 5;
+    st.CHOPCONF(chopconf.sr);
+
+    st.rms_current(mA, HOLD_MULTIPLIER);
     st.microsteps(microsteps);
-    st.blank_time(24);
-    st.toff(5);
-    st.intpol(INTERPOLATE);
+    st.iholddelay(10);
     st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
-    st.hysteresis_start(3);
-    st.hysteresis_end(2);
     #if ENABLED(STEALTHCHOP)
-      st.pwm_lim(12);
-      st.pwm_reg(8);
-      st.pwm_autograd(1);
-      st.pwm_autoscale(1);
-      st.pwm_freq(1);
-      st.pwm_grad(14);
-      st.pwm_ofs(36);
-      st.en_spreadCycle(false);
+      gconf.en_spreadcycle = false;
+
+      TMC2208_n::PWMCONF_t pwmconf{0};
+      pwmconf.pwm_lim = 12;
+      pwmconf.pwm_reg = 8;
+      pwmconf.pwm_autograd = true;
+      pwmconf.pwm_autoscale = true;
+      pwmconf.pwm_freq = 0b01;
+      pwmconf.pwm_grad = 14;
+      pwmconf.pwm_ofs = 36;
+      st.PWMCONF(pwmconf.sr);
       #if ENABLED(HYBRID_THRESHOLD)
         st.TPWMTHRS(12650000UL*microsteps/(256*thrs*spmm));
-      #else
-        UNUSED(thrs);
-        UNUSED(spmm);
       #endif
     #else
-      st.en_spreadCycle(true);
+      gconf.en_spreadcycle = true;
     #endif
+    st.GCONF(gconf.sr);
     st.GSTAT(0b111); // Clear
     delay(200);
   }
-
-  #define _TMC2208_INIT(ST, SPMM) tmc2208_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, SPMM)
-
-  void tmc2208_init_to_defaults() {
-    #if AXIS_DRIVER_TYPE(X, TMC2208)
-      _TMC2208_INIT(X, planner.axis_steps_per_mm[X_AXIS]);
-    #endif
-    #if AXIS_DRIVER_TYPE(X2, TMC2208)
-      _TMC2208_INIT(X2, planner.axis_steps_per_mm[X_AXIS]);
-    #endif
-    #if AXIS_DRIVER_TYPE(Y, TMC2208)
-      _TMC2208_INIT(Y, planner.axis_steps_per_mm[Y_AXIS]);
-    #endif
-    #if AXIS_DRIVER_TYPE(Y2, TMC2208)
-      _TMC2208_INIT(Y2, planner.axis_steps_per_mm[Y_AXIS]);
-    #endif
-    #if AXIS_DRIVER_TYPE(Z, TMC2208)
-      _TMC2208_INIT(Z, planner.axis_steps_per_mm[Z_AXIS]);
-    #endif
-    #if AXIS_DRIVER_TYPE(Z2, TMC2208)
-      _TMC2208_INIT(Z2, planner.axis_steps_per_mm[Z_AXIS]);
-    #endif
-    #if AXIS_DRIVER_TYPE(Z3, TMC2208)
-      _TMC2208_INIT(Z3, planner.axis_steps_per_mm[Z_AXIS]);
-    #endif
-    #if AXIS_DRIVER_TYPE(E0, TMC2208)
-      _TMC2208_INIT(E0, planner.axis_steps_per_mm[E_AXIS]);
-    #endif
-    #if AXIS_DRIVER_TYPE(E1, TMC2208)
-      { constexpr int extruder = 1; _TMC2208_INIT(E1, planner.axis_steps_per_mm[E_AXIS_N]); }
-    #endif
-    #if AXIS_DRIVER_TYPE(E2, TMC2208)
-      { constexpr int extruder = 2; _TMC2208_INIT(E2, planner.axis_steps_per_mm[E_AXIS_N]); }
-    #endif
-    #if AXIS_DRIVER_TYPE(E3, TMC2208)
-      { constexpr int extruder = 3; _TMC2208_INIT(E3, planner.axis_steps_per_mm[E_AXIS_N]); }
-    #endif
-    #if AXIS_DRIVER_TYPE(E4, TMC2208)
-      { constexpr int extruder = 4; _TMC2208_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N]); }
-    #endif
-    #if AXIS_DRIVER_TYPE(E5, TMC2208)
-      { constexpr int extruder = 5; _TMC2208_INIT(E5, planner.axis_steps_per_mm[E_AXIS_N]); }
-    #endif
-  }
 #endif // TMC2208
 
 void restore_stepper_drivers() {
@@ -635,20 +533,84 @@ void reset_stepper_drivers() {
   #if HAS_DRIVER(TMC26X)
     tmc26x_init_to_defaults();
   #endif
-  #if HAS_DRIVER(TMC2130)
-    delay(100);
-    tmc2130_init_to_defaults();
+  #if ENABLED(HAVE_L6470DRIVER)
+    L6470_init_to_defaults();
+  #endif
+
+  #if AXIS_IS_TMC(X)
+    _TMC_INIT(X, planner.axis_steps_per_mm[X_AXIS]);
+  #endif
+  #if AXIS_IS_TMC(X2)
+    _TMC_INIT(X2, planner.axis_steps_per_mm[X_AXIS]);
+  #endif
+  #if AXIS_IS_TMC(Y)
+    _TMC_INIT(Y, planner.axis_steps_per_mm[Y_AXIS]);
+  #endif
+  #if AXIS_IS_TMC(Y2)
+    _TMC_INIT(Y2, planner.axis_steps_per_mm[Y_AXIS]);
+  #endif
+  #if AXIS_IS_TMC(Z)
+    _TMC_INIT(Z, planner.axis_steps_per_mm[Z_AXIS]);
+  #endif
+  #if AXIS_IS_TMC(Z2)
+    _TMC_INIT(Z2, planner.axis_steps_per_mm[Z_AXIS]);
+  #endif
+  #if AXIS_IS_TMC(Z3)
+    _TMC_INIT(Z3, planner.axis_steps_per_mm[Z_AXIS]);
+  #endif
+  #if AXIS_IS_TMC(E0)
+    _TMC_INIT(E0, planner.axis_steps_per_mm[E_AXIS]);
+  #endif
+  #if AXIS_IS_TMC(E1)
+    { constexpr uint8_t extruder = 1; _TMC_INIT(E1, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
+  #endif
+  #if AXIS_IS_TMC(E2)
+    { constexpr uint8_t extruder = 2; _TMC_INIT(E2, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
   #endif
-  #if HAS_DRIVER(TMC2208)
-    delay(100);
-    tmc2208_init_to_defaults();
+  #if AXIS_IS_TMC(E3)
+    { constexpr uint8_t extruder = 3; _TMC_INIT(E3, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
+  #endif
+  #if AXIS_IS_TMC(E4)
+    { constexpr uint8_t extruder = 4; _TMC_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
+  #endif
+  #if AXIS_IS_TMC(E5)
+    { constexpr uint8_t extruder = 5; _TMC_INIT(E5, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
+  #endif
+
+  #if ENABLED(SENSORLESS_HOMING)
+    #if X_SENSORLESS
+      #if AXIS_HAS_STALLGUARD(X)
+        stepperX.sgt(X_STALL_SENSITIVITY);
+      #endif
+      #if AXIS_HAS_STALLGUARD(X2)
+        stepperX2.sgt(X_STALL_SENSITIVITY);
+      #endif
+    #endif
+    #if Y_SENSORLESS
+      #if AXIS_HAS_STALLGUARD(Y)
+        stepperY.sgt(Y_STALL_SENSITIVITY);
+      #endif
+      #if AXIS_HAS_STALLGUARD(Y2)
+        stepperY2.sgt(Y_STALL_SENSITIVITY);
+      #endif
+    #endif
+    #if Z_SENSORLESS
+      #if AXIS_HAS_STALLGUARD(Z)
+        stepperZ.sgt(Z_STALL_SENSITIVITY);
+      #endif
+      #if AXIS_HAS_STALLGUARD(Z2)
+        stepperZ2.sgt(Z_STALL_SENSITIVITY);
+      #endif
+      #if AXIS_HAS_STALLGUARD(Z3)
+        stepperZ3.sgt(Z_STALL_SENSITIVITY);
+      #endif
+    #endif
   #endif
+
   #ifdef TMC_ADV
     TMC_ADV()
   #endif
-  #if HAS_DRIVER(L6470)
-    L6470_init_to_defaults();
-  #endif
+
   stepper.set_directions();
 }
 

commit 3286325044a7788f12ceb3f3d6cef00dc8b32433
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sun Sep 9 15:59:12 2018 -0400

    Add TMC2130 sensorless probing

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 1927cad230..86cd7c3832 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -273,33 +273,33 @@
       { constexpr uint8_t extruder = 5; _TMC2130_INIT(E5, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
     #endif
 
-    #if ENABLED(SENSORLESS_HOMING)
-      #define TMC_INIT_SGT(P,Q) stepper##Q.sgt(P##_HOMING_SENSITIVITY);
+    #if USE_SENSORLESS
+      #define TMC_INIT_SGT(P,Q) stepper##Q.sgt(P##_STALL_SENSITIVITY);
       #if X_SENSORLESS
         #if AXIS_DRIVER_TYPE(X, TMC2130)
-          stepperX.sgt(X_HOMING_SENSITIVITY);
+          stepperX.sgt(X_STALL_SENSITIVITY);
         #endif
         #if AXIS_DRIVER_TYPE(X2, TMC2130)
-          stepperX2.sgt(X_HOMING_SENSITIVITY);
+          stepperX2.sgt(X_STALL_SENSITIVITY);
         #endif
       #endif
       #if Y_SENSORLESS
         #if AXIS_DRIVER_TYPE(Y, TMC2130)
-          stepperY.sgt(Y_HOMING_SENSITIVITY);
+          stepperY.sgt(Y_STALL_SENSITIVITY);
         #endif
         #if AXIS_DRIVER_TYPE(Y2, TMC2130)
-          stepperY2.sgt(Y_HOMING_SENSITIVITY);
+          stepperY2.sgt(Y_STALL_SENSITIVITY);
         #endif
       #endif
       #if Z_SENSORLESS
         #if AXIS_DRIVER_TYPE(Z, TMC2130)
-          stepperZ.sgt(Z_HOMING_SENSITIVITY);
+          stepperZ.sgt(Z_STALL_SENSITIVITY);
         #endif
         #if AXIS_DRIVER_TYPE(Z2, TMC2130)
-          stepperZ2.sgt(Z_HOMING_SENSITIVITY);
+          stepperZ2.sgt(Z_STALL_SENSITIVITY);
         #endif
         #if ENABLED(Z3_IS_TMC2130)
-          stepperZ3.sgt(Z_HOMING_SENSITIVITY);
+          stepperZ3.sgt(Z_STALL_SENSITIVITY);
         #endif
       #endif
     #endif

commit c411e7eb0dd34e3cfefd29b71d9dde152c99304f
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sat Sep 22 10:46:29 2018 -0600

    [2.0.x] Squelch compiler warnings seen with -Wall (#11889)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index e6bd0abf2d..1927cad230 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -258,16 +258,19 @@
       _TMC2130_INIT(E0, planner.axis_steps_per_mm[E_AXIS]);
     #endif
     #if AXIS_DRIVER_TYPE(E1, TMC2130)
-      { constexpr int extruder = 1; _TMC2130_INIT(E1, planner.axis_steps_per_mm[E_AXIS_N]); }
+      { constexpr uint8_t extruder = 1; _TMC2130_INIT(E1, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
     #endif
     #if AXIS_DRIVER_TYPE(E2, TMC2130)
-      { constexpr int extruder = 2; _TMC2130_INIT(E2, planner.axis_steps_per_mm[E_AXIS_N]); }
+      { constexpr uint8_t extruder = 2; _TMC2130_INIT(E2, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
     #endif
     #if AXIS_DRIVER_TYPE(E3, TMC2130)
-      { constexpr int extruder = 3; _TMC2130_INIT(E3, planner.axis_steps_per_mm[E_AXIS_N]); }
+      { constexpr uint8_t extruder = 3; _TMC2130_INIT(E3, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
     #endif
     #if AXIS_DRIVER_TYPE(E4, TMC2130)
-      { constexpr int extruder = 4; _TMC2130_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N]); }
+      { constexpr uint8_t extruder = 4; _TMC2130_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
+    #endif
+    #if AXIS_DRIVER_TYPE(E5, TMC2130)
+      { constexpr uint8_t extruder = 5; _TMC2130_INIT(E5, planner.axis_steps_per_mm[E_AXIS_N]); UNUSED(extruder); }
     #endif
 
     #if ENABLED(SENSORLESS_HOMING)
@@ -580,6 +583,9 @@
     #if AXIS_DRIVER_TYPE(E4, TMC2208)
       { constexpr int extruder = 4; _TMC2208_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
+    #if AXIS_DRIVER_TYPE(E5, TMC2208)
+      { constexpr int extruder = 5; _TMC2208_INIT(E5, planner.axis_steps_per_mm[E_AXIS_N]); }
+    #endif
   }
 #endif // TMC2208
 

commit 53bd0b55cbbba9815eab8e3ad1ec23d3e4370e21
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 16 23:57:50 2018 -0500

    Followup for 6 extruders

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index a0ec490d77..e6bd0abf2d 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -87,6 +87,9 @@
   #if AXIS_DRIVER_TYPE(E4, TMC26X)
     _TMC26X_DEFINE(E4);
   #endif
+  #if AXIS_DRIVER_TYPE(E5, TMC26X)
+    _TMC26X_DEFINE(E5);
+  #endif
 
   #define _TMC26X_INIT(A) do{ \
     stepper##A.setMicrosteps(A##_MICROSTEPS); \
@@ -130,6 +133,9 @@
     #if AXIS_DRIVER_TYPE(E4, TMC26X)
       _TMC26X_INIT(E4);
     #endif
+    #if AXIS_DRIVER_TYPE(E5, TMC26X)
+      _TMC26X_INIT(E5);
+    #endif
   }
 #endif // TMC26X
 
@@ -190,6 +196,9 @@
   #if AXIS_DRIVER_TYPE(E4, TMC2130)
     _TMC2130_DEFINE(E4);
   #endif
+  #if AXIS_DRIVER_TYPE(E5, TMC2130)
+    _TMC2130_DEFINE(E5);
+  #endif
 
   // Use internal reference voltage for current calculations. This is the default.
   // Following values from Trinamic's spreadsheet with values for a NEMA17 (42BYGHW609)
@@ -394,6 +403,13 @@
       _TMC2208_DEFINE_SOFTWARE(E4);
     #endif
   #endif
+  #if AXIS_DRIVER_TYPE(E5, TMC2208)
+    #ifdef E5_HARDWARE_SERIAL
+      _TMC2208_DEFINE_HARDWARE(E5);
+    #else
+      _TMC2208_DEFINE_SOFTWARE(E5);
+    #endif
+  #endif
 
   void tmc2208_serial_begin() {
     #if AXIS_DRIVER_TYPE(X, TMC2208)
@@ -480,6 +496,13 @@
         stepperE4.beginSerial(115200);
       #endif
     #endif
+    #if AXIS_DRIVER_TYPE(E5, TMC2208)
+      #ifdef E5_HARDWARE_SERIAL
+        E5_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperE5.beginSerial(115200);
+      #endif
+    #endif
   }
 
   // Use internal reference voltage for current calculations. This is the default.
@@ -597,6 +620,9 @@ void restore_stepper_drivers() {
   #if AXIS_IS_TMC(E4)
     stepperE4.push();
   #endif
+  #if AXIS_IS_TMC(E5)
+    stepperE5.push();
+  #endif
 }
 
 void reset_stepper_drivers() {
@@ -667,6 +693,9 @@ void reset_stepper_drivers() {
   #if AXIS_DRIVER_TYPE(E4, L6470)
     _L6470_DEFINE(E4);
   #endif
+  #if AXIS_DRIVER_TYPE(E5, L6470)
+    _L6470_DEFINE(E5);
+  #endif
 
   #define _L6470_INIT(A) do{ \
     stepper##A.init(); \
@@ -713,6 +742,9 @@ void reset_stepper_drivers() {
     #if AXIS_DRIVER_TYPE(E4, L6470)
       _L6470_INIT(E4);
     #endif
+    #if AXIS_DRIVER_TYPE(E5, L6470)
+      _L6470_INIT(E5);
+    #endif
   }
 
 #endif // L6470

commit 1a6f2b29b8dd3bc8e6ef56d4f376f49cacfc8785
Author: Holger Muller <holger@mueller-gelff.de>
Date:   Tue Jun 19 18:55:49 2018 +0200

    Add support for Triple-Z steppers/endstops

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 89c4381ca4..a0ec490d77 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -69,6 +69,9 @@
   #if AXIS_DRIVER_TYPE(Z2, TMC26X)
     _TMC26X_DEFINE(Z2);
   #endif
+  #if AXIS_DRIVER_TYPE(Z3, TMC26X)
+    _TMC26X_DEFINE(Z3);
+  #endif
   #if AXIS_DRIVER_TYPE(E0, TMC26X)
     _TMC26X_DEFINE(E0);
   #endif
@@ -109,6 +112,9 @@
     #if AXIS_DRIVER_TYPE(Z2, TMC26X)
       _TMC26X_INIT(Z2);
     #endif
+    #if AXIS_DRIVER_TYPE(Z3, TMC26X)
+      _TMC26X_INIT(Z3);
+    #endif
     #if AXIS_DRIVER_TYPE(E0, TMC26X)
       _TMC26X_INIT(E0);
     #endif
@@ -166,6 +172,9 @@
   #if AXIS_DRIVER_TYPE(Z2, TMC2130)
     _TMC2130_DEFINE(Z2);
   #endif
+  #if AXIS_DRIVER_TYPE(Z3, TMC2130)
+    _TMC2130_DEFINE(Z3);
+  #endif
   #if AXIS_DRIVER_TYPE(E0, TMC2130)
     _TMC2130_DEFINE(E0);
   #endif
@@ -233,6 +242,9 @@
     #if AXIS_DRIVER_TYPE(Z2, TMC2130)
       _TMC2130_INIT(Z2, planner.axis_steps_per_mm[Z_AXIS]);
     #endif
+    #if AXIS_DRIVER_TYPE(Z3, TMC2130)
+      _TMC2130_INIT(Z3, planner.axis_steps_per_mm[Z_AXIS]);
+    #endif
     #if AXIS_DRIVER_TYPE(E0, TMC2130)
       _TMC2130_INIT(E0, planner.axis_steps_per_mm[E_AXIS]);
     #endif
@@ -274,6 +286,9 @@
         #if AXIS_DRIVER_TYPE(Z2, TMC2130)
           stepperZ2.sgt(Z_HOMING_SENSITIVITY);
         #endif
+        #if ENABLED(Z3_IS_TMC2130)
+          stepperZ3.sgt(Z_HOMING_SENSITIVITY);
+        #endif
       #endif
     #endif
   }
@@ -337,6 +352,13 @@
       _TMC2208_DEFINE_SOFTWARE(Z2);
     #endif
   #endif
+  #if AXIS_DRIVER_TYPE(Z3, TMC2208)
+    #ifdef Z3_HARDWARE_SERIAL
+      _TMC2208_DEFINE_HARDWARE(Z3);
+    #else
+      _TMC2208_DEFINE_SOFTWARE(Z3);
+    #endif
+  #endif
   #if AXIS_DRIVER_TYPE(E0, TMC2208)
     #ifdef E0_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(E0);
@@ -416,6 +438,13 @@
         stepperZ2.beginSerial(115200);
       #endif
     #endif
+    #if AXIS_DRIVER_TYPE(Z3, TMC2208)
+      #ifdef Z3_HARDWARE_SERIAL
+        Z3_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperZ3.beginSerial(115200);
+      #endif
+    #endif
     #if AXIS_DRIVER_TYPE(E0, TMC2208)
       #ifdef E0_HARDWARE_SERIAL
         E0_HARDWARE_SERIAL.begin(115200);
@@ -510,6 +539,9 @@
     #if AXIS_DRIVER_TYPE(Z2, TMC2208)
       _TMC2208_INIT(Z2, planner.axis_steps_per_mm[Z_AXIS]);
     #endif
+    #if AXIS_DRIVER_TYPE(Z3, TMC2208)
+      _TMC2208_INIT(Z3, planner.axis_steps_per_mm[Z_AXIS]);
+    #endif
     #if AXIS_DRIVER_TYPE(E0, TMC2208)
       _TMC2208_INIT(E0, planner.axis_steps_per_mm[E_AXIS]);
     #endif
@@ -547,6 +579,9 @@ void restore_stepper_drivers() {
   #if AXIS_IS_TMC(Z2)
     stepperZ2.push();
   #endif
+  #if AXIS_IS_TMC(Z3)
+    stepperZ3.push();
+  #endif
   #if AXIS_IS_TMC(E0)
     stepperE0.push();
   #endif
@@ -614,6 +649,9 @@ void reset_stepper_drivers() {
   #if AXIS_DRIVER_TYPE(Z2, L6470)
     _L6470_DEFINE(Z2);
   #endif
+  #if AXIS_DRIVER_TYPE(Z3, L6470)
+    _L6470_DEFINE(Z3);
+  #endif
   #if AXIS_DRIVER_TYPE(E0, L6470)
     _L6470_DEFINE(E0);
   #endif
@@ -657,6 +695,9 @@ void reset_stepper_drivers() {
     #if AXIS_DRIVER_TYPE(Z2, L6470)
       _L6470_INIT(Z2);
     #endif
+    #if AXIS_DRIVER_TYPE(Z3, L6470)
+      _L6470_INIT(Z3);
+    #endif
     #if AXIS_DRIVER_TYPE(E0, L6470)
       _L6470_INIT(E0);
     #endif

commit 809b232fa256c345114ea36c9fbb879e93b29f12
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 14 20:00:55 2018 -0500

    Fix stepper directions after M501/M502
    
    See https://github.com/MarlinFirmware/Marlin/issues/11103#issuecomment-421387611
    
    Co-Authored-By: tcm0116 <tcm0116@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index abd28eb65a..89c4381ca4 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -35,6 +35,8 @@
 
 #include "../inc/MarlinConfig.h"
 
+#include "../module/stepper.h"
+
 //
 // TMC26X Driver objects and inits
 //
@@ -580,6 +582,7 @@ void reset_stepper_drivers() {
   #if HAS_DRIVER(L6470)
     L6470_init_to_defaults();
   #endif
+  stepper.set_directions();
 }
 
 //

commit 49e107cea9544bc531b8d01f47613747cecc1621
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sat Sep 1 23:24:44 2018 +0300

    Restrict SW serial to AVR (#11696)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index e0aeae0168..abd28eb65a 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -281,8 +281,6 @@
 // TMC2208 Driver objects and inits
 //
 #if HAS_DRIVER(TMC2208)
-
-  #include <SoftwareSerial.h>
   #include <HardwareSerial.h>
   #include <TMC2208Stepper.h>
   #include "planner.h"

commit 1561e61df78a47fbe7a1b1b095a890c0ddeba77e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Aug 14 18:41:37 2018 -0500

    New TMC2208 constructor
    
    Co-Authored-By: teemuatlut <teemu.mantykallio@live.fi>

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 8858d22fdb..e0aeae0168 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -292,8 +292,7 @@
   #endif
 
   #define _TMC2208_DEFINE_HARDWARE(ST) TMC2208Stepper stepper##ST(&ST##_HARDWARE_SERIAL)
-  #define _TMC2208_DEFINE_SOFTWARE(ST) SoftwareSerial ST##_HARDWARE_SERIAL = SoftwareSerial(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN); \
-                                       TMC2208Stepper stepper##ST(&ST##_HARDWARE_SERIAL, ST##_SERIAL_RX_PIN > -1)
+  #define _TMC2208_DEFINE_SOFTWARE(ST) TMC2208Stepper stepper##ST(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN, ST##_SERIAL_RX_PIN > -1)
 
   // Stepper objects of TMC2208 steppers used
   #if AXIS_DRIVER_TYPE(X, TMC2208)
@@ -376,37 +375,81 @@
 
   void tmc2208_serial_begin() {
     #if AXIS_DRIVER_TYPE(X, TMC2208)
-      X_HARDWARE_SERIAL.begin(115200);
+      #ifdef X_HARDWARE_SERIAL
+        X_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperX.beginSerial(115200);
+      #endif
     #endif
     #if AXIS_DRIVER_TYPE(X2, TMC2208)
-      X2_HARDWARE_SERIAL.begin(115200);
+      #ifdef X2_HARDWARE_SERIAL
+        X2_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperX2.beginSerial(115200);
+      #endif
     #endif
     #if AXIS_DRIVER_TYPE(Y, TMC2208)
-      Y_HARDWARE_SERIAL.begin(115200);
+      #ifdef Y_HARDWARE_SERIAL
+        Y_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperY.beginSerial(115200);
+      #endif
     #endif
     #if AXIS_DRIVER_TYPE(Y2, TMC2208)
-      Y2_HARDWARE_SERIAL.begin(115200);
+      #ifdef Y2_HARDWARE_SERIAL
+        Y2_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperY2.beginSerial(115200);
+      #endif
     #endif
     #if AXIS_DRIVER_TYPE(Z, TMC2208)
-      Z_HARDWARE_SERIAL.begin(115200);
+      #ifdef Z_HARDWARE_SERIAL
+        Z_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperZ.beginSerial(115200);
+      #endif
     #endif
     #if AXIS_DRIVER_TYPE(Z2, TMC2208)
-      Z2_HARDWARE_SERIAL.begin(115200);
+      #ifdef Z2_HARDWARE_SERIAL
+        Z2_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperZ2.beginSerial(115200);
+      #endif
     #endif
     #if AXIS_DRIVER_TYPE(E0, TMC2208)
-      E0_HARDWARE_SERIAL.begin(115200);
+      #ifdef E0_HARDWARE_SERIAL
+        E0_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperE0.beginSerial(115200);
+      #endif
     #endif
     #if AXIS_DRIVER_TYPE(E1, TMC2208)
-      E1_HARDWARE_SERIAL.begin(115200);
+      #ifdef E1_HARDWARE_SERIAL
+        E1_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperE1.beginSerial(115200);
+      #endif
     #endif
     #if AXIS_DRIVER_TYPE(E2, TMC2208)
-      E2_HARDWARE_SERIAL.begin(115200);
+      #ifdef E2_HARDWARE_SERIAL
+        E2_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperE2.beginSerial(115200);
+      #endif
     #endif
     #if AXIS_DRIVER_TYPE(E3, TMC2208)
-      E3_HARDWARE_SERIAL.begin(115200);
+      #ifdef E3_HARDWARE_SERIAL
+        E3_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperE3.beginSerial(115200);
+      #endif
     #endif
     #if AXIS_DRIVER_TYPE(E4, TMC2208)
-      E4_HARDWARE_SERIAL.begin(115200);
+      #ifdef E4_HARDWARE_SERIAL
+        E4_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperE4.beginSerial(115200);
+      #endif
     #endif
   }
 

commit fbcdf5eaeb4f2265fd43097ab6c652a89842d8e7
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sat Jul 14 14:13:06 2018 +0300

    Simplify stepper driver per-axis selection

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index bf63e61b6d..8858d22fdb 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -38,7 +38,7 @@
 //
 // TMC26X Driver objects and inits
 //
-#if ENABLED(HAVE_TMC26X)
+#if HAS_DRIVER(TMC26X)
   #include <SPI.h>
 
   #ifdef STM32F7
@@ -49,37 +49,37 @@
 
   #define _TMC26X_DEFINE(ST) TMC26XStepper stepper##ST(200, ST##_CS_PIN, ST##_STEP_PIN, ST##_DIR_PIN, ST##_MAX_CURRENT, ST##_SENSE_RESISTOR)
 
-  #if ENABLED(X_IS_TMC26X)
+  #if AXIS_DRIVER_TYPE(X, TMC26X)
     _TMC26X_DEFINE(X);
   #endif
-  #if ENABLED(X2_IS_TMC26X)
+  #if AXIS_DRIVER_TYPE(X2, TMC26X)
     _TMC26X_DEFINE(X2);
   #endif
-  #if ENABLED(Y_IS_TMC26X)
+  #if AXIS_DRIVER_TYPE(Y, TMC26X)
     _TMC26X_DEFINE(Y);
   #endif
-  #if ENABLED(Y2_IS_TMC26X)
+  #if AXIS_DRIVER_TYPE(Y2, TMC26X)
     _TMC26X_DEFINE(Y2);
   #endif
-  #if ENABLED(Z_IS_TMC26X)
+  #if AXIS_DRIVER_TYPE(Z, TMC26X)
     _TMC26X_DEFINE(Z);
   #endif
-  #if ENABLED(Z2_IS_TMC26X)
+  #if AXIS_DRIVER_TYPE(Z2, TMC26X)
     _TMC26X_DEFINE(Z2);
   #endif
-  #if ENABLED(E0_IS_TMC26X)
+  #if AXIS_DRIVER_TYPE(E0, TMC26X)
     _TMC26X_DEFINE(E0);
   #endif
-  #if ENABLED(E1_IS_TMC26X)
+  #if AXIS_DRIVER_TYPE(E1, TMC26X)
     _TMC26X_DEFINE(E1);
   #endif
-  #if ENABLED(E2_IS_TMC26X)
+  #if AXIS_DRIVER_TYPE(E2, TMC26X)
     _TMC26X_DEFINE(E2);
   #endif
-  #if ENABLED(E3_IS_TMC26X)
+  #if AXIS_DRIVER_TYPE(E3, TMC26X)
     _TMC26X_DEFINE(E3);
   #endif
-  #if ENABLED(E4_IS_TMC26X)
+  #if AXIS_DRIVER_TYPE(E4, TMC26X)
     _TMC26X_DEFINE(E4);
   #endif
 
@@ -89,46 +89,46 @@
   }while(0)
 
   void tmc26x_init_to_defaults() {
-    #if ENABLED(X_IS_TMC26X)
+    #if AXIS_DRIVER_TYPE(X, TMC26X)
       _TMC26X_INIT(X);
     #endif
-    #if ENABLED(X2_IS_TMC26X)
+    #if AXIS_DRIVER_TYPE(X2, TMC26X)
       _TMC26X_INIT(X2);
     #endif
-    #if ENABLED(Y_IS_TMC26X)
+    #if AXIS_DRIVER_TYPE(Y, TMC26X)
       _TMC26X_INIT(Y);
     #endif
-    #if ENABLED(Y2_IS_TMC26X)
+    #if AXIS_DRIVER_TYPE(Y2, TMC26X)
       _TMC26X_INIT(Y2);
     #endif
-    #if ENABLED(Z_IS_TMC26X)
+    #if AXIS_DRIVER_TYPE(Z, TMC26X)
       _TMC26X_INIT(Z);
     #endif
-    #if ENABLED(Z2_IS_TMC26X)
+    #if AXIS_DRIVER_TYPE(Z2, TMC26X)
       _TMC26X_INIT(Z2);
     #endif
-    #if ENABLED(E0_IS_TMC26X)
+    #if AXIS_DRIVER_TYPE(E0, TMC26X)
       _TMC26X_INIT(E0);
     #endif
-    #if ENABLED(E1_IS_TMC26X)
+    #if AXIS_DRIVER_TYPE(E1, TMC26X)
       _TMC26X_INIT(E1);
     #endif
-    #if ENABLED(E2_IS_TMC26X)
+    #if AXIS_DRIVER_TYPE(E2, TMC26X)
       _TMC26X_INIT(E2);
     #endif
-    #if ENABLED(E3_IS_TMC26X)
+    #if AXIS_DRIVER_TYPE(E3, TMC26X)
       _TMC26X_INIT(E3);
     #endif
-    #if ENABLED(E4_IS_TMC26X)
+    #if AXIS_DRIVER_TYPE(E4, TMC26X)
       _TMC26X_INIT(E4);
     #endif
   }
-#endif // HAVE_TMC26X
+#endif // TMC26X
 
 //
 // TMC2130 Driver objects and inits
 //
-#if ENABLED(HAVE_TMC2130)
+#if HAS_DRIVER(TMC2130)
 
   #include <SPI.h>
   #include <TMC2130Stepper.h>
@@ -146,37 +146,37 @@
   #endif
 
   // Stepper objects of TMC2130 steppers used
-  #if ENABLED(X_IS_TMC2130)
+  #if AXIS_DRIVER_TYPE(X, TMC2130)
     _TMC2130_DEFINE(X);
   #endif
-  #if ENABLED(X2_IS_TMC2130)
+  #if AXIS_DRIVER_TYPE(X2, TMC2130)
     _TMC2130_DEFINE(X2);
   #endif
-  #if ENABLED(Y_IS_TMC2130)
+  #if AXIS_DRIVER_TYPE(Y, TMC2130)
     _TMC2130_DEFINE(Y);
   #endif
-  #if ENABLED(Y2_IS_TMC2130)
+  #if AXIS_DRIVER_TYPE(Y2, TMC2130)
     _TMC2130_DEFINE(Y2);
   #endif
-  #if ENABLED(Z_IS_TMC2130)
+  #if AXIS_DRIVER_TYPE(Z, TMC2130)
     _TMC2130_DEFINE(Z);
   #endif
-  #if ENABLED(Z2_IS_TMC2130)
+  #if AXIS_DRIVER_TYPE(Z2, TMC2130)
     _TMC2130_DEFINE(Z2);
   #endif
-  #if ENABLED(E0_IS_TMC2130)
+  #if AXIS_DRIVER_TYPE(E0, TMC2130)
     _TMC2130_DEFINE(E0);
   #endif
-  #if ENABLED(E1_IS_TMC2130)
+  #if AXIS_DRIVER_TYPE(E1, TMC2130)
     _TMC2130_DEFINE(E1);
   #endif
-  #if ENABLED(E2_IS_TMC2130)
+  #if AXIS_DRIVER_TYPE(E2, TMC2130)
     _TMC2130_DEFINE(E2);
   #endif
-  #if ENABLED(E3_IS_TMC2130)
+  #if AXIS_DRIVER_TYPE(E3, TMC2130)
     _TMC2130_DEFINE(E3);
   #endif
-  #if ENABLED(E4_IS_TMC2130)
+  #if AXIS_DRIVER_TYPE(E4, TMC2130)
     _TMC2130_DEFINE(E4);
   #endif
 
@@ -213,74 +213,74 @@
   #define _TMC2130_INIT(ST, SPMM) tmc2130_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, SPMM)
 
   void tmc2130_init_to_defaults() {
-    #if ENABLED(X_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(X, TMC2130)
       _TMC2130_INIT( X, planner.axis_steps_per_mm[X_AXIS]);
     #endif
-    #if ENABLED(X2_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(X2, TMC2130)
       _TMC2130_INIT(X2, planner.axis_steps_per_mm[X_AXIS]);
     #endif
-    #if ENABLED(Y_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(Y, TMC2130)
       _TMC2130_INIT( Y, planner.axis_steps_per_mm[Y_AXIS]);
     #endif
-    #if ENABLED(Y2_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(Y2, TMC2130)
       _TMC2130_INIT(Y2, planner.axis_steps_per_mm[Y_AXIS]);
     #endif
-    #if ENABLED(Z_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(Z, TMC2130)
       _TMC2130_INIT( Z, planner.axis_steps_per_mm[Z_AXIS]);
     #endif
-    #if ENABLED(Z2_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(Z2, TMC2130)
       _TMC2130_INIT(Z2, planner.axis_steps_per_mm[Z_AXIS]);
     #endif
-    #if ENABLED(E0_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(E0, TMC2130)
       _TMC2130_INIT(E0, planner.axis_steps_per_mm[E_AXIS]);
     #endif
-    #if ENABLED(E1_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(E1, TMC2130)
       { constexpr int extruder = 1; _TMC2130_INIT(E1, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
-    #if ENABLED(E2_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(E2, TMC2130)
       { constexpr int extruder = 2; _TMC2130_INIT(E2, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
-    #if ENABLED(E3_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(E3, TMC2130)
       { constexpr int extruder = 3; _TMC2130_INIT(E3, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
-    #if ENABLED(E4_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(E4, TMC2130)
       { constexpr int extruder = 4; _TMC2130_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
 
     #if ENABLED(SENSORLESS_HOMING)
       #define TMC_INIT_SGT(P,Q) stepper##Q.sgt(P##_HOMING_SENSITIVITY);
       #if X_SENSORLESS
-        #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
+        #if AXIS_DRIVER_TYPE(X, TMC2130)
           stepperX.sgt(X_HOMING_SENSITIVITY);
         #endif
-        #if ENABLED(X2_IS_TMC2130)
+        #if AXIS_DRIVER_TYPE(X2, TMC2130)
           stepperX2.sgt(X_HOMING_SENSITIVITY);
         #endif
       #endif
       #if Y_SENSORLESS
-        #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
+        #if AXIS_DRIVER_TYPE(Y, TMC2130)
           stepperY.sgt(Y_HOMING_SENSITIVITY);
         #endif
-        #if ENABLED(Y2_IS_TMC2130)
+        #if AXIS_DRIVER_TYPE(Y2, TMC2130)
           stepperY2.sgt(Y_HOMING_SENSITIVITY);
         #endif
       #endif
       #if Z_SENSORLESS
-        #if ENABLED(Z_IS_TMC2130) || ENABLED(IS_TRAMS)
+        #if AXIS_DRIVER_TYPE(Z, TMC2130)
           stepperZ.sgt(Z_HOMING_SENSITIVITY);
         #endif
-        #if ENABLED(Z2_IS_TMC2130)
+        #if AXIS_DRIVER_TYPE(Z2, TMC2130)
           stepperZ2.sgt(Z_HOMING_SENSITIVITY);
         #endif
       #endif
     #endif
   }
-#endif // HAVE_TMC2130
+#endif // TMC2130
 
 //
 // TMC2208 Driver objects and inits
 //
-#if ENABLED(HAVE_TMC2208)
+#if HAS_DRIVER(TMC2208)
 
   #include <SoftwareSerial.h>
   #include <HardwareSerial.h>
@@ -296,77 +296,77 @@
                                        TMC2208Stepper stepper##ST(&ST##_HARDWARE_SERIAL, ST##_SERIAL_RX_PIN > -1)
 
   // Stepper objects of TMC2208 steppers used
-  #if ENABLED(X_IS_TMC2208)
+  #if AXIS_DRIVER_TYPE(X, TMC2208)
     #ifdef X_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(X);
     #else
       _TMC2208_DEFINE_SOFTWARE(X);
     #endif
   #endif
-  #if ENABLED(X2_IS_TMC2208)
+  #if AXIS_DRIVER_TYPE(X2, TMC2208)
     #ifdef X2_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(X2);
     #else
       _TMC2208_DEFINE_SOFTWARE(X2);
     #endif
   #endif
-  #if ENABLED(Y_IS_TMC2208)
+  #if AXIS_DRIVER_TYPE(Y, TMC2208)
     #ifdef Y_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(Y);
     #else
       _TMC2208_DEFINE_SOFTWARE(Y);
     #endif
   #endif
-  #if ENABLED(Y2_IS_TMC2208)
+  #if AXIS_DRIVER_TYPE(Y2, TMC2208)
     #ifdef Y2_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(Y2);
     #else
       _TMC2208_DEFINE_SOFTWARE(Y2);
     #endif
   #endif
-  #if ENABLED(Z_IS_TMC2208)
+  #if AXIS_DRIVER_TYPE(Z, TMC2208)
     #ifdef Z_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(Z);
     #else
       _TMC2208_DEFINE_SOFTWARE(Z);
     #endif
   #endif
-  #if ENABLED(Z2_IS_TMC2208)
+  #if AXIS_DRIVER_TYPE(Z2, TMC2208)
     #ifdef Z2_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(Z2);
     #else
       _TMC2208_DEFINE_SOFTWARE(Z2);
     #endif
   #endif
-  #if ENABLED(E0_IS_TMC2208)
+  #if AXIS_DRIVER_TYPE(E0, TMC2208)
     #ifdef E0_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(E0);
     #else
       _TMC2208_DEFINE_SOFTWARE(E0);
     #endif
   #endif
-  #if ENABLED(E1_IS_TMC2208)
+  #if AXIS_DRIVER_TYPE(E1, TMC2208)
     #ifdef E1_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(E1);
     #else
       _TMC2208_DEFINE_SOFTWARE(E1);
     #endif
   #endif
-  #if ENABLED(E2_IS_TMC2208)
+  #if AXIS_DRIVER_TYPE(E2, TMC2208)
     #ifdef E2_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(E2);
     #else
       _TMC2208_DEFINE_SOFTWARE(E2);
     #endif
   #endif
-  #if ENABLED(E3_IS_TMC2208)
+  #if AXIS_DRIVER_TYPE(E3, TMC2208)
     #ifdef E3_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(E3);
     #else
       _TMC2208_DEFINE_SOFTWARE(E3);
     #endif
   #endif
-  #if ENABLED(E4_IS_TMC2208)
+  #if AXIS_DRIVER_TYPE(E4, TMC2208)
     #ifdef E4_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(E4);
     #else
@@ -375,37 +375,37 @@
   #endif
 
   void tmc2208_serial_begin() {
-    #if ENABLED(X_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(X, TMC2208)
       X_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(X2_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(X2, TMC2208)
       X2_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(Y_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(Y, TMC2208)
       Y_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(Y2_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(Y2, TMC2208)
       Y2_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(Z_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(Z, TMC2208)
       Z_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(Z2_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(Z2, TMC2208)
       Z2_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(E0_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(E0, TMC2208)
       E0_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(E1_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(E1, TMC2208)
       E1_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(E2_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(E2, TMC2208)
       E2_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(E3_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(E3, TMC2208)
       E3_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(E4_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(E4, TMC2208)
       E4_HARDWARE_SERIAL.begin(115200);
     #endif
   }
@@ -449,94 +449,94 @@
   #define _TMC2208_INIT(ST, SPMM) tmc2208_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, SPMM)
 
   void tmc2208_init_to_defaults() {
-    #if ENABLED(X_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(X, TMC2208)
       _TMC2208_INIT(X, planner.axis_steps_per_mm[X_AXIS]);
     #endif
-    #if ENABLED(X2_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(X2, TMC2208)
       _TMC2208_INIT(X2, planner.axis_steps_per_mm[X_AXIS]);
     #endif
-    #if ENABLED(Y_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(Y, TMC2208)
       _TMC2208_INIT(Y, planner.axis_steps_per_mm[Y_AXIS]);
     #endif
-    #if ENABLED(Y2_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(Y2, TMC2208)
       _TMC2208_INIT(Y2, planner.axis_steps_per_mm[Y_AXIS]);
     #endif
-    #if ENABLED(Z_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(Z, TMC2208)
       _TMC2208_INIT(Z, planner.axis_steps_per_mm[Z_AXIS]);
     #endif
-    #if ENABLED(Z2_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(Z2, TMC2208)
       _TMC2208_INIT(Z2, planner.axis_steps_per_mm[Z_AXIS]);
     #endif
-    #if ENABLED(E0_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(E0, TMC2208)
       _TMC2208_INIT(E0, planner.axis_steps_per_mm[E_AXIS]);
     #endif
-    #if ENABLED(E1_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(E1, TMC2208)
       { constexpr int extruder = 1; _TMC2208_INIT(E1, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
-    #if ENABLED(E2_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(E2, TMC2208)
       { constexpr int extruder = 2; _TMC2208_INIT(E2, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
-    #if ENABLED(E3_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(E3, TMC2208)
       { constexpr int extruder = 3; _TMC2208_INIT(E3, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
-    #if ENABLED(E4_IS_TMC2208)
+    #if AXIS_DRIVER_TYPE(E4, TMC2208)
       { constexpr int extruder = 4; _TMC2208_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
   }
-#endif // HAVE_TMC2208
+#endif // TMC2208
 
 void restore_stepper_drivers() {
-  #if X_IS_TRINAMIC
+  #if AXIS_IS_TMC(X)
     stepperX.push();
   #endif
-  #if X2_IS_TRINAMIC
+  #if AXIS_IS_TMC(X2)
     stepperX2.push();
   #endif
-  #if Y_IS_TRINAMIC
+  #if AXIS_IS_TMC(Y)
     stepperY.push();
   #endif
-  #if Y2_IS_TRINAMIC
+  #if AXIS_IS_TMC(Y2)
     stepperY2.push();
   #endif
-  #if Z_IS_TRINAMIC
+  #if AXIS_IS_TMC(Z)
     stepperZ.push();
   #endif
-  #if Z2_IS_TRINAMIC
+  #if AXIS_IS_TMC(Z2)
     stepperZ2.push();
   #endif
-  #if E0_IS_TRINAMIC
+  #if AXIS_IS_TMC(E0)
     stepperE0.push();
   #endif
-  #if E1_IS_TRINAMIC
+  #if AXIS_IS_TMC(E1)
     stepperE1.push();
   #endif
-  #if E2_IS_TRINAMIC
+  #if AXIS_IS_TMC(E2)
     stepperE2.push();
   #endif
-  #if E3_IS_TRINAMIC
+  #if AXIS_IS_TMC(E3)
     stepperE3.push();
   #endif
-  #if E4_IS_TRINAMIC
+  #if AXIS_IS_TMC(E4)
     stepperE4.push();
   #endif
 }
 
 void reset_stepper_drivers() {
-  #if ENABLED(HAVE_TMC26X)
+  #if HAS_DRIVER(TMC26X)
     tmc26x_init_to_defaults();
   #endif
-  #if ENABLED(HAVE_TMC2130)
+  #if HAS_DRIVER(TMC2130)
     delay(100);
     tmc2130_init_to_defaults();
   #endif
-  #if ENABLED(HAVE_TMC2208)
+  #if HAS_DRIVER(TMC2208)
     delay(100);
     tmc2208_init_to_defaults();
   #endif
   #ifdef TMC_ADV
     TMC_ADV()
   #endif
-  #if ENABLED(HAVE_L6470DRIVER)
+  #if HAS_DRIVER(L6470)
     L6470_init_to_defaults();
   #endif
 }
@@ -544,7 +544,7 @@ void reset_stepper_drivers() {
 //
 // L6470 Driver objects and inits
 //
-#if ENABLED(HAVE_L6470DRIVER)
+#if HAS_DRIVER(L6470)
 
   #include <SPI.h>
   #include <L6470.h>
@@ -552,37 +552,37 @@ void reset_stepper_drivers() {
   #define _L6470_DEFINE(ST) L6470 stepper##ST(ST##_ENABLE_PIN)
 
   // L6470 Stepper objects
-  #if ENABLED(X_IS_L6470)
+  #if AXIS_DRIVER_TYPE(X, L6470)
     _L6470_DEFINE(X);
   #endif
-  #if ENABLED(X2_IS_L6470)
+  #if AXIS_DRIVER_TYPE(X2, L6470)
     _L6470_DEFINE(X2);
   #endif
-  #if ENABLED(Y_IS_L6470)
+  #if AXIS_DRIVER_TYPE(Y, L6470)
     _L6470_DEFINE(Y);
   #endif
-  #if ENABLED(Y2_IS_L6470)
+  #if AXIS_DRIVER_TYPE(Y2, L6470)
     _L6470_DEFINE(Y2);
   #endif
-  #if ENABLED(Z_IS_L6470)
+  #if AXIS_DRIVER_TYPE(Z, L6470)
     _L6470_DEFINE(Z);
   #endif
-  #if ENABLED(Z2_IS_L6470)
+  #if AXIS_DRIVER_TYPE(Z2, L6470)
     _L6470_DEFINE(Z2);
   #endif
-  #if ENABLED(E0_IS_L6470)
+  #if AXIS_DRIVER_TYPE(E0, L6470)
     _L6470_DEFINE(E0);
   #endif
-  #if ENABLED(E1_IS_L6470)
+  #if AXIS_DRIVER_TYPE(E1, L6470)
     _L6470_DEFINE(E1);
   #endif
-  #if ENABLED(E2_IS_L6470)
+  #if AXIS_DRIVER_TYPE(E2, L6470)
     _L6470_DEFINE(E2);
   #endif
-  #if ENABLED(E3_IS_L6470)
+  #if AXIS_DRIVER_TYPE(E3, L6470)
     _L6470_DEFINE(E3);
   #endif
-  #if ENABLED(E4_IS_L6470)
+  #if AXIS_DRIVER_TYPE(E4, L6470)
     _L6470_DEFINE(E4);
   #endif
 
@@ -595,39 +595,39 @@ void reset_stepper_drivers() {
   }while(0)
 
   void L6470_init_to_defaults() {
-    #if ENABLED(X_IS_L6470)
+    #if AXIS_DRIVER_TYPE(X, L6470)
       _L6470_INIT(X);
     #endif
-    #if ENABLED(X2_IS_L6470)
+    #if AXIS_DRIVER_TYPE(X2, L6470)
       _L6470_INIT(X2);
     #endif
-    #if ENABLED(Y_IS_L6470)
+    #if AXIS_DRIVER_TYPE(Y, L6470)
       _L6470_INIT(Y);
     #endif
-    #if ENABLED(Y2_IS_L6470)
+    #if AXIS_DRIVER_TYPE(Y2, L6470)
       _L6470_INIT(Y2);
     #endif
-    #if ENABLED(Z_IS_L6470)
+    #if AXIS_DRIVER_TYPE(Z, L6470)
       _L6470_INIT(Z);
     #endif
-    #if ENABLED(Z2_IS_L6470)
+    #if AXIS_DRIVER_TYPE(Z2, L6470)
       _L6470_INIT(Z2);
     #endif
-    #if ENABLED(E0_IS_L6470)
+    #if AXIS_DRIVER_TYPE(E0, L6470)
       _L6470_INIT(E0);
     #endif
-    #if ENABLED(E1_IS_L6470)
+    #if AXIS_DRIVER_TYPE(E1, L6470)
       _L6470_INIT(E1);
     #endif
-    #if ENABLED(E2_IS_L6470)
+    #if AXIS_DRIVER_TYPE(E2, L6470)
       _L6470_INIT(E2);
     #endif
-    #if ENABLED(E3_IS_L6470)
+    #if AXIS_DRIVER_TYPE(E3, L6470)
       _L6470_INIT(E3);
     #endif
-    #if ENABLED(E4_IS_L6470)
+    #if AXIS_DRIVER_TYPE(E4, L6470)
       _L6470_INIT(E4);
     #endif
   }
 
-#endif // HAVE_L6470DRIVER
+#endif // L6470

commit 9c058091e936e3bec2900455ace27db2643ab565
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 3 19:24:44 2018 -0500

    No M914 or SGT set for non-sensorless axes

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index e1ac4a54ad..bf63e61b6d 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -249,7 +249,7 @@
 
     #if ENABLED(SENSORLESS_HOMING)
       #define TMC_INIT_SGT(P,Q) stepper##Q.sgt(P##_HOMING_SENSITIVITY);
-      #ifdef X_HOMING_SENSITIVITY
+      #if X_SENSORLESS
         #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
           stepperX.sgt(X_HOMING_SENSITIVITY);
         #endif
@@ -257,7 +257,7 @@
           stepperX2.sgt(X_HOMING_SENSITIVITY);
         #endif
       #endif
-      #ifdef Y_HOMING_SENSITIVITY
+      #if Y_SENSORLESS
         #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
           stepperY.sgt(Y_HOMING_SENSITIVITY);
         #endif
@@ -265,7 +265,7 @@
           stepperY2.sgt(Y_HOMING_SENSITIVITY);
         #endif
       #endif
-      #ifdef Z_HOMING_SENSITIVITY
+      #if Z_SENSORLESS
         #if ENABLED(Z_IS_TMC2130) || ENABLED(IS_TRAMS)
           stepperZ.sgt(Z_HOMING_SENSITIVITY);
         #endif

commit f3fed52348005c313d5565959545fe1b3a756662
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 12 22:12:46 2018 -0500

    Fix coolstep_min_speed / sensorless homing
    
    Fix #8890

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index be62f9d308..e1ac4a54ad 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -206,8 +206,6 @@
       #if ENABLED(HYBRID_THRESHOLD)
         st.stealth_max_speed(12650000UL*microsteps/(256*thrs*spmm));
       #endif
-    #elif ENABLED(SENSORLESS_HOMING)
-      st.coolstep_min_speed(1024UL * 1024UL - 1UL);
     #endif
     st.GSTAT(); // Clear GSTAT
   }

commit b76344c080ce0b7f651290dcfeecc6b815fea916
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 10 00:05:15 2018 -0500

    More Trinamic cleanup

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 7052c3a45a..be62f9d308 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -184,6 +184,10 @@
   // Following values from Trinamic's spreadsheet with values for a NEMA17 (42BYGHW609)
   // https://www.trinamic.com/products/integrated-circuits/details/tmc2130/
   void tmc2130_init(TMC2130Stepper &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm) {
+    #if DISABLED(STEALTHCHOP) || DISABLED(HYBRID_THRESHOLD)
+      UNUSED(thrs);
+      UNUSED(spmm);
+    #endif
     st.begin();
     st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
     st.microsteps(microsteps);
@@ -201,9 +205,6 @@
       st.stealthChop(1);
       #if ENABLED(HYBRID_THRESHOLD)
         st.stealth_max_speed(12650000UL*microsteps/(256*thrs*spmm));
-      #else
-        UNUSED(thrs);
-        UNUSED(spmm);
       #endif
     #elif ENABLED(SENSORLESS_HOMING)
       st.coolstep_min_speed(1024UL * 1024UL - 1UL);

commit 1dab44213a03e54b578e3d88b95e4e9ddf7579b9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 28 12:02:45 2018 -0500

    Fix the TMC26X initializer CS pin argument
    
    From #10531
    
    Co-Authored-By: chriscg9 <chriscg9@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 1220427ddd..7052c3a45a 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -47,7 +47,7 @@
     #include <TMC26XStepper.h>
   #endif
 
-  #define _TMC26X_DEFINE(ST) TMC26XStepper stepper##ST(200, ST##_ENABLE_PIN, ST##_STEP_PIN, ST##_DIR_PIN, ST##_MAX_CURRENT, ST##_SENSE_RESISTOR)
+  #define _TMC26X_DEFINE(ST) TMC26XStepper stepper##ST(200, ST##_CS_PIN, ST##_STEP_PIN, ST##_DIR_PIN, ST##_MAX_CURRENT, ST##_SENSE_RESISTOR)
 
   #if ENABLED(X_IS_TMC26X)
     _TMC26X_DEFINE(X);

commit 75037493fa0bb9f62e7d362a1fa783a1e2af7b98
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu Apr 5 14:09:49 2018 -0600

    Default active low for TMC2130 DIAG1 (#10294)
    
    - Added sanity check to inform users to set the endstop to inverting
      when using SENSORLESS_HOMING

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 274e1fd2cd..1220427ddd 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -193,7 +193,6 @@
     st.power_down_delay(128); // ~2s until driver lowers to hold current
     st.hysteresis_start(3);
     st.hysteresis_end(2);
-    st.diag1_active_high(1); // For sensorless homing
     #if ENABLED(STEALTHCHOP)
       st.stealth_freq(1); // f_pwm = 2/683 f_clk
       st.stealth_autoscale(1);

commit a891af2f7a8a548d451c4801771bc622e3da824c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 24 15:26:11 2018 -0400

    Enforce minimum TMC2130 / TMC2208 libs

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 1e54fc8768..274e1fd2cd 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -135,6 +135,10 @@
   #include "planner.h"
   #include "../core/enum.h"
 
+  #if TMC2130STEPPER_VERSION < 0x020201
+    #error "Update TMC2130Stepper library to 2.2.1 or newer."
+  #endif
+
   #if ENABLED(TMC_USE_SW_SPI)
     #define _TMC2130_DEFINE(ST) TMC2130Stepper stepper##ST(ST##_ENABLE_PIN, ST##_DIR_PIN, ST##_STEP_PIN, ST##_CS_PIN, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
   #else
@@ -285,6 +289,10 @@
   #include <TMC2208Stepper.h>
   #include "planner.h"
 
+  #if TMC2208STEPPER_VERSION < 0x000101
+    #error "Update TMC2208Stepper library to 0.1.1 or newer."
+  #endif
+
   #define _TMC2208_DEFINE_HARDWARE(ST) TMC2208Stepper stepper##ST(&ST##_HARDWARE_SERIAL)
   #define _TMC2208_DEFINE_SOFTWARE(ST) SoftwareSerial ST##_HARDWARE_SERIAL = SoftwareSerial(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN); \
                                        TMC2208Stepper stepper##ST(&ST##_HARDWARE_SERIAL, ST##_SERIAL_RX_PIN > -1)

commit 48d7036874e55131847360e5693d9807ee0e5184
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 18 19:01:42 2018 -0500

    Consolidate smart stepper driver initialization

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index e92ad8826c..1e54fc8768 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -47,83 +47,82 @@
     #include <TMC26XStepper.h>
   #endif
 
-  #define _TMC_DEFINE(ST) TMC26XStepper stepper##ST(200, ST##_ENABLE_PIN, ST##_STEP_PIN, ST##_DIR_PIN, ST##_MAX_CURRENT, ST##_SENSE_RESISTOR)
+  #define _TMC26X_DEFINE(ST) TMC26XStepper stepper##ST(200, ST##_ENABLE_PIN, ST##_STEP_PIN, ST##_DIR_PIN, ST##_MAX_CURRENT, ST##_SENSE_RESISTOR)
 
   #if ENABLED(X_IS_TMC26X)
-    _TMC_DEFINE(X);
+    _TMC26X_DEFINE(X);
   #endif
   #if ENABLED(X2_IS_TMC26X)
-    _TMC_DEFINE(X2);
+    _TMC26X_DEFINE(X2);
   #endif
   #if ENABLED(Y_IS_TMC26X)
-    _TMC_DEFINE(Y);
+    _TMC26X_DEFINE(Y);
   #endif
   #if ENABLED(Y2_IS_TMC26X)
-    _TMC_DEFINE(Y2);
+    _TMC26X_DEFINE(Y2);
   #endif
   #if ENABLED(Z_IS_TMC26X)
-    _TMC_DEFINE(Z);
+    _TMC26X_DEFINE(Z);
   #endif
   #if ENABLED(Z2_IS_TMC26X)
-    _TMC_DEFINE(Z2);
+    _TMC26X_DEFINE(Z2);
   #endif
   #if ENABLED(E0_IS_TMC26X)
-    _TMC_DEFINE(E0);
+    _TMC26X_DEFINE(E0);
   #endif
   #if ENABLED(E1_IS_TMC26X)
-    _TMC_DEFINE(E1);
+    _TMC26X_DEFINE(E1);
   #endif
   #if ENABLED(E2_IS_TMC26X)
-    _TMC_DEFINE(E2);
+    _TMC26X_DEFINE(E2);
   #endif
   #if ENABLED(E3_IS_TMC26X)
-    _TMC_DEFINE(E3);
+    _TMC26X_DEFINE(E3);
   #endif
   #if ENABLED(E4_IS_TMC26X)
-    _TMC_DEFINE(E4);
+    _TMC26X_DEFINE(E4);
   #endif
 
-  #define _TMC_INIT(A) do{ \
+  #define _TMC26X_INIT(A) do{ \
     stepper##A.setMicrosteps(A##_MICROSTEPS); \
     stepper##A.start(); \
   }while(0)
 
-  void tmc26x_init() {
+  void tmc26x_init_to_defaults() {
     #if ENABLED(X_IS_TMC26X)
-      _TMC_INIT(X);
+      _TMC26X_INIT(X);
     #endif
     #if ENABLED(X2_IS_TMC26X)
-      _TMC_INIT(X2);
+      _TMC26X_INIT(X2);
     #endif
     #if ENABLED(Y_IS_TMC26X)
-      _TMC_INIT(Y);
+      _TMC26X_INIT(Y);
     #endif
     #if ENABLED(Y2_IS_TMC26X)
-      _TMC_INIT(Y2);
+      _TMC26X_INIT(Y2);
     #endif
     #if ENABLED(Z_IS_TMC26X)
-      _TMC_INIT(Z);
+      _TMC26X_INIT(Z);
     #endif
     #if ENABLED(Z2_IS_TMC26X)
-      _TMC_INIT(Z2);
+      _TMC26X_INIT(Z2);
     #endif
     #if ENABLED(E0_IS_TMC26X)
-      _TMC_INIT(E0);
+      _TMC26X_INIT(E0);
     #endif
     #if ENABLED(E1_IS_TMC26X)
-      _TMC_INIT(E1);
+      _TMC26X_INIT(E1);
     #endif
     #if ENABLED(E2_IS_TMC26X)
-      _TMC_INIT(E2);
+      _TMC26X_INIT(E2);
     #endif
     #if ENABLED(E3_IS_TMC26X)
-      _TMC_INIT(E3);
+      _TMC26X_INIT(E3);
     #endif
     #if ENABLED(E4_IS_TMC26X)
-      _TMC_INIT(E4);
+      _TMC26X_INIT(E4);
     #endif
   }
-
 #endif // HAVE_TMC26X
 
 //
@@ -180,9 +179,9 @@
   // Use internal reference voltage for current calculations. This is the default.
   // Following values from Trinamic's spreadsheet with values for a NEMA17 (42BYGHW609)
   // https://www.trinamic.com/products/integrated-circuits/details/tmc2130/
-  void tmc2130_init(TMC2130Stepper &st, const uint16_t microsteps, const uint32_t thrs, const float spmm) {
+  void tmc2130_init(TMC2130Stepper &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm) {
     st.begin();
-    st.setCurrent(st.getCurrent(), R_SENSE, HOLD_MULTIPLIER);
+    st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
     st.microsteps(microsteps);
     st.blank_time(24);
     st.off_time(5); // Only enables the driver if used with stealthChop
@@ -209,9 +208,9 @@
     st.GSTAT(); // Clear GSTAT
   }
 
-  #define _TMC2130_INIT(ST, SPMM) tmc2130_init(stepper##ST, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, SPMM)
+  #define _TMC2130_INIT(ST, SPMM) tmc2130_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, SPMM)
 
-  void tmc2130_init() {
+  void tmc2130_init_to_defaults() {
     #if ENABLED(X_IS_TMC2130)
       _TMC2130_INIT( X, planner.axis_steps_per_mm[X_AXIS]);
     #endif
@@ -234,34 +233,45 @@
       _TMC2130_INIT(E0, planner.axis_steps_per_mm[E_AXIS]);
     #endif
     #if ENABLED(E1_IS_TMC2130)
-      _TMC2130_INIT(E1, planner.axis_steps_per_mm[E_AXIS
-        #if ENABLED(DISTINCT_E_FACTORS)
-          + 1
-        #endif
-      ]);
+      { constexpr int extruder = 1; _TMC2130_INIT(E1, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
     #if ENABLED(E2_IS_TMC2130)
-      _TMC2130_INIT(E2, planner.axis_steps_per_mm[E_AXIS
-        #if ENABLED(DISTINCT_E_FACTORS)
-          + 2
-        #endif
-      ]);
+      { constexpr int extruder = 2; _TMC2130_INIT(E2, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
     #if ENABLED(E3_IS_TMC2130)
-      _TMC2130_INIT(E3, planner.axis_steps_per_mm[E_AXIS
-        #if ENABLED(DISTINCT_E_FACTORS)
-          + 3
-        #endif
-      ]);
+      { constexpr int extruder = 3; _TMC2130_INIT(E3, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
     #if ENABLED(E4_IS_TMC2130)
-      _TMC2130_INIT(E4, planner.axis_steps_per_mm[E_AXIS
-        #if ENABLED(DISTINCT_E_FACTORS)
-          + 4
-        #endif
-      ]);
+      { constexpr int extruder = 4; _TMC2130_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
 
+    #if ENABLED(SENSORLESS_HOMING)
+      #define TMC_INIT_SGT(P,Q) stepper##Q.sgt(P##_HOMING_SENSITIVITY);
+      #ifdef X_HOMING_SENSITIVITY
+        #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
+          stepperX.sgt(X_HOMING_SENSITIVITY);
+        #endif
+        #if ENABLED(X2_IS_TMC2130)
+          stepperX2.sgt(X_HOMING_SENSITIVITY);
+        #endif
+      #endif
+      #ifdef Y_HOMING_SENSITIVITY
+        #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
+          stepperY.sgt(Y_HOMING_SENSITIVITY);
+        #endif
+        #if ENABLED(Y2_IS_TMC2130)
+          stepperY2.sgt(Y_HOMING_SENSITIVITY);
+        #endif
+      #endif
+      #ifdef Z_HOMING_SENSITIVITY
+        #if ENABLED(Z_IS_TMC2130) || ENABLED(IS_TRAMS)
+          stepperZ.sgt(Z_HOMING_SENSITIVITY);
+        #endif
+        #if ENABLED(Z2_IS_TMC2130)
+          stepperZ2.sgt(Z_HOMING_SENSITIVITY);
+        #endif
+      #endif
+    #endif
   }
 #endif // HAVE_TMC2130
 
@@ -396,11 +406,11 @@
 
   // Use internal reference voltage for current calculations. This is the default.
   // Following values from Trinamic's spreadsheet with values for a NEMA17 (42BYGHW609)
-  void tmc2208_init(TMC2208Stepper &st, const uint16_t microsteps, const uint32_t thrs, const float spmm) {
+  void tmc2208_init(TMC2208Stepper &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const float spmm) {
     st.pdn_disable(true); // Use UART
     st.mstep_reg_select(true); // Select microsteps with UART
     st.I_scale_analog(false);
-    st.rms_current(st.getCurrent(), HOLD_MULTIPLIER, R_SENSE);
+    st.rms_current(mA, HOLD_MULTIPLIER, R_SENSE);
     st.microsteps(microsteps);
     st.blank_time(24);
     st.toff(5);
@@ -430,9 +440,9 @@
     delay(200);
   }
 
-  #define _TMC2208_INIT(ST, SPMM) tmc2208_init(stepper##ST, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, SPMM)
+  #define _TMC2208_INIT(ST, SPMM) tmc2208_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, SPMM)
 
-  void tmc2208_init() {
+  void tmc2208_init_to_defaults() {
     #if ENABLED(X_IS_TMC2208)
       _TMC2208_INIT(X, planner.axis_steps_per_mm[X_AXIS]);
     #endif
@@ -455,36 +465,76 @@
       _TMC2208_INIT(E0, planner.axis_steps_per_mm[E_AXIS]);
     #endif
     #if ENABLED(E1_IS_TMC2208)
-      _TMC2208_INIT(E1, planner.axis_steps_per_mm[E_AXIS
-        #if ENABLED(DISTINCT_E_FACTORS)
-          + 1
-        #endif
-      ]);
+      { constexpr int extruder = 1; _TMC2208_INIT(E1, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
     #if ENABLED(E2_IS_TMC2208)
-      _TMC2208_INIT(E2, planner.axis_steps_per_mm[E_AXIS
-        #if ENABLED(DISTINCT_E_FACTORS)
-          + 2
-        #endif
-      ]);
+      { constexpr int extruder = 2; _TMC2208_INIT(E2, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
     #if ENABLED(E3_IS_TMC2208)
-      _TMC2208_INIT(E3, planner.axis_steps_per_mm[E_AXIS
-        #if ENABLED(DISTINCT_E_FACTORS)
-          + 3
-        #endif
-      ]);
+      { constexpr int extruder = 3; _TMC2208_INIT(E3, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
     #if ENABLED(E4_IS_TMC2208)
-      _TMC2208_INIT(E4, planner.axis_steps_per_mm[E_AXIS
-        #if ENABLED(DISTINCT_E_FACTORS)
-          + 4
-        #endif
-      ]);
+      { constexpr int extruder = 4; _TMC2208_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
   }
 #endif // HAVE_TMC2208
 
+void restore_stepper_drivers() {
+  #if X_IS_TRINAMIC
+    stepperX.push();
+  #endif
+  #if X2_IS_TRINAMIC
+    stepperX2.push();
+  #endif
+  #if Y_IS_TRINAMIC
+    stepperY.push();
+  #endif
+  #if Y2_IS_TRINAMIC
+    stepperY2.push();
+  #endif
+  #if Z_IS_TRINAMIC
+    stepperZ.push();
+  #endif
+  #if Z2_IS_TRINAMIC
+    stepperZ2.push();
+  #endif
+  #if E0_IS_TRINAMIC
+    stepperE0.push();
+  #endif
+  #if E1_IS_TRINAMIC
+    stepperE1.push();
+  #endif
+  #if E2_IS_TRINAMIC
+    stepperE2.push();
+  #endif
+  #if E3_IS_TRINAMIC
+    stepperE3.push();
+  #endif
+  #if E4_IS_TRINAMIC
+    stepperE4.push();
+  #endif
+}
+
+void reset_stepper_drivers() {
+  #if ENABLED(HAVE_TMC26X)
+    tmc26x_init_to_defaults();
+  #endif
+  #if ENABLED(HAVE_TMC2130)
+    delay(100);
+    tmc2130_init_to_defaults();
+  #endif
+  #if ENABLED(HAVE_TMC2208)
+    delay(100);
+    tmc2208_init_to_defaults();
+  #endif
+  #ifdef TMC_ADV
+    TMC_ADV()
+  #endif
+  #if ENABLED(HAVE_L6470DRIVER)
+    L6470_init_to_defaults();
+  #endif
+}
+
 //
 // L6470 Driver objects and inits
 //
@@ -538,7 +588,7 @@
     stepper##A.setStallCurrent(A##_STALLCURRENT); \
   }while(0)
 
-  void L6470_init() {
+  void L6470_init_to_defaults() {
     #if ENABLED(X_IS_L6470)
       _L6470_INIT(X);
     #endif
@@ -575,4 +625,3 @@
   }
 
 #endif // HAVE_L6470DRIVER
-

commit 1e946d681da353a70cc1e74055dbbfe78f5e64c1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Mar 15 21:03:12 2018 -0500

    Update Marlin for newest TMC libraries
    
    - TMC2130Stepper v2.2.0
    - TMC2208Stepper v0.0.4

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 7caa1fb938..e92ad8826c 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -188,8 +188,8 @@
     st.off_time(5); // Only enables the driver if used with stealthChop
     st.interpolate(INTERPOLATE);
     st.power_down_delay(128); // ~2s until driver lowers to hold current
-    st.hysterisis_start(3);
-    st.hysterisis_end(2);
+    st.hysteresis_start(3);
+    st.hysteresis_end(2);
     st.diag1_active_high(1); // For sensorless homing
     #if ENABLED(STEALTHCHOP)
       st.stealth_freq(1); // f_pwm = 2/683 f_clk
@@ -406,8 +406,8 @@
     st.toff(5);
     st.intpol(INTERPOLATE);
     st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
-    st.hysterisis_start(3);
-    st.hysterisis_end(2);
+    st.hysteresis_start(3);
+    st.hysteresis_end(2);
     #if ENABLED(STEALTHCHOP)
       st.pwm_lim(12);
       st.pwm_reg(8);

commit e7570f3195189f3b6df31faff629da33c8f9f625
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 13 02:06:40 2018 -0500

    Improve TMC config organization, naming

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index f3f70b3863..7caa1fb938 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -38,8 +38,7 @@
 //
 // TMC26X Driver objects and inits
 //
-#if ENABLED(HAVE_TMCDRIVER)
-
+#if ENABLED(HAVE_TMC26X)
   #include <SPI.h>
 
   #ifdef STM32F7
@@ -50,37 +49,37 @@
 
   #define _TMC_DEFINE(ST) TMC26XStepper stepper##ST(200, ST##_ENABLE_PIN, ST##_STEP_PIN, ST##_DIR_PIN, ST##_MAX_CURRENT, ST##_SENSE_RESISTOR)
 
-  #if ENABLED(X_IS_TMC)
+  #if ENABLED(X_IS_TMC26X)
     _TMC_DEFINE(X);
   #endif
-  #if ENABLED(X2_IS_TMC)
+  #if ENABLED(X2_IS_TMC26X)
     _TMC_DEFINE(X2);
   #endif
-  #if ENABLED(Y_IS_TMC)
+  #if ENABLED(Y_IS_TMC26X)
     _TMC_DEFINE(Y);
   #endif
-  #if ENABLED(Y2_IS_TMC)
+  #if ENABLED(Y2_IS_TMC26X)
     _TMC_DEFINE(Y2);
   #endif
-  #if ENABLED(Z_IS_TMC)
+  #if ENABLED(Z_IS_TMC26X)
     _TMC_DEFINE(Z);
   #endif
-  #if ENABLED(Z2_IS_TMC)
+  #if ENABLED(Z2_IS_TMC26X)
     _TMC_DEFINE(Z2);
   #endif
-  #if ENABLED(E0_IS_TMC)
+  #if ENABLED(E0_IS_TMC26X)
     _TMC_DEFINE(E0);
   #endif
-  #if ENABLED(E1_IS_TMC)
+  #if ENABLED(E1_IS_TMC26X)
     _TMC_DEFINE(E1);
   #endif
-  #if ENABLED(E2_IS_TMC)
+  #if ENABLED(E2_IS_TMC26X)
     _TMC_DEFINE(E2);
   #endif
-  #if ENABLED(E3_IS_TMC)
+  #if ENABLED(E3_IS_TMC26X)
     _TMC_DEFINE(E3);
   #endif
-  #if ENABLED(E4_IS_TMC)
+  #if ENABLED(E4_IS_TMC26X)
     _TMC_DEFINE(E4);
   #endif
 
@@ -89,43 +88,43 @@
     stepper##A.start(); \
   }while(0)
 
-  void tmc_init() {
-    #if ENABLED(X_IS_TMC)
+  void tmc26x_init() {
+    #if ENABLED(X_IS_TMC26X)
       _TMC_INIT(X);
     #endif
-    #if ENABLED(X2_IS_TMC)
+    #if ENABLED(X2_IS_TMC26X)
       _TMC_INIT(X2);
     #endif
-    #if ENABLED(Y_IS_TMC)
+    #if ENABLED(Y_IS_TMC26X)
       _TMC_INIT(Y);
     #endif
-    #if ENABLED(Y2_IS_TMC)
+    #if ENABLED(Y2_IS_TMC26X)
       _TMC_INIT(Y2);
     #endif
-    #if ENABLED(Z_IS_TMC)
+    #if ENABLED(Z_IS_TMC26X)
       _TMC_INIT(Z);
     #endif
-    #if ENABLED(Z2_IS_TMC)
+    #if ENABLED(Z2_IS_TMC26X)
       _TMC_INIT(Z2);
     #endif
-    #if ENABLED(E0_IS_TMC)
+    #if ENABLED(E0_IS_TMC26X)
       _TMC_INIT(E0);
     #endif
-    #if ENABLED(E1_IS_TMC)
+    #if ENABLED(E1_IS_TMC26X)
       _TMC_INIT(E1);
     #endif
-    #if ENABLED(E2_IS_TMC)
+    #if ENABLED(E2_IS_TMC26X)
       _TMC_INIT(E2);
     #endif
-    #if ENABLED(E3_IS_TMC)
+    #if ENABLED(E3_IS_TMC26X)
       _TMC_INIT(E3);
     #endif
-    #if ENABLED(E4_IS_TMC)
+    #if ENABLED(E4_IS_TMC26X)
       _TMC_INIT(E4);
     #endif
   }
 
-#endif // HAVE_TMCDRIVER
+#endif // HAVE_TMC26X
 
 //
 // TMC2130 Driver objects and inits

commit e1fd9c08b33be7073dbcfe57b88cd6f724aa34df
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sat Feb 3 19:33:26 2018 -0600

    [2.0.x] Add support for LPC1769 at 120 MHz (#9423)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index bee6fdde44..f3f70b3863 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -235,16 +235,32 @@
       _TMC2130_INIT(E0, planner.axis_steps_per_mm[E_AXIS]);
     #endif
     #if ENABLED(E1_IS_TMC2130)
-      { constexpr int extruder = 1; _TMC2130_INIT(E1, planner.axis_steps_per_mm[E_AXIS_N]); }
+      _TMC2130_INIT(E1, planner.axis_steps_per_mm[E_AXIS
+        #if ENABLED(DISTINCT_E_FACTORS)
+          + 1
+        #endif
+      ]);
     #endif
     #if ENABLED(E2_IS_TMC2130)
-      { constexpr int extruder = 2; _TMC2130_INIT(E2, planner.axis_steps_per_mm[E_AXIS_N]); }
+      _TMC2130_INIT(E2, planner.axis_steps_per_mm[E_AXIS
+        #if ENABLED(DISTINCT_E_FACTORS)
+          + 2
+        #endif
+      ]);
     #endif
     #if ENABLED(E3_IS_TMC2130)
-      { constexpr int extruder = 3; _TMC2130_INIT(E3, planner.axis_steps_per_mm[E_AXIS_N]); }
+      _TMC2130_INIT(E3, planner.axis_steps_per_mm[E_AXIS
+        #if ENABLED(DISTINCT_E_FACTORS)
+          + 3
+        #endif
+      ]);
     #endif
     #if ENABLED(E4_IS_TMC2130)
-      { constexpr int extruder = 4; _TMC2130_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N]); }
+      _TMC2130_INIT(E4, planner.axis_steps_per_mm[E_AXIS
+        #if ENABLED(DISTINCT_E_FACTORS)
+          + 4
+        #endif
+      ]);
     #endif
 
   }
@@ -440,16 +456,32 @@
       _TMC2208_INIT(E0, planner.axis_steps_per_mm[E_AXIS]);
     #endif
     #if ENABLED(E1_IS_TMC2208)
-      { constexpr int extruder = 1; _TMC2208_INIT(E1, planner.axis_steps_per_mm[E_AXIS_N]); }
+      _TMC2208_INIT(E1, planner.axis_steps_per_mm[E_AXIS
+        #if ENABLED(DISTINCT_E_FACTORS)
+          + 1
+        #endif
+      ]);
     #endif
     #if ENABLED(E2_IS_TMC2208)
-      { constexpr int extruder = 2; _TMC2208_INIT(E2, planner.axis_steps_per_mm[E_AXIS_N]); }
+      _TMC2208_INIT(E2, planner.axis_steps_per_mm[E_AXIS
+        #if ENABLED(DISTINCT_E_FACTORS)
+          + 2
+        #endif
+      ]);
     #endif
     #if ENABLED(E3_IS_TMC2208)
-      { constexpr int extruder = 3; _TMC2208_INIT(E3, planner.axis_steps_per_mm[E_AXIS_N]); }
+      _TMC2208_INIT(E3, planner.axis_steps_per_mm[E_AXIS
+        #if ENABLED(DISTINCT_E_FACTORS)
+          + 3
+        #endif
+      ]);
     #endif
     #if ENABLED(E4_IS_TMC2208)
-      { constexpr int extruder = 4; _TMC2208_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N]); }
+      _TMC2208_INIT(E4, planner.axis_steps_per_mm[E_AXIS
+        #if ENABLED(DISTINCT_E_FACTORS)
+          + 4
+        #endif
+      ]);
     #endif
   }
 #endif // HAVE_TMC2208

commit 5c69d45f5bc96d6cc122813baa3e2a76b5a87580
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Feb 2 05:49:40 2018 +0200

    [2.0.x] TMC2130 support for LPC platform (#9114)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 4e685da74e..bee6fdde44 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -137,7 +137,11 @@
   #include "planner.h"
   #include "../core/enum.h"
 
-  #define _TMC2130_DEFINE(ST) TMC2130Stepper stepper##ST(ST##_ENABLE_PIN, ST##_DIR_PIN, ST##_STEP_PIN, ST##_CS_PIN)
+  #if ENABLED(TMC_USE_SW_SPI)
+    #define _TMC2130_DEFINE(ST) TMC2130Stepper stepper##ST(ST##_ENABLE_PIN, ST##_DIR_PIN, ST##_STEP_PIN, ST##_CS_PIN, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
+  #else
+    #define _TMC2130_DEFINE(ST) TMC2130Stepper stepper##ST(ST##_ENABLE_PIN, ST##_DIR_PIN, ST##_STEP_PIN, ST##_CS_PIN)
+  #endif
 
   // Stepper objects of TMC2130 steppers used
   #if ENABLED(X_IS_TMC2130)

commit 3217da6fa527c25ec83f87df6ac81d38968b4d4d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 23 13:59:51 2018 -0600

    Followup patch for TMC stepper init

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 4efd406ea5..4e685da74e 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -258,7 +258,7 @@
 
   #define _TMC2208_DEFINE_HARDWARE(ST) TMC2208Stepper stepper##ST(&ST##_HARDWARE_SERIAL)
   #define _TMC2208_DEFINE_SOFTWARE(ST) SoftwareSerial ST##_HARDWARE_SERIAL = SoftwareSerial(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN); \
-                                       TMC2208Stepper stepper##ST(&stepper##ST##_serial, ST##_SERIAL_RX_PIN > -1)
+                                       TMC2208Stepper stepper##ST(&ST##_HARDWARE_SERIAL, ST##_SERIAL_RX_PIN > -1)
 
   // Stepper objects of TMC2208 steppers used
   #if ENABLED(X_IS_TMC2208)

commit db031d5d768246a8576c74ba8f67cc30411a6133
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 22 10:24:30 2018 -0600

    Add missing SoftwareSerial begin for TMC2208
    
    Based on #9299

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index d83b2d011d..4efd406ea5 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -257,82 +257,82 @@
   #include "planner.h"
 
   #define _TMC2208_DEFINE_HARDWARE(ST) TMC2208Stepper stepper##ST(&ST##_HARDWARE_SERIAL)
-  #define _TMC2208_DEFINE_SOFTWARE(ST) SoftwareSerial stepper##ST##_serial = SoftwareSerial(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN); \
+  #define _TMC2208_DEFINE_SOFTWARE(ST) SoftwareSerial ST##_HARDWARE_SERIAL = SoftwareSerial(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN); \
                                        TMC2208Stepper stepper##ST(&stepper##ST##_serial, ST##_SERIAL_RX_PIN > -1)
 
   // Stepper objects of TMC2208 steppers used
   #if ENABLED(X_IS_TMC2208)
-    #if defined(X_HARDWARE_SERIAL)
+    #ifdef X_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(X);
     #else
       _TMC2208_DEFINE_SOFTWARE(X);
     #endif
   #endif
   #if ENABLED(X2_IS_TMC2208)
-    #if defined(X2_HARDWARE_SERIAL)
+    #ifdef X2_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(X2);
     #else
       _TMC2208_DEFINE_SOFTWARE(X2);
     #endif
   #endif
   #if ENABLED(Y_IS_TMC2208)
-    #if defined(Y_HARDWARE_SERIAL)
+    #ifdef Y_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(Y);
     #else
       _TMC2208_DEFINE_SOFTWARE(Y);
     #endif
   #endif
   #if ENABLED(Y2_IS_TMC2208)
-    #if defined(Y2_HARDWARE_SERIAL)
+    #ifdef Y2_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(Y2);
     #else
       _TMC2208_DEFINE_SOFTWARE(Y2);
     #endif
   #endif
   #if ENABLED(Z_IS_TMC2208)
-    #if defined(Z_HARDWARE_SERIAL)
+    #ifdef Z_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(Z);
     #else
       _TMC2208_DEFINE_SOFTWARE(Z);
     #endif
   #endif
   #if ENABLED(Z2_IS_TMC2208)
-    #if defined(Z2_HARDWARE_SERIAL)
+    #ifdef Z2_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(Z2);
     #else
       _TMC2208_DEFINE_SOFTWARE(Z2);
     #endif
   #endif
   #if ENABLED(E0_IS_TMC2208)
-    #if defined(E0_HARDWARE_SERIAL)
+    #ifdef E0_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(E0);
     #else
       _TMC2208_DEFINE_SOFTWARE(E0);
     #endif
   #endif
   #if ENABLED(E1_IS_TMC2208)
-    #if defined(E1_HARDWARE_SERIAL)
+    #ifdef E1_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(E1);
     #else
       _TMC2208_DEFINE_SOFTWARE(E1);
     #endif
   #endif
   #if ENABLED(E2_IS_TMC2208)
-    #if defined(E2_HARDWARE_SERIAL)
+    #ifdef E2_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(E2);
     #else
       _TMC2208_DEFINE_SOFTWARE(E2);
     #endif
   #endif
   #if ENABLED(E3_IS_TMC2208)
-    #if defined(E3_HARDWARE_SERIAL)
+    #ifdef E3_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(E3);
     #else
       _TMC2208_DEFINE_SOFTWARE(E3);
     #endif
   #endif
   #if ENABLED(E4_IS_TMC2208)
-    #if defined(E4_HARDWARE_SERIAL)
+    #ifdef E4_HARDWARE_SERIAL
       _TMC2208_DEFINE_HARDWARE(E4);
     #else
       _TMC2208_DEFINE_SOFTWARE(E4);
@@ -340,38 +340,38 @@
   #endif
 
   void tmc2208_serial_begin() {
-    #if ENABLED(X_IS_TMC2208) && defined(X_HARDWARE_SERIAL)
-      X_HARDWARE_SERIAL.begin(250000);
+    #if ENABLED(X_IS_TMC2208)
+      X_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(X2_IS_TMC2208) && defined(X2_HARDWARE_SERIAL)
-      X2_HARDWARE_SERIAL.begin(250000);
+    #if ENABLED(X2_IS_TMC2208)
+      X2_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(Y_IS_TMC2208) && defined(Y_HARDWARE_SERIAL)
-      Y_HARDWARE_SERIAL.begin(250000);
+    #if ENABLED(Y_IS_TMC2208)
+      Y_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(Y2_IS_TMC2208) && defined(Y2_HARDWARE_SERIAL)
-      Y2_HARDWARE_SERIAL.begin(250000);
+    #if ENABLED(Y2_IS_TMC2208)
+      Y2_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(Z_IS_TMC2208) && defined(Z_HARDWARE_SERIAL)
-      Z_HARDWARE_SERIAL.begin(250000);
+    #if ENABLED(Z_IS_TMC2208)
+      Z_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(Z2_IS_TMC2208) && defined(Z2_HARDWARE_SERIAL)
-      Z2_HARDWARE_SERIAL.begin(250000);
+    #if ENABLED(Z2_IS_TMC2208)
+      Z2_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(E0_IS_TMC2208) && defined(E0_HARDWARE_SERIAL)
-      E0_HARDWARE_SERIAL.begin(250000);
+    #if ENABLED(E0_IS_TMC2208)
+      E0_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(E1_IS_TMC2208) && defined(E1_HARDWARE_SERIAL)
-      E1_HARDWARE_SERIAL.begin(250000);
+    #if ENABLED(E1_IS_TMC2208)
+      E1_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(E2_IS_TMC2208) && defined(E2_HARDWARE_SERIAL)
-      E2_HARDWARE_SERIAL.begin(250000);
+    #if ENABLED(E2_IS_TMC2208)
+      E2_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(E3_IS_TMC2208) && defined(E3_HARDWARE_SERIAL)
-      E3_HARDWARE_SERIAL.begin(250000);
+    #if ENABLED(E3_IS_TMC2208)
+      E3_HARDWARE_SERIAL.begin(115200);
     #endif
-    #if ENABLED(E4_IS_TMC2208) && defined(E4_HARDWARE_SERIAL)
-      E4_HARDWARE_SERIAL.begin(250000);
+    #if ENABLED(E4_IS_TMC2208)
+      E4_HARDWARE_SERIAL.begin(115200);
     #endif
   }
 
@@ -450,7 +450,6 @@
   }
 #endif // HAVE_TMC2208
 
-
 //
 // L6470 Driver objects and inits
 //

commit 382a5e3318406d8081551cf11eb91fa1f41c8088
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jan 21 17:13:56 2018 -0600

    Clean up trailing whitespace

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 0fb97957dd..d83b2d011d 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -41,7 +41,7 @@
 #if ENABLED(HAVE_TMCDRIVER)
 
   #include <SPI.h>
-  
+
   #ifdef STM32F7
     #include "../HAL/HAL_STM32F7/TMC2660.h"
   #else

commit 42933c804a08740b47a341623783be52182f477b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 15 02:28:39 2018 -0600

    Cleanups for STM32F7

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 85a9114cde..0fb97957dd 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -42,7 +42,7 @@
 
   #include <SPI.h>
   
-  #if defined(STM32F7)
+  #ifdef STM32F7
     #include "../HAL/HAL_STM32F7/TMC2660.h"
   #else
     #include <TMC26XStepper.h>

commit a0246c5c96954f3dbd60083f237b68687356ff24
Author: Morten <familien_enholm@hotmail.com>
Date:   Thu Jan 11 22:29:08 2018 +0100

    Add support for STM32F7 MCU

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index b8f5af6633..85a9114cde 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -41,7 +41,12 @@
 #if ENABLED(HAVE_TMCDRIVER)
 
   #include <SPI.h>
-  #include <TMC26XStepper.h>
+  
+  #if defined(STM32F7)
+    #include "../HAL/HAL_STM32F7/TMC2660.h"
+  #else
+    #include <TMC26XStepper.h>
+  #endif
 
   #define _TMC_DEFINE(ST) TMC26XStepper stepper##ST(200, ST##_ENABLE_PIN, ST##_STEP_PIN, ST##_DIR_PIN, ST##_MAX_CURRENT, ST##_SENSE_RESISTOR)
 

commit 0cd1e91056213d6a0bd422848ccff7cd1191d001
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 15 23:03:14 2017 +0200

    [2.0.x] TMC driver update (#8769)

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 4f3ede7ef4..b8f5af6633 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -129,6 +129,7 @@
 
   #include <SPI.h>
   #include <TMC2130Stepper.h>
+  #include "planner.h"
   #include "../core/enum.h"
 
   #define _TMC2130_DEFINE(ST) TMC2130Stepper stepper##ST(ST##_ENABLE_PIN, ST##_DIR_PIN, ST##_STEP_PIN, ST##_CS_PIN)
@@ -171,17 +172,17 @@
   // Use internal reference voltage for current calculations. This is the default.
   // Following values from Trinamic's spreadsheet with values for a NEMA17 (42BYGHW609)
   // https://www.trinamic.com/products/integrated-circuits/details/tmc2130/
-  void tmc2130_init(TMC2130Stepper &st, const uint16_t microsteps, const uint32_t thrs, const float &spmm) {
+  void tmc2130_init(TMC2130Stepper &st, const uint16_t microsteps, const uint32_t thrs, const float spmm) {
     st.begin();
     st.setCurrent(st.getCurrent(), R_SENSE, HOLD_MULTIPLIER);
     st.microsteps(microsteps);
-    st.blank_time(36);
+    st.blank_time(24);
     st.off_time(5); // Only enables the driver if used with stealthChop
     st.interpolate(INTERPOLATE);
     st.power_down_delay(128); // ~2s until driver lowers to hold current
-    st.hysterisis_start(0); // HSTRT = 1
-    st.hysterisis_low(1); // HEND = -2
-    st.diag1_active_high(0); // For sensorless homing
+    st.hysterisis_start(3);
+    st.hysterisis_end(2);
+    st.diag1_active_high(1); // For sensorless homing
     #if ENABLED(STEALTHCHOP)
       st.stealth_freq(1); // f_pwm = 2/683 f_clk
       st.stealth_autoscale(1);
@@ -189,61 +190,261 @@
       st.stealth_amplitude(255);
       st.stealthChop(1);
       #if ENABLED(HYBRID_THRESHOLD)
-        st.stealth_max_speed(12650000UL*st.microsteps()/(256*thrs*spmm));
+        st.stealth_max_speed(12650000UL*microsteps/(256*thrs*spmm));
+      #else
+        UNUSED(thrs);
+        UNUSED(spmm);
       #endif
     #elif ENABLED(SENSORLESS_HOMING)
       st.coolstep_min_speed(1024UL * 1024UL - 1UL);
     #endif
+    st.GSTAT(); // Clear GSTAT
   }
 
   #define _TMC2130_INIT(ST, SPMM) tmc2130_init(stepper##ST, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, SPMM)
 
   void tmc2130_init() {
-    constexpr float steps_per_mm[] = DEFAULT_AXIS_STEPS_PER_UNIT;
     #if ENABLED(X_IS_TMC2130)
-      _TMC2130_INIT( X, steps_per_mm[X_AXIS]);
-      #if ENABLED(SENSORLESS_HOMING)
-        stepperX.sg_stall_value(X_HOMING_SENSITIVITY);
-      #endif
+      _TMC2130_INIT( X, planner.axis_steps_per_mm[X_AXIS]);
     #endif
     #if ENABLED(X2_IS_TMC2130)
-      _TMC2130_INIT(X2, steps_per_mm[X_AXIS]);
+      _TMC2130_INIT(X2, planner.axis_steps_per_mm[X_AXIS]);
     #endif
     #if ENABLED(Y_IS_TMC2130)
-      _TMC2130_INIT( Y, steps_per_mm[Y_AXIS]);
-      #if ENABLED(SENSORLESS_HOMING)
-        stepperY.sg_stall_value(Y_HOMING_SENSITIVITY);
-      #endif
+      _TMC2130_INIT( Y, planner.axis_steps_per_mm[Y_AXIS]);
     #endif
     #if ENABLED(Y2_IS_TMC2130)
-      _TMC2130_INIT(Y2, steps_per_mm[Y_AXIS]);
+      _TMC2130_INIT(Y2, planner.axis_steps_per_mm[Y_AXIS]);
     #endif
     #if ENABLED(Z_IS_TMC2130)
-      _TMC2130_INIT( Z, steps_per_mm[Z_AXIS]);
+      _TMC2130_INIT( Z, planner.axis_steps_per_mm[Z_AXIS]);
     #endif
     #if ENABLED(Z2_IS_TMC2130)
-      _TMC2130_INIT(Z2, steps_per_mm[Z_AXIS]);
+      _TMC2130_INIT(Z2, planner.axis_steps_per_mm[Z_AXIS]);
     #endif
     #if ENABLED(E0_IS_TMC2130)
-      _TMC2130_INIT(E0, steps_per_mm[E_AXIS]);
+      _TMC2130_INIT(E0, planner.axis_steps_per_mm[E_AXIS]);
     #endif
     #if ENABLED(E1_IS_TMC2130)
-      { constexpr int extruder = 1; _TMC2130_INIT(E1, steps_per_mm[E_AXIS_N]); }
+      { constexpr int extruder = 1; _TMC2130_INIT(E1, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
     #if ENABLED(E2_IS_TMC2130)
-      { constexpr int extruder = 2; _TMC2130_INIT(E2, steps_per_mm[E_AXIS_N]); }
+      { constexpr int extruder = 2; _TMC2130_INIT(E2, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
     #if ENABLED(E3_IS_TMC2130)
-      { constexpr int extruder = 3; _TMC2130_INIT(E3, steps_per_mm[E_AXIS_N]); }
+      { constexpr int extruder = 3; _TMC2130_INIT(E3, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
     #if ENABLED(E4_IS_TMC2130)
-      { constexpr int extruder = 4; _TMC2130_INIT(E4, steps_per_mm[E_AXIS_N]); }
+      { constexpr int extruder = 4; _TMC2130_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N]); }
     #endif
 
-    TMC2130_ADV()
   }
 #endif // HAVE_TMC2130
 
+//
+// TMC2208 Driver objects and inits
+//
+#if ENABLED(HAVE_TMC2208)
+
+  #include <SoftwareSerial.h>
+  #include <HardwareSerial.h>
+  #include <TMC2208Stepper.h>
+  #include "planner.h"
+
+  #define _TMC2208_DEFINE_HARDWARE(ST) TMC2208Stepper stepper##ST(&ST##_HARDWARE_SERIAL)
+  #define _TMC2208_DEFINE_SOFTWARE(ST) SoftwareSerial stepper##ST##_serial = SoftwareSerial(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN); \
+                                       TMC2208Stepper stepper##ST(&stepper##ST##_serial, ST##_SERIAL_RX_PIN > -1)
+
+  // Stepper objects of TMC2208 steppers used
+  #if ENABLED(X_IS_TMC2208)
+    #if defined(X_HARDWARE_SERIAL)
+      _TMC2208_DEFINE_HARDWARE(X);
+    #else
+      _TMC2208_DEFINE_SOFTWARE(X);
+    #endif
+  #endif
+  #if ENABLED(X2_IS_TMC2208)
+    #if defined(X2_HARDWARE_SERIAL)
+      _TMC2208_DEFINE_HARDWARE(X2);
+    #else
+      _TMC2208_DEFINE_SOFTWARE(X2);
+    #endif
+  #endif
+  #if ENABLED(Y_IS_TMC2208)
+    #if defined(Y_HARDWARE_SERIAL)
+      _TMC2208_DEFINE_HARDWARE(Y);
+    #else
+      _TMC2208_DEFINE_SOFTWARE(Y);
+    #endif
+  #endif
+  #if ENABLED(Y2_IS_TMC2208)
+    #if defined(Y2_HARDWARE_SERIAL)
+      _TMC2208_DEFINE_HARDWARE(Y2);
+    #else
+      _TMC2208_DEFINE_SOFTWARE(Y2);
+    #endif
+  #endif
+  #if ENABLED(Z_IS_TMC2208)
+    #if defined(Z_HARDWARE_SERIAL)
+      _TMC2208_DEFINE_HARDWARE(Z);
+    #else
+      _TMC2208_DEFINE_SOFTWARE(Z);
+    #endif
+  #endif
+  #if ENABLED(Z2_IS_TMC2208)
+    #if defined(Z2_HARDWARE_SERIAL)
+      _TMC2208_DEFINE_HARDWARE(Z2);
+    #else
+      _TMC2208_DEFINE_SOFTWARE(Z2);
+    #endif
+  #endif
+  #if ENABLED(E0_IS_TMC2208)
+    #if defined(E0_HARDWARE_SERIAL)
+      _TMC2208_DEFINE_HARDWARE(E0);
+    #else
+      _TMC2208_DEFINE_SOFTWARE(E0);
+    #endif
+  #endif
+  #if ENABLED(E1_IS_TMC2208)
+    #if defined(E1_HARDWARE_SERIAL)
+      _TMC2208_DEFINE_HARDWARE(E1);
+    #else
+      _TMC2208_DEFINE_SOFTWARE(E1);
+    #endif
+  #endif
+  #if ENABLED(E2_IS_TMC2208)
+    #if defined(E2_HARDWARE_SERIAL)
+      _TMC2208_DEFINE_HARDWARE(E2);
+    #else
+      _TMC2208_DEFINE_SOFTWARE(E2);
+    #endif
+  #endif
+  #if ENABLED(E3_IS_TMC2208)
+    #if defined(E3_HARDWARE_SERIAL)
+      _TMC2208_DEFINE_HARDWARE(E3);
+    #else
+      _TMC2208_DEFINE_SOFTWARE(E3);
+    #endif
+  #endif
+  #if ENABLED(E4_IS_TMC2208)
+    #if defined(E4_HARDWARE_SERIAL)
+      _TMC2208_DEFINE_HARDWARE(E4);
+    #else
+      _TMC2208_DEFINE_SOFTWARE(E4);
+    #endif
+  #endif
+
+  void tmc2208_serial_begin() {
+    #if ENABLED(X_IS_TMC2208) && defined(X_HARDWARE_SERIAL)
+      X_HARDWARE_SERIAL.begin(250000);
+    #endif
+    #if ENABLED(X2_IS_TMC2208) && defined(X2_HARDWARE_SERIAL)
+      X2_HARDWARE_SERIAL.begin(250000);
+    #endif
+    #if ENABLED(Y_IS_TMC2208) && defined(Y_HARDWARE_SERIAL)
+      Y_HARDWARE_SERIAL.begin(250000);
+    #endif
+    #if ENABLED(Y2_IS_TMC2208) && defined(Y2_HARDWARE_SERIAL)
+      Y2_HARDWARE_SERIAL.begin(250000);
+    #endif
+    #if ENABLED(Z_IS_TMC2208) && defined(Z_HARDWARE_SERIAL)
+      Z_HARDWARE_SERIAL.begin(250000);
+    #endif
+    #if ENABLED(Z2_IS_TMC2208) && defined(Z2_HARDWARE_SERIAL)
+      Z2_HARDWARE_SERIAL.begin(250000);
+    #endif
+    #if ENABLED(E0_IS_TMC2208) && defined(E0_HARDWARE_SERIAL)
+      E0_HARDWARE_SERIAL.begin(250000);
+    #endif
+    #if ENABLED(E1_IS_TMC2208) && defined(E1_HARDWARE_SERIAL)
+      E1_HARDWARE_SERIAL.begin(250000);
+    #endif
+    #if ENABLED(E2_IS_TMC2208) && defined(E2_HARDWARE_SERIAL)
+      E2_HARDWARE_SERIAL.begin(250000);
+    #endif
+    #if ENABLED(E3_IS_TMC2208) && defined(E3_HARDWARE_SERIAL)
+      E3_HARDWARE_SERIAL.begin(250000);
+    #endif
+    #if ENABLED(E4_IS_TMC2208) && defined(E4_HARDWARE_SERIAL)
+      E4_HARDWARE_SERIAL.begin(250000);
+    #endif
+  }
+
+  // Use internal reference voltage for current calculations. This is the default.
+  // Following values from Trinamic's spreadsheet with values for a NEMA17 (42BYGHW609)
+  void tmc2208_init(TMC2208Stepper &st, const uint16_t microsteps, const uint32_t thrs, const float spmm) {
+    st.pdn_disable(true); // Use UART
+    st.mstep_reg_select(true); // Select microsteps with UART
+    st.I_scale_analog(false);
+    st.rms_current(st.getCurrent(), HOLD_MULTIPLIER, R_SENSE);
+    st.microsteps(microsteps);
+    st.blank_time(24);
+    st.toff(5);
+    st.intpol(INTERPOLATE);
+    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
+    st.hysterisis_start(3);
+    st.hysterisis_end(2);
+    #if ENABLED(STEALTHCHOP)
+      st.pwm_lim(12);
+      st.pwm_reg(8);
+      st.pwm_autograd(1);
+      st.pwm_autoscale(1);
+      st.pwm_freq(1);
+      st.pwm_grad(14);
+      st.pwm_ofs(36);
+      st.en_spreadCycle(false);
+      #if ENABLED(HYBRID_THRESHOLD)
+        st.TPWMTHRS(12650000UL*microsteps/(256*thrs*spmm));
+      #else
+        UNUSED(thrs);
+        UNUSED(spmm);
+      #endif
+    #else
+      st.en_spreadCycle(true);
+    #endif
+    st.GSTAT(0b111); // Clear
+    delay(200);
+  }
+
+  #define _TMC2208_INIT(ST, SPMM) tmc2208_init(stepper##ST, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, SPMM)
+
+  void tmc2208_init() {
+    #if ENABLED(X_IS_TMC2208)
+      _TMC2208_INIT(X, planner.axis_steps_per_mm[X_AXIS]);
+    #endif
+    #if ENABLED(X2_IS_TMC2208)
+      _TMC2208_INIT(X2, planner.axis_steps_per_mm[X_AXIS]);
+    #endif
+    #if ENABLED(Y_IS_TMC2208)
+      _TMC2208_INIT(Y, planner.axis_steps_per_mm[Y_AXIS]);
+    #endif
+    #if ENABLED(Y2_IS_TMC2208)
+      _TMC2208_INIT(Y2, planner.axis_steps_per_mm[Y_AXIS]);
+    #endif
+    #if ENABLED(Z_IS_TMC2208)
+      _TMC2208_INIT(Z, planner.axis_steps_per_mm[Z_AXIS]);
+    #endif
+    #if ENABLED(Z2_IS_TMC2208)
+      _TMC2208_INIT(Z2, planner.axis_steps_per_mm[Z_AXIS]);
+    #endif
+    #if ENABLED(E0_IS_TMC2208)
+      _TMC2208_INIT(E0, planner.axis_steps_per_mm[E_AXIS]);
+    #endif
+    #if ENABLED(E1_IS_TMC2208)
+      { constexpr int extruder = 1; _TMC2208_INIT(E1, planner.axis_steps_per_mm[E_AXIS_N]); }
+    #endif
+    #if ENABLED(E2_IS_TMC2208)
+      { constexpr int extruder = 2; _TMC2208_INIT(E2, planner.axis_steps_per_mm[E_AXIS_N]); }
+    #endif
+    #if ENABLED(E3_IS_TMC2208)
+      { constexpr int extruder = 3; _TMC2208_INIT(E3, planner.axis_steps_per_mm[E_AXIS_N]); }
+    #endif
+    #if ENABLED(E4_IS_TMC2208)
+      { constexpr int extruder = 4; _TMC2208_INIT(E4, planner.axis_steps_per_mm[E_AXIS_N]); }
+    #endif
+  }
+#endif // HAVE_TMC2208
+
 
 //
 // L6470 Driver objects and inits

commit 70be4d206e32de92b1d89e9b92348defcb48bede
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Nov 3 11:48:15 2017 +0200

    [2.0.x] UltiMachine Archim2 (#8190)
    
    * UltiMachine Archim2 support
    
    * SPI gets included by the library
    
    * Invert TMC2130 diag pin state
    
    * Clean up Archim2 pins
    
    * Update Archim2 config
    
    * FAN2 -> FAN1
    
    * Cleanup
    
    * Add brief Archim installation instructions
    
    * Bring pins into compliance
    
    * Update 1.0 SD Detect pin for 1.1
    
    * Update Configuration.h
    
    * Update pins_ARCHIM2.h

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index fb86f34954..4f3ede7ef4 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -181,7 +181,7 @@
     st.power_down_delay(128); // ~2s until driver lowers to hold current
     st.hysterisis_start(0); // HSTRT = 1
     st.hysterisis_low(1); // HEND = -2
-    st.diag1_active_high(1); // For sensorless homing
+    st.diag1_active_high(0); // For sensorless homing
     #if ENABLED(STEALTHCHOP)
       st.stealth_freq(1); // f_pwm = 2/683 f_clk
       st.stealth_autoscale(1);

commit 038f82cc38613aca79cd2ece2ded535f0d9b1c1c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 7 03:36:39 2017 -0500

    Fix L6470 init and options

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 7ddfb244f2..fb86f34954 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -291,7 +291,7 @@
   #endif
 
   #define _L6470_INIT(A) do{ \
-    stepper##A.init(A##_K_VAL); \
+    stepper##A.init(); \
     stepper##A.softFree(); \
     stepper##A.setMicroSteps(A##_MICROSTEPS); \
     stepper##A.setOverCurrent(A##_OVERCURRENT); \

commit 3d8a0ab4b215a3869a0388e5c0ef35a6372ed7d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:32 2017 -0500

    Module updates

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
index 9e9d3bf996..7ddfb244f2 100644
--- a/Marlin/src/module/stepper_indirection.cpp
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -33,7 +33,7 @@
 
 #include "stepper_indirection.h"
 
-#include "MarlinConfig.h"
+#include "../inc/MarlinConfig.h"
 
 //
 // TMC26X Driver objects and inits
@@ -129,7 +129,7 @@
 
   #include <SPI.h>
   #include <TMC2130Stepper.h>
-  #include "enum.h"
+  #include "../core/enum.h"
 
   #define _TMC2130_DEFINE(ST) TMC2130Stepper stepper##ST(ST##_ENABLE_PIN, ST##_DIR_PIN, ST##_STEP_PIN, ST##_CS_PIN)
 

commit 0c9231fd04798c30830513a0cad8b204a6b9633f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:30 2017 -0500

    Move 'module' files

diff --git a/Marlin/src/module/stepper_indirection.cpp b/Marlin/src/module/stepper_indirection.cpp
new file mode 100644
index 0000000000..9e9d3bf996
--- /dev/null
+++ b/Marlin/src/module/stepper_indirection.cpp
@@ -0,0 +1,338 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * stepper_indirection.cpp
+ *
+ * Stepper motor driver indirection to allow some stepper functions to
+ * be done via SPI/I2c instead of direct pin manipulation.
+ *
+ * Part of Marlin
+ *
+ * Copyright (c) 2015 Dominik Wenger
+ */
+
+#include "stepper_indirection.h"
+
+#include "MarlinConfig.h"
+
+//
+// TMC26X Driver objects and inits
+//
+#if ENABLED(HAVE_TMCDRIVER)
+
+  #include <SPI.h>
+  #include <TMC26XStepper.h>
+
+  #define _TMC_DEFINE(ST) TMC26XStepper stepper##ST(200, ST##_ENABLE_PIN, ST##_STEP_PIN, ST##_DIR_PIN, ST##_MAX_CURRENT, ST##_SENSE_RESISTOR)
+
+  #if ENABLED(X_IS_TMC)
+    _TMC_DEFINE(X);
+  #endif
+  #if ENABLED(X2_IS_TMC)
+    _TMC_DEFINE(X2);
+  #endif
+  #if ENABLED(Y_IS_TMC)
+    _TMC_DEFINE(Y);
+  #endif
+  #if ENABLED(Y2_IS_TMC)
+    _TMC_DEFINE(Y2);
+  #endif
+  #if ENABLED(Z_IS_TMC)
+    _TMC_DEFINE(Z);
+  #endif
+  #if ENABLED(Z2_IS_TMC)
+    _TMC_DEFINE(Z2);
+  #endif
+  #if ENABLED(E0_IS_TMC)
+    _TMC_DEFINE(E0);
+  #endif
+  #if ENABLED(E1_IS_TMC)
+    _TMC_DEFINE(E1);
+  #endif
+  #if ENABLED(E2_IS_TMC)
+    _TMC_DEFINE(E2);
+  #endif
+  #if ENABLED(E3_IS_TMC)
+    _TMC_DEFINE(E3);
+  #endif
+  #if ENABLED(E4_IS_TMC)
+    _TMC_DEFINE(E4);
+  #endif
+
+  #define _TMC_INIT(A) do{ \
+    stepper##A.setMicrosteps(A##_MICROSTEPS); \
+    stepper##A.start(); \
+  }while(0)
+
+  void tmc_init() {
+    #if ENABLED(X_IS_TMC)
+      _TMC_INIT(X);
+    #endif
+    #if ENABLED(X2_IS_TMC)
+      _TMC_INIT(X2);
+    #endif
+    #if ENABLED(Y_IS_TMC)
+      _TMC_INIT(Y);
+    #endif
+    #if ENABLED(Y2_IS_TMC)
+      _TMC_INIT(Y2);
+    #endif
+    #if ENABLED(Z_IS_TMC)
+      _TMC_INIT(Z);
+    #endif
+    #if ENABLED(Z2_IS_TMC)
+      _TMC_INIT(Z2);
+    #endif
+    #if ENABLED(E0_IS_TMC)
+      _TMC_INIT(E0);
+    #endif
+    #if ENABLED(E1_IS_TMC)
+      _TMC_INIT(E1);
+    #endif
+    #if ENABLED(E2_IS_TMC)
+      _TMC_INIT(E2);
+    #endif
+    #if ENABLED(E3_IS_TMC)
+      _TMC_INIT(E3);
+    #endif
+    #if ENABLED(E4_IS_TMC)
+      _TMC_INIT(E4);
+    #endif
+  }
+
+#endif // HAVE_TMCDRIVER
+
+//
+// TMC2130 Driver objects and inits
+//
+#if ENABLED(HAVE_TMC2130)
+
+  #include <SPI.h>
+  #include <TMC2130Stepper.h>
+  #include "enum.h"
+
+  #define _TMC2130_DEFINE(ST) TMC2130Stepper stepper##ST(ST##_ENABLE_PIN, ST##_DIR_PIN, ST##_STEP_PIN, ST##_CS_PIN)
+
+  // Stepper objects of TMC2130 steppers used
+  #if ENABLED(X_IS_TMC2130)
+    _TMC2130_DEFINE(X);
+  #endif
+  #if ENABLED(X2_IS_TMC2130)
+    _TMC2130_DEFINE(X2);
+  #endif
+  #if ENABLED(Y_IS_TMC2130)
+    _TMC2130_DEFINE(Y);
+  #endif
+  #if ENABLED(Y2_IS_TMC2130)
+    _TMC2130_DEFINE(Y2);
+  #endif
+  #if ENABLED(Z_IS_TMC2130)
+    _TMC2130_DEFINE(Z);
+  #endif
+  #if ENABLED(Z2_IS_TMC2130)
+    _TMC2130_DEFINE(Z2);
+  #endif
+  #if ENABLED(E0_IS_TMC2130)
+    _TMC2130_DEFINE(E0);
+  #endif
+  #if ENABLED(E1_IS_TMC2130)
+    _TMC2130_DEFINE(E1);
+  #endif
+  #if ENABLED(E2_IS_TMC2130)
+    _TMC2130_DEFINE(E2);
+  #endif
+  #if ENABLED(E3_IS_TMC2130)
+    _TMC2130_DEFINE(E3);
+  #endif
+  #if ENABLED(E4_IS_TMC2130)
+    _TMC2130_DEFINE(E4);
+  #endif
+
+  // Use internal reference voltage for current calculations. This is the default.
+  // Following values from Trinamic's spreadsheet with values for a NEMA17 (42BYGHW609)
+  // https://www.trinamic.com/products/integrated-circuits/details/tmc2130/
+  void tmc2130_init(TMC2130Stepper &st, const uint16_t microsteps, const uint32_t thrs, const float &spmm) {
+    st.begin();
+    st.setCurrent(st.getCurrent(), R_SENSE, HOLD_MULTIPLIER);
+    st.microsteps(microsteps);
+    st.blank_time(36);
+    st.off_time(5); // Only enables the driver if used with stealthChop
+    st.interpolate(INTERPOLATE);
+    st.power_down_delay(128); // ~2s until driver lowers to hold current
+    st.hysterisis_start(0); // HSTRT = 1
+    st.hysterisis_low(1); // HEND = -2
+    st.diag1_active_high(1); // For sensorless homing
+    #if ENABLED(STEALTHCHOP)
+      st.stealth_freq(1); // f_pwm = 2/683 f_clk
+      st.stealth_autoscale(1);
+      st.stealth_gradient(5);
+      st.stealth_amplitude(255);
+      st.stealthChop(1);
+      #if ENABLED(HYBRID_THRESHOLD)
+        st.stealth_max_speed(12650000UL*st.microsteps()/(256*thrs*spmm));
+      #endif
+    #elif ENABLED(SENSORLESS_HOMING)
+      st.coolstep_min_speed(1024UL * 1024UL - 1UL);
+    #endif
+  }
+
+  #define _TMC2130_INIT(ST, SPMM) tmc2130_init(stepper##ST, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, SPMM)
+
+  void tmc2130_init() {
+    constexpr float steps_per_mm[] = DEFAULT_AXIS_STEPS_PER_UNIT;
+    #if ENABLED(X_IS_TMC2130)
+      _TMC2130_INIT( X, steps_per_mm[X_AXIS]);
+      #if ENABLED(SENSORLESS_HOMING)
+        stepperX.sg_stall_value(X_HOMING_SENSITIVITY);
+      #endif
+    #endif
+    #if ENABLED(X2_IS_TMC2130)
+      _TMC2130_INIT(X2, steps_per_mm[X_AXIS]);
+    #endif
+    #if ENABLED(Y_IS_TMC2130)
+      _TMC2130_INIT( Y, steps_per_mm[Y_AXIS]);
+      #if ENABLED(SENSORLESS_HOMING)
+        stepperY.sg_stall_value(Y_HOMING_SENSITIVITY);
+      #endif
+    #endif
+    #if ENABLED(Y2_IS_TMC2130)
+      _TMC2130_INIT(Y2, steps_per_mm[Y_AXIS]);
+    #endif
+    #if ENABLED(Z_IS_TMC2130)
+      _TMC2130_INIT( Z, steps_per_mm[Z_AXIS]);
+    #endif
+    #if ENABLED(Z2_IS_TMC2130)
+      _TMC2130_INIT(Z2, steps_per_mm[Z_AXIS]);
+    #endif
+    #if ENABLED(E0_IS_TMC2130)
+      _TMC2130_INIT(E0, steps_per_mm[E_AXIS]);
+    #endif
+    #if ENABLED(E1_IS_TMC2130)
+      { constexpr int extruder = 1; _TMC2130_INIT(E1, steps_per_mm[E_AXIS_N]); }
+    #endif
+    #if ENABLED(E2_IS_TMC2130)
+      { constexpr int extruder = 2; _TMC2130_INIT(E2, steps_per_mm[E_AXIS_N]); }
+    #endif
+    #if ENABLED(E3_IS_TMC2130)
+      { constexpr int extruder = 3; _TMC2130_INIT(E3, steps_per_mm[E_AXIS_N]); }
+    #endif
+    #if ENABLED(E4_IS_TMC2130)
+      { constexpr int extruder = 4; _TMC2130_INIT(E4, steps_per_mm[E_AXIS_N]); }
+    #endif
+
+    TMC2130_ADV()
+  }
+#endif // HAVE_TMC2130
+
+
+//
+// L6470 Driver objects and inits
+//
+#if ENABLED(HAVE_L6470DRIVER)
+
+  #include <SPI.h>
+  #include <L6470.h>
+
+  #define _L6470_DEFINE(ST) L6470 stepper##ST(ST##_ENABLE_PIN)
+
+  // L6470 Stepper objects
+  #if ENABLED(X_IS_L6470)
+    _L6470_DEFINE(X);
+  #endif
+  #if ENABLED(X2_IS_L6470)
+    _L6470_DEFINE(X2);
+  #endif
+  #if ENABLED(Y_IS_L6470)
+    _L6470_DEFINE(Y);
+  #endif
+  #if ENABLED(Y2_IS_L6470)
+    _L6470_DEFINE(Y2);
+  #endif
+  #if ENABLED(Z_IS_L6470)
+    _L6470_DEFINE(Z);
+  #endif
+  #if ENABLED(Z2_IS_L6470)
+    _L6470_DEFINE(Z2);
+  #endif
+  #if ENABLED(E0_IS_L6470)
+    _L6470_DEFINE(E0);
+  #endif
+  #if ENABLED(E1_IS_L6470)
+    _L6470_DEFINE(E1);
+  #endif
+  #if ENABLED(E2_IS_L6470)
+    _L6470_DEFINE(E2);
+  #endif
+  #if ENABLED(E3_IS_L6470)
+    _L6470_DEFINE(E3);
+  #endif
+  #if ENABLED(E4_IS_L6470)
+    _L6470_DEFINE(E4);
+  #endif
+
+  #define _L6470_INIT(A) do{ \
+    stepper##A.init(A##_K_VAL); \
+    stepper##A.softFree(); \
+    stepper##A.setMicroSteps(A##_MICROSTEPS); \
+    stepper##A.setOverCurrent(A##_OVERCURRENT); \
+    stepper##A.setStallCurrent(A##_STALLCURRENT); \
+  }while(0)
+
+  void L6470_init() {
+    #if ENABLED(X_IS_L6470)
+      _L6470_INIT(X);
+    #endif
+    #if ENABLED(X2_IS_L6470)
+      _L6470_INIT(X2);
+    #endif
+    #if ENABLED(Y_IS_L6470)
+      _L6470_INIT(Y);
+    #endif
+    #if ENABLED(Y2_IS_L6470)
+      _L6470_INIT(Y2);
+    #endif
+    #if ENABLED(Z_IS_L6470)
+      _L6470_INIT(Z);
+    #endif
+    #if ENABLED(Z2_IS_L6470)
+      _L6470_INIT(Z2);
+    #endif
+    #if ENABLED(E0_IS_L6470)
+      _L6470_INIT(E0);
+    #endif
+    #if ENABLED(E1_IS_L6470)
+      _L6470_INIT(E1);
+    #endif
+    #if ENABLED(E2_IS_L6470)
+      _L6470_INIT(E2);
+    #endif
+    #if ENABLED(E3_IS_L6470)
+      _L6470_INIT(E3);
+    #endif
+    #if ENABLED(E4_IS_L6470)
+      _L6470_INIT(E4);
+    #endif
+  }
+
+#endif // HAVE_L6470DRIVER
+
