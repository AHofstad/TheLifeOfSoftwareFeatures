commit ba08dcfb76804a912380603b3f69831ea0d1d6eb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 3 04:40:07 2023 -0500

    üßë‚Äçüíª Fix narrowing conversions (#25924)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 1a2b6eb23a..053a68b77d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -61,7 +61,7 @@
       const xyze_pos_t &start = current_position, &end = destination;
     #endif
 
-    const xy_int8_t istart = cell_indexes(start), iend = cell_indexes(end);
+    const xy_uint8_t istart = cell_indexes(start), iend = cell_indexes(end);
 
     // A move within the same cell needs no splitting
     if (istart == iend) {
@@ -108,7 +108,7 @@
 
     const xy_float_t dist = end - start;
     const xy_bool_t neg { dist.x < 0, dist.y < 0 };
-    const xy_int8_t ineg { int8_t(neg.x), int8_t(neg.y) };
+    const xy_uint8_t ineg { uint8_t(neg.x), uint8_t(neg.y) };
     const xy_float_t sign { neg.x ? -1.0f : 1.0f, neg.y ? -1.0f : 1.0f };
     const xy_int8_t iadd { int8_t(iend.x == istart.x ? 0 : sign.x), int8_t(iend.y == istart.y ? 0 : sign.y) };
 
@@ -131,7 +131,7 @@
       const bool inf_normalized_flag = isinf(e_normalized_dist);
     #endif
 
-    xy_int8_t icell = istart;
+    xy_uint8_t icell = istart;
 
     const float ratio = dist.y / dist.x,        // Allow divide by zero
                 c = start.y - ratio * start.x;
@@ -252,7 +252,7 @@
      * Generic case of a line crossing both X and Y Mesh lines.
      */
 
-    xy_int8_t cnt = (istart - iend).ABS();
+    xy_uint8_t cnt = istart.diff(iend);
 
     icell += ineg;
 

commit 7717beb79362522b8239d5af62b32ff3d0e2d748
Author: kadir ilkimen <kadirilkimen@gmail.com>
Date:   Wed Jan 11 06:29:38 2023 +0200

    ‚ú® Polar Kinematics (#25214)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 96c30a0efd..1a2b6eb23a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -334,16 +334,14 @@
 #else // UBL_SEGMENTED
 
   #if IS_SCARA
-    #define DELTA_SEGMENT_MIN_LENGTH 0.25 // SCARA minimum segment size is 0.25mm
-  #elif ENABLED(DELTA)
-    #define DELTA_SEGMENT_MIN_LENGTH 0.10 // mm (still subject to DEFAULT_SEGMENTS_PER_SECOND)
-  #elif ENABLED(POLARGRAPH)
-    #define DELTA_SEGMENT_MIN_LENGTH 0.10 // mm (still subject to DEFAULT_SEGMENTS_PER_SECOND)
+    #define SEGMENT_MIN_LENGTH 0.25 // SCARA minimum segment size is 0.25mm
+  #elif IS_KINEMATIC
+    #define SEGMENT_MIN_LENGTH 0.10 // (mm) Still subject to DEFAULT_SEGMENTS_PER_SECOND
   #else // CARTESIAN
     #ifdef LEVELED_SEGMENT_LENGTH
-      #define DELTA_SEGMENT_MIN_LENGTH LEVELED_SEGMENT_LENGTH
+      #define SEGMENT_MIN_LENGTH LEVELED_SEGMENT_LENGTH
     #else
-      #define DELTA_SEGMENT_MIN_LENGTH 1.00 // mm (similar to G2/G3 arc segmentation)
+      #define SEGMENT_MIN_LENGTH 1.00 // (mm) Similar to G2/G3 arc segmentation
     #endif
   #endif
 
@@ -361,23 +359,23 @@
     const xyze_pos_t total = destination - current_position;
 
     const float cart_xy_mm_2 = HYPOT2(total.x, total.y),
-                cart_xy_mm = SQRT(cart_xy_mm_2);                                     // Total XY distance
+                cart_xy_mm = SQRT(cart_xy_mm_2);                               // Total XY distance
 
     #if IS_KINEMATIC
-      const float seconds = cart_xy_mm / scaled_fr_mm_s;                             // Duration of XY move at requested rate
-      uint16_t segments = LROUND(segments_per_second * seconds),                     // Preferred number of segments for distance @ feedrate
-               seglimit = LROUND(cart_xy_mm * RECIPROCAL(DELTA_SEGMENT_MIN_LENGTH)); // Number of segments at minimum segment length
-      NOMORE(segments, seglimit);                                                    // Limit to minimum segment length (fewer segments)
+      const float seconds = cart_xy_mm / scaled_fr_mm_s;                       // Duration of XY move at requested rate
+      uint16_t segments = LROUND(segments_per_second * seconds),               // Preferred number of segments for distance @ feedrate
+               seglimit = LROUND(cart_xy_mm * RECIPROCAL(SEGMENT_MIN_LENGTH)); // Number of segments at minimum segment length
+      NOMORE(segments, seglimit);                                              // Limit to minimum segment length (fewer segments)
     #else
-      uint16_t segments = LROUND(cart_xy_mm * RECIPROCAL(DELTA_SEGMENT_MIN_LENGTH)); // Cartesian fixed segment length
+      uint16_t segments = LROUND(cart_xy_mm * RECIPROCAL(SEGMENT_MIN_LENGTH)); // Cartesian fixed segment length
     #endif
 
-    NOLESS(segments, 1U);                                                            // Must have at least one segment
-    const float inv_segments = 1.0f / segments;                                      // Reciprocal to save calculation
+    NOLESS(segments, 1U);                                                      // Must have at least one segment
+    const float inv_segments = 1.0f / segments;                                // Reciprocal to save calculation
 
     // Add hints to help optimize the move
-    PlannerHints hints(SQRT(cart_xy_mm_2 + sq(total.z)) * inv_segments);             // Length of each segment
-    #if ENABLED(SCARA_FEEDRATE_SCALING)
+    PlannerHints hints(SQRT(cart_xy_mm_2 + sq(total.z)) * inv_segments);       // Length of each segment
+    #if ENABLED(FEEDRATE_SCALING)
       hints.inv_duration = scaled_fr_mm_s / hints.millimeters;
     #endif
 

commit 74474c8a818745f1324aa5e22e59c361b4dff609
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Nov 26 19:21:47 2022 +1300

    üîß Fix TPARA (‚Ä¶SCARA, DELTA) settings (#25016)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 56c48650f1..96c30a0efd 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -336,9 +336,9 @@
   #if IS_SCARA
     #define DELTA_SEGMENT_MIN_LENGTH 0.25 // SCARA minimum segment size is 0.25mm
   #elif ENABLED(DELTA)
-    #define DELTA_SEGMENT_MIN_LENGTH 0.10 // mm (still subject to DELTA_SEGMENTS_PER_SECOND)
+    #define DELTA_SEGMENT_MIN_LENGTH 0.10 // mm (still subject to DEFAULT_SEGMENTS_PER_SECOND)
   #elif ENABLED(POLARGRAPH)
-    #define DELTA_SEGMENT_MIN_LENGTH 0.10 // mm (still subject to DELTA_SEGMENTS_PER_SECOND)
+    #define DELTA_SEGMENT_MIN_LENGTH 0.10 // mm (still subject to DEFAULT_SEGMENTS_PER_SECOND)
   #else // CARTESIAN
     #ifdef LEVELED_SEGMENT_LENGTH
       #define DELTA_SEGMENT_MIN_LENGTH LEVELED_SEGMENT_LENGTH

commit c918e90b8d59e1789442e84418b18fbd965e9833
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Thu Aug 25 23:23:54 2022 -0500

    ü©π Constrain UBL within mesh bounds (#24631)
    
    Fixes #24630

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 18110c67fa..56c48650f1 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -423,10 +423,12 @@
       LIMIT(icell.x, 0, GRID_MAX_CELLS_X);
       LIMIT(icell.y, 0, GRID_MAX_CELLS_Y);
 
-      float z_x0y0 = z_values[icell.x  ][icell.y  ],  // z at lower left corner
-            z_x1y0 = z_values[icell.x+1][icell.y  ],  // z at upper left corner
-            z_x0y1 = z_values[icell.x  ][icell.y+1],  // z at lower right corner
-            z_x1y1 = z_values[icell.x+1][icell.y+1];  // z at upper right corner
+      const int8_t ncellx = _MIN(icell.x+1, GRID_MAX_CELLS_X),
+                   ncelly = _MIN(icell.y+1, GRID_MAX_CELLS_Y);
+      float z_x0y0 = z_values[icell.x][icell.y],  // z at lower left corner
+            z_x1y0 = z_values[ncellx ][icell.y],  // z at upper left corner
+            z_x0y1 = z_values[icell.x][ncelly ],  // z at lower right corner
+            z_x1y1 = z_values[ncellx ][ncelly ];  // z at upper right corner
 
       if (isnan(z_x0y0)) z_x0y0 = 0;              // ideally activating planner.leveling_active (G29 A)
       if (isnan(z_x1y0)) z_x1y0 = 0;              //   should refuse if any invalid mesh points

commit 21c48d9f927c81d7b7cf6fc3641ce01a831a16ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 27 04:24:50 2022 -0500

    üßë‚Äçüíª  Update planner/stepper includes

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 8121a0b9b5..18110c67fa 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -26,7 +26,6 @@
 
 #include "../bedlevel.h"
 #include "../../../module/planner.h"
-#include "../../../module/stepper.h"
 #include "../../../module/motion.h"
 
 #if ENABLED(DELTA)

commit 920799e38d192f056b76b25a35886f19543308e6
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Jul 8 20:41:39 2022 +0100

    ‚ö°Ô∏è Optimize G2-G3 Arcs (#24366)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 9fa2257dc8..8121a0b9b5 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -374,11 +374,12 @@
     #endif
 
     NOLESS(segments, 1U);                                                            // Must have at least one segment
-    const float inv_segments = 1.0f / segments,                                      // Reciprocal to save calculation
-                segment_xyz_mm = SQRT(cart_xy_mm_2 + sq(total.z)) * inv_segments;    // Length of each segment
+    const float inv_segments = 1.0f / segments;                                      // Reciprocal to save calculation
 
+    // Add hints to help optimize the move
+    PlannerHints hints(SQRT(cart_xy_mm_2 + sq(total.z)) * inv_segments);             // Length of each segment
     #if ENABLED(SCARA_FEEDRATE_SCALING)
-      const float inv_duration = scaled_fr_mm_s / segment_xyz_mm;
+      hints.inv_duration = scaled_fr_mm_s / hints.millimeters;
     #endif
 
     xyze_float_t diff = total * inv_segments;
@@ -392,13 +393,9 @@
     if (!planner.leveling_active || !planner.leveling_active_at_z(destination.z)) {
       while (--segments) {
         raw += diff;
-        planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, segment_xyz_mm
-          OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
-        );
+        planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, hints);
       }
-      planner.buffer_line(destination, scaled_fr_mm_s, active_extruder, segment_xyz_mm
-        OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
-      );
+      planner.buffer_line(destination, scaled_fr_mm_s, active_extruder, hints);
       return false; // Did not set current from destination
     }
 
@@ -467,7 +464,7 @@
           TERN_(ENABLE_LEVELING_FADE_HEIGHT, * fade_scaling_factor); // apply fade factor to interpolated height
 
         const float oldz = raw.z; raw.z += z_cxcy;
-        planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, segment_xyz_mm OPTARG(SCARA_FEEDRATE_SCALING, inv_duration) );
+        planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, hints);
         raw.z = oldz;
 
         if (segments == 0)                        // done with last segment

commit 884f7c7db9dbe7a7044bb2e97e59d91946f4a071
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 26 22:32:00 2022 -0500

    üìù  Note about UBL bad splits

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index e6eec0de63..9fa2257dc8 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -36,8 +36,18 @@
 #include "../../../MarlinCore.h"
 #include <math.h>
 
+//#define DEBUG_UBL_MOTION
+#define DEBUG_OUT ENABLED(DEBUG_UBL_MOTION)
+#include "../../../core/debug_out.h"
+
 #if !UBL_SEGMENTED
 
+  // TODO: The first and last parts of a move might result in very short segment(s)
+  //       after getting split on the cell boundary, so moves like that should not
+  //       get split. This will be most common for moves that start/end near the
+  //       corners of cells. To fix the issue, simply check if the start/end of the line
+  //       is very close to a cell boundary in advance and don't split the line there.
+
   void unified_bed_leveling::line_to_destination_cartesian(const_feedRate_t scaled_fr_mm_s, const uint8_t extruder) {
     /**
      * Much of the nozzle movement will be within the same cell. So we will do as little computation
@@ -176,7 +186,9 @@
           dest.z += z0;
           planner.buffer_segment(dest, scaled_fr_mm_s, extruder);
 
-        } //else printf("FIRST MOVE PRUNED  ");
+        }
+        else
+          DEBUG_ECHOLNPGM("[ubl] skip Y segment");
       }
 
       // At the final destination? Usually not, but when on a Y Mesh Line it's completed.
@@ -225,7 +237,9 @@
           dest.z += z0;
           if (!planner.buffer_segment(dest, scaled_fr_mm_s, extruder)) break;
 
-        } //else printf("FIRST MOVE PRUNED  ");
+        }
+        else
+          DEBUG_ECHOLNPGM("[ubl] skip Y segment");
       }
 
       if (xy_pos_t(current_position) != xy_pos_t(end))

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ‚ôªÔ∏è Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 3da4ed9809..e6eec0de63 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -76,8 +76,8 @@
       #endif
 
       // The distance is always MESH_X_DIST so multiply by the constant reciprocal.
-      const float xratio = (end.x - mesh_index_to_xpos(iend.x)) * RECIPROCAL(MESH_X_DIST),
-                  yratio = (end.y - mesh_index_to_ypos(iend.y)) * RECIPROCAL(MESH_Y_DIST),
+      const float xratio = (end.x - get_mesh_x(iend.x)) * RECIPROCAL(MESH_X_DIST),
+                  yratio = (end.y - get_mesh_y(iend.y)) * RECIPROCAL(MESH_Y_DIST),
                   z1 = z_values[iend.x][iend.y    ] + xratio * (z_values[iend.x + 1][iend.y    ] - z_values[iend.x][iend.y    ]),
                   z2 = z_values[iend.x][iend.y + 1] + xratio * (z_values[iend.x + 1][iend.y + 1] - z_values[iend.x][iend.y + 1]);
 
@@ -139,7 +139,7 @@
       icell.y += ineg.y;      // Line going down? Just go to the bottom.
       while (icell.y != iend.y + ineg.y) {
         icell.y += iadd.y;
-        const float next_mesh_line_y = mesh_index_to_ypos(icell.y);
+        const float next_mesh_line_y = get_mesh_y(icell.y);
 
         /**
          * Skip the calculations for an infinite slope.
@@ -155,7 +155,7 @@
         // Replace NAN corrections with 0.0 to prevent NAN propagation.
         if (isnan(z0)) z0 = 0.0;
 
-        dest.y = mesh_index_to_ypos(icell.y);
+        dest.y = get_mesh_y(icell.y);
 
         /**
          * Without this check, it's possible to generate a zero length move, as in the case where
@@ -196,7 +196,7 @@
 
       while (icell.x != iend.x + ineg.x) {
         icell.x += iadd.x;
-        dest.x = mesh_index_to_xpos(icell.x);
+        dest.x = get_mesh_x(icell.x);
         dest.y = ratio * dest.x + c;    // Calculate Y at the next X mesh line
 
         float z0 = z_correction_for_y_on_vertical_mesh_line(dest.y, icell.x, icell.y)
@@ -245,8 +245,8 @@
 
     while (cnt) {
 
-      const float next_mesh_line_x = mesh_index_to_xpos(icell.x + iadd.x),
-                  next_mesh_line_y = mesh_index_to_ypos(icell.y + iadd.y);
+      const float next_mesh_line_x = get_mesh_x(icell.x + iadd.x),
+                  next_mesh_line_y = get_mesh_y(icell.y + iadd.y);
 
       dest.y = ratio * next_mesh_line_x + c;    // Calculate Y at the next X mesh line
       dest.x = (next_mesh_line_y - c) / ratio;  // Calculate X at the next Y mesh line
@@ -423,7 +423,7 @@
       if (isnan(z_x0y1)) z_x0y1 = 0;              //   in order to avoid isnan tests per cell,
       if (isnan(z_x1y1)) z_x1y1 = 0;              //   thus guessing zero for undefined points
 
-      const xy_pos_t pos = { mesh_index_to_xpos(icell.x), mesh_index_to_ypos(icell.y) };
+      const xy_pos_t pos = { get_mesh_x(icell.x), get_mesh_y(icell.y) };
       xy_pos_t cell = raw - pos;
 
       const float z_xmy0 = (z_x1y0 - z_x0y0) * RECIPROCAL(MESH_X_DIST),   // z slope per x along y0 (lower left to lower right)
@@ -450,10 +450,7 @@
         if (--segments == 0) raw = destination;     // if this is last segment, use destination for exact
 
         const float z_cxcy = (z_cxy0 + z_cxym * cell.y) // interpolated mesh z height along cell.x at cell.y
-          #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-            * fade_scaling_factor                   // apply fade factor to interpolated mesh height
-          #endif
-        ;
+          TERN_(ENABLE_LEVELING_FADE_HEIGHT, * fade_scaling_factor); // apply fade factor to interpolated height
 
         const float oldz = raw.z; raw.z += z_cxcy;
         planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, segment_xyz_mm OPTARG(SCARA_FEEDRATE_SCALING, inv_duration) );

commit 659b4172aa49d82e54a08b5ed674b3ba4ad51fb0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 5 18:55:43 2022 -0500

    üî® Prevent build attribute define conflicts

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index f7e98c9fa7..3da4ed9809 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -340,7 +340,7 @@
    * Returns true if did NOT move, false if moved (requires current_position update).
    */
 
-  bool _O2 unified_bed_leveling::line_to_destination_segmented(const_feedRate_t scaled_fr_mm_s) {
+  bool __O2 unified_bed_leveling::line_to_destination_segmented(const_feedRate_t scaled_fr_mm_s) {
 
     if (!position_is_reachable(destination))  // fail if moving outside reachable boundary
       return true;                            // did not move, so current_position still accurate

commit 3344071f24b505d180dd1423b11510172c3f1c1c
Author: Dan Royer <dan@marginallyclever.com>
Date:   Mon Sep 20 13:42:33 2021 -0700

    Polargraph / Makelangelo kinematics (#22790)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index be5f6fee12..f7e98c9fa7 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -324,6 +324,8 @@
     #define DELTA_SEGMENT_MIN_LENGTH 0.25 // SCARA minimum segment size is 0.25mm
   #elif ENABLED(DELTA)
     #define DELTA_SEGMENT_MIN_LENGTH 0.10 // mm (still subject to DELTA_SEGMENTS_PER_SECOND)
+  #elif ENABLED(POLARGRAPH)
+    #define DELTA_SEGMENT_MIN_LENGTH 0.10 // mm (still subject to DELTA_SEGMENTS_PER_SECOND)
   #else // CARTESIAN
     #ifdef LEVELED_SEGMENT_LENGTH
       #define DELTA_SEGMENT_MIN_LENGTH LEVELED_SEGMENT_LENGTH

commit 323b38ee88dbf2a4691a20439dbb95a824822199
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 16 04:36:26 2021 -0500

    üí° Adjust headers, formatting

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 20408d8d1e..be5f6fee12 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -19,6 +19,7 @@
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
+
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 4af608cce4..20408d8d1e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -113,20 +113,22 @@
     const xy_float_t ad = sign * dist;
     const bool use_x_dist = ad.x > ad.y;
 
-    float on_axis_distance = use_x_dist ? dist.x : dist.y,
-          e_position = end.e - start.e,
-          z_position = end.z - start.z;
+    float on_axis_distance = use_x_dist ? dist.x : dist.y;
 
-    const float e_normalized_dist = e_position / on_axis_distance, // Allow divide by zero
-                z_normalized_dist = z_position / on_axis_distance;
+    const float z_normalized_dist = (end.z - start.z) / on_axis_distance; // Allow divide by zero
+    #if HAS_EXTRUDERS
+      const float e_normalized_dist = (end.e - start.e) / on_axis_distance;
+      const bool inf_normalized_flag = isinf(e_normalized_dist);
+    #endif
 
     xy_int8_t icell = istart;
 
     const float ratio = dist.y / dist.x,        // Allow divide by zero
                 c = start.y - ratio * start.x;
 
-    const bool inf_normalized_flag = isinf(e_normalized_dist),
-               inf_ratio_flag = isinf(ratio);
+    const bool inf_ratio_flag = isinf(ratio);
+
+    xyze_pos_t dest; // Stores XYZE for segmented moves
 
     /**
      * Handle vertical lines that stay within one column.
@@ -143,34 +145,36 @@
          * For others the next X is the same so this can continue.
          * Calculate X at the next Y mesh line.
          */
-        const float rx = inf_ratio_flag ? start.x : (next_mesh_line_y - c) / ratio;
+        dest.x = inf_ratio_flag ? start.x : (next_mesh_line_y - c) / ratio;
 
-        float z0 = z_correction_for_x_on_horizontal_mesh_line(rx, icell.x, icell.y)
+        float z0 = z_correction_for_x_on_horizontal_mesh_line(dest.x, icell.x, icell.y)
                    * planner.fade_scaling_factor_for_z(end.z);
 
         // Undefined parts of the Mesh in z_values[][] are NAN.
         // Replace NAN corrections with 0.0 to prevent NAN propagation.
         if (isnan(z0)) z0 = 0.0;
 
-        const float ry = mesh_index_to_ypos(icell.y);
+        dest.y = mesh_index_to_ypos(icell.y);
 
         /**
          * Without this check, it's possible to generate a zero length move, as in the case where
          * the line is heading down, starting exactly on a mesh line boundary. Since this is rare
          * it might be fine to remove this check and let planner.buffer_segment() filter it out.
          */
-        if (ry != start.y) {
+        if (dest.y != start.y) {
           if (!inf_normalized_flag) { // fall-through faster than branch
-            on_axis_distance = use_x_dist ? rx - start.x : ry - start.y;
-            e_position = start.e + on_axis_distance * e_normalized_dist;
-            z_position = start.z + on_axis_distance * z_normalized_dist;
+            on_axis_distance = use_x_dist ? dest.x - start.x : dest.y - start.y;
+            TERN_(HAS_EXTRUDERS, dest.e = start.e + on_axis_distance * e_normalized_dist);
+            dest.z = start.z + on_axis_distance * z_normalized_dist;
           }
           else {
-            e_position = end.e;
-            z_position = end.z;
+            TERN_(HAS_EXTRUDERS, dest.e = end.e);
+            dest.z = end.z;
           }
 
-          planner.buffer_segment(rx, ry, z_position + z0, e_position, scaled_fr_mm_s, extruder);
+          dest.z += z0;
+          planner.buffer_segment(dest, scaled_fr_mm_s, extruder);
+
         } //else printf("FIRST MOVE PRUNED  ");
       }
 
@@ -188,12 +192,13 @@
      */
     if (iadd.y == 0) {      // Horizontal line?
       icell.x += ineg.x;     // Heading left? Just go to the left edge of the cell for the first move.
+
       while (icell.x != iend.x + ineg.x) {
         icell.x += iadd.x;
-        const float rx = mesh_index_to_xpos(icell.x);
-        const float ry = ratio * rx + c;    // Calculate Y at the next X mesh line
+        dest.x = mesh_index_to_xpos(icell.x);
+        dest.y = ratio * dest.x + c;    // Calculate Y at the next X mesh line
 
-        float z0 = z_correction_for_y_on_vertical_mesh_line(ry, icell.x, icell.y)
+        float z0 = z_correction_for_y_on_vertical_mesh_line(dest.y, icell.x, icell.y)
                      * planner.fade_scaling_factor_for_z(end.z);
 
         // Undefined parts of the Mesh in z_values[][] are NAN.
@@ -205,19 +210,20 @@
          * the line is heading left, starting exactly on a mesh line boundary. Since this is rare
          * it might be fine to remove this check and let planner.buffer_segment() filter it out.
          */
-        if (rx != start.x) {
+        if (dest.x != start.x) {
           if (!inf_normalized_flag) {
-            on_axis_distance = use_x_dist ? rx - start.x : ry - start.y;
-            e_position = start.e + on_axis_distance * e_normalized_dist;  // is based on X or Y because this is a horizontal move
-            z_position = start.z + on_axis_distance * z_normalized_dist;
+            on_axis_distance = use_x_dist ? dest.x - start.x : dest.y - start.y;
+            TERN_(HAS_EXTRUDERS, dest.e = start.e + on_axis_distance * e_normalized_dist); // Based on X or Y because the move is horizontal
+            dest.z = start.z + on_axis_distance * z_normalized_dist;
           }
           else {
-            e_position = end.e;
-            z_position = end.z;
+            TERN_(HAS_EXTRUDERS, dest.e = end.e);
+            dest.z = end.z;
           }
 
-          if (!planner.buffer_segment(rx, ry, z_position + z0, e_position, scaled_fr_mm_s, extruder))
-            break;
+          dest.z += z0;
+          if (!planner.buffer_segment(dest, scaled_fr_mm_s, extruder)) break;
+
         } //else printf("FIRST MOVE PRUNED  ");
       }
 
@@ -239,57 +245,65 @@
     while (cnt) {
 
       const float next_mesh_line_x = mesh_index_to_xpos(icell.x + iadd.x),
-                  next_mesh_line_y = mesh_index_to_ypos(icell.y + iadd.y),
-                  ry = ratio * next_mesh_line_x + c,    // Calculate Y at the next X mesh line
-                  rx = (next_mesh_line_y - c) / ratio;  // Calculate X at the next Y mesh line
-                                                        // (No need to worry about ratio == 0.
-                                                        //  In that case, it was already detected
-                                                        //  as a vertical line move above.)
-
-      if (neg.x == (rx > next_mesh_line_x)) { // Check if we hit the Y line first
+                  next_mesh_line_y = mesh_index_to_ypos(icell.y + iadd.y);
+
+      dest.y = ratio * next_mesh_line_x + c;    // Calculate Y at the next X mesh line
+      dest.x = (next_mesh_line_y - c) / ratio;  // Calculate X at the next Y mesh line
+                                                // (No need to worry about ratio == 0.
+                                                //  In that case, it was already detected
+                                                //  as a vertical line move above.)
+
+      if (neg.x == (dest.x > next_mesh_line_x)) { // Check if we hit the Y line first
         // Yes!  Crossing a Y Mesh Line next
-        float z0 = z_correction_for_x_on_horizontal_mesh_line(rx, icell.x - ineg.x, icell.y + iadd.y)
+        float z0 = z_correction_for_x_on_horizontal_mesh_line(dest.x, icell.x - ineg.x, icell.y + iadd.y)
                    * planner.fade_scaling_factor_for_z(end.z);
 
         // Undefined parts of the Mesh in z_values[][] are NAN.
         // Replace NAN corrections with 0.0 to prevent NAN propagation.
         if (isnan(z0)) z0 = 0.0;
 
+        dest.y = next_mesh_line_y;
+
         if (!inf_normalized_flag) {
-          on_axis_distance = use_x_dist ? rx - start.x : next_mesh_line_y - start.y;
-          e_position = start.e + on_axis_distance * e_normalized_dist;
-          z_position = start.z + on_axis_distance * z_normalized_dist;
+          on_axis_distance = use_x_dist ? dest.x - start.x : dest.y - start.y;
+          TERN_(HAS_EXTRUDERS, dest.e = start.e + on_axis_distance * e_normalized_dist);
+          dest.z = start.z + on_axis_distance * z_normalized_dist;
         }
         else {
-          e_position = end.e;
-          z_position = end.z;
+          TERN_(HAS_EXTRUDERS, dest.e = end.e);
+          dest.z = end.z;
         }
-        if (!planner.buffer_segment(rx, next_mesh_line_y, z_position + z0, e_position, scaled_fr_mm_s, extruder))
-          break;
+
+        dest.z += z0;
+        if (!planner.buffer_segment(dest, scaled_fr_mm_s, extruder)) break;
+
         icell.y += iadd.y;
         cnt.y--;
       }
       else {
         // Yes!  Crossing a X Mesh Line next
-        float z0 = z_correction_for_y_on_vertical_mesh_line(ry, icell.x + iadd.x, icell.y - ineg.y)
+        float z0 = z_correction_for_y_on_vertical_mesh_line(dest.y, icell.x + iadd.x, icell.y - ineg.y)
                    * planner.fade_scaling_factor_for_z(end.z);
 
         // Undefined parts of the Mesh in z_values[][] are NAN.
         // Replace NAN corrections with 0.0 to prevent NAN propagation.
         if (isnan(z0)) z0 = 0.0;
 
+        dest.x = next_mesh_line_x;
+
         if (!inf_normalized_flag) {
-          on_axis_distance = use_x_dist ? next_mesh_line_x - start.x : ry - start.y;
-          e_position = start.e + on_axis_distance * e_normalized_dist;
-          z_position = start.z + on_axis_distance * z_normalized_dist;
+          on_axis_distance = use_x_dist ? dest.x - start.x : dest.y - start.y;
+          TERN_(HAS_EXTRUDERS, dest.e = start.e + on_axis_distance * e_normalized_dist);
+          dest.z = start.z + on_axis_distance * z_normalized_dist;
         }
         else {
-          e_position = end.e;
-          z_position = end.z;
+          TERN_(HAS_EXTRUDERS, dest.e = end.e);
+          dest.z = end.z;
         }
 
-        if (!planner.buffer_segment(next_mesh_line_x, ry, z_position + z0, e_position, scaled_fr_mm_s, extruder))
-          break;
+        dest.z += z0;
+        if (!planner.buffer_segment(dest, scaled_fr_mm_s, extruder)) break;
+
         icell.x += iadd.x;
         cnt.x--;
       }
@@ -438,11 +452,9 @@
           #endif
         ;
 
-        planner.buffer_line(raw.x, raw.y, raw.z + z_cxcy, raw.e, scaled_fr_mm_s, active_extruder, segment_xyz_mm
-          #if ENABLED(SCARA_FEEDRATE_SCALING)
-            , inv_duration
-          #endif
-        );
+        const float oldz = raw.z; raw.z += z_cxcy;
+        planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, segment_xyz_mm OPTARG(SCARA_FEEDRATE_SCALING, inv_duration) );
+        raw.z = oldz;
 
         if (segments == 0)                        // done with last segment
           return false;                           // didn't set current from destination

commit 84fd0eff17d089e3f75f6585d4bba47f15c00ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 23 21:33:22 2021 -0500

    üé® Macros for optional arguments (#21969)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 3ebc5fc2bd..4af608cce4 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -362,15 +362,11 @@
       while (--segments) {
         raw += diff;
         planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, segment_xyz_mm
-          #if ENABLED(SCARA_FEEDRATE_SCALING)
-            , inv_duration
-          #endif
+          OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
         );
       }
       planner.buffer_line(destination, scaled_fr_mm_s, active_extruder, segment_xyz_mm
-        #if ENABLED(SCARA_FEEDRATE_SCALING)
-          , inv_duration
-        #endif
+        OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
       );
       return false; // Did not set current from destination
     }

commit 528b9bd8729656d7ebcd3dc7898ceddc2f377354
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 16 02:43:59 2021 -0500

    Revert experimental NAN patch
    
    Hold changes from #21575 (24a095c) for more testing.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index cb3f7d3bbe..3ebc5fc2bd 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -85,7 +85,7 @@
 
       // Undefined parts of the Mesh in z_values[][] are NAN.
       // Replace NAN corrections with 0.0 to prevent NAN propagation.
-      if (!ISNAN(z0)) end.z += z0;
+      if (!isnan(z0)) end.z += z0;
       planner.buffer_segment(end, scaled_fr_mm_s, extruder);
       current_position = destination;
       return;
@@ -150,7 +150,7 @@
 
         // Undefined parts of the Mesh in z_values[][] are NAN.
         // Replace NAN corrections with 0.0 to prevent NAN propagation.
-        if (ISNAN(z0)) z0 = 0.0;
+        if (isnan(z0)) z0 = 0.0;
 
         const float ry = mesh_index_to_ypos(icell.y);
 
@@ -198,7 +198,7 @@
 
         // Undefined parts of the Mesh in z_values[][] are NAN.
         // Replace NAN corrections with 0.0 to prevent NAN propagation.
-        if (ISNAN(z0)) z0 = 0.0;
+        if (isnan(z0)) z0 = 0.0;
 
         /**
          * Without this check, it's possible to generate a zero length move, as in the case where
@@ -253,7 +253,7 @@
 
         // Undefined parts of the Mesh in z_values[][] are NAN.
         // Replace NAN corrections with 0.0 to prevent NAN propagation.
-        if (ISNAN(z0)) z0 = 0.0;
+        if (isnan(z0)) z0 = 0.0;
 
         if (!inf_normalized_flag) {
           on_axis_distance = use_x_dist ? rx - start.x : next_mesh_line_y - start.y;
@@ -276,7 +276,7 @@
 
         // Undefined parts of the Mesh in z_values[][] are NAN.
         // Replace NAN corrections with 0.0 to prevent NAN propagation.
-        if (ISNAN(z0)) z0 = 0.0;
+        if (isnan(z0)) z0 = 0.0;
 
         if (!inf_normalized_flag) {
           on_axis_distance = use_x_dist ? next_mesh_line_x - start.x : ry - start.y;
@@ -405,10 +405,10 @@
             z_x0y1 = z_values[icell.x  ][icell.y+1],  // z at lower right corner
             z_x1y1 = z_values[icell.x+1][icell.y+1];  // z at upper right corner
 
-      if (ISNAN(z_x0y0)) z_x0y0 = 0;              // ideally activating planner.leveling_active (G29 A)
-      if (ISNAN(z_x1y0)) z_x1y0 = 0;              //   should refuse if any invalid mesh points
-      if (ISNAN(z_x0y1)) z_x0y1 = 0;              //   in order to avoid ISNAN tests per cell,
-      if (ISNAN(z_x1y1)) z_x1y1 = 0;              //   thus guessing zero for undefined points
+      if (isnan(z_x0y0)) z_x0y0 = 0;              // ideally activating planner.leveling_active (G29 A)
+      if (isnan(z_x1y0)) z_x1y0 = 0;              //   should refuse if any invalid mesh points
+      if (isnan(z_x0y1)) z_x0y1 = 0;              //   in order to avoid isnan tests per cell,
+      if (isnan(z_x1y1)) z_x1y1 = 0;              //   thus guessing zero for undefined points
 
       const xy_pos_t pos = { mesh_index_to_xpos(icell.x), mesh_index_to_ypos(icell.y) };
       xy_pos_t cell = raw - pos;

commit 24a095c5c14b60bcbffc2807d2c8cc8e9af46e90
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 12 16:49:53 2021 -0500

    Reduce math library code size by 3.4KB (#21575)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 3ebc5fc2bd..cb3f7d3bbe 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -85,7 +85,7 @@
 
       // Undefined parts of the Mesh in z_values[][] are NAN.
       // Replace NAN corrections with 0.0 to prevent NAN propagation.
-      if (!isnan(z0)) end.z += z0;
+      if (!ISNAN(z0)) end.z += z0;
       planner.buffer_segment(end, scaled_fr_mm_s, extruder);
       current_position = destination;
       return;
@@ -150,7 +150,7 @@
 
         // Undefined parts of the Mesh in z_values[][] are NAN.
         // Replace NAN corrections with 0.0 to prevent NAN propagation.
-        if (isnan(z0)) z0 = 0.0;
+        if (ISNAN(z0)) z0 = 0.0;
 
         const float ry = mesh_index_to_ypos(icell.y);
 
@@ -198,7 +198,7 @@
 
         // Undefined parts of the Mesh in z_values[][] are NAN.
         // Replace NAN corrections with 0.0 to prevent NAN propagation.
-        if (isnan(z0)) z0 = 0.0;
+        if (ISNAN(z0)) z0 = 0.0;
 
         /**
          * Without this check, it's possible to generate a zero length move, as in the case where
@@ -253,7 +253,7 @@
 
         // Undefined parts of the Mesh in z_values[][] are NAN.
         // Replace NAN corrections with 0.0 to prevent NAN propagation.
-        if (isnan(z0)) z0 = 0.0;
+        if (ISNAN(z0)) z0 = 0.0;
 
         if (!inf_normalized_flag) {
           on_axis_distance = use_x_dist ? rx - start.x : next_mesh_line_y - start.y;
@@ -276,7 +276,7 @@
 
         // Undefined parts of the Mesh in z_values[][] are NAN.
         // Replace NAN corrections with 0.0 to prevent NAN propagation.
-        if (isnan(z0)) z0 = 0.0;
+        if (ISNAN(z0)) z0 = 0.0;
 
         if (!inf_normalized_flag) {
           on_axis_distance = use_x_dist ? next_mesh_line_x - start.x : ry - start.y;
@@ -405,10 +405,10 @@
             z_x0y1 = z_values[icell.x  ][icell.y+1],  // z at lower right corner
             z_x1y1 = z_values[icell.x+1][icell.y+1];  // z at upper right corner
 
-      if (isnan(z_x0y0)) z_x0y0 = 0;              // ideally activating planner.leveling_active (G29 A)
-      if (isnan(z_x1y0)) z_x1y0 = 0;              //   should refuse if any invalid mesh points
-      if (isnan(z_x0y1)) z_x0y1 = 0;              //   in order to avoid isnan tests per cell,
-      if (isnan(z_x1y1)) z_x1y1 = 0;              //   thus guessing zero for undefined points
+      if (ISNAN(z_x0y0)) z_x0y0 = 0;              // ideally activating planner.leveling_active (G29 A)
+      if (ISNAN(z_x1y0)) z_x1y0 = 0;              //   should refuse if any invalid mesh points
+      if (ISNAN(z_x0y1)) z_x0y1 = 0;              //   in order to avoid ISNAN tests per cell,
+      if (ISNAN(z_x1y1)) z_x1y1 = 0;              //   thus guessing zero for undefined points
 
       const xy_pos_t pos = { mesh_index_to_xpos(icell.x), mesh_index_to_ypos(icell.y) };
       xy_pos_t cell = raw - pos;

commit 45c1432946547cef4cbe9ac832394ff68526687d
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Thu Apr 1 18:12:00 2021 -0600

    G26 Hilbert Curve followup (#21480)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 4e522210d0..3ebc5fc2bd 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -397,8 +397,8 @@
         int8_t((raw.x - (MESH_MIN_X)) * RECIPROCAL(MESH_X_DIST)),
         int8_t((raw.y - (MESH_MIN_Y)) * RECIPROCAL(MESH_Y_DIST))
       };
-      LIMIT(icell.x, 0, (GRID_MAX_POINTS_X) - 1);
-      LIMIT(icell.y, 0, (GRID_MAX_POINTS_Y) - 1);
+      LIMIT(icell.x, 0, GRID_MAX_CELLS_X);
+      LIMIT(icell.y, 0, GRID_MAX_CELLS_Y);
 
       float z_x0y0 = z_values[icell.x  ][icell.y  ],  // z at lower left corner
             z_x1y0 = z_values[icell.x+1][icell.y  ],  // z at upper left corner

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 33b4f03ac2..4e522210d0 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -37,7 +37,7 @@
 
 #if !UBL_SEGMENTED
 
-  void unified_bed_leveling::line_to_destination_cartesian(const feedRate_t &scaled_fr_mm_s, const uint8_t extruder) {
+  void unified_bed_leveling::line_to_destination_cartesian(const_feedRate_t scaled_fr_mm_s, const uint8_t extruder) {
     /**
      * Much of the nozzle movement will be within the same cell. So we will do as little computation
      * as possible to determine if this is the case. If this move is within the same cell, we will
@@ -323,7 +323,7 @@
    * Returns true if did NOT move, false if moved (requires current_position update).
    */
 
-  bool _O2 unified_bed_leveling::line_to_destination_segmented(const feedRate_t &scaled_fr_mm_s) {
+  bool _O2 unified_bed_leveling::line_to_destination_segmented(const_feedRate_t scaled_fr_mm_s) {
 
     if (!position_is_reachable(destination))  // fail if moving outside reachable boundary
       return true;                            // did not move, so current_position still accurate

commit a0d312396adb089d31b1d4c1379d86dcd5b734ee
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Fri Mar 5 00:34:38 2021 +0100

    Followup to MP_SCARA/TPARA patches (#21248)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 8b7cd15a3c..33b4f03ac2 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -335,7 +335,7 @@
 
     #if IS_KINEMATIC
       const float seconds = cart_xy_mm / scaled_fr_mm_s;                             // Duration of XY move at requested rate
-      uint16_t segments = LROUND(delta_segments_per_second * seconds),               // Preferred number of segments for distance @ feedrate
+      uint16_t segments = LROUND(segments_per_second * seconds),                     // Preferred number of segments for distance @ feedrate
                seglimit = LROUND(cart_xy_mm * RECIPROCAL(DELTA_SEGMENT_MIN_LENGTH)); // Number of segments at minimum segment length
       NOMORE(segments, seglimit);                                                    // Limit to minimum segment length (fewer segments)
     #else

commit c1b900aae9d2b57c397d7687cb7ff1ed7edf9518
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Tue Dec 22 11:59:25 2020 +0000

    Fix UBL mesh inset Z position (#20538)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 010b5951be..8b7cd15a3c 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -56,39 +56,32 @@
     // A move within the same cell needs no splitting
     if (istart == iend) {
 
-      // For a move off the bed, use a constant Z raise
-      if (!WITHIN(iend.x, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iend.y, 0, GRID_MAX_POINTS_Y - 1)) {
+      FINAL_MOVE:
 
-        // Note: There is no Z Correction in this case. We are off the grid and don't know what
-        // a reasonable correction would be.  If the user has specified a UBL_Z_RAISE_WHEN_OFF_MESH
-        // value, that will be used instead of a calculated (Bi-Linear interpolation) correction.
+      // When UBL_Z_RAISE_WHEN_OFF_MESH is disabled Z correction is extrapolated from the edge of the mesh
+      #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
+        // For a move off the UBL mesh, use a constant Z raise
+        if (!cell_index_x_valid(end.x) || !cell_index_y_valid(end.y)) {
 
-        #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
-          end.z += UBL_Z_RAISE_WHEN_OFF_MESH;
-        #endif
-        planner.buffer_segment(end, scaled_fr_mm_s, extruder);
-        current_position = destination;
-        return;
-      }
+          // Note: There is no Z Correction in this case. We are off the mesh and don't know what
+          // a reasonable correction would be, UBL_Z_RAISE_WHEN_OFF_MESH will be used instead of
+          // a calculated (Bi-Linear interpolation) correction.
 
-      FINAL_MOVE:
+          end.z += UBL_Z_RAISE_WHEN_OFF_MESH;
+          planner.buffer_segment(end, scaled_fr_mm_s, extruder);
+          current_position = destination;
+          return;
+        }
+      #endif
 
       // The distance is always MESH_X_DIST so multiply by the constant reciprocal.
-      const float xratio = (end.x - mesh_index_to_xpos(iend.x)) * RECIPROCAL(MESH_X_DIST);
-
-      float z1, z2;
-      if (iend.x >= GRID_MAX_POINTS_X - 1)
-        z1 = z2 = 0.0;
-      else {
-        z1 = z_values[iend.x    ][iend.y    ] + xratio *
-            (z_values[iend.x + 1][iend.y    ] - z_values[iend.x][iend.y    ]),
-        z2 = z_values[iend.x    ][iend.y + 1] + xratio *
-            (z_values[iend.x + 1][iend.y + 1] - z_values[iend.x][iend.y + 1]);
-      }
+      const float xratio = (end.x - mesh_index_to_xpos(iend.x)) * RECIPROCAL(MESH_X_DIST),
+                  yratio = (end.y - mesh_index_to_ypos(iend.y)) * RECIPROCAL(MESH_Y_DIST),
+                  z1 = z_values[iend.x][iend.y    ] + xratio * (z_values[iend.x + 1][iend.y    ] - z_values[iend.x][iend.y    ]),
+                  z2 = z_values[iend.x][iend.y + 1] + xratio * (z_values[iend.x + 1][iend.y + 1] - z_values[iend.x][iend.y + 1]);
 
       // X cell-fraction done. Interpolate the two Z offsets with the Y fraction for the final Z offset.
-      const float yratio = (end.y - mesh_index_to_ypos(iend.y)) * RECIPROCAL(MESH_Y_DIST),
-                  z0 = iend.y < GRID_MAX_POINTS_Y - 1 ? (z1 + (z2 - z1) * yratio) * planner.fade_scaling_factor_for_z(end.z) : 0.0;
+      const float z0 = (z1 + (z2 - z1) * yratio) * planner.fade_scaling_factor_for_z(end.z);
 
       // Undefined parts of the Mesh in z_values[][] are NAN.
       // Replace NAN corrections with 0.0 to prevent NAN propagation.

commit 4424645e04c9e75462d36de8f7a82e67cc9c262e
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Mon Sep 28 21:53:50 2020 +0200

    Multi-line comments cleanup (#19535)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 63559e0bb8..010b5951be 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -236,9 +236,7 @@
     }
 
     /**
-     *
      * Generic case of a line crossing both X and Y Mesh lines.
-     *
      */
 
     xy_int8_t cnt = (istart - iend).ABS();

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 5364108240..63559e0bb8 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 #include "../../../inc/MarlinConfig.h"

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index f464d0fd6f..5364108240 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index a0d5518c45..f464d0fd6f 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -32,7 +32,7 @@
   #include "../../../module/delta.h"
 #endif
 
-#include "../../../Marlin.h"
+#include "../../../MarlinCore.h"
 #include <math.h>
 
 #if !UBL_SEGMENTED

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index fcce41169a..a0d5518c45 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -35,12 +35,6 @@
 #include "../../../Marlin.h"
 #include <math.h>
 
-#if AVR_AT90USB1286_FAMILY  // Teensyduino & Printrboard IDE extensions have compile errors without this
-  inline void set_current_from_destination() { COPY(current_position, destination); }
-#else
-  extern void set_current_from_destination();
-#endif
-
 #if !UBL_SEGMENTED
 
   void unified_bed_leveling::line_to_destination_cartesian(const feedRate_t &scaled_fr_mm_s, const uint8_t extruder) {
@@ -50,60 +44,57 @@
      * just do the required Z-Height correction, call the Planner's buffer_line() routine, and leave
      */
     #if HAS_POSITION_MODIFIERS
-      float start[XYZE] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS] },
-            end[XYZE] = { destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS] };
+      xyze_pos_t start = current_position, end = destination;
       planner.apply_modifiers(start);
       planner.apply_modifiers(end);
     #else
-      const float (&start)[XYZE] = current_position,
-                    (&end)[XYZE] = destination;
+      const xyze_pos_t &start = current_position, &end = destination;
     #endif
 
-    const int cell_start_xi = get_cell_index_x(start[X_AXIS]),
-              cell_start_yi = get_cell_index_y(start[Y_AXIS]),
-              cell_dest_xi  = get_cell_index_x(end[X_AXIS]),
-              cell_dest_yi  = get_cell_index_y(end[Y_AXIS]);
+    const xy_int8_t istart = cell_indexes(start), iend = cell_indexes(end);
 
     // A move within the same cell needs no splitting
-    if (cell_start_xi == cell_dest_xi && cell_start_yi == cell_dest_yi) {
+    if (istart == iend) {
 
       // For a move off the bed, use a constant Z raise
-      if (!WITHIN(cell_dest_xi, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(cell_dest_yi, 0, GRID_MAX_POINTS_Y - 1)) {
+      if (!WITHIN(iend.x, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iend.y, 0, GRID_MAX_POINTS_Y - 1)) {
 
         // Note: There is no Z Correction in this case. We are off the grid and don't know what
         // a reasonable correction would be.  If the user has specified a UBL_Z_RAISE_WHEN_OFF_MESH
         // value, that will be used instead of a calculated (Bi-Linear interpolation) correction.
 
-        const float z_raise = 0.0
-          #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
-            + UBL_Z_RAISE_WHEN_OFF_MESH
-          #endif
-        ;
-        planner.buffer_segment(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + z_raise, end[E_AXIS], scaled_fr_mm_s, extruder);
-        set_current_from_destination();
+        #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
+          end.z += UBL_Z_RAISE_WHEN_OFF_MESH;
+        #endif
+        planner.buffer_segment(end, scaled_fr_mm_s, extruder);
+        current_position = destination;
         return;
       }
 
       FINAL_MOVE:
 
       // The distance is always MESH_X_DIST so multiply by the constant reciprocal.
-      const float xratio = (end[X_AXIS] - mesh_index_to_xpos(cell_dest_xi)) * RECIPROCAL(MESH_X_DIST);
+      const float xratio = (end.x - mesh_index_to_xpos(iend.x)) * RECIPROCAL(MESH_X_DIST);
 
-      float z1 = z_values[cell_dest_xi    ][cell_dest_yi    ] + xratio *
-                (z_values[cell_dest_xi + 1][cell_dest_yi    ] - z_values[cell_dest_xi][cell_dest_yi    ]),
-            z2 = z_values[cell_dest_xi    ][cell_dest_yi + 1] + xratio *
-                (z_values[cell_dest_xi + 1][cell_dest_yi + 1] - z_values[cell_dest_xi][cell_dest_yi + 1]);
-
-      if (cell_dest_xi >= GRID_MAX_POINTS_X - 1) z1 = z2 = 0.0;
+      float z1, z2;
+      if (iend.x >= GRID_MAX_POINTS_X - 1)
+        z1 = z2 = 0.0;
+      else {
+        z1 = z_values[iend.x    ][iend.y    ] + xratio *
+            (z_values[iend.x + 1][iend.y    ] - z_values[iend.x][iend.y    ]),
+        z2 = z_values[iend.x    ][iend.y + 1] + xratio *
+            (z_values[iend.x + 1][iend.y + 1] - z_values[iend.x][iend.y + 1]);
+      }
 
       // X cell-fraction done. Interpolate the two Z offsets with the Y fraction for the final Z offset.
-      const float yratio = (end[Y_AXIS] - mesh_index_to_ypos(cell_dest_yi)) * RECIPROCAL(MESH_Y_DIST),
-                  z0 = cell_dest_yi < GRID_MAX_POINTS_Y - 1 ? (z1 + (z2 - z1) * yratio) * planner.fade_scaling_factor_for_z(end[Z_AXIS]) : 0.0;
+      const float yratio = (end.y - mesh_index_to_ypos(iend.y)) * RECIPROCAL(MESH_Y_DIST),
+                  z0 = iend.y < GRID_MAX_POINTS_Y - 1 ? (z1 + (z2 - z1) * yratio) * planner.fade_scaling_factor_for_z(end.z) : 0.0;
 
       // Undefined parts of the Mesh in z_values[][] are NAN.
       // Replace NAN corrections with 0.0 to prevent NAN propagation.
-      planner.buffer_segment(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + (isnan(z0) ? 0.0 : z0), end[E_AXIS], scaled_fr_mm_s, extruder);
-      set_current_from_destination();
+      if (!isnan(z0)) end.z += z0;
+      planner.buffer_segment(end, scaled_fr_mm_s, extruder);
+      current_position = destination;
       return;
     }
 
@@ -112,17 +103,11 @@
      * case - crossing only one X or Y line - after details are worked out to reduce computation.
      */
 
-    const float dx = end[X_AXIS] - start[X_AXIS],
-                dy = end[Y_AXIS] - start[Y_AXIS];
-
-    const int left_flag = dx < 0.0 ? 1 : 0,
-              down_flag = dy < 0.0 ? 1 : 0;
-
-    const float adx = left_flag ? -dx : dx,
-                ady = down_flag ? -dy : dy;
-
-    const int dxi = cell_start_xi == cell_dest_xi ? 0 : left_flag ? -1 : 1,
-              dyi = cell_start_yi == cell_dest_yi ? 0 : down_flag ? -1 : 1;
+    const xy_float_t dist = end - start;
+    const xy_bool_t neg { dist.x < 0, dist.y < 0 };
+    const xy_int8_t ineg { int8_t(neg.x), int8_t(neg.y) };
+    const xy_float_t sign { neg.x ? -1.0f : 1.0f, neg.y ? -1.0f : 1.0f };
+    const xy_int8_t iadd { int8_t(iend.x == istart.x ? 0 : sign.x), int8_t(iend.y == istart.y ? 0 : sign.y) };
 
     /**
      * Compute the extruder scaling factor for each partial move, checking for
@@ -132,64 +117,64 @@
      * components. The larger of the two is used to preserve precision.
      */
 
-    const bool use_x_dist = adx > ady;
+    const xy_float_t ad = sign * dist;
+    const bool use_x_dist = ad.x > ad.y;
 
-    float on_axis_distance = use_x_dist ? dx : dy,
-          e_position = end[E_AXIS] - start[E_AXIS],
-          z_position = end[Z_AXIS] - start[Z_AXIS];
+    float on_axis_distance = use_x_dist ? dist.x : dist.y,
+          e_position = end.e - start.e,
+          z_position = end.z - start.z;
 
-    const float e_normalized_dist = e_position / on_axis_distance,
+    const float e_normalized_dist = e_position / on_axis_distance, // Allow divide by zero
                 z_normalized_dist = z_position / on_axis_distance;
 
-    int current_xi = cell_start_xi,
-        current_yi = cell_start_yi;
+    xy_int8_t icell = istart;
 
-    const float m = dy / dx,
-                c = start[Y_AXIS] - m * start[X_AXIS];
+    const float ratio = dist.y / dist.x,        // Allow divide by zero
+                c = start.y - ratio * start.x;
 
-    const bool inf_normalized_flag = (isinf(e_normalized_dist) != 0),
-               inf_m_flag = (isinf(m) != 0);
+    const bool inf_normalized_flag = isinf(e_normalized_dist),
+               inf_ratio_flag = isinf(ratio);
 
     /**
      * Handle vertical lines that stay within one column.
      * These need not be perfectly vertical.
      */
-    if (dxi == 0) {             // Vertical line?
-      current_yi += down_flag;  // Line going down? Just go to the bottom.
-      while (current_yi != cell_dest_yi + down_flag) {
-        current_yi += dyi;
-        const float next_mesh_line_y = mesh_index_to_ypos(current_yi);
+    if (iadd.x == 0) {        // Vertical line?
+      icell.y += ineg.y;      // Line going down? Just go to the bottom.
+      while (icell.y != iend.y + ineg.y) {
+        icell.y += iadd.y;
+        const float next_mesh_line_y = mesh_index_to_ypos(icell.y);
 
         /**
          * Skip the calculations for an infinite slope.
          * For others the next X is the same so this can continue.
          * Calculate X at the next Y mesh line.
          */
-        const float rx = inf_m_flag ? start[X_AXIS] : (next_mesh_line_y - c) / m;
+        const float rx = inf_ratio_flag ? start.x : (next_mesh_line_y - c) / ratio;
 
-        float z0 = z_correction_for_x_on_horizontal_mesh_line(rx, current_xi, current_yi)
-                   * planner.fade_scaling_factor_for_z(end[Z_AXIS]);
+        float z0 = z_correction_for_x_on_horizontal_mesh_line(rx, icell.x, icell.y)
+                   * planner.fade_scaling_factor_for_z(end.z);
 
         // Undefined parts of the Mesh in z_values[][] are NAN.
         // Replace NAN corrections with 0.0 to prevent NAN propagation.
         if (isnan(z0)) z0 = 0.0;
 
-        const float ry = mesh_index_to_ypos(current_yi);
+        const float ry = mesh_index_to_ypos(icell.y);
 
         /**
          * Without this check, it's possible to generate a zero length move, as in the case where
          * the line is heading down, starting exactly on a mesh line boundary. Since this is rare
          * it might be fine to remove this check and let planner.buffer_segment() filter it out.
          */
-        if (ry != start[Y_AXIS]) {
-          if (!inf_normalized_flag) {
-            on_axis_distance = use_x_dist ? rx - start[X_AXIS] : ry - start[Y_AXIS];
-            e_position = start[E_AXIS] + on_axis_distance * e_normalized_dist;
-            z_position = start[Z_AXIS] + on_axis_distance * z_normalized_dist;
+        if (ry != start.y) {
+          if (!inf_normalized_flag) { // fall-through faster than branch
+            on_axis_distance = use_x_dist ? rx - start.x : ry - start.y;
+            e_position = start.e + on_axis_distance * e_normalized_dist;
+            z_position = start.z + on_axis_distance * z_normalized_dist;
           }
           else {
-            e_position = end[E_AXIS];
-            z_position = end[Z_AXIS];
+            e_position = end.e;
+            z_position = end.z;
           }
 
           planner.buffer_segment(rx, ry, z_position + z0, e_position, scaled_fr_mm_s, extruder);
@@ -197,10 +182,10 @@
       }
 
       // At the final destination? Usually not, but when on a Y Mesh Line it's completed.
-      if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
+      if (xy_pos_t(current_position) != xy_pos_t(end))
         goto FINAL_MOVE;
 
-      set_current_from_destination();
+      current_position = destination;
       return;
     }
 
@@ -208,36 +193,34 @@
      * Handle horizontal lines that stay within one row.
      * These need not be perfectly horizontal.
      */
-    if (dyi == 0) {             // Horizontal line?
-      current_xi += left_flag;  // Heading left? Just go to the left edge of the cell for the first move.
-      while (current_xi != cell_dest_xi + left_flag) {
-        current_xi += dxi;
-        const float next_mesh_line_x = mesh_index_to_xpos(current_xi),
-                    ry = m * next_mesh_line_x + c;   // Calculate Y at the next X mesh line
+    if (iadd.y == 0) {      // Horizontal line?
+      icell.x += ineg.x;     // Heading left? Just go to the left edge of the cell for the first move.
+      while (icell.x != iend.x + ineg.x) {
+        icell.x += iadd.x;
+        const float rx = mesh_index_to_xpos(icell.x);
+        const float ry = ratio * rx + c;    // Calculate Y at the next X mesh line
 
-        float z0 = z_correction_for_y_on_vertical_mesh_line(ry, current_xi, current_yi)
-                   * planner.fade_scaling_factor_for_z(end[Z_AXIS]);
+        float z0 = z_correction_for_y_on_vertical_mesh_line(ry, icell.x, icell.y)
+                     * planner.fade_scaling_factor_for_z(end.z);
 
         // Undefined parts of the Mesh in z_values[][] are NAN.
         // Replace NAN corrections with 0.0 to prevent NAN propagation.
         if (isnan(z0)) z0 = 0.0;
 
-        const float rx = mesh_index_to_xpos(current_xi);
-
         /**
          * Without this check, it's possible to generate a zero length move, as in the case where
          * the line is heading left, starting exactly on a mesh line boundary. Since this is rare
          * it might be fine to remove this check and let planner.buffer_segment() filter it out.
          */
-        if (rx != start[X_AXIS]) {
+        if (rx != start.x) {
           if (!inf_normalized_flag) {
-            on_axis_distance = use_x_dist ? rx - start[X_AXIS] : ry - start[Y_AXIS];
-            e_position = start[E_AXIS] + on_axis_distance * e_normalized_dist;  // is based on X or Y because this is a horizontal move
-            z_position = start[Z_AXIS] + on_axis_distance * z_normalized_dist;
+            on_axis_distance = use_x_dist ? rx - start.x : ry - start.y;
+            e_position = start.e + on_axis_distance * e_normalized_dist;  // is based on X or Y because this is a horizontal move
+            z_position = start.z + on_axis_distance * z_normalized_dist;
           }
           else {
-            e_position = end[E_AXIS];
-            z_position = end[Z_AXIS];
+            e_position = end.e;
+            z_position = end.z;
           }
 
           if (!planner.buffer_segment(rx, ry, z_position + z0, e_position, scaled_fr_mm_s, extruder))
@@ -245,93 +228,88 @@
         } //else printf("FIRST MOVE PRUNED  ");
       }
 
-      if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
+      if (xy_pos_t(current_position) != xy_pos_t(end))
         goto FINAL_MOVE;
 
-      set_current_from_destination();
+      current_position = destination;
       return;
     }
 
     /**
      *
-     * Handle the generic case of a line crossing both X and Y Mesh lines.
+     * Generic case of a line crossing both X and Y Mesh lines.
      *
      */
 
-    int xi_cnt = cell_start_xi - cell_dest_xi,
-        yi_cnt = cell_start_yi - cell_dest_yi;
-
-    if (xi_cnt < 0) xi_cnt = -xi_cnt;
-    if (yi_cnt < 0) yi_cnt = -yi_cnt;
+    xy_int8_t cnt = (istart - iend).ABS();
 
-    current_xi += left_flag;
-    current_yi += down_flag;
+    icell += ineg;
 
-    while (xi_cnt || yi_cnt) {
+    while (cnt) {
 
-      const float next_mesh_line_x = mesh_index_to_xpos(current_xi + dxi),
-                  next_mesh_line_y = mesh_index_to_ypos(current_yi + dyi),
-                  ry = m * next_mesh_line_x + c,   // Calculate Y at the next X mesh line
-                  rx = (next_mesh_line_y - c) / m; // Calculate X at the next Y mesh line
-                                                   // (No need to worry about m being zero.
-                                                   //  If that was the case, it was already detected
-                                                   //  as a vertical line move above.)
+      const float next_mesh_line_x = mesh_index_to_xpos(icell.x + iadd.x),
+                  next_mesh_line_y = mesh_index_to_ypos(icell.y + iadd.y),
+                  ry = ratio * next_mesh_line_x + c,    // Calculate Y at the next X mesh line
+                  rx = (next_mesh_line_y - c) / ratio;  // Calculate X at the next Y mesh line
+                                                        // (No need to worry about ratio == 0.
+                                                        //  In that case, it was already detected
+                                                        //  as a vertical line move above.)
 
-      if (left_flag == (rx > next_mesh_line_x)) { // Check if we hit the Y line first
+      if (neg.x == (rx > next_mesh_line_x)) { // Check if we hit the Y line first
         // Yes!  Crossing a Y Mesh Line next
-        float z0 = z_correction_for_x_on_horizontal_mesh_line(rx, current_xi - left_flag, current_yi + dyi)
-                   * planner.fade_scaling_factor_for_z(end[Z_AXIS]);
+        float z0 = z_correction_for_x_on_horizontal_mesh_line(rx, icell.x - ineg.x, icell.y + iadd.y)
+                   * planner.fade_scaling_factor_for_z(end.z);
 
         // Undefined parts of the Mesh in z_values[][] are NAN.
         // Replace NAN corrections with 0.0 to prevent NAN propagation.
         if (isnan(z0)) z0 = 0.0;
 
         if (!inf_normalized_flag) {
-          on_axis_distance = use_x_dist ? rx - start[X_AXIS] : next_mesh_line_y - start[Y_AXIS];
-          e_position = start[E_AXIS] + on_axis_distance * e_normalized_dist;
-          z_position = start[Z_AXIS] + on_axis_distance * z_normalized_dist;
+          on_axis_distance = use_x_dist ? rx - start.x : next_mesh_line_y - start.y;
+          e_position = start.e + on_axis_distance * e_normalized_dist;
+          z_position = start.z + on_axis_distance * z_normalized_dist;
         }
         else {
-          e_position = end[E_AXIS];
-          z_position = end[Z_AXIS];
+          e_position = end.e;
+          z_position = end.z;
         }
         if (!planner.buffer_segment(rx, next_mesh_line_y, z_position + z0, e_position, scaled_fr_mm_s, extruder))
           break;
-        current_yi += dyi;
-        yi_cnt--;
+        icell.y += iadd.y;
+        cnt.y--;
       }
       else {
         // Yes!  Crossing a X Mesh Line next
-        float z0 = z_correction_for_y_on_vertical_mesh_line(ry, current_xi + dxi, current_yi - down_flag)
-                   * planner.fade_scaling_factor_for_z(end[Z_AXIS]);
+        float z0 = z_correction_for_y_on_vertical_mesh_line(ry, icell.x + iadd.x, icell.y - ineg.y)
+                   * planner.fade_scaling_factor_for_z(end.z);
 
         // Undefined parts of the Mesh in z_values[][] are NAN.
         // Replace NAN corrections with 0.0 to prevent NAN propagation.
         if (isnan(z0)) z0 = 0.0;
 
         if (!inf_normalized_flag) {
-          on_axis_distance = use_x_dist ? next_mesh_line_x - start[X_AXIS] : ry - start[Y_AXIS];
-          e_position = start[E_AXIS] + on_axis_distance * e_normalized_dist;
-          z_position = start[Z_AXIS] + on_axis_distance * z_normalized_dist;
+          on_axis_distance = use_x_dist ? next_mesh_line_x - start.x : ry - start.y;
+          e_position = start.e + on_axis_distance * e_normalized_dist;
+          z_position = start.z + on_axis_distance * z_normalized_dist;
         }
         else {
-          e_position = end[E_AXIS];
-          z_position = end[Z_AXIS];
+          e_position = end.e;
+          z_position = end.z;
         }
 
         if (!planner.buffer_segment(next_mesh_line_x, ry, z_position + z0, e_position, scaled_fr_mm_s, extruder))
           break;
-        current_xi += dxi;
-        xi_cnt--;
+        icell.x += iadd.x;
+        cnt.x--;
       }
 
-      if (xi_cnt < 0 || yi_cnt < 0) break; // Too far! Exit the loop and go to FINAL_MOVE
+      if (cnt.x < 0 || cnt.y < 0) break; // Too far! Exit the loop and go to FINAL_MOVE
     }
 
-    if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
+    if (xy_pos_t(current_position) != xy_pos_t(end))
       goto FINAL_MOVE;
 
-    set_current_from_destination();
+    current_position = destination;
   }
 
 #else // UBL_SEGMENTED
@@ -356,56 +334,42 @@
 
   bool _O2 unified_bed_leveling::line_to_destination_segmented(const feedRate_t &scaled_fr_mm_s) {
 
-    if (!position_is_reachable(destination[X_AXIS], destination[Y_AXIS]))  // fail if moving outside reachable boundary
-      return true; // did not move, so current_position still accurate
+    if (!position_is_reachable(destination))  // fail if moving outside reachable boundary
+      return true;                            // did not move, so current_position still accurate
 
-    const float total[XYZE] = {
-      destination[X_AXIS] - current_position[X_AXIS],
-      destination[Y_AXIS] - current_position[Y_AXIS],
-      destination[Z_AXIS] - current_position[Z_AXIS],
-      destination[E_AXIS] - current_position[E_AXIS]
-    };
+    const xyze_pos_t total = destination - current_position;
 
-    const float cartesian_xy_mm = HYPOT(total[X_AXIS], total[Y_AXIS]);  // total horizontal xy distance
+    const float cart_xy_mm_2 = HYPOT2(total.x, total.y),
+                cart_xy_mm = SQRT(cart_xy_mm_2);                                     // Total XY distance
 
     #if IS_KINEMATIC
-      const float seconds = cartesian_xy_mm / scaled_fr_mm_s;                             // Duration of XY move at requested rate
-      uint16_t segments = LROUND(delta_segments_per_second * seconds),                    // Preferred number of segments for distance @ feedrate
-               seglimit = LROUND(cartesian_xy_mm * RECIPROCAL(DELTA_SEGMENT_MIN_LENGTH)); // Number of segments at minimum segment length
-      NOMORE(segments, seglimit);                                                         // Limit to minimum segment length (fewer segments)
+      const float seconds = cart_xy_mm / scaled_fr_mm_s;                             // Duration of XY move at requested rate
+      uint16_t segments = LROUND(delta_segments_per_second * seconds),               // Preferred number of segments for distance @ feedrate
+               seglimit = LROUND(cart_xy_mm * RECIPROCAL(DELTA_SEGMENT_MIN_LENGTH)); // Number of segments at minimum segment length
+      NOMORE(segments, seglimit);                                                    // Limit to minimum segment length (fewer segments)
     #else
-      uint16_t segments = LROUND(cartesian_xy_mm * RECIPROCAL(DELTA_SEGMENT_MIN_LENGTH)); // cartesian fixed segment length
+      uint16_t segments = LROUND(cart_xy_mm * RECIPROCAL(DELTA_SEGMENT_MIN_LENGTH)); // Cartesian fixed segment length
     #endif
 
-    NOLESS(segments, 1U);                        // must have at least one segment
-    const float inv_segments = 1.0f / segments;  // divide once, multiply thereafter
+    NOLESS(segments, 1U);                                                            // Must have at least one segment
+    const float inv_segments = 1.0f / segments,                                      // Reciprocal to save calculation
+                segment_xyz_mm = SQRT(cart_xy_mm_2 + sq(total.z)) * inv_segments;    // Length of each segment
 
-    const float segment_xyz_mm = HYPOT(cartesian_xy_mm, total[Z_AXIS]) * inv_segments;   // length of each segment
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       const float inv_duration = scaled_fr_mm_s / segment_xyz_mm;
     #endif
 
-    const float diff[XYZE] = {
-      total[X_AXIS] * inv_segments,
-      total[Y_AXIS] * inv_segments,
-      total[Z_AXIS] * inv_segments,
-      total[E_AXIS] * inv_segments
-    };
+    xyze_float_t diff = total * inv_segments;
 
     // Note that E segment distance could vary slightly as z mesh height
     // changes for each segment, but small enough to ignore.
 
-    float raw[XYZE] = {
-      current_position[X_AXIS],
-      current_position[Y_AXIS],
-      current_position[Z_AXIS],
-      current_position[E_AXIS]
-    };
+    xyze_pos_t raw = current_position;
 
     // Just do plain segmentation if UBL is inactive or the target is above the fade height
-    if (!planner.leveling_active || !planner.leveling_active_at_z(destination[Z_AXIS])) {
+    if (!planner.leveling_active || !planner.leveling_active_at_z(destination.z)) {
       while (--segments) {
-        LOOP_XYZE(i) raw[i] += diff[i];
+        raw += diff;
         planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, segment_xyz_mm
           #if ENABLED(SCARA_FEEDRATE_SCALING)
             , inv_duration
@@ -417,17 +381,17 @@
           , inv_duration
         #endif
       );
-      return false; // moved but did not set_current_from_destination();
+      return false; // Did not set current from destination
     }
 
     // Otherwise perform per-segment leveling
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      const float fade_scaling_factor = planner.fade_scaling_factor_for_z(destination[Z_AXIS]);
+      const float fade_scaling_factor = planner.fade_scaling_factor_for_z(destination.z);
     #endif
 
-    // increment to first segment destination
-    LOOP_XYZE(i) raw[i] += diff[i];
+    // Move to first segment destination
+    raw += diff;
 
     for (;;) {  // for each mesh cell encountered during the move
 
@@ -438,75 +402,68 @@
       // in top of loop and again re-find same adjacent cell and use it, just less efficient
       // for mesh inset area.
 
-      int8_t cell_xi = (raw[X_AXIS] - (MESH_MIN_X)) * RECIPROCAL(MESH_X_DIST),
-             cell_yi = (raw[Y_AXIS] - (MESH_MIN_Y)) * RECIPROCAL(MESH_Y_DIST);
+      xy_int8_t icell = {
+        int8_t((raw.x - (MESH_MIN_X)) * RECIPROCAL(MESH_X_DIST)),
+        int8_t((raw.y - (MESH_MIN_Y)) * RECIPROCAL(MESH_Y_DIST))
+      };
+      LIMIT(icell.x, 0, (GRID_MAX_POINTS_X) - 1);
+      LIMIT(icell.y, 0, (GRID_MAX_POINTS_Y) - 1);
 
-      LIMIT(cell_xi, 0, (GRID_MAX_POINTS_X) - 1);
-      LIMIT(cell_yi, 0, (GRID_MAX_POINTS_Y) - 1);
-
-      const float x0 = mesh_index_to_xpos(cell_xi),   // 64 byte table lookup avoids mul+add
-                  y0 = mesh_index_to_ypos(cell_yi);
-
-      float z_x0y0 = z_values[cell_xi  ][cell_yi  ],  // z at lower left corner
-            z_x1y0 = z_values[cell_xi+1][cell_yi  ],  // z at upper left corner
-            z_x0y1 = z_values[cell_xi  ][cell_yi+1],  // z at lower right corner
-            z_x1y1 = z_values[cell_xi+1][cell_yi+1];  // z at upper right corner
+      float z_x0y0 = z_values[icell.x  ][icell.y  ],  // z at lower left corner
+            z_x1y0 = z_values[icell.x+1][icell.y  ],  // z at upper left corner
+            z_x0y1 = z_values[icell.x  ][icell.y+1],  // z at lower right corner
+            z_x1y1 = z_values[icell.x+1][icell.y+1];  // z at upper right corner
 
       if (isnan(z_x0y0)) z_x0y0 = 0;              // ideally activating planner.leveling_active (G29 A)
       if (isnan(z_x1y0)) z_x1y0 = 0;              //   should refuse if any invalid mesh points
       if (isnan(z_x0y1)) z_x0y1 = 0;              //   in order to avoid isnan tests per cell,
       if (isnan(z_x1y1)) z_x1y1 = 0;              //   thus guessing zero for undefined points
 
-      float cx = raw[X_AXIS] - x0,   // cell-relative x and y
-            cy = raw[Y_AXIS] - y0;
+      const xy_pos_t pos = { mesh_index_to_xpos(icell.x), mesh_index_to_ypos(icell.y) };
+      xy_pos_t cell = raw - pos;
 
       const float z_xmy0 = (z_x1y0 - z_x0y0) * RECIPROCAL(MESH_X_DIST),   // z slope per x along y0 (lower left to lower right)
                   z_xmy1 = (z_x1y1 - z_x0y1) * RECIPROCAL(MESH_X_DIST);   // z slope per x along y1 (upper left to upper right)
 
-            float z_cxy0 = z_x0y0 + z_xmy0 * cx;            // z height along y0 at cx (changes for each cx in cell)
+            float z_cxy0 = z_x0y0 + z_xmy0 * cell.x;        // z height along y0 at cell.x (changes for each cell.x in cell)
 
-      const float z_cxy1 = z_x0y1 + z_xmy1 * cx,            // z height along y1 at cx
-                  z_cxyd = z_cxy1 - z_cxy0;                 // z height difference along cx from y0 to y1
+      const float z_cxy1 = z_x0y1 + z_xmy1 * cell.x,        // z height along y1 at cell.x
+                  z_cxyd = z_cxy1 - z_cxy0;                 // z height difference along cell.x from y0 to y1
 
-            float z_cxym = z_cxyd * RECIPROCAL(MESH_Y_DIST);  // z slope per y along cx from y0 to y1 (changes for each cx in cell)
+            float z_cxym = z_cxyd * RECIPROCAL(MESH_Y_DIST); // z slope per y along cell.x from pos.y to y1 (changes for each cell.x in cell)
 
-      //    float z_cxcy = z_cxy0 + z_cxym * cy;            // interpolated mesh z height along cx at cy (do inside the segment loop)
+      //    float z_cxcy = z_cxy0 + z_cxym * cell.y;        // interpolated mesh z height along cell.x at cell.y (do inside the segment loop)
 
       // As subsequent segments step through this cell, the z_cxy0 intercept will change
-      // and the z_cxym slope will change, both as a function of cx within the cell, and
+      // and the z_cxym slope will change, both as a function of cell.x within the cell, and
       // each change by a constant for fixed segment lengths.
 
-      const float z_sxy0 = z_xmy0 * diff[X_AXIS],                                     // per-segment adjustment to z_cxy0
-                  z_sxym = (z_xmy1 - z_xmy0) * RECIPROCAL(MESH_Y_DIST) * diff[X_AXIS];  // per-segment adjustment to z_cxym
+      const float z_sxy0 = z_xmy0 * diff.x,                                       // per-segment adjustment to z_cxy0
+                  z_sxym = (z_xmy1 - z_xmy0) * RECIPROCAL(MESH_Y_DIST) * diff.x;  // per-segment adjustment to z_cxym
 
       for (;;) {  // for all segments within this mesh cell
 
-        if (--segments == 0) COPY(raw, destination); // if this is last segment, use destination for exact
+        if (--segments == 0) raw = destination;     // if this is last segment, use destination for exact
 
-        const float z_cxcy = (z_cxy0 + z_cxym * cy) // interpolated mesh z height along cx at cy
+        const float z_cxcy = (z_cxy0 + z_cxym * cell.y) // interpolated mesh z height along cell.x at cell.y
           #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
             * fade_scaling_factor                   // apply fade factor to interpolated mesh height
           #endif
         ;
 
-        const float z = raw[Z_AXIS];
-        raw[Z_AXIS] += z_cxcy;
-        planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, segment_xyz_mm
+        planner.buffer_line(raw.x, raw.y, raw.z + z_cxcy, raw.e, scaled_fr_mm_s, active_extruder, segment_xyz_mm
           #if ENABLED(SCARA_FEEDRATE_SCALING)
             , inv_duration
           #endif
         );
-        raw[Z_AXIS] = z;
 
         if (segments == 0)                        // done with last segment
-          return false;                           // did not set_current_from_destination()
-
-        LOOP_XYZE(i) raw[i] += diff[i];
+          return false;                           // didn't set current from destination
 
-        cx += diff[X_AXIS];
-        cy += diff[Y_AXIS];
+        raw += diff;
+        cell += diff;
 
-        if (!WITHIN(cx, 0, MESH_X_DIST) || !WITHIN(cy, 0, MESH_Y_DIST))    // done within this cell, break to next
+        if (!WITHIN(cell.x, 0, MESH_X_DIST) || !WITHIN(cell.y, 0, MESH_Y_DIST))    // done within this cell, break to next
           break;
 
         // Next segment still within same mesh cell, adjust the per-segment

commit 455dabb18334c89878a75be62bccebd9f537574d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 26 01:28:09 2019 -0500

    Add a feedRate_t data type (#15349)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 105aee1c77..fcce41169a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -43,7 +43,7 @@
 
 #if !UBL_SEGMENTED
 
-  void unified_bed_leveling::line_to_destination_cartesian(const float &feed_rate, const uint8_t extruder) {
+  void unified_bed_leveling::line_to_destination_cartesian(const feedRate_t &scaled_fr_mm_s, const uint8_t extruder) {
     /**
      * Much of the nozzle movement will be within the same cell. So we will do as little computation
      * as possible to determine if this is the case. If this move is within the same cell, we will
@@ -79,9 +79,8 @@
             + UBL_Z_RAISE_WHEN_OFF_MESH
           #endif
         ;
-        planner.buffer_segment(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + z_raise, end[E_AXIS], feed_rate, extruder);
+        planner.buffer_segment(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + z_raise, end[E_AXIS], scaled_fr_mm_s, extruder);
         set_current_from_destination();
-
         return;
       }
 
@@ -103,8 +102,7 @@
 
       // Undefined parts of the Mesh in z_values[][] are NAN.
       // Replace NAN corrections with 0.0 to prevent NAN propagation.
-      planner.buffer_segment(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + (isnan(z0) ? 0.0 : z0), end[E_AXIS], feed_rate, extruder);
-
+      planner.buffer_segment(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + (isnan(z0) ? 0.0 : z0), end[E_AXIS], scaled_fr_mm_s, extruder);
       set_current_from_destination();
       return;
     }
@@ -194,7 +192,7 @@
             z_position = end[Z_AXIS];
           }
 
-          planner.buffer_segment(rx, ry, z_position + z0, e_position, feed_rate, extruder);
+          planner.buffer_segment(rx, ry, z_position + z0, e_position, scaled_fr_mm_s, extruder);
         } //else printf("FIRST MOVE PRUNED  ");
       }
 
@@ -242,7 +240,7 @@
             z_position = end[Z_AXIS];
           }
 
-          if (!planner.buffer_segment(rx, ry, z_position + z0, e_position, feed_rate, extruder))
+          if (!planner.buffer_segment(rx, ry, z_position + z0, e_position, scaled_fr_mm_s, extruder))
             break;
         } //else printf("FIRST MOVE PRUNED  ");
       }
@@ -297,7 +295,7 @@
           e_position = end[E_AXIS];
           z_position = end[Z_AXIS];
         }
-        if (!planner.buffer_segment(rx, next_mesh_line_y, z_position + z0, e_position, feed_rate, extruder))
+        if (!planner.buffer_segment(rx, next_mesh_line_y, z_position + z0, e_position, scaled_fr_mm_s, extruder))
           break;
         current_yi += dyi;
         yi_cnt--;
@@ -321,7 +319,7 @@
           z_position = end[Z_AXIS];
         }
 
-        if (!planner.buffer_segment(next_mesh_line_x, ry, z_position + z0, e_position, feed_rate, extruder))
+        if (!planner.buffer_segment(next_mesh_line_x, ry, z_position + z0, e_position, scaled_fr_mm_s, extruder))
           break;
         current_xi += dxi;
         xi_cnt--;
@@ -356,25 +354,25 @@
    * Returns true if did NOT move, false if moved (requires current_position update).
    */
 
-  bool _O2 unified_bed_leveling::prepare_segmented_line_to(const float (&rtarget)[XYZE], const float &feedrate) {
+  bool _O2 unified_bed_leveling::line_to_destination_segmented(const feedRate_t &scaled_fr_mm_s) {
 
-    if (!position_is_reachable(rtarget[X_AXIS], rtarget[Y_AXIS]))  // fail if moving outside reachable boundary
+    if (!position_is_reachable(destination[X_AXIS], destination[Y_AXIS]))  // fail if moving outside reachable boundary
       return true; // did not move, so current_position still accurate
 
     const float total[XYZE] = {
-      rtarget[X_AXIS] - current_position[X_AXIS],
-      rtarget[Y_AXIS] - current_position[Y_AXIS],
-      rtarget[Z_AXIS] - current_position[Z_AXIS],
-      rtarget[E_AXIS] - current_position[E_AXIS]
+      destination[X_AXIS] - current_position[X_AXIS],
+      destination[Y_AXIS] - current_position[Y_AXIS],
+      destination[Z_AXIS] - current_position[Z_AXIS],
+      destination[E_AXIS] - current_position[E_AXIS]
     };
 
     const float cartesian_xy_mm = HYPOT(total[X_AXIS], total[Y_AXIS]);  // total horizontal xy distance
 
     #if IS_KINEMATIC
-      const float seconds = cartesian_xy_mm / feedrate;                                  // seconds to move xy distance at requested rate
-      uint16_t segments = LROUND(delta_segments_per_second * seconds),                  // preferred number of segments for distance @ feedrate
-               seglimit = LROUND(cartesian_xy_mm * RECIPROCAL(DELTA_SEGMENT_MIN_LENGTH)); // number of segments at minimum segment length
-      NOMORE(segments, seglimit);                                                        // limit to minimum segment length (fewer segments)
+      const float seconds = cartesian_xy_mm / scaled_fr_mm_s;                             // Duration of XY move at requested rate
+      uint16_t segments = LROUND(delta_segments_per_second * seconds),                    // Preferred number of segments for distance @ feedrate
+               seglimit = LROUND(cartesian_xy_mm * RECIPROCAL(DELTA_SEGMENT_MIN_LENGTH)); // Number of segments at minimum segment length
+      NOMORE(segments, seglimit);                                                         // Limit to minimum segment length (fewer segments)
     #else
       uint16_t segments = LROUND(cartesian_xy_mm * RECIPROCAL(DELTA_SEGMENT_MIN_LENGTH)); // cartesian fixed segment length
     #endif
@@ -384,7 +382,7 @@
 
     const float segment_xyz_mm = HYPOT(cartesian_xy_mm, total[Z_AXIS]) * inv_segments;   // length of each segment
     #if ENABLED(SCARA_FEEDRATE_SCALING)
-      const float inv_duration = feedrate / segment_xyz_mm;
+      const float inv_duration = scaled_fr_mm_s / segment_xyz_mm;
     #endif
 
     const float diff[XYZE] = {
@@ -404,17 +402,17 @@
       current_position[E_AXIS]
     };
 
-    // Only compute leveling per segment if ubl active and target below z_fade_height.
-    if (!planner.leveling_active || !planner.leveling_active_at_z(rtarget[Z_AXIS])) {   // no mesh leveling
+    // Just do plain segmentation if UBL is inactive or the target is above the fade height
+    if (!planner.leveling_active || !planner.leveling_active_at_z(destination[Z_AXIS])) {
       while (--segments) {
         LOOP_XYZE(i) raw[i] += diff[i];
-        planner.buffer_line(raw, feedrate, active_extruder, segment_xyz_mm
+        planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, segment_xyz_mm
           #if ENABLED(SCARA_FEEDRATE_SCALING)
             , inv_duration
           #endif
         );
       }
-      planner.buffer_line(rtarget, feedrate, active_extruder, segment_xyz_mm
+      planner.buffer_line(destination, scaled_fr_mm_s, active_extruder, segment_xyz_mm
         #if ENABLED(SCARA_FEEDRATE_SCALING)
           , inv_duration
         #endif
@@ -425,7 +423,7 @@
     // Otherwise perform per-segment leveling
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      const float fade_scaling_factor = planner.fade_scaling_factor_for_z(rtarget[Z_AXIS]);
+      const float fade_scaling_factor = planner.fade_scaling_factor_for_z(destination[Z_AXIS]);
     #endif
 
     // increment to first segment destination
@@ -483,8 +481,7 @@
 
       for (;;) {  // for all segments within this mesh cell
 
-        if (--segments == 0)                      // if this is last segment, use rtarget for exact
-          COPY(raw, rtarget);
+        if (--segments == 0) COPY(raw, destination); // if this is last segment, use destination for exact
 
         const float z_cxcy = (z_cxy0 + z_cxym * cy) // interpolated mesh z height along cx at cy
           #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
@@ -494,7 +491,7 @@
 
         const float z = raw[Z_AXIS];
         raw[Z_AXIS] += z_cxcy;
-        planner.buffer_line(raw, feedrate, active_extruder, segment_xyz_mm
+        planner.buffer_line(raw, scaled_fr_mm_s, active_extruder, segment_xyz_mm
           #if ENABLED(SCARA_FEEDRATE_SCALING)
             , inv_duration
           #endif

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 4bb29d7e0b..105aee1c77 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -88,7 +88,7 @@
       FINAL_MOVE:
 
       // The distance is always MESH_X_DIST so multiply by the constant reciprocal.
-      const float xratio = (end[X_AXIS] - mesh_index_to_xpos(cell_dest_xi)) * (1.0f / (MESH_X_DIST));
+      const float xratio = (end[X_AXIS] - mesh_index_to_xpos(cell_dest_xi)) * RECIPROCAL(MESH_X_DIST);
 
       float z1 = z_values[cell_dest_xi    ][cell_dest_yi    ] + xratio *
                 (z_values[cell_dest_xi + 1][cell_dest_yi    ] - z_values[cell_dest_xi][cell_dest_yi    ]),
@@ -98,7 +98,7 @@
       if (cell_dest_xi >= GRID_MAX_POINTS_X - 1) z1 = z2 = 0.0;
 
       // X cell-fraction done. Interpolate the two Z offsets with the Y fraction for the final Z offset.
-      const float yratio = (end[Y_AXIS] - mesh_index_to_ypos(cell_dest_yi)) * (1.0f / (MESH_Y_DIST)),
+      const float yratio = (end[Y_AXIS] - mesh_index_to_ypos(cell_dest_yi)) * RECIPROCAL(MESH_Y_DIST),
                   z0 = cell_dest_yi < GRID_MAX_POINTS_Y - 1 ? (z1 + (z2 - z1) * yratio) * planner.fade_scaling_factor_for_z(end[Z_AXIS]) : 0.0;
 
       // Undefined parts of the Mesh in z_values[][] are NAN.
@@ -373,10 +373,10 @@
     #if IS_KINEMATIC
       const float seconds = cartesian_xy_mm / feedrate;                                  // seconds to move xy distance at requested rate
       uint16_t segments = LROUND(delta_segments_per_second * seconds),                  // preferred number of segments for distance @ feedrate
-               seglimit = LROUND(cartesian_xy_mm * (1.0f / (DELTA_SEGMENT_MIN_LENGTH))); // number of segments at minimum segment length
+               seglimit = LROUND(cartesian_xy_mm * RECIPROCAL(DELTA_SEGMENT_MIN_LENGTH)); // number of segments at minimum segment length
       NOMORE(segments, seglimit);                                                        // limit to minimum segment length (fewer segments)
     #else
-      uint16_t segments = LROUND(cartesian_xy_mm * (1.0f / (DELTA_SEGMENT_MIN_LENGTH))); // cartesian fixed segment length
+      uint16_t segments = LROUND(cartesian_xy_mm * RECIPROCAL(DELTA_SEGMENT_MIN_LENGTH)); // cartesian fixed segment length
     #endif
 
     NOLESS(segments, 1U);                        // must have at least one segment
@@ -440,8 +440,8 @@
       // in top of loop and again re-find same adjacent cell and use it, just less efficient
       // for mesh inset area.
 
-      int8_t cell_xi = (raw[X_AXIS] - (MESH_MIN_X)) * (1.0f / (MESH_X_DIST)),
-             cell_yi = (raw[Y_AXIS] - (MESH_MIN_Y)) * (1.0f / (MESH_Y_DIST));
+      int8_t cell_xi = (raw[X_AXIS] - (MESH_MIN_X)) * RECIPROCAL(MESH_X_DIST),
+             cell_yi = (raw[Y_AXIS] - (MESH_MIN_Y)) * RECIPROCAL(MESH_Y_DIST);
 
       LIMIT(cell_xi, 0, (GRID_MAX_POINTS_X) - 1);
       LIMIT(cell_yi, 0, (GRID_MAX_POINTS_Y) - 1);
@@ -462,15 +462,15 @@
       float cx = raw[X_AXIS] - x0,   // cell-relative x and y
             cy = raw[Y_AXIS] - y0;
 
-      const float z_xmy0 = (z_x1y0 - z_x0y0) * (1.0f / (MESH_X_DIST)),   // z slope per x along y0 (lower left to lower right)
-                  z_xmy1 = (z_x1y1 - z_x0y1) * (1.0f / (MESH_X_DIST));   // z slope per x along y1 (upper left to upper right)
+      const float z_xmy0 = (z_x1y0 - z_x0y0) * RECIPROCAL(MESH_X_DIST),   // z slope per x along y0 (lower left to lower right)
+                  z_xmy1 = (z_x1y1 - z_x0y1) * RECIPROCAL(MESH_X_DIST);   // z slope per x along y1 (upper left to upper right)
 
             float z_cxy0 = z_x0y0 + z_xmy0 * cx;            // z height along y0 at cx (changes for each cx in cell)
 
       const float z_cxy1 = z_x0y1 + z_xmy1 * cx,            // z height along y1 at cx
                   z_cxyd = z_cxy1 - z_cxy0;                 // z height difference along cx from y0 to y1
 
-            float z_cxym = z_cxyd * (1.0f / (MESH_Y_DIST));  // z slope per y along cx from y0 to y1 (changes for each cx in cell)
+            float z_cxym = z_cxyd * RECIPROCAL(MESH_Y_DIST);  // z slope per y along cx from y0 to y1 (changes for each cx in cell)
 
       //    float z_cxcy = z_cxy0 + z_cxym * cy;            // interpolated mesh z height along cx at cy (do inside the segment loop)
 
@@ -479,7 +479,7 @@
       // each change by a constant for fixed segment lengths.
 
       const float z_sxy0 = z_xmy0 * diff[X_AXIS],                                     // per-segment adjustment to z_cxy0
-                  z_sxym = (z_xmy1 - z_xmy0) * (1.0f / (MESH_Y_DIST)) * diff[X_AXIS];  // per-segment adjustment to z_cxym
+                  z_sxym = (z_xmy1 - z_xmy0) * RECIPROCAL(MESH_Y_DIST) * diff[X_AXIS];  // per-segment adjustment to z_cxym
 
       for (;;) {  // for all segments within this mesh cell
 

commit ed0e6afacbbd5ef8836166feccbd4b50fc9da009
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 10 03:33:28 2019 -0500

    Apply LIMIT macro

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index d3b012da5a..4bb29d7e0b 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -443,8 +443,8 @@
       int8_t cell_xi = (raw[X_AXIS] - (MESH_MIN_X)) * (1.0f / (MESH_X_DIST)),
              cell_yi = (raw[Y_AXIS] - (MESH_MIN_Y)) * (1.0f / (MESH_Y_DIST));
 
-      cell_xi = constrain(cell_xi, 0, (GRID_MAX_POINTS_X) - 1);
-      cell_yi = constrain(cell_yi, 0, (GRID_MAX_POINTS_Y) - 1);
+      LIMIT(cell_xi, 0, (GRID_MAX_POINTS_X) - 1);
+      LIMIT(cell_yi, 0, (GRID_MAX_POINTS_Y) - 1);
 
       const float x0 = mesh_index_to_xpos(cell_xi),   // 64 byte table lookup avoids mul+add
                   y0 = mesh_index_to_ypos(cell_yi);

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index d3cf1ac924..d3b012da5a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit cf12fc8366f2ffbc3811173769d5428236af0dd9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 5 20:02:46 2019 -0500

    Expand on serial debugging (#13577)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 4034531a04..d3cf1ac924 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -64,17 +64,6 @@
               cell_dest_xi  = get_cell_index_x(end[X_AXIS]),
               cell_dest_yi  = get_cell_index_y(end[Y_AXIS]);
 
-    if (g26_debug_flag) {
-      SERIAL_ECHOLNPAIR(
-        " ubl.line_to_destination_cartesian(xe=", destination[X_AXIS],
-        ", ye=", destination[Y_AXIS],
-        ", ze=", destination[Z_AXIS],
-        ", ee=", destination[E_AXIS],
-        ")"
-      );
-      debug_current_and_destination(PSTR("Start of ubl.line_to_destination_cartesian()"));
-    }
-
     // A move within the same cell needs no splitting
     if (cell_start_xi == cell_dest_xi && cell_start_yi == cell_dest_yi) {
 
@@ -93,9 +82,6 @@
         planner.buffer_segment(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + z_raise, end[E_AXIS], feed_rate, extruder);
         set_current_from_destination();
 
-        if (g26_debug_flag)
-          debug_current_and_destination(PSTR("out of bounds in ubl.line_to_destination_cartesian()"));
-
         return;
       }
 
@@ -119,9 +105,6 @@
       // Replace NAN corrections with 0.0 to prevent NAN propagation.
       planner.buffer_segment(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + (isnan(z0) ? 0.0 : z0), end[E_AXIS], feed_rate, extruder);
 
-      if (g26_debug_flag)
-        debug_current_and_destination(PSTR("FINAL_MOVE in ubl.line_to_destination_cartesian()"));
-
       set_current_from_destination();
       return;
     }
@@ -215,9 +198,6 @@
         } //else printf("FIRST MOVE PRUNED  ");
       }
 
-      if (g26_debug_flag)
-        debug_current_and_destination(PSTR("vertical move done in ubl.line_to_destination_cartesian()"));
-
       // At the final destination? Usually not, but when on a Y Mesh Line it's completed.
       if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
         goto FINAL_MOVE;
@@ -267,9 +247,6 @@
         } //else printf("FIRST MOVE PRUNED  ");
       }
 
-      if (g26_debug_flag)
-        debug_current_and_destination(PSTR("horizontal move done in ubl.line_to_destination_cartesian()"));
-
       if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
         goto FINAL_MOVE;
 
@@ -353,9 +330,6 @@
       if (xi_cnt < 0 || yi_cnt < 0) break; // Too far! Exit the loop and go to FINAL_MOVE
     }
 
-    if (g26_debug_flag)
-      debug_current_and_destination(PSTR("generic move done in ubl.line_to_destination_cartesian()"));
-
     if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
       goto FINAL_MOVE;
 

commit cfdb38eda4b4d993bac4a0e8600e776429b42b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 5 06:46:19 2019 -0600

    Allow SERIAL_ECHOPAIR to take up to 12 pairs (#13311)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 01773972a1..4034531a04 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -65,12 +65,13 @@
               cell_dest_yi  = get_cell_index_y(end[Y_AXIS]);
 
     if (g26_debug_flag) {
-      SERIAL_ECHOPAIR(" ubl.line_to_destination_cartesian(xe=", destination[X_AXIS]);
-      SERIAL_ECHOPAIR(", ye=", destination[Y_AXIS]);
-      SERIAL_ECHOPAIR(", ze=", destination[Z_AXIS]);
-      SERIAL_ECHOPAIR(", ee=", destination[E_AXIS]);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
+      SERIAL_ECHOLNPAIR(
+        " ubl.line_to_destination_cartesian(xe=", destination[X_AXIS],
+        ", ye=", destination[Y_AXIS],
+        ", ze=", destination[Z_AXIS],
+        ", ee=", destination[E_AXIS],
+        ")"
+      );
       debug_current_and_destination(PSTR("Start of ubl.line_to_destination_cartesian()"));
     }
 

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 0519f736d9..01773972a1 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit c5e5cc5e9f20e82cbd15b47a85bf08bbca542961
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 17 17:30:04 2018 -0500

    Fix some trailing whitespace, macros

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index f7add5f79e..0519f736d9 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -397,11 +397,11 @@
 
     #if IS_KINEMATIC
       const float seconds = cartesian_xy_mm / feedrate;                                  // seconds to move xy distance at requested rate
-      uint16_t segments = lroundf(delta_segments_per_second * seconds),                  // preferred number of segments for distance @ feedrate
-               seglimit = lroundf(cartesian_xy_mm * (1.0f / (DELTA_SEGMENT_MIN_LENGTH))); // number of segments at minimum segment length
+      uint16_t segments = LROUND(delta_segments_per_second * seconds),                  // preferred number of segments for distance @ feedrate
+               seglimit = LROUND(cartesian_xy_mm * (1.0f / (DELTA_SEGMENT_MIN_LENGTH))); // number of segments at minimum segment length
       NOMORE(segments, seglimit);                                                        // limit to minimum segment length (fewer segments)
     #else
-      uint16_t segments = lroundf(cartesian_xy_mm * (1.0f / (DELTA_SEGMENT_MIN_LENGTH))); // cartesian fixed segment length
+      uint16_t segments = LROUND(cartesian_xy_mm * (1.0f / (DELTA_SEGMENT_MIN_LENGTH))); // cartesian fixed segment length
     #endif
 
     NOLESS(segments, 1U);                        // must have at least one segment

commit c437bb08f12f1c0535cc78a761b49a18f2dc2a12
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Sep 16 22:24:15 2018 -0400

    Overhaul of the planner (#11578)
    
    - Move FWRETRACT to the planner
    - Combine leveling, skew, etc. in a single modifier method
    - Have kinematic and non-kinematic moves call one planner method

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 85ed86838e..f7add5f79e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -49,12 +49,11 @@
      * as possible to determine if this is the case. If this move is within the same cell, we will
      * just do the required Z-Height correction, call the Planner's buffer_line() routine, and leave
      */
-    #if ENABLED(SKEW_CORRECTION)
-      // For skew correction just adjust the destination point and we're done
+    #if HAS_POSITION_MODIFIERS
       float start[XYZE] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS] },
             end[XYZE] = { destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS] };
-      planner.skew(start[X_AXIS], start[Y_AXIS], start[Z_AXIS]);
-      planner.skew(end[X_AXIS], end[Y_AXIS], end[Z_AXIS]);
+      planner.apply_modifiers(start);
+      planner.apply_modifiers(end);
     #else
       const float (&start)[XYZE] = current_position,
                     (&end)[XYZE] = destination;
@@ -364,47 +363,6 @@
 
 #else // UBL_SEGMENTED
 
-  #if IS_SCARA // scale the feed rate from mm/s to degrees/s
-    static float scara_feed_factor, scara_oldA, scara_oldB;
-  #endif
-
-  // We don't want additional apply_leveling() performed by regular buffer_line or buffer_line_kinematic,
-  // so we call buffer_segment directly here.  Per-segmented leveling and kinematics performed first.
-
-  inline void _O2 ubl_buffer_segment_raw(const float (&in_raw)[XYZE], const float &fr) {
-
-    #if ENABLED(SKEW_CORRECTION)
-      float raw[XYZE] = { in_raw[X_AXIS], in_raw[Y_AXIS], in_raw[Z_AXIS] };
-      planner.skew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]);
-    #else
-      const float (&raw)[XYZE] = in_raw;
-    #endif
-
-    #if ENABLED(DELTA)  // apply delta inverse_kinematics
-
-      DELTA_IK(raw);
-      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], in_raw[E_AXIS], fr, active_extruder);
-
-    #elif IS_SCARA  // apply scara inverse_kinematics (should be changed to save raw->logical->raw)
-
-      inverse_kinematics(raw);  // this writes delta[ABC] from raw[XYZE]
-                                // should move the feedrate scaling to scara inverse_kinematics
-
-      const float adiff = ABS(delta[A_AXIS] - scara_oldA),
-                  bdiff = ABS(delta[B_AXIS] - scara_oldB);
-      scara_oldA = delta[A_AXIS];
-      scara_oldB = delta[B_AXIS];
-      float s_feedrate = MAX(adiff, bdiff) * scara_feed_factor;
-
-      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], in_raw[E_AXIS], s_feedrate, active_extruder);
-
-    #else // CARTESIAN
-
-      planner.buffer_segment(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], in_raw[E_AXIS], fr, active_extruder);
-
-    #endif
-  }
-
   #if IS_SCARA
     #define DELTA_SEGMENT_MIN_LENGTH 0.25 // SCARA minimum segment size is 0.25mm
   #elif ENABLED(DELTA)
@@ -449,10 +407,9 @@
     NOLESS(segments, 1U);                        // must have at least one segment
     const float inv_segments = 1.0f / segments;  // divide once, multiply thereafter
 
-    #if IS_SCARA // scale the feed rate from mm/s to degrees/s
-      scara_feed_factor = cartesian_xy_mm * inv_segments * feedrate;
-      scara_oldA = planner.get_axis_position_degrees(A_AXIS);
-      scara_oldB = planner.get_axis_position_degrees(B_AXIS);
+    const float segment_xyz_mm = HYPOT(cartesian_xy_mm, total[Z_AXIS]) * inv_segments;   // length of each segment
+    #if ENABLED(SCARA_FEEDRATE_SCALING)
+      const float inv_duration = feedrate / segment_xyz_mm;
     #endif
 
     const float diff[XYZE] = {
@@ -476,9 +433,17 @@
     if (!planner.leveling_active || !planner.leveling_active_at_z(rtarget[Z_AXIS])) {   // no mesh leveling
       while (--segments) {
         LOOP_XYZE(i) raw[i] += diff[i];
-        ubl_buffer_segment_raw(raw, feedrate);
+        planner.buffer_line(raw, feedrate, active_extruder, segment_xyz_mm
+          #if ENABLED(SCARA_FEEDRATE_SCALING)
+            , inv_duration
+          #endif
+        );
       }
-      ubl_buffer_segment_raw(rtarget, feedrate);
+      planner.buffer_line(rtarget, feedrate, active_extruder, segment_xyz_mm
+        #if ENABLED(SCARA_FEEDRATE_SCALING)
+          , inv_duration
+        #endif
+      );
       return false; // moved but did not set_current_from_destination();
     }
 
@@ -554,7 +519,11 @@
 
         const float z = raw[Z_AXIS];
         raw[Z_AXIS] += z_cxcy;
-        ubl_buffer_segment_raw(raw, feedrate);
+        planner.buffer_line(raw, feedrate, active_extruder, segment_xyz_mm
+          #if ENABLED(SCARA_FEEDRATE_SCALING)
+            , inv_duration
+          #endif
+        );
         raw[Z_AXIS] = z;
 
         if (segments == 0)                        // done with last segment

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 4900f0e0df..85ed86838e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -102,7 +102,7 @@
       FINAL_MOVE:
 
       // The distance is always MESH_X_DIST so multiply by the constant reciprocal.
-      const float xratio = (end[X_AXIS] - mesh_index_to_xpos(cell_dest_xi)) * (1.0 / (MESH_X_DIST));
+      const float xratio = (end[X_AXIS] - mesh_index_to_xpos(cell_dest_xi)) * (1.0f / (MESH_X_DIST));
 
       float z1 = z_values[cell_dest_xi    ][cell_dest_yi    ] + xratio *
                 (z_values[cell_dest_xi + 1][cell_dest_yi    ] - z_values[cell_dest_xi][cell_dest_yi    ]),
@@ -112,7 +112,7 @@
       if (cell_dest_xi >= GRID_MAX_POINTS_X - 1) z1 = z2 = 0.0;
 
       // X cell-fraction done. Interpolate the two Z offsets with the Y fraction for the final Z offset.
-      const float yratio = (end[Y_AXIS] - mesh_index_to_ypos(cell_dest_yi)) * (1.0 / (MESH_Y_DIST)),
+      const float yratio = (end[Y_AXIS] - mesh_index_to_ypos(cell_dest_yi)) * (1.0f / (MESH_Y_DIST)),
                   z0 = cell_dest_yi < GRID_MAX_POINTS_Y - 1 ? (z1 + (z2 - z1) * yratio) * planner.fade_scaling_factor_for_z(end[Z_AXIS]) : 0.0;
 
       // Undefined parts of the Mesh in z_values[][] are NAN.
@@ -440,14 +440,14 @@
     #if IS_KINEMATIC
       const float seconds = cartesian_xy_mm / feedrate;                                  // seconds to move xy distance at requested rate
       uint16_t segments = lroundf(delta_segments_per_second * seconds),                  // preferred number of segments for distance @ feedrate
-               seglimit = lroundf(cartesian_xy_mm * (1.0 / (DELTA_SEGMENT_MIN_LENGTH))); // number of segments at minimum segment length
+               seglimit = lroundf(cartesian_xy_mm * (1.0f / (DELTA_SEGMENT_MIN_LENGTH))); // number of segments at minimum segment length
       NOMORE(segments, seglimit);                                                        // limit to minimum segment length (fewer segments)
     #else
-      uint16_t segments = lroundf(cartesian_xy_mm * (1.0 / (DELTA_SEGMENT_MIN_LENGTH))); // cartesian fixed segment length
+      uint16_t segments = lroundf(cartesian_xy_mm * (1.0f / (DELTA_SEGMENT_MIN_LENGTH))); // cartesian fixed segment length
     #endif
 
     NOLESS(segments, 1U);                        // must have at least one segment
-    const float inv_segments = 1.0 / segments;  // divide once, multiply thereafter
+    const float inv_segments = 1.0f / segments;  // divide once, multiply thereafter
 
     #if IS_SCARA // scale the feed rate from mm/s to degrees/s
       scara_feed_factor = cartesian_xy_mm * inv_segments * feedrate;
@@ -500,8 +500,8 @@
       // in top of loop and again re-find same adjacent cell and use it, just less efficient
       // for mesh inset area.
 
-      int8_t cell_xi = (raw[X_AXIS] - (MESH_MIN_X)) * (1.0 / (MESH_X_DIST)),
-             cell_yi = (raw[Y_AXIS] - (MESH_MIN_Y)) * (1.0 / (MESH_Y_DIST));
+      int8_t cell_xi = (raw[X_AXIS] - (MESH_MIN_X)) * (1.0f / (MESH_X_DIST)),
+             cell_yi = (raw[Y_AXIS] - (MESH_MIN_Y)) * (1.0f / (MESH_Y_DIST));
 
       cell_xi = constrain(cell_xi, 0, (GRID_MAX_POINTS_X) - 1);
       cell_yi = constrain(cell_yi, 0, (GRID_MAX_POINTS_Y) - 1);
@@ -522,15 +522,15 @@
       float cx = raw[X_AXIS] - x0,   // cell-relative x and y
             cy = raw[Y_AXIS] - y0;
 
-      const float z_xmy0 = (z_x1y0 - z_x0y0) * (1.0 / (MESH_X_DIST)),   // z slope per x along y0 (lower left to lower right)
-                  z_xmy1 = (z_x1y1 - z_x0y1) * (1.0 / (MESH_X_DIST));   // z slope per x along y1 (upper left to upper right)
+      const float z_xmy0 = (z_x1y0 - z_x0y0) * (1.0f / (MESH_X_DIST)),   // z slope per x along y0 (lower left to lower right)
+                  z_xmy1 = (z_x1y1 - z_x0y1) * (1.0f / (MESH_X_DIST));   // z slope per x along y1 (upper left to upper right)
 
             float z_cxy0 = z_x0y0 + z_xmy0 * cx;            // z height along y0 at cx (changes for each cx in cell)
 
       const float z_cxy1 = z_x0y1 + z_xmy1 * cx,            // z height along y1 at cx
                   z_cxyd = z_cxy1 - z_cxy0;                 // z height difference along cx from y0 to y1
 
-            float z_cxym = z_cxyd * (1.0 / (MESH_Y_DIST));  // z slope per y along cx from y0 to y1 (changes for each cx in cell)
+            float z_cxym = z_cxyd * (1.0f / (MESH_Y_DIST));  // z slope per y along cx from y0 to y1 (changes for each cx in cell)
 
       //    float z_cxcy = z_cxy0 + z_cxym * cy;            // interpolated mesh z height along cx at cy (do inside the segment loop)
 
@@ -539,7 +539,7 @@
       // each change by a constant for fixed segment lengths.
 
       const float z_sxy0 = z_xmy0 * diff[X_AXIS],                                     // per-segment adjustment to z_cxy0
-                  z_sxym = (z_xmy1 - z_xmy0) * (1.0 / (MESH_Y_DIST)) * diff[X_AXIS];  // per-segment adjustment to z_cxym
+                  z_sxym = (z_xmy1 - z_xmy0) * (1.0f / (MESH_Y_DIST)) * diff[X_AXIS];  // per-segment adjustment to z_cxym
 
       for (;;) {  // for all segments within this mesh cell
 

commit a11eb50a3eab6d58d595a67e526fb51190018db3
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 9 02:17:53 2018 -0300

    Refactor and optimize Stepper/Planner
    
    Better encapsulation and considerably reduce stepper jitter

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index a94144f58c..4900f0e0df 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -262,7 +262,8 @@
             z_position = end[Z_AXIS];
           }
 
-          planner.buffer_segment(rx, ry, z_position + z0, e_position, feed_rate, extruder);
+          if (!planner.buffer_segment(rx, ry, z_position + z0, e_position, feed_rate, extruder))
+            break;
         } //else printf("FIRST MOVE PRUNED  ");
       }
 
@@ -319,7 +320,8 @@
           e_position = end[E_AXIS];
           z_position = end[Z_AXIS];
         }
-        planner.buffer_segment(rx, next_mesh_line_y, z_position + z0, e_position, feed_rate, extruder);
+        if (!planner.buffer_segment(rx, next_mesh_line_y, z_position + z0, e_position, feed_rate, extruder))
+          break;
         current_yi += dyi;
         yi_cnt--;
       }
@@ -342,7 +344,8 @@
           z_position = end[Z_AXIS];
         }
 
-        planner.buffer_segment(next_mesh_line_x, ry, z_position + z0, e_position, feed_rate, extruder);
+        if (!planner.buffer_segment(next_mesh_line_x, ry, z_position + z0, e_position, feed_rate, extruder))
+          break;
         current_xi += dxi;
         xi_cnt--;
       }

commit 50270b53a0a2b8d716f1a771563e17f9753e14ce
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 17 18:40:22 2018 -0500

    Clear up some more compile warnings

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 85a6fad8e6..a94144f58c 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -443,7 +443,7 @@
       uint16_t segments = lroundf(cartesian_xy_mm * (1.0 / (DELTA_SEGMENT_MIN_LENGTH))); // cartesian fixed segment length
     #endif
 
-    NOLESS(segments, 1);                        // must have at least one segment
+    NOLESS(segments, 1U);                        // must have at least one segment
     const float inv_segments = 1.0 / segments;  // divide once, multiply thereafter
 
     #if IS_SCARA // scale the feed rate from mm/s to degrees/s

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 957a3a7d1d..85a6fad8e6 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -387,11 +387,11 @@
       inverse_kinematics(raw);  // this writes delta[ABC] from raw[XYZE]
                                 // should move the feedrate scaling to scara inverse_kinematics
 
-      const float adiff = FABS(delta[A_AXIS] - scara_oldA),
-                  bdiff = FABS(delta[B_AXIS] - scara_oldB);
+      const float adiff = ABS(delta[A_AXIS] - scara_oldA),
+                  bdiff = ABS(delta[B_AXIS] - scara_oldB);
       scara_oldA = delta[A_AXIS];
       scara_oldB = delta[B_AXIS];
-      float s_feedrate = max(adiff, bdiff) * scara_feed_factor;
+      float s_feedrate = MAX(adiff, bdiff) * scara_feed_factor;
 
       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], in_raw[E_AXIS], s_feedrate, active_extruder);
 

commit 8f8c6a9bc4f1c8b2d927e74339a48217d9b48ec7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 09:59:11 2018 -0500

    Move get_axis_position_mm to Planner (#10718)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 44fd02a4c5..957a3a7d1d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -448,8 +448,8 @@
 
     #if IS_SCARA // scale the feed rate from mm/s to degrees/s
       scara_feed_factor = cartesian_xy_mm * inv_segments * feedrate;
-      scara_oldA = stepper.get_axis_position_degrees(A_AXIS);
-      scara_oldB = stepper.get_axis_position_degrees(B_AXIS);
+      scara_oldA = planner.get_axis_position_degrees(A_AXIS);
+      scara_oldB = planner.get_axis_position_degrees(B_AXIS);
     #endif
 
     const float diff[XYZE] = {

commit 23635c2b647bbe14dcf0cf165338ee79dc624c57
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Thu Apr 19 12:04:35 2018 -0500

    Update ubl_motion.cpp
    
    Restore necessary and needed loop termination logic.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index ed92510103..44fd02a4c5 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -347,7 +347,7 @@
         xi_cnt--;
       }
 
-      //if (xi_cnt < 0 || yi_cnt < 0) break; // Too far! Exit the loop and go to FINAL_MOVE
+      if (xi_cnt < 0 || yi_cnt < 0) break; // Too far! Exit the loop and go to FINAL_MOVE
     }
 
     if (g26_debug_flag)

commit 3bc179a16f5164462f54996d7e26b3690da156fb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 12 18:06:48 2018 -0500

    Compress/update comments ubl_motion
    
    ‚Ä¶to fit more code on the screen and correct outdated commentary contrasting ABL.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 8e8b5256d7..ed92510103 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -75,19 +75,16 @@
       debug_current_and_destination(PSTR("Start of ubl.line_to_destination_cartesian()"));
     }
 
-    if (cell_start_xi == cell_dest_xi && cell_start_yi == cell_dest_yi) { // if the whole move is within the same cell,
-      /**
-       * we don't need to break up the move
-       *
-       * If we are moving off the print bed, we are going to allow the move at this level.
-       * But we detect it and isolate it. For now, we just pass along the request.
-       */
+    // A move within the same cell needs no splitting
+    if (cell_start_xi == cell_dest_xi && cell_start_yi == cell_dest_yi) {
 
+      // For a move off the bed, use a constant Z raise
       if (!WITHIN(cell_dest_xi, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(cell_dest_yi, 0, GRID_MAX_POINTS_Y - 1)) {
 
         // Note: There is no Z Correction in this case. We are off the grid and don't know what
         // a reasonable correction would be.  If the user has specified a UBL_Z_RAISE_WHEN_OFF_MESH
         // value, that will be used instead of a calculated (Bi-Linear interpolation) correction.
+
         const float z_raise = 0.0
           #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
             + UBL_Z_RAISE_WHEN_OFF_MESH
@@ -104,15 +101,7 @@
 
       FINAL_MOVE:
 
-      /**
-       * Optimize some floating point operations here. We could call float get_z_correction(float x0, float y0) to
-       * generate the correction for us. But we can lighten the load on the CPU by doing a modified version of the function.
-       * We are going to only calculate the amount we are from the first mesh line towards the second mesh line once.
-       * We will use this fraction in both of the original two Z Height calculations for the bi-linear interpolation. And,
-       * instead of doing a generic divide of the distance, we know the distance is MESH_X_DIST so we can use the preprocessor
-       * to create a 1-over number for us. That will allow us to do a floating point multiply instead of a floating point divide.
-       */
-
+      // The distance is always MESH_X_DIST so multiply by the constant reciprocal.
       const float xratio = (end[X_AXIS] - mesh_index_to_xpos(cell_dest_xi)) * (1.0 / (MESH_X_DIST));
 
       float z1 = z_values[cell_dest_xi    ][cell_dest_yi    ] + xratio *
@@ -122,22 +111,13 @@
 
       if (cell_dest_xi >= GRID_MAX_POINTS_X - 1) z1 = z2 = 0.0;
 
-      // we are done with the fractional X distance into the cell. Now with the two Z-Heights we have calculated, we
-      // are going to apply the Y-Distance into the cell to interpolate the final Z correction.
-
-      const float yratio = (end[Y_AXIS] - mesh_index_to_ypos(cell_dest_yi)) * (1.0 / (MESH_Y_DIST));
-      float z0 = cell_dest_yi < GRID_MAX_POINTS_Y - 1 ? (z1 + (z2 - z1) * yratio) * planner.fade_scaling_factor_for_z(end[Z_AXIS]) : 0.0;
-
-      /**
-       * If part of the Mesh is undefined, it will show up as NAN
-       * in z_values[][] and propagate through the
-       * calculations. If our correction is NAN, we throw it out
-       * because part of the Mesh is undefined and we don't have the
-       * information we need to complete the height correction.
-       */
-      if (isnan(z0)) z0 = 0.0;
+      // X cell-fraction done. Interpolate the two Z offsets with the Y fraction for the final Z offset.
+      const float yratio = (end[Y_AXIS] - mesh_index_to_ypos(cell_dest_yi)) * (1.0 / (MESH_Y_DIST)),
+                  z0 = cell_dest_yi < GRID_MAX_POINTS_Y - 1 ? (z1 + (z2 - z1) * yratio) * planner.fade_scaling_factor_for_z(end[Z_AXIS]) : 0.0;
 
-      planner.buffer_segment(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + z0, end[E_AXIS], feed_rate, extruder);
+      // Undefined parts of the Mesh in z_values[][] are NAN.
+      // Replace NAN corrections with 0.0 to prevent NAN propagation.
+      planner.buffer_segment(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + (isnan(z0) ? 0.0 : z0), end[E_AXIS], feed_rate, extruder);
 
       if (g26_debug_flag)
         debug_current_and_destination(PSTR("FINAL_MOVE in ubl.line_to_destination_cartesian()"));
@@ -147,11 +127,8 @@
     }
 
     /**
-     * If we get here, we are processing a move that crosses at least one Mesh Line. We will check
-     * for the simple case of just crossing X or just crossing Y Mesh Lines after we get all the details
-     * of the move figured out. We can process the easy case of just crossing an X or Y Mesh Line with less
-     * computation and in fact most lines are of this nature. We will check for that in the following
-     * blocks of code:
+     * Past this point the move is known to cross one or more mesh lines. Check for the most common
+     * case - crossing only one X or Y line - after details are worked out to reduce computation.
      */
 
     const float dx = end[X_AXIS] - start[X_AXIS],
@@ -167,12 +144,11 @@
               dyi = cell_start_yi == cell_dest_yi ? 0 : down_flag ? -1 : 1;
 
     /**
-     * Compute the scaling factor for the extruder for each partial move.
-     * We need to watch out for zero length moves because it will cause us to
-     * have an infinate scaling factor. We are stuck doing a floating point
-     * divide to get our scaling factor, but after that, we just multiply by this
-     * number. We also pick our scaling factor based on whether the X or Y
-     * component is larger. We use the biggest of the two to preserve precision.
+     * Compute the extruder scaling factor for each partial move, checking for
+     * zero-length moves that would result in an infinite scaling factor.
+     * A float divide is required for this, but then it just multiplies.
+     * Also select a scaling factor based on the larger of the X and Y
+     * components. The larger of the two is used to preserve precision.
      */
 
     const bool use_x_dist = adx > ady;
@@ -192,43 +168,37 @@
 
     const bool inf_normalized_flag = (isinf(e_normalized_dist) != 0),
                inf_m_flag = (isinf(m) != 0);
+
     /**
-     * This block handles vertical lines. These are lines that stay within the same
-     * X Cell column. They do not need to be perfectly vertical. They just can
-     * not cross into another X Cell column.
+     * Handle vertical lines that stay within one column.
+     * These need not be perfectly vertical.
      */
-    if (dxi == 0) {       // Check for a vertical line
-      current_yi += down_flag;  // Line is heading down, we just want to go to the bottom
+    if (dxi == 0) {             // Vertical line?
+      current_yi += down_flag;  // Line going down? Just go to the bottom.
       while (current_yi != cell_dest_yi + down_flag) {
         current_yi += dyi;
         const float next_mesh_line_y = mesh_index_to_ypos(current_yi);
 
         /**
-         * if the slope of the line is infinite, we won't do the calculations
-         * else, we know the next X is the same so we can recover and continue!
-         * Calculate X at the next Y mesh line
+         * Skip the calculations for an infinite slope.
+         * For others the next X is the same so this can continue.
+         * Calculate X at the next Y mesh line.
          */
         const float rx = inf_m_flag ? start[X_AXIS] : (next_mesh_line_y - c) / m;
 
         float z0 = z_correction_for_x_on_horizontal_mesh_line(rx, current_xi, current_yi)
                    * planner.fade_scaling_factor_for_z(end[Z_AXIS]);
 
-        /**
-         * If part of the Mesh is undefined, it will show up as NAN
-         * in z_values[][] and propagate through the
-         * calculations. If our correction is NAN, we throw it out
-         * because part of the Mesh is undefined and we don't have the
-         * information we need to complete the height correction.
-         */
+        // Undefined parts of the Mesh in z_values[][] are NAN.
+        // Replace NAN corrections with 0.0 to prevent NAN propagation.
         if (isnan(z0)) z0 = 0.0;
 
         const float ry = mesh_index_to_ypos(current_yi);
 
         /**
-         * Without this check, it is possible for the algorithm to generate a zero length move in the case
-         * where the line is heading down and it is starting right on a Mesh Line boundary. For how often that
-         * happens, it might be best to remove the check and always 'schedule' the move because
-         * the planner.buffer_segment() routine will filter it if that happens.
+         * Without this check, it's possible to generate a zero length move, as in the case where
+         * the line is heading down, starting exactly on a mesh line boundary. Since this is rare
+         * it might be fine to remove this check and let planner.buffer_segment() filter it out.
          */
         if (ry != start[Y_AXIS]) {
           if (!inf_normalized_flag) {
@@ -248,9 +218,7 @@
       if (g26_debug_flag)
         debug_current_and_destination(PSTR("vertical move done in ubl.line_to_destination_cartesian()"));
 
-      //
-      // Check if we are at the final destination. Usually, we won't be, but if it is on a Y Mesh Line, we are done.
-      //
+      // At the final destination? Usually not, but when on a Y Mesh Line it's completed.
       if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
         goto FINAL_MOVE;
 
@@ -259,16 +227,11 @@
     }
 
     /**
-     *
-     * This block handles horizontal lines. These are lines that stay within the same
-     * Y Cell row. They do not need to be perfectly horizontal. They just can
-     * not cross into another Y Cell row.
-     *
+     * Handle horizontal lines that stay within one row.
+     * These need not be perfectly horizontal.
      */
-
-    if (dyi == 0) {             // Check for a horizontal line
-      current_xi += left_flag;  // Line is heading left, we just want to go to the left
-                                // edge of this cell for the first move.
+    if (dyi == 0) {             // Horizontal line?
+      current_xi += left_flag;  // Heading left? Just go to the left edge of the cell for the first move.
       while (current_xi != cell_dest_xi + left_flag) {
         current_xi += dxi;
         const float next_mesh_line_x = mesh_index_to_xpos(current_xi),
@@ -277,22 +240,16 @@
         float z0 = z_correction_for_y_on_vertical_mesh_line(ry, current_xi, current_yi)
                    * planner.fade_scaling_factor_for_z(end[Z_AXIS]);
 
-        /**
-         * If part of the Mesh is undefined, it will show up as NAN
-         * in z_values[][] and propagate through the
-         * calculations. If our correction is NAN, we throw it out
-         * because part of the Mesh is undefined and we don't have the
-         * information we need to complete the height correction.
-         */
+        // Undefined parts of the Mesh in z_values[][] are NAN.
+        // Replace NAN corrections with 0.0 to prevent NAN propagation.
         if (isnan(z0)) z0 = 0.0;
 
         const float rx = mesh_index_to_xpos(current_xi);
 
         /**
-         * Without this check, it is possible for the algorithm to generate a zero length move in the case
-         * where the line is heading left and it is starting right on a Mesh Line boundary. For how often
-         * that happens, it might be best to remove the check and always 'schedule' the move because
-         * the planner.buffer_segment() routine will filter it if that happens.
+         * Without this check, it's possible to generate a zero length move, as in the case where
+         * the line is heading left, starting exactly on a mesh line boundary. Since this is rare
+         * it might be fine to remove this check and let planner.buffer_segment() filter it out.
          */
         if (rx != start[X_AXIS]) {
           if (!inf_normalized_flag) {
@@ -321,7 +278,7 @@
 
     /**
      *
-     * This block handles the generic case of a line crossing both X and Y Mesh lines.
+     * Handle the generic case of a line crossing both X and Y Mesh lines.
      *
      */
 
@@ -334,7 +291,7 @@
     current_xi += left_flag;
     current_yi += down_flag;
 
-    while (xi_cnt > 0 || yi_cnt > 0) {
+    while (xi_cnt || yi_cnt) {
 
       const float next_mesh_line_x = mesh_index_to_xpos(current_xi + dxi),
                   next_mesh_line_y = mesh_index_to_ypos(current_yi + dyi),
@@ -349,13 +306,8 @@
         float z0 = z_correction_for_x_on_horizontal_mesh_line(rx, current_xi - left_flag, current_yi + dyi)
                    * planner.fade_scaling_factor_for_z(end[Z_AXIS]);
 
-        /**
-         * If part of the Mesh is undefined, it will show up as NAN
-         * in z_values[][] and propagate through the
-         * calculations. If our correction is NAN, we throw it out
-         * because part of the Mesh is undefined and we don't have the
-         * information we need to complete the height correction.
-         */
+        // Undefined parts of the Mesh in z_values[][] are NAN.
+        // Replace NAN corrections with 0.0 to prevent NAN propagation.
         if (isnan(z0)) z0 = 0.0;
 
         if (!inf_normalized_flag) {
@@ -376,13 +328,8 @@
         float z0 = z_correction_for_y_on_vertical_mesh_line(ry, current_xi + dxi, current_yi - down_flag)
                    * planner.fade_scaling_factor_for_z(end[Z_AXIS]);
 
-        /**
-         * If part of the Mesh is undefined, it will show up as NAN
-         * in z_values[][] and propagate through the
-         * calculations. If our correction is NAN, we throw it out
-         * because part of the Mesh is undefined and we don't have the
-         * information we need to complete the height correction.
-         */
+        // Undefined parts of the Mesh in z_values[][] are NAN.
+        // Replace NAN corrections with 0.0 to prevent NAN propagation.
         if (isnan(z0)) z0 = 0.0;
 
         if (!inf_normalized_flag) {
@@ -400,7 +347,7 @@
         xi_cnt--;
       }
 
-      if (xi_cnt < 0 || yi_cnt < 0) break; // we've gone too far, so exit the loop and move on to FINAL_MOVE
+      //if (xi_cnt < 0 || yi_cnt < 0) break; // Too far! Exit the loop and go to FINAL_MOVE
     }
 
     if (g26_debug_flag)

commit d0ac0151b6421a779d703f5874feaf08130c6c07
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 11 10:12:45 2018 -0500

    Fix typo in ubl.prepare_segmented_line_to

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index bf458a88c2..8e8b5256d7 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -551,7 +551,7 @@
       // for mesh inset area.
 
       int8_t cell_xi = (raw[X_AXIS] - (MESH_MIN_X)) * (1.0 / (MESH_X_DIST)),
-             cell_yi = (raw[Y_AXIS] - (MESH_MIN_Y)) * (1.0 / (MESH_X_DIST));
+             cell_yi = (raw[Y_AXIS] - (MESH_MIN_Y)) * (1.0 / (MESH_Y_DIST));
 
       cell_xi = constrain(cell_xi, 0, (GRID_MAX_POINTS_X) - 1);
       cell_yi = constrain(cell_yi, 0, (GRID_MAX_POINTS_Y) - 1);

commit f3dbe1966991ccf85f00de939e8d39e25084c07d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 25 00:13:46 2018 -0600

    Tweaks to HAL codestyle

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 5b83f49ce1..bf458a88c2 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -541,7 +541,7 @@
     // increment to first segment destination
     LOOP_XYZE(i) raw[i] += diff[i];
 
-    for(;;) {  // for each mesh cell encountered during the move
+    for (;;) {  // for each mesh cell encountered during the move
 
       // Compute mesh cell invariants that remain constant for all segments within cell.
       // Note for cell index, if point is outside the mesh grid (in MESH_INSET perimeter)
@@ -591,7 +591,7 @@
       const float z_sxy0 = z_xmy0 * diff[X_AXIS],                                     // per-segment adjustment to z_cxy0
                   z_sxym = (z_xmy1 - z_xmy0) * (1.0 / (MESH_Y_DIST)) * diff[X_AXIS];  // per-segment adjustment to z_cxym
 
-      for(;;) {  // for all segments within this mesh cell
+      for (;;) {  // for all segments within this mesh cell
 
         if (--segments == 0)                      // if this is last segment, use rtarget for exact
           COPY(raw, rtarget);

commit 304e0f8945f8a25b9c08b5047dc8530a10f66975
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 15 22:22:06 2018 -0600

    Followup to 21e60fd
    
    `ENABLED` only works for flag-type options. Floats must use `#ifdef`.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index c265e4ade1..5b83f49ce1 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -86,13 +86,13 @@
       if (!WITHIN(cell_dest_xi, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(cell_dest_yi, 0, GRID_MAX_POINTS_Y - 1)) {
 
         // Note: There is no Z Correction in this case. We are off the grid and don't know what
-        // a reasonable correction would be.  If the user has specified a UBL_Z_RAISE_WHEN_OFF_MESH 
+        // a reasonable correction would be.  If the user has specified a UBL_Z_RAISE_WHEN_OFF_MESH
         // value, that will be used instead of a calculated (Bi-Linear interpolation) correction.
-
-        float z_raise = 0.0;
-        #if ENABLED(UBL_Z_RAISE_WHEN_OFF_MESH)
-          z_raise = UBL_Z_RAISE_WHEN_OFF_MESH;
-        #endif
+        const float z_raise = 0.0
+          #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
+            + UBL_Z_RAISE_WHEN_OFF_MESH
+          #endif
+        ;
         planner.buffer_segment(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + z_raise, end[E_AXIS], feed_rate, extruder);
         set_current_from_destination();
 

commit 21e60fd3edd9ea009f1a86db5c06909d59ff1cd0
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Thu Feb 15 15:07:42 2018 -0600

    Allow user to control Z-Height correction for off mesh movements (#9661)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 07d541233a..c265e4ade1 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -86,9 +86,14 @@
       if (!WITHIN(cell_dest_xi, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(cell_dest_yi, 0, GRID_MAX_POINTS_Y - 1)) {
 
         // Note: There is no Z Correction in this case. We are off the grid and don't know what
-        // a reasonable correction would be.
-
-        planner.buffer_segment(end[X_AXIS], end[Y_AXIS], end[Z_AXIS], end[E_AXIS], feed_rate, extruder);
+        // a reasonable correction would be.  If the user has specified a UBL_Z_RAISE_WHEN_OFF_MESH 
+        // value, that will be used instead of a calculated (Bi-Linear interpolation) correction.
+
+        float z_raise = 0.0;
+        #if ENABLED(UBL_Z_RAISE_WHEN_OFF_MESH)
+          z_raise = UBL_Z_RAISE_WHEN_OFF_MESH;
+        #endif
+        planner.buffer_segment(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + z_raise, end[E_AXIS], feed_rate, extruder);
         set_current_from_destination();
 
         if (g26_debug_flag)

commit 705ea98fd3a243c8a0332b34d076deceb5a5cf6a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 24 22:56:23 2017 -0600

    Comment `return false` in motion functions

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index fefff867f8..07d541233a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -621,6 +621,8 @@
 
       } // segment loop
     } // cell loop
+
+    return false; // caller will update current_position
   }
 
 #endif // UBL_SEGMENTED

commit caa50934984692e7b0de8aeb05438be9a19ce660
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Dec 21 22:41:57 2017 -0600

    General DELTA_IK macro

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 4bc106976d..fefff867f8 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -427,7 +427,7 @@
 
     #if ENABLED(DELTA)  // apply delta inverse_kinematics
 
-      DELTA_RAW_IK();
+      DELTA_IK(raw);
       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], in_raw[E_AXIS], fr, active_extruder);
 
     #elif IS_SCARA  // apply scara inverse_kinematics (should be changed to save raw->logical->raw)

commit d568e586b7f7b14f841bb59203e626d8941b6e18
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Dec 11 02:30:27 2017 -0600

    Fix up ubl_motion indentation

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 98d979e6ea..4bc106976d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -23,23 +23,23 @@
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
-  #include "../bedlevel.h"
-  #include "../../../module/planner.h"
-  #include "../../../module/stepper.h"
-  #include "../../../module/motion.h"
+#include "../bedlevel.h"
+#include "../../../module/planner.h"
+#include "../../../module/stepper.h"
+#include "../../../module/motion.h"
 
-  #if ENABLED(DELTA)
-    #include "../../../module/delta.h"
-  #endif
+#if ENABLED(DELTA)
+  #include "../../../module/delta.h"
+#endif
 
-  #include "../../../Marlin.h"
-  #include <math.h>
+#include "../../../Marlin.h"
+#include <math.h>
 
-  #if AVR_AT90USB1286_FAMILY  // Teensyduino & Printrboard IDE extensions have compile errors without this
-    inline void set_current_from_destination() { COPY(current_position, destination); }
-  #else
-    extern void set_current_from_destination();
-  #endif
+#if AVR_AT90USB1286_FAMILY  // Teensyduino & Printrboard IDE extensions have compile errors without this
+  inline void set_current_from_destination() { COPY(current_position, destination); }
+#else
+  extern void set_current_from_destination();
+#endif
 
 #if !UBL_SEGMENTED
 
@@ -409,219 +409,219 @@
 
 #else // UBL_SEGMENTED
 
-    #if IS_SCARA // scale the feed rate from mm/s to degrees/s
-      static float scara_feed_factor, scara_oldA, scara_oldB;
+  #if IS_SCARA // scale the feed rate from mm/s to degrees/s
+    static float scara_feed_factor, scara_oldA, scara_oldB;
+  #endif
+
+  // We don't want additional apply_leveling() performed by regular buffer_line or buffer_line_kinematic,
+  // so we call buffer_segment directly here.  Per-segmented leveling and kinematics performed first.
+
+  inline void _O2 ubl_buffer_segment_raw(const float (&in_raw)[XYZE], const float &fr) {
+
+    #if ENABLED(SKEW_CORRECTION)
+      float raw[XYZE] = { in_raw[X_AXIS], in_raw[Y_AXIS], in_raw[Z_AXIS] };
+      planner.skew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]);
+    #else
+      const float (&raw)[XYZE] = in_raw;
     #endif
 
-    // We don't want additional apply_leveling() performed by regular buffer_line or buffer_line_kinematic,
-    // so we call buffer_segment directly here.  Per-segmented leveling and kinematics performed first.
+    #if ENABLED(DELTA)  // apply delta inverse_kinematics
 
-    inline void _O2 ubl_buffer_segment_raw(const float (&in_raw)[XYZE], const float &fr) {
+      DELTA_RAW_IK();
+      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], in_raw[E_AXIS], fr, active_extruder);
 
-      #if ENABLED(SKEW_CORRECTION)
-        float raw[XYZE] = { in_raw[X_AXIS], in_raw[Y_AXIS], in_raw[Z_AXIS] };
-        planner.skew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]);
-      #else
-        const float (&raw)[XYZE] = in_raw;
-      #endif
+    #elif IS_SCARA  // apply scara inverse_kinematics (should be changed to save raw->logical->raw)
 
-      #if ENABLED(DELTA)  // apply delta inverse_kinematics
+      inverse_kinematics(raw);  // this writes delta[ABC] from raw[XYZE]
+                                // should move the feedrate scaling to scara inverse_kinematics
 
-        DELTA_RAW_IK();
-        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], in_raw[E_AXIS], fr, active_extruder);
+      const float adiff = FABS(delta[A_AXIS] - scara_oldA),
+                  bdiff = FABS(delta[B_AXIS] - scara_oldB);
+      scara_oldA = delta[A_AXIS];
+      scara_oldB = delta[B_AXIS];
+      float s_feedrate = max(adiff, bdiff) * scara_feed_factor;
 
-      #elif IS_SCARA  // apply scara inverse_kinematics (should be changed to save raw->logical->raw)
+      planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], in_raw[E_AXIS], s_feedrate, active_extruder);
 
-        inverse_kinematics(raw);  // this writes delta[ABC] from raw[XYZE]
-                                  // should move the feedrate scaling to scara inverse_kinematics
+    #else // CARTESIAN
 
-        const float adiff = FABS(delta[A_AXIS] - scara_oldA),
-                    bdiff = FABS(delta[B_AXIS] - scara_oldB);
-        scara_oldA = delta[A_AXIS];
-        scara_oldB = delta[B_AXIS];
-        float s_feedrate = max(adiff, bdiff) * scara_feed_factor;
+      planner.buffer_segment(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], in_raw[E_AXIS], fr, active_extruder);
 
-        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], in_raw[E_AXIS], s_feedrate, active_extruder);
+    #endif
+  }
 
-      #else // CARTESIAN
+  #if IS_SCARA
+    #define DELTA_SEGMENT_MIN_LENGTH 0.25 // SCARA minimum segment size is 0.25mm
+  #elif ENABLED(DELTA)
+    #define DELTA_SEGMENT_MIN_LENGTH 0.10 // mm (still subject to DELTA_SEGMENTS_PER_SECOND)
+  #else // CARTESIAN
+    #ifdef LEVELED_SEGMENT_LENGTH
+      #define DELTA_SEGMENT_MIN_LENGTH LEVELED_SEGMENT_LENGTH
+    #else
+      #define DELTA_SEGMENT_MIN_LENGTH 1.00 // mm (similar to G2/G3 arc segmentation)
+    #endif
+  #endif
 
-        planner.buffer_segment(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], in_raw[E_AXIS], fr, active_extruder);
+  /**
+   * Prepare a segmented linear move for DELTA/SCARA/CARTESIAN with UBL and FADE semantics.
+   * This calls planner.buffer_segment multiple times for small incremental moves.
+   * Returns true if did NOT move, false if moved (requires current_position update).
+   */
 
-      #endif
-    }
+  bool _O2 unified_bed_leveling::prepare_segmented_line_to(const float (&rtarget)[XYZE], const float &feedrate) {
 
-    #if IS_SCARA
-      #define DELTA_SEGMENT_MIN_LENGTH 0.25 // SCARA minimum segment size is 0.25mm
-    #elif ENABLED(DELTA)
-      #define DELTA_SEGMENT_MIN_LENGTH 0.10 // mm (still subject to DELTA_SEGMENTS_PER_SECOND)
-    #else // CARTESIAN
-      #ifdef LEVELED_SEGMENT_LENGTH
-        #define DELTA_SEGMENT_MIN_LENGTH LEVELED_SEGMENT_LENGTH
-      #else
-        #define DELTA_SEGMENT_MIN_LENGTH 1.00 // mm (similar to G2/G3 arc segmentation)
-      #endif
+    if (!position_is_reachable(rtarget[X_AXIS], rtarget[Y_AXIS]))  // fail if moving outside reachable boundary
+      return true; // did not move, so current_position still accurate
+
+    const float total[XYZE] = {
+      rtarget[X_AXIS] - current_position[X_AXIS],
+      rtarget[Y_AXIS] - current_position[Y_AXIS],
+      rtarget[Z_AXIS] - current_position[Z_AXIS],
+      rtarget[E_AXIS] - current_position[E_AXIS]
+    };
+
+    const float cartesian_xy_mm = HYPOT(total[X_AXIS], total[Y_AXIS]);  // total horizontal xy distance
+
+    #if IS_KINEMATIC
+      const float seconds = cartesian_xy_mm / feedrate;                                  // seconds to move xy distance at requested rate
+      uint16_t segments = lroundf(delta_segments_per_second * seconds),                  // preferred number of segments for distance @ feedrate
+               seglimit = lroundf(cartesian_xy_mm * (1.0 / (DELTA_SEGMENT_MIN_LENGTH))); // number of segments at minimum segment length
+      NOMORE(segments, seglimit);                                                        // limit to minimum segment length (fewer segments)
+    #else
+      uint16_t segments = lroundf(cartesian_xy_mm * (1.0 / (DELTA_SEGMENT_MIN_LENGTH))); // cartesian fixed segment length
     #endif
 
-    /**
-     * Prepare a segmented linear move for DELTA/SCARA/CARTESIAN with UBL and FADE semantics.
-     * This calls planner.buffer_segment multiple times for small incremental moves.
-     * Returns true if did NOT move, false if moved (requires current_position update).
-     */
+    NOLESS(segments, 1);                        // must have at least one segment
+    const float inv_segments = 1.0 / segments;  // divide once, multiply thereafter
 
-    bool _O2 unified_bed_leveling::prepare_segmented_line_to(const float (&rtarget)[XYZE], const float &feedrate) {
-
-      if (!position_is_reachable(rtarget[X_AXIS], rtarget[Y_AXIS]))  // fail if moving outside reachable boundary
-        return true; // did not move, so current_position still accurate
-
-      const float total[XYZE] = {
-        rtarget[X_AXIS] - current_position[X_AXIS],
-        rtarget[Y_AXIS] - current_position[Y_AXIS],
-        rtarget[Z_AXIS] - current_position[Z_AXIS],
-        rtarget[E_AXIS] - current_position[E_AXIS]
-      };
-
-      const float cartesian_xy_mm = HYPOT(total[X_AXIS], total[Y_AXIS]);  // total horizontal xy distance
-
-      #if IS_KINEMATIC
-        const float seconds = cartesian_xy_mm / feedrate;                                  // seconds to move xy distance at requested rate
-        uint16_t segments = lroundf(delta_segments_per_second * seconds),                  // preferred number of segments for distance @ feedrate
-                 seglimit = lroundf(cartesian_xy_mm * (1.0 / (DELTA_SEGMENT_MIN_LENGTH))); // number of segments at minimum segment length
-        NOMORE(segments, seglimit);                                                        // limit to minimum segment length (fewer segments)
-      #else
-        uint16_t segments = lroundf(cartesian_xy_mm * (1.0 / (DELTA_SEGMENT_MIN_LENGTH))); // cartesian fixed segment length
-      #endif
-
-      NOLESS(segments, 1);                        // must have at least one segment
-      const float inv_segments = 1.0 / segments;  // divide once, multiply thereafter
-
-      #if IS_SCARA // scale the feed rate from mm/s to degrees/s
-        scara_feed_factor = cartesian_xy_mm * inv_segments * feedrate;
-        scara_oldA = stepper.get_axis_position_degrees(A_AXIS);
-        scara_oldB = stepper.get_axis_position_degrees(B_AXIS);
-      #endif
-
-      const float diff[XYZE] = {
-        total[X_AXIS] * inv_segments,
-        total[Y_AXIS] * inv_segments,
-        total[Z_AXIS] * inv_segments,
-        total[E_AXIS] * inv_segments
-      };
-
-      // Note that E segment distance could vary slightly as z mesh height
-      // changes for each segment, but small enough to ignore.
-
-      float raw[XYZE] = {
-        current_position[X_AXIS],
-        current_position[Y_AXIS],
-        current_position[Z_AXIS],
-        current_position[E_AXIS]
-      };
-
-      // Only compute leveling per segment if ubl active and target below z_fade_height.
-      if (!planner.leveling_active || !planner.leveling_active_at_z(rtarget[Z_AXIS])) {   // no mesh leveling
-        while (--segments) {
-          LOOP_XYZE(i) raw[i] += diff[i];
-          ubl_buffer_segment_raw(raw, feedrate);
-        }
-        ubl_buffer_segment_raw(rtarget, feedrate);
-        return false; // moved but did not set_current_from_destination();
+    #if IS_SCARA // scale the feed rate from mm/s to degrees/s
+      scara_feed_factor = cartesian_xy_mm * inv_segments * feedrate;
+      scara_oldA = stepper.get_axis_position_degrees(A_AXIS);
+      scara_oldB = stepper.get_axis_position_degrees(B_AXIS);
+    #endif
+
+    const float diff[XYZE] = {
+      total[X_AXIS] * inv_segments,
+      total[Y_AXIS] * inv_segments,
+      total[Z_AXIS] * inv_segments,
+      total[E_AXIS] * inv_segments
+    };
+
+    // Note that E segment distance could vary slightly as z mesh height
+    // changes for each segment, but small enough to ignore.
+
+    float raw[XYZE] = {
+      current_position[X_AXIS],
+      current_position[Y_AXIS],
+      current_position[Z_AXIS],
+      current_position[E_AXIS]
+    };
+
+    // Only compute leveling per segment if ubl active and target below z_fade_height.
+    if (!planner.leveling_active || !planner.leveling_active_at_z(rtarget[Z_AXIS])) {   // no mesh leveling
+      while (--segments) {
+        LOOP_XYZE(i) raw[i] += diff[i];
+        ubl_buffer_segment_raw(raw, feedrate);
       }
+      ubl_buffer_segment_raw(rtarget, feedrate);
+      return false; // moved but did not set_current_from_destination();
+    }
 
-      // Otherwise perform per-segment leveling
+    // Otherwise perform per-segment leveling
 
-      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        const float fade_scaling_factor = planner.fade_scaling_factor_for_z(rtarget[Z_AXIS]);
-      #endif
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      const float fade_scaling_factor = planner.fade_scaling_factor_for_z(rtarget[Z_AXIS]);
+    #endif
 
-      // increment to first segment destination
-      LOOP_XYZE(i) raw[i] += diff[i];
+    // increment to first segment destination
+    LOOP_XYZE(i) raw[i] += diff[i];
 
-      for(;;) {  // for each mesh cell encountered during the move
+    for(;;) {  // for each mesh cell encountered during the move
 
-        // Compute mesh cell invariants that remain constant for all segments within cell.
-        // Note for cell index, if point is outside the mesh grid (in MESH_INSET perimeter)
-        // the bilinear interpolation from the adjacent cell within the mesh will still work.
-        // Inner loop will exit each time (because out of cell bounds) but will come back
-        // in top of loop and again re-find same adjacent cell and use it, just less efficient
-        // for mesh inset area.
+      // Compute mesh cell invariants that remain constant for all segments within cell.
+      // Note for cell index, if point is outside the mesh grid (in MESH_INSET perimeter)
+      // the bilinear interpolation from the adjacent cell within the mesh will still work.
+      // Inner loop will exit each time (because out of cell bounds) but will come back
+      // in top of loop and again re-find same adjacent cell and use it, just less efficient
+      // for mesh inset area.
 
-        int8_t cell_xi = (raw[X_AXIS] - (MESH_MIN_X)) * (1.0 / (MESH_X_DIST)),
-               cell_yi = (raw[Y_AXIS] - (MESH_MIN_Y)) * (1.0 / (MESH_X_DIST));
+      int8_t cell_xi = (raw[X_AXIS] - (MESH_MIN_X)) * (1.0 / (MESH_X_DIST)),
+             cell_yi = (raw[Y_AXIS] - (MESH_MIN_Y)) * (1.0 / (MESH_X_DIST));
 
-        cell_xi = constrain(cell_xi, 0, (GRID_MAX_POINTS_X) - 1);
-        cell_yi = constrain(cell_yi, 0, (GRID_MAX_POINTS_Y) - 1);
+      cell_xi = constrain(cell_xi, 0, (GRID_MAX_POINTS_X) - 1);
+      cell_yi = constrain(cell_yi, 0, (GRID_MAX_POINTS_Y) - 1);
 
-        const float x0 = mesh_index_to_xpos(cell_xi),   // 64 byte table lookup avoids mul+add
-                    y0 = mesh_index_to_ypos(cell_yi);
+      const float x0 = mesh_index_to_xpos(cell_xi),   // 64 byte table lookup avoids mul+add
+                  y0 = mesh_index_to_ypos(cell_yi);
 
-        float z_x0y0 = z_values[cell_xi  ][cell_yi  ],  // z at lower left corner
-              z_x1y0 = z_values[cell_xi+1][cell_yi  ],  // z at upper left corner
-              z_x0y1 = z_values[cell_xi  ][cell_yi+1],  // z at lower right corner
-              z_x1y1 = z_values[cell_xi+1][cell_yi+1];  // z at upper right corner
+      float z_x0y0 = z_values[cell_xi  ][cell_yi  ],  // z at lower left corner
+            z_x1y0 = z_values[cell_xi+1][cell_yi  ],  // z at upper left corner
+            z_x0y1 = z_values[cell_xi  ][cell_yi+1],  // z at lower right corner
+            z_x1y1 = z_values[cell_xi+1][cell_yi+1];  // z at upper right corner
 
-        if (isnan(z_x0y0)) z_x0y0 = 0;              // ideally activating planner.leveling_active (G29 A)
-        if (isnan(z_x1y0)) z_x1y0 = 0;              //   should refuse if any invalid mesh points
-        if (isnan(z_x0y1)) z_x0y1 = 0;              //   in order to avoid isnan tests per cell,
-        if (isnan(z_x1y1)) z_x1y1 = 0;              //   thus guessing zero for undefined points
+      if (isnan(z_x0y0)) z_x0y0 = 0;              // ideally activating planner.leveling_active (G29 A)
+      if (isnan(z_x1y0)) z_x1y0 = 0;              //   should refuse if any invalid mesh points
+      if (isnan(z_x0y1)) z_x0y1 = 0;              //   in order to avoid isnan tests per cell,
+      if (isnan(z_x1y1)) z_x1y1 = 0;              //   thus guessing zero for undefined points
 
-        float cx = raw[X_AXIS] - x0,   // cell-relative x and y
-              cy = raw[Y_AXIS] - y0;
+      float cx = raw[X_AXIS] - x0,   // cell-relative x and y
+            cy = raw[Y_AXIS] - y0;
 
-        const float z_xmy0 = (z_x1y0 - z_x0y0) * (1.0 / (MESH_X_DIST)),   // z slope per x along y0 (lower left to lower right)
-                    z_xmy1 = (z_x1y1 - z_x0y1) * (1.0 / (MESH_X_DIST));   // z slope per x along y1 (upper left to upper right)
+      const float z_xmy0 = (z_x1y0 - z_x0y0) * (1.0 / (MESH_X_DIST)),   // z slope per x along y0 (lower left to lower right)
+                  z_xmy1 = (z_x1y1 - z_x0y1) * (1.0 / (MESH_X_DIST));   // z slope per x along y1 (upper left to upper right)
 
-              float z_cxy0 = z_x0y0 + z_xmy0 * cx;            // z height along y0 at cx (changes for each cx in cell)
+            float z_cxy0 = z_x0y0 + z_xmy0 * cx;            // z height along y0 at cx (changes for each cx in cell)
 
-        const float z_cxy1 = z_x0y1 + z_xmy1 * cx,            // z height along y1 at cx
-                    z_cxyd = z_cxy1 - z_cxy0;                 // z height difference along cx from y0 to y1
+      const float z_cxy1 = z_x0y1 + z_xmy1 * cx,            // z height along y1 at cx
+                  z_cxyd = z_cxy1 - z_cxy0;                 // z height difference along cx from y0 to y1
 
-              float z_cxym = z_cxyd * (1.0 / (MESH_Y_DIST));  // z slope per y along cx from y0 to y1 (changes for each cx in cell)
+            float z_cxym = z_cxyd * (1.0 / (MESH_Y_DIST));  // z slope per y along cx from y0 to y1 (changes for each cx in cell)
 
-        //    float z_cxcy = z_cxy0 + z_cxym * cy;            // interpolated mesh z height along cx at cy (do inside the segment loop)
+      //    float z_cxcy = z_cxy0 + z_cxym * cy;            // interpolated mesh z height along cx at cy (do inside the segment loop)
 
-        // As subsequent segments step through this cell, the z_cxy0 intercept will change
-        // and the z_cxym slope will change, both as a function of cx within the cell, and
-        // each change by a constant for fixed segment lengths.
+      // As subsequent segments step through this cell, the z_cxy0 intercept will change
+      // and the z_cxym slope will change, both as a function of cx within the cell, and
+      // each change by a constant for fixed segment lengths.
 
-        const float z_sxy0 = z_xmy0 * diff[X_AXIS],                                     // per-segment adjustment to z_cxy0
-                    z_sxym = (z_xmy1 - z_xmy0) * (1.0 / (MESH_Y_DIST)) * diff[X_AXIS];  // per-segment adjustment to z_cxym
+      const float z_sxy0 = z_xmy0 * diff[X_AXIS],                                     // per-segment adjustment to z_cxy0
+                  z_sxym = (z_xmy1 - z_xmy0) * (1.0 / (MESH_Y_DIST)) * diff[X_AXIS];  // per-segment adjustment to z_cxym
 
-        for(;;) {  // for all segments within this mesh cell
+      for(;;) {  // for all segments within this mesh cell
 
-          if (--segments == 0)                      // if this is last segment, use rtarget for exact
-            COPY(raw, rtarget);
+        if (--segments == 0)                      // if this is last segment, use rtarget for exact
+          COPY(raw, rtarget);
 
-          const float z_cxcy = (z_cxy0 + z_cxym * cy) // interpolated mesh z height along cx at cy
-            #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-              * fade_scaling_factor                   // apply fade factor to interpolated mesh height
-            #endif
-          ;
+        const float z_cxcy = (z_cxy0 + z_cxym * cy) // interpolated mesh z height along cx at cy
+          #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+            * fade_scaling_factor                   // apply fade factor to interpolated mesh height
+          #endif
+        ;
 
-          const float z = raw[Z_AXIS];
-          raw[Z_AXIS] += z_cxcy;
-          ubl_buffer_segment_raw(raw, feedrate);
-          raw[Z_AXIS] = z;
+        const float z = raw[Z_AXIS];
+        raw[Z_AXIS] += z_cxcy;
+        ubl_buffer_segment_raw(raw, feedrate);
+        raw[Z_AXIS] = z;
 
-          if (segments == 0)                        // done with last segment
-            return false;                           // did not set_current_from_destination()
+        if (segments == 0)                        // done with last segment
+          return false;                           // did not set_current_from_destination()
 
-          LOOP_XYZE(i) raw[i] += diff[i];
+        LOOP_XYZE(i) raw[i] += diff[i];
 
-          cx += diff[X_AXIS];
-          cy += diff[Y_AXIS];
+        cx += diff[X_AXIS];
+        cy += diff[Y_AXIS];
 
-          if (!WITHIN(cx, 0, MESH_X_DIST) || !WITHIN(cy, 0, MESH_Y_DIST))    // done within this cell, break to next
-            break;
+        if (!WITHIN(cx, 0, MESH_X_DIST) || !WITHIN(cy, 0, MESH_Y_DIST))    // done within this cell, break to next
+          break;
 
-          // Next segment still within same mesh cell, adjust the per-segment
-          // slope and intercept to compute next z height.
+        // Next segment still within same mesh cell, adjust the per-segment
+        // slope and intercept to compute next z height.
 
-          z_cxy0 += z_sxy0;   // adjust z_cxy0 by per-segment z_sxy0
-          z_cxym += z_sxym;   // adjust z_cxym by per-segment z_sxym
+        z_cxy0 += z_sxy0;   // adjust z_cxy0 by per-segment z_sxy0
+        z_cxym += z_sxym;   // adjust z_cxym by per-segment z_sxym
 
-        } // segment loop
-      } // cell loop
-    }
+      } // segment loop
+    } // cell loop
+  }
 
 #endif // UBL_SEGMENTED
 

commit 6d0678d9633057dfc338b127d55026a4a28e119d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 07:55:55 2017 -0600

    Omit unused UBL motion code

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 63ea07472c..98d979e6ea 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -41,6 +41,8 @@
     extern void set_current_from_destination();
   #endif
 
+#if !UBL_SEGMENTED
+
   void unified_bed_leveling::line_to_destination_cartesian(const float &feed_rate, const uint8_t extruder) {
     /**
      * Much of the nozzle movement will be within the same cell. So we will do as little computation
@@ -405,7 +407,7 @@
     set_current_from_destination();
   }
 
-  #if UBL_SEGMENTED
+#else // UBL_SEGMENTED
 
     #if IS_SCARA // scale the feed rate from mm/s to degrees/s
       static float scara_feed_factor, scara_oldA, scara_oldB;
@@ -621,6 +623,6 @@
       } // cell loop
     }
 
-  #endif // UBL_SEGMENTED
+#endif // UBL_SEGMENTED
 
 #endif // AUTO_BED_LEVELING_UBL

commit 3255712343fdc9177cc94c86b2c31bf94ffbb8ca
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 07:50:55 2017 -0600

    Skew Correction for UBL
    
    Also remove unused grid slicing function when using UBL segmented.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 942c5dbdbd..63ea07472c 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -47,18 +47,16 @@
      * as possible to determine if this is the case. If this move is within the same cell, we will
      * just do the required Z-Height correction, call the Planner's buffer_line() routine, and leave
      */
-    const float start[XYZE] = {
-                  current_position[X_AXIS],
-                  current_position[Y_AXIS],
-                  current_position[Z_AXIS],
-                  current_position[E_AXIS]
-                },
-                end[XYZE] = {
-                  destination[X_AXIS],
-                  destination[Y_AXIS],
-                  destination[Z_AXIS],
-                  destination[E_AXIS]
-                };
+    #if ENABLED(SKEW_CORRECTION)
+      // For skew correction just adjust the destination point and we're done
+      float start[XYZE] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS] },
+            end[XYZE] = { destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS] };
+      planner.skew(start[X_AXIS], start[Y_AXIS], start[Z_AXIS]);
+      planner.skew(end[X_AXIS], end[Y_AXIS], end[Z_AXIS]);
+    #else
+      const float (&start)[XYZE] = current_position,
+                    (&end)[XYZE] = destination;
+    #endif
 
     const int cell_start_xi = get_cell_index_x(start[X_AXIS]),
               cell_start_yi = get_cell_index_y(start[Y_AXIS]),
@@ -66,10 +64,10 @@
               cell_dest_yi  = get_cell_index_y(end[Y_AXIS]);
 
     if (g26_debug_flag) {
-      SERIAL_ECHOPAIR(" ubl.line_to_destination(xe=", end[X_AXIS]);
-      SERIAL_ECHOPAIR(", ye=", end[Y_AXIS]);
-      SERIAL_ECHOPAIR(", ze=", end[Z_AXIS]);
-      SERIAL_ECHOPAIR(", ee=", end[E_AXIS]);
+      SERIAL_ECHOPAIR(" ubl.line_to_destination_cartesian(xe=", destination[X_AXIS]);
+      SERIAL_ECHOPAIR(", ye=", destination[Y_AXIS]);
+      SERIAL_ECHOPAIR(", ze=", destination[Z_AXIS]);
+      SERIAL_ECHOPAIR(", ee=", destination[E_AXIS]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
       debug_current_and_destination(PSTR("Start of ubl.line_to_destination_cartesian()"));
@@ -416,12 +414,19 @@
     // We don't want additional apply_leveling() performed by regular buffer_line or buffer_line_kinematic,
     // so we call buffer_segment directly here.  Per-segmented leveling and kinematics performed first.
 
-    inline void _O2 ubl_buffer_segment_raw(const float (&raw)[XYZE], const float &fr) {
+    inline void _O2 ubl_buffer_segment_raw(const float (&in_raw)[XYZE], const float &fr) {
+
+      #if ENABLED(SKEW_CORRECTION)
+        float raw[XYZE] = { in_raw[X_AXIS], in_raw[Y_AXIS], in_raw[Z_AXIS] };
+        planner.skew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]);
+      #else
+        const float (&raw)[XYZE] = in_raw;
+      #endif
 
       #if ENABLED(DELTA)  // apply delta inverse_kinematics
 
         DELTA_RAW_IK();
-        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], fr, active_extruder);
+        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], in_raw[E_AXIS], fr, active_extruder);
 
       #elif IS_SCARA  // apply scara inverse_kinematics (should be changed to save raw->logical->raw)
 
@@ -434,11 +439,11 @@
         scara_oldB = delta[B_AXIS];
         float s_feedrate = max(adiff, bdiff) * scara_feed_factor;
 
-        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], s_feedrate, active_extruder);
+        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], in_raw[E_AXIS], s_feedrate, active_extruder);
 
       #else // CARTESIAN
 
-        planner.buffer_segment(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], raw[E_AXIS], fr, active_extruder);
+        planner.buffer_segment(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], in_raw[E_AXIS], fr, active_extruder);
 
       #endif
     }
@@ -461,7 +466,7 @@
      * Returns true if did NOT move, false if moved (requires current_position update).
      */
 
-    bool _O2 unified_bed_leveling::prepare_segmented_line_to(const float rtarget[XYZE], const float &feedrate) {
+    bool _O2 unified_bed_leveling::prepare_segmented_line_to(const float (&rtarget)[XYZE], const float &feedrate) {
 
       if (!position_is_reachable(rtarget[X_AXIS], rtarget[Y_AXIS]))  // fail if moving outside reachable boundary
         return true; // did not move, so current_position still accurate

commit 3d796d80404896dde4d1360859b6b2def158547a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 07:14:06 2017 -0600

    Move debug code

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index f3da33dfda..942c5dbdbd 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -35,63 +35,12 @@
   #include "../../../Marlin.h"
   #include <math.h>
 
-  extern float destination[XYZE];
-
   #if AVR_AT90USB1286_FAMILY  // Teensyduino & Printrboard IDE extensions have compile errors without this
     inline void set_current_from_destination() { COPY(current_position, destination); }
   #else
     extern void set_current_from_destination();
   #endif
 
-  static void debug_echo_axis(const AxisEnum axis) {
-    if (current_position[axis] == destination[axis])
-      SERIAL_ECHOPGM("-------------");
-    else
-      SERIAL_ECHO_F(destination[X_AXIS], 6);
-  }
-
-  void debug_current_and_destination(const char *title) {
-
-    // if the title message starts with a '!' it is so important, we are going to
-    // ignore the status of the g26_debug_flag
-    if (*title != '!' && !g26_debug_flag) return;
-
-    const float de = destination[E_AXIS] - current_position[E_AXIS];
-
-    if (de == 0.0) return; // Printing moves only
-
-    const float dx = destination[X_AXIS] - current_position[X_AXIS],
-                dy = destination[Y_AXIS] - current_position[Y_AXIS],
-                xy_dist = HYPOT(dx, dy);
-
-    if (xy_dist == 0.0) return;
-
-    SERIAL_ECHOPGM("   fpmm=");
-    const float fpmm = de / xy_dist;
-    SERIAL_ECHO_F(fpmm, 6);
-
-    SERIAL_ECHOPGM("    current=( ");
-    SERIAL_ECHO_F(current_position[X_AXIS], 6);
-    SERIAL_ECHOPGM(", ");
-    SERIAL_ECHO_F(current_position[Y_AXIS], 6);
-    SERIAL_ECHOPGM(", ");
-    SERIAL_ECHO_F(current_position[Z_AXIS], 6);
-    SERIAL_ECHOPGM(", ");
-    SERIAL_ECHO_F(current_position[E_AXIS], 6);
-    SERIAL_ECHOPGM(" )   destination=( ");
-    debug_echo_axis(X_AXIS);
-    SERIAL_ECHOPGM(", ");
-    debug_echo_axis(Y_AXIS);
-    SERIAL_ECHOPGM(", ");
-    debug_echo_axis(Z_AXIS);
-    SERIAL_ECHOPGM(", ");
-    debug_echo_axis(E_AXIS);
-    SERIAL_ECHOPGM(" )   ");
-    SERIAL_ECHO(title);
-    SERIAL_EOL();
-
-  }
-
   void unified_bed_leveling::line_to_destination_cartesian(const float &feed_rate, const uint8_t extruder) {
     /**
      * Much of the nozzle movement will be within the same cell. So we will do as little computation
@@ -123,7 +72,7 @@
       SERIAL_ECHOPAIR(", ee=", end[E_AXIS]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
-      debug_current_and_destination(PSTR("Start of ubl.line_to_destination()"));
+      debug_current_and_destination(PSTR("Start of ubl.line_to_destination_cartesian()"));
     }
 
     if (cell_start_xi == cell_dest_xi && cell_start_yi == cell_dest_yi) { // if the whole move is within the same cell,
@@ -143,7 +92,7 @@
         set_current_from_destination();
 
         if (g26_debug_flag)
-          debug_current_and_destination(PSTR("out of bounds in ubl.line_to_destination()"));
+          debug_current_and_destination(PSTR("out of bounds in ubl.line_to_destination_cartesian()"));
 
         return;
       }
@@ -186,7 +135,7 @@
       planner.buffer_segment(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + z0, end[E_AXIS], feed_rate, extruder);
 
       if (g26_debug_flag)
-        debug_current_and_destination(PSTR("FINAL_MOVE in ubl.line_to_destination()"));
+        debug_current_and_destination(PSTR("FINAL_MOVE in ubl.line_to_destination_cartesian()"));
 
       set_current_from_destination();
       return;
@@ -292,7 +241,7 @@
       }
 
       if (g26_debug_flag)
-        debug_current_and_destination(PSTR("vertical move done in ubl.line_to_destination()"));
+        debug_current_and_destination(PSTR("vertical move done in ubl.line_to_destination_cartesian()"));
 
       //
       // Check if we are at the final destination. Usually, we won't be, but if it is on a Y Mesh Line, we are done.
@@ -356,7 +305,7 @@
       }
 
       if (g26_debug_flag)
-        debug_current_and_destination(PSTR("horizontal move done in ubl.line_to_destination()"));
+        debug_current_and_destination(PSTR("horizontal move done in ubl.line_to_destination_cartesian()"));
 
       if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
         goto FINAL_MOVE;
@@ -450,7 +399,7 @@
     }
 
     if (g26_debug_flag)
-      debug_current_and_destination(PSTR("generic move done in ubl.line_to_destination()"));
+      debug_current_and_destination(PSTR("generic move done in ubl.line_to_destination_cartesian()"));
 
     if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
       goto FINAL_MOVE;

commit 3db5303bfeed53180fb6a53caffcdf822fcfb285
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 07:41:19 2017 -0600

    _buffer_line => buffer_segment

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index ef78fba77b..f3da33dfda 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -139,7 +139,7 @@
         // Note: There is no Z Correction in this case. We are off the grid and don't know what
         // a reasonable correction would be.
 
-        planner._buffer_line(end[X_AXIS], end[Y_AXIS], end[Z_AXIS], end[E_AXIS], feed_rate, extruder);
+        planner.buffer_segment(end[X_AXIS], end[Y_AXIS], end[Z_AXIS], end[E_AXIS], feed_rate, extruder);
         set_current_from_destination();
 
         if (g26_debug_flag)
@@ -183,7 +183,7 @@
        */
       if (isnan(z0)) z0 = 0.0;
 
-      planner._buffer_line(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + z0, end[E_AXIS], feed_rate, extruder);
+      planner.buffer_segment(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + z0, end[E_AXIS], feed_rate, extruder);
 
       if (g26_debug_flag)
         debug_current_and_destination(PSTR("FINAL_MOVE in ubl.line_to_destination()"));
@@ -274,7 +274,7 @@
          * Without this check, it is possible for the algorithm to generate a zero length move in the case
          * where the line is heading down and it is starting right on a Mesh Line boundary. For how often that
          * happens, it might be best to remove the check and always 'schedule' the move because
-         * the planner._buffer_line() routine will filter it if that happens.
+         * the planner.buffer_segment() routine will filter it if that happens.
          */
         if (ry != start[Y_AXIS]) {
           if (!inf_normalized_flag) {
@@ -287,7 +287,7 @@
             z_position = end[Z_AXIS];
           }
 
-          planner._buffer_line(rx, ry, z_position + z0, e_position, feed_rate, extruder);
+          planner.buffer_segment(rx, ry, z_position + z0, e_position, feed_rate, extruder);
         } //else printf("FIRST MOVE PRUNED  ");
       }
 
@@ -338,7 +338,7 @@
          * Without this check, it is possible for the algorithm to generate a zero length move in the case
          * where the line is heading left and it is starting right on a Mesh Line boundary. For how often
          * that happens, it might be best to remove the check and always 'schedule' the move because
-         * the planner._buffer_line() routine will filter it if that happens.
+         * the planner.buffer_segment() routine will filter it if that happens.
          */
         if (rx != start[X_AXIS]) {
           if (!inf_normalized_flag) {
@@ -351,7 +351,7 @@
             z_position = end[Z_AXIS];
           }
 
-          planner._buffer_line(rx, ry, z_position + z0, e_position, feed_rate, extruder);
+          planner.buffer_segment(rx, ry, z_position + z0, e_position, feed_rate, extruder);
         } //else printf("FIRST MOVE PRUNED  ");
       }
 
@@ -413,7 +413,7 @@
           e_position = end[E_AXIS];
           z_position = end[Z_AXIS];
         }
-        planner._buffer_line(rx, next_mesh_line_y, z_position + z0, e_position, feed_rate, extruder);
+        planner.buffer_segment(rx, next_mesh_line_y, z_position + z0, e_position, feed_rate, extruder);
         current_yi += dyi;
         yi_cnt--;
       }
@@ -441,7 +441,7 @@
           z_position = end[Z_AXIS];
         }
 
-        planner._buffer_line(next_mesh_line_x, ry, z_position + z0, e_position, feed_rate, extruder);
+        planner.buffer_segment(next_mesh_line_x, ry, z_position + z0, e_position, feed_rate, extruder);
         current_xi += dxi;
         xi_cnt--;
       }
@@ -465,14 +465,14 @@
     #endif
 
     // We don't want additional apply_leveling() performed by regular buffer_line or buffer_line_kinematic,
-    // so we call _buffer_line directly here.  Per-segmented leveling and kinematics performed first.
+    // so we call buffer_segment directly here.  Per-segmented leveling and kinematics performed first.
 
     inline void _O2 ubl_buffer_segment_raw(const float (&raw)[XYZE], const float &fr) {
 
       #if ENABLED(DELTA)  // apply delta inverse_kinematics
 
         DELTA_RAW_IK();
-        planner._buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], fr, active_extruder);
+        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], fr, active_extruder);
 
       #elif IS_SCARA  // apply scara inverse_kinematics (should be changed to save raw->logical->raw)
 
@@ -485,11 +485,11 @@
         scara_oldB = delta[B_AXIS];
         float s_feedrate = max(adiff, bdiff) * scara_feed_factor;
 
-        planner._buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], s_feedrate, active_extruder);
+        planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], s_feedrate, active_extruder);
 
       #else // CARTESIAN
 
-        planner._buffer_line(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], raw[E_AXIS], fr, active_extruder);
+        planner.buffer_segment(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], raw[E_AXIS], fr, active_extruder);
 
       #endif
     }
@@ -508,7 +508,7 @@
 
     /**
      * Prepare a segmented linear move for DELTA/SCARA/CARTESIAN with UBL and FADE semantics.
-     * This calls planner._buffer_line multiple times for small incremental moves.
+     * This calls planner.buffer_segment multiple times for small incremental moves.
      * Returns true if did NOT move, false if moved (requires current_position update).
      */
 

commit a71d2f3f40639945676eede207a9b4f4f5c6d122
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 02:11:31 2017 -0600

    UBL_DELTA => UBL_SEGMENTED

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 53a4ffb751..ef78fba77b 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -458,15 +458,7 @@
     set_current_from_destination();
   }
 
-  #if UBL_DELTA
-
-    // macro to inline copy exactly 4 floats, don't rely on sizeof operator
-    #define COPY_XYZE( target, source ) { \
-                target[X_AXIS] = source[X_AXIS]; \
-                target[Y_AXIS] = source[Y_AXIS]; \
-                target[Z_AXIS] = source[Z_AXIS]; \
-                target[E_AXIS] = source[E_AXIS]; \
-            }
+  #if UBL_SEGMENTED
 
     #if IS_SCARA // scale the feed rate from mm/s to degrees/s
       static float scara_feed_factor, scara_oldA, scara_oldB;
@@ -675,6 +667,6 @@
       } // cell loop
     }
 
-  #endif // UBL_DELTA
+  #endif // UBL_SEGMENTED
 
 #endif // AUTO_BED_LEVELING_UBL

commit 73e32925e4b140fe23f62eeb658f807e4477d872
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 02:10:54 2017 -0600

    References are better for array args

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index d8fbe284ac..53a4ffb751 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -92,7 +92,7 @@
 
   }
 
-  void unified_bed_leveling::line_to_destination_cartesian(const float &feed_rate, uint8_t extruder) {
+  void unified_bed_leveling::line_to_destination_cartesian(const float &feed_rate, const uint8_t extruder) {
     /**
      * Much of the nozzle movement will be within the same cell. So we will do as little computation
      * as possible to determine if this is the case. If this move is within the same cell, we will
@@ -475,7 +475,7 @@
     // We don't want additional apply_leveling() performed by regular buffer_line or buffer_line_kinematic,
     // so we call _buffer_line directly here.  Per-segmented leveling and kinematics performed first.
 
-    inline void _O2 ubl_buffer_segment_raw(const float raw[XYZE], const float &fr) {
+    inline void _O2 ubl_buffer_segment_raw(const float (&raw)[XYZE], const float &fr) {
 
       #if ENABLED(DELTA)  // apply delta inverse_kinematics
 

commit 24437de5913901bbca13e20fd2eaf1922877b194
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 3 00:10:54 2017 -0600

    Use custom segment length for UBL Cartesian

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 466bf463a2..d8fbe284ac 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -484,8 +484,8 @@
 
       #elif IS_SCARA  // apply scara inverse_kinematics (should be changed to save raw->logical->raw)
 
-        inverse_kinematics(raw); // this writes delta[ABC] from raw[XYZE]
-                                 // should move the feedrate scaling to scara inverse_kinematics
+        inverse_kinematics(raw);  // this writes delta[ABC] from raw[XYZE]
+                                  // should move the feedrate scaling to scara inverse_kinematics
 
         const float adiff = FABS(delta[A_AXIS] - scara_oldA),
                     bdiff = FABS(delta[B_AXIS] - scara_oldB);
@@ -500,9 +500,19 @@
         planner._buffer_line(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], raw[E_AXIS], fr, active_extruder);
 
       #endif
-
     }
 
+    #if IS_SCARA
+      #define DELTA_SEGMENT_MIN_LENGTH 0.25 // SCARA minimum segment size is 0.25mm
+    #elif ENABLED(DELTA)
+      #define DELTA_SEGMENT_MIN_LENGTH 0.10 // mm (still subject to DELTA_SEGMENTS_PER_SECOND)
+    #else // CARTESIAN
+      #ifdef LEVELED_SEGMENT_LENGTH
+        #define DELTA_SEGMENT_MIN_LENGTH LEVELED_SEGMENT_LENGTH
+      #else
+        #define DELTA_SEGMENT_MIN_LENGTH 1.00 // mm (similar to G2/G3 arc segmentation)
+      #endif
+    #endif
 
     /**
      * Prepare a segmented linear move for DELTA/SCARA/CARTESIAN with UBL and FADE semantics.
@@ -633,10 +643,11 @@
           if (--segments == 0)                      // if this is last segment, use rtarget for exact
             COPY(raw, rtarget);
 
-          float z_cxcy = z_cxy0 + z_cxym * cy;      // interpolated mesh z height along cx at cy
-          #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-            z_cxcy *= fade_scaling_factor;          // apply fade factor to interpolated mesh height
-          #endif
+          const float z_cxcy = (z_cxy0 + z_cxym * cy) // interpolated mesh z height along cx at cy
+            #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+              * fade_scaling_factor                   // apply fade factor to interpolated mesh height
+            #endif
+          ;
 
           const float z = raw[Z_AXIS];
           raw[Z_AXIS] += z_cxcy;

commit 000b3b3117c500f51be05cdb136ce56617edd69a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 1 21:43:44 2017 -0600

    Comment/cleanup of motion code

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index d04ec3dde0..466bf463a2 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -475,30 +475,17 @@
     // We don't want additional apply_leveling() performed by regular buffer_line or buffer_line_kinematic,
     // so we call _buffer_line directly here.  Per-segmented leveling and kinematics performed first.
 
-    inline void _O2 ubl_buffer_segment_raw(const float &rx, const float &ry, const float rz, const float &e, const float &fr) {
+    inline void _O2 ubl_buffer_segment_raw(const float raw[XYZE], const float &fr) {
 
       #if ENABLED(DELTA)  // apply delta inverse_kinematics
 
-        const float delta_A = rz + SQRT( delta_diagonal_rod_2_tower[A_AXIS]
-                                         - HYPOT2( delta_tower[A_AXIS][X_AXIS] - rx,
-                                                   delta_tower[A_AXIS][Y_AXIS] - ry ));
-
-        const float delta_B = rz + SQRT( delta_diagonal_rod_2_tower[B_AXIS]
-                                         - HYPOT2( delta_tower[B_AXIS][X_AXIS] - rx,
-                                                   delta_tower[B_AXIS][Y_AXIS] - ry ));
-
-        const float delta_C = rz + SQRT( delta_diagonal_rod_2_tower[C_AXIS]
-                                         - HYPOT2( delta_tower[C_AXIS][X_AXIS] - rx,
-                                                   delta_tower[C_AXIS][Y_AXIS] - ry ));
-
-        planner._buffer_line(delta_A, delta_B, delta_C, e, fr, active_extruder);
+        DELTA_RAW_IK();
+        planner._buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], fr, active_extruder);
 
       #elif IS_SCARA  // apply scara inverse_kinematics (should be changed to save raw->logical->raw)
 
-        const float lseg[XYZ] = { rx, ry, rz };
-
-        inverse_kinematics(lseg); // this writes delta[ABC] from lseg[XYZ]
-                                  // should move the feedrate scaling to scara inverse_kinematics
+        inverse_kinematics(raw); // this writes delta[ABC] from raw[XYZE]
+                                 // should move the feedrate scaling to scara inverse_kinematics
 
         const float adiff = FABS(delta[A_AXIS] - scara_oldA),
                     bdiff = FABS(delta[B_AXIS] - scara_oldB);
@@ -506,11 +493,11 @@
         scara_oldB = delta[B_AXIS];
         float s_feedrate = max(adiff, bdiff) * scara_feed_factor;
 
-        planner._buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], e, s_feedrate, active_extruder);
+        planner._buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], s_feedrate, active_extruder);
 
       #else // CARTESIAN
 
-        planner._buffer_line(rx, ry, rz, e, fr, active_extruder);
+        planner._buffer_line(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], raw[E_AXIS], fr, active_extruder);
 
       #endif
 
@@ -528,12 +515,14 @@
       if (!position_is_reachable(rtarget[X_AXIS], rtarget[Y_AXIS]))  // fail if moving outside reachable boundary
         return true; // did not move, so current_position still accurate
 
-      const float tot_dx = rtarget[X_AXIS] - current_position[X_AXIS],
-                  tot_dy = rtarget[Y_AXIS] - current_position[Y_AXIS],
-                  tot_dz = rtarget[Z_AXIS] - current_position[Z_AXIS],
-                  tot_de = rtarget[E_AXIS] - current_position[E_AXIS];
+      const float total[XYZE] = {
+        rtarget[X_AXIS] - current_position[X_AXIS],
+        rtarget[Y_AXIS] - current_position[Y_AXIS],
+        rtarget[Z_AXIS] - current_position[Z_AXIS],
+        rtarget[E_AXIS] - current_position[E_AXIS]
+      };
 
-      const float cartesian_xy_mm = HYPOT(tot_dx, tot_dy);  // total horizontal xy distance
+      const float cartesian_xy_mm = HYPOT(total[X_AXIS], total[Y_AXIS]);  // total horizontal xy distance
 
       #if IS_KINEMATIC
         const float seconds = cartesian_xy_mm / feedrate;                                  // seconds to move xy distance at requested rate
@@ -553,41 +542,30 @@
         scara_oldB = stepper.get_axis_position_degrees(B_AXIS);
       #endif
 
-      const float seg_dx = tot_dx * inv_segments,
-                  seg_dy = tot_dy * inv_segments,
-                  seg_dz = tot_dz * inv_segments,
-                  seg_de = tot_de * inv_segments;
+      const float diff[XYZE] = {
+        total[X_AXIS] * inv_segments,
+        total[Y_AXIS] * inv_segments,
+        total[Z_AXIS] * inv_segments,
+        total[E_AXIS] * inv_segments
+      };
 
       // Note that E segment distance could vary slightly as z mesh height
       // changes for each segment, but small enough to ignore.
 
-      float seg_rx = current_position[X_AXIS],
-            seg_ry = current_position[Y_AXIS],
-            seg_rz = current_position[Z_AXIS],
-            seg_le = current_position[E_AXIS];
+      float raw[XYZE] = {
+        current_position[X_AXIS],
+        current_position[Y_AXIS],
+        current_position[Z_AXIS],
+        current_position[E_AXIS]
+      };
 
       // Only compute leveling per segment if ubl active and target below z_fade_height.
-
       if (!planner.leveling_active || !planner.leveling_active_at_z(rtarget[Z_AXIS])) {   // no mesh leveling
-
-        do {
-
-          if (--segments) {     // not the last segment
-            seg_rx += seg_dx;
-            seg_ry += seg_dy;
-            seg_rz += seg_dz;
-            seg_le += seg_de;
-          } else {              // last segment, use exact destination
-            seg_rx = rtarget[X_AXIS];
-            seg_ry = rtarget[Y_AXIS];
-            seg_rz = rtarget[Z_AXIS];
-            seg_le = rtarget[E_AXIS];
-          }
-
-          ubl_buffer_segment_raw(seg_rx, seg_ry, seg_rz, seg_le, feedrate);
-
-        } while (segments);
-
+        while (--segments) {
+          LOOP_XYZE(i) raw[i] += diff[i];
+          ubl_buffer_segment_raw(raw, feedrate);
+        }
+        ubl_buffer_segment_raw(rtarget, feedrate);
         return false; // moved but did not set_current_from_destination();
       }
 
@@ -598,10 +576,7 @@
       #endif
 
       // increment to first segment destination
-      seg_rx += seg_dx;
-      seg_ry += seg_dy;
-      seg_rz += seg_dz;
-      seg_le += seg_de;
+      LOOP_XYZE(i) raw[i] += diff[i];
 
       for(;;) {  // for each mesh cell encountered during the move
 
@@ -612,8 +587,8 @@
         // in top of loop and again re-find same adjacent cell and use it, just less efficient
         // for mesh inset area.
 
-        int8_t cell_xi = (seg_rx - (MESH_MIN_X)) * (1.0 / (MESH_X_DIST)),
-               cell_yi = (seg_ry - (MESH_MIN_Y)) * (1.0 / (MESH_X_DIST));
+        int8_t cell_xi = (raw[X_AXIS] - (MESH_MIN_X)) * (1.0 / (MESH_X_DIST)),
+               cell_yi = (raw[Y_AXIS] - (MESH_MIN_Y)) * (1.0 / (MESH_X_DIST));
 
         cell_xi = constrain(cell_xi, 0, (GRID_MAX_POINTS_X) - 1);
         cell_yi = constrain(cell_yi, 0, (GRID_MAX_POINTS_Y) - 1);
@@ -631,8 +606,8 @@
         if (isnan(z_x0y1)) z_x0y1 = 0;              //   in order to avoid isnan tests per cell,
         if (isnan(z_x1y1)) z_x1y1 = 0;              //   thus guessing zero for undefined points
 
-        float cx = seg_rx - x0,   // cell-relative x and y
-              cy = seg_ry - y0;
+        float cx = raw[X_AXIS] - x0,   // cell-relative x and y
+              cy = raw[Y_AXIS] - y0;
 
         const float z_xmy0 = (z_x1y0 - z_x0y0) * (1.0 / (MESH_X_DIST)),   // z slope per x along y0 (lower left to lower right)
                     z_xmy1 = (z_x1y1 - z_x0y1) * (1.0 / (MESH_X_DIST));   // z slope per x along y1 (upper left to upper right)
@@ -650,40 +625,34 @@
         // and the z_cxym slope will change, both as a function of cx within the cell, and
         // each change by a constant for fixed segment lengths.
 
-        const float z_sxy0 = z_xmy0 * seg_dx,                                     // per-segment adjustment to z_cxy0
-                    z_sxym = (z_xmy1 - z_xmy0) * (1.0 / (MESH_Y_DIST)) * seg_dx;  // per-segment adjustment to z_cxym
+        const float z_sxy0 = z_xmy0 * diff[X_AXIS],                                     // per-segment adjustment to z_cxy0
+                    z_sxym = (z_xmy1 - z_xmy0) * (1.0 / (MESH_Y_DIST)) * diff[X_AXIS];  // per-segment adjustment to z_cxym
 
         for(;;) {  // for all segments within this mesh cell
 
-          float z_cxcy = z_cxy0 + z_cxym * cy;      // interpolated mesh z height along cx at cy
+          if (--segments == 0)                      // if this is last segment, use rtarget for exact
+            COPY(raw, rtarget);
 
+          float z_cxcy = z_cxy0 + z_cxym * cy;      // interpolated mesh z height along cx at cy
           #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
             z_cxcy *= fade_scaling_factor;          // apply fade factor to interpolated mesh height
           #endif
 
-          if (--segments == 0) {                    // if this is last segment, use rtarget for exact
-            seg_rx = rtarget[X_AXIS];
-            seg_ry = rtarget[Y_AXIS];
-            seg_rz = rtarget[Z_AXIS];
-            seg_le = rtarget[E_AXIS];
-          }
-
-          ubl_buffer_segment_raw(seg_rx, seg_ry, seg_rz + z_cxcy, seg_le, feedrate);
+          const float z = raw[Z_AXIS];
+          raw[Z_AXIS] += z_cxcy;
+          ubl_buffer_segment_raw(raw, feedrate);
+          raw[Z_AXIS] = z;
 
           if (segments == 0)                        // done with last segment
             return false;                           // did not set_current_from_destination()
 
-          seg_rx += seg_dx;
-          seg_ry += seg_dy;
-          seg_rz += seg_dz;
-          seg_le += seg_de;
+          LOOP_XYZE(i) raw[i] += diff[i];
 
-          cx += seg_dx;
-          cy += seg_dy;
+          cx += diff[X_AXIS];
+          cy += diff[Y_AXIS];
 
-          if (!WITHIN(cx, 0, MESH_X_DIST) || !WITHIN(cy, 0, MESH_Y_DIST)) {  // done within this cell, break to next
+          if (!WITHIN(cx, 0, MESH_X_DIST) || !WITHIN(cy, 0, MESH_Y_DIST))    // done within this cell, break to next
             break;
-          }
 
           // Next segment still within same mesh cell, adjust the per-segment
           // slope and intercept to compute next z height.

commit c6b0c104bbab04d4d59c4f3f8fddb728e9b99603
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 23 17:59:43 2017 -0600

    Adapt G26 to work for all meshes

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 75f0f25d3d..d04ec3dde0 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -23,9 +23,7 @@
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
-  #include "ubl.h"
-
-  #include "../../../Marlin.h"
+  #include "../bedlevel.h"
   #include "../../../module/planner.h"
   #include "../../../module/stepper.h"
   #include "../../../module/motion.h"
@@ -34,6 +32,7 @@
     #include "../../../module/delta.h"
   #endif
 
+  #include "../../../Marlin.h"
   #include <math.h>
 
   extern float destination[XYZE];
@@ -55,7 +54,7 @@
 
     // if the title message starts with a '!' it is so important, we are going to
     // ignore the status of the g26_debug_flag
-    if (*title != '!' && !ubl.g26_debug_flag) return;
+    if (*title != '!' && !g26_debug_flag) return;
 
     const float de = destination[E_AXIS] - current_position[E_AXIS];
 

commit f8393a09086f01eafbb8563411da3b237c96b982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 2 23:59:42 2017 -0500

    Operate in Native Machine Space

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 41c11e4c69..75f0f25d3d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -112,10 +112,10 @@
                   destination[E_AXIS]
                 };
 
-    const int cell_start_xi = get_cell_index_x(RAW_X_POSITION(start[X_AXIS])),
-              cell_start_yi = get_cell_index_y(RAW_Y_POSITION(start[Y_AXIS])),
-              cell_dest_xi  = get_cell_index_x(RAW_X_POSITION(end[X_AXIS])),
-              cell_dest_yi  = get_cell_index_y(RAW_Y_POSITION(end[Y_AXIS]));
+    const int cell_start_xi = get_cell_index_x(start[X_AXIS]),
+              cell_start_yi = get_cell_index_y(start[Y_AXIS]),
+              cell_dest_xi  = get_cell_index_x(end[X_AXIS]),
+              cell_dest_yi  = get_cell_index_y(end[Y_AXIS]);
 
     if (g26_debug_flag) {
       SERIAL_ECHOPAIR(" ubl.line_to_destination(xe=", end[X_AXIS]);
@@ -160,7 +160,7 @@
        * to create a 1-over number for us. That will allow us to do a floating point multiply instead of a floating point divide.
        */
 
-      const float xratio = (RAW_X_POSITION(end[X_AXIS]) - mesh_index_to_xpos(cell_dest_xi)) * (1.0 / (MESH_X_DIST));
+      const float xratio = (end[X_AXIS] - mesh_index_to_xpos(cell_dest_xi)) * (1.0 / (MESH_X_DIST));
 
       float z1 = z_values[cell_dest_xi    ][cell_dest_yi    ] + xratio *
                 (z_values[cell_dest_xi + 1][cell_dest_yi    ] - z_values[cell_dest_xi][cell_dest_yi    ]),
@@ -172,7 +172,7 @@
       // we are done with the fractional X distance into the cell. Now with the two Z-Heights we have calculated, we
       // are going to apply the Y-Distance into the cell to interpolate the final Z correction.
 
-      const float yratio = (RAW_Y_POSITION(end[Y_AXIS]) - mesh_index_to_ypos(cell_dest_yi)) * (1.0 / (MESH_Y_DIST));
+      const float yratio = (end[Y_AXIS] - mesh_index_to_ypos(cell_dest_yi)) * (1.0 / (MESH_Y_DIST));
       float z0 = cell_dest_yi < GRID_MAX_POINTS_Y - 1 ? (z1 + (z2 - z1) * yratio) * planner.fade_scaling_factor_for_z(end[Z_AXIS]) : 0.0;
 
       /**
@@ -248,16 +248,16 @@
       current_yi += down_flag;  // Line is heading down, we just want to go to the bottom
       while (current_yi != cell_dest_yi + down_flag) {
         current_yi += dyi;
-        const float next_mesh_line_y = LOGICAL_Y_POSITION(mesh_index_to_ypos(current_yi));
+        const float next_mesh_line_y = mesh_index_to_ypos(current_yi);
 
         /**
          * if the slope of the line is infinite, we won't do the calculations
          * else, we know the next X is the same so we can recover and continue!
          * Calculate X at the next Y mesh line
          */
-        const float x = inf_m_flag ? start[X_AXIS] : (next_mesh_line_y - c) / m;
+        const float rx = inf_m_flag ? start[X_AXIS] : (next_mesh_line_y - c) / m;
 
-        float z0 = z_correction_for_x_on_horizontal_mesh_line(x, current_xi, current_yi)
+        float z0 = z_correction_for_x_on_horizontal_mesh_line(rx, current_xi, current_yi)
                    * planner.fade_scaling_factor_for_z(end[Z_AXIS]);
 
         /**
@@ -269,7 +269,7 @@
          */
         if (isnan(z0)) z0 = 0.0;
 
-        const float y = LOGICAL_Y_POSITION(mesh_index_to_ypos(current_yi));
+        const float ry = mesh_index_to_ypos(current_yi);
 
         /**
          * Without this check, it is possible for the algorithm to generate a zero length move in the case
@@ -277,9 +277,9 @@
          * happens, it might be best to remove the check and always 'schedule' the move because
          * the planner._buffer_line() routine will filter it if that happens.
          */
-        if (y != start[Y_AXIS]) {
+        if (ry != start[Y_AXIS]) {
           if (!inf_normalized_flag) {
-            on_axis_distance = use_x_dist ? x - start[X_AXIS] : y - start[Y_AXIS];
+            on_axis_distance = use_x_dist ? rx - start[X_AXIS] : ry - start[Y_AXIS];
             e_position = start[E_AXIS] + on_axis_distance * e_normalized_dist;
             z_position = start[Z_AXIS] + on_axis_distance * z_normalized_dist;
           }
@@ -288,7 +288,7 @@
             z_position = end[Z_AXIS];
           }
 
-          planner._buffer_line(x, y, z_position + z0, e_position, feed_rate, extruder);
+          planner._buffer_line(rx, ry, z_position + z0, e_position, feed_rate, extruder);
         } //else printf("FIRST MOVE PRUNED  ");
       }
 
@@ -318,10 +318,10 @@
                                 // edge of this cell for the first move.
       while (current_xi != cell_dest_xi + left_flag) {
         current_xi += dxi;
-        const float next_mesh_line_x = LOGICAL_X_POSITION(mesh_index_to_xpos(current_xi)),
-                    y = m * next_mesh_line_x + c;   // Calculate Y at the next X mesh line
+        const float next_mesh_line_x = mesh_index_to_xpos(current_xi),
+                    ry = m * next_mesh_line_x + c;   // Calculate Y at the next X mesh line
 
-        float z0 = z_correction_for_y_on_vertical_mesh_line(y, current_xi, current_yi)
+        float z0 = z_correction_for_y_on_vertical_mesh_line(ry, current_xi, current_yi)
                    * planner.fade_scaling_factor_for_z(end[Z_AXIS]);
 
         /**
@@ -333,7 +333,7 @@
          */
         if (isnan(z0)) z0 = 0.0;
 
-        const float x = LOGICAL_X_POSITION(mesh_index_to_xpos(current_xi));
+        const float rx = mesh_index_to_xpos(current_xi);
 
         /**
          * Without this check, it is possible for the algorithm to generate a zero length move in the case
@@ -341,9 +341,9 @@
          * that happens, it might be best to remove the check and always 'schedule' the move because
          * the planner._buffer_line() routine will filter it if that happens.
          */
-        if (x != start[X_AXIS]) {
+        if (rx != start[X_AXIS]) {
           if (!inf_normalized_flag) {
-            on_axis_distance = use_x_dist ? x - start[X_AXIS] : y - start[Y_AXIS];
+            on_axis_distance = use_x_dist ? rx - start[X_AXIS] : ry - start[Y_AXIS];
             e_position = start[E_AXIS] + on_axis_distance * e_normalized_dist;  // is based on X or Y because this is a horizontal move
             z_position = start[Z_AXIS] + on_axis_distance * z_normalized_dist;
           }
@@ -352,7 +352,7 @@
             z_position = end[Z_AXIS];
           }
 
-          planner._buffer_line(x, y, z_position + z0, e_position, feed_rate, extruder);
+          planner._buffer_line(rx, ry, z_position + z0, e_position, feed_rate, extruder);
         } //else printf("FIRST MOVE PRUNED  ");
       }
 
@@ -383,17 +383,17 @@
 
     while (xi_cnt > 0 || yi_cnt > 0) {
 
-      const float next_mesh_line_x = LOGICAL_X_POSITION(mesh_index_to_xpos(current_xi + dxi)),
-                  next_mesh_line_y = LOGICAL_Y_POSITION(mesh_index_to_ypos(current_yi + dyi)),
-                  y = m * next_mesh_line_x + c,   // Calculate Y at the next X mesh line
-                  x = (next_mesh_line_y - c) / m; // Calculate X at the next Y mesh line
-                                                  // (No need to worry about m being zero.
-                                                  //  If that was the case, it was already detected
-                                                  //  as a vertical line move above.)
+      const float next_mesh_line_x = mesh_index_to_xpos(current_xi + dxi),
+                  next_mesh_line_y = mesh_index_to_ypos(current_yi + dyi),
+                  ry = m * next_mesh_line_x + c,   // Calculate Y at the next X mesh line
+                  rx = (next_mesh_line_y - c) / m; // Calculate X at the next Y mesh line
+                                                   // (No need to worry about m being zero.
+                                                   //  If that was the case, it was already detected
+                                                   //  as a vertical line move above.)
 
-      if (left_flag == (x > next_mesh_line_x)) { // Check if we hit the Y line first
+      if (left_flag == (rx > next_mesh_line_x)) { // Check if we hit the Y line first
         // Yes!  Crossing a Y Mesh Line next
-        float z0 = z_correction_for_x_on_horizontal_mesh_line(x, current_xi - left_flag, current_yi + dyi)
+        float z0 = z_correction_for_x_on_horizontal_mesh_line(rx, current_xi - left_flag, current_yi + dyi)
                    * planner.fade_scaling_factor_for_z(end[Z_AXIS]);
 
         /**
@@ -406,7 +406,7 @@
         if (isnan(z0)) z0 = 0.0;
 
         if (!inf_normalized_flag) {
-          on_axis_distance = use_x_dist ? x - start[X_AXIS] : next_mesh_line_y - start[Y_AXIS];
+          on_axis_distance = use_x_dist ? rx - start[X_AXIS] : next_mesh_line_y - start[Y_AXIS];
           e_position = start[E_AXIS] + on_axis_distance * e_normalized_dist;
           z_position = start[Z_AXIS] + on_axis_distance * z_normalized_dist;
         }
@@ -414,13 +414,13 @@
           e_position = end[E_AXIS];
           z_position = end[Z_AXIS];
         }
-        planner._buffer_line(x, next_mesh_line_y, z_position + z0, e_position, feed_rate, extruder);
+        planner._buffer_line(rx, next_mesh_line_y, z_position + z0, e_position, feed_rate, extruder);
         current_yi += dyi;
         yi_cnt--;
       }
       else {
         // Yes!  Crossing a X Mesh Line next
-        float z0 = z_correction_for_y_on_vertical_mesh_line(y, current_xi + dxi, current_yi - down_flag)
+        float z0 = z_correction_for_y_on_vertical_mesh_line(ry, current_xi + dxi, current_yi - down_flag)
                    * planner.fade_scaling_factor_for_z(end[Z_AXIS]);
 
         /**
@@ -433,7 +433,7 @@
         if (isnan(z0)) z0 = 0.0;
 
         if (!inf_normalized_flag) {
-          on_axis_distance = use_x_dist ? next_mesh_line_x - start[X_AXIS] : y - start[Y_AXIS];
+          on_axis_distance = use_x_dist ? next_mesh_line_x - start[X_AXIS] : ry - start[Y_AXIS];
           e_position = start[E_AXIS] + on_axis_distance * e_normalized_dist;
           z_position = start[Z_AXIS] + on_axis_distance * z_normalized_dist;
         }
@@ -442,7 +442,7 @@
           z_position = end[Z_AXIS];
         }
 
-        planner._buffer_line(next_mesh_line_x, y, z_position + z0, e_position, feed_rate, extruder);
+        planner._buffer_line(next_mesh_line_x, ry, z_position + z0, e_position, feed_rate, extruder);
         current_xi += dxi;
         xi_cnt--;
       }
@@ -476,7 +476,7 @@
     // We don't want additional apply_leveling() performed by regular buffer_line or buffer_line_kinematic,
     // so we call _buffer_line directly here.  Per-segmented leveling and kinematics performed first.
 
-    inline void _O2 ubl_buffer_segment_raw( float rx, float ry, float rz, float le, float fr ) {
+    inline void _O2 ubl_buffer_segment_raw(const float &rx, const float &ry, const float rz, const float &e, const float &fr) {
 
       #if ENABLED(DELTA)  // apply delta inverse_kinematics
 
@@ -492,14 +492,11 @@
                                          - HYPOT2( delta_tower[C_AXIS][X_AXIS] - rx,
                                                    delta_tower[C_AXIS][Y_AXIS] - ry ));
 
-        planner._buffer_line(delta_A, delta_B, delta_C, le, fr, active_extruder);
+        planner._buffer_line(delta_A, delta_B, delta_C, e, fr, active_extruder);
 
       #elif IS_SCARA  // apply scara inverse_kinematics (should be changed to save raw->logical->raw)
 
-        const float lseg[XYZ] = { LOGICAL_X_POSITION(rx),
-                                  LOGICAL_Y_POSITION(ry),
-                                  LOGICAL_Z_POSITION(rz)
-                                };
+        const float lseg[XYZ] = { rx, ry, rz };
 
         inverse_kinematics(lseg); // this writes delta[ABC] from lseg[XYZ]
                                   // should move the feedrate scaling to scara inverse_kinematics
@@ -510,17 +507,11 @@
         scara_oldB = delta[B_AXIS];
         float s_feedrate = max(adiff, bdiff) * scara_feed_factor;
 
-        planner._buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], le, s_feedrate, active_extruder);
+        planner._buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], e, s_feedrate, active_extruder);
 
       #else // CARTESIAN
 
-        // Cartesian _buffer_line seems to take LOGICAL, not RAW coordinates
-
-        const float lx = LOGICAL_X_POSITION(rx),
-                    ly = LOGICAL_Y_POSITION(ry),
-                    lz = LOGICAL_Z_POSITION(rz);
-
-        planner._buffer_line(lx, ly, lz, le, fr, active_extruder);
+        planner._buffer_line(rx, ry, rz, e, fr, active_extruder);
 
       #endif
 
@@ -533,15 +524,15 @@
      * Returns true if did NOT move, false if moved (requires current_position update).
      */
 
-    bool _O2 unified_bed_leveling::prepare_segmented_line_to(const float ltarget[XYZE], const float &feedrate) {
+    bool _O2 unified_bed_leveling::prepare_segmented_line_to(const float rtarget[XYZE], const float &feedrate) {
 
-      if (!position_is_reachable_xy(ltarget[X_AXIS], ltarget[Y_AXIS]))  // fail if moving outside reachable boundary
+      if (!position_is_reachable(rtarget[X_AXIS], rtarget[Y_AXIS]))  // fail if moving outside reachable boundary
         return true; // did not move, so current_position still accurate
 
-      const float tot_dx = ltarget[X_AXIS] - current_position[X_AXIS],
-                  tot_dy = ltarget[Y_AXIS] - current_position[Y_AXIS],
-                  tot_dz = ltarget[Z_AXIS] - current_position[Z_AXIS],
-                  tot_de = ltarget[E_AXIS] - current_position[E_AXIS];
+      const float tot_dx = rtarget[X_AXIS] - current_position[X_AXIS],
+                  tot_dy = rtarget[Y_AXIS] - current_position[Y_AXIS],
+                  tot_dz = rtarget[Z_AXIS] - current_position[Z_AXIS],
+                  tot_de = rtarget[E_AXIS] - current_position[E_AXIS];
 
       const float cartesian_xy_mm = HYPOT(tot_dx, tot_dy);  // total horizontal xy distance
 
@@ -571,14 +562,14 @@
       // Note that E segment distance could vary slightly as z mesh height
       // changes for each segment, but small enough to ignore.
 
-      float seg_rx = RAW_X_POSITION(current_position[X_AXIS]),
-            seg_ry = RAW_Y_POSITION(current_position[Y_AXIS]),
-            seg_rz = RAW_Z_POSITION(current_position[Z_AXIS]),
+      float seg_rx = current_position[X_AXIS],
+            seg_ry = current_position[Y_AXIS],
+            seg_rz = current_position[Z_AXIS],
             seg_le = current_position[E_AXIS];
 
       // Only compute leveling per segment if ubl active and target below z_fade_height.
 
-      if (!planner.leveling_active || !planner.leveling_active_at_z(ltarget[Z_AXIS])) {   // no mesh leveling
+      if (!planner.leveling_active || !planner.leveling_active_at_z(rtarget[Z_AXIS])) {   // no mesh leveling
 
         do {
 
@@ -588,13 +579,13 @@
             seg_rz += seg_dz;
             seg_le += seg_de;
           } else {              // last segment, use exact destination
-            seg_rx = RAW_X_POSITION(ltarget[X_AXIS]);
-            seg_ry = RAW_Y_POSITION(ltarget[Y_AXIS]);
-            seg_rz = RAW_Z_POSITION(ltarget[Z_AXIS]);
-            seg_le = ltarget[E_AXIS];
+            seg_rx = rtarget[X_AXIS];
+            seg_ry = rtarget[Y_AXIS];
+            seg_rz = rtarget[Z_AXIS];
+            seg_le = rtarget[E_AXIS];
           }
 
-          ubl_buffer_segment_raw( seg_rx, seg_ry, seg_rz, seg_le, feedrate );
+          ubl_buffer_segment_raw(seg_rx, seg_ry, seg_rz, seg_le, feedrate);
 
         } while (segments);
 
@@ -604,7 +595,7 @@
       // Otherwise perform per-segment leveling
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        const float fade_scaling_factor = planner.fade_scaling_factor_for_z(ltarget[Z_AXIS]);
+        const float fade_scaling_factor = planner.fade_scaling_factor_for_z(rtarget[Z_AXIS]);
       #endif
 
       // increment to first segment destination
@@ -671,16 +662,16 @@
             z_cxcy *= fade_scaling_factor;          // apply fade factor to interpolated mesh height
           #endif
 
-          if (--segments == 0) {                    // if this is last segment, use ltarget for exact
-            seg_rx = RAW_X_POSITION(ltarget[X_AXIS]);
-            seg_ry = RAW_Y_POSITION(ltarget[Y_AXIS]);
-            seg_rz = RAW_Z_POSITION(ltarget[Z_AXIS]);
-            seg_le = ltarget[E_AXIS];
+          if (--segments == 0) {                    // if this is last segment, use rtarget for exact
+            seg_rx = rtarget[X_AXIS];
+            seg_ry = rtarget[Y_AXIS];
+            seg_rz = rtarget[Z_AXIS];
+            seg_le = rtarget[E_AXIS];
           }
 
-          ubl_buffer_segment_raw( seg_rx, seg_ry, seg_rz + z_cxcy, seg_le, feedrate );
+          ubl_buffer_segment_raw(seg_rx, seg_ry, seg_rz + z_cxcy, seg_le, feedrate);
 
-          if (segments == 0 )                       // done with last segment
+          if (segments == 0)                        // done with last segment
             return false;                           // did not set_current_from_destination()
 
           seg_rx += seg_dx;

commit 580b6e9089cefa7cf85c33ef53af4d02a6b59f37
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 19 01:39:39 2017 -0500

    Apply physical limits to mesh bounds

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 376c077b82..41c11e4c69 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -622,8 +622,8 @@
         // in top of loop and again re-find same adjacent cell and use it, just less efficient
         // for mesh inset area.
 
-        int8_t cell_xi = (seg_rx - (UBL_MESH_MIN_X)) * (1.0 / (MESH_X_DIST)),
-               cell_yi = (seg_ry - (UBL_MESH_MIN_Y)) * (1.0 / (MESH_X_DIST));
+        int8_t cell_xi = (seg_rx - (MESH_MIN_X)) * (1.0 / (MESH_X_DIST)),
+               cell_yi = (seg_ry - (MESH_MIN_Y)) * (1.0 / (MESH_X_DIST));
 
         cell_xi = constrain(cell_xi, 0, (GRID_MAX_POINTS_X) - 1);
         cell_yi = constrain(cell_yi, 0, (GRID_MAX_POINTS_Y) - 1);

commit 72156a2029d329c7dc251f5e576103fda691372d
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Oct 21 11:42:26 2017 -0500

    change to better (more clear) names (#8050)
    
    set_destination_to_current() changed to set_destination_from_current()
    
    set_current_to_destination() changed to set_current_from_destination()

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 977f2a865e..376c077b82 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -39,9 +39,9 @@
   extern float destination[XYZE];
 
   #if AVR_AT90USB1286_FAMILY  // Teensyduino & Printrboard IDE extensions have compile errors without this
-    inline void set_current_to_destination() { COPY(current_position, destination); }
+    inline void set_current_from_destination() { COPY(current_position, destination); }
   #else
-    extern void set_current_to_destination();
+    extern void set_current_from_destination();
   #endif
 
   static void debug_echo_axis(const AxisEnum axis) {
@@ -141,7 +141,7 @@
         // a reasonable correction would be.
 
         planner._buffer_line(end[X_AXIS], end[Y_AXIS], end[Z_AXIS], end[E_AXIS], feed_rate, extruder);
-        set_current_to_destination();
+        set_current_from_destination();
 
         if (g26_debug_flag)
           debug_current_and_destination(PSTR("out of bounds in ubl.line_to_destination()"));
@@ -189,7 +189,7 @@
       if (g26_debug_flag)
         debug_current_and_destination(PSTR("FINAL_MOVE in ubl.line_to_destination()"));
 
-      set_current_to_destination();
+      set_current_from_destination();
       return;
     }
 
@@ -301,7 +301,7 @@
       if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
         goto FINAL_MOVE;
 
-      set_current_to_destination();
+      set_current_from_destination();
       return;
     }
 
@@ -362,7 +362,7 @@
       if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
         goto FINAL_MOVE;
 
-      set_current_to_destination();
+      set_current_from_destination();
       return;
     }
 
@@ -456,7 +456,7 @@
     if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
       goto FINAL_MOVE;
 
-    set_current_to_destination();
+    set_current_from_destination();
   }
 
   #if UBL_DELTA
@@ -598,7 +598,7 @@
 
         } while (segments);
 
-        return false; // moved but did not set_current_to_destination();
+        return false; // moved but did not set_current_from_destination();
       }
 
       // Otherwise perform per-segment leveling
@@ -681,7 +681,7 @@
           ubl_buffer_segment_raw( seg_rx, seg_ry, seg_rz + z_cxcy, seg_le, feedrate );
 
           if (segments == 0 )                       // done with last segment
-            return false;                           // did not set_current_to_destination()
+            return false;                           // did not set_current_from_destination()
 
           seg_rx += seg_dx;
           seg_ry += seg_dy;

commit 3e3911fb81cef6f17f7e77c54f520e2a4579225b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 17:21:25 2017 -0500

    Use planner.leveling_active for all leveling systems

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index c2a74e8282..977f2a865e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -257,9 +257,8 @@
          */
         const float x = inf_m_flag ? start[X_AXIS] : (next_mesh_line_y - c) / m;
 
-        float z0 = z_correction_for_x_on_horizontal_mesh_line(x, current_xi, current_yi);
-
-        z0 *= planner.fade_scaling_factor_for_z(end[Z_AXIS]);
+        float z0 = z_correction_for_x_on_horizontal_mesh_line(x, current_xi, current_yi)
+                   * planner.fade_scaling_factor_for_z(end[Z_AXIS]);
 
         /**
          * If part of the Mesh is undefined, it will show up as NAN
@@ -322,9 +321,8 @@
         const float next_mesh_line_x = LOGICAL_X_POSITION(mesh_index_to_xpos(current_xi)),
                     y = m * next_mesh_line_x + c;   // Calculate Y at the next X mesh line
 
-        float z0 = z_correction_for_y_on_vertical_mesh_line(y, current_xi, current_yi);
-
-        z0 *= planner.fade_scaling_factor_for_z(end[Z_AXIS]);
+        float z0 = z_correction_for_y_on_vertical_mesh_line(y, current_xi, current_yi)
+                   * planner.fade_scaling_factor_for_z(end[Z_AXIS]);
 
         /**
          * If part of the Mesh is undefined, it will show up as NAN
@@ -395,9 +393,8 @@
 
       if (left_flag == (x > next_mesh_line_x)) { // Check if we hit the Y line first
         // Yes!  Crossing a Y Mesh Line next
-        float z0 = z_correction_for_x_on_horizontal_mesh_line(x, current_xi - left_flag, current_yi + dyi);
-
-        z0 *= planner.fade_scaling_factor_for_z(end[Z_AXIS]);
+        float z0 = z_correction_for_x_on_horizontal_mesh_line(x, current_xi - left_flag, current_yi + dyi)
+                   * planner.fade_scaling_factor_for_z(end[Z_AXIS]);
 
         /**
          * If part of the Mesh is undefined, it will show up as NAN
@@ -423,9 +420,8 @@
       }
       else {
         // Yes!  Crossing a X Mesh Line next
-        float z0 = z_correction_for_y_on_vertical_mesh_line(y, current_xi + dxi, current_yi - down_flag);
-
-        z0 *= planner.fade_scaling_factor_for_z(end[Z_AXIS]);
+        float z0 = z_correction_for_y_on_vertical_mesh_line(y, current_xi + dxi, current_yi - down_flag)
+                   * planner.fade_scaling_factor_for_z(end[Z_AXIS]);
 
         /**
          * If part of the Mesh is undefined, it will show up as NAN
@@ -580,17 +576,9 @@
             seg_rz = RAW_Z_POSITION(current_position[Z_AXIS]),
             seg_le = current_position[E_AXIS];
 
-      const bool above_fade_height = (
-        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-          planner.z_fade_height != 0 && planner.z_fade_height < RAW_Z_POSITION(ltarget[Z_AXIS])
-        #else
-          false
-        #endif
-      );
-
       // Only compute leveling per segment if ubl active and target below z_fade_height.
 
-      if (!state.active || above_fade_height) {   // no mesh leveling
+      if (!planner.leveling_active || !planner.leveling_active_at_z(ltarget[Z_AXIS])) {   // no mesh leveling
 
         do {
 
@@ -648,7 +636,7 @@
               z_x0y1 = z_values[cell_xi  ][cell_yi+1],  // z at lower right corner
               z_x1y1 = z_values[cell_xi+1][cell_yi+1];  // z at upper right corner
 
-        if (isnan(z_x0y0)) z_x0y0 = 0;              // ideally activating state.active (G29 A)
+        if (isnan(z_x0y0)) z_x0y0 = 0;              // ideally activating planner.leveling_active (G29 A)
         if (isnan(z_x1y0)) z_x1y0 = 0;              //   should refuse if any invalid mesh points
         if (isnan(z_x0y1)) z_x0y1 = 0;              //   in order to avoid isnan tests per cell,
         if (isnan(z_x1y1)) z_x1y1 = 0;              //   thus guessing zero for undefined points

commit ca1e47375c71e6ddd4973a63a7a8cbf125a439bd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 10:39:11 2017 -0500

    Move fade_scaling_factor_for_z to Planner

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 1fa97b43c2..c2a74e8282 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -173,7 +173,7 @@
       // are going to apply the Y-Distance into the cell to interpolate the final Z correction.
 
       const float yratio = (RAW_Y_POSITION(end[Y_AXIS]) - mesh_index_to_ypos(cell_dest_yi)) * (1.0 / (MESH_Y_DIST));
-      float z0 = cell_dest_yi < GRID_MAX_POINTS_Y - 1 ? (z1 + (z2 - z1) * yratio) * fade_scaling_factor_for_z(end[Z_AXIS]) : 0.0;
+      float z0 = cell_dest_yi < GRID_MAX_POINTS_Y - 1 ? (z1 + (z2 - z1) * yratio) * planner.fade_scaling_factor_for_z(end[Z_AXIS]) : 0.0;
 
       /**
        * If part of the Mesh is undefined, it will show up as NAN
@@ -259,7 +259,7 @@
 
         float z0 = z_correction_for_x_on_horizontal_mesh_line(x, current_xi, current_yi);
 
-        z0 *= fade_scaling_factor_for_z(end[Z_AXIS]);
+        z0 *= planner.fade_scaling_factor_for_z(end[Z_AXIS]);
 
         /**
          * If part of the Mesh is undefined, it will show up as NAN
@@ -324,7 +324,7 @@
 
         float z0 = z_correction_for_y_on_vertical_mesh_line(y, current_xi, current_yi);
 
-        z0 *= fade_scaling_factor_for_z(end[Z_AXIS]);
+        z0 *= planner.fade_scaling_factor_for_z(end[Z_AXIS]);
 
         /**
          * If part of the Mesh is undefined, it will show up as NAN
@@ -397,7 +397,7 @@
         // Yes!  Crossing a Y Mesh Line next
         float z0 = z_correction_for_x_on_horizontal_mesh_line(x, current_xi - left_flag, current_yi + dyi);
 
-        z0 *= fade_scaling_factor_for_z(end[Z_AXIS]);
+        z0 *= planner.fade_scaling_factor_for_z(end[Z_AXIS]);
 
         /**
          * If part of the Mesh is undefined, it will show up as NAN
@@ -425,7 +425,7 @@
         // Yes!  Crossing a X Mesh Line next
         float z0 = z_correction_for_y_on_vertical_mesh_line(y, current_xi + dxi, current_yi - down_flag);
 
-        z0 *= fade_scaling_factor_for_z(end[Z_AXIS]);
+        z0 *= planner.fade_scaling_factor_for_z(end[Z_AXIS]);
 
         /**
          * If part of the Mesh is undefined, it will show up as NAN
@@ -616,7 +616,7 @@
       // Otherwise perform per-segment leveling
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        const float fade_scaling_factor = fade_scaling_factor_for_z(ltarget[Z_AXIS]);
+        const float fade_scaling_factor = planner.fade_scaling_factor_for_z(ltarget[Z_AXIS]);
       #endif
 
       // increment to first segment destination

commit 1adb5a6a4800e65e04cef5833dc1cf21c7e13c2e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 12 22:20:02 2017 -0500

    Remove obsolete UBL z_offset

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
index 2212310c48..1fa97b43c2 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -140,7 +140,7 @@
         // Note: There is no Z Correction in this case. We are off the grid and don't know what
         // a reasonable correction would be.
 
-        planner._buffer_line(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + state.z_offset, end[E_AXIS], feed_rate, extruder);
+        planner._buffer_line(end[X_AXIS], end[Y_AXIS], end[Z_AXIS], end[E_AXIS], feed_rate, extruder);
         set_current_to_destination();
 
         if (g26_debug_flag)
@@ -184,7 +184,7 @@
        */
       if (isnan(z0)) z0 = 0.0;
 
-      planner._buffer_line(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + z0 + state.z_offset, end[E_AXIS], feed_rate, extruder);
+      planner._buffer_line(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + z0, end[E_AXIS], feed_rate, extruder);
 
       if (g26_debug_flag)
         debug_current_and_destination(PSTR("FINAL_MOVE in ubl.line_to_destination()"));
@@ -289,7 +289,7 @@
             z_position = end[Z_AXIS];
           }
 
-          planner._buffer_line(x, y, z_position + z0 + state.z_offset, e_position, feed_rate, extruder);
+          planner._buffer_line(x, y, z_position + z0, e_position, feed_rate, extruder);
         } //else printf("FIRST MOVE PRUNED  ");
       }
 
@@ -354,7 +354,7 @@
             z_position = end[Z_AXIS];
           }
 
-          planner._buffer_line(x, y, z_position + z0 + state.z_offset, e_position, feed_rate, extruder);
+          planner._buffer_line(x, y, z_position + z0, e_position, feed_rate, extruder);
         } //else printf("FIRST MOVE PRUNED  ");
       }
 
@@ -417,7 +417,7 @@
           e_position = end[E_AXIS];
           z_position = end[Z_AXIS];
         }
-        planner._buffer_line(x, next_mesh_line_y, z_position + z0 + state.z_offset, e_position, feed_rate, extruder);
+        planner._buffer_line(x, next_mesh_line_y, z_position + z0, e_position, feed_rate, extruder);
         current_yi += dyi;
         yi_cnt--;
       }
@@ -446,7 +446,7 @@
           z_position = end[Z_AXIS];
         }
 
-        planner._buffer_line(next_mesh_line_x, y, z_position + z0 + state.z_offset, e_position, feed_rate, extruder);
+        planner._buffer_line(next_mesh_line_x, y, z_position + z0, e_position, feed_rate, extruder);
         current_xi += dxi;
         xi_cnt--;
       }
@@ -592,8 +592,6 @@
 
       if (!state.active || above_fade_height) {   // no mesh leveling
 
-        const float z_offset = state.active ? state.z_offset : 0.0;
-
         do {
 
           if (--segments) {     // not the last segment
@@ -608,7 +606,7 @@
             seg_le = ltarget[E_AXIS];
           }
 
-          ubl_buffer_segment_raw( seg_rx, seg_ry, seg_rz + z_offset, seg_le, feedrate );
+          ubl_buffer_segment_raw( seg_rx, seg_ry, seg_rz, seg_le, feedrate );
 
         } while (segments);
 
@@ -685,8 +683,6 @@
             z_cxcy *= fade_scaling_factor;          // apply fade factor to interpolated mesh height
           #endif
 
-          z_cxcy += state.z_offset;                 // add fixed mesh offset from G29 Z
-
           if (--segments == 0) {                    // if this is last segment, use ltarget for exact
             seg_rx = RAW_X_POSITION(ltarget[X_AXIS]);
             seg_ry = RAW_Y_POSITION(ltarget[Y_AXIS]);

commit 551752eac73a6f60de45b6465e2f224b2b2dca24
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 15:35:25 2017 -0500

    Consolidate "bedlevel" code

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
new file mode 100644
index 0000000000..2212310c48
--- /dev/null
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_motion.cpp
@@ -0,0 +1,726 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "../../../inc/MarlinConfig.h"
+
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+
+  #include "ubl.h"
+
+  #include "../../../Marlin.h"
+  #include "../../../module/planner.h"
+  #include "../../../module/stepper.h"
+  #include "../../../module/motion.h"
+
+  #if ENABLED(DELTA)
+    #include "../../../module/delta.h"
+  #endif
+
+  #include <math.h>
+
+  extern float destination[XYZE];
+
+  #if AVR_AT90USB1286_FAMILY  // Teensyduino & Printrboard IDE extensions have compile errors without this
+    inline void set_current_to_destination() { COPY(current_position, destination); }
+  #else
+    extern void set_current_to_destination();
+  #endif
+
+  static void debug_echo_axis(const AxisEnum axis) {
+    if (current_position[axis] == destination[axis])
+      SERIAL_ECHOPGM("-------------");
+    else
+      SERIAL_ECHO_F(destination[X_AXIS], 6);
+  }
+
+  void debug_current_and_destination(const char *title) {
+
+    // if the title message starts with a '!' it is so important, we are going to
+    // ignore the status of the g26_debug_flag
+    if (*title != '!' && !ubl.g26_debug_flag) return;
+
+    const float de = destination[E_AXIS] - current_position[E_AXIS];
+
+    if (de == 0.0) return; // Printing moves only
+
+    const float dx = destination[X_AXIS] - current_position[X_AXIS],
+                dy = destination[Y_AXIS] - current_position[Y_AXIS],
+                xy_dist = HYPOT(dx, dy);
+
+    if (xy_dist == 0.0) return;
+
+    SERIAL_ECHOPGM("   fpmm=");
+    const float fpmm = de / xy_dist;
+    SERIAL_ECHO_F(fpmm, 6);
+
+    SERIAL_ECHOPGM("    current=( ");
+    SERIAL_ECHO_F(current_position[X_AXIS], 6);
+    SERIAL_ECHOPGM(", ");
+    SERIAL_ECHO_F(current_position[Y_AXIS], 6);
+    SERIAL_ECHOPGM(", ");
+    SERIAL_ECHO_F(current_position[Z_AXIS], 6);
+    SERIAL_ECHOPGM(", ");
+    SERIAL_ECHO_F(current_position[E_AXIS], 6);
+    SERIAL_ECHOPGM(" )   destination=( ");
+    debug_echo_axis(X_AXIS);
+    SERIAL_ECHOPGM(", ");
+    debug_echo_axis(Y_AXIS);
+    SERIAL_ECHOPGM(", ");
+    debug_echo_axis(Z_AXIS);
+    SERIAL_ECHOPGM(", ");
+    debug_echo_axis(E_AXIS);
+    SERIAL_ECHOPGM(" )   ");
+    SERIAL_ECHO(title);
+    SERIAL_EOL();
+
+  }
+
+  void unified_bed_leveling::line_to_destination_cartesian(const float &feed_rate, uint8_t extruder) {
+    /**
+     * Much of the nozzle movement will be within the same cell. So we will do as little computation
+     * as possible to determine if this is the case. If this move is within the same cell, we will
+     * just do the required Z-Height correction, call the Planner's buffer_line() routine, and leave
+     */
+    const float start[XYZE] = {
+                  current_position[X_AXIS],
+                  current_position[Y_AXIS],
+                  current_position[Z_AXIS],
+                  current_position[E_AXIS]
+                },
+                end[XYZE] = {
+                  destination[X_AXIS],
+                  destination[Y_AXIS],
+                  destination[Z_AXIS],
+                  destination[E_AXIS]
+                };
+
+    const int cell_start_xi = get_cell_index_x(RAW_X_POSITION(start[X_AXIS])),
+              cell_start_yi = get_cell_index_y(RAW_Y_POSITION(start[Y_AXIS])),
+              cell_dest_xi  = get_cell_index_x(RAW_X_POSITION(end[X_AXIS])),
+              cell_dest_yi  = get_cell_index_y(RAW_Y_POSITION(end[Y_AXIS]));
+
+    if (g26_debug_flag) {
+      SERIAL_ECHOPAIR(" ubl.line_to_destination(xe=", end[X_AXIS]);
+      SERIAL_ECHOPAIR(", ye=", end[Y_AXIS]);
+      SERIAL_ECHOPAIR(", ze=", end[Z_AXIS]);
+      SERIAL_ECHOPAIR(", ee=", end[E_AXIS]);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+      debug_current_and_destination(PSTR("Start of ubl.line_to_destination()"));
+    }
+
+    if (cell_start_xi == cell_dest_xi && cell_start_yi == cell_dest_yi) { // if the whole move is within the same cell,
+      /**
+       * we don't need to break up the move
+       *
+       * If we are moving off the print bed, we are going to allow the move at this level.
+       * But we detect it and isolate it. For now, we just pass along the request.
+       */
+
+      if (!WITHIN(cell_dest_xi, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(cell_dest_yi, 0, GRID_MAX_POINTS_Y - 1)) {
+
+        // Note: There is no Z Correction in this case. We are off the grid and don't know what
+        // a reasonable correction would be.
+
+        planner._buffer_line(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + state.z_offset, end[E_AXIS], feed_rate, extruder);
+        set_current_to_destination();
+
+        if (g26_debug_flag)
+          debug_current_and_destination(PSTR("out of bounds in ubl.line_to_destination()"));
+
+        return;
+      }
+
+      FINAL_MOVE:
+
+      /**
+       * Optimize some floating point operations here. We could call float get_z_correction(float x0, float y0) to
+       * generate the correction for us. But we can lighten the load on the CPU by doing a modified version of the function.
+       * We are going to only calculate the amount we are from the first mesh line towards the second mesh line once.
+       * We will use this fraction in both of the original two Z Height calculations for the bi-linear interpolation. And,
+       * instead of doing a generic divide of the distance, we know the distance is MESH_X_DIST so we can use the preprocessor
+       * to create a 1-over number for us. That will allow us to do a floating point multiply instead of a floating point divide.
+       */
+
+      const float xratio = (RAW_X_POSITION(end[X_AXIS]) - mesh_index_to_xpos(cell_dest_xi)) * (1.0 / (MESH_X_DIST));
+
+      float z1 = z_values[cell_dest_xi    ][cell_dest_yi    ] + xratio *
+                (z_values[cell_dest_xi + 1][cell_dest_yi    ] - z_values[cell_dest_xi][cell_dest_yi    ]),
+            z2 = z_values[cell_dest_xi    ][cell_dest_yi + 1] + xratio *
+                (z_values[cell_dest_xi + 1][cell_dest_yi + 1] - z_values[cell_dest_xi][cell_dest_yi + 1]);
+
+      if (cell_dest_xi >= GRID_MAX_POINTS_X - 1) z1 = z2 = 0.0;
+
+      // we are done with the fractional X distance into the cell. Now with the two Z-Heights we have calculated, we
+      // are going to apply the Y-Distance into the cell to interpolate the final Z correction.
+
+      const float yratio = (RAW_Y_POSITION(end[Y_AXIS]) - mesh_index_to_ypos(cell_dest_yi)) * (1.0 / (MESH_Y_DIST));
+      float z0 = cell_dest_yi < GRID_MAX_POINTS_Y - 1 ? (z1 + (z2 - z1) * yratio) * fade_scaling_factor_for_z(end[Z_AXIS]) : 0.0;
+
+      /**
+       * If part of the Mesh is undefined, it will show up as NAN
+       * in z_values[][] and propagate through the
+       * calculations. If our correction is NAN, we throw it out
+       * because part of the Mesh is undefined and we don't have the
+       * information we need to complete the height correction.
+       */
+      if (isnan(z0)) z0 = 0.0;
+
+      planner._buffer_line(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + z0 + state.z_offset, end[E_AXIS], feed_rate, extruder);
+
+      if (g26_debug_flag)
+        debug_current_and_destination(PSTR("FINAL_MOVE in ubl.line_to_destination()"));
+
+      set_current_to_destination();
+      return;
+    }
+
+    /**
+     * If we get here, we are processing a move that crosses at least one Mesh Line. We will check
+     * for the simple case of just crossing X or just crossing Y Mesh Lines after we get all the details
+     * of the move figured out. We can process the easy case of just crossing an X or Y Mesh Line with less
+     * computation and in fact most lines are of this nature. We will check for that in the following
+     * blocks of code:
+     */
+
+    const float dx = end[X_AXIS] - start[X_AXIS],
+                dy = end[Y_AXIS] - start[Y_AXIS];
+
+    const int left_flag = dx < 0.0 ? 1 : 0,
+              down_flag = dy < 0.0 ? 1 : 0;
+
+    const float adx = left_flag ? -dx : dx,
+                ady = down_flag ? -dy : dy;
+
+    const int dxi = cell_start_xi == cell_dest_xi ? 0 : left_flag ? -1 : 1,
+              dyi = cell_start_yi == cell_dest_yi ? 0 : down_flag ? -1 : 1;
+
+    /**
+     * Compute the scaling factor for the extruder for each partial move.
+     * We need to watch out for zero length moves because it will cause us to
+     * have an infinate scaling factor. We are stuck doing a floating point
+     * divide to get our scaling factor, but after that, we just multiply by this
+     * number. We also pick our scaling factor based on whether the X or Y
+     * component is larger. We use the biggest of the two to preserve precision.
+     */
+
+    const bool use_x_dist = adx > ady;
+
+    float on_axis_distance = use_x_dist ? dx : dy,
+          e_position = end[E_AXIS] - start[E_AXIS],
+          z_position = end[Z_AXIS] - start[Z_AXIS];
+
+    const float e_normalized_dist = e_position / on_axis_distance,
+                z_normalized_dist = z_position / on_axis_distance;
+
+    int current_xi = cell_start_xi,
+        current_yi = cell_start_yi;
+
+    const float m = dy / dx,
+                c = start[Y_AXIS] - m * start[X_AXIS];
+
+    const bool inf_normalized_flag = (isinf(e_normalized_dist) != 0),
+               inf_m_flag = (isinf(m) != 0);
+    /**
+     * This block handles vertical lines. These are lines that stay within the same
+     * X Cell column. They do not need to be perfectly vertical. They just can
+     * not cross into another X Cell column.
+     */
+    if (dxi == 0) {       // Check for a vertical line
+      current_yi += down_flag;  // Line is heading down, we just want to go to the bottom
+      while (current_yi != cell_dest_yi + down_flag) {
+        current_yi += dyi;
+        const float next_mesh_line_y = LOGICAL_Y_POSITION(mesh_index_to_ypos(current_yi));
+
+        /**
+         * if the slope of the line is infinite, we won't do the calculations
+         * else, we know the next X is the same so we can recover and continue!
+         * Calculate X at the next Y mesh line
+         */
+        const float x = inf_m_flag ? start[X_AXIS] : (next_mesh_line_y - c) / m;
+
+        float z0 = z_correction_for_x_on_horizontal_mesh_line(x, current_xi, current_yi);
+
+        z0 *= fade_scaling_factor_for_z(end[Z_AXIS]);
+
+        /**
+         * If part of the Mesh is undefined, it will show up as NAN
+         * in z_values[][] and propagate through the
+         * calculations. If our correction is NAN, we throw it out
+         * because part of the Mesh is undefined and we don't have the
+         * information we need to complete the height correction.
+         */
+        if (isnan(z0)) z0 = 0.0;
+
+        const float y = LOGICAL_Y_POSITION(mesh_index_to_ypos(current_yi));
+
+        /**
+         * Without this check, it is possible for the algorithm to generate a zero length move in the case
+         * where the line is heading down and it is starting right on a Mesh Line boundary. For how often that
+         * happens, it might be best to remove the check and always 'schedule' the move because
+         * the planner._buffer_line() routine will filter it if that happens.
+         */
+        if (y != start[Y_AXIS]) {
+          if (!inf_normalized_flag) {
+            on_axis_distance = use_x_dist ? x - start[X_AXIS] : y - start[Y_AXIS];
+            e_position = start[E_AXIS] + on_axis_distance * e_normalized_dist;
+            z_position = start[Z_AXIS] + on_axis_distance * z_normalized_dist;
+          }
+          else {
+            e_position = end[E_AXIS];
+            z_position = end[Z_AXIS];
+          }
+
+          planner._buffer_line(x, y, z_position + z0 + state.z_offset, e_position, feed_rate, extruder);
+        } //else printf("FIRST MOVE PRUNED  ");
+      }
+
+      if (g26_debug_flag)
+        debug_current_and_destination(PSTR("vertical move done in ubl.line_to_destination()"));
+
+      //
+      // Check if we are at the final destination. Usually, we won't be, but if it is on a Y Mesh Line, we are done.
+      //
+      if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
+        goto FINAL_MOVE;
+
+      set_current_to_destination();
+      return;
+    }
+
+    /**
+     *
+     * This block handles horizontal lines. These are lines that stay within the same
+     * Y Cell row. They do not need to be perfectly horizontal. They just can
+     * not cross into another Y Cell row.
+     *
+     */
+
+    if (dyi == 0) {             // Check for a horizontal line
+      current_xi += left_flag;  // Line is heading left, we just want to go to the left
+                                // edge of this cell for the first move.
+      while (current_xi != cell_dest_xi + left_flag) {
+        current_xi += dxi;
+        const float next_mesh_line_x = LOGICAL_X_POSITION(mesh_index_to_xpos(current_xi)),
+                    y = m * next_mesh_line_x + c;   // Calculate Y at the next X mesh line
+
+        float z0 = z_correction_for_y_on_vertical_mesh_line(y, current_xi, current_yi);
+
+        z0 *= fade_scaling_factor_for_z(end[Z_AXIS]);
+
+        /**
+         * If part of the Mesh is undefined, it will show up as NAN
+         * in z_values[][] and propagate through the
+         * calculations. If our correction is NAN, we throw it out
+         * because part of the Mesh is undefined and we don't have the
+         * information we need to complete the height correction.
+         */
+        if (isnan(z0)) z0 = 0.0;
+
+        const float x = LOGICAL_X_POSITION(mesh_index_to_xpos(current_xi));
+
+        /**
+         * Without this check, it is possible for the algorithm to generate a zero length move in the case
+         * where the line is heading left and it is starting right on a Mesh Line boundary. For how often
+         * that happens, it might be best to remove the check and always 'schedule' the move because
+         * the planner._buffer_line() routine will filter it if that happens.
+         */
+        if (x != start[X_AXIS]) {
+          if (!inf_normalized_flag) {
+            on_axis_distance = use_x_dist ? x - start[X_AXIS] : y - start[Y_AXIS];
+            e_position = start[E_AXIS] + on_axis_distance * e_normalized_dist;  // is based on X or Y because this is a horizontal move
+            z_position = start[Z_AXIS] + on_axis_distance * z_normalized_dist;
+          }
+          else {
+            e_position = end[E_AXIS];
+            z_position = end[Z_AXIS];
+          }
+
+          planner._buffer_line(x, y, z_position + z0 + state.z_offset, e_position, feed_rate, extruder);
+        } //else printf("FIRST MOVE PRUNED  ");
+      }
+
+      if (g26_debug_flag)
+        debug_current_and_destination(PSTR("horizontal move done in ubl.line_to_destination()"));
+
+      if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
+        goto FINAL_MOVE;
+
+      set_current_to_destination();
+      return;
+    }
+
+    /**
+     *
+     * This block handles the generic case of a line crossing both X and Y Mesh lines.
+     *
+     */
+
+    int xi_cnt = cell_start_xi - cell_dest_xi,
+        yi_cnt = cell_start_yi - cell_dest_yi;
+
+    if (xi_cnt < 0) xi_cnt = -xi_cnt;
+    if (yi_cnt < 0) yi_cnt = -yi_cnt;
+
+    current_xi += left_flag;
+    current_yi += down_flag;
+
+    while (xi_cnt > 0 || yi_cnt > 0) {
+
+      const float next_mesh_line_x = LOGICAL_X_POSITION(mesh_index_to_xpos(current_xi + dxi)),
+                  next_mesh_line_y = LOGICAL_Y_POSITION(mesh_index_to_ypos(current_yi + dyi)),
+                  y = m * next_mesh_line_x + c,   // Calculate Y at the next X mesh line
+                  x = (next_mesh_line_y - c) / m; // Calculate X at the next Y mesh line
+                                                  // (No need to worry about m being zero.
+                                                  //  If that was the case, it was already detected
+                                                  //  as a vertical line move above.)
+
+      if (left_flag == (x > next_mesh_line_x)) { // Check if we hit the Y line first
+        // Yes!  Crossing a Y Mesh Line next
+        float z0 = z_correction_for_x_on_horizontal_mesh_line(x, current_xi - left_flag, current_yi + dyi);
+
+        z0 *= fade_scaling_factor_for_z(end[Z_AXIS]);
+
+        /**
+         * If part of the Mesh is undefined, it will show up as NAN
+         * in z_values[][] and propagate through the
+         * calculations. If our correction is NAN, we throw it out
+         * because part of the Mesh is undefined and we don't have the
+         * information we need to complete the height correction.
+         */
+        if (isnan(z0)) z0 = 0.0;
+
+        if (!inf_normalized_flag) {
+          on_axis_distance = use_x_dist ? x - start[X_AXIS] : next_mesh_line_y - start[Y_AXIS];
+          e_position = start[E_AXIS] + on_axis_distance * e_normalized_dist;
+          z_position = start[Z_AXIS] + on_axis_distance * z_normalized_dist;
+        }
+        else {
+          e_position = end[E_AXIS];
+          z_position = end[Z_AXIS];
+        }
+        planner._buffer_line(x, next_mesh_line_y, z_position + z0 + state.z_offset, e_position, feed_rate, extruder);
+        current_yi += dyi;
+        yi_cnt--;
+      }
+      else {
+        // Yes!  Crossing a X Mesh Line next
+        float z0 = z_correction_for_y_on_vertical_mesh_line(y, current_xi + dxi, current_yi - down_flag);
+
+        z0 *= fade_scaling_factor_for_z(end[Z_AXIS]);
+
+        /**
+         * If part of the Mesh is undefined, it will show up as NAN
+         * in z_values[][] and propagate through the
+         * calculations. If our correction is NAN, we throw it out
+         * because part of the Mesh is undefined and we don't have the
+         * information we need to complete the height correction.
+         */
+        if (isnan(z0)) z0 = 0.0;
+
+        if (!inf_normalized_flag) {
+          on_axis_distance = use_x_dist ? next_mesh_line_x - start[X_AXIS] : y - start[Y_AXIS];
+          e_position = start[E_AXIS] + on_axis_distance * e_normalized_dist;
+          z_position = start[Z_AXIS] + on_axis_distance * z_normalized_dist;
+        }
+        else {
+          e_position = end[E_AXIS];
+          z_position = end[Z_AXIS];
+        }
+
+        planner._buffer_line(next_mesh_line_x, y, z_position + z0 + state.z_offset, e_position, feed_rate, extruder);
+        current_xi += dxi;
+        xi_cnt--;
+      }
+
+      if (xi_cnt < 0 || yi_cnt < 0) break; // we've gone too far, so exit the loop and move on to FINAL_MOVE
+    }
+
+    if (g26_debug_flag)
+      debug_current_and_destination(PSTR("generic move done in ubl.line_to_destination()"));
+
+    if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
+      goto FINAL_MOVE;
+
+    set_current_to_destination();
+  }
+
+  #if UBL_DELTA
+
+    // macro to inline copy exactly 4 floats, don't rely on sizeof operator
+    #define COPY_XYZE( target, source ) { \
+                target[X_AXIS] = source[X_AXIS]; \
+                target[Y_AXIS] = source[Y_AXIS]; \
+                target[Z_AXIS] = source[Z_AXIS]; \
+                target[E_AXIS] = source[E_AXIS]; \
+            }
+
+    #if IS_SCARA // scale the feed rate from mm/s to degrees/s
+      static float scara_feed_factor, scara_oldA, scara_oldB;
+    #endif
+
+    // We don't want additional apply_leveling() performed by regular buffer_line or buffer_line_kinematic,
+    // so we call _buffer_line directly here.  Per-segmented leveling and kinematics performed first.
+
+    inline void _O2 ubl_buffer_segment_raw( float rx, float ry, float rz, float le, float fr ) {
+
+      #if ENABLED(DELTA)  // apply delta inverse_kinematics
+
+        const float delta_A = rz + SQRT( delta_diagonal_rod_2_tower[A_AXIS]
+                                         - HYPOT2( delta_tower[A_AXIS][X_AXIS] - rx,
+                                                   delta_tower[A_AXIS][Y_AXIS] - ry ));
+
+        const float delta_B = rz + SQRT( delta_diagonal_rod_2_tower[B_AXIS]
+                                         - HYPOT2( delta_tower[B_AXIS][X_AXIS] - rx,
+                                                   delta_tower[B_AXIS][Y_AXIS] - ry ));
+
+        const float delta_C = rz + SQRT( delta_diagonal_rod_2_tower[C_AXIS]
+                                         - HYPOT2( delta_tower[C_AXIS][X_AXIS] - rx,
+                                                   delta_tower[C_AXIS][Y_AXIS] - ry ));
+
+        planner._buffer_line(delta_A, delta_B, delta_C, le, fr, active_extruder);
+
+      #elif IS_SCARA  // apply scara inverse_kinematics (should be changed to save raw->logical->raw)
+
+        const float lseg[XYZ] = { LOGICAL_X_POSITION(rx),
+                                  LOGICAL_Y_POSITION(ry),
+                                  LOGICAL_Z_POSITION(rz)
+                                };
+
+        inverse_kinematics(lseg); // this writes delta[ABC] from lseg[XYZ]
+                                  // should move the feedrate scaling to scara inverse_kinematics
+
+        const float adiff = FABS(delta[A_AXIS] - scara_oldA),
+                    bdiff = FABS(delta[B_AXIS] - scara_oldB);
+        scara_oldA = delta[A_AXIS];
+        scara_oldB = delta[B_AXIS];
+        float s_feedrate = max(adiff, bdiff) * scara_feed_factor;
+
+        planner._buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], le, s_feedrate, active_extruder);
+
+      #else // CARTESIAN
+
+        // Cartesian _buffer_line seems to take LOGICAL, not RAW coordinates
+
+        const float lx = LOGICAL_X_POSITION(rx),
+                    ly = LOGICAL_Y_POSITION(ry),
+                    lz = LOGICAL_Z_POSITION(rz);
+
+        planner._buffer_line(lx, ly, lz, le, fr, active_extruder);
+
+      #endif
+
+    }
+
+
+    /**
+     * Prepare a segmented linear move for DELTA/SCARA/CARTESIAN with UBL and FADE semantics.
+     * This calls planner._buffer_line multiple times for small incremental moves.
+     * Returns true if did NOT move, false if moved (requires current_position update).
+     */
+
+    bool _O2 unified_bed_leveling::prepare_segmented_line_to(const float ltarget[XYZE], const float &feedrate) {
+
+      if (!position_is_reachable_xy(ltarget[X_AXIS], ltarget[Y_AXIS]))  // fail if moving outside reachable boundary
+        return true; // did not move, so current_position still accurate
+
+      const float tot_dx = ltarget[X_AXIS] - current_position[X_AXIS],
+                  tot_dy = ltarget[Y_AXIS] - current_position[Y_AXIS],
+                  tot_dz = ltarget[Z_AXIS] - current_position[Z_AXIS],
+                  tot_de = ltarget[E_AXIS] - current_position[E_AXIS];
+
+      const float cartesian_xy_mm = HYPOT(tot_dx, tot_dy);  // total horizontal xy distance
+
+      #if IS_KINEMATIC
+        const float seconds = cartesian_xy_mm / feedrate;                                  // seconds to move xy distance at requested rate
+        uint16_t segments = lroundf(delta_segments_per_second * seconds),                  // preferred number of segments for distance @ feedrate
+                 seglimit = lroundf(cartesian_xy_mm * (1.0 / (DELTA_SEGMENT_MIN_LENGTH))); // number of segments at minimum segment length
+        NOMORE(segments, seglimit);                                                        // limit to minimum segment length (fewer segments)
+      #else
+        uint16_t segments = lroundf(cartesian_xy_mm * (1.0 / (DELTA_SEGMENT_MIN_LENGTH))); // cartesian fixed segment length
+      #endif
+
+      NOLESS(segments, 1);                        // must have at least one segment
+      const float inv_segments = 1.0 / segments;  // divide once, multiply thereafter
+
+      #if IS_SCARA // scale the feed rate from mm/s to degrees/s
+        scara_feed_factor = cartesian_xy_mm * inv_segments * feedrate;
+        scara_oldA = stepper.get_axis_position_degrees(A_AXIS);
+        scara_oldB = stepper.get_axis_position_degrees(B_AXIS);
+      #endif
+
+      const float seg_dx = tot_dx * inv_segments,
+                  seg_dy = tot_dy * inv_segments,
+                  seg_dz = tot_dz * inv_segments,
+                  seg_de = tot_de * inv_segments;
+
+      // Note that E segment distance could vary slightly as z mesh height
+      // changes for each segment, but small enough to ignore.
+
+      float seg_rx = RAW_X_POSITION(current_position[X_AXIS]),
+            seg_ry = RAW_Y_POSITION(current_position[Y_AXIS]),
+            seg_rz = RAW_Z_POSITION(current_position[Z_AXIS]),
+            seg_le = current_position[E_AXIS];
+
+      const bool above_fade_height = (
+        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+          planner.z_fade_height != 0 && planner.z_fade_height < RAW_Z_POSITION(ltarget[Z_AXIS])
+        #else
+          false
+        #endif
+      );
+
+      // Only compute leveling per segment if ubl active and target below z_fade_height.
+
+      if (!state.active || above_fade_height) {   // no mesh leveling
+
+        const float z_offset = state.active ? state.z_offset : 0.0;
+
+        do {
+
+          if (--segments) {     // not the last segment
+            seg_rx += seg_dx;
+            seg_ry += seg_dy;
+            seg_rz += seg_dz;
+            seg_le += seg_de;
+          } else {              // last segment, use exact destination
+            seg_rx = RAW_X_POSITION(ltarget[X_AXIS]);
+            seg_ry = RAW_Y_POSITION(ltarget[Y_AXIS]);
+            seg_rz = RAW_Z_POSITION(ltarget[Z_AXIS]);
+            seg_le = ltarget[E_AXIS];
+          }
+
+          ubl_buffer_segment_raw( seg_rx, seg_ry, seg_rz + z_offset, seg_le, feedrate );
+
+        } while (segments);
+
+        return false; // moved but did not set_current_to_destination();
+      }
+
+      // Otherwise perform per-segment leveling
+
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        const float fade_scaling_factor = fade_scaling_factor_for_z(ltarget[Z_AXIS]);
+      #endif
+
+      // increment to first segment destination
+      seg_rx += seg_dx;
+      seg_ry += seg_dy;
+      seg_rz += seg_dz;
+      seg_le += seg_de;
+
+      for(;;) {  // for each mesh cell encountered during the move
+
+        // Compute mesh cell invariants that remain constant for all segments within cell.
+        // Note for cell index, if point is outside the mesh grid (in MESH_INSET perimeter)
+        // the bilinear interpolation from the adjacent cell within the mesh will still work.
+        // Inner loop will exit each time (because out of cell bounds) but will come back
+        // in top of loop and again re-find same adjacent cell and use it, just less efficient
+        // for mesh inset area.
+
+        int8_t cell_xi = (seg_rx - (UBL_MESH_MIN_X)) * (1.0 / (MESH_X_DIST)),
+               cell_yi = (seg_ry - (UBL_MESH_MIN_Y)) * (1.0 / (MESH_X_DIST));
+
+        cell_xi = constrain(cell_xi, 0, (GRID_MAX_POINTS_X) - 1);
+        cell_yi = constrain(cell_yi, 0, (GRID_MAX_POINTS_Y) - 1);
+
+        const float x0 = mesh_index_to_xpos(cell_xi),   // 64 byte table lookup avoids mul+add
+                    y0 = mesh_index_to_ypos(cell_yi);
+
+        float z_x0y0 = z_values[cell_xi  ][cell_yi  ],  // z at lower left corner
+              z_x1y0 = z_values[cell_xi+1][cell_yi  ],  // z at upper left corner
+              z_x0y1 = z_values[cell_xi  ][cell_yi+1],  // z at lower right corner
+              z_x1y1 = z_values[cell_xi+1][cell_yi+1];  // z at upper right corner
+
+        if (isnan(z_x0y0)) z_x0y0 = 0;              // ideally activating state.active (G29 A)
+        if (isnan(z_x1y0)) z_x1y0 = 0;              //   should refuse if any invalid mesh points
+        if (isnan(z_x0y1)) z_x0y1 = 0;              //   in order to avoid isnan tests per cell,
+        if (isnan(z_x1y1)) z_x1y1 = 0;              //   thus guessing zero for undefined points
+
+        float cx = seg_rx - x0,   // cell-relative x and y
+              cy = seg_ry - y0;
+
+        const float z_xmy0 = (z_x1y0 - z_x0y0) * (1.0 / (MESH_X_DIST)),   // z slope per x along y0 (lower left to lower right)
+                    z_xmy1 = (z_x1y1 - z_x0y1) * (1.0 / (MESH_X_DIST));   // z slope per x along y1 (upper left to upper right)
+
+              float z_cxy0 = z_x0y0 + z_xmy0 * cx;            // z height along y0 at cx (changes for each cx in cell)
+
+        const float z_cxy1 = z_x0y1 + z_xmy1 * cx,            // z height along y1 at cx
+                    z_cxyd = z_cxy1 - z_cxy0;                 // z height difference along cx from y0 to y1
+
+              float z_cxym = z_cxyd * (1.0 / (MESH_Y_DIST));  // z slope per y along cx from y0 to y1 (changes for each cx in cell)
+
+        //    float z_cxcy = z_cxy0 + z_cxym * cy;            // interpolated mesh z height along cx at cy (do inside the segment loop)
+
+        // As subsequent segments step through this cell, the z_cxy0 intercept will change
+        // and the z_cxym slope will change, both as a function of cx within the cell, and
+        // each change by a constant for fixed segment lengths.
+
+        const float z_sxy0 = z_xmy0 * seg_dx,                                     // per-segment adjustment to z_cxy0
+                    z_sxym = (z_xmy1 - z_xmy0) * (1.0 / (MESH_Y_DIST)) * seg_dx;  // per-segment adjustment to z_cxym
+
+        for(;;) {  // for all segments within this mesh cell
+
+          float z_cxcy = z_cxy0 + z_cxym * cy;      // interpolated mesh z height along cx at cy
+
+          #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+            z_cxcy *= fade_scaling_factor;          // apply fade factor to interpolated mesh height
+          #endif
+
+          z_cxcy += state.z_offset;                 // add fixed mesh offset from G29 Z
+
+          if (--segments == 0) {                    // if this is last segment, use ltarget for exact
+            seg_rx = RAW_X_POSITION(ltarget[X_AXIS]);
+            seg_ry = RAW_Y_POSITION(ltarget[Y_AXIS]);
+            seg_rz = RAW_Z_POSITION(ltarget[Z_AXIS]);
+            seg_le = ltarget[E_AXIS];
+          }
+
+          ubl_buffer_segment_raw( seg_rx, seg_ry, seg_rz + z_cxcy, seg_le, feedrate );
+
+          if (segments == 0 )                       // done with last segment
+            return false;                           // did not set_current_to_destination()
+
+          seg_rx += seg_dx;
+          seg_ry += seg_dy;
+          seg_rz += seg_dz;
+          seg_le += seg_de;
+
+          cx += seg_dx;
+          cy += seg_dy;
+
+          if (!WITHIN(cx, 0, MESH_X_DIST) || !WITHIN(cy, 0, MESH_Y_DIST)) {  // done within this cell, break to next
+            break;
+          }
+
+          // Next segment still within same mesh cell, adjust the per-segment
+          // slope and intercept to compute next z height.
+
+          z_cxy0 += z_sxy0;   // adjust z_cxy0 by per-segment z_sxy0
+          z_cxym += z_sxym;   // adjust z_cxym by per-segment z_sxym
+
+        } // segment loop
+      } // cell loop
+    }
+
+  #endif // UBL_DELTA
+
+#endif // AUTO_BED_LEVELING_UBL
