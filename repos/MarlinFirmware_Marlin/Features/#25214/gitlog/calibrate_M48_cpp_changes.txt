commit 49348716f538a16f7232efb0eed5d4e01d5a1494
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon May 6 19:58:00 2024 -0400

    ü©π Fix printf et.al. expecting F-strings (#27032)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 8dd951e054..910395e561 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -149,7 +149,7 @@ void GcodeSuite::M48() {
     for (uint8_t n = 0; n < n_samples; ++n) {
       #if HAS_STATUS_MESSAGE
         // Display M48 progress in the status bar
-        ui.status_printf(0, F(S_FMT ": %d/%d"), GET_TEXT(MSG_M48_POINT), int(n + 1), int(n_samples));
+        ui.status_printf(0, F(S_FMT ": %d/%d"), GET_TEXT_F(MSG_M48_POINT), int(n + 1), int(n_samples));
       #endif
 
       // When there are "legs" of movement move around the point before probing

commit 669814d0d408a622f020a55971ba04030e4fa4bf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 7 23:40:54 2024 -0600

    ‚ú® MARLIN_SMALL_BUILD option (#26775)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index e3b81ce5b8..8dd951e054 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -62,13 +62,13 @@ void GcodeSuite::M48() {
 
   const int8_t verbose_level = parser.byteval('V', 1);
   if (!WITHIN(verbose_level, 0, 4)) {
-    SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-4).");
+    SERIAL_ECHOLNPGM(GCODE_ERR_MSG("(V)erbose level implausible (0-4)."));
     return;
   }
 
   const int8_t n_samples = parser.byteval('P', 10);
   if (!WITHIN(n_samples, 4, 50)) {
-    SERIAL_ECHOLNPGM("?Sample size not plausible (4-50).");
+    SERIAL_ECHOLNPGM(GCODE_ERR_MSG("Sample size not plausible (4-50)."));
     return;
   }
 
@@ -82,7 +82,7 @@ void GcodeSuite::M48() {
 
   if (!probe.can_reach(test_position)) {
     LCD_MESSAGE_MAX(MSG_M48_OUT_OF_BOUNDS);
-    SERIAL_ECHOLNPGM("? (X,Y) out of bounds.");
+    SERIAL_ECHOLNPGM(GCODE_ERR_MSG(" (X,Y) out of bounds."));
     return;
   }
 
@@ -90,7 +90,7 @@ void GcodeSuite::M48() {
   bool seen_L = parser.seen('L');
   uint8_t n_legs = seen_L ? parser.value_byte() : 0;
   if (n_legs > 15) {
-    SERIAL_ECHOLNPGM("?Legs of movement implausible (0-15).");
+    SERIAL_ECHOLNPGM(GCODE_ERR_MSG("Legs of movement implausible (0-15)."));
     return;
   }
   if (n_legs == 1) n_legs = 2;

commit dd3b5a10a09e2a83918af1cf6f8782fd0c473f98
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 21 22:00:37 2024 -0600

    Misc. aesthetic adjustments
    
    Co-Authored-By: Andrew <18502096+classicrocker883@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 2d219a07c5..e3b81ce5b8 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -66,9 +66,6 @@ void GcodeSuite::M48() {
     return;
   }
 
-  if (verbose_level > 0)
-    SERIAL_ECHOLNPGM("M48 Z-Probe Repeatability Test");
-
   const int8_t n_samples = parser.byteval('P', 10);
   if (!WITHIN(n_samples, 4, 50)) {
     SERIAL_ECHOLNPGM("?Sample size not plausible (4-50).");
@@ -102,6 +99,9 @@ void GcodeSuite::M48() {
   const bool schizoid_flag = parser.boolval('S');
   if (schizoid_flag && !seen_L) n_legs = 7;
 
+  if (verbose_level > 0)
+    SERIAL_ECHOLNPGM("M48 Z-Probe Repeatability Test");
+
   if (verbose_level > 2)
     SERIAL_ECHOLNPGM("Positioning the probe...");
 
@@ -261,8 +261,7 @@ void GcodeSuite::M48() {
 
     #if HAS_STATUS_MESSAGE
       // Display M48 results in the status bar
-      char sigma_str[8];
-      ui.status_printf(0, F(S_FMT ": %s"), GET_TEXT(MSG_M48_DEVIATION), dtostrf(sigma, 2, 6, sigma_str));
+      ui.set_status_and_level(MString<30>(GET_TEXT_F(MSG_M48_DEVIATION), F(": "), w_float_t(sigma, 2, 6)));
     #endif
   }
 

commit 15f26b402123d087f62728e1f1763a2b96f8d21d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Dec 27 01:25:51 2023 -0600

    üßë‚Äçüíª AS_CHAR => C (#26569)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 9f285b8b8a..2d219a07c5 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -245,7 +245,7 @@ void GcodeSuite::M48() {
       sigma = SQRT(dev_sum / (n + 1));
 
       if (verbose_level > 1) {
-        SERIAL_ECHO(n + 1, F(" of "), n_samples, F(": z: "), p_float_t(pz, 3), AS_CHAR(' '));
+        SERIAL_ECHO(n + 1, F(" of "), n_samples, F(": z: "), p_float_t(pz, 3), C(' '));
         dev_report(verbose_level > 2, mean, sigma, min, max);
         SERIAL_EOL();
       }

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ‚ôªÔ∏è Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 2748d4e7ba..9f285b8b8a 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -126,15 +126,13 @@ void GcodeSuite::M48() {
 
   auto dev_report = [](const bool verbose, const_float_t mean, const_float_t sigma, const_float_t min, const_float_t max, const bool final=false) {
     if (verbose) {
-      SERIAL_ECHOPAIR_F("Mean: ", mean, 6);
-      if (!final) SERIAL_ECHOPAIR_F(" Sigma: ", sigma, 6);
-      SERIAL_ECHOPAIR_F(" Min: ", min, 3);
-      SERIAL_ECHOPAIR_F(" Max: ", max, 3);
-      SERIAL_ECHOPAIR_F(" Range: ", max-min, 3);
+      SERIAL_ECHOPGM("Mean: ", p_float_t(mean, 6));
+      if (!final) SERIAL_ECHOPGM(" Sigma: ", p_float_t(sigma, 6));
+      SERIAL_ECHOPGM(" Min: ", p_float_t(min, 3), " Max: ", p_float_t(max, 3), " Range: ", p_float_t(max-min, 3));
       if (final) SERIAL_EOL();
     }
     if (final) {
-      SERIAL_ECHOLNPAIR_F("Standard Deviation: ", sigma, 6);
+      SERIAL_ECHOLNPGM("Standard Deviation: ", p_float_t(sigma, 6));
       SERIAL_EOL();
     }
   };
@@ -207,7 +205,7 @@ void GcodeSuite::M48() {
             while (!probe.can_reach(next_pos)) {
               next_pos *= 0.8f;
               if (verbose_level > 3)
-                SERIAL_ECHOLNPGM_P(PSTR("Moving inward: X"), next_pos.x, SP_Y_STR, next_pos.y);
+                SERIAL_ECHOLN(F("Moving inward: X"), next_pos.x, FPSTR(SP_Y_STR), next_pos.y);
             }
           #elif HAS_ENDSTOPS
             // For a rectangular bed just keep the probe in bounds
@@ -216,7 +214,7 @@ void GcodeSuite::M48() {
           #endif
 
           if (verbose_level > 3)
-            SERIAL_ECHOLNPGM_P(PSTR("Going to: X"), next_pos.x, SP_Y_STR, next_pos.y);
+            SERIAL_ECHOLN(F("Going to: X"), next_pos.x, FPSTR(SP_Y_STR), next_pos.y);
 
           do_blocking_move_to_xy(next_pos);
         } // n_legs loop
@@ -247,10 +245,7 @@ void GcodeSuite::M48() {
       sigma = SQRT(dev_sum / (n + 1));
 
       if (verbose_level > 1) {
-        SERIAL_ECHO(n + 1);
-        SERIAL_ECHOPGM(" of ", n_samples);
-        SERIAL_ECHOPAIR_F(": z: ", pz, 3);
-        SERIAL_CHAR(' ');
+        SERIAL_ECHO(n + 1, F(" of "), n_samples, F(": z: "), p_float_t(pz, 3), AS_CHAR(' '));
         dev_report(verbose_level > 2, mean, sigma, min, max);
         SERIAL_EOL();
       }

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 701e938697..2748d4e7ba 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -148,7 +148,7 @@ void GcodeSuite::M48() {
 
     float sample_sum = 0.0;
 
-    LOOP_L_N(n, n_samples) {
+    for (uint8_t n = 0; n < n_samples; ++n) {
       #if HAS_STATUS_MESSAGE
         // Display M48 progress in the status bar
         ui.status_printf(0, F(S_FMT ": %d/%d"), GET_TEXT(MSG_M48_POINT), int(n + 1), int(n_samples));
@@ -175,7 +175,7 @@ void GcodeSuite::M48() {
         }
 
         // Move from leg to leg in rapid succession
-        LOOP_L_N(l, n_legs - 1) {
+        for (uint8_t l = 0; l < n_legs - 1; ++l) {
 
           // Move some distance around the perimeter
           float delta_angle;
@@ -243,7 +243,7 @@ void GcodeSuite::M48() {
       // Calculate the standard deviation so far.
       // The value after the last sample will be the final output.
       float dev_sum = 0.0;
-      LOOP_LE_N(j, n) dev_sum += sq(sample_set[j] - mean);
+      for (uint8_t j = 0; j <= n; ++j) dev_sum += sq(sample_set[j] - mean);
       sigma = SQRT(dev_sum / (n + 1));
 
       if (verbose_level > 1) {

commit c5a2e41647a12ef16b280975ab713e080e831e46
Author: James Pearson <jamespearson04@hotmail.co.uk>
Date:   Fri Apr 28 23:30:15 2023 +0100

    üêõ Probe behavior corrections (#25631)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: David Fries <2767875+dfries@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 5e0c21b42e..701e938697 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -223,7 +223,7 @@ void GcodeSuite::M48() {
       } // n_legs
 
       // Probe a single point
-      const float pz = probe.probe_at_point(test_position, raise_after, 0);
+      const float pz = probe.probe_at_point(test_position, raise_after);
 
       // Break the loop if the probe fails
       probing_good = !isnan(pz);

commit 9a1c02591ba4c3d5b41f4c64edd819ea1860b75b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 14 17:51:45 2023 -0500

    üßë‚Äçüíª Status Message cleanup

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index ff14175c71..5e0c21b42e 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -84,7 +84,7 @@ void GcodeSuite::M48() {
   };
 
   if (!probe.can_reach(test_position)) {
-    ui.set_status(GET_TEXT_F(MSG_M48_OUT_OF_BOUNDS), 99);
+    LCD_MESSAGE_MAX(MSG_M48_OUT_OF_BOUNDS);
     SERIAL_ECHOLNPGM("? (X,Y) out of bounds.");
     return;
   }

commit 7717beb79362522b8239d5af62b32ff3d0e2d748
Author: kadir ilkimen <kadirilkimen@gmail.com>
Date:   Wed Jan 11 06:29:38 2023 +0200

    ‚ú® Polar Kinematics (#25214)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index bfb3b64007..ff14175c71 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -162,8 +162,8 @@ void GcodeSuite::M48() {
         float angle = random(0, 360);
         const float radius = random(
           #if ENABLED(DELTA)
-            int(0.1250000000 * (DELTA_PRINTABLE_RADIUS)),
-            int(0.3333333333 * (DELTA_PRINTABLE_RADIUS))
+            int(0.1250000000 * (PRINTABLE_RADIUS)),
+            int(0.3333333333 * (PRINTABLE_RADIUS))
           #else
             int(5), int(0.125 * _MIN(X_BED_SIZE, Y_BED_SIZE))
           #endif

commit dab43a762718af1d23e1422d751eb312cafcb17e
Author: kisslorand <50251547+kisslorand@users.noreply.github.com>
Date:   Mon Dec 5 00:04:11 2022 +0200

    ‚úèÔ∏è Fix missing ) (#25055)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 825f3713f4..bfb3b64007 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -112,7 +112,7 @@ void GcodeSuite::M48() {
     set_bed_leveling_enabled(false);
   #endif
 
-  TERN_(HAS_PTC, ptc.set_enabled(parser.boolval('C', true));
+  TERN_(HAS_PTC, ptc.set_enabled(parser.boolval('C', true)));
 
   // Work with reasonable feedrates
   remember_feedrate_scaling_off();

commit 3ba9387479b115e7e21f33b3cd2d3e153209520e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Dec 3 20:49:46 2022 -0600

    üé® Misc. cleanup

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 8b6ea0bf1f..825f3713f4 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -112,7 +112,7 @@ void GcodeSuite::M48() {
     set_bed_leveling_enabled(false);
   #endif
 
-  TERN_(HAS_PTC, ptc.set_enabled(!parser.seen('C') || parser.value_bool()));
+  TERN_(HAS_PTC, ptc.set_enabled(parser.boolval('C', true));
 
   // Work with reasonable feedrates
   remember_feedrate_scaling_off();

commit 8f8427ec8f69705e09ca226d9f16da6b82634439
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Tue Feb 22 01:15:52 2022 +0000

    ‚ö°Ô∏è Apply PTC on all probing (#23764)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 913ffe30d4..8b6ea0bf1f 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -35,11 +35,15 @@
   #include "../../module/planner.h"
 #endif
 
+#if HAS_PTC
+  #include "../../feature/probe_temp_comp.h"
+#endif
+
 /**
  * M48: Z probe repeatability measurement function.
  *
  * Usage:
- *   M48 <P#> <X#> <Y#> <V#> <E> <L#> <S>
+ *   M48 <P#> <X#> <Y#> <V#> <E> <L#> <S> <C#>
  *     P = Number of sampled points (4-50, default 10)
  *     X = Sample X position
  *     Y = Sample Y position
@@ -47,6 +51,7 @@
  *     E = Engage Z probe for each reading
  *     L = Number of legs of movement before probe
  *     S = Schizoid (Or Star if you prefer)
+ *     C = Enable probe temperature compensation (0 or 1, default 1)
  *
  * This function requires the machine to be homed before invocation.
  */
@@ -107,6 +112,8 @@ void GcodeSuite::M48() {
     set_bed_leveling_enabled(false);
   #endif
 
+  TERN_(HAS_PTC, ptc.set_enabled(!parser.seen('C') || parser.value_bool()));
+
   // Work with reasonable feedrates
   remember_feedrate_scaling_off();
 
@@ -269,6 +276,9 @@ void GcodeSuite::M48() {
   // Re-enable bed level correction if it had been on
   TERN_(HAS_LEVELING, set_bed_leveling_enabled(was_enabled));
 
+  // Re-enable probe temperature correction
+  TERN_(HAS_PTC, ptc.set_enabled(true));
+
   report_current_position();
 }
 

commit 7f1286a11f87065c4e666985e679cf9c77d668bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 17:05:11 2021 -0500

    üé® Apply F() to status message

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 9db90c76ac..913ffe30d4 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -79,7 +79,7 @@ void GcodeSuite::M48() {
   };
 
   if (!probe.can_reach(test_position)) {
-    ui.set_status_P(GET_TEXT(MSG_M48_OUT_OF_BOUNDS), 99);
+    ui.set_status(GET_TEXT_F(MSG_M48_OUT_OF_BOUNDS), 99);
     SERIAL_ECHOLNPGM("? (X,Y) out of bounds.");
     return;
   }
@@ -144,7 +144,7 @@ void GcodeSuite::M48() {
     LOOP_L_N(n, n_samples) {
       #if HAS_STATUS_MESSAGE
         // Display M48 progress in the status bar
-        ui.status_printf_P(0, PSTR(S_FMT ": %d/%d"), GET_TEXT(MSG_M48_POINT), int(n + 1), int(n_samples));
+        ui.status_printf(0, F(S_FMT ": %d/%d"), GET_TEXT(MSG_M48_POINT), int(n + 1), int(n_samples));
       #endif
 
       // When there are "legs" of movement move around the point before probing
@@ -260,7 +260,7 @@ void GcodeSuite::M48() {
     #if HAS_STATUS_MESSAGE
       // Display M48 results in the status bar
       char sigma_str[8];
-      ui.status_printf_P(0, PSTR(S_FMT ": %s"), GET_TEXT(MSG_M48_DEVIATION), dtostrf(sigma, 2, 6, sigma_str));
+      ui.status_printf(0, F(S_FMT ": %s"), GET_TEXT(MSG_M48_DEVIATION), dtostrf(sigma, 2, 6, sigma_str));
     #endif
   }
 

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 19b11f602a..9db90c76ac 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -162,7 +162,7 @@ void GcodeSuite::M48() {
           #endif
         );
         if (verbose_level > 3) {
-          SERIAL_ECHOPAIR("Start radius:", radius, " angle:", angle, " dir:");
+          SERIAL_ECHOPGM("Start radius:", radius, " angle:", angle, " dir:");
           if (dir > 0) SERIAL_CHAR('C');
           SERIAL_ECHOLNPGM("CW");
         }
@@ -200,7 +200,7 @@ void GcodeSuite::M48() {
             while (!probe.can_reach(next_pos)) {
               next_pos *= 0.8f;
               if (verbose_level > 3)
-                SERIAL_ECHOLNPAIR_P(PSTR("Moving inward: X"), next_pos.x, SP_Y_STR, next_pos.y);
+                SERIAL_ECHOLNPGM_P(PSTR("Moving inward: X"), next_pos.x, SP_Y_STR, next_pos.y);
             }
           #elif HAS_ENDSTOPS
             // For a rectangular bed just keep the probe in bounds
@@ -209,7 +209,7 @@ void GcodeSuite::M48() {
           #endif
 
           if (verbose_level > 3)
-            SERIAL_ECHOLNPAIR_P(PSTR("Going to: X"), next_pos.x, SP_Y_STR, next_pos.y);
+            SERIAL_ECHOLNPGM_P(PSTR("Going to: X"), next_pos.x, SP_Y_STR, next_pos.y);
 
           do_blocking_move_to_xy(next_pos);
         } // n_legs loop
@@ -241,7 +241,7 @@ void GcodeSuite::M48() {
 
       if (verbose_level > 1) {
         SERIAL_ECHO(n + 1);
-        SERIAL_ECHOPAIR(" of ", n_samples);
+        SERIAL_ECHOPGM(" of ", n_samples);
         SERIAL_ECHOPAIR_F(": z: ", pz, 3);
         SERIAL_CHAR(' ');
         dev_report(verbose_level > 2, mean, sigma, min, max);

commit 528b9bd8729656d7ebcd3dc7898ceddc2f377354
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 16 02:43:59 2021 -0500

    Revert experimental NAN patch
    
    Hold changes from #21575 (24a095c) for more testing.

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 07e248fc3d..19b11f602a 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -134,7 +134,7 @@ void GcodeSuite::M48() {
 
   // Move to the first point, deploy, and probe
   const float t = probe.probe_at_point(test_position, raise_after, verbose_level);
-  bool probing_good = !ISNAN(t);
+  bool probing_good = !isnan(t);
 
   if (probing_good) {
     randomSeed(millis());
@@ -219,7 +219,7 @@ void GcodeSuite::M48() {
       const float pz = probe.probe_at_point(test_position, raise_after, 0);
 
       // Break the loop if the probe fails
-      probing_good = !ISNAN(pz);
+      probing_good = !isnan(pz);
       if (!probing_good) break;
 
       // Store the new sample

commit 24a095c5c14b60bcbffc2807d2c8cc8e9af46e90
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 12 16:49:53 2021 -0500

    Reduce math library code size by 3.4KB (#21575)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 19b11f602a..07e248fc3d 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -134,7 +134,7 @@ void GcodeSuite::M48() {
 
   // Move to the first point, deploy, and probe
   const float t = probe.probe_at_point(test_position, raise_after, verbose_level);
-  bool probing_good = !isnan(t);
+  bool probing_good = !ISNAN(t);
 
   if (probing_good) {
     randomSeed(millis());
@@ -219,7 +219,7 @@ void GcodeSuite::M48() {
       const float pz = probe.probe_at_point(test_position, raise_after, 0);
 
       // Break the loop if the probe fails
-      probing_good = !isnan(pz);
+      probing_good = !ISNAN(pz);
       if (!probing_good) break;
 
       // Store the new sample

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 0c3da13bf9..19b11f602a 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -117,7 +117,7 @@ void GcodeSuite::M48() {
         max = -99999.9, // Largest value sampled so far
         sample_set[n_samples];  // Storage for sampled values
 
-  auto dev_report = [](const bool verbose, const float &mean, const float &sigma, const float &min, const float &max, const bool final=false) {
+  auto dev_report = [](const bool verbose, const_float_t mean, const_float_t sigma, const_float_t min, const_float_t max, const bool final=false) {
     if (verbose) {
       SERIAL_ECHOPAIR_F("Mean: ", mean, 6);
       if (!final) SERIAL_ECHOPAIR_F(" Sigma: ", sigma, 6);

commit 930752d46e6aacb484ea89dacae6baf823d78d62
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Wed Mar 24 10:12:57 2021 -0500

    Ender 3 V2 Status Line (#21369)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 0c6176173c..0c3da13bf9 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -142,7 +142,7 @@ void GcodeSuite::M48() {
     float sample_sum = 0.0;
 
     LOOP_L_N(n, n_samples) {
-      #if HAS_WIRED_LCD
+      #if HAS_STATUS_MESSAGE
         // Display M48 progress in the status bar
         ui.status_printf_P(0, PSTR(S_FMT ": %d/%d"), GET_TEXT(MSG_M48_POINT), int(n + 1), int(n_samples));
       #endif
@@ -257,7 +257,7 @@ void GcodeSuite::M48() {
     SERIAL_ECHOLNPGM("Finished!");
     dev_report(verbose_level > 0, mean, sigma, min, max, true);
 
-    #if HAS_WIRED_LCD
+    #if HAS_STATUS_MESSAGE
       // Display M48 results in the status bar
       char sigma_str[8];
       ui.status_printf_P(0, PSTR(S_FMT ": %s"), GET_TEXT(MSG_M48_DEVIATION), dtostrf(sigma, 2, 6, sigma_str));

commit 468e437390afdb1de7059e7f9049d0b30c312024
Author: deirdreobyrne <deirdre.dub@gmail.com>
Date:   Thu Feb 25 10:49:34 2021 +0000

    Allow Zero Endstops (e.g., for CNC) (#21120)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 63d2370697..0c6176173c 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -202,7 +202,7 @@ void GcodeSuite::M48() {
               if (verbose_level > 3)
                 SERIAL_ECHOLNPAIR_P(PSTR("Moving inward: X"), next_pos.x, SP_Y_STR, next_pos.y);
             }
-          #else
+          #elif HAS_ENDSTOPS
             // For a rectangular bed just keep the probe in bounds
             LIMIT(next_pos.x, X_MIN_POS, X_MAX_POS);
             LIMIT(next_pos.y, Y_MIN_POS, Y_MAX_POS);

commit e7c711996bd3080f5e343eff5556736cbf2e2416
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 8 07:37:24 2021 +0100

    Serial refactor. Default 8-bit ECHO to int, not char (#20985)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 97aea59221..63d2370697 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -240,8 +240,8 @@ void GcodeSuite::M48() {
       sigma = SQRT(dev_sum / (n + 1));
 
       if (verbose_level > 1) {
-        SERIAL_ECHO((int)(n + 1));
-        SERIAL_ECHOPAIR(" of ", (int)n_samples);
+        SERIAL_ECHO(n + 1);
+        SERIAL_ECHOPAIR(" of ", n_samples);
         SERIAL_ECHOPAIR_F(": z: ", pz, 3);
         SERIAL_CHAR(' ');
         dev_report(verbose_level > 2, mean, sigma, min, max);

commit 27366197f3380627af365b005702bbe16393a18a
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 1 00:21:27 2021 +0100

    Serial refactor followup (#20932)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 529d5c75d9..97aea59221 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -240,8 +240,8 @@ void GcodeSuite::M48() {
       sigma = SQRT(dev_sum / (n + 1));
 
       if (verbose_level > 1) {
-        SERIAL_ECHO(n + 1);
-        SERIAL_ECHOPAIR(" of ", int(n_samples));
+        SERIAL_ECHO((int)(n + 1));
+        SERIAL_ECHOPAIR(" of ", (int)n_samples);
         SERIAL_ECHOPAIR_F(": z: ", pz, 3);
         SERIAL_CHAR(' ');
         dev_report(verbose_level > 2, mean, sigma, min, max);

commit d33fe2378c25d258b02440aef6cc31e36753f98f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 22 15:01:19 2021 -0600

    Move common strings (#20846)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 46367df10d..529d5c75d9 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -51,8 +51,6 @@
  * This function requires the machine to be homed before invocation.
  */
 
-extern const char SP_Y_STR[];
-
 void GcodeSuite::M48() {
 
   if (homing_needed_error()) return;

commit 4eedeabb51ada1f18656567588dfc750fa19bc39
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Fri Jan 8 00:55:57 2021 +0100

    Fix M48 output (#20713)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index e70815ad54..46367df10d 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -245,6 +245,7 @@ void GcodeSuite::M48() {
         SERIAL_ECHO(n + 1);
         SERIAL_ECHOPAIR(" of ", int(n_samples));
         SERIAL_ECHOPAIR_F(": z: ", pz, 3);
+        SERIAL_CHAR(' ');
         dev_report(verbose_level > 2, mean, sigma, min, max);
         SERIAL_EOL();
       }

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 8640dfa391..e70815ad54 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -27,7 +27,7 @@
 #include "../gcode.h"
 #include "../../module/motion.h"
 #include "../../module/probe.h"
-#include "../../lcd/ultralcd.h"
+#include "../../lcd/marlinui.h"
 
 #include "../../feature/bedlevel/bedlevel.h"
 

commit c2c6a679ea4bdf48ce1800a8831fcec36c09ce53
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 28 01:13:27 2020 -0500

    Rename LCD conditionals (#19533)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 88273b46e4..8640dfa391 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -144,7 +144,7 @@ void GcodeSuite::M48() {
     float sample_sum = 0.0;
 
     LOOP_L_N(n, n_samples) {
-      #if HAS_SPI_LCD
+      #if HAS_WIRED_LCD
         // Display M48 progress in the status bar
         ui.status_printf_P(0, PSTR(S_FMT ": %d/%d"), GET_TEXT(MSG_M48_POINT), int(n + 1), int(n_samples));
       #endif
@@ -258,7 +258,7 @@ void GcodeSuite::M48() {
     SERIAL_ECHOLNPGM("Finished!");
     dev_report(verbose_level > 0, mean, sigma, min, max, true);
 
-    #if HAS_SPI_LCD
+    #if HAS_WIRED_LCD
       // Display M48 results in the status bar
       char sigma_str[8];
       ui.status_printf_P(0, PSTR(S_FMT ": %s"), GET_TEXT(MSG_M48_DEVIATION), dtostrf(sigma, 2, 6, sigma_str));

commit 5f5f76956f11c7c58278fd449f6ad85e07cd6e10
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 22 19:58:06 2020 -0500

    Fix up tests, warnings

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index aaf58eed1c..88273b46e4 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -192,8 +192,8 @@ void GcodeSuite::M48() {
           // Choose the next position as an offset to chosen test position
           const xy_pos_t noz_pos = test_position - probe.offset_xy;
           xy_pos_t next_pos = {
-            noz_pos.x + cos(RADIANS(angle)) * radius,
-            noz_pos.y + sin(RADIANS(angle)) * radius
+            noz_pos.x + float(cos(RADIANS(angle))) * radius,
+            noz_pos.y + float(sin(RADIANS(angle))) * radius
           };
 
           #if ENABLED(DELTA)

commit a12ac5e1754f0f66babde400a0406b6cdbff983e
Author: swissnorp <67485708+swissnorp@users.noreply.github.com>
Date:   Thu Aug 27 23:05:53 2020 +0200

    Mark axes not-homed with HOME_AFTER_DEACTIVATE (#18907)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index fc9d22957b..aaf58eed1c 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -55,7 +55,7 @@ extern const char SP_Y_STR[];
 
 void GcodeSuite::M48() {
 
-  if (axis_unhomed_error()) return;
+  if (homing_needed_error()) return;
 
   const int8_t verbose_level = parser.byteval('V', 1);
   if (!WITHIN(verbose_level, 0, 4)) {

commit 6b549e19719e855555c1a9db5e3c0453516afb28
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sat Aug 22 04:20:30 2020 +0200

    Optional homing in LCD Repeatability Test (#19104)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 47c72eece7..fc9d22957b 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -27,13 +27,10 @@
 #include "../gcode.h"
 #include "../../module/motion.h"
 #include "../../module/probe.h"
+#include "../../lcd/ultralcd.h"
 
 #include "../../feature/bedlevel/bedlevel.h"
 
-#if HAS_SPI_LCD
-  #include "../../lcd/ultralcd.h"
-#endif
-
 #if HAS_LEVELING
   #include "../../module/planner.h"
 #endif
@@ -77,61 +74,85 @@ void GcodeSuite::M48() {
 
   const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
 
-  xy_float_t next_pos = current_position;
-
-  const xy_pos_t probe_pos = {
-    parser.linearval('X', next_pos.x + probe.offset_xy.x),  // If no X use the probe's current X position
-    parser.linearval('Y', next_pos.y + probe.offset_xy.y)   // If no Y, ditto
+  // Test at the current position by default, overridden by X and Y
+  const xy_pos_t test_position = {
+    parser.linearval('X', current_position.x + probe.offset_xy.x),  // If no X use the probe's current X position
+    parser.linearval('Y', current_position.y + probe.offset_xy.y)   // If no Y, ditto
   };
 
-  if (!probe.can_reach(probe_pos)) {
+  if (!probe.can_reach(test_position)) {
+    ui.set_status_P(GET_TEXT(MSG_M48_OUT_OF_BOUNDS), 99);
     SERIAL_ECHOLNPGM("? (X,Y) out of bounds.");
     return;
   }
 
+  // Get the number of leg moves per test-point
   bool seen_L = parser.seen('L');
   uint8_t n_legs = seen_L ? parser.value_byte() : 0;
   if (n_legs > 15) {
-    SERIAL_ECHOLNPGM("?Number of legs in movement not plausible (0-15).");
+    SERIAL_ECHOLNPGM("?Legs of movement implausible (0-15).");
     return;
   }
   if (n_legs == 1) n_legs = 2;
 
+  // Schizoid motion as an optional stress-test
   const bool schizoid_flag = parser.boolval('S');
   if (schizoid_flag && !seen_L) n_legs = 7;
 
-  /**
-   * Now get everything to the specified probe point So we can safely do a
-   * probe to get us close to the bed.  If the Z-Axis is far from the bed,
-   * we don't want to use that as a starting point for each probe.
-   */
   if (verbose_level > 2)
     SERIAL_ECHOLNPGM("Positioning the probe...");
 
-  // Disable bed level correction in M48 because we want the raw data when we probe
+  // Always disable Bed Level correction before probing...
 
   #if HAS_LEVELING
     const bool was_enabled = planner.leveling_active;
     set_bed_leveling_enabled(false);
   #endif
 
+  // Work with reasonable feedrates
   remember_feedrate_scaling_off();
 
-  float mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
+  // Working variables
+  float mean = 0.0,     // The average of all points so far, used to calculate deviation
+        sigma = 0.0,    // Standard deviation of all points so far
+        min = 99999.9,  // Smallest value sampled so far
+        max = -99999.9, // Largest value sampled so far
+        sample_set[n_samples];  // Storage for sampled values
+
+  auto dev_report = [](const bool verbose, const float &mean, const float &sigma, const float &min, const float &max, const bool final=false) {
+    if (verbose) {
+      SERIAL_ECHOPAIR_F("Mean: ", mean, 6);
+      if (!final) SERIAL_ECHOPAIR_F(" Sigma: ", sigma, 6);
+      SERIAL_ECHOPAIR_F(" Min: ", min, 3);
+      SERIAL_ECHOPAIR_F(" Max: ", max, 3);
+      SERIAL_ECHOPAIR_F(" Range: ", max-min, 3);
+      if (final) SERIAL_EOL();
+    }
+    if (final) {
+      SERIAL_ECHOLNPAIR_F("Standard Deviation: ", sigma, 6);
+      SERIAL_EOL();
+    }
+  };
 
   // Move to the first point, deploy, and probe
-  const float t = probe.probe_at_point(probe_pos, raise_after, verbose_level);
+  const float t = probe.probe_at_point(test_position, raise_after, verbose_level);
   bool probing_good = !isnan(t);
 
   if (probing_good) {
     randomSeed(millis());
 
+    float sample_sum = 0.0;
+
     LOOP_L_N(n, n_samples) {
       #if HAS_SPI_LCD
         // Display M48 progress in the status bar
         ui.status_printf_P(0, PSTR(S_FMT ": %d/%d"), GET_TEXT(MSG_M48_POINT), int(n + 1), int(n_samples));
       #endif
+
+      // When there are "legs" of movement move around the point before probing
       if (n_legs) {
+
+        // Pick a random direction, starting angle, and radius
         const int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
         float angle = random(0, 360);
         const float radius = random(
@@ -142,48 +163,51 @@ void GcodeSuite::M48() {
             int(5), int(0.125 * _MIN(X_BED_SIZE, Y_BED_SIZE))
           #endif
         );
-
         if (verbose_level > 3) {
           SERIAL_ECHOPAIR("Start radius:", radius, " angle:", angle, " dir:");
           if (dir > 0) SERIAL_CHAR('C');
           SERIAL_ECHOLNPGM("CW");
         }
 
+        // Move from leg to leg in rapid succession
         LOOP_L_N(l, n_legs - 1) {
-          float delta_angle;
 
+          // Move some distance around the perimeter
+          float delta_angle;
           if (schizoid_flag) {
-            // The points of a 5 point star are 72 degrees apart.  We need to
-            // skip a point and go to the next one on the star.
+            // The points of a 5 point star are 72 degrees apart.
+            // Skip a point and go to the next one on the star.
             delta_angle = dir * 2.0 * 72.0;
           }
           else {
-            // If we do this line, we are just trying to move further
-            // around the circle.
-            delta_angle = dir * (float) random(25, 45);
+            // Just move further along the perimeter.
+            delta_angle = dir * (float)random(25, 45);
           }
-
           angle += delta_angle;
-          while (angle > 360.0) angle -= 360.0; // We probably do not need to keep the angle between 0 and 2*PI, but the
-                                                // Arduino documentation says the trig functions should not be given values
-          while (angle < 0.0) angle += 360.0;   // outside of this range.   It looks like they behave correctly with
-                                                // numbers outside of the range, but just to be safe we clamp them.
 
-          const xy_pos_t noz_pos = probe_pos - probe.offset_xy;
-          next_pos.set(noz_pos.x + cos(RADIANS(angle)) * radius,
-                       noz_pos.y + sin(RADIANS(angle)) * radius);
+          // Trig functions work without clamping, but just to be safe...
+          while (angle > 360.0) angle -= 360.0;
+          while (angle < 0.0) angle += 360.0;
 
-          #if DISABLED(DELTA)
-            LIMIT(next_pos.x, X_MIN_POS, X_MAX_POS);
-            LIMIT(next_pos.y, Y_MIN_POS, Y_MAX_POS);
-          #else
-            // If we have gone out too far, we can do a simple fix and scale the numbers
-            // back in closer to the origin.
+          // Choose the next position as an offset to chosen test position
+          const xy_pos_t noz_pos = test_position - probe.offset_xy;
+          xy_pos_t next_pos = {
+            noz_pos.x + cos(RADIANS(angle)) * radius,
+            noz_pos.y + sin(RADIANS(angle)) * radius
+          };
+
+          #if ENABLED(DELTA)
+            // If the probe can't reach the point on a round bed...
+            // Simply scale the numbers to bring them closer to origin.
             while (!probe.can_reach(next_pos)) {
               next_pos *= 0.8f;
               if (verbose_level > 3)
                 SERIAL_ECHOLNPAIR_P(PSTR("Moving inward: X"), next_pos.x, SP_Y_STR, next_pos.y);
             }
+          #else
+            // For a rectangular bed just keep the probe in bounds
+            LIMIT(next_pos.x, X_MIN_POS, X_MAX_POS);
+            LIMIT(next_pos.y, Y_MIN_POS, Y_MAX_POS);
           #endif
 
           if (verbose_level > 3)
@@ -194,45 +218,35 @@ void GcodeSuite::M48() {
       } // n_legs
 
       // Probe a single point
-      sample_set[n] = probe.probe_at_point(probe_pos, raise_after, 0);
+      const float pz = probe.probe_at_point(test_position, raise_after, 0);
 
       // Break the loop if the probe fails
-      probing_good = !isnan(sample_set[n]);
+      probing_good = !isnan(pz);
       if (!probing_good) break;
 
-      /**
-       * Get the current mean for the data points we have so far
-       */
-      float sum = 0.0;
-      LOOP_LE_N(j, n) sum += sample_set[j];
-      mean = sum / (n + 1);
-
-      NOMORE(min, sample_set[n]);
-      NOLESS(max, sample_set[n]);
-
-      /**
-       * Now, use that mean to calculate the standard deviation for the
-       * data points we have so far
-       */
-      sum = 0.0;
-      LOOP_LE_N(j, n)
-        sum += sq(sample_set[j] - mean);
-
-      sigma = SQRT(sum / (n + 1));
-      if (verbose_level > 0) {
-        if (verbose_level > 1) {
-          SERIAL_ECHO(n + 1);
-          SERIAL_ECHOPAIR(" of ", int(n_samples));
-          SERIAL_ECHOPAIR_F(": z: ", sample_set[n], 3);
-          if (verbose_level > 2) {
-            SERIAL_ECHOPAIR_F(" mean: ", mean, 4);
-            SERIAL_ECHOPAIR_F(" sigma: ", sigma, 6);
-            SERIAL_ECHOPAIR_F(" min: ", min, 3);
-            SERIAL_ECHOPAIR_F(" max: ", max, 3);
-            SERIAL_ECHOPAIR_F(" range: ", max-min, 3);
-          }
-          SERIAL_EOL();
-        }
+      // Store the new sample
+      sample_set[n] = pz;
+
+      // Keep track of the largest and smallest samples
+      NOMORE(min, pz);
+      NOLESS(max, pz);
+
+      // Get the mean value of all samples thus far
+      sample_sum += pz;
+      mean = sample_sum / (n + 1);
+
+      // Calculate the standard deviation so far.
+      // The value after the last sample will be the final output.
+      float dev_sum = 0.0;
+      LOOP_LE_N(j, n) dev_sum += sq(sample_set[j] - mean);
+      sigma = SQRT(dev_sum / (n + 1));
+
+      if (verbose_level > 1) {
+        SERIAL_ECHO(n + 1);
+        SERIAL_ECHOPAIR(" of ", int(n_samples));
+        SERIAL_ECHOPAIR_F(": z: ", pz, 3);
+        dev_report(verbose_level > 2, mean, sigma, min, max);
+        SERIAL_EOL();
       }
 
     } // n_samples loop
@@ -242,16 +256,7 @@ void GcodeSuite::M48() {
 
   if (probing_good) {
     SERIAL_ECHOLNPGM("Finished!");
-
-    if (verbose_level > 0) {
-      SERIAL_ECHOPAIR_F("Mean: ", mean, 6);
-      SERIAL_ECHOPAIR_F(" Min: ", min, 3);
-      SERIAL_ECHOPAIR_F(" Max: ", max, 3);
-      SERIAL_ECHOLNPAIR_F(" Range: ", max-min, 3);
-    }
-
-    SERIAL_ECHOLNPAIR_F("Standard Deviation: ", sigma, 6);
-    SERIAL_EOL();
+    dev_report(verbose_level > 0, mean, sigma, min, max, true);
 
     #if HAS_SPI_LCD
       // Display M48 results in the status bar

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 175a4d4034..47c72eece7 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index c1e8b0e9f8..175a4d4034 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -263,9 +263,7 @@ void GcodeSuite::M48() {
   restore_feedrate_and_scaling();
 
   // Re-enable bed level correction if it had been on
-  #if HAS_LEVELING
-    set_bed_leveling_enabled(was_enabled);
-  #endif
+  TERN_(HAS_LEVELING, set_bed_leveling_enabled(was_enabled));
 
   report_current_position();
 }

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index fb86517799..c1e8b0e9f8 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -126,7 +126,7 @@ void GcodeSuite::M48() {
   if (probing_good) {
     randomSeed(millis());
 
-    for (uint8_t n = 0; n < n_samples; n++) {
+    LOOP_L_N(n, n_samples) {
       #if HAS_SPI_LCD
         // Display M48 progress in the status bar
         ui.status_printf_P(0, PSTR(S_FMT ": %d/%d"), GET_TEXT(MSG_M48_POINT), int(n + 1), int(n_samples));
@@ -149,7 +149,7 @@ void GcodeSuite::M48() {
           SERIAL_ECHOLNPGM("CW");
         }
 
-        for (uint8_t l = 0; l < n_legs - 1; l++) {
+        LOOP_L_N(l, n_legs - 1) {
           float delta_angle;
 
           if (schizoid_flag) {
@@ -204,7 +204,7 @@ void GcodeSuite::M48() {
        * Get the current mean for the data points we have so far
        */
       float sum = 0.0;
-      for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
+      LOOP_LE_N(j, n) sum += sample_set[j];
       mean = sum / (n + 1);
 
       NOMORE(min, sample_set[n]);
@@ -215,7 +215,7 @@ void GcodeSuite::M48() {
        * data points we have so far
        */
       sum = 0.0;
-      for (uint8_t j = 0; j <= n; j++)
+      LOOP_LE_N(j, n)
         sum += sq(sample_set[j] - mean);
 
       sigma = SQRT(sum / (n + 1));

commit be62ab2d02f58634013a78a2e243a50c1cd4a1c4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 27 06:16:33 2020 -0600

    Move reachable test to Probe class

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 8fba7a646f..fb86517799 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -80,11 +80,11 @@ void GcodeSuite::M48() {
   xy_float_t next_pos = current_position;
 
   const xy_pos_t probe_pos = {
-    parser.linearval('X', next_pos.x + probe.offset_xy.x),
-    parser.linearval('Y', next_pos.y + probe.offset_xy.y)
+    parser.linearval('X', next_pos.x + probe.offset_xy.x),  // If no X use the probe's current X position
+    parser.linearval('Y', next_pos.y + probe.offset_xy.y)   // If no Y, ditto
   };
 
-  if (!position_is_reachable_by_probe(probe_pos)) {
+  if (!probe.can_reach(probe_pos)) {
     SERIAL_ECHOLNPGM("? (X,Y) out of bounds.");
     return;
   }
@@ -179,7 +179,7 @@ void GcodeSuite::M48() {
           #else
             // If we have gone out too far, we can do a simple fix and scale the numbers
             // back in closer to the origin.
-            while (!position_is_reachable_by_probe(next_pos)) {
+            while (!probe.can_reach(next_pos)) {
               next_pos *= 0.8f;
               if (verbose_level > 3)
                 SERIAL_ECHOLNPAIR_P(PSTR("Moving inward: X"), next_pos.x, SP_Y_STR, next_pos.y);

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 707a37fc23..8fba7a646f 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit 90b6324563b806ea7dc24ddf299f055dc4854341
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 04:21:36 2020 -0600

    Encapsulate probe as singleton class (#16751)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 75c5ed9a81..707a37fc23 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -80,8 +80,8 @@ void GcodeSuite::M48() {
   xy_float_t next_pos = current_position;
 
   const xy_pos_t probe_pos = {
-    parser.linearval('X', next_pos.x + probe_offset_xy.x),
-    parser.linearval('Y', next_pos.y + probe_offset_xy.y)
+    parser.linearval('X', next_pos.x + probe.offset_xy.x),
+    parser.linearval('Y', next_pos.y + probe.offset_xy.y)
   };
 
   if (!position_is_reachable_by_probe(probe_pos)) {
@@ -120,7 +120,7 @@ void GcodeSuite::M48() {
   float mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
 
   // Move to the first point, deploy, and probe
-  const float t = probe_at_point(probe_pos, raise_after, verbose_level);
+  const float t = probe.probe_at_point(probe_pos, raise_after, verbose_level);
   bool probing_good = !isnan(t);
 
   if (probing_good) {
@@ -169,7 +169,7 @@ void GcodeSuite::M48() {
           while (angle < 0.0) angle += 360.0;   // outside of this range.   It looks like they behave correctly with
                                                 // numbers outside of the range, but just to be safe we clamp them.
 
-          const xy_pos_t noz_pos = probe_pos - probe_offset_xy;
+          const xy_pos_t noz_pos = probe_pos - probe.offset_xy;
           next_pos.set(noz_pos.x + cos(RADIANS(angle)) * radius,
                        noz_pos.y + sin(RADIANS(angle)) * radius);
 
@@ -194,7 +194,7 @@ void GcodeSuite::M48() {
       } // n_legs
 
       // Probe a single point
-      sample_set[n] = probe_at_point(probe_pos, raise_after, 0);
+      sample_set[n] = probe.probe_at_point(probe_pos, raise_after, 0);
 
       // Break the loop if the probe fails
       probing_good = !isnan(sample_set[n]);
@@ -238,7 +238,7 @@ void GcodeSuite::M48() {
     } // n_samples loop
   }
 
-  STOW_PROBE();
+  probe.stow();
 
   if (probing_good) {
     SERIAL_ECHOLNPGM("Finished!");

commit e6a675e6ecaccb5b897bb7c6e4bcf3bf48bfbf6d
Author: Radek Pietruszewski <radexpl@gmail.com>
Date:   Thu Jan 30 10:13:32 2020 +0100

    Fix missing string for M48 build (#16708)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index f111de4b17..75c5ed9a81 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -53,6 +53,9 @@
  *
  * This function requires the machine to be homed before invocation.
  */
+
+extern const char SP_Y_STR[];
+
 void GcodeSuite::M48() {
 
   if (axis_unhomed_error()) return;

commit 3cade6245e851af9a33d1f395758b898c4a06a30
Author: Jason Smith <jason.inet@gmail.com>
Date:   Fri Jan 3 17:46:26 2020 -0600

    Fix MIN_PROBE_EDGE bug in default ABL G29 (#16367)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 86b25d8240..f111de4b17 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -77,8 +77,8 @@ void GcodeSuite::M48() {
   xy_float_t next_pos = current_position;
 
   const xy_pos_t probe_pos = {
-    parser.linearval('X', next_pos.x + probe_offset.x),
-    parser.linearval('Y', next_pos.y + probe_offset.y)
+    parser.linearval('X', next_pos.x + probe_offset_xy.x),
+    parser.linearval('Y', next_pos.y + probe_offset_xy.y)
   };
 
   if (!position_is_reachable_by_probe(probe_pos)) {
@@ -166,8 +166,9 @@ void GcodeSuite::M48() {
           while (angle < 0.0) angle += 360.0;   // outside of this range.   It looks like they behave correctly with
                                                 // numbers outside of the range, but just to be safe we clamp them.
 
-          next_pos.set(probe_pos.x - probe_offset.x + cos(RADIANS(angle)) * radius,
-                       probe_pos.y - probe_offset.y + sin(RADIANS(angle)) * radius);
+          const xy_pos_t noz_pos = probe_pos - probe_offset_xy;
+          next_pos.set(noz_pos.x + cos(RADIANS(angle)) * radius,
+                       noz_pos.y + sin(RADIANS(angle)) * radius);
 
           #if DISABLED(DELTA)
             LIMIT(next_pos.x, X_MIN_POS, X_MAX_POS);

commit f83bc0aa13e8cf2d92ec138576cc3a620e74a982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 29 04:45:07 2019 -0600

    Optimize common strings
    
    Saves 128 bytes in testing with `mftest mega 1 -y`

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index ca30110670..86b25d8240 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -178,12 +178,12 @@ void GcodeSuite::M48() {
             while (!position_is_reachable_by_probe(next_pos)) {
               next_pos *= 0.8f;
               if (verbose_level > 3)
-                SERIAL_ECHOLNPAIR("Moving inward: X", next_pos.x, " Y", next_pos.y);
+                SERIAL_ECHOLNPAIR_P(PSTR("Moving inward: X"), next_pos.x, SP_Y_STR, next_pos.y);
             }
           #endif
 
           if (verbose_level > 3)
-            SERIAL_ECHOLNPAIR("Going to: X", next_pos.x, " Y", next_pos.y);
+            SERIAL_ECHOLNPAIR_P(PSTR("Going to: X"), next_pos.x, SP_Y_STR, next_pos.y);
 
           do_blocking_move_to_xy(next_pos);
         } // n_legs loop

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 8a12767224..ca30110670 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -126,7 +126,7 @@ void GcodeSuite::M48() {
     for (uint8_t n = 0; n < n_samples; n++) {
       #if HAS_SPI_LCD
         // Display M48 progress in the status bar
-        ui.status_printf_P(0, PSTR(MSG_M48_POINT ": %d/%d"), int(n + 1), int(n_samples));
+        ui.status_printf_P(0, PSTR(S_FMT ": %d/%d"), GET_TEXT(MSG_M48_POINT), int(n + 1), int(n_samples));
       #endif
       if (n_legs) {
         const int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
@@ -252,7 +252,7 @@ void GcodeSuite::M48() {
     #if HAS_SPI_LCD
       // Display M48 results in the status bar
       char sigma_str[8];
-      ui.status_printf_P(0, PSTR(MSG_M48_DEVIATION ": %s"), dtostrf(sigma, 2, 6, sigma_str));
+      ui.status_printf_P(0, PSTR(S_FMT ": %s"), GET_TEXT(MSG_M48_DEVIATION), dtostrf(sigma, 2, 6, sigma_str));
     #endif
   }
 

commit f307ff68f766ef4e01b55bc4ded16c878f1d3abf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 29 17:24:55 2019 -0500

    Multiply by float, not double

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index d8fe4e4104..8a12767224 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -176,7 +176,7 @@ void GcodeSuite::M48() {
             // If we have gone out too far, we can do a simple fix and scale the numbers
             // back in closer to the origin.
             while (!position_is_reachable_by_probe(next_pos)) {
-              next_pos *= 0.8;
+              next_pos *= 0.8f;
               if (verbose_level > 3)
                 SERIAL_ECHOLNPAIR("Moving inward: X", next_pos.x, " Y", next_pos.y);
             }

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 49fc9982dc..d8fe4e4104 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -74,13 +74,14 @@ void GcodeSuite::M48() {
 
   const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
 
-  float X_current = current_position[X_AXIS],
-        Y_current = current_position[Y_AXIS];
+  xy_float_t next_pos = current_position;
 
-  const float X_probe_location = parser.linearval('X', X_current + probe_offset[X_AXIS]),
-              Y_probe_location = parser.linearval('Y', Y_current + probe_offset[Y_AXIS]);
+  const xy_pos_t probe_pos = {
+    parser.linearval('X', next_pos.x + probe_offset.x),
+    parser.linearval('Y', next_pos.y + probe_offset.y)
+  };
 
-  if (!position_is_reachable_by_probe(X_probe_location, Y_probe_location)) {
+  if (!position_is_reachable_by_probe(probe_pos)) {
     SERIAL_ECHOLNPGM("? (X,Y) out of bounds.");
     return;
   }
@@ -116,7 +117,7 @@ void GcodeSuite::M48() {
   float mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
 
   // Move to the first point, deploy, and probe
-  const float t = probe_at_point(X_probe_location, Y_probe_location, raise_after, verbose_level);
+  const float t = probe_at_point(probe_pos, raise_after, verbose_level);
   bool probing_good = !isnan(t);
 
   if (probing_good) {
@@ -165,32 +166,31 @@ void GcodeSuite::M48() {
           while (angle < 0.0) angle += 360.0;   // outside of this range.   It looks like they behave correctly with
                                                 // numbers outside of the range, but just to be safe we clamp them.
 
-          X_current = X_probe_location - probe_offset[X_AXIS] + cos(RADIANS(angle)) * radius;
-          Y_current = Y_probe_location - probe_offset[Y_AXIS] + sin(RADIANS(angle)) * radius;
+          next_pos.set(probe_pos.x - probe_offset.x + cos(RADIANS(angle)) * radius,
+                       probe_pos.y - probe_offset.y + sin(RADIANS(angle)) * radius);
 
           #if DISABLED(DELTA)
-            LIMIT(X_current, X_MIN_POS, X_MAX_POS);
-            LIMIT(Y_current, Y_MIN_POS, Y_MAX_POS);
+            LIMIT(next_pos.x, X_MIN_POS, X_MAX_POS);
+            LIMIT(next_pos.y, Y_MIN_POS, Y_MAX_POS);
           #else
             // If we have gone out too far, we can do a simple fix and scale the numbers
             // back in closer to the origin.
-            while (!position_is_reachable_by_probe(X_current, Y_current)) {
-              X_current *= 0.8;
-              Y_current *= 0.8;
+            while (!position_is_reachable_by_probe(next_pos)) {
+              next_pos *= 0.8;
               if (verbose_level > 3)
-                SERIAL_ECHOLNPAIR("Moving inward: X", X_current, " Y", Y_current);
+                SERIAL_ECHOLNPAIR("Moving inward: X", next_pos.x, " Y", next_pos.y);
             }
           #endif
 
           if (verbose_level > 3)
-            SERIAL_ECHOLNPAIR("Going to: X", X_current, " Y", Y_current, " Z", current_position[Z_AXIS]);
+            SERIAL_ECHOLNPAIR("Going to: X", next_pos.x, " Y", next_pos.y);
 
-          do_blocking_move_to_xy(X_current, Y_current);
+          do_blocking_move_to_xy(next_pos);
         } // n_legs loop
       } // n_legs
 
       // Probe a single point
-      sample_set[n] = probe_at_point(X_probe_location, Y_probe_location, raise_after, 0);
+      sample_set[n] = probe_at_point(probe_pos, raise_after, 0);
 
       // Break the loop if the probe fails
       probing_good = !isnan(sample_set[n]);

commit 4e8d9fe59b53fc5937d907fcf6d79b58233ab6ef
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 24 23:35:49 2019 -0500

    zprobe_offset => probe_offset

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index e9bdd2abeb..49fc9982dc 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -77,8 +77,8 @@ void GcodeSuite::M48() {
   float X_current = current_position[X_AXIS],
         Y_current = current_position[Y_AXIS];
 
-  const float X_probe_location = parser.linearval('X', X_current + zprobe_offset[X_AXIS]),
-              Y_probe_location = parser.linearval('Y', Y_current + zprobe_offset[Y_AXIS]);
+  const float X_probe_location = parser.linearval('X', X_current + probe_offset[X_AXIS]),
+              Y_probe_location = parser.linearval('Y', Y_current + probe_offset[Y_AXIS]);
 
   if (!position_is_reachable_by_probe(X_probe_location, Y_probe_location)) {
     SERIAL_ECHOLNPGM("? (X,Y) out of bounds.");
@@ -165,8 +165,8 @@ void GcodeSuite::M48() {
           while (angle < 0.0) angle += 360.0;   // outside of this range.   It looks like they behave correctly with
                                                 // numbers outside of the range, but just to be safe we clamp them.
 
-          X_current = X_probe_location - zprobe_offset[X_AXIS] + cos(RADIANS(angle)) * radius;
-          Y_current = Y_probe_location - zprobe_offset[Y_AXIS] + sin(RADIANS(angle)) * radius;
+          X_current = X_probe_location - probe_offset[X_AXIS] + cos(RADIANS(angle)) * radius;
+          Y_current = Y_probe_location - probe_offset[Y_AXIS] + sin(RADIANS(angle)) * radius;
 
           #if DISABLED(DELTA)
             LIMIT(X_current, X_MIN_POS, X_MAX_POS);

commit df1e51258a8bcc432deed9f5bd60df41a75b2c32
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Sep 24 22:29:21 2019 -0400

    Add M851 X Y probe offsets (#15202)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 4557a94162..e9bdd2abeb 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -77,8 +77,8 @@ void GcodeSuite::M48() {
   float X_current = current_position[X_AXIS],
         Y_current = current_position[Y_AXIS];
 
-  const float X_probe_location = parser.linearval('X', X_current + X_PROBE_OFFSET_FROM_EXTRUDER),
-              Y_probe_location = parser.linearval('Y', Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER);
+  const float X_probe_location = parser.linearval('X', X_current + zprobe_offset[X_AXIS]),
+              Y_probe_location = parser.linearval('Y', Y_current + zprobe_offset[Y_AXIS]);
 
   if (!position_is_reachable_by_probe(X_probe_location, Y_probe_location)) {
     SERIAL_ECHOLNPGM("? (X,Y) out of bounds.");
@@ -165,8 +165,8 @@ void GcodeSuite::M48() {
           while (angle < 0.0) angle += 360.0;   // outside of this range.   It looks like they behave correctly with
                                                 // numbers outside of the range, but just to be safe we clamp them.
 
-          X_current = X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER) + cos(RADIANS(angle)) * radius;
-          Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;
+          X_current = X_probe_location - zprobe_offset[X_AXIS] + cos(RADIANS(angle)) * radius;
+          Y_current = Y_probe_location - zprobe_offset[Y_AXIS] + sin(RADIANS(angle)) * radius;
 
           #if DISABLED(DELTA)
             LIMIT(X_current, X_MIN_POS, X_MAX_POS);

commit 5e13fe989f21bcbd4da1a567953dab8a18f96e11
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 23 20:58:01 2019 -0500

    Rename some feedrate-oriented functions

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index dd0039e9b2..4557a94162 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -111,7 +111,7 @@ void GcodeSuite::M48() {
     set_bed_leveling_enabled(false);
   #endif
 
-  setup_for_endstop_or_probe_move();
+  remember_feedrate_scaling_off();
 
   float mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
 
@@ -256,7 +256,7 @@ void GcodeSuite::M48() {
     #endif
   }
 
-  clean_up_after_endstop_or_probe_move();
+  restore_feedrate_and_scaling();
 
   // Re-enable bed level correction if it had been on
   #if HAS_LEVELING

commit c353eaa14630eb9d74f185e2b6aae1630ca21525
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 17 18:16:28 2019 -0500

    Misc changes from struct refactor (#15289)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 49b43eae73..dd0039e9b2 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -116,7 +116,7 @@ void GcodeSuite::M48() {
   float mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
 
   // Move to the first point, deploy, and probe
-  const float t = probe_pt(X_probe_location, Y_probe_location, raise_after, verbose_level);
+  const float t = probe_at_point(X_probe_location, Y_probe_location, raise_after, verbose_level);
   bool probing_good = !isnan(t);
 
   if (probing_good) {
@@ -190,7 +190,7 @@ void GcodeSuite::M48() {
       } // n_legs
 
       // Probe a single point
-      sample_set[n] = probe_pt(X_probe_location, Y_probe_location, raise_after, 0);
+      sample_set[n] = probe_at_point(X_probe_location, Y_probe_location, raise_after, 0);
 
       // Break the loop if the probe fails
       probing_good = !isnan(sample_set[n]);

commit f9992c5f33d954da1a70a03acf8b58d86def601b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 11 02:46:52 2019 -0500

    Implausible

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 2b5edb0919..49b43eae73 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -59,7 +59,7 @@ void GcodeSuite::M48() {
 
   const int8_t verbose_level = parser.byteval('V', 1);
   if (!WITHIN(verbose_level, 0, 4)) {
-    SERIAL_ECHOLNPGM("?(V)erbose level is implausible (0-4).");
+    SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-4).");
     return;
   }
 

commit c8e30b663973be40855b46560616edd916477bb2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 8 01:51:37 2019 -0500

    Fix code attempting to sprintf %f (#14869)
    
    Arduino doesn't (always) support `float` formatting in strings. So either cast to `int` or use `dtostrf()` to fix these usages.

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 5201e7c10c..2b5edb0919 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -252,8 +252,7 @@ void GcodeSuite::M48() {
     #if HAS_SPI_LCD
       // Display M48 results in the status bar
       char sigma_str[8];
-      dtostrf(sigma, 2, 6, sigma_str);
-      ui.status_printf_P(0, PSTR(MSG_M48_DEVIATION ": %s"), sigma_str);
+      ui.status_printf_P(0, PSTR(MSG_M48_DEVIATION ": %s"), dtostrf(sigma, 2, 6, sigma_str));
     #endif
   }
 

commit 4af9908764d3629d8abec0ad8a72f8939ab2e0ac
Author: Acenotass <44540957+Acenotass@users.noreply.github.com>
Date:   Tue Aug 6 07:01:40 2019 +0600

    Update M48 command in the status line (#14816)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 1746543cf2..5201e7c10c 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -123,45 +123,47 @@ void GcodeSuite::M48() {
     randomSeed(millis());
 
     for (uint8_t n = 0; n < n_samples; n++) {
+      #if HAS_SPI_LCD
+        // Display M48 progress in the status bar
+        ui.status_printf_P(0, PSTR(MSG_M48_POINT ": %d/%d"), int(n + 1), int(n_samples));
+      #endif
       if (n_legs) {
         const int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
         float angle = random(0, 360);
         const float radius = random(
           #if ENABLED(DELTA)
-            (int) (0.1250000000 * (DELTA_PRINTABLE_RADIUS)),
-            (int) (0.3333333333 * (DELTA_PRINTABLE_RADIUS))
+            int(0.1250000000 * (DELTA_PRINTABLE_RADIUS)),
+            int(0.3333333333 * (DELTA_PRINTABLE_RADIUS))
           #else
-            (int) 5.0, (int) (0.125 * _MIN(X_BED_SIZE, Y_BED_SIZE))
+            int(5), int(0.125 * _MIN(X_BED_SIZE, Y_BED_SIZE))
           #endif
         );
 
         if (verbose_level > 3) {
-          SERIAL_ECHOPAIR("Starting radius: ", radius);
-          SERIAL_ECHOPAIR("   angle: ", angle);
-          SERIAL_ECHOPGM(" Direction: ");
-          if (dir > 0) SERIAL_ECHOPGM("Counter-");
-          SERIAL_ECHOLNPGM("Clockwise");
+          SERIAL_ECHOPAIR("Start radius:", radius, " angle:", angle, " dir:");
+          if (dir > 0) SERIAL_CHAR('C');
+          SERIAL_ECHOLNPGM("CW");
         }
 
         for (uint8_t l = 0; l < n_legs - 1; l++) {
           float delta_angle;
 
-          if (schizoid_flag)
+          if (schizoid_flag) {
             // The points of a 5 point star are 72 degrees apart.  We need to
             // skip a point and go to the next one on the star.
             delta_angle = dir * 2.0 * 72.0;
-
-          else
+          }
+          else {
             // If we do this line, we are just trying to move further
             // around the circle.
             delta_angle = dir * (float) random(25, 45);
+          }
 
           angle += delta_angle;
-
-          while (angle > 360.0)   // We probably do not need to keep the angle between 0 and 2*PI, but the
-            angle -= 360.0;       // Arduino documentation says the trig functions should not be given values
-          while (angle < 0.0)     // outside of this range.   It looks like they behave correctly with
-            angle += 360.0;       // numbers outside of the range, but just to be safe we clamp them.
+          while (angle > 360.0) angle -= 360.0; // We probably do not need to keep the angle between 0 and 2*PI, but the
+                                                // Arduino documentation says the trig functions should not be given values
+          while (angle < 0.0) angle += 360.0;   // outside of this range.   It looks like they behave correctly with
+                                                // numbers outside of the range, but just to be safe we clamp them.
 
           X_current = X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER) + cos(RADIANS(angle)) * radius;
           Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;
@@ -175,18 +177,14 @@ void GcodeSuite::M48() {
             while (!position_is_reachable_by_probe(X_current, Y_current)) {
               X_current *= 0.8;
               Y_current *= 0.8;
-              if (verbose_level > 3) {
-                SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
-                SERIAL_ECHOLNPAIR(", ", Y_current);
-              }
+              if (verbose_level > 3)
+                SERIAL_ECHOLNPAIR("Moving inward: X", X_current, " Y", Y_current);
             }
           #endif
-          if (verbose_level > 3) {
-            SERIAL_ECHOPGM("Going to:");
-            SERIAL_ECHOPAIR(" X", X_current);
-            SERIAL_ECHOPAIR(" Y", Y_current);
-            SERIAL_ECHOLNPAIR(" Z", current_position[Z_AXIS]);
-          }
+
+          if (verbose_level > 3)
+            SERIAL_ECHOLNPAIR("Going to: X", X_current, " Y", Y_current, " Z", current_position[Z_AXIS]);
+
           do_blocking_move_to_xy(X_current, Y_current);
         } // n_legs loop
       } // n_legs
@@ -220,7 +218,7 @@ void GcodeSuite::M48() {
       if (verbose_level > 0) {
         if (verbose_level > 1) {
           SERIAL_ECHO(n + 1);
-          SERIAL_ECHOPAIR(" of ", (int)n_samples);
+          SERIAL_ECHOPAIR(" of ", int(n_samples));
           SERIAL_ECHOPAIR_F(": z: ", sample_set[n], 3);
           if (verbose_level > 2) {
             SERIAL_ECHOPAIR_F(" mean: ", mean, 4);

commit 659d06d9b9c38c62e91a91254f41306edf840d87
Author: Acenotass <44540957+Acenotass@users.noreply.github.com>
Date:   Tue Jul 30 13:31:14 2019 +0600

    M48 menu item, result to status (#14772)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index ca54ae8f9c..1746543cf2 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -30,6 +30,10 @@
 
 #include "../../feature/bedlevel/bedlevel.h"
 
+#if HAS_SPI_LCD
+  #include "../../lcd/ultralcd.h"
+#endif
+
 #if HAS_LEVELING
   #include "../../module/planner.h"
 #endif
@@ -246,6 +250,13 @@ void GcodeSuite::M48() {
 
     SERIAL_ECHOLNPAIR_F("Standard Deviation: ", sigma, 6);
     SERIAL_EOL();
+
+    #if HAS_SPI_LCD
+      // Display M48 results in the status bar
+      char sigma_str[8];
+      dtostrf(sigma, 2, 6, sigma_str);
+      ui.status_printf_P(0, PSTR(MSG_M48_DEVIATION ": %s"), sigma_str);
+    #endif
   }
 
   clean_up_after_endstop_or_probe_move();

commit ed0e6afacbbd5ef8836166feccbd4b50fc9da009
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 10 03:33:28 2019 -0500

    Apply LIMIT macro

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 9f0fc714d6..ca54ae8f9c 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -163,8 +163,8 @@ void GcodeSuite::M48() {
           Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;
 
           #if DISABLED(DELTA)
-            X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
-            Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
+            LIMIT(X_current, X_MIN_POS, X_MAX_POS);
+            LIMIT(Y_current, Y_MIN_POS, Y_MAX_POS);
           #else
             // If we have gone out too far, we can do a simple fix and scale the numbers
             // back in closer to the origin.

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 6e9ccf1ed8..9f0fc714d6 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -127,7 +127,7 @@ void GcodeSuite::M48() {
             (int) (0.1250000000 * (DELTA_PRINTABLE_RADIUS)),
             (int) (0.3333333333 * (DELTA_PRINTABLE_RADIUS))
           #else
-            (int) 5.0, (int) (0.125 * MIN(X_BED_SIZE, Y_BED_SIZE))
+            (int) 5.0, (int) (0.125 * _MIN(X_BED_SIZE, Y_BED_SIZE))
           #endif
         );
 

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index d17b2df3fd..6e9ccf1ed8 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 243949e22b..d17b2df3fd 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 098d626f5e..243949e22b 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -55,16 +55,16 @@ void GcodeSuite::M48() {
 
   const int8_t verbose_level = parser.byteval('V', 1);
   if (!WITHIN(verbose_level, 0, 4)) {
-    SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
+    SERIAL_ECHOLNPGM("?(V)erbose level is implausible (0-4).");
     return;
   }
 
   if (verbose_level > 0)
-    SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability Test");
+    SERIAL_ECHOLNPGM("M48 Z-Probe Repeatability Test");
 
   const int8_t n_samples = parser.byteval('P', 10);
   if (!WITHIN(n_samples, 4, 50)) {
-    SERIAL_PROTOCOLLNPGM("?Sample size not plausible (4-50).");
+    SERIAL_ECHOLNPGM("?Sample size not plausible (4-50).");
     return;
   }
 
@@ -77,14 +77,14 @@ void GcodeSuite::M48() {
               Y_probe_location = parser.linearval('Y', Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER);
 
   if (!position_is_reachable_by_probe(X_probe_location, Y_probe_location)) {
-    SERIAL_PROTOCOLLNPGM("? (X,Y) out of bounds.");
+    SERIAL_ECHOLNPGM("? (X,Y) out of bounds.");
     return;
   }
 
   bool seen_L = parser.seen('L');
   uint8_t n_legs = seen_L ? parser.value_byte() : 0;
   if (n_legs > 15) {
-    SERIAL_PROTOCOLLNPGM("?Number of legs in movement not plausible (0-15).");
+    SERIAL_ECHOLNPGM("?Number of legs in movement not plausible (0-15).");
     return;
   }
   if (n_legs == 1) n_legs = 2;
@@ -98,7 +98,7 @@ void GcodeSuite::M48() {
    * we don't want to use that as a starting point for each probe.
    */
   if (verbose_level > 2)
-    SERIAL_PROTOCOLLNPGM("Positioning the probe...");
+    SERIAL_ECHOLNPGM("Positioning the probe...");
 
   // Disable bed level correction in M48 because we want the raw data when we probe
 
@@ -178,7 +178,7 @@ void GcodeSuite::M48() {
             }
           #endif
           if (verbose_level > 3) {
-            SERIAL_PROTOCOLPGM("Going to:");
+            SERIAL_ECHOPGM("Going to:");
             SERIAL_ECHOPAIR(" X", X_current);
             SERIAL_ECHOPAIR(" Y", Y_current);
             SERIAL_ECHOLNPAIR(" Z", current_position[Z_AXIS]);
@@ -215,22 +215,15 @@ void GcodeSuite::M48() {
       sigma = SQRT(sum / (n + 1));
       if (verbose_level > 0) {
         if (verbose_level > 1) {
-          SERIAL_PROTOCOL(n + 1);
-          SERIAL_PROTOCOLPGM(" of ");
-          SERIAL_PROTOCOL((int)n_samples);
-          SERIAL_PROTOCOLPGM(": z: ");
-          SERIAL_PROTOCOL_F(sample_set[n], 3);
+          SERIAL_ECHO(n + 1);
+          SERIAL_ECHOPAIR(" of ", (int)n_samples);
+          SERIAL_ECHOPAIR_F(": z: ", sample_set[n], 3);
           if (verbose_level > 2) {
-            SERIAL_PROTOCOLPGM(" mean: ");
-            SERIAL_PROTOCOL_F(mean, 4);
-            SERIAL_PROTOCOLPGM(" sigma: ");
-            SERIAL_PROTOCOL_F(sigma, 6);
-            SERIAL_PROTOCOLPGM(" min: ");
-            SERIAL_PROTOCOL_F(min, 3);
-            SERIAL_PROTOCOLPGM(" max: ");
-            SERIAL_PROTOCOL_F(max, 3);
-            SERIAL_PROTOCOLPGM(" range: ");
-            SERIAL_PROTOCOL_F(max-min, 3);
+            SERIAL_ECHOPAIR_F(" mean: ", mean, 4);
+            SERIAL_ECHOPAIR_F(" sigma: ", sigma, 6);
+            SERIAL_ECHOPAIR_F(" min: ", min, 3);
+            SERIAL_ECHOPAIR_F(" max: ", max, 3);
+            SERIAL_ECHOPAIR_F(" range: ", max-min, 3);
           }
           SERIAL_EOL();
         }
@@ -242,23 +235,16 @@ void GcodeSuite::M48() {
   STOW_PROBE();
 
   if (probing_good) {
-    SERIAL_PROTOCOLLNPGM("Finished!");
+    SERIAL_ECHOLNPGM("Finished!");
 
     if (verbose_level > 0) {
-      SERIAL_PROTOCOLPGM("Mean: ");
-      SERIAL_PROTOCOL_F(mean, 6);
-      SERIAL_PROTOCOLPGM(" Min: ");
-      SERIAL_PROTOCOL_F(min, 3);
-      SERIAL_PROTOCOLPGM(" Max: ");
-      SERIAL_PROTOCOL_F(max, 3);
-      SERIAL_PROTOCOLPGM(" Range: ");
-      SERIAL_PROTOCOL_F(max-min, 3);
-      SERIAL_EOL();
+      SERIAL_ECHOPAIR_F("Mean: ", mean, 6);
+      SERIAL_ECHOPAIR_F(" Min: ", min, 3);
+      SERIAL_ECHOPAIR_F(" Max: ", max, 3);
+      SERIAL_ECHOLNPAIR_F(" Range: ", max-min, 3);
     }
 
-    SERIAL_PROTOCOLPGM("Standard Deviation: ");
-    SERIAL_PROTOCOL_F(sigma, 6);
-    SERIAL_EOL();
+    SERIAL_ECHOLNPAIR_F("Standard Deviation: ", sigma, 6);
     SERIAL_EOL();
   }
 

commit 5f6aabccbe7b2df3cfdc9381a41fd8a831ead204
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 8 18:18:08 2018 -0500

    Tweak M48 spacing

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index dd646961f7..098d626f5e 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -28,10 +28,8 @@
 #include "../../module/motion.h"
 #include "../../module/probe.h"
 
-
 #include "../../feature/bedlevel/bedlevel.h"
 
-
 #if HAS_LEVELING
   #include "../../module/planner.h"
 #endif

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 3b5a18bbdd..dd646961f7 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -111,7 +111,7 @@ void GcodeSuite::M48() {
 
   setup_for_endstop_or_probe_move();
 
-  double mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
+  float mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
 
   // Move to the first point, deploy, and probe
   const float t = probe_pt(X_probe_location, Y_probe_location, raise_after, verbose_level);
@@ -142,7 +142,7 @@ void GcodeSuite::M48() {
         }
 
         for (uint8_t l = 0; l < n_legs - 1; l++) {
-          double delta_angle;
+          float delta_angle;
 
           if (schizoid_flag)
             // The points of a 5 point star are 72 degrees apart.  We need to
@@ -199,7 +199,7 @@ void GcodeSuite::M48() {
       /**
        * Get the current mean for the data points we have so far
        */
-      double sum = 0.0;
+      float sum = 0.0;
       for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
       mean = sum / (n + 1);
 

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 14efec5e00..3b5a18bbdd 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -129,7 +129,7 @@ void GcodeSuite::M48() {
             (int) (0.1250000000 * (DELTA_PRINTABLE_RADIUS)),
             (int) (0.3333333333 * (DELTA_PRINTABLE_RADIUS))
           #else
-            (int) 5.0, (int) (0.125 * min(X_BED_SIZE, Y_BED_SIZE))
+            (int) 5.0, (int) (0.125 * MIN(X_BED_SIZE, Y_BED_SIZE))
           #endif
         );
 

commit c352954882bc931377ece338b3f5fa459c55ea07
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 21 01:01:43 2018 -0500

    Allow no raise after run_z_probe in probe_pt

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index cc82a7fe33..14efec5e00 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -70,7 +70,7 @@ void GcodeSuite::M48() {
     return;
   }
 
-  const bool stow_probe_after_each = parser.boolval('E');
+  const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
 
   float X_current = current_position[X_AXIS],
         Y_current = current_position[Y_AXIS];
@@ -114,7 +114,7 @@ void GcodeSuite::M48() {
   double mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
 
   // Move to the first point, deploy, and probe
-  const float t = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);
+  const float t = probe_pt(X_probe_location, Y_probe_location, raise_after, verbose_level);
   bool probing_good = !isnan(t);
 
   if (probing_good) {
@@ -190,7 +190,7 @@ void GcodeSuite::M48() {
       } // n_legs
 
       // Probe a single point
-      sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, 0);
+      sample_set[n] = probe_pt(X_probe_location, Y_probe_location, raise_after, 0);
 
       // Break the loop if the probe fails
       probing_good = !isnan(sample_set[n]);

commit 14c03cb6f4bf20b06ba5d6c849cd1a15341627df
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 13 01:15:22 2018 -0500

    [2.0.x] Make MIN_PROBE_EDGE a general option (for electronic probes) (#10069)
    
    Some probes don't work near the edges of the bed. This change promotes MIN_PROBE_EDGE to a general setting that applies to all probing functions.

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 763b041848..cc82a7fe33 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -78,21 +78,10 @@ void GcodeSuite::M48() {
   const float X_probe_location = parser.linearval('X', X_current + X_PROBE_OFFSET_FROM_EXTRUDER),
               Y_probe_location = parser.linearval('Y', Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER);
 
-  #if DISABLED(DELTA)
-    if (!WITHIN(X_probe_location, MIN_PROBE_X, MAX_PROBE_X)) {
-      out_of_range_error(PSTR("X"));
-      return;
-    }
-    if (!WITHIN(Y_probe_location, MIN_PROBE_Y, MAX_PROBE_Y)) {
-      out_of_range_error(PSTR("Y"));
-      return;
-    }
-  #else
-    if (!position_is_reachable_by_probe(X_probe_location, Y_probe_location)) {
-      SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
-      return;
-    }
-  #endif
+  if (!position_is_reachable_by_probe(X_probe_location, Y_probe_location)) {
+    SERIAL_PROTOCOLLNPGM("? (X,Y) out of bounds.");
+    return;
+  }
 
   bool seen_L = parser.seen('L');
   uint8_t n_legs = seen_L ? parser.value_byte() : 0;
@@ -137,8 +126,8 @@ void GcodeSuite::M48() {
         float angle = random(0, 360);
         const float radius = random(
           #if ENABLED(DELTA)
-            (int) (0.1250000000 * (DELTA_PROBEABLE_RADIUS)),
-            (int) (0.3333333333 * (DELTA_PROBEABLE_RADIUS))
+            (int) (0.1250000000 * (DELTA_PRINTABLE_RADIUS)),
+            (int) (0.3333333333 * (DELTA_PRINTABLE_RADIUS))
           #else
             (int) 5.0, (int) (0.125 * min(X_BED_SIZE, Y_BED_SIZE))
           #endif

commit 133b38b93b0a83e2601c93a47a51f97783921f71
Author: AnHardt <github@kitelab.de>
Date:   Wed Feb 14 12:17:58 2018 +0100

    Complete M48 description (#9631)

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 766d3fb91e..763b041848 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -40,7 +40,7 @@
  * M48: Z probe repeatability measurement function.
  *
  * Usage:
- *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
+ *   M48 <P#> <X#> <Y#> <V#> <E> <L#> <S>
  *     P = Number of sampled points (4-50, default 10)
  *     X = Sample X position
  *     Y = Sample Y position

commit a6160916b0a23f8ccac731380ce81554c94bab7c
Author: Colten Edwards <cd.edwards@sasktel.net>
Date:   Tue Nov 7 15:36:33 2017 -0600

    [2.0] Fix M48 for delta printers/ABL compile issue (#8286)
    
    * fix M48 for delta printers
    
    fix M48 for delta printers. home printer if not already homed.
    
    * remove ENABLED(DELTA)
    
    remove ENABLED(DELTA) as it is not needed.
    
    * Update M48.cpp
    
    * abl needs queue.h
    
    without queue.h abl will not compile since there is a script that runs at the end of it and we need to queue it up.

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index df9b01b7ae..766d3fb91e 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -28,9 +28,9 @@
 #include "../../module/motion.h"
 #include "../../module/probe.h"
 
-#if DISABLED(DELTA)
-  #include "../../feature/bedlevel/bedlevel.h"
-#endif
+
+#include "../../feature/bedlevel/bedlevel.h"
+
 
 #if HAS_LEVELING
   #include "../../module/planner.h"
@@ -49,10 +49,7 @@
  *     L = Number of legs of movement before probe
  *     S = Schizoid (Or Star if you prefer)
  *
- * This function assumes the bed has been homed.  Specifically, that a G28 command
- * as been issued prior to invoking the M48 Z probe repeatability measurement function.
- * Any information generated by a prior G29 Bed leveling command will be lost and need to be
- * regenerated.
+ * This function requires the machine to be homed before invocation.
  */
 void GcodeSuite::M48() {
 

commit f8393a09086f01eafbb8563411da3b237c96b982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 2 23:59:42 2017 -0500

    Operate in Native Machine Space

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index ced53d47ed..df9b01b7ae 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -82,16 +82,16 @@ void GcodeSuite::M48() {
               Y_probe_location = parser.linearval('Y', Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER);
 
   #if DISABLED(DELTA)
-    if (!WITHIN(X_probe_location, LOGICAL_X_POSITION(MIN_PROBE_X), LOGICAL_X_POSITION(MAX_PROBE_X))) {
+    if (!WITHIN(X_probe_location, MIN_PROBE_X, MAX_PROBE_X)) {
       out_of_range_error(PSTR("X"));
       return;
     }
-    if (!WITHIN(Y_probe_location, LOGICAL_Y_POSITION(MIN_PROBE_Y), LOGICAL_Y_POSITION(MAX_PROBE_Y))) {
+    if (!WITHIN(Y_probe_location, MIN_PROBE_Y, MAX_PROBE_Y)) {
       out_of_range_error(PSTR("Y"));
       return;
     }
   #else
-    if (!position_is_reachable_by_probe_xy(X_probe_location, Y_probe_location)) {
+    if (!position_is_reachable_by_probe(X_probe_location, Y_probe_location)) {
       SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
       return;
     }
@@ -184,7 +184,7 @@ void GcodeSuite::M48() {
           #else
             // If we have gone out too far, we can do a simple fix and scale the numbers
             // back in closer to the origin.
-            while (!position_is_reachable_by_probe_xy(X_current, Y_current)) {
+            while (!position_is_reachable_by_probe(X_current, Y_current)) {
               X_current *= 0.8;
               Y_current *= 0.8;
               if (verbose_level > 3) {

commit 543935828134831a3129247fcfcf3cb071048011
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Thu Oct 19 10:44:45 2017 -0500

    Basic UBL operations working on 32-bit platforms (#8024)
    
    * 32-bit work for UBL
    
    * Update FT i3-2020 reference file

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index a910f02ee6..ced53d47ed 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -137,13 +137,13 @@ void GcodeSuite::M48() {
     for (uint8_t n = 0; n < n_samples; n++) {
       if (n_legs) {
         const int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
-        float angle = random(0.0, 360.0);
+        float angle = random(0, 360);
         const float radius = random(
           #if ENABLED(DELTA)
-            0.1250000000 * (DELTA_PROBEABLE_RADIUS),
-            0.3333333333 * (DELTA_PROBEABLE_RADIUS)
+            (int) (0.1250000000 * (DELTA_PROBEABLE_RADIUS)),
+            (int) (0.3333333333 * (DELTA_PROBEABLE_RADIUS))
           #else
-            5.0, 0.125 * min(X_BED_SIZE, Y_BED_SIZE)
+            (int) 5.0, (int) (0.125 * min(X_BED_SIZE, Y_BED_SIZE))
           #endif
         );
 

commit 3e3911fb81cef6f17f7e77c54f520e2a4579225b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 17:21:25 2017 -0500

    Use planner.leveling_active for all leveling systems

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index d3c551f170..a910f02ee6 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -119,7 +119,7 @@ void GcodeSuite::M48() {
   // Disable bed level correction in M48 because we want the raw data when we probe
 
   #if HAS_LEVELING
-    const bool was_enabled = LEVELING_IS_ACTIVE();
+    const bool was_enabled = planner.leveling_active;
     set_bed_leveling_enabled(false);
   #endif
 

commit 9a930ebec27008d2e47161d050e7d1f9dd534b66
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 10:25:05 2017 -0500

    Make leveling_is_active a macro

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
index 4c32933b00..d3c551f170 100644
--- a/Marlin/src/gcode/calibrate/M48.cpp
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -32,6 +32,10 @@
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
+#if HAS_LEVELING
+  #include "../../module/planner.h"
+#endif
+
 /**
  * M48: Z probe repeatability measurement function.
  *
@@ -115,7 +119,7 @@ void GcodeSuite::M48() {
   // Disable bed level correction in M48 because we want the raw data when we probe
 
   #if HAS_LEVELING
-    const bool was_enabled = leveling_is_active();
+    const bool was_enabled = LEVELING_IS_ACTIVE();
     set_bed_leveling_enabled(false);
   #endif
 

commit fc52fc72ac4ff1b2a66a0189a45745f36c2bf23e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 04:13:55 2017 -0500

    Move M48 to cpp

diff --git a/Marlin/src/gcode/calibrate/M48.cpp b/Marlin/src/gcode/calibrate/M48.cpp
new file mode 100644
index 0000000000..4c32933b00
--- /dev/null
+++ b/Marlin/src/gcode/calibrate/M48.cpp
@@ -0,0 +1,287 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
+
+#include "../gcode.h"
+#include "../../module/motion.h"
+#include "../../module/probe.h"
+
+#if DISABLED(DELTA)
+  #include "../../feature/bedlevel/bedlevel.h"
+#endif
+
+/**
+ * M48: Z probe repeatability measurement function.
+ *
+ * Usage:
+ *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
+ *     P = Number of sampled points (4-50, default 10)
+ *     X = Sample X position
+ *     Y = Sample Y position
+ *     V = Verbose level (0-4, default=1)
+ *     E = Engage Z probe for each reading
+ *     L = Number of legs of movement before probe
+ *     S = Schizoid (Or Star if you prefer)
+ *
+ * This function assumes the bed has been homed.  Specifically, that a G28 command
+ * as been issued prior to invoking the M48 Z probe repeatability measurement function.
+ * Any information generated by a prior G29 Bed leveling command will be lost and need to be
+ * regenerated.
+ */
+void GcodeSuite::M48() {
+
+  if (axis_unhomed_error()) return;
+
+  const int8_t verbose_level = parser.byteval('V', 1);
+  if (!WITHIN(verbose_level, 0, 4)) {
+    SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
+    return;
+  }
+
+  if (verbose_level > 0)
+    SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability Test");
+
+  const int8_t n_samples = parser.byteval('P', 10);
+  if (!WITHIN(n_samples, 4, 50)) {
+    SERIAL_PROTOCOLLNPGM("?Sample size not plausible (4-50).");
+    return;
+  }
+
+  const bool stow_probe_after_each = parser.boolval('E');
+
+  float X_current = current_position[X_AXIS],
+        Y_current = current_position[Y_AXIS];
+
+  const float X_probe_location = parser.linearval('X', X_current + X_PROBE_OFFSET_FROM_EXTRUDER),
+              Y_probe_location = parser.linearval('Y', Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER);
+
+  #if DISABLED(DELTA)
+    if (!WITHIN(X_probe_location, LOGICAL_X_POSITION(MIN_PROBE_X), LOGICAL_X_POSITION(MAX_PROBE_X))) {
+      out_of_range_error(PSTR("X"));
+      return;
+    }
+    if (!WITHIN(Y_probe_location, LOGICAL_Y_POSITION(MIN_PROBE_Y), LOGICAL_Y_POSITION(MAX_PROBE_Y))) {
+      out_of_range_error(PSTR("Y"));
+      return;
+    }
+  #else
+    if (!position_is_reachable_by_probe_xy(X_probe_location, Y_probe_location)) {
+      SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
+      return;
+    }
+  #endif
+
+  bool seen_L = parser.seen('L');
+  uint8_t n_legs = seen_L ? parser.value_byte() : 0;
+  if (n_legs > 15) {
+    SERIAL_PROTOCOLLNPGM("?Number of legs in movement not plausible (0-15).");
+    return;
+  }
+  if (n_legs == 1) n_legs = 2;
+
+  const bool schizoid_flag = parser.boolval('S');
+  if (schizoid_flag && !seen_L) n_legs = 7;
+
+  /**
+   * Now get everything to the specified probe point So we can safely do a
+   * probe to get us close to the bed.  If the Z-Axis is far from the bed,
+   * we don't want to use that as a starting point for each probe.
+   */
+  if (verbose_level > 2)
+    SERIAL_PROTOCOLLNPGM("Positioning the probe...");
+
+  // Disable bed level correction in M48 because we want the raw data when we probe
+
+  #if HAS_LEVELING
+    const bool was_enabled = leveling_is_active();
+    set_bed_leveling_enabled(false);
+  #endif
+
+  setup_for_endstop_or_probe_move();
+
+  double mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
+
+  // Move to the first point, deploy, and probe
+  const float t = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);
+  bool probing_good = !isnan(t);
+
+  if (probing_good) {
+    randomSeed(millis());
+
+    for (uint8_t n = 0; n < n_samples; n++) {
+      if (n_legs) {
+        const int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
+        float angle = random(0.0, 360.0);
+        const float radius = random(
+          #if ENABLED(DELTA)
+            0.1250000000 * (DELTA_PROBEABLE_RADIUS),
+            0.3333333333 * (DELTA_PROBEABLE_RADIUS)
+          #else
+            5.0, 0.125 * min(X_BED_SIZE, Y_BED_SIZE)
+          #endif
+        );
+
+        if (verbose_level > 3) {
+          SERIAL_ECHOPAIR("Starting radius: ", radius);
+          SERIAL_ECHOPAIR("   angle: ", angle);
+          SERIAL_ECHOPGM(" Direction: ");
+          if (dir > 0) SERIAL_ECHOPGM("Counter-");
+          SERIAL_ECHOLNPGM("Clockwise");
+        }
+
+        for (uint8_t l = 0; l < n_legs - 1; l++) {
+          double delta_angle;
+
+          if (schizoid_flag)
+            // The points of a 5 point star are 72 degrees apart.  We need to
+            // skip a point and go to the next one on the star.
+            delta_angle = dir * 2.0 * 72.0;
+
+          else
+            // If we do this line, we are just trying to move further
+            // around the circle.
+            delta_angle = dir * (float) random(25, 45);
+
+          angle += delta_angle;
+
+          while (angle > 360.0)   // We probably do not need to keep the angle between 0 and 2*PI, but the
+            angle -= 360.0;       // Arduino documentation says the trig functions should not be given values
+          while (angle < 0.0)     // outside of this range.   It looks like they behave correctly with
+            angle += 360.0;       // numbers outside of the range, but just to be safe we clamp them.
+
+          X_current = X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER) + cos(RADIANS(angle)) * radius;
+          Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;
+
+          #if DISABLED(DELTA)
+            X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
+            Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
+          #else
+            // If we have gone out too far, we can do a simple fix and scale the numbers
+            // back in closer to the origin.
+            while (!position_is_reachable_by_probe_xy(X_current, Y_current)) {
+              X_current *= 0.8;
+              Y_current *= 0.8;
+              if (verbose_level > 3) {
+                SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
+                SERIAL_ECHOLNPAIR(", ", Y_current);
+              }
+            }
+          #endif
+          if (verbose_level > 3) {
+            SERIAL_PROTOCOLPGM("Going to:");
+            SERIAL_ECHOPAIR(" X", X_current);
+            SERIAL_ECHOPAIR(" Y", Y_current);
+            SERIAL_ECHOLNPAIR(" Z", current_position[Z_AXIS]);
+          }
+          do_blocking_move_to_xy(X_current, Y_current);
+        } // n_legs loop
+      } // n_legs
+
+      // Probe a single point
+      sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, 0);
+
+      // Break the loop if the probe fails
+      probing_good = !isnan(sample_set[n]);
+      if (!probing_good) break;
+
+      /**
+       * Get the current mean for the data points we have so far
+       */
+      double sum = 0.0;
+      for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
+      mean = sum / (n + 1);
+
+      NOMORE(min, sample_set[n]);
+      NOLESS(max, sample_set[n]);
+
+      /**
+       * Now, use that mean to calculate the standard deviation for the
+       * data points we have so far
+       */
+      sum = 0.0;
+      for (uint8_t j = 0; j <= n; j++)
+        sum += sq(sample_set[j] - mean);
+
+      sigma = SQRT(sum / (n + 1));
+      if (verbose_level > 0) {
+        if (verbose_level > 1) {
+          SERIAL_PROTOCOL(n + 1);
+          SERIAL_PROTOCOLPGM(" of ");
+          SERIAL_PROTOCOL((int)n_samples);
+          SERIAL_PROTOCOLPGM(": z: ");
+          SERIAL_PROTOCOL_F(sample_set[n], 3);
+          if (verbose_level > 2) {
+            SERIAL_PROTOCOLPGM(" mean: ");
+            SERIAL_PROTOCOL_F(mean, 4);
+            SERIAL_PROTOCOLPGM(" sigma: ");
+            SERIAL_PROTOCOL_F(sigma, 6);
+            SERIAL_PROTOCOLPGM(" min: ");
+            SERIAL_PROTOCOL_F(min, 3);
+            SERIAL_PROTOCOLPGM(" max: ");
+            SERIAL_PROTOCOL_F(max, 3);
+            SERIAL_PROTOCOLPGM(" range: ");
+            SERIAL_PROTOCOL_F(max-min, 3);
+          }
+          SERIAL_EOL();
+        }
+      }
+
+    } // n_samples loop
+  }
+
+  STOW_PROBE();
+
+  if (probing_good) {
+    SERIAL_PROTOCOLLNPGM("Finished!");
+
+    if (verbose_level > 0) {
+      SERIAL_PROTOCOLPGM("Mean: ");
+      SERIAL_PROTOCOL_F(mean, 6);
+      SERIAL_PROTOCOLPGM(" Min: ");
+      SERIAL_PROTOCOL_F(min, 3);
+      SERIAL_PROTOCOLPGM(" Max: ");
+      SERIAL_PROTOCOL_F(max, 3);
+      SERIAL_PROTOCOLPGM(" Range: ");
+      SERIAL_PROTOCOL_F(max-min, 3);
+      SERIAL_EOL();
+    }
+
+    SERIAL_PROTOCOLPGM("Standard Deviation: ");
+    SERIAL_PROTOCOL_F(sigma, 6);
+    SERIAL_EOL();
+    SERIAL_EOL();
+  }
+
+  clean_up_after_endstop_or_probe_move();
+
+  // Re-enable bed level correction if it had been on
+  #if HAS_LEVELING
+    set_bed_leveling_enabled(was_enabled);
+  #endif
+
+  report_current_position();
+}
+
+#endif // Z_MIN_PROBE_REPEATABILITY_TEST
