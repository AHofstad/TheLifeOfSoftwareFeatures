commit 959be66cc22611bbaa8eabafaec308dbcbf3b03d
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Fri Jun 14 17:01:34 2024 -0400

    üî® Build scripts cleanup (#27157)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index faa44292a8..6c76cb8c5e 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -1,21 +1,21 @@
 #
 # common-dependencies.py
 # Convenience script to check dependencies and add libs and sources for Marlin Enabled Features
 #
 import pioutil
 if pioutil.is_pio_build():
 
-    import subprocess,os,re,fnmatch,glob
+    import os, re, fnmatch, glob
     srcfilepattern = re.compile(r".*[.](cpp|c)$")
     marlinbasedir = os.path.join(os.getcwd(), "Marlin/")
-    Import("env")
+    env = pioutil.env
 
     from platformio.package.meta import PackageSpec
     from platformio.project.config import ProjectConfig
 
     verbose = 0
     FEATURE_CONFIG = {}
 
     def validate_pio():
         PIO_VERSION_MIN = (6, 0, 1)
         try:

commit 244de2458ac6fd48f3031d0179ca1bcad6808583
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Mon Jul 17 10:53:36 2023 +0300

    üßë‚Äçüíª Improve TFT Color UI layout / theme (#26077)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index e90ba24dd3..faa44292a8 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -87,21 +87,21 @@ if pioutil.is_pio_build():
         for n in env.GetProjectOptions():
             key = n[0]
             mat = re.match(r'custom_marlin\.(.+)', key)
             if mat:
                 try:
                     val = env.GetProjectOption(key)
                 except:
                     val = None
                 if val:
                     opt = mat[1].upper()
-                    blab("%s.custom_marlin.%s = '%s'" % ( env['PIOENV'], opt, val ))
+                    blab("%s.custom_marlin.%s = '%s'" % ( env['PIOENV'], opt, val ), 2)
                     add_to_feat_cnf(opt, val)
 
     def get_all_known_libs():
         known_libs = []
         for feature in FEATURE_CONFIG:
             feat = FEATURE_CONFIG[feature]
             if not 'lib_deps' in feat:
                 continue
             for dep in feat['lib_deps']:
                 known_libs.append(PackageSpec(dep).name)
@@ -195,70 +195,70 @@ if pioutil.is_pio_build():
             # Remove the references to the same folder
             my_srcs = re.findall(r'([+-]<.*?>)', build_filters)
             for d in my_srcs:
                 # Assume normalized relative paths
                 plain = d[2:-1]
                 if d[0] == '+':
                     def addentry(fullpath, info=None):
                         relp = os.path.relpath(fullpath, marlinbasedir)
                         if srcfilepattern.match(relp):
                             if info:
-                                blab("Added src file %s (%s)" % (relp, str(info)))
+                                blab("Added src file %s (%s)" % (relp, str(info)), 3)
                             else:
-                                blab("Added src file %s " % relp)
+                                blab("Added src file %s " % relp, 3)
                             cur_srcs.add(relp)
                     # Special rule: If a direct folder is specified add all files within.
                     fullplain = os.path.join(marlinbasedir, plain)
                     if os.path.isdir(fullplain):
-                        blab("Directory content addition for %s " % plain)
+                        blab("Directory content addition for %s " % plain, 3)
                         gpattern = os.path.join(fullplain, "**")
                         for fname in glob.glob(gpattern, recursive=True):
                             addentry(fname, "dca")
                     else:
                         # Add all the things from the pattern by GLOB.
                         def srepl(matchi):
                             g0 = matchi.group(0)
                             return r"**" + g0[1:]
                         gpattern = re.sub(r'[*]($|[^*])', srepl, plain)
                         gpattern = os.path.join(marlinbasedir, gpattern)
 
                         for fname in glob.glob(gpattern, recursive=True):
                             addentry(fname)
                 else:
                     # Special rule: If a direct folder is specified then remove all files within.
                     def onremove(relp, info=None):
                         if info:
-                            blab("Removed src file %s (%s)" % (relp, str(info)))
+                            blab("Removed src file %s (%s)" % (relp, str(info)), 3)
                         else:
-                            blab("Removed src file %s " % relp)
+                            blab("Removed src file %s " % relp, 3)
                     fullplain = os.path.join(marlinbasedir, plain)
                     if os.path.isdir(fullplain):
-                        blab("Directory content removal for %s " % plain)
+                        blab("Directory content removal for %s " % plain, 2)
                         def filt(x):
                             common = os.path.commonpath([plain, x])
                             if not common == os.path.normpath(plain): return True
                             onremove(x, "dcr")
                             return False
                         cur_srcs = set(filter(filt, cur_srcs))
                     else:
                         # Remove matching source entries.
                         def filt(x):
                             if not fnmatch.fnmatch(x, plain): return True
                             onremove(x)
                             return False
                         cur_srcs = set(filter(filt, cur_srcs))
             # Transform the resulting set into a string.
             for x in cur_srcs:
-                if len(build_src_filter) > 0: build_src_filter += ' '
+                if build_src_filter != "": build_src_filter += ' '
                 build_src_filter += "+<" + x + ">"
 
-            #blab("Final build_src_filter: " + build_src_filter)
+            #blab("Final build_src_filter: " + build_src_filter, 3)
         else:
             build_src_filter = build_filters
 
         # Update in PlatformIO
         set_env_field('build_src_filter', [build_src_filter])
         env.Replace(SRC_FILTER=build_src_filter)
 
     #
     # Use the compiler to get a list of all enabled features
     #
@@ -274,34 +274,34 @@ if pioutil.is_pio_build():
             feature = define[8:].strip().decode().split(' ')
             feature, definition = feature[0], ' '.join(feature[1:])
             marlin_features[feature] = definition
         env['MARLIN_FEATURES'] = marlin_features
 
     #
     # Return True if a matching feature is enabled
     #
     def MarlinHas(env, feature):
         load_marlin_features()
-        r = re.compile('^' + feature + '$')
+        r = re.compile('^' + feature + '$', re.IGNORECASE)
         found = list(filter(r.match, env['MARLIN_FEATURES']))
 
         # Defines could still be 'false' or '0', so check
         some_on = False
         if len(found):
             for f in found:
                 val = env['MARLIN_FEATURES'][f]
                 if val in [ '', '1', 'true' ]:
                     some_on = True
                 elif val in env['MARLIN_FEATURES']:
                     some_on = env.MarlinHas(val)
 
-        #blab("%s is %s" % (feature, str(some_on)))
+        #blab("%s is %s" % (feature, str(some_on)), 2)
 
         return some_on
 
     validate_pio()
 
     try:
         verbose = int(env.GetProjectOption('custom_verbose'))
     except:
         pass
 

commit 74a6f5961bc82ef5887ddb7407a8798dc282b2c5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 18 03:03:54 2023 -0500

    üî® Fix Windows path backslash treated as escape
    
    Co-Authored-By: Luc <8822552+luc-github@users.noreply.github.com>

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index aa531be296..e90ba24dd3 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -48,24 +48,25 @@ if pioutil.is_pio_build():
     def add_to_feat_cnf(feature, flines):
 
         try:
             feat = FEATURE_CONFIG[feature]
         except:
             FEATURE_CONFIG[feature] = {}
 
         # Get a reference to the FEATURE_CONFIG under construction
         feat = FEATURE_CONFIG[feature]
 
-        # Split up passed lines on commas or newlines and iterate
-        # Add common options to the features config under construction
-        # For lib_deps replace a previous instance of the same library
-        atoms = re.sub(r',\s*', '\n', flines).strip().split('\n')
+        # Split up passed lines on commas or newlines and iterate.
+        # Take care to convert Windows '\' paths to Unix-style '/'.
+        # Add common options to the features config under construction.
+        # For lib_deps replace a previous instance of the same library.
+        atoms = re.sub(r',\s*', '\n', flines.replace('\\', '/')).strip().split('\n')
         for line in atoms:
             parts = line.split('=')
             name = parts.pop(0)
             if name in ['build_flags', 'extra_scripts', 'build_src_filter', 'lib_ignore']:
                 feat[name] = '='.join(parts)
                 blab("[%s] %s=%s" % (feature, name, feat[name]), 3)
             else:
                 for dep in re.split(r',\s*', line):
                     lib_name = re.sub(r'@([~^]|[<>]=?)?[\d.]+', '', dep.strip()).split('=').pop(0)
                     lib_re = re.compile('(?!^' + lib_name + '\\b)')

commit 79b0f3158556933699cab4c5ed4e8e798b4ef4d8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 11 19:39:30 2023 -0500

    üî® Use 'build_src_filter' (#25810)

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 58d9cfcb4d..aa531be296 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -55,21 +55,21 @@ if pioutil.is_pio_build():
         # Get a reference to the FEATURE_CONFIG under construction
         feat = FEATURE_CONFIG[feature]
 
         # Split up passed lines on commas or newlines and iterate
         # Add common options to the features config under construction
         # For lib_deps replace a previous instance of the same library
         atoms = re.sub(r',\s*', '\n', flines).strip().split('\n')
         for line in atoms:
             parts = line.split('=')
             name = parts.pop(0)
-            if name in ['build_flags', 'extra_scripts', 'src_filter', 'lib_ignore']:
+            if name in ['build_flags', 'extra_scripts', 'build_src_filter', 'lib_ignore']:
                 feat[name] = '='.join(parts)
                 blab("[%s] %s=%s" % (feature, name, feat[name]), 3)
             else:
                 for dep in re.split(r',\s*', line):
                     lib_name = re.sub(r'@([~^]|[<>]=?)?[\d.]+', '', dep.strip()).split('=').pop(0)
                     lib_re = re.compile('(?!^' + lib_name + '\\b)')
                     if not 'lib_deps' in feat: feat['lib_deps'] = {}
                     feat['lib_deps'] = list(filter(lib_re.match, feat['lib_deps'])) + [dep]
                     blab("[%s] lib_deps = %s" % (feature, dep), 3)
 
@@ -123,21 +123,21 @@ if pioutil.is_pio_build():
         env_libs = get_all_env_libs()
         known_libs = get_all_known_libs()
         diff = (list(set(known_libs) - set(env_libs)))
         lib_ignore = env.GetProjectOption('lib_ignore') + diff
         blab("Ignore libraries: %s" % lib_ignore)
         set_env_field('lib_ignore', lib_ignore)
 
     def apply_features_config():
         load_features()
         blab("========== Apply enabled features...")
-        build_filters = ' '.join(env.GetProjectOption('src_filter'))
+        build_filters = ' '.join(env.GetProjectOption('build_src_filter'))
         for feature in FEATURE_CONFIG:
             if not env.MarlinHas(feature):
                 continue
 
             feat = FEATURE_CONFIG[feature]
 
             if 'lib_deps' in feat and len(feat['lib_deps']):
                 blab("========== Adding lib_deps for %s... " % feature, 2)
 
                 # feat to add
@@ -168,32 +168,32 @@ if pioutil.is_pio_build():
             if 'build_flags' in feat:
                 f = feat['build_flags']
                 blab("========== Adding build_flags for %s: %s" % (feature, f), 2)
                 new_flags = env.GetProjectOption('build_flags') + [ f ]
                 env.Replace(BUILD_FLAGS=new_flags)
 
             if 'extra_scripts' in feat:
                 blab("Running extra_scripts for %s... " % feature, 2)
                 env.SConscript(feat['extra_scripts'], exports="env")
 
-            if 'src_filter' in feat:
+            if 'build_src_filter' in feat:
                 blab("========== Adding build_src_filter for %s... " % feature, 2)
-                build_filters = build_filters + ' ' + feat['src_filter']
+                build_filters = build_filters + ' ' + feat['build_src_filter']
                 # Just append the filter in the order that the build environment specifies.
                 # Important here is the order of entries in the "features.ini" file.
 
             if 'lib_ignore' in feat:
                 blab("========== Adding lib_ignore for %s... " % feature, 2)
                 lib_ignore = env.GetProjectOption('lib_ignore') + [feat['lib_ignore']]
                 set_env_field('lib_ignore', lib_ignore)
 
-        src_filter = ""
+        build_src_filter = ""
         if True:
             # Build the actual equivalent build_src_filter list based on the inclusions by the features.
             # PlatformIO doesn't do it this way, but maybe in the future....
             cur_srcs = set()
             # Remove the references to the same folder
             my_srcs = re.findall(r'([+-]<.*?>)', build_filters)
             for d in my_srcs:
                 # Assume normalized relative paths
                 plain = d[2:-1]
                 if d[0] == '+':
@@ -240,30 +240,30 @@ if pioutil.is_pio_build():
                         cur_srcs = set(filter(filt, cur_srcs))
                     else:
                         # Remove matching source entries.
                         def filt(x):
                             if not fnmatch.fnmatch(x, plain): return True
                             onremove(x)
                             return False
                         cur_srcs = set(filter(filt, cur_srcs))
             # Transform the resulting set into a string.
             for x in cur_srcs:
-                if len(src_filter) > 0: src_filter += ' '
-                src_filter += "+<" + x + ">"
+                if len(build_src_filter) > 0: build_src_filter += ' '
+                build_src_filter += "+<" + x + ">"
 
-            #blab("Final src_filter: " + src_filter)
+            #blab("Final build_src_filter: " + build_src_filter)
         else:
-            src_filter = build_filters
+            build_src_filter = build_filters
 
         # Update in PlatformIO
-        set_env_field('build_src_filter', [src_filter])
-        env.Replace(SRC_FILTER=src_filter)
+        set_env_field('build_src_filter', [build_src_filter])
+        env.Replace(SRC_FILTER=build_src_filter)
 
     #
     # Use the compiler to get a list of all enabled features
     #
     def load_marlin_features():
         if 'MARLIN_FEATURES' in env:
             return
 
         # Process defines
         from preprocessor import run_preprocessor

commit 9a7d9e6995f4f66c4b48147ec7876d49d4b3ae77
Author: Martin Turski <turningtides@outlook.de>
Date:   Thu Apr 27 14:05:24 2023 +0200

    üßë‚Äçüíª Optimize PlatformIO source filtering (#25332)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 6b5a9aea57..58d9cfcb4d 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -1,18 +1,20 @@
 #
 # common-dependencies.py
 # Convenience script to check dependencies and add libs and sources for Marlin Enabled Features
 #
 import pioutil
 if pioutil.is_pio_build():
 
-    import subprocess,os,re
+    import subprocess,os,re,fnmatch,glob
+    srcfilepattern = re.compile(r".*[.](cpp|c)$")
+    marlinbasedir = os.path.join(os.getcwd(), "Marlin/")
     Import("env")
 
     from platformio.package.meta import PackageSpec
     from platformio.project.config import ProjectConfig
 
     verbose = 0
     FEATURE_CONFIG = {}
 
     def validate_pio():
         PIO_VERSION_MIN = (6, 0, 1)
@@ -121,20 +123,21 @@ if pioutil.is_pio_build():
         env_libs = get_all_env_libs()
         known_libs = get_all_known_libs()
         diff = (list(set(known_libs) - set(env_libs)))
         lib_ignore = env.GetProjectOption('lib_ignore') + diff
         blab("Ignore libraries: %s" % lib_ignore)
         set_env_field('lib_ignore', lib_ignore)
 
     def apply_features_config():
         load_features()
         blab("========== Apply enabled features...")
+        build_filters = ' '.join(env.GetProjectOption('src_filter'))
         for feature in FEATURE_CONFIG:
             if not env.MarlinHas(feature):
                 continue
 
             feat = FEATURE_CONFIG[feature]
 
             if 'lib_deps' in feat and len(feat['lib_deps']):
                 blab("========== Adding lib_deps for %s... " % feature, 2)
 
                 # feat to add
@@ -167,37 +170,101 @@ if pioutil.is_pio_build():
                 blab("========== Adding build_flags for %s: %s" % (feature, f), 2)
                 new_flags = env.GetProjectOption('build_flags') + [ f ]
                 env.Replace(BUILD_FLAGS=new_flags)
 
             if 'extra_scripts' in feat:
                 blab("Running extra_scripts for %s... " % feature, 2)
                 env.SConscript(feat['extra_scripts'], exports="env")
 
             if 'src_filter' in feat:
                 blab("========== Adding build_src_filter for %s... " % feature, 2)
-                src_filter = ' '.join(env.GetProjectOption('src_filter'))
-                # first we need to remove the references to the same folder
-                my_srcs = re.findall(r'[+-](<.*?>)', feat['src_filter'])
-                cur_srcs = re.findall(r'[+-](<.*?>)', src_filter)
-                for d in my_srcs:
-                    if d in cur_srcs:
-                        src_filter = re.sub(r'[+-]' + d, '', src_filter)
-
-                src_filter = feat['src_filter'] + ' ' + src_filter
-                set_env_field('build_src_filter', [src_filter])
-                env.Replace(SRC_FILTER=src_filter)
+                build_filters = build_filters + ' ' + feat['src_filter']
+                # Just append the filter in the order that the build environment specifies.
+                # Important here is the order of entries in the "features.ini" file.
 
             if 'lib_ignore' in feat:
                 blab("========== Adding lib_ignore for %s... " % feature, 2)
                 lib_ignore = env.GetProjectOption('lib_ignore') + [feat['lib_ignore']]
                 set_env_field('lib_ignore', lib_ignore)
 
+        src_filter = ""
+        if True:
+            # Build the actual equivalent build_src_filter list based on the inclusions by the features.
+            # PlatformIO doesn't do it this way, but maybe in the future....
+            cur_srcs = set()
+            # Remove the references to the same folder
+            my_srcs = re.findall(r'([+-]<.*?>)', build_filters)
+            for d in my_srcs:
+                # Assume normalized relative paths
+                plain = d[2:-1]
+                if d[0] == '+':
+                    def addentry(fullpath, info=None):
+                        relp = os.path.relpath(fullpath, marlinbasedir)
+                        if srcfilepattern.match(relp):
+                            if info:
+                                blab("Added src file %s (%s)" % (relp, str(info)))
+                            else:
+                                blab("Added src file %s " % relp)
+                            cur_srcs.add(relp)
+                    # Special rule: If a direct folder is specified add all files within.
+                    fullplain = os.path.join(marlinbasedir, plain)
+                    if os.path.isdir(fullplain):
+                        blab("Directory content addition for %s " % plain)
+                        gpattern = os.path.join(fullplain, "**")
+                        for fname in glob.glob(gpattern, recursive=True):
+                            addentry(fname, "dca")
+                    else:
+                        # Add all the things from the pattern by GLOB.
+                        def srepl(matchi):
+                            g0 = matchi.group(0)
+                            return r"**" + g0[1:]
+                        gpattern = re.sub(r'[*]($|[^*])', srepl, plain)
+                        gpattern = os.path.join(marlinbasedir, gpattern)
+
+                        for fname in glob.glob(gpattern, recursive=True):
+                            addentry(fname)
+                else:
+                    # Special rule: If a direct folder is specified then remove all files within.
+                    def onremove(relp, info=None):
+                        if info:
+                            blab("Removed src file %s (%s)" % (relp, str(info)))
+                        else:
+                            blab("Removed src file %s " % relp)
+                    fullplain = os.path.join(marlinbasedir, plain)
+                    if os.path.isdir(fullplain):
+                        blab("Directory content removal for %s " % plain)
+                        def filt(x):
+                            common = os.path.commonpath([plain, x])
+                            if not common == os.path.normpath(plain): return True
+                            onremove(x, "dcr")
+                            return False
+                        cur_srcs = set(filter(filt, cur_srcs))
+                    else:
+                        # Remove matching source entries.
+                        def filt(x):
+                            if not fnmatch.fnmatch(x, plain): return True
+                            onremove(x)
+                            return False
+                        cur_srcs = set(filter(filt, cur_srcs))
+            # Transform the resulting set into a string.
+            for x in cur_srcs:
+                if len(src_filter) > 0: src_filter += ' '
+                src_filter += "+<" + x + ">"
+
+            #blab("Final src_filter: " + src_filter)
+        else:
+            src_filter = build_filters
+
+        # Update in PlatformIO
+        set_env_field('build_src_filter', [src_filter])
+        env.Replace(SRC_FILTER=src_filter)
+
     #
     # Use the compiler to get a list of all enabled features
     #
     def load_marlin_features():
         if 'MARLIN_FEATURES' in env:
             return
 
         # Process defines
         from preprocessor import run_preprocessor
         define_list = run_preprocessor(env)
@@ -219,20 +286,22 @@ if pioutil.is_pio_build():
         # Defines could still be 'false' or '0', so check
         some_on = False
         if len(found):
             for f in found:
                 val = env['MARLIN_FEATURES'][f]
                 if val in [ '', '1', 'true' ]:
                     some_on = True
                 elif val in env['MARLIN_FEATURES']:
                     some_on = env.MarlinHas(val)
 
+        #blab("%s is %s" % (feature, str(some_on)))
+
         return some_on
 
     validate_pio()
 
     try:
         verbose = int(env.GetProjectOption('custom_verbose'))
     except:
         pass
 
     #

commit 9e42480855b54d64415f3810d4aa911f7f439097
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Feb 21 18:22:16 2023 -0600

    üî® Fix marlin_custom.* without lib_deps

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 91331d8f7a..6b5a9aea57 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -60,20 +60,21 @@ if pioutil.is_pio_build():
         for line in atoms:
             parts = line.split('=')
             name = parts.pop(0)
             if name in ['build_flags', 'extra_scripts', 'src_filter', 'lib_ignore']:
                 feat[name] = '='.join(parts)
                 blab("[%s] %s=%s" % (feature, name, feat[name]), 3)
             else:
                 for dep in re.split(r',\s*', line):
                     lib_name = re.sub(r'@([~^]|[<>]=?)?[\d.]+', '', dep.strip()).split('=').pop(0)
                     lib_re = re.compile('(?!^' + lib_name + '\\b)')
+                    if not 'lib_deps' in feat: feat['lib_deps'] = {}
                     feat['lib_deps'] = list(filter(lib_re.match, feat['lib_deps'])) + [dep]
                     blab("[%s] lib_deps = %s" % (feature, dep), 3)
 
     def load_features():
         blab("========== Gather [features] entries...")
         for key in ProjectConfig().items('features'):
             feature = key[0].upper()
             if not feature in FEATURE_CONFIG:
                 FEATURE_CONFIG[feature] = { 'lib_deps': [] }
             add_to_feat_cnf(feature, key[1])

commit 306e03b03b1a51dd11b6d70ffcbfab099655e68a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Aug 19 11:00:52 2022 -0500

    üßë‚Äçüíª Use spaces indent for Python

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 4b986274ee..91331d8f7a 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -1,251 +1,251 @@
 #
 # common-dependencies.py
 # Convenience script to check dependencies and add libs and sources for Marlin Enabled Features
 #
 import pioutil
 if pioutil.is_pio_build():
 
-	import subprocess,os,re
-	Import("env")
-
-	from platformio.package.meta import PackageSpec
-	from platformio.project.config import ProjectConfig
-
-	verbose = 0
-	FEATURE_CONFIG = {}
-
-	def validate_pio():
-		PIO_VERSION_MIN = (6, 0, 1)
-		try:
-			from platformio import VERSION as PIO_VERSION
-			weights = (1000, 100, 1)
-			version_min = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION_MIN)])
-			version_cur = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION)])
-			if version_cur < version_min:
-				print()
-				print("**************************************************")
-				print("******      An update to PlatformIO is      ******")
-				print("******  required to build Marlin Firmware.  ******")
-				print("******                                      ******")
-				print("******      Minimum version: ", PIO_VERSION_MIN, "    ******")
-				print("******      Current Version: ", PIO_VERSION, "    ******")
-				print("******                                      ******")
-				print("******   Update PlatformIO and try again.   ******")
-				print("**************************************************")
-				print()
-				exit(1)
-		except SystemExit:
-			exit(1)
-		except:
-			print("Can't detect PlatformIO Version")
-
-	def blab(str,level=1):
-		if verbose >= level:
-			print("[deps] %s" % str)
-
-	def add_to_feat_cnf(feature, flines):
-
-		try:
-			feat = FEATURE_CONFIG[feature]
-		except:
-			FEATURE_CONFIG[feature] = {}
-
-		# Get a reference to the FEATURE_CONFIG under construction
-		feat = FEATURE_CONFIG[feature]
-
-		# Split up passed lines on commas or newlines and iterate
-		# Add common options to the features config under construction
-		# For lib_deps replace a previous instance of the same library
-		atoms = re.sub(r',\s*', '\n', flines).strip().split('\n')
-		for line in atoms:
-			parts = line.split('=')
-			name = parts.pop(0)
-			if name in ['build_flags', 'extra_scripts', 'src_filter', 'lib_ignore']:
-				feat[name] = '='.join(parts)
-				blab("[%s] %s=%s" % (feature, name, feat[name]), 3)
-			else:
-				for dep in re.split(r',\s*', line):
-					lib_name = re.sub(r'@([~^]|[<>]=?)?[\d.]+', '', dep.strip()).split('=').pop(0)
-					lib_re = re.compile('(?!^' + lib_name + '\\b)')
-					feat['lib_deps'] = list(filter(lib_re.match, feat['lib_deps'])) + [dep]
-					blab("[%s] lib_deps = %s" % (feature, dep), 3)
-
-	def load_features():
-		blab("========== Gather [features] entries...")
-		for key in ProjectConfig().items('features'):
-			feature = key[0].upper()
-			if not feature in FEATURE_CONFIG:
-				FEATURE_CONFIG[feature] = { 'lib_deps': [] }
-			add_to_feat_cnf(feature, key[1])
-
-		# Add options matching custom_marlin.MY_OPTION to the pile
-		blab("========== Gather custom_marlin entries...")
-		for n in env.GetProjectOptions():
-			key = n[0]
-			mat = re.match(r'custom_marlin\.(.+)', key)
-			if mat:
-				try:
-					val = env.GetProjectOption(key)
-				except:
-					val = None
-				if val:
-					opt = mat[1].upper()
-					blab("%s.custom_marlin.%s = '%s'" % ( env['PIOENV'], opt, val ))
-					add_to_feat_cnf(opt, val)
-
-	def get_all_known_libs():
-		known_libs = []
-		for feature in FEATURE_CONFIG:
-			feat = FEATURE_CONFIG[feature]
-			if not 'lib_deps' in feat:
-				continue
-			for dep in feat['lib_deps']:
-				known_libs.append(PackageSpec(dep).name)
-		return known_libs
-
-	def get_all_env_libs():
-		env_libs = []
-		lib_deps = env.GetProjectOption('lib_deps')
-		for dep in lib_deps:
-			env_libs.append(PackageSpec(dep).name)
-		return env_libs
-
-	def set_env_field(field, value):
-		proj = env.GetProjectConfig()
-		proj.set("env:" + env['PIOENV'], field, value)
-
-	# All unused libs should be ignored so that if a library
-	# exists in .pio/lib_deps it will not break compilation.
-	def force_ignore_unused_libs():
-		env_libs = get_all_env_libs()
-		known_libs = get_all_known_libs()
-		diff = (list(set(known_libs) - set(env_libs)))
-		lib_ignore = env.GetProjectOption('lib_ignore') + diff
-		blab("Ignore libraries: %s" % lib_ignore)
-		set_env_field('lib_ignore', lib_ignore)
-
-	def apply_features_config():
-		load_features()
-		blab("========== Apply enabled features...")
-		for feature in FEATURE_CONFIG:
-			if not env.MarlinHas(feature):
-				continue
-
-			feat = FEATURE_CONFIG[feature]
-
-			if 'lib_deps' in feat and len(feat['lib_deps']):
-				blab("========== Adding lib_deps for %s... " % feature, 2)
-
-				# feat to add
-				deps_to_add = {}
-				for dep in feat['lib_deps']:
-					deps_to_add[PackageSpec(dep).name] = dep
-					blab("==================== %s... " % dep, 2)
-
-				# Does the env already have the dependency?
-				deps = env.GetProjectOption('lib_deps')
-				for dep in deps:
-					name = PackageSpec(dep).name
-					if name in deps_to_add:
-						del deps_to_add[name]
-
-				# Are there any libraries that should be ignored?
-				lib_ignore = env.GetProjectOption('lib_ignore')
-				for dep in deps:
-					name = PackageSpec(dep).name
-					if name in deps_to_add:
-						del deps_to_add[name]
-
-				# Is there anything left?
-				if len(deps_to_add) > 0:
-					# Only add the missing dependencies
-					set_env_field('lib_deps', deps + list(deps_to_add.values()))
-
-			if 'build_flags' in feat:
-				f = feat['build_flags']
-				blab("========== Adding build_flags for %s: %s" % (feature, f), 2)
-				new_flags = env.GetProjectOption('build_flags') + [ f ]
-				env.Replace(BUILD_FLAGS=new_flags)
-
-			if 'extra_scripts' in feat:
-				blab("Running extra_scripts for %s... " % feature, 2)
-				env.SConscript(feat['extra_scripts'], exports="env")
-
-			if 'src_filter' in feat:
-				blab("========== Adding build_src_filter for %s... " % feature, 2)
-				src_filter = ' '.join(env.GetProjectOption('src_filter'))
-				# first we need to remove the references to the same folder
-				my_srcs = re.findall(r'[+-](<.*?>)', feat['src_filter'])
-				cur_srcs = re.findall(r'[+-](<.*?>)', src_filter)
-				for d in my_srcs:
-					if d in cur_srcs:
-						src_filter = re.sub(r'[+-]' + d, '', src_filter)
-
-				src_filter = feat['src_filter'] + ' ' + src_filter
-				set_env_field('build_src_filter', [src_filter])
-				env.Replace(SRC_FILTER=src_filter)
-
-			if 'lib_ignore' in feat:
-				blab("========== Adding lib_ignore for %s... " % feature, 2)
-				lib_ignore = env.GetProjectOption('lib_ignore') + [feat['lib_ignore']]
-				set_env_field('lib_ignore', lib_ignore)
-
-	#
-	# Use the compiler to get a list of all enabled features
-	#
-	def load_marlin_features():
-		if 'MARLIN_FEATURES' in env:
-			return
-
-		# Process defines
-		from preprocessor import run_preprocessor
-		define_list = run_preprocessor(env)
-		marlin_features = {}
-		for define in define_list:
-			feature = define[8:].strip().decode().split(' ')
-			feature, definition = feature[0], ' '.join(feature[1:])
-			marlin_features[feature] = definition
-		env['MARLIN_FEATURES'] = marlin_features
-
-	#
-	# Return True if a matching feature is enabled
-	#
-	def MarlinHas(env, feature):
-		load_marlin_features()
-		r = re.compile('^' + feature + '$')
-		found = list(filter(r.match, env['MARLIN_FEATURES']))
-
-		# Defines could still be 'false' or '0', so check
-		some_on = False
-		if len(found):
-			for f in found:
-				val = env['MARLIN_FEATURES'][f]
-				if val in [ '', '1', 'true' ]:
-					some_on = True
-				elif val in env['MARLIN_FEATURES']:
-					some_on = env.MarlinHas(val)
-
-		return some_on
-
-	validate_pio()
-
-	try:
-		verbose = int(env.GetProjectOption('custom_verbose'))
-	except:
-		pass
-
-	#
-	# Add a method for other PIO scripts to query enabled features
-	#
-	env.AddMethod(MarlinHas)
-
-	#
-	# Add dependencies for enabled Marlin features
-	#
-	apply_features_config()
-	force_ignore_unused_libs()
-
-	#print(env.Dump())
-
-	from signature import compute_build_signature
-	compute_build_signature(env)
+    import subprocess,os,re
+    Import("env")
+
+    from platformio.package.meta import PackageSpec
+    from platformio.project.config import ProjectConfig
+
+    verbose = 0
+    FEATURE_CONFIG = {}
+
+    def validate_pio():
+        PIO_VERSION_MIN = (6, 0, 1)
+        try:
+            from platformio import VERSION as PIO_VERSION
+            weights = (1000, 100, 1)
+            version_min = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION_MIN)])
+            version_cur = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION)])
+            if version_cur < version_min:
+                print()
+                print("**************************************************")
+                print("******      An update to PlatformIO is      ******")
+                print("******  required to build Marlin Firmware.  ******")
+                print("******                                      ******")
+                print("******      Minimum version: ", PIO_VERSION_MIN, "    ******")
+                print("******      Current Version: ", PIO_VERSION, "    ******")
+                print("******                                      ******")
+                print("******   Update PlatformIO and try again.   ******")
+                print("**************************************************")
+                print()
+                exit(1)
+        except SystemExit:
+            exit(1)
+        except:
+            print("Can't detect PlatformIO Version")
+
+    def blab(str,level=1):
+        if verbose >= level:
+            print("[deps] %s" % str)
+
+    def add_to_feat_cnf(feature, flines):
+
+        try:
+            feat = FEATURE_CONFIG[feature]
+        except:
+            FEATURE_CONFIG[feature] = {}
+
+        # Get a reference to the FEATURE_CONFIG under construction
+        feat = FEATURE_CONFIG[feature]
+
+        # Split up passed lines on commas or newlines and iterate
+        # Add common options to the features config under construction
+        # For lib_deps replace a previous instance of the same library
+        atoms = re.sub(r',\s*', '\n', flines).strip().split('\n')
+        for line in atoms:
+            parts = line.split('=')
+            name = parts.pop(0)
+            if name in ['build_flags', 'extra_scripts', 'src_filter', 'lib_ignore']:
+                feat[name] = '='.join(parts)
+                blab("[%s] %s=%s" % (feature, name, feat[name]), 3)
+            else:
+                for dep in re.split(r',\s*', line):
+                    lib_name = re.sub(r'@([~^]|[<>]=?)?[\d.]+', '', dep.strip()).split('=').pop(0)
+                    lib_re = re.compile('(?!^' + lib_name + '\\b)')
+                    feat['lib_deps'] = list(filter(lib_re.match, feat['lib_deps'])) + [dep]
+                    blab("[%s] lib_deps = %s" % (feature, dep), 3)
+
+    def load_features():
+        blab("========== Gather [features] entries...")
+        for key in ProjectConfig().items('features'):
+            feature = key[0].upper()
+            if not feature in FEATURE_CONFIG:
+                FEATURE_CONFIG[feature] = { 'lib_deps': [] }
+            add_to_feat_cnf(feature, key[1])
+
+        # Add options matching custom_marlin.MY_OPTION to the pile
+        blab("========== Gather custom_marlin entries...")
+        for n in env.GetProjectOptions():
+            key = n[0]
+            mat = re.match(r'custom_marlin\.(.+)', key)
+            if mat:
+                try:
+                    val = env.GetProjectOption(key)
+                except:
+                    val = None
+                if val:
+                    opt = mat[1].upper()
+                    blab("%s.custom_marlin.%s = '%s'" % ( env['PIOENV'], opt, val ))
+                    add_to_feat_cnf(opt, val)
+
+    def get_all_known_libs():
+        known_libs = []
+        for feature in FEATURE_CONFIG:
+            feat = FEATURE_CONFIG[feature]
+            if not 'lib_deps' in feat:
+                continue
+            for dep in feat['lib_deps']:
+                known_libs.append(PackageSpec(dep).name)
+        return known_libs
+
+    def get_all_env_libs():
+        env_libs = []
+        lib_deps = env.GetProjectOption('lib_deps')
+        for dep in lib_deps:
+            env_libs.append(PackageSpec(dep).name)
+        return env_libs
+
+    def set_env_field(field, value):
+        proj = env.GetProjectConfig()
+        proj.set("env:" + env['PIOENV'], field, value)
+
+    # All unused libs should be ignored so that if a library
+    # exists in .pio/lib_deps it will not break compilation.
+    def force_ignore_unused_libs():
+        env_libs = get_all_env_libs()
+        known_libs = get_all_known_libs()
+        diff = (list(set(known_libs) - set(env_libs)))
+        lib_ignore = env.GetProjectOption('lib_ignore') + diff
+        blab("Ignore libraries: %s" % lib_ignore)
+        set_env_field('lib_ignore', lib_ignore)
+
+    def apply_features_config():
+        load_features()
+        blab("========== Apply enabled features...")
+        for feature in FEATURE_CONFIG:
+            if not env.MarlinHas(feature):
+                continue
+
+            feat = FEATURE_CONFIG[feature]
+
+            if 'lib_deps' in feat and len(feat['lib_deps']):
+                blab("========== Adding lib_deps for %s... " % feature, 2)
+
+                # feat to add
+                deps_to_add = {}
+                for dep in feat['lib_deps']:
+                    deps_to_add[PackageSpec(dep).name] = dep
+                    blab("==================== %s... " % dep, 2)
+
+                # Does the env already have the dependency?
+                deps = env.GetProjectOption('lib_deps')
+                for dep in deps:
+                    name = PackageSpec(dep).name
+                    if name in deps_to_add:
+                        del deps_to_add[name]
+
+                # Are there any libraries that should be ignored?
+                lib_ignore = env.GetProjectOption('lib_ignore')
+                for dep in deps:
+                    name = PackageSpec(dep).name
+                    if name in deps_to_add:
+                        del deps_to_add[name]
+
+                # Is there anything left?
+                if len(deps_to_add) > 0:
+                    # Only add the missing dependencies
+                    set_env_field('lib_deps', deps + list(deps_to_add.values()))
+
+            if 'build_flags' in feat:
+                f = feat['build_flags']
+                blab("========== Adding build_flags for %s: %s" % (feature, f), 2)
+                new_flags = env.GetProjectOption('build_flags') + [ f ]
+                env.Replace(BUILD_FLAGS=new_flags)
+
+            if 'extra_scripts' in feat:
+                blab("Running extra_scripts for %s... " % feature, 2)
+                env.SConscript(feat['extra_scripts'], exports="env")
+
+            if 'src_filter' in feat:
+                blab("========== Adding build_src_filter for %s... " % feature, 2)
+                src_filter = ' '.join(env.GetProjectOption('src_filter'))
+                # first we need to remove the references to the same folder
+                my_srcs = re.findall(r'[+-](<.*?>)', feat['src_filter'])
+                cur_srcs = re.findall(r'[+-](<.*?>)', src_filter)
+                for d in my_srcs:
+                    if d in cur_srcs:
+                        src_filter = re.sub(r'[+-]' + d, '', src_filter)
+
+                src_filter = feat['src_filter'] + ' ' + src_filter
+                set_env_field('build_src_filter', [src_filter])
+                env.Replace(SRC_FILTER=src_filter)
+
+            if 'lib_ignore' in feat:
+                blab("========== Adding lib_ignore for %s... " % feature, 2)
+                lib_ignore = env.GetProjectOption('lib_ignore') + [feat['lib_ignore']]
+                set_env_field('lib_ignore', lib_ignore)
+
+    #
+    # Use the compiler to get a list of all enabled features
+    #
+    def load_marlin_features():
+        if 'MARLIN_FEATURES' in env:
+            return
+
+        # Process defines
+        from preprocessor import run_preprocessor
+        define_list = run_preprocessor(env)
+        marlin_features = {}
+        for define in define_list:
+            feature = define[8:].strip().decode().split(' ')
+            feature, definition = feature[0], ' '.join(feature[1:])
+            marlin_features[feature] = definition
+        env['MARLIN_FEATURES'] = marlin_features
+
+    #
+    # Return True if a matching feature is enabled
+    #
+    def MarlinHas(env, feature):
+        load_marlin_features()
+        r = re.compile('^' + feature + '$')
+        found = list(filter(r.match, env['MARLIN_FEATURES']))
+
+        # Defines could still be 'false' or '0', so check
+        some_on = False
+        if len(found):
+            for f in found:
+                val = env['MARLIN_FEATURES'][f]
+                if val in [ '', '1', 'true' ]:
+                    some_on = True
+                elif val in env['MARLIN_FEATURES']:
+                    some_on = env.MarlinHas(val)
+
+        return some_on
+
+    validate_pio()
+
+    try:
+        verbose = int(env.GetProjectOption('custom_verbose'))
+    except:
+        pass
+
+    #
+    # Add a method for other PIO scripts to query enabled features
+    #
+    env.AddMethod(MarlinHas)
+
+    #
+    # Add dependencies for enabled Marlin features
+    #
+    apply_features_config()
+    force_ignore_unused_libs()
+
+    #print(env.Dump())
+
+    from signature import compute_build_signature
+    compute_build_signature(env)

commit 8ccbac5317c5b07c3191a810bccb0e0aac1ef3e6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 24 13:51:43 2022 -0500

    üé® PIO scripts cleanup

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index e8219503bd..4b986274ee 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -49,29 +49,29 @@ if pioutil.is_pio_build():
 			feat = FEATURE_CONFIG[feature]
 		except:
 			FEATURE_CONFIG[feature] = {}
 
 		# Get a reference to the FEATURE_CONFIG under construction
 		feat = FEATURE_CONFIG[feature]
 
 		# Split up passed lines on commas or newlines and iterate
 		# Add common options to the features config under construction
 		# For lib_deps replace a previous instance of the same library
-		atoms = re.sub(r',\\s*', '\n', flines).strip().split('\n')
+		atoms = re.sub(r',\s*', '\n', flines).strip().split('\n')
 		for line in atoms:
 			parts = line.split('=')
 			name = parts.pop(0)
 			if name in ['build_flags', 'extra_scripts', 'src_filter', 'lib_ignore']:
 				feat[name] = '='.join(parts)
 				blab("[%s] %s=%s" % (feature, name, feat[name]), 3)
 			else:
-				for dep in re.split(r",\s*", line):
+				for dep in re.split(r',\s*', line):
 					lib_name = re.sub(r'@([~^]|[<>]=?)?[\d.]+', '', dep.strip()).split('=').pop(0)
 					lib_re = re.compile('(?!^' + lib_name + '\\b)')
 					feat['lib_deps'] = list(filter(lib_re.match, feat['lib_deps'])) + [dep]
 					blab("[%s] lib_deps = %s" % (feature, dep), 3)
 
 	def load_features():
 		blab("========== Gather [features] entries...")
 		for key in ProjectConfig().items('features'):
 			feature = key[0].upper()
 			if not feature in FEATURE_CONFIG:
@@ -82,21 +82,21 @@ if pioutil.is_pio_build():
 		blab("========== Gather custom_marlin entries...")
 		for n in env.GetProjectOptions():
 			key = n[0]
 			mat = re.match(r'custom_marlin\.(.+)', key)
 			if mat:
 				try:
 					val = env.GetProjectOption(key)
 				except:
 					val = None
 				if val:
-					opt = mat.group(1).upper()
+					opt = mat[1].upper()
 					blab("%s.custom_marlin.%s = '%s'" % ( env['PIOENV'], opt, val ))
 					add_to_feat_cnf(opt, val)
 
 	def get_all_known_libs():
 		known_libs = []
 		for feature in FEATURE_CONFIG:
 			feat = FEATURE_CONFIG[feature]
 			if not 'lib_deps' in feat:
 				continue
 			for dep in feat['lib_deps']:

commit edeea5a6fbe866fa7d26f34bad60ffa3cc35e326
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jul 21 04:18:17 2022 -0500

    üî® Minor build script changes

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index e9e8c79187..e8219503bd 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -63,33 +63,31 @@ if pioutil.is_pio_build():
 			if name in ['build_flags', 'extra_scripts', 'src_filter', 'lib_ignore']:
 				feat[name] = '='.join(parts)
 				blab("[%s] %s=%s" % (feature, name, feat[name]), 3)
 			else:
 				for dep in re.split(r",\s*", line):
 					lib_name = re.sub(r'@([~^]|[<>]=?)?[\d.]+', '', dep.strip()).split('=').pop(0)
 					lib_re = re.compile('(?!^' + lib_name + '\\b)')
 					feat['lib_deps'] = list(filter(lib_re.match, feat['lib_deps'])) + [dep]
 					blab("[%s] lib_deps = %s" % (feature, dep), 3)
 
-	def load_config():
+	def load_features():
 		blab("========== Gather [features] entries...")
-		items = ProjectConfig().items('features')
-		for key in items:
+		for key in ProjectConfig().items('features'):
 			feature = key[0].upper()
 			if not feature in FEATURE_CONFIG:
 				FEATURE_CONFIG[feature] = { 'lib_deps': [] }
 			add_to_feat_cnf(feature, key[1])
 
 		# Add options matching custom_marlin.MY_OPTION to the pile
 		blab("========== Gather custom_marlin entries...")
-		all_opts = env.GetProjectOptions()
-		for n in all_opts:
+		for n in env.GetProjectOptions():
 			key = n[0]
 			mat = re.match(r'custom_marlin\.(.+)', key)
 			if mat:
 				try:
 					val = env.GetProjectOption(key)
 				except:
 					val = None
 				if val:
 					opt = mat.group(1).upper()
 					blab("%s.custom_marlin.%s = '%s'" % ( env['PIOENV'], opt, val ))
@@ -120,24 +118,24 @@ if pioutil.is_pio_build():
 	# exists in .pio/lib_deps it will not break compilation.
 	def force_ignore_unused_libs():
 		env_libs = get_all_env_libs()
 		known_libs = get_all_known_libs()
 		diff = (list(set(known_libs) - set(env_libs)))
 		lib_ignore = env.GetProjectOption('lib_ignore') + diff
 		blab("Ignore libraries: %s" % lib_ignore)
 		set_env_field('lib_ignore', lib_ignore)
 
 	def apply_features_config():
-		load_config()
+		load_features()
 		blab("========== Apply enabled features...")
 		for feature in FEATURE_CONFIG:
-			if not env.MarlinFeatureIsEnabled(feature):
+			if not env.MarlinHas(feature):
 				continue
 
 			feat = FEATURE_CONFIG[feature]
 
 			if 'lib_deps' in feat and len(feat['lib_deps']):
 				blab("========== Adding lib_deps for %s... " % feature, 2)
 
 				# feat to add
 				deps_to_add = {}
 				for dep in feat['lib_deps']:
@@ -205,48 +203,48 @@ if pioutil.is_pio_build():
 		marlin_features = {}
 		for define in define_list:
 			feature = define[8:].strip().decode().split(' ')
 			feature, definition = feature[0], ' '.join(feature[1:])
 			marlin_features[feature] = definition
 		env['MARLIN_FEATURES'] = marlin_features
 
 	#
 	# Return True if a matching feature is enabled
 	#
-	def MarlinFeatureIsEnabled(env, feature):
+	def MarlinHas(env, feature):
 		load_marlin_features()
 		r = re.compile('^' + feature + '$')
 		found = list(filter(r.match, env['MARLIN_FEATURES']))
 
 		# Defines could still be 'false' or '0', so check
 		some_on = False
 		if len(found):
 			for f in found:
 				val = env['MARLIN_FEATURES'][f]
 				if val in [ '', '1', 'true' ]:
 					some_on = True
 				elif val in env['MARLIN_FEATURES']:
-					some_on = env.MarlinFeatureIsEnabled(val)
+					some_on = env.MarlinHas(val)
 
 		return some_on
 
 	validate_pio()
 
 	try:
 		verbose = int(env.GetProjectOption('custom_verbose'))
 	except:
 		pass
 
 	#
 	# Add a method for other PIO scripts to query enabled features
 	#
-	env.AddMethod(MarlinFeatureIsEnabled)
+	env.AddMethod(MarlinHas)
 
 	#
 	# Add dependencies for enabled Marlin features
 	#
 	apply_features_config()
 	force_ignore_unused_libs()
 
 	#print(env.Dump())
 
 	from signature import compute_build_signature

commit 6a880280e4c7e7ed6ebc72d9b446017bd7db3702
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Fri May 20 02:15:57 2022 +1200

    üî® Require PIO >= 6.0.1 (#24205)

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 24e780d9b6..e9e8c79187 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -8,21 +8,21 @@ if pioutil.is_pio_build():
 	import subprocess,os,re
 	Import("env")
 
 	from platformio.package.meta import PackageSpec
 	from platformio.project.config import ProjectConfig
 
 	verbose = 0
 	FEATURE_CONFIG = {}
 
 	def validate_pio():
-		PIO_VERSION_MIN = (5, 0, 3)
+		PIO_VERSION_MIN = (6, 0, 1)
 		try:
 			from platformio import VERSION as PIO_VERSION
 			weights = (1000, 100, 1)
 			version_min = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION_MIN)])
 			version_cur = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION)])
 			if version_cur < version_min:
 				print()
 				print("**************************************************")
 				print("******      An update to PlatformIO is      ******")
 				print("******  required to build Marlin Firmware.  ******")
@@ -167,31 +167,31 @@ if pioutil.is_pio_build():
 				f = feat['build_flags']
 				blab("========== Adding build_flags for %s: %s" % (feature, f), 2)
 				new_flags = env.GetProjectOption('build_flags') + [ f ]
 				env.Replace(BUILD_FLAGS=new_flags)
 
 			if 'extra_scripts' in feat:
 				blab("Running extra_scripts for %s... " % feature, 2)
 				env.SConscript(feat['extra_scripts'], exports="env")
 
 			if 'src_filter' in feat:
-				blab("========== Adding src_filter for %s... " % feature, 2)
+				blab("========== Adding build_src_filter for %s... " % feature, 2)
 				src_filter = ' '.join(env.GetProjectOption('src_filter'))
 				# first we need to remove the references to the same folder
 				my_srcs = re.findall(r'[+-](<.*?>)', feat['src_filter'])
 				cur_srcs = re.findall(r'[+-](<.*?>)', src_filter)
 				for d in my_srcs:
 					if d in cur_srcs:
 						src_filter = re.sub(r'[+-]' + d, '', src_filter)
 
 				src_filter = feat['src_filter'] + ' ' + src_filter
-				set_env_field('src_filter', [src_filter])
+				set_env_field('build_src_filter', [src_filter])
 				env.Replace(SRC_FILTER=src_filter)
 
 			if 'lib_ignore' in feat:
 				blab("========== Adding lib_ignore for %s... " % feature, 2)
 				lib_ignore = env.GetProjectOption('lib_ignore') + [feat['lib_ignore']]
 				set_env_field('lib_ignore', lib_ignore)
 
 	#
 	# Use the compiler to get a list of all enabled features
 	#

commit b464a4b1a4ea9cca914126c5f50c3e7384108a5e
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Tue Dec 14 07:22:06 2021 +0100

    ‚ú® Configurations embed and retrieve (#21321)

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 004f78f19b..24e780d9b6 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -185,104 +185,30 @@ if pioutil.is_pio_build():
 
 				src_filter = feat['src_filter'] + ' ' + src_filter
 				set_env_field('src_filter', [src_filter])
 				env.Replace(SRC_FILTER=src_filter)
 
 			if 'lib_ignore' in feat:
 				blab("========== Adding lib_ignore for %s... " % feature, 2)
 				lib_ignore = env.GetProjectOption('lib_ignore') + [feat['lib_ignore']]
 				set_env_field('lib_ignore', lib_ignore)
 
-	#
-	# Find a compiler, considering the OS
-	#
-	ENV_BUILD_PATH = os.path.join(env.Dictionary('PROJECT_BUILD_DIR'), env['PIOENV'])
-	GCC_PATH_CACHE = os.path.join(ENV_BUILD_PATH, ".gcc_path")
-	def search_compiler():
-		try:
-			filepath = env.GetProjectOption('custom_gcc')
-			blab("Getting compiler from env")
-			return filepath
-		except:
-			pass
-
-		if os.path.exists(GCC_PATH_CACHE):
-			with open(GCC_PATH_CACHE, 'r') as f:
-				return f.read()
-
-		# Find the current platform compiler by searching the $PATH
-		# which will be in a platformio toolchain bin folder
-		path_regex = re.escape(env['PROJECT_PACKAGES_DIR'])
-
-		# See if the environment provides a default compiler
-		try:
-			gcc = env.GetProjectOption('custom_deps_gcc')
-		except:
-			gcc = "g++"
-
-		if env['PLATFORM'] == 'win32':
-			path_separator = ';'
-			path_regex += r'.*\\bin'
-			gcc += ".exe"
-		else:
-			path_separator = ':'
-			path_regex += r'/.+/bin'
-
-		# Search for the compiler
-		for pathdir in env['ENV']['PATH'].split(path_separator):
-			if not re.search(path_regex, pathdir, re.IGNORECASE):
-				continue
-			for filepath in os.listdir(pathdir):
-				if not filepath.endswith(gcc):
-					continue
-				# Use entire path to not rely on env PATH
-				filepath = os.path.sep.join([pathdir, filepath])
-				# Cache the g++ path to no search always
-				if os.path.exists(ENV_BUILD_PATH):
-					with open(GCC_PATH_CACHE, 'w+') as f:
-						f.write(filepath)
-
-				return filepath
-
-		filepath = env.get('CXX')
-		if filepath == 'CC':
-			filepath = gcc
-		blab("Couldn't find a compiler! Fallback to %s" % filepath)
-		return filepath
-
 	#
 	# Use the compiler to get a list of all enabled features
 	#
 	def load_marlin_features():
 		if 'MARLIN_FEATURES' in env:
 			return
 
 		# Process defines
-		build_flags = env.get('BUILD_FLAGS')
-		build_flags = env.ParseFlagsExtended(build_flags)
-
-		cxx = search_compiler()
-		cmd = ['"' + cxx + '"']
-
-		# Build flags from board.json
-		#if 'BOARD' in env:
-		#	cmd += [env.BoardConfig().get("build.extra_flags")]
-		for s in build_flags['CPPDEFINES']:
-			if isinstance(s, tuple):
-				cmd += ['-D' + s[0] + '=' + str(s[1])]
-			else:
-				cmd += ['-D' + s]
-
-		cmd += ['-D__MARLIN_DEPS__ -w -dM -E -x c++ buildroot/share/PlatformIO/scripts/common-dependencies.h']
-		cmd = ' '.join(cmd)
-		blab(cmd, 4)
-		define_list = subprocess.check_output(cmd, shell=True).splitlines()
+		from preprocessor import run_preprocessor
+		define_list = run_preprocessor(env)
 		marlin_features = {}
 		for define in define_list:
 			feature = define[8:].strip().decode().split(' ')
 			feature, definition = feature[0], ' '.join(feature[1:])
 			marlin_features[feature] = definition
 		env['MARLIN_FEATURES'] = marlin_features
 
 	#
 	# Return True if a matching feature is enabled
 	#
@@ -303,16 +229,25 @@ if pioutil.is_pio_build():
 
 		return some_on
 
 	validate_pio()
 
 	try:
 		verbose = int(env.GetProjectOption('custom_verbose'))
 	except:
 		pass
 
+	#
 	# Add a method for other PIO scripts to query enabled features
+	#
 	env.AddMethod(MarlinFeatureIsEnabled)
 
+	#
 	# Add dependencies for enabled Marlin features
+	#
 	apply_features_config()
 	force_ignore_unused_libs()
+
+	#print(env.Dump())
+
+	from signature import compute_build_signature
+	compute_build_signature(env)

commit 4483b8aaf023576ea1c8ecfa84e7093ec26ad75a
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Thu Nov 4 17:28:42 2021 +0700

    üî® Fix IntelliSense / PIO conflicts (#23058)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index f523b12069..004f78f19b 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -1,321 +1,318 @@
 #
 # common-dependencies.py
 # Convenience script to check dependencies and add libs and sources for Marlin Enabled Features
 #
-import subprocess,os,re,pioutil
-Import("env")
-
-# Detect that 'vscode init' is running
-if pioutil.is_vscode_init():
-	env.Exit(0)
-
-PIO_VERSION_MIN = (5, 0, 3)
-try:
-	from platformio import VERSION as PIO_VERSION
-	weights = (1000, 100, 1)
-	version_min = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION_MIN)])
-	version_cur = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION)])
-	if version_cur < version_min:
-		print()
-		print("**************************************************")
-		print("******      An update to PlatformIO is      ******")
-		print("******  required to build Marlin Firmware.  ******")
-		print("******                                      ******")
-		print("******      Minimum version: ", PIO_VERSION_MIN, "    ******")
-		print("******      Current Version: ", PIO_VERSION, "    ******")
-		print("******                                      ******")
-		print("******   Update PlatformIO and try again.   ******")
-		print("**************************************************")
-		print()
-		exit(1)
-except SystemExit:
-	exit(1)
-except:
-	print("Can't detect PlatformIO Version")
-
-from platformio.package.meta import PackageSpec
-from platformio.project.config import ProjectConfig
-
-#print(env.Dump())
-
-try:
-	verbose = int(env.GetProjectOption('custom_verbose'))
-except:
-	verbose = 0
-
-def blab(str,level=1):
-	if verbose >= level:
-		print("[deps] %s" % str)
-
-FEATURE_CONFIG = {}
+import pioutil
+if pioutil.is_pio_build():
 
-def add_to_feat_cnf(feature, flines):
+	import subprocess,os,re
+	Import("env")
 
-	try:
-		feat = FEATURE_CONFIG[feature]
-	except:
-		FEATURE_CONFIG[feature] = {}
-
-	# Get a reference to the FEATURE_CONFIG under construction
-	feat = FEATURE_CONFIG[feature]
-
-	# Split up passed lines on commas or newlines and iterate
-	# Add common options to the features config under construction
-	# For lib_deps replace a previous instance of the same library
-	atoms = re.sub(r',\\s*', '\n', flines).strip().split('\n')
-	for line in atoms:
-		parts = line.split('=')
-		name = parts.pop(0)
-		if name in ['build_flags', 'extra_scripts', 'src_filter', 'lib_ignore']:
-			feat[name] = '='.join(parts)
-			blab("[%s] %s=%s" % (feature, name, feat[name]), 3)
-		else:
-			for dep in re.split(r",\s*", line):
-				lib_name = re.sub(r'@([~^]|[<>]=?)?[\d.]+', '', dep.strip()).split('=').pop(0)
-				lib_re = re.compile('(?!^' + lib_name + '\\b)')
-				feat['lib_deps'] = list(filter(lib_re.match, feat['lib_deps'])) + [dep]
-				blab("[%s] lib_deps = %s" % (feature, dep), 3)
-
-def load_config():
-	blab("========== Gather [features] entries...")
-	items = ProjectConfig().items('features')
-	for key in items:
-		feature = key[0].upper()
-		if not feature in FEATURE_CONFIG:
-			FEATURE_CONFIG[feature] = { 'lib_deps': [] }
-		add_to_feat_cnf(feature, key[1])
-
-	# Add options matching custom_marlin.MY_OPTION to the pile
-	blab("========== Gather custom_marlin entries...")
-	all_opts = env.GetProjectOptions()
-	for n in all_opts:
-		key = n[0]
-		mat = re.match(r'custom_marlin\.(.+)', key)
-		if mat:
-			try:
-				val = env.GetProjectOption(key)
-			except:
-				val = None
-			if val:
-				opt = mat.group(1).upper()
-				blab("%s.custom_marlin.%s = '%s'" % ( env['PIOENV'], opt, val ))
-				add_to_feat_cnf(opt, val)
-
-def get_all_known_libs():
-	known_libs = []
-	for feature in FEATURE_CONFIG:
-		feat = FEATURE_CONFIG[feature]
-		if not 'lib_deps' in feat:
-			continue
-		for dep in feat['lib_deps']:
-			known_libs.append(PackageSpec(dep).name)
-	return known_libs
-
-def get_all_env_libs():
-	env_libs = []
-	lib_deps = env.GetProjectOption('lib_deps')
-	for dep in lib_deps:
-		env_libs.append(PackageSpec(dep).name)
-	return env_libs
-
-def set_env_field(field, value):
-	proj = env.GetProjectConfig()
-	proj.set("env:" + env['PIOENV'], field, value)
-
-# All unused libs should be ignored so that if a library
-# exists in .pio/lib_deps it will not break compilation.
-def force_ignore_unused_libs():
-	env_libs = get_all_env_libs()
-	known_libs = get_all_known_libs()
-	diff = (list(set(known_libs) - set(env_libs)))
-	lib_ignore = env.GetProjectOption('lib_ignore') + diff
-	blab("Ignore libraries: %s" % lib_ignore)
-	set_env_field('lib_ignore', lib_ignore)
-
-def apply_features_config():
-	load_config()
-	blab("========== Apply enabled features...")
-	for feature in FEATURE_CONFIG:
-		if not env.MarlinFeatureIsEnabled(feature):
-			continue
+	from platformio.package.meta import PackageSpec
+	from platformio.project.config import ProjectConfig
 
+	verbose = 0
+	FEATURE_CONFIG = {}
+
+	def validate_pio():
+		PIO_VERSION_MIN = (5, 0, 3)
+		try:
+			from platformio import VERSION as PIO_VERSION
+			weights = (1000, 100, 1)
+			version_min = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION_MIN)])
+			version_cur = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION)])
+			if version_cur < version_min:
+				print()
+				print("**************************************************")
+				print("******      An update to PlatformIO is      ******")
+				print("******  required to build Marlin Firmware.  ******")
+				print("******                                      ******")
+				print("******      Minimum version: ", PIO_VERSION_MIN, "    ******")
+				print("******      Current Version: ", PIO_VERSION, "    ******")
+				print("******                                      ******")
+				print("******   Update PlatformIO and try again.   ******")
+				print("**************************************************")
+				print()
+				exit(1)
+		except SystemExit:
+			exit(1)
+		except:
+			print("Can't detect PlatformIO Version")
+
+	def blab(str,level=1):
+		if verbose >= level:
+			print("[deps] %s" % str)
+
+	def add_to_feat_cnf(feature, flines):
+
+		try:
+			feat = FEATURE_CONFIG[feature]
+		except:
+			FEATURE_CONFIG[feature] = {}
+
+		# Get a reference to the FEATURE_CONFIG under construction
 		feat = FEATURE_CONFIG[feature]
 
-		if 'lib_deps' in feat and len(feat['lib_deps']):
-			blab("========== Adding lib_deps for %s... " % feature, 2)
-
-			# feat to add
-			deps_to_add = {}
+		# Split up passed lines on commas or newlines and iterate
+		# Add common options to the features config under construction
+		# For lib_deps replace a previous instance of the same library
+		atoms = re.sub(r',\\s*', '\n', flines).strip().split('\n')
+		for line in atoms:
+			parts = line.split('=')
+			name = parts.pop(0)
+			if name in ['build_flags', 'extra_scripts', 'src_filter', 'lib_ignore']:
+				feat[name] = '='.join(parts)
+				blab("[%s] %s=%s" % (feature, name, feat[name]), 3)
+			else:
+				for dep in re.split(r",\s*", line):
+					lib_name = re.sub(r'@([~^]|[<>]=?)?[\d.]+', '', dep.strip()).split('=').pop(0)
+					lib_re = re.compile('(?!^' + lib_name + '\\b)')
+					feat['lib_deps'] = list(filter(lib_re.match, feat['lib_deps'])) + [dep]
+					blab("[%s] lib_deps = %s" % (feature, dep), 3)
+
+	def load_config():
+		blab("========== Gather [features] entries...")
+		items = ProjectConfig().items('features')
+		for key in items:
+			feature = key[0].upper()
+			if not feature in FEATURE_CONFIG:
+				FEATURE_CONFIG[feature] = { 'lib_deps': [] }
+			add_to_feat_cnf(feature, key[1])
+
+		# Add options matching custom_marlin.MY_OPTION to the pile
+		blab("========== Gather custom_marlin entries...")
+		all_opts = env.GetProjectOptions()
+		for n in all_opts:
+			key = n[0]
+			mat = re.match(r'custom_marlin\.(.+)', key)
+			if mat:
+				try:
+					val = env.GetProjectOption(key)
+				except:
+					val = None
+				if val:
+					opt = mat.group(1).upper()
+					blab("%s.custom_marlin.%s = '%s'" % ( env['PIOENV'], opt, val ))
+					add_to_feat_cnf(opt, val)
+
+	def get_all_known_libs():
+		known_libs = []
+		for feature in FEATURE_CONFIG:
+			feat = FEATURE_CONFIG[feature]
+			if not 'lib_deps' in feat:
+				continue
 			for dep in feat['lib_deps']:
-				deps_to_add[PackageSpec(dep).name] = dep
-				blab("==================== %s... " % dep, 2)
-
-			# Does the env already have the dependency?
-			deps = env.GetProjectOption('lib_deps')
-			for dep in deps:
-				name = PackageSpec(dep).name
-				if name in deps_to_add:
-					del deps_to_add[name]
-
-			# Are there any libraries that should be ignored?
-			lib_ignore = env.GetProjectOption('lib_ignore')
-			for dep in deps:
-				name = PackageSpec(dep).name
-				if name in deps_to_add:
-					del deps_to_add[name]
-
-			# Is there anything left?
-			if len(deps_to_add) > 0:
-				# Only add the missing dependencies
-				set_env_field('lib_deps', deps + list(deps_to_add.values()))
-
-		if 'build_flags' in feat:
-			f = feat['build_flags']
-			blab("========== Adding build_flags for %s: %s" % (feature, f), 2)
-			new_flags = env.GetProjectOption('build_flags') + [ f ]
-			env.Replace(BUILD_FLAGS=new_flags)
-
-		if 'extra_scripts' in feat:
-			blab("Running extra_scripts for %s... " % feature, 2)
-			env.SConscript(feat['extra_scripts'], exports="env")
-
-		if 'src_filter' in feat:
-			blab("========== Adding src_filter for %s... " % feature, 2)
-			src_filter = ' '.join(env.GetProjectOption('src_filter'))
-			# first we need to remove the references to the same folder
-			my_srcs = re.findall(r'[+-](<.*?>)', feat['src_filter'])
-			cur_srcs = re.findall(r'[+-](<.*?>)', src_filter)
-			for d in my_srcs:
-				if d in cur_srcs:
-					src_filter = re.sub(r'[+-]' + d, '', src_filter)
-
-			src_filter = feat['src_filter'] + ' ' + src_filter
-			set_env_field('src_filter', [src_filter])
-			env.Replace(SRC_FILTER=src_filter)
-
-		if 'lib_ignore' in feat:
-			blab("========== Adding lib_ignore for %s... " % feature, 2)
-			lib_ignore = env.GetProjectOption('lib_ignore') + [feat['lib_ignore']]
-			set_env_field('lib_ignore', lib_ignore)
-
-#
-# Find a compiler, considering the OS
-#
-ENV_BUILD_PATH = os.path.join(env.Dictionary('PROJECT_BUILD_DIR'), env['PIOENV'])
-GCC_PATH_CACHE = os.path.join(ENV_BUILD_PATH, ".gcc_path")
-def search_compiler():
-	try:
-		filepath = env.GetProjectOption('custom_gcc')
-		blab("Getting compiler from env")
-		return filepath
-	except:
-		pass
-
-	if os.path.exists(GCC_PATH_CACHE):
-		with open(GCC_PATH_CACHE, 'r') as f:
-			return f.read()
-
-	# Find the current platform compiler by searching the $PATH
-	# which will be in a platformio toolchain bin folder
-	path_regex = re.escape(env['PROJECT_PACKAGES_DIR'])
-
-	# See if the environment provides a default compiler
-	try:
-		gcc = env.GetProjectOption('custom_deps_gcc')
-	except:
-		gcc = "g++"
-
-	if env['PLATFORM'] == 'win32':
-		path_separator = ';'
-		path_regex += r'.*\\bin'
-		gcc += ".exe"
-	else:
-		path_separator = ':'
-		path_regex += r'/.+/bin'
-
-	# Search for the compiler
-	for pathdir in env['ENV']['PATH'].split(path_separator):
-		if not re.search(path_regex, pathdir, re.IGNORECASE):
-			continue
-		for filepath in os.listdir(pathdir):
-			if not filepath.endswith(gcc):
+				known_libs.append(PackageSpec(dep).name)
+		return known_libs
+
+	def get_all_env_libs():
+		env_libs = []
+		lib_deps = env.GetProjectOption('lib_deps')
+		for dep in lib_deps:
+			env_libs.append(PackageSpec(dep).name)
+		return env_libs
+
+	def set_env_field(field, value):
+		proj = env.GetProjectConfig()
+		proj.set("env:" + env['PIOENV'], field, value)
+
+	# All unused libs should be ignored so that if a library
+	# exists in .pio/lib_deps it will not break compilation.
+	def force_ignore_unused_libs():
+		env_libs = get_all_env_libs()
+		known_libs = get_all_known_libs()
+		diff = (list(set(known_libs) - set(env_libs)))
+		lib_ignore = env.GetProjectOption('lib_ignore') + diff
+		blab("Ignore libraries: %s" % lib_ignore)
+		set_env_field('lib_ignore', lib_ignore)
+
+	def apply_features_config():
+		load_config()
+		blab("========== Apply enabled features...")
+		for feature in FEATURE_CONFIG:
+			if not env.MarlinFeatureIsEnabled(feature):
 				continue
-			# Use entire path to not rely on env PATH
-			filepath = os.path.sep.join([pathdir, filepath])
-			# Cache the g++ path to no search always
-			if os.path.exists(ENV_BUILD_PATH):
-				with open(GCC_PATH_CACHE, 'w+') as f:
-					f.write(filepath)
 
+			feat = FEATURE_CONFIG[feature]
+
+			if 'lib_deps' in feat and len(feat['lib_deps']):
+				blab("========== Adding lib_deps for %s... " % feature, 2)
+
+				# feat to add
+				deps_to_add = {}
+				for dep in feat['lib_deps']:
+					deps_to_add[PackageSpec(dep).name] = dep
+					blab("==================== %s... " % dep, 2)
+
+				# Does the env already have the dependency?
+				deps = env.GetProjectOption('lib_deps')
+				for dep in deps:
+					name = PackageSpec(dep).name
+					if name in deps_to_add:
+						del deps_to_add[name]
+
+				# Are there any libraries that should be ignored?
+				lib_ignore = env.GetProjectOption('lib_ignore')
+				for dep in deps:
+					name = PackageSpec(dep).name
+					if name in deps_to_add:
+						del deps_to_add[name]
+
+				# Is there anything left?
+				if len(deps_to_add) > 0:
+					# Only add the missing dependencies
+					set_env_field('lib_deps', deps + list(deps_to_add.values()))
+
+			if 'build_flags' in feat:
+				f = feat['build_flags']
+				blab("========== Adding build_flags for %s: %s" % (feature, f), 2)
+				new_flags = env.GetProjectOption('build_flags') + [ f ]
+				env.Replace(BUILD_FLAGS=new_flags)
+
+			if 'extra_scripts' in feat:
+				blab("Running extra_scripts for %s... " % feature, 2)
+				env.SConscript(feat['extra_scripts'], exports="env")
+
+			if 'src_filter' in feat:
+				blab("========== Adding src_filter for %s... " % feature, 2)
+				src_filter = ' '.join(env.GetProjectOption('src_filter'))
+				# first we need to remove the references to the same folder
+				my_srcs = re.findall(r'[+-](<.*?>)', feat['src_filter'])
+				cur_srcs = re.findall(r'[+-](<.*?>)', src_filter)
+				for d in my_srcs:
+					if d in cur_srcs:
+						src_filter = re.sub(r'[+-]' + d, '', src_filter)
+
+				src_filter = feat['src_filter'] + ' ' + src_filter
+				set_env_field('src_filter', [src_filter])
+				env.Replace(SRC_FILTER=src_filter)
+
+			if 'lib_ignore' in feat:
+				blab("========== Adding lib_ignore for %s... " % feature, 2)
+				lib_ignore = env.GetProjectOption('lib_ignore') + [feat['lib_ignore']]
+				set_env_field('lib_ignore', lib_ignore)
+
+	#
+	# Find a compiler, considering the OS
+	#
+	ENV_BUILD_PATH = os.path.join(env.Dictionary('PROJECT_BUILD_DIR'), env['PIOENV'])
+	GCC_PATH_CACHE = os.path.join(ENV_BUILD_PATH, ".gcc_path")
+	def search_compiler():
+		try:
+			filepath = env.GetProjectOption('custom_gcc')
+			blab("Getting compiler from env")
 			return filepath
+		except:
+			pass
+
+		if os.path.exists(GCC_PATH_CACHE):
+			with open(GCC_PATH_CACHE, 'r') as f:
+				return f.read()
+
+		# Find the current platform compiler by searching the $PATH
+		# which will be in a platformio toolchain bin folder
+		path_regex = re.escape(env['PROJECT_PACKAGES_DIR'])
+
+		# See if the environment provides a default compiler
+		try:
+			gcc = env.GetProjectOption('custom_deps_gcc')
+		except:
+			gcc = "g++"
+
+		if env['PLATFORM'] == 'win32':
+			path_separator = ';'
+			path_regex += r'.*\\bin'
+			gcc += ".exe"
+		else:
+			path_separator = ':'
+			path_regex += r'/.+/bin'
 
-	filepath = env.get('CXX')
-	if filepath == 'CC':
-		filepath = gcc
-	blab("Couldn't find a compiler! Fallback to %s" % filepath)
-	return filepath
+		# Search for the compiler
+		for pathdir in env['ENV']['PATH'].split(path_separator):
+			if not re.search(path_regex, pathdir, re.IGNORECASE):
+				continue
+			for filepath in os.listdir(pathdir):
+				if not filepath.endswith(gcc):
+					continue
+				# Use entire path to not rely on env PATH
+				filepath = os.path.sep.join([pathdir, filepath])
+				# Cache the g++ path to no search always
+				if os.path.exists(ENV_BUILD_PATH):
+					with open(GCC_PATH_CACHE, 'w+') as f:
+						f.write(filepath)
+
+				return filepath
+
+		filepath = env.get('CXX')
+		if filepath == 'CC':
+			filepath = gcc
+		blab("Couldn't find a compiler! Fallback to %s" % filepath)
+		return filepath
 
-#
-# Use the compiler to get a list of all enabled features
-#
-def load_marlin_features():
-	if 'MARLIN_FEATURES' in env:
-		return
-
-	# Process defines
-	build_flags = env.get('BUILD_FLAGS')
-	build_flags = env.ParseFlagsExtended(build_flags)
-
-	cxx = search_compiler()
-	cmd = ['"' + cxx + '"']
-
-	# Build flags from board.json
-	#if 'BOARD' in env:
-	#	cmd += [env.BoardConfig().get("build.extra_flags")]
-	for s in build_flags['CPPDEFINES']:
-		if isinstance(s, tuple):
-			cmd += ['-D' + s[0] + '=' + str(s[1])]
-		else:
-			cmd += ['-D' + s]
-
-	cmd += ['-D__MARLIN_DEPS__ -w -dM -E -x c++ buildroot/share/PlatformIO/scripts/common-dependencies.h']
-	cmd = ' '.join(cmd)
-	blab(cmd, 4)
-	define_list = subprocess.check_output(cmd, shell=True).splitlines()
-	marlin_features = {}
-	for define in define_list:
-		feature = define[8:].strip().decode().split(' ')
-		feature, definition = feature[0], ' '.join(feature[1:])
-		marlin_features[feature] = definition
-	env['MARLIN_FEATURES'] = marlin_features
+	#
+	# Use the compiler to get a list of all enabled features
+	#
+	def load_marlin_features():
+		if 'MARLIN_FEATURES' in env:
+			return
+
+		# Process defines
+		build_flags = env.get('BUILD_FLAGS')
+		build_flags = env.ParseFlagsExtended(build_flags)
+
+		cxx = search_compiler()
+		cmd = ['"' + cxx + '"']
+
+		# Build flags from board.json
+		#if 'BOARD' in env:
+		#	cmd += [env.BoardConfig().get("build.extra_flags")]
+		for s in build_flags['CPPDEFINES']:
+			if isinstance(s, tuple):
+				cmd += ['-D' + s[0] + '=' + str(s[1])]
+			else:
+				cmd += ['-D' + s]
+
+		cmd += ['-D__MARLIN_DEPS__ -w -dM -E -x c++ buildroot/share/PlatformIO/scripts/common-dependencies.h']
+		cmd = ' '.join(cmd)
+		blab(cmd, 4)
+		define_list = subprocess.check_output(cmd, shell=True).splitlines()
+		marlin_features = {}
+		for define in define_list:
+			feature = define[8:].strip().decode().split(' ')
+			feature, definition = feature[0], ' '.join(feature[1:])
+			marlin_features[feature] = definition
+		env['MARLIN_FEATURES'] = marlin_features
+
+	#
+	# Return True if a matching feature is enabled
+	#
+	def MarlinFeatureIsEnabled(env, feature):
+		load_marlin_features()
+		r = re.compile('^' + feature + '$')
+		found = list(filter(r.match, env['MARLIN_FEATURES']))
+
+		# Defines could still be 'false' or '0', so check
+		some_on = False
+		if len(found):
+			for f in found:
+				val = env['MARLIN_FEATURES'][f]
+				if val in [ '', '1', 'true' ]:
+					some_on = True
+				elif val in env['MARLIN_FEATURES']:
+					some_on = env.MarlinFeatureIsEnabled(val)
+
+		return some_on
+
+	validate_pio()
 
-#
-# Return True if a matching feature is enabled
-#
-def MarlinFeatureIsEnabled(env, feature):
-	load_marlin_features()
-	r = re.compile('^' + feature + '$')
-	found = list(filter(r.match, env['MARLIN_FEATURES']))
-
-	# Defines could still be 'false' or '0', so check
-	some_on = False
-	if len(found):
-		for f in found:
-			val = env['MARLIN_FEATURES'][f]
-			if val in [ '', '1', 'true' ]:
-				some_on = True
-			elif val in env['MARLIN_FEATURES']:
-				some_on = env.MarlinFeatureIsEnabled(val)
-
-	return some_on
+	try:
+		verbose = int(env.GetProjectOption('custom_verbose'))
+	except:
+		pass
 
-#
-# Add a method for other PIO scripts to query enabled features
-#
-env.AddMethod(MarlinFeatureIsEnabled)
+	# Add a method for other PIO scripts to query enabled features
+	env.AddMethod(MarlinFeatureIsEnabled)
 
-#
-# Add dependencies for enabled Marlin features
-#
-apply_features_config()
-force_ignore_unused_libs()
+	# Add dependencies for enabled Marlin features
+	apply_features_config()
+	force_ignore_unused_libs()

commit c91451d215506b3c3977b9ae4b146c98b48acdeb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 19 02:49:35 2021 -0500

    üî® Update 'pio vscode init' detection

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 83dfeca879..f523b12069 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -1,15 +1,20 @@
 #
 # common-dependencies.py
 # Convenience script to check dependencies and add libs and sources for Marlin Enabled Features
 #
-import subprocess,os,re
+import subprocess,os,re,pioutil
+Import("env")
+
+# Detect that 'vscode init' is running
+if pioutil.is_vscode_init():
+	env.Exit(0)
 
 PIO_VERSION_MIN = (5, 0, 3)
 try:
 	from platformio import VERSION as PIO_VERSION
 	weights = (1000, 100, 1)
 	version_min = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION_MIN)])
 	version_cur = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION)])
 	if version_cur < version_min:
 		print()
 		print("**************************************************")
@@ -24,22 +29,20 @@ try:
 		print()
 		exit(1)
 except SystemExit:
 	exit(1)
 except:
 	print("Can't detect PlatformIO Version")
 
 from platformio.package.meta import PackageSpec
 from platformio.project.config import ProjectConfig
 
-Import("env")
-
 #print(env.Dump())
 
 try:
 	verbose = int(env.GetProjectOption('custom_verbose'))
 except:
 	verbose = 0
 
 def blab(str,level=1):
 	if verbose >= level:
 		print("[deps] %s" % str)

commit 21011eefa818f73d79746f7555fead94f0d3d20a
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Thu Jul 22 01:01:23 2021 +0100

    ‚ú® Simulator HAL and build targets (#22418)

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 01ee89e25e..83dfeca879 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -208,21 +208,27 @@ def search_compiler():
 	except:
 		pass
 
 	if os.path.exists(GCC_PATH_CACHE):
 		with open(GCC_PATH_CACHE, 'r') as f:
 			return f.read()
 
 	# Find the current platform compiler by searching the $PATH
 	# which will be in a platformio toolchain bin folder
 	path_regex = re.escape(env['PROJECT_PACKAGES_DIR'])
-	gcc = "g++"
+
+	# See if the environment provides a default compiler
+	try:
+		gcc = env.GetProjectOption('custom_deps_gcc')
+	except:
+		gcc = "g++"
+
 	if env['PLATFORM'] == 'win32':
 		path_separator = ';'
 		path_regex += r'.*\\bin'
 		gcc += ".exe"
 	else:
 		path_separator = ':'
 		path_regex += r'/.+/bin'
 
 	# Search for the compiler
 	for pathdir in env['ENV']['PATH'].split(path_separator):
@@ -234,20 +240,22 @@ def search_compiler():
 			# Use entire path to not rely on env PATH
 			filepath = os.path.sep.join([pathdir, filepath])
 			# Cache the g++ path to no search always
 			if os.path.exists(ENV_BUILD_PATH):
 				with open(GCC_PATH_CACHE, 'w+') as f:
 					f.write(filepath)
 
 			return filepath
 
 	filepath = env.get('CXX')
+	if filepath == 'CC':
+		filepath = gcc
 	blab("Couldn't find a compiler! Fallback to %s" % filepath)
 	return filepath
 
 #
 # Use the compiler to get a list of all enabled features
 #
 def load_marlin_features():
 	if 'MARLIN_FEATURES' in env:
 		return
 

commit d87a71bd044a186deebdeeed57ac916e56c8ac86
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 20 05:11:43 2021 -0500

    Extra dependency script logging

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index fe6ae7dba5..01ee89e25e 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -33,23 +33,23 @@ from platformio.project.config import ProjectConfig
 
 Import("env")
 
 #print(env.Dump())
 
 try:
 	verbose = int(env.GetProjectOption('custom_verbose'))
 except:
 	verbose = 0
 
-def blab(str):
-	if verbose:
-		print(str)
+def blab(str,level=1):
+	if verbose >= level:
+		print("[deps] %s" % str)
 
 FEATURE_CONFIG = {}
 
 def add_to_feat_cnf(feature, flines):
 
 	try:
 		feat = FEATURE_CONFIG[feature]
 	except:
 		FEATURE_CONFIG[feature] = {}
 
@@ -58,45 +58,52 @@ def add_to_feat_cnf(feature, flines):
 
 	# Split up passed lines on commas or newlines and iterate
 	# Add common options to the features config under construction
 	# For lib_deps replace a previous instance of the same library
 	atoms = re.sub(r',\\s*', '\n', flines).strip().split('\n')
 	for line in atoms:
 		parts = line.split('=')
 		name = parts.pop(0)
 		if name in ['build_flags', 'extra_scripts', 'src_filter', 'lib_ignore']:
 			feat[name] = '='.join(parts)
+			blab("[%s] %s=%s" % (feature, name, feat[name]), 3)
 		else:
-			for dep in line.split(','):
+			for dep in re.split(r",\s*", line):
 				lib_name = re.sub(r'@([~^]|[<>]=?)?[\d.]+', '', dep.strip()).split('=').pop(0)
 				lib_re = re.compile('(?!^' + lib_name + '\\b)')
 				feat['lib_deps'] = list(filter(lib_re.match, feat['lib_deps'])) + [dep]
+				blab("[%s] lib_deps = %s" % (feature, dep), 3)
 
 def load_config():
+	blab("========== Gather [features] entries...")
 	items = ProjectConfig().items('features')
 	for key in items:
 		feature = key[0].upper()
 		if not feature in FEATURE_CONFIG:
 			FEATURE_CONFIG[feature] = { 'lib_deps': [] }
 		add_to_feat_cnf(feature, key[1])
 
 	# Add options matching custom_marlin.MY_OPTION to the pile
+	blab("========== Gather custom_marlin entries...")
 	all_opts = env.GetProjectOptions()
 	for n in all_opts:
-		mat = re.match(r'custom_marlin\.(.+)', n[0])
+		key = n[0]
+		mat = re.match(r'custom_marlin\.(.+)', key)
 		if mat:
 			try:
-				val = env.GetProjectOption(n[0])
+				val = env.GetProjectOption(key)
 			except:
 				val = None
 			if val:
-				add_to_feat_cnf(mat.group(1).upper(), val)
+				opt = mat.group(1).upper()
+				blab("%s.custom_marlin.%s = '%s'" % ( env['PIOENV'], opt, val ))
+				add_to_feat_cnf(opt, val)
 
 def get_all_known_libs():
 	known_libs = []
 	for feature in FEATURE_CONFIG:
 		feat = FEATURE_CONFIG[feature]
 		if not 'lib_deps' in feat:
 			continue
 		for dep in feat['lib_deps']:
 			known_libs.append(PackageSpec(dep).name)
 	return known_libs
@@ -117,33 +124,35 @@ def set_env_field(field, value):
 def force_ignore_unused_libs():
 	env_libs = get_all_env_libs()
 	known_libs = get_all_known_libs()
 	diff = (list(set(known_libs) - set(env_libs)))
 	lib_ignore = env.GetProjectOption('lib_ignore') + diff
 	blab("Ignore libraries: %s" % lib_ignore)
 	set_env_field('lib_ignore', lib_ignore)
 
 def apply_features_config():
 	load_config()
+	blab("========== Apply enabled features...")
 	for feature in FEATURE_CONFIG:
 		if not env.MarlinFeatureIsEnabled(feature):
 			continue
 
 		feat = FEATURE_CONFIG[feature]
 
 		if 'lib_deps' in feat and len(feat['lib_deps']):
-			blab("Adding lib_deps for %s... " % feature)
+			blab("========== Adding lib_deps for %s... " % feature, 2)
 
 			# feat to add
 			deps_to_add = {}
 			for dep in feat['lib_deps']:
 				deps_to_add[PackageSpec(dep).name] = dep
+				blab("==================== %s... " % dep, 2)
 
 			# Does the env already have the dependency?
 			deps = env.GetProjectOption('lib_deps')
 			for dep in deps:
 				name = PackageSpec(dep).name
 				if name in deps_to_add:
 					del deps_to_add[name]
 
 			# Are there any libraries that should be ignored?
 			lib_ignore = env.GetProjectOption('lib_ignore')
@@ -152,62 +161,61 @@ def apply_features_config():
 				if name in deps_to_add:
 					del deps_to_add[name]
 
 			# Is there anything left?
 			if len(deps_to_add) > 0:
 				# Only add the missing dependencies
 				set_env_field('lib_deps', deps + list(deps_to_add.values()))
 
 		if 'build_flags' in feat:
 			f = feat['build_flags']
-			blab("Adding build_flags for %s: %s" % (feature, f))
+			blab("========== Adding build_flags for %s: %s" % (feature, f), 2)
 			new_flags = env.GetProjectOption('build_flags') + [ f ]
 			env.Replace(BUILD_FLAGS=new_flags)
 
 		if 'extra_scripts' in feat:
-			blab("Running extra_scripts for %s... " % feature)
+			blab("Running extra_scripts for %s... " % feature, 2)
 			env.SConscript(feat['extra_scripts'], exports="env")
 
 		if 'src_filter' in feat:
-			blab("Adding src_filter for %s... " % feature)
+			blab("========== Adding src_filter for %s... " % feature, 2)
 			src_filter = ' '.join(env.GetProjectOption('src_filter'))
 			# first we need to remove the references to the same folder
 			my_srcs = re.findall(r'[+-](<.*?>)', feat['src_filter'])
 			cur_srcs = re.findall(r'[+-](<.*?>)', src_filter)
 			for d in my_srcs:
 				if d in cur_srcs:
 					src_filter = re.sub(r'[+-]' + d, '', src_filter)
 
 			src_filter = feat['src_filter'] + ' ' + src_filter
 			set_env_field('src_filter', [src_filter])
 			env.Replace(SRC_FILTER=src_filter)
 
 		if 'lib_ignore' in feat:
-			blab("Adding lib_ignore for %s... " % feature)
+			blab("========== Adding lib_ignore for %s... " % feature, 2)
 			lib_ignore = env.GetProjectOption('lib_ignore') + [feat['lib_ignore']]
 			set_env_field('lib_ignore', lib_ignore)
 
 #
 # Find a compiler, considering the OS
 #
 ENV_BUILD_PATH = os.path.join(env.Dictionary('PROJECT_BUILD_DIR'), env['PIOENV'])
 GCC_PATH_CACHE = os.path.join(ENV_BUILD_PATH, ".gcc_path")
 def search_compiler():
 	try:
 		filepath = env.GetProjectOption('custom_gcc')
 		blab("Getting compiler from env")
 		return filepath
 	except:
 		pass
 
 	if os.path.exists(GCC_PATH_CACHE):
-		blab("Getting g++ path from cache")
 		with open(GCC_PATH_CACHE, 'r') as f:
 			return f.read()
 
 	# Find the current platform compiler by searching the $PATH
 	# which will be in a platformio toolchain bin folder
 	path_regex = re.escape(env['PROJECT_PACKAGES_DIR'])
 	gcc = "g++"
 	if env['PLATFORM'] == 'win32':
 		path_separator = ';'
 		path_regex += r'.*\\bin'
@@ -220,21 +228,20 @@ def search_compiler():
 	for pathdir in env['ENV']['PATH'].split(path_separator):
 		if not re.search(path_regex, pathdir, re.IGNORECASE):
 			continue
 		for filepath in os.listdir(pathdir):
 			if not filepath.endswith(gcc):
 				continue
 			# Use entire path to not rely on env PATH
 			filepath = os.path.sep.join([pathdir, filepath])
 			# Cache the g++ path to no search always
 			if os.path.exists(ENV_BUILD_PATH):
-				blab("Caching g++ for current env")
 				with open(GCC_PATH_CACHE, 'w+') as f:
 					f.write(filepath)
 
 			return filepath
 
 	filepath = env.get('CXX')
 	blab("Couldn't find a compiler! Fallback to %s" % filepath)
 	return filepath
 
 #
@@ -255,21 +262,21 @@ def load_marlin_features():
 	#if 'BOARD' in env:
 	#	cmd += [env.BoardConfig().get("build.extra_flags")]
 	for s in build_flags['CPPDEFINES']:
 		if isinstance(s, tuple):
 			cmd += ['-D' + s[0] + '=' + str(s[1])]
 		else:
 			cmd += ['-D' + s]
 
 	cmd += ['-D__MARLIN_DEPS__ -w -dM -E -x c++ buildroot/share/PlatformIO/scripts/common-dependencies.h']
 	cmd = ' '.join(cmd)
-	blab(cmd)
+	blab(cmd, 4)
 	define_list = subprocess.check_output(cmd, shell=True).splitlines()
 	marlin_features = {}
 	for define in define_list:
 		feature = define[8:].strip().decode().split(' ')
 		feature, definition = feature[0], ' '.join(feature[1:])
 		marlin_features[feature] = definition
 	env['MARLIN_FEATURES'] = marlin_features
 
 #
 # Return True if a matching feature is enabled

commit 59fd6428ae77a153082d8e1dd49c081b79a81a93
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 18 22:46:43 2021 -0500

    Skip preflight checks only (#21658)
    
    Followup to e8af38cc2d

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 5b17c3586f..fe6ae7dba5 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -1,23 +1,14 @@
 #
 # common-dependencies.py
 # Convenience script to check dependencies and add libs and sources for Marlin Enabled Features
 #
-Import("env")
-
-#print(env.Dump())
-
-# Detect that 'vscode init' is running
-from SCons.Script import COMMAND_LINE_TARGETS
-if "idedata" in COMMAND_LINE_TARGETS:
-    env.Exit(0)
-
 import subprocess,os,re
 
 PIO_VERSION_MIN = (5, 0, 3)
 try:
 	from platformio import VERSION as PIO_VERSION
 	weights = (1000, 100, 1)
 	version_min = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION_MIN)])
 	version_cur = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION)])
 	if version_cur < version_min:
 		print()
@@ -33,20 +24,24 @@ try:
 		print()
 		exit(1)
 except SystemExit:
 	exit(1)
 except:
 	print("Can't detect PlatformIO Version")
 
 from platformio.package.meta import PackageSpec
 from platformio.project.config import ProjectConfig
 
+Import("env")
+
+#print(env.Dump())
+
 try:
 	verbose = int(env.GetProjectOption('custom_verbose'))
 except:
 	verbose = 0
 
 def blab(str):
 	if verbose:
 		print(str)
 
 FEATURE_CONFIG = {}

commit e8af38cc2df433536e6fc584efc251f62e826999
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 17 14:19:33 2021 -0500

    Skip scripts during 'platformio init' (#21643)

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index fe6ae7dba5..5b17c3586f 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -1,14 +1,23 @@
 #
 # common-dependencies.py
 # Convenience script to check dependencies and add libs and sources for Marlin Enabled Features
 #
+Import("env")
+
+#print(env.Dump())
+
+# Detect that 'vscode init' is running
+from SCons.Script import COMMAND_LINE_TARGETS
+if "idedata" in COMMAND_LINE_TARGETS:
+    env.Exit(0)
+
 import subprocess,os,re
 
 PIO_VERSION_MIN = (5, 0, 3)
 try:
 	from platformio import VERSION as PIO_VERSION
 	weights = (1000, 100, 1)
 	version_min = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION_MIN)])
 	version_cur = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION)])
 	if version_cur < version_min:
 		print()
@@ -24,24 +33,20 @@ try:
 		print()
 		exit(1)
 except SystemExit:
 	exit(1)
 except:
 	print("Can't detect PlatformIO Version")
 
 from platformio.package.meta import PackageSpec
 from platformio.project.config import ProjectConfig
 
-Import("env")
-
-#print(env.Dump())
-
 try:
 	verbose = int(env.GetProjectOption('custom_verbose'))
 except:
 	verbose = 0
 
 def blab(str):
 	if verbose:
 		print(str)
 
 FEATURE_CONFIG = {}

commit 3229100025dc428d5038eca753c70f3c831d6336
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 21:53:19 2021 -0500

    Split up platformio.ini (#21507)

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 3844d8298a..fe6ae7dba5 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -1,25 +1,15 @@
 #
 # common-dependencies.py
 # Convenience script to check dependencies and add libs and sources for Marlin Enabled Features
 #
 import subprocess,os,re
-try:
-	import configparser
-except ImportError:
-	import ConfigParser as configparser
-try:
-	# PIO < 4.4
-	from platformio.managers.package import PackageManager
-except ImportError:
-	# PIO >= 4.4
-	from platformio.package.meta import PackageSpec as PackageManager
 
 PIO_VERSION_MIN = (5, 0, 3)
 try:
 	from platformio import VERSION as PIO_VERSION
 	weights = (1000, 100, 1)
 	version_min = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION_MIN)])
 	version_cur = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION)])
 	if version_cur < version_min:
 		print()
 		print("**************************************************")
@@ -31,40 +21,36 @@ try:
 		print("******                                      ******")
 		print("******   Update PlatformIO and try again.   ******")
 		print("**************************************************")
 		print()
 		exit(1)
 except SystemExit:
 	exit(1)
 except:
 	print("Can't detect PlatformIO Version")
 
+from platformio.package.meta import PackageSpec
+from platformio.project.config import ProjectConfig
+
 Import("env")
 
 #print(env.Dump())
 
 try:
 	verbose = int(env.GetProjectOption('custom_verbose'))
 except:
 	verbose = 0
 
 def blab(str):
 	if verbose:
 		print(str)
 
-def parse_pkg_uri(spec):
-	if PackageManager.__name__ == 'PackageSpec':
-		return PackageManager(spec).name
-	else:
-		name, _, _ = PackageManager.parse_pkg_uri(spec)
-		return name
-
 FEATURE_CONFIG = {}
 
 def add_to_feat_cnf(feature, flines):
 
 	try:
 		feat = FEATURE_CONFIG[feature]
 	except:
 		FEATURE_CONFIG[feature] = {}
 
 	# Get a reference to the FEATURE_CONFIG under construction
@@ -79,23 +65,21 @@ def add_to_feat_cnf(feature, flines):
 		name = parts.pop(0)
 		if name in ['build_flags', 'extra_scripts', 'src_filter', 'lib_ignore']:
 			feat[name] = '='.join(parts)
 		else:
 			for dep in line.split(','):
 				lib_name = re.sub(r'@([~^]|[<>]=?)?[\d.]+', '', dep.strip()).split('=').pop(0)
 				lib_re = re.compile('(?!^' + lib_name + '\\b)')
 				feat['lib_deps'] = list(filter(lib_re.match, feat['lib_deps'])) + [dep]
 
 def load_config():
-	config = configparser.ConfigParser()
-	config.read("platformio.ini")
-	items = config.items('features')
+	items = ProjectConfig().items('features')
 	for key in items:
 		feature = key[0].upper()
 		if not feature in FEATURE_CONFIG:
 			FEATURE_CONFIG[feature] = { 'lib_deps': [] }
 		add_to_feat_cnf(feature, key[1])
 
 	# Add options matching custom_marlin.MY_OPTION to the pile
 	all_opts = env.GetProjectOptions()
 	for n in all_opts:
 		mat = re.match(r'custom_marlin\.(.+)', n[0])
@@ -107,30 +91,28 @@ def load_config():
 			if val:
 				add_to_feat_cnf(mat.group(1).upper(), val)
 
 def get_all_known_libs():
 	known_libs = []
 	for feature in FEATURE_CONFIG:
 		feat = FEATURE_CONFIG[feature]
 		if not 'lib_deps' in feat:
 			continue
 		for dep in feat['lib_deps']:
-			name = parse_pkg_uri(dep)
-			known_libs.append(name)
+			known_libs.append(PackageSpec(dep).name)
 	return known_libs
 
 def get_all_env_libs():
 	env_libs = []
 	lib_deps = env.GetProjectOption('lib_deps')
 	for dep in lib_deps:
-		name = parse_pkg_uri(dep)
-		env_libs.append(name)
+		env_libs.append(PackageSpec(dep).name)
 	return env_libs
 
 def set_env_field(field, value):
 	proj = env.GetProjectConfig()
 	proj.set("env:" + env['PIOENV'], field, value)
 
 # All unused libs should be ignored so that if a library
 # exists in .pio/lib_deps it will not break compilation.
 def force_ignore_unused_libs():
 	env_libs = get_all_env_libs()
@@ -147,34 +129,33 @@ def apply_features_config():
 			continue
 
 		feat = FEATURE_CONFIG[feature]
 
 		if 'lib_deps' in feat and len(feat['lib_deps']):
 			blab("Adding lib_deps for %s... " % feature)
 
 			# feat to add
 			deps_to_add = {}
 			for dep in feat['lib_deps']:
-				name = parse_pkg_uri(dep)
-				deps_to_add[name] = dep
+				deps_to_add[PackageSpec(dep).name] = dep
 
 			# Does the env already have the dependency?
 			deps = env.GetProjectOption('lib_deps')
 			for dep in deps:
-				name = parse_pkg_uri(dep)
+				name = PackageSpec(dep).name
 				if name in deps_to_add:
 					del deps_to_add[name]
 
 			# Are there any libraries that should be ignored?
 			lib_ignore = env.GetProjectOption('lib_ignore')
 			for dep in deps:
-				name = parse_pkg_uri(dep)
+				name = PackageSpec(dep).name
 				if name in deps_to_add:
 					del deps_to_add[name]
 
 			# Is there anything left?
 			if len(deps_to_add) > 0:
 				# Only add the missing dependencies
 				set_env_field('lib_deps', deps + list(deps_to_add.values()))
 
 		if 'build_flags' in feat:
 			f = feat['build_flags']

commit 903d0b91fc28b1198e7b90131f94f02a7c3f1530
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 27 22:38:57 2021 -0600

    Tweaks to build scripts

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 30e168d83f..3844d8298a 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -1,17 +1,15 @@
 #
 # common-dependencies.py
 # Convenience script to check dependencies and add libs and sources for Marlin Enabled Features
 #
-import subprocess
-import os
-import re
+import subprocess,os,re
 try:
 	import configparser
 except ImportError:
 	import ConfigParser as configparser
 try:
 	# PIO < 4.4
 	from platformio.managers.package import PackageManager
 except ImportError:
 	# PIO >= 4.4
 	from platformio.package.meta import PackageSpec as PackageManager

commit bb1039d4c91b7bfd282cd5b2b86e1466db80ba28
Author: ellensp <ellensp@hotmail.com>
Date:   Fri Feb 26 03:15:55 2021 +1300

    Preflight checks for PlatformIO builds (#21068)
    
    Co-authored-by: Alexander D. Kanevskiy <alexander.kanevskiy@intel.com>

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 4500f529a6..30e168d83f 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -305,31 +305,20 @@ def MarlinFeatureIsEnabled(env, feature):
 	if len(found):
 		for f in found:
 			val = env['MARLIN_FEATURES'][f]
 			if val in [ '', '1', 'true' ]:
 				some_on = True
 			elif val in env['MARLIN_FEATURES']:
 				some_on = env.MarlinFeatureIsEnabled(val)
 
 	return some_on
 
-#
-# Check for Configfiles in two common incorrect places
-#
-def check_configfile_locations():
-	for p in [ env['PROJECT_DIR'], os.path.join(env['PROJECT_DIR'], "config") ]:
-		for f in [ "Configuration.h", "Configuration_adv.h" ]:
-			if os.path.isfile(os.path.join(p, f)):
-				err = 'ERROR: Config files found in directory ' + str(p) + '. Please move them into the Marlin subdirectory.'
-				raise SystemExit(err)
-
 #
 # Add a method for other PIO scripts to query enabled features
 #
 env.AddMethod(MarlinFeatureIsEnabled)
 
 #
 # Add dependencies for enabled Marlin features
 #
-check_configfile_locations()
 apply_features_config()
 force_ignore_unused_libs()

commit 727bf7dd8cd5f2f1f980fb2c6050c4d177db6246
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 24 21:20:51 2021 -0600

    üõ†Fix deps script version regex

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 4b8c339d46..4500f529a6 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -76,21 +76,21 @@ def add_to_feat_cnf(feature, flines):
 	# Add common options to the features config under construction
 	# For lib_deps replace a previous instance of the same library
 	atoms = re.sub(r',\\s*', '\n', flines).strip().split('\n')
 	for line in atoms:
 		parts = line.split('=')
 		name = parts.pop(0)
 		if name in ['build_flags', 'extra_scripts', 'src_filter', 'lib_ignore']:
 			feat[name] = '='.join(parts)
 		else:
 			for dep in line.split(','):
-				lib_name = re.sub(r'([@~^=]|[<>]=?)[\d.]+', '', dep.strip()).split('=').pop(0)
+				lib_name = re.sub(r'@([~^]|[<>]=?)?[\d.]+', '', dep.strip()).split('=').pop(0)
 				lib_re = re.compile('(?!^' + lib_name + '\\b)')
 				feat['lib_deps'] = list(filter(lib_re.match, feat['lib_deps'])) + [dep]
 
 def load_config():
 	config = configparser.ConfigParser()
 	config.read("platformio.ini")
 	items = config.items('features')
 	for key in items:
 		feature = key[0].upper()
 		if not feature in FEATURE_CONFIG:

commit a54154e760c0e3012b7841b317b277353174354d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 22 20:51:58 2021 -0600

    üõ† Replace lib_deps for custom_marlin.FEATURE (#20858)

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 2f4ad3e502..4b8c339d46 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -62,30 +62,37 @@ def parse_pkg_uri(spec):
 
 FEATURE_CONFIG = {}
 
 def add_to_feat_cnf(feature, flines):
 
 	try:
 		feat = FEATURE_CONFIG[feature]
 	except:
 		FEATURE_CONFIG[feature] = {}
 
+	# Get a reference to the FEATURE_CONFIG under construction
 	feat = FEATURE_CONFIG[feature]
-	atoms = re.sub(',\\s*', '\n', flines).strip().split('\n')
-	for dep in atoms:
-		parts = dep.split('=')
+
+	# Split up passed lines on commas or newlines and iterate
+	# Add common options to the features config under construction
+	# For lib_deps replace a previous instance of the same library
+	atoms = re.sub(r',\\s*', '\n', flines).strip().split('\n')
+	for line in atoms:
+		parts = line.split('=')
 		name = parts.pop(0)
-		rest = '='.join(parts)
 		if name in ['build_flags', 'extra_scripts', 'src_filter', 'lib_ignore']:
-			feat[name] = rest
+			feat[name] = '='.join(parts)
 		else:
-			feat['lib_deps'] += [dep]
+			for dep in line.split(','):
+				lib_name = re.sub(r'([@~^=]|[<>]=?)[\d.]+', '', dep.strip()).split('=').pop(0)
+				lib_re = re.compile('(?!^' + lib_name + '\\b)')
+				feat['lib_deps'] = list(filter(lib_re.match, feat['lib_deps'])) + [dep]
 
 def load_config():
 	config = configparser.ConfigParser()
 	config.read("platformio.ini")
 	items = config.items('features')
 	for key in items:
 		feature = key[0].upper()
 		if not feature in FEATURE_CONFIG:
 			FEATURE_CONFIG[feature] = { 'lib_deps': [] }
 		add_to_feat_cnf(feature, key[1])
@@ -178,22 +185,22 @@ def apply_features_config():
 			env.Replace(BUILD_FLAGS=new_flags)
 
 		if 'extra_scripts' in feat:
 			blab("Running extra_scripts for %s... " % feature)
 			env.SConscript(feat['extra_scripts'], exports="env")
 
 		if 'src_filter' in feat:
 			blab("Adding src_filter for %s... " % feature)
 			src_filter = ' '.join(env.GetProjectOption('src_filter'))
 			# first we need to remove the references to the same folder
-			my_srcs = re.findall( r'[+-](<.*?>)', feat['src_filter'])
-			cur_srcs = re.findall( r'[+-](<.*?>)', src_filter)
+			my_srcs = re.findall(r'[+-](<.*?>)', feat['src_filter'])
+			cur_srcs = re.findall(r'[+-](<.*?>)', src_filter)
 			for d in my_srcs:
 				if d in cur_srcs:
 					src_filter = re.sub(r'[+-]' + d, '', src_filter)
 
 			src_filter = feat['src_filter'] + ' ' + src_filter
 			set_env_field('src_filter', [src_filter])
 			env.Replace(SRC_FILTER=src_filter)
 
 		if 'lib_ignore' in feat:
 			blab("Adding lib_ignore for %s... " % feature)

commit 8ffae97128524d404ae06253aeb8085ee25fb91c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 8 18:51:54 2021 -0600

    Fix Python 2.7 compatibility
    
    Fix regression from #20692

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 73c1727d6a..2f4ad3e502 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -125,33 +125,33 @@ def set_env_field(field, value):
 	proj = env.GetProjectConfig()
 	proj.set("env:" + env['PIOENV'], field, value)
 
 # All unused libs should be ignored so that if a library
 # exists in .pio/lib_deps it will not break compilation.
 def force_ignore_unused_libs():
 	env_libs = get_all_env_libs()
 	known_libs = get_all_known_libs()
 	diff = (list(set(known_libs) - set(env_libs)))
 	lib_ignore = env.GetProjectOption('lib_ignore') + diff
-	blab(f'Ignore libraries: {lib_ignore}')
+	blab("Ignore libraries: %s" % lib_ignore)
 	set_env_field('lib_ignore', lib_ignore)
 
 def apply_features_config():
 	load_config()
 	for feature in FEATURE_CONFIG:
 		if not env.MarlinFeatureIsEnabled(feature):
 			continue
 
 		feat = FEATURE_CONFIG[feature]
 
 		if 'lib_deps' in feat and len(feat['lib_deps']):
-			blab(f'Adding lib_deps for {feature}...')
+			blab("Adding lib_deps for %s... " % feature)
 
 			# feat to add
 			deps_to_add = {}
 			for dep in feat['lib_deps']:
 				name = parse_pkg_uri(dep)
 				deps_to_add[name] = dep
 
 			# Does the env already have the dependency?
 			deps = env.GetProjectOption('lib_deps')
 			for dep in deps:
@@ -166,62 +166,62 @@ def apply_features_config():
 				if name in deps_to_add:
 					del deps_to_add[name]
 
 			# Is there anything left?
 			if len(deps_to_add) > 0:
 				# Only add the missing dependencies
 				set_env_field('lib_deps', deps + list(deps_to_add.values()))
 
 		if 'build_flags' in feat:
 			f = feat['build_flags']
-			blab(f'Adding build_flags for {feature}: {f}')
+			blab("Adding build_flags for %s: %s" % (feature, f))
 			new_flags = env.GetProjectOption('build_flags') + [ f ]
 			env.Replace(BUILD_FLAGS=new_flags)
 
 		if 'extra_scripts' in feat:
-			blab(f'Running extra_scripts for {feature}...')
+			blab("Running extra_scripts for %s... " % feature)
 			env.SConscript(feat['extra_scripts'], exports="env")
 
 		if 'src_filter' in feat:
-			blab(f'Adding src_filter for {feature}...')
+			blab("Adding src_filter for %s... " % feature)
 			src_filter = ' '.join(env.GetProjectOption('src_filter'))
 			# first we need to remove the references to the same folder
 			my_srcs = re.findall( r'[+-](<.*?>)', feat['src_filter'])
 			cur_srcs = re.findall( r'[+-](<.*?>)', src_filter)
 			for d in my_srcs:
 				if d in cur_srcs:
 					src_filter = re.sub(r'[+-]' + d, '', src_filter)
 
 			src_filter = feat['src_filter'] + ' ' + src_filter
 			set_env_field('src_filter', [src_filter])
 			env.Replace(SRC_FILTER=src_filter)
 
 		if 'lib_ignore' in feat:
-			blab(f'Adding lib_ignore for {feature}...')
+			blab("Adding lib_ignore for %s... " % feature)
 			lib_ignore = env.GetProjectOption('lib_ignore') + [feat['lib_ignore']]
 			set_env_field('lib_ignore', lib_ignore)
 
 #
 # Find a compiler, considering the OS
 #
 ENV_BUILD_PATH = os.path.join(env.Dictionary('PROJECT_BUILD_DIR'), env['PIOENV'])
 GCC_PATH_CACHE = os.path.join(ENV_BUILD_PATH, ".gcc_path")
 def search_compiler():
 	try:
 		filepath = env.GetProjectOption('custom_gcc')
-		blab('Getting compiler from env')
+		blab("Getting compiler from env")
 		return filepath
 	except:
 		pass
 
 	if os.path.exists(GCC_PATH_CACHE):
-		blab('Getting g++ path from cache')
+		blab("Getting g++ path from cache")
 		with open(GCC_PATH_CACHE, 'r') as f:
 			return f.read()
 
 	# Find the current platform compiler by searching the $PATH
 	# which will be in a platformio toolchain bin folder
 	path_regex = re.escape(env['PROJECT_PACKAGES_DIR'])
 	gcc = "g++"
 	if env['PLATFORM'] == 'win32':
 		path_separator = ';'
 		path_regex += r'.*\\bin'
@@ -234,28 +234,28 @@ def search_compiler():
 	for pathdir in env['ENV']['PATH'].split(path_separator):
 		if not re.search(path_regex, pathdir, re.IGNORECASE):
 			continue
 		for filepath in os.listdir(pathdir):
 			if not filepath.endswith(gcc):
 				continue
 			# Use entire path to not rely on env PATH
 			filepath = os.path.sep.join([pathdir, filepath])
 			# Cache the g++ path to no search always
 			if os.path.exists(ENV_BUILD_PATH):
-				blab('Caching g++ for current env')
+				blab("Caching g++ for current env")
 				with open(GCC_PATH_CACHE, 'w+') as f:
 					f.write(filepath)
 
 			return filepath
 
 	filepath = env.get('CXX')
-	blab(f"Couldn't find a compiler! Fallback to {filepath}")
+	blab("Couldn't find a compiler! Fallback to %s" % filepath)
 	return filepath
 
 #
 # Use the compiler to get a list of all enabled features
 #
 def load_marlin_features():
 	if 'MARLIN_FEATURES' in env:
 		return
 
 	# Process defines

commit 3dd1fe42112f18792c5e47c3eff110870a9c9f13
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 5 21:03:13 2021 -0600

    Custom build_flags by feature (#20692)

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 24a2eadf9a..73c1727d6a 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -68,21 +68,21 @@ def add_to_feat_cnf(feature, flines):
 		feat = FEATURE_CONFIG[feature]
 	except:
 		FEATURE_CONFIG[feature] = {}
 
 	feat = FEATURE_CONFIG[feature]
 	atoms = re.sub(',\\s*', '\n', flines).strip().split('\n')
 	for dep in atoms:
 		parts = dep.split('=')
 		name = parts.pop(0)
 		rest = '='.join(parts)
-		if name in ['extra_scripts', 'src_filter', 'lib_ignore']:
+		if name in ['build_flags', 'extra_scripts', 'src_filter', 'lib_ignore']:
 			feat[name] = rest
 		else:
 			feat['lib_deps'] += [dep]
 
 def load_config():
 	config = configparser.ConfigParser()
 	config.read("platformio.ini")
 	items = config.items('features')
 	for key in items:
 		feature = key[0].upper()
@@ -125,34 +125,33 @@ def set_env_field(field, value):
 	proj = env.GetProjectConfig()
 	proj.set("env:" + env['PIOENV'], field, value)
 
 # All unused libs should be ignored so that if a library
 # exists in .pio/lib_deps it will not break compilation.
 def force_ignore_unused_libs():
 	env_libs = get_all_env_libs()
 	known_libs = get_all_known_libs()
 	diff = (list(set(known_libs) - set(env_libs)))
 	lib_ignore = env.GetProjectOption('lib_ignore') + diff
-	if verbose:
-		print("Ignore libraries:", lib_ignore)
+	blab(f'Ignore libraries: {lib_ignore}')
 	set_env_field('lib_ignore', lib_ignore)
 
 def apply_features_config():
 	load_config()
 	for feature in FEATURE_CONFIG:
 		if not env.MarlinFeatureIsEnabled(feature):
 			continue
 
 		feat = FEATURE_CONFIG[feature]
 
 		if 'lib_deps' in feat and len(feat['lib_deps']):
-			blab("Adding lib_deps for %s... " % feature)
+			blab(f'Adding lib_deps for {feature}...')
 
 			# feat to add
 			deps_to_add = {}
 			for dep in feat['lib_deps']:
 				name = parse_pkg_uri(dep)
 				deps_to_add[name] = dep
 
 			# Does the env already have the dependency?
 			deps = env.GetProjectOption('lib_deps')
 			for dep in deps:
@@ -165,40 +164,46 @@ def apply_features_config():
 			for dep in deps:
 				name = parse_pkg_uri(dep)
 				if name in deps_to_add:
 					del deps_to_add[name]
 
 			# Is there anything left?
 			if len(deps_to_add) > 0:
 				# Only add the missing dependencies
 				set_env_field('lib_deps', deps + list(deps_to_add.values()))
 
+		if 'build_flags' in feat:
+			f = feat['build_flags']
+			blab(f'Adding build_flags for {feature}: {f}')
+			new_flags = env.GetProjectOption('build_flags') + [ f ]
+			env.Replace(BUILD_FLAGS=new_flags)
+
 		if 'extra_scripts' in feat:
-			blab("Running extra_scripts for %s... " % feature)
+			blab(f'Running extra_scripts for {feature}...')
 			env.SConscript(feat['extra_scripts'], exports="env")
 
 		if 'src_filter' in feat:
-			blab("Adding src_filter for %s... " % feature)
+			blab(f'Adding src_filter for {feature}...')
 			src_filter = ' '.join(env.GetProjectOption('src_filter'))
 			# first we need to remove the references to the same folder
 			my_srcs = re.findall( r'[+-](<.*?>)', feat['src_filter'])
 			cur_srcs = re.findall( r'[+-](<.*?>)', src_filter)
 			for d in my_srcs:
 				if d in cur_srcs:
 					src_filter = re.sub(r'[+-]' + d, '', src_filter)
 
 			src_filter = feat['src_filter'] + ' ' + src_filter
 			set_env_field('src_filter', [src_filter])
 			env.Replace(SRC_FILTER=src_filter)
 
 		if 'lib_ignore' in feat:
-			blab("Adding lib_ignore for %s... " % feature)
+			blab(f'Adding lib_ignore for {feature}...')
 			lib_ignore = env.GetProjectOption('lib_ignore') + [feat['lib_ignore']]
 			set_env_field('lib_ignore', lib_ignore)
 
 #
 # Find a compiler, considering the OS
 #
 ENV_BUILD_PATH = os.path.join(env.Dictionary('PROJECT_BUILD_DIR'), env['PIOENV'])
 GCC_PATH_CACHE = os.path.join(ENV_BUILD_PATH, ".gcc_path")
 def search_compiler():
 	try:
@@ -236,21 +241,21 @@ def search_compiler():
 			filepath = os.path.sep.join([pathdir, filepath])
 			# Cache the g++ path to no search always
 			if os.path.exists(ENV_BUILD_PATH):
 				blab('Caching g++ for current env')
 				with open(GCC_PATH_CACHE, 'w+') as f:
 					f.write(filepath)
 
 			return filepath
 
 	filepath = env.get('CXX')
-	blab("Couldn't find a compiler! Fallback to %s" % filepath)
+	blab(f"Couldn't find a compiler! Fallback to {filepath}")
 	return filepath
 
 #
 # Use the compiler to get a list of all enabled features
 #
 def load_marlin_features():
 	if 'MARLIN_FEATURES' in env:
 		return
 
 	# Process defines

commit 56a5d0b2872cbe2e5a3b09ca3b668eeeec8e25b9
Author: ellensp <ellensp@hotmail.com>
Date:   Sun Jan 3 13:37:47 2021 +1300

    Homing code followup (#20632)
    
    Patching a87e5197cfb2f302c3eea9271b4c25c49df3ab6b

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index ff7b9f024b..24a2eadf9a 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -311,13 +311,13 @@ def check_configfile_locations():
 				raise SystemExit(err)
 
 #
 # Add a method for other PIO scripts to query enabled features
 #
 env.AddMethod(MarlinFeatureIsEnabled)
 
 #
 # Add dependencies for enabled Marlin features
 #
-check_configfile_locations() 
+check_configfile_locations()
 apply_features_config()
 force_ignore_unused_libs()

commit b0585e13d84758e344f1b8bcadea32534f56f455
Author: ellensp <ellensp@hotmail.com>
Date:   Sat Jan 2 21:51:35 2021 +1300

    Check for misplaced configs on build (#20599)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 56dc86e634..ff7b9f024b 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -293,20 +293,31 @@ def MarlinFeatureIsEnabled(env, feature):
 	if len(found):
 		for f in found:
 			val = env['MARLIN_FEATURES'][f]
 			if val in [ '', '1', 'true' ]:
 				some_on = True
 			elif val in env['MARLIN_FEATURES']:
 				some_on = env.MarlinFeatureIsEnabled(val)
 
 	return some_on
 
+#
+# Check for Configfiles in two common incorrect places
+#
+def check_configfile_locations():
+	for p in [ env['PROJECT_DIR'], os.path.join(env['PROJECT_DIR'], "config") ]:
+		for f in [ "Configuration.h", "Configuration_adv.h" ]:
+			if os.path.isfile(os.path.join(p, f)):
+				err = 'ERROR: Config files found in directory ' + str(p) + '. Please move them into the Marlin subdirectory.'
+				raise SystemExit(err)
+
 #
 # Add a method for other PIO scripts to query enabled features
 #
 env.AddMethod(MarlinFeatureIsEnabled)
 
 #
 # Add dependencies for enabled Marlin features
 #
+check_configfile_locations() 
 apply_features_config()
 force_ignore_unused_libs()

commit 3eddbc7286ce2dd5a14ceb848ef26fd1dd7a3c4c
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Thu Dec 3 14:23:48 2020 -0300

    Require minimum PlatformIO version (#20361)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: Jason Smith <jason.inet@gmail.com>

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index f3bc2b9b02..56dc86e634 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -9,20 +9,44 @@ try:
 	import configparser
 except ImportError:
 	import ConfigParser as configparser
 try:
 	# PIO < 4.4
 	from platformio.managers.package import PackageManager
 except ImportError:
 	# PIO >= 4.4
 	from platformio.package.meta import PackageSpec as PackageManager
 
+PIO_VERSION_MIN = (5, 0, 3)
+try:
+	from platformio import VERSION as PIO_VERSION
+	weights = (1000, 100, 1)
+	version_min = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION_MIN)])
+	version_cur = sum([x[0] * float(re.sub(r'[^0-9]', '.', str(x[1]))) for x in zip(weights, PIO_VERSION)])
+	if version_cur < version_min:
+		print()
+		print("**************************************************")
+		print("******      An update to PlatformIO is      ******")
+		print("******  required to build Marlin Firmware.  ******")
+		print("******                                      ******")
+		print("******      Minimum version: ", PIO_VERSION_MIN, "    ******")
+		print("******      Current Version: ", PIO_VERSION, "    ******")
+		print("******                                      ******")
+		print("******   Update PlatformIO and try again.   ******")
+		print("**************************************************")
+		print()
+		exit(1)
+except SystemExit:
+	exit(1)
+except:
+	print("Can't detect PlatformIO Version")
+
 Import("env")
 
 #print(env.Dump())
 
 try:
 	verbose = int(env.GetProjectOption('custom_verbose'))
 except:
 	verbose = 0
 
 def blab(str):

commit 18a5000718478a51ebde8955d7707d2f9cabd362
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Thu Oct 29 01:45:10 2020 -0300

    Permit spaces in dependencies g++ path (#19929)

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index b9cefeab7c..f3bc2b9b02 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -227,21 +227,21 @@ def search_compiler():
 #
 def load_marlin_features():
 	if 'MARLIN_FEATURES' in env:
 		return
 
 	# Process defines
 	build_flags = env.get('BUILD_FLAGS')
 	build_flags = env.ParseFlagsExtended(build_flags)
 
 	cxx = search_compiler()
-	cmd = [cxx]
+	cmd = ['"' + cxx + '"']
 
 	# Build flags from board.json
 	#if 'BOARD' in env:
 	#	cmd += [env.BoardConfig().get("build.extra_flags")]
 	for s in build_flags['CPPDEFINES']:
 		if isinstance(s, tuple):
 			cmd += ['-D' + s[0] + '=' + str(s[1])]
 		else:
 			cmd += ['-D' + s]
 

commit b632b52b11cb116b70b51d15b0ecb17f5e2512b8
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Oct 24 18:25:14 2020 -0300

    Update PIO dependencies script

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 4b4bba6258..b9cefeab7c 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -201,21 +201,22 @@ def search_compiler():
 		path_separator = ':'
 		path_regex += r'/.+/bin'
 
 	# Search for the compiler
 	for pathdir in env['ENV']['PATH'].split(path_separator):
 		if not re.search(path_regex, pathdir, re.IGNORECASE):
 			continue
 		for filepath in os.listdir(pathdir):
 			if not filepath.endswith(gcc):
 				continue
-
+			# Use entire path to not rely on env PATH
+			filepath = os.path.sep.join([pathdir, filepath])
 			# Cache the g++ path to no search always
 			if os.path.exists(ENV_BUILD_PATH):
 				blab('Caching g++ for current env')
 				with open(GCC_PATH_CACHE, 'w+') as f:
 					f.write(filepath)
 
 			return filepath
 
 	filepath = env.get('CXX')
 	blab("Couldn't find a compiler! Fallback to %s" % filepath)

commit 0988af453c567fae1796cc821bbc41e930b45836
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 9 16:42:23 2020 -0500

    Optional `M42`/`M226`; Add more features filters (#19664)

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 6005855156..4b4bba6258 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -32,20 +32,26 @@ def blab(str):
 def parse_pkg_uri(spec):
 	if PackageManager.__name__ == 'PackageSpec':
 		return PackageManager(spec).name
 	else:
 		name, _, _ = PackageManager.parse_pkg_uri(spec)
 		return name
 
 FEATURE_CONFIG = {}
 
 def add_to_feat_cnf(feature, flines):
+
+	try:
+		feat = FEATURE_CONFIG[feature]
+	except:
+		FEATURE_CONFIG[feature] = {}
+
 	feat = FEATURE_CONFIG[feature]
 	atoms = re.sub(',\\s*', '\n', flines).strip().split('\n')
 	for dep in atoms:
 		parts = dep.split('=')
 		name = parts.pop(0)
 		rest = '='.join(parts)
 		if name in ['extra_scripts', 'src_filter', 'lib_ignore']:
 			feat[name] = rest
 		else:
 			feat['lib_deps'] += [dep]
@@ -231,21 +237,21 @@ def load_marlin_features():
 
 	# Build flags from board.json
 	#if 'BOARD' in env:
 	#	cmd += [env.BoardConfig().get("build.extra_flags")]
 	for s in build_flags['CPPDEFINES']:
 		if isinstance(s, tuple):
 			cmd += ['-D' + s[0] + '=' + str(s[1])]
 		else:
 			cmd += ['-D' + s]
 
-	cmd += ['-D__MARLIN_PREBUILD__ -w -dM -E -x c++ buildroot/share/PlatformIO/scripts/common-dependencies.h']
+	cmd += ['-D__MARLIN_DEPS__ -w -dM -E -x c++ buildroot/share/PlatformIO/scripts/common-dependencies.h']
 	cmd = ' '.join(cmd)
 	blab(cmd)
 	define_list = subprocess.check_output(cmd, shell=True).splitlines()
 	marlin_features = {}
 	for define in define_list:
 		feature = define[8:].strip().decode().split(' ')
 		feature, definition = feature[0], ' '.join(feature[1:])
 		marlin_features[feature] = definition
 	env['MARLIN_FEATURES'] = marlin_features
 

commit 90bc1993b6811623dd9d0de00251e0c63415cb49
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Wed Sep 23 17:06:36 2020 -0300

    Include pins.h in dependencies script (#19468)

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index def3bf40c2..6005855156 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -231,21 +231,21 @@ def load_marlin_features():
 
 	# Build flags from board.json
 	#if 'BOARD' in env:
 	#	cmd += [env.BoardConfig().get("build.extra_flags")]
 	for s in build_flags['CPPDEFINES']:
 		if isinstance(s, tuple):
 			cmd += ['-D' + s[0] + '=' + str(s[1])]
 		else:
 			cmd += ['-D' + s]
 
-	cmd += ['-w -dM -E -x c++ buildroot/share/PlatformIO/scripts/common-dependencies.h']
+	cmd += ['-D__MARLIN_PREBUILD__ -w -dM -E -x c++ buildroot/share/PlatformIO/scripts/common-dependencies.h']
 	cmd = ' '.join(cmd)
 	blab(cmd)
 	define_list = subprocess.check_output(cmd, shell=True).splitlines()
 	marlin_features = {}
 	for define in define_list:
 		feature = define[8:].strip().decode().split(' ')
 		feature, definition = feature[0], ' '.join(feature[1:])
 		marlin_features[feature] = definition
 	env['MARLIN_FEATURES'] = marlin_features
 

commit 28a0650cf3dcc14f8dadf0b13ccc44b506207617
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 20 02:47:16 2020 -0500

    Add custom_verbose, custom_gcc deps flags

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index d5f6fc1958..def3bf40c2 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -11,29 +11,40 @@ except ImportError:
 	import ConfigParser as configparser
 try:
 	# PIO < 4.4
 	from platformio.managers.package import PackageManager
 except ImportError:
 	# PIO >= 4.4
 	from platformio.package.meta import PackageSpec as PackageManager
 
 Import("env")
 
-FEATURE_CONFIG = {}
+#print(env.Dump())
+
+try:
+	verbose = int(env.GetProjectOption('custom_verbose'))
+except:
+	verbose = 0
+
+def blab(str):
+	if verbose:
+		print(str)
 
 def parse_pkg_uri(spec):
 	if PackageManager.__name__ == 'PackageSpec':
 		return PackageManager(spec).name
 	else:
 		name, _, _ = PackageManager.parse_pkg_uri(spec)
 		return name
 
+FEATURE_CONFIG = {}
+
 def add_to_feat_cnf(feature, flines):
 	feat = FEATURE_CONFIG[feature]
 	atoms = re.sub(',\\s*', '\n', flines).strip().split('\n')
 	for dep in atoms:
 		parts = dep.split('=')
 		name = parts.pop(0)
 		rest = '='.join(parts)
 		if name in ['extra_scripts', 'src_filter', 'lib_ignore']:
 			feat[name] = rest
 		else:
@@ -84,33 +95,34 @@ def set_env_field(field, value):
 	proj = env.GetProjectConfig()
 	proj.set("env:" + env['PIOENV'], field, value)
 
 # All unused libs should be ignored so that if a library
 # exists in .pio/lib_deps it will not break compilation.
 def force_ignore_unused_libs():
 	env_libs = get_all_env_libs()
 	known_libs = get_all_known_libs()
 	diff = (list(set(known_libs) - set(env_libs)))
 	lib_ignore = env.GetProjectOption('lib_ignore') + diff
-	print("Ignore libraries:", lib_ignore)
+	if verbose:
+		print("Ignore libraries:", lib_ignore)
 	set_env_field('lib_ignore', lib_ignore)
 
 def apply_features_config():
 	load_config()
 	for feature in FEATURE_CONFIG:
 		if not env.MarlinFeatureIsEnabled(feature):
 			continue
 
 		feat = FEATURE_CONFIG[feature]
 
 		if 'lib_deps' in feat and len(feat['lib_deps']):
-			print("Adding lib_deps for %s... " % feature)
+			blab("Adding lib_deps for %s... " % feature)
 
 			# feat to add
 			deps_to_add = {}
 			for dep in feat['lib_deps']:
 				name = parse_pkg_uri(dep)
 				deps_to_add[name] = dep
 
 			# Does the env already have the dependency?
 			deps = env.GetProjectOption('lib_deps')
 			for dep in deps:
@@ -124,111 +136,118 @@ def apply_features_config():
 				name = parse_pkg_uri(dep)
 				if name in deps_to_add:
 					del deps_to_add[name]
 
 			# Is there anything left?
 			if len(deps_to_add) > 0:
 				# Only add the missing dependencies
 				set_env_field('lib_deps', deps + list(deps_to_add.values()))
 
 		if 'extra_scripts' in feat:
-			print("Running extra_scripts for %s... " % feature)
+			blab("Running extra_scripts for %s... " % feature)
 			env.SConscript(feat['extra_scripts'], exports="env")
 
 		if 'src_filter' in feat:
-			print("Adding src_filter for %s... " % feature)
+			blab("Adding src_filter for %s... " % feature)
 			src_filter = ' '.join(env.GetProjectOption('src_filter'))
 			# first we need to remove the references to the same folder
 			my_srcs = re.findall( r'[+-](<.*?>)', feat['src_filter'])
 			cur_srcs = re.findall( r'[+-](<.*?>)', src_filter)
 			for d in my_srcs:
 				if d in cur_srcs:
 					src_filter = re.sub(r'[+-]' + d, '', src_filter)
 
 			src_filter = feat['src_filter'] + ' ' + src_filter
 			set_env_field('src_filter', [src_filter])
 			env.Replace(SRC_FILTER=src_filter)
 
 		if 'lib_ignore' in feat:
-			print("Adding lib_ignore for %s... " % feature)
+			blab("Adding lib_ignore for %s... " % feature)
 			lib_ignore = env.GetProjectOption('lib_ignore') + [feat['lib_ignore']]
 			set_env_field('lib_ignore', lib_ignore)
 
 #
 # Find a compiler, considering the OS
 #
 ENV_BUILD_PATH = os.path.join(env.Dictionary('PROJECT_BUILD_DIR'), env['PIOENV'])
 GCC_PATH_CACHE = os.path.join(ENV_BUILD_PATH, ".gcc_path")
 def search_compiler():
+	try:
+		filepath = env.GetProjectOption('custom_gcc')
+		blab('Getting compiler from env')
+		return filepath
+	except:
+		pass
+
 	if os.path.exists(GCC_PATH_CACHE):
-		print('Getting g++ path from cache')
+		blab('Getting g++ path from cache')
 		with open(GCC_PATH_CACHE, 'r') as f:
 			return f.read()
 
-	# PlatformIO inserts the toolchain bin folder on the front of the $PATH
 	# Find the current platform compiler by searching the $PATH
+	# which will be in a platformio toolchain bin folder
+	path_regex = re.escape(env['PROJECT_PACKAGES_DIR'])
+	gcc = "g++"
 	if env['PLATFORM'] == 'win32':
 		path_separator = ';'
-		path_regex = re.escape(env['PROJECT_PACKAGES_DIR']) + r'.*\\bin'
-		gcc = "g++.exe"
+		path_regex += r'.*\\bin'
+		gcc += ".exe"
 	else:
 		path_separator = ':'
-		path_regex = re.escape(env['PROJECT_PACKAGES_DIR']) + r'.*/bin'
-		gcc = "g++"
+		path_regex += r'/.+/bin'
 
 	# Search for the compiler
-	for path in env['ENV']['PATH'].split(path_separator):
-		if not re.search(path_regex, path, re.IGNORECASE):
+	for pathdir in env['ENV']['PATH'].split(path_separator):
+		if not re.search(path_regex, pathdir, re.IGNORECASE):
 			continue
-		for file in os.listdir(path):
-			if not file.endswith(gcc):
+		for filepath in os.listdir(pathdir):
+			if not filepath.endswith(gcc):
 				continue
 
 			# Cache the g++ path to no search always
 			if os.path.exists(ENV_BUILD_PATH):
-				print('Caching g++ for current env')
+				blab('Caching g++ for current env')
 				with open(GCC_PATH_CACHE, 'w+') as f:
-					f.write(file)
+					f.write(filepath)
 
-			return file
+			return filepath
 
-	file = env.get('CXX')
-	print("Couldn't find a compiler! Fallback to", file)
-	return file
+	filepath = env.get('CXX')
+	blab("Couldn't find a compiler! Fallback to %s" % filepath)
+	return filepath
 
 #
 # Use the compiler to get a list of all enabled features
 #
 def load_marlin_features():
 	if 'MARLIN_FEATURES' in env:
 		return
 
 	# Process defines
-	#print(env.Dump())
 	build_flags = env.get('BUILD_FLAGS')
 	build_flags = env.ParseFlagsExtended(build_flags)
 
 	cxx = search_compiler()
 	cmd = [cxx]
 
 	# Build flags from board.json
 	#if 'BOARD' in env:
 	#	cmd += [env.BoardConfig().get("build.extra_flags")]
 	for s in build_flags['CPPDEFINES']:
 		if isinstance(s, tuple):
 			cmd += ['-D' + s[0] + '=' + str(s[1])]
 		else:
 			cmd += ['-D' + s]
 
 	cmd += ['-w -dM -E -x c++ buildroot/share/PlatformIO/scripts/common-dependencies.h']
 	cmd = ' '.join(cmd)
-	print(cmd)
+	blab(cmd)
 	define_list = subprocess.check_output(cmd, shell=True).splitlines()
 	marlin_features = {}
 	for define in define_list:
 		feature = define[8:].strip().decode().split(' ')
 		feature, definition = feature[0], ' '.join(feature[1:])
 		marlin_features[feature] = definition
 	env['MARLIN_FEATURES'] = marlin_features
 
 #
 # Return True if a matching feature is enabled

commit bb64aa7841b081ccada9384dd2401341601b24e2
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Aug 15 21:38:13 2020 -0300

    Update build script for PIO 4.4 (#19034)

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 6c1b571bf1..d5f6fc1958 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -2,26 +2,38 @@
 # common-dependencies.py
 # Convenience script to check dependencies and add libs and sources for Marlin Enabled Features
 #
 import subprocess
 import os
 import re
 try:
 	import configparser
 except ImportError:
 	import ConfigParser as configparser
-from platformio.managers.package import PackageManager
+try:
+	# PIO < 4.4
+	from platformio.managers.package import PackageManager
+except ImportError:
+	# PIO >= 4.4
+	from platformio.package.meta import PackageSpec as PackageManager
 
 Import("env")
 
 FEATURE_CONFIG = {}
 
+def parse_pkg_uri(spec):
+	if PackageManager.__name__ == 'PackageSpec':
+		return PackageManager(spec).name
+	else:
+		name, _, _ = PackageManager.parse_pkg_uri(spec)
+		return name
+
 def add_to_feat_cnf(feature, flines):
 	feat = FEATURE_CONFIG[feature]
 	atoms = re.sub(',\\s*', '\n', flines).strip().split('\n')
 	for dep in atoms:
 		parts = dep.split('=')
 		name = parts.pop(0)
 		rest = '='.join(parts)
 		if name in ['extra_scripts', 'src_filter', 'lib_ignore']:
 			feat[name] = rest
 		else:
@@ -49,29 +61,29 @@ def load_config():
 			if val:
 				add_to_feat_cnf(mat.group(1).upper(), val)
 
 def get_all_known_libs():
 	known_libs = []
 	for feature in FEATURE_CONFIG:
 		feat = FEATURE_CONFIG[feature]
 		if not 'lib_deps' in feat:
 			continue
 		for dep in feat['lib_deps']:
-			name, _, _ = PackageManager.parse_pkg_uri(dep)
+			name = parse_pkg_uri(dep)
 			known_libs.append(name)
 	return known_libs
 
 def get_all_env_libs():
 	env_libs = []
 	lib_deps = env.GetProjectOption('lib_deps')
 	for dep in lib_deps:
-		name, _, _ = PackageManager.parse_pkg_uri(dep)
+		name = parse_pkg_uri(dep)
 		env_libs.append(name)
 	return env_libs
 
 def set_env_field(field, value):
 	proj = env.GetProjectConfig()
 	proj.set("env:" + env['PIOENV'], field, value)
 
 # All unused libs should be ignored so that if a library
 # exists in .pio/lib_deps it will not break compilation.
 def force_ignore_unused_libs():
@@ -89,34 +101,34 @@ def apply_features_config():
 			continue
 
 		feat = FEATURE_CONFIG[feature]
 
 		if 'lib_deps' in feat and len(feat['lib_deps']):
 			print("Adding lib_deps for %s... " % feature)
 
 			# feat to add
 			deps_to_add = {}
 			for dep in feat['lib_deps']:
-				name, _, _ = PackageManager.parse_pkg_uri(dep)
+				name = parse_pkg_uri(dep)
 				deps_to_add[name] = dep
 
 			# Does the env already have the dependency?
 			deps = env.GetProjectOption('lib_deps')
 			for dep in deps:
-				name, _, _ = PackageManager.parse_pkg_uri(dep)
+				name = parse_pkg_uri(dep)
 				if name in deps_to_add:
 					del deps_to_add[name]
 
 			# Are there any libraries that should be ignored?
 			lib_ignore = env.GetProjectOption('lib_ignore')
 			for dep in deps:
-				name, _, _ = PackageManager.parse_pkg_uri(dep)
+				name = parse_pkg_uri(dep)
 				if name in deps_to_add:
 					del deps_to_add[name]
 
 			# Is there anything left?
 			if len(deps_to_add) > 0:
 				# Only add the missing dependencies
 				set_env_field('lib_deps', deps + list(deps_to_add.values()))
 
 		if 'extra_scripts' in feat:
 			print("Running extra_scripts for %s... " % feature)

commit e3c0891d2b6f956ab6dbb8b27e37f8215a1d4903
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Aug 8 20:40:12 2020 -0300

    Fix compiler search in non-default PIO installs (#18960)

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index e09c639ad7..6c1b571bf1 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -149,30 +149,30 @@ GCC_PATH_CACHE = os.path.join(ENV_BUILD_PATH, ".gcc_path")
 def search_compiler():
 	if os.path.exists(GCC_PATH_CACHE):
 		print('Getting g++ path from cache')
 		with open(GCC_PATH_CACHE, 'r') as f:
 			return f.read()
 
 	# PlatformIO inserts the toolchain bin folder on the front of the $PATH
 	# Find the current platform compiler by searching the $PATH
 	if env['PLATFORM'] == 'win32':
 		path_separator = ';'
-		path_regex = r'platformio\\packages.*\\bin'
+		path_regex = re.escape(env['PROJECT_PACKAGES_DIR']) + r'.*\\bin'
 		gcc = "g++.exe"
 	else:
 		path_separator = ':'
-		path_regex = r'platformio/packages.*/bin'
+		path_regex = re.escape(env['PROJECT_PACKAGES_DIR']) + r'.*/bin'
 		gcc = "g++"
 
 	# Search for the compiler
 	for path in env['ENV']['PATH'].split(path_separator):
-		if not re.search(path_regex, path):
+		if not re.search(path_regex, path, re.IGNORECASE):
 			continue
 		for file in os.listdir(path):
 			if not file.endswith(gcc):
 				continue
 
 			# Cache the g++ path to no search always
 			if os.path.exists(ENV_BUILD_PATH):
 				print('Caching g++ for current env')
 				with open(GCC_PATH_CACHE, 'w+') as f:
 					f.write(file)

commit c3fdc7f81ec015fff664c4cddb61077e503e6a3f
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Thu Aug 6 19:33:42 2020 -0300

    Apply PIO-supported custom_option for deps (#18935)

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index ec708b116a..e09c639ad7 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -30,24 +30,24 @@ def add_to_feat_cnf(feature, flines):
 def load_config():
 	config = configparser.ConfigParser()
 	config.read("platformio.ini")
 	items = config.items('features')
 	for key in items:
 		feature = key[0].upper()
 		if not feature in FEATURE_CONFIG:
 			FEATURE_CONFIG[feature] = { 'lib_deps': [] }
 		add_to_feat_cnf(feature, key[1])
 
-	# Add options matching marlin.MY_OPTION to the pile
+	# Add options matching custom_marlin.MY_OPTION to the pile
 	all_opts = env.GetProjectOptions()
 	for n in all_opts:
-		mat = re.match(r'marlin\.(.+)', n[0])
+		mat = re.match(r'custom_marlin\.(.+)', n[0])
 		if mat:
 			try:
 				val = env.GetProjectOption(n[0])
 			except:
 				val = None
 			if val:
 				add_to_feat_cnf(mat.group(1).upper(), val)
 
 def get_all_known_libs():
 	known_libs = []

commit 99ba866d8d3c9abc16558ca12ba34efb9a7922e5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 6 08:14:00 2020 -0500

    Optimize G-code / feature dependencies (#18919)

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 37efaa3743..ec708b116a 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -1,53 +1,68 @@
 #
 # common-dependencies.py
 # Convenience script to check dependencies and add libs and sources for Marlin Enabled Features
 #
 import subprocess
 import os
 import re
 try:
-    import configparser
+	import configparser
 except ImportError:
-    import ConfigParser as configparser
+	import ConfigParser as configparser
 from platformio.managers.package import PackageManager
 
 Import("env")
 
-FEATURE_DEPENDENCIES = {}
+FEATURE_CONFIG = {}
+
+def add_to_feat_cnf(feature, flines):
+	feat = FEATURE_CONFIG[feature]
+	atoms = re.sub(',\\s*', '\n', flines).strip().split('\n')
+	for dep in atoms:
+		parts = dep.split('=')
+		name = parts.pop(0)
+		rest = '='.join(parts)
+		if name in ['extra_scripts', 'src_filter', 'lib_ignore']:
+			feat[name] = rest
+		else:
+			feat['lib_deps'] += [dep]
 
 def load_config():
 	config = configparser.ConfigParser()
 	config.read("platformio.ini")
 	items = config.items('features')
 	for key in items:
-		ukey = key[0].upper()
-		if not ukey in FEATURE_DEPENDENCIES:
-			FEATURE_DEPENDENCIES[ukey] = {
-				'lib_deps': []
-			}
-		deps = re.sub(',\\s*', '\n', key[1]).strip().split('\n')
-		for dep in deps:
-			parts = dep.split('=')
-			name = parts.pop(0)
-			rest = '='.join(parts)
-			if name in ['extra_scripts', 'src_filter', 'lib_ignore']:
-				FEATURE_DEPENDENCIES[ukey][name] = rest
-			else:
-				FEATURE_DEPENDENCIES[ukey]['lib_deps'] += [dep]
+		feature = key[0].upper()
+		if not feature in FEATURE_CONFIG:
+			FEATURE_CONFIG[feature] = { 'lib_deps': [] }
+		add_to_feat_cnf(feature, key[1])
+
+	# Add options matching marlin.MY_OPTION to the pile
+	all_opts = env.GetProjectOptions()
+	for n in all_opts:
+		mat = re.match(r'marlin\.(.+)', n[0])
+		if mat:
+			try:
+				val = env.GetProjectOption(n[0])
+			except:
+				val = None
+			if val:
+				add_to_feat_cnf(mat.group(1).upper(), val)
 
 def get_all_known_libs():
 	known_libs = []
-	for feature in FEATURE_DEPENDENCIES:
-		if not 'lib_deps' in FEATURE_DEPENDENCIES[feature]:
+	for feature in FEATURE_CONFIG:
+		feat = FEATURE_CONFIG[feature]
+		if not 'lib_deps' in feat:
 			continue
-		for dep in FEATURE_DEPENDENCIES[feature]['lib_deps']:
+		for dep in feat['lib_deps']:
 			name, _, _ = PackageManager.parse_pkg_uri(dep)
 			known_libs.append(name)
 	return known_libs
 
 def get_all_env_libs():
 	env_libs = []
 	lib_deps = env.GetProjectOption('lib_deps')
 	for dep in lib_deps:
 		name, _, _ = PackageManager.parse_pkg_uri(dep)
 		env_libs.append(name)
@@ -57,35 +72,37 @@ def set_env_field(field, value):
 	proj = env.GetProjectConfig()
 	proj.set("env:" + env['PIOENV'], field, value)
 
 # All unused libs should be ignored so that if a library
 # exists in .pio/lib_deps it will not break compilation.
 def force_ignore_unused_libs():
 	env_libs = get_all_env_libs()
 	known_libs = get_all_known_libs()
 	diff = (list(set(known_libs) - set(env_libs)))
 	lib_ignore = env.GetProjectOption('lib_ignore') + diff
-	print("Ignoring libs:", lib_ignore)
+	print("Ignore libraries:", lib_ignore)
 	set_env_field('lib_ignore', lib_ignore)
 
-def install_features_dependencies():
+def apply_features_config():
 	load_config()
-	for feature in FEATURE_DEPENDENCIES:
+	for feature in FEATURE_CONFIG:
 		if not env.MarlinFeatureIsEnabled(feature):
 			continue
 
-		if 'lib_deps' in FEATURE_DEPENDENCIES[feature]:
+		feat = FEATURE_CONFIG[feature]
+
+		if 'lib_deps' in feat and len(feat['lib_deps']):
 			print("Adding lib_deps for %s... " % feature)
 
-			# deps to add
+			# feat to add
 			deps_to_add = {}
-			for dep in FEATURE_DEPENDENCIES[feature]['lib_deps']:
+			for dep in feat['lib_deps']:
 				name, _, _ = PackageManager.parse_pkg_uri(dep)
 				deps_to_add[name] = dep
 
 			# Does the env already have the dependency?
 			deps = env.GetProjectOption('lib_deps')
 			for dep in deps:
 				name, _, _ = PackageManager.parse_pkg_uri(dep)
 				if name in deps_to_add:
 					del deps_to_add[name]
 
@@ -94,41 +111,41 @@ def install_features_dependencies():
 			for dep in deps:
 				name, _, _ = PackageManager.parse_pkg_uri(dep)
 				if name in deps_to_add:
 					del deps_to_add[name]
 
 			# Is there anything left?
 			if len(deps_to_add) > 0:
 				# Only add the missing dependencies
 				set_env_field('lib_deps', deps + list(deps_to_add.values()))
 
-		if 'extra_scripts' in FEATURE_DEPENDENCIES[feature]:
-			print("Executing extra_scripts for %s... " % feature)
-			env.SConscript(FEATURE_DEPENDENCIES[feature]['extra_scripts'], exports="env")
+		if 'extra_scripts' in feat:
+			print("Running extra_scripts for %s... " % feature)
+			env.SConscript(feat['extra_scripts'], exports="env")
 
-		if 'src_filter' in FEATURE_DEPENDENCIES[feature]:
+		if 'src_filter' in feat:
 			print("Adding src_filter for %s... " % feature)
 			src_filter = ' '.join(env.GetProjectOption('src_filter'))
 			# first we need to remove the references to the same folder
-			my_srcs = re.findall( r'[+-](<.*?>)', FEATURE_DEPENDENCIES[feature]['src_filter'])
+			my_srcs = re.findall( r'[+-](<.*?>)', feat['src_filter'])
 			cur_srcs = re.findall( r'[+-](<.*?>)', src_filter)
 			for d in my_srcs:
 				if d in cur_srcs:
 					src_filter = re.sub(r'[+-]' + d, '', src_filter)
 
-			src_filter = FEATURE_DEPENDENCIES[feature]['src_filter'] + ' ' + src_filter
+			src_filter = feat['src_filter'] + ' ' + src_filter
 			set_env_field('src_filter', [src_filter])
 			env.Replace(SRC_FILTER=src_filter)
 
-		if 'lib_ignore' in FEATURE_DEPENDENCIES[feature]:
-			print("Ignoring libs for %s... " % feature)
-			lib_ignore = env.GetProjectOption('lib_ignore') + [FEATURE_DEPENDENCIES[feature]['lib_ignore']]
+		if 'lib_ignore' in feat:
+			print("Adding lib_ignore for %s... " % feature)
+			lib_ignore = env.GetProjectOption('lib_ignore') + [feat['lib_ignore']]
 			set_env_field('lib_ignore', lib_ignore)
 
 #
 # Find a compiler, considering the OS
 #
 ENV_BUILD_PATH = os.path.join(env.Dictionary('PROJECT_BUILD_DIR'), env['PIOENV'])
 GCC_PATH_CACHE = os.path.join(ENV_BUILD_PATH, ".gcc_path")
 def search_compiler():
 	if os.path.exists(GCC_PATH_CACHE):
 		print('Getting g++ path from cache')
@@ -163,21 +180,21 @@ def search_compiler():
 			return file
 
 	file = env.get('CXX')
 	print("Couldn't find a compiler! Fallback to", file)
 	return file
 
 #
 # Use the compiler to get a list of all enabled features
 #
 def load_marlin_features():
-	if "MARLIN_FEATURES" in env:
+	if 'MARLIN_FEATURES' in env:
 		return
 
 	# Process defines
 	#print(env.Dump())
 	build_flags = env.get('BUILD_FLAGS')
 	build_flags = env.ParseFlagsExtended(build_flags)
 
 	cxx = search_compiler()
 	cmd = [cxx]
 
@@ -192,31 +209,42 @@ def load_marlin_features():
 
 	cmd += ['-w -dM -E -x c++ buildroot/share/PlatformIO/scripts/common-dependencies.h']
 	cmd = ' '.join(cmd)
 	print(cmd)
 	define_list = subprocess.check_output(cmd, shell=True).splitlines()
 	marlin_features = {}
 	for define in define_list:
 		feature = define[8:].strip().decode().split(' ')
 		feature, definition = feature[0], ' '.join(feature[1:])
 		marlin_features[feature] = definition
-	env["MARLIN_FEATURES"] = marlin_features
+	env['MARLIN_FEATURES'] = marlin_features
 
 #
 # Return True if a matching feature is enabled
 #
 def MarlinFeatureIsEnabled(env, feature):
 	load_marlin_features()
-	r = re.compile(feature)
-	matches = list(filter(r.match, env["MARLIN_FEATURES"]))
-	return len(matches) > 0
+	r = re.compile('^' + feature + '$')
+	found = list(filter(r.match, env['MARLIN_FEATURES']))
+
+	# Defines could still be 'false' or '0', so check
+	some_on = False
+	if len(found):
+		for f in found:
+			val = env['MARLIN_FEATURES'][f]
+			if val in [ '', '1', 'true' ]:
+				some_on = True
+			elif val in env['MARLIN_FEATURES']:
+				some_on = env.MarlinFeatureIsEnabled(val)
+
+	return some_on
 
 #
 # Add a method for other PIO scripts to query enabled features
 #
 env.AddMethod(MarlinFeatureIsEnabled)
 
 #
 # Add dependencies for enabled Marlin features
 #
-install_features_dependencies()
+apply_features_config()
 force_ignore_unused_libs()

commit d0222e5c76276d4bb1c46a4731ec63938f545eb0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jul 25 22:57:00 2020 -0500

    Randomize firmware.bin, fix unflag

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
index 8287c0b202..37efaa3743 100644
--- a/buildroot/share/PlatformIO/scripts/common-dependencies.py
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -40,101 +40,101 @@ def get_all_known_libs():
 	for feature in FEATURE_DEPENDENCIES:
 		if not 'lib_deps' in FEATURE_DEPENDENCIES[feature]:
 			continue
 		for dep in FEATURE_DEPENDENCIES[feature]['lib_deps']:
 			name, _, _ = PackageManager.parse_pkg_uri(dep)
 			known_libs.append(name)
 	return known_libs
 
 def get_all_env_libs():
 	env_libs = []
-	lib_deps = env.GetProjectOption("lib_deps")
+	lib_deps = env.GetProjectOption('lib_deps')
 	for dep in lib_deps:
 		name, _, _ = PackageManager.parse_pkg_uri(dep)
 		env_libs.append(name)
 	return env_libs
 
+def set_env_field(field, value):
+	proj = env.GetProjectConfig()
+	proj.set("env:" + env['PIOENV'], field, value)
+
 # All unused libs should be ignored so that if a library
 # exists in .pio/lib_deps it will not break compilation.
 def force_ignore_unused_libs():
 	env_libs = get_all_env_libs()
 	known_libs = get_all_known_libs()
 	diff = (list(set(known_libs) - set(env_libs)))
-	lib_ignore = env.GetProjectOption("lib_ignore") + diff
+	lib_ignore = env.GetProjectOption('lib_ignore') + diff
 	print("Ignoring libs:", lib_ignore)
-	proj = env.GetProjectConfig()
-	proj.set("env:" + env["PIOENV"], "lib_ignore", lib_ignore)
+	set_env_field('lib_ignore', lib_ignore)
 
 def install_features_dependencies():
 	load_config()
 	for feature in FEATURE_DEPENDENCIES:
 		if not env.MarlinFeatureIsEnabled(feature):
 			continue
 
 		if 'lib_deps' in FEATURE_DEPENDENCIES[feature]:
 			print("Adding lib_deps for %s... " % feature)
 
 			# deps to add
 			deps_to_add = {}
 			for dep in FEATURE_DEPENDENCIES[feature]['lib_deps']:
 				name, _, _ = PackageManager.parse_pkg_uri(dep)
 				deps_to_add[name] = dep
 
 			# Does the env already have the dependency?
-			deps = env.GetProjectOption("lib_deps")
+			deps = env.GetProjectOption('lib_deps')
 			for dep in deps:
 				name, _, _ = PackageManager.parse_pkg_uri(dep)
 				if name in deps_to_add:
 					del deps_to_add[name]
 
 			# Are there any libraries that should be ignored?
-			lib_ignore = env.GetProjectOption("lib_ignore")
+			lib_ignore = env.GetProjectOption('lib_ignore')
 			for dep in deps:
 				name, _, _ = PackageManager.parse_pkg_uri(dep)
 				if name in deps_to_add:
 					del deps_to_add[name]
 
 			# Is there anything left?
 			if len(deps_to_add) > 0:
 				# Only add the missing dependencies
-				proj = env.GetProjectConfig()
-				proj.set("env:" + env["PIOENV"], "lib_deps", deps + list(deps_to_add.values()))
+				set_env_field('lib_deps', deps + list(deps_to_add.values()))
 
 		if 'extra_scripts' in FEATURE_DEPENDENCIES[feature]:
 			print("Executing extra_scripts for %s... " % feature)
 			env.SConscript(FEATURE_DEPENDENCIES[feature]['extra_scripts'], exports="env")
 
 		if 'src_filter' in FEATURE_DEPENDENCIES[feature]:
 			print("Adding src_filter for %s... " % feature)
-			proj = env.GetProjectConfig()
-			src_filter = ' '.join(env.GetProjectOption("src_filter"))
+			src_filter = ' '.join(env.GetProjectOption('src_filter'))
 			# first we need to remove the references to the same folder
 			my_srcs = re.findall( r'[+-](<.*?>)', FEATURE_DEPENDENCIES[feature]['src_filter'])
 			cur_srcs = re.findall( r'[+-](<.*?>)', src_filter)
 			for d in my_srcs:
 				if d in cur_srcs:
 					src_filter = re.sub(r'[+-]' + d, '', src_filter)
 
 			src_filter = FEATURE_DEPENDENCIES[feature]['src_filter'] + ' ' + src_filter
-			proj.set("env:" + env["PIOENV"], "src_filter", [src_filter])
+			set_env_field('src_filter', [src_filter])
 			env.Replace(SRC_FILTER=src_filter)
 
 		if 'lib_ignore' in FEATURE_DEPENDENCIES[feature]:
 			print("Ignoring libs for %s... " % feature)
-			lib_ignore = env.GetProjectOption("lib_ignore") + [FEATURE_DEPENDENCIES[feature]['lib_ignore']]
-			proj = env.GetProjectConfig()
-			proj.set("env:" + env["PIOENV"], "lib_ignore", lib_ignore)
+			lib_ignore = env.GetProjectOption('lib_ignore') + [FEATURE_DEPENDENCIES[feature]['lib_ignore']]
+			set_env_field('lib_ignore', lib_ignore)
 
 #
 # Find a compiler, considering the OS
 #
-ENV_BUILD_PATH = os.path.join(env.Dictionary("PROJECT_BUILD_DIR"), env["PIOENV"])
+ENV_BUILD_PATH = os.path.join(env.Dictionary('PROJECT_BUILD_DIR'), env['PIOENV'])
 GCC_PATH_CACHE = os.path.join(ENV_BUILD_PATH, ".gcc_path")
 def search_compiler():
 	if os.path.exists(GCC_PATH_CACHE):
 		print('Getting g++ path from cache')
 		with open(GCC_PATH_CACHE, 'r') as f:
 			return f.read()
 
 	# PlatformIO inserts the toolchain bin folder on the front of the $PATH
 	# Find the current platform compiler by searching the $PATH
 	if env['PLATFORM'] == 'win32':

commit e02817b07798b92aa31091c78c16581f0c867923
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Jul 25 23:40:44 2020 -0300

    More folders only compiled when their feature is Enabled (#18780)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/buildroot/share/PlatformIO/scripts/common-dependencies.py b/buildroot/share/PlatformIO/scripts/common-dependencies.py
new file mode 100644
index 0000000000..8287c0b202
--- /dev/null
+++ b/buildroot/share/PlatformIO/scripts/common-dependencies.py
@@ -0,0 +1,222 @@
+#
+# common-dependencies.py
+# Convenience script to check dependencies and add libs and sources for Marlin Enabled Features
+#
+import subprocess
+import os
+import re
+try:
+    import configparser
+except ImportError:
+    import ConfigParser as configparser
+from platformio.managers.package import PackageManager
+
+Import("env")
+
+FEATURE_DEPENDENCIES = {}
+
+def load_config():
+	config = configparser.ConfigParser()
+	config.read("platformio.ini")
+	items = config.items('features')
+	for key in items:
+		ukey = key[0].upper()
+		if not ukey in FEATURE_DEPENDENCIES:
+			FEATURE_DEPENDENCIES[ukey] = {
+				'lib_deps': []
+			}
+		deps = re.sub(',\\s*', '\n', key[1]).strip().split('\n')
+		for dep in deps:
+			parts = dep.split('=')
+			name = parts.pop(0)
+			rest = '='.join(parts)
+			if name in ['extra_scripts', 'src_filter', 'lib_ignore']:
+				FEATURE_DEPENDENCIES[ukey][name] = rest
+			else:
+				FEATURE_DEPENDENCIES[ukey]['lib_deps'] += [dep]
+
+def get_all_known_libs():
+	known_libs = []
+	for feature in FEATURE_DEPENDENCIES:
+		if not 'lib_deps' in FEATURE_DEPENDENCIES[feature]:
+			continue
+		for dep in FEATURE_DEPENDENCIES[feature]['lib_deps']:
+			name, _, _ = PackageManager.parse_pkg_uri(dep)
+			known_libs.append(name)
+	return known_libs
+
+def get_all_env_libs():
+	env_libs = []
+	lib_deps = env.GetProjectOption("lib_deps")
+	for dep in lib_deps:
+		name, _, _ = PackageManager.parse_pkg_uri(dep)
+		env_libs.append(name)
+	return env_libs
+
+# All unused libs should be ignored so that if a library
+# exists in .pio/lib_deps it will not break compilation.
+def force_ignore_unused_libs():
+	env_libs = get_all_env_libs()
+	known_libs = get_all_known_libs()
+	diff = (list(set(known_libs) - set(env_libs)))
+	lib_ignore = env.GetProjectOption("lib_ignore") + diff
+	print("Ignoring libs:", lib_ignore)
+	proj = env.GetProjectConfig()
+	proj.set("env:" + env["PIOENV"], "lib_ignore", lib_ignore)
+
+def install_features_dependencies():
+	load_config()
+	for feature in FEATURE_DEPENDENCIES:
+		if not env.MarlinFeatureIsEnabled(feature):
+			continue
+
+		if 'lib_deps' in FEATURE_DEPENDENCIES[feature]:
+			print("Adding lib_deps for %s... " % feature)
+
+			# deps to add
+			deps_to_add = {}
+			for dep in FEATURE_DEPENDENCIES[feature]['lib_deps']:
+				name, _, _ = PackageManager.parse_pkg_uri(dep)
+				deps_to_add[name] = dep
+
+			# Does the env already have the dependency?
+			deps = env.GetProjectOption("lib_deps")
+			for dep in deps:
+				name, _, _ = PackageManager.parse_pkg_uri(dep)
+				if name in deps_to_add:
+					del deps_to_add[name]
+
+			# Are there any libraries that should be ignored?
+			lib_ignore = env.GetProjectOption("lib_ignore")
+			for dep in deps:
+				name, _, _ = PackageManager.parse_pkg_uri(dep)
+				if name in deps_to_add:
+					del deps_to_add[name]
+
+			# Is there anything left?
+			if len(deps_to_add) > 0:
+				# Only add the missing dependencies
+				proj = env.GetProjectConfig()
+				proj.set("env:" + env["PIOENV"], "lib_deps", deps + list(deps_to_add.values()))
+
+		if 'extra_scripts' in FEATURE_DEPENDENCIES[feature]:
+			print("Executing extra_scripts for %s... " % feature)
+			env.SConscript(FEATURE_DEPENDENCIES[feature]['extra_scripts'], exports="env")
+
+		if 'src_filter' in FEATURE_DEPENDENCIES[feature]:
+			print("Adding src_filter for %s... " % feature)
+			proj = env.GetProjectConfig()
+			src_filter = ' '.join(env.GetProjectOption("src_filter"))
+			# first we need to remove the references to the same folder
+			my_srcs = re.findall( r'[+-](<.*?>)', FEATURE_DEPENDENCIES[feature]['src_filter'])
+			cur_srcs = re.findall( r'[+-](<.*?>)', src_filter)
+			for d in my_srcs:
+				if d in cur_srcs:
+					src_filter = re.sub(r'[+-]' + d, '', src_filter)
+
+			src_filter = FEATURE_DEPENDENCIES[feature]['src_filter'] + ' ' + src_filter
+			proj.set("env:" + env["PIOENV"], "src_filter", [src_filter])
+			env.Replace(SRC_FILTER=src_filter)
+
+		if 'lib_ignore' in FEATURE_DEPENDENCIES[feature]:
+			print("Ignoring libs for %s... " % feature)
+			lib_ignore = env.GetProjectOption("lib_ignore") + [FEATURE_DEPENDENCIES[feature]['lib_ignore']]
+			proj = env.GetProjectConfig()
+			proj.set("env:" + env["PIOENV"], "lib_ignore", lib_ignore)
+
+#
+# Find a compiler, considering the OS
+#
+ENV_BUILD_PATH = os.path.join(env.Dictionary("PROJECT_BUILD_DIR"), env["PIOENV"])
+GCC_PATH_CACHE = os.path.join(ENV_BUILD_PATH, ".gcc_path")
+def search_compiler():
+	if os.path.exists(GCC_PATH_CACHE):
+		print('Getting g++ path from cache')
+		with open(GCC_PATH_CACHE, 'r') as f:
+			return f.read()
+
+	# PlatformIO inserts the toolchain bin folder on the front of the $PATH
+	# Find the current platform compiler by searching the $PATH
+	if env['PLATFORM'] == 'win32':
+		path_separator = ';'
+		path_regex = r'platformio\\packages.*\\bin'
+		gcc = "g++.exe"
+	else:
+		path_separator = ':'
+		path_regex = r'platformio/packages.*/bin'
+		gcc = "g++"
+
+	# Search for the compiler
+	for path in env['ENV']['PATH'].split(path_separator):
+		if not re.search(path_regex, path):
+			continue
+		for file in os.listdir(path):
+			if not file.endswith(gcc):
+				continue
+
+			# Cache the g++ path to no search always
+			if os.path.exists(ENV_BUILD_PATH):
+				print('Caching g++ for current env')
+				with open(GCC_PATH_CACHE, 'w+') as f:
+					f.write(file)
+
+			return file
+
+	file = env.get('CXX')
+	print("Couldn't find a compiler! Fallback to", file)
+	return file
+
+#
+# Use the compiler to get a list of all enabled features
+#
+def load_marlin_features():
+	if "MARLIN_FEATURES" in env:
+		return
+
+	# Process defines
+	#print(env.Dump())
+	build_flags = env.get('BUILD_FLAGS')
+	build_flags = env.ParseFlagsExtended(build_flags)
+
+	cxx = search_compiler()
+	cmd = [cxx]
+
+	# Build flags from board.json
+	#if 'BOARD' in env:
+	#	cmd += [env.BoardConfig().get("build.extra_flags")]
+	for s in build_flags['CPPDEFINES']:
+		if isinstance(s, tuple):
+			cmd += ['-D' + s[0] + '=' + str(s[1])]
+		else:
+			cmd += ['-D' + s]
+
+	cmd += ['-w -dM -E -x c++ buildroot/share/PlatformIO/scripts/common-dependencies.h']
+	cmd = ' '.join(cmd)
+	print(cmd)
+	define_list = subprocess.check_output(cmd, shell=True).splitlines()
+	marlin_features = {}
+	for define in define_list:
+		feature = define[8:].strip().decode().split(' ')
+		feature, definition = feature[0], ' '.join(feature[1:])
+		marlin_features[feature] = definition
+	env["MARLIN_FEATURES"] = marlin_features
+
+#
+# Return True if a matching feature is enabled
+#
+def MarlinFeatureIsEnabled(env, feature):
+	load_marlin_features()
+	r = re.compile(feature)
+	matches = list(filter(r.match, env["MARLIN_FEATURES"]))
+	return len(matches) > 0
+
+#
+# Add a method for other PIO scripts to query enabled features
+#
+env.AddMethod(MarlinFeatureIsEnabled)
+
+#
+# Add dependencies for enabled Marlin features
+#
+install_features_dependencies()
+force_ignore_unused_libs()
