commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    üßë‚Äçüíª Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index be431eed0d..28edf9dcdb 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -199,7 +199,7 @@ void GcodeSuite::D(const int16_t dcode) {
       SERIAL_ECHOLNPGM("FAILURE: Watchdog did not trigger board reset.");
     } break;
 
-    #if ENABLED(SDSUPPORT)
+    #if HAS_MEDIA
 
       case 101: { // D101 Test SD Write
         card.openFileWrite("test.gco");
@@ -250,7 +250,7 @@ void GcodeSuite::D(const int16_t dcode) {
         card.closefile();
       } break;
 
-    #endif // SDSUPPORT
+    #endif // HAS_MEDIA
 
     #if ENABLED(POSTMORTEM_DEBUGGING)
 

commit 19bcb77f8788d367f99f60b8c22aeda57607fdca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Dec 20 21:14:58 2022 -0600

    üßë‚Äçüíª Fix D5 warning

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 2ebe38bbcf..be431eed0d 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -156,20 +156,21 @@ void GcodeSuite::D(const int16_t dcode) {
     } break;
 
     case 5: { // D5 Read / Write onboard Flash
-      #define FLASH_SIZE 1024
+              // This will overwrite program and data, so don't use it.
+      #define ONBOARD_FLASH_SIZE 1024 // 0x400
       uint8_t *pointer = parser.hex_adr_val('A');
       uint16_t len = parser.ushortval('C', 1);
       uintptr_t addr = (uintptr_t)pointer;
-      NOMORE(addr, size_t(FLASH_SIZE - 1));
-      NOMORE(len, FLASH_SIZE - addr);
+      NOMORE(addr, size_t(ONBOARD_FLASH_SIZE - 1));
+      NOMORE(len, ONBOARD_FLASH_SIZE - addr);
       if (parser.seenval('X')) {
         // TODO: Write the hex bytes after the X
         //while (len--) {}
       }
       else {
         //while (len--) {
-        //// TODO: Read bytes from EEPROM
-        //  print_hex_byte(eeprom_read_byte(adr++));
+        //// TODO: Read bytes from FLASH
+        //  print_hex_byte(flash_read_byte(adr++));
         //}
         SERIAL_EOL();
       }

commit 52eefa90e1c18616f127cdf43798907880e05ee5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 11:36:13 2022 -0500

    ‚ôªÔ∏è Move watchdog to MarlinHAL

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 2dd1de0001..2ebe38bbcf 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -214,7 +214,7 @@ void GcodeSuite::D(const int16_t dcode) {
 
         c = 1024 * 4;
         while (c--) {
-          TERN_(USE_WATCHDOG, watchdog_refresh());
+          hal.watchdog_refresh();
           card.write(buf, COUNT(buf));
         }
         SERIAL_ECHOLNPGM(" done");
@@ -231,7 +231,7 @@ void GcodeSuite::D(const int16_t dcode) {
         __attribute__((aligned(sizeof(size_t)))) uint8_t buf[512];
         uint16_t c = 1024 * 4;
         while (c--) {
-          TERN_(USE_WATCHDOG, watchdog_refresh());
+          hal.watchdog_refresh();
           card.read(buf, COUNT(buf));
           bool error = false;
           for (uint16_t i = 0; i < COUNT(buf); i++) {

commit 44eff9a23348dcc117fd1ea9b4b1ef0b54061808
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Feb 17 18:50:31 2022 -0600

    ‚ôªÔ∏è Refactor HAL as singleton (#23357)

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 204455e65e..2dd1de0001 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -38,7 +38,7 @@
 #include "../sd/cardreader.h"
 #include "../MarlinCore.h" // for kill
 
-extern void dump_delay_accuracy_check();
+void dump_delay_accuracy_check();
 
 /**
  * Dn: G-code for development and testing
@@ -54,7 +54,7 @@ void GcodeSuite::D(const int16_t dcode) {
       for (;;) { /* loop forever (watchdog reset) */ }
 
     case 0:
-      HAL_reboot();
+      hal.reboot();
       break;
 
     case 10:
@@ -74,7 +74,7 @@ void GcodeSuite::D(const int16_t dcode) {
         settings.reset();
         settings.save();
       #endif
-      HAL_reboot();
+      hal.reboot();
     } break;
 
     case 2: { // D2 Read / Write SRAM
@@ -189,12 +189,12 @@ void GcodeSuite::D(const int16_t dcode) {
       SERIAL_ECHOLNPGM("(USE_WATCHDOG " TERN(USE_WATCHDOG, "ENABLED", "DISABLED") ")");
       thermalManager.disable_all_heaters();
       delay(1000); // Allow time to print
-      DISABLE_ISRS();
+      hal.isr_off();
       // Use a low-level delay that does not rely on interrupts to function
       // Do not spin forever, to avoid thermal risks if heaters are enabled and
       // watchdog does not work.
       for (int i = 10000; i--;) DELAY_US(1000UL);
-      ENABLE_ISRS();
+      hal.isr_on();
       SERIAL_ECHOLNPGM("FAILURE: Watchdog did not trigger board reset.");
     } break;
 

commit 6a8b9274a31d11c396ce1bc44b3a0b872a4606dc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Dec 25 23:15:17 2021 -0600

    ‚è™Ô∏è Refactor still needs work
    
    Reverting #23295

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 2dd1de0001..204455e65e 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -38,7 +38,7 @@
 #include "../sd/cardreader.h"
 #include "../MarlinCore.h" // for kill
 
-void dump_delay_accuracy_check();
+extern void dump_delay_accuracy_check();
 
 /**
  * Dn: G-code for development and testing
@@ -54,7 +54,7 @@ void GcodeSuite::D(const int16_t dcode) {
       for (;;) { /* loop forever (watchdog reset) */ }
 
     case 0:
-      hal.reboot();
+      HAL_reboot();
       break;
 
     case 10:
@@ -74,7 +74,7 @@ void GcodeSuite::D(const int16_t dcode) {
         settings.reset();
         settings.save();
       #endif
-      hal.reboot();
+      HAL_reboot();
     } break;
 
     case 2: { // D2 Read / Write SRAM
@@ -189,12 +189,12 @@ void GcodeSuite::D(const int16_t dcode) {
       SERIAL_ECHOLNPGM("(USE_WATCHDOG " TERN(USE_WATCHDOG, "ENABLED", "DISABLED") ")");
       thermalManager.disable_all_heaters();
       delay(1000); // Allow time to print
-      hal.isr_off();
+      DISABLE_ISRS();
       // Use a low-level delay that does not rely on interrupts to function
       // Do not spin forever, to avoid thermal risks if heaters are enabled and
       // watchdog does not work.
       for (int i = 10000; i--;) DELAY_US(1000UL);
-      hal.isr_on();
+      ENABLE_ISRS();
       SERIAL_ECHOLNPGM("FAILURE: Watchdog did not trigger board reset.");
     } break;
 

commit e211ff148c39bf5dace72de7cffbb83f19d3f1bf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 24 21:33:59 2021 -0600

    ‚ôªÔ∏è Refactor HAL as singleton (#23295)

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 204455e65e..2dd1de0001 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -38,7 +38,7 @@
 #include "../sd/cardreader.h"
 #include "../MarlinCore.h" // for kill
 
-extern void dump_delay_accuracy_check();
+void dump_delay_accuracy_check();
 
 /**
  * Dn: G-code for development and testing
@@ -54,7 +54,7 @@ void GcodeSuite::D(const int16_t dcode) {
       for (;;) { /* loop forever (watchdog reset) */ }
 
     case 0:
-      HAL_reboot();
+      hal.reboot();
       break;
 
     case 10:
@@ -74,7 +74,7 @@ void GcodeSuite::D(const int16_t dcode) {
         settings.reset();
         settings.save();
       #endif
-      HAL_reboot();
+      hal.reboot();
     } break;
 
     case 2: { // D2 Read / Write SRAM
@@ -189,12 +189,12 @@ void GcodeSuite::D(const int16_t dcode) {
       SERIAL_ECHOLNPGM("(USE_WATCHDOG " TERN(USE_WATCHDOG, "ENABLED", "DISABLED") ")");
       thermalManager.disable_all_heaters();
       delay(1000); // Allow time to print
-      DISABLE_ISRS();
+      hal.isr_off();
       // Use a low-level delay that does not rely on interrupts to function
       // Do not spin forever, to avoid thermal risks if heaters are enabled and
       // watchdog does not work.
       for (int i = 10000; i--;) DELAY_US(1000UL);
-      ENABLE_ISRS();
+      hal.isr_on();
       SERIAL_ECHOLNPGM("FAILURE: Watchdog did not trigger board reset.");
     } break;
 

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    üé® Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 83646ef67c..204455e65e 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -58,7 +58,7 @@ void GcodeSuite::D(const int16_t dcode) {
       break;
 
     case 10:
-      kill(PSTR("D10"), PSTR("KILL TEST"), parser.seen_test('P'));
+      kill(F("D10"), F("KILL TEST"), parser.seen_test('P'));
       break;
 
     case 1: {

commit 323b38ee88dbf2a4691a20439dbb95a824822199
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 16 04:36:26 2021 -0500

    üí° Adjust headers, formatting

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 3baff46836..83646ef67c 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -19,6 +19,7 @@
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
+
 #include "../inc/MarlinConfigPre.h"
 
 #if ENABLED(MARLIN_DEV_MODE)

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index b317a17815..3baff46836 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -179,7 +179,7 @@ void GcodeSuite::D(const int16_t dcode) {
       break;
 
     case 7: // D7 dump the current serial port type (hence configuration)
-      SERIAL_ECHOLNPAIR("Current serial configuration RX_BS:", RX_BUFFER_SIZE, ", TX_BS:", TX_BUFFER_SIZE);
+      SERIAL_ECHOLNPGM("Current serial configuration RX_BS:", RX_BUFFER_SIZE, ", TX_BS:", TX_BUFFER_SIZE);
       SERIAL_ECHOLN(gtn(&SERIAL_IMPL));
       break;
 
@@ -202,7 +202,7 @@ void GcodeSuite::D(const int16_t dcode) {
       case 101: { // D101 Test SD Write
         card.openFileWrite("test.gco");
         if (!card.isFileOpen()) {
-          SERIAL_ECHOLNPAIR("Failed to open test.gco to write.");
+          SERIAL_ECHOLNPGM("Failed to open test.gco to write.");
           return;
         }
         __attribute__((aligned(sizeof(size_t)))) uint8_t buf[512];
@@ -224,7 +224,7 @@ void GcodeSuite::D(const int16_t dcode) {
         char testfile[] = "test.gco";
         card.openFileRead(testfile);
         if (!card.isFileOpen()) {
-          SERIAL_ECHOLNPAIR("Failed to open test.gco to read.");
+          SERIAL_ECHOLNPGM("Failed to open test.gco to read.");
           return;
         }
         __attribute__((aligned(sizeof(size_t)))) uint8_t buf[512];

commit 2c49283e97f4bb9cac9577af7c38bcf5e0e06826
Author: chendo <chendo@users.noreply.github.com>
Date:   Fri Jul 23 13:53:00 2021 +1000

    ‚ú® D576 Buffer Monitoring (#19674)

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 52a273964a..b317a17815 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -23,248 +23,279 @@
 
 #if ENABLED(MARLIN_DEV_MODE)
 
-  #include "gcode.h"
-  #include "../module/settings.h"
-  #include "../module/temperature.h"
-  #include "../libs/hex_print.h"
-  #include "../HAL/shared/eeprom_if.h"
-  #include "../HAL/shared/Delay.h"
-  #include "../sd/cardreader.h"
-  #include "../MarlinCore.h" // for kill
+#include "gcode.h"
 
-  extern void dump_delay_accuracy_check();
+#if ENABLED(BUFFER_MONITORING)
+  #include "queue.h"
+#endif
 
-  /**
-   * Dn: G-code for development and testing
-   *
-   * See https://reprap.org/wiki/G-code#D:_Debug_codes
-   *
-   * Put whatever else you need here to test ongoing development.
-   */
-  void GcodeSuite::D(const int16_t dcode) {
-    switch (dcode) {
+#include "../module/settings.h"
+#include "../module/temperature.h"
+#include "../libs/hex_print.h"
+#include "../HAL/shared/eeprom_if.h"
+#include "../HAL/shared/Delay.h"
+#include "../sd/cardreader.h"
+#include "../MarlinCore.h" // for kill
 
-      case -1:
-        for (;;) { /* loop forever (watchdog reset) */ }
+extern void dump_delay_accuracy_check();
 
-      case 0:
-        HAL_reboot();
-        break;
+/**
+ * Dn: G-code for development and testing
+ *
+ * See https://reprap.org/wiki/G-code#D:_Debug_codes
+ *
+ * Put whatever else you need here to test ongoing development.
+ */
+void GcodeSuite::D(const int16_t dcode) {
+  switch (dcode) {
 
-      case 10:
-        kill(PSTR("D10"), PSTR("KILL TEST"), parser.seen_test('P'));
-        break;
+    case -1:
+      for (;;) { /* loop forever (watchdog reset) */ }
 
-      case 1: {
-        // Zero or pattern-fill the EEPROM data
-        #if ENABLED(EEPROM_SETTINGS)
-          persistentStore.access_start();
-          size_t total = persistentStore.capacity();
-          int pos = 0;
-          const uint8_t value = 0x0;
-          while (total--) persistentStore.write_data(pos, &value, 1);
-          persistentStore.access_finish();
-        #else
-          settings.reset();
-          settings.save();
-        #endif
-        HAL_reboot();
-      } break;
+    case 0:
+      HAL_reboot();
+      break;
 
-      case 2: { // D2 Read / Write SRAM
-        #define SRAM_SIZE 8192
-        uint8_t *pointer = parser.hex_adr_val('A');
-        uint16_t len = parser.ushortval('C', 1);
-        uintptr_t addr = (uintptr_t)pointer;
-        NOMORE(addr, size_t(SRAM_SIZE - 1));
-        NOMORE(len, SRAM_SIZE - addr);
-        if (parser.seenval('X')) {
-          // Write the hex bytes after the X
-          uint16_t val = parser.hex_val('X');
-          while (len--) {
-            *pointer = val;
-            pointer++;
-          }
-        }
-        else {
-          while (len--) print_hex_byte(*(pointer++));
-          SERIAL_EOL();
-        }
-      } break;
+    case 10:
+      kill(PSTR("D10"), PSTR("KILL TEST"), parser.seen_test('P'));
+      break;
 
+    case 1: {
+      // Zero or pattern-fill the EEPROM data
       #if ENABLED(EEPROM_SETTINGS)
-        case 3: { // D3 Read / Write EEPROM
-          uint8_t *pointer = parser.hex_adr_val('A');
-          uint16_t len = parser.ushortval('C', 1);
-          uintptr_t addr = (uintptr_t)pointer;
-          NOMORE(addr, size_t(persistentStore.capacity() - 1));
-          NOMORE(len, persistentStore.capacity() - addr);
-          if (parser.seenval('X')) {
-            uint16_t val = parser.hex_val('X');
-            #if ENABLED(EEPROM_SETTINGS)
-              persistentStore.access_start();
-              while (len--) {
-                int pos = 0;
-                persistentStore.write_data(pos, (uint8_t *)&val, sizeof(val));
-              }
-              SERIAL_EOL();
-              persistentStore.access_finish();
-            #else
-              SERIAL_ECHOLNPGM("NO EEPROM");
-            #endif
-          }
-          else {
-            // Read bytes from EEPROM
-            #if ENABLED(EEPROM_SETTINGS)
-              persistentStore.access_start();
-              int pos = 0;
-              uint8_t val;
-              while (len--) if (!persistentStore.read_data(pos, &val, 1)) print_hex_byte(val);
-              SERIAL_EOL();
-              persistentStore.access_finish();
-            #else
-              SERIAL_ECHOLNPGM("NO EEPROM");
-              len = 0;
-            #endif
-            SERIAL_EOL();
-          }
-        } break;
+        persistentStore.access_start();
+        size_t total = persistentStore.capacity();
+        int pos = 0;
+        const uint8_t value = 0x0;
+        while (total--) persistentStore.write_data(pos, &value, 1);
+        persistentStore.access_finish();
+      #else
+        settings.reset();
+        settings.save();
       #endif
+      HAL_reboot();
+    } break;
 
-      case 4: { // D4 Read / Write PIN
-        //const bool is_out = parser.boolval('F');
-        //const uint8_t pin = parser.byteval('P'),
-        //              val = parser.byteval('V', LOW);
-        if (parser.seenval('X')) {
-          // TODO: Write the hex bytes after the X
-          //while (len--) {
-          //}
+    case 2: { // D2 Read / Write SRAM
+      #define SRAM_SIZE 8192
+      uint8_t *pointer = parser.hex_adr_val('A');
+      uint16_t len = parser.ushortval('C', 1);
+      uintptr_t addr = (uintptr_t)pointer;
+      NOMORE(addr, size_t(SRAM_SIZE - 1));
+      NOMORE(len, SRAM_SIZE - addr);
+      if (parser.seenval('X')) {
+        // Write the hex bytes after the X
+        uint16_t val = parser.hex_val('X');
+        while (len--) {
+          *pointer = val;
+          pointer++;
         }
-        else {
-          //while (len--) {
-          //// TODO: Read bytes from EEPROM
-          //  print_hex_byte(eeprom_read_byte(adr++));
-          //}
-          SERIAL_EOL();
-        }
-      } break;
+      }
+      else {
+        while (len--) print_hex_byte(*(pointer++));
+        SERIAL_EOL();
+      }
+    } break;
 
-      case 5: { // D5 Read / Write onboard Flash
-        #define FLASH_SIZE 1024
+    #if ENABLED(EEPROM_SETTINGS)
+      case 3: { // D3 Read / Write EEPROM
         uint8_t *pointer = parser.hex_adr_val('A');
         uint16_t len = parser.ushortval('C', 1);
         uintptr_t addr = (uintptr_t)pointer;
-        NOMORE(addr, size_t(FLASH_SIZE - 1));
-        NOMORE(len, FLASH_SIZE - addr);
+        NOMORE(addr, size_t(persistentStore.capacity() - 1));
+        NOMORE(len, persistentStore.capacity() - addr);
         if (parser.seenval('X')) {
-          // TODO: Write the hex bytes after the X
-          //while (len--) {}
+          uint16_t val = parser.hex_val('X');
+          #if ENABLED(EEPROM_SETTINGS)
+            persistentStore.access_start();
+            while (len--) {
+              int pos = 0;
+              persistentStore.write_data(pos, (uint8_t *)&val, sizeof(val));
+            }
+            SERIAL_EOL();
+            persistentStore.access_finish();
+          #else
+            SERIAL_ECHOLNPGM("NO EEPROM");
+          #endif
         }
         else {
-          //while (len--) {
-          //// TODO: Read bytes from EEPROM
-          //  print_hex_byte(eeprom_read_byte(adr++));
-          //}
+          // Read bytes from EEPROM
+          #if ENABLED(EEPROM_SETTINGS)
+            persistentStore.access_start();
+            int pos = 0;
+            uint8_t val;
+            while (len--) if (!persistentStore.read_data(pos, &val, 1)) print_hex_byte(val);
+            SERIAL_EOL();
+            persistentStore.access_finish();
+          #else
+            SERIAL_ECHOLNPGM("NO EEPROM");
+            len = 0;
+          #endif
           SERIAL_EOL();
         }
       } break;
+    #endif
 
-      case 6: // D6 Check delay loop accuracy
-        dump_delay_accuracy_check();
-        break;
+    case 4: { // D4 Read / Write PIN
+      //const bool is_out = parser.boolval('F');
+      //const uint8_t pin = parser.byteval('P'),
+      //              val = parser.byteval('V', LOW);
+      if (parser.seenval('X')) {
+        // TODO: Write the hex bytes after the X
+        //while (len--) {
+        //}
+      }
+      else {
+        //while (len--) {
+        //// TODO: Read bytes from EEPROM
+        //  print_hex_byte(eeprom_read_byte(adr++));
+        //}
+        SERIAL_EOL();
+      }
+    } break;
 
-      case 7: // D7 dump the current serial port type (hence configuration)
-        SERIAL_ECHOLNPAIR("Current serial configuration RX_BS:", RX_BUFFER_SIZE, ", TX_BS:", TX_BUFFER_SIZE);
-        SERIAL_ECHOLN(gtn(&SERIAL_IMPL));
-        break;
+    case 5: { // D5 Read / Write onboard Flash
+      #define FLASH_SIZE 1024
+      uint8_t *pointer = parser.hex_adr_val('A');
+      uint16_t len = parser.ushortval('C', 1);
+      uintptr_t addr = (uintptr_t)pointer;
+      NOMORE(addr, size_t(FLASH_SIZE - 1));
+      NOMORE(len, FLASH_SIZE - addr);
+      if (parser.seenval('X')) {
+        // TODO: Write the hex bytes after the X
+        //while (len--) {}
+      }
+      else {
+        //while (len--) {
+        //// TODO: Read bytes from EEPROM
+        //  print_hex_byte(eeprom_read_byte(adr++));
+        //}
+        SERIAL_EOL();
+      }
+    } break;
 
-      case 100: { // D100 Disable heaters and attempt a hard hang (Watchdog Test)
-        SERIAL_ECHOLNPGM("Disabling heaters and attempting to trigger Watchdog");
-        SERIAL_ECHOLNPGM("(USE_WATCHDOG " TERN(USE_WATCHDOG, "ENABLED", "DISABLED") ")");
-        thermalManager.disable_all_heaters();
-        delay(1000); // Allow time to print
-        DISABLE_ISRS();
-        // Use a low-level delay that does not rely on interrupts to function
-        // Do not spin forever, to avoid thermal risks if heaters are enabled and
-        // watchdog does not work.
-        for (int i = 10000; i--;) DELAY_US(1000UL);
-        ENABLE_ISRS();
-        SERIAL_ECHOLNPGM("FAILURE: Watchdog did not trigger board reset.");
-      } break;
+    case 6: // D6 Check delay loop accuracy
+      dump_delay_accuracy_check();
+      break;
 
-      #if ENABLED(SDSUPPORT)
+    case 7: // D7 dump the current serial port type (hence configuration)
+      SERIAL_ECHOLNPAIR("Current serial configuration RX_BS:", RX_BUFFER_SIZE, ", TX_BS:", TX_BUFFER_SIZE);
+      SERIAL_ECHOLN(gtn(&SERIAL_IMPL));
+      break;
 
-        case 101: { // D101 Test SD Write
-          card.openFileWrite("test.gco");
-          if (!card.isFileOpen()) {
-            SERIAL_ECHOLNPAIR("Failed to open test.gco to write.");
-            return;
-          }
-          __attribute__((aligned(sizeof(size_t)))) uint8_t buf[512];
+    case 100: { // D100 Disable heaters and attempt a hard hang (Watchdog Test)
+      SERIAL_ECHOLNPGM("Disabling heaters and attempting to trigger Watchdog");
+      SERIAL_ECHOLNPGM("(USE_WATCHDOG " TERN(USE_WATCHDOG, "ENABLED", "DISABLED") ")");
+      thermalManager.disable_all_heaters();
+      delay(1000); // Allow time to print
+      DISABLE_ISRS();
+      // Use a low-level delay that does not rely on interrupts to function
+      // Do not spin forever, to avoid thermal risks if heaters are enabled and
+      // watchdog does not work.
+      for (int i = 10000; i--;) DELAY_US(1000UL);
+      ENABLE_ISRS();
+      SERIAL_ECHOLNPGM("FAILURE: Watchdog did not trigger board reset.");
+    } break;
 
-          uint16_t c;
-          for (c = 0; c < COUNT(buf); c++)
-            buf[c] = 'A' + (c % ('Z' - 'A'));
+    #if ENABLED(SDSUPPORT)
 
-          c = 1024 * 4;
-          while (c--) {
-            TERN_(USE_WATCHDOG, watchdog_refresh());
-            card.write(buf, COUNT(buf));
-          }
-          SERIAL_ECHOLNPGM(" done");
-          card.closefile();
-        } break;
+      case 101: { // D101 Test SD Write
+        card.openFileWrite("test.gco");
+        if (!card.isFileOpen()) {
+          SERIAL_ECHOLNPAIR("Failed to open test.gco to write.");
+          return;
+        }
+        __attribute__((aligned(sizeof(size_t)))) uint8_t buf[512];
 
-        case 102: { // D102 Test SD Read
-          char testfile[] = "test.gco";
-          card.openFileRead(testfile);
-          if (!card.isFileOpen()) {
-            SERIAL_ECHOLNPAIR("Failed to open test.gco to read.");
-            return;
-          }
-          __attribute__((aligned(sizeof(size_t)))) uint8_t buf[512];
-          uint16_t c = 1024 * 4;
-          while (c--) {
-            TERN_(USE_WATCHDOG, watchdog_refresh());
-            card.read(buf, COUNT(buf));
-            bool error = false;
-            for (uint16_t i = 0; i < COUNT(buf); i++) {
-              if (buf[i] != ('A' + (i % ('Z' - 'A')))) {
-                error = true;
-                break;
-              }
-            }
-            if (error) {
-              SERIAL_ECHOLNPGM(" Read error!");
+        uint16_t c;
+        for (c = 0; c < COUNT(buf); c++)
+          buf[c] = 'A' + (c % ('Z' - 'A'));
+
+        c = 1024 * 4;
+        while (c--) {
+          TERN_(USE_WATCHDOG, watchdog_refresh());
+          card.write(buf, COUNT(buf));
+        }
+        SERIAL_ECHOLNPGM(" done");
+        card.closefile();
+      } break;
+
+      case 102: { // D102 Test SD Read
+        char testfile[] = "test.gco";
+        card.openFileRead(testfile);
+        if (!card.isFileOpen()) {
+          SERIAL_ECHOLNPAIR("Failed to open test.gco to read.");
+          return;
+        }
+        __attribute__((aligned(sizeof(size_t)))) uint8_t buf[512];
+        uint16_t c = 1024 * 4;
+        while (c--) {
+          TERN_(USE_WATCHDOG, watchdog_refresh());
+          card.read(buf, COUNT(buf));
+          bool error = false;
+          for (uint16_t i = 0; i < COUNT(buf); i++) {
+            if (buf[i] != ('A' + (i % ('Z' - 'A')))) {
+              error = true;
               break;
             }
           }
-          SERIAL_ECHOLNPGM(" done");
-          card.closefile();
-        } break;
+          if (error) {
+            SERIAL_ECHOLNPGM(" Read error!");
+            break;
+          }
+        }
+        SERIAL_ECHOLNPGM(" done");
+        card.closefile();
+      } break;
 
-      #endif // SDSUPPORT
+    #endif // SDSUPPORT
 
-      #if ENABLED(POSTMORTEM_DEBUGGING)
+    #if ENABLED(POSTMORTEM_DEBUGGING)
 
-        case 451: { // Trigger all kind of faults to test exception catcher
-          SERIAL_ECHOLNPGM("Disabling heaters");
-          thermalManager.disable_all_heaters();
-          delay(1000); // Allow time to print
-          volatile uint8_t type[5] = { parser.byteval('T', 1) };
+      case 451: { // Trigger all kind of faults to test exception catcher
+        SERIAL_ECHOLNPGM("Disabling heaters");
+        thermalManager.disable_all_heaters();
+        delay(1000); // Allow time to print
+        volatile uint8_t type[5] = { parser.byteval('T', 1) };
 
-          // The code below is obviously wrong and it's full of quirks to fool the compiler from optimizing away the code
-          switch (type[0]) {
-            case 1: default: *(int*)0 = 451; break; // Write at bad address
-            case 2: { volatile int a = 0; volatile int b = 452 / a; *(int*)&a = b; } break; // Divide by zero (some CPUs accept this, like ARM)
-            case 3: { *(uint32_t*)&type[1] = 453; volatile int a = *(int*)&type[1]; type[0] = a / 255; } break; // Unaligned access (some CPUs accept this)
-            case 4: { volatile void (*func)() = (volatile void (*)()) 0xE0000000; func(); } break; // Invalid instruction
-          }
-          break;
+        // The code below is obviously wrong and it's full of quirks to fool the compiler from optimizing away the code
+        switch (type[0]) {
+          case 1: default: *(int*)0 = 451; break; // Write at bad address
+          case 2: { volatile int a = 0; volatile int b = 452 / a; *(int*)&a = b; } break; // Divide by zero (some CPUs accept this, like ARM)
+          case 3: { *(uint32_t*)&type[1] = 453; volatile int a = *(int*)&type[1]; type[0] = a / 255; } break; // Unaligned access (some CPUs accept this)
+          case 4: { volatile void (*func)() = (volatile void (*)()) 0xE0000000; func(); } break; // Invalid instruction
         }
+        break;
+      }
 
-      #endif
-    }
+    #endif
+
+    #if ENABLED(BUFFER_MONITORING)
+
+      /**
+       * D576: Return buffer stats or set the auto-report interval.
+       * Usage: D576 [S<seconds>]
+       *
+       * With no parameters emits the following output:
+       * "D576 P<nn> B<nn> PU<nn> PD<nn> BU<nn> BD<nn>"
+       * Where:
+       *   P : Planner buffers free
+       *   B : Command buffers free
+       *   PU: Planner buffer underruns (since the last report)
+       *   PD: Longest duration (ms) the planner buffer was empty (since the last report)
+       *   BU: Command buffer underruns (since the last report)
+       *   BD: Longest duration (ms) command buffer was empty (since the last report)
+       */
+      case 576: {
+        if (parser.seenval('S'))
+          queue.set_auto_report_interval((uint8_t)parser.value_byte());
+        else
+          queue.report_buffer_statistics();
+        break;
+      }
+
+    #endif // BUFFER_MONITORING
   }
+}
 
-#endif
+#endif // MARLIN_DEV_MODE

commit 49548c343deb1e7f38f6027af20c02a79dbe5031
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 9 03:50:51 2021 -0500

    Optimize G-code flag parameters (#21849)

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index a8a6bdfc3d..52a273964a 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -52,7 +52,7 @@
         break;
 
       case 10:
-        kill(PSTR("D10"), PSTR("KILL TEST"), parser.seen('P'));
+        kill(PSTR("D10"), PSTR("KILL TEST"), parser.seen_test('P'));
         break;
 
       case 1: {

commit 636facf40d668bee1cc4c866dab340d1d35d73c4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 28 02:04:07 2021 -0500

    Silence warning in gcode_D

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 74277291e5..a8a6bdfc3d 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -216,7 +216,8 @@
         } break;
 
         case 102: { // D102 Test SD Read
-          card.openFileRead("test.gco");
+          char testfile[] = "test.gco";
+          card.openFileRead(testfile);
           if (!card.isFileOpen()) {
             SERIAL_ECHOLNPAIR("Failed to open test.gco to read.");
             return;

commit d3a2c6a0b47fba8f560ff9ea60e73eb2610ff527
Author: fedetony <45215920+fedetony@users.noreply.github.com>
Date:   Sat Apr 24 09:53:52 2021 +0200

    Soft Reset via Serial or post-kill button click (#21652)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index f87cebc886..74277291e5 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -30,6 +30,7 @@
   #include "../HAL/shared/eeprom_if.h"
   #include "../HAL/shared/Delay.h"
   #include "../sd/cardreader.h"
+  #include "../MarlinCore.h" // for kill
 
   extern void dump_delay_accuracy_check();
 
@@ -44,12 +45,16 @@
     switch (dcode) {
 
       case -1:
-        for (;;); // forever
+        for (;;) { /* loop forever (watchdog reset) */ }
 
       case 0:
         HAL_reboot();
         break;
 
+      case 10:
+        kill(PSTR("D10"), PSTR("KILL TEST"), parser.seen('P'));
+        break;
+
       case 1: {
         // Zero or pattern-fill the EEPROM data
         #if ENABLED(EEPROM_SETTINGS)

commit 6e0b79a33b7e6d5405be6d0ae5b16e5f3fd62fac
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Mon Mar 29 23:52:30 2021 -0300

    Fix and add STM32 SDIO DMA (#21476)

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 8941523a16..f87cebc886 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -29,6 +29,7 @@
   #include "../libs/hex_print.h"
   #include "../HAL/shared/eeprom_if.h"
   #include "../HAL/shared/Delay.h"
+  #include "../sd/cardreader.h"
 
   extern void dump_delay_accuracy_check();
 
@@ -126,19 +127,19 @@
       #endif
 
       case 4: { // D4 Read / Write PIN
-        // const uint8_t pin = parser.byteval('P');
-        // const bool is_out = parser.boolval('F'),
-        //            val = parser.byteval('V', LOW);
+        //const bool is_out = parser.boolval('F');
+        //const uint8_t pin = parser.byteval('P'),
+        //              val = parser.byteval('V', LOW);
         if (parser.seenval('X')) {
           // TODO: Write the hex bytes after the X
           //while (len--) {
           //}
         }
         else {
-          // while (len--) {
-            // TODO: Read bytes from EEPROM
-            // print_hex_byte(eeprom_read_byte(*(adr++));
-          // }
+          //while (len--) {
+          //// TODO: Read bytes from EEPROM
+          //  print_hex_byte(eeprom_read_byte(adr++));
+          //}
           SERIAL_EOL();
         }
       } break;
@@ -155,10 +156,10 @@
           //while (len--) {}
         }
         else {
-          // while (len--) {
-            // TODO: Read bytes from EEPROM
-            // print_hex_byte(eeprom_read_byte(adr++));
-          // }
+          //while (len--) {
+          //// TODO: Read bytes from EEPROM
+          //  print_hex_byte(eeprom_read_byte(adr++));
+          //}
           SERIAL_EOL();
         }
       } break;
@@ -186,22 +187,76 @@
         SERIAL_ECHOLNPGM("FAILURE: Watchdog did not trigger board reset.");
       } break;
 
+      #if ENABLED(SDSUPPORT)
+
+        case 101: { // D101 Test SD Write
+          card.openFileWrite("test.gco");
+          if (!card.isFileOpen()) {
+            SERIAL_ECHOLNPAIR("Failed to open test.gco to write.");
+            return;
+          }
+          __attribute__((aligned(sizeof(size_t)))) uint8_t buf[512];
+
+          uint16_t c;
+          for (c = 0; c < COUNT(buf); c++)
+            buf[c] = 'A' + (c % ('Z' - 'A'));
+
+          c = 1024 * 4;
+          while (c--) {
+            TERN_(USE_WATCHDOG, watchdog_refresh());
+            card.write(buf, COUNT(buf));
+          }
+          SERIAL_ECHOLNPGM(" done");
+          card.closefile();
+        } break;
+
+        case 102: { // D102 Test SD Read
+          card.openFileRead("test.gco");
+          if (!card.isFileOpen()) {
+            SERIAL_ECHOLNPAIR("Failed to open test.gco to read.");
+            return;
+          }
+          __attribute__((aligned(sizeof(size_t)))) uint8_t buf[512];
+          uint16_t c = 1024 * 4;
+          while (c--) {
+            TERN_(USE_WATCHDOG, watchdog_refresh());
+            card.read(buf, COUNT(buf));
+            bool error = false;
+            for (uint16_t i = 0; i < COUNT(buf); i++) {
+              if (buf[i] != ('A' + (i % ('Z' - 'A')))) {
+                error = true;
+                break;
+              }
+            }
+            if (error) {
+              SERIAL_ECHOLNPGM(" Read error!");
+              break;
+            }
+          }
+          SERIAL_ECHOLNPGM(" done");
+          card.closefile();
+        } break;
+
+      #endif // SDSUPPORT
+
       #if ENABLED(POSTMORTEM_DEBUGGING)
-      case 451: { // Trigger all kind of faults to test exception catcher
-        SERIAL_ECHOLNPGM("Disabling heaters");
-        thermalManager.disable_all_heaters();
-        delay(1000); // Allow time to print
-        volatile uint8_t type[5] = { parser.byteval('T', 1) };
-
-        // The code below is obviously wrong and it's full of quirks to fool the compiler from optimizing away the code
-        switch (type[0]) {
-          case 1: default: *(int*)0 = 451; break; // Write at bad address
-          case 2: { volatile int a = 0; volatile int b = 452 / a; *(int*)&a = b; } break; // Divide by zero (some CPUs accept this, like ARM)
-          case 3: { *(uint32_t*)&type[1] = 453; volatile int a = *(int*)&type[1]; type[0] = a / 255; } break; // Unaligned access (some CPUs accept this)
-          case 4: { volatile void (*func)() = (volatile void (*)()) 0xE0000000; func(); } break; // Invalid instruction
+
+        case 451: { // Trigger all kind of faults to test exception catcher
+          SERIAL_ECHOLNPGM("Disabling heaters");
+          thermalManager.disable_all_heaters();
+          delay(1000); // Allow time to print
+          volatile uint8_t type[5] = { parser.byteval('T', 1) };
+
+          // The code below is obviously wrong and it's full of quirks to fool the compiler from optimizing away the code
+          switch (type[0]) {
+            case 1: default: *(int*)0 = 451; break; // Write at bad address
+            case 2: { volatile int a = 0; volatile int b = 452 / a; *(int*)&a = b; } break; // Divide by zero (some CPUs accept this, like ARM)
+            case 3: { *(uint32_t*)&type[1] = 453; volatile int a = *(int*)&type[1]; type[0] = a / 255; } break; // Unaligned access (some CPUs accept this)
+            case 4: { volatile void (*func)() = (volatile void (*)()) 0xE0000000; func(); } break; // Invalid instruction
+          }
+          break;
         }
-        break;
-      }
+
       #endif
     }
   }

commit 139c14948621adcaa227bcef67765a5228039cd3
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Tue Mar 30 04:36:01 2021 +0200

    Flags for MarlinSerial instance features (#21318)

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index a683a330f1..8941523a16 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -167,6 +167,11 @@
         dump_delay_accuracy_check();
         break;
 
+      case 7: // D7 dump the current serial port type (hence configuration)
+        SERIAL_ECHOLNPAIR("Current serial configuration RX_BS:", RX_BUFFER_SIZE, ", TX_BS:", TX_BUFFER_SIZE);
+        SERIAL_ECHOLN(gtn(&SERIAL_IMPL));
+        break;
+
       case 100: { // D100 Disable heaters and attempt a hard hang (Watchdog Test)
         SERIAL_ECHOLNPGM("Disabling heaters and attempting to trigger Watchdog");
         SERIAL_ECHOLNPGM("(USE_WATCHDOG " TERN(USE_WATCHDOG, "ENABLED", "DISABLED") ")");

commit 6225870aa917e81c35a910653f0f482998a6e5c7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Mar 4 03:15:32 2021 -0600

    Implement G42, after all

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 805dcd52ce..a683a330f1 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -165,7 +165,7 @@
 
       case 6: // D6 Check delay loop accuracy
         dump_delay_accuracy_check();
-      break;
+        break;
 
       case 100: { // D100 Disable heaters and attempt a hard hang (Watchdog Test)
         SERIAL_ECHOLNPGM("Disabling heaters and attempting to trigger Watchdog");

commit 8d2885377435e423eaa187b52f33ce5d12fb03be
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Sun Feb 21 03:22:20 2021 +0100

    Postmortem Debugging to serial port (#20492)

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 653ae6a553..805dcd52ce 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -152,8 +152,7 @@
         NOMORE(len, FLASH_SIZE - addr);
         if (parser.seenval('X')) {
           // TODO: Write the hex bytes after the X
-          //while (len--) {
-          //}
+          //while (len--) {}
         }
         else {
           // while (len--) {
@@ -180,7 +179,25 @@
         for (int i = 10000; i--;) DELAY_US(1000UL);
         ENABLE_ISRS();
         SERIAL_ECHOLNPGM("FAILURE: Watchdog did not trigger board reset.");
+      } break;
+
+      #if ENABLED(POSTMORTEM_DEBUGGING)
+      case 451: { // Trigger all kind of faults to test exception catcher
+        SERIAL_ECHOLNPGM("Disabling heaters");
+        thermalManager.disable_all_heaters();
+        delay(1000); // Allow time to print
+        volatile uint8_t type[5] = { parser.byteval('T', 1) };
+
+        // The code below is obviously wrong and it's full of quirks to fool the compiler from optimizing away the code
+        switch (type[0]) {
+          case 1: default: *(int*)0 = 451; break; // Write at bad address
+          case 2: { volatile int a = 0; volatile int b = 452 / a; *(int*)&a = b; } break; // Divide by zero (some CPUs accept this, like ARM)
+          case 3: { *(uint32_t*)&type[1] = 453; volatile int a = *(int*)&type[1]; type[0] = a / 255; } break; // Unaligned access (some CPUs accept this)
+          case 4: { volatile void (*func)() = (volatile void (*)()) 0xE0000000; func(); } break; // Invalid instruction
+        }
+        break;
       }
+      #endif
     }
   }
 

commit 1c19af2c8fd95ff6da86c9f8eb18166805ea0097
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Sat Feb 6 05:43:51 2021 +0100

    Fix ARM delay function (#20901)

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 0bd2955875..653ae6a553 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -30,6 +30,8 @@
   #include "../HAL/shared/eeprom_if.h"
   #include "../HAL/shared/Delay.h"
 
+  extern void dump_delay_accuracy_check();
+
   /**
    * Dn: G-code for development and testing
    *
@@ -141,7 +143,7 @@
         }
       } break;
 
-      case 5: { // D4 Read / Write onboard Flash
+      case 5: { // D5 Read / Write onboard Flash
         #define FLASH_SIZE 1024
         uint8_t *pointer = parser.hex_adr_val('A');
         uint16_t len = parser.ushortval('C', 1);
@@ -162,6 +164,10 @@
         }
       } break;
 
+      case 6: // D6 Check delay loop accuracy
+        dump_delay_accuracy_check();
+      break;
+
       case 100: { // D100 Disable heaters and attempt a hard hang (Watchdog Test)
         SERIAL_ECHOLNPGM("Disabling heaters and attempting to trigger Watchdog");
         SERIAL_ECHOLNPGM("(USE_WATCHDOG " TERN(USE_WATCHDOG, "ENABLED", "DISABLED") ")");

commit f8d57370d00867df6a4fb7c934982d503be48c4b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 29 17:33:59 2020 -0500

    gcode_D EEPROM size, cleanup
    
    Fixes #19920
    
    Co-Authored-By: Orel <37673727+0r31@users.noreply.github.com>

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 2fd03144c5..0bd2955875 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -54,9 +54,7 @@
           size_t total = persistentStore.capacity();
           int pos = 0;
           const uint8_t value = 0x0;
-          while(total--) {
-            persistentStore.write_data(pos, &value, 1);
-          }
+          while (total--) persistentStore.write_data(pos, &value, 1);
           persistentStore.access_finish();
         #else
           settings.reset();
@@ -70,7 +68,7 @@
         uint8_t *pointer = parser.hex_adr_val('A');
         uint16_t len = parser.ushortval('C', 1);
         uintptr_t addr = (uintptr_t)pointer;
-        NOMORE(addr, (size_t)(SRAM_SIZE - 1));
+        NOMORE(addr, size_t(SRAM_SIZE - 1));
         NOMORE(len, SRAM_SIZE - addr);
         if (parser.seenval('X')) {
           // Write the hex bytes after the X
@@ -91,16 +89,13 @@
           uint8_t *pointer = parser.hex_adr_val('A');
           uint16_t len = parser.ushortval('C', 1);
           uintptr_t addr = (uintptr_t)pointer;
-          #ifndef MARLIN_EEPROM_SIZE
-            #define MARLIN_EEPROM_SIZE size_t(E2END + 1)
-          #endif
-          NOMORE(addr, (size_t)(MARLIN_EEPROM_SIZE - 1));
-          NOMORE(len, MARLIN_EEPROM_SIZE - addr);
+          NOMORE(addr, size_t(persistentStore.capacity() - 1));
+          NOMORE(len, persistentStore.capacity() - addr);
           if (parser.seenval('X')) {
             uint16_t val = parser.hex_val('X');
             #if ENABLED(EEPROM_SETTINGS)
               persistentStore.access_start();
-              while(len--) {
+              while (len--) {
                 int pos = 0;
                 persistentStore.write_data(pos, (uint8_t *)&val, sizeof(val));
               }
@@ -111,23 +106,18 @@
             #endif
           }
           else {
-            while (len--) {
-              // Read bytes from EEPROM
-              #if ENABLED(EEPROM_SETTINGS)
-                persistentStore.access_start();
-                uint8_t val;
-                while(len--) {
-                  int pos = 0;
-                  if (!persistentStore.read_data(pos, (uint8_t *)&val, sizeof(val))) {
-                    print_hex_byte(val);
-                  }
-                }
-                SERIAL_EOL();
-                persistentStore.access_finish();
-              #else
-                SERIAL_ECHOLNPGM("NO EEPROM");
-              #endif
-            }
+            // Read bytes from EEPROM
+            #if ENABLED(EEPROM_SETTINGS)
+              persistentStore.access_start();
+              int pos = 0;
+              uint8_t val;
+              while (len--) if (!persistentStore.read_data(pos, &val, 1)) print_hex_byte(val);
+              SERIAL_EOL();
+              persistentStore.access_finish();
+            #else
+              SERIAL_ECHOLNPGM("NO EEPROM");
+              len = 0;
+            #endif
             SERIAL_EOL();
           }
         } break;
@@ -156,7 +146,7 @@
         uint8_t *pointer = parser.hex_adr_val('A');
         uint16_t len = parser.ushortval('C', 1);
         uintptr_t addr = (uintptr_t)pointer;
-        NOMORE(addr, (size_t)(FLASH_SIZE - 1));
+        NOMORE(addr, size_t(FLASH_SIZE - 1));
         NOMORE(len, FLASH_SIZE - addr);
         if (parser.seenval('X')) {
           // TODO: Write the hex bytes after the X

commit 5917b5cf5cdaaca3b460c2a8e470b838d01b06fe
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 23 19:25:22 2020 -0500

    Fix warning in gcode_D

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 99968b625a..2fd03144c5 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -181,7 +181,7 @@
         // Use a low-level delay that does not rely on interrupts to function
         // Do not spin forever, to avoid thermal risks if heaters are enabled and
         // watchdog does not work.
-        DELAY_US(10000000);
+        for (int i = 10000; i--;) DELAY_US(1000UL);
         ENABLE_ISRS();
         SERIAL_ECHOLNPGM("FAILURE: Watchdog did not trigger board reset.");
       }

commit 92767f5513924842498af90e8557bdf3da91c000
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 19 20:38:24 2020 -0500

    Misc. cleanup, serial strings

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 1f38a85b91..99968b625a 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -107,7 +107,7 @@
               SERIAL_EOL();
               persistentStore.access_finish();
             #else
-              SERIAL_ECHOLN("NO EEPROM");
+              SERIAL_ECHOLNPGM("NO EEPROM");
             #endif
           }
           else {
@@ -125,13 +125,13 @@
                 SERIAL_EOL();
                 persistentStore.access_finish();
               #else
-                SERIAL_ECHOLN("NO EEPROM");
+                SERIAL_ECHOLNPGM("NO EEPROM");
               #endif
             }
             SERIAL_EOL();
           }
         } break;
-      #endif      
+      #endif
 
       case 4: { // D4 Read / Write PIN
         // const uint8_t pin = parser.byteval('P');
@@ -173,8 +173,8 @@
       } break;
 
       case 100: { // D100 Disable heaters and attempt a hard hang (Watchdog Test)
-        SERIAL_ECHOLN("Disabling heaters and attempting to trigger Watchdog");
-        SERIAL_ECHOLN("(USE_WATCHDOG " TERN(USE_WATCHDOG, "ENABLED", "DISABLED") ")");
+        SERIAL_ECHOLNPGM("Disabling heaters and attempting to trigger Watchdog");
+        SERIAL_ECHOLNPGM("(USE_WATCHDOG " TERN(USE_WATCHDOG, "ENABLED", "DISABLED") ")");
         thermalManager.disable_all_heaters();
         delay(1000); // Allow time to print
         DISABLE_ISRS();
@@ -183,7 +183,7 @@
         // watchdog does not work.
         DELAY_US(10000000);
         ENABLE_ISRS();
-        SERIAL_ECHOLN("FAILURE: Watchdog did not trigger board reset.");
+        SERIAL_ECHOLNPGM("FAILURE: Watchdog did not trigger board reset.");
       }
     }
   }

commit f5139f8bf433b5c2bfd4022e14e91a51ac46d951
Author: Jason Smith <jason.inet@gmail.com>
Date:   Mon Oct 12 14:39:31 2020 -0700

    Add D100 Watchdog Test (#19697)

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
index 4bc3b6c6c3..1f38a85b91 100644
--- a/Marlin/src/gcode/gcode_d.cpp
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -25,8 +25,10 @@
 
   #include "gcode.h"
   #include "../module/settings.h"
+  #include "../module/temperature.h"
   #include "../libs/hex_print.h"
   #include "../HAL/shared/eeprom_if.h"
+  #include "../HAL/shared/Delay.h"
 
   /**
    * Dn: G-code for development and testing
@@ -84,40 +86,23 @@
         }
       } break;
 
-      case 3: { // D3 Read / Write EEPROM
-        uint8_t *pointer = parser.hex_adr_val('A');
-        uint16_t len = parser.ushortval('C', 1);
-        uintptr_t addr = (uintptr_t)pointer;
-        #ifndef MARLIN_EEPROM_SIZE
-          #define MARLIN_EEPROM_SIZE size_t(E2END + 1)
-        #endif
-        NOMORE(addr, (size_t)(MARLIN_EEPROM_SIZE - 1));
-        NOMORE(len, MARLIN_EEPROM_SIZE - addr);
-        if (parser.seenval('X')) {
-          uint16_t val = parser.hex_val('X');
-          #if ENABLED(EEPROM_SETTINGS)
-            persistentStore.access_start();
-            while(len--) {
-              int pos = 0;
-              persistentStore.write_data(pos, (uint8_t *)&val, sizeof(val));
-            }
-            SERIAL_EOL();
-            persistentStore.access_finish();
-          #else
-            SERIAL_ECHOLN("NO EEPROM");
+      #if ENABLED(EEPROM_SETTINGS)
+        case 3: { // D3 Read / Write EEPROM
+          uint8_t *pointer = parser.hex_adr_val('A');
+          uint16_t len = parser.ushortval('C', 1);
+          uintptr_t addr = (uintptr_t)pointer;
+          #ifndef MARLIN_EEPROM_SIZE
+            #define MARLIN_EEPROM_SIZE size_t(E2END + 1)
           #endif
-        }
-        else {
-          while (len--) {
-            // Read bytes from EEPROM
+          NOMORE(addr, (size_t)(MARLIN_EEPROM_SIZE - 1));
+          NOMORE(len, MARLIN_EEPROM_SIZE - addr);
+          if (parser.seenval('X')) {
+            uint16_t val = parser.hex_val('X');
             #if ENABLED(EEPROM_SETTINGS)
               persistentStore.access_start();
-              uint8_t val;
               while(len--) {
                 int pos = 0;
-                if (!persistentStore.read_data(pos, (uint8_t *)&val, sizeof(val))) {
-                  print_hex_byte(val);
-                }
+                persistentStore.write_data(pos, (uint8_t *)&val, sizeof(val));
               }
               SERIAL_EOL();
               persistentStore.access_finish();
@@ -125,9 +110,28 @@
               SERIAL_ECHOLN("NO EEPROM");
             #endif
           }
-          SERIAL_EOL();
-        }
-      } break;
+          else {
+            while (len--) {
+              // Read bytes from EEPROM
+              #if ENABLED(EEPROM_SETTINGS)
+                persistentStore.access_start();
+                uint8_t val;
+                while(len--) {
+                  int pos = 0;
+                  if (!persistentStore.read_data(pos, (uint8_t *)&val, sizeof(val))) {
+                    print_hex_byte(val);
+                  }
+                }
+                SERIAL_EOL();
+                persistentStore.access_finish();
+              #else
+                SERIAL_ECHOLN("NO EEPROM");
+              #endif
+            }
+            SERIAL_EOL();
+          }
+        } break;
+      #endif      
 
       case 4: { // D4 Read / Write PIN
         // const uint8_t pin = parser.byteval('P');
@@ -167,6 +171,20 @@
           SERIAL_EOL();
         }
       } break;
+
+      case 100: { // D100 Disable heaters and attempt a hard hang (Watchdog Test)
+        SERIAL_ECHOLN("Disabling heaters and attempting to trigger Watchdog");
+        SERIAL_ECHOLN("(USE_WATCHDOG " TERN(USE_WATCHDOG, "ENABLED", "DISABLED") ")");
+        thermalManager.disable_all_heaters();
+        delay(1000); // Allow time to print
+        DISABLE_ISRS();
+        // Use a low-level delay that does not rely on interrupts to function
+        // Do not spin forever, to avoid thermal risks if heaters are enabled and
+        // watchdog does not work.
+        DELAY_US(10000000);
+        ENABLE_ISRS();
+        SERIAL_ECHOLN("FAILURE: Watchdog did not trigger board reset.");
+      }
     }
   }
 

commit 631457ffea46debd43079137e09bc2d36b5d4fe4
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Oct 9 08:25:23 2020 -0300

    Support for Debug Codes - Dnnn (#19225)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/gcode_d.cpp b/Marlin/src/gcode/gcode_d.cpp
new file mode 100644
index 0000000000..4bc3b6c6c3
--- /dev/null
+++ b/Marlin/src/gcode/gcode_d.cpp
@@ -0,0 +1,173 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#include "../inc/MarlinConfigPre.h"
+
+#if ENABLED(MARLIN_DEV_MODE)
+
+  #include "gcode.h"
+  #include "../module/settings.h"
+  #include "../libs/hex_print.h"
+  #include "../HAL/shared/eeprom_if.h"
+
+  /**
+   * Dn: G-code for development and testing
+   *
+   * See https://reprap.org/wiki/G-code#D:_Debug_codes
+   *
+   * Put whatever else you need here to test ongoing development.
+   */
+  void GcodeSuite::D(const int16_t dcode) {
+    switch (dcode) {
+
+      case -1:
+        for (;;); // forever
+
+      case 0:
+        HAL_reboot();
+        break;
+
+      case 1: {
+        // Zero or pattern-fill the EEPROM data
+        #if ENABLED(EEPROM_SETTINGS)
+          persistentStore.access_start();
+          size_t total = persistentStore.capacity();
+          int pos = 0;
+          const uint8_t value = 0x0;
+          while(total--) {
+            persistentStore.write_data(pos, &value, 1);
+          }
+          persistentStore.access_finish();
+        #else
+          settings.reset();
+          settings.save();
+        #endif
+        HAL_reboot();
+      } break;
+
+      case 2: { // D2 Read / Write SRAM
+        #define SRAM_SIZE 8192
+        uint8_t *pointer = parser.hex_adr_val('A');
+        uint16_t len = parser.ushortval('C', 1);
+        uintptr_t addr = (uintptr_t)pointer;
+        NOMORE(addr, (size_t)(SRAM_SIZE - 1));
+        NOMORE(len, SRAM_SIZE - addr);
+        if (parser.seenval('X')) {
+          // Write the hex bytes after the X
+          uint16_t val = parser.hex_val('X');
+          while (len--) {
+            *pointer = val;
+            pointer++;
+          }
+        }
+        else {
+          while (len--) print_hex_byte(*(pointer++));
+          SERIAL_EOL();
+        }
+      } break;
+
+      case 3: { // D3 Read / Write EEPROM
+        uint8_t *pointer = parser.hex_adr_val('A');
+        uint16_t len = parser.ushortval('C', 1);
+        uintptr_t addr = (uintptr_t)pointer;
+        #ifndef MARLIN_EEPROM_SIZE
+          #define MARLIN_EEPROM_SIZE size_t(E2END + 1)
+        #endif
+        NOMORE(addr, (size_t)(MARLIN_EEPROM_SIZE - 1));
+        NOMORE(len, MARLIN_EEPROM_SIZE - addr);
+        if (parser.seenval('X')) {
+          uint16_t val = parser.hex_val('X');
+          #if ENABLED(EEPROM_SETTINGS)
+            persistentStore.access_start();
+            while(len--) {
+              int pos = 0;
+              persistentStore.write_data(pos, (uint8_t *)&val, sizeof(val));
+            }
+            SERIAL_EOL();
+            persistentStore.access_finish();
+          #else
+            SERIAL_ECHOLN("NO EEPROM");
+          #endif
+        }
+        else {
+          while (len--) {
+            // Read bytes from EEPROM
+            #if ENABLED(EEPROM_SETTINGS)
+              persistentStore.access_start();
+              uint8_t val;
+              while(len--) {
+                int pos = 0;
+                if (!persistentStore.read_data(pos, (uint8_t *)&val, sizeof(val))) {
+                  print_hex_byte(val);
+                }
+              }
+              SERIAL_EOL();
+              persistentStore.access_finish();
+            #else
+              SERIAL_ECHOLN("NO EEPROM");
+            #endif
+          }
+          SERIAL_EOL();
+        }
+      } break;
+
+      case 4: { // D4 Read / Write PIN
+        // const uint8_t pin = parser.byteval('P');
+        // const bool is_out = parser.boolval('F'),
+        //            val = parser.byteval('V', LOW);
+        if (parser.seenval('X')) {
+          // TODO: Write the hex bytes after the X
+          //while (len--) {
+          //}
+        }
+        else {
+          // while (len--) {
+            // TODO: Read bytes from EEPROM
+            // print_hex_byte(eeprom_read_byte(*(adr++));
+          // }
+          SERIAL_EOL();
+        }
+      } break;
+
+      case 5: { // D4 Read / Write onboard Flash
+        #define FLASH_SIZE 1024
+        uint8_t *pointer = parser.hex_adr_val('A');
+        uint16_t len = parser.ushortval('C', 1);
+        uintptr_t addr = (uintptr_t)pointer;
+        NOMORE(addr, (size_t)(FLASH_SIZE - 1));
+        NOMORE(len, FLASH_SIZE - addr);
+        if (parser.seenval('X')) {
+          // TODO: Write the hex bytes after the X
+          //while (len--) {
+          //}
+        }
+        else {
+          // while (len--) {
+            // TODO: Read bytes from EEPROM
+            // print_hex_byte(eeprom_read_byte(adr++));
+          // }
+          SERIAL_EOL();
+        }
+      } break;
+    }
+  }
+
+#endif
