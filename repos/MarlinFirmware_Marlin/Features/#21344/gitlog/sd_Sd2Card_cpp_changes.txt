commit 6af6060aa0240ccc03020edba661fe42125d3713
Author: Martin Turski <turningtides@outlook.de>
Date:   Sun Aug 13 22:57:38 2023 +0200

    üîß Configurable SD card retry/timeout (#25340)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 7deebd4776..25fc35e6ab 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -40,6 +40,37 @@
 
 #include "../MarlinCore.h"
 
+#if DISABLED(SD_NO_DEFAULT_TIMEOUT)
+  #ifndef SD_INIT_TIMEOUT
+    #define SD_INIT_TIMEOUT 2000u   // (ms) Init timeout
+  #elif SD_INIT_TIMEOUT < 0
+    #error "SD_INIT_TIMEOUT must be greater than or equal to 0."
+  #endif
+  #ifndef SD_ERASE_TIMEOUT
+    #define SD_ERASE_TIMEOUT 10000u // (ms) Erase timeout
+  #elif SD_ERASE_TIMEOUT < 0
+    #error "SD_ERASE_TIMEOUT must be greater than or equal to 0."
+  #endif
+  #ifndef SD_READ_TIMEOUT
+    #define SD_READ_TIMEOUT 300u    // (ms) Read timeout
+  #elif SD_READ_TIMEOUT < 0
+    #error "SD_READ_TIMEOUT must be greater than or equal to 0."
+  #endif
+  #ifndef SD_WRITE_TIMEOUT
+    #define SD_WRITE_TIMEOUT 600u   // (ms) Write timeout
+  #elif SD_WRITE_TIMEOUT < 0
+    #error "SD_WRITE_TIMEOUT must be greater than or equal to 0."
+  #endif
+#endif // SD_NO_DEFAULT_TIMEOUT
+
+#if ENABLED(SD_CHECK_AND_RETRY)
+  #ifndef SD_RETRY_COUNT
+    #define SD_RETRY_COUNT 3
+  #elif SD_RETRY_COUNT < 1
+    #error "SD_RETRY_COUNT must be greater than or equal to 1."
+  #endif
+#endif
+
 #if ENABLED(SD_CHECK_AND_RETRY)
   static bool crcSupported = true;
 
@@ -97,15 +128,16 @@ uint8_t DiskIODriver_SPI_SD::cardCommand(const uint8_t cmd, const uint32_t arg)
   // Select card
   chipSelect();
 
-  // Wait up to 300 ms if busy
-  waitNotBusy(SD_WRITE_TIMEOUT);
+  #if SD_WRITE_TIMEOUT
+    waitNotBusy(SD_WRITE_TIMEOUT);  // Wait up to 600 ms (by default) if busy
+  #endif
 
   uint8_t *pa = (uint8_t *)(&arg);
 
   #if ENABLED(SD_CHECK_AND_RETRY)
 
     // Form message
-    uint8_t d[6] = {(uint8_t) (cmd | 0x40), pa[3], pa[2], pa[1], pa[0] };
+    uint8_t d[6] = { uint8_t(cmd | 0x40), pa[3], pa[2], pa[1], pa[0] };
 
     // Add crc
     d[5] = CRC7(d, 5);
@@ -186,33 +218,42 @@ void DiskIODriver_SPI_SD::chipSelect() {
 bool DiskIODriver_SPI_SD::erase(uint32_t firstBlock, uint32_t lastBlock) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
-  csd_t csd;
-  if (!readCSD(&csd)) goto FAIL;
-
-  // check for single block erase
-  if (!csd.v1.erase_blk_en) {
-    // erase size mask
-    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
-    if ((firstBlock & m) != 0 || ((lastBlock + 1) & m) != 0) {
-      // error card can't erase specified area
-      error(SD_CARD_ERROR_ERASE_SINGLE_BLOCK);
-      goto FAIL;
+  bool success = false;
+  do {
+
+    csd_t csd;
+    if (!readCSD(&csd)) break;
+
+    // check for single block erase
+    if (!csd.v1.erase_blk_en) {
+      // erase size mask
+      uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
+      if ((firstBlock & m) || ((lastBlock + 1) & m)) {
+        // error card can't erase specified area
+        error(SD_CARD_ERROR_ERASE_SINGLE_BLOCK);
+        break;
+      }
     }
-  }
-  if (type_ != SD_CARD_TYPE_SDHC) { firstBlock <<= 9; lastBlock <<= 9; }
-  if (cardCommand(CMD32, firstBlock) || cardCommand(CMD33, lastBlock) || cardCommand(CMD38, 0)) {
-    error(SD_CARD_ERROR_ERASE);
-    goto FAIL;
-  }
-  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
-    error(SD_CARD_ERROR_ERASE_TIMEOUT);
-    goto FAIL;
-  }
-  chipDeselect();
-  return true;
-  FAIL:
+    if (type_ != SD_CARD_TYPE_SDHC) { firstBlock <<= 9; lastBlock <<= 9; }
+    if (cardCommand(CMD32, firstBlock) || cardCommand(CMD33, lastBlock) || cardCommand(CMD38, 0)) {
+      error(SD_CARD_ERROR_ERASE);
+      break;
+    }
+    #if SD_ERASE_TIMEOUT
+      if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
+        error(SD_CARD_ERROR_ERASE_TIMEOUT);
+        break;
+      }
+    #else
+      while (spiRec() != 0xFF) {}
+    #endif
+
+    success = true;
+
+  } while (0);
+
   chipDeselect();
-  return false;
+  return success;
 }
 
 /**
@@ -245,8 +286,15 @@ bool DiskIODriver_SPI_SD::init(const uint8_t sckRateID, const pin_t chipSelectPi
 
   errorCode_ = type_ = 0;
   chipSelectPin_ = chipSelectPin;
+
   // 16-bit init start time allows over a minute
-  const millis_t init_timeout = millis() + SD_INIT_TIMEOUT;
+  #if SD_INIT_TIMEOUT
+    const millis_t init_timeout = millis() + SD_INIT_TIMEOUT;
+    #define INIT_TIMEOUT() ELAPSED(millis(), init_timeout)
+  #else
+    #define INIT_TIMEOUT() false
+  #endif
+
   uint32_t arg;
 
   hal.watchdog_refresh(); // In case init takes too long
@@ -274,7 +322,7 @@ bool DiskIODriver_SPI_SD::init(const uint8_t sckRateID, const pin_t chipSelectPi
 
   // Command to go idle in SPI mode
   while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {
-    if (ELAPSED(millis(), init_timeout)) {
+    if (INIT_TIMEOUT()) {
       error(SD_CARD_ERROR_CMD0);
       goto FAIL;
     }
@@ -300,7 +348,7 @@ bool DiskIODriver_SPI_SD::init(const uint8_t sckRateID, const pin_t chipSelectPi
       break;
     }
 
-    if (ELAPSED(millis(), init_timeout)) {
+    if (INIT_TIMEOUT()) {
       error(SD_CARD_ERROR_CMD8);
       goto FAIL;
     }
@@ -312,11 +360,12 @@ bool DiskIODriver_SPI_SD::init(const uint8_t sckRateID, const pin_t chipSelectPi
   arg = type() == SD_CARD_TYPE_SD2 ? 0x40000000 : 0;
   while ((status_ = cardAcmd(ACMD41, arg)) != R1_READY_STATE) {
     // Check for timeout
-    if (ELAPSED(millis(), init_timeout)) {
+    if (INIT_TIMEOUT()) {
       error(SD_CARD_ERROR_ACMD41);
       goto FAIL;
     }
   }
+
   // If SD2 read OCR register to check for SDHC card
   if (type() == SD_CARD_TYPE_SD2) {
     if (cardCommand(CMD58, 0)) {
@@ -327,6 +376,7 @@ bool DiskIODriver_SPI_SD::init(const uint8_t sckRateID, const pin_t chipSelectPi
     // Discard rest of ocr - contains allowed voltage range
     for (uint8_t i = 0; i < 3; ++i) spiRec();
   }
+
   chipDeselect();
 
   ready = true;
@@ -353,7 +403,7 @@ bool DiskIODriver_SPI_SD::readBlock(uint32_t blockNumber, uint8_t * const dst) {
   if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;   // Use address if not SDHC card
 
   #if ENABLED(SD_CHECK_AND_RETRY)
-    uint8_t retryCnt = 3;
+    uint8_t retryCnt = SD_RETRY_COUNT;
     for (;;) {
       if (cardCommand(CMD17, blockNumber))
         error(SD_CARD_ERROR_CMD17);
@@ -458,9 +508,15 @@ bool DiskIODriver_SPI_SD::readData(uint8_t * const dst) {
 bool DiskIODriver_SPI_SD::readData(uint8_t * const dst, const uint16_t count) {
   bool success = false;
 
-  const millis_t read_timeout = millis() + SD_READ_TIMEOUT;
+  #if SD_READ_TIMEOUT
+    const millis_t read_timeout = millis() + SD_READ_TIMEOUT;
+    #define READ_TIMEOUT() ELAPSED(millis(), read_timeout)
+  #else
+    #define READ_TIMEOUT() false
+  #endif
+
   while ((status_ = spiRec()) == 0xFF) {      // Wait for start block token
-    if (ELAPSED(millis(), read_timeout)) {
+    if (READ_TIMEOUT()) {
       error(SD_CARD_ERROR_READ_TIMEOUT);
       goto FAIL;
     }
@@ -469,7 +525,7 @@ bool DiskIODriver_SPI_SD::readData(uint8_t * const dst, const uint16_t count) {
   if (status_ == DATA_START_BLOCK) {
     spiRead(dst, count);                      // Transfer data
 
-    const uint16_t recvCrc = (spiRec() << 8) | spiRec();
+    const uint16_t recvCrc = ((uint16_t)spiRec() << 8) | (uint16_t)spiRec();
     #if ENABLED(SD_CHECK_AND_RETRY)
       success = !crcSupported || recvCrc == CRC_CCITT(dst, count);
       if (!success) error(SD_CARD_ERROR_READ_CRC);
@@ -574,20 +630,23 @@ bool DiskIODriver_SPI_SD::writeBlock(uint32_t blockNumber, const uint8_t * const
     return 0 == SDHC_CardWriteBlock(src, blockNumber);
   #endif
 
-  bool success = false;
-  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;   // Use address if not SDHC card
-  if (!cardCommand(CMD24, blockNumber)) {
-    if (writeData(DATA_START_BLOCK, src)) {
-      if (waitNotBusy(SD_WRITE_TIMEOUT)) {              // Wait for flashing to complete
-        success = !(cardCommand(CMD13, 0) || spiRec()); // Response is r2 so get and check two bytes for nonzero
-        if (!success) error(SD_CARD_ERROR_WRITE_PROGRAMMING);
-      }
-      else
-        error(SD_CARD_ERROR_WRITE_TIMEOUT);
+  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9; // Use address if not SDHC card
+  bool success = !cardCommand(CMD24, blockNumber);
+  if (!success) {
+    error(SD_CARD_ERROR_CMD24);
+  }
+  else if (writeData(DATA_START_BLOCK, src)) {
+    #if SD_WRITE_TIMEOUT
+      success = waitNotBusy(SD_WRITE_TIMEOUT);        // Wait for flashing to complete
+      if (!success) error(SD_CARD_ERROR_WRITE_TIMEOUT);
+    #else
+      while (spiRec() != 0xFF) {}
+    #endif
+    if (success) {
+      success = !(cardCommand(CMD13, 0) || spiRec()); // Response is r2 so get and check two bytes for nonzero
+      if (!success) error(SD_CARD_ERROR_WRITE_PROGRAMMING);
     }
   }
-  else
-    error(SD_CARD_ERROR_CMD24);
 
   chipDeselect();
   return success;
@@ -601,13 +660,25 @@ bool DiskIODriver_SPI_SD::writeBlock(uint32_t blockNumber, const uint8_t * const
 bool DiskIODriver_SPI_SD::writeData(const uint8_t * const src) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
-  bool success = true;
   chipSelect();
-  // Wait for previous write to finish
-  if (!waitNotBusy(SD_WRITE_TIMEOUT) || !writeData(WRITE_MULTIPLE_TOKEN, src)) {
-    error(SD_CARD_ERROR_WRITE_MULTIPLE);
-    success = false;
-  }
+
+  bool success = false;
+  do {
+
+    // Wait for previous write to finish
+    #if SD_WRITE_TIMEOUT
+      if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
+        error(SD_CARD_ERROR_WRITE_MULTIPLE);
+        break;
+      }
+    #else
+      while (spiRec() != 0xFF) {}
+    #endif
+
+    success = writeData(WRITE_MULTIPLE_TOKEN, src);
+
+  } while (0);
+
   chipDeselect();
   return success;
 }
@@ -665,14 +736,31 @@ bool DiskIODriver_SPI_SD::writeStart(uint32_t blockNumber, const uint32_t eraseC
 bool DiskIODriver_SPI_SD::writeStop() {
   if (ENABLED(SDCARD_READONLY)) return false;
 
-  bool success = false;
   chipSelect();
-  if (waitNotBusy(SD_WRITE_TIMEOUT)) {
+
+  bool success = false;
+  do {
+
+    #if SD_WRITE_TIMEOUT
+      if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
+        error(SD_CARD_ERROR_STOP_TRAN);
+        break;
+      }
+    #else
+      while (spiRec() != 0xFF) {}
+    #endif
+
     spiSend(STOP_TRAN_TOKEN);
-    success = waitNotBusy(SD_WRITE_TIMEOUT);
-  }
-  else
-    error(SD_CARD_ERROR_STOP_TRAN);
+
+    #if SD_WRITE_TIMEOUT
+      if (!waitNotBusy(SD_WRITE_TIMEOUT)) break;
+    #else
+      while (spiRec() != 0xFF) {}
+    #endif
+
+    success = true;
+
+  } while (0);
 
   chipDeselect();
   return success;

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 81cc032304..7deebd4776 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -74,7 +74,7 @@
   #else
     static uint8_t CRC7(const uint8_t *data, uint8_t n) {
       uint8_t crc = 0;
-      LOOP_L_N(i, n) {
+      for (uint8_t i = 0; i < n; ++i) {
         uint8_t d = data[i];
         d ^= crc << 1;
         if (d & 0x80) d ^= 9;
@@ -111,7 +111,7 @@ uint8_t DiskIODriver_SPI_SD::cardCommand(const uint8_t cmd, const uint32_t arg)
     d[5] = CRC7(d, 5);
 
     // Send message
-    LOOP_L_N(k, 6) spiSend(d[k]);
+    for (uint8_t k = 0; k < 6; ++k) spiSend(d[k]);
 
   #else
     // Send command
@@ -268,7 +268,7 @@ bool DiskIODriver_SPI_SD::init(const uint8_t sckRateID, const pin_t chipSelectPi
   spiInit(spiRate_);
 
   // Must supply min of 74 clock cycles with CS high.
-  LOOP_L_N(i, 10) spiSend(0xFF);
+  for (uint8_t i = 0; i < 10; ++i) spiSend(0xFF);
 
   hal.watchdog_refresh(); // In case init takes too long
 
@@ -294,7 +294,7 @@ bool DiskIODriver_SPI_SD::init(const uint8_t sckRateID, const pin_t chipSelectPi
     }
 
     // Get the last byte of r7 response
-    LOOP_L_N(i, 4) status_ = spiRec();
+    for (uint8_t i = 0; i < 4; ++i) status_ = spiRec();
     if (status_ == 0xAA) {
       type(SD_CARD_TYPE_SD2);
       break;
@@ -325,7 +325,7 @@ bool DiskIODriver_SPI_SD::init(const uint8_t sckRateID, const pin_t chipSelectPi
     }
     if ((spiRec() & 0xC0) == 0xC0) type(SD_CARD_TYPE_SDHC);
     // Discard rest of ocr - contains allowed voltage range
-    LOOP_L_N(i, 3) spiRec();
+    for (uint8_t i = 0; i < 3; ++i) spiRec();
   }
   chipDeselect();
 

commit 27b828891db155f8b372e4efb9891bdc91bf6d33
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 7 01:33:03 2023 -0500

    üé® Apply const (#25643)

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 2d84c95a3d..81cc032304 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -345,7 +345,7 @@ bool DiskIODriver_SPI_SD::init(const uint8_t sckRateID, const pin_t chipSelectPi
  * \param[out] dst Pointer to the location that will receive the data.
  * \return true for success, false for failure.
  */
-bool DiskIODriver_SPI_SD::readBlock(uint32_t blockNumber, uint8_t *dst) {
+bool DiskIODriver_SPI_SD::readBlock(uint32_t blockNumber, uint8_t * const dst) {
   #if IS_TEENSY_35_36 || IS_TEENSY_40_41
     return 0 == SDHC_CardReadBlock(dst, blockNumber);
   #endif
@@ -385,7 +385,7 @@ bool DiskIODriver_SPI_SD::readBlock(uint32_t blockNumber, uint8_t *dst) {
  *
  * \return true for success, false for failure.
  */
-bool DiskIODriver_SPI_SD::readData(uint8_t *dst) {
+bool DiskIODriver_SPI_SD::readData(uint8_t * const dst) {
   chipSelect();
   return readData(dst, 512);
 }
@@ -455,7 +455,7 @@ bool DiskIODriver_SPI_SD::readData(uint8_t *dst) {
 
 #endif // SD_CHECK_AND_RETRY
 
-bool DiskIODriver_SPI_SD::readData(uint8_t *dst, const uint16_t count) {
+bool DiskIODriver_SPI_SD::readData(uint8_t * const dst, const uint16_t count) {
   bool success = false;
 
   const millis_t read_timeout = millis() + SD_READ_TIMEOUT;
@@ -487,8 +487,8 @@ bool DiskIODriver_SPI_SD::readData(uint8_t *dst, const uint16_t count) {
 }
 
 /** read CID or CSR register */
-bool DiskIODriver_SPI_SD::readRegister(const uint8_t cmd, void *buf) {
-  uint8_t *dst = reinterpret_cast<uint8_t*>(buf);
+bool DiskIODriver_SPI_SD::readRegister(const uint8_t cmd, void * const buf) {
+  uint8_t * const dst = reinterpret_cast<uint8_t*>(buf);
   if (cardCommand(cmd, 0)) {
     error(SD_CARD_ERROR_READ_REG);
     chipDeselect();
@@ -567,7 +567,7 @@ void DiskIODriver_SPI_SD::error(const uint8_t code) { errorCode_ = code; }
  * \param[in] src Pointer to the location of the data to be written.
  * \return true for success, false for failure.
  */
-bool DiskIODriver_SPI_SD::writeBlock(uint32_t blockNumber, const uint8_t *src) {
+bool DiskIODriver_SPI_SD::writeBlock(uint32_t blockNumber, const uint8_t * const src) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   #if IS_TEENSY_35_36 || IS_TEENSY_40_41
@@ -598,7 +598,7 @@ bool DiskIODriver_SPI_SD::writeBlock(uint32_t blockNumber, const uint8_t *src) {
  * \param[in] src Pointer to the location of the data to be written.
  * \return true for success, false for failure.
  */
-bool DiskIODriver_SPI_SD::writeData(const uint8_t *src) {
+bool DiskIODriver_SPI_SD::writeData(const uint8_t * const src) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   bool success = true;
@@ -613,7 +613,7 @@ bool DiskIODriver_SPI_SD::writeData(const uint8_t *src) {
 }
 
 // Send one block of data for write block or write multiple blocks
-bool DiskIODriver_SPI_SD::writeData(const uint8_t token, const uint8_t *src) {
+bool DiskIODriver_SPI_SD::writeData(const uint8_t token, const uint8_t * const src) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   const uint16_t crc = TERN(SD_CHECK_AND_RETRY, CRC_CCITT(src, 512), 0xFFFF);

commit 52eefa90e1c18616f127cdf43798907880e05ee5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 11:36:13 2022 -0500

    ‚ôªÔ∏è Move watchdog to MarlinHAL

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 3402bfaee3..2d84c95a3d 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -249,7 +249,7 @@ bool DiskIODriver_SPI_SD::init(const uint8_t sckRateID, const pin_t chipSelectPi
   const millis_t init_timeout = millis() + SD_INIT_TIMEOUT;
   uint32_t arg;
 
-  watchdog_refresh(); // In case init takes too long
+  hal.watchdog_refresh(); // In case init takes too long
 
   // Set pin modes
   #if ENABLED(ZONESTAR_12864OLED)
@@ -270,7 +270,7 @@ bool DiskIODriver_SPI_SD::init(const uint8_t sckRateID, const pin_t chipSelectPi
   // Must supply min of 74 clock cycles with CS high.
   LOOP_L_N(i, 10) spiSend(0xFF);
 
-  watchdog_refresh(); // In case init takes too long
+  hal.watchdog_refresh(); // In case init takes too long
 
   // Command to go idle in SPI mode
   while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {
@@ -284,7 +284,7 @@ bool DiskIODriver_SPI_SD::init(const uint8_t sckRateID, const pin_t chipSelectPi
     crcSupported = (cardCommand(CMD59, 1) == R1_IDLE_STATE);
   #endif
 
-  watchdog_refresh(); // In case init takes too long
+  hal.watchdog_refresh(); // In case init takes too long
 
   // check SD version
   for (;;) {
@@ -306,7 +306,7 @@ bool DiskIODriver_SPI_SD::init(const uint8_t sckRateID, const pin_t chipSelectPi
     }
   }
 
-  watchdog_refresh(); // In case init takes too long
+  hal.watchdog_refresh(); // In case init takes too long
 
   // Initialize card and send host supports SDHC if SD2
   arg = type() == SD_CARD_TYPE_SD2 ? 0x40000000 : 0;

commit 13ce5aa1ed4ab4f8fc01f7ff6f7ad7884fc28ea9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Dec 21 22:15:48 2021 -0600

    üé® Misc. cleanup

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index a81932d494..3402bfaee3 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -392,50 +392,51 @@ bool DiskIODriver_SPI_SD::readData(uint8_t *dst) {
 
 #if ENABLED(SD_CHECK_AND_RETRY)
   #ifdef FAST_CRC
-  static const uint16_t crctab16[] PROGMEM = {
-    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
-    0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
-    0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
-    0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
-    0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
-    0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
-    0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
-    0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
-    0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
-    0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
-    0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
-    0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
-    0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
-    0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
-    0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
-    0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
-    0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
-    0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
-    0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
-    0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
-    0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
-    0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
-    0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
-    0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
-    0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
-    0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
-    0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
-    0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
-    0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
-    0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
-    0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
-    0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
-  };
+    static const uint16_t crctab16[] PROGMEM = {
+      0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
+      0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
+      0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
+      0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
+      0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
+      0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
+      0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
+      0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
+      0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
+      0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
+      0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
+      0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
+      0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
+      0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
+      0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
+      0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
+      0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
+      0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
+      0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
+      0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
+      0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
+      0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
+      0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
+      0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
+      0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
+      0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
+      0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
+      0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
+      0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
+      0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
+      0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
+      0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
+    };
     // faster CRC-CCITT
     // uses the x^16,x^12,x^5,x^1 polynomial.
-  static uint16_t CRC_CCITT(const uint8_t *data, size_t n) {
-    uint16_t crc = 0;
-    for (size_t i = 0; i < n; i++) {
-      crc = pgm_read_word(&crctab16[(crc >> 8 ^ data[i]) & 0xFF]) ^ (crc << 8);
+    static uint16_t CRC_CCITT(const uint8_t *data, size_t n) {
+      uint16_t crc = 0;
+      for (size_t i = 0; i < n; i++)
+        crc = pgm_read_word(&crctab16[(crc >> 8 ^ data[i]) & 0xFF]) ^ (crc << 8);
+      return crc;
     }
-    return crc;
-  }
+
   #else
+
     // slower CRC-CCITT
     // uses the x^16,x^12,x^5,x^1 polynomial.
     static uint16_t CRC_CCITT(const uint8_t *data, size_t n) {
@@ -449,7 +450,9 @@ bool DiskIODriver_SPI_SD::readData(uint8_t *dst) {
       }
       return crc;
     }
+
   #endif
+
 #endif // SD_CHECK_AND_RETRY
 
 bool DiskIODriver_SPI_SD::readData(uint8_t *dst, const uint16_t count) {

commit 7da4ed7340044a2457846af9a1709232f7eb0037
Author: Moonglow <fxdteam@gmail.com>
Date:   Thu May 20 14:09:10 2021 +0300

    üêõ Fix Toshiba FlashAir (SDCARD_COMMANDS_SPLIT) (#21944)

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 3e714fe9fe..a81932d494 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -89,6 +89,11 @@
 
 // Send command and return error code. Return zero for OK
 uint8_t DiskIODriver_SPI_SD::cardCommand(const uint8_t cmd, const uint32_t arg) {
+
+  #if ENABLED(SDCARD_COMMANDS_SPLIT)
+    if (cmd != CMD12) chipDeselect();
+  #endif
+
   // Select card
   chipSelect();
 

commit 138340ee99a852bc116e2a436932bed074624fde
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Apr 13 19:34:19 2021 -0300

    Multi-Volume. Select Media for LVGL (#21344)

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 28049c7e7e..3e714fe9fe 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -30,7 +30,7 @@
 
 #include "../inc/MarlinConfig.h"
 
-#if ENABLED(SDSUPPORT) && NONE(USB_FLASH_DRIVE_SUPPORT, SDIO_SUPPORT)
+#if NEED_SD2CARD_SPI
 
 /* Enable FAST CRC computations - You can trade speed for FLASH space if
  * needed by disabling the following define */
@@ -88,7 +88,7 @@
 #endif
 
 // Send command and return error code. Return zero for OK
-uint8_t Sd2Card::cardCommand(const uint8_t cmd, const uint32_t arg) {
+uint8_t DiskIODriver_SPI_SD::cardCommand(const uint8_t cmd, const uint32_t arg) {
   // Select card
   chipSelect();
 
@@ -133,7 +133,7 @@ uint8_t Sd2Card::cardCommand(const uint8_t cmd, const uint32_t arg) {
  * \return The number of 512 byte data blocks in the card
  *         or zero if an error occurs.
  */
-uint32_t Sd2Card::cardSize() {
+uint32_t DiskIODriver_SPI_SD::cardSize() {
   csd_t csd;
   if (!readCSD(&csd)) return 0;
   if (csd.v1.csd_ver == 0) {
@@ -155,12 +155,12 @@ uint32_t Sd2Card::cardSize() {
   }
 }
 
-void Sd2Card::chipDeselect() {
+void DiskIODriver_SPI_SD::chipDeselect() {
   extDigitalWrite(chipSelectPin_, HIGH);
   spiSend(0xFF); // Ensure MISO goes high impedance
 }
 
-void Sd2Card::chipSelect() {
+void DiskIODriver_SPI_SD::chipSelect() {
   spiInit(spiRate_);
   extDigitalWrite(chipSelectPin_, LOW);
 }
@@ -178,7 +178,7 @@ void Sd2Card::chipSelect() {
  *
  * \return true for success, false for failure.
  */
-bool Sd2Card::erase(uint32_t firstBlock, uint32_t lastBlock) {
+bool DiskIODriver_SPI_SD::erase(uint32_t firstBlock, uint32_t lastBlock) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   csd_t csd;
@@ -216,7 +216,7 @@ bool Sd2Card::erase(uint32_t firstBlock, uint32_t lastBlock) {
  * \return true if single block erase is supported.
  *         false if single block erase is not supported.
  */
-bool Sd2Card::eraseSingleBlockEnable() {
+bool DiskIODriver_SPI_SD::eraseSingleBlockEnable() {
   csd_t csd;
   return readCSD(&csd) ? csd.v1.erase_blk_en : false;
 }
@@ -230,7 +230,7 @@ bool Sd2Card::eraseSingleBlockEnable() {
  * \return true for success, false for failure.
  * The reason for failure can be determined by calling errorCode() and errorData().
  */
-bool Sd2Card::init(const uint8_t sckRateID, const pin_t chipSelectPin) {
+bool DiskIODriver_SPI_SD::init(const uint8_t sckRateID, const pin_t chipSelectPin) {
   #if IS_TEENSY_35_36 || IS_TEENSY_40_41
     chipSelectPin_ = BUILTIN_SDCARD;
     const uint8_t ret = SDHC_CardInit();
@@ -324,10 +324,12 @@ bool Sd2Card::init(const uint8_t sckRateID, const pin_t chipSelectPin) {
   }
   chipDeselect();
 
+  ready = true;
   return setSckRate(sckRateID);
 
   FAIL:
   chipDeselect();
+  ready = false;
   return false;
 }
 
@@ -338,7 +340,7 @@ bool Sd2Card::init(const uint8_t sckRateID, const pin_t chipSelectPin) {
  * \param[out] dst Pointer to the location that will receive the data.
  * \return true for success, false for failure.
  */
-bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t *dst) {
+bool DiskIODriver_SPI_SD::readBlock(uint32_t blockNumber, uint8_t *dst) {
   #if IS_TEENSY_35_36 || IS_TEENSY_40_41
     return 0 == SDHC_CardReadBlock(dst, blockNumber);
   #endif
@@ -378,7 +380,7 @@ bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t *dst) {
  *
  * \return true for success, false for failure.
  */
-bool Sd2Card::readData(uint8_t *dst) {
+bool DiskIODriver_SPI_SD::readData(uint8_t *dst) {
   chipSelect();
   return readData(dst, 512);
 }
@@ -445,7 +447,7 @@ bool Sd2Card::readData(uint8_t *dst) {
   #endif
 #endif // SD_CHECK_AND_RETRY
 
-bool Sd2Card::readData(uint8_t *dst, const uint16_t count) {
+bool DiskIODriver_SPI_SD::readData(uint8_t *dst, const uint16_t count) {
   bool success = false;
 
   const millis_t read_timeout = millis() + SD_READ_TIMEOUT;
@@ -477,7 +479,7 @@ bool Sd2Card::readData(uint8_t *dst, const uint16_t count) {
 }
 
 /** read CID or CSR register */
-bool Sd2Card::readRegister(const uint8_t cmd, void *buf) {
+bool DiskIODriver_SPI_SD::readRegister(const uint8_t cmd, void *buf) {
   uint8_t *dst = reinterpret_cast<uint8_t*>(buf);
   if (cardCommand(cmd, 0)) {
     error(SD_CARD_ERROR_READ_REG);
@@ -497,7 +499,7 @@ bool Sd2Card::readRegister(const uint8_t cmd, void *buf) {
  *
  * \return true for success, false for failure.
  */
-bool Sd2Card::readStart(uint32_t blockNumber) {
+bool DiskIODriver_SPI_SD::readStart(uint32_t blockNumber) {
   if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
 
   const bool success = !cardCommand(CMD18, blockNumber);
@@ -511,7 +513,7 @@ bool Sd2Card::readStart(uint32_t blockNumber) {
  *
  * \return true for success, false for failure.
  */
-bool Sd2Card::readStop() {
+bool DiskIODriver_SPI_SD::readStop() {
   chipSelect();
   const bool success = !cardCommand(CMD12, 0);
   if (!success) error(SD_CARD_ERROR_CMD12);
@@ -531,7 +533,7 @@ bool Sd2Card::readStop() {
  * \return The value one, true, is returned for success and the value zero,
  * false, is returned for an invalid value of \a sckRateID.
  */
-bool Sd2Card::setSckRate(const uint8_t sckRateID) {
+bool DiskIODriver_SPI_SD::setSckRate(const uint8_t sckRateID) {
   const bool success = (sckRateID <= 6);
   if (success) spiRate_ = sckRateID; else error(SD_CARD_ERROR_SCK_RATE);
   return success;
@@ -542,12 +544,14 @@ bool Sd2Card::setSckRate(const uint8_t sckRateID) {
  * \param[in] timeout_ms Timeout to abort.
  * \return true for success, false for timeout.
  */
-bool Sd2Card::waitNotBusy(const millis_t timeout_ms) {
+bool DiskIODriver_SPI_SD::waitNotBusy(const millis_t timeout_ms) {
   const millis_t wait_timeout = millis() + timeout_ms;
   while (spiRec() != 0xFF) if (ELAPSED(millis(), wait_timeout)) return false;
   return true;
 }
 
+void DiskIODriver_SPI_SD::error(const uint8_t code) { errorCode_ = code; }
+
 /**
  * Write a 512 byte block to an SD card.
  *
@@ -555,7 +559,7 @@ bool Sd2Card::waitNotBusy(const millis_t timeout_ms) {
  * \param[in] src Pointer to the location of the data to be written.
  * \return true for success, false for failure.
  */
-bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t *src) {
+bool DiskIODriver_SPI_SD::writeBlock(uint32_t blockNumber, const uint8_t *src) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   #if IS_TEENSY_35_36 || IS_TEENSY_40_41
@@ -586,7 +590,7 @@ bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t *src) {
  * \param[in] src Pointer to the location of the data to be written.
  * \return true for success, false for failure.
  */
-bool Sd2Card::writeData(const uint8_t *src) {
+bool DiskIODriver_SPI_SD::writeData(const uint8_t *src) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   bool success = true;
@@ -601,7 +605,7 @@ bool Sd2Card::writeData(const uint8_t *src) {
 }
 
 // Send one block of data for write block or write multiple blocks
-bool Sd2Card::writeData(const uint8_t token, const uint8_t *src) {
+bool DiskIODriver_SPI_SD::writeData(const uint8_t token, const uint8_t *src) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   const uint16_t crc = TERN(SD_CHECK_AND_RETRY, CRC_CCITT(src, 512), 0xFFFF);
@@ -629,7 +633,7 @@ bool Sd2Card::writeData(const uint8_t token, const uint8_t *src) {
  *
  * \return true for success, false for failure.
  */
-bool Sd2Card::writeStart(uint32_t blockNumber, const uint32_t eraseCount) {
+bool DiskIODriver_SPI_SD::writeStart(uint32_t blockNumber, const uint32_t eraseCount) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   bool success = false;
@@ -650,7 +654,7 @@ bool Sd2Card::writeStart(uint32_t blockNumber, const uint32_t eraseCount) {
  *
  * \return true for success, false for failure.
  */
-bool Sd2Card::writeStop() {
+bool DiskIODriver_SPI_SD::writeStop() {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   bool success = false;
@@ -666,4 +670,4 @@ bool Sd2Card::writeStop() {
   return success;
 }
 
-#endif // SDSUPPORT
+#endif // NEED_SD2CARD_SPI

commit 8b6718c6320c32abe0fa1de56a033aca54ff0b76
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 4 18:07:16 2021 -0500

    misc. pointer formatting

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index b914b29635..28049c7e7e 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -477,7 +477,7 @@ bool Sd2Card::readData(uint8_t *dst, const uint16_t count) {
 }
 
 /** read CID or CSR register */
-bool Sd2Card::readRegister(const uint8_t cmd, void* buf) {
+bool Sd2Card::readRegister(const uint8_t cmd, void *buf) {
   uint8_t *dst = reinterpret_cast<uint8_t*>(buf);
   if (cardCommand(cmd, 0)) {
     error(SD_CARD_ERROR_READ_REG);

commit 3b73b115ca9366f0155986b717d4c85c31ed2f80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 29 20:36:37 2021 -0500

    Apply pointer formatting

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 491c0692c7..b914b29635 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -63,7 +63,7 @@
       0x0E,0x07,0x1C,0x15,0x2A,0x23,0x38,0x31,0x46,0x4F,0x54,0x5D,0x62,0x6B,0x70,0x79
     };
 
-    static uint8_t CRC7(const uint8_t* data, uint8_t n) {
+    static uint8_t CRC7(const uint8_t *data, uint8_t n) {
       uint8_t crc = 0;
       while (n > 0) {
         crc = pgm_read_byte(&crctab7[ (crc << 1) ^ *data++ ]);
@@ -72,7 +72,7 @@
       return (crc << 1) | 1;
     }
   #else
-    static uint8_t CRC7(const uint8_t* data, uint8_t n) {
+    static uint8_t CRC7(const uint8_t *data, uint8_t n) {
       uint8_t crc = 0;
       LOOP_L_N(i, n) {
         uint8_t d = data[i];
@@ -338,7 +338,7 @@ bool Sd2Card::init(const uint8_t sckRateID, const pin_t chipSelectPin) {
  * \param[out] dst Pointer to the location that will receive the data.
  * \return true for success, false for failure.
  */
-bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
+bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t *dst) {
   #if IS_TEENSY_35_36 || IS_TEENSY_40_41
     return 0 == SDHC_CardReadBlock(dst, blockNumber);
   #endif
@@ -378,7 +378,7 @@ bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
  *
  * \return true for success, false for failure.
  */
-bool Sd2Card::readData(uint8_t* dst) {
+bool Sd2Card::readData(uint8_t *dst) {
   chipSelect();
   return readData(dst, 512);
 }
@@ -421,7 +421,7 @@ bool Sd2Card::readData(uint8_t* dst) {
   };
     // faster CRC-CCITT
     // uses the x^16,x^12,x^5,x^1 polynomial.
-  static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
+  static uint16_t CRC_CCITT(const uint8_t *data, size_t n) {
     uint16_t crc = 0;
     for (size_t i = 0; i < n; i++) {
       crc = pgm_read_word(&crctab16[(crc >> 8 ^ data[i]) & 0xFF]) ^ (crc << 8);
@@ -431,7 +431,7 @@ bool Sd2Card::readData(uint8_t* dst) {
   #else
     // slower CRC-CCITT
     // uses the x^16,x^12,x^5,x^1 polynomial.
-    static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
+    static uint16_t CRC_CCITT(const uint8_t *data, size_t n) {
       uint16_t crc = 0;
       for (size_t i = 0; i < n; i++) {
         crc = (uint8_t)(crc >> 8) | (crc << 8);
@@ -445,7 +445,7 @@ bool Sd2Card::readData(uint8_t* dst) {
   #endif
 #endif // SD_CHECK_AND_RETRY
 
-bool Sd2Card::readData(uint8_t* dst, const uint16_t count) {
+bool Sd2Card::readData(uint8_t *dst, const uint16_t count) {
   bool success = false;
 
   const millis_t read_timeout = millis() + SD_READ_TIMEOUT;
@@ -478,7 +478,7 @@ bool Sd2Card::readData(uint8_t* dst, const uint16_t count) {
 
 /** read CID or CSR register */
 bool Sd2Card::readRegister(const uint8_t cmd, void* buf) {
-  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
+  uint8_t *dst = reinterpret_cast<uint8_t*>(buf);
   if (cardCommand(cmd, 0)) {
     error(SD_CARD_ERROR_READ_REG);
     chipDeselect();
@@ -555,7 +555,7 @@ bool Sd2Card::waitNotBusy(const millis_t timeout_ms) {
  * \param[in] src Pointer to the location of the data to be written.
  * \return true for success, false for failure.
  */
-bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
+bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t *src) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   #if IS_TEENSY_35_36 || IS_TEENSY_40_41
@@ -586,7 +586,7 @@ bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
  * \param[in] src Pointer to the location of the data to be written.
  * \return true for success, false for failure.
  */
-bool Sd2Card::writeData(const uint8_t* src) {
+bool Sd2Card::writeData(const uint8_t *src) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   bool success = true;
@@ -601,7 +601,7 @@ bool Sd2Card::writeData(const uint8_t* src) {
 }
 
 // Send one block of data for write block or write multiple blocks
-bool Sd2Card::writeData(const uint8_t token, const uint8_t* src) {
+bool Sd2Card::writeData(const uint8_t token, const uint8_t *src) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   const uint16_t crc = TERN(SD_CHECK_AND_RETRY, CRC_CCITT(src, 512), 0xFFFF);

commit e8a62ee3cf24af08541524ed46b7d0373b3e140b
Author: bilsef <bilsef1@gmail.com>
Date:   Fri Oct 2 15:08:50 2020 -0700

    Fix onboard SD card support for Teensy 3.6 & 4.1 (#19593)

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 6ff2793e93..491c0692c7 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -231,6 +231,13 @@ bool Sd2Card::eraseSingleBlockEnable() {
  * The reason for failure can be determined by calling errorCode() and errorData().
  */
 bool Sd2Card::init(const uint8_t sckRateID, const pin_t chipSelectPin) {
+  #if IS_TEENSY_35_36 || IS_TEENSY_40_41
+    chipSelectPin_ = BUILTIN_SDCARD;
+    const uint8_t ret = SDHC_CardInit();
+    type_ = SDHC_CardGetType();
+    return (ret == 0);
+  #endif
+
   errorCode_ = type_ = 0;
   chipSelectPin_ = chipSelectPin;
   // 16-bit init start time allows over a minute
@@ -332,6 +339,10 @@ bool Sd2Card::init(const uint8_t sckRateID, const pin_t chipSelectPin) {
  * \return true for success, false for failure.
  */
 bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
+  #if IS_TEENSY_35_36 || IS_TEENSY_40_41
+    return 0 == SDHC_CardReadBlock(dst, blockNumber);
+  #endif
+
   if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;   // Use address if not SDHC card
 
   #if ENABLED(SD_CHECK_AND_RETRY)
@@ -547,6 +558,10 @@ bool Sd2Card::waitNotBusy(const millis_t timeout_ms) {
 bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
+  #if IS_TEENSY_35_36 || IS_TEENSY_40_41
+    return 0 == SDHC_CardWriteBlock(src, blockNumber);
+  #endif
+
   bool success = false;
   if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;   // Use address if not SDHC card
   if (!cardCommand(CMD24, blockNumber)) {

commit da4eaebdc9c1adc7387e302fe6516ed009974edd
Author: wmariz <11435639+wmariz@users.noreply.github.com>
Date:   Fri Aug 7 19:03:59 2020 -0300

    ZoneStar Z6FB (#18918)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index c56d690b2e..6ff2793e93 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -240,8 +240,15 @@ bool Sd2Card::init(const uint8_t sckRateID, const pin_t chipSelectPin) {
   watchdog_refresh(); // In case init takes too long
 
   // Set pin modes
-  extDigitalWrite(chipSelectPin_, HIGH);  // For some CPUs pinMode can write the wrong data so init desired data value first
-  pinMode(chipSelectPin_, OUTPUT);        // Solution for #8746 by @benlye
+  #if ENABLED(ZONESTAR_12864OLED)
+    if (chipSelectPin_ != DOGLCD_CS) {
+      SET_OUTPUT(DOGLCD_CS);
+      WRITE(DOGLCD_CS, HIGH);
+    }
+  #else
+    extDigitalWrite(chipSelectPin_, HIGH);  // For some CPUs pinMode can write the wrong data so init desired data value first
+    pinMode(chipSelectPin_, OUTPUT);        // Solution for #8746 by @benlye
+  #endif
   spiBegin();
 
   // Set SCK rate for initialization commands

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index b5a3960890..c56d690b2e 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit 801f99edadbf37966f231a8ae4b06fd93ff58cb1
Author: Leandro A. F. Pereira <leandro@hardinfo.org>
Date:   Sat May 30 21:59:29 2020 -0700

    SDCARD_READONLY (#17884)

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index e21662afc1..b5a3960890 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -179,8 +179,11 @@ void Sd2Card::chipSelect() {
  * \return true for success, false for failure.
  */
 bool Sd2Card::erase(uint32_t firstBlock, uint32_t lastBlock) {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   csd_t csd;
   if (!readCSD(&csd)) goto FAIL;
+
   // check for single block erase
   if (!csd.v1.erase_blk_en) {
     // erase size mask
@@ -535,9 +538,10 @@ bool Sd2Card::waitNotBusy(const millis_t timeout_ms) {
  * \return true for success, false for failure.
  */
 bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
-  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;   // Use address if not SDHC card
+  if (ENABLED(SDCARD_READONLY)) return false;
 
   bool success = false;
+  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;   // Use address if not SDHC card
   if (!cardCommand(CMD24, blockNumber)) {
     if (writeData(DATA_START_BLOCK, src)) {
       if (waitNotBusy(SD_WRITE_TIMEOUT)) {              // Wait for flashing to complete
@@ -561,6 +565,8 @@ bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
  * \return true for success, false for failure.
  */
 bool Sd2Card::writeData(const uint8_t* src) {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   bool success = true;
   chipSelect();
   // Wait for previous write to finish
@@ -574,14 +580,9 @@ bool Sd2Card::writeData(const uint8_t* src) {
 
 // Send one block of data for write block or write multiple blocks
 bool Sd2Card::writeData(const uint8_t token, const uint8_t* src) {
+  if (ENABLED(SDCARD_READONLY)) return false;
 
-  const uint16_t crc =
-    #if ENABLED(SD_CHECK_AND_RETRY)
-      CRC_CCITT(src, 512)
-    #else
-      0xFFFF
-    #endif
-  ;
+  const uint16_t crc = TERN(SD_CHECK_AND_RETRY, CRC_CCITT(src, 512), 0xFFFF);
   spiSendBlock(token, src);
   spiSend(crc >> 8);
   spiSend(crc & 0xFF);
@@ -607,6 +608,8 @@ bool Sd2Card::writeData(const uint8_t token, const uint8_t* src) {
  * \return true for success, false for failure.
  */
 bool Sd2Card::writeStart(uint32_t blockNumber, const uint32_t eraseCount) {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   bool success = false;
   if (!cardAcmd(ACMD23, eraseCount)) {                    // Send pre-erase count
     if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;   // Use address if not SDHC card
@@ -626,6 +629,8 @@ bool Sd2Card::writeStart(uint32_t blockNumber, const uint32_t eraseCount) {
  * \return true for success, false for failure.
  */
 bool Sd2Card::writeStop() {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   bool success = false;
   chipSelect();
   if (waitNotBusy(SD_WRITE_TIMEOUT)) {

commit 6c994002af1ef13004490b5e15501e6cdc70dd88
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Tue May 26 00:44:12 2020 -0500

    No SD_CHECK_AND_RETRY with USE_USB_COMPOSITE (STM32F103 + SDIO) (#18108)
    
    * disable SD_CHECK_AND_RETRY when USE_USB_COMPOSITE is enabled
    
    * Update Sd2Card.cpp
    
    * Disable SD_CHECK_AND_RETRY with USE_USB_COMPOSITE
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index ba233d36f6..e21662afc1 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -575,7 +575,7 @@ bool Sd2Card::writeData(const uint8_t* src) {
 // Send one block of data for write block or write multiple blocks
 bool Sd2Card::writeData(const uint8_t token, const uint8_t* src) {
 
-  uint16_t crc =
+  const uint16_t crc =
     #if ENABLED(SD_CHECK_AND_RETRY)
       CRC_CCITT(src, 512)
     #else

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index f82fab1b50..ba233d36f6 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -74,7 +74,7 @@
   #else
     static uint8_t CRC7(const uint8_t* data, uint8_t n) {
       uint8_t crc = 0;
-      for (uint8_t i = 0; i < n; i++) {
+      LOOP_L_N(i, n) {
         uint8_t d = data[i];
         d ^= crc << 1;
         if (d & 0x80) d ^= 9;
@@ -106,7 +106,7 @@ uint8_t Sd2Card::cardCommand(const uint8_t cmd, const uint32_t arg) {
     d[5] = CRC7(d, 5);
 
     // Send message
-    for (uint8_t k = 0; k < 6; k++) spiSend(d[k]);
+    LOOP_L_N(k, 6) spiSend(d[k]);
 
   #else
     // Send command
@@ -246,7 +246,7 @@ bool Sd2Card::init(const uint8_t sckRateID, const pin_t chipSelectPin) {
   spiInit(spiRate_);
 
   // Must supply min of 74 clock cycles with CS high.
-  for (uint8_t i = 0; i < 10; i++) spiSend(0xFF);
+  LOOP_L_N(i, 10) spiSend(0xFF);
 
   watchdog_refresh(); // In case init takes too long
 
@@ -272,7 +272,7 @@ bool Sd2Card::init(const uint8_t sckRateID, const pin_t chipSelectPin) {
     }
 
     // Get the last byte of r7 response
-    for (uint8_t i = 0; i < 4; i++) status_ = spiRec();
+    LOOP_L_N(i, 4) status_ = spiRec();
     if (status_ == 0xAA) {
       type(SD_CARD_TYPE_SD2);
       break;
@@ -303,7 +303,7 @@ bool Sd2Card::init(const uint8_t sckRateID, const pin_t chipSelectPin) {
     }
     if ((spiRec() & 0xC0) == 0xC0) type(SD_CARD_TYPE_SDHC);
     // Discard rest of ocr - contains allowed voltage range
-    for (uint8_t i = 0; i < 3; i++) spiRec();
+    LOOP_L_N(i, 3) spiRec();
   }
   chipDeselect();
 

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 01cb5ec1b8..f82fab1b50 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index a09de08fe5..01cb5ec1b8 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -38,7 +38,7 @@
 
 #include "Sd2Card.h"
 
-#include "../Marlin.h"
+#include "../MarlinCore.h"
 
 #if ENABLED(SD_CHECK_AND_RETRY)
   static bool crcSupported = true;

commit 139b7196a0eb2cf74763c9879ff5e1e14ac935c3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 17:57:29 2019 -0500

    Watchdog cleanup (#15283)

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index a6223858cb..a09de08fe5 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -234,11 +234,7 @@ bool Sd2Card::init(const uint8_t sckRateID, const pin_t chipSelectPin) {
   const millis_t init_timeout = millis() + SD_INIT_TIMEOUT;
   uint32_t arg;
 
-  // If init takes more than 4s it could trigger
-  // watchdog leading to a reboot loop.
-  #if ENABLED(USE_WATCHDOG)
-    watchdog_reset();
-  #endif
+  watchdog_refresh(); // In case init takes too long
 
   // Set pin modes
   extDigitalWrite(chipSelectPin_, HIGH);  // For some CPUs pinMode can write the wrong data so init desired data value first
@@ -252,10 +248,7 @@ bool Sd2Card::init(const uint8_t sckRateID, const pin_t chipSelectPin) {
   // Must supply min of 74 clock cycles with CS high.
   for (uint8_t i = 0; i < 10; i++) spiSend(0xFF);
 
-  // Initialization can cause the watchdog to timeout, so reinit it here
-  #if ENABLED(USE_WATCHDOG)
-    watchdog_reset();
-  #endif
+  watchdog_refresh(); // In case init takes too long
 
   // Command to go idle in SPI mode
   while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {
@@ -269,10 +262,7 @@ bool Sd2Card::init(const uint8_t sckRateID, const pin_t chipSelectPin) {
     crcSupported = (cardCommand(CMD59, 1) == R1_IDLE_STATE);
   #endif
 
-  // Initialization can cause the watchdog to timeout, so reinit it here
-  #if ENABLED(USE_WATCHDOG)
-    watchdog_reset();
-  #endif
+  watchdog_refresh(); // In case init takes too long
 
   // check SD version
   for (;;) {
@@ -294,10 +284,7 @@ bool Sd2Card::init(const uint8_t sckRateID, const pin_t chipSelectPin) {
     }
   }
 
-  // Initialization can cause the watchdog to timeout, so reinit it here
-  #if ENABLED(USE_WATCHDOG)
-    watchdog_reset();
-  #endif
+  watchdog_refresh(); // In case init takes too long
 
   // Initialize card and send host supports SDHC if SD2
   arg = type() == SD_CARD_TYPE_SD2 ? 0x40000000 : 0;

commit caa87d5fe1d497fadf797091199568d282a797a0
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Thu Jul 11 05:04:16 2019 +0200

    SD2Card cleanup (#14571)

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 7942adde5f..a6223858cb 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -227,7 +227,7 @@ bool Sd2Card::eraseSingleBlockEnable() {
  * \return true for success, false for failure.
  * The reason for failure can be determined by calling errorCode() and errorData().
  */
-bool Sd2Card::init(const uint8_t sckRateID/*=0*/, const pin_t chipSelectPin/*=SD_CHIP_SELECT_PIN*/) {
+bool Sd2Card::init(const uint8_t sckRateID, const pin_t chipSelectPin) {
   errorCode_ = type_ = 0;
   chipSelectPin_ = chipSelectPin;
   // 16-bit init start time allows over a minute

commit fe0224104498a42a3921b97ef3902581fba6c309
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:20:15 2019 -0500

    NONE on combined options

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 433db3ff85..7942adde5f 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -30,7 +30,7 @@
 
 #include "../inc/MarlinConfig.h"
 
-#if ENABLED(SDSUPPORT) && DISABLED(USB_FLASH_DRIVE_SUPPORT, SDIO_SUPPORT)
+#if ENABLED(SDSUPPORT) && NONE(USB_FLASH_DRIVE_SUPPORT, SDIO_SUPPORT)
 
 /* Enable FAST CRC computations - You can trade speed for FLASH space if
  * needed by disabling the following define */

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 0abc8142a0..433db3ff85 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -22,7 +22,7 @@
 
 /**
  * Arduino Sd2Card Library
- * Copyright (C) 2009 by William Greiman
+ * Copyright (c) 2009 by William Greiman
  * Updated with backports of the latest SdFat library from the same author
  *
  * This file is part of the Arduino Sd2Card Library

commit b376c7e374bbbc2cb69b6009c619f923f42f84b3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 17 05:50:06 2019 -0500

    Group DISABLED items

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 9d54012475..0abc8142a0 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -30,7 +30,7 @@
 
 #include "../inc/MarlinConfig.h"
 
-#if ENABLED(SDSUPPORT) && DISABLED(USB_FLASH_DRIVE_SUPPORT) && DISABLED(SDIO_SUPPORT)
+#if ENABLED(SDSUPPORT) && DISABLED(USB_FLASH_DRIVE_SUPPORT, SDIO_SUPPORT)
 
 /* Enable FAST CRC computations - You can trade speed for FLASH space if
  * needed by disabling the following define */

commit 2212da453aa8a575df529cd4333b5248d9bae5b5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 5 00:41:31 2019 -0600

    Distinguish between analog/digital auto fans (#13298)

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index ab221e4971..9d54012475 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -156,13 +156,13 @@ uint32_t Sd2Card::cardSize() {
 }
 
 void Sd2Card::chipDeselect() {
-  digitalWrite(chipSelectPin_, HIGH);
+  extDigitalWrite(chipSelectPin_, HIGH);
   spiSend(0xFF); // Ensure MISO goes high impedance
 }
 
 void Sd2Card::chipSelect() {
   spiInit(spiRate_);
-  digitalWrite(chipSelectPin_, LOW);
+  extDigitalWrite(chipSelectPin_, LOW);
 }
 
 /**
@@ -241,8 +241,8 @@ bool Sd2Card::init(const uint8_t sckRateID/*=0*/, const pin_t chipSelectPin/*=SD
   #endif
 
   // Set pin modes
-  digitalWrite(chipSelectPin_, HIGH);  // For some CPUs pinMode can write the wrong data so init desired data value first
-  pinMode(chipSelectPin_, OUTPUT);     // Solution for #8746 by @benlye
+  extDigitalWrite(chipSelectPin_, HIGH);  // For some CPUs pinMode can write the wrong data so init desired data value first
+  pinMode(chipSelectPin_, OUTPUT);        // Solution for #8746 by @benlye
   spiBegin();
 
   // Set SCK rate for initialization commands

commit 3a1b6fe8c19d22a15f9dddf012655fd5235bcd0f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 16:25:49 2019 -0600

    Coding standards

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index b734d17449..ab221e4971 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -339,7 +339,7 @@ bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
 
   #if ENABLED(SD_CHECK_AND_RETRY)
     uint8_t retryCnt = 3;
-    for(;;) {
+    for (;;) {
       if (cardCommand(CMD17, blockNumber))
         error(SD_CARD_ERROR_CMD17);
       else if (readData(dst, 512))

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 2011b0cea1..b734d17449 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit 712e23c3835b582e9098fc8e9f0b13d8fb0fb5a9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 17 18:03:58 2019 -0600

    Fix up some whitespace

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 6b5acf6d34..2011b0cea1 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -525,10 +525,7 @@ bool Sd2Card::readStop() {
  */
 bool Sd2Card::setSckRate(const uint8_t sckRateID) {
   const bool success = (sckRateID <= 6);
-  if (success) 
-    spiRate_ = sckRateID;
-  else
-    error(SD_CARD_ERROR_SCK_RATE);
+  if (success) spiRate_ = sckRateID; else error(SD_CARD_ERROR_SCK_RATE);
   return success;
 }
 
@@ -539,9 +536,7 @@ bool Sd2Card::setSckRate(const uint8_t sckRateID) {
  */
 bool Sd2Card::waitNotBusy(const millis_t timeout_ms) {
   const millis_t wait_timeout = millis() + timeout_ms;
-  while (spiRec() != 0xFF)
-    if (ELAPSED(millis(), wait_timeout)) return false;
-
+  while (spiRec() != 0xFF) if (ELAPSED(millis(), wait_timeout)) return false;
   return true;
 }
 

commit d372e7e4779ebd233d9f0a6dc3853fc1010c8b51
Author: jmz52 <jmz52@users.noreply.github.com>
Date:   Fri Jan 4 22:38:07 2019 +0300

    SDIO support for STM32F1 (#12782)

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 0f959a3ccb..6b5acf6d34 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -30,7 +30,7 @@
 
 #include "../inc/MarlinConfig.h"
 
-#if ENABLED(SDSUPPORT) && DISABLED(USB_FLASH_DRIVE_SUPPORT)
+#if ENABLED(SDSUPPORT) && DISABLED(USB_FLASH_DRIVE_SUPPORT) && DISABLED(SDIO_SUPPORT)
 
 /* Enable FAST CRC computations - You can trade speed for FLASH space if
  * needed by disabling the following define */

commit 60cb36bef3644640f2eb1c9d2b30189e41e81ef2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Jan 1 14:17:48 2019 -0700

    Misc. improvements (#12747)
    
    * Make ExtUI respect MAXTEMP limits
      - Temperatures are now clamped by MAXTEMP limits rather than arbitrary values.
    * Speed up USB init, add status
      - Speed up USB initialization
      - Show status message if init failed
    * Enable status messages for EXTENSIBLE_UI
    * Adjust max limit to MAX_TEMP - 15
    * Misc. tweaks to formatting, const, etc.

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index d1116cdb35..0f959a3ccb 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -65,7 +65,7 @@
 
     static uint8_t CRC7(const uint8_t* data, uint8_t n) {
       uint8_t crc = 0;
-      while ( n > 0 ) {
+      while (n > 0) {
         crc = pgm_read_byte(&crctab7[ (crc << 1) ^ *data++ ]);
         n--;
       }
@@ -87,44 +87,42 @@
   #endif
 #endif
 
-// send command and return error code.  Return zero for OK
-uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
-  // select card
+// Send command and return error code. Return zero for OK
+uint8_t Sd2Card::cardCommand(const uint8_t cmd, const uint32_t arg) {
+  // Select card
   chipSelect();
 
-  // wait up to 300 ms if busy
-  waitNotBusy( SD_WRITE_TIMEOUT );
+  // Wait up to 300 ms if busy
+  waitNotBusy(SD_WRITE_TIMEOUT);
 
   uint8_t *pa = (uint8_t *)(&arg);
 
-#if ENABLED(SD_CHECK_AND_RETRY)
+  #if ENABLED(SD_CHECK_AND_RETRY)
 
-  // form message
-  uint8_t d[6] = {(uint8_t) (cmd | 0x40), pa[3], pa[2], pa[1], pa[0] };
+    // Form message
+    uint8_t d[6] = {(uint8_t) (cmd | 0x40), pa[3], pa[2], pa[1], pa[0] };
 
-  // add crc
-  d[5] = CRC7(d, 5);
+    // Add crc
+    d[5] = CRC7(d, 5);
 
-  // send message
-  for (uint8_t k = 0; k < 6; k++ )
-    spiSend( d[k] );
+    // Send message
+    for (uint8_t k = 0; k < 6; k++) spiSend(d[k]);
 
-#else
-  // send command
-  spiSend(cmd | 0x40);
+  #else
+    // Send command
+    spiSend(cmd | 0x40);
 
-  // send argument
-  for( int8_t i = 3; i >= 0; i-- )
-    spiSend( pa[i] );
+    // Send argument
+    for (int8_t i = 3; i >= 0; i--) spiSend(pa[i]);
 
-  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
-  spiSend( cmd == CMD0 ? 0X95 : 0X87 );
-#endif
+    // Send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
+    spiSend(cmd == CMD0 ? 0X95 : 0X87);
+  #endif
 
-  // skip stuff byte for stop read
+  // Skip stuff byte for stop read
   if (cmd == CMD12) spiRec();
 
-  // wait for response
+  // Wait for response
   for (uint8_t i = 0; ((status_ = spiRec()) & 0x80) && i != 0xFF; i++) { /* Intentionally left empty */ }
   return status_;
 }
@@ -159,9 +157,7 @@ uint32_t Sd2Card::cardSize() {
 
 void Sd2Card::chipDeselect() {
   digitalWrite(chipSelectPin_, HIGH);
-
-  // insure MISO goes high impedance
-  spiSend( 0xFF );
+  spiSend(0xFF); // Ensure MISO goes high impedance
 }
 
 void Sd2Card::chipSelect() {
@@ -195,13 +191,8 @@ bool Sd2Card::erase(uint32_t firstBlock, uint32_t lastBlock) {
       goto FAIL;
     }
   }
-  if (type_ != SD_CARD_TYPE_SDHC) {
-    firstBlock <<= 9;
-    lastBlock <<= 9;
-  }
-  if (cardCommand(CMD32, firstBlock)
-      || cardCommand(CMD33, lastBlock)
-      || cardCommand(CMD38, 0)) {
+  if (type_ != SD_CARD_TYPE_SDHC) { firstBlock <<= 9; lastBlock <<= 9; }
+  if (cardCommand(CMD32, firstBlock) || cardCommand(CMD33, lastBlock) || cardCommand(CMD38, 0)) {
     error(SD_CARD_ERROR_ERASE);
     goto FAIL;
   }
@@ -236,7 +227,7 @@ bool Sd2Card::eraseSingleBlockEnable() {
  * \return true for success, false for failure.
  * The reason for failure can be determined by calling errorCode() and errorData().
  */
-bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
+bool Sd2Card::init(const uint8_t sckRateID/*=0*/, const pin_t chipSelectPin/*=SD_CHIP_SELECT_PIN*/) {
   errorCode_ = type_ = 0;
   chipSelectPin_ = chipSelectPin;
   // 16-bit init start time allows over a minute
@@ -308,23 +299,23 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
     watchdog_reset();
   #endif
 
-  // initialize card and send host supports SDHC if SD2
+  // Initialize card and send host supports SDHC if SD2
   arg = type() == SD_CARD_TYPE_SD2 ? 0x40000000 : 0;
   while ((status_ = cardAcmd(ACMD41, arg)) != R1_READY_STATE) {
-    // check for timeout
+    // Check for timeout
     if (ELAPSED(millis(), init_timeout)) {
       error(SD_CARD_ERROR_ACMD41);
       goto FAIL;
     }
   }
-  // if SD2 read OCR register to check for SDHC card
+  // If SD2 read OCR register to check for SDHC card
   if (type() == SD_CARD_TYPE_SD2) {
     if (cardCommand(CMD58, 0)) {
       error(SD_CARD_ERROR_CMD58);
       goto FAIL;
     }
     if ((spiRec() & 0xC0) == 0xC0) type(SD_CARD_TYPE_SDHC);
-    // discard rest of ocr - contains allowed voltage range
+    // Discard rest of ocr - contains allowed voltage range
     for (uint8_t i = 0; i < 3; i++) spiRec();
   }
   chipDeselect();
@@ -344,8 +335,7 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
  * \return true for success, false for failure.
  */
 bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
-  // use address if not SDHC card
-  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
+  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;   // Use address if not SDHC card
 
   #if ENABLED(SD_CHECK_AND_RETRY)
     uint8_t retryCnt = 3;
@@ -447,44 +437,39 @@ bool Sd2Card::readData(uint8_t* dst) {
   #endif
 #endif // SD_CHECK_AND_RETRY
 
-bool Sd2Card::readData(uint8_t* dst, uint16_t count) {
-  // wait for start block token
+bool Sd2Card::readData(uint8_t* dst, const uint16_t count) {
+  bool success = false;
+
   const millis_t read_timeout = millis() + SD_READ_TIMEOUT;
-  while ((status_ = spiRec()) == 0xFF) {
+  while ((status_ = spiRec()) == 0xFF) {      // Wait for start block token
     if (ELAPSED(millis(), read_timeout)) {
       error(SD_CARD_ERROR_READ_TIMEOUT);
       goto FAIL;
     }
   }
-  if (status_ != DATA_START_BLOCK) {
-    error(SD_CARD_ERROR_READ);
-    goto FAIL;
-  }
-  // transfer data
-  spiRead(dst, count);
 
-#if ENABLED(SD_CHECK_AND_RETRY)
-  {
-    uint16_t recvCrc = (spiRec() << 8) | spiRec();
-    if (crcSupported && recvCrc != CRC_CCITT(dst, count)) {
-      error(SD_CARD_ERROR_READ_CRC);
-      goto FAIL;
-    }
+  if (status_ == DATA_START_BLOCK) {
+    spiRead(dst, count);                      // Transfer data
+
+    const uint16_t recvCrc = (spiRec() << 8) | spiRec();
+    #if ENABLED(SD_CHECK_AND_RETRY)
+      success = !crcSupported || recvCrc == CRC_CCITT(dst, count);
+      if (!success) error(SD_CARD_ERROR_READ_CRC);
+    #else
+      success = true;
+      UNUSED(recvCrc);
+    #endif
   }
-#else
-  // discard CRC
-  spiRec();
-  spiRec();
-#endif
-  chipDeselect();
-  return true;
+  else
+    error(SD_CARD_ERROR_READ);
+
   FAIL:
   chipDeselect();
-  return false;
+  return success;
 }
 
 /** read CID or CSR register */
-bool Sd2Card::readRegister(uint8_t cmd, void* buf) {
+bool Sd2Card::readRegister(const uint8_t cmd, void* buf) {
   uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
   if (cardCommand(cmd, 0)) {
     error(SD_CARD_ERROR_READ_REG);
@@ -506,13 +491,11 @@ bool Sd2Card::readRegister(uint8_t cmd, void* buf) {
  */
 bool Sd2Card::readStart(uint32_t blockNumber) {
   if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
-  if (cardCommand(CMD18, blockNumber)) {
-    error(SD_CARD_ERROR_CMD18);
-    chipDeselect();
-    return false;
-  }
+
+  const bool success = !cardCommand(CMD18, blockNumber);
+  if (!success) error(SD_CARD_ERROR_CMD18);
   chipDeselect();
-  return true;
+  return success;
 }
 
 /**
@@ -522,13 +505,10 @@ bool Sd2Card::readStart(uint32_t blockNumber) {
  */
 bool Sd2Card::readStop() {
   chipSelect();
-  if (cardCommand(CMD12, 0)) {
-    error(SD_CARD_ERROR_CMD12);
-    chipDeselect();
-    return false;
-  }
+  const bool success = !cardCommand(CMD12, 0);
+  if (!success) error(SD_CARD_ERROR_CMD12);
   chipDeselect();
-  return true;
+  return success;
 }
 
 /**
@@ -543,16 +523,20 @@ bool Sd2Card::readStop() {
  * \return The value one, true, is returned for success and the value zero,
  * false, is returned for an invalid value of \a sckRateID.
  */
-bool Sd2Card::setSckRate(uint8_t sckRateID) {
-  if (sckRateID > 6) {
+bool Sd2Card::setSckRate(const uint8_t sckRateID) {
+  const bool success = (sckRateID <= 6);
+  if (success) 
+    spiRate_ = sckRateID;
+  else
     error(SD_CARD_ERROR_SCK_RATE);
-    return false;
-  }
-  spiRate_ = sckRateID;
-  return true;
+  return success;
 }
 
-// wait for card to go not busy
+/**
+ * Wait for card to become not-busy
+ * \param[in] timeout_ms Timeout to abort.
+ * \return true for success, false for timeout.
+ */
 bool Sd2Card::waitNotBusy(const millis_t timeout_ms) {
   const millis_t wait_timeout = millis() + timeout_ms;
   while (spiRec() != 0xFF)
@@ -562,36 +546,31 @@ bool Sd2Card::waitNotBusy(const millis_t timeout_ms) {
 }
 
 /**
- * Writes a 512 byte block to an SD card.
+ * Write a 512 byte block to an SD card.
  *
  * \param[in] blockNumber Logical block to be written.
  * \param[in] src Pointer to the location of the data to be written.
  * \return true for success, false for failure.
  */
 bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
-  // use address if not SDHC card
-  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
-  if (cardCommand(CMD24, blockNumber)) {
-    error(SD_CARD_ERROR_CMD24);
-    goto FAIL;
+  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;   // Use address if not SDHC card
+
+  bool success = false;
+  if (!cardCommand(CMD24, blockNumber)) {
+    if (writeData(DATA_START_BLOCK, src)) {
+      if (waitNotBusy(SD_WRITE_TIMEOUT)) {              // Wait for flashing to complete
+        success = !(cardCommand(CMD13, 0) || spiRec()); // Response is r2 so get and check two bytes for nonzero
+        if (!success) error(SD_CARD_ERROR_WRITE_PROGRAMMING);
+      }
+      else
+        error(SD_CARD_ERROR_WRITE_TIMEOUT);
+    }
   }
-  if (!writeData(DATA_START_BLOCK, src)) goto FAIL;
+  else
+    error(SD_CARD_ERROR_CMD24);
 
-  // wait for flash programming to complete
-  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
-    error(SD_CARD_ERROR_WRITE_TIMEOUT);
-    goto FAIL;
-  }
-  // response is r2 so get and check two bytes for nonzero
-  if (cardCommand(CMD13, 0) || spiRec()) {
-    error(SD_CARD_ERROR_WRITE_PROGRAMMING);
-    goto FAIL;
-  }
   chipDeselect();
-  return true;
-  FAIL:
-  chipDeselect();
-  return false;
+  return success;
 }
 
 /**
@@ -600,28 +579,30 @@ bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
  * \return true for success, false for failure.
  */
 bool Sd2Card::writeData(const uint8_t* src) {
+  bool success = true;
   chipSelect();
-  // wait for previous write to finish
+  // Wait for previous write to finish
   if (!waitNotBusy(SD_WRITE_TIMEOUT) || !writeData(WRITE_MULTIPLE_TOKEN, src)) {
     error(SD_CARD_ERROR_WRITE_MULTIPLE);
-    chipDeselect();
-    return false;
+    success = false;
   }
   chipDeselect();
-  return true;
+  return success;
 }
 
-// send one block of data for write block or write multiple blocks
-bool Sd2Card::writeData(uint8_t token, const uint8_t* src) {
+// Send one block of data for write block or write multiple blocks
+bool Sd2Card::writeData(const uint8_t token, const uint8_t* src) {
 
-#if ENABLED(SD_CHECK_AND_RETRY)
-  uint16_t crc = CRC_CCITT( src, 512 );
-#else  // ENABLED(SD_CHECK_AND_RETRY)
-  uint16_t crc = 0xFFFF;
-#endif  // ENABLED(SD_CHECK_AND_RETRY)
-  spiSendBlock( token, src );
-  spiSend( crc >> 8 );
-  spiSend( crc & 0XFF );
+  uint16_t crc =
+    #if ENABLED(SD_CHECK_AND_RETRY)
+      CRC_CCITT(src, 512)
+    #else
+      0xFFFF
+    #endif
+  ;
+  spiSendBlock(token, src);
+  spiSend(crc >> 8);
+  spiSend(crc & 0xFF);
 
   status_ = spiRec();
   if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
@@ -643,23 +624,18 @@ bool Sd2Card::writeData(uint8_t token, const uint8_t* src) {
  *
  * \return true for success, false for failure.
  */
-bool Sd2Card::writeStart(uint32_t blockNumber, uint32_t eraseCount) {
-  // send pre-erase count
-  if (cardAcmd(ACMD23, eraseCount)) {
-    error(SD_CARD_ERROR_ACMD23);
-    goto FAIL;
-  }
-  // use address if not SDHC card
-  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
-  if (cardCommand(CMD25, blockNumber)) {
-    error(SD_CARD_ERROR_CMD25);
-    goto FAIL;
+bool Sd2Card::writeStart(uint32_t blockNumber, const uint32_t eraseCount) {
+  bool success = false;
+  if (!cardAcmd(ACMD23, eraseCount)) {                    // Send pre-erase count
+    if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;   // Use address if not SDHC card
+    success = !cardCommand(CMD25, blockNumber);
+    if (!success) error(SD_CARD_ERROR_CMD25);
   }
+  else
+    error(SD_CARD_ERROR_ACMD23);
+
   chipDeselect();
-  return true;
-  FAIL:
-  chipDeselect();
-  return false;
+  return success;
 }
 
 /**
@@ -668,16 +644,17 @@ bool Sd2Card::writeStart(uint32_t blockNumber, uint32_t eraseCount) {
  * \return true for success, false for failure.
  */
 bool Sd2Card::writeStop() {
+  bool success = false;
   chipSelect();
-  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto FAIL;
-  spiSend(STOP_TRAN_TOKEN);
-  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto FAIL;
-  chipDeselect();
-  return true;
-  FAIL:
-  error(SD_CARD_ERROR_STOP_TRAN);
+  if (waitNotBusy(SD_WRITE_TIMEOUT)) {
+    spiSend(STOP_TRAN_TOKEN);
+    success = waitNotBusy(SD_WRITE_TIMEOUT);
+  }
+  else
+    error(SD_CARD_ERROR_STOP_TRAN);
+
   chipDeselect();
-  return false;
+  return success;
 }
 
 #endif // SDSUPPORT

commit 44369d536a658a7ab5c75f33646ab170a5250825
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sun Oct 21 06:21:27 2018 +0200

    Use millis_t where needed (#12152)

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 153611d7ad..d1116cdb35 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -240,7 +240,7 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
   errorCode_ = type_ = 0;
   chipSelectPin_ = chipSelectPin;
   // 16-bit init start time allows over a minute
-  uint16_t t0 = (uint16_t)millis();
+  const millis_t init_timeout = millis() + SD_INIT_TIMEOUT;
   uint32_t arg;
 
   // If init takes more than 4s it could trigger
@@ -268,7 +268,7 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
 
   // Command to go idle in SPI mode
   while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {
-    if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
+    if (ELAPSED(millis(), init_timeout)) {
       error(SD_CARD_ERROR_CMD0);
       goto FAIL;
     }
@@ -297,7 +297,7 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
       break;
     }
 
-    if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
+    if (ELAPSED(millis(), init_timeout)) {
       error(SD_CARD_ERROR_CMD8);
       goto FAIL;
     }
@@ -312,7 +312,7 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
   arg = type() == SD_CARD_TYPE_SD2 ? 0x40000000 : 0;
   while ((status_ = cardAcmd(ACMD41, arg)) != R1_READY_STATE) {
     // check for timeout
-    if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
+    if (ELAPSED(millis(), init_timeout)) {
       error(SD_CARD_ERROR_ACMD41);
       goto FAIL;
     }
@@ -449,9 +449,9 @@ bool Sd2Card::readData(uint8_t* dst) {
 
 bool Sd2Card::readData(uint8_t* dst, uint16_t count) {
   // wait for start block token
-  uint16_t t0 = millis();
+  const millis_t read_timeout = millis() + SD_READ_TIMEOUT;
   while ((status_ = spiRec()) == 0xFF) {
-    if (((uint16_t)millis() - t0) > SD_READ_TIMEOUT) {
+    if (ELAPSED(millis(), read_timeout)) {
       error(SD_CARD_ERROR_READ_TIMEOUT);
       goto FAIL;
     }
@@ -553,10 +553,10 @@ bool Sd2Card::setSckRate(uint8_t sckRateID) {
 }
 
 // wait for card to go not busy
-bool Sd2Card::waitNotBusy(uint16_t timeoutMillis) {
-  uint16_t t0 = millis();
+bool Sd2Card::waitNotBusy(const millis_t timeout_ms) {
+  const millis_t wait_timeout = millis() + timeout_ms;
   while (spiRec() != 0xFF)
-    if (((uint16_t)millis() - t0) >= timeoutMillis) return false;
+    if (ELAPSED(millis(), wait_timeout)) return false;
 
   return true;
 }

commit 2067619a269f2b4a6e52fdcb1f968e48b952a7d1
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Jul 2 09:06:17 2018 -0600

    Add USB_FLASH_DRIVE_SUPPORT

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index b52e4fa16d..153611d7ad 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -30,7 +30,7 @@
 
 #include "../inc/MarlinConfig.h"
 
-#if ENABLED(SDSUPPORT)
+#if ENABLED(SDSUPPORT) && DISABLED(USB_FLASH_DRIVE_SUPPORT)
 
 /* Enable FAST CRC computations - You can trade speed for FLASH space if
  * needed by disabling the following define */

commit d1b619be52c7af5c506add9ee78d4a4742e22b9c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 8 09:17:44 2018 -0500

    Standardize some hexadecimals

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 174a8ffd4a..b52e4fa16d 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -45,22 +45,22 @@
 
   #ifdef FAST_CRC
     static const uint8_t crctab7[] PROGMEM = {
-      0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
-      0x19,0x10,0x0b,0x02,0x3d,0x34,0x2f,0x26,0x51,0x58,0x43,0x4a,0x75,0x7c,0x67,0x6e,
-      0x32,0x3b,0x20,0x29,0x16,0x1f,0x04,0x0d,0x7a,0x73,0x68,0x61,0x5e,0x57,0x4c,0x45,
-      0x2b,0x22,0x39,0x30,0x0f,0x06,0x1d,0x14,0x63,0x6a,0x71,0x78,0x47,0x4e,0x55,0x5c,
-      0x64,0x6d,0x76,0x7f,0x40,0x49,0x52,0x5b,0x2c,0x25,0x3e,0x37,0x08,0x01,0x1a,0x13,
-      0x7d,0x74,0x6f,0x66,0x59,0x50,0x4b,0x42,0x35,0x3c,0x27,0x2e,0x11,0x18,0x03,0x0a,
-      0x56,0x5f,0x44,0x4d,0x72,0x7b,0x60,0x69,0x1e,0x17,0x0c,0x05,0x3a,0x33,0x28,0x21,
-      0x4f,0x46,0x5d,0x54,0x6b,0x62,0x79,0x70,0x07,0x0e,0x15,0x1c,0x23,0x2a,0x31,0x38,
-      0x41,0x48,0x53,0x5a,0x65,0x6c,0x77,0x7e,0x09,0x00,0x1b,0x12,0x2d,0x24,0x3f,0x36,
-      0x58,0x51,0x4a,0x43,0x7c,0x75,0x6e,0x67,0x10,0x19,0x02,0x0b,0x34,0x3d,0x26,0x2f,
-      0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,
-      0x6a,0x63,0x78,0x71,0x4e,0x47,0x5c,0x55,0x22,0x2b,0x30,0x39,0x06,0x0f,0x14,0x1d,
-      0x25,0x2c,0x37,0x3e,0x01,0x08,0x13,0x1a,0x6d,0x64,0x7f,0x76,0x49,0x40,0x5b,0x52,
-      0x3c,0x35,0x2e,0x27,0x18,0x11,0x0a,0x03,0x74,0x7d,0x66,0x6f,0x50,0x59,0x42,0x4b,
-      0x17,0x1e,0x05,0x0c,0x33,0x3a,0x21,0x28,0x5f,0x56,0x4d,0x44,0x7b,0x72,0x69,0x60,
-      0x0e,0x07,0x1c,0x15,0x2a,0x23,0x38,0x31,0x46,0x4f,0x54,0x5d,0x62,0x6b,0x70,0x79
+      0x00,0x09,0x12,0x1B,0x24,0x2D,0x36,0x3F,0x48,0x41,0x5A,0x53,0x6C,0x65,0x7E,0x77,
+      0x19,0x10,0x0B,0x02,0x3D,0x34,0x2F,0x26,0x51,0x58,0x43,0x4A,0x75,0x7C,0x67,0x6E,
+      0x32,0x3B,0x20,0x29,0x16,0x1F,0x04,0x0D,0x7A,0x73,0x68,0x61,0x5E,0x57,0x4C,0x45,
+      0x2B,0x22,0x39,0x30,0x0F,0x06,0x1D,0x14,0x63,0x6A,0x71,0x78,0x47,0x4E,0x55,0x5C,
+      0x64,0x6D,0x76,0x7F,0x40,0x49,0x52,0x5B,0x2C,0x25,0x3E,0x37,0x08,0x01,0x1A,0x13,
+      0x7D,0x74,0x6F,0x66,0x59,0x50,0x4B,0x42,0x35,0x3C,0x27,0x2E,0x11,0x18,0x03,0x0A,
+      0x56,0x5F,0x44,0x4D,0x72,0x7B,0x60,0x69,0x1E,0x17,0x0C,0x05,0x3A,0x33,0x28,0x21,
+      0x4F,0x46,0x5D,0x54,0x6B,0x62,0x79,0x70,0x07,0x0E,0x15,0x1C,0x23,0x2A,0x31,0x38,
+      0x41,0x48,0x53,0x5A,0x65,0x6C,0x77,0x7E,0x09,0x00,0x1B,0x12,0x2D,0x24,0x3F,0x36,
+      0x58,0x51,0x4A,0x43,0x7C,0x75,0x6E,0x67,0x10,0x19,0x02,0x0B,0x34,0x3D,0x26,0x2F,
+      0x73,0x7A,0x61,0x68,0x57,0x5E,0x45,0x4C,0x3B,0x32,0x29,0x20,0x1F,0x16,0x0D,0x04,
+      0x6A,0x63,0x78,0x71,0x4E,0x47,0x5C,0x55,0x22,0x2B,0x30,0x39,0x06,0x0F,0x14,0x1D,
+      0x25,0x2C,0x37,0x3E,0x01,0x08,0x13,0x1A,0x6D,0x64,0x7F,0x76,0x49,0x40,0x5B,0x52,
+      0x3C,0x35,0x2E,0x27,0x18,0x11,0x0A,0x03,0x74,0x7D,0x66,0x6F,0x50,0x59,0x42,0x4B,
+      0x17,0x1E,0x05,0x0C,0x33,0x3A,0x21,0x28,0x5F,0x56,0x4D,0x44,0x7B,0x72,0x69,0x60,
+      0x0E,0x07,0x1C,0x15,0x2A,0x23,0x38,0x31,0x46,0x4F,0x54,0x5D,0x62,0x6B,0x70,0x79
     };
 
     static uint8_t CRC7(const uint8_t* data, uint8_t n) {
@@ -79,9 +79,9 @@
         d ^= crc << 1;
         if (d & 0x80) d ^= 9;
         crc = d ^ (crc & 0x78) ^ (crc << 4) ^ ((crc >> 3) & 15);
-        crc &= 0x7f;
+        crc &= 0x7F;
       }
-      crc = (crc << 1) ^ (crc << 4) ^ (crc & 0x70) ^ ((crc >> 3) & 0x0f);
+      crc = (crc << 1) ^ (crc << 4) ^ (crc & 0x70) ^ ((crc >> 3) & 0x0F);
       return crc | 1;
     }
   #endif
@@ -438,9 +438,9 @@ bool Sd2Card::readData(uint8_t* dst) {
       for (size_t i = 0; i < n; i++) {
         crc = (uint8_t)(crc >> 8) | (crc << 8);
         crc ^= data[i];
-        crc ^= (uint8_t)(crc & 0xff) >> 4;
+        crc ^= (uint8_t)(crc & 0xFF) >> 4;
         crc ^= crc << 12;
-        crc ^= (crc & 0xff) << 5;
+        crc ^= (crc & 0xFF) << 5;
       }
       return crc;
     }

commit 902c885782d389905d5c34c78a19e2be8d7e6cf5
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Wed Apr 4 20:13:27 2018 -0500

    Switch to TMC2130 compatible hardware SPI & misc (#10299)

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 9216480e20..174a8ffd4a 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -249,15 +249,16 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
     watchdog_reset();
   #endif
 
-  // set pin modes
-  pinMode(chipSelectPin_, OUTPUT); // Solution for #8746 by @benlye
+  // Set pin modes
+  digitalWrite(chipSelectPin_, HIGH);  // For some CPUs pinMode can write the wrong data so init desired data value first
+  pinMode(chipSelectPin_, OUTPUT);     // Solution for #8746 by @benlye
   spiBegin();
 
-  // set SCK rate for initialization commands
+  // Set SCK rate for initialization commands
   spiRate_ = SPI_SD_INIT_RATE;
   spiInit(spiRate_);
 
-  // must supply min of 74 clock cycles with CS high.
+  // Must supply min of 74 clock cycles with CS high.
   for (uint8_t i = 0; i < 10; i++) spiSend(0xFF);
 
   // Initialization can cause the watchdog to timeout, so reinit it here
@@ -265,7 +266,7 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
     watchdog_reset();
   #endif
 
-  // command to go idle in SPI mode
+  // Command to go idle in SPI mode
   while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {
     if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
       error(SD_CARD_ERROR_CMD0);

commit 97e8a6ebd972ce0ad5b4e27aa139b9bb074ff44e
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Wed Mar 21 21:04:45 2018 -0300

    Various fixes for DUE... (#10152)
    
    - Watchdog reset during SD Card initialization.
    - Move `DebugMonitor` to `DebugMonitor_Due.cpp`.
    - Since the watchdog is enabled on boot do extra resets during init.
    - Have `thermalManager` do watchdog reset before its ISR starts to prevent reset.
    - Ensure that timers are stopped before reprogramming them to address tone issues.
    - Improve SAM3XE reset when reflashed through the native port.

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index da831525ef..9216480e20 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -260,6 +260,11 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
   // must supply min of 74 clock cycles with CS high.
   for (uint8_t i = 0; i < 10; i++) spiSend(0xFF);
 
+  // Initialization can cause the watchdog to timeout, so reinit it here
+  #if ENABLED(USE_WATCHDOG)
+    watchdog_reset();
+  #endif
+
   // command to go idle in SPI mode
   while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {
     if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
@@ -272,6 +277,11 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
     crcSupported = (cardCommand(CMD59, 1) == R1_IDLE_STATE);
   #endif
 
+  // Initialization can cause the watchdog to timeout, so reinit it here
+  #if ENABLED(USE_WATCHDOG)
+    watchdog_reset();
+  #endif
+
   // check SD version
   for (;;) {
     if (cardCommand(CMD8, 0x1AA) == (R1_ILLEGAL_COMMAND | R1_IDLE_STATE)) {
@@ -292,6 +302,11 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
     }
   }
 
+  // Initialization can cause the watchdog to timeout, so reinit it here
+  #if ENABLED(USE_WATCHDOG)
+    watchdog_reset();
+  #endif
+
   // initialize card and send host supports SDHC if SD2
   arg = type() == SD_CARD_TYPE_SD2 ? 0x40000000 : 0;
   while ((status_ = cardAcmd(ACMD41, arg)) != R1_READY_STATE) {

commit 02474a321afdd691500d0f9da8a97990677e874d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 26 14:40:40 2018 -0600

    Fix SDSUPPORT (and indentation)
    
    Based on https://github.com/MarlinFirmware/Marlin/issues/8746#issuecomment-368471901 by @benlye

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index ff82cdaac8..da831525ef 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -250,7 +250,7 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
   #endif
 
   // set pin modes
-//todo: should use chipSelectPin ?
+  pinMode(chipSelectPin_, OUTPUT); // Solution for #8746 by @benlye
   spiBegin();
 
   // set SCK rate for initialization commands
@@ -268,18 +268,18 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
     }
   }
 
-#if ENABLED(SD_CHECK_AND_RETRY)
-  crcSupported = (cardCommand(CMD59, 1) == R1_IDLE_STATE);
-#endif
+  #if ENABLED(SD_CHECK_AND_RETRY)
+    crcSupported = (cardCommand(CMD59, 1) == R1_IDLE_STATE);
+  #endif
 
   // check SD version
-  while (1) {
+  for (;;) {
     if (cardCommand(CMD8, 0x1AA) == (R1_ILLEGAL_COMMAND | R1_IDLE_STATE)) {
-    type(SD_CARD_TYPE_SD1);
+      type(SD_CARD_TYPE_SD1);
       break;
-  }
+    }
 
-    // only need last byte of r7 response
+    // Get the last byte of r7 response
     for (uint8_t i = 0; i < 4; i++) status_ = spiRec();
     if (status_ == 0xAA) {
       type(SD_CARD_TYPE_SD2);

commit 6667a916a4f6341316bf155c1f88f8003feca0a6
Author: GMagician <GMagician@users.noreply.github.com>
Date:   Sat Jan 13 09:48:26 2018 +0100

    Indentation fix

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index ba26243c95..ff82cdaac8 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -345,7 +345,7 @@ bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
       cardCommand(CMD12, 0); // Try sending a stop command, ignore the result.
       errorCode_ = 0;
     }
-  return false;
+    return false;
   #else
     if (cardCommand(CMD17, blockNumber)) {
       error(SD_CARD_ERROR_CMD17);

commit be717b3c07e15b81c3e4ba8b5d839f66fbdf42a1
Author: GMagician <GMagician@users.noreply.github.com>
Date:   Sat Jan 13 08:56:51 2018 +0100

    Save some program memory
    
    This will save some program memory with no speed lose

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index adecc8e61c..ba26243c95 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -339,21 +339,22 @@ bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
       else if (readData(dst, 512))
         return true;
 
+      chipDeselect();
       if (!--retryCnt) break;
 
-      chipDeselect();
       cardCommand(CMD12, 0); // Try sending a stop command, ignore the result.
       errorCode_ = 0;
     }
+  return false;
   #else
-    if (cardCommand(CMD17, blockNumber))
+    if (cardCommand(CMD17, blockNumber)) {
       error(SD_CARD_ERROR_CMD17);
+      chipDeselect();
+      return false;
+    }
     else
       return readData(dst, 512);
   #endif
-
-  chipDeselect();
-  return false;
 }
 
 /**

commit f37c64ee5b640ef9c2e295db792c34c9f1f8369f
Author: GMagician <GMagician@users.noreply.github.com>
Date:   Sat Jan 13 08:53:12 2018 +0100

    Fix unsupported CMD59
    
    It seems that some SD cards don't support CRC_ON_OFF command. This fix will permit to use also these cards but leaving CRC check active on the system

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 4392c06b28..adecc8e61c 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -41,6 +41,8 @@
 #include "../Marlin.h"
 
 #if ENABLED(SD_CHECK_AND_RETRY)
+  static bool crcSupported = true;
+
   #ifdef FAST_CRC
     static const uint8_t crctab7[] PROGMEM = {
       0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
@@ -267,10 +269,7 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
   }
 
 #if ENABLED(SD_CHECK_AND_RETRY)
-  if (cardCommand( CMD59, 1 ) != R1_IDLE_STATE) {
-    error(SD_CARD_ERROR_CMD59);
-    goto FAIL;
-  }
+  crcSupported = (cardCommand(CMD59, 1) == R1_IDLE_STATE);
 #endif
 
   // check SD version
@@ -450,7 +449,7 @@ bool Sd2Card::readData(uint8_t* dst, uint16_t count) {
 #if ENABLED(SD_CHECK_AND_RETRY)
   {
     uint16_t recvCrc = (spiRec() << 8) | spiRec();
-    if (recvCrc != CRC_CCITT(dst, count)) {
+    if (crcSupported && recvCrc != CRC_CCITT(dst, count)) {
       error(SD_CARD_ERROR_READ_CRC);
       goto FAIL;
     }

commit 9aff55ed1fab03fd26359591848556ed98a63ce9
Author: etagle <ejtagle@hotmail.com>
Date:   Thu Dec 21 02:29:00 2017 -0300

    Backported latest improvements and fixes from the SdFat liibrary to our own version. This includes support for CRC7 validation on commands and also, made sure that even if using software SPI implementations, SD card speed is properly adjusted when transitioning from INITIALIZATION to DATA TRANSFER mode. ALL HALs implement spiInit, even in SW SPI mode, and we NEED this change to improve 25x the transfer speed of the SD card and allow implementations of USB MSD

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index f746a22773..4392c06b28 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -23,6 +23,7 @@
 /**
  * Arduino Sd2Card Library
  * Copyright (C) 2009 by William Greiman
+ * Updated with backports of the latest SdFat library from the same author
  *
  * This file is part of the Arduino Sd2Card Library
  */
@@ -31,29 +32,92 @@
 
 #if ENABLED(SDSUPPORT)
 
+/* Enable FAST CRC computations - You can trade speed for FLASH space if
+ * needed by disabling the following define */
+#define FAST_CRC 1
+
 #include "Sd2Card.h"
 
 #include "../Marlin.h"
 
+#if ENABLED(SD_CHECK_AND_RETRY)
+  #ifdef FAST_CRC
+    static const uint8_t crctab7[] PROGMEM = {
+      0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
+      0x19,0x10,0x0b,0x02,0x3d,0x34,0x2f,0x26,0x51,0x58,0x43,0x4a,0x75,0x7c,0x67,0x6e,
+      0x32,0x3b,0x20,0x29,0x16,0x1f,0x04,0x0d,0x7a,0x73,0x68,0x61,0x5e,0x57,0x4c,0x45,
+      0x2b,0x22,0x39,0x30,0x0f,0x06,0x1d,0x14,0x63,0x6a,0x71,0x78,0x47,0x4e,0x55,0x5c,
+      0x64,0x6d,0x76,0x7f,0x40,0x49,0x52,0x5b,0x2c,0x25,0x3e,0x37,0x08,0x01,0x1a,0x13,
+      0x7d,0x74,0x6f,0x66,0x59,0x50,0x4b,0x42,0x35,0x3c,0x27,0x2e,0x11,0x18,0x03,0x0a,
+      0x56,0x5f,0x44,0x4d,0x72,0x7b,0x60,0x69,0x1e,0x17,0x0c,0x05,0x3a,0x33,0x28,0x21,
+      0x4f,0x46,0x5d,0x54,0x6b,0x62,0x79,0x70,0x07,0x0e,0x15,0x1c,0x23,0x2a,0x31,0x38,
+      0x41,0x48,0x53,0x5a,0x65,0x6c,0x77,0x7e,0x09,0x00,0x1b,0x12,0x2d,0x24,0x3f,0x36,
+      0x58,0x51,0x4a,0x43,0x7c,0x75,0x6e,0x67,0x10,0x19,0x02,0x0b,0x34,0x3d,0x26,0x2f,
+      0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,
+      0x6a,0x63,0x78,0x71,0x4e,0x47,0x5c,0x55,0x22,0x2b,0x30,0x39,0x06,0x0f,0x14,0x1d,
+      0x25,0x2c,0x37,0x3e,0x01,0x08,0x13,0x1a,0x6d,0x64,0x7f,0x76,0x49,0x40,0x5b,0x52,
+      0x3c,0x35,0x2e,0x27,0x18,0x11,0x0a,0x03,0x74,0x7d,0x66,0x6f,0x50,0x59,0x42,0x4b,
+      0x17,0x1e,0x05,0x0c,0x33,0x3a,0x21,0x28,0x5f,0x56,0x4d,0x44,0x7b,0x72,0x69,0x60,
+      0x0e,0x07,0x1c,0x15,0x2a,0x23,0x38,0x31,0x46,0x4f,0x54,0x5d,0x62,0x6b,0x70,0x79
+    };
+
+    static uint8_t CRC7(const uint8_t* data, uint8_t n) {
+      uint8_t crc = 0;
+      while ( n > 0 ) {
+        crc = pgm_read_byte(&crctab7[ (crc << 1) ^ *data++ ]);
+        n--;
+      }
+      return (crc << 1) | 1;
+    }
+  #else
+    static uint8_t CRC7(const uint8_t* data, uint8_t n) {
+      uint8_t crc = 0;
+      for (uint8_t i = 0; i < n; i++) {
+        uint8_t d = data[i];
+        d ^= crc << 1;
+        if (d & 0x80) d ^= 9;
+        crc = d ^ (crc & 0x78) ^ (crc << 4) ^ ((crc >> 3) & 15);
+        crc &= 0x7f;
+      }
+      crc = (crc << 1) ^ (crc << 4) ^ (crc & 0x70) ^ ((crc >> 3) & 0x0f);
+      return crc | 1;
+    }
+  #endif
+#endif
+
 // send command and return error code.  Return zero for OK
 uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
   // select card
-  chipSelectLow();
+  chipSelect();
 
   // wait up to 300 ms if busy
-  waitNotBusy(300);
+  waitNotBusy( SD_WRITE_TIMEOUT );
+
+  uint8_t *pa = (uint8_t *)(&arg);
 
+#if ENABLED(SD_CHECK_AND_RETRY)
+
+  // form message
+  uint8_t d[6] = {(uint8_t) (cmd | 0x40), pa[3], pa[2], pa[1], pa[0] };
+
+  // add crc
+  d[5] = CRC7(d, 5);
+
+  // send message
+  for (uint8_t k = 0; k < 6; k++ )
+    spiSend( d[k] );
+
+#else
   // send command
   spiSend(cmd | 0x40);
 
   // send argument
-  for (int8_t s = 24; s >= 0; s -= 8) spiSend(arg >> s);
+  for( int8_t i = 3; i >= 0; i-- )
+    spiSend( pa[i] );
 
-  // send CRC
-  uint8_t crc = 0xFF;
-  if (cmd == CMD0) crc = 0x95;  // correct crc for CMD0 with arg 0
-  if (cmd == CMD8) crc = 0x87;  // correct crc for CMD8 with arg 0x1AA
-  spiSend(crc);
+  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
+  spiSend( cmd == CMD0 ? 0X95 : 0X87 );
+#endif
 
   // skip stuff byte for stop read
   if (cmd == CMD12) spiRec();
@@ -91,14 +155,15 @@ uint32_t Sd2Card::cardSize() {
   }
 }
 
-void Sd2Card::chipSelectHigh() {
+void Sd2Card::chipDeselect() {
   digitalWrite(chipSelectPin_, HIGH);
+
+  // insure MISO goes high impedance
+  spiSend( 0xFF );
 }
 
-void Sd2Card::chipSelectLow() {
-  #if DISABLED(SOFTWARE_SPI)
-    spiInit(spiRate_);
-  #endif  // SOFTWARE_SPI
+void Sd2Card::chipSelect() {
+  spiInit(spiRate_);
   digitalWrite(chipSelectPin_, LOW);
 }
 
@@ -142,10 +207,10 @@ bool Sd2Card::erase(uint32_t firstBlock, uint32_t lastBlock) {
     error(SD_CARD_ERROR_ERASE_TIMEOUT);
     goto FAIL;
   }
-  chipSelectHigh();
+  chipDeselect();
   return true;
   FAIL:
-  chipSelectHigh();
+  chipDeselect();
   return false;
 }
 
@@ -200,22 +265,36 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
       goto FAIL;
     }
   }
+
+#if ENABLED(SD_CHECK_AND_RETRY)
+  if (cardCommand( CMD59, 1 ) != R1_IDLE_STATE) {
+    error(SD_CARD_ERROR_CMD59);
+    goto FAIL;
+  }
+#endif
+
   // check SD version
-  if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
+  while (1) {
+    if (cardCommand(CMD8, 0x1AA) == (R1_ILLEGAL_COMMAND | R1_IDLE_STATE)) {
     type(SD_CARD_TYPE_SD1);
+      break;
   }
-  else {
+
     // only need last byte of r7 response
     for (uint8_t i = 0; i < 4; i++) status_ = spiRec();
-    if (status_ != 0xAA) {
+    if (status_ == 0xAA) {
+      type(SD_CARD_TYPE_SD2);
+      break;
+    }
+
+    if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
       error(SD_CARD_ERROR_CMD8);
       goto FAIL;
     }
-    type(SD_CARD_TYPE_SD2);
   }
+
   // initialize card and send host supports SDHC if SD2
   arg = type() == SD_CARD_TYPE_SD2 ? 0x40000000 : 0;
-
   while ((status_ = cardAcmd(ACMD41, arg)) != R1_READY_STATE) {
     // check for timeout
     if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
@@ -233,17 +312,12 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
     // discard rest of ocr - contains allowed voltage range
     for (uint8_t i = 0; i < 3; i++) spiRec();
   }
-  chipSelectHigh();
+  chipDeselect();
 
-  #if DISABLED(SOFTWARE_SPI)
-    return setSckRate(sckRateID);
-  #else  // SOFTWARE_SPI
-    UNUSED(sckRateID);
-    return true;
-  #endif  // SOFTWARE_SPI
+  return setSckRate(sckRateID);
 
   FAIL:
-  chipSelectHigh();
+  chipDeselect();
   return false;
 }
 
@@ -268,7 +342,7 @@ bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
 
       if (!--retryCnt) break;
 
-      chipSelectHigh();
+      chipDeselect();
       cardCommand(CMD12, 0); // Try sending a stop command, ignore the result.
       errorCode_ = 0;
     }
@@ -279,7 +353,7 @@ bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
       return readData(dst, 512);
   #endif
 
-  chipSelectHigh();
+  chipDeselect();
   return false;
 }
 
@@ -291,12 +365,13 @@ bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
  * \return true for success, false for failure.
  */
 bool Sd2Card::readData(uint8_t* dst) {
-  chipSelectLow();
+  chipSelect();
   return readData(dst, 512);
 }
 
 #if ENABLED(SD_CHECK_AND_RETRY)
-  static const uint16_t crctab[] PROGMEM = {
+  #ifdef FAST_CRC
+  static const uint16_t crctab16[] PROGMEM = {
     0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
     0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
     0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
@@ -330,13 +405,30 @@ bool Sd2Card::readData(uint8_t* dst) {
     0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
     0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
   };
+    // faster CRC-CCITT
+    // uses the x^16,x^12,x^5,x^1 polynomial.
   static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
     uint16_t crc = 0;
     for (size_t i = 0; i < n; i++) {
-      crc = pgm_read_word(&crctab[(crc >> 8 ^ data[i]) & 0xFF]) ^ (crc << 8);
+      crc = pgm_read_word(&crctab16[(crc >> 8 ^ data[i]) & 0xFF]) ^ (crc << 8);
     }
     return crc;
   }
+  #else
+    // slower CRC-CCITT
+    // uses the x^16,x^12,x^5,x^1 polynomial.
+    static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
+      uint16_t crc = 0;
+      for (size_t i = 0; i < n; i++) {
+        crc = (uint8_t)(crc >> 8) | (crc << 8);
+        crc ^= data[i];
+        crc ^= (uint8_t)(crc & 0xff) >> 4;
+        crc ^= crc << 12;
+        crc ^= (crc & 0xff) << 5;
+      }
+      return crc;
+    }
+  #endif
 #endif // SD_CHECK_AND_RETRY
 
 bool Sd2Card::readData(uint8_t* dst, uint16_t count) {
@@ -357,11 +449,9 @@ bool Sd2Card::readData(uint8_t* dst, uint16_t count) {
 
 #if ENABLED(SD_CHECK_AND_RETRY)
   {
-    uint16_t calcCrc = CRC_CCITT(dst, count);
-    uint16_t recvCrc = spiRec() << 8;
-    recvCrc |= spiRec();
-    if (calcCrc != recvCrc) {
-      error(SD_CARD_ERROR_CRC);
+    uint16_t recvCrc = (spiRec() << 8) | spiRec();
+    if (recvCrc != CRC_CCITT(dst, count)) {
+      error(SD_CARD_ERROR_READ_CRC);
       goto FAIL;
     }
   }
@@ -370,14 +460,10 @@ bool Sd2Card::readData(uint8_t* dst, uint16_t count) {
   spiRec();
   spiRec();
 #endif
-  chipSelectHigh();
-  // Send an additional dummy byte, required by Toshiba Flash Air SD Card
-  spiSend(0xFF);
+  chipDeselect();
   return true;
   FAIL:
-  chipSelectHigh();
-  // Send an additional dummy byte, required by Toshiba Flash Air SD Card
-  spiSend(0xFF);
+  chipDeselect();
   return false;
 }
 
@@ -386,7 +472,7 @@ bool Sd2Card::readRegister(uint8_t cmd, void* buf) {
   uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
   if (cardCommand(cmd, 0)) {
     error(SD_CARD_ERROR_READ_REG);
-    chipSelectHigh();
+    chipDeselect();
     return false;
   }
   return readData(dst, 16);
@@ -406,10 +492,10 @@ bool Sd2Card::readStart(uint32_t blockNumber) {
   if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
   if (cardCommand(CMD18, blockNumber)) {
     error(SD_CARD_ERROR_CMD18);
-    chipSelectHigh();
+    chipDeselect();
     return false;
   }
-  chipSelectHigh();
+  chipDeselect();
   return true;
 }
 
@@ -419,13 +505,13 @@ bool Sd2Card::readStart(uint32_t blockNumber) {
  * \return true for success, false for failure.
  */
 bool Sd2Card::readStop() {
-  chipSelectLow();
+  chipSelect();
   if (cardCommand(CMD12, 0)) {
     error(SD_CARD_ERROR_CMD12);
-    chipSelectHigh();
+    chipDeselect();
     return false;
   }
-  chipSelectHigh();
+  chipDeselect();
   return true;
 }
 
@@ -485,10 +571,10 @@ bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
     error(SD_CARD_ERROR_WRITE_PROGRAMMING);
     goto FAIL;
   }
-  chipSelectHigh();
+  chipDeselect();
   return true;
   FAIL:
-  chipSelectHigh();
+  chipDeselect();
   return false;
 }
 
@@ -498,28 +584,33 @@ bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
  * \return true for success, false for failure.
  */
 bool Sd2Card::writeData(const uint8_t* src) {
-  chipSelectLow();
+  chipSelect();
   // wait for previous write to finish
   if (!waitNotBusy(SD_WRITE_TIMEOUT) || !writeData(WRITE_MULTIPLE_TOKEN, src)) {
     error(SD_CARD_ERROR_WRITE_MULTIPLE);
-    chipSelectHigh();
+    chipDeselect();
     return false;
   }
-  chipSelectHigh();
+  chipDeselect();
   return true;
 }
 
 // send one block of data for write block or write multiple blocks
 bool Sd2Card::writeData(uint8_t token, const uint8_t* src) {
-  spiSendBlock(token, src);
 
-  spiSend(0xFF);  // dummy crc
-  spiSend(0xFF);  // dummy crc
+#if ENABLED(SD_CHECK_AND_RETRY)
+  uint16_t crc = CRC_CCITT( src, 512 );
+#else  // ENABLED(SD_CHECK_AND_RETRY)
+  uint16_t crc = 0xFFFF;
+#endif  // ENABLED(SD_CHECK_AND_RETRY)
+  spiSendBlock( token, src );
+  spiSend( crc >> 8 );
+  spiSend( crc & 0XFF );
 
   status_ = spiRec();
   if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
     error(SD_CARD_ERROR_WRITE);
-    chipSelectHigh();
+    chipDeselect();
     return false;
   }
   return true;
@@ -548,10 +639,10 @@ bool Sd2Card::writeStart(uint32_t blockNumber, uint32_t eraseCount) {
     error(SD_CARD_ERROR_CMD25);
     goto FAIL;
   }
-  chipSelectHigh();
+  chipDeselect();
   return true;
   FAIL:
-  chipSelectHigh();
+  chipDeselect();
   return false;
 }
 
@@ -561,15 +652,15 @@ bool Sd2Card::writeStart(uint32_t blockNumber, uint32_t eraseCount) {
  * \return true for success, false for failure.
  */
 bool Sd2Card::writeStop() {
-  chipSelectLow();
+  chipSelect();
   if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto FAIL;
   spiSend(STOP_TRAN_TOKEN);
   if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto FAIL;
-  chipSelectHigh();
+  chipDeselect();
   return true;
   FAIL:
   error(SD_CARD_ERROR_STOP_TRAN);
-  chipSelectHigh();
+  chipDeselect();
   return false;
 }
 

commit 8b12371e45356aadf175e02e80c87a3df47ea60c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 15 15:17:52 2017 -0600

    Change some hex case

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 4955e9949a..f746a22773 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -342,7 +342,7 @@ bool Sd2Card::readData(uint8_t* dst) {
 bool Sd2Card::readData(uint8_t* dst, uint16_t count) {
   // wait for start block token
   uint16_t t0 = millis();
-  while ((status_ = spiRec()) == 0XFF) {
+  while ((status_ = spiRec()) == 0xFF) {
     if (((uint16_t)millis() - t0) > SD_READ_TIMEOUT) {
       error(SD_CARD_ERROR_READ_TIMEOUT);
       goto FAIL;
@@ -372,12 +372,12 @@ bool Sd2Card::readData(uint8_t* dst, uint16_t count) {
 #endif
   chipSelectHigh();
   // Send an additional dummy byte, required by Toshiba Flash Air SD Card
-  spiSend(0XFF);
+  spiSend(0xFF);
   return true;
   FAIL:
   chipSelectHigh();
   // Send an additional dummy byte, required by Toshiba Flash Air SD Card
-  spiSend(0XFF);
+  spiSend(0xFF);
   return false;
 }
 
@@ -453,7 +453,7 @@ bool Sd2Card::setSckRate(uint8_t sckRateID) {
 // wait for card to go not busy
 bool Sd2Card::waitNotBusy(uint16_t timeoutMillis) {
   uint16_t t0 = millis();
-  while (spiRec() != 0XFF)
+  while (spiRec() != 0xFF)
     if (((uint16_t)millis() - t0) >= timeoutMillis) return false;
 
   return true;

commit 9f8b4c5ee858e80a48c35fcf6112f92dee58df79
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 15 00:06:20 2017 -0600

    Patch SD lib files for readability

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index d0e807f82f..4955e9949a 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -35,7 +35,6 @@
 
 #include "../Marlin.h"
 
-//------------------------------------------------------------------------------
 // send command and return error code.  Return zero for OK
 uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
   // select card
@@ -63,7 +62,7 @@ uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
   for (uint8_t i = 0; ((status_ = spiRec()) & 0x80) && i != 0xFF; i++) { /* Intentionally left empty */ }
   return status_;
 }
-//------------------------------------------------------------------------------
+
 /**
  * Determine the size of an SD flash memory card.
  *
@@ -91,19 +90,20 @@ uint32_t Sd2Card::cardSize() {
     return 0;
   }
 }
-//------------------------------------------------------------------------------
+
 void Sd2Card::chipSelectHigh() {
   digitalWrite(chipSelectPin_, HIGH);
 }
-//------------------------------------------------------------------------------
+
 void Sd2Card::chipSelectLow() {
   #if DISABLED(SOFTWARE_SPI)
     spiInit(spiRate_);
   #endif  // SOFTWARE_SPI
   digitalWrite(chipSelectPin_, LOW);
 }
-//------------------------------------------------------------------------------
-/** Erase a range of blocks.
+
+/**
+ * Erase a range of blocks.
  *
  * \param[in] firstBlock The address of the first block in the range.
  * \param[in] lastBlock The address of the last block in the range.
@@ -113,8 +113,7 @@ void Sd2Card::chipSelectLow() {
  * either 0 or 1, depends on the card vendor.  The card must support
  * single block erase.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
 bool Sd2Card::erase(uint32_t firstBlock, uint32_t lastBlock) {
   csd_t csd;
@@ -149,26 +148,26 @@ bool Sd2Card::erase(uint32_t firstBlock, uint32_t lastBlock) {
   chipSelectHigh();
   return false;
 }
-//------------------------------------------------------------------------------
-/** Determine if card supports single block erase.
+
+/**
+ * Determine if card supports single block erase.
  *
- * \return The value one, true, is returned if single block erase is supported.
- * The value zero, false, is returned if single block erase is not supported.
+ * \return true if single block erase is supported.
+ *         false if single block erase is not supported.
  */
 bool Sd2Card::eraseSingleBlockEnable() {
   csd_t csd;
   return readCSD(&csd) ? csd.v1.erase_blk_en : false;
 }
-//------------------------------------------------------------------------------
+
 /**
  * Initialize an SD flash memory card.
  *
  * \param[in] sckRateID SPI clock rate selector. See setSckRate().
  * \param[in] chipSelectPin SD chip select pin number.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.  The reason for failure
- * can be determined by calling errorCode() and errorData().
+ * \return true for success, false for failure.
+ * The reason for failure can be determined by calling errorCode() and errorData().
  */
 bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
   errorCode_ = type_ = 0;
@@ -247,14 +246,13 @@ bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
   chipSelectHigh();
   return false;
 }
-//------------------------------------------------------------------------------
+
 /**
  * Read a 512 byte block from an SD card.
  *
  * \param[in] blockNumber Logical block to be read.
  * \param[out] dst Pointer to the location that will receive the data.
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
 bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
   // use address if not SDHC card
@@ -262,19 +260,18 @@ bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
 
   #if ENABLED(SD_CHECK_AND_RETRY)
     uint8_t retryCnt = 3;
-    do {
-      if (!cardCommand(CMD17, blockNumber)) {
-        if (readData(dst, 512)) return true;
-      }
-      else
+    for(;;) {
+      if (cardCommand(CMD17, blockNumber))
         error(SD_CARD_ERROR_CMD17);
+      else if (readData(dst, 512))
+        return true;
 
       if (!--retryCnt) break;
 
       chipSelectHigh();
       cardCommand(CMD12, 0); // Try sending a stop command, ignore the result.
       errorCode_ = 0;
-    } while (true);
+    }
   #else
     if (cardCommand(CMD17, blockNumber))
       error(SD_CARD_ERROR_CMD17);
@@ -285,13 +282,13 @@ bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
   chipSelectHigh();
   return false;
 }
-//------------------------------------------------------------------------------
-/** Read one data block in a multiple block read sequence
+
+/**
+ * Read one data block in a multiple block read sequence
  *
  * \param[in] dst Pointer to the location for the data to be read.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
 bool Sd2Card::readData(uint8_t* dst) {
   chipSelectLow();
@@ -299,50 +296,49 @@ bool Sd2Card::readData(uint8_t* dst) {
 }
 
 #if ENABLED(SD_CHECK_AND_RETRY)
-static const uint16_t crctab[] PROGMEM = {
-  0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
-  0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
-  0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
-  0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
-  0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
-  0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
-  0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
-  0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
-  0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
-  0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
-  0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
-  0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
-  0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
-  0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
-  0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
-  0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
-  0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
-  0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
-  0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
-  0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
-  0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
-  0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
-  0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
-  0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
-  0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
-  0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
-  0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
-  0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
-  0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
-  0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
-  0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
-  0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
-};
-static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
-  uint16_t crc = 0;
-  for (size_t i = 0; i < n; i++) {
-    crc = pgm_read_word(&crctab[(crc >> 8 ^ data[i]) & 0xFF]) ^ (crc << 8);
+  static const uint16_t crctab[] PROGMEM = {
+    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
+    0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
+    0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
+    0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
+    0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
+    0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
+    0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
+    0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
+    0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
+    0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
+    0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
+    0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
+    0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
+    0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
+    0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
+    0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
+    0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
+    0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
+    0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
+    0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
+    0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
+    0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
+    0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
+    0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
+    0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
+    0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
+    0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
+    0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
+    0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
+    0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
+    0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
+    0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
+  };
+  static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
+    uint16_t crc = 0;
+    for (size_t i = 0; i < n; i++) {
+      crc = pgm_read_word(&crctab[(crc >> 8 ^ data[i]) & 0xFF]) ^ (crc << 8);
+    }
+    return crc;
   }
-  return crc;
-}
-#endif
+#endif // SD_CHECK_AND_RETRY
 
-//------------------------------------------------------------------------------
 bool Sd2Card::readData(uint8_t* dst, uint16_t count) {
   // wait for start block token
   uint16_t t0 = millis();
@@ -384,61 +380,55 @@ bool Sd2Card::readData(uint8_t* dst, uint16_t count) {
   spiSend(0XFF);
   return false;
 }
-//------------------------------------------------------------------------------
+
 /** read CID or CSR register */
 bool Sd2Card::readRegister(uint8_t cmd, void* buf) {
   uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
   if (cardCommand(cmd, 0)) {
     error(SD_CARD_ERROR_READ_REG);
-    goto FAIL;
+    chipSelectHigh();
+    return false;
   }
   return readData(dst, 16);
-  FAIL:
-  chipSelectHigh();
-  return false;
 }
-//------------------------------------------------------------------------------
-/** Start a read multiple blocks sequence.
+
+/**
+ * Start a read multiple blocks sequence.
  *
  * \param[in] blockNumber Address of first block in sequence.
  *
  * \note This function is used with readData() and readStop() for optimized
  * multiple block reads.  SPI chipSelect must be low for the entire sequence.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
 bool Sd2Card::readStart(uint32_t blockNumber) {
   if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
   if (cardCommand(CMD18, blockNumber)) {
     error(SD_CARD_ERROR_CMD18);
-    goto FAIL;
+    chipSelectHigh();
+    return false;
   }
   chipSelectHigh();
   return true;
-  FAIL:
-  chipSelectHigh();
-  return false;
 }
-//------------------------------------------------------------------------------
-/** End a read multiple blocks sequence.
+
+/**
+ * End a read multiple blocks sequence.
  *
-* \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
 bool Sd2Card::readStop() {
   chipSelectLow();
   if (cardCommand(CMD12, 0)) {
     error(SD_CARD_ERROR_CMD12);
-    goto FAIL;
+    chipSelectHigh();
+    return false;
   }
   chipSelectHigh();
   return true;
-  FAIL:
-  chipSelectHigh();
-  return false;
 }
-//------------------------------------------------------------------------------
+
 /**
  * Set the SPI clock rate.
  *
@@ -459,25 +449,22 @@ bool Sd2Card::setSckRate(uint8_t sckRateID) {
   spiRate_ = sckRateID;
   return true;
 }
-//------------------------------------------------------------------------------
+
 // wait for card to go not busy
 bool Sd2Card::waitNotBusy(uint16_t timeoutMillis) {
   uint16_t t0 = millis();
-  while (spiRec() != 0XFF) {
-    if (((uint16_t)millis() - t0) >= timeoutMillis) goto FAIL;
-  }
+  while (spiRec() != 0XFF)
+    if (((uint16_t)millis() - t0) >= timeoutMillis) return false;
+
   return true;
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
+
 /**
  * Writes a 512 byte block to an SD card.
  *
  * \param[in] blockNumber Logical block to be written.
  * \param[in] src Pointer to the location of the data to be written.
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
 bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
   // use address if not SDHC card
@@ -504,25 +491,24 @@ bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
   chipSelectHigh();
   return false;
 }
-//------------------------------------------------------------------------------
-/** Write one data block in a multiple block write sequence
+
+/**
+ * Write one data block in a multiple block write sequence
  * \param[in] src Pointer to the location of the data to be written.
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
 bool Sd2Card::writeData(const uint8_t* src) {
   chipSelectLow();
   // wait for previous write to finish
-  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto FAIL;
-  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) goto FAIL;
+  if (!waitNotBusy(SD_WRITE_TIMEOUT) || !writeData(WRITE_MULTIPLE_TOKEN, src)) {
+    error(SD_CARD_ERROR_WRITE_MULTIPLE);
+    chipSelectHigh();
+    return false;
+  }
   chipSelectHigh();
   return true;
-  FAIL:
-  error(SD_CARD_ERROR_WRITE_MULTIPLE);
-  chipSelectHigh();
-  return false;
 }
-//------------------------------------------------------------------------------
+
 // send one block of data for write block or write multiple blocks
 bool Sd2Card::writeData(uint8_t token, const uint8_t* src) {
   spiSendBlock(token, src);
@@ -533,15 +519,14 @@ bool Sd2Card::writeData(uint8_t token, const uint8_t* src) {
   status_ = spiRec();
   if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
     error(SD_CARD_ERROR_WRITE);
-    goto FAIL;
+    chipSelectHigh();
+    return false;
   }
   return true;
-  FAIL:
-  chipSelectHigh();
-  return false;
 }
-//------------------------------------------------------------------------------
-/** Start a write multiple blocks sequence.
+
+/**
+ * Start a write multiple blocks sequence.
  *
  * \param[in] blockNumber Address of first block in sequence.
  * \param[in] eraseCount The number of blocks to be pre-erased.
@@ -549,8 +534,7 @@ bool Sd2Card::writeData(uint8_t token, const uint8_t* src) {
  * \note This function is used with writeData() and writeStop()
  * for optimized multiple block writes.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
 bool Sd2Card::writeStart(uint32_t blockNumber, uint32_t eraseCount) {
   // send pre-erase count
@@ -570,11 +554,11 @@ bool Sd2Card::writeStart(uint32_t blockNumber, uint32_t eraseCount) {
   chipSelectHigh();
   return false;
 }
-//------------------------------------------------------------------------------
-/** End a write multiple blocks sequence.
+
+/**
+ * End a write multiple blocks sequence.
  *
-* \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
 bool Sd2Card::writeStop() {
   chipSelectLow();
@@ -589,4 +573,4 @@ bool Sd2Card::writeStop() {
   return false;
 }
 
-#endif
+#endif // SDSUPPORT

commit 9e699811d25918fe64793824b2a2fdbccdf3b7bd
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Thu Oct 26 13:37:26 2017 -0500

    Make LPC1768 pinmapping not specific to Re-ARM (#8063)
    
    * Merging early because of build failures.  See #8105
    
    * Make LPC1768 pinmapping not specific to Re-ARM
    
    * Add HAL_PIN_TYPE and LPC1768 pin features
    
    * M43 Updates
    
    * Move pin map into pinsDebug_LPC1768.h
    
    * Incorporate comments and M226
    
    * Fix persistent store compilation issues
    
    * Update pin features
    
    * Update MKS SBASE pins
    
    * Use native LPC1768 pin numbers in M42, M43, and M226

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 4107eaf2bc..d0e807f82f 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -170,7 +170,7 @@ bool Sd2Card::eraseSingleBlockEnable() {
  * the value zero, false, is returned for failure.  The reason for failure
  * can be determined by calling errorCode() and errorData().
  */
-bool Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {
+bool Sd2Card::init(uint8_t sckRateID, pin_t chipSelectPin) {
   errorCode_ = type_ = 0;
   chipSelectPin_ = chipSelectPin;
   // 16-bit init start time allows over a minute

commit 614a86a380cb23a5e22661f71de5bc2e3168bb11
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:32 2017 -0500

    SD file updates

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
index 512871f218..4107eaf2bc 100644
--- a/Marlin/src/sd/Sd2Card.cpp
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -26,11 +26,15 @@
  *
  * This file is part of the Arduino Sd2Card Library
  */
-#include "Marlin.h"
+
+#include "../inc/MarlinConfig.h"
 
 #if ENABLED(SDSUPPORT)
+
 #include "Sd2Card.h"
 
+#include "../Marlin.h"
+
 //------------------------------------------------------------------------------
 // send command and return error code.  Return zero for OK
 uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {

commit b66d65f8657efe2ddecfe4a4c255b2d260671ce1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:31 2017 -0500

    Move 'sd' files

diff --git a/Marlin/src/sd/Sd2Card.cpp b/Marlin/src/sd/Sd2Card.cpp
new file mode 100644
index 0000000000..512871f218
--- /dev/null
+++ b/Marlin/src/sd/Sd2Card.cpp
@@ -0,0 +1,588 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * Arduino Sd2Card Library
+ * Copyright (C) 2009 by William Greiman
+ *
+ * This file is part of the Arduino Sd2Card Library
+ */
+#include "Marlin.h"
+
+#if ENABLED(SDSUPPORT)
+#include "Sd2Card.h"
+
+//------------------------------------------------------------------------------
+// send command and return error code.  Return zero for OK
+uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
+  // select card
+  chipSelectLow();
+
+  // wait up to 300 ms if busy
+  waitNotBusy(300);
+
+  // send command
+  spiSend(cmd | 0x40);
+
+  // send argument
+  for (int8_t s = 24; s >= 0; s -= 8) spiSend(arg >> s);
+
+  // send CRC
+  uint8_t crc = 0xFF;
+  if (cmd == CMD0) crc = 0x95;  // correct crc for CMD0 with arg 0
+  if (cmd == CMD8) crc = 0x87;  // correct crc for CMD8 with arg 0x1AA
+  spiSend(crc);
+
+  // skip stuff byte for stop read
+  if (cmd == CMD12) spiRec();
+
+  // wait for response
+  for (uint8_t i = 0; ((status_ = spiRec()) & 0x80) && i != 0xFF; i++) { /* Intentionally left empty */ }
+  return status_;
+}
+//------------------------------------------------------------------------------
+/**
+ * Determine the size of an SD flash memory card.
+ *
+ * \return The number of 512 byte data blocks in the card
+ *         or zero if an error occurs.
+ */
+uint32_t Sd2Card::cardSize() {
+  csd_t csd;
+  if (!readCSD(&csd)) return 0;
+  if (csd.v1.csd_ver == 0) {
+    uint8_t read_bl_len = csd.v1.read_bl_len;
+    uint16_t c_size = (csd.v1.c_size_high << 10)
+                      | (csd.v1.c_size_mid << 2) | csd.v1.c_size_low;
+    uint8_t c_size_mult = (csd.v1.c_size_mult_high << 1)
+                          | csd.v1.c_size_mult_low;
+    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
+  }
+  else if (csd.v2.csd_ver == 1) {
+    uint32_t c_size = ((uint32_t)csd.v2.c_size_high << 16)
+                      | (csd.v2.c_size_mid << 8) | csd.v2.c_size_low;
+    return (c_size + 1) << 10;
+  }
+  else {
+    error(SD_CARD_ERROR_BAD_CSD);
+    return 0;
+  }
+}
+//------------------------------------------------------------------------------
+void Sd2Card::chipSelectHigh() {
+  digitalWrite(chipSelectPin_, HIGH);
+}
+//------------------------------------------------------------------------------
+void Sd2Card::chipSelectLow() {
+  #if DISABLED(SOFTWARE_SPI)
+    spiInit(spiRate_);
+  #endif  // SOFTWARE_SPI
+  digitalWrite(chipSelectPin_, LOW);
+}
+//------------------------------------------------------------------------------
+/** Erase a range of blocks.
+ *
+ * \param[in] firstBlock The address of the first block in the range.
+ * \param[in] lastBlock The address of the last block in the range.
+ *
+ * \note This function requests the SD card to do a flash erase for a
+ * range of blocks.  The data on the card after an erase operation is
+ * either 0 or 1, depends on the card vendor.  The card must support
+ * single block erase.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::erase(uint32_t firstBlock, uint32_t lastBlock) {
+  csd_t csd;
+  if (!readCSD(&csd)) goto FAIL;
+  // check for single block erase
+  if (!csd.v1.erase_blk_en) {
+    // erase size mask
+    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
+    if ((firstBlock & m) != 0 || ((lastBlock + 1) & m) != 0) {
+      // error card can't erase specified area
+      error(SD_CARD_ERROR_ERASE_SINGLE_BLOCK);
+      goto FAIL;
+    }
+  }
+  if (type_ != SD_CARD_TYPE_SDHC) {
+    firstBlock <<= 9;
+    lastBlock <<= 9;
+  }
+  if (cardCommand(CMD32, firstBlock)
+      || cardCommand(CMD33, lastBlock)
+      || cardCommand(CMD38, 0)) {
+    error(SD_CARD_ERROR_ERASE);
+    goto FAIL;
+  }
+  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
+    error(SD_CARD_ERROR_ERASE_TIMEOUT);
+    goto FAIL;
+  }
+  chipSelectHigh();
+  return true;
+  FAIL:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Determine if card supports single block erase.
+ *
+ * \return The value one, true, is returned if single block erase is supported.
+ * The value zero, false, is returned if single block erase is not supported.
+ */
+bool Sd2Card::eraseSingleBlockEnable() {
+  csd_t csd;
+  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
+}
+//------------------------------------------------------------------------------
+/**
+ * Initialize an SD flash memory card.
+ *
+ * \param[in] sckRateID SPI clock rate selector. See setSckRate().
+ * \param[in] chipSelectPin SD chip select pin number.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.  The reason for failure
+ * can be determined by calling errorCode() and errorData().
+ */
+bool Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {
+  errorCode_ = type_ = 0;
+  chipSelectPin_ = chipSelectPin;
+  // 16-bit init start time allows over a minute
+  uint16_t t0 = (uint16_t)millis();
+  uint32_t arg;
+
+  // If init takes more than 4s it could trigger
+  // watchdog leading to a reboot loop.
+  #if ENABLED(USE_WATCHDOG)
+    watchdog_reset();
+  #endif
+
+  // set pin modes
+//todo: should use chipSelectPin ?
+  spiBegin();
+
+  // set SCK rate for initialization commands
+  spiRate_ = SPI_SD_INIT_RATE;
+  spiInit(spiRate_);
+
+  // must supply min of 74 clock cycles with CS high.
+  for (uint8_t i = 0; i < 10; i++) spiSend(0xFF);
+
+  // command to go idle in SPI mode
+  while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {
+    if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
+      error(SD_CARD_ERROR_CMD0);
+      goto FAIL;
+    }
+  }
+  // check SD version
+  if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
+    type(SD_CARD_TYPE_SD1);
+  }
+  else {
+    // only need last byte of r7 response
+    for (uint8_t i = 0; i < 4; i++) status_ = spiRec();
+    if (status_ != 0xAA) {
+      error(SD_CARD_ERROR_CMD8);
+      goto FAIL;
+    }
+    type(SD_CARD_TYPE_SD2);
+  }
+  // initialize card and send host supports SDHC if SD2
+  arg = type() == SD_CARD_TYPE_SD2 ? 0x40000000 : 0;
+
+  while ((status_ = cardAcmd(ACMD41, arg)) != R1_READY_STATE) {
+    // check for timeout
+    if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
+      error(SD_CARD_ERROR_ACMD41);
+      goto FAIL;
+    }
+  }
+  // if SD2 read OCR register to check for SDHC card
+  if (type() == SD_CARD_TYPE_SD2) {
+    if (cardCommand(CMD58, 0)) {
+      error(SD_CARD_ERROR_CMD58);
+      goto FAIL;
+    }
+    if ((spiRec() & 0xC0) == 0xC0) type(SD_CARD_TYPE_SDHC);
+    // discard rest of ocr - contains allowed voltage range
+    for (uint8_t i = 0; i < 3; i++) spiRec();
+  }
+  chipSelectHigh();
+
+  #if DISABLED(SOFTWARE_SPI)
+    return setSckRate(sckRateID);
+  #else  // SOFTWARE_SPI
+    UNUSED(sckRateID);
+    return true;
+  #endif  // SOFTWARE_SPI
+
+  FAIL:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/**
+ * Read a 512 byte block from an SD card.
+ *
+ * \param[in] blockNumber Logical block to be read.
+ * \param[out] dst Pointer to the location that will receive the data.
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
+  // use address if not SDHC card
+  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
+
+  #if ENABLED(SD_CHECK_AND_RETRY)
+    uint8_t retryCnt = 3;
+    do {
+      if (!cardCommand(CMD17, blockNumber)) {
+        if (readData(dst, 512)) return true;
+      }
+      else
+        error(SD_CARD_ERROR_CMD17);
+
+      if (!--retryCnt) break;
+
+      chipSelectHigh();
+      cardCommand(CMD12, 0); // Try sending a stop command, ignore the result.
+      errorCode_ = 0;
+    } while (true);
+  #else
+    if (cardCommand(CMD17, blockNumber))
+      error(SD_CARD_ERROR_CMD17);
+    else
+      return readData(dst, 512);
+  #endif
+
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Read one data block in a multiple block read sequence
+ *
+ * \param[in] dst Pointer to the location for the data to be read.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::readData(uint8_t* dst) {
+  chipSelectLow();
+  return readData(dst, 512);
+}
+
+#if ENABLED(SD_CHECK_AND_RETRY)
+static const uint16_t crctab[] PROGMEM = {
+  0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
+  0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
+  0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
+  0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
+  0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
+  0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
+  0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
+  0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
+  0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
+  0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
+  0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
+  0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
+  0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
+  0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
+  0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
+  0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
+  0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
+  0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
+  0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
+  0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
+  0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
+  0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
+  0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
+  0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
+  0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
+  0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
+  0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
+  0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
+  0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
+  0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
+  0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
+  0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
+};
+static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
+  uint16_t crc = 0;
+  for (size_t i = 0; i < n; i++) {
+    crc = pgm_read_word(&crctab[(crc >> 8 ^ data[i]) & 0xFF]) ^ (crc << 8);
+  }
+  return crc;
+}
+#endif
+
+//------------------------------------------------------------------------------
+bool Sd2Card::readData(uint8_t* dst, uint16_t count) {
+  // wait for start block token
+  uint16_t t0 = millis();
+  while ((status_ = spiRec()) == 0XFF) {
+    if (((uint16_t)millis() - t0) > SD_READ_TIMEOUT) {
+      error(SD_CARD_ERROR_READ_TIMEOUT);
+      goto FAIL;
+    }
+  }
+  if (status_ != DATA_START_BLOCK) {
+    error(SD_CARD_ERROR_READ);
+    goto FAIL;
+  }
+  // transfer data
+  spiRead(dst, count);
+
+#if ENABLED(SD_CHECK_AND_RETRY)
+  {
+    uint16_t calcCrc = CRC_CCITT(dst, count);
+    uint16_t recvCrc = spiRec() << 8;
+    recvCrc |= spiRec();
+    if (calcCrc != recvCrc) {
+      error(SD_CARD_ERROR_CRC);
+      goto FAIL;
+    }
+  }
+#else
+  // discard CRC
+  spiRec();
+  spiRec();
+#endif
+  chipSelectHigh();
+  // Send an additional dummy byte, required by Toshiba Flash Air SD Card
+  spiSend(0XFF);
+  return true;
+  FAIL:
+  chipSelectHigh();
+  // Send an additional dummy byte, required by Toshiba Flash Air SD Card
+  spiSend(0XFF);
+  return false;
+}
+//------------------------------------------------------------------------------
+/** read CID or CSR register */
+bool Sd2Card::readRegister(uint8_t cmd, void* buf) {
+  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
+  if (cardCommand(cmd, 0)) {
+    error(SD_CARD_ERROR_READ_REG);
+    goto FAIL;
+  }
+  return readData(dst, 16);
+  FAIL:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Start a read multiple blocks sequence.
+ *
+ * \param[in] blockNumber Address of first block in sequence.
+ *
+ * \note This function is used with readData() and readStop() for optimized
+ * multiple block reads.  SPI chipSelect must be low for the entire sequence.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::readStart(uint32_t blockNumber) {
+  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
+  if (cardCommand(CMD18, blockNumber)) {
+    error(SD_CARD_ERROR_CMD18);
+    goto FAIL;
+  }
+  chipSelectHigh();
+  return true;
+  FAIL:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/** End a read multiple blocks sequence.
+ *
+* \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::readStop() {
+  chipSelectLow();
+  if (cardCommand(CMD12, 0)) {
+    error(SD_CARD_ERROR_CMD12);
+    goto FAIL;
+  }
+  chipSelectHigh();
+  return true;
+  FAIL:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/**
+ * Set the SPI clock rate.
+ *
+ * \param[in] sckRateID A value in the range [0, 6].
+ *
+ * The SPI clock will be set to F_CPU/pow(2, 1 + sckRateID). The maximum
+ * SPI rate is F_CPU/2 for \a sckRateID = 0 and the minimum rate is F_CPU/128
+ * for \a scsRateID = 6.
+ *
+ * \return The value one, true, is returned for success and the value zero,
+ * false, is returned for an invalid value of \a sckRateID.
+ */
+bool Sd2Card::setSckRate(uint8_t sckRateID) {
+  if (sckRateID > 6) {
+    error(SD_CARD_ERROR_SCK_RATE);
+    return false;
+  }
+  spiRate_ = sckRateID;
+  return true;
+}
+//------------------------------------------------------------------------------
+// wait for card to go not busy
+bool Sd2Card::waitNotBusy(uint16_t timeoutMillis) {
+  uint16_t t0 = millis();
+  while (spiRec() != 0XFF) {
+    if (((uint16_t)millis() - t0) >= timeoutMillis) goto FAIL;
+  }
+  return true;
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/**
+ * Writes a 512 byte block to an SD card.
+ *
+ * \param[in] blockNumber Logical block to be written.
+ * \param[in] src Pointer to the location of the data to be written.
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
+  // use address if not SDHC card
+  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
+  if (cardCommand(CMD24, blockNumber)) {
+    error(SD_CARD_ERROR_CMD24);
+    goto FAIL;
+  }
+  if (!writeData(DATA_START_BLOCK, src)) goto FAIL;
+
+  // wait for flash programming to complete
+  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
+    error(SD_CARD_ERROR_WRITE_TIMEOUT);
+    goto FAIL;
+  }
+  // response is r2 so get and check two bytes for nonzero
+  if (cardCommand(CMD13, 0) || spiRec()) {
+    error(SD_CARD_ERROR_WRITE_PROGRAMMING);
+    goto FAIL;
+  }
+  chipSelectHigh();
+  return true;
+  FAIL:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Write one data block in a multiple block write sequence
+ * \param[in] src Pointer to the location of the data to be written.
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::writeData(const uint8_t* src) {
+  chipSelectLow();
+  // wait for previous write to finish
+  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto FAIL;
+  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) goto FAIL;
+  chipSelectHigh();
+  return true;
+  FAIL:
+  error(SD_CARD_ERROR_WRITE_MULTIPLE);
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+// send one block of data for write block or write multiple blocks
+bool Sd2Card::writeData(uint8_t token, const uint8_t* src) {
+  spiSendBlock(token, src);
+
+  spiSend(0xFF);  // dummy crc
+  spiSend(0xFF);  // dummy crc
+
+  status_ = spiRec();
+  if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
+    error(SD_CARD_ERROR_WRITE);
+    goto FAIL;
+  }
+  return true;
+  FAIL:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Start a write multiple blocks sequence.
+ *
+ * \param[in] blockNumber Address of first block in sequence.
+ * \param[in] eraseCount The number of blocks to be pre-erased.
+ *
+ * \note This function is used with writeData() and writeStop()
+ * for optimized multiple block writes.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::writeStart(uint32_t blockNumber, uint32_t eraseCount) {
+  // send pre-erase count
+  if (cardAcmd(ACMD23, eraseCount)) {
+    error(SD_CARD_ERROR_ACMD23);
+    goto FAIL;
+  }
+  // use address if not SDHC card
+  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
+  if (cardCommand(CMD25, blockNumber)) {
+    error(SD_CARD_ERROR_CMD25);
+    goto FAIL;
+  }
+  chipSelectHigh();
+  return true;
+  FAIL:
+  chipSelectHigh();
+  return false;
+}
+//------------------------------------------------------------------------------
+/** End a write multiple blocks sequence.
+ *
+* \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool Sd2Card::writeStop() {
+  chipSelectLow();
+  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto FAIL;
+  spiSend(STOP_TRAN_TOKEN);
+  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto FAIL;
+  chipSelectHigh();
+  return true;
+  FAIL:
+  error(SD_CARD_ERROR_STOP_TRAN);
+  chipSelectHigh();
+  return false;
+}
+
+#endif
