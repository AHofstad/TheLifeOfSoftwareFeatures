commit 8d9021e8069c0550e9a31107adf44b9112b87471
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 6 04:17:59 2021 -0500

    Move ExtUI subfolders up a level (#21820)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
deleted file mode 100644
index 0a99df08e5..0000000000
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ /dev/null
@@ -1,1382 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#include "../../../../inc/MarlinConfigPre.h"
-
-#if HAS_TFT_LVGL_UI
-
-#include "SPI_TFT.h"
-
-#include "tft_lvgl_configuration.h"
-
-#include "pic_manager.h"
-
-#include "draw_ui.h"
-#include "mks_hardware_test.h"
-
-#include <SPI.h>
-
-#include "../../../../MarlinCore.h" // for marlin_state
-#include "../../../../sd/cardreader.h"
-#include "../../../../module/motion.h"
-#include "../../../../module/planner.h"
-#include "../../../../inc/MarlinConfig.h"
-
-#if ENABLED(POWER_LOSS_RECOVERY)
-  #include "../../../../feature/powerloss.h"
-#endif
-
-#if ENABLED(PARK_HEAD_ON_PAUSE)
-  #include "../../../../feature/pause.h"
-#endif
-
-#if ENABLED(TOUCH_SCREEN_CALIBRATION)
-  #include "draw_touch_calibration.h"
-#endif
-
-CFG_ITMES gCfgItems;
-UI_CFG uiCfg;
-DISP_STATE_STACK disp_state_stack;
-DISP_STATE disp_state = MAIN_UI;
-DISP_STATE last_disp_state;
-PRINT_TIME print_time;
-num_key_value_state value;
-keyboard_value_state keyboard_value;
-
-uint32_t To_pre_view;
-bool gcode_preview_over, flash_preview_begin, default_preview_flg;
-uint32_t size = 809;
-uint16_t row;
-bool temps_update_flag;
-uint8_t printing_rate_update_flag;
-
-extern bool once_flag;
-extern uint8_t sel_id;
-extern lv_group_t *g;
-
-void LCD_IO_WriteData(uint16_t RegValue);
-
-static const char custom_gcode_command[][100] = {
-  "G29N\nM500",
-  "G28",
-  "G28",
-  "G28",
-  "G28"
-};
-
-lv_point_t line_points[4][2] = {
-  {{PARA_UI_POS_X, PARA_UI_POS_Y + PARA_UI_SIZE_Y}, {TFT_WIDTH, PARA_UI_POS_Y + PARA_UI_SIZE_Y}},
-  {{PARA_UI_POS_X, PARA_UI_POS_Y*2 + PARA_UI_SIZE_Y}, {TFT_WIDTH, PARA_UI_POS_Y*2 + PARA_UI_SIZE_Y}},
-  {{PARA_UI_POS_X, PARA_UI_POS_Y*3 + PARA_UI_SIZE_Y}, {TFT_WIDTH, PARA_UI_POS_Y*3 + PARA_UI_SIZE_Y}},
-  {{PARA_UI_POS_X, PARA_UI_POS_Y*4 + PARA_UI_SIZE_Y}, {TFT_WIDTH, PARA_UI_POS_Y*4 + PARA_UI_SIZE_Y}}
-};
-void gCfgItems_init() {
-  gCfgItems.multiple_language = MULTI_LANGUAGE_ENABLE;
-  #if 1 // LCD_LANGUAGE == en
-    gCfgItems.language = LANG_ENGLISH;
-  #elif LCD_LANGUAGE == zh_CN
-    gCfgItems.language = LANG_SIMPLE_CHINESE;
-  #elif LCD_LANGUAGE == zh_TW
-    gCfgItems.language = LANG_COMPLEX_CHINESE;
-  #elif LCD_LANGUAGE == jp_kana
-    gCfgItems.language = LANG_JAPAN;
-  #elif LCD_LANGUAGE == de
-    gCfgItems.language = LANG_GERMAN;
-  #elif LCD_LANGUAGE == fr
-    gCfgItems.language = LANG_FRENCH;
-  #elif LCD_LANGUAGE == ru
-    gCfgItems.language = LANG_RUSSIAN;
-  #elif LCD_LANGUAGE == ko_KR
-    gCfgItems.language = LANG_KOREAN;
-  #elif LCD_LANGUAGE == tr
-    gCfgItems.language = LANG_TURKISH;
-  #elif LCD_LANGUAGE == es
-    gCfgItems.language = LANG_SPANISH;
-  #elif LCD_LANGUAGE == el
-    gCfgItems.language = LANG_GREEK;
-  #elif LCD_LANGUAGE == it
-    gCfgItems.language = LANG_ITALY;
-  #elif LCD_LANGUAGE == pt
-    gCfgItems.language = LANG_PORTUGUESE;
-  #endif
-  gCfgItems.leveling_mode     = 0;
-  gCfgItems.from_flash_pic    = false;
-  gCfgItems.curFilesize       = 0;
-  gCfgItems.finish_power_off  = false;
-  gCfgItems.pause_reprint     = false;
-  gCfgItems.pausePosX         = -1;
-  gCfgItems.pausePosY         = -1;
-  gCfgItems.pausePosZ         = 5;
-  gCfgItems.trammingPos[0].x  = X_MIN_POS + 30;
-  gCfgItems.trammingPos[0].y  = Y_MIN_POS + 30;
-  gCfgItems.trammingPos[1].x  = X_MAX_POS - 30;
-  gCfgItems.trammingPos[1].y  = Y_MIN_POS + 30;
-  gCfgItems.trammingPos[2].x  = X_MAX_POS - 30;
-  gCfgItems.trammingPos[2].y  = Y_MAX_POS - 30;
-  gCfgItems.trammingPos[3].x  = X_MIN_POS + 30;
-  gCfgItems.trammingPos[3].y  = Y_MAX_POS - 30;
-  gCfgItems.trammingPos[4].x  = X_BED_SIZE / 2;
-  gCfgItems.trammingPos[4].y  = Y_BED_SIZE / 2;
-  gCfgItems.cloud_enable      = false;
-  gCfgItems.wifi_mode_sel = STA_MODEL;
-  gCfgItems.fileSysType   = FILE_SYS_SD;
-  gCfgItems.wifi_type     = ESP_WIFI;
-  gCfgItems.filamentchange_load_length   = 200;
-  gCfgItems.filamentchange_load_speed    = 1000;
-  gCfgItems.filamentchange_unload_length = 200;
-  gCfgItems.filamentchange_unload_speed  = 1000;
-  gCfgItems.filament_limit_temp          = 200;
-
-  gCfgItems.encoder_enable = true;
-
-  W25QXX.SPI_FLASH_BufferRead((uint8_t *)&gCfgItems.spi_flash_flag, VAR_INF_ADDR, sizeof(gCfgItems.spi_flash_flag));
-  if (gCfgItems.spi_flash_flag == FLASH_INF_VALID_FLAG) {
-    W25QXX.SPI_FLASH_BufferRead((uint8_t *)&gCfgItems, VAR_INF_ADDR, sizeof(gCfgItems));
-  }
-  else {
-    gCfgItems.spi_flash_flag = FLASH_INF_VALID_FLAG;
-    W25QXX.SPI_FLASH_SectorErase(VAR_INF_ADDR);
-    W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&gCfgItems, VAR_INF_ADDR, sizeof(gCfgItems));
-    //init gcode command
-    W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&custom_gcode_command[0], AUTO_LEVELING_COMMAND_ADDR, 100);
-    W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&custom_gcode_command[1], OTHERS_COMMAND_ADDR_1, 100);
-    W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&custom_gcode_command[2], OTHERS_COMMAND_ADDR_2, 100);
-    W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&custom_gcode_command[3], OTHERS_COMMAND_ADDR_3, 100);
-    W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&custom_gcode_command[4], OTHERS_COMMAND_ADDR_4, 100);
-  }
-
-  const byte rot = (TFT_ROTATION & TFT_ROTATE_180) ? 0xEE : 0x00;
-  if (gCfgItems.disp_rotation_180 != rot) {
-    gCfgItems.disp_rotation_180 = rot;
-    update_spi_flash();
-  }
-
-  uiCfg.F[0] = 'N';
-  uiCfg.F[1] = 'A';
-  uiCfg.F[2] = 'N';
-  uiCfg.F[3] = 'O';
-  W25QXX.SPI_FLASH_BlockErase(REFLSHE_FLGA_ADD + 32 - 64*1024);
-  W25QXX.SPI_FLASH_BufferWrite(uiCfg.F,REFLSHE_FLGA_ADD,4);
-}
-
-void ui_cfg_init() {
-  uiCfg.curTempType         = 0;
-  uiCfg.extruderIndex       = 0;
-  uiCfg.stepHeat            = 10;
-  uiCfg.leveling_first_time = false;
-  uiCfg.para_ui_page        = false;
-  uiCfg.extruStep           = 5;
-  uiCfg.extruSpeed          = 10;
-  uiCfg.move_dist           = 1;
-  uiCfg.moveSpeed           = 3000;
-  uiCfg.stepPrintSpeed      = 10;
-  uiCfg.command_send        = false;
-  uiCfg.dialogType          = 0;
-  uiCfg.filament_heat_completed_load = false;
-  uiCfg.filament_rate                = 0;
-  uiCfg.filament_loading_completed   = false;
-  uiCfg.filament_unloading_completed = false;
-  uiCfg.filament_loading_time_flg    = false;
-  uiCfg.filament_loading_time_cnt    = 0;
-  uiCfg.filament_unloading_time_flg  = false;
-  uiCfg.filament_unloading_time_cnt  = 0;
-
-  #if ENABLED(MKS_WIFI_MODULE)
-    memset(&wifiPara, 0, sizeof(wifiPara));
-    memset(&ipPara, 0, sizeof(ipPara));
-    strcpy(wifiPara.ap_name, WIFI_AP_NAME);
-    strcpy(wifiPara.keyCode, WIFI_KEY_CODE);
-    //client
-    strcpy(ipPara.ip_addr, IP_ADDR);
-    strcpy(ipPara.mask, IP_MASK);
-    strcpy(ipPara.gate, IP_GATE);
-    strcpy(ipPara.dns, IP_DNS);
-
-    ipPara.dhcp_flag = IP_DHCP_FLAG;
-
-    //AP
-    strcpy(ipPara.dhcpd_ip, AP_IP_ADDR);
-    strcpy(ipPara.dhcpd_mask, AP_IP_MASK);
-    strcpy(ipPara.dhcpd_gate, AP_IP_GATE);
-    strcpy(ipPara.dhcpd_dns, AP_IP_DNS);
-    strcpy(ipPara.start_ip_addr, IP_START_IP);
-    strcpy(ipPara.end_ip_addr, IP_END_IP);
-
-    ipPara.dhcpd_flag = AP_IP_DHCP_FLAG;
-
-    strcpy((char*)uiCfg.cloud_hostUrl, "baizhongyun.cn");
-    uiCfg.cloud_port = 10086;
-  #endif
-
-  uiCfg.filament_loading_time = (uint32_t)((gCfgItems.filamentchange_load_length * 60.0f / gCfgItems.filamentchange_load_speed) + 0.5f);
-  uiCfg.filament_unloading_time = (uint32_t)((gCfgItems.filamentchange_unload_length * 60.0f / gCfgItems.filamentchange_unload_speed) + 0.5f);
-}
-
-void update_spi_flash() {
-  uint8_t command_buf[512];
-
-  W25QXX.init(SPI_QUARTER_SPEED);
-  //read back the gcode command befor erase spi flash
-  W25QXX.SPI_FLASH_BufferRead((uint8_t *)&command_buf, GCODE_COMMAND_ADDR, sizeof(command_buf));
-  W25QXX.SPI_FLASH_SectorErase(VAR_INF_ADDR);
-  W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&gCfgItems, VAR_INF_ADDR, sizeof(gCfgItems));
-  W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&command_buf, GCODE_COMMAND_ADDR, sizeof(command_buf));
-}
-
-void update_gcode_command(int addr,uint8_t *s) {
-  uint8_t command_buf[512];
-
-  W25QXX.init(SPI_QUARTER_SPEED);
-  //read back the gcode command befor erase spi flash
-  W25QXX.SPI_FLASH_BufferRead((uint8_t *)&command_buf, GCODE_COMMAND_ADDR, sizeof(command_buf));
-  W25QXX.SPI_FLASH_SectorErase(VAR_INF_ADDR);
-  W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&gCfgItems, VAR_INF_ADDR, sizeof(gCfgItems));
-  switch (addr) {
-    case AUTO_LEVELING_COMMAND_ADDR: memcpy(&command_buf[0*100], s, 100); break;
-    case OTHERS_COMMAND_ADDR_1: memcpy(&command_buf[1*100], s, 100); break;
-    case OTHERS_COMMAND_ADDR_2: memcpy(&command_buf[2*100], s, 100); break;
-    case OTHERS_COMMAND_ADDR_3: memcpy(&command_buf[3*100], s, 100); break;
-    case OTHERS_COMMAND_ADDR_4: memcpy(&command_buf[4*100], s, 100); break;
-    default: break;
-  }
-  W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&command_buf, GCODE_COMMAND_ADDR, sizeof(command_buf));
-}
-
-void get_gcode_command(int addr,uint8_t *d) {
-  W25QXX.init(SPI_QUARTER_SPEED);
-  W25QXX.SPI_FLASH_BufferRead((uint8_t *)d, addr, 100);
-}
-
-lv_style_t tft_style_scr;
-lv_style_t tft_style_label_pre;
-lv_style_t tft_style_label_rel;
-lv_style_t style_line;
-lv_style_t style_para_value_pre;
-lv_style_t style_para_value_rel;
-
-lv_style_t style_num_key_pre;
-lv_style_t style_num_key_rel;
-
-lv_style_t style_num_text;
-lv_style_t style_sel_text;
-
-lv_style_t style_para_value;
-lv_style_t style_para_back;
-
-lv_style_t lv_bar_style_indic;
-
-lv_style_t style_btn_pr;
-lv_style_t style_btn_rel;
-
-void tft_style_init() {
-  lv_style_copy(&tft_style_scr, &lv_style_scr);
-  tft_style_scr.body.main_color   = LV_COLOR_BACKGROUND;
-  tft_style_scr.body.grad_color   = LV_COLOR_BACKGROUND;
-  tft_style_scr.text.color        = LV_COLOR_TEXT;
-  tft_style_scr.text.sel_color    = LV_COLOR_TEXT;
-  tft_style_scr.line.width        = 0;
-  tft_style_scr.text.letter_space = 0;
-  tft_style_scr.text.line_space   = 0;
-
-  lv_style_copy(&tft_style_label_pre, &lv_style_scr);
-  lv_style_copy(&tft_style_label_rel, &lv_style_scr);
-  tft_style_label_pre.body.main_color = LV_COLOR_BACKGROUND;
-  tft_style_label_pre.body.grad_color = LV_COLOR_BACKGROUND;
-  tft_style_label_pre.text.color      = LV_COLOR_TEXT;
-  tft_style_label_pre.text.sel_color  = LV_COLOR_TEXT;
-  tft_style_label_rel.body.main_color = LV_COLOR_BACKGROUND;
-  tft_style_label_rel.body.grad_color = LV_COLOR_BACKGROUND;
-  tft_style_label_rel.text.color      = LV_COLOR_TEXT;
-  tft_style_label_rel.text.sel_color  = LV_COLOR_TEXT;
-  tft_style_label_pre.text.font       = TERN(HAS_SPI_FLASH_FONT, &gb2312_puhui32, LV_FONT_DEFAULT);
-  tft_style_label_rel.text.font       = TERN(HAS_SPI_FLASH_FONT, &gb2312_puhui32, LV_FONT_DEFAULT);
-  tft_style_label_pre.line.width        = 0;
-  tft_style_label_rel.line.width        = 0;
-  tft_style_label_pre.text.letter_space = 0;
-  tft_style_label_rel.text.letter_space = 0;
-  tft_style_label_pre.text.line_space   = -5;
-  tft_style_label_rel.text.line_space   = -5;
-
-  lv_style_copy(&style_para_value_pre, &lv_style_scr);
-  lv_style_copy(&style_para_value_rel, &lv_style_scr);
-  style_para_value_pre.body.main_color = LV_COLOR_BACKGROUND;
-  style_para_value_pre.body.grad_color = LV_COLOR_BACKGROUND;
-  style_para_value_pre.text.color      = LV_COLOR_TEXT;
-  style_para_value_pre.text.sel_color  = LV_COLOR_TEXT;
-  style_para_value_rel.body.main_color = LV_COLOR_BACKGROUND;
-  style_para_value_rel.body.grad_color = LV_COLOR_BACKGROUND;
-  style_para_value_rel.text.color      = LV_COLOR_BLACK;
-  style_para_value_rel.text.sel_color  = LV_COLOR_BLACK;
-  style_para_value_pre.text.font       = TERN(HAS_SPI_FLASH_FONT, &gb2312_puhui32, LV_FONT_DEFAULT);
-  style_para_value_rel.text.font       = TERN(HAS_SPI_FLASH_FONT, &gb2312_puhui32, LV_FONT_DEFAULT);
-  style_para_value_pre.line.width        = 0;
-  style_para_value_rel.line.width        = 0;
-  style_para_value_pre.text.letter_space = 0;
-  style_para_value_rel.text.letter_space = 0;
-  style_para_value_pre.text.line_space   = -5;
-  style_para_value_rel.text.line_space   = -5;
-
-  lv_style_copy(&style_num_key_pre, &lv_style_scr);
-  lv_style_copy(&style_num_key_rel, &lv_style_scr);
-  style_num_key_pre.body.main_color = LV_COLOR_KEY_BACKGROUND;
-  style_num_key_pre.body.grad_color = LV_COLOR_KEY_BACKGROUND;
-  style_num_key_pre.text.color      = LV_COLOR_TEXT;
-  style_num_key_pre.text.sel_color  = LV_COLOR_TEXT;
-  style_num_key_rel.body.main_color = LV_COLOR_KEY_BACKGROUND;
-  style_num_key_rel.body.grad_color = LV_COLOR_KEY_BACKGROUND;
-  style_num_key_rel.text.color      = LV_COLOR_TEXT;
-  style_num_key_rel.text.sel_color  = LV_COLOR_TEXT;
-  #if HAS_SPI_FLASH_FONT
-    style_num_key_pre.text.font = &gb2312_puhui32;
-    style_num_key_rel.text.font = &gb2312_puhui32;
-  #else
-    style_num_key_pre.text.font = LV_FONT_DEFAULT;
-    style_num_key_rel.text.font = LV_FONT_DEFAULT;
-  #endif
-
-  style_num_key_pre.line.width        = 0;
-  style_num_key_rel.line.width        = 0;
-  style_num_key_pre.text.letter_space = 0;
-  style_num_key_rel.text.letter_space = 0;
-  style_num_key_pre.text.line_space   = -5;
-  style_num_key_rel.text.line_space   = -5;
-  lv_style_copy(&style_num_text, &lv_style_scr);
-
-  style_num_text.body.main_color   = LV_COLOR_WHITE;
-  style_num_text.body.grad_color   = LV_COLOR_WHITE;
-  style_num_text.text.color        = LV_COLOR_BLACK;
-  style_num_text.text.sel_color    = LV_COLOR_BLACK;
-  style_num_text.text.font         = TERN(HAS_SPI_FLASH_FONT, &gb2312_puhui32, LV_FONT_DEFAULT);
-  style_num_text.line.width        = 0;
-  style_num_text.text.letter_space = 0;
-  style_num_text.text.line_space   = -5;
-
-  lv_style_copy(&style_sel_text, &lv_style_scr);
-  style_sel_text.body.main_color  = LV_COLOR_BACKGROUND;
-  style_sel_text.body.grad_color  = LV_COLOR_BACKGROUND;
-  style_sel_text.text.color       = LV_COLOR_YELLOW;
-  style_sel_text.text.sel_color   = LV_COLOR_YELLOW;
-  style_sel_text.text.font        = &gb2312_puhui32;
-  style_sel_text.line.width       = 0;
-  style_sel_text.text.letter_space  = 0;
-  style_sel_text.text.line_space    = -5;
-  lv_style_copy(&style_line, &lv_style_plain);
-  style_line.line.color   = LV_COLOR_MAKE(0x49, 0x54, 0xFF);
-  style_line.line.width   = 1;
-  style_line.line.rounded = 1;
-
-  lv_style_copy(&style_para_value, &lv_style_plain);
-  style_para_value.body.border.color = LV_COLOR_BACKGROUND;
-  style_para_value.body.border.width = 1;
-  style_para_value.body.main_color   = LV_COLOR_WHITE;
-  style_para_value.body.grad_color   = LV_COLOR_WHITE;
-  style_para_value.body.shadow.width = 0;
-  style_para_value.body.radius       = 3;
-  style_para_value.text.color        = LV_COLOR_BLACK;
-  style_para_value.text.font         = &TERN(HAS_SPI_FLASH_FONT, gb2312_puhui32, lv_font_roboto_22);
-
-  lv_style_copy(&style_para_back, &lv_style_plain);
-  style_para_back.body.border.color = LV_COLOR_BACKGROUND;
-  style_para_back.body.border.width = 1;
-  style_para_back.body.main_color   = TFT_LV_PARA_BACK_BODY_COLOR;
-  style_para_back.body.grad_color   = TFT_LV_PARA_BACK_BODY_COLOR;
-  style_para_back.body.shadow.width = 0;
-  style_para_back.body.radius       = 3;
-  style_para_back.text.color        = LV_COLOR_WHITE;
-  style_para_back.text.font         = &TERN(HAS_SPI_FLASH_FONT, gb2312_puhui32, lv_font_roboto_22);
-
-  lv_style_copy(&style_btn_rel, &lv_style_plain);
-  style_btn_rel.body.border.color = lv_color_hex3(0x269);
-  style_btn_rel.body.border.width = 1;
-  style_btn_rel.body.main_color   = lv_color_hex3(0xADF);
-  style_btn_rel.body.grad_color   = lv_color_hex3(0x46B);
-  style_btn_rel.body.shadow.width = 4;
-  style_btn_rel.body.shadow.type  = LV_SHADOW_BOTTOM;
-  style_btn_rel.body.radius       = LV_RADIUS_CIRCLE;
-  style_btn_rel.text.color        = lv_color_hex3(0xDEF);
-  style_btn_rel.text.font         = &TERN(HAS_SPI_FLASH_FONT, gb2312_puhui32, lv_font_roboto_22);
-
-  lv_style_copy(&style_btn_pr, &style_btn_rel);
-  style_btn_pr.body.border.color = lv_color_hex3(0x46B);
-  style_btn_pr.body.main_color   = lv_color_hex3(0x8BD);
-  style_btn_pr.body.grad_color   = lv_color_hex3(0x24A);
-  style_btn_pr.body.shadow.width = 2;
-  style_btn_pr.text.color        = lv_color_hex3(0xBCD);
-  style_btn_pr.text.font         = &TERN(HAS_SPI_FLASH_FONT, gb2312_puhui32, lv_font_roboto_22);
-
-  lv_style_copy(&lv_bar_style_indic, &lv_style_pretty_color);
-  lv_bar_style_indic.text.color        = lv_color_hex3(0xADF);
-  lv_bar_style_indic.image.color       = lv_color_hex3(0xADF);
-  lv_bar_style_indic.line.color        = lv_color_hex3(0xADF);
-  lv_bar_style_indic.body.main_color   = lv_color_hex3(0xADF);
-  lv_bar_style_indic.body.grad_color   = lv_color_hex3(0xADF);
-  lv_bar_style_indic.body.border.color = lv_color_hex3(0xADF);
-}
-
-#define MAX_TITLE_LEN 28
-
-char public_buf_m[100] = {0};
-char public_buf_l[30];
-
-void titleText_cat(char *str, int strSize, char *addPart) {
-  if (str == 0 || addPart == 0) return;
-  if ((int)(strlen(str) + strlen(addPart)) >= strSize) return;
-  strcat(str, addPart);
-}
-
-char *getDispText(int index) {
-
-  ZERO(public_buf_l);
-
-  switch (disp_state_stack._disp_state[index]) {
-    case PRINT_READY_UI:      strcpy(public_buf_l, main_menu.title); break;
-    case PRINT_FILE_UI:       strcpy(public_buf_l, file_menu.title); break;
-    case PRINTING_UI:
-      switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
-        IF_DISABLED(TFT35, case OPERATE_UI: case PAUSE_UI:)
-        case PRINTING_UI:     strcpy(public_buf_l, common_menu.print_special_title); break;
-        default:              strcpy(public_buf_l, printing_menu.title); break;
-      }
-      break;
-    case MOVE_MOTOR_UI:       strcpy(public_buf_l, move_menu.title); break;
-    case OPERATE_UI:
-      switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
-        IF_DISABLED(TFT35, case OPERATE_UI: case PAUSE_UI:)
-        case PRINTING_UI:     strcpy(public_buf_l, common_menu.operate_special_title); break;
-        default:              strcpy(public_buf_l, operation_menu.title); break;
-      }
-      break;
-
-    case PAUSE_UI:
-      switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
-        case OPERATE_UI:
-        case PAUSE_UI:
-        case PRINTING_UI:     strcpy(public_buf_l, common_menu.pause_special_title); break;
-        default:              strcpy(public_buf_l, pause_menu.title); break;
-      }
-      break;
-    case EXTRUSION_UI:        strcpy(public_buf_l, extrude_menu.title); break;
-    case CHANGE_SPEED_UI:     strcpy(public_buf_l, speed_menu.title); break;
-    case FAN_UI:              strcpy(public_buf_l, fan_menu.title); break;
-    case PRE_HEAT_UI:
-      switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
-        case OPERATE_UI:      strcpy(public_buf_l, preheat_menu.adjust_title);
-        default:              strcpy(public_buf_l, preheat_menu.title); break;
-      }
-      break;
-    case SET_UI:              strcpy(public_buf_l, set_menu.title); break;
-    case ZERO_UI:             strcpy(public_buf_l, home_menu.title); break;
-    case SPRAYER_UI:          break;
-    case MACHINE_UI:          break;
-    case LANGUAGE_UI:         strcpy(public_buf_l, language_menu.title); break;
-    case ABOUT_UI:            strcpy(public_buf_l, about_menu.title); break;
-    case LOG_UI:              break;
-    case DISK_UI:             strcpy(public_buf_l, filesys_menu.title); break;
-    case DIALOG_UI:           strcpy(public_buf_l, common_menu.dialog_confirm_title); break;
-    case WIFI_UI:             strcpy(public_buf_l, wifi_menu.title); break;
-    case MORE_UI:
-    case PRINT_MORE_UI:       strcpy(public_buf_l, more_menu.title); break;
-    case FILAMENTCHANGE_UI:   strcpy(public_buf_l, filament_menu.title); break;
-    case LEVELING_UI:
-    case MESHLEVELING_UI:     strcpy(public_buf_l, leveling_menu.title); break;
-    case BIND_UI:             strcpy(public_buf_l, cloud_menu.title); break;
-    case TOOL_UI:             strcpy(public_buf_l, tool_menu.title); break;
-    case WIFI_LIST_UI:        TERN_(MKS_WIFI_MODULE, strcpy(public_buf_l, list_menu.title)); break;
-    case MACHINE_PARA_UI:     strcpy(public_buf_l, MachinePara_menu.title); break;
-    case BABY_STEP_UI:        strcpy(public_buf_l, operation_menu.babystep); break;
-    case EEPROM_SETTINGS_UI:  strcpy(public_buf_l, eeprom_menu.title); break;
-    case MEDIA_SELECT_UI:     strcpy(public_buf_l, media_select_menu.title); break;
-    default: break;
-  }
-
-  return public_buf_l;
-}
-
-char *creat_title_text() {
-  int index     = 0;
-  char *tmpText = 0;
-  char tmpCurFileStr[20];
-
-  ZERO(tmpCurFileStr);
-
-  cutFileName(list_file.long_name[sel_id], 16, 16, tmpCurFileStr);
-
-  ZERO(public_buf_m);
-
-  while (index <= disp_state_stack._disp_index) {
-    tmpText = getDispText(index);
-    if ((*tmpText == 0) || (tmpText == 0)) {
-      index++;
-      continue;
-    }
-
-    titleText_cat(public_buf_m, sizeof(public_buf_m), tmpText);
-    if (index < disp_state_stack._disp_index) titleText_cat(public_buf_m, sizeof(public_buf_m), (char *)">");
-
-    index++;
-  }
-
-  if (disp_state_stack._disp_state[disp_state_stack._disp_index] == PRINTING_UI) {
-    titleText_cat(public_buf_m, sizeof(public_buf_m), (char *)":");
-    titleText_cat(public_buf_m, sizeof(public_buf_m), tmpCurFileStr);
-  }
-
-  if (strlen(public_buf_m) > MAX_TITLE_LEN) {
-    ZERO(public_buf_m);
-    tmpText = 0;
-    for (index = 0; index <= disp_state_stack._disp_index && (!tmpText || *tmpText == 0); index++)
-      tmpText = getDispText(index);
-    if (*tmpText != 0) {
-      titleText_cat(public_buf_m, sizeof(public_buf_m), tmpText);
-      titleText_cat(public_buf_m, sizeof(public_buf_m), (char *)">...>");
-      tmpText = getDispText(disp_state_stack._disp_index);
-      if (*tmpText != 0) titleText_cat(public_buf_m, sizeof(public_buf_m), tmpText);
-    }
-  }
-
-  return public_buf_m;
-}
-
-#if HAS_GCODE_PREVIEW
-
-  uint32_t gPicturePreviewStart = 0;
-
-  void preview_gcode_prehandle(char *path) {
-    #if ENABLED(SDSUPPORT)
-      uint32_t pre_read_cnt = 0;
-      uint32_t *p1;
-      char *cur_name;
-
-      gPicturePreviewStart = 0;
-      cur_name             = strrchr(path, '/');
-      card.openFileRead(cur_name);
-      card.read(public_buf, 512);
-      p1 = (uint32_t *)strstr((char *)public_buf, ";simage:");
-
-      if (p1) {
-        pre_read_cnt = (uint32_t)p1 - (uint32_t)((uint32_t *)(&public_buf[0]));
-
-        To_pre_view              = pre_read_cnt;
-        gcode_preview_over       = true;
-        gCfgItems.from_flash_pic = true;
-        update_spi_flash();
-      }
-      else {
-        gcode_preview_over       = false;
-        default_preview_flg      = true;
-        gCfgItems.from_flash_pic = false;
-        update_spi_flash();
-      }
-      card.closefile();
-    #endif
-  }
-
-  void gcode_preview(char *path, int xpos_pixel, int ypos_pixel) {
-    #if ENABLED(SDSUPPORT)
-      volatile uint32_t i, j;
-      volatile uint16_t *p_index;
-      char *cur_name;
-
-      cur_name = strrchr(path, '/');
-      card.openFileRead(cur_name);
-
-      if (gPicturePreviewStart <= 0) {
-        while (1) {
-          uint32_t br  = card.read(public_buf, 400);
-          uint32_t *p1 = (uint32_t *)strstr((char *)public_buf, ";gimage:");
-          if (p1) {
-            gPicturePreviewStart += (uint32_t)p1 - (uint32_t)((uint32_t *)(&public_buf[0]));
-            break;
-          }
-          else {
-            gPicturePreviewStart += br;
-          }
-          if (br < 400) break;
-        }
-      }
-
-      card.setIndex(gPicturePreviewStart + size * row + 8);
-      SPI_TFT.setWindow(xpos_pixel, ypos_pixel + row, 200, 1);
-
-      j = i = 0;
-
-      while (1) {
-        card.read(public_buf, 400);
-        for (i = 0; i < 400;) {
-          bmp_public_buf[j] = ascii2dec_test((char*)&public_buf[i]) << 4 | ascii2dec_test((char*)&public_buf[i + 1]);
-          i                += 2;
-          j++;
-        }
-        if (j >= 400) break;
-      }
-      for (i = 0; i < 400; i += 2) {
-        p_index  = (uint16_t *)(&bmp_public_buf[i]);
-        if (*p_index == 0x0000) *p_index = LV_COLOR_BACKGROUND.full;
-      }
-      SPI_TFT.tftio.WriteSequence((uint16_t*)bmp_public_buf, 200);
-      #if HAS_BAK_VIEW_IN_FLASH
-        W25QXX.init(SPI_QUARTER_SPEED);
-        if (row < 20) W25QXX.SPI_FLASH_SectorErase(BAK_VIEW_ADDR_TFT35 + row * 4096);
-        W25QXX.SPI_FLASH_BufferWrite(bmp_public_buf, BAK_VIEW_ADDR_TFT35 + row * 400, 400);
-      #endif
-      row++;
-      if (row >= 200) {
-        size = 809;
-        row  = 0;
-
-        gcode_preview_over = false;
-
-        card.closefile();
-        char *cur_name;
-
-        cur_name = strrchr(list_file.file_name[sel_id], '/');
-
-        SdFile file;
-        SdFile *curDir;
-        card.endFilePrint();
-        const char * const fname = card.diveToFile(true, curDir, cur_name);
-        if (!fname) return;
-        if (file.open(curDir, fname, O_READ)) {
-          gCfgItems.curFilesize = file.fileSize();
-          file.close();
-          update_spi_flash();
-        }
-
-        card.openFileRead(cur_name);
-        if (card.isFileOpen()) {
-          feedrate_percentage = 100;
-          planner.flow_percentage[0] = 100;
-          planner.e_factor[0]        = planner.flow_percentage[0] * 0.01;
-          #if HAS_MULTI_EXTRUDER
-            planner.flow_percentage[1] = 100;
-            planner.e_factor[1]        = planner.flow_percentage[1] * 0.01;
-          #endif
-          card.startFileprint();
-          TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
-          once_flag = false;
-        }
-        return;
-      }
-      card.closefile();
-    #endif // SDSUPPORT
-  }
-
-  void draw_default_preview(int xpos_pixel, int ypos_pixel, uint8_t sel) {
-    int index;
-    int y_off = 0;
-    W25QXX.init(SPI_QUARTER_SPEED);
-    for (index = 0; index < 10; index++) { // 200*200
-      #if HAS_BAK_VIEW_IN_FLASH
-        if (sel == 1) {
-          flash_view_Read(bmp_public_buf, 8000); // 20k
-        }
-        else {
-          default_view_Read(bmp_public_buf, DEFAULT_VIEW_MAX_SIZE / 10); // 8k
-        }
-      #else
-        default_view_Read(bmp_public_buf, DEFAULT_VIEW_MAX_SIZE / 10); // 8k
-      #endif
-
-      SPI_TFT.setWindow(xpos_pixel, y_off * 20 + ypos_pixel, 200, 20); // 200*200
-      SPI_TFT.tftio.WriteSequence((uint16_t*)(bmp_public_buf), DEFAULT_VIEW_MAX_SIZE / 20);
-
-      y_off++;
-    }
-    W25QXX.init(SPI_QUARTER_SPEED);
-  }
-
-  void disp_pre_gcode(int xpos_pixel, int ypos_pixel) {
-    if (gcode_preview_over) gcode_preview(list_file.file_name[sel_id], xpos_pixel, ypos_pixel);
-    #if HAS_BAK_VIEW_IN_FLASH
-      if (flash_preview_begin) {
-        flash_preview_begin = false;
-        draw_default_preview(xpos_pixel, ypos_pixel, 1);
-      }
-    #endif
-    #if HAS_GCODE_DEFAULT_VIEW_IN_FLASH
-      if (default_preview_flg) {
-        draw_default_preview(xpos_pixel, ypos_pixel, 0);
-        default_preview_flg = false;
-      }
-    #endif
-  }
-#endif // HAS_GCODE_PREVIEW
-
-void print_time_run() {
-  static uint8_t lastSec = 0;
-
-  if (print_time.seconds >= 60) {
-    print_time.seconds = 0;
-    print_time.minutes++;
-    if (print_time.minutes >= 60) {
-      print_time.minutes = 0;
-      print_time.hours++;
-    }
-  }
-  if (disp_state == PRINTING_UI) {
-    if (lastSec != print_time.seconds) disp_print_time();
-    lastSec = print_time.seconds;
-  }
-}
-
-void GUI_RefreshPage() {
-  if ((systick_uptime_millis % 1000) == 0) temps_update_flag = true;
-  if ((systick_uptime_millis % 3000) == 0) printing_rate_update_flag = true;
-
-  switch (disp_state) {
-    case MAIN_UI:
-      break;
-    case EXTRUSION_UI:
-      if (temps_update_flag) {
-        temps_update_flag = false;
-        disp_hotend_temp();
-      }
-      break;
-    case PRE_HEAT_UI:
-      if (temps_update_flag) {
-        temps_update_flag = false;
-        disp_desire_temp();
-      }
-      break;
-    case PRINT_READY_UI:
-      if (temps_update_flag) {
-        temps_update_flag = false;
-        lv_temp_refr();
-      }
-      break;
-
-    case PRINT_FILE_UI: break;
-
-    case PRINTING_UI:
-      if (temps_update_flag) {
-        temps_update_flag = false;
-        disp_ext_temp();
-        disp_bed_temp();
-        disp_fan_speed();
-        disp_print_time();
-        disp_fan_Zpos();
-      }
-      if (printing_rate_update_flag || marlin_state == MF_SD_COMPLETE) {
-        printing_rate_update_flag = false;
-        if (!gcode_preview_over) setProBarRate();
-      }
-      break;
-
-    case OPERATE_UI: break;
-
-    case PAUSE_UI: break;
-
-    case FAN_UI:
-      if (temps_update_flag) {
-        temps_update_flag = false;
-        disp_fan_value();
-      }
-      break;
-
-    case MOVE_MOTOR_UI: break;
-
-    #if ENABLED(MKS_WIFI_MODULE)
-      case WIFI_UI:
-        if (temps_update_flag) {
-          temps_update_flag = false;
-          disp_wifi_state();
-        }
-        break;
-
-      case BIND_UI: refresh_bind_ui(); break;
-    #endif
-
-    case FILAMENTCHANGE_UI:
-      if (temps_update_flag) {
-        temps_update_flag = false;
-        disp_filament_temp();
-      }
-      break;
-    case DIALOG_UI:
-      filament_dialog_handle();
-      TERN_(MKS_WIFI_MODULE, wifi_scan_handle());
-      break;
-    case MESHLEVELING_UI: break;
-    case HARDWARE_TEST_UI: break;
-    case WIFI_LIST_UI:
-      #if ENABLED(MKS_WIFI_MODULE)
-        if (printing_rate_update_flag) {
-          disp_wifi_list();
-          printing_rate_update_flag = false;
-        }
-      #endif
-      break;
-    case KEYBOARD_UI: break;
-
-    #if ENABLED(MKS_WIFI_MODULE)
-      case WIFI_TIPS_UI:
-        switch (wifi_tips_type) {
-          case TIPS_TYPE_JOINING:
-            if (wifi_link_state == WIFI_CONNECTED && strcmp((const char *)wifi_list.wifiConnectedName,(const char *)wifi_list.wifiName[wifi_list.nameIndex]) == 0) {
-              tips_disp.timer = TIPS_TIMER_STOP;
-              tips_disp.timer_count = 0;
-
-              lv_clear_wifi_tips();
-              wifi_tips_type = TIPS_TYPE_WIFI_CONECTED;
-              lv_draw_wifi_tips();
-
-            }
-            if (tips_disp.timer_count >= SEC_TO_MS(30)) {
-              tips_disp.timer = TIPS_TIMER_STOP;
-              tips_disp.timer_count = 0;
-              lv_clear_wifi_tips();
-              wifi_tips_type = TIPS_TYPE_TAILED_JOIN;
-              lv_draw_wifi_tips();
-            }
-            break;
-          case TIPS_TYPE_TAILED_JOIN:
-            if (tips_disp.timer_count >= SEC_TO_MS(3)) {
-              tips_disp.timer = TIPS_TIMER_STOP;
-              tips_disp.timer_count = 0;
-
-              last_disp_state = WIFI_TIPS_UI;
-              lv_clear_wifi_tips();
-              lv_draw_wifi_list();
-            }
-            break;
-          case TIPS_TYPE_WIFI_CONECTED:
-            if (tips_disp.timer_count >= SEC_TO_MS(3)) {
-              tips_disp.timer = TIPS_TIMER_STOP;
-              tips_disp.timer_count = 0;
-
-              last_disp_state = WIFI_TIPS_UI;
-              lv_clear_wifi_tips();
-              lv_draw_wifi();
-            }
-            break;
-          default: break;
-        }
-        break;
-    #endif
-
-    case BABY_STEP_UI:
-      if (temps_update_flag) {
-        temps_update_flag = false;
-        disp_z_offset_value();
-      }
-      break;
-
-    default: break;
-  }
-
-  print_time_run();
-}
-
-void clear_cur_ui() {
-  last_disp_state = disp_state_stack._disp_state[disp_state_stack._disp_index];
-
-  switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
-    case PRINT_READY_UI:              lv_clear_ready_print(); break;
-    case PRINT_FILE_UI:               lv_clear_print_file(); break;
-    case PRINTING_UI:                 lv_clear_printing(); break;
-    case MOVE_MOTOR_UI:               lv_clear_move_motor(); break;
-    case OPERATE_UI:                  lv_clear_operation(); break;
-    case PAUSE_UI:                    break;
-    case EXTRUSION_UI:                lv_clear_extrusion(); break;
-    case PRE_HEAT_UI:                 lv_clear_preHeat(); break;
-    case CHANGE_SPEED_UI:             lv_clear_change_speed(); break;
-    case FAN_UI:                      lv_clear_fan(); break;
-    case SET_UI:                      lv_clear_set(); break;
-    case ZERO_UI:                     lv_clear_home(); break;
-    case SPRAYER_UI:                  break;
-    case MACHINE_UI:                  break;
-    case LANGUAGE_UI:                 lv_clear_language(); break;
-    case ABOUT_UI:                    lv_clear_about(); break;
-    case LOG_UI:                      break;
-    case DISK_UI:                     break;
-    #if ENABLED(MKS_WIFI_MODULE)
-      case WIFI_UI:                   lv_clear_wifi(); break;
-    #endif
-    case MORE_UI:                     lv_clear_more(); break;
-    case FILETRANSFER_UI:             break;
-    case DIALOG_UI:                   lv_clear_dialog(); break;
-    case FILETRANSFERSTATE_UI:        break;
-    case PRINT_MORE_UI:               break;
-    case FILAMENTCHANGE_UI:           lv_clear_filament_change(); break;
-    case LEVELING_UI:                 lv_clear_manualLevel(); break;
-    #if ENABLED(MKS_WIFI_MODULE)
-      case BIND_UI:                   lv_clear_cloud_bind(); break;
-    #endif
-    #if HAS_BED_PROBE
-      case NOZZLE_PROBE_OFFSET_UI:    lv_clear_auto_level_offset_settings(); break;
-    #endif
-    case TOOL_UI:                     lv_clear_tool(); break;
-    case MESHLEVELING_UI:             break;
-    case HARDWARE_TEST_UI:            break;
-    #if ENABLED(MKS_WIFI_MODULE)
-      case WIFI_LIST_UI:              lv_clear_wifi_list(); break;
-    #endif
-    case KEYBOARD_UI:                 lv_clear_keyboard(); break;
-    #if ENABLED(MKS_WIFI_MODULE)
-      case WIFI_TIPS_UI:              lv_clear_wifi_tips(); break;
-    #endif
-    case MACHINE_PARA_UI:             lv_clear_machine_para(); break;
-    case MACHINE_SETTINGS_UI:         lv_clear_machine_settings(); break;
-    case TEMPERATURE_SETTINGS_UI:     break;
-    case MOTOR_SETTINGS_UI:           lv_clear_motor_settings(); break;
-    case MACHINETYPE_UI:              break;
-    case STROKE_UI:                   break;
-    case HOME_DIR_UI:                 break;
-    case ENDSTOP_TYPE_UI:             break;
-    case FILAMENT_SETTINGS_UI:        break;
-    case LEVELING_SETTIGNS_UI:        break;
-    case LEVELING_PARA_UI:            lv_clear_level_settings(); break;
-    case DELTA_LEVELING_PARA_UI:      break;
-    case MANUAL_LEVELING_POSIGION_UI: lv_clear_tramming_pos_settings(); break;
-    case MAXFEEDRATE_UI:              lv_clear_max_feedrate_settings(); break;
-    case STEPS_UI:                    lv_clear_step_settings(); break;
-    case ACCELERATION_UI:             lv_clear_acceleration_settings(); break;
-    case JERK_UI:                     TERN_(HAS_CLASSIC_JERK, lv_clear_jerk_settings()); break;
-    case MOTORDIR_UI:                 break;
-    case HOMESPEED_UI:                break;
-    case NOZZLE_CONFIG_UI:            break;
-    case HOTBED_CONFIG_UI:            break;
-    case ADVANCED_UI:                 lv_clear_advance_settings(); break;
-    case DOUBLE_Z_UI:                 break;
-    case ENABLE_INVERT_UI:            break;
-    case NUMBER_KEY_UI:               lv_clear_number_key(); break;
-    case BABY_STEP_UI:                lv_clear_baby_stepping(); break;
-    case PAUSE_POS_UI:                lv_clear_pause_position(); break;
-    #if HAS_TRINAMIC_CONFIG
-      case TMC_CURRENT_UI:            lv_clear_tmc_current_settings(); break;
-    #endif
-    case EEPROM_SETTINGS_UI:          lv_clear_eeprom_settings(); break;
-    #if HAS_STEALTHCHOP
-      case TMC_MODE_UI:               lv_clear_tmc_step_mode_settings(); break;
-    #endif
-    #if ENABLED(MKS_WIFI_MODULE)
-      case WIFI_SETTINGS_UI:          lv_clear_wifi_settings(); break;
-    #endif
-    #if USE_SENSORLESS
-      case HOMING_SENSITIVITY_UI:     lv_clear_homing_sensitivity_settings(); break;
-    #endif
-    #if HAS_ROTARY_ENCODER
-      case ENCODER_SETTINGS_UI:       lv_clear_encoder_settings(); break;
-    #endif
-    #if ENABLED(TOUCH_SCREEN_CALIBRATION)
-      case TOUCH_CALIBRATION_UI:      lv_clear_touch_calibration_screen(); break;
-    #endif
-    #if ENABLED(MULTI_VOLUME)
-      case MEDIA_SELECT_UI:           lv_clear_media_select(); break;
-    #endif
-    default: break;
-  }
-}
-
-void draw_return_ui() {
-  if (disp_state_stack._disp_index > 0) {
-    disp_state_stack._disp_index--;
-
-    switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
-      case PRINT_READY_UI:              lv_draw_ready_print(); break;
-      case PRINT_FILE_UI:               lv_draw_print_file(); break;
-
-      case PRINTING_UI:                 if (gCfgItems.from_flash_pic)
-                                          flash_preview_begin = true;
-                                        else
-                                          default_preview_flg = true;
-                                        lv_draw_printing();
-                                        break;
-
-      case MOVE_MOTOR_UI:               lv_draw_move_motor(); break;
-      case OPERATE_UI:                  lv_draw_operation(); break;
-      case PAUSE_UI:                    break;
-      case EXTRUSION_UI:                lv_draw_extrusion(); break;
-      case PRE_HEAT_UI:                 lv_draw_preHeat(); break;
-      case CHANGE_SPEED_UI:             lv_draw_change_speed(); break;
-      case FAN_UI:                      lv_draw_fan(); break;
-      case SET_UI:                      lv_draw_set(); break;
-      case ZERO_UI:                     lv_draw_home(); break;
-      case SPRAYER_UI:                  break;
-      case MACHINE_UI:                  break;
-      case LANGUAGE_UI:                 lv_draw_language(); break;
-      case ABOUT_UI:                    lv_draw_about(); break;
-
-      case CALIBRATE_UI:                break;
-      case DISK_UI:                     break;
-      #if ENABLED(MKS_WIFI_MODULE)
-        case WIFI_UI:                   lv_draw_wifi(); break;
-      #endif
-      case MORE_UI:                     break;
-      case PRINT_MORE_UI:               lv_draw_more(); break;
-      case FILAMENTCHANGE_UI:           lv_draw_filament_change(); break;
-      case LEVELING_UI:                 lv_draw_manualLevel(); break;
-      #if ENABLED(MKS_WIFI_MODULE)
-        case BIND_UI:                   lv_draw_cloud_bind(); break;
-      #endif
-      #if HAS_BED_PROBE
-        case NOZZLE_PROBE_OFFSET_UI:    lv_draw_auto_level_offset_settings(); break;
-      #endif
-      case TOOL_UI:                     lv_draw_tool(); break;
-      case GCODE_UI:                    lv_draw_gcode(); break;
-      case MESHLEVELING_UI:             break;
-      case HARDWARE_TEST_UI:            break;
-      #if ENABLED(MKS_WIFI_MODULE)
-        case WIFI_LIST_UI:              lv_draw_wifi_list(); break;
-      #endif
-      case KEYBOARD_UI:                 lv_draw_keyboard(); break;
-      #if ENABLED(MKS_WIFI_MODULE)
-        case WIFI_TIPS_UI:              lv_draw_wifi_tips(); break;
-      #endif
-      case MACHINE_PARA_UI:             lv_draw_machine_para(); break;
-      case MACHINE_SETTINGS_UI:         lv_draw_machine_settings(); break;
-      case TEMPERATURE_SETTINGS_UI:     break;
-      case MOTOR_SETTINGS_UI:           lv_draw_motor_settings(); break;
-      case MACHINETYPE_UI:              break;
-      case STROKE_UI:                   break;
-      case HOME_DIR_UI:                 break;
-      case ENDSTOP_TYPE_UI:             break;
-      case FILAMENT_SETTINGS_UI:        lv_draw_filament_settings(); break;
-      case LEVELING_SETTIGNS_UI:        break;
-      case LEVELING_PARA_UI:            lv_draw_level_settings(); break;
-      case DELTA_LEVELING_PARA_UI:      break;
-      case MANUAL_LEVELING_POSIGION_UI: lv_draw_tramming_pos_settings(); break;
-      case MAXFEEDRATE_UI:              lv_draw_max_feedrate_settings(); break;
-      case STEPS_UI:                    lv_draw_step_settings(); break;
-      case ACCELERATION_UI:             lv_draw_acceleration_settings(); break;
-      #if HAS_CLASSIC_JERK
-        case JERK_UI:                   lv_draw_jerk_settings(); break;
-      #endif
-      case MOTORDIR_UI:                 break;
-      case HOMESPEED_UI:                break;
-      case NOZZLE_CONFIG_UI:            break;
-      case HOTBED_CONFIG_UI:            break;
-      case ADVANCED_UI:                 lv_draw_advance_settings(); break;
-      case DOUBLE_Z_UI:                 break;
-      case ENABLE_INVERT_UI:            break;
-      case NUMBER_KEY_UI:               lv_draw_number_key(); break;
-      case DIALOG_UI:                   break;
-      case BABY_STEP_UI:                lv_draw_baby_stepping(); break;
-      case PAUSE_POS_UI:                lv_draw_pause_position(); break;
-      #if HAS_TRINAMIC_CONFIG
-        case TMC_CURRENT_UI:            lv_draw_tmc_current_settings(); break;
-      #endif
-      case EEPROM_SETTINGS_UI:          lv_draw_eeprom_settings(); break;
-        #if HAS_STEALTHCHOP
-          case TMC_MODE_UI:             lv_draw_tmc_step_mode_settings(); break;
-        #endif
-      #if ENABLED(MKS_WIFI_MODULE)
-        case WIFI_SETTINGS_UI:          lv_draw_wifi_settings(); break;
-      #endif
-      #if USE_SENSORLESS
-        case HOMING_SENSITIVITY_UI:     lv_draw_homing_sensitivity_settings(); break;
-      #endif
-      #if HAS_ROTARY_ENCODER
-        case ENCODER_SETTINGS_UI:       lv_draw_encoder_settings(); break;
-      #endif
-      default: break;
-    }
-  }
-}
-
-// Set the same image for both Released and Pressed
-void lv_imgbtn_set_src_both(lv_obj_t *imgbtn, const void *src) {
-  lv_imgbtn_set_src(imgbtn, LV_BTN_STATE_REL, src);
-  lv_imgbtn_set_src(imgbtn, LV_BTN_STATE_PR,  src);
-}
-
-// Use label style for the image button
-void lv_imgbtn_use_label_style(lv_obj_t *imgbtn) {
-  lv_imgbtn_set_style(imgbtn, LV_BTN_STATE_REL, &tft_style_label_rel);
-  lv_imgbtn_set_style(imgbtn, LV_BTN_STATE_PR,  &tft_style_label_pre);
-}
-
-// Use label style for the button
-void lv_btn_use_label_style(lv_obj_t *btn) {
-  lv_btn_set_style(btn, LV_BTN_STYLE_REL, &tft_style_label_rel);
-  lv_btn_set_style(btn, LV_BTN_STYLE_PR,  &tft_style_label_pre);
-}
-
-// Use button style for the button
-void lv_btn_use_button_style(lv_obj_t *btn) {
-  lv_btn_set_style(btn, LV_BTN_STYLE_REL, &style_btn_rel);
-  lv_btn_set_style(btn, LV_BTN_STYLE_PR,  &style_btn_pr);
-}
-
-// Use a single style for both Released and Pressed
-void lv_btn_set_style_both(lv_obj_t *btn, lv_style_t *style) {
-  lv_btn_set_style(btn, LV_BTN_STYLE_REL, style);
-  lv_btn_set_style(btn, LV_BTN_STYLE_PR,  style);
-}
-
-// Create a screen
-lv_obj_t* lv_screen_create(DISP_STATE newScreenType, const char *title) {
-  lv_obj_t *scr = lv_obj_create(nullptr, nullptr);
-  lv_obj_set_style(scr, &tft_style_scr);
-  lv_scr_load(scr);
-  lv_obj_clean(scr);
-
-  // breadcrumbs
-  if (disp_state_stack._disp_state[disp_state_stack._disp_index] != newScreenType) {
-    disp_state_stack._disp_index++;
-    disp_state_stack._disp_state[disp_state_stack._disp_index] = newScreenType;
-  }
-  disp_state = newScreenType;
-
-  // title
-  lv_obj_t *titleLabel = nullptr;
-  if (!title)
-    titleLabel = lv_label_create(scr, TITLE_XPOS, TITLE_YPOS, creat_title_text());
-  else if (title[0] != '\0')
-    titleLabel = lv_label_create(scr, TITLE_XPOS, TITLE_YPOS, title);
-  if (titleLabel)
-    lv_obj_set_style(titleLabel, &tft_style_label_rel);
-
-  lv_refr_now(lv_refr_get_disp_refreshing());
-
-  return scr;
-}
-
-// Create an empty label
-lv_obj_t* lv_label_create_empty(lv_obj_t *par) {
-  lv_obj_t *label = lv_label_create(par, (lv_obj_t*)nullptr);
-  return label;
-}
-
-// Create a label with style and text
-lv_obj_t* lv_label_create(lv_obj_t *par, const char *text) {
-  lv_obj_t *label = lv_label_create_empty(par);
-  if (text) lv_label_set_text(label, text);
-  lv_obj_set_style(label, &tft_style_label_rel);
-  return label;
-}
-
-// Create a label with style, position, and text
-lv_obj_t* lv_label_create(lv_obj_t *par, lv_coord_t x, lv_coord_t y, const char *text) {
-  lv_obj_t *label = lv_label_create(par, text);
-  lv_obj_set_pos(label, x, y);
-  return label;
-}
-
-// Create a button with callback, ID, and Style.
-lv_obj_t* lv_btn_create(lv_obj_t *par, lv_event_cb_t cb, const int id/*=0*/, lv_style_t *style/*=&style_para_value*/) {
-  lv_obj_t *btn = lv_btn_create(par, nullptr);
-  if (id)
-    lv_obj_set_event_cb_mks(btn, cb, id, "", 0);
-  else
-    lv_obj_set_event_cb(btn, cb);
-  lv_btn_set_style_both(btn, style);
-  return btn;
-}
-
-// Create a button with callback and ID, with label style.
-lv_obj_t* lv_label_btn_create(lv_obj_t *par, lv_event_cb_t cb, const int id/*=0*/) {
-  lv_obj_t *btn = lv_btn_create(par, cb, id, nullptr);
-  lv_btn_use_label_style(btn);
-  return btn;
-}
-
-// Create a button with callback and ID, with button style.
-lv_obj_t* lv_button_btn_create(lv_obj_t *par, lv_event_cb_t cb, const int id/*=0*/) {
-  lv_obj_t *btn = lv_btn_create(par, cb, id, nullptr);
-  lv_btn_use_button_style(btn);
-  return btn;
-}
-
-// Create a button with position, size, callback, ID, and style.
-lv_obj_t* lv_btn_create(lv_obj_t *par, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, lv_event_cb_t cb, const int id, lv_style_t *style) {
-  lv_obj_t *btn = lv_btn_create(par, cb, id, style);
-  lv_obj_set_pos(btn, x, y);
-  lv_obj_set_size(btn, w, h);
-  return btn;
-}
-
-// Create a button with position, size, callback, and ID. Style set to style_para_value.
-lv_obj_t* lv_btn_create(lv_obj_t *par, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, lv_event_cb_t cb, const int id/*=0*/) {
-  lv_obj_t *btn = lv_btn_create(par, x, y, w, h, cb, id, &style_para_value);
-  return btn;
-}
-
-// Create a button with position, size, callback, and ID, with label style.
-lv_obj_t* lv_label_btn_create(lv_obj_t *par, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, lv_event_cb_t cb, const int id/*=0*/) {
-  lv_obj_t *btn = lv_label_btn_create(par, cb, id);
-  lv_obj_set_pos(btn, x, y);
-  lv_obj_set_size(btn, w, h);
-  return btn;
-}
-
-// Create a button with position, size, callback, and ID, with label style.
-lv_obj_t* lv_button_btn_create(lv_obj_t *par, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, lv_event_cb_t cb, const int id/*=0*/) {
-  lv_obj_t *btn = lv_button_btn_create(par, cb, id);
-  lv_obj_set_pos(btn, x, y);
-  lv_obj_set_size(btn, w, h);
-  return btn;
-}
-
-// Create a button with callback and ID. Style set to style_para_back.
-lv_obj_t* lv_btn_create_back(lv_obj_t *par, lv_event_cb_t cb, const int id/*=0*/) {
-  return lv_btn_create(par, cb, id, &style_para_back);
-}
-// Create a button with position, size, callback, and ID. Style set to style_para_back.
-lv_obj_t* lv_btn_create_back(lv_obj_t *par, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, lv_event_cb_t cb, const int id/*=0*/) {
-  lv_obj_t *btn = lv_btn_create_back(par, cb, id);
-  lv_obj_set_pos(btn, x, y);
-  lv_obj_set_size(btn, w, h);
-  return btn;
-}
-
-// Create an image button with image, callback, and ID. Use label style.
-lv_obj_t* lv_imgbtn_create(lv_obj_t *par, const char *img, lv_event_cb_t cb, const int id/*=0*/) {
-  lv_obj_t *btn = lv_imgbtn_create(par, nullptr);
-  if (img) lv_imgbtn_set_src_both(btn, img);
-  if (id)
-    lv_obj_set_event_cb_mks(btn, cb, id, "", 0);
-  else
-    lv_obj_set_event_cb(btn, cb);
-  lv_imgbtn_use_label_style(btn);
-  lv_btn_set_layout(btn, LV_LAYOUT_OFF);
-  return btn;
-}
-
-// Create an image button with image, position, callback, and ID. Use label style.
-lv_obj_t* lv_imgbtn_create(lv_obj_t *par, const char *img, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id/*=0*/) {
-  lv_obj_t *btn = lv_imgbtn_create(par, img, cb, id);
-  lv_obj_set_pos(btn, x, y);
-  return btn;
-}
-
-lv_obj_t* lv_big_button_create(lv_obj_t *par, const char *img, const char *text, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id, bool centerLabel) {
-  lv_obj_t *btn = lv_imgbtn_create(par, img, cb, id);
-  lv_obj_set_pos(btn, x, y);
-  lv_obj_t *label = lv_label_create_empty(btn);
-  if (gCfgItems.multiple_language) {
-    lv_label_set_text(label, text);
-    if (centerLabel)
-      lv_obj_align(label, btn, LV_ALIGN_CENTER, 0, 0);
-    else
-      lv_obj_align(label, btn, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
-  }
-  if (TERN0(HAS_ROTARY_ENCODER, gCfgItems.encoder_enable))
-    lv_group_add_obj(g, btn);
-  return btn;
-}
-
-lv_obj_t* lv_screen_menu_item(lv_obj_t *par, const char *text, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id, const int index, bool drawArrow) {
-  lv_obj_t *btn = lv_btn_create(par, nullptr);   /*Add a button the current screen*/
-  lv_obj_set_pos(btn, x, y);                         /*Set its position*/
-  lv_obj_set_size(btn, PARA_UI_SIZE_X, PARA_UI_SIZE_Y);                       /*Set its size*/
-  if (id > -1) lv_obj_set_event_cb_mks(btn, cb, id, "", 0);
-  lv_btn_use_label_style(btn);
-  lv_btn_set_layout(btn, LV_LAYOUT_OFF);
-  lv_obj_t *label = lv_label_create_empty(btn);        /*Add a label to the button*/
-  if (gCfgItems.multiple_language) {
-    lv_label_set_text(label, text);
-    lv_obj_align(label, btn, LV_ALIGN_IN_LEFT_MID, 0, 0);
-  }
-  if (TERN0(HAS_ROTARY_ENCODER, gCfgItems.encoder_enable))
-    lv_group_add_obj(g, btn);
-
-  if (drawArrow) (void)lv_imgbtn_create(par, "F:/bmp_arrow.bin", x + PARA_UI_SIZE_X, y + PARA_UI_ARROW_V, cb, id);
-
-  lv_obj_t *line1 = lv_line_create(par, nullptr);
-  lv_ex_line(line1, line_points[index]);
-
-  return btn;
-}
-
-lv_obj_t* lv_screen_menu_item_1_edit(lv_obj_t *par, const char *text, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id, const int index, const char *editValue) {
-  lv_obj_t *btn = lv_screen_menu_item(par, text, x, y, cb, -1, index, false);
-  lv_obj_t *btnValue = lv_btn_create(par, PARA_UI_VALUE_POS_X, y + PARA_UI_VALUE_V, PARA_UI_VALUE_BTN_X_SIZE, PARA_UI_VALUE_BTN_Y_SIZE, cb, id);
-  lv_obj_t *labelValue = lv_label_create_empty(btnValue);
-  lv_label_set_text(labelValue, editValue);
-  lv_obj_align(labelValue, btnValue, LV_ALIGN_CENTER, 0, 0);
-  return btn;
-}
-
-lv_obj_t* lv_screen_menu_item_2_edit(lv_obj_t *par, const char *text, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id, const int index, const char *editValue, const int idEdit2, const char *editValue2) {
-  lv_obj_t *btn = lv_screen_menu_item(par, text, x, y, cb, -1, index, false);
-
-  lv_obj_t *btnValue = lv_btn_create(par, PARA_UI_VALUE_POS_X_2, y + PARA_UI_VALUE_V_2, PARA_UI_VALUE_BTN_X_SIZE, PARA_UI_VALUE_BTN_Y_SIZE, cb, idEdit2);
-  lv_obj_t *labelValue = lv_label_create_empty(btnValue);
-  lv_label_set_text(labelValue, editValue2);
-  lv_obj_align(labelValue, btnValue, LV_ALIGN_CENTER, 0, 0);
-
-  btnValue = lv_btn_create(par, PARA_UI_VALUE_POS_X, y + PARA_UI_VALUE_V, PARA_UI_VALUE_BTN_X_SIZE, PARA_UI_VALUE_BTN_Y_SIZE, cb, id);
-  labelValue = lv_label_create_empty(btnValue);
-  lv_label_set_text(labelValue, editValue);
-  lv_obj_align(labelValue, btnValue, LV_ALIGN_CENTER, 0, 0);
-
-  return btn;
-}
-
-lv_obj_t* lv_screen_menu_item_onoff(lv_obj_t *par, const char *text, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id, const int index, const bool curValue) {
-  lv_screen_menu_item(par, text, x, y, cb, -1, index, false);
-  lv_obj_t *btnValue = lv_imgbtn_create(par, curValue ? "F:/bmp_enable.bin" : "F:/bmp_disable.bin", PARA_UI_STATE_POS_X, y + PARA_UI_STATE_V, cb, id);
-  lv_obj_t *labelValue = lv_label_create_empty(btnValue);
-  lv_label_set_text(labelValue, curValue ? machine_menu.enable : machine_menu.disable);
-  lv_obj_align(labelValue, btnValue, LV_ALIGN_CENTER, 0, 0);
-  return btnValue;
-}
-
-void lv_screen_menu_item_onoff_update(lv_obj_t *btn, const bool curValue) {
-  lv_imgbtn_set_src_both(btn, curValue ? "F:/bmp_enable.bin" : "F:/bmp_disable.bin");
-  lv_label_set_text((lv_obj_t*)btn->child_ll.head, curValue ? machine_menu.enable : machine_menu.disable);
-}
-
-
-#if ENABLED(SDSUPPORT)
-
-  void sd_detection() {
-    static bool last_sd_status;
-    const bool sd_status = IS_SD_INSERTED();
-    if (sd_status != last_sd_status) {
-      last_sd_status = sd_status;
-      if (sd_status) card.mount(); else card.release();
-    }
-  }
-
-#endif
-
-void lv_ex_line(lv_obj_t *line, lv_point_t *points) {
-  // Copy the previous line and apply the new style
-  lv_line_set_points(line, points, 2);     // Set the points
-  lv_line_set_style(line, LV_LINE_STYLE_MAIN, &style_line);
-  lv_obj_align(line, nullptr, LV_ALIGN_IN_TOP_MID, 0, 0);
-}
-
-extern volatile uint32_t systick_uptime_millis;
-
-void print_time_count() {
-  if ((systick_uptime_millis % 1000) == 0)
-  if (print_time.start == 1) print_time.seconds++;
-}
-
-void LV_TASK_HANDLER() {
-  lv_task_handler();
-  if (mks_test_flag == 0x1E) mks_hardware_test();
-
-  TERN_(HAS_GCODE_PREVIEW, disp_pre_gcode(2, 36));
-
-  GUI_RefreshPage();
-
-  TERN_(MKS_WIFI_MODULE, get_wifi_commands());
-
-  #if HAS_ROTARY_ENCODER
-    if (gCfgItems.encoder_enable) lv_update_encoder();
-  #endif
-}
-
-#endif // HAS_TFT_LVGL_UI

commit 138340ee99a852bc116e2a436932bed074624fde
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Apr 13 19:34:19 2021 -0300

    Multi-Volume. Select Media for LVGL (#21344)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 51e187435c..0a99df08e5 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -447,111 +447,63 @@ char *getDispText(int index) {
   ZERO(public_buf_l);
 
   switch (disp_state_stack._disp_state[index]) {
-    case PRINT_READY_UI:
-      strcpy(public_buf_l, main_menu.title);
-      break;
-    case PRINT_FILE_UI:
-      strcpy(public_buf_l, file_menu.title);
-      break;
+    case PRINT_READY_UI:      strcpy(public_buf_l, main_menu.title); break;
+    case PRINT_FILE_UI:       strcpy(public_buf_l, file_menu.title); break;
     case PRINTING_UI:
-      if (disp_state_stack._disp_state[disp_state_stack._disp_index] == PRINTING_UI
-        #ifndef TFT35
-          || disp_state_stack._disp_state[disp_state_stack._disp_index] == OPERATE_UI
-          || disp_state_stack._disp_state[disp_state_stack._disp_index] == PAUSE_UI
-        #endif
-      )    strcpy(public_buf_l, common_menu.print_special_title);
-      else strcpy(public_buf_l, printing_menu.title);
-      break;
-    case MOVE_MOTOR_UI:
-      strcpy(public_buf_l, move_menu.title);
+      switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
+        IF_DISABLED(TFT35, case OPERATE_UI: case PAUSE_UI:)
+        case PRINTING_UI:     strcpy(public_buf_l, common_menu.print_special_title); break;
+        default:              strcpy(public_buf_l, printing_menu.title); break;
+      }
       break;
+    case MOVE_MOTOR_UI:       strcpy(public_buf_l, move_menu.title); break;
     case OPERATE_UI:
-      if (disp_state_stack._disp_state[disp_state_stack._disp_index] == PRINTING_UI
-        #ifndef TFT35
-          || disp_state_stack._disp_state[disp_state_stack._disp_index] == OPERATE_UI
-          || disp_state_stack._disp_state[disp_state_stack._disp_index] == PAUSE_UI
-        #endif
-      )    strcpy(public_buf_l, common_menu.operate_special_title);
-      else strcpy(public_buf_l, operation_menu.title);
+      switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
+        IF_DISABLED(TFT35, case OPERATE_UI: case PAUSE_UI:)
+        case PRINTING_UI:     strcpy(public_buf_l, common_menu.operate_special_title); break;
+        default:              strcpy(public_buf_l, operation_menu.title); break;
+      }
       break;
 
     case PAUSE_UI:
-      if (disp_state_stack._disp_state[disp_state_stack._disp_index] == PRINTING_UI
-        || disp_state_stack._disp_state[disp_state_stack._disp_index] == OPERATE_UI
-        || disp_state_stack._disp_state[disp_state_stack._disp_index] == PAUSE_UI
-      )    strcpy(public_buf_l, common_menu.pause_special_title);
-      else strcpy(public_buf_l, pause_menu.title);
-      break;
-
-    case EXTRUSION_UI:
-      strcpy(public_buf_l, extrude_menu.title);
-      break;
-    case CHANGE_SPEED_UI:
-      strcpy(public_buf_l, speed_menu.title);
-      break;
-    case FAN_UI:
-      strcpy(public_buf_l, fan_menu.title);
+      switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
+        case OPERATE_UI:
+        case PAUSE_UI:
+        case PRINTING_UI:     strcpy(public_buf_l, common_menu.pause_special_title); break;
+        default:              strcpy(public_buf_l, pause_menu.title); break;
+      }
       break;
+    case EXTRUSION_UI:        strcpy(public_buf_l, extrude_menu.title); break;
+    case CHANGE_SPEED_UI:     strcpy(public_buf_l, speed_menu.title); break;
+    case FAN_UI:              strcpy(public_buf_l, fan_menu.title); break;
     case PRE_HEAT_UI:
-      if ((disp_state_stack._disp_state[disp_state_stack._disp_index - 1] == OPERATE_UI))
-           strcpy(public_buf_l, preheat_menu.adjust_title);
-      else strcpy(public_buf_l, preheat_menu.title);
-      break;
-    case SET_UI:
-      strcpy(public_buf_l, set_menu.title);
-      break;
-    case ZERO_UI:
-      strcpy(public_buf_l, home_menu.title);
-      break;
-    case SPRAYER_UI: break;
-    case MACHINE_UI: break;
-    case LANGUAGE_UI:
-      strcpy(public_buf_l, language_menu.title);
-      break;
-    case ABOUT_UI:
-      strcpy(public_buf_l, about_menu.title);
-      break;
-    case LOG_UI: break;
-    case DISK_UI:
-      strcpy(public_buf_l, filesys_menu.title);
-      break;
-    case DIALOG_UI:
-      strcpy(public_buf_l, common_menu.dialog_confirm_title);
-      break;
-    case WIFI_UI:
-      strcpy(public_buf_l, wifi_menu.title);
+      switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
+        case OPERATE_UI:      strcpy(public_buf_l, preheat_menu.adjust_title);
+        default:              strcpy(public_buf_l, preheat_menu.title); break;
+      }
       break;
+    case SET_UI:              strcpy(public_buf_l, set_menu.title); break;
+    case ZERO_UI:             strcpy(public_buf_l, home_menu.title); break;
+    case SPRAYER_UI:          break;
+    case MACHINE_UI:          break;
+    case LANGUAGE_UI:         strcpy(public_buf_l, language_menu.title); break;
+    case ABOUT_UI:            strcpy(public_buf_l, about_menu.title); break;
+    case LOG_UI:              break;
+    case DISK_UI:             strcpy(public_buf_l, filesys_menu.title); break;
+    case DIALOG_UI:           strcpy(public_buf_l, common_menu.dialog_confirm_title); break;
+    case WIFI_UI:             strcpy(public_buf_l, wifi_menu.title); break;
     case MORE_UI:
-    case PRINT_MORE_UI:
-      strcpy(public_buf_l, more_menu.title);
-      break;
-    case FILAMENTCHANGE_UI:
-      strcpy(public_buf_l, filament_menu.title);
-      break;
+    case PRINT_MORE_UI:       strcpy(public_buf_l, more_menu.title); break;
+    case FILAMENTCHANGE_UI:   strcpy(public_buf_l, filament_menu.title); break;
     case LEVELING_UI:
-    case MESHLEVELING_UI:
-      strcpy(public_buf_l, leveling_menu.title);
-      break;
-    case BIND_UI:
-      strcpy(public_buf_l, cloud_menu.title);
-      break;
-    case TOOL_UI:
-      strcpy(public_buf_l, tool_menu.title);
-      break;
-    case WIFI_LIST_UI:
-      #if ENABLED(MKS_WIFI_MODULE)
-        strcpy(public_buf_l, list_menu.title);
-        break;
-      #endif
-    case MACHINE_PARA_UI:
-      strcpy(public_buf_l, MachinePara_menu.title);
-      break;
-    case BABY_STEP_UI:
-      strcpy(public_buf_l, operation_menu.babystep);
-      break;
-    case EEPROM_SETTINGS_UI:
-      strcpy(public_buf_l, eeprom_menu.title);
-      break;
+    case MESHLEVELING_UI:     strcpy(public_buf_l, leveling_menu.title); break;
+    case BIND_UI:             strcpy(public_buf_l, cloud_menu.title); break;
+    case TOOL_UI:             strcpy(public_buf_l, tool_menu.title); break;
+    case WIFI_LIST_UI:        TERN_(MKS_WIFI_MODULE, strcpy(public_buf_l, list_menu.title)); break;
+    case MACHINE_PARA_UI:     strcpy(public_buf_l, MachinePara_menu.title); break;
+    case BABY_STEP_UI:        strcpy(public_buf_l, operation_menu.babystep); break;
+    case EEPROM_SETTINGS_UI:  strcpy(public_buf_l, eeprom_menu.title); break;
+    case MEDIA_SELECT_UI:     strcpy(public_buf_l, media_select_menu.title); break;
     default: break;
   }
 
@@ -828,11 +780,9 @@ void GUI_RefreshPage() {
       }
       break;
 
-    case OPERATE_UI:
-      break;
+    case OPERATE_UI: break;
 
-    case PAUSE_UI:
-      break;
+    case PAUSE_UI: break;
 
     case FAN_UI:
       if (temps_update_flag) {
@@ -841,8 +791,7 @@ void GUI_RefreshPage() {
       }
       break;
 
-    case MOVE_MOTOR_UI:
-      break;
+    case MOVE_MOTOR_UI: break;
 
     #if ENABLED(MKS_WIFI_MODULE)
       case WIFI_UI:
@@ -852,10 +801,9 @@ void GUI_RefreshPage() {
         }
         break;
 
-      case BIND_UI:
-        refresh_bind_ui();
-        break;
+      case BIND_UI: refresh_bind_ui(); break;
     #endif
+
     case FILAMENTCHANGE_UI:
       if (temps_update_flag) {
         temps_update_flag = false;
@@ -866,10 +814,8 @@ void GUI_RefreshPage() {
       filament_dialog_handle();
       TERN_(MKS_WIFI_MODULE, wifi_scan_handle());
       break;
-    case MESHLEVELING_UI:
-      break;
-    case HARDWARE_TEST_UI:
-      break;
+    case MESHLEVELING_UI: break;
+    case HARDWARE_TEST_UI: break;
     case WIFI_LIST_UI:
       #if ENABLED(MKS_WIFI_MODULE)
         if (printing_rate_update_flag) {
@@ -878,8 +824,8 @@ void GUI_RefreshPage() {
         }
       #endif
       break;
-    case KEY_BOARD_UI:
-      break;
+    case KEYBOARD_UI: break;
+
     #if ENABLED(MKS_WIFI_MODULE)
       case WIFI_TIPS_UI:
         switch (wifi_tips_type) {
@@ -932,6 +878,7 @@ void GUI_RefreshPage() {
         disp_z_offset_value();
       }
       break;
+
     default: break;
   }
 
@@ -982,7 +929,7 @@ void clear_cur_ui() {
     #if ENABLED(MKS_WIFI_MODULE)
       case WIFI_LIST_UI:              lv_clear_wifi_list(); break;
     #endif
-    case KEY_BOARD_UI:                lv_clear_keyboard(); break;
+    case KEYBOARD_UI:                 lv_clear_keyboard(); break;
     #if ENABLED(MKS_WIFI_MODULE)
       case WIFI_TIPS_UI:              lv_clear_wifi_tips(); break;
     #endif
@@ -1013,9 +960,9 @@ void clear_cur_ui() {
     case NUMBER_KEY_UI:               lv_clear_number_key(); break;
     case BABY_STEP_UI:                lv_clear_baby_stepping(); break;
     case PAUSE_POS_UI:                lv_clear_pause_position(); break;
-      #if HAS_TRINAMIC_CONFIG
-        case TMC_CURRENT_UI:          lv_clear_tmc_current_settings(); break;
-      #endif
+    #if HAS_TRINAMIC_CONFIG
+      case TMC_CURRENT_UI:            lv_clear_tmc_current_settings(); break;
+    #endif
     case EEPROM_SETTINGS_UI:          lv_clear_eeprom_settings(); break;
     #if HAS_STEALTHCHOP
       case TMC_MODE_UI:               lv_clear_tmc_step_mode_settings(); break;
@@ -1032,6 +979,9 @@ void clear_cur_ui() {
     #if ENABLED(TOUCH_SCREEN_CALIBRATION)
       case TOUCH_CALIBRATION_UI:      lv_clear_touch_calibration_screen(); break;
     #endif
+    #if ENABLED(MULTI_VOLUME)
+      case MEDIA_SELECT_UI:           lv_clear_media_select(); break;
+    #endif
     default: break;
   }
 }
@@ -1087,7 +1037,7 @@ void draw_return_ui() {
       #if ENABLED(MKS_WIFI_MODULE)
         case WIFI_LIST_UI:              lv_draw_wifi_list(); break;
       #endif
-      case KEY_BOARD_UI:                lv_draw_keyboard(); break;
+      case KEYBOARD_UI:                 lv_draw_keyboard(); break;
       #if ENABLED(MKS_WIFI_MODULE)
         case WIFI_TIPS_UI:              lv_draw_wifi_tips(); break;
       #endif

commit e0ed57db67ff191452f00808dc696c80dd8e03f7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 12 23:40:32 2021 -0500

    Remove extraneous MKS UI sprintf

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 68baea30c7..51e187435c 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -125,16 +125,16 @@ void gCfgItems_init() {
   gCfgItems.pausePosX         = -1;
   gCfgItems.pausePosY         = -1;
   gCfgItems.pausePosZ         = 5;
-  gCfgItems.trammingPos[0][X_AXIS] = X_MIN_POS + 30;
-  gCfgItems.trammingPos[0][Y_AXIS] = Y_MIN_POS + 30;
-  gCfgItems.trammingPos[1][X_AXIS] = X_MAX_POS - 30;
-  gCfgItems.trammingPos[1][Y_AXIS] = Y_MIN_POS + 30;
-  gCfgItems.trammingPos[2][X_AXIS] = X_MAX_POS - 30;
-  gCfgItems.trammingPos[2][Y_AXIS] = Y_MAX_POS - 30;
-  gCfgItems.trammingPos[3][X_AXIS] = X_MIN_POS + 30;
-  gCfgItems.trammingPos[3][Y_AXIS] = Y_MAX_POS - 30;
-  gCfgItems.trammingPos[4][X_AXIS] = X_BED_SIZE / 2;
-  gCfgItems.trammingPos[4][Y_AXIS] = Y_BED_SIZE / 2;
+  gCfgItems.trammingPos[0].x  = X_MIN_POS + 30;
+  gCfgItems.trammingPos[0].y  = Y_MIN_POS + 30;
+  gCfgItems.trammingPos[1].x  = X_MAX_POS - 30;
+  gCfgItems.trammingPos[1].y  = Y_MIN_POS + 30;
+  gCfgItems.trammingPos[2].x  = X_MAX_POS - 30;
+  gCfgItems.trammingPos[2].y  = Y_MAX_POS - 30;
+  gCfgItems.trammingPos[3].x  = X_MIN_POS + 30;
+  gCfgItems.trammingPos[3].y  = Y_MAX_POS - 30;
+  gCfgItems.trammingPos[4].x  = X_BED_SIZE / 2;
+  gCfgItems.trammingPos[4].y  = Y_BED_SIZE / 2;
   gCfgItems.cloud_enable      = false;
   gCfgItems.wifi_mode_sel = STA_MODEL;
   gCfgItems.fileSysType   = FILE_SYS_SD;

commit c2b72c0e73a59c7b0915253c775eb6253032f0b0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 2 14:22:43 2021 -0500

    Remove extraneous 'extern' hints (#21516)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index e65ba788f5..68baea30c7 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -72,7 +72,7 @@ extern bool once_flag;
 extern uint8_t sel_id;
 extern lv_group_t *g;
 
-extern void LCD_IO_WriteData(uint16_t RegValue);
+void LCD_IO_WriteData(uint16_t RegValue);
 
 static const char custom_gcode_command[][100] = {
   "G29N\nM500",

commit 3b73b115ca9366f0155986b717d4c85c31ed2f80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 29 20:36:37 2021 -0500

    Apply pointer formatting

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 8d560a19a4..e65ba788f5 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -649,7 +649,7 @@ char *creat_title_text() {
       if (gPicturePreviewStart <= 0) {
         while (1) {
           uint32_t br  = card.read(public_buf, 400);
-          uint32_t* p1 = (uint32_t *)strstr((char *)public_buf, ";gimage:");
+          uint32_t *p1 = (uint32_t *)strstr((char *)public_buf, ";gimage:");
           if (p1) {
             gPicturePreviewStart += (uint32_t)p1 - (uint32_t)((uint32_t *)(&public_buf[0]));
             break;
@@ -1173,7 +1173,7 @@ void lv_btn_set_style_both(lv_obj_t *btn, lv_style_t *style) {
 }
 
 // Create a screen
-lv_obj_t* lv_screen_create(DISP_STATE newScreenType, const char* title) {
+lv_obj_t* lv_screen_create(DISP_STATE newScreenType, const char *title) {
   lv_obj_t *scr = lv_obj_create(nullptr, nullptr);
   lv_obj_set_style(scr, &tft_style_scr);
   lv_scr_load(scr);
@@ -1348,19 +1348,19 @@ lv_obj_t* lv_screen_menu_item(lv_obj_t *par, const char *text, lv_coord_t x, lv_
 }
 
 lv_obj_t* lv_screen_menu_item_1_edit(lv_obj_t *par, const char *text, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id, const int index, const char *editValue) {
-  lv_obj_t* btn = lv_screen_menu_item(par, text, x, y, cb, -1, index, false);
-  lv_obj_t* btnValue = lv_btn_create(par, PARA_UI_VALUE_POS_X, y + PARA_UI_VALUE_V, PARA_UI_VALUE_BTN_X_SIZE, PARA_UI_VALUE_BTN_Y_SIZE, cb, id);
-  lv_obj_t* labelValue = lv_label_create_empty(btnValue);
+  lv_obj_t *btn = lv_screen_menu_item(par, text, x, y, cb, -1, index, false);
+  lv_obj_t *btnValue = lv_btn_create(par, PARA_UI_VALUE_POS_X, y + PARA_UI_VALUE_V, PARA_UI_VALUE_BTN_X_SIZE, PARA_UI_VALUE_BTN_Y_SIZE, cb, id);
+  lv_obj_t *labelValue = lv_label_create_empty(btnValue);
   lv_label_set_text(labelValue, editValue);
   lv_obj_align(labelValue, btnValue, LV_ALIGN_CENTER, 0, 0);
   return btn;
 }
 
 lv_obj_t* lv_screen_menu_item_2_edit(lv_obj_t *par, const char *text, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id, const int index, const char *editValue, const int idEdit2, const char *editValue2) {
-  lv_obj_t* btn = lv_screen_menu_item(par, text, x, y, cb, -1, index, false);
+  lv_obj_t *btn = lv_screen_menu_item(par, text, x, y, cb, -1, index, false);
 
-  lv_obj_t* btnValue = lv_btn_create(par, PARA_UI_VALUE_POS_X_2, y + PARA_UI_VALUE_V_2, PARA_UI_VALUE_BTN_X_SIZE, PARA_UI_VALUE_BTN_Y_SIZE, cb, idEdit2);
-  lv_obj_t* labelValue = lv_label_create_empty(btnValue);
+  lv_obj_t *btnValue = lv_btn_create(par, PARA_UI_VALUE_POS_X_2, y + PARA_UI_VALUE_V_2, PARA_UI_VALUE_BTN_X_SIZE, PARA_UI_VALUE_BTN_Y_SIZE, cb, idEdit2);
+  lv_obj_t *labelValue = lv_label_create_empty(btnValue);
   lv_label_set_text(labelValue, editValue2);
   lv_obj_align(labelValue, btnValue, LV_ALIGN_CENTER, 0, 0);
 
@@ -1374,8 +1374,8 @@ lv_obj_t* lv_screen_menu_item_2_edit(lv_obj_t *par, const char *text, lv_coord_t
 
 lv_obj_t* lv_screen_menu_item_onoff(lv_obj_t *par, const char *text, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id, const int index, const bool curValue) {
   lv_screen_menu_item(par, text, x, y, cb, -1, index, false);
-  lv_obj_t* btnValue = lv_imgbtn_create(par, curValue ? "F:/bmp_enable.bin" : "F:/bmp_disable.bin", PARA_UI_STATE_POS_X, y + PARA_UI_STATE_V, cb, id);
-  lv_obj_t* labelValue = lv_label_create_empty(btnValue);
+  lv_obj_t *btnValue = lv_imgbtn_create(par, curValue ? "F:/bmp_enable.bin" : "F:/bmp_disable.bin", PARA_UI_STATE_POS_X, y + PARA_UI_STATE_V, cb, id);
+  lv_obj_t *labelValue = lv_label_create_empty(btnValue);
   lv_label_set_text(labelValue, curValue ? machine_menu.enable : machine_menu.disable);
   lv_obj_align(labelValue, btnValue, LV_ALIGN_CENTER, 0, 0);
   return btnValue;

commit a335cf2edf66db08ab12d3800784b58ad992f6a9
Author: Malderin <52313714+Malderin@users.noreply.github.com>
Date:   Mon Mar 29 11:19:38 2021 +0300

    Fix MKS LVGL UI Main screen / print buttons (#21468)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 0c574b1e15..8d560a19a4 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -805,6 +805,10 @@ void GUI_RefreshPage() {
       }
       break;
     case PRINT_READY_UI:
+      if (temps_update_flag) {
+        temps_update_flag = false;
+        lv_temp_refr();
+      }
       break;
 
     case PRINT_FILE_UI: break;
@@ -843,8 +847,8 @@ void GUI_RefreshPage() {
     #if ENABLED(MKS_WIFI_MODULE)
       case WIFI_UI:
         if (temps_update_flag) {
-          disp_wifi_state();
           temps_update_flag = false;
+          disp_wifi_state();
         }
         break;
 

commit 8fca37f3737e66150c1ed5b5793e2c48dd108b23
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 23 23:54:23 2021 -0500

    Misc LCD cleanup

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 12e060aa01..0c574b1e15 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -125,16 +125,16 @@ void gCfgItems_init() {
   gCfgItems.pausePosX         = -1;
   gCfgItems.pausePosY         = -1;
   gCfgItems.pausePosZ         = 5;
-  gCfgItems.levelingPos[0][0] = X_MIN_POS + 30;
-  gCfgItems.levelingPos[0][1] = Y_MIN_POS + 30;
-  gCfgItems.levelingPos[1][0] = X_MAX_POS - 30;
-  gCfgItems.levelingPos[1][1] = Y_MIN_POS + 30;
-  gCfgItems.levelingPos[2][0] = X_MAX_POS - 30;
-  gCfgItems.levelingPos[2][1] = Y_MAX_POS - 30;
-  gCfgItems.levelingPos[3][0] = X_MIN_POS + 30;
-  gCfgItems.levelingPos[3][1] = Y_MAX_POS - 30;
-  gCfgItems.levelingPos[4][0] = X_BED_SIZE / 2;
-  gCfgItems.levelingPos[4][1] = Y_BED_SIZE / 2;
+  gCfgItems.trammingPos[0][X_AXIS] = X_MIN_POS + 30;
+  gCfgItems.trammingPos[0][Y_AXIS] = Y_MIN_POS + 30;
+  gCfgItems.trammingPos[1][X_AXIS] = X_MAX_POS - 30;
+  gCfgItems.trammingPos[1][Y_AXIS] = Y_MIN_POS + 30;
+  gCfgItems.trammingPos[2][X_AXIS] = X_MAX_POS - 30;
+  gCfgItems.trammingPos[2][Y_AXIS] = Y_MAX_POS - 30;
+  gCfgItems.trammingPos[3][X_AXIS] = X_MIN_POS + 30;
+  gCfgItems.trammingPos[3][Y_AXIS] = Y_MAX_POS - 30;
+  gCfgItems.trammingPos[4][X_AXIS] = X_BED_SIZE / 2;
+  gCfgItems.trammingPos[4][Y_AXIS] = Y_BED_SIZE / 2;
   gCfgItems.cloud_enable      = false;
   gCfgItems.wifi_mode_sel = STA_MODEL;
   gCfgItems.fileSysType   = FILE_SYS_SD;
@@ -994,7 +994,7 @@ void clear_cur_ui() {
     case LEVELING_SETTIGNS_UI:        break;
     case LEVELING_PARA_UI:            lv_clear_level_settings(); break;
     case DELTA_LEVELING_PARA_UI:      break;
-    case MANUAL_LEVELING_POSIGION_UI: lv_clear_manual_level_pos_settings(); break;
+    case MANUAL_LEVELING_POSIGION_UI: lv_clear_tramming_pos_settings(); break;
     case MAXFEEDRATE_UI:              lv_clear_max_feedrate_settings(); break;
     case STEPS_UI:                    lv_clear_step_settings(); break;
     case ACCELERATION_UI:             lv_clear_acceleration_settings(); break;
@@ -1099,7 +1099,7 @@ void draw_return_ui() {
       case LEVELING_SETTIGNS_UI:        break;
       case LEVELING_PARA_UI:            lv_draw_level_settings(); break;
       case DELTA_LEVELING_PARA_UI:      break;
-      case MANUAL_LEVELING_POSIGION_UI: lv_draw_manual_level_pos_settings(); break;
+      case MANUAL_LEVELING_POSIGION_UI: lv_draw_tramming_pos_settings(); break;
       case MAXFEEDRATE_UI:              lv_draw_max_feedrate_settings(); break;
       case STEPS_UI:                    lv_draw_step_settings(); break;
       case ACCELERATION_UI:             lv_draw_acceleration_settings(); break;

commit 58f0330d3f51115dbc8cda792105fe66d4c61241
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 19 16:41:47 2021 -0500

    MKS / E3V2 LCD code cleanup

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 9b7fea0a45..12e060aa01 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -143,7 +143,7 @@ void gCfgItems_init() {
   gCfgItems.filamentchange_load_speed    = 1000;
   gCfgItems.filamentchange_unload_length = 200;
   gCfgItems.filamentchange_unload_speed  = 1000;
-  gCfgItems.filament_limit_temper        = 200;
+  gCfgItems.filament_limit_temp          = 200;
 
   gCfgItems.encoder_enable = true;
 
@@ -226,8 +226,8 @@ void ui_cfg_init() {
     uiCfg.cloud_port = 10086;
   #endif
 
-  uiCfg.filament_loading_time = (uint32_t)((gCfgItems.filamentchange_load_length * 60.0 / gCfgItems.filamentchange_load_speed) + 0.5);
-  uiCfg.filament_unloading_time = (uint32_t)((gCfgItems.filamentchange_unload_length * 60.0 / gCfgItems.filamentchange_unload_speed) + 0.5);
+  uiCfg.filament_loading_time = (uint32_t)((gCfgItems.filamentchange_load_length * 60.0f / gCfgItems.filamentchange_load_speed) + 0.5f);
+  uiCfg.filament_unloading_time = (uint32_t)((gCfgItems.filamentchange_unload_length * 60.0f / gCfgItems.filamentchange_unload_speed) + 0.5f);
 }
 
 void update_spi_flash() {

commit 72cc5a49e6fdcf7246b6bded66a4b4fc043054a3
Author: Sola <42537573+solawc@users.noreply.github.com>
Date:   Sat Mar 6 23:04:05 2021 +0800

    MKS H43 fixup (#21267)
    
    Co-authored-by: makerbase <4164049@qq.com>
    Co-authored-by: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 9d13ca3120..9b7fea0a45 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -179,7 +179,7 @@ void gCfgItems_init() {
 
 void ui_cfg_init() {
   uiCfg.curTempType         = 0;
-  uiCfg.curSprayerChoose    = 0;
+  uiCfg.extruderIndex       = 0;
   uiCfg.stepHeat            = 10;
   uiCfg.leveling_first_time = false;
   uiCfg.para_ui_page        = false;

commit c74f972627ab8dcf69a637268cf86682959bd18e
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 1 01:18:39 2021 +0100

    LVGL UI G-code console (#20755)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 84049d51ab..9d13ca3120 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -1077,6 +1077,7 @@ void draw_return_ui() {
         case NOZZLE_PROBE_OFFSET_UI:    lv_draw_auto_level_offset_settings(); break;
       #endif
       case TOOL_UI:                     lv_draw_tool(); break;
+      case GCODE_UI:                    lv_draw_gcode(); break;
       case MESHLEVELING_UI:             break;
       case HARDWARE_TEST_UI:            break;
       #if ENABLED(MKS_WIFI_MODULE)

commit 9d0e64a725290233d6002017147c578ffd32c504
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 28 20:40:20 2021 -0600

    AutoReport class (Temperature, Cardreader) (#20913)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 88e6fab07c..84049d51ab 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -889,7 +889,7 @@ void GUI_RefreshPage() {
               lv_draw_wifi_tips();
 
             }
-            if (tips_disp.timer_count >= 30 * 1000) {
+            if (tips_disp.timer_count >= SEC_TO_MS(30)) {
               tips_disp.timer = TIPS_TIMER_STOP;
               tips_disp.timer_count = 0;
               lv_clear_wifi_tips();
@@ -898,7 +898,7 @@ void GUI_RefreshPage() {
             }
             break;
           case TIPS_TYPE_TAILED_JOIN:
-            if (tips_disp.timer_count >= 3 * 1000) {
+            if (tips_disp.timer_count >= SEC_TO_MS(3)) {
               tips_disp.timer = TIPS_TIMER_STOP;
               tips_disp.timer_count = 0;
 
@@ -908,7 +908,7 @@ void GUI_RefreshPage() {
             }
             break;
           case TIPS_TYPE_WIFI_CONECTED:
-            if (tips_disp.timer_count >= 3 * 1000) {
+            if (tips_disp.timer_count >= SEC_TO_MS(3)) {
               tips_disp.timer = TIPS_TIMER_STOP;
               tips_disp.timer_count = 0;
 

commit bb597dcf66ac0baa3f3528bb34c3b4aad78ad520
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 17 12:08:40 2021 -0600

    Internal G29N for G28+G29 (#20800)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 8abedfe0d8..88e6fab07c 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -75,7 +75,7 @@ extern lv_group_t *g;
 extern void LCD_IO_WriteData(uint16_t RegValue);
 
 static const char custom_gcode_command[][100] = {
-  "G28\nG29\nM500",
+  "G29N\nM500",
   "G28",
   "G28",
   "G28",

commit 40c8f2001d2274dd34868d2e83ba65a09bcfba17
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 16 20:43:46 2021 -0600

    Apply bool to some MKS UI

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 50282536e6..8abedfe0d8 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -181,22 +181,22 @@ void ui_cfg_init() {
   uiCfg.curTempType         = 0;
   uiCfg.curSprayerChoose    = 0;
   uiCfg.stepHeat            = 10;
-  uiCfg.leveling_first_time = 0;
-  uiCfg.para_ui_page        = 0;
+  uiCfg.leveling_first_time = false;
+  uiCfg.para_ui_page        = false;
   uiCfg.extruStep           = 5;
   uiCfg.extruSpeed          = 10;
   uiCfg.move_dist           = 1;
   uiCfg.moveSpeed           = 3000;
   uiCfg.stepPrintSpeed      = 10;
-  uiCfg.command_send        = 0;
+  uiCfg.command_send        = false;
   uiCfg.dialogType          = 0;
-  uiCfg.filament_heat_completed_load = 0;
+  uiCfg.filament_heat_completed_load = false;
   uiCfg.filament_rate                = 0;
-  uiCfg.filament_loading_completed   = 0;
-  uiCfg.filament_unloading_completed = 0;
-  uiCfg.filament_loading_time_flg    = 0;
+  uiCfg.filament_loading_completed   = false;
+  uiCfg.filament_unloading_completed = false;
+  uiCfg.filament_loading_time_flg    = false;
   uiCfg.filament_loading_time_cnt    = 0;
-  uiCfg.filament_unloading_time_flg  = 0;
+  uiCfg.filament_unloading_time_flg  = false;
   uiCfg.filament_unloading_time_cnt  = 0;
 
   #if ENABLED(MKS_WIFI_MODULE)

commit c753fc690f6cdd181213304224eee029988ffd34
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 14 00:23:56 2021 -0600

    More MKS UI prelim. cleanup

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index bb6e9419f0..50282536e6 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -72,9 +72,6 @@ extern bool once_flag;
 extern uint8_t sel_id;
 extern lv_group_t *g;
 
-extern uint8_t bmp_public_buf[14 * 1024];
-extern uint8_t public_buf[513];
-
 extern void LCD_IO_WriteData(uint16_t RegValue);
 
 static const char custom_gcode_command[][100] = {

commit 35c1b330ec62e698a455176330e7d75600af461d
Author: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
Date:   Thu Jan 14 12:41:09 2021 +0800

    MKS WiFi for TFT_LVGL_UI (#20191)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index ffbaba4ea5..bb6e9419f0 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -138,12 +138,10 @@ void gCfgItems_init() {
   gCfgItems.levelingPos[3][1] = Y_MAX_POS - 30;
   gCfgItems.levelingPos[4][0] = X_BED_SIZE / 2;
   gCfgItems.levelingPos[4][1] = Y_BED_SIZE / 2;
-  gCfgItems.cloud_enable  = true;
-  #if ENABLED(MKS_WIFI_MODULE)
-    gCfgItems.wifi_mode_sel = STA_MODEL;
-    gCfgItems.fileSysType   = FILE_SYS_SD;
-    gCfgItems.wifi_type     = ESP_WIFI;
-  #endif
+  gCfgItems.cloud_enable      = false;
+  gCfgItems.wifi_mode_sel = STA_MODEL;
+  gCfgItems.fileSysType   = FILE_SYS_SD;
+  gCfgItems.wifi_type     = ESP_WIFI;
   gCfgItems.filamentchange_load_length   = 200;
   gCfgItems.filamentchange_load_speed    = 1000;
   gCfgItems.filamentchange_unload_length = 200;
@@ -449,6 +447,7 @@ void titleText_cat(char *str, int strSize, char *addPart) {
 
 char *getDispText(int index) {
 
+  ZERO(public_buf_l);
 
   switch (disp_state_stack._disp_state[index]) {
     case PRINT_READY_UI:
@@ -593,7 +592,9 @@ char *creat_title_text() {
 
   if (strlen(public_buf_m) > MAX_TITLE_LEN) {
     ZERO(public_buf_m);
-    tmpText = getDispText(0);
+    tmpText = 0;
+    for (index = 0; index <= disp_state_stack._disp_index && (!tmpText || *tmpText == 0); index++)
+      tmpText = getDispText(index);
     if (*tmpText != 0) {
       titleText_cat(public_buf_m, sizeof(public_buf_m), tmpText);
       titleText_cat(public_buf_m, sizeof(public_buf_m), (char *)">...>");
@@ -639,253 +640,97 @@ char *creat_title_text() {
     #endif
   }
 
-  #if 1
-
-    void gcode_preview(char *path, int xpos_pixel, int ypos_pixel) {
-      #if ENABLED(SDSUPPORT)
-        //uint8_t ress;
-        //uint32_t write;
-        volatile uint32_t i, j;
-        volatile uint16_t *p_index;
-        //int res;
-        char *cur_name;
-
-        cur_name = strrchr(path, '/');
-        card.openFileRead(cur_name);
-
-        if (gPicturePreviewStart <= 0) {
-          while (1) {
-            uint32_t br  = card.read(public_buf, 400);
-            uint32_t* p1 = (uint32_t *)strstr((char *)public_buf, ";gimage:");
-            if (p1) {
-              gPicturePreviewStart += (uint32_t)p1 - (uint32_t)((uint32_t *)(&public_buf[0]));
-              break;
-            }
-            else {
-              gPicturePreviewStart += br;
-            }
-            if (br < 400) break;
-          }
-        }
-
-        card.setIndex((gPicturePreviewStart + To_pre_view) + size * row + 8);
-        SPI_TFT.setWindow(xpos_pixel, ypos_pixel + row, 200, 1);
+  void gcode_preview(char *path, int xpos_pixel, int ypos_pixel) {
+    #if ENABLED(SDSUPPORT)
+      volatile uint32_t i, j;
+      volatile uint16_t *p_index;
+      char *cur_name;
 
-        j = i = 0;
+      cur_name = strrchr(path, '/');
+      card.openFileRead(cur_name);
 
+      if (gPicturePreviewStart <= 0) {
         while (1) {
-          card.read(public_buf, 400);
-          for (i = 0; i < 400;) {
-            bmp_public_buf[j] = ascii2dec_test((char*)&public_buf[i]) << 4 | ascii2dec_test((char*)&public_buf[i + 1]);
-            i                += 2;
-            j++;
-          }
-          if (j >= 400) break;
-        }
-        for (i = 0; i < 400; i += 2) {
-          p_index  = (uint16_t *)(&bmp_public_buf[i]);
-          if (*p_index == 0x0000) *p_index = LV_COLOR_BACKGROUND.full;
-        }
-        SPI_TFT.tftio.WriteSequence((uint16_t*)bmp_public_buf, 200);
-        #if HAS_BAK_VIEW_IN_FLASH
-          W25QXX.init(SPI_QUARTER_SPEED);
-          if (row < 20) W25QXX.SPI_FLASH_SectorErase(BAK_VIEW_ADDR_TFT35 + row * 4096);
-          W25QXX.SPI_FLASH_BufferWrite(bmp_public_buf, BAK_VIEW_ADDR_TFT35 + row * 400, 400);
-        #endif
-        row++;
-        if (row >= 200) {
-          size = 809;
-          row  = 0;
-
-          gcode_preview_over = false;
-          //flash_preview_begin = true;
-
-          card.closefile();
-
-          /*
-          if (gCurFileState.file_open_flag != 0xAA) {
-            reset_file_info();
-            res = f_open(file, curFileName, FA_OPEN_EXISTING | FA_READ);
-            if (res == FR_OK) {
-              f_lseek(file,PREVIEW_SIZE+To_pre_view);
-              gCurFileState.file_open_flag = 0xAA;
-              //bakup_file_path((uint8_t *)curFileName, strlen(curFileName));
-              srcfp = file;
-              mksReprint.mks_printer_state = MKS_WORKING;
-              once_flag = false;
-            }
-          }
-          */
-          char *cur_name;
-
-          cur_name = strrchr(list_file.file_name[sel_id], '/');
-
-          SdFile file;
-          SdFile *curDir;
-          card.endFilePrint();
-          const char * const fname = card.diveToFile(true, curDir, cur_name);
-          if (!fname) return;
-          if (file.open(curDir, fname, O_READ)) {
-            gCfgItems.curFilesize = file.fileSize();
-            file.close();
-            update_spi_flash();
+          uint32_t br  = card.read(public_buf, 400);
+          uint32_t* p1 = (uint32_t *)strstr((char *)public_buf, ";gimage:");
+          if (p1) {
+            gPicturePreviewStart += (uint32_t)p1 - (uint32_t)((uint32_t *)(&public_buf[0]));
+            break;
           }
-
-          card.openFileRead(cur_name);
-          if (card.isFileOpen()) {
-            feedrate_percentage = 100;
-            //saved_feedrate_percentage = feedrate_percentage;
-            planner.flow_percentage[0] = 100;
-            planner.e_factor[0]        = planner.flow_percentage[0] * 0.01;
-            #if HAS_MULTI_EXTRUDER
-              planner.flow_percentage[1] = 100;
-              planner.e_factor[1]        = planner.flow_percentage[1] * 0.01;
-            #endif
-            card.startFileprint();
-            TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
-            once_flag = false;
+          else {
+            gPicturePreviewStart += br;
           }
-          return;
+          if (br < 400) break;
         }
-        card.closefile();
-      #endif // SDSUPPORT
-    }
-
-  #else // if 1
-
-    void gcode_preview(char *path, int xpos_pixel, int ypos_pixel) {
-      #if ENABLED(SDSUPPORT)
-        //uint8_t ress;
-        //uint32_t write;
-        volatile uint32_t i, j;
-        volatile uint16_t *p_index;
-        //int res;
-        char *cur_name;
-        uint16_t Color;
-
-        cur_name = strrchr(path, '/');
-        card.openFileRead(cur_name);
-
-        card.setIndex((PREVIEW_LITTLE_PIC_SIZE + To_pre_view) + size * row + 8);
-        #if HAS_TFT_LVGL_UI_SPI
-          SPI_TFT.setWindow(xpos_pixel, ypos_pixel + row, 200, 1);
-        #else
-          LCD_setWindowArea(xpos_pixel, ypos_pixel + row, 200, 1);
-          LCD_WriteRAM_Prepare();
-        #endif
-
-        j = 0;
-        i = 0;
+      }
 
-        while (1) {
-          card.read(public_buf, 400);
-          for (i = 0; i < 400;) {
-            bmp_public_buf[j] = ascii2dec_test((char*)&public_buf[i]) << 4 | ascii2dec_test((char*)&public_buf[i + 1]);
-            i += 2;
-            j++;
-          }
+      card.setIndex(gPicturePreviewStart + size * row + 8);
+      SPI_TFT.setWindow(xpos_pixel, ypos_pixel + row, 200, 1);
 
-          //if (i > 800) break;
-          //#ifdef TFT70
-          //  if (j > 400) {
-          //    f_read(file, buff_pic, 1, &read);
-          //    break;
-          //  }
-          //#elif defined(TFT35)
-          if (j >= 400)
-            //f_read(file, buff_pic, 1, &read);
-            break;
-          //#endif
+      j = i = 0;
 
+      while (1) {
+        card.read(public_buf, 400);
+        for (i = 0; i < 400;) {
+          bmp_public_buf[j] = ascii2dec_test((char*)&public_buf[i]) << 4 | ascii2dec_test((char*)&public_buf[i + 1]);
+          i                += 2;
+          j++;
         }
-        #if HAS_TFT_LVGL_UI_SPI
-          for (i = 0; i < 400;) {
-            p_index = (uint16_t *)(&bmp_public_buf[i]);
-
-            Color    = (*p_index >> 8);
-            *p_index = Color | ((*p_index & 0xFF) << 8);
-            i       += 2;
-            if (*p_index == 0x0000) *p_index = 0xC318;
-          }
-          TFT_CS_L;
-          TFT_DC_H;
-          SPI.dmaSend(bmp_public_buf, 400, true);
-          TFT_CS_H;
-
-        #else
-          for (i = 0; i < 400;) {
-            p_index = (uint16_t *)(&bmp_public_buf[i]);
-            if (*p_index == 0x0000) *p_index = 0x18C3;
-            LCD_IO_WriteData(*p_index);
-            i = i + 2;
-          }
-        #endif
+        if (j >= 400) break;
+      }
+      for (i = 0; i < 400; i += 2) {
+        p_index  = (uint16_t *)(&bmp_public_buf[i]);
+        if (*p_index == 0x0000) *p_index = LV_COLOR_BACKGROUND.full;
+      }
+      SPI_TFT.tftio.WriteSequence((uint16_t*)bmp_public_buf, 200);
+      #if HAS_BAK_VIEW_IN_FLASH
         W25QXX.init(SPI_QUARTER_SPEED);
-        if (row < 20)
-          W25QXX.SPI_FLASH_SectorErase(BAK_VIEW_ADDR_TFT35 + row * 4096);
+        if (row < 20) W25QXX.SPI_FLASH_SectorErase(BAK_VIEW_ADDR_TFT35 + row * 4096);
         W25QXX.SPI_FLASH_BufferWrite(bmp_public_buf, BAK_VIEW_ADDR_TFT35 + row * 400, 400);
-        row++;
-        if (row >= 200) {
-          size = 809;
-          row  = 0;
-
-          gcode_preview_over = false;
-          //flash_preview_begin = true;
-
-          card.closefile();
-
-          /*
-          if (gCurFileState.file_open_flag != 0xAA) {
-            reset_file_info();
-            res = f_open(file, curFileName, FA_OPEN_EXISTING | FA_READ);
-            if (res == FR_OK) {
-              f_lseek(file,PREVIEW_SIZE+To_pre_view);
-              gCurFileState.file_open_flag = 0xAA;
-              //bakup_file_path((uint8_t *)curFileName, strlen(curFileName));
-              srcfp = file;
-              mksReprint.mks_printer_state = MKS_WORKING;
-              once_flag = false;
-            }
-          }
-          */
-          char *cur_name;
-
-          cur_name = strrchr(list_file.file_name[sel_id], '/');
-
-          SdFile file;
-          SdFile *curDir;
-          card.endFilePrint();
-          const char * const fname = card.diveToFile(true, curDir, cur_name);
-          if (!fname) return;
-          if (file.open(curDir, fname, O_READ)) {
-            gCfgItems.curFilesize = file.fileSize();
-            file.close();
-            update_spi_flash();
-          }
+      #endif
+      row++;
+      if (row >= 200) {
+        size = 809;
+        row  = 0;
+
+        gcode_preview_over = false;
 
-          card.openFileRead(cur_name);
-          if (card.isFileOpen()) {
-            feedrate_percentage = 100;
-            //saved_feedrate_percentage = feedrate_percentage;
-            planner.flow_percentage[0] = 100;
-            planner.e_factor[0]        = planner.flow_percentage[0] * 0.01;
-            #if HAS_MULTI_EXTRUDER
-              planner.flow_percentage[1] = 100;
-              planner.e_factor[1]        = planner.flow_percentage[1] * 0.01;
-            #endif
-            card.startFileprint();
-            TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
-            once_flag = false;
-          }
-          return;
-        }
         card.closefile();
-      #endif // SDSUPPORT
-    }
+        char *cur_name;
 
-  #endif // if 1
+        cur_name = strrchr(list_file.file_name[sel_id], '/');
+
+        SdFile file;
+        SdFile *curDir;
+        card.endFilePrint();
+        const char * const fname = card.diveToFile(true, curDir, cur_name);
+        if (!fname) return;
+        if (file.open(curDir, fname, O_READ)) {
+          gCfgItems.curFilesize = file.fileSize();
+          file.close();
+          update_spi_flash();
+        }
 
-  void Draw_default_preview(int xpos_pixel, int ypos_pixel, uint8_t sel) {
+        card.openFileRead(cur_name);
+        if (card.isFileOpen()) {
+          feedrate_percentage = 100;
+          planner.flow_percentage[0] = 100;
+          planner.e_factor[0]        = planner.flow_percentage[0] * 0.01;
+          #if HAS_MULTI_EXTRUDER
+            planner.flow_percentage[1] = 100;
+            planner.e_factor[1]        = planner.flow_percentage[1] * 0.01;
+          #endif
+          card.startFileprint();
+          TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
+          once_flag = false;
+        }
+        return;
+      }
+      card.closefile();
+    #endif // SDSUPPORT
+  }
+
+  void draw_default_preview(int xpos_pixel, int ypos_pixel, uint8_t sel) {
     int index;
     int y_off = 0;
     W25QXX.init(SPI_QUARTER_SPEED);
@@ -914,12 +759,12 @@ char *creat_title_text() {
     #if HAS_BAK_VIEW_IN_FLASH
       if (flash_preview_begin) {
         flash_preview_begin = false;
-        Draw_default_preview(xpos_pixel, ypos_pixel, 1);
+        draw_default_preview(xpos_pixel, ypos_pixel, 1);
       }
     #endif
     #if HAS_GCODE_DEFAULT_VIEW_IN_FLASH
       if (default_preview_flg) {
-        Draw_default_preview(xpos_pixel, ypos_pixel, 0);
+        draw_default_preview(xpos_pixel, ypos_pixel, 0);
         default_preview_flg = false;
       }
     #endif
@@ -1005,12 +850,11 @@ void GUI_RefreshPage() {
           temps_update_flag = false;
         }
         break;
-    #endif
-
-    case BIND_UI:
-      /*refresh_bind_ui();*/
-      break;
 
+      case BIND_UI:
+        refresh_bind_ui();
+        break;
+    #endif
     case FILAMENTCHANGE_UI:
       if (temps_update_flag) {
         temps_update_flag = false;
@@ -1097,8 +941,7 @@ void clear_cur_ui() {
   last_disp_state = disp_state_stack._disp_state[disp_state_stack._disp_index];
 
   switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
-    case PRINT_READY_UI:
-                                      lv_clear_ready_print(); break;
+    case PRINT_READY_UI:              lv_clear_ready_print(); break;
     case PRINT_FILE_UI:               lv_clear_print_file(); break;
     case PRINTING_UI:                 lv_clear_printing(); break;
     case MOVE_MOTOR_UI:               lv_clear_move_motor(); break;
@@ -1119,14 +962,16 @@ void clear_cur_ui() {
     #if ENABLED(MKS_WIFI_MODULE)
       case WIFI_UI:                   lv_clear_wifi(); break;
     #endif
-    case MORE_UI:                     /* Clear_more(); */ break;
+    case MORE_UI:                     lv_clear_more(); break;
     case FILETRANSFER_UI:             break;
     case DIALOG_UI:                   lv_clear_dialog(); break;
     case FILETRANSFERSTATE_UI:        break;
     case PRINT_MORE_UI:               break;
     case FILAMENTCHANGE_UI:           lv_clear_filament_change(); break;
     case LEVELING_UI:                 lv_clear_manualLevel(); break;
-    case BIND_UI:                     /* Clear_Bind(); */ break;
+    #if ENABLED(MKS_WIFI_MODULE)
+      case BIND_UI:                   lv_clear_cloud_bind(); break;
+    #endif
     #if HAS_BED_PROBE
       case NOZZLE_PROBE_OFFSET_UI:    lv_clear_auto_level_offset_settings(); break;
     #endif
@@ -1224,11 +1069,13 @@ void draw_return_ui() {
       #if ENABLED(MKS_WIFI_MODULE)
         case WIFI_UI:                   lv_draw_wifi(); break;
       #endif
-      case PRINT_MORE_UI:               /* draw_printmore(); */ break;
       case MORE_UI:                     break;
+      case PRINT_MORE_UI:               lv_draw_more(); break;
       case FILAMENTCHANGE_UI:           lv_draw_filament_change(); break;
       case LEVELING_UI:                 lv_draw_manualLevel(); break;
-      case BIND_UI:                     /* draw_bind(); */ break;
+      #if ENABLED(MKS_WIFI_MODULE)
+        case BIND_UI:                   lv_draw_cloud_bind(); break;
+      #endif
       #if HAS_BED_PROBE
         case NOZZLE_PROBE_OFFSET_UI:    lv_draw_auto_level_offset_settings(); break;
       #endif

commit 44c57ab05a8f909b85f51e08c90316b41e50c455
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 12 21:02:35 2021 -0600

    MKS UI prelim. cleanup (#20763)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 46c1ab8279..ffbaba4ea5 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -70,10 +70,11 @@ uint8_t printing_rate_update_flag;
 
 extern bool once_flag;
 extern uint8_t sel_id;
-extern uint8_t public_buf[512];
-extern uint8_t bmp_public_buf[17 * 1024];
 extern lv_group_t *g;
 
+extern uint8_t bmp_public_buf[14 * 1024];
+extern uint8_t public_buf[513];
+
 extern void LCD_IO_WriteData(uint16_t RegValue);
 
 static const char custom_gcode_command[][100] = {
@@ -568,11 +569,7 @@ char *creat_title_text() {
 
   ZERO(tmpCurFileStr);
 
-  #if _LFN_UNICODE
-    //cutFileName((TCHAR *)curFileName, 16, 16, (TCHAR *)tmpCurFileStr);
-  #else
-    cutFileName(list_file.long_name[sel_id], 16, 16, tmpCurFileStr);
-  #endif
+  cutFileName(list_file.long_name[sel_id], 16, 16, tmpCurFileStr);
 
   ZERO(public_buf_m);
 
@@ -589,10 +586,7 @@ char *creat_title_text() {
     index++;
   }
 
-  if (disp_state_stack._disp_state[disp_state_stack._disp_index] == PRINTING_UI
-    /*|| disp_state_stack._disp_state[disp_state_stack._disp_index] == OPERATE_UI
-    || disp_state_stack._disp_state[disp_state_stack._disp_index] == PAUSE_UI*/
-  ) {
+  if (disp_state_stack._disp_state[disp_state_stack._disp_index] == PRINTING_UI) {
     titleText_cat(public_buf_m, sizeof(public_buf_m), (char *)":");
     titleText_cat(public_buf_m, sizeof(public_buf_m), tmpCurFileStr);
   }
@@ -617,8 +611,6 @@ char *creat_title_text() {
 
   void preview_gcode_prehandle(char *path) {
     #if ENABLED(SDSUPPORT)
-      //uint8_t re;
-      //uint32_t read;
       uint32_t pre_read_cnt = 0;
       uint32_t *p1;
       char *cur_name;
@@ -957,7 +949,6 @@ void GUI_RefreshPage() {
 
   switch (disp_state) {
     case MAIN_UI:
-      //lv_draw_ready_print();
       break;
     case EXTRUSION_UI:
       if (temps_update_flag) {
@@ -972,14 +963,6 @@ void GUI_RefreshPage() {
       }
       break;
     case PRINT_READY_UI:
-      /*
-      if (gCfgItems.display_style == 2) {
-        if (temps_update_flag) {
-          temps_update_flag = false;
-          disp_restro_state();
-        }
-      }
-      */
       break;
 
     case PRINT_FILE_UI: break;
@@ -1000,23 +983,9 @@ void GUI_RefreshPage() {
       break;
 
     case OPERATE_UI:
-      /*
-      if (temps_update_flag) {
-        temps_update_flag = false;
-        disp_temp_operate();
-      }
-
-      setProBarRateOpera();
-      */
       break;
 
     case PAUSE_UI:
-      /*
-      if (temps_update_flag) {
-        temps_update_flag = false;
-        disp_temp_pause();
-      }
-      */
       break;
 
     case FAN_UI:
@@ -1027,17 +996,6 @@ void GUI_RefreshPage() {
       break;
 
     case MOVE_MOTOR_UI:
-      /*
-      if (mksReprint.mks_printer_state == MKS_IDLE) {
-        if (z_high_count == 1 && temper_error_flg != 1) {
-          z_high_count = 0;
-          memset((char *)gCfgItems.move_z_coordinate, ' ', sizeof(gCfgItems.move_z_coordinate));
-          GUI_DispStringAt((const char *)gCfgItems.move_z_coordinate, 380, TITLE_YPOS);
-          sprintf_P((char *)gCfgItems.move_z_coordinate, PSTR("Z: %.3f"), current_position[Z_AXIS]);
-          GUI_DispStringAt((const char *)gCfgItems.move_z_coordinate, 380, TITLE_YPOS);
-        }
-      }
-      */
       break;
 
     #if ENABLED(MKS_WIFI_MODULE)
@@ -1064,7 +1022,6 @@ void GUI_RefreshPage() {
       TERN_(MKS_WIFI_MODULE, wifi_scan_handle());
       break;
     case MESHLEVELING_UI:
-      /*disp_zpos();*/
       break;
     case HARDWARE_TEST_UI:
       break;
@@ -1077,8 +1034,6 @@ void GUI_RefreshPage() {
       #endif
       break;
     case KEY_BOARD_UI:
-      /*update_password_disp();
-      update_join_state_disp();*/
       break;
     #if ENABLED(MKS_WIFI_MODULE)
       case WIFI_TIPS_UI:
@@ -1142,33 +1097,33 @@ void clear_cur_ui() {
   last_disp_state = disp_state_stack._disp_state[disp_state_stack._disp_index];
 
   switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
-    case PRINT_READY_UI:              //Get_Temperature_Flg = 0;
+    case PRINT_READY_UI:
                                       lv_clear_ready_print(); break;
     case PRINT_FILE_UI:               lv_clear_print_file(); break;
     case PRINTING_UI:                 lv_clear_printing(); break;
     case MOVE_MOTOR_UI:               lv_clear_move_motor(); break;
     case OPERATE_UI:                  lv_clear_operation(); break;
-    case PAUSE_UI:                    /* Clear_pause(); */ break;
+    case PAUSE_UI:                    break;
     case EXTRUSION_UI:                lv_clear_extrusion(); break;
     case PRE_HEAT_UI:                 lv_clear_preHeat(); break;
     case CHANGE_SPEED_UI:             lv_clear_change_speed(); break;
     case FAN_UI:                      lv_clear_fan(); break;
     case SET_UI:                      lv_clear_set(); break;
     case ZERO_UI:                     lv_clear_home(); break;
-    case SPRAYER_UI:                  /* Clear_Sprayer(); */ break;
-    case MACHINE_UI:                  /* Clear_Machine(); */ break;
+    case SPRAYER_UI:                  break;
+    case MACHINE_UI:                  break;
     case LANGUAGE_UI:                 lv_clear_language(); break;
     case ABOUT_UI:                    lv_clear_about(); break;
-    case LOG_UI:                      /* Clear_Connect(); */ break;
-    case DISK_UI:                     /* Clear_Disk(); */ break;
+    case LOG_UI:                      break;
+    case DISK_UI:                     break;
     #if ENABLED(MKS_WIFI_MODULE)
       case WIFI_UI:                   lv_clear_wifi(); break;
     #endif
     case MORE_UI:                     /* Clear_more(); */ break;
-    case FILETRANSFER_UI:             /* Clear_fileTransfer(); */ break;
+    case FILETRANSFER_UI:             break;
     case DIALOG_UI:                   lv_clear_dialog(); break;
-    case FILETRANSFERSTATE_UI:        /* Clear_WifiFileTransferdialog(); */ break;
-    case PRINT_MORE_UI:               /* Clear_Printmore(); */ break;
+    case FILETRANSFERSTATE_UI:        break;
+    case PRINT_MORE_UI:               break;
     case FILAMENTCHANGE_UI:           lv_clear_filament_change(); break;
     case LEVELING_UI:                 lv_clear_manualLevel(); break;
     case BIND_UI:                     /* Clear_Bind(); */ break;
@@ -1176,8 +1131,8 @@ void clear_cur_ui() {
       case NOZZLE_PROBE_OFFSET_UI:    lv_clear_auto_level_offset_settings(); break;
     #endif
     case TOOL_UI:                     lv_clear_tool(); break;
-    case MESHLEVELING_UI:             /* Clear_MeshLeveling(); */ break;
-    case HARDWARE_TEST_UI:            /* Clear_Hardwaretest(); */ break;
+    case MESHLEVELING_UI:             break;
+    case HARDWARE_TEST_UI:            break;
     #if ENABLED(MKS_WIFI_MODULE)
       case WIFI_LIST_UI:              lv_clear_wifi_list(); break;
     #endif
@@ -1187,28 +1142,28 @@ void clear_cur_ui() {
     #endif
     case MACHINE_PARA_UI:             lv_clear_machine_para(); break;
     case MACHINE_SETTINGS_UI:         lv_clear_machine_settings(); break;
-    case TEMPERATURE_SETTINGS_UI:     /* Clear_TemperatureSettings(); */ break;
+    case TEMPERATURE_SETTINGS_UI:     break;
     case MOTOR_SETTINGS_UI:           lv_clear_motor_settings(); break;
-    case MACHINETYPE_UI:              /* Clear_MachineType(); */ break;
-    case STROKE_UI:                   /* Clear_Stroke(); */ break;
-    case HOME_DIR_UI:                 /* Clear_HomeDir(); */ break;
-    case ENDSTOP_TYPE_UI:             /* Clear_EndstopType(); */ break;
-    case FILAMENT_SETTINGS_UI:        lv_clear_filament_settings(); break;
-    case LEVELING_SETTIGNS_UI:        /* Clear_LevelingSettings(); */ break;
+    case MACHINETYPE_UI:              break;
+    case STROKE_UI:                   break;
+    case HOME_DIR_UI:                 break;
+    case ENDSTOP_TYPE_UI:             break;
+    case FILAMENT_SETTINGS_UI:        break;
+    case LEVELING_SETTIGNS_UI:        break;
     case LEVELING_PARA_UI:            lv_clear_level_settings(); break;
-    case DELTA_LEVELING_PARA_UI:      /* Clear_DeltaLevelPara(); */ break;
+    case DELTA_LEVELING_PARA_UI:      break;
     case MANUAL_LEVELING_POSIGION_UI: lv_clear_manual_level_pos_settings(); break;
     case MAXFEEDRATE_UI:              lv_clear_max_feedrate_settings(); break;
     case STEPS_UI:                    lv_clear_step_settings(); break;
     case ACCELERATION_UI:             lv_clear_acceleration_settings(); break;
     case JERK_UI:                     TERN_(HAS_CLASSIC_JERK, lv_clear_jerk_settings()); break;
-    case MOTORDIR_UI:                 /* Clear_MotorDir(); */ break;
-    case HOMESPEED_UI:                /* Clear_HomeSpeed(); */ break;
-    case NOZZLE_CONFIG_UI:            /* Clear_NozzleConfig(); */ break;
-    case HOTBED_CONFIG_UI:            /* Clear_HotbedConfig(); */ break;
+    case MOTORDIR_UI:                 break;
+    case HOMESPEED_UI:                break;
+    case NOZZLE_CONFIG_UI:            break;
+    case HOTBED_CONFIG_UI:            break;
     case ADVANCED_UI:                 lv_clear_advance_settings(); break;
-    case DOUBLE_Z_UI:                 /* Clear_DoubleZ(); */ break;
-    case ENABLE_INVERT_UI:            /* Clear_EnableInvert(); */ break;
+    case DOUBLE_Z_UI:                 break;
+    case ENABLE_INVERT_UI:            break;
     case NUMBER_KEY_UI:               lv_clear_number_key(); break;
     case BABY_STEP_UI:                lv_clear_baby_stepping(); break;
     case PAUSE_POS_UI:                lv_clear_pause_position(); break;
@@ -1233,7 +1188,6 @@ void clear_cur_ui() {
     #endif
     default: break;
   }
-  //GUI_Clear();
 }
 
 void draw_return_ui() {
@@ -1253,25 +1207,25 @@ void draw_return_ui() {
 
       case MOVE_MOTOR_UI:               lv_draw_move_motor(); break;
       case OPERATE_UI:                  lv_draw_operation(); break;
-      case PAUSE_UI:                    /* draw_pause(); */ break;
+      case PAUSE_UI:                    break;
       case EXTRUSION_UI:                lv_draw_extrusion(); break;
       case PRE_HEAT_UI:                 lv_draw_preHeat(); break;
       case CHANGE_SPEED_UI:             lv_draw_change_speed(); break;
       case FAN_UI:                      lv_draw_fan(); break;
       case SET_UI:                      lv_draw_set(); break;
       case ZERO_UI:                     lv_draw_home(); break;
-      case SPRAYER_UI:                  /* draw_Sprayer(); */ break;
-      case MACHINE_UI:                  /* draw_Machine(); */ break;
+      case SPRAYER_UI:                  break;
+      case MACHINE_UI:                  break;
       case LANGUAGE_UI:                 lv_draw_language(); break;
       case ABOUT_UI:                    lv_draw_about(); break;
 
-      case CALIBRATE_UI:                /* draw_calibrate(); */ break;
-      case DISK_UI:                     /* draw_Disk(); */ break;
+      case CALIBRATE_UI:                break;
+      case DISK_UI:                     break;
       #if ENABLED(MKS_WIFI_MODULE)
         case WIFI_UI:                   lv_draw_wifi(); break;
       #endif
-      case MORE_UI:                     /* draw_More(); */ break;
       case PRINT_MORE_UI:               /* draw_printmore(); */ break;
+      case MORE_UI:                     break;
       case FILAMENTCHANGE_UI:           lv_draw_filament_change(); break;
       case LEVELING_UI:                 lv_draw_manualLevel(); break;
       case BIND_UI:                     /* draw_bind(); */ break;
@@ -1279,8 +1233,8 @@ void draw_return_ui() {
         case NOZZLE_PROBE_OFFSET_UI:    lv_draw_auto_level_offset_settings(); break;
       #endif
       case TOOL_UI:                     lv_draw_tool(); break;
-      case MESHLEVELING_UI:             /* draw_meshleveling(); */ break;
-      case HARDWARE_TEST_UI:            /* draw_Hardwaretest(); */ break;
+      case MESHLEVELING_UI:             break;
+      case HARDWARE_TEST_UI:            break;
       #if ENABLED(MKS_WIFI_MODULE)
         case WIFI_LIST_UI:              lv_draw_wifi_list(); break;
       #endif
@@ -1290,16 +1244,16 @@ void draw_return_ui() {
       #endif
       case MACHINE_PARA_UI:             lv_draw_machine_para(); break;
       case MACHINE_SETTINGS_UI:         lv_draw_machine_settings(); break;
-      case TEMPERATURE_SETTINGS_UI:     /* draw_TemperatureSettings(); */ break;
+      case TEMPERATURE_SETTINGS_UI:     break;
       case MOTOR_SETTINGS_UI:           lv_draw_motor_settings(); break;
-      case MACHINETYPE_UI:              /* draw_MachineType(); */ break;
-      case STROKE_UI:                   /* draw_Stroke(); */ break;
-      case HOME_DIR_UI:                 /* draw_HomeDir(); */ break;
-      case ENDSTOP_TYPE_UI:             /* draw_EndstopType(); */ break;
+      case MACHINETYPE_UI:              break;
+      case STROKE_UI:                   break;
+      case HOME_DIR_UI:                 break;
+      case ENDSTOP_TYPE_UI:             break;
       case FILAMENT_SETTINGS_UI:        lv_draw_filament_settings(); break;
-      case LEVELING_SETTIGNS_UI:        /* draw_LevelingSettings(); */ break;
+      case LEVELING_SETTIGNS_UI:        break;
       case LEVELING_PARA_UI:            lv_draw_level_settings(); break;
-      case DELTA_LEVELING_PARA_UI:      /* draw_DeltaLevelPara(); */ break;
+      case DELTA_LEVELING_PARA_UI:      break;
       case MANUAL_LEVELING_POSIGION_UI: lv_draw_manual_level_pos_settings(); break;
       case MAXFEEDRATE_UI:              lv_draw_max_feedrate_settings(); break;
       case STEPS_UI:                    lv_draw_step_settings(); break;
@@ -1307,15 +1261,15 @@ void draw_return_ui() {
       #if HAS_CLASSIC_JERK
         case JERK_UI:                   lv_draw_jerk_settings(); break;
       #endif
-      case MOTORDIR_UI:                 /* draw_MotorDir(); */ break;
-      case HOMESPEED_UI:                /* draw_HomeSpeed(); */ break;
-      case NOZZLE_CONFIG_UI:            /* draw_NozzleConfig(); */ break;
-      case HOTBED_CONFIG_UI:            /* draw_HotbedConfig(); */ break;
+      case MOTORDIR_UI:                 break;
+      case HOMESPEED_UI:                break;
+      case NOZZLE_CONFIG_UI:            break;
+      case HOTBED_CONFIG_UI:            break;
       case ADVANCED_UI:                 lv_draw_advance_settings(); break;
-      case DOUBLE_Z_UI:                 /* draw_DoubleZ(); */ break;
-      case ENABLE_INVERT_UI:            /* draw_EnableInvert(); */ break;
+      case DOUBLE_Z_UI:                 break;
+      case ENABLE_INVERT_UI:            break;
       case NUMBER_KEY_UI:               lv_draw_number_key(); break;
-      case DIALOG_UI:                   /* draw_dialog(uiCfg.dialogType); */ break;
+      case DIALOG_UI:                   break;
       case BABY_STEP_UI:                lv_draw_baby_stepping(); break;
       case PAUSE_POS_UI:                lv_draw_pause_position(); break;
       #if HAS_TRINAMIC_CONFIG
@@ -1612,7 +1566,6 @@ void print_time_count() {
 }
 
 void LV_TASK_HANDLER() {
-  //lv_tick_inc(1);
   lv_task_handler();
   if (mks_test_flag == 0x1E) mks_hardware_test();
 
@@ -1622,8 +1575,6 @@ void LV_TASK_HANDLER() {
 
   TERN_(MKS_WIFI_MODULE, get_wifi_commands());
 
-  //sd_detection();
-
   #if HAS_ROTARY_ENCODER
     if (gCfgItems.encoder_enable) lv_update_encoder();
   #endif

commit b51c6d4737f7987d551cea1096dca049e277c15b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 19 17:28:45 2020 -0600

    More MKS WiFi

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 102234b090..46c1ab8279 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -1161,7 +1161,7 @@ void clear_cur_ui() {
     case ABOUT_UI:                    lv_clear_about(); break;
     case LOG_UI:                      /* Clear_Connect(); */ break;
     case DISK_UI:                     /* Clear_Disk(); */ break;
-    #if ENABLED(USE_WIFI_FUNCTION)
+    #if ENABLED(MKS_WIFI_MODULE)
       case WIFI_UI:                   lv_clear_wifi(); break;
     #endif
     case MORE_UI:                     /* Clear_more(); */ break;
@@ -1178,11 +1178,11 @@ void clear_cur_ui() {
     case TOOL_UI:                     lv_clear_tool(); break;
     case MESHLEVELING_UI:             /* Clear_MeshLeveling(); */ break;
     case HARDWARE_TEST_UI:            /* Clear_Hardwaretest(); */ break;
-    #if ENABLED(USE_WIFI_FUNCTION)
+    #if ENABLED(MKS_WIFI_MODULE)
       case WIFI_LIST_UI:              lv_clear_wifi_list(); break;
     #endif
     case KEY_BOARD_UI:                lv_clear_keyboard(); break;
-    #if ENABLED(USE_WIFI_FUNCTION)
+    #if ENABLED(MKS_WIFI_MODULE)
       case WIFI_TIPS_UI:              lv_clear_wifi_tips(); break;
     #endif
     case MACHINE_PARA_UI:             lv_clear_machine_para(); break;
@@ -1219,7 +1219,7 @@ void clear_cur_ui() {
     #if HAS_STEALTHCHOP
       case TMC_MODE_UI:               lv_clear_tmc_step_mode_settings(); break;
     #endif
-    #if ENABLED(USE_WIFI_FUNCTION)
+    #if ENABLED(MKS_WIFI_MODULE)
       case WIFI_SETTINGS_UI:          lv_clear_wifi_settings(); break;
     #endif
     #if USE_SENSORLESS
@@ -1267,7 +1267,7 @@ void draw_return_ui() {
 
       case CALIBRATE_UI:                /* draw_calibrate(); */ break;
       case DISK_UI:                     /* draw_Disk(); */ break;
-      #if ENABLED(USE_WIFI_FUNCTION)
+      #if ENABLED(MKS_WIFI_MODULE)
         case WIFI_UI:                   lv_draw_wifi(); break;
       #endif
       case MORE_UI:                     /* draw_More(); */ break;
@@ -1281,11 +1281,11 @@ void draw_return_ui() {
       case TOOL_UI:                     lv_draw_tool(); break;
       case MESHLEVELING_UI:             /* draw_meshleveling(); */ break;
       case HARDWARE_TEST_UI:            /* draw_Hardwaretest(); */ break;
-      #if ENABLED(USE_WIFI_FUNCTION)
+      #if ENABLED(MKS_WIFI_MODULE)
         case WIFI_LIST_UI:              lv_draw_wifi_list(); break;
       #endif
       case KEY_BOARD_UI:                lv_draw_keyboard(); break;
-      #if ENABLED(USE_WIFI_FUNCTION)
+      #if ENABLED(MKS_WIFI_MODULE)
         case WIFI_TIPS_UI:              lv_draw_wifi_tips(); break;
       #endif
       case MACHINE_PARA_UI:             lv_draw_machine_para(); break;
@@ -1325,7 +1325,7 @@ void draw_return_ui() {
         #if HAS_STEALTHCHOP
           case TMC_MODE_UI:             lv_draw_tmc_step_mode_settings(); break;
         #endif
-      #if ENABLED(USE_WIFI_FUNCTION)
+      #if ENABLED(MKS_WIFI_MODULE)
         case WIFI_SETTINGS_UI:          lv_draw_wifi_settings(); break;
       #endif
       #if USE_SENSORLESS
@@ -1620,7 +1620,7 @@ void LV_TASK_HANDLER() {
 
   GUI_RefreshPage();
 
-  TERN_(USE_WIFI_FUNCTION, get_wifi_commands());
+  TERN_(MKS_WIFI_MODULE, get_wifi_commands());
 
   //sd_detection();
 

commit 3893114c86c195d227e023c9e702197b54b2636f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 19 15:51:53 2020 -0600

    MKS WiFi preliminary changes

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index a6c96d6799..102234b090 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -138,7 +138,7 @@ void gCfgItems_init() {
   gCfgItems.levelingPos[4][0] = X_BED_SIZE / 2;
   gCfgItems.levelingPos[4][1] = Y_BED_SIZE / 2;
   gCfgItems.cloud_enable  = true;
-  #if ENABLED(USE_WIFI_FUNCTION)
+  #if ENABLED(MKS_WIFI_MODULE)
     gCfgItems.wifi_mode_sel = STA_MODEL;
     gCfgItems.fileSysType   = FILE_SYS_SD;
     gCfgItems.wifi_type     = ESP_WIFI;
@@ -203,7 +203,7 @@ void ui_cfg_init() {
   uiCfg.filament_unloading_time_flg  = 0;
   uiCfg.filament_unloading_time_cnt  = 0;
 
-  #if ENABLED(USE_WIFI_FUNCTION)
+  #if ENABLED(MKS_WIFI_MODULE)
     memset(&wifiPara, 0, sizeof(wifiPara));
     memset(&ipPara, 0, sizeof(ipPara));
     strcpy(wifiPara.ap_name, WIFI_AP_NAME);
@@ -542,7 +542,7 @@ char *getDispText(int index) {
       strcpy(public_buf_l, tool_menu.title);
       break;
     case WIFI_LIST_UI:
-      #if ENABLED(USE_WIFI_FUNCTION)
+      #if ENABLED(MKS_WIFI_MODULE)
         strcpy(public_buf_l, list_menu.title);
         break;
       #endif
@@ -1040,7 +1040,7 @@ void GUI_RefreshPage() {
       */
       break;
 
-    #if ENABLED(USE_WIFI_FUNCTION)
+    #if ENABLED(MKS_WIFI_MODULE)
       case WIFI_UI:
         if (temps_update_flag) {
           disp_wifi_state();
@@ -1061,7 +1061,7 @@ void GUI_RefreshPage() {
       break;
     case DIALOG_UI:
       filament_dialog_handle();
-      TERN_(USE_WIFI_FUNCTION, wifi_scan_handle());
+      TERN_(MKS_WIFI_MODULE, wifi_scan_handle());
       break;
     case MESHLEVELING_UI:
       /*disp_zpos();*/
@@ -1069,7 +1069,7 @@ void GUI_RefreshPage() {
     case HARDWARE_TEST_UI:
       break;
     case WIFI_LIST_UI:
-      #if ENABLED(USE_WIFI_FUNCTION)
+      #if ENABLED(MKS_WIFI_MODULE)
         if (printing_rate_update_flag) {
           disp_wifi_list();
           printing_rate_update_flag = false;
@@ -1080,7 +1080,7 @@ void GUI_RefreshPage() {
       /*update_password_disp();
       update_join_state_disp();*/
       break;
-    #if ENABLED(USE_WIFI_FUNCTION)
+    #if ENABLED(MKS_WIFI_MODULE)
       case WIFI_TIPS_UI:
         switch (wifi_tips_type) {
           case TIPS_TYPE_JOINING:
@@ -1216,11 +1216,11 @@ void clear_cur_ui() {
         case TMC_CURRENT_UI:          lv_clear_tmc_current_settings(); break;
       #endif
     case EEPROM_SETTINGS_UI:          lv_clear_eeprom_settings(); break;
-      #if HAS_STEALTHCHOP
-        case TMC_MODE_UI:             lv_clear_tmc_step_mode_settings(); break;
-      #endif
+    #if HAS_STEALTHCHOP
+      case TMC_MODE_UI:               lv_clear_tmc_step_mode_settings(); break;
+    #endif
     #if ENABLED(USE_WIFI_FUNCTION)
-    case WIFI_SETTINGS_UI:            lv_clear_wifi_settings(); break;
+      case WIFI_SETTINGS_UI:          lv_clear_wifi_settings(); break;
     #endif
     #if USE_SENSORLESS
       case HOMING_SENSITIVITY_UI:     lv_clear_homing_sensitivity_settings(); break;
@@ -1516,10 +1516,8 @@ lv_obj_t* lv_big_button_create(lv_obj_t *par, const char *img, const char *text,
     else
       lv_obj_align(label, btn, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
   }
-  #if HAS_ROTARY_ENCODER
-    if (gCfgItems.encoder_enable == true)
-      lv_group_add_obj(g, btn);
-  #endif
+  if (TERN0(HAS_ROTARY_ENCODER, gCfgItems.encoder_enable))
+    lv_group_add_obj(g, btn);
   return btn;
 }
 
@@ -1535,11 +1533,8 @@ lv_obj_t* lv_screen_menu_item(lv_obj_t *par, const char *text, lv_coord_t x, lv_
     lv_label_set_text(label, text);
     lv_obj_align(label, btn, LV_ALIGN_IN_LEFT_MID, 0, 0);
   }
-  #if HAS_ROTARY_ENCODER
-    if (gCfgItems.encoder_enable == true) {
-      lv_group_add_obj(g, btn);
-    }
-  #endif
+  if (TERN0(HAS_ROTARY_ENCODER, gCfgItems.encoder_enable))
+    lv_group_add_obj(g, btn);
 
   if (drawArrow) (void)lv_imgbtn_create(par, "F:/bmp_arrow.bin", x + PARA_UI_SIZE_X, y + PARA_UI_ARROW_V, cb, id);
 

commit ea371618da71dc43e6aee95a8e479c8797867e04
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sun Nov 15 19:39:58 2020 -0300

    Add Touch Calibration screen (#20049)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 58b593a128..a6c96d6799 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -48,6 +48,10 @@
   #include "../../../../feature/pause.h"
 #endif
 
+#if ENABLED(TOUCH_SCREEN_CALIBRATION)
+  #include "draw_touch_calibration.h"
+#endif
+
 CFG_ITMES gCfgItems;
 UI_CFG uiCfg;
 DISP_STATE_STACK disp_state_stack;
@@ -1138,227 +1142,94 @@ void clear_cur_ui() {
   last_disp_state = disp_state_stack._disp_state[disp_state_stack._disp_index];
 
   switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
-    case PRINT_READY_UI:
-      //Get_Temperature_Flg = 0;
-      lv_clear_ready_print();
-      break;
-    case PRINT_FILE_UI:
-      lv_clear_print_file();
-      break;
-    case PRINTING_UI:
-      lv_clear_printing();
-      break;
-    case MOVE_MOTOR_UI:
-      lv_clear_move_motor();
-      break;
-    case OPERATE_UI:
-      lv_clear_operation();
-      break;
-    case PAUSE_UI:
-      //Clear_pause();
-      break;
-    case EXTRUSION_UI:
-      lv_clear_extrusion();
-      break;
-    case PRE_HEAT_UI:
-      lv_clear_preHeat();
-      break;
-    case CHANGE_SPEED_UI:
-      lv_clear_change_speed();
-      break;
-    case FAN_UI:
-      lv_clear_fan();
-      break;
-    case SET_UI:
-      lv_clear_set();
-      break;
-    case ZERO_UI:
-      lv_clear_home();
-      break;
-    case SPRAYER_UI:
-      //Clear_Sprayer();
-      break;
-    case MACHINE_UI:
-      //Clear_Machine();
-      break;
-    case LANGUAGE_UI:
-      lv_clear_language();
-      break;
-    case ABOUT_UI:
-      lv_clear_about();
-      break;
-    case LOG_UI:
-      //Clear_Connect();
-      break;
-    case DISK_UI:
-      //Clear_Disk();
-      break;
+    case PRINT_READY_UI:              //Get_Temperature_Flg = 0;
+                                      lv_clear_ready_print(); break;
+    case PRINT_FILE_UI:               lv_clear_print_file(); break;
+    case PRINTING_UI:                 lv_clear_printing(); break;
+    case MOVE_MOTOR_UI:               lv_clear_move_motor(); break;
+    case OPERATE_UI:                  lv_clear_operation(); break;
+    case PAUSE_UI:                    /* Clear_pause(); */ break;
+    case EXTRUSION_UI:                lv_clear_extrusion(); break;
+    case PRE_HEAT_UI:                 lv_clear_preHeat(); break;
+    case CHANGE_SPEED_UI:             lv_clear_change_speed(); break;
+    case FAN_UI:                      lv_clear_fan(); break;
+    case SET_UI:                      lv_clear_set(); break;
+    case ZERO_UI:                     lv_clear_home(); break;
+    case SPRAYER_UI:                  /* Clear_Sprayer(); */ break;
+    case MACHINE_UI:                  /* Clear_Machine(); */ break;
+    case LANGUAGE_UI:                 lv_clear_language(); break;
+    case ABOUT_UI:                    lv_clear_about(); break;
+    case LOG_UI:                      /* Clear_Connect(); */ break;
+    case DISK_UI:                     /* Clear_Disk(); */ break;
     #if ENABLED(USE_WIFI_FUNCTION)
-      case WIFI_UI:
-        lv_clear_wifi();
-        break;
+      case WIFI_UI:                   lv_clear_wifi(); break;
     #endif
-    case MORE_UI:
-      //Clear_more();
-      break;
-    case FILETRANSFER_UI:
-      //Clear_fileTransfer();
-      break;
-    case DIALOG_UI:
-      lv_clear_dialog();
-      break;
-    case FILETRANSFERSTATE_UI:
-      //Clear_WifiFileTransferdialog();
-      break;
-    case PRINT_MORE_UI:
-      //Clear_Printmore();
-      break;
-    case FILAMENTCHANGE_UI:
-      lv_clear_filament_change();
-      break;
-    case LEVELING_UI:
-      lv_clear_manualLevel();
-      break;
-    case BIND_UI:
-      //Clear_Bind();
-      break;
+    case MORE_UI:                     /* Clear_more(); */ break;
+    case FILETRANSFER_UI:             /* Clear_fileTransfer(); */ break;
+    case DIALOG_UI:                   lv_clear_dialog(); break;
+    case FILETRANSFERSTATE_UI:        /* Clear_WifiFileTransferdialog(); */ break;
+    case PRINT_MORE_UI:               /* Clear_Printmore(); */ break;
+    case FILAMENTCHANGE_UI:           lv_clear_filament_change(); break;
+    case LEVELING_UI:                 lv_clear_manualLevel(); break;
+    case BIND_UI:                     /* Clear_Bind(); */ break;
     #if HAS_BED_PROBE
-      case NOZZLE_PROBE_OFFSET_UI:
-        lv_clear_auto_level_offset_settings();
-        break;
+      case NOZZLE_PROBE_OFFSET_UI:    lv_clear_auto_level_offset_settings(); break;
     #endif
-    case TOOL_UI:
-      lv_clear_tool();
-      break;
-    case MESHLEVELING_UI:
-      //Clear_MeshLeveling();
-      break;
-    case HARDWARE_TEST_UI:
-      //Clear_Hardwaretest();
-      break;
+    case TOOL_UI:                     lv_clear_tool(); break;
+    case MESHLEVELING_UI:             /* Clear_MeshLeveling(); */ break;
+    case HARDWARE_TEST_UI:            /* Clear_Hardwaretest(); */ break;
     #if ENABLED(USE_WIFI_FUNCTION)
-      case WIFI_LIST_UI:
-          lv_clear_wifi_list();
-        break;
+      case WIFI_LIST_UI:              lv_clear_wifi_list(); break;
     #endif
-    case KEY_BOARD_UI:
-      lv_clear_keyboard();
-      break;
+    case KEY_BOARD_UI:                lv_clear_keyboard(); break;
     #if ENABLED(USE_WIFI_FUNCTION)
-      case WIFI_TIPS_UI:
-        lv_clear_wifi_tips();
-        break;
+      case WIFI_TIPS_UI:              lv_clear_wifi_tips(); break;
     #endif
-    case MACHINE_PARA_UI:
-      lv_clear_machine_para();
-      break;
-    case MACHINE_SETTINGS_UI:
-      lv_clear_machine_settings();
-      break;
-    case TEMPERATURE_SETTINGS_UI:
-      //Clear_TemperatureSettings();
-      break;
-    case MOTOR_SETTINGS_UI:
-      lv_clear_motor_settings();
-      break;
-    case MACHINETYPE_UI:
-      //Clear_MachineType();
-      break;
-    case STROKE_UI:
-      //Clear_Stroke();
-      break;
-    case HOME_DIR_UI:
-      //Clear_HomeDir();
-      break;
-    case ENDSTOP_TYPE_UI:
-      //Clear_EndstopType();
-      break;
-    case FILAMENT_SETTINGS_UI:
-      lv_clear_filament_settings();
-      break;
-    case LEVELING_SETTIGNS_UI:
-      //Clear_LevelingSettings();
-      break;
-    case LEVELING_PARA_UI:
-      lv_clear_level_settings();
-      break;
-    case DELTA_LEVELING_PARA_UI:
-      //Clear_DeltaLevelPara();
-      break;
-    case MANUAL_LEVELING_POSIGION_UI:
-      lv_clear_manual_level_pos_settings();
-      break;
-    case MAXFEEDRATE_UI:
-      lv_clear_max_feedrate_settings();
-      break;
-    case STEPS_UI:
-      lv_clear_step_settings();
-      break;
-    case ACCELERATION_UI:
-      lv_clear_acceleration_settings();
-      break;
-    case JERK_UI:
-      #if HAS_CLASSIC_JERK
-        lv_clear_jerk_settings();
-      #endif
-      break;
-    case MOTORDIR_UI:
-      //Clear_MotorDir();
-      break;
-    case HOMESPEED_UI:
-      //Clear_HomeSpeed();
-      break;
-    case NOZZLE_CONFIG_UI:
-      //Clear_NozzleConfig();
-      break;
-    case HOTBED_CONFIG_UI:
-      //Clear_HotbedConfig();
-      break;
-    case ADVANCED_UI:
-      lv_clear_advance_settings();
-      break;
-    case DOUBLE_Z_UI:
-      //Clear_DoubleZ();
-      break;
-    case ENABLE_INVERT_UI:
-      //Clear_EnableInvert();
-      break;
-    case NUMBER_KEY_UI:
-      lv_clear_number_key();
-      break;
-    case BABY_STEP_UI:
-      lv_clear_baby_stepping();
-      break;
-    case PAUSE_POS_UI:
-      lv_clear_pause_position();
-      break;
+    case MACHINE_PARA_UI:             lv_clear_machine_para(); break;
+    case MACHINE_SETTINGS_UI:         lv_clear_machine_settings(); break;
+    case TEMPERATURE_SETTINGS_UI:     /* Clear_TemperatureSettings(); */ break;
+    case MOTOR_SETTINGS_UI:           lv_clear_motor_settings(); break;
+    case MACHINETYPE_UI:              /* Clear_MachineType(); */ break;
+    case STROKE_UI:                   /* Clear_Stroke(); */ break;
+    case HOME_DIR_UI:                 /* Clear_HomeDir(); */ break;
+    case ENDSTOP_TYPE_UI:             /* Clear_EndstopType(); */ break;
+    case FILAMENT_SETTINGS_UI:        lv_clear_filament_settings(); break;
+    case LEVELING_SETTIGNS_UI:        /* Clear_LevelingSettings(); */ break;
+    case LEVELING_PARA_UI:            lv_clear_level_settings(); break;
+    case DELTA_LEVELING_PARA_UI:      /* Clear_DeltaLevelPara(); */ break;
+    case MANUAL_LEVELING_POSIGION_UI: lv_clear_manual_level_pos_settings(); break;
+    case MAXFEEDRATE_UI:              lv_clear_max_feedrate_settings(); break;
+    case STEPS_UI:                    lv_clear_step_settings(); break;
+    case ACCELERATION_UI:             lv_clear_acceleration_settings(); break;
+    case JERK_UI:                     TERN_(HAS_CLASSIC_JERK, lv_clear_jerk_settings()); break;
+    case MOTORDIR_UI:                 /* Clear_MotorDir(); */ break;
+    case HOMESPEED_UI:                /* Clear_HomeSpeed(); */ break;
+    case NOZZLE_CONFIG_UI:            /* Clear_NozzleConfig(); */ break;
+    case HOTBED_CONFIG_UI:            /* Clear_HotbedConfig(); */ break;
+    case ADVANCED_UI:                 lv_clear_advance_settings(); break;
+    case DOUBLE_Z_UI:                 /* Clear_DoubleZ(); */ break;
+    case ENABLE_INVERT_UI:            /* Clear_EnableInvert(); */ break;
+    case NUMBER_KEY_UI:               lv_clear_number_key(); break;
+    case BABY_STEP_UI:                lv_clear_baby_stepping(); break;
+    case PAUSE_POS_UI:                lv_clear_pause_position(); break;
       #if HAS_TRINAMIC_CONFIG
-        case TMC_CURRENT_UI:
-          lv_clear_tmc_current_settings();
-          break;
+        case TMC_CURRENT_UI:          lv_clear_tmc_current_settings(); break;
       #endif
-    case EEPROM_SETTINGS_UI:
-      lv_clear_eeprom_settings();
-      break;
+    case EEPROM_SETTINGS_UI:          lv_clear_eeprom_settings(); break;
       #if HAS_STEALTHCHOP
-        case TMC_MODE_UI:
-          lv_clear_tmc_step_mode_settings();
-          break;
+        case TMC_MODE_UI:             lv_clear_tmc_step_mode_settings(); break;
       #endif
     #if ENABLED(USE_WIFI_FUNCTION)
-    case WIFI_SETTINGS_UI:
-      lv_clear_wifi_settings();
-      break;
+    case WIFI_SETTINGS_UI:            lv_clear_wifi_settings(); break;
     #endif
     #if USE_SENSORLESS
-      case HOMING_SENSITIVITY_UI:
-        lv_clear_homing_sensitivity_settings();
-        break;
+      case HOMING_SENSITIVITY_UI:     lv_clear_homing_sensitivity_settings(); break;
     #endif
     #if HAS_ROTARY_ENCODER
-      case ENCODER_SETTINGS_UI:
-        lv_clear_encoder_settings();
-        break;
+      case ENCODER_SETTINGS_UI:       lv_clear_encoder_settings(); break;
+    #endif
+    #if ENABLED(TOUCH_SCREEN_CALIBRATION)
+      case TOUCH_CALIBRATION_UI:      lv_clear_touch_calibration_screen(); break;
     #endif
     default: break;
   }
@@ -1370,227 +1241,98 @@ void draw_return_ui() {
     disp_state_stack._disp_index--;
 
     switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
-      case PRINT_READY_UI:
-        lv_draw_ready_print();
-        break;
-      case PRINT_FILE_UI:
-        lv_draw_print_file();
-        break;
-      case PRINTING_UI:
-        if (gCfgItems.from_flash_pic) flash_preview_begin = true;
-        else default_preview_flg = true;
-        lv_draw_printing();
-        break;
-      case MOVE_MOTOR_UI:
-        lv_draw_move_motor();
-        break;
-      case OPERATE_UI:
-        lv_draw_operation();
-        break;
-
-        #if 1
-          case PAUSE_UI:
-            //draw_pause();
-            break;
-        #endif
-
-      case EXTRUSION_UI:
-        lv_draw_extrusion();
-        break;
-      case PRE_HEAT_UI:
-        lv_draw_preHeat();
-        break;
-      case CHANGE_SPEED_UI:
-        lv_draw_change_speed();
-        break;
-      case FAN_UI:
-        lv_draw_fan();
-        break;
-      case SET_UI:
-        lv_draw_set();
-        break;
-      case ZERO_UI:
-        lv_draw_home();
-        break;
-      case SPRAYER_UI:
-        //draw_Sprayer();
-        break;
-      case MACHINE_UI:
-        //draw_Machine();
-        break;
-      case LANGUAGE_UI:
-        lv_draw_language();
-        break;
-      case ABOUT_UI:
-        lv_draw_about();
-        break;
-
-      case CALIBRATE_UI:
-        //draw_calibrate();
-        break;
-      case DISK_UI:
-        //draw_Disk();
-        break;
+      case PRINT_READY_UI:              lv_draw_ready_print(); break;
+      case PRINT_FILE_UI:               lv_draw_print_file(); break;
+
+      case PRINTING_UI:                 if (gCfgItems.from_flash_pic)
+                                          flash_preview_begin = true;
+                                        else
+                                          default_preview_flg = true;
+                                        lv_draw_printing();
+                                        break;
+
+      case MOVE_MOTOR_UI:               lv_draw_move_motor(); break;
+      case OPERATE_UI:                  lv_draw_operation(); break;
+      case PAUSE_UI:                    /* draw_pause(); */ break;
+      case EXTRUSION_UI:                lv_draw_extrusion(); break;
+      case PRE_HEAT_UI:                 lv_draw_preHeat(); break;
+      case CHANGE_SPEED_UI:             lv_draw_change_speed(); break;
+      case FAN_UI:                      lv_draw_fan(); break;
+      case SET_UI:                      lv_draw_set(); break;
+      case ZERO_UI:                     lv_draw_home(); break;
+      case SPRAYER_UI:                  /* draw_Sprayer(); */ break;
+      case MACHINE_UI:                  /* draw_Machine(); */ break;
+      case LANGUAGE_UI:                 lv_draw_language(); break;
+      case ABOUT_UI:                    lv_draw_about(); break;
+
+      case CALIBRATE_UI:                /* draw_calibrate(); */ break;
+      case DISK_UI:                     /* draw_Disk(); */ break;
       #if ENABLED(USE_WIFI_FUNCTION)
-        case WIFI_UI:
-          lv_draw_wifi();
-          break;
+        case WIFI_UI:                   lv_draw_wifi(); break;
       #endif
-      case MORE_UI:
-        //draw_More();
-        break;
-      case PRINT_MORE_UI:
-        //draw_printmore();
-        break;
-      case FILAMENTCHANGE_UI:
-        lv_draw_filament_change();
-        break;
-      case LEVELING_UI:
-        lv_draw_manualLevel();
-        break;
-      case BIND_UI:
-        //draw_bind();
-        break;
+      case MORE_UI:                     /* draw_More(); */ break;
+      case PRINT_MORE_UI:               /* draw_printmore(); */ break;
+      case FILAMENTCHANGE_UI:           lv_draw_filament_change(); break;
+      case LEVELING_UI:                 lv_draw_manualLevel(); break;
+      case BIND_UI:                     /* draw_bind(); */ break;
       #if HAS_BED_PROBE
-        case NOZZLE_PROBE_OFFSET_UI:
-          lv_draw_auto_level_offset_settings();
-          break;
+        case NOZZLE_PROBE_OFFSET_UI:    lv_draw_auto_level_offset_settings(); break;
       #endif
-      case TOOL_UI:
-        lv_draw_tool();
-        break;
-      case MESHLEVELING_UI:
-        //draw_meshleveling();
-        break;
-      case HARDWARE_TEST_UI:
-        //draw_Hardwaretest();
-        break;
-      case WIFI_LIST_UI:
-        #if ENABLED(USE_WIFI_FUNCTION)
-          lv_draw_wifi_list();
-        #endif
-        break;
-      case KEY_BOARD_UI:
-        lv_draw_keyboard();
-        break;
-      case WIFI_TIPS_UI:
-        #if ENABLED(USE_WIFI_FUNCTION)
-          lv_draw_wifi_tips();
-        #endif
-        break;
-      case MACHINE_PARA_UI:
-        lv_draw_machine_para();
-        break;
-      case MACHINE_SETTINGS_UI:
-        lv_draw_machine_settings();
-        break;
-      case TEMPERATURE_SETTINGS_UI:
-        //draw_TemperatureSettings();
-        break;
-      case MOTOR_SETTINGS_UI:
-        lv_draw_motor_settings();
-        break;
-      case MACHINETYPE_UI:
-        //draw_MachineType();
-        break;
-      case STROKE_UI:
-        //draw_Stroke();
-        break;
-      case HOME_DIR_UI:
-        //draw_HomeDir();
-        break;
-      case ENDSTOP_TYPE_UI:
-        //draw_EndstopType();
-        break;
-      case FILAMENT_SETTINGS_UI:
-        lv_draw_filament_settings();
-        break;
-      case LEVELING_SETTIGNS_UI:
-        //draw_LevelingSettings();
-        break;
-      case LEVELING_PARA_UI:
-        lv_draw_level_settings();
-        break;
-      case DELTA_LEVELING_PARA_UI:
-        //draw_DeltaLevelPara();
-        break;
-      case MANUAL_LEVELING_POSIGION_UI:
-        lv_draw_manual_level_pos_settings();
-        break;
-      case MAXFEEDRATE_UI:
-        lv_draw_max_feedrate_settings();
-        break;
-      case STEPS_UI:
-        lv_draw_step_settings();
-        break;
-      case ACCELERATION_UI:
-        lv_draw_acceleration_settings();
-        break;
-      case JERK_UI:
-        #if HAS_CLASSIC_JERK
-          lv_draw_jerk_settings();
-        #endif
-        break;
-      case MOTORDIR_UI:
-        //draw_MotorDir();
-        break;
-      case HOMESPEED_UI:
-        //draw_HomeSpeed();
-        break;
-      case NOZZLE_CONFIG_UI:
-        //draw_NozzleConfig();
-        break;
-      case HOTBED_CONFIG_UI:
-        //draw_HotbedConfig();
-        break;
-      case ADVANCED_UI:
-        lv_draw_advance_settings();
-        break;
-      case DOUBLE_Z_UI:
-        //draw_DoubleZ();
-        break;
-      case ENABLE_INVERT_UI:
-        //draw_EnableInvert();
-        break;
-      case NUMBER_KEY_UI:
-        lv_draw_number_key();
-        break;
-      case DIALOG_UI:
-        //draw_dialog(uiCfg.dialogType);
-        break;
-      case BABY_STEP_UI:
-        lv_draw_baby_stepping();
-        break;
-      case PAUSE_POS_UI:
-        lv_draw_pause_position();
-        break;
-        #if HAS_TRINAMIC_CONFIG
-          case TMC_CURRENT_UI:
-            lv_draw_tmc_current_settings();
-            break;
-        #endif
-      case EEPROM_SETTINGS_UI:
-        lv_draw_eeprom_settings();
-        break;
+      case TOOL_UI:                     lv_draw_tool(); break;
+      case MESHLEVELING_UI:             /* draw_meshleveling(); */ break;
+      case HARDWARE_TEST_UI:            /* draw_Hardwaretest(); */ break;
+      #if ENABLED(USE_WIFI_FUNCTION)
+        case WIFI_LIST_UI:              lv_draw_wifi_list(); break;
+      #endif
+      case KEY_BOARD_UI:                lv_draw_keyboard(); break;
+      #if ENABLED(USE_WIFI_FUNCTION)
+        case WIFI_TIPS_UI:              lv_draw_wifi_tips(); break;
+      #endif
+      case MACHINE_PARA_UI:             lv_draw_machine_para(); break;
+      case MACHINE_SETTINGS_UI:         lv_draw_machine_settings(); break;
+      case TEMPERATURE_SETTINGS_UI:     /* draw_TemperatureSettings(); */ break;
+      case MOTOR_SETTINGS_UI:           lv_draw_motor_settings(); break;
+      case MACHINETYPE_UI:              /* draw_MachineType(); */ break;
+      case STROKE_UI:                   /* draw_Stroke(); */ break;
+      case HOME_DIR_UI:                 /* draw_HomeDir(); */ break;
+      case ENDSTOP_TYPE_UI:             /* draw_EndstopType(); */ break;
+      case FILAMENT_SETTINGS_UI:        lv_draw_filament_settings(); break;
+      case LEVELING_SETTIGNS_UI:        /* draw_LevelingSettings(); */ break;
+      case LEVELING_PARA_UI:            lv_draw_level_settings(); break;
+      case DELTA_LEVELING_PARA_UI:      /* draw_DeltaLevelPara(); */ break;
+      case MANUAL_LEVELING_POSIGION_UI: lv_draw_manual_level_pos_settings(); break;
+      case MAXFEEDRATE_UI:              lv_draw_max_feedrate_settings(); break;
+      case STEPS_UI:                    lv_draw_step_settings(); break;
+      case ACCELERATION_UI:             lv_draw_acceleration_settings(); break;
+      #if HAS_CLASSIC_JERK
+        case JERK_UI:                   lv_draw_jerk_settings(); break;
+      #endif
+      case MOTORDIR_UI:                 /* draw_MotorDir(); */ break;
+      case HOMESPEED_UI:                /* draw_HomeSpeed(); */ break;
+      case NOZZLE_CONFIG_UI:            /* draw_NozzleConfig(); */ break;
+      case HOTBED_CONFIG_UI:            /* draw_HotbedConfig(); */ break;
+      case ADVANCED_UI:                 lv_draw_advance_settings(); break;
+      case DOUBLE_Z_UI:                 /* draw_DoubleZ(); */ break;
+      case ENABLE_INVERT_UI:            /* draw_EnableInvert(); */ break;
+      case NUMBER_KEY_UI:               lv_draw_number_key(); break;
+      case DIALOG_UI:                   /* draw_dialog(uiCfg.dialogType); */ break;
+      case BABY_STEP_UI:                lv_draw_baby_stepping(); break;
+      case PAUSE_POS_UI:                lv_draw_pause_position(); break;
+      #if HAS_TRINAMIC_CONFIG
+        case TMC_CURRENT_UI:            lv_draw_tmc_current_settings(); break;
+      #endif
+      case EEPROM_SETTINGS_UI:          lv_draw_eeprom_settings(); break;
         #if HAS_STEALTHCHOP
-          case TMC_MODE_UI:
-            lv_draw_tmc_step_mode_settings();
-            break;
+          case TMC_MODE_UI:             lv_draw_tmc_step_mode_settings(); break;
         #endif
       #if ENABLED(USE_WIFI_FUNCTION)
-        case WIFI_SETTINGS_UI:
-        lv_draw_wifi_settings();
-        break;
+        case WIFI_SETTINGS_UI:          lv_draw_wifi_settings(); break;
       #endif
       #if USE_SENSORLESS
-        case HOMING_SENSITIVITY_UI:
-          lv_draw_homing_sensitivity_settings();
-          break;
+        case HOMING_SENSITIVITY_UI:     lv_draw_homing_sensitivity_settings(); break;
       #endif
       #if HAS_ROTARY_ENCODER
-        case ENCODER_SETTINGS_UI:
-          lv_draw_encoder_settings();
-          break;
+        case ENCODER_SETTINGS_UI:       lv_draw_encoder_settings(); break;
       #endif
       default: break;
     }
@@ -1879,15 +1621,11 @@ void LV_TASK_HANDLER() {
   lv_task_handler();
   if (mks_test_flag == 0x1E) mks_hardware_test();
 
-  #if HAS_GCODE_PREVIEW
-    disp_pre_gcode(2, 36);
-  #endif
+  TERN_(HAS_GCODE_PREVIEW, disp_pre_gcode(2, 36));
 
   GUI_RefreshPage();
 
-  #if ENABLED(USE_WIFI_FUNCTION)
-    get_wifi_commands();
-  #endif
+  TERN_(USE_WIFI_FUNCTION, get_wifi_commands());
 
   //sd_detection();
 

commit f8ee6f8b3176b6df7bc3d23119a4bee36c6ff0d8
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Nov 10 22:39:34 2020 -0300

    Fix UI compile issues (#20092)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index c7f5f418f5..58b593a128 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -1680,7 +1680,7 @@ lv_obj_t* lv_label_create(lv_obj_t *par, lv_coord_t x, lv_coord_t y, const char
 lv_obj_t* lv_btn_create(lv_obj_t *par, lv_event_cb_t cb, const int id/*=0*/, lv_style_t *style/*=&style_para_value*/) {
   lv_obj_t *btn = lv_btn_create(par, nullptr);
   if (id)
-    lv_obj_set_event_cb_mks(btn, cb, id, nullptr, 0);
+    lv_obj_set_event_cb_mks(btn, cb, id, "", 0);
   else
     lv_obj_set_event_cb(btn, cb);
   lv_btn_set_style_both(btn, style);
@@ -1748,7 +1748,7 @@ lv_obj_t* lv_imgbtn_create(lv_obj_t *par, const char *img, lv_event_cb_t cb, con
   lv_obj_t *btn = lv_imgbtn_create(par, nullptr);
   if (img) lv_imgbtn_set_src_both(btn, img);
   if (id)
-    lv_obj_set_event_cb_mks(btn, cb, id, nullptr, 0);
+    lv_obj_set_event_cb_mks(btn, cb, id, "", 0);
   else
     lv_obj_set_event_cb(btn, cb);
   lv_imgbtn_use_label_style(btn);
@@ -1785,7 +1785,7 @@ lv_obj_t* lv_screen_menu_item(lv_obj_t *par, const char *text, lv_coord_t x, lv_
   lv_obj_t *btn = lv_btn_create(par, nullptr);   /*Add a button the current screen*/
   lv_obj_set_pos(btn, x, y);                         /*Set its position*/
   lv_obj_set_size(btn, PARA_UI_SIZE_X, PARA_UI_SIZE_Y);                       /*Set its size*/
-  if (id > -1) lv_obj_set_event_cb_mks(btn, cb, id, nullptr, 0);
+  if (id > -1) lv_obj_set_event_cb_mks(btn, cb, id, "", 0);
   lv_btn_use_label_style(btn);
   lv_btn_set_layout(btn, LV_LAYOUT_OFF);
   lv_obj_t *label = lv_label_create_empty(btn);        /*Add a label to the button*/

commit 75b0e3246a00c04c5bf04607d030775f1d8d1e0c
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Oct 27 17:09:19 2020 -0300

    Fix some LVGL bugs (#19904)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 50c49999af..c7f5f418f5 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -1640,7 +1640,6 @@ lv_obj_t* lv_screen_create(DISP_STATE newScreenType, const char* title) {
     disp_state_stack._disp_state[disp_state_stack._disp_index] = newScreenType;
   }
   disp_state = newScreenType;
-  lv_refr_now(lv_refr_get_disp_refreshing());
 
   // title
   lv_obj_t *titleLabel = nullptr;
@@ -1651,18 +1650,22 @@ lv_obj_t* lv_screen_create(DISP_STATE newScreenType, const char* title) {
   if (titleLabel)
     lv_obj_set_style(titleLabel, &tft_style_label_rel);
 
+  lv_refr_now(lv_refr_get_disp_refreshing());
+
   return scr;
 }
 
 // Create an empty label
 lv_obj_t* lv_label_create_empty(lv_obj_t *par) {
-  return lv_label_create(par, (lv_obj_t*)nullptr);
+  lv_obj_t *label = lv_label_create(par, (lv_obj_t*)nullptr);
+  return label;
 }
 
 // Create a label with style and text
 lv_obj_t* lv_label_create(lv_obj_t *par, const char *text) {
   lv_obj_t *label = lv_label_create_empty(par);
   if (text) lv_label_set_text(label, text);
+  lv_obj_set_style(label, &tft_style_label_rel);
   return label;
 }
 

commit 853d01de683ab3efcbb15ef95db869e279053ee0
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Oct 24 19:28:31 2020 -0300

    More LVGL UI code reduction (#19879)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 2de5bf25e1..50c49999af 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -1628,11 +1628,29 @@ void lv_btn_set_style_both(lv_obj_t *btn, lv_style_t *style) {
 }
 
 // Create a screen
-lv_obj_t* lv_screen_create() {
+lv_obj_t* lv_screen_create(DISP_STATE newScreenType, const char* title) {
   lv_obj_t *scr = lv_obj_create(nullptr, nullptr);
   lv_obj_set_style(scr, &tft_style_scr);
   lv_scr_load(scr);
   lv_obj_clean(scr);
+
+  // breadcrumbs
+  if (disp_state_stack._disp_state[disp_state_stack._disp_index] != newScreenType) {
+    disp_state_stack._disp_index++;
+    disp_state_stack._disp_state[disp_state_stack._disp_index] = newScreenType;
+  }
+  disp_state = newScreenType;
+  lv_refr_now(lv_refr_get_disp_refreshing());
+
+  // title
+  lv_obj_t *titleLabel = nullptr;
+  if (!title)
+    titleLabel = lv_label_create(scr, TITLE_XPOS, TITLE_YPOS, creat_title_text());
+  else if (title[0] != '\0')
+    titleLabel = lv_label_create(scr, TITLE_XPOS, TITLE_YPOS, title);
+  if (titleLabel)
+    lv_obj_set_style(titleLabel, &tft_style_label_rel);
+
   return scr;
 }
 

commit 9630c2683c39468bf885c560a1768d8b377d9462
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Oct 24 01:37:45 2020 -0300

    More MKS UI cleanup, optimization (#19869)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index ef23305285..2de5bf25e1 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -61,13 +61,14 @@ uint32_t To_pre_view;
 bool gcode_preview_over, flash_preview_begin, default_preview_flg;
 uint32_t size = 809;
 uint16_t row;
-uint8_t temperature_change_frequency;
+bool temps_update_flag;
 uint8_t printing_rate_update_flag;
 
 extern bool once_flag;
 extern uint8_t sel_id;
 extern uint8_t public_buf[512];
 extern uint8_t bmp_public_buf[17 * 1024];
+extern lv_group_t *g;
 
 extern void LCD_IO_WriteData(uint16_t RegValue);
 
@@ -282,6 +283,9 @@ lv_style_t style_para_back;
 
 lv_style_t lv_bar_style_indic;
 
+lv_style_t style_btn_pr;
+lv_style_t style_btn_rel;
+
 void tft_style_init() {
   lv_style_copy(&tft_style_scr, &lv_style_scr);
   tft_style_scr.body.main_color   = LV_COLOR_BACKGROUND;
@@ -399,6 +403,25 @@ void tft_style_init() {
   style_para_back.text.color        = LV_COLOR_WHITE;
   style_para_back.text.font         = &TERN(HAS_SPI_FLASH_FONT, gb2312_puhui32, lv_font_roboto_22);
 
+  lv_style_copy(&style_btn_rel, &lv_style_plain);
+  style_btn_rel.body.border.color = lv_color_hex3(0x269);
+  style_btn_rel.body.border.width = 1;
+  style_btn_rel.body.main_color   = lv_color_hex3(0xADF);
+  style_btn_rel.body.grad_color   = lv_color_hex3(0x46B);
+  style_btn_rel.body.shadow.width = 4;
+  style_btn_rel.body.shadow.type  = LV_SHADOW_BOTTOM;
+  style_btn_rel.body.radius       = LV_RADIUS_CIRCLE;
+  style_btn_rel.text.color        = lv_color_hex3(0xDEF);
+  style_btn_rel.text.font         = &TERN(HAS_SPI_FLASH_FONT, gb2312_puhui32, lv_font_roboto_22);
+
+  lv_style_copy(&style_btn_pr, &style_btn_rel);
+  style_btn_pr.body.border.color = lv_color_hex3(0x46B);
+  style_btn_pr.body.main_color   = lv_color_hex3(0x8BD);
+  style_btn_pr.body.grad_color   = lv_color_hex3(0x24A);
+  style_btn_pr.body.shadow.width = 2;
+  style_btn_pr.text.color        = lv_color_hex3(0xBCD);
+  style_btn_pr.text.font         = &TERN(HAS_SPI_FLASH_FONT, gb2312_puhui32, lv_font_roboto_22);
+
   lv_style_copy(&lv_bar_style_indic, &lv_style_pretty_color);
   lv_bar_style_indic.text.color        = lv_color_hex3(0xADF);
   lv_bar_style_indic.image.color       = lv_color_hex3(0xADF);
@@ -421,7 +444,6 @@ void titleText_cat(char *str, int strSize, char *addPart) {
 
 char *getDispText(int index) {
 
-  ZERO(public_buf_l);
 
   switch (disp_state_stack._disp_state[index]) {
     case PRINT_READY_UI:
@@ -926,30 +948,30 @@ void print_time_run() {
 }
 
 void GUI_RefreshPage() {
-  if ((systick_uptime_millis % 1000) == 0) temperature_change_frequency = 1;
-  if ((systick_uptime_millis % 3000) == 0) printing_rate_update_flag = 1;
+  if ((systick_uptime_millis % 1000) == 0) temps_update_flag = true;
+  if ((systick_uptime_millis % 3000) == 0) printing_rate_update_flag = true;
 
   switch (disp_state) {
     case MAIN_UI:
       //lv_draw_ready_print();
       break;
     case EXTRUSION_UI:
-      if (temperature_change_frequency == 1) {
-        temperature_change_frequency = 0;
+      if (temps_update_flag) {
+        temps_update_flag = false;
         disp_hotend_temp();
       }
       break;
     case PRE_HEAT_UI:
-      if (temperature_change_frequency == 1) {
-        temperature_change_frequency = 0;
+      if (temps_update_flag) {
+        temps_update_flag = false;
         disp_desire_temp();
       }
       break;
     case PRINT_READY_UI:
       /*
       if (gCfgItems.display_style == 2) {
-        if (temperature_change_frequency) {
-          temperature_change_frequency = 0;
+        if (temps_update_flag) {
+          temps_update_flag = false;
           disp_restro_state();
         }
       }
@@ -959,8 +981,8 @@ void GUI_RefreshPage() {
     case PRINT_FILE_UI: break;
 
     case PRINTING_UI:
-      if (temperature_change_frequency) {
-        temperature_change_frequency = 0;
+      if (temps_update_flag) {
+        temps_update_flag = false;
         disp_ext_temp();
         disp_bed_temp();
         disp_fan_speed();
@@ -968,15 +990,15 @@ void GUI_RefreshPage() {
         disp_fan_Zpos();
       }
       if (printing_rate_update_flag || marlin_state == MF_SD_COMPLETE) {
-        printing_rate_update_flag = 0;
+        printing_rate_update_flag = false;
         if (!gcode_preview_over) setProBarRate();
       }
       break;
 
     case OPERATE_UI:
       /*
-      if (temperature_change_frequency == 1) {
-        temperature_change_frequency = 0;
+      if (temps_update_flag) {
+        temps_update_flag = false;
         disp_temp_operate();
       }
 
@@ -986,16 +1008,16 @@ void GUI_RefreshPage() {
 
     case PAUSE_UI:
       /*
-      if (temperature_change_frequency == 1) {
-        temperature_change_frequency = 0;
+      if (temps_update_flag) {
+        temps_update_flag = false;
         disp_temp_pause();
       }
       */
       break;
 
     case FAN_UI:
-      if (temperature_change_frequency == 1) {
-        temperature_change_frequency = 0;
+      if (temps_update_flag) {
+        temps_update_flag = false;
         disp_fan_value();
       }
       break;
@@ -1003,14 +1025,12 @@ void GUI_RefreshPage() {
     case MOVE_MOTOR_UI:
       /*
       if (mksReprint.mks_printer_state == MKS_IDLE) {
-        if ((z_high_count==1)&&(temper_error_flg != 1)) {
+        if (z_high_count == 1 && temper_error_flg != 1) {
           z_high_count = 0;
-          {
-            memset((char *)gCfgItems.move_z_coordinate, ' ', sizeof(gCfgItems.move_z_coordinate));
-            GUI_DispStringAt((const char *)gCfgItems.move_z_coordinate, 380, TITLE_YPOS);
-            sprintf_P((char *)gCfgItems.move_z_coordinate, PSTR("Z: %.3f"), current_position[Z_AXIS]);
-            GUI_DispStringAt((const char *)gCfgItems.move_z_coordinate, 380, TITLE_YPOS);
-          }
+          memset((char *)gCfgItems.move_z_coordinate, ' ', sizeof(gCfgItems.move_z_coordinate));
+          GUI_DispStringAt((const char *)gCfgItems.move_z_coordinate, 380, TITLE_YPOS);
+          sprintf_P((char *)gCfgItems.move_z_coordinate, PSTR("Z: %.3f"), current_position[Z_AXIS]);
+          GUI_DispStringAt((const char *)gCfgItems.move_z_coordinate, 380, TITLE_YPOS);
         }
       }
       */
@@ -1018,9 +1038,9 @@ void GUI_RefreshPage() {
 
     #if ENABLED(USE_WIFI_FUNCTION)
       case WIFI_UI:
-        if (temperature_change_frequency == 1) {
+        if (temps_update_flag) {
           disp_wifi_state();
-          temperature_change_frequency = 0;
+          temps_update_flag = false;
         }
         break;
     #endif
@@ -1030,8 +1050,8 @@ void GUI_RefreshPage() {
       break;
 
     case FILAMENTCHANGE_UI:
-      if (temperature_change_frequency) {
-        temperature_change_frequency = 0;
+      if (temps_update_flag) {
+        temps_update_flag = false;
         disp_filament_temp();
       }
       break;
@@ -1046,9 +1066,9 @@ void GUI_RefreshPage() {
       break;
     case WIFI_LIST_UI:
       #if ENABLED(USE_WIFI_FUNCTION)
-        if (printing_rate_update_flag == 1) {
+        if (printing_rate_update_flag) {
           disp_wifi_list();
-          printing_rate_update_flag = 0;
+          printing_rate_update_flag = false;
         }
       #endif
       break;
@@ -1103,8 +1123,8 @@ void GUI_RefreshPage() {
     #endif
 
     case BABY_STEP_UI:
-      if (temperature_change_frequency == 1) {
-        temperature_change_frequency = 0;
+      if (temps_update_flag) {
+        temps_update_flag = false;
         disp_z_offset_value();
       }
       break;
@@ -1589,21 +1609,36 @@ void lv_imgbtn_use_label_style(lv_obj_t *imgbtn) {
   lv_imgbtn_set_style(imgbtn, LV_BTN_STATE_PR,  &tft_style_label_pre);
 }
 
-// Use label style for the image button
+// Use label style for the button
 void lv_btn_use_label_style(lv_obj_t *btn) {
   lv_btn_set_style(btn, LV_BTN_STYLE_REL, &tft_style_label_rel);
   lv_btn_set_style(btn, LV_BTN_STYLE_PR,  &tft_style_label_pre);
 }
 
+// Use button style for the button
+void lv_btn_use_button_style(lv_obj_t *btn) {
+  lv_btn_set_style(btn, LV_BTN_STYLE_REL, &style_btn_rel);
+  lv_btn_set_style(btn, LV_BTN_STYLE_PR,  &style_btn_pr);
+}
+
 // Use a single style for both Released and Pressed
 void lv_btn_set_style_both(lv_obj_t *btn, lv_style_t *style) {
   lv_btn_set_style(btn, LV_BTN_STYLE_REL, style);
   lv_btn_set_style(btn, LV_BTN_STYLE_PR,  style);
 }
 
+// Create a screen
+lv_obj_t* lv_screen_create() {
+  lv_obj_t *scr = lv_obj_create(nullptr, nullptr);
+  lv_obj_set_style(scr, &tft_style_scr);
+  lv_scr_load(scr);
+  lv_obj_clean(scr);
+  return scr;
+}
+
 // Create an empty label
 lv_obj_t* lv_label_create_empty(lv_obj_t *par) {
-  return lv_label_create(par, (lv_obj_t*)NULL);
+  return lv_label_create(par, (lv_obj_t*)nullptr);
 }
 
 // Create a label with style and text
@@ -1621,35 +1656,66 @@ lv_obj_t* lv_label_create(lv_obj_t *par, lv_coord_t x, lv_coord_t y, const char
 }
 
 // Create a button with callback, ID, and Style.
-lv_obj_t* lv_btn_create(lv_obj_t *par, lv_event_cb_t cb, const int id, lv_style_t *style) {
-  lv_obj_t *btn = lv_btn_create(par, NULL);
+lv_obj_t* lv_btn_create(lv_obj_t *par, lv_event_cb_t cb, const int id/*=0*/, lv_style_t *style/*=&style_para_value*/) {
+  lv_obj_t *btn = lv_btn_create(par, nullptr);
   if (id)
-    lv_obj_set_event_cb_mks(btn, cb, id, NULL, 0);
+    lv_obj_set_event_cb_mks(btn, cb, id, nullptr, 0);
   else
     lv_obj_set_event_cb(btn, cb);
   lv_btn_set_style_both(btn, style);
   return btn;
 }
 
-// Create a button with callback and ID. Style set to style_para_value.
-lv_obj_t* lv_btn_create(lv_obj_t *par, lv_event_cb_t cb, const int id) {
-  return lv_btn_create(par, cb, id, &style_para_value);
+// Create a button with callback and ID, with label style.
+lv_obj_t* lv_label_btn_create(lv_obj_t *par, lv_event_cb_t cb, const int id/*=0*/) {
+  lv_obj_t *btn = lv_btn_create(par, cb, id, nullptr);
+  lv_btn_use_label_style(btn);
+  return btn;
+}
+
+// Create a button with callback and ID, with button style.
+lv_obj_t* lv_button_btn_create(lv_obj_t *par, lv_event_cb_t cb, const int id/*=0*/) {
+  lv_obj_t *btn = lv_btn_create(par, cb, id, nullptr);
+  lv_btn_use_button_style(btn);
+  return btn;
+}
+
+// Create a button with position, size, callback, ID, and style.
+lv_obj_t* lv_btn_create(lv_obj_t *par, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, lv_event_cb_t cb, const int id, lv_style_t *style) {
+  lv_obj_t *btn = lv_btn_create(par, cb, id, style);
+  lv_obj_set_pos(btn, x, y);
+  lv_obj_set_size(btn, w, h);
+  return btn;
 }
 
 // Create a button with position, size, callback, and ID. Style set to style_para_value.
-lv_obj_t* lv_btn_create(lv_obj_t *par, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, lv_event_cb_t cb, const int id) {
-  lv_obj_t *btn = lv_btn_create(par, cb, id);
+lv_obj_t* lv_btn_create(lv_obj_t *par, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, lv_event_cb_t cb, const int id/*=0*/) {
+  lv_obj_t *btn = lv_btn_create(par, x, y, w, h, cb, id, &style_para_value);
+  return btn;
+}
+
+// Create a button with position, size, callback, and ID, with label style.
+lv_obj_t* lv_label_btn_create(lv_obj_t *par, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, lv_event_cb_t cb, const int id/*=0*/) {
+  lv_obj_t *btn = lv_label_btn_create(par, cb, id);
+  lv_obj_set_pos(btn, x, y);
+  lv_obj_set_size(btn, w, h);
+  return btn;
+}
+
+// Create a button with position, size, callback, and ID, with label style.
+lv_obj_t* lv_button_btn_create(lv_obj_t *par, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, lv_event_cb_t cb, const int id/*=0*/) {
+  lv_obj_t *btn = lv_button_btn_create(par, cb, id);
   lv_obj_set_pos(btn, x, y);
   lv_obj_set_size(btn, w, h);
   return btn;
 }
 
 // Create a button with callback and ID. Style set to style_para_back.
-lv_obj_t* lv_btn_create_back(lv_obj_t *par, lv_event_cb_t cb, const int id) {
+lv_obj_t* lv_btn_create_back(lv_obj_t *par, lv_event_cb_t cb, const int id/*=0*/) {
   return lv_btn_create(par, cb, id, &style_para_back);
 }
 // Create a button with position, size, callback, and ID. Style set to style_para_back.
-lv_obj_t* lv_btn_create_back(lv_obj_t *par, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, lv_event_cb_t cb, const int id) {
+lv_obj_t* lv_btn_create_back(lv_obj_t *par, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, lv_event_cb_t cb, const int id/*=0*/) {
   lv_obj_t *btn = lv_btn_create_back(par, cb, id);
   lv_obj_set_pos(btn, x, y);
   lv_obj_set_size(btn, w, h);
@@ -1657,11 +1723,11 @@ lv_obj_t* lv_btn_create_back(lv_obj_t *par, lv_coord_t x, lv_coord_t y, lv_coord
 }
 
 // Create an image button with image, callback, and ID. Use label style.
-lv_obj_t* lv_imgbtn_create(lv_obj_t *par, const char *img, lv_event_cb_t cb, const int id) {
-  lv_obj_t *btn = lv_imgbtn_create(par, NULL);
+lv_obj_t* lv_imgbtn_create(lv_obj_t *par, const char *img, lv_event_cb_t cb, const int id/*=0*/) {
+  lv_obj_t *btn = lv_imgbtn_create(par, nullptr);
   if (img) lv_imgbtn_set_src_both(btn, img);
   if (id)
-    lv_obj_set_event_cb_mks(btn, cb, id, NULL, 0);
+    lv_obj_set_event_cb_mks(btn, cb, id, nullptr, 0);
   else
     lv_obj_set_event_cb(btn, cb);
   lv_imgbtn_use_label_style(btn);
@@ -1670,12 +1736,96 @@ lv_obj_t* lv_imgbtn_create(lv_obj_t *par, const char *img, lv_event_cb_t cb, con
 }
 
 // Create an image button with image, position, callback, and ID. Use label style.
-lv_obj_t* lv_imgbtn_create(lv_obj_t *par, const char *img, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id) {
+lv_obj_t* lv_imgbtn_create(lv_obj_t *par, const char *img, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id/*=0*/) {
+  lv_obj_t *btn = lv_imgbtn_create(par, img, cb, id);
+  lv_obj_set_pos(btn, x, y);
+  return btn;
+}
+
+lv_obj_t* lv_big_button_create(lv_obj_t *par, const char *img, const char *text, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id, bool centerLabel) {
   lv_obj_t *btn = lv_imgbtn_create(par, img, cb, id);
   lv_obj_set_pos(btn, x, y);
+  lv_obj_t *label = lv_label_create_empty(btn);
+  if (gCfgItems.multiple_language) {
+    lv_label_set_text(label, text);
+    if (centerLabel)
+      lv_obj_align(label, btn, LV_ALIGN_CENTER, 0, 0);
+    else
+      lv_obj_align(label, btn, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
+  }
+  #if HAS_ROTARY_ENCODER
+    if (gCfgItems.encoder_enable == true)
+      lv_group_add_obj(g, btn);
+  #endif
+  return btn;
+}
+
+lv_obj_t* lv_screen_menu_item(lv_obj_t *par, const char *text, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id, const int index, bool drawArrow) {
+  lv_obj_t *btn = lv_btn_create(par, nullptr);   /*Add a button the current screen*/
+  lv_obj_set_pos(btn, x, y);                         /*Set its position*/
+  lv_obj_set_size(btn, PARA_UI_SIZE_X, PARA_UI_SIZE_Y);                       /*Set its size*/
+  if (id > -1) lv_obj_set_event_cb_mks(btn, cb, id, nullptr, 0);
+  lv_btn_use_label_style(btn);
+  lv_btn_set_layout(btn, LV_LAYOUT_OFF);
+  lv_obj_t *label = lv_label_create_empty(btn);        /*Add a label to the button*/
+  if (gCfgItems.multiple_language) {
+    lv_label_set_text(label, text);
+    lv_obj_align(label, btn, LV_ALIGN_IN_LEFT_MID, 0, 0);
+  }
+  #if HAS_ROTARY_ENCODER
+    if (gCfgItems.encoder_enable == true) {
+      lv_group_add_obj(g, btn);
+    }
+  #endif
+
+  if (drawArrow) (void)lv_imgbtn_create(par, "F:/bmp_arrow.bin", x + PARA_UI_SIZE_X, y + PARA_UI_ARROW_V, cb, id);
+
+  lv_obj_t *line1 = lv_line_create(par, nullptr);
+  lv_ex_line(line1, line_points[index]);
+
   return btn;
 }
 
+lv_obj_t* lv_screen_menu_item_1_edit(lv_obj_t *par, const char *text, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id, const int index, const char *editValue) {
+  lv_obj_t* btn = lv_screen_menu_item(par, text, x, y, cb, -1, index, false);
+  lv_obj_t* btnValue = lv_btn_create(par, PARA_UI_VALUE_POS_X, y + PARA_UI_VALUE_V, PARA_UI_VALUE_BTN_X_SIZE, PARA_UI_VALUE_BTN_Y_SIZE, cb, id);
+  lv_obj_t* labelValue = lv_label_create_empty(btnValue);
+  lv_label_set_text(labelValue, editValue);
+  lv_obj_align(labelValue, btnValue, LV_ALIGN_CENTER, 0, 0);
+  return btn;
+}
+
+lv_obj_t* lv_screen_menu_item_2_edit(lv_obj_t *par, const char *text, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id, const int index, const char *editValue, const int idEdit2, const char *editValue2) {
+  lv_obj_t* btn = lv_screen_menu_item(par, text, x, y, cb, -1, index, false);
+
+  lv_obj_t* btnValue = lv_btn_create(par, PARA_UI_VALUE_POS_X_2, y + PARA_UI_VALUE_V_2, PARA_UI_VALUE_BTN_X_SIZE, PARA_UI_VALUE_BTN_Y_SIZE, cb, idEdit2);
+  lv_obj_t* labelValue = lv_label_create_empty(btnValue);
+  lv_label_set_text(labelValue, editValue2);
+  lv_obj_align(labelValue, btnValue, LV_ALIGN_CENTER, 0, 0);
+
+  btnValue = lv_btn_create(par, PARA_UI_VALUE_POS_X, y + PARA_UI_VALUE_V, PARA_UI_VALUE_BTN_X_SIZE, PARA_UI_VALUE_BTN_Y_SIZE, cb, id);
+  labelValue = lv_label_create_empty(btnValue);
+  lv_label_set_text(labelValue, editValue);
+  lv_obj_align(labelValue, btnValue, LV_ALIGN_CENTER, 0, 0);
+
+  return btn;
+}
+
+lv_obj_t* lv_screen_menu_item_onoff(lv_obj_t *par, const char *text, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id, const int index, const bool curValue) {
+  lv_screen_menu_item(par, text, x, y, cb, -1, index, false);
+  lv_obj_t* btnValue = lv_imgbtn_create(par, curValue ? "F:/bmp_enable.bin" : "F:/bmp_disable.bin", PARA_UI_STATE_POS_X, y + PARA_UI_STATE_V, cb, id);
+  lv_obj_t* labelValue = lv_label_create_empty(btnValue);
+  lv_label_set_text(labelValue, curValue ? machine_menu.enable : machine_menu.disable);
+  lv_obj_align(labelValue, btnValue, LV_ALIGN_CENTER, 0, 0);
+  return btnValue;
+}
+
+void lv_screen_menu_item_onoff_update(lv_obj_t *btn, const bool curValue) {
+  lv_imgbtn_set_src_both(btn, curValue ? "F:/bmp_enable.bin" : "F:/bmp_disable.bin");
+  lv_label_set_text((lv_obj_t*)btn->child_ll.head, curValue ? machine_menu.enable : machine_menu.disable);
+}
+
+
 #if ENABLED(SDSUPPORT)
 
   void sd_detection() {
@@ -1689,11 +1839,11 @@ lv_obj_t* lv_imgbtn_create(lv_obj_t *par, const char *img, lv_coord_t x, lv_coor
 
 #endif
 
-void lv_ex_line(lv_obj_t * line, lv_point_t *points) {
+void lv_ex_line(lv_obj_t *line, lv_point_t *points) {
   // Copy the previous line and apply the new style
   lv_line_set_points(line, points, 2);     // Set the points
   lv_line_set_style(line, LV_LINE_STYLE_MAIN, &style_line);
-  lv_obj_align(line, NULL, LV_ALIGN_IN_TOP_MID, 0, 0);
+  lv_obj_align(line, nullptr, LV_ALIGN_IN_TOP_MID, 0, 0);
 }
 
 extern volatile uint32_t systick_uptime_millis;

commit 4533a197d59ffcaccc4d476f06df7754b11b9b0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 22 20:22:17 2020 -0500

    Slim down MKS UI code (#19843)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 1f21136668..ef23305285 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -1577,6 +1577,105 @@ void draw_return_ui() {
   }
 }
 
+// Set the same image for both Released and Pressed
+void lv_imgbtn_set_src_both(lv_obj_t *imgbtn, const void *src) {
+  lv_imgbtn_set_src(imgbtn, LV_BTN_STATE_REL, src);
+  lv_imgbtn_set_src(imgbtn, LV_BTN_STATE_PR,  src);
+}
+
+// Use label style for the image button
+void lv_imgbtn_use_label_style(lv_obj_t *imgbtn) {
+  lv_imgbtn_set_style(imgbtn, LV_BTN_STATE_REL, &tft_style_label_rel);
+  lv_imgbtn_set_style(imgbtn, LV_BTN_STATE_PR,  &tft_style_label_pre);
+}
+
+// Use label style for the image button
+void lv_btn_use_label_style(lv_obj_t *btn) {
+  lv_btn_set_style(btn, LV_BTN_STYLE_REL, &tft_style_label_rel);
+  lv_btn_set_style(btn, LV_BTN_STYLE_PR,  &tft_style_label_pre);
+}
+
+// Use a single style for both Released and Pressed
+void lv_btn_set_style_both(lv_obj_t *btn, lv_style_t *style) {
+  lv_btn_set_style(btn, LV_BTN_STYLE_REL, style);
+  lv_btn_set_style(btn, LV_BTN_STYLE_PR,  style);
+}
+
+// Create an empty label
+lv_obj_t* lv_label_create_empty(lv_obj_t *par) {
+  return lv_label_create(par, (lv_obj_t*)NULL);
+}
+
+// Create a label with style and text
+lv_obj_t* lv_label_create(lv_obj_t *par, const char *text) {
+  lv_obj_t *label = lv_label_create_empty(par);
+  if (text) lv_label_set_text(label, text);
+  return label;
+}
+
+// Create a label with style, position, and text
+lv_obj_t* lv_label_create(lv_obj_t *par, lv_coord_t x, lv_coord_t y, const char *text) {
+  lv_obj_t *label = lv_label_create(par, text);
+  lv_obj_set_pos(label, x, y);
+  return label;
+}
+
+// Create a button with callback, ID, and Style.
+lv_obj_t* lv_btn_create(lv_obj_t *par, lv_event_cb_t cb, const int id, lv_style_t *style) {
+  lv_obj_t *btn = lv_btn_create(par, NULL);
+  if (id)
+    lv_obj_set_event_cb_mks(btn, cb, id, NULL, 0);
+  else
+    lv_obj_set_event_cb(btn, cb);
+  lv_btn_set_style_both(btn, style);
+  return btn;
+}
+
+// Create a button with callback and ID. Style set to style_para_value.
+lv_obj_t* lv_btn_create(lv_obj_t *par, lv_event_cb_t cb, const int id) {
+  return lv_btn_create(par, cb, id, &style_para_value);
+}
+
+// Create a button with position, size, callback, and ID. Style set to style_para_value.
+lv_obj_t* lv_btn_create(lv_obj_t *par, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, lv_event_cb_t cb, const int id) {
+  lv_obj_t *btn = lv_btn_create(par, cb, id);
+  lv_obj_set_pos(btn, x, y);
+  lv_obj_set_size(btn, w, h);
+  return btn;
+}
+
+// Create a button with callback and ID. Style set to style_para_back.
+lv_obj_t* lv_btn_create_back(lv_obj_t *par, lv_event_cb_t cb, const int id) {
+  return lv_btn_create(par, cb, id, &style_para_back);
+}
+// Create a button with position, size, callback, and ID. Style set to style_para_back.
+lv_obj_t* lv_btn_create_back(lv_obj_t *par, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, lv_event_cb_t cb, const int id) {
+  lv_obj_t *btn = lv_btn_create_back(par, cb, id);
+  lv_obj_set_pos(btn, x, y);
+  lv_obj_set_size(btn, w, h);
+  return btn;
+}
+
+// Create an image button with image, callback, and ID. Use label style.
+lv_obj_t* lv_imgbtn_create(lv_obj_t *par, const char *img, lv_event_cb_t cb, const int id) {
+  lv_obj_t *btn = lv_imgbtn_create(par, NULL);
+  if (img) lv_imgbtn_set_src_both(btn, img);
+  if (id)
+    lv_obj_set_event_cb_mks(btn, cb, id, NULL, 0);
+  else
+    lv_obj_set_event_cb(btn, cb);
+  lv_imgbtn_use_label_style(btn);
+  lv_btn_set_layout(btn, LV_LAYOUT_OFF);
+  return btn;
+}
+
+// Create an image button with image, position, callback, and ID. Use label style.
+lv_obj_t* lv_imgbtn_create(lv_obj_t *par, const char *img, lv_coord_t x, lv_coord_t y, lv_event_cb_t cb, const int id) {
+  lv_obj_t *btn = lv_imgbtn_create(par, img, cb, id);
+  lv_obj_set_pos(btn, x, y);
+  return btn;
+}
+
 #if ENABLED(SDSUPPORT)
 
   void sd_detection() {

commit 072f996af70b5ac635893eca2d4bd4bbb4f00acc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 21 12:45:27 2020 -0500

    General cleanup, mostly MKS UI (#19825)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 519fae2f39..1f21136668 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -34,10 +34,11 @@
 
 #include <SPI.h>
 
-#include "../../../../MarlinCore.h"
+#include "../../../../MarlinCore.h" // for marlin_state
 #include "../../../../sd/cardreader.h"
 #include "../../../../module/motion.h"
 #include "../../../../module/planner.h"
+#include "../../../../inc/MarlinConfig.h"
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../../feature/powerloss.h"
@@ -57,15 +58,13 @@ num_key_value_state value;
 keyboard_value_state keyboard_value;
 
 uint32_t To_pre_view;
-uint8_t gcode_preview_over;
-uint8_t flash_preview_begin;
-uint8_t default_preview_flg;
+bool gcode_preview_over, flash_preview_begin, default_preview_flg;
 uint32_t size = 809;
 uint16_t row;
 uint8_t temperature_change_frequency;
 uint8_t printing_rate_update_flag;
 
-extern uint8_t once_flag;
+extern bool once_flag;
 extern uint8_t sel_id;
 extern uint8_t public_buf[512];
 extern uint8_t bmp_public_buf[17 * 1024];
@@ -116,10 +115,10 @@ void gCfgItems_init() {
     gCfgItems.language = LANG_PORTUGUESE;
   #endif
   gCfgItems.leveling_mode     = 0;
-  gCfgItems.from_flash_pic    = 0;
+  gCfgItems.from_flash_pic    = false;
   gCfgItems.curFilesize       = 0;
-  gCfgItems.finish_power_off  = 0;
-  gCfgItems.pause_reprint     = 0;
+  gCfgItems.finish_power_off  = false;
+  gCfgItems.pause_reprint     = false;
   gCfgItems.pausePosX         = -1;
   gCfgItems.pausePosY         = -1;
   gCfgItems.pausePosZ         = 5;
@@ -407,7 +406,6 @@ void tft_style_init() {
   lv_bar_style_indic.body.main_color   = lv_color_hex3(0xADF);
   lv_bar_style_indic.body.grad_color   = lv_color_hex3(0xADF);
   lv_bar_style_indic.body.border.color = lv_color_hex3(0xADF);
-
 }
 
 #define MAX_TITLE_LEN 28
@@ -609,14 +607,14 @@ char *creat_title_text() {
         pre_read_cnt = (uint32_t)p1 - (uint32_t)((uint32_t *)(&public_buf[0]));
 
         To_pre_view              = pre_read_cnt;
-        gcode_preview_over       = 1;
-        gCfgItems.from_flash_pic = 1;
+        gcode_preview_over       = true;
+        gCfgItems.from_flash_pic = true;
         update_spi_flash();
       }
       else {
-        gcode_preview_over       = 0;
-        default_preview_flg      = 1;
-        gCfgItems.from_flash_pic = 0;
+        gcode_preview_over       = false;
+        default_preview_flg      = true;
+        gCfgItems.from_flash_pic = false;
         update_spi_flash();
       }
       card.closefile();
@@ -681,8 +679,8 @@ char *creat_title_text() {
           size = 809;
           row  = 0;
 
-          gcode_preview_over = 0;
-          //flash_preview_begin = 1;
+          gcode_preview_over = false;
+          //flash_preview_begin = true;
 
           card.closefile();
 
@@ -696,7 +694,7 @@ char *creat_title_text() {
               //bakup_file_path((uint8_t *)curFileName, strlen(curFileName));
               srcfp = file;
               mksReprint.mks_printer_state = MKS_WORKING;
-              once_flag = 0;
+              once_flag = false;
             }
           }
           */
@@ -727,7 +725,7 @@ char *creat_title_text() {
             #endif
             card.startFileprint();
             TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
-            once_flag = 0;
+            once_flag = false;
           }
           return;
         }
@@ -813,8 +811,8 @@ char *creat_title_text() {
           size = 809;
           row  = 0;
 
-          gcode_preview_over = 0;
-          //flash_preview_begin = 1;
+          gcode_preview_over = false;
+          //flash_preview_begin = true;
 
           card.closefile();
 
@@ -828,7 +826,7 @@ char *creat_title_text() {
               //bakup_file_path((uint8_t *)curFileName, strlen(curFileName));
               srcfp = file;
               mksReprint.mks_printer_state = MKS_WORKING;
-              once_flag = 0;
+              once_flag = false;
             }
           }
           */
@@ -859,7 +857,7 @@ char *creat_title_text() {
             #endif
             card.startFileprint();
             TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
-            once_flag = 0;
+            once_flag = false;
           }
           return;
         }
@@ -894,17 +892,17 @@ char *creat_title_text() {
   }
 
   void disp_pre_gcode(int xpos_pixel, int ypos_pixel) {
-    if (gcode_preview_over == 1) gcode_preview(list_file.file_name[sel_id], xpos_pixel, ypos_pixel);
+    if (gcode_preview_over) gcode_preview(list_file.file_name[sel_id], xpos_pixel, ypos_pixel);
     #if HAS_BAK_VIEW_IN_FLASH
-      if (flash_preview_begin == 1) {
-        flash_preview_begin = 0;
+      if (flash_preview_begin) {
+        flash_preview_begin = false;
         Draw_default_preview(xpos_pixel, ypos_pixel, 1);
       }
     #endif
     #if HAS_GCODE_DEFAULT_VIEW_IN_FLASH
-      if (default_preview_flg == 1) {
+      if (default_preview_flg) {
         Draw_default_preview(xpos_pixel, ypos_pixel, 0);
-        default_preview_flg = 0;
+        default_preview_flg = false;
       }
     #endif
   }
@@ -971,7 +969,7 @@ void GUI_RefreshPage() {
       }
       if (printing_rate_update_flag || marlin_state == MF_SD_COMPLETE) {
         printing_rate_update_flag = 0;
-        if (gcode_preview_over == 0) setProBarRate();
+        if (!gcode_preview_over) setProBarRate();
       }
       break;
 
@@ -1359,8 +1357,8 @@ void draw_return_ui() {
         lv_draw_print_file();
         break;
       case PRINTING_UI:
-        if (gCfgItems.from_flash_pic == 1) flash_preview_begin = 1;
-        else default_preview_flg = 1;
+        if (gCfgItems.from_flash_pic) flash_preview_begin = true;
+        else default_preview_flg = true;
         lv_draw_printing();
         break;
       case MOVE_MOTOR_UI:

commit f6ffbe548c81abfeecc996c8f2bffd27cabe0014
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 15 03:00:27 2020 -0500

    TFT Presets, Generic options, Sanity checks (#19723)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index d600b09a5f..519fae2f39 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -751,7 +751,7 @@ char *creat_title_text() {
         card.openFileRead(cur_name);
 
         card.setIndex((PREVIEW_LITTLE_PIC_SIZE + To_pre_view) + size * row + 8);
-        #if ENABLED(TFT_LVGL_UI_SPI)
+        #if HAS_TFT_LVGL_UI_SPI
           SPI_TFT.setWindow(xpos_pixel, ypos_pixel + row, 200, 1);
         #else
           LCD_setWindowArea(xpos_pixel, ypos_pixel + row, 200, 1);
@@ -782,7 +782,7 @@ char *creat_title_text() {
           //#endif
 
         }
-        #if ENABLED(TFT_LVGL_UI_SPI)
+        #if HAS_TFT_LVGL_UI_SPI
           for (i = 0; i < 400;) {
             p_index = (uint16_t *)(&bmp_public_buf[i]);
 

commit c0920bbf6a2490b7ea66d2a9e828c0f527a6c77b
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Mon Oct 12 18:38:07 2020 -0300

    TFT Refactoring (#19192)
    
    * split tft folder in two: tft for color ui; tft_io for shared tft code
    
    * after the files got moved, now the code was moved to the right place
    
    * classic ui using TFT IO init lcd codes
    
    * feature to compile tft_io when enabled
    
    * compiling fix
    
    * lvgl spi tft working with tft io init codes
    
    * there is no need for separeted fsmc and spi class in lvgl anymore, as tft io handle everything
    
    * remove debug
    
    * base for TFT rotation and mirroring API, and ILI9488 support
    
    * ST7796S rotate and mirror support
    
    * ST7789V rotate and mirror support
    
    * ST7735 rotate and mirror support
    
    * ILI9341 rotate and mirror support
    
    * ILI9328 rotate and mirror support
    
    * R61505 rotate and mirror support
    
    * MKS TFT definitions
    
    * more configs for mks tfts
    
    * update config
    
    * naming typo
    
    * to configure the user interface
    
    * ANYCUBIC_TFT35
    
    * tft configs
    
    * support for SSD1963
    
    * tft display types
    
    * updated conditionals lcd; first board fully working with the new code - all 3 ui!
    
    * compatiblity
    
    * changed name
    
    * move classic ui file name
    
    * rename TURN -> ROTATE
    
    * GRAPHICAL_TFT_ROTATE_180 deprecated
    
    * first fsmc board fully working - chitu v5
    
    * mks robin nano v1.2 + tft 35 ok!
    
    * right pin name
    
    * anycubic tft tested in a TRIGORILLA_PRO
    
    * chitu v6
    
    * nano 32 tft orientation
    
    * mks tft43
    
    * mks tft43 rotation
    
    * fixed LONGER LK tft setup
    
    * GRAPHICAL_TFT_UPSCALE defined by the display type
    
    * better offsets defaults
    
    * Update Configuration.h
    
    * Update tft_fsmc.cpp
    
    * Update Conditionals_LCD.h
    
    * Tweak comments
    
    * update nano tests
    
    * Revert "update nano tests"
    
    This reverts commit a071ebbfad30e28855a4a5695ec8a726542a1a65.
    
    * default tft
    
    * outdated comments
    
    * to not break non-vscode builds
    
    * upscale tft 35
    
    * support tft 180 rotation for color ui
    
    * Each TFT Driver is responsible for its default color mode.
    
    * use auto detect in mks displays, because some of them could be shipped with diferent drivers
    
    * extra s
    
    * unused code
    
    * wrong -1
    
    * missing mirror options
    
    * Smaller regex pattern
    
    * Comment updates
    
    * Clean up old defines
    
    * Apply pins formatting
    
    * GRAPHICAL_TFT_ROTATE_180 => TFT_ROTATE_180
    
    * MKS_ROBIN_TFT_V1_1R
    
    * merge fix
    
    * correct resolution
    
    * auto is default, dont need be there, and it will allow the user to configure it even for named displays
    
    * to not use rotation with MKS_ROBIN_TFT_V1_1R
    
    * i like () in macros
    
    * avoid sleepy commits
    
    * default for st7789 is rgb
    
    * nano follow up
    
    * to allow ili9328 rotation
    
    * default is rgb
    
    * boards merge follow up
    
    * to match bootloader orientation
    
    * HAS_TOUCH_XPT2046 is not hal specific anymore
    
    * lets not forget LPC
    
    * 180 rotation for ili9328 and R61505
    
    * Clean up whitespace
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 458620801b..d600b09a5f 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -23,9 +23,7 @@
 
 #if HAS_TFT_LVGL_UI
 
-#if ENABLED(TFT_LVGL_UI_SPI)
-  #include "SPI_TFT.h"
-#endif
+#include "SPI_TFT.h"
 
 #include "tft_lvgl_configuration.h"
 
@@ -165,7 +163,7 @@ void gCfgItems_init() {
     W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&custom_gcode_command[4], OTHERS_COMMAND_ADDR_4, 100);
   }
 
-  const byte rot = TERN0(GRAPHICAL_TFT_ROTATE_180, 0xEE);
+  const byte rot = (TFT_ROTATION & TFT_ROTATE_180) ? 0xEE : 0x00;
   if (gCfgItems.disp_rotation_180 != rot) {
     gCfgItems.disp_rotation_180 = rot;
     update_spi_flash();
@@ -655,12 +653,7 @@ char *creat_title_text() {
         }
 
         card.setIndex((gPicturePreviewStart + To_pre_view) + size * row + 8);
-        #if ENABLED(TFT_LVGL_UI_SPI)
-          SPI_TFT.SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
-        #else
-          LCD_setWindowArea(xpos_pixel, ypos_pixel + row, 200, 1);
-          LCD_WriteRAM_Prepare();
-        #endif
+        SPI_TFT.setWindow(xpos_pixel, ypos_pixel + row, 200, 1);
 
         j = i = 0;
 
@@ -673,20 +666,11 @@ char *creat_title_text() {
           }
           if (j >= 400) break;
         }
-        #if ENABLED(TFT_LVGL_UI_SPI)
-          for (i = 0; i < 400; i += 2) {
-            p_index  = (uint16_t *)(&bmp_public_buf[i]);
-            if (*p_index == 0x0000) *p_index = LV_COLOR_BACKGROUND.full;
-          }
-          SPI_TFT.tftio.WriteSequence((uint16_t*)bmp_public_buf, 200);
-        #else
-          for (i = 0; i < 400;) {
-            p_index = (uint16_t *)(&bmp_public_buf[i]);
-            if (*p_index == 0x0000) *p_index = LV_COLOR_BACKGROUND.full; //gCfgItems.preview_bk_color;
-            LCD_IO_WriteData(*p_index);
-            i += 2;
-          }
-        #endif
+        for (i = 0; i < 400; i += 2) {
+          p_index  = (uint16_t *)(&bmp_public_buf[i]);
+          if (*p_index == 0x0000) *p_index = LV_COLOR_BACKGROUND.full;
+        }
+        SPI_TFT.tftio.WriteSequence((uint16_t*)bmp_public_buf, 200);
         #if HAS_BAK_VIEW_IN_FLASH
           W25QXX.init(SPI_QUARTER_SPEED);
           if (row < 20) W25QXX.SPI_FLASH_SectorErase(BAK_VIEW_ADDR_TFT35 + row * 4096);
@@ -768,7 +752,7 @@ char *creat_title_text() {
 
         card.setIndex((PREVIEW_LITTLE_PIC_SIZE + To_pre_view) + size * row + 8);
         #if ENABLED(TFT_LVGL_UI_SPI)
-          SPI_TFT.SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
+          SPI_TFT.setWindow(xpos_pixel, ypos_pixel + row, 200, 1);
         #else
           LCD_setWindowArea(xpos_pixel, ypos_pixel + row, 200, 1);
           LCD_WriteRAM_Prepare();
@@ -901,34 +885,9 @@ char *creat_title_text() {
         default_view_Read(bmp_public_buf, DEFAULT_VIEW_MAX_SIZE / 10); // 8k
       #endif
 
-      #if ENABLED(TFT_LVGL_UI_SPI)
-        SPI_TFT.SetWindows(xpos_pixel, y_off * 20 + ypos_pixel, 200, 20); // 200*200
-        SPI_TFT.tftio.WriteSequence((uint16_t*)(bmp_public_buf), DEFAULT_VIEW_MAX_SIZE / 20);
-      #else
-        int x_off = 0;
-        uint16_t temp_p;
-        int i = 0;
-        uint16_t *p_index;
-        LCD_setWindowArea(xpos_pixel, y_off * 20 + ypos_pixel, 200, 20); // 200*200
-
-        LCD_WriteRAM_Prepare();
-
-        for (int _y = y_off * 20; _y < (y_off + 1) * 20; _y++) {
-          for (x_off = 0; x_off < 200; x_off++) {
-            if (sel == 1) {
-              temp_p  = (uint16_t)(bmp_public_buf[i] | bmp_public_buf[i + 1] << 8);
-              p_index = &temp_p;
-            }
-            else {
-              p_index = (uint16_t *)(&bmp_public_buf[i]);
-            }
-            if (*p_index == 0x0000) *p_index = LV_COLOR_BACKGROUND.full; //gCfgItems.preview_bk_color;
-            LCD_IO_WriteData(*p_index);
-            i += 2;
-          }
-          if (i >= 8000) break;
-        }
-      #endif // TFT_LVGL_UI_SPI
+      SPI_TFT.setWindow(xpos_pixel, y_off * 20 + ypos_pixel, 200, 20); // 200*200
+      SPI_TFT.tftio.WriteSequence((uint16_t*)(bmp_public_buf), DEFAULT_VIEW_MAX_SIZE / 20);
+
       y_off++;
     }
     W25QXX.init(SPI_QUARTER_SPEED);

commit 6831341ab483a49d7daad4c704bb684d3cbbf075
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 9 16:50:17 2020 -0500

    Batch appercase hex values

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 922f6a2dc7..458620801b 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -378,7 +378,7 @@ void tft_style_init() {
   style_sel_text.text.letter_space  = 0;
   style_sel_text.text.line_space    = -5;
   lv_style_copy(&style_line, &lv_style_plain);
-  style_line.line.color   = LV_COLOR_MAKE(0x49, 0x54, 0xff);
+  style_line.line.color   = LV_COLOR_MAKE(0x49, 0x54, 0xFF);
   style_line.line.width   = 1;
   style_line.line.rounded = 1;
 
@@ -703,12 +703,12 @@ char *creat_title_text() {
           card.closefile();
 
           /*
-          if (gCurFileState.file_open_flag != 0xaa) {
+          if (gCurFileState.file_open_flag != 0xAA) {
             reset_file_info();
             res = f_open(file, curFileName, FA_OPEN_EXISTING | FA_READ);
             if (res == FR_OK) {
               f_lseek(file,PREVIEW_SIZE+To_pre_view);
-              gCurFileState.file_open_flag = 0xaa;
+              gCurFileState.file_open_flag = 0xAA;
               //bakup_file_path((uint8_t *)curFileName, strlen(curFileName));
               srcfp = file;
               mksReprint.mks_printer_state = MKS_WORKING;
@@ -803,7 +803,7 @@ char *creat_title_text() {
             p_index = (uint16_t *)(&bmp_public_buf[i]);
 
             Color    = (*p_index >> 8);
-            *p_index = Color | ((*p_index & 0xff) << 8);
+            *p_index = Color | ((*p_index & 0xFF) << 8);
             i       += 2;
             if (*p_index == 0x0000) *p_index = 0xC318;
           }
@@ -835,12 +835,12 @@ char *creat_title_text() {
           card.closefile();
 
           /*
-          if (gCurFileState.file_open_flag != 0xaa) {
+          if (gCurFileState.file_open_flag != 0xAA) {
             reset_file_info();
             res = f_open(file, curFileName, FA_OPEN_EXISTING | FA_READ);
             if (res == FR_OK) {
               f_lseek(file,PREVIEW_SIZE+To_pre_view);
-              gCurFileState.file_open_flag = 0xaa;
+              gCurFileState.file_open_flag = 0xAA;
               //bakup_file_path((uint8_t *)curFileName, strlen(curFileName));
               srcfp = file;
               mksReprint.mks_printer_state = MKS_WORKING;
@@ -1650,7 +1650,7 @@ void print_time_count() {
 void LV_TASK_HANDLER() {
   //lv_tick_inc(1);
   lv_task_handler();
-  if (mks_test_flag == 0x1e) mks_hardware_test();
+  if (mks_test_flag == 0x1E) mks_hardware_test();
 
   #if HAS_GCODE_PREVIEW
     disp_pre_gcode(2, 36);

commit d8ed74904559aa8bdccc8b68acbccfbf1bf779d3
Author: makerbase <4164049@qq.com>
Date:   Mon Sep 21 09:55:02 2020 +0800

    Add MKS Robin E3P, improve LVGL UI (#19442)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 6bdea3fd21..922f6a2dc7 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -55,7 +55,8 @@ DISP_STATE_STACK disp_state_stack;
 DISP_STATE disp_state = MAIN_UI;
 DISP_STATE last_disp_state;
 PRINT_TIME print_time;
-value_state value;
+num_key_value_state value;
+keyboard_value_state keyboard_value;
 
 uint32_t To_pre_view;
 uint8_t gcode_preview_over;
@@ -73,6 +74,14 @@ extern uint8_t bmp_public_buf[17 * 1024];
 
 extern void LCD_IO_WriteData(uint16_t RegValue);
 
+static const char custom_gcode_command[][100] = {
+  "G28\nG29\nM500",
+  "G28",
+  "G28",
+  "G28",
+  "G28"
+};
+
 lv_point_t line_points[4][2] = {
   {{PARA_UI_POS_X, PARA_UI_POS_Y + PARA_UI_SIZE_Y}, {TFT_WIDTH, PARA_UI_POS_Y + PARA_UI_SIZE_Y}},
   {{PARA_UI_POS_X, PARA_UI_POS_Y*2 + PARA_UI_SIZE_Y}, {TFT_WIDTH, PARA_UI_POS_Y*2 + PARA_UI_SIZE_Y}},
@@ -108,22 +117,58 @@ void gCfgItems_init() {
   #elif LCD_LANGUAGE == pt
     gCfgItems.language = LANG_PORTUGUESE;
   #endif
-  gCfgItems.leveling_mode    = 0;
-  gCfgItems.from_flash_pic   = 0;
-  gCfgItems.curFilesize      = 0;
-  gCfgItems.finish_power_off = 0;
-  gCfgItems.pause_reprint    = 0;
-  gCfgItems.pausePosX        = -1;
-  gCfgItems.pausePosY        = -1;
-  gCfgItems.pausePosZ        = 5;
+  gCfgItems.leveling_mode     = 0;
+  gCfgItems.from_flash_pic    = 0;
+  gCfgItems.curFilesize       = 0;
+  gCfgItems.finish_power_off  = 0;
+  gCfgItems.pause_reprint     = 0;
+  gCfgItems.pausePosX         = -1;
+  gCfgItems.pausePosY         = -1;
+  gCfgItems.pausePosZ         = 5;
+  gCfgItems.levelingPos[0][0] = X_MIN_POS + 30;
+  gCfgItems.levelingPos[0][1] = Y_MIN_POS + 30;
+  gCfgItems.levelingPos[1][0] = X_MAX_POS - 30;
+  gCfgItems.levelingPos[1][1] = Y_MIN_POS + 30;
+  gCfgItems.levelingPos[2][0] = X_MAX_POS - 30;
+  gCfgItems.levelingPos[2][1] = Y_MAX_POS - 30;
+  gCfgItems.levelingPos[3][0] = X_MIN_POS + 30;
+  gCfgItems.levelingPos[3][1] = Y_MAX_POS - 30;
+  gCfgItems.levelingPos[4][0] = X_BED_SIZE / 2;
+  gCfgItems.levelingPos[4][1] = Y_BED_SIZE / 2;
+  gCfgItems.cloud_enable  = true;
+  #if ENABLED(USE_WIFI_FUNCTION)
+    gCfgItems.wifi_mode_sel = STA_MODEL;
+    gCfgItems.fileSysType   = FILE_SYS_SD;
+    gCfgItems.wifi_type     = ESP_WIFI;
+  #endif
+  gCfgItems.filamentchange_load_length   = 200;
+  gCfgItems.filamentchange_load_speed    = 1000;
+  gCfgItems.filamentchange_unload_length = 200;
+  gCfgItems.filamentchange_unload_speed  = 1000;
+  gCfgItems.filament_limit_temper        = 200;
+
+  gCfgItems.encoder_enable = true;
+
   W25QXX.SPI_FLASH_BufferRead((uint8_t *)&gCfgItems.spi_flash_flag, VAR_INF_ADDR, sizeof(gCfgItems.spi_flash_flag));
-  if (gCfgItems.spi_flash_flag == GCFG_FLAG_VALUE) {
+  if (gCfgItems.spi_flash_flag == FLASH_INF_VALID_FLAG) {
     W25QXX.SPI_FLASH_BufferRead((uint8_t *)&gCfgItems, VAR_INF_ADDR, sizeof(gCfgItems));
   }
   else {
-    gCfgItems.spi_flash_flag = GCFG_FLAG_VALUE;
+    gCfgItems.spi_flash_flag = FLASH_INF_VALID_FLAG;
     W25QXX.SPI_FLASH_SectorErase(VAR_INF_ADDR);
     W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&gCfgItems, VAR_INF_ADDR, sizeof(gCfgItems));
+    //init gcode command
+    W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&custom_gcode_command[0], AUTO_LEVELING_COMMAND_ADDR, 100);
+    W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&custom_gcode_command[1], OTHERS_COMMAND_ADDR_1, 100);
+    W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&custom_gcode_command[2], OTHERS_COMMAND_ADDR_2, 100);
+    W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&custom_gcode_command[3], OTHERS_COMMAND_ADDR_3, 100);
+    W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&custom_gcode_command[4], OTHERS_COMMAND_ADDR_4, 100);
+  }
+
+  const byte rot = TERN0(GRAPHICAL_TFT_ROTATE_180, 0xEE);
+  if (gCfgItems.disp_rotation_180 != rot) {
+    gCfgItems.disp_rotation_180 = rot;
+    update_spi_flash();
   }
 
   uiCfg.F[0] = 'N';
@@ -134,11 +179,6 @@ void gCfgItems_init() {
   W25QXX.SPI_FLASH_BufferWrite(uiCfg.F,REFLSHE_FLGA_ADD,4);
 }
 
-void gCfg_to_spiFlah() {
-  W25QXX.SPI_FLASH_SectorErase(VAR_INF_ADDR);
-  W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&gCfgItems, VAR_INF_ADDR, sizeof(gCfgItems));
-}
-
 void ui_cfg_init() {
   uiCfg.curTempType         = 0;
   uiCfg.curSprayerChoose    = 0;
@@ -150,12 +190,81 @@ void ui_cfg_init() {
   uiCfg.move_dist           = 1;
   uiCfg.moveSpeed           = 3000;
   uiCfg.stepPrintSpeed      = 10;
+  uiCfg.command_send        = 0;
+  uiCfg.dialogType          = 0;
+  uiCfg.filament_heat_completed_load = 0;
+  uiCfg.filament_rate                = 0;
+  uiCfg.filament_loading_completed   = 0;
+  uiCfg.filament_unloading_completed = 0;
+  uiCfg.filament_loading_time_flg    = 0;
+  uiCfg.filament_loading_time_cnt    = 0;
+  uiCfg.filament_unloading_time_flg  = 0;
+  uiCfg.filament_unloading_time_cnt  = 0;
+
+  #if ENABLED(USE_WIFI_FUNCTION)
+    memset(&wifiPara, 0, sizeof(wifiPara));
+    memset(&ipPara, 0, sizeof(ipPara));
+    strcpy(wifiPara.ap_name, WIFI_AP_NAME);
+    strcpy(wifiPara.keyCode, WIFI_KEY_CODE);
+    //client
+    strcpy(ipPara.ip_addr, IP_ADDR);
+    strcpy(ipPara.mask, IP_MASK);
+    strcpy(ipPara.gate, IP_GATE);
+    strcpy(ipPara.dns, IP_DNS);
+
+    ipPara.dhcp_flag = IP_DHCP_FLAG;
+
+    //AP
+    strcpy(ipPara.dhcpd_ip, AP_IP_ADDR);
+    strcpy(ipPara.dhcpd_mask, AP_IP_MASK);
+    strcpy(ipPara.dhcpd_gate, AP_IP_GATE);
+    strcpy(ipPara.dhcpd_dns, AP_IP_DNS);
+    strcpy(ipPara.start_ip_addr, IP_START_IP);
+    strcpy(ipPara.end_ip_addr, IP_END_IP);
+
+    ipPara.dhcpd_flag = AP_IP_DHCP_FLAG;
+
+    strcpy((char*)uiCfg.cloud_hostUrl, "baizhongyun.cn");
+    uiCfg.cloud_port = 10086;
+  #endif
+
+  uiCfg.filament_loading_time = (uint32_t)((gCfgItems.filamentchange_load_length * 60.0 / gCfgItems.filamentchange_load_speed) + 0.5);
+  uiCfg.filament_unloading_time = (uint32_t)((gCfgItems.filamentchange_unload_length * 60.0 / gCfgItems.filamentchange_unload_speed) + 0.5);
 }
 
 void update_spi_flash() {
+  uint8_t command_buf[512];
+
+  W25QXX.init(SPI_QUARTER_SPEED);
+  //read back the gcode command befor erase spi flash
+  W25QXX.SPI_FLASH_BufferRead((uint8_t *)&command_buf, GCODE_COMMAND_ADDR, sizeof(command_buf));
+  W25QXX.SPI_FLASH_SectorErase(VAR_INF_ADDR);
+  W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&gCfgItems, VAR_INF_ADDR, sizeof(gCfgItems));
+  W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&command_buf, GCODE_COMMAND_ADDR, sizeof(command_buf));
+}
+
+void update_gcode_command(int addr,uint8_t *s) {
+  uint8_t command_buf[512];
+
   W25QXX.init(SPI_QUARTER_SPEED);
+  //read back the gcode command befor erase spi flash
+  W25QXX.SPI_FLASH_BufferRead((uint8_t *)&command_buf, GCODE_COMMAND_ADDR, sizeof(command_buf));
   W25QXX.SPI_FLASH_SectorErase(VAR_INF_ADDR);
   W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&gCfgItems, VAR_INF_ADDR, sizeof(gCfgItems));
+  switch (addr) {
+    case AUTO_LEVELING_COMMAND_ADDR: memcpy(&command_buf[0*100], s, 100); break;
+    case OTHERS_COMMAND_ADDR_1: memcpy(&command_buf[1*100], s, 100); break;
+    case OTHERS_COMMAND_ADDR_2: memcpy(&command_buf[2*100], s, 100); break;
+    case OTHERS_COMMAND_ADDR_3: memcpy(&command_buf[3*100], s, 100); break;
+    case OTHERS_COMMAND_ADDR_4: memcpy(&command_buf[4*100], s, 100); break;
+    default: break;
+  }
+  W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&command_buf, GCODE_COMMAND_ADDR, sizeof(command_buf));
+}
+
+void get_gcode_command(int addr,uint8_t *d) {
+  W25QXX.init(SPI_QUARTER_SPEED);
+  W25QXX.SPI_FLASH_BufferRead((uint8_t *)d, addr, 100);
 }
 
 lv_style_t tft_style_scr;
@@ -169,6 +278,13 @@ lv_style_t style_num_key_pre;
 lv_style_t style_num_key_rel;
 
 lv_style_t style_num_text;
+lv_style_t style_sel_text;
+
+lv_style_t style_para_value;
+lv_style_t style_para_back;
+
+lv_style_t lv_bar_style_indic;
+
 void tft_style_init() {
   lv_style_copy(&tft_style_scr, &lv_style_scr);
   tft_style_scr.body.main_color   = LV_COLOR_BACKGROUND;
@@ -197,12 +313,13 @@ void tft_style_init() {
   tft_style_label_rel.text.letter_space = 0;
   tft_style_label_pre.text.line_space   = -5;
   tft_style_label_rel.text.line_space   = -5;
+
   lv_style_copy(&style_para_value_pre, &lv_style_scr);
   lv_style_copy(&style_para_value_rel, &lv_style_scr);
   style_para_value_pre.body.main_color = LV_COLOR_BACKGROUND;
   style_para_value_pre.body.grad_color = LV_COLOR_BACKGROUND;
-  style_para_value_pre.text.color      = LV_COLOR_BLACK;
-  style_para_value_pre.text.sel_color  = LV_COLOR_BLACK;
+  style_para_value_pre.text.color      = LV_COLOR_TEXT;
+  style_para_value_pre.text.sel_color  = LV_COLOR_TEXT;
   style_para_value_rel.body.main_color = LV_COLOR_BACKGROUND;
   style_para_value_rel.body.grad_color = LV_COLOR_BACKGROUND;
   style_para_value_rel.text.color      = LV_COLOR_BLACK;
@@ -215,6 +332,7 @@ void tft_style_init() {
   style_para_value_rel.text.letter_space = 0;
   style_para_value_pre.text.line_space   = -5;
   style_para_value_rel.text.line_space   = -5;
+
   lv_style_copy(&style_num_key_pre, &lv_style_scr);
   lv_style_copy(&style_num_key_rel, &lv_style_scr);
   style_num_key_pre.body.main_color = LV_COLOR_KEY_BACKGROUND;
@@ -250,10 +368,48 @@ void tft_style_init() {
   style_num_text.text.letter_space = 0;
   style_num_text.text.line_space   = -5;
 
+  lv_style_copy(&style_sel_text, &lv_style_scr);
+  style_sel_text.body.main_color  = LV_COLOR_BACKGROUND;
+  style_sel_text.body.grad_color  = LV_COLOR_BACKGROUND;
+  style_sel_text.text.color       = LV_COLOR_YELLOW;
+  style_sel_text.text.sel_color   = LV_COLOR_YELLOW;
+  style_sel_text.text.font        = &gb2312_puhui32;
+  style_sel_text.line.width       = 0;
+  style_sel_text.text.letter_space  = 0;
+  style_sel_text.text.line_space    = -5;
   lv_style_copy(&style_line, &lv_style_plain);
   style_line.line.color   = LV_COLOR_MAKE(0x49, 0x54, 0xff);
   style_line.line.width   = 1;
   style_line.line.rounded = 1;
+
+  lv_style_copy(&style_para_value, &lv_style_plain);
+  style_para_value.body.border.color = LV_COLOR_BACKGROUND;
+  style_para_value.body.border.width = 1;
+  style_para_value.body.main_color   = LV_COLOR_WHITE;
+  style_para_value.body.grad_color   = LV_COLOR_WHITE;
+  style_para_value.body.shadow.width = 0;
+  style_para_value.body.radius       = 3;
+  style_para_value.text.color        = LV_COLOR_BLACK;
+  style_para_value.text.font         = &TERN(HAS_SPI_FLASH_FONT, gb2312_puhui32, lv_font_roboto_22);
+
+  lv_style_copy(&style_para_back, &lv_style_plain);
+  style_para_back.body.border.color = LV_COLOR_BACKGROUND;
+  style_para_back.body.border.width = 1;
+  style_para_back.body.main_color   = TFT_LV_PARA_BACK_BODY_COLOR;
+  style_para_back.body.grad_color   = TFT_LV_PARA_BACK_BODY_COLOR;
+  style_para_back.body.shadow.width = 0;
+  style_para_back.body.radius       = 3;
+  style_para_back.text.color        = LV_COLOR_WHITE;
+  style_para_back.text.font         = &TERN(HAS_SPI_FLASH_FONT, gb2312_puhui32, lv_font_roboto_22);
+
+  lv_style_copy(&lv_bar_style_indic, &lv_style_pretty_color);
+  lv_bar_style_indic.text.color        = lv_color_hex3(0xADF);
+  lv_bar_style_indic.image.color       = lv_color_hex3(0xADF);
+  lv_bar_style_indic.line.color        = lv_color_hex3(0xADF);
+  lv_bar_style_indic.body.main_color   = lv_color_hex3(0xADF);
+  lv_bar_style_indic.body.grad_color   = lv_color_hex3(0xADF);
+  lv_bar_style_indic.body.border.color = lv_color_hex3(0xADF);
+
 }
 
 #define MAX_TITLE_LEN 28
@@ -360,15 +516,14 @@ char *getDispText(int index) {
     case BIND_UI:
       strcpy(public_buf_l, cloud_menu.title);
       break;
-    case ZOFFSET_UI:
-      strcpy(public_buf_l, zoffset_menu.title);
-      break;
     case TOOL_UI:
       strcpy(public_buf_l, tool_menu.title);
       break;
     case WIFI_LIST_UI:
-      //strcpy(public_buf_l, list_menu.title);
-      break;
+      #if ENABLED(USE_WIFI_FUNCTION)
+        strcpy(public_buf_l, list_menu.title);
+        break;
+      #endif
     case MACHINE_PARA_UI:
       strcpy(public_buf_l, MachinePara_menu.title);
       break;
@@ -503,7 +658,7 @@ char *creat_title_text() {
         #if ENABLED(TFT_LVGL_UI_SPI)
           SPI_TFT.SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
         #else
-          ili9320_SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
+          LCD_setWindowArea(xpos_pixel, ypos_pixel + row, 200, 1);
           LCD_WriteRAM_Prepare();
         #endif
 
@@ -582,10 +737,10 @@ char *creat_title_text() {
             //saved_feedrate_percentage = feedrate_percentage;
             planner.flow_percentage[0] = 100;
             planner.e_factor[0]        = planner.flow_percentage[0] * 0.01;
-            if (EXTRUDERS == 2) {
+            #if HAS_MULTI_EXTRUDER
               planner.flow_percentage[1] = 100;
               planner.e_factor[1]        = planner.flow_percentage[1] * 0.01;
-            }
+            #endif
             card.startFileprint();
             TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
             once_flag = 0;
@@ -615,7 +770,7 @@ char *creat_title_text() {
         #if ENABLED(TFT_LVGL_UI_SPI)
           SPI_TFT.SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
         #else
-          ili9320_SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
+          LCD_setWindowArea(xpos_pixel, ypos_pixel + row, 200, 1);
           LCD_WriteRAM_Prepare();
         #endif
 
@@ -714,10 +869,10 @@ char *creat_title_text() {
             //saved_feedrate_percentage = feedrate_percentage;
             planner.flow_percentage[0] = 100;
             planner.e_factor[0]        = planner.flow_percentage[0] * 0.01;
-            if (EXTRUDERS == 2) {
+            #if HAS_MULTI_EXTRUDER
               planner.flow_percentage[1] = 100;
               planner.e_factor[1]        = planner.flow_percentage[1] * 0.01;
-            }
+            #endif
             card.startFileprint();
             TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
             once_flag = 0;
@@ -733,17 +888,17 @@ char *creat_title_text() {
   void Draw_default_preview(int xpos_pixel, int ypos_pixel, uint8_t sel) {
     int index;
     int y_off = 0;
-
+    W25QXX.init(SPI_QUARTER_SPEED);
     for (index = 0; index < 10; index++) { // 200*200
       #if HAS_BAK_VIEW_IN_FLASH
         if (sel == 1) {
           flash_view_Read(bmp_public_buf, 8000); // 20k
         }
         else {
-          default_view_Read(bmp_public_buf, DEFAULT_VIEW_MAX_SIZE / 10); // 20k
+          default_view_Read(bmp_public_buf, DEFAULT_VIEW_MAX_SIZE / 10); // 8k
         }
       #else
-        default_view_Read(bmp_public_buf, DEFAULT_VIEW_MAX_SIZE / 10); // 20k
+        default_view_Read(bmp_public_buf, DEFAULT_VIEW_MAX_SIZE / 10); // 8k
       #endif
 
       #if ENABLED(TFT_LVGL_UI_SPI)
@@ -754,7 +909,7 @@ char *creat_title_text() {
         uint16_t temp_p;
         int i = 0;
         uint16_t *p_index;
-        ili9320_SetWindows(xpos_pixel, y_off * 20 + ypos_pixel, 200, 20); // 200*200
+        LCD_setWindowArea(xpos_pixel, y_off * 20 + ypos_pixel, 200, 20); // 200*200
 
         LCD_WriteRAM_Prepare();
 
@@ -904,29 +1059,28 @@ void GUI_RefreshPage() {
       */
       break;
 
-    case WIFI_UI:
-      /*
-      if (wifi_refresh_flg == 1) {
-        disp_wifi_state();
-        wifi_refresh_flg = 0;
-      }
-      */
-      break;
+    #if ENABLED(USE_WIFI_FUNCTION)
+      case WIFI_UI:
+        if (temperature_change_frequency == 1) {
+          disp_wifi_state();
+          temperature_change_frequency = 0;
+        }
+        break;
+    #endif
+
     case BIND_UI:
       /*refresh_bind_ui();*/
       break;
 
     case FILAMENTCHANGE_UI:
-      /*
       if (temperature_change_frequency) {
         temperature_change_frequency = 0;
-        disp_filament_sprayer_temp();
+        disp_filament_temp();
       }
-      */
       break;
     case DIALOG_UI:
-      /*filament_dialog_handle();
-      wifi_scan_handle();*/
+      filament_dialog_handle();
+      TERN_(USE_WIFI_FUNCTION, wifi_scan_handle());
       break;
     case MESHLEVELING_UI:
       /*disp_zpos();*/
@@ -934,66 +1088,68 @@ void GUI_RefreshPage() {
     case HARDWARE_TEST_UI:
       break;
     case WIFI_LIST_UI:
-      /*
-      if (wifi_refresh_flg == 1) {
-        disp_wifi_list();
-        wifi_refresh_flg = 0;
-      }
-      */
+      #if ENABLED(USE_WIFI_FUNCTION)
+        if (printing_rate_update_flag == 1) {
+          disp_wifi_list();
+          printing_rate_update_flag = 0;
+        }
+      #endif
       break;
     case KEY_BOARD_UI:
       /*update_password_disp();
       update_join_state_disp();*/
       break;
-    case TIPS_UI:
-      /*
-      switch (tips_type) {
-        case TIPS_TYPE_JOINING:
-          if (wifi_link_state == WIFI_CONNECTED && strcmp((const char *)wifi_list.wifiConnectedName, (const char *)wifi_list.wifiName[wifi_list.nameIndex]) == 0) {
-            tips_disp.timer = TIPS_TIMER_STOP;
-            tips_disp.timer_count = 0;
-            Clear_Tips();
-            tips_type = TIPS_TYPE_WIFI_CONECTED;
-            draw_Tips();
-          }
-          if (tips_disp.timer_count >= 30) {
-            tips_disp.timer = TIPS_TIMER_STOP;
-            tips_disp.timer_count = 0;
-            Clear_Tips();
-            tips_type = TIPS_TYPE_TAILED_JOIN;
-            draw_Tips();
-          }
-          break;
-        case TIPS_TYPE_TAILED_JOIN:
-          if (tips_disp.timer_count >= 3) {
-            tips_disp.timer = TIPS_TIMER_STOP;
-            tips_disp.timer_count = 0;
-            last_disp_state = TIPS_UI;
-            Clear_Tips();
-            draw_Wifi_list();
-          }
-          break;
-        case TIPS_TYPE_WIFI_CONECTED:
-          if (tips_disp.timer_count >= 3) {
-            tips_disp.timer = TIPS_TIMER_STOP;
-            tips_disp.timer_count = 0;
-
-            last_disp_state = TIPS_UI;
-            Clear_Tips();
-            draw_Wifi();
-          }
-          break;
-        default: break;
-      }
-      */
-      break;
+    #if ENABLED(USE_WIFI_FUNCTION)
+      case WIFI_TIPS_UI:
+        switch (wifi_tips_type) {
+          case TIPS_TYPE_JOINING:
+            if (wifi_link_state == WIFI_CONNECTED && strcmp((const char *)wifi_list.wifiConnectedName,(const char *)wifi_list.wifiName[wifi_list.nameIndex]) == 0) {
+              tips_disp.timer = TIPS_TIMER_STOP;
+              tips_disp.timer_count = 0;
+
+              lv_clear_wifi_tips();
+              wifi_tips_type = TIPS_TYPE_WIFI_CONECTED;
+              lv_draw_wifi_tips();
+
+            }
+            if (tips_disp.timer_count >= 30 * 1000) {
+              tips_disp.timer = TIPS_TIMER_STOP;
+              tips_disp.timer_count = 0;
+              lv_clear_wifi_tips();
+              wifi_tips_type = TIPS_TYPE_TAILED_JOIN;
+              lv_draw_wifi_tips();
+            }
+            break;
+          case TIPS_TYPE_TAILED_JOIN:
+            if (tips_disp.timer_count >= 3 * 1000) {
+              tips_disp.timer = TIPS_TIMER_STOP;
+              tips_disp.timer_count = 0;
+
+              last_disp_state = WIFI_TIPS_UI;
+              lv_clear_wifi_tips();
+              lv_draw_wifi_list();
+            }
+            break;
+          case TIPS_TYPE_WIFI_CONECTED:
+            if (tips_disp.timer_count >= 3 * 1000) {
+              tips_disp.timer = TIPS_TIMER_STOP;
+              tips_disp.timer_count = 0;
+
+              last_disp_state = WIFI_TIPS_UI;
+              lv_clear_wifi_tips();
+              lv_draw_wifi();
+            }
+            break;
+          default: break;
+        }
+        break;
+    #endif
+
     case BABY_STEP_UI:
-      /*
       if (temperature_change_frequency == 1) {
         temperature_change_frequency = 0;
         disp_z_offset_value();
       }
-      */
       break;
     default: break;
   }
@@ -1060,9 +1216,11 @@ void clear_cur_ui() {
     case DISK_UI:
       //Clear_Disk();
       break;
-    case WIFI_UI:
-      //Clear_Wifi();
-      break;
+    #if ENABLED(USE_WIFI_FUNCTION)
+      case WIFI_UI:
+        lv_clear_wifi();
+        break;
+    #endif
     case MORE_UI:
       //Clear_more();
       break;
@@ -1078,15 +1236,20 @@ void clear_cur_ui() {
     case PRINT_MORE_UI:
       //Clear_Printmore();
       break;
+    case FILAMENTCHANGE_UI:
+      lv_clear_filament_change();
+      break;
     case LEVELING_UI:
       lv_clear_manualLevel();
       break;
     case BIND_UI:
       //Clear_Bind();
       break;
-    case ZOFFSET_UI:
-      //Clear_Zoffset();
-      break;
+    #if HAS_BED_PROBE
+      case NOZZLE_PROBE_OFFSET_UI:
+        lv_clear_auto_level_offset_settings();
+        break;
+    #endif
     case TOOL_UI:
       lv_clear_tool();
       break;
@@ -1096,15 +1259,19 @@ void clear_cur_ui() {
     case HARDWARE_TEST_UI:
       //Clear_Hardwaretest();
       break;
-    case WIFI_LIST_UI:
-      //Clear_Wifi_list();
-      break;
+    #if ENABLED(USE_WIFI_FUNCTION)
+      case WIFI_LIST_UI:
+          lv_clear_wifi_list();
+        break;
+    #endif
     case KEY_BOARD_UI:
-      //Clear_Keyboard();
-      break;
-    case TIPS_UI:
-      //Clear_Tips();
+      lv_clear_keyboard();
       break;
+    #if ENABLED(USE_WIFI_FUNCTION)
+      case WIFI_TIPS_UI:
+        lv_clear_wifi_tips();
+        break;
+    #endif
     case MACHINE_PARA_UI:
       lv_clear_machine_para();
       break;
@@ -1130,19 +1297,19 @@ void clear_cur_ui() {
       //Clear_EndstopType();
       break;
     case FILAMENT_SETTINGS_UI:
-      //Clear_FilamentSettings();
+      lv_clear_filament_settings();
       break;
     case LEVELING_SETTIGNS_UI:
       //Clear_LevelingSettings();
       break;
     case LEVELING_PARA_UI:
-      //Clear_LevelingPara();
+      lv_clear_level_settings();
       break;
     case DELTA_LEVELING_PARA_UI:
       //Clear_DeltaLevelPara();
       break;
-    case XYZ_LEVELING_PARA_UI:
-      //Clear_XYZLevelPara();
+    case MANUAL_LEVELING_POSIGION_UI:
+      lv_clear_manual_level_pos_settings();
       break;
     case MAXFEEDRATE_UI:
       lv_clear_max_feedrate_settings();
@@ -1183,7 +1350,7 @@ void clear_cur_ui() {
       lv_clear_number_key();
       break;
     case BABY_STEP_UI:
-      //Clear_babyStep();
+      lv_clear_baby_stepping();
       break;
     case PAUSE_POS_UI:
       lv_clear_pause_position();
@@ -1201,8 +1368,22 @@ void clear_cur_ui() {
           lv_clear_tmc_step_mode_settings();
           break;
       #endif
-    default:
+    #if ENABLED(USE_WIFI_FUNCTION)
+    case WIFI_SETTINGS_UI:
+      lv_clear_wifi_settings();
       break;
+    #endif
+    #if USE_SENSORLESS
+      case HOMING_SENSITIVITY_UI:
+        lv_clear_homing_sensitivity_settings();
+        break;
+    #endif
+    #if HAS_ROTARY_ENCODER
+      case ENCODER_SETTINGS_UI:
+        lv_clear_encoder_settings();
+        break;
+    #endif
+    default: break;
   }
   //GUI_Clear();
 }
@@ -1267,21 +1448,17 @@ void draw_return_ui() {
         lv_draw_about();
         break;
 
-        #if tan_mask
-          case LOG_UI:
-            //draw_Connect();
-            break;
-        #endif
-
       case CALIBRATE_UI:
         //draw_calibrate();
         break;
       case DISK_UI:
         //draw_Disk();
         break;
-      case WIFI_UI:
-        //draw_Wifi();
-        break;
+      #if ENABLED(USE_WIFI_FUNCTION)
+        case WIFI_UI:
+          lv_draw_wifi();
+          break;
+      #endif
       case MORE_UI:
         //draw_More();
         break;
@@ -1289,7 +1466,7 @@ void draw_return_ui() {
         //draw_printmore();
         break;
       case FILAMENTCHANGE_UI:
-        //draw_FilamentChange();
+        lv_draw_filament_change();
         break;
       case LEVELING_UI:
         lv_draw_manualLevel();
@@ -1297,13 +1474,11 @@ void draw_return_ui() {
       case BIND_UI:
         //draw_bind();
         break;
-
-        #if tan_mask
-          case ZOFFSET_UI:
-            //draw_Zoffset();
-            break;
-        #endif
-
+      #if HAS_BED_PROBE
+        case NOZZLE_PROBE_OFFSET_UI:
+          lv_draw_auto_level_offset_settings();
+          break;
+      #endif
       case TOOL_UI:
         lv_draw_tool();
         break;
@@ -1314,13 +1489,17 @@ void draw_return_ui() {
         //draw_Hardwaretest();
         break;
       case WIFI_LIST_UI:
-        //draw_Wifi_list();
+        #if ENABLED(USE_WIFI_FUNCTION)
+          lv_draw_wifi_list();
+        #endif
         break;
       case KEY_BOARD_UI:
-        //draw_Keyboard();
+        lv_draw_keyboard();
         break;
-      case TIPS_UI:
-        //draw_Tips();
+      case WIFI_TIPS_UI:
+        #if ENABLED(USE_WIFI_FUNCTION)
+          lv_draw_wifi_tips();
+        #endif
         break;
       case MACHINE_PARA_UI:
         lv_draw_machine_para();
@@ -1347,19 +1526,19 @@ void draw_return_ui() {
         //draw_EndstopType();
         break;
       case FILAMENT_SETTINGS_UI:
-        //draw_FilamentSettings();
+        lv_draw_filament_settings();
         break;
       case LEVELING_SETTIGNS_UI:
         //draw_LevelingSettings();
         break;
       case LEVELING_PARA_UI:
-        //draw_LevelingPara();
+        lv_draw_level_settings();
         break;
       case DELTA_LEVELING_PARA_UI:
         //draw_DeltaLevelPara();
         break;
-      case XYZ_LEVELING_PARA_UI:
-        //draw_XYZLevelPara();
+      case MANUAL_LEVELING_POSIGION_UI:
+        lv_draw_manual_level_pos_settings();
         break;
       case MAXFEEDRATE_UI:
         lv_draw_max_feedrate_settings();
@@ -1400,10 +1579,10 @@ void draw_return_ui() {
         lv_draw_number_key();
         break;
       case DIALOG_UI:
-        //draw_dialog(DialogType);
+        //draw_dialog(uiCfg.dialogType);
         break;
       case BABY_STEP_UI:
-        //draw_babyStep();
+        lv_draw_baby_stepping();
         break;
       case PAUSE_POS_UI:
         lv_draw_pause_position();
@@ -1421,6 +1600,21 @@ void draw_return_ui() {
             lv_draw_tmc_step_mode_settings();
             break;
         #endif
+      #if ENABLED(USE_WIFI_FUNCTION)
+        case WIFI_SETTINGS_UI:
+        lv_draw_wifi_settings();
+        break;
+      #endif
+      #if USE_SENSORLESS
+        case HOMING_SENSITIVITY_UI:
+          lv_draw_homing_sensitivity_settings();
+          break;
+      #endif
+      #if HAS_ROTARY_ENCODER
+        case ENCODER_SETTINGS_UI:
+          lv_draw_encoder_settings();
+          break;
+      #endif
       default: break;
     }
   }
@@ -1440,8 +1634,8 @@ void draw_return_ui() {
 #endif
 
 void lv_ex_line(lv_obj_t * line, lv_point_t *points) {
-  /*Copy the previous line and apply the new style*/
-  lv_line_set_points(line, points, 2);     /*Set the points*/
+  // Copy the previous line and apply the new style
+  lv_line_set_points(line, points, 2);     // Set the points
   lv_line_set_style(line, LV_LINE_STYLE_MAIN, &style_line);
   lv_obj_align(line, NULL, LV_ALIGN_IN_TOP_MID, 0, 0);
 }
@@ -1450,18 +1644,29 @@ extern volatile uint32_t systick_uptime_millis;
 
 void print_time_count() {
   if ((systick_uptime_millis % 1000) == 0)
-    if (print_time.start == 1) print_time.seconds++;
+  if (print_time.start == 1) print_time.seconds++;
 }
 
 void LV_TASK_HANDLER() {
   //lv_tick_inc(1);
   lv_task_handler();
   if (mks_test_flag == 0x1e) mks_hardware_test();
+
   #if HAS_GCODE_PREVIEW
     disp_pre_gcode(2, 36);
   #endif
+
   GUI_RefreshPage();
+
+  #if ENABLED(USE_WIFI_FUNCTION)
+    get_wifi_commands();
+  #endif
+
   //sd_detection();
+
+  #if HAS_ROTARY_ENCODER
+    if (gCfgItems.encoder_enable) lv_update_encoder();
+  #endif
 }
 
 #endif // HAS_TFT_LVGL_UI

commit 6759aff22036a9fd4ae9f9398cd6e142a31ebd3b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 10 17:34:41 2020 -0500

    Clean up W25QXXFlash class

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index ff9d0518d3..6bdea3fd21 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -49,7 +49,6 @@
   #include "../../../../feature/pause.h"
 #endif
 
-W25QXXFlash W25QXX;
 CFG_ITMES gCfgItems;
 UI_CFG uiCfg;
 DISP_STATE_STACK disp_state_stack;

commit a37cf2490054ece3c16f0caca26a02c3d33057c8
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Aug 21 20:54:21 2020 -0300

    Emulated DOGM via HAL TFT, XPT IO (#19017)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index dc5e4910e9..ff9d0518d3 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -653,10 +653,10 @@ char *creat_title_text() {
             i       += 2;
             if (*p_index == 0x0000) *p_index = 0xC318;
           }
-          SPI_TFT_CS_L;
-          SPI_TFT_DC_H;
+          TFT_CS_L;
+          TFT_DC_H;
           SPI.dmaSend(bmp_public_buf, 400, true);
-          SPI_TFT_CS_H;
+          TFT_CS_H;
 
         #else
           for (i = 0; i < 400;) {

commit ff5c8d35705df99f385a6b27163380a249c2e646
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Thu Aug 13 20:31:59 2020 -0300

    Optimize LVGL with HAL TFT IO (SPI and FSMC) (#18974)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 5d87eb9f87..dc5e4910e9 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -500,14 +500,9 @@ char *creat_title_text() {
           }
         }
 
-        //SERIAL_ECHOLNPAIR("gPicturePreviewStart: ", gPicturePreviewStart, " PREVIEW_LITTLE_PIC_SIZE: ", PREVIEW_LITTLE_PIC_SIZE);
-
         card.setIndex((gPicturePreviewStart + To_pre_view) + size * row + 8);
         #if ENABLED(TFT_LVGL_UI_SPI)
-          SPI_TFT.spi_init(SPI_FULL_SPEED);
-          //SPI_TFT.SetCursor(0,0);
           SPI_TFT.SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
-          SPI_TFT.LCD_WriteRAM_Prepare();
         #else
           ili9320_SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
           LCD_WriteRAM_Prepare();
@@ -525,19 +520,11 @@ char *creat_title_text() {
           if (j >= 400) break;
         }
         #if ENABLED(TFT_LVGL_UI_SPI)
-          uint16_t Color, SpiColor;
-          SpiColor = (LV_COLOR_BACKGROUND.full >> 8) | ((LV_COLOR_BACKGROUND.full & 0xFF) << 8);
-          for (i = 0; i < 400;) {
+          for (i = 0; i < 400; i += 2) {
             p_index  = (uint16_t *)(&bmp_public_buf[i]);
-            Color    = (*p_index >> 8);
-            *p_index = Color | ((*p_index & 0xFF) << 8);
-            i       += 2;
-            if (*p_index == 0x0000) *p_index = SpiColor;
+            if (*p_index == 0x0000) *p_index = LV_COLOR_BACKGROUND.full;
           }
-          SPI_TFT_CS_L;
-          SPI_TFT_DC_H;
-          SPI.dmaSend(bmp_public_buf, 400, true);
-          SPI_TFT_CS_H;
+          SPI_TFT.tftio.WriteSequence((uint16_t*)bmp_public_buf, 200);
         #else
           for (i = 0; i < 400;) {
             p_index = (uint16_t *)(&bmp_public_buf[i]);
@@ -627,10 +614,7 @@ char *creat_title_text() {
 
         card.setIndex((PREVIEW_LITTLE_PIC_SIZE + To_pre_view) + size * row + 8);
         #if ENABLED(TFT_LVGL_UI_SPI)
-          SPI_TFT.spi_init(SPI_FULL_SPEED);
-          //SPI_TFT.SetCursor(0,0);
           SPI_TFT.SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
-          SPI_TFT.LCD_WriteRAM_Prepare();
         #else
           ili9320_SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
           LCD_WriteRAM_Prepare();
@@ -750,9 +734,6 @@ char *creat_title_text() {
   void Draw_default_preview(int xpos_pixel, int ypos_pixel, uint8_t sel) {
     int index;
     int y_off = 0;
-    int _y;
-    uint16_t *p_index;
-    int i;
 
     for (index = 0; index < 10; index++) { // 200*200
       #if HAS_BAK_VIEW_IN_FLASH
@@ -761,58 +742,24 @@ char *creat_title_text() {
         }
         else {
           default_view_Read(bmp_public_buf, DEFAULT_VIEW_MAX_SIZE / 10); // 20k
-          #if ENABLED(TFT_LVGL_UI_SPI)
-            uint16_t Color;
-            for (i = 0; i < (DEFAULT_VIEW_MAX_SIZE / 10);) {
-              p_index = (uint16_t *)(&bmp_public_buf[i]);
-              Color = (*p_index >> 8);
-              *p_index = Color | ((*p_index & 0xff) << 8);
-              i += 2;
-            }
-          #endif
         }
       #else
         default_view_Read(bmp_public_buf, DEFAULT_VIEW_MAX_SIZE / 10); // 20k
-        #if ENABLED(TFT_LVGL_UI_SPI)
-          for (i = 0; i < (DEFAULT_VIEW_MAX_SIZE / 10);) {
-            p_index = (uint16_t *)(&bmp_public_buf[i]);
-            Color = (*p_index >> 8);
-            *p_index = Color | ((*p_index & 0xff) << 8);
-            i += 2;
-          }
-        #endif
       #endif
 
-      i = 0;
       #if ENABLED(TFT_LVGL_UI_SPI)
-
-        //SPI_TFT.spi_init(SPI_FULL_SPEED);
-        //SPI_TFT.SetWindows(xpos_pixel, y_off * 20+ypos_pixel, 200,20);     //200*200
-        //SPI_TFT.LCD_WriteRAM_Prepare();
-        int j = 0;
-        for (_y = y_off * 20; _y < (y_off + 1) * 20; _y++) {
-          SPI_TFT.spi_init(SPI_FULL_SPEED);
-          SPI_TFT.SetWindows(xpos_pixel, y_off * 20 + ypos_pixel + j, 200, 1); // 200*200
-          SPI_TFT.LCD_WriteRAM_Prepare();
-
-          j++;
-          //memcpy(public_buf,&bmp_public_buf[i],400);
-          SPI_TFT_CS_L;
-          SPI_TFT_DC_H;
-          SPI.dmaSend(&bmp_public_buf[i], 400, true);
-          SPI_TFT_CS_H;
-
-          i += 400;
-          if (i >= 8000) break;
-        }
+        SPI_TFT.SetWindows(xpos_pixel, y_off * 20 + ypos_pixel, 200, 20); // 200*200
+        SPI_TFT.tftio.WriteSequence((uint16_t*)(bmp_public_buf), DEFAULT_VIEW_MAX_SIZE / 20);
       #else
         int x_off = 0;
         uint16_t temp_p;
+        int i = 0;
+        uint16_t *p_index;
         ili9320_SetWindows(xpos_pixel, y_off * 20 + ypos_pixel, 200, 20); // 200*200
 
         LCD_WriteRAM_Prepare();
 
-        for (_y = y_off * 20; _y < (y_off + 1) * 20; _y++) {
+        for (int _y = y_off * 20; _y < (y_off + 1) * 20; _y++) {
           for (x_off = 0; x_off < 200; x_off++) {
             if (sel == 1) {
               temp_p  = (uint16_t)(bmp_public_buf[i] | bmp_public_buf[i + 1] << 8);

commit 0a1b8659871f681464f24c40b16aa64cd2f7ca8e
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Aug 8 21:24:31 2020 -0300

    W25QXX SPI Flash support (#18897)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index e8899b9ad1..5d87eb9f87 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -27,7 +27,6 @@
   #include "SPI_TFT.h"
 #endif
 
-#include "W25Qxx.h"
 #include "tft_lvgl_configuration.h"
 
 #include "pic_manager.h"
@@ -50,6 +49,7 @@
   #include "../../../../feature/pause.h"
 #endif
 
+W25QXXFlash W25QXX;
 CFG_ITMES gCfgItems;
 UI_CFG uiCfg;
 DISP_STATE_STACK disp_state_stack;

commit 3eef000e2a7623d0d1d1f56fbf3109023f5d74c2
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sun Jul 26 01:08:30 2020 -0300

    Fix MKS Robin Nano V2 build / upload (#18784)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 5fb3bf6d73..e8899b9ad1 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -126,6 +126,13 @@ void gCfgItems_init() {
     W25QXX.SPI_FLASH_SectorErase(VAR_INF_ADDR);
     W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&gCfgItems, VAR_INF_ADDR, sizeof(gCfgItems));
   }
+
+  uiCfg.F[0] = 'N';
+  uiCfg.F[1] = 'A';
+  uiCfg.F[2] = 'N';
+  uiCfg.F[3] = 'O';
+  W25QXX.SPI_FLASH_BlockErase(REFLSHE_FLGA_ADD + 32 - 64*1024);
+  W25QXX.SPI_FLASH_BufferWrite(uiCfg.F,REFLSHE_FLGA_ADD,4);
 }
 
 void gCfg_to_spiFlah() {

commit bc688f27dc6db76021da584bc529f29ddb6f6cce
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jul 25 01:53:07 2020 -0500

    Clean up after changes

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 75e9b7cdc8..5fb3bf6d73 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -361,7 +361,7 @@ char *getDispText(int index) {
       strcpy(public_buf_l, tool_menu.title);
       break;
     case WIFI_LIST_UI:
-      // strcpy(public_buf_l, list_menu.title);
+      //strcpy(public_buf_l, list_menu.title);
       break;
     case MACHINE_PARA_UI:
       strcpy(public_buf_l, MachinePara_menu.title);
@@ -386,7 +386,7 @@ char *creat_title_text() {
   ZERO(tmpCurFileStr);
 
   #if _LFN_UNICODE
-    // cutFileName((TCHAR *)curFileName, 16, 16, (TCHAR *)tmpCurFileStr);
+    //cutFileName((TCHAR *)curFileName, 16, 16, (TCHAR *)tmpCurFileStr);
   #else
     cutFileName(list_file.long_name[sel_id], 16, 16, tmpCurFileStr);
   #endif
@@ -434,8 +434,8 @@ char *creat_title_text() {
 
   void preview_gcode_prehandle(char *path) {
     #if ENABLED(SDSUPPORT)
-      // uint8_t re;
-      // uint32_t read;
+      //uint8_t re;
+      //uint32_t read;
       uint32_t pre_read_cnt = 0;
       uint32_t *p1;
       char *cur_name;
@@ -468,11 +468,11 @@ char *creat_title_text() {
 
     void gcode_preview(char *path, int xpos_pixel, int ypos_pixel) {
       #if ENABLED(SDSUPPORT)
-        // uint8_t ress;
-        // uint32_t write;
+        //uint8_t ress;
+        //uint32_t write;
         volatile uint32_t i, j;
         volatile uint16_t *p_index;
-        // int res;
+        //int res;
         char *cur_name;
 
         cur_name = strrchr(path, '/');
@@ -493,12 +493,12 @@ char *creat_title_text() {
           }
         }
 
-        // SERIAL_ECHOLNPAIR("gPicturePreviewStart: ", gPicturePreviewStart, " PREVIEW_LITTLE_PIC_SIZE: ", PREVIEW_LITTLE_PIC_SIZE);
+        //SERIAL_ECHOLNPAIR("gPicturePreviewStart: ", gPicturePreviewStart, " PREVIEW_LITTLE_PIC_SIZE: ", PREVIEW_LITTLE_PIC_SIZE);
 
         card.setIndex((gPicturePreviewStart + To_pre_view) + size * row + 8);
         #if ENABLED(TFT_LVGL_UI_SPI)
           SPI_TFT.spi_init(SPI_FULL_SPEED);
-          // SPI_TFT.SetCursor(0,0);
+          //SPI_TFT.SetCursor(0,0);
           SPI_TFT.SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
           SPI_TFT.LCD_WriteRAM_Prepare();
         #else
@@ -534,7 +534,7 @@ char *creat_title_text() {
         #else
           for (i = 0; i < 400;) {
             p_index = (uint16_t *)(&bmp_public_buf[i]);
-            if (*p_index == 0x0000) *p_index = LV_COLOR_BACKGROUND.full; // gCfgItems.preview_bk_color;
+            if (*p_index == 0x0000) *p_index = LV_COLOR_BACKGROUND.full; //gCfgItems.preview_bk_color;
             LCD_IO_WriteData(*p_index);
             i += 2;
           }
@@ -550,7 +550,7 @@ char *creat_title_text() {
           row  = 0;
 
           gcode_preview_over = 0;
-          // flash_preview_begin = 1;
+          //flash_preview_begin = 1;
 
           card.closefile();
 
@@ -586,7 +586,7 @@ char *creat_title_text() {
           card.openFileRead(cur_name);
           if (card.isFileOpen()) {
             feedrate_percentage = 100;
-            // saved_feedrate_percentage = feedrate_percentage;
+            //saved_feedrate_percentage = feedrate_percentage;
             planner.flow_percentage[0] = 100;
             planner.e_factor[0]        = planner.flow_percentage[0] * 0.01;
             if (EXTRUDERS == 2) {
@@ -607,11 +607,11 @@ char *creat_title_text() {
 
     void gcode_preview(char *path, int xpos_pixel, int ypos_pixel) {
       #if ENABLED(SDSUPPORT)
-        // uint8_t ress;
-        // uint32_t write;
+        //uint8_t ress;
+        //uint32_t write;
         volatile uint32_t i, j;
         volatile uint16_t *p_index;
-        // int res;
+        //int res;
         char *cur_name;
         uint16_t Color;
 
@@ -621,7 +621,7 @@ char *creat_title_text() {
         card.setIndex((PREVIEW_LITTLE_PIC_SIZE + To_pre_view) + size * row + 8);
         #if ENABLED(TFT_LVGL_UI_SPI)
           SPI_TFT.spi_init(SPI_FULL_SPEED);
-          // SPI_TFT.SetCursor(0,0);
+          //SPI_TFT.SetCursor(0,0);
           SPI_TFT.SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
           SPI_TFT.LCD_WriteRAM_Prepare();
         #else
@@ -685,7 +685,7 @@ char *creat_title_text() {
           row  = 0;
 
           gcode_preview_over = 0;
-          // flash_preview_begin = 1;
+          //flash_preview_begin = 1;
 
           card.closefile();
 
@@ -721,7 +721,7 @@ char *creat_title_text() {
           card.openFileRead(cur_name);
           if (card.isFileOpen()) {
             feedrate_percentage = 100;
-            // saved_feedrate_percentage = feedrate_percentage;
+            //saved_feedrate_percentage = feedrate_percentage;
             planner.flow_percentage[0] = 100;
             planner.e_factor[0]        = planner.flow_percentage[0] * 0.01;
             if (EXTRUDERS == 2) {
@@ -779,9 +779,9 @@ char *creat_title_text() {
       i = 0;
       #if ENABLED(TFT_LVGL_UI_SPI)
 
-        // SPI_TFT.spi_init(SPI_FULL_SPEED);
-        // SPI_TFT.SetWindows(xpos_pixel, y_off * 20+ypos_pixel, 200,20);     //200*200
-        // SPI_TFT.LCD_WriteRAM_Prepare();
+        //SPI_TFT.spi_init(SPI_FULL_SPEED);
+        //SPI_TFT.SetWindows(xpos_pixel, y_off * 20+ypos_pixel, 200,20);     //200*200
+        //SPI_TFT.LCD_WriteRAM_Prepare();
         int j = 0;
         for (_y = y_off * 20; _y < (y_off + 1) * 20; _y++) {
           SPI_TFT.spi_init(SPI_FULL_SPEED);
@@ -789,7 +789,7 @@ char *creat_title_text() {
           SPI_TFT.LCD_WriteRAM_Prepare();
 
           j++;
-          // memcpy(public_buf,&bmp_public_buf[i],400);
+          //memcpy(public_buf,&bmp_public_buf[i],400);
           SPI_TFT_CS_L;
           SPI_TFT_DC_H;
           SPI.dmaSend(&bmp_public_buf[i], 400, true);
@@ -814,13 +814,13 @@ char *creat_title_text() {
             else {
               p_index = (uint16_t *)(&bmp_public_buf[i]);
             }
-            if (*p_index == 0x0000) *p_index = LV_COLOR_BACKGROUND.full; // gCfgItems.preview_bk_color;
+            if (*p_index == 0x0000) *p_index = LV_COLOR_BACKGROUND.full; //gCfgItems.preview_bk_color;
             LCD_IO_WriteData(*p_index);
             i += 2;
           }
           if (i >= 8000) break;
         }
-      #endif // if ENABLED(TFT_LVGL_UI_SPI)
+      #endif // TFT_LVGL_UI_SPI
       y_off++;
     }
     W25QXX.init(SPI_QUARTER_SPEED);
@@ -841,7 +841,7 @@ char *creat_title_text() {
       }
     #endif
   }
-#endif // if HAS_GCODE_PREVIEW
+#endif // HAS_GCODE_PREVIEW
 
 void print_time_run() {
   static uint8_t lastSec = 0;
@@ -866,7 +866,7 @@ void GUI_RefreshPage() {
 
   switch (disp_state) {
     case MAIN_UI:
-      // lv_draw_ready_print();
+      //lv_draw_ready_print();
       break;
     case EXTRUSION_UI:
       if (temperature_change_frequency == 1) {
@@ -1053,7 +1053,7 @@ void clear_cur_ui() {
 
   switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
     case PRINT_READY_UI:
-      // Get_Temperature_Flg = 0;
+      //Get_Temperature_Flg = 0;
       lv_clear_ready_print();
       break;
     case PRINT_FILE_UI:
@@ -1251,7 +1251,7 @@ void clear_cur_ui() {
     default:
       break;
   }
-  // GUI_Clear();
+  //GUI_Clear();
 }
 
 void draw_return_ui() {
@@ -1501,14 +1501,14 @@ void print_time_count() {
 }
 
 void LV_TASK_HANDLER() {
-  // lv_tick_inc(1);
+  //lv_tick_inc(1);
   lv_task_handler();
   if (mks_test_flag == 0x1e) mks_hardware_test();
   #if HAS_GCODE_PREVIEW
     disp_pre_gcode(2, 36);
   #endif
   GUI_RefreshPage();
-  // sd_detection();
+  //sd_detection();
 }
 
 #endif // HAS_TFT_LVGL_UI

commit d20d4591321aa467c062f0050355d2aca84e03ad
Author: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
Date:   Sat Jul 25 13:52:07 2020 +0800

    Robin nano V2, TFT LVGL UI parameters, and more (#18500)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index ef2a29a930..75e9b7cdc8 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -21,24 +21,27 @@
  */
 #include "../../../../inc/MarlinConfigPre.h"
 
-#if ENABLED(TFT_LVGL_UI)
+#if HAS_TFT_LVGL_UI
+
+#if ENABLED(TFT_LVGL_UI_SPI)
+  #include "SPI_TFT.h"
+#endif
 
 #include "W25Qxx.h"
 #include "tft_lvgl_configuration.h"
 
-#include <SPI.h>
+#include "pic_manager.h"
 
-#if ENABLED(SPI_GRAPHICAL_TFT)
-  #include "SPI_TFT.h"
-#endif
+#include "draw_ui.h"
+#include "mks_hardware_test.h"
+
+#include <SPI.h>
 
 #include "../../../../MarlinCore.h"
 #include "../../../../sd/cardreader.h"
 #include "../../../../module/motion.h"
 #include "../../../../module/planner.h"
 
-#include "pic_manager.h"
-
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../../feature/powerloss.h"
 #endif
@@ -47,14 +50,13 @@
   #include "../../../../feature/pause.h"
 #endif
 
-#include "draw_ui.h"
-
 CFG_ITMES gCfgItems;
 UI_CFG uiCfg;
 DISP_STATE_STACK disp_state_stack;
 DISP_STATE disp_state = MAIN_UI;
 DISP_STATE last_disp_state;
 PRINT_TIME print_time;
+value_state value;
 
 uint32_t To_pre_view;
 uint8_t gcode_preview_over;
@@ -72,9 +74,15 @@ extern uint8_t bmp_public_buf[17 * 1024];
 
 extern void LCD_IO_WriteData(uint16_t RegValue);
 
+lv_point_t line_points[4][2] = {
+  {{PARA_UI_POS_X, PARA_UI_POS_Y + PARA_UI_SIZE_Y}, {TFT_WIDTH, PARA_UI_POS_Y + PARA_UI_SIZE_Y}},
+  {{PARA_UI_POS_X, PARA_UI_POS_Y*2 + PARA_UI_SIZE_Y}, {TFT_WIDTH, PARA_UI_POS_Y*2 + PARA_UI_SIZE_Y}},
+  {{PARA_UI_POS_X, PARA_UI_POS_Y*3 + PARA_UI_SIZE_Y}, {TFT_WIDTH, PARA_UI_POS_Y*3 + PARA_UI_SIZE_Y}},
+  {{PARA_UI_POS_X, PARA_UI_POS_Y*4 + PARA_UI_SIZE_Y}, {TFT_WIDTH, PARA_UI_POS_Y*4 + PARA_UI_SIZE_Y}}
+};
 void gCfgItems_init() {
   gCfgItems.multiple_language = MULTI_LANGUAGE_ENABLE;
-  #if 1 //LCD_LANGUAGE == en
+  #if 1 // LCD_LANGUAGE == en
     gCfgItems.language = LANG_ENGLISH;
   #elif LCD_LANGUAGE == zh_CN
     gCfgItems.language = LANG_SIMPLE_CHINESE;
@@ -101,12 +109,14 @@ void gCfgItems_init() {
   #elif LCD_LANGUAGE == pt
     gCfgItems.language = LANG_PORTUGUESE;
   #endif
-  gCfgItems.leveling_mode = 0;
-  gCfgItems.from_flash_pic = 0;
-  gCfgItems.curFilesize = 0;
+  gCfgItems.leveling_mode    = 0;
+  gCfgItems.from_flash_pic   = 0;
+  gCfgItems.curFilesize      = 0;
   gCfgItems.finish_power_off = 0;
-  gCfgItems.pause_reprint = 0;
-
+  gCfgItems.pause_reprint    = 0;
+  gCfgItems.pausePosX        = -1;
+  gCfgItems.pausePosY        = -1;
+  gCfgItems.pausePosZ        = 5;
   W25QXX.SPI_FLASH_BufferRead((uint8_t *)&gCfgItems.spi_flash_flag, VAR_INF_ADDR, sizeof(gCfgItems.spi_flash_flag));
   if (gCfgItems.spi_flash_flag == GCFG_FLAG_VALUE) {
     W25QXX.SPI_FLASH_BufferRead((uint8_t *)&gCfgItems, VAR_INF_ADDR, sizeof(gCfgItems));
@@ -116,7 +126,6 @@ void gCfgItems_init() {
     W25QXX.SPI_FLASH_SectorErase(VAR_INF_ADDR);
     W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&gCfgItems, VAR_INF_ADDR, sizeof(gCfgItems));
   }
-
 }
 
 void gCfg_to_spiFlah() {
@@ -125,15 +134,16 @@ void gCfg_to_spiFlah() {
 }
 
 void ui_cfg_init() {
-  uiCfg.curTempType = 0;
-  uiCfg.curSprayerChoose = 0;
-  uiCfg.stepHeat = 10;
+  uiCfg.curTempType         = 0;
+  uiCfg.curSprayerChoose    = 0;
+  uiCfg.stepHeat            = 10;
   uiCfg.leveling_first_time = 0;
-  uiCfg.extruStep = 5;
-  uiCfg.extruSpeed = 10;
-  uiCfg.move_dist = 1;
-  uiCfg.moveSpeed = 3000;
-  uiCfg.stepPrintSpeed = 10;
+  uiCfg.para_ui_page        = 0;
+  uiCfg.extruStep           = 5;
+  uiCfg.extruSpeed          = 10;
+  uiCfg.move_dist           = 1;
+  uiCfg.moveSpeed           = 3000;
+  uiCfg.stepPrintSpeed      = 10;
 }
 
 void update_spi_flash() {
@@ -143,48 +153,106 @@ void update_spi_flash() {
 }
 
 lv_style_t tft_style_scr;
-lv_style_t tft_style_lable_pre;
-lv_style_t tft_style_lable_rel;
+lv_style_t tft_style_label_pre;
+lv_style_t tft_style_label_rel;
+lv_style_t style_line;
+lv_style_t style_para_value_pre;
+lv_style_t style_para_value_rel;
 
+lv_style_t style_num_key_pre;
+lv_style_t style_num_key_rel;
+
+lv_style_t style_num_text;
 void tft_style_init() {
   lv_style_copy(&tft_style_scr, &lv_style_scr);
-  tft_style_scr.body.main_color = LV_COLOR_BACKGROUND;
-  tft_style_scr.body.grad_color = LV_COLOR_BACKGROUND;
-  tft_style_scr.text.color = LV_COLOR_TEXT;
-  tft_style_scr.text.sel_color = LV_COLOR_TEXT;
-  tft_style_scr.line.width = 0;
+  tft_style_scr.body.main_color   = LV_COLOR_BACKGROUND;
+  tft_style_scr.body.grad_color   = LV_COLOR_BACKGROUND;
+  tft_style_scr.text.color        = LV_COLOR_TEXT;
+  tft_style_scr.text.sel_color    = LV_COLOR_TEXT;
+  tft_style_scr.line.width        = 0;
   tft_style_scr.text.letter_space = 0;
-  tft_style_scr.text.line_space = 0;
-
-  lv_style_copy(&tft_style_lable_pre, &lv_style_scr);
-  lv_style_copy(&tft_style_lable_rel, &lv_style_scr);
-  tft_style_lable_pre.body.main_color = LV_COLOR_BACKGROUND;
-  tft_style_lable_pre.body.grad_color = LV_COLOR_BACKGROUND;
-  tft_style_lable_pre.text.color = LV_COLOR_TEXT;
-  tft_style_lable_pre.text.sel_color = LV_COLOR_TEXT;
-  tft_style_lable_rel.body.main_color = LV_COLOR_BACKGROUND;
-  tft_style_lable_rel.body.grad_color = LV_COLOR_BACKGROUND;
-  tft_style_lable_rel.text.color = LV_COLOR_TEXT;
-  tft_style_lable_rel.text.sel_color = LV_COLOR_TEXT;
+  tft_style_scr.text.line_space   = 0;
+
+  lv_style_copy(&tft_style_label_pre, &lv_style_scr);
+  lv_style_copy(&tft_style_label_rel, &lv_style_scr);
+  tft_style_label_pre.body.main_color = LV_COLOR_BACKGROUND;
+  tft_style_label_pre.body.grad_color = LV_COLOR_BACKGROUND;
+  tft_style_label_pre.text.color      = LV_COLOR_TEXT;
+  tft_style_label_pre.text.sel_color  = LV_COLOR_TEXT;
+  tft_style_label_rel.body.main_color = LV_COLOR_BACKGROUND;
+  tft_style_label_rel.body.grad_color = LV_COLOR_BACKGROUND;
+  tft_style_label_rel.text.color      = LV_COLOR_TEXT;
+  tft_style_label_rel.text.sel_color  = LV_COLOR_TEXT;
+  tft_style_label_pre.text.font       = TERN(HAS_SPI_FLASH_FONT, &gb2312_puhui32, LV_FONT_DEFAULT);
+  tft_style_label_rel.text.font       = TERN(HAS_SPI_FLASH_FONT, &gb2312_puhui32, LV_FONT_DEFAULT);
+  tft_style_label_pre.line.width        = 0;
+  tft_style_label_rel.line.width        = 0;
+  tft_style_label_pre.text.letter_space = 0;
+  tft_style_label_rel.text.letter_space = 0;
+  tft_style_label_pre.text.line_space   = -5;
+  tft_style_label_rel.text.line_space   = -5;
+  lv_style_copy(&style_para_value_pre, &lv_style_scr);
+  lv_style_copy(&style_para_value_rel, &lv_style_scr);
+  style_para_value_pre.body.main_color = LV_COLOR_BACKGROUND;
+  style_para_value_pre.body.grad_color = LV_COLOR_BACKGROUND;
+  style_para_value_pre.text.color      = LV_COLOR_BLACK;
+  style_para_value_pre.text.sel_color  = LV_COLOR_BLACK;
+  style_para_value_rel.body.main_color = LV_COLOR_BACKGROUND;
+  style_para_value_rel.body.grad_color = LV_COLOR_BACKGROUND;
+  style_para_value_rel.text.color      = LV_COLOR_BLACK;
+  style_para_value_rel.text.sel_color  = LV_COLOR_BLACK;
+  style_para_value_pre.text.font       = TERN(HAS_SPI_FLASH_FONT, &gb2312_puhui32, LV_FONT_DEFAULT);
+  style_para_value_rel.text.font       = TERN(HAS_SPI_FLASH_FONT, &gb2312_puhui32, LV_FONT_DEFAULT);
+  style_para_value_pre.line.width        = 0;
+  style_para_value_rel.line.width        = 0;
+  style_para_value_pre.text.letter_space = 0;
+  style_para_value_rel.text.letter_space = 0;
+  style_para_value_pre.text.line_space   = -5;
+  style_para_value_rel.text.line_space   = -5;
+  lv_style_copy(&style_num_key_pre, &lv_style_scr);
+  lv_style_copy(&style_num_key_rel, &lv_style_scr);
+  style_num_key_pre.body.main_color = LV_COLOR_KEY_BACKGROUND;
+  style_num_key_pre.body.grad_color = LV_COLOR_KEY_BACKGROUND;
+  style_num_key_pre.text.color      = LV_COLOR_TEXT;
+  style_num_key_pre.text.sel_color  = LV_COLOR_TEXT;
+  style_num_key_rel.body.main_color = LV_COLOR_KEY_BACKGROUND;
+  style_num_key_rel.body.grad_color = LV_COLOR_KEY_BACKGROUND;
+  style_num_key_rel.text.color      = LV_COLOR_TEXT;
+  style_num_key_rel.text.sel_color  = LV_COLOR_TEXT;
   #if HAS_SPI_FLASH_FONT
-    tft_style_lable_pre.text.font = &gb2312_puhui32;
-    tft_style_lable_rel.text.font = &gb2312_puhui32;
+    style_num_key_pre.text.font = &gb2312_puhui32;
+    style_num_key_rel.text.font = &gb2312_puhui32;
   #else
-    tft_style_lable_pre.text.font = LV_FONT_DEFAULT;
-    tft_style_lable_rel.text.font = LV_FONT_DEFAULT;
+    style_num_key_pre.text.font = LV_FONT_DEFAULT;
+    style_num_key_rel.text.font = LV_FONT_DEFAULT;
   #endif
-  tft_style_lable_pre.line.width = 0;
-  tft_style_lable_rel.line.width = 0;
-  tft_style_lable_pre.text.letter_space = 0;
-  tft_style_lable_rel.text.letter_space = 0;
-  tft_style_lable_pre.text.line_space = -5;
-  tft_style_lable_rel.text.line_space = -5;
+
+  style_num_key_pre.line.width        = 0;
+  style_num_key_rel.line.width        = 0;
+  style_num_key_pre.text.letter_space = 0;
+  style_num_key_rel.text.letter_space = 0;
+  style_num_key_pre.text.line_space   = -5;
+  style_num_key_rel.text.line_space   = -5;
+  lv_style_copy(&style_num_text, &lv_style_scr);
+
+  style_num_text.body.main_color   = LV_COLOR_WHITE;
+  style_num_text.body.grad_color   = LV_COLOR_WHITE;
+  style_num_text.text.color        = LV_COLOR_BLACK;
+  style_num_text.text.sel_color    = LV_COLOR_BLACK;
+  style_num_text.text.font         = TERN(HAS_SPI_FLASH_FONT, &gb2312_puhui32, LV_FONT_DEFAULT);
+  style_num_text.line.width        = 0;
+  style_num_text.text.letter_space = 0;
+  style_num_text.text.line_space   = -5;
+
+  lv_style_copy(&style_line, &lv_style_plain);
+  style_line.line.color   = LV_COLOR_MAKE(0x49, 0x54, 0xff);
+  style_line.line.width   = 1;
+  style_line.line.rounded = 1;
 }
 
 #define MAX_TITLE_LEN 28
 
 char public_buf_m[100] = {0};
-
 char public_buf_l[30];
 
 void titleText_cat(char *str, int strSize, char *addPart) {
@@ -195,7 +263,7 @@ void titleText_cat(char *str, int strSize, char *addPart) {
 
 char *getDispText(int index) {
 
-  memset(public_buf_l, 0, sizeof(public_buf_l));
+  ZERO(public_buf_l);
 
   switch (disp_state_stack._disp_state[index]) {
     case PRINT_READY_UI:
@@ -206,11 +274,11 @@ char *getDispText(int index) {
       break;
     case PRINTING_UI:
       if (disp_state_stack._disp_state[disp_state_stack._disp_index] == PRINTING_UI
-          #ifndef TFT35
-            || disp_state_stack._disp_state[disp_state_stack._disp_index] == OPERATE_UI
-            || disp_state_stack._disp_state[disp_state_stack._disp_index] == PAUSE_UI
-          #endif
-          ) strcpy(public_buf_l, common_menu.print_special_title);
+        #ifndef TFT35
+          || disp_state_stack._disp_state[disp_state_stack._disp_index] == OPERATE_UI
+          || disp_state_stack._disp_state[disp_state_stack._disp_index] == PAUSE_UI
+        #endif
+      )    strcpy(public_buf_l, common_menu.print_special_title);
       else strcpy(public_buf_l, printing_menu.title);
       break;
     case MOVE_MOTOR_UI:
@@ -218,19 +286,19 @@ char *getDispText(int index) {
       break;
     case OPERATE_UI:
       if (disp_state_stack._disp_state[disp_state_stack._disp_index] == PRINTING_UI
-          #ifndef TFT35
-            || disp_state_stack._disp_state[disp_state_stack._disp_index] == OPERATE_UI
-            || disp_state_stack._disp_state[disp_state_stack._disp_index] == PAUSE_UI
-          #endif
-          ) strcpy(public_buf_l, common_menu.operate_special_title);
+        #ifndef TFT35
+          || disp_state_stack._disp_state[disp_state_stack._disp_index] == OPERATE_UI
+          || disp_state_stack._disp_state[disp_state_stack._disp_index] == PAUSE_UI
+        #endif
+      )    strcpy(public_buf_l, common_menu.operate_special_title);
       else strcpy(public_buf_l, operation_menu.title);
       break;
 
     case PAUSE_UI:
       if (disp_state_stack._disp_state[disp_state_stack._disp_index] == PRINTING_UI
-          || disp_state_stack._disp_state[disp_state_stack._disp_index] == OPERATE_UI
-          || disp_state_stack._disp_state[disp_state_stack._disp_index] == PAUSE_UI
-          ) strcpy(public_buf_l, common_menu.pause_special_title);
+        || disp_state_stack._disp_state[disp_state_stack._disp_index] == OPERATE_UI
+        || disp_state_stack._disp_state[disp_state_stack._disp_index] == PAUSE_UI
+      )    strcpy(public_buf_l, common_menu.pause_special_title);
       else strcpy(public_buf_l, pause_menu.title);
       break;
 
@@ -244,7 +312,8 @@ char *getDispText(int index) {
       strcpy(public_buf_l, fan_menu.title);
       break;
     case PRE_HEAT_UI:
-      if ((disp_state_stack._disp_state[disp_state_stack._disp_index - 1] == OPERATE_UI)) strcpy(public_buf_l, preheat_menu.adjust_title);
+      if ((disp_state_stack._disp_state[disp_state_stack._disp_index - 1] == OPERATE_UI))
+           strcpy(public_buf_l, preheat_menu.adjust_title);
       else strcpy(public_buf_l, preheat_menu.title);
       break;
     case SET_UI:
@@ -292,7 +361,7 @@ char *getDispText(int index) {
       strcpy(public_buf_l, tool_menu.title);
       break;
     case WIFI_LIST_UI:
-      //strcpy(public_buf_l, list_menu.title);
+      // strcpy(public_buf_l, list_menu.title);
       break;
     case MACHINE_PARA_UI:
       strcpy(public_buf_l, MachinePara_menu.title);
@@ -300,6 +369,9 @@ char *getDispText(int index) {
     case BABY_STEP_UI:
       strcpy(public_buf_l, operation_menu.babystep);
       break;
+    case EEPROM_SETTINGS_UI:
+      strcpy(public_buf_l, eeprom_menu.title);
+      break;
     default: break;
   }
 
@@ -307,19 +379,19 @@ char *getDispText(int index) {
 }
 
 char *creat_title_text() {
-  int index = 0;
+  int index     = 0;
   char *tmpText = 0;
   char tmpCurFileStr[20];
 
-  memset(tmpCurFileStr, 0, sizeof(tmpCurFileStr));
+  ZERO(tmpCurFileStr);
 
   #if _LFN_UNICODE
-    //cutFileName((TCHAR *)curFileName, 16, 16, (TCHAR *)tmpCurFileStr);
+    // cutFileName((TCHAR *)curFileName, 16, 16, (TCHAR *)tmpCurFileStr);
   #else
     cutFileName(list_file.long_name[sel_id], 16, 16, tmpCurFileStr);
   #endif
 
-  memset(public_buf_m, 0, sizeof(public_buf_m));
+  ZERO(public_buf_m);
 
   while (index <= disp_state_stack._disp_index) {
     tmpText = getDispText(index);
@@ -335,15 +407,15 @@ char *creat_title_text() {
   }
 
   if (disp_state_stack._disp_state[disp_state_stack._disp_index] == PRINTING_UI
-      /*|| disp_state_stack._disp_state[disp_state_stack._disp_index] == OPERATE_UI
-      || disp_state_stack._disp_state[disp_state_stack._disp_index] == PAUSE_UI*/) {
+    /*|| disp_state_stack._disp_state[disp_state_stack._disp_index] == OPERATE_UI
+    || disp_state_stack._disp_state[disp_state_stack._disp_index] == PAUSE_UI*/
+  ) {
     titleText_cat(public_buf_m, sizeof(public_buf_m), (char *)":");
     titleText_cat(public_buf_m, sizeof(public_buf_m), tmpCurFileStr);
   }
 
   if (strlen(public_buf_m) > MAX_TITLE_LEN) {
-    memset(public_buf_m, 0, sizeof(public_buf_m));
-
+    ZERO(public_buf_m);
     tmpText = getDispText(0);
     if (*tmpText != 0) {
       titleText_cat(public_buf_m, sizeof(public_buf_m), tmpText);
@@ -351,275 +423,425 @@ char *creat_title_text() {
       tmpText = getDispText(disp_state_stack._disp_index);
       if (*tmpText != 0) titleText_cat(public_buf_m, sizeof(public_buf_m), tmpText);
     }
-
   }
 
   return public_buf_m;
 }
 
 #if HAS_GCODE_PREVIEW
-uint32_t gPicturePreviewStart = 0;
-
-void preview_gcode_prehandle(char *path) {
-  #if ENABLED(SDSUPPORT)
-    //uint8_t re;
-    //uint32_t read;
-    uint32_t pre_read_cnt = 0;
-    uint32_t *p1;
-    char *cur_name;
-
-    gPicturePreviewStart = 0;
-    cur_name = strrchr(path, '/');
-    card.openFileRead(cur_name);
-    card.read(public_buf, 512);
-    p1 = (uint32_t *)strstr((char *)public_buf, ";simage:");
-
-    if (p1) {
-      pre_read_cnt = (uint32_t)p1 - (uint32_t)((uint32_t *)(&public_buf[0]));
-
-      To_pre_view = pre_read_cnt;
-      gcode_preview_over = 1;
-      gCfgItems.from_flash_pic = 1;
-      update_spi_flash();
-    }
-    else {
-      gcode_preview_over = 0;
-      default_preview_flg = 1;
-      gCfgItems.from_flash_pic = 0;
-      update_spi_flash();
-    }
-    card.closefile();
-  #endif
-}
 
-void gcode_preview(char *path, int xpos_pixel, int ypos_pixel) {
-  #if ENABLED(SDSUPPORT)
-    //uint8_t ress;
-    //uint32_t write;
-    volatile uint32_t i, j;
-    volatile uint16_t *p_index;
-    //int res;
-    char *cur_name;
-
-    cur_name = strrchr(path, '/');
-    card.openFileRead(cur_name);
-
-    if (gPicturePreviewStart <= 0) {
-      while (1) {
-        uint32_t br = card.read(public_buf, 400);
-        uint32_t* p1 = (uint32_t *)strstr((char *)public_buf, ";gimage:");
-        if (p1) {
-          gPicturePreviewStart += (uint32_t)p1 - (uint32_t)((uint32_t *)(&public_buf[0]));
-          break;
-        }
-        else {
-          gPicturePreviewStart += br;
-        }
-        if (br < 400) break;
-      }
-    }
-
-    // SERIAL_ECHOLNPAIR("gPicturePreviewStart: ", gPicturePreviewStart, " PREVIEW_LITTLE_PIC_SIZE: ", PREVIEW_LITTLE_PIC_SIZE);
-
-    card.setIndex((gPicturePreviewStart + To_pre_view) + size * row + 8);
-    #if ENABLED(SPI_GRAPHICAL_TFT)
-      SPI_TFT.spi_init(SPI_FULL_SPEED);
-      //SPI_TFT.SetCursor(0,0);
-      SPI_TFT.SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
-      SPI_TFT.LCD_WriteRAM_Prepare();
-    #else
-      ili9320_SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
-      LCD_WriteRAM_Prepare();
-    #endif
+  uint32_t gPicturePreviewStart = 0;
 
-    j = i = 0;
+  void preview_gcode_prehandle(char *path) {
+    #if ENABLED(SDSUPPORT)
+      // uint8_t re;
+      // uint32_t read;
+      uint32_t pre_read_cnt = 0;
+      uint32_t *p1;
+      char *cur_name;
 
-    while (1) {
-      card.read(public_buf, 400);
-      for (i = 0; i < 400;) {
-        bmp_public_buf[j] = ascii2dec_test((char*)&public_buf[i]) << 4 | ascii2dec_test((char*)&public_buf[i + 1]);
-        i += 2;
-        j++;
-      }
+      gPicturePreviewStart = 0;
+      cur_name             = strrchr(path, '/');
+      card.openFileRead(cur_name);
+      card.read(public_buf, 512);
+      p1 = (uint32_t *)strstr((char *)public_buf, ";simage:");
 
-      //if (i > 800) break;
-      //#ifdef TFT70
-      //if (j>400) {
-      //  f_read(file, buff_pic, 1, &read);
-      //  break;
-      //}
-      //#elif defined(TFT35)
-      if (j >= 400)
-        //f_read(file, buff_pic, 1, &read);
-        break;
-      //#endif
+      if (p1) {
+        pre_read_cnt = (uint32_t)p1 - (uint32_t)((uint32_t *)(&public_buf[0]));
 
-    }
-    #if ENABLED(SPI_GRAPHICAL_TFT)
-      for (i = 0; i < 400;) {
-        p_index = (uint16_t *)(&bmp_public_buf[i]);
-        Color = (*p_index >> 8);
-        *p_index = Color | ((*p_index & 0xFF) << 8);
-        i += 2;
+        To_pre_view              = pre_read_cnt;
+        gcode_preview_over       = 1;
+        gCfgItems.from_flash_pic = 1;
+        update_spi_flash();
       }
-      SPI_TFT_CS_L;
-      SPI_TFT_DC_H;
-      SPI.dmaSend(bmp_public_buf, 400, true);
-      SPI_TFT_CS_H;
-    #else
-      for (i = 0; i < 400;) {
-        p_index = (uint16_t *)(&bmp_public_buf[i]);
-        if (*p_index == 0x0000)*p_index=LV_COLOR_BACKGROUND.full; //gCfgItems.preview_bk_color;
-        LCD_IO_WriteData(*p_index);
-        i += 2;
+      else {
+        gcode_preview_over       = 0;
+        default_preview_flg      = 1;
+        gCfgItems.from_flash_pic = 0;
+        update_spi_flash();
       }
-    #endif
-    #if HAS_BAK_VIEW_IN_FLASH
-      W25QXX.init(SPI_QUARTER_SPEED);
-      if (row < 20) W25QXX.SPI_FLASH_SectorErase(BAK_VIEW_ADDR_TFT35 + row * 4096);
-      W25QXX.SPI_FLASH_BufferWrite(bmp_public_buf, BAK_VIEW_ADDR_TFT35 + row * 400, 400);
-    #endif
-    row++;
-    if (row >= 200) {
-      size = 809;
-      row = 0;
-
-      gcode_preview_over = 0;
-      //flash_preview_begin = 1;
-
       card.closefile();
+    #endif
+  }
 
-      /*
-      if (gCurFileState.file_open_flag != 0xaa) {
-        reset_file_info();
-        res = f_open(file, curFileName, FA_OPEN_EXISTING | FA_READ);
-        if (res == FR_OK) {
-          f_lseek(file,PREVIEW_SIZE+To_pre_view);
-          gCurFileState.file_open_flag = 0xaa;
-          //bakup_file_path((uint8_t *)curFileName, strlen(curFileName));
-          srcfp = file;
-          mksReprint.mks_printer_state = MKS_WORKING;
-          once_flag = 0;
+  #if 1
+
+    void gcode_preview(char *path, int xpos_pixel, int ypos_pixel) {
+      #if ENABLED(SDSUPPORT)
+        // uint8_t ress;
+        // uint32_t write;
+        volatile uint32_t i, j;
+        volatile uint16_t *p_index;
+        // int res;
+        char *cur_name;
+
+        cur_name = strrchr(path, '/');
+        card.openFileRead(cur_name);
+
+        if (gPicturePreviewStart <= 0) {
+          while (1) {
+            uint32_t br  = card.read(public_buf, 400);
+            uint32_t* p1 = (uint32_t *)strstr((char *)public_buf, ";gimage:");
+            if (p1) {
+              gPicturePreviewStart += (uint32_t)p1 - (uint32_t)((uint32_t *)(&public_buf[0]));
+              break;
+            }
+            else {
+              gPicturePreviewStart += br;
+            }
+            if (br < 400) break;
+          }
         }
-      }
-      */
-      char *cur_name;
 
-      cur_name = strrchr(list_file.file_name[sel_id], '/');
+        // SERIAL_ECHOLNPAIR("gPicturePreviewStart: ", gPicturePreviewStart, " PREVIEW_LITTLE_PIC_SIZE: ", PREVIEW_LITTLE_PIC_SIZE);
+
+        card.setIndex((gPicturePreviewStart + To_pre_view) + size * row + 8);
+        #if ENABLED(TFT_LVGL_UI_SPI)
+          SPI_TFT.spi_init(SPI_FULL_SPEED);
+          // SPI_TFT.SetCursor(0,0);
+          SPI_TFT.SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
+          SPI_TFT.LCD_WriteRAM_Prepare();
+        #else
+          ili9320_SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
+          LCD_WriteRAM_Prepare();
+        #endif
 
-      SdFile file;
-      SdFile *curDir;
-      card.endFilePrint();
-      const char * const fname = card.diveToFile(true, curDir, cur_name);
-      if (!fname) return;
-      if (file.open(curDir, fname, O_READ)) {
-        gCfgItems.curFilesize = file.fileSize();
-        file.close();
-        update_spi_flash();
-      }
+        j = i = 0;
 
-      card.openFileRead(cur_name);
-      if (card.isFileOpen()) {
-        feedrate_percentage = 100;
-        // saved_feedrate_percentage = feedrate_percentage;
-        planner.flow_percentage[0] = 100;
-        planner.e_factor[0] = planner.flow_percentage[0] * 0.01;
-        if (EXTRUDERS == 2) {
-          planner.flow_percentage[1] = 100;
-          planner.e_factor[1] = planner.flow_percentage[1] * 0.01;
+        while (1) {
+          card.read(public_buf, 400);
+          for (i = 0; i < 400;) {
+            bmp_public_buf[j] = ascii2dec_test((char*)&public_buf[i]) << 4 | ascii2dec_test((char*)&public_buf[i + 1]);
+            i                += 2;
+            j++;
+          }
+          if (j >= 400) break;
         }
-        card.startFileprint();
-        TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
-        once_flag = 0;
-      }
-      return;
+        #if ENABLED(TFT_LVGL_UI_SPI)
+          uint16_t Color, SpiColor;
+          SpiColor = (LV_COLOR_BACKGROUND.full >> 8) | ((LV_COLOR_BACKGROUND.full & 0xFF) << 8);
+          for (i = 0; i < 400;) {
+            p_index  = (uint16_t *)(&bmp_public_buf[i]);
+            Color    = (*p_index >> 8);
+            *p_index = Color | ((*p_index & 0xFF) << 8);
+            i       += 2;
+            if (*p_index == 0x0000) *p_index = SpiColor;
+          }
+          SPI_TFT_CS_L;
+          SPI_TFT_DC_H;
+          SPI.dmaSend(bmp_public_buf, 400, true);
+          SPI_TFT_CS_H;
+        #else
+          for (i = 0; i < 400;) {
+            p_index = (uint16_t *)(&bmp_public_buf[i]);
+            if (*p_index == 0x0000) *p_index = LV_COLOR_BACKGROUND.full; // gCfgItems.preview_bk_color;
+            LCD_IO_WriteData(*p_index);
+            i += 2;
+          }
+        #endif
+        #if HAS_BAK_VIEW_IN_FLASH
+          W25QXX.init(SPI_QUARTER_SPEED);
+          if (row < 20) W25QXX.SPI_FLASH_SectorErase(BAK_VIEW_ADDR_TFT35 + row * 4096);
+          W25QXX.SPI_FLASH_BufferWrite(bmp_public_buf, BAK_VIEW_ADDR_TFT35 + row * 400, 400);
+        #endif
+        row++;
+        if (row >= 200) {
+          size = 809;
+          row  = 0;
+
+          gcode_preview_over = 0;
+          // flash_preview_begin = 1;
+
+          card.closefile();
+
+          /*
+          if (gCurFileState.file_open_flag != 0xaa) {
+            reset_file_info();
+            res = f_open(file, curFileName, FA_OPEN_EXISTING | FA_READ);
+            if (res == FR_OK) {
+              f_lseek(file,PREVIEW_SIZE+To_pre_view);
+              gCurFileState.file_open_flag = 0xaa;
+              //bakup_file_path((uint8_t *)curFileName, strlen(curFileName));
+              srcfp = file;
+              mksReprint.mks_printer_state = MKS_WORKING;
+              once_flag = 0;
+            }
+          }
+          */
+          char *cur_name;
+
+          cur_name = strrchr(list_file.file_name[sel_id], '/');
+
+          SdFile file;
+          SdFile *curDir;
+          card.endFilePrint();
+          const char * const fname = card.diveToFile(true, curDir, cur_name);
+          if (!fname) return;
+          if (file.open(curDir, fname, O_READ)) {
+            gCfgItems.curFilesize = file.fileSize();
+            file.close();
+            update_spi_flash();
+          }
+
+          card.openFileRead(cur_name);
+          if (card.isFileOpen()) {
+            feedrate_percentage = 100;
+            // saved_feedrate_percentage = feedrate_percentage;
+            planner.flow_percentage[0] = 100;
+            planner.e_factor[0]        = planner.flow_percentage[0] * 0.01;
+            if (EXTRUDERS == 2) {
+              planner.flow_percentage[1] = 100;
+              planner.e_factor[1]        = planner.flow_percentage[1] * 0.01;
+            }
+            card.startFileprint();
+            TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
+            once_flag = 0;
+          }
+          return;
+        }
+        card.closefile();
+      #endif // SDSUPPORT
     }
-    card.closefile();
-  #endif // SDSUPPORT
-}
 
-void Draw_default_preview(int xpos_pixel, int ypos_pixel, uint8_t sel) {
-  int index;
-  int x_off = 0, y_off = 0;
-  int _y;
-  uint16_t *p_index;
-  int i;
-  uint16_t temp_p;
+  #else // if 1
+
+    void gcode_preview(char *path, int xpos_pixel, int ypos_pixel) {
+      #if ENABLED(SDSUPPORT)
+        // uint8_t ress;
+        // uint32_t write;
+        volatile uint32_t i, j;
+        volatile uint16_t *p_index;
+        // int res;
+        char *cur_name;
+        uint16_t Color;
+
+        cur_name = strrchr(path, '/');
+        card.openFileRead(cur_name);
+
+        card.setIndex((PREVIEW_LITTLE_PIC_SIZE + To_pre_view) + size * row + 8);
+        #if ENABLED(TFT_LVGL_UI_SPI)
+          SPI_TFT.spi_init(SPI_FULL_SPEED);
+          // SPI_TFT.SetCursor(0,0);
+          SPI_TFT.SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
+          SPI_TFT.LCD_WriteRAM_Prepare();
+        #else
+          ili9320_SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
+          LCD_WriteRAM_Prepare();
+        #endif
 
-  for (index = 0; index < 10; index++) { // 200*200
-    #if HAS_BAK_VIEW_IN_FLASH
-      if (sel == 1) flash_view_Read(bmp_public_buf, 8000); //20k
-      //memset(bmp_public_buf,0x1f,8000);
-      else
-        //memset(bmp_public_buf,0x1f,8000);
-        default_view_Read(bmp_public_buf, DEFAULT_VIEW_MAX_SIZE / 10); //20k
-    #else
-      default_view_Read(bmp_public_buf, DEFAULT_VIEW_MAX_SIZE / 10); //20k
-    #endif
+        j = 0;
+        i = 0;
 
-    i = 0;
-    #if ENABLED(SPI_GRAPHICAL_TFT)
-      //SPI_TFT.spi_init(SPI_FULL_SPEED);
-      //SPI_TFT.SetWindows(xpos_pixel, y_off * 20+ypos_pixel, 200,20);     //200*200
-      //SPI_TFT.LCD_WriteRAM_Prepare();
-      j = 0;
-      for (_y = y_off * 20; _y < (y_off + 1) * 20; _y++) {
-        SPI_TFT.spi_init(SPI_FULL_SPEED);
-        SPI_TFT.SetWindows(xpos_pixel, y_off * 20 + ypos_pixel + j, 200, 1);    //200*200
-        SPI_TFT.LCD_WriteRAM_Prepare();
-
-        j++;
-        //memcpy(public_buf,&bmp_public_buf[i],400);
-        SPI_TFT_CS_L;
-        SPI_TFT_DC_H;
-        SPI.dmaSend(&bmp_public_buf[i], 400, true);
-        SPI_TFT_CS_H;
-
-        i += 400;
-        if (i >= 8000) break;
-      }
-    #else
-      ili9320_SetWindows(xpos_pixel, y_off * 20 + ypos_pixel, 200, 20);     //200*200
+        while (1) {
+          card.read(public_buf, 400);
+          for (i = 0; i < 400;) {
+            bmp_public_buf[j] = ascii2dec_test((char*)&public_buf[i]) << 4 | ascii2dec_test((char*)&public_buf[i + 1]);
+            i += 2;
+            j++;
+          }
+
+          //if (i > 800) break;
+          //#ifdef TFT70
+          //  if (j > 400) {
+          //    f_read(file, buff_pic, 1, &read);
+          //    break;
+          //  }
+          //#elif defined(TFT35)
+          if (j >= 400)
+            //f_read(file, buff_pic, 1, &read);
+            break;
+          //#endif
 
-      LCD_WriteRAM_Prepare();
+        }
+        #if ENABLED(TFT_LVGL_UI_SPI)
+          for (i = 0; i < 400;) {
+            p_index = (uint16_t *)(&bmp_public_buf[i]);
 
-      for (_y = y_off * 20; _y < (y_off + 1) * 20; _y++) {
-        for (x_off = 0; x_off < 200; x_off++) {
-          if (sel == 1) {
-            temp_p = (uint16_t)(bmp_public_buf[i] | bmp_public_buf[i + 1] << 8);
-            p_index = &temp_p;
+            Color    = (*p_index >> 8);
+            *p_index = Color | ((*p_index & 0xff) << 8);
+            i       += 2;
+            if (*p_index == 0x0000) *p_index = 0xC318;
+          }
+          SPI_TFT_CS_L;
+          SPI_TFT_DC_H;
+          SPI.dmaSend(bmp_public_buf, 400, true);
+          SPI_TFT_CS_H;
+
+        #else
+          for (i = 0; i < 400;) {
+            p_index = (uint16_t *)(&bmp_public_buf[i]);
+            if (*p_index == 0x0000) *p_index = 0x18C3;
+            LCD_IO_WriteData(*p_index);
+            i = i + 2;
           }
-          else {
+        #endif
+        W25QXX.init(SPI_QUARTER_SPEED);
+        if (row < 20)
+          W25QXX.SPI_FLASH_SectorErase(BAK_VIEW_ADDR_TFT35 + row * 4096);
+        W25QXX.SPI_FLASH_BufferWrite(bmp_public_buf, BAK_VIEW_ADDR_TFT35 + row * 400, 400);
+        row++;
+        if (row >= 200) {
+          size = 809;
+          row  = 0;
+
+          gcode_preview_over = 0;
+          // flash_preview_begin = 1;
+
+          card.closefile();
+
+          /*
+          if (gCurFileState.file_open_flag != 0xaa) {
+            reset_file_info();
+            res = f_open(file, curFileName, FA_OPEN_EXISTING | FA_READ);
+            if (res == FR_OK) {
+              f_lseek(file,PREVIEW_SIZE+To_pre_view);
+              gCurFileState.file_open_flag = 0xaa;
+              //bakup_file_path((uint8_t *)curFileName, strlen(curFileName));
+              srcfp = file;
+              mksReprint.mks_printer_state = MKS_WORKING;
+              once_flag = 0;
+            }
+          }
+          */
+          char *cur_name;
+
+          cur_name = strrchr(list_file.file_name[sel_id], '/');
+
+          SdFile file;
+          SdFile *curDir;
+          card.endFilePrint();
+          const char * const fname = card.diveToFile(true, curDir, cur_name);
+          if (!fname) return;
+          if (file.open(curDir, fname, O_READ)) {
+            gCfgItems.curFilesize = file.fileSize();
+            file.close();
+            update_spi_flash();
+          }
+
+          card.openFileRead(cur_name);
+          if (card.isFileOpen()) {
+            feedrate_percentage = 100;
+            // saved_feedrate_percentage = feedrate_percentage;
+            planner.flow_percentage[0] = 100;
+            planner.e_factor[0]        = planner.flow_percentage[0] * 0.01;
+            if (EXTRUDERS == 2) {
+              planner.flow_percentage[1] = 100;
+              planner.e_factor[1]        = planner.flow_percentage[1] * 0.01;
+            }
+            card.startFileprint();
+            TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
+            once_flag = 0;
+          }
+          return;
+        }
+        card.closefile();
+      #endif // SDSUPPORT
+    }
+
+  #endif // if 1
+
+  void Draw_default_preview(int xpos_pixel, int ypos_pixel, uint8_t sel) {
+    int index;
+    int y_off = 0;
+    int _y;
+    uint16_t *p_index;
+    int i;
+
+    for (index = 0; index < 10; index++) { // 200*200
+      #if HAS_BAK_VIEW_IN_FLASH
+        if (sel == 1) {
+          flash_view_Read(bmp_public_buf, 8000); // 20k
+        }
+        else {
+          default_view_Read(bmp_public_buf, DEFAULT_VIEW_MAX_SIZE / 10); // 20k
+          #if ENABLED(TFT_LVGL_UI_SPI)
+            uint16_t Color;
+            for (i = 0; i < (DEFAULT_VIEW_MAX_SIZE / 10);) {
+              p_index = (uint16_t *)(&bmp_public_buf[i]);
+              Color = (*p_index >> 8);
+              *p_index = Color | ((*p_index & 0xff) << 8);
+              i += 2;
+            }
+          #endif
+        }
+      #else
+        default_view_Read(bmp_public_buf, DEFAULT_VIEW_MAX_SIZE / 10); // 20k
+        #if ENABLED(TFT_LVGL_UI_SPI)
+          for (i = 0; i < (DEFAULT_VIEW_MAX_SIZE / 10);) {
             p_index = (uint16_t *)(&bmp_public_buf[i]);
+            Color = (*p_index >> 8);
+            *p_index = Color | ((*p_index & 0xff) << 8);
+            i += 2;
+          }
+        #endif
+      #endif
+
+      i = 0;
+      #if ENABLED(TFT_LVGL_UI_SPI)
+
+        // SPI_TFT.spi_init(SPI_FULL_SPEED);
+        // SPI_TFT.SetWindows(xpos_pixel, y_off * 20+ypos_pixel, 200,20);     //200*200
+        // SPI_TFT.LCD_WriteRAM_Prepare();
+        int j = 0;
+        for (_y = y_off * 20; _y < (y_off + 1) * 20; _y++) {
+          SPI_TFT.spi_init(SPI_FULL_SPEED);
+          SPI_TFT.SetWindows(xpos_pixel, y_off * 20 + ypos_pixel + j, 200, 1); // 200*200
+          SPI_TFT.LCD_WriteRAM_Prepare();
+
+          j++;
+          // memcpy(public_buf,&bmp_public_buf[i],400);
+          SPI_TFT_CS_L;
+          SPI_TFT_DC_H;
+          SPI.dmaSend(&bmp_public_buf[i], 400, true);
+          SPI_TFT_CS_H;
+
+          i += 400;
+          if (i >= 8000) break;
+        }
+      #else
+        int x_off = 0;
+        uint16_t temp_p;
+        ili9320_SetWindows(xpos_pixel, y_off * 20 + ypos_pixel, 200, 20); // 200*200
+
+        LCD_WriteRAM_Prepare();
+
+        for (_y = y_off * 20; _y < (y_off + 1) * 20; _y++) {
+          for (x_off = 0; x_off < 200; x_off++) {
+            if (sel == 1) {
+              temp_p  = (uint16_t)(bmp_public_buf[i] | bmp_public_buf[i + 1] << 8);
+              p_index = &temp_p;
+            }
+            else {
+              p_index = (uint16_t *)(&bmp_public_buf[i]);
+            }
+            if (*p_index == 0x0000) *p_index = LV_COLOR_BACKGROUND.full; // gCfgItems.preview_bk_color;
+            LCD_IO_WriteData(*p_index);
+            i += 2;
           }
-          if (*p_index == 0x0000)*p_index=LV_COLOR_BACKGROUND.full; //gCfgItems.preview_bk_color;
-          LCD_IO_WriteData(*p_index);
-          i += 2;
+          if (i >= 8000) break;
         }
-        if (i >= 8000) break;
+      #endif // if ENABLED(TFT_LVGL_UI_SPI)
+      y_off++;
+    }
+    W25QXX.init(SPI_QUARTER_SPEED);
+  }
+
+  void disp_pre_gcode(int xpos_pixel, int ypos_pixel) {
+    if (gcode_preview_over == 1) gcode_preview(list_file.file_name[sel_id], xpos_pixel, ypos_pixel);
+    #if HAS_BAK_VIEW_IN_FLASH
+      if (flash_preview_begin == 1) {
+        flash_preview_begin = 0;
+        Draw_default_preview(xpos_pixel, ypos_pixel, 1);
+      }
+    #endif
+    #if HAS_GCODE_DEFAULT_VIEW_IN_FLASH
+      if (default_preview_flg == 1) {
+        Draw_default_preview(xpos_pixel, ypos_pixel, 0);
+        default_preview_flg = 0;
       }
     #endif
-    y_off++;
   }
-  W25QXX.init(SPI_QUARTER_SPEED);
-}
-
-void disp_pre_gcode(int xpos_pixel, int ypos_pixel) {
-  if (gcode_preview_over == 1) gcode_preview(list_file.file_name[sel_id], xpos_pixel, ypos_pixel);
-  #if HAS_BAK_VIEW_IN_FLASH
-    if (flash_preview_begin == 1) {
-      flash_preview_begin = 0;
-      Draw_default_preview(xpos_pixel, ypos_pixel, 1);
-    }
-  #endif
-  #if HAS_GCODE_DEFAULT_VIEW_IN_FLASH
-    if (default_preview_flg == 1) {
-      Draw_default_preview(xpos_pixel, ypos_pixel, 0);
-      default_preview_flg = 0;
-    }
-  #endif
-}
-#endif
+#endif // if HAS_GCODE_PREVIEW
 
 void print_time_run() {
   static uint8_t lastSec = 0;
@@ -644,7 +866,7 @@ void GUI_RefreshPage() {
 
   switch (disp_state) {
     case MAIN_UI:
-      lv_draw_ready_print();
+      // lv_draw_ready_print();
       break;
     case EXTRUSION_UI:
       if (temperature_change_frequency == 1) {
@@ -721,7 +943,7 @@ void GUI_RefreshPage() {
           {
             memset((char *)gCfgItems.move_z_coordinate, ' ', sizeof(gCfgItems.move_z_coordinate));
             GUI_DispStringAt((const char *)gCfgItems.move_z_coordinate, 380, TITLE_YPOS);
-            sprintf((char *)gCfgItems.move_z_coordinate, "Z: %.3f", current_position[Z_AXIS]);
+            sprintf_P((char *)gCfgItems.move_z_coordinate, PSTR("Z: %.3f"), current_position[Z_AXIS]);
             GUI_DispStringAt((const char *)gCfgItems.move_z_coordinate, 380, TITLE_YPOS);
           }
         }
@@ -831,7 +1053,7 @@ void clear_cur_ui() {
 
   switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
     case PRINT_READY_UI:
-      //Get_Temperature_Flg = 0;
+      // Get_Temperature_Flg = 0;
       lv_clear_ready_print();
       break;
     case PRINT_FILE_UI:
@@ -844,7 +1066,7 @@ void clear_cur_ui() {
       lv_clear_move_motor();
       break;
     case OPERATE_UI:
-      lv_clear_opration();
+      lv_clear_operation();
       break;
     case PAUSE_UI:
       //Clear_pause();
@@ -931,16 +1153,16 @@ void clear_cur_ui() {
       //Clear_Tips();
       break;
     case MACHINE_PARA_UI:
-      //Clear_MachinePara();
+      lv_clear_machine_para();
       break;
     case MACHINE_SETTINGS_UI:
-      //Clear_MachineSettings();
+      lv_clear_machine_settings();
       break;
     case TEMPERATURE_SETTINGS_UI:
       //Clear_TemperatureSettings();
       break;
     case MOTOR_SETTINGS_UI:
-      //Clear_MotorSettings();
+      lv_clear_motor_settings();
       break;
     case MACHINETYPE_UI:
       //Clear_MachineType();
@@ -970,16 +1192,18 @@ void clear_cur_ui() {
       //Clear_XYZLevelPara();
       break;
     case MAXFEEDRATE_UI:
-      //Clear_MaxFeedRate();
+      lv_clear_max_feedrate_settings();
       break;
     case STEPS_UI:
-      //Clear_Steps();
+      lv_clear_step_settings();
       break;
     case ACCELERATION_UI:
-      //Clear_Acceleration();
+      lv_clear_acceleration_settings();
       break;
     case JERK_UI:
-      //Clear_Jerk();
+      #if HAS_CLASSIC_JERK
+        lv_clear_jerk_settings();
+      #endif
       break;
     case MOTORDIR_UI:
       //Clear_MotorDir();
@@ -994,7 +1218,7 @@ void clear_cur_ui() {
       //Clear_HotbedConfig();
       break;
     case ADVANCED_UI:
-      //Clear_Advanced();
+      lv_clear_advance_settings();
       break;
     case DOUBLE_Z_UI:
       //Clear_DoubleZ();
@@ -1003,15 +1227,31 @@ void clear_cur_ui() {
       //Clear_EnableInvert();
       break;
     case NUMBER_KEY_UI:
-      //Clear_NumberKey();
+      lv_clear_number_key();
       break;
     case BABY_STEP_UI:
       //Clear_babyStep();
       break;
+    case PAUSE_POS_UI:
+      lv_clear_pause_position();
+      break;
+      #if HAS_TRINAMIC_CONFIG
+        case TMC_CURRENT_UI:
+          lv_clear_tmc_current_settings();
+          break;
+      #endif
+    case EEPROM_SETTINGS_UI:
+      lv_clear_eeprom_settings();
+      break;
+      #if HAS_STEALTHCHOP
+        case TMC_MODE_UI:
+          lv_clear_tmc_step_mode_settings();
+          break;
+      #endif
     default:
       break;
   }
-  //GUI_Clear();
+  // GUI_Clear();
 }
 
 void draw_return_ui() {
@@ -1034,13 +1274,13 @@ void draw_return_ui() {
         lv_draw_move_motor();
         break;
       case OPERATE_UI:
-        lv_draw_opration();
+        lv_draw_operation();
         break;
 
         #if 1
-      case PAUSE_UI:
-        //draw_pause();
-        break;
+          case PAUSE_UI:
+            //draw_pause();
+            break;
         #endif
 
       case EXTRUSION_UI:
@@ -1075,9 +1315,9 @@ void draw_return_ui() {
         break;
 
         #if tan_mask
-      case LOG_UI:
-        //draw_Connect();
-        break;
+          case LOG_UI:
+            //draw_Connect();
+            break;
         #endif
 
       case CALIBRATE_UI:
@@ -1106,9 +1346,9 @@ void draw_return_ui() {
         break;
 
         #if tan_mask
-      case ZOFFSET_UI:
-        //draw_Zoffset();
-        break;
+          case ZOFFSET_UI:
+            //draw_Zoffset();
+            break;
         #endif
 
       case TOOL_UI:
@@ -1130,16 +1370,16 @@ void draw_return_ui() {
         //draw_Tips();
         break;
       case MACHINE_PARA_UI:
-        //draw_MachinePara();
+        lv_draw_machine_para();
         break;
       case MACHINE_SETTINGS_UI:
-        //draw_MachineSettings();
+        lv_draw_machine_settings();
         break;
       case TEMPERATURE_SETTINGS_UI:
         //draw_TemperatureSettings();
         break;
       case MOTOR_SETTINGS_UI:
-        //draw_MotorSettings();
+        lv_draw_motor_settings();
         break;
       case MACHINETYPE_UI:
         //draw_MachineType();
@@ -1169,16 +1409,18 @@ void draw_return_ui() {
         //draw_XYZLevelPara();
         break;
       case MAXFEEDRATE_UI:
-        //draw_MaxFeedRate();
+        lv_draw_max_feedrate_settings();
         break;
       case STEPS_UI:
-        //draw_Steps();
+        lv_draw_step_settings();
         break;
       case ACCELERATION_UI:
-        //draw_Acceleration();
+        lv_draw_acceleration_settings();
         break;
       case JERK_UI:
-        //draw_Jerk();
+        #if HAS_CLASSIC_JERK
+          lv_draw_jerk_settings();
+        #endif
         break;
       case MOTORDIR_UI:
         //draw_MotorDir();
@@ -1193,7 +1435,7 @@ void draw_return_ui() {
         //draw_HotbedConfig();
         break;
       case ADVANCED_UI:
-        //draw_Advanced();
+        lv_draw_advance_settings();
         break;
       case DOUBLE_Z_UI:
         //draw_DoubleZ();
@@ -1202,7 +1444,7 @@ void draw_return_ui() {
         //draw_EnableInvert();
         break;
       case NUMBER_KEY_UI:
-        //draw_NumberKey();
+        lv_draw_number_key();
         break;
       case DIALOG_UI:
         //draw_dialog(DialogType);
@@ -1210,6 +1452,22 @@ void draw_return_ui() {
       case BABY_STEP_UI:
         //draw_babyStep();
         break;
+      case PAUSE_POS_UI:
+        lv_draw_pause_position();
+        break;
+        #if HAS_TRINAMIC_CONFIG
+          case TMC_CURRENT_UI:
+            lv_draw_tmc_current_settings();
+            break;
+        #endif
+      case EEPROM_SETTINGS_UI:
+        lv_draw_eeprom_settings();
+        break;
+        #if HAS_STEALTHCHOP
+          case TMC_MODE_UI:
+            lv_draw_tmc_step_mode_settings();
+            break;
+        #endif
       default: break;
     }
   }
@@ -1228,6 +1486,13 @@ void draw_return_ui() {
 
 #endif
 
+void lv_ex_line(lv_obj_t * line, lv_point_t *points) {
+  /*Copy the previous line and apply the new style*/
+  lv_line_set_points(line, points, 2);     /*Set the points*/
+  lv_line_set_style(line, LV_LINE_STYLE_MAIN, &style_line);
+  lv_obj_align(line, NULL, LV_ALIGN_IN_TOP_MID, 0, 0);
+}
+
 extern volatile uint32_t systick_uptime_millis;
 
 void print_time_count() {
@@ -1236,14 +1501,14 @@ void print_time_count() {
 }
 
 void LV_TASK_HANDLER() {
-  //lv_tick_inc(1);
+  // lv_tick_inc(1);
   lv_task_handler();
-  TERN_(MKS_TEST, mks_test());
+  if (mks_test_flag == 0x1e) mks_hardware_test();
   #if HAS_GCODE_PREVIEW
     disp_pre_gcode(2, 36);
   #endif
   GUI_RefreshPage();
-  //sd_detection();
+  // sd_detection();
 }
 
-#endif // TFT_LVGL_UI
+#endif // HAS_TFT_LVGL_UI

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index af0d1f440c..ef2a29a930 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 #include "../../../../inc/MarlinConfigPre.h"

commit 0a86291e66f0c33d399b8698dd0e7d41e628181b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jul 19 22:06:45 2020 -0500

    Fix some LVGL warnings

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 52e83204e9..af0d1f440c 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -400,7 +400,6 @@ void gcode_preview(char *path, int xpos_pixel, int ypos_pixel) {
     volatile uint16_t *p_index;
     //int res;
     char *cur_name;
-    uint16_t Color;
 
     cur_name = strrchr(path, '/');
     card.openFileRead(cur_name);

commit e5bc9d31cc87be5c7ef2bd3cd70c2599f76d2bd7
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Wed Jul 1 03:30:24 2020 -0300

    Add TFT_LVGL_UI support (#18438)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index c8df85203e..52e83204e9 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -21,11 +21,10 @@
  */
 #include "../../../../inc/MarlinConfigPre.h"
 
-#if ENABLED(TFT_LITTLE_VGL_UI)
+#if ENABLED(TFT_LVGL_UI)
 
 #include "W25Qxx.h"
 #include "tft_lvgl_configuration.h"
-#include "pic_manager.h"
 
 #include <SPI.h>
 
@@ -38,6 +37,8 @@
 #include "../../../../module/motion.h"
 #include "../../../../module/planner.h"
 
+#include "pic_manager.h"
+
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../../feature/powerloss.h"
 #endif
@@ -73,7 +74,33 @@ extern void LCD_IO_WriteData(uint16_t RegValue);
 
 void gCfgItems_init() {
   gCfgItems.multiple_language = MULTI_LANGUAGE_ENABLE;
-  gCfgItems.language = LANG_ENGLISH;
+  #if 1 //LCD_LANGUAGE == en
+    gCfgItems.language = LANG_ENGLISH;
+  #elif LCD_LANGUAGE == zh_CN
+    gCfgItems.language = LANG_SIMPLE_CHINESE;
+  #elif LCD_LANGUAGE == zh_TW
+    gCfgItems.language = LANG_COMPLEX_CHINESE;
+  #elif LCD_LANGUAGE == jp_kana
+    gCfgItems.language = LANG_JAPAN;
+  #elif LCD_LANGUAGE == de
+    gCfgItems.language = LANG_GERMAN;
+  #elif LCD_LANGUAGE == fr
+    gCfgItems.language = LANG_FRENCH;
+  #elif LCD_LANGUAGE == ru
+    gCfgItems.language = LANG_RUSSIAN;
+  #elif LCD_LANGUAGE == ko_KR
+    gCfgItems.language = LANG_KOREAN;
+  #elif LCD_LANGUAGE == tr
+    gCfgItems.language = LANG_TURKISH;
+  #elif LCD_LANGUAGE == es
+    gCfgItems.language = LANG_SPANISH;
+  #elif LCD_LANGUAGE == el
+    gCfgItems.language = LANG_GREEK;
+  #elif LCD_LANGUAGE == it
+    gCfgItems.language = LANG_ITALY;
+  #elif LCD_LANGUAGE == pt
+    gCfgItems.language = LANG_PORTUGUESE;
+  #endif
   gCfgItems.leveling_mode = 0;
   gCfgItems.from_flash_pic = 0;
   gCfgItems.curFilesize = 0;
@@ -139,8 +166,13 @@ void tft_style_init() {
   tft_style_lable_rel.body.grad_color = LV_COLOR_BACKGROUND;
   tft_style_lable_rel.text.color = LV_COLOR_TEXT;
   tft_style_lable_rel.text.sel_color = LV_COLOR_TEXT;
-  tft_style_lable_pre.text.font = &gb2312_puhui32;
-  tft_style_lable_rel.text.font = &gb2312_puhui32;
+  #if HAS_SPI_FLASH_FONT
+    tft_style_lable_pre.text.font = &gb2312_puhui32;
+    tft_style_lable_rel.text.font = &gb2312_puhui32;
+  #else
+    tft_style_lable_pre.text.font = LV_FONT_DEFAULT;
+    tft_style_lable_rel.text.font = LV_FONT_DEFAULT;
+  #endif
   tft_style_lable_pre.line.width = 0;
   tft_style_lable_rel.line.width = 0;
   tft_style_lable_pre.text.letter_space = 0;
@@ -325,6 +357,9 @@ char *creat_title_text() {
   return public_buf_m;
 }
 
+#if HAS_GCODE_PREVIEW
+uint32_t gPicturePreviewStart = 0;
+
 void preview_gcode_prehandle(char *path) {
   #if ENABLED(SDSUPPORT)
     //uint8_t re;
@@ -333,6 +368,7 @@ void preview_gcode_prehandle(char *path) {
     uint32_t *p1;
     char *cur_name;
 
+    gPicturePreviewStart = 0;
     cur_name = strrchr(path, '/');
     card.openFileRead(cur_name);
     card.read(public_buf, 512);
@@ -369,7 +405,24 @@ void gcode_preview(char *path, int xpos_pixel, int ypos_pixel) {
     cur_name = strrchr(path, '/');
     card.openFileRead(cur_name);
 
-    card.setIndex((PREVIEW_LITTLE_PIC_SIZE + To_pre_view) + size * row + 8);
+    if (gPicturePreviewStart <= 0) {
+      while (1) {
+        uint32_t br = card.read(public_buf, 400);
+        uint32_t* p1 = (uint32_t *)strstr((char *)public_buf, ";gimage:");
+        if (p1) {
+          gPicturePreviewStart += (uint32_t)p1 - (uint32_t)((uint32_t *)(&public_buf[0]));
+          break;
+        }
+        else {
+          gPicturePreviewStart += br;
+        }
+        if (br < 400) break;
+      }
+    }
+
+    // SERIAL_ECHOLNPAIR("gPicturePreviewStart: ", gPicturePreviewStart, " PREVIEW_LITTLE_PIC_SIZE: ", PREVIEW_LITTLE_PIC_SIZE);
+
+    card.setIndex((gPicturePreviewStart + To_pre_view) + size * row + 8);
     #if ENABLED(SPI_GRAPHICAL_TFT)
       SPI_TFT.spi_init(SPI_FULL_SPEED);
       //SPI_TFT.SetCursor(0,0);
@@ -417,14 +470,16 @@ void gcode_preview(char *path, int xpos_pixel, int ypos_pixel) {
     #else
       for (i = 0; i < 400;) {
         p_index = (uint16_t *)(&bmp_public_buf[i]);
-        //if (*p_index == 0x0000)*p_index=gCfgItems.preview_bk_color;
+        if (*p_index == 0x0000)*p_index=LV_COLOR_BACKGROUND.full; //gCfgItems.preview_bk_color;
         LCD_IO_WriteData(*p_index);
         i += 2;
       }
     #endif
-    W25QXX.init(SPI_QUARTER_SPEED);
-    if (row < 20) W25QXX.SPI_FLASH_SectorErase(BAK_VIEW_ADDR_TFT35 + row * 4096);
-    W25QXX.SPI_FLASH_BufferWrite(bmp_public_buf, BAK_VIEW_ADDR_TFT35 + row * 400, 400);
+    #if HAS_BAK_VIEW_IN_FLASH
+      W25QXX.init(SPI_QUARTER_SPEED);
+      if (row < 20) W25QXX.SPI_FLASH_SectorErase(BAK_VIEW_ADDR_TFT35 + row * 4096);
+      W25QXX.SPI_FLASH_BufferWrite(bmp_public_buf, BAK_VIEW_ADDR_TFT35 + row * 400, 400);
+    #endif
     row++;
     if (row >= 200) {
       size = 809;
@@ -489,15 +544,19 @@ void Draw_default_preview(int xpos_pixel, int ypos_pixel, uint8_t sel) {
   int x_off = 0, y_off = 0;
   int _y;
   uint16_t *p_index;
-  int i, j;
-  uint16_t temp_p, Color;
+  int i;
+  uint16_t temp_p;
 
   for (index = 0; index < 10; index++) { // 200*200
-    if (sel == 1) flash_view_Read(bmp_public_buf, 8000); //20k
-    //memset(bmp_public_buf,0x1f,8000);
-    else
+    #if HAS_BAK_VIEW_IN_FLASH
+      if (sel == 1) flash_view_Read(bmp_public_buf, 8000); //20k
       //memset(bmp_public_buf,0x1f,8000);
-      default_view_Read(bmp_public_buf, 8000); //20k
+      else
+        //memset(bmp_public_buf,0x1f,8000);
+        default_view_Read(bmp_public_buf, DEFAULT_VIEW_MAX_SIZE / 10); //20k
+    #else
+      default_view_Read(bmp_public_buf, DEFAULT_VIEW_MAX_SIZE / 10); //20k
+    #endif
 
     i = 0;
     #if ENABLED(SPI_GRAPHICAL_TFT)
@@ -534,6 +593,7 @@ void Draw_default_preview(int xpos_pixel, int ypos_pixel, uint8_t sel) {
           else {
             p_index = (uint16_t *)(&bmp_public_buf[i]);
           }
+          if (*p_index == 0x0000)*p_index=LV_COLOR_BACKGROUND.full; //gCfgItems.preview_bk_color;
           LCD_IO_WriteData(*p_index);
           i += 2;
         }
@@ -547,15 +607,20 @@ void Draw_default_preview(int xpos_pixel, int ypos_pixel, uint8_t sel) {
 
 void disp_pre_gcode(int xpos_pixel, int ypos_pixel) {
   if (gcode_preview_over == 1) gcode_preview(list_file.file_name[sel_id], xpos_pixel, ypos_pixel);
-  if (flash_preview_begin == 1) {
-    flash_preview_begin = 0;
-    Draw_default_preview(xpos_pixel, ypos_pixel, 1);
-  }
-  if (default_preview_flg == 1) {
-    Draw_default_preview(xpos_pixel, ypos_pixel, 0);
-    default_preview_flg = 0;
-  }
+  #if HAS_BAK_VIEW_IN_FLASH
+    if (flash_preview_begin == 1) {
+      flash_preview_begin = 0;
+      Draw_default_preview(xpos_pixel, ypos_pixel, 1);
+    }
+  #endif
+  #if HAS_GCODE_DEFAULT_VIEW_IN_FLASH
+    if (default_preview_flg == 1) {
+      Draw_default_preview(xpos_pixel, ypos_pixel, 0);
+      default_preview_flg = 0;
+    }
+  #endif
 }
+#endif
 
 void print_time_run() {
   static uint8_t lastSec = 0;
@@ -1175,9 +1240,11 @@ void LV_TASK_HANDLER() {
   //lv_tick_inc(1);
   lv_task_handler();
   TERN_(MKS_TEST, mks_test());
-  disp_pre_gcode(2, 36);
+  #if HAS_GCODE_PREVIEW
+    disp_pre_gcode(2, 36);
+  #endif
   GUI_RefreshPage();
   //sd_detection();
 }
 
-#endif // TFT_LITTLE_VGL_UI
+#endif // TFT_LVGL_UI

commit 2a650a2793be724077d624359d549297d0a1daaf
Author: Victor <rhapsodyv@gmail.com>
Date:   Wed Jun 24 16:54:39 2020 -0300

    TFT_LITTLE_VGL_UI followup (#18410)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
index 01fa6bc37a..c8df85203e 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -46,6 +46,8 @@
   #include "../../../../feature/pause.h"
 #endif
 
+#include "draw_ui.h"
+
 CFG_ITMES gCfgItems;
 UI_CFG uiCfg;
 DISP_STATE_STACK disp_state_stack;

commit 642112d3eb7c1af9a52feec8134c85ed3e34891c
Author: makerbase <4164049@qq.com>
Date:   Tue Jun 16 10:05:33 2020 +0800

    Add MKS UI (TFT_LITTLE_VGL_UI) (#18071)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
new file mode 100644
index 0000000000..01fa6bc37a
--- /dev/null
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_ui.cpp
@@ -0,0 +1,1181 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "../../../../inc/MarlinConfigPre.h"
+
+#if ENABLED(TFT_LITTLE_VGL_UI)
+
+#include "W25Qxx.h"
+#include "tft_lvgl_configuration.h"
+#include "pic_manager.h"
+
+#include <SPI.h>
+
+#if ENABLED(SPI_GRAPHICAL_TFT)
+  #include "SPI_TFT.h"
+#endif
+
+#include "../../../../MarlinCore.h"
+#include "../../../../sd/cardreader.h"
+#include "../../../../module/motion.h"
+#include "../../../../module/planner.h"
+
+#if ENABLED(POWER_LOSS_RECOVERY)
+  #include "../../../../feature/powerloss.h"
+#endif
+
+#if ENABLED(PARK_HEAD_ON_PAUSE)
+  #include "../../../../feature/pause.h"
+#endif
+
+CFG_ITMES gCfgItems;
+UI_CFG uiCfg;
+DISP_STATE_STACK disp_state_stack;
+DISP_STATE disp_state = MAIN_UI;
+DISP_STATE last_disp_state;
+PRINT_TIME print_time;
+
+uint32_t To_pre_view;
+uint8_t gcode_preview_over;
+uint8_t flash_preview_begin;
+uint8_t default_preview_flg;
+uint32_t size = 809;
+uint16_t row;
+uint8_t temperature_change_frequency;
+uint8_t printing_rate_update_flag;
+
+extern uint8_t once_flag;
+extern uint8_t sel_id;
+extern uint8_t public_buf[512];
+extern uint8_t bmp_public_buf[17 * 1024];
+
+extern void LCD_IO_WriteData(uint16_t RegValue);
+
+void gCfgItems_init() {
+  gCfgItems.multiple_language = MULTI_LANGUAGE_ENABLE;
+  gCfgItems.language = LANG_ENGLISH;
+  gCfgItems.leveling_mode = 0;
+  gCfgItems.from_flash_pic = 0;
+  gCfgItems.curFilesize = 0;
+  gCfgItems.finish_power_off = 0;
+  gCfgItems.pause_reprint = 0;
+
+  W25QXX.SPI_FLASH_BufferRead((uint8_t *)&gCfgItems.spi_flash_flag, VAR_INF_ADDR, sizeof(gCfgItems.spi_flash_flag));
+  if (gCfgItems.spi_flash_flag == GCFG_FLAG_VALUE) {
+    W25QXX.SPI_FLASH_BufferRead((uint8_t *)&gCfgItems, VAR_INF_ADDR, sizeof(gCfgItems));
+  }
+  else {
+    gCfgItems.spi_flash_flag = GCFG_FLAG_VALUE;
+    W25QXX.SPI_FLASH_SectorErase(VAR_INF_ADDR);
+    W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&gCfgItems, VAR_INF_ADDR, sizeof(gCfgItems));
+  }
+
+}
+
+void gCfg_to_spiFlah() {
+  W25QXX.SPI_FLASH_SectorErase(VAR_INF_ADDR);
+  W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&gCfgItems, VAR_INF_ADDR, sizeof(gCfgItems));
+}
+
+void ui_cfg_init() {
+  uiCfg.curTempType = 0;
+  uiCfg.curSprayerChoose = 0;
+  uiCfg.stepHeat = 10;
+  uiCfg.leveling_first_time = 0;
+  uiCfg.extruStep = 5;
+  uiCfg.extruSpeed = 10;
+  uiCfg.move_dist = 1;
+  uiCfg.moveSpeed = 3000;
+  uiCfg.stepPrintSpeed = 10;
+}
+
+void update_spi_flash() {
+  W25QXX.init(SPI_QUARTER_SPEED);
+  W25QXX.SPI_FLASH_SectorErase(VAR_INF_ADDR);
+  W25QXX.SPI_FLASH_BufferWrite((uint8_t *)&gCfgItems, VAR_INF_ADDR, sizeof(gCfgItems));
+}
+
+lv_style_t tft_style_scr;
+lv_style_t tft_style_lable_pre;
+lv_style_t tft_style_lable_rel;
+
+void tft_style_init() {
+  lv_style_copy(&tft_style_scr, &lv_style_scr);
+  tft_style_scr.body.main_color = LV_COLOR_BACKGROUND;
+  tft_style_scr.body.grad_color = LV_COLOR_BACKGROUND;
+  tft_style_scr.text.color = LV_COLOR_TEXT;
+  tft_style_scr.text.sel_color = LV_COLOR_TEXT;
+  tft_style_scr.line.width = 0;
+  tft_style_scr.text.letter_space = 0;
+  tft_style_scr.text.line_space = 0;
+
+  lv_style_copy(&tft_style_lable_pre, &lv_style_scr);
+  lv_style_copy(&tft_style_lable_rel, &lv_style_scr);
+  tft_style_lable_pre.body.main_color = LV_COLOR_BACKGROUND;
+  tft_style_lable_pre.body.grad_color = LV_COLOR_BACKGROUND;
+  tft_style_lable_pre.text.color = LV_COLOR_TEXT;
+  tft_style_lable_pre.text.sel_color = LV_COLOR_TEXT;
+  tft_style_lable_rel.body.main_color = LV_COLOR_BACKGROUND;
+  tft_style_lable_rel.body.grad_color = LV_COLOR_BACKGROUND;
+  tft_style_lable_rel.text.color = LV_COLOR_TEXT;
+  tft_style_lable_rel.text.sel_color = LV_COLOR_TEXT;
+  tft_style_lable_pre.text.font = &gb2312_puhui32;
+  tft_style_lable_rel.text.font = &gb2312_puhui32;
+  tft_style_lable_pre.line.width = 0;
+  tft_style_lable_rel.line.width = 0;
+  tft_style_lable_pre.text.letter_space = 0;
+  tft_style_lable_rel.text.letter_space = 0;
+  tft_style_lable_pre.text.line_space = -5;
+  tft_style_lable_rel.text.line_space = -5;
+}
+
+#define MAX_TITLE_LEN 28
+
+char public_buf_m[100] = {0};
+
+char public_buf_l[30];
+
+void titleText_cat(char *str, int strSize, char *addPart) {
+  if (str == 0 || addPart == 0) return;
+  if ((int)(strlen(str) + strlen(addPart)) >= strSize) return;
+  strcat(str, addPart);
+}
+
+char *getDispText(int index) {
+
+  memset(public_buf_l, 0, sizeof(public_buf_l));
+
+  switch (disp_state_stack._disp_state[index]) {
+    case PRINT_READY_UI:
+      strcpy(public_buf_l, main_menu.title);
+      break;
+    case PRINT_FILE_UI:
+      strcpy(public_buf_l, file_menu.title);
+      break;
+    case PRINTING_UI:
+      if (disp_state_stack._disp_state[disp_state_stack._disp_index] == PRINTING_UI
+          #ifndef TFT35
+            || disp_state_stack._disp_state[disp_state_stack._disp_index] == OPERATE_UI
+            || disp_state_stack._disp_state[disp_state_stack._disp_index] == PAUSE_UI
+          #endif
+          ) strcpy(public_buf_l, common_menu.print_special_title);
+      else strcpy(public_buf_l, printing_menu.title);
+      break;
+    case MOVE_MOTOR_UI:
+      strcpy(public_buf_l, move_menu.title);
+      break;
+    case OPERATE_UI:
+      if (disp_state_stack._disp_state[disp_state_stack._disp_index] == PRINTING_UI
+          #ifndef TFT35
+            || disp_state_stack._disp_state[disp_state_stack._disp_index] == OPERATE_UI
+            || disp_state_stack._disp_state[disp_state_stack._disp_index] == PAUSE_UI
+          #endif
+          ) strcpy(public_buf_l, common_menu.operate_special_title);
+      else strcpy(public_buf_l, operation_menu.title);
+      break;
+
+    case PAUSE_UI:
+      if (disp_state_stack._disp_state[disp_state_stack._disp_index] == PRINTING_UI
+          || disp_state_stack._disp_state[disp_state_stack._disp_index] == OPERATE_UI
+          || disp_state_stack._disp_state[disp_state_stack._disp_index] == PAUSE_UI
+          ) strcpy(public_buf_l, common_menu.pause_special_title);
+      else strcpy(public_buf_l, pause_menu.title);
+      break;
+
+    case EXTRUSION_UI:
+      strcpy(public_buf_l, extrude_menu.title);
+      break;
+    case CHANGE_SPEED_UI:
+      strcpy(public_buf_l, speed_menu.title);
+      break;
+    case FAN_UI:
+      strcpy(public_buf_l, fan_menu.title);
+      break;
+    case PRE_HEAT_UI:
+      if ((disp_state_stack._disp_state[disp_state_stack._disp_index - 1] == OPERATE_UI)) strcpy(public_buf_l, preheat_menu.adjust_title);
+      else strcpy(public_buf_l, preheat_menu.title);
+      break;
+    case SET_UI:
+      strcpy(public_buf_l, set_menu.title);
+      break;
+    case ZERO_UI:
+      strcpy(public_buf_l, home_menu.title);
+      break;
+    case SPRAYER_UI: break;
+    case MACHINE_UI: break;
+    case LANGUAGE_UI:
+      strcpy(public_buf_l, language_menu.title);
+      break;
+    case ABOUT_UI:
+      strcpy(public_buf_l, about_menu.title);
+      break;
+    case LOG_UI: break;
+    case DISK_UI:
+      strcpy(public_buf_l, filesys_menu.title);
+      break;
+    case DIALOG_UI:
+      strcpy(public_buf_l, common_menu.dialog_confirm_title);
+      break;
+    case WIFI_UI:
+      strcpy(public_buf_l, wifi_menu.title);
+      break;
+    case MORE_UI:
+    case PRINT_MORE_UI:
+      strcpy(public_buf_l, more_menu.title);
+      break;
+    case FILAMENTCHANGE_UI:
+      strcpy(public_buf_l, filament_menu.title);
+      break;
+    case LEVELING_UI:
+    case MESHLEVELING_UI:
+      strcpy(public_buf_l, leveling_menu.title);
+      break;
+    case BIND_UI:
+      strcpy(public_buf_l, cloud_menu.title);
+      break;
+    case ZOFFSET_UI:
+      strcpy(public_buf_l, zoffset_menu.title);
+      break;
+    case TOOL_UI:
+      strcpy(public_buf_l, tool_menu.title);
+      break;
+    case WIFI_LIST_UI:
+      //strcpy(public_buf_l, list_menu.title);
+      break;
+    case MACHINE_PARA_UI:
+      strcpy(public_buf_l, MachinePara_menu.title);
+      break;
+    case BABY_STEP_UI:
+      strcpy(public_buf_l, operation_menu.babystep);
+      break;
+    default: break;
+  }
+
+  return public_buf_l;
+}
+
+char *creat_title_text() {
+  int index = 0;
+  char *tmpText = 0;
+  char tmpCurFileStr[20];
+
+  memset(tmpCurFileStr, 0, sizeof(tmpCurFileStr));
+
+  #if _LFN_UNICODE
+    //cutFileName((TCHAR *)curFileName, 16, 16, (TCHAR *)tmpCurFileStr);
+  #else
+    cutFileName(list_file.long_name[sel_id], 16, 16, tmpCurFileStr);
+  #endif
+
+  memset(public_buf_m, 0, sizeof(public_buf_m));
+
+  while (index <= disp_state_stack._disp_index) {
+    tmpText = getDispText(index);
+    if ((*tmpText == 0) || (tmpText == 0)) {
+      index++;
+      continue;
+    }
+
+    titleText_cat(public_buf_m, sizeof(public_buf_m), tmpText);
+    if (index < disp_state_stack._disp_index) titleText_cat(public_buf_m, sizeof(public_buf_m), (char *)">");
+
+    index++;
+  }
+
+  if (disp_state_stack._disp_state[disp_state_stack._disp_index] == PRINTING_UI
+      /*|| disp_state_stack._disp_state[disp_state_stack._disp_index] == OPERATE_UI
+      || disp_state_stack._disp_state[disp_state_stack._disp_index] == PAUSE_UI*/) {
+    titleText_cat(public_buf_m, sizeof(public_buf_m), (char *)":");
+    titleText_cat(public_buf_m, sizeof(public_buf_m), tmpCurFileStr);
+  }
+
+  if (strlen(public_buf_m) > MAX_TITLE_LEN) {
+    memset(public_buf_m, 0, sizeof(public_buf_m));
+
+    tmpText = getDispText(0);
+    if (*tmpText != 0) {
+      titleText_cat(public_buf_m, sizeof(public_buf_m), tmpText);
+      titleText_cat(public_buf_m, sizeof(public_buf_m), (char *)">...>");
+      tmpText = getDispText(disp_state_stack._disp_index);
+      if (*tmpText != 0) titleText_cat(public_buf_m, sizeof(public_buf_m), tmpText);
+    }
+
+  }
+
+  return public_buf_m;
+}
+
+void preview_gcode_prehandle(char *path) {
+  #if ENABLED(SDSUPPORT)
+    //uint8_t re;
+    //uint32_t read;
+    uint32_t pre_read_cnt = 0;
+    uint32_t *p1;
+    char *cur_name;
+
+    cur_name = strrchr(path, '/');
+    card.openFileRead(cur_name);
+    card.read(public_buf, 512);
+    p1 = (uint32_t *)strstr((char *)public_buf, ";simage:");
+
+    if (p1) {
+      pre_read_cnt = (uint32_t)p1 - (uint32_t)((uint32_t *)(&public_buf[0]));
+
+      To_pre_view = pre_read_cnt;
+      gcode_preview_over = 1;
+      gCfgItems.from_flash_pic = 1;
+      update_spi_flash();
+    }
+    else {
+      gcode_preview_over = 0;
+      default_preview_flg = 1;
+      gCfgItems.from_flash_pic = 0;
+      update_spi_flash();
+    }
+    card.closefile();
+  #endif
+}
+
+void gcode_preview(char *path, int xpos_pixel, int ypos_pixel) {
+  #if ENABLED(SDSUPPORT)
+    //uint8_t ress;
+    //uint32_t write;
+    volatile uint32_t i, j;
+    volatile uint16_t *p_index;
+    //int res;
+    char *cur_name;
+    uint16_t Color;
+
+    cur_name = strrchr(path, '/');
+    card.openFileRead(cur_name);
+
+    card.setIndex((PREVIEW_LITTLE_PIC_SIZE + To_pre_view) + size * row + 8);
+    #if ENABLED(SPI_GRAPHICAL_TFT)
+      SPI_TFT.spi_init(SPI_FULL_SPEED);
+      //SPI_TFT.SetCursor(0,0);
+      SPI_TFT.SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
+      SPI_TFT.LCD_WriteRAM_Prepare();
+    #else
+      ili9320_SetWindows(xpos_pixel, ypos_pixel + row, 200, 1);
+      LCD_WriteRAM_Prepare();
+    #endif
+
+    j = i = 0;
+
+    while (1) {
+      card.read(public_buf, 400);
+      for (i = 0; i < 400;) {
+        bmp_public_buf[j] = ascii2dec_test((char*)&public_buf[i]) << 4 | ascii2dec_test((char*)&public_buf[i + 1]);
+        i += 2;
+        j++;
+      }
+
+      //if (i > 800) break;
+      //#ifdef TFT70
+      //if (j>400) {
+      //  f_read(file, buff_pic, 1, &read);
+      //  break;
+      //}
+      //#elif defined(TFT35)
+      if (j >= 400)
+        //f_read(file, buff_pic, 1, &read);
+        break;
+      //#endif
+
+    }
+    #if ENABLED(SPI_GRAPHICAL_TFT)
+      for (i = 0; i < 400;) {
+        p_index = (uint16_t *)(&bmp_public_buf[i]);
+        Color = (*p_index >> 8);
+        *p_index = Color | ((*p_index & 0xFF) << 8);
+        i += 2;
+      }
+      SPI_TFT_CS_L;
+      SPI_TFT_DC_H;
+      SPI.dmaSend(bmp_public_buf, 400, true);
+      SPI_TFT_CS_H;
+    #else
+      for (i = 0; i < 400;) {
+        p_index = (uint16_t *)(&bmp_public_buf[i]);
+        //if (*p_index == 0x0000)*p_index=gCfgItems.preview_bk_color;
+        LCD_IO_WriteData(*p_index);
+        i += 2;
+      }
+    #endif
+    W25QXX.init(SPI_QUARTER_SPEED);
+    if (row < 20) W25QXX.SPI_FLASH_SectorErase(BAK_VIEW_ADDR_TFT35 + row * 4096);
+    W25QXX.SPI_FLASH_BufferWrite(bmp_public_buf, BAK_VIEW_ADDR_TFT35 + row * 400, 400);
+    row++;
+    if (row >= 200) {
+      size = 809;
+      row = 0;
+
+      gcode_preview_over = 0;
+      //flash_preview_begin = 1;
+
+      card.closefile();
+
+      /*
+      if (gCurFileState.file_open_flag != 0xaa) {
+        reset_file_info();
+        res = f_open(file, curFileName, FA_OPEN_EXISTING | FA_READ);
+        if (res == FR_OK) {
+          f_lseek(file,PREVIEW_SIZE+To_pre_view);
+          gCurFileState.file_open_flag = 0xaa;
+          //bakup_file_path((uint8_t *)curFileName, strlen(curFileName));
+          srcfp = file;
+          mksReprint.mks_printer_state = MKS_WORKING;
+          once_flag = 0;
+        }
+      }
+      */
+      char *cur_name;
+
+      cur_name = strrchr(list_file.file_name[sel_id], '/');
+
+      SdFile file;
+      SdFile *curDir;
+      card.endFilePrint();
+      const char * const fname = card.diveToFile(true, curDir, cur_name);
+      if (!fname) return;
+      if (file.open(curDir, fname, O_READ)) {
+        gCfgItems.curFilesize = file.fileSize();
+        file.close();
+        update_spi_flash();
+      }
+
+      card.openFileRead(cur_name);
+      if (card.isFileOpen()) {
+        feedrate_percentage = 100;
+        // saved_feedrate_percentage = feedrate_percentage;
+        planner.flow_percentage[0] = 100;
+        planner.e_factor[0] = planner.flow_percentage[0] * 0.01;
+        if (EXTRUDERS == 2) {
+          planner.flow_percentage[1] = 100;
+          planner.e_factor[1] = planner.flow_percentage[1] * 0.01;
+        }
+        card.startFileprint();
+        TERN_(POWER_LOSS_RECOVERY, recovery.prepare());
+        once_flag = 0;
+      }
+      return;
+    }
+    card.closefile();
+  #endif // SDSUPPORT
+}
+
+void Draw_default_preview(int xpos_pixel, int ypos_pixel, uint8_t sel) {
+  int index;
+  int x_off = 0, y_off = 0;
+  int _y;
+  uint16_t *p_index;
+  int i, j;
+  uint16_t temp_p, Color;
+
+  for (index = 0; index < 10; index++) { // 200*200
+    if (sel == 1) flash_view_Read(bmp_public_buf, 8000); //20k
+    //memset(bmp_public_buf,0x1f,8000);
+    else
+      //memset(bmp_public_buf,0x1f,8000);
+      default_view_Read(bmp_public_buf, 8000); //20k
+
+    i = 0;
+    #if ENABLED(SPI_GRAPHICAL_TFT)
+      //SPI_TFT.spi_init(SPI_FULL_SPEED);
+      //SPI_TFT.SetWindows(xpos_pixel, y_off * 20+ypos_pixel, 200,20);     //200*200
+      //SPI_TFT.LCD_WriteRAM_Prepare();
+      j = 0;
+      for (_y = y_off * 20; _y < (y_off + 1) * 20; _y++) {
+        SPI_TFT.spi_init(SPI_FULL_SPEED);
+        SPI_TFT.SetWindows(xpos_pixel, y_off * 20 + ypos_pixel + j, 200, 1);    //200*200
+        SPI_TFT.LCD_WriteRAM_Prepare();
+
+        j++;
+        //memcpy(public_buf,&bmp_public_buf[i],400);
+        SPI_TFT_CS_L;
+        SPI_TFT_DC_H;
+        SPI.dmaSend(&bmp_public_buf[i], 400, true);
+        SPI_TFT_CS_H;
+
+        i += 400;
+        if (i >= 8000) break;
+      }
+    #else
+      ili9320_SetWindows(xpos_pixel, y_off * 20 + ypos_pixel, 200, 20);     //200*200
+
+      LCD_WriteRAM_Prepare();
+
+      for (_y = y_off * 20; _y < (y_off + 1) * 20; _y++) {
+        for (x_off = 0; x_off < 200; x_off++) {
+          if (sel == 1) {
+            temp_p = (uint16_t)(bmp_public_buf[i] | bmp_public_buf[i + 1] << 8);
+            p_index = &temp_p;
+          }
+          else {
+            p_index = (uint16_t *)(&bmp_public_buf[i]);
+          }
+          LCD_IO_WriteData(*p_index);
+          i += 2;
+        }
+        if (i >= 8000) break;
+      }
+    #endif
+    y_off++;
+  }
+  W25QXX.init(SPI_QUARTER_SPEED);
+}
+
+void disp_pre_gcode(int xpos_pixel, int ypos_pixel) {
+  if (gcode_preview_over == 1) gcode_preview(list_file.file_name[sel_id], xpos_pixel, ypos_pixel);
+  if (flash_preview_begin == 1) {
+    flash_preview_begin = 0;
+    Draw_default_preview(xpos_pixel, ypos_pixel, 1);
+  }
+  if (default_preview_flg == 1) {
+    Draw_default_preview(xpos_pixel, ypos_pixel, 0);
+    default_preview_flg = 0;
+  }
+}
+
+void print_time_run() {
+  static uint8_t lastSec = 0;
+
+  if (print_time.seconds >= 60) {
+    print_time.seconds = 0;
+    print_time.minutes++;
+    if (print_time.minutes >= 60) {
+      print_time.minutes = 0;
+      print_time.hours++;
+    }
+  }
+  if (disp_state == PRINTING_UI) {
+    if (lastSec != print_time.seconds) disp_print_time();
+    lastSec = print_time.seconds;
+  }
+}
+
+void GUI_RefreshPage() {
+  if ((systick_uptime_millis % 1000) == 0) temperature_change_frequency = 1;
+  if ((systick_uptime_millis % 3000) == 0) printing_rate_update_flag = 1;
+
+  switch (disp_state) {
+    case MAIN_UI:
+      lv_draw_ready_print();
+      break;
+    case EXTRUSION_UI:
+      if (temperature_change_frequency == 1) {
+        temperature_change_frequency = 0;
+        disp_hotend_temp();
+      }
+      break;
+    case PRE_HEAT_UI:
+      if (temperature_change_frequency == 1) {
+        temperature_change_frequency = 0;
+        disp_desire_temp();
+      }
+      break;
+    case PRINT_READY_UI:
+      /*
+      if (gCfgItems.display_style == 2) {
+        if (temperature_change_frequency) {
+          temperature_change_frequency = 0;
+          disp_restro_state();
+        }
+      }
+      */
+      break;
+
+    case PRINT_FILE_UI: break;
+
+    case PRINTING_UI:
+      if (temperature_change_frequency) {
+        temperature_change_frequency = 0;
+        disp_ext_temp();
+        disp_bed_temp();
+        disp_fan_speed();
+        disp_print_time();
+        disp_fan_Zpos();
+      }
+      if (printing_rate_update_flag || marlin_state == MF_SD_COMPLETE) {
+        printing_rate_update_flag = 0;
+        if (gcode_preview_over == 0) setProBarRate();
+      }
+      break;
+
+    case OPERATE_UI:
+      /*
+      if (temperature_change_frequency == 1) {
+        temperature_change_frequency = 0;
+        disp_temp_operate();
+      }
+
+      setProBarRateOpera();
+      */
+      break;
+
+    case PAUSE_UI:
+      /*
+      if (temperature_change_frequency == 1) {
+        temperature_change_frequency = 0;
+        disp_temp_pause();
+      }
+      */
+      break;
+
+    case FAN_UI:
+      if (temperature_change_frequency == 1) {
+        temperature_change_frequency = 0;
+        disp_fan_value();
+      }
+      break;
+
+    case MOVE_MOTOR_UI:
+      /*
+      if (mksReprint.mks_printer_state == MKS_IDLE) {
+        if ((z_high_count==1)&&(temper_error_flg != 1)) {
+          z_high_count = 0;
+          {
+            memset((char *)gCfgItems.move_z_coordinate, ' ', sizeof(gCfgItems.move_z_coordinate));
+            GUI_DispStringAt((const char *)gCfgItems.move_z_coordinate, 380, TITLE_YPOS);
+            sprintf((char *)gCfgItems.move_z_coordinate, "Z: %.3f", current_position[Z_AXIS]);
+            GUI_DispStringAt((const char *)gCfgItems.move_z_coordinate, 380, TITLE_YPOS);
+          }
+        }
+      }
+      */
+      break;
+
+    case WIFI_UI:
+      /*
+      if (wifi_refresh_flg == 1) {
+        disp_wifi_state();
+        wifi_refresh_flg = 0;
+      }
+      */
+      break;
+    case BIND_UI:
+      /*refresh_bind_ui();*/
+      break;
+
+    case FILAMENTCHANGE_UI:
+      /*
+      if (temperature_change_frequency) {
+        temperature_change_frequency = 0;
+        disp_filament_sprayer_temp();
+      }
+      */
+      break;
+    case DIALOG_UI:
+      /*filament_dialog_handle();
+      wifi_scan_handle();*/
+      break;
+    case MESHLEVELING_UI:
+      /*disp_zpos();*/
+      break;
+    case HARDWARE_TEST_UI:
+      break;
+    case WIFI_LIST_UI:
+      /*
+      if (wifi_refresh_flg == 1) {
+        disp_wifi_list();
+        wifi_refresh_flg = 0;
+      }
+      */
+      break;
+    case KEY_BOARD_UI:
+      /*update_password_disp();
+      update_join_state_disp();*/
+      break;
+    case TIPS_UI:
+      /*
+      switch (tips_type) {
+        case TIPS_TYPE_JOINING:
+          if (wifi_link_state == WIFI_CONNECTED && strcmp((const char *)wifi_list.wifiConnectedName, (const char *)wifi_list.wifiName[wifi_list.nameIndex]) == 0) {
+            tips_disp.timer = TIPS_TIMER_STOP;
+            tips_disp.timer_count = 0;
+            Clear_Tips();
+            tips_type = TIPS_TYPE_WIFI_CONECTED;
+            draw_Tips();
+          }
+          if (tips_disp.timer_count >= 30) {
+            tips_disp.timer = TIPS_TIMER_STOP;
+            tips_disp.timer_count = 0;
+            Clear_Tips();
+            tips_type = TIPS_TYPE_TAILED_JOIN;
+            draw_Tips();
+          }
+          break;
+        case TIPS_TYPE_TAILED_JOIN:
+          if (tips_disp.timer_count >= 3) {
+            tips_disp.timer = TIPS_TIMER_STOP;
+            tips_disp.timer_count = 0;
+            last_disp_state = TIPS_UI;
+            Clear_Tips();
+            draw_Wifi_list();
+          }
+          break;
+        case TIPS_TYPE_WIFI_CONECTED:
+          if (tips_disp.timer_count >= 3) {
+            tips_disp.timer = TIPS_TIMER_STOP;
+            tips_disp.timer_count = 0;
+
+            last_disp_state = TIPS_UI;
+            Clear_Tips();
+            draw_Wifi();
+          }
+          break;
+        default: break;
+      }
+      */
+      break;
+    case BABY_STEP_UI:
+      /*
+      if (temperature_change_frequency == 1) {
+        temperature_change_frequency = 0;
+        disp_z_offset_value();
+      }
+      */
+      break;
+    default: break;
+  }
+
+  print_time_run();
+}
+
+void clear_cur_ui() {
+  last_disp_state = disp_state_stack._disp_state[disp_state_stack._disp_index];
+
+  switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
+    case PRINT_READY_UI:
+      //Get_Temperature_Flg = 0;
+      lv_clear_ready_print();
+      break;
+    case PRINT_FILE_UI:
+      lv_clear_print_file();
+      break;
+    case PRINTING_UI:
+      lv_clear_printing();
+      break;
+    case MOVE_MOTOR_UI:
+      lv_clear_move_motor();
+      break;
+    case OPERATE_UI:
+      lv_clear_opration();
+      break;
+    case PAUSE_UI:
+      //Clear_pause();
+      break;
+    case EXTRUSION_UI:
+      lv_clear_extrusion();
+      break;
+    case PRE_HEAT_UI:
+      lv_clear_preHeat();
+      break;
+    case CHANGE_SPEED_UI:
+      lv_clear_change_speed();
+      break;
+    case FAN_UI:
+      lv_clear_fan();
+      break;
+    case SET_UI:
+      lv_clear_set();
+      break;
+    case ZERO_UI:
+      lv_clear_home();
+      break;
+    case SPRAYER_UI:
+      //Clear_Sprayer();
+      break;
+    case MACHINE_UI:
+      //Clear_Machine();
+      break;
+    case LANGUAGE_UI:
+      lv_clear_language();
+      break;
+    case ABOUT_UI:
+      lv_clear_about();
+      break;
+    case LOG_UI:
+      //Clear_Connect();
+      break;
+    case DISK_UI:
+      //Clear_Disk();
+      break;
+    case WIFI_UI:
+      //Clear_Wifi();
+      break;
+    case MORE_UI:
+      //Clear_more();
+      break;
+    case FILETRANSFER_UI:
+      //Clear_fileTransfer();
+      break;
+    case DIALOG_UI:
+      lv_clear_dialog();
+      break;
+    case FILETRANSFERSTATE_UI:
+      //Clear_WifiFileTransferdialog();
+      break;
+    case PRINT_MORE_UI:
+      //Clear_Printmore();
+      break;
+    case LEVELING_UI:
+      lv_clear_manualLevel();
+      break;
+    case BIND_UI:
+      //Clear_Bind();
+      break;
+    case ZOFFSET_UI:
+      //Clear_Zoffset();
+      break;
+    case TOOL_UI:
+      lv_clear_tool();
+      break;
+    case MESHLEVELING_UI:
+      //Clear_MeshLeveling();
+      break;
+    case HARDWARE_TEST_UI:
+      //Clear_Hardwaretest();
+      break;
+    case WIFI_LIST_UI:
+      //Clear_Wifi_list();
+      break;
+    case KEY_BOARD_UI:
+      //Clear_Keyboard();
+      break;
+    case TIPS_UI:
+      //Clear_Tips();
+      break;
+    case MACHINE_PARA_UI:
+      //Clear_MachinePara();
+      break;
+    case MACHINE_SETTINGS_UI:
+      //Clear_MachineSettings();
+      break;
+    case TEMPERATURE_SETTINGS_UI:
+      //Clear_TemperatureSettings();
+      break;
+    case MOTOR_SETTINGS_UI:
+      //Clear_MotorSettings();
+      break;
+    case MACHINETYPE_UI:
+      //Clear_MachineType();
+      break;
+    case STROKE_UI:
+      //Clear_Stroke();
+      break;
+    case HOME_DIR_UI:
+      //Clear_HomeDir();
+      break;
+    case ENDSTOP_TYPE_UI:
+      //Clear_EndstopType();
+      break;
+    case FILAMENT_SETTINGS_UI:
+      //Clear_FilamentSettings();
+      break;
+    case LEVELING_SETTIGNS_UI:
+      //Clear_LevelingSettings();
+      break;
+    case LEVELING_PARA_UI:
+      //Clear_LevelingPara();
+      break;
+    case DELTA_LEVELING_PARA_UI:
+      //Clear_DeltaLevelPara();
+      break;
+    case XYZ_LEVELING_PARA_UI:
+      //Clear_XYZLevelPara();
+      break;
+    case MAXFEEDRATE_UI:
+      //Clear_MaxFeedRate();
+      break;
+    case STEPS_UI:
+      //Clear_Steps();
+      break;
+    case ACCELERATION_UI:
+      //Clear_Acceleration();
+      break;
+    case JERK_UI:
+      //Clear_Jerk();
+      break;
+    case MOTORDIR_UI:
+      //Clear_MotorDir();
+      break;
+    case HOMESPEED_UI:
+      //Clear_HomeSpeed();
+      break;
+    case NOZZLE_CONFIG_UI:
+      //Clear_NozzleConfig();
+      break;
+    case HOTBED_CONFIG_UI:
+      //Clear_HotbedConfig();
+      break;
+    case ADVANCED_UI:
+      //Clear_Advanced();
+      break;
+    case DOUBLE_Z_UI:
+      //Clear_DoubleZ();
+      break;
+    case ENABLE_INVERT_UI:
+      //Clear_EnableInvert();
+      break;
+    case NUMBER_KEY_UI:
+      //Clear_NumberKey();
+      break;
+    case BABY_STEP_UI:
+      //Clear_babyStep();
+      break;
+    default:
+      break;
+  }
+  //GUI_Clear();
+}
+
+void draw_return_ui() {
+  if (disp_state_stack._disp_index > 0) {
+    disp_state_stack._disp_index--;
+
+    switch (disp_state_stack._disp_state[disp_state_stack._disp_index]) {
+      case PRINT_READY_UI:
+        lv_draw_ready_print();
+        break;
+      case PRINT_FILE_UI:
+        lv_draw_print_file();
+        break;
+      case PRINTING_UI:
+        if (gCfgItems.from_flash_pic == 1) flash_preview_begin = 1;
+        else default_preview_flg = 1;
+        lv_draw_printing();
+        break;
+      case MOVE_MOTOR_UI:
+        lv_draw_move_motor();
+        break;
+      case OPERATE_UI:
+        lv_draw_opration();
+        break;
+
+        #if 1
+      case PAUSE_UI:
+        //draw_pause();
+        break;
+        #endif
+
+      case EXTRUSION_UI:
+        lv_draw_extrusion();
+        break;
+      case PRE_HEAT_UI:
+        lv_draw_preHeat();
+        break;
+      case CHANGE_SPEED_UI:
+        lv_draw_change_speed();
+        break;
+      case FAN_UI:
+        lv_draw_fan();
+        break;
+      case SET_UI:
+        lv_draw_set();
+        break;
+      case ZERO_UI:
+        lv_draw_home();
+        break;
+      case SPRAYER_UI:
+        //draw_Sprayer();
+        break;
+      case MACHINE_UI:
+        //draw_Machine();
+        break;
+      case LANGUAGE_UI:
+        lv_draw_language();
+        break;
+      case ABOUT_UI:
+        lv_draw_about();
+        break;
+
+        #if tan_mask
+      case LOG_UI:
+        //draw_Connect();
+        break;
+        #endif
+
+      case CALIBRATE_UI:
+        //draw_calibrate();
+        break;
+      case DISK_UI:
+        //draw_Disk();
+        break;
+      case WIFI_UI:
+        //draw_Wifi();
+        break;
+      case MORE_UI:
+        //draw_More();
+        break;
+      case PRINT_MORE_UI:
+        //draw_printmore();
+        break;
+      case FILAMENTCHANGE_UI:
+        //draw_FilamentChange();
+        break;
+      case LEVELING_UI:
+        lv_draw_manualLevel();
+        break;
+      case BIND_UI:
+        //draw_bind();
+        break;
+
+        #if tan_mask
+      case ZOFFSET_UI:
+        //draw_Zoffset();
+        break;
+        #endif
+
+      case TOOL_UI:
+        lv_draw_tool();
+        break;
+      case MESHLEVELING_UI:
+        //draw_meshleveling();
+        break;
+      case HARDWARE_TEST_UI:
+        //draw_Hardwaretest();
+        break;
+      case WIFI_LIST_UI:
+        //draw_Wifi_list();
+        break;
+      case KEY_BOARD_UI:
+        //draw_Keyboard();
+        break;
+      case TIPS_UI:
+        //draw_Tips();
+        break;
+      case MACHINE_PARA_UI:
+        //draw_MachinePara();
+        break;
+      case MACHINE_SETTINGS_UI:
+        //draw_MachineSettings();
+        break;
+      case TEMPERATURE_SETTINGS_UI:
+        //draw_TemperatureSettings();
+        break;
+      case MOTOR_SETTINGS_UI:
+        //draw_MotorSettings();
+        break;
+      case MACHINETYPE_UI:
+        //draw_MachineType();
+        break;
+      case STROKE_UI:
+        //draw_Stroke();
+        break;
+      case HOME_DIR_UI:
+        //draw_HomeDir();
+        break;
+      case ENDSTOP_TYPE_UI:
+        //draw_EndstopType();
+        break;
+      case FILAMENT_SETTINGS_UI:
+        //draw_FilamentSettings();
+        break;
+      case LEVELING_SETTIGNS_UI:
+        //draw_LevelingSettings();
+        break;
+      case LEVELING_PARA_UI:
+        //draw_LevelingPara();
+        break;
+      case DELTA_LEVELING_PARA_UI:
+        //draw_DeltaLevelPara();
+        break;
+      case XYZ_LEVELING_PARA_UI:
+        //draw_XYZLevelPara();
+        break;
+      case MAXFEEDRATE_UI:
+        //draw_MaxFeedRate();
+        break;
+      case STEPS_UI:
+        //draw_Steps();
+        break;
+      case ACCELERATION_UI:
+        //draw_Acceleration();
+        break;
+      case JERK_UI:
+        //draw_Jerk();
+        break;
+      case MOTORDIR_UI:
+        //draw_MotorDir();
+        break;
+      case HOMESPEED_UI:
+        //draw_HomeSpeed();
+        break;
+      case NOZZLE_CONFIG_UI:
+        //draw_NozzleConfig();
+        break;
+      case HOTBED_CONFIG_UI:
+        //draw_HotbedConfig();
+        break;
+      case ADVANCED_UI:
+        //draw_Advanced();
+        break;
+      case DOUBLE_Z_UI:
+        //draw_DoubleZ();
+        break;
+      case ENABLE_INVERT_UI:
+        //draw_EnableInvert();
+        break;
+      case NUMBER_KEY_UI:
+        //draw_NumberKey();
+        break;
+      case DIALOG_UI:
+        //draw_dialog(DialogType);
+        break;
+      case BABY_STEP_UI:
+        //draw_babyStep();
+        break;
+      default: break;
+    }
+  }
+}
+
+#if ENABLED(SDSUPPORT)
+
+  void sd_detection() {
+    static bool last_sd_status;
+    const bool sd_status = IS_SD_INSERTED();
+    if (sd_status != last_sd_status) {
+      last_sd_status = sd_status;
+      if (sd_status) card.mount(); else card.release();
+    }
+  }
+
+#endif
+
+extern volatile uint32_t systick_uptime_millis;
+
+void print_time_count() {
+  if ((systick_uptime_millis % 1000) == 0)
+    if (print_time.start == 1) print_time.seconds++;
+}
+
+void LV_TASK_HANDLER() {
+  //lv_tick_inc(1);
+  lv_task_handler();
+  TERN_(MKS_TEST, mks_test());
+  disp_pre_gcode(2, 36);
+  GUI_RefreshPage();
+  //sd_detection();
+}
+
+#endif // TFT_LITTLE_VGL_UI
