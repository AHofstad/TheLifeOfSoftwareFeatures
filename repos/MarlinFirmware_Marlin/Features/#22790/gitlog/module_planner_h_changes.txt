commit 6fed66dd428f46d073a3c28f6ff39b13c86cc65e
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Mon Jul 1 21:56:06 2024 +0300

    ü©π‚ö°Ô∏è Fix judder, optimize planner (#27035)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index fd26b4340e..1053a27688 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -212,20 +212,21 @@ typedef struct PlannerBlock {
   bool is_sync() { return is_sync_pos() || is_sync_fan() || is_sync_pwr(); }
   bool is_page() { return TERN0(DIRECT_STEPPING, flag.page); }
   bool is_move() { return !(is_sync() || is_page()); }
 
   // Fields used by the motion planner to manage acceleration
   float nominal_speed,                      // The nominal speed for this block in (mm/sec)
         entry_speed_sqr,                    // Entry speed at previous-current junction in (mm/sec)^2
         min_entry_speed_sqr,                // Minimum allowable junction entry speed in (mm/sec)^2
         max_entry_speed_sqr,                // Maximum allowable junction entry speed in (mm/sec)^2
         millimeters,                        // The total travel of this block in mm
+        steps_per_mm,                       // steps/mm
         acceleration;                       // acceleration mm/sec^2
 
   union {
     abce_ulong_t steps;                     // Step count along each axis
     abce_long_t position;                   // New position to force when this sync block is executed
   };
   uint32_t step_event_count;                // The number of step events required to complete this block
 
   #if HAS_MULTI_EXTRUDER
     uint8_t extruder;                       // The extruder to move (if E move)
@@ -435,21 +436,20 @@ class Planner {
      *            head==tail : the buffer is empty
      *            head!=tail : blocks are in the buffer
      *   head==(tail-1)%size : the buffer is full
      *
      *  Writer of head is Planner::buffer_segment().
      *  Reader of tail is Stepper::isr(). Always consider tail busy / read-only
      */
     static block_t block_buffer[BLOCK_BUFFER_SIZE];
     static volatile uint8_t block_buffer_head,      // Index of the next block to be pushed
                             block_buffer_nonbusy,   // Index of the first non busy block
-                            block_buffer_planned,   // Index of the optimally planned block
                             block_buffer_tail;      // Index of the busy block, if any
     static uint16_t cleaning_buffer_counter;        // A counter to disable queuing of blocks
     static uint8_t delay_before_delivering;         // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;                 // Respond to extruder change
     #endif
 
     #if ENABLED(DIRECT_STEPPING)
       static uint32_t last_page_step_rate;          // Last page step rate given
@@ -797,21 +797,21 @@ class Planner {
       }
     #endif // HAS_POSITION_MODIFIERS
 
     // Number of moves currently in the planner including the busy block, if any
     FORCE_INLINE static uint8_t movesplanned() { return block_dec_mod(block_buffer_head, block_buffer_tail); }
 
     // Number of nonbusy moves currently in the planner
     FORCE_INLINE static uint8_t nonbusy_movesplanned() { return block_dec_mod(block_buffer_head, block_buffer_nonbusy); }
 
     // Remove all blocks from the buffer
-    FORCE_INLINE static void clear_block_buffer() { block_buffer_nonbusy = block_buffer_planned = block_buffer_head = block_buffer_tail = 0; }
+    FORCE_INLINE static void clear_block_buffer() { block_buffer_nonbusy = block_buffer_head = block_buffer_tail = 0; }
 
     // Check if movement queue is full
     FORCE_INLINE static bool is_full() { return block_buffer_tail == next_block_index(block_buffer_head); }
 
     // Get count of movement slots free
     FORCE_INLINE static uint8_t moves_free() { return (BLOCK_BUFFER_SIZE) - 1 - movesplanned(); }
 
     /**
      * Planner::get_next_free_block
      *
@@ -1074,27 +1074,26 @@ class Planner {
 
     #if ANY(S_CURVE_ACCELERATION, LIN_ADVANCE)
       /**
        * Calculate the speed reached given initial speed, acceleration and distance
        */
       static float final_speed(const_float_t initial_velocity, const_float_t accel, const_float_t distance) {
         return SQRT(sq(initial_velocity) + 2 * accel * distance);
       }
     #endif
 
-    static void calculate_trapezoid_for_block(block_t * const block, const_float_t entry_factor, const_float_t exit_factor);
+    static void calculate_trapezoid_for_block(block_t * const block, const_float_t entry_speed, const_float_t exit_speed);
 
-    static void reverse_pass_kernel(block_t * const current, const block_t * const next, const_float_t safe_exit_speed_sqr);
-    static void forward_pass_kernel(const block_t * const previous, block_t * const current, uint8_t block_index);
+    static bool reverse_pass_kernel(block_t * const current, const block_t * const next, const_float_t safe_exit_speed_sqr);
+    static void forward_pass_kernel(const block_t * const previous, block_t * const current);
 
     static void reverse_pass(const_float_t safe_exit_speed_sqr);
-    static void forward_pass();
 
     static void recalculate_trapezoids(const_float_t safe_exit_speed_sqr);
 
     static void recalculate(const_float_t safe_exit_speed_sqr);
 
     #if HAS_JUNCTION_DEVIATION
 
       FORCE_INLINE static void normalize_junction_vector(xyze_float_t &vector) {
         float magnitude_sq = 0;
         LOOP_LOGICAL_AXES(idx) if (vector[idx]) magnitude_sq += sq(vector[idx]);

commit 2fd7c2b8652a3250e1eb1dbfd96991b4b11f6257
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Fri May 17 04:48:21 2024 +0300

    ‚ö°Ô∏è Fix motion smoothness (#27013)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index a06dd50e04..fd26b4340e 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -231,22 +231,22 @@ typedef struct PlannerBlock {
     uint8_t extruder;                       // The extruder to move (if E move)
   #else
     static constexpr uint8_t extruder = 0;
   #endif
 
   #if ENABLED(MIXING_EXTRUDER)
     mixer_comp_t b_color[MIXING_STEPPERS];  // Normalized color for the mixing steppers
   #endif
 
   // Settings for the trapezoid generator
-  uint32_t accelerate_until,                // The index of the step event on which to stop acceleration
-           decelerate_after;                // The index of the step event on which to start decelerating
+  uint32_t accelerate_before,               // The index of the step event where cruising starts
+           decelerate_start;                // The index of the step event on which to start decelerating
 
   #if ENABLED(S_CURVE_ACCELERATION)
     uint32_t cruise_rate,                   // The actual cruise rate to use, between end of the acceleration phase and start of deceleration phase
              acceleration_time,             // Acceleration time and deceleration time in STEP timer counts
              deceleration_time,
              acceleration_time_inverse,     // Inverse of acceleration and deceleration periods, expressed as integer. Scale depends on CPU being used
              deceleration_time_inverse;
   #else
     uint32_t acceleration_rate;             // Acceleration rate in (2^24 steps)/timer_ticks*s
   #endif

commit 6423b8031deba6c7a1e21279d6c468c3c33d28e6
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Wed May 15 23:01:56 2024 +0300

    ‚ö°Ô∏è Add / enforce min_entry_speed_sqr (#27089)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 74a587f858..a06dd50e04 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -104,25 +104,20 @@
   #define HAS_DIST_MM_ARG 1
 #endif
 
 /**
  * Planner block flags as boolean bit fields
  */
 enum BlockFlagBit {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
-  // Nominal speed always reached.
-  // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
-  // from a safe speed (in consideration of jerking from zero speed).
-  BLOCK_BIT_NOMINAL_LENGTH,
-
   // The block is segment 2+ of a longer move
   BLOCK_BIT_CONTINUED,
 
   // Sync the stepper counts from the block
   BLOCK_BIT_SYNC_POSITION
 
   // Direct stepping page
   OPTARG(DIRECT_STEPPING, BLOCK_BIT_PAGE)
 
   // Sync the fan speeds from the block
@@ -135,22 +130,20 @@ enum BlockFlagBit {
 /**
  * Planner block flags as boolean bit fields
  */
 typedef struct {
   union {
     uint8_t bits;
 
     struct {
       bool recalculate:1;
 
-      bool nominal_length:1;
-
       bool continued:1;
 
       bool sync_position:1;
 
       #if ENABLED(DIRECT_STEPPING)
         bool page:1;
       #endif
 
       #if ENABLED(LASER_SYNCHRONOUS_M106_M107)
         bool sync_fans:1;
@@ -159,21 +152,20 @@ typedef struct {
       #if ENABLED(LASER_POWER_SYNC)
         bool sync_laser_pwr:1;
       #endif
     };
   };
 
   void clear() volatile { bits = 0; }
   void apply(const uint8_t f) volatile { bits |= f; }
   void apply(const BlockFlagBit b) volatile { SBI(bits, b); }
   void reset(const BlockFlagBit b) volatile { bits = _BV(b); }
-  void set_nominal(const bool n) volatile { recalculate = true; if (n) nominal_length = true; }
 
 } block_flags_t;
 
 #if ENABLED(AUTOTEMP)
   typedef struct {
     celsius_t min, max;
     float factor;
     bool enabled;
   } autotemp_t;
 #endif
@@ -217,20 +209,21 @@ typedef struct PlannerBlock {
   bool is_sync_pos() { return flag.sync_position; }
   bool is_sync_fan() { return TERN0(LASER_SYNCHRONOUS_M106_M107, flag.sync_fans); }
   bool is_sync_pwr() { return TERN0(LASER_POWER_SYNC, flag.sync_laser_pwr); }
   bool is_sync() { return is_sync_pos() || is_sync_fan() || is_sync_pwr(); }
   bool is_page() { return TERN0(DIRECT_STEPPING, flag.page); }
   bool is_move() { return !(is_sync() || is_page()); }
 
   // Fields used by the motion planner to manage acceleration
   float nominal_speed,                      // The nominal speed for this block in (mm/sec)
         entry_speed_sqr,                    // Entry speed at previous-current junction in (mm/sec)^2
+        min_entry_speed_sqr,                // Minimum allowable junction entry speed in (mm/sec)^2
         max_entry_speed_sqr,                // Maximum allowable junction entry speed in (mm/sec)^2
         millimeters,                        // The total travel of this block in mm
         acceleration;                       // acceleration mm/sec^2
 
   union {
     abce_ulong_t steps;                     // Step count along each axis
     abce_long_t position;                   // New position to force when this sync block is executed
   };
   uint32_t step_event_count;                // The number of step events required to complete this block
 
@@ -248,21 +241,21 @@ typedef struct PlannerBlock {
   uint32_t accelerate_until,                // The index of the step event on which to stop acceleration
            decelerate_after;                // The index of the step event on which to start decelerating
 
   #if ENABLED(S_CURVE_ACCELERATION)
     uint32_t cruise_rate,                   // The actual cruise rate to use, between end of the acceleration phase and start of deceleration phase
              acceleration_time,             // Acceleration time and deceleration time in STEP timer counts
              deceleration_time,
              acceleration_time_inverse,     // Inverse of acceleration and deceleration periods, expressed as integer. Scale depends on CPU being used
              deceleration_time_inverse;
   #else
-    uint32_t acceleration_rate;             // The acceleration rate used for acceleration calculation
+    uint32_t acceleration_rate;             // Acceleration rate in (2^24 steps)/timer_ticks*s
   #endif
 
   AxisBits direction_bits;                  // Direction bits set for this block, where 1 is negative motion
 
   // Advance extrusion
   #if ENABLED(LIN_ADVANCE)
     uint32_t la_advance_rate;               // The rate at which steps are added whilst accelerating
     uint8_t  la_scaling;                    // Scale ISR frequency down and step frequency up by 2 ^ la_scaling
     uint16_t max_adv_steps,                 // Max advance steps to get cruising speed pressure
              final_adv_steps;               // Advance steps for exit speed pressure

commit 4a5bd47b6a8d48f6c0045399e667f2c521faa213
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 11 13:40:29 2024 -0500

    üé® Apply MUL_TERN

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index e783b0cd0f..74a587f858 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -627,21 +627,21 @@ class Planner {
 
     // For an axis set the Maximum Jerk (instant change) in mm/s
     #if ENABLED(CLASSIC_JERK)
       static void set_max_jerk(const AxisEnum axis, float inMaxJerkMMS);
     #else
       static void set_max_jerk(const AxisEnum, const_float_t) {}
     #endif
 
     #if HAS_EXTRUDERS
       FORCE_INLINE static void refresh_e_factor(const uint8_t e) {
-        e_factor[e] = flow_percentage[e] * 0.01f * TERN(NO_VOLUMETRICS, 1.0f, volumetric_multiplier[e]);
+        e_factor[e] = flow_percentage[e] * 0.01f IF_DISABLED(NO_VOLUMETRICS, * volumetric_multiplier[e]);
       }
 
       static void set_flow(const uint8_t e, const int16_t flow) {
         flow_percentage[e] = flow;
         refresh_e_factor(e);
       }
 
     #endif
 
     // Manage fans, paste pressure, etc.

commit 1da947f54806437fdff84adfdc06f48d2e3d60a3
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Thu May 9 23:57:23 2024 +0200

    ‚ö°Ô∏è FT_MOTION : Core and other refinements (#26720)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: Ulendo Alex <alex@ulendo.io>

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index b7b1abbb61..e783b0cd0f 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -207,23 +207,24 @@ typedef struct {
  * A single entry in the planner buffer.
  * Tracks linear movement over multiple axes.
  *
  * The "nominal" values are as-specified by G-code, and
  * may never actually be reached due to acceleration limits.
  */
 typedef struct PlannerBlock {
 
   volatile block_flags_t flag;              // Block flags
 
-  bool is_fan_sync() { return TERN0(LASER_SYNCHRONOUS_M106_M107, flag.sync_fans); }
-  bool is_pwr_sync() { return TERN0(LASER_POWER_SYNC, flag.sync_laser_pwr); }
-  bool is_sync() { return flag.sync_position || is_fan_sync() || is_pwr_sync(); }
+  bool is_sync_pos() { return flag.sync_position; }
+  bool is_sync_fan() { return TERN0(LASER_SYNCHRONOUS_M106_M107, flag.sync_fans); }
+  bool is_sync_pwr() { return TERN0(LASER_POWER_SYNC, flag.sync_laser_pwr); }
+  bool is_sync() { return is_sync_pos() || is_sync_fan() || is_sync_pwr(); }
   bool is_page() { return TERN0(DIRECT_STEPPING, flag.page); }
   bool is_move() { return !(is_sync() || is_page()); }
 
   // Fields used by the motion planner to manage acceleration
   float nominal_speed,                      // The nominal speed for this block in (mm/sec)
         entry_speed_sqr,                    // Entry speed at previous-current junction in (mm/sec)^2
         max_entry_speed_sqr,                // Maximum allowable junction entry speed in (mm/sec)^2
         millimeters,                        // The total travel of this block in mm
         acceleration;                       // acceleration mm/sec^2
 

commit c91771a51e32dd490b1298fa2eef3af67f033553
Author: Vovodroid <vovodroid@users.noreply.github.com>
Date:   Sun Apr 7 08:41:01 2024 +0300

    ü©πDisable nonlinear extrusion on unretract (#26824)
    
    * Fixes disable NLE on unretract #26808, which reported blobs at the start of lines during unretract.

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 856e70e582..b7b1abbb61 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -1116,11 +1116,17 @@ class Planner {
           }
         }
         return limit_value;
       }
 
     #endif // HAS_JUNCTION_DEVIATION
 };
 
 #define PLANNER_XY_FEEDRATE() _MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS])
 
+#define ANY_AXIS_MOVES(BLOCK)  \
+  (false NUM_AXIS_GANG(        \
+  || BLOCK->steps.a, || BLOCK->steps.b, || BLOCK->steps.c, \
+  || BLOCK->steps.i, || BLOCK->steps.j, || BLOCK->steps.k, \
+  || BLOCK->steps.u, || BLOCK->steps.v, || BLOCK->steps.w))
+
 extern Planner planner;

commit 5639237e2b174715413f9ffc6f6421db9150d9d6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 29 20:38:03 2024 -0600

    üé® Misc. cleanup 29-01

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 42eee677cb..856e70e582 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -118,21 +118,20 @@ enum BlockFlagBit {
 
   // The block is segment 2+ of a longer move
   BLOCK_BIT_CONTINUED,
 
   // Sync the stepper counts from the block
   BLOCK_BIT_SYNC_POSITION
 
   // Direct stepping page
   OPTARG(DIRECT_STEPPING, BLOCK_BIT_PAGE)
 
-
   // Sync the fan speeds from the block
   OPTARG(LASER_SYNCHRONOUS_M106_M107, BLOCK_BIT_SYNC_FANS)
 
   // Sync laser power from a queued block
   OPTARG(LASER_POWER_SYNC, BLOCK_BIT_LASER_PWR)
 };
 
 /**
  * Planner block flags as boolean bit fields
  */
@@ -447,21 +446,20 @@ class Planner {
      *  Reader of tail is Stepper::isr(). Always consider tail busy / read-only
      */
     static block_t block_buffer[BLOCK_BUFFER_SIZE];
     static volatile uint8_t block_buffer_head,      // Index of the next block to be pushed
                             block_buffer_nonbusy,   // Index of the first non busy block
                             block_buffer_planned,   // Index of the optimally planned block
                             block_buffer_tail;      // Index of the busy block, if any
     static uint16_t cleaning_buffer_counter;        // A counter to disable queuing of blocks
     static uint8_t delay_before_delivering;         // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
-
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;                 // Respond to extruder change
     #endif
 
     #if ENABLED(DIRECT_STEPPING)
       static uint32_t last_page_step_rate;          // Last page step rate given
       static AxisBits last_page_dir;                // Last page direction given, where 1 represents forward or positive motion
     #endif
 
     #if HAS_EXTRUDERS

commit 854f3315af645775e7b0aa39bd05db66187bcc38
Author: plampix <plampix@users.noreply.github.com>
Date:   Wed Jan 10 07:33:54 2024 +0100

    ‚ú® EDITABLE_STEPS_PER_UNIT (#26618)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 726ccb4d3f..42eee677cb 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -333,24 +333,44 @@ constexpr uint8_t block_inc_mod(const uint8_t v1, const uint8_t v2) {
     /**
      * Laser power: 0 or 255 in case of PWM-less laser,
      * or the OCR (oscillator count register) value;
      * Using OCR instead of raw power, because it avoids
      * floating point operations during the move loop.
      */
     volatile uint8_t power;
   } laser_state_t;
 #endif
 
-typedef struct {
+#if DISABLED(EDITABLE_STEPS_PER_UNIT)
+  static constexpr float _dasu[] = DEFAULT_AXIS_STEPS_PER_UNIT;
+#endif
+
+typedef struct PlannerSettings {
    uint32_t max_acceleration_mm_per_s2[DISTINCT_AXES], // (mm/s^2) M201 XYZE
             min_segment_time_us;                // (¬µs) M205 B
-      float axis_steps_per_mm[DISTINCT_AXES];   // (steps) M92 XYZE - Steps per millimeter
+
+  // (steps) M92 XYZE - Steps per millimeter
+  #if ENABLED(EDITABLE_STEPS_PER_UNIT)
+    float axis_steps_per_mm[DISTINCT_AXES];
+  #else
+    #define _DLIM(I) _MIN(I, (signed)COUNT(_dasu) - 1)
+    #define _DASU(N) _dasu[_DLIM(N)],
+    #define _EASU(N) _dasu[_DLIM(E_AXIS + N)],
+    static constexpr float axis_steps_per_mm[DISTINCT_AXES] = {
+      REPEAT(NUM_AXES, _DASU)
+      TERN_(HAS_EXTRUDERS, REPEAT(DISTINCT_E, _EASU))
+    };
+    #undef _EASU
+    #undef _DASU
+    #undef _DLIM
+  #endif
+
  feedRate_t max_feedrate_mm_s[DISTINCT_AXES];   // (mm/s) M203 XYZE - Max speeds
       float acceleration,                       // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
             retract_acceleration,               // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
             travel_acceleration;                // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
  feedRate_t min_feedrate_mm_s,                  // (mm/s) M205 S - Minimum linear feedrate
             min_travel_feedrate_mm_s;           // (mm/s) M205 T - Minimum travel feedrate
 } planner_settings_t;
 
 #if ENABLED(IMPROVE_HOMING_RELIABILITY)
   struct motion_state_t {
@@ -443,39 +463,46 @@ class Planner {
       static uint32_t last_page_step_rate;          // Last page step rate given
       static AxisBits last_page_dir;                // Last page direction given, where 1 represents forward or positive motion
     #endif
 
     #if HAS_EXTRUDERS
       static int16_t flow_percentage[EXTRUDERS];    // Extrusion factor for each extruder
       static float e_factor[EXTRUDERS];             // The flow percentage and volumetric multiplier combine to scale E movement
     #endif
 
     #if DISABLED(NO_VOLUMETRICS)
-      static float filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
-                   volumetric_area_nominal,           // Nominal cross-sectional area
-                   volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
+      static float filament_size[EXTRUDERS],          // (mm) Diameter of filament, typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
+                   volumetric_area_nominal,           // (mm^3) Nominal cross-sectional area
+                   volumetric_multiplier[EXTRUDERS];  // (1/mm^2) Reciprocal of cross-sectional area of filament. Pre-calculated to reduce computation in the planner
                                                       // May be auto-adjusted by a filament width sensor
     #endif
 
     #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
-      static float volumetric_extruder_limit[EXTRUDERS],          // Maximum mm^3/sec the extruder can handle
-                   volumetric_extruder_feedrate_limit[EXTRUDERS]; // Feedrate limit (mm/s) calculated from volume limit
+      static float volumetric_extruder_limit[EXTRUDERS],          // (mm^3/sec) Maximum volume the extruder can handle
+                   volumetric_extruder_feedrate_limit[EXTRUDERS]; // (mm/s) Feedrate limit calculated from volume limit
     #endif
 
     static planner_settings_t settings;
 
     #if ENABLED(LASER_FEATURE)
       static laser_state_t laser_inline;
     #endif
 
     static uint32_t max_acceleration_steps_per_s2[DISTINCT_AXES]; // (steps/s^2) Derived from mm_per_s2
-    static float mm_per_step[DISTINCT_AXES];          // Millimeters per step
+
+    #if ENABLED(EDITABLE_STEPS_PER_UNIT)
+      static float mm_per_step[DISTINCT_AXES];        // Millimeters per step
+    #else
+      #define _RSTEP(N) RECIPROCAL(settings.axis_steps_per_mm[N]),
+      static constexpr float mm_per_step[DISTINCT_AXES] = { REPEAT(DISTINCT_AXES, _RSTEP) };
+      #undef _RSTEP
+    #endif
 
     #if HAS_JUNCTION_DEVIATION
       static float junction_deviation_mm;             // (mm) M205 J
       #if HAS_LINEAR_E_JERK
         static float max_e_jerk[DISTINCT_E];          // Calculated from junction_deviation_mm
       #endif
     #else // CLASSIC_JERK
       // (mm/s^2) M205 XYZ(E) - The largest speed change requiring no acceleration.
       static TERN(HAS_LINEAR_E_JERK, xyz_pos_t, xyze_pos_t) max_jerk;
     #endif

commit b90133813a96ce839e17da039b2679601ee59afc
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Thu Dec 14 22:16:15 2023 +0200

    üêõ Fix planner jerk limits (#26529)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index e746071de9..726ccb4d3f 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -468,23 +468,21 @@ class Planner {
     #endif
 
     static uint32_t max_acceleration_steps_per_s2[DISTINCT_AXES]; // (steps/s^2) Derived from mm_per_s2
     static float mm_per_step[DISTINCT_AXES];          // Millimeters per step
 
     #if HAS_JUNCTION_DEVIATION
       static float junction_deviation_mm;             // (mm) M205 J
       #if HAS_LINEAR_E_JERK
         static float max_e_jerk[DISTINCT_E];          // Calculated from junction_deviation_mm
       #endif
-    #endif
-
-    #if ENABLED(CLASSIC_JERK)
+    #else // CLASSIC_JERK
       // (mm/s^2) M205 XYZ(E) - The largest speed change requiring no acceleration.
       static TERN(HAS_LINEAR_E_JERK, xyz_pos_t, xyze_pos_t) max_jerk;
     #endif
 
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
       #if ABL_PLANAR
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)

commit 75da3555ee0910f3d572f4b8176afecdc941524b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Dec 14 10:03:11 2023 -0600

    üîß Update CLASSIC_JERK conditionals

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 5c98307577..e746071de9 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -348,21 +348,21 @@ typedef struct {
       float acceleration,                       // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
             retract_acceleration,               // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
             travel_acceleration;                // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
  feedRate_t min_feedrate_mm_s,                  // (mm/s) M205 S - Minimum linear feedrate
             min_travel_feedrate_mm_s;           // (mm/s) M205 T - Minimum travel feedrate
 } planner_settings_t;
 
 #if ENABLED(IMPROVE_HOMING_RELIABILITY)
   struct motion_state_t {
     TERN(DELTA, xyz_ulong_t, xy_ulong_t) acceleration;
-    #if HAS_CLASSIC_JERK
+    #if ENABLED(CLASSIC_JERK)
       TERN(DELTA, xyz_float_t, xy_float_t) jerk_state;
     #endif
   };
 #endif
 
 #if ENABLED(SKEW_CORRECTION)
   typedef struct {
     #if ENABLED(SKEW_CORRECTION_GCODE)
       float xy;
       #if ENABLED(SKEW_CORRECTION_FOR_Z)
@@ -470,21 +470,21 @@ class Planner {
     static uint32_t max_acceleration_steps_per_s2[DISTINCT_AXES]; // (steps/s^2) Derived from mm_per_s2
     static float mm_per_step[DISTINCT_AXES];          // Millimeters per step
 
     #if HAS_JUNCTION_DEVIATION
       static float junction_deviation_mm;             // (mm) M205 J
       #if HAS_LINEAR_E_JERK
         static float max_e_jerk[DISTINCT_E];          // Calculated from junction_deviation_mm
       #endif
     #endif
 
-    #if HAS_CLASSIC_JERK
+    #if ENABLED(CLASSIC_JERK)
       // (mm/s^2) M205 XYZ(E) - The largest speed change requiring no acceleration.
       static TERN(HAS_LINEAR_E_JERK, xyz_pos_t, xyze_pos_t) max_jerk;
     #endif
 
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
       #if ABL_PLANAR
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
@@ -595,21 +595,21 @@ class Planner {
      */
     static void refresh_positioning();
 
     // For an axis set the Maximum Acceleration in mm/s^2
     static void set_max_acceleration(const AxisEnum axis, float inMaxAccelMMS2);
 
     // For an axis set the Maximum Feedrate in mm/s
     static void set_max_feedrate(const AxisEnum axis, float inMaxFeedrateMMS);
 
     // For an axis set the Maximum Jerk (instant change) in mm/s
-    #if HAS_CLASSIC_JERK
+    #if ENABLED(CLASSIC_JERK)
       static void set_max_jerk(const AxisEnum axis, float inMaxJerkMMS);
     #else
       static void set_max_jerk(const AxisEnum, const_float_t) {}
     #endif
 
     #if HAS_EXTRUDERS
       FORCE_INLINE static void refresh_e_factor(const uint8_t e) {
         e_factor[e] = flow_percentage[e] * 0.01f * TERN(NO_VOLUMETRICS, 1.0f, volumetric_multiplier[e]);
       }
 

commit c666b492c4e188987e9382e6ec2e79453b5136bc
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Oct 27 23:06:04 2023 +0100

    üî• Automatic minimum planner junction speed (#26198)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 6fde0b2bf3..5c98307577 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -303,20 +303,28 @@ typedef struct PlannerBlock {
   #endif
 
   void reset() { memset((char*)this, 0, sizeof(*this)); }
 
 } block_t;
 
 #if ANY(LIN_ADVANCE, FEEDRATE_SCALING, GRADIENT_MIX, LCD_SHOW_E_TOTAL, POWER_LOSS_RECOVERY)
   #define HAS_POSITION_FLOAT 1
 #endif
 
+constexpr uint8_t block_dec_mod(const uint8_t v1, const uint8_t v2) {
+  return v1 >= v2 ? v1 - v2 : v1 - v2 + BLOCK_BUFFER_SIZE;
+}
+
+constexpr uint8_t block_inc_mod(const uint8_t v1, const uint8_t v2) {
+  return v1 + v2 < BLOCK_BUFFER_SIZE ? v1 + v2 : v1 + v2 - BLOCK_BUFFER_SIZE;
+}
+
 #if IS_POWER_OF_2(BLOCK_BUFFER_SIZE)
   #define BLOCK_MOD(n) ((n)&((BLOCK_BUFFER_SIZE)-1))
 #else
   #define BLOCK_MOD(n) ((n)%(BLOCK_BUFFER_SIZE))
 #endif
 
 #if ENABLED(LASER_FEATURE)
   typedef struct {
     /**
      * Laser status flags
@@ -539,20 +547,25 @@ class Planner {
     /**
      * Nominal speed of previous path line segment (mm/s)^2
      */
     static float previous_nominal_speed;
 
     /**
      * Limit where 64bit math is necessary for acceleration calculation
      */
     static uint32_t acceleration_long_cutoff;
 
+    #ifdef MAX7219_DEBUG_SLOWDOWN
+      friend class Max7219;
+      static uint8_t slowdown_count;
+    #endif
+
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       static float last_fade_z;
     #endif
 
     #if ENABLED(DISABLE_OTHER_EXTRUDERS)
       // Counters to manage disabling inactive extruder steppers
       static last_move_t extruder_last_move[E_STEPPERS];
     #endif
 
     #if HAS_WIRED_LCD
@@ -761,24 +774,24 @@ class Planner {
       }
 
       FORCE_INLINE static void unapply_modifiers(xyze_pos_t &pos, bool leveling=ENABLED(PLANNER_LEVELING)) {
         TERN_(FWRETRACT, unapply_retract(pos));
         if (leveling) unapply_leveling(pos);
         TERN_(SKEW_CORRECTION, unskew(pos));
       }
     #endif // HAS_POSITION_MODIFIERS
 
     // Number of moves currently in the planner including the busy block, if any
-    FORCE_INLINE static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail); }
+    FORCE_INLINE static uint8_t movesplanned() { return block_dec_mod(block_buffer_head, block_buffer_tail); }
 
     // Number of nonbusy moves currently in the planner
-    FORCE_INLINE static uint8_t nonbusy_movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_nonbusy); }
+    FORCE_INLINE static uint8_t nonbusy_movesplanned() { return block_dec_mod(block_buffer_head, block_buffer_nonbusy); }
 
     // Remove all blocks from the buffer
     FORCE_INLINE static void clear_block_buffer() { block_buffer_nonbusy = block_buffer_planned = block_buffer_head = block_buffer_tail = 0; }
 
     // Check if movement queue is full
     FORCE_INLINE static bool is_full() { return block_buffer_tail == next_block_index(block_buffer_head); }
 
     // Get count of movement slots free
     FORCE_INLINE static uint8_t moves_free() { return (BLOCK_BUFFER_SIZE) - 1 - movesplanned(); }
 
@@ -830,20 +843,21 @@ class Planner {
      * @param fr_mm_s       (target) speed of the move
      * @param extruder      target extruder
      * @param hints         parameters to aid planner calculations
      *
      * @return  true if movement is acceptable, false otherwise
      */
     static bool _populate_block(block_t * const block, const xyze_long_t &target
       OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
       OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
       , feedRate_t fr_mm_s, const uint8_t extruder, const PlannerHints &hints
+      , float &minimum_planner_speed_sqr
     );
 
     /**
      * Planner::buffer_sync_block
      * Add a block to the buffer that just updates the position
      * @param sync_flag sets a condition bit to process additional items
      * such as sync fan pwm or sync M3/M4 laser power into a queued block
      */
       static void buffer_sync_block(const BlockFlagBit flag=BLOCK_BIT_SYNC_POSITION);
 
@@ -1022,22 +1036,22 @@ class Planner {
       #if ENABLED(AUTOTEMP_PROPORTIONAL)
         static void _autotemp_update_from_hotend();
       #else
         static void _autotemp_update_from_hotend() {}
       #endif
     #endif
 
     /**
      * Get the index of the next / previous block in the ring buffer
      */
-    static constexpr uint8_t next_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index + 1); }
-    static constexpr uint8_t prev_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index - 1); }
+    static constexpr uint8_t next_block_index(const uint8_t block_index) { return block_inc_mod(block_index, 1); }
+    static constexpr uint8_t prev_block_index(const uint8_t block_index) { return block_dec_mod(block_index, 1); }
 
     /**
      * Calculate the maximum allowable speed squared at this point, in order
      * to reach 'target_velocity_sqr' using 'acceleration' within a given
      * 'distance'.
      */
     static float max_allowable_speed_sqr(const_float_t accel, const_float_t target_velocity_sqr, const_float_t distance) {
       return target_velocity_sqr - 2 * accel * distance;
     }
 
@@ -1045,29 +1059,29 @@ class Planner {
       /**
        * Calculate the speed reached given initial speed, acceleration and distance
        */
       static float final_speed(const_float_t initial_velocity, const_float_t accel, const_float_t distance) {
         return SQRT(sq(initial_velocity) + 2 * accel * distance);
       }
     #endif
 
     static void calculate_trapezoid_for_block(block_t * const block, const_float_t entry_factor, const_float_t exit_factor);
 
-    static void reverse_pass_kernel(block_t * const current, const block_t * const next OPTARG(ARC_SUPPORT, const_float_t safe_exit_speed_sqr));
+    static void reverse_pass_kernel(block_t * const current, const block_t * const next, const_float_t safe_exit_speed_sqr);
     static void forward_pass_kernel(const block_t * const previous, block_t * const current, uint8_t block_index);
 
-    static void reverse_pass(TERN_(ARC_SUPPORT, const_float_t safe_exit_speed_sqr));
+    static void reverse_pass(const_float_t safe_exit_speed_sqr);
     static void forward_pass();
 
-    static void recalculate_trapezoids(TERN_(ARC_SUPPORT, const_float_t safe_exit_speed_sqr));
+    static void recalculate_trapezoids(const_float_t safe_exit_speed_sqr);
 
-    static void recalculate(TERN_(ARC_SUPPORT, const_float_t safe_exit_speed_sqr));
+    static void recalculate(const_float_t safe_exit_speed_sqr);
 
     #if HAS_JUNCTION_DEVIATION
 
       FORCE_INLINE static void normalize_junction_vector(xyze_float_t &vector) {
         float magnitude_sq = 0;
         LOOP_LOGICAL_AXES(idx) if (vector[idx]) magnitude_sq += sq(vector[idx]);
         vector *= RSQRT(magnitude_sq);
       }
 
       FORCE_INLINE static float limit_value_by_axis_maximum(const_float_t max_value, xyze_float_t &unit_vec) {

commit e7e77d9612253cf7106cfc9e69f69e52f4083294
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 12 09:44:46 2023 -0500

    üßë‚Äçüíª FxdTiCtrl => FTMotion

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 238657be7b..6fde0b2bf3 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -522,24 +522,20 @@ class Planner {
       }
       static void set_min_speed_factor_u8(const uint8_t v255) {
         xy_freq_min_speed_factor = float(ui8_to_percent(v255)) / 100;
       }
       static void set_frequency_limit(const uint8_t hz) {
         xy_freq_limit_hz = constrain(hz, 0, 100);
         refresh_frequency_limit();
       }
     #endif
 
-    #if ENABLED(FT_MOTION)
-      static bool fxdTiCtrl_busy;
-    #endif
-
   private:
 
     /**
      * Speed of previous path line segment
      */
     static xyze_float_t previous_speed;
 
     /**
      * Nominal speed of previous path line segment (mm/s)^2
      */

commit ab8af7fa9cb7007ac710f62137e91f73446f8b60
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Aug 22 19:16:35 2023 -0500

    üîß Allow arbitrary BLOCK_BUFFER_SIZE

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index c45ff6ad1d..238657be7b 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -303,21 +303,25 @@ typedef struct PlannerBlock {
   #endif
 
   void reset() { memset((char*)this, 0, sizeof(*this)); }
 
 } block_t;
 
 #if ANY(LIN_ADVANCE, FEEDRATE_SCALING, GRADIENT_MIX, LCD_SHOW_E_TOTAL, POWER_LOSS_RECOVERY)
   #define HAS_POSITION_FLOAT 1
 #endif
 
-#define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
+#if IS_POWER_OF_2(BLOCK_BUFFER_SIZE)
+  #define BLOCK_MOD(n) ((n)&((BLOCK_BUFFER_SIZE)-1))
+#else
+  #define BLOCK_MOD(n) ((n)%(BLOCK_BUFFER_SIZE))
+#endif
 
 #if ENABLED(LASER_FEATURE)
   typedef struct {
     /**
      * Laser status flags
      */
     power_status_t status;
     /**
      * Laser power: 0 or 255 in case of PWM-less laser,
      * or the OCR (oscillator count register) value;
@@ -359,21 +363,21 @@ typedef struct {
         const float xz = XZ_SKEW_FACTOR, yz = YZ_SKEW_FACTOR;
       #endif
     #else
       const float xy = XY_SKEW_FACTOR,
                   xz = XZ_SKEW_FACTOR, yz = YZ_SKEW_FACTOR;
     #endif
   } skew_factor_t;
 #endif
 
 #if ENABLED(DISABLE_OTHER_EXTRUDERS)
-  typedef uvalue_t(BLOCK_BUFFER_SIZE * 2) last_move_t;
+  typedef uvalue_t((BLOCK_BUFFER_SIZE) * 2) last_move_t;
 #endif
 
 #if ENABLED(ARC_SUPPORT)
   #define HINTS_CURVE_RADIUS
   #define HINTS_SAFE_EXIT_SPEED
 #endif
 
 struct PlannerHints {
   float millimeters = 0.0;            // Move Length, if known, else 0.
   #if ENABLED(FEEDRATE_SCALING)
@@ -773,21 +777,21 @@ class Planner {
     // Number of nonbusy moves currently in the planner
     FORCE_INLINE static uint8_t nonbusy_movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_nonbusy); }
 
     // Remove all blocks from the buffer
     FORCE_INLINE static void clear_block_buffer() { block_buffer_nonbusy = block_buffer_planned = block_buffer_head = block_buffer_tail = 0; }
 
     // Check if movement queue is full
     FORCE_INLINE static bool is_full() { return block_buffer_tail == next_block_index(block_buffer_head); }
 
     // Get count of movement slots free
-    FORCE_INLINE static uint8_t moves_free() { return BLOCK_BUFFER_SIZE - 1 - movesplanned(); }
+    FORCE_INLINE static uint8_t moves_free() { return (BLOCK_BUFFER_SIZE) - 1 - movesplanned(); }
 
     /**
      * Planner::get_next_free_block
      *
      * - Get the next head indices (passed by reference)
      * - Wait for the number of spaces to open up in the planner
      * - Return the first head block
      */
     FORCE_INLINE static block_t* get_next_free_block(uint8_t &next_buffer_head, const uint8_t count=1) {
 

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index e74aea56a5..c45ff6ad1d 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -643,21 +643,21 @@ class Planner {
       #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
         // Update pre calculated extruder feedrate limits based on volumetric values
         static void calculate_volumetric_extruder_limit(const uint8_t e);
         static void calculate_volumetric_extruder_limits();
       #endif
 
       FORCE_INLINE static void set_filament_size(const uint8_t e, const_float_t v) {
         filament_size[e] = v;
         if (v > 0) volumetric_area_nominal = CIRCLE_AREA(v * 0.5); //TODO: should it be per extruder
         // make sure all extruders have some sane value for the filament size
-        LOOP_L_N(i, COUNT(filament_size))
+        for (uint8_t i = 0; i < COUNT(filament_size); ++i)
           if (!filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;
       }
 
     #endif
 
     #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
       FORCE_INLINE static void set_volumetric_extruder_limit(const uint8_t e, const_float_t v) {
         volumetric_extruder_limit[e] = v;
         calculate_volumetric_extruder_limit(e);
       }

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index ee79c913af..e74aea56a5 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -931,21 +931,21 @@ class Planner {
       const abce_pos_t out = LOGICAL_AXIS_ARRAY(
         get_axis_position_mm(E_AXIS),
         get_axis_position_mm(A_AXIS), get_axis_position_mm(B_AXIS), get_axis_position_mm(C_AXIS),
         get_axis_position_mm(I_AXIS), get_axis_position_mm(J_AXIS), get_axis_position_mm(K_AXIS),
         get_axis_position_mm(U_AXIS), get_axis_position_mm(V_AXIS), get_axis_position_mm(W_AXIS)
       );
       return out;
     }
 
     // SCARA AB and Polar YB axes are in degrees, not mm
-    #if EITHER(IS_SCARA, POLAR)
+    #if ANY(IS_SCARA, POLAR)
       FORCE_INLINE static float get_axis_position_degrees(const AxisEnum axis) { return get_axis_position_mm(axis); }
     #endif
 
     // Called to force a quick stop of the machine (for example, when
     // a Full Shutdown is required, or when endstops are hit)
     static void quick_stop();
 
     #if ENABLED(REALTIME_REPORTING_COMMANDS)
       // Force a quick pause of the machine (e.g., when a pause is required in the middle of move).
       // NOTE: Hard-stops will lose steps so encoders are highly recommended if using these!
@@ -1034,21 +1034,21 @@ class Planner {
 
     /**
      * Calculate the maximum allowable speed squared at this point, in order
      * to reach 'target_velocity_sqr' using 'acceleration' within a given
      * 'distance'.
      */
     static float max_allowable_speed_sqr(const_float_t accel, const_float_t target_velocity_sqr, const_float_t distance) {
       return target_velocity_sqr - 2 * accel * distance;
     }
 
-    #if EITHER(S_CURVE_ACCELERATION, LIN_ADVANCE)
+    #if ANY(S_CURVE_ACCELERATION, LIN_ADVANCE)
       /**
        * Calculate the speed reached given initial speed, acceleration and distance
        */
       static float final_speed(const_float_t initial_velocity, const_float_t accel, const_float_t distance) {
         return SQRT(sq(initial_velocity) + 2 * accel * distance);
       }
     #endif
 
     static void calculate_trapezoid_for_block(block_t * const block, const_float_t entry_factor, const_float_t exit_factor);
 

commit 772e19aab988b5d6466bdf2e8948c8c7eee3cafd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 24 22:10:40 2023 -0500

    ‚ú® EP_BABYSTEPPING (#25869)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 4b68c5f656..ee79c913af 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -81,20 +81,32 @@
 // Feedrate for manual moves
 #ifdef MANUAL_FEEDRATE
   constexpr xyze_feedrate_t manual_feedrate_mm_m = MANUAL_FEEDRATE,
                             manual_feedrate_mm_s = LOGICAL_AXIS_ARRAY(
                               MMM_TO_MMS(manual_feedrate_mm_m.e),
                               MMM_TO_MMS(manual_feedrate_mm_m.x), MMM_TO_MMS(manual_feedrate_mm_m.y), MMM_TO_MMS(manual_feedrate_mm_m.z),
                               MMM_TO_MMS(manual_feedrate_mm_m.i), MMM_TO_MMS(manual_feedrate_mm_m.j), MMM_TO_MMS(manual_feedrate_mm_m.k),
                               MMM_TO_MMS(manual_feedrate_mm_m.u), MMM_TO_MMS(manual_feedrate_mm_m.v), MMM_TO_MMS(manual_feedrate_mm_m.w));
 #endif
 
+#if ENABLED(BABYSTEPPING)
+  #if ENABLED(BABYSTEP_MILLIMETER_UNITS)
+    #define BABYSTEP_SIZE_X int32_t((BABYSTEP_MULTIPLICATOR_XY) * planner.settings.axis_steps_per_mm[X_AXIS])
+    #define BABYSTEP_SIZE_Y int32_t((BABYSTEP_MULTIPLICATOR_XY) * planner.settings.axis_steps_per_mm[Y_AXIS])
+    #define BABYSTEP_SIZE_Z int32_t((BABYSTEP_MULTIPLICATOR_Z)  * planner.settings.axis_steps_per_mm[Z_AXIS])
+  #else
+    #define BABYSTEP_SIZE_X BABYSTEP_MULTIPLICATOR_XY
+    #define BABYSTEP_SIZE_Y BABYSTEP_MULTIPLICATOR_XY
+    #define BABYSTEP_SIZE_Z BABYSTEP_MULTIPLICATOR_Z
+  #endif
+#endif
+
 #if IS_KINEMATIC && HAS_JUNCTION_DEVIATION
   #define HAS_DIST_MM_ARG 1
 #endif
 
 /**
  * Planner block flags as boolean bit fields
  */
 enum BlockFlagBit {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,

commit 25ddde0394361c23194c0f4a8f9777d389040af3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 15 22:00:15 2023 -0500

    üßë‚Äçüíª Change Marlin DIR bits: 1=Forward, 0=Reverse (#25791)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index eb0f072f4b..4b68c5f656 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -410,21 +410,21 @@ class Planner {
     static uint16_t cleaning_buffer_counter;        // A counter to disable queuing of blocks
     static uint8_t delay_before_delivering;         // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;                 // Respond to extruder change
     #endif
 
     #if ENABLED(DIRECT_STEPPING)
       static uint32_t last_page_step_rate;          // Last page step rate given
-      static xyze_bool_t last_page_dir;             // Last page direction given
+      static AxisBits last_page_dir;                // Last page direction given, where 1 represents forward or positive motion
     #endif
 
     #if HAS_EXTRUDERS
       static int16_t flow_percentage[EXTRUDERS];    // Extrusion factor for each extruder
       static float e_factor[EXTRUDERS];             // The flow percentage and volumetric multiplier combine to scale E movement
     #endif
 
     #if DISABLED(NO_VOLUMETRICS)
       static float filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
                    volumetric_area_nominal,           // Nominal cross-sectional area

commit 664b35b77c0ddf9562de6e74dd253f5bb33ce6b0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 03:03:33 2023 -0500

    üßë‚Äçüíª Replace axis_bits_t with AxisBits class (#25761)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index e072e94dbd..eb0f072f4b 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -239,21 +239,21 @@ typedef struct PlannerBlock {
   #if ENABLED(S_CURVE_ACCELERATION)
     uint32_t cruise_rate,                   // The actual cruise rate to use, between end of the acceleration phase and start of deceleration phase
              acceleration_time,             // Acceleration time and deceleration time in STEP timer counts
              deceleration_time,
              acceleration_time_inverse,     // Inverse of acceleration and deceleration periods, expressed as integer. Scale depends on CPU being used
              deceleration_time_inverse;
   #else
     uint32_t acceleration_rate;             // The acceleration rate used for acceleration calculation
   #endif
 
-  axis_bits_t direction_bits;               // Direction bits set for this block, where 1 is negative motion
+  AxisBits direction_bits;                  // Direction bits set for this block, where 1 is negative motion
 
   // Advance extrusion
   #if ENABLED(LIN_ADVANCE)
     uint32_t la_advance_rate;               // The rate at which steps are added whilst accelerating
     uint8_t  la_scaling;                    // Scale ISR frequency down and step frequency up by 2 ^ la_scaling
     uint16_t max_adv_steps,                 // Max advance steps to get cruising speed pressure
              final_adv_steps;               // Advance steps for exit speed pressure
   #endif
 
   uint32_t nominal_rate,                    // The nominal step rate for this block in step_events/sec

commit 2538a7c4d6148d8249f5418a76c58ec483343d2b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 29 21:28:12 2023 -0500

    üßë‚Äçüíª Move DIR inverting to *_DIR_WRITE

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 030c1b31db..e072e94dbd 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -239,21 +239,21 @@ typedef struct PlannerBlock {
   #if ENABLED(S_CURVE_ACCELERATION)
     uint32_t cruise_rate,                   // The actual cruise rate to use, between end of the acceleration phase and start of deceleration phase
              acceleration_time,             // Acceleration time and deceleration time in STEP timer counts
              deceleration_time,
              acceleration_time_inverse,     // Inverse of acceleration and deceleration periods, expressed as integer. Scale depends on CPU being used
              deceleration_time_inverse;
   #else
     uint32_t acceleration_rate;             // The acceleration rate used for acceleration calculation
   #endif
 
-  axis_bits_t direction_bits;               // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
+  axis_bits_t direction_bits;               // Direction bits set for this block, where 1 is negative motion
 
   // Advance extrusion
   #if ENABLED(LIN_ADVANCE)
     uint32_t la_advance_rate;               // The rate at which steps are added whilst accelerating
     uint8_t  la_scaling;                    // Scale ISR frequency down and step frequency up by 2 ^ la_scaling
     uint16_t max_adv_steps,                 // Max advance steps to get cruising speed pressure
              final_adv_steps;               // Advance steps for exit speed pressure
   #endif
 
   uint32_t nominal_rate,                    // The nominal step rate for this block in step_events/sec

commit 161b99cb54f5d6d183877902581d3d77e8a1fa78
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 14 01:08:51 2023 -0500

    üêõ Fix some bad feedrates (#25672)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index e2d1d6739c..030c1b31db 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -73,25 +73,26 @@
 #if ENABLED(DIRECT_STEPPING)
   #include "../feature/direct_stepping.h"
 #endif
 
 #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
   #include "../feature/closedloop.h"
 #endif
 
 // Feedrate for manual moves
 #ifdef MANUAL_FEEDRATE
-  constexpr xyze_feedrate_t _mf = MANUAL_FEEDRATE,
-           manual_feedrate_mm_s = LOGICAL_AXIS_ARRAY(_mf.e / 60.0f,
-                                                     _mf.x / 60.0f, _mf.y / 60.0f, _mf.z / 60.0f,
-                                                     _mf.i / 60.0f, _mf.j / 60.0f, _mf.k / 60.0f,
-                                                     _mf.u / 60.0f, _mf.v / 60.0f, _mf.w / 60.0f);
+  constexpr xyze_feedrate_t manual_feedrate_mm_m = MANUAL_FEEDRATE,
+                            manual_feedrate_mm_s = LOGICAL_AXIS_ARRAY(
+                              MMM_TO_MMS(manual_feedrate_mm_m.e),
+                              MMM_TO_MMS(manual_feedrate_mm_m.x), MMM_TO_MMS(manual_feedrate_mm_m.y), MMM_TO_MMS(manual_feedrate_mm_m.z),
+                              MMM_TO_MMS(manual_feedrate_mm_m.i), MMM_TO_MMS(manual_feedrate_mm_m.j), MMM_TO_MMS(manual_feedrate_mm_m.k),
+                              MMM_TO_MMS(manual_feedrate_mm_m.u), MMM_TO_MMS(manual_feedrate_mm_m.v), MMM_TO_MMS(manual_feedrate_mm_m.w));
 #endif
 
 #if IS_KINEMATIC && HAS_JUNCTION_DEVIATION
   #define HAS_DIST_MM_ARG 1
 #endif
 
 /**
  * Planner block flags as boolean bit fields
  */
 enum BlockFlagBit {

commit c37fa3cc9097a9aa7fad5f168e335caabf23278e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 31 21:18:37 2023 -0500

    ‚ú® Fixed-Time Motion with Input Shaping by Ulendo (#25394)
    
    Co-authored-by: Ulendo Alex <alex@ulendo.io>

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index ccf6ba08d3..e2d1d6739c 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -505,20 +505,24 @@ class Planner {
       }
       static void set_min_speed_factor_u8(const uint8_t v255) {
         xy_freq_min_speed_factor = float(ui8_to_percent(v255)) / 100;
       }
       static void set_frequency_limit(const uint8_t hz) {
         xy_freq_limit_hz = constrain(hz, 0, 100);
         refresh_frequency_limit();
       }
     #endif
 
+    #if ENABLED(FT_MOTION)
+      static bool fxdTiCtrl_busy;
+    #endif
+
   private:
 
     /**
      * Speed of previous path line segment
      */
     static xyze_float_t previous_speed;
 
     /**
      * Nominal speed of previous path line segment (mm/s)^2
      */

commit 61f22f34d32ca33d99233eb5b242e52c23aabb23
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 26 17:24:40 2023 -0500

    üîß Clarify axis disable / timeout (#25571)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 9497912d2f..ccf6ba08d3 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -345,21 +345,21 @@ typedef struct {
       #else
         const float xz = XZ_SKEW_FACTOR, yz = YZ_SKEW_FACTOR;
       #endif
     #else
       const float xy = XY_SKEW_FACTOR,
                   xz = XZ_SKEW_FACTOR, yz = YZ_SKEW_FACTOR;
     #endif
   } skew_factor_t;
 #endif
 
-#if ENABLED(DISABLE_INACTIVE_EXTRUDER)
+#if ENABLED(DISABLE_OTHER_EXTRUDERS)
   typedef uvalue_t(BLOCK_BUFFER_SIZE * 2) last_move_t;
 #endif
 
 #if ENABLED(ARC_SUPPORT)
   #define HINTS_CURVE_RADIUS
   #define HINTS_SAFE_EXIT_SPEED
 #endif
 
 struct PlannerHints {
   float millimeters = 0.0;            // Move Length, if known, else 0.
@@ -526,21 +526,21 @@ class Planner {
 
     /**
      * Limit where 64bit math is necessary for acceleration calculation
      */
     static uint32_t acceleration_long_cutoff;
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       static float last_fade_z;
     #endif
 
-    #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
+    #if ENABLED(DISABLE_OTHER_EXTRUDERS)
       // Counters to manage disabling inactive extruder steppers
       static last_move_t extruder_last_move[E_STEPPERS];
     #endif
 
     #if HAS_WIRED_LCD
       volatile static uint32_t block_buffer_runtime_us; // Theoretical block buffer runtime in ¬µs
     #endif
 
   public:
 

commit f0c8c9182090f8929ec4766683ec2d6902d4bc00
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 3 20:44:24 2023 -0600

    üßë‚Äçüíª Width/Magnitude-based types (#25458)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index b63fabb84d..9497912d2f 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -346,21 +346,21 @@ typedef struct {
         const float xz = XZ_SKEW_FACTOR, yz = YZ_SKEW_FACTOR;
       #endif
     #else
       const float xy = XY_SKEW_FACTOR,
                   xz = XZ_SKEW_FACTOR, yz = YZ_SKEW_FACTOR;
     #endif
   } skew_factor_t;
 #endif
 
 #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
-  typedef IF<(BLOCK_BUFFER_SIZE > 64), uint16_t, uint8_t>::type last_move_t;
+  typedef uvalue_t(BLOCK_BUFFER_SIZE * 2) last_move_t;
 #endif
 
 #if ENABLED(ARC_SUPPORT)
   #define HINTS_CURVE_RADIUS
   #define HINTS_SAFE_EXIT_SPEED
 #endif
 
 struct PlannerHints {
   float millimeters = 0.0;            // Move Length, if known, else 0.
   #if ENABLED(FEEDRATE_SCALING)
@@ -528,21 +528,21 @@ class Planner {
      * Limit where 64bit math is necessary for acceleration calculation
      */
     static uint32_t acceleration_long_cutoff;
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       static float last_fade_z;
     #endif
 
     #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
       // Counters to manage disabling inactive extruder steppers
-      static last_move_t g_uc_extruder_last_move[E_STEPPERS];
+      static last_move_t extruder_last_move[E_STEPPERS];
     #endif
 
     #if HAS_WIRED_LCD
       volatile static uint32_t block_buffer_runtime_us; // Theoretical block buffer runtime in ¬µs
     #endif
 
   public:
 
     /**
      * Instance Methods

commit babd3b0037d660f52cccbb295b8839b8dd744036
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Tue Feb 21 19:26:10 2023 +0100

    üßë‚Äçüíª Add get_move_distance for rotation/kinematics (#25370)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 7cc8bc08e4..b63fabb84d 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -370,20 +370,25 @@ struct PlannerHints {
     float curve_radius = 0.0;         // Radius of curvature of the motion path - to calculate cornering speed
   #else
     static constexpr float curve_radius = 0.0;
   #endif
   #if ENABLED(HINTS_SAFE_EXIT_SPEED)
     float safe_exit_speed_sqr = 0.0;  // Square of the speed considered "safe" at the end of the segment
                                       // i.e., at or below the exit speed of the segment that the planner
                                       // would calculate if it knew the as-yet-unbuffered path
   #endif
 
+  #if HAS_ROTATIONAL_AXES
+    bool cartesian_move = true;       // True if linear motion of the tool centerpoint relative to the workpiece occurs.
+                                      // False if no movement of the tool center point relative to the work piece occurs
+                                      // (i.e. the tool rotates around the tool centerpoint)
+  #endif
   PlannerHints(const_float_t mm=0.0f) : millimeters(mm) {}
 };
 
 class Planner {
   public:
 
     /**
      * The move buffer, calculated in stepper steps
      *
      * block_buffer is a ring buffer...

commit 7717beb79362522b8239d5af62b32ff3d0e2d748
Author: kadir ilkimen <kadirilkimen@gmail.com>
Date:   Wed Jan 11 06:29:38 2023 +0200

    ‚ú® Polar Kinematics (#25214)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 04cde2381d..7cc8bc08e4 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -43,20 +43,22 @@
   #define JD_USE_LOOKUP_TABLE
 #endif
 
 #include "motion.h"
 #include "../gcode/queue.h"
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #elif ENABLED(POLARGRAPH)
   #include "polargraph.h"
+#elif ENABLED(POLAR)
+  #include "polar.h"
 #endif
 
 #if ABL_PLANAR
   #include "../libs/vector_3.h" // for matrix_3x3
 #endif
 
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
 #endif
 
@@ -284,21 +286,21 @@ typedef struct PlannerBlock {
   #endif
 
   #if ENABLED(LASER_FEATURE)
     block_laser_t laser;
   #endif
 
   void reset() { memset((char*)this, 0, sizeof(*this)); }
 
 } block_t;
 
-#if ANY(LIN_ADVANCE, SCARA_FEEDRATE_SCALING, GRADIENT_MIX, LCD_SHOW_E_TOTAL, POWER_LOSS_RECOVERY)
+#if ANY(LIN_ADVANCE, FEEDRATE_SCALING, GRADIENT_MIX, LCD_SHOW_E_TOTAL, POWER_LOSS_RECOVERY)
   #define HAS_POSITION_FLOAT 1
 #endif
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 #if ENABLED(LASER_FEATURE)
   typedef struct {
     /**
      * Laser status flags
      */
@@ -354,21 +356,21 @@ typedef struct {
   typedef IF<(BLOCK_BUFFER_SIZE > 64), uint16_t, uint8_t>::type last_move_t;
 #endif
 
 #if ENABLED(ARC_SUPPORT)
   #define HINTS_CURVE_RADIUS
   #define HINTS_SAFE_EXIT_SPEED
 #endif
 
 struct PlannerHints {
   float millimeters = 0.0;            // Move Length, if known, else 0.
-  #if ENABLED(SCARA_FEEDRATE_SCALING)
+  #if ENABLED(FEEDRATE_SCALING)
     float inv_duration = 0.0;         // Reciprocal of the move duration, if known
   #endif
   #if ENABLED(HINTS_CURVE_RADIUS)
     float curve_radius = 0.0;         // Radius of curvature of the motion path - to calculate cornering speed
   #else
     static constexpr float curve_radius = 0.0;
   #endif
   #if ENABLED(HINTS_SAFE_EXIT_SPEED)
     float safe_exit_speed_sqr = 0.0;  // Square of the speed considered "safe" at the end of the segment
                                       // i.e., at or below the exit speed of the segment that the planner
@@ -906,22 +908,22 @@ class Planner {
     static abce_pos_t get_axis_positions_mm() {
       const abce_pos_t out = LOGICAL_AXIS_ARRAY(
         get_axis_position_mm(E_AXIS),
         get_axis_position_mm(A_AXIS), get_axis_position_mm(B_AXIS), get_axis_position_mm(C_AXIS),
         get_axis_position_mm(I_AXIS), get_axis_position_mm(J_AXIS), get_axis_position_mm(K_AXIS),
         get_axis_position_mm(U_AXIS), get_axis_position_mm(V_AXIS), get_axis_position_mm(W_AXIS)
       );
       return out;
     }
 
-    // SCARA AB axes are in degrees, not mm
-    #if IS_SCARA
+    // SCARA AB and Polar YB axes are in degrees, not mm
+    #if EITHER(IS_SCARA, POLAR)
       FORCE_INLINE static float get_axis_position_degrees(const AxisEnum axis) { return get_axis_position_mm(axis); }
     #endif
 
     // Called to force a quick stop of the machine (for example, when
     // a Full Shutdown is required, or when endstops are hit)
     static void quick_stop();
 
     #if ENABLED(REALTIME_REPORTING_COMMANDS)
       // Force a quick pause of the machine (e.g., when a pause is required in the middle of move).
       // NOTE: Hard-stops will lose steps so encoders are highly recommended if using these!

commit c7e84e8ef145a35b2c90e1a6f1d908929cc46d83
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Dec 31 15:59:13 2022 +1300

    ‚ú® Persistent AUTOTEMP settings (#25093)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index dcfdb1c28e..04cde2381d 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -149,20 +149,28 @@ typedef struct {
   };
 
   void clear() volatile { bits = 0; }
   void apply(const uint8_t f) volatile { bits |= f; }
   void apply(const BlockFlagBit b) volatile { SBI(bits, b); }
   void reset(const BlockFlagBit b) volatile { bits = _BV(b); }
   void set_nominal(const bool n) volatile { recalculate = true; if (n) nominal_length = true; }
 
 } block_flags_t;
 
+#if ENABLED(AUTOTEMP)
+  typedef struct {
+    celsius_t min, max;
+    float factor;
+    bool enabled;
+  } autotemp_t;
+#endif
+
 #if ENABLED(LASER_FEATURE)
 
   typedef struct {
     bool isEnabled:1;                                 // Set to engage the inline laser power output.
     bool dir:1;
     bool isPowered:1;                                 // Set on any parsed G1, G2, G3, or G5 powered move, cleared on G0 and G28.
     bool isSyncPower:1;                               // Set on a M3 sync based set laser power, used to determine active trap power
     bool Reserved:4;
   } power_status_t;
 
@@ -319,39 +327,35 @@ typedef struct {
 
 #if ENABLED(IMPROVE_HOMING_RELIABILITY)
   struct motion_state_t {
     TERN(DELTA, xyz_ulong_t, xy_ulong_t) acceleration;
     #if HAS_CLASSIC_JERK
       TERN(DELTA, xyz_float_t, xy_float_t) jerk_state;
     #endif
   };
 #endif
 
-#if DISABLED(SKEW_CORRECTION)
-  #define XY_SKEW_FACTOR 0
-  #define XZ_SKEW_FACTOR 0
-  #define YZ_SKEW_FACTOR 0
-#endif
-
-typedef struct {
-  #if ENABLED(SKEW_CORRECTION_GCODE)
-    float xy;
-    #if ENABLED(SKEW_CORRECTION_FOR_Z)
-      float xz, yz;
+#if ENABLED(SKEW_CORRECTION)
+  typedef struct {
+    #if ENABLED(SKEW_CORRECTION_GCODE)
+      float xy;
+      #if ENABLED(SKEW_CORRECTION_FOR_Z)
+        float xz, yz;
+      #else
+        const float xz = XZ_SKEW_FACTOR, yz = YZ_SKEW_FACTOR;
+      #endif
     #else
-      const float xz = XZ_SKEW_FACTOR, yz = YZ_SKEW_FACTOR;
+      const float xy = XY_SKEW_FACTOR,
+                  xz = XZ_SKEW_FACTOR, yz = YZ_SKEW_FACTOR;
     #endif
-  #else
-    const float xy = XY_SKEW_FACTOR,
-                xz = XZ_SKEW_FACTOR, yz = YZ_SKEW_FACTOR;
-  #endif
-} skew_factor_t;
+  } skew_factor_t;
+#endif
 
 #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
   typedef IF<(BLOCK_BUFFER_SIZE > 64), uint16_t, uint8_t>::type last_move_t;
 #endif
 
 #if ENABLED(ARC_SUPPORT)
   #define HINTS_CURVE_RADIUS
   #define HINTS_SAFE_EXIT_SPEED
 #endif
 
@@ -469,21 +473,23 @@ class Planner {
     static xyze_long_t position;
 
     #if HAS_POSITION_FLOAT
       static xyze_pos_t position_float;
     #endif
 
     #if IS_KINEMATIC
       static xyze_pos_t position_cart;
     #endif
 
-    static skew_factor_t skew_factor;
+    #if ENABLED(SKEW_CORRECTION)
+      static skew_factor_t skew_factor;
+    #endif
 
     #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
       static bool abort_on_endstop_hit;
     #endif
     #ifdef XY_FREQUENCY_LIMIT
       static int8_t xy_freq_limit_hz;         // Minimum XY frequency setting
       static float xy_freq_min_speed_factor;  // Minimum speed factor setting
       static int32_t xy_freq_min_interval_us; // Minimum segment time based on xy_freq_limit_hz
       static void refresh_frequency_limit() {
         //xy_freq_min_interval_us = xy_freq_limit_hz ?: LROUND(1000000.0f / xy_freq_limit_hz);
@@ -965,23 +971,21 @@ class Planner {
       if (has_blocks_queued())
         block_buffer_tail = next_block_index(block_buffer_tail);
     }
 
     #if HAS_WIRED_LCD
       static uint16_t block_buffer_runtime();
       static void clear_block_buffer_runtime();
     #endif
 
     #if ENABLED(AUTOTEMP)
-      static celsius_t autotemp_min, autotemp_max;
-      static float autotemp_factor;
-      static bool autotemp_enabled;
+      static autotemp_t autotemp;
       static void autotemp_update();
       static void autotemp_M104_M109();
       static void autotemp_task();
     #endif
 
     #if HAS_LINEAR_E_JERK
       FORCE_INLINE static void recalculate_max_e_jerk() {
         const float prop = junction_deviation_mm * SQRT(0.5) / (1.0f - SQRT(0.5));
         EXTRUDER_LOOP()
           max_e_jerk[E_INDEX_N(e)] = SQRT(prop * settings.max_acceleration_mm_per_s2[E_AXIS_N(e)]);

commit 89334caa526f2d300eee834d34d06d8f837a57d5
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Mon Nov 28 03:38:15 2022 +0000

    ‚ö°Ô∏è Input Shaping improvements (#24951)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 32b5a8795b..dcfdb1c28e 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -923,25 +923,21 @@ class Planner {
       static void quick_resume();
     #endif
 
     // Called when an endstop is triggered. Causes the machine to stop immediately
     static void endstop_triggered(const AxisEnum axis);
 
     // Triggered position of an axis in mm (not core-savvy)
     static float triggered_position_mm(const AxisEnum axis);
 
     // Blocks are queued, or we're running out moves, or the closed loop controller is waiting
-    static bool busy() {
-      return (has_blocks_queued() || cleaning_buffer_counter
-          || TERN0(EXTERNAL_CLOSED_LOOP_CONTROLLER, CLOSED_LOOP_WAITING())
-      );
-    }
+    static bool busy();
 
     // Block until all buffered steps are executed / cleaned
     static void synchronize();
 
     // Wait for moves to finish and disable all steppers
     static void finish_and_disable();
 
     // Periodic handler to manage the cleaning buffer counter
     // Called from the Temperature ISR at ~1kHz
     static void isr() { if (cleaning_buffer_counter) --cleaning_buffer_counter; }

commit 3985d269397e59bd69e5169d7cc3d2542af88086
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 9 20:54:17 2022 -0600

    üêõ Fix recalculate_max_e_jerk

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index cfd7b45516..32b5a8795b 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -981,21 +981,21 @@ class Planner {
       static bool autotemp_enabled;
       static void autotemp_update();
       static void autotemp_M104_M109();
       static void autotemp_task();
     #endif
 
     #if HAS_LINEAR_E_JERK
       FORCE_INLINE static void recalculate_max_e_jerk() {
         const float prop = junction_deviation_mm * SQRT(0.5) / (1.0f - SQRT(0.5));
         EXTRUDER_LOOP()
-          max_e_jerk[E_INDEX_N(e)] = SQRT(prop * settings.max_acceleration_mm_per_s2[E_INDEX_N(e)]);
+          max_e_jerk[E_INDEX_N(e)] = SQRT(prop * settings.max_acceleration_mm_per_s2[E_AXIS_N(e)]);
       }
     #endif
 
   private:
 
     #if ENABLED(AUTOTEMP)
       #if ENABLED(AUTOTEMP_PROPORTIONAL)
         static void _autotemp_update_from_hotend();
       #else
         static void _autotemp_update_from_hotend() {}

commit efde96131d9e9288dc2ea28b548f691a184fb33e
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Mon Oct 10 20:49:37 2022 +0200

    ‚ú® ADVANCE_K per-extruder (#24821)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 2e7ed014f8..cfd7b45516 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -452,21 +452,21 @@ class Planner {
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         static float z_fade_height, inverse_z_fade_height;
       #endif
     #else
       static constexpr bool leveling_active = false;
     #endif
 
     #if ENABLED(LIN_ADVANCE)
-      static float extruder_advance_K[EXTRUDERS];
+      static float extruder_advance_K[DISTINCT_E];
     #endif
 
     /**
      * The current position of the tool in absolute steps
      * Recalculated if any axis_steps_per_mm are changed by G-code
      */
     static xyze_long_t position;
 
     #if HAS_POSITION_FLOAT
       static xyze_pos_t position_float;

commit 35594a23debc011081765fc7a2d856ea9b9ddba5
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Thu Sep 29 19:54:59 2022 -0300

    üêõ Fix DUE compile and errors (#24809)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 09afee7db1..2e7ed014f8 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -185,25 +185,25 @@ typedef struct {
  * A single entry in the planner buffer.
  * Tracks linear movement over multiple axes.
  *
  * The "nominal" values are as-specified by G-code, and
  * may never actually be reached due to acceleration limits.
  */
 typedef struct PlannerBlock {
 
   volatile block_flags_t flag;              // Block flags
 
-  volatile bool is_fan_sync() { return TERN0(LASER_SYNCHRONOUS_M106_M107, flag.sync_fans); }
-  volatile bool is_pwr_sync() { return TERN0(LASER_POWER_SYNC, flag.sync_laser_pwr); }
-  volatile bool is_sync() { return flag.sync_position || is_fan_sync() || is_pwr_sync(); }
-  volatile bool is_page() { return TERN0(DIRECT_STEPPING, flag.page); }
-  volatile bool is_move() { return !(is_sync() || is_page()); }
+  bool is_fan_sync() { return TERN0(LASER_SYNCHRONOUS_M106_M107, flag.sync_fans); }
+  bool is_pwr_sync() { return TERN0(LASER_POWER_SYNC, flag.sync_laser_pwr); }
+  bool is_sync() { return flag.sync_position || is_fan_sync() || is_pwr_sync(); }
+  bool is_page() { return TERN0(DIRECT_STEPPING, flag.page); }
+  bool is_move() { return !(is_sync() || is_page()); }
 
   // Fields used by the motion planner to manage acceleration
   float nominal_speed,                      // The nominal speed for this block in (mm/sec)
         entry_speed_sqr,                    // Entry speed at previous-current junction in (mm/sec)^2
         max_entry_speed_sqr,                // Maximum allowable junction entry speed in (mm/sec)^2
         millimeters,                        // The total travel of this block in mm
         acceleration;                       // acceleration mm/sec^2
 
   union {
     abce_ulong_t steps;                     // Step count along each axis

commit 232a104a927988c63f8c0c53a8c2e26005166e2d
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sun Jul 31 03:39:48 2022 +0100

    Fix, improve Linear Advance (#24533)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 6eb5272071..09afee7db1 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -232,25 +232,24 @@ typedef struct PlannerBlock {
              acceleration_time_inverse,     // Inverse of acceleration and deceleration periods, expressed as integer. Scale depends on CPU being used
              deceleration_time_inverse;
   #else
     uint32_t acceleration_rate;             // The acceleration rate used for acceleration calculation
   #endif
 
   axis_bits_t direction_bits;               // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
 
   // Advance extrusion
   #if ENABLED(LIN_ADVANCE)
-    bool use_advance_lead;
-    uint16_t advance_speed,                 // STEP timer value for extruder speed offset ISR
-             max_adv_steps,                 // max. advance steps to get cruising speed pressure (not always nominal_speed!)
-             final_adv_steps;               // advance steps due to exit speed
-    float e_D_ratio;
+    uint32_t la_advance_rate;               // The rate at which steps are added whilst accelerating
+    uint8_t  la_scaling;                    // Scale ISR frequency down and step frequency up by 2 ^ la_scaling
+    uint16_t max_adv_steps,                 // Max advance steps to get cruising speed pressure
+             final_adv_steps;               // Advance steps for exit speed pressure
   #endif
 
   uint32_t nominal_rate,                    // The nominal step rate for this block in step_events/sec
            initial_rate,                    // The jerk-adjusted step rate at start of block
            final_rate,                      // The minimal rate at exit
            acceleration_steps_per_s2;       // acceleration steps/sec^2
 
   #if ENABLED(DIRECT_STEPPING)
     page_idx_t page_idx;                    // Page index used for direct stepping
   #endif
@@ -1011,21 +1010,21 @@ class Planner {
 
     /**
      * Calculate the maximum allowable speed squared at this point, in order
      * to reach 'target_velocity_sqr' using 'acceleration' within a given
      * 'distance'.
      */
     static float max_allowable_speed_sqr(const_float_t accel, const_float_t target_velocity_sqr, const_float_t distance) {
       return target_velocity_sqr - 2 * accel * distance;
     }
 
-    #if ENABLED(S_CURVE_ACCELERATION)
+    #if EITHER(S_CURVE_ACCELERATION, LIN_ADVANCE)
       /**
        * Calculate the speed reached given initial speed, acceleration and distance
        */
       static float final_speed(const_float_t initial_velocity, const_float_t accel, const_float_t distance) {
         return SQRT(sq(initial_velocity) + 2 * accel * distance);
       }
     #endif
 
     static void calculate_trapezoid_for_block(block_t * const block, const_float_t entry_factor, const_float_t exit_factor);
 

commit fc0615fbd12a2609fb937afa94fa092cc9cfebdd
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sat Jul 16 00:15:51 2022 +0100

    ‚ö°Ô∏è Optimize Planner calculations (#24484)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 389ae6d4bf..6eb5272071 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -192,21 +192,21 @@ typedef struct PlannerBlock {
 
   volatile block_flags_t flag;              // Block flags
 
   volatile bool is_fan_sync() { return TERN0(LASER_SYNCHRONOUS_M106_M107, flag.sync_fans); }
   volatile bool is_pwr_sync() { return TERN0(LASER_POWER_SYNC, flag.sync_laser_pwr); }
   volatile bool is_sync() { return flag.sync_position || is_fan_sync() || is_pwr_sync(); }
   volatile bool is_page() { return TERN0(DIRECT_STEPPING, flag.page); }
   volatile bool is_move() { return !(is_sync() || is_page()); }
 
   // Fields used by the motion planner to manage acceleration
-  float nominal_speed_sqr,                  // The nominal speed for this block in (mm/sec)^2
+  float nominal_speed,                      // The nominal speed for this block in (mm/sec)
         entry_speed_sqr,                    // Entry speed at previous-current junction in (mm/sec)^2
         max_entry_speed_sqr,                // Maximum allowable junction entry speed in (mm/sec)^2
         millimeters,                        // The total travel of this block in mm
         acceleration;                       // acceleration mm/sec^2
 
   union {
     abce_ulong_t steps;                     // Step count along each axis
     abce_long_t position;                   // New position to force when this sync block is executed
   };
   uint32_t step_event_count;                // The number of step events required to complete this block
@@ -503,21 +503,21 @@ class Planner {
   private:
 
     /**
      * Speed of previous path line segment
      */
     static xyze_float_t previous_speed;
 
     /**
      * Nominal speed of previous path line segment (mm/s)^2
      */
-    static float previous_nominal_speed_sqr;
+    static float previous_nominal_speed;
 
     /**
      * Limit where 64bit math is necessary for acceleration calculation
      */
     static uint32_t acceleration_long_cutoff;
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       static float last_fade_z;
     #endif
 
@@ -1002,42 +1002,20 @@ class Planner {
         static void _autotemp_update_from_hotend() {}
       #endif
     #endif
 
     /**
      * Get the index of the next / previous block in the ring buffer
      */
     static constexpr uint8_t next_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index + 1); }
     static constexpr uint8_t prev_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index - 1); }
 
-    /**
-     * Calculate the distance (not time) it takes to accelerate
-     * from initial_rate to target_rate using the given acceleration:
-     */
-    static float estimate_acceleration_distance(const_float_t initial_rate, const_float_t target_rate, const_float_t accel) {
-      if (accel == 0) return 0; // accel was 0, set acceleration distance to 0
-      return (sq(target_rate) - sq(initial_rate)) / (accel * 2);
-    }
-
-    /**
-     * Return the point at which you must start braking (at the rate of -'accel') if
-     * you start at 'initial_rate', accelerate (until reaching the point), and want to end at
-     * 'final_rate' after traveling 'distance'.
-     *
-     * This is used to compute the intersection point between acceleration and deceleration
-     * in cases where the "trapezoid" has no plateau (i.e., never reaches maximum speed)
-     */
-    static float intersection_distance(const_float_t initial_rate, const_float_t final_rate, const_float_t accel, const_float_t distance) {
-      if (accel == 0) return 0; // accel was 0, set intersection distance to 0
-      return (accel * 2 * distance - sq(initial_rate) + sq(final_rate)) / (accel * 4);
-    }
-
     /**
      * Calculate the maximum allowable speed squared at this point, in order
      * to reach 'target_velocity_sqr' using 'acceleration' within a given
      * 'distance'.
      */
     static float max_allowable_speed_sqr(const_float_t accel, const_float_t target_velocity_sqr, const_float_t distance) {
       return target_velocity_sqr - 2 * accel * distance;
     }
 
     #if ENABLED(S_CURVE_ACCELERATION)

commit 8fb54d4621c5f571d613fca2943393d4a95cb8e4
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Thu Jul 14 00:00:33 2022 -0500

    üö∏ Fix and update ProUI (#24477)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 5a0de47bf2..389ae6d4bf 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -181,21 +181,21 @@ typedef struct {
 
 /**
  * struct block_t
  *
  * A single entry in the planner buffer.
  * Tracks linear movement over multiple axes.
  *
  * The "nominal" values are as-specified by G-code, and
  * may never actually be reached due to acceleration limits.
  */
-typedef struct block_t {
+typedef struct PlannerBlock {
 
   volatile block_flags_t flag;              // Block flags
 
   volatile bool is_fan_sync() { return TERN0(LASER_SYNCHRONOUS_M106_M107, flag.sync_fans); }
   volatile bool is_pwr_sync() { return TERN0(LASER_POWER_SYNC, flag.sync_laser_pwr); }
   volatile bool is_sync() { return flag.sync_position || is_fan_sync() || is_pwr_sync(); }
   volatile bool is_page() { return TERN0(DIRECT_STEPPING, flag.page); }
   volatile bool is_move() { return !(is_sync() || is_page()); }
 
   // Fields used by the motion planner to manage acceleration

commit 920799e38d192f056b76b25a35886f19543308e6
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Jul 8 20:41:39 2022 +0100

    ‚ö°Ô∏è Optimize G2-G3 Arcs (#24366)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index e0aa89ab72..5a0de47bf2 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -273,20 +273,22 @@ typedef struct block_t {
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     uint32_t sdpos;
     xyze_pos_t start_position;
   #endif
 
   #if ENABLED(LASER_FEATURE)
     block_laser_t laser;
   #endif
 
+  void reset() { memset((char*)this, 0, sizeof(*this)); }
+
 } block_t;
 
 #if ANY(LIN_ADVANCE, SCARA_FEEDRATE_SCALING, GRADIENT_MIX, LCD_SHOW_E_TOTAL, POWER_LOSS_RECOVERY)
   #define HAS_POSITION_FLOAT 1
 #endif
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 #if ENABLED(LASER_FEATURE)
   typedef struct {
@@ -342,20 +344,44 @@ typedef struct {
   #else
     const float xy = XY_SKEW_FACTOR,
                 xz = XZ_SKEW_FACTOR, yz = YZ_SKEW_FACTOR;
   #endif
 } skew_factor_t;
 
 #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
   typedef IF<(BLOCK_BUFFER_SIZE > 64), uint16_t, uint8_t>::type last_move_t;
 #endif
 
+#if ENABLED(ARC_SUPPORT)
+  #define HINTS_CURVE_RADIUS
+  #define HINTS_SAFE_EXIT_SPEED
+#endif
+
+struct PlannerHints {
+  float millimeters = 0.0;            // Move Length, if known, else 0.
+  #if ENABLED(SCARA_FEEDRATE_SCALING)
+    float inv_duration = 0.0;         // Reciprocal of the move duration, if known
+  #endif
+  #if ENABLED(HINTS_CURVE_RADIUS)
+    float curve_radius = 0.0;         // Radius of curvature of the motion path - to calculate cornering speed
+  #else
+    static constexpr float curve_radius = 0.0;
+  #endif
+  #if ENABLED(HINTS_SAFE_EXIT_SPEED)
+    float safe_exit_speed_sqr = 0.0;  // Square of the speed considered "safe" at the end of the segment
+                                      // i.e., at or below the exit speed of the segment that the planner
+                                      // would calculate if it knew the as-yet-unbuffered path
+  #endif
+
+  PlannerHints(const_float_t mm=0.0f) : millimeters(mm) {}
+};
+
 class Planner {
   public:
 
     /**
      * The move buffer, calculated in stepper steps
      *
      * block_buffer is a ring buffer...
      *
      *             head,tail : indexes for write,read
      *            head==tail : the buffer is empty
@@ -745,51 +771,50 @@ class Planner {
     }
 
     /**
      * Planner::_buffer_steps
      *
      * Add a new linear movement to the buffer (in terms of steps).
      *
      *  target      - target position in steps units
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
-     *  millimeters - the length of the movement, if known
+     *  hints       - parameters to aid planner calculations
      *
      * Returns true if movement was buffered, false otherwise
      */
     static bool _buffer_steps(const xyze_long_t &target
       OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
       OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
-      , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
+      , feedRate_t fr_mm_s, const uint8_t extruder, const PlannerHints &hints
     );
 
     /**
      * @brief Populate a block in preparation for insertion
      * @details Populate the fields of a new linear movement block
      *          that will be added to the queue and processed soon
      *          by the Stepper ISR.
      *
      * @param block         A block to populate
      * @param target        Target position in steps units
      * @param target_float  Target position in native mm
      * @param cart_dist_mm  The pre-calculated move lengths for all axes, in mm
      * @param fr_mm_s       (target) speed of the move
      * @param extruder      target extruder
-     * @param millimeters   A pre-calculated linear distance for the move, in mm,
-     *                      or 0.0 to have the distance calculated here.
+     * @param hints         parameters to aid planner calculations
      *
      * @return  true if movement is acceptable, false otherwise
      */
     static bool _populate_block(block_t * const block, const xyze_long_t &target
       OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
       OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
-      , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
+      , feedRate_t fr_mm_s, const uint8_t extruder, const PlannerHints &hints
     );
 
     /**
      * Planner::buffer_sync_block
      * Add a block to the buffer that just updates the position
      * @param sync_flag sets a condition bit to process additional items
      * such as sync fan pwm or sync M3/M4 laser power into a queued block
      */
       static void buffer_sync_block(const BlockFlagBit flag=BLOCK_BIT_SYNC_POSITION);
 
@@ -802,43 +827,45 @@ class Planner {
 
     /**
      * Planner::buffer_segment
      *
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e     - target positions in mm and/or degrees
      *  fr_mm_s     - (target) speed of the move
-     *  extruder    - target extruder
-     *  millimeters - the length of the movement, if known
+     *  extruder    - optional target extruder (otherwise active_extruder)
+     *  hints       - optional parameters to aid planner calculations
      */
     static bool buffer_segment(const abce_pos_t &abce
       OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
-      , const_feedRate_t fr_mm_s, const uint8_t extruder=active_extruder, const_float_t millimeters=0.0
+      , const_feedRate_t fr_mm_s
+      , const uint8_t extruder=active_extruder
+      , const PlannerHints &hints=PlannerHints()
     );
 
   public:
 
     /**
      * Add a new linear movement to the buffer.
      * The target is cartesian. It's translated to
      * delta/scara if needed.
      *
      *  cart         - target position in mm or degrees
      *  fr_mm_s      - (target) speed of the move (mm/s)
-     *  extruder     - target extruder
-     *  millimeters  - the length of the movement, if known
-     *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
+     *  extruder     - optional target extruder (otherwise active_extruder)
+     *  hints        - optional parameters to aid planner calculations
      */
-    static bool buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s, const uint8_t extruder=active_extruder, const float millimeters=0.0
-      OPTARG(SCARA_FEEDRATE_SCALING, const_float_t inv_duration=0.0)
+    static bool buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s
+      , const uint8_t extruder=active_extruder
+      , const PlannerHints &hints=PlannerHints()
     );
 
     #if ENABLED(DIRECT_STEPPING)
       static void buffer_page(const page_idx_t page_idx, const uint8_t extruder, const uint16_t num_steps);
     #endif
 
     /**
      * Set the planner.position and individual stepper positions.
      * Used by G92, G28, G29, and other procedures.
      *
@@ -1017,29 +1044,29 @@ class Planner {
       /**
        * Calculate the speed reached given initial speed, acceleration and distance
        */
       static float final_speed(const_float_t initial_velocity, const_float_t accel, const_float_t distance) {
         return SQRT(sq(initial_velocity) + 2 * accel * distance);
       }
     #endif
 
     static void calculate_trapezoid_for_block(block_t * const block, const_float_t entry_factor, const_float_t exit_factor);
 
-    static void reverse_pass_kernel(block_t * const current, const block_t * const next);
+    static void reverse_pass_kernel(block_t * const current, const block_t * const next OPTARG(ARC_SUPPORT, const_float_t safe_exit_speed_sqr));
     static void forward_pass_kernel(const block_t * const previous, block_t * const current, uint8_t block_index);
 
-    static void reverse_pass();
+    static void reverse_pass(TERN_(ARC_SUPPORT, const_float_t safe_exit_speed_sqr));
     static void forward_pass();
 
-    static void recalculate_trapezoids();
+    static void recalculate_trapezoids(TERN_(ARC_SUPPORT, const_float_t safe_exit_speed_sqr));
 
-    static void recalculate();
+    static void recalculate(TERN_(ARC_SUPPORT, const_float_t safe_exit_speed_sqr));
 
     #if HAS_JUNCTION_DEVIATION
 
       FORCE_INLINE static void normalize_junction_vector(xyze_float_t &vector) {
         float magnitude_sq = 0;
         LOOP_LOGICAL_AXES(idx) if (vector[idx]) magnitude_sq += sq(vector[idx]);
         vector *= RSQRT(magnitude_sq);
       }
 
       FORCE_INLINE static float limit_value_by_axis_maximum(const_float_t max_value, xyze_float_t &unit_vec) {

commit 6a67ad4e4aacf7e7314f9e15fd8fe8489b73742b
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Wed Jul 6 07:46:39 2022 -0500

    ‚ö°Ô∏è Fix and improve Inline Laser Power (#22690)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index a6f5bd5774..e0aa89ab72 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -82,71 +82,47 @@
            manual_feedrate_mm_s = LOGICAL_AXIS_ARRAY(_mf.e / 60.0f,
                                                      _mf.x / 60.0f, _mf.y / 60.0f, _mf.z / 60.0f,
                                                      _mf.i / 60.0f, _mf.j / 60.0f, _mf.k / 60.0f,
                                                      _mf.u / 60.0f, _mf.v / 60.0f, _mf.w / 60.0f);
 #endif
 
 #if IS_KINEMATIC && HAS_JUNCTION_DEVIATION
   #define HAS_DIST_MM_ARG 1
 #endif
 
-#if ENABLED(LASER_POWER_INLINE)
-
-  typedef struct {
-    bool isPlanned:1;
-    bool isEnabled:1;
-    bool dir:1;
-    bool Reserved:6;
-  } power_status_t;
-
-  typedef struct {
-    power_status_t status;    // See planner settings for meaning
-    uint8_t power;            // Ditto; When in trapezoid mode this is nominal power
-    #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
-      uint8_t   power_entry;  // Entry power for the laser
-      #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
-        uint8_t   power_exit; // Exit power for the laser
-        uint32_t  entry_per,  // Steps per power increment (to avoid floats in stepper calcs)
-                  exit_per;   // Steps per power decrement
-      #endif
-    #endif
-  } block_laser_t;
-
-#endif
-
 /**
  * Planner block flags as boolean bit fields
  */
 enum BlockFlagBit {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).
   BLOCK_BIT_NOMINAL_LENGTH,
 
   // The block is segment 2+ of a longer move
   BLOCK_BIT_CONTINUED,
 
   // Sync the stepper counts from the block
   BLOCK_BIT_SYNC_POSITION
 
   // Direct stepping page
-  #if ENABLED(DIRECT_STEPPING)
-    , BLOCK_BIT_PAGE
-  #endif
+  OPTARG(DIRECT_STEPPING, BLOCK_BIT_PAGE)
+
 
   // Sync the fan speeds from the block
-  #if ENABLED(LASER_SYNCHRONOUS_M106_M107)
-    , BLOCK_BIT_SYNC_FANS
-  #endif
+  OPTARG(LASER_SYNCHRONOUS_M106_M107, BLOCK_BIT_SYNC_FANS)
+
+  // Sync laser power from a queued block
+  OPTARG(LASER_POWER_SYNC, BLOCK_BIT_LASER_PWR)
 };
 
 /**
  * Planner block flags as boolean bit fields
  */
 typedef struct {
   union {
     uint8_t bits;
 
     struct {
@@ -158,44 +134,74 @@ typedef struct {
 
       bool sync_position:1;
 
       #if ENABLED(DIRECT_STEPPING)
         bool page:1;
       #endif
 
       #if ENABLED(LASER_SYNCHRONOUS_M106_M107)
         bool sync_fans:1;
       #endif
+
+      #if ENABLED(LASER_POWER_SYNC)
+        bool sync_laser_pwr:1;
+      #endif
     };
   };
 
   void clear() volatile { bits = 0; }
   void apply(const uint8_t f) volatile { bits |= f; }
   void apply(const BlockFlagBit b) volatile { SBI(bits, b); }
   void reset(const BlockFlagBit b) volatile { bits = _BV(b); }
   void set_nominal(const bool n) volatile { recalculate = true; if (n) nominal_length = true; }
 
 } block_flags_t;
 
+#if ENABLED(LASER_FEATURE)
+
+  typedef struct {
+    bool isEnabled:1;                                 // Set to engage the inline laser power output.
+    bool dir:1;
+    bool isPowered:1;                                 // Set on any parsed G1, G2, G3, or G5 powered move, cleared on G0 and G28.
+    bool isSyncPower:1;                               // Set on a M3 sync based set laser power, used to determine active trap power
+    bool Reserved:4;
+  } power_status_t;
+
+  typedef struct {
+    power_status_t status;                            // See planner settings for meaning
+    uint8_t power;                                    // Ditto; When in trapezoid mode this is nominal power
+
+    #if ENABLED(LASER_POWER_TRAP)
+      float trap_ramp_active_pwr;                     // Laser power level during active trapezoid smoothing
+      float trap_ramp_entry_incr;                     // Acceleration per step laser power increment (trap entry)
+      float trap_ramp_exit_decr;                      // Deceleration per step laser power decrement (trap exit)
+    #endif
+  } block_laser_t;
+
+#endif
+
 /**
- * A single entry in the planner buffer, used to set up and
- * track a coordinated linear motion for one or more axes.
+ * struct block_t
+ *
+ * A single entry in the planner buffer.
+ * Tracks linear movement over multiple axes.
  *
  * The "nominal" values are as-specified by G-code, and
  * may never actually be reached due to acceleration limits.
  */
 typedef struct block_t {
 
   volatile block_flags_t flag;              // Block flags
 
   volatile bool is_fan_sync() { return TERN0(LASER_SYNCHRONOUS_M106_M107, flag.sync_fans); }
-  volatile bool is_sync() { return flag.sync_position || is_fan_sync(); }
+  volatile bool is_pwr_sync() { return TERN0(LASER_POWER_SYNC, flag.sync_laser_pwr); }
+  volatile bool is_sync() { return flag.sync_position || is_fan_sync() || is_pwr_sync(); }
   volatile bool is_page() { return TERN0(DIRECT_STEPPING, flag.page); }
   volatile bool is_move() { return !(is_sync() || is_page()); }
 
   // Fields used by the motion planner to manage acceleration
   float nominal_speed_sqr,                  // The nominal speed for this block in (mm/sec)^2
         entry_speed_sqr,                    // Entry speed at previous-current junction in (mm/sec)^2
         max_entry_speed_sqr,                // Maximum allowable junction entry speed in (mm/sec)^2
         millimeters,                        // The total travel of this block in mm
         acceleration;                       // acceleration mm/sec^2
 
@@ -263,48 +269,45 @@ typedef struct block_t {
 
   #if HAS_WIRED_LCD
     uint32_t segment_time_us;
   #endif
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     uint32_t sdpos;
     xyze_pos_t start_position;
   #endif
 
-  #if ENABLED(LASER_POWER_INLINE)
+  #if ENABLED(LASER_FEATURE)
     block_laser_t laser;
   #endif
 
-  void reset() { memset((char*)this, 0, sizeof(*this)); }
-
 } block_t;
 
 #if ANY(LIN_ADVANCE, SCARA_FEEDRATE_SCALING, GRADIENT_MIX, LCD_SHOW_E_TOTAL, POWER_LOSS_RECOVERY)
   #define HAS_POSITION_FLOAT 1
 #endif
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
-#if ENABLED(LASER_POWER_INLINE)
+#if ENABLED(LASER_FEATURE)
   typedef struct {
     /**
      * Laser status flags
      */
     power_status_t status;
     /**
      * Laser power: 0 or 255 in case of PWM-less laser,
      * or the OCR (oscillator count register) value;
-     *
      * Using OCR instead of raw power, because it avoids
      * floating point operations during the move loop.
      */
-    uint8_t power;
+    volatile uint8_t power;
   } laser_state_t;
 #endif
 
 typedef struct {
    uint32_t max_acceleration_mm_per_s2[DISTINCT_AXES], // (mm/s^2) M201 XYZE
             min_segment_time_us;                // (¬µs) M205 B
       float axis_steps_per_mm[DISTINCT_AXES];   // (steps) M92 XYZE - Steps per millimeter
  feedRate_t max_feedrate_mm_s[DISTINCT_AXES];   // (mm/s) M203 XYZE - Max speeds
       float acceleration,                       // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
             retract_acceleration,               // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
@@ -392,21 +395,21 @@ class Planner {
                                                       // May be auto-adjusted by a filament width sensor
     #endif
 
     #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
       static float volumetric_extruder_limit[EXTRUDERS],          // Maximum mm^3/sec the extruder can handle
                    volumetric_extruder_feedrate_limit[EXTRUDERS]; // Feedrate limit (mm/s) calculated from volume limit
     #endif
 
     static planner_settings_t settings;
 
-    #if ENABLED(LASER_POWER_INLINE)
+    #if ENABLED(LASER_FEATURE)
       static laser_state_t laser_inline;
     #endif
 
     static uint32_t max_acceleration_steps_per_s2[DISTINCT_AXES]; // (steps/s^2) Derived from mm_per_s2
     static float mm_per_step[DISTINCT_AXES];          // Millimeters per step
 
     #if HAS_JUNCTION_DEVIATION
       static float junction_deviation_mm;             // (mm) M205 J
       #if HAS_LINEAR_E_JERK
         static float max_e_jerk[DISTINCT_E];          // Calculated from junction_deviation_mm
@@ -777,26 +780,25 @@ class Planner {
      * @return  true if movement is acceptable, false otherwise
      */
     static bool _populate_block(block_t * const block, const xyze_long_t &target
       OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
       OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
       , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
     );
 
     /**
      * Planner::buffer_sync_block
-     * Add a block to the buffer that just updates the position or in
-     * case of LASER_SYNCHRONOUS_M106_M107 the fan pwm
+     * Add a block to the buffer that just updates the position
+     * @param sync_flag sets a condition bit to process additional items
+     * such as sync fan pwm or sync M3/M4 laser power into a queued block
      */
-    static void buffer_sync_block(
-      TERN_(LASER_SYNCHRONOUS_M106_M107, const BlockFlagBit flag=BLOCK_BIT_SYNC_POSITION)
-    );
+      static void buffer_sync_block(const BlockFlagBit flag=BLOCK_BIT_SYNC_POSITION);
 
   #if IS_KINEMATIC
     private:
 
       // Allow do_homing_move to access internal functions, such as buffer_segment.
       friend void do_homing_move(const AxisEnum, const float, const feedRate_t, const bool);
   #endif
 
     /**
      * Planner::buffer_segment

commit 9c376f120c36687e4bd225c09db9d8c87fcd2a0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 1 20:10:51 2022 -0500

    ü©π Remove obsolete split_move

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 2d8a966ca0..a6f5bd5774 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -753,32 +753,37 @@ class Planner {
      *
      * Returns true if movement was buffered, false otherwise
      */
     static bool _buffer_steps(const xyze_long_t &target
       OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
       OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
       , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
     );
 
     /**
-     * Planner::_populate_block
+     * @brief Populate a block in preparation for insertion
+     * @details Populate the fields of a new linear movement block
+     *          that will be added to the queue and processed soon
+     *          by the Stepper ISR.
      *
-     * Fills a new linear movement in the block (in terms of steps).
+     * @param block         A block to populate
+     * @param target        Target position in steps units
+     * @param target_float  Target position in native mm
+     * @param cart_dist_mm  The pre-calculated move lengths for all axes, in mm
+     * @param fr_mm_s       (target) speed of the move
+     * @param extruder      target extruder
+     * @param millimeters   A pre-calculated linear distance for the move, in mm,
+     *                      or 0.0 to have the distance calculated here.
      *
-     *  target      - target position in steps units
-     *  fr_mm_s     - (target) speed of the move
-     *  extruder    - target extruder
-     *  millimeters - the length of the movement, if known
-     *
-     * Returns true is movement is acceptable, false otherwise
+     * @return  true if movement is acceptable, false otherwise
      */
-    static bool _populate_block(block_t * const block, bool split_move, const xyze_long_t &target
+    static bool _populate_block(block_t * const block, const xyze_long_t &target
       OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
       OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
       , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
     );
 
     /**
      * Planner::buffer_sync_block
      * Add a block to the buffer that just updates the position or in
      * case of LASER_SYNCHRONOUS_M106_M107 the fan pwm
      */

commit d9ec3795fbfa1c0c6de4774304eaa255794101fd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 29 17:14:23 2022 -0500

    ü©π Fix memset block warning

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index b8a108b4b3..2d8a966ca0 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -267,20 +267,22 @@ typedef struct block_t {
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     uint32_t sdpos;
     xyze_pos_t start_position;
   #endif
 
   #if ENABLED(LASER_POWER_INLINE)
     block_laser_t laser;
   #endif
 
+  void reset() { memset((char*)this, 0, sizeof(*this)); }
+
 } block_t;
 
 #if ANY(LIN_ADVANCE, SCARA_FEEDRATE_SCALING, GRADIENT_MIX, LCD_SHOW_E_TOTAL, POWER_LOSS_RECOVERY)
   #define HAS_POSITION_FLOAT 1
 #endif
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 #if ENABLED(LASER_POWER_INLINE)
   typedef struct {

commit 93ffd57383723c48a092e97364b6659c54b5c419
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 26 22:30:05 2022 -0500

    ‚ôªÔ∏è  reset_acceleration_rates => refresh_‚Ä¶

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index d181b771c1..b8a108b4b3 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -507,21 +507,21 @@ class Planner {
 
     Planner();
 
     void init();
 
     /**
      * Static (class) Methods
      */
 
     // Recalculate steps/s^2 accelerations based on mm/s^2 settings
-    static void reset_acceleration_rates();
+    static void refresh_acceleration_rates();
 
     /**
      * Recalculate 'position' and 'mm_per_step'.
      * Must be called whenever settings.axis_steps_per_mm changes!
      */
     static void refresh_positioning();
 
     // For an axis set the Maximum Acceleration in mm/s^2
     static void set_max_acceleration(const AxisEnum axis, float inMaxAccelMMS2);
 

commit 307dfb15ca88f424dcb4cf579e4542e77dfb0eaf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 26 22:24:59 2022 -0500

    ‚ôªÔ∏è Planner flags refactor

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index bef381b5c7..d181b771c1 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -63,119 +63,141 @@
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"
 #endif
 
 #if HAS_CUTTER
   #include "../feature/spindle_laser_types.h"
 #endif
 
 #if ENABLED(DIRECT_STEPPING)
   #include "../feature/direct_stepping.h"
-  #define IS_PAGE(B) TEST(B->flag, BLOCK_BIT_IS_PAGE)
-#else
-  #define IS_PAGE(B) false
 #endif
 
 #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
   #include "../feature/closedloop.h"
 #endif
 
 // Feedrate for manual moves
 #ifdef MANUAL_FEEDRATE
   constexpr xyze_feedrate_t _mf = MANUAL_FEEDRATE,
            manual_feedrate_mm_s = LOGICAL_AXIS_ARRAY(_mf.e / 60.0f,
                                                      _mf.x / 60.0f, _mf.y / 60.0f, _mf.z / 60.0f,
                                                      _mf.i / 60.0f, _mf.j / 60.0f, _mf.k / 60.0f,
                                                      _mf.u / 60.0f, _mf.v / 60.0f, _mf.w / 60.0f);
 #endif
 
 #if IS_KINEMATIC && HAS_JUNCTION_DEVIATION
   #define HAS_DIST_MM_ARG 1
 #endif
 
-enum BlockFlagBit : char {
+#if ENABLED(LASER_POWER_INLINE)
+
+  typedef struct {
+    bool isPlanned:1;
+    bool isEnabled:1;
+    bool dir:1;
+    bool Reserved:6;
+  } power_status_t;
+
+  typedef struct {
+    power_status_t status;    // See planner settings for meaning
+    uint8_t power;            // Ditto; When in trapezoid mode this is nominal power
+    #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
+      uint8_t   power_entry;  // Entry power for the laser
+      #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
+        uint8_t   power_exit; // Exit power for the laser
+        uint32_t  entry_per,  // Steps per power increment (to avoid floats in stepper calcs)
+                  exit_per;   // Steps per power decrement
+      #endif
+    #endif
+  } block_laser_t;
+
+#endif
+
+/**
+ * Planner block flags as boolean bit fields
+ */
+enum BlockFlagBit {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).
   BLOCK_BIT_NOMINAL_LENGTH,
 
   // The block is segment 2+ of a longer move
   BLOCK_BIT_CONTINUED,
 
   // Sync the stepper counts from the block
   BLOCK_BIT_SYNC_POSITION
 
   // Direct stepping page
   #if ENABLED(DIRECT_STEPPING)
-    , BLOCK_BIT_IS_PAGE
+    , BLOCK_BIT_PAGE
   #endif
 
   // Sync the fan speeds from the block
   #if ENABLED(LASER_SYNCHRONOUS_M106_M107)
     , BLOCK_BIT_SYNC_FANS
   #endif
 };
 
-enum BlockFlag : char {
-    BLOCK_FLAG_RECALCULATE          = _BV(BLOCK_BIT_RECALCULATE)
-  , BLOCK_FLAG_NOMINAL_LENGTH       = _BV(BLOCK_BIT_NOMINAL_LENGTH)
-  , BLOCK_FLAG_CONTINUED            = _BV(BLOCK_BIT_CONTINUED)
-  , BLOCK_FLAG_SYNC_POSITION        = _BV(BLOCK_BIT_SYNC_POSITION)
-  #if ENABLED(DIRECT_STEPPING)
-    , BLOCK_FLAG_IS_PAGE            = _BV(BLOCK_BIT_IS_PAGE)
-  #endif
-  #if ENABLED(LASER_SYNCHRONOUS_M106_M107)
-    , BLOCK_FLAG_SYNC_FANS          = _BV(BLOCK_BIT_SYNC_FANS)
-  #endif
-};
+/**
+ * Planner block flags as boolean bit fields
+ */
+typedef struct {
+  union {
+    uint8_t bits;
 
-#define BLOCK_MASK_SYNC ( BLOCK_FLAG_SYNC_POSITION | TERN0(LASER_SYNCHRONOUS_M106_M107, BLOCK_FLAG_SYNC_FANS) )
+    struct {
+      bool recalculate:1;
 
-#if ENABLED(LASER_POWER_INLINE)
+      bool nominal_length:1;
 
-  typedef struct {
-    bool isPlanned:1;
-    bool isEnabled:1;
-    bool dir:1;
-    bool Reserved:6;
-  } power_status_t;
+      bool continued:1;
 
-  typedef struct {
-    power_status_t status;    // See planner settings for meaning
-    uint8_t power;            // Ditto; When in trapezoid mode this is nominal power
-    #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
-      uint8_t   power_entry;  // Entry power for the laser
-      #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
-        uint8_t   power_exit; // Exit power for the laser
-        uint32_t  entry_per,  // Steps per power increment (to avoid floats in stepper calcs)
-                  exit_per;   // Steps per power decrement
+      bool sync_position:1;
+
+      #if ENABLED(DIRECT_STEPPING)
+        bool page:1;
       #endif
-    #endif
-  } block_laser_t;
 
-#endif
+      #if ENABLED(LASER_SYNCHRONOUS_M106_M107)
+        bool sync_fans:1;
+      #endif
+    };
+  };
+
+  void clear() volatile { bits = 0; }
+  void apply(const uint8_t f) volatile { bits |= f; }
+  void apply(const BlockFlagBit b) volatile { SBI(bits, b); }
+  void reset(const BlockFlagBit b) volatile { bits = _BV(b); }
+  void set_nominal(const bool n) volatile { recalculate = true; if (n) nominal_length = true; }
+
+} block_flags_t;
 
 /**
- * struct block_t
- *
- * A single entry in the planner buffer.
- * Tracks linear movement over multiple axes.
+ * A single entry in the planner buffer, used to set up and
+ * track a coordinated linear motion for one or more axes.
  *
  * The "nominal" values are as-specified by G-code, and
  * may never actually be reached due to acceleration limits.
  */
 typedef struct block_t {
 
-  volatile uint8_t flag;                    // Block flags (See BlockFlag enum above) - Modified by ISR and main thread!
+  volatile block_flags_t flag;              // Block flags
+
+  volatile bool is_fan_sync() { return TERN0(LASER_SYNCHRONOUS_M106_M107, flag.sync_fans); }
+  volatile bool is_sync() { return flag.sync_position || is_fan_sync(); }
+  volatile bool is_page() { return TERN0(DIRECT_STEPPING, flag.page); }
+  volatile bool is_move() { return !(is_sync() || is_page()); }
 
   // Fields used by the motion planner to manage acceleration
   float nominal_speed_sqr,                  // The nominal speed for this block in (mm/sec)^2
         entry_speed_sqr,                    // Entry speed at previous-current junction in (mm/sec)^2
         max_entry_speed_sqr,                // Maximum allowable junction entry speed in (mm/sec)^2
         millimeters,                        // The total travel of this block in mm
         acceleration;                       // acceleration mm/sec^2
 
   union {
     abce_ulong_t steps;                     // Step count along each axis
@@ -752,21 +774,21 @@ class Planner {
       OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
       , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
     );
 
     /**
      * Planner::buffer_sync_block
      * Add a block to the buffer that just updates the position or in
      * case of LASER_SYNCHRONOUS_M106_M107 the fan pwm
      */
     static void buffer_sync_block(
-      TERN_(LASER_SYNCHRONOUS_M106_M107, uint8_t sync_flag=BLOCK_FLAG_SYNC_POSITION)
+      TERN_(LASER_SYNCHRONOUS_M106_M107, const BlockFlagBit flag=BLOCK_BIT_SYNC_POSITION)
     );
 
   #if IS_KINEMATIC
     private:
 
       // Allow do_homing_move to access internal functions, such as buffer_segment.
       friend void do_homing_move(const AxisEnum, const float, const feedRate_t, const bool);
   #endif
 
     /**

commit 58ce5182c2ea93e79ccaef4c912c68aa554e637e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 31 12:43:44 2022 -0500

    üé® Fix spelling, whitespace

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index dbc8592179..bef381b5c7 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -156,21 +156,21 @@ enum BlockFlag : char {
   } block_laser_t;
 
 #endif
 
 /**
  * struct block_t
  *
  * A single entry in the planner buffer.
  * Tracks linear movement over multiple axes.
  *
- * The "nominal" values are as-specified by gcode, and
+ * The "nominal" values are as-specified by G-code, and
  * may never actually be reached due to acceleration limits.
  */
 typedef struct block_t {
 
   volatile uint8_t flag;                    // Block flags (See BlockFlag enum above) - Modified by ISR and main thread!
 
   // Fields used by the motion planner to manage acceleration
   float nominal_speed_sqr,                  // The nominal speed for this block in (mm/sec)^2
         entry_speed_sqr,                    // Entry speed at previous-current junction in (mm/sec)^2
         max_entry_speed_sqr,                // Maximum allowable junction entry speed in (mm/sec)^2
@@ -405,21 +405,21 @@ class Planner {
     #else
       static constexpr bool leveling_active = false;
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       static float extruder_advance_K[EXTRUDERS];
     #endif
 
     /**
      * The current position of the tool in absolute steps
-     * Recalculated if any axis_steps_per_mm are changed by gcode
+     * Recalculated if any axis_steps_per_mm are changed by G-code
      */
     static xyze_long_t position;
 
     #if HAS_POSITION_FLOAT
       static xyze_pos_t position_float;
     #endif
 
     #if IS_KINEMATIC
       static xyze_pos_t position_cart;
     #endif

commit 726a38712e17f1f31436d033d0597237c086d309
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Mon May 9 17:18:47 2022 -0500

    ü©π Fix Fan Tail Speed Init (#24076)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index afcc5a1566..dbc8592179 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -1015,16 +1015,16 @@ class Planner {
         float limit_value = max_value;
         LOOP_LOGICAL_AXES(idx) {
           if (unit_vec[idx]) {
             if (limit_value * ABS(unit_vec[idx]) > settings.max_acceleration_mm_per_s2[idx])
               limit_value = ABS(settings.max_acceleration_mm_per_s2[idx] / unit_vec[idx]);
           }
         }
         return limit_value;
       }
 
-    #endif // !CLASSIC_JERK
+    #endif // HAS_JUNCTION_DEVIATION
 };
 
 #define PLANNER_XY_FEEDRATE() _MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS])
 
 extern Planner planner;

commit 80810f1b187661860a2ded43e2a0c4cc356edebe
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 1 17:49:54 2022 -0600

    üö® Fix some compiler warnings

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 40f60f91e7..afcc5a1566 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -494,24 +494,24 @@ class Planner {
     // Recalculate steps/s^2 accelerations based on mm/s^2 settings
     static void reset_acceleration_rates();
 
     /**
      * Recalculate 'position' and 'mm_per_step'.
      * Must be called whenever settings.axis_steps_per_mm changes!
      */
     static void refresh_positioning();
 
     // For an axis set the Maximum Acceleration in mm/s^2
-    static void set_max_acceleration(const uint8_t axis, float inMaxAccelMMS2);
+    static void set_max_acceleration(const AxisEnum axis, float inMaxAccelMMS2);
 
     // For an axis set the Maximum Feedrate in mm/s
-    static void set_max_feedrate(const uint8_t axis, float inMaxFeedrateMMS);
+    static void set_max_feedrate(const AxisEnum axis, float inMaxFeedrateMMS);
 
     // For an axis set the Maximum Jerk (instant change) in mm/s
     #if HAS_CLASSIC_JERK
       static void set_max_jerk(const AxisEnum axis, float inMaxJerkMMS);
     #else
       static void set_max_jerk(const AxisEnum, const_float_t) {}
     #endif
 
     #if HAS_EXTRUDERS
       FORCE_INLINE static void refresh_e_factor(const uint8_t e) {

commit 577831bf1a412a617b04a58551223903ff0a932f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 10 01:49:59 2022 -0500

    ü©π Apply 100% leveling correction below the bed
    
    See #24002

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index eb4a34cec9..40f60f91e7 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -585,21 +585,21 @@ class Planner {
 
       /**
        * Get the Z leveling fade factor based on the given Z height,
        * re-calculating only when needed.
        *
        *  Returns 1.0 if planner.z_fade_height is 0.0.
        *  Returns 0.0 if Z is past the specified 'Fade Height'.
        */
       static float fade_scaling_factor_for_z(const_float_t rz) {
         static float z_fade_factor = 1;
-        if (!z_fade_height) return 1;
+        if (!z_fade_height || rz <= 0) return 1;
         if (rz >= z_fade_height) return 0;
         if (last_fade_z != rz) {
           last_fade_z = rz;
           z_fade_factor = 1 - rz * inverse_z_fade_height;
         }
         return z_fade_factor;
       }
 
       FORCE_INLINE static void force_fade_recalc() { last_fade_z = -999.999f; }
 

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 5b79e406f5..eb4a34cec9 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -77,21 +77,22 @@
 
 #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
   #include "../feature/closedloop.h"
 #endif
 
 // Feedrate for manual moves
 #ifdef MANUAL_FEEDRATE
   constexpr xyze_feedrate_t _mf = MANUAL_FEEDRATE,
            manual_feedrate_mm_s = LOGICAL_AXIS_ARRAY(_mf.e / 60.0f,
                                                      _mf.x / 60.0f, _mf.y / 60.0f, _mf.z / 60.0f,
-                                                     _mf.i / 60.0f, _mf.j / 60.0f, _mf.k / 60.0f);
+                                                     _mf.i / 60.0f, _mf.j / 60.0f, _mf.k / 60.0f,
+                                                     _mf.u / 60.0f, _mf.v / 60.0f, _mf.w / 60.0f);
 #endif
 
 #if IS_KINEMATIC && HAS_JUNCTION_DEVIATION
   #define HAS_DIST_MM_ARG 1
 #endif
 
 enum BlockFlagBit : char {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
@@ -836,21 +837,22 @@ class Planner {
     /**
      * Get an axis position according to stepper position(s)
      * For CORE machines apply translation from ABC to XYZ.
      */
     static float get_axis_position_mm(const AxisEnum axis);
 
     static abce_pos_t get_axis_positions_mm() {
       const abce_pos_t out = LOGICAL_AXIS_ARRAY(
         get_axis_position_mm(E_AXIS),
         get_axis_position_mm(A_AXIS), get_axis_position_mm(B_AXIS), get_axis_position_mm(C_AXIS),
-        get_axis_position_mm(I_AXIS), get_axis_position_mm(J_AXIS), get_axis_position_mm(K_AXIS)
+        get_axis_position_mm(I_AXIS), get_axis_position_mm(J_AXIS), get_axis_position_mm(K_AXIS),
+        get_axis_position_mm(U_AXIS), get_axis_position_mm(V_AXIS), get_axis_position_mm(W_AXIS)
       );
       return out;
     }
 
     // SCARA AB axes are in degrees, not mm
     #if IS_SCARA
       FORCE_INLINE static float get_axis_position_degrees(const AxisEnum axis) { return get_axis_position_mm(axis); }
     #endif
 
     // Called to force a quick stop of the machine (for example, when

commit a80a303cbe057b02e8d9cd29bc94c161e48784f1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 22 22:22:08 2022 -0500

    üßë‚Äçüíª EXTRUDER_LOOP macro

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index f29604bea8..5b79e406f5 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -921,22 +921,22 @@ class Planner {
       static float autotemp_factor;
       static bool autotemp_enabled;
       static void autotemp_update();
       static void autotemp_M104_M109();
       static void autotemp_task();
     #endif
 
     #if HAS_LINEAR_E_JERK
       FORCE_INLINE static void recalculate_max_e_jerk() {
         const float prop = junction_deviation_mm * SQRT(0.5) / (1.0f - SQRT(0.5));
-        LOOP_L_N(i, EXTRUDERS)
-          max_e_jerk[E_INDEX_N(i)] = SQRT(prop * settings.max_acceleration_mm_per_s2[E_INDEX_N(i)]);
+        EXTRUDER_LOOP()
+          max_e_jerk[E_INDEX_N(e)] = SQRT(prop * settings.max_acceleration_mm_per_s2[E_INDEX_N(e)]);
       }
     #endif
 
   private:
 
     #if ENABLED(AUTOTEMP)
       #if ENABLED(AUTOTEMP_PROPORTIONAL)
         static void _autotemp_update_from_hotend();
       #else
         static void _autotemp_update_from_hotend() {}

commit a323d6732bf691d29ce996b6bfd11cbcc3c9f0a7
Author: MOHAMMAD RASIM <mohammad.rasim96@gmail.com>
Date:   Wed Feb 9 21:29:34 2022 +0300

    üö∏ Fix, Improve Power-Loss Recovery (#22828)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 380c35755c..f29604bea8 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -237,29 +237,30 @@ typedef struct block_t {
   #if ENABLED(BARICUDA)
     uint8_t valve_pressure, e_to_p_pressure;
   #endif
 
   #if HAS_WIRED_LCD
     uint32_t segment_time_us;
   #endif
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     uint32_t sdpos;
+    xyze_pos_t start_position;
   #endif
 
   #if ENABLED(LASER_POWER_INLINE)
     block_laser_t laser;
   #endif
 
 } block_t;
 
-#if ANY(LIN_ADVANCE, SCARA_FEEDRATE_SCALING, GRADIENT_MIX, LCD_SHOW_E_TOTAL)
+#if ANY(LIN_ADVANCE, SCARA_FEEDRATE_SCALING, GRADIENT_MIX, LCD_SHOW_E_TOTAL, POWER_LOSS_RECOVERY)
   #define HAS_POSITION_FLOAT 1
 #endif
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 #if ENABLED(LASER_POWER_INLINE)
   typedef struct {
     /**
      * Laser status flags
      */

commit 3e2a38b653b1d8479b7b38447d5fdff51ea9947f
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed Jan 12 08:24:56 2022 -0800

    üìù KHz => kHz (#23512)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index b83c445260..380c35755c 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -876,21 +876,21 @@ class Planner {
       );
     }
 
     // Block until all buffered steps are executed / cleaned
     static void synchronize();
 
     // Wait for moves to finish and disable all steppers
     static void finish_and_disable();
 
     // Periodic handler to manage the cleaning buffer counter
-    // Called from the Temperature ISR at ~1KHz
+    // Called from the Temperature ISR at ~1kHz
     static void isr() { if (cleaning_buffer_counter) --cleaning_buffer_counter; }
 
     /**
      * Does the buffer have any blocks queued?
      */
     FORCE_INLINE static bool has_blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
     /**
      * Get the current block for processing
      * and mark the block as busy.

commit 02b29c0fecd1d68226cd64d660bb409e6f131f9e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 10 19:49:03 2022 -0600

    üìù kHz => KHz

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 380c35755c..b83c445260 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -876,21 +876,21 @@ class Planner {
       );
     }
 
     // Block until all buffered steps are executed / cleaned
     static void synchronize();
 
     // Wait for moves to finish and disable all steppers
     static void finish_and_disable();
 
     // Periodic handler to manage the cleaning buffer counter
-    // Called from the Temperature ISR at ~1kHz
+    // Called from the Temperature ISR at ~1KHz
     static void isr() { if (cleaning_buffer_counter) --cleaning_buffer_counter; }
 
     /**
      * Does the buffer have any blocks queued?
      */
     FORCE_INLINE static bool has_blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
     /**
      * Get the current block for processing
      * and mark the block as busy.

commit 6fb2d8a25f096d084348a6f6930f515d947474d4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Dec 28 02:57:24 2021 -0600

    üßë‚Äçüíª Remove extraneous 'inline' hints

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 69e3f035ba..380c35755c 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -424,29 +424,29 @@ class Planner {
 
     static skew_factor_t skew_factor;
 
     #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
       static bool abort_on_endstop_hit;
     #endif
     #ifdef XY_FREQUENCY_LIMIT
       static int8_t xy_freq_limit_hz;         // Minimum XY frequency setting
       static float xy_freq_min_speed_factor;  // Minimum speed factor setting
       static int32_t xy_freq_min_interval_us; // Minimum segment time based on xy_freq_limit_hz
-      static inline void refresh_frequency_limit() {
+      static void refresh_frequency_limit() {
         //xy_freq_min_interval_us = xy_freq_limit_hz ?: LROUND(1000000.0f / xy_freq_limit_hz);
         if (xy_freq_limit_hz)
           xy_freq_min_interval_us = LROUND(1000000.0f / xy_freq_limit_hz);
       }
-      static inline void set_min_speed_factor_u8(const uint8_t v255) {
+      static void set_min_speed_factor_u8(const uint8_t v255) {
         xy_freq_min_speed_factor = float(ui8_to_percent(v255)) / 100;
       }
-      static inline void set_frequency_limit(const uint8_t hz) {
+      static void set_frequency_limit(const uint8_t hz) {
         xy_freq_limit_hz = constrain(hz, 0, 100);
         refresh_frequency_limit();
       }
     #endif
 
   private:
 
     /**
      * Speed of previous path line segment
      */
@@ -501,29 +501,29 @@ class Planner {
     // For an axis set the Maximum Acceleration in mm/s^2
     static void set_max_acceleration(const uint8_t axis, float inMaxAccelMMS2);
 
     // For an axis set the Maximum Feedrate in mm/s
     static void set_max_feedrate(const uint8_t axis, float inMaxFeedrateMMS);
 
     // For an axis set the Maximum Jerk (instant change) in mm/s
     #if HAS_CLASSIC_JERK
       static void set_max_jerk(const AxisEnum axis, float inMaxJerkMMS);
     #else
-      static inline void set_max_jerk(const AxisEnum, const_float_t) {}
+      static void set_max_jerk(const AxisEnum, const_float_t) {}
     #endif
 
     #if HAS_EXTRUDERS
       FORCE_INLINE static void refresh_e_factor(const uint8_t e) {
         e_factor[e] = flow_percentage[e] * 0.01f * TERN(NO_VOLUMETRICS, 1.0f, volumetric_multiplier[e]);
       }
 
-      static inline void set_flow(const uint8_t e, const int16_t flow) {
+      static void set_flow(const uint8_t e, const int16_t flow) {
         flow_percentage[e] = flow;
         refresh_e_factor(e);
       }
 
     #endif
 
     // Manage fans, paste pressure, etc.
     static void check_axes_activity();
 
     // Apply fan speeds
@@ -532,21 +532,21 @@ class Planner {
       #if FAN_KICKSTART_TIME
         static void kickstart_fan(uint8_t (&fan_speed)[FAN_COUNT], const millis_t &ms, const uint8_t f);
       #else
         FORCE_INLINE static void kickstart_fan(uint8_t (&)[FAN_COUNT], const millis_t &, const uint8_t) {}
       #endif
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       void apply_filament_width_sensor(const int8_t encoded_ratio);
 
-      static inline float volumetric_percent(const bool vol) {
+      static float volumetric_percent(const bool vol) {
         return 100.0f * (vol
             ? volumetric_area_nominal / volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
             : volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
         );
       }
     #endif
 
     #if ENABLED(IMPROVE_HOMING_RELIABILITY)
       void enable_stall_prevention(const bool onoff);
     #endif
@@ -581,21 +581,21 @@ class Planner {
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
 
       /**
        * Get the Z leveling fade factor based on the given Z height,
        * re-calculating only when needed.
        *
        *  Returns 1.0 if planner.z_fade_height is 0.0.
        *  Returns 0.0 if Z is past the specified 'Fade Height'.
        */
-      static inline float fade_scaling_factor_for_z(const_float_t rz) {
+      static float fade_scaling_factor_for_z(const_float_t rz) {
         static float z_fade_factor = 1;
         if (!z_fade_height) return 1;
         if (rz >= z_fade_height) return 0;
         if (last_fade_z != rz) {
           last_fade_z = rz;
           z_fade_factor = 1 - rz * inverse_z_fade_height;
         }
         return z_fade_factor;
       }
 
@@ -831,21 +831,21 @@ class Planner {
      * conversions are applied.
      */
     static void set_machine_position_mm(const abce_pos_t &abce);
 
     /**
      * Get an axis position according to stepper position(s)
      * For CORE machines apply translation from ABC to XYZ.
      */
     static float get_axis_position_mm(const AxisEnum axis);
 
-    static inline abce_pos_t get_axis_positions_mm() {
+    static abce_pos_t get_axis_positions_mm() {
       const abce_pos_t out = LOGICAL_AXIS_ARRAY(
         get_axis_position_mm(E_AXIS),
         get_axis_position_mm(A_AXIS), get_axis_position_mm(B_AXIS), get_axis_position_mm(C_AXIS),
         get_axis_position_mm(I_AXIS), get_axis_position_mm(J_AXIS), get_axis_position_mm(K_AXIS)
       );
       return out;
     }
 
     // SCARA AB axes are in degrees, not mm
     #if IS_SCARA
@@ -863,21 +863,21 @@ class Planner {
       static void quick_resume();
     #endif
 
     // Called when an endstop is triggered. Causes the machine to stop immediately
     static void endstop_triggered(const AxisEnum axis);
 
     // Triggered position of an axis in mm (not core-savvy)
     static float triggered_position_mm(const AxisEnum axis);
 
     // Blocks are queued, or we're running out moves, or the closed loop controller is waiting
-    static inline bool busy() {
+    static bool busy() {
       return (has_blocks_queued() || cleaning_buffer_counter
           || TERN0(EXTERNAL_CLOSED_LOOP_CONTROLLER, CLOSED_LOOP_WAITING())
       );
     }
 
     // Block until all buffered steps are executed / cleaned
     static void synchronize();
 
     // Wait for moves to finish and disable all steppers
     static void finish_and_disable();
@@ -931,21 +931,21 @@ class Planner {
           max_e_jerk[E_INDEX_N(i)] = SQRT(prop * settings.max_acceleration_mm_per_s2[E_INDEX_N(i)]);
       }
     #endif
 
   private:
 
     #if ENABLED(AUTOTEMP)
       #if ENABLED(AUTOTEMP_PROPORTIONAL)
         static void _autotemp_update_from_hotend();
       #else
-        static inline void _autotemp_update_from_hotend() {}
+        static void _autotemp_update_from_hotend() {}
       #endif
     #endif
 
     /**
      * Get the index of the next / previous block in the ring buffer
      */
     static constexpr uint8_t next_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index + 1); }
     static constexpr uint8_t prev_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index - 1); }
 
     /**

commit 0539e870de30877a38c78d29a304a97a6068cc80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 27 18:33:32 2021 -0600

    üé® Rename HAL timer elements

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 60574b65f0..69e3f035ba 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -868,21 +868,21 @@ class Planner {
 
     // Triggered position of an axis in mm (not core-savvy)
     static float triggered_position_mm(const AxisEnum axis);
 
     // Blocks are queued, or we're running out moves, or the closed loop controller is waiting
     static inline bool busy() {
       return (has_blocks_queued() || cleaning_buffer_counter
           || TERN0(EXTERNAL_CLOSED_LOOP_CONTROLLER, CLOSED_LOOP_WAITING())
       );
     }
-    
+
     // Block until all buffered steps are executed / cleaned
     static void synchronize();
 
     // Wait for moves to finish and disable all steppers
     static void finish_and_disable();
 
     // Periodic handler to manage the cleaning buffer counter
     // Called from the Temperature ISR at ~1kHz
     static void isr() { if (cleaning_buffer_counter) --cleaning_buffer_counter; }
 

commit 44d8c2f5bf970e5f701e8bf8e2eff4e17b9266bc
Author: espr14 <espr14@gmail.com>
Date:   Wed Nov 17 18:07:11 2021 +0100

    üèóÔ∏è Planner::busy() (#23145)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 16d136be45..60574b65f0 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -68,20 +68,24 @@
   #include "../feature/spindle_laser_types.h"
 #endif
 
 #if ENABLED(DIRECT_STEPPING)
   #include "../feature/direct_stepping.h"
   #define IS_PAGE(B) TEST(B->flag, BLOCK_BIT_IS_PAGE)
 #else
   #define IS_PAGE(B) false
 #endif
 
+#if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
+  #include "../feature/closedloop.h"
+#endif
+
 // Feedrate for manual moves
 #ifdef MANUAL_FEEDRATE
   constexpr xyze_feedrate_t _mf = MANUAL_FEEDRATE,
            manual_feedrate_mm_s = LOGICAL_AXIS_ARRAY(_mf.e / 60.0f,
                                                      _mf.x / 60.0f, _mf.y / 60.0f, _mf.z / 60.0f,
                                                      _mf.i / 60.0f, _mf.j / 60.0f, _mf.k / 60.0f);
 #endif
 
 #if IS_KINEMATIC && HAS_JUNCTION_DEVIATION
   #define HAS_DIST_MM_ARG 1
@@ -858,20 +862,27 @@ class Planner {
       static void quick_pause();
       static void quick_resume();
     #endif
 
     // Called when an endstop is triggered. Causes the machine to stop immediately
     static void endstop_triggered(const AxisEnum axis);
 
     // Triggered position of an axis in mm (not core-savvy)
     static float triggered_position_mm(const AxisEnum axis);
 
+    // Blocks are queued, or we're running out moves, or the closed loop controller is waiting
+    static inline bool busy() {
+      return (has_blocks_queued() || cleaning_buffer_counter
+          || TERN0(EXTERNAL_CLOSED_LOOP_CONTROLLER, CLOSED_LOOP_WAITING())
+      );
+    }
+    
     // Block until all buffered steps are executed / cleaned
     static void synchronize();
 
     // Wait for moves to finish and disable all steppers
     static void finish_and_disable();
 
     // Periodic handler to manage the cleaning buffer counter
     // Called from the Temperature ISR at ~1kHz
     static void isr() { if (cleaning_buffer_counter) --cleaning_buffer_counter; }
 

commit 228eb9c404fcbcebb507bbfe781ebe3ca0a1ccdf
Author: espr14 <espr14@gmail.com>
Date:   Mon Sep 27 21:05:52 2021 +0200

    üé® steps_to_mm => mm_per_step (#22847)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 15744c3f9a..16d136be45 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -367,21 +367,21 @@ class Planner {
                    volumetric_extruder_feedrate_limit[EXTRUDERS]; // Feedrate limit (mm/s) calculated from volume limit
     #endif
 
     static planner_settings_t settings;
 
     #if ENABLED(LASER_POWER_INLINE)
       static laser_state_t laser_inline;
     #endif
 
     static uint32_t max_acceleration_steps_per_s2[DISTINCT_AXES]; // (steps/s^2) Derived from mm_per_s2
-    static float steps_to_mm[DISTINCT_AXES];          // Millimeters per step
+    static float mm_per_step[DISTINCT_AXES];          // Millimeters per step
 
     #if HAS_JUNCTION_DEVIATION
       static float junction_deviation_mm;             // (mm) M205 J
       #if HAS_LINEAR_E_JERK
         static float max_e_jerk[DISTINCT_E];          // Calculated from junction_deviation_mm
       #endif
     #endif
 
     #if HAS_CLASSIC_JERK
       // (mm/s^2) M205 XYZ(E) - The largest speed change requiring no acceleration.
@@ -482,21 +482,21 @@ class Planner {
     void init();
 
     /**
      * Static (class) Methods
      */
 
     // Recalculate steps/s^2 accelerations based on mm/s^2 settings
     static void reset_acceleration_rates();
 
     /**
-     * Recalculate 'position' and 'steps_to_mm'.
+     * Recalculate 'position' and 'mm_per_step'.
      * Must be called whenever settings.axis_steps_per_mm changes!
      */
     static void refresh_positioning();
 
     // For an axis set the Maximum Acceleration in mm/s^2
     static void set_max_acceleration(const uint8_t axis, float inMaxAccelMMS2);
 
     // For an axis set the Maximum Feedrate in mm/s
     static void set_max_feedrate(const uint8_t axis, float inMaxFeedrateMMS);
 

commit dc5bef62ba185461ba969db6af996ebc93a33ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 23 10:01:37 2021 -0500

    üé® Various multi-axis patches (#22823)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index ea63f862e0..15744c3f9a 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -195,21 +195,21 @@ typedef struct block_t {
   #if ENABLED(S_CURVE_ACCELERATION)
     uint32_t cruise_rate,                   // The actual cruise rate to use, between end of the acceleration phase and start of deceleration phase
              acceleration_time,             // Acceleration time and deceleration time in STEP timer counts
              deceleration_time,
              acceleration_time_inverse,     // Inverse of acceleration and deceleration periods, expressed as integer. Scale depends on CPU being used
              deceleration_time_inverse;
   #else
     uint32_t acceleration_rate;             // The acceleration rate used for acceleration calculation
   #endif
 
-  uint8_t direction_bits;                   // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
+  axis_bits_t direction_bits;               // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
 
   // Advance extrusion
   #if ENABLED(LIN_ADVANCE)
     bool use_advance_lead;
     uint16_t advance_speed,                 // STEP timer value for extruder speed offset ISR
              max_adv_steps,                 // max. advance steps to get cruising speed pressure (not always nominal_speed!)
              final_adv_steps;               // advance steps due to exit speed
     float e_D_ratio;
   #endif
 

commit 3344071f24b505d180dd1423b11510172c3f1c1c
Author: Dan Royer <dan@marginallyclever.com>
Date:   Mon Sep 20 13:42:33 2021 -0700

    Polargraph / Makelangelo kinematics (#22790)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 5e3922c897..ea63f862e0 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -41,20 +41,22 @@
   // but incur increased computation and a reduction
   // in accuracy.
   #define JD_USE_LOOKUP_TABLE
 #endif
 
 #include "motion.h"
 #include "../gcode/queue.h"
 
 #if ENABLED(DELTA)
   #include "delta.h"
+#elif ENABLED(POLARGRAPH)
+  #include "polargraph.h"
 #endif
 
 #if ABL_PLANAR
   #include "../libs/vector_3.h" // for matrix_3x3
 #endif
 
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
 #endif
 

commit afca6e745932d295b88d37fa9bd4274e22705b0b
Author: luzpaz <luzpaz@users.noreply.github.com>
Date:   Tue Aug 3 20:02:34 2021 -0400

    üêõ Spellcheck comments (#22496)
    
    codespell -q 3 --builtin=clear,rare,informal,code -S ./Marlin/src/lcd/language -L alo,amin,endcode,stdio,uint

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 9b104615f6..5e3922c897 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -850,21 +850,21 @@ class Planner {
     // a Full Shutdown is required, or when endstops are hit)
     static void quick_stop();
 
     #if ENABLED(REALTIME_REPORTING_COMMANDS)
       // Force a quick pause of the machine (e.g., when a pause is required in the middle of move).
       // NOTE: Hard-stops will lose steps so encoders are highly recommended if using these!
       static void quick_pause();
       static void quick_resume();
     #endif
 
-    // Called when an endstop is triggered. Causes the machine to stop inmediately
+    // Called when an endstop is triggered. Causes the machine to stop immediately
     static void endstop_triggered(const AxisEnum axis);
 
     // Triggered position of an axis in mm (not core-savvy)
     static float triggered_position_mm(const AxisEnum axis);
 
     // Block until all buffered steps are executed / cleaned
     static void synchronize();
 
     // Wait for moves to finish and disable all steppers
     static void finish_and_disable();

commit 05ebde38127ca6c3bc056cb4068a414bade766b4
Author: lujios <83166168+lujios@users.noreply.github.com>
Date:   Tue Jul 13 02:19:29 2021 +0200

    ‚ö°Ô∏è Improve Sensorless homing/probing for G28, G33 (#21899)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 10114ebfc6..9b104615f6 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -274,20 +274,29 @@ typedef struct {
             min_segment_time_us;                // (¬µs) M205 B
       float axis_steps_per_mm[DISTINCT_AXES];   // (steps) M92 XYZE - Steps per millimeter
  feedRate_t max_feedrate_mm_s[DISTINCT_AXES];   // (mm/s) M203 XYZE - Max speeds
       float acceleration,                       // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
             retract_acceleration,               // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
             travel_acceleration;                // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
  feedRate_t min_feedrate_mm_s,                  // (mm/s) M205 S - Minimum linear feedrate
             min_travel_feedrate_mm_s;           // (mm/s) M205 T - Minimum travel feedrate
 } planner_settings_t;
 
+#if ENABLED(IMPROVE_HOMING_RELIABILITY)
+  struct motion_state_t {
+    TERN(DELTA, xyz_ulong_t, xy_ulong_t) acceleration;
+    #if HAS_CLASSIC_JERK
+      TERN(DELTA, xyz_float_t, xy_float_t) jerk_state;
+    #endif
+  };
+#endif
+
 #if DISABLED(SKEW_CORRECTION)
   #define XY_SKEW_FACTOR 0
   #define XZ_SKEW_FACTOR 0
   #define YZ_SKEW_FACTOR 0
 #endif
 
 typedef struct {
   #if ENABLED(SKEW_CORRECTION_GCODE)
     float xy;
     #if ENABLED(SKEW_CORRECTION_FOR_Z)
@@ -525,20 +534,24 @@ class Planner {
       void apply_filament_width_sensor(const int8_t encoded_ratio);
 
       static inline float volumetric_percent(const bool vol) {
         return 100.0f * (vol
             ? volumetric_area_nominal / volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
             : volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
         );
       }
     #endif
 
+    #if ENABLED(IMPROVE_HOMING_RELIABILITY)
+      void enable_stall_prevention(const bool onoff);
+    #endif
+
     #if DISABLED(NO_VOLUMETRICS)
 
       // Update multipliers based on new diameter measurements
       static void calculate_volumetric_multipliers();
 
       #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
         // Update pre calculated extruder feedrate limits based on volumetric values
         static void calculate_volumetric_extruder_limit(const uint8_t e);
         static void calculate_volumetric_extruder_limits();
       #endif

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 02b7179c5a..10114ebfc6 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -69,21 +69,23 @@
 #if ENABLED(DIRECT_STEPPING)
   #include "../feature/direct_stepping.h"
   #define IS_PAGE(B) TEST(B->flag, BLOCK_BIT_IS_PAGE)
 #else
   #define IS_PAGE(B) false
 #endif
 
 // Feedrate for manual moves
 #ifdef MANUAL_FEEDRATE
   constexpr xyze_feedrate_t _mf = MANUAL_FEEDRATE,
-           manual_feedrate_mm_s = LOGICAL_AXIS_ARRAY(_mf.e / 60.0f, _mf.x / 60.0f, _mf.y / 60.0f, _mf.z / 60.0f);
+           manual_feedrate_mm_s = LOGICAL_AXIS_ARRAY(_mf.e / 60.0f,
+                                                     _mf.x / 60.0f, _mf.y / 60.0f, _mf.z / 60.0f,
+                                                     _mf.i / 60.0f, _mf.j / 60.0f, _mf.k / 60.0f);
 #endif
 
 #if IS_KINEMATIC && HAS_JUNCTION_DEVIATION
   #define HAS_DIST_MM_ARG 1
 #endif
 
 enum BlockFlagBit : char {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
@@ -751,117 +753,84 @@ class Planner {
      *
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e     - target positions in mm and/or degrees
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      */
-    static bool buffer_segment(
-      LOGICAL_AXIS_LIST(const_float_t e, const_float_t a, const_float_t b, const_float_t c)
+    static bool buffer_segment(const abce_pos_t &abce
       OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
-      , const_feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
+      , const_feedRate_t fr_mm_s, const uint8_t extruder=active_extruder, const_float_t millimeters=0.0
     );
 
-    FORCE_INLINE static bool buffer_segment(abce_pos_t &abce
-      OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
-      , const_feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
-    ) {
-      return buffer_segment(
-        LOGICAL_AXIS_LIST(abce.e, abce.a, abce.b, abce.c)
-        OPTARG(HAS_DIST_MM_ARG, cart_dist_mm)
-        , fr_mm_s, extruder, millimeters
-      );
-    }
-
   public:
 
     /**
      * Add a new linear movement to the buffer.
      * The target is cartesian. It's translated to
      * delta/scara if needed.
      *
-     *  rx,ry,rz,e   - target position in mm or degrees
+     *  cart         - target position in mm or degrees
      *  fr_mm_s      - (target) speed of the move (mm/s)
      *  extruder     - target extruder
      *  millimeters  - the length of the movement, if known
      *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
      */
-    static bool buffer_line(
-      LOGICAL_AXIS_LIST(const_float_t e, const_float_t rx, const_float_t ry, const_float_t rz)
-      , const feedRate_t &fr_mm_s, const uint8_t extruder, const float millimeters=0.0
+    static bool buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s, const uint8_t extruder=active_extruder, const float millimeters=0.0
       OPTARG(SCARA_FEEDRATE_SCALING, const_float_t inv_duration=0.0)
     );
 
-    FORCE_INLINE static bool buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s, const uint8_t extruder, const float millimeters=0.0
-      OPTARG(SCARA_FEEDRATE_SCALING, const_float_t inv_duration=0.0)
-    ) {
-      return buffer_line(
-        LOGICAL_AXIS_LIST(cart.e, cart.x, cart.y, cart.z)
-        , fr_mm_s, extruder, millimeters
-        OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
-      );
-    }
-
     #if ENABLED(DIRECT_STEPPING)
       static void buffer_page(const page_idx_t page_idx, const uint8_t extruder, const uint16_t num_steps);
     #endif
 
     /**
      * Set the planner.position and individual stepper positions.
      * Used by G92, G28, G29, and other procedures.
      *
      * The supplied position is in the cartesian coordinate space and is
      * translated in to machine space as needed. Modifiers such as leveling
      * and skew are also applied.
      *
      * Multiplies by axis_steps_per_mm[] and does necessary conversion
      * for COREXY / COREXZ / COREYZ to set the corresponding stepper positions.
      *
      * Clears previous speed values.
      */
-    static void set_position_mm(
-      LOGICAL_AXIS_LIST(const_float_t e, const_float_t rx, const_float_t ry, const_float_t rz)
-    );
-    FORCE_INLINE static void set_position_mm(const xyze_pos_t &cart) {
-      set_position_mm(LOGICAL_AXIS_LIST(cart.e, cart.x, cart.y, cart.z, cart.i, cart.j, cart.k));
-    }
+    static void set_position_mm(const xyze_pos_t &xyze);
 
     #if HAS_EXTRUDERS
       static void set_e_position_mm(const_float_t e);
     #endif
 
     /**
      * Set the planner.position and individual stepper positions.
      *
      * The supplied position is in machine space, and no additional
      * conversions are applied.
      */
-    static void set_machine_position_mm(
-      LOGICAL_AXIS_LIST(const_float_t e, const_float_t a, const_float_t b, const_float_t c)
-    );
-    FORCE_INLINE static void set_machine_position_mm(const abce_pos_t &abce) {
-      set_machine_position_mm(LOGICAL_AXIS_LIST(abce.e, abce.a, abce.b, abce.c));
-    }
+    static void set_machine_position_mm(const abce_pos_t &abce);
 
     /**
      * Get an axis position according to stepper position(s)
      * For CORE machines apply translation from ABC to XYZ.
      */
     static float get_axis_position_mm(const AxisEnum axis);
 
     static inline abce_pos_t get_axis_positions_mm() {
       const abce_pos_t out = LOGICAL_AXIS_ARRAY(
         get_axis_position_mm(E_AXIS),
-        get_axis_position_mm(A_AXIS), get_axis_position_mm(B_AXIS), get_axis_position_mm(C_AXIS)
+        get_axis_position_mm(A_AXIS), get_axis_position_mm(B_AXIS), get_axis_position_mm(C_AXIS),
+        get_axis_position_mm(I_AXIS), get_axis_position_mm(J_AXIS), get_axis_position_mm(K_AXIS)
       );
       return out;
     }
 
     // SCARA AB axes are in degrees, not mm
     #if IS_SCARA
       FORCE_INLINE static float get_axis_position_degrees(const AxisEnum axis) { return get_axis_position_mm(axis); }
     #endif
 
     // Called to force a quick stop of the machine (for example, when

commit eea9b6d8ae38af3ca9d5b2f6fb355fc8fce405fb
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sat Jun 5 03:02:37 2021 +0200

    üêõ Fix MMU compile with >5 EXTRUDERS (#22036)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index edeac9b7f9..02b7179c5a 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -443,22 +443,22 @@ class Planner {
     /**
      * Limit where 64bit math is necessary for acceleration calculation
      */
     static uint32_t acceleration_long_cutoff;
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       static float last_fade_z;
     #endif
 
     #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
-       // Counters to manage disabling inactive extruders
-      static last_move_t g_uc_extruder_last_move[EXTRUDERS];
+      // Counters to manage disabling inactive extruder steppers
+      static last_move_t g_uc_extruder_last_move[E_STEPPERS];
     #endif
 
     #if HAS_WIRED_LCD
       volatile static uint32_t block_buffer_runtime_us; // Theoretical block buffer runtime in ¬µs
     #endif
 
   public:
 
     /**
      * Instance Methods

commit dd4990252e891cdfe56cb7d6e3bbe1e6289be649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 24 16:38:57 2021 -0500

    ‚ôªÔ∏è Refactor Linear / Logical / Distinct Axes (#21953)
    
    * More patches supporting EXTRUDERS 0
    * Extend types in prep for more axes

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index be004dd3f4..edeac9b7f9 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -69,21 +69,21 @@
 #if ENABLED(DIRECT_STEPPING)
   #include "../feature/direct_stepping.h"
   #define IS_PAGE(B) TEST(B->flag, BLOCK_BIT_IS_PAGE)
 #else
   #define IS_PAGE(B) false
 #endif
 
 // Feedrate for manual moves
 #ifdef MANUAL_FEEDRATE
   constexpr xyze_feedrate_t _mf = MANUAL_FEEDRATE,
-                            manual_feedrate_mm_s { _mf.x / 60.0f, _mf.y / 60.0f, _mf.z / 60.0f, _mf.e / 60.0f };
+           manual_feedrate_mm_s = LOGICAL_AXIS_ARRAY(_mf.e / 60.0f, _mf.x / 60.0f, _mf.y / 60.0f, _mf.z / 60.0f);
 #endif
 
 #if IS_KINEMATIC && HAS_JUNCTION_DEVIATION
   #define HAS_DIST_MM_ARG 1
 #endif
 
 enum BlockFlagBit : char {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
@@ -751,55 +751,62 @@ class Planner {
      *
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e     - target positions in mm and/or degrees
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      */
-    static bool buffer_segment(const_float_t a, const_float_t b, const_float_t c, const_float_t e
+    static bool buffer_segment(
+      LOGICAL_AXIS_LIST(const_float_t e, const_float_t a, const_float_t b, const_float_t c)
       OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
       , const_feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
     );
 
     FORCE_INLINE static bool buffer_segment(abce_pos_t &abce
       OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
       , const_feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
     ) {
-      return buffer_segment(abce.a, abce.b, abce.c, abce.e
+      return buffer_segment(
+        LOGICAL_AXIS_LIST(abce.e, abce.a, abce.b, abce.c)
         OPTARG(HAS_DIST_MM_ARG, cart_dist_mm)
-        , fr_mm_s, extruder, millimeters);
+        , fr_mm_s, extruder, millimeters
+      );
     }
 
   public:
 
     /**
      * Add a new linear movement to the buffer.
      * The target is cartesian. It's translated to
      * delta/scara if needed.
      *
      *  rx,ry,rz,e   - target position in mm or degrees
      *  fr_mm_s      - (target) speed of the move (mm/s)
      *  extruder     - target extruder
      *  millimeters  - the length of the movement, if known
      *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
      */
-    static bool buffer_line(const_float_t rx, const_float_t ry, const_float_t rz, const_float_t e, const_feedRate_t fr_mm_s, const uint8_t extruder, const float millimeters=0.0
+    static bool buffer_line(
+      LOGICAL_AXIS_LIST(const_float_t e, const_float_t rx, const_float_t ry, const_float_t rz)
+      , const feedRate_t &fr_mm_s, const uint8_t extruder, const float millimeters=0.0
       OPTARG(SCARA_FEEDRATE_SCALING, const_float_t inv_duration=0.0)
     );
 
     FORCE_INLINE static bool buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s, const uint8_t extruder, const float millimeters=0.0
       OPTARG(SCARA_FEEDRATE_SCALING, const_float_t inv_duration=0.0)
     ) {
-      return buffer_line(cart.x, cart.y, cart.z, cart.e, fr_mm_s, extruder, millimeters
+      return buffer_line(
+        LOGICAL_AXIS_LIST(cart.e, cart.x, cart.y, cart.z)
+        , fr_mm_s, extruder, millimeters
         OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
       );
     }
 
     #if ENABLED(DIRECT_STEPPING)
       static void buffer_page(const page_idx_t page_idx, const uint8_t extruder, const uint16_t num_steps);
     #endif
 
     /**
      * Set the planner.position and individual stepper positions.
@@ -807,46 +814,55 @@ class Planner {
      *
      * The supplied position is in the cartesian coordinate space and is
      * translated in to machine space as needed. Modifiers such as leveling
      * and skew are also applied.
      *
      * Multiplies by axis_steps_per_mm[] and does necessary conversion
      * for COREXY / COREXZ / COREYZ to set the corresponding stepper positions.
      *
      * Clears previous speed values.
      */
-    static void set_position_mm(const_float_t rx, const_float_t ry, const_float_t rz, const_float_t e);
-    FORCE_INLINE static void set_position_mm(const xyze_pos_t &cart) { set_position_mm(cart.x, cart.y, cart.z, cart.e); }
-    static void set_e_position_mm(const_float_t e);
+    static void set_position_mm(
+      LOGICAL_AXIS_LIST(const_float_t e, const_float_t rx, const_float_t ry, const_float_t rz)
+    );
+    FORCE_INLINE static void set_position_mm(const xyze_pos_t &cart) {
+      set_position_mm(LOGICAL_AXIS_LIST(cart.e, cart.x, cart.y, cart.z, cart.i, cart.j, cart.k));
+    }
+
+    #if HAS_EXTRUDERS
+      static void set_e_position_mm(const_float_t e);
+    #endif
 
     /**
      * Set the planner.position and individual stepper positions.
      *
      * The supplied position is in machine space, and no additional
      * conversions are applied.
      */
-    static void set_machine_position_mm(const_float_t a, const_float_t b, const_float_t c, const_float_t e);
-    FORCE_INLINE static void set_machine_position_mm(const abce_pos_t &abce) { set_machine_position_mm(abce.a, abce.b, abce.c, abce.e); }
+    static void set_machine_position_mm(
+      LOGICAL_AXIS_LIST(const_float_t e, const_float_t a, const_float_t b, const_float_t c)
+    );
+    FORCE_INLINE static void set_machine_position_mm(const abce_pos_t &abce) {
+      set_machine_position_mm(LOGICAL_AXIS_LIST(abce.e, abce.a, abce.b, abce.c));
+    }
 
     /**
      * Get an axis position according to stepper position(s)
      * For CORE machines apply translation from ABC to XYZ.
      */
     static float get_axis_position_mm(const AxisEnum axis);
 
     static inline abce_pos_t get_axis_positions_mm() {
-      const abce_pos_t out = {
-        get_axis_position_mm(A_AXIS),
-        get_axis_position_mm(B_AXIS),
-        get_axis_position_mm(C_AXIS),
-        get_axis_position_mm(E_AXIS)
-      };
+      const abce_pos_t out = LOGICAL_AXIS_ARRAY(
+        get_axis_position_mm(E_AXIS),
+        get_axis_position_mm(A_AXIS), get_axis_position_mm(B_AXIS), get_axis_position_mm(C_AXIS)
+      );
       return out;
     }
 
     // SCARA AB axes are in degrees, not mm
     #if IS_SCARA
       FORCE_INLINE static float get_axis_position_degrees(const AxisEnum axis) { return get_axis_position_mm(axis); }
     #endif
 
     // Called to force a quick stop of the machine (for example, when
     // a Full Shutdown is required, or when endstops are hit)

commit 84fd0eff17d089e3f75f6585d4bba47f15c00ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 23 21:33:22 2021 -0500

    üé® Macros for optional arguments (#21969)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 66e98f4a57..be004dd3f4 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -700,49 +700,40 @@ class Planner {
      * Add a new linear movement to the buffer (in terms of steps).
      *
      *  target      - target position in steps units
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      *
      * Returns true if movement was buffered, false otherwise
      */
     static bool _buffer_steps(const xyze_long_t &target
-      #if HAS_POSITION_FLOAT
-        , const xyze_pos_t &target_float
-      #endif
-      #if HAS_DIST_MM_ARG
-        , const xyze_float_t &cart_dist_mm
-      #endif
+      OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
+      OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
       , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
     );
 
     /**
      * Planner::_populate_block
      *
      * Fills a new linear movement in the block (in terms of steps).
      *
      *  target      - target position in steps units
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      *
      * Returns true is movement is acceptable, false otherwise
      */
-    static bool _populate_block(block_t * const block, bool split_move,
-        const xyze_long_t &target
-      #if HAS_POSITION_FLOAT
-        , const xyze_pos_t &target_float
-      #endif
-      #if HAS_DIST_MM_ARG
-        , const xyze_float_t &cart_dist_mm
-      #endif
+    static bool _populate_block(block_t * const block, bool split_move, const xyze_long_t &target
+      OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
+      OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
       , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
     );
 
     /**
      * Planner::buffer_sync_block
      * Add a block to the buffer that just updates the position or in
      * case of LASER_SYNCHRONOUS_M106_M107 the fan pwm
      */
     static void buffer_sync_block(
       TERN_(LASER_SYNCHRONOUS_M106_M107, uint8_t sync_flag=BLOCK_FLAG_SYNC_POSITION)
@@ -761,67 +752,55 @@ class Planner {
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e     - target positions in mm and/or degrees
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      */
     static bool buffer_segment(const_float_t a, const_float_t b, const_float_t c, const_float_t e
-      #if HAS_DIST_MM_ARG
-        , const xyze_float_t &cart_dist_mm
-      #endif
+      OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
       , const_feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
     );
 
     FORCE_INLINE static bool buffer_segment(abce_pos_t &abce
-      #if HAS_DIST_MM_ARG
-        , const xyze_float_t &cart_dist_mm
-      #endif
+      OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
       , const_feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
     ) {
       return buffer_segment(abce.a, abce.b, abce.c, abce.e
-        #if HAS_DIST_MM_ARG
-          , cart_dist_mm
-        #endif
+        OPTARG(HAS_DIST_MM_ARG, cart_dist_mm)
         , fr_mm_s, extruder, millimeters);
     }
 
   public:
 
     /**
      * Add a new linear movement to the buffer.
      * The target is cartesian. It's translated to
      * delta/scara if needed.
      *
      *  rx,ry,rz,e   - target position in mm or degrees
      *  fr_mm_s      - (target) speed of the move (mm/s)
      *  extruder     - target extruder
      *  millimeters  - the length of the movement, if known
      *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
      */
     static bool buffer_line(const_float_t rx, const_float_t ry, const_float_t rz, const_float_t e, const_feedRate_t fr_mm_s, const uint8_t extruder, const float millimeters=0.0
-      #if ENABLED(SCARA_FEEDRATE_SCALING)
-        , const_float_t inv_duration=0.0
-      #endif
+      OPTARG(SCARA_FEEDRATE_SCALING, const_float_t inv_duration=0.0)
     );
 
     FORCE_INLINE static bool buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s, const uint8_t extruder, const float millimeters=0.0
-      #if ENABLED(SCARA_FEEDRATE_SCALING)
-        , const_float_t inv_duration=0.0
-      #endif
+      OPTARG(SCARA_FEEDRATE_SCALING, const_float_t inv_duration=0.0)
     ) {
       return buffer_line(cart.x, cart.y, cart.z, cart.e, fr_mm_s, extruder, millimeters
-        #if ENABLED(SCARA_FEEDRATE_SCALING)
-          , inv_duration
-        #endif
+        OPTARG(SCARA_FEEDRATE_SCALING, inv_duration)
       );
     }
 
     #if ENABLED(DIRECT_STEPPING)
       static void buffer_page(const page_idx_t page_idx, const uint8_t extruder, const uint16_t num_steps);
     #endif
 
     /**
      * Set the planner.position and individual stepper positions.
      * Used by G92, G28, G29, and other procedures.

commit d71b35c24f5e8d4c40d5e721f3548abfe899592d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 22 21:12:53 2021 -0500

    üé® Apply shorthand and cleanups

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 2ec90e1fa2..66e98f4a57 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -484,21 +484,21 @@ class Planner {
     // For an axis set the Maximum Acceleration in mm/s^2
     static void set_max_acceleration(const uint8_t axis, float inMaxAccelMMS2);
 
     // For an axis set the Maximum Feedrate in mm/s
     static void set_max_feedrate(const uint8_t axis, float inMaxFeedrateMMS);
 
     // For an axis set the Maximum Jerk (instant change) in mm/s
     #if HAS_CLASSIC_JERK
       static void set_max_jerk(const AxisEnum axis, float inMaxJerkMMS);
     #else
-      static inline void set_max_jerk(const AxisEnum, const_float_t ) {}
+      static inline void set_max_jerk(const AxisEnum, const_float_t) {}
     #endif
 
     #if HAS_EXTRUDERS
       FORCE_INLINE static void refresh_e_factor(const uint8_t e) {
         e_factor[e] = flow_percentage[e] * 0.01f * TERN(NO_VOLUMETRICS, 1.0f, volumetric_multiplier[e]);
       }
 
       static inline void set_flow(const uint8_t e, const int16_t flow) {
         flow_percentage[e] = flow;
         refresh_e_factor(e);
@@ -585,23 +585,23 @@ class Planner {
         inverse_z_fade_height = RECIPROCAL(z_fade_height);
         force_fade_recalc();
       }
 
       FORCE_INLINE static bool leveling_active_at_z(const_float_t rz) {
         return !z_fade_height || rz < z_fade_height;
       }
 
     #else
 
-      FORCE_INLINE static float fade_scaling_factor_for_z(const_float_t ) { return 1; }
+      FORCE_INLINE static float fade_scaling_factor_for_z(const_float_t) { return 1; }
 
-      FORCE_INLINE static bool leveling_active_at_z(const_float_t ) { return true; }
+      FORCE_INLINE static bool leveling_active_at_z(const_float_t) { return true; }
 
     #endif
 
     #if ENABLED(SKEW_CORRECTION)
 
       FORCE_INLINE static void skew(float &cx, float &cy, const_float_t cz) {
         if (COORDINATE_OKAY(cx, X_MIN_POS + 1, X_MAX_POS) && COORDINATE_OKAY(cy, Y_MIN_POS + 1, Y_MAX_POS)) {
           const float sx = cx - cy * skew_factor.xy - cz * (skew_factor.xz - (skew_factor.xy * skew_factor.yz)),
                       sy = cy - cz * skew_factor.yz;
           if (COORDINATE_OKAY(sx, X_MIN_POS, X_MAX_POS) && COORDINATE_OKAY(sy, Y_MIN_POS, Y_MAX_POS)) {

commit 2de54dab84d82ef69fb9ac3bd9025444f4f84813
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 21 08:23:09 2021 -0500

    üé® Move HAS_EXTRUDERS

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index db83792b45..2ec90e1fa2 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -330,21 +330,21 @@ class Planner {
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;                 // Respond to extruder change
     #endif
 
     #if ENABLED(DIRECT_STEPPING)
       static uint32_t last_page_step_rate;          // Last page step rate given
       static xyze_bool_t last_page_dir;             // Last page direction given
     #endif
 
-    #if EXTRUDERS
+    #if HAS_EXTRUDERS
       static int16_t flow_percentage[EXTRUDERS];    // Extrusion factor for each extruder
       static float e_factor[EXTRUDERS];             // The flow percentage and volumetric multiplier combine to scale E movement
     #endif
 
     #if DISABLED(NO_VOLUMETRICS)
       static float filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
                    volumetric_area_nominal,           // Nominal cross-sectional area
                    volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                       // May be auto-adjusted by a filament width sensor
     #endif
@@ -487,21 +487,21 @@ class Planner {
     // For an axis set the Maximum Feedrate in mm/s
     static void set_max_feedrate(const uint8_t axis, float inMaxFeedrateMMS);
 
     // For an axis set the Maximum Jerk (instant change) in mm/s
     #if HAS_CLASSIC_JERK
       static void set_max_jerk(const AxisEnum axis, float inMaxJerkMMS);
     #else
       static inline void set_max_jerk(const AxisEnum, const_float_t ) {}
     #endif
 
-    #if EXTRUDERS
+    #if HAS_EXTRUDERS
       FORCE_INLINE static void refresh_e_factor(const uint8_t e) {
         e_factor[e] = flow_percentage[e] * 0.01f * TERN(NO_VOLUMETRICS, 1.0f, volumetric_multiplier[e]);
       }
 
       static inline void set_flow(const uint8_t e, const int16_t flow) {
         flow_percentage[e] = flow;
         refresh_e_factor(e);
       }
 
     #endif

commit a6e5492b088add3589aeac168136369f21614e60
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:51:19 2021 -0500

    ‚ôªÔ∏è Refactor axis counts and loops

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 30eeb758a4..db83792b45 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -261,24 +261,24 @@ typedef struct block_t {
      * or the OCR (oscillator count register) value;
      *
      * Using OCR instead of raw power, because it avoids
      * floating point operations during the move loop.
      */
     uint8_t power;
   } laser_state_t;
 #endif
 
 typedef struct {
-   uint32_t max_acceleration_mm_per_s2[XYZE_N], // (mm/s^2) M201 XYZE
+   uint32_t max_acceleration_mm_per_s2[DISTINCT_AXES], // (mm/s^2) M201 XYZE
             min_segment_time_us;                // (¬µs) M205 B
-      float axis_steps_per_mm[XYZE_N];          // (steps) M92 XYZE - Steps per millimeter
- feedRate_t max_feedrate_mm_s[XYZE_N];          // (mm/s) M203 XYZE - Max speeds
+      float axis_steps_per_mm[DISTINCT_AXES];   // (steps) M92 XYZE - Steps per millimeter
+ feedRate_t max_feedrate_mm_s[DISTINCT_AXES];   // (mm/s) M203 XYZE - Max speeds
       float acceleration,                       // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
             retract_acceleration,               // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
             travel_acceleration;                // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
  feedRate_t min_feedrate_mm_s,                  // (mm/s) M205 S - Minimum linear feedrate
             min_travel_feedrate_mm_s;           // (mm/s) M205 T - Minimum travel feedrate
 } planner_settings_t;
 
 #if DISABLED(SKEW_CORRECTION)
   #define XY_SKEW_FACTOR 0
   #define XZ_SKEW_FACTOR 0
@@ -353,27 +353,27 @@ class Planner {
       static float volumetric_extruder_limit[EXTRUDERS],          // Maximum mm^3/sec the extruder can handle
                    volumetric_extruder_feedrate_limit[EXTRUDERS]; // Feedrate limit (mm/s) calculated from volume limit
     #endif
 
     static planner_settings_t settings;
 
     #if ENABLED(LASER_POWER_INLINE)
       static laser_state_t laser_inline;
     #endif
 
-    static uint32_t max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
-    static float steps_to_mm[XYZE_N];           // Millimeters per step
+    static uint32_t max_acceleration_steps_per_s2[DISTINCT_AXES]; // (steps/s^2) Derived from mm_per_s2
+    static float steps_to_mm[DISTINCT_AXES];          // Millimeters per step
 
     #if HAS_JUNCTION_DEVIATION
-      static float junction_deviation_mm;       // (mm) M205 J
+      static float junction_deviation_mm;             // (mm) M205 J
       #if HAS_LINEAR_E_JERK
-        static float max_e_jerk[DISTINCT_E];    // Calculated from junction_deviation_mm
+        static float max_e_jerk[DISTINCT_E];          // Calculated from junction_deviation_mm
       #endif
     #endif
 
     #if HAS_CLASSIC_JERK
       // (mm/s^2) M205 XYZ(E) - The largest speed change requiring no acceleration.
       static TERN(HAS_LINEAR_E_JERK, xyz_pos_t, xyze_pos_t) max_jerk;
     #endif
 
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
@@ -1007,27 +1007,27 @@ class Planner {
     static void forward_pass();
 
     static void recalculate_trapezoids();
 
     static void recalculate();
 
     #if HAS_JUNCTION_DEVIATION
 
       FORCE_INLINE static void normalize_junction_vector(xyze_float_t &vector) {
         float magnitude_sq = 0;
-        LOOP_XYZE(idx) if (vector[idx]) magnitude_sq += sq(vector[idx]);
+        LOOP_LOGICAL_AXES(idx) if (vector[idx]) magnitude_sq += sq(vector[idx]);
         vector *= RSQRT(magnitude_sq);
       }
 
       FORCE_INLINE static float limit_value_by_axis_maximum(const_float_t max_value, xyze_float_t &unit_vec) {
         float limit_value = max_value;
-        LOOP_XYZE(idx) {
+        LOOP_LOGICAL_AXES(idx) {
           if (unit_vec[idx]) {
             if (limit_value * ABS(unit_vec[idx]) > settings.max_acceleration_mm_per_s2[idx])
               limit_value = ABS(settings.max_acceleration_mm_per_s2[idx] / unit_vec[idx]);
           }
         }
         return limit_value;
       }
 
     #endif // !CLASSIC_JERK
 };

commit 32dba5e0c735166d3bb54783efbf0d5d1b275b66
Author: fedetony <45215920+fedetony@users.noreply.github.com>
Date:   Fri Apr 16 08:59:28 2021 +0200

    Realtime Reporting, S000, P000, R000 (#19330)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 398339f04e..30eeb758a4 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -866,20 +866,27 @@ class Planner {
 
     // SCARA AB axes are in degrees, not mm
     #if IS_SCARA
       FORCE_INLINE static float get_axis_position_degrees(const AxisEnum axis) { return get_axis_position_mm(axis); }
     #endif
 
     // Called to force a quick stop of the machine (for example, when
     // a Full Shutdown is required, or when endstops are hit)
     static void quick_stop();
 
+    #if ENABLED(REALTIME_REPORTING_COMMANDS)
+      // Force a quick pause of the machine (e.g., when a pause is required in the middle of move).
+      // NOTE: Hard-stops will lose steps so encoders are highly recommended if using these!
+      static void quick_pause();
+      static void quick_resume();
+    #endif
+
     // Called when an endstop is triggered. Causes the machine to stop inmediately
     static void endstop_triggered(const AxisEnum axis);
 
     // Triggered position of an axis in mm (not core-savvy)
     static float triggered_position_mm(const AxisEnum axis);
 
     // Block until all buffered steps are executed / cleaned
     static void synchronize();
 
     // Wait for moves to finish and disable all steppers

commit d705a5b45efa4c7a47650fc2c187ff1d025db8fa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 13 23:22:57 2021 -0500

    Fix long acceleration overflow

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index d4ed00d2fa..398339f04e 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -436,21 +436,21 @@ class Planner {
     static xyze_float_t previous_speed;
 
     /**
      * Nominal speed of previous path line segment (mm/s)^2
      */
     static float previous_nominal_speed_sqr;
 
     /**
      * Limit where 64bit math is necessary for acceleration calculation
      */
-    static uint32_t cutoff_long;
+    static uint32_t acceleration_long_cutoff;
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       static float last_fade_z;
     #endif
 
     #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
        // Counters to manage disabling inactive extruders
       static last_move_t g_uc_extruder_last_move[EXTRUDERS];
     #endif
 

commit 6ab7baa413b520fde11f588e288b391b39bf4cd8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 8 15:43:16 2021 -0500

    tick() => isr() to spotlight interrupt-time

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 570fcc08af..d4ed00d2fa 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -878,25 +878,23 @@ class Planner {
 
     // Triggered position of an axis in mm (not core-savvy)
     static float triggered_position_mm(const AxisEnum axis);
 
     // Block until all buffered steps are executed / cleaned
     static void synchronize();
 
     // Wait for moves to finish and disable all steppers
     static void finish_and_disable();
 
-    // Periodic tick to handle cleaning timeouts
+    // Periodic handler to manage the cleaning buffer counter
     // Called from the Temperature ISR at ~1kHz
-    static void tick() {
-      if (cleaning_buffer_counter) --cleaning_buffer_counter;
-    }
+    static void isr() { if (cleaning_buffer_counter) --cleaning_buffer_counter; }
 
     /**
      * Does the buffer have any blocks queued?
      */
     FORCE_INLINE static bool has_blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
     /**
      * Get the current block for processing
      * and mark the block as busy.
      * Return nullptr if the buffer is empty

commit ed14731146006442f1cc4045b70cefdec00aaa8f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 5 21:27:05 2021 -0500

    getHighESpeed => autotemp_task

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 6b99c8bcc1..570fcc08af 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -919,21 +919,21 @@ class Planner {
       static uint16_t block_buffer_runtime();
       static void clear_block_buffer_runtime();
     #endif
 
     #if ENABLED(AUTOTEMP)
       static celsius_t autotemp_min, autotemp_max;
       static float autotemp_factor;
       static bool autotemp_enabled;
       static void autotemp_update();
       static void autotemp_M104_M109();
-      static void getHighESpeed();
+      static void autotemp_task();
     #endif
 
     #if HAS_LINEAR_E_JERK
       FORCE_INLINE static void recalculate_max_e_jerk() {
         const float prop = junction_deviation_mm * SQRT(0.5) / (1.0f - SQRT(0.5));
         LOOP_L_N(i, EXTRUDERS)
           max_e_jerk[E_INDEX_N(i)] = SQRT(prop * settings.max_acceleration_mm_per_s2[E_INDEX_N(i)]);
       }
     #endif
 

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 768bf29e2f..6b99c8bcc1 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -484,21 +484,21 @@ class Planner {
     // For an axis set the Maximum Acceleration in mm/s^2
     static void set_max_acceleration(const uint8_t axis, float inMaxAccelMMS2);
 
     // For an axis set the Maximum Feedrate in mm/s
     static void set_max_feedrate(const uint8_t axis, float inMaxFeedrateMMS);
 
     // For an axis set the Maximum Jerk (instant change) in mm/s
     #if HAS_CLASSIC_JERK
       static void set_max_jerk(const AxisEnum axis, float inMaxJerkMMS);
     #else
-      static inline void set_max_jerk(const AxisEnum, const float&) {}
+      static inline void set_max_jerk(const AxisEnum, const_float_t ) {}
     #endif
 
     #if EXTRUDERS
       FORCE_INLINE static void refresh_e_factor(const uint8_t e) {
         e_factor[e] = flow_percentage[e] * 0.01f * TERN(NO_VOLUMETRICS, 1.0f, volumetric_multiplier[e]);
       }
 
       static inline void set_flow(const uint8_t e, const int16_t flow) {
         flow_percentage[e] = flow;
         refresh_e_factor(e);
@@ -534,91 +534,91 @@ class Planner {
 
       // Update multipliers based on new diameter measurements
       static void calculate_volumetric_multipliers();
 
       #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
         // Update pre calculated extruder feedrate limits based on volumetric values
         static void calculate_volumetric_extruder_limit(const uint8_t e);
         static void calculate_volumetric_extruder_limits();
       #endif
 
-      FORCE_INLINE static void set_filament_size(const uint8_t e, const float &v) {
+      FORCE_INLINE static void set_filament_size(const uint8_t e, const_float_t v) {
         filament_size[e] = v;
         if (v > 0) volumetric_area_nominal = CIRCLE_AREA(v * 0.5); //TODO: should it be per extruder
         // make sure all extruders have some sane value for the filament size
         LOOP_L_N(i, COUNT(filament_size))
           if (!filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;
       }
 
     #endif
 
     #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
-      FORCE_INLINE static void set_volumetric_extruder_limit(const uint8_t e, const float &v) {
+      FORCE_INLINE static void set_volumetric_extruder_limit(const uint8_t e, const_float_t v) {
         volumetric_extruder_limit[e] = v;
         calculate_volumetric_extruder_limit(e);
       }
     #endif
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
 
       /**
        * Get the Z leveling fade factor based on the given Z height,
        * re-calculating only when needed.
        *
        *  Returns 1.0 if planner.z_fade_height is 0.0.
        *  Returns 0.0 if Z is past the specified 'Fade Height'.
        */
-      static inline float fade_scaling_factor_for_z(const float &rz) {
+      static inline float fade_scaling_factor_for_z(const_float_t rz) {
         static float z_fade_factor = 1;
         if (!z_fade_height) return 1;
         if (rz >= z_fade_height) return 0;
         if (last_fade_z != rz) {
           last_fade_z = rz;
           z_fade_factor = 1 - rz * inverse_z_fade_height;
         }
         return z_fade_factor;
       }
 
       FORCE_INLINE static void force_fade_recalc() { last_fade_z = -999.999f; }
 
-      FORCE_INLINE static void set_z_fade_height(const float &zfh) {
+      FORCE_INLINE static void set_z_fade_height(const_float_t zfh) {
         z_fade_height = zfh > 0 ? zfh : 0;
         inverse_z_fade_height = RECIPROCAL(z_fade_height);
         force_fade_recalc();
       }
 
-      FORCE_INLINE static bool leveling_active_at_z(const float &rz) {
+      FORCE_INLINE static bool leveling_active_at_z(const_float_t rz) {
         return !z_fade_height || rz < z_fade_height;
       }
 
     #else
 
-      FORCE_INLINE static float fade_scaling_factor_for_z(const float&) { return 1; }
+      FORCE_INLINE static float fade_scaling_factor_for_z(const_float_t ) { return 1; }
 
-      FORCE_INLINE static bool leveling_active_at_z(const float&) { return true; }
+      FORCE_INLINE static bool leveling_active_at_z(const_float_t ) { return true; }
 
     #endif
 
     #if ENABLED(SKEW_CORRECTION)
 
-      FORCE_INLINE static void skew(float &cx, float &cy, const float &cz) {
+      FORCE_INLINE static void skew(float &cx, float &cy, const_float_t cz) {
         if (COORDINATE_OKAY(cx, X_MIN_POS + 1, X_MAX_POS) && COORDINATE_OKAY(cy, Y_MIN_POS + 1, Y_MAX_POS)) {
           const float sx = cx - cy * skew_factor.xy - cz * (skew_factor.xz - (skew_factor.xy * skew_factor.yz)),
                       sy = cy - cz * skew_factor.yz;
           if (COORDINATE_OKAY(sx, X_MIN_POS, X_MAX_POS) && COORDINATE_OKAY(sy, Y_MIN_POS, Y_MAX_POS)) {
             cx = sx; cy = sy;
           }
         }
       }
       FORCE_INLINE static void skew(xyz_pos_t &raw) { skew(raw.x, raw.y, raw.z); }
 
-      FORCE_INLINE static void unskew(float &cx, float &cy, const float &cz) {
+      FORCE_INLINE static void unskew(float &cx, float &cy, const_float_t cz) {
         if (COORDINATE_OKAY(cx, X_MIN_POS, X_MAX_POS) && COORDINATE_OKAY(cy, Y_MIN_POS, Y_MAX_POS)) {
           const float sx = cx + cy * skew_factor.xy + cz * skew_factor.xz,
                       sy = cy + cz * skew_factor.yz;
           if (COORDINATE_OKAY(sx, X_MIN_POS, X_MAX_POS) && COORDINATE_OKAY(sy, Y_MIN_POS, Y_MAX_POS)) {
             cx = sx; cy = sy;
           }
         }
       }
       FORCE_INLINE static void unskew(xyz_pos_t &raw) { unskew(raw.x, raw.y, raw.z); }
 
@@ -706,21 +706,21 @@ class Planner {
      *
      * Returns true if movement was buffered, false otherwise
      */
     static bool _buffer_steps(const xyze_long_t &target
       #if HAS_POSITION_FLOAT
         , const xyze_pos_t &target_float
       #endif
       #if HAS_DIST_MM_ARG
         , const xyze_float_t &cart_dist_mm
       #endif
-      , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
+      , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
     );
 
     /**
      * Planner::_populate_block
      *
      * Fills a new linear movement in the block (in terms of steps).
      *
      *  target      - target position in steps units
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
@@ -729,21 +729,21 @@ class Planner {
      * Returns true is movement is acceptable, false otherwise
      */
     static bool _populate_block(block_t * const block, bool split_move,
         const xyze_long_t &target
       #if HAS_POSITION_FLOAT
         , const xyze_pos_t &target_float
       #endif
       #if HAS_DIST_MM_ARG
         , const xyze_float_t &cart_dist_mm
       #endif
-      , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
+      , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
     );
 
     /**
      * Planner::buffer_sync_block
      * Add a block to the buffer that just updates the position or in
      * case of LASER_SYNCHRONOUS_M106_M107 the fan pwm
      */
     static void buffer_sync_block(
       TERN_(LASER_SYNCHRONOUS_M106_M107, uint8_t sync_flag=BLOCK_FLAG_SYNC_POSITION)
     );
@@ -760,32 +760,32 @@ class Planner {
      *
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e     - target positions in mm and/or degrees
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      */
-    static bool buffer_segment(const float &a, const float &b, const float &c, const float &e
+    static bool buffer_segment(const_float_t a, const_float_t b, const_float_t c, const_float_t e
       #if HAS_DIST_MM_ARG
         , const xyze_float_t &cart_dist_mm
       #endif
-      , const feedRate_t &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
+      , const_feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
     );
 
     FORCE_INLINE static bool buffer_segment(abce_pos_t &abce
       #if HAS_DIST_MM_ARG
         , const xyze_float_t &cart_dist_mm
       #endif
-      , const feedRate_t &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
+      , const_feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters=0.0
     ) {
       return buffer_segment(abce.a, abce.b, abce.c, abce.e
         #if HAS_DIST_MM_ARG
           , cart_dist_mm
         #endif
         , fr_mm_s, extruder, millimeters);
     }
 
   public:
 
@@ -793,29 +793,29 @@ class Planner {
      * Add a new linear movement to the buffer.
      * The target is cartesian. It's translated to
      * delta/scara if needed.
      *
      *  rx,ry,rz,e   - target position in mm or degrees
      *  fr_mm_s      - (target) speed of the move (mm/s)
      *  extruder     - target extruder
      *  millimeters  - the length of the movement, if known
      *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
      */
-    static bool buffer_line(const float &rx, const float &ry, const float &rz, const float &e, const feedRate_t &fr_mm_s, const uint8_t extruder, const float millimeters=0.0
+    static bool buffer_line(const_float_t rx, const_float_t ry, const_float_t rz, const_float_t e, const_feedRate_t fr_mm_s, const uint8_t extruder, const float millimeters=0.0
       #if ENABLED(SCARA_FEEDRATE_SCALING)
-        , const float &inv_duration=0.0
+        , const_float_t inv_duration=0.0
       #endif
     );
 
-    FORCE_INLINE static bool buffer_line(const xyze_pos_t &cart, const feedRate_t &fr_mm_s, const uint8_t extruder, const float millimeters=0.0
+    FORCE_INLINE static bool buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s, const uint8_t extruder, const float millimeters=0.0
       #if ENABLED(SCARA_FEEDRATE_SCALING)
-        , const float &inv_duration=0.0
+        , const_float_t inv_duration=0.0
       #endif
     ) {
       return buffer_line(cart.x, cart.y, cart.z, cart.e, fr_mm_s, extruder, millimeters
         #if ENABLED(SCARA_FEEDRATE_SCALING)
           , inv_duration
         #endif
       );
     }
 
     #if ENABLED(DIRECT_STEPPING)
@@ -828,31 +828,31 @@ class Planner {
      *
      * The supplied position is in the cartesian coordinate space and is
      * translated in to machine space as needed. Modifiers such as leveling
      * and skew are also applied.
      *
      * Multiplies by axis_steps_per_mm[] and does necessary conversion
      * for COREXY / COREXZ / COREYZ to set the corresponding stepper positions.
      *
      * Clears previous speed values.
      */
-    static void set_position_mm(const float &rx, const float &ry, const float &rz, const float &e);
+    static void set_position_mm(const_float_t rx, const_float_t ry, const_float_t rz, const_float_t e);
     FORCE_INLINE static void set_position_mm(const xyze_pos_t &cart) { set_position_mm(cart.x, cart.y, cart.z, cart.e); }
-    static void set_e_position_mm(const float &e);
+    static void set_e_position_mm(const_float_t e);
 
     /**
      * Set the planner.position and individual stepper positions.
      *
      * The supplied position is in machine space, and no additional
      * conversions are applied.
      */
-    static void set_machine_position_mm(const float &a, const float &b, const float &c, const float &e);
+    static void set_machine_position_mm(const_float_t a, const_float_t b, const_float_t c, const_float_t e);
     FORCE_INLINE static void set_machine_position_mm(const abce_pos_t &abce) { set_machine_position_mm(abce.a, abce.b, abce.c, abce.e); }
 
     /**
      * Get an axis position according to stepper position(s)
      * For CORE machines apply translation from ABC to XYZ.
      */
     static float get_axis_position_mm(const AxisEnum axis);
 
     static inline abce_pos_t get_axis_positions_mm() {
       const abce_pos_t out = {
@@ -950,77 +950,77 @@ class Planner {
     /**
      * Get the index of the next / previous block in the ring buffer
      */
     static constexpr uint8_t next_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index + 1); }
     static constexpr uint8_t prev_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index - 1); }
 
     /**
      * Calculate the distance (not time) it takes to accelerate
      * from initial_rate to target_rate using the given acceleration:
      */
-    static float estimate_acceleration_distance(const float &initial_rate, const float &target_rate, const float &accel) {
+    static float estimate_acceleration_distance(const_float_t initial_rate, const_float_t target_rate, const_float_t accel) {
       if (accel == 0) return 0; // accel was 0, set acceleration distance to 0
       return (sq(target_rate) - sq(initial_rate)) / (accel * 2);
     }
 
     /**
      * Return the point at which you must start braking (at the rate of -'accel') if
      * you start at 'initial_rate', accelerate (until reaching the point), and want to end at
      * 'final_rate' after traveling 'distance'.
      *
      * This is used to compute the intersection point between acceleration and deceleration
      * in cases where the "trapezoid" has no plateau (i.e., never reaches maximum speed)
      */
-    static float intersection_distance(const float &initial_rate, const float &final_rate, const float &accel, const float &distance) {
+    static float intersection_distance(const_float_t initial_rate, const_float_t final_rate, const_float_t accel, const_float_t distance) {
       if (accel == 0) return 0; // accel was 0, set intersection distance to 0
       return (accel * 2 * distance - sq(initial_rate) + sq(final_rate)) / (accel * 4);
     }
 
     /**
      * Calculate the maximum allowable speed squared at this point, in order
      * to reach 'target_velocity_sqr' using 'acceleration' within a given
      * 'distance'.
      */
-    static float max_allowable_speed_sqr(const float &accel, const float &target_velocity_sqr, const float &distance) {
+    static float max_allowable_speed_sqr(const_float_t accel, const_float_t target_velocity_sqr, const_float_t distance) {
       return target_velocity_sqr - 2 * accel * distance;
     }
 
     #if ENABLED(S_CURVE_ACCELERATION)
       /**
        * Calculate the speed reached given initial speed, acceleration and distance
        */
-      static float final_speed(const float &initial_velocity, const float &accel, const float &distance) {
+      static float final_speed(const_float_t initial_velocity, const_float_t accel, const_float_t distance) {
         return SQRT(sq(initial_velocity) + 2 * accel * distance);
       }
     #endif
 
-    static void calculate_trapezoid_for_block(block_t * const block, const float &entry_factor, const float &exit_factor);
+    static void calculate_trapezoid_for_block(block_t * const block, const_float_t entry_factor, const_float_t exit_factor);
 
     static void reverse_pass_kernel(block_t * const current, const block_t * const next);
     static void forward_pass_kernel(const block_t * const previous, block_t * const current, uint8_t block_index);
 
     static void reverse_pass();
     static void forward_pass();
 
     static void recalculate_trapezoids();
 
     static void recalculate();
 
     #if HAS_JUNCTION_DEVIATION
 
       FORCE_INLINE static void normalize_junction_vector(xyze_float_t &vector) {
         float magnitude_sq = 0;
         LOOP_XYZE(idx) if (vector[idx]) magnitude_sq += sq(vector[idx]);
         vector *= RSQRT(magnitude_sq);
       }
 
-      FORCE_INLINE static float limit_value_by_axis_maximum(const float &max_value, xyze_float_t &unit_vec) {
+      FORCE_INLINE static float limit_value_by_axis_maximum(const_float_t max_value, xyze_float_t &unit_vec) {
         float limit_value = max_value;
         LOOP_XYZE(idx) {
           if (unit_vec[idx]) {
             if (limit_value * ABS(unit_vec[idx]) > settings.max_acceleration_mm_per_s2[idx])
               limit_value = ABS(settings.max_acceleration_mm_per_s2[idx] / unit_vec[idx]);
           }
         }
         return limit_value;
       }
 

commit 3b73b115ca9366f0155986b717d4c85c31ed2f80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 29 20:36:37 2021 -0500

    Apply pointer formatting

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index da9e202cdf..768bf29e2f 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -986,24 +986,24 @@ class Planner {
 
     #if ENABLED(S_CURVE_ACCELERATION)
       /**
        * Calculate the speed reached given initial speed, acceleration and distance
        */
       static float final_speed(const float &initial_velocity, const float &accel, const float &distance) {
         return SQRT(sq(initial_velocity) + 2 * accel * distance);
       }
     #endif
 
-    static void calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor);
+    static void calculate_trapezoid_for_block(block_t * const block, const float &entry_factor, const float &exit_factor);
 
-    static void reverse_pass_kernel(block_t* const current, const block_t * const next);
-    static void forward_pass_kernel(const block_t * const previous, block_t* const current, uint8_t block_index);
+    static void reverse_pass_kernel(block_t * const current, const block_t * const next);
+    static void forward_pass_kernel(const block_t * const previous, block_t * const current, uint8_t block_index);
 
     static void reverse_pass();
     static void forward_pass();
 
     static void recalculate_trapezoids();
 
     static void recalculate();
 
     #if HAS_JUNCTION_DEVIATION
 

commit 30e7e2c2766d7dbbe0144344287994f1969dfadd
Author: Martijn Bosgraaf <drywfiltiarn+github@gmail.com>
Date:   Wed Mar 24 18:21:11 2021 +0100

    Extend M106/M107 for better laser module support (#16082)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 24c814e851..da9e202cdf 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -95,32 +95,42 @@ enum BlockFlagBit : char {
   // The block is segment 2+ of a longer move
   BLOCK_BIT_CONTINUED,
 
   // Sync the stepper counts from the block
   BLOCK_BIT_SYNC_POSITION
 
   // Direct stepping page
   #if ENABLED(DIRECT_STEPPING)
     , BLOCK_BIT_IS_PAGE
   #endif
+
+  // Sync the fan speeds from the block
+  #if ENABLED(LASER_SYNCHRONOUS_M106_M107)
+    , BLOCK_BIT_SYNC_FANS
+  #endif
 };
 
 enum BlockFlag : char {
     BLOCK_FLAG_RECALCULATE          = _BV(BLOCK_BIT_RECALCULATE)
   , BLOCK_FLAG_NOMINAL_LENGTH       = _BV(BLOCK_BIT_NOMINAL_LENGTH)
   , BLOCK_FLAG_CONTINUED            = _BV(BLOCK_BIT_CONTINUED)
   , BLOCK_FLAG_SYNC_POSITION        = _BV(BLOCK_BIT_SYNC_POSITION)
   #if ENABLED(DIRECT_STEPPING)
     , BLOCK_FLAG_IS_PAGE            = _BV(BLOCK_BIT_IS_PAGE)
   #endif
+  #if ENABLED(LASER_SYNCHRONOUS_M106_M107)
+    , BLOCK_FLAG_SYNC_FANS          = _BV(BLOCK_BIT_SYNC_FANS)
+  #endif
 };
 
+#define BLOCK_MASK_SYNC ( BLOCK_FLAG_SYNC_POSITION | TERN0(LASER_SYNCHRONOUS_M106_M107, BLOCK_FLAG_SYNC_FANS) )
+
 #if ENABLED(LASER_POWER_INLINE)
 
   typedef struct {
     bool isPlanned:1;
     bool isEnabled:1;
     bool dir:1;
     bool Reserved:6;
   } power_status_t;
 
   typedef struct {
@@ -492,20 +502,30 @@ class Planner {
       static inline void set_flow(const uint8_t e, const int16_t flow) {
         flow_percentage[e] = flow;
         refresh_e_factor(e);
       }
 
     #endif
 
     // Manage fans, paste pressure, etc.
     static void check_axes_activity();
 
+    // Apply fan speeds
+    #if HAS_FAN
+      static void sync_fan_speeds(uint8_t (&fan_speed)[FAN_COUNT]);
+      #if FAN_KICKSTART_TIME
+        static void kickstart_fan(uint8_t (&fan_speed)[FAN_COUNT], const millis_t &ms, const uint8_t f);
+      #else
+        FORCE_INLINE static void kickstart_fan(uint8_t (&)[FAN_COUNT], const millis_t &, const uint8_t) {}
+      #endif
+    #endif
+
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       void apply_filament_width_sensor(const int8_t encoded_ratio);
 
       static inline float volumetric_percent(const bool vol) {
         return 100.0f * (vol
             ? volumetric_area_nominal / volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
             : volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
         );
       }
     #endif
@@ -714,23 +734,26 @@ class Planner {
         , const xyze_pos_t &target_float
       #endif
       #if HAS_DIST_MM_ARG
         , const xyze_float_t &cart_dist_mm
       #endif
       , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
     /**
      * Planner::buffer_sync_block
-     * Add a block to the buffer that just updates the position
+     * Add a block to the buffer that just updates the position or in
+     * case of LASER_SYNCHRONOUS_M106_M107 the fan pwm
      */
-    static void buffer_sync_block();
+    static void buffer_sync_block(
+      TERN_(LASER_SYNCHRONOUS_M106_M107, uint8_t sync_flag=BLOCK_FLAG_SYNC_POSITION)
+    );
 
   #if IS_KINEMATIC
     private:
 
       // Allow do_homing_move to access internal functions, such as buffer_segment.
       friend void do_homing_move(const AxisEnum, const float, const feedRate_t, const bool);
   #endif
 
     /**
      * Planner::buffer_segment

commit 2d2291d00eab6159de24eb7ff74001b1d6dd29e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 24 05:40:28 2021 -0500

    More IntelliSense-friendly declarations

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 769967d4a6..24c814e851 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -163,21 +163,23 @@ typedef struct block_t {
     abce_long_t position;                   // New position to force when this sync block is executed
   };
   uint32_t step_event_count;                // The number of step events required to complete this block
 
   #if HAS_MULTI_EXTRUDER
     uint8_t extruder;                       // The extruder to move (if E move)
   #else
     static constexpr uint8_t extruder = 0;
   #endif
 
-  TERN_(MIXING_EXTRUDER, MIXER_BLOCK_FIELD); // Normalized color for the mixing steppers
+  #if ENABLED(MIXING_EXTRUDER)
+    mixer_comp_t b_color[MIXING_STEPPERS];  // Normalized color for the mixing steppers
+  #endif
 
   // Settings for the trapezoid generator
   uint32_t accelerate_until,                // The index of the step event on which to stop acceleration
            decelerate_after;                // The index of the step event on which to start decelerating
 
   #if ENABLED(S_CURVE_ACCELERATION)
     uint32_t cruise_rate,                   // The actual cruise rate to use, between end of the acceleration phase and start of deceleration phase
              acceleration_time,             // Acceleration time and deceleration time in STEP timer counts
              deceleration_time,
              acceleration_time_inverse,     // Inverse of acceleration and deceleration periods, expressed as integer. Scale depends on CPU being used

commit e5ff55a1be7646b6159e6dedac50bfbe57e6dfa0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 24 04:11:43 2021 -0500

    Add typedef celsius_t (#21374)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 7ebba1e342..769967d4a6 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -889,21 +889,22 @@ class Planner {
       if (has_blocks_queued())
         block_buffer_tail = next_block_index(block_buffer_tail);
     }
 
     #if HAS_WIRED_LCD
       static uint16_t block_buffer_runtime();
       static void clear_block_buffer_runtime();
     #endif
 
     #if ENABLED(AUTOTEMP)
-      static float autotemp_min, autotemp_max, autotemp_factor;
+      static celsius_t autotemp_min, autotemp_max;
+      static float autotemp_factor;
       static bool autotemp_enabled;
       static void autotemp_update();
       static void autotemp_M104_M109();
       static void getHighESpeed();
     #endif
 
     #if HAS_LINEAR_E_JERK
       FORCE_INLINE static void recalculate_max_e_jerk() {
         const float prop = junction_deviation_mm * SQRT(0.5) / (1.0f - SQRT(0.5));
         LOOP_L_N(i, EXTRUDERS)

commit ad907a51e245a908024ff2736f95455d89e9571d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Mar 18 00:11:06 2021 -0500

    Followup to planner cleanup

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index a7aabd9d65..7ebba1e342 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -463,28 +463,28 @@ class Planner {
     // Recalculate steps/s^2 accelerations based on mm/s^2 settings
     static void reset_acceleration_rates();
 
     /**
      * Recalculate 'position' and 'steps_to_mm'.
      * Must be called whenever settings.axis_steps_per_mm changes!
      */
     static void refresh_positioning();
 
     // For an axis set the Maximum Acceleration in mm/s^2
-    static void set_max_acceleration(const uint8_t axis, const float &inMaxAccelMMS2);
+    static void set_max_acceleration(const uint8_t axis, float inMaxAccelMMS2);
 
     // For an axis set the Maximum Feedrate in mm/s
-    static void set_max_feedrate(const uint8_t axis, const float &inMaxFeedrateMMS);
+    static void set_max_feedrate(const uint8_t axis, float inMaxFeedrateMMS);
 
     // For an axis set the Maximum Jerk (instant change) in mm/s
     #if HAS_CLASSIC_JERK
-      static void set_max_jerk(const AxisEnum axis, const float &inMaxJerkMMS);
+      static void set_max_jerk(const AxisEnum axis, float inMaxJerkMMS);
     #else
       static inline void set_max_jerk(const AxisEnum, const float&) {}
     #endif
 
     #if EXTRUDERS
       FORCE_INLINE static void refresh_e_factor(const uint8_t e) {
         e_factor[e] = flow_percentage[e] * 0.01f * TERN(NO_VOLUMETRICS, 1.0f, volumetric_multiplier[e]);
       }
 
       static inline void set_flow(const uint8_t e, const int16_t flow) {

commit 9823a37362c86f8f722c01af2147075d70234ada
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 16 15:12:28 2021 -0500

    E1+ Autotemp and Planner comments

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index b7ff0ee932..a7aabd9d65 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -453,26 +453,41 @@ class Planner {
      */
 
     Planner();
 
     void init();
 
     /**
      * Static (class) Methods
      */
 
+    // Recalculate steps/s^2 accelerations based on mm/s^2 settings
     static void reset_acceleration_rates();
+
+    /**
+     * Recalculate 'position' and 'steps_to_mm'.
+     * Must be called whenever settings.axis_steps_per_mm changes!
+     */
     static void refresh_positioning();
-    static void set_max_acceleration(const uint8_t axis, float targetValue);
-    static void set_max_feedrate(const uint8_t axis, float targetValue);
-    static void set_max_jerk(const AxisEnum axis, float targetValue);
 
+    // For an axis set the Maximum Acceleration in mm/s^2
+    static void set_max_acceleration(const uint8_t axis, const float &inMaxAccelMMS2);
+
+    // For an axis set the Maximum Feedrate in mm/s
+    static void set_max_feedrate(const uint8_t axis, const float &inMaxFeedrateMMS);
+
+    // For an axis set the Maximum Jerk (instant change) in mm/s
+    #if HAS_CLASSIC_JERK
+      static void set_max_jerk(const AxisEnum axis, const float &inMaxJerkMMS);
+    #else
+      static inline void set_max_jerk(const AxisEnum, const float&) {}
+    #endif
 
     #if EXTRUDERS
       FORCE_INLINE static void refresh_e_factor(const uint8_t e) {
         e_factor[e] = flow_percentage[e] * 0.01f * TERN(NO_VOLUMETRICS, 1.0f, volumetric_multiplier[e]);
       }
 
       static inline void set_flow(const uint8_t e, const int16_t flow) {
         flow_percentage[e] = flow;
         refresh_e_factor(e);
       }
@@ -876,35 +891,43 @@ class Planner {
     }
 
     #if HAS_WIRED_LCD
       static uint16_t block_buffer_runtime();
       static void clear_block_buffer_runtime();
     #endif
 
     #if ENABLED(AUTOTEMP)
       static float autotemp_min, autotemp_max, autotemp_factor;
       static bool autotemp_enabled;
-      static void getHighESpeed();
-      static void autotemp_M104_M109();
       static void autotemp_update();
+      static void autotemp_M104_M109();
+      static void getHighESpeed();
     #endif
 
     #if HAS_LINEAR_E_JERK
       FORCE_INLINE static void recalculate_max_e_jerk() {
         const float prop = junction_deviation_mm * SQRT(0.5) / (1.0f - SQRT(0.5));
         LOOP_L_N(i, EXTRUDERS)
           max_e_jerk[E_INDEX_N(i)] = SQRT(prop * settings.max_acceleration_mm_per_s2[E_INDEX_N(i)]);
       }
     #endif
 
   private:
 
+    #if ENABLED(AUTOTEMP)
+      #if ENABLED(AUTOTEMP_PROPORTIONAL)
+        static void _autotemp_update_from_hotend();
+      #else
+        static inline void _autotemp_update_from_hotend() {}
+      #endif
+    #endif
+
     /**
      * Get the index of the next / previous block in the ring buffer
      */
     static constexpr uint8_t next_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index + 1); }
     static constexpr uint8_t prev_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index - 1); }
 
     /**
      * Calculate the distance (not time) it takes to accelerate
      * from initial_rate to target_rate using the given acceleration:
      */

commit 468e437390afdb1de7059e7f9049d0b30c312024
Author: deirdreobyrne <deirdre.dub@gmail.com>
Date:   Thu Feb 25 10:49:34 2021 +0000

    Allow Zero Endstops (e.g., for CNC) (#21120)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index cd906c5d13..b7ff0ee932 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -557,35 +557,35 @@ class Planner {
 
       FORCE_INLINE static float fade_scaling_factor_for_z(const float&) { return 1; }
 
       FORCE_INLINE static bool leveling_active_at_z(const float&) { return true; }
 
     #endif
 
     #if ENABLED(SKEW_CORRECTION)
 
       FORCE_INLINE static void skew(float &cx, float &cy, const float &cz) {
-        if (WITHIN(cx, X_MIN_POS + 1, X_MAX_POS) && WITHIN(cy, Y_MIN_POS + 1, Y_MAX_POS)) {
+        if (COORDINATE_OKAY(cx, X_MIN_POS + 1, X_MAX_POS) && COORDINATE_OKAY(cy, Y_MIN_POS + 1, Y_MAX_POS)) {
           const float sx = cx - cy * skew_factor.xy - cz * (skew_factor.xz - (skew_factor.xy * skew_factor.yz)),
                       sy = cy - cz * skew_factor.yz;
-          if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {
+          if (COORDINATE_OKAY(sx, X_MIN_POS, X_MAX_POS) && COORDINATE_OKAY(sy, Y_MIN_POS, Y_MAX_POS)) {
             cx = sx; cy = sy;
           }
         }
       }
       FORCE_INLINE static void skew(xyz_pos_t &raw) { skew(raw.x, raw.y, raw.z); }
 
       FORCE_INLINE static void unskew(float &cx, float &cy, const float &cz) {
-        if (WITHIN(cx, X_MIN_POS, X_MAX_POS) && WITHIN(cy, Y_MIN_POS, Y_MAX_POS)) {
+        if (COORDINATE_OKAY(cx, X_MIN_POS, X_MAX_POS) && COORDINATE_OKAY(cy, Y_MIN_POS, Y_MAX_POS)) {
           const float sx = cx + cy * skew_factor.xy + cz * skew_factor.xz,
                       sy = cy + cz * skew_factor.yz;
-          if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {
+          if (COORDINATE_OKAY(sx, X_MIN_POS, X_MAX_POS) && COORDINATE_OKAY(sy, Y_MIN_POS, Y_MAX_POS)) {
             cx = sx; cy = sy;
           }
         }
       }
       FORCE_INLINE static void unskew(xyz_pos_t &raw) { unskew(raw.x, raw.y, raw.z); }
 
     #endif // SKEW_CORRECTION
 
     #if HAS_LEVELING
       /**

commit 55d1938977e310648602e1b23e9e22e8fd6838b5
Author: FanDjango <51046875+FanDjango@users.noreply.github.com>
Date:   Tue Jan 5 03:32:52 2021 +0100

    Defer "quiet probing" till the last Z bump (#20610)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 5050f060b0..cd906c5d13 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -705,21 +705,21 @@ class Planner {
     /**
      * Planner::buffer_sync_block
      * Add a block to the buffer that just updates the position
      */
     static void buffer_sync_block();
 
   #if IS_KINEMATIC
     private:
 
       // Allow do_homing_move to access internal functions, such as buffer_segment.
-      friend void do_homing_move(const AxisEnum, const float, const feedRate_t);
+      friend void do_homing_move(const AxisEnum, const float, const feedRate_t, const bool);
   #endif
 
     /**
      * Planner::buffer_segment
      *
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e     - target positions in mm and/or degrees

commit 20b3af1cc2c4a5e8505d1aae3419ab9418ed88ab
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Dec 16 22:18:40 2020 -0600

    Use homing_feedrate function

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index ac30938f2a..5050f060b0 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -971,13 +971,13 @@ class Planner {
             if (limit_value * ABS(unit_vec[idx]) > settings.max_acceleration_mm_per_s2[idx])
               limit_value = ABS(settings.max_acceleration_mm_per_s2[idx] / unit_vec[idx]);
           }
         }
         return limit_value;
       }
 
     #endif // !CLASSIC_JERK
 };
 
-#define PLANNER_XY_FEEDRATE() (_MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]))
+#define PLANNER_XY_FEEDRATE() _MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS])
 
 extern Planner planner;

commit 110e0d782f50082819101ca39ad4e38300046467
Author: FanDjango <51046875+FanDjango@users.noreply.github.com>
Date:   Mon Nov 16 21:56:05 2020 +0100

    Guards for large BLOCK_BUFFER_SIZE (>=128) (#20130)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index c4e11490b1..ac30938f2a 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -280,20 +280,24 @@ typedef struct {
       float xz, yz;
     #else
       const float xz = XZ_SKEW_FACTOR, yz = YZ_SKEW_FACTOR;
     #endif
   #else
     const float xy = XY_SKEW_FACTOR,
                 xz = XZ_SKEW_FACTOR, yz = YZ_SKEW_FACTOR;
   #endif
 } skew_factor_t;
 
+#if ENABLED(DISABLE_INACTIVE_EXTRUDER)
+  typedef IF<(BLOCK_BUFFER_SIZE > 64), uint16_t, uint8_t>::type last_move_t;
+#endif
+
 class Planner {
   public:
 
     /**
      * The move buffer, calculated in stepper steps
      *
      * block_buffer is a ring buffer...
      *
      *             head,tail : indexes for write,read
      *            head==tail : the buffer is empty
@@ -428,21 +432,21 @@ class Planner {
      * Limit where 64bit math is necessary for acceleration calculation
      */
     static uint32_t cutoff_long;
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       static float last_fade_z;
     #endif
 
     #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
        // Counters to manage disabling inactive extruders
-      static uint8_t g_uc_extruder_last_move[EXTRUDERS];
+      static last_move_t g_uc_extruder_last_move[EXTRUDERS];
     #endif
 
     #if HAS_WIRED_LCD
       volatile static uint32_t block_buffer_runtime_us; // Theoretical block buffer runtime in ¬µs
     #endif
 
   public:
 
     /**
      * Instance Methods

commit c2c6a679ea4bdf48ce1800a8831fcec36c09ce53
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 28 01:13:27 2020 -0500

    Rename LCD conditionals (#19533)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 660d9ad5aa..c4e11490b1 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -211,21 +211,21 @@ typedef struct block_t {
   #endif
 
   #if HAS_FAN
     uint8_t fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
     uint8_t valve_pressure, e_to_p_pressure;
   #endif
 
-  #if HAS_SPI_LCD
+  #if HAS_WIRED_LCD
     uint32_t segment_time_us;
   #endif
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     uint32_t sdpos;
   #endif
 
   #if ENABLED(LASER_POWER_INLINE)
     block_laser_t laser;
   #endif
@@ -431,21 +431,21 @@ class Planner {
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       static float last_fade_z;
     #endif
 
     #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
        // Counters to manage disabling inactive extruders
       static uint8_t g_uc_extruder_last_move[EXTRUDERS];
     #endif
 
-    #if HAS_SPI_LCD
+    #if HAS_WIRED_LCD
       volatile static uint32_t block_buffer_runtime_us; // Theoretical block buffer runtime in ¬µs
     #endif
 
   public:
 
     /**
      * Instance Methods
      */
 
     Planner();
@@ -864,21 +864,21 @@ class Planner {
 
     /**
      * "Release" the current block so its slot can be reused.
      * Called when the current block is no longer needed.
      */
     FORCE_INLINE static void release_current_block() {
       if (has_blocks_queued())
         block_buffer_tail = next_block_index(block_buffer_tail);
     }
 
-    #if HAS_SPI_LCD
+    #if HAS_WIRED_LCD
       static uint16_t block_buffer_runtime();
       static void clear_block_buffer_runtime();
     #endif
 
     #if ENABLED(AUTOTEMP)
       static float autotemp_min, autotemp_max, autotemp_factor;
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
       static void autotemp_update();

commit 76d8d1742c1d4a1efe0fd6c0645d3fc656bfd0b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 20 18:29:08 2020 -0500

    Add multi-extruder condition

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index f3a3a0e0fc..660d9ad5aa 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -157,21 +157,21 @@ typedef struct block_t {
         max_entry_speed_sqr,                // Maximum allowable junction entry speed in (mm/sec)^2
         millimeters,                        // The total travel of this block in mm
         acceleration;                       // acceleration mm/sec^2
 
   union {
     abce_ulong_t steps;                     // Step count along each axis
     abce_long_t position;                   // New position to force when this sync block is executed
   };
   uint32_t step_event_count;                // The number of step events required to complete this block
 
-  #if EXTRUDERS > 1
+  #if HAS_MULTI_EXTRUDER
     uint8_t extruder;                       // The extruder to move (if E move)
   #else
     static constexpr uint8_t extruder = 0;
   #endif
 
   TERN_(MIXING_EXTRUDER, MIXER_BLOCK_FIELD); // Normalized color for the mixing steppers
 
   // Settings for the trapezoid generator
   uint32_t accelerate_until,                // The index of the step event on which to stop acceleration
            decelerate_after;                // The index of the step event on which to start decelerating

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 07bead3caf..f3a3a0e0fc 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 #pragma once
 
 /**
  * planner.h
  *
  * Buffer movement commands and manage the acceleration profile plan
  *
  * Derived from Grbl

commit a4b46eaf8f45ef9f8c212b9f17692682cae08aaa
Author: XDA-Bam <1209896+XDA-Bam@users.noreply.github.com>
Date:   Tue Jun 16 01:54:00 2020 +0200

    Add JD_HANDLE_SMALL_SEGMENTS option (#18316)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 33b5da9fe9..07bead3caf 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -25,21 +25,21 @@
  * planner.h
  *
  * Buffer movement commands and manage the acceleration profile plan
  *
  * Derived from Grbl
  * Copyright (c) 2009-2011 Simen Svale Skogsrud
  */
 
 #include "../MarlinCore.h"
 
-#if HAS_JUNCTION_DEVIATION
+#if ENABLED(JD_HANDLE_SMALL_SEGMENTS)
   // Enable this option for perfect accuracy but maximum
   // computation. Should be fine on ARM processors.
   //#define JD_USE_MATH_ACOS
 
   // Disable this option to save 120 bytes of PROGMEM,
   // but incur increased computation and a reduction
   // in accuracy.
   #define JD_USE_LOOKUP_TABLE
 #endif
 

commit aea60d94507da282c182a065c226734bc83f4d52
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 15 18:11:19 2020 -0500

    Clean up trailing spaces

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 4086a8a62a..33b5da9fe9 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -486,21 +486,21 @@ class Planner {
             ? volumetric_area_nominal / volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
             : volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
         );
       }
     #endif
 
     #if DISABLED(NO_VOLUMETRICS)
 
       // Update multipliers based on new diameter measurements
       static void calculate_volumetric_multipliers();
-  
+
       #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
         // Update pre calculated extruder feedrate limits based on volumetric values
         static void calculate_volumetric_extruder_limit(const uint8_t e);
         static void calculate_volumetric_extruder_limits();
       #endif
 
       FORCE_INLINE static void set_filament_size(const uint8_t e, const float &v) {
         filament_size[e] = v;
         if (v > 0) volumetric_area_nominal = CIRCLE_AREA(v * 0.5); //TODO: should it be per extruder
         // make sure all extruders have some sane value for the filament size

commit bac760207c3e85b9ac97a36c37aeb4ad601102a3
Author: MoellerDi <MoellerDi@users.noreply.github.com>
Date:   Mon Jun 8 10:24:46 2020 +0200

    Add volumetric extrusion limit (#17017)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 228b3c9a1c..4086a8a62a 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -326,20 +326,25 @@ class Planner {
       static float e_factor[EXTRUDERS];             // The flow percentage and volumetric multiplier combine to scale E movement
     #endif
 
     #if DISABLED(NO_VOLUMETRICS)
       static float filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
                    volumetric_area_nominal,           // Nominal cross-sectional area
                    volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                       // May be auto-adjusted by a filament width sensor
     #endif
 
+    #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+      static float volumetric_extruder_limit[EXTRUDERS],          // Maximum mm^3/sec the extruder can handle
+                   volumetric_extruder_feedrate_limit[EXTRUDERS]; // Feedrate limit (mm/s) calculated from volume limit
+    #endif
+
     static planner_settings_t settings;
 
     #if ENABLED(LASER_POWER_INLINE)
       static laser_state_t laser_inline;
     #endif
 
     static uint32_t max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
     static float steps_to_mm[XYZE_N];           // Millimeters per step
 
     #if HAS_JUNCTION_DEVIATION
@@ -466,45 +471,59 @@ class Planner {
       static inline void set_flow(const uint8_t e, const int16_t flow) {
         flow_percentage[e] = flow;
         refresh_e_factor(e);
       }
 
     #endif
 
     // Manage fans, paste pressure, etc.
     static void check_axes_activity();
 
-    // Update multipliers based on new diameter measurements
-    static void calculate_volumetric_multipliers();
-
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       void apply_filament_width_sensor(const int8_t encoded_ratio);
 
       static inline float volumetric_percent(const bool vol) {
         return 100.0f * (vol
             ? volumetric_area_nominal / volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
             : volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
         );
       }
     #endif
 
     #if DISABLED(NO_VOLUMETRICS)
 
+      // Update multipliers based on new diameter measurements
+      static void calculate_volumetric_multipliers();
+  
+      #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+        // Update pre calculated extruder feedrate limits based on volumetric values
+        static void calculate_volumetric_extruder_limit(const uint8_t e);
+        static void calculate_volumetric_extruder_limits();
+      #endif
+
       FORCE_INLINE static void set_filament_size(const uint8_t e, const float &v) {
         filament_size[e] = v;
+        if (v > 0) volumetric_area_nominal = CIRCLE_AREA(v * 0.5); //TODO: should it be per extruder
         // make sure all extruders have some sane value for the filament size
         LOOP_L_N(i, COUNT(filament_size))
           if (!filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;
       }
 
     #endif
 
+    #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+      FORCE_INLINE static void set_volumetric_extruder_limit(const uint8_t e, const float &v) {
+        volumetric_extruder_limit[e] = v;
+        calculate_volumetric_extruder_limit(e);
+      }
+    #endif
+
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
 
       /**
        * Get the Z leveling fade factor based on the given Z height,
        * re-calculating only when needed.
        *
        *  Returns 1.0 if planner.z_fade_height is 0.0.
        *  Returns 0.0 if Z is past the specified 'Fade Height'.
        */
       static inline float fade_scaling_factor_for_z(const float &rz) {

commit eda2fd8dbea69cb8f571f2992cb11334b2cb7a2f
Author: Luu Lac <45380455+shitcreek@users.noreply.github.com>
Date:   Mon Jun 8 00:47:31 2020 -0500

    Improvements for Laser / Spindle (#17661)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 6c5218cd6f..228b3c9a1c 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -110,22 +110,29 @@ enum BlockFlag : char {
   , BLOCK_FLAG_CONTINUED            = _BV(BLOCK_BIT_CONTINUED)
   , BLOCK_FLAG_SYNC_POSITION        = _BV(BLOCK_BIT_SYNC_POSITION)
   #if ENABLED(DIRECT_STEPPING)
     , BLOCK_FLAG_IS_PAGE            = _BV(BLOCK_BIT_IS_PAGE)
   #endif
 };
 
 #if ENABLED(LASER_POWER_INLINE)
 
   typedef struct {
-    uint8_t status,           // See planner settings for meaning
-            power;            // Ditto; When in trapezoid mode this is nominal power
+    bool isPlanned:1;
+    bool isEnabled:1;
+    bool dir:1;
+    bool Reserved:6;
+  } power_status_t;
+
+  typedef struct {
+    power_status_t status;    // See planner settings for meaning
+    uint8_t power;            // Ditto; When in trapezoid mode this is nominal power
     #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
       uint8_t   power_entry;  // Entry power for the laser
       #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
         uint8_t   power_exit; // Exit power for the laser
         uint32_t  entry_per,  // Steps per power increment (to avoid floats in stepper calcs)
                   exit_per;   // Steps per power decrement
       #endif
     #endif
   } block_laser_t;
 
@@ -227,32 +234,29 @@ typedef struct block_t {
 
 #if ANY(LIN_ADVANCE, SCARA_FEEDRATE_SCALING, GRADIENT_MIX, LCD_SHOW_E_TOTAL)
   #define HAS_POSITION_FLOAT 1
 #endif
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 #if ENABLED(LASER_POWER_INLINE)
   typedef struct {
     /**
-     * Laser status bitmask; most bits are unused;
-     *  0: Planner buffer enable
-     *  1: Laser enable
-     *  2: Reserved for direction
+     * Laser status flags
      */
-    uint8_t status;
+    power_status_t status;
     /**
      * Laser power: 0 or 255 in case of PWM-less laser,
-     * or the OCR value;
+     * or the OCR (oscillator count register) value;
      *
-     * Using OCR instead of raw power,
-     * as it avoids floating points during move loop
+     * Using OCR instead of raw power, because it avoids
+     * floating point operations during the move loop.
      */
     uint8_t power;
   } laser_state_t;
 #endif
 
 typedef struct {
    uint32_t max_acceleration_mm_per_s2[XYZE_N], // (mm/s^2) M201 XYZE
             min_segment_time_us;                // (¬µs) M205 B
       float axis_steps_per_mm[XYZE_N];          // (steps) M92 XYZE - Steps per millimeter
  feedRate_t max_feedrate_mm_s[XYZE_N];          // (mm/s) M203 XYZE - Max speeds
@@ -325,21 +329,21 @@ class Planner {
     #if DISABLED(NO_VOLUMETRICS)
       static float filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
                    volumetric_area_nominal,           // Nominal cross-sectional area
                    volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                       // May be auto-adjusted by a filament width sensor
     #endif
 
     static planner_settings_t settings;
 
     #if ENABLED(LASER_POWER_INLINE)
-      static laser_state_t laser;
+      static laser_state_t laser_inline;
     #endif
 
     static uint32_t max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
     static float steps_to_mm[XYZE_N];           // Millimeters per step
 
     #if HAS_JUNCTION_DEVIATION
       static float junction_deviation_mm;       // (mm) M205 J
       #if HAS_LINEAR_E_JERK
         static float max_e_jerk[DISTINCT_E];    // Calculated from junction_deviation_mm
       #endif

commit 181739d0d1a54ab01c4f97678f04ae43ebb1facd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 12 00:09:18 2020 -0500

    Move inline laser state to fix EEPROM error

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 0314758a1d..6c5218cd6f 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -241,36 +241,33 @@ typedef struct block_t {
      */
     uint8_t status;
     /**
      * Laser power: 0 or 255 in case of PWM-less laser,
      * or the OCR value;
      *
      * Using OCR instead of raw power,
      * as it avoids floating points during move loop
      */
     uint8_t power;
-  } settings_laser_t;
+  } laser_state_t;
 #endif
 
 typedef struct {
    uint32_t max_acceleration_mm_per_s2[XYZE_N], // (mm/s^2) M201 XYZE
             min_segment_time_us;                // (¬µs) M205 B
       float axis_steps_per_mm[XYZE_N];          // (steps) M92 XYZE - Steps per millimeter
  feedRate_t max_feedrate_mm_s[XYZE_N];          // (mm/s) M203 XYZE - Max speeds
       float acceleration,                       // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
             retract_acceleration,               // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
             travel_acceleration;                // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
  feedRate_t min_feedrate_mm_s,                  // (mm/s) M205 S - Minimum linear feedrate
             min_travel_feedrate_mm_s;           // (mm/s) M205 T - Minimum travel feedrate
-  #if ENABLED(LASER_POWER_INLINE)
-    settings_laser_t laser;
-  #endif
 } planner_settings_t;
 
 #if DISABLED(SKEW_CORRECTION)
   #define XY_SKEW_FACTOR 0
   #define XZ_SKEW_FACTOR 0
   #define YZ_SKEW_FACTOR 0
 #endif
 
 typedef struct {
   #if ENABLED(SKEW_CORRECTION_GCODE)
@@ -327,20 +324,24 @@ class Planner {
 
     #if DISABLED(NO_VOLUMETRICS)
       static float filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
                    volumetric_area_nominal,           // Nominal cross-sectional area
                    volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                       // May be auto-adjusted by a filament width sensor
     #endif
 
     static planner_settings_t settings;
 
+    #if ENABLED(LASER_POWER_INLINE)
+      static laser_state_t laser;
+    #endif
+
     static uint32_t max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
     static float steps_to_mm[XYZE_N];           // Millimeters per step
 
     #if HAS_JUNCTION_DEVIATION
       static float junction_deviation_mm;       // (mm) M205 J
       #if HAS_LINEAR_E_JERK
         static float max_e_jerk[DISTINCT_E];    // Calculated from junction_deviation_mm
       #endif
     #endif
 

commit 8a22ef0c83a94f742be39005f259226e005ded2d
Author: Colin Godsey <crgodsey@gmail.com>
Date:   Mon May 11 18:22:41 2020 -0600

    G6 Direct Stepping (#17853)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 60dbb612c7..0314758a1d 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -59,20 +59,27 @@
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"
 #endif
 
 #if HAS_CUTTER
   #include "../feature/spindle_laser_types.h"
 #endif
 
+#if ENABLED(DIRECT_STEPPING)
+  #include "../feature/direct_stepping.h"
+  #define IS_PAGE(B) TEST(B->flag, BLOCK_BIT_IS_PAGE)
+#else
+  #define IS_PAGE(B) false
+#endif
+
 // Feedrate for manual moves
 #ifdef MANUAL_FEEDRATE
   constexpr xyze_feedrate_t _mf = MANUAL_FEEDRATE,
                             manual_feedrate_mm_s { _mf.x / 60.0f, _mf.y / 60.0f, _mf.z / 60.0f, _mf.e / 60.0f };
 #endif
 
 #if IS_KINEMATIC && HAS_JUNCTION_DEVIATION
   #define HAS_DIST_MM_ARG 1
 #endif
 
@@ -83,27 +90,35 @@ enum BlockFlagBit : char {
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).
   BLOCK_BIT_NOMINAL_LENGTH,
 
   // The block is segment 2+ of a longer move
   BLOCK_BIT_CONTINUED,
 
   // Sync the stepper counts from the block
   BLOCK_BIT_SYNC_POSITION
+
+  // Direct stepping page
+  #if ENABLED(DIRECT_STEPPING)
+    , BLOCK_BIT_IS_PAGE
+  #endif
 };
 
 enum BlockFlag : char {
-  BLOCK_FLAG_RECALCULATE          = _BV(BLOCK_BIT_RECALCULATE),
-  BLOCK_FLAG_NOMINAL_LENGTH       = _BV(BLOCK_BIT_NOMINAL_LENGTH),
-  BLOCK_FLAG_CONTINUED            = _BV(BLOCK_BIT_CONTINUED),
-  BLOCK_FLAG_SYNC_POSITION        = _BV(BLOCK_BIT_SYNC_POSITION)
+    BLOCK_FLAG_RECALCULATE          = _BV(BLOCK_BIT_RECALCULATE)
+  , BLOCK_FLAG_NOMINAL_LENGTH       = _BV(BLOCK_BIT_NOMINAL_LENGTH)
+  , BLOCK_FLAG_CONTINUED            = _BV(BLOCK_BIT_CONTINUED)
+  , BLOCK_FLAG_SYNC_POSITION        = _BV(BLOCK_BIT_SYNC_POSITION)
+  #if ENABLED(DIRECT_STEPPING)
+    , BLOCK_FLAG_IS_PAGE            = _BV(BLOCK_BIT_IS_PAGE)
+  #endif
 };
 
 #if ENABLED(LASER_POWER_INLINE)
 
   typedef struct {
     uint8_t status,           // See planner settings for meaning
             power;            // Ditto; When in trapezoid mode this is nominal power
     #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
       uint8_t   power_entry;  // Entry power for the laser
       #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
@@ -173,20 +188,24 @@ typedef struct block_t {
              max_adv_steps,                 // max. advance steps to get cruising speed pressure (not always nominal_speed!)
              final_adv_steps;               // advance steps due to exit speed
     float e_D_ratio;
   #endif
 
   uint32_t nominal_rate,                    // The nominal step rate for this block in step_events/sec
            initial_rate,                    // The jerk-adjusted step rate at start of block
            final_rate,                      // The minimal rate at exit
            acceleration_steps_per_s2;       // acceleration steps/sec^2
 
+  #if ENABLED(DIRECT_STEPPING)
+    page_idx_t page_idx;                    // Page index used for direct stepping
+  #endif
+
   #if HAS_CUTTER
     cutter_power_t cutter_power;            // Power level for Spindle, Laser, etc.
   #endif
 
   #if HAS_FAN
     uint8_t fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
     uint8_t valve_pressure, e_to_p_pressure;
@@ -289,20 +308,25 @@ class Planner {
                             block_buffer_planned,   // Index of the optimally planned block
                             block_buffer_tail;      // Index of the busy block, if any
     static uint16_t cleaning_buffer_counter;        // A counter to disable queuing of blocks
     static uint8_t delay_before_delivering;         // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;                 // Respond to extruder change
     #endif
 
+    #if ENABLED(DIRECT_STEPPING)
+      static uint32_t last_page_step_rate;          // Last page step rate given
+      static xyze_bool_t last_page_dir;             // Last page direction given
+    #endif
+
     #if EXTRUDERS
       static int16_t flow_percentage[EXTRUDERS];    // Extrusion factor for each extruder
       static float e_factor[EXTRUDERS];             // The flow percentage and volumetric multiplier combine to scale E movement
     #endif
 
     #if DISABLED(NO_VOLUMETRICS)
       static float filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
                    volumetric_area_nominal,           // Nominal cross-sectional area
                    volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                       // May be auto-adjusted by a filament width sensor
@@ -719,20 +743,24 @@ class Planner {
         , const float &inv_duration=0.0
       #endif
     ) {
       return buffer_line(cart.x, cart.y, cart.z, cart.e, fr_mm_s, extruder, millimeters
         #if ENABLED(SCARA_FEEDRATE_SCALING)
           , inv_duration
         #endif
       );
     }
 
+    #if ENABLED(DIRECT_STEPPING)
+      static void buffer_page(const page_idx_t page_idx, const uint8_t extruder, const uint16_t num_steps);
+    #endif
+
     /**
      * Set the planner.position and individual stepper positions.
      * Used by G92, G28, G29, and other procedures.
      *
      * The supplied position is in the cartesian coordinate space and is
      * translated in to machine space as needed. Modifiers such as leveling
      * and skew are also applied.
      *
      * Multiplies by axis_steps_per_mm[] and does necessary conversion
      * for COREXY / COREXZ / COREYZ to set the corresponding stepper positions.
@@ -804,24 +832,24 @@ class Planner {
      * Get the current block for processing
      * and mark the block as busy.
      * Return nullptr if the buffer is empty
      * or if there is a first-block delay.
      *
      * WARNING: Called from Stepper ISR context!
      */
     static block_t* get_current_block();
 
     /**
-     * "Discard" the block and "release" the memory.
+     * "Release" the current block so its slot can be reused.
      * Called when the current block is no longer needed.
      */
-    FORCE_INLINE static void discard_current_block() {
+    FORCE_INLINE static void release_current_block() {
       if (has_blocks_queued())
         block_buffer_tail = next_block_index(block_buffer_tail);
     }
 
     #if HAS_SPI_LCD
       static uint16_t block_buffer_runtime();
       static void clear_block_buffer_runtime();
     #endif
 
     #if ENABLED(AUTOTEMP)

commit e22e0763d94a94776a33f8557dddadc3432342cf
Author: XDA-Bam <1209896+XDA-Bam@users.noreply.github.com>
Date:   Mon May 11 04:23:51 2020 +0200

    Reduce division in JD calc (#17945)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index f2b90cd994..60dbb612c7 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -903,21 +903,25 @@ class Planner {
     #if HAS_JUNCTION_DEVIATION
 
       FORCE_INLINE static void normalize_junction_vector(xyze_float_t &vector) {
         float magnitude_sq = 0;
         LOOP_XYZE(idx) if (vector[idx]) magnitude_sq += sq(vector[idx]);
         vector *= RSQRT(magnitude_sq);
       }
 
       FORCE_INLINE static float limit_value_by_axis_maximum(const float &max_value, xyze_float_t &unit_vec) {
         float limit_value = max_value;
-        LOOP_XYZE(idx) if (unit_vec[idx]) // Avoid divide by zero
-          NOMORE(limit_value, ABS(settings.max_acceleration_mm_per_s2[idx] / unit_vec[idx]));
+        LOOP_XYZE(idx) {
+          if (unit_vec[idx]) {
+            if (limit_value * ABS(unit_vec[idx]) > settings.max_acceleration_mm_per_s2[idx])
+              limit_value = ABS(settings.max_acceleration_mm_per_s2[idx] / unit_vec[idx]);
+          }
+        }
         return limit_value;
       }
 
     #endif // !CLASSIC_JERK
 };
 
 #define PLANNER_XY_FEEDRATE() (_MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]))
 
 extern Planner planner;

commit 7a2cc782b406f7e89a0a61d168cc7a5d90835c06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 5 03:09:40 2020 -0500

    Clean up planner modifier methods

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 9e5088f55a..f2b90cd994 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -540,47 +540,42 @@ class Planner {
        * Apply leveling to transform a cartesian position
        * as it will be given to the planner and steppers.
        */
       static void apply_leveling(xyz_pos_t &raw);
       static void unapply_leveling(xyz_pos_t &raw);
       FORCE_INLINE static void force_unapply_leveling(xyz_pos_t &raw) {
         leveling_active = true;
         unapply_leveling(raw);
         leveling_active = false;
       }
+    #else
+      FORCE_INLINE static void apply_leveling(xyz_pos_t&) {}
+      FORCE_INLINE static void unapply_leveling(xyz_pos_t&) {}
     #endif
 
     #if ENABLED(FWRETRACT)
       static void apply_retract(float &rz, float &e);
       FORCE_INLINE static void apply_retract(xyze_pos_t &raw) { apply_retract(raw.z, raw.e); }
       static void unapply_retract(float &rz, float &e);
       FORCE_INLINE static void unapply_retract(xyze_pos_t &raw) { unapply_retract(raw.z, raw.e); }
     #endif
 
     #if HAS_POSITION_MODIFIERS
-      FORCE_INLINE static void apply_modifiers(xyze_pos_t &pos
-        #if HAS_LEVELING
-          , bool leveling = ENABLED(PLANNER_LEVELING)
-        #endif
-      ) {
+      FORCE_INLINE static void apply_modifiers(xyze_pos_t &pos, bool leveling=ENABLED(PLANNER_LEVELING)) {
         TERN_(SKEW_CORRECTION, skew(pos));
-        TERN_(HAS_LEVELING, if (leveling) apply_leveling(pos));
+        if (leveling) apply_leveling(pos);
         TERN_(FWRETRACT, apply_retract(pos));
       }
 
-      FORCE_INLINE static void unapply_modifiers(xyze_pos_t &pos
-        #if HAS_LEVELING
-          , bool leveling = ENABLED(PLANNER_LEVELING)
-        #endif
-      ) {
+      FORCE_INLINE static void unapply_modifiers(xyze_pos_t &pos, bool leveling=ENABLED(PLANNER_LEVELING)) {
         TERN_(FWRETRACT, unapply_retract(pos));
-        TERN_(HAS_LEVELING, if (leveling) unapply_leveling(pos));
+        if (leveling) unapply_leveling(pos);
         TERN_(SKEW_CORRECTION, unskew(pos));
       }
     #endif // HAS_POSITION_MODIFIERS
 
     // Number of moves currently in the planner including the busy block, if any
     FORCE_INLINE static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail); }
 
     // Number of nonbusy moves currently in the planner
     FORCE_INLINE static uint8_t nonbusy_movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_nonbusy); }
 

commit eeabe66fc49501222fc458f5c298893e4d88ee17
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 5 00:28:39 2020 -0500

    Some distinct E helpers

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 8c1810c3a8..9e5088f55a 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -308,23 +308,22 @@ class Planner {
                                                       // May be auto-adjusted by a filament width sensor
     #endif
 
     static planner_settings_t settings;
 
     static uint32_t max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
     static float steps_to_mm[XYZE_N];           // Millimeters per step
 
     #if HAS_JUNCTION_DEVIATION
       static float junction_deviation_mm;       // (mm) M205 J
-      #if ENABLED(LIN_ADVANCE)
-        static float max_e_jerk                 // Calculated from junction_deviation_mm
-          [TERN(DISTINCT_E_FACTORS, EXTRUDERS, 1)];
+      #if HAS_LINEAR_E_JERK
+        static float max_e_jerk[DISTINCT_E];    // Calculated from junction_deviation_mm
       #endif
     #endif
 
     #if HAS_CLASSIC_JERK
       // (mm/s^2) M205 XYZ(E) - The largest speed change requiring no acceleration.
       static TERN(HAS_LINEAR_E_JERK, xyz_pos_t, xyze_pos_t) max_jerk;
     #endif
 
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
@@ -835,21 +834,21 @@ class Planner {
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
       static void autotemp_update();
     #endif
 
     #if HAS_LINEAR_E_JERK
       FORCE_INLINE static void recalculate_max_e_jerk() {
         const float prop = junction_deviation_mm * SQRT(0.5) / (1.0f - SQRT(0.5));
         LOOP_L_N(i, EXTRUDERS)
-          max_e_jerk[E_AXIS_N(i)] = SQRT(prop * settings.max_acceleration_mm_per_s2[E_AXIS_N(i)]);
+          max_e_jerk[E_INDEX_N(i)] = SQRT(prop * settings.max_acceleration_mm_per_s2[E_INDEX_N(i)]);
       }
     #endif
 
   private:
 
     /**
      * Get the index of the next / previous block in the ring buffer
      */
     static constexpr uint8_t next_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index + 1); }
     static constexpr uint8_t prev_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index - 1); }

commit 90e1035e9bcb4dedee41e698a8923c71fbbaf060
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 4 23:07:54 2020 -0500

    Define max_e_jerk as array always

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 05c5c44cee..8c1810c3a8 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -310,21 +310,21 @@ class Planner {
 
     static planner_settings_t settings;
 
     static uint32_t max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
     static float steps_to_mm[XYZE_N];           // Millimeters per step
 
     #if HAS_JUNCTION_DEVIATION
       static float junction_deviation_mm;       // (mm) M205 J
       #if ENABLED(LIN_ADVANCE)
         static float max_e_jerk                 // Calculated from junction_deviation_mm
-          TERN_(DISTINCT_E_FACTORS, [EXTRUDERS]);
+          [TERN(DISTINCT_E_FACTORS, EXTRUDERS, 1)];
       #endif
     #endif
 
     #if HAS_CLASSIC_JERK
       // (mm/s^2) M205 XYZ(E) - The largest speed change requiring no acceleration.
       static TERN(HAS_LINEAR_E_JERK, xyz_pos_t, xyze_pos_t) max_jerk;
     #endif
 
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
@@ -833,27 +833,23 @@ class Planner {
     #if ENABLED(AUTOTEMP)
       static float autotemp_min, autotemp_max, autotemp_factor;
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
       static void autotemp_update();
     #endif
 
     #if HAS_LINEAR_E_JERK
       FORCE_INLINE static void recalculate_max_e_jerk() {
-        #define GET_MAX_E_JERK(N) SQRT(junction_deviation_mm * (N) * SQRT(0.5) / (1.0f - SQRT(0.5)))
-        #if ENABLED(DISTINCT_E_FACTORS)
-          LOOP_L_N(i, EXTRUDERS)
-            max_e_jerk[i] = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS_N(i)]);
-        #else
-          max_e_jerk = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS]);
-        #endif
+        const float prop = junction_deviation_mm * SQRT(0.5) / (1.0f - SQRT(0.5));
+        LOOP_L_N(i, EXTRUDERS)
+          max_e_jerk[E_AXIS_N(i)] = SQRT(prop * settings.max_acceleration_mm_per_s2[E_AXIS_N(i)]);
       }
     #endif
 
   private:
 
     /**
      * Get the index of the next / previous block in the ring buffer
      */
     static constexpr uint8_t next_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index + 1); }
     static constexpr uint8_t prev_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index - 1); }

commit b8947ac8a5182b6b54165fb6ddc4177efb32091a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 4 15:13:37 2020 -0500

    More explicit junction/jerk math

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index ccc7faf706..05c5c44cee 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -831,25 +831,23 @@ class Planner {
     #endif
 
     #if ENABLED(AUTOTEMP)
       static float autotemp_min, autotemp_max, autotemp_factor;
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
       static void autotemp_update();
     #endif
 
-    #define JUNC_SQ(N,ST) (junction_deviation_mm * (N) * (ST) / (1.0f - (ST)))
-
     #if HAS_LINEAR_E_JERK
       FORCE_INLINE static void recalculate_max_e_jerk() {
-        #define GET_MAX_E_JERK(N) SQRT(JUNC_SQ(N,SQRT(0.5)))
+        #define GET_MAX_E_JERK(N) SQRT(junction_deviation_mm * (N) * SQRT(0.5) / (1.0f - SQRT(0.5)))
         #if ENABLED(DISTINCT_E_FACTORS)
           LOOP_L_N(i, EXTRUDERS)
             max_e_jerk[i] = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS_N(i)]);
         #else
           max_e_jerk = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS]);
         #endif
       }
     #endif
 
   private:

commit 0c68794fa920838c289373314c9e1b172bbfa676
Author: ≈†tƒõp√°n Daleck√Ω <36531759+daleckystepan@users.noreply.github.com>
Date:   Sun May 3 06:59:09 2020 +0200

    Improve JD acosx implementation (#17817)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 7b029cba01..ccc7faf706 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -25,20 +25,31 @@
  * planner.h
  *
  * Buffer movement commands and manage the acceleration profile plan
  *
  * Derived from Grbl
  * Copyright (c) 2009-2011 Simen Svale Skogsrud
  */
 
 #include "../MarlinCore.h"
 
+#if HAS_JUNCTION_DEVIATION
+  // Enable this option for perfect accuracy but maximum
+  // computation. Should be fine on ARM processors.
+  //#define JD_USE_MATH_ACOS
+
+  // Disable this option to save 120 bytes of PROGMEM,
+  // but incur increased computation and a reduction
+  // in accuracy.
+  #define JD_USE_LOOKUP_TABLE
+#endif
+
 #include "motion.h"
 #include "../gcode/queue.h"
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
 #if ABL_PLANAR
   #include "../libs/vector_3.h" // for matrix_3x3
 #endif
@@ -820,23 +831,25 @@ class Planner {
     #endif
 
     #if ENABLED(AUTOTEMP)
       static float autotemp_min, autotemp_max, autotemp_factor;
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
       static void autotemp_update();
     #endif
 
+    #define JUNC_SQ(N,ST) (junction_deviation_mm * (N) * (ST) / (1.0f - (ST)))
+
     #if HAS_LINEAR_E_JERK
       FORCE_INLINE static void recalculate_max_e_jerk() {
-        #define GET_MAX_E_JERK(N) SQRT(SQRT(0.5) * junction_deviation_mm * (N) * RECIPROCAL(1.0 - SQRT(0.5)))
+        #define GET_MAX_E_JERK(N) SQRT(JUNC_SQ(N,SQRT(0.5)))
         #if ENABLED(DISTINCT_E_FACTORS)
           LOOP_L_N(i, EXTRUDERS)
             max_e_jerk[i] = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS_N(i)]);
         #else
           max_e_jerk = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS]);
         #endif
       }
     #endif
 
   private:

commit 89b17b54637200838e52ae39a9e4b23f3c2f8d35
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Tue Apr 28 07:21:23 2020 +0200

    Followup fixes for singlenozzle, etc. (#17712)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index ebfb8dcb9e..7b029cba01 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -817,20 +817,21 @@ class Planner {
     #if HAS_SPI_LCD
       static uint16_t block_buffer_runtime();
       static void clear_block_buffer_runtime();
     #endif
 
     #if ENABLED(AUTOTEMP)
       static float autotemp_min, autotemp_max, autotemp_factor;
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
+      static void autotemp_update();
     #endif
 
     #if HAS_LINEAR_E_JERK
       FORCE_INLINE static void recalculate_max_e_jerk() {
         #define GET_MAX_E_JERK(N) SQRT(SQRT(0.5) * junction_deviation_mm * (N) * RECIPROCAL(1.0 - SQRT(0.5)))
         #if ENABLED(DISTINCT_E_FACTORS)
           LOOP_L_N(i, EXTRUDERS)
             max_e_jerk[i] = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS_N(i)]);
         #else
           max_e_jerk = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS]);

commit c536b8de629807b489f054051bb120457f112a11
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 25 17:53:06 2020 -0500

    Apply ternary macros

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index e9658f2c60..ebfb8dcb9e 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -130,23 +130,21 @@ typedef struct block_t {
     abce_long_t position;                   // New position to force when this sync block is executed
   };
   uint32_t step_event_count;                // The number of step events required to complete this block
 
   #if EXTRUDERS > 1
     uint8_t extruder;                       // The extruder to move (if E move)
   #else
     static constexpr uint8_t extruder = 0;
   #endif
 
-  #if ENABLED(MIXING_EXTRUDER)
-    MIXER_BLOCK_FIELD;                      // Normalized color for the mixing steppers
-  #endif
+  TERN_(MIXING_EXTRUDER, MIXER_BLOCK_FIELD); // Normalized color for the mixing steppers
 
   // Settings for the trapezoid generator
   uint32_t accelerate_until,                // The index of the step event on which to stop acceleration
            decelerate_after;                // The index of the step event on which to start decelerating
 
   #if ENABLED(S_CURVE_ACCELERATION)
     uint32_t cruise_rate,                   // The actual cruise rate to use, between end of the acceleration phase and start of deceleration phase
              acceleration_time,             // Acceleration time and deceleration time in STEP timer counts
              deceleration_time,
              acceleration_time_inverse,     // Inverse of acceleration and deceleration periods, expressed as integer. Scale depends on CPU being used

commit 5ae45bab1826fc9c743d62a52f55cea5fe124b6b
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Mon Apr 27 12:59:52 2020 +0200

    Adjustable XY_FREQUENCY_LIMIT (#17583)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index bf585320de..e9658f2c60 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -345,20 +345,37 @@ class Planner {
 
     #if IS_KINEMATIC
       static xyze_pos_t position_cart;
     #endif
 
     static skew_factor_t skew_factor;
 
     #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
       static bool abort_on_endstop_hit;
     #endif
+    #ifdef XY_FREQUENCY_LIMIT
+      static int8_t xy_freq_limit_hz;         // Minimum XY frequency setting
+      static float xy_freq_min_speed_factor;  // Minimum speed factor setting
+      static int32_t xy_freq_min_interval_us; // Minimum segment time based on xy_freq_limit_hz
+      static inline void refresh_frequency_limit() {
+        //xy_freq_min_interval_us = xy_freq_limit_hz ?: LROUND(1000000.0f / xy_freq_limit_hz);
+        if (xy_freq_limit_hz)
+          xy_freq_min_interval_us = LROUND(1000000.0f / xy_freq_limit_hz);
+      }
+      static inline void set_min_speed_factor_u8(const uint8_t v255) {
+        xy_freq_min_speed_factor = float(ui8_to_percent(v255)) / 100;
+      }
+      static inline void set_frequency_limit(const uint8_t hz) {
+        xy_freq_limit_hz = constrain(hz, 0, 100);
+        refresh_frequency_limit();
+      }
+    #endif
 
   private:
 
     /**
      * Speed of previous path line segment
      */
     static xyze_float_t previous_speed;
 
     /**
      * Nominal speed of previous path line segment (mm/s)^2
@@ -368,37 +385,26 @@ class Planner {
     /**
      * Limit where 64bit math is necessary for acceleration calculation
      */
     static uint32_t cutoff_long;
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       static float last_fade_z;
     #endif
 
     #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
-      /**
-       * Counters to manage disabling inactive extruders
-       */
+       // Counters to manage disabling inactive extruders
       static uint8_t g_uc_extruder_last_move[EXTRUDERS];
-    #endif // DISABLE_INACTIVE_EXTRUDER
-
-    #ifdef XY_FREQUENCY_LIMIT
-      // Used for the frequency limit
-      #define MAX_FREQ_TIME_US (uint32_t)(1000000.0 / XY_FREQUENCY_LIMIT)
-      // Old direction bits. Used for speed calculations
-      static unsigned char old_direction_bits;
-      // Segment times (in ¬µs). Used for speed calculations
-      static xy_ulong_t axis_segment_time_us[3];
     #endif
 
     #if HAS_SPI_LCD
-      volatile static uint32_t block_buffer_runtime_us; //Theoretical block buffer runtime in ¬µs
+      volatile static uint32_t block_buffer_runtime_us; // Theoretical block buffer runtime in ¬µs
     #endif
 
   public:
 
     /**
      * Instance Methods
      */
 
     Planner();
 

commit 8b3c7dda755ebce5bd57a7ce52891a137ea12b35
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 04:41:18 2020 -0500

    Add HAS_FAN and others

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 8b6cdcada0..bf585320de 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -168,21 +168,21 @@ typedef struct block_t {
 
   uint32_t nominal_rate,                    // The nominal step rate for this block in step_events/sec
            initial_rate,                    // The jerk-adjusted step rate at start of block
            final_rate,                      // The minimal rate at exit
            acceleration_steps_per_s2;       // acceleration steps/sec^2
 
   #if HAS_CUTTER
     cutter_power_t cutter_power;            // Power level for Spindle, Laser, etc.
   #endif
 
-  #if FAN_COUNT > 0
+  #if HAS_FAN
     uint8_t fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
     uint8_t valve_pressure, e_to_p_pressure;
   #endif
 
   #if HAS_SPI_LCD
     uint32_t segment_time_us;
   #endif

commit e25402b5411c8ea77e05f7f925e588b40b7e02a8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 24 17:41:20 2020 -0500

    Apply TERN

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 626e39c721..8b6cdcada0 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -301,33 +301,27 @@ class Planner {
 
     static planner_settings_t settings;
 
     static uint32_t max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
     static float steps_to_mm[XYZE_N];           // Millimeters per step
 
     #if HAS_JUNCTION_DEVIATION
       static float junction_deviation_mm;       // (mm) M205 J
       #if ENABLED(LIN_ADVANCE)
         static float max_e_jerk                 // Calculated from junction_deviation_mm
-          #if ENABLED(DISTINCT_E_FACTORS)
-            [EXTRUDERS]
-          #endif
-        ;
+          TERN_(DISTINCT_E_FACTORS, [EXTRUDERS]);
       #endif
     #endif
 
     #if HAS_CLASSIC_JERK
-      #if HAS_LINEAR_E_JERK
-        static xyz_pos_t max_jerk;              // (mm/s^2) M205 XYZ - The largest speed change requiring no acceleration.
-      #else
-        static xyze_pos_t max_jerk;             // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
-      #endif
+      // (mm/s^2) M205 XYZ(E) - The largest speed change requiring no acceleration.
+      static TERN(HAS_LINEAR_E_JERK, xyz_pos_t, xyze_pos_t) max_jerk;
     #endif
 
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
       #if ABL_PLANAR
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         static float z_fade_height, inverse_z_fade_height;
       #endif

commit 55d66fb8971d9e5dbfb15e7ae5c952839b488f59
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 20:49:11 2020 -0500

    Add HAS_JUNCTION_DEVIATION

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 87a6e7c0a8..626e39c721 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -54,21 +54,21 @@
 #if HAS_CUTTER
   #include "../feature/spindle_laser_types.h"
 #endif
 
 // Feedrate for manual moves
 #ifdef MANUAL_FEEDRATE
   constexpr xyze_feedrate_t _mf = MANUAL_FEEDRATE,
                             manual_feedrate_mm_s { _mf.x / 60.0f, _mf.y / 60.0f, _mf.z / 60.0f, _mf.e / 60.0f };
 #endif
 
-#if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
+#if IS_KINEMATIC && HAS_JUNCTION_DEVIATION
   #define HAS_DIST_MM_ARG 1
 #endif
 
 enum BlockFlagBit : char {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).
@@ -297,21 +297,21 @@ class Planner {
                    volumetric_area_nominal,           // Nominal cross-sectional area
                    volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                       // May be auto-adjusted by a filament width sensor
     #endif
 
     static planner_settings_t settings;
 
     static uint32_t max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
     static float steps_to_mm[XYZE_N];           // Millimeters per step
 
-    #if DISABLED(CLASSIC_JERK)
+    #if HAS_JUNCTION_DEVIATION
       static float junction_deviation_mm;       // (mm) M205 J
       #if ENABLED(LIN_ADVANCE)
         static float max_e_jerk                 // Calculated from junction_deviation_mm
           #if ENABLED(DISTINCT_E_FACTORS)
             [EXTRUDERS]
           #endif
         ;
       #endif
     #endif
 
@@ -893,21 +893,21 @@ class Planner {
     static void reverse_pass_kernel(block_t* const current, const block_t * const next);
     static void forward_pass_kernel(const block_t * const previous, block_t* const current, uint8_t block_index);
 
     static void reverse_pass();
     static void forward_pass();
 
     static void recalculate_trapezoids();
 
     static void recalculate();
 
-    #if DISABLED(CLASSIC_JERK)
+    #if HAS_JUNCTION_DEVIATION
 
       FORCE_INLINE static void normalize_junction_vector(xyze_float_t &vector) {
         float magnitude_sq = 0;
         LOOP_XYZE(idx) if (vector[idx]) magnitude_sq += sq(vector[idx]);
         vector *= RSQRT(magnitude_sq);
       }
 
       FORCE_INLINE static float limit_value_by_axis_maximum(const float &max_value, xyze_float_t &unit_vec) {
         float limit_value = max_value;
         LOOP_XYZE(idx) if (unit_vec[idx]) // Avoid divide by zero

commit 2f6262c27b11598293839f6d46f3b340ee6a1f4c
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Thu Apr 23 04:03:28 2020 +0200

    Automatic Tool Migration feature (#17248)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 7ac7d5ade7..87a6e7c0a8 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -416,26 +416,28 @@ class Planner {
 
     static void reset_acceleration_rates();
     static void refresh_positioning();
     static void set_max_acceleration(const uint8_t axis, float targetValue);
     static void set_max_feedrate(const uint8_t axis, float targetValue);
     static void set_max_jerk(const AxisEnum axis, float targetValue);
 
 
     #if EXTRUDERS
       FORCE_INLINE static void refresh_e_factor(const uint8_t e) {
-        e_factor[e] = (flow_percentage[e] * 0.01f
-          #if DISABLED(NO_VOLUMETRICS)
-            * volumetric_multiplier[e]
-          #endif
-        );
+        e_factor[e] = flow_percentage[e] * 0.01f * TERN(NO_VOLUMETRICS, 1.0f, volumetric_multiplier[e]);
       }
+
+      static inline void set_flow(const uint8_t e, const int16_t flow) {
+        flow_percentage[e] = flow;
+        refresh_e_factor(e);
+      }
+
     #endif
 
     // Manage fans, paste pressure, etc.
     static void check_axes_activity();
 
     // Update multipliers based on new diameter measurements
     static void calculate_volumetric_multipliers();
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       void apply_filament_width_sensor(const int8_t encoded_ratio);

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 97e907e26b..7ac7d5ade7 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -190,21 +190,23 @@ typedef struct block_t {
   #if ENABLED(POWER_LOSS_RECOVERY)
     uint32_t sdpos;
   #endif
 
   #if ENABLED(LASER_POWER_INLINE)
     block_laser_t laser;
   #endif
 
 } block_t;
 
-#define HAS_POSITION_FLOAT ANY(LIN_ADVANCE, SCARA_FEEDRATE_SCALING, GRADIENT_MIX, LCD_SHOW_E_TOTAL)
+#if ANY(LIN_ADVANCE, SCARA_FEEDRATE_SCALING, GRADIENT_MIX, LCD_SHOW_E_TOTAL)
+  #define HAS_POSITION_FLOAT 1
+#endif
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 #if ENABLED(LASER_POWER_INLINE)
   typedef struct {
     /**
      * Laser status bitmask; most bits are unused;
      *  0: Planner buffer enable
      *  1: Laser enable
      *  2: Reserved for direction
@@ -540,58 +542,36 @@ class Planner {
     #if ENABLED(FWRETRACT)
       static void apply_retract(float &rz, float &e);
       FORCE_INLINE static void apply_retract(xyze_pos_t &raw) { apply_retract(raw.z, raw.e); }
       static void unapply_retract(float &rz, float &e);
       FORCE_INLINE static void unapply_retract(xyze_pos_t &raw) { unapply_retract(raw.z, raw.e); }
     #endif
 
     #if HAS_POSITION_MODIFIERS
       FORCE_INLINE static void apply_modifiers(xyze_pos_t &pos
         #if HAS_LEVELING
-          , bool leveling =
-          #if PLANNER_LEVELING
-            true
-          #else
-            false
-          #endif
+          , bool leveling = ENABLED(PLANNER_LEVELING)
         #endif
       ) {
-        #if ENABLED(SKEW_CORRECTION)
-          skew(pos);
-        #endif
-        #if HAS_LEVELING
-          if (leveling) apply_leveling(pos);
-        #endif
-        #if ENABLED(FWRETRACT)
-          apply_retract(pos);
-        #endif
+        TERN_(SKEW_CORRECTION, skew(pos));
+        TERN_(HAS_LEVELING, if (leveling) apply_leveling(pos));
+        TERN_(FWRETRACT, apply_retract(pos));
       }
 
       FORCE_INLINE static void unapply_modifiers(xyze_pos_t &pos
         #if HAS_LEVELING
-          , bool leveling =
-          #if PLANNER_LEVELING
-            true
-          #else
-            false
-          #endif
+          , bool leveling = ENABLED(PLANNER_LEVELING)
         #endif
       ) {
-        #if ENABLED(FWRETRACT)
-          unapply_retract(pos);
-        #endif
-        #if HAS_LEVELING
-          if (leveling) unapply_leveling(pos);
-        #endif
-        #if ENABLED(SKEW_CORRECTION)
-          unskew(pos);
-        #endif
+        TERN_(FWRETRACT, unapply_retract(pos));
+        TERN_(HAS_LEVELING, if (leveling) unapply_leveling(pos));
+        TERN_(SKEW_CORRECTION, unskew(pos));
       }
     #endif // HAS_POSITION_MODIFIERS
 
     // Number of moves currently in the planner including the busy block, if any
     FORCE_INLINE static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail); }
 
     // Number of nonbusy moves currently in the planner
     FORCE_INLINE static uint8_t nonbusy_movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_nonbusy); }
 
     // Remove all blocks from the buffer

commit 7aed32df00ae33b6ab2815006ad4c422a9231b69
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 11 21:27:49 2020 -0500

    Fix SD_FINISHED_RELEASECOMMAND bug
    
    Fixes #17401 bug that was introduced in 8f26c3a

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index a42c84c1fa..97e907e26b 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -800,26 +800,21 @@ class Planner {
 
     // Block until all buffered steps are executed / cleaned
     static void synchronize();
 
     // Wait for moves to finish and disable all steppers
     static void finish_and_disable();
 
     // Periodic tick to handle cleaning timeouts
     // Called from the Temperature ISR at ~1kHz
     static void tick() {
-      if (cleaning_buffer_counter) {
-        --cleaning_buffer_counter;
-        #if ENABLED(SD_FINISHED_STEPPERRELEASE) && defined(SD_FINISHED_RELEASECOMMAND)
-          if (!cleaning_buffer_counter) queue.inject_P(PSTR(SD_FINISHED_RELEASECOMMAND));
-        #endif
-      }
+      if (cleaning_buffer_counter) --cleaning_buffer_counter;
     }
 
     /**
      * Does the buffer have any blocks queued?
      */
     FORCE_INLINE static bool has_blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
     /**
      * Get the current block for processing
      * and mark the block as busy.

commit df8b7dfc406be095a62b5445b69c40034d418823
Author: Ben <jediminer543@users.noreply.github.com>
Date:   Fri Apr 3 01:31:08 2020 +0100

    Various Laser / Spindle improvements (#15335)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 24c02c01c5..a42c84c1fa 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -45,21 +45,21 @@
 
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"
 #endif
 
 #if HAS_CUTTER
-  #include "../feature/spindle_laser.h"
+  #include "../feature/spindle_laser_types.h"
 #endif
 
 // Feedrate for manual moves
 #ifdef MANUAL_FEEDRATE
   constexpr xyze_feedrate_t _mf = MANUAL_FEEDRATE,
                             manual_feedrate_mm_s { _mf.x / 60.0f, _mf.y / 60.0f, _mf.z / 60.0f, _mf.e / 60.0f };
 #endif
 
 #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
   #define HAS_DIST_MM_ARG 1
@@ -81,20 +81,37 @@ enum BlockFlagBit : char {
   BLOCK_BIT_SYNC_POSITION
 };
 
 enum BlockFlag : char {
   BLOCK_FLAG_RECALCULATE          = _BV(BLOCK_BIT_RECALCULATE),
   BLOCK_FLAG_NOMINAL_LENGTH       = _BV(BLOCK_BIT_NOMINAL_LENGTH),
   BLOCK_FLAG_CONTINUED            = _BV(BLOCK_BIT_CONTINUED),
   BLOCK_FLAG_SYNC_POSITION        = _BV(BLOCK_BIT_SYNC_POSITION)
 };
 
+#if ENABLED(LASER_POWER_INLINE)
+
+  typedef struct {
+    uint8_t status,           // See planner settings for meaning
+            power;            // Ditto; When in trapezoid mode this is nominal power
+    #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
+      uint8_t   power_entry;  // Entry power for the laser
+      #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
+        uint8_t   power_exit; // Exit power for the laser
+        uint32_t  entry_per,  // Steps per power increment (to avoid floats in stepper calcs)
+                  exit_per;   // Steps per power decrement
+      #endif
+    #endif
+  } block_laser_t;
+
+#endif
+
 /**
  * struct block_t
  *
  * A single entry in the planner buffer.
  * Tracks linear movement over multiple axes.
  *
  * The "nominal" values are as-specified by gcode, and
  * may never actually be reached due to acceleration limits.
  */
 typedef struct block_t {
@@ -167,36 +184,63 @@ typedef struct block_t {
   #endif
 
   #if HAS_SPI_LCD
     uint32_t segment_time_us;
   #endif
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     uint32_t sdpos;
   #endif
 
+  #if ENABLED(LASER_POWER_INLINE)
+    block_laser_t laser;
+  #endif
+
 } block_t;
 
 #define HAS_POSITION_FLOAT ANY(LIN_ADVANCE, SCARA_FEEDRATE_SCALING, GRADIENT_MIX, LCD_SHOW_E_TOTAL)
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
+#if ENABLED(LASER_POWER_INLINE)
+  typedef struct {
+    /**
+     * Laser status bitmask; most bits are unused;
+     *  0: Planner buffer enable
+     *  1: Laser enable
+     *  2: Reserved for direction
+     */
+    uint8_t status;
+    /**
+     * Laser power: 0 or 255 in case of PWM-less laser,
+     * or the OCR value;
+     *
+     * Using OCR instead of raw power,
+     * as it avoids floating points during move loop
+     */
+    uint8_t power;
+  } settings_laser_t;
+#endif
+
 typedef struct {
    uint32_t max_acceleration_mm_per_s2[XYZE_N], // (mm/s^2) M201 XYZE
             min_segment_time_us;                // (¬µs) M205 B
       float axis_steps_per_mm[XYZE_N];          // (steps) M92 XYZE - Steps per millimeter
  feedRate_t max_feedrate_mm_s[XYZE_N];          // (mm/s) M203 XYZE - Max speeds
       float acceleration,                       // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
             retract_acceleration,               // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
             travel_acceleration;                // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
  feedRate_t min_feedrate_mm_s,                  // (mm/s) M205 S - Minimum linear feedrate
             min_travel_feedrate_mm_s;           // (mm/s) M205 T - Minimum travel feedrate
+  #if ENABLED(LASER_POWER_INLINE)
+    settings_laser_t laser;
+  #endif
 } planner_settings_t;
 
 #if DISABLED(SKEW_CORRECTION)
   #define XY_SKEW_FACTOR 0
   #define XZ_SKEW_FACTOR 0
   #define YZ_SKEW_FACTOR 0
 #endif
 
 typedef struct {
   #if ENABLED(SKEW_CORRECTION_GCODE)

commit adb6334ba031166e33f256344fc2b01e909cd99f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 25 17:55:36 2020 -0500

    Use "dist" instead of "delta" for clarity

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index ae104eb354..24c02c01c5 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -54,20 +54,24 @@
 #if HAS_CUTTER
   #include "../feature/spindle_laser.h"
 #endif
 
 // Feedrate for manual moves
 #ifdef MANUAL_FEEDRATE
   constexpr xyze_feedrate_t _mf = MANUAL_FEEDRATE,
                             manual_feedrate_mm_s { _mf.x / 60.0f, _mf.y / 60.0f, _mf.z / 60.0f, _mf.e / 60.0f };
 #endif
 
+#if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
+  #define HAS_DIST_MM_ARG 1
+#endif
+
 enum BlockFlagBit : char {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).
   BLOCK_BIT_NOMINAL_LENGTH,
 
   // The block is segment 2+ of a longer move
@@ -581,22 +585,22 @@ class Planner {
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      *
      * Returns true if movement was buffered, false otherwise
      */
     static bool _buffer_steps(const xyze_long_t &target
       #if HAS_POSITION_FLOAT
         , const xyze_pos_t &target_float
       #endif
-      #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
-        , const xyze_float_t &delta_mm_cart
+      #if HAS_DIST_MM_ARG
+        , const xyze_float_t &cart_dist_mm
       #endif
       , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
     /**
      * Planner::_populate_block
      *
      * Fills a new linear movement in the block (in terms of steps).
      *
      *  target      - target position in steps units
@@ -604,22 +608,22 @@ class Planner {
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      *
      * Returns true is movement is acceptable, false otherwise
      */
     static bool _populate_block(block_t * const block, bool split_move,
         const xyze_long_t &target
       #if HAS_POSITION_FLOAT
         , const xyze_pos_t &target_float
       #endif
-      #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
-        , const xyze_float_t &delta_mm_cart
+      #if HAS_DIST_MM_ARG
+        , const xyze_float_t &cart_dist_mm
       #endif
       , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
     /**
      * Planner::buffer_sync_block
      * Add a block to the buffer that just updates the position
      */
     static void buffer_sync_block();
 
@@ -636,35 +640,35 @@ class Planner {
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e     - target positions in mm and/or degrees
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      */
     static bool buffer_segment(const float &a, const float &b, const float &c, const float &e
-      #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
-        , const xyze_float_t &delta_mm_cart
+      #if HAS_DIST_MM_ARG
+        , const xyze_float_t &cart_dist_mm
       #endif
       , const feedRate_t &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
     FORCE_INLINE static bool buffer_segment(abce_pos_t &abce
-      #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
-        , const xyze_float_t &delta_mm_cart
+      #if HAS_DIST_MM_ARG
+        , const xyze_float_t &cart_dist_mm
       #endif
       , const feedRate_t &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     ) {
       return buffer_segment(abce.a, abce.b, abce.c, abce.e
-        #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
-          , delta_mm_cart
+        #if HAS_DIST_MM_ARG
+          , cart_dist_mm
         #endif
         , fr_mm_s, extruder, millimeters);
     }
 
   public:
 
     /**
      * Add a new linear movement to the buffer.
      * The target is cartesian. It's translated to
      * delta/scara if needed.

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 3e5d9d902e..ae104eb354 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -396,21 +396,21 @@ class Planner {
             : volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
         );
       }
     #endif
 
     #if DISABLED(NO_VOLUMETRICS)
 
       FORCE_INLINE static void set_filament_size(const uint8_t e, const float &v) {
         filament_size[e] = v;
         // make sure all extruders have some sane value for the filament size
-        for (uint8_t i = 0; i < COUNT(filament_size); i++)
+        LOOP_L_N(i, COUNT(filament_size))
           if (!filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;
       }
 
     #endif
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
 
       /**
        * Get the Z leveling fade factor based on the given Z height,
        * re-calculating only when needed.
@@ -800,21 +800,21 @@ class Planner {
       static float autotemp_min, autotemp_max, autotemp_factor;
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
     #endif
 
     #if HAS_LINEAR_E_JERK
       FORCE_INLINE static void recalculate_max_e_jerk() {
         #define GET_MAX_E_JERK(N) SQRT(SQRT(0.5) * junction_deviation_mm * (N) * RECIPROCAL(1.0 - SQRT(0.5)))
         #if ENABLED(DISTINCT_E_FACTORS)
-          for (uint8_t i = 0; i < EXTRUDERS; i++)
+          LOOP_L_N(i, EXTRUDERS)
             max_e_jerk[i] = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS_N(i)]);
         #else
           max_e_jerk = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS]);
         #endif
       }
     #endif
 
   private:
 
     /**

commit 3a07b4412d24a6afd430f6d7e1b8c7f3c442a3c2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Mar 2 21:52:53 2020 -0600

    Asynchronous M114 and (R)ealtime position option (#17032)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 6942ec6028..3e5d9d902e 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -282,42 +282,42 @@ class Planner {
         static float z_fade_height, inverse_z_fade_height;
       #endif
     #else
       static constexpr bool leveling_active = false;
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       static float extruder_advance_K[EXTRUDERS];
     #endif
 
+    /**
+     * The current position of the tool in absolute steps
+     * Recalculated if any axis_steps_per_mm are changed by gcode
+     */
+    static xyze_long_t position;
+
     #if HAS_POSITION_FLOAT
       static xyze_pos_t position_float;
     #endif
 
     #if IS_KINEMATIC
       static xyze_pos_t position_cart;
     #endif
 
     static skew_factor_t skew_factor;
 
     #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
       static bool abort_on_endstop_hit;
     #endif
 
   private:
 
-    /**
-     * The current position of the tool in absolute steps
-     * Recalculated if any axis_steps_per_mm are changed by gcode
-     */
-    static xyze_long_t position;
-
     /**
      * Speed of previous path line segment
      */
     static xyze_float_t previous_speed;
 
     /**
      * Nominal speed of previous path line segment (mm/s)^2
      */
     static float previous_nominal_speed_sqr;
 
@@ -718,20 +718,30 @@ class Planner {
      */
     static void set_machine_position_mm(const float &a, const float &b, const float &c, const float &e);
     FORCE_INLINE static void set_machine_position_mm(const abce_pos_t &abce) { set_machine_position_mm(abce.a, abce.b, abce.c, abce.e); }
 
     /**
      * Get an axis position according to stepper position(s)
      * For CORE machines apply translation from ABC to XYZ.
      */
     static float get_axis_position_mm(const AxisEnum axis);
 
+    static inline abce_pos_t get_axis_positions_mm() {
+      const abce_pos_t out = {
+        get_axis_position_mm(A_AXIS),
+        get_axis_position_mm(B_AXIS),
+        get_axis_position_mm(C_AXIS),
+        get_axis_position_mm(E_AXIS)
+      };
+      return out;
+    }
+
     // SCARA AB axes are in degrees, not mm
     #if IS_SCARA
       FORCE_INLINE static float get_axis_position_degrees(const AxisEnum axis) { return get_axis_position_mm(axis); }
     #endif
 
     // Called to force a quick stop of the machine (for example, when
     // a Full Shutdown is required, or when endstops are hit)
     static void quick_stop();
 
     // Called when an endstop is triggered. Causes the machine to stop inmediately

commit 0b984519c30f453fdb5b4efb8008a07c69688824
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Feb 14 05:14:37 2020 -0600

    Clean up stepper and babystep (#16857)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 37f0112cc8..6942ec6028 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -756,122 +756,41 @@ class Planner {
         #endif
       }
     }
 
     /**
      * Does the buffer have any blocks queued?
      */
     FORCE_INLINE static bool has_blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
     /**
-     * The current block. nullptr if the buffer is empty.
-     * This also marks the block as busy.
+     * Get the current block for processing
+     * and mark the block as busy.
+     * Return nullptr if the buffer is empty
+     * or if there is a first-block delay.
+     *
      * WARNING: Called from Stepper ISR context!
      */
-    static block_t* get_current_block() {
-
-      // Get the number of moves in the planner queue so far
-      const uint8_t nr_moves = movesplanned();
-
-      // If there are any moves queued ...
-      if (nr_moves) {
-
-        // If there is still delay of delivery of blocks running, decrement it
-        if (delay_before_delivering) {
-          --delay_before_delivering;
-          // If the number of movements queued is less than 3, and there is still time
-          //  to wait, do not deliver anything
-          if (nr_moves < 3 && delay_before_delivering) return nullptr;
-          delay_before_delivering = 0;
-        }
-
-        // If we are here, there is no excuse to deliver the block
-        block_t * const block = &block_buffer[block_buffer_tail];
-
-        // No trapezoid calculated? Don't execute yet.
-        if (TEST(block->flag, BLOCK_BIT_RECALCULATE)) return nullptr;
-
-        #if HAS_SPI_LCD
-          block_buffer_runtime_us -= block->segment_time_us; // We can't be sure how long an active block will take, so don't count it.
-        #endif
-
-        // As this block is busy, advance the nonbusy block pointer
-        block_buffer_nonbusy = next_block_index(block_buffer_tail);
-
-        // Push block_buffer_planned pointer, if encountered.
-        if (block_buffer_tail == block_buffer_planned)
-          block_buffer_planned = block_buffer_nonbusy;
-
-        // Return the block
-        return block;
-      }
-
-      // The queue became empty
-      #if HAS_SPI_LCD
-        clear_block_buffer_runtime(); // paranoia. Buffer is empty now - so reset accumulated time to zero.
-      #endif
-
-      return nullptr;
-    }
+    static block_t* get_current_block();
 
     /**
      * "Discard" the block and "release" the memory.
      * Called when the current block is no longer needed.
-     * NB: There MUST be a current block to call this function!!
      */
     FORCE_INLINE static void discard_current_block() {
       if (has_blocks_queued())
         block_buffer_tail = next_block_index(block_buffer_tail);
     }
 
     #if HAS_SPI_LCD
-
-      static uint16_t block_buffer_runtime() {
-        #ifdef __AVR__
-          // Protect the access to the variable. Only required for AVR, as
-          //  any 32bit CPU offers atomic access to 32bit variables
-          bool was_enabled = STEPPER_ISR_ENABLED();
-          if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
-        #endif
-
-        millis_t bbru = block_buffer_runtime_us;
-
-        #ifdef __AVR__
-          // Reenable Stepper ISR
-          if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
-        #endif
-
-        // To translate ¬µs to ms a division by 1000 would be required.
-        // We introduce 2.4% error here by dividing by 1024.
-        // Doesn't matter because block_buffer_runtime_us is already too small an estimation.
-        bbru >>= 10;
-        // limit to about a minute.
-        NOMORE(bbru, 0xFFFFul);
-        return bbru;
-      }
-
-      static void clear_block_buffer_runtime() {
-        #ifdef __AVR__
-          // Protect the access to the variable. Only required for AVR, as
-          //  any 32bit CPU offers atomic access to 32bit variables
-          bool was_enabled = STEPPER_ISR_ENABLED();
-          if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
-        #endif
-
-        block_buffer_runtime_us = 0;
-
-        #ifdef __AVR__
-          // Reenable Stepper ISR
-          if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
-        #endif
-      }
-
+      static uint16_t block_buffer_runtime();
+      static void clear_block_buffer_runtime();
     #endif
 
     #if ENABLED(AUTOTEMP)
       static float autotemp_min, autotemp_max, autotemp_factor;
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
     #endif
 
     #if HAS_LINEAR_E_JERK

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 5f70c06cc5..37f0112cc8 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 7f9c62437e5c72947acc3310d94829f132697c81
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Feb 3 00:00:35 2020 -0600

    Corner Leveling: Add inset for each side (#16759)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 52b6bc1ea4..5f70c06cc5 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -50,21 +50,22 @@
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"
 #endif
 
 #if HAS_CUTTER
   #include "../feature/spindle_laser.h"
 #endif
 
 // Feedrate for manual moves
 #ifdef MANUAL_FEEDRATE
-  constexpr xyze_feedrate_t manual_feedrate_mm_m = MANUAL_FEEDRATE;
+  constexpr xyze_feedrate_t _mf = MANUAL_FEEDRATE,
+                            manual_feedrate_mm_s { _mf.x / 60.0f, _mf.y / 60.0f, _mf.z / 60.0f, _mf.e / 60.0f };
 #endif
 
 enum BlockFlagBit : char {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).
   BLOCK_BIT_NOMINAL_LENGTH,

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index a79c5bfd38..52b6bc1ea4 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -23,21 +23,21 @@
 
 /**
  * planner.h
  *
  * Buffer movement commands and manage the acceleration profile plan
  *
  * Derived from Grbl
  * Copyright (c) 2009-2011 Simen Svale Skogsrud
  */
 
-#include "../Marlin.h"
+#include "../MarlinCore.h"
 
 #include "motion.h"
 #include "../gcode/queue.h"
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
 #if ABL_PLANAR
   #include "../libs/vector_3.h" // for matrix_3x3

commit 7a342ecb935e421abfef2f8ed9a8d004f4d30a9f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 27 17:49:27 2019 -0500

    Show Total E during print (#15703)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 8919ae123c..a79c5bfd38 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -164,21 +164,21 @@ typedef struct block_t {
   #if HAS_SPI_LCD
     uint32_t segment_time_us;
   #endif
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     uint32_t sdpos;
   #endif
 
 } block_t;
 
-#define HAS_POSITION_FLOAT ANY(LIN_ADVANCE, SCARA_FEEDRATE_SCALING, GRADIENT_MIX)
+#define HAS_POSITION_FLOAT ANY(LIN_ADVANCE, SCARA_FEEDRATE_SCALING, GRADIENT_MIX, LCD_SHOW_E_TOTAL)
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 typedef struct {
    uint32_t max_acceleration_mm_per_s2[XYZE_N], // (mm/s^2) M201 XYZE
             min_segment_time_us;                // (¬µs) M205 B
       float axis_steps_per_mm[XYZE_N];          // (steps) M92 XYZE - Steps per millimeter
  feedRate_t max_feedrate_mm_s[XYZE_N];          // (mm/s) M203 XYZE - Max speeds
       float acceleration,                       // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
             retract_acceleration,               // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes

commit b7b303f4bfbced9f7a242a87af0f50d4cb24d8ae
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 15 16:10:20 2019 -0500

    Spindle/Laser power in planner blocks (#14437)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index c4e5765140..8919ae123c 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -44,20 +44,24 @@
 #endif
 
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"
 #endif
 
+#if HAS_CUTTER
+  #include "../feature/spindle_laser.h"
+#endif
+
 // Feedrate for manual moves
 #ifdef MANUAL_FEEDRATE
   constexpr xyze_feedrate_t manual_feedrate_mm_m = MANUAL_FEEDRATE;
 #endif
 
 enum BlockFlagBit : char {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
   // Nominal speed always reached.
@@ -138,20 +142,24 @@ typedef struct block_t {
              max_adv_steps,                 // max. advance steps to get cruising speed pressure (not always nominal_speed!)
              final_adv_steps;               // advance steps due to exit speed
     float e_D_ratio;
   #endif
 
   uint32_t nominal_rate,                    // The nominal step rate for this block in step_events/sec
            initial_rate,                    // The jerk-adjusted step rate at start of block
            final_rate,                      // The minimal rate at exit
            acceleration_steps_per_s2;       // acceleration steps/sec^2
 
+  #if HAS_CUTTER
+    cutter_power_t cutter_power;            // Power level for Spindle, Laser, etc.
+  #endif
+
   #if FAN_COUNT > 0
     uint8_t fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
     uint8_t valve_pressure, e_to_p_pressure;
   #endif
 
   #if HAS_SPI_LCD
     uint32_t segment_time_us;

commit c0005e939cf9c1d9db16f20e605c3228bc41a758
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 8 19:42:18 2019 -0500

    Enable junction deviation by default (#15481)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index fd05c6a866..c4e5765140 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -238,33 +238,33 @@ class Planner {
                    volumetric_area_nominal,           // Nominal cross-sectional area
                    volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                       // May be auto-adjusted by a filament width sensor
     #endif
 
     static planner_settings_t settings;
 
     static uint32_t max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
     static float steps_to_mm[XYZE_N];           // Millimeters per step
 
-    #if ENABLED(JUNCTION_DEVIATION)
+    #if DISABLED(CLASSIC_JERK)
       static float junction_deviation_mm;       // (mm) M205 J
       #if ENABLED(LIN_ADVANCE)
         static float max_e_jerk                 // Calculated from junction_deviation_mm
           #if ENABLED(DISTINCT_E_FACTORS)
             [EXTRUDERS]
           #endif
         ;
       #endif
     #endif
 
     #if HAS_CLASSIC_JERK
-      #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
+      #if HAS_LINEAR_E_JERK
         static xyz_pos_t max_jerk;              // (mm/s^2) M205 XYZ - The largest speed change requiring no acceleration.
       #else
         static xyze_pos_t max_jerk;             // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
       #endif
     #endif
 
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
       #if ABL_PLANAR
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
@@ -572,21 +572,21 @@ class Planner {
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      *
      * Returns true if movement was buffered, false otherwise
      */
     static bool _buffer_steps(const xyze_long_t &target
       #if HAS_POSITION_FLOAT
         , const xyze_pos_t &target_float
       #endif
-      #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+      #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
         , const xyze_float_t &delta_mm_cart
       #endif
       , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
     /**
      * Planner::_populate_block
      *
      * Fills a new linear movement in the block (in terms of steps).
      *
@@ -595,21 +595,21 @@ class Planner {
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      *
      * Returns true is movement is acceptable, false otherwise
      */
     static bool _populate_block(block_t * const block, bool split_move,
         const xyze_long_t &target
       #if HAS_POSITION_FLOAT
         , const xyze_pos_t &target_float
       #endif
-      #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+      #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
         , const xyze_float_t &delta_mm_cart
       #endif
       , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
     /**
      * Planner::buffer_sync_block
      * Add a block to the buffer that just updates the position
      */
     static void buffer_sync_block();
@@ -627,34 +627,34 @@ class Planner {
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e     - target positions in mm and/or degrees
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      */
     static bool buffer_segment(const float &a, const float &b, const float &c, const float &e
-      #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+      #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
         , const xyze_float_t &delta_mm_cart
       #endif
       , const feedRate_t &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
     FORCE_INLINE static bool buffer_segment(abce_pos_t &abce
-      #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+      #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
         , const xyze_float_t &delta_mm_cart
       #endif
       , const feedRate_t &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     ) {
       return buffer_segment(abce.a, abce.b, abce.c, abce.e
-        #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+        #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
           , delta_mm_cart
         #endif
         , fr_mm_s, extruder, millimeters);
     }
 
   public:
 
     /**
      * Add a new linear movement to the buffer.
      * The target is cartesian. It's translated to
@@ -858,21 +858,21 @@ class Planner {
 
     #endif
 
     #if ENABLED(AUTOTEMP)
       static float autotemp_min, autotemp_max, autotemp_factor;
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
     #endif
 
-    #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
+    #if HAS_LINEAR_E_JERK
       FORCE_INLINE static void recalculate_max_e_jerk() {
         #define GET_MAX_E_JERK(N) SQRT(SQRT(0.5) * junction_deviation_mm * (N) * RECIPROCAL(1.0 - SQRT(0.5)))
         #if ENABLED(DISTINCT_E_FACTORS)
           for (uint8_t i = 0; i < EXTRUDERS; i++)
             max_e_jerk[i] = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS_N(i)]);
         #else
           max_e_jerk = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS]);
         #endif
       }
     #endif
@@ -930,31 +930,31 @@ class Planner {
     static void reverse_pass_kernel(block_t* const current, const block_t * const next);
     static void forward_pass_kernel(const block_t * const previous, block_t* const current, uint8_t block_index);
 
     static void reverse_pass();
     static void forward_pass();
 
     static void recalculate_trapezoids();
 
     static void recalculate();
 
-    #if ENABLED(JUNCTION_DEVIATION)
+    #if DISABLED(CLASSIC_JERK)
 
       FORCE_INLINE static void normalize_junction_vector(xyze_float_t &vector) {
         float magnitude_sq = 0;
         LOOP_XYZE(idx) if (vector[idx]) magnitude_sq += sq(vector[idx]);
         vector *= RSQRT(magnitude_sq);
       }
 
       FORCE_INLINE static float limit_value_by_axis_maximum(const float &max_value, xyze_float_t &unit_vec) {
         float limit_value = max_value;
         LOOP_XYZE(idx) if (unit_vec[idx]) // Avoid divide by zero
           NOMORE(limit_value, ABS(settings.max_acceleration_mm_per_s2[idx] / unit_vec[idx]));
         return limit_value;
       }
 
-    #endif // JUNCTION_DEVIATION
+    #endif // !CLASSIC_JERK
 };
 
 #define PLANNER_XY_FEEDRATE() (_MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]))
 
 extern Planner planner;

commit 1df6c7a46c3be610377ee2fe33cef36cad5ef255
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 8 19:27:03 2019 -0500

    Work around a compiler bug
    
    See #15478

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index e547ead80f..fd05c6a866 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -261,21 +261,20 @@ class Planner {
         static xyz_pos_t max_jerk;              // (mm/s^2) M205 XYZ - The largest speed change requiring no acceleration.
       #else
         static xyze_pos_t max_jerk;             // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
       #endif
     #endif
 
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
       #if ABL_PLANAR
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
-        static constexpr xy_pos_t level_fulcrum = { X_TILT_FULCRUM, Y_TILT_FULCRUM };
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         static float z_fade_height, inverse_z_fade_height;
       #endif
     #else
       static constexpr bool leveling_active = false;
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       static float extruder_advance_K[EXTRUDERS];

commit 438835f6a52ab23c9b0114a27d35941a34648592
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Oct 1 20:59:48 2019 -0400

    Configurable Max Accel, Max Feedrate, Max Jerk edit limits (#13929)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 55ccae85a3..e547ead80f 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -351,20 +351,24 @@ class Planner {
     Planner();
 
     void init();
 
     /**
      * Static (class) Methods
      */
 
     static void reset_acceleration_rates();
     static void refresh_positioning();
+    static void set_max_acceleration(const uint8_t axis, float targetValue);
+    static void set_max_feedrate(const uint8_t axis, float targetValue);
+    static void set_max_jerk(const AxisEnum axis, float targetValue);
+
 
     #if EXTRUDERS
       FORCE_INLINE static void refresh_e_factor(const uint8_t e) {
         e_factor[e] = (flow_percentage[e] * 0.01f
           #if DISABLED(NO_VOLUMETRICS)
             * volumetric_multiplier[e]
           #endif
         );
       }
     #endif

commit e3fd0519b323182a3d096eca8209c4eaf56b6802
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 30 21:44:07 2019 -0500

    Reduce need for UNUSED

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index c18b7753e6..55ccae85a3 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -424,26 +424,23 @@ class Planner {
         inverse_z_fade_height = RECIPROCAL(z_fade_height);
         force_fade_recalc();
       }
 
       FORCE_INLINE static bool leveling_active_at_z(const float &rz) {
         return !z_fade_height || rz < z_fade_height;
       }
 
     #else
 
-      FORCE_INLINE static float fade_scaling_factor_for_z(const float &rz) {
-        UNUSED(rz);
-        return 1;
-      }
+      FORCE_INLINE static float fade_scaling_factor_for_z(const float&) { return 1; }
 
-      FORCE_INLINE static bool leveling_active_at_z(const float &rz) { UNUSED(rz); return true; }
+      FORCE_INLINE static bool leveling_active_at_z(const float&) { return true; }
 
     #endif
 
     #if ENABLED(SKEW_CORRECTION)
 
       FORCE_INLINE static void skew(float &cx, float &cy, const float &cz) {
         if (WITHIN(cx, X_MIN_POS + 1, X_MAX_POS) && WITHIN(cy, Y_MIN_POS + 1, Y_MAX_POS)) {
           const float sx = cx - cy * skew_factor.xy - cz * (skew_factor.xz - (skew_factor.xy * skew_factor.yz)),
                       sy = cy - cz * skew_factor.yz;
           if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 2f3ee471d6..c18b7753e6 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -33,31 +33,36 @@
 #include "../Marlin.h"
 
 #include "motion.h"
 #include "../gcode/queue.h"
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
 #if ABL_PLANAR
-  #include "../libs/vector_3.h"
+  #include "../libs/vector_3.h" // for matrix_3x3
 #endif
 
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"
 #endif
 
+// Feedrate for manual moves
+#ifdef MANUAL_FEEDRATE
+  constexpr xyze_feedrate_t manual_feedrate_mm_m = MANUAL_FEEDRATE;
+#endif
+
 enum BlockFlagBit : char {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).
   BLOCK_BIT_NOMINAL_LENGTH,
 
   // The block is segment 2+ of a longer move
@@ -88,29 +93,22 @@ typedef struct block_t {
   volatile uint8_t flag;                    // Block flags (See BlockFlag enum above) - Modified by ISR and main thread!
 
   // Fields used by the motion planner to manage acceleration
   float nominal_speed_sqr,                  // The nominal speed for this block in (mm/sec)^2
         entry_speed_sqr,                    // Entry speed at previous-current junction in (mm/sec)^2
         max_entry_speed_sqr,                // Maximum allowable junction entry speed in (mm/sec)^2
         millimeters,                        // The total travel of this block in mm
         acceleration;                       // acceleration mm/sec^2
 
   union {
-    // Data used by all move blocks
-    struct {
-      // Fields used by the Bresenham algorithm for tracing the line
-      uint32_t steps[NUM_AXIS];             // Step count along each axis
-    };
-    // Data used by all sync blocks
-    struct {
-      int32_t position[NUM_AXIS];           // New position to force when this sync block is executed
-    };
+    abce_ulong_t steps;                     // Step count along each axis
+    abce_long_t position;                   // New position to force when this sync block is executed
   };
   uint32_t step_event_count;                // The number of step events required to complete this block
 
   #if EXTRUDERS > 1
     uint8_t extruder;                       // The extruder to move (if E move)
   #else
     static constexpr uint8_t extruder = 0;
   #endif
 
   #if ENABLED(MIXING_EXTRUDER)
@@ -252,71 +250,70 @@ class Planner {
       #if ENABLED(LIN_ADVANCE)
         static float max_e_jerk                 // Calculated from junction_deviation_mm
           #if ENABLED(DISTINCT_E_FACTORS)
             [EXTRUDERS]
           #endif
         ;
       #endif
     #endif
 
     #if HAS_CLASSIC_JERK
-      static float max_jerk[
-        #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
-          XYZ                                    // (mm/s^2) M205 XYZ - The largest speed change requiring no acceleration.
-        #else
-          XYZE                                   // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
-        #endif
-      ];
+      #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
+        static xyz_pos_t max_jerk;              // (mm/s^2) M205 XYZ - The largest speed change requiring no acceleration.
+      #else
+        static xyze_pos_t max_jerk;             // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
+      #endif
     #endif
 
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
       #if ABL_PLANAR
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
+        static constexpr xy_pos_t level_fulcrum = { X_TILT_FULCRUM, Y_TILT_FULCRUM };
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         static float z_fade_height, inverse_z_fade_height;
       #endif
     #else
       static constexpr bool leveling_active = false;
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       static float extruder_advance_K[EXTRUDERS];
     #endif
 
     #if HAS_POSITION_FLOAT
-      static float position_float[XYZE];
+      static xyze_pos_t position_float;
     #endif
 
     #if IS_KINEMATIC
-      static float position_cart[XYZE];
+      static xyze_pos_t position_cart;
     #endif
 
     static skew_factor_t skew_factor;
 
     #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
       static bool abort_on_endstop_hit;
     #endif
 
   private:
 
     /**
      * The current position of the tool in absolute steps
      * Recalculated if any axis_steps_per_mm are changed by gcode
      */
-    static int32_t position[NUM_AXIS];
+    static xyze_long_t position;
 
     /**
      * Speed of previous path line segment
      */
-    static float previous_speed[NUM_AXIS];
+    static xyze_float_t previous_speed;
 
     /**
      * Nominal speed of previous path line segment (mm/s)^2
      */
     static float previous_nominal_speed_sqr;
 
     /**
      * Limit where 64bit math is necessary for acceleration calculation
      */
     static uint32_t cutoff_long;
@@ -331,21 +328,21 @@ class Planner {
        */
       static uint8_t g_uc_extruder_last_move[EXTRUDERS];
     #endif // DISABLE_INACTIVE_EXTRUDER
 
     #ifdef XY_FREQUENCY_LIMIT
       // Used for the frequency limit
       #define MAX_FREQ_TIME_US (uint32_t)(1000000.0 / XY_FREQUENCY_LIMIT)
       // Old direction bits. Used for speed calculations
       static unsigned char old_direction_bits;
       // Segment times (in ¬µs). Used for speed calculations
-      static uint32_t axis_segment_time_us[2][3];
+      static xy_ulong_t axis_segment_time_us[3];
     #endif
 
     #if HAS_SPI_LCD
       volatile static uint32_t block_buffer_runtime_us; //Theoretical block buffer runtime in ¬µs
     #endif
 
   public:
 
     /**
      * Instance Methods
@@ -447,79 +444,79 @@ class Planner {
 
       FORCE_INLINE static void skew(float &cx, float &cy, const float &cz) {
         if (WITHIN(cx, X_MIN_POS + 1, X_MAX_POS) && WITHIN(cy, Y_MIN_POS + 1, Y_MAX_POS)) {
           const float sx = cx - cy * skew_factor.xy - cz * (skew_factor.xz - (skew_factor.xy * skew_factor.yz)),
                       sy = cy - cz * skew_factor.yz;
           if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {
             cx = sx; cy = sy;
           }
         }
       }
-      FORCE_INLINE static void skew(float (&raw)[XYZ]) { skew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
-      FORCE_INLINE static void skew(float (&raw)[XYZE]) { skew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
+      FORCE_INLINE static void skew(xyz_pos_t &raw) { skew(raw.x, raw.y, raw.z); }
 
       FORCE_INLINE static void unskew(float &cx, float &cy, const float &cz) {
         if (WITHIN(cx, X_MIN_POS, X_MAX_POS) && WITHIN(cy, Y_MIN_POS, Y_MAX_POS)) {
           const float sx = cx + cy * skew_factor.xy + cz * skew_factor.xz,
                       sy = cy + cz * skew_factor.yz;
           if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {
             cx = sx; cy = sy;
           }
         }
       }
-      FORCE_INLINE static void unskew(float (&raw)[XYZ]) { unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
-      FORCE_INLINE static void unskew(float (&raw)[XYZE]) { unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
+      FORCE_INLINE static void unskew(xyz_pos_t &raw) { unskew(raw.x, raw.y, raw.z); }
 
     #endif // SKEW_CORRECTION
 
     #if HAS_LEVELING
       /**
        * Apply leveling to transform a cartesian position
        * as it will be given to the planner and steppers.
        */
-      static void apply_leveling(float &rx, float &ry, float &rz);
-      FORCE_INLINE static void apply_leveling(float (&raw)[XYZ]) { apply_leveling(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
-      FORCE_INLINE static void apply_leveling(float (&raw)[XYZE]) { apply_leveling(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
-
-      static void unapply_leveling(float raw[XYZ]);
+      static void apply_leveling(xyz_pos_t &raw);
+      static void unapply_leveling(xyz_pos_t &raw);
+      FORCE_INLINE static void force_unapply_leveling(xyz_pos_t &raw) {
+        leveling_active = true;
+        unapply_leveling(raw);
+        leveling_active = false;
+      }
     #endif
 
     #if ENABLED(FWRETRACT)
       static void apply_retract(float &rz, float &e);
-      FORCE_INLINE static void apply_retract(float (&raw)[XYZE]) { apply_retract(raw[Z_AXIS], raw[E_AXIS]); }
+      FORCE_INLINE static void apply_retract(xyze_pos_t &raw) { apply_retract(raw.z, raw.e); }
       static void unapply_retract(float &rz, float &e);
-      FORCE_INLINE static void unapply_retract(float (&raw)[XYZE]) { unapply_retract(raw[Z_AXIS], raw[E_AXIS]); }
+      FORCE_INLINE static void unapply_retract(xyze_pos_t &raw) { unapply_retract(raw.z, raw.e); }
     #endif
 
     #if HAS_POSITION_MODIFIERS
-      FORCE_INLINE static void apply_modifiers(float (&pos)[XYZE]
+      FORCE_INLINE static void apply_modifiers(xyze_pos_t &pos
         #if HAS_LEVELING
           , bool leveling =
           #if PLANNER_LEVELING
             true
           #else
             false
           #endif
         #endif
       ) {
         #if ENABLED(SKEW_CORRECTION)
           skew(pos);
         #endif
         #if HAS_LEVELING
           if (leveling) apply_leveling(pos);
         #endif
         #if ENABLED(FWRETRACT)
           apply_retract(pos);
         #endif
       }
 
-      FORCE_INLINE static void unapply_modifiers(float (&pos)[XYZE]
+      FORCE_INLINE static void unapply_modifiers(xyze_pos_t &pos
         #if HAS_LEVELING
           , bool leveling =
           #if PLANNER_LEVELING
             true
           #else
             false
           #endif
         #endif
       ) {
         #if ENABLED(FWRETRACT)
@@ -571,49 +568,49 @@ class Planner {
      *
      * Add a new linear movement to the buffer (in terms of steps).
      *
      *  target      - target position in steps units
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      *
      * Returns true if movement was buffered, false otherwise
      */
-    static bool _buffer_steps(const int32_t (&target)[XYZE]
+    static bool _buffer_steps(const xyze_long_t &target
       #if HAS_POSITION_FLOAT
-        , const float (&target_float)[ABCE]
+        , const xyze_pos_t &target_float
       #endif
       #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
-        , const float (&delta_mm_cart)[XYZE]
+        , const xyze_float_t &delta_mm_cart
       #endif
       , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
     /**
      * Planner::_populate_block
      *
      * Fills a new linear movement in the block (in terms of steps).
      *
      *  target      - target position in steps units
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      *
      * Returns true is movement is acceptable, false otherwise
      */
     static bool _populate_block(block_t * const block, bool split_move,
-        const int32_t (&target)[XYZE]
+        const xyze_long_t &target
       #if HAS_POSITION_FLOAT
-        , const float (&target_float)[XYZE]
+        , const xyze_pos_t &target_float
       #endif
       #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
-        , const float (&delta_mm_cart)[XYZE]
+        , const xyze_float_t &delta_mm_cart
       #endif
       , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
     /**
      * Planner::buffer_sync_block
      * Add a block to the buffer that just updates the position
      */
     static void buffer_sync_block();
 
@@ -631,32 +628,32 @@ class Planner {
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e     - target positions in mm and/or degrees
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      */
     static bool buffer_segment(const float &a, const float &b, const float &c, const float &e
       #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
-        , const float (&delta_mm_cart)[XYZE]
+        , const xyze_float_t &delta_mm_cart
       #endif
       , const feedRate_t &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
-    FORCE_INLINE static bool buffer_segment(const float (&abce)[ABCE]
+    FORCE_INLINE static bool buffer_segment(abce_pos_t &abce
       #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
-        , const float (&delta_mm_cart)[XYZE]
+        , const xyze_float_t &delta_mm_cart
       #endif
       , const feedRate_t &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     ) {
-      return buffer_segment(abce[A_AXIS], abce[B_AXIS], abce[C_AXIS], abce[E_AXIS]
+      return buffer_segment(abce.a, abce.b, abce.c, abce.e
         #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
           , delta_mm_cart
         #endif
         , fr_mm_s, extruder, millimeters);
     }
 
   public:
 
     /**
      * Add a new linear movement to the buffer.
@@ -668,57 +665,57 @@ class Planner {
      *  extruder     - target extruder
      *  millimeters  - the length of the movement, if known
      *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
      */
     static bool buffer_line(const float &rx, const float &ry, const float &rz, const float &e, const feedRate_t &fr_mm_s, const uint8_t extruder, const float millimeters=0.0
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         , const float &inv_duration=0.0
       #endif
     );
 
-    FORCE_INLINE static bool buffer_line(const float (&cart)[XYZE], const feedRate_t &fr_mm_s, const uint8_t extruder, const float millimeters=0.0
+    FORCE_INLINE static bool buffer_line(const xyze_pos_t &cart, const feedRate_t &fr_mm_s, const uint8_t extruder, const float millimeters=0.0
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         , const float &inv_duration=0.0
       #endif
     ) {
-      return buffer_line(cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS], cart[E_AXIS], fr_mm_s, extruder, millimeters
+      return buffer_line(cart.x, cart.y, cart.z, cart.e, fr_mm_s, extruder, millimeters
         #if ENABLED(SCARA_FEEDRATE_SCALING)
           , inv_duration
         #endif
       );
     }
 
     /**
      * Set the planner.position and individual stepper positions.
      * Used by G92, G28, G29, and other procedures.
      *
      * The supplied position is in the cartesian coordinate space and is
      * translated in to machine space as needed. Modifiers such as leveling
      * and skew are also applied.
      *
      * Multiplies by axis_steps_per_mm[] and does necessary conversion
      * for COREXY / COREXZ / COREYZ to set the corresponding stepper positions.
      *
      * Clears previous speed values.
      */
     static void set_position_mm(const float &rx, const float &ry, const float &rz, const float &e);
-    FORCE_INLINE static void set_position_mm(const float (&cart)[XYZE]) { set_position_mm(cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS], cart[E_AXIS]); }
+    FORCE_INLINE static void set_position_mm(const xyze_pos_t &cart) { set_position_mm(cart.x, cart.y, cart.z, cart.e); }
     static void set_e_position_mm(const float &e);
 
     /**
      * Set the planner.position and individual stepper positions.
      *
      * The supplied position is in machine space, and no additional
      * conversions are applied.
      */
     static void set_machine_position_mm(const float &a, const float &b, const float &c, const float &e);
-    FORCE_INLINE static void set_machine_position_mm(const float (&abce)[ABCE]) { set_machine_position_mm(abce[A_AXIS], abce[B_AXIS], abce[C_AXIS], abce[E_AXIS]); }
+    FORCE_INLINE static void set_machine_position_mm(const abce_pos_t &abce) { set_machine_position_mm(abce.a, abce.b, abce.c, abce.e); }
 
     /**
      * Get an axis position according to stepper position(s)
      * For CORE machines apply translation from ABC to XYZ.
      */
     static float get_axis_position_mm(const AxisEnum axis);
 
     // SCARA AB axes are in degrees, not mm
     #if IS_SCARA
       FORCE_INLINE static float get_axis_position_degrees(const AxisEnum axis) { return get_axis_position_mm(axis); }
@@ -935,28 +932,27 @@ class Planner {
 
     static void reverse_pass();
     static void forward_pass();
 
     static void recalculate_trapezoids();
 
     static void recalculate();
 
     #if ENABLED(JUNCTION_DEVIATION)
 
-      FORCE_INLINE static void normalize_junction_vector(float (&vector)[XYZE]) {
+      FORCE_INLINE static void normalize_junction_vector(xyze_float_t &vector) {
         float magnitude_sq = 0;
         LOOP_XYZE(idx) if (vector[idx]) magnitude_sq += sq(vector[idx]);
-        const float inv_magnitude = RSQRT(magnitude_sq);
-        LOOP_XYZE(idx) vector[idx] *= inv_magnitude;
+        vector *= RSQRT(magnitude_sq);
       }
 
-      FORCE_INLINE static float limit_value_by_axis_maximum(const float &max_value, float (&unit_vec)[XYZE]) {
+      FORCE_INLINE static float limit_value_by_axis_maximum(const float &max_value, xyze_float_t &unit_vec) {
         float limit_value = max_value;
         LOOP_XYZE(idx) if (unit_vec[idx]) // Avoid divide by zero
           NOMORE(limit_value, ABS(settings.max_acceleration_mm_per_s2[idx] / unit_vec[idx]));
         return limit_value;
       }
 
     #endif // JUNCTION_DEVIATION
 };
 
 #define PLANNER_XY_FEEDRATE() (_MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]))

commit 455dabb18334c89878a75be62bccebd9f537574d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 26 01:28:09 2019 -0500

    Add a feedRate_t data type (#15349)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 79efe349a1..2f3ee471d6 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -163,29 +163,29 @@ typedef struct block_t {
     uint32_t sdpos;
   #endif
 
 } block_t;
 
 #define HAS_POSITION_FLOAT ANY(LIN_ADVANCE, SCARA_FEEDRATE_SCALING, GRADIENT_MIX)
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 typedef struct {
-  uint32_t max_acceleration_mm_per_s2[XYZE_N],  // (mm/s^2) M201 XYZE
-           min_segment_time_us;                 // (¬µs) M205 B
-  float axis_steps_per_mm[XYZE_N],              // (steps) M92 XYZE - Steps per millimeter
-        max_feedrate_mm_s[XYZE_N],              // (mm/s) M203 XYZE - Max speeds
-        acceleration,                           // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
-        retract_acceleration,                   // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
-        travel_acceleration,                    // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
-        min_feedrate_mm_s,                      // (mm/s) M205 S - Minimum linear feedrate
-        min_travel_feedrate_mm_s;               // (mm/s) M205 T - Minimum travel feedrate
+   uint32_t max_acceleration_mm_per_s2[XYZE_N], // (mm/s^2) M201 XYZE
+            min_segment_time_us;                // (¬µs) M205 B
+      float axis_steps_per_mm[XYZE_N];          // (steps) M92 XYZE - Steps per millimeter
+ feedRate_t max_feedrate_mm_s[XYZE_N];          // (mm/s) M203 XYZE - Max speeds
+      float acceleration,                       // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
+            retract_acceleration,               // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
+            travel_acceleration;                // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
+ feedRate_t min_feedrate_mm_s,                  // (mm/s) M205 S - Minimum linear feedrate
+            min_travel_feedrate_mm_s;           // (mm/s) M205 T - Minimum travel feedrate
 } planner_settings_t;
 
 #if DISABLED(SKEW_CORRECTION)
   #define XY_SKEW_FACTOR 0
   #define XZ_SKEW_FACTOR 0
   #define YZ_SKEW_FACTOR 0
 #endif
 
 typedef struct {
   #if ENABLED(SKEW_CORRECTION_GCODE)
@@ -578,21 +578,21 @@ class Planner {
      *
      * Returns true if movement was buffered, false otherwise
      */
     static bool _buffer_steps(const int32_t (&target)[XYZE]
       #if HAS_POSITION_FLOAT
         , const float (&target_float)[ABCE]
       #endif
       #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
         , const float (&delta_mm_cart)[XYZE]
       #endif
-      , float fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
+      , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
     /**
      * Planner::_populate_block
      *
      * Fills a new linear movement in the block (in terms of steps).
      *
      *  target      - target position in steps units
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
@@ -601,89 +601,88 @@ class Planner {
      * Returns true is movement is acceptable, false otherwise
      */
     static bool _populate_block(block_t * const block, bool split_move,
         const int32_t (&target)[XYZE]
       #if HAS_POSITION_FLOAT
         , const float (&target_float)[XYZE]
       #endif
       #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
         , const float (&delta_mm_cart)[XYZE]
       #endif
-      , float fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
+      , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
     /**
      * Planner::buffer_sync_block
      * Add a block to the buffer that just updates the position
      */
     static void buffer_sync_block();
 
   #if IS_KINEMATIC
     private:
 
       // Allow do_homing_move to access internal functions, such as buffer_segment.
-      friend void do_homing_move(const AxisEnum, const float, const float);
+      friend void do_homing_move(const AxisEnum, const float, const feedRate_t);
   #endif
 
     /**
      * Planner::buffer_segment
      *
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e     - target positions in mm and/or degrees
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      */
     static bool buffer_segment(const float &a, const float &b, const float &c, const float &e
       #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
         , const float (&delta_mm_cart)[XYZE]
       #endif
-      , const float &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
+      , const feedRate_t &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
     FORCE_INLINE static bool buffer_segment(const float (&abce)[ABCE]
       #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
         , const float (&delta_mm_cart)[XYZE]
       #endif
-      , const float &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
+      , const feedRate_t &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     ) {
       return buffer_segment(abce[A_AXIS], abce[B_AXIS], abce[C_AXIS], abce[E_AXIS]
         #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
           , delta_mm_cart
         #endif
         , fr_mm_s, extruder, millimeters);
     }
 
   public:
 
     /**
      * Add a new linear movement to the buffer.
-     * The target is cartesian, it's translated to delta/scara if
-     * needed.
-     *
+     * The target is cartesian. It's translated to
+     * delta/scara if needed.
      *
      *  rx,ry,rz,e   - target position in mm or degrees
      *  fr_mm_s      - (target) speed of the move (mm/s)
      *  extruder     - target extruder
      *  millimeters  - the length of the movement, if known
      *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
      */
-    static bool buffer_line(const float &rx, const float &ry, const float &rz, const float &e, const float &fr_mm_s, const uint8_t extruder, const float millimeters=0.0
+    static bool buffer_line(const float &rx, const float &ry, const float &rz, const float &e, const feedRate_t &fr_mm_s, const uint8_t extruder, const float millimeters=0.0
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         , const float &inv_duration=0.0
       #endif
     );
 
-    FORCE_INLINE static bool buffer_line(const float (&cart)[XYZE], const float &fr_mm_s, const uint8_t extruder, const float millimeters=0.0
+    FORCE_INLINE static bool buffer_line(const float (&cart)[XYZE], const feedRate_t &fr_mm_s, const uint8_t extruder, const float millimeters=0.0
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         , const float &inv_duration=0.0
       #endif
     ) {
       return buffer_line(cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS], cart[E_AXIS], fr_mm_s, extruder, millimeters
         #if ENABLED(SCARA_FEEDRATE_SCALING)
           , inv_duration
         #endif
       );
     }

commit ee7558a6228747a7502ab50e2817234fb8a6feb4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 26 01:15:35 2019 -0500

    Tweaks to Z fade behavior

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index cb74065d9d..79efe349a1 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -404,29 +404,27 @@ class Planner {
 
       /**
        * Get the Z leveling fade factor based on the given Z height,
        * re-calculating only when needed.
        *
        *  Returns 1.0 if planner.z_fade_height is 0.0.
        *  Returns 0.0 if Z is past the specified 'Fade Height'.
        */
       static inline float fade_scaling_factor_for_z(const float &rz) {
         static float z_fade_factor = 1;
-        if (z_fade_height) {
-          if (rz >= z_fade_height) return 0;
-          if (last_fade_z != rz) {
-            last_fade_z = rz;
-            z_fade_factor = 1 - rz * inverse_z_fade_height;
-          }
-          return z_fade_factor;
+        if (!z_fade_height) return 1;
+        if (rz >= z_fade_height) return 0;
+        if (last_fade_z != rz) {
+          last_fade_z = rz;
+          z_fade_factor = 1 - rz * inverse_z_fade_height;
         }
-        return 1;
+        return z_fade_factor;
       }
 
       FORCE_INLINE static void force_fade_recalc() { last_fade_z = -999.999f; }
 
       FORCE_INLINE static void set_z_fade_height(const float &zfh) {
         z_fade_height = zfh > 0 ? zfh : 0;
         inverse_z_fade_height = RECIPROCAL(z_fade_height);
         force_fade_recalc();
       }
 

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 16486b4076..cb74065d9d 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -500,44 +500,42 @@ class Planner {
             true
           #else
             false
           #endif
         #endif
       ) {
         #if ENABLED(SKEW_CORRECTION)
           skew(pos);
         #endif
         #if HAS_LEVELING
-          if (leveling)
-            apply_leveling(pos);
+          if (leveling) apply_leveling(pos);
         #endif
         #if ENABLED(FWRETRACT)
           apply_retract(pos);
         #endif
       }
 
       FORCE_INLINE static void unapply_modifiers(float (&pos)[XYZE]
         #if HAS_LEVELING
           , bool leveling =
           #if PLANNER_LEVELING
             true
           #else
             false
           #endif
         #endif
       ) {
         #if ENABLED(FWRETRACT)
           unapply_retract(pos);
         #endif
         #if HAS_LEVELING
-          if (leveling)
-            unapply_leveling(pos);
+          if (leveling) unapply_leveling(pos);
         #endif
         #if ENABLED(SKEW_CORRECTION)
           unskew(pos);
         #endif
       }
     #endif // HAS_POSITION_MODIFIERS
 
     // Number of moves currently in the planner including the busy block, if any
     FORCE_INLINE static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail); }
 

commit c590e8ac05c3b417aa42ecd1f4967c4f70cfdd71
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 18:52:41 2019 -0500

    Improve Power-loss Recovery (#15135)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 2de0336251..16486b4076 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -152,20 +152,24 @@ typedef struct block_t {
   #endif
 
   #if ENABLED(BARICUDA)
     uint8_t valve_pressure, e_to_p_pressure;
   #endif
 
   #if HAS_SPI_LCD
     uint32_t segment_time_us;
   #endif
 
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    uint32_t sdpos;
+  #endif
+
 } block_t;
 
 #define HAS_POSITION_FLOAT ANY(LIN_ADVANCE, SCARA_FEEDRATE_SCALING, GRADIENT_MIX)
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 typedef struct {
   uint32_t max_acceleration_mm_per_s2[XYZE_N],  // (mm/s^2) M201 XYZE
            min_segment_time_us;                 // (¬µs) M205 B
   float axis_steps_per_mm[XYZE_N],              // (steps) M92 XYZE - Steps per millimeter

commit 75927e17dd2114c14a593c12394d941eff684685
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 18:48:58 2019 -0500

    Filament Width Sensor singleton (#15191)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 2f9d52698b..2de0336251 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -368,21 +368,28 @@ class Planner {
       }
     #endif
 
     // Manage fans, paste pressure, etc.
     static void check_axes_activity();
 
     // Update multipliers based on new diameter measurements
     static void calculate_volumetric_multipliers();
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      void calculate_volumetric_for_width_sensor(const int8_t encoded_ratio);
+      void apply_filament_width_sensor(const int8_t encoded_ratio);
+
+      static inline float volumetric_percent(const bool vol) {
+        return 100.0f * (vol
+            ? volumetric_area_nominal / volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
+            : volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]
+        );
+      }
     #endif
 
     #if DISABLED(NO_VOLUMETRICS)
 
       FORCE_INLINE static void set_filament_size(const uint8_t e, const float &v) {
         filament_size[e] = v;
         // make sure all extruders have some sane value for the filament size
         for (uint8_t i = 0; i < COUNT(filament_size); i++)
           if (!filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;
       }

commit 584c86bed1d81548da03681bd3b3c6bd54ae0fe3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 02:20:49 2019 -0500

    More "zero extruders" changes (#15213)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 77cde6e2bf..2f9d52698b 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -219,23 +219,24 @@ class Planner {
                             block_buffer_planned,   // Index of the optimally planned block
                             block_buffer_tail;      // Index of the busy block, if any
     static uint16_t cleaning_buffer_counter;        // A counter to disable queuing of blocks
     static uint8_t delay_before_delivering;         // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;                 // Respond to extruder change
     #endif
 
-    static int16_t flow_percentage[EXTRUDERS];      // Extrusion factor for each extruder
-
-    static float e_factor[EXTRUDERS];               // The flow percentage and volumetric multiplier combine to scale E movement
+    #if EXTRUDERS
+      static int16_t flow_percentage[EXTRUDERS];    // Extrusion factor for each extruder
+      static float e_factor[EXTRUDERS];             // The flow percentage and volumetric multiplier combine to scale E movement
+    #endif
 
     #if DISABLED(NO_VOLUMETRICS)
       static float filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
                    volumetric_area_nominal,           // Nominal cross-sectional area
                    volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                       // May be auto-adjusted by a filament width sensor
     #endif
 
     static planner_settings_t settings;
 
@@ -350,27 +351,29 @@ class Planner {
 
     void init();
 
     /**
      * Static (class) Methods
      */
 
     static void reset_acceleration_rates();
     static void refresh_positioning();
 
-    FORCE_INLINE static void refresh_e_factor(const uint8_t e) {
-      e_factor[e] = (flow_percentage[e] * 0.01f
-        #if DISABLED(NO_VOLUMETRICS)
-          * volumetric_multiplier[e]
-        #endif
-      );
-    }
+    #if EXTRUDERS
+      FORCE_INLINE static void refresh_e_factor(const uint8_t e) {
+        e_factor[e] = (flow_percentage[e] * 0.01f
+          #if DISABLED(NO_VOLUMETRICS)
+            * volumetric_multiplier[e]
+          #endif
+        );
+      }
+    #endif
 
     // Manage fans, paste pressure, etc.
     static void check_axes_activity();
 
     // Update multipliers based on new diameter measurements
     static void calculate_volumetric_multipliers();
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       void calculate_volumetric_for_width_sensor(const int8_t encoded_ratio);
     #endif

commit b7796bcce6a1d375b57d72db5fd4dd03d66fcceb
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Aug 28 01:51:01 2019 -0400

    Disable steppers on M112 (#15065)
    
    And change verbiage to not refer to "Emergency Stop."

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 38884cffa9..77cde6e2bf 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -708,22 +708,22 @@ class Planner {
      * Get an axis position according to stepper position(s)
      * For CORE machines apply translation from ABC to XYZ.
      */
     static float get_axis_position_mm(const AxisEnum axis);
 
     // SCARA AB axes are in degrees, not mm
     #if IS_SCARA
       FORCE_INLINE static float get_axis_position_degrees(const AxisEnum axis) { return get_axis_position_mm(axis); }
     #endif
 
-    // Called to force a quick stop of the machine (for example, when an emergency
-    // stop is required, or when endstops are hit)
+    // Called to force a quick stop of the machine (for example, when
+    // a Full Shutdown is required, or when endstops are hit)
     static void quick_stop();
 
     // Called when an endstop is triggered. Causes the machine to stop inmediately
     static void endstop_triggered(const AxisEnum axis);
 
     // Triggered position of an axis in mm (not core-savvy)
     static float triggered_position_mm(const AxisEnum axis);
 
     // Block until all buffered steps are executed / cleaned
     static void synchronize();

commit 587d4a63731be776bb3deba878bd0509d386a72a
Author: AnHardt <github@kitelab.de>
Date:   Sat Aug 17 04:17:10 2019 +0200

    Repair display throttling (#14960)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 9df4820576..38884cffa9 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -148,21 +148,23 @@ typedef struct block_t {
            acceleration_steps_per_s2;       // acceleration steps/sec^2
 
   #if FAN_COUNT > 0
     uint8_t fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
     uint8_t valve_pressure, e_to_p_pressure;
   #endif
 
-  uint32_t segment_time_us;
+  #if HAS_SPI_LCD
+    uint32_t segment_time_us;
+  #endif
 
 } block_t;
 
 #define HAS_POSITION_FLOAT ANY(LIN_ADVANCE, SCARA_FEEDRATE_SCALING, GRADIENT_MIX)
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 typedef struct {
   uint32_t max_acceleration_mm_per_s2[XYZE_N],  // (mm/s^2) M201 XYZE
            min_segment_time_us;                 // (¬µs) M205 B

commit eae543adf34268505f9321b7576495db20293c09
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jul 29 18:45:01 2019 -0500

    Apply HAS_SPI_LCD as needed

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index e1766b566e..9df4820576 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -327,21 +327,21 @@ class Planner {
 
     #ifdef XY_FREQUENCY_LIMIT
       // Used for the frequency limit
       #define MAX_FREQ_TIME_US (uint32_t)(1000000.0 / XY_FREQUENCY_LIMIT)
       // Old direction bits. Used for speed calculations
       static unsigned char old_direction_bits;
       // Segment times (in ¬µs). Used for speed calculations
       static uint32_t axis_segment_time_us[2][3];
     #endif
 
-    #if ENABLED(ULTRA_LCD)
+    #if HAS_SPI_LCD
       volatile static uint32_t block_buffer_runtime_us; //Theoretical block buffer runtime in ¬µs
     #endif
 
   public:
 
     /**
      * Instance Methods
      */
 
     Planner();
@@ -766,54 +766,54 @@ class Planner {
           if (nr_moves < 3 && delay_before_delivering) return nullptr;
           delay_before_delivering = 0;
         }
 
         // If we are here, there is no excuse to deliver the block
         block_t * const block = &block_buffer[block_buffer_tail];
 
         // No trapezoid calculated? Don't execute yet.
         if (TEST(block->flag, BLOCK_BIT_RECALCULATE)) return nullptr;
 
-        #if ENABLED(ULTRA_LCD)
+        #if HAS_SPI_LCD
           block_buffer_runtime_us -= block->segment_time_us; // We can't be sure how long an active block will take, so don't count it.
         #endif
 
         // As this block is busy, advance the nonbusy block pointer
         block_buffer_nonbusy = next_block_index(block_buffer_tail);
 
         // Push block_buffer_planned pointer, if encountered.
         if (block_buffer_tail == block_buffer_planned)
           block_buffer_planned = block_buffer_nonbusy;
 
         // Return the block
         return block;
       }
 
       // The queue became empty
-      #if ENABLED(ULTRA_LCD)
+      #if HAS_SPI_LCD
         clear_block_buffer_runtime(); // paranoia. Buffer is empty now - so reset accumulated time to zero.
       #endif
 
       return nullptr;
     }
 
     /**
      * "Discard" the block and "release" the memory.
      * Called when the current block is no longer needed.
      * NB: There MUST be a current block to call this function!!
      */
     FORCE_INLINE static void discard_current_block() {
       if (has_blocks_queued())
         block_buffer_tail = next_block_index(block_buffer_tail);
     }
 
-    #if ENABLED(ULTRA_LCD)
+    #if HAS_SPI_LCD
 
       static uint16_t block_buffer_runtime() {
         #ifdef __AVR__
           // Protect the access to the variable. Only required for AVR, as
           //  any 32bit CPU offers atomic access to 32bit variables
           bool was_enabled = STEPPER_ISR_ENABLED();
           if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
         #endif
 
         millis_t bbru = block_buffer_runtime_us;

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 679ecbe8a3..e1766b566e 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -941,13 +941,13 @@ class Planner {
       FORCE_INLINE static float limit_value_by_axis_maximum(const float &max_value, float (&unit_vec)[XYZE]) {
         float limit_value = max_value;
         LOOP_XYZE(idx) if (unit_vec[idx]) // Avoid divide by zero
           NOMORE(limit_value, ABS(settings.max_acceleration_mm_per_s2[idx] / unit_vec[idx]));
         return limit_value;
       }
 
     #endif // JUNCTION_DEVIATION
 };
 
-#define PLANNER_XY_FEEDRATE() (MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]))
+#define PLANNER_XY_FEEDRATE() (_MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]))
 
 extern Planner planner;

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 5bcb37f39a..679ecbe8a3 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit 4c872a01f284cbf181f52c84e2ba6b4618e62556
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 19 00:00:19 2019 -0500

    G-code queue singleton, front injection (#14236)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index bebcf113a3..5bcb37f39a 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -728,21 +728,21 @@ class Planner {
 
     // Wait for moves to finish and disable all steppers
     static void finish_and_disable();
 
     // Periodic tick to handle cleaning timeouts
     // Called from the Temperature ISR at ~1kHz
     static void tick() {
       if (cleaning_buffer_counter) {
         --cleaning_buffer_counter;
         #if ENABLED(SD_FINISHED_STEPPERRELEASE) && defined(SD_FINISHED_RELEASECOMMAND)
-          if (!cleaning_buffer_counter) enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
+          if (!cleaning_buffer_counter) queue.inject_P(PSTR(SD_FINISHED_RELEASECOMMAND));
         #endif
       }
     }
 
     /**
      * Does the buffer have any blocks queued?
      */
     FORCE_INLINE static bool has_blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
     /**

commit 0ca2073625fcf1eb35de8c37d49960bf20bed4b6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 10 17:25:43 2019 -0500

    ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED => SD_ABORT_ON_ENDSTOP_HIT

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 39309a3e95..bebcf113a3 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -280,21 +280,21 @@ class Planner {
     #if HAS_POSITION_FLOAT
       static float position_float[XYZE];
     #endif
 
     #if IS_KINEMATIC
       static float position_cart[XYZE];
     #endif
 
     static skew_factor_t skew_factor;
 
-    #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+    #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
       static bool abort_on_endstop_hit;
     #endif
 
   private:
 
     /**
      * The current position of the tool in absolute steps
      * Recalculated if any axis_steps_per_mm are changed by gcode
      */
     static int32_t position[NUM_AXIS];

commit ad4ffa1d2fbd17ac09c816ba2052cdf714261042
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 9 11:45:55 2019 -0500

    Use C++ language supported 'nullptr' (#13944)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 5e24ce6139..39309a3e95 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -739,46 +739,46 @@ class Planner {
         #endif
       }
     }
 
     /**
      * Does the buffer have any blocks queued?
      */
     FORCE_INLINE static bool has_blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
     /**
-     * The current block. NULL if the buffer is empty.
+     * The current block. nullptr if the buffer is empty.
      * This also marks the block as busy.
      * WARNING: Called from Stepper ISR context!
      */
     static block_t* get_current_block() {
 
       // Get the number of moves in the planner queue so far
       const uint8_t nr_moves = movesplanned();
 
       // If there are any moves queued ...
       if (nr_moves) {
 
         // If there is still delay of delivery of blocks running, decrement it
         if (delay_before_delivering) {
           --delay_before_delivering;
           // If the number of movements queued is less than 3, and there is still time
           //  to wait, do not deliver anything
-          if (nr_moves < 3 && delay_before_delivering) return NULL;
+          if (nr_moves < 3 && delay_before_delivering) return nullptr;
           delay_before_delivering = 0;
         }
 
         // If we are here, there is no excuse to deliver the block
         block_t * const block = &block_buffer[block_buffer_tail];
 
         // No trapezoid calculated? Don't execute yet.
-        if (TEST(block->flag, BLOCK_BIT_RECALCULATE)) return NULL;
+        if (TEST(block->flag, BLOCK_BIT_RECALCULATE)) return nullptr;
 
         #if ENABLED(ULTRA_LCD)
           block_buffer_runtime_us -= block->segment_time_us; // We can't be sure how long an active block will take, so don't count it.
         #endif
 
         // As this block is busy, advance the nonbusy block pointer
         block_buffer_nonbusy = next_block_index(block_buffer_tail);
 
         // Push block_buffer_planned pointer, if encountered.
         if (block_buffer_tail == block_buffer_planned)
@@ -786,21 +786,21 @@ class Planner {
 
         // Return the block
         return block;
       }
 
       // The queue became empty
       #if ENABLED(ULTRA_LCD)
         clear_block_buffer_runtime(); // paranoia. Buffer is empty now - so reset accumulated time to zero.
       #endif
 
-      return NULL;
+      return nullptr;
     }
 
     /**
      * "Discard" the block and "release" the memory.
      * Called when the current block is no longer needed.
      * NB: There MUST be a current block to call this function!!
      */
     FORCE_INLINE static void discard_current_block() {
       if (has_blocks_queued())
         block_buffer_tail = next_block_index(block_buffer_tail);

commit 15357af67ceb74b14606eba9fbb75d20914f8909
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri May 3 22:53:15 2019 -0600

    Backlash cleanup (#13659)
    
    ‚Ä¶And save backlash, fil. sensor, ExtUI userdata to EEPROM.

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index a95c3f2605..5e24ce6139 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -331,24 +331,20 @@ class Planner {
       // Old direction bits. Used for speed calculations
       static unsigned char old_direction_bits;
       // Segment times (in ¬µs). Used for speed calculations
       static uint32_t axis_segment_time_us[2][3];
     #endif
 
     #if ENABLED(ULTRA_LCD)
       volatile static uint32_t block_buffer_runtime_us; //Theoretical block buffer runtime in ¬µs
     #endif
 
-    #if ENABLED(BACKLASH_COMPENSATION)
-      static void add_backlash_correction_steps(const int32_t da, const int32_t db, const int32_t dc, const uint8_t dm, block_t * const block);
-    #endif
-
   public:
 
     /**
      * Instance Methods
      */
 
     Planner();
 
     void init();
 

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 44be1413cc..a95c3f2605 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -152,21 +152,21 @@ typedef struct block_t {
   #endif
 
   #if ENABLED(BARICUDA)
     uint8_t valve_pressure, e_to_p_pressure;
   #endif
 
   uint32_t segment_time_us;
 
 } block_t;
 
-#define HAS_POSITION_FLOAT (ENABLED(LIN_ADVANCE) || ENABLED(SCARA_FEEDRATE_SCALING) || ENABLED(GRADIENT_MIX))
+#define HAS_POSITION_FLOAT ANY(LIN_ADVANCE, SCARA_FEEDRATE_SCALING, GRADIENT_MIX)
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 typedef struct {
   uint32_t max_acceleration_mm_per_s2[XYZE_N],  // (mm/s^2) M201 XYZE
            min_segment_time_us;                 // (¬µs) M205 B
   float axis_steps_per_mm[XYZE_N],              // (steps) M92 XYZE - Steps per millimeter
         max_feedrate_mm_s[XYZE_N],              // (mm/s) M203 XYZE - Max speeds
         acceleration,                           // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
         retract_acceleration,                   // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
@@ -246,21 +246,21 @@ class Planner {
         static float max_e_jerk                 // Calculated from junction_deviation_mm
           #if ENABLED(DISTINCT_E_FACTORS)
             [EXTRUDERS]
           #endif
         ;
       #endif
     #endif
 
     #if HAS_CLASSIC_JERK
       static float max_jerk[
-        #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+        #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
           XYZ                                    // (mm/s^2) M205 XYZ - The largest speed change requiring no acceleration.
         #else
           XYZE                                   // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
         #endif
       ];
     #endif
 
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
       #if ABL_PLANAR
@@ -854,21 +854,21 @@ class Planner {
 
     #endif
 
     #if ENABLED(AUTOTEMP)
       static float autotemp_min, autotemp_max, autotemp_factor;
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
     #endif
 
-    #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+    #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
       FORCE_INLINE static void recalculate_max_e_jerk() {
         #define GET_MAX_E_JERK(N) SQRT(SQRT(0.5) * junction_deviation_mm * (N) * RECIPROCAL(1.0 - SQRT(0.5)))
         #if ENABLED(DISTINCT_E_FACTORS)
           for (uint8_t i = 0; i < EXTRUDERS; i++)
             max_e_jerk[i] = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS_N(i)]);
         #else
           max_e_jerk = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS]);
         #endif
       }
     #endif

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index e2fb227187..44be1413cc 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 6de3d3437849c0710881311bc9ad4069b0aee55d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 10 04:54:23 2019 -0600

    M166 Gradients, LCD Menu for 2-channel Mixer (Geeetech A10M/A20M) (#13022)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index c17fb197b6..e2fb227187 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -152,21 +152,21 @@ typedef struct block_t {
   #endif
 
   #if ENABLED(BARICUDA)
     uint8_t valve_pressure, e_to_p_pressure;
   #endif
 
   uint32_t segment_time_us;
 
 } block_t;
 
-#define HAS_POSITION_FLOAT (ENABLED(LIN_ADVANCE) || ENABLED(SCARA_FEEDRATE_SCALING))
+#define HAS_POSITION_FLOAT (ENABLED(LIN_ADVANCE) || ENABLED(SCARA_FEEDRATE_SCALING) || ENABLED(GRADIENT_MIX))
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 typedef struct {
   uint32_t max_acceleration_mm_per_s2[XYZE_N],  // (mm/s^2) M201 XYZE
            min_segment_time_us;                 // (¬µs) M205 B
   float axis_steps_per_mm[XYZE_N],              // (steps) M92 XYZE - Steps per millimeter
         max_feedrate_mm_s[XYZE_N],              // (mm/s) M203 XYZE - Max speeds
         acceleration,                           // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
         retract_acceleration,                   // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes

commit a5e33846916e5415146399d03eac334fc5cc71c8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 2 23:30:26 2019 -0600

    Pre-apply cosmetic changes to mixing

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 9f6acc2ae7..c17fb197b6 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -107,21 +107,21 @@ typedef struct block_t {
   };
   uint32_t step_event_count;                // The number of step events required to complete this block
 
   #if EXTRUDERS > 1
     uint8_t extruder;                       // The extruder to move (if E move)
   #else
     static constexpr uint8_t extruder = 0;
   #endif
 
   #if ENABLED(MIXING_EXTRUDER)
-    MIXER_BLOCK_DEFINITION;                 // Normalized color for the mixing steppers
+    MIXER_BLOCK_FIELD;                      // Normalized color for the mixing steppers
   #endif
 
   // Settings for the trapezoid generator
   uint32_t accelerate_until,                // The index of the step event on which to stop acceleration
            decelerate_after;                // The index of the step event on which to start decelerating
 
   #if ENABLED(S_CURVE_ACCELERATION)
     uint32_t cruise_rate,                   // The actual cruise rate to use, between end of the acceleration phase and start of deceleration phase
              acceleration_time,             // Acceleration time and deceleration time in STEP timer counts
              deceleration_time,

commit 19fea772e5eba0b850512123f10c9c72868d75a4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jan 11 19:37:20 2019 -0600

    Use E_AXIS_N where it makes sense

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 45c18365ab..9f6acc2ae7 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -859,21 +859,21 @@ class Planner {
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
     #endif
 
     #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
       FORCE_INLINE static void recalculate_max_e_jerk() {
         #define GET_MAX_E_JERK(N) SQRT(SQRT(0.5) * junction_deviation_mm * (N) * RECIPROCAL(1.0 - SQRT(0.5)))
         #if ENABLED(DISTINCT_E_FACTORS)
           for (uint8_t i = 0; i < EXTRUDERS; i++)
-            max_e_jerk[i] = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS + i]);
+            max_e_jerk[i] = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS_N(i)]);
         #else
           max_e_jerk = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS]);
         #endif
       }
     #endif
 
   private:
 
     /**
      * Get the index of the next / previous block in the ring buffer

commit 6a8fb0f25f65b2547a1f5cf723d523f5b3d4972c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Jan 4 12:30:56 2019 -0700

    Simplify backlash compensation code. (#12813)
    
    - Use `TEST(dm,axis)` to determine directions instead of doing comparisons.
    - Remove recomputation of `millimeters` and `delta_mm` since backlash compensation should not affect the distance over which material is extruded.

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 2592f45b54..45c18365ab 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -332,21 +332,21 @@ class Planner {
       static unsigned char old_direction_bits;
       // Segment times (in ¬µs). Used for speed calculations
       static uint32_t axis_segment_time_us[2][3];
     #endif
 
     #if ENABLED(ULTRA_LCD)
       volatile static uint32_t block_buffer_runtime_us; //Theoretical block buffer runtime in ¬µs
     #endif
 
     #if ENABLED(BACKLASH_COMPENSATION)
-      static void add_backlash_correction_steps(const int32_t da, const int32_t db, const int32_t dc, const uint8_t dm, block_t * const block, float (&delta_mm)[ABCE]);
+      static void add_backlash_correction_steps(const int32_t da, const int32_t db, const int32_t dc, const uint8_t dm, block_t * const block);
     #endif
 
   public:
 
     /**
      * Instance Methods
      */
 
     Planner();
 

commit b22716e938397d8beb64f5855b64f6fdb375b5d2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sat Dec 8 13:36:46 2018 -0700

    M425 Backlash Correction (#11061)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 4fe90b9fa7..2592f45b54 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -331,20 +331,24 @@ class Planner {
       // Old direction bits. Used for speed calculations
       static unsigned char old_direction_bits;
       // Segment times (in ¬µs). Used for speed calculations
       static uint32_t axis_segment_time_us[2][3];
     #endif
 
     #if ENABLED(ULTRA_LCD)
       volatile static uint32_t block_buffer_runtime_us; //Theoretical block buffer runtime in ¬µs
     #endif
 
+    #if ENABLED(BACKLASH_COMPENSATION)
+      static void add_backlash_correction_steps(const int32_t da, const int32_t db, const int32_t dc, const uint8_t dm, block_t * const block, float (&delta_mm)[ABCE]);
+    #endif
+
   public:
 
     /**
      * Instance Methods
      */
 
     Planner();
 
     void init();
 

commit 8be91677df714b6c28db5ebfee4824a07239d5be
Author: Jacob Jordan <doublejinitials@gmail.com>
Date:   Thu Nov 29 09:39:31 2018 -0800

    Fix Skew factors (#12555)
    
    - Ensure Skew factors are calculated from test square measurements

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 8cf37f0758..4fe90b9fa7 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -168,27 +168,23 @@ typedef struct {
            min_segment_time_us;                 // (¬µs) M205 B
   float axis_steps_per_mm[XYZE_N],              // (steps) M92 XYZE - Steps per millimeter
         max_feedrate_mm_s[XYZE_N],              // (mm/s) M203 XYZE - Max speeds
         acceleration,                           // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
         retract_acceleration,                   // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
         travel_acceleration,                    // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
         min_feedrate_mm_s,                      // (mm/s) M205 S - Minimum linear feedrate
         min_travel_feedrate_mm_s;               // (mm/s) M205 T - Minimum travel feedrate
 } planner_settings_t;
 
-#ifndef XY_SKEW_FACTOR
+#if DISABLED(SKEW_CORRECTION)
   #define XY_SKEW_FACTOR 0
-#endif
-#ifndef XZ_SKEW_FACTOR
   #define XZ_SKEW_FACTOR 0
-#endif
-#ifndef YZ_SKEW_FACTOR
   #define YZ_SKEW_FACTOR 0
 #endif
 
 typedef struct {
   #if ENABLED(SKEW_CORRECTION_GCODE)
     float xy;
     #if ENABLED(SKEW_CORRECTION_FOR_Z)
       float xz, yz;
     #else
       const float xz = XZ_SKEW_FACTOR, yz = YZ_SKEW_FACTOR;

commit 056561df935f47ecfabc16e2ed777f3754be837c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Oct 16 06:28:52 2018 -0600

    [2.0.x] Enhancements to FILAMENT_RUNOUT_SENSOR (#12069)
    
    - Added FILAMENT_RUNOUT_DISTANCE_MM option
    - Added FILAMENT_MOTION_SENSOR option

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 791ebe31f3..8cf37f0758 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -76,21 +76,21 @@ enum BlockFlag : char {
 
 /**
  * struct block_t
  *
  * A single entry in the planner buffer.
  * Tracks linear movement over multiple axes.
  *
  * The "nominal" values are as-specified by gcode, and
  * may never actually be reached due to acceleration limits.
  */
-typedef struct {
+typedef struct block_t {
 
   volatile uint8_t flag;                    // Block flags (See BlockFlag enum above) - Modified by ISR and main thread!
 
   // Fields used by the motion planner to manage acceleration
   float nominal_speed_sqr,                  // The nominal speed for this block in (mm/sec)^2
         entry_speed_sqr,                    // Entry speed at previous-current junction in (mm/sec)^2
         max_entry_speed_sqr,                // Maximum allowable junction entry speed in (mm/sec)^2
         millimeters,                        // The total travel of this block in mm
         acceleration;                       // acceleration mm/sec^2
 
@@ -102,20 +102,22 @@ typedef struct {
     };
     // Data used by all sync blocks
     struct {
       int32_t position[NUM_AXIS];           // New position to force when this sync block is executed
     };
   };
   uint32_t step_event_count;                // The number of step events required to complete this block
 
   #if EXTRUDERS > 1
     uint8_t extruder;                       // The extruder to move (if E move)
+  #else
+    static constexpr uint8_t extruder = 0;
   #endif
 
   #if ENABLED(MIXING_EXTRUDER)
     MIXER_BLOCK_DEFINITION;                 // Normalized color for the mixing steppers
   #endif
 
   // Settings for the trapezoid generator
   uint32_t accelerate_until,                // The index of the step event on which to stop acceleration
            decelerate_after;                // The index of the step event on which to start decelerating
 

commit f56968ba0b8d4eaccbc9b0c7834cf0cd2f5872d8
Author: AnHardt <github@kitelab.de>
Date:   Tue Oct 16 10:38:57 2018 +0200

    New Continuous Filament Mixer (#12098)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index d3a0b1ee96..791ebe31f3 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -40,20 +40,24 @@
 #endif
 
 #if ABL_PLANAR
   #include "../libs/vector_3.h"
 #endif
 
 #if ENABLED(FWRETRACT)
   #include "../feature/fwretract.h"
 #endif
 
+#if ENABLED(MIXING_EXTRUDER)
+  #include "../feature/mixing.h"
+#endif
+
 enum BlockFlagBit : char {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).
   BLOCK_BIT_NOMINAL_LENGTH,
 
   // The block is segment 2+ of a longer move
@@ -97,25 +101,25 @@ typedef struct {
       uint32_t steps[NUM_AXIS];             // Step count along each axis
     };
     // Data used by all sync blocks
     struct {
       int32_t position[NUM_AXIS];           // New position to force when this sync block is executed
     };
   };
   uint32_t step_event_count;                // The number of step events required to complete this block
 
   #if EXTRUDERS > 1
-    uint8_t active_extruder;                // The extruder to move (if E move)
+    uint8_t extruder;                       // The extruder to move (if E move)
   #endif
 
   #if ENABLED(MIXING_EXTRUDER)
-    uint32_t mix_steps[MIXING_STEPPERS];    // Scaled steps[E_AXIS] for the mixing steppers
+    MIXER_BLOCK_DEFINITION;                 // Normalized color for the mixing steppers
   #endif
 
   // Settings for the trapezoid generator
   uint32_t accelerate_until,                // The index of the step event on which to stop acceleration
            decelerate_after;                // The index of the step event on which to start decelerating
 
   #if ENABLED(S_CURVE_ACCELERATION)
     uint32_t cruise_rate,                   // The actual cruise rate to use, between end of the acceleration phase and start of deceleration phase
              acceleration_time,             // Acceleration time and deceleration time in STEP timer counts
              deceleration_time,

commit d556dc18650e2185791834d7fe70b4acf45254bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 10 09:45:20 2018 -0500

    Fix and improve EEPROM storage (#12054)
    
    * Clean up Temperature PID
    * Improve EEPROM read/write/validate
    * Group `SINGLENOZZLE` saved settings
    * Group planner saved settings
    * Group filament change saved settings
    * Group skew saved settings
    * Group `FWRETRACT` saved settings

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 1e5caa994f..d3a0b1ee96 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -12,33 +12,31 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
+#pragma once
 
 /**
  * planner.h
  *
  * Buffer movement commands and manage the acceleration profile plan
  *
  * Derived from Grbl
  * Copyright (c) 2009-2011 Simen Svale Skogsrud
  */
 
-#ifndef PLANNER_H
-#define PLANNER_H
-
 #include "../Marlin.h"
 
 #include "motion.h"
 #include "../gcode/queue.h"
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
 #if ABL_PLANAR
@@ -152,20 +150,56 @@ typedef struct {
   #endif
 
   uint32_t segment_time_us;
 
 } block_t;
 
 #define HAS_POSITION_FLOAT (ENABLED(LIN_ADVANCE) || ENABLED(SCARA_FEEDRATE_SCALING))
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
+typedef struct {
+  uint32_t max_acceleration_mm_per_s2[XYZE_N],  // (mm/s^2) M201 XYZE
+           min_segment_time_us;                 // (¬µs) M205 B
+  float axis_steps_per_mm[XYZE_N],              // (steps) M92 XYZE - Steps per millimeter
+        max_feedrate_mm_s[XYZE_N],              // (mm/s) M203 XYZE - Max speeds
+        acceleration,                           // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
+        retract_acceleration,                   // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
+        travel_acceleration,                    // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
+        min_feedrate_mm_s,                      // (mm/s) M205 S - Minimum linear feedrate
+        min_travel_feedrate_mm_s;               // (mm/s) M205 T - Minimum travel feedrate
+} planner_settings_t;
+
+#ifndef XY_SKEW_FACTOR
+  #define XY_SKEW_FACTOR 0
+#endif
+#ifndef XZ_SKEW_FACTOR
+  #define XZ_SKEW_FACTOR 0
+#endif
+#ifndef YZ_SKEW_FACTOR
+  #define YZ_SKEW_FACTOR 0
+#endif
+
+typedef struct {
+  #if ENABLED(SKEW_CORRECTION_GCODE)
+    float xy;
+    #if ENABLED(SKEW_CORRECTION_FOR_Z)
+      float xz, yz;
+    #else
+      const float xz = XZ_SKEW_FACTOR, yz = YZ_SKEW_FACTOR;
+    #endif
+  #else
+    const float xy = XY_SKEW_FACTOR,
+                xz = XZ_SKEW_FACTOR, yz = YZ_SKEW_FACTOR;
+  #endif
+} skew_factor_t;
+
 class Planner {
   public:
 
     /**
      * The move buffer, calculated in stepper steps
      *
      * block_buffer is a ring buffer...
      *
      *             head,tail : indexes for write,read
      *            head==tail : the buffer is empty
@@ -192,31 +226,24 @@ class Planner {
 
     static float e_factor[EXTRUDERS];               // The flow percentage and volumetric multiplier combine to scale E movement
 
     #if DISABLED(NO_VOLUMETRICS)
       static float filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
                    volumetric_area_nominal,           // Nominal cross-sectional area
                    volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                       // May be auto-adjusted by a filament width sensor
     #endif
 
-    static uint32_t max_acceleration_mm_per_s2[XYZE_N],    // (mm/s^2) M201 XYZE
-                    max_acceleration_steps_per_s2[XYZE_N], // (steps/s^2) Derived from mm_per_s2
-                    min_segment_time_us;                   // (¬µs) M205 B
-    static float max_feedrate_mm_s[XYZE_N],     // (mm/s) M203 XYZE - Max speeds
-                 axis_steps_per_mm[XYZE_N],     // (steps) M92 XYZE - Steps per millimeter
-                 steps_to_mm[XYZE_N],           // (mm) Millimeters per step
-                 min_feedrate_mm_s,             // (mm/s) M205 S - Minimum linear feedrate
-                 acceleration,                  // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
-                 retract_acceleration,          // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
-                 travel_acceleration,           // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
-                 min_travel_feedrate_mm_s;      // (mm/s) M205 T - Minimum travel feedrate
+    static planner_settings_t settings;
+
+    static uint32_t max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
+    static float steps_to_mm[XYZE_N];           // Millimeters per step
 
     #if ENABLED(JUNCTION_DEVIATION)
       static float junction_deviation_mm;       // (mm) M205 J
       #if ENABLED(LIN_ADVANCE)
         static float max_e_jerk                 // Calculated from junction_deviation_mm
           #if ENABLED(DISTINCT_E_FACTORS)
             [EXTRUDERS]
           #endif
         ;
       #endif
@@ -249,36 +276,21 @@ class Planner {
     #endif
 
     #if HAS_POSITION_FLOAT
       static float position_float[XYZE];
     #endif
 
     #if IS_KINEMATIC
       static float position_cart[XYZE];
     #endif
 
-    #if ENABLED(SKEW_CORRECTION)
-      #if ENABLED(SKEW_CORRECTION_GCODE)
-        static float xy_skew_factor;
-      #else
-        static constexpr float xy_skew_factor = XY_SKEW_FACTOR;
-      #endif
-      #if ENABLED(SKEW_CORRECTION_FOR_Z)
-        #if ENABLED(SKEW_CORRECTION_GCODE)
-          static float xz_skew_factor, yz_skew_factor;
-        #else
-          static constexpr float xz_skew_factor = XZ_SKEW_FACTOR, yz_skew_factor = YZ_SKEW_FACTOR;
-        #endif
-      #else
-        static constexpr float xz_skew_factor = 0, yz_skew_factor = 0;
-      #endif
-    #endif
+    static skew_factor_t skew_factor;
 
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
       static bool abort_on_endstop_hit;
     #endif
 
   private:
 
     /**
      * The current position of the tool in absolute steps
      * Recalculated if any axis_steps_per_mm are changed by gcode
@@ -412,34 +424,34 @@ class Planner {
       }
 
       FORCE_INLINE static bool leveling_active_at_z(const float &rz) { UNUSED(rz); return true; }
 
     #endif
 
     #if ENABLED(SKEW_CORRECTION)
 
       FORCE_INLINE static void skew(float &cx, float &cy, const float &cz) {
         if (WITHIN(cx, X_MIN_POS + 1, X_MAX_POS) && WITHIN(cy, Y_MIN_POS + 1, Y_MAX_POS)) {
-          const float sx = cx - cy * xy_skew_factor - cz * (xz_skew_factor - (xy_skew_factor * yz_skew_factor)),
-                      sy = cy - cz * yz_skew_factor;
+          const float sx = cx - cy * skew_factor.xy - cz * (skew_factor.xz - (skew_factor.xy * skew_factor.yz)),
+                      sy = cy - cz * skew_factor.yz;
           if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {
             cx = sx; cy = sy;
           }
         }
       }
       FORCE_INLINE static void skew(float (&raw)[XYZ]) { skew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
       FORCE_INLINE static void skew(float (&raw)[XYZE]) { skew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
 
       FORCE_INLINE static void unskew(float &cx, float &cy, const float &cz) {
         if (WITHIN(cx, X_MIN_POS, X_MAX_POS) && WITHIN(cy, Y_MIN_POS, Y_MAX_POS)) {
-          const float sx = cx + cy * xy_skew_factor + cz * xz_skew_factor,
-                      sy = cy + cz * yz_skew_factor;
+          const float sx = cx + cy * skew_factor.xy + cz * skew_factor.xz,
+                      sy = cy + cz * skew_factor.yz;
           if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {
             cx = sx; cy = sy;
           }
         }
       }
       FORCE_INLINE static void unskew(float (&raw)[XYZ]) { unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
       FORCE_INLINE static void unskew(float (&raw)[XYZE]) { unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
 
     #endif // SKEW_CORRECTION
 
@@ -841,23 +853,23 @@ class Planner {
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
     #endif
 
     #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
       FORCE_INLINE static void recalculate_max_e_jerk() {
         #define GET_MAX_E_JERK(N) SQRT(SQRT(0.5) * junction_deviation_mm * (N) * RECIPROCAL(1.0 - SQRT(0.5)))
         #if ENABLED(DISTINCT_E_FACTORS)
           for (uint8_t i = 0; i < EXTRUDERS; i++)
-            max_e_jerk[i] = GET_MAX_E_JERK(max_acceleration_mm_per_s2[E_AXIS + i]);
+            max_e_jerk[i] = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS + i]);
         #else
-          max_e_jerk = GET_MAX_E_JERK(max_acceleration_mm_per_s2[E_AXIS]);
+          max_e_jerk = GET_MAX_E_JERK(settings.max_acceleration_mm_per_s2[E_AXIS]);
         #endif
       }
     #endif
 
   private:
 
     /**
      * Get the index of the next / previous block in the ring buffer
      */
     static constexpr uint8_t next_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index + 1); }
@@ -920,22 +932,20 @@ class Planner {
       FORCE_INLINE static void normalize_junction_vector(float (&vector)[XYZE]) {
         float magnitude_sq = 0;
         LOOP_XYZE(idx) if (vector[idx]) magnitude_sq += sq(vector[idx]);
         const float inv_magnitude = RSQRT(magnitude_sq);
         LOOP_XYZE(idx) vector[idx] *= inv_magnitude;
       }
 
       FORCE_INLINE static float limit_value_by_axis_maximum(const float &max_value, float (&unit_vec)[XYZE]) {
         float limit_value = max_value;
         LOOP_XYZE(idx) if (unit_vec[idx]) // Avoid divide by zero
-          NOMORE(limit_value, ABS(max_acceleration_mm_per_s2[idx] / unit_vec[idx]));
+          NOMORE(limit_value, ABS(settings.max_acceleration_mm_per_s2[idx] / unit_vec[idx]));
         return limit_value;
       }
 
     #endif // JUNCTION_DEVIATION
 };
 
-#define PLANNER_XY_FEEDRATE() (MIN(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]))
+#define PLANNER_XY_FEEDRATE() (MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]))
 
 extern Planner planner;
-
-#endif // PLANNER_H

commit d6b0fbd7715da67a2aaeeeafb0d4dc7c1563ef98
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 7 15:34:41 2018 -0500

    Use uint8_t for all fan speeds (#12032)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index acdfbd816c..1e5caa994f 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -137,21 +137,21 @@ typedef struct {
              final_adv_steps;               // advance steps due to exit speed
     float e_D_ratio;
   #endif
 
   uint32_t nominal_rate,                    // The nominal step rate for this block in step_events/sec
            initial_rate,                    // The jerk-adjusted step rate at start of block
            final_rate,                      // The minimal rate at exit
            acceleration_steps_per_s2;       // acceleration steps/sec^2
 
   #if FAN_COUNT > 0
-    uint16_t fan_speed[FAN_COUNT];
+    uint8_t fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
     uint8_t valve_pressure, e_to_p_pressure;
   #endif
 
   uint32_t segment_time_us;
 
 } block_t;
 

commit c5e5cc5e9f20e82cbd15b47a85bf08bbca542961
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 17 17:30:04 2018 -0500

    Fix some trailing whitespace, macros

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 8b745d5de8..acdfbd816c 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -635,21 +635,21 @@ class Planner {
     /**
      * Add a new linear movement to the buffer.
      * The target is cartesian, it's translated to delta/scara if
      * needed.
      *
      *
      *  rx,ry,rz,e   - target position in mm or degrees
      *  fr_mm_s      - (target) speed of the move (mm/s)
      *  extruder     - target extruder
      *  millimeters  - the length of the movement, if known
-     *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled) 
+     *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
      */
     static bool buffer_line(const float &rx, const float &ry, const float &rz, const float &e, const float &fr_mm_s, const uint8_t extruder, const float millimeters=0.0
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         , const float &inv_duration=0.0
       #endif
     );
 
     FORCE_INLINE static bool buffer_line(const float (&cart)[XYZE], const float &fr_mm_s, const uint8_t extruder, const float millimeters=0.0
       #if ENABLED(SCARA_FEEDRATE_SCALING)
         , const float &inv_duration=0.0
@@ -658,37 +658,37 @@ class Planner {
       return buffer_line(cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS], cart[E_AXIS], fr_mm_s, extruder, millimeters
         #if ENABLED(SCARA_FEEDRATE_SCALING)
           , inv_duration
         #endif
       );
     }
 
     /**
      * Set the planner.position and individual stepper positions.
      * Used by G92, G28, G29, and other procedures.
-     * 
+     *
      * The supplied position is in the cartesian coordinate space and is
      * translated in to machine space as needed. Modifiers such as leveling
      * and skew are also applied.
      *
      * Multiplies by axis_steps_per_mm[] and does necessary conversion
      * for COREXY / COREXZ / COREYZ to set the corresponding stepper positions.
      *
      * Clears previous speed values.
      */
     static void set_position_mm(const float &rx, const float &ry, const float &rz, const float &e);
     FORCE_INLINE static void set_position_mm(const float (&cart)[XYZE]) { set_position_mm(cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS], cart[E_AXIS]); }
     static void set_e_position_mm(const float &e);
 
     /**
      * Set the planner.position and individual stepper positions.
-     * 
+     *
      * The supplied position is in machine space, and no additional
      * conversions are applied.
      */
     static void set_machine_position_mm(const float &a, const float &b, const float &c, const float &e);
     FORCE_INLINE static void set_machine_position_mm(const float (&abce)[ABCE]) { set_machine_position_mm(abce[A_AXIS], abce[B_AXIS], abce[C_AXIS], abce[E_AXIS]); }
 
     /**
      * Get an axis position according to stepper position(s)
      * For CORE machines apply translation from ABC to XYZ.
      */

commit c437bb08f12f1c0535cc78a761b49a18f2dc2a12
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Sep 16 22:24:15 2018 -0400

    Overhaul of the planner (#11578)
    
    - Move FWRETRACT to the planner
    - Combine leveling, skew, etc. in a single modifier method
    - Have kinematic and non-kinematic moves call one planner method

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 48f392a65b..8b745d5de8 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -38,20 +38,24 @@
 #include "../gcode/queue.h"
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
 #if ABL_PLANAR
   #include "../libs/vector_3.h"
 #endif
 
+#if ENABLED(FWRETRACT)
+  #include "../feature/fwretract.h"
+#endif
+
 enum BlockFlagBit : char {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).
   BLOCK_BIT_NOMINAL_LENGTH,
 
   // The block is segment 2+ of a longer move
@@ -144,21 +148,21 @@ typedef struct {
   #endif
 
   #if ENABLED(BARICUDA)
     uint8_t valve_pressure, e_to_p_pressure;
   #endif
 
   uint32_t segment_time_us;
 
 } block_t;
 
-#define HAS_POSITION_FLOAT (ENABLED(LIN_ADVANCE) || HAS_FEEDRATE_SCALING)
+#define HAS_POSITION_FLOAT (ENABLED(LIN_ADVANCE) || ENABLED(SCARA_FEEDRATE_SCALING))
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 class Planner {
   public:
 
     /**
      * The move buffer, calculated in stepper steps
      *
      * block_buffer is a ring buffer...
@@ -203,28 +207,36 @@ class Planner {
                  steps_to_mm[XYZE_N],           // (mm) Millimeters per step
                  min_feedrate_mm_s,             // (mm/s) M205 S - Minimum linear feedrate
                  acceleration,                  // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
                  retract_acceleration,          // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
                  travel_acceleration,           // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
                  min_travel_feedrate_mm_s;      // (mm/s) M205 T - Minimum travel feedrate
 
     #if ENABLED(JUNCTION_DEVIATION)
       static float junction_deviation_mm;       // (mm) M205 J
       #if ENABLED(LIN_ADVANCE)
-        #if ENABLED(DISTINCT_E_FACTORS)
-          static float max_e_jerk[EXTRUDERS];   // Calculated from junction_deviation_mm
+        static float max_e_jerk                 // Calculated from junction_deviation_mm
+          #if ENABLED(DISTINCT_E_FACTORS)
+            [EXTRUDERS]
+          #endif
+        ;
+      #endif
+    #endif
+
+    #if HAS_CLASSIC_JERK
+      static float max_jerk[
+        #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+          XYZ                                    // (mm/s^2) M205 XYZ - The largest speed change requiring no acceleration.
         #else
-          static float max_e_jerk;
+          XYZE                                   // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
         #endif
-      #endif
-    #else
-      static float max_jerk[XYZE];              // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
+      ];
     #endif
 
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
       #if ABL_PLANAR
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         static float z_fade_height, inverse_z_fade_height;
       #endif
@@ -233,20 +245,24 @@ class Planner {
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       static float extruder_advance_K[EXTRUDERS];
     #endif
 
     #if HAS_POSITION_FLOAT
       static float position_float[XYZE];
     #endif
 
+    #if IS_KINEMATIC
+      static float position_cart[XYZE];
+    #endif
+
     #if ENABLED(SKEW_CORRECTION)
       #if ENABLED(SKEW_CORRECTION_GCODE)
         static float xy_skew_factor;
       #else
         static constexpr float xy_skew_factor = XY_SKEW_FACTOR;
       #endif
       #if ENABLED(SKEW_CORRECTION_FOR_Z)
         #if ENABLED(SKEW_CORRECTION_GCODE)
           static float xz_skew_factor, yz_skew_factor;
         #else
@@ -403,53 +419,102 @@ class Planner {
 
       FORCE_INLINE static void skew(float &cx, float &cy, const float &cz) {
         if (WITHIN(cx, X_MIN_POS + 1, X_MAX_POS) && WITHIN(cy, Y_MIN_POS + 1, Y_MAX_POS)) {
           const float sx = cx - cy * xy_skew_factor - cz * (xz_skew_factor - (xy_skew_factor * yz_skew_factor)),
                       sy = cy - cz * yz_skew_factor;
           if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {
             cx = sx; cy = sy;
           }
         }
       }
+      FORCE_INLINE static void skew(float (&raw)[XYZ]) { skew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
+      FORCE_INLINE static void skew(float (&raw)[XYZE]) { skew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
 
       FORCE_INLINE static void unskew(float &cx, float &cy, const float &cz) {
         if (WITHIN(cx, X_MIN_POS, X_MAX_POS) && WITHIN(cy, Y_MIN_POS, Y_MAX_POS)) {
           const float sx = cx + cy * xy_skew_factor + cz * xz_skew_factor,
                       sy = cy + cz * yz_skew_factor;
           if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {
             cx = sx; cy = sy;
           }
         }
       }
+      FORCE_INLINE static void unskew(float (&raw)[XYZ]) { unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
+      FORCE_INLINE static void unskew(float (&raw)[XYZE]) { unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
 
     #endif // SKEW_CORRECTION
 
-    #if PLANNER_LEVELING || HAS_UBL_AND_CURVES
+    #if HAS_LEVELING
       /**
        * Apply leveling to transform a cartesian position
        * as it will be given to the planner and steppers.
        */
       static void apply_leveling(float &rx, float &ry, float &rz);
       FORCE_INLINE static void apply_leveling(float (&raw)[XYZ]) { apply_leveling(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
-    #endif
+      FORCE_INLINE static void apply_leveling(float (&raw)[XYZE]) { apply_leveling(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
 
-    #if PLANNER_LEVELING
-      #define ARG_X float rx
-      #define ARG_Y float ry
-      #define ARG_Z float rz
       static void unapply_leveling(float raw[XYZ]);
-    #else
-      #define ARG_X const float &rx
-      #define ARG_Y const float &ry
-      #define ARG_Z const float &rz
     #endif
 
+    #if ENABLED(FWRETRACT)
+      static void apply_retract(float &rz, float &e);
+      FORCE_INLINE static void apply_retract(float (&raw)[XYZE]) { apply_retract(raw[Z_AXIS], raw[E_AXIS]); }
+      static void unapply_retract(float &rz, float &e);
+      FORCE_INLINE static void unapply_retract(float (&raw)[XYZE]) { unapply_retract(raw[Z_AXIS], raw[E_AXIS]); }
+    #endif
+
+    #if HAS_POSITION_MODIFIERS
+      FORCE_INLINE static void apply_modifiers(float (&pos)[XYZE]
+        #if HAS_LEVELING
+          , bool leveling =
+          #if PLANNER_LEVELING
+            true
+          #else
+            false
+          #endif
+        #endif
+      ) {
+        #if ENABLED(SKEW_CORRECTION)
+          skew(pos);
+        #endif
+        #if HAS_LEVELING
+          if (leveling)
+            apply_leveling(pos);
+        #endif
+        #if ENABLED(FWRETRACT)
+          apply_retract(pos);
+        #endif
+      }
+
+      FORCE_INLINE static void unapply_modifiers(float (&pos)[XYZE]
+        #if HAS_LEVELING
+          , bool leveling =
+          #if PLANNER_LEVELING
+            true
+          #else
+            false
+          #endif
+        #endif
+      ) {
+        #if ENABLED(FWRETRACT)
+          unapply_retract(pos);
+        #endif
+        #if HAS_LEVELING
+          if (leveling)
+            unapply_leveling(pos);
+        #endif
+        #if ENABLED(SKEW_CORRECTION)
+          unskew(pos);
+        #endif
+      }
+    #endif // HAS_POSITION_MODIFIERS
+
     // Number of moves currently in the planner including the busy block, if any
     FORCE_INLINE static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail); }
 
     // Number of nonbusy moves currently in the planner
     FORCE_INLINE static uint8_t nonbusy_movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_nonbusy); }
 
     // Remove all blocks from the buffer
     FORCE_INLINE static void clear_block_buffer() { block_buffer_nonbusy = block_buffer_planned = block_buffer_head = block_buffer_tail = 0; }
 
     // Check if movement queue is full
@@ -482,21 +547,24 @@ class Planner {
      *
      *  target      - target position in steps units
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      *
      * Returns true if movement was buffered, false otherwise
      */
     static bool _buffer_steps(const int32_t (&target)[XYZE]
       #if HAS_POSITION_FLOAT
-        , const float (&target_float)[XYZE]
+        , const float (&target_float)[ABCE]
+      #endif
+      #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+        , const float (&delta_mm_cart)[XYZE]
       #endif
       , float fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
     /**
      * Planner::_populate_block
      *
      * Fills a new linear movement in the block (in terms of steps).
      *
      *  target      - target position in steps units
@@ -504,109 +572,128 @@ class Planner {
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      *
      * Returns true is movement is acceptable, false otherwise
      */
     static bool _populate_block(block_t * const block, bool split_move,
         const int32_t (&target)[XYZE]
       #if HAS_POSITION_FLOAT
         , const float (&target_float)[XYZE]
       #endif
+      #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+        , const float (&delta_mm_cart)[XYZE]
+      #endif
       , float fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
     /**
      * Planner::buffer_sync_block
      * Add a block to the buffer that just updates the position
      */
     static void buffer_sync_block();
 
+  #if IS_KINEMATIC
+    private:
+
+      // Allow do_homing_move to access internal functions, such as buffer_segment.
+      friend void do_homing_move(const AxisEnum, const float, const float);
+  #endif
+
     /**
      * Planner::buffer_segment
      *
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e     - target positions in mm and/or degrees
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      */
-    static bool buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0);
-
-    static void _set_position_mm(const float &a, const float &b, const float &c, const float &e);
+    static bool buffer_segment(const float &a, const float &b, const float &c, const float &e
+      #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+        , const float (&delta_mm_cart)[XYZE]
+      #endif
+      , const float &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
+    );
 
-    /**
-     * Add a new linear movement to the buffer.
-     * The target is NOT translated to delta/scara
-     *
-     * Leveling will be applied to input on cartesians.
-     * Kinematic machines should call buffer_line_kinematic (for leveled moves).
-     * (Cartesians may also call buffer_line_kinematic.)
-     *
-     *  rx,ry,rz,e   - target position in mm or degrees
-     *  fr_mm_s      - (target) speed of the move (mm/s)
-     *  extruder     - target extruder
-     *  millimeters  - the length of the movement, if known
-     */
-    FORCE_INLINE static bool buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, const float &fr_mm_s, const uint8_t extruder, const float millimeters = 0.0) {
-      #if PLANNER_LEVELING && IS_CARTESIAN
-        apply_leveling(rx, ry, rz);
+    FORCE_INLINE static bool buffer_segment(const float (&abce)[ABCE]
+      #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+        , const float (&delta_mm_cart)[XYZE]
       #endif
-      return buffer_segment(rx, ry, rz, e, fr_mm_s, extruder, millimeters);
+      , const float &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
+    ) {
+      return buffer_segment(abce[A_AXIS], abce[B_AXIS], abce[C_AXIS], abce[E_AXIS]
+        #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+          , delta_mm_cart
+        #endif
+        , fr_mm_s, extruder, millimeters);
     }
 
+  public:
+
     /**
      * Add a new linear movement to the buffer.
      * The target is cartesian, it's translated to delta/scara if
      * needed.
      *
-     *  cart         - x,y,z,e CARTESIAN target in mm
+     *
+     *  rx,ry,rz,e   - target position in mm or degrees
      *  fr_mm_s      - (target) speed of the move (mm/s)
      *  extruder     - target extruder
      *  millimeters  - the length of the movement, if known
+     *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled) 
      */
-    FORCE_INLINE static bool buffer_line_kinematic(const float (&cart)[XYZE], const float &fr_mm_s, const uint8_t extruder, const float millimeters = 0.0) {
-      #if PLANNER_LEVELING
-        float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
-        apply_leveling(raw);
-      #else
-        const float (&raw)[XYZE] = cart;
+    static bool buffer_line(const float &rx, const float &ry, const float &rz, const float &e, const float &fr_mm_s, const uint8_t extruder, const float millimeters=0.0
+      #if ENABLED(SCARA_FEEDRATE_SCALING)
+        , const float &inv_duration=0.0
       #endif
-      #if IS_KINEMATIC
-        inverse_kinematics(raw);
-        return buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS], fr_mm_s, extruder, millimeters);
-      #else
-        return buffer_segment(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS], fr_mm_s, extruder, millimeters);
+    );
+
+    FORCE_INLINE static bool buffer_line(const float (&cart)[XYZE], const float &fr_mm_s, const uint8_t extruder, const float millimeters=0.0
+      #if ENABLED(SCARA_FEEDRATE_SCALING)
+        , const float &inv_duration=0.0
       #endif
+    ) {
+      return buffer_line(cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS], cart[E_AXIS], fr_mm_s, extruder, millimeters
+        #if ENABLED(SCARA_FEEDRATE_SCALING)
+          , inv_duration
+        #endif
+      );
     }
 
     /**
      * Set the planner.position and individual stepper positions.
      * Used by G92, G28, G29, and other procedures.
+     * 
+     * The supplied position is in the cartesian coordinate space and is
+     * translated in to machine space as needed. Modifiers such as leveling
+     * and skew are also applied.
      *
      * Multiplies by axis_steps_per_mm[] and does necessary conversion
      * for COREXY / COREXZ / COREYZ to set the corresponding stepper positions.
      *
      * Clears previous speed values.
      */
-    FORCE_INLINE static void set_position_mm(ARG_X, ARG_Y, ARG_Z, const float &e) {
-      #if PLANNER_LEVELING && IS_CARTESIAN
-        apply_leveling(rx, ry, rz);
-      #endif
-      _set_position_mm(rx, ry, rz, e);
-    }
-    static void set_position_mm_kinematic(const float (&cart)[XYZE]);
-    static void set_position_mm(const AxisEnum axis, const float &v);
-    FORCE_INLINE static void set_z_position_mm(const float &z) { set_position_mm(Z_AXIS, z); }
-    FORCE_INLINE static void set_e_position_mm(const float &e) { set_position_mm(E_AXIS, e); }
+    static void set_position_mm(const float &rx, const float &ry, const float &rz, const float &e);
+    FORCE_INLINE static void set_position_mm(const float (&cart)[XYZE]) { set_position_mm(cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS], cart[E_AXIS]); }
+    static void set_e_position_mm(const float &e);
+
+    /**
+     * Set the planner.position and individual stepper positions.
+     * 
+     * The supplied position is in machine space, and no additional
+     * conversions are applied.
+     */
+    static void set_machine_position_mm(const float &a, const float &b, const float &c, const float &e);
+    FORCE_INLINE static void set_machine_position_mm(const float (&abce)[ABCE]) { set_machine_position_mm(abce[A_AXIS], abce[B_AXIS], abce[C_AXIS], abce[E_AXIS]); }
 
     /**
      * Get an axis position according to stepper position(s)
      * For CORE machines apply translation from ABC to XYZ.
      */
     static float get_axis_position_mm(const AxisEnum axis);
 
     // SCARA AB axes are in degrees, not mm
     #if IS_SCARA
       FORCE_INLINE static float get_axis_position_degrees(const AxisEnum axis) { return get_axis_position_mm(axis); }
@@ -749,30 +836,28 @@ class Planner {
 
     #endif
 
     #if ENABLED(AUTOTEMP)
       static float autotemp_min, autotemp_max, autotemp_factor;
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
     #endif
 
-    #if ENABLED(JUNCTION_DEVIATION)
+    #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
       FORCE_INLINE static void recalculate_max_e_jerk() {
         #define GET_MAX_E_JERK(N) SQRT(SQRT(0.5) * junction_deviation_mm * (N) * RECIPROCAL(1.0 - SQRT(0.5)))
-        #if ENABLED(LIN_ADVANCE)
-          #if ENABLED(DISTINCT_E_FACTORS)
-            for (uint8_t i = 0; i < EXTRUDERS; i++)
-              max_e_jerk[i] = GET_MAX_E_JERK(max_acceleration_mm_per_s2[E_AXIS + i]);
-          #else
-            max_e_jerk = GET_MAX_E_JERK(max_acceleration_mm_per_s2[E_AXIS]);
-          #endif
+        #if ENABLED(DISTINCT_E_FACTORS)
+          for (uint8_t i = 0; i < EXTRUDERS; i++)
+            max_e_jerk[i] = GET_MAX_E_JERK(max_acceleration_mm_per_s2[E_AXIS + i]);
+        #else
+          max_e_jerk = GET_MAX_E_JERK(max_acceleration_mm_per_s2[E_AXIS]);
         #endif
       }
     #endif
 
   private:
 
     /**
      * Get the index of the next / previous block in the ring buffer
      */
     static constexpr uint8_t next_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index + 1); }

commit d882717d98d08ba7a47234eacf291b2d82288f13
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 10 23:09:26 2018 -0500

    Save some PROGMEM with constexpr (#11798)
    
    When possible, make `active_extruder` a `constexpr` to save some PROGMEM.

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 9353b4655e..48f392a65b 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -94,21 +94,23 @@ typedef struct {
       // Fields used by the Bresenham algorithm for tracing the line
       uint32_t steps[NUM_AXIS];             // Step count along each axis
     };
     // Data used by all sync blocks
     struct {
       int32_t position[NUM_AXIS];           // New position to force when this sync block is executed
     };
   };
   uint32_t step_event_count;                // The number of step events required to complete this block
 
-  uint8_t active_extruder;                  // The extruder to move (if E move)
+  #if EXTRUDERS > 1
+    uint8_t active_extruder;                // The extruder to move (if E move)
+  #endif
 
   #if ENABLED(MIXING_EXTRUDER)
     uint32_t mix_steps[MIXING_STEPPERS];    // Scaled steps[E_AXIS] for the mixing steppers
   #endif
 
   // Settings for the trapezoid generator
   uint32_t accelerate_until,                // The index of the step event on which to stop acceleration
            decelerate_after;                // The index of the step event on which to start decelerating
 
   #if ENABLED(S_CURVE_ACCELERATION)

commit 4f883d59712608d82d33d387d13571c8a0b7dfd4
Author: Sam Lane <9569766+SJ-Innovation@users.noreply.github.com>
Date:   Tue Sep 11 04:37:32 2018 +0100

    [2.0.x] Extruder-Distinct Linear Advance K Factors (#11789)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 8a639a0431..9353b4655e 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -224,21 +224,21 @@ class Planner {
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         static float z_fade_height, inverse_z_fade_height;
       #endif
     #else
       static constexpr bool leveling_active = false;
     #endif
 
     #if ENABLED(LIN_ADVANCE)
-      static float extruder_advance_K;
+      static float extruder_advance_K[EXTRUDERS];
     #endif
 
     #if HAS_POSITION_FLOAT
       static float position_float[XYZE];
     #endif
 
     #if ENABLED(SKEW_CORRECTION)
       #if ENABLED(SKEW_CORRECTION_GCODE)
         static float xy_skew_factor;
       #else

commit a4b01483650ce50e3916d4bc16553429825603ec
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Aug 13 23:55:12 2018 -0500

    Easier to find 'static inline'

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index c362bf0f4b..8a639a0431 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -354,21 +354,21 @@ class Planner {
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
 
       /**
        * Get the Z leveling fade factor based on the given Z height,
        * re-calculating only when needed.
        *
        *  Returns 1.0 if planner.z_fade_height is 0.0.
        *  Returns 0.0 if Z is past the specified 'Fade Height'.
        */
-      inline static float fade_scaling_factor_for_z(const float &rz) {
+      static inline float fade_scaling_factor_for_z(const float &rz) {
         static float z_fade_factor = 1;
         if (z_fade_height) {
           if (rz >= z_fade_height) return 0;
           if (last_fade_z != rz) {
             last_fade_z = rz;
             z_fade_factor = 1 - rz * inverse_z_fade_height;
           }
           return z_fade_factor;
         }
         return 1;

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index c3a912b46c..c362bf0f4b 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -317,21 +317,21 @@ class Planner {
     void init();
 
     /**
      * Static (class) Methods
      */
 
     static void reset_acceleration_rates();
     static void refresh_positioning();
 
     FORCE_INLINE static void refresh_e_factor(const uint8_t e) {
-      e_factor[e] = (flow_percentage[e] * 0.01
+      e_factor[e] = (flow_percentage[e] * 0.01f
         #if DISABLED(NO_VOLUMETRICS)
           * volumetric_multiplier[e]
         #endif
       );
     }
 
     // Manage fans, paste pressure, etc.
     static void check_axes_activity();
 
     // Update multipliers based on new diameter measurements
@@ -355,49 +355,49 @@ class Planner {
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
 
       /**
        * Get the Z leveling fade factor based on the given Z height,
        * re-calculating only when needed.
        *
        *  Returns 1.0 if planner.z_fade_height is 0.0.
        *  Returns 0.0 if Z is past the specified 'Fade Height'.
        */
       inline static float fade_scaling_factor_for_z(const float &rz) {
-        static float z_fade_factor = 1.0;
+        static float z_fade_factor = 1;
         if (z_fade_height) {
-          if (rz >= z_fade_height) return 0.0;
+          if (rz >= z_fade_height) return 0;
           if (last_fade_z != rz) {
             last_fade_z = rz;
-            z_fade_factor = 1.0 - rz * inverse_z_fade_height;
+            z_fade_factor = 1 - rz * inverse_z_fade_height;
           }
           return z_fade_factor;
         }
-        return 1.0;
+        return 1;
       }
 
-      FORCE_INLINE static void force_fade_recalc() { last_fade_z = -999.999; }
+      FORCE_INLINE static void force_fade_recalc() { last_fade_z = -999.999f; }
 
       FORCE_INLINE static void set_z_fade_height(const float &zfh) {
         z_fade_height = zfh > 0 ? zfh : 0;
         inverse_z_fade_height = RECIPROCAL(z_fade_height);
         force_fade_recalc();
       }
 
       FORCE_INLINE static bool leveling_active_at_z(const float &rz) {
         return !z_fade_height || rz < z_fade_height;
       }
 
     #else
 
       FORCE_INLINE static float fade_scaling_factor_for_z(const float &rz) {
         UNUSED(rz);
-        return 1.0;
+        return 1;
       }
 
       FORCE_INLINE static bool leveling_active_at_z(const float &rz) { UNUSED(rz); return true; }
 
     #endif
 
     #if ENABLED(SKEW_CORRECTION)
 
       FORCE_INLINE static void skew(float &cx, float &cy, const float &cz) {
         if (WITHIN(cx, X_MIN_POS + 1, X_MAX_POS) && WITHIN(cy, Y_MIN_POS + 1, Y_MAX_POS)) {
@@ -824,23 +824,23 @@ class Planner {
     static void reverse_pass();
     static void forward_pass();
 
     static void recalculate_trapezoids();
 
     static void recalculate();
 
     #if ENABLED(JUNCTION_DEVIATION)
 
       FORCE_INLINE static void normalize_junction_vector(float (&vector)[XYZE]) {
-        float magnitude_sq = 0.0;
+        float magnitude_sq = 0;
         LOOP_XYZE(idx) if (vector[idx]) magnitude_sq += sq(vector[idx]);
-        const float inv_magnitude = 1.0 / SQRT(magnitude_sq);
+        const float inv_magnitude = RSQRT(magnitude_sq);
         LOOP_XYZE(idx) vector[idx] *= inv_magnitude;
       }
 
       FORCE_INLINE static float limit_value_by_axis_maximum(const float &max_value, float (&unit_vec)[XYZE]) {
         float limit_value = max_value;
         LOOP_XYZE(idx) if (unit_vec[idx]) // Avoid divide by zero
           NOMORE(limit_value, ABS(max_acceleration_mm_per_s2[idx] / unit_vec[idx]));
         return limit_value;
       }
 

commit 8eaac0dab37b4376ac06f1fefd469cdd6bc80673
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 30 13:44:27 2018 -0500

    Add delta feedrate scaling (#11153)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 96382014cb..c3a912b46c 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -142,21 +142,21 @@ typedef struct {
   #endif
 
   #if ENABLED(BARICUDA)
     uint8_t valve_pressure, e_to_p_pressure;
   #endif
 
   uint32_t segment_time_us;
 
 } block_t;
 
-#define HAS_POSITION_FLOAT (ENABLED(LIN_ADVANCE) || ENABLED(SCARA_FEEDRATE_SCALING))
+#define HAS_POSITION_FLOAT (ENABLED(LIN_ADVANCE) || HAS_FEEDRATE_SCALING)
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 class Planner {
   public:
 
     /**
      * The move buffer, calculated in stepper steps
      *
      * block_buffer is a ring buffer...

commit bd7f5848f1a87b5db4709178bf1024de8aff694e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 29 22:42:05 2018 -0500

    Remove JUNCTION_DEVIATION_INCLUDE_E option (#11147)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index e799cbb30e..96382014cb 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -823,36 +823,30 @@ class Planner {
 
     static void reverse_pass();
     static void forward_pass();
 
     static void recalculate_trapezoids();
 
     static void recalculate();
 
     #if ENABLED(JUNCTION_DEVIATION)
 
-      #if ENABLED(JUNCTION_DEVIATION_INCLUDE_E)
-        #define JD_AXES XYZE
-      #else
-        #define JD_AXES XYZ
-      #endif
-
-      FORCE_INLINE static void normalize_junction_vector(float (&vector)[JD_AXES]) {
+      FORCE_INLINE static void normalize_junction_vector(float (&vector)[XYZE]) {
         float magnitude_sq = 0.0;
-        for (uint8_t idx = 0; idx < JD_AXES; idx++) if (vector[idx]) magnitude_sq += sq(vector[idx]);
+        LOOP_XYZE(idx) if (vector[idx]) magnitude_sq += sq(vector[idx]);
         const float inv_magnitude = 1.0 / SQRT(magnitude_sq);
-        for (uint8_t idx = 0; idx < JD_AXES; idx++) vector[idx] *= inv_magnitude;
+        LOOP_XYZE(idx) vector[idx] *= inv_magnitude;
       }
 
-      FORCE_INLINE static float limit_value_by_axis_maximum(const float &max_value, float (&unit_vec)[JD_AXES]) {
+      FORCE_INLINE static float limit_value_by_axis_maximum(const float &max_value, float (&unit_vec)[XYZE]) {
         float limit_value = max_value;
-        for (uint8_t idx = 0; idx < JD_AXES; idx++) if (unit_vec[idx]) // Avoid divide by zero
+        LOOP_XYZE(idx) if (unit_vec[idx]) // Avoid divide by zero
           NOMORE(limit_value, ABS(max_acceleration_mm_per_s2[idx] / unit_vec[idx]));
         return limit_value;
       }
 
     #endif // JUNCTION_DEVIATION
 };
 
 #define PLANNER_XY_FEEDRATE() (MIN(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]))
 
 extern Planner planner;

commit edb21f349ad18d2948ff6c313c6d43132bad5118
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Wed Jun 27 20:11:16 2018 -0300

    Fix stepper/planner block handling, race conditions (#11098)
    
    - Allow planner to alter the deceleration phase of the currently executing block.
    - Remove BUSY flag, as it is NON ATOMIC to set bits in the Stepper ISR and Planner at the same time.

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 39dd7a2944..e799cbb30e 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -47,50 +47,46 @@
 
 enum BlockFlagBit : char {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).
   BLOCK_BIT_NOMINAL_LENGTH,
 
-  // The block is busy, being interpreted by the stepper ISR
-  BLOCK_BIT_BUSY,
-
   // The block is segment 2+ of a longer move
   BLOCK_BIT_CONTINUED,
 
   // Sync the stepper counts from the block
   BLOCK_BIT_SYNC_POSITION
 };
 
 enum BlockFlag : char {
   BLOCK_FLAG_RECALCULATE          = _BV(BLOCK_BIT_RECALCULATE),
   BLOCK_FLAG_NOMINAL_LENGTH       = _BV(BLOCK_BIT_NOMINAL_LENGTH),
-  BLOCK_FLAG_BUSY                 = _BV(BLOCK_BIT_BUSY),
   BLOCK_FLAG_CONTINUED            = _BV(BLOCK_BIT_CONTINUED),
   BLOCK_FLAG_SYNC_POSITION        = _BV(BLOCK_BIT_SYNC_POSITION)
 };
 
 /**
  * struct block_t
  *
  * A single entry in the planner buffer.
  * Tracks linear movement over multiple axes.
  *
  * The "nominal" values are as-specified by gcode, and
  * may never actually be reached due to acceleration limits.
  */
 typedef struct {
 
-  uint8_t flag;                             // Block flags (See BlockFlag enum above)
+  volatile uint8_t flag;                    // Block flags (See BlockFlag enum above) - Modified by ISR and main thread!
 
   // Fields used by the motion planner to manage acceleration
   float nominal_speed_sqr,                  // The nominal speed for this block in (mm/sec)^2
         entry_speed_sqr,                    // Entry speed at previous-current junction in (mm/sec)^2
         max_entry_speed_sqr,                // Maximum allowable junction entry speed in (mm/sec)^2
         millimeters,                        // The total travel of this block in mm
         acceleration;                       // acceleration mm/sec^2
 
   union {
     // Data used by all move blocks
@@ -168,24 +164,26 @@ class Planner {
      *             head,tail : indexes for write,read
      *            head==tail : the buffer is empty
      *            head!=tail : blocks are in the buffer
      *   head==(tail-1)%size : the buffer is full
      *
      *  Writer of head is Planner::buffer_segment().
      *  Reader of tail is Stepper::isr(). Always consider tail busy / read-only
      */
     static block_t block_buffer[BLOCK_BUFFER_SIZE];
     static volatile uint8_t block_buffer_head,      // Index of the next block to be pushed
+                            block_buffer_nonbusy,   // Index of the first non busy block
+                            block_buffer_planned,   // Index of the optimally planned block
                             block_buffer_tail;      // Index of the busy block, if any
     static uint16_t cleaning_buffer_counter;        // A counter to disable queuing of blocks
-    static uint8_t delay_before_delivering,         // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
-                   block_buffer_planned;            // Index of the optimally planned block
+    static uint8_t delay_before_delivering;         // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
+
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;                 // Respond to extruder change
     #endif
 
     static int16_t flow_percentage[EXTRUDERS];      // Extrusion factor for each extruder
 
     static float e_factor[EXTRUDERS];               // The flow percentage and volumetric multiplier combine to scale E movement
 
     #if DISABLED(NO_VOLUMETRICS)
@@ -436,25 +434,28 @@ class Planner {
       #define ARG_X float rx
       #define ARG_Y float ry
       #define ARG_Z float rz
       static void unapply_leveling(float raw[XYZ]);
     #else
       #define ARG_X const float &rx
       #define ARG_Y const float &ry
       #define ARG_Z const float &rz
     #endif
 
-    // Number of moves currently in the planner
+    // Number of moves currently in the planner including the busy block, if any
     FORCE_INLINE static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail); }
 
+    // Number of nonbusy moves currently in the planner
+    FORCE_INLINE static uint8_t nonbusy_movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_nonbusy); }
+
     // Remove all blocks from the buffer
-    FORCE_INLINE static void clear_block_buffer() { block_buffer_head = block_buffer_tail = 0; }
+    FORCE_INLINE static void clear_block_buffer() { block_buffer_nonbusy = block_buffer_planned = block_buffer_head = block_buffer_tail = 0; }
 
     // Check if movement queue is full
     FORCE_INLINE static bool is_full() { return block_buffer_tail == next_block_index(block_buffer_head); }
 
     // Get count of movement slots free
     FORCE_INLINE static uint8_t moves_free() { return BLOCK_BUFFER_SIZE - 1 - movesplanned(); }
 
     /**
      * Planner::get_next_free_block
      *
@@ -642,21 +643,21 @@ class Planner {
     FORCE_INLINE static bool has_blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
     /**
      * The current block. NULL if the buffer is empty.
      * This also marks the block as busy.
      * WARNING: Called from Stepper ISR context!
      */
     static block_t* get_current_block() {
 
       // Get the number of moves in the planner queue so far
-      uint8_t nr_moves = movesplanned();
+      const uint8_t nr_moves = movesplanned();
 
       // If there are any moves queued ...
       if (nr_moves) {
 
         // If there is still delay of delivery of blocks running, decrement it
         if (delay_before_delivering) {
           --delay_before_delivering;
           // If the number of movements queued is less than 3, and there is still time
           //  to wait, do not deliver anything
           if (nr_moves < 3 && delay_before_delivering) return NULL;
@@ -666,47 +667,47 @@ class Planner {
         // If we are here, there is no excuse to deliver the block
         block_t * const block = &block_buffer[block_buffer_tail];
 
         // No trapezoid calculated? Don't execute yet.
         if (TEST(block->flag, BLOCK_BIT_RECALCULATE)) return NULL;
 
         #if ENABLED(ULTRA_LCD)
           block_buffer_runtime_us -= block->segment_time_us; // We can't be sure how long an active block will take, so don't count it.
         #endif
 
-        // Mark the block as busy, so the planner does not attempt to replan it
-        SBI(block->flag, BLOCK_BIT_BUSY);
+        // As this block is busy, advance the nonbusy block pointer
+        block_buffer_nonbusy = next_block_index(block_buffer_tail);
+
+        // Push block_buffer_planned pointer, if encountered.
+        if (block_buffer_tail == block_buffer_planned)
+          block_buffer_planned = block_buffer_nonbusy;
+
+        // Return the block
         return block;
       }
 
       // The queue became empty
       #if ENABLED(ULTRA_LCD)
         clear_block_buffer_runtime(); // paranoia. Buffer is empty now - so reset accumulated time to zero.
       #endif
 
       return NULL;
     }
 
     /**
      * "Discard" the block and "release" the memory.
      * Called when the current block is no longer needed.
      * NB: There MUST be a current block to call this function!!
      */
     FORCE_INLINE static void discard_current_block() {
-      if (has_blocks_queued()) { // Discard non-empty buffer.
-        uint8_t block_index = next_block_index( block_buffer_tail );
-
-        // Push block_buffer_planned pointer, if encountered.
-        if (!has_blocks_queued()) block_buffer_planned = block_index;
-
-        block_buffer_tail = block_index;
-      }
+      if (has_blocks_queued())
+        block_buffer_tail = next_block_index(block_buffer_tail);
     }
 
     #if ENABLED(ULTRA_LCD)
 
       static uint16_t block_buffer_runtime() {
         #ifdef __AVR__
           // Protect the access to the variable. Only required for AVR, as
           //  any 32bit CPU offers atomic access to 32bit variables
           bool was_enabled = STEPPER_ISR_ENABLED();
           if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();

commit 3b3029c4bfd785c19f791493fbea68fe312abf9a
Author: Andy Shaw <andy-git@gloomy-place.com>
Date:   Wed Jun 27 03:38:31 2018 +0100

    Make max_e_jerk an array to reduce CPU usage (#11118)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index d981c233e2..39dd7a2944 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -203,21 +203,25 @@ class Planner {
                  steps_to_mm[XYZE_N],           // (mm) Millimeters per step
                  min_feedrate_mm_s,             // (mm/s) M205 S - Minimum linear feedrate
                  acceleration,                  // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
                  retract_acceleration,          // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
                  travel_acceleration,           // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
                  min_travel_feedrate_mm_s;      // (mm/s) M205 T - Minimum travel feedrate
 
     #if ENABLED(JUNCTION_DEVIATION)
       static float junction_deviation_mm;       // (mm) M205 J
       #if ENABLED(LIN_ADVANCE)
-        static float max_e_jerk_factor;         // Calculated from junction_deviation_mm
+        #if ENABLED(DISTINCT_E_FACTORS)
+          static float max_e_jerk[EXTRUDERS];   // Calculated from junction_deviation_mm
+        #else
+          static float max_e_jerk;
+        #endif
       #endif
     #else
       static float max_jerk[XYZE];              // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
     #endif
 
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
       #if ABL_PLANAR
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
@@ -743,23 +747,29 @@ class Planner {
     #endif
 
     #if ENABLED(AUTOTEMP)
       static float autotemp_min, autotemp_max, autotemp_factor;
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
     #endif
 
     #if ENABLED(JUNCTION_DEVIATION)
-      FORCE_INLINE static void recalculate_max_e_jerk_factor() {
+      FORCE_INLINE static void recalculate_max_e_jerk() {
+        #define GET_MAX_E_JERK(N) SQRT(SQRT(0.5) * junction_deviation_mm * (N) * RECIPROCAL(1.0 - SQRT(0.5)))
         #if ENABLED(LIN_ADVANCE)
-          max_e_jerk_factor = SQRT(SQRT(0.5) * junction_deviation_mm * RECIPROCAL(1.0 - SQRT(0.5)));
+          #if ENABLED(DISTINCT_E_FACTORS)
+            for (uint8_t i = 0; i < EXTRUDERS; i++)
+              max_e_jerk[i] = GET_MAX_E_JERK(max_acceleration_mm_per_s2[E_AXIS + i]);
+          #else
+            max_e_jerk = GET_MAX_E_JERK(max_acceleration_mm_per_s2[E_AXIS]);
+          #endif
         #endif
       }
     #endif
 
   private:
 
     /**
      * Get the index of the next / previous block in the ring buffer
      */
     static constexpr uint8_t next_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index + 1); }

commit 50b6204079e9b6d4b756968543dbf4feaf49e49d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 21 22:01:54 2018 -0400

    Fix LIN_ADVANCE max_e_jerk_factor
    
    According to https://github.com/MarlinFirmware/Marlin/issues/9917#issuecomment-399204568

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 0e313152dd..d981c233e2 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -745,21 +745,21 @@ class Planner {
     #if ENABLED(AUTOTEMP)
       static float autotemp_min, autotemp_max, autotemp_factor;
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
     #endif
 
     #if ENABLED(JUNCTION_DEVIATION)
       FORCE_INLINE static void recalculate_max_e_jerk_factor() {
         #if ENABLED(LIN_ADVANCE)
-          max_e_jerk_factor = SQRT(SQRT(0.5) * junction_deviation_mm) * RECIPROCAL(1.0 - SQRT(0.5));
+          max_e_jerk_factor = SQRT(SQRT(0.5) * junction_deviation_mm * RECIPROCAL(1.0 - SQRT(0.5)));
         #endif
       }
     #endif
 
   private:
 
     /**
      * Get the index of the next / previous block in the ring buffer
      */
     static constexpr uint8_t next_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index + 1); }

commit 9d04f47d9809a22f2ed41cb8cc093ce68e5f5753
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 11 18:49:08 2018 -0500

    Improvements for junction_deviation_mm
    
    - Drop `max_jerk` with `JUNCTION_DEVIATION`
    - Add `max_e_jerk_factor` for use by `LIN_ADVANCE`
    - Recalculate `max_e_jerk_factor` when `junction_deviation_mm` changes
    - Fix LCD editing of `junction_deviation_mm`

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 2d880c8bd9..0e313152dd 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -188,35 +188,39 @@ class Planner {
 
     static float e_factor[EXTRUDERS];               // The flow percentage and volumetric multiplier combine to scale E movement
 
     #if DISABLED(NO_VOLUMETRICS)
       static float filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
                    volumetric_area_nominal,           // Nominal cross-sectional area
                    volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                       // May be auto-adjusted by a filament width sensor
     #endif
 
-    static uint32_t max_acceleration_steps_per_s2[XYZE_N],
-                    max_acceleration_mm_per_s2[XYZE_N], // Use M201 to override
-                    min_segment_time_us; // Use 'M205 B<¬µs>' to override
-    static float max_feedrate_mm_s[XYZE_N],         // Max speeds in mm per second
-                 axis_steps_per_mm[XYZE_N],
-                 steps_to_mm[XYZE_N],
-                 min_feedrate_mm_s,
-                 acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
-                 retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
-                 travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
-                 max_jerk[XYZE],       // The largest speed change requiring no acceleration
-                 min_travel_feedrate_mm_s;
+    static uint32_t max_acceleration_mm_per_s2[XYZE_N],    // (mm/s^2) M201 XYZE
+                    max_acceleration_steps_per_s2[XYZE_N], // (steps/s^2) Derived from mm_per_s2
+                    min_segment_time_us;                   // (¬µs) M205 B
+    static float max_feedrate_mm_s[XYZE_N],     // (mm/s) M203 XYZE - Max speeds
+                 axis_steps_per_mm[XYZE_N],     // (steps) M92 XYZE - Steps per millimeter
+                 steps_to_mm[XYZE_N],           // (mm) Millimeters per step
+                 min_feedrate_mm_s,             // (mm/s) M205 S - Minimum linear feedrate
+                 acceleration,                  // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
+                 retract_acceleration,          // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
+                 travel_acceleration,           // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
+                 min_travel_feedrate_mm_s;      // (mm/s) M205 T - Minimum travel feedrate
 
     #if ENABLED(JUNCTION_DEVIATION)
-      static float junction_deviation_mm; // Initialized by EEPROM
+      static float junction_deviation_mm;       // (mm) M205 J
+      #if ENABLED(LIN_ADVANCE)
+        static float max_e_jerk_factor;         // Calculated from junction_deviation_mm
+      #endif
+    #else
+      static float max_jerk[XYZE];              // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
     #endif
 
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
       #if ABL_PLANAR
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         static float z_fade_height, inverse_z_fade_height;
       #endif
@@ -738,20 +742,28 @@ class Planner {
 
     #endif
 
     #if ENABLED(AUTOTEMP)
       static float autotemp_min, autotemp_max, autotemp_factor;
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
     #endif
 
+    #if ENABLED(JUNCTION_DEVIATION)
+      FORCE_INLINE static void recalculate_max_e_jerk_factor() {
+        #if ENABLED(LIN_ADVANCE)
+          max_e_jerk_factor = SQRT(SQRT(0.5) * junction_deviation_mm) * RECIPROCAL(1.0 - SQRT(0.5));
+        #endif
+      }
+    #endif
+
   private:
 
     /**
      * Get the index of the next / previous block in the ring buffer
      */
     static constexpr uint8_t next_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index + 1); }
     static constexpr uint8_t prev_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index - 1); }
 
     /**
      * Calculate the distance (not time) it takes to accelerate

commit a2f521d34b7a500bcaea996e1f386b57ff40d2f7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 10 18:02:54 2018 -0500

    Add Junction Deviation mm runtime setting (#10990)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 94dda12ff9..2d880c8bd9 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -109,24 +109,24 @@ typedef struct {
 
   #if ENABLED(MIXING_EXTRUDER)
     uint32_t mix_steps[MIXING_STEPPERS];    // Scaled steps[E_AXIS] for the mixing steppers
   #endif
 
   // Settings for the trapezoid generator
   uint32_t accelerate_until,                // The index of the step event on which to stop acceleration
            decelerate_after;                // The index of the step event on which to start decelerating
 
   #if ENABLED(S_CURVE_ACCELERATION)
-    uint32_t cruise_rate;                   // The actual cruise rate to use, between end of the acceleration phase and start of deceleration phase
-    uint32_t acceleration_time,             // Acceleration time and deceleration time in STEP timer counts
-             deceleration_time;
-    uint32_t acceleration_time_inverse,     // Inverse of acceleration and deceleration periods, expressed as integer. Scale depends on CPU being used
+    uint32_t cruise_rate,                   // The actual cruise rate to use, between end of the acceleration phase and start of deceleration phase
+             acceleration_time,             // Acceleration time and deceleration time in STEP timer counts
+             deceleration_time,
+             acceleration_time_inverse,     // Inverse of acceleration and deceleration periods, expressed as integer. Scale depends on CPU being used
              deceleration_time_inverse;
   #else
     uint32_t acceleration_rate;             // The acceleration rate used for acceleration calculation
   #endif
 
   uint8_t direction_bits;                   // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
 
   // Advance extrusion
   #if ENABLED(LIN_ADVANCE)
     bool use_advance_lead;
@@ -188,34 +188,37 @@ class Planner {
 
     static float e_factor[EXTRUDERS];               // The flow percentage and volumetric multiplier combine to scale E movement
 
     #if DISABLED(NO_VOLUMETRICS)
       static float filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
                    volumetric_area_nominal,           // Nominal cross-sectional area
                    volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                       // May be auto-adjusted by a filament width sensor
     #endif
 
+    static uint32_t max_acceleration_steps_per_s2[XYZE_N],
+                    max_acceleration_mm_per_s2[XYZE_N], // Use M201 to override
+                    min_segment_time_us; // Use 'M205 B<¬µs>' to override
     static float max_feedrate_mm_s[XYZE_N],         // Max speeds in mm per second
                  axis_steps_per_mm[XYZE_N],
-                 steps_to_mm[XYZE_N];
-    static uint32_t max_acceleration_steps_per_s2[XYZE_N],
-                    max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override
-
-    static uint32_t min_segment_time_us; // Use 'M205 B<¬µs>' to override
-    static float min_feedrate_mm_s,
+                 steps_to_mm[XYZE_N],
+                 min_feedrate_mm_s,
                  acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
                  retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
                  travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
                  max_jerk[XYZE],       // The largest speed change requiring no acceleration
                  min_travel_feedrate_mm_s;
 
+    #if ENABLED(JUNCTION_DEVIATION)
+      static float junction_deviation_mm; // Initialized by EEPROM
+    #endif
+
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
       #if ABL_PLANAR
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         static float z_fade_height, inverse_z_fade_height;
       #endif
     #else
       static constexpr bool leveling_active = false;

commit 39a7e7720d0b14e7c55b65d7da7973b528d184c7
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jun 3 00:59:21 2018 -0300

    Adaptive multiaxis step smoothing
    
    - Stepper bugs fixed
    - Support MIXING_EXTRUDER with Linear Advance
    - Miscellaneous cleanup

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 8e5d52b098..94dda12ff9 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -101,21 +101,21 @@ typedef struct {
     // Data used by all sync blocks
     struct {
       int32_t position[NUM_AXIS];           // New position to force when this sync block is executed
     };
   };
   uint32_t step_event_count;                // The number of step events required to complete this block
 
   uint8_t active_extruder;                  // The extruder to move (if E move)
 
   #if ENABLED(MIXING_EXTRUDER)
-    uint32_t mix_event_count[MIXING_STEPPERS]; // Scaled step_event_count for the mixing steppers
+    uint32_t mix_steps[MIXING_STEPPERS];    // Scaled steps[E_AXIS] for the mixing steppers
   #endif
 
   // Settings for the trapezoid generator
   uint32_t accelerate_until,                // The index of the step event on which to stop acceleration
            decelerate_after;                // The index of the step event on which to start decelerating
 
   #if ENABLED(S_CURVE_ACCELERATION)
     uint32_t cruise_rate;                   // The actual cruise rate to use, between end of the acceleration phase and start of deceleration phase
     uint32_t acceleration_time,             // Acceleration time and deceleration time in STEP timer counts
              deceleration_time;
@@ -123,21 +123,21 @@ typedef struct {
              deceleration_time_inverse;
   #else
     uint32_t acceleration_rate;             // The acceleration rate used for acceleration calculation
   #endif
 
   uint8_t direction_bits;                   // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
 
   // Advance extrusion
   #if ENABLED(LIN_ADVANCE)
     bool use_advance_lead;
-    uint16_t advance_speed,                 // Timer value for extruder speed offset
+    uint16_t advance_speed,                 // STEP timer value for extruder speed offset ISR
              max_adv_steps,                 // max. advance steps to get cruising speed pressure (not always nominal_speed!)
              final_adv_steps;               // advance steps due to exit speed
     float e_D_ratio;
   #endif
 
   uint32_t nominal_rate,                    // The nominal step rate for this block in step_events/sec
            initial_rate,                    // The jerk-adjusted step rate at start of block
            final_rate,                      // The minimal rate at exit
            acceleration_steps_per_s2;       // acceleration steps/sec^2
 

commit 2deff0d9b96e117fc03870169b52ac785d7bf430
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 31 20:09:53 2018 -0500

    Fix/Improve junction deviation
    
    - Respect axis max acceleration limits instead of forcing a fixed acceleration value.
    - The `junction_unit_vec` ensures proper handling of entry and exit speeds even when the axes involved have different limits.

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index b8ab952c10..8e5d52b098 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -795,17 +795,40 @@ class Planner {
     static void reverse_pass_kernel(block_t* const current, const block_t * const next);
     static void forward_pass_kernel(const block_t * const previous, block_t* const current, uint8_t block_index);
 
     static void reverse_pass();
     static void forward_pass();
 
     static void recalculate_trapezoids();
 
     static void recalculate();
 
+    #if ENABLED(JUNCTION_DEVIATION)
+
+      #if ENABLED(JUNCTION_DEVIATION_INCLUDE_E)
+        #define JD_AXES XYZE
+      #else
+        #define JD_AXES XYZ
+      #endif
+
+      FORCE_INLINE static void normalize_junction_vector(float (&vector)[JD_AXES]) {
+        float magnitude_sq = 0.0;
+        for (uint8_t idx = 0; idx < JD_AXES; idx++) if (vector[idx]) magnitude_sq += sq(vector[idx]);
+        const float inv_magnitude = 1.0 / SQRT(magnitude_sq);
+        for (uint8_t idx = 0; idx < JD_AXES; idx++) vector[idx] *= inv_magnitude;
+      }
+
+      FORCE_INLINE static float limit_value_by_axis_maximum(const float &max_value, float (&unit_vec)[JD_AXES]) {
+        float limit_value = max_value;
+        for (uint8_t idx = 0; idx < JD_AXES; idx++) if (unit_vec[idx]) // Avoid divide by zero
+          NOMORE(limit_value, ABS(max_acceleration_mm_per_s2[idx] / unit_vec[idx]));
+        return limit_value;
+      }
+
+    #endif // JUNCTION_DEVIATION
 };
 
 #define PLANNER_XY_FEEDRATE() (MIN(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]))
 
 extern Planner planner;
 
 #endif // PLANNER_H

commit d25907098020d60ddff91ad1abf6ab253d97cc36
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 31 00:06:26 2018 -0500

    Clean up trailing spaces from vim, etc.

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 77b0d5a09c..b8ab952c10 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -172,21 +172,20 @@ class Planner {
      *
      *  Writer of head is Planner::buffer_segment().
      *  Reader of tail is Stepper::isr(). Always consider tail busy / read-only
      */
     static block_t block_buffer[BLOCK_BUFFER_SIZE];
     static volatile uint8_t block_buffer_head,      // Index of the next block to be pushed
                             block_buffer_tail;      // Index of the busy block, if any
     static uint16_t cleaning_buffer_counter;        // A counter to disable queuing of blocks
     static uint8_t delay_before_delivering,         // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
                    block_buffer_planned;            // Index of the optimally planned block
-                   
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;                 // Respond to extruder change
     #endif
 
     static int16_t flow_percentage[EXTRUDERS];      // Extrusion factor for each extruder
 
     static float e_factor[EXTRUDERS];               // The flow percentage and volumetric multiplier combine to scale E movement
 
     #if DISABLED(NO_VOLUMETRICS)

commit aaaf09bda27eff38d773b4b73925442f61d34866
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 26 02:02:39 2018 -0500

    BEZIER_JERK_CONTROL => S_CURVE_ACCELERATION

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 878675d4d9..77b0d5a09c 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -108,21 +108,21 @@ typedef struct {
   uint8_t active_extruder;                  // The extruder to move (if E move)
 
   #if ENABLED(MIXING_EXTRUDER)
     uint32_t mix_event_count[MIXING_STEPPERS]; // Scaled step_event_count for the mixing steppers
   #endif
 
   // Settings for the trapezoid generator
   uint32_t accelerate_until,                // The index of the step event on which to stop acceleration
            decelerate_after;                // The index of the step event on which to start decelerating
 
-  #if ENABLED(BEZIER_JERK_CONTROL)
+  #if ENABLED(S_CURVE_ACCELERATION)
     uint32_t cruise_rate;                   // The actual cruise rate to use, between end of the acceleration phase and start of deceleration phase
     uint32_t acceleration_time,             // Acceleration time and deceleration time in STEP timer counts
              deceleration_time;
     uint32_t acceleration_time_inverse,     // Inverse of acceleration and deceleration periods, expressed as integer. Scale depends on CPU being used
              deceleration_time_inverse;
   #else
     uint32_t acceleration_rate;             // The acceleration rate used for acceleration calculation
   #endif
 
   uint8_t direction_bits;                   // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
@@ -775,21 +775,21 @@ class Planner {
 
     /**
      * Calculate the maximum allowable speed squared at this point, in order
      * to reach 'target_velocity_sqr' using 'acceleration' within a given
      * 'distance'.
      */
     static float max_allowable_speed_sqr(const float &accel, const float &target_velocity_sqr, const float &distance) {
       return target_velocity_sqr - 2 * accel * distance;
     }
 
-    #if ENABLED(BEZIER_JERK_CONTROL)
+    #if ENABLED(S_CURVE_ACCELERATION)
       /**
        * Calculate the speed reached given initial speed, acceleration and distance
        */
       static float final_speed(const float &initial_velocity, const float &accel, const float &distance) {
         return SQRT(sq(initial_velocity) + 2 * accel * distance);
       }
     #endif
 
     static void calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor);
 

commit 435ecb6b67e285becad4e6ca8375ffc8b5cb6025
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 20 22:20:11 2018 -0500

    Followup to stepper/planner refactor

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 86707610ba..878675d4d9 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -445,21 +445,21 @@ class Planner {
     // Get count of movement slots free
     FORCE_INLINE static uint8_t moves_free() { return BLOCK_BUFFER_SIZE - 1 - movesplanned(); }
 
     /**
      * Planner::get_next_free_block
      *
      * - Get the next head indices (passed by reference)
      * - Wait for the number of spaces to open up in the planner
      * - Return the first head block
      */
-    FORCE_INLINE static block_t* get_next_free_block(uint8_t &next_buffer_head, uint8_t count = 1) {
+    FORCE_INLINE static block_t* get_next_free_block(uint8_t &next_buffer_head, const uint8_t count=1) {
 
       // Wait until there are enough slots free
       while (moves_free() < count) { idle(); }
 
       // Return the first available block
       next_buffer_head = next_block_index(block_buffer_head);
       return &block_buffer[block_buffer_head];
     }
 
     /**

commit a4af975873c7b0c75d986cb829eb5d869a4a6b8e
Author: etagle <ejtagle@hotmail.com>
Date:   Fri May 18 04:04:01 2018 -0300

    Fix planner block optimization
    
    - Fixed the planner incorrectly avoiding optimization of the block following the active one.
    - Added extra conditions to terminate planner early and avoid redundant computations.

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 34288c14d8..86707610ba 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -170,21 +170,23 @@ class Planner {
      *            head!=tail : blocks are in the buffer
      *   head==(tail-1)%size : the buffer is full
      *
      *  Writer of head is Planner::buffer_segment().
      *  Reader of tail is Stepper::isr(). Always consider tail busy / read-only
      */
     static block_t block_buffer[BLOCK_BUFFER_SIZE];
     static volatile uint8_t block_buffer_head,      // Index of the next block to be pushed
                             block_buffer_tail;      // Index of the busy block, if any
     static uint16_t cleaning_buffer_counter;        // A counter to disable queuing of blocks
-    static uint8_t delay_before_delivering;         // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
+    static uint8_t delay_before_delivering,         // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
+                   block_buffer_planned;            // Index of the optimally planned block
+                   
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;                 // Respond to extruder change
     #endif
 
     static int16_t flow_percentage[EXTRUDERS];      // Extrusion factor for each extruder
 
     static float e_factor[EXTRUDERS];               // The flow percentage and volumetric multiplier combine to scale E movement
 
     #if DISABLED(NO_VOLUMETRICS)
@@ -648,48 +650,53 @@ class Planner {
           // If the number of movements queued is less than 3, and there is still time
           //  to wait, do not deliver anything
           if (nr_moves < 3 && delay_before_delivering) return NULL;
           delay_before_delivering = 0;
         }
 
         // If we are here, there is no excuse to deliver the block
         block_t * const block = &block_buffer[block_buffer_tail];
 
         // No trapezoid calculated? Don't execute yet.
-        if ( TEST(block->flag, BLOCK_BIT_RECALCULATE)
-          || (movesplanned() > 1 && TEST(block_buffer[next_block_index(block_buffer_tail)].flag, BLOCK_BIT_RECALCULATE))
-        ) return NULL;
+        if (TEST(block->flag, BLOCK_BIT_RECALCULATE)) return NULL;
 
         #if ENABLED(ULTRA_LCD)
           block_buffer_runtime_us -= block->segment_time_us; // We can't be sure how long an active block will take, so don't count it.
         #endif
 
         // Mark the block as busy, so the planner does not attempt to replan it
         SBI(block->flag, BLOCK_BIT_BUSY);
         return block;
       }
-      else {
-        // The queue became empty
-        #if ENABLED(ULTRA_LCD)
-          clear_block_buffer_runtime(); // paranoia. Buffer is empty now - so reset accumulated time to zero.
-        #endif
-        return NULL;
-      }
+
+      // The queue became empty
+      #if ENABLED(ULTRA_LCD)
+        clear_block_buffer_runtime(); // paranoia. Buffer is empty now - so reset accumulated time to zero.
+      #endif
+
+      return NULL;
     }
 
     /**
      * "Discard" the block and "release" the memory.
      * Called when the current block is no longer needed.
      * NB: There MUST be a current block to call this function!!
      */
     FORCE_INLINE static void discard_current_block() {
-      block_buffer_tail = BLOCK_MOD(block_buffer_tail + 1);
+      if (has_blocks_queued()) { // Discard non-empty buffer.
+        uint8_t block_index = next_block_index( block_buffer_tail );
+
+        // Push block_buffer_planned pointer, if encountered.
+        if (!has_blocks_queued()) block_buffer_planned = block_index;
+
+        block_buffer_tail = block_index;
+      }
     }
 
     #if ENABLED(ULTRA_LCD)
 
       static uint16_t block_buffer_runtime() {
         #ifdef __AVR__
           // Protect the access to the variable. Only required for AVR, as
           //  any 32bit CPU offers atomic access to 32bit variables
           bool was_enabled = STEPPER_ISR_ENABLED();
           if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
@@ -734,22 +741,22 @@ class Planner {
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
     #endif
 
   private:
 
     /**
      * Get the index of the next / previous block in the ring buffer
      */
-    static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
-    static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
+    static constexpr uint8_t next_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index + 1); }
+    static constexpr uint8_t prev_block_index(const uint8_t block_index) { return BLOCK_MOD(block_index - 1); }
 
     /**
      * Calculate the distance (not time) it takes to accelerate
      * from initial_rate to target_rate using the given acceleration:
      */
     static float estimate_acceleration_distance(const float &initial_rate, const float &target_rate, const float &accel) {
       if (accel == 0) return 0; // accel was 0, set acceleration distance to 0
       return (sq(target_rate) - sq(initial_rate)) / (accel * 2);
     }
 
@@ -780,21 +787,21 @@ class Planner {
        * Calculate the speed reached given initial speed, acceleration and distance
        */
       static float final_speed(const float &initial_velocity, const float &accel, const float &distance) {
         return SQRT(sq(initial_velocity) + 2 * accel * distance);
       }
     #endif
 
     static void calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor);
 
     static void reverse_pass_kernel(block_t* const current, const block_t * const next);
-    static void forward_pass_kernel(const block_t * const previous, block_t* const current);
+    static void forward_pass_kernel(const block_t * const previous, block_t* const current, uint8_t block_index);
 
     static void reverse_pass();
     static void forward_pass();
 
     static void recalculate_trapezoids();
 
     static void recalculate();
 
 };
 

commit e0ca627033504dd7bf8d9b87ce9ec526ee792276
Author: etagle <ejtagle@hotmail.com>
Date:   Sun May 13 00:49:54 2018 -0300

    Planner block HOLD flag
    
    Allows the Stepper ISR to wait until a given block is free for use. Allows Planner to plan the first move, which is split into two.

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 9dc2035017..34288c14d8 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -47,21 +47,21 @@
 
 enum BlockFlagBit : char {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).
   BLOCK_BIT_NOMINAL_LENGTH,
 
-  // The block is busy
+  // The block is busy, being interpreted by the stepper ISR
   BLOCK_BIT_BUSY,
 
   // The block is segment 2+ of a longer move
   BLOCK_BIT_CONTINUED,
 
   // Sync the stepper counts from the block
   BLOCK_BIT_SYNC_POSITION
 };
 
 enum BlockFlag : char {
@@ -169,21 +169,22 @@ class Planner {
      *            head==tail : the buffer is empty
      *            head!=tail : blocks are in the buffer
      *   head==(tail-1)%size : the buffer is full
      *
      *  Writer of head is Planner::buffer_segment().
      *  Reader of tail is Stepper::isr(). Always consider tail busy / read-only
      */
     static block_t block_buffer[BLOCK_BUFFER_SIZE];
     static volatile uint8_t block_buffer_head,      // Index of the next block to be pushed
                             block_buffer_tail;      // Index of the busy block, if any
-    static int16_t cleaning_buffer_counter;         // A counter to disable queuing of blocks
+    static uint16_t cleaning_buffer_counter;        // A counter to disable queuing of blocks
+    static uint8_t delay_before_delivering;         // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;                 // Respond to extruder change
     #endif
 
     static int16_t flow_percentage[EXTRUDERS];      // Extrusion factor for each extruder
 
     static float e_factor[EXTRUDERS];               // The flow percentage and volumetric multiplier combine to scale E movement
 
     #if DISABLED(NO_VOLUMETRICS)
@@ -627,39 +628,54 @@ class Planner {
      * Does the buffer have any blocks queued?
      */
     FORCE_INLINE static bool has_blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
     /**
      * The current block. NULL if the buffer is empty.
      * This also marks the block as busy.
      * WARNING: Called from Stepper ISR context!
      */
     static block_t* get_current_block() {
-      if (has_blocks_queued()) {
-        block_t * const block = &block_buffer[block_buffer_tail];
 
-        // If the block has no trapezoid calculated, it's unsafe to execute.
-        if (movesplanned() > 1) {
-          const block_t * const next = &block_buffer[next_block_index(block_buffer_tail)];
-          if (TEST(block->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE))
-            return NULL;
+      // Get the number of moves in the planner queue so far
+      uint8_t nr_moves = movesplanned();
+
+      // If there are any moves queued ...
+      if (nr_moves) {
+
+        // If there is still delay of delivery of blocks running, decrement it
+        if (delay_before_delivering) {
+          --delay_before_delivering;
+          // If the number of movements queued is less than 3, and there is still time
+          //  to wait, do not deliver anything
+          if (nr_moves < 3 && delay_before_delivering) return NULL;
+          delay_before_delivering = 0;
         }
-        else if (TEST(block->flag, BLOCK_BIT_RECALCULATE))
-          return NULL;
+
+        // If we are here, there is no excuse to deliver the block
+        block_t * const block = &block_buffer[block_buffer_tail];
+
+        // No trapezoid calculated? Don't execute yet.
+        if ( TEST(block->flag, BLOCK_BIT_RECALCULATE)
+          || (movesplanned() > 1 && TEST(block_buffer[next_block_index(block_buffer_tail)].flag, BLOCK_BIT_RECALCULATE))
+        ) return NULL;
 
         #if ENABLED(ULTRA_LCD)
           block_buffer_runtime_us -= block->segment_time_us; // We can't be sure how long an active block will take, so don't count it.
         #endif
+
+        // Mark the block as busy, so the planner does not attempt to replan it
         SBI(block->flag, BLOCK_BIT_BUSY);
         return block;
       }
       else {
+        // The queue became empty
         #if ENABLED(ULTRA_LCD)
           clear_block_buffer_runtime(); // paranoia. Buffer is empty now - so reset accumulated time to zero.
         #endif
         return NULL;
       }
     }
 
     /**
      * "Discard" the block and "release" the memory.
      * Called when the current block is no longer needed.

commit a11eb50a3eab6d58d595a67e526fb51190018db3
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 9 02:17:53 2018 -0300

    Refactor and optimize Stepper/Planner
    
    Better encapsulation and considerably reduce stepper jitter

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 89a3716305..9dc2035017 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -28,20 +28,21 @@
  * Derived from Grbl
  * Copyright (c) 2009-2011 Simen Svale Skogsrud
  */
 
 #ifndef PLANNER_H
 #define PLANNER_H
 
 #include "../Marlin.h"
 
 #include "motion.h"
+#include "../gcode/queue.h"
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
 #if ABL_PLANAR
   #include "../libs/vector_3.h"
 #endif
 
 enum BlockFlagBit : char {
@@ -77,62 +78,71 @@ enum BlockFlag : char {
  * A single entry in the planner buffer.
  * Tracks linear movement over multiple axes.
  *
  * The "nominal" values are as-specified by gcode, and
  * may never actually be reached due to acceleration limits.
  */
 typedef struct {
 
   uint8_t flag;                             // Block flags (See BlockFlag enum above)
 
-  unsigned char active_extruder;            // The extruder to move (if E move)
+  // Fields used by the motion planner to manage acceleration
+  float nominal_speed_sqr,                  // The nominal speed for this block in (mm/sec)^2
+        entry_speed_sqr,                    // Entry speed at previous-current junction in (mm/sec)^2
+        max_entry_speed_sqr,                // Maximum allowable junction entry speed in (mm/sec)^2
+        millimeters,                        // The total travel of this block in mm
+        acceleration;                       // acceleration mm/sec^2
 
-  // Fields used by the Bresenham algorithm for tracing the line
-  int32_t steps[NUM_AXIS];                  // Step count along each axis
+  union {
+    // Data used by all move blocks
+    struct {
+      // Fields used by the Bresenham algorithm for tracing the line
+      uint32_t steps[NUM_AXIS];             // Step count along each axis
+    };
+    // Data used by all sync blocks
+    struct {
+      int32_t position[NUM_AXIS];           // New position to force when this sync block is executed
+    };
+  };
   uint32_t step_event_count;                // The number of step events required to complete this block
 
+  uint8_t active_extruder;                  // The extruder to move (if E move)
+
   #if ENABLED(MIXING_EXTRUDER)
     uint32_t mix_event_count[MIXING_STEPPERS]; // Scaled step_event_count for the mixing steppers
   #endif
 
   // Settings for the trapezoid generator
-  int32_t accelerate_until,                 // The index of the step event on which to stop acceleration
-          decelerate_after;                 // The index of the step event on which to start decelerating
+  uint32_t accelerate_until,                // The index of the step event on which to stop acceleration
+           decelerate_after;                // The index of the step event on which to start decelerating
 
   #if ENABLED(BEZIER_JERK_CONTROL)
     uint32_t cruise_rate;                   // The actual cruise rate to use, between end of the acceleration phase and start of deceleration phase
     uint32_t acceleration_time,             // Acceleration time and deceleration time in STEP timer counts
              deceleration_time;
     uint32_t acceleration_time_inverse,     // Inverse of acceleration and deceleration periods, expressed as integer. Scale depends on CPU being used
              deceleration_time_inverse;
   #else
-    int32_t acceleration_rate;              // The acceleration rate used for acceleration calculation
+    uint32_t acceleration_rate;             // The acceleration rate used for acceleration calculation
   #endif
 
   uint8_t direction_bits;                   // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
 
   // Advance extrusion
   #if ENABLED(LIN_ADVANCE)
     bool use_advance_lead;
     uint16_t advance_speed,                 // Timer value for extruder speed offset
              max_adv_steps,                 // max. advance steps to get cruising speed pressure (not always nominal_speed!)
              final_adv_steps;               // advance steps due to exit speed
     float e_D_ratio;
   #endif
 
-  // Fields used by the motion planner to manage acceleration
-  float nominal_speed,                      // The nominal speed for this block in mm/sec
-        entry_speed,                        // Entry speed at previous-current junction in mm/sec
-        max_entry_speed,                    // Maximum allowable junction entry speed in mm/sec
-        millimeters,                        // The total travel of this block in mm
-        acceleration;                       // acceleration mm/sec^2
-
   uint32_t nominal_rate,                    // The nominal step rate for this block in step_events/sec
            initial_rate,                    // The jerk-adjusted step rate at start of block
            final_rate,                      // The minimal rate at exit
            acceleration_steps_per_s2;       // acceleration steps/sec^2
 
   #if FAN_COUNT > 0
     uint16_t fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
@@ -159,20 +169,21 @@ class Planner {
      *            head==tail : the buffer is empty
      *            head!=tail : blocks are in the buffer
      *   head==(tail-1)%size : the buffer is full
      *
      *  Writer of head is Planner::buffer_segment().
      *  Reader of tail is Stepper::isr(). Always consider tail busy / read-only
      */
     static block_t block_buffer[BLOCK_BUFFER_SIZE];
     static volatile uint8_t block_buffer_head,      // Index of the next block to be pushed
                             block_buffer_tail;      // Index of the busy block, if any
+    static int16_t cleaning_buffer_counter;         // A counter to disable queuing of blocks
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;                 // Respond to extruder change
     #endif
 
     static int16_t flow_percentage[EXTRUDERS];      // Extrusion factor for each extruder
 
     static float e_factor[EXTRUDERS];               // The flow percentage and volumetric multiplier combine to scale E movement
 
     #if DISABLED(NO_VOLUMETRICS)
@@ -226,37 +237,41 @@ class Planner {
         #if ENABLED(SKEW_CORRECTION_GCODE)
           static float xz_skew_factor, yz_skew_factor;
         #else
           static constexpr float xz_skew_factor = XZ_SKEW_FACTOR, yz_skew_factor = YZ_SKEW_FACTOR;
         #endif
       #else
         static constexpr float xz_skew_factor = 0, yz_skew_factor = 0;
       #endif
     #endif
 
+    #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+      static bool abort_on_endstop_hit;
+    #endif
+
   private:
 
     /**
      * The current position of the tool in absolute steps
      * Recalculated if any axis_steps_per_mm are changed by gcode
      */
     static int32_t position[NUM_AXIS];
 
     /**
      * Speed of previous path line segment
      */
     static float previous_speed[NUM_AXIS];
 
     /**
-     * Nominal speed of previous path line segment
+     * Nominal speed of previous path line segment (mm/s)^2
      */
-    static float previous_nominal_speed;
+    static float previous_nominal_speed_sqr;
 
     /**
      * Limit where 64bit math is necessary for acceleration calculation
      */
     static uint32_t cutoff_long;
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       static float last_fade_z;
     #endif
 
@@ -301,29 +316,20 @@ class Planner {
       e_factor[e] = (flow_percentage[e] * 0.01
         #if DISABLED(NO_VOLUMETRICS)
           * volumetric_multiplier[e]
         #endif
       );
     }
 
     // Manage fans, paste pressure, etc.
     static void check_axes_activity();
 
-    /**
-     * Number of moves currently in the planner
-     */
-    FORCE_INLINE static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail + BLOCK_BUFFER_SIZE); }
-
-    FORCE_INLINE static void clear_block_buffer() { block_buffer_head = block_buffer_tail = 0; }
-
-    FORCE_INLINE static bool is_full() { return block_buffer_tail == next_block_index(block_buffer_head); }
-
     // Update multipliers based on new diameter measurements
     static void calculate_volumetric_multipliers();
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       void calculate_volumetric_for_width_sensor(const int8_t encoded_ratio);
     #endif
 
     #if DISABLED(NO_VOLUMETRICS)
 
       FORCE_INLINE static void set_filament_size(const uint8_t e, const float &v) {
@@ -417,44 +423,82 @@ class Planner {
       #define ARG_X float rx
       #define ARG_Y float ry
       #define ARG_Z float rz
       static void unapply_leveling(float raw[XYZ]);
     #else
       #define ARG_X const float &rx
       #define ARG_Y const float &ry
       #define ARG_Z const float &rz
     #endif
 
+    // Number of moves currently in the planner
+    FORCE_INLINE static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail); }
+
+    // Remove all blocks from the buffer
+    FORCE_INLINE static void clear_block_buffer() { block_buffer_head = block_buffer_tail = 0; }
+
+    // Check if movement queue is full
+    FORCE_INLINE static bool is_full() { return block_buffer_tail == next_block_index(block_buffer_head); }
+
+    // Get count of movement slots free
+    FORCE_INLINE static uint8_t moves_free() { return BLOCK_BUFFER_SIZE - 1 - movesplanned(); }
+
     /**
      * Planner::get_next_free_block
      *
-     * - Get the next head index (passed by reference)
-     * - Wait for a space to open up in the planner
-     * - Return the head block
+     * - Get the next head indices (passed by reference)
+     * - Wait for the number of spaces to open up in the planner
+     * - Return the first head block
      */
-    FORCE_INLINE static block_t* get_next_free_block(uint8_t &next_buffer_head) {
+    FORCE_INLINE static block_t* get_next_free_block(uint8_t &next_buffer_head, uint8_t count = 1) {
+
+      // Wait until there are enough slots free
+      while (moves_free() < count) { idle(); }
+
+      // Return the first available block
       next_buffer_head = next_block_index(block_buffer_head);
-      while (block_buffer_tail == next_buffer_head) idle(); // while (is_full)
       return &block_buffer[block_buffer_head];
     }
 
     /**
      * Planner::_buffer_steps
      *
      * Add a new linear movement to the buffer (in terms of steps).
      *
      *  target      - target position in steps units
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
+     *
+     * Returns true if movement was buffered, false otherwise
      */
-    static void _buffer_steps(const int32_t (&target)[XYZE]
+    static bool _buffer_steps(const int32_t (&target)[XYZE]
+      #if HAS_POSITION_FLOAT
+        , const float (&target_float)[XYZE]
+      #endif
+      , float fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
+    );
+
+    /**
+     * Planner::_populate_block
+     *
+     * Fills a new linear movement in the block (in terms of steps).
+     *
+     *  target      - target position in steps units
+     *  fr_mm_s     - (target) speed of the move
+     *  extruder    - target extruder
+     *  millimeters - the length of the movement, if known
+     *
+     * Returns true is movement is acceptable, false otherwise
+     */
+    static bool _populate_block(block_t * const block, bool split_move,
+        const int32_t (&target)[XYZE]
       #if HAS_POSITION_FLOAT
         , const float (&target_float)[XYZE]
       #endif
       , float fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
     /**
      * Planner::buffer_sync_block
      * Add a block to the buffer that just updates the position
      */
@@ -465,66 +509,66 @@ class Planner {
      *
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e     - target positions in mm and/or degrees
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      */
-    static void buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0);
+    static bool buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0);
 
     static void _set_position_mm(const float &a, const float &b, const float &c, const float &e);
 
     /**
      * Add a new linear movement to the buffer.
      * The target is NOT translated to delta/scara
      *
      * Leveling will be applied to input on cartesians.
      * Kinematic machines should call buffer_line_kinematic (for leveled moves).
      * (Cartesians may also call buffer_line_kinematic.)
      *
      *  rx,ry,rz,e   - target position in mm or degrees
      *  fr_mm_s      - (target) speed of the move (mm/s)
      *  extruder     - target extruder
      *  millimeters  - the length of the movement, if known
      */
-    FORCE_INLINE static void buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, const float &fr_mm_s, const uint8_t extruder, const float millimeters = 0.0) {
+    FORCE_INLINE static bool buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, const float &fr_mm_s, const uint8_t extruder, const float millimeters = 0.0) {
       #if PLANNER_LEVELING && IS_CARTESIAN
         apply_leveling(rx, ry, rz);
       #endif
-      buffer_segment(rx, ry, rz, e, fr_mm_s, extruder, millimeters);
+      return buffer_segment(rx, ry, rz, e, fr_mm_s, extruder, millimeters);
     }
 
     /**
      * Add a new linear movement to the buffer.
      * The target is cartesian, it's translated to delta/scara if
      * needed.
      *
      *  cart         - x,y,z,e CARTESIAN target in mm
      *  fr_mm_s      - (target) speed of the move (mm/s)
      *  extruder     - target extruder
      *  millimeters  - the length of the movement, if known
      */
-    FORCE_INLINE static void buffer_line_kinematic(const float (&cart)[XYZE], const float &fr_mm_s, const uint8_t extruder, const float millimeters = 0.0) {
+    FORCE_INLINE static bool buffer_line_kinematic(const float (&cart)[XYZE], const float &fr_mm_s, const uint8_t extruder, const float millimeters = 0.0) {
       #if PLANNER_LEVELING
         float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
         apply_leveling(raw);
       #else
         const float (&raw)[XYZE] = cart;
       #endif
       #if IS_KINEMATIC
         inverse_kinematics(raw);
-        buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS], fr_mm_s, extruder, millimeters);
+        return buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS], fr_mm_s, extruder, millimeters);
       #else
-        buffer_segment(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS], fr_mm_s, extruder, millimeters);
+        return buffer_segment(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS], fr_mm_s, extruder, millimeters);
       #endif
     }
 
     /**
      * Set the planner.position and individual stepper positions.
      * Used by G92, G28, G29, and other procedures.
      *
      * Multiplies by axis_steps_per_mm[] and does necessary conversion
      * for COREXY / COREXZ / COREYZ to set the corresponding stepper positions.
      *
@@ -534,64 +578,62 @@ class Planner {
       #if PLANNER_LEVELING && IS_CARTESIAN
         apply_leveling(rx, ry, rz);
       #endif
       _set_position_mm(rx, ry, rz, e);
     }
     static void set_position_mm_kinematic(const float (&cart)[XYZE]);
     static void set_position_mm(const AxisEnum axis, const float &v);
     FORCE_INLINE static void set_z_position_mm(const float &z) { set_position_mm(Z_AXIS, z); }
     FORCE_INLINE static void set_e_position_mm(const float &e) { set_position_mm(E_AXIS, e); }
 
-    /**
-     * Sync from the stepper positions. (e.g., after an interrupted move)
-     */
-    static void sync_from_steppers();
-
     /**
      * Get an axis position according to stepper position(s)
      * For CORE machines apply translation from ABC to XYZ.
      */
     static float get_axis_position_mm(const AxisEnum axis);
 
     // SCARA AB axes are in degrees, not mm
     #if IS_SCARA
       FORCE_INLINE static float get_axis_position_degrees(const AxisEnum axis) { return get_axis_position_mm(axis); }
     #endif
 
-    /**
-     * Does the buffer have any blocks queued?
-     */
-    FORCE_INLINE static bool has_blocks_queued() { return (block_buffer_head != block_buffer_tail); }
+    // Called to force a quick stop of the machine (for example, when an emergency
+    // stop is required, or when endstops are hit)
+    static void quick_stop();
+
+    // Called when an endstop is triggered. Causes the machine to stop inmediately
+    static void endstop_triggered(const AxisEnum axis);
 
-    //
-    // Block until all buffered steps are executed
-    //
+    // Triggered position of an axis in mm (not core-savvy)
+    static float triggered_position_mm(const AxisEnum axis);
+
+    // Block until all buffered steps are executed / cleaned
     static void synchronize();
 
-    /**
-     * "Discard" the block and "release" the memory.
-     * Called when the current block is no longer needed.
-     */
-    FORCE_INLINE static void discard_current_block() {
-      if (has_blocks_queued())
-        block_buffer_tail = BLOCK_MOD(block_buffer_tail + 1);
+    // Wait for moves to finish and disable all steppers
+    static void finish_and_disable();
+
+    // Periodic tick to handle cleaning timeouts
+    // Called from the Temperature ISR at ~1kHz
+    static void tick() {
+      if (cleaning_buffer_counter) {
+        --cleaning_buffer_counter;
+        #if ENABLED(SD_FINISHED_STEPPERRELEASE) && defined(SD_FINISHED_RELEASECOMMAND)
+          if (!cleaning_buffer_counter) enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
+        #endif
+      }
     }
 
     /**
-     * "Discard" the next block if it's continued.
-     * Called after an interrupted move to throw away the rest of the move.
+     * Does the buffer have any blocks queued?
      */
-    FORCE_INLINE static bool discard_continued_block() {
-      const bool discard = has_blocks_queued() && TEST(block_buffer[block_buffer_tail].flag, BLOCK_BIT_CONTINUED);
-      if (discard) discard_current_block();
-      return discard;
-    }
+    FORCE_INLINE static bool has_blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
     /**
      * The current block. NULL if the buffer is empty.
      * This also marks the block as busy.
      * WARNING: Called from Stepper ISR context!
      */
     static block_t* get_current_block() {
       if (has_blocks_queued()) {
         block_t * const block = &block_buffer[block_buffer_tail];
 
@@ -611,39 +653,69 @@ class Planner {
         return block;
       }
       else {
         #if ENABLED(ULTRA_LCD)
           clear_block_buffer_runtime(); // paranoia. Buffer is empty now - so reset accumulated time to zero.
         #endif
         return NULL;
       }
     }
 
+    /**
+     * "Discard" the block and "release" the memory.
+     * Called when the current block is no longer needed.
+     * NB: There MUST be a current block to call this function!!
+     */
+    FORCE_INLINE static void discard_current_block() {
+      block_buffer_tail = BLOCK_MOD(block_buffer_tail + 1);
+    }
+
     #if ENABLED(ULTRA_LCD)
 
       static uint16_t block_buffer_runtime() {
-        CRITICAL_SECTION_START
-          millis_t bbru = block_buffer_runtime_us;
-        CRITICAL_SECTION_END
+        #ifdef __AVR__
+          // Protect the access to the variable. Only required for AVR, as
+          //  any 32bit CPU offers atomic access to 32bit variables
+          bool was_enabled = STEPPER_ISR_ENABLED();
+          if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+        #endif
+
+        millis_t bbru = block_buffer_runtime_us;
+
+        #ifdef __AVR__
+          // Reenable Stepper ISR
+          if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+        #endif
+
         // To translate ¬µs to ms a division by 1000 would be required.
         // We introduce 2.4% error here by dividing by 1024.
         // Doesn't matter because block_buffer_runtime_us is already too small an estimation.
         bbru >>= 10;
         // limit to about a minute.
         NOMORE(bbru, 0xFFFFul);
         return bbru;
       }
 
       static void clear_block_buffer_runtime() {
-        CRITICAL_SECTION_START
-          block_buffer_runtime_us = 0;
-        CRITICAL_SECTION_END
+        #ifdef __AVR__
+          // Protect the access to the variable. Only required for AVR, as
+          //  any 32bit CPU offers atomic access to 32bit variables
+          bool was_enabled = STEPPER_ISR_ENABLED();
+          if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+        #endif
+
+        block_buffer_runtime_us = 0;
+
+        #ifdef __AVR__
+          // Reenable Stepper ISR
+          if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+        #endif
       }
 
     #endif
 
     #if ENABLED(AUTOTEMP)
       static float autotemp_min, autotemp_max, autotemp_factor;
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
     #endif
@@ -672,26 +744,26 @@ class Planner {
      *
      * This is used to compute the intersection point between acceleration and deceleration
      * in cases where the "trapezoid" has no plateau (i.e., never reaches maximum speed)
      */
     static float intersection_distance(const float &initial_rate, const float &final_rate, const float &accel, const float &distance) {
       if (accel == 0) return 0; // accel was 0, set intersection distance to 0
       return (accel * 2 * distance - sq(initial_rate) + sq(final_rate)) / (accel * 4);
     }
 
     /**
-     * Calculate the maximum allowable speed at this point, in order
-     * to reach 'target_velocity' using 'acceleration' within a given
+     * Calculate the maximum allowable speed squared at this point, in order
+     * to reach 'target_velocity_sqr' using 'acceleration' within a given
      * 'distance'.
      */
-    static float max_allowable_speed(const float &accel, const float &target_velocity, const float &distance) {
-      return SQRT(sq(target_velocity) - 2 * accel * distance);
+    static float max_allowable_speed_sqr(const float &accel, const float &target_velocity_sqr, const float &distance) {
+      return target_velocity_sqr - 2 * accel * distance;
     }
 
     #if ENABLED(BEZIER_JERK_CONTROL)
       /**
        * Calculate the speed reached given initial speed, acceleration and distance
        */
       static float final_speed(const float &initial_velocity, const float &accel, const float &distance) {
         return SQRT(sq(initial_velocity) + 2 * accel * distance);
       }
     #endif

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index e7fe34031b..89a3716305 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -703,15 +703,15 @@ class Planner {
 
     static void reverse_pass();
     static void forward_pass();
 
     static void recalculate_trapezoids();
 
     static void recalculate();
 
 };
 
-#define PLANNER_XY_FEEDRATE() (min(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]))
+#define PLANNER_XY_FEEDRATE() (MIN(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]))
 
 extern Planner planner;
 
 #endif // PLANNER_H

commit 8f8c6a9bc4f1c8b2d927e74339a48217d9b48ec7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 09:59:11 2018 -0500

    Move get_axis_position_mm to Planner (#10718)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 148ca93bdb..e7fe34031b 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -539,20 +539,31 @@ class Planner {
     static void set_position_mm_kinematic(const float (&cart)[XYZE]);
     static void set_position_mm(const AxisEnum axis, const float &v);
     FORCE_INLINE static void set_z_position_mm(const float &z) { set_position_mm(Z_AXIS, z); }
     FORCE_INLINE static void set_e_position_mm(const float &e) { set_position_mm(E_AXIS, e); }
 
     /**
      * Sync from the stepper positions. (e.g., after an interrupted move)
      */
     static void sync_from_steppers();
 
+    /**
+     * Get an axis position according to stepper position(s)
+     * For CORE machines apply translation from ABC to XYZ.
+     */
+    static float get_axis_position_mm(const AxisEnum axis);
+
+    // SCARA AB axes are in degrees, not mm
+    #if IS_SCARA
+      FORCE_INLINE static float get_axis_position_degrees(const AxisEnum axis) { return get_axis_position_mm(axis); }
+    #endif
+
     /**
      * Does the buffer have any blocks queued?
      */
     FORCE_INLINE static bool has_blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
     //
     // Block until all buffered steps are executed
     //
     static void synchronize();
 

commit 306f0f2135e4b2aed749a0d1b870abf17d883e38
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 01:38:02 2018 -0500

    Move Stepper::synchronize to Planner (#10713)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index bb4483c383..148ca93bdb 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -544,20 +544,25 @@ class Planner {
     /**
      * Sync from the stepper positions. (e.g., after an interrupted move)
      */
     static void sync_from_steppers();
 
     /**
      * Does the buffer have any blocks queued?
      */
     FORCE_INLINE static bool has_blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
+    //
+    // Block until all buffered steps are executed
+    //
+    static void synchronize();
+
     /**
      * "Discard" the block and "release" the memory.
      * Called when the current block is no longer needed.
      */
     FORCE_INLINE static void discard_current_block() {
       if (has_blocks_queued())
         block_buffer_tail = BLOCK_MOD(block_buffer_tail + 1);
     }
 
     /**

commit a225d2e99e038c57f14a0363d22bcf27aa584a8c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 9 00:40:37 2018 -0500

    Fix compilation with UBL and Arc/B√©zier
    
    Fix #10660

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 46950528a4..bb4483c383 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -398,47 +398,39 @@ class Planner {
                       sy = cy + cz * yz_skew_factor;
           if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {
             cx = sx; cy = sy;
           }
         }
       }
 
     #endif // SKEW_CORRECTION
 
     #if PLANNER_LEVELING || HAS_UBL_AND_CURVES
-
       /**
        * Apply leveling to transform a cartesian position
        * as it will be given to the planner and steppers.
        */
       static void apply_leveling(float &rx, float &ry, float &rz);
       FORCE_INLINE static void apply_leveling(float (&raw)[XYZ]) { apply_leveling(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
+    #endif
 
-      #if PLANNER_LEVELING
-
-        #define ARG_X float rx
-        #define ARG_Y float ry
-        #define ARG_Z float rz
-
-        static void unapply_leveling(float raw[XYZ]);
-
-      #endif
-
+    #if PLANNER_LEVELING
+      #define ARG_X float rx
+      #define ARG_Y float ry
+      #define ARG_Z float rz
+      static void unapply_leveling(float raw[XYZ]);
     #else
-
       #define ARG_X const float &rx
       #define ARG_Y const float &ry
       #define ARG_Z const float &rz
-
     #endif
 
-
     /**
      * Planner::get_next_free_block
      *
      * - Get the next head index (passed by reference)
      * - Wait for a space to open up in the planner
      * - Return the head block
      */
     FORCE_INLINE static block_t* get_next_free_block(uint8_t &next_buffer_head) {
       next_buffer_head = next_block_index(block_buffer_head);
       while (block_buffer_tail == next_buffer_head) idle(); // while (is_full)

commit 19f189b4e5e10bdbdb3b28d94fa180f74cdbd654
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 8 11:10:45 2018 -0500

    Add UBL support for G2/G3 and G5 (#10648)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index eceb31f3a1..46950528a4 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -397,33 +397,38 @@ class Planner {
           const float sx = cx + cy * xy_skew_factor + cz * xz_skew_factor,
                       sy = cy + cz * yz_skew_factor;
           if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {
             cx = sx; cy = sy;
           }
         }
       }
 
     #endif // SKEW_CORRECTION
 
-    #if PLANNER_LEVELING
-
-      #define ARG_X float rx
-      #define ARG_Y float ry
-      #define ARG_Z float rz
+    #if PLANNER_LEVELING || HAS_UBL_AND_CURVES
 
       /**
        * Apply leveling to transform a cartesian position
        * as it will be given to the planner and steppers.
        */
       static void apply_leveling(float &rx, float &ry, float &rz);
-      static void apply_leveling(float (&raw)[XYZ]) { apply_leveling(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
-      static void unapply_leveling(float raw[XYZ]);
+      FORCE_INLINE static void apply_leveling(float (&raw)[XYZ]) { apply_leveling(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
+
+      #if PLANNER_LEVELING
+
+        #define ARG_X float rx
+        #define ARG_Y float ry
+        #define ARG_Z float rz
+
+        static void unapply_leveling(float raw[XYZ]);
+
+      #endif
 
     #else
 
       #define ARG_X const float &rx
       #define ARG_Y const float &ry
       #define ARG_Z const float &rz
 
     #endif
 
 

commit af1950a63e4049c6f870fffcc12bf6e0f15dddac
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 3 17:45:13 2018 -0500

    Improve sync of stepper positions

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 031cee7451..eceb31f3a1 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -50,28 +50,32 @@ enum BlockFlagBit : char {
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).
   BLOCK_BIT_NOMINAL_LENGTH,
 
   // The block is busy
   BLOCK_BIT_BUSY,
 
   // The block is segment 2+ of a longer move
-  BLOCK_BIT_CONTINUED
+  BLOCK_BIT_CONTINUED,
+
+  // Sync the stepper counts from the block
+  BLOCK_BIT_SYNC_POSITION
 };
 
 enum BlockFlag : char {
   BLOCK_FLAG_RECALCULATE          = _BV(BLOCK_BIT_RECALCULATE),
   BLOCK_FLAG_NOMINAL_LENGTH       = _BV(BLOCK_BIT_NOMINAL_LENGTH),
   BLOCK_FLAG_BUSY                 = _BV(BLOCK_BIT_BUSY),
-  BLOCK_FLAG_CONTINUED            = _BV(BLOCK_BIT_CONTINUED)
+  BLOCK_FLAG_CONTINUED            = _BV(BLOCK_BIT_CONTINUED),
+  BLOCK_FLAG_SYNC_POSITION        = _BV(BLOCK_BIT_SYNC_POSITION)
 };
 
 /**
  * struct block_t
  *
  * A single entry in the planner buffer.
  * Tracks linear movement over multiple axes.
  *
  * The "nominal" values are as-specified by gcode, and
  * may never actually be reached due to acceleration limits.
@@ -415,37 +419,57 @@ class Planner {
       static void unapply_leveling(float raw[XYZ]);
 
     #else
 
       #define ARG_X const float &rx
       #define ARG_Y const float &ry
       #define ARG_Z const float &rz
 
     #endif
 
+
+    /**
+     * Planner::get_next_free_block
+     *
+     * - Get the next head index (passed by reference)
+     * - Wait for a space to open up in the planner
+     * - Return the head block
+     */
+    FORCE_INLINE static block_t* get_next_free_block(uint8_t &next_buffer_head) {
+      next_buffer_head = next_block_index(block_buffer_head);
+      while (block_buffer_tail == next_buffer_head) idle(); // while (is_full)
+      return &block_buffer[block_buffer_head];
+    }
+
     /**
      * Planner::_buffer_steps
      *
      * Add a new linear movement to the buffer (in terms of steps).
      *
      *  target      - target position in steps units
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      */
     static void _buffer_steps(const int32_t (&target)[XYZE]
       #if HAS_POSITION_FLOAT
         , const float (&target_float)[XYZE]
       #endif
       , float fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
+    /**
+     * Planner::buffer_sync_block
+     * Add a block to the buffer that just updates the position
+     */
+    static void buffer_sync_block();
+
     /**
      * Planner::buffer_segment
      *
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e     - target positions in mm and/or degrees
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
@@ -511,31 +535,31 @@ class Planner {
      */
     FORCE_INLINE static void set_position_mm(ARG_X, ARG_Y, ARG_Z, const float &e) {
       #if PLANNER_LEVELING && IS_CARTESIAN
         apply_leveling(rx, ry, rz);
       #endif
       _set_position_mm(rx, ry, rz, e);
     }
     static void set_position_mm_kinematic(const float (&cart)[XYZE]);
     static void set_position_mm(const AxisEnum axis, const float &v);
     FORCE_INLINE static void set_z_position_mm(const float &z) { set_position_mm(Z_AXIS, z); }
-    FORCE_INLINE static void set_e_position_mm(const float &e) { set_position_mm(AxisEnum(E_AXIS), e); }
+    FORCE_INLINE static void set_e_position_mm(const float &e) { set_position_mm(E_AXIS, e); }
 
     /**
      * Sync from the stepper positions. (e.g., after an interrupted move)
      */
     static void sync_from_steppers();
 
     /**
      * Does the buffer have any blocks queued?
      */
-    static bool has_blocks_queued() { return (block_buffer_head != block_buffer_tail); }
+    FORCE_INLINE static bool has_blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
     /**
      * "Discard" the block and "release" the memory.
      * Called when the current block is no longer needed.
      */
     FORCE_INLINE static void discard_current_block() {
       if (has_blocks_queued())
         block_buffer_tail = BLOCK_MOD(block_buffer_tail + 1);
     }
 

commit d7b699ec340caf0c14efda13c7ced4fec78ecff9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 1 07:05:18 2018 -0500

    Fewer includes of vector_3.h

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 0b594fff61..031cee7451 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -33,21 +33,21 @@
 #define PLANNER_H
 
 #include "../Marlin.h"
 
 #include "motion.h"
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
-#if HAS_ABL
+#if ABL_PLANAR
   #include "../libs/vector_3.h"
 #endif
 
 enum BlockFlagBit : char {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).

commit 36b97bde9f92b6ebf899f5240cec62ca8abdcd94
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 13 22:04:53 2018 -0500

    clear_block_buffer, kill_current_block in quick_stop

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 17c133a1d0..0b594fff61 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -302,20 +302,22 @@ class Planner {
     }
 
     // Manage fans, paste pressure, etc.
     static void check_axes_activity();
 
     /**
      * Number of moves currently in the planner
      */
     FORCE_INLINE static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail + BLOCK_BUFFER_SIZE); }
 
+    FORCE_INLINE static void clear_block_buffer() { block_buffer_head = block_buffer_tail = 0; }
+
     FORCE_INLINE static bool is_full() { return block_buffer_tail == next_block_index(block_buffer_head); }
 
     // Update multipliers based on new diameter measurements
     static void calculate_volumetric_multipliers();
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       void calculate_volumetric_for_width_sensor(const int8_t encoded_ratio);
     #endif
 
     #if DISABLED(NO_VOLUMETRICS)
@@ -587,21 +589,21 @@ class Planner {
         CRITICAL_SECTION_END
         // To translate ¬µs to ms a division by 1000 would be required.
         // We introduce 2.4% error here by dividing by 1024.
         // Doesn't matter because block_buffer_runtime_us is already too small an estimation.
         bbru >>= 10;
         // limit to about a minute.
         NOMORE(bbru, 0xFFFFul);
         return bbru;
       }
 
-      static void clear_block_buffer_runtime(){
+      static void clear_block_buffer_runtime() {
         CRITICAL_SECTION_START
           block_buffer_runtime_us = 0;
         CRITICAL_SECTION_END
       }
 
     #endif
 
     #if ENABLED(AUTOTEMP)
       static float autotemp_min, autotemp_max, autotemp_factor;
       static bool autotemp_enabled;

commit 57a899a412b0d45c159423925c1f63164dcd9308
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Wed Apr 11 20:13:42 2018 -0300

    [2.0.x] 6th-order jerk-controlled motion planning in real-time for AVR (#10373)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 0c752c1f87..17c133a1d0 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -89,22 +89,24 @@ typedef struct {
   #if ENABLED(MIXING_EXTRUDER)
     uint32_t mix_event_count[MIXING_STEPPERS]; // Scaled step_event_count for the mixing steppers
   #endif
 
   // Settings for the trapezoid generator
   int32_t accelerate_until,                 // The index of the step event on which to stop acceleration
           decelerate_after;                 // The index of the step event on which to start decelerating
 
   #if ENABLED(BEZIER_JERK_CONTROL)
     uint32_t cruise_rate;                   // The actual cruise rate to use, between end of the acceleration phase and start of deceleration phase
-    int32_t acceleration_time,              // Acceleration time and deceleration time in STEP timer counts
-            deceleration_time;
+    uint32_t acceleration_time,             // Acceleration time and deceleration time in STEP timer counts
+             deceleration_time;
+    uint32_t acceleration_time_inverse,     // Inverse of acceleration and deceleration periods, expressed as integer. Scale depends on CPU being used
+             deceleration_time_inverse;
   #else
     int32_t acceleration_rate;              // The acceleration rate used for acceleration calculation
   #endif
 
   uint8_t direction_bits;                   // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
 
   // Advance extrusion
   #if ENABLED(LIN_ADVANCE)
     bool use_advance_lead;
     uint16_t advance_speed,                 // Timer value for extruder speed offset

commit a29adde5c0706a572261c40a02c61e1c966928a4
Author: etagle <ejtagle@hotmail.com>
Date:   Fri Apr 6 22:48:06 2018 -0300

    Implement BEZIER_JERK_CONTROL
    
    Enable 6th-order jerk-controlled motion planning in real-time.
    Only for 32bit MCUs. (AVR simply does not have enough processing power for this!)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index e2fedc4445..0c752c1f87 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -83,43 +83,50 @@ typedef struct {
   unsigned char active_extruder;            // The extruder to move (if E move)
 
   // Fields used by the Bresenham algorithm for tracing the line
   int32_t steps[NUM_AXIS];                  // Step count along each axis
   uint32_t step_event_count;                // The number of step events required to complete this block
 
   #if ENABLED(MIXING_EXTRUDER)
     uint32_t mix_event_count[MIXING_STEPPERS]; // Scaled step_event_count for the mixing steppers
   #endif
 
+  // Settings for the trapezoid generator
   int32_t accelerate_until,                 // The index of the step event on which to stop acceleration
-          decelerate_after,                 // The index of the step event on which to start decelerating
-          acceleration_rate;                // The acceleration rate used for acceleration calculation
+          decelerate_after;                 // The index of the step event on which to start decelerating
+
+  #if ENABLED(BEZIER_JERK_CONTROL)
+    uint32_t cruise_rate;                   // The actual cruise rate to use, between end of the acceleration phase and start of deceleration phase
+    int32_t acceleration_time,              // Acceleration time and deceleration time in STEP timer counts
+            deceleration_time;
+  #else
+    int32_t acceleration_rate;              // The acceleration rate used for acceleration calculation
+  #endif
 
   uint8_t direction_bits;                   // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
 
   // Advance extrusion
   #if ENABLED(LIN_ADVANCE)
     bool use_advance_lead;
     uint16_t advance_speed,                 // Timer value for extruder speed offset
              max_adv_steps,                 // max. advance steps to get cruising speed pressure (not always nominal_speed!)
              final_adv_steps;               // advance steps due to exit speed
     float e_D_ratio;
   #endif
 
   // Fields used by the motion planner to manage acceleration
   float nominal_speed,                      // The nominal speed for this block in mm/sec
         entry_speed,                        // Entry speed at previous-current junction in mm/sec
         max_entry_speed,                    // Maximum allowable junction entry speed in mm/sec
         millimeters,                        // The total travel of this block in mm
         acceleration;                       // acceleration mm/sec^2
 
-  // Settings for the trapezoid generator
   uint32_t nominal_rate,                    // The nominal step rate for this block in step_events/sec
            initial_rate,                    // The jerk-adjusted step rate at start of block
            final_rate,                      // The minimal rate at exit
            acceleration_steps_per_s2;       // acceleration steps/sec^2
 
   #if FAN_COUNT > 0
     uint16_t fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
@@ -632,20 +639,29 @@ class Planner {
 
     /**
      * Calculate the maximum allowable speed at this point, in order
      * to reach 'target_velocity' using 'acceleration' within a given
      * 'distance'.
      */
     static float max_allowable_speed(const float &accel, const float &target_velocity, const float &distance) {
       return SQRT(sq(target_velocity) - 2 * accel * distance);
     }
 
+    #if ENABLED(BEZIER_JERK_CONTROL)
+      /**
+       * Calculate the speed reached given initial speed, acceleration and distance
+       */
+      static float final_speed(const float &initial_velocity, const float &accel, const float &distance) {
+        return SQRT(sq(initial_velocity) + 2 * accel * distance);
+      }
+    #endif
+
     static void calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor);
 
     static void reverse_pass_kernel(block_t* const current, const block_t * const next);
     static void forward_pass_kernel(const block_t * const previous, block_t* const current);
 
     static void reverse_pass();
     static void forward_pass();
 
     static void recalculate_trapezoids();
 

commit e8e60263c8e454454d126f9154cf5c7ac3213725
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 5 15:47:56 2018 -0500

    Scale feedrate (mm/s to deg/s) for SCARA

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index da2cf36009..e2fedc4445 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -123,20 +123,22 @@ typedef struct {
   #endif
 
   #if ENABLED(BARICUDA)
     uint8_t valve_pressure, e_to_p_pressure;
   #endif
 
   uint32_t segment_time_us;
 
 } block_t;
 
+#define HAS_POSITION_FLOAT (ENABLED(LIN_ADVANCE) || ENABLED(SCARA_FEEDRATE_SCALING))
+
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 class Planner {
   public:
 
     /**
      * The move buffer, calculated in stepper steps
      *
      * block_buffer is a ring buffer...
      *
@@ -187,22 +189,25 @@ class Planner {
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         static float z_fade_height, inverse_z_fade_height;
       #endif
     #else
       static constexpr bool leveling_active = false;
     #endif
 
     #if ENABLED(LIN_ADVANCE)
-      static float extruder_advance_K,
-                   position_float[XYZE];
+      static float extruder_advance_K;
+    #endif
+
+    #if HAS_POSITION_FLOAT
+      static float position_float[XYZE];
     #endif
 
     #if ENABLED(SKEW_CORRECTION)
       #if ENABLED(SKEW_CORRECTION_GCODE)
         static float xy_skew_factor;
       #else
         static constexpr float xy_skew_factor = XY_SKEW_FACTOR;
       #endif
       #if ENABLED(SKEW_CORRECTION_FOR_Z)
         #if ENABLED(SKEW_CORRECTION_GCODE)
@@ -410,21 +415,21 @@ class Planner {
      * Planner::_buffer_steps
      *
      * Add a new linear movement to the buffer (in terms of steps).
      *
      *  target      - target position in steps units
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      */
     static void _buffer_steps(const int32_t (&target)[XYZE]
-      #if ENABLED(LIN_ADVANCE)
+      #if HAS_POSITION_FLOAT
         , const float (&target_float)[XYZE]
       #endif
       , float fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
     );
 
     /**
      * Planner::buffer_segment
      *
      * Add a new linear movement to the buffer in axis units.
      *

commit 1cb810ff1c04065daa29182a6c22ecf6b0c0098b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 21 19:30:06 2018 -0500

    [2.0.x] Automatically reset stepper timeout (#10179)
    
    * Automatically reset stepper timeout in manage_inactivity
    
    Any code that adds moves to the planner can skip resetting the stepper timeout. We can let `idle` / `manage_inactivity` reset the timer whenever it detects any moves in the planner.
    
    * blocks_queued => has_blocks_queued

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 4097c42b2e..da2cf36009 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -505,48 +505,48 @@ class Planner {
     FORCE_INLINE static void set_e_position_mm(const float &e) { set_position_mm(AxisEnum(E_AXIS), e); }
 
     /**
      * Sync from the stepper positions. (e.g., after an interrupted move)
      */
     static void sync_from_steppers();
 
     /**
      * Does the buffer have any blocks queued?
      */
-    static bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
+    static bool has_blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
     /**
      * "Discard" the block and "release" the memory.
      * Called when the current block is no longer needed.
      */
     FORCE_INLINE static void discard_current_block() {
-      if (blocks_queued())
+      if (has_blocks_queued())
         block_buffer_tail = BLOCK_MOD(block_buffer_tail + 1);
     }
 
     /**
      * "Discard" the next block if it's continued.
      * Called after an interrupted move to throw away the rest of the move.
      */
     FORCE_INLINE static bool discard_continued_block() {
-      const bool discard = blocks_queued() && TEST(block_buffer[block_buffer_tail].flag, BLOCK_BIT_CONTINUED);
+      const bool discard = has_blocks_queued() && TEST(block_buffer[block_buffer_tail].flag, BLOCK_BIT_CONTINUED);
       if (discard) discard_current_block();
       return discard;
     }
 
     /**
      * The current block. NULL if the buffer is empty.
      * This also marks the block as busy.
      * WARNING: Called from Stepper ISR context!
      */
     static block_t* get_current_block() {
-      if (blocks_queued()) {
+      if (has_blocks_queued()) {
         block_t * const block = &block_buffer[block_buffer_tail];
 
         // If the block has no trapezoid calculated, it's unsafe to execute.
         if (movesplanned() > 1) {
           const block_t * const next = &block_buffer[next_block_index(block_buffer_tail)];
           if (TEST(block->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE))
             return NULL;
         }
         else if (TEST(block->flag, BLOCK_BIT_RECALCULATE))
           return NULL;

commit 20571771848e2d8d3bb4f216c25c3d610c7e47cb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 6 22:35:22 2018 -0600

    Make enums into implicit char

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 5db086029d..4097c42b2e 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -37,37 +37,37 @@
 #include "motion.h"
 
 #if ENABLED(DELTA)
   #include "delta.h"
 #endif
 
 #if HAS_ABL
   #include "../libs/vector_3.h"
 #endif
 
-enum BlockFlagBit {
+enum BlockFlagBit : char {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).
   BLOCK_BIT_NOMINAL_LENGTH,
 
   // The block is busy
   BLOCK_BIT_BUSY,
 
   // The block is segment 2+ of a longer move
   BLOCK_BIT_CONTINUED
 };
 
-enum BlockFlag {
+enum BlockFlag : char {
   BLOCK_FLAG_RECALCULATE          = _BV(BLOCK_BIT_RECALCULATE),
   BLOCK_FLAG_NOMINAL_LENGTH       = _BV(BLOCK_BIT_NOMINAL_LENGTH),
   BLOCK_FLAG_BUSY                 = _BV(BLOCK_BIT_BUSY),
   BLOCK_FLAG_CONTINUED            = _BV(BLOCK_BIT_CONTINUED)
 };
 
 /**
  * struct block_t
  *
  * A single entry in the planner buffer.

commit 930720bbbb7ba69df066684cf598583fd6c49ab9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 4 21:19:06 2018 -0600

    Fix broken reverse planner (#9943)
    
    From #9914 by @Sebastianv650

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 1428168ed1..5db086029d 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -46,34 +46,30 @@
 
 enum BlockFlagBit {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).
   BLOCK_BIT_NOMINAL_LENGTH,
 
-  // Start from a halt at the start of this block, respecting the maximum allowed jerk.
-  BLOCK_BIT_START_FROM_FULL_HALT,
-
   // The block is busy
   BLOCK_BIT_BUSY,
 
   // The block is segment 2+ of a longer move
   BLOCK_BIT_CONTINUED
 };
 
 enum BlockFlag {
   BLOCK_FLAG_RECALCULATE          = _BV(BLOCK_BIT_RECALCULATE),
   BLOCK_FLAG_NOMINAL_LENGTH       = _BV(BLOCK_BIT_NOMINAL_LENGTH),
-  BLOCK_FLAG_START_FROM_FULL_HALT = _BV(BLOCK_BIT_START_FROM_FULL_HALT),
   BLOCK_FLAG_BUSY                 = _BV(BLOCK_BIT_BUSY),
   BLOCK_FLAG_CONTINUED            = _BV(BLOCK_BIT_CONTINUED)
 };
 
 /**
  * struct block_t
  *
  * A single entry in the planner buffer.
  * Tracks linear movement over multiple axes.
  *

commit 2bd252b50149c860cf37d488762abcf70a83f78d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Feb 23 00:53:29 2018 -0600

    [2.0.x] LIN_ADVANCE v1.5 (#9712)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index e1f3d988d1..1428168ed1 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -96,21 +96,24 @@ typedef struct {
 
   int32_t accelerate_until,                 // The index of the step event on which to stop acceleration
           decelerate_after,                 // The index of the step event on which to start decelerating
           acceleration_rate;                // The acceleration rate used for acceleration calculation
 
   uint8_t direction_bits;                   // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
 
   // Advance extrusion
   #if ENABLED(LIN_ADVANCE)
     bool use_advance_lead;
-    uint32_t abs_adv_steps_multiplier8; // Factorised by 2^8 to avoid float
+    uint16_t advance_speed,                 // Timer value for extruder speed offset
+             max_adv_steps,                 // max. advance steps to get cruising speed pressure (not always nominal_speed!)
+             final_adv_steps;               // advance steps due to exit speed
+    float e_D_ratio;
   #endif
 
   // Fields used by the motion planner to manage acceleration
   float nominal_speed,                      // The nominal speed for this block in mm/sec
         entry_speed,                        // Entry speed at previous-current junction in mm/sec
         max_entry_speed,                    // Maximum allowable junction entry speed in mm/sec
         millimeters,                        // The total travel of this block in mm
         acceleration;                       // acceleration mm/sec^2
 
   // Settings for the trapezoid generator
@@ -188,23 +191,22 @@ class Planner {
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         static float z_fade_height, inverse_z_fade_height;
       #endif
     #else
       static constexpr bool leveling_active = false;
     #endif
 
     #if ENABLED(LIN_ADVANCE)
-      static float extruder_advance_k, advance_ed_ratio,
-                   position_float[XYZE],
-                   lin_dist_xy, lin_dist_e;
+      static float extruder_advance_K,
+                   position_float[XYZE];
     #endif
 
     #if ENABLED(SKEW_CORRECTION)
       #if ENABLED(SKEW_CORRECTION_GCODE)
         static float xy_skew_factor;
       #else
         static constexpr float xy_skew_factor = XY_SKEW_FACTOR;
       #endif
       #if ENABLED(SKEW_CORRECTION_FOR_Z)
         #if ENABLED(SKEW_CORRECTION_GCODE)
@@ -411,35 +413,40 @@ class Planner {
     /**
      * Planner::_buffer_steps
      *
      * Add a new linear movement to the buffer (in terms of steps).
      *
      *  target      - target position in steps units
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      */
-    static void _buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const uint8_t extruder, const float &millimeters = 0.0);
+    static void _buffer_steps(const int32_t (&target)[XYZE]
+      #if ENABLED(LIN_ADVANCE)
+        , const float (&target_float)[XYZE]
+      #endif
+      , float fr_mm_s, const uint8_t extruder, const float &millimeters=0.0
+    );
 
     /**
      * Planner::buffer_segment
      *
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e     - target positions in mm and/or degrees
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      *  millimeters - the length of the movement, if known
      */
-    static void buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder, const float &millimeters = 0.0);
+    static void buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder, const float &millimeters=0.0);
 
     static void _set_position_mm(const float &a, const float &b, const float &c, const float &e);
 
     /**
      * Add a new linear movement to the buffer.
      * The target is NOT translated to delta/scara
      *
      * Leveling will be applied to input on cartesians.
      * Kinematic machines should call buffer_line_kinematic (for leveled moves).
      * (Cartesians may also call buffer_line_kinematic.)

commit 786746404b8aa58c44a93734afd61c701d2abecb
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Feb 4 00:26:05 2018 -0600

    [2.0.x] Apply feedrate to nozzle movement for kinematic machines (#8778)

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index a904caacb5..e1f3d988d1 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -409,78 +409,82 @@ class Planner {
     #endif
 
     /**
      * Planner::_buffer_steps
      *
      * Add a new linear movement to the buffer (in terms of steps).
      *
      *  target      - target position in steps units
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
+     *  millimeters - the length of the movement, if known
      */
-    static void _buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const uint8_t extruder);
+    static void _buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const uint8_t extruder, const float &millimeters = 0.0);
 
     /**
      * Planner::buffer_segment
      *
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
-     *  a,b,c,e   - target positions in mm and/or degrees
-     *  fr_mm_s   - (target) speed of the move
-     *  extruder  - target extruder
+     *  a,b,c,e     - target positions in mm and/or degrees
+     *  fr_mm_s     - (target) speed of the move
+     *  extruder    - target extruder
+     *  millimeters - the length of the movement, if known
      */
-    static void buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder);
+    static void buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder, const float &millimeters = 0.0);
 
     static void _set_position_mm(const float &a, const float &b, const float &c, const float &e);
 
     /**
      * Add a new linear movement to the buffer.
      * The target is NOT translated to delta/scara
      *
      * Leveling will be applied to input on cartesians.
      * Kinematic machines should call buffer_line_kinematic (for leveled moves).
      * (Cartesians may also call buffer_line_kinematic.)
      *
      *  rx,ry,rz,e   - target position in mm or degrees
      *  fr_mm_s      - (target) speed of the move (mm/s)
      *  extruder     - target extruder
+     *  millimeters  - the length of the movement, if known
      */
-    FORCE_INLINE static void buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, const float &fr_mm_s, const uint8_t extruder) {
+    FORCE_INLINE static void buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, const float &fr_mm_s, const uint8_t extruder, const float millimeters = 0.0) {
       #if PLANNER_LEVELING && IS_CARTESIAN
         apply_leveling(rx, ry, rz);
       #endif
-      buffer_segment(rx, ry, rz, e, fr_mm_s, extruder);
+      buffer_segment(rx, ry, rz, e, fr_mm_s, extruder, millimeters);
     }
 
     /**
      * Add a new linear movement to the buffer.
      * The target is cartesian, it's translated to delta/scara if
      * needed.
      *
-     *  cart     - x,y,z,e CARTESIAN target in mm
-     *  fr_mm_s  - (target) speed of the move (mm/s)
-     *  extruder - target extruder
+     *  cart         - x,y,z,e CARTESIAN target in mm
+     *  fr_mm_s      - (target) speed of the move (mm/s)
+     *  extruder     - target extruder
+     *  millimeters  - the length of the movement, if known
      */
-    FORCE_INLINE static void buffer_line_kinematic(const float (&cart)[XYZE], const float &fr_mm_s, const uint8_t extruder) {
+    FORCE_INLINE static void buffer_line_kinematic(const float (&cart)[XYZE], const float &fr_mm_s, const uint8_t extruder, const float millimeters = 0.0) {
       #if PLANNER_LEVELING
         float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
         apply_leveling(raw);
       #else
         const float (&raw)[XYZE] = cart;
       #endif
       #if IS_KINEMATIC
         inverse_kinematics(raw);
-        buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS], fr_mm_s, extruder);
+        buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS], fr_mm_s, extruder, millimeters);
       #else
-        buffer_segment(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS], fr_mm_s, extruder);
+        buffer_segment(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS], fr_mm_s, extruder, millimeters);
       #endif
     }
 
     /**
      * Set the planner.position and individual stepper positions.
      * Used by G92, G28, G29, and other procedures.
      *
      * Multiplies by axis_steps_per_mm[] and does necessary conversion
      * for COREXY / COREXZ / COREYZ to set the corresponding stepper positions.
      *

commit 4f5e087ff49a57790b3e02ca895b15795e595713
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 11 21:02:13 2018 -0600

    Planner anti-stutter by Sebastian Popp

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index efdd4c7be9..a904caacb5 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -527,20 +527,30 @@ class Planner {
     }
 
     /**
      * The current block. NULL if the buffer is empty.
      * This also marks the block as busy.
      * WARNING: Called from Stepper ISR context!
      */
     static block_t* get_current_block() {
       if (blocks_queued()) {
         block_t * const block = &block_buffer[block_buffer_tail];
+
+        // If the block has no trapezoid calculated, it's unsafe to execute.
+        if (movesplanned() > 1) {
+          const block_t * const next = &block_buffer[next_block_index(block_buffer_tail)];
+          if (TEST(block->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE))
+            return NULL;
+        }
+        else if (TEST(block->flag, BLOCK_BIT_RECALCULATE))
+          return NULL;
+
         #if ENABLED(ULTRA_LCD)
           block_buffer_runtime_us -= block->segment_time_us; // We can't be sure how long an active block will take, so don't count it.
         #endif
         SBI(block->flag, BLOCK_BIT_BUSY);
         return block;
       }
       else {
         #if ENABLED(ULTRA_LCD)
           clear_block_buffer_runtime(); // paranoia. Buffer is empty now - so reset accumulated time to zero.
         #endif

commit 5bc2acc0728b08a296cc5cdf16ac63c68d2aae68
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Dec 21 16:39:18 2017 -0600

    Restore position_float to fix LIN_ADVANCE

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 444073eef0..efdd4c7be9 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -188,21 +188,23 @@ class Planner {
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         static float z_fade_height, inverse_z_fade_height;
       #endif
     #else
       static constexpr bool leveling_active = false;
     #endif
 
     #if ENABLED(LIN_ADVANCE)
-      static float extruder_advance_k, advance_ed_ratio;
+      static float extruder_advance_k, advance_ed_ratio,
+                   position_float[XYZE],
+                   lin_dist_xy, lin_dist_e;
     #endif
 
     #if ENABLED(SKEW_CORRECTION)
       #if ENABLED(SKEW_CORRECTION_GCODE)
         static float xy_skew_factor;
       #else
         static constexpr float xy_skew_factor = XY_SKEW_FACTOR;
       #endif
       #if ENABLED(SKEW_CORRECTION_FOR_Z)
         #if ENABLED(SKEW_CORRECTION_GCODE)

commit 933f76fda3a2e8ecd9b3e8493b2885f4356b0430
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 19 19:44:11 2017 -0600

    Option to disable all volumetric extrusion

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 842ff2d213..444073eef0 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -152,25 +152,28 @@ class Planner {
     static block_t block_buffer[BLOCK_BUFFER_SIZE];
     static volatile uint8_t block_buffer_head,      // Index of the next block to be pushed
                             block_buffer_tail;      // Index of the busy block, if any
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;                 // Respond to extruder change
     #endif
 
     static int16_t flow_percentage[EXTRUDERS];      // Extrusion factor for each extruder
 
-    static float e_factor[EXTRUDERS],               // The flow percentage and volumetric multiplier combine to scale E movement
-                 filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
-                 volumetric_area_nominal,           // Nominal cross-sectional area
-                 volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
-                                                    // May be auto-adjusted by a filament width sensor
+    static float e_factor[EXTRUDERS];               // The flow percentage and volumetric multiplier combine to scale E movement
+
+    #if DISABLED(NO_VOLUMETRICS)
+      static float filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
+                   volumetric_area_nominal,           // Nominal cross-sectional area
+                   volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
+                                                      // May be auto-adjusted by a filament width sensor
+    #endif
 
     static float max_feedrate_mm_s[XYZE_N],         // Max speeds in mm per second
                  axis_steps_per_mm[XYZE_N],
                  steps_to_mm[XYZE_N];
     static uint32_t max_acceleration_steps_per_s2[XYZE_N],
                     max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override
 
     static uint32_t min_segment_time_us; // Use 'M205 B<¬µs>' to override
     static float min_feedrate_mm_s,
                  acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
@@ -270,46 +273,54 @@ class Planner {
     void init();
 
     /**
      * Static (class) Methods
      */
 
     static void reset_acceleration_rates();
     static void refresh_positioning();
 
     FORCE_INLINE static void refresh_e_factor(const uint8_t e) {
-      e_factor[e] = volumetric_multiplier[e] * flow_percentage[e] * 0.01;
+      e_factor[e] = (flow_percentage[e] * 0.01
+        #if DISABLED(NO_VOLUMETRICS)
+          * volumetric_multiplier[e]
+        #endif
+      );
     }
 
     // Manage fans, paste pressure, etc.
     static void check_axes_activity();
 
     /**
      * Number of moves currently in the planner
      */
     FORCE_INLINE static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail + BLOCK_BUFFER_SIZE); }
 
     FORCE_INLINE static bool is_full() { return block_buffer_tail == next_block_index(block_buffer_head); }
 
     // Update multipliers based on new diameter measurements
     static void calculate_volumetric_multipliers();
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       void calculate_volumetric_for_width_sensor(const int8_t encoded_ratio);
     #endif
 
-    FORCE_INLINE static void set_filament_size(const uint8_t e, const float &v) {
-      filament_size[e] = v;
-      // make sure all extruders have some sane value for the filament size
-      for (uint8_t i = 0; i < COUNT(filament_size); i++)
-        if (!filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;
-    }
+    #if DISABLED(NO_VOLUMETRICS)
+
+      FORCE_INLINE static void set_filament_size(const uint8_t e, const float &v) {
+        filament_size[e] = v;
+        // make sure all extruders have some sane value for the filament size
+        for (uint8_t i = 0; i < COUNT(filament_size); i++)
+          if (!filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;
+      }
+
+    #endif
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
 
       /**
        * Get the Z leveling fade factor based on the given Z height,
        * re-calculating only when needed.
        *
        *  Returns 1.0 if planner.z_fade_height is 0.0.
        *  Returns 0.0 if Z is past the specified 'Fade Height'.
        */

commit 09d13f186fa5b8ee4a123c928ffd7937e2f384b1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 15 14:24:20 2017 -0600

    Correct unskew, after all

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 73b4b069c6..842ff2d213 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -356,21 +356,21 @@ class Planner {
           const float sx = cx - cy * xy_skew_factor - cz * (xz_skew_factor - (xy_skew_factor * yz_skew_factor)),
                       sy = cy - cz * yz_skew_factor;
           if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {
             cx = sx; cy = sy;
           }
         }
       }
 
       FORCE_INLINE static void unskew(float &cx, float &cy, const float &cz) {
         if (WITHIN(cx, X_MIN_POS, X_MAX_POS) && WITHIN(cy, Y_MIN_POS, Y_MAX_POS)) {
-          const float sx = cx + cy * xy_skew_factor + cz * (xz_skew_factor - (xy_skew_factor * yz_skew_factor)),
+          const float sx = cx + cy * xy_skew_factor + cz * xz_skew_factor,
                       sy = cy + cz * yz_skew_factor;
           if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {
             cx = sx; cy = sy;
           }
         }
       }
 
     #endif // SKEW_CORRECTION
 
     #if PLANNER_LEVELING

commit 368c124de8ffbb234ff8bb6c45ce0e1ab07e91da
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 13 17:46:48 2017 -0600

    Fix Planner::unskew parity with skew

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 8b14dd5dcf..73b4b069c6 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -346,31 +346,31 @@ class Planner {
       }
 
       FORCE_INLINE static bool leveling_active_at_z(const float &rz) { UNUSED(rz); return true; }
 
     #endif
 
     #if ENABLED(SKEW_CORRECTION)
 
       FORCE_INLINE static void skew(float &cx, float &cy, const float &cz) {
         if (WITHIN(cx, X_MIN_POS + 1, X_MAX_POS) && WITHIN(cy, Y_MIN_POS + 1, Y_MAX_POS)) {
-          const float sx = cx - (cy * xy_skew_factor) - (cz * (xz_skew_factor - (xy_skew_factor * yz_skew_factor))),
-                      sy = cy - (cz * yz_skew_factor);
+          const float sx = cx - cy * xy_skew_factor - cz * (xz_skew_factor - (xy_skew_factor * yz_skew_factor)),
+                      sy = cy - cz * yz_skew_factor;
           if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {
             cx = sx; cy = sy;
           }
         }
       }
 
       FORCE_INLINE static void unskew(float &cx, float &cy, const float &cz) {
         if (WITHIN(cx, X_MIN_POS, X_MAX_POS) && WITHIN(cy, Y_MIN_POS, Y_MAX_POS)) {
-          const float sx = cx + cy * xy_skew_factor + cz * xz_skew_factor,
+          const float sx = cx + cy * xy_skew_factor + cz * (xz_skew_factor - (xy_skew_factor * yz_skew_factor)),
                       sy = cy + cz * yz_skew_factor;
           if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {
             cx = sx; cy = sy;
           }
         }
       }
 
     #endif // SKEW_CORRECTION
 
     #if PLANNER_LEVELING

commit cf2193c07ffc07597ece619da2db8cc587f68479
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 13 02:32:34 2017 -0600

    Comment, fix filament width sensor

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 6134f57659..8b14dd5dcf 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -286,20 +286,24 @@ class Planner {
     /**
      * Number of moves currently in the planner
      */
     FORCE_INLINE static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail + BLOCK_BUFFER_SIZE); }
 
     FORCE_INLINE static bool is_full() { return block_buffer_tail == next_block_index(block_buffer_head); }
 
     // Update multipliers based on new diameter measurements
     static void calculate_volumetric_multipliers();
 
+    #if ENABLED(FILAMENT_WIDTH_SENSOR)
+      void calculate_volumetric_for_width_sensor(const int8_t encoded_ratio);
+    #endif
+
     FORCE_INLINE static void set_filament_size(const uint8_t e, const float &v) {
       filament_size[e] = v;
       // make sure all extruders have some sane value for the filament size
       for (uint8_t i = 0; i < COUNT(filament_size); i++)
         if (!filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;
     }
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
 
       /**

commit 3255712343fdc9177cc94c86b2c31bf94ffbb8ca
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 07:50:55 2017 -0600

    Skew Correction for UBL
    
    Also remove unused grid slicing function when using UBL segmented.

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 4cdd9cb7ea..6134f57659 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -338,20 +338,44 @@ class Planner {
 
       FORCE_INLINE static float fade_scaling_factor_for_z(const float &rz) {
         UNUSED(rz);
         return 1.0;
       }
 
       FORCE_INLINE static bool leveling_active_at_z(const float &rz) { UNUSED(rz); return true; }
 
     #endif
 
+    #if ENABLED(SKEW_CORRECTION)
+
+      FORCE_INLINE static void skew(float &cx, float &cy, const float &cz) {
+        if (WITHIN(cx, X_MIN_POS + 1, X_MAX_POS) && WITHIN(cy, Y_MIN_POS + 1, Y_MAX_POS)) {
+          const float sx = cx - (cy * xy_skew_factor) - (cz * (xz_skew_factor - (xy_skew_factor * yz_skew_factor))),
+                      sy = cy - (cz * yz_skew_factor);
+          if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {
+            cx = sx; cy = sy;
+          }
+        }
+      }
+
+      FORCE_INLINE static void unskew(float &cx, float &cy, const float &cz) {
+        if (WITHIN(cx, X_MIN_POS, X_MAX_POS) && WITHIN(cy, Y_MIN_POS, Y_MAX_POS)) {
+          const float sx = cx + cy * xy_skew_factor + cz * xz_skew_factor,
+                      sy = cy + cz * yz_skew_factor;
+          if (WITHIN(sx, X_MIN_POS, X_MAX_POS) && WITHIN(sy, Y_MIN_POS, Y_MAX_POS)) {
+            cx = sx; cy = sy;
+          }
+        }
+      }
+
+    #endif // SKEW_CORRECTION
+
     #if PLANNER_LEVELING
 
       #define ARG_X float rx
       #define ARG_Y float ry
       #define ARG_Z float rz
 
       /**
        * Apply leveling to transform a cartesian position
        * as it will be given to the planner and steppers.
        */

commit 3db5303bfeed53180fb6a53caffcdf822fcfb285
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 07:41:19 2017 -0600

    _buffer_line => buffer_segment

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 55b88a7a59..4cdd9cb7ea 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -139,21 +139,21 @@ class Planner {
     /**
      * The move buffer, calculated in stepper steps
      *
      * block_buffer is a ring buffer...
      *
      *             head,tail : indexes for write,read
      *            head==tail : the buffer is empty
      *            head!=tail : blocks are in the buffer
      *   head==(tail-1)%size : the buffer is full
      *
-     *  Writer of head is Planner::_buffer_line().
+     *  Writer of head is Planner::buffer_segment().
      *  Reader of tail is Stepper::isr(). Always consider tail busy / read-only
      */
     static block_t block_buffer[BLOCK_BUFFER_SIZE];
     static volatile uint8_t block_buffer_head,      // Index of the next block to be pushed
                             block_buffer_tail;      // Index of the busy block, if any
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;                 // Respond to extruder change
     #endif
 
@@ -372,74 +372,74 @@ class Planner {
      *
      * Add a new linear movement to the buffer (in terms of steps).
      *
      *  target      - target position in steps units
      *  fr_mm_s     - (target) speed of the move
      *  extruder    - target extruder
      */
     static void _buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const uint8_t extruder);
 
     /**
-     * Planner::_buffer_line
+     * Planner::buffer_segment
      *
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e   - target positions in mm and/or degrees
      *  fr_mm_s   - (target) speed of the move
      *  extruder  - target extruder
      */
-    static void _buffer_line(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder);
+    static void buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder);
 
     static void _set_position_mm(const float &a, const float &b, const float &c, const float &e);
 
     /**
      * Add a new linear movement to the buffer.
      * The target is NOT translated to delta/scara
      *
      * Leveling will be applied to input on cartesians.
      * Kinematic machines should call buffer_line_kinematic (for leveled moves).
      * (Cartesians may also call buffer_line_kinematic.)
      *
      *  rx,ry,rz,e   - target position in mm or degrees
      *  fr_mm_s      - (target) speed of the move (mm/s)
      *  extruder     - target extruder
      */
     FORCE_INLINE static void buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, const float &fr_mm_s, const uint8_t extruder) {
       #if PLANNER_LEVELING && IS_CARTESIAN
         apply_leveling(rx, ry, rz);
       #endif
-      _buffer_line(rx, ry, rz, e, fr_mm_s, extruder);
+      buffer_segment(rx, ry, rz, e, fr_mm_s, extruder);
     }
 
     /**
      * Add a new linear movement to the buffer.
      * The target is cartesian, it's translated to delta/scara if
      * needed.
      *
      *  cart     - x,y,z,e CARTESIAN target in mm
      *  fr_mm_s  - (target) speed of the move (mm/s)
      *  extruder - target extruder
      */
     FORCE_INLINE static void buffer_line_kinematic(const float (&cart)[XYZE], const float &fr_mm_s, const uint8_t extruder) {
       #if PLANNER_LEVELING
         float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
         apply_leveling(raw);
       #else
         const float (&raw)[XYZE] = cart;
       #endif
       #if IS_KINEMATIC
         inverse_kinematics(raw);
-        _buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS], fr_mm_s, extruder);
+        buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS], fr_mm_s, extruder);
       #else
-        _buffer_line(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS], fr_mm_s, extruder);
+        buffer_segment(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS], fr_mm_s, extruder);
       #endif
     }
 
     /**
      * Set the planner.position and individual stepper positions.
      * Used by G92, G28, G29, and other procedures.
      *
      * Multiplies by axis_steps_per_mm[] and does necessary conversion
      * for COREXY / COREXZ / COREYZ to set the corresponding stepper positions.
      *

commit 73e32925e4b140fe23f62eeb658f807e4477d872
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 02:10:54 2017 -0600

    References are better for array args

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index cb0315c761..55b88a7a59 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -349,21 +349,21 @@ class Planner {
 
       #define ARG_X float rx
       #define ARG_Y float ry
       #define ARG_Z float rz
 
       /**
        * Apply leveling to transform a cartesian position
        * as it will be given to the planner and steppers.
        */
       static void apply_leveling(float &rx, float &ry, float &rz);
-      static void apply_leveling(float raw[XYZ]) { apply_leveling(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
+      static void apply_leveling(float (&raw)[XYZ]) { apply_leveling(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
       static void unapply_leveling(float raw[XYZ]);
 
     #else
 
       #define ARG_X const float &rx
       #define ARG_Y const float &ry
       #define ARG_Z const float &rz
 
     #endif
 
@@ -414,26 +414,26 @@ class Planner {
 
     /**
      * Add a new linear movement to the buffer.
      * The target is cartesian, it's translated to delta/scara if
      * needed.
      *
      *  cart     - x,y,z,e CARTESIAN target in mm
      *  fr_mm_s  - (target) speed of the move (mm/s)
      *  extruder - target extruder
      */
-    FORCE_INLINE static void buffer_line_kinematic(const float cart[XYZE], const float &fr_mm_s, const uint8_t extruder) {
+    FORCE_INLINE static void buffer_line_kinematic(const float (&cart)[XYZE], const float &fr_mm_s, const uint8_t extruder) {
       #if PLANNER_LEVELING
         float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
         apply_leveling(raw);
       #else
-        const float * const raw = cart;
+        const float (&raw)[XYZE] = cart;
       #endif
       #if IS_KINEMATIC
         inverse_kinematics(raw);
         _buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS], fr_mm_s, extruder);
       #else
         _buffer_line(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS], fr_mm_s, extruder);
       #endif
     }
 
     /**
@@ -444,21 +444,21 @@ class Planner {
      * for COREXY / COREXZ / COREYZ to set the corresponding stepper positions.
      *
      * Clears previous speed values.
      */
     FORCE_INLINE static void set_position_mm(ARG_X, ARG_Y, ARG_Z, const float &e) {
       #if PLANNER_LEVELING && IS_CARTESIAN
         apply_leveling(rx, ry, rz);
       #endif
       _set_position_mm(rx, ry, rz, e);
     }
-    static void set_position_mm_kinematic(const float position[NUM_AXIS]);
+    static void set_position_mm_kinematic(const float (&cart)[XYZE]);
     static void set_position_mm(const AxisEnum axis, const float &v);
     FORCE_INLINE static void set_z_position_mm(const float &z) { set_position_mm(Z_AXIS, z); }
     FORCE_INLINE static void set_e_position_mm(const float &e) { set_position_mm(AxisEnum(E_AXIS), e); }
 
     /**
      * Sync from the stepper positions. (e.g., after an interrupted move)
      */
     static void sync_from_steppers();
 
     /**

commit b3daf6b5db951abeda8246d207faf27474465784
Author: AnHardt <github@kitelab.de>
Date:   Sat Dec 9 04:38:45 2017 +0100

    [2.0.x] better reverse pass (#8722)
    
    * repair reverse_pass()
    
    And make it readeble.
    This was broken a long time ago.
    Not competely unfunctional but far from optimal.
    
    * Minor speedup when calling calculate_trapezoid_for_block
    
    2 float / to 1 foat / and 2 float *
    
    * Various style changes

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 2872ef53b8..cb0315c761 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -127,43 +127,52 @@ typedef struct {
     uint8_t valve_pressure, e_to_p_pressure;
   #endif
 
   uint32_t segment_time_us;
 
 } block_t;
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 class Planner {
-
   public:
 
     /**
-     * A ring buffer of moves described in steps
+     * The move buffer, calculated in stepper steps
+     *
+     * block_buffer is a ring buffer...
+     *
+     *             head,tail : indexes for write,read
+     *            head==tail : the buffer is empty
+     *            head!=tail : blocks are in the buffer
+     *   head==(tail-1)%size : the buffer is full
+     *
+     *  Writer of head is Planner::_buffer_line().
+     *  Reader of tail is Stepper::isr(). Always consider tail busy / read-only
      */
     static block_t block_buffer[BLOCK_BUFFER_SIZE];
-    static volatile uint8_t block_buffer_head,  // Index of the next block to be pushed
-                            block_buffer_tail;
+    static volatile uint8_t block_buffer_head,      // Index of the next block to be pushed
+                            block_buffer_tail;      // Index of the busy block, if any
 
     #if ENABLED(DISTINCT_E_FACTORS)
-      static uint8_t last_extruder;             // Respond to extruder change
+      static uint8_t last_extruder;                 // Respond to extruder change
     #endif
 
-    static int16_t flow_percentage[EXTRUDERS]; // Extrusion factor for each extruder
+    static int16_t flow_percentage[EXTRUDERS];      // Extrusion factor for each extruder
 
     static float e_factor[EXTRUDERS],               // The flow percentage and volumetric multiplier combine to scale E movement
                  filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
                  volumetric_area_nominal,           // Nominal cross-sectional area
                  volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                     // May be auto-adjusted by a filament width sensor
 
-    static float max_feedrate_mm_s[XYZE_N],     // Max speeds in mm per second
+    static float max_feedrate_mm_s[XYZE_N],         // Max speeds in mm per second
                  axis_steps_per_mm[XYZE_N],
                  steps_to_mm[XYZE_N];
     static uint32_t max_acceleration_steps_per_s2[XYZE_N],
                     max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override
 
     static uint32_t min_segment_time_us; // Use 'M205 B<¬µs>' to override
     static float min_feedrate_mm_s,
                  acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
                  retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
                  travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
@@ -270,23 +279,23 @@ class Planner {
     FORCE_INLINE static void refresh_e_factor(const uint8_t e) {
       e_factor[e] = volumetric_multiplier[e] * flow_percentage[e] * 0.01;
     }
 
     // Manage fans, paste pressure, etc.
     static void check_axes_activity();
 
     /**
      * Number of moves currently in the planner
      */
-    static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail + BLOCK_BUFFER_SIZE); }
+    FORCE_INLINE static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail + BLOCK_BUFFER_SIZE); }
 
-    static bool is_full() { return (block_buffer_tail == BLOCK_MOD(block_buffer_head + 1)); }
+    FORCE_INLINE static bool is_full() { return block_buffer_tail == next_block_index(block_buffer_head); }
 
     // Update multipliers based on new diameter measurements
     static void calculate_volumetric_multipliers();
 
     FORCE_INLINE static void set_filament_size(const uint8_t e, const float &v) {
       filament_size[e] = v;
       // make sure all extruders have some sane value for the filament size
       for (uint8_t i = 0; i < COUNT(filament_size); i++)
         if (!filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;
     }
@@ -526,22 +535,22 @@ class Planner {
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
     #endif
 
   private:
 
     /**
      * Get the index of the next / previous block in the ring buffer
      */
-    static int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
-    static int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
+    static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
+    static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
 
     /**
      * Calculate the distance (not time) it takes to accelerate
      * from initial_rate to target_rate using the given acceleration:
      */
     static float estimate_acceleration_distance(const float &initial_rate, const float &target_rate, const float &accel) {
       if (accel == 0) return 0; // accel was 0, set acceleration distance to 0
       return (sq(target_rate) - sq(initial_rate)) / (accel * 2);
     }
 
@@ -562,22 +571,22 @@ class Planner {
      * Calculate the maximum allowable speed at this point, in order
      * to reach 'target_velocity' using 'acceleration' within a given
      * 'distance'.
      */
     static float max_allowable_speed(const float &accel, const float &target_velocity, const float &distance) {
       return SQRT(sq(target_velocity) - 2 * accel * distance);
     }
 
     static void calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor);
 
-    static void reverse_pass_kernel(block_t* const current, const block_t *next);
-    static void forward_pass_kernel(const block_t *previous, block_t* const current);
+    static void reverse_pass_kernel(block_t* const current, const block_t * const next);
+    static void forward_pass_kernel(const block_t * const previous, block_t* const current);
 
     static void reverse_pass();
     static void forward_pass();
 
     static void recalculate_trapezoids();
 
     static void recalculate();
 
 };
 

commit 85c6ffbe0d411cd223f345705e2b1235239bd91e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Dec 7 23:03:36 2017 -0600

    Discard all "continued" blocks on interrupted move

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 9e70e3f690..2872ef53b8 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -50,28 +50,32 @@ enum BlockFlagBit {
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).
   BLOCK_BIT_NOMINAL_LENGTH,
 
   // Start from a halt at the start of this block, respecting the maximum allowed jerk.
   BLOCK_BIT_START_FROM_FULL_HALT,
 
   // The block is busy
-  BLOCK_BIT_BUSY
+  BLOCK_BIT_BUSY,
+
+  // The block is segment 2+ of a longer move
+  BLOCK_BIT_CONTINUED
 };
 
 enum BlockFlag {
   BLOCK_FLAG_RECALCULATE          = _BV(BLOCK_BIT_RECALCULATE),
   BLOCK_FLAG_NOMINAL_LENGTH       = _BV(BLOCK_BIT_NOMINAL_LENGTH),
   BLOCK_FLAG_START_FROM_FULL_HALT = _BV(BLOCK_BIT_START_FROM_FULL_HALT),
-  BLOCK_FLAG_BUSY                 = _BV(BLOCK_BIT_BUSY)
+  BLOCK_FLAG_BUSY                 = _BV(BLOCK_BIT_BUSY),
+  BLOCK_FLAG_CONTINUED            = _BV(BLOCK_BIT_CONTINUED)
 };
 
 /**
  * struct block_t
  *
  * A single entry in the planner buffer.
  * Tracks linear movement over multiple axes.
  *
  * The "nominal" values are as-specified by gcode, and
  * may never actually be reached due to acceleration limits.
@@ -447,36 +451,46 @@ class Planner {
      * Sync from the stepper positions. (e.g., after an interrupted move)
      */
     static void sync_from_steppers();
 
     /**
      * Does the buffer have any blocks queued?
      */
     static bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
 
     /**
-     * "Discards" the block and "releases" the memory.
+     * "Discard" the block and "release" the memory.
      * Called when the current block is no longer needed.
      */
-    static void discard_current_block() {
+    FORCE_INLINE static void discard_current_block() {
       if (blocks_queued())
         block_buffer_tail = BLOCK_MOD(block_buffer_tail + 1);
     }
 
+    /**
+     * "Discard" the next block if it's continued.
+     * Called after an interrupted move to throw away the rest of the move.
+     */
+    FORCE_INLINE static bool discard_continued_block() {
+      const bool discard = blocks_queued() && TEST(block_buffer[block_buffer_tail].flag, BLOCK_BIT_CONTINUED);
+      if (discard) discard_current_block();
+      return discard;
+    }
+
     /**
      * The current block. NULL if the buffer is empty.
      * This also marks the block as busy.
      * WARNING: Called from Stepper ISR context!
      */
     static block_t* get_current_block() {
       if (blocks_queued()) {
-        block_t* block = &block_buffer[block_buffer_tail];
+        block_t * const block = &block_buffer[block_buffer_tail];
         #if ENABLED(ULTRA_LCD)
           block_buffer_runtime_us -= block->segment_time_us; // We can't be sure how long an active block will take, so don't count it.
         #endif
         SBI(block->flag, BLOCK_BIT_BUSY);
         return block;
       }
       else {
         #if ENABLED(ULTRA_LCD)
           clear_block_buffer_runtime(); // paranoia. Buffer is empty now - so reset accumulated time to zero.
         #endif

commit de3d3b9cb19cce2be09b5c7c8be32a81bf2b6d97
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 8 00:37:09 2017 -0600

    Put FORCE_INLINE before static

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 314d6daa04..9e70e3f690 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -385,37 +385,37 @@ class Planner {
      * The target is NOT translated to delta/scara
      *
      * Leveling will be applied to input on cartesians.
      * Kinematic machines should call buffer_line_kinematic (for leveled moves).
      * (Cartesians may also call buffer_line_kinematic.)
      *
      *  rx,ry,rz,e   - target position in mm or degrees
      *  fr_mm_s      - (target) speed of the move (mm/s)
      *  extruder     - target extruder
      */
-    static FORCE_INLINE void buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, const float &fr_mm_s, const uint8_t extruder) {
+    FORCE_INLINE static void buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, const float &fr_mm_s, const uint8_t extruder) {
       #if PLANNER_LEVELING && IS_CARTESIAN
         apply_leveling(rx, ry, rz);
       #endif
       _buffer_line(rx, ry, rz, e, fr_mm_s, extruder);
     }
 
     /**
      * Add a new linear movement to the buffer.
      * The target is cartesian, it's translated to delta/scara if
      * needed.
      *
      *  cart     - x,y,z,e CARTESIAN target in mm
      *  fr_mm_s  - (target) speed of the move (mm/s)
      *  extruder - target extruder
      */
-    static FORCE_INLINE void buffer_line_kinematic(const float cart[XYZE], const float &fr_mm_s, const uint8_t extruder) {
+    FORCE_INLINE static void buffer_line_kinematic(const float cart[XYZE], const float &fr_mm_s, const uint8_t extruder) {
       #if PLANNER_LEVELING
         float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
         apply_leveling(raw);
       #else
         const float * const raw = cart;
       #endif
       #if IS_KINEMATIC
         inverse_kinematics(raw);
         _buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS], fr_mm_s, extruder);
       #else
@@ -425,30 +425,30 @@ class Planner {
 
     /**
      * Set the planner.position and individual stepper positions.
      * Used by G92, G28, G29, and other procedures.
      *
      * Multiplies by axis_steps_per_mm[] and does necessary conversion
      * for COREXY / COREXZ / COREYZ to set the corresponding stepper positions.
      *
      * Clears previous speed values.
      */
-    static FORCE_INLINE void set_position_mm(ARG_X, ARG_Y, ARG_Z, const float &e) {
+    FORCE_INLINE static void set_position_mm(ARG_X, ARG_Y, ARG_Z, const float &e) {
       #if PLANNER_LEVELING && IS_CARTESIAN
         apply_leveling(rx, ry, rz);
       #endif
       _set_position_mm(rx, ry, rz, e);
     }
     static void set_position_mm_kinematic(const float position[NUM_AXIS]);
     static void set_position_mm(const AxisEnum axis, const float &v);
-    static FORCE_INLINE void set_z_position_mm(const float &z) { set_position_mm(Z_AXIS, z); }
-    static FORCE_INLINE void set_e_position_mm(const float &e) { set_position_mm(AxisEnum(E_AXIS), e); }
+    FORCE_INLINE static void set_z_position_mm(const float &z) { set_position_mm(Z_AXIS, z); }
+    FORCE_INLINE static void set_e_position_mm(const float &e) { set_position_mm(AxisEnum(E_AXIS), e); }
 
     /**
      * Sync from the stepper positions. (e.g., after an interrupted move)
      */
     static void sync_from_steppers();
 
     /**
      * Does the buffer have any blocks queued?
      */
     static bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }

commit 840289e7ccaa79846acfdceee63ffc1baa77168c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 12:44:44 2017 -0600

    Use block cleaning instead of split flag

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index ce0a89cd11..314d6daa04 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -158,21 +158,20 @@ class Planner {
     static uint32_t max_acceleration_steps_per_s2[XYZE_N],
                     max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override
 
     static uint32_t min_segment_time_us; // Use 'M205 B<¬µs>' to override
     static float min_feedrate_mm_s,
                  acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
                  retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
                  travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
                  max_jerk[XYZE],       // The largest speed change requiring no acceleration
                  min_travel_feedrate_mm_s;
-    static bool split_first_move;
 
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
       #if ABL_PLANAR
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         static float z_fade_height, inverse_z_fade_height;
       #endif
     #else

commit a993c5227d4b48106798b08b327a36a53d60d302
Author: AnHardt <github@kitelab.de>
Date:   Wed Dec 6 14:08:49 2017 +0100

    Don't split first_move while homing or probing
    While homing or probing it might be bad if the stop/trobe triggers during the first part and the second is still in the buffer.

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 314d6daa04..ce0a89cd11 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -158,20 +158,21 @@ class Planner {
     static uint32_t max_acceleration_steps_per_s2[XYZE_N],
                     max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override
 
     static uint32_t min_segment_time_us; // Use 'M205 B<¬µs>' to override
     static float min_feedrate_mm_s,
                  acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
                  retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
                  travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
                  max_jerk[XYZE],       // The largest speed change requiring no acceleration
                  min_travel_feedrate_mm_s;
+    static bool split_first_move;
 
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
       #if ABL_PLANAR
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         static float z_fade_height, inverse_z_fade_height;
       #endif
     #else

commit a2372cfab5eef64812ea923f876a813de23b2b34
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 5 18:41:56 2017 -0600

    Fix SKEW_CORRECTION without leveling

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 37259f3783..314d6daa04 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -167,20 +167,22 @@ class Planner {
                  min_travel_feedrate_mm_s;
 
     #if HAS_LEVELING
       static bool leveling_active;          // Flag that bed leveling is enabled
       #if ABL_PLANAR
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         static float z_fade_height, inverse_z_fade_height;
       #endif
+    #else
+      static constexpr bool leveling_active = false;
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       static float extruder_advance_k, advance_ed_ratio;
     #endif
 
     #if ENABLED(SKEW_CORRECTION)
       #if ENABLED(SKEW_CORRECTION_GCODE)
         static float xy_skew_factor;
       #else

commit 4b612f590c730a1e8b757da717dbba45debb45e7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 30 16:40:42 2017 -0600

    Split first move to planner for better chaining

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 84818bc5f9..37259f3783 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -345,32 +345,43 @@ class Planner {
       static void unapply_leveling(float raw[XYZ]);
 
     #else
 
       #define ARG_X const float &rx
       #define ARG_Y const float &ry
       #define ARG_Z const float &rz
 
     #endif
 
+    /**
+     * Planner::_buffer_steps
+     *
+     * Add a new linear movement to the buffer (in terms of steps).
+     *
+     *  target      - target position in steps units
+     *  fr_mm_s     - (target) speed of the move
+     *  extruder    - target extruder
+     */
+    static void _buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const uint8_t extruder);
+
     /**
      * Planner::_buffer_line
      *
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e   - target positions in mm and/or degrees
      *  fr_mm_s   - (target) speed of the move
      *  extruder  - target extruder
      */
-    static void _buffer_line(const float &a, const float &b, const float &c, const float &e, float fr_mm_s, const uint8_t extruder);
+    static void _buffer_line(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder);
 
     static void _set_position_mm(const float &a, const float &b, const float &c, const float &e);
 
     /**
      * Add a new linear movement to the buffer.
      * The target is NOT translated to delta/scara
      *
      * Leveling will be applied to input on cartesians.
      * Kinematic machines should call buffer_line_kinematic (for leveled moves).
      * (Cartesians may also call buffer_line_kinematic.)

commit dd8febca1a29c08b002a31dd960279b28b7f2f12
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 3 16:52:48 2017 -0600

    Revert "Merge pull request #8611 from thinkyhead/bf2_planner_split_first"
    
    This reverts commit 824980e70eaec5598716b9bbfde1e98a5c1e2420, reversing
    changes made to aa7efb96bfffbbfc45d3a3e4a41810ef1b4b7c7a.

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 38474fad5f..84818bc5f9 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -137,21 +137,21 @@ class Planner {
      * A ring buffer of moves described in steps
      */
     static block_t block_buffer[BLOCK_BUFFER_SIZE];
     static volatile uint8_t block_buffer_head,  // Index of the next block to be pushed
                             block_buffer_tail;
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;             // Respond to extruder change
     #endif
 
-    static int16_t flow_percentage[EXTRUDERS];  // Extrusion factor for each extruder
+    static int16_t flow_percentage[EXTRUDERS]; // Extrusion factor for each extruder
 
     static float e_factor[EXTRUDERS],               // The flow percentage and volumetric multiplier combine to scale E movement
                  filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
                  volumetric_area_nominal,           // Nominal cross-sectional area
                  volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                     // May be auto-adjusted by a filament width sensor
 
     static float max_feedrate_mm_s[XYZE_N],     // Max speeds in mm per second
                  axis_steps_per_mm[XYZE_N],
                  steps_to_mm[XYZE_N];
@@ -345,43 +345,32 @@ class Planner {
       static void unapply_leveling(float raw[XYZ]);
 
     #else
 
       #define ARG_X const float &rx
       #define ARG_Y const float &ry
       #define ARG_Z const float &rz
 
     #endif
 
-    /**
-     * Planner::_buffer_steps
-     *
-     * Add a new linear movement to the buffer (in terms of steps).
-     *
-     *  target    - target position in steps units
-     *  fr_mm_s   - (target) speed of the move
-     *  extruder  - target extruder
-     */
-    static void _buffer_steps(const int32_t target[XYZE], float fr_mm_s, const uint8_t extruder);
-
     /**
      * Planner::_buffer_line
      *
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e   - target positions in mm and/or degrees
      *  fr_mm_s   - (target) speed of the move
      *  extruder  - target extruder
      */
-    static void _buffer_line(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder);
+    static void _buffer_line(const float &a, const float &b, const float &c, const float &e, float fr_mm_s, const uint8_t extruder);
 
     static void _set_position_mm(const float &a, const float &b, const float &c, const float &e);
 
     /**
      * Add a new linear movement to the buffer.
      * The target is NOT translated to delta/scara
      *
      * Leveling will be applied to input on cartesians.
      * Kinematic machines should call buffer_line_kinematic (for leveled moves).
      * (Cartesians may also call buffer_line_kinematic.)

commit 3a97de52ef6bc178e34af54db70f803b4d6ab451
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 30 16:40:42 2017 -0600

    Split first move to planner for better chaining
    
    Address #8573, #8595

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 84818bc5f9..38474fad5f 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -137,21 +137,21 @@ class Planner {
      * A ring buffer of moves described in steps
      */
     static block_t block_buffer[BLOCK_BUFFER_SIZE];
     static volatile uint8_t block_buffer_head,  // Index of the next block to be pushed
                             block_buffer_tail;
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;             // Respond to extruder change
     #endif
 
-    static int16_t flow_percentage[EXTRUDERS]; // Extrusion factor for each extruder
+    static int16_t flow_percentage[EXTRUDERS];  // Extrusion factor for each extruder
 
     static float e_factor[EXTRUDERS],               // The flow percentage and volumetric multiplier combine to scale E movement
                  filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
                  volumetric_area_nominal,           // Nominal cross-sectional area
                  volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                     // May be auto-adjusted by a filament width sensor
 
     static float max_feedrate_mm_s[XYZE_N],     // Max speeds in mm per second
                  axis_steps_per_mm[XYZE_N],
                  steps_to_mm[XYZE_N];
@@ -345,32 +345,43 @@ class Planner {
       static void unapply_leveling(float raw[XYZ]);
 
     #else
 
       #define ARG_X const float &rx
       #define ARG_Y const float &ry
       #define ARG_Z const float &rz
 
     #endif
 
+    /**
+     * Planner::_buffer_steps
+     *
+     * Add a new linear movement to the buffer (in terms of steps).
+     *
+     *  target    - target position in steps units
+     *  fr_mm_s   - (target) speed of the move
+     *  extruder  - target extruder
+     */
+    static void _buffer_steps(const int32_t target[XYZE], float fr_mm_s, const uint8_t extruder);
+
     /**
      * Planner::_buffer_line
      *
      * Add a new linear movement to the buffer in axis units.
      *
      * Leveling and kinematics should be applied ahead of calling this.
      *
      *  a,b,c,e   - target positions in mm and/or degrees
      *  fr_mm_s   - (target) speed of the move
      *  extruder  - target extruder
      */
-    static void _buffer_line(const float &a, const float &b, const float &c, const float &e, float fr_mm_s, const uint8_t extruder);
+    static void _buffer_line(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder);
 
     static void _set_position_mm(const float &a, const float &b, const float &c, const float &e);
 
     /**
      * Add a new linear movement to the buffer.
      * The target is NOT translated to delta/scara
      *
      * Leveling will be applied to input on cartesians.
      * Kinematic machines should call buffer_line_kinematic (for leveled moves).
      * (Cartesians may also call buffer_line_kinematic.)

commit 805612019553ad105b34760fbadf15abcea47187
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 2 20:17:51 2017 -0600

    Rename inverse_mm_s => inverse_secs

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index d5634aa17b..84818bc5f9 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -445,20 +445,21 @@ class Planner {
      * Called when the current block is no longer needed.
      */
     static void discard_current_block() {
       if (blocks_queued())
         block_buffer_tail = BLOCK_MOD(block_buffer_tail + 1);
     }
 
     /**
      * The current block. NULL if the buffer is empty.
      * This also marks the block as busy.
+     * WARNING: Called from Stepper ISR context!
      */
     static block_t* get_current_block() {
       if (blocks_queued()) {
         block_t* block = &block_buffer[block_buffer_tail];
         #if ENABLED(ULTRA_LCD)
           block_buffer_runtime_us -= block->segment_time_us; // We can't be sure how long an active block will take, so don't count it.
         #endif
         SBI(block->flag, BLOCK_BIT_BUSY);
         return block;
       }
@@ -511,21 +512,21 @@ class Planner {
     /**
      * Calculate the distance (not time) it takes to accelerate
      * from initial_rate to target_rate using the given acceleration:
      */
     static float estimate_acceleration_distance(const float &initial_rate, const float &target_rate, const float &accel) {
       if (accel == 0) return 0; // accel was 0, set acceleration distance to 0
       return (sq(target_rate) - sq(initial_rate)) / (accel * 2);
     }
 
     /**
-     * Return the point at which you must start braking (at the rate of -'acceleration') if
+     * Return the point at which you must start braking (at the rate of -'accel') if
      * you start at 'initial_rate', accelerate (until reaching the point), and want to end at
      * 'final_rate' after traveling 'distance'.
      *
      * This is used to compute the intersection point between acceleration and deceleration
      * in cases where the "trapezoid" has no plateau (i.e., never reaches maximum speed)
      */
     static float intersection_distance(const float &initial_rate, const float &final_rate, const float &accel, const float &distance) {
       if (accel == 0) return 0; // accel was 0, set intersection distance to 0
       return (accel * 2 * distance - sq(initial_rate) + sq(final_rate)) / (accel * 4);
     }

commit 000b3b3117c500f51be05cdb136ce56617edd69a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 1 21:43:44 2017 -0600

    Comment/cleanup of motion code

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 070e75c012..d5634aa17b 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -498,22 +498,22 @@ class Planner {
       static bool autotemp_enabled;
       static void getHighESpeed();
       static void autotemp_M104_M109();
     #endif
 
   private:
 
     /**
      * Get the index of the next / previous block in the ring buffer
      */
-    static int8_t next_block_index(int8_t block_index) { return BLOCK_MOD(block_index + 1); }
-    static int8_t prev_block_index(int8_t block_index) { return BLOCK_MOD(block_index - 1); }
+    static int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
+    static int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
 
     /**
      * Calculate the distance (not time) it takes to accelerate
      * from initial_rate to target_rate using the given acceleration:
      */
     static float estimate_acceleration_distance(const float &initial_rate, const float &target_rate, const float &accel) {
       if (accel == 0) return 0; // accel was 0, set acceleration distance to 0
       return (sq(target_rate) - sq(initial_rate)) / (accel * 2);
     }
 

commit 0154e3480c44bf9d96d662382da25afaaf3fd854
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 1 16:42:23 2017 -0600

    New feature: BED_SKEW_CORRECTION

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index b89655d3c5..070e75c012 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -173,20 +173,37 @@ class Planner {
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         static float z_fade_height, inverse_z_fade_height;
       #endif
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       static float extruder_advance_k, advance_ed_ratio;
     #endif
 
+    #if ENABLED(SKEW_CORRECTION)
+      #if ENABLED(SKEW_CORRECTION_GCODE)
+        static float xy_skew_factor;
+      #else
+        static constexpr float xy_skew_factor = XY_SKEW_FACTOR;
+      #endif
+      #if ENABLED(SKEW_CORRECTION_FOR_Z)
+        #if ENABLED(SKEW_CORRECTION_GCODE)
+          static float xz_skew_factor, yz_skew_factor;
+        #else
+          static constexpr float xz_skew_factor = XZ_SKEW_FACTOR, yz_skew_factor = YZ_SKEW_FACTOR;
+        #endif
+      #else
+        static constexpr float xz_skew_factor = 0, yz_skew_factor = 0;
+      #endif
+    #endif
+
   private:
 
     /**
      * The current position of the tool in absolute steps
      * Recalculated if any axis_steps_per_mm are changed by gcode
      */
     static int32_t position[NUM_AXIS];
 
     /**
      * Speed of previous path line segment

commit dd3ce408261cb44fa698ea648d6d258bc9f49f40
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 30 16:38:35 2017 -0600

    Drop Planner::position_float, use int types

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index db9d8efc52..b89655d3c5 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -179,21 +179,21 @@ class Planner {
     #if ENABLED(LIN_ADVANCE)
       static float extruder_advance_k, advance_ed_ratio;
     #endif
 
   private:
 
     /**
      * The current position of the tool in absolute steps
      * Recalculated if any axis_steps_per_mm are changed by gcode
      */
-    static long position[NUM_AXIS];
+    static int32_t position[NUM_AXIS];
 
     /**
      * Speed of previous path line segment
      */
     static float previous_speed[NUM_AXIS];
 
     /**
      * Nominal speed of previous path line segment
      */
     static float previous_nominal_speed;
@@ -213,25 +213,21 @@ class Planner {
        */
       static uint8_t g_uc_extruder_last_move[EXTRUDERS];
     #endif // DISABLE_INACTIVE_EXTRUDER
 
     #ifdef XY_FREQUENCY_LIMIT
       // Used for the frequency limit
       #define MAX_FREQ_TIME_US (uint32_t)(1000000.0 / XY_FREQUENCY_LIMIT)
       // Old direction bits. Used for speed calculations
       static unsigned char old_direction_bits;
       // Segment times (in ¬µs). Used for speed calculations
-      static long axis_segment_time_us[2][3];
-    #endif
-
-    #if ENABLED(LIN_ADVANCE)
-      static float position_float[NUM_AXIS];
+      static uint32_t axis_segment_time_us[2][3];
     #endif
 
     #if ENABLED(ULTRA_LCD)
       volatile static uint32_t block_buffer_runtime_us; //Theoretical block buffer runtime in ¬µs
     #endif
 
   public:
 
     /**
      * Instance Methods

commit a52fec6ac49e47dc390ccb41990921970479d6da
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 30 15:55:08 2017 -0600

    Planner class parity with 1.1.x

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 1e70921283..db9d8efc52 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -137,21 +137,21 @@ class Planner {
      * A ring buffer of moves described in steps
      */
     static block_t block_buffer[BLOCK_BUFFER_SIZE];
     static volatile uint8_t block_buffer_head,  // Index of the next block to be pushed
                             block_buffer_tail;
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;             // Respond to extruder change
     #endif
 
-    static int16_t flow_percentage[EXTRUDERS];  // Extrusion factor for each extruder
+    static int16_t flow_percentage[EXTRUDERS]; // Extrusion factor for each extruder
 
     static float e_factor[EXTRUDERS],               // The flow percentage and volumetric multiplier combine to scale E movement
                  filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
                  volumetric_area_nominal,           // Nominal cross-sectional area
                  volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                     // May be auto-adjusted by a filament width sensor
 
     static float max_feedrate_mm_s[XYZE_N],     // Max speeds in mm per second
                  axis_steps_per_mm[XYZE_N],
                  steps_to_mm[XYZE_N];
@@ -160,21 +160,21 @@ class Planner {
 
     static uint32_t min_segment_time_us; // Use 'M205 B<¬µs>' to override
     static float min_feedrate_mm_s,
                  acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
                  retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
                  travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
                  max_jerk[XYZE],       // The largest speed change requiring no acceleration
                  min_travel_feedrate_mm_s;
 
     #if HAS_LEVELING
-      static bool leveling_active;              // Flag that bed leveling is enabled
+      static bool leveling_active;          // Flag that bed leveling is enabled
       #if ABL_PLANAR
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         static float z_fade_height, inverse_z_fade_height;
       #endif
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       static float extruder_advance_k, advance_ed_ratio;
@@ -335,26 +335,26 @@ class Planner {
 
       #define ARG_X const float &rx
       #define ARG_Y const float &ry
       #define ARG_Z const float &rz
 
     #endif
 
     /**
      * Planner::_buffer_line
      *
-     * Add a new direct linear movement to the buffer.
+     * Add a new linear movement to the buffer in axis units.
      *
-     * Leveling and kinematics should be applied ahead of this.
+     * Leveling and kinematics should be applied ahead of calling this.
      *
-     *  a,b,c,e   - target position in mm or degrees
-     *  fr_mm_s   - (target) speed of the move (mm/s)
+     *  a,b,c,e   - target positions in mm and/or degrees
+     *  fr_mm_s   - (target) speed of the move
      *  extruder  - target extruder
      */
     static void _buffer_line(const float &a, const float &b, const float &c, const float &e, float fr_mm_s, const uint8_t extruder);
 
     static void _set_position_mm(const float &a, const float &b, const float &c, const float &e);
 
     /**
      * Add a new linear movement to the buffer.
      * The target is NOT translated to delta/scara
      *
@@ -437,21 +437,21 @@ class Planner {
     }
 
     /**
      * The current block. NULL if the buffer is empty.
      * This also marks the block as busy.
      */
     static block_t* get_current_block() {
       if (blocks_queued()) {
         block_t* block = &block_buffer[block_buffer_tail];
         #if ENABLED(ULTRA_LCD)
-          block_buffer_runtime_us -= block->segment_time_us; //We can't be sure how long an active block will take, so don't count it.
+          block_buffer_runtime_us -= block->segment_time_us; // We can't be sure how long an active block will take, so don't count it.
         #endif
         SBI(block->flag, BLOCK_BIT_BUSY);
         return block;
       }
       else {
         #if ENABLED(ULTRA_LCD)
           clear_block_buffer_runtime(); // paranoia. Buffer is empty now - so reset accumulated time to zero.
         #endif
         return NULL;
       }

commit 60adc6ff0213c6989cd31b9e76e4ac6ab314cc66
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 18 07:01:49 2017 -0600

    Display filwidth ratio in terms of E mm

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 2a238ec3b9..1e70921283 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -141,20 +141,21 @@ class Planner {
                             block_buffer_tail;
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;             // Respond to extruder change
     #endif
 
     static int16_t flow_percentage[EXTRUDERS];  // Extrusion factor for each extruder
 
     static float e_factor[EXTRUDERS],               // The flow percentage and volumetric multiplier combine to scale E movement
                  filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
+                 volumetric_area_nominal,           // Nominal cross-sectional area
                  volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                     // May be auto-adjusted by a filament width sensor
 
     static float max_feedrate_mm_s[XYZE_N],     // Max speeds in mm per second
                  axis_steps_per_mm[XYZE_N],
                  steps_to_mm[XYZE_N];
     static uint32_t max_acceleration_steps_per_s2[XYZE_N],
                     max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override
 
     static uint32_t min_segment_time_us; // Use 'M205 B<¬µs>' to override

commit 1e8afb66b713252f17d1c3f29c0bc9908efe6fae
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 16 16:54:03 2017 -0600

    Fix a planner comment

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 1ebcf554c4..2a238ec3b9 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -370,21 +370,21 @@ class Planner {
         apply_leveling(rx, ry, rz);
       #endif
       _buffer_line(rx, ry, rz, e, fr_mm_s, extruder);
     }
 
     /**
      * Add a new linear movement to the buffer.
      * The target is cartesian, it's translated to delta/scara if
      * needed.
      *
-     *  rtarget  - x,y,z,e CARTESIAN target in mm
+     *  cart     - x,y,z,e CARTESIAN target in mm
      *  fr_mm_s  - (target) speed of the move (mm/s)
      *  extruder - target extruder
      */
     static FORCE_INLINE void buffer_line_kinematic(const float cart[XYZE], const float &fr_mm_s, const uint8_t extruder) {
       #if PLANNER_LEVELING
         float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
         apply_leveling(raw);
       #else
         const float * const raw = cart;
       #endif

commit cba9c1cf9e7831a86acbdc35fe405fb600e0f6e3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 10 02:26:49 2017 -0600

    Add pre-calculated planner.e_factor

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 99abdc4f6c..1ebcf554c4 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -139,21 +139,22 @@ class Planner {
     static block_t block_buffer[BLOCK_BUFFER_SIZE];
     static volatile uint8_t block_buffer_head,  // Index of the next block to be pushed
                             block_buffer_tail;
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;             // Respond to extruder change
     #endif
 
     static int16_t flow_percentage[EXTRUDERS];  // Extrusion factor for each extruder
 
-    static float filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
+    static float e_factor[EXTRUDERS],               // The flow percentage and volumetric multiplier combine to scale E movement
+                 filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
                  volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                     // May be auto-adjusted by a filament width sensor
 
     static float max_feedrate_mm_s[XYZE_N],     // Max speeds in mm per second
                  axis_steps_per_mm[XYZE_N],
                  steps_to_mm[XYZE_N];
     static uint32_t max_acceleration_steps_per_s2[XYZE_N],
                     max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override
 
     static uint32_t min_segment_time_us; // Use 'M205 B<¬µs>' to override
@@ -239,20 +240,24 @@ class Planner {
 
     void init();
 
     /**
      * Static (class) Methods
      */
 
     static void reset_acceleration_rates();
     static void refresh_positioning();
 
+    FORCE_INLINE static void refresh_e_factor(const uint8_t e) {
+      e_factor[e] = volumetric_multiplier[e] * flow_percentage[e] * 0.01;
+    }
+
     // Manage fans, paste pressure, etc.
     static void check_axes_activity();
 
     /**
      * Number of moves currently in the planner
      */
     static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail + BLOCK_BUFFER_SIZE); }
 
     static bool is_full() { return (block_buffer_tail == BLOCK_MOD(block_buffer_head + 1)); }
 

commit 0cfb936dd124d22a6079a5e85802ddc14f0b4328
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 8 22:13:33 2017 -0600

    Clarify some motion code

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index ff123bdd4d..99abdc4f6c 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -369,32 +369,32 @@ class Planner {
 
     /**
      * Add a new linear movement to the buffer.
      * The target is cartesian, it's translated to delta/scara if
      * needed.
      *
      *  rtarget  - x,y,z,e CARTESIAN target in mm
      *  fr_mm_s  - (target) speed of the move (mm/s)
      *  extruder - target extruder
      */
-    static FORCE_INLINE void buffer_line_kinematic(const float rtarget[XYZE], const float &fr_mm_s, const uint8_t extruder) {
+    static FORCE_INLINE void buffer_line_kinematic(const float cart[XYZE], const float &fr_mm_s, const uint8_t extruder) {
       #if PLANNER_LEVELING
-        float lpos[XYZ] = { rtarget[X_AXIS], rtarget[Y_AXIS], rtarget[Z_AXIS] };
-        apply_leveling(lpos);
+        float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
+        apply_leveling(raw);
       #else
-        const float * const lpos = rtarget;
+        const float * const raw = cart;
       #endif
       #if IS_KINEMATIC
-        inverse_kinematics(lpos);
-        _buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], rtarget[E_AXIS], fr_mm_s, extruder);
+        inverse_kinematics(raw);
+        _buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS], fr_mm_s, extruder);
       #else
-        _buffer_line(lpos[X_AXIS], lpos[Y_AXIS], lpos[Z_AXIS], rtarget[E_AXIS], fr_mm_s, extruder);
+        _buffer_line(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS], fr_mm_s, extruder);
       #endif
     }
 
     /**
      * Set the planner.position and individual stepper positions.
      * Used by G92, G28, G29, and other procedures.
      *
      * Multiplies by axis_steps_per_mm[] and does necessary conversion
      * for COREXY / COREXZ / COREYZ to set the corresponding stepper positions.
      *

commit f8393a09086f01eafbb8563411da3b237c96b982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 2 23:59:42 2017 -0500

    Operate in Native Machine Space

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index a78af02869..ff123bdd4d 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -195,21 +195,21 @@ class Planner {
      * Nominal speed of previous path line segment
      */
     static float previous_nominal_speed;
 
     /**
      * Limit where 64bit math is necessary for acceleration calculation
      */
     static uint32_t cutoff_long;
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      static float last_raw_lz;
+      static float last_fade_z;
     #endif
 
     #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
       /**
        * Counters to manage disabling inactive extruders
        */
       static uint8_t g_uc_extruder_last_move[EXTRUDERS];
     #endif // DISABLE_INACTIVE_EXTRUDER
 
     #ifdef XY_FREQUENCY_LIMIT
@@ -268,76 +268,75 @@ class Planner {
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
 
       /**
        * Get the Z leveling fade factor based on the given Z height,
        * re-calculating only when needed.
        *
        *  Returns 1.0 if planner.z_fade_height is 0.0.
        *  Returns 0.0 if Z is past the specified 'Fade Height'.
        */
-      inline static float fade_scaling_factor_for_z(const float &lz) {
+      inline static float fade_scaling_factor_for_z(const float &rz) {
         static float z_fade_factor = 1.0;
         if (z_fade_height) {
-          const float raw_lz = RAW_Z_POSITION(lz);
-          if (raw_lz >= z_fade_height) return 0.0;
-          if (last_raw_lz != raw_lz) {
-            last_raw_lz = raw_lz;
-            z_fade_factor = 1.0 - raw_lz * inverse_z_fade_height;
+          if (rz >= z_fade_height) return 0.0;
+          if (last_fade_z != rz) {
+            last_fade_z = rz;
+            z_fade_factor = 1.0 - rz * inverse_z_fade_height;
           }
           return z_fade_factor;
         }
         return 1.0;
       }
 
-      FORCE_INLINE static void force_fade_recalc() { last_raw_lz = -999.999; }
+      FORCE_INLINE static void force_fade_recalc() { last_fade_z = -999.999; }
 
       FORCE_INLINE static void set_z_fade_height(const float &zfh) {
         z_fade_height = zfh > 0 ? zfh : 0;
         inverse_z_fade_height = RECIPROCAL(z_fade_height);
         force_fade_recalc();
       }
 
-      FORCE_INLINE static bool leveling_active_at_z(const float &lz) {
-        return !z_fade_height || RAW_Z_POSITION(lz) < z_fade_height;
+      FORCE_INLINE static bool leveling_active_at_z(const float &rz) {
+        return !z_fade_height || rz < z_fade_height;
       }
 
     #else
 
-      FORCE_INLINE static float fade_scaling_factor_for_z(const float &lz) {
-        UNUSED(lz);
+      FORCE_INLINE static float fade_scaling_factor_for_z(const float &rz) {
+        UNUSED(rz);
         return 1.0;
       }
 
-      FORCE_INLINE static bool leveling_active_at_z(const float &lz) { UNUSED(lz); return true; }
+      FORCE_INLINE static bool leveling_active_at_z(const float &rz) { UNUSED(rz); return true; }
 
     #endif
 
     #if PLANNER_LEVELING
 
-      #define ARG_X float lx
-      #define ARG_Y float ly
-      #define ARG_Z float lz
+      #define ARG_X float rx
+      #define ARG_Y float ry
+      #define ARG_Z float rz
 
       /**
        * Apply leveling to transform a cartesian position
        * as it will be given to the planner and steppers.
        */
-      static void apply_leveling(float &lx, float &ly, float &lz);
-      static void apply_leveling(float logical[XYZ]) { apply_leveling(logical[X_AXIS], logical[Y_AXIS], logical[Z_AXIS]); }
-      static void unapply_leveling(float logical[XYZ]);
+      static void apply_leveling(float &rx, float &ry, float &rz);
+      static void apply_leveling(float raw[XYZ]) { apply_leveling(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]); }
+      static void unapply_leveling(float raw[XYZ]);
 
     #else
 
-      #define ARG_X const float &lx
-      #define ARG_Y const float &ly
-      #define ARG_Z const float &lz
+      #define ARG_X const float &rx
+      #define ARG_Y const float &ry
+      #define ARG_Z const float &rz
 
     #endif
 
     /**
      * Planner::_buffer_line
      *
      * Add a new direct linear movement to the buffer.
      *
      * Leveling and kinematics should be applied ahead of this.
      *
@@ -350,69 +349,69 @@ class Planner {
     static void _set_position_mm(const float &a, const float &b, const float &c, const float &e);
 
     /**
      * Add a new linear movement to the buffer.
      * The target is NOT translated to delta/scara
      *
      * Leveling will be applied to input on cartesians.
      * Kinematic machines should call buffer_line_kinematic (for leveled moves).
      * (Cartesians may also call buffer_line_kinematic.)
      *
-     *  lx,ly,lz,e   - target position in mm or degrees
+     *  rx,ry,rz,e   - target position in mm or degrees
      *  fr_mm_s      - (target) speed of the move (mm/s)
      *  extruder     - target extruder
      */
     static FORCE_INLINE void buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, const float &fr_mm_s, const uint8_t extruder) {
       #if PLANNER_LEVELING && IS_CARTESIAN
-        apply_leveling(lx, ly, lz);
+        apply_leveling(rx, ry, rz);
       #endif
-      _buffer_line(lx, ly, lz, e, fr_mm_s, extruder);
+      _buffer_line(rx, ry, rz, e, fr_mm_s, extruder);
     }
 
     /**
      * Add a new linear movement to the buffer.
      * The target is cartesian, it's translated to delta/scara if
      * needed.
      *
-     *  ltarget  - x,y,z,e CARTESIAN target in mm
+     *  rtarget  - x,y,z,e CARTESIAN target in mm
      *  fr_mm_s  - (target) speed of the move (mm/s)
      *  extruder - target extruder
      */
-    static FORCE_INLINE void buffer_line_kinematic(const float ltarget[XYZE], const float &fr_mm_s, const uint8_t extruder) {
+    static FORCE_INLINE void buffer_line_kinematic(const float rtarget[XYZE], const float &fr_mm_s, const uint8_t extruder) {
       #if PLANNER_LEVELING
-        float lpos[XYZ] = { ltarget[X_AXIS], ltarget[Y_AXIS], ltarget[Z_AXIS] };
+        float lpos[XYZ] = { rtarget[X_AXIS], rtarget[Y_AXIS], rtarget[Z_AXIS] };
         apply_leveling(lpos);
       #else
-        const float * const lpos = ltarget;
+        const float * const lpos = rtarget;
       #endif
       #if IS_KINEMATIC
         inverse_kinematics(lpos);
-        _buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], ltarget[E_AXIS], fr_mm_s, extruder);
+        _buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], rtarget[E_AXIS], fr_mm_s, extruder);
       #else
-        _buffer_line(lpos[X_AXIS], lpos[Y_AXIS], lpos[Z_AXIS], ltarget[E_AXIS], fr_mm_s, extruder);
+        _buffer_line(lpos[X_AXIS], lpos[Y_AXIS], lpos[Z_AXIS], rtarget[E_AXIS], fr_mm_s, extruder);
       #endif
     }
 
     /**
      * Set the planner.position and individual stepper positions.
      * Used by G92, G28, G29, and other procedures.
      *
      * Multiplies by axis_steps_per_mm[] and does necessary conversion
      * for COREXY / COREXZ / COREYZ to set the corresponding stepper positions.
      *
      * Clears previous speed values.
      */
     static FORCE_INLINE void set_position_mm(ARG_X, ARG_Y, ARG_Z, const float &e) {
       #if PLANNER_LEVELING && IS_CARTESIAN
-        apply_leveling(lx, ly, lz);
+        apply_leveling(rx, ry, rz);
       #endif
-      _set_position_mm(lx, ly, lz, e);
+      _set_position_mm(rx, ry, rz, e);
     }
     static void set_position_mm_kinematic(const float position[NUM_AXIS]);
     static void set_position_mm(const AxisEnum axis, const float &v);
     static FORCE_INLINE void set_z_position_mm(const float &z) { set_position_mm(Z_AXIS, z); }
     static FORCE_INLINE void set_e_position_mm(const float &e) { set_position_mm(AxisEnum(E_AXIS), e); }
 
     /**
      * Sync from the stepper positions. (e.g., after an interrupted move)
      */
     static void sync_from_steppers();

commit 3e8754a38a57f0b37e6880b1ddc6214890f6cf5e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 29 18:21:15 2017 -0500

    Add/correct time units on planner vars / M205 B

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 1e157bbdf2..a78af02869 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -116,21 +116,21 @@ typedef struct {
            acceleration_steps_per_s2;       // acceleration steps/sec^2
 
   #if FAN_COUNT > 0
     uint16_t fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
     uint8_t valve_pressure, e_to_p_pressure;
   #endif
 
-  uint32_t segment_time;
+  uint32_t segment_time_us;
 
 } block_t;
 
 #define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
 
 class Planner {
 
   public:
 
     /**
@@ -147,23 +147,23 @@ class Planner {
     static int16_t flow_percentage[EXTRUDERS];  // Extrusion factor for each extruder
 
     static float filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
                  volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
                                                     // May be auto-adjusted by a filament width sensor
 
     static float max_feedrate_mm_s[XYZE_N],     // Max speeds in mm per second
                  axis_steps_per_mm[XYZE_N],
                  steps_to_mm[XYZE_N];
     static uint32_t max_acceleration_steps_per_s2[XYZE_N],
-                    max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
+                    max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override
 
-    static millis_t min_segment_time;
+    static uint32_t min_segment_time_us; // Use 'M205 B<¬µs>' to override
     static float min_feedrate_mm_s,
                  acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
                  retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
                  travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
                  max_jerk[XYZE],       // The largest speed change requiring no acceleration
                  min_travel_feedrate_mm_s;
 
     #if HAS_LEVELING
       static bool leveling_active;              // Flag that bed leveling is enabled
       #if ABL_PLANAR
@@ -207,25 +207,25 @@ class Planner {
 
     #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
       /**
        * Counters to manage disabling inactive extruders
        */
       static uint8_t g_uc_extruder_last_move[EXTRUDERS];
     #endif // DISABLE_INACTIVE_EXTRUDER
 
     #ifdef XY_FREQUENCY_LIMIT
       // Used for the frequency limit
-      #define MAX_FREQ_TIME long(1000000.0/XY_FREQUENCY_LIMIT)
+      #define MAX_FREQ_TIME_US (uint32_t)(1000000.0 / XY_FREQUENCY_LIMIT)
       // Old direction bits. Used for speed calculations
       static unsigned char old_direction_bits;
       // Segment times (in ¬µs). Used for speed calculations
-      static long axis_segment_time[2][3];
+      static long axis_segment_time_us[2][3];
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       static float position_float[NUM_AXIS];
     #endif
 
     #if ENABLED(ULTRA_LCD)
       volatile static uint32_t block_buffer_runtime_us; //Theoretical block buffer runtime in ¬µs
     #endif
 
@@ -432,21 +432,21 @@ class Planner {
     }
 
     /**
      * The current block. NULL if the buffer is empty.
      * This also marks the block as busy.
      */
     static block_t* get_current_block() {
       if (blocks_queued()) {
         block_t* block = &block_buffer[block_buffer_tail];
         #if ENABLED(ULTRA_LCD)
-          block_buffer_runtime_us -= block->segment_time; //We can't be sure how long an active block will take, so don't count it.
+          block_buffer_runtime_us -= block->segment_time_us; //We can't be sure how long an active block will take, so don't count it.
         #endif
         SBI(block->flag, BLOCK_BIT_BUSY);
         return block;
       }
       else {
         #if ENABLED(ULTRA_LCD)
           clear_block_buffer_runtime(); // paranoia. Buffer is empty now - so reset accumulated time to zero.
         #endif
         return NULL;
       }

commit 0ceec1f1669c6b678d8df7095a8170e5bfd312d3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 26 22:19:23 2017 -0500

    Fix leveling_active_at_z warning

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 36f4e4e9a0..1e157bbdf2 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -301,21 +301,21 @@ class Planner {
         return !z_fade_height || RAW_Z_POSITION(lz) < z_fade_height;
       }
 
     #else
 
       FORCE_INLINE static float fade_scaling_factor_for_z(const float &lz) {
         UNUSED(lz);
         return 1.0;
       }
 
-      FORCE_INLINE static bool leveling_active_at_z(const float &lz) { return true; }
+      FORCE_INLINE static bool leveling_active_at_z(const float &lz) { UNUSED(lz); return true; }
 
     #endif
 
     #if PLANNER_LEVELING
 
       #define ARG_X float lx
       #define ARG_Y float ly
       #define ARG_Z float lz
 
       /**

commit 3e3911fb81cef6f17f7e77c54f520e2a4579225b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 17:21:25 2017 -0500

    Use planner.leveling_active for all leveling systems

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 38ae94d188..36f4e4e9a0 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -157,29 +157,28 @@ class Planner {
                     max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
 
     static millis_t min_segment_time;
     static float min_feedrate_mm_s,
                  acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
                  retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
                  travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
                  max_jerk[XYZE],       // The largest speed change requiring no acceleration
                  min_travel_feedrate_mm_s;
 
-    #if OLDSCHOOL_ABL
-      static bool abl_enabled;              // Flag that bed leveling is enabled
+    #if HAS_LEVELING
+      static bool leveling_active;              // Flag that bed leveling is enabled
       #if ABL_PLANAR
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
-    #endif
-
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      static float z_fade_height, inverse_z_fade_height;
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        static float z_fade_height, inverse_z_fade_height;
+      #endif
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       static float extruder_advance_k, advance_ed_ratio;
     #endif
 
   private:
 
     /**
      * The current position of the tool in absolute steps
@@ -285,27 +284,39 @@ class Planner {
             last_raw_lz = raw_lz;
             z_fade_factor = 1.0 - raw_lz * inverse_z_fade_height;
           }
           return z_fade_factor;
         }
         return 1.0;
       }
 
       FORCE_INLINE static void force_fade_recalc() { last_raw_lz = -999.999; }
 
+      FORCE_INLINE static void set_z_fade_height(const float &zfh) {
+        z_fade_height = zfh > 0 ? zfh : 0;
+        inverse_z_fade_height = RECIPROCAL(z_fade_height);
+        force_fade_recalc();
+      }
+
+      FORCE_INLINE static bool leveling_active_at_z(const float &lz) {
+        return !z_fade_height || RAW_Z_POSITION(lz) < z_fade_height;
+      }
+
     #else
 
       FORCE_INLINE static float fade_scaling_factor_for_z(const float &lz) {
         UNUSED(lz);
         return 1.0;
       }
 
+      FORCE_INLINE static bool leveling_active_at_z(const float &lz) { return true; }
+
     #endif
 
     #if PLANNER_LEVELING
 
       #define ARG_X float lx
       #define ARG_Y float ly
       #define ARG_Z float lz
 
       /**
        * Apply leveling to transform a cartesian position

commit 32c607ffe21f0532b51d40147389eba4a4d44079
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 11:07:09 2017 -0500

    Ensure fade factor is recalculated if fade height changes

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 3d7ec53e00..38ae94d188 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -195,20 +195,24 @@ class Planner {
     /**
      * Nominal speed of previous path line segment
      */
     static float previous_nominal_speed;
 
     /**
      * Limit where 64bit math is necessary for acceleration calculation
      */
     static uint32_t cutoff_long;
 
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      static float last_raw_lz;
+    #endif
+
     #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
       /**
        * Counters to manage disabling inactive extruders
        */
       static uint8_t g_uc_extruder_last_move[EXTRUDERS];
     #endif // DISABLE_INACTIVE_EXTRUDER
 
     #ifdef XY_FREQUENCY_LIMIT
       // Used for the frequency limit
       #define MAX_FREQ_TIME long(1000000.0/XY_FREQUENCY_LIMIT)
@@ -266,33 +270,35 @@ class Planner {
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
 
       /**
        * Get the Z leveling fade factor based on the given Z height,
        * re-calculating only when needed.
        *
        *  Returns 1.0 if planner.z_fade_height is 0.0.
        *  Returns 0.0 if Z is past the specified 'Fade Height'.
        */
       inline static float fade_scaling_factor_for_z(const float &lz) {
-        static float z_fade_factor = 1.0, last_raw_lz = -999.0;
+        static float z_fade_factor = 1.0;
         if (z_fade_height) {
           const float raw_lz = RAW_Z_POSITION(lz);
           if (raw_lz >= z_fade_height) return 0.0;
           if (last_raw_lz != raw_lz) {
             last_raw_lz = raw_lz;
             z_fade_factor = 1.0 - raw_lz * inverse_z_fade_height;
           }
           return z_fade_factor;
         }
         return 1.0;
       }
 
+      FORCE_INLINE static void force_fade_recalc() { last_raw_lz = -999.999; }
+
     #else
 
       FORCE_INLINE static float fade_scaling_factor_for_z(const float &lz) {
         UNUSED(lz);
         return 1.0;
       }
 
     #endif
 
     #if PLANNER_LEVELING

commit ca1e47375c71e6ddd4973a63a7a8cbf125a439bd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 10:39:11 2017 -0500

    Move fade_scaling_factor_for_z to Planner

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 85f35f35b8..3d7ec53e00 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -256,20 +256,52 @@ class Planner {
     // Update multipliers based on new diameter measurements
     static void calculate_volumetric_multipliers();
 
     FORCE_INLINE static void set_filament_size(const uint8_t e, const float &v) {
       filament_size[e] = v;
       // make sure all extruders have some sane value for the filament size
       for (uint8_t i = 0; i < COUNT(filament_size); i++)
         if (!filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;
     }
 
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+
+      /**
+       * Get the Z leveling fade factor based on the given Z height,
+       * re-calculating only when needed.
+       *
+       *  Returns 1.0 if planner.z_fade_height is 0.0.
+       *  Returns 0.0 if Z is past the specified 'Fade Height'.
+       */
+      inline static float fade_scaling_factor_for_z(const float &lz) {
+        static float z_fade_factor = 1.0, last_raw_lz = -999.0;
+        if (z_fade_height) {
+          const float raw_lz = RAW_Z_POSITION(lz);
+          if (raw_lz >= z_fade_height) return 0.0;
+          if (last_raw_lz != raw_lz) {
+            last_raw_lz = raw_lz;
+            z_fade_factor = 1.0 - raw_lz * inverse_z_fade_height;
+          }
+          return z_fade_factor;
+        }
+        return 1.0;
+      }
+
+    #else
+
+      FORCE_INLINE static float fade_scaling_factor_for_z(const float &lz) {
+        UNUSED(lz);
+        return 1.0;
+      }
+
+    #endif
+
     #if PLANNER_LEVELING
 
       #define ARG_X float lx
       #define ARG_Y float ly
       #define ARG_Z float lz
 
       /**
        * Apply leveling to transform a cartesian position
        * as it will be given to the planner and steppers.
        */

commit 03f4891fb98c032509643b6fbc8b6d24df6630b6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 9 04:25:18 2017 -0500

    Remove legacy ADVANCE feature

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index def50dbb8e..85f35f35b8 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -93,25 +93,20 @@ typedef struct {
   int32_t accelerate_until,                 // The index of the step event on which to stop acceleration
           decelerate_after,                 // The index of the step event on which to start decelerating
           acceleration_rate;                // The acceleration rate used for acceleration calculation
 
   uint8_t direction_bits;                   // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
 
   // Advance extrusion
   #if ENABLED(LIN_ADVANCE)
     bool use_advance_lead;
     uint32_t abs_adv_steps_multiplier8; // Factorised by 2^8 to avoid float
-  #elif ENABLED(ADVANCE)
-    int32_t advance_rate;
-    volatile int32_t initial_advance;
-    volatile int32_t final_advance;
-    float advance;
   #endif
 
   // Fields used by the motion planner to manage acceleration
   float nominal_speed,                      // The nominal speed for this block in mm/sec
         entry_speed,                        // Entry speed at previous-current junction in mm/sec
         max_entry_speed,                    // Maximum allowable junction entry speed in mm/sec
         millimeters,                        // The total travel of this block in mm
         acceleration;                       // acceleration mm/sec^2
 
   // Settings for the trapezoid generator

commit a10451ceed61e16a62d5395c27ad4ebe8ed06029
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 05:51:45 2017 -0500

    Move Volumetric methods to Planner

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 5cd886431a..def50dbb8e 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -144,20 +144,24 @@ class Planner {
     static block_t block_buffer[BLOCK_BUFFER_SIZE];
     static volatile uint8_t block_buffer_head,  // Index of the next block to be pushed
                             block_buffer_tail;
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;             // Respond to extruder change
     #endif
 
     static int16_t flow_percentage[EXTRUDERS];  // Extrusion factor for each extruder
 
+    static float filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
+                 volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
+                                                    // May be auto-adjusted by a filament width sensor
+
     static float max_feedrate_mm_s[XYZE_N],     // Max speeds in mm per second
                  axis_steps_per_mm[XYZE_N],
                  steps_to_mm[XYZE_N];
     static uint32_t max_acceleration_steps_per_s2[XYZE_N],
                     max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
 
     static millis_t min_segment_time;
     static float min_feedrate_mm_s,
                  acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
                  retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
@@ -247,20 +251,30 @@ class Planner {
     // Manage fans, paste pressure, etc.
     static void check_axes_activity();
 
     /**
      * Number of moves currently in the planner
      */
     static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail + BLOCK_BUFFER_SIZE); }
 
     static bool is_full() { return (block_buffer_tail == BLOCK_MOD(block_buffer_head + 1)); }
 
+    // Update multipliers based on new diameter measurements
+    static void calculate_volumetric_multipliers();
+
+    FORCE_INLINE static void set_filament_size(const uint8_t e, const float &v) {
+      filament_size[e] = v;
+      // make sure all extruders have some sane value for the filament size
+      for (uint8_t i = 0; i < COUNT(filament_size); i++)
+        if (!filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;
+    }
+
     #if PLANNER_LEVELING
 
       #define ARG_X float lx
       #define ARG_Y float ly
       #define ARG_Z float lz
 
       /**
        * Apply leveling to transform a cartesian position
        * as it will be given to the planner and steppers.
        */

commit 551752eac73a6f60de45b6465e2f224b2b2dca24
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 15:35:25 2017 -0500

    Consolidate "bedlevel" code

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 3ac5784e1c..5cd886431a 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -27,20 +27,26 @@
  *
  * Derived from Grbl
  * Copyright (c) 2009-2011 Simen Svale Skogsrud
  */
 
 #ifndef PLANNER_H
 #define PLANNER_H
 
 #include "../Marlin.h"
 
+#include "motion.h"
+
+#if ENABLED(DELTA)
+  #include "delta.h"
+#endif
+
 #if HAS_ABL
   #include "../libs/vector_3.h"
 #endif
 
 enum BlockFlagBit {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
@@ -152,21 +158,21 @@ class Planner {
                     max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
 
     static millis_t min_segment_time;
     static float min_feedrate_mm_s,
                  acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
                  retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
                  travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
                  max_jerk[XYZE],       // The largest speed change requiring no acceleration
                  min_travel_feedrate_mm_s;
 
-    #if HAS_ABL
+    #if OLDSCHOOL_ABL
       static bool abl_enabled;              // Flag that bed leveling is enabled
       #if ABL_PLANAR
         static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
       #endif
     #endif
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       static float z_fade_height, inverse_z_fade_height;
     #endif
 

commit bf7af95db361d57e844894278fcb0a5d5ea4eba5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 23:50:46 2017 -0500

    Move flow_percentage to Planner

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index bd6a86da40..3ac5784e1c 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -136,20 +136,22 @@ class Planner {
      * A ring buffer of moves described in steps
      */
     static block_t block_buffer[BLOCK_BUFFER_SIZE];
     static volatile uint8_t block_buffer_head,  // Index of the next block to be pushed
                             block_buffer_tail;
 
     #if ENABLED(DISTINCT_E_FACTORS)
       static uint8_t last_extruder;             // Respond to extruder change
     #endif
 
+    static int16_t flow_percentage[EXTRUDERS];  // Extrusion factor for each extruder
+
     static float max_feedrate_mm_s[XYZE_N],     // Max speeds in mm per second
                  axis_steps_per_mm[XYZE_N],
                  steps_to_mm[XYZE_N];
     static uint32_t max_acceleration_steps_per_s2[XYZE_N],
                     max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
 
     static millis_t min_segment_time;
     static float min_feedrate_mm_s,
                  acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
                  retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX

commit 3d8a0ab4b215a3869a0388e5c0ef35a6372ed7d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:32 2017 -0500

    Module updates

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
index 9abcf10b23..bd6a86da40 100644
--- a/Marlin/src/module/planner.h
+++ b/Marlin/src/module/planner.h
@@ -25,26 +25,24 @@
  *
  * Buffer movement commands and manage the acceleration profile plan
  *
  * Derived from Grbl
  * Copyright (c) 2009-2011 Simen Svale Skogsrud
  */
 
 #ifndef PLANNER_H
 #define PLANNER_H
 
-#include "types.h"
-#include "enum.h"
-#include "Marlin.h"
+#include "../Marlin.h"
 
 #if HAS_ABL
-  #include "vector_3.h"
+  #include "../libs/vector_3.h"
 #endif
 
 enum BlockFlagBit {
   // Recalculate trapezoids on entry junction. For optimization.
   BLOCK_BIT_RECALCULATE,
 
   // Nominal speed always reached.
   // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
   // from a safe speed (in consideration of jerking from zero speed).
   BLOCK_BIT_NOMINAL_LENGTH,

commit 0c9231fd04798c30830513a0cad8b204a6b9633f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:30 2017 -0500

    Move 'module' files

diff --git a/Marlin/src/module/planner.h b/Marlin/src/module/planner.h
new file mode 100644
index 0000000000..9abcf10b23
--- /dev/null
+++ b/Marlin/src/module/planner.h
@@ -0,0 +1,478 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * planner.h
+ *
+ * Buffer movement commands and manage the acceleration profile plan
+ *
+ * Derived from Grbl
+ * Copyright (c) 2009-2011 Simen Svale Skogsrud
+ */
+
+#ifndef PLANNER_H
+#define PLANNER_H
+
+#include "types.h"
+#include "enum.h"
+#include "Marlin.h"
+
+#if HAS_ABL
+  #include "vector_3.h"
+#endif
+
+enum BlockFlagBit {
+  // Recalculate trapezoids on entry junction. For optimization.
+  BLOCK_BIT_RECALCULATE,
+
+  // Nominal speed always reached.
+  // i.e., The segment is long enough, so the nominal speed is reachable if accelerating
+  // from a safe speed (in consideration of jerking from zero speed).
+  BLOCK_BIT_NOMINAL_LENGTH,
+
+  // Start from a halt at the start of this block, respecting the maximum allowed jerk.
+  BLOCK_BIT_START_FROM_FULL_HALT,
+
+  // The block is busy
+  BLOCK_BIT_BUSY
+};
+
+enum BlockFlag {
+  BLOCK_FLAG_RECALCULATE          = _BV(BLOCK_BIT_RECALCULATE),
+  BLOCK_FLAG_NOMINAL_LENGTH       = _BV(BLOCK_BIT_NOMINAL_LENGTH),
+  BLOCK_FLAG_START_FROM_FULL_HALT = _BV(BLOCK_BIT_START_FROM_FULL_HALT),
+  BLOCK_FLAG_BUSY                 = _BV(BLOCK_BIT_BUSY)
+};
+
+/**
+ * struct block_t
+ *
+ * A single entry in the planner buffer.
+ * Tracks linear movement over multiple axes.
+ *
+ * The "nominal" values are as-specified by gcode, and
+ * may never actually be reached due to acceleration limits.
+ */
+typedef struct {
+
+  uint8_t flag;                             // Block flags (See BlockFlag enum above)
+
+  unsigned char active_extruder;            // The extruder to move (if E move)
+
+  // Fields used by the Bresenham algorithm for tracing the line
+  int32_t steps[NUM_AXIS];                  // Step count along each axis
+  uint32_t step_event_count;                // The number of step events required to complete this block
+
+  #if ENABLED(MIXING_EXTRUDER)
+    uint32_t mix_event_count[MIXING_STEPPERS]; // Scaled step_event_count for the mixing steppers
+  #endif
+
+  int32_t accelerate_until,                 // The index of the step event on which to stop acceleration
+          decelerate_after,                 // The index of the step event on which to start decelerating
+          acceleration_rate;                // The acceleration rate used for acceleration calculation
+
+  uint8_t direction_bits;                   // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)
+
+  // Advance extrusion
+  #if ENABLED(LIN_ADVANCE)
+    bool use_advance_lead;
+    uint32_t abs_adv_steps_multiplier8; // Factorised by 2^8 to avoid float
+  #elif ENABLED(ADVANCE)
+    int32_t advance_rate;
+    volatile int32_t initial_advance;
+    volatile int32_t final_advance;
+    float advance;
+  #endif
+
+  // Fields used by the motion planner to manage acceleration
+  float nominal_speed,                      // The nominal speed for this block in mm/sec
+        entry_speed,                        // Entry speed at previous-current junction in mm/sec
+        max_entry_speed,                    // Maximum allowable junction entry speed in mm/sec
+        millimeters,                        // The total travel of this block in mm
+        acceleration;                       // acceleration mm/sec^2
+
+  // Settings for the trapezoid generator
+  uint32_t nominal_rate,                    // The nominal step rate for this block in step_events/sec
+           initial_rate,                    // The jerk-adjusted step rate at start of block
+           final_rate,                      // The minimal rate at exit
+           acceleration_steps_per_s2;       // acceleration steps/sec^2
+
+  #if FAN_COUNT > 0
+    uint16_t fan_speed[FAN_COUNT];
+  #endif
+
+  #if ENABLED(BARICUDA)
+    uint8_t valve_pressure, e_to_p_pressure;
+  #endif
+
+  uint32_t segment_time;
+
+} block_t;
+
+#define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))
+
+class Planner {
+
+  public:
+
+    /**
+     * A ring buffer of moves described in steps
+     */
+    static block_t block_buffer[BLOCK_BUFFER_SIZE];
+    static volatile uint8_t block_buffer_head,  // Index of the next block to be pushed
+                            block_buffer_tail;
+
+    #if ENABLED(DISTINCT_E_FACTORS)
+      static uint8_t last_extruder;             // Respond to extruder change
+    #endif
+
+    static float max_feedrate_mm_s[XYZE_N],     // Max speeds in mm per second
+                 axis_steps_per_mm[XYZE_N],
+                 steps_to_mm[XYZE_N];
+    static uint32_t max_acceleration_steps_per_s2[XYZE_N],
+                    max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
+
+    static millis_t min_segment_time;
+    static float min_feedrate_mm_s,
+                 acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
+                 retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
+                 travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
+                 max_jerk[XYZE],       // The largest speed change requiring no acceleration
+                 min_travel_feedrate_mm_s;
+
+    #if HAS_ABL
+      static bool abl_enabled;              // Flag that bed leveling is enabled
+      #if ABL_PLANAR
+        static matrix_3x3 bed_level_matrix; // Transform to compensate for bed level
+      #endif
+    #endif
+
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      static float z_fade_height, inverse_z_fade_height;
+    #endif
+
+    #if ENABLED(LIN_ADVANCE)
+      static float extruder_advance_k, advance_ed_ratio;
+    #endif
+
+  private:
+
+    /**
+     * The current position of the tool in absolute steps
+     * Recalculated if any axis_steps_per_mm are changed by gcode
+     */
+    static long position[NUM_AXIS];
+
+    /**
+     * Speed of previous path line segment
+     */
+    static float previous_speed[NUM_AXIS];
+
+    /**
+     * Nominal speed of previous path line segment
+     */
+    static float previous_nominal_speed;
+
+    /**
+     * Limit where 64bit math is necessary for acceleration calculation
+     */
+    static uint32_t cutoff_long;
+
+    #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
+      /**
+       * Counters to manage disabling inactive extruders
+       */
+      static uint8_t g_uc_extruder_last_move[EXTRUDERS];
+    #endif // DISABLE_INACTIVE_EXTRUDER
+
+    #ifdef XY_FREQUENCY_LIMIT
+      // Used for the frequency limit
+      #define MAX_FREQ_TIME long(1000000.0/XY_FREQUENCY_LIMIT)
+      // Old direction bits. Used for speed calculations
+      static unsigned char old_direction_bits;
+      // Segment times (in ¬µs). Used for speed calculations
+      static long axis_segment_time[2][3];
+    #endif
+
+    #if ENABLED(LIN_ADVANCE)
+      static float position_float[NUM_AXIS];
+    #endif
+
+    #if ENABLED(ULTRA_LCD)
+      volatile static uint32_t block_buffer_runtime_us; //Theoretical block buffer runtime in ¬µs
+    #endif
+
+  public:
+
+    /**
+     * Instance Methods
+     */
+
+    Planner();
+
+    void init();
+
+    /**
+     * Static (class) Methods
+     */
+
+    static void reset_acceleration_rates();
+    static void refresh_positioning();
+
+    // Manage fans, paste pressure, etc.
+    static void check_axes_activity();
+
+    /**
+     * Number of moves currently in the planner
+     */
+    static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail + BLOCK_BUFFER_SIZE); }
+
+    static bool is_full() { return (block_buffer_tail == BLOCK_MOD(block_buffer_head + 1)); }
+
+    #if PLANNER_LEVELING
+
+      #define ARG_X float lx
+      #define ARG_Y float ly
+      #define ARG_Z float lz
+
+      /**
+       * Apply leveling to transform a cartesian position
+       * as it will be given to the planner and steppers.
+       */
+      static void apply_leveling(float &lx, float &ly, float &lz);
+      static void apply_leveling(float logical[XYZ]) { apply_leveling(logical[X_AXIS], logical[Y_AXIS], logical[Z_AXIS]); }
+      static void unapply_leveling(float logical[XYZ]);
+
+    #else
+
+      #define ARG_X const float &lx
+      #define ARG_Y const float &ly
+      #define ARG_Z const float &lz
+
+    #endif
+
+    /**
+     * Planner::_buffer_line
+     *
+     * Add a new direct linear movement to the buffer.
+     *
+     * Leveling and kinematics should be applied ahead of this.
+     *
+     *  a,b,c,e   - target position in mm or degrees
+     *  fr_mm_s   - (target) speed of the move (mm/s)
+     *  extruder  - target extruder
+     */
+    static void _buffer_line(const float &a, const float &b, const float &c, const float &e, float fr_mm_s, const uint8_t extruder);
+
+    static void _set_position_mm(const float &a, const float &b, const float &c, const float &e);
+
+    /**
+     * Add a new linear movement to the buffer.
+     * The target is NOT translated to delta/scara
+     *
+     * Leveling will be applied to input on cartesians.
+     * Kinematic machines should call buffer_line_kinematic (for leveled moves).
+     * (Cartesians may also call buffer_line_kinematic.)
+     *
+     *  lx,ly,lz,e   - target position in mm or degrees
+     *  fr_mm_s      - (target) speed of the move (mm/s)
+     *  extruder     - target extruder
+     */
+    static FORCE_INLINE void buffer_line(ARG_X, ARG_Y, ARG_Z, const float &e, const float &fr_mm_s, const uint8_t extruder) {
+      #if PLANNER_LEVELING && IS_CARTESIAN
+        apply_leveling(lx, ly, lz);
+      #endif
+      _buffer_line(lx, ly, lz, e, fr_mm_s, extruder);
+    }
+
+    /**
+     * Add a new linear movement to the buffer.
+     * The target is cartesian, it's translated to delta/scara if
+     * needed.
+     *
+     *  ltarget  - x,y,z,e CARTESIAN target in mm
+     *  fr_mm_s  - (target) speed of the move (mm/s)
+     *  extruder - target extruder
+     */
+    static FORCE_INLINE void buffer_line_kinematic(const float ltarget[XYZE], const float &fr_mm_s, const uint8_t extruder) {
+      #if PLANNER_LEVELING
+        float lpos[XYZ] = { ltarget[X_AXIS], ltarget[Y_AXIS], ltarget[Z_AXIS] };
+        apply_leveling(lpos);
+      #else
+        const float * const lpos = ltarget;
+      #endif
+      #if IS_KINEMATIC
+        inverse_kinematics(lpos);
+        _buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], ltarget[E_AXIS], fr_mm_s, extruder);
+      #else
+        _buffer_line(lpos[X_AXIS], lpos[Y_AXIS], lpos[Z_AXIS], ltarget[E_AXIS], fr_mm_s, extruder);
+      #endif
+    }
+
+    /**
+     * Set the planner.position and individual stepper positions.
+     * Used by G92, G28, G29, and other procedures.
+     *
+     * Multiplies by axis_steps_per_mm[] and does necessary conversion
+     * for COREXY / COREXZ / COREYZ to set the corresponding stepper positions.
+     *
+     * Clears previous speed values.
+     */
+    static FORCE_INLINE void set_position_mm(ARG_X, ARG_Y, ARG_Z, const float &e) {
+      #if PLANNER_LEVELING && IS_CARTESIAN
+        apply_leveling(lx, ly, lz);
+      #endif
+      _set_position_mm(lx, ly, lz, e);
+    }
+    static void set_position_mm_kinematic(const float position[NUM_AXIS]);
+    static void set_position_mm(const AxisEnum axis, const float &v);
+    static FORCE_INLINE void set_z_position_mm(const float &z) { set_position_mm(Z_AXIS, z); }
+    static FORCE_INLINE void set_e_position_mm(const float &e) { set_position_mm(AxisEnum(E_AXIS), e); }
+
+    /**
+     * Sync from the stepper positions. (e.g., after an interrupted move)
+     */
+    static void sync_from_steppers();
+
+    /**
+     * Does the buffer have any blocks queued?
+     */
+    static bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
+
+    /**
+     * "Discards" the block and "releases" the memory.
+     * Called when the current block is no longer needed.
+     */
+    static void discard_current_block() {
+      if (blocks_queued())
+        block_buffer_tail = BLOCK_MOD(block_buffer_tail + 1);
+    }
+
+    /**
+     * The current block. NULL if the buffer is empty.
+     * This also marks the block as busy.
+     */
+    static block_t* get_current_block() {
+      if (blocks_queued()) {
+        block_t* block = &block_buffer[block_buffer_tail];
+        #if ENABLED(ULTRA_LCD)
+          block_buffer_runtime_us -= block->segment_time; //We can't be sure how long an active block will take, so don't count it.
+        #endif
+        SBI(block->flag, BLOCK_BIT_BUSY);
+        return block;
+      }
+      else {
+        #if ENABLED(ULTRA_LCD)
+          clear_block_buffer_runtime(); // paranoia. Buffer is empty now - so reset accumulated time to zero.
+        #endif
+        return NULL;
+      }
+    }
+
+    #if ENABLED(ULTRA_LCD)
+
+      static uint16_t block_buffer_runtime() {
+        CRITICAL_SECTION_START
+          millis_t bbru = block_buffer_runtime_us;
+        CRITICAL_SECTION_END
+        // To translate ¬µs to ms a division by 1000 would be required.
+        // We introduce 2.4% error here by dividing by 1024.
+        // Doesn't matter because block_buffer_runtime_us is already too small an estimation.
+        bbru >>= 10;
+        // limit to about a minute.
+        NOMORE(bbru, 0xFFFFul);
+        return bbru;
+      }
+
+      static void clear_block_buffer_runtime(){
+        CRITICAL_SECTION_START
+          block_buffer_runtime_us = 0;
+        CRITICAL_SECTION_END
+      }
+
+    #endif
+
+    #if ENABLED(AUTOTEMP)
+      static float autotemp_min, autotemp_max, autotemp_factor;
+      static bool autotemp_enabled;
+      static void getHighESpeed();
+      static void autotemp_M104_M109();
+    #endif
+
+  private:
+
+    /**
+     * Get the index of the next / previous block in the ring buffer
+     */
+    static int8_t next_block_index(int8_t block_index) { return BLOCK_MOD(block_index + 1); }
+    static int8_t prev_block_index(int8_t block_index) { return BLOCK_MOD(block_index - 1); }
+
+    /**
+     * Calculate the distance (not time) it takes to accelerate
+     * from initial_rate to target_rate using the given acceleration:
+     */
+    static float estimate_acceleration_distance(const float &initial_rate, const float &target_rate, const float &accel) {
+      if (accel == 0) return 0; // accel was 0, set acceleration distance to 0
+      return (sq(target_rate) - sq(initial_rate)) / (accel * 2);
+    }
+
+    /**
+     * Return the point at which you must start braking (at the rate of -'acceleration') if
+     * you start at 'initial_rate', accelerate (until reaching the point), and want to end at
+     * 'final_rate' after traveling 'distance'.
+     *
+     * This is used to compute the intersection point between acceleration and deceleration
+     * in cases where the "trapezoid" has no plateau (i.e., never reaches maximum speed)
+     */
+    static float intersection_distance(const float &initial_rate, const float &final_rate, const float &accel, const float &distance) {
+      if (accel == 0) return 0; // accel was 0, set intersection distance to 0
+      return (accel * 2 * distance - sq(initial_rate) + sq(final_rate)) / (accel * 4);
+    }
+
+    /**
+     * Calculate the maximum allowable speed at this point, in order
+     * to reach 'target_velocity' using 'acceleration' within a given
+     * 'distance'.
+     */
+    static float max_allowable_speed(const float &accel, const float &target_velocity, const float &distance) {
+      return SQRT(sq(target_velocity) - 2 * accel * distance);
+    }
+
+    static void calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor);
+
+    static void reverse_pass_kernel(block_t* const current, const block_t *next);
+    static void forward_pass_kernel(const block_t *previous, block_t* const current);
+
+    static void reverse_pass();
+    static void forward_pass();
+
+    static void recalculate_trapezoids();
+
+    static void recalculate();
+
+};
+
+#define PLANNER_XY_FEEDRATE() (min(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]))
+
+extern Planner planner;
+
+#endif // PLANNER_H
