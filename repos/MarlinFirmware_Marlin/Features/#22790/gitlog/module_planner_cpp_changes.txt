commit f0bc4274f817166fcce82949d94330bd1c441c15
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Mon Jul 15 20:13:00 2024 +0200

    üßë‚Äçüíª FT Motion: Individual axis shaping, new buffer management (#26848)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index b3dc856a0a..0773fa4021 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1577,21 +1577,21 @@ void Planner::quick_stop() {
   // so this must be enclosed in a critical section
 
   const bool was_enabled = stepper.suspend();
 
   // Drop all queue entries
   block_buffer_nonbusy = block_buffer_head = block_buffer_tail;
 
   // Restart the block delay for the first movement - As the queue was
   // forced to empty, there's no risk the ISR will touch this.
 
-  delay_before_delivering = TERN_(FT_MOTION, ftMotion.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
+  delay_before_delivering = TERN_(FT_MOTION, ftMotion.cfg.active ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
 
   TERN_(HAS_WIRED_LCD, clear_block_buffer_runtime()); // Clear the accumulated runtime
 
   // Make sure to drop any attempt of queuing moves for 1 second
   cleaning_buffer_counter = TEMP_TIMER_FREQUENCY;
 
   // Reenable Stepper ISR
   if (was_enabled) stepper.wake_up();
 
   // And stop the stepper ISR
@@ -1738,21 +1738,21 @@ bool Planner::_buffer_steps(const xyze_long_t &target
     return true;
   }
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
     // give the planner an opportunity to queue more movements and plan them
     // As there are no queued movements, the Stepper ISR will not touch this
     // variable, so there is no risk setting this here (but it MUST be done
     // before the following line!!)
-    delay_before_delivering = TERN_(FT_MOTION, ftMotion.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
+    delay_before_delivering = TERN_(FT_MOTION, ftMotion.cfg.active ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
   }
 
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
   // find a speed from which the new block can stop safely
   const float safe_exit_speed_sqr = _MAX(
     TERN0(HINTS_SAFE_EXIT_SPEED, hints.safe_exit_speed_sqr),
     minimum_planner_speed_sqr
   );
@@ -2797,21 +2797,21 @@ void Planner::buffer_sync_block(const BlockFlagBit sync_flag/*=BLOCK_BIT_SYNC_PO
    */
   TERN_(LASER_POWER_SYNC, block->laser.power = cutter.power);
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
     // give the planner an opportunity to queue more movements and plan them
     // As there are no queued movements, the Stepper ISR will not touch this
     // variable, so there is no risk setting this here (but it MUST be done
     // before the following line!!)
-    delay_before_delivering = TERN_(FT_MOTION, ftMotion.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
+    delay_before_delivering = TERN_(FT_MOTION, ftMotion.cfg.active ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
   }
 
   block_buffer_head = next_buffer_head;
 
   stepper.wake_up();
 } // buffer_sync_block()
 
 /**
  * @brief Add a single linear movement
  *
@@ -3090,42 +3090,42 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s
       LOGICAL_AXIS_MAP(PAGE_UPDATE_DIR);
     }
 
     // If this is the first added movement, reload the delay, otherwise, cancel it.
     if (block_buffer_head == block_buffer_tail) {
       // If it was the first queued block, restart the 1st block delivery delay, to
       // give the planner an opportunity to queue more movements and plan them
       // As there are no queued movements, the Stepper ISR will not touch this
       // variable, so there is no risk setting this here (but it MUST be done
       // before the following line!!)
-      delay_before_delivering = TERN_(FT_MOTION, ftMotion.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
+      delay_before_delivering = TERN_(FT_MOTION, ftMotion.cfg.active ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
     }
 
     // Move buffer head
     block_buffer_head = next_buffer_head;
 
     stepper.enable_all_steppers();
     stepper.wake_up();
   }
 
 #endif // DIRECT_STEPPING
 
 /**
  * Directly set the planner ABCE position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * The provided ABCE position is in machine units.
  */
 void Planner::set_machine_position_mm(const abce_pos_t &abce) {
 
   // When FT Motion is enabled, call synchronize() here instead of generating a sync block
-  if (TERN0(FT_MOTION, ftMotion.cfg.mode)) synchronize();
+  if (TERN0(FT_MOTION, ftMotion.cfg.active)) synchronize();
 
   TERN_(DISTINCT_E_FACTORS, last_extruder = active_extruder);
   TERN_(HAS_POSITION_FLOAT, position_float = abce);
   position.set(
     LOGICAL_AXIS_LIST(
       LROUND(abce.e * settings.axis_steps_per_mm[E_AXIS_N(active_extruder)]),
       LROUND(abce.a * settings.axis_steps_per_mm[A_AXIS]),
       LROUND(abce.b * settings.axis_steps_per_mm[B_AXIS]),
       LROUND(abce.c * settings.axis_steps_per_mm[C_AXIS]),
       LROUND(abce.i * settings.axis_steps_per_mm[I_AXIS]),

commit 228179e09bfbc3b13c4cfd1a6cbf763fa57689e7
Author: John Robertson <john@cirtech.co.uk>
Date:   Sat Jul 13 17:47:46 2024 +0100

    ü©π Clock-based planner trapezoidal nominal_rate (#26881)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 892258ff3b..b3dc856a0a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -722,22 +722,20 @@ void Planner::init() {
   #else
     // All other 32-bit MPUs can easily do inverse using hardware division,
     // so we don't need to reduce precision or to use assembly language at all.
     // This routine, for all other archs, returns 0x100000000 / d ~= 0xFFFFFFFF / d
     FORCE_INLINE static uint32_t get_period_inverse(const uint32_t d) {
       return d ? 0xFFFFFFFF / d : 0xFFFFFFFF;
     }
   #endif
 #endif
 
-#define MINIMAL_STEP_RATE 120
-
 /**
  * Get the current block for processing
  * and mark the block as busy.
  * Return nullptr if the buffer is empty
  * or if there is a first-block delay.
  *
  * WARNING: Called from Stepper ISR context!
  */
 block_t* Planner::get_current_block() {
   // Get the number of moves in the planner queue so far
@@ -789,27 +787,23 @@ block_t* Planner::get_current_block() {
  * NOTE that the PRECONDITION to call this function is that the block is
  * NOT BUSY and it is marked as RECALCULATE. That WARRANTIES the Stepper ISR
  * is not and will not use the block while we modify it.
  */
 void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t entry_speed, const_float_t exit_speed) {
 
   const float spmm = block->steps_per_mm;
   uint32_t initial_rate = entry_speed ? LROUND(entry_speed * spmm) : block->initial_rate,
            final_rate = LROUND(exit_speed * spmm);
 
-  // Removing code to constrain values produces judder in direction-switching moves because the
-  // current discrete stepping math diverges from physical motion under constant acceleration
-  // when acceleration_steps_per_s2 is large compared to initial/final_rate.
-  NOLESS(initial_rate, uint32_t(MINIMAL_STEP_RATE));
-  NOLESS(final_rate,   uint32_t(MINIMAL_STEP_RATE));
-  NOMORE(initial_rate, block->nominal_rate);  // NOTE: The nominal rate may be less than MINIMAL_STEP_RATE!
-  NOMORE(final_rate,   block->nominal_rate);
+  NOLESS(initial_rate,        stepper.minimal_step_rate);
+  NOLESS(final_rate,          stepper.minimal_step_rate);
+  NOLESS(block->nominal_rate, stepper.minimal_step_rate);
 
   #if ANY(S_CURVE_ACCELERATION, LIN_ADVANCE)
     // If we have some plateau time, the cruise rate will be the nominal rate
     uint32_t cruise_rate = block->nominal_rate;
   #endif
 
   // Steps for acceleration, plateau and deceleration
   int32_t plateau_steps = block->step_event_count,
           accelerate_steps = 0,
           decelerate_steps = 0;

commit 4aff10785ee96a35eb4777c08b81722a59cecf68
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 5 18:46:38 2024 -0500

    üßë‚Äçüíª Use "enum class"

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 0e45f55214..892258ff3b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -792,22 +792,22 @@ block_t* Planner::get_current_block() {
  */
 void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t entry_speed, const_float_t exit_speed) {
 
   const float spmm = block->steps_per_mm;
   uint32_t initial_rate = entry_speed ? LROUND(entry_speed * spmm) : block->initial_rate,
            final_rate = LROUND(exit_speed * spmm);
 
   // Removing code to constrain values produces judder in direction-switching moves because the
   // current discrete stepping math diverges from physical motion under constant acceleration
   // when acceleration_steps_per_s2 is large compared to initial/final_rate.
-  NOLESS(initial_rate, long(MINIMAL_STEP_RATE));
-  NOLESS(final_rate,   long(MINIMAL_STEP_RATE));
+  NOLESS(initial_rate, uint32_t(MINIMAL_STEP_RATE));
+  NOLESS(final_rate,   uint32_t(MINIMAL_STEP_RATE));
   NOMORE(initial_rate, block->nominal_rate);  // NOTE: The nominal rate may be less than MINIMAL_STEP_RATE!
   NOMORE(final_rate,   block->nominal_rate);
 
   #if ANY(S_CURVE_ACCELERATION, LIN_ADVANCE)
     // If we have some plateau time, the cruise rate will be the nominal rate
     uint32_t cruise_rate = block->nominal_rate;
   #endif
 
   // Steps for acceleration, plateau and deceleration
   int32_t plateau_steps = block->step_event_count,

commit 10ffb9cb68b1e21757c17fd3c1958eb740caa260
Author: Vovodroid <vovodroid@users.noreply.github.com>
Date:   Fri Jul 5 05:22:16 2024 +0300

    ‚ú® FAN_KICKSTART_LINEAR (#27072)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index b4546e0235..0e45f55214 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1194,30 +1194,34 @@ void Planner::recalculate(const_float_t safe_exit_speed_sqr) {
     TERN_(HAS_FAN0, FAN_SET(0)); TERN_(HAS_FAN1, FAN_SET(1));
     TERN_(HAS_FAN2, FAN_SET(2)); TERN_(HAS_FAN3, FAN_SET(3));
     TERN_(HAS_FAN4, FAN_SET(4)); TERN_(HAS_FAN5, FAN_SET(5));
     TERN_(HAS_FAN6, FAN_SET(6)); TERN_(HAS_FAN7, FAN_SET(7));
   }
 
   #if FAN_KICKSTART_TIME
 
     void Planner::kickstart_fan(uint8_t (&fan_speed)[FAN_COUNT], const millis_t &ms, const uint8_t f) {
       static millis_t fan_kick_end[FAN_COUNT] = { 0 };
+      #if ENABLED(FAN_KICKSTART_LINEAR)
+        static uint8_t set_fan_speed[FAN_COUNT] = { 0 };
+      #endif
       if (fan_speed[f] > FAN_OFF_PWM) {
-        if (fan_kick_end[f] == 0) {
-          fan_kick_end[f] = ms + FAN_KICKSTART_TIME;
+        const bool first_kick = fan_kick_end[f] == 0 && TERN1(FAN_KICKSTART_LINEAR, fan_speed[f] > set_fan_speed[f]);
+        if (first_kick)
+          fan_kick_end[f] = ms + (FAN_KICKSTART_TIME) TERN_(FAN_KICKSTART_LINEAR, * (fan_speed[f] - set_fan_speed[f]) / 255);
+        if (first_kick || PENDING(ms, fan_kick_end[f])) {
           fan_speed[f] = FAN_KICKSTART_POWER;
+          return;
         }
-        else if (PENDING(ms, fan_kick_end[f]))
-          fan_speed[f] = FAN_KICKSTART_POWER;
       }
-      else
-        fan_kick_end[f] = 0;
+      fan_kick_end[f] = 0;
+      TERN_(FAN_KICKSTART_LINEAR, set_fan_speed[f] = fan_speed[f]);
     }
 
   #endif
 
 #endif // HAS_FAN
 
 /**
  * Maintain fans, paste extruder pressure, spindle/laser power
  */
 void Planner::check_axes_activity() {

commit 6fed66dd428f46d073a3c28f6ff39b13c86cc65e
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Mon Jul 1 21:56:06 2024 +0300

    ü©π‚ö°Ô∏è Fix judder, optimize planner (#27035)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 8f11f4ec18..b4546e0235 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -121,21 +121,20 @@
 Planner planner;
 
 // public:
 
 /**
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head,    // Index of the next block to be pushed
                  Planner::block_buffer_nonbusy, // Index of the first non-busy block
-                 Planner::block_buffer_planned, // Index of the optimally planned block
                  Planner::block_buffer_tail;    // Index of the busy block, if any
 uint16_t Planner::cleaning_buffer_counter;      // A counter to disable queuing of blocks
 uint8_t Planner::delay_before_delivering;       // Delay block delivery so initial blocks in an empty queue may merge
 
 #if ENABLED(EDITABLE_STEPS_PER_UNIT)
   float Planner::mm_per_step[DISTINCT_AXES];    // (mm) Millimeters per step
 #else
   constexpr float PlannerSettings::axis_steps_per_mm[DISTINCT_AXES];
   constexpr float Planner::mm_per_step[DISTINCT_AXES];
 #endif
@@ -761,59 +760,56 @@ block_t* Planner::get_current_block() {
 
     // No trapezoid calculated? Don't execute yet.
     if (block->flag.recalculate) return nullptr;
 
     // We can't be sure how long an active block will take, so don't count it.
     TERN_(HAS_WIRED_LCD, block_buffer_runtime_us -= block->segment_time_us);
 
     // As this block is busy, advance the nonbusy block pointer
     block_buffer_nonbusy = next_block_index(block_buffer_tail);
 
-    // Push block_buffer_planned pointer, if encountered.
-    if (block_buffer_tail == block_buffer_planned)
-      block_buffer_planned = block_buffer_nonbusy;
-
     // Return the block
     return block;
   }
 
   // The queue became empty
   TERN_(HAS_WIRED_LCD, clear_block_buffer_runtime()); // paranoia. Buffer is empty now - so reset accumulated time to zero.
 
   return nullptr;
 }
 
 /**
  * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
- * by the provided factors. Requires that initial_rate and final_rate are
- * no less than sqrt(block->acceleration_steps_per_s2 / 2), which is ensured
- * through minimum_planner_speed_sqr in _populate_block().
+ * by the provided factors. If entry_factor is 0 don't change the initial_rate.
+ * Assumes that the implied initial_rate and final_rate are no less than
+ * sqrt(block->acceleration_steps_per_s2 / 2). This is ensured through
+ * minimum_planner_speed_sqr / min_entry_speed_sqr though note there's one
+ * exception in recalculate_trapezoids().
  **
  * ############ VERY IMPORTANT ############
  * NOTE that the PRECONDITION to call this function is that the block is
  * NOT BUSY and it is marked as RECALCULATE. That WARRANTIES the Stepper ISR
- * is not and will not use the block while we modify it, so it is safe to
- * alter its values.
+ * is not and will not use the block while we modify it.
  */
-void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t entry_factor, const_float_t exit_factor) {
+void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t entry_speed, const_float_t exit_speed) {
 
-  uint32_t initial_rate = LROUND(block->nominal_rate * entry_factor),
-           final_rate = LROUND(block->nominal_rate * exit_factor); // (steps per second)
+  const float spmm = block->steps_per_mm;
+  uint32_t initial_rate = entry_speed ? LROUND(entry_speed * spmm) : block->initial_rate,
+           final_rate = LROUND(exit_speed * spmm);
 
-  // Legacy check against supposed timer overflow. However Stepper::calc_timer_interval() already
-  // should protect against it. But removing this code produces judder in direction-switching
-  // moves. This is because the current discrete stepping math diverges from physical motion under
-  // constant acceleration when acceleration_steps_per_s2 is large compared to initial/final_rate.
-  NOLESS(initial_rate, uint32_t(MINIMAL_STEP_RATE));  // Enforce the minimum speed
-  NOLESS(final_rate, uint32_t(MINIMAL_STEP_RATE));
-  NOMORE(initial_rate, block->nominal_rate);          // NOTE: The nominal rate may be less than MINIMAL_STEP_RATE!
-  NOMORE(final_rate, block->nominal_rate);
+  // Removing code to constrain values produces judder in direction-switching moves because the
+  // current discrete stepping math diverges from physical motion under constant acceleration
+  // when acceleration_steps_per_s2 is large compared to initial/final_rate.
+  NOLESS(initial_rate, long(MINIMAL_STEP_RATE));
+  NOLESS(final_rate,   long(MINIMAL_STEP_RATE));
+  NOMORE(initial_rate, block->nominal_rate);  // NOTE: The nominal rate may be less than MINIMAL_STEP_RATE!
+  NOMORE(final_rate,   block->nominal_rate);
 
   #if ANY(S_CURVE_ACCELERATION, LIN_ADVANCE)
     // If we have some plateau time, the cruise rate will be the nominal rate
     uint32_t cruise_rate = block->nominal_rate;
   #endif
 
   // Steps for acceleration, plateau and deceleration
   int32_t plateau_steps = block->step_event_count,
           accelerate_steps = 0,
           decelerate_steps = 0;
@@ -935,59 +931,53 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
  *                              PLANNER SPEED DEFINITION
  *                                     +--------+   <- current->nominal_speed
  *                                    /          \
  *         current->entry_speed ->   +            \
  *                                   |             + <- next->entry_speed (aka exit speed)
  *                                   +-------------+
  *                                       time -->
  *
  *  Recalculates the motion plan according to the following basic guidelines:
  *
- *    1. Go over every feasible block sequentially in reverse order and calculate the junction speeds
- *        (i.e. current->entry_speed) such that:
- *      a. No junction speed exceeds the pre-computed maximum junction speed limit or nominal speeds of
- *         neighboring blocks.
- *      b. A block entry speed cannot exceed one reverse-computed from its exit speed (next->entry_speed)
- *         with a maximum allowable deceleration over the block travel distance.
- *      c. The last (or newest appended) block is planned from safe_exit_speed_sqr.
- *    2. Go over every block in chronological (forward) order and dial down junction speed values if
- *      a. The exit speed exceeds the one forward-computed from its entry speed with the maximum allowable
- *         acceleration over the block travel distance.
+ *    1. Go over blocks sequentially in reverse order and maximize the entry junction speed:
+ *      a. Entry speed should stay below/at the pre-computed maximum junction speed limit
+ *      b. Aim for the maximum entry speed which is the one reverse-computed from its exit speed
+ *         (next->entry_speed) if assuming maximum deceleration over the full block travel distance
+ *      c. The last (newest appended) block uses safe_exit_speed exit speed (there's no 'next')
+ *    2. Go over blocks in chronological (forward) order and fix the exit junction speed:
+ *      a. Exit speed (next->entry_speed) must be below/at the maximum exit speed forward-computed
+ *         from its entry speed if assuming maximum acceleration over the full block travel distance
+ *      b. Exit speed should stay above/at the pre-computed minimum junction speed limit
+ *    3. Convert entry / exit speeds (mm/s) into final/initial steps/s
  *
  *  When these stages are complete, the planner will have maximized the velocity profiles throughout the all
  *  of the planner blocks, where every block is operating at its maximum allowable acceleration limits. In
  *  other words, for all of the blocks in the planner, the plan is optimal and no further speed improvements
  *  are possible. If a new block is added to the buffer, the plan is recomputed according to the said
  *  guidelines for a new optimal plan.
  *
- *  To increase computational efficiency of these guidelines, a set of planner block pointers have been
- *  created to indicate stop-compute points for when the planner guidelines cannot logically make any further
- *  changes or improvements to the plan when in normal operation and new blocks are streamed and added to the
- *  planner buffer. For example, if a subset of sequential blocks in the planner have been planned and are
- *  bracketed by junction velocities at their maximums (or by the first planner block as well), no new block
- *  added to the planner buffer will alter the velocity profiles within them. So we no longer have to compute
- *  them. Or, if a set of sequential blocks from the first block in the planner (or a optimal stop-compute
- *  point) are all accelerating, they are all optimal and can not be altered by a new block added to the
- *  planner buffer, as this will only further increase the plan speed to chronological blocks until a maximum
- *  junction velocity is reached. However, if the operational conditions of the plan changes from infrequently
- *  used feed holds or feedrate overrides, the stop-compute pointers will be reset and the entire plan is
- *  recomputed as stated in the general guidelines.
+ *  To increase computational efficiency of these guidelines:
+ *    1. We keep track of which blocks need calculation (block->flag.recalculate)
+ *    2. We stop the reverse pass on the first block whose entry_speed == max_entry_speed. As soon
+ *       as that happens, there can be no further increases (ensured by the previous recalculate)
+ *    3. On the forward pass we skip through to the first block with a modified exit speed
+ *       (next->entry_speed)
+ *    4. On the forward pass if we encounter a full acceleration block that limits its exit speed
+ *       (next->entry_speed) we also update the maximum for that junction (next->max_entry_speed)
+ *       so it's never updated again
+ *    5. We use speed squared (ex: entry_speed_sqr in mm^2/s^2) in acceleration limit computations
+ *    6. We don't recompute sqrt(entry_speed_sqr) if the block's entry speed didn't change
  *
  *  Planner buffer index mapping:
  *  - block_buffer_tail: Points to the beginning of the planner buffer. First to be executed or being executed.
  *  - block_buffer_head: Points to the buffer block after the last block in the buffer. Used to indicate whether
  *      the buffer is full or empty. As described for standard ring buffers, this block is always empty.
- *  - block_buffer_planned: Points to the first buffer block after the last optimally planned block for normal
- *      streaming operating conditions. Use for planning optimizations by avoiding recomputing parts of the
- *      planner buffer that don't change with the addition of a new block, as describe above. In addition,
- *      this block can never be less than block_buffer_tail and will always be pushed forward and maintain
- *      this requirement when encountered by the Planner::release_current_block() routine during a cycle.
  *
  *  NOTE: Since the planner only computes on what's in the planner buffer, some motions with many short
  *        segments (e.g., complex curves) may seem to move slowly. This is because there simply isn't
  *        enough combined distance traveled in the entire buffer to accelerate up to the nominal speed and
  *        then decelerate to a complete stop at the end of the buffer, as stated by the guidelines. If this
  *        happens and becomes an annoyance, there are a few simple solutions:
  *
  *    - Maximize the machine acceleration. The planner will be able to compute higher velocity profiles
  *      within the same combined distance.
  *
@@ -996,276 +986,200 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
  *
  *    - Maximize the planner buffer size. This also will increase the combined distance for the planner to
  *      compute over. It also increases the number of computations the planner has to perform to compute an
  *      optimal plan, so select carefully.
  *
  *    - Use G2/G3 arcs instead of many short segments. Arcs inform the planner of a safe exit speed at the
  *      end of the last segment, which alleviates this problem.
  */
 
 // The kernel called by recalculate() when scanning the plan from last to first entry.
-void Planner::reverse_pass_kernel(block_t * const current, const block_t * const next, const_float_t safe_exit_speed_sqr) {
+// Returns true if it could increase the current block's entry speed.
+bool Planner::reverse_pass_kernel(block_t * const current, const block_t * const next, const_float_t safe_exit_speed_sqr) {
   // We need to recalculate only for the last block added or if next->entry_speed_sqr changed.
   if (!next || next->flag.recalculate) {
     // And only if we're not already at max entry speed.
     if (current->entry_speed_sqr != current->max_entry_speed_sqr) {
       const float next_entry_speed_sqr = next ? next->entry_speed_sqr : safe_exit_speed_sqr;
       float new_entry_speed_sqr = max_allowable_speed_sqr(-current->acceleration, next_entry_speed_sqr, current->millimeters);
       NOMORE(new_entry_speed_sqr, current->max_entry_speed_sqr);
       if (current->entry_speed_sqr != new_entry_speed_sqr) {
 
         // Need to recalculate the block speed - Mark it now, so the stepper
         // ISR does not consume the block before being recalculated
         current->flag.recalculate = true;
 
         // But there is an inherent race condition here, as the block may have
         // become BUSY just before being marked RECALCULATE, so check for that!
         if (stepper.is_block_busy(current)) {
           // Block became busy. Clear the RECALCULATE flag (no point in
-          // recalculating BUSY blocks). And don't set its speed, as it can't
-          // be updated at this time.
+          // recalculating BUSY blocks).
           current->flag.recalculate = false;
         }
         else {
           // Block is not BUSY so this is ahead of the Stepper ISR:
-          // Just Set the new entry speed.
+
           current->entry_speed_sqr = new_entry_speed_sqr;
+          return true;
         }
       }
     }
   }
+  return false;
 }
 
 /**
  * recalculate() needs to go over the current plan twice.
- * Once in reverse and once forward. This implements the reverse pass.
+ * Once in reverse and once forward. This implements the reverse pass that
+ * coarsely maximizes the entry speeds starting from last block.
+ * Requires there's at least one block with flag.recalculate in the buffer.
  */
 void Planner::reverse_pass(const_float_t safe_exit_speed_sqr) {
   // Initialize block index to the last block in the planner buffer.
+  // This last block will have flag.recalculate set.
   uint8_t block_index = prev_block_index(block_buffer_head);
 
-  // Read the index of the last buffer planned block.
-  // The ISR may change it so get a stable local copy.
-  uint8_t planned_block_index = block_buffer_planned;
-
-  // If there was a race condition and block_buffer_planned was incremented
-  //  or was pointing at the head (queue empty) break loop now and avoid
-  //  planning already consumed blocks
-  if (planned_block_index == block_buffer_head) return;
+  // The ISR may change block_buffer_nonbusy so get a stable local copy.
+  uint8_t nonbusy_block_index = block_buffer_nonbusy;
 
-  // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
-  // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
-  // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
   const block_t *next = nullptr;
-  while (block_index != planned_block_index) {
-
-    // Perform the reverse pass
+  // Don't try to change the entry speed of the first non-busy block.
+  while (block_index != nonbusy_block_index) {
     block_t *current = &block_buffer[block_index];
 
     // Only process movement blocks
     if (current->is_move()) {
-      reverse_pass_kernel(current, next, safe_exit_speed_sqr);
+      // If no entry speed increase was possible we end the reverse pass.
+      if (!reverse_pass_kernel(current, next, safe_exit_speed_sqr)) return;
       next = current;
     }
 
-    // Advance to the next
     block_index = prev_block_index(block_index);
 
-    // The ISR could advance the block_buffer_planned while we were doing the reverse pass.
+    // The ISR could advance block_buffer_nonbusy while we were doing the reverse pass.
     // We must try to avoid using an already consumed block as the last one - So follow
     // changes to the pointer and make sure to limit the loop to the currently busy block
-    while (planned_block_index != block_buffer_planned) {
+    while (nonbusy_block_index != block_buffer_nonbusy) {
 
       // If we reached the busy block or an already processed block, break the loop now
-      if (block_index == planned_block_index) return;
+      if (block_index == nonbusy_block_index) return;
 
       // Advance the pointer, following the busy block
-      planned_block_index = next_block_index(planned_block_index);
+      nonbusy_block_index = next_block_index(nonbusy_block_index);
     }
   }
 }
 
-// The kernel called by recalculate() when scanning the plan from first to last entry.
-void Planner::forward_pass_kernel(const block_t * const previous, block_t * const current, const uint8_t block_index) {
-  // Check against previous speed only on current->entry_speed_sqr changes (or if first time).
-  if (current->flag.recalculate) {
-    // If the previous block is accelerating check if it's too short to complete the full speed
-    // change then adjust the entry speed accordingly. Entry speeds have already been maximized.
-    if (previous->entry_speed_sqr < current->entry_speed_sqr) {
-      float new_entry_speed_sqr = max_allowable_speed_sqr(-previous->acceleration, previous->entry_speed_sqr, previous->millimeters);
-
-      // If true, previous block is full-acceleration and we can move the planned pointer forward.
-      if (new_entry_speed_sqr < current->entry_speed_sqr) {
-        // Current entry speed limited by full acceleration from previous entry speed.
-        // Make sure entry speed not lower than minimum_planner_speed_sqr.
-        NOLESS(new_entry_speed_sqr, current->min_entry_speed_sqr);
-        current->entry_speed_sqr = new_entry_speed_sqr;
-
-        // Set optimal plan pointer.
-        block_buffer_planned = block_index;
-      }
-      else {
-        // Previous entry speed has been maximized.
-        block_buffer_planned = prev_block_index(block_index);
-      }
+// The kernel called during the forward pass. Assumes current->flag.recalculate.
+void Planner::forward_pass_kernel(const block_t * const previous, block_t * const current) {
+  // Check if the previous block is accelerating.
+  if (previous->entry_speed_sqr < current->entry_speed_sqr) {
+    // Compute the maximum achievable speed if the previous block was fully accelerating.
+    float new_exit_speed_sqr = max_allowable_speed_sqr(-previous->acceleration, previous->entry_speed_sqr, previous->millimeters);
+
+    if (new_exit_speed_sqr < current->entry_speed_sqr) {
+      // Current entry speed limited by full acceleration from previous entry speed.
+
+      // Make sure entry speed not lower than minimum_planner_speed_sqr.
+      NOLESS(new_exit_speed_sqr, current->min_entry_speed_sqr);
+      current->entry_speed_sqr = new_exit_speed_sqr;
+      // Ensure we don't try updating entry_speed_sqr again.
+      current->max_entry_speed_sqr = new_exit_speed_sqr;
     }
-
-    // Any block set at its maximum entry speed also creates an optimal plan up to this
-    // point in the buffer. When the plan is bracketed by either the beginning of the
-    // buffer and a maximum entry speed or two maximum entry speeds, every block in between
-    // cannot logically be further improved. Hence, we don't have to recompute them anymore.
-    if (current->entry_speed_sqr == current->max_entry_speed_sqr)
-      block_buffer_planned = block_index;
   }
-}
 
-/**
- * recalculate() needs to go over the current plan twice.
- * Once in reverse and once forward. This implements the forward pass.
- */
-void Planner::forward_pass() {
-
-  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
-  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
-
-  // Begin at buffer planned pointer. Note that block_buffer_planned can be modified
-  //  by the stepper ISR,  so read it ONCE. It it guaranteed that block_buffer_planned
-  //  will never lead head, so the loop is safe to execute. Also note that the forward
-  //  pass will never modify the values at the tail.
-  uint8_t block_index = block_buffer_planned;
-
-  block_t *block;
-  const block_t * previous = nullptr;
-  while (block_index != block_buffer_head) {
-
-    // Perform the forward pass
-    block = &block_buffer[block_index];
-
-    // Only process movement blocks
-    if (block->is_move()) {
-      // If there's no previous block or the previous block is not
-      // BUSY (thus, modifiable) run the forward_pass_kernel. Otherwise,
-      // the previous block became BUSY, so assume the current block's
-      // entry speed can't be altered (since that would also require
-      // updating the exit speed of the previous block).
-      if (previous && !stepper.is_block_busy(previous))
-        forward_pass_kernel(previous, block, block_index);
-      previous = block;
-    }
-    // Advance to the previous
-    block_index = next_block_index(block_index);
-  }
+  // The fully optimized entry speed is our new minimum speed.
+  current->min_entry_speed_sqr = current->entry_speed_sqr;
 }
 
 /**
- * Recalculate the trapezoid speed profiles for all blocks in the plan
- * according to the entry_factor for each junction. Must be called by
- * recalculate() after updating the blocks.
+ * Do the forward pass and recalculate the trapezoid speed profiles for all blocks in the plan
+ * according to entry/exit speeds.
  */
 void Planner::recalculate_trapezoids(const_float_t safe_exit_speed_sqr) {
-  // The tail may be changed by the ISR so get a local copy.
+  // Start with the block that's about to execute or is executing.
   uint8_t block_index = block_buffer_tail,
           head_block_index = block_buffer_head;
-  // Since there could be a sync block in the head of the queue, and the
-  // next loop must not recalculate the head block (as it needs to be
-  // specially handled), scan backwards to the first non-SYNC block.
-  while (head_block_index != block_index) {
-
-    // Go back (head always point to the first free block)
-    const uint8_t prev_index = prev_block_index(head_block_index);
-
-    // Get the pointer to the block
-    block_t *prev = &block_buffer[prev_index];
-
-    // It the block is a move, we're done with this loop
-    if (prev->is_move()) break;
 
-    // Examine the previous block. This and all following are SYNC blocks
-    head_block_index = prev_index;
-  }
-
-  // Go from the tail (currently executed block) to the first block, without including it)
   block_t *block = nullptr, *next = nullptr;
-  float current_entry_speed = 0.0f, next_entry_speed = 0.0f;
+  float next_entry_speed = 0.0f;
   while (block_index != head_block_index) {
 
     next = &block_buffer[block_index];
 
-    // Only process movement blocks
     if (next->is_move()) {
-      next_entry_speed = SQRT(next->entry_speed_sqr);
-
-      if (block) {
-
-        // If the next block is marked to RECALCULATE, also mark the previously-fetched one
-        if (next->flag.recalculate) block->flag.recalculate = true;
+      // Check if the next block's entry speed changed
+      if (next->flag.recalculate) {
+        if (!block) {
+          // 'next' is the first move due to either being the first added move or due to the planner
+          // having completely fallen behind. Revert any reverse pass change.
+          next->entry_speed_sqr = next->min_entry_speed_sqr;
+          next_entry_speed = SQRT(next->min_entry_speed_sqr);
+        }
+        else {
+          // Try to fix exit speed which requires trapezoid recalculation
+          block->flag.recalculate = true;
+
+          // But there is an inherent race condition here, as the block may have
+          // become BUSY just before being marked RECALCULATE, so check for that!
+          if (stepper.is_block_busy(block)) {
+            // Block is BUSY so we can't change the exit speed. Revert any reverse pass change.
+            next->entry_speed_sqr = next->min_entry_speed_sqr;
+            if (!next->initial_rate) {
+              // 'next' was never calculated. Planner is falling behind so for maximum efficiency
+              // set next's stepping speed directly and forgo checking against min_entry_speed_sqr.
+              // calculate_trapezoid_for_block() can handle it, albeit sub-optimally.
+              next->initial_rate = block->final_rate;
+            }
+            // Note that at this point next_entry_speed is (still) 0.
+          }
+          else {
+            // Block is not BUSY: we won the race against the ISR or recalculate was already set
 
-        // Recalculate if current block entry or exit junction speed has changed.
-        if (block->flag.recalculate) {
+            if (next->entry_speed_sqr != next->min_entry_speed_sqr)
+              forward_pass_kernel(block, next);
 
-          // But there is an inherent race condition here, as the block maybe
-          // became BUSY, just before it was marked as RECALCULATE, so check
-          // if that is the case!
-          if (!stepper.is_block_busy(block)) {
-            // Block is not BUSY, we won the race against the Stepper ISR:
+            const float current_entry_speed = next_entry_speed;
+            next_entry_speed = SQRT(next->entry_speed_sqr);
 
-            // NOTE: Entry and exit factors always > 0 by all previous logic operations.
-            const float nomr = 1.0f / block->nominal_speed;
-            calculate_trapezoid_for_block(block, current_entry_speed * nomr, next_entry_speed * nomr);
+            calculate_trapezoid_for_block(block, current_entry_speed, next_entry_speed);
           }
 
           // Reset current only to ensure next trapezoid is computed - The
           // stepper is free to use the block from now on.
           block->flag.recalculate = false;
         }
       }
 
       block = next;
-      current_entry_speed = next_entry_speed;
     }
 
     block_index = next_block_index(block_index);
   }
 
-  // Last/newest block in buffer. Always recalculated.
-  if (block) {
+  // Last/newest block in buffer. The above guarantees it's a move block.
+  if (block && block->flag.recalculate) {
+    const float current_entry_speed = next_entry_speed;
     next_entry_speed = SQRT(safe_exit_speed_sqr);
 
-    // Mark the next(last) block as RECALCULATE, to prevent the Stepper ISR running it.
-    // As the last block is always recalculated here, there is a chance the block isn't
-    // marked as RECALCULATE yet. That's the reason for the following line.
-    block->flag.recalculate = true;
-
-    // But there is an inherent race condition here, as the block maybe
-    // became BUSY, just before it was marked as RECALCULATE, so check
-    // if that is the case!
-    if (!stepper.is_block_busy(block)) {
-      // Block is not BUSY, we won the race against the Stepper ISR:
-
-      const float nomr = 1.0f / block->nominal_speed;
-      calculate_trapezoid_for_block(block, current_entry_speed * nomr, next_entry_speed * nomr);
-    }
+    calculate_trapezoid_for_block(block, current_entry_speed, next_entry_speed);
 
     // Reset block to ensure its trapezoid is computed - The stepper is free to use
     // the block from now on.
     block->flag.recalculate = false;
   }
 }
 
+// Requires there's at least one block with flag.recalculate in the buffer
 void Planner::recalculate(const_float_t safe_exit_speed_sqr) {
-  // Initialize block index to the last block in the planner buffer.
-  const uint8_t block_index = prev_block_index(block_buffer_head);
-  // If there is just one block, no planning can be done. Avoid it!
-  if (block_index != block_buffer_planned) {
-    reverse_pass(safe_exit_speed_sqr);
-    forward_pass();
-  }
+  reverse_pass(safe_exit_speed_sqr);
+  // The forward pass is done as part of recalculate_trapezoids()
   recalculate_trapezoids(safe_exit_speed_sqr);
 }
 
 /**
  * Apply fan speeds
  */
 #if HAS_FAN
 
   void Planner::sync_fan_speeds(uint8_t (&fan_speed)[FAN_COUNT]) {
 
@@ -1660,21 +1574,21 @@ void Planner::quick_stop() {
 
   // Remove all the queued blocks. Note that this function is NOT
   // called from the Stepper ISR, so we must consider tail as readonly!
   // that is why we set head to tail - But there is a race condition that
   // must be handled: The tail could change between the read and the assignment
   // so this must be enclosed in a critical section
 
   const bool was_enabled = stepper.suspend();
 
   // Drop all queue entries
-  block_buffer_nonbusy = block_buffer_planned = block_buffer_head = block_buffer_tail;
+  block_buffer_nonbusy = block_buffer_head = block_buffer_tail;
 
   // Restart the block delay for the first movement - As the queue was
   // forced to empty, there's no risk the ISR will touch this.
 
   delay_before_delivering = TERN_(FT_MOTION, ftMotion.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
 
   TERN_(HAS_WIRED_LCD, clear_block_buffer_runtime()); // Clear the accumulated runtime
 
   // Make sure to drop any attempt of queuing moves for 1 second
   cleaning_buffer_counter = TEMP_TIMER_FREQUENCY;
@@ -2429,20 +2343,21 @@ bool Planner::_populate_block(
 
   // Correct the speed
   if (speed_factor < 1.0f) {
     current_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
     block->nominal_speed *= speed_factor;
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
+  block->steps_per_mm = steps_per_mm;
   uint32_t accel;
   #if ENABLED(LIN_ADVANCE)
     bool use_advance_lead = false;
   #endif
   if (!ANY_AXIS_MOVES(block)) {                                   // Is this a retract / recover move?
     accel = CEIL(settings.retract_acceleration * steps_per_mm);   // Convert to: acceleration steps/sec^2
   }
   else {
     #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
@@ -2822,20 +2737,22 @@ bool Planner::_populate_block(
   // High acceleration limits override low jerk/junction deviation limits (as fixing trapezoids
   // or reducing acceleration introduces too much complexity and/or too much compute)
   NOLESS(vmax_junction_sqr, minimum_planner_speed_sqr);
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed_sqr = vmax_junction_sqr;
   // Set entry speed. The reverse and forward passes will optimize it later.
   block->entry_speed_sqr = minimum_planner_speed_sqr;
   // Set min entry speed. Rarely it could be higher than the previous nominal speed but that's ok.
   block->min_entry_speed_sqr = minimum_planner_speed_sqr;
+  // Zero the initial_rate to indicate that calculate_trapezoid_for_block() hasn't been called yet.
+  block->initial_rate = 0;
 
   block->flag.recalculate = true;
 
   // Update previous path unit_vector and nominal speed
   previous_speed = current_speed;
   previous_nominal_speed = block->nominal_speed;
 
   position = target;  // Update the position
 
   #if ENABLED(POWER_LOSS_RECOVERY)

commit 2fd7c2b8652a3250e1eb1dbfd96991b4b11f6257
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Fri May 17 04:48:21 2024 +0300

    ‚ö°Ô∏è Fix motion smoothness (#27013)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 6b4f63fb00..8f11f4ec18 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -789,81 +789,87 @@ block_t* Planner::get_current_block() {
  * through minimum_planner_speed_sqr in _populate_block().
  **
  * ############ VERY IMPORTANT ############
  * NOTE that the PRECONDITION to call this function is that the block is
  * NOT BUSY and it is marked as RECALCULATE. That WARRANTIES the Stepper ISR
  * is not and will not use the block while we modify it, so it is safe to
  * alter its values.
  */
 void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t entry_factor, const_float_t exit_factor) {
 
-  uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
-           final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
-
-  // Limit minimal step rate (Otherwise the timer will overflow.)
-  NOLESS(initial_rate, uint32_t(MINIMAL_STEP_RATE));
+  uint32_t initial_rate = LROUND(block->nominal_rate * entry_factor),
+           final_rate = LROUND(block->nominal_rate * exit_factor); // (steps per second)
+
+  // Legacy check against supposed timer overflow. However Stepper::calc_timer_interval() already
+  // should protect against it. But removing this code produces judder in direction-switching
+  // moves. This is because the current discrete stepping math diverges from physical motion under
+  // constant acceleration when acceleration_steps_per_s2 is large compared to initial/final_rate.
+  NOLESS(initial_rate, uint32_t(MINIMAL_STEP_RATE));  // Enforce the minimum speed
   NOLESS(final_rate, uint32_t(MINIMAL_STEP_RATE));
+  NOMORE(initial_rate, block->nominal_rate);          // NOTE: The nominal rate may be less than MINIMAL_STEP_RATE!
+  NOMORE(final_rate, block->nominal_rate);
 
   #if ANY(S_CURVE_ACCELERATION, LIN_ADVANCE)
     // If we have some plateau time, the cruise rate will be the nominal rate
     uint32_t cruise_rate = block->nominal_rate;
   #endif
 
   // Steps for acceleration, plateau and deceleration
-  int32_t plateau_steps = block->step_event_count;
-  uint32_t accelerate_steps = 0,
-           decelerate_steps = 0;
+  int32_t plateau_steps = block->step_event_count,
+          accelerate_steps = 0,
+          decelerate_steps = 0;
 
   const int32_t accel = block->acceleration_steps_per_s2;
   float inverse_accel = 0.0f;
   if (accel != 0) {
     inverse_accel = 1.0f / accel;
     const float half_inverse_accel = 0.5f * inverse_accel,
                 nominal_rate_sq = FLOAT_SQ(block->nominal_rate),
                 // Steps required for acceleration, deceleration to/from nominal rate
-                decelerate_steps_float = half_inverse_accel * (nominal_rate_sq - FLOAT_SQ(final_rate));
-          float accelerate_steps_float = half_inverse_accel * (nominal_rate_sq - FLOAT_SQ(initial_rate));
+                decelerate_steps_float = half_inverse_accel * (nominal_rate_sq - FLOAT_SQ(final_rate)),
+                accelerate_steps_float = half_inverse_accel * (nominal_rate_sq - FLOAT_SQ(initial_rate));
+    // Aims to fully reach nominal and final rates
     accelerate_steps = CEIL(accelerate_steps_float);
-    decelerate_steps = FLOOR(decelerate_steps_float);
+    decelerate_steps = CEIL(decelerate_steps_float);
 
     // Steps between acceleration and deceleration, if any
     plateau_steps -= accelerate_steps + decelerate_steps;
 
     // Does accelerate_steps + decelerate_steps exceed step_event_count?
     // Then we can't possibly reach the nominal rate, there will be no cruising.
     // Calculate accel / braking time in order to reach the final_rate exactly
     // at the end of this block.
     if (plateau_steps < 0) {
-      accelerate_steps_float = CEIL((block->step_event_count + accelerate_steps_float - decelerate_steps_float) * 0.5f);
-      accelerate_steps = _MIN(uint32_t(_MAX(accelerate_steps_float, 0)), block->step_event_count);
+      accelerate_steps = LROUND((block->step_event_count + accelerate_steps_float - decelerate_steps_float) * 0.5f);
+      LIMIT(accelerate_steps, 0, int32_t(block->step_event_count));
       decelerate_steps = block->step_event_count - accelerate_steps;
 
       #if ANY(S_CURVE_ACCELERATION, LIN_ADVANCE)
         // We won't reach the cruising rate. Let's calculate the speed we will reach
-        cruise_rate = final_speed(initial_rate, accel, accelerate_steps);
+        NOMORE(cruise_rate, final_speed(initial_rate, accel, accelerate_steps));
       #endif
     }
   }
 
   #if ENABLED(S_CURVE_ACCELERATION)
     const float rate_factor = inverse_accel * (STEPPER_TIMER_RATE);
     // Jerk controlled speed requires to express speed versus time, NOT steps
     uint32_t acceleration_time = rate_factor * float(cruise_rate - initial_rate),
              deceleration_time = rate_factor * float(cruise_rate - final_rate),
     // And to offload calculations from the ISR, we also calculate the inverse of those times here
              acceleration_time_inverse = get_period_inverse(acceleration_time),
              deceleration_time_inverse = get_period_inverse(deceleration_time);
   #endif
 
   // Store new block parameters
-  block->accelerate_until = accelerate_steps;
-  block->decelerate_after = block->step_event_count - decelerate_steps;
+  block->accelerate_before = accelerate_steps;
+  block->decelerate_start = block->step_event_count - decelerate_steps;
   block->initial_rate = initial_rate;
   #if ENABLED(S_CURVE_ACCELERATION)
     block->acceleration_time = acceleration_time;
     block->deceleration_time = deceleration_time;
     block->acceleration_time_inverse = acceleration_time_inverse;
     block->deceleration_time_inverse = deceleration_time_inverse;
     block->cruise_rate = cruise_rate;
   #endif
   block->final_rate = final_rate;
 
@@ -3151,22 +3157,22 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s
       FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
     #endif
 
     E_TERN_(block->extruder = extruder);
 
     block->page_idx = page_idx;
 
     block->step_event_count = num_steps;
     block->initial_rate = block->final_rate = block->nominal_rate = last_page_step_rate; // steps/s
 
-    block->accelerate_until = 0;
-    block->decelerate_after = block->step_event_count;
+    block->accelerate_before = 0;
+    block->decelerate_start = block->step_event_count;
 
     // Will be set to last direction later if directional format.
     block->direction_bits.reset();
 
     if (!DirectStepping::Config::DIRECTIONAL) {
       #define PAGE_UPDATE_DIR(AXIS) do{ if (last_page_dir.AXIS) block->direction_bits.AXIS = true; }while(0);
       LOGICAL_AXIS_MAP(PAGE_UPDATE_DIR);
     }
 
     // If this is the first added movement, reload the delay, otherwise, cancel it.

commit 3dc437add4d142b71ea0684848fc1b73e4245a4c
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Thu May 16 08:42:19 2024 +1200

    üé® Apply TERN0/1 for some contexts (#27036)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 0b236b8a10..6b4f63fb00 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1422,37 +1422,37 @@ void Planner::check_axes_activity() {
     }
   #endif
 
   /**
    * Called after changing tools to:
    *  - Reset or re-apply the default proportional autotemp factor.
    *  - Enable autotemp if the factor is non-zero.
    */
   void Planner::autotemp_update() {
     _autotemp_update_from_hotend();
-    autotemp.factor = TERN(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P, 0);
+    autotemp.factor = TERN0(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P);
     autotemp.enabled = autotemp.factor != 0;
   }
 
   /**
    * Called by the M104/M109 commands after setting Hotend Temperature
    *
    */
   void Planner::autotemp_M104_M109() {
     _autotemp_update_from_hotend();
 
     if (parser.seenval('S')) autotemp.min = parser.value_celsius();
     if (parser.seenval('B')) autotemp.max = parser.value_celsius();
 
     // When AUTOTEMP_PROPORTIONAL is enabled, F0 disables autotemp.
     // Normally, leaving off F also disables autotemp.
-    autotemp.factor = parser.seen('F') ? parser.value_float() : TERN(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P, 0);
+    autotemp.factor = parser.seen('F') ? parser.value_float() : TERN0(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P);
     autotemp.enabled = autotemp.factor != 0;
   }
 
   /**
    * Called every so often to adjust the hotend target temperature
    * based on the extrusion speed, which is calculated from the blocks
    * currently in the planner.
    */
   void Planner::autotemp_task() {
     static float oldt = 0.0f;

commit 5f96dffb9b50baf1e730c21405a573ad45b45e7d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 15 15:21:39 2024 -0500

    üßë‚Äçüíª FLOAT_SQ macro

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 10d2f4a88f..0b236b8a10 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -811,24 +811,24 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
   // Steps for acceleration, plateau and deceleration
   int32_t plateau_steps = block->step_event_count;
   uint32_t accelerate_steps = 0,
            decelerate_steps = 0;
 
   const int32_t accel = block->acceleration_steps_per_s2;
   float inverse_accel = 0.0f;
   if (accel != 0) {
     inverse_accel = 1.0f / accel;
     const float half_inverse_accel = 0.5f * inverse_accel,
-                nominal_rate_sq = sq(float(block->nominal_rate)),
+                nominal_rate_sq = FLOAT_SQ(block->nominal_rate),
                 // Steps required for acceleration, deceleration to/from nominal rate
-                decelerate_steps_float = half_inverse_accel * (nominal_rate_sq - sq(float(final_rate)));
-          float accelerate_steps_float = half_inverse_accel * (nominal_rate_sq - sq(float(initial_rate)));
+                decelerate_steps_float = half_inverse_accel * (nominal_rate_sq - FLOAT_SQ(final_rate));
+          float accelerate_steps_float = half_inverse_accel * (nominal_rate_sq - FLOAT_SQ(initial_rate));
     accelerate_steps = CEIL(accelerate_steps_float);
     decelerate_steps = FLOOR(decelerate_steps_float);
 
     // Steps between acceleration and deceleration, if any
     plateau_steps -= accelerate_steps + decelerate_steps;
 
     // Does accelerate_steps + decelerate_steps exceed step_event_count?
     // Then we can't possibly reach the nominal rate, there will be no cruising.
     // Calculate accel / braking time in order to reach the final_rate exactly
     // at the end of this block.

commit 6423b8031deba6c7a1e21279d6c468c3c33d28e6
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Wed May 15 23:01:56 2024 +0300

    ‚ö°Ô∏è Add / enforce min_entry_speed_sqr (#27089)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ae3b9e50a0..10d2f4a88f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -777,21 +777,23 @@ block_t* Planner::get_current_block() {
   }
 
   // The queue became empty
   TERN_(HAS_WIRED_LCD, clear_block_buffer_runtime()); // paranoia. Buffer is empty now - so reset accumulated time to zero.
 
   return nullptr;
 }
 
 /**
  * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
- * by the provided factors.
+ * by the provided factors. Requires that initial_rate and final_rate are
+ * no less than sqrt(block->acceleration_steps_per_s2 / 2), which is ensured
+ * through minimum_planner_speed_sqr in _populate_block().
  **
  * ############ VERY IMPORTANT ############
  * NOTE that the PRECONDITION to call this function is that the block is
  * NOT BUSY and it is marked as RECALCULATE. That WARRANTIES the Stepper ISR
  * is not and will not use the block while we modify it, so it is safe to
  * alter its values.
  */
 void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t entry_factor, const_float_t exit_factor) {
 
   uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
@@ -933,21 +935,21 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
  *                                       time -->
  *
  *  Recalculates the motion plan according to the following basic guidelines:
  *
  *    1. Go over every feasible block sequentially in reverse order and calculate the junction speeds
  *        (i.e. current->entry_speed) such that:
  *      a. No junction speed exceeds the pre-computed maximum junction speed limit or nominal speeds of
  *         neighboring blocks.
  *      b. A block entry speed cannot exceed one reverse-computed from its exit speed (next->entry_speed)
  *         with a maximum allowable deceleration over the block travel distance.
- *      c. The last (or newest appended) block is planned from a complete stop (an exit speed of zero).
+ *      c. The last (or newest appended) block is planned from safe_exit_speed_sqr.
  *    2. Go over every block in chronological (forward) order and dial down junction speed values if
  *      a. The exit speed exceeds the one forward-computed from its entry speed with the maximum allowable
  *         acceleration over the block travel distance.
  *
  *  When these stages are complete, the planner will have maximized the velocity profiles throughout the all
  *  of the planner blocks, where every block is operating at its maximum allowable acceleration limits. In
  *  other words, for all of the blocks in the planner, the plan is optimal and no further speed improvements
  *  are possible. If a new block is added to the buffer, the plan is recomputed according to the said
  *  guidelines for a new optimal plan.
  *
@@ -989,43 +991,27 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
  *    - Maximize the planner buffer size. This also will increase the combined distance for the planner to
  *      compute over. It also increases the number of computations the planner has to perform to compute an
  *      optimal plan, so select carefully.
  *
  *    - Use G2/G3 arcs instead of many short segments. Arcs inform the planner of a safe exit speed at the
  *      end of the last segment, which alleviates this problem.
  */
 
 // The kernel called by recalculate() when scanning the plan from last to first entry.
 void Planner::reverse_pass_kernel(block_t * const current, const block_t * const next, const_float_t safe_exit_speed_sqr) {
-  if (current) {
-    // If entry speed is already at the maximum entry speed, and there was no change of speed
-    // in the next block, there is no need to recheck. Block is cruising and there is no need to
-    // compute anything for this block,
-    // If not, block entry speed needs to be recalculated to ensure maximum possible planned speed.
-    const float max_entry_speed_sqr = current->max_entry_speed_sqr;
-
-    // Compute maximum entry speed decelerating over the current block from its exit speed.
-    // If not at the maximum entry speed, or the previous block entry speed changed
-    if (current->entry_speed_sqr != max_entry_speed_sqr || (next && next->flag.recalculate)) {
-
-      // If nominal length true, max junction speed is guaranteed to be reached.
-      // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
-      // the current block and next block junction speeds are guaranteed to always be at their maximum
-      // junction speeds in deceleration and acceleration, respectively. This is due to how the current
-      // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
-      // the reverse and forward planners, the corresponding block junction speed will always be at the
-      // the maximum junction speed and may always be ignored for any speed reduction checks.
-
-      const float next_entry_speed_sqr = next ? next->entry_speed_sqr : safe_exit_speed_sqr,
-                  new_entry_speed_sqr = current->flag.nominal_length
-                    ? max_entry_speed_sqr
-                    : _MIN(max_entry_speed_sqr, max_allowable_speed_sqr(-current->acceleration, next_entry_speed_sqr, current->millimeters));
+  // We need to recalculate only for the last block added or if next->entry_speed_sqr changed.
+  if (!next || next->flag.recalculate) {
+    // And only if we're not already at max entry speed.
+    if (current->entry_speed_sqr != current->max_entry_speed_sqr) {
+      const float next_entry_speed_sqr = next ? next->entry_speed_sqr : safe_exit_speed_sqr;
+      float new_entry_speed_sqr = max_allowable_speed_sqr(-current->acceleration, next_entry_speed_sqr, current->millimeters);
+      NOMORE(new_entry_speed_sqr, current->max_entry_speed_sqr);
       if (current->entry_speed_sqr != new_entry_speed_sqr) {
 
         // Need to recalculate the block speed - Mark it now, so the stepper
         // ISR does not consume the block before being recalculated
         current->flag.recalculate = true;
 
         // But there is an inherent race condition here, as the block may have
         // become BUSY just before being marked RECALCULATE, so check for that!
         if (stepper.is_block_busy(current)) {
           // Block became busy. Clear the RECALCULATE flag (no point in
@@ -1087,55 +1073,40 @@ void Planner::reverse_pass(const_float_t safe_exit_speed_sqr) {
       if (block_index == planned_block_index) return;
 
       // Advance the pointer, following the busy block
       planned_block_index = next_block_index(planned_block_index);
     }
   }
 }
 
 // The kernel called by recalculate() when scanning the plan from first to last entry.
 void Planner::forward_pass_kernel(const block_t * const previous, block_t * const current, const uint8_t block_index) {
-  if (previous) {
-    // If the previous block is an acceleration block, too short to complete the full speed
-    // change, adjust the entry speed accordingly. Entry speeds have already been reset,
-    // maximized, and reverse-planned. If nominal length is set, max junction speed is
-    // guaranteed to be reached. No need to recheck.
-    if (!previous->flag.nominal_length && previous->entry_speed_sqr < current->entry_speed_sqr) {
-
-      // Compute the maximum allowable speed
-      const float new_entry_speed_sqr = max_allowable_speed_sqr(-previous->acceleration, previous->entry_speed_sqr, previous->millimeters);
-
-      // If true, current block is full-acceleration and we can move the planned pointer forward.
+  // Check against previous speed only on current->entry_speed_sqr changes (or if first time).
+  if (current->flag.recalculate) {
+    // If the previous block is accelerating check if it's too short to complete the full speed
+    // change then adjust the entry speed accordingly. Entry speeds have already been maximized.
+    if (previous->entry_speed_sqr < current->entry_speed_sqr) {
+      float new_entry_speed_sqr = max_allowable_speed_sqr(-previous->acceleration, previous->entry_speed_sqr, previous->millimeters);
+
+      // If true, previous block is full-acceleration and we can move the planned pointer forward.
       if (new_entry_speed_sqr < current->entry_speed_sqr) {
+        // Current entry speed limited by full acceleration from previous entry speed.
+        // Make sure entry speed not lower than minimum_planner_speed_sqr.
+        NOLESS(new_entry_speed_sqr, current->min_entry_speed_sqr);
+        current->entry_speed_sqr = new_entry_speed_sqr;
 
-        // Mark we need to recompute the trapezoidal shape, and do it now,
-        // so the stepper ISR does not consume the block before being recalculated
-        current->flag.recalculate = true;
-
-        // But there is an inherent race condition here, as the block maybe
-        // became BUSY, just before it was marked as RECALCULATE, so check
-        // if that is the case!
-        if (stepper.is_block_busy(current)) {
-          // Block became busy. Clear the RECALCULATE flag (no point in
-          //  recalculating BUSY blocks and don't set its speed, as it can't
-          //  be updated at this time.
-          current->flag.recalculate = false;
-        }
-        else {
-          // Block is not BUSY, we won the race against the Stepper ISR:
-
-          // Always <= max_entry_speed_sqr. Backward pass sets this.
-          current->entry_speed_sqr = new_entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass sets this.
-
-          // Set optimal plan pointer.
-          block_buffer_planned = block_index;
-        }
+        // Set optimal plan pointer.
+        block_buffer_planned = block_index;
+      }
+      else {
+        // Previous entry speed has been maximized.
+        block_buffer_planned = prev_block_index(block_index);
       }
     }
 
     // Any block set at its maximum entry speed also creates an optimal plan up to this
     // point in the buffer. When the plan is bracketed by either the beginning of the
     // buffer and a maximum entry speed or two maximum entry speeds, every block in between
     // cannot logically be further improved. Hence, we don't have to recompute them anymore.
     if (current->entry_speed_sqr == current->max_entry_speed_sqr)
       block_buffer_planned = block_index;
   }
@@ -1163,21 +1134,21 @@ void Planner::forward_pass() {
     // Perform the forward pass
     block = &block_buffer[block_index];
 
     // Only process movement blocks
     if (block->is_move()) {
       // If there's no previous block or the previous block is not
       // BUSY (thus, modifiable) run the forward_pass_kernel. Otherwise,
       // the previous block became BUSY, so assume the current block's
       // entry speed can't be altered (since that would also require
       // updating the exit speed of the previous block).
-      if (!previous || !stepper.is_block_busy(previous))
+      if (previous && !stepper.is_block_busy(previous))
         forward_pass_kernel(previous, block, block_index);
       previous = block;
     }
     // Advance to the previous
     block_index = next_block_index(block_index);
   }
 }
 
 /**
  * Recalculate the trapezoid speed profiles for all blocks in the plan
@@ -2559,23 +2530,27 @@ bool Planner::_populate_block(
       for (uint32_t dividend = block->steps.e << 1; dividend <= (block->step_event_count >> 2); dividend <<= 1)
         block->la_scaling++;
 
       #if ENABLED(LA_DEBUG)
         if (block->la_advance_rate >> block->la_scaling > 10000)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz: ", block->la_advance_rate);
       #endif
     }
   #endif
 
-  // The minimum possible speed is the average speed for
-  // the first / last step at current acceleration limit
+  // Formula for the average speed over a 1 step worth of distance if starting from zero and
+  // accelerating at the current limit. Since we can only change the speed every step this is a
+  // good lower limit for the entry and exit speeds. Note that for calculate_trapezoid_for_block()
+  // to work correctly, this must be accurately set and propagated.
   minimum_planner_speed_sqr = 0.5f * block->acceleration / steps_per_mm;
+  // Go straight to/from nominal speed if block->acceleration is too high for it.
+  NOMORE(minimum_planner_speed_sqr, sq(block->nominal_speed));
 
   float vmax_junction_sqr; // Initial limit on the segment entry velocity (mm/s)^2
 
   #if HAS_JUNCTION_DEVIATION
     /**
      * Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
      * Let a circle be tangent to both previous and current path line segments, where the junction
      * deviation is defined as the distance from the junction to the closest edge of the circle,
      * colinear with the circle center. The circular segment joining the two paths represents the
      * path of centripetal acceleration. Solve for max velocity based on max acceleration about the
@@ -2757,22 +2732,21 @@ bool Planner::_populate_block(
               NOMORE(vmax_junction_sqr, limit_sqr);
             }
 
           #endif // JD_HANDLE_SMALL_SEGMENTS
         }
       }
 
       // Get the lowest speed
       vmax_junction_sqr = _MIN(vmax_junction_sqr, sq(block->nominal_speed), sq(previous_nominal_speed));
     }
-    else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
-      vmax_junction_sqr = 0;
+    else vmax_junction_sqr = minimum_planner_speed_sqr;
 
     prev_unit_vec = unit_vec;
 
   #else // CLASSIC_JERK
 
     /**
      * Heavily modified. Originally adapted from Pr≈Ø≈°a firmware.
      * https://github.com/prusa3d/Prusa-Firmware
      */
     #if defined(TRAVEL_EXTRA_XYJERK) || ENABLED(LIN_ADVANCE)
@@ -2800,22 +2774,21 @@ bool Planner::_populate_block(
         // get E to nominal retract speed, the equation simplifies to an increase in max jerk.
         max_j.e += previous_advance_rate * previous_e_mm_per_step;
       }
       // Prepare for next segment.
       previous_advance_rate = block->la_advance_rate;
       previous_e_mm_per_step = mm_per_step[E_AXIS_N(extruder)];
     #endif
 
     xyze_float_t speed_diff = current_speed;
     float vmax_junction;
-    const bool start_from_zero = !moves_queued || UNEAR_ZERO(previous_nominal_speed);
-    if (start_from_zero) {
+    if (!moves_queued || UNEAR_ZERO(previous_nominal_speed)) {
       // Limited by a jerk to/from full halt.
       vmax_junction = block->nominal_speed;
     }
     else {
       // Compute the maximum velocity allowed at a joint of two successive segments.
 
       // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
       // Scale per-axis velocities for the same vmax_junction.
       if (block->nominal_speed < previous_nominal_speed) {
         vmax_junction = block->nominal_speed;
@@ -2831,42 +2804,34 @@ bool Planner::_populate_block(
 
     // Now limit the jerk in all axes.
     float v_factor = 1.0f;
     LOOP_LOGICAL_AXES(i) {
       // Jerk is the per-axis velocity difference.
       const float jerk = ABS(speed_diff[i]), maxj = max_j[i];
       if (jerk * v_factor > maxj) v_factor = maxj / jerk;
     }
     vmax_junction_sqr = sq(vmax_junction * v_factor);
 
-    if (start_from_zero) minimum_planner_speed_sqr = vmax_junction_sqr;
-
   #endif // CLASSIC_JERK
 
+  // High acceleration limits override low jerk/junction deviation limits (as fixing trapezoids
+  // or reducing acceleration introduces too much complexity and/or too much compute)
+  NOLESS(vmax_junction_sqr, minimum_planner_speed_sqr);
+
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed_sqr = vmax_junction_sqr;
-
-  // Initialize block entry speed. Compute based on deceleration to sqrt(minimum_planner_speed_sqr).
-  const float v_allowable_sqr = max_allowable_speed_sqr(-block->acceleration, minimum_planner_speed_sqr, block->millimeters);
-
-  // Start with the minimum allowed speed
+  // Set entry speed. The reverse and forward passes will optimize it later.
   block->entry_speed_sqr = minimum_planner_speed_sqr;
+  // Set min entry speed. Rarely it could be higher than the previous nominal speed but that's ok.
+  block->min_entry_speed_sqr = minimum_planner_speed_sqr;
 
-  // Initialize planner efficiency flags
-  // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
-  // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
-  // the current block and next block junction speeds are guaranteed to always be at their maximum
-  // junction speeds in deceleration and acceleration, respectively. This is due to how the current
-  // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
-  // the reverse and forward planners, the corresponding block junction speed will always be at the
-  // the maximum junction speed and may always be ignored for any speed reduction checks.
-  block->flag.set_nominal(sq(block->nominal_speed) <= v_allowable_sqr);
+  block->flag.recalculate = true;
 
   // Update previous path unit_vector and nominal speed
   previous_speed = current_speed;
   previous_nominal_speed = block->nominal_speed;
 
   position = target;  // Update the position
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     block->sdpos = recovery.command_sdpos();
     block->start_position = position_float.asLogical();

commit 4a5bd47b6a8d48f6c0045399e667f2c521faa213
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 11 13:40:29 2024 -0500

    üé® Apply MUL_TERN

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 37c344bfe7..ae3b9e50a0 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2385,28 +2385,26 @@ bool Planner::_populate_block(
   #if HAS_EXTRUDERS
   {
     current_speed.e = dist_mm.e * inverse_secs;
     #if HAS_MIXER_SYNC_CHANNEL
       // Move all mixing extruders at the specified rate
       if (mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)
         current_speed.e *= MIXING_STEPPERS;
     #endif
 
     const feedRate_t cs = ABS(current_speed.e),
-                 max_fr = settings.max_feedrate_mm_s[E_AXIS_N(extruder)]
-                          * TERN(HAS_MIXER_SYNC_CHANNEL, MIXING_STEPPERS, 1);
+                 max_fr = MUL_TERN(HAS_MIXER_SYNC_CHANNEL, settings.max_feedrate_mm_s[E_AXIS_N(extruder)], MIXING_STEPPERS);
 
-    if (cs > max_fr) NOMORE(speed_factor, max_fr / cs); //respect max feedrate on any movement (doesn't matter if E axes only or not)
+    if (cs > max_fr) NOMORE(speed_factor, max_fr / cs); // Respect max feedrate on any move (travel and print)
 
     #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
-      const feedRate_t max_vfr = volumetric_extruder_feedrate_limit[extruder]
-                                 * TERN(HAS_MIXER_SYNC_CHANNEL, MIXING_STEPPERS, 1);
+      const feedRate_t max_vfr = MUL_TERN(HAS_MIXER_SYNC_CHANNEL, volumetric_extruder_feedrate_limit[extruder], MIXING_STEPPERS);
 
       // TODO: Doesn't work properly for joined segments. Set MIN_STEPS_PER_SEGMENT 1 as workaround.
 
       if (block->steps.a || block->steps.b || block->steps.c) {
 
         if (max_vfr > 0 && cs > max_vfr) {
           NOMORE(speed_factor, max_vfr / cs); // respect volumetric extruder limit (if any)
           /* <-- add a slash to enable
           SERIAL_ECHOPGM("volumetric extruder limit enforced: ", (cs * CIRCLE_AREA(filament_size[extruder] * 0.5f)));
           SERIAL_ECHOPGM(" mm^3/s (", cs);

commit 1da947f54806437fdff84adfdc06f48d2e3d60a3
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Thu May 9 23:57:23 2024 +0200

    ‚ö°Ô∏è FT_MOTION : Core and other refinements (#26720)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: Ulendo Alex <alex@ulendo.io>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c21230f662..37c344bfe7 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1966,46 +1966,49 @@ bool Planner::_populate_block(
             dist.e = 0; // no difference
             SERIAL_ECHO_MSG(STR_ERR_LONG_EXTRUDE_STOP);
           }
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   // Compute direction bit-mask for this block
   AxisBits dm;
-  #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
-    dm.hx = (dist.a > 0);                       // Save the toolhead's true direction in X
-    dm.hy = (dist.b > 0);                       // ...and Y
-    TERN_(HAS_Z_AXIS, dm.z = (dist.c > 0));
+  #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
+    dm.hx = (dist.a > 0);                       // True direction in X
+  #endif
+  #if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY, MARKFORGED_YX)
+    dm.hy = (dist.b > 0);                       // True direction in Y
+  #endif
+  #if ANY(CORE_IS_XZ, CORE_IS_YZ)
+    dm.hz = (dist.c > 0);                       // True direction in Z
   #endif
   #if CORE_IS_XY
-    dm.a = (dist.a + dist.b > 0);               // Motor A direction
-    dm.b = (CORESIGN(dist.a - dist.b) > 0);     // Motor B direction
+    dm.a  = (dist.a + dist.b > 0);              // Motor A direction
+    dm.b  = (CORESIGN(dist.a - dist.b) > 0);    // Motor B direction
+    TERN_(HAS_Z_AXIS, dm.z = (dist.c > 0));     // Axis  Z direction
   #elif CORE_IS_XZ
-    dm.hx = (dist.a > 0);                       // Save the toolhead's true direction in X
-    dm.y  = (dist.b > 0);
-    dm.hz = (dist.c > 0);                       // ...and Z
     dm.a  = (dist.a + dist.c > 0);              // Motor A direction
+    dm.y  = (dist.b > 0);                       // Axis  Y direction
     dm.c  = (CORESIGN(dist.a - dist.c) > 0);    // Motor C direction
   #elif CORE_IS_YZ
-    dm.x  = (dist.a > 0);
-    dm.hy = (dist.b > 0);                       // Save the toolhead's true direction in Y
-    dm.hz = (dist.c > 0);                       // ...and Z
+    dm.x  = (dist.a > 0);                       // Axis  X direction
     dm.b  = (dist.b + dist.c > 0);              // Motor B direction
     dm.c  = (CORESIGN(dist.b - dist.c) > 0);    // Motor C direction
   #elif ENABLED(MARKFORGED_XY)
     dm.a = (dist.a TERN(MARKFORGED_INVERSE, -, +) dist.b > 0); // Motor A direction
     dm.b = (dist.b > 0);                        // Motor B direction
+    TERN_(HAS_Z_AXIS, dm.z = (dist.c > 0));     // Axis  Z direction
   #elif ENABLED(MARKFORGED_YX)
     dm.a = (dist.a > 0);                        // Motor A direction
     dm.b = (dist.b TERN(MARKFORGED_INVERSE, -, +) dist.a > 0); // Motor B direction
+    TERN_(HAS_Z_AXIS, dm.z = (dist.c > 0));     // Axis  Z direction
   #else
     XYZ_CODE(
       dm.x = (dist.a > 0),
       dm.y = (dist.b > 0),
       dm.z = (dist.c > 0)
     );
   #endif
 
   SECONDARY_AXIS_CODE(
     dm.i = (dist.i > 0), dm.j = (dist.j > 0), dm.k = (dist.k > 0),
@@ -2888,24 +2891,26 @@ void Planner::buffer_sync_block(const BlockFlagBit sync_flag/*=BLOCK_BIT_SYNC_PO
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Clear block
   block->reset();
   block->flag.apply(sync_flag);
 
   block->position = position;
+
   #if ENABLED(BACKLASH_COMPENSATION)
     LOOP_NUM_AXES(axis) block->position[axis] += backlash.get_applied_steps((AxisEnum)axis);
   #endif
-  #if ALL(HAS_FAN, LASER_SYNCHRONOUS_M106_M107)
+
+  #if ENABLED(LASER_SYNCHRONOUS_M106_M107)
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   /**
    * M3-based power setting can be processed inline with a laser power sync block.
    * During active moves cutter.power is processed immediately, otherwise on the next move.
    */
   TERN_(LASER_POWER_SYNC, block->laser.power = cutter.power);
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
@@ -3220,20 +3225,24 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s
 
 #endif // DIRECT_STEPPING
 
 /**
  * Directly set the planner ABCE position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * The provided ABCE position is in machine units.
  */
 void Planner::set_machine_position_mm(const abce_pos_t &abce) {
+
+  // When FT Motion is enabled, call synchronize() here instead of generating a sync block
+  if (TERN0(FT_MOTION, ftMotion.cfg.mode)) synchronize();
+
   TERN_(DISTINCT_E_FACTORS, last_extruder = active_extruder);
   TERN_(HAS_POSITION_FLOAT, position_float = abce);
   position.set(
     LOGICAL_AXIS_LIST(
       LROUND(abce.e * settings.axis_steps_per_mm[E_AXIS_N(active_extruder)]),
       LROUND(abce.a * settings.axis_steps_per_mm[A_AXIS]),
       LROUND(abce.b * settings.axis_steps_per_mm[B_AXIS]),
       LROUND(abce.c * settings.axis_steps_per_mm[C_AXIS]),
       LROUND(abce.i * settings.axis_steps_per_mm[I_AXIS]),
       LROUND(abce.j * settings.axis_steps_per_mm[J_AXIS]),

commit c91771a51e32dd490b1298fa2eef3af67f033553
Author: Vovodroid <vovodroid@users.noreply.github.com>
Date:   Sun Apr 7 08:41:01 2024 +0300

    ü©πDisable nonlinear extrusion on unretract (#26824)
    
    * Fixes disable NLE on unretract #26808, which reported blobs at the start of lines during unretract.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 8f7c4ceb72..c21230f662 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2455,25 +2455,21 @@ bool Planner::_populate_block(
     block->nominal_rate *= speed_factor;
     block->nominal_speed *= speed_factor;
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
   #if ENABLED(LIN_ADVANCE)
     bool use_advance_lead = false;
   #endif
-  if (true NUM_AXIS_GANG(
-      && !block->steps.a, && !block->steps.b, && !block->steps.c,
-      && !block->steps.i, && !block->steps.j, && !block->steps.k,
-      && !block->steps.u, && !block->steps.v, && !block->steps.w)
-  ) {                                                             // Is this a retract / recover move?
+  if (!ANY_AXIS_MOVES(block)) {                                   // Is this a retract / recover move?
     accel = CEIL(settings.retract_acceleration * steps_per_mm);   // Convert to: acceleration steps/sec^2
   }
   else {
     #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
         const uint32_t max_possible = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count / block->steps[AXIS]; \
         NOMORE(accel, max_possible); \
       } \
     }while(0)
 

commit c8d51c27234bcb2b1419d238e8751593d855dadb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Mar 2 04:16:39 2024 +0100

    üö∏ Enable G92.9 with rotational axes (#26174)
    
    - Supporting axes that can rotate forever.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 0ace6e32ce..8f7c4ceb72 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2072,25 +2072,25 @@ bool Planner::_populate_block(
     #elif IS_SCARA
       ABS(dist.a), ABS(dist.b), ABS(dist.c)
     #else // default non-h-bot planning
       ABS(dist.a), ABS(dist.b), ABS(dist.c)
     #endif
     , ABS(dist.i), ABS(dist.j), ABS(dist.k), ABS(dist.u), ABS(dist.v), ABS(dist.w)
   ));
 
   /**
    * This part of the code calculates the total length of the movement.
-   * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
-   * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
-   * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
-   * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
-   * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
+   * For cartesian bots, the distance along the X axis equals the X_AXIS joint displacement and same holds true for Y_AXIS.
+   * But for geometries like CORE_XY that is not true. For these machines we need to create 2 additional variables, named X_HEAD and Y_HEAD, to store the displacent of the head along the X and Y axes in a cartesian coordinate system.
+   * The displacement of the head along the axes of the cartesian coordinate system has to be calculated from "X_AXIS" and "Y_AXIS" (should be renamed to A_JOINT and B_JOINT)
+   * displacements in joints space using forward kinematics (A=X+Y and B=X-Y in the case of CORE_XY).
+   * Next we can calculate the total movement length and apply the desired speed.
    */
   struct DistanceMM : abce_float_t {
     #if ANY(IS_CORE, MARKFORGED_XY, MARKFORGED_YX)
       struct { float x, y, z; } head;
     #endif
   } dist_mm;
 
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
     dist_mm.head.x = dist.a * mm_per_step[A_AXIS];
     dist_mm.head.y = dist.b * mm_per_step[B_AXIS];
@@ -2301,20 +2301,24 @@ bool Planner::_populate_block(
   else
     NOLESS(fr_mm_s, settings.min_travel_feedrate_mm_s);
 
   const float inverse_millimeters = 1.0f / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate inverse time for this move. No divide by zero due to previous checks.
   // Example: At 120mm/s a 60mm move involving XYZ axes takes 0.5s. So this will give 2.0.
   // Example 2: At 120¬∞/s a 60¬∞ move involving only rotational axes takes 0.5s. So this will give 2.0.
   float inverse_secs = inverse_millimeters * (
     #if ALL(HAS_ROTATIONAL_AXES, INCH_MODE_SUPPORT)
+      /**
+       * Workaround for premature feedrate conversion
+       * from in/s to mm/s by get_distance_from_command.
+       */
       cartesian_move ? fr_mm_s : LINEAR_UNIT(fr_mm_s)
     #else
       fr_mm_s
     #endif
   );
 
   // Get the number of non busy movements in queue (non busy means that they can be altered)
   const uint8_t moves_queued = nonbusy_movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill

commit da96607b65ecc910178413d6979c128add9d098e
Author: Vovodroid <vovodroid@users.noreply.github.com>
Date:   Sat Jan 20 00:38:25 2024 +0200

    üîß Adjust DEFAULT_EJERK settings (#26665)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 6371a960a7..0ace6e32ce 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -3379,22 +3379,26 @@ void Planner::set_max_feedrate(const AxisEnum axis, float inMaxFeedrateMMS) {
    * The value may be limited with warning feedback, if configured.
    *
    * This hard limit is applied (to the block start speed) as the block is being added to the planner queue.
    */
   void Planner::set_max_jerk(const AxisEnum axis, float inMaxJerkMMS) {
     #if ENABLED(LIMITED_JERK_EDITING)
       constexpr xyze_float_t max_jerk_edit =
         #ifdef MAX_JERK_EDIT_VALUES
           MAX_JERK_EDIT_VALUES
         #else
-          { (DEFAULT_XJERK) * 2, (DEFAULT_YJERK) * 2,
-            (DEFAULT_ZJERK) * 2, (DEFAULT_EJERK) * 2 }
+          LOGICAL_AXIS_ARRAY(
+            (DEFAULT_EJERK) * 2,
+            (DEFAULT_XJERK) * 2, (DEFAULT_YJERK) * 2, (DEFAULT_ZJERK) * 2,
+            (DEFAULT_IJERK) * 2, (DEFAULT_JJERK) * 2, (DEFAULT_KJERK) * 2,
+            (DEFAULT_UJERK) * 2, (DEFAULT_VJERK) * 2, (DEFAULT_WJERK) * 2
+          )
         #endif
       ;
       limit_and_warn(inMaxJerkMMS, axis, F("Jerk"), max_jerk_edit);
     #endif
     max_jerk[axis] = inMaxJerkMMS;
   }
 
 #endif
 
 #if HAS_WIRED_LCD

commit 1f1ca34ea6c37d8d22808f3fb25992776abfe4f2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 15 22:22:08 2024 -0600

    üßë‚Äçüíª Tweak limit_and_warn

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 14cc06419e..6371a960a7 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -3313,49 +3313,45 @@ void Planner::refresh_acceleration_rates() {
  */
 void Planner::refresh_positioning() {
   #if ENABLED(EDITABLE_STEPS_PER_UNIT)
     LOOP_DISTINCT_AXES(i) mm_per_step[i] = 1.0f / settings.axis_steps_per_mm[i];
   #endif
   set_position_mm(current_position);
   refresh_acceleration_rates();
 }
 
 // Apply limits to a variable and give a warning if the value was out of range
-inline void limit_and_warn(float &val, const AxisEnum axis, PGM_P const setting_name, const xyze_float_t &max_limit) {
+inline void limit_and_warn(float &val, const AxisEnum axis, FSTR_P const setting_name, const xyze_float_t &max_limit) {
   const uint8_t lim_axis = TERN_(HAS_EXTRUDERS, axis > E_AXIS ? E_AXIS :) axis;
   const float before = val;
   LIMIT(val, 0.1f, max_limit[lim_axis]);
-  if (before != val) {
-    SERIAL_CHAR(AXIS_CHAR(lim_axis));
-    SERIAL_ECHOPGM(" Max ");
-    SERIAL_ECHOPGM_P(setting_name);
-    SERIAL_ECHOLNPGM(" limited to ", val);
-  }
+  if (before != val)
+    SERIAL_ECHOLN(C(AXIS_CHAR(lim_axis)), F(" Max "), setting_name, F(" limited to "), val);
 }
 
 /**
  * For the specified 'axis' set the Maximum Acceleration to the given value (mm/s^2)
  * The value may be limited with warning feedback, if configured.
  * Calls refresh_acceleration_rates to precalculate planner terms in steps.
  *
  * This hard limit is applied as a block is being added to the planner queue.
  */
 void Planner::set_max_acceleration(const AxisEnum axis, float inMaxAccelMMS2) {
   #if ENABLED(LIMITED_MAX_ACCEL_EDITING)
     #ifdef MAX_ACCEL_EDIT_VALUES
       constexpr xyze_float_t max_accel_edit = MAX_ACCEL_EDIT_VALUES;
       const xyze_float_t &max_acc_edit_scaled = max_accel_edit;
     #else
       constexpr xyze_float_t max_accel_edit = DEFAULT_MAX_ACCELERATION;
       const xyze_float_t max_acc_edit_scaled = max_accel_edit * 2;
     #endif
-    limit_and_warn(inMaxAccelMMS2, axis, PSTR("Acceleration"), max_acc_edit_scaled);
+    limit_and_warn(inMaxAccelMMS2, axis, F("Acceleration"), max_acc_edit_scaled);
   #endif
   settings.max_acceleration_mm_per_s2[axis] = inMaxAccelMMS2;
 
   // Update steps per s2 to agree with the units per s2 (since they are used in the planner)
   refresh_acceleration_rates();
 }
 
 /**
  * For the specified 'axis' set the Maximum Feedrate to the given value (mm/s)
  * The value may be limited with warning feedback, if configured.
@@ -3364,21 +3360,21 @@ void Planner::set_max_acceleration(const AxisEnum axis, float inMaxAccelMMS2) {
  */
 void Planner::set_max_feedrate(const AxisEnum axis, float inMaxFeedrateMMS) {
   #if ENABLED(LIMITED_MAX_FR_EDITING)
     #ifdef MAX_FEEDRATE_EDIT_VALUES
       constexpr xyze_float_t max_fr_edit = MAX_FEEDRATE_EDIT_VALUES;
       const xyze_float_t &max_fr_edit_scaled = max_fr_edit;
     #else
       constexpr xyze_float_t max_fr_edit = DEFAULT_MAX_FEEDRATE;
       const xyze_float_t max_fr_edit_scaled = max_fr_edit * 2;
     #endif
-    limit_and_warn(inMaxFeedrateMMS, axis, PSTR("Feedrate"), max_fr_edit_scaled);
+    limit_and_warn(inMaxFeedrateMMS, axis, F("Feedrate"), max_fr_edit_scaled);
   #endif
   settings.max_feedrate_mm_s[axis] = inMaxFeedrateMMS;
 }
 
 #if ENABLED(CLASSIC_JERK)
 
   /**
    * For the specified 'axis' set the Maximum Jerk (instant change) to the given value (mm/s)
    * The value may be limited with warning feedback, if configured.
    *
@@ -3387,21 +3383,21 @@ void Planner::set_max_feedrate(const AxisEnum axis, float inMaxFeedrateMMS) {
   void Planner::set_max_jerk(const AxisEnum axis, float inMaxJerkMMS) {
     #if ENABLED(LIMITED_JERK_EDITING)
       constexpr xyze_float_t max_jerk_edit =
         #ifdef MAX_JERK_EDIT_VALUES
           MAX_JERK_EDIT_VALUES
         #else
           { (DEFAULT_XJERK) * 2, (DEFAULT_YJERK) * 2,
             (DEFAULT_ZJERK) * 2, (DEFAULT_EJERK) * 2 }
         #endif
       ;
-      limit_and_warn(inMaxJerkMMS, axis, PSTR("Jerk"), max_jerk_edit);
+      limit_and_warn(inMaxJerkMMS, axis, F("Jerk"), max_jerk_edit);
     #endif
     max_jerk[axis] = inMaxJerkMMS;
   }
 
 #endif
 
 #if HAS_WIRED_LCD
 
   uint16_t Planner::block_buffer_runtime() {
     #ifdef __AVR__

commit 8d4ab15748eb9c6bcbc1dd30c1b8f51d2cc94dc5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 15 21:36:15 2024 -0600

    üßë‚Äçüíª Tweak planner debug

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 6b27971d9d..14cc06419e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1898,27 +1898,27 @@ bool Planner::_populate_block(
   OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
   , feedRate_t fr_mm_s, const uint8_t extruder, const PlannerHints &hints
   , float &minimum_planner_speed_sqr
 ) {
   xyze_long_t dist = target - position;
 
   /* <-- add a slash to enable
     SERIAL_ECHOLNPGM(
       "  _populate_block FR:", fr_mm_s,
       #if HAS_X_AXIS
-        " A:", target.a, " (", dist.a, " steps)"
+        " " STR_A ":", target.a, " (", dist.a, " steps)"
       #endif
       #if HAS_Y_AXIS
-        " B:", target.b, " (", dist.b, " steps)"
+        " " STR_B ":", target.b, " (", dist.b, " steps)"
       #endif
       #if HAS_Z_AXIS
-        " C:", target.c, " (", dist.c, " steps)"
+        " " STR_C ":", target.c, " (", dist.c, " steps)"
       #endif
       #if HAS_I_AXIS
         " " STR_I ":", target.i, " (", dist.i, " steps)"
       #endif
       #if HAS_J_AXIS
         " " STR_J ":", target.j, " (", dist.j, " steps)"
       #endif
       #if HAS_K_AXIS
         " " STR_K ":", target.k, " (", dist.k, " steps)"
       #endif

commit 854f3315af645775e7b0aa39bd05db66187bcc38
Author: plampix <plampix@users.noreply.github.com>
Date:   Wed Jan 10 07:33:54 2024 +0100

    ‚ú® EDITABLE_STEPS_PER_UNIT (#26618)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 0c6027bfde..6b27971d9d 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -126,35 +126,39 @@ Planner planner;
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head,    // Index of the next block to be pushed
                  Planner::block_buffer_nonbusy, // Index of the first non-busy block
                  Planner::block_buffer_planned, // Index of the optimally planned block
                  Planner::block_buffer_tail;    // Index of the busy block, if any
 uint16_t Planner::cleaning_buffer_counter;      // A counter to disable queuing of blocks
 uint8_t Planner::delay_before_delivering;       // Delay block delivery so initial blocks in an empty queue may merge
 
+#if ENABLED(EDITABLE_STEPS_PER_UNIT)
+  float Planner::mm_per_step[DISTINCT_AXES];    // (mm) Millimeters per step
+#else
+  constexpr float PlannerSettings::axis_steps_per_mm[DISTINCT_AXES];
+  constexpr float Planner::mm_per_step[DISTINCT_AXES];
+#endif
 planner_settings_t Planner::settings;           // Initialized by settings.load()
 
 /**
  * Set up inline block variables
  * Set laser_power_floor based on SPEED_POWER_MIN to pevent a zero power output state with LASER_POWER_TRAP
  */
 #if ENABLED(LASER_FEATURE)
   laser_state_t Planner::laser_inline;          // Current state for blocks
   const uint8_t laser_power_floor = cutter.pct_to_ocr(SPEED_POWER_MIN);
 #endif
 
 uint32_t Planner::max_acceleration_steps_per_s2[DISTINCT_AXES]; // (steps/s^2) Derived from mm_per_s2
 
-float Planner::mm_per_step[DISTINCT_AXES];      // (mm) Millimeters per step
-
 #if HAS_JUNCTION_DEVIATION
   float Planner::junction_deviation_mm;         // (mm) M205 J
   #if HAS_LINEAR_E_JERK
     float Planner::max_e_jerk[DISTINCT_E];      // Calculated from junction_deviation_mm
   #endif
 #else // CLASSIC_JERK
   TERN(HAS_LINEAR_E_JERK, xyz_pos_t, xyze_pos_t) Planner::max_jerk;
 #endif
 
 #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
@@ -3301,21 +3305,23 @@ void Planner::refresh_acceleration_rates() {
   }
   acceleration_long_cutoff = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
   TERN_(HAS_LINEAR_E_JERK, recalculate_max_e_jerk());
 }
 
 /**
  * Recalculate 'position' and 'mm_per_step'.
  * Must be called whenever settings.axis_steps_per_mm changes!
  */
 void Planner::refresh_positioning() {
-  LOOP_DISTINCT_AXES(i) mm_per_step[i] = 1.0f / settings.axis_steps_per_mm[i];
+  #if ENABLED(EDITABLE_STEPS_PER_UNIT)
+    LOOP_DISTINCT_AXES(i) mm_per_step[i] = 1.0f / settings.axis_steps_per_mm[i];
+  #endif
   set_position_mm(current_position);
   refresh_acceleration_rates();
 }
 
 // Apply limits to a variable and give a warning if the value was out of range
 inline void limit_and_warn(float &val, const AxisEnum axis, PGM_P const setting_name, const xyze_float_t &max_limit) {
   const uint8_t lim_axis = TERN_(HAS_EXTRUDERS, axis > E_AXIS ? E_AXIS :) axis;
   const float before = val;
   LIMIT(val, 0.1f, max_limit[lim_axis]);
   if (before != val) {

commit 3029a6b1aa4c436cdda352e2add5cd421beaf104
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Sat Dec 23 09:45:37 2023 +0200

    ü©π Jerk correction for LIN_ADVANCE + CLASSIC_JERK (#26551)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index f7ab42ad81..0c6027bfde 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2483,23 +2483,23 @@ bool Planner::_populate_block(
       // Linear advance is currently not ready for HAS_I_AXIS
       #define MAX_E_JERK(N) TERN(HAS_LINEAR_E_JERK, max_e_jerk[E_INDEX_N(N)], max_jerk.e)
 
       /**
        * Use LIN_ADVANCE for blocks if all these are true:
        *
        * esteps                       : This is a print move, because we checked for A, B, C steps before.
        *
        * extruder_advance_K[extruder] : There is an advance factor set for this extruder.
        *
-       * dist.e > 0                   : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
+       * dm.e                         : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
        */
-      use_advance_lead = esteps && extruder_advance_K[E_INDEX_N(extruder)] && dist.e > 0;
+      use_advance_lead = esteps && extruder_advance_K[E_INDEX_N(extruder)] && dm.e;
 
       if (use_advance_lead) {
         float e_D_ratio = (target_float.e - position_float.e) /
           TERN(IS_KINEMATIC, block->millimeters,
             SQRT(sq(target_float.x - position_float.x)
                + sq(target_float.y - position_float.y)
                + sq(target_float.z - position_float.z))
           );
 
         // Check for unusual high e_D ratio to detect if a retract move was combined with the last print move due to min. steps per segment. Never execute this with advance!
@@ -2763,67 +2763,84 @@ bool Planner::_populate_block(
       vmax_junction_sqr = 0;
 
     prev_unit_vec = unit_vec;
 
   #else // CLASSIC_JERK
 
     /**
      * Heavily modified. Originally adapted from Pr≈Ø≈°a firmware.
      * https://github.com/prusa3d/Prusa-Firmware
      */
-    #ifndef TRAVEL_EXTRA_XYJERK
-      #define TRAVEL_EXTRA_XYJERK 0.0f
+    #if defined(TRAVEL_EXTRA_XYJERK) || ENABLED(LIN_ADVANCE)
+      xyze_float_t max_j = max_jerk;
+    #else
+      const xyze_float_t &max_j = max_jerk;
     #endif
-    const float extra_xyjerk = TERN0(HAS_EXTRUDERS, dist.e <= 0) ? TRAVEL_EXTRA_XYJERK : 0.0f;
 
-    if (!moves_queued || UNEAR_ZERO(previous_nominal_speed)) {
-      // Compute "safe" speed, limited by a jerk to/from full halt.
+    #ifdef TRAVEL_EXTRA_XYJERK
+      if (dist.e <= 0) {
+        max_j.x += TRAVEL_EXTRA_XYJERK;
+        max_j.y += TRAVEL_EXTRA_XYJERK;
+      }
+    #endif
 
-      float v_factor = 1.0f;
-      LOOP_LOGICAL_AXES(i) {
-        const float jerk = ABS(current_speed[i]),   // Starting from zero, change in speed for this axis
-                    maxj = max_jerk[i] + (i == X_AXIS || i == Y_AXIS ? extra_xyjerk : 0.0f); // The max jerk setting for this axis
-        if (jerk * v_factor > maxj) v_factor = maxj / jerk;
+    #if ENABLED(LIN_ADVANCE)
+      // Advance affects E_AXIS speed and therefore jerk. Add a speed correction whenever
+      // LA is turned OFF. No correction is applied when LA is turned ON (because it didn't
+      // perform well; it takes more time/effort to push/melt filament than the reverse).
+      static uint32_t previous_advance_rate;
+      static float previous_e_mm_per_step;
+      if (dist.e < 0 && previous_advance_rate) {
+        // Retract move after a segment with LA that ended with an E speed decrease.
+        // Correct for this to allow a faster junction speed. Since the decrease always helps to
+        // get E to nominal retract speed, the equation simplifies to an increase in max jerk.
+        max_j.e += previous_advance_rate * previous_e_mm_per_step;
       }
-      vmax_junction_sqr = sq(block->nominal_speed * v_factor);
-      NOLESS(minimum_planner_speed_sqr, vmax_junction_sqr);
+      // Prepare for next segment.
+      previous_advance_rate = block->la_advance_rate;
+      previous_e_mm_per_step = mm_per_step[E_AXIS_N(extruder)];
+    #endif
+
+    xyze_float_t speed_diff = current_speed;
+    float vmax_junction;
+    const bool start_from_zero = !moves_queued || UNEAR_ZERO(previous_nominal_speed);
+    if (start_from_zero) {
+      // Limited by a jerk to/from full halt.
+      vmax_junction = block->nominal_speed;
     }
     else {
       // Compute the maximum velocity allowed at a joint of two successive segments.
 
       // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
-      float vmax_junction, previous_speed_factor, current_speed_factor;
+      // Scale per-axis velocities for the same vmax_junction.
       if (block->nominal_speed < previous_nominal_speed) {
         vmax_junction = block->nominal_speed;
-        previous_speed_factor = vmax_junction / previous_nominal_speed;
-        current_speed_factor = 1.0f;
+        const float previous_scale = vmax_junction / previous_nominal_speed;
+        LOOP_LOGICAL_AXES(i) speed_diff[i] -= previous_speed[i] * previous_scale;
       }
       else {
         vmax_junction = previous_nominal_speed;
-        previous_speed_factor = 1.0f;
-        current_speed_factor = vmax_junction / block->nominal_speed;
+        const float current_scale = vmax_junction / block->nominal_speed;
+        LOOP_LOGICAL_AXES(i) speed_diff[i] = speed_diff[i] * current_scale - previous_speed[i];
       }
+    }
 
-      // Now limit the jerk in all axes.
-      float v_factor = 1.0f;
-      LOOP_LOGICAL_AXES(i) {
-        // Scale per-axis velocities for the same vmax_junction.
-        const float v_exit = previous_speed[i] * previous_speed_factor,
-                    v_entry = current_speed[i] * current_speed_factor;
-
-        // Jerk is the per-axis velocity difference.
-        const float jerk = ABS(v_exit - v_entry),
-                    maxj = max_jerk[i] + (i == X_AXIS || i == Y_AXIS ? extra_xyjerk : 0.0f);
-        if (jerk * v_factor > maxj) v_factor = maxj / jerk;
-      }
-      vmax_junction_sqr = sq(vmax_junction * v_factor);
+    // Now limit the jerk in all axes.
+    float v_factor = 1.0f;
+    LOOP_LOGICAL_AXES(i) {
+      // Jerk is the per-axis velocity difference.
+      const float jerk = ABS(speed_diff[i]), maxj = max_j[i];
+      if (jerk * v_factor > maxj) v_factor = maxj / jerk;
     }
+    vmax_junction_sqr = sq(vmax_junction * v_factor);
+
+    if (start_from_zero) minimum_planner_speed_sqr = vmax_junction_sqr;
 
   #endif // CLASSIC_JERK
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed_sqr = vmax_junction_sqr;
 
   // Initialize block entry speed. Compute based on deceleration to sqrt(minimum_planner_speed_sqr).
   const float v_allowable_sqr = max_allowable_speed_sqr(-block->acceleration, minimum_planner_speed_sqr, block->millimeters);
 
   // Start with the minimum allowed speed

commit 2c5468ce333cd4a8c6ddfde8d4ad66d8417f32bd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Dec 21 22:34:19 2023 -0600

    üé® Planner indent

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 64c47301f5..f7ab42ad81 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -250,25 +250,29 @@ float Planner::previous_nominal_speed;
 /**
  * Class and Instance Methods
  */
 
 Planner::Planner() { init(); }
 
 void Planner::init() {
   position.reset();
   TERN_(HAS_POSITION_FLOAT, position_float.reset());
   TERN_(IS_KINEMATIC, position_cart.reset());
+
   previous_speed.reset();
   previous_nominal_speed = 0;
+
   TERN_(ABL_PLANAR, bed_level_matrix.set_to_identity());
+
   clear_block_buffer();
   delay_before_delivering = 0;
+
   #if ENABLED(DIRECT_STEPPING)
     last_page_step_rate = 0;
     last_page_dir.reset();
   #endif
 }
 
 #if ENABLED(S_CURVE_ACCELERATION)
   #ifdef __AVR__
     /**
      * This routine returns 0x1000000 / d, getting the inverse as fast as possible.
@@ -1963,37 +1967,35 @@ bool Planner::_populate_block(
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   // Compute direction bit-mask for this block
   AxisBits dm;
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
     dm.hx = (dist.a > 0);                       // Save the toolhead's true direction in X
     dm.hy = (dist.b > 0);                       // ...and Y
     TERN_(HAS_Z_AXIS, dm.z = (dist.c > 0));
   #endif
-  #if IS_CORE
-    #if CORE_IS_XY
-      dm.a = (dist.a + dist.b > 0);             // Motor A direction
-      dm.b = (CORESIGN(dist.a - dist.b) > 0);   // Motor B direction
-    #elif CORE_IS_XZ
-      dm.hx = (dist.a > 0);                     // Save the toolhead's true direction in X
-      dm.y  = (dist.b > 0);
-      dm.hz = (dist.c > 0);                     // ...and Z
-      dm.a  = (dist.a + dist.c > 0);            // Motor A direction
-      dm.c  = (CORESIGN(dist.a - dist.c) > 0);  // Motor C direction
-    #elif CORE_IS_YZ
-      dm.x  = (dist.a > 0);
-      dm.hy = (dist.b > 0);                     // Save the toolhead's true direction in Y
-      dm.hz = (dist.c > 0);                     // ...and Z
-      dm.b  = (dist.b + dist.c > 0);            // Motor B direction
-      dm.c  = (CORESIGN(dist.b - dist.c) > 0);  // Motor C direction
-    #endif
+  #if CORE_IS_XY
+    dm.a = (dist.a + dist.b > 0);               // Motor A direction
+    dm.b = (CORESIGN(dist.a - dist.b) > 0);     // Motor B direction
+  #elif CORE_IS_XZ
+    dm.hx = (dist.a > 0);                       // Save the toolhead's true direction in X
+    dm.y  = (dist.b > 0);
+    dm.hz = (dist.c > 0);                       // ...and Z
+    dm.a  = (dist.a + dist.c > 0);              // Motor A direction
+    dm.c  = (CORESIGN(dist.a - dist.c) > 0);    // Motor C direction
+  #elif CORE_IS_YZ
+    dm.x  = (dist.a > 0);
+    dm.hy = (dist.b > 0);                       // Save the toolhead's true direction in Y
+    dm.hz = (dist.c > 0);                       // ...and Z
+    dm.b  = (dist.b + dist.c > 0);              // Motor B direction
+    dm.c  = (CORESIGN(dist.b - dist.c) > 0);    // Motor C direction
   #elif ENABLED(MARKFORGED_XY)
     dm.a = (dist.a TERN(MARKFORGED_INVERSE, -, +) dist.b > 0); // Motor A direction
     dm.b = (dist.b > 0);                        // Motor B direction
   #elif ENABLED(MARKFORGED_YX)
     dm.a = (dist.a > 0);                        // Motor A direction
     dm.b = (dist.b TERN(MARKFORGED_INVERSE, -, +) dist.a > 0); // Motor B direction
   #else
     XYZ_CODE(
       dm.x = (dist.a > 0),
       dm.y = (dist.b > 0),
@@ -2083,37 +2085,35 @@ bool Planner::_populate_block(
     #if ANY(IS_CORE, MARKFORGED_XY, MARKFORGED_YX)
       struct { float x, y, z; } head;
     #endif
   } dist_mm;
 
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
     dist_mm.head.x = dist.a * mm_per_step[A_AXIS];
     dist_mm.head.y = dist.b * mm_per_step[B_AXIS];
     TERN_(HAS_Z_AXIS, dist_mm.z = dist.c * mm_per_step[Z_AXIS]);
   #endif
-  #if IS_CORE
-    #if CORE_IS_XY
-      dist_mm.a      = (dist.a + dist.b) * mm_per_step[A_AXIS];
-      dist_mm.b      = CORESIGN(dist.a - dist.b) * mm_per_step[B_AXIS];
-    #elif CORE_IS_XZ
-      dist_mm.head.x = dist.a * mm_per_step[A_AXIS];
-      dist_mm.y      = dist.b * mm_per_step[Y_AXIS];
-      dist_mm.head.z = dist.c * mm_per_step[C_AXIS];
-      dist_mm.a      = (dist.a + dist.c) * mm_per_step[A_AXIS];
-      dist_mm.c      = CORESIGN(dist.a - dist.c) * mm_per_step[C_AXIS];
-    #elif CORE_IS_YZ
-      dist_mm.x      = dist.a * mm_per_step[X_AXIS];
-      dist_mm.head.y = dist.b * mm_per_step[B_AXIS];
-      dist_mm.head.z = dist.c * mm_per_step[C_AXIS];
-      dist_mm.b      = (dist.b + dist.c) * mm_per_step[B_AXIS];
-      dist_mm.c      = CORESIGN(dist.b - dist.c) * mm_per_step[C_AXIS];
-    #endif
+  #if CORE_IS_XY
+    dist_mm.a      = (dist.a + dist.b) * mm_per_step[A_AXIS];
+    dist_mm.b      = CORESIGN(dist.a - dist.b) * mm_per_step[B_AXIS];
+  #elif CORE_IS_XZ
+    dist_mm.head.x = dist.a * mm_per_step[A_AXIS];
+    dist_mm.y      = dist.b * mm_per_step[Y_AXIS];
+    dist_mm.head.z = dist.c * mm_per_step[C_AXIS];
+    dist_mm.a      = (dist.a + dist.c) * mm_per_step[A_AXIS];
+    dist_mm.c      = CORESIGN(dist.a - dist.c) * mm_per_step[C_AXIS];
+  #elif CORE_IS_YZ
+    dist_mm.x      = dist.a * mm_per_step[X_AXIS];
+    dist_mm.head.y = dist.b * mm_per_step[B_AXIS];
+    dist_mm.head.z = dist.c * mm_per_step[C_AXIS];
+    dist_mm.b      = (dist.b + dist.c) * mm_per_step[B_AXIS];
+    dist_mm.c      = CORESIGN(dist.b - dist.c) * mm_per_step[C_AXIS];
   #elif ENABLED(MARKFORGED_XY)
     dist_mm.a = (dist.a TERN(MARKFORGED_INVERSE, +, -) dist.b) * mm_per_step[A_AXIS];
     dist_mm.b = dist.b * mm_per_step[B_AXIS];
   #elif ENABLED(MARKFORGED_YX)
     dist_mm.a = dist.a * mm_per_step[A_AXIS];
     dist_mm.b = (dist.b TERN(MARKFORGED_INVERSE, +, -) dist.a) * mm_per_step[B_AXIS];
   #else
     XYZ_CODE(
       dist_mm.a = dist.a * mm_per_step[A_AXIS],
       dist_mm.b = dist.b * mm_per_step[B_AXIS],
@@ -2533,20 +2533,21 @@ bool Planner::_populate_block(
         LIMIT_ACCEL_FLOAT(I_AXIS, 0), LIMIT_ACCEL_FLOAT(J_AXIS, 0), LIMIT_ACCEL_FLOAT(K_AXIS, 0),
         LIMIT_ACCEL_FLOAT(U_AXIS, 0), LIMIT_ACCEL_FLOAT(V_AXIS, 0), LIMIT_ACCEL_FLOAT(W_AXIS, 0)
       );
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
     block->acceleration_rate = (uint32_t)(accel * (float(1UL << 24) / (STEPPER_TIMER_RATE)));
   #endif
+
   #if ENABLED(LIN_ADVANCE)
     block->la_advance_rate = 0;
     block->la_scaling = 0;
 
     if (use_advance_lead) {
       // the Bresenham algorithm will convert this step rate into extruder steps
       block->la_advance_rate = extruder_advance_K[E_INDEX_N(extruder)] * block->acceleration_steps_per_s2;
 
       // reduce LA ISR frequency by calling it only often enough to ensure that there will
       // never be more than four extruder steps per call

commit b90133813a96ce839e17da039b2679601ee59afc
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Thu Dec 14 22:16:15 2023 +0200

    üêõ Fix planner jerk limits (#26529)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 61dff55caf..64c47301f5 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -146,23 +146,21 @@ planner_settings_t Planner::settings;           // Initialized by settings.load(
 
 uint32_t Planner::max_acceleration_steps_per_s2[DISTINCT_AXES]; // (steps/s^2) Derived from mm_per_s2
 
 float Planner::mm_per_step[DISTINCT_AXES];      // (mm) Millimeters per step
 
 #if HAS_JUNCTION_DEVIATION
   float Planner::junction_deviation_mm;         // (mm) M205 J
   #if HAS_LINEAR_E_JERK
     float Planner::max_e_jerk[DISTINCT_E];      // Calculated from junction_deviation_mm
   #endif
-#endif
-
-#if ENABLED(CLASSIC_JERK)
+#else // CLASSIC_JERK
   TERN(HAS_LINEAR_E_JERK, xyz_pos_t, xyze_pos_t) Planner::max_jerk;
 #endif
 
 #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
@@ -2367,56 +2365,56 @@ bool Planner::_populate_block(
   // Linear axes first with less logic
   LOOP_NUM_AXES(i) {
     current_speed[i] = dist_mm[i] * inverse_secs;
     const feedRate_t cs = ABS(current_speed[i]),
                  max_fr = settings.max_feedrate_mm_s[i];
     if (cs > max_fr) NOMORE(speed_factor, max_fr / cs);
   }
 
   // Limit speed on extruders, if any
   #if HAS_EXTRUDERS
-    {
-      current_speed.e = dist_mm.e * inverse_secs;
-      #if HAS_MIXER_SYNC_CHANNEL
-        // Move all mixing extruders at the specified rate
-        if (mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)
-          current_speed.e *= MIXING_STEPPERS;
-      #endif
-
-      const feedRate_t cs = ABS(current_speed.e),
-                   max_fr = settings.max_feedrate_mm_s[E_AXIS_N(extruder)]
-                            * TERN(HAS_MIXER_SYNC_CHANNEL, MIXING_STEPPERS, 1);
-
-      if (cs > max_fr) NOMORE(speed_factor, max_fr / cs); //respect max feedrate on any movement (doesn't matter if E axes only or not)
-
-      #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
-        const feedRate_t max_vfr = volumetric_extruder_feedrate_limit[extruder]
-                                   * TERN(HAS_MIXER_SYNC_CHANNEL, MIXING_STEPPERS, 1);
+  {
+    current_speed.e = dist_mm.e * inverse_secs;
+    #if HAS_MIXER_SYNC_CHANNEL
+      // Move all mixing extruders at the specified rate
+      if (mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)
+        current_speed.e *= MIXING_STEPPERS;
+    #endif
 
-        // TODO: Doesn't work properly for joined segments. Set MIN_STEPS_PER_SEGMENT 1 as workaround.
+    const feedRate_t cs = ABS(current_speed.e),
+                 max_fr = settings.max_feedrate_mm_s[E_AXIS_N(extruder)]
+                          * TERN(HAS_MIXER_SYNC_CHANNEL, MIXING_STEPPERS, 1);
 
-        if (block->steps.a || block->steps.b || block->steps.c) {
+    if (cs > max_fr) NOMORE(speed_factor, max_fr / cs); //respect max feedrate on any movement (doesn't matter if E axes only or not)
 
-          if (max_vfr > 0 && cs > max_vfr) {
-            NOMORE(speed_factor, max_vfr / cs); // respect volumetric extruder limit (if any)
-            /* <-- add a slash to enable
-            SERIAL_ECHOPGM("volumetric extruder limit enforced: ", (cs * CIRCLE_AREA(filament_size[extruder] * 0.5f)));
-            SERIAL_ECHOPGM(" mm^3/s (", cs);
-            SERIAL_ECHOPGM(" mm/s) limited to ", (max_vfr * CIRCLE_AREA(filament_size[extruder] * 0.5f)));
-            SERIAL_ECHOPGM(" mm^3/s (", max_vfr);
-            SERIAL_ECHOLNPGM(" mm/s)");
-            //*/
-          }
+    #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+      const feedRate_t max_vfr = volumetric_extruder_feedrate_limit[extruder]
+                                 * TERN(HAS_MIXER_SYNC_CHANNEL, MIXING_STEPPERS, 1);
+
+      // TODO: Doesn't work properly for joined segments. Set MIN_STEPS_PER_SEGMENT 1 as workaround.
+
+      if (block->steps.a || block->steps.b || block->steps.c) {
+
+        if (max_vfr > 0 && cs > max_vfr) {
+          NOMORE(speed_factor, max_vfr / cs); // respect volumetric extruder limit (if any)
+          /* <-- add a slash to enable
+          SERIAL_ECHOPGM("volumetric extruder limit enforced: ", (cs * CIRCLE_AREA(filament_size[extruder] * 0.5f)));
+          SERIAL_ECHOPGM(" mm^3/s (", cs);
+          SERIAL_ECHOPGM(" mm/s) limited to ", (max_vfr * CIRCLE_AREA(filament_size[extruder] * 0.5f)));
+          SERIAL_ECHOPGM(" mm^3/s (", max_vfr);
+          SERIAL_ECHOLNPGM(" mm/s)");
+          //*/
         }
-      #endif
-    }
-  #endif
+      }
+    #endif
+  }
+  #endif // HAS_EXTRUDERS
 
   #ifdef XY_FREQUENCY_LIMIT
 
     static AxisBits old_direction_bits; // = 0
 
     if (xy_freq_limit_hz) {
       // Check and limit the xy direction change frequency
       const AxisBits direction_change = block->direction_bits ^ old_direction_bits;
       old_direction_bits = block->direction_bits;
       segment_time_us = LROUND(float(segment_time_us) / speed_factor);
@@ -2485,42 +2483,43 @@ bool Planner::_populate_block(
       // Linear advance is currently not ready for HAS_I_AXIS
       #define MAX_E_JERK(N) TERN(HAS_LINEAR_E_JERK, max_e_jerk[E_INDEX_N(N)], max_jerk.e)
 
       /**
        * Use LIN_ADVANCE for blocks if all these are true:
        *
        * esteps                       : This is a print move, because we checked for A, B, C steps before.
        *
        * extruder_advance_K[extruder] : There is an advance factor set for this extruder.
        *
-       * dist.e > 0                       : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
+       * dist.e > 0                   : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
        */
       use_advance_lead = esteps && extruder_advance_K[E_INDEX_N(extruder)] && dist.e > 0;
 
       if (use_advance_lead) {
         float e_D_ratio = (target_float.e - position_float.e) /
           TERN(IS_KINEMATIC, block->millimeters,
             SQRT(sq(target_float.x - position_float.x)
                + sq(target_float.y - position_float.y)
                + sq(target_float.z - position_float.z))
           );
 
         // Check for unusual high e_D ratio to detect if a retract move was combined with the last print move due to min. steps per segment. Never execute this with advance!
         // This assumes no one will use a retract length of 0mm < retr_length < ~0.2mm and no one will print 100mm wide lines using 3mm filament or 35mm wide lines using 1.75mm filament.
         if (e_D_ratio > 3.0f)
           use_advance_lead = false;
         else {
           // Scale E acceleration so that it will be possible to jump to the advance speed.
           const uint32_t max_accel_steps_per_s2 = MAX_E_JERK(extruder) / (extruder_advance_K[E_INDEX_N(extruder)] * e_D_ratio) * steps_per_mm;
-          if (TERN0(LA_DEBUG, accel > max_accel_steps_per_s2))
-            SERIAL_ECHOLNPGM("Acceleration limited.");
-          NOMORE(accel, max_accel_steps_per_s2);
+          if (accel > max_accel_steps_per_s2) {
+            accel = max_accel_steps_per_s2;
+            if (ENABLED(LA_DEBUG)) SERIAL_ECHOLNPGM("Acceleration limited.");
+          }
         }
       }
     #endif
 
     // Limit acceleration per axis
     if (block->step_event_count <= acceleration_long_cutoff) {
       LOGICAL_AXIS_CODE(
         LIMIT_ACCEL_LONG(E_AXIS, E_INDEX_N(extruder)),
         LIMIT_ACCEL_LONG(A_AXIS, 0), LIMIT_ACCEL_LONG(B_AXIS, 0), LIMIT_ACCEL_LONG(C_AXIS, 0),
         LIMIT_ACCEL_LONG(I_AXIS, 0), LIMIT_ACCEL_LONG(J_AXIS, 0), LIMIT_ACCEL_LONG(K_AXIS, 0),
@@ -2757,118 +2756,73 @@ bool Planner::_populate_block(
       }
 
       // Get the lowest speed
       vmax_junction_sqr = _MIN(vmax_junction_sqr, sq(block->nominal_speed), sq(previous_nominal_speed));
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
       vmax_junction_sqr = 0;
 
     prev_unit_vec = unit_vec;
 
-  #endif
-
-  #if ENABLED(CLASSIC_JERK)
+  #else // CLASSIC_JERK
 
     /**
-     * Adapted from Pr≈Ø≈°a MKS firmware
+     * Heavily modified. Originally adapted from Pr≈Ø≈°a firmware.
      * https://github.com/prusa3d/Prusa-Firmware
      */
-    // Exit speed limited by a jerk to full halt of a previous last segment
-    static float previous_safe_speed;
-
-    // Start with a safe speed (from which the machine may halt to stop immediately).
-    float safe_speed = block->nominal_speed;
-
     #ifndef TRAVEL_EXTRA_XYJERK
-      #define TRAVEL_EXTRA_XYJERK 0
+      #define TRAVEL_EXTRA_XYJERK 0.0f
     #endif
-    const float extra_xyjerk = TERN0(HAS_EXTRUDERS, dist.e <= 0) ? TRAVEL_EXTRA_XYJERK : 0;
-
-    uint8_t limited = 0;
-    TERN(HAS_LINEAR_E_JERK, LOOP_NUM_AXES, LOOP_LOGICAL_AXES)(i) {
-      const float jerk = ABS(current_speed[i]),   // cs : Starting from zero, change in speed for this axis
-                  maxj = (max_jerk[i] + (i == X_AXIS || i == Y_AXIS ? extra_xyjerk : 0.0f)); // mj : The max jerk setting for this axis
-      if (jerk > maxj) {                          // cs > mj : New current speed too fast?
-        if (limited) {                            // limited already?
-          const float mjerk = block->nominal_speed * maxj; // ns*mj
-          if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk; // ns*mj/cs
-        }
-        else {
-          safe_speed *= maxj / jerk;              // Initial limit: ns*mj/cs
-          ++limited;                              // Initially limited
-        }
-      }
-    }
+    const float extra_xyjerk = TERN0(HAS_EXTRUDERS, dist.e <= 0) ? TRAVEL_EXTRA_XYJERK : 0.0f;
 
-    float vmax_junction;
-    if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
-      // Estimate a maximum velocity allowed at a joint of two successive segments.
-      // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
-      // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
+    if (!moves_queued || UNEAR_ZERO(previous_nominal_speed)) {
+      // Compute "safe" speed, limited by a jerk to/from full halt.
 
-      // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
-      float v_factor = 1;
-      limited = 0;
+      float v_factor = 1.0f;
+      LOOP_LOGICAL_AXES(i) {
+        const float jerk = ABS(current_speed[i]),   // Starting from zero, change in speed for this axis
+                    maxj = max_jerk[i] + (i == X_AXIS || i == Y_AXIS ? extra_xyjerk : 0.0f); // The max jerk setting for this axis
+        if (jerk * v_factor > maxj) v_factor = maxj / jerk;
+      }
+      vmax_junction_sqr = sq(block->nominal_speed * v_factor);
+      NOLESS(minimum_planner_speed_sqr, vmax_junction_sqr);
+    }
+    else {
+      // Compute the maximum velocity allowed at a joint of two successive segments.
 
       // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
-      // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
-      float smaller_speed_factor = 1.0f;
+      float vmax_junction, previous_speed_factor, current_speed_factor;
       if (block->nominal_speed < previous_nominal_speed) {
         vmax_junction = block->nominal_speed;
-        smaller_speed_factor = vmax_junction / previous_nominal_speed;
+        previous_speed_factor = vmax_junction / previous_nominal_speed;
+        current_speed_factor = 1.0f;
       }
-      else
+      else {
         vmax_junction = previous_nominal_speed;
+        previous_speed_factor = 1.0f;
+        current_speed_factor = vmax_junction / block->nominal_speed;
+      }
 
       // Now limit the jerk in all axes.
-      TERN(HAS_LINEAR_E_JERK, LOOP_NUM_AXES, LOOP_LOGICAL_AXES)(axis) {
-        // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
-        float v_exit = previous_speed[axis] * smaller_speed_factor,
-              v_entry = current_speed[axis];
-        if (limited) {
-          v_exit *= v_factor;
-          v_entry *= v_factor;
-        }
-
-        // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
-        const float jerk = (v_exit > v_entry)
-            ? //                                  coasting             axis reversal
-              ( (v_entry > 0 || v_exit < 0) ? (v_exit - v_entry) : _MAX(v_exit, -v_entry) )
-            : // v_exit <= v_entry                coasting             axis reversal
-              ( (v_entry < 0 || v_exit > 0) ? (v_entry - v_exit) : _MAX(-v_exit, v_entry) );
-
-        const float maxj = (max_jerk[axis] + (axis == X_AXIS || axis == Y_AXIS ? extra_xyjerk : 0.0f));
-
-        if (jerk > maxj) {
-          v_factor *= maxj / jerk;
-          ++limited;
-        }
+      float v_factor = 1.0f;
+      LOOP_LOGICAL_AXES(i) {
+        // Scale per-axis velocities for the same vmax_junction.
+        const float v_exit = previous_speed[i] * previous_speed_factor,
+                    v_entry = current_speed[i] * current_speed_factor;
+
+        // Jerk is the per-axis velocity difference.
+        const float jerk = ABS(v_exit - v_entry),
+                    maxj = max_jerk[i] + (i == X_AXIS || i == Y_AXIS ? extra_xyjerk : 0.0f);
+        if (jerk * v_factor > maxj) v_factor = maxj / jerk;
       }
-      if (limited) vmax_junction *= v_factor;
-      // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
-      // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
-      const float vmax_junction_threshold = vmax_junction * 0.99f;
-      if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold)
-        vmax_junction = safe_speed;
+      vmax_junction_sqr = sq(vmax_junction * v_factor);
     }
-    else
-      vmax_junction = safe_speed;
-
-    previous_safe_speed = safe_speed;
-
-    NOLESS(minimum_planner_speed_sqr, sq(safe_speed));
-
-    #if HAS_JUNCTION_DEVIATION
-      NOMORE(vmax_junction_sqr, sq(vmax_junction));   // Throttle down to max speed
-    #else
-      vmax_junction_sqr = sq(vmax_junction);          // Go up or down to the new speed
-    #endif
 
   #endif // CLASSIC_JERK
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed_sqr = vmax_junction_sqr;
 
   // Initialize block entry speed. Compute based on deceleration to sqrt(minimum_planner_speed_sqr).
   const float v_allowable_sqr = max_allowable_speed_sqr(-block->acceleration, minimum_planner_speed_sqr, block->millimeters);
 
   // Start with the minimum allowed speed

commit 75da3555ee0910f3d572f4b8176afecdc941524b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Dec 14 10:03:11 2023 -0600

    üîß Update CLASSIC_JERK conditionals

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 70a1b105db..61dff55caf 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -148,21 +148,21 @@ uint32_t Planner::max_acceleration_steps_per_s2[DISTINCT_AXES]; // (steps/s^2) D
 
 float Planner::mm_per_step[DISTINCT_AXES];      // (mm) Millimeters per step
 
 #if HAS_JUNCTION_DEVIATION
   float Planner::junction_deviation_mm;         // (mm) M205 J
   #if HAS_LINEAR_E_JERK
     float Planner::max_e_jerk[DISTINCT_E];      // Calculated from junction_deviation_mm
   #endif
 #endif
 
-#if HAS_CLASSIC_JERK
+#if ENABLED(CLASSIC_JERK)
   TERN(HAS_LINEAR_E_JERK, xyz_pos_t, xyze_pos_t) Planner::max_jerk;
 #endif
 
 #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
@@ -1567,30 +1567,30 @@ void Planner::check_axes_activity() {
   void Planner::enable_stall_prevention(const bool onoff) {
     static motion_state_t saved_motion_state;
     if (onoff) {
       saved_motion_state.acceleration.x = settings.max_acceleration_mm_per_s2[X_AXIS];
       saved_motion_state.acceleration.y = settings.max_acceleration_mm_per_s2[Y_AXIS];
       settings.max_acceleration_mm_per_s2[X_AXIS] = settings.max_acceleration_mm_per_s2[Y_AXIS] = 100;
       #if ENABLED(DELTA)
         saved_motion_state.acceleration.z = settings.max_acceleration_mm_per_s2[Z_AXIS];
         settings.max_acceleration_mm_per_s2[Z_AXIS] = 100;
       #endif
-      #if HAS_CLASSIC_JERK
+      #if ENABLED(CLASSIC_JERK)
         saved_motion_state.jerk_state = max_jerk;
         max_jerk.set(0, 0 OPTARG(DELTA, 0));
       #endif
     }
     else {
       settings.max_acceleration_mm_per_s2[X_AXIS] = saved_motion_state.acceleration.x;
       settings.max_acceleration_mm_per_s2[Y_AXIS] = saved_motion_state.acceleration.y;
       TERN_(DELTA, settings.max_acceleration_mm_per_s2[Z_AXIS] = saved_motion_state.acceleration.z);
-      TERN_(HAS_CLASSIC_JERK, max_jerk = saved_motion_state.jerk_state);
+      TERN_(CLASSIC_JERK, max_jerk = saved_motion_state.jerk_state);
     }
     refresh_acceleration_rates();
   }
 
 #endif
 
 #if HAS_LEVELING
 
   constexpr xy_pos_t level_fulcrum = {
     TERN(Z_SAFE_HOMING, Z_SAFE_HOMING_X_POINT, X_HOME_POS),
@@ -2759,21 +2759,21 @@ bool Planner::_populate_block(
       // Get the lowest speed
       vmax_junction_sqr = _MIN(vmax_junction_sqr, sq(block->nominal_speed), sq(previous_nominal_speed));
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
       vmax_junction_sqr = 0;
 
     prev_unit_vec = unit_vec;
 
   #endif
 
-  #if HAS_CLASSIC_JERK
+  #if ENABLED(CLASSIC_JERK)
 
     /**
      * Adapted from Pr≈Ø≈°a MKS firmware
      * https://github.com/prusa3d/Prusa-Firmware
      */
     // Exit speed limited by a jerk to full halt of a previous last segment
     static float previous_safe_speed;
 
     // Start with a safe speed (from which the machine may halt to stop immediately).
     float safe_speed = block->nominal_speed;
@@ -2856,21 +2856,21 @@ bool Planner::_populate_block(
     previous_safe_speed = safe_speed;
 
     NOLESS(minimum_planner_speed_sqr, sq(safe_speed));
 
     #if HAS_JUNCTION_DEVIATION
       NOMORE(vmax_junction_sqr, sq(vmax_junction));   // Throttle down to max speed
     #else
       vmax_junction_sqr = sq(vmax_junction);          // Go up or down to the new speed
     #endif
 
-  #endif // Classic Jerk Limiting
+  #endif // CLASSIC_JERK
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed_sqr = vmax_junction_sqr;
 
   // Initialize block entry speed. Compute based on deceleration to sqrt(minimum_planner_speed_sqr).
   const float v_allowable_sqr = max_allowable_speed_sqr(-block->acceleration, minimum_planner_speed_sqr, block->millimeters);
 
   // Start with the minimum allowed speed
   block->entry_speed_sqr = minimum_planner_speed_sqr;
 
@@ -3391,21 +3391,21 @@ void Planner::set_max_feedrate(const AxisEnum axis, float inMaxFeedrateMMS) {
       const xyze_float_t &max_fr_edit_scaled = max_fr_edit;
     #else
       constexpr xyze_float_t max_fr_edit = DEFAULT_MAX_FEEDRATE;
       const xyze_float_t max_fr_edit_scaled = max_fr_edit * 2;
     #endif
     limit_and_warn(inMaxFeedrateMMS, axis, PSTR("Feedrate"), max_fr_edit_scaled);
   #endif
   settings.max_feedrate_mm_s[axis] = inMaxFeedrateMMS;
 }
 
-#if HAS_CLASSIC_JERK
+#if ENABLED(CLASSIC_JERK)
 
   /**
    * For the specified 'axis' set the Maximum Jerk (instant change) to the given value (mm/s)
    * The value may be limited with warning feedback, if configured.
    *
    * This hard limit is applied (to the block start speed) as the block is being added to the planner queue.
    */
   void Planner::set_max_jerk(const AxisEnum axis, float inMaxJerkMMS) {
     #if ENABLED(LIMITED_JERK_EDITING)
       constexpr xyze_float_t max_jerk_edit =

commit fef74398e41a1b492792837941af55057eb694f5
Author: jesterhead82 <mclauss82@gmail.com>
Date:   Wed Dec 13 08:44:11 2023 +0100

    ‚ú® MARKFORGED_INVERSE (#26516)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 8e9021b030..70a1b105db 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1983,25 +1983,25 @@ bool Planner::_populate_block(
       dm.a  = (dist.a + dist.c > 0);            // Motor A direction
       dm.c  = (CORESIGN(dist.a - dist.c) > 0);  // Motor C direction
     #elif CORE_IS_YZ
       dm.x  = (dist.a > 0);
       dm.hy = (dist.b > 0);                     // Save the toolhead's true direction in Y
       dm.hz = (dist.c > 0);                     // ...and Z
       dm.b  = (dist.b + dist.c > 0);            // Motor B direction
       dm.c  = (CORESIGN(dist.b - dist.c) > 0);  // Motor C direction
     #endif
   #elif ENABLED(MARKFORGED_XY)
-    dm.a = (dist.a + dist.b > 0);               // Motor A direction
+    dm.a = (dist.a TERN(MARKFORGED_INVERSE, -, +) dist.b > 0); // Motor A direction
     dm.b = (dist.b > 0);                        // Motor B direction
   #elif ENABLED(MARKFORGED_YX)
     dm.a = (dist.a > 0);                        // Motor A direction
-    dm.b = (dist.b + dist.a > 0);               // Motor B direction
+    dm.b = (dist.b TERN(MARKFORGED_INVERSE, -, +) dist.a > 0); // Motor B direction
   #else
     XYZ_CODE(
       dm.x = (dist.a > 0),
       dm.y = (dist.b > 0),
       dm.z = (dist.c > 0)
     );
   #endif
 
   SECONDARY_AXIS_CODE(
     dm.i = (dist.i > 0), dm.j = (dist.j > 0), dm.k = (dist.k > 0),
@@ -2055,23 +2055,23 @@ bool Planner::_populate_block(
   // Number of steps for each axis
   // See https://www.corexy.com/theory.html
   block->steps.set(NUM_AXIS_LIST(
     #if CORE_IS_XY
       ABS(dist.a + dist.b), ABS(dist.a - dist.b), ABS(dist.c)
     #elif CORE_IS_XZ
       ABS(dist.a + dist.c), ABS(dist.b), ABS(dist.a - dist.c)
     #elif CORE_IS_YZ
       ABS(dist.a), ABS(dist.b + dist.c), ABS(dist.b - dist.c)
     #elif ENABLED(MARKFORGED_XY)
-      ABS(dist.a + dist.b), ABS(dist.b), ABS(dist.c)
+      ABS(dist.a TERN(MARKFORGED_INVERSE, -, +) dist.b), ABS(dist.b), ABS(dist.c)
     #elif ENABLED(MARKFORGED_YX)
-      ABS(dist.a), ABS(dist.b + dist.a), ABS(dist.c)
+      ABS(dist.a), ABS(dist.b TERN(MARKFORGED_INVERSE, -, +) dist.a), ABS(dist.c)
     #elif IS_SCARA
       ABS(dist.a), ABS(dist.b), ABS(dist.c)
     #else // default non-h-bot planning
       ABS(dist.a), ABS(dist.b), ABS(dist.c)
     #endif
     , ABS(dist.i), ABS(dist.j), ABS(dist.k), ABS(dist.u), ABS(dist.v), ABS(dist.w)
   ));
 
   /**
    * This part of the code calculates the total length of the movement.
@@ -2103,25 +2103,25 @@ bool Planner::_populate_block(
       dist_mm.a      = (dist.a + dist.c) * mm_per_step[A_AXIS];
       dist_mm.c      = CORESIGN(dist.a - dist.c) * mm_per_step[C_AXIS];
     #elif CORE_IS_YZ
       dist_mm.x      = dist.a * mm_per_step[X_AXIS];
       dist_mm.head.y = dist.b * mm_per_step[B_AXIS];
       dist_mm.head.z = dist.c * mm_per_step[C_AXIS];
       dist_mm.b      = (dist.b + dist.c) * mm_per_step[B_AXIS];
       dist_mm.c      = CORESIGN(dist.b - dist.c) * mm_per_step[C_AXIS];
     #endif
   #elif ENABLED(MARKFORGED_XY)
-    dist_mm.a = (dist.a - dist.b) * mm_per_step[A_AXIS];
+    dist_mm.a = (dist.a TERN(MARKFORGED_INVERSE, +, -) dist.b) * mm_per_step[A_AXIS];
     dist_mm.b = dist.b * mm_per_step[B_AXIS];
   #elif ENABLED(MARKFORGED_YX)
     dist_mm.a = dist.a * mm_per_step[A_AXIS];
-    dist_mm.b = (dist.b - dist.a) * mm_per_step[B_AXIS];
+    dist_mm.b = (dist.b TERN(MARKFORGED_INVERSE, +, -) dist.a) * mm_per_step[B_AXIS];
   #else
     XYZ_CODE(
       dist_mm.a = dist.a * mm_per_step[A_AXIS],
       dist_mm.b = dist.b * mm_per_step[B_AXIS],
       dist_mm.c = dist.c * mm_per_step[C_AXIS]
     );
   #endif
 
   SECONDARY_AXIS_CODE(
     dist_mm.i = dist.i * mm_per_step[I_AXIS], dist_mm.j = dist.j * mm_per_step[J_AXIS], dist_mm.k = dist.k * mm_per_step[K_AXIS],

commit cac742009c1b44f3789e6bd8c400d9ee5763521b
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sat Nov 4 04:12:33 2023 +0000

    üêõ Fix Backlash Compensation layer shift (#26392)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 1414a31445..8e9021b030 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2168,21 +2168,21 @@ bool Planner::_populate_block(
 
     /**
      * At this point at least one of the axes has more steps than
      * MIN_STEPS_PER_SEGMENT, ensuring the segment won't get dropped as
      * zero-length. It's important to not apply corrections
      * to blocks that would get dropped!
      *
      * A correction function is permitted to add steps to an axis, it
      * should *never* remove steps!
      */
-    TERN_(BACKLASH_COMPENSATION, backlash.add_correction_steps(dist.a, dist.b, dist.c, dm, block));
+    TERN_(BACKLASH_COMPENSATION, backlash.add_correction_steps(dist, dm, block));
   }
 
   TERN_(HAS_EXTRUDERS, block->steps.e = esteps);
 
   block->step_event_count = (
     #if NUM_AXES
       _MAX(LOGICAL_AXIS_LIST(esteps,
         block->steps.a, block->steps.b, block->steps.c,
         block->steps.i, block->steps.j, block->steps.k,
         block->steps.u, block->steps.v, block->steps.w

commit c666b492c4e188987e9382e6ec2e79453b5136bc
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Oct 27 23:06:04 2023 +0100

    üî• Automatic minimum planner junction speed (#26198)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 0916ade581..1414a31445 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -181,20 +181,24 @@ float Planner::mm_per_step[DISTINCT_AXES];      // (mm) Millimeters per step
   float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
         Planner::volumetric_area_nominal = CIRCLE_AREA(float(DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5f), // Nominal cross-sectional area
         Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
 #endif
 
 #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
   float Planner::volumetric_extruder_limit[EXTRUDERS],          // max mm^3/sec the extruder is able to handle
         Planner::volumetric_extruder_feedrate_limit[EXTRUDERS]; // pre calculated extruder feedrate limit based on volumetric_extruder_limit; pre-calculated to reduce computation in the planner
 #endif
 
+#ifdef MAX7219_DEBUG_SLOWDOWN
+  uint8_t Planner::slowdown_count = 0;
+#endif
+
 #if HAS_LEVELING
   bool Planner::leveling_active = false; // Flag that auto bed leveling is enabled
   #if ABL_PLANAR
     matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
   #endif
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
     float Planner::z_fade_height,      // Initialized by settings.load()
           Planner::inverse_z_fade_height,
           Planner::last_fade_z;
   #endif
@@ -978,43 +982,41 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
  *
  *    - Maximize the planner buffer size. This also will increase the combined distance for the planner to
  *      compute over. It also increases the number of computations the planner has to perform to compute an
  *      optimal plan, so select carefully.
  *
  *    - Use G2/G3 arcs instead of many short segments. Arcs inform the planner of a safe exit speed at the
  *      end of the last segment, which alleviates this problem.
  */
 
 // The kernel called by recalculate() when scanning the plan from last to first entry.
-void Planner::reverse_pass_kernel(block_t * const current, const block_t * const next
-  OPTARG(HINTS_SAFE_EXIT_SPEED, const_float_t safe_exit_speed_sqr)
-) {
+void Planner::reverse_pass_kernel(block_t * const current, const block_t * const next, const_float_t safe_exit_speed_sqr) {
   if (current) {
     // If entry speed is already at the maximum entry speed, and there was no change of speed
     // in the next block, there is no need to recheck. Block is cruising and there is no need to
     // compute anything for this block,
     // If not, block entry speed needs to be recalculated to ensure maximum possible planned speed.
     const float max_entry_speed_sqr = current->max_entry_speed_sqr;
 
     // Compute maximum entry speed decelerating over the current block from its exit speed.
     // If not at the maximum entry speed, or the previous block entry speed changed
     if (current->entry_speed_sqr != max_entry_speed_sqr || (next && next->flag.recalculate)) {
 
       // If nominal length true, max junction speed is guaranteed to be reached.
       // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
       // the current block and next block junction speeds are guaranteed to always be at their maximum
       // junction speeds in deceleration and acceleration, respectively. This is due to how the current
       // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
       // the reverse and forward planners, the corresponding block junction speed will always be at the
       // the maximum junction speed and may always be ignored for any speed reduction checks.
 
-      const float next_entry_speed_sqr = next ? next->entry_speed_sqr : _MAX(TERN0(HINTS_SAFE_EXIT_SPEED, safe_exit_speed_sqr), sq(float(MINIMUM_PLANNER_SPEED))),
+      const float next_entry_speed_sqr = next ? next->entry_speed_sqr : safe_exit_speed_sqr,
                   new_entry_speed_sqr = current->flag.nominal_length
                     ? max_entry_speed_sqr
                     : _MIN(max_entry_speed_sqr, max_allowable_speed_sqr(-current->acceleration, next_entry_speed_sqr, current->millimeters));
       if (current->entry_speed_sqr != new_entry_speed_sqr) {
 
         // Need to recalculate the block speed - Mark it now, so the stepper
         // ISR does not consume the block before being recalculated
         current->flag.recalculate = true;
 
         // But there is an inherent race condition here, as the block may have
@@ -1032,21 +1034,21 @@ void Planner::reverse_pass_kernel(block_t * const current, const block_t * const
         }
       }
     }
   }
 }
 
 /**
  * recalculate() needs to go over the current plan twice.
  * Once in reverse and once forward. This implements the reverse pass.
  */
-void Planner::reverse_pass(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t safe_exit_speed_sqr)) {
+void Planner::reverse_pass(const_float_t safe_exit_speed_sqr) {
   // Initialize block index to the last block in the planner buffer.
   uint8_t block_index = prev_block_index(block_buffer_head);
 
   // Read the index of the last buffer planned block.
   // The ISR may change it so get a stable local copy.
   uint8_t planned_block_index = block_buffer_planned;
 
   // If there was a race condition and block_buffer_planned was incremented
   //  or was pointing at the head (queue empty) break loop now and avoid
   //  planning already consumed blocks
@@ -1056,21 +1058,21 @@ void Planner::reverse_pass(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t safe_exit_
   // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
   // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
   const block_t *next = nullptr;
   while (block_index != planned_block_index) {
 
     // Perform the reverse pass
     block_t *current = &block_buffer[block_index];
 
     // Only process movement blocks
     if (current->is_move()) {
-      reverse_pass_kernel(current, next OPTARG(HINTS_SAFE_EXIT_SPEED, safe_exit_speed_sqr));
+      reverse_pass_kernel(current, next, safe_exit_speed_sqr);
       next = current;
     }
 
     // Advance to the next
     block_index = prev_block_index(block_index);
 
     // The ISR could advance the block_buffer_planned while we were doing the reverse pass.
     // We must try to avoid using an already consumed block as the last one - So follow
     // changes to the pointer and make sure to limit the loop to the currently busy block
     while (planned_block_index != block_buffer_planned) {
@@ -1169,21 +1171,21 @@ void Planner::forward_pass() {
     // Advance to the previous
     block_index = next_block_index(block_index);
   }
 }
 
 /**
  * Recalculate the trapezoid speed profiles for all blocks in the plan
  * according to the entry_factor for each junction. Must be called by
  * recalculate() after updating the blocks.
  */
-void Planner::recalculate_trapezoids(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t safe_exit_speed_sqr)) {
+void Planner::recalculate_trapezoids(const_float_t safe_exit_speed_sqr) {
   // The tail may be changed by the ISR so get a local copy.
   uint8_t block_index = block_buffer_tail,
           head_block_index = block_buffer_head;
   // Since there could be a sync block in the head of the queue, and the
   // next loop must not recalculate the head block (as it needs to be
   // specially handled), scan backwards to the first non-SYNC block.
   while (head_block_index != block_index) {
 
     // Go back (head always point to the first free block)
     const uint8_t prev_index = prev_block_index(head_block_index);
@@ -1236,22 +1238,21 @@ void Planner::recalculate_trapezoids(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t
 
       block = next;
       current_entry_speed = next_entry_speed;
     }
 
     block_index = next_block_index(block_index);
   }
 
   // Last/newest block in buffer. Always recalculated.
   if (block) {
-    // Exit speed is set with MINIMUM_PLANNER_SPEED unless some code higher up knows better.
-    next_entry_speed = _MAX(TERN0(HINTS_SAFE_EXIT_SPEED, SQRT(safe_exit_speed_sqr)), float(MINIMUM_PLANNER_SPEED));
+    next_entry_speed = SQRT(safe_exit_speed_sqr);
 
     // Mark the next(last) block as RECALCULATE, to prevent the Stepper ISR running it.
     // As the last block is always recalculated here, there is a chance the block isn't
     // marked as RECALCULATE yet. That's the reason for the following line.
     block->flag.recalculate = true;
 
     // But there is an inherent race condition here, as the block maybe
     // became BUSY, just before it was marked as RECALCULATE, so check
     // if that is the case!
     if (!stepper.is_block_busy(block)) {
@@ -1260,29 +1261,29 @@ void Planner::recalculate_trapezoids(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t
       const float nomr = 1.0f / block->nominal_speed;
       calculate_trapezoid_for_block(block, current_entry_speed * nomr, next_entry_speed * nomr);
     }
 
     // Reset block to ensure its trapezoid is computed - The stepper is free to use
     // the block from now on.
     block->flag.recalculate = false;
   }
 }
 
-void Planner::recalculate(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t safe_exit_speed_sqr)) {
+void Planner::recalculate(const_float_t safe_exit_speed_sqr) {
   // Initialize block index to the last block in the planner buffer.
   const uint8_t block_index = prev_block_index(block_buffer_head);
   // If there is just one block, no planning can be done. Avoid it!
   if (block_index != block_buffer_planned) {
-    reverse_pass(TERN_(HINTS_SAFE_EXIT_SPEED, safe_exit_speed_sqr));
+    reverse_pass(safe_exit_speed_sqr);
     forward_pass();
   }
-  recalculate_trapezoids(TERN_(HINTS_SAFE_EXIT_SPEED, safe_exit_speed_sqr));
+  recalculate_trapezoids(safe_exit_speed_sqr);
 }
 
 /**
  * Apply fan speeds
  */
 #if HAS_FAN
 
   void Planner::sync_fan_speeds(uint8_t (&fan_speed)[FAN_COUNT]) {
 
     #if ENABLED(FAN_SOFT_PWM)
@@ -1822,46 +1823,54 @@ bool Planner::_buffer_steps(const xyze_long_t &target
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // If we are cleaning, do not accept queuing of movements
   // This must be after get_next_free_block() because it calls idle()
   // where cleaning_buffer_counter can be changed
   if (cleaning_buffer_counter) return false;
 
   // Fill the block with the specified movement
+  float minimum_planner_speed_sqr;
   if (!_populate_block(block, target
         OPTARG(HAS_POSITION_FLOAT, target_float)
         OPTARG(HAS_DIST_MM_ARG, cart_dist_mm)
         , fr_mm_s, extruder, hints
+        , minimum_planner_speed_sqr
       )
   ) {
     // Movement was not queued, probably because it was too short.
     //  Simply accept that as movement queued and done
     return true;
   }
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
     // give the planner an opportunity to queue more movements and plan them
     // As there are no queued movements, the Stepper ISR will not touch this
     // variable, so there is no risk setting this here (but it MUST be done
     // before the following line!!)
     delay_before_delivering = TERN_(FT_MOTION, ftMotion.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
   }
 
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
+  // find a speed from which the new block can stop safely
+  const float safe_exit_speed_sqr = _MAX(
+    TERN0(HINTS_SAFE_EXIT_SPEED, hints.safe_exit_speed_sqr),
+    minimum_planner_speed_sqr
+  );
+
   // Recalculate and optimize trapezoidal speed profiles
-  recalculate(TERN_(HINTS_SAFE_EXIT_SPEED, hints.safe_exit_speed_sqr));
+  recalculate(safe_exit_speed_sqr);
 
   // Movement successfully queued!
   return true;
 }
 
 /**
  * @brief Populate a block in preparation for insertion
  * @details Populate the fields of a new linear movement block
  *          that will be added to the queue and processed soon
  *          by the Stepper ISR.
@@ -1875,20 +1884,21 @@ bool Planner::_buffer_steps(const xyze_long_t &target
  * @param hints         parameters to aid planner calculations
  *
  * @return  true if movement is acceptable, false otherwise
  */
 bool Planner::_populate_block(
   block_t * const block,
   const abce_long_t &target
   OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
   OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
   , feedRate_t fr_mm_s, const uint8_t extruder, const PlannerHints &hints
+  , float &minimum_planner_speed_sqr
 ) {
   xyze_long_t dist = target - position;
 
   /* <-- add a slash to enable
     SERIAL_ECHOLNPGM(
       "  _populate_block FR:", fr_mm_s,
       #if HAS_X_AXIS
         " A:", target.a, " (", dist.a, " steps)"
       #endif
       #if HAS_Y_AXIS
@@ -2309,20 +2319,23 @@ bool Planner::_populate_block(
   #if ANY(SLOWDOWN, HAS_WIRED_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time in microseconds
     int32_t segment_time_us = LROUND(1000000.0f / inverse_secs);
   #endif
 
   #if ENABLED(SLOWDOWN)
     #ifndef SLOWDOWN_DIVISOR
       #define SLOWDOWN_DIVISOR 2
     #endif
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / (SLOWDOWN_DIVISOR) - 1)) {
+      #ifdef MAX7219_DEBUG_SLOWDOWN
+        slowdown_count = (slowdown_count + 1) & 0x0F;
+      #endif
       const int32_t time_diff = settings.min_segment_time_us - segment_time_us;
       if (time_diff > 0) {
         // Buffer is draining so add extra time. The amount of time added increases if the buffer is still emptied more.
         const int32_t nst = segment_time_us + LROUND(2 * time_diff / moves_queued);
         inverse_secs = 1000000.0f / nst;
         #if defined(XY_FREQUENCY_LIMIT) || HAS_WIRED_LCD
           segment_time_us = nst;
         #endif
       }
     }
@@ -2541,20 +2554,24 @@ bool Planner::_populate_block(
       for (uint32_t dividend = block->steps.e << 1; dividend <= (block->step_event_count >> 2); dividend <<= 1)
         block->la_scaling++;
 
       #if ENABLED(LA_DEBUG)
         if (block->la_advance_rate >> block->la_scaling > 10000)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz: ", block->la_advance_rate);
       #endif
     }
   #endif
 
+  // The minimum possible speed is the average speed for
+  // the first / last step at current acceleration limit
+  minimum_planner_speed_sqr = 0.5f * block->acceleration / steps_per_mm;
+
   float vmax_junction_sqr; // Initial limit on the segment entry velocity (mm/s)^2
 
   #if HAS_JUNCTION_DEVIATION
     /**
      * Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
      * Let a circle be tangent to both previous and current path line segments, where the junction
      * deviation is defined as the distance from the junction to the closest edge of the circle,
      * colinear with the circle center. The circular segment joining the two paths represents the
      * path of centripetal acceleration. Solve for max velocity based on max acceleration about the
      * radius of the circle, defined indirectly by junction deviation. This may be also viewed as
@@ -2623,21 +2640,21 @@ bool Planner::_populate_block(
                                  + (-prev_unit_vec.j * unit_vec.j),
                                  + (-prev_unit_vec.k * unit_vec.k),
                                  + (-prev_unit_vec.u * unit_vec.u),
                                  + (-prev_unit_vec.v * unit_vec.v),
                                  + (-prev_unit_vec.w * unit_vec.w)
                                );
 
       // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
       if (junction_cos_theta > 0.999999f) {
         // For a 0 degree acute junction, just set minimum junction speed.
-        vmax_junction_sqr = sq(float(MINIMUM_PLANNER_SPEED));
+        vmax_junction_sqr = minimum_planner_speed_sqr;
       }
       else {
         // Convert delta vector to unit vector
         xyze_float_t junction_unit_vec = unit_vec - prev_unit_vec;
         normalize_junction_vector(junction_unit_vec);
 
         const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec);
 
         if (TERN0(HINTS_CURVE_RADIUS, hints.curve_radius)) {
           TERN_(HINTS_CURVE_RADIUS, vmax_junction_sqr = junction_acceleration * hints.curve_radius);
@@ -2831,36 +2848,38 @@ bool Planner::_populate_block(
       // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
       const float vmax_junction_threshold = vmax_junction * 0.99f;
       if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold)
         vmax_junction = safe_speed;
     }
     else
       vmax_junction = safe_speed;
 
     previous_safe_speed = safe_speed;
 
+    NOLESS(minimum_planner_speed_sqr, sq(safe_speed));
+
     #if HAS_JUNCTION_DEVIATION
       NOMORE(vmax_junction_sqr, sq(vmax_junction));   // Throttle down to max speed
     #else
       vmax_junction_sqr = sq(vmax_junction);          // Go up or down to the new speed
     #endif
 
   #endif // Classic Jerk Limiting
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed_sqr = vmax_junction_sqr;
 
-  // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
-  const float v_allowable_sqr = max_allowable_speed_sqr(-block->acceleration, sq(float(MINIMUM_PLANNER_SPEED)), block->millimeters);
+  // Initialize block entry speed. Compute based on deceleration to sqrt(minimum_planner_speed_sqr).
+  const float v_allowable_sqr = max_allowable_speed_sqr(-block->acceleration, minimum_planner_speed_sqr, block->millimeters);
 
   // Start with the minimum allowed speed
-  block->entry_speed_sqr = sq(float(MINIMUM_PLANNER_SPEED));
+  block->entry_speed_sqr = minimum_planner_speed_sqr;
 
   // Initialize planner efficiency flags
   // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
   // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
   // the current block and next block junction speeds are guaranteed to always be at their maximum
   // junction speeds in deceleration and acceleration, respectively. This is due to how the current
   // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
   block->flag.set_nominal(sq(block->nominal_speed) <= v_allowable_sqr);

commit e7e77d9612253cf7106cfc9e69f69e52f4083294
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 12 09:44:46 2023 -0500

    üßë‚Äçüíª FxdTiCtrl => FTMotion

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 9b8b268927..0916ade581 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -222,24 +222,20 @@ float Planner::previous_nominal_speed;
 #if ENABLED(DISABLE_OTHER_EXTRUDERS)
   last_move_t Planner::extruder_last_move[E_STEPPERS] = { 0 };
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
   int8_t Planner::xy_freq_limit_hz = XY_FREQUENCY_LIMIT;
   float Planner::xy_freq_min_speed_factor = (XY_FREQUENCY_MIN_PERCENT) * 0.01f;
   int32_t Planner::xy_freq_min_interval_us = LROUND(1000000.0f / (XY_FREQUENCY_LIMIT));
 #endif
 
-#if ENABLED(FT_MOTION)
-  bool Planner::fxdTiCtrl_busy = false;
-#endif
-
 #if ENABLED(LIN_ADVANCE)
   float Planner::extruder_advance_K[DISTINCT_E]; // Initialized by settings.load()
 #endif
 
 #if HAS_POSITION_FLOAT
   xyze_pos_t Planner::position_float; // Needed for accurate maths. Steps cannot be used!
 #endif
 
 #if IS_KINEMATIC
   xyze_pos_t Planner::position_cart;
@@ -1685,21 +1681,21 @@ void Planner::quick_stop() {
   // so this must be enclosed in a critical section
 
   const bool was_enabled = stepper.suspend();
 
   // Drop all queue entries
   block_buffer_nonbusy = block_buffer_planned = block_buffer_head = block_buffer_tail;
 
   // Restart the block delay for the first movement - As the queue was
   // forced to empty, there's no risk the ISR will touch this.
 
-  delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
+  delay_before_delivering = TERN_(FT_MOTION, ftMotion.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
 
   TERN_(HAS_WIRED_LCD, clear_block_buffer_runtime()); // Clear the accumulated runtime
 
   // Make sure to drop any attempt of queuing moves for 1 second
   cleaning_buffer_counter = TEMP_TIMER_FREQUENCY;
 
   // Reenable Stepper ISR
   if (was_enabled) stepper.wake_up();
 
   // And stop the stepper ISR
@@ -1731,21 +1727,21 @@ void Planner::endstop_triggered(const AxisEnum axis) {
 
 float Planner::triggered_position_mm(const AxisEnum axis) {
   const float result = DIFF_TERN(BACKLASH_COMPENSATION, stepper.triggered_position(axis), backlash.get_applied_steps(axis));
   return result * mm_per_step[axis];
 }
 
 bool Planner::busy() {
   return (has_blocks_queued() || cleaning_buffer_counter
       || TERN0(EXTERNAL_CLOSED_LOOP_CONTROLLER, CLOSED_LOOP_WAITING())
       || TERN0(HAS_ZV_SHAPING, stepper.input_shaping_busy())
-      || TERN0(FT_MOTION, fxdTiCtrl_busy)
+      || TERN0(FT_MOTION, ftMotion.busy)
   );
 }
 
 void Planner::finish_and_disable() {
   while (has_blocks_queued() || cleaning_buffer_counter) idle();
   stepper.disable_all_steppers();
 }
 
 /**
  * Get an axis position according to stepper position(s)
@@ -1844,21 +1840,21 @@ bool Planner::_buffer_steps(const xyze_long_t &target
     return true;
   }
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
     // give the planner an opportunity to queue more movements and plan them
     // As there are no queued movements, the Stepper ISR will not touch this
     // variable, so there is no risk setting this here (but it MUST be done
     // before the following line!!)
-    delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
+    delay_before_delivering = TERN_(FT_MOTION, ftMotion.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
   }
 
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
   // Recalculate and optimize trapezoidal speed profiles
   recalculate(TERN_(HINTS_SAFE_EXIT_SPEED, hints.safe_exit_speed_sqr));
 
   // Movement successfully queued!
   return true;
@@ -2917,21 +2913,21 @@ void Planner::buffer_sync_block(const BlockFlagBit sync_flag/*=BLOCK_BIT_SYNC_PO
    */
   TERN_(LASER_POWER_SYNC, block->laser.power = cutter.power);
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
     // give the planner an opportunity to queue more movements and plan them
     // As there are no queued movements, the Stepper ISR will not touch this
     // variable, so there is no risk setting this here (but it MUST be done
     // before the following line!!)
-    delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
+    delay_before_delivering = TERN_(FT_MOTION, ftMotion.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
   }
 
   block_buffer_head = next_buffer_head;
 
   stepper.wake_up();
 } // buffer_sync_block()
 
 /**
  * @brief Add a single linear movement
  *
@@ -3210,21 +3206,21 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s
       LOGICAL_AXIS_MAP(PAGE_UPDATE_DIR);
     }
 
     // If this is the first added movement, reload the delay, otherwise, cancel it.
     if (block_buffer_head == block_buffer_tail) {
       // If it was the first queued block, restart the 1st block delivery delay, to
       // give the planner an opportunity to queue more movements and plan them
       // As there are no queued movements, the Stepper ISR will not touch this
       // variable, so there is no risk setting this here (but it MUST be done
       // before the following line!!)
-      delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
+      delay_before_delivering = TERN_(FT_MOTION, ftMotion.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
     }
 
     // Move buffer head
     block_buffer_head = next_buffer_head;
 
     stepper.enable_all_steppers();
     stepper.wake_up();
   }
 
 #endif // DIRECT_STEPPING

commit e9b9d634c4ef5d48791de84545ef86d46909fec0
Author: Andrew Bortz <andrew@abortz.net>
Date:   Tue Oct 10 20:24:48 2023 -0700

    ‚ú® Nonlinear Extrusion Control (M592) (#26127)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 6b645fa133..9b8b268927 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1998,21 +1998,21 @@ bool Planner::_populate_block(
   #endif
 
   SECONDARY_AXIS_CODE(
     dm.i = (dist.i > 0), dm.j = (dist.j > 0), dm.k = (dist.k > 0),
     dm.u = (dist.u > 0), dm.v = (dist.v > 0), dm.w = (dist.w > 0)
   );
 
   #if HAS_EXTRUDERS
     dm.e = (dist.e > 0);
     const float esteps_float = dist.e * e_factor[extruder];
-    const uint32_t esteps = ABS(esteps_float) + 0.5f;
+    const uint32_t esteps = ABS(esteps_float);
   #else
     constexpr uint32_t esteps = 0;
   #endif
 
   // Clear all flags, including the "busy" bit
   block->flag.clear();
 
   // Set direction bits
   block->direction_bits = dm;
 

commit 7680fe2b59c9861c0e6acb13cf085ca55d7deddc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 5 16:01:32 2023 -0500

    üßë‚Äçüíª Dir change is AxisBits
    
    Followup to #25761

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 10b8ca8670..6b645fa133 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2412,22 +2412,22 @@ bool Planner::_populate_block(
       old_direction_bits = block->direction_bits;
       segment_time_us = LROUND(float(segment_time_us) / speed_factor);
 
       static int32_t xs0, xs1, xs2, ys0, ys1, ys2;
       if (segment_time_us > xy_freq_min_interval_us)
         xs2 = xs1 = ys2 = ys1 = xy_freq_min_interval_us;
       else {
         xs2 = xs1; xs1 = xs0;
         ys2 = ys1; ys1 = ys0;
       }
-      xs0 = TEST(direction_change, X_AXIS) ? segment_time_us : xy_freq_min_interval_us;
-      ys0 = TEST(direction_change, Y_AXIS) ? segment_time_us : xy_freq_min_interval_us;
+      xs0 = direction_change.x ? segment_time_us : xy_freq_min_interval_us;
+      ys0 = direction_change.y ? segment_time_us : xy_freq_min_interval_us;
 
       if (segment_time_us < xy_freq_min_interval_us) {
         const int32_t least_xy_segment_time = _MIN(_MAX(xs0, xs1, xs2), _MAX(ys0, ys1, ys2));
         if (least_xy_segment_time < xy_freq_min_interval_us) {
           float freq_xy_feedrate = (speed_factor * least_xy_segment_time) / xy_freq_min_interval_us;
           NOLESS(freq_xy_feedrate, xy_freq_min_speed_factor);
           NOMORE(speed_factor, freq_xy_feedrate);
         }
       }
     }

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 1d3bb268ef..10b8ca8670 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1513,21 +1513,21 @@ void Planner::check_axes_activity() {
    */
   inline float calculate_volumetric_multiplier(const_float_t diameter) {
     return (parser.volumetric_enabled && diameter) ? 1.0f / CIRCLE_AREA(diameter * 0.5f) : 1;
   }
 
   /**
    * Convert the filament sizes into volumetric multipliers.
    * The multiplier converts a given E value into a length.
    */
   void Planner::calculate_volumetric_multipliers() {
-    LOOP_L_N(i, COUNT(filament_size)) {
+    for (uint8_t i = 0; i < COUNT(filament_size); ++i) {
       volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
       refresh_e_factor(i);
     }
     #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
       calculate_volumetric_extruder_limits(); // update volumetric_extruder_limits as well.
     #endif
   }
 
 #endif // !NO_VOLUMETRICS
 
@@ -2253,21 +2253,21 @@ bool Planner::_populate_block(
   #endif
 
   // Enable extruder(s)
   #if HAS_EXTRUDERS
     if (esteps) {
       TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
       #if ENABLED(DISABLE_OTHER_EXTRUDERS) // Enable only the selected extruder
 
         // Count down all steppers that were recently moved
-        LOOP_L_N(i, E_STEPPERS)
+        for (uint8_t i = 0; i < E_STEPPERS; ++i)
           if (extruder_last_move[i]) extruder_last_move[i]--;
 
         // Switching Extruder uses one E stepper motor per two nozzles
         #define E_STEPPER_INDEX(E) TERN(HAS_SWITCHING_EXTRUDER, (E) / 2, E)
 
         // Enable all (i.e., both) E steppers for IDEX-style duplication, but only active E steppers for multi-nozzle (i.e., single wide X carriage) duplication
         #define _IS_DUPE(N) TERN0(HAS_DUPLICATION_MODE, (extruder_duplication_enabled && TERN1(MULTI_NOZZLE_DUPLICATION, TEST(duplication_e_mask, N))))
 
         #define ENABLE_ONE_E(N) do{ \
           if (N == E_STEPPER_INDEX(extruder) || _IS_DUPE(N)) {  /* N is 'extruder', or N is duplicating */ \

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 02a7d05cae..1d3bb268ef 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -788,21 +788,21 @@ block_t* Planner::get_current_block() {
  */
 void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t entry_factor, const_float_t exit_factor) {
 
   uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
            final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
 
   // Limit minimal step rate (Otherwise the timer will overflow.)
   NOLESS(initial_rate, uint32_t(MINIMAL_STEP_RATE));
   NOLESS(final_rate, uint32_t(MINIMAL_STEP_RATE));
 
-  #if EITHER(S_CURVE_ACCELERATION, LIN_ADVANCE)
+  #if ANY(S_CURVE_ACCELERATION, LIN_ADVANCE)
     // If we have some plateau time, the cruise rate will be the nominal rate
     uint32_t cruise_rate = block->nominal_rate;
   #endif
 
   // Steps for acceleration, plateau and deceleration
   int32_t plateau_steps = block->step_event_count;
   uint32_t accelerate_steps = 0,
            decelerate_steps = 0;
 
   const int32_t accel = block->acceleration_steps_per_s2;
@@ -822,21 +822,21 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
 
     // Does accelerate_steps + decelerate_steps exceed step_event_count?
     // Then we can't possibly reach the nominal rate, there will be no cruising.
     // Calculate accel / braking time in order to reach the final_rate exactly
     // at the end of this block.
     if (plateau_steps < 0) {
       accelerate_steps_float = CEIL((block->step_event_count + accelerate_steps_float - decelerate_steps_float) * 0.5f);
       accelerate_steps = _MIN(uint32_t(_MAX(accelerate_steps_float, 0)), block->step_event_count);
       decelerate_steps = block->step_event_count - accelerate_steps;
 
-      #if EITHER(S_CURVE_ACCELERATION, LIN_ADVANCE)
+      #if ANY(S_CURVE_ACCELERATION, LIN_ADVANCE)
         // We won't reach the cruising rate. Let's calculate the speed we will reach
         cruise_rate = final_speed(initial_rate, accel, accelerate_steps);
       #endif
     }
   }
 
   #if ENABLED(S_CURVE_ACCELERATION)
     const float rate_factor = inverse_accel * (STEPPER_TIMER_RATE);
     // Jerk controlled speed requires to express speed versus time, NOT steps
     uint32_t acceleration_time = rate_factor * float(cruise_rate - initial_rate),
@@ -1342,21 +1342,21 @@ void Planner::check_axes_activity() {
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
     #endif
     #if HAS_HEATER_2
       uint8_t tail_e_to_p_pressure;
     #endif
   #endif
 
   if (has_blocks_queued()) {
 
-    #if EITHER(HAS_TAIL_FAN_SPEED, BARICUDA)
+    #if ANY(HAS_TAIL_FAN_SPEED, BARICUDA)
       block_t *block = &block_buffer[block_buffer_tail];
     #endif
 
     #if HAS_TAIL_FAN_SPEED
       FANS_LOOP(i) {
         const uint8_t spd = thermalManager.scaledFanSpeed(i, block->fan_speed[i]);
         if (tail_fan_speed[i] != spd) {
           fans_need_update = true;
           tail_fan_speed[i] = spd;
         }
@@ -1766,21 +1766,21 @@ float Planner::get_axis_position_mm(const AxisEnum axis) {
 
       if (was_enabled) stepper.wake_up();
 
       // ((a1+a2)+(a1-a2))/2 -> (a1+a2+a1-a2)/2 -> (a1+a1)/2 -> a1
       // ((a1+a2)-(a1-a2))/2 -> (a1+a2-a1+a2)/2 -> (a2+a2)/2 -> a2
       axis_steps = (axis == CORE_AXIS_2 ? CORESIGN(p1 - p2) : p1 + p2) * 0.5f;
     }
     else
       axis_steps = DIFF_TERN(BACKLASH_COMPENSATION, stepper.position(axis), backlash.get_applied_steps(axis));
 
-  #elif EITHER(MARKFORGED_XY, MARKFORGED_YX)
+  #elif ANY(MARKFORGED_XY, MARKFORGED_YX)
 
     // Requesting one of the joined axes?
     if (axis == CORE_AXIS_1 || axis == CORE_AXIS_2) {
       // Protect the access to the position.
       const bool was_enabled = stepper.suspend();
 
       const int32_t p1 = stepper.position(CORE_AXIS_1),
                     p2 = stepper.position(CORE_AXIS_2);
 
       if (was_enabled) stepper.wake_up();
@@ -1918,21 +1918,21 @@ bool Planner::_populate_block(
       #endif
       #if HAS_W_AXIS
         " " STR_W ":", target.w, " (", dist.w, " steps)"
       #endif
       #if HAS_EXTRUDERS
         " E:", target.e, " (", dist.e, " steps)"
       #endif
     );
   //*/
 
-  #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
+  #if ANY(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
     if (dist.e) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position.e = target.e; // Behave as if the move really took place, but ignore E part
           TERN_(HAS_POSITION_FLOAT, position_float.e = target_float.e);
           dist.e = 0; // no difference
           SERIAL_ECHO_MSG(STR_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
@@ -2292,32 +2292,32 @@ bool Planner::_populate_block(
     NOLESS(fr_mm_s, settings.min_feedrate_mm_s);
   else
     NOLESS(fr_mm_s, settings.min_travel_feedrate_mm_s);
 
   const float inverse_millimeters = 1.0f / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate inverse time for this move. No divide by zero due to previous checks.
   // Example: At 120mm/s a 60mm move involving XYZ axes takes 0.5s. So this will give 2.0.
   // Example 2: At 120¬∞/s a 60¬∞ move involving only rotational axes takes 0.5s. So this will give 2.0.
   float inverse_secs = inverse_millimeters * (
-    #if BOTH(HAS_ROTATIONAL_AXES, INCH_MODE_SUPPORT)
+    #if ALL(HAS_ROTATIONAL_AXES, INCH_MODE_SUPPORT)
       cartesian_move ? fr_mm_s : LINEAR_UNIT(fr_mm_s)
     #else
       fr_mm_s
     #endif
   );
 
   // Get the number of non busy movements in queue (non busy means that they can be altered)
   const uint8_t moves_queued = nonbusy_movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
-  #if EITHER(SLOWDOWN, HAS_WIRED_LCD) || defined(XY_FREQUENCY_LIMIT)
+  #if ANY(SLOWDOWN, HAS_WIRED_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time in microseconds
     int32_t segment_time_us = LROUND(1000000.0f / inverse_secs);
   #endif
 
   #if ENABLED(SLOWDOWN)
     #ifndef SLOWDOWN_DIVISOR
       #define SLOWDOWN_DIVISOR 2
     #endif
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / (SLOWDOWN_DIVISOR) - 1)) {
       const int32_t time_diff = settings.min_segment_time_us - segment_time_us;
@@ -2900,21 +2900,21 @@ void Planner::buffer_sync_block(const BlockFlagBit sync_flag/*=BLOCK_BIT_SYNC_PO
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Clear block
   block->reset();
   block->flag.apply(sync_flag);
 
   block->position = position;
   #if ENABLED(BACKLASH_COMPENSATION)
     LOOP_NUM_AXES(axis) block->position[axis] += backlash.get_applied_steps((AxisEnum)axis);
   #endif
-  #if BOTH(HAS_FAN, LASER_SYNCHRONOUS_M106_M107)
+  #if ALL(HAS_FAN, LASER_SYNCHRONOUS_M106_M107)
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   /**
    * M3-based power setting can be processed inline with a laser power sync block.
    * During active moves cutter.power is processed immediately, otherwise on the next move.
    */
   TERN_(LASER_POWER_SYNC, block->laser.power = cutter.power);
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.

commit ed66f498eb713f59f14d000f8bfa550b34ce8528
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 16 02:38:24 2023 -0500

    üö∏ Fixed-Time Motion EEPROM and Menu (#25835)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index b0d0b3e353..02a7d05cae 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1685,21 +1685,21 @@ void Planner::quick_stop() {
   // so this must be enclosed in a critical section
 
   const bool was_enabled = stepper.suspend();
 
   // Drop all queue entries
   block_buffer_nonbusy = block_buffer_planned = block_buffer_head = block_buffer_tail;
 
   // Restart the block delay for the first movement - As the queue was
   // forced to empty, there's no risk the ISR will touch this.
 
-  delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg_mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
+  delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
 
   TERN_(HAS_WIRED_LCD, clear_block_buffer_runtime()); // Clear the accumulated runtime
 
   // Make sure to drop any attempt of queuing moves for 1 second
   cleaning_buffer_counter = TEMP_TIMER_FREQUENCY;
 
   // Reenable Stepper ISR
   if (was_enabled) stepper.wake_up();
 
   // And stop the stepper ISR
@@ -1844,21 +1844,21 @@ bool Planner::_buffer_steps(const xyze_long_t &target
     return true;
   }
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
     // give the planner an opportunity to queue more movements and plan them
     // As there are no queued movements, the Stepper ISR will not touch this
     // variable, so there is no risk setting this here (but it MUST be done
     // before the following line!!)
-    delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg_mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
+    delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
   }
 
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
   // Recalculate and optimize trapezoidal speed profiles
   recalculate(TERN_(HINTS_SAFE_EXIT_SPEED, hints.safe_exit_speed_sqr));
 
   // Movement successfully queued!
   return true;
@@ -2917,21 +2917,21 @@ void Planner::buffer_sync_block(const BlockFlagBit sync_flag/*=BLOCK_BIT_SYNC_PO
    */
   TERN_(LASER_POWER_SYNC, block->laser.power = cutter.power);
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
     // give the planner an opportunity to queue more movements and plan them
     // As there are no queued movements, the Stepper ISR will not touch this
     // variable, so there is no risk setting this here (but it MUST be done
     // before the following line!!)
-    delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg_mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
+    delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
   }
 
   block_buffer_head = next_buffer_head;
 
   stepper.wake_up();
 } // buffer_sync_block()
 
 /**
  * @brief Add a single linear movement
  *
@@ -3210,21 +3210,21 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s
       LOGICAL_AXIS_MAP(PAGE_UPDATE_DIR);
     }
 
     // If this is the first added movement, reload the delay, otherwise, cancel it.
     if (block_buffer_head == block_buffer_tail) {
       // If it was the first queued block, restart the 1st block delivery delay, to
       // give the planner an opportunity to queue more movements and plan them
       // As there are no queued movements, the Stepper ISR will not touch this
       // variable, so there is no risk setting this here (but it MUST be done
       // before the following line!!)
-      delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg_mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
+      delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg.mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
     }
 
     // Move buffer head
     block_buffer_head = next_buffer_head;
 
     stepper.enable_all_steppers();
     stepper.wake_up();
   }
 
 #endif // DIRECT_STEPPING

commit 25ddde0394361c23194c0f4a8f9777d389040af3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 15 22:00:15 2023 -0500

    üßë‚Äçüíª Change Marlin DIR bits: 1=Forward, 0=Reverse (#25791)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index a2d7e6843b..b0d0b3e353 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -162,21 +162,21 @@ float Planner::mm_per_step[DISTINCT_AXES];      // (mm) Millimeters per step
 #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
 #if ENABLED(DIRECT_STEPPING)
   uint32_t Planner::last_page_step_rate = 0;
-  xyze_bool_t Planner::last_page_dir{0};
+  AxisBits Planner::last_page_dir; // = 0
 #endif
 
 #if HAS_EXTRUDERS
   int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
   float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0f); // The flow percentage and volumetric multiplier combine to scale E movement
 #endif
 
 #if DISABLED(NO_VOLUMETRICS)
   float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
         Planner::volumetric_area_nominal = CIRCLE_AREA(float(DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5f), // Nominal cross-sectional area
@@ -1880,149 +1880,138 @@ bool Planner::_buffer_steps(const xyze_long_t &target
  *
  * @return  true if movement is acceptable, false otherwise
  */
 bool Planner::_populate_block(
   block_t * const block,
   const abce_long_t &target
   OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
   OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
   , feedRate_t fr_mm_s, const uint8_t extruder, const PlannerHints &hints
 ) {
-  int32_t LOGICAL_AXIS_LIST(
-    de = target.e - position.e,
-    da = target.a - position.a,
-    db = target.b - position.b,
-    dc = target.c - position.c,
-    di = target.i - position.i,
-    dj = target.j - position.j,
-    dk = target.k - position.k,
-    du = target.u - position.u,
-    dv = target.v - position.v,
-    dw = target.w - position.w
-  );
+  xyze_long_t dist = target - position;
 
   /* <-- add a slash to enable
     SERIAL_ECHOLNPGM(
       "  _populate_block FR:", fr_mm_s,
       #if HAS_X_AXIS
-        " A:", target.a, " (", da, " steps)"
+        " A:", target.a, " (", dist.a, " steps)"
       #endif
       #if HAS_Y_AXIS
-        " B:", target.b, " (", db, " steps)"
+        " B:", target.b, " (", dist.b, " steps)"
       #endif
       #if HAS_Z_AXIS
-        " C:", target.c, " (", dc, " steps)"
+        " C:", target.c, " (", dist.c, " steps)"
       #endif
       #if HAS_I_AXIS
-        " " STR_I ":", target.i, " (", di, " steps)"
+        " " STR_I ":", target.i, " (", dist.i, " steps)"
       #endif
       #if HAS_J_AXIS
-        " " STR_J ":", target.j, " (", dj, " steps)"
+        " " STR_J ":", target.j, " (", dist.j, " steps)"
       #endif
       #if HAS_K_AXIS
-        " " STR_K ":", target.k, " (", dk, " steps)"
+        " " STR_K ":", target.k, " (", dist.k, " steps)"
       #endif
       #if HAS_U_AXIS
-        " " STR_U ":", target.u, " (", du, " steps)"
+        " " STR_U ":", target.u, " (", dist.u, " steps)"
       #endif
       #if HAS_V_AXIS
-        " " STR_V ":", target.v, " (", dv, " steps)"
+        " " STR_V ":", target.v, " (", dist.v, " steps)"
       #endif
       #if HAS_W_AXIS
-        " " STR_W ":", target.w, " (", dw, " steps)"
+        " " STR_W ":", target.w, " (", dist.w, " steps)"
       #endif
       #if HAS_EXTRUDERS
-        " E:", target.e, " (", de, " steps)"
+        " E:", target.e, " (", dist.e, " steps)"
       #endif
     );
   //*/
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
-    if (de) {
+    if (dist.e) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position.e = target.e; // Behave as if the move really took place, but ignore E part
           TERN_(HAS_POSITION_FLOAT, position_float.e = target_float.e);
-          de = 0; // no difference
+          dist.e = 0; // no difference
           SERIAL_ECHO_MSG(STR_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-        const float e_steps = ABS(de * e_factor[extruder]);
+        const float e_steps = ABS(dist.e * e_factor[extruder]);
         const float max_e_steps = settings.axis_steps_per_mm[E_AXIS_N(extruder)] * (EXTRUDE_MAXLENGTH);
         if (e_steps > max_e_steps) {
           #if ENABLED(MIXING_EXTRUDER)
             bool ignore_e = false;
             float collector[MIXING_STEPPERS];
             mixer.refresh_collector(1.0f, mixer.get_current_vtool(), collector);
             MIXER_STEPPER_LOOP(e)
               if (e_steps * collector[e] > max_e_steps) { ignore_e = true; break; }
           #else
             constexpr bool ignore_e = true;
           #endif
           if (ignore_e) {
             position.e = target.e; // Behave as if the move really took place, but ignore E part
             TERN_(HAS_POSITION_FLOAT, position_float.e = target_float.e);
-            de = 0; // no difference
+            dist.e = 0; // no difference
             SERIAL_ECHO_MSG(STR_ERR_LONG_EXTRUDE_STOP);
           }
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   // Compute direction bit-mask for this block
   AxisBits dm;
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
-    dm.hx = (da < 0);                 // Save the toolhead's true direction in X
-    dm.hy = (db < 0);                 // ...and Y
-    TERN_(HAS_Z_AXIS, dm.z = (dc < 0));
+    dm.hx = (dist.a > 0);                       // Save the toolhead's true direction in X
+    dm.hy = (dist.b > 0);                       // ...and Y
+    TERN_(HAS_Z_AXIS, dm.z = (dist.c > 0));
   #endif
   #if IS_CORE
     #if CORE_IS_XY
-      dm.a = (da + db < 0);           // Motor A direction
-      dm.b = (CORESIGN(da - db) < 0); // Motor B direction
+      dm.a = (dist.a + dist.b > 0);             // Motor A direction
+      dm.b = (CORESIGN(dist.a - dist.b) > 0);   // Motor B direction
     #elif CORE_IS_XZ
-      dm.hx = (da < 0);               // Save the toolhead's true direction in X
-      dm.y = (db < 0);
-      dm.hz = (dc < 0);               // ...and Z
-      dm.a = (da + dc < 0);           // Motor A direction
-      dm.c = (CORESIGN(da - dc) < 0); // Motor C direction
+      dm.hx = (dist.a > 0);                     // Save the toolhead's true direction in X
+      dm.y  = (dist.b > 0);
+      dm.hz = (dist.c > 0);                     // ...and Z
+      dm.a  = (dist.a + dist.c > 0);            // Motor A direction
+      dm.c  = (CORESIGN(dist.a - dist.c) > 0);  // Motor C direction
     #elif CORE_IS_YZ
-      dm.x = (da < 0);
-      dm.hy = (db < 0);               // Save the toolhead's true direction in Y
-      dm.hz = (dc < 0);               // ...and Z
-      dm.b = (db + dc < 0);           // Motor B direction
-      dm.c = (CORESIGN(db - dc) < 0); // Motor C direction
+      dm.x  = (dist.a > 0);
+      dm.hy = (dist.b > 0);                     // Save the toolhead's true direction in Y
+      dm.hz = (dist.c > 0);                     // ...and Z
+      dm.b  = (dist.b + dist.c > 0);            // Motor B direction
+      dm.c  = (CORESIGN(dist.b - dist.c) > 0);  // Motor C direction
     #endif
   #elif ENABLED(MARKFORGED_XY)
-    dm.a = (da + db < 0);             // Motor A direction
-    dm.b = (db < 0);                  // Motor B direction
+    dm.a = (dist.a + dist.b > 0);               // Motor A direction
+    dm.b = (dist.b > 0);                        // Motor B direction
   #elif ENABLED(MARKFORGED_YX)
-    dm.a = (da < 0);                  // Motor A direction
-    dm.b = (db + da < 0);             // Motor B direction
+    dm.a = (dist.a > 0);                        // Motor A direction
+    dm.b = (dist.b + dist.a > 0);               // Motor B direction
   #else
     XYZ_CODE(
-      dm.x = (da < 0),
-      dm.y = (db < 0),
-      dm.z = (dc < 0)
+      dm.x = (dist.a > 0),
+      dm.y = (dist.b > 0),
+      dm.z = (dist.c > 0)
     );
   #endif
 
   SECONDARY_AXIS_CODE(
-    dm.i = (di < 0), dm.j = (dj < 0), dm.k = (dk < 0),
-    dm.u = (du < 0), dm.v = (dv < 0), dm.w = (dw < 0)
+    dm.i = (dist.i > 0), dm.j = (dist.j > 0), dm.k = (dist.k > 0),
+    dm.u = (dist.u > 0), dm.v = (dist.v > 0), dm.w = (dist.w > 0)
   );
 
   #if HAS_EXTRUDERS
-    dm.e = (de < 0);
-    const float esteps_float = de * e_factor[extruder];
+    dm.e = (dist.e > 0);
+    const float esteps_float = dist.e * e_factor[extruder];
     const uint32_t esteps = ABS(esteps_float) + 0.5f;
   #else
     constexpr uint32_t esteps = 0;
   #endif
 
   // Clear all flags, including the "busy" bit
   block->flag.clear();
 
   // Set direction bits
   block->direction_bits = dm;
@@ -2054,162 +2043,140 @@ bool Planner::_populate_block(
             block->laser.power = laser_inline.power = cutter.calc_dynamic_power();
           break;
       #endif
     }
   #endif
 
   // Number of steps for each axis
   // See https://www.corexy.com/theory.html
   block->steps.set(NUM_AXIS_LIST(
     #if CORE_IS_XY
-      ABS(da + db), ABS(da - db), ABS(dc)
+      ABS(dist.a + dist.b), ABS(dist.a - dist.b), ABS(dist.c)
     #elif CORE_IS_XZ
-      ABS(da + dc), ABS(db), ABS(da - dc)
+      ABS(dist.a + dist.c), ABS(dist.b), ABS(dist.a - dist.c)
     #elif CORE_IS_YZ
-      ABS(da), ABS(db + dc), ABS(db - dc)
+      ABS(dist.a), ABS(dist.b + dist.c), ABS(dist.b - dist.c)
     #elif ENABLED(MARKFORGED_XY)
-      ABS(da + db), ABS(db), ABS(dc)
+      ABS(dist.a + dist.b), ABS(dist.b), ABS(dist.c)
     #elif ENABLED(MARKFORGED_YX)
-      ABS(da), ABS(db + da), ABS(dc)
+      ABS(dist.a), ABS(dist.b + dist.a), ABS(dist.c)
     #elif IS_SCARA
-      ABS(da), ABS(db), ABS(dc)
+      ABS(dist.a), ABS(dist.b), ABS(dist.c)
     #else // default non-h-bot planning
-      ABS(da), ABS(db), ABS(dc)
+      ABS(dist.a), ABS(dist.b), ABS(dist.c)
     #endif
-    , ABS(di), ABS(dj), ABS(dk), ABS(du), ABS(dv), ABS(dw)
+    , ABS(dist.i), ABS(dist.j), ABS(dist.k), ABS(dist.u), ABS(dist.v), ABS(dist.w)
   ));
 
   /**
    * This part of the code calculates the total length of the movement.
    * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
    * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
    * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
    * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
    * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
    */
   struct DistanceMM : abce_float_t {
     #if ANY(IS_CORE, MARKFORGED_XY, MARKFORGED_YX)
       struct { float x, y, z; } head;
     #endif
-  } steps_dist_mm;
+  } dist_mm;
 
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
-    steps_dist_mm.head.x = da * mm_per_step[A_AXIS];
-    steps_dist_mm.head.y = db * mm_per_step[B_AXIS];
-    TERN_(HAS_Z_AXIS, steps_dist_mm.z = dc * mm_per_step[Z_AXIS]);
+    dist_mm.head.x = dist.a * mm_per_step[A_AXIS];
+    dist_mm.head.y = dist.b * mm_per_step[B_AXIS];
+    TERN_(HAS_Z_AXIS, dist_mm.z = dist.c * mm_per_step[Z_AXIS]);
   #endif
   #if IS_CORE
     #if CORE_IS_XY
-      steps_dist_mm.a      = (da + db) * mm_per_step[A_AXIS];
-      steps_dist_mm.b      = CORESIGN(da - db) * mm_per_step[B_AXIS];
+      dist_mm.a      = (dist.a + dist.b) * mm_per_step[A_AXIS];
+      dist_mm.b      = CORESIGN(dist.a - dist.b) * mm_per_step[B_AXIS];
     #elif CORE_IS_XZ
-      steps_dist_mm.head.x = da * mm_per_step[A_AXIS];
-      steps_dist_mm.y      = db * mm_per_step[Y_AXIS];
-      steps_dist_mm.head.z = dc * mm_per_step[C_AXIS];
-      steps_dist_mm.a      = (da + dc) * mm_per_step[A_AXIS];
-      steps_dist_mm.c      = CORESIGN(da - dc) * mm_per_step[C_AXIS];
+      dist_mm.head.x = dist.a * mm_per_step[A_AXIS];
+      dist_mm.y      = dist.b * mm_per_step[Y_AXIS];
+      dist_mm.head.z = dist.c * mm_per_step[C_AXIS];
+      dist_mm.a      = (dist.a + dist.c) * mm_per_step[A_AXIS];
+      dist_mm.c      = CORESIGN(dist.a - dist.c) * mm_per_step[C_AXIS];
     #elif CORE_IS_YZ
-      steps_dist_mm.x      = da * mm_per_step[X_AXIS];
-      steps_dist_mm.head.y = db * mm_per_step[B_AXIS];
-      steps_dist_mm.head.z = dc * mm_per_step[C_AXIS];
-      steps_dist_mm.b      = (db + dc) * mm_per_step[B_AXIS];
-      steps_dist_mm.c      = CORESIGN(db - dc) * mm_per_step[C_AXIS];
+      dist_mm.x      = dist.a * mm_per_step[X_AXIS];
+      dist_mm.head.y = dist.b * mm_per_step[B_AXIS];
+      dist_mm.head.z = dist.c * mm_per_step[C_AXIS];
+      dist_mm.b      = (dist.b + dist.c) * mm_per_step[B_AXIS];
+      dist_mm.c      = CORESIGN(dist.b - dist.c) * mm_per_step[C_AXIS];
     #endif
   #elif ENABLED(MARKFORGED_XY)
-    steps_dist_mm.a      = (da - db) * mm_per_step[A_AXIS];
-    steps_dist_mm.b      = db * mm_per_step[B_AXIS];
+    dist_mm.a = (dist.a - dist.b) * mm_per_step[A_AXIS];
+    dist_mm.b = dist.b * mm_per_step[B_AXIS];
   #elif ENABLED(MARKFORGED_YX)
-    steps_dist_mm.a      = da * mm_per_step[A_AXIS];
-    steps_dist_mm.b      = (db - da) * mm_per_step[B_AXIS];
+    dist_mm.a = dist.a * mm_per_step[A_AXIS];
+    dist_mm.b = (dist.b - dist.a) * mm_per_step[B_AXIS];
   #else
     XYZ_CODE(
-      steps_dist_mm.a = da * mm_per_step[A_AXIS],
-      steps_dist_mm.b = db * mm_per_step[B_AXIS],
-      steps_dist_mm.c = dc * mm_per_step[C_AXIS]
+      dist_mm.a = dist.a * mm_per_step[A_AXIS],
+      dist_mm.b = dist.b * mm_per_step[B_AXIS],
+      dist_mm.c = dist.c * mm_per_step[C_AXIS]
     );
   #endif
 
   SECONDARY_AXIS_CODE(
-    steps_dist_mm.i = di * mm_per_step[I_AXIS],
-    steps_dist_mm.j = dj * mm_per_step[J_AXIS],
-    steps_dist_mm.k = dk * mm_per_step[K_AXIS],
-    steps_dist_mm.u = du * mm_per_step[U_AXIS],
-    steps_dist_mm.v = dv * mm_per_step[V_AXIS],
-    steps_dist_mm.w = dw * mm_per_step[W_AXIS]
+    dist_mm.i = dist.i * mm_per_step[I_AXIS], dist_mm.j = dist.j * mm_per_step[J_AXIS], dist_mm.k = dist.k * mm_per_step[K_AXIS],
+    dist_mm.u = dist.u * mm_per_step[U_AXIS], dist_mm.v = dist.v * mm_per_step[V_AXIS], dist_mm.w = dist.w * mm_per_step[W_AXIS]
   );
 
-  TERN_(HAS_EXTRUDERS, steps_dist_mm.e = esteps_float * mm_per_step[E_AXIS_N(extruder)]);
+  TERN_(HAS_EXTRUDERS, dist_mm.e = esteps_float * mm_per_step[E_AXIS_N(extruder)]);
 
-  TERN_(LCD_SHOW_E_TOTAL, e_move_accumulator += steps_dist_mm.e);
+  TERN_(LCD_SHOW_E_TOTAL, e_move_accumulator += dist_mm.e);
 
   #if HAS_ROTATIONAL_AXES
     bool cartesian_move = hints.cartesian_move;
   #endif
 
   if (true NUM_AXIS_GANG(
-      && block->steps.a < MIN_STEPS_PER_SEGMENT,
-      && block->steps.b < MIN_STEPS_PER_SEGMENT,
-      && block->steps.c < MIN_STEPS_PER_SEGMENT,
-      && block->steps.i < MIN_STEPS_PER_SEGMENT,
-      && block->steps.j < MIN_STEPS_PER_SEGMENT,
-      && block->steps.k < MIN_STEPS_PER_SEGMENT,
-      && block->steps.u < MIN_STEPS_PER_SEGMENT,
-      && block->steps.v < MIN_STEPS_PER_SEGMENT,
-      && block->steps.w < MIN_STEPS_PER_SEGMENT
+      && block->steps.a < MIN_STEPS_PER_SEGMENT, && block->steps.b < MIN_STEPS_PER_SEGMENT, && block->steps.c < MIN_STEPS_PER_SEGMENT,
+      && block->steps.i < MIN_STEPS_PER_SEGMENT, && block->steps.j < MIN_STEPS_PER_SEGMENT, && block->steps.k < MIN_STEPS_PER_SEGMENT,
+      && block->steps.u < MIN_STEPS_PER_SEGMENT, && block->steps.v < MIN_STEPS_PER_SEGMENT, && block->steps.w < MIN_STEPS_PER_SEGMENT
     )
   ) {
-    block->millimeters = TERN0(HAS_EXTRUDERS, ABS(steps_dist_mm.e));
+    block->millimeters = TERN0(HAS_EXTRUDERS, ABS(dist_mm.e));
   }
   else {
     if (hints.millimeters)
       block->millimeters = hints.millimeters;
     else {
       const xyze_pos_t displacement = LOGICAL_AXIS_ARRAY(
-        steps_dist_mm.e,
+        dist_mm.e,
         #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
-          steps_dist_mm.head.x,
-          steps_dist_mm.head.y,
-          steps_dist_mm.z,
+          dist_mm.head.x, dist_mm.head.y, dist_mm.z,
         #elif CORE_IS_XZ
-          steps_dist_mm.head.x,
-          steps_dist_mm.y,
-          steps_dist_mm.head.z,
+          dist_mm.head.x, dist_mm.y, dist_mm.head.z,
         #elif CORE_IS_YZ
-          steps_dist_mm.x,
-          steps_dist_mm.head.y,
-          steps_dist_mm.head.z,
+          dist_mm.x, dist_mm.head.y, dist_mm.head.z,
         #else
-          steps_dist_mm.x,
-          steps_dist_mm.y,
-          steps_dist_mm.z,
+          dist_mm.x, dist_mm.y, dist_mm.z,
         #endif
-        steps_dist_mm.i,
-        steps_dist_mm.j,
-        steps_dist_mm.k,
-        steps_dist_mm.u,
-        steps_dist_mm.v,
-        steps_dist_mm.w
+        dist_mm.i, dist_mm.j, dist_mm.k,
+        dist_mm.u, dist_mm.v, dist_mm.w
       );
 
       block->millimeters = get_move_distance(displacement OPTARG(HAS_ROTATIONAL_AXES, cartesian_move));
     }
 
     /**
      * At this point at least one of the axes has more steps than
      * MIN_STEPS_PER_SEGMENT, ensuring the segment won't get dropped as
      * zero-length. It's important to not apply corrections
      * to blocks that would get dropped!
      *
      * A correction function is permitted to add steps to an axis, it
      * should *never* remove steps!
      */
-    TERN_(BACKLASH_COMPENSATION, backlash.add_correction_steps(da, db, dc, dm, block));
+    TERN_(BACKLASH_COMPENSATION, backlash.add_correction_steps(dist.a, dist.b, dist.c, dm, block));
   }
 
   TERN_(HAS_EXTRUDERS, block->steps.e = esteps);
 
   block->step_event_count = (
     #if NUM_AXES
       _MAX(LOGICAL_AXIS_LIST(esteps,
         block->steps.a, block->steps.b, block->steps.c,
         block->steps.i, block->steps.j, block->steps.k,
         block->steps.u, block->steps.v, block->steps.w
@@ -2272,26 +2239,23 @@ bool Planner::_populate_block(
       if (block->steps.i) stepper.enable_axis(I_AXIS),
       if (block->steps.j) stepper.enable_axis(J_AXIS),
       if (block->steps.k) stepper.enable_axis(K_AXIS),
       if (block->steps.u) stepper.enable_axis(U_AXIS),
       if (block->steps.v) stepper.enable_axis(V_AXIS),
       if (block->steps.w) stepper.enable_axis(W_AXIS)
     );
   #endif
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
     SECONDARY_AXIS_CODE(
-      if (block->steps.i) stepper.enable_axis(I_AXIS),
-      if (block->steps.j) stepper.enable_axis(J_AXIS),
-      if (block->steps.k) stepper.enable_axis(K_AXIS),
-      if (block->steps.u) stepper.enable_axis(U_AXIS),
-      if (block->steps.v) stepper.enable_axis(V_AXIS),
-      if (block->steps.w) stepper.enable_axis(W_AXIS)
+      if (block->steps.i) stepper.enable_axis(I_AXIS), if (block->steps.j) stepper.enable_axis(J_AXIS),
+      if (block->steps.k) stepper.enable_axis(K_AXIS), if (block->steps.u) stepper.enable_axis(U_AXIS),
+      if (block->steps.v) stepper.enable_axis(V_AXIS), if (block->steps.w) stepper.enable_axis(W_AXIS)
     );
   #endif
 
   // Enable extruder(s)
   #if HAS_EXTRUDERS
     if (esteps) {
       TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
       #if ENABLED(DISABLE_OTHER_EXTRUDERS) // Enable only the selected extruder
 
@@ -2376,40 +2340,40 @@ bool Planner::_populate_block(
     block->segment_time_us = segment_time_us;
 
     if (was_enabled) stepper.wake_up();
   #endif
 
   block->nominal_speed = block->millimeters * inverse_secs;           // (mm/sec) Always > 0
   block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM)   // Only for extruder with filament sensor
-      filwidth.advance_e(steps_dist_mm.e);
+      filwidth.advance_e(dist_mm.e);
   #endif
 
   // Calculate and limit speed in mm/sec (linear) or degrees/sec (rotational)
 
   xyze_float_t current_speed;
   float speed_factor = 1.0f; // factor <1 decreases speed
 
   // Linear axes first with less logic
   LOOP_NUM_AXES(i) {
-    current_speed[i] = steps_dist_mm[i] * inverse_secs;
+    current_speed[i] = dist_mm[i] * inverse_secs;
     const feedRate_t cs = ABS(current_speed[i]),
                  max_fr = settings.max_feedrate_mm_s[i];
     if (cs > max_fr) NOMORE(speed_factor, max_fr / cs);
   }
 
   // Limit speed on extruders, if any
   #if HAS_EXTRUDERS
     {
-      current_speed.e = steps_dist_mm.e * inverse_secs;
+      current_speed.e = dist_mm.e * inverse_secs;
       #if HAS_MIXER_SYNC_CHANNEL
         // Move all mixing extruders at the specified rate
         if (mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)
           current_speed.e *= MIXING_STEPPERS;
       #endif
 
       const feedRate_t cs = ABS(current_speed.e),
                    max_fr = settings.max_feedrate_mm_s[E_AXIS_N(extruder)]
                             * TERN(HAS_MIXER_SYNC_CHANNEL, MIXING_STEPPERS, 1);
 
@@ -2512,23 +2476,23 @@ bool Planner::_populate_block(
       // Linear advance is currently not ready for HAS_I_AXIS
       #define MAX_E_JERK(N) TERN(HAS_LINEAR_E_JERK, max_e_jerk[E_INDEX_N(N)], max_jerk.e)
 
       /**
        * Use LIN_ADVANCE for blocks if all these are true:
        *
        * esteps                       : This is a print move, because we checked for A, B, C steps before.
        *
        * extruder_advance_K[extruder] : There is an advance factor set for this extruder.
        *
-       * de > 0                       : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
+       * dist.e > 0                       : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
        */
-      use_advance_lead = esteps && extruder_advance_K[E_INDEX_N(extruder)] && de > 0;
+      use_advance_lead = esteps && extruder_advance_K[E_INDEX_N(extruder)] && dist.e > 0;
 
       if (use_advance_lead) {
         float e_D_ratio = (target_float.e - position_float.e) /
           TERN(IS_KINEMATIC, block->millimeters,
             SQRT(sq(target_float.x - position_float.x)
                + sq(target_float.y - position_float.y)
                + sq(target_float.z - position_float.z))
           );
 
         // Check for unusual high e_D ratio to detect if a retract move was combined with the last print move due to min. steps per segment. Never execute this with advance!
@@ -2625,24 +2589,24 @@ bool Planner::_populate_block(
           can be spared, a better acos could be used. For all I know, it may be
           already calculated in a different place. */
 
     // Unit vector of previous path line segment
     static xyze_float_t prev_unit_vec;
 
     xyze_float_t unit_vec =
       #if HAS_DIST_MM_ARG
         cart_dist_mm
       #else
-        LOGICAL_AXIS_ARRAY(steps_dist_mm.e,
-          steps_dist_mm.x, steps_dist_mm.y, steps_dist_mm.z,
-          steps_dist_mm.i, steps_dist_mm.j, steps_dist_mm.k,
-          steps_dist_mm.u, steps_dist_mm.v, steps_dist_mm.w)
+        LOGICAL_AXIS_ARRAY(dist_mm.e,
+          dist_mm.x, dist_mm.y, dist_mm.z,
+          dist_mm.i, dist_mm.j, dist_mm.k,
+          dist_mm.u, dist_mm.v, dist_mm.w)
       #endif
     ;
 
     /**
      * On CoreXY the length of the vector [A,B] is SQRT(2) times the length of the head movement vector [X,Y].
      * So taking Z and E into account, we cannot scale to a unit vector with "inverse_millimeters".
      * => normalize the complete junction vector.
      * Elsewise, when needed JD will factor-in the E component
      */
     if (ANY(IS_CORE, MARKFORGED_XY, MARKFORGED_YX) || esteps > 0)
@@ -2797,21 +2761,21 @@ bool Planner::_populate_block(
      */
     // Exit speed limited by a jerk to full halt of a previous last segment
     static float previous_safe_speed;
 
     // Start with a safe speed (from which the machine may halt to stop immediately).
     float safe_speed = block->nominal_speed;
 
     #ifndef TRAVEL_EXTRA_XYJERK
       #define TRAVEL_EXTRA_XYJERK 0
     #endif
-    const float extra_xyjerk = TERN0(HAS_EXTRUDERS, de <= 0) ? TRAVEL_EXTRA_XYJERK : 0;
+    const float extra_xyjerk = TERN0(HAS_EXTRUDERS, dist.e <= 0) ? TRAVEL_EXTRA_XYJERK : 0;
 
     uint8_t limited = 0;
     TERN(HAS_LINEAR_E_JERK, LOOP_NUM_AXES, LOOP_LOGICAL_AXES)(i) {
       const float jerk = ABS(current_speed[i]),   // cs : Starting from zero, change in speed for this axis
                   maxj = (max_jerk[i] + (i == X_AXIS || i == Y_AXIS ? extra_xyjerk : 0.0f)); // mj : The max jerk setting for this axis
       if (jerk > maxj) {                          // cs > mj : New current speed too fast?
         if (limited) {                            // limited already?
           const float mjerk = block->nominal_speed * maxj; // ns*mj
           if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk; // ns*mj/cs
         }
@@ -3232,30 +3196,25 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s
 
     block->page_idx = page_idx;
 
     block->step_event_count = num_steps;
     block->initial_rate = block->final_rate = block->nominal_rate = last_page_step_rate; // steps/s
 
     block->accelerate_until = 0;
     block->decelerate_after = block->step_event_count;
 
     // Will be set to last direction later if directional format.
-    block->direction_bits = 0;
-
-    #define PAGE_UPDATE_DIR(AXIS) \
-      if (!last_page_dir[_AXIS(AXIS)]) SBI(block->direction_bits, _AXIS(AXIS));
+    block->direction_bits.reset();
 
     if (!DirectStepping::Config::DIRECTIONAL) {
-      PAGE_UPDATE_DIR(X);
-      PAGE_UPDATE_DIR(Y);
-      PAGE_UPDATE_DIR(Z);
-      PAGE_UPDATE_DIR(E);
+      #define PAGE_UPDATE_DIR(AXIS) do{ if (last_page_dir.AXIS) block->direction_bits.AXIS = true; }while(0);
+      LOGICAL_AXIS_MAP(PAGE_UPDATE_DIR);
     }
 
     // If this is the first added movement, reload the delay, otherwise, cancel it.
     if (block_buffer_head == block_buffer_tail) {
       // If it was the first queued block, restart the 1st block delivery delay, to
       // give the planner an opportunity to queue more movements and plan them
       // As there are no queued movements, the Stepper ISR will not touch this
       // variable, so there is no risk setting this here (but it MUST be done
       // before the following line!!)
       delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg_mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;

commit 6e5f41fe6b996e074b042c6ac521475b8e8aab91
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 15 19:48:30 2023 -0500

    üßë‚Äçüíª Serial ternary args, etc.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index a9da48df01..a2d7e6843b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1922,20 +1922,21 @@ bool Planner::_populate_block(
         " " STR_K ":", target.k, " (", dk, " steps)"
       #endif
       #if HAS_U_AXIS
         " " STR_U ":", target.u, " (", du, " steps)"
       #endif
       #if HAS_V_AXIS
         " " STR_V ":", target.v, " (", dv, " steps)"
       #endif
       #if HAS_W_AXIS
         " " STR_W ":", target.w, " (", dw, " steps)"
+      #endif
       #if HAS_EXTRUDERS
         " E:", target.e, " (", de, " steps)"
       #endif
     );
   //*/
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    üö∏ Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 1b995a3224..a9da48df01 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1896,21 +1896,23 @@ bool Planner::_populate_block(
     dj = target.j - position.j,
     dk = target.k - position.k,
     du = target.u - position.u,
     dv = target.v - position.v,
     dw = target.w - position.w
   );
 
   /* <-- add a slash to enable
     SERIAL_ECHOLNPGM(
       "  _populate_block FR:", fr_mm_s,
-      " A:", target.a, " (", da, " steps)"
+      #if HAS_X_AXIS
+        " A:", target.a, " (", da, " steps)"
+      #endif
       #if HAS_Y_AXIS
         " B:", target.b, " (", db, " steps)"
       #endif
       #if HAS_Z_AXIS
         " C:", target.c, " (", dc, " steps)"
       #endif
       #if HAS_I_AXIS
         " " STR_I ":", target.i, " (", di, " steps)"
       #endif
       #if HAS_J_AXIS
@@ -2197,25 +2199,31 @@ bool Planner::_populate_block(
      * to blocks that would get dropped!
      *
      * A correction function is permitted to add steps to an axis, it
      * should *never* remove steps!
      */
     TERN_(BACKLASH_COMPENSATION, backlash.add_correction_steps(da, db, dc, dm, block));
   }
 
   TERN_(HAS_EXTRUDERS, block->steps.e = esteps);
 
-  block->step_event_count = _MAX(LOGICAL_AXIS_LIST(esteps,
-    block->steps.a, block->steps.b, block->steps.c,
-    block->steps.i, block->steps.j, block->steps.k,
-    block->steps.u, block->steps.v, block->steps.w
-  ));
+  block->step_event_count = (
+    #if NUM_AXES
+      _MAX(LOGICAL_AXIS_LIST(esteps,
+        block->steps.a, block->steps.b, block->steps.c,
+        block->steps.i, block->steps.j, block->steps.k,
+        block->steps.u, block->steps.v, block->steps.w
+      ))
+    #elif HAS_EXTRUDERS
+      esteps
+    #endif
+  );
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   TERN_(MIXING_EXTRUDER, mixer.populate_block(block->b_color));
 
   #if HAS_FAN
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
@@ -2467,22 +2475,22 @@ bool Planner::_populate_block(
     block->nominal_rate *= speed_factor;
     block->nominal_speed *= speed_factor;
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
   #if ENABLED(LIN_ADVANCE)
     bool use_advance_lead = false;
   #endif
-  if (NUM_AXIS_GANG(
-         !block->steps.a, && !block->steps.b, && !block->steps.c,
+  if (true NUM_AXIS_GANG(
+      && !block->steps.a, && !block->steps.b, && !block->steps.c,
       && !block->steps.i, && !block->steps.j, && !block->steps.k,
       && !block->steps.u, && !block->steps.v, && !block->steps.w)
   ) {                                                             // Is this a retract / recover move?
     accel = CEIL(settings.retract_acceleration * steps_per_mm);   // Convert to: acceleration steps/sec^2
   }
   else {
     #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
         const uint32_t max_possible = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count / block->steps[AXIS]; \
         NOMORE(accel, max_possible); \

commit 70efb515b16a9c8b5ebd0dae7348a0194841c4e3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 8 05:27:55 2023 -0500

    üßë‚Äçüíª PI => M_PI

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 52519b805c..1b995a3224 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -3166,28 +3166,28 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s
        *
        * Milling:
        * This shouldn't be a problem for cutting/milling operations.
        */
       feedRate_t calculated_feedrate = fr_mm_s;
       const xyz_pos_t diff = delta - position_float;
       if (!NEAR_ZERO(diff.b)) {
         if (delta.a <= POLAR_FAST_RADIUS )
           calculated_feedrate = settings.max_feedrate_mm_s[Y_AXIS];
         else {
-            // Normalized vector of movement
-            const float diffBLength = ABS((2.0f * PI * diff.a) * (diff.b / 360.0f)),
-                        diffTheta = DEGREES(ATAN2(diff.a, diffBLength)),
-                        normalizedTheta = 1.0f - (ABS(diffTheta > 90.0f ? 180.0f - diffTheta : diffTheta) / 90.0f);
-
-            // Normalized position along the radius
-            const float radiusRatio = PRINTABLE_RADIUS/delta.a;
-            calculated_feedrate += (fr_mm_s * radiusRatio * normalizedTheta);
+          // Normalized vector of movement
+          const float diffBLength = ABS((2.0f * M_PI * diff.a) * (diff.b / 360.0f)),
+                      diffTheta = DEGREES(ATAN2(diff.a, diffBLength)),
+                      normalizedTheta = 1.0f - (ABS(diffTheta > 90.0f ? 180.0f - diffTheta : diffTheta) / 90.0f);
+
+          // Normalized position along the radius
+          const float radiusRatio = (PRINTABLE_RADIUS) / delta.a;
+          calculated_feedrate += (fr_mm_s * radiusRatio * normalizedTheta);
         }
       }
       const feedRate_t feedrate = calculated_feedrate;
 
     #endif // POLAR && FEEDRATE_SCALING
 
     TERN_(HAS_EXTRUDERS, delta.e = machine.e);
     if (buffer_segment(delta OPTARG(HAS_DIST_MM_ARG, cart_dist_mm), feedrate, extruder, ph)) {
       position_cart = cart;
       return true;

commit 664b35b77c0ddf9562de6e74dd253f5bb33ce6b0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 03:03:33 2023 -0500

    üßë‚Äçüíª Replace axis_bits_t with AxisBits class (#25761)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ccf27a502a..52519b805c 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1961,68 +1961,64 @@ bool Planner::_populate_block(
             TERN_(HAS_POSITION_FLOAT, position_float.e = target_float.e);
             de = 0; // no difference
             SERIAL_ECHO_MSG(STR_ERR_LONG_EXTRUDE_STOP);
           }
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   // Compute direction bit-mask for this block
-  axis_bits_t dm = 0;
+  AxisBits dm;
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
-    if (da < 0) SBI(dm, X_HEAD);                  // Save the toolhead's true direction in X
-    if (db < 0) SBI(dm, Y_HEAD);                  // ...and Y
-    TERN_(HAS_Z_AXIS, if (dc < 0) SBI(dm, Z_AXIS));
+    dm.hx = (da < 0);                 // Save the toolhead's true direction in X
+    dm.hy = (db < 0);                 // ...and Y
+    TERN_(HAS_Z_AXIS, dm.z = (dc < 0));
   #endif
   #if IS_CORE
     #if CORE_IS_XY
-      if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
-      if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
+      dm.a = (da + db < 0);           // Motor A direction
+      dm.b = (CORESIGN(da - db) < 0); // Motor B direction
     #elif CORE_IS_XZ
-      if (da < 0) SBI(dm, X_HEAD);                // Save the toolhead's true direction in X
-      if (db < 0) SBI(dm, Y_AXIS);
-      if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
-      if (da + dc < 0) SBI(dm, A_AXIS);           // Motor A direction
-      if (CORESIGN(da - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
+      dm.hx = (da < 0);               // Save the toolhead's true direction in X
+      dm.y = (db < 0);
+      dm.hz = (dc < 0);               // ...and Z
+      dm.a = (da + dc < 0);           // Motor A direction
+      dm.c = (CORESIGN(da - dc) < 0); // Motor C direction
     #elif CORE_IS_YZ
-      if (da < 0) SBI(dm, X_AXIS);
-      if (db < 0) SBI(dm, Y_HEAD);                // Save the toolhead's true direction in Y
-      if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
-      if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
-      if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
+      dm.x = (da < 0);
+      dm.hy = (db < 0);               // Save the toolhead's true direction in Y
+      dm.hz = (dc < 0);               // ...and Z
+      dm.b = (db + dc < 0);           // Motor B direction
+      dm.c = (CORESIGN(db - dc) < 0); // Motor C direction
     #endif
   #elif ENABLED(MARKFORGED_XY)
-    if (da + db < 0) SBI(dm, A_AXIS);              // Motor A direction
-    if (db < 0) SBI(dm, B_AXIS);                   // Motor B direction
+    dm.a = (da + db < 0);             // Motor A direction
+    dm.b = (db < 0);                  // Motor B direction
   #elif ENABLED(MARKFORGED_YX)
-    if (da < 0) SBI(dm, A_AXIS);                   // Motor A direction
-    if (db + da < 0) SBI(dm, B_AXIS);              // Motor B direction
+    dm.a = (da < 0);                  // Motor A direction
+    dm.b = (db + da < 0);             // Motor B direction
   #else
     XYZ_CODE(
-      if (da < 0) SBI(dm, X_AXIS),
-      if (db < 0) SBI(dm, Y_AXIS),
-      if (dc < 0) SBI(dm, Z_AXIS)
+      dm.x = (da < 0),
+      dm.y = (db < 0),
+      dm.z = (dc < 0)
     );
   #endif
 
   SECONDARY_AXIS_CODE(
-    if (di < 0) SBI(dm, I_AXIS),
-    if (dj < 0) SBI(dm, J_AXIS),
-    if (dk < 0) SBI(dm, K_AXIS),
-    if (du < 0) SBI(dm, U_AXIS),
-    if (dv < 0) SBI(dm, V_AXIS),
-    if (dw < 0) SBI(dm, W_AXIS)
+    dm.i = (di < 0), dm.j = (dj < 0), dm.k = (dk < 0),
+    dm.u = (du < 0), dm.v = (dv < 0), dm.w = (dw < 0)
   );
 
   #if HAS_EXTRUDERS
-    if (de < 0) SBI(dm, E_AXIS);
+    dm.e = (de < 0);
     const float esteps_float = de * e_factor[extruder];
     const uint32_t esteps = ABS(esteps_float) + 0.5f;
   #else
     constexpr uint32_t esteps = 0;
   #endif
 
   // Clear all flags, including the "busy" bit
   block->flag.clear();
 
   // Set direction bits
@@ -2428,25 +2424,25 @@ bool Planner::_populate_block(
             SERIAL_ECHOLNPGM(" mm/s)");
             //*/
           }
         }
       #endif
     }
   #endif
 
   #ifdef XY_FREQUENCY_LIMIT
 
-    static axis_bits_t old_direction_bits; // = 0
+    static AxisBits old_direction_bits; // = 0
 
     if (xy_freq_limit_hz) {
       // Check and limit the xy direction change frequency
-      const axis_bits_t direction_change = block->direction_bits ^ old_direction_bits;
+      const AxisBits direction_change = block->direction_bits ^ old_direction_bits;
       old_direction_bits = block->direction_bits;
       segment_time_us = LROUND(float(segment_time_us) / speed_factor);
 
       static int32_t xs0, xs1, xs2, ys0, ys1, ys2;
       if (segment_time_us > xy_freq_min_interval_us)
         xs2 = xs1 = ys2 = ys1 = xy_freq_min_interval_us;
       else {
         xs2 = xs1; xs1 = xs0;
         ys2 = ys1; ys1 = ys0;
       }

commit 74b205c7abfa5cf9bc487edcd6a26a75a6c9a0cb
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Fri Apr 7 18:32:25 2023 +1200

    üö∏ Support CoreXY without Z (#25630)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index dadb22fbde..ccf27a502a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1965,21 +1965,21 @@ bool Planner::_populate_block(
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   // Compute direction bit-mask for this block
   axis_bits_t dm = 0;
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
     if (da < 0) SBI(dm, X_HEAD);                  // Save the toolhead's true direction in X
     if (db < 0) SBI(dm, Y_HEAD);                  // ...and Y
-    if (dc < 0) SBI(dm, Z_AXIS);
+    TERN_(HAS_Z_AXIS, if (dc < 0) SBI(dm, Z_AXIS));
   #endif
   #if IS_CORE
     #if CORE_IS_XY
       if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
       if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
     #elif CORE_IS_XZ
       if (da < 0) SBI(dm, X_HEAD);                // Save the toolhead's true direction in X
       if (db < 0) SBI(dm, Y_AXIS);
       if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
       if (da + dc < 0) SBI(dm, A_AXIS);           // Motor A direction
@@ -2089,21 +2089,21 @@ bool Planner::_populate_block(
    */
   struct DistanceMM : abce_float_t {
     #if ANY(IS_CORE, MARKFORGED_XY, MARKFORGED_YX)
       struct { float x, y, z; } head;
     #endif
   } steps_dist_mm;
 
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
     steps_dist_mm.head.x = da * mm_per_step[A_AXIS];
     steps_dist_mm.head.y = db * mm_per_step[B_AXIS];
-    steps_dist_mm.z      = dc * mm_per_step[Z_AXIS];
+    TERN_(HAS_Z_AXIS, steps_dist_mm.z = dc * mm_per_step[Z_AXIS]);
   #endif
   #if IS_CORE
     #if CORE_IS_XY
       steps_dist_mm.a      = (da + db) * mm_per_step[A_AXIS];
       steps_dist_mm.b      = CORESIGN(da - db) * mm_per_step[B_AXIS];
     #elif CORE_IS_XZ
       steps_dist_mm.head.x = da * mm_per_step[A_AXIS];
       steps_dist_mm.y      = db * mm_per_step[Y_AXIS];
       steps_dist_mm.head.z = dc * mm_per_step[C_AXIS];
       steps_dist_mm.a      = (da + dc) * mm_per_step[A_AXIS];
@@ -2237,21 +2237,21 @@ bool Planner::_populate_block(
       || block->steps.u, || block->steps.v, || block->steps.w
     )) powerManager.power_on();
   #endif
 
   // Enable active axes
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
     if (block->steps.a || block->steps.b) {
       stepper.enable_axis(X_AXIS);
       stepper.enable_axis(Y_AXIS);
     }
-    #if DISABLED(Z_LATE_ENABLE)
+    #if HAS_Z_AXIS && DISABLED(Z_LATE_ENABLE)
       if (block->steps.z) stepper.enable_axis(Z_AXIS);
     #endif
   #elif CORE_IS_XZ
     if (block->steps.a || block->steps.c) {
       stepper.enable_axis(X_AXIS);
       stepper.enable_axis(Z_AXIS);
     }
     if (block->steps.y) stepper.enable_axis(Y_AXIS);
   #elif CORE_IS_YZ
     if (block->steps.b || block->steps.c) {

commit c37fa3cc9097a9aa7fad5f168e335caabf23278e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 31 21:18:37 2023 -0500

    ‚ú® Fixed-Time Motion with Input Shaping by Ulendo (#25394)
    
    Co-authored-by: Ulendo Alex <alex@ulendo.io>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 552d212e2e..dadb22fbde 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -62,20 +62,23 @@
  *
  *   d1 -> (m^2 - s1^2) / (2 a)
  *   d2 -> (m^2 - s2^2) / (2 a)
  *   di -> (d + d1 - d2) / 2
  */
 
 #include "planner.h"
 #include "stepper.h"
 #include "motion.h"
 #include "temperature.h"
+#if ENABLED(FT_MOTION)
+  #include "ft_motion.h"
+#endif
 #include "../lcd/marlinui.h"
 #include "../gcode/parser.h"
 
 #include "../MarlinCore.h"
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
@@ -105,36 +108,37 @@
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/powerloss.h"
 #endif
 
 #if HAS_CUTTER
   #include "../feature/spindle_laser.h"
 #endif
 
 // Delay for delivery of first block to the stepper ISR, if the queue contains 2 or
 // fewer movements. The delay is measured in milliseconds, and must be less than 250ms
-#define BLOCK_DELAY_FOR_1ST_MOVE 100
+#define BLOCK_DELAY_NONE         0U
+#define BLOCK_DELAY_FOR_1ST_MOVE 100U
 
 Planner planner;
 
 // public:
 
 /**
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head,    // Index of the next block to be pushed
                  Planner::block_buffer_nonbusy, // Index of the first non-busy block
                  Planner::block_buffer_planned, // Index of the optimally planned block
                  Planner::block_buffer_tail;    // Index of the busy block, if any
 uint16_t Planner::cleaning_buffer_counter;      // A counter to disable queuing of blocks
-uint8_t Planner::delay_before_delivering;       // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
+uint8_t Planner::delay_before_delivering;       // Delay block delivery so initial blocks in an empty queue may merge
 
 planner_settings_t Planner::settings;           // Initialized by settings.load()
 
 /**
  * Set up inline block variables
  * Set laser_power_floor based on SPEED_POWER_MIN to pevent a zero power output state with LASER_POWER_TRAP
  */
 #if ENABLED(LASER_FEATURE)
   laser_state_t Planner::laser_inline;          // Current state for blocks
   const uint8_t laser_power_floor = cutter.pct_to_ocr(SPEED_POWER_MIN);
@@ -218,20 +222,24 @@ float Planner::previous_nominal_speed;
 #if ENABLED(DISABLE_OTHER_EXTRUDERS)
   last_move_t Planner::extruder_last_move[E_STEPPERS] = { 0 };
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
   int8_t Planner::xy_freq_limit_hz = XY_FREQUENCY_LIMIT;
   float Planner::xy_freq_min_speed_factor = (XY_FREQUENCY_MIN_PERCENT) * 0.01f;
   int32_t Planner::xy_freq_min_interval_us = LROUND(1000000.0f / (XY_FREQUENCY_LIMIT));
 #endif
 
+#if ENABLED(FT_MOTION)
+  bool Planner::fxdTiCtrl_busy = false;
+#endif
+
 #if ENABLED(LIN_ADVANCE)
   float Planner::extruder_advance_K[DISTINCT_E]; // Initialized by settings.load()
 #endif
 
 #if HAS_POSITION_FLOAT
   xyze_pos_t Planner::position_float; // Needed for accurate maths. Steps cannot be used!
 #endif
 
 #if IS_KINEMATIC
   xyze_pos_t Planner::position_cart;
@@ -1676,21 +1684,22 @@ void Planner::quick_stop() {
   // must be handled: The tail could change between the read and the assignment
   // so this must be enclosed in a critical section
 
   const bool was_enabled = stepper.suspend();
 
   // Drop all queue entries
   block_buffer_nonbusy = block_buffer_planned = block_buffer_head = block_buffer_tail;
 
   // Restart the block delay for the first movement - As the queue was
   // forced to empty, there's no risk the ISR will touch this.
-  delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
+
+  delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg_mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
 
   TERN_(HAS_WIRED_LCD, clear_block_buffer_runtime()); // Clear the accumulated runtime
 
   // Make sure to drop any attempt of queuing moves for 1 second
   cleaning_buffer_counter = TEMP_TIMER_FREQUENCY;
 
   // Reenable Stepper ISR
   if (was_enabled) stepper.wake_up();
 
   // And stop the stepper ISR
@@ -1722,20 +1731,21 @@ void Planner::endstop_triggered(const AxisEnum axis) {
 
 float Planner::triggered_position_mm(const AxisEnum axis) {
   const float result = DIFF_TERN(BACKLASH_COMPENSATION, stepper.triggered_position(axis), backlash.get_applied_steps(axis));
   return result * mm_per_step[axis];
 }
 
 bool Planner::busy() {
   return (has_blocks_queued() || cleaning_buffer_counter
       || TERN0(EXTERNAL_CLOSED_LOOP_CONTROLLER, CLOSED_LOOP_WAITING())
       || TERN0(HAS_ZV_SHAPING, stepper.input_shaping_busy())
+      || TERN0(FT_MOTION, fxdTiCtrl_busy)
   );
 }
 
 void Planner::finish_and_disable() {
   while (has_blocks_queued() || cleaning_buffer_counter) idle();
   stepper.disable_all_steppers();
 }
 
 /**
  * Get an axis position according to stepper position(s)
@@ -1834,21 +1844,21 @@ bool Planner::_buffer_steps(const xyze_long_t &target
     return true;
   }
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
     // give the planner an opportunity to queue more movements and plan them
     // As there are no queued movements, the Stepper ISR will not touch this
     // variable, so there is no risk setting this here (but it MUST be done
     // before the following line!!)
-    delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
+    delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg_mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
   }
 
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
   // Recalculate and optimize trapezoidal speed profiles
   recalculate(TERN_(HINTS_SAFE_EXIT_SPEED, hints.safe_exit_speed_sqr));
 
   // Movement successfully queued!
   return true;
@@ -2938,21 +2948,21 @@ void Planner::buffer_sync_block(const BlockFlagBit sync_flag/*=BLOCK_BIT_SYNC_PO
    */
   TERN_(LASER_POWER_SYNC, block->laser.power = cutter.power);
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
     // give the planner an opportunity to queue more movements and plan them
     // As there are no queued movements, the Stepper ISR will not touch this
     // variable, so there is no risk setting this here (but it MUST be done
     // before the following line!!)
-    delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
+    delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg_mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
   }
 
   block_buffer_head = next_buffer_head;
 
   stepper.wake_up();
 } // buffer_sync_block()
 
 /**
  * @brief Add a single linear movement
  *
@@ -3236,21 +3246,21 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s
       PAGE_UPDATE_DIR(E);
     }
 
     // If this is the first added movement, reload the delay, otherwise, cancel it.
     if (block_buffer_head == block_buffer_tail) {
       // If it was the first queued block, restart the 1st block delivery delay, to
       // give the planner an opportunity to queue more movements and plan them
       // As there are no queued movements, the Stepper ISR will not touch this
       // variable, so there is no risk setting this here (but it MUST be done
       // before the following line!!)
-      delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
+      delay_before_delivering = TERN_(FT_MOTION, fxdTiCtrl.cfg_mode ? BLOCK_DELAY_NONE :) BLOCK_DELAY_FOR_1ST_MOVE;
     }
 
     // Move buffer head
     block_buffer_head = next_buffer_head;
 
     stepper.enable_all_steppers();
     stepper.wake_up();
   }
 
 #endif // DIRECT_STEPPING

commit 8cdf43f8fdf8900ad903d094d1aeb5dc651b324b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 31 20:26:49 2023 -0500

    üé®  HAS_SHAPING => HAS_ZV_SHAPING

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 8e77a7c979..552d212e2e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1721,21 +1721,21 @@ void Planner::endstop_triggered(const AxisEnum axis) {
 }
 
 float Planner::triggered_position_mm(const AxisEnum axis) {
   const float result = DIFF_TERN(BACKLASH_COMPENSATION, stepper.triggered_position(axis), backlash.get_applied_steps(axis));
   return result * mm_per_step[axis];
 }
 
 bool Planner::busy() {
   return (has_blocks_queued() || cleaning_buffer_counter
       || TERN0(EXTERNAL_CLOSED_LOOP_CONTROLLER, CLOSED_LOOP_WAITING())
-      || TERN0(HAS_SHAPING, stepper.input_shaping_busy())
+      || TERN0(HAS_ZV_SHAPING, stepper.input_shaping_busy())
   );
 }
 
 void Planner::finish_and_disable() {
   while (has_blocks_queued() || cleaning_buffer_counter) idle();
   stepper.disable_all_steppers();
 }
 
 /**
  * Get an axis position according to stepper position(s)

commit 61f22f34d32ca33d99233eb5b242e52c23aabb23
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 26 17:24:40 2023 -0500

    üîß Clarify axis disable / timeout (#25571)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 12e879af96..8e77a7c979 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -208,21 +208,21 @@ float Planner::mm_per_step[DISTINCT_AXES];      // (mm) Millimeters per step
 
 // private:
 
 xyze_long_t Planner::position{0};
 
 uint32_t Planner::acceleration_long_cutoff;
 
 xyze_float_t Planner::previous_speed;
 float Planner::previous_nominal_speed;
 
-#if ENABLED(DISABLE_INACTIVE_EXTRUDER)
+#if ENABLED(DISABLE_OTHER_EXTRUDERS)
   last_move_t Planner::extruder_last_move[E_STEPPERS] = { 0 };
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
   int8_t Planner::xy_freq_limit_hz = XY_FREQUENCY_LIMIT;
   float Planner::xy_freq_min_speed_factor = (XY_FREQUENCY_MIN_PERCENT) * 0.01f;
   int32_t Planner::xy_freq_min_interval_us = LROUND(1000000.0f / (XY_FREQUENCY_LIMIT));
 #endif
 
 #if ENABLED(LIN_ADVANCE)
@@ -1313,21 +1313,21 @@ void Planner::recalculate(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t safe_exit_s
 
   #endif
 
 #endif // HAS_FAN
 
 /**
  * Maintain fans, paste extruder pressure, spindle/laser power
  */
 void Planner::check_axes_activity() {
 
-  #if HAS_DISABLE_AXIS
+  #if HAS_DISABLE_AXES
     xyze_bool_t axis_active = { false };
   #endif
 
   #if HAS_FAN && DISABLED(LASER_SYNCHRONOUS_M106_M107)
     #define HAS_TAIL_FAN_SPEED 1
     static uint8_t tail_fan_speed[FAN_COUNT] = ARRAY_N_1(FAN_COUNT, 13);
     bool fans_need_update = false;
   #endif
 
   #if ENABLED(BARICUDA)
@@ -1353,21 +1353,21 @@ void Planner::check_axes_activity() {
           tail_fan_speed[i] = spd;
         }
       }
     #endif
 
     #if ENABLED(BARICUDA)
       TERN_(HAS_HEATER_1, tail_valve_pressure = block->valve_pressure);
       TERN_(HAS_HEATER_2, tail_e_to_p_pressure = block->e_to_p_pressure);
     #endif
 
-    #if HAS_DISABLE_AXIS
+    #if HAS_DISABLE_AXES
       for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
         block_t * const bnext = &block_buffer[b];
         LOGICAL_AXIS_CODE(
           if (TERN0(DISABLE_E, bnext->steps.e)) axis_active.e = true,
           if (TERN0(DISABLE_X, bnext->steps.x)) axis_active.x = true,
           if (TERN0(DISABLE_Y, bnext->steps.y)) axis_active.y = true,
           if (TERN0(DISABLE_Z, bnext->steps.z)) axis_active.z = true,
           if (TERN0(DISABLE_I, bnext->steps.i)) axis_active.i = true,
           if (TERN0(DISABLE_J, bnext->steps.j)) axis_active.j = true,
           if (TERN0(DISABLE_K, bnext->steps.k)) axis_active.k = true,
@@ -1394,32 +1394,34 @@ void Planner::check_axes_activity() {
 
     #if ENABLED(BARICUDA)
       TERN_(HAS_HEATER_1, tail_valve_pressure = baricuda_valve_pressure);
       TERN_(HAS_HEATER_2, tail_e_to_p_pressure = baricuda_e_to_p_pressure);
     #endif
   }
 
   //
   // Disable inactive axes
   //
-  LOGICAL_AXIS_CODE(
-    if (TERN0(DISABLE_E, !axis_active.e)) stepper.disable_e_steppers(),
-    if (TERN0(DISABLE_X, !axis_active.x)) stepper.disable_axis(X_AXIS),
-    if (TERN0(DISABLE_Y, !axis_active.y)) stepper.disable_axis(Y_AXIS),
-    if (TERN0(DISABLE_Z, !axis_active.z)) stepper.disable_axis(Z_AXIS),
-    if (TERN0(DISABLE_I, !axis_active.i)) stepper.disable_axis(I_AXIS),
-    if (TERN0(DISABLE_J, !axis_active.j)) stepper.disable_axis(J_AXIS),
-    if (TERN0(DISABLE_K, !axis_active.k)) stepper.disable_axis(K_AXIS),
-    if (TERN0(DISABLE_U, !axis_active.u)) stepper.disable_axis(U_AXIS),
-    if (TERN0(DISABLE_V, !axis_active.v)) stepper.disable_axis(V_AXIS),
-    if (TERN0(DISABLE_W, !axis_active.w)) stepper.disable_axis(W_AXIS)
-  );
+  #if HAS_DISABLE_AXES
+    LOGICAL_AXIS_CODE(
+      if (TERN0(DISABLE_E, !axis_active.e)) stepper.disable_e_steppers(),
+      if (TERN0(DISABLE_X, !axis_active.x)) stepper.disable_axis(X_AXIS),
+      if (TERN0(DISABLE_Y, !axis_active.y)) stepper.disable_axis(Y_AXIS),
+      if (TERN0(DISABLE_Z, !axis_active.z)) stepper.disable_axis(Z_AXIS),
+      if (TERN0(DISABLE_I, !axis_active.i)) stepper.disable_axis(I_AXIS),
+      if (TERN0(DISABLE_J, !axis_active.j)) stepper.disable_axis(J_AXIS),
+      if (TERN0(DISABLE_K, !axis_active.k)) stepper.disable_axis(K_AXIS),
+      if (TERN0(DISABLE_U, !axis_active.u)) stepper.disable_axis(U_AXIS),
+      if (TERN0(DISABLE_V, !axis_active.v)) stepper.disable_axis(V_AXIS),
+      if (TERN0(DISABLE_W, !axis_active.w)) stepper.disable_axis(W_AXIS)
+    );
+  #endif
 
   //
   // Update Fan speeds
   // Only if synchronous M106/M107 is disabled
   //
   TERN_(HAS_TAIL_FAN_SPEED, if (fans_need_update) sync_fan_speeds(tail_fan_speed));
 
   TERN_(AUTOTEMP, autotemp_task());
 
   #if ENABLED(BARICUDA)
@@ -2269,21 +2271,21 @@ bool Planner::_populate_block(
       if (block->steps.v) stepper.enable_axis(V_AXIS),
       if (block->steps.w) stepper.enable_axis(W_AXIS)
     );
   #endif
 
   // Enable extruder(s)
   #if HAS_EXTRUDERS
     if (esteps) {
       TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
-      #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
+      #if ENABLED(DISABLE_OTHER_EXTRUDERS) // Enable only the selected extruder
 
         // Count down all steppers that were recently moved
         LOOP_L_N(i, E_STEPPERS)
           if (extruder_last_move[i]) extruder_last_move[i]--;
 
         // Switching Extruder uses one E stepper motor per two nozzles
         #define E_STEPPER_INDEX(E) TERN(HAS_SWITCHING_EXTRUDER, (E) / 2, E)
 
         // Enable all (i.e., both) E steppers for IDEX-style duplication, but only active E steppers for multi-nozzle (i.e., single wide X carriage) duplication
         #define _IS_DUPE(N) TERN0(HAS_DUPLICATION_MODE, (extruder_duplication_enabled && TERN1(MULTI_NOZZLE_DUPLICATION, TEST(duplication_e_mask, N))))

commit f0c8c9182090f8929ec4766683ec2d6902d4bc00
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 3 20:44:24 2023 -0600

    üßë‚Äçüíª Width/Magnitude-based types (#25458)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 9fb775e03f..12e879af96 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -209,21 +209,21 @@ float Planner::mm_per_step[DISTINCT_AXES];      // (mm) Millimeters per step
 // private:
 
 xyze_long_t Planner::position{0};
 
 uint32_t Planner::acceleration_long_cutoff;
 
 xyze_float_t Planner::previous_speed;
 float Planner::previous_nominal_speed;
 
 #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
-  last_move_t Planner::g_uc_extruder_last_move[E_STEPPERS] = { 0 };
+  last_move_t Planner::extruder_last_move[E_STEPPERS] = { 0 };
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
   int8_t Planner::xy_freq_limit_hz = XY_FREQUENCY_LIMIT;
   float Planner::xy_freq_min_speed_factor = (XY_FREQUENCY_MIN_PERCENT) * 0.01f;
   int32_t Planner::xy_freq_min_interval_us = LROUND(1000000.0f / (XY_FREQUENCY_LIMIT));
 #endif
 
 #if ENABLED(LIN_ADVANCE)
   float Planner::extruder_advance_K[DISTINCT_E]; // Initialized by settings.load()
@@ -2273,35 +2273,35 @@ bool Planner::_populate_block(
 
   // Enable extruder(s)
   #if HAS_EXTRUDERS
     if (esteps) {
       TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
         // Count down all steppers that were recently moved
         LOOP_L_N(i, E_STEPPERS)
-          if (g_uc_extruder_last_move[i]) g_uc_extruder_last_move[i]--;
+          if (extruder_last_move[i]) extruder_last_move[i]--;
 
         // Switching Extruder uses one E stepper motor per two nozzles
         #define E_STEPPER_INDEX(E) TERN(HAS_SWITCHING_EXTRUDER, (E) / 2, E)
 
         // Enable all (i.e., both) E steppers for IDEX-style duplication, but only active E steppers for multi-nozzle (i.e., single wide X carriage) duplication
         #define _IS_DUPE(N) TERN0(HAS_DUPLICATION_MODE, (extruder_duplication_enabled && TERN1(MULTI_NOZZLE_DUPLICATION, TEST(duplication_e_mask, N))))
 
         #define ENABLE_ONE_E(N) do{ \
-          if (N == E_STEPPER_INDEX(extruder) || _IS_DUPE(N)) {    /* N is 'extruder', or N is duplicating */ \
-            stepper.ENABLE_EXTRUDER(N);                           /* Enable the relevant E stepper... */ \
-            g_uc_extruder_last_move[N] = (BLOCK_BUFFER_SIZE) * 2; /* ...and reset its counter */ \
+          if (N == E_STEPPER_INDEX(extruder) || _IS_DUPE(N)) {  /* N is 'extruder', or N is duplicating */ \
+            stepper.ENABLE_EXTRUDER(N);                         /* Enable the relevant E stepper... */ \
+            extruder_last_move[N] = (BLOCK_BUFFER_SIZE) * 2;    /* ...and reset its counter */ \
           } \
-          else if (!g_uc_extruder_last_move[N])                   /* Counter expired since last E stepper enable */ \
-            stepper.DISABLE_EXTRUDER(N);                          /* Disable the E stepper */ \
+          else if (!extruder_last_move[N])                      /* Counter expired since last E stepper enable */ \
+            stepper.DISABLE_EXTRUDER(N);                        /* Disable the E stepper */ \
         }while(0);
 
       #else
 
         #define ENABLE_ONE_E(N) stepper.ENABLE_EXTRUDER(N);
 
       #endif
 
       REPEAT(E_STEPPERS, ENABLE_ONE_E); // (ENABLE_ONE_E must end with semicolon)
     }

commit e977232735abd759678e8665759dbc214df88202
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Sat Mar 4 05:43:20 2023 +0300

    ‚ú® Switching extruder/nozzle without servo (e.g., Dondolo) (#24553)
    
    Co-authored-by: Anson Liu <ansonl@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 583e3686a0..9fb775e03f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2276,21 +2276,21 @@ bool Planner::_populate_block(
     if (esteps) {
       TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
         // Count down all steppers that were recently moved
         LOOP_L_N(i, E_STEPPERS)
           if (g_uc_extruder_last_move[i]) g_uc_extruder_last_move[i]--;
 
         // Switching Extruder uses one E stepper motor per two nozzles
-        #define E_STEPPER_INDEX(E) TERN(SWITCHING_EXTRUDER, (E) / 2, E)
+        #define E_STEPPER_INDEX(E) TERN(HAS_SWITCHING_EXTRUDER, (E) / 2, E)
 
         // Enable all (i.e., both) E steppers for IDEX-style duplication, but only active E steppers for multi-nozzle (i.e., single wide X carriage) duplication
         #define _IS_DUPE(N) TERN0(HAS_DUPLICATION_MODE, (extruder_duplication_enabled && TERN1(MULTI_NOZZLE_DUPLICATION, TEST(duplication_e_mask, N))))
 
         #define ENABLE_ONE_E(N) do{ \
           if (N == E_STEPPER_INDEX(extruder) || _IS_DUPE(N)) {    /* N is 'extruder', or N is duplicating */ \
             stepper.ENABLE_EXTRUDER(N);                           /* Enable the relevant E stepper... */ \
             g_uc_extruder_last_move[N] = (BLOCK_BUFFER_SIZE) * 2; /* ...and reset its counter */ \
           } \
           else if (!g_uc_extruder_last_move[N])                   /* Counter expired since last E stepper enable */ \

commit acfde4e7e5e1fc4ad46a26700f25a6e60e325967
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Feb 23 21:38:11 2023 -0600

    üé® Use LIMIT macro

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 25db52437f..583e3686a0 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -3446,22 +3446,21 @@ void Planner::set_max_feedrate(const AxisEnum axis, float inMaxFeedrateMMS) {
     #ifdef __AVR__
       // Reenable Stepper ISR
       if (was_enabled) stepper.wake_up();
     #endif
 
     // To translate ¬µs to ms a division by 1000 would be required.
     // We introduce 2.4% error here by dividing by 1024.
     // Doesn't matter because block_buffer_runtime_us is already too small an estimation.
     bbru >>= 10;
     // limit to about a minute.
-    NOMORE(bbru, 0x0000FFFFUL);
-    return bbru;
+    return _MIN(bbru, 0x0000FFFFUL);
   }
 
   void Planner::clear_block_buffer_runtime() {
     #ifdef __AVR__
       // Protect the access to the variable. Only required for AVR, as
       //  any 32bit CPU offers atomic access to 32bit variables
       const bool was_enabled = stepper.suspend();
     #endif
 
     block_buffer_runtime_us = 0;

commit f9f6662a8c4692cc67006fb302068c96a0e86ac1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Feb 23 21:08:31 2023 -0600

    ‚ôªÔ∏è Stepper options refactor (#25422)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ff5449d230..25db52437f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1313,21 +1313,21 @@ void Planner::recalculate(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t safe_exit_s
 
   #endif
 
 #endif // HAS_FAN
 
 /**
  * Maintain fans, paste extruder pressure, spindle/laser power
  */
 void Planner::check_axes_activity() {
 
-  #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_I, DISABLE_J, DISABLE_K, DISABLE_U, DISABLE_V, DISABLE_W, DISABLE_E)
+  #if HAS_DISABLE_AXIS
     xyze_bool_t axis_active = { false };
   #endif
 
   #if HAS_FAN && DISABLED(LASER_SYNCHRONOUS_M106_M107)
     #define HAS_TAIL_FAN_SPEED 1
     static uint8_t tail_fan_speed[FAN_COUNT] = ARRAY_N_1(FAN_COUNT, 13);
     bool fans_need_update = false;
   #endif
 
   #if ENABLED(BARICUDA)
@@ -1353,21 +1353,21 @@ void Planner::check_axes_activity() {
           tail_fan_speed[i] = spd;
         }
       }
     #endif
 
     #if ENABLED(BARICUDA)
       TERN_(HAS_HEATER_1, tail_valve_pressure = block->valve_pressure);
       TERN_(HAS_HEATER_2, tail_e_to_p_pressure = block->e_to_p_pressure);
     #endif
 
-    #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_I, DISABLE_J, DISABLE_K, DISABLE_E)
+    #if HAS_DISABLE_AXIS
       for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
         block_t * const bnext = &block_buffer[b];
         LOGICAL_AXIS_CODE(
           if (TERN0(DISABLE_E, bnext->steps.e)) axis_active.e = true,
           if (TERN0(DISABLE_X, bnext->steps.x)) axis_active.x = true,
           if (TERN0(DISABLE_Y, bnext->steps.y)) axis_active.y = true,
           if (TERN0(DISABLE_Z, bnext->steps.z)) axis_active.z = true,
           if (TERN0(DISABLE_I, bnext->steps.i)) axis_active.i = true,
           if (TERN0(DISABLE_J, bnext->steps.j)) axis_active.j = true,
           if (TERN0(DISABLE_K, bnext->steps.k)) axis_active.k = true,
@@ -1485,21 +1485,21 @@ void Planner::check_axes_activity() {
       }
     }
 
     float t = autotemp.min + high * autotemp.factor;
     LIMIT(t, autotemp.min, autotemp.max);
     if (t < oldt) t = t * (1.0f - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
     oldt = t;
     thermalManager.setTargetHotend(t, active_extruder);
   }
 
-#endif
+#endif // AUTOTEMP
 
 #if DISABLED(NO_VOLUMETRICS)
 
   /**
    * Get a volumetric multiplier from a filament diameter.
    * This is the reciprocal of the circular cross-section area.
    * Return 1.0 with volumetric off or a diameter of 0.0.
    */
   inline float calculate_volumetric_multiplier(const_float_t diameter) {
     return (parser.volumetric_enabled && diameter) ? 1.0f / CIRCLE_AREA(diameter * 0.5f) : 1;

commit babd3b0037d660f52cccbb295b8839b8dd744036
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Tue Feb 21 19:26:10 2023 +0100

    üßë‚Äçüíª Add get_move_distance for rotation/kinematics (#25370)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 46aff32481..ff5449d230 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2123,107 +2123,70 @@ bool Planner::_populate_block(
     steps_dist_mm.k = dk * mm_per_step[K_AXIS],
     steps_dist_mm.u = du * mm_per_step[U_AXIS],
     steps_dist_mm.v = dv * mm_per_step[V_AXIS],
     steps_dist_mm.w = dw * mm_per_step[W_AXIS]
   );
 
   TERN_(HAS_EXTRUDERS, steps_dist_mm.e = esteps_float * mm_per_step[E_AXIS_N(extruder)]);
 
   TERN_(LCD_SHOW_E_TOTAL, e_move_accumulator += steps_dist_mm.e);
 
-  #if BOTH(HAS_ROTATIONAL_AXES, INCH_MODE_SUPPORT)
-    bool cartesian_move = true;
+  #if HAS_ROTATIONAL_AXES
+    bool cartesian_move = hints.cartesian_move;
   #endif
 
   if (true NUM_AXIS_GANG(
       && block->steps.a < MIN_STEPS_PER_SEGMENT,
       && block->steps.b < MIN_STEPS_PER_SEGMENT,
       && block->steps.c < MIN_STEPS_PER_SEGMENT,
       && block->steps.i < MIN_STEPS_PER_SEGMENT,
       && block->steps.j < MIN_STEPS_PER_SEGMENT,
       && block->steps.k < MIN_STEPS_PER_SEGMENT,
       && block->steps.u < MIN_STEPS_PER_SEGMENT,
       && block->steps.v < MIN_STEPS_PER_SEGMENT,
       && block->steps.w < MIN_STEPS_PER_SEGMENT
     )
   ) {
     block->millimeters = TERN0(HAS_EXTRUDERS, ABS(steps_dist_mm.e));
   }
   else {
     if (hints.millimeters)
       block->millimeters = hints.millimeters;
     else {
-      /**
-       * Distance for interpretation of feedrate in accordance with LinuxCNC (the successor of NIST
-       * RS274NGC interpreter - version 3) and its default CANON_XYZ feed reference mode.
-       * Assume that X, Y, Z are the primary linear axes and U, V, W are secondary linear axes and A, B, C are
-       * rotational axes. Then dX, dY, dZ are the displacements of the primary linear axes and dU, dV, dW are the displacements of linear axes and
-       * dA, dB, dC are the displacements of rotational axes.
-       * The time it takes to execute move command with feedrate F is t = D/F, where D is the total distance, calculated as follows:
-       *   D^2 = dX^2 + dY^2 + dZ^2
-       *   if D^2 == 0 (none of XYZ move but any secondary linear axes move, whether other axes are moved or not):
-       *     D^2 = dU^2 + dV^2 + dW^2
-       *   if D^2 == 0 (only rotational axes are moved):
-       *     D^2 = dA^2 + dB^2 + dC^2
-       */
-      float distance_sqr = (
-        #if ENABLED(ARTICULATED_ROBOT_ARM)
-          // For articulated robots, interpreting feedrate like LinuxCNC would require inverse kinematics. As a workaround, pretend that motors sit on n mutually orthogonal
-          // axes and assume that we could think of distance as magnitude of an n-vector in an n-dimensional Euclidian space.
-          NUM_AXIS_GANG(
-              sq(steps_dist_mm.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.z),
-            + sq(steps_dist_mm.i), + sq(steps_dist_mm.j), + sq(steps_dist_mm.k),
-            + sq(steps_dist_mm.u), + sq(steps_dist_mm.v), + sq(steps_dist_mm.w)
-          )
-        #elif ENABLED(FOAMCUTTER_XYUV)
-          #if HAS_J_AXIS
-            // Special 5 axis kinematics. Return the largest distance move from either X/Y or I/J plane
-            _MAX(sq(steps_dist_mm.x) + sq(steps_dist_mm.y), sq(steps_dist_mm.i) + sq(steps_dist_mm.j))
-          #else // Foamcutter with only two axes (XY)
-            sq(steps_dist_mm.x) + sq(steps_dist_mm.y)
-          #endif
-        #elif ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
-          XYZ_GANG(sq(steps_dist_mm.head.x), + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.z))
+      const xyze_pos_t displacement = LOGICAL_AXIS_ARRAY(
+        steps_dist_mm.e,
+        #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
+          steps_dist_mm.head.x,
+          steps_dist_mm.head.y,
+          steps_dist_mm.z,
         #elif CORE_IS_XZ
-          XYZ_GANG(sq(steps_dist_mm.head.x), + sq(steps_dist_mm.y),      + sq(steps_dist_mm.head.z))
+          steps_dist_mm.head.x,
+          steps_dist_mm.y,
+          steps_dist_mm.head.z,
         #elif CORE_IS_YZ
-          XYZ_GANG(sq(steps_dist_mm.x),      + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.head.z))
+          steps_dist_mm.x,
+          steps_dist_mm.head.y,
+          steps_dist_mm.head.z,
         #else
-          XYZ_GANG(sq(steps_dist_mm.x),       + sq(steps_dist_mm.y),      + sq(steps_dist_mm.z))
+          steps_dist_mm.x,
+          steps_dist_mm.y,
+          steps_dist_mm.z,
         #endif
+        steps_dist_mm.i,
+        steps_dist_mm.j,
+        steps_dist_mm.k,
+        steps_dist_mm.u,
+        steps_dist_mm.v,
+        steps_dist_mm.w
       );
 
-      #if SECONDARY_LINEAR_AXES && NONE(FOAMCUTTER_XYUV, ARTICULATED_ROBOT_ARM)
-        if (UNEAR_ZERO(distance_sqr)) {
-          // Move does not involve any primary linear axes (xyz) but might involve secondary linear axes
-          distance_sqr = (0.0f
-            SECONDARY_AXIS_GANG(
-              IF_DISABLED(AXIS4_ROTATES, + sq(steps_dist_mm.i)),
-              IF_DISABLED(AXIS5_ROTATES, + sq(steps_dist_mm.j)),
-              IF_DISABLED(AXIS6_ROTATES, + sq(steps_dist_mm.k)),
-              IF_DISABLED(AXIS7_ROTATES, + sq(steps_dist_mm.u)),
-              IF_DISABLED(AXIS8_ROTATES, + sq(steps_dist_mm.v)),
-              IF_DISABLED(AXIS9_ROTATES, + sq(steps_dist_mm.w))
-            )
-          );
-        }
-      #endif
-
-      #if HAS_ROTATIONAL_AXES && NONE(FOAMCUTTER_XYUV, ARTICULATED_ROBOT_ARM)
-        if (UNEAR_ZERO(distance_sqr)) {
-          // Move involves only rotational axes. Calculate angular distance in accordance with LinuxCNC
-          TERN_(INCH_MODE_SUPPORT, cartesian_move = false);
-          distance_sqr = ROTATIONAL_AXIS_GANG(sq(steps_dist_mm.i), + sq(steps_dist_mm.j), + sq(steps_dist_mm.k), + sq(steps_dist_mm.u), + sq(steps_dist_mm.v), + sq(steps_dist_mm.w));
-        }
-      #endif
-
-      block->millimeters = SQRT(distance_sqr);
+      block->millimeters = get_move_distance(displacement OPTARG(HAS_ROTATIONAL_AXES, cartesian_move));
     }
 
     /**
      * At this point at least one of the axes has more steps than
      * MIN_STEPS_PER_SEGMENT, ensuring the segment won't get dropped as
      * zero-length. It's important to not apply corrections
      * to blocks that would get dropped!
      *
      * A correction function is permitted to add steps to an axis, it
      * should *never* remove steps!
@@ -2347,26 +2310,27 @@ bool Planner::_populate_block(
   if (esteps)
     NOLESS(fr_mm_s, settings.min_feedrate_mm_s);
   else
     NOLESS(fr_mm_s, settings.min_travel_feedrate_mm_s);
 
   const float inverse_millimeters = 1.0f / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate inverse time for this move. No divide by zero due to previous checks.
   // Example: At 120mm/s a 60mm move involving XYZ axes takes 0.5s. So this will give 2.0.
   // Example 2: At 120¬∞/s a 60¬∞ move involving only rotational axes takes 0.5s. So this will give 2.0.
-  float inverse_secs;
-  #if BOTH(HAS_ROTATIONAL_AXES, INCH_MODE_SUPPORT)
-    inverse_secs = inverse_millimeters * (cartesian_move ? fr_mm_s : LINEAR_UNIT(fr_mm_s));
-  #else
-    inverse_secs = fr_mm_s * inverse_millimeters;
-  #endif
+  float inverse_secs = inverse_millimeters * (
+    #if BOTH(HAS_ROTATIONAL_AXES, INCH_MODE_SUPPORT)
+      cartesian_move ? fr_mm_s : LINEAR_UNIT(fr_mm_s)
+    #else
+      fr_mm_s
+    #endif
+  );
 
   // Get the number of non busy movements in queue (non busy means that they can be altered)
   const uint8_t moves_queued = nonbusy_movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if EITHER(SLOWDOWN, HAS_WIRED_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time in microseconds
     int32_t segment_time_us = LROUND(1000000.0f / inverse_secs);
   #endif
 
@@ -3150,23 +3114,21 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s
         cart.i - position_cart.i, cart.j - position_cart.j, cart.k - position_cart.k,
         cart.u - position_cart.u, cart.v - position_cart.v, cart.w - position_cart.w
       );
     #endif
 
     // Cartesian XYZ to kinematic ABC, stored in global 'delta'
     inverse_kinematics(machine);
 
     PlannerHints ph = hints;
     if (!hints.millimeters)
-      ph.millimeters = (cart_dist_mm.x || cart_dist_mm.y)
-        ? xyz_pos_t(cart_dist_mm).magnitude()
-        : TERN0(HAS_Z_AXIS, ABS(cart_dist_mm.z));
+      ph.millimeters = get_move_distance(xyze_pos_t(cart_dist_mm) OPTARG(HAS_ROTATIONAL_AXES, ph.cartesian_move));
 
     #if DISABLED(FEEDRATE_SCALING)
 
       const feedRate_t feedrate = fr_mm_s;
 
     #elif IS_SCARA
 
       // For SCARA scale the feedrate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
       const float duration_recip = hints.inv_duration ?: fr_mm_s / ph.millimeters;

commit f595878b5b12ba87c88e43160b3434e76c782998
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 8 20:28:56 2023 -0600

    ü©π Various simple fixes

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index aceaf8a253..46aff32481 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2185,21 +2185,21 @@ bool Planner::_populate_block(
           XYZ_GANG(sq(steps_dist_mm.head.x), + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.z))
         #elif CORE_IS_XZ
           XYZ_GANG(sq(steps_dist_mm.head.x), + sq(steps_dist_mm.y),      + sq(steps_dist_mm.head.z))
         #elif CORE_IS_YZ
           XYZ_GANG(sq(steps_dist_mm.x),      + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.head.z))
         #else
           XYZ_GANG(sq(steps_dist_mm.x),       + sq(steps_dist_mm.y),      + sq(steps_dist_mm.z))
         #endif
       );
 
-      #if SECONDARY_LINEAR_AXES >= 1 && NONE(FOAMCUTTER_XYUV, ARTICULATED_ROBOT_ARM)
+      #if SECONDARY_LINEAR_AXES && NONE(FOAMCUTTER_XYUV, ARTICULATED_ROBOT_ARM)
         if (UNEAR_ZERO(distance_sqr)) {
           // Move does not involve any primary linear axes (xyz) but might involve secondary linear axes
           distance_sqr = (0.0f
             SECONDARY_AXIS_GANG(
               IF_DISABLED(AXIS4_ROTATES, + sq(steps_dist_mm.i)),
               IF_DISABLED(AXIS5_ROTATES, + sq(steps_dist_mm.j)),
               IF_DISABLED(AXIS6_ROTATES, + sq(steps_dist_mm.k)),
               IF_DISABLED(AXIS7_ROTATES, + sq(steps_dist_mm.u)),
               IF_DISABLED(AXIS8_ROTATES, + sq(steps_dist_mm.v)),
               IF_DISABLED(AXIS9_ROTATES, + sq(steps_dist_mm.w))

commit 7717beb79362522b8239d5af62b32ff3d0e2d748
Author: kadir ilkimen <kadirilkimen@gmail.com>
Date:   Wed Jan 11 06:29:38 2023 +0200

    ‚ú® Polar Kinematics (#25214)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 867b6a98a8..aceaf8a253 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -3154,38 +3154,89 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s
 
     // Cartesian XYZ to kinematic ABC, stored in global 'delta'
     inverse_kinematics(machine);
 
     PlannerHints ph = hints;
     if (!hints.millimeters)
       ph.millimeters = (cart_dist_mm.x || cart_dist_mm.y)
         ? xyz_pos_t(cart_dist_mm).magnitude()
         : TERN0(HAS_Z_AXIS, ABS(cart_dist_mm.z));
 
-    #if ENABLED(SCARA_FEEDRATE_SCALING)
+    #if DISABLED(FEEDRATE_SCALING)
+
+      const feedRate_t feedrate = fr_mm_s;
+
+    #elif IS_SCARA
+
       // For SCARA scale the feedrate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
       const float duration_recip = hints.inv_duration ?: fr_mm_s / ph.millimeters;
       const xyz_pos_t diff = delta - position_float;
       const feedRate_t feedrate = diff.magnitude() * duration_recip;
-    #else
-      const feedRate_t feedrate = fr_mm_s;
-    #endif
+
+    #elif ENABLED(POLAR)
+
+      /**
+       * Motion problem for Polar axis near center / origin:
+       *
+       * 3D printing:
+       * Movements very close to the center of the polar axis take more time than others.
+       * This brief delay results in more material deposition due to the pressure in the nozzle.
+       *
+       * Current Kinematics and feedrate scaling deals with this by making the movement as fast
+       * as possible. It works for slow movements but doesn't work well with fast ones. A more
+       * complicated extrusion compensation must be implemented.
+       *
+       * Ideally, it should estimate that a long rotation near the center is ahead and will cause
+       * unwanted deposition. Therefore it can compensate the extrusion beforehand.
+       *
+       * Laser cutting:
+       * Same thing would be a problem for laser engraving too. As it spends time rotating at the
+       * center point, more likely it will burn more material than it should. Therefore similar
+       * compensation would be implemented for laser-cutting operations.
+       *
+       * Milling:
+       * This shouldn't be a problem for cutting/milling operations.
+       */
+      feedRate_t calculated_feedrate = fr_mm_s;
+      const xyz_pos_t diff = delta - position_float;
+      if (!NEAR_ZERO(diff.b)) {
+        if (delta.a <= POLAR_FAST_RADIUS )
+          calculated_feedrate = settings.max_feedrate_mm_s[Y_AXIS];
+        else {
+            // Normalized vector of movement
+            const float diffBLength = ABS((2.0f * PI * diff.a) * (diff.b / 360.0f)),
+                        diffTheta = DEGREES(ATAN2(diff.a, diffBLength)),
+                        normalizedTheta = 1.0f - (ABS(diffTheta > 90.0f ? 180.0f - diffTheta : diffTheta) / 90.0f);
+
+            // Normalized position along the radius
+            const float radiusRatio = PRINTABLE_RADIUS/delta.a;
+            calculated_feedrate += (fr_mm_s * radiusRatio * normalizedTheta);
+        }
+      }
+      const feedRate_t feedrate = calculated_feedrate;
+
+    #endif // POLAR && FEEDRATE_SCALING
+
     TERN_(HAS_EXTRUDERS, delta.e = machine.e);
     if (buffer_segment(delta OPTARG(HAS_DIST_MM_ARG, cart_dist_mm), feedrate, extruder, ph)) {
       position_cart = cart;
       return true;
     }
     return false;
-  #else
+
+  #else // !IS_KINEMATIC
+
     return buffer_segment(machine, fr_mm_s, extruder, hints);
+
   #endif
+
 } // buffer_line()
 
 #if ENABLED(DIRECT_STEPPING)
 
   void Planner::buffer_page(const page_idx_t page_idx, const uint8_t extruder, const uint16_t num_steps) {
     if (!last_page_step_rate) {
       kill(GET_TEXT_F(MSG_BAD_PAGE_SPEED));
       return;
     }
 

commit c7e84e8ef145a35b2c90e1a6f1d908929cc46d83
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Dec 31 15:59:13 2022 +1300

    ‚ú® Persistent AUTOTEMP settings (#25093)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ed85045098..867b6a98a8 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -191,27 +191,26 @@ float Planner::mm_per_step[DISTINCT_AXES];      // (mm) Millimeters per step
   #endif
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
     float Planner::z_fade_height,      // Initialized by settings.load()
           Planner::inverse_z_fade_height,
           Planner::last_fade_z;
   #endif
 #else
   constexpr bool Planner::leveling_active;
 #endif
 
-skew_factor_t Planner::skew_factor; // Initialized by settings.load()
+#if ENABLED(SKEW_CORRECTION)
+  skew_factor_t Planner::skew_factor; // Initialized by settings.load()
+#endif
 
 #if ENABLED(AUTOTEMP)
-  celsius_t Planner::autotemp_max = 250,
-            Planner::autotemp_min = 210;
-  float Planner::autotemp_factor = 0.1f;
-  bool Planner::autotemp_enabled = false;
+  autotemp_t Planner::autotemp = { AUTOTEMP_MIN, AUTOTEMP_MAX, AUTOTEMP_FACTOR, false };
 #endif
 
 // private:
 
 xyze_long_t Planner::position{0};
 
 uint32_t Planner::acceleration_long_cutoff;
 
 xyze_float_t Planner::previous_speed;
 float Planner::previous_nominal_speed;
@@ -1427,74 +1426,74 @@ void Planner::check_axes_activity() {
     TERN_(HAS_HEATER_1, hal.set_pwm_duty(pin_t(HEATER_1_PIN), tail_valve_pressure));
     TERN_(HAS_HEATER_2, hal.set_pwm_duty(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
   #endif
 }
 
 #if ENABLED(AUTOTEMP)
 
   #if ENABLED(AUTOTEMP_PROPORTIONAL)
     void Planner::_autotemp_update_from_hotend() {
       const celsius_t target = thermalManager.degTargetHotend(active_extruder);
-      autotemp_min = target + AUTOTEMP_MIN_P;
-      autotemp_max = target + AUTOTEMP_MAX_P;
+      autotemp.min = target + AUTOTEMP_MIN_P;
+      autotemp.max = target + AUTOTEMP_MAX_P;
     }
   #endif
 
   /**
    * Called after changing tools to:
    *  - Reset or re-apply the default proportional autotemp factor.
    *  - Enable autotemp if the factor is non-zero.
    */
   void Planner::autotemp_update() {
     _autotemp_update_from_hotend();
-    autotemp_factor = TERN(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P, 0);
-    autotemp_enabled = autotemp_factor != 0;
+    autotemp.factor = TERN(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P, 0);
+    autotemp.enabled = autotemp.factor != 0;
   }
 
   /**
    * Called by the M104/M109 commands after setting Hotend Temperature
    *
    */
   void Planner::autotemp_M104_M109() {
     _autotemp_update_from_hotend();
 
-    if (parser.seenval('S')) autotemp_min = parser.value_celsius();
-    if (parser.seenval('B')) autotemp_max = parser.value_celsius();
+    if (parser.seenval('S')) autotemp.min = parser.value_celsius();
+    if (parser.seenval('B')) autotemp.max = parser.value_celsius();
 
     // When AUTOTEMP_PROPORTIONAL is enabled, F0 disables autotemp.
     // Normally, leaving off F also disables autotemp.
-    autotemp_factor = parser.seen('F') ? parser.value_float() : TERN(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P, 0);
-    autotemp_enabled = autotemp_factor != 0;
+    autotemp.factor = parser.seen('F') ? parser.value_float() : TERN(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P, 0);
+    autotemp.enabled = autotemp.factor != 0;
   }
 
   /**
    * Called every so often to adjust the hotend target temperature
    * based on the extrusion speed, which is calculated from the blocks
    * currently in the planner.
    */
   void Planner::autotemp_task() {
     static float oldt = 0.0f;
 
-    if (!autotemp_enabled) return;
-    if (thermalManager.degTargetHotend(active_extruder) < autotemp_min - 2) return; // Below the min?
+    if (!autotemp.enabled) return;
+    if (thermalManager.degTargetHotend(active_extruder) < autotemp.min - 2) return; // Below the min?
 
     float high = 0.0f;
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       const block_t * const block = &block_buffer[b];
       if (NUM_AXIS_GANG(block->steps.x, || block->steps.y, || block->steps.z, || block->steps.i, || block->steps.j, || block->steps.k, || block->steps.u, || block->steps.v, || block->steps.w)) {
         const float se = float(block->steps.e) / block->step_event_count * block->nominal_speed; // mm/sec
         NOLESS(high, se);
       }
     }
 
-    float t = autotemp_min + high * autotemp_factor;
-    LIMIT(t, autotemp_min, autotemp_max);
+    float t = autotemp.min + high * autotemp.factor;
+    LIMIT(t, autotemp.min, autotemp.max);
     if (t < oldt) t = t * (1.0f - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
     oldt = t;
     thermalManager.setTargetHotend(t, active_extruder);
   }
 
 #endif
 
 #if DISABLED(NO_VOLUMETRICS)
 
   /**

commit 89334caa526f2d300eee834d34d06d8f837a57d5
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Mon Nov 28 03:38:15 2022 +0000

    ‚ö°Ô∏è Input Shaping improvements (#24951)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 0128d90f0f..ed85045098 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1717,20 +1717,27 @@ void Planner::quick_stop() {
 void Planner::endstop_triggered(const AxisEnum axis) {
   // Record stepper position and discard the current block
   stepper.endstop_triggered(axis);
 }
 
 float Planner::triggered_position_mm(const AxisEnum axis) {
   const float result = DIFF_TERN(BACKLASH_COMPENSATION, stepper.triggered_position(axis), backlash.get_applied_steps(axis));
   return result * mm_per_step[axis];
 }
 
+bool Planner::busy() {
+  return (has_blocks_queued() || cleaning_buffer_counter
+      || TERN0(EXTERNAL_CLOSED_LOOP_CONTROLLER, CLOSED_LOOP_WAITING())
+      || TERN0(HAS_SHAPING, stepper.input_shaping_busy())
+  );
+}
+
 void Planner::finish_and_disable() {
   while (has_blocks_queued() || cleaning_buffer_counter) idle();
   stepper.disable_all_steppers();
 }
 
 /**
  * Get an axis position according to stepper position(s)
  * For CORE machines apply translation from ABC to XYZ.
  */
 float Planner::get_axis_position_mm(const AxisEnum axis) {
@@ -2476,28 +2483,20 @@ bool Planner::_populate_block(
         if (least_xy_segment_time < xy_freq_min_interval_us) {
           float freq_xy_feedrate = (speed_factor * least_xy_segment_time) / xy_freq_min_interval_us;
           NOLESS(freq_xy_feedrate, xy_freq_min_speed_factor);
           NOMORE(speed_factor, freq_xy_feedrate);
         }
       }
     }
 
   #endif // XY_FREQUENCY_LIMIT
 
-  #if ENABLED(INPUT_SHAPING)
-    const float top_freq = _MIN(float(0x7FFFFFFFL)
-                                OPTARG(HAS_SHAPING_X, stepper.get_shaping_frequency(X_AXIS))
-                                OPTARG(HAS_SHAPING_Y, stepper.get_shaping_frequency(Y_AXIS))),
-                max_factor = (top_freq * float(shaping_dividends - 3) * 2.0f) / block->nominal_rate;
-    NOMORE(speed_factor, max_factor);
-  #endif
-
   // Correct the speed
   if (speed_factor < 1.0f) {
     current_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
     block->nominal_speed *= speed_factor;
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;

commit 9c092ed0fcbe4f96300c9f2ecafa903cec54ca73
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Nov 26 14:17:24 2022 +1300

    ü©π Fix planner typo (#24977)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index dce9160664..0128d90f0f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2160,21 +2160,21 @@ bool Planner::_populate_block(
        *     D^2 = dA^2 + dB^2 + dC^2
        */
       float distance_sqr = (
         #if ENABLED(ARTICULATED_ROBOT_ARM)
           // For articulated robots, interpreting feedrate like LinuxCNC would require inverse kinematics. As a workaround, pretend that motors sit on n mutually orthogonal
           // axes and assume that we could think of distance as magnitude of an n-vector in an n-dimensional Euclidian space.
           NUM_AXIS_GANG(
               sq(steps_dist_mm.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.z),
             + sq(steps_dist_mm.i), + sq(steps_dist_mm.j), + sq(steps_dist_mm.k),
             + sq(steps_dist_mm.u), + sq(steps_dist_mm.v), + sq(steps_dist_mm.w)
-          );
+          )
         #elif ENABLED(FOAMCUTTER_XYUV)
           #if HAS_J_AXIS
             // Special 5 axis kinematics. Return the largest distance move from either X/Y or I/J plane
             _MAX(sq(steps_dist_mm.x) + sq(steps_dist_mm.y), sq(steps_dist_mm.i) + sq(steps_dist_mm.j))
           #else // Foamcutter with only two axes (XY)
             sq(steps_dist_mm.x) + sq(steps_dist_mm.y)
           #endif
         #elif ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
           XYZ_GANG(sq(steps_dist_mm.head.x), + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.z))
         #elif CORE_IS_XZ

commit a460b01c876ff39901fe55a4b66b2c62737ef46c
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Oct 21 22:34:22 2022 +0100

    üöÄ ZV Input Shaping (#24797)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 3263e7660a..dce9160664 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2476,20 +2476,28 @@ bool Planner::_populate_block(
         if (least_xy_segment_time < xy_freq_min_interval_us) {
           float freq_xy_feedrate = (speed_factor * least_xy_segment_time) / xy_freq_min_interval_us;
           NOLESS(freq_xy_feedrate, xy_freq_min_speed_factor);
           NOMORE(speed_factor, freq_xy_feedrate);
         }
       }
     }
 
   #endif // XY_FREQUENCY_LIMIT
 
+  #if ENABLED(INPUT_SHAPING)
+    const float top_freq = _MIN(float(0x7FFFFFFFL)
+                                OPTARG(HAS_SHAPING_X, stepper.get_shaping_frequency(X_AXIS))
+                                OPTARG(HAS_SHAPING_Y, stepper.get_shaping_frequency(Y_AXIS))),
+                max_factor = (top_freq * float(shaping_dividends - 3) * 2.0f) / block->nominal_rate;
+    NOMORE(speed_factor, max_factor);
+  #endif
+
   // Correct the speed
   if (speed_factor < 1.0f) {
     current_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
     block->nominal_speed *= speed_factor;
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;

commit 02c43f44c73b76c8d8d1e48b8e595ced62da2459
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Oct 21 14:03:38 2022 -0400

    ‚ú® Controllerfan PWM scaling, kickstart (#24873)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 91a994470a..3263e7660a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1275,51 +1275,45 @@ void Planner::recalculate(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t safe_exit_s
   recalculate_trapezoids(TERN_(HINTS_SAFE_EXIT_SPEED, safe_exit_speed_sqr));
 }
 
 /**
  * Apply fan speeds
  */
 #if HAS_FAN
 
   void Planner::sync_fan_speeds(uint8_t (&fan_speed)[FAN_COUNT]) {
 
-    #if FAN_MIN_PWM != 0 || FAN_MAX_PWM != 255
-      #define CALC_FAN_SPEED(f) (fan_speed[f] ? map(fan_speed[f], 1, 255, FAN_MIN_PWM, FAN_MAX_PWM) : FAN_OFF_PWM)
-    #else
-      #define CALC_FAN_SPEED(f) (fan_speed[f] ?: FAN_OFF_PWM)
-    #endif
-
     #if ENABLED(FAN_SOFT_PWM)
-      #define _FAN_SET(F) thermalManager.soft_pwm_amount_fan[F] = CALC_FAN_SPEED(F);
+      #define _FAN_SET(F) thermalManager.soft_pwm_amount_fan[F] = CALC_FAN_SPEED(fan_speed[F]);
     #else
-      #define _FAN_SET(F) hal.set_pwm_duty(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(F));
+      #define _FAN_SET(F) hal.set_pwm_duty(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(fan_speed[F]));
     #endif
     #define FAN_SET(F) do{ kickstart_fan(fan_speed, ms, F); _FAN_SET(F); }while(0)
 
     const millis_t ms = millis();
     TERN_(HAS_FAN0, FAN_SET(0)); TERN_(HAS_FAN1, FAN_SET(1));
     TERN_(HAS_FAN2, FAN_SET(2)); TERN_(HAS_FAN3, FAN_SET(3));
     TERN_(HAS_FAN4, FAN_SET(4)); TERN_(HAS_FAN5, FAN_SET(5));
     TERN_(HAS_FAN6, FAN_SET(6)); TERN_(HAS_FAN7, FAN_SET(7));
   }
 
   #if FAN_KICKSTART_TIME
 
     void Planner::kickstart_fan(uint8_t (&fan_speed)[FAN_COUNT], const millis_t &ms, const uint8_t f) {
       static millis_t fan_kick_end[FAN_COUNT] = { 0 };
-      if (fan_speed[f]) {
+      if (fan_speed[f] > FAN_OFF_PWM) {
         if (fan_kick_end[f] == 0) {
           fan_kick_end[f] = ms + FAN_KICKSTART_TIME;
-          fan_speed[f] = 255;
+          fan_speed[f] = FAN_KICKSTART_POWER;
         }
         else if (PENDING(ms, fan_kick_end[f]))
-          fan_speed[f] = 255;
+          fan_speed[f] = FAN_KICKSTART_POWER;
       }
       else
         fan_kick_end[f] = 0;
     }
 
   #endif
 
 #endif // HAS_FAN
 
 /**

commit 5a80fc261736f6e88ec87b5544228383e2937894
Author: Dan Royer <dan@marginallyclever.com>
Date:   Sat Oct 15 22:03:42 2022 -0700

    üêõ Fix and improve Polargraph (#24847)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index dee86cad90..91a994470a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2237,21 +2237,20 @@ bool Planner::_populate_block(
     block->steps.a, block->steps.b, block->steps.c,
     block->steps.i, block->steps.j, block->steps.k,
     block->steps.u, block->steps.v, block->steps.w
   ));
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   TERN_(MIXING_EXTRUDER, mixer.populate_block(block->b_color));
 
-
   #if HAS_FAN
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
   E_TERN_(block->extruder = extruder);

commit efde96131d9e9288dc2ea28b548f691a184fb33e
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Mon Oct 10 20:49:37 2022 +0200

    ‚ú® ADVANCE_K per-extruder (#24821)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 6ef1ed6c28..dee86cad90 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -220,21 +220,21 @@ float Planner::previous_nominal_speed;
   last_move_t Planner::g_uc_extruder_last_move[E_STEPPERS] = { 0 };
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
   int8_t Planner::xy_freq_limit_hz = XY_FREQUENCY_LIMIT;
   float Planner::xy_freq_min_speed_factor = (XY_FREQUENCY_MIN_PERCENT) * 0.01f;
   int32_t Planner::xy_freq_min_interval_us = LROUND(1000000.0f / (XY_FREQUENCY_LIMIT));
 #endif
 
 #if ENABLED(LIN_ADVANCE)
-  float Planner::extruder_advance_K[EXTRUDERS]; // Initialized by settings.load()
+  float Planner::extruder_advance_K[DISTINCT_E]; // Initialized by settings.load()
 #endif
 
 #if HAS_POSITION_FLOAT
   xyze_pos_t Planner::position_float; // Needed for accurate maths. Steps cannot be used!
 #endif
 
 #if IS_KINEMATIC
   xyze_pos_t Planner::position_cart;
 #endif
 
@@ -847,21 +847,21 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
     block->acceleration_time = acceleration_time;
     block->deceleration_time = deceleration_time;
     block->acceleration_time_inverse = acceleration_time_inverse;
     block->deceleration_time_inverse = deceleration_time_inverse;
     block->cruise_rate = cruise_rate;
   #endif
   block->final_rate = final_rate;
 
   #if ENABLED(LIN_ADVANCE)
     if (block->la_advance_rate) {
-      const float comp = extruder_advance_K[block->extruder] * block->steps.e / block->step_event_count;
+      const float comp = extruder_advance_K[E_INDEX_N(block->extruder)] * block->steps.e / block->step_event_count;
       block->max_adv_steps = cruise_rate * comp;
       block->final_adv_steps = final_rate * comp;
     }
   #endif
 
   #if ENABLED(LASER_POWER_TRAP)
     /**
      * Laser Trapezoid Calculations
      *
      * Approximate the trapezoid with the laser, incrementing the power every `trap_ramp_entry_incr`
@@ -2534,37 +2534,37 @@ bool Planner::_populate_block(
 
       /**
        * Use LIN_ADVANCE for blocks if all these are true:
        *
        * esteps                       : This is a print move, because we checked for A, B, C steps before.
        *
        * extruder_advance_K[extruder] : There is an advance factor set for this extruder.
        *
        * de > 0                       : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
        */
-      use_advance_lead = esteps && extruder_advance_K[extruder] && de > 0;
+      use_advance_lead = esteps && extruder_advance_K[E_INDEX_N(extruder)] && de > 0;
 
       if (use_advance_lead) {
         float e_D_ratio = (target_float.e - position_float.e) /
           TERN(IS_KINEMATIC, block->millimeters,
             SQRT(sq(target_float.x - position_float.x)
                + sq(target_float.y - position_float.y)
                + sq(target_float.z - position_float.z))
           );
 
         // Check for unusual high e_D ratio to detect if a retract move was combined with the last print move due to min. steps per segment. Never execute this with advance!
         // This assumes no one will use a retract length of 0mm < retr_length < ~0.2mm and no one will print 100mm wide lines using 3mm filament or 35mm wide lines using 1.75mm filament.
         if (e_D_ratio > 3.0f)
           use_advance_lead = false;
         else {
           // Scale E acceleration so that it will be possible to jump to the advance speed.
-          const uint32_t max_accel_steps_per_s2 = MAX_E_JERK(extruder) / (extruder_advance_K[extruder] * e_D_ratio) * steps_per_mm;
+          const uint32_t max_accel_steps_per_s2 = MAX_E_JERK(extruder) / (extruder_advance_K[E_INDEX_N(extruder)] * e_D_ratio) * steps_per_mm;
           if (TERN0(LA_DEBUG, accel > max_accel_steps_per_s2))
             SERIAL_ECHOLNPGM("Acceleration limited.");
           NOMORE(accel, max_accel_steps_per_s2);
         }
       }
     #endif
 
     // Limit acceleration per axis
     if (block->step_event_count <= acceleration_long_cutoff) {
       LOGICAL_AXIS_CODE(
@@ -2587,21 +2587,21 @@ bool Planner::_populate_block(
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
     block->acceleration_rate = (uint32_t)(accel * (float(1UL << 24) / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     block->la_advance_rate = 0;
     block->la_scaling = 0;
 
     if (use_advance_lead) {
       // the Bresenham algorithm will convert this step rate into extruder steps
-      block->la_advance_rate = extruder_advance_K[extruder] * block->acceleration_steps_per_s2;
+      block->la_advance_rate = extruder_advance_K[E_INDEX_N(extruder)] * block->acceleration_steps_per_s2;
 
       // reduce LA ISR frequency by calling it only often enough to ensure that there will
       // never be more than four extruder steps per call
       for (uint32_t dividend = block->steps.e << 1; dividend <= (block->step_event_count >> 2); dividend <<= 1)
         block->la_scaling++;
 
       #if ENABLED(LA_DEBUG)
         if (block->la_advance_rate >> block->la_scaling > 10000)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz: ", block->la_advance_rate);
       #endif

commit 1e525c597699536d3185dfc92b3066bc6b4ef695
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 17 20:36:55 2022 -0500

    ü©π Fix inverse_accel redefine
    
    Followup to #24737

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 605c2ecfbd..6ef1ed6c28 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -794,22 +794,22 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
   #endif
 
   // Steps for acceleration, plateau and deceleration
   int32_t plateau_steps = block->step_event_count;
   uint32_t accelerate_steps = 0,
            decelerate_steps = 0;
 
   const int32_t accel = block->acceleration_steps_per_s2;
   float inverse_accel = 0.0f;
   if (accel != 0) {
-    const float inverse_accel = 1.0f / accel,
-                half_inverse_accel = 0.5f * inverse_accel,
+    inverse_accel = 1.0f / accel;
+    const float half_inverse_accel = 0.5f * inverse_accel,
                 nominal_rate_sq = sq(float(block->nominal_rate)),
                 // Steps required for acceleration, deceleration to/from nominal rate
                 decelerate_steps_float = half_inverse_accel * (nominal_rate_sq - sq(float(final_rate)));
           float accelerate_steps_float = half_inverse_accel * (nominal_rate_sq - sq(float(initial_rate)));
     accelerate_steps = CEIL(accelerate_steps_float);
     decelerate_steps = FLOOR(decelerate_steps_float);
 
     // Steps between acceleration and deceleration, if any
     plateau_steps -= accelerate_steps + decelerate_steps;
 

commit d5cf0b334802cf825e501135a55d1d63884004a1
Author: XDA-Bam <1209896+XDA-Bam@users.noreply.github.com>
Date:   Fri Sep 9 22:51:11 2022 +0200

    ‚ö°Ô∏è Minor planner optimization (#24737)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 1c9601632d..605c2ecfbd 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -786,33 +786,35 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
 
   // Limit minimal step rate (Otherwise the timer will overflow.)
   NOLESS(initial_rate, uint32_t(MINIMAL_STEP_RATE));
   NOLESS(final_rate, uint32_t(MINIMAL_STEP_RATE));
 
   #if EITHER(S_CURVE_ACCELERATION, LIN_ADVANCE)
     // If we have some plateau time, the cruise rate will be the nominal rate
     uint32_t cruise_rate = block->nominal_rate;
   #endif
 
-  const int32_t accel = block->acceleration_steps_per_s2;
-
   // Steps for acceleration, plateau and deceleration
   int32_t plateau_steps = block->step_event_count;
   uint32_t accelerate_steps = 0,
            decelerate_steps = 0;
 
+  const int32_t accel = block->acceleration_steps_per_s2;
+  float inverse_accel = 0.0f;
   if (accel != 0) {
-    // Steps required for acceleration, deceleration to/from nominal rate
-    const float nominal_rate_sq = sq(float(block->nominal_rate));
-    float accelerate_steps_float = (nominal_rate_sq - sq(float(initial_rate))) * (0.5f / accel);
+    const float inverse_accel = 1.0f / accel,
+                half_inverse_accel = 0.5f * inverse_accel,
+                nominal_rate_sq = sq(float(block->nominal_rate)),
+                // Steps required for acceleration, deceleration to/from nominal rate
+                decelerate_steps_float = half_inverse_accel * (nominal_rate_sq - sq(float(final_rate)));
+          float accelerate_steps_float = half_inverse_accel * (nominal_rate_sq - sq(float(initial_rate)));
     accelerate_steps = CEIL(accelerate_steps_float);
-    const float decelerate_steps_float = (nominal_rate_sq - sq(float(final_rate))) * (0.5f / accel);
     decelerate_steps = FLOOR(decelerate_steps_float);
 
     // Steps between acceleration and deceleration, if any
     plateau_steps -= accelerate_steps + decelerate_steps;
 
     // Does accelerate_steps + decelerate_steps exceed step_event_count?
     // Then we can't possibly reach the nominal rate, there will be no cruising.
     // Calculate accel / braking time in order to reach the final_rate exactly
     // at the end of this block.
     if (plateau_steps < 0) {
@@ -821,23 +823,24 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
       decelerate_steps = block->step_event_count - accelerate_steps;
 
       #if EITHER(S_CURVE_ACCELERATION, LIN_ADVANCE)
         // We won't reach the cruising rate. Let's calculate the speed we will reach
         cruise_rate = final_speed(initial_rate, accel, accelerate_steps);
       #endif
     }
   }
 
   #if ENABLED(S_CURVE_ACCELERATION)
+    const float rate_factor = inverse_accel * (STEPPER_TIMER_RATE);
     // Jerk controlled speed requires to express speed versus time, NOT steps
-    uint32_t acceleration_time = (float(cruise_rate - initial_rate) / accel) * (STEPPER_TIMER_RATE),
-             deceleration_time = (float(cruise_rate - final_rate) / accel) * (STEPPER_TIMER_RATE),
+    uint32_t acceleration_time = rate_factor * float(cruise_rate - initial_rate),
+             deceleration_time = rate_factor * float(cruise_rate - final_rate),
     // And to offload calculations from the ISR, we also calculate the inverse of those times here
              acceleration_time_inverse = get_period_inverse(acceleration_time),
              deceleration_time_inverse = get_period_inverse(deceleration_time);
   #endif
 
   // Store new block parameters
   block->accelerate_until = accelerate_steps;
   block->decelerate_after = block->step_event_count - decelerate_steps;
   block->initial_rate = initial_rate;
   #if ENABLED(S_CURVE_ACCELERATION)

commit 232a104a927988c63f8c0c53a8c2e26005166e2d
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sun Jul 31 03:39:48 2022 +0100

    Fix, improve Linear Advance (#24533)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 4bc81c1051..1c9601632d 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -781,21 +781,21 @@ block_t* Planner::get_current_block() {
  */
 void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t entry_factor, const_float_t exit_factor) {
 
   uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
            final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
 
   // Limit minimal step rate (Otherwise the timer will overflow.)
   NOLESS(initial_rate, uint32_t(MINIMAL_STEP_RATE));
   NOLESS(final_rate, uint32_t(MINIMAL_STEP_RATE));
 
-  #if ENABLED(S_CURVE_ACCELERATION)
+  #if EITHER(S_CURVE_ACCELERATION, LIN_ADVANCE)
     // If we have some plateau time, the cruise rate will be the nominal rate
     uint32_t cruise_rate = block->nominal_rate;
   #endif
 
   const int32_t accel = block->acceleration_steps_per_s2;
 
   // Steps for acceleration, plateau and deceleration
   int32_t plateau_steps = block->step_event_count;
   uint32_t accelerate_steps = 0,
            decelerate_steps = 0;
@@ -813,21 +813,21 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
 
     // Does accelerate_steps + decelerate_steps exceed step_event_count?
     // Then we can't possibly reach the nominal rate, there will be no cruising.
     // Calculate accel / braking time in order to reach the final_rate exactly
     // at the end of this block.
     if (plateau_steps < 0) {
       accelerate_steps_float = CEIL((block->step_event_count + accelerate_steps_float - decelerate_steps_float) * 0.5f);
       accelerate_steps = _MIN(uint32_t(_MAX(accelerate_steps_float, 0)), block->step_event_count);
       decelerate_steps = block->step_event_count - accelerate_steps;
 
-      #if ENABLED(S_CURVE_ACCELERATION)
+      #if EITHER(S_CURVE_ACCELERATION, LIN_ADVANCE)
         // We won't reach the cruising rate. Let's calculate the speed we will reach
         cruise_rate = final_speed(initial_rate, accel, accelerate_steps);
       #endif
     }
   }
 
   #if ENABLED(S_CURVE_ACCELERATION)
     // Jerk controlled speed requires to express speed versus time, NOT steps
     uint32_t acceleration_time = (float(cruise_rate - initial_rate) / accel) * (STEPPER_TIMER_RATE),
              deceleration_time = (float(cruise_rate - final_rate) / accel) * (STEPPER_TIMER_RATE),
@@ -842,20 +842,28 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
   block->initial_rate = initial_rate;
   #if ENABLED(S_CURVE_ACCELERATION)
     block->acceleration_time = acceleration_time;
     block->deceleration_time = deceleration_time;
     block->acceleration_time_inverse = acceleration_time_inverse;
     block->deceleration_time_inverse = deceleration_time_inverse;
     block->cruise_rate = cruise_rate;
   #endif
   block->final_rate = final_rate;
 
+  #if ENABLED(LIN_ADVANCE)
+    if (block->la_advance_rate) {
+      const float comp = extruder_advance_K[block->extruder] * block->steps.e / block->step_event_count;
+      block->max_adv_steps = cruise_rate * comp;
+      block->final_adv_steps = final_rate * comp;
+    }
+  #endif
+
   #if ENABLED(LASER_POWER_TRAP)
     /**
      * Laser Trapezoid Calculations
      *
      * Approximate the trapezoid with the laser, incrementing the power every `trap_ramp_entry_incr`
      * steps while accelerating, and decrementing the power every `trap_ramp_exit_decr` while decelerating,
      * to keep power proportional to feedrate. Laser power trap will reduce the initial power to no less
      * than the laser_power_floor value. Based on the number of calculated accel/decel steps the power is
      * distributed over the trapezoid entry- and exit-ramp steps.
      *
@@ -892,89 +900,90 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
           block->laser.trap_ramp_active_pwr = 0;
           block->laser.trap_ramp_entry_incr = 0;
           block->laser.trap_ramp_exit_decr = 0;
         }
 
       }
     }
   #endif // LASER_POWER_TRAP
 }
 
-/*                            PLANNER SPEED DEFINITION
-                                     +--------+   <- current->nominal_speed
-                                    /          \
-         current->entry_speed ->   +            \
-                                   |             + <- next->entry_speed (aka exit speed)
-                                   +-------------+
-                                       time -->
-
-  Recalculates the motion plan according to the following basic guidelines:
-
-    1. Go over every feasible block sequentially in reverse order and calculate the junction speeds
-        (i.e. current->entry_speed) such that:
-      a. No junction speed exceeds the pre-computed maximum junction speed limit or nominal speeds of
-         neighboring blocks.
-      b. A block entry speed cannot exceed one reverse-computed from its exit speed (next->entry_speed)
-         with a maximum allowable deceleration over the block travel distance.
-      c. The last (or newest appended) block is planned from a complete stop (an exit speed of zero).
-    2. Go over every block in chronological (forward) order and dial down junction speed values if
-      a. The exit speed exceeds the one forward-computed from its entry speed with the maximum allowable
-         acceleration over the block travel distance.
-
-  When these stages are complete, the planner will have maximized the velocity profiles throughout the all
-  of the planner blocks, where every block is operating at its maximum allowable acceleration limits. In
-  other words, for all of the blocks in the planner, the plan is optimal and no further speed improvements
-  are possible. If a new block is added to the buffer, the plan is recomputed according to the said
-  guidelines for a new optimal plan.
-
-  To increase computational efficiency of these guidelines, a set of planner block pointers have been
-  created to indicate stop-compute points for when the planner guidelines cannot logically make any further
-  changes or improvements to the plan when in normal operation and new blocks are streamed and added to the
-  planner buffer. For example, if a subset of sequential blocks in the planner have been planned and are
-  bracketed by junction velocities at their maximums (or by the first planner block as well), no new block
-  added to the planner buffer will alter the velocity profiles within them. So we no longer have to compute
-  them. Or, if a set of sequential blocks from the first block in the planner (or a optimal stop-compute
-  point) are all accelerating, they are all optimal and can not be altered by a new block added to the
-  planner buffer, as this will only further increase the plan speed to chronological blocks until a maximum
-  junction velocity is reached. However, if the operational conditions of the plan changes from infrequently
-  used feed holds or feedrate overrides, the stop-compute pointers will be reset and the entire plan is
-  recomputed as stated in the general guidelines.
-
-  Planner buffer index mapping:
-  - block_buffer_tail: Points to the beginning of the planner buffer. First to be executed or being executed.
-  - block_buffer_head: Points to the buffer block after the last block in the buffer. Used to indicate whether
-      the buffer is full or empty. As described for standard ring buffers, this block is always empty.
-  - block_buffer_planned: Points to the first buffer block after the last optimally planned block for normal
-      streaming operating conditions. Use for planning optimizations by avoiding recomputing parts of the
-      planner buffer that don't change with the addition of a new block, as describe above. In addition,
-      this block can never be less than block_buffer_tail and will always be pushed forward and maintain
-      this requirement when encountered by the Planner::release_current_block() routine during a cycle.
-
-  NOTE: Since the planner only computes on what's in the planner buffer, some motions with many short
-        segments (e.g., complex curves) may seem to move slowly. This is because there simply isn't
-        enough combined distance traveled in the entire buffer to accelerate up to the nominal speed and
-        then decelerate to a complete stop at the end of the buffer, as stated by the guidelines. If this
-        happens and becomes an annoyance, there are a few simple solutions:
-
-    - Maximize the machine acceleration. The planner will be able to compute higher velocity profiles
-      within the same combined distance.
-
-    - Maximize line motion(s) distance per block to a desired tolerance. The more combined distance the
-      planner has to use, the faster it can go.
-
-    - Maximize the planner buffer size. This also will increase the combined distance for the planner to
-      compute over. It also increases the number of computations the planner has to perform to compute an
-      optimal plan, so select carefully.
-
-    - Use G2/G3 arcs instead of many short segments. Arcs inform the planner of a safe exit speed at the
-      end of the last segment, which alleviates this problem.
-*/
+/**
+ *                              PLANNER SPEED DEFINITION
+ *                                     +--------+   <- current->nominal_speed
+ *                                    /          \
+ *         current->entry_speed ->   +            \
+ *                                   |             + <- next->entry_speed (aka exit speed)
+ *                                   +-------------+
+ *                                       time -->
+ *
+ *  Recalculates the motion plan according to the following basic guidelines:
+ *
+ *    1. Go over every feasible block sequentially in reverse order and calculate the junction speeds
+ *        (i.e. current->entry_speed) such that:
+ *      a. No junction speed exceeds the pre-computed maximum junction speed limit or nominal speeds of
+ *         neighboring blocks.
+ *      b. A block entry speed cannot exceed one reverse-computed from its exit speed (next->entry_speed)
+ *         with a maximum allowable deceleration over the block travel distance.
+ *      c. The last (or newest appended) block is planned from a complete stop (an exit speed of zero).
+ *    2. Go over every block in chronological (forward) order and dial down junction speed values if
+ *      a. The exit speed exceeds the one forward-computed from its entry speed with the maximum allowable
+ *         acceleration over the block travel distance.
+ *
+ *  When these stages are complete, the planner will have maximized the velocity profiles throughout the all
+ *  of the planner blocks, where every block is operating at its maximum allowable acceleration limits. In
+ *  other words, for all of the blocks in the planner, the plan is optimal and no further speed improvements
+ *  are possible. If a new block is added to the buffer, the plan is recomputed according to the said
+ *  guidelines for a new optimal plan.
+ *
+ *  To increase computational efficiency of these guidelines, a set of planner block pointers have been
+ *  created to indicate stop-compute points for when the planner guidelines cannot logically make any further
+ *  changes or improvements to the plan when in normal operation and new blocks are streamed and added to the
+ *  planner buffer. For example, if a subset of sequential blocks in the planner have been planned and are
+ *  bracketed by junction velocities at their maximums (or by the first planner block as well), no new block
+ *  added to the planner buffer will alter the velocity profiles within them. So we no longer have to compute
+ *  them. Or, if a set of sequential blocks from the first block in the planner (or a optimal stop-compute
+ *  point) are all accelerating, they are all optimal and can not be altered by a new block added to the
+ *  planner buffer, as this will only further increase the plan speed to chronological blocks until a maximum
+ *  junction velocity is reached. However, if the operational conditions of the plan changes from infrequently
+ *  used feed holds or feedrate overrides, the stop-compute pointers will be reset and the entire plan is
+ *  recomputed as stated in the general guidelines.
+ *
+ *  Planner buffer index mapping:
+ *  - block_buffer_tail: Points to the beginning of the planner buffer. First to be executed or being executed.
+ *  - block_buffer_head: Points to the buffer block after the last block in the buffer. Used to indicate whether
+ *      the buffer is full or empty. As described for standard ring buffers, this block is always empty.
+ *  - block_buffer_planned: Points to the first buffer block after the last optimally planned block for normal
+ *      streaming operating conditions. Use for planning optimizations by avoiding recomputing parts of the
+ *      planner buffer that don't change with the addition of a new block, as describe above. In addition,
+ *      this block can never be less than block_buffer_tail and will always be pushed forward and maintain
+ *      this requirement when encountered by the Planner::release_current_block() routine during a cycle.
+ *
+ *  NOTE: Since the planner only computes on what's in the planner buffer, some motions with many short
+ *        segments (e.g., complex curves) may seem to move slowly. This is because there simply isn't
+ *        enough combined distance traveled in the entire buffer to accelerate up to the nominal speed and
+ *        then decelerate to a complete stop at the end of the buffer, as stated by the guidelines. If this
+ *        happens and becomes an annoyance, there are a few simple solutions:
+ *
+ *    - Maximize the machine acceleration. The planner will be able to compute higher velocity profiles
+ *      within the same combined distance.
+ *
+ *    - Maximize line motion(s) distance per block to a desired tolerance. The more combined distance the
+ *      planner has to use, the faster it can go.
+ *
+ *    - Maximize the planner buffer size. This also will increase the combined distance for the planner to
+ *      compute over. It also increases the number of computations the planner has to perform to compute an
+ *      optimal plan, so select carefully.
+ *
+ *    - Use G2/G3 arcs instead of many short segments. Arcs inform the planner of a safe exit speed at the
+ *      end of the last segment, which alleviates this problem.
+ */
 
 // The kernel called by recalculate() when scanning the plan from last to first entry.
 void Planner::reverse_pass_kernel(block_t * const current, const block_t * const next
   OPTARG(HINTS_SAFE_EXIT_SPEED, const_float_t safe_exit_speed_sqr)
 ) {
   if (current) {
     // If entry speed is already at the maximum entry speed, and there was no change of speed
     // in the next block, there is no need to recheck. Block is cruising and there is no need to
     // compute anything for this block,
     // If not, block entry speed needs to be recalculated to ensure maximum possible planned speed.
@@ -1204,27 +1213,20 @@ void Planner::recalculate_trapezoids(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t
 
           // But there is an inherent race condition here, as the block maybe
           // became BUSY, just before it was marked as RECALCULATE, so check
           // if that is the case!
           if (!stepper.is_block_busy(block)) {
             // Block is not BUSY, we won the race against the Stepper ISR:
 
             // NOTE: Entry and exit factors always > 0 by all previous logic operations.
             const float nomr = 1.0f / block->nominal_speed;
             calculate_trapezoid_for_block(block, current_entry_speed * nomr, next_entry_speed * nomr);
-            #if ENABLED(LIN_ADVANCE)
-              if (block->use_advance_lead) {
-                const float comp = block->e_D_ratio * extruder_advance_K[active_extruder] * settings.axis_steps_per_mm[E_AXIS];
-                block->max_adv_steps = block->nominal_speed * comp;
-                block->final_adv_steps = next_entry_speed * comp;
-              }
-            #endif
           }
 
           // Reset current only to ensure next trapezoid is computed - The
           // stepper is free to use the block from now on.
           block->flag.recalculate = false;
         }
       }
 
       block = next;
       current_entry_speed = next_entry_speed;
@@ -1244,27 +1246,20 @@ void Planner::recalculate_trapezoids(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t
     block->flag.recalculate = true;
 
     // But there is an inherent race condition here, as the block maybe
     // became BUSY, just before it was marked as RECALCULATE, so check
     // if that is the case!
     if (!stepper.is_block_busy(block)) {
       // Block is not BUSY, we won the race against the Stepper ISR:
 
       const float nomr = 1.0f / block->nominal_speed;
       calculate_trapezoid_for_block(block, current_entry_speed * nomr, next_entry_speed * nomr);
-      #if ENABLED(LIN_ADVANCE)
-        if (block->use_advance_lead) {
-          const float comp = block->e_D_ratio * extruder_advance_K[active_extruder] * settings.axis_steps_per_mm[E_AXIS];
-          block->max_adv_steps = block->nominal_speed * comp;
-          block->final_adv_steps = next_entry_speed * comp;
-        }
-      #endif
     }
 
     // Reset block to ensure its trapezoid is computed - The stepper is free to use
     // the block from now on.
     block->flag.recalculate = false;
   }
 }
 
 void Planner::recalculate(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t safe_exit_speed_sqr)) {
   // Initialize block index to the last block in the planner buffer.
@@ -2495,27 +2490,29 @@ bool Planner::_populate_block(
   // Correct the speed
   if (speed_factor < 1.0f) {
     current_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
     block->nominal_speed *= speed_factor;
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
+  #if ENABLED(LIN_ADVANCE)
+    bool use_advance_lead = false;
+  #endif
   if (NUM_AXIS_GANG(
          !block->steps.a, && !block->steps.b, && !block->steps.c,
       && !block->steps.i, && !block->steps.j, && !block->steps.k,
       && !block->steps.u, && !block->steps.v, && !block->steps.w)
   ) {                                                             // Is this a retract / recover move?
     accel = CEIL(settings.retract_acceleration * steps_per_mm);   // Convert to: acceleration steps/sec^2
-    TERN_(LIN_ADVANCE, block->use_advance_lead = false);          // No linear advance for simple retract/recover
   }
   else {
     #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
         const uint32_t max_possible = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count / block->steps[AXIS]; \
         NOMORE(accel, max_possible); \
       } \
     }while(0)
 
     #define LIMIT_ACCEL_FLOAT(AXIS,INDX) do{ \
@@ -2528,47 +2525,43 @@ bool Planner::_populate_block(
     // Start with print or travel acceleration
     accel = CEIL((esteps ? settings.acceleration : settings.travel_acceleration) * steps_per_mm);
 
     #if ENABLED(LIN_ADVANCE)
       // Linear advance is currently not ready for HAS_I_AXIS
       #define MAX_E_JERK(N) TERN(HAS_LINEAR_E_JERK, max_e_jerk[E_INDEX_N(N)], max_jerk.e)
 
       /**
        * Use LIN_ADVANCE for blocks if all these are true:
        *
-       * esteps             : This is a print move, because we checked for A, B, C steps before.
+       * esteps                       : This is a print move, because we checked for A, B, C steps before.
        *
-       * extruder_advance_K[active_extruder] : There is an advance factor set for this extruder.
+       * extruder_advance_K[extruder] : There is an advance factor set for this extruder.
        *
-       * de > 0             : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
+       * de > 0                       : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
        */
-      block->use_advance_lead =  esteps
-                              && extruder_advance_K[active_extruder]
-                              && de > 0;
-
-      if (block->use_advance_lead) {
-        block->e_D_ratio = (target_float.e - position_float.e) /
-          #if IS_KINEMATIC
-            block->millimeters
-          #else
+      use_advance_lead = esteps && extruder_advance_K[extruder] && de > 0;
+
+      if (use_advance_lead) {
+        float e_D_ratio = (target_float.e - position_float.e) /
+          TERN(IS_KINEMATIC, block->millimeters,
             SQRT(sq(target_float.x - position_float.x)
                + sq(target_float.y - position_float.y)
                + sq(target_float.z - position_float.z))
-          #endif
-        ;
+          );
 
         // Check for unusual high e_D ratio to detect if a retract move was combined with the last print move due to min. steps per segment. Never execute this with advance!
         // This assumes no one will use a retract length of 0mm < retr_length < ~0.2mm and no one will print 100mm wide lines using 3mm filament or 35mm wide lines using 1.75mm filament.
-        if (block->e_D_ratio > 3.0f)
-          block->use_advance_lead = false;
+        if (e_D_ratio > 3.0f)
+          use_advance_lead = false;
         else {
-          const uint32_t max_accel_steps_per_s2 = MAX_E_JERK(extruder) / (extruder_advance_K[active_extruder] * block->e_D_ratio) * steps_per_mm;
+          // Scale E acceleration so that it will be possible to jump to the advance speed.
+          const uint32_t max_accel_steps_per_s2 = MAX_E_JERK(extruder) / (extruder_advance_K[extruder] * e_D_ratio) * steps_per_mm;
           if (TERN0(LA_DEBUG, accel > max_accel_steps_per_s2))
             SERIAL_ECHOLNPGM("Acceleration limited.");
           NOMORE(accel, max_accel_steps_per_s2);
         }
       }
     #endif
 
     // Limit acceleration per axis
     if (block->step_event_count <= acceleration_long_cutoff) {
       LOGICAL_AXIS_CODE(
@@ -2586,27 +2579,35 @@ bool Planner::_populate_block(
         LIMIT_ACCEL_FLOAT(U_AXIS, 0), LIMIT_ACCEL_FLOAT(V_AXIS, 0), LIMIT_ACCEL_FLOAT(W_AXIS, 0)
       );
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
     block->acceleration_rate = (uint32_t)(accel * (float(1UL << 24) / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
-    if (block->use_advance_lead) {
-      block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * settings.axis_steps_per_mm[E_AXIS_N(extruder)]);
+    block->la_advance_rate = 0;
+    block->la_scaling = 0;
+
+    if (use_advance_lead) {
+      // the Bresenham algorithm will convert this step rate into extruder steps
+      block->la_advance_rate = extruder_advance_K[extruder] * block->acceleration_steps_per_s2;
+
+      // reduce LA ISR frequency by calling it only often enough to ensure that there will
+      // never be more than four extruder steps per call
+      for (uint32_t dividend = block->steps.e << 1; dividend <= (block->step_event_count >> 2); dividend <<= 1)
+        block->la_scaling++;
+
       #if ENABLED(LA_DEBUG)
-        if (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * 2 < block->nominal_speed * block->e_D_ratio)
-          SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
-        if (block->advance_speed < 200)
-          SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
+        if (block->la_advance_rate >> block->la_scaling > 10000)
+          SERIAL_ECHOLNPGM("eISR running at > 10kHz: ", block->la_advance_rate);
       #endif
     }
   #endif
 
   float vmax_junction_sqr; // Initial limit on the segment entry velocity (mm/s)^2
 
   #if HAS_JUNCTION_DEVIATION
     /**
      * Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
      * Let a circle be tangent to both previous and current path line segments, where the junction

commit d8df9ffd61b112a21a1946a9b120e806886aa54e
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sun Jul 31 03:49:15 2022 +0200

    üêõ Fix kinematic feedrate (#24568)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index b4455ca5ec..4bc81c1051 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2188,37 +2188,37 @@ bool Planner::_populate_block(
         #elif CORE_IS_XZ
           XYZ_GANG(sq(steps_dist_mm.head.x), + sq(steps_dist_mm.y),      + sq(steps_dist_mm.head.z))
         #elif CORE_IS_YZ
           XYZ_GANG(sq(steps_dist_mm.x),      + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.head.z))
         #else
           XYZ_GANG(sq(steps_dist_mm.x),       + sq(steps_dist_mm.y),      + sq(steps_dist_mm.z))
         #endif
       );
 
       #if SECONDARY_LINEAR_AXES >= 1 && NONE(FOAMCUTTER_XYUV, ARTICULATED_ROBOT_ARM)
-        if (NEAR_ZERO(distance_sqr)) {
+        if (UNEAR_ZERO(distance_sqr)) {
           // Move does not involve any primary linear axes (xyz) but might involve secondary linear axes
           distance_sqr = (0.0f
             SECONDARY_AXIS_GANG(
               IF_DISABLED(AXIS4_ROTATES, + sq(steps_dist_mm.i)),
               IF_DISABLED(AXIS5_ROTATES, + sq(steps_dist_mm.j)),
               IF_DISABLED(AXIS6_ROTATES, + sq(steps_dist_mm.k)),
               IF_DISABLED(AXIS7_ROTATES, + sq(steps_dist_mm.u)),
               IF_DISABLED(AXIS8_ROTATES, + sq(steps_dist_mm.v)),
               IF_DISABLED(AXIS9_ROTATES, + sq(steps_dist_mm.w))
             )
           );
         }
       #endif
 
       #if HAS_ROTATIONAL_AXES && NONE(FOAMCUTTER_XYUV, ARTICULATED_ROBOT_ARM)
-        if (NEAR_ZERO(distance_sqr)) {
+        if (UNEAR_ZERO(distance_sqr)) {
           // Move involves only rotational axes. Calculate angular distance in accordance with LinuxCNC
           TERN_(INCH_MODE_SUPPORT, cartesian_move = false);
           distance_sqr = ROTATIONAL_AXIS_GANG(sq(steps_dist_mm.i), + sq(steps_dist_mm.j), + sq(steps_dist_mm.k), + sq(steps_dist_mm.u), + sq(steps_dist_mm.v), + sq(steps_dist_mm.w));
         }
       #endif
 
       block->millimeters = SQRT(distance_sqr);
     }
 
     /**
@@ -3147,21 +3147,23 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s
         cart.i - position_cart.i, cart.j - position_cart.j, cart.k - position_cart.k,
         cart.u - position_cart.u, cart.v - position_cart.v, cart.w - position_cart.w
       );
     #endif
 
     // Cartesian XYZ to kinematic ABC, stored in global 'delta'
     inverse_kinematics(machine);
 
     PlannerHints ph = hints;
     if (!hints.millimeters)
-      ph.millimeters = (cart_dist_mm.x || cart_dist_mm.y) ? cart_dist_mm.magnitude() : TERN0(HAS_Z_AXIS, ABS(cart_dist_mm.z));
+      ph.millimeters = (cart_dist_mm.x || cart_dist_mm.y)
+        ? xyz_pos_t(cart_dist_mm).magnitude()
+        : TERN0(HAS_Z_AXIS, ABS(cart_dist_mm.z));
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feedrate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
       const float duration_recip = hints.inv_duration ?: fr_mm_s / ph.millimeters;
       const xyz_pos_t diff = delta - position_float;
       const feedRate_t feedrate = diff.magnitude() * duration_recip;
     #else
       const feedRate_t feedrate = fr_mm_s;
     #endif

commit 3b4a5a1ae86da5e790f1551ea801dfcd61acff50
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Mon Jul 18 06:51:44 2022 +0100

    ü©π Arc/Planner optimization followup (#24509)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index de1351babf..b4455ca5ec 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -799,21 +799,21 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
   int32_t plateau_steps = block->step_event_count;
   uint32_t accelerate_steps = 0,
            decelerate_steps = 0;
 
   if (accel != 0) {
     // Steps required for acceleration, deceleration to/from nominal rate
     const float nominal_rate_sq = sq(float(block->nominal_rate));
     float accelerate_steps_float = (nominal_rate_sq - sq(float(initial_rate))) * (0.5f / accel);
     accelerate_steps = CEIL(accelerate_steps_float);
     const float decelerate_steps_float = (nominal_rate_sq - sq(float(final_rate))) * (0.5f / accel);
-    decelerate_steps = decelerate_steps_float;
+    decelerate_steps = FLOOR(decelerate_steps_float);
 
     // Steps between acceleration and deceleration, if any
     plateau_steps -= accelerate_steps + decelerate_steps;
 
     // Does accelerate_steps + decelerate_steps exceed step_event_count?
     // Then we can't possibly reach the nominal rate, there will be no cruising.
     // Calculate accel / braking time in order to reach the final_rate exactly
     // at the end of this block.
     if (plateau_steps < 0) {
       accelerate_steps_float = CEIL((block->step_event_count + accelerate_steps_float - decelerate_steps_float) * 0.5f);

commit fc0615fbd12a2609fb937afa94fa092cc9cfebdd
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sat Jul 16 00:15:51 2022 +0100

    ‚ö°Ô∏è Optimize Planner calculations (#24484)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7b00552dff..de1351babf 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -21,52 +21,55 @@
  */
 
 /**
  * planner.cpp
  *
  * Buffer movement commands and manage the acceleration profile plan
  *
  * Derived from Grbl
  * Copyright (c) 2009-2011 Simen Svale Skogsrud
  *
- * The ring buffer implementation gleaned from the wiring_serial library by David A. Mellis.
+ * Ring buffer gleaned from wiring_serial library by David A. Mellis.
  *
+ * Fast inverse function needed for B√©zier interpolation for AVR
+ * was designed, written and tested by Eduardo Jos√© Tagle, April 2018.
  *
- * Reasoning behind the mathematics in this module (in the key of 'Mathematica'):
+ * Planner mathematics (Mathematica-style):
  *
- * s == speed, a == acceleration, t == time, d == distance
+ * Where: s == speed, a == acceleration, t == time, d == distance
  *
  * Basic definitions:
  *   Speed[s_, a_, t_] := s + (a*t)
  *   Travel[s_, a_, t_] := Integrate[Speed[s, a, t], t]
  *
  * Distance to reach a specific speed with a constant acceleration:
  *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, d, t]
- *   d -> (m^2 - s^2)/(2 a) --> estimate_acceleration_distance()
+ *   d -> (m^2 - s^2) / (2 a)
  *
  * Speed after a given distance of travel with constant acceleration:
  *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, m, t]
  *   m -> Sqrt[2 a d + s^2]
  *
  * DestinationSpeed[s_, a_, d_] := Sqrt[2 a d + s^2]
  *
- * When to start braking (di) to reach a specified destination speed (s2) after accelerating
- * from initial speed s1 without ever stopping at a plateau:
+ * When to start braking (di) to reach a specified destination speed (s2) after
+ * acceleration from initial speed s1 without ever reaching a plateau:
  *   Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]
- *   di -> (2 a d - s1^2 + s2^2)/(4 a) --> intersection_distance()
+ *   di -> (2 a d - s1^2 + s2^2)/(4 a)
  *
- * IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)
+ * We note, as an optimization, that if we have already calculated an
+ * acceleration distance d1 from s1 to m and a deceration distance d2
+ * from m to s2 then
  *
- * --
- *
- * The fast inverse function needed for B√©zier interpolation for AVR
- * was designed, written and tested by Eduardo Jos√© Tagle on April/2018
+ *   d1 -> (m^2 - s1^2) / (2 a)
+ *   d2 -> (m^2 - s2^2) / (2 a)
+ *   di -> (d + d1 - d2) / 2
  */
 
 #include "planner.h"
 #include "stepper.h"
 #include "motion.h"
 #include "temperature.h"
 #include "../lcd/marlinui.h"
 #include "../gcode/parser.h"
 
 #include "../MarlinCore.h"
@@ -204,30 +207,30 @@ skew_factor_t Planner::skew_factor; // Initialized by settings.load()
   bool Planner::autotemp_enabled = false;
 #endif
 
 // private:
 
 xyze_long_t Planner::position{0};
 
 uint32_t Planner::acceleration_long_cutoff;
 
 xyze_float_t Planner::previous_speed;
-float Planner::previous_nominal_speed_sqr;
+float Planner::previous_nominal_speed;
 
 #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
   last_move_t Planner::g_uc_extruder_last_move[E_STEPPERS] = { 0 };
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
   int8_t Planner::xy_freq_limit_hz = XY_FREQUENCY_LIMIT;
   float Planner::xy_freq_min_speed_factor = (XY_FREQUENCY_MIN_PERCENT) * 0.01f;
-  int32_t Planner::xy_freq_min_interval_us = LROUND(1000000.0 / (XY_FREQUENCY_LIMIT));
+  int32_t Planner::xy_freq_min_interval_us = LROUND(1000000.0f / (XY_FREQUENCY_LIMIT));
 #endif
 
 #if ENABLED(LIN_ADVANCE)
   float Planner::extruder_advance_K[EXTRUDERS]; // Initialized by settings.load()
 #endif
 
 #if HAS_POSITION_FLOAT
   xyze_pos_t Planner::position_float; // Needed for accurate maths. Steps cannot be used!
 #endif
 
@@ -243,21 +246,21 @@ float Planner::previous_nominal_speed_sqr;
  * Class and Instance Methods
  */
 
 Planner::Planner() { init(); }
 
 void Planner::init() {
   position.reset();
   TERN_(HAS_POSITION_FLOAT, position_float.reset());
   TERN_(IS_KINEMATIC, position_cart.reset());
   previous_speed.reset();
-  previous_nominal_speed_sqr = 0;
+  previous_nominal_speed = 0;
   TERN_(ABL_PLANAR, bed_level_matrix.set_to_identity());
   clear_block_buffer();
   delay_before_delivering = 0;
   #if ENABLED(DIRECT_STEPPING)
     last_page_step_rate = 0;
     last_page_dir.reset();
   #endif
 }
 
 #if ENABLED(S_CURVE_ACCELERATION)
@@ -779,55 +782,62 @@ block_t* Planner::get_current_block() {
 void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t entry_factor, const_float_t exit_factor) {
 
   uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
            final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
 
   // Limit minimal step rate (Otherwise the timer will overflow.)
   NOLESS(initial_rate, uint32_t(MINIMAL_STEP_RATE));
   NOLESS(final_rate, uint32_t(MINIMAL_STEP_RATE));
 
   #if ENABLED(S_CURVE_ACCELERATION)
-    uint32_t cruise_rate = initial_rate;
+    // If we have some plateau time, the cruise rate will be the nominal rate
+    uint32_t cruise_rate = block->nominal_rate;
   #endif
 
   const int32_t accel = block->acceleration_steps_per_s2;
 
-          // Steps required for acceleration, deceleration to/from nominal rate
-  uint32_t accelerate_steps = CEIL(estimate_acceleration_distance(initial_rate, block->nominal_rate, accel)),
-           decelerate_steps = FLOOR(estimate_acceleration_distance(block->nominal_rate, final_rate, -accel));
-          // Steps between acceleration and deceleration, if any
-  int32_t plateau_steps = block->step_event_count - accelerate_steps - decelerate_steps;
-
-  // Does accelerate_steps + decelerate_steps exceed step_event_count?
-  // Then we can't possibly reach the nominal rate, there will be no cruising.
-  // Use intersection_distance() to calculate accel / braking time in order to
-  // reach the final_rate exactly at the end of this block.
-  if (plateau_steps < 0) {
-    const float accelerate_steps_float = CEIL(intersection_distance(initial_rate, final_rate, accel, block->step_event_count));
-    accelerate_steps = _MIN(uint32_t(_MAX(accelerate_steps_float, 0)), block->step_event_count);
-    decelerate_steps = block->step_event_count - accelerate_steps;
-    plateau_steps = 0;
-
-    #if ENABLED(S_CURVE_ACCELERATION)
-      // We won't reach the cruising rate. Let's calculate the speed we will reach
-      cruise_rate = final_speed(initial_rate, accel, accelerate_steps);
-    #endif
+  // Steps for acceleration, plateau and deceleration
+  int32_t plateau_steps = block->step_event_count;
+  uint32_t accelerate_steps = 0,
+           decelerate_steps = 0;
+
+  if (accel != 0) {
+    // Steps required for acceleration, deceleration to/from nominal rate
+    const float nominal_rate_sq = sq(float(block->nominal_rate));
+    float accelerate_steps_float = (nominal_rate_sq - sq(float(initial_rate))) * (0.5f / accel);
+    accelerate_steps = CEIL(accelerate_steps_float);
+    const float decelerate_steps_float = (nominal_rate_sq - sq(float(final_rate))) * (0.5f / accel);
+    decelerate_steps = decelerate_steps_float;
+
+    // Steps between acceleration and deceleration, if any
+    plateau_steps -= accelerate_steps + decelerate_steps;
+
+    // Does accelerate_steps + decelerate_steps exceed step_event_count?
+    // Then we can't possibly reach the nominal rate, there will be no cruising.
+    // Calculate accel / braking time in order to reach the final_rate exactly
+    // at the end of this block.
+    if (plateau_steps < 0) {
+      accelerate_steps_float = CEIL((block->step_event_count + accelerate_steps_float - decelerate_steps_float) * 0.5f);
+      accelerate_steps = _MIN(uint32_t(_MAX(accelerate_steps_float, 0)), block->step_event_count);
+      decelerate_steps = block->step_event_count - accelerate_steps;
+
+      #if ENABLED(S_CURVE_ACCELERATION)
+        // We won't reach the cruising rate. Let's calculate the speed we will reach
+        cruise_rate = final_speed(initial_rate, accel, accelerate_steps);
+      #endif
+    }
   }
-  #if ENABLED(S_CURVE_ACCELERATION)
-    else // We have some plateau time, so the cruise rate will be the nominal rate
-      cruise_rate = block->nominal_rate;
-  #endif
 
   #if ENABLED(S_CURVE_ACCELERATION)
     // Jerk controlled speed requires to express speed versus time, NOT steps
-    uint32_t acceleration_time = ((float)(cruise_rate - initial_rate) / accel) * (STEPPER_TIMER_RATE),
-             deceleration_time = ((float)(cruise_rate - final_rate) / accel) * (STEPPER_TIMER_RATE),
+    uint32_t acceleration_time = (float(cruise_rate - initial_rate) / accel) * (STEPPER_TIMER_RATE),
+             deceleration_time = (float(cruise_rate - final_rate) / accel) * (STEPPER_TIMER_RATE),
     // And to offload calculations from the ISR, we also calculate the inverse of those times here
              acceleration_time_inverse = get_period_inverse(acceleration_time),
              deceleration_time_inverse = get_period_inverse(deceleration_time);
   #endif
 
   // Store new block parameters
   block->accelerate_until = accelerate_steps;
   block->decelerate_after = block->step_event_count - decelerate_steps;
   block->initial_rate = initial_rate;
   #if ENABLED(S_CURVE_ACCELERATION)
@@ -1168,21 +1178,21 @@ void Planner::recalculate_trapezoids(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t
 
     // It the block is a move, we're done with this loop
     if (prev->is_move()) break;
 
     // Examine the previous block. This and all following are SYNC blocks
     head_block_index = prev_index;
   }
 
   // Go from the tail (currently executed block) to the first block, without including it)
   block_t *block = nullptr, *next = nullptr;
-  float current_entry_speed = 0.0, next_entry_speed = 0.0;
+  float current_entry_speed = 0.0f, next_entry_speed = 0.0f;
   while (block_index != head_block_index) {
 
     next = &block_buffer[block_index];
 
     // Only process movement blocks
     if (next->is_move()) {
       next_entry_speed = SQRT(next->entry_speed_sqr);
 
       if (block) {
 
@@ -1192,27 +1202,26 @@ void Planner::recalculate_trapezoids(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t
         // Recalculate if current block entry or exit junction speed has changed.
         if (block->flag.recalculate) {
 
           // But there is an inherent race condition here, as the block maybe
           // became BUSY, just before it was marked as RECALCULATE, so check
           // if that is the case!
           if (!stepper.is_block_busy(block)) {
             // Block is not BUSY, we won the race against the Stepper ISR:
 
             // NOTE: Entry and exit factors always > 0 by all previous logic operations.
-            const float current_nominal_speed = SQRT(block->nominal_speed_sqr),
-                        nomr = 1.0f / current_nominal_speed;
+            const float nomr = 1.0f / block->nominal_speed;
             calculate_trapezoid_for_block(block, current_entry_speed * nomr, next_entry_speed * nomr);
             #if ENABLED(LIN_ADVANCE)
               if (block->use_advance_lead) {
                 const float comp = block->e_D_ratio * extruder_advance_K[active_extruder] * settings.axis_steps_per_mm[E_AXIS];
-                block->max_adv_steps = current_nominal_speed * comp;
+                block->max_adv_steps = block->nominal_speed * comp;
                 block->final_adv_steps = next_entry_speed * comp;
               }
             #endif
           }
 
           // Reset current only to ensure next trapezoid is computed - The
           // stepper is free to use the block from now on.
           block->flag.recalculate = false;
         }
       }
@@ -1233,27 +1242,26 @@ void Planner::recalculate_trapezoids(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t
     // As the last block is always recalculated here, there is a chance the block isn't
     // marked as RECALCULATE yet. That's the reason for the following line.
     block->flag.recalculate = true;
 
     // But there is an inherent race condition here, as the block maybe
     // became BUSY, just before it was marked as RECALCULATE, so check
     // if that is the case!
     if (!stepper.is_block_busy(block)) {
       // Block is not BUSY, we won the race against the Stepper ISR:
 
-      const float current_nominal_speed = SQRT(block->nominal_speed_sqr),
-                  nomr = 1.0f / current_nominal_speed;
+      const float nomr = 1.0f / block->nominal_speed;
       calculate_trapezoid_for_block(block, current_entry_speed * nomr, next_entry_speed * nomr);
       #if ENABLED(LIN_ADVANCE)
         if (block->use_advance_lead) {
           const float comp = block->e_D_ratio * extruder_advance_K[active_extruder] * settings.axis_steps_per_mm[E_AXIS];
-          block->max_adv_steps = current_nominal_speed * comp;
+          block->max_adv_steps = block->nominal_speed * comp;
           block->final_adv_steps = next_entry_speed * comp;
         }
       #endif
     }
 
     // Reset block to ensure its trapezoid is computed - The stepper is free to use
     // the block from now on.
     block->flag.recalculate = false;
   }
 }
@@ -1283,28 +1291,24 @@ void Planner::recalculate(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t safe_exit_s
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       #define _FAN_SET(F) thermalManager.soft_pwm_amount_fan[F] = CALC_FAN_SPEED(F);
     #else
       #define _FAN_SET(F) hal.set_pwm_duty(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(F));
     #endif
     #define FAN_SET(F) do{ kickstart_fan(fan_speed, ms, F); _FAN_SET(F); }while(0)
 
     const millis_t ms = millis();
-    TERN_(HAS_FAN0, FAN_SET(0));
-    TERN_(HAS_FAN1, FAN_SET(1));
-    TERN_(HAS_FAN2, FAN_SET(2));
-    TERN_(HAS_FAN3, FAN_SET(3));
-    TERN_(HAS_FAN4, FAN_SET(4));
-    TERN_(HAS_FAN5, FAN_SET(5));
-    TERN_(HAS_FAN6, FAN_SET(6));
-    TERN_(HAS_FAN7, FAN_SET(7));
+    TERN_(HAS_FAN0, FAN_SET(0)); TERN_(HAS_FAN1, FAN_SET(1));
+    TERN_(HAS_FAN2, FAN_SET(2)); TERN_(HAS_FAN3, FAN_SET(3));
+    TERN_(HAS_FAN4, FAN_SET(4)); TERN_(HAS_FAN5, FAN_SET(5));
+    TERN_(HAS_FAN6, FAN_SET(6)); TERN_(HAS_FAN7, FAN_SET(7));
   }
 
   #if FAN_KICKSTART_TIME
 
     void Planner::kickstart_fan(uint8_t (&fan_speed)[FAN_COUNT], const millis_t &ms, const uint8_t f) {
       static millis_t fan_kick_end[FAN_COUNT] = { 0 };
       if (fan_speed[f]) {
         if (fan_kick_end[f] == 0) {
           fan_kick_end[f] = ms + FAN_KICKSTART_TIME;
           fan_speed[f] = 255;
@@ -1478,21 +1482,21 @@ void Planner::check_axes_activity() {
   void Planner::autotemp_task() {
     static float oldt = 0.0f;
 
     if (!autotemp_enabled) return;
     if (thermalManager.degTargetHotend(active_extruder) < autotemp_min - 2) return; // Below the min?
 
     float high = 0.0f;
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       const block_t * const block = &block_buffer[b];
       if (NUM_AXIS_GANG(block->steps.x, || block->steps.y, || block->steps.z, || block->steps.i, || block->steps.j, || block->steps.k, || block->steps.u, || block->steps.v, || block->steps.w)) {
-        const float se = (float)block->steps.e / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;
+        const float se = float(block->steps.e) / block->step_event_count * block->nominal_speed; // mm/sec
         NOLESS(high, se);
       }
     }
 
     float t = autotemp_min + high * autotemp_factor;
     LIMIT(t, autotemp_min, autotemp_max);
     if (t < oldt) t = t * (1.0f - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
     oldt = t;
     thermalManager.setTargetHotend(t, active_extruder);
   }
@@ -1929,21 +1933,21 @@ bool Planner::_populate_block(
           SERIAL_ECHO_MSG(STR_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
         const float e_steps = ABS(de * e_factor[extruder]);
         const float max_e_steps = settings.axis_steps_per_mm[E_AXIS_N(extruder)] * (EXTRUDE_MAXLENGTH);
         if (e_steps > max_e_steps) {
           #if ENABLED(MIXING_EXTRUDER)
             bool ignore_e = false;
             float collector[MIXING_STEPPERS];
-            mixer.refresh_collector(1.0, mixer.get_current_vtool(), collector);
+            mixer.refresh_collector(1.0f, mixer.get_current_vtool(), collector);
             MIXER_STEPPER_LOOP(e)
               if (e_steps * collector[e] > max_e_steps) { ignore_e = true; break; }
           #else
             constexpr bool ignore_e = true;
           #endif
           if (ignore_e) {
             position.e = target.e; // Behave as if the move really took place, but ignore E part
             TERN_(HAS_POSITION_FLOAT, position_float.e = target_float.e);
             de = 0; // no difference
             SERIAL_ECHO_MSG(STR_ERR_LONG_EXTRUDE_STOP);
@@ -2186,21 +2190,21 @@ bool Planner::_populate_block(
         #elif CORE_IS_YZ
           XYZ_GANG(sq(steps_dist_mm.x),      + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.head.z))
         #else
           XYZ_GANG(sq(steps_dist_mm.x),       + sq(steps_dist_mm.y),      + sq(steps_dist_mm.z))
         #endif
       );
 
       #if SECONDARY_LINEAR_AXES >= 1 && NONE(FOAMCUTTER_XYUV, ARTICULATED_ROBOT_ARM)
         if (NEAR_ZERO(distance_sqr)) {
           // Move does not involve any primary linear axes (xyz) but might involve secondary linear axes
-          distance_sqr = (0.0
+          distance_sqr = (0.0f
             SECONDARY_AXIS_GANG(
               IF_DISABLED(AXIS4_ROTATES, + sq(steps_dist_mm.i)),
               IF_DISABLED(AXIS5_ROTATES, + sq(steps_dist_mm.j)),
               IF_DISABLED(AXIS6_ROTATES, + sq(steps_dist_mm.k)),
               IF_DISABLED(AXIS7_ROTATES, + sq(steps_dist_mm.u)),
               IF_DISABLED(AXIS8_ROTATES, + sq(steps_dist_mm.v)),
               IF_DISABLED(AXIS9_ROTATES, + sq(steps_dist_mm.w))
             )
           );
         }
@@ -2389,21 +2393,21 @@ bool Planner::_populate_block(
   #if HAS_WIRED_LCD
     // Protect the access to the position.
     const bool was_enabled = stepper.suspend();
 
     block_buffer_runtime_us += segment_time_us;
     block->segment_time_us = segment_time_us;
 
     if (was_enabled) stepper.wake_up();
   #endif
 
-  block->nominal_speed_sqr = sq(block->millimeters * inverse_secs);   // (mm/sec)^2 Always > 0
+  block->nominal_speed = block->millimeters * inverse_secs;           // (mm/sec) Always > 0
   block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM)   // Only for extruder with filament sensor
       filwidth.advance_e(steps_dist_mm.e);
   #endif
 
   // Calculate and limit speed in mm/sec (linear) or degrees/sec (rotational)
 
   xyze_float_t current_speed;
@@ -2485,21 +2489,21 @@ bool Planner::_populate_block(
         }
       }
     }
 
   #endif // XY_FREQUENCY_LIMIT
 
   // Correct the speed
   if (speed_factor < 1.0f) {
     current_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
-    block->nominal_speed_sqr = block->nominal_speed_sqr * sq(speed_factor);
+    block->nominal_speed *= speed_factor;
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
   if (NUM_AXIS_GANG(
          !block->steps.a, && !block->steps.b, && !block->steps.c,
       && !block->steps.i, && !block->steps.j, && !block->steps.k,
       && !block->steps.u, && !block->steps.v, && !block->steps.w)
   ) {                                                             // Is this a retract / recover move?
@@ -2585,21 +2589,21 @@ bool Planner::_populate_block(
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
     block->acceleration_rate = (uint32_t)(accel * (float(1UL << 24) / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
       block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * settings.axis_steps_per_mm[E_AXIS_N(extruder)]);
       #if ENABLED(LA_DEBUG)
-        if (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * 2 < SQRT(block->nominal_speed_sqr) * block->e_D_ratio)
+        if (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * 2 < block->nominal_speed * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif
     }
   #endif
 
   float vmax_junction_sqr; // Initial limit on the segment entry velocity (mm/s)^2
 
   #if HAS_JUNCTION_DEVIATION
@@ -2656,21 +2660,21 @@ bool Planner::_populate_block(
      * So taking Z and E into account, we cannot scale to a unit vector with "inverse_millimeters".
      * => normalize the complete junction vector.
      * Elsewise, when needed JD will factor-in the E component
      */
     if (ANY(IS_CORE, MARKFORGED_XY, MARKFORGED_YX) || esteps > 0)
       normalize_junction_vector(unit_vec);  // Normalize with XYZE components
     else
       unit_vec *= inverse_millimeters;      // Use pre-calculated (1 / SQRT(x^2 + y^2 + z^2))
 
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
-    if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
+    if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
       float junction_cos_theta = LOGICAL_AXIS_GANG(
                                  + (-prev_unit_vec.e * unit_vec.e),
                                  + (-prev_unit_vec.x * unit_vec.x),
                                  + (-prev_unit_vec.y * unit_vec.y),
                                  + (-prev_unit_vec.z * unit_vec.z),
                                  + (-prev_unit_vec.i * unit_vec.i),
                                  + (-prev_unit_vec.j * unit_vec.j),
                                  + (-prev_unit_vec.k * unit_vec.k),
@@ -2785,89 +2789,77 @@ bool Planner::_populate_block(
 
               const float limit_sqr = (block->millimeters * junction_acceleration) / junction_theta;
               NOMORE(vmax_junction_sqr, limit_sqr);
             }
 
           #endif // JD_HANDLE_SMALL_SEGMENTS
         }
       }
 
       // Get the lowest speed
-      vmax_junction_sqr = _MIN(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
+      vmax_junction_sqr = _MIN(vmax_junction_sqr, sq(block->nominal_speed), sq(previous_nominal_speed));
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
       vmax_junction_sqr = 0;
 
     prev_unit_vec = unit_vec;
 
   #endif
 
-  #ifdef USE_CACHED_SQRT
-    #define CACHED_SQRT(N, V) \
-      static float saved_V, N; \
-      if (V != saved_V) { N = SQRT(V); saved_V = V; }
-  #else
-    #define CACHED_SQRT(N, V) const float N = SQRT(V)
-  #endif
-
   #if HAS_CLASSIC_JERK
 
     /**
      * Adapted from Pr≈Ø≈°a MKS firmware
      * https://github.com/prusa3d/Prusa-Firmware
      */
-    CACHED_SQRT(nominal_speed, block->nominal_speed_sqr);
-
     // Exit speed limited by a jerk to full halt of a previous last segment
     static float previous_safe_speed;
 
     // Start with a safe speed (from which the machine may halt to stop immediately).
-    float safe_speed = nominal_speed;
+    float safe_speed = block->nominal_speed;
 
     #ifndef TRAVEL_EXTRA_XYJERK
       #define TRAVEL_EXTRA_XYJERK 0
     #endif
     const float extra_xyjerk = TERN0(HAS_EXTRUDERS, de <= 0) ? TRAVEL_EXTRA_XYJERK : 0;
 
     uint8_t limited = 0;
     TERN(HAS_LINEAR_E_JERK, LOOP_NUM_AXES, LOOP_LOGICAL_AXES)(i) {
       const float jerk = ABS(current_speed[i]),   // cs : Starting from zero, change in speed for this axis
                   maxj = (max_jerk[i] + (i == X_AXIS || i == Y_AXIS ? extra_xyjerk : 0.0f)); // mj : The max jerk setting for this axis
       if (jerk > maxj) {                          // cs > mj : New current speed too fast?
         if (limited) {                            // limited already?
-          const float mjerk = nominal_speed * maxj; // ns*mj
+          const float mjerk = block->nominal_speed * maxj; // ns*mj
           if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk; // ns*mj/cs
         }
         else {
           safe_speed *= maxj / jerk;              // Initial limit: ns*mj/cs
           ++limited;                              // Initially limited
         }
       }
     }
 
     float vmax_junction;
-    if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
+    if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
       // Estimate a maximum velocity allowed at a joint of two successive segments.
       // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
       // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
 
       // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
       float v_factor = 1;
       limited = 0;
 
       // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
       // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
-      CACHED_SQRT(previous_nominal_speed, previous_nominal_speed_sqr);
-
       float smaller_speed_factor = 1.0f;
-      if (nominal_speed < previous_nominal_speed) {
-        vmax_junction = nominal_speed;
+      if (block->nominal_speed < previous_nominal_speed) {
+        vmax_junction = block->nominal_speed;
         smaller_speed_factor = vmax_junction / previous_nominal_speed;
       }
       else
         vmax_junction = previous_nominal_speed;
 
       // Now limit the jerk in all axes.
       TERN(HAS_LINEAR_E_JERK, LOOP_NUM_AXES, LOOP_LOGICAL_AXES)(axis) {
         // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
         float v_exit = previous_speed[axis] * smaller_speed_factor,
               v_entry = current_speed[axis];
@@ -2920,25 +2912,25 @@ bool Planner::_populate_block(
   block->entry_speed_sqr = sq(float(MINIMUM_PLANNER_SPEED));
 
   // Initialize planner efficiency flags
   // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
   // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
   // the current block and next block junction speeds are guaranteed to always be at their maximum
   // junction speeds in deceleration and acceleration, respectively. This is due to how the current
   // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
-  block->flag.set_nominal(block->nominal_speed_sqr <= v_allowable_sqr);
+  block->flag.set_nominal(sq(block->nominal_speed) <= v_allowable_sqr);
 
   // Update previous path unit_vector and nominal speed
   previous_speed = current_speed;
-  previous_nominal_speed_sqr = block->nominal_speed_sqr;
+  previous_nominal_speed = block->nominal_speed;
 
   position = target;  // Update the position
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     block->sdpos = recovery.command_sdpos();
     block->start_position = position_float.asLogical();
   #endif
 
   TERN_(HAS_POSITION_FLOAT, position_float = target_float);
   TERN_(GRADIENT_MIX, mixer.gradient_control(target_float.z));
@@ -3261,21 +3253,21 @@ void Planner::set_machine_position_mm(const abce_pos_t &abce) {
       LROUND(abce.i * settings.axis_steps_per_mm[I_AXIS]),
       LROUND(abce.j * settings.axis_steps_per_mm[J_AXIS]),
       LROUND(abce.k * settings.axis_steps_per_mm[K_AXIS]),
       LROUND(abce.u * settings.axis_steps_per_mm[U_AXIS]),
       LROUND(abce.v * settings.axis_steps_per_mm[V_AXIS]),
       LROUND(abce.w * settings.axis_steps_per_mm[W_AXIS])
     )
   );
 
   if (has_blocks_queued()) {
-    //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.
+    //previous_nominal_speed = 0.0f; // Reset planner junction speeds. Assume start from rest.
     //previous_speed.reset();
     buffer_sync_block(BLOCK_BIT_SYNC_POSITION);
   }
   else {
     #if ENABLED(BACKLASH_COMPENSATION)
       abce_long_t stepper_pos = position;
       LOOP_NUM_AXES(axis) stepper_pos[axis] += backlash.get_applied_steps((AxisEnum)axis);
       stepper.set_position(stepper_pos);
     #else
       stepper.set_position(position);
@@ -3337,21 +3329,21 @@ void Planner::refresh_acceleration_rates() {
 void Planner::refresh_positioning() {
   LOOP_DISTINCT_AXES(i) mm_per_step[i] = 1.0f / settings.axis_steps_per_mm[i];
   set_position_mm(current_position);
   refresh_acceleration_rates();
 }
 
 // Apply limits to a variable and give a warning if the value was out of range
 inline void limit_and_warn(float &val, const AxisEnum axis, PGM_P const setting_name, const xyze_float_t &max_limit) {
   const uint8_t lim_axis = TERN_(HAS_EXTRUDERS, axis > E_AXIS ? E_AXIS :) axis;
   const float before = val;
-  LIMIT(val, 0.1, max_limit[lim_axis]);
+  LIMIT(val, 0.1f, max_limit[lim_axis]);
   if (before != val) {
     SERIAL_CHAR(AXIS_CHAR(lim_axis));
     SERIAL_ECHOPGM(" Max ");
     SERIAL_ECHOPGM_P(setting_name);
     SERIAL_ECHOLNPGM(" limited to ", val);
   }
 }
 
 /**
  * For the specified 'axis' set the Maximum Acceleration to the given value (mm/s^2)

commit 920799e38d192f056b76b25a35886f19543308e6
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Jul 8 20:41:39 2022 +0100

    ‚ö°Ô∏è Optimize G2-G3 Arcs (#24366)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index bc5bfd3dfc..7b00552dff 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -836,34 +836,36 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
     block->acceleration_time_inverse = acceleration_time_inverse;
     block->deceleration_time_inverse = deceleration_time_inverse;
     block->cruise_rate = cruise_rate;
   #endif
   block->final_rate = final_rate;
 
   #if ENABLED(LASER_POWER_TRAP)
     /**
      * Laser Trapezoid Calculations
      *
-     * Approximate the trapezoid with the laser, incrementing the power every `trap_ramp_entry_incr` steps while accelerating,
-     * and decrementing the power every `trap_ramp_exit_decr` while decelerating, to keep power proportional to feedrate.
-     * Laser power trap will reduce the initial power to no less than the laser_power_floor value. Based on the number
-     * of calculated accel/decel steps the power is distributed over the trapezoid entry- and exit-ramp steps.
+     * Approximate the trapezoid with the laser, incrementing the power every `trap_ramp_entry_incr`
+     * steps while accelerating, and decrementing the power every `trap_ramp_exit_decr` while decelerating,
+     * to keep power proportional to feedrate. Laser power trap will reduce the initial power to no less
+     * than the laser_power_floor value. Based on the number of calculated accel/decel steps the power is
+     * distributed over the trapezoid entry- and exit-ramp steps.
      *
-     * trap_ramp_active_pwr - The active power is initially set at a reduced level factor of initial power / accel steps and
-     * will be additively incremented using a trap_ramp_entry_incr value for each accel step processed later in the stepper code.
-     * The trap_ramp_exit_decr value is calculated as power / decel steps and is also adjusted to no less than the power floor.
+     * trap_ramp_active_pwr - The active power is initially set at a reduced level factor of initial
+     * power / accel steps and will be additively incremented using a trap_ramp_entry_incr value for each
+     * accel step processed later in the stepper code. The trap_ramp_exit_decr value is calculated as
+     * power / decel steps and is also adjusted to no less than the power floor.
      *
-     * If the power == 0 the inline mode variables need to be set to zero to prevent stepper processing. The method allows
-     * for simpler non-powered moves like G0 or G28.
+     * If the power == 0 the inline mode variables need to be set to zero to prevent stepper processing.
+     * The method allows for simpler non-powered moves like G0 or G28.
      *
-     * Laser Trap Power works for all Jerk and Curve modes; however Arc-based moves will have issues since the segments are
-     * usually too small.
+     * Laser Trap Power works for all Jerk and Curve modes; however Arc-based moves will have issues since
+     * the segments are usually too small.
      */
     if (cutter.cutter_mode == CUTTER_MODE_CONTINUOUS) {
       if (planner.laser_inline.status.isPowered && planner.laser_inline.status.isEnabled) {
         if (block->laser.power > 0) {
           NOLESS(block->laser.power, laser_power_floor);
           block->laser.trap_ramp_active_pwr = (block->laser.power - laser_power_floor) * (initial_rate / float(block->nominal_rate)) + laser_power_floor;
           block->laser.trap_ramp_entry_incr = (block->laser.power - block->laser.trap_ramp_active_pwr) / accelerate_steps;
           float laser_pwr = block->laser.power * (final_rate / float(block->nominal_rate));
           NOLESS(laser_pwr, laser_power_floor);
           block->laser.trap_ramp_exit_decr = (block->laser.power - laser_pwr) / decelerate_steps;
@@ -930,56 +932,67 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
   Planner buffer index mapping:
   - block_buffer_tail: Points to the beginning of the planner buffer. First to be executed or being executed.
   - block_buffer_head: Points to the buffer block after the last block in the buffer. Used to indicate whether
       the buffer is full or empty. As described for standard ring buffers, this block is always empty.
   - block_buffer_planned: Points to the first buffer block after the last optimally planned block for normal
       streaming operating conditions. Use for planning optimizations by avoiding recomputing parts of the
       planner buffer that don't change with the addition of a new block, as describe above. In addition,
       this block can never be less than block_buffer_tail and will always be pushed forward and maintain
       this requirement when encountered by the Planner::release_current_block() routine during a cycle.
 
-  NOTE: Since the planner only computes on what's in the planner buffer, some motions with lots of short
-  line segments, like G2/3 arcs or complex curves, may seem to move slow. This is because there simply isn't
-  enough combined distance traveled in the entire buffer to accelerate up to the nominal speed and then
-  decelerate to a complete stop at the end of the buffer, as stated by the guidelines. If this happens and
-  becomes an annoyance, there are a few simple solutions: (1) Maximize the machine acceleration. The planner
-  will be able to compute higher velocity profiles within the same combined distance. (2) Maximize line
-  motion(s) distance per block to a desired tolerance. The more combined distance the planner has to use,
-  the faster it can go. (3) Maximize the planner buffer size. This also will increase the combined distance
-  for the planner to compute over. It also increases the number of computations the planner has to perform
-  to compute an optimal plan, so select carefully.
+  NOTE: Since the planner only computes on what's in the planner buffer, some motions with many short
+        segments (e.g., complex curves) may seem to move slowly. This is because there simply isn't
+        enough combined distance traveled in the entire buffer to accelerate up to the nominal speed and
+        then decelerate to a complete stop at the end of the buffer, as stated by the guidelines. If this
+        happens and becomes an annoyance, there are a few simple solutions:
+
+    - Maximize the machine acceleration. The planner will be able to compute higher velocity profiles
+      within the same combined distance.
+
+    - Maximize line motion(s) distance per block to a desired tolerance. The more combined distance the
+      planner has to use, the faster it can go.
+
+    - Maximize the planner buffer size. This also will increase the combined distance for the planner to
+      compute over. It also increases the number of computations the planner has to perform to compute an
+      optimal plan, so select carefully.
+
+    - Use G2/G3 arcs instead of many short segments. Arcs inform the planner of a safe exit speed at the
+      end of the last segment, which alleviates this problem.
 */
 
 // The kernel called by recalculate() when scanning the plan from last to first entry.
-void Planner::reverse_pass_kernel(block_t * const current, const block_t * const next) {
+void Planner::reverse_pass_kernel(block_t * const current, const block_t * const next
+  OPTARG(HINTS_SAFE_EXIT_SPEED, const_float_t safe_exit_speed_sqr)
+) {
   if (current) {
     // If entry speed is already at the maximum entry speed, and there was no change of speed
     // in the next block, there is no need to recheck. Block is cruising and there is no need to
     // compute anything for this block,
     // If not, block entry speed needs to be recalculated to ensure maximum possible planned speed.
     const float max_entry_speed_sqr = current->max_entry_speed_sqr;
 
     // Compute maximum entry speed decelerating over the current block from its exit speed.
     // If not at the maximum entry speed, or the previous block entry speed changed
     if (current->entry_speed_sqr != max_entry_speed_sqr || (next && next->flag.recalculate)) {
 
       // If nominal length true, max junction speed is guaranteed to be reached.
       // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
       // the current block and next block junction speeds are guaranteed to always be at their maximum
       // junction speeds in deceleration and acceleration, respectively. This is due to how the current
       // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
       // the reverse and forward planners, the corresponding block junction speed will always be at the
       // the maximum junction speed and may always be ignored for any speed reduction checks.
 
-      const float new_entry_speed_sqr = current->flag.nominal_length
-        ? max_entry_speed_sqr
-        : _MIN(max_entry_speed_sqr, max_allowable_speed_sqr(-current->acceleration, next ? next->entry_speed_sqr : sq(float(MINIMUM_PLANNER_SPEED)), current->millimeters));
+      const float next_entry_speed_sqr = next ? next->entry_speed_sqr : _MAX(TERN0(HINTS_SAFE_EXIT_SPEED, safe_exit_speed_sqr), sq(float(MINIMUM_PLANNER_SPEED))),
+                  new_entry_speed_sqr = current->flag.nominal_length
+                    ? max_entry_speed_sqr
+                    : _MIN(max_entry_speed_sqr, max_allowable_speed_sqr(-current->acceleration, next_entry_speed_sqr, current->millimeters));
       if (current->entry_speed_sqr != new_entry_speed_sqr) {
 
         // Need to recalculate the block speed - Mark it now, so the stepper
         // ISR does not consume the block before being recalculated
         current->flag.recalculate = true;
 
         // But there is an inherent race condition here, as the block may have
         // become BUSY just before being marked RECALCULATE, so check for that!
         if (stepper.is_block_busy(current)) {
           // Block became busy. Clear the RECALCULATE flag (no point in
@@ -994,21 +1007,21 @@ void Planner::reverse_pass_kernel(block_t * const current, const block_t * const
         }
       }
     }
   }
 }
 
 /**
  * recalculate() needs to go over the current plan twice.
  * Once in reverse and once forward. This implements the reverse pass.
  */
-void Planner::reverse_pass() {
+void Planner::reverse_pass(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t safe_exit_speed_sqr)) {
   // Initialize block index to the last block in the planner buffer.
   uint8_t block_index = prev_block_index(block_buffer_head);
 
   // Read the index of the last buffer planned block.
   // The ISR may change it so get a stable local copy.
   uint8_t planned_block_index = block_buffer_planned;
 
   // If there was a race condition and block_buffer_planned was incremented
   //  or was pointing at the head (queue empty) break loop now and avoid
   //  planning already consumed blocks
@@ -1018,21 +1031,21 @@ void Planner::reverse_pass() {
   // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
   // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
   const block_t *next = nullptr;
   while (block_index != planned_block_index) {
 
     // Perform the reverse pass
     block_t *current = &block_buffer[block_index];
 
     // Only process movement blocks
     if (current->is_move()) {
-      reverse_pass_kernel(current, next);
+      reverse_pass_kernel(current, next OPTARG(HINTS_SAFE_EXIT_SPEED, safe_exit_speed_sqr));
       next = current;
     }
 
     // Advance to the next
     block_index = prev_block_index(block_index);
 
     // The ISR could advance the block_buffer_planned while we were doing the reverse pass.
     // We must try to avoid using an already consumed block as the last one - So follow
     // changes to the pointer and make sure to limit the loop to the currently busy block
     while (planned_block_index != block_buffer_planned) {
@@ -1131,21 +1144,21 @@ void Planner::forward_pass() {
     // Advance to the previous
     block_index = next_block_index(block_index);
   }
 }
 
 /**
  * Recalculate the trapezoid speed profiles for all blocks in the plan
  * according to the entry_factor for each junction. Must be called by
  * recalculate() after updating the blocks.
  */
-void Planner::recalculate_trapezoids() {
+void Planner::recalculate_trapezoids(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t safe_exit_speed_sqr)) {
   // The tail may be changed by the ISR so get a local copy.
   uint8_t block_index = block_buffer_tail,
           head_block_index = block_buffer_head;
   // Since there could be a sync block in the head of the queue, and the
   // next loop must not recalculate the head block (as it needs to be
   // specially handled), scan backwards to the first non-SYNC block.
   while (head_block_index != block_index) {
 
     // Go back (head always point to the first free block)
     const uint8_t prev_index = prev_block_index(head_block_index);
@@ -1204,61 +1217,63 @@ void Planner::recalculate_trapezoids() {
         }
       }
 
       block = next;
       current_entry_speed = next_entry_speed;
     }
 
     block_index = next_block_index(block_index);
   }
 
-  // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
-  if (next) {
+  // Last/newest block in buffer. Always recalculated.
+  if (block) {
+    // Exit speed is set with MINIMUM_PLANNER_SPEED unless some code higher up knows better.
+    next_entry_speed = _MAX(TERN0(HINTS_SAFE_EXIT_SPEED, SQRT(safe_exit_speed_sqr)), float(MINIMUM_PLANNER_SPEED));
 
     // Mark the next(last) block as RECALCULATE, to prevent the Stepper ISR running it.
     // As the last block is always recalculated here, there is a chance the block isn't
     // marked as RECALCULATE yet. That's the reason for the following line.
     block->flag.recalculate = true;
 
     // But there is an inherent race condition here, as the block maybe
     // became BUSY, just before it was marked as RECALCULATE, so check
     // if that is the case!
     if (!stepper.is_block_busy(block)) {
       // Block is not BUSY, we won the race against the Stepper ISR:
 
-      const float next_nominal_speed = SQRT(next->nominal_speed_sqr),
-                  nomr = 1.0f / next_nominal_speed;
-      calculate_trapezoid_for_block(next, next_entry_speed * nomr, float(MINIMUM_PLANNER_SPEED) * nomr);
+      const float current_nominal_speed = SQRT(block->nominal_speed_sqr),
+                  nomr = 1.0f / current_nominal_speed;
+      calculate_trapezoid_for_block(block, current_entry_speed * nomr, next_entry_speed * nomr);
       #if ENABLED(LIN_ADVANCE)
-        if (next->use_advance_lead) {
-          const float comp = next->e_D_ratio * extruder_advance_K[active_extruder] * settings.axis_steps_per_mm[E_AXIS];
-          next->max_adv_steps = next_nominal_speed * comp;
-          next->final_adv_steps = (MINIMUM_PLANNER_SPEED) * comp;
+        if (block->use_advance_lead) {
+          const float comp = block->e_D_ratio * extruder_advance_K[active_extruder] * settings.axis_steps_per_mm[E_AXIS];
+          block->max_adv_steps = current_nominal_speed * comp;
+          block->final_adv_steps = next_entry_speed * comp;
         }
       #endif
     }
 
-    // Reset next only to ensure its trapezoid is computed - The stepper is free to use
+    // Reset block to ensure its trapezoid is computed - The stepper is free to use
     // the block from now on.
-    next->flag.recalculate = false;
+    block->flag.recalculate = false;
   }
 }
 
-void Planner::recalculate() {
+void Planner::recalculate(TERN_(HINTS_SAFE_EXIT_SPEED, const_float_t safe_exit_speed_sqr)) {
   // Initialize block index to the last block in the planner buffer.
   const uint8_t block_index = prev_block_index(block_buffer_head);
   // If there is just one block, no planning can be done. Avoid it!
   if (block_index != block_buffer_planned) {
-    reverse_pass();
+    reverse_pass(TERN_(HINTS_SAFE_EXIT_SPEED, safe_exit_speed_sqr));
     forward_pass();
   }
-  recalculate_trapezoids();
+  recalculate_trapezoids(TERN_(HINTS_SAFE_EXIT_SPEED, safe_exit_speed_sqr));
 }
 
 /**
  * Apply fan speeds
  */
 #if HAS_FAN
 
   void Planner::sync_fan_speeds(uint8_t (&fan_speed)[FAN_COUNT]) {
 
     #if FAN_MIN_PWM != 0 || FAN_MAX_PWM != 255
@@ -1770,52 +1785,51 @@ float Planner::get_axis_position_mm(const AxisEnum axis) {
 
   return axis_steps * mm_per_step[axis];
 }
 
 /**
  * Block until the planner is finished processing
  */
 void Planner::synchronize() { while (busy()) idle(); }
 
 /**
- * Planner::_buffer_steps
- *
- * Add a new linear movement to the planner queue (in terms of steps).
+ * @brief Add a new linear movement to the planner queue (in terms of steps).
  *
- *  target        - target position in steps units
- *  target_float  - target position in direct (mm, degrees) units. optional
- *  fr_mm_s       - (target) speed of the move
- *  extruder      - target extruder
- *  millimeters   - the length of the movement, if known
+ * @param target        Target position in steps units
+ * @param target_float  Target position in direct (mm, degrees) units.
+ * @param cart_dist_mm  The pre-calculated move lengths for all axes, in mm
+ * @param fr_mm_s       (target) speed of the move
+ * @param extruder      target extruder
+ * @param hints         parameters to aid planner calculations
  *
- * Returns true if movement was properly queued, false otherwise (if cleaning)
+ * @return  true if movement was properly queued, false otherwise (if cleaning)
  */
 bool Planner::_buffer_steps(const xyze_long_t &target
   OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
   OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
-  , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters
+  , feedRate_t fr_mm_s, const uint8_t extruder, const PlannerHints &hints
 ) {
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // If we are cleaning, do not accept queuing of movements
   // This must be after get_next_free_block() because it calls idle()
   // where cleaning_buffer_counter can be changed
   if (cleaning_buffer_counter) return false;
 
   // Fill the block with the specified movement
   if (!_populate_block(block, target
         OPTARG(HAS_POSITION_FLOAT, target_float)
         OPTARG(HAS_DIST_MM_ARG, cart_dist_mm)
-        , fr_mm_s, extruder, millimeters
+        , fr_mm_s, extruder, hints
       )
   ) {
     // Movement was not queued, probably because it was too short.
     //  Simply accept that as movement queued and done
     return true;
   }
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
@@ -1823,49 +1837,48 @@ bool Planner::_buffer_steps(const xyze_long_t &target
     // As there are no queued movements, the Stepper ISR will not touch this
     // variable, so there is no risk setting this here (but it MUST be done
     // before the following line!!)
     delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
   }
 
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
   // Recalculate and optimize trapezoidal speed profiles
-  recalculate();
+  recalculate(TERN_(HINTS_SAFE_EXIT_SPEED, hints.safe_exit_speed_sqr));
 
   // Movement successfully queued!
   return true;
 }
 
 /**
  * @brief Populate a block in preparation for insertion
  * @details Populate the fields of a new linear movement block
  *          that will be added to the queue and processed soon
  *          by the Stepper ISR.
  *
  * @param block         A block to populate
  * @param target        Target position in steps units
  * @param target_float  Target position in native mm
  * @param cart_dist_mm  The pre-calculated move lengths for all axes, in mm
  * @param fr_mm_s       (target) speed of the move
  * @param extruder      target extruder
- * @param millimeters   A pre-calculated linear distance for the move, in mm,
- *                      or 0.0 to have the distance calculated here.
+ * @param hints         parameters to aid planner calculations
  *
  * @return  true if movement is acceptable, false otherwise
  */
 bool Planner::_populate_block(
   block_t * const block,
   const abce_long_t &target
   OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
   OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
-  , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters/*=0.0*/
+  , feedRate_t fr_mm_s, const uint8_t extruder, const PlannerHints &hints
 ) {
   int32_t LOGICAL_AXIS_LIST(
     de = target.e - position.e,
     da = target.a - position.a,
     db = target.b - position.b,
     dc = target.c - position.c,
     di = target.i - position.i,
     dj = target.j - position.j,
     dk = target.k - position.k,
     du = target.u - position.u,
@@ -2127,22 +2140,22 @@ bool Planner::_populate_block(
       && block->steps.j < MIN_STEPS_PER_SEGMENT,
       && block->steps.k < MIN_STEPS_PER_SEGMENT,
       && block->steps.u < MIN_STEPS_PER_SEGMENT,
       && block->steps.v < MIN_STEPS_PER_SEGMENT,
       && block->steps.w < MIN_STEPS_PER_SEGMENT
     )
   ) {
     block->millimeters = TERN0(HAS_EXTRUDERS, ABS(steps_dist_mm.e));
   }
   else {
-    if (millimeters)
-      block->millimeters = millimeters;
+    if (hints.millimeters)
+      block->millimeters = hints.millimeters;
     else {
       /**
        * Distance for interpretation of feedrate in accordance with LinuxCNC (the successor of NIST
        * RS274NGC interpreter - version 3) and its default CANON_XYZ feed reference mode.
        * Assume that X, Y, Z are the primary linear axes and U, V, W are secondary linear axes and A, B, C are
        * rotational axes. Then dX, dY, dZ are the displacements of the primary linear axes and dU, dV, dW are the displacements of linear axes and
        * dA, dB, dC are the displacements of rotational axes.
        * The time it takes to execute move command with feedrate F is t = D/F, where D is the total distance, calculated as follows:
        *   D^2 = dX^2 + dY^2 + dZ^2
        *   if D^2 == 0 (none of XYZ move but any secondary linear axes move, whether other axes are moved or not):
@@ -2236,29 +2249,23 @@ bool Planner::_populate_block(
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
   E_TERN_(block->extruder = extruder);
 
   #if ENABLED(AUTO_POWER_CONTROL)
     if (NUM_AXIS_GANG(
-         block->steps.x,
-      || block->steps.y,
-      || block->steps.z,
-      || block->steps.i,
-      || block->steps.j,
-      || block->steps.k,
-      || block->steps.u,
-      || block->steps.v,
-      || block->steps.w
+         block->steps.x, || block->steps.y, || block->steps.z,
+      || block->steps.i, || block->steps.j, || block->steps.k,
+      || block->steps.u, || block->steps.v, || block->steps.w
     )) powerManager.power_on();
   #endif
 
   // Enable active axes
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
     if (block->steps.a || block->steps.b) {
       stepper.enable_axis(X_AXIS);
       stepper.enable_axis(Y_AXIS);
     }
     #if DISABLED(Z_LATE_ENABLE)
@@ -2555,43 +2562,31 @@ bool Planner::_populate_block(
             SERIAL_ECHOLNPGM("Acceleration limited.");
           NOMORE(accel, max_accel_steps_per_s2);
         }
       }
     #endif
 
     // Limit acceleration per axis
     if (block->step_event_count <= acceleration_long_cutoff) {
       LOGICAL_AXIS_CODE(
         LIMIT_ACCEL_LONG(E_AXIS, E_INDEX_N(extruder)),
-        LIMIT_ACCEL_LONG(A_AXIS, 0),
-        LIMIT_ACCEL_LONG(B_AXIS, 0),
-        LIMIT_ACCEL_LONG(C_AXIS, 0),
-        LIMIT_ACCEL_LONG(I_AXIS, 0),
-        LIMIT_ACCEL_LONG(J_AXIS, 0),
-        LIMIT_ACCEL_LONG(K_AXIS, 0),
-        LIMIT_ACCEL_LONG(U_AXIS, 0),
-        LIMIT_ACCEL_LONG(V_AXIS, 0),
-        LIMIT_ACCEL_LONG(W_AXIS, 0)
+        LIMIT_ACCEL_LONG(A_AXIS, 0), LIMIT_ACCEL_LONG(B_AXIS, 0), LIMIT_ACCEL_LONG(C_AXIS, 0),
+        LIMIT_ACCEL_LONG(I_AXIS, 0), LIMIT_ACCEL_LONG(J_AXIS, 0), LIMIT_ACCEL_LONG(K_AXIS, 0),
+        LIMIT_ACCEL_LONG(U_AXIS, 0), LIMIT_ACCEL_LONG(V_AXIS, 0), LIMIT_ACCEL_LONG(W_AXIS, 0)
       );
     }
     else {
       LOGICAL_AXIS_CODE(
         LIMIT_ACCEL_FLOAT(E_AXIS, E_INDEX_N(extruder)),
-        LIMIT_ACCEL_FLOAT(A_AXIS, 0),
-        LIMIT_ACCEL_FLOAT(B_AXIS, 0),
-        LIMIT_ACCEL_FLOAT(C_AXIS, 0),
-        LIMIT_ACCEL_FLOAT(I_AXIS, 0),
-        LIMIT_ACCEL_FLOAT(J_AXIS, 0),
-        LIMIT_ACCEL_FLOAT(K_AXIS, 0),
-        LIMIT_ACCEL_FLOAT(U_AXIS, 0),
-        LIMIT_ACCEL_FLOAT(V_AXIS, 0),
-        LIMIT_ACCEL_FLOAT(W_AXIS, 0)
+        LIMIT_ACCEL_FLOAT(A_AXIS, 0), LIMIT_ACCEL_FLOAT(B_AXIS, 0), LIMIT_ACCEL_FLOAT(C_AXIS, 0),
+        LIMIT_ACCEL_FLOAT(I_AXIS, 0), LIMIT_ACCEL_FLOAT(J_AXIS, 0), LIMIT_ACCEL_FLOAT(K_AXIS, 0),
+        LIMIT_ACCEL_FLOAT(U_AXIS, 0), LIMIT_ACCEL_FLOAT(V_AXIS, 0), LIMIT_ACCEL_FLOAT(W_AXIS, 0)
       );
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
     block->acceleration_rate = (uint32_t)(accel * (float(1UL << 24) / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
@@ -2642,156 +2637,165 @@ bool Planner::_populate_block(
           can be spared, a better acos could be used. For all I know, it may be
           already calculated in a different place. */
 
     // Unit vector of previous path line segment
     static xyze_float_t prev_unit_vec;
 
     xyze_float_t unit_vec =
       #if HAS_DIST_MM_ARG
         cart_dist_mm
       #else
-        LOGICAL_AXIS_ARRAY(steps_dist_mm.e, steps_dist_mm.x, steps_dist_mm.y, steps_dist_mm.z, steps_dist_mm.i, steps_dist_mm.j, steps_dist_mm.k, steps_dist_mm.u, steps_dist_mm.v, steps_dist_mm.w)
+        LOGICAL_AXIS_ARRAY(steps_dist_mm.e,
+          steps_dist_mm.x, steps_dist_mm.y, steps_dist_mm.z,
+          steps_dist_mm.i, steps_dist_mm.j, steps_dist_mm.k,
+          steps_dist_mm.u, steps_dist_mm.v, steps_dist_mm.w)
       #endif
     ;
 
     /**
      * On CoreXY the length of the vector [A,B] is SQRT(2) times the length of the head movement vector [X,Y].
      * So taking Z and E into account, we cannot scale to a unit vector with "inverse_millimeters".
      * => normalize the complete junction vector.
      * Elsewise, when needed JD will factor-in the E component
      */
     if (ANY(IS_CORE, MARKFORGED_XY, MARKFORGED_YX) || esteps > 0)
       normalize_junction_vector(unit_vec);  // Normalize with XYZE components
     else
       unit_vec *= inverse_millimeters;      // Use pre-calculated (1 / SQRT(x^2 + y^2 + z^2))
 
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
       float junction_cos_theta = LOGICAL_AXIS_GANG(
                                  + (-prev_unit_vec.e * unit_vec.e),
-                                   (-prev_unit_vec.x * unit_vec.x),
+                                 + (-prev_unit_vec.x * unit_vec.x),
                                  + (-prev_unit_vec.y * unit_vec.y),
                                  + (-prev_unit_vec.z * unit_vec.z),
                                  + (-prev_unit_vec.i * unit_vec.i),
                                  + (-prev_unit_vec.j * unit_vec.j),
                                  + (-prev_unit_vec.k * unit_vec.k),
                                  + (-prev_unit_vec.u * unit_vec.u),
                                  + (-prev_unit_vec.v * unit_vec.v),
                                  + (-prev_unit_vec.w * unit_vec.w)
                                );
 
       // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
       if (junction_cos_theta > 0.999999f) {
         // For a 0 degree acute junction, just set minimum junction speed.
         vmax_junction_sqr = sq(float(MINIMUM_PLANNER_SPEED));
       }
       else {
-        NOLESS(junction_cos_theta, -0.999999f); // Check for numerical round-off to avoid divide by zero.
-
         // Convert delta vector to unit vector
         xyze_float_t junction_unit_vec = unit_vec - prev_unit_vec;
         normalize_junction_vector(junction_unit_vec);
 
-        const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec),
-                    sin_theta_d2 = SQRT(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
-
-        vmax_junction_sqr = junction_acceleration * junction_deviation_mm * sin_theta_d2 / (1.0f - sin_theta_d2);
-
-        #if ENABLED(JD_HANDLE_SMALL_SEGMENTS)
-
-          // For small moves with >135¬∞ junction (octagon) find speed for approximate arc
-          if (block->millimeters < 1 && junction_cos_theta < -0.7071067812f) {
-
-            #if ENABLED(JD_USE_MATH_ACOS)
-
-              #error "TODO: Inline maths with the MCU / FPU."
-
-            #elif ENABLED(JD_USE_LOOKUP_TABLE)
-
-              // Fast acos approximation (max. error +-0.01 rads)
-              // Based on LUT table and linear interpolation
-
-              /**
-               *  // Generate the JD Lookup Table
-               *  constexpr float c = 1.00751495f; // Correction factor to center error around 0
-               *  for (int i = 0; i < jd_lut_count - 1; ++i) {
-               *    const float x0 = (sq(i) - 1) / sq(i),
-               *                y0 = acos(x0) * (i == 0 ? 1 : c),
-               *                x1 = i < jd_lut_count - 1 ?  0.5 * x0 + 0.5 : 0.999999f,
-               *                y1 = acos(x1) * (i < jd_lut_count - 1 ? c : 1);
-               *    jd_lut_k[i] = (y0 - y1) / (x0 - x1);
-               *    jd_lut_b[i] = (y1 * x0 - y0 * x1) / (x0 - x1);
-               *  }
-               *
-               *  // Compute correction factor (Set c to 1.0f first!)
-               *  float min = INFINITY, max = -min;
-               *  for (float t = 0; t <= 1; t += 0.0003f) {
-               *    const float e = acos(t) / approx(t);
-               *    if (isfinite(e)) {
-               *      if (e < min) min = e;
-               *      if (e > max) max = e;
-               *    }
-               *  }
-               *  fprintf(stderr, "%.9gf, ", (min + max) / 2);
-               */
-              static constexpr int16_t  jd_lut_count = 16;
-              static constexpr uint16_t jd_lut_tll   = _BV(jd_lut_count - 1);
-              static constexpr int16_t  jd_lut_tll0  = __builtin_clz(jd_lut_tll) + 1; // i.e., 16 - jd_lut_count + 1
-              static constexpr float jd_lut_k[jd_lut_count] PROGMEM = {
-                -1.03145837f, -1.30760646f, -1.75205851f, -2.41705704f,
-                -3.37769222f, -4.74888992f, -6.69649887f, -9.45661736f,
-                -13.3640480f, -18.8928222f, -26.7136841f, -37.7754593f,
-                -53.4201813f, -75.5458374f, -106.836761f, -218.532821f };
-              static constexpr float jd_lut_b[jd_lut_count] PROGMEM = {
-                 1.57079637f,  1.70887053f,  2.04220939f,  2.62408352f,
-                 3.52467871f,  4.85302639f,  6.77020454f,  9.50875854f,
-                 13.4009285f,  18.9188995f,  26.7321243f,  37.7885055f,
-                 53.4293975f,  75.5523529f,  106.841369f,  218.534011f };
-
-              const float neg = junction_cos_theta < 0 ? -1 : 1,
-                          t = neg * junction_cos_theta;
-
-              const int16_t idx = (t < 0.00000003f) ? 0 : __builtin_clz(uint16_t((1.0f - t) * jd_lut_tll)) - jd_lut_tll0;
-
-              float junction_theta = t * pgm_read_float(&jd_lut_k[idx]) + pgm_read_float(&jd_lut_b[idx]);
-              if (neg > 0) junction_theta = RADIANS(180) - junction_theta; // acos(-t)
-
-            #else
-
-              // Fast acos(-t) approximation (max. error +-0.033rad = 1.89¬∞)
-              // Based on MinMax polynomial published by W. Randolph Franklin, see
-              // https://wrf.ecse.rpi.edu/Research/Short_Notes/arcsin/onlyelem.html
-              //  acos( t) = pi / 2 - asin(x)
-              //  acos(-t) = pi - acos(t) ... pi / 2 + asin(x)
-
-              const float neg = junction_cos_theta < 0 ? -1 : 1,
-                          t = neg * junction_cos_theta,
-                          asinx =       0.032843707f
-                                + t * (-1.451838349f
-                                + t * ( 29.66153956f
-                                + t * (-131.1123477f
-                                + t * ( 262.8130562f
-                                + t * (-242.7199627f
-                                + t * ( 84.31466202f ) ))))),
-                          junction_theta = RADIANS(90) + neg * asinx; // acos(-t)
-
-              // NOTE: junction_theta bottoms out at 0.033 which avoids divide by 0.
-
-            #endif
-
-            const float limit_sqr = (block->millimeters * junction_acceleration) / junction_theta;
-            NOMORE(vmax_junction_sqr, limit_sqr);
-          }
+        const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec);
 
-        #endif // JD_HANDLE_SMALL_SEGMENTS
+        if (TERN0(HINTS_CURVE_RADIUS, hints.curve_radius)) {
+          TERN_(HINTS_CURVE_RADIUS, vmax_junction_sqr = junction_acceleration * hints.curve_radius);
+        }
+        else {
+          NOLESS(junction_cos_theta, -0.999999f); // Check for numerical round-off to avoid divide by zero.
+
+          const float sin_theta_d2 = SQRT(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
+
+          vmax_junction_sqr = junction_acceleration * junction_deviation_mm * sin_theta_d2 / (1.0f - sin_theta_d2);
+
+          #if ENABLED(JD_HANDLE_SMALL_SEGMENTS)
+
+            // For small moves with >135¬∞ junction (octagon) find speed for approximate arc
+            if (block->millimeters < 1 && junction_cos_theta < -0.7071067812f) {
+
+              #if ENABLED(JD_USE_MATH_ACOS)
+
+                #error "TODO: Inline maths with the MCU / FPU."
+
+              #elif ENABLED(JD_USE_LOOKUP_TABLE)
+
+                // Fast acos approximation (max. error +-0.01 rads)
+                // Based on LUT table and linear interpolation
+
+                /**
+                 *  // Generate the JD Lookup Table
+                 *  constexpr float c = 1.00751495f; // Correction factor to center error around 0
+                 *  for (int i = 0; i < jd_lut_count - 1; ++i) {
+                 *    const float x0 = (sq(i) - 1) / sq(i),
+                 *                y0 = acos(x0) * (i == 0 ? 1 : c),
+                 *                x1 = i < jd_lut_count - 1 ?  0.5 * x0 + 0.5 : 0.999999f,
+                 *                y1 = acos(x1) * (i < jd_lut_count - 1 ? c : 1);
+                 *    jd_lut_k[i] = (y0 - y1) / (x0 - x1);
+                 *    jd_lut_b[i] = (y1 * x0 - y0 * x1) / (x0 - x1);
+                 *  }
+                 *
+                 *  // Compute correction factor (Set c to 1.0f first!)
+                 *  float min = INFINITY, max = -min;
+                 *  for (float t = 0; t <= 1; t += 0.0003f) {
+                 *    const float e = acos(t) / approx(t);
+                 *    if (isfinite(e)) {
+                 *      if (e < min) min = e;
+                 *      if (e > max) max = e;
+                 *    }
+                 *  }
+                 *  fprintf(stderr, "%.9gf, ", (min + max) / 2);
+                 */
+                static constexpr int16_t  jd_lut_count = 16;
+                static constexpr uint16_t jd_lut_tll   = _BV(jd_lut_count - 1);
+                static constexpr int16_t  jd_lut_tll0  = __builtin_clz(jd_lut_tll) + 1; // i.e., 16 - jd_lut_count + 1
+                static constexpr float jd_lut_k[jd_lut_count] PROGMEM = {
+                  -1.03145837f, -1.30760646f, -1.75205851f, -2.41705704f,
+                  -3.37769222f, -4.74888992f, -6.69649887f, -9.45661736f,
+                  -13.3640480f, -18.8928222f, -26.7136841f, -37.7754593f,
+                  -53.4201813f, -75.5458374f, -106.836761f, -218.532821f };
+                static constexpr float jd_lut_b[jd_lut_count] PROGMEM = {
+                   1.57079637f,  1.70887053f,  2.04220939f,  2.62408352f,
+                   3.52467871f,  4.85302639f,  6.77020454f,  9.50875854f,
+                   13.4009285f,  18.9188995f,  26.7321243f,  37.7885055f,
+                   53.4293975f,  75.5523529f,  106.841369f,  218.534011f };
+
+                const float neg = junction_cos_theta < 0 ? -1 : 1,
+                            t = neg * junction_cos_theta;
+
+                const int16_t idx = (t < 0.00000003f) ? 0 : __builtin_clz(uint16_t((1.0f - t) * jd_lut_tll)) - jd_lut_tll0;
+
+                float junction_theta = t * pgm_read_float(&jd_lut_k[idx]) + pgm_read_float(&jd_lut_b[idx]);
+                if (neg > 0) junction_theta = RADIANS(180) - junction_theta; // acos(-t)
+
+              #else
+
+                // Fast acos(-t) approximation (max. error +-0.033rad = 1.89¬∞)
+                // Based on MinMax polynomial published by W. Randolph Franklin, see
+                // https://wrf.ecse.rpi.edu/Research/Short_Notes/arcsin/onlyelem.html
+                //  acos( t) = pi / 2 - asin(x)
+                //  acos(-t) = pi - acos(t) ... pi / 2 + asin(x)
+
+                const float neg = junction_cos_theta < 0 ? -1 : 1,
+                            t = neg * junction_cos_theta,
+                            asinx =       0.032843707f
+                                  + t * (-1.451838349f
+                                  + t * ( 29.66153956f
+                                  + t * (-131.1123477f
+                                  + t * ( 262.8130562f
+                                  + t * (-242.7199627f
+                                  + t * ( 84.31466202f ) ))))),
+                            junction_theta = RADIANS(90) + neg * asinx; // acos(-t)
+
+                // NOTE: junction_theta bottoms out at 0.033 which avoids divide by 0.
+
+              #endif
+
+              const float limit_sqr = (block->millimeters * junction_acceleration) / junction_theta;
+              NOMORE(vmax_junction_sqr, limit_sqr);
+            }
+
+          #endif // JD_HANDLE_SMALL_SEGMENTS
+        }
       }
 
       // Get the lowest speed
       vmax_junction_sqr = _MIN(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
       vmax_junction_sqr = 0;
 
     prev_unit_vec = unit_vec;
 
@@ -2937,41 +2941,39 @@ bool Planner::_populate_block(
   #endif
 
   TERN_(HAS_POSITION_FLOAT, position_float = target_float);
   TERN_(GRADIENT_MIX, mixer.gradient_control(target_float.z));
 
   return true;        // Movement was accepted
 
 } // _populate_block()
 
 /**
- * Planner::buffer_sync_block
- * Add a block to the buffer that just updates the position
- * @param sync_flag BLOCK_FLAG_SYNC_FANS & BLOCK_FLAG_LASER_PWR
- * Supports LASER_SYNCHRONOUS_M106_M107 and LASER_POWER_SYNC power sync block buffer queueing.
+ * @brief Add a block to the buffer that just updates the position
+ *        Supports LASER_SYNCHRONOUS_M106_M107 and LASER_POWER_SYNC power sync block buffer queueing.
+ *
+ * @param sync_flag  The sync flag to set, determining the type of sync the block will do
  */
-
 void Planner::buffer_sync_block(const BlockFlagBit sync_flag/*=BLOCK_BIT_SYNC_POSITION*/) {
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Clear block
-  memset(block, 0, sizeof(block_t));
+  block->reset();
   block->flag.apply(sync_flag);
 
   block->position = position;
   #if ENABLED(BACKLASH_COMPENSATION)
     LOOP_NUM_AXES(axis) block->position[axis] += backlash.get_applied_steps((AxisEnum)axis);
   #endif
-
   #if BOTH(HAS_FAN, LASER_SYNCHRONOUS_M106_M107)
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   /**
    * M3-based power setting can be processed inline with a laser power sync block.
    * During active moves cutter.power is processed immediately, otherwise on the next move.
    */
   TERN_(LASER_POWER_SYNC, block->laser.power = cutter.power);
 
@@ -2984,36 +2986,38 @@ void Planner::buffer_sync_block(const BlockFlagBit sync_flag/*=BLOCK_BIT_SYNC_PO
     // before the following line!!)
     delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
   }
 
   block_buffer_head = next_buffer_head;
 
   stepper.wake_up();
 } // buffer_sync_block()
 
 /**
- * Planner::buffer_segment
- *
- * Add a new linear movement to the buffer in axis units.
+ * @brief Add a single linear movement
  *
- * Leveling and kinematics should be applied ahead of calling this.
+ * @description Add a new linear movement to the buffer in axis units.
+ *              Leveling and kinematics should be applied before calling this.
  *
- *  a,b,c,e     - target positions in mm and/or degrees
- *  fr_mm_s     - (target) speed of the move
- *  extruder    - target extruder
- *  millimeters - the length of the movement, if known
+ * @param abce          Target position in mm and/or degrees
+ * @param cart_dist_mm  The pre-calculated move lengths for all axes, in mm
+ * @param fr_mm_s       (target) speed of the move
+ * @param extruder      optional target extruder (otherwise active_extruder)
+ * @param hints         optional parameters to aid planner calculations
  *
- * Return 'false' if no segment was queued due to cleaning, cold extrusion, full queue, etc.
+ * @return  false if no segment was queued due to cleaning, cold extrusion, full queue, etc.
  */
 bool Planner::buffer_segment(const abce_pos_t &abce
   OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
-  , const_feedRate_t fr_mm_s, const uint8_t extruder/*=active_extruder*/, const_float_t millimeters/*=0.0*/
+  , const_feedRate_t fr_mm_s
+  , const uint8_t extruder/*=active_extruder*/
+  , const PlannerHints &hints/*=PlannerHints()*/
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
     if (last_extruder != extruder && settings.axis_steps_per_mm[E_AXIS_N(extruder)] != settings.axis_steps_per_mm[E_AXIS_N(last_extruder)]) {
       position.e = LROUND(position.e * settings.axis_steps_per_mm[E_AXIS_N(extruder)] * mm_per_step[E_AXIS_N(last_extruder)]);
       last_extruder = extruder;
@@ -3105,40 +3109,40 @@ bool Planner::buffer_segment(const abce_pos_t &abce
       SERIAL_ECHOLNPGM(" (", position.e, "->", target.e, ")");
     #else
       SERIAL_EOL();
     #endif
   //*/
 
   // Queue the movement. Return 'false' if the move was not queued.
   if (!_buffer_steps(target
       OPTARG(HAS_POSITION_FLOAT, target_float)
       OPTARG(HAS_DIST_MM_ARG, cart_dist_mm)
-      , fr_mm_s, extruder, millimeters)
-  ) return false;
+      , fr_mm_s, extruder, hints
+  )) return false;
 
   stepper.wake_up();
   return true;
 } // buffer_segment()
 
 /**
  * Add a new linear movement to the buffer.
  * The target is cartesian. It's translated to
  * delta/scara if needed.
  *
  *  cart            - target position in mm or degrees
  *  fr_mm_s         - (target) speed of the move (mm/s)
- *  extruder        - target extruder
- *  millimeters     - the length of the movement, if known
- *  inv_duration    - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
+ *  extruder        - optional target extruder (otherwise active_extruder)
+ *  hints           - optional parameters to aid planner calculations
  */
-bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s, const uint8_t extruder/*=active_extruder*/, const float millimeters/*=0.0*/
-  OPTARG(SCARA_FEEDRATE_SCALING, const_float_t inv_duration/*=0.0*/)
+bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s
+  , const uint8_t extruder/*=active_extruder*/
+  , const PlannerHints &hints/*=PlannerHints()*/
 ) {
   xyze_pos_t machine = cart;
   TERN_(HAS_POSITION_MODIFIERS, apply_modifiers(machine));
 
   #if IS_KINEMATIC
 
     #if HAS_JUNCTION_DEVIATION
       const xyze_pos_t cart_dist_mm = LOGICAL_AXIS_ARRAY(
         cart.e - position_cart.e,
         cart.x - position_cart.x, cart.y - position_cart.y, cart.z - position_cart.z,
@@ -3146,42 +3150,44 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s, cons
         cart.u - position_cart.u, cart.v - position_cart.v, cart.w - position_cart.w
       );
     #else
       const xyz_pos_t cart_dist_mm = NUM_AXIS_ARRAY(
         cart.x - position_cart.x, cart.y - position_cart.y, cart.z - position_cart.z,
         cart.i - position_cart.i, cart.j - position_cart.j, cart.k - position_cart.k,
         cart.u - position_cart.u, cart.v - position_cart.v, cart.w - position_cart.w
       );
     #endif
 
-    const float mm = millimeters ?: (cart_dist_mm.x || cart_dist_mm.y) ? cart_dist_mm.magnitude() : TERN0(HAS_Z_AXIS, ABS(cart_dist_mm.z));
-
     // Cartesian XYZ to kinematic ABC, stored in global 'delta'
     inverse_kinematics(machine);
 
+    PlannerHints ph = hints;
+    if (!hints.millimeters)
+      ph.millimeters = (cart_dist_mm.x || cart_dist_mm.y) ? cart_dist_mm.magnitude() : TERN0(HAS_Z_AXIS, ABS(cart_dist_mm.z));
+
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feedrate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
-      const float duration_recip = inv_duration ?: fr_mm_s / mm;
+      const float duration_recip = hints.inv_duration ?: fr_mm_s / ph.millimeters;
       const xyz_pos_t diff = delta - position_float;
       const feedRate_t feedrate = diff.magnitude() * duration_recip;
     #else
       const feedRate_t feedrate = fr_mm_s;
     #endif
     TERN_(HAS_EXTRUDERS, delta.e = machine.e);
-    if (buffer_segment(delta OPTARG(HAS_DIST_MM_ARG, cart_dist_mm), feedrate, extruder, mm)) {
+    if (buffer_segment(delta OPTARG(HAS_DIST_MM_ARG, cart_dist_mm), feedrate, extruder, ph)) {
       position_cart = cart;
       return true;
     }
     return false;
   #else
-    return buffer_segment(machine, fr_mm_s, extruder, millimeters);
+    return buffer_segment(machine, fr_mm_s, extruder, hints);
   #endif
 } // buffer_line()
 
 #if ENABLED(DIRECT_STEPPING)
 
   void Planner::buffer_page(const page_idx_t page_idx, const uint8_t extruder, const uint16_t num_steps) {
     if (!last_page_step_rate) {
       kill(GET_TEXT_F(MSG_BAD_PAGE_SPEED));
       return;
     }

commit 6a67ad4e4aacf7e7314f9e15fd8fe8489b73742b
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Wed Jul 6 07:46:39 2022 -0500

    ‚ö°Ô∏è Fix and improve Inline Laser Power (#22690)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index b80be01dea..bc5bfd3dfc 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -121,22 +121,27 @@ Planner planner;
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head,    // Index of the next block to be pushed
                  Planner::block_buffer_nonbusy, // Index of the first non-busy block
                  Planner::block_buffer_planned, // Index of the optimally planned block
                  Planner::block_buffer_tail;    // Index of the busy block, if any
 uint16_t Planner::cleaning_buffer_counter;      // A counter to disable queuing of blocks
 uint8_t Planner::delay_before_delivering;       // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
 planner_settings_t Planner::settings;           // Initialized by settings.load()
 
-#if ENABLED(LASER_POWER_INLINE)
+/**
+ * Set up inline block variables
+ * Set laser_power_floor based on SPEED_POWER_MIN to pevent a zero power output state with LASER_POWER_TRAP
+ */
+#if ENABLED(LASER_FEATURE)
   laser_state_t Planner::laser_inline;          // Current state for blocks
+  const uint8_t laser_power_floor = cutter.pct_to_ocr(SPEED_POWER_MIN);
 #endif
 
 uint32_t Planner::max_acceleration_steps_per_s2[DISTINCT_AXES]; // (steps/s^2) Derived from mm_per_s2
 
 float Planner::mm_per_step[DISTINCT_AXES];      // (mm) Millimeters per step
 
 #if HAS_JUNCTION_DEVIATION
   float Planner::junction_deviation_mm;         // (mm) M205 J
   #if HAS_LINEAR_E_JERK
     float Planner::max_e_jerk[DISTINCT_E];      // Calculated from junction_deviation_mm
@@ -792,20 +797,21 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
           // Steps between acceleration and deceleration, if any
   int32_t plateau_steps = block->step_event_count - accelerate_steps - decelerate_steps;
 
   // Does accelerate_steps + decelerate_steps exceed step_event_count?
   // Then we can't possibly reach the nominal rate, there will be no cruising.
   // Use intersection_distance() to calculate accel / braking time in order to
   // reach the final_rate exactly at the end of this block.
   if (plateau_steps < 0) {
     const float accelerate_steps_float = CEIL(intersection_distance(initial_rate, final_rate, accel, block->step_event_count));
     accelerate_steps = _MIN(uint32_t(_MAX(accelerate_steps_float, 0)), block->step_event_count);
+    decelerate_steps = block->step_event_count - accelerate_steps;
     plateau_steps = 0;
 
     #if ENABLED(S_CURVE_ACCELERATION)
       // We won't reach the cruising rate. Let's calculate the speed we will reach
       cruise_rate = final_speed(initial_rate, accel, accelerate_steps);
     #endif
   }
   #if ENABLED(S_CURVE_ACCELERATION)
     else // We have some plateau time, so the cruise rate will be the nominal rate
       cruise_rate = block->nominal_rate;
@@ -815,71 +821,77 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
     // Jerk controlled speed requires to express speed versus time, NOT steps
     uint32_t acceleration_time = ((float)(cruise_rate - initial_rate) / accel) * (STEPPER_TIMER_RATE),
              deceleration_time = ((float)(cruise_rate - final_rate) / accel) * (STEPPER_TIMER_RATE),
     // And to offload calculations from the ISR, we also calculate the inverse of those times here
              acceleration_time_inverse = get_period_inverse(acceleration_time),
              deceleration_time_inverse = get_period_inverse(deceleration_time);
   #endif
 
   // Store new block parameters
   block->accelerate_until = accelerate_steps;
-  block->decelerate_after = accelerate_steps + plateau_steps;
+  block->decelerate_after = block->step_event_count - decelerate_steps;
   block->initial_rate = initial_rate;
   #if ENABLED(S_CURVE_ACCELERATION)
     block->acceleration_time = acceleration_time;
     block->deceleration_time = deceleration_time;
     block->acceleration_time_inverse = acceleration_time_inverse;
     block->deceleration_time_inverse = deceleration_time_inverse;
     block->cruise_rate = cruise_rate;
   #endif
   block->final_rate = final_rate;
 
-  /**
-   * Laser trapezoid calculations
-   *
-   * Approximate the trapezoid with the laser, incrementing the power every `entry_per` while accelerating
-   * and decrementing it every `exit_power_per` while decelerating, thus ensuring power is related to feedrate.
-   *
-   * LASER_POWER_INLINE_TRAPEZOID_CONT doesn't need this as it continuously approximates
-   *
-   * Note this may behave unreliably when running with S_CURVE_ACCELERATION
-   */
-  #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
-    if (block->laser.power > 0) { // No need to care if power == 0
-      const uint8_t entry_power = block->laser.power * entry_factor; // Power on block entry
-      #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
-        // Speedup power
-        const uint8_t entry_power_diff = block->laser.power - entry_power;
-        if (entry_power_diff) {
-          block->laser.entry_per = accelerate_steps / entry_power_diff;
-          block->laser.power_entry = entry_power;
-        }
-        else {
-          block->laser.entry_per = 0;
-          block->laser.power_entry = block->laser.power;
-        }
-        // Slowdown power
-        const uint8_t exit_power = block->laser.power * exit_factor, // Power on block entry
-                      exit_power_diff = block->laser.power - exit_power;
-        if (exit_power_diff) {
-          block->laser.exit_per = (block->step_event_count - block->decelerate_after) / exit_power_diff;
-          block->laser.power_exit = exit_power;
+  #if ENABLED(LASER_POWER_TRAP)
+    /**
+     * Laser Trapezoid Calculations
+     *
+     * Approximate the trapezoid with the laser, incrementing the power every `trap_ramp_entry_incr` steps while accelerating,
+     * and decrementing the power every `trap_ramp_exit_decr` while decelerating, to keep power proportional to feedrate.
+     * Laser power trap will reduce the initial power to no less than the laser_power_floor value. Based on the number
+     * of calculated accel/decel steps the power is distributed over the trapezoid entry- and exit-ramp steps.
+     *
+     * trap_ramp_active_pwr - The active power is initially set at a reduced level factor of initial power / accel steps and
+     * will be additively incremented using a trap_ramp_entry_incr value for each accel step processed later in the stepper code.
+     * The trap_ramp_exit_decr value is calculated as power / decel steps and is also adjusted to no less than the power floor.
+     *
+     * If the power == 0 the inline mode variables need to be set to zero to prevent stepper processing. The method allows
+     * for simpler non-powered moves like G0 or G28.
+     *
+     * Laser Trap Power works for all Jerk and Curve modes; however Arc-based moves will have issues since the segments are
+     * usually too small.
+     */
+    if (cutter.cutter_mode == CUTTER_MODE_CONTINUOUS) {
+      if (planner.laser_inline.status.isPowered && planner.laser_inline.status.isEnabled) {
+        if (block->laser.power > 0) {
+          NOLESS(block->laser.power, laser_power_floor);
+          block->laser.trap_ramp_active_pwr = (block->laser.power - laser_power_floor) * (initial_rate / float(block->nominal_rate)) + laser_power_floor;
+          block->laser.trap_ramp_entry_incr = (block->laser.power - block->laser.trap_ramp_active_pwr) / accelerate_steps;
+          float laser_pwr = block->laser.power * (final_rate / float(block->nominal_rate));
+          NOLESS(laser_pwr, laser_power_floor);
+          block->laser.trap_ramp_exit_decr = (block->laser.power - laser_pwr) / decelerate_steps;
+          #if ENABLED(DEBUG_LASER_TRAP)
+            SERIAL_ECHO_MSG("lp:",block->laser.power);
+            SERIAL_ECHO_MSG("as:",accelerate_steps);
+            SERIAL_ECHO_MSG("ds:",decelerate_steps);
+            SERIAL_ECHO_MSG("p.trap:",block->laser.trap_ramp_active_pwr);
+            SERIAL_ECHO_MSG("p.incr:",block->laser.trap_ramp_entry_incr);
+            SERIAL_ECHO_MSG("p.decr:",block->laser.trap_ramp_exit_decr);
+          #endif
         }
         else {
-          block->laser.exit_per = 0;
-          block->laser.power_exit = block->laser.power;
+          block->laser.trap_ramp_active_pwr = 0;
+          block->laser.trap_ramp_entry_incr = 0;
+          block->laser.trap_ramp_exit_decr = 0;
         }
-      #else
-        block->laser.power_entry = entry_power;
-      #endif
+
+      }
     }
-  #endif
+  #endif // LASER_POWER_TRAP
 }
 
 /*                            PLANNER SPEED DEFINITION
                                      +--------+   <- current->nominal_speed
                                     /          \
          current->entry_speed ->   +            \
                                    |             + <- next->entry_speed (aka exit speed)
                                    +-------------+
                                        time -->
 
@@ -1123,24 +1135,23 @@ void Planner::forward_pass() {
 
 /**
  * Recalculate the trapezoid speed profiles for all blocks in the plan
  * according to the entry_factor for each junction. Must be called by
  * recalculate() after updating the blocks.
  */
 void Planner::recalculate_trapezoids() {
   // The tail may be changed by the ISR so get a local copy.
   uint8_t block_index = block_buffer_tail,
           head_block_index = block_buffer_head;
-
-  // Since there could be non-move blocks in the head of the queue, and the
+  // Since there could be a sync block in the head of the queue, and the
   // next loop must not recalculate the head block (as it needs to be
-  // specially handled), scan backwards to the first move block.
+  // specially handled), scan backwards to the first non-SYNC block.
   while (head_block_index != block_index) {
 
     // Go back (head always point to the first free block)
     const uint8_t prev_index = prev_block_index(head_block_index);
 
     // Get the pointer to the block
     block_t *prev = &block_buffer[prev_index];
 
     // It the block is a move, we're done with this loop
     if (prev->is_move()) break;
@@ -1196,21 +1207,21 @@ void Planner::recalculate_trapezoids() {
       block = next;
       current_entry_speed = next_entry_speed;
     }
 
     block_index = next_block_index(block_index);
   }
 
   // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
   if (next) {
 
-    // Mark the last block as RECALCULATE, to prevent the Stepper ISR running it.
+    // Mark the next(last) block as RECALCULATE, to prevent the Stepper ISR running it.
     // As the last block is always recalculated here, there is a chance the block isn't
     // marked as RECALCULATE yet. That's the reason for the following line.
     block->flag.recalculate = true;
 
     // But there is an inherent race condition here, as the block maybe
     // became BUSY, just before it was marked as RECALCULATE, so check
     // if that is the case!
     if (!stepper.is_block_busy(block)) {
       // Block is not BUSY, we won the race against the Stepper ISR:
 
@@ -1288,21 +1299,21 @@ void Planner::recalculate() {
       }
       else
         fan_kick_end[f] = 0;
     }
 
   #endif
 
 #endif // HAS_FAN
 
 /**
- * Maintain fans, paste extruder pressure,
+ * Maintain fans, paste extruder pressure, spindle/laser power
  */
 void Planner::check_axes_activity() {
 
   #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_I, DISABLE_J, DISABLE_K, DISABLE_U, DISABLE_V, DISABLE_W, DISABLE_E)
     xyze_bool_t axis_active = { false };
   #endif
 
   #if HAS_FAN && DISABLED(LASER_SYNCHRONOUS_M106_M107)
     #define HAS_TAIL_FAN_SPEED 1
     static uint8_t tail_fan_speed[FAN_COUNT] = ARRAY_N_1(FAN_COUNT, 13);
@@ -1352,21 +1363,21 @@ void Planner::check_axes_activity() {
           if (TERN0(DISABLE_K, bnext->steps.k)) axis_active.k = true,
           if (TERN0(DISABLE_U, bnext->steps.u)) axis_active.u = true,
           if (TERN0(DISABLE_V, bnext->steps.v)) axis_active.v = true,
           if (TERN0(DISABLE_W, bnext->steps.w)) axis_active.w = true
         );
       }
     #endif
   }
   else {
 
-    TERN_(HAS_CUTTER, cutter.refresh());
+    TERN_(HAS_CUTTER, if (cutter.cutter_mode == CUTTER_MODE_STANDARD) cutter.refresh());
 
     #if HAS_TAIL_FAN_SPEED
       FANS_LOOP(i) {
         const uint8_t spd = thermalManager.scaledFanSpeed(i);
         if (tail_fan_speed[i] != spd) {
           fans_need_update = true;
           tail_fan_speed[i] = spd;
         }
       }
     #endif
@@ -1452,21 +1463,21 @@ void Planner::check_axes_activity() {
   void Planner::autotemp_task() {
     static float oldt = 0.0f;
 
     if (!autotemp_enabled) return;
     if (thermalManager.degTargetHotend(active_extruder) < autotemp_min - 2) return; // Below the min?
 
     float high = 0.0f;
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       const block_t * const block = &block_buffer[b];
       if (NUM_AXIS_GANG(block->steps.x, || block->steps.y, || block->steps.z, || block->steps.i, || block->steps.j, || block->steps.k, || block->steps.u, || block->steps.v, || block->steps.w)) {
-        const float se = (float)block->steps.e / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec
+        const float se = (float)block->steps.e / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;
         NOLESS(high, se);
       }
     }
 
     float t = autotemp_min + high * autotemp_factor;
     LIMIT(t, autotemp_min, autotemp_max);
     if (t < oldt) t = t * (1.0f - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
     oldt = t;
     thermalManager.setTargetHotend(t, active_extruder);
   }
@@ -1774,21 +1785,21 @@ void Planner::synchronize() { while (busy()) idle(); }
  *  target_float  - target position in direct (mm, degrees) units. optional
  *  fr_mm_s       - (target) speed of the move
  *  extruder      - target extruder
  *  millimeters   - the length of the movement, if known
  *
  * Returns true if movement was properly queued, false otherwise (if cleaning)
  */
 bool Planner::_buffer_steps(const xyze_long_t &target
   OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
   OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
-  , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters/*=0.0*/
+  , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters
 ) {
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // If we are cleaning, do not accept queuing of movements
   // This must be after get_next_free_block() because it calls idle()
   // where cleaning_buffer_counter can be changed
   if (cleaning_buffer_counter) return false;
@@ -1856,22 +1867,50 @@ bool Planner::_populate_block(
     dc = target.c - position.c,
     di = target.i - position.i,
     dj = target.j - position.j,
     dk = target.k - position.k,
     du = target.u - position.u,
     dv = target.v - position.v,
     dw = target.w - position.w
   );
 
   /* <-- add a slash to enable
-    #define _ALINE(A) " " STR_##A  ":", target[_AXIS(A)], " (", int32_t(target[_AXIS(A)] - position[_AXIS(A)]), " steps)"
-    SERIAL_ECHOLNPGM("  _populate_block FR:", fr_mm_s, LOGICAL_AXIS_MAP(_ALINE));
+    SERIAL_ECHOLNPGM(
+      "  _populate_block FR:", fr_mm_s,
+      " A:", target.a, " (", da, " steps)"
+      #if HAS_Y_AXIS
+        " B:", target.b, " (", db, " steps)"
+      #endif
+      #if HAS_Z_AXIS
+        " C:", target.c, " (", dc, " steps)"
+      #endif
+      #if HAS_I_AXIS
+        " " STR_I ":", target.i, " (", di, " steps)"
+      #endif
+      #if HAS_J_AXIS
+        " " STR_J ":", target.j, " (", dj, " steps)"
+      #endif
+      #if HAS_K_AXIS
+        " " STR_K ":", target.k, " (", dk, " steps)"
+      #endif
+      #if HAS_U_AXIS
+        " " STR_U ":", target.u, " (", du, " steps)"
+      #endif
+      #if HAS_V_AXIS
+        " " STR_V ":", target.v, " (", dv, " steps)"
+      #endif
+      #if HAS_W_AXIS
+        " " STR_W ":", target.w, " (", dw, " steps)"
+      #if HAS_EXTRUDERS
+        " E:", target.e, " (", de, " steps)"
+      #endif
+    );
   //*/
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position.e = target.e; // Behave as if the move really took place, but ignore E part
           TERN_(HAS_POSITION_FLOAT, position_float.e = target_float.e);
           de = 0; // no difference
           SERIAL_ECHO_MSG(STR_ERR_COLD_EXTRUDE_STOP);
@@ -1955,25 +1994,48 @@ bool Planner::_populate_block(
   #else
     constexpr uint32_t esteps = 0;
   #endif
 
   // Clear all flags, including the "busy" bit
   block->flag.clear();
 
   // Set direction bits
   block->direction_bits = dm;
 
-  // Update block laser power
-  #if ENABLED(LASER_POWER_INLINE)
-    laser_inline.status.isPlanned = true;
-    block->laser.status = laser_inline.status;
-    block->laser.power = laser_inline.power;
+  /**
+   * Update block laser power
+   * For standard mode get the cutter.power value for processing, since it's
+   * only set by apply_power().
+   */
+  #if HAS_CUTTER
+    switch (cutter.cutter_mode) {
+      default: break;
+
+      case CUTTER_MODE_STANDARD: block->cutter_power = cutter.power; break;
+
+      #if ENABLED(LASER_FEATURE)
+        /**
+         * For inline mode get the laser_inline variables, including power and status.
+         * Dynamic mode only needs to update if the feedrate has changed, since it's
+         * calculated from the current feedrate and power level.
+         */
+        case CUTTER_MODE_CONTINUOUS:
+          block->laser.power = laser_inline.power;
+          block->laser.status = laser_inline.status;
+          break;
+
+        case CUTTER_MODE_DYNAMIC:
+          if (cutter.laser_feedrate_changed())  // Only process changes in rate
+            block->laser.power = laser_inline.power = cutter.calc_dynamic_power();
+          break;
+      #endif
+    }
   #endif
 
   // Number of steps for each axis
   // See https://www.corexy.com/theory.html
   block->steps.set(NUM_AXIS_LIST(
     #if CORE_IS_XY
       ABS(da + db), ABS(da - db), ABS(dc)
     #elif CORE_IS_XZ
       ABS(da + dc), ABS(db), ABS(da - dc)
     #elif CORE_IS_YZ
@@ -2021,23 +2083,23 @@ bool Planner::_populate_block(
       steps_dist_mm.c      = CORESIGN(da - dc) * mm_per_step[C_AXIS];
     #elif CORE_IS_YZ
       steps_dist_mm.x      = da * mm_per_step[X_AXIS];
       steps_dist_mm.head.y = db * mm_per_step[B_AXIS];
       steps_dist_mm.head.z = dc * mm_per_step[C_AXIS];
       steps_dist_mm.b      = (db + dc) * mm_per_step[B_AXIS];
       steps_dist_mm.c      = CORESIGN(db - dc) * mm_per_step[C_AXIS];
     #endif
   #elif ENABLED(MARKFORGED_XY)
     steps_dist_mm.a      = (da - db) * mm_per_step[A_AXIS];
-    steps_dist_mm.b      =       db  * mm_per_step[B_AXIS];
+    steps_dist_mm.b      = db * mm_per_step[B_AXIS];
   #elif ENABLED(MARKFORGED_YX)
-    steps_dist_mm.a      =       da  * mm_per_step[A_AXIS];
+    steps_dist_mm.a      = da * mm_per_step[A_AXIS];
     steps_dist_mm.b      = (db - da) * mm_per_step[B_AXIS];
   #else
     XYZ_CODE(
       steps_dist_mm.a = da * mm_per_step[A_AXIS],
       steps_dist_mm.b = db * mm_per_step[B_AXIS],
       steps_dist_mm.c = dc * mm_per_step[C_AXIS]
     );
   #endif
 
   SECONDARY_AXIS_CODE(
@@ -2069,66 +2131,56 @@ bool Planner::_populate_block(
       && block->steps.w < MIN_STEPS_PER_SEGMENT
     )
   ) {
     block->millimeters = TERN0(HAS_EXTRUDERS, ABS(steps_dist_mm.e));
   }
   else {
     if (millimeters)
       block->millimeters = millimeters;
     else {
       /**
-       * Distance for interpretation of feedrate in accordance with LinuxCNC (the successor of
-       * NIST RS274NGC interpreter - version 3) and its default CANON_XYZ feed reference mode.
-       *
-       * Assume:
-       *   - X, Y, Z are the primary linear axes;
-       *   - U, V, W are secondary linear axes;
-       *   - A, B, C are rotational axes.
-       *
-       * Then:
-       *   - dX, dY, dZ are the displacements of the primary linear axes;
-       *   - dU, dV, dW are the displacements of linear axes;
-       *   - dA, dB, dC are the displacements of rotational axes.
-       *
-       * The time it takes to execute move command with feedrate F is t = D/F,
-       * where D is the total distance, calculated as follows:
+       * Distance for interpretation of feedrate in accordance with LinuxCNC (the successor of NIST
+       * RS274NGC interpreter - version 3) and its default CANON_XYZ feed reference mode.
+       * Assume that X, Y, Z are the primary linear axes and U, V, W are secondary linear axes and A, B, C are
+       * rotational axes. Then dX, dY, dZ are the displacements of the primary linear axes and dU, dV, dW are the displacements of linear axes and
+       * dA, dB, dC are the displacements of rotational axes.
+       * The time it takes to execute move command with feedrate F is t = D/F, where D is the total distance, calculated as follows:
        *   D^2 = dX^2 + dY^2 + dZ^2
        *   if D^2 == 0 (none of XYZ move but any secondary linear axes move, whether other axes are moved or not):
        *     D^2 = dU^2 + dV^2 + dW^2
        *   if D^2 == 0 (only rotational axes are moved):
        *     D^2 = dA^2 + dB^2 + dC^2
        */
       float distance_sqr = (
         #if ENABLED(ARTICULATED_ROBOT_ARM)
-          // For articulated robots, interpreting feedrate like LinuxCNC would require inverse kinematics. As a workaround,
-          // assume that motors sit on a mutually-orthogonal axes and we can think of distance as magnitude of an n-vector
-          // in an n-dimensional Euclidian space.
+          // For articulated robots, interpreting feedrate like LinuxCNC would require inverse kinematics. As a workaround, pretend that motors sit on n mutually orthogonal
+          // axes and assume that we could think of distance as magnitude of an n-vector in an n-dimensional Euclidian space.
           NUM_AXIS_GANG(
               sq(steps_dist_mm.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.z),
             + sq(steps_dist_mm.i), + sq(steps_dist_mm.j), + sq(steps_dist_mm.k),
             + sq(steps_dist_mm.u), + sq(steps_dist_mm.v), + sq(steps_dist_mm.w)
           );
         #elif ENABLED(FOAMCUTTER_XYUV)
           #if HAS_J_AXIS
             // Special 5 axis kinematics. Return the largest distance move from either X/Y or I/J plane
             _MAX(sq(steps_dist_mm.x) + sq(steps_dist_mm.y), sq(steps_dist_mm.i) + sq(steps_dist_mm.j))
           #else // Foamcutter with only two axes (XY)
             sq(steps_dist_mm.x) + sq(steps_dist_mm.y)
           #endif
         #elif ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
           XYZ_GANG(sq(steps_dist_mm.head.x), + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.z))
         #elif CORE_IS_XZ
           XYZ_GANG(sq(steps_dist_mm.head.x), + sq(steps_dist_mm.y),      + sq(steps_dist_mm.head.z))
         #elif CORE_IS_YZ
           XYZ_GANG(sq(steps_dist_mm.x),      + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.head.z))
         #else
-          XYZ_GANG(sq(steps_dist_mm.x),      + sq(steps_dist_mm.y),      + sq(steps_dist_mm.z))
+          XYZ_GANG(sq(steps_dist_mm.x),       + sq(steps_dist_mm.y),      + sq(steps_dist_mm.z))
         #endif
       );
 
       #if SECONDARY_LINEAR_AXES >= 1 && NONE(FOAMCUTTER_XYUV, ARTICULATED_ROBOT_ARM)
         if (NEAR_ZERO(distance_sqr)) {
           // Move does not involve any primary linear axes (xyz) but might involve secondary linear axes
           distance_sqr = (0.0
             SECONDARY_AXIS_GANG(
               IF_DISABLED(AXIS4_ROTATES, + sq(steps_dist_mm.i)),
               IF_DISABLED(AXIS5_ROTATES, + sq(steps_dist_mm.j)),
@@ -2147,61 +2199,66 @@ bool Planner::_populate_block(
           TERN_(INCH_MODE_SUPPORT, cartesian_move = false);
           distance_sqr = ROTATIONAL_AXIS_GANG(sq(steps_dist_mm.i), + sq(steps_dist_mm.j), + sq(steps_dist_mm.k), + sq(steps_dist_mm.u), + sq(steps_dist_mm.v), + sq(steps_dist_mm.w));
         }
       #endif
 
       block->millimeters = SQRT(distance_sqr);
     }
 
     /**
      * At this point at least one of the axes has more steps than
-     * MIN_STEPS_PER_SEGMENT, ensuring the segment won't get dropped
-     * as zero-length. It's important to not apply corrections to blocks
-     * that would get dropped!
+     * MIN_STEPS_PER_SEGMENT, ensuring the segment won't get dropped as
+     * zero-length. It's important to not apply corrections
+     * to blocks that would get dropped!
      *
      * A correction function is permitted to add steps to an axis, it
      * should *never* remove steps!
      */
     TERN_(BACKLASH_COMPENSATION, backlash.add_correction_steps(da, db, dc, dm, block));
   }
 
   TERN_(HAS_EXTRUDERS, block->steps.e = esteps);
 
   block->step_event_count = _MAX(LOGICAL_AXIS_LIST(esteps,
     block->steps.a, block->steps.b, block->steps.c,
     block->steps.i, block->steps.j, block->steps.k,
     block->steps.u, block->steps.v, block->steps.w
   ));
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   TERN_(MIXING_EXTRUDER, mixer.populate_block(block->b_color));
 
-  TERN_(HAS_CUTTER, block->cutter_power = cutter.power);
 
   #if HAS_FAN
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
   E_TERN_(block->extruder = extruder);
 
   #if ENABLED(AUTO_POWER_CONTROL)
     if (NUM_AXIS_GANG(
-         block->steps.x, || block->steps.y, || block->steps.z,
-      || block->steps.i, || block->steps.j, || block->steps.k,
-      || block->steps.u, || block->steps.v, || block->steps.w
+         block->steps.x,
+      || block->steps.y,
+      || block->steps.z,
+      || block->steps.i,
+      || block->steps.j,
+      || block->steps.k,
+      || block->steps.u,
+      || block->steps.v,
+      || block->steps.w
     )) powerManager.power_on();
   #endif
 
   // Enable active axes
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
     if (block->steps.a || block->steps.b) {
       stepper.enable_axis(X_AXIS);
       stepper.enable_axis(Y_AXIS);
     }
     #if DISABLED(Z_LATE_ENABLE)
@@ -2421,21 +2478,21 @@ bool Planner::_populate_block(
         }
       }
     }
 
   #endif // XY_FREQUENCY_LIMIT
 
   // Correct the speed
   if (speed_factor < 1.0f) {
     current_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
-    block->nominal_speed_sqr *= sq(speed_factor);
+    block->nominal_speed_sqr = block->nominal_speed_sqr * sq(speed_factor);
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
   if (NUM_AXIS_GANG(
          !block->steps.a, && !block->steps.b, && !block->steps.c,
       && !block->steps.i, && !block->steps.j, && !block->steps.k,
       && !block->steps.u, && !block->steps.v, && !block->steps.w)
   ) {                                                             // Is this a retract / recover move?
@@ -2623,29 +2680,28 @@ bool Planner::_populate_block(
                                  + (-prev_unit_vec.v * unit_vec.v),
                                  + (-prev_unit_vec.w * unit_vec.w)
                                );
 
       // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
       if (junction_cos_theta > 0.999999f) {
         // For a 0 degree acute junction, just set minimum junction speed.
         vmax_junction_sqr = sq(float(MINIMUM_PLANNER_SPEED));
       }
       else {
+        NOLESS(junction_cos_theta, -0.999999f); // Check for numerical round-off to avoid divide by zero.
+
         // Convert delta vector to unit vector
         xyze_float_t junction_unit_vec = unit_vec - prev_unit_vec;
         normalize_junction_vector(junction_unit_vec);
 
-        const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec);
-
-        NOLESS(junction_cos_theta, -0.999999f); // Check for numerical round-off to avoid divide by zero.
-
-        const float sin_theta_d2 = SQRT(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
+        const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec),
+                    sin_theta_d2 = SQRT(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
 
         vmax_junction_sqr = junction_acceleration * junction_deviation_mm * sin_theta_d2 / (1.0f - sin_theta_d2);
 
         #if ENABLED(JD_HANDLE_SMALL_SEGMENTS)
 
           // For small moves with >135¬∞ junction (octagon) find speed for approximate arc
           if (block->millimeters < 1 && junction_cos_theta < -0.7071067812f) {
 
             #if ENABLED(JD_USE_MATH_ACOS)
 
@@ -2882,46 +2938,50 @@ bool Planner::_populate_block(
 
   TERN_(HAS_POSITION_FLOAT, position_float = target_float);
   TERN_(GRADIENT_MIX, mixer.gradient_control(target_float.z));
 
   return true;        // Movement was accepted
 
 } // _populate_block()
 
 /**
  * Planner::buffer_sync_block
- * Add a block to the buffer that just updates the position,
- * or in case of LASER_SYNCHRONOUS_M106_M107 the fan PWM
+ * Add a block to the buffer that just updates the position
+ * @param sync_flag BLOCK_FLAG_SYNC_FANS & BLOCK_FLAG_LASER_PWR
+ * Supports LASER_SYNCHRONOUS_M106_M107 and LASER_POWER_SYNC power sync block buffer queueing.
  */
-void Planner::buffer_sync_block(TERN_(LASER_SYNCHRONOUS_M106_M107, const BlockFlagBit sync_flag/*=BLOCK_BIT_SYNC_POSITION*/)) {
-  #if DISABLED(LASER_SYNCHRONOUS_M106_M107)
-    constexpr BlockFlagBit sync_flag = BLOCK_BIT_SYNC_POSITION;
-  #endif
+
+void Planner::buffer_sync_block(const BlockFlagBit sync_flag/*=BLOCK_BIT_SYNC_POSITION*/) {
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Clear block
-  block->reset();
-
+  memset(block, 0, sizeof(block_t));
   block->flag.apply(sync_flag);
 
   block->position = position;
   #if ENABLED(BACKLASH_COMPENSATION)
     LOOP_NUM_AXES(axis) block->position[axis] += backlash.get_applied_steps((AxisEnum)axis);
   #endif
 
   #if BOTH(HAS_FAN, LASER_SYNCHRONOUS_M106_M107)
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
+  /**
+   * M3-based power setting can be processed inline with a laser power sync block.
+   * During active moves cutter.power is processed immediately, otherwise on the next move.
+   */
+  TERN_(LASER_POWER_SYNC, block->laser.power = cutter.power);
+
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
     // give the planner an opportunity to queue more movements and plan them
     // As there are no queued movements, the Stepper ISR will not touch this
     // variable, so there is no risk setting this here (but it MUST be done
     // before the following line!!)
     delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
   }
 
@@ -3045,22 +3105,22 @@ bool Planner::buffer_segment(const abce_pos_t &abce
       SERIAL_ECHOLNPGM(" (", position.e, "->", target.e, ")");
     #else
       SERIAL_EOL();
     #endif
   //*/
 
   // Queue the movement. Return 'false' if the move was not queued.
   if (!_buffer_steps(target
       OPTARG(HAS_POSITION_FLOAT, target_float)
       OPTARG(HAS_DIST_MM_ARG, cart_dist_mm)
-      , fr_mm_s, extruder, millimeters
-  )) return false;
+      , fr_mm_s, extruder, millimeters)
+  ) return false;
 
   stepper.wake_up();
   return true;
 } // buffer_segment()
 
 /**
  * Add a new linear movement to the buffer.
  * The target is cartesian. It's translated to
  * delta/scara if needed.
  *
@@ -3092,49 +3152,41 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s, cons
         cart.u - position_cart.u, cart.v - position_cart.v, cart.w - position_cart.w
       );
     #endif
 
     const float mm = millimeters ?: (cart_dist_mm.x || cart_dist_mm.y) ? cart_dist_mm.magnitude() : TERN0(HAS_Z_AXIS, ABS(cart_dist_mm.z));
 
     // Cartesian XYZ to kinematic ABC, stored in global 'delta'
     inverse_kinematics(machine);
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
-      // For SCARA scale the feed rate from mm/s to degrees/s
+      // For SCARA scale the feedrate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
       const float duration_recip = inv_duration ?: fr_mm_s / mm;
       const xyz_pos_t diff = delta - position_float;
       const feedRate_t feedrate = diff.magnitude() * duration_recip;
     #else
       const feedRate_t feedrate = fr_mm_s;
     #endif
     TERN_(HAS_EXTRUDERS, delta.e = machine.e);
     if (buffer_segment(delta OPTARG(HAS_DIST_MM_ARG, cart_dist_mm), feedrate, extruder, mm)) {
       position_cart = cart;
       return true;
     }
     return false;
   #else
     return buffer_segment(machine, fr_mm_s, extruder, millimeters);
   #endif
 } // buffer_line()
 
 #if ENABLED(DIRECT_STEPPING)
 
-  /**
-   * @brief Add a direct stepping page block to the buffer
-   *        and wake up the Stepper ISR to process it.
-   *
-   * @param page_idx Page index provided by G6 I<index>
-   * @param extruder The extruder to use in the move
-   * @param num_steps Number of steps to process in the ISR
-   */
   void Planner::buffer_page(const page_idx_t page_idx, const uint8_t extruder, const uint16_t num_steps) {
     if (!last_page_step_rate) {
       kill(GET_TEXT_F(MSG_BAD_PAGE_SPEED));
       return;
     }
 
     uint8_t next_buffer_head;
     block_t * const block = get_next_free_block(next_buffer_head);
 
     block->flag.reset(BLOCK_BIT_PAGE);
@@ -3205,39 +3257,33 @@ void Planner::set_machine_position_mm(const abce_pos_t &abce) {
       LROUND(abce.k * settings.axis_steps_per_mm[K_AXIS]),
       LROUND(abce.u * settings.axis_steps_per_mm[U_AXIS]),
       LROUND(abce.v * settings.axis_steps_per_mm[V_AXIS]),
       LROUND(abce.w * settings.axis_steps_per_mm[W_AXIS])
     )
   );
 
   if (has_blocks_queued()) {
     //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.
     //previous_speed.reset();
-    buffer_sync_block();
+    buffer_sync_block(BLOCK_BIT_SYNC_POSITION);
   }
   else {
     #if ENABLED(BACKLASH_COMPENSATION)
       abce_long_t stepper_pos = position;
       LOOP_NUM_AXES(axis) stepper_pos[axis] += backlash.get_applied_steps((AxisEnum)axis);
       stepper.set_position(stepper_pos);
     #else
       stepper.set_position(position);
     #endif
   }
 }
 
-/**
- * @brief Set the Planner position in mm
- * @details Set the Planner position from a native machine position in mm
- *
- * @param xyze A native (Cartesian) machine position
- */
 void Planner::set_position_mm(const xyze_pos_t &xyze) {
   xyze_pos_t machine = xyze;
   TERN_(HAS_POSITION_MODIFIERS, apply_modifiers(machine, true));
   #if IS_KINEMATIC
     position_cart = xyze;
     inverse_kinematics(machine);
     TERN_(HAS_EXTRUDERS, delta.e = machine.e);
     set_machine_position_mm(delta);
   #else
     set_machine_position_mm(machine);
@@ -3252,48 +3298,42 @@ void Planner::set_position_mm(const xyze_pos_t &xyze) {
   void Planner::set_e_position_mm(const_float_t e) {
     const uint8_t axis_index = E_AXIS_N(active_extruder);
     TERN_(DISTINCT_E_FACTORS, last_extruder = active_extruder);
 
     const float e_new = DIFF_TERN(FWRETRACT, e, fwretract.current_retract[active_extruder]);
     position.e = LROUND(settings.axis_steps_per_mm[axis_index] * e_new);
     TERN_(HAS_POSITION_FLOAT, position_float.e = e_new);
     TERN_(IS_KINEMATIC, TERN_(HAS_EXTRUDERS, position_cart.e = e));
 
     if (has_blocks_queued())
-      buffer_sync_block();
+      buffer_sync_block(BLOCK_BIT_SYNC_POSITION);
     else
       stepper.set_axis_position(E_AXIS, position.e);
   }
 
 #endif
 
-/**
- * @brief Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
- * @details Update planner movement factors after a change to certain settings:
- *          - max_acceleration_steps_per_s2 from settings max_acceleration_mm_per_s2 * axis_steps_per_mm (M201, M92)
- *          - acceleration_long_cutoff based on the largest max_acceleration_steps_per_s2 (M201)
- *          - max_e_jerk for all extruders based on junction_deviation_mm (M205 J)
- */
+// Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::refresh_acceleration_rates() {
   uint32_t highest_rate = 1;
   LOOP_DISTINCT_AXES(i) {
     max_acceleration_steps_per_s2[i] = settings.max_acceleration_mm_per_s2[i] * settings.axis_steps_per_mm[i];
     if (TERN1(DISTINCT_E_FACTORS, i < E_AXIS || i == E_AXIS_N(active_extruder)))
       NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   }
   acceleration_long_cutoff = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
   TERN_(HAS_LINEAR_E_JERK, recalculate_max_e_jerk());
 }
 
 /**
- * @brief Recalculate 'position' and 'mm_per_step'.
- * @details Required whenever settings.axis_steps_per_mm changes!
+ * Recalculate 'position' and 'mm_per_step'.
+ * Must be called whenever settings.axis_steps_per_mm changes!
  */
 void Planner::refresh_positioning() {
   LOOP_DISTINCT_AXES(i) mm_per_step[i] = 1.0f / settings.axis_steps_per_mm[i];
   set_position_mm(current_position);
   refresh_acceleration_rates();
 }
 
 // Apply limits to a variable and give a warning if the value was out of range
 inline void limit_and_warn(float &val, const AxisEnum axis, PGM_P const setting_name, const xyze_float_t &max_limit) {
   const uint8_t lim_axis = TERN_(HAS_EXTRUDERS, axis > E_AXIS ? E_AXIS :) axis;

commit 9c376f120c36687e4bd225c09db9d8c87fcd2a0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 1 20:10:51 2022 -0500

    ü©π Remove obsolete split_move

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 129b9962d3..b80be01dea 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1787,21 +1787,21 @@ bool Planner::_buffer_steps(const xyze_long_t &target
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // If we are cleaning, do not accept queuing of movements
   // This must be after get_next_free_block() because it calls idle()
   // where cleaning_buffer_counter can be changed
   if (cleaning_buffer_counter) return false;
 
   // Fill the block with the specified movement
-  if (!_populate_block(block, false, target
+  if (!_populate_block(block, target
         OPTARG(HAS_POSITION_FLOAT, target_float)
         OPTARG(HAS_DIST_MM_ARG, cart_dist_mm)
         , fr_mm_s, extruder, millimeters
       )
   ) {
     // Movement was not queued, probably because it was too short.
     //  Simply accept that as movement queued and done
     return true;
   }
 
@@ -1819,31 +1819,38 @@ bool Planner::_buffer_steps(const xyze_long_t &target
   block_buffer_head = next_buffer_head;
 
   // Recalculate and optimize trapezoidal speed profiles
   recalculate();
 
   // Movement successfully queued!
   return true;
 }
 
 /**
- * Planner::_populate_block
+ * @brief Populate a block in preparation for insertion
+ * @details Populate the fields of a new linear movement block
+ *          that will be added to the queue and processed soon
+ *          by the Stepper ISR.
  *
- * Fills a new linear movement in the block (in terms of steps).
+ * @param block         A block to populate
+ * @param target        Target position in steps units
+ * @param target_float  Target position in native mm
+ * @param cart_dist_mm  The pre-calculated move lengths for all axes, in mm
+ * @param fr_mm_s       (target) speed of the move
+ * @param extruder      target extruder
+ * @param millimeters   A pre-calculated linear distance for the move, in mm,
+ *                      or 0.0 to have the distance calculated here.
  *
- *  target      - target position in steps units
- *  fr_mm_s     - (target) speed of the move
- *  extruder    - target extruder
- *
- * Returns true if movement is acceptable, false otherwise
+ * @return  true if movement is acceptable, false otherwise
  */
-bool Planner::_populate_block(block_t * const block, bool split_move,
+bool Planner::_populate_block(
+  block_t * const block,
   const abce_long_t &target
   OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
   OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
   , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters/*=0.0*/
 ) {
   int32_t LOGICAL_AXIS_LIST(
     de = target.e - position.e,
     da = target.a - position.a,
     db = target.b - position.b,
     dc = target.c - position.c,
@@ -2842,23 +2849,22 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     #endif
 
   #endif // Classic Jerk Limiting
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed_sqr = vmax_junction_sqr;
 
   // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
   const float v_allowable_sqr = max_allowable_speed_sqr(-block->acceleration, sq(float(MINIMUM_PLANNER_SPEED)), block->millimeters);
 
-  // If we are trying to add a split block, start with the
-  // max. allowed speed to avoid an interrupted first move.
-  block->entry_speed_sqr = !split_move ? sq(float(MINIMUM_PLANNER_SPEED)) : _MIN(vmax_junction_sqr, v_allowable_sqr);
+  // Start with the minimum allowed speed
+  block->entry_speed_sqr = sq(float(MINIMUM_PLANNER_SPEED));
 
   // Initialize planner efficiency flags
   // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
   // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
   // the current block and next block junction speeds are guaranteed to always be at their maximum
   // junction speeds in deceleration and acceleration, respectively. This is due to how the current
   // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
   block->flag.set_nominal(block->nominal_speed_sqr <= v_allowable_sqr);

commit d9ec3795fbfa1c0c6de4774304eaa255794101fd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 29 17:14:23 2022 -0500

    ü©π Fix memset block warning

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c3b1fdd72a..129b9962d3 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2889,21 +2889,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 void Planner::buffer_sync_block(TERN_(LASER_SYNCHRONOUS_M106_M107, const BlockFlagBit sync_flag/*=BLOCK_BIT_SYNC_POSITION*/)) {
   #if DISABLED(LASER_SYNCHRONOUS_M106_M107)
     constexpr BlockFlagBit sync_flag = BLOCK_BIT_SYNC_POSITION;
   #endif
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Clear block
-  memset(block, 0, sizeof(block_t));
+  block->reset();
 
   block->flag.apply(sync_flag);
 
   block->position = position;
   #if ENABLED(BACKLASH_COMPENSATION)
     LOOP_NUM_AXES(axis) block->position[axis] += backlash.get_applied_steps((AxisEnum)axis);
   #endif
 
   #if BOTH(HAS_FAN, LASER_SYNCHRONOUS_M106_M107)
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];

commit 93ffd57383723c48a092e97364b6659c54b5c419
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 26 22:30:05 2022 -0500

    ‚ôªÔ∏è  reset_acceleration_rates => refresh_‚Ä¶

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index d12fa5ed4b..c3b1fdd72a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1550,21 +1550,21 @@ void Planner::check_axes_activity() {
         saved_motion_state.jerk_state = max_jerk;
         max_jerk.set(0, 0 OPTARG(DELTA, 0));
       #endif
     }
     else {
       settings.max_acceleration_mm_per_s2[X_AXIS] = saved_motion_state.acceleration.x;
       settings.max_acceleration_mm_per_s2[Y_AXIS] = saved_motion_state.acceleration.y;
       TERN_(DELTA, settings.max_acceleration_mm_per_s2[Z_AXIS] = saved_motion_state.acceleration.z);
       TERN_(HAS_CLASSIC_JERK, max_jerk = saved_motion_state.jerk_state);
     }
-    reset_acceleration_rates();
+    refresh_acceleration_rates();
   }
 
 #endif
 
 #if HAS_LEVELING
 
   constexpr xy_pos_t level_fulcrum = {
     TERN(Z_SAFE_HOMING, Z_SAFE_HOMING_X_POINT, X_HOME_POS),
     TERN(Z_SAFE_HOMING, Z_SAFE_HOMING_Y_POINT, Y_HOME_POS)
   };
@@ -3260,76 +3260,76 @@ void Planner::set_position_mm(const xyze_pos_t &xyze) {
 
 #endif
 
 /**
  * @brief Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
  * @details Update planner movement factors after a change to certain settings:
  *          - max_acceleration_steps_per_s2 from settings max_acceleration_mm_per_s2 * axis_steps_per_mm (M201, M92)
  *          - acceleration_long_cutoff based on the largest max_acceleration_steps_per_s2 (M201)
  *          - max_e_jerk for all extruders based on junction_deviation_mm (M205 J)
  */
-void Planner::reset_acceleration_rates() {
+void Planner::refresh_acceleration_rates() {
   uint32_t highest_rate = 1;
   LOOP_DISTINCT_AXES(i) {
     max_acceleration_steps_per_s2[i] = settings.max_acceleration_mm_per_s2[i] * settings.axis_steps_per_mm[i];
     if (TERN1(DISTINCT_E_FACTORS, i < E_AXIS || i == E_AXIS_N(active_extruder)))
       NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   }
   acceleration_long_cutoff = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
   TERN_(HAS_LINEAR_E_JERK, recalculate_max_e_jerk());
 }
 
 /**
  * @brief Recalculate 'position' and 'mm_per_step'.
  * @details Required whenever settings.axis_steps_per_mm changes!
  */
 void Planner::refresh_positioning() {
   LOOP_DISTINCT_AXES(i) mm_per_step[i] = 1.0f / settings.axis_steps_per_mm[i];
   set_position_mm(current_position);
-  reset_acceleration_rates();
+  refresh_acceleration_rates();
 }
 
 // Apply limits to a variable and give a warning if the value was out of range
 inline void limit_and_warn(float &val, const AxisEnum axis, PGM_P const setting_name, const xyze_float_t &max_limit) {
   const uint8_t lim_axis = TERN_(HAS_EXTRUDERS, axis > E_AXIS ? E_AXIS :) axis;
   const float before = val;
   LIMIT(val, 0.1, max_limit[lim_axis]);
   if (before != val) {
     SERIAL_CHAR(AXIS_CHAR(lim_axis));
     SERIAL_ECHOPGM(" Max ");
     SERIAL_ECHOPGM_P(setting_name);
     SERIAL_ECHOLNPGM(" limited to ", val);
   }
 }
 
 /**
  * For the specified 'axis' set the Maximum Acceleration to the given value (mm/s^2)
  * The value may be limited with warning feedback, if configured.
- * Calls reset_acceleration_rates to precalculate planner terms in steps.
+ * Calls refresh_acceleration_rates to precalculate planner terms in steps.
  *
  * This hard limit is applied as a block is being added to the planner queue.
  */
 void Planner::set_max_acceleration(const AxisEnum axis, float inMaxAccelMMS2) {
   #if ENABLED(LIMITED_MAX_ACCEL_EDITING)
     #ifdef MAX_ACCEL_EDIT_VALUES
       constexpr xyze_float_t max_accel_edit = MAX_ACCEL_EDIT_VALUES;
       const xyze_float_t &max_acc_edit_scaled = max_accel_edit;
     #else
       constexpr xyze_float_t max_accel_edit = DEFAULT_MAX_ACCELERATION;
       const xyze_float_t max_acc_edit_scaled = max_accel_edit * 2;
     #endif
     limit_and_warn(inMaxAccelMMS2, axis, PSTR("Acceleration"), max_acc_edit_scaled);
   #endif
   settings.max_acceleration_mm_per_s2[axis] = inMaxAccelMMS2;
 
   // Update steps per s2 to agree with the units per s2 (since they are used in the planner)
-  reset_acceleration_rates();
+  refresh_acceleration_rates();
 }
 
 /**
  * For the specified 'axis' set the Maximum Feedrate to the given value (mm/s)
  * The value may be limited with warning feedback, if configured.
  *
  * This hard limit is applied as a block is being added to the planner queue.
  */
 void Planner::set_max_feedrate(const AxisEnum axis, float inMaxFeedrateMMS) {
   #if ENABLED(LIMITED_MAX_FR_EDITING)

commit 307dfb15ca88f424dcb4cf579e4542e77dfb0eaf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 26 22:24:59 2022 -0500

    ‚ôªÔ∏è Planner flags refactor

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 950f11f862..d12fa5ed4b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -732,21 +732,21 @@ block_t* Planner::get_current_block() {
       // If the number of movements queued is less than 3, and there is still time
       //  to wait, do not deliver anything
       if (nr_moves < 3 && delay_before_delivering) return nullptr;
       delay_before_delivering = 0;
     }
 
     // If we are here, there is no excuse to deliver the block
     block_t * const block = &block_buffer[block_buffer_tail];
 
     // No trapezoid calculated? Don't execute yet.
-    if (TEST(block->flag, BLOCK_BIT_RECALCULATE)) return nullptr;
+    if (block->flag.recalculate) return nullptr;
 
     // We can't be sure how long an active block will take, so don't count it.
     TERN_(HAS_WIRED_LCD, block_buffer_runtime_us -= block->segment_time_us);
 
     // As this block is busy, advance the nonbusy block pointer
     block_buffer_nonbusy = next_block_index(block_buffer_tail);
 
     // Push block_buffer_planned pointer, if encountered.
     if (block_buffer_tail == block_buffer_planned)
       block_buffer_planned = block_buffer_nonbusy;
@@ -941,46 +941,46 @@ void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t
 void Planner::reverse_pass_kernel(block_t * const current, const block_t * const next) {
   if (current) {
     // If entry speed is already at the maximum entry speed, and there was no change of speed
     // in the next block, there is no need to recheck. Block is cruising and there is no need to
     // compute anything for this block,
     // If not, block entry speed needs to be recalculated to ensure maximum possible planned speed.
     const float max_entry_speed_sqr = current->max_entry_speed_sqr;
 
     // Compute maximum entry speed decelerating over the current block from its exit speed.
     // If not at the maximum entry speed, or the previous block entry speed changed
-    if (current->entry_speed_sqr != max_entry_speed_sqr || (next && TEST(next->flag, BLOCK_BIT_RECALCULATE))) {
+    if (current->entry_speed_sqr != max_entry_speed_sqr || (next && next->flag.recalculate)) {
 
       // If nominal length true, max junction speed is guaranteed to be reached.
       // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
       // the current block and next block junction speeds are guaranteed to always be at their maximum
       // junction speeds in deceleration and acceleration, respectively. This is due to how the current
       // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
       // the reverse and forward planners, the corresponding block junction speed will always be at the
       // the maximum junction speed and may always be ignored for any speed reduction checks.
 
-      const float new_entry_speed_sqr = TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH)
+      const float new_entry_speed_sqr = current->flag.nominal_length
         ? max_entry_speed_sqr
         : _MIN(max_entry_speed_sqr, max_allowable_speed_sqr(-current->acceleration, next ? next->entry_speed_sqr : sq(float(MINIMUM_PLANNER_SPEED)), current->millimeters));
       if (current->entry_speed_sqr != new_entry_speed_sqr) {
 
         // Need to recalculate the block speed - Mark it now, so the stepper
         // ISR does not consume the block before being recalculated
-        SBI(current->flag, BLOCK_BIT_RECALCULATE);
+        current->flag.recalculate = true;
 
         // But there is an inherent race condition here, as the block may have
         // become BUSY just before being marked RECALCULATE, so check for that!
         if (stepper.is_block_busy(current)) {
           // Block became busy. Clear the RECALCULATE flag (no point in
           // recalculating BUSY blocks). And don't set its speed, as it can't
           // be updated at this time.
-          CBI(current->flag, BLOCK_BIT_RECALCULATE);
+          current->flag.recalculate = false;
         }
         else {
           // Block is not BUSY so this is ahead of the Stepper ISR:
           // Just Set the new entry speed.
           current->entry_speed_sqr = new_entry_speed_sqr;
         }
       }
     }
   }
 }
@@ -1004,22 +1004,22 @@ void Planner::reverse_pass() {
 
   // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
   // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
   // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
   const block_t *next = nullptr;
   while (block_index != planned_block_index) {
 
     // Perform the reverse pass
     block_t *current = &block_buffer[block_index];
 
-    // Only consider non sync-and-page blocks
-    if (!(current->flag & BLOCK_MASK_SYNC) && !IS_PAGE(current)) {
+    // Only process movement blocks
+    if (current->is_move()) {
       reverse_pass_kernel(current, next);
       next = current;
     }
 
     // Advance to the next
     block_index = prev_block_index(block_index);
 
     // The ISR could advance the block_buffer_planned while we were doing the reverse pass.
     // We must try to avoid using an already consumed block as the last one - So follow
     // changes to the pointer and make sure to limit the loop to the currently busy block
@@ -1034,41 +1034,40 @@ void Planner::reverse_pass() {
   }
 }
 
 // The kernel called by recalculate() when scanning the plan from first to last entry.
 void Planner::forward_pass_kernel(const block_t * const previous, block_t * const current, const uint8_t block_index) {
   if (previous) {
     // If the previous block is an acceleration block, too short to complete the full speed
     // change, adjust the entry speed accordingly. Entry speeds have already been reset,
     // maximized, and reverse-planned. If nominal length is set, max junction speed is
     // guaranteed to be reached. No need to recheck.
-    if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH) &&
-      previous->entry_speed_sqr < current->entry_speed_sqr) {
+    if (!previous->flag.nominal_length && previous->entry_speed_sqr < current->entry_speed_sqr) {
 
       // Compute the maximum allowable speed
       const float new_entry_speed_sqr = max_allowable_speed_sqr(-previous->acceleration, previous->entry_speed_sqr, previous->millimeters);
 
       // If true, current block is full-acceleration and we can move the planned pointer forward.
       if (new_entry_speed_sqr < current->entry_speed_sqr) {
 
         // Mark we need to recompute the trapezoidal shape, and do it now,
         // so the stepper ISR does not consume the block before being recalculated
-        SBI(current->flag, BLOCK_BIT_RECALCULATE);
+        current->flag.recalculate = true;
 
         // But there is an inherent race condition here, as the block maybe
         // became BUSY, just before it was marked as RECALCULATE, so check
         // if that is the case!
         if (stepper.is_block_busy(current)) {
           // Block became busy. Clear the RECALCULATE flag (no point in
           //  recalculating BUSY blocks and don't set its speed, as it can't
           //  be updated at this time.
-          CBI(current->flag, BLOCK_BIT_RECALCULATE);
+          current->flag.recalculate = false;
         }
         else {
           // Block is not BUSY, we won the race against the Stepper ISR:
 
           // Always <= max_entry_speed_sqr. Backward pass sets this.
           current->entry_speed_sqr = new_entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass sets this.
 
           // Set optimal plan pointer.
           block_buffer_planned = block_index;
         }
@@ -1099,22 +1098,22 @@ void Planner::forward_pass() {
   //  pass will never modify the values at the tail.
   uint8_t block_index = block_buffer_planned;
 
   block_t *block;
   const block_t * previous = nullptr;
   while (block_index != block_buffer_head) {
 
     // Perform the forward pass
     block = &block_buffer[block_index];
 
-    // Skip SYNC and page blocks
-    if (!(block->flag & BLOCK_MASK_SYNC) && !IS_PAGE(block)) {
+    // Only process movement blocks
+    if (block->is_move()) {
       // If there's no previous block or the previous block is not
       // BUSY (thus, modifiable) run the forward_pass_kernel. Otherwise,
       // the previous block became BUSY, so assume the current block's
       // entry speed can't be altered (since that would also require
       // updating the exit speed of the previous block).
       if (!previous || !stepper.is_block_busy(previous))
         forward_pass_kernel(previous, block, block_index);
       previous = block;
     }
     // Advance to the previous
@@ -1124,57 +1123,57 @@ void Planner::forward_pass() {
 
 /**
  * Recalculate the trapezoid speed profiles for all blocks in the plan
  * according to the entry_factor for each junction. Must be called by
  * recalculate() after updating the blocks.
  */
 void Planner::recalculate_trapezoids() {
   // The tail may be changed by the ISR so get a local copy.
   uint8_t block_index = block_buffer_tail,
           head_block_index = block_buffer_head;
-  // Since there could be a sync block in the head of the queue, and the
+
+  // Since there could be non-move blocks in the head of the queue, and the
   // next loop must not recalculate the head block (as it needs to be
-  // specially handled), scan backwards to the first non-SYNC block.
+  // specially handled), scan backwards to the first move block.
   while (head_block_index != block_index) {
 
     // Go back (head always point to the first free block)
     const uint8_t prev_index = prev_block_index(head_block_index);
 
     // Get the pointer to the block
     block_t *prev = &block_buffer[prev_index];
 
-    // If not dealing with a sync block, we are done. The last block is not a SYNC block
-    if (!(prev->flag & BLOCK_MASK_SYNC)) break;
+    // It the block is a move, we're done with this loop
+    if (prev->is_move()) break;
 
     // Examine the previous block. This and all following are SYNC blocks
     head_block_index = prev_index;
   }
 
   // Go from the tail (currently executed block) to the first block, without including it)
   block_t *block = nullptr, *next = nullptr;
   float current_entry_speed = 0.0, next_entry_speed = 0.0;
   while (block_index != head_block_index) {
 
     next = &block_buffer[block_index];
 
-    // Skip sync and page blocks
-    if (!(next->flag & BLOCK_MASK_SYNC) && !IS_PAGE(next)) {
+    // Only process movement blocks
+    if (next->is_move()) {
       next_entry_speed = SQRT(next->entry_speed_sqr);
 
       if (block) {
-        // Recalculate if current block entry or exit junction speed has changed.
-        if (TEST(block->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
 
-          // Mark the current block as RECALCULATE, to protect it from the Stepper ISR running it.
-          // Note that due to the above condition, there's a chance the current block isn't marked as
-          // RECALCULATE yet, but the next one is. That's the reason for the following line.
-          SBI(block->flag, BLOCK_BIT_RECALCULATE);
+        // If the next block is marked to RECALCULATE, also mark the previously-fetched one
+        if (next->flag.recalculate) block->flag.recalculate = true;
+
+        // Recalculate if current block entry or exit junction speed has changed.
+        if (block->flag.recalculate) {
 
           // But there is an inherent race condition here, as the block maybe
           // became BUSY, just before it was marked as RECALCULATE, so check
           // if that is the case!
           if (!stepper.is_block_busy(block)) {
             // Block is not BUSY, we won the race against the Stepper ISR:
 
             // NOTE: Entry and exit factors always > 0 by all previous logic operations.
             const float current_nominal_speed = SQRT(block->nominal_speed_sqr),
                         nomr = 1.0f / current_nominal_speed;
@@ -1183,38 +1182,38 @@ void Planner::recalculate_trapezoids() {
               if (block->use_advance_lead) {
                 const float comp = block->e_D_ratio * extruder_advance_K[active_extruder] * settings.axis_steps_per_mm[E_AXIS];
                 block->max_adv_steps = current_nominal_speed * comp;
                 block->final_adv_steps = next_entry_speed * comp;
               }
             #endif
           }
 
           // Reset current only to ensure next trapezoid is computed - The
           // stepper is free to use the block from now on.
-          CBI(block->flag, BLOCK_BIT_RECALCULATE);
+          block->flag.recalculate = false;
         }
       }
 
       block = next;
       current_entry_speed = next_entry_speed;
     }
 
     block_index = next_block_index(block_index);
   }
 
   // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
   if (next) {
 
-    // Mark the next(last) block as RECALCULATE, to prevent the Stepper ISR running it.
+    // Mark the last block as RECALCULATE, to prevent the Stepper ISR running it.
     // As the last block is always recalculated here, there is a chance the block isn't
     // marked as RECALCULATE yet. That's the reason for the following line.
-    SBI(next->flag, BLOCK_BIT_RECALCULATE);
+    block->flag.recalculate = true;
 
     // But there is an inherent race condition here, as the block maybe
     // became BUSY, just before it was marked as RECALCULATE, so check
     // if that is the case!
     if (!stepper.is_block_busy(block)) {
       // Block is not BUSY, we won the race against the Stepper ISR:
 
       const float next_nominal_speed = SQRT(next->nominal_speed_sqr),
                   nomr = 1.0f / next_nominal_speed;
       calculate_trapezoid_for_block(next, next_entry_speed * nomr, float(MINIMUM_PLANNER_SPEED) * nomr);
@@ -1222,21 +1221,21 @@ void Planner::recalculate_trapezoids() {
         if (next->use_advance_lead) {
           const float comp = next->e_D_ratio * extruder_advance_K[active_extruder] * settings.axis_steps_per_mm[E_AXIS];
           next->max_adv_steps = next_nominal_speed * comp;
           next->final_adv_steps = (MINIMUM_PLANNER_SPEED) * comp;
         }
       #endif
     }
 
     // Reset next only to ensure its trapezoid is computed - The stepper is free to use
     // the block from now on.
-    CBI(next->flag, BLOCK_BIT_RECALCULATE);
+    next->flag.recalculate = false;
   }
 }
 
 void Planner::recalculate() {
   // Initialize block index to the last block in the planner buffer.
   const uint8_t block_index = prev_block_index(block_buffer_head);
   // If there is just one block, no planning can be done. Avoid it!
   if (block_index != block_buffer_planned) {
     reverse_pass();
     forward_pass();
@@ -1453,21 +1452,21 @@ void Planner::check_axes_activity() {
   void Planner::autotemp_task() {
     static float oldt = 0.0f;
 
     if (!autotemp_enabled) return;
     if (thermalManager.degTargetHotend(active_extruder) < autotemp_min - 2) return; // Below the min?
 
     float high = 0.0f;
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       const block_t * const block = &block_buffer[b];
       if (NUM_AXIS_GANG(block->steps.x, || block->steps.y, || block->steps.z, || block->steps.i, || block->steps.j, || block->steps.k, || block->steps.u, || block->steps.v, || block->steps.w)) {
-        const float se = (float)block->steps.e / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;
+        const float se = (float)block->steps.e / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec
         NOLESS(high, se);
       }
     }
 
     float t = autotemp_min + high * autotemp_factor;
     LIMIT(t, autotemp_min, autotemp_max);
     if (t < oldt) t = t * (1.0f - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
     oldt = t;
     thermalManager.setTargetHotend(t, active_extruder);
   }
@@ -1775,38 +1774,39 @@ void Planner::synchronize() { while (busy()) idle(); }
  *  target_float  - target position in direct (mm, degrees) units. optional
  *  fr_mm_s       - (target) speed of the move
  *  extruder      - target extruder
  *  millimeters   - the length of the movement, if known
  *
  * Returns true if movement was properly queued, false otherwise (if cleaning)
  */
 bool Planner::_buffer_steps(const xyze_long_t &target
   OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
   OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
-  , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters
+  , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters/*=0.0*/
 ) {
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // If we are cleaning, do not accept queuing of movements
   // This must be after get_next_free_block() because it calls idle()
   // where cleaning_buffer_counter can be changed
   if (cleaning_buffer_counter) return false;
 
   // Fill the block with the specified movement
   if (!_populate_block(block, false, target
-    OPTARG(HAS_POSITION_FLOAT, target_float)
-    OPTARG(HAS_DIST_MM_ARG, cart_dist_mm)
-    , fr_mm_s, extruder, millimeters
-  )) {
+        OPTARG(HAS_POSITION_FLOAT, target_float)
+        OPTARG(HAS_DIST_MM_ARG, cart_dist_mm)
+        , fr_mm_s, extruder, millimeters
+      )
+  ) {
     // Movement was not queued, probably because it was too short.
     //  Simply accept that as movement queued and done
     return true;
   }
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
     // give the planner an opportunity to queue more movements and plan them
     // As there are no queued movements, the Stepper ISR will not touch this
@@ -1849,50 +1849,22 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     dc = target.c - position.c,
     di = target.i - position.i,
     dj = target.j - position.j,
     dk = target.k - position.k,
     du = target.u - position.u,
     dv = target.v - position.v,
     dw = target.w - position.w
   );
 
   /* <-- add a slash to enable
-    SERIAL_ECHOLNPGM(
-      "  _populate_block FR:", fr_mm_s,
-      " A:", target.a, " (", da, " steps)"
-      #if HAS_Y_AXIS
-        " B:", target.b, " (", db, " steps)"
-      #endif
-      #if HAS_Z_AXIS
-        " C:", target.c, " (", dc, " steps)"
-      #endif
-      #if HAS_I_AXIS
-        " " STR_I ":", target.i, " (", di, " steps)"
-      #endif
-      #if HAS_J_AXIS
-        " " STR_J ":", target.j, " (", dj, " steps)"
-      #endif
-      #if HAS_K_AXIS
-        " " STR_K ":", target.k, " (", dk, " steps)"
-      #endif
-      #if HAS_U_AXIS
-        " " STR_U ":", target.u, " (", du, " steps)"
-      #endif
-      #if HAS_V_AXIS
-        " " STR_V ":", target.v, " (", dv, " steps)"
-      #endif
-      #if HAS_W_AXIS
-        " " STR_W ":", target.w, " (", dw, " steps)"
-      #if HAS_EXTRUDERS
-        " E:", target.e, " (", de, " steps)"
-      #endif
-    );
+    #define _ALINE(A) " " STR_##A  ":", target[_AXIS(A)], " (", int32_t(target[_AXIS(A)] - position[_AXIS(A)]), " steps)"
+    SERIAL_ECHOLNPGM("  _populate_block FR:", fr_mm_s, LOGICAL_AXIS_MAP(_ALINE));
   //*/
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position.e = target.e; // Behave as if the move really took place, but ignore E part
           TERN_(HAS_POSITION_FLOAT, position_float.e = target_float.e);
           de = 0; // no difference
           SERIAL_ECHO_MSG(STR_ERR_COLD_EXTRUDE_STOP);
@@ -1971,21 +1943,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   #if HAS_EXTRUDERS
     if (de < 0) SBI(dm, E_AXIS);
     const float esteps_float = de * e_factor[extruder];
     const uint32_t esteps = ABS(esteps_float) + 0.5f;
   #else
     constexpr uint32_t esteps = 0;
   #endif
 
   // Clear all flags, including the "busy" bit
-  block->flag = 0x00;
+  block->flag.clear();
 
   // Set direction bits
   block->direction_bits = dm;
 
   // Update block laser power
   #if ENABLED(LASER_POWER_INLINE)
     laser_inline.status.isPlanned = true;
     block->laser.status = laser_inline.status;
     block->laser.power = laser_inline.power;
   #endif
@@ -2442,21 +2414,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         }
       }
     }
 
   #endif // XY_FREQUENCY_LIMIT
 
   // Correct the speed
   if (speed_factor < 1.0f) {
     current_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
-    block->nominal_speed_sqr = block->nominal_speed_sqr * sq(speed_factor);
+    block->nominal_speed_sqr *= sq(speed_factor);
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
   if (NUM_AXIS_GANG(
          !block->steps.a, && !block->steps.b, && !block->steps.c,
       && !block->steps.i, && !block->steps.j, && !block->steps.k,
       && !block->steps.u, && !block->steps.v, && !block->steps.w)
   ) {                                                             // Is this a retract / recover move?
@@ -2644,28 +2616,29 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
                                  + (-prev_unit_vec.v * unit_vec.v),
                                  + (-prev_unit_vec.w * unit_vec.w)
                                );
 
       // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
       if (junction_cos_theta > 0.999999f) {
         // For a 0 degree acute junction, just set minimum junction speed.
         vmax_junction_sqr = sq(float(MINIMUM_PLANNER_SPEED));
       }
       else {
-        NOLESS(junction_cos_theta, -0.999999f); // Check for numerical round-off to avoid divide by zero.
-
         // Convert delta vector to unit vector
         xyze_float_t junction_unit_vec = unit_vec - prev_unit_vec;
         normalize_junction_vector(junction_unit_vec);
 
-        const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec),
-                    sin_theta_d2 = SQRT(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
+        const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec);
+
+        NOLESS(junction_cos_theta, -0.999999f); // Check for numerical round-off to avoid divide by zero.
+
+        const float sin_theta_d2 = SQRT(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
 
         vmax_junction_sqr = junction_acceleration * junction_deviation_mm * sin_theta_d2 / (1.0f - sin_theta_d2);
 
         #if ENABLED(JD_HANDLE_SMALL_SEGMENTS)
 
           // For small moves with >135¬∞ junction (octagon) find speed for approximate arc
           if (block->millimeters < 1 && junction_cos_theta < -0.7071067812f) {
 
             #if ENABLED(JD_USE_MATH_ACOS)
 
@@ -2881,21 +2854,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   block->entry_speed_sqr = !split_move ? sq(float(MINIMUM_PLANNER_SPEED)) : _MIN(vmax_junction_sqr, v_allowable_sqr);
 
   // Initialize planner efficiency flags
   // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
   // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
   // the current block and next block junction speeds are guaranteed to always be at their maximum
   // junction speeds in deceleration and acceleration, respectively. This is due to how the current
   // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
-  block->flag |= block->nominal_speed_sqr <= v_allowable_sqr ? BLOCK_FLAG_RECALCULATE | BLOCK_FLAG_NOMINAL_LENGTH : BLOCK_FLAG_RECALCULATE;
+  block->flag.set_nominal(block->nominal_speed_sqr <= v_allowable_sqr);
 
   // Update previous path unit_vector and nominal speed
   previous_speed = current_speed;
   previous_nominal_speed_sqr = block->nominal_speed_sqr;
 
   position = target;  // Update the position
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     block->sdpos = recovery.command_sdpos();
     block->start_position = position_float.asLogical();
@@ -2906,33 +2879,33 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   return true;        // Movement was accepted
 
 } // _populate_block()
 
 /**
  * Planner::buffer_sync_block
  * Add a block to the buffer that just updates the position,
  * or in case of LASER_SYNCHRONOUS_M106_M107 the fan PWM
  */
-void Planner::buffer_sync_block(TERN_(LASER_SYNCHRONOUS_M106_M107, uint8_t sync_flag)) {
+void Planner::buffer_sync_block(TERN_(LASER_SYNCHRONOUS_M106_M107, const BlockFlagBit sync_flag/*=BLOCK_BIT_SYNC_POSITION*/)) {
   #if DISABLED(LASER_SYNCHRONOUS_M106_M107)
-    constexpr uint8_t sync_flag = BLOCK_FLAG_SYNC_POSITION;
+    constexpr BlockFlagBit sync_flag = BLOCK_BIT_SYNC_POSITION;
   #endif
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Clear block
   memset(block, 0, sizeof(block_t));
 
-  block->flag = sync_flag;
+  block->flag.apply(sync_flag);
 
   block->position = position;
   #if ENABLED(BACKLASH_COMPENSATION)
     LOOP_NUM_AXES(axis) block->position[axis] += backlash.get_applied_steps((AxisEnum)axis);
   #endif
 
   #if BOTH(HAS_FAN, LASER_SYNCHRONOUS_M106_M107)
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
@@ -3066,22 +3039,22 @@ bool Planner::buffer_segment(const abce_pos_t &abce
       SERIAL_ECHOLNPGM(" (", position.e, "->", target.e, ")");
     #else
       SERIAL_EOL();
     #endif
   //*/
 
   // Queue the movement. Return 'false' if the move was not queued.
   if (!_buffer_steps(target
       OPTARG(HAS_POSITION_FLOAT, target_float)
       OPTARG(HAS_DIST_MM_ARG, cart_dist_mm)
-      , fr_mm_s, extruder, millimeters)
-  ) return false;
+      , fr_mm_s, extruder, millimeters
+  )) return false;
 
   stepper.wake_up();
   return true;
 } // buffer_segment()
 
 /**
  * Add a new linear movement to the buffer.
  * The target is cartesian. It's translated to
  * delta/scara if needed.
  *
@@ -3134,30 +3107,38 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s, cons
       return true;
     }
     return false;
   #else
     return buffer_segment(machine, fr_mm_s, extruder, millimeters);
   #endif
 } // buffer_line()
 
 #if ENABLED(DIRECT_STEPPING)
 
+  /**
+   * @brief Add a direct stepping page block to the buffer
+   *        and wake up the Stepper ISR to process it.
+   *
+   * @param page_idx Page index provided by G6 I<index>
+   * @param extruder The extruder to use in the move
+   * @param num_steps Number of steps to process in the ISR
+   */
   void Planner::buffer_page(const page_idx_t page_idx, const uint8_t extruder, const uint16_t num_steps) {
     if (!last_page_step_rate) {
       kill(GET_TEXT_F(MSG_BAD_PAGE_SPEED));
       return;
     }
 
     uint8_t next_buffer_head;
     block_t * const block = get_next_free_block(next_buffer_head);
 
-    block->flag = BLOCK_FLAG_IS_PAGE;
+    block->flag.reset(BLOCK_BIT_PAGE);
 
     #if HAS_FAN
       FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
     #endif
 
     E_TERN_(block->extruder = extruder);
 
     block->page_idx = page_idx;
 
     block->step_event_count = num_steps;
@@ -3231,20 +3212,26 @@ void Planner::set_machine_position_mm(const abce_pos_t &abce) {
     #if ENABLED(BACKLASH_COMPENSATION)
       abce_long_t stepper_pos = position;
       LOOP_NUM_AXES(axis) stepper_pos[axis] += backlash.get_applied_steps((AxisEnum)axis);
       stepper.set_position(stepper_pos);
     #else
       stepper.set_position(position);
     #endif
   }
 }
 
+/**
+ * @brief Set the Planner position in mm
+ * @details Set the Planner position from a native machine position in mm
+ *
+ * @param xyze A native (Cartesian) machine position
+ */
 void Planner::set_position_mm(const xyze_pos_t &xyze) {
   xyze_pos_t machine = xyze;
   TERN_(HAS_POSITION_MODIFIERS, apply_modifiers(machine, true));
   #if IS_KINEMATIC
     position_cart = xyze;
     inverse_kinematics(machine);
     TERN_(HAS_EXTRUDERS, delta.e = machine.e);
     set_machine_position_mm(delta);
   #else
     set_machine_position_mm(machine);
@@ -3266,35 +3253,41 @@ void Planner::set_position_mm(const xyze_pos_t &xyze) {
     TERN_(IS_KINEMATIC, TERN_(HAS_EXTRUDERS, position_cart.e = e));
 
     if (has_blocks_queued())
       buffer_sync_block();
     else
       stepper.set_axis_position(E_AXIS, position.e);
   }
 
 #endif
 
-// Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
+/**
+ * @brief Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
+ * @details Update planner movement factors after a change to certain settings:
+ *          - max_acceleration_steps_per_s2 from settings max_acceleration_mm_per_s2 * axis_steps_per_mm (M201, M92)
+ *          - acceleration_long_cutoff based on the largest max_acceleration_steps_per_s2 (M201)
+ *          - max_e_jerk for all extruders based on junction_deviation_mm (M205 J)
+ */
 void Planner::reset_acceleration_rates() {
   uint32_t highest_rate = 1;
   LOOP_DISTINCT_AXES(i) {
     max_acceleration_steps_per_s2[i] = settings.max_acceleration_mm_per_s2[i] * settings.axis_steps_per_mm[i];
     if (TERN1(DISTINCT_E_FACTORS, i < E_AXIS || i == E_AXIS_N(active_extruder)))
       NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   }
   acceleration_long_cutoff = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
   TERN_(HAS_LINEAR_E_JERK, recalculate_max_e_jerk());
 }
 
 /**
- * Recalculate 'position' and 'mm_per_step'.
- * Must be called whenever settings.axis_steps_per_mm changes!
+ * @brief Recalculate 'position' and 'mm_per_step'.
+ * @details Required whenever settings.axis_steps_per_mm changes!
  */
 void Planner::refresh_positioning() {
   LOOP_DISTINCT_AXES(i) mm_per_step[i] = 1.0f / settings.axis_steps_per_mm[i];
   set_position_mm(current_position);
   reset_acceleration_rates();
 }
 
 // Apply limits to a variable and give a warning if the value was out of range
 inline void limit_and_warn(float &val, const AxisEnum axis, PGM_P const setting_name, const xyze_float_t &max_limit) {
   const uint8_t lim_axis = TERN_(HAS_EXTRUDERS, axis > E_AXIS ? E_AXIS :) axis;

commit 6cbd7a48d16789fd73ab6ebe4be00bc2beff5591
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 20 21:15:57 2022 -0500

    üé® Fix comments, formatting

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 6aa363890e..950f11f862 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2042,23 +2042,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       steps_dist_mm.c      = CORESIGN(da - dc) * mm_per_step[C_AXIS];
     #elif CORE_IS_YZ
       steps_dist_mm.x      = da * mm_per_step[X_AXIS];
       steps_dist_mm.head.y = db * mm_per_step[B_AXIS];
       steps_dist_mm.head.z = dc * mm_per_step[C_AXIS];
       steps_dist_mm.b      = (db + dc) * mm_per_step[B_AXIS];
       steps_dist_mm.c      = CORESIGN(db - dc) * mm_per_step[C_AXIS];
     #endif
   #elif ENABLED(MARKFORGED_XY)
     steps_dist_mm.a      = (da - db) * mm_per_step[A_AXIS];
-    steps_dist_mm.b      = db * mm_per_step[B_AXIS];
+    steps_dist_mm.b      =       db  * mm_per_step[B_AXIS];
   #elif ENABLED(MARKFORGED_YX)
-    steps_dist_mm.a      = da * mm_per_step[A_AXIS];
+    steps_dist_mm.a      =       da  * mm_per_step[A_AXIS];
     steps_dist_mm.b      = (db - da) * mm_per_step[B_AXIS];
   #else
     XYZ_CODE(
       steps_dist_mm.a = da * mm_per_step[A_AXIS],
       steps_dist_mm.b = db * mm_per_step[B_AXIS],
       steps_dist_mm.c = dc * mm_per_step[C_AXIS]
     );
   #endif
 
   SECONDARY_AXIS_CODE(
@@ -2090,56 +2090,66 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       && block->steps.w < MIN_STEPS_PER_SEGMENT
     )
   ) {
     block->millimeters = TERN0(HAS_EXTRUDERS, ABS(steps_dist_mm.e));
   }
   else {
     if (millimeters)
       block->millimeters = millimeters;
     else {
       /**
-       * Distance for interpretation of feedrate in accordance with LinuxCNC (the successor of NIST
-       * RS274NGC interpreter - version 3) and its default CANON_XYZ feed reference mode.
-       * Assume that X, Y, Z are the primary linear axes and U, V, W are secondary linear axes and A, B, C are
-       * rotational axes. Then dX, dY, dZ are the displacements of the primary linear axes and dU, dV, dW are the displacements of linear axes and
-       * dA, dB, dC are the displacements of rotational axes.
-       * The time it takes to execute move command with feedrate F is t = D/F, where D is the total distance, calculated as follows:
+       * Distance for interpretation of feedrate in accordance with LinuxCNC (the successor of
+       * NIST RS274NGC interpreter - version 3) and its default CANON_XYZ feed reference mode.
+       *
+       * Assume:
+       *   - X, Y, Z are the primary linear axes;
+       *   - U, V, W are secondary linear axes;
+       *   - A, B, C are rotational axes.
+       *
+       * Then:
+       *   - dX, dY, dZ are the displacements of the primary linear axes;
+       *   - dU, dV, dW are the displacements of linear axes;
+       *   - dA, dB, dC are the displacements of rotational axes.
+       *
+       * The time it takes to execute move command with feedrate F is t = D/F,
+       * where D is the total distance, calculated as follows:
        *   D^2 = dX^2 + dY^2 + dZ^2
        *   if D^2 == 0 (none of XYZ move but any secondary linear axes move, whether other axes are moved or not):
        *     D^2 = dU^2 + dV^2 + dW^2
        *   if D^2 == 0 (only rotational axes are moved):
        *     D^2 = dA^2 + dB^2 + dC^2
        */
       float distance_sqr = (
         #if ENABLED(ARTICULATED_ROBOT_ARM)
-          // For articulated robots, interpreting feedrate like LinuxCNC would require inverse kinematics. As a workaround, pretend that motors sit on n mutually orthogonal
-          // axes and assume that we could think of distance as magnitude of an n-vector in an n-dimensional Euclidian space.
+          // For articulated robots, interpreting feedrate like LinuxCNC would require inverse kinematics. As a workaround,
+          // assume that motors sit on a mutually-orthogonal axes and we can think of distance as magnitude of an n-vector
+          // in an n-dimensional Euclidian space.
           NUM_AXIS_GANG(
               sq(steps_dist_mm.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.z),
             + sq(steps_dist_mm.i), + sq(steps_dist_mm.j), + sq(steps_dist_mm.k),
             + sq(steps_dist_mm.u), + sq(steps_dist_mm.v), + sq(steps_dist_mm.w)
           );
         #elif ENABLED(FOAMCUTTER_XYUV)
           #if HAS_J_AXIS
-          // Special 5 axis kinematics. Return the largest distance move from either X/Y or I/J plane
-          _MAX(sq(steps_dist_mm.x) + sq(steps_dist_mm.y), sq(steps_dist_mm.i) + sq(steps_dist_mm.j))
+            // Special 5 axis kinematics. Return the largest distance move from either X/Y or I/J plane
+            _MAX(sq(steps_dist_mm.x) + sq(steps_dist_mm.y), sq(steps_dist_mm.i) + sq(steps_dist_mm.j))
           #else // Foamcutter with only two axes (XY)
             sq(steps_dist_mm.x) + sq(steps_dist_mm.y)
           #endif
         #elif ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
           XYZ_GANG(sq(steps_dist_mm.head.x), + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.z))
         #elif CORE_IS_XZ
           XYZ_GANG(sq(steps_dist_mm.head.x), + sq(steps_dist_mm.y),      + sq(steps_dist_mm.head.z))
         #elif CORE_IS_YZ
           XYZ_GANG(sq(steps_dist_mm.x),      + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.head.z))
         #else
-          XYZ_GANG(sq(steps_dist_mm.x),       + sq(steps_dist_mm.y),      + sq(steps_dist_mm.z))
+          XYZ_GANG(sq(steps_dist_mm.x),      + sq(steps_dist_mm.y),      + sq(steps_dist_mm.z))
         #endif
       );
 
       #if SECONDARY_LINEAR_AXES >= 1 && NONE(FOAMCUTTER_XYUV, ARTICULATED_ROBOT_ARM)
         if (NEAR_ZERO(distance_sqr)) {
           // Move does not involve any primary linear axes (xyz) but might involve secondary linear axes
           distance_sqr = (0.0
             SECONDARY_AXIS_GANG(
               IF_DISABLED(AXIS4_ROTATES, + sq(steps_dist_mm.i)),
               IF_DISABLED(AXIS5_ROTATES, + sq(steps_dist_mm.j)),
@@ -2158,23 +2168,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           TERN_(INCH_MODE_SUPPORT, cartesian_move = false);
           distance_sqr = ROTATIONAL_AXIS_GANG(sq(steps_dist_mm.i), + sq(steps_dist_mm.j), + sq(steps_dist_mm.k), + sq(steps_dist_mm.u), + sq(steps_dist_mm.v), + sq(steps_dist_mm.w));
         }
       #endif
 
       block->millimeters = SQRT(distance_sqr);
     }
 
     /**
      * At this point at least one of the axes has more steps than
-     * MIN_STEPS_PER_SEGMENT, ensuring the segment won't get dropped as
-     * zero-length. It's important to not apply corrections
-     * to blocks that would get dropped!
+     * MIN_STEPS_PER_SEGMENT, ensuring the segment won't get dropped
+     * as zero-length. It's important to not apply corrections to blocks
+     * that would get dropped!
      *
      * A correction function is permitted to add steps to an axis, it
      * should *never* remove steps!
      */
     TERN_(BACKLASH_COMPENSATION, backlash.add_correction_steps(da, db, dc, dm, block));
   }
 
   TERN_(HAS_EXTRUDERS, block->steps.e = esteps);
 
   block->step_event_count = _MAX(LOGICAL_AXIS_LIST(esteps,
@@ -2196,29 +2206,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
   E_TERN_(block->extruder = extruder);
 
   #if ENABLED(AUTO_POWER_CONTROL)
     if (NUM_AXIS_GANG(
-         block->steps.x,
-      || block->steps.y,
-      || block->steps.z,
-      || block->steps.i,
-      || block->steps.j,
-      || block->steps.k,
-      || block->steps.u,
-      || block->steps.v,
-      || block->steps.w
+         block->steps.x, || block->steps.y, || block->steps.z,
+      || block->steps.i, || block->steps.j, || block->steps.k,
+      || block->steps.u, || block->steps.v, || block->steps.w
     )) powerManager.power_on();
   #endif
 
   // Enable active axes
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
     if (block->steps.a || block->steps.b) {
       stepper.enable_axis(X_AXIS);
       stepper.enable_axis(Y_AXIS);
     }
     #if DISABLED(Z_LATE_ENABLE)

commit 41f73cb457116ed9646932eb505b5e9fbe29e77d
Author: lujios <83166168+lujios@users.noreply.github.com>
Date:   Fri Jun 3 07:19:25 2022 +0200

    ‚ö°Ô∏è Improve Sensorless homing/probing accuracy for G28, G33, M48 (#24220)
    
    Co-authored-by: Robby Candra <robbycandra.mail@gmail.com>
    Co-authored-by: ellensp <530024+ellensp@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e11a760902..6aa363890e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1656,24 +1656,21 @@ void Planner::quick_stop() {
 
   const bool was_enabled = stepper.suspend();
 
   // Drop all queue entries
   block_buffer_nonbusy = block_buffer_planned = block_buffer_head = block_buffer_tail;
 
   // Restart the block delay for the first movement - As the queue was
   // forced to empty, there's no risk the ISR will touch this.
   delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
 
-  #if HAS_WIRED_LCD
-    // Clear the accumulated runtime
-    clear_block_buffer_runtime();
-  #endif
+  TERN_(HAS_WIRED_LCD, clear_block_buffer_runtime()); // Clear the accumulated runtime
 
   // Make sure to drop any attempt of queuing moves for 1 second
   cleaning_buffer_counter = TEMP_TIMER_FREQUENCY;
 
   // Reenable Stepper ISR
   if (was_enabled) stepper.wake_up();
 
   // And stop the stepper ISR
   stepper.quick_stop();
 }

commit 62057d3204c727fdf5c2c5e9f112e0c597e60924
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Thu May 19 22:15:15 2022 +0100

    üêõ Fix Leveling apply/unapply (#24188)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 3a65c9591b..e11a760902 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1591,44 +1591,48 @@ void Planner::check_axes_activity() {
       #else
         raw.z += bedlevel.get_z_correction(raw);
       #endif
 
       TERN_(MESH_BED_LEVELING, raw.z += bedlevel.get_z_offset());
 
     #endif
   }
 
   void Planner::unapply_leveling(xyz_pos_t &raw) {
+    if (!leveling_active) return;
 
-    if (leveling_active) {
-
-      #if ABL_PLANAR
-
-        matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
+    #if ABL_PLANAR
 
-        xy_pos_t d = raw - level_fulcrum;
-        inverse.apply_rotation_xyz(d.x, d.y, raw.z);
-        raw = d + level_fulcrum;
+      matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
 
-      #elif HAS_MESH
+      xy_pos_t d = raw - level_fulcrum;
+      inverse.apply_rotation_xyz(d.x, d.y, raw.z);
+      raw = d + level_fulcrum;
 
-        TERN_(MESH_BED_LEVELING, raw.z -= bedlevel.get_z_offset());
+    #elif HAS_MESH
 
-        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-          const float fade_scaling_factor = fade_scaling_factor_for_z(raw.z);
-          if (fade_scaling_factor) raw.z -= fade_scaling_factor * bedlevel.get_z_correction(raw);
-        #else
-          raw.z -= bedlevel.get_z_correction(raw);
-        #endif
+      const float z_correction = bedlevel.get_z_correction(raw),
+                  z_full_fade = DIFF_TERN(MESH_BED_LEVELING, raw.z, bedlevel.get_z_offset()),
+                  z_no_fade = z_full_fade - z_correction;
 
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        if (!z_fade_height || z_no_fade <= 0.0f)                              // Not fading or at bed level?
+          raw.z = z_no_fade;                                                  //  Unapply full mesh Z.
+        else if (z_full_fade >= z_fade_height)                                // Above the fade height?
+          raw.z = z_full_fade;                                                //  Nothing more to unapply.
+        else                                                                  // Within the fade zone?
+          raw.z = z_no_fade / (1.0f - z_correction * inverse_z_fade_height);  // Unapply the faded Z offset
+      #else
+        raw.z = z_no_fade;
       #endif
-    }
+
+    #endif
   }
 
 #endif // HAS_LEVELING
 
 #if ENABLED(FWRETRACT)
   /**
    * rz, e - Cartesian positions in mm
    */
   void Planner::apply_retract(float &rz, float &e) {
     rz += fwretract.current_hop;

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ‚ôªÔ∏è Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 90424b55ee..3a65c9591b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1580,67 +1580,53 @@ void Planner::check_axes_activity() {
     #if ABL_PLANAR
 
       xy_pos_t d = raw - level_fulcrum;
       bed_level_matrix.apply_rotation_xyz(d.x, d.y, raw.z);
       raw = d + level_fulcrum;
 
     #elif HAS_MESH
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         const float fade_scaling_factor = fade_scaling_factor_for_z(raw.z);
-      #elif DISABLED(MESH_BED_LEVELING)
-        constexpr float fade_scaling_factor = 1.0;
+        if (fade_scaling_factor) raw.z += fade_scaling_factor * bedlevel.get_z_correction(raw);
+      #else
+        raw.z += bedlevel.get_z_correction(raw);
       #endif
 
-      raw.z += (
-        #if ENABLED(MESH_BED_LEVELING)
-          mbl.get_z(raw OPTARG(ENABLE_LEVELING_FADE_HEIGHT, fade_scaling_factor))
-        #elif ENABLED(AUTO_BED_LEVELING_UBL)
-          fade_scaling_factor ? fade_scaling_factor * ubl.get_z_correction(raw) : 0.0
-        #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-          fade_scaling_factor ? fade_scaling_factor * bbl.get_z_correction(raw) : 0.0
-        #endif
-      );
+      TERN_(MESH_BED_LEVELING, raw.z += bedlevel.get_z_offset());
 
     #endif
   }
 
   void Planner::unapply_leveling(xyz_pos_t &raw) {
 
     if (leveling_active) {
 
       #if ABL_PLANAR
 
         matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
 
         xy_pos_t d = raw - level_fulcrum;
         inverse.apply_rotation_xyz(d.x, d.y, raw.z);
         raw = d + level_fulcrum;
 
       #elif HAS_MESH
 
+        TERN_(MESH_BED_LEVELING, raw.z -= bedlevel.get_z_offset());
+
         #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
           const float fade_scaling_factor = fade_scaling_factor_for_z(raw.z);
-        #elif DISABLED(MESH_BED_LEVELING)
-          constexpr float fade_scaling_factor = 1.0;
+          if (fade_scaling_factor) raw.z -= fade_scaling_factor * bedlevel.get_z_correction(raw);
+        #else
+          raw.z -= bedlevel.get_z_correction(raw);
         #endif
 
-        raw.z -= (
-          #if ENABLED(MESH_BED_LEVELING)
-            mbl.get_z(raw OPTARG(ENABLE_LEVELING_FADE_HEIGHT, fade_scaling_factor))
-          #elif ENABLED(AUTO_BED_LEVELING_UBL)
-            fade_scaling_factor ? fade_scaling_factor * ubl.get_z_correction(raw) : 0.0
-          #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-            fade_scaling_factor ? fade_scaling_factor * bbl.get_z_correction(raw) : 0.0
-          #endif
-        );
-
       #endif
     }
   }
 
 #endif // HAS_LEVELING
 
 #if ENABLED(FWRETRACT)
   /**
    * rz, e - Cartesian positions in mm
    */

commit f1ab24d0ae2aa226235755be2345a677103952aa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 12 04:16:31 2022 -0500

    ü©π Fix accel dividend

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 62cbc172df..90424b55ee 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2557,21 +2557,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         LIMIT_ACCEL_FLOAT(K_AXIS, 0),
         LIMIT_ACCEL_FLOAT(U_AXIS, 0),
         LIMIT_ACCEL_FLOAT(V_AXIS, 0),
         LIMIT_ACCEL_FLOAT(W_AXIS, 0)
       );
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
-    block->acceleration_rate = (uint32_t)(accel * (float(1 << 24) / (STEPPER_TIMER_RATE)));
+    block->acceleration_rate = (uint32_t)(accel * (float(1UL << 24) / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
       block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * settings.axis_steps_per_mm[E_AXIS_N(extruder)]);
       #if ENABLED(LA_DEBUG)
         if (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * 2 < SQRT(block->nominal_speed_sqr) * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif

commit 918a9cf3d1c613e59dca5c59b567af86a5a3c8c9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 9 18:50:14 2022 -0500

    üßë‚Äçüíª Clarify acceleration factor

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index a22a99340f..62cbc172df 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2557,21 +2557,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         LIMIT_ACCEL_FLOAT(K_AXIS, 0),
         LIMIT_ACCEL_FLOAT(U_AXIS, 0),
         LIMIT_ACCEL_FLOAT(V_AXIS, 0),
         LIMIT_ACCEL_FLOAT(W_AXIS, 0)
       );
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
-    block->acceleration_rate = (uint32_t)(accel * (sq(4096.0f) / (STEPPER_TIMER_RATE)));
+    block->acceleration_rate = (uint32_t)(accel * (float(1 << 24) / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
       block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * settings.axis_steps_per_mm[E_AXIS_N(extruder)]);
       #if ENABLED(LA_DEBUG)
         if (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * 2 < SQRT(block->nominal_speed_sqr) * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif

commit 726a38712e17f1f31436d033d0597237c086d309
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Mon May 9 17:18:47 2022 -0500

    ü©π Fix Fan Tail Speed Init (#24076)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 6dc2c9e084..a22a99340f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1299,21 +1299,21 @@ void Planner::recalculate() {
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
 
   #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_I, DISABLE_J, DISABLE_K, DISABLE_U, DISABLE_V, DISABLE_W, DISABLE_E)
     xyze_bool_t axis_active = { false };
   #endif
 
   #if HAS_FAN && DISABLED(LASER_SYNCHRONOUS_M106_M107)
     #define HAS_TAIL_FAN_SPEED 1
-    static uint8_t tail_fan_speed[FAN_COUNT] = ARRAY_N_1(FAN_COUNT, 128);
+    static uint8_t tail_fan_speed[FAN_COUNT] = ARRAY_N_1(FAN_COUNT, 13);
     bool fans_need_update = false;
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
     #endif
     #if HAS_HEATER_2
       uint8_t tail_e_to_p_pressure;
     #endif
@@ -1335,32 +1335,32 @@ void Planner::check_axes_activity() {
       }
     #endif
 
     #if ENABLED(BARICUDA)
       TERN_(HAS_HEATER_1, tail_valve_pressure = block->valve_pressure);
       TERN_(HAS_HEATER_2, tail_e_to_p_pressure = block->e_to_p_pressure);
     #endif
 
     #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_I, DISABLE_J, DISABLE_K, DISABLE_E)
       for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
-        block_t *block = &block_buffer[b];
+        block_t * const bnext = &block_buffer[b];
         LOGICAL_AXIS_CODE(
-          if (TERN0(DISABLE_E, block->steps.e)) axis_active.e = true,
-          if (TERN0(DISABLE_X, block->steps.x)) axis_active.x = true,
-          if (TERN0(DISABLE_Y, block->steps.y)) axis_active.y = true,
-          if (TERN0(DISABLE_Z, block->steps.z)) axis_active.z = true,
-          if (TERN0(DISABLE_I, block->steps.i)) axis_active.i = true,
-          if (TERN0(DISABLE_J, block->steps.j)) axis_active.j = true,
-          if (TERN0(DISABLE_K, block->steps.k)) axis_active.k = true,
-          if (TERN0(DISABLE_U, block->steps.u)) axis_active.u = true,
-          if (TERN0(DISABLE_V, block->steps.v)) axis_active.v = true,
-          if (TERN0(DISABLE_W, block->steps.w)) axis_active.w = true
+          if (TERN0(DISABLE_E, bnext->steps.e)) axis_active.e = true,
+          if (TERN0(DISABLE_X, bnext->steps.x)) axis_active.x = true,
+          if (TERN0(DISABLE_Y, bnext->steps.y)) axis_active.y = true,
+          if (TERN0(DISABLE_Z, bnext->steps.z)) axis_active.z = true,
+          if (TERN0(DISABLE_I, bnext->steps.i)) axis_active.i = true,
+          if (TERN0(DISABLE_J, bnext->steps.j)) axis_active.j = true,
+          if (TERN0(DISABLE_K, bnext->steps.k)) axis_active.k = true,
+          if (TERN0(DISABLE_U, bnext->steps.u)) axis_active.u = true,
+          if (TERN0(DISABLE_V, bnext->steps.v)) axis_active.v = true,
+          if (TERN0(DISABLE_W, bnext->steps.w)) axis_active.w = true
         );
       }
     #endif
   }
   else {
 
     TERN_(HAS_CUTTER, cutter.refresh());
 
     #if HAS_TAIL_FAN_SPEED
       FANS_LOOP(i) {
@@ -1444,28 +1444,28 @@ void Planner::check_axes_activity() {
     autotemp_factor = parser.seen('F') ? parser.value_float() : TERN(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P, 0);
     autotemp_enabled = autotemp_factor != 0;
   }
 
   /**
    * Called every so often to adjust the hotend target temperature
    * based on the extrusion speed, which is calculated from the blocks
    * currently in the planner.
    */
   void Planner::autotemp_task() {
-    static float oldt = 0;
+    static float oldt = 0.0f;
 
     if (!autotemp_enabled) return;
     if (thermalManager.degTargetHotend(active_extruder) < autotemp_min - 2) return; // Below the min?
 
-    float high = 0.0;
+    float high = 0.0f;
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
-      block_t *block = &block_buffer[b];
+      const block_t * const block = &block_buffer[b];
       if (NUM_AXIS_GANG(block->steps.x, || block->steps.y, || block->steps.z, || block->steps.i, || block->steps.j, || block->steps.k, || block->steps.u, || block->steps.v, || block->steps.w)) {
         const float se = (float)block->steps.e / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;
         NOLESS(high, se);
       }
     }
 
     float t = autotemp_min + high * autotemp_factor;
     LIMIT(t, autotemp_min, autotemp_max);
     if (t < oldt) t = t * (1.0f - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
     oldt = t;

commit a0d28f1770870a90be5c7887d7bfc4b34db5d5d2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 20 04:29:39 2022 -0500

    üé® Minimize block->steps.set

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ad095dc149..6dc2c9e084 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1998,36 +1998,38 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   // Update block laser power
   #if ENABLED(LASER_POWER_INLINE)
     laser_inline.status.isPlanned = true;
     block->laser.status = laser_inline.status;
     block->laser.power = laser_inline.power;
   #endif
 
   // Number of steps for each axis
   // See https://www.corexy.com/theory.html
-  #if CORE_IS_XY
-    block->steps.set(NUM_AXIS_LIST(ABS(da + db), ABS(da - db), ABS(dc), ABS(di), ABS(dj), ABS(dk), ABS(du), ABS(dv), ABS(dw)));
-  #elif CORE_IS_XZ
-    block->steps.set(NUM_AXIS_LIST(ABS(da + dc), ABS(db), ABS(da - dc), ABS(di), ABS(dj), ABS(dk), ABS(du), ABS(dv), ABS(dw)));
-  #elif CORE_IS_YZ
-    block->steps.set(NUM_AXIS_LIST(ABS(da), ABS(db + dc), ABS(db - dc), ABS(di), ABS(dj), ABS(dk), ABS(du), ABS(dv), ABS(dw)));
-  #elif ENABLED(MARKFORGED_XY)
-    block->steps.set(NUM_AXIS_LIST(ABS(da + db), ABS(db), ABS(dc), ABS(di), ABS(dj), ABS(dk), ABS(du), ABS(dv), ABS(dw)));
-  #elif ENABLED(MARKFORGED_YX)
-    block->steps.set(NUM_AXIS_LIST(ABS(da), ABS(db + da), ABS(dc), ABS(di), ABS(dj), ABS(dk), ABS(du), ABS(dv), ABS(dw)));
-  #elif IS_SCARA
-    block->steps.set(NUM_AXIS_LIST(ABS(da), ABS(db), ABS(dc), ABS(di), ABS(dj), ABS(dk), ABS(du), ABS(dv), ABS(dw)));
-  #else
-    // default non-h-bot planning
-    block->steps.set(NUM_AXIS_LIST(ABS(da), ABS(db), ABS(dc), ABS(di), ABS(dj), ABS(dk), ABS(du), ABS(dv), ABS(dw)));
-  #endif
+  block->steps.set(NUM_AXIS_LIST(
+    #if CORE_IS_XY
+      ABS(da + db), ABS(da - db), ABS(dc)
+    #elif CORE_IS_XZ
+      ABS(da + dc), ABS(db), ABS(da - dc)
+    #elif CORE_IS_YZ
+      ABS(da), ABS(db + dc), ABS(db - dc)
+    #elif ENABLED(MARKFORGED_XY)
+      ABS(da + db), ABS(db), ABS(dc)
+    #elif ENABLED(MARKFORGED_YX)
+      ABS(da), ABS(db + da), ABS(dc)
+    #elif IS_SCARA
+      ABS(da), ABS(db), ABS(dc)
+    #else // default non-h-bot planning
+      ABS(da), ABS(db), ABS(dc)
+    #endif
+    , ABS(di), ABS(dj), ABS(dk), ABS(du), ABS(dv), ABS(dw)
+  ));
 
   /**
    * This part of the code calculates the total length of the movement.
    * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
    * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
    * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
    * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
    * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
    */
   struct DistanceMM : abce_float_t {

commit 80810f1b187661860a2ded43e2a0c4cc356edebe
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 1 17:49:54 2022 -0600

    üö® Fix some compiler warnings

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 42a16603d4..ad095dc149 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -3296,40 +3296,40 @@ void Planner::reset_acceleration_rates() {
  * Recalculate 'position' and 'mm_per_step'.
  * Must be called whenever settings.axis_steps_per_mm changes!
  */
 void Planner::refresh_positioning() {
   LOOP_DISTINCT_AXES(i) mm_per_step[i] = 1.0f / settings.axis_steps_per_mm[i];
   set_position_mm(current_position);
   reset_acceleration_rates();
 }
 
 // Apply limits to a variable and give a warning if the value was out of range
-inline void limit_and_warn(float &val, const uint8_t axis, PGM_P const setting_name, const xyze_float_t &max_limit) {
+inline void limit_and_warn(float &val, const AxisEnum axis, PGM_P const setting_name, const xyze_float_t &max_limit) {
   const uint8_t lim_axis = TERN_(HAS_EXTRUDERS, axis > E_AXIS ? E_AXIS :) axis;
   const float before = val;
   LIMIT(val, 0.1, max_limit[lim_axis]);
   if (before != val) {
     SERIAL_CHAR(AXIS_CHAR(lim_axis));
     SERIAL_ECHOPGM(" Max ");
     SERIAL_ECHOPGM_P(setting_name);
     SERIAL_ECHOLNPGM(" limited to ", val);
   }
 }
 
 /**
  * For the specified 'axis' set the Maximum Acceleration to the given value (mm/s^2)
  * The value may be limited with warning feedback, if configured.
  * Calls reset_acceleration_rates to precalculate planner terms in steps.
  *
  * This hard limit is applied as a block is being added to the planner queue.
  */
-void Planner::set_max_acceleration(const uint8_t axis, float inMaxAccelMMS2) {
+void Planner::set_max_acceleration(const AxisEnum axis, float inMaxAccelMMS2) {
   #if ENABLED(LIMITED_MAX_ACCEL_EDITING)
     #ifdef MAX_ACCEL_EDIT_VALUES
       constexpr xyze_float_t max_accel_edit = MAX_ACCEL_EDIT_VALUES;
       const xyze_float_t &max_acc_edit_scaled = max_accel_edit;
     #else
       constexpr xyze_float_t max_accel_edit = DEFAULT_MAX_ACCELERATION;
       const xyze_float_t max_acc_edit_scaled = max_accel_edit * 2;
     #endif
     limit_and_warn(inMaxAccelMMS2, axis, PSTR("Acceleration"), max_acc_edit_scaled);
   #endif
@@ -3338,21 +3338,21 @@ void Planner::set_max_acceleration(const uint8_t axis, float inMaxAccelMMS2) {
   // Update steps per s2 to agree with the units per s2 (since they are used in the planner)
   reset_acceleration_rates();
 }
 
 /**
  * For the specified 'axis' set the Maximum Feedrate to the given value (mm/s)
  * The value may be limited with warning feedback, if configured.
  *
  * This hard limit is applied as a block is being added to the planner queue.
  */
-void Planner::set_max_feedrate(const uint8_t axis, float inMaxFeedrateMMS) {
+void Planner::set_max_feedrate(const AxisEnum axis, float inMaxFeedrateMMS) {
   #if ENABLED(LIMITED_MAX_FR_EDITING)
     #ifdef MAX_FEEDRATE_EDIT_VALUES
       constexpr xyze_float_t max_fr_edit = MAX_FEEDRATE_EDIT_VALUES;
       const xyze_float_t &max_fr_edit_scaled = max_fr_edit;
     #else
       constexpr xyze_float_t max_fr_edit = DEFAULT_MAX_FEEDRATE;
       const xyze_float_t max_fr_edit_scaled = max_fr_edit * 2;
     #endif
     limit_and_warn(inMaxFeedrateMMS, axis, PSTR("Feedrate"), max_fr_edit_scaled);
   #endif

commit e4c7c550fcb3a69b2d89f718b23166fcad4d0f15
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun Apr 3 01:27:05 2022 +0200

    üêõ Fix PID edit menu for Bed, Chamber (#23987)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ae67073b4f..42a16603d4 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2122,21 +2122,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
        */
       float distance_sqr = (
         #if ENABLED(ARTICULATED_ROBOT_ARM)
           // For articulated robots, interpreting feedrate like LinuxCNC would require inverse kinematics. As a workaround, pretend that motors sit on n mutually orthogonal
           // axes and assume that we could think of distance as magnitude of an n-vector in an n-dimensional Euclidian space.
           NUM_AXIS_GANG(
               sq(steps_dist_mm.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.z),
             + sq(steps_dist_mm.i), + sq(steps_dist_mm.j), + sq(steps_dist_mm.k),
             + sq(steps_dist_mm.u), + sq(steps_dist_mm.v), + sq(steps_dist_mm.w)
           );
-        #elif ENABLED(FOAMCUTTER_XYUV) 
+        #elif ENABLED(FOAMCUTTER_XYUV)
           #if HAS_J_AXIS
           // Special 5 axis kinematics. Return the largest distance move from either X/Y or I/J plane
           _MAX(sq(steps_dist_mm.x) + sq(steps_dist_mm.y), sq(steps_dist_mm.i) + sq(steps_dist_mm.j))
           #else // Foamcutter with only two axes (XY)
             sq(steps_dist_mm.x) + sq(steps_dist_mm.y)
           #endif
         #elif ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
           XYZ_GANG(sq(steps_dist_mm.head.x), + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.z))
         #elif CORE_IS_XZ
           XYZ_GANG(sq(steps_dist_mm.head.x), + sq(steps_dist_mm.y),      + sq(steps_dist_mm.head.z))

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 8c723aa06e..ae67073b4f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1293,21 +1293,21 @@ void Planner::recalculate() {
 
   #endif
 
 #endif // HAS_FAN
 
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
 
-  #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_I, DISABLE_J, DISABLE_K, DISABLE_E)
+  #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_I, DISABLE_J, DISABLE_K, DISABLE_U, DISABLE_V, DISABLE_W, DISABLE_E)
     xyze_bool_t axis_active = { false };
   #endif
 
   #if HAS_FAN && DISABLED(LASER_SYNCHRONOUS_M106_M107)
     #define HAS_TAIL_FAN_SPEED 1
     static uint8_t tail_fan_speed[FAN_COUNT] = ARRAY_N_1(FAN_COUNT, 128);
     bool fans_need_update = false;
   #endif
 
   #if ENABLED(BARICUDA)
@@ -1343,21 +1343,24 @@ void Planner::check_axes_activity() {
     #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_I, DISABLE_J, DISABLE_K, DISABLE_E)
       for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
         block_t *block = &block_buffer[b];
         LOGICAL_AXIS_CODE(
           if (TERN0(DISABLE_E, block->steps.e)) axis_active.e = true,
           if (TERN0(DISABLE_X, block->steps.x)) axis_active.x = true,
           if (TERN0(DISABLE_Y, block->steps.y)) axis_active.y = true,
           if (TERN0(DISABLE_Z, block->steps.z)) axis_active.z = true,
           if (TERN0(DISABLE_I, block->steps.i)) axis_active.i = true,
           if (TERN0(DISABLE_J, block->steps.j)) axis_active.j = true,
-          if (TERN0(DISABLE_K, block->steps.k)) axis_active.k = true
+          if (TERN0(DISABLE_K, block->steps.k)) axis_active.k = true,
+          if (TERN0(DISABLE_U, block->steps.u)) axis_active.u = true,
+          if (TERN0(DISABLE_V, block->steps.v)) axis_active.v = true,
+          if (TERN0(DISABLE_W, block->steps.w)) axis_active.w = true
         );
       }
     #endif
   }
   else {
 
     TERN_(HAS_CUTTER, cutter.refresh());
 
     #if HAS_TAIL_FAN_SPEED
       FANS_LOOP(i) {
@@ -1378,21 +1381,24 @@ void Planner::check_axes_activity() {
   //
   // Disable inactive axes
   //
   LOGICAL_AXIS_CODE(
     if (TERN0(DISABLE_E, !axis_active.e)) stepper.disable_e_steppers(),
     if (TERN0(DISABLE_X, !axis_active.x)) stepper.disable_axis(X_AXIS),
     if (TERN0(DISABLE_Y, !axis_active.y)) stepper.disable_axis(Y_AXIS),
     if (TERN0(DISABLE_Z, !axis_active.z)) stepper.disable_axis(Z_AXIS),
     if (TERN0(DISABLE_I, !axis_active.i)) stepper.disable_axis(I_AXIS),
     if (TERN0(DISABLE_J, !axis_active.j)) stepper.disable_axis(J_AXIS),
-    if (TERN0(DISABLE_K, !axis_active.k)) stepper.disable_axis(K_AXIS)
+    if (TERN0(DISABLE_K, !axis_active.k)) stepper.disable_axis(K_AXIS),
+    if (TERN0(DISABLE_U, !axis_active.u)) stepper.disable_axis(U_AXIS),
+    if (TERN0(DISABLE_V, !axis_active.v)) stepper.disable_axis(V_AXIS),
+    if (TERN0(DISABLE_W, !axis_active.w)) stepper.disable_axis(W_AXIS)
   );
 
   //
   // Update Fan speeds
   // Only if synchronous M106/M107 is disabled
   //
   TERN_(HAS_TAIL_FAN_SPEED, if (fans_need_update) sync_fan_speeds(tail_fan_speed));
 
   TERN_(AUTOTEMP, autotemp_task());
 
@@ -1446,21 +1452,21 @@ void Planner::check_axes_activity() {
    */
   void Planner::autotemp_task() {
     static float oldt = 0;
 
     if (!autotemp_enabled) return;
     if (thermalManager.degTargetHotend(active_extruder) < autotemp_min - 2) return; // Below the min?
 
     float high = 0.0;
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block_t *block = &block_buffer[b];
-      if (LINEAR_AXIS_GANG(block->steps.x, || block->steps.y, || block->steps.z, || block->steps.i, || block->steps.j, || block->steps.k)) {
+      if (NUM_AXIS_GANG(block->steps.x, || block->steps.y, || block->steps.z, || block->steps.i, || block->steps.j, || block->steps.k, || block->steps.u, || block->steps.v, || block->steps.w)) {
         const float se = (float)block->steps.e / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;
         NOLESS(high, se);
       }
     }
 
     float t = autotemp_min + high * autotemp_factor;
     LIMIT(t, autotemp_min, autotemp_max);
     if (t < oldt) t = t * (1.0f - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
     oldt = t;
     thermalManager.setTargetHotend(t, active_extruder);
@@ -1849,38 +1855,53 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
   , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters/*=0.0*/
 ) {
   int32_t LOGICAL_AXIS_LIST(
     de = target.e - position.e,
     da = target.a - position.a,
     db = target.b - position.b,
     dc = target.c - position.c,
     di = target.i - position.i,
     dj = target.j - position.j,
-    dk = target.k - position.k
+    dk = target.k - position.k,
+    du = target.u - position.u,
+    dv = target.v - position.v,
+    dw = target.w - position.w
   );
 
   /* <-- add a slash to enable
     SERIAL_ECHOLNPGM(
       "  _populate_block FR:", fr_mm_s,
       " A:", target.a, " (", da, " steps)"
-      " B:", target.b, " (", db, " steps)"
-      " C:", target.c, " (", dc, " steps)"
+      #if HAS_Y_AXIS
+        " B:", target.b, " (", db, " steps)"
+      #endif
+      #if HAS_Z_AXIS
+        " C:", target.c, " (", dc, " steps)"
+      #endif
       #if HAS_I_AXIS
         " " STR_I ":", target.i, " (", di, " steps)"
       #endif
       #if HAS_J_AXIS
         " " STR_J ":", target.j, " (", dj, " steps)"
       #endif
       #if HAS_K_AXIS
         " " STR_K ":", target.k, " (", dk, " steps)"
       #endif
+      #if HAS_U_AXIS
+        " " STR_U ":", target.u, " (", du, " steps)"
+      #endif
+      #if HAS_V_AXIS
+        " " STR_V ":", target.v, " (", dv, " steps)"
+      #endif
+      #if HAS_W_AXIS
+        " " STR_W ":", target.w, " (", dw, " steps)"
       #if HAS_EXTRUDERS
         " E:", target.e, " (", de, " steps)"
       #endif
     );
   //*/
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
@@ -1931,46 +1952,43 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
       if (da + dc < 0) SBI(dm, A_AXIS);           // Motor A direction
       if (CORESIGN(da - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
     #elif CORE_IS_YZ
       if (da < 0) SBI(dm, X_AXIS);
       if (db < 0) SBI(dm, Y_HEAD);                // Save the toolhead's true direction in Y
       if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
       if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
       if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
     #endif
-    #if HAS_I_AXIS
-      if (di < 0) SBI(dm, I_AXIS);
-    #endif
-    #if HAS_J_AXIS
-      if (dj < 0) SBI(dm, J_AXIS);
-    #endif
-    #if HAS_K_AXIS
-      if (dk < 0) SBI(dm, K_AXIS);
-    #endif
   #elif ENABLED(MARKFORGED_XY)
     if (da + db < 0) SBI(dm, A_AXIS);              // Motor A direction
     if (db < 0) SBI(dm, B_AXIS);                   // Motor B direction
   #elif ENABLED(MARKFORGED_YX)
     if (da < 0) SBI(dm, A_AXIS);                   // Motor A direction
     if (db + da < 0) SBI(dm, B_AXIS);              // Motor B direction
   #else
-    LINEAR_AXIS_CODE(
+    XYZ_CODE(
       if (da < 0) SBI(dm, X_AXIS),
       if (db < 0) SBI(dm, Y_AXIS),
-      if (dc < 0) SBI(dm, Z_AXIS),
-      if (di < 0) SBI(dm, I_AXIS),
-      if (dj < 0) SBI(dm, J_AXIS),
-      if (dk < 0) SBI(dm, K_AXIS)
+      if (dc < 0) SBI(dm, Z_AXIS)
     );
   #endif
 
+  SECONDARY_AXIS_CODE(
+    if (di < 0) SBI(dm, I_AXIS),
+    if (dj < 0) SBI(dm, J_AXIS),
+    if (dk < 0) SBI(dm, K_AXIS),
+    if (du < 0) SBI(dm, U_AXIS),
+    if (dv < 0) SBI(dm, V_AXIS),
+    if (dw < 0) SBI(dm, W_AXIS)
+  );
+
   #if HAS_EXTRUDERS
     if (de < 0) SBI(dm, E_AXIS);
     const float esteps_float = de * e_factor[extruder];
     const uint32_t esteps = ABS(esteps_float) + 0.5f;
   #else
     constexpr uint32_t esteps = 0;
   #endif
 
   // Clear all flags, including the "busy" bit
   block->flag = 0x00;
@@ -1981,34 +1999,34 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   // Update block laser power
   #if ENABLED(LASER_POWER_INLINE)
     laser_inline.status.isPlanned = true;
     block->laser.status = laser_inline.status;
     block->laser.power = laser_inline.power;
   #endif
 
   // Number of steps for each axis
   // See https://www.corexy.com/theory.html
   #if CORE_IS_XY
-    block->steps.set(LINEAR_AXIS_LIST(ABS(da + db), ABS(da - db), ABS(dc), ABS(di), ABS(dj), ABS(dk)));
+    block->steps.set(NUM_AXIS_LIST(ABS(da + db), ABS(da - db), ABS(dc), ABS(di), ABS(dj), ABS(dk), ABS(du), ABS(dv), ABS(dw)));
   #elif CORE_IS_XZ
-    block->steps.set(LINEAR_AXIS_LIST(ABS(da + dc), ABS(db), ABS(da - dc), ABS(di), ABS(dj), ABS(dk)));
+    block->steps.set(NUM_AXIS_LIST(ABS(da + dc), ABS(db), ABS(da - dc), ABS(di), ABS(dj), ABS(dk), ABS(du), ABS(dv), ABS(dw)));
   #elif CORE_IS_YZ
-    block->steps.set(LINEAR_AXIS_LIST(ABS(da), ABS(db + dc), ABS(db - dc), ABS(di), ABS(dj), ABS(dk)));
+    block->steps.set(NUM_AXIS_LIST(ABS(da), ABS(db + dc), ABS(db - dc), ABS(di), ABS(dj), ABS(dk), ABS(du), ABS(dv), ABS(dw)));
   #elif ENABLED(MARKFORGED_XY)
-    block->steps.set(LINEAR_AXIS_LIST(ABS(da + db), ABS(db), ABS(dc), ABS(di), ABS(dj), ABS(dk)));
+    block->steps.set(NUM_AXIS_LIST(ABS(da + db), ABS(db), ABS(dc), ABS(di), ABS(dj), ABS(dk), ABS(du), ABS(dv), ABS(dw)));
   #elif ENABLED(MARKFORGED_YX)
-    block->steps.set(LINEAR_AXIS_LIST(ABS(da), ABS(db + da), ABS(dc), ABS(di), ABS(dj), ABS(dk)));
+    block->steps.set(NUM_AXIS_LIST(ABS(da), ABS(db + da), ABS(dc), ABS(di), ABS(dj), ABS(dk), ABS(du), ABS(dv), ABS(dw)));
   #elif IS_SCARA
-    block->steps.set(LINEAR_AXIS_LIST(ABS(da), ABS(db), ABS(dc), ABS(di), ABS(dj), ABS(dk)));
+    block->steps.set(NUM_AXIS_LIST(ABS(da), ABS(db), ABS(dc), ABS(di), ABS(dj), ABS(dk), ABS(du), ABS(dv), ABS(dw)));
   #else
     // default non-h-bot planning
-    block->steps.set(LINEAR_AXIS_LIST(ABS(da), ABS(db), ABS(dc), ABS(di), ABS(dj), ABS(dk)));
+    block->steps.set(NUM_AXIS_LIST(ABS(da), ABS(db), ABS(dc), ABS(di), ABS(dj), ABS(dk), ABS(du), ABS(dv), ABS(dw)));
   #endif
 
   /**
    * This part of the code calculates the total length of the movement.
    * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
    * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
    * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
    * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
    * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
    */
@@ -2033,107 +2051,154 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       steps_dist_mm.head.z = dc * mm_per_step[C_AXIS];
       steps_dist_mm.a      = (da + dc) * mm_per_step[A_AXIS];
       steps_dist_mm.c      = CORESIGN(da - dc) * mm_per_step[C_AXIS];
     #elif CORE_IS_YZ
       steps_dist_mm.x      = da * mm_per_step[X_AXIS];
       steps_dist_mm.head.y = db * mm_per_step[B_AXIS];
       steps_dist_mm.head.z = dc * mm_per_step[C_AXIS];
       steps_dist_mm.b      = (db + dc) * mm_per_step[B_AXIS];
       steps_dist_mm.c      = CORESIGN(db - dc) * mm_per_step[C_AXIS];
     #endif
-    TERN_(HAS_I_AXIS, steps_dist_mm.i = di * mm_per_step[I_AXIS]);
-    TERN_(HAS_J_AXIS, steps_dist_mm.j = dj * mm_per_step[J_AXIS]);
-    TERN_(HAS_K_AXIS, steps_dist_mm.k = dk * mm_per_step[K_AXIS]);
   #elif ENABLED(MARKFORGED_XY)
     steps_dist_mm.a      = (da - db) * mm_per_step[A_AXIS];
     steps_dist_mm.b      = db * mm_per_step[B_AXIS];
   #elif ENABLED(MARKFORGED_YX)
     steps_dist_mm.a      = da * mm_per_step[A_AXIS];
     steps_dist_mm.b      = (db - da) * mm_per_step[B_AXIS];
   #else
-    LINEAR_AXIS_CODE(
+    XYZ_CODE(
       steps_dist_mm.a = da * mm_per_step[A_AXIS],
       steps_dist_mm.b = db * mm_per_step[B_AXIS],
-      steps_dist_mm.c = dc * mm_per_step[C_AXIS],
-      steps_dist_mm.i = di * mm_per_step[I_AXIS],
-      steps_dist_mm.j = dj * mm_per_step[J_AXIS],
-      steps_dist_mm.k = dk * mm_per_step[K_AXIS]
+      steps_dist_mm.c = dc * mm_per_step[C_AXIS]
     );
   #endif
 
+  SECONDARY_AXIS_CODE(
+    steps_dist_mm.i = di * mm_per_step[I_AXIS],
+    steps_dist_mm.j = dj * mm_per_step[J_AXIS],
+    steps_dist_mm.k = dk * mm_per_step[K_AXIS],
+    steps_dist_mm.u = du * mm_per_step[U_AXIS],
+    steps_dist_mm.v = dv * mm_per_step[V_AXIS],
+    steps_dist_mm.w = dw * mm_per_step[W_AXIS]
+  );
+
   TERN_(HAS_EXTRUDERS, steps_dist_mm.e = esteps_float * mm_per_step[E_AXIS_N(extruder)]);
 
   TERN_(LCD_SHOW_E_TOTAL, e_move_accumulator += steps_dist_mm.e);
 
-  if (true LINEAR_AXIS_GANG(
+  #if BOTH(HAS_ROTATIONAL_AXES, INCH_MODE_SUPPORT)
+    bool cartesian_move = true;
+  #endif
+
+  if (true NUM_AXIS_GANG(
       && block->steps.a < MIN_STEPS_PER_SEGMENT,
       && block->steps.b < MIN_STEPS_PER_SEGMENT,
       && block->steps.c < MIN_STEPS_PER_SEGMENT,
       && block->steps.i < MIN_STEPS_PER_SEGMENT,
       && block->steps.j < MIN_STEPS_PER_SEGMENT,
-      && block->steps.k < MIN_STEPS_PER_SEGMENT
+      && block->steps.k < MIN_STEPS_PER_SEGMENT,
+      && block->steps.u < MIN_STEPS_PER_SEGMENT,
+      && block->steps.v < MIN_STEPS_PER_SEGMENT,
+      && block->steps.w < MIN_STEPS_PER_SEGMENT
     )
   ) {
     block->millimeters = TERN0(HAS_EXTRUDERS, ABS(steps_dist_mm.e));
   }
   else {
     if (millimeters)
       block->millimeters = millimeters;
     else {
-      block->millimeters = SQRT(
-        #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
-          LINEAR_AXIS_GANG(
-              sq(steps_dist_mm.head.x), + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.z),
-            + sq(steps_dist_mm.i),      + sq(steps_dist_mm.j),      + sq(steps_dist_mm.k)
-          )
-        #elif CORE_IS_XZ
-          LINEAR_AXIS_GANG(
-              sq(steps_dist_mm.head.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.head.z),
-            + sq(steps_dist_mm.i),      + sq(steps_dist_mm.j), + sq(steps_dist_mm.k)
-          )
-        #elif CORE_IS_YZ
-          LINEAR_AXIS_GANG(
-              sq(steps_dist_mm.x)  + sq(steps_dist_mm.head.y) + sq(steps_dist_mm.head.z)
-            + sq(steps_dist_mm.i), + sq(steps_dist_mm.j),     + sq(steps_dist_mm.k)
-          )
-        #elif ENABLED(FOAMCUTTER_XYUV)
-          // Return the largest distance move from either X/Y or I/J plane
+      /**
+       * Distance for interpretation of feedrate in accordance with LinuxCNC (the successor of NIST
+       * RS274NGC interpreter - version 3) and its default CANON_XYZ feed reference mode.
+       * Assume that X, Y, Z are the primary linear axes and U, V, W are secondary linear axes and A, B, C are
+       * rotational axes. Then dX, dY, dZ are the displacements of the primary linear axes and dU, dV, dW are the displacements of linear axes and
+       * dA, dB, dC are the displacements of rotational axes.
+       * The time it takes to execute move command with feedrate F is t = D/F, where D is the total distance, calculated as follows:
+       *   D^2 = dX^2 + dY^2 + dZ^2
+       *   if D^2 == 0 (none of XYZ move but any secondary linear axes move, whether other axes are moved or not):
+       *     D^2 = dU^2 + dV^2 + dW^2
+       *   if D^2 == 0 (only rotational axes are moved):
+       *     D^2 = dA^2 + dB^2 + dC^2
+       */
+      float distance_sqr = (
+        #if ENABLED(ARTICULATED_ROBOT_ARM)
+          // For articulated robots, interpreting feedrate like LinuxCNC would require inverse kinematics. As a workaround, pretend that motors sit on n mutually orthogonal
+          // axes and assume that we could think of distance as magnitude of an n-vector in an n-dimensional Euclidian space.
+          NUM_AXIS_GANG(
+              sq(steps_dist_mm.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.z),
+            + sq(steps_dist_mm.i), + sq(steps_dist_mm.j), + sq(steps_dist_mm.k),
+            + sq(steps_dist_mm.u), + sq(steps_dist_mm.v), + sq(steps_dist_mm.w)
+          );
+        #elif ENABLED(FOAMCUTTER_XYUV) 
           #if HAS_J_AXIS
-            _MAX(sq(steps_dist_mm.x) + sq(steps_dist_mm.y), sq(steps_dist_mm.i) + sq(steps_dist_mm.j))
-          #else
+          // Special 5 axis kinematics. Return the largest distance move from either X/Y or I/J plane
+          _MAX(sq(steps_dist_mm.x) + sq(steps_dist_mm.y), sq(steps_dist_mm.i) + sq(steps_dist_mm.j))
+          #else // Foamcutter with only two axes (XY)
             sq(steps_dist_mm.x) + sq(steps_dist_mm.y)
           #endif
+        #elif ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
+          XYZ_GANG(sq(steps_dist_mm.head.x), + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.z))
+        #elif CORE_IS_XZ
+          XYZ_GANG(sq(steps_dist_mm.head.x), + sq(steps_dist_mm.y),      + sq(steps_dist_mm.head.z))
+        #elif CORE_IS_YZ
+          XYZ_GANG(sq(steps_dist_mm.x),      + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.head.z))
         #else
-          LINEAR_AXIS_GANG(
-              sq(steps_dist_mm.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.z),
-            + sq(steps_dist_mm.i), + sq(steps_dist_mm.j), + sq(steps_dist_mm.k)
-          )
+          XYZ_GANG(sq(steps_dist_mm.x),       + sq(steps_dist_mm.y),      + sq(steps_dist_mm.z))
         #endif
       );
+
+      #if SECONDARY_LINEAR_AXES >= 1 && NONE(FOAMCUTTER_XYUV, ARTICULATED_ROBOT_ARM)
+        if (NEAR_ZERO(distance_sqr)) {
+          // Move does not involve any primary linear axes (xyz) but might involve secondary linear axes
+          distance_sqr = (0.0
+            SECONDARY_AXIS_GANG(
+              IF_DISABLED(AXIS4_ROTATES, + sq(steps_dist_mm.i)),
+              IF_DISABLED(AXIS5_ROTATES, + sq(steps_dist_mm.j)),
+              IF_DISABLED(AXIS6_ROTATES, + sq(steps_dist_mm.k)),
+              IF_DISABLED(AXIS7_ROTATES, + sq(steps_dist_mm.u)),
+              IF_DISABLED(AXIS8_ROTATES, + sq(steps_dist_mm.v)),
+              IF_DISABLED(AXIS9_ROTATES, + sq(steps_dist_mm.w))
+            )
+          );
+        }
+      #endif
+
+      #if HAS_ROTATIONAL_AXES && NONE(FOAMCUTTER_XYUV, ARTICULATED_ROBOT_ARM)
+        if (NEAR_ZERO(distance_sqr)) {
+          // Move involves only rotational axes. Calculate angular distance in accordance with LinuxCNC
+          TERN_(INCH_MODE_SUPPORT, cartesian_move = false);
+          distance_sqr = ROTATIONAL_AXIS_GANG(sq(steps_dist_mm.i), + sq(steps_dist_mm.j), + sq(steps_dist_mm.k), + sq(steps_dist_mm.u), + sq(steps_dist_mm.v), + sq(steps_dist_mm.w));
+        }
+      #endif
+
+      block->millimeters = SQRT(distance_sqr);
     }
 
     /**
      * At this point at least one of the axes has more steps than
      * MIN_STEPS_PER_SEGMENT, ensuring the segment won't get dropped as
      * zero-length. It's important to not apply corrections
      * to blocks that would get dropped!
      *
      * A correction function is permitted to add steps to an axis, it
      * should *never* remove steps!
      */
     TERN_(BACKLASH_COMPENSATION, backlash.add_correction_steps(da, db, dc, dm, block));
   }
 
   TERN_(HAS_EXTRUDERS, block->steps.e = esteps);
 
-  block->step_event_count = _MAX(LOGICAL_AXIS_LIST(
-    esteps, block->steps.a, block->steps.b, block->steps.c, block->steps.i, block->steps.j, block->steps.k
+  block->step_event_count = _MAX(LOGICAL_AXIS_LIST(esteps,
+    block->steps.a, block->steps.b, block->steps.c,
+    block->steps.i, block->steps.j, block->steps.k,
+    block->steps.u, block->steps.v, block->steps.w
   ));
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   TERN_(MIXING_EXTRUDER, mixer.populate_block(block->b_color));
 
   TERN_(HAS_CUTTER, block->cutter_power = cutter.power);
 
   #if HAS_FAN
@@ -2141,27 +2206,30 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
   E_TERN_(block->extruder = extruder);
 
   #if ENABLED(AUTO_POWER_CONTROL)
-    if (LINEAR_AXIS_GANG(
+    if (NUM_AXIS_GANG(
          block->steps.x,
       || block->steps.y,
       || block->steps.z,
       || block->steps.i,
       || block->steps.j,
-      || block->steps.k
+      || block->steps.k,
+      || block->steps.u,
+      || block->steps.v,
+      || block->steps.w
     )) powerManager.power_on();
   #endif
 
   // Enable active axes
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
     if (block->steps.a || block->steps.b) {
       stepper.enable_axis(X_AXIS);
       stepper.enable_axis(Y_AXIS);
     }
     #if DISABLED(Z_LATE_ENABLE)
@@ -2173,33 +2241,41 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       stepper.enable_axis(Z_AXIS);
     }
     if (block->steps.y) stepper.enable_axis(Y_AXIS);
   #elif CORE_IS_YZ
     if (block->steps.b || block->steps.c) {
       stepper.enable_axis(Y_AXIS);
       stepper.enable_axis(Z_AXIS);
     }
     if (block->steps.x) stepper.enable_axis(X_AXIS);
   #else
-    LINEAR_AXIS_CODE(
+    NUM_AXIS_CODE(
       if (block->steps.x) stepper.enable_axis(X_AXIS),
       if (block->steps.y) stepper.enable_axis(Y_AXIS),
       if (TERN(Z_LATE_ENABLE, 0, block->steps.z)) stepper.enable_axis(Z_AXIS),
       if (block->steps.i) stepper.enable_axis(I_AXIS),
       if (block->steps.j) stepper.enable_axis(J_AXIS),
-      if (block->steps.k) stepper.enable_axis(K_AXIS)
+      if (block->steps.k) stepper.enable_axis(K_AXIS),
+      if (block->steps.u) stepper.enable_axis(U_AXIS),
+      if (block->steps.v) stepper.enable_axis(V_AXIS),
+      if (block->steps.w) stepper.enable_axis(W_AXIS)
     );
   #endif
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
-    TERN_(HAS_I_AXIS, if (block->steps.i) stepper.enable_axis(I_AXIS));
-    TERN_(HAS_J_AXIS, if (block->steps.j) stepper.enable_axis(J_AXIS));
-    TERN_(HAS_K_AXIS, if (block->steps.k) stepper.enable_axis(K_AXIS));
+    SECONDARY_AXIS_CODE(
+      if (block->steps.i) stepper.enable_axis(I_AXIS),
+      if (block->steps.j) stepper.enable_axis(J_AXIS),
+      if (block->steps.k) stepper.enable_axis(K_AXIS),
+      if (block->steps.u) stepper.enable_axis(U_AXIS),
+      if (block->steps.v) stepper.enable_axis(V_AXIS),
+      if (block->steps.w) stepper.enable_axis(W_AXIS)
+    );
   #endif
 
   // Enable extruder(s)
   #if HAS_EXTRUDERS
     if (esteps) {
       TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
         // Count down all steppers that were recently moved
@@ -2232,22 +2308,28 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #endif // HAS_EXTRUDERS
 
   if (esteps)
     NOLESS(fr_mm_s, settings.min_feedrate_mm_s);
   else
     NOLESS(fr_mm_s, settings.min_travel_feedrate_mm_s);
 
   const float inverse_millimeters = 1.0f / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate inverse time for this move. No divide by zero due to previous checks.
-  // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
-  float inverse_secs = fr_mm_s * inverse_millimeters;
+  // Example: At 120mm/s a 60mm move involving XYZ axes takes 0.5s. So this will give 2.0.
+  // Example 2: At 120¬∞/s a 60¬∞ move involving only rotational axes takes 0.5s. So this will give 2.0.
+  float inverse_secs;
+  #if BOTH(HAS_ROTATIONAL_AXES, INCH_MODE_SUPPORT)
+    inverse_secs = inverse_millimeters * (cartesian_move ? fr_mm_s : LINEAR_UNIT(fr_mm_s));
+  #else
+    inverse_secs = fr_mm_s * inverse_millimeters;
+  #endif
 
   // Get the number of non busy movements in queue (non busy means that they can be altered)
   const uint8_t moves_queued = nonbusy_movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if EITHER(SLOWDOWN, HAS_WIRED_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time in microseconds
     int32_t segment_time_us = LROUND(1000000.0f / inverse_secs);
   #endif
 
@@ -2279,27 +2361,27 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #endif
 
   block->nominal_speed_sqr = sq(block->millimeters * inverse_secs);   // (mm/sec)^2 Always > 0
   block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM)   // Only for extruder with filament sensor
       filwidth.advance_e(steps_dist_mm.e);
   #endif
 
-  // Calculate and limit speed in mm/sec
+  // Calculate and limit speed in mm/sec (linear) or degrees/sec (rotational)
 
   xyze_float_t current_speed;
   float speed_factor = 1.0f; // factor <1 decreases speed
 
   // Linear axes first with less logic
-  LOOP_LINEAR_AXES(i) {
+  LOOP_NUM_AXES(i) {
     current_speed[i] = steps_dist_mm[i] * inverse_secs;
     const feedRate_t cs = ABS(current_speed[i]),
                  max_fr = settings.max_feedrate_mm_s[i];
     if (cs > max_fr) NOMORE(speed_factor, max_fr / cs);
   }
 
   // Limit speed on extruders, if any
   #if HAS_EXTRUDERS
     {
       current_speed.e = steps_dist_mm.e * inverse_secs;
@@ -2373,23 +2455,24 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   // Correct the speed
   if (speed_factor < 1.0f) {
     current_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
     block->nominal_speed_sqr = block->nominal_speed_sqr * sq(speed_factor);
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
-  if (LINEAR_AXIS_GANG(
+  if (NUM_AXIS_GANG(
          !block->steps.a, && !block->steps.b, && !block->steps.c,
-      && !block->steps.i, && !block->steps.j, && !block->steps.k)
+      && !block->steps.i, && !block->steps.j, && !block->steps.k,
+      && !block->steps.u, && !block->steps.v, && !block->steps.w)
   ) {                                                             // Is this a retract / recover move?
     accel = CEIL(settings.retract_acceleration * steps_per_mm);   // Convert to: acceleration steps/sec^2
     TERN_(LIN_ADVANCE, block->use_advance_lead = false);          // No linear advance for simple retract/recover
   }
   else {
     #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
         const uint32_t max_possible = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count / block->steps[AXIS]; \
         NOMORE(accel, max_possible); \
       } \
@@ -2448,32 +2531,38 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
     // Limit acceleration per axis
     if (block->step_event_count <= acceleration_long_cutoff) {
       LOGICAL_AXIS_CODE(
         LIMIT_ACCEL_LONG(E_AXIS, E_INDEX_N(extruder)),
         LIMIT_ACCEL_LONG(A_AXIS, 0),
         LIMIT_ACCEL_LONG(B_AXIS, 0),
         LIMIT_ACCEL_LONG(C_AXIS, 0),
         LIMIT_ACCEL_LONG(I_AXIS, 0),
         LIMIT_ACCEL_LONG(J_AXIS, 0),
-        LIMIT_ACCEL_LONG(K_AXIS, 0)
+        LIMIT_ACCEL_LONG(K_AXIS, 0),
+        LIMIT_ACCEL_LONG(U_AXIS, 0),
+        LIMIT_ACCEL_LONG(V_AXIS, 0),
+        LIMIT_ACCEL_LONG(W_AXIS, 0)
       );
     }
     else {
       LOGICAL_AXIS_CODE(
         LIMIT_ACCEL_FLOAT(E_AXIS, E_INDEX_N(extruder)),
         LIMIT_ACCEL_FLOAT(A_AXIS, 0),
         LIMIT_ACCEL_FLOAT(B_AXIS, 0),
         LIMIT_ACCEL_FLOAT(C_AXIS, 0),
         LIMIT_ACCEL_FLOAT(I_AXIS, 0),
         LIMIT_ACCEL_FLOAT(J_AXIS, 0),
-        LIMIT_ACCEL_FLOAT(K_AXIS, 0)
+        LIMIT_ACCEL_FLOAT(K_AXIS, 0),
+        LIMIT_ACCEL_FLOAT(U_AXIS, 0),
+        LIMIT_ACCEL_FLOAT(V_AXIS, 0),
+        LIMIT_ACCEL_FLOAT(W_AXIS, 0)
       );
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
     block->acceleration_rate = (uint32_t)(accel * (sq(4096.0f) / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
@@ -2524,21 +2613,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           can be spared, a better acos could be used. For all I know, it may be
           already calculated in a different place. */
 
     // Unit vector of previous path line segment
     static xyze_float_t prev_unit_vec;
 
     xyze_float_t unit_vec =
       #if HAS_DIST_MM_ARG
         cart_dist_mm
       #else
-        LOGICAL_AXIS_ARRAY(steps_dist_mm.e, steps_dist_mm.x, steps_dist_mm.y, steps_dist_mm.z, steps_dist_mm.i, steps_dist_mm.j, steps_dist_mm.k)
+        LOGICAL_AXIS_ARRAY(steps_dist_mm.e, steps_dist_mm.x, steps_dist_mm.y, steps_dist_mm.z, steps_dist_mm.i, steps_dist_mm.j, steps_dist_mm.k, steps_dist_mm.u, steps_dist_mm.v, steps_dist_mm.w)
       #endif
     ;
 
     /**
      * On CoreXY the length of the vector [A,B] is SQRT(2) times the length of the head movement vector [X,Y].
      * So taking Z and E into account, we cannot scale to a unit vector with "inverse_millimeters".
      * => normalize the complete junction vector.
      * Elsewise, when needed JD will factor-in the E component
      */
     if (ANY(IS_CORE, MARKFORGED_XY, MARKFORGED_YX) || esteps > 0)
@@ -2550,21 +2639,24 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
       float junction_cos_theta = LOGICAL_AXIS_GANG(
                                  + (-prev_unit_vec.e * unit_vec.e),
                                    (-prev_unit_vec.x * unit_vec.x),
                                  + (-prev_unit_vec.y * unit_vec.y),
                                  + (-prev_unit_vec.z * unit_vec.z),
                                  + (-prev_unit_vec.i * unit_vec.i),
                                  + (-prev_unit_vec.j * unit_vec.j),
-                                 + (-prev_unit_vec.k * unit_vec.k)
+                                 + (-prev_unit_vec.k * unit_vec.k),
+                                 + (-prev_unit_vec.u * unit_vec.u),
+                                 + (-prev_unit_vec.v * unit_vec.v),
+                                 + (-prev_unit_vec.w * unit_vec.w)
                                );
 
       // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
       if (junction_cos_theta > 0.999999f) {
         // For a 0 degree acute junction, just set minimum junction speed.
         vmax_junction_sqr = sq(float(MINIMUM_PLANNER_SPEED));
       }
       else {
         NOLESS(junction_cos_theta, -0.999999f); // Check for numerical round-off to avoid divide by zero.
 
@@ -2697,21 +2789,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
     // Start with a safe speed (from which the machine may halt to stop immediately).
     float safe_speed = nominal_speed;
 
     #ifndef TRAVEL_EXTRA_XYJERK
       #define TRAVEL_EXTRA_XYJERK 0
     #endif
     const float extra_xyjerk = TERN0(HAS_EXTRUDERS, de <= 0) ? TRAVEL_EXTRA_XYJERK : 0;
 
     uint8_t limited = 0;
-    TERN(HAS_LINEAR_E_JERK, LOOP_LINEAR_AXES, LOOP_LOGICAL_AXES)(i) {
+    TERN(HAS_LINEAR_E_JERK, LOOP_NUM_AXES, LOOP_LOGICAL_AXES)(i) {
       const float jerk = ABS(current_speed[i]),   // cs : Starting from zero, change in speed for this axis
                   maxj = (max_jerk[i] + (i == X_AXIS || i == Y_AXIS ? extra_xyjerk : 0.0f)); // mj : The max jerk setting for this axis
       if (jerk > maxj) {                          // cs > mj : New current speed too fast?
         if (limited) {                            // limited already?
           const float mjerk = nominal_speed * maxj; // ns*mj
           if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk; // ns*mj/cs
         }
         else {
           safe_speed *= maxj / jerk;              // Initial limit: ns*mj/cs
           ++limited;                              // Initially limited
@@ -2735,21 +2827,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
       float smaller_speed_factor = 1.0f;
       if (nominal_speed < previous_nominal_speed) {
         vmax_junction = nominal_speed;
         smaller_speed_factor = vmax_junction / previous_nominal_speed;
       }
       else
         vmax_junction = previous_nominal_speed;
 
       // Now limit the jerk in all axes.
-      TERN(HAS_LINEAR_E_JERK, LOOP_LINEAR_AXES, LOOP_LOGICAL_AXES)(axis) {
+      TERN(HAS_LINEAR_E_JERK, LOOP_NUM_AXES, LOOP_LOGICAL_AXES)(axis) {
         // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
         float v_exit = previous_speed[axis] * smaller_speed_factor,
               v_entry = current_speed[axis];
         if (limited) {
           v_exit *= v_factor;
           v_entry *= v_factor;
         }
 
         // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
         const float jerk = (v_exit > v_entry)
@@ -2837,21 +2929,21 @@ void Planner::buffer_sync_block(TERN_(LASER_SYNCHRONOUS_M106_M107, uint8_t sync_
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Clear block
   memset(block, 0, sizeof(block_t));
 
   block->flag = sync_flag;
 
   block->position = position;
   #if ENABLED(BACKLASH_COMPENSATION)
-    LOOP_LINEAR_AXES(axis) block->position[axis] += backlash.get_applied_steps((AxisEnum)axis);
+    LOOP_NUM_AXES(axis) block->position[axis] += backlash.get_applied_steps((AxisEnum)axis);
   #endif
 
   #if BOTH(HAS_FAN, LASER_SYNCHRONOUS_M106_M107)
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
     // give the planner an opportunity to queue more movements and plan them
@@ -2899,21 +2991,24 @@ bool Planner::buffer_segment(const abce_pos_t &abce
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
   const abce_long_t target = {
      LOGICAL_AXIS_LIST(
       int32_t(LROUND(abce.e * settings.axis_steps_per_mm[E_AXIS_N(extruder)])),
       int32_t(LROUND(abce.a * settings.axis_steps_per_mm[A_AXIS])),
       int32_t(LROUND(abce.b * settings.axis_steps_per_mm[B_AXIS])),
       int32_t(LROUND(abce.c * settings.axis_steps_per_mm[C_AXIS])),
       int32_t(LROUND(abce.i * settings.axis_steps_per_mm[I_AXIS])),
       int32_t(LROUND(abce.j * settings.axis_steps_per_mm[J_AXIS])),
-      int32_t(LROUND(abce.k * settings.axis_steps_per_mm[K_AXIS]))
+      int32_t(LROUND(abce.k * settings.axis_steps_per_mm[K_AXIS])),
+      int32_t(LROUND(abce.u * settings.axis_steps_per_mm[U_AXIS])),
+      int32_t(LROUND(abce.v * settings.axis_steps_per_mm[V_AXIS])),
+      int32_t(LROUND(abce.w * settings.axis_steps_per_mm[W_AXIS]))
     )
   };
 
   #if HAS_POSITION_FLOAT
     const xyze_pos_t target_float = abce;
   #endif
 
   #if HAS_EXTRUDERS
     // DRYRUN prevents E moves from taking place
     if (DEBUGGING(DRYRUN) || TERN0(CANCEL_OBJECTS, cancelable.skipping)) {
@@ -2951,20 +3046,35 @@ bool Planner::buffer_segment(const abce_pos_t &abce
     #if HAS_J_AXIS
       SERIAL_ECHOPGM_P(SP_J_LBL, abce.j);
       SERIAL_ECHOPGM(" (", position.j, "->", target.j);
       SERIAL_CHAR(')');
     #endif
     #if HAS_K_AXIS
       SERIAL_ECHOPGM_P(SP_K_LBL, abce.k);
       SERIAL_ECHOPGM(" (", position.k, "->", target.k);
       SERIAL_CHAR(')');
     #endif
+    #if HAS_U_AXIS
+      SERIAL_ECHOPGM_P(SP_U_LBL, abce.u);
+      SERIAL_ECHOPGM(" (", position.u, "->", target.u);
+      SERIAL_CHAR(')');
+    #endif
+    #if HAS_V_AXIS
+      SERIAL_ECHOPGM_P(SP_V_LBL, abce.v);
+      SERIAL_ECHOPGM(" (", position.v, "->", target.v);
+      SERIAL_CHAR(')');
+    #endif
+    #if HAS_W_AXIS
+      SERIAL_ECHOPGM_P(SP_W_LBL, abce.w);
+      SERIAL_ECHOPGM(" (", position.w, "->", target.w);
+      SERIAL_CHAR(')');
+    #endif
     #if HAS_EXTRUDERS
       SERIAL_ECHOPGM_P(SP_E_LBL, abce.e);
       SERIAL_ECHOLNPGM(" (", position.e, "->", target.e, ")");
     #else
       SERIAL_EOL();
     #endif
   //*/
 
   // Queue the movement. Return 'false' if the move was not queued.
   if (!_buffer_steps(target
@@ -2993,26 +3103,28 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s, cons
 ) {
   xyze_pos_t machine = cart;
   TERN_(HAS_POSITION_MODIFIERS, apply_modifiers(machine));
 
   #if IS_KINEMATIC
 
     #if HAS_JUNCTION_DEVIATION
       const xyze_pos_t cart_dist_mm = LOGICAL_AXIS_ARRAY(
         cart.e - position_cart.e,
         cart.x - position_cart.x, cart.y - position_cart.y, cart.z - position_cart.z,
-        cart.i - position_cart.i, cart.j - position_cart.j, cart.j - position_cart.k
+        cart.i - position_cart.i, cart.j - position_cart.j, cart.k - position_cart.k,
+        cart.u - position_cart.u, cart.v - position_cart.v, cart.w - position_cart.w
       );
     #else
-      const xyz_pos_t cart_dist_mm = LINEAR_AXIS_ARRAY(
+      const xyz_pos_t cart_dist_mm = NUM_AXIS_ARRAY(
         cart.x - position_cart.x, cart.y - position_cart.y, cart.z - position_cart.z,
-        cart.i - position_cart.i, cart.j - position_cart.j, cart.j - position_cart.k
+        cart.i - position_cart.i, cart.j - position_cart.j, cart.k - position_cart.k,
+        cart.u - position_cart.u, cart.v - position_cart.v, cart.w - position_cart.w
       );
     #endif
 
     const float mm = millimeters ?: (cart_dist_mm.x || cart_dist_mm.y) ? cart_dist_mm.magnitude() : TERN0(HAS_Z_AXIS, ABS(cart_dist_mm.z));
 
     // Cartesian XYZ to kinematic ABC, stored in global 'delta'
     inverse_kinematics(machine);
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
@@ -3103,33 +3215,36 @@ void Planner::set_machine_position_mm(const abce_pos_t &abce) {
   TERN_(DISTINCT_E_FACTORS, last_extruder = active_extruder);
   TERN_(HAS_POSITION_FLOAT, position_float = abce);
   position.set(
     LOGICAL_AXIS_LIST(
       LROUND(abce.e * settings.axis_steps_per_mm[E_AXIS_N(active_extruder)]),
       LROUND(abce.a * settings.axis_steps_per_mm[A_AXIS]),
       LROUND(abce.b * settings.axis_steps_per_mm[B_AXIS]),
       LROUND(abce.c * settings.axis_steps_per_mm[C_AXIS]),
       LROUND(abce.i * settings.axis_steps_per_mm[I_AXIS]),
       LROUND(abce.j * settings.axis_steps_per_mm[J_AXIS]),
-      LROUND(abce.k * settings.axis_steps_per_mm[K_AXIS])
+      LROUND(abce.k * settings.axis_steps_per_mm[K_AXIS]),
+      LROUND(abce.u * settings.axis_steps_per_mm[U_AXIS]),
+      LROUND(abce.v * settings.axis_steps_per_mm[V_AXIS]),
+      LROUND(abce.w * settings.axis_steps_per_mm[W_AXIS])
     )
   );
 
   if (has_blocks_queued()) {
     //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.
     //previous_speed.reset();
     buffer_sync_block();
   }
   else {
     #if ENABLED(BACKLASH_COMPENSATION)
       abce_long_t stepper_pos = position;
-      LOOP_LINEAR_AXES(axis) stepper_pos[axis] += backlash.get_applied_steps((AxisEnum)axis);
+      LOOP_NUM_AXES(axis) stepper_pos[axis] += backlash.get_applied_steps((AxisEnum)axis);
       stepper.set_position(stepper_pos);
     #else
       stepper.set_position(position);
     #endif
   }
 }
 
 void Planner::set_position_mm(const xyze_pos_t &xyze) {
   xyze_pos_t machine = xyze;
   TERN_(HAS_POSITION_MODIFIERS, apply_modifiers(machine, true));

commit ae53033cea506209310fb014b304f3a07c59e9d7
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Apr 1 03:13:16 2022 +0100

    ‚ôªÔ∏è Refactor and fix ABL Bilinear (#23868)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index a3caa199c1..8c723aa06e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1584,21 +1584,21 @@ void Planner::check_axes_activity() {
       #elif DISABLED(MESH_BED_LEVELING)
         constexpr float fade_scaling_factor = 1.0;
       #endif
 
       raw.z += (
         #if ENABLED(MESH_BED_LEVELING)
           mbl.get_z(raw OPTARG(ENABLE_LEVELING_FADE_HEIGHT, fade_scaling_factor))
         #elif ENABLED(AUTO_BED_LEVELING_UBL)
           fade_scaling_factor ? fade_scaling_factor * ubl.get_z_correction(raw) : 0.0
         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-          fade_scaling_factor ? fade_scaling_factor * bilinear_z_offset(raw) : 0.0
+          fade_scaling_factor ? fade_scaling_factor * bbl.get_z_correction(raw) : 0.0
         #endif
       );
 
     #endif
   }
 
   void Planner::unapply_leveling(xyz_pos_t &raw) {
 
     if (leveling_active) {
 
@@ -1617,21 +1617,21 @@ void Planner::check_axes_activity() {
         #elif DISABLED(MESH_BED_LEVELING)
           constexpr float fade_scaling_factor = 1.0;
         #endif
 
         raw.z -= (
           #if ENABLED(MESH_BED_LEVELING)
             mbl.get_z(raw OPTARG(ENABLE_LEVELING_FADE_HEIGHT, fade_scaling_factor))
           #elif ENABLED(AUTO_BED_LEVELING_UBL)
             fade_scaling_factor ? fade_scaling_factor * ubl.get_z_correction(raw) : 0.0
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-            fade_scaling_factor ? fade_scaling_factor * bilinear_z_offset(raw) : 0.0
+            fade_scaling_factor ? fade_scaling_factor * bbl.get_z_correction(raw) : 0.0
           #endif
         );
 
       #endif
     }
   }
 
 #endif // HAS_LEVELING
 
 #if ENABLED(FWRETRACT)

commit a80a303cbe057b02e8d9cd29bc94c161e48784f1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 22 22:22:08 2022 -0500

    üßë‚Äçüíª EXTRUDER_LOOP macro

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 51440aac26..a3caa199c1 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1498,21 +1498,21 @@ void Planner::check_axes_activity() {
 #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
 
   /**
    * Convert volumetric based limits into pre calculated extruder feedrate limits.
    */
   void Planner::calculate_volumetric_extruder_limit(const uint8_t e) {
     const float &lim = volumetric_extruder_limit[e], &siz = filament_size[e];
     volumetric_extruder_feedrate_limit[e] = (lim && siz) ? lim / CIRCLE_AREA(siz * 0.5f) : 0;
   }
   void Planner::calculate_volumetric_extruder_limits() {
-    LOOP_L_N(e, EXTRUDERS) calculate_volumetric_extruder_limit(e);
+    EXTRUDER_LOOP() calculate_volumetric_extruder_limit(e);
   }
 
 #endif
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   /**
    * Convert the ratio value given by the filament width sensor
    * into a volumetric multiplier. Conversion differs when using
    * linear extrusion vs volumetric extrusion.
    */

commit 6b7868d943cd08b83af085ea0d507cc8433799c6
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Tue Mar 1 22:14:52 2022 +0000

    üêõ Fix backlash applied steps when config changes (#23826)
    
    Followup to #23814

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 37b264a3c5..51440aac26 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1699,21 +1699,21 @@ void Planner::quick_stop() {
   }
 
 #endif
 
 void Planner::endstop_triggered(const AxisEnum axis) {
   // Record stepper position and discard the current block
   stepper.endstop_triggered(axis);
 }
 
 float Planner::triggered_position_mm(const AxisEnum axis) {
-  const float result = DIFF_TERN(BACKLASH_COMPENSATION, stepper.triggered_position(axis), backlash.applied_steps(axis));
+  const float result = DIFF_TERN(BACKLASH_COMPENSATION, stepper.triggered_position(axis), backlash.get_applied_steps(axis));
   return result * mm_per_step[axis];
 }
 
 void Planner::finish_and_disable() {
   while (has_blocks_queued() || cleaning_buffer_counter) idle();
   stepper.disable_all_steppers();
 }
 
 /**
  * Get an axis position according to stepper position(s)
@@ -1722,53 +1722,53 @@ void Planner::finish_and_disable() {
 float Planner::get_axis_position_mm(const AxisEnum axis) {
   float axis_steps;
   #if IS_CORE
 
     // Requesting one of the "core" axes?
     if (axis == CORE_AXIS_1 || axis == CORE_AXIS_2) {
 
       // Protect the access to the position.
       const bool was_enabled = stepper.suspend();
 
-      const int32_t p1 = DIFF_TERN(BACKLASH_COMPENSATION, stepper.position(CORE_AXIS_1), backlash.applied_steps(CORE_AXIS_1)),
-                    p2 = DIFF_TERN(BACKLASH_COMPENSATION, stepper.position(CORE_AXIS_2), backlash.applied_steps(CORE_AXIS_2));
+      const int32_t p1 = DIFF_TERN(BACKLASH_COMPENSATION, stepper.position(CORE_AXIS_1), backlash.get_applied_steps(CORE_AXIS_1)),
+                    p2 = DIFF_TERN(BACKLASH_COMPENSATION, stepper.position(CORE_AXIS_2), backlash.get_applied_steps(CORE_AXIS_2));
 
       if (was_enabled) stepper.wake_up();
 
       // ((a1+a2)+(a1-a2))/2 -> (a1+a2+a1-a2)/2 -> (a1+a1)/2 -> a1
       // ((a1+a2)-(a1-a2))/2 -> (a1+a2-a1+a2)/2 -> (a2+a2)/2 -> a2
       axis_steps = (axis == CORE_AXIS_2 ? CORESIGN(p1 - p2) : p1 + p2) * 0.5f;
     }
     else
-      axis_steps = DIFF_TERN(BACKLASH_COMPENSATION, stepper.position(axis), backlash.applied_steps(axis));
+      axis_steps = DIFF_TERN(BACKLASH_COMPENSATION, stepper.position(axis), backlash.get_applied_steps(axis));
 
   #elif EITHER(MARKFORGED_XY, MARKFORGED_YX)
 
     // Requesting one of the joined axes?
     if (axis == CORE_AXIS_1 || axis == CORE_AXIS_2) {
       // Protect the access to the position.
       const bool was_enabled = stepper.suspend();
 
       const int32_t p1 = stepper.position(CORE_AXIS_1),
                     p2 = stepper.position(CORE_AXIS_2);
 
       if (was_enabled) stepper.wake_up();
 
       axis_steps = ((axis == CORE_AXIS_1) ? p1 - p2 : p2);
     }
     else
-      axis_steps = DIFF_TERN(BACKLASH_COMPENSATION, stepper.position(axis), backlash.applied_steps(axis));
+      axis_steps = DIFF_TERN(BACKLASH_COMPENSATION, stepper.position(axis), backlash.get_applied_steps(axis));
 
   #else
 
     axis_steps = stepper.position(axis);
-    TERN_(BACKLASH_COMPENSATION, axis_steps -= backlash.applied_steps(axis));
+    TERN_(BACKLASH_COMPENSATION, axis_steps -= backlash.get_applied_steps(axis));
 
   #endif
 
   return axis_steps * mm_per_step[axis];
 }
 
 /**
  * Block until the planner is finished processing
  */
 void Planner::synchronize() { while (busy()) idle(); }
@@ -2837,21 +2837,21 @@ void Planner::buffer_sync_block(TERN_(LASER_SYNCHRONOUS_M106_M107, uint8_t sync_
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Clear block
   memset(block, 0, sizeof(block_t));
 
   block->flag = sync_flag;
 
   block->position = position;
   #if ENABLED(BACKLASH_COMPENSATION)
-    LOOP_LINEAR_AXES(axis) block->position[axis] += backlash.applied_steps((AxisEnum)axis);
+    LOOP_LINEAR_AXES(axis) block->position[axis] += backlash.get_applied_steps((AxisEnum)axis);
   #endif
 
   #if BOTH(HAS_FAN, LASER_SYNCHRONOUS_M106_M107)
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
     // give the planner an opportunity to queue more movements and plan them
@@ -3115,21 +3115,21 @@ void Planner::set_machine_position_mm(const abce_pos_t &abce) {
   );
 
   if (has_blocks_queued()) {
     //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.
     //previous_speed.reset();
     buffer_sync_block();
   }
   else {
     #if ENABLED(BACKLASH_COMPENSATION)
       abce_long_t stepper_pos = position;
-      LOOP_LINEAR_AXES(axis) stepper_pos[axis] += backlash.applied_steps((AxisEnum)axis);
+      LOOP_LINEAR_AXES(axis) stepper_pos[axis] += backlash.get_applied_steps((AxisEnum)axis);
       stepper.set_position(stepper_pos);
     #else
       stepper.set_position(position);
     #endif
   }
 }
 
 void Planner::set_position_mm(const xyze_pos_t &xyze) {
   xyze_pos_t machine = xyze;
   TERN_(HAS_POSITION_MODIFIERS, apply_modifiers(machine, true));

commit 87c4cd20e514b9fc94450e9503e268cc014490e8
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sat Feb 26 20:30:33 2022 +0000

    üêõ Fix steps-to-mm with backlash (#23814)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index d2e11f62fe..37b264a3c5 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1699,21 +1699,22 @@ void Planner::quick_stop() {
   }
 
 #endif
 
 void Planner::endstop_triggered(const AxisEnum axis) {
   // Record stepper position and discard the current block
   stepper.endstop_triggered(axis);
 }
 
 float Planner::triggered_position_mm(const AxisEnum axis) {
-  return stepper.triggered_position(axis) * mm_per_step[axis];
+  const float result = DIFF_TERN(BACKLASH_COMPENSATION, stepper.triggered_position(axis), backlash.applied_steps(axis));
+  return result * mm_per_step[axis];
 }
 
 void Planner::finish_and_disable() {
   while (has_blocks_queued() || cleaning_buffer_counter) idle();
   stepper.disable_all_steppers();
 }
 
 /**
  * Get an axis position according to stepper position(s)
  * For CORE machines apply translation from ABC to XYZ.
@@ -1721,52 +1722,53 @@ void Planner::finish_and_disable() {
 float Planner::get_axis_position_mm(const AxisEnum axis) {
   float axis_steps;
   #if IS_CORE
 
     // Requesting one of the "core" axes?
     if (axis == CORE_AXIS_1 || axis == CORE_AXIS_2) {
 
       // Protect the access to the position.
       const bool was_enabled = stepper.suspend();
 
-      const int32_t p1 = stepper.position(CORE_AXIS_1),
-                    p2 = stepper.position(CORE_AXIS_2);
+      const int32_t p1 = DIFF_TERN(BACKLASH_COMPENSATION, stepper.position(CORE_AXIS_1), backlash.applied_steps(CORE_AXIS_1)),
+                    p2 = DIFF_TERN(BACKLASH_COMPENSATION, stepper.position(CORE_AXIS_2), backlash.applied_steps(CORE_AXIS_2));
 
       if (was_enabled) stepper.wake_up();
 
       // ((a1+a2)+(a1-a2))/2 -> (a1+a2+a1-a2)/2 -> (a1+a1)/2 -> a1
       // ((a1+a2)-(a1-a2))/2 -> (a1+a2-a1+a2)/2 -> (a2+a2)/2 -> a2
       axis_steps = (axis == CORE_AXIS_2 ? CORESIGN(p1 - p2) : p1 + p2) * 0.5f;
     }
     else
-      axis_steps = stepper.position(axis);
+      axis_steps = DIFF_TERN(BACKLASH_COMPENSATION, stepper.position(axis), backlash.applied_steps(axis));
 
   #elif EITHER(MARKFORGED_XY, MARKFORGED_YX)
 
     // Requesting one of the joined axes?
     if (axis == CORE_AXIS_1 || axis == CORE_AXIS_2) {
       // Protect the access to the position.
       const bool was_enabled = stepper.suspend();
 
       const int32_t p1 = stepper.position(CORE_AXIS_1),
                     p2 = stepper.position(CORE_AXIS_2);
 
       if (was_enabled) stepper.wake_up();
 
       axis_steps = ((axis == CORE_AXIS_1) ? p1 - p2 : p2);
     }
     else
-      axis_steps = stepper.position(axis);
+      axis_steps = DIFF_TERN(BACKLASH_COMPENSATION, stepper.position(axis), backlash.applied_steps(axis));
 
   #else
 
     axis_steps = stepper.position(axis);
+    TERN_(BACKLASH_COMPENSATION, axis_steps -= backlash.applied_steps(axis));
 
   #endif
 
   return axis_steps * mm_per_step[axis];
 }
 
 /**
  * Block until the planner is finished processing
  */
 void Planner::synchronize() { while (busy()) idle(); }
@@ -2834,20 +2836,23 @@ void Planner::buffer_sync_block(TERN_(LASER_SYNCHRONOUS_M106_M107, uint8_t sync_
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Clear block
   memset(block, 0, sizeof(block_t));
 
   block->flag = sync_flag;
 
   block->position = position;
+  #if ENABLED(BACKLASH_COMPENSATION)
+    LOOP_LINEAR_AXES(axis) block->position[axis] += backlash.applied_steps((AxisEnum)axis);
+  #endif
 
   #if BOTH(HAS_FAN, LASER_SYNCHRONOUS_M106_M107)
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
     // give the planner an opportunity to queue more movements and plan them
     // As there are no queued movements, the Stepper ISR will not touch this
@@ -3101,27 +3106,35 @@ void Planner::set_machine_position_mm(const abce_pos_t &abce) {
     LOGICAL_AXIS_LIST(
       LROUND(abce.e * settings.axis_steps_per_mm[E_AXIS_N(active_extruder)]),
       LROUND(abce.a * settings.axis_steps_per_mm[A_AXIS]),
       LROUND(abce.b * settings.axis_steps_per_mm[B_AXIS]),
       LROUND(abce.c * settings.axis_steps_per_mm[C_AXIS]),
       LROUND(abce.i * settings.axis_steps_per_mm[I_AXIS]),
       LROUND(abce.j * settings.axis_steps_per_mm[J_AXIS]),
       LROUND(abce.k * settings.axis_steps_per_mm[K_AXIS])
     )
   );
+
   if (has_blocks_queued()) {
     //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.
     //previous_speed.reset();
     buffer_sync_block();
   }
-  else
-    stepper.set_position(position);
+  else {
+    #if ENABLED(BACKLASH_COMPENSATION)
+      abce_long_t stepper_pos = position;
+      LOOP_LINEAR_AXES(axis) stepper_pos[axis] += backlash.applied_steps((AxisEnum)axis);
+      stepper.set_position(stepper_pos);
+    #else
+      stepper.set_position(position);
+    #endif
+  }
 }
 
 void Planner::set_position_mm(const xyze_pos_t &xyze) {
   xyze_pos_t machine = xyze;
   TERN_(HAS_POSITION_MODIFIERS, apply_modifiers(machine, true));
   #if IS_KINEMATIC
     position_cart = xyze;
     inverse_kinematics(machine);
     TERN_(HAS_EXTRUDERS, delta.e = machine.e);
     set_machine_position_mm(delta);

commit 44eff9a23348dcc117fd1ea9b4b1ef0b54061808
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Feb 17 18:50:31 2022 -0600

    ‚ôªÔ∏è Refactor HAL as singleton (#23357)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index f9ddcf8f13..d2e11f62fe 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -696,21 +696,21 @@ void Planner::init() {
         : "r0", "r1", "cc"
       );
 
       // Return the result
       return r11 | (uint16_t(r12) << 8) | (uint32_t(r13) << 16);
     }
   #else
     // All other 32-bit MPUs can easily do inverse using hardware division,
     // so we don't need to reduce precision or to use assembly language at all.
     // This routine, for all other archs, returns 0x100000000 / d ~= 0xFFFFFFFF / d
-    static FORCE_INLINE uint32_t get_period_inverse(const uint32_t d) {
+    FORCE_INLINE static uint32_t get_period_inverse(const uint32_t d) {
       return d ? 0xFFFFFFFF / d : 0xFFFFFFFF;
     }
   #endif
 #endif
 
 #define MINIMAL_STEP_RATE 120
 
 /**
  * Get the current block for processing
  * and mark the block as busy.
@@ -1253,21 +1253,21 @@ void Planner::recalculate() {
 
     #if FAN_MIN_PWM != 0 || FAN_MAX_PWM != 255
       #define CALC_FAN_SPEED(f) (fan_speed[f] ? map(fan_speed[f], 1, 255, FAN_MIN_PWM, FAN_MAX_PWM) : FAN_OFF_PWM)
     #else
       #define CALC_FAN_SPEED(f) (fan_speed[f] ?: FAN_OFF_PWM)
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       #define _FAN_SET(F) thermalManager.soft_pwm_amount_fan[F] = CALC_FAN_SPEED(F);
     #else
-      #define _FAN_SET(F) set_pwm_duty(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(F));
+      #define _FAN_SET(F) hal.set_pwm_duty(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(F));
     #endif
     #define FAN_SET(F) do{ kickstart_fan(fan_speed, ms, F); _FAN_SET(F); }while(0)
 
     const millis_t ms = millis();
     TERN_(HAS_FAN0, FAN_SET(0));
     TERN_(HAS_FAN1, FAN_SET(1));
     TERN_(HAS_FAN2, FAN_SET(2));
     TERN_(HAS_FAN3, FAN_SET(3));
     TERN_(HAS_FAN4, FAN_SET(4));
     TERN_(HAS_FAN5, FAN_SET(5));
@@ -1390,22 +1390,22 @@ void Planner::check_axes_activity() {
 
   //
   // Update Fan speeds
   // Only if synchronous M106/M107 is disabled
   //
   TERN_(HAS_TAIL_FAN_SPEED, if (fans_need_update) sync_fan_speeds(tail_fan_speed));
 
   TERN_(AUTOTEMP, autotemp_task());
 
   #if ENABLED(BARICUDA)
-    TERN_(HAS_HEATER_1, set_pwm_duty(pin_t(HEATER_1_PIN), tail_valve_pressure));
-    TERN_(HAS_HEATER_2, set_pwm_duty(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
+    TERN_(HAS_HEATER_1, hal.set_pwm_duty(pin_t(HEATER_1_PIN), tail_valve_pressure));
+    TERN_(HAS_HEATER_2, hal.set_pwm_duty(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
   #endif
 }
 
 #if ENABLED(AUTOTEMP)
 
   #if ENABLED(AUTOTEMP_PROPORTIONAL)
     void Planner::_autotemp_update_from_hotend() {
       const celsius_t target = thermalManager.degTargetHotend(active_extruder);
       autotemp_min = target + AUTOTEMP_MIN_P;
       autotemp_max = target + AUTOTEMP_MAX_P;

commit a323d6732bf691d29ce996b6bfd11cbcc3c9f0a7
Author: MOHAMMAD RASIM <mohammad.rasim96@gmail.com>
Date:   Wed Feb 9 21:29:34 2022 +0300

    üö∏ Fix, Improve Power-Loss Recovery (#22828)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 8d8f44dc78..f9ddcf8f13 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2802,23 +2802,27 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
   block->flag |= block->nominal_speed_sqr <= v_allowable_sqr ? BLOCK_FLAG_RECALCULATE | BLOCK_FLAG_NOMINAL_LENGTH : BLOCK_FLAG_RECALCULATE;
 
   // Update previous path unit_vector and nominal speed
   previous_speed = current_speed;
   previous_nominal_speed_sqr = block->nominal_speed_sqr;
 
   position = target;  // Update the position
 
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    block->sdpos = recovery.command_sdpos();
+    block->start_position = position_float.asLogical();
+  #endif
+
   TERN_(HAS_POSITION_FLOAT, position_float = target_float);
   TERN_(GRADIENT_MIX, mixer.gradient_control(target_float.z));
-  TERN_(POWER_LOSS_RECOVERY, block->sdpos = recovery.command_sdpos());
 
   return true;        // Movement was accepted
 
 } // _populate_block()
 
 /**
  * Planner::buffer_sync_block
  * Add a block to the buffer that just updates the position,
  * or in case of LASER_SYNCHRONOUS_M106_M107 the fan PWM
  */

commit 9778b67e84b1ff022669b7327a297d6cd44d4ed2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jan 15 23:17:39 2022 -0600

    ü©π Fan speed followup

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index aae997c48a..8d8f44dc78 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1385,26 +1385,21 @@ void Planner::check_axes_activity() {
     if (TERN0(DISABLE_Z, !axis_active.z)) stepper.disable_axis(Z_AXIS),
     if (TERN0(DISABLE_I, !axis_active.i)) stepper.disable_axis(I_AXIS),
     if (TERN0(DISABLE_J, !axis_active.j)) stepper.disable_axis(J_AXIS),
     if (TERN0(DISABLE_K, !axis_active.k)) stepper.disable_axis(K_AXIS)
   );
 
   //
   // Update Fan speeds
   // Only if synchronous M106/M107 is disabled
   //
-  #if HAS_TAIL_FAN_SPEED
-    if (fans_need_update) {
-      sync_fan_speeds(tail_fan_speed);
-      fans_need_update = false;
-    }
-  #endif
+  TERN_(HAS_TAIL_FAN_SPEED, if (fans_need_update) sync_fan_speeds(tail_fan_speed));
 
   TERN_(AUTOTEMP, autotemp_task());
 
   #if ENABLED(BARICUDA)
     TERN_(HAS_HEATER_1, set_pwm_duty(pin_t(HEATER_1_PIN), tail_valve_pressure));
     TERN_(HAS_HEATER_2, set_pwm_duty(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
   #endif
 }
 
 #if ENABLED(AUTOTEMP)

commit 09909512d721b41fcd1fbb85bfe2fbc138990eff
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Sat Jan 15 23:05:53 2022 -0600

    üêõ Fix, improve PWM on AVR (#23520)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 6979fa6a80..aae997c48a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1237,24 +1237,20 @@ void Planner::recalculate() {
   // Initialize block index to the last block in the planner buffer.
   const uint8_t block_index = prev_block_index(block_buffer_head);
   // If there is just one block, no planning can be done. Avoid it!
   if (block_index != block_buffer_planned) {
     reverse_pass();
     forward_pass();
   }
   recalculate_trapezoids();
 }
 
-#if HAS_FAN && DISABLED(LASER_SYNCHRONOUS_M106_M107)
-  #define HAS_TAIL_FAN_SPEED 1
-#endif
-
 /**
  * Apply fan speeds
  */
 #if HAS_FAN
 
   void Planner::sync_fan_speeds(uint8_t (&fan_speed)[FAN_COUNT]) {
 
     #if FAN_MIN_PWM != 0 || FAN_MAX_PWM != 255
       #define CALC_FAN_SPEED(f) (fan_speed[f] ? map(fan_speed[f], 1, 255, FAN_MIN_PWM, FAN_MAX_PWM) : FAN_OFF_PWM)
     #else
@@ -1301,22 +1297,23 @@ void Planner::recalculate() {
 
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
 
   #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_I, DISABLE_J, DISABLE_K, DISABLE_E)
     xyze_bool_t axis_active = { false };
   #endif
 
-  #if HAS_TAIL_FAN_SPEED
-    static uint8_t tail_fan_speed[FAN_COUNT] = ARRAY_N_1(FAN_COUNT, 255);
+  #if HAS_FAN && DISABLED(LASER_SYNCHRONOUS_M106_M107)
+    #define HAS_TAIL_FAN_SPEED 1
+    static uint8_t tail_fan_speed[FAN_COUNT] = ARRAY_N_1(FAN_COUNT, 128);
     bool fans_need_update = false;
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
     #endif
     #if HAS_HEATER_2
       uint8_t tail_e_to_p_pressure;
     #endif
@@ -1388,21 +1385,26 @@ void Planner::check_axes_activity() {
     if (TERN0(DISABLE_Z, !axis_active.z)) stepper.disable_axis(Z_AXIS),
     if (TERN0(DISABLE_I, !axis_active.i)) stepper.disable_axis(I_AXIS),
     if (TERN0(DISABLE_J, !axis_active.j)) stepper.disable_axis(J_AXIS),
     if (TERN0(DISABLE_K, !axis_active.k)) stepper.disable_axis(K_AXIS)
   );
 
   //
   // Update Fan speeds
   // Only if synchronous M106/M107 is disabled
   //
-  TERN_(HAS_TAIL_FAN_SPEED, if (fans_need_update) sync_fan_speeds(tail_fan_speed));
+  #if HAS_TAIL_FAN_SPEED
+    if (fans_need_update) {
+      sync_fan_speeds(tail_fan_speed);
+      fans_need_update = false;
+    }
+  #endif
 
   TERN_(AUTOTEMP, autotemp_task());
 
   #if ENABLED(BARICUDA)
     TERN_(HAS_HEATER_1, set_pwm_duty(pin_t(HEATER_1_PIN), tail_valve_pressure));
     TERN_(HAS_HEATER_2, set_pwm_duty(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
   #endif
 }
 
 #if ENABLED(AUTOTEMP)

commit 40481947fc1f11a01235c5c55333a4437fc45c5f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 14 03:14:13 2022 -0600

    üßë‚Äçüíª Misc. updates for extra axes (#23521)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 17d279cfa5..6979fa6a80 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2034,29 +2034,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       steps_dist_mm.head.z = dc * mm_per_step[C_AXIS];
       steps_dist_mm.a      = (da + dc) * mm_per_step[A_AXIS];
       steps_dist_mm.c      = CORESIGN(da - dc) * mm_per_step[C_AXIS];
     #elif CORE_IS_YZ
       steps_dist_mm.x      = da * mm_per_step[X_AXIS];
       steps_dist_mm.head.y = db * mm_per_step[B_AXIS];
       steps_dist_mm.head.z = dc * mm_per_step[C_AXIS];
       steps_dist_mm.b      = (db + dc) * mm_per_step[B_AXIS];
       steps_dist_mm.c      = CORESIGN(db - dc) * mm_per_step[C_AXIS];
     #endif
-    #if HAS_I_AXIS
-      steps_dist_mm.i = di * mm_per_step[I_AXIS];
-    #endif
-    #if HAS_J_AXIS
-      steps_dist_mm.j = dj * mm_per_step[J_AXIS];
-    #endif
-    #if HAS_K_AXIS
-      steps_dist_mm.k = dk * mm_per_step[K_AXIS];
-    #endif
+    TERN_(HAS_I_AXIS, steps_dist_mm.i = di * mm_per_step[I_AXIS]);
+    TERN_(HAS_J_AXIS, steps_dist_mm.j = dj * mm_per_step[J_AXIS]);
+    TERN_(HAS_K_AXIS, steps_dist_mm.k = dk * mm_per_step[K_AXIS]);
   #elif ENABLED(MARKFORGED_XY)
     steps_dist_mm.a      = (da - db) * mm_per_step[A_AXIS];
     steps_dist_mm.b      = db * mm_per_step[B_AXIS];
   #elif ENABLED(MARKFORGED_YX)
     steps_dist_mm.a      = da * mm_per_step[A_AXIS];
     steps_dist_mm.b      = (db - da) * mm_per_step[B_AXIS];
   #else
     LINEAR_AXIS_CODE(
       steps_dist_mm.a = da * mm_per_step[A_AXIS],
       steps_dist_mm.b = db * mm_per_step[B_AXIS],
@@ -2190,29 +2184,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     LINEAR_AXIS_CODE(
       if (block->steps.x) stepper.enable_axis(X_AXIS),
       if (block->steps.y) stepper.enable_axis(Y_AXIS),
       if (TERN(Z_LATE_ENABLE, 0, block->steps.z)) stepper.enable_axis(Z_AXIS),
       if (block->steps.i) stepper.enable_axis(I_AXIS),
       if (block->steps.j) stepper.enable_axis(J_AXIS),
       if (block->steps.k) stepper.enable_axis(K_AXIS)
     );
   #endif
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
-    #if HAS_I_AXIS
-      if (block->steps.i) stepper.enable_axis(I_AXIS);
-    #endif
-    #if HAS_J_AXIS
-      if (block->steps.j) stepper.enable_axis(J_AXIS);
-    #endif
-    #if HAS_K_AXIS
-      if (block->steps.k) stepper.enable_axis(K_AXIS);
-    #endif
+    TERN_(HAS_I_AXIS, if (block->steps.i) stepper.enable_axis(I_AXIS));
+    TERN_(HAS_J_AXIS, if (block->steps.j) stepper.enable_axis(J_AXIS));
+    TERN_(HAS_K_AXIS, if (block->steps.k) stepper.enable_axis(K_AXIS));
   #endif
 
   // Enable extruder(s)
   #if HAS_EXTRUDERS
     if (esteps) {
       TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
         // Count down all steppers that were recently moved
@@ -2253,21 +2241,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   // Calculate inverse time for this move. No divide by zero due to previous checks.
   // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   float inverse_secs = fr_mm_s * inverse_millimeters;
 
   // Get the number of non busy movements in queue (non busy means that they can be altered)
   const uint8_t moves_queued = nonbusy_movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if EITHER(SLOWDOWN, HAS_WIRED_LCD) || defined(XY_FREQUENCY_LIMIT)
-    // Segment time im micro seconds
+    // Segment time in microseconds
     int32_t segment_time_us = LROUND(1000000.0f / inverse_secs);
   #endif
 
   #if ENABLED(SLOWDOWN)
     #ifndef SLOWDOWN_DIVISOR
       #define SLOWDOWN_DIVISOR 2
     #endif
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / (SLOWDOWN_DIVISOR) - 1)) {
       const int32_t time_diff = settings.min_segment_time_us - segment_time_us;
       if (time_diff > 0) {
@@ -2412,21 +2400,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
         const float max_possible = float(max_acceleration_steps_per_s2[AXIS+INDX]) * float(block->step_event_count) / float(block->steps[AXIS]); \
         NOMORE(accel, max_possible); \
       } \
     }while(0)
 
     // Start with print or travel acceleration
     accel = CEIL((esteps ? settings.acceleration : settings.travel_acceleration) * steps_per_mm);
 
     #if ENABLED(LIN_ADVANCE)
-
+      // Linear advance is currently not ready for HAS_I_AXIS
       #define MAX_E_JERK(N) TERN(HAS_LINEAR_E_JERK, max_e_jerk[E_INDEX_N(N)], max_jerk.e)
 
       /**
        * Use LIN_ADVANCE for blocks if all these are true:
        *
        * esteps             : This is a print move, because we checked for A, B, C steps before.
        *
        * extruder_advance_K[active_extruder] : There is an advance factor set for this extruder.
        *
        * de > 0             : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
@@ -2932,21 +2920,21 @@ bool Planner::buffer_segment(const abce_pos_t &abce
     SERIAL_ECHOPGM("  buffer_segment FR:", fr_mm_s);
     #if IS_KINEMATIC
       SERIAL_ECHOPGM(" A:", abce.a, " (", position.a, "->", target.a, ") B:", abce.b);
     #else
       SERIAL_ECHOPGM_P(SP_X_LBL, abce.a);
       SERIAL_ECHOPGM(" (", position.x, "->", target.x);
       SERIAL_CHAR(')');
       SERIAL_ECHOPGM_P(SP_Y_LBL, abce.b);
     #endif
     SERIAL_ECHOPGM(" (", position.y, "->", target.y);
-    #if LINEAR_AXES >= ABC
+    #if HAS_Z_AXIS
       #if ENABLED(DELTA)
         SERIAL_ECHOPGM(") C:", abce.c);
       #else
         SERIAL_CHAR(')');
         SERIAL_ECHOPGM_P(SP_Z_LBL, abce.c);
       #endif
       SERIAL_ECHOPGM(" (", position.z, "->", target.z);
       SERIAL_CHAR(')');
     #endif
     #if HAS_I_AXIS

commit 3e2a38b653b1d8479b7b38447d5fdff51ea9947f
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed Jan 12 08:24:56 2022 -0800

    üìù KHz => kHz (#23512)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 1f10aba01b..17d279cfa5 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2488,21 +2488,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #if DISABLED(S_CURVE_ACCELERATION)
     block->acceleration_rate = (uint32_t)(accel * (sq(4096.0f) / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
       block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * settings.axis_steps_per_mm[E_AXIS_N(extruder)]);
       #if ENABLED(LA_DEBUG)
         if (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * 2 < SQRT(block->nominal_speed_sqr) * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
-          SERIAL_ECHOLNPGM("eISR running at > 10KHz.");
+          SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif
     }
   #endif
 
   float vmax_junction_sqr; // Initial limit on the segment entry velocity (mm/s)^2
 
   #if HAS_JUNCTION_DEVIATION
     /**
      * Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
      * Let a circle be tangent to both previous and current path line segments, where the junction

commit 02b29c0fecd1d68226cd64d660bb409e6f131f9e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 10 19:49:03 2022 -0600

    üìù kHz => KHz

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 17d279cfa5..1f10aba01b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2488,21 +2488,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #if DISABLED(S_CURVE_ACCELERATION)
     block->acceleration_rate = (uint32_t)(accel * (sq(4096.0f) / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
       block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * settings.axis_steps_per_mm[E_AXIS_N(extruder)]);
       #if ENABLED(LA_DEBUG)
         if (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * 2 < SQRT(block->nominal_speed_sqr) * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
-          SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
+          SERIAL_ECHOLNPGM("eISR running at > 10KHz.");
       #endif
     }
   #endif
 
   float vmax_junction_sqr; // Initial limit on the segment entry velocity (mm/s)^2
 
   #if HAS_JUNCTION_DEVIATION
     /**
      * Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
      * Let a circle be tangent to both previous and current path line segments, where the junction

commit 9665a4434cee0386fa2a63a058b6f2598943ee98
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 10 02:51:34 2022 -0600

    üßë‚Äçüíª Fewer string macros

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 4c86c06efe..17d279cfa5 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1860,27 +1860,27 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     dk = target.k - position.k
   );
 
   /* <-- add a slash to enable
     SERIAL_ECHOLNPGM(
       "  _populate_block FR:", fr_mm_s,
       " A:", target.a, " (", da, " steps)"
       " B:", target.b, " (", db, " steps)"
       " C:", target.c, " (", dc, " steps)"
       #if HAS_I_AXIS
-        " " AXIS4_STR ":", target.i, " (", di, " steps)"
+        " " STR_I ":", target.i, " (", di, " steps)"
       #endif
       #if HAS_J_AXIS
-        " " AXIS5_STR ":", target.j, " (", dj, " steps)"
+        " " STR_J ":", target.j, " (", dj, " steps)"
       #endif
       #if HAS_K_AXIS
-        " " AXIS6_STR ":", target.k, " (", dk, " steps)"
+        " " STR_K ":", target.k, " (", dk, " steps)"
       #endif
       #if HAS_EXTRUDERS
         " E:", target.e, " (", de, " steps)"
       #endif
     );
   //*/
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)

commit e65c12cf96a226019a7456099078ee5cb03f9a49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 2 09:22:36 2022 -0600

    üßë‚Äçüíª Apply axis conditionals

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 45ccdd1702..4c86c06efe 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1859,27 +1859,27 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     dj = target.j - position.j,
     dk = target.k - position.k
   );
 
   /* <-- add a slash to enable
     SERIAL_ECHOLNPGM(
       "  _populate_block FR:", fr_mm_s,
       " A:", target.a, " (", da, " steps)"
       " B:", target.b, " (", db, " steps)"
       " C:", target.c, " (", dc, " steps)"
-      #if LINEAR_AXES >= 4
+      #if HAS_I_AXIS
         " " AXIS4_STR ":", target.i, " (", di, " steps)"
       #endif
-      #if LINEAR_AXES >= 5
+      #if HAS_J_AXIS
         " " AXIS5_STR ":", target.j, " (", dj, " steps)"
       #endif
-      #if LINEAR_AXES >= 6
+      #if HAS_K_AXIS
         " " AXIS6_STR ":", target.k, " (", dk, " steps)"
       #endif
       #if HAS_EXTRUDERS
         " E:", target.e, " (", de, " steps)"
       #endif
     );
   //*/
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
     if (de) {
@@ -1932,27 +1932,27 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
       if (da + dc < 0) SBI(dm, A_AXIS);           // Motor A direction
       if (CORESIGN(da - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
     #elif CORE_IS_YZ
       if (da < 0) SBI(dm, X_AXIS);
       if (db < 0) SBI(dm, Y_HEAD);                // Save the toolhead's true direction in Y
       if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
       if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
       if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
     #endif
-    #if LINEAR_AXES >= 4
+    #if HAS_I_AXIS
       if (di < 0) SBI(dm, I_AXIS);
     #endif
-    #if LINEAR_AXES >= 5
+    #if HAS_J_AXIS
       if (dj < 0) SBI(dm, J_AXIS);
     #endif
-    #if LINEAR_AXES >= 6
+    #if HAS_K_AXIS
       if (dk < 0) SBI(dm, K_AXIS);
     #endif
   #elif ENABLED(MARKFORGED_XY)
     if (da + db < 0) SBI(dm, A_AXIS);              // Motor A direction
     if (db < 0) SBI(dm, B_AXIS);                   // Motor B direction
   #elif ENABLED(MARKFORGED_YX)
     if (da < 0) SBI(dm, A_AXIS);                   // Motor A direction
     if (db + da < 0) SBI(dm, B_AXIS);              // Motor B direction
   #else
     LINEAR_AXIS_CODE(
@@ -2034,27 +2034,27 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       steps_dist_mm.head.z = dc * mm_per_step[C_AXIS];
       steps_dist_mm.a      = (da + dc) * mm_per_step[A_AXIS];
       steps_dist_mm.c      = CORESIGN(da - dc) * mm_per_step[C_AXIS];
     #elif CORE_IS_YZ
       steps_dist_mm.x      = da * mm_per_step[X_AXIS];
       steps_dist_mm.head.y = db * mm_per_step[B_AXIS];
       steps_dist_mm.head.z = dc * mm_per_step[C_AXIS];
       steps_dist_mm.b      = (db + dc) * mm_per_step[B_AXIS];
       steps_dist_mm.c      = CORESIGN(db - dc) * mm_per_step[C_AXIS];
     #endif
-    #if LINEAR_AXES >= 4
+    #if HAS_I_AXIS
       steps_dist_mm.i = di * mm_per_step[I_AXIS];
     #endif
-    #if LINEAR_AXES >= 5
+    #if HAS_J_AXIS
       steps_dist_mm.j = dj * mm_per_step[J_AXIS];
     #endif
-    #if LINEAR_AXES >= 6
+    #if HAS_K_AXIS
       steps_dist_mm.k = dk * mm_per_step[K_AXIS];
     #endif
   #elif ENABLED(MARKFORGED_XY)
     steps_dist_mm.a      = (da - db) * mm_per_step[A_AXIS];
     steps_dist_mm.b      = db * mm_per_step[B_AXIS];
   #elif ENABLED(MARKFORGED_YX)
     steps_dist_mm.a      = da * mm_per_step[A_AXIS];
     steps_dist_mm.b      = (db - da) * mm_per_step[B_AXIS];
   #else
     LINEAR_AXIS_CODE(
@@ -2097,21 +2097,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
               sq(steps_dist_mm.head.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.head.z),
             + sq(steps_dist_mm.i),      + sq(steps_dist_mm.j), + sq(steps_dist_mm.k)
           )
         #elif CORE_IS_YZ
           LINEAR_AXIS_GANG(
               sq(steps_dist_mm.x)  + sq(steps_dist_mm.head.y) + sq(steps_dist_mm.head.z)
             + sq(steps_dist_mm.i), + sq(steps_dist_mm.j),     + sq(steps_dist_mm.k)
           )
         #elif ENABLED(FOAMCUTTER_XYUV)
           // Return the largest distance move from either X/Y or I/J plane
-          #if LINEAR_AXES >= 5
+          #if HAS_J_AXIS
             _MAX(sq(steps_dist_mm.x) + sq(steps_dist_mm.y), sq(steps_dist_mm.i) + sq(steps_dist_mm.j))
           #else
             sq(steps_dist_mm.x) + sq(steps_dist_mm.y)
           #endif
         #else
           LINEAR_AXIS_GANG(
               sq(steps_dist_mm.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.z),
             + sq(steps_dist_mm.i), + sq(steps_dist_mm.j), + sq(steps_dist_mm.k)
           )
         #endif
@@ -2190,27 +2190,27 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     LINEAR_AXIS_CODE(
       if (block->steps.x) stepper.enable_axis(X_AXIS),
       if (block->steps.y) stepper.enable_axis(Y_AXIS),
       if (TERN(Z_LATE_ENABLE, 0, block->steps.z)) stepper.enable_axis(Z_AXIS),
       if (block->steps.i) stepper.enable_axis(I_AXIS),
       if (block->steps.j) stepper.enable_axis(J_AXIS),
       if (block->steps.k) stepper.enable_axis(K_AXIS)
     );
   #endif
   #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
-    #if LINEAR_AXES >= 4
+    #if HAS_I_AXIS
       if (block->steps.i) stepper.enable_axis(I_AXIS);
     #endif
-    #if LINEAR_AXES >= 5
+    #if HAS_J_AXIS
       if (block->steps.j) stepper.enable_axis(J_AXIS);
     #endif
-    #if LINEAR_AXES >= 6
+    #if HAS_K_AXIS
       if (block->steps.k) stepper.enable_axis(K_AXIS);
     #endif
   #endif
 
   // Enable extruder(s)
   #if HAS_EXTRUDERS
     if (esteps) {
       TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
@@ -2942,31 +2942,31 @@ bool Planner::buffer_segment(const abce_pos_t &abce
     #if LINEAR_AXES >= ABC
       #if ENABLED(DELTA)
         SERIAL_ECHOPGM(") C:", abce.c);
       #else
         SERIAL_CHAR(')');
         SERIAL_ECHOPGM_P(SP_Z_LBL, abce.c);
       #endif
       SERIAL_ECHOPGM(" (", position.z, "->", target.z);
       SERIAL_CHAR(')');
     #endif
-    #if LINEAR_AXES >= 4
+    #if HAS_I_AXIS
       SERIAL_ECHOPGM_P(SP_I_LBL, abce.i);
       SERIAL_ECHOPGM(" (", position.i, "->", target.i);
       SERIAL_CHAR(')');
     #endif
-    #if LINEAR_AXES >= 5
+    #if HAS_J_AXIS
       SERIAL_ECHOPGM_P(SP_J_LBL, abce.j);
       SERIAL_ECHOPGM(" (", position.j, "->", target.j);
       SERIAL_CHAR(')');
     #endif
-    #if LINEAR_AXES >= 6
+    #if HAS_K_AXIS
       SERIAL_ECHOPGM_P(SP_K_LBL, abce.k);
       SERIAL_ECHOPGM(" (", position.k, "->", target.k);
       SERIAL_CHAR(')');
     #endif
     #if HAS_EXTRUDERS
       SERIAL_ECHOPGM_P(SP_E_LBL, abce.e);
       SERIAL_ECHOLNPGM(" (", position.e, "->", target.e, ")");
     #else
       SERIAL_EOL();
     #endif

commit 6a8b9274a31d11c396ce1bc44b3a0b872a4606dc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Dec 25 23:15:17 2021 -0600

    ‚è™Ô∏è Refactor still needs work
    
    Reverting #23295

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 752834c6ab..45ccdd1702 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1257,21 +1257,21 @@ void Planner::recalculate() {
 
     #if FAN_MIN_PWM != 0 || FAN_MAX_PWM != 255
       #define CALC_FAN_SPEED(f) (fan_speed[f] ? map(fan_speed[f], 1, 255, FAN_MIN_PWM, FAN_MAX_PWM) : FAN_OFF_PWM)
     #else
       #define CALC_FAN_SPEED(f) (fan_speed[f] ?: FAN_OFF_PWM)
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       #define _FAN_SET(F) thermalManager.soft_pwm_amount_fan[F] = CALC_FAN_SPEED(F);
     #else
-      #define _FAN_SET(F) hal.set_pwm_duty(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(F));
+      #define _FAN_SET(F) set_pwm_duty(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(F));
     #endif
     #define FAN_SET(F) do{ kickstart_fan(fan_speed, ms, F); _FAN_SET(F); }while(0)
 
     const millis_t ms = millis();
     TERN_(HAS_FAN0, FAN_SET(0));
     TERN_(HAS_FAN1, FAN_SET(1));
     TERN_(HAS_FAN2, FAN_SET(2));
     TERN_(HAS_FAN3, FAN_SET(3));
     TERN_(HAS_FAN4, FAN_SET(4));
     TERN_(HAS_FAN5, FAN_SET(5));
@@ -1393,22 +1393,22 @@ void Planner::check_axes_activity() {
 
   //
   // Update Fan speeds
   // Only if synchronous M106/M107 is disabled
   //
   TERN_(HAS_TAIL_FAN_SPEED, if (fans_need_update) sync_fan_speeds(tail_fan_speed));
 
   TERN_(AUTOTEMP, autotemp_task());
 
   #if ENABLED(BARICUDA)
-    TERN_(HAS_HEATER_1, hal.set_pwm_duty(pin_t(HEATER_1_PIN), tail_valve_pressure));
-    TERN_(HAS_HEATER_2, hal.set_pwm_duty(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
+    TERN_(HAS_HEATER_1, set_pwm_duty(pin_t(HEATER_1_PIN), tail_valve_pressure));
+    TERN_(HAS_HEATER_2, set_pwm_duty(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
   #endif
 }
 
 #if ENABLED(AUTOTEMP)
 
   #if ENABLED(AUTOTEMP_PROPORTIONAL)
     void Planner::_autotemp_update_from_hotend() {
       const celsius_t target = thermalManager.degTargetHotend(active_extruder);
       autotemp_min = target + AUTOTEMP_MIN_P;
       autotemp_max = target + AUTOTEMP_MAX_P;

commit e211ff148c39bf5dace72de7cffbb83f19d3f1bf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 24 21:33:59 2021 -0600

    ‚ôªÔ∏è Refactor HAL as singleton (#23295)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 45ccdd1702..752834c6ab 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1257,21 +1257,21 @@ void Planner::recalculate() {
 
     #if FAN_MIN_PWM != 0 || FAN_MAX_PWM != 255
       #define CALC_FAN_SPEED(f) (fan_speed[f] ? map(fan_speed[f], 1, 255, FAN_MIN_PWM, FAN_MAX_PWM) : FAN_OFF_PWM)
     #else
       #define CALC_FAN_SPEED(f) (fan_speed[f] ?: FAN_OFF_PWM)
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       #define _FAN_SET(F) thermalManager.soft_pwm_amount_fan[F] = CALC_FAN_SPEED(F);
     #else
-      #define _FAN_SET(F) set_pwm_duty(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(F));
+      #define _FAN_SET(F) hal.set_pwm_duty(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(F));
     #endif
     #define FAN_SET(F) do{ kickstart_fan(fan_speed, ms, F); _FAN_SET(F); }while(0)
 
     const millis_t ms = millis();
     TERN_(HAS_FAN0, FAN_SET(0));
     TERN_(HAS_FAN1, FAN_SET(1));
     TERN_(HAS_FAN2, FAN_SET(2));
     TERN_(HAS_FAN3, FAN_SET(3));
     TERN_(HAS_FAN4, FAN_SET(4));
     TERN_(HAS_FAN5, FAN_SET(5));
@@ -1393,22 +1393,22 @@ void Planner::check_axes_activity() {
 
   //
   // Update Fan speeds
   // Only if synchronous M106/M107 is disabled
   //
   TERN_(HAS_TAIL_FAN_SPEED, if (fans_need_update) sync_fan_speeds(tail_fan_speed));
 
   TERN_(AUTOTEMP, autotemp_task());
 
   #if ENABLED(BARICUDA)
-    TERN_(HAS_HEATER_1, set_pwm_duty(pin_t(HEATER_1_PIN), tail_valve_pressure));
-    TERN_(HAS_HEATER_2, set_pwm_duty(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
+    TERN_(HAS_HEATER_1, hal.set_pwm_duty(pin_t(HEATER_1_PIN), tail_valve_pressure));
+    TERN_(HAS_HEATER_2, hal.set_pwm_duty(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
   #endif
 }
 
 #if ENABLED(AUTOTEMP)
 
   #if ENABLED(AUTOTEMP_PROPORTIONAL)
     void Planner::_autotemp_update_from_hotend() {
       const celsius_t target = thermalManager.degTargetHotend(active_extruder);
       autotemp_min = target + AUTOTEMP_MIN_P;
       autotemp_max = target + AUTOTEMP_MAX_P;

commit 26689e1d85e5c210daa01548ae0b6c9118e35bd4
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Tue Dec 14 07:11:52 2021 +0700

    ü©π Init fan speed at boot (#23181)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 0c62b11f5c..45ccdd1702 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1302,21 +1302,21 @@ void Planner::recalculate() {
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
 
   #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_I, DISABLE_J, DISABLE_K, DISABLE_E)
     xyze_bool_t axis_active = { false };
   #endif
 
   #if HAS_TAIL_FAN_SPEED
-    static uint8_t tail_fan_speed[FAN_COUNT];
+    static uint8_t tail_fan_speed[FAN_COUNT] = ARRAY_N_1(FAN_COUNT, 255);
     bool fans_need_update = false;
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
     #endif
     #if HAS_HEATER_2
       uint8_t tail_e_to_p_pressure;
     #endif

commit dfa1c26471f27e0fa81f1e7f7655a54efc50f77c
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Thu Dec 9 02:15:31 2021 +0700

    ü©π Coerce pin_t in set_pwm_duty macros (#23273)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index cd8729edac..0c62b11f5c 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1256,22 +1256,20 @@ void Planner::recalculate() {
   void Planner::sync_fan_speeds(uint8_t (&fan_speed)[FAN_COUNT]) {
 
     #if FAN_MIN_PWM != 0 || FAN_MAX_PWM != 255
       #define CALC_FAN_SPEED(f) (fan_speed[f] ? map(fan_speed[f], 1, 255, FAN_MIN_PWM, FAN_MAX_PWM) : FAN_OFF_PWM)
     #else
       #define CALC_FAN_SPEED(f) (fan_speed[f] ?: FAN_OFF_PWM)
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       #define _FAN_SET(F) thermalManager.soft_pwm_amount_fan[F] = CALC_FAN_SPEED(F);
-    #elif ENABLED(FAST_PWM_FAN)
-      #define _FAN_SET(F) set_pwm_duty(FAN##F##_PIN, CALC_FAN_SPEED(F));
     #else
       #define _FAN_SET(F) set_pwm_duty(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(F));
     #endif
     #define FAN_SET(F) do{ kickstart_fan(fan_speed, ms, F); _FAN_SET(F); }while(0)
 
     const millis_t ms = millis();
     TERN_(HAS_FAN0, FAN_SET(0));
     TERN_(HAS_FAN1, FAN_SET(1));
     TERN_(HAS_FAN2, FAN_SET(2));
     TERN_(HAS_FAN3, FAN_SET(3));

commit e5154ec28179c7dc7b58a830412e7cb09c2f878c
Author: John Robertson <john@cirtech.co.uk>
Date:   Tue Nov 23 21:24:24 2021 +0000

    ‚ú® MarkForged YX kinematics (#23163)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 28364d4be0..cd8729edac 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1738,21 +1738,21 @@ float Planner::get_axis_position_mm(const AxisEnum axis) {
 
       if (was_enabled) stepper.wake_up();
 
       // ((a1+a2)+(a1-a2))/2 -> (a1+a2+a1-a2)/2 -> (a1+a1)/2 -> a1
       // ((a1+a2)-(a1-a2))/2 -> (a1+a2-a1+a2)/2 -> (a2+a2)/2 -> a2
       axis_steps = (axis == CORE_AXIS_2 ? CORESIGN(p1 - p2) : p1 + p2) * 0.5f;
     }
     else
       axis_steps = stepper.position(axis);
 
-  #elif ENABLED(MARKFORGED_XY)
+  #elif EITHER(MARKFORGED_XY, MARKFORGED_YX)
 
     // Requesting one of the joined axes?
     if (axis == CORE_AXIS_1 || axis == CORE_AXIS_2) {
       // Protect the access to the position.
       const bool was_enabled = stepper.suspend();
 
       const int32_t p1 = stepper.position(CORE_AXIS_1),
                     p2 = stepper.position(CORE_AXIS_2);
 
       if (was_enabled) stepper.wake_up();
@@ -1912,70 +1912,70 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
             de = 0; // no difference
             SERIAL_ECHO_MSG(STR_ERR_LONG_EXTRUDE_STOP);
           }
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   // Compute direction bit-mask for this block
   axis_bits_t dm = 0;
-  #if CORE_IS_XY
-    if (da < 0) SBI(dm, X_HEAD);                // Save the toolhead's true direction in X
-    if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
-    if (dc < 0) SBI(dm, Z_AXIS);
-    if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
-    if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
-  #elif CORE_IS_XZ
-    if (da < 0) SBI(dm, X_HEAD);                // Save the toolhead's true direction in X
-    if (db < 0) SBI(dm, Y_AXIS);
-    if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
-    if (da + dc < 0) SBI(dm, A_AXIS);           // Motor A direction
-    if (CORESIGN(da - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
-  #elif CORE_IS_YZ
-    if (da < 0) SBI(dm, X_AXIS);
-    if (db < 0) SBI(dm, Y_HEAD);                // Save the toolhead's true direction in Y
-    if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
-    if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
-    if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
-  #elif ENABLED(MARKFORGED_XY)
-    if (da < 0) SBI(dm, X_HEAD);                // Save the toolhead's true direction in X
-    if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
+  #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
+    if (da < 0) SBI(dm, X_HEAD);                  // Save the toolhead's true direction in X
+    if (db < 0) SBI(dm, Y_HEAD);                  // ...and Y
     if (dc < 0) SBI(dm, Z_AXIS);
-    if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
-    if (db < 0) SBI(dm, B_AXIS);                // Motor B direction
-  #else
-    LINEAR_AXIS_CODE(
-      if (da < 0) SBI(dm, X_AXIS),
-      if (db < 0) SBI(dm, Y_AXIS),
-      if (dc < 0) SBI(dm, Z_AXIS),
-      if (di < 0) SBI(dm, I_AXIS),
-      if (dj < 0) SBI(dm, J_AXIS),
-      if (dk < 0) SBI(dm, K_AXIS)
-    );
   #endif
-
   #if IS_CORE
+    #if CORE_IS_XY
+      if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
+      if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
+    #elif CORE_IS_XZ
+      if (da < 0) SBI(dm, X_HEAD);                // Save the toolhead's true direction in X
+      if (db < 0) SBI(dm, Y_AXIS);
+      if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
+      if (da + dc < 0) SBI(dm, A_AXIS);           // Motor A direction
+      if (CORESIGN(da - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
+    #elif CORE_IS_YZ
+      if (da < 0) SBI(dm, X_AXIS);
+      if (db < 0) SBI(dm, Y_HEAD);                // Save the toolhead's true direction in Y
+      if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
+      if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
+      if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
+    #endif
     #if LINEAR_AXES >= 4
       if (di < 0) SBI(dm, I_AXIS);
     #endif
     #if LINEAR_AXES >= 5
       if (dj < 0) SBI(dm, J_AXIS);
     #endif
     #if LINEAR_AXES >= 6
       if (dk < 0) SBI(dm, K_AXIS);
     #endif
+  #elif ENABLED(MARKFORGED_XY)
+    if (da + db < 0) SBI(dm, A_AXIS);              // Motor A direction
+    if (db < 0) SBI(dm, B_AXIS);                   // Motor B direction
+  #elif ENABLED(MARKFORGED_YX)
+    if (da < 0) SBI(dm, A_AXIS);                   // Motor A direction
+    if (db + da < 0) SBI(dm, B_AXIS);              // Motor B direction
+  #else
+    LINEAR_AXIS_CODE(
+      if (da < 0) SBI(dm, X_AXIS),
+      if (db < 0) SBI(dm, Y_AXIS),
+      if (dc < 0) SBI(dm, Z_AXIS),
+      if (di < 0) SBI(dm, I_AXIS),
+      if (dj < 0) SBI(dm, J_AXIS),
+      if (dk < 0) SBI(dm, K_AXIS)
+    );
   #endif
 
-  TERN_(HAS_EXTRUDERS, if (de < 0) SBI(dm, E_AXIS));
-
   #if HAS_EXTRUDERS
+    if (de < 0) SBI(dm, E_AXIS);
     const float esteps_float = de * e_factor[extruder];
     const uint32_t esteps = ABS(esteps_float) + 0.5f;
   #else
     constexpr uint32_t esteps = 0;
   #endif
 
   // Clear all flags, including the "busy" bit
   block->flag = 0x00;
 
   // Set direction bits
@@ -1991,45 +1991,50 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   // Number of steps for each axis
   // See https://www.corexy.com/theory.html
   #if CORE_IS_XY
     block->steps.set(LINEAR_AXIS_LIST(ABS(da + db), ABS(da - db), ABS(dc), ABS(di), ABS(dj), ABS(dk)));
   #elif CORE_IS_XZ
     block->steps.set(LINEAR_AXIS_LIST(ABS(da + dc), ABS(db), ABS(da - dc), ABS(di), ABS(dj), ABS(dk)));
   #elif CORE_IS_YZ
     block->steps.set(LINEAR_AXIS_LIST(ABS(da), ABS(db + dc), ABS(db - dc), ABS(di), ABS(dj), ABS(dk)));
   #elif ENABLED(MARKFORGED_XY)
     block->steps.set(LINEAR_AXIS_LIST(ABS(da + db), ABS(db), ABS(dc), ABS(di), ABS(dj), ABS(dk)));
+  #elif ENABLED(MARKFORGED_YX)
+    block->steps.set(LINEAR_AXIS_LIST(ABS(da), ABS(db + da), ABS(dc), ABS(di), ABS(dj), ABS(dk)));
   #elif IS_SCARA
     block->steps.set(LINEAR_AXIS_LIST(ABS(da), ABS(db), ABS(dc), ABS(di), ABS(dj), ABS(dk)));
   #else
     // default non-h-bot planning
     block->steps.set(LINEAR_AXIS_LIST(ABS(da), ABS(db), ABS(dc), ABS(di), ABS(dj), ABS(dk)));
   #endif
 
   /**
    * This part of the code calculates the total length of the movement.
    * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
    * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
    * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
    * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
    * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
    */
   struct DistanceMM : abce_float_t {
-    #if EITHER(IS_CORE, MARKFORGED_XY)
+    #if ANY(IS_CORE, MARKFORGED_XY, MARKFORGED_YX)
       struct { float x, y, z; } head;
     #endif
   } steps_dist_mm;
+
+  #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
+    steps_dist_mm.head.x = da * mm_per_step[A_AXIS];
+    steps_dist_mm.head.y = db * mm_per_step[B_AXIS];
+    steps_dist_mm.z      = dc * mm_per_step[Z_AXIS];
+  #endif
   #if IS_CORE
     #if CORE_IS_XY
-      steps_dist_mm.head.x = da * mm_per_step[A_AXIS];
-      steps_dist_mm.head.y = db * mm_per_step[B_AXIS];
-      steps_dist_mm.z      = dc * mm_per_step[Z_AXIS];
       steps_dist_mm.a      = (da + db) * mm_per_step[A_AXIS];
       steps_dist_mm.b      = CORESIGN(da - db) * mm_per_step[B_AXIS];
     #elif CORE_IS_XZ
       steps_dist_mm.head.x = da * mm_per_step[A_AXIS];
       steps_dist_mm.y      = db * mm_per_step[Y_AXIS];
       steps_dist_mm.head.z = dc * mm_per_step[C_AXIS];
       steps_dist_mm.a      = (da + dc) * mm_per_step[A_AXIS];
       steps_dist_mm.c      = CORESIGN(da - dc) * mm_per_step[C_AXIS];
     #elif CORE_IS_YZ
       steps_dist_mm.x      = da * mm_per_step[X_AXIS];
@@ -2041,25 +2046,25 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     #if LINEAR_AXES >= 4
       steps_dist_mm.i = di * mm_per_step[I_AXIS];
     #endif
     #if LINEAR_AXES >= 5
       steps_dist_mm.j = dj * mm_per_step[J_AXIS];
     #endif
     #if LINEAR_AXES >= 6
       steps_dist_mm.k = dk * mm_per_step[K_AXIS];
     #endif
   #elif ENABLED(MARKFORGED_XY)
-    steps_dist_mm.head.x = da * mm_per_step[A_AXIS];
-    steps_dist_mm.head.y = db * mm_per_step[B_AXIS];
-    steps_dist_mm.z      = dc * mm_per_step[Z_AXIS];
     steps_dist_mm.a      = (da - db) * mm_per_step[A_AXIS];
     steps_dist_mm.b      = db * mm_per_step[B_AXIS];
+  #elif ENABLED(MARKFORGED_YX)
+    steps_dist_mm.a      = da * mm_per_step[A_AXIS];
+    steps_dist_mm.b      = (db - da) * mm_per_step[B_AXIS];
   #else
     LINEAR_AXIS_CODE(
       steps_dist_mm.a = da * mm_per_step[A_AXIS],
       steps_dist_mm.b = db * mm_per_step[B_AXIS],
       steps_dist_mm.c = dc * mm_per_step[C_AXIS],
       steps_dist_mm.i = di * mm_per_step[I_AXIS],
       steps_dist_mm.j = dj * mm_per_step[J_AXIS],
       steps_dist_mm.k = dk * mm_per_step[K_AXIS]
     );
   #endif
@@ -2077,21 +2082,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       && block->steps.k < MIN_STEPS_PER_SEGMENT
     )
   ) {
     block->millimeters = TERN0(HAS_EXTRUDERS, ABS(steps_dist_mm.e));
   }
   else {
     if (millimeters)
       block->millimeters = millimeters;
     else {
       block->millimeters = SQRT(
-        #if EITHER(CORE_IS_XY, MARKFORGED_XY)
+        #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
           LINEAR_AXIS_GANG(
               sq(steps_dist_mm.head.x), + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.z),
             + sq(steps_dist_mm.i),      + sq(steps_dist_mm.j),      + sq(steps_dist_mm.k)
           )
         #elif CORE_IS_XZ
           LINEAR_AXIS_GANG(
               sq(steps_dist_mm.head.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.head.z),
             + sq(steps_dist_mm.i),      + sq(steps_dist_mm.j), + sq(steps_dist_mm.k)
           )
         #elif CORE_IS_YZ
@@ -2156,21 +2161,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
          block->steps.x,
       || block->steps.y,
       || block->steps.z,
       || block->steps.i,
       || block->steps.j,
       || block->steps.k
     )) powerManager.power_on();
   #endif
 
   // Enable active axes
-  #if EITHER(CORE_IS_XY, MARKFORGED_XY)
+  #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
     if (block->steps.a || block->steps.b) {
       stepper.enable_axis(X_AXIS);
       stepper.enable_axis(Y_AXIS);
     }
     #if DISABLED(Z_LATE_ENABLE)
       if (block->steps.z) stepper.enable_axis(Z_AXIS);
     #endif
   #elif CORE_IS_XZ
     if (block->steps.a || block->steps.c) {
       stepper.enable_axis(X_AXIS);
@@ -2186,21 +2191,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #else
     LINEAR_AXIS_CODE(
       if (block->steps.x) stepper.enable_axis(X_AXIS),
       if (block->steps.y) stepper.enable_axis(Y_AXIS),
       if (TERN(Z_LATE_ENABLE, 0, block->steps.z)) stepper.enable_axis(Z_AXIS),
       if (block->steps.i) stepper.enable_axis(I_AXIS),
       if (block->steps.j) stepper.enable_axis(J_AXIS),
       if (block->steps.k) stepper.enable_axis(K_AXIS)
     );
   #endif
-  #if EITHER(IS_CORE, MARKFORGED_XY)
+  #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
     #if LINEAR_AXES >= 4
       if (block->steps.i) stepper.enable_axis(I_AXIS);
     #endif
     #if LINEAR_AXES >= 5
       if (block->steps.j) stepper.enable_axis(J_AXIS);
     #endif
     #if LINEAR_AXES >= 6
       if (block->steps.k) stepper.enable_axis(K_AXIS);
     #endif
   #endif
@@ -2544,21 +2549,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         LOGICAL_AXIS_ARRAY(steps_dist_mm.e, steps_dist_mm.x, steps_dist_mm.y, steps_dist_mm.z, steps_dist_mm.i, steps_dist_mm.j, steps_dist_mm.k)
       #endif
     ;
 
     /**
      * On CoreXY the length of the vector [A,B] is SQRT(2) times the length of the head movement vector [X,Y].
      * So taking Z and E into account, we cannot scale to a unit vector with "inverse_millimeters".
      * => normalize the complete junction vector.
      * Elsewise, when needed JD will factor-in the E component
      */
-    if (EITHER(IS_CORE, MARKFORGED_XY) || esteps > 0)
+    if (ANY(IS_CORE, MARKFORGED_XY, MARKFORGED_YX) || esteps > 0)
       normalize_junction_vector(unit_vec);  // Normalize with XYZE components
     else
       unit_vec *= inverse_millimeters;      // Use pre-calculated (1 / SQRT(x^2 + y^2 + z^2))
 
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
       float junction_cos_theta = LOGICAL_AXIS_GANG(
                                  + (-prev_unit_vec.e * unit_vec.e),

commit 1c31366bf37fcebe91e8e6011af354904dd58ad4
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sat Nov 20 02:44:53 2021 +0100

    ‚ö°Ô∏è Reduce calls to set fan PWM (#23149)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e19684a7b5..28364d4be0 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1304,40 +1304,47 @@ void Planner::recalculate() {
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
 
   #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_I, DISABLE_J, DISABLE_K, DISABLE_E)
     xyze_bool_t axis_active = { false };
   #endif
 
   #if HAS_TAIL_FAN_SPEED
-    uint8_t tail_fan_speed[FAN_COUNT];
+    static uint8_t tail_fan_speed[FAN_COUNT];
+    bool fans_need_update = false;
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
     #endif
     #if HAS_HEATER_2
       uint8_t tail_e_to_p_pressure;
     #endif
   #endif
 
   if (has_blocks_queued()) {
 
     #if EITHER(HAS_TAIL_FAN_SPEED, BARICUDA)
       block_t *block = &block_buffer[block_buffer_tail];
     #endif
 
     #if HAS_TAIL_FAN_SPEED
-      FANS_LOOP(i) tail_fan_speed[i] = thermalManager.scaledFanSpeed(i, block->fan_speed[i]);
+      FANS_LOOP(i) {
+        const uint8_t spd = thermalManager.scaledFanSpeed(i, block->fan_speed[i]);
+        if (tail_fan_speed[i] != spd) {
+          fans_need_update = true;
+          tail_fan_speed[i] = spd;
+        }
+      }
     #endif
 
     #if ENABLED(BARICUDA)
       TERN_(HAS_HEATER_1, tail_valve_pressure = block->valve_pressure);
       TERN_(HAS_HEATER_2, tail_e_to_p_pressure = block->e_to_p_pressure);
     #endif
 
     #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_I, DISABLE_J, DISABLE_K, DISABLE_E)
       for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
         block_t *block = &block_buffer[b];
@@ -1351,21 +1358,27 @@ void Planner::check_axes_activity() {
           if (TERN0(DISABLE_K, block->steps.k)) axis_active.k = true
         );
       }
     #endif
   }
   else {
 
     TERN_(HAS_CUTTER, cutter.refresh());
 
     #if HAS_TAIL_FAN_SPEED
-      FANS_LOOP(i) tail_fan_speed[i] = thermalManager.scaledFanSpeed(i);
+      FANS_LOOP(i) {
+        const uint8_t spd = thermalManager.scaledFanSpeed(i);
+        if (tail_fan_speed[i] != spd) {
+          fans_need_update = true;
+          tail_fan_speed[i] = spd;
+        }
+      }
     #endif
 
     #if ENABLED(BARICUDA)
       TERN_(HAS_HEATER_1, tail_valve_pressure = baricuda_valve_pressure);
       TERN_(HAS_HEATER_2, tail_e_to_p_pressure = baricuda_e_to_p_pressure);
     #endif
   }
 
   //
   // Disable inactive axes
@@ -1377,21 +1390,21 @@ void Planner::check_axes_activity() {
     if (TERN0(DISABLE_Z, !axis_active.z)) stepper.disable_axis(Z_AXIS),
     if (TERN0(DISABLE_I, !axis_active.i)) stepper.disable_axis(I_AXIS),
     if (TERN0(DISABLE_J, !axis_active.j)) stepper.disable_axis(J_AXIS),
     if (TERN0(DISABLE_K, !axis_active.k)) stepper.disable_axis(K_AXIS)
   );
 
   //
   // Update Fan speeds
   // Only if synchronous M106/M107 is disabled
   //
-  TERN_(HAS_TAIL_FAN_SPEED, sync_fan_speeds(tail_fan_speed));
+  TERN_(HAS_TAIL_FAN_SPEED, if (fans_need_update) sync_fan_speeds(tail_fan_speed));
 
   TERN_(AUTOTEMP, autotemp_task());
 
   #if ENABLED(BARICUDA)
     TERN_(HAS_HEATER_1, set_pwm_duty(pin_t(HEATER_1_PIN), tail_valve_pressure));
     TERN_(HAS_HEATER_2, set_pwm_duty(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
   #endif
 }
 
 #if ENABLED(AUTOTEMP)

commit 44d8c2f5bf970e5f701e8bf8e2eff4e17b9266bc
Author: espr14 <espr14@gmail.com>
Date:   Wed Nov 17 18:07:11 2021 +0100

    üèóÔ∏è Planner::busy() (#23145)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 11460fa67a..e19684a7b5 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -84,24 +84,20 @@
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"
 #endif
 
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
-#if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
-  #include "../feature/closedloop.h"
-#endif
-
 #if ENABLED(BACKLASH_COMPENSATION)
   #include "../feature/backlash.h"
 #endif
 
 #if ENABLED(CANCEL_OBJECTS)
   #include "../feature/cancel_object.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/powerloss.h"
@@ -1756,27 +1752,23 @@ float Planner::get_axis_position_mm(const AxisEnum axis) {
   #else
 
     axis_steps = stepper.position(axis);
 
   #endif
 
   return axis_steps * mm_per_step[axis];
 }
 
 /**
- * Block until all buffered steps are executed / cleaned
+ * Block until the planner is finished processing
  */
-void Planner::synchronize() {
-  while (has_blocks_queued() || cleaning_buffer_counter
-      || TERN0(EXTERNAL_CLOSED_LOOP_CONTROLLER, CLOSED_LOOP_WAITING())
-  ) idle();
-}
+void Planner::synchronize() { while (busy()) idle(); }
 
 /**
  * Planner::_buffer_steps
  *
  * Add a new linear movement to the planner queue (in terms of steps).
  *
  *  target        - target position in steps units
  *  target_float  - target position in direct (mm, degrees) units. optional
  *  fr_mm_s       - (target) speed of the move
  *  extruder      - target extruder

commit da830e6ced7f7c7e509e748104245064d1c1b265
Author: Andrei M <22990561+andrei-moraru@users.noreply.github.com>
Date:   Tue Nov 2 01:47:16 2021 -0400

    ‚öóÔ∏è Use pwm_set_duty over analogWrite to set PWM (#23048)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 2552efc69a..11460fa67a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1263,21 +1263,21 @@ void Planner::recalculate() {
       #define CALC_FAN_SPEED(f) (fan_speed[f] ? map(fan_speed[f], 1, 255, FAN_MIN_PWM, FAN_MAX_PWM) : FAN_OFF_PWM)
     #else
       #define CALC_FAN_SPEED(f) (fan_speed[f] ?: FAN_OFF_PWM)
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       #define _FAN_SET(F) thermalManager.soft_pwm_amount_fan[F] = CALC_FAN_SPEED(F);
     #elif ENABLED(FAST_PWM_FAN)
       #define _FAN_SET(F) set_pwm_duty(FAN##F##_PIN, CALC_FAN_SPEED(F));
     #else
-      #define _FAN_SET(F) analogWrite(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(F));
+      #define _FAN_SET(F) set_pwm_duty(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(F));
     #endif
     #define FAN_SET(F) do{ kickstart_fan(fan_speed, ms, F); _FAN_SET(F); }while(0)
 
     const millis_t ms = millis();
     TERN_(HAS_FAN0, FAN_SET(0));
     TERN_(HAS_FAN1, FAN_SET(1));
     TERN_(HAS_FAN2, FAN_SET(2));
     TERN_(HAS_FAN3, FAN_SET(3));
     TERN_(HAS_FAN4, FAN_SET(4));
     TERN_(HAS_FAN5, FAN_SET(5));
@@ -1386,22 +1386,22 @@ void Planner::check_axes_activity() {
 
   //
   // Update Fan speeds
   // Only if synchronous M106/M107 is disabled
   //
   TERN_(HAS_TAIL_FAN_SPEED, sync_fan_speeds(tail_fan_speed));
 
   TERN_(AUTOTEMP, autotemp_task());
 
   #if ENABLED(BARICUDA)
-    TERN_(HAS_HEATER_1, analogWrite(pin_t(HEATER_1_PIN), tail_valve_pressure));
-    TERN_(HAS_HEATER_2, analogWrite(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
+    TERN_(HAS_HEATER_1, set_pwm_duty(pin_t(HEATER_1_PIN), tail_valve_pressure));
+    TERN_(HAS_HEATER_2, set_pwm_duty(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
   #endif
 }
 
 #if ENABLED(AUTOTEMP)
 
   #if ENABLED(AUTOTEMP_PROPORTIONAL)
     void Planner::_autotemp_update_from_hotend() {
       const celsius_t target = thermalManager.degTargetHotend(active_extruder);
       autotemp_min = target + AUTOTEMP_MIN_P;
       autotemp_max = target + AUTOTEMP_MAX_P;

commit 9338b7f06e03fd27ac8b2babb96e92a2701700ad
Author: woisy00 <spam@bergermeier.info>
Date:   Wed Oct 27 01:05:34 2021 +0200

    üêõ Fix AUTOTEMP bug (thermal runaway) (#23025)
    
    Regression from 9823a37

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index b89a313f2b..2552efc69a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1450,21 +1450,21 @@ void Planner::check_axes_activity() {
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block_t *block = &block_buffer[b];
       if (LINEAR_AXIS_GANG(block->steps.x, || block->steps.y, || block->steps.z, || block->steps.i, || block->steps.j, || block->steps.k)) {
         const float se = (float)block->steps.e / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;
         NOLESS(high, se);
       }
     }
 
     float t = autotemp_min + high * autotemp_factor;
     LIMIT(t, autotemp_min, autotemp_max);
-    if (t < oldt) t *= (1.0f - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
+    if (t < oldt) t = t * (1.0f - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
     oldt = t;
     thermalManager.setTargetHotend(t, active_extruder);
   }
 
 #endif
 
 #if DISABLED(NO_VOLUMETRICS)
 
   /**
    * Get a volumetric multiplier from a filament diameter.

commit 15ebe45f36f34bce4a07f6348c85ffb1ab904087
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Oct 12 19:40:56 2021 -0400

    üêõ Fix IDEX + DISABLE_INACTIVE_EXTRUDER (#22925)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e62a9ab5ee..b89a313f2b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2200,37 +2200,37 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     #endif
   #endif
 
   // Enable extruder(s)
   #if HAS_EXTRUDERS
     if (esteps) {
       TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
+        // Count down all steppers that were recently moved
         LOOP_L_N(i, E_STEPPERS)
           if (g_uc_extruder_last_move[i]) g_uc_extruder_last_move[i]--;
 
+        // Switching Extruder uses one E stepper motor per two nozzles
         #define E_STEPPER_INDEX(E) TERN(SWITCHING_EXTRUDER, (E) / 2, E)
 
+        // Enable all (i.e., both) E steppers for IDEX-style duplication, but only active E steppers for multi-nozzle (i.e., single wide X carriage) duplication
+        #define _IS_DUPE(N) TERN0(HAS_DUPLICATION_MODE, (extruder_duplication_enabled && TERN1(MULTI_NOZZLE_DUPLICATION, TEST(duplication_e_mask, N))))
+
         #define ENABLE_ONE_E(N) do{ \
-          if (E_STEPPER_INDEX(extruder) == N) { \
-            stepper.ENABLE_EXTRUDER(N); \
-            g_uc_extruder_last_move[N] = (BLOCK_BUFFER_SIZE) * 2; \
-            if ((N) == 0 && TERN0(HAS_DUPLICATION_MODE, extruder_duplication_enabled)) \
-              stepper.ENABLE_EXTRUDER(1); \
-          } \
-          else if (!g_uc_extruder_last_move[N]) { \
-            stepper.DISABLE_EXTRUDER(N); \
-            if ((N) == 0 && TERN0(HAS_DUPLICATION_MODE, extruder_duplication_enabled)) \
-              stepper.DISABLE_EXTRUDER(1); \
+          if (N == E_STEPPER_INDEX(extruder) || _IS_DUPE(N)) {    /* N is 'extruder', or N is duplicating */ \
+            stepper.ENABLE_EXTRUDER(N);                           /* Enable the relevant E stepper... */ \
+            g_uc_extruder_last_move[N] = (BLOCK_BUFFER_SIZE) * 2; /* ...and reset its counter */ \
           } \
+          else if (!g_uc_extruder_last_move[N])                   /* Counter expired since last E stepper enable */ \
+            stepper.DISABLE_EXTRUDER(N);                          /* Disable the E stepper */ \
         }while(0);
 
       #else
 
         #define ENABLE_ONE_E(N) stepper.ENABLE_EXTRUDER(N);
 
       #endif
 
       REPEAT(E_STEPPERS, ENABLE_ONE_E); // (ENABLE_ONE_E must end with semicolon)
     }

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    üé® Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c6edfb835e..e62a9ab5ee 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -3029,21 +3029,21 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s, cons
     return false;
   #else
     return buffer_segment(machine, fr_mm_s, extruder, millimeters);
   #endif
 } // buffer_line()
 
 #if ENABLED(DIRECT_STEPPING)
 
   void Planner::buffer_page(const page_idx_t page_idx, const uint8_t extruder, const uint16_t num_steps) {
     if (!last_page_step_rate) {
-      kill(GET_TEXT(MSG_BAD_PAGE_SPEED));
+      kill(GET_TEXT_F(MSG_BAD_PAGE_SPEED));
       return;
     }
 
     uint8_t next_buffer_head;
     block_t * const block = get_next_free_block(next_buffer_head);
 
     block->flag = BLOCK_FLAG_IS_PAGE;
 
     #if HAS_FAN
       FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];

commit 33e0855e2c173680865aaa6c6aa93047d63fc469
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 01:07:51 2021 -0500

    ‚ö°Ô∏è Handle shared enable pins (#22824)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index f22a99316f..c6edfb835e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1368,27 +1368,27 @@ void Planner::check_axes_activity() {
     #if ENABLED(BARICUDA)
       TERN_(HAS_HEATER_1, tail_valve_pressure = baricuda_valve_pressure);
       TERN_(HAS_HEATER_2, tail_e_to_p_pressure = baricuda_e_to_p_pressure);
     #endif
   }
 
   //
   // Disable inactive axes
   //
   LOGICAL_AXIS_CODE(
-    if (TERN0(DISABLE_E, !axis_active.e)) disable_e_steppers(),
-    if (TERN0(DISABLE_X, !axis_active.x)) DISABLE_AXIS_X(),
-    if (TERN0(DISABLE_Y, !axis_active.y)) DISABLE_AXIS_Y(),
-    if (TERN0(DISABLE_Z, !axis_active.z)) DISABLE_AXIS_Z(),
-    if (TERN0(DISABLE_I, !axis_active.i)) DISABLE_AXIS_I(),
-    if (TERN0(DISABLE_J, !axis_active.j)) DISABLE_AXIS_J(),
-    if (TERN0(DISABLE_K, !axis_active.k)) DISABLE_AXIS_K()
+    if (TERN0(DISABLE_E, !axis_active.e)) stepper.disable_e_steppers(),
+    if (TERN0(DISABLE_X, !axis_active.x)) stepper.disable_axis(X_AXIS),
+    if (TERN0(DISABLE_Y, !axis_active.y)) stepper.disable_axis(Y_AXIS),
+    if (TERN0(DISABLE_Z, !axis_active.z)) stepper.disable_axis(Z_AXIS),
+    if (TERN0(DISABLE_I, !axis_active.i)) stepper.disable_axis(I_AXIS),
+    if (TERN0(DISABLE_J, !axis_active.j)) stepper.disable_axis(J_AXIS),
+    if (TERN0(DISABLE_K, !axis_active.k)) stepper.disable_axis(K_AXIS)
   );
 
   //
   // Update Fan speeds
   // Only if synchronous M106/M107 is disabled
   //
   TERN_(HAS_TAIL_FAN_SPEED, sync_fan_speeds(tail_fan_speed));
 
   TERN_(AUTOTEMP, autotemp_task());
 
@@ -1700,21 +1700,21 @@ void Planner::endstop_triggered(const AxisEnum axis) {
   // Record stepper position and discard the current block
   stepper.endstop_triggered(axis);
 }
 
 float Planner::triggered_position_mm(const AxisEnum axis) {
   return stepper.triggered_position(axis) * mm_per_step[axis];
 }
 
 void Planner::finish_and_disable() {
   while (has_blocks_queued() || cleaning_buffer_counter) idle();
-  disable_all_steppers();
+  stepper.disable_all_steppers();
 }
 
 /**
  * Get an axis position according to stepper position(s)
  * For CORE machines apply translation from ABC to XYZ.
  */
 float Planner::get_axis_position_mm(const AxisEnum axis) {
   float axis_steps;
   #if IS_CORE
 
@@ -2137,111 +2137,111 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   #if HAS_FAN
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
-  TERN_(HAS_MULTI_EXTRUDER, block->extruder = extruder);
+  E_TERN_(block->extruder = extruder);
 
   #if ENABLED(AUTO_POWER_CONTROL)
     if (LINEAR_AXIS_GANG(
          block->steps.x,
       || block->steps.y,
       || block->steps.z,
       || block->steps.i,
       || block->steps.j,
       || block->steps.k
     )) powerManager.power_on();
   #endif
 
   // Enable active axes
   #if EITHER(CORE_IS_XY, MARKFORGED_XY)
     if (block->steps.a || block->steps.b) {
-      ENABLE_AXIS_X();
-      ENABLE_AXIS_Y();
+      stepper.enable_axis(X_AXIS);
+      stepper.enable_axis(Y_AXIS);
     }
     #if DISABLED(Z_LATE_ENABLE)
-      if (block->steps.z) ENABLE_AXIS_Z();
+      if (block->steps.z) stepper.enable_axis(Z_AXIS);
     #endif
   #elif CORE_IS_XZ
     if (block->steps.a || block->steps.c) {
-      ENABLE_AXIS_X();
-      ENABLE_AXIS_Z();
+      stepper.enable_axis(X_AXIS);
+      stepper.enable_axis(Z_AXIS);
     }
-    if (block->steps.y) ENABLE_AXIS_Y();
+    if (block->steps.y) stepper.enable_axis(Y_AXIS);
   #elif CORE_IS_YZ
     if (block->steps.b || block->steps.c) {
-      ENABLE_AXIS_Y();
-      ENABLE_AXIS_Z();
+      stepper.enable_axis(Y_AXIS);
+      stepper.enable_axis(Z_AXIS);
     }
-    if (block->steps.x) ENABLE_AXIS_X();
+    if (block->steps.x) stepper.enable_axis(X_AXIS);
   #else
     LINEAR_AXIS_CODE(
-      if (block->steps.x) ENABLE_AXIS_X(),
-      if (block->steps.y) ENABLE_AXIS_Y(),
-      if (TERN(Z_LATE_ENABLE, 0, block->steps.z)) ENABLE_AXIS_Z(),
-      if (block->steps.i) ENABLE_AXIS_I(),
-      if (block->steps.j) ENABLE_AXIS_J(),
-      if (block->steps.k) ENABLE_AXIS_K()
+      if (block->steps.x) stepper.enable_axis(X_AXIS),
+      if (block->steps.y) stepper.enable_axis(Y_AXIS),
+      if (TERN(Z_LATE_ENABLE, 0, block->steps.z)) stepper.enable_axis(Z_AXIS),
+      if (block->steps.i) stepper.enable_axis(I_AXIS),
+      if (block->steps.j) stepper.enable_axis(J_AXIS),
+      if (block->steps.k) stepper.enable_axis(K_AXIS)
     );
   #endif
   #if EITHER(IS_CORE, MARKFORGED_XY)
     #if LINEAR_AXES >= 4
-      if (block->steps.i) ENABLE_AXIS_I();
+      if (block->steps.i) stepper.enable_axis(I_AXIS);
     #endif
     #if LINEAR_AXES >= 5
-      if (block->steps.j) ENABLE_AXIS_J();
+      if (block->steps.j) stepper.enable_axis(J_AXIS);
     #endif
     #if LINEAR_AXES >= 6
-      if (block->steps.k) ENABLE_AXIS_K();
+      if (block->steps.k) stepper.enable_axis(K_AXIS);
     #endif
   #endif
 
   // Enable extruder(s)
   #if HAS_EXTRUDERS
     if (esteps) {
       TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
         LOOP_L_N(i, E_STEPPERS)
           if (g_uc_extruder_last_move[i]) g_uc_extruder_last_move[i]--;
 
         #define E_STEPPER_INDEX(E) TERN(SWITCHING_EXTRUDER, (E) / 2, E)
 
         #define ENABLE_ONE_E(N) do{ \
           if (E_STEPPER_INDEX(extruder) == N) { \
-            ENABLE_AXIS_E##N(); \
+            stepper.ENABLE_EXTRUDER(N); \
             g_uc_extruder_last_move[N] = (BLOCK_BUFFER_SIZE) * 2; \
             if ((N) == 0 && TERN0(HAS_DUPLICATION_MODE, extruder_duplication_enabled)) \
-              ENABLE_AXIS_E1(); \
+              stepper.ENABLE_EXTRUDER(1); \
           } \
           else if (!g_uc_extruder_last_move[N]) { \
-            DISABLE_AXIS_E##N(); \
+            stepper.DISABLE_EXTRUDER(N); \
             if ((N) == 0 && TERN0(HAS_DUPLICATION_MODE, extruder_duplication_enabled)) \
-              DISABLE_AXIS_E1(); \
+              stepper.DISABLE_EXTRUDER(1); \
           } \
         }while(0);
 
       #else
 
-        #define ENABLE_ONE_E(N) ENABLE_AXIS_E##N();
+        #define ENABLE_ONE_E(N) stepper.ENABLE_EXTRUDER(N);
 
       #endif
 
       REPEAT(E_STEPPERS, ENABLE_ONE_E); // (ENABLE_ONE_E must end with semicolon)
     }
-  #endif // EXTRUDERS
+  #endif // HAS_EXTRUDERS
 
   if (esteps)
     NOLESS(fr_mm_s, settings.min_feedrate_mm_s);
   else
     NOLESS(fr_mm_s, settings.min_travel_feedrate_mm_s);
 
   const float inverse_millimeters = 1.0f / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate inverse time for this move. No divide by zero due to previous checks.
   // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
@@ -3042,21 +3042,21 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s, cons
 
     uint8_t next_buffer_head;
     block_t * const block = get_next_free_block(next_buffer_head);
 
     block->flag = BLOCK_FLAG_IS_PAGE;
 
     #if HAS_FAN
       FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
     #endif
 
-    TERN_(HAS_MULTI_EXTRUDER, block->extruder = extruder);
+    E_TERN_(block->extruder = extruder);
 
     block->page_idx = page_idx;
 
     block->step_event_count = num_steps;
     block->initial_rate = block->final_rate = block->nominal_rate = last_page_step_rate; // steps/s
 
     block->accelerate_until = 0;
     block->decelerate_after = block->step_event_count;
 
     // Will be set to last direction later if directional format.
@@ -3078,21 +3078,21 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s, cons
       // give the planner an opportunity to queue more movements and plan them
       // As there are no queued movements, the Stepper ISR will not touch this
       // variable, so there is no risk setting this here (but it MUST be done
       // before the following line!!)
       delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
     }
 
     // Move buffer head
     block_buffer_head = next_buffer_head;
 
-    enable_all_steppers();
+    stepper.enable_all_steppers();
     stepper.wake_up();
   }
 
 #endif // DIRECT_STEPPING
 
 /**
  * Directly set the planner ABCE position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * The provided ABCE position is in machine units.

commit 228eb9c404fcbcebb507bbfe781ebe3ca0a1ccdf
Author: espr14 <espr14@gmail.com>
Date:   Mon Sep 27 21:05:52 2021 +0200

    üé® steps_to_mm => mm_per_step (#22847)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 511c3b3f43..f22a99316f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -131,21 +131,21 @@ uint16_t Planner::cleaning_buffer_counter;      // A counter to disable queuing
 uint8_t Planner::delay_before_delivering;       // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
 planner_settings_t Planner::settings;           // Initialized by settings.load()
 
 #if ENABLED(LASER_POWER_INLINE)
   laser_state_t Planner::laser_inline;          // Current state for blocks
 #endif
 
 uint32_t Planner::max_acceleration_steps_per_s2[DISTINCT_AXES]; // (steps/s^2) Derived from mm_per_s2
 
-float Planner::steps_to_mm[DISTINCT_AXES];      // (mm) Millimeters per step
+float Planner::mm_per_step[DISTINCT_AXES];      // (mm) Millimeters per step
 
 #if HAS_JUNCTION_DEVIATION
   float Planner::junction_deviation_mm;         // (mm) M205 J
   #if HAS_LINEAR_E_JERK
     float Planner::max_e_jerk[DISTINCT_E];      // Calculated from junction_deviation_mm
   #endif
 #endif
 
 #if HAS_CLASSIC_JERK
   TERN(HAS_LINEAR_E_JERK, xyz_pos_t, xyze_pos_t) Planner::max_jerk;
@@ -1695,21 +1695,21 @@ void Planner::quick_stop() {
   }
 
 #endif
 
 void Planner::endstop_triggered(const AxisEnum axis) {
   // Record stepper position and discard the current block
   stepper.endstop_triggered(axis);
 }
 
 float Planner::triggered_position_mm(const AxisEnum axis) {
-  return stepper.triggered_position(axis) * steps_to_mm[axis];
+  return stepper.triggered_position(axis) * mm_per_step[axis];
 }
 
 void Planner::finish_and_disable() {
   while (has_blocks_queued() || cleaning_buffer_counter) idle();
   disable_all_steppers();
 }
 
 /**
  * Get an axis position according to stepper position(s)
  * For CORE machines apply translation from ABC to XYZ.
@@ -1752,21 +1752,21 @@ float Planner::get_axis_position_mm(const AxisEnum axis) {
     }
     else
       axis_steps = stepper.position(axis);
 
   #else
 
     axis_steps = stepper.position(axis);
 
   #endif
 
-  return axis_steps * steps_to_mm[axis];
+  return axis_steps * mm_per_step[axis];
 }
 
 /**
  * Block until all buffered steps are executed / cleaned
  */
 void Planner::synchronize() {
   while (has_blocks_queued() || cleaning_buffer_counter
       || TERN0(EXTERNAL_CLOSED_LOOP_CONTROLLER, CLOSED_LOOP_WAITING())
   ) idle();
 }
@@ -2008,65 +2008,65 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
    * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
    * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
    */
   struct DistanceMM : abce_float_t {
     #if EITHER(IS_CORE, MARKFORGED_XY)
       struct { float x, y, z; } head;
     #endif
   } steps_dist_mm;
   #if IS_CORE
     #if CORE_IS_XY
-      steps_dist_mm.head.x = da * steps_to_mm[A_AXIS];
-      steps_dist_mm.head.y = db * steps_to_mm[B_AXIS];
-      steps_dist_mm.z      = dc * steps_to_mm[Z_AXIS];
-      steps_dist_mm.a      = (da + db) * steps_to_mm[A_AXIS];
-      steps_dist_mm.b      = CORESIGN(da - db) * steps_to_mm[B_AXIS];
+      steps_dist_mm.head.x = da * mm_per_step[A_AXIS];
+      steps_dist_mm.head.y = db * mm_per_step[B_AXIS];
+      steps_dist_mm.z      = dc * mm_per_step[Z_AXIS];
+      steps_dist_mm.a      = (da + db) * mm_per_step[A_AXIS];
+      steps_dist_mm.b      = CORESIGN(da - db) * mm_per_step[B_AXIS];
     #elif CORE_IS_XZ
-      steps_dist_mm.head.x = da * steps_to_mm[A_AXIS];
-      steps_dist_mm.y      = db * steps_to_mm[Y_AXIS];
-      steps_dist_mm.head.z = dc * steps_to_mm[C_AXIS];
-      steps_dist_mm.a      = (da + dc) * steps_to_mm[A_AXIS];
-      steps_dist_mm.c      = CORESIGN(da - dc) * steps_to_mm[C_AXIS];
+      steps_dist_mm.head.x = da * mm_per_step[A_AXIS];
+      steps_dist_mm.y      = db * mm_per_step[Y_AXIS];
+      steps_dist_mm.head.z = dc * mm_per_step[C_AXIS];
+      steps_dist_mm.a      = (da + dc) * mm_per_step[A_AXIS];
+      steps_dist_mm.c      = CORESIGN(da - dc) * mm_per_step[C_AXIS];
     #elif CORE_IS_YZ
-      steps_dist_mm.x      = da * steps_to_mm[X_AXIS];
-      steps_dist_mm.head.y = db * steps_to_mm[B_AXIS];
-      steps_dist_mm.head.z = dc * steps_to_mm[C_AXIS];
-      steps_dist_mm.b      = (db + dc) * steps_to_mm[B_AXIS];
-      steps_dist_mm.c      = CORESIGN(db - dc) * steps_to_mm[C_AXIS];
+      steps_dist_mm.x      = da * mm_per_step[X_AXIS];
+      steps_dist_mm.head.y = db * mm_per_step[B_AXIS];
+      steps_dist_mm.head.z = dc * mm_per_step[C_AXIS];
+      steps_dist_mm.b      = (db + dc) * mm_per_step[B_AXIS];
+      steps_dist_mm.c      = CORESIGN(db - dc) * mm_per_step[C_AXIS];
     #endif
     #if LINEAR_AXES >= 4
-      steps_dist_mm.i = di * steps_to_mm[I_AXIS];
+      steps_dist_mm.i = di * mm_per_step[I_AXIS];
     #endif
     #if LINEAR_AXES >= 5
-      steps_dist_mm.j = dj * steps_to_mm[J_AXIS];
+      steps_dist_mm.j = dj * mm_per_step[J_AXIS];
     #endif
     #if LINEAR_AXES >= 6
-      steps_dist_mm.k = dk * steps_to_mm[K_AXIS];
+      steps_dist_mm.k = dk * mm_per_step[K_AXIS];
     #endif
   #elif ENABLED(MARKFORGED_XY)
-    steps_dist_mm.head.x = da * steps_to_mm[A_AXIS];
-    steps_dist_mm.head.y = db * steps_to_mm[B_AXIS];
-    steps_dist_mm.z      = dc * steps_to_mm[Z_AXIS];
-    steps_dist_mm.a      = (da - db) * steps_to_mm[A_AXIS];
-    steps_dist_mm.b      = db * steps_to_mm[B_AXIS];
+    steps_dist_mm.head.x = da * mm_per_step[A_AXIS];
+    steps_dist_mm.head.y = db * mm_per_step[B_AXIS];
+    steps_dist_mm.z      = dc * mm_per_step[Z_AXIS];
+    steps_dist_mm.a      = (da - db) * mm_per_step[A_AXIS];
+    steps_dist_mm.b      = db * mm_per_step[B_AXIS];
   #else
     LINEAR_AXIS_CODE(
-      steps_dist_mm.a = da * steps_to_mm[A_AXIS],
-      steps_dist_mm.b = db * steps_to_mm[B_AXIS],
-      steps_dist_mm.c = dc * steps_to_mm[C_AXIS],
-      steps_dist_mm.i = di * steps_to_mm[I_AXIS],
-      steps_dist_mm.j = dj * steps_to_mm[J_AXIS],
-      steps_dist_mm.k = dk * steps_to_mm[K_AXIS]
+      steps_dist_mm.a = da * mm_per_step[A_AXIS],
+      steps_dist_mm.b = db * mm_per_step[B_AXIS],
+      steps_dist_mm.c = dc * mm_per_step[C_AXIS],
+      steps_dist_mm.i = di * mm_per_step[I_AXIS],
+      steps_dist_mm.j = dj * mm_per_step[J_AXIS],
+      steps_dist_mm.k = dk * mm_per_step[K_AXIS]
     );
   #endif
 
-  TERN_(HAS_EXTRUDERS, steps_dist_mm.e = esteps_float * steps_to_mm[E_AXIS_N(extruder)]);
+  TERN_(HAS_EXTRUDERS, steps_dist_mm.e = esteps_float * mm_per_step[E_AXIS_N(extruder)]);
 
   TERN_(LCD_SHOW_E_TOTAL, e_move_accumulator += steps_dist_mm.e);
 
   if (true LINEAR_AXIS_GANG(
       && block->steps.a < MIN_STEPS_PER_SEGMENT,
       && block->steps.b < MIN_STEPS_PER_SEGMENT,
       && block->steps.c < MIN_STEPS_PER_SEGMENT,
       && block->steps.i < MIN_STEPS_PER_SEGMENT,
       && block->steps.j < MIN_STEPS_PER_SEGMENT,
       && block->steps.k < MIN_STEPS_PER_SEGMENT
@@ -2882,21 +2882,21 @@ bool Planner::buffer_segment(const abce_pos_t &abce
   OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
   , const_feedRate_t fr_mm_s, const uint8_t extruder/*=active_extruder*/, const_float_t millimeters/*=0.0*/
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
     if (last_extruder != extruder && settings.axis_steps_per_mm[E_AXIS_N(extruder)] != settings.axis_steps_per_mm[E_AXIS_N(last_extruder)]) {
-      position.e = LROUND(position.e * settings.axis_steps_per_mm[E_AXIS_N(extruder)] * steps_to_mm[E_AXIS_N(last_extruder)]);
+      position.e = LROUND(position.e * settings.axis_steps_per_mm[E_AXIS_N(extruder)] * mm_per_step[E_AXIS_N(last_extruder)]);
       last_extruder = extruder;
     }
   #endif
 
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
   const abce_long_t target = {
      LOGICAL_AXIS_LIST(
       int32_t(LROUND(abce.e * settings.axis_steps_per_mm[E_AXIS_N(extruder)])),
       int32_t(LROUND(abce.a * settings.axis_steps_per_mm[A_AXIS])),
@@ -3161,25 +3161,25 @@ void Planner::reset_acceleration_rates() {
   LOOP_DISTINCT_AXES(i) {
     max_acceleration_steps_per_s2[i] = settings.max_acceleration_mm_per_s2[i] * settings.axis_steps_per_mm[i];
     if (TERN1(DISTINCT_E_FACTORS, i < E_AXIS || i == E_AXIS_N(active_extruder)))
       NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   }
   acceleration_long_cutoff = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
   TERN_(HAS_LINEAR_E_JERK, recalculate_max_e_jerk());
 }
 
 /**
- * Recalculate 'position' and 'steps_to_mm'.
+ * Recalculate 'position' and 'mm_per_step'.
  * Must be called whenever settings.axis_steps_per_mm changes!
  */
 void Planner::refresh_positioning() {
-  LOOP_DISTINCT_AXES(i) steps_to_mm[i] = 1.0f / settings.axis_steps_per_mm[i];
+  LOOP_DISTINCT_AXES(i) mm_per_step[i] = 1.0f / settings.axis_steps_per_mm[i];
   set_position_mm(current_position);
   reset_acceleration_rates();
 }
 
 // Apply limits to a variable and give a warning if the value was out of range
 inline void limit_and_warn(float &val, const uint8_t axis, PGM_P const setting_name, const xyze_float_t &max_limit) {
   const uint8_t lim_axis = TERN_(HAS_EXTRUDERS, axis > E_AXIS ? E_AXIS :) axis;
   const float before = val;
   LIMIT(val, 0.1, max_limit[lim_axis]);
   if (before != val) {

commit dc5bef62ba185461ba969db6af996ebc93a33ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 23 10:01:37 2021 -0500

    üé® Various multi-axis patches (#22823)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 04fabd2df7..511c3b3f43 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1303,21 +1303,21 @@ void Planner::recalculate() {
 
   #endif
 
 #endif // HAS_FAN
 
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
 
-  #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z , DISABLE_I , DISABLE_J , DISABLE_K, DISABLE_E)
+  #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_I, DISABLE_J, DISABLE_K, DISABLE_E)
     xyze_bool_t axis_active = { false };
   #endif
 
   #if HAS_TAIL_FAN_SPEED
     uint8_t tail_fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
@@ -1906,21 +1906,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
             TERN_(HAS_POSITION_FLOAT, position_float.e = target_float.e);
             de = 0; // no difference
             SERIAL_ECHO_MSG(STR_ERR_LONG_EXTRUDE_STOP);
           }
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   // Compute direction bit-mask for this block
-  uint8_t dm = 0;
+  axis_bits_t dm = 0;
   #if CORE_IS_XY
     if (da < 0) SBI(dm, X_HEAD);                // Save the toolhead's true direction in X
     if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
     if (dc < 0) SBI(dm, Z_AXIS);
     if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
     if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
   #elif CORE_IS_XZ
     if (da < 0) SBI(dm, X_HEAD);                // Save the toolhead's true direction in X
     if (db < 0) SBI(dm, Y_AXIS);
     if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
@@ -2338,25 +2338,25 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
             SERIAL_ECHOLNPGM(" mm/s)");
             //*/
           }
         }
       #endif
     }
   #endif
 
   #ifdef XY_FREQUENCY_LIMIT
 
-    static uint8_t old_direction_bits; // = 0
+    static axis_bits_t old_direction_bits; // = 0
 
     if (xy_freq_limit_hz) {
       // Check and limit the xy direction change frequency
-      const uint8_t direction_change = block->direction_bits ^ old_direction_bits;
+      const axis_bits_t direction_change = block->direction_bits ^ old_direction_bits;
       old_direction_bits = block->direction_bits;
       segment_time_us = LROUND(float(segment_time_us) / speed_factor);
 
       static int32_t xs0, xs1, xs2, ys0, ys1, ys2;
       if (segment_time_us > xy_freq_min_interval_us)
         xs2 = xs1 = ys2 = ys1 = xy_freq_min_interval_us;
       else {
         xs2 = xs1; xs1 = xs0;
         ys2 = ys1; ys1 = ys0;
       }

commit 3344071f24b505d180dd1423b11510172c3f1c1c
Author: Dan Royer <dan@marginallyclever.com>
Date:   Mon Sep 20 13:42:33 2021 -0700

    Polargraph / Makelangelo kinematics (#22790)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 3e030c84d2..04fabd2df7 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -3014,21 +3014,21 @@ bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s, cons
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
       const float duration_recip = inv_duration ?: fr_mm_s / mm;
       const xyz_pos_t diff = delta - position_float;
       const feedRate_t feedrate = diff.magnitude() * duration_recip;
     #else
       const feedRate_t feedrate = fr_mm_s;
     #endif
-    delta.e = machine.e;
+    TERN_(HAS_EXTRUDERS, delta.e = machine.e);
     if (buffer_segment(delta OPTARG(HAS_DIST_MM_ARG, cart_dist_mm), feedrate, extruder, mm)) {
       position_cart = cart;
       return true;
     }
     return false;
   #else
     return buffer_segment(machine, fr_mm_s, extruder, millimeters);
   #endif
 } // buffer_line()
 
@@ -3119,21 +3119,21 @@ void Planner::set_machine_position_mm(const abce_pos_t &abce) {
   else
     stepper.set_position(position);
 }
 
 void Planner::set_position_mm(const xyze_pos_t &xyze) {
   xyze_pos_t machine = xyze;
   TERN_(HAS_POSITION_MODIFIERS, apply_modifiers(machine, true));
   #if IS_KINEMATIC
     position_cart = xyze;
     inverse_kinematics(machine);
-    delta.e = machine.e;
+    TERN_(HAS_EXTRUDERS, delta.e = machine.e);
     set_machine_position_mm(delta);
   #else
     set_machine_position_mm(machine);
   #endif
 }
 
 #if HAS_EXTRUDERS
 
   /**
    * Setters for planner position (also setting stepper position).

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 04d32f9c18..3e030c84d2 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1851,21 +1851,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     de = target.e - position.e,
     da = target.a - position.a,
     db = target.b - position.b,
     dc = target.c - position.c,
     di = target.i - position.i,
     dj = target.j - position.j,
     dk = target.k - position.k
   );
 
   /* <-- add a slash to enable
-    SERIAL_ECHOLNPAIR(
+    SERIAL_ECHOLNPGM(
       "  _populate_block FR:", fr_mm_s,
       " A:", target.a, " (", da, " steps)"
       " B:", target.b, " (", db, " steps)"
       " C:", target.c, " (", dc, " steps)"
       #if LINEAR_AXES >= 4
         " " AXIS4_STR ":", target.i, " (", di, " steps)"
       #endif
       #if LINEAR_AXES >= 5
         " " AXIS5_STR ":", target.j, " (", dj, " steps)"
       #endif
@@ -2324,24 +2324,24 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         const feedRate_t max_vfr = volumetric_extruder_feedrate_limit[extruder]
                                    * TERN(HAS_MIXER_SYNC_CHANNEL, MIXING_STEPPERS, 1);
 
         // TODO: Doesn't work properly for joined segments. Set MIN_STEPS_PER_SEGMENT 1 as workaround.
 
         if (block->steps.a || block->steps.b || block->steps.c) {
 
           if (max_vfr > 0 && cs > max_vfr) {
             NOMORE(speed_factor, max_vfr / cs); // respect volumetric extruder limit (if any)
             /* <-- add a slash to enable
-            SERIAL_ECHOPAIR("volumetric extruder limit enforced: ", (cs * CIRCLE_AREA(filament_size[extruder] * 0.5f)));
-            SERIAL_ECHOPAIR(" mm^3/s (", cs);
-            SERIAL_ECHOPAIR(" mm/s) limited to ", (max_vfr * CIRCLE_AREA(filament_size[extruder] * 0.5f)));
-            SERIAL_ECHOPAIR(" mm^3/s (", max_vfr);
+            SERIAL_ECHOPGM("volumetric extruder limit enforced: ", (cs * CIRCLE_AREA(filament_size[extruder] * 0.5f)));
+            SERIAL_ECHOPGM(" mm^3/s (", cs);
+            SERIAL_ECHOPGM(" mm/s) limited to ", (max_vfr * CIRCLE_AREA(filament_size[extruder] * 0.5f)));
+            SERIAL_ECHOPGM(" mm^3/s (", max_vfr);
             SERIAL_ECHOLNPGM(" mm/s)");
             //*/
           }
         }
       #endif
     }
   #endif
 
   #ifdef XY_FREQUENCY_LIMIT
 
@@ -2914,58 +2914,58 @@ bool Planner::buffer_segment(const abce_pos_t &abce
 
   #if HAS_EXTRUDERS
     // DRYRUN prevents E moves from taking place
     if (DEBUGGING(DRYRUN) || TERN0(CANCEL_OBJECTS, cancelable.skipping)) {
       position.e = target.e;
       TERN_(HAS_POSITION_FLOAT, position_float.e = abce.e);
     }
   #endif
 
   /* <-- add a slash to enable
-    SERIAL_ECHOPAIR("  buffer_segment FR:", fr_mm_s);
+    SERIAL_ECHOPGM("  buffer_segment FR:", fr_mm_s);
     #if IS_KINEMATIC
-      SERIAL_ECHOPAIR(" A:", abce.a, " (", position.a, "->", target.a, ") B:", abce.b);
+      SERIAL_ECHOPGM(" A:", abce.a, " (", position.a, "->", target.a, ") B:", abce.b);
     #else
-      SERIAL_ECHOPAIR_P(SP_X_LBL, abce.a);
-      SERIAL_ECHOPAIR(" (", position.x, "->", target.x);
+      SERIAL_ECHOPGM_P(SP_X_LBL, abce.a);
+      SERIAL_ECHOPGM(" (", position.x, "->", target.x);
       SERIAL_CHAR(')');
-      SERIAL_ECHOPAIR_P(SP_Y_LBL, abce.b);
+      SERIAL_ECHOPGM_P(SP_Y_LBL, abce.b);
     #endif
-    SERIAL_ECHOPAIR(" (", position.y, "->", target.y);
+    SERIAL_ECHOPGM(" (", position.y, "->", target.y);
     #if LINEAR_AXES >= ABC
       #if ENABLED(DELTA)
-        SERIAL_ECHOPAIR(") C:", abce.c);
+        SERIAL_ECHOPGM(") C:", abce.c);
       #else
         SERIAL_CHAR(')');
-        SERIAL_ECHOPAIR_P(SP_Z_LBL, abce.c);
+        SERIAL_ECHOPGM_P(SP_Z_LBL, abce.c);
       #endif
-      SERIAL_ECHOPAIR(" (", position.z, "->", target.z);
+      SERIAL_ECHOPGM(" (", position.z, "->", target.z);
       SERIAL_CHAR(')');
     #endif
     #if LINEAR_AXES >= 4
-      SERIAL_ECHOPAIR_P(SP_I_LBL, abce.i);
-      SERIAL_ECHOPAIR(" (", position.i, "->", target.i);
+      SERIAL_ECHOPGM_P(SP_I_LBL, abce.i);
+      SERIAL_ECHOPGM(" (", position.i, "->", target.i);
       SERIAL_CHAR(')');
     #endif
     #if LINEAR_AXES >= 5
-      SERIAL_ECHOPAIR_P(SP_J_LBL, abce.j);
-      SERIAL_ECHOPAIR(" (", position.j, "->", target.j);
+      SERIAL_ECHOPGM_P(SP_J_LBL, abce.j);
+      SERIAL_ECHOPGM(" (", position.j, "->", target.j);
       SERIAL_CHAR(')');
     #endif
     #if LINEAR_AXES >= 6
-      SERIAL_ECHOPAIR_P(SP_K_LBL, abce.k);
-      SERIAL_ECHOPAIR(" (", position.k, "->", target.k);
+      SERIAL_ECHOPGM_P(SP_K_LBL, abce.k);
+      SERIAL_ECHOPGM(" (", position.k, "->", target.k);
       SERIAL_CHAR(')');
     #endif
     #if HAS_EXTRUDERS
-      SERIAL_ECHOPAIR_P(SP_E_LBL, abce.e);
-      SERIAL_ECHOLNPAIR(" (", position.e, "->", target.e, ")");
+      SERIAL_ECHOPGM_P(SP_E_LBL, abce.e);
+      SERIAL_ECHOLNPGM(" (", position.e, "->", target.e, ")");
     #else
       SERIAL_EOL();
     #endif
   //*/
 
   // Queue the movement. Return 'false' if the move was not queued.
   if (!_buffer_steps(target
       OPTARG(HAS_POSITION_FLOAT, target_float)
       OPTARG(HAS_DIST_MM_ARG, cart_dist_mm)
       , fr_mm_s, extruder, millimeters)
@@ -3179,21 +3179,21 @@ void Planner::refresh_positioning() {
 
 // Apply limits to a variable and give a warning if the value was out of range
 inline void limit_and_warn(float &val, const uint8_t axis, PGM_P const setting_name, const xyze_float_t &max_limit) {
   const uint8_t lim_axis = TERN_(HAS_EXTRUDERS, axis > E_AXIS ? E_AXIS :) axis;
   const float before = val;
   LIMIT(val, 0.1, max_limit[lim_axis]);
   if (before != val) {
     SERIAL_CHAR(AXIS_CHAR(lim_axis));
     SERIAL_ECHOPGM(" Max ");
     SERIAL_ECHOPGM_P(setting_name);
-    SERIAL_ECHOLNPAIR(" limited to ", val);
+    SERIAL_ECHOLNPGM(" limited to ", val);
   }
 }
 
 /**
  * For the specified 'axis' set the Maximum Acceleration to the given value (mm/s^2)
  * The value may be limited with warning feedback, if configured.
  * Calls reset_acceleration_rates to precalculate planner terms in steps.
  *
  * This hard limit is applied as a block is being added to the planner queue.
  */

commit ff95a93ecc299dc8c811012e7e77e32427649cf8
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Fri Sep 3 05:08:40 2021 +0200

    üêõ Fix Mixing code typos (#22697)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 00173e9ad1..04d32f9c18 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2124,21 +2124,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   TERN_(HAS_EXTRUDERS, block->steps.e = esteps);
 
   block->step_event_count = _MAX(LOGICAL_AXIS_LIST(
     esteps, block->steps.a, block->steps.b, block->steps.c, block->steps.i, block->steps.j, block->steps.k
   ));
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
-  TERN_(MIXING_EXTRUDER, mixer.populate_block(block->b_color))
+  TERN_(MIXING_EXTRUDER, mixer.populate_block(block->b_color));
 
   TERN_(HAS_CUTTER, block->cutter_power = cutter.power);
 
   #if HAS_FAN
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;

commit 536cf287a6f642aa3eccd290b421b0e3869f018a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Aug 21 18:00:55 2021 -0500

    üé® Misc code and spacing cleanup

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e4649b9410..00173e9ad1 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1381,23 +1381,21 @@ void Planner::check_axes_activity() {
     if (TERN0(DISABLE_Z, !axis_active.z)) DISABLE_AXIS_Z(),
     if (TERN0(DISABLE_I, !axis_active.i)) DISABLE_AXIS_I(),
     if (TERN0(DISABLE_J, !axis_active.j)) DISABLE_AXIS_J(),
     if (TERN0(DISABLE_K, !axis_active.k)) DISABLE_AXIS_K()
   );
 
   //
   // Update Fan speeds
   // Only if synchronous M106/M107 is disabled
   //
-  #if HAS_TAIL_FAN_SPEED
-    sync_fan_speeds(tail_fan_speed);
-  #endif
+  TERN_(HAS_TAIL_FAN_SPEED, sync_fan_speeds(tail_fan_speed));
 
   TERN_(AUTOTEMP, autotemp_task());
 
   #if ENABLED(BARICUDA)
     TERN_(HAS_HEATER_1, analogWrite(pin_t(HEATER_1_PIN), tail_valve_pressure));
     TERN_(HAS_HEATER_2, analogWrite(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
   #endif
 }
 
 #if ENABLED(AUTOTEMP)
@@ -1578,25 +1576,21 @@ void Planner::check_axes_activity() {
     #elif HAS_MESH
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         const float fade_scaling_factor = fade_scaling_factor_for_z(raw.z);
       #elif DISABLED(MESH_BED_LEVELING)
         constexpr float fade_scaling_factor = 1.0;
       #endif
 
       raw.z += (
         #if ENABLED(MESH_BED_LEVELING)
-          mbl.get_z(raw
-            #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-              , fade_scaling_factor
-            #endif
-          )
+          mbl.get_z(raw OPTARG(ENABLE_LEVELING_FADE_HEIGHT, fade_scaling_factor))
         #elif ENABLED(AUTO_BED_LEVELING_UBL)
           fade_scaling_factor ? fade_scaling_factor * ubl.get_z_correction(raw) : 0.0
         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
           fade_scaling_factor ? fade_scaling_factor * bilinear_z_offset(raw) : 0.0
         #endif
       );
 
     #endif
   }
 
@@ -1615,25 +1609,21 @@ void Planner::check_axes_activity() {
       #elif HAS_MESH
 
         #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
           const float fade_scaling_factor = fade_scaling_factor_for_z(raw.z);
         #elif DISABLED(MESH_BED_LEVELING)
           constexpr float fade_scaling_factor = 1.0;
         #endif
 
         raw.z -= (
           #if ENABLED(MESH_BED_LEVELING)
-            mbl.get_z(raw
-              #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-                , fade_scaling_factor
-              #endif
-            )
+            mbl.get_z(raw OPTARG(ENABLE_LEVELING_FADE_HEIGHT, fade_scaling_factor))
           #elif ENABLED(AUTO_BED_LEVELING_UBL)
             fade_scaling_factor ? fade_scaling_factor * ubl.get_z_correction(raw) : 0.0
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
             fade_scaling_factor ? fade_scaling_factor * bilinear_z_offset(raw) : 0.0
           #endif
         );
 
       #endif
     }
   }
@@ -1804,26 +1794,22 @@ bool Planner::_buffer_steps(const xyze_long_t &target
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // If we are cleaning, do not accept queuing of movements
   // This must be after get_next_free_block() because it calls idle()
   // where cleaning_buffer_counter can be changed
   if (cleaning_buffer_counter) return false;
 
   // Fill the block with the specified movement
   if (!_populate_block(block, false, target
-    #if HAS_POSITION_FLOAT
-      , target_float
-    #endif
-    #if HAS_DIST_MM_ARG
-      , cart_dist_mm
-    #endif
+    OPTARG(HAS_POSITION_FLOAT, target_float)
+    OPTARG(HAS_DIST_MM_ARG, cart_dist_mm)
     , fr_mm_s, extruder, millimeters
   )) {
     // Movement was not queued, probably because it was too short.
     //  Simply accept that as movement queued and done
     return true;
   }
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
@@ -1968,23 +1954,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       if (di < 0) SBI(dm, I_AXIS);
     #endif
     #if LINEAR_AXES >= 5
       if (dj < 0) SBI(dm, J_AXIS);
     #endif
     #if LINEAR_AXES >= 6
       if (dk < 0) SBI(dm, K_AXIS);
     #endif
   #endif
 
-  #if HAS_EXTRUDERS
-    if (de < 0) SBI(dm, E_AXIS);
-  #endif
+  TERN_(HAS_EXTRUDERS, if (de < 0) SBI(dm, E_AXIS));
 
   #if HAS_EXTRUDERS
     const float esteps_float = de * e_factor[extruder];
     const uint32_t esteps = ABS(esteps_float) + 0.5f;
   #else
     constexpr uint32_t esteps = 0;
   #endif
 
   // Clear all flags, including the "busy" bit
   block->flag = 0x00;
@@ -2068,23 +2052,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     LINEAR_AXIS_CODE(
       steps_dist_mm.a = da * steps_to_mm[A_AXIS],
       steps_dist_mm.b = db * steps_to_mm[B_AXIS],
       steps_dist_mm.c = dc * steps_to_mm[C_AXIS],
       steps_dist_mm.i = di * steps_to_mm[I_AXIS],
       steps_dist_mm.j = dj * steps_to_mm[J_AXIS],
       steps_dist_mm.k = dk * steps_to_mm[K_AXIS]
     );
   #endif
 
-  #if HAS_EXTRUDERS
-    steps_dist_mm.e = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
-  #endif
+  TERN_(HAS_EXTRUDERS, steps_dist_mm.e = esteps_float * steps_to_mm[E_AXIS_N(extruder)]);
 
   TERN_(LCD_SHOW_E_TOTAL, e_move_accumulator += steps_dist_mm.e);
 
   if (true LINEAR_AXIS_GANG(
       && block->steps.a < MIN_STEPS_PER_SEGMENT,
       && block->steps.b < MIN_STEPS_PER_SEGMENT,
       && block->steps.c < MIN_STEPS_PER_SEGMENT,
       && block->steps.i < MIN_STEPS_PER_SEGMENT,
       && block->steps.j < MIN_STEPS_PER_SEGMENT,
       && block->steps.k < MIN_STEPS_PER_SEGMENT
@@ -2155,23 +2137,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   #if HAS_FAN
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
-  #if HAS_MULTI_EXTRUDER
-    block->extruder = extruder;
-  #endif
+  TERN_(HAS_MULTI_EXTRUDER, block->extruder = extruder);
 
   #if ENABLED(AUTO_POWER_CONTROL)
     if (LINEAR_AXIS_GANG(
          block->steps.x,
       || block->steps.y,
       || block->steps.z,
       || block->steps.i,
       || block->steps.j,
       || block->steps.k
     )) powerManager.power_on();
@@ -2979,26 +2959,22 @@ bool Planner::buffer_segment(const abce_pos_t &abce
     #if HAS_EXTRUDERS
       SERIAL_ECHOPAIR_P(SP_E_LBL, abce.e);
       SERIAL_ECHOLNPAIR(" (", position.e, "->", target.e, ")");
     #else
       SERIAL_EOL();
     #endif
   //*/
 
   // Queue the movement. Return 'false' if the move was not queued.
   if (!_buffer_steps(target
-      #if HAS_POSITION_FLOAT
-        , target_float
-      #endif
-      #if HAS_DIST_MM_ARG
-        , cart_dist_mm
-      #endif
+      OPTARG(HAS_POSITION_FLOAT, target_float)
+      OPTARG(HAS_DIST_MM_ARG, cart_dist_mm)
       , fr_mm_s, extruder, millimeters)
   ) return false;
 
   stepper.wake_up();
   return true;
 } // buffer_segment()
 
 /**
  * Add a new linear movement to the buffer.
  * The target is cartesian. It's translated to

commit 1903cc23c6a6a004b342503006ae9d51a5ea86c8
Author: Fjederhaek <fjederhaek@gmail.com>
Date:   Sat Aug 21 00:45:05 2021 +0200

    üêõ Update H-bot / Core for 6-axis (#22600)
    
    Followup to #19112

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7bf672a85d..e4649b9410 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1995,29 +1995,29 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   // Update block laser power
   #if ENABLED(LASER_POWER_INLINE)
     laser_inline.status.isPlanned = true;
     block->laser.status = laser_inline.status;
     block->laser.power = laser_inline.power;
   #endif
 
   // Number of steps for each axis
   // See https://www.corexy.com/theory.html
   #if CORE_IS_XY
-    block->steps.set(ABS(da + db), ABS(da - db), ABS(dc));
+    block->steps.set(LINEAR_AXIS_LIST(ABS(da + db), ABS(da - db), ABS(dc), ABS(di), ABS(dj), ABS(dk)));
   #elif CORE_IS_XZ
-    block->steps.set(ABS(da + dc), ABS(db), ABS(da - dc));
+    block->steps.set(LINEAR_AXIS_LIST(ABS(da + dc), ABS(db), ABS(da - dc), ABS(di), ABS(dj), ABS(dk)));
   #elif CORE_IS_YZ
-    block->steps.set(ABS(da), ABS(db + dc), ABS(db - dc));
+    block->steps.set(LINEAR_AXIS_LIST(ABS(da), ABS(db + dc), ABS(db - dc), ABS(di), ABS(dj), ABS(dk)));
   #elif ENABLED(MARKFORGED_XY)
-    block->steps.set(ABS(da + db), ABS(db), ABS(dc));
+    block->steps.set(LINEAR_AXIS_LIST(ABS(da + db), ABS(db), ABS(dc), ABS(di), ABS(dj), ABS(dk)));
   #elif IS_SCARA
-    block->steps.set(ABS(da), ABS(db), ABS(dc));
+    block->steps.set(LINEAR_AXIS_LIST(ABS(da), ABS(db), ABS(dc), ABS(di), ABS(dj), ABS(dk)));
   #else
     // default non-h-bot planning
     block->steps.set(LINEAR_AXIS_LIST(ABS(da), ABS(db), ABS(dc), ABS(di), ABS(dj), ABS(dk)));
   #endif
 
   /**
    * This part of the code calculates the total length of the movement.
    * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
    * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
    * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
@@ -2201,20 +2201,31 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #else
     LINEAR_AXIS_CODE(
       if (block->steps.x) ENABLE_AXIS_X(),
       if (block->steps.y) ENABLE_AXIS_Y(),
       if (TERN(Z_LATE_ENABLE, 0, block->steps.z)) ENABLE_AXIS_Z(),
       if (block->steps.i) ENABLE_AXIS_I(),
       if (block->steps.j) ENABLE_AXIS_J(),
       if (block->steps.k) ENABLE_AXIS_K()
     );
   #endif
+  #if EITHER(IS_CORE, MARKFORGED_XY)
+    #if LINEAR_AXES >= 4
+      if (block->steps.i) ENABLE_AXIS_I();
+    #endif
+    #if LINEAR_AXES >= 5
+      if (block->steps.j) ENABLE_AXIS_J();
+    #endif
+    #if LINEAR_AXES >= 6
+      if (block->steps.k) ENABLE_AXIS_K();
+    #endif
+  #endif
 
   // Enable extruder(s)
   #if HAS_EXTRUDERS
     if (esteps) {
       TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
         LOOP_L_N(i, E_STEPPERS)
           if (g_uc_extruder_last_move[i]) g_uc_extruder_last_move[i]--;

commit cc109c1802193ac2830791e8dbce269a1edb4a3b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Aug 9 16:07:15 2021 -0500

    üêõ Fix CoreXY plus extra axes
    
    See #22490

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 52ca76308c..7bf672a85d 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1870,20 +1870,29 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     dj = target.j - position.j,
     dk = target.k - position.k
   );
 
   /* <-- add a slash to enable
     SERIAL_ECHOLNPAIR(
       "  _populate_block FR:", fr_mm_s,
       " A:", target.a, " (", da, " steps)"
       " B:", target.b, " (", db, " steps)"
       " C:", target.c, " (", dc, " steps)"
+      #if LINEAR_AXES >= 4
+        " " AXIS4_STR ":", target.i, " (", di, " steps)"
+      #endif
+      #if LINEAR_AXES >= 5
+        " " AXIS5_STR ":", target.j, " (", dj, " steps)"
+      #endif
+      #if LINEAR_AXES >= 6
+        " " AXIS6_STR ":", target.k, " (", dk, " steps)"
+      #endif
       #if HAS_EXTRUDERS
         " E:", target.e, " (", de, " steps)"
       #endif
     );
   //*/
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
@@ -1946,20 +1955,33 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #else
     LINEAR_AXIS_CODE(
       if (da < 0) SBI(dm, X_AXIS),
       if (db < 0) SBI(dm, Y_AXIS),
       if (dc < 0) SBI(dm, Z_AXIS),
       if (di < 0) SBI(dm, I_AXIS),
       if (dj < 0) SBI(dm, J_AXIS),
       if (dk < 0) SBI(dm, K_AXIS)
     );
   #endif
+
+  #if IS_CORE
+    #if LINEAR_AXES >= 4
+      if (di < 0) SBI(dm, I_AXIS);
+    #endif
+    #if LINEAR_AXES >= 5
+      if (dj < 0) SBI(dm, J_AXIS);
+    #endif
+    #if LINEAR_AXES >= 6
+      if (dk < 0) SBI(dm, K_AXIS);
+    #endif
+  #endif
+
   #if HAS_EXTRUDERS
     if (de < 0) SBI(dm, E_AXIS);
   #endif
 
   #if HAS_EXTRUDERS
     const float esteps_float = de * e_factor[extruder];
     const uint32_t esteps = ABS(esteps_float) + 0.5f;
   #else
     constexpr uint32_t esteps = 0;
   #endif
@@ -1997,21 +2019,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   /**
    * This part of the code calculates the total length of the movement.
    * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
    * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
    * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
    * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
    * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
    */
   struct DistanceMM : abce_float_t {
     #if EITHER(IS_CORE, MARKFORGED_XY)
-      xyz_pos_t head;
+      struct { float x, y, z; } head;
     #endif
   } steps_dist_mm;
   #if IS_CORE
     #if CORE_IS_XY
       steps_dist_mm.head.x = da * steps_to_mm[A_AXIS];
       steps_dist_mm.head.y = db * steps_to_mm[B_AXIS];
       steps_dist_mm.z      = dc * steps_to_mm[Z_AXIS];
       steps_dist_mm.a      = (da + db) * steps_to_mm[A_AXIS];
       steps_dist_mm.b      = CORESIGN(da - db) * steps_to_mm[B_AXIS];
     #elif CORE_IS_XZ
@@ -2020,20 +2042,29 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       steps_dist_mm.head.z = dc * steps_to_mm[C_AXIS];
       steps_dist_mm.a      = (da + dc) * steps_to_mm[A_AXIS];
       steps_dist_mm.c      = CORESIGN(da - dc) * steps_to_mm[C_AXIS];
     #elif CORE_IS_YZ
       steps_dist_mm.x      = da * steps_to_mm[X_AXIS];
       steps_dist_mm.head.y = db * steps_to_mm[B_AXIS];
       steps_dist_mm.head.z = dc * steps_to_mm[C_AXIS];
       steps_dist_mm.b      = (db + dc) * steps_to_mm[B_AXIS];
       steps_dist_mm.c      = CORESIGN(db - dc) * steps_to_mm[C_AXIS];
     #endif
+    #if LINEAR_AXES >= 4
+      steps_dist_mm.i = di * steps_to_mm[I_AXIS];
+    #endif
+    #if LINEAR_AXES >= 5
+      steps_dist_mm.j = dj * steps_to_mm[J_AXIS];
+    #endif
+    #if LINEAR_AXES >= 6
+      steps_dist_mm.k = dk * steps_to_mm[K_AXIS];
+    #endif
   #elif ENABLED(MARKFORGED_XY)
     steps_dist_mm.head.x = da * steps_to_mm[A_AXIS];
     steps_dist_mm.head.y = db * steps_to_mm[B_AXIS];
     steps_dist_mm.z      = dc * steps_to_mm[Z_AXIS];
     steps_dist_mm.a      = (da - db) * steps_to_mm[A_AXIS];
     steps_dist_mm.b      = db * steps_to_mm[B_AXIS];
   #else
     LINEAR_AXIS_CODE(
       steps_dist_mm.a = da * steps_to_mm[A_AXIS],
       steps_dist_mm.b = db * steps_to_mm[B_AXIS],

commit 99a53e2c86e95cea0427742b267b244870526304
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jul 29 19:55:04 2021 -0500

    üêõ Fix 5-axis no extruder compile
    
    Fixes #22446

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e48d05b09f..52ca76308c 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2677,21 +2677,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
     // Exit speed limited by a jerk to full halt of a previous last segment
     static float previous_safe_speed;
 
     // Start with a safe speed (from which the machine may halt to stop immediately).
     float safe_speed = nominal_speed;
 
     #ifndef TRAVEL_EXTRA_XYJERK
       #define TRAVEL_EXTRA_XYJERK 0
     #endif
-    const float extra_xyjerk = (de <= 0) ? TRAVEL_EXTRA_XYJERK : 0;
+    const float extra_xyjerk = TERN0(HAS_EXTRUDERS, de <= 0) ? TRAVEL_EXTRA_XYJERK : 0;
 
     uint8_t limited = 0;
     TERN(HAS_LINEAR_E_JERK, LOOP_LINEAR_AXES, LOOP_LOGICAL_AXES)(i) {
       const float jerk = ABS(current_speed[i]),   // cs : Starting from zero, change in speed for this axis
                   maxj = (max_jerk[i] + (i == X_AXIS || i == Y_AXIS ? extra_xyjerk : 0.0f)); // mj : The max jerk setting for this axis
       if (jerk > maxj) {                          // cs > mj : New current speed too fast?
         if (limited) {                            // limited already?
           const float mjerk = nominal_speed * maxj; // ns*mj
           if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk; // ns*mj/cs
         }

commit 05ebde38127ca6c3bc056cb4068a414bade766b4
Author: lujios <83166168+lujios@users.noreply.github.com>
Date:   Tue Jul 13 02:19:29 2021 +0200

    ‚ö°Ô∏è Improve Sensorless homing/probing for G28, G33 (#21899)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 49b2d60b20..e48d05b09f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1520,20 +1520,48 @@ void Planner::check_axes_activity() {
                 ratio_2 = sq(nom_meas_ratio);
 
     volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = parser.volumetric_enabled
       ? ratio_2 / CIRCLE_AREA(filwidth.nominal_mm * 0.5f) // Volumetric uses a true volumetric multiplier
       : ratio_2;                                          // Linear squares the ratio, which scales the volume
 
     refresh_e_factor(FILAMENT_SENSOR_EXTRUDER_NUM);
   }
 #endif
 
+#if ENABLED(IMPROVE_HOMING_RELIABILITY)
+
+  void Planner::enable_stall_prevention(const bool onoff) {
+    static motion_state_t saved_motion_state;
+    if (onoff) {
+      saved_motion_state.acceleration.x = settings.max_acceleration_mm_per_s2[X_AXIS];
+      saved_motion_state.acceleration.y = settings.max_acceleration_mm_per_s2[Y_AXIS];
+      settings.max_acceleration_mm_per_s2[X_AXIS] = settings.max_acceleration_mm_per_s2[Y_AXIS] = 100;
+      #if ENABLED(DELTA)
+        saved_motion_state.acceleration.z = settings.max_acceleration_mm_per_s2[Z_AXIS];
+        settings.max_acceleration_mm_per_s2[Z_AXIS] = 100;
+      #endif
+      #if HAS_CLASSIC_JERK
+        saved_motion_state.jerk_state = max_jerk;
+        max_jerk.set(0, 0 OPTARG(DELTA, 0));
+      #endif
+    }
+    else {
+      settings.max_acceleration_mm_per_s2[X_AXIS] = saved_motion_state.acceleration.x;
+      settings.max_acceleration_mm_per_s2[Y_AXIS] = saved_motion_state.acceleration.y;
+      TERN_(DELTA, settings.max_acceleration_mm_per_s2[Z_AXIS] = saved_motion_state.acceleration.z);
+      TERN_(HAS_CLASSIC_JERK, max_jerk = saved_motion_state.jerk_state);
+    }
+    reset_acceleration_rates();
+  }
+
+#endif
+
 #if HAS_LEVELING
 
   constexpr xy_pos_t level_fulcrum = {
     TERN(Z_SAFE_HOMING, Z_SAFE_HOMING_X_POINT, X_HOME_POS),
     TERN(Z_SAFE_HOMING, Z_SAFE_HOMING_Y_POINT, Y_HOME_POS)
   };
 
   /**
    * rx, ry, rz - Cartesian positions in mm
    *              Leveled XYZ on completion

commit ba4fa4983411d03eae791b70d8ec3e26f0781785
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sun Jun 6 08:30:39 2021 +0200

    ‚úèÔ∏è Followup to Six Linear Axes (#22056)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index eb0d204cb0..49b2d60b20 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1444,21 +1444,21 @@ void Planner::check_axes_activity() {
    */
   void Planner::autotemp_task() {
     static float oldt = 0;
 
     if (!autotemp_enabled) return;
     if (thermalManager.degTargetHotend(active_extruder) < autotemp_min - 2) return; // Below the min?
 
     float high = 0.0;
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block_t *block = &block_buffer[b];
-      if (LINEAR_AXIS_GANG(block->steps.x, || block->steps.y, || block->steps.z, block->steps.i, || block->steps.j, || block->steps.k)) {
+      if (LINEAR_AXIS_GANG(block->steps.x, || block->steps.y, || block->steps.z, || block->steps.i, || block->steps.j, || block->steps.k)) {
         const float se = (float)block->steps.e / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;
         NOLESS(high, se);
       }
     }
 
     float t = autotemp_min + high * autotemp_factor;
     LIMIT(t, autotemp_min, autotemp_max);
     if (t < oldt) t *= (1.0f - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
     oldt = t;
     thermalManager.setTargetHotend(t, active_extruder);
@@ -2845,21 +2845,21 @@ bool Planner::buffer_segment(const abce_pos_t &abce
   #endif
 
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
   const abce_long_t target = {
      LOGICAL_AXIS_LIST(
       int32_t(LROUND(abce.e * settings.axis_steps_per_mm[E_AXIS_N(extruder)])),
       int32_t(LROUND(abce.a * settings.axis_steps_per_mm[A_AXIS])),
       int32_t(LROUND(abce.b * settings.axis_steps_per_mm[B_AXIS])),
       int32_t(LROUND(abce.c * settings.axis_steps_per_mm[C_AXIS])),
-      int32_t(LROUND(abce.i * settings.axis_steps_per_mm[I_AXIS])), // FIXME (DerAndere): Multiplication by 4.0 is a work-around for issue with wrong internal steps per mm
+      int32_t(LROUND(abce.i * settings.axis_steps_per_mm[I_AXIS])),
       int32_t(LROUND(abce.j * settings.axis_steps_per_mm[J_AXIS])),
       int32_t(LROUND(abce.k * settings.axis_steps_per_mm[K_AXIS]))
     )
   };
 
   #if HAS_POSITION_FLOAT
     const xyze_pos_t target_float = abce;
   #endif
 
   #if HAS_EXTRUDERS
@@ -2886,21 +2886,21 @@ bool Planner::buffer_segment(const abce_pos_t &abce
         SERIAL_ECHOPAIR(") C:", abce.c);
       #else
         SERIAL_CHAR(')');
         SERIAL_ECHOPAIR_P(SP_Z_LBL, abce.c);
       #endif
       SERIAL_ECHOPAIR(" (", position.z, "->", target.z);
       SERIAL_CHAR(')');
     #endif
     #if LINEAR_AXES >= 4
       SERIAL_ECHOPAIR_P(SP_I_LBL, abce.i);
-      SERIAL_ECHOPAIR(" (", position.i, "->", target.i); // FIXME (DerAndere): Introduce work-around for issue with wrong internal steps per mm and feedrate for I_AXIS
+      SERIAL_ECHOPAIR(" (", position.i, "->", target.i);
       SERIAL_CHAR(')');
     #endif
     #if LINEAR_AXES >= 5
       SERIAL_ECHOPAIR_P(SP_J_LBL, abce.j);
       SERIAL_ECHOPAIR(" (", position.j, "->", target.j);
       SERIAL_CHAR(')');
     #endif
     #if LINEAR_AXES >= 6
       SERIAL_ECHOPAIR_P(SP_K_LBL, abce.k);
       SERIAL_ECHOPAIR(" (", position.k, "->", target.k);

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 1ea333e926..eb0d204cb0 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1303,21 +1303,21 @@ void Planner::recalculate() {
 
   #endif
 
 #endif // HAS_FAN
 
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
 
-  #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
+  #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z , DISABLE_I , DISABLE_J , DISABLE_K, DISABLE_E)
     xyze_bool_t axis_active = { false };
   #endif
 
   #if HAS_TAIL_FAN_SPEED
     uint8_t tail_fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
@@ -1335,28 +1335,31 @@ void Planner::check_axes_activity() {
 
     #if HAS_TAIL_FAN_SPEED
       FANS_LOOP(i) tail_fan_speed[i] = thermalManager.scaledFanSpeed(i, block->fan_speed[i]);
     #endif
 
     #if ENABLED(BARICUDA)
       TERN_(HAS_HEATER_1, tail_valve_pressure = block->valve_pressure);
       TERN_(HAS_HEATER_2, tail_e_to_p_pressure = block->e_to_p_pressure);
     #endif
 
-    #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
+    #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_I, DISABLE_J, DISABLE_K, DISABLE_E)
       for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
         block_t *block = &block_buffer[b];
         LOGICAL_AXIS_CODE(
           if (TERN0(DISABLE_E, block->steps.e)) axis_active.e = true,
           if (TERN0(DISABLE_X, block->steps.x)) axis_active.x = true,
           if (TERN0(DISABLE_Y, block->steps.y)) axis_active.y = true,
-          if (TERN0(DISABLE_Z, block->steps.z)) axis_active.z = true
+          if (TERN0(DISABLE_Z, block->steps.z)) axis_active.z = true,
+          if (TERN0(DISABLE_I, block->steps.i)) axis_active.i = true,
+          if (TERN0(DISABLE_J, block->steps.j)) axis_active.j = true,
+          if (TERN0(DISABLE_K, block->steps.k)) axis_active.k = true
         );
       }
     #endif
   }
   else {
 
     TERN_(HAS_CUTTER, cutter.refresh());
 
     #if HAS_TAIL_FAN_SPEED
       FANS_LOOP(i) tail_fan_speed[i] = thermalManager.scaledFanSpeed(i);
@@ -1368,21 +1371,24 @@ void Planner::check_axes_activity() {
     #endif
   }
 
   //
   // Disable inactive axes
   //
   LOGICAL_AXIS_CODE(
     if (TERN0(DISABLE_E, !axis_active.e)) disable_e_steppers(),
     if (TERN0(DISABLE_X, !axis_active.x)) DISABLE_AXIS_X(),
     if (TERN0(DISABLE_Y, !axis_active.y)) DISABLE_AXIS_Y(),
-    if (TERN0(DISABLE_Z, !axis_active.z)) DISABLE_AXIS_Z()
+    if (TERN0(DISABLE_Z, !axis_active.z)) DISABLE_AXIS_Z(),
+    if (TERN0(DISABLE_I, !axis_active.i)) DISABLE_AXIS_I(),
+    if (TERN0(DISABLE_J, !axis_active.j)) DISABLE_AXIS_J(),
+    if (TERN0(DISABLE_K, !axis_active.k)) DISABLE_AXIS_K()
   );
 
   //
   // Update Fan speeds
   // Only if synchronous M106/M107 is disabled
   //
   #if HAS_TAIL_FAN_SPEED
     sync_fan_speeds(tail_fan_speed);
   #endif
 
@@ -1438,21 +1444,21 @@ void Planner::check_axes_activity() {
    */
   void Planner::autotemp_task() {
     static float oldt = 0;
 
     if (!autotemp_enabled) return;
     if (thermalManager.degTargetHotend(active_extruder) < autotemp_min - 2) return; // Below the min?
 
     float high = 0.0;
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block_t *block = &block_buffer[b];
-      if (block->steps.x || block->steps.y || block->steps.z) {
+      if (LINEAR_AXIS_GANG(block->steps.x, || block->steps.y, || block->steps.z, block->steps.i, || block->steps.j, || block->steps.k)) {
         const float se = (float)block->steps.e / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;
         NOLESS(high, se);
       }
     }
 
     float t = autotemp_min + high * autotemp_factor;
     LIMIT(t, autotemp_min, autotemp_max);
     if (t < oldt) t *= (1.0f - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
     oldt = t;
     thermalManager.setTargetHotend(t, active_extruder);
@@ -1824,21 +1830,24 @@ bool Planner::_buffer_steps(const xyze_long_t &target
 bool Planner::_populate_block(block_t * const block, bool split_move,
   const abce_long_t &target
   OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
   OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
   , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters/*=0.0*/
 ) {
   int32_t LOGICAL_AXIS_LIST(
     de = target.e - position.e,
     da = target.a - position.a,
     db = target.b - position.b,
-    dc = target.c - position.c
+    dc = target.c - position.c,
+    di = target.i - position.i,
+    dj = target.j - position.j,
+    dk = target.k - position.k
   );
 
   /* <-- add a slash to enable
     SERIAL_ECHOLNPAIR(
       "  _populate_block FR:", fr_mm_s,
       " A:", target.a, " (", da, " steps)"
       " B:", target.b, " (", db, " steps)"
       " C:", target.c, " (", dc, " steps)"
       #if HAS_EXTRUDERS
         " E:", target.e, " (", de, " steps)"
@@ -1903,21 +1912,24 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #elif ENABLED(MARKFORGED_XY)
     if (da < 0) SBI(dm, X_HEAD);                // Save the toolhead's true direction in X
     if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
     if (dc < 0) SBI(dm, Z_AXIS);
     if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
     if (db < 0) SBI(dm, B_AXIS);                // Motor B direction
   #else
     LINEAR_AXIS_CODE(
       if (da < 0) SBI(dm, X_AXIS),
       if (db < 0) SBI(dm, Y_AXIS),
-      if (dc < 0) SBI(dm, Z_AXIS)
+      if (dc < 0) SBI(dm, Z_AXIS),
+      if (di < 0) SBI(dm, I_AXIS),
+      if (dj < 0) SBI(dm, J_AXIS),
+      if (dk < 0) SBI(dm, K_AXIS)
     );
   #endif
   #if HAS_EXTRUDERS
     if (de < 0) SBI(dm, E_AXIS);
   #endif
 
   #if HAS_EXTRUDERS
     const float esteps_float = de * e_factor[extruder];
     const uint32_t esteps = ABS(esteps_float) + 0.5f;
   #else
@@ -1944,21 +1956,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #elif CORE_IS_XZ
     block->steps.set(ABS(da + dc), ABS(db), ABS(da - dc));
   #elif CORE_IS_YZ
     block->steps.set(ABS(da), ABS(db + dc), ABS(db - dc));
   #elif ENABLED(MARKFORGED_XY)
     block->steps.set(ABS(da + db), ABS(db), ABS(dc));
   #elif IS_SCARA
     block->steps.set(ABS(da), ABS(db), ABS(dc));
   #else
     // default non-h-bot planning
-    block->steps.set(LINEAR_AXIS_LIST(ABS(da), ABS(db), ABS(dc)));
+    block->steps.set(LINEAR_AXIS_LIST(ABS(da), ABS(db), ABS(dc), ABS(di), ABS(dj), ABS(dk)));
   #endif
 
   /**
    * This part of the code calculates the total length of the movement.
    * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
    * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
    * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
    * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
    * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
    */
@@ -1990,79 +2002,96 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #elif ENABLED(MARKFORGED_XY)
     steps_dist_mm.head.x = da * steps_to_mm[A_AXIS];
     steps_dist_mm.head.y = db * steps_to_mm[B_AXIS];
     steps_dist_mm.z      = dc * steps_to_mm[Z_AXIS];
     steps_dist_mm.a      = (da - db) * steps_to_mm[A_AXIS];
     steps_dist_mm.b      = db * steps_to_mm[B_AXIS];
   #else
     LINEAR_AXIS_CODE(
       steps_dist_mm.a = da * steps_to_mm[A_AXIS],
       steps_dist_mm.b = db * steps_to_mm[B_AXIS],
-      steps_dist_mm.c = dc * steps_to_mm[C_AXIS]
+      steps_dist_mm.c = dc * steps_to_mm[C_AXIS],
+      steps_dist_mm.i = di * steps_to_mm[I_AXIS],
+      steps_dist_mm.j = dj * steps_to_mm[J_AXIS],
+      steps_dist_mm.k = dk * steps_to_mm[K_AXIS]
     );
   #endif
 
   #if HAS_EXTRUDERS
     steps_dist_mm.e = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
   #endif
 
   TERN_(LCD_SHOW_E_TOTAL, e_move_accumulator += steps_dist_mm.e);
 
   if (true LINEAR_AXIS_GANG(
       && block->steps.a < MIN_STEPS_PER_SEGMENT,
       && block->steps.b < MIN_STEPS_PER_SEGMENT,
-      && block->steps.c < MIN_STEPS_PER_SEGMENT
+      && block->steps.c < MIN_STEPS_PER_SEGMENT,
+      && block->steps.i < MIN_STEPS_PER_SEGMENT,
+      && block->steps.j < MIN_STEPS_PER_SEGMENT,
+      && block->steps.k < MIN_STEPS_PER_SEGMENT
     )
   ) {
     block->millimeters = TERN0(HAS_EXTRUDERS, ABS(steps_dist_mm.e));
   }
   else {
     if (millimeters)
       block->millimeters = millimeters;
     else {
       block->millimeters = SQRT(
         #if EITHER(CORE_IS_XY, MARKFORGED_XY)
           LINEAR_AXIS_GANG(
-            sq(steps_dist_mm.head.x), + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.z)
+              sq(steps_dist_mm.head.x), + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.z),
+            + sq(steps_dist_mm.i),      + sq(steps_dist_mm.j),      + sq(steps_dist_mm.k)
           )
         #elif CORE_IS_XZ
           LINEAR_AXIS_GANG(
-            sq(steps_dist_mm.head.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.head.z)
+              sq(steps_dist_mm.head.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.head.z),
+            + sq(steps_dist_mm.i),      + sq(steps_dist_mm.j), + sq(steps_dist_mm.k)
           )
         #elif CORE_IS_YZ
           LINEAR_AXIS_GANG(
-            sq(steps_dist_mm.x), + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.head.z)
+              sq(steps_dist_mm.x)  + sq(steps_dist_mm.head.y) + sq(steps_dist_mm.head.z)
+            + sq(steps_dist_mm.i), + sq(steps_dist_mm.j),     + sq(steps_dist_mm.k)
           )
+        #elif ENABLED(FOAMCUTTER_XYUV)
+          // Return the largest distance move from either X/Y or I/J plane
+          #if LINEAR_AXES >= 5
+            _MAX(sq(steps_dist_mm.x) + sq(steps_dist_mm.y), sq(steps_dist_mm.i) + sq(steps_dist_mm.j))
+          #else
+            sq(steps_dist_mm.x) + sq(steps_dist_mm.y)
+          #endif
         #else
           LINEAR_AXIS_GANG(
-            sq(steps_dist_mm.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.z)
+              sq(steps_dist_mm.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.z),
+            + sq(steps_dist_mm.i), + sq(steps_dist_mm.j), + sq(steps_dist_mm.k)
           )
         #endif
       );
     }
 
     /**
      * At this point at least one of the axes has more steps than
      * MIN_STEPS_PER_SEGMENT, ensuring the segment won't get dropped as
      * zero-length. It's important to not apply corrections
      * to blocks that would get dropped!
      *
      * A correction function is permitted to add steps to an axis, it
      * should *never* remove steps!
      */
     TERN_(BACKLASH_COMPENSATION, backlash.add_correction_steps(da, db, dc, dm, block));
   }
 
   TERN_(HAS_EXTRUDERS, block->steps.e = esteps);
 
   block->step_event_count = _MAX(LOGICAL_AXIS_LIST(
-    esteps, block->steps.a, block->steps.b, block->steps.c
+    esteps, block->steps.a, block->steps.b, block->steps.c, block->steps.i, block->steps.j, block->steps.k
   ));
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   TERN_(MIXING_EXTRUDER, mixer.populate_block(block->b_color))
 
   TERN_(HAS_CUTTER, block->cutter_power = cutter.power);
 
   #if HAS_FAN
@@ -2075,21 +2104,24 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #endif
 
   #if HAS_MULTI_EXTRUDER
     block->extruder = extruder;
   #endif
 
   #if ENABLED(AUTO_POWER_CONTROL)
     if (LINEAR_AXIS_GANG(
          block->steps.x,
       || block->steps.y,
-      || block->steps.z
+      || block->steps.z,
+      || block->steps.i,
+      || block->steps.j,
+      || block->steps.k
     )) powerManager.power_on();
   #endif
 
   // Enable active axes
   #if EITHER(CORE_IS_XY, MARKFORGED_XY)
     if (block->steps.a || block->steps.b) {
       ENABLE_AXIS_X();
       ENABLE_AXIS_Y();
     }
     #if DISABLED(Z_LATE_ENABLE)
@@ -2104,21 +2136,24 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #elif CORE_IS_YZ
     if (block->steps.b || block->steps.c) {
       ENABLE_AXIS_Y();
       ENABLE_AXIS_Z();
     }
     if (block->steps.x) ENABLE_AXIS_X();
   #else
     LINEAR_AXIS_CODE(
       if (block->steps.x) ENABLE_AXIS_X(),
       if (block->steps.y) ENABLE_AXIS_Y(),
-      if (TERN(Z_LATE_ENABLE, 0, block->steps.z)) ENABLE_AXIS_Z()
+      if (TERN(Z_LATE_ENABLE, 0, block->steps.z)) ENABLE_AXIS_Z(),
+      if (block->steps.i) ENABLE_AXIS_I(),
+      if (block->steps.j) ENABLE_AXIS_J(),
+      if (block->steps.k) ENABLE_AXIS_K()
     );
   #endif
 
   // Enable extruder(s)
   #if HAS_EXTRUDERS
     if (esteps) {
       TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
@@ -2294,22 +2329,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   if (speed_factor < 1.0f) {
     current_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
     block->nominal_speed_sqr = block->nominal_speed_sqr * sq(speed_factor);
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
   if (LINEAR_AXIS_GANG(
-    !block->steps.a, && !block->steps.b, && !block->steps.c
-  )) {                                                            // Is this a retract / recover move?
+         !block->steps.a, && !block->steps.b, && !block->steps.c,
+      && !block->steps.i, && !block->steps.j, && !block->steps.k)
+  ) {                                                             // Is this a retract / recover move?
     accel = CEIL(settings.retract_acceleration * steps_per_mm);   // Convert to: acceleration steps/sec^2
     TERN_(LIN_ADVANCE, block->use_advance_lead = false);          // No linear advance for simple retract/recover
   }
   else {
     #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
         const uint32_t max_possible = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count / block->steps[AXIS]; \
         NOMORE(accel, max_possible); \
       } \
     }while(0)
@@ -2364,29 +2400,35 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         }
       }
     #endif
 
     // Limit acceleration per axis
     if (block->step_event_count <= acceleration_long_cutoff) {
       LOGICAL_AXIS_CODE(
         LIMIT_ACCEL_LONG(E_AXIS, E_INDEX_N(extruder)),
         LIMIT_ACCEL_LONG(A_AXIS, 0),
         LIMIT_ACCEL_LONG(B_AXIS, 0),
-        LIMIT_ACCEL_LONG(C_AXIS, 0)
+        LIMIT_ACCEL_LONG(C_AXIS, 0),
+        LIMIT_ACCEL_LONG(I_AXIS, 0),
+        LIMIT_ACCEL_LONG(J_AXIS, 0),
+        LIMIT_ACCEL_LONG(K_AXIS, 0)
       );
     }
     else {
       LOGICAL_AXIS_CODE(
         LIMIT_ACCEL_FLOAT(E_AXIS, E_INDEX_N(extruder)),
         LIMIT_ACCEL_FLOAT(A_AXIS, 0),
         LIMIT_ACCEL_FLOAT(B_AXIS, 0),
-        LIMIT_ACCEL_FLOAT(C_AXIS, 0)
+        LIMIT_ACCEL_FLOAT(C_AXIS, 0),
+        LIMIT_ACCEL_FLOAT(I_AXIS, 0),
+        LIMIT_ACCEL_FLOAT(J_AXIS, 0),
+        LIMIT_ACCEL_FLOAT(K_AXIS, 0)
       );
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
     block->acceleration_rate = (uint32_t)(accel * (sq(4096.0f) / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
@@ -2437,21 +2479,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           can be spared, a better acos could be used. For all I know, it may be
           already calculated in a different place. */
 
     // Unit vector of previous path line segment
     static xyze_float_t prev_unit_vec;
 
     xyze_float_t unit_vec =
       #if HAS_DIST_MM_ARG
         cart_dist_mm
       #else
-        LOGICAL_AXIS_ARRAY(steps_dist_mm.e, steps_dist_mm.x, steps_dist_mm.y, steps_dist_mm.z)
+        LOGICAL_AXIS_ARRAY(steps_dist_mm.e, steps_dist_mm.x, steps_dist_mm.y, steps_dist_mm.z, steps_dist_mm.i, steps_dist_mm.j, steps_dist_mm.k)
       #endif
     ;
 
     /**
      * On CoreXY the length of the vector [A,B] is SQRT(2) times the length of the head movement vector [X,Y].
      * So taking Z and E into account, we cannot scale to a unit vector with "inverse_millimeters".
      * => normalize the complete junction vector.
      * Elsewise, when needed JD will factor-in the E component
      */
     if (EITHER(IS_CORE, MARKFORGED_XY) || esteps > 0)
@@ -2460,21 +2502,24 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       unit_vec *= inverse_millimeters;      // Use pre-calculated (1 / SQRT(x^2 + y^2 + z^2))
 
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
       float junction_cos_theta = LOGICAL_AXIS_GANG(
                                  + (-prev_unit_vec.e * unit_vec.e),
                                    (-prev_unit_vec.x * unit_vec.x),
                                  + (-prev_unit_vec.y * unit_vec.y),
-                                 + (-prev_unit_vec.z * unit_vec.z)
+                                 + (-prev_unit_vec.z * unit_vec.z),
+                                 + (-prev_unit_vec.i * unit_vec.i),
+                                 + (-prev_unit_vec.j * unit_vec.j),
+                                 + (-prev_unit_vec.k * unit_vec.k)
                                );
 
       // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
       if (junction_cos_theta > 0.999999f) {
         // For a 0 degree acute junction, just set minimum junction speed.
         vmax_junction_sqr = sq(float(MINIMUM_PLANNER_SPEED));
       }
       else {
         NOLESS(junction_cos_theta, -0.999999f); // Check for numerical round-off to avoid divide by zero.
 
@@ -2776,89 +2821,104 @@ void Planner::buffer_sync_block(TERN_(LASER_SYNCHRONOUS_M106_M107, uint8_t sync_
  *
  * Leveling and kinematics should be applied ahead of calling this.
  *
  *  a,b,c,e     - target positions in mm and/or degrees
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *  millimeters - the length of the movement, if known
  *
  * Return 'false' if no segment was queued due to cleaning, cold extrusion, full queue, etc.
  */
-bool Planner::buffer_segment(
-  LOGICAL_AXIS_LIST(const_float_t e, const_float_t a, const_float_t b, const_float_t c)
+bool Planner::buffer_segment(const abce_pos_t &abce
   OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
-  , const_feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters/*=0.0*/
+  , const_feedRate_t fr_mm_s, const uint8_t extruder/*=active_extruder*/, const_float_t millimeters/*=0.0*/
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
     if (last_extruder != extruder && settings.axis_steps_per_mm[E_AXIS_N(extruder)] != settings.axis_steps_per_mm[E_AXIS_N(last_extruder)]) {
       position.e = LROUND(position.e * settings.axis_steps_per_mm[E_AXIS_N(extruder)] * steps_to_mm[E_AXIS_N(last_extruder)]);
       last_extruder = extruder;
     }
   #endif
 
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
   const abce_long_t target = {
      LOGICAL_AXIS_LIST(
-      int32_t(LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(extruder)])),
-      int32_t(LROUND(a * settings.axis_steps_per_mm[A_AXIS])),
-      int32_t(LROUND(b * settings.axis_steps_per_mm[B_AXIS])),
-      int32_t(LROUND(c * settings.axis_steps_per_mm[C_AXIS]))
+      int32_t(LROUND(abce.e * settings.axis_steps_per_mm[E_AXIS_N(extruder)])),
+      int32_t(LROUND(abce.a * settings.axis_steps_per_mm[A_AXIS])),
+      int32_t(LROUND(abce.b * settings.axis_steps_per_mm[B_AXIS])),
+      int32_t(LROUND(abce.c * settings.axis_steps_per_mm[C_AXIS])),
+      int32_t(LROUND(abce.i * settings.axis_steps_per_mm[I_AXIS])), // FIXME (DerAndere): Multiplication by 4.0 is a work-around for issue with wrong internal steps per mm
+      int32_t(LROUND(abce.j * settings.axis_steps_per_mm[J_AXIS])),
+      int32_t(LROUND(abce.k * settings.axis_steps_per_mm[K_AXIS]))
     )
   };
 
   #if HAS_POSITION_FLOAT
-    const xyze_pos_t target_float = LOGICAL_AXIS_ARRAY(e, a, b, c);
+    const xyze_pos_t target_float = abce;
   #endif
 
   #if HAS_EXTRUDERS
     // DRYRUN prevents E moves from taking place
     if (DEBUGGING(DRYRUN) || TERN0(CANCEL_OBJECTS, cancelable.skipping)) {
       position.e = target.e;
-      TERN_(HAS_POSITION_FLOAT, position_float.e = e);
+      TERN_(HAS_POSITION_FLOAT, position_float.e = abce.e);
     }
   #endif
 
   /* <-- add a slash to enable
     SERIAL_ECHOPAIR("  buffer_segment FR:", fr_mm_s);
     #if IS_KINEMATIC
-      SERIAL_ECHOPAIR(" A:", a);
-      SERIAL_ECHOPAIR(" (", position.a);
-      SERIAL_ECHOPAIR("->", target.a);
-      SERIAL_ECHOPAIR(") B:", b);
+      SERIAL_ECHOPAIR(" A:", abce.a, " (", position.a, "->", target.a, ") B:", abce.b);
     #else
-      SERIAL_ECHOPAIR_P(SP_X_LBL, a);
-      SERIAL_ECHOPAIR(" (", position.x);
-      SERIAL_ECHOPAIR("->", target.x);
+      SERIAL_ECHOPAIR_P(SP_X_LBL, abce.a);
+      SERIAL_ECHOPAIR(" (", position.x, "->", target.x);
       SERIAL_CHAR(')');
-      SERIAL_ECHOPAIR_P(SP_Y_LBL, b);
+      SERIAL_ECHOPAIR_P(SP_Y_LBL, abce.b);
     #endif
-    SERIAL_ECHOPAIR(" (", position.y);
-    SERIAL_ECHOPAIR("->", target.y);
-    #if ENABLED(DELTA)
-      SERIAL_ECHOPAIR(") C:", c);
-    #else
+    SERIAL_ECHOPAIR(" (", position.y, "->", target.y);
+    #if LINEAR_AXES >= ABC
+      #if ENABLED(DELTA)
+        SERIAL_ECHOPAIR(") C:", abce.c);
+      #else
+        SERIAL_CHAR(')');
+        SERIAL_ECHOPAIR_P(SP_Z_LBL, abce.c);
+      #endif
+      SERIAL_ECHOPAIR(" (", position.z, "->", target.z);
+      SERIAL_CHAR(')');
+    #endif
+    #if LINEAR_AXES >= 4
+      SERIAL_ECHOPAIR_P(SP_I_LBL, abce.i);
+      SERIAL_ECHOPAIR(" (", position.i, "->", target.i); // FIXME (DerAndere): Introduce work-around for issue with wrong internal steps per mm and feedrate for I_AXIS
       SERIAL_CHAR(')');
-      SERIAL_ECHOPAIR_P(SP_Z_LBL, c);
     #endif
-    SERIAL_ECHOPAIR(" (", position.z);
-    SERIAL_ECHOPAIR("->", target.z);
-    SERIAL_CHAR(')');
-    SERIAL_ECHOPAIR_P(SP_E_LBL, e);
-    SERIAL_ECHOPAIR(" (", position.e);
-    SERIAL_ECHOPAIR("->", target.e);
-    SERIAL_ECHOLNPGM(")");
+    #if LINEAR_AXES >= 5
+      SERIAL_ECHOPAIR_P(SP_J_LBL, abce.j);
+      SERIAL_ECHOPAIR(" (", position.j, "->", target.j);
+      SERIAL_CHAR(')');
+    #endif
+    #if LINEAR_AXES >= 6
+      SERIAL_ECHOPAIR_P(SP_K_LBL, abce.k);
+      SERIAL_ECHOPAIR(" (", position.k, "->", target.k);
+      SERIAL_CHAR(')');
+    #endif
+    #if HAS_EXTRUDERS
+      SERIAL_ECHOPAIR_P(SP_E_LBL, abce.e);
+      SERIAL_ECHOLNPAIR(" (", position.e, "->", target.e, ")");
+    #else
+      SERIAL_EOL();
+    #endif
   //*/
 
   // Queue the movement. Return 'false' if the move was not queued.
   if (!_buffer_steps(target
       #if HAS_POSITION_FLOAT
         , target_float
       #endif
       #if HAS_DIST_MM_ARG
         , cart_dist_mm
       #endif
@@ -2867,72 +2927,67 @@ bool Planner::buffer_segment(
 
   stepper.wake_up();
   return true;
 } // buffer_segment()
 
 /**
  * Add a new linear movement to the buffer.
  * The target is cartesian. It's translated to
  * delta/scara if needed.
  *
- *  rx,ry,rz,e   - target position in mm or degrees
- *  fr_mm_s      - (target) speed of the move (mm/s)
- *  extruder     - target extruder
- *  millimeters  - the length of the movement, if known
- *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
+ *  cart            - target position in mm or degrees
+ *  fr_mm_s         - (target) speed of the move (mm/s)
+ *  extruder        - target extruder
+ *  millimeters     - the length of the movement, if known
+ *  inv_duration    - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
  */
-bool Planner::buffer_line(
-  LOGICAL_AXIS_LIST(const_float_t e, const_float_t rx, const_float_t ry, const_float_t rz)
-  , const feedRate_t &fr_mm_s, const uint8_t extruder, const float millimeters
-  OPTARG(SCARA_FEEDRATE_SCALING, const_float_t inv_duration)
+bool Planner::buffer_line(const xyze_pos_t &cart, const_feedRate_t fr_mm_s, const uint8_t extruder/*=active_extruder*/, const float millimeters/*=0.0*/
+  OPTARG(SCARA_FEEDRATE_SCALING, const_float_t inv_duration/*=0.0*/)
 ) {
-  xyze_pos_t machine = LOGICAL_AXIS_ARRAY(e, rx, ry, rz);
+  xyze_pos_t machine = cart;
   TERN_(HAS_POSITION_MODIFIERS, apply_modifiers(machine));
 
   #if IS_KINEMATIC
 
     #if HAS_JUNCTION_DEVIATION
-      const xyze_pos_t cart_dist_mm = {
-        rx - position_cart.x, ry - position_cart.y,
-        rz - position_cart.z, e  - position_cart.e
-      };
+      const xyze_pos_t cart_dist_mm = LOGICAL_AXIS_ARRAY(
+        cart.e - position_cart.e,
+        cart.x - position_cart.x, cart.y - position_cart.y, cart.z - position_cart.z,
+        cart.i - position_cart.i, cart.j - position_cart.j, cart.j - position_cart.k
+      );
     #else
-      const xyz_pos_t cart_dist_mm = { rx - position_cart.x, ry - position_cart.y, rz - position_cart.z };
+      const xyz_pos_t cart_dist_mm = LINEAR_AXIS_ARRAY(
+        cart.x - position_cart.x, cart.y - position_cart.y, cart.z - position_cart.z,
+        cart.i - position_cart.i, cart.j - position_cart.j, cart.j - position_cart.k
+      );
     #endif
 
-    float mm = millimeters;
-    if (mm == 0.0)
-      mm = (cart_dist_mm.x != 0.0 || cart_dist_mm.y != 0.0) ? cart_dist_mm.magnitude() : ABS(cart_dist_mm.z);
+    const float mm = millimeters ?: (cart_dist_mm.x || cart_dist_mm.y) ? cart_dist_mm.magnitude() : TERN0(HAS_Z_AXIS, ABS(cart_dist_mm.z));
 
     // Cartesian XYZ to kinematic ABC, stored in global 'delta'
     inverse_kinematics(machine);
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
       const float duration_recip = inv_duration ?: fr_mm_s / mm;
       const xyz_pos_t diff = delta - position_float;
       const feedRate_t feedrate = diff.magnitude() * duration_recip;
     #else
       const feedRate_t feedrate = fr_mm_s;
     #endif
-    if (buffer_segment(delta.a, delta.b, delta.c, machine.e
-      #if HAS_JUNCTION_DEVIATION
-        , cart_dist_mm
-      #endif
-      , feedrate, extruder, mm
-    )) {
-      position_cart.set(rx, ry, rz, e);
+    delta.e = machine.e;
+    if (buffer_segment(delta OPTARG(HAS_DIST_MM_ARG, cart_dist_mm), feedrate, extruder, mm)) {
+      position_cart = cart;
       return true;
     }
-    else
-      return false;
+    return false;
   #else
     return buffer_segment(machine, fr_mm_s, extruder, millimeters);
   #endif
 } // buffer_line()
 
 #if ENABLED(DIRECT_STEPPING)
 
   void Planner::buffer_page(const page_idx_t page_idx, const uint8_t extruder, const uint16_t num_steps) {
     if (!last_page_step_rate) {
       kill(GET_TEXT(MSG_BAD_PAGE_SPEED));
@@ -2984,95 +3039,90 @@ bool Planner::buffer_line(
     // Move buffer head
     block_buffer_head = next_buffer_head;
 
     enable_all_steppers();
     stepper.wake_up();
   }
 
 #endif // DIRECT_STEPPING
 
 /**
- * Directly set the planner ABC position (and stepper positions)
+ * Directly set the planner ABCE position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
- * The provided ABC position is in machine units.
+ * The provided ABCE position is in machine units.
  */
-
-void Planner::set_machine_position_mm(
-  LOGICAL_AXIS_LIST(const_float_t e, const_float_t a, const_float_t b, const_float_t c)
-) {
+void Planner::set_machine_position_mm(const abce_pos_t &abce) {
   TERN_(DISTINCT_E_FACTORS, last_extruder = active_extruder);
-  TERN_(HAS_POSITION_FLOAT, position_float.set(LOGICAL_AXIS_LIST(e, a, b, c)));
+  TERN_(HAS_POSITION_FLOAT, position_float = abce);
   position.set(
     LOGICAL_AXIS_LIST(
-      LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(active_extruder)]),
-      LROUND(a * settings.axis_steps_per_mm[A_AXIS]),
-      LROUND(b * settings.axis_steps_per_mm[B_AXIS]),
-      LROUND(c * settings.axis_steps_per_mm[C_AXIS])
+      LROUND(abce.e * settings.axis_steps_per_mm[E_AXIS_N(active_extruder)]),
+      LROUND(abce.a * settings.axis_steps_per_mm[A_AXIS]),
+      LROUND(abce.b * settings.axis_steps_per_mm[B_AXIS]),
+      LROUND(abce.c * settings.axis_steps_per_mm[C_AXIS]),
+      LROUND(abce.i * settings.axis_steps_per_mm[I_AXIS]),
+      LROUND(abce.j * settings.axis_steps_per_mm[J_AXIS]),
+      LROUND(abce.k * settings.axis_steps_per_mm[K_AXIS])
     )
   );
   if (has_blocks_queued()) {
     //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.
     //previous_speed.reset();
     buffer_sync_block();
   }
   else
     stepper.set_position(position);
 }
 
-void Planner::set_position_mm(
-  LOGICAL_AXIS_LIST(const_float_t e, const_float_t rx, const_float_t ry, const_float_t rz)
-) {
-  xyze_pos_t machine = LOGICAL_AXIS_ARRAY(e, rx, ry, rz);
+void Planner::set_position_mm(const xyze_pos_t &xyze) {
+  xyze_pos_t machine = xyze;
   TERN_(HAS_POSITION_MODIFIERS, apply_modifiers(machine, true));
   #if IS_KINEMATIC
-    position_cart.set(rx, ry, rz, e);
+    position_cart = xyze;
     inverse_kinematics(machine);
-    set_machine_position_mm(delta.a, delta.b, delta.c, machine.e);
+    delta.e = machine.e;
+    set_machine_position_mm(delta);
   #else
     set_machine_position_mm(machine);
   #endif
 }
 
 #if HAS_EXTRUDERS
 
   /**
    * Setters for planner position (also setting stepper position).
    */
   void Planner::set_e_position_mm(const_float_t e) {
     const uint8_t axis_index = E_AXIS_N(active_extruder);
     TERN_(DISTINCT_E_FACTORS, last_extruder = active_extruder);
 
     const float e_new = DIFF_TERN(FWRETRACT, e, fwretract.current_retract[active_extruder]);
     position.e = LROUND(settings.axis_steps_per_mm[axis_index] * e_new);
     TERN_(HAS_POSITION_FLOAT, position_float.e = e_new);
-    TERN_(IS_KINEMATIC, position_cart.e = e);
+    TERN_(IS_KINEMATIC, TERN_(HAS_EXTRUDERS, position_cart.e = e));
 
     if (has_blocks_queued())
       buffer_sync_block();
     else
       stepper.set_axis_position(E_AXIS, position.e);
   }
 
 #endif
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
-  #if ENABLED(DISTINCT_E_FACTORS)
-    #define AXIS_CONDITION (i < E_AXIS || i == E_AXIS_N(active_extruder))
-  #else
-    #define AXIS_CONDITION true
-  #endif
   uint32_t highest_rate = 1;
   LOOP_DISTINCT_AXES(i) {
     max_acceleration_steps_per_s2[i] = settings.max_acceleration_mm_per_s2[i] * settings.axis_steps_per_mm[i];
-    if (AXIS_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
+    if (TERN1(DISTINCT_E_FACTORS, i < E_AXIS || i == E_AXIS_N(active_extruder)))
+      NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   }
   acceleration_long_cutoff = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
   TERN_(HAS_LINEAR_E_JERK, recalculate_max_e_jerk());
 }
 
 /**
  * Recalculate 'position' and 'steps_to_mm'.
  * Must be called whenever settings.axis_steps_per_mm changes!
  */
 void Planner::refresh_positioning() {

commit eea9b6d8ae38af3ca9d5b2f6fb355fc8fce405fb
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sat Jun 5 03:02:37 2021 +0200

    üêõ Fix MMU compile with >5 EXTRUDERS (#22036)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c06e4be79b..1ea333e926 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -206,21 +206,21 @@ skew_factor_t Planner::skew_factor; // Initialized by settings.load()
 // private:
 
 xyze_long_t Planner::position{0};
 
 uint32_t Planner::acceleration_long_cutoff;
 
 xyze_float_t Planner::previous_speed;
 float Planner::previous_nominal_speed_sqr;
 
 #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
-  last_move_t Planner::g_uc_extruder_last_move[EXTRUDERS] = { 0 };
+  last_move_t Planner::g_uc_extruder_last_move[E_STEPPERS] = { 0 };
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
   int8_t Planner::xy_freq_limit_hz = XY_FREQUENCY_LIMIT;
   float Planner::xy_freq_min_speed_factor = (XY_FREQUENCY_MIN_PERCENT) * 0.01f;
   int32_t Planner::xy_freq_min_interval_us = LROUND(1000000.0 / (XY_FREQUENCY_LIMIT));
 #endif
 
 #if ENABLED(LIN_ADVANCE)
   float Planner::extruder_advance_K[EXTRUDERS]; // Initialized by settings.load()
@@ -2115,44 +2115,46 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     );
   #endif
 
   // Enable extruder(s)
   #if HAS_EXTRUDERS
     if (esteps) {
       TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
-        LOOP_L_N(i, EXTRUDERS)
+        LOOP_L_N(i, E_STEPPERS)
           if (g_uc_extruder_last_move[i]) g_uc_extruder_last_move[i]--;
 
+        #define E_STEPPER_INDEX(E) TERN(SWITCHING_EXTRUDER, (E) / 2, E)
+
         #define ENABLE_ONE_E(N) do{ \
-          if (extruder == N) { \
+          if (E_STEPPER_INDEX(extruder) == N) { \
             ENABLE_AXIS_E##N(); \
             g_uc_extruder_last_move[N] = (BLOCK_BUFFER_SIZE) * 2; \
             if ((N) == 0 && TERN0(HAS_DUPLICATION_MODE, extruder_duplication_enabled)) \
               ENABLE_AXIS_E1(); \
           } \
           else if (!g_uc_extruder_last_move[N]) { \
             DISABLE_AXIS_E##N(); \
             if ((N) == 0 && TERN0(HAS_DUPLICATION_MODE, extruder_duplication_enabled)) \
               DISABLE_AXIS_E1(); \
           } \
         }while(0);
 
       #else
 
         #define ENABLE_ONE_E(N) ENABLE_AXIS_E##N();
 
       #endif
 
-      REPEAT(EXTRUDERS, ENABLE_ONE_E); // (ENABLE_ONE_E must end with semicolon)
+      REPEAT(E_STEPPERS, ENABLE_ONE_E); // (ENABLE_ONE_E must end with semicolon)
     }
   #endif // EXTRUDERS
 
   if (esteps)
     NOLESS(fr_mm_s, settings.min_feedrate_mm_s);
   else
     NOLESS(fr_mm_s, settings.min_travel_feedrate_mm_s);
 
   const float inverse_millimeters = 1.0f / block->millimeters;  // Inverse millimeters to remove multiple divides
 

commit dd4990252e891cdfe56cb7d6e3bbe1e6289be649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 24 16:38:57 2021 -0500

    ‚ôªÔ∏è Refactor Linear / Logical / Distinct Axes (#21953)
    
    * More patches supporting EXTRUDERS 0
    * Extend types in prep for more axes

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 09db12cd7a..c06e4be79b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1338,48 +1338,52 @@ void Planner::check_axes_activity() {
     #endif
 
     #if ENABLED(BARICUDA)
       TERN_(HAS_HEATER_1, tail_valve_pressure = block->valve_pressure);
       TERN_(HAS_HEATER_2, tail_e_to_p_pressure = block->e_to_p_pressure);
     #endif
 
     #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
       for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
         block_t *block = &block_buffer[b];
-        if (ENABLED(DISABLE_X) && block->steps.x) axis_active.x = true;
-        if (ENABLED(DISABLE_Y) && block->steps.y) axis_active.y = true;
-        if (ENABLED(DISABLE_Z) && block->steps.z) axis_active.z = true;
-        if (ENABLED(DISABLE_E) && block->steps.e) axis_active.e = true;
+        LOGICAL_AXIS_CODE(
+          if (TERN0(DISABLE_E, block->steps.e)) axis_active.e = true,
+          if (TERN0(DISABLE_X, block->steps.x)) axis_active.x = true,
+          if (TERN0(DISABLE_Y, block->steps.y)) axis_active.y = true,
+          if (TERN0(DISABLE_Z, block->steps.z)) axis_active.z = true
+        );
       }
     #endif
   }
   else {
 
     TERN_(HAS_CUTTER, cutter.refresh());
 
     #if HAS_TAIL_FAN_SPEED
       FANS_LOOP(i) tail_fan_speed[i] = thermalManager.scaledFanSpeed(i);
     #endif
 
     #if ENABLED(BARICUDA)
       TERN_(HAS_HEATER_1, tail_valve_pressure = baricuda_valve_pressure);
       TERN_(HAS_HEATER_2, tail_e_to_p_pressure = baricuda_e_to_p_pressure);
     #endif
   }
 
   //
   // Disable inactive axes
   //
-  if (TERN0(DISABLE_X, !axis_active.x)) DISABLE_AXIS_X();
-  if (TERN0(DISABLE_Y, !axis_active.y)) DISABLE_AXIS_Y();
-  if (TERN0(DISABLE_Z, !axis_active.z)) DISABLE_AXIS_Z();
-  if (TERN0(DISABLE_E, !axis_active.e)) disable_e_steppers();
+  LOGICAL_AXIS_CODE(
+    if (TERN0(DISABLE_E, !axis_active.e)) disable_e_steppers(),
+    if (TERN0(DISABLE_X, !axis_active.x)) DISABLE_AXIS_X(),
+    if (TERN0(DISABLE_Y, !axis_active.y)) DISABLE_AXIS_Y(),
+    if (TERN0(DISABLE_Z, !axis_active.z)) DISABLE_AXIS_Z()
+  );
 
   //
   // Update Fan speeds
   // Only if synchronous M106/M107 is disabled
   //
   #if HAS_TAIL_FAN_SPEED
     sync_fan_speeds(tail_fan_speed);
   #endif
 
   TERN_(AUTOTEMP, autotemp_task());
@@ -1816,30 +1820,26 @@ bool Planner::_buffer_steps(const xyze_long_t &target
  *  extruder    - target extruder
  *
  * Returns true if movement is acceptable, false otherwise
  */
 bool Planner::_populate_block(block_t * const block, bool split_move,
   const abce_long_t &target
   OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
   OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
   , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters/*=0.0*/
 ) {
-
-  const int32_t da = target.a - position.a,
-                db = target.b - position.b,
-                dc = target.c - position.c;
-
-  #if HAS_EXTRUDERS
-    int32_t de = target.e - position.e;
-  #else
-    constexpr int32_t de = 0;
-  #endif
+  int32_t LOGICAL_AXIS_LIST(
+    de = target.e - position.e,
+    da = target.a - position.a,
+    db = target.b - position.b,
+    dc = target.c - position.c
+  );
 
   /* <-- add a slash to enable
     SERIAL_ECHOLNPAIR(
       "  _populate_block FR:", fr_mm_s,
       " A:", target.a, " (", da, " steps)"
       " B:", target.b, " (", db, " steps)"
       " C:", target.c, " (", dc, " steps)"
       #if HAS_EXTRUDERS
         " E:", target.e, " (", de, " steps)"
       #endif
@@ -1876,49 +1876,53 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
             SERIAL_ECHO_MSG(STR_ERR_LONG_EXTRUDE_STOP);
           }
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   // Compute direction bit-mask for this block
   uint8_t dm = 0;
   #if CORE_IS_XY
-    if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
+    if (da < 0) SBI(dm, X_HEAD);                // Save the toolhead's true direction in X
     if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
     if (dc < 0) SBI(dm, Z_AXIS);
     if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
     if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
   #elif CORE_IS_XZ
-    if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
+    if (da < 0) SBI(dm, X_HEAD);                // Save the toolhead's true direction in X
     if (db < 0) SBI(dm, Y_AXIS);
     if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
     if (da + dc < 0) SBI(dm, A_AXIS);           // Motor A direction
     if (CORESIGN(da - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
   #elif CORE_IS_YZ
     if (da < 0) SBI(dm, X_AXIS);
-    if (db < 0) SBI(dm, Y_HEAD);                // Save the real Extruder (head) direction in Y Axis
+    if (db < 0) SBI(dm, Y_HEAD);                // Save the toolhead's true direction in Y
     if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
     if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
     if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
   #elif ENABLED(MARKFORGED_XY)
-    if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
+    if (da < 0) SBI(dm, X_HEAD);                // Save the toolhead's true direction in X
     if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
     if (dc < 0) SBI(dm, Z_AXIS);
     if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
     if (db < 0) SBI(dm, B_AXIS);                // Motor B direction
   #else
-    if (da < 0) SBI(dm, X_AXIS);
-    if (db < 0) SBI(dm, Y_AXIS);
-    if (dc < 0) SBI(dm, Z_AXIS);
+    LINEAR_AXIS_CODE(
+      if (da < 0) SBI(dm, X_AXIS),
+      if (db < 0) SBI(dm, Y_AXIS),
+      if (dc < 0) SBI(dm, Z_AXIS)
+    );
+  #endif
+  #if HAS_EXTRUDERS
+    if (de < 0) SBI(dm, E_AXIS);
   #endif
-  if (de < 0) SBI(dm, E_AXIS);
 
   #if HAS_EXTRUDERS
     const float esteps_float = de * e_factor[extruder];
     const uint32_t esteps = ABS(esteps_float) + 0.5f;
   #else
     constexpr uint32_t esteps = 0;
   #endif
 
   // Clear all flags, including the "busy" bit
   block->flag = 0x00;
@@ -1940,21 +1944,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #elif CORE_IS_XZ
     block->steps.set(ABS(da + dc), ABS(db), ABS(da - dc));
   #elif CORE_IS_YZ
     block->steps.set(ABS(da), ABS(db + dc), ABS(db - dc));
   #elif ENABLED(MARKFORGED_XY)
     block->steps.set(ABS(da + db), ABS(db), ABS(dc));
   #elif IS_SCARA
     block->steps.set(ABS(da), ABS(db), ABS(dc));
   #else
     // default non-h-bot planning
-    block->steps.set(ABS(da), ABS(db), ABS(dc));
+    block->steps.set(LINEAR_AXIS_LIST(ABS(da), ABS(db), ABS(dc)));
   #endif
 
   /**
    * This part of the code calculates the total length of the movement.
    * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
    * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
    * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
    * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
    * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
    */
@@ -1983,73 +1987,83 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       steps_dist_mm.b      = (db + dc) * steps_to_mm[B_AXIS];
       steps_dist_mm.c      = CORESIGN(db - dc) * steps_to_mm[C_AXIS];
     #endif
   #elif ENABLED(MARKFORGED_XY)
     steps_dist_mm.head.x = da * steps_to_mm[A_AXIS];
     steps_dist_mm.head.y = db * steps_to_mm[B_AXIS];
     steps_dist_mm.z      = dc * steps_to_mm[Z_AXIS];
     steps_dist_mm.a      = (da - db) * steps_to_mm[A_AXIS];
     steps_dist_mm.b      = db * steps_to_mm[B_AXIS];
   #else
-    steps_dist_mm.a = da * steps_to_mm[A_AXIS];
-    steps_dist_mm.b = db * steps_to_mm[B_AXIS];
-    steps_dist_mm.c = dc * steps_to_mm[C_AXIS];
+    LINEAR_AXIS_CODE(
+      steps_dist_mm.a = da * steps_to_mm[A_AXIS],
+      steps_dist_mm.b = db * steps_to_mm[B_AXIS],
+      steps_dist_mm.c = dc * steps_to_mm[C_AXIS]
+    );
   #endif
 
   #if HAS_EXTRUDERS
     steps_dist_mm.e = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
-  #else
-    steps_dist_mm.e = 0.0f;
   #endif
 
   TERN_(LCD_SHOW_E_TOTAL, e_move_accumulator += steps_dist_mm.e);
 
-  if (block->steps.a < MIN_STEPS_PER_SEGMENT && block->steps.b < MIN_STEPS_PER_SEGMENT && block->steps.c < MIN_STEPS_PER_SEGMENT) {
-    block->millimeters = (0
-      #if HAS_EXTRUDERS
-        + ABS(steps_dist_mm.e)
-      #endif
-    );
+  if (true LINEAR_AXIS_GANG(
+      && block->steps.a < MIN_STEPS_PER_SEGMENT,
+      && block->steps.b < MIN_STEPS_PER_SEGMENT,
+      && block->steps.c < MIN_STEPS_PER_SEGMENT
+    )
+  ) {
+    block->millimeters = TERN0(HAS_EXTRUDERS, ABS(steps_dist_mm.e));
   }
   else {
     if (millimeters)
       block->millimeters = millimeters;
-    else
+    else {
       block->millimeters = SQRT(
         #if EITHER(CORE_IS_XY, MARKFORGED_XY)
-          sq(steps_dist_mm.head.x) + sq(steps_dist_mm.head.y) + sq(steps_dist_mm.z)
+          LINEAR_AXIS_GANG(
+            sq(steps_dist_mm.head.x), + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.z)
+          )
         #elif CORE_IS_XZ
-          sq(steps_dist_mm.head.x) + sq(steps_dist_mm.y) + sq(steps_dist_mm.head.z)
+          LINEAR_AXIS_GANG(
+            sq(steps_dist_mm.head.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.head.z)
+          )
         #elif CORE_IS_YZ
-          sq(steps_dist_mm.x) + sq(steps_dist_mm.head.y) + sq(steps_dist_mm.head.z)
+          LINEAR_AXIS_GANG(
+            sq(steps_dist_mm.x), + sq(steps_dist_mm.head.y), + sq(steps_dist_mm.head.z)
+          )
         #else
-          sq(steps_dist_mm.x) + sq(steps_dist_mm.y) + sq(steps_dist_mm.z)
+          LINEAR_AXIS_GANG(
+            sq(steps_dist_mm.x), + sq(steps_dist_mm.y), + sq(steps_dist_mm.z)
+          )
         #endif
       );
+    }
 
     /**
      * At this point at least one of the axes has more steps than
      * MIN_STEPS_PER_SEGMENT, ensuring the segment won't get dropped as
      * zero-length. It's important to not apply corrections
      * to blocks that would get dropped!
      *
      * A correction function is permitted to add steps to an axis, it
      * should *never* remove steps!
      */
     TERN_(BACKLASH_COMPENSATION, backlash.add_correction_steps(da, db, dc, dm, block));
   }
 
-  #if HAS_EXTRUDERS
-    block->steps.e = esteps;
-  #endif
+  TERN_(HAS_EXTRUDERS, block->steps.e = esteps);
 
-  block->step_event_count = _MAX(block->steps.a, block->steps.b, block->steps.c, esteps);
+  block->step_event_count = _MAX(LOGICAL_AXIS_LIST(
+    esteps, block->steps.a, block->steps.b, block->steps.c
+  ));
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   TERN_(MIXING_EXTRUDER, mixer.populate_block(block->b_color))
 
   TERN_(HAS_CUTTER, block->cutter_power = cutter.power);
 
   #if HAS_FAN
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
@@ -2058,22 +2072,25 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
   #if HAS_MULTI_EXTRUDER
     block->extruder = extruder;
   #endif
 
   #if ENABLED(AUTO_POWER_CONTROL)
-    if (block->steps.x || block->steps.y || block->steps.z)
-      powerManager.power_on();
+    if (LINEAR_AXIS_GANG(
+         block->steps.x,
+      || block->steps.y,
+      || block->steps.z
+    )) powerManager.power_on();
   #endif
 
   // Enable active axes
   #if EITHER(CORE_IS_XY, MARKFORGED_XY)
     if (block->steps.a || block->steps.b) {
       ENABLE_AXIS_X();
       ENABLE_AXIS_Y();
     }
     #if DISABLED(Z_LATE_ENABLE)
       if (block->steps.z) ENABLE_AXIS_Z();
@@ -2084,25 +2101,25 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       ENABLE_AXIS_Z();
     }
     if (block->steps.y) ENABLE_AXIS_Y();
   #elif CORE_IS_YZ
     if (block->steps.b || block->steps.c) {
       ENABLE_AXIS_Y();
       ENABLE_AXIS_Z();
     }
     if (block->steps.x) ENABLE_AXIS_X();
   #else
-    if (block->steps.x) ENABLE_AXIS_X();
-    if (block->steps.y) ENABLE_AXIS_Y();
-    #if DISABLED(Z_LATE_ENABLE)
-      if (block->steps.z) ENABLE_AXIS_Z();
-    #endif
+    LINEAR_AXIS_CODE(
+      if (block->steps.x) ENABLE_AXIS_X(),
+      if (block->steps.y) ENABLE_AXIS_Y(),
+      if (TERN(Z_LATE_ENABLE, 0, block->steps.z)) ENABLE_AXIS_Z()
+    );
   #endif
 
   // Enable extruder(s)
   #if HAS_EXTRUDERS
     if (esteps) {
       TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
         LOOP_L_N(i, EXTRUDERS)
@@ -2274,21 +2291,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   // Correct the speed
   if (speed_factor < 1.0f) {
     current_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
     block->nominal_speed_sqr = block->nominal_speed_sqr * sq(speed_factor);
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
-  if (!block->steps.a && !block->steps.b && !block->steps.c) {    // Is this a retract / recover move?
+  if (LINEAR_AXIS_GANG(
+    !block->steps.a, && !block->steps.b, && !block->steps.c
+  )) {                                                            // Is this a retract / recover move?
     accel = CEIL(settings.retract_acceleration * steps_per_mm);   // Convert to: acceleration steps/sec^2
     TERN_(LIN_ADVANCE, block->use_advance_lead = false);          // No linear advance for simple retract/recover
   }
   else {
     #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
         const uint32_t max_possible = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count / block->steps[AXIS]; \
         NOMORE(accel, max_possible); \
       } \
     }while(0)
@@ -2339,30 +2358,34 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           const uint32_t max_accel_steps_per_s2 = MAX_E_JERK(extruder) / (extruder_advance_K[active_extruder] * block->e_D_ratio) * steps_per_mm;
           if (TERN0(LA_DEBUG, accel > max_accel_steps_per_s2))
             SERIAL_ECHOLNPGM("Acceleration limited.");
           NOMORE(accel, max_accel_steps_per_s2);
         }
       }
     #endif
 
     // Limit acceleration per axis
     if (block->step_event_count <= acceleration_long_cutoff) {
-      LIMIT_ACCEL_LONG(A_AXIS, 0);
-      LIMIT_ACCEL_LONG(B_AXIS, 0);
-      LIMIT_ACCEL_LONG(C_AXIS, 0);
-      LIMIT_ACCEL_LONG(E_AXIS, E_INDEX_N(extruder));
+      LOGICAL_AXIS_CODE(
+        LIMIT_ACCEL_LONG(E_AXIS, E_INDEX_N(extruder)),
+        LIMIT_ACCEL_LONG(A_AXIS, 0),
+        LIMIT_ACCEL_LONG(B_AXIS, 0),
+        LIMIT_ACCEL_LONG(C_AXIS, 0)
+      );
     }
     else {
-      LIMIT_ACCEL_FLOAT(A_AXIS, 0);
-      LIMIT_ACCEL_FLOAT(B_AXIS, 0);
-      LIMIT_ACCEL_FLOAT(C_AXIS, 0);
-      LIMIT_ACCEL_FLOAT(E_AXIS, E_INDEX_N(extruder));
+      LOGICAL_AXIS_CODE(
+        LIMIT_ACCEL_FLOAT(E_AXIS, E_INDEX_N(extruder)),
+        LIMIT_ACCEL_FLOAT(A_AXIS, 0),
+        LIMIT_ACCEL_FLOAT(B_AXIS, 0),
+        LIMIT_ACCEL_FLOAT(C_AXIS, 0)
+      );
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
     block->acceleration_rate = (uint32_t)(accel * (sq(4096.0f) / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
       block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * settings.axis_steps_per_mm[E_AXIS_N(extruder)]);
@@ -2412,41 +2435,45 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           can be spared, a better acos could be used. For all I know, it may be
           already calculated in a different place. */
 
     // Unit vector of previous path line segment
     static xyze_float_t prev_unit_vec;
 
     xyze_float_t unit_vec =
       #if HAS_DIST_MM_ARG
         cart_dist_mm
       #else
-        { steps_dist_mm.x, steps_dist_mm.y, steps_dist_mm.z, steps_dist_mm.e }
+        LOGICAL_AXIS_ARRAY(steps_dist_mm.e, steps_dist_mm.x, steps_dist_mm.y, steps_dist_mm.z)
       #endif
     ;
 
     /**
      * On CoreXY the length of the vector [A,B] is SQRT(2) times the length of the head movement vector [X,Y].
      * So taking Z and E into account, we cannot scale to a unit vector with "inverse_millimeters".
      * => normalize the complete junction vector.
      * Elsewise, when needed JD will factor-in the E component
      */
     if (EITHER(IS_CORE, MARKFORGED_XY) || esteps > 0)
       normalize_junction_vector(unit_vec);  // Normalize with XYZE components
     else
       unit_vec *= inverse_millimeters;      // Use pre-calculated (1 / SQRT(x^2 + y^2 + z^2))
 
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
-      float junction_cos_theta = (-prev_unit_vec.x * unit_vec.x) + (-prev_unit_vec.y * unit_vec.y)
-                               + (-prev_unit_vec.z * unit_vec.z) + (-prev_unit_vec.e * unit_vec.e);
+      float junction_cos_theta = LOGICAL_AXIS_GANG(
+                                 + (-prev_unit_vec.e * unit_vec.e),
+                                   (-prev_unit_vec.x * unit_vec.x),
+                                 + (-prev_unit_vec.y * unit_vec.y),
+                                 + (-prev_unit_vec.z * unit_vec.z)
+                               );
 
       // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
       if (junction_cos_theta > 0.999999f) {
         // For a 0 degree acute junction, just set minimum junction speed.
         vmax_junction_sqr = sq(float(MINIMUM_PLANNER_SPEED));
       }
       else {
         NOLESS(junction_cos_theta, -0.999999f); // Check for numerical round-off to avoid divide by zero.
 
         // Convert delta vector to unit vector
@@ -2747,54 +2774,59 @@ void Planner::buffer_sync_block(TERN_(LASER_SYNCHRONOUS_M106_M107, uint8_t sync_
  *
  * Leveling and kinematics should be applied ahead of calling this.
  *
  *  a,b,c,e     - target positions in mm and/or degrees
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *  millimeters - the length of the movement, if known
  *
  * Return 'false' if no segment was queued due to cleaning, cold extrusion, full queue, etc.
  */
-bool Planner::buffer_segment(const_float_t a, const_float_t b, const_float_t c, const_float_t e
+bool Planner::buffer_segment(
+  LOGICAL_AXIS_LIST(const_float_t e, const_float_t a, const_float_t b, const_float_t c)
   OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
   , const_feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters/*=0.0*/
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
     if (last_extruder != extruder && settings.axis_steps_per_mm[E_AXIS_N(extruder)] != settings.axis_steps_per_mm[E_AXIS_N(last_extruder)]) {
       position.e = LROUND(position.e * settings.axis_steps_per_mm[E_AXIS_N(extruder)] * steps_to_mm[E_AXIS_N(last_extruder)]);
       last_extruder = extruder;
     }
   #endif
 
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
   const abce_long_t target = {
-    int32_t(LROUND(a * settings.axis_steps_per_mm[A_AXIS])),
-    int32_t(LROUND(b * settings.axis_steps_per_mm[B_AXIS])),
-    int32_t(LROUND(c * settings.axis_steps_per_mm[C_AXIS])),
-    int32_t(LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(extruder)]))
+     LOGICAL_AXIS_LIST(
+      int32_t(LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(extruder)])),
+      int32_t(LROUND(a * settings.axis_steps_per_mm[A_AXIS])),
+      int32_t(LROUND(b * settings.axis_steps_per_mm[B_AXIS])),
+      int32_t(LROUND(c * settings.axis_steps_per_mm[C_AXIS]))
+    )
   };
 
   #if HAS_POSITION_FLOAT
-    const xyze_pos_t target_float = { a, b, c, e };
+    const xyze_pos_t target_float = LOGICAL_AXIS_ARRAY(e, a, b, c);
   #endif
 
-  // DRYRUN prevents E moves from taking place
-  if (DEBUGGING(DRYRUN) || TERN0(CANCEL_OBJECTS, cancelable.skipping)) {
-    position.e = target.e;
-    TERN_(HAS_POSITION_FLOAT, position_float.e = e);
-  }
+  #if HAS_EXTRUDERS
+    // DRYRUN prevents E moves from taking place
+    if (DEBUGGING(DRYRUN) || TERN0(CANCEL_OBJECTS, cancelable.skipping)) {
+      position.e = target.e;
+      TERN_(HAS_POSITION_FLOAT, position_float.e = e);
+    }
+  #endif
 
   /* <-- add a slash to enable
     SERIAL_ECHOPAIR("  buffer_segment FR:", fr_mm_s);
     #if IS_KINEMATIC
       SERIAL_ECHOPAIR(" A:", a);
       SERIAL_ECHOPAIR(" (", position.a);
       SERIAL_ECHOPAIR("->", target.a);
       SERIAL_ECHOPAIR(") B:", b);
     #else
       SERIAL_ECHOPAIR_P(SP_X_LBL, a);
@@ -2839,24 +2871,26 @@ bool Planner::buffer_segment(const_float_t a, const_float_t b, const_float_t c,
  * Add a new linear movement to the buffer.
  * The target is cartesian. It's translated to
  * delta/scara if needed.
  *
  *  rx,ry,rz,e   - target position in mm or degrees
  *  fr_mm_s      - (target) speed of the move (mm/s)
  *  extruder     - target extruder
  *  millimeters  - the length of the movement, if known
  *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
  */
-bool Planner::buffer_line(const_float_t rx, const_float_t ry, const_float_t rz, const_float_t e, const_feedRate_t fr_mm_s, const uint8_t extruder, const float millimeters
+bool Planner::buffer_line(
+  LOGICAL_AXIS_LIST(const_float_t e, const_float_t rx, const_float_t ry, const_float_t rz)
+  , const feedRate_t &fr_mm_s, const uint8_t extruder, const float millimeters
   OPTARG(SCARA_FEEDRATE_SCALING, const_float_t inv_duration)
 ) {
-  xyze_pos_t machine = { rx, ry, rz, e };
+  xyze_pos_t machine = LOGICAL_AXIS_ARRAY(e, rx, ry, rz);
   TERN_(HAS_POSITION_MODIFIERS, apply_modifiers(machine));
 
   #if IS_KINEMATIC
 
     #if HAS_JUNCTION_DEVIATION
       const xyze_pos_t cart_dist_mm = {
         rx - position_cart.x, ry - position_cart.y,
         rz - position_cart.z, e  - position_cart.e
       };
     #else
@@ -2905,30 +2939,26 @@ bool Planner::buffer_line(const_float_t rx, const_float_t ry, const_float_t rz,
 
     uint8_t next_buffer_head;
     block_t * const block = get_next_free_block(next_buffer_head);
 
     block->flag = BLOCK_FLAG_IS_PAGE;
 
     #if HAS_FAN
       FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
     #endif
 
-    #if HAS_MULTI_EXTRUDER
-      block->extruder = extruder;
-    #endif
+    TERN_(HAS_MULTI_EXTRUDER, block->extruder = extruder);
 
     block->page_idx = page_idx;
 
     block->step_event_count = num_steps;
-    block->initial_rate =
-      block->final_rate =
-      block->nominal_rate = last_page_step_rate; // steps/s
+    block->initial_rate = block->final_rate = block->nominal_rate = last_page_step_rate; // steps/s
 
     block->accelerate_until = 0;
     block->decelerate_after = block->step_event_count;
 
     // Will be set to last direction later if directional format.
     block->direction_bits = 0;
 
     #define PAGE_UPDATE_DIR(AXIS) \
       if (!last_page_dir[_AXIS(AXIS)]) SBI(block->direction_bits, _AXIS(AXIS));
 
@@ -2958,67 +2988,77 @@ bool Planner::buffer_line(const_float_t rx, const_float_t ry, const_float_t rz,
 
 #endif // DIRECT_STEPPING
 
 /**
  * Directly set the planner ABC position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * The provided ABC position is in machine units.
  */
 
-void Planner::set_machine_position_mm(const_float_t a, const_float_t b, const_float_t c, const_float_t e) {
+void Planner::set_machine_position_mm(
+  LOGICAL_AXIS_LIST(const_float_t e, const_float_t a, const_float_t b, const_float_t c)
+) {
   TERN_(DISTINCT_E_FACTORS, last_extruder = active_extruder);
-  TERN_(HAS_POSITION_FLOAT, position_float.set(a, b, c, e));
-  position.set(LROUND(a * settings.axis_steps_per_mm[A_AXIS]),
-               LROUND(b * settings.axis_steps_per_mm[B_AXIS]),
-               LROUND(c * settings.axis_steps_per_mm[C_AXIS]),
-               LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(active_extruder)]));
+  TERN_(HAS_POSITION_FLOAT, position_float.set(LOGICAL_AXIS_LIST(e, a, b, c)));
+  position.set(
+    LOGICAL_AXIS_LIST(
+      LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(active_extruder)]),
+      LROUND(a * settings.axis_steps_per_mm[A_AXIS]),
+      LROUND(b * settings.axis_steps_per_mm[B_AXIS]),
+      LROUND(c * settings.axis_steps_per_mm[C_AXIS])
+    )
+  );
   if (has_blocks_queued()) {
     //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.
     //previous_speed.reset();
     buffer_sync_block();
   }
   else
     stepper.set_position(position);
 }
 
-void Planner::set_position_mm(const_float_t rx, const_float_t ry, const_float_t rz, const_float_t e) {
-  xyze_pos_t machine = { rx, ry, rz, e };
-  #if HAS_POSITION_MODIFIERS
-    apply_modifiers(machine, true);
-  #endif
+void Planner::set_position_mm(
+  LOGICAL_AXIS_LIST(const_float_t e, const_float_t rx, const_float_t ry, const_float_t rz)
+) {
+  xyze_pos_t machine = LOGICAL_AXIS_ARRAY(e, rx, ry, rz);
+  TERN_(HAS_POSITION_MODIFIERS, apply_modifiers(machine, true));
   #if IS_KINEMATIC
     position_cart.set(rx, ry, rz, e);
     inverse_kinematics(machine);
     set_machine_position_mm(delta.a, delta.b, delta.c, machine.e);
   #else
     set_machine_position_mm(machine);
   #endif
 }
 
-/**
- * Setters for planner position (also setting stepper position).
- */
-void Planner::set_e_position_mm(const_float_t e) {
-  const uint8_t axis_index = E_AXIS_N(active_extruder);
-  TERN_(DISTINCT_E_FACTORS, last_extruder = active_extruder);
+#if HAS_EXTRUDERS
 
-  const float e_new = DIFF_TERN(FWRETRACT, e, fwretract.current_retract[active_extruder]);
-  position.e = LROUND(settings.axis_steps_per_mm[axis_index] * e_new);
-  TERN_(HAS_POSITION_FLOAT, position_float.e = e_new);
-  TERN_(IS_KINEMATIC, position_cart.e = e);
+  /**
+   * Setters for planner position (also setting stepper position).
+   */
+  void Planner::set_e_position_mm(const_float_t e) {
+    const uint8_t axis_index = E_AXIS_N(active_extruder);
+    TERN_(DISTINCT_E_FACTORS, last_extruder = active_extruder);
 
-  if (has_blocks_queued())
-    buffer_sync_block();
-  else
-    stepper.set_axis_position(E_AXIS, position.e);
-}
+    const float e_new = DIFF_TERN(FWRETRACT, e, fwretract.current_retract[active_extruder]);
+    position.e = LROUND(settings.axis_steps_per_mm[axis_index] * e_new);
+    TERN_(HAS_POSITION_FLOAT, position_float.e = e_new);
+    TERN_(IS_KINEMATIC, position_cart.e = e);
+
+    if (has_blocks_queued())
+      buffer_sync_block();
+    else
+      stepper.set_axis_position(E_AXIS, position.e);
+  }
+
+#endif
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define AXIS_CONDITION (i < E_AXIS || i == E_AXIS_N(active_extruder))
   #else
     #define AXIS_CONDITION true
   #endif
   uint32_t highest_rate = 1;
   LOOP_DISTINCT_AXES(i) {
@@ -3034,25 +3074,25 @@ void Planner::reset_acceleration_rates() {
  * Must be called whenever settings.axis_steps_per_mm changes!
  */
 void Planner::refresh_positioning() {
   LOOP_DISTINCT_AXES(i) steps_to_mm[i] = 1.0f / settings.axis_steps_per_mm[i];
   set_position_mm(current_position);
   reset_acceleration_rates();
 }
 
 // Apply limits to a variable and give a warning if the value was out of range
 inline void limit_and_warn(float &val, const uint8_t axis, PGM_P const setting_name, const xyze_float_t &max_limit) {
-  const uint8_t lim_axis = axis > E_AXIS ? E_AXIS : axis;
+  const uint8_t lim_axis = TERN_(HAS_EXTRUDERS, axis > E_AXIS ? E_AXIS :) axis;
   const float before = val;
   LIMIT(val, 0.1, max_limit[lim_axis]);
   if (before != val) {
-    SERIAL_CHAR(axis_codes[lim_axis]);
+    SERIAL_CHAR(AXIS_CHAR(lim_axis));
     SERIAL_ECHOPGM(" Max ");
     SERIAL_ECHOPGM_P(setting_name);
     SERIAL_ECHOLNPAIR(" limited to ", val);
   }
 }
 
 /**
  * For the specified 'axis' set the Maximum Acceleration to the given value (mm/s^2)
  * The value may be limited with warning feedback, if configured.
  * Calls reset_acceleration_rates to precalculate planner terms in steps.

commit 84fd0eff17d089e3f75f6585d4bba47f15c00ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 23 21:33:22 2021 -0500

    üé® Macros for optional arguments (#21969)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 714be8019e..09db12cd7a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1750,26 +1750,22 @@ void Planner::synchronize() {
  *
  *  target        - target position in steps units
  *  target_float  - target position in direct (mm, degrees) units. optional
  *  fr_mm_s       - (target) speed of the move
  *  extruder      - target extruder
  *  millimeters   - the length of the movement, if known
  *
  * Returns true if movement was properly queued, false otherwise (if cleaning)
  */
 bool Planner::_buffer_steps(const xyze_long_t &target
-  #if HAS_POSITION_FLOAT
-    , const xyze_pos_t &target_float
-  #endif
-  #if HAS_DIST_MM_ARG
-    , const xyze_float_t &cart_dist_mm
-  #endif
+  OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
+  OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
   , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters
 ) {
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // If we are cleaning, do not accept queuing of movements
   // This must be after get_next_free_block() because it calls idle()
   // where cleaning_buffer_counter can be changed
@@ -1816,26 +1812,22 @@ bool Planner::_buffer_steps(const xyze_long_t &target
  * Fills a new linear movement in the block (in terms of steps).
  *
  *  target      - target position in steps units
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *
  * Returns true if movement is acceptable, false otherwise
  */
 bool Planner::_populate_block(block_t * const block, bool split_move,
   const abce_long_t &target
-  #if HAS_POSITION_FLOAT
-    , const xyze_pos_t &target_float
-  #endif
-  #if HAS_DIST_MM_ARG
-    , const xyze_float_t &cart_dist_mm
-  #endif
+  OPTARG(HAS_POSITION_FLOAT, const xyze_pos_t &target_float)
+  OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
   , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters/*=0.0*/
 ) {
 
   const int32_t da = target.a - position.a,
                 db = target.b - position.b,
                 dc = target.c - position.c;
 
   #if HAS_EXTRUDERS
     int32_t de = target.e - position.e;
   #else
@@ -2756,23 +2748,21 @@ void Planner::buffer_sync_block(TERN_(LASER_SYNCHRONOUS_M106_M107, uint8_t sync_
  * Leveling and kinematics should be applied ahead of calling this.
  *
  *  a,b,c,e     - target positions in mm and/or degrees
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *  millimeters - the length of the movement, if known
  *
  * Return 'false' if no segment was queued due to cleaning, cold extrusion, full queue, etc.
  */
 bool Planner::buffer_segment(const_float_t a, const_float_t b, const_float_t c, const_float_t e
-  #if HAS_DIST_MM_ARG
-    , const xyze_float_t &cart_dist_mm
-  #endif
+  OPTARG(HAS_DIST_MM_ARG, const xyze_float_t &cart_dist_mm)
   , const_feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters/*=0.0*/
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
     if (last_extruder != extruder && settings.axis_steps_per_mm[E_AXIS_N(extruder)] != settings.axis_steps_per_mm[E_AXIS_N(last_extruder)]) {
       position.e = LROUND(position.e * settings.axis_steps_per_mm[E_AXIS_N(extruder)] * steps_to_mm[E_AXIS_N(last_extruder)]);
@@ -2850,23 +2840,21 @@ bool Planner::buffer_segment(const_float_t a, const_float_t b, const_float_t c,
  * The target is cartesian. It's translated to
  * delta/scara if needed.
  *
  *  rx,ry,rz,e   - target position in mm or degrees
  *  fr_mm_s      - (target) speed of the move (mm/s)
  *  extruder     - target extruder
  *  millimeters  - the length of the movement, if known
  *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
  */
 bool Planner::buffer_line(const_float_t rx, const_float_t ry, const_float_t rz, const_float_t e, const_feedRate_t fr_mm_s, const uint8_t extruder, const float millimeters
-  #if ENABLED(SCARA_FEEDRATE_SCALING)
-    , const_float_t inv_duration
-  #endif
+  OPTARG(SCARA_FEEDRATE_SCALING, const_float_t inv_duration)
 ) {
   xyze_pos_t machine = { rx, ry, rz, e };
   TERN_(HAS_POSITION_MODIFIERS, apply_modifiers(machine));
 
   #if IS_KINEMATIC
 
     #if HAS_JUNCTION_DEVIATION
       const xyze_pos_t cart_dist_mm = {
         rx - position_cart.x, ry - position_cart.y,
         rz - position_cart.z, e  - position_cart.e

commit 2de54dab84d82ef69fb9ac3bd9025444f4f84813
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 21 08:23:09 2021 -0500

    üé® Move HAS_EXTRUDERS

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index dde6e89a1f..714be8019e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -157,21 +157,21 @@ float Planner::steps_to_mm[DISTINCT_AXES];      // (mm) Millimeters per step
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
 #if ENABLED(DIRECT_STEPPING)
   uint32_t Planner::last_page_step_rate = 0;
   xyze_bool_t Planner::last_page_dir{0};
 #endif
 
-#if EXTRUDERS
+#if HAS_EXTRUDERS
   int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
   float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0f); // The flow percentage and volumetric multiplier combine to scale E movement
 #endif
 
 #if DISABLED(NO_VOLUMETRICS)
   float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
         Planner::volumetric_area_nominal = CIRCLE_AREA(float(DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5f), // Nominal cross-sectional area
         Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
 #endif
 
@@ -1829,33 +1829,33 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #if HAS_DIST_MM_ARG
     , const xyze_float_t &cart_dist_mm
   #endif
   , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters/*=0.0*/
 ) {
 
   const int32_t da = target.a - position.a,
                 db = target.b - position.b,
                 dc = target.c - position.c;
 
-  #if EXTRUDERS
+  #if HAS_EXTRUDERS
     int32_t de = target.e - position.e;
   #else
     constexpr int32_t de = 0;
   #endif
 
   /* <-- add a slash to enable
     SERIAL_ECHOLNPAIR(
       "  _populate_block FR:", fr_mm_s,
       " A:", target.a, " (", da, " steps)"
       " B:", target.b, " (", db, " steps)"
       " C:", target.c, " (", dc, " steps)"
-      #if EXTRUDERS
+      #if HAS_EXTRUDERS
         " E:", target.e, " (", de, " steps)"
       #endif
     );
   //*/
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position.e = target.e; // Behave as if the move really took place, but ignore E part
@@ -1914,21 +1914,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     if (dc < 0) SBI(dm, Z_AXIS);
     if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
     if (db < 0) SBI(dm, B_AXIS);                // Motor B direction
   #else
     if (da < 0) SBI(dm, X_AXIS);
     if (db < 0) SBI(dm, Y_AXIS);
     if (dc < 0) SBI(dm, Z_AXIS);
   #endif
   if (de < 0) SBI(dm, E_AXIS);
 
-  #if EXTRUDERS
+  #if HAS_EXTRUDERS
     const float esteps_float = de * e_factor[extruder];
     const uint32_t esteps = ABS(esteps_float) + 0.5f;
   #else
     constexpr uint32_t esteps = 0;
   #endif
 
   // Clear all flags, including the "busy" bit
   block->flag = 0x00;
 
   // Set direction bits
@@ -1996,31 +1996,31 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     steps_dist_mm.head.y = db * steps_to_mm[B_AXIS];
     steps_dist_mm.z      = dc * steps_to_mm[Z_AXIS];
     steps_dist_mm.a      = (da - db) * steps_to_mm[A_AXIS];
     steps_dist_mm.b      = db * steps_to_mm[B_AXIS];
   #else
     steps_dist_mm.a = da * steps_to_mm[A_AXIS];
     steps_dist_mm.b = db * steps_to_mm[B_AXIS];
     steps_dist_mm.c = dc * steps_to_mm[C_AXIS];
   #endif
 
-  #if EXTRUDERS
+  #if HAS_EXTRUDERS
     steps_dist_mm.e = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
   #else
     steps_dist_mm.e = 0.0f;
   #endif
 
   TERN_(LCD_SHOW_E_TOTAL, e_move_accumulator += steps_dist_mm.e);
 
   if (block->steps.a < MIN_STEPS_PER_SEGMENT && block->steps.b < MIN_STEPS_PER_SEGMENT && block->steps.c < MIN_STEPS_PER_SEGMENT) {
     block->millimeters = (0
-      #if EXTRUDERS
+      #if HAS_EXTRUDERS
         + ABS(steps_dist_mm.e)
       #endif
     );
   }
   else {
     if (millimeters)
       block->millimeters = millimeters;
     else
       block->millimeters = SQRT(
         #if EITHER(CORE_IS_XY, MARKFORGED_XY)
@@ -2039,21 +2039,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
      * MIN_STEPS_PER_SEGMENT, ensuring the segment won't get dropped as
      * zero-length. It's important to not apply corrections
      * to blocks that would get dropped!
      *
      * A correction function is permitted to add steps to an axis, it
      * should *never* remove steps!
      */
     TERN_(BACKLASH_COMPENSATION, backlash.add_correction_steps(da, db, dc, dm, block));
   }
 
-  #if EXTRUDERS
+  #if HAS_EXTRUDERS
     block->steps.e = esteps;
   #endif
 
   block->step_event_count = _MAX(block->steps.a, block->steps.b, block->steps.c, esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   TERN_(MIXING_EXTRUDER, mixer.populate_block(block->b_color))
 
@@ -2100,21 +2100,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     if (block->steps.x) ENABLE_AXIS_X();
   #else
     if (block->steps.x) ENABLE_AXIS_X();
     if (block->steps.y) ENABLE_AXIS_Y();
     #if DISABLED(Z_LATE_ENABLE)
       if (block->steps.z) ENABLE_AXIS_Z();
     #endif
   #endif
 
   // Enable extruder(s)
-  #if EXTRUDERS
+  #if HAS_EXTRUDERS
     if (esteps) {
       TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
         LOOP_L_N(i, EXTRUDERS)
           if (g_uc_extruder_last_move[i]) g_uc_extruder_last_move[i]--;
 
         #define ENABLE_ONE_E(N) do{ \
           if (extruder == N) { \
@@ -2202,21 +2202,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   // Linear axes first with less logic
   LOOP_LINEAR_AXES(i) {
     current_speed[i] = steps_dist_mm[i] * inverse_secs;
     const feedRate_t cs = ABS(current_speed[i]),
                  max_fr = settings.max_feedrate_mm_s[i];
     if (cs > max_fr) NOMORE(speed_factor, max_fr / cs);
   }
 
   // Limit speed on extruders, if any
-  #if EXTRUDERS
+  #if HAS_EXTRUDERS
     {
       current_speed.e = steps_dist_mm.e * inverse_secs;
       #if HAS_MIXER_SYNC_CHANNEL
         // Move all mixing extruders at the specified rate
         if (mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)
           current_speed.e *= MIXING_STEPPERS;
       #endif
 
       const feedRate_t cs = ABS(current_speed.e),
                    max_fr = settings.max_feedrate_mm_s[E_AXIS_N(extruder)]

commit a6e5492b088add3589aeac168136369f21614e60
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:51:19 2021 -0500

    ‚ôªÔ∏è Refactor axis counts and loops

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index f11f273867..dde6e89a1f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -129,23 +129,23 @@ volatile uint8_t Planner::block_buffer_head,    // Index of the next block to be
                  Planner::block_buffer_tail;    // Index of the busy block, if any
 uint16_t Planner::cleaning_buffer_counter;      // A counter to disable queuing of blocks
 uint8_t Planner::delay_before_delivering;       // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
 planner_settings_t Planner::settings;           // Initialized by settings.load()
 
 #if ENABLED(LASER_POWER_INLINE)
   laser_state_t Planner::laser_inline;          // Current state for blocks
 #endif
 
-uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
+uint32_t Planner::max_acceleration_steps_per_s2[DISTINCT_AXES]; // (steps/s^2) Derived from mm_per_s2
 
-float Planner::steps_to_mm[XYZE_N];             // (mm) Millimeters per step
+float Planner::steps_to_mm[DISTINCT_AXES];      // (mm) Millimeters per step
 
 #if HAS_JUNCTION_DEVIATION
   float Planner::junction_deviation_mm;         // (mm) M205 J
   #if HAS_LINEAR_E_JERK
     float Planner::max_e_jerk[DISTINCT_E];      // Calculated from junction_deviation_mm
   #endif
 #endif
 
 #if HAS_CLASSIC_JERK
   TERN(HAS_LINEAR_E_JERK, xyz_pos_t, xyze_pos_t) Planner::max_jerk;
@@ -2194,21 +2194,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM)   // Only for extruder with filament sensor
       filwidth.advance_e(steps_dist_mm.e);
   #endif
 
   // Calculate and limit speed in mm/sec
 
   xyze_float_t current_speed;
   float speed_factor = 1.0f; // factor <1 decreases speed
 
   // Linear axes first with less logic
-  LOOP_XYZ(i) {
+  LOOP_LINEAR_AXES(i) {
     current_speed[i] = steps_dist_mm[i] * inverse_secs;
     const feedRate_t cs = ABS(current_speed[i]),
                  max_fr = settings.max_feedrate_mm_s[i];
     if (cs > max_fr) NOMORE(speed_factor, max_fr / cs);
   }
 
   // Limit speed on extruders, if any
   #if EXTRUDERS
     {
       current_speed.e = steps_dist_mm.e * inverse_secs;
@@ -2586,21 +2586,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
     // Start with a safe speed (from which the machine may halt to stop immediately).
     float safe_speed = nominal_speed;
 
     #ifndef TRAVEL_EXTRA_XYJERK
       #define TRAVEL_EXTRA_XYJERK 0
     #endif
     const float extra_xyjerk = (de <= 0) ? TRAVEL_EXTRA_XYJERK : 0;
 
     uint8_t limited = 0;
-    TERN(HAS_LINEAR_E_JERK, LOOP_XYZ, LOOP_XYZE)(i) {
+    TERN(HAS_LINEAR_E_JERK, LOOP_LINEAR_AXES, LOOP_LOGICAL_AXES)(i) {
       const float jerk = ABS(current_speed[i]),   // cs : Starting from zero, change in speed for this axis
                   maxj = (max_jerk[i] + (i == X_AXIS || i == Y_AXIS ? extra_xyjerk : 0.0f)); // mj : The max jerk setting for this axis
       if (jerk > maxj) {                          // cs > mj : New current speed too fast?
         if (limited) {                            // limited already?
           const float mjerk = nominal_speed * maxj; // ns*mj
           if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk; // ns*mj/cs
         }
         else {
           safe_speed *= maxj / jerk;              // Initial limit: ns*mj/cs
           ++limited;                              // Initially limited
@@ -2624,21 +2624,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
       float smaller_speed_factor = 1.0f;
       if (nominal_speed < previous_nominal_speed) {
         vmax_junction = nominal_speed;
         smaller_speed_factor = vmax_junction / previous_nominal_speed;
       }
       else
         vmax_junction = previous_nominal_speed;
 
       // Now limit the jerk in all axes.
-      TERN(HAS_LINEAR_E_JERK, LOOP_XYZ, LOOP_XYZE)(axis) {
+      TERN(HAS_LINEAR_E_JERK, LOOP_LINEAR_AXES, LOOP_LOGICAL_AXES)(axis) {
         // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
         float v_exit = previous_speed[axis] * smaller_speed_factor,
               v_entry = current_speed[axis];
         if (limited) {
           v_exit *= v_factor;
           v_entry *= v_factor;
         }
 
         // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
         const float jerk = (v_exit > v_entry)
@@ -3026,34 +3026,34 @@ void Planner::set_e_position_mm(const_float_t e) {
 }
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define AXIS_CONDITION (i < E_AXIS || i == E_AXIS_N(active_extruder))
   #else
     #define AXIS_CONDITION true
   #endif
   uint32_t highest_rate = 1;
-  LOOP_XYZE_N(i) {
+  LOOP_DISTINCT_AXES(i) {
     max_acceleration_steps_per_s2[i] = settings.max_acceleration_mm_per_s2[i] * settings.axis_steps_per_mm[i];
     if (AXIS_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   }
   acceleration_long_cutoff = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
   TERN_(HAS_LINEAR_E_JERK, recalculate_max_e_jerk());
 }
 
 /**
  * Recalculate 'position' and 'steps_to_mm'.
  * Must be called whenever settings.axis_steps_per_mm changes!
  */
 void Planner::refresh_positioning() {
-  LOOP_XYZE_N(i) steps_to_mm[i] = 1.0f / settings.axis_steps_per_mm[i];
+  LOOP_DISTINCT_AXES(i) steps_to_mm[i] = 1.0f / settings.axis_steps_per_mm[i];
   set_position_mm(current_position);
   reset_acceleration_rates();
 }
 
 // Apply limits to a variable and give a warning if the value was out of range
 inline void limit_and_warn(float &val, const uint8_t axis, PGM_P const setting_name, const xyze_float_t &max_limit) {
   const uint8_t lim_axis = axis > E_AXIS ? E_AXIS : axis;
   const float before = val;
   LIMIT(val, 0.1, max_limit[lim_axis]);
   if (before != val) {

commit 32dba5e0c735166d3bb54783efbf0d5d1b275b66
Author: fedetony <45215920+fedetony@users.noreply.github.com>
Date:   Fri Apr 16 08:59:28 2021 +0200

    Realtime Reporting, S000, P000, R000 (#19330)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index b528eb9d3b..f11f273867 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1643,20 +1643,38 @@ void Planner::quick_stop() {
   // Make sure to drop any attempt of queuing moves for 1 second
   cleaning_buffer_counter = TEMP_TIMER_FREQUENCY;
 
   // Reenable Stepper ISR
   if (was_enabled) stepper.wake_up();
 
   // And stop the stepper ISR
   stepper.quick_stop();
 }
 
+#if ENABLED(REALTIME_REPORTING_COMMANDS)
+
+  void Planner::quick_pause() {
+    // Suspend until quick_resume is called
+    // Don't empty buffers or queues
+    const bool did_suspend = stepper.suspend();
+    if (did_suspend)
+      TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(M_HOLD));
+  }
+
+  // Resume if suspended
+  void Planner::quick_resume() {
+    TERN_(FULL_REPORT_TO_HOST_FEATURE, set_and_report_grblstate(grbl_state_for_marlin_state()));
+    stepper.wake_up();
+  }
+
+#endif
+
 void Planner::endstop_triggered(const AxisEnum axis) {
   // Record stepper position and discard the current block
   stepper.endstop_triggered(axis);
 }
 
 float Planner::triggered_position_mm(const AxisEnum axis) {
   return stepper.triggered_position(axis) * steps_to_mm[axis];
 }
 
 void Planner::finish_and_disable() {

commit d705a5b45efa4c7a47650fc2c187ff1d025db8fa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 13 23:22:57 2021 -0500

    Fix long acceleration overflow

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index d6356432e7..b528eb9d3b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -200,21 +200,21 @@ skew_factor_t Planner::skew_factor; // Initialized by settings.load()
   celsius_t Planner::autotemp_max = 250,
             Planner::autotemp_min = 210;
   float Planner::autotemp_factor = 0.1f;
   bool Planner::autotemp_enabled = false;
 #endif
 
 // private:
 
 xyze_long_t Planner::position{0};
 
-uint32_t Planner::cutoff_long;
+uint32_t Planner::acceleration_long_cutoff;
 
 xyze_float_t Planner::previous_speed;
 float Planner::previous_nominal_speed_sqr;
 
 #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
   last_move_t Planner::g_uc_extruder_last_move[EXTRUDERS] = { 0 };
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
   int8_t Planner::xy_freq_limit_hz = XY_FREQUENCY_LIMIT;
@@ -2264,37 +2264,36 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   // Correct the speed
   if (speed_factor < 1.0f) {
     current_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
     block->nominal_speed_sqr = block->nominal_speed_sqr * sq(speed_factor);
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
-  if (!block->steps.a && !block->steps.b && !block->steps.c) {
-    // convert to: acceleration steps/sec^2
-    accel = CEIL(settings.retract_acceleration * steps_per_mm);
-    TERN_(LIN_ADVANCE, block->use_advance_lead = false);
+  if (!block->steps.a && !block->steps.b && !block->steps.c) {    // Is this a retract / recover move?
+    accel = CEIL(settings.retract_acceleration * steps_per_mm);   // Convert to: acceleration steps/sec^2
+    TERN_(LIN_ADVANCE, block->use_advance_lead = false);          // No linear advance for simple retract/recover
   }
   else {
     #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
-        const uint32_t comp = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count; \
-        if (accel * block->steps[AXIS] > comp) accel = comp / block->steps[AXIS]; \
+        const uint32_t max_possible = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count / block->steps[AXIS]; \
+        NOMORE(accel, max_possible); \
       } \
     }while(0)
 
     #define LIMIT_ACCEL_FLOAT(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
-        const float comp = (float)max_acceleration_steps_per_s2[AXIS+INDX] * (float)block->step_event_count; \
-        if ((float)accel * (float)block->steps[AXIS] > comp) accel = comp / (float)block->steps[AXIS]; \
+        const float max_possible = float(max_acceleration_steps_per_s2[AXIS+INDX]) * float(block->step_event_count) / float(block->steps[AXIS]); \
+        NOMORE(accel, max_possible); \
       } \
     }while(0)
 
     // Start with print or travel acceleration
     accel = CEIL((esteps ? settings.acceleration : settings.travel_acceleration) * steps_per_mm);
 
     #if ENABLED(LIN_ADVANCE)
 
       #define MAX_E_JERK(N) TERN(HAS_LINEAR_E_JERK, max_e_jerk[E_INDEX_N(N)], max_jerk.e)
 
@@ -2329,37 +2328,37 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         else {
           const uint32_t max_accel_steps_per_s2 = MAX_E_JERK(extruder) / (extruder_advance_K[active_extruder] * block->e_D_ratio) * steps_per_mm;
           if (TERN0(LA_DEBUG, accel > max_accel_steps_per_s2))
             SERIAL_ECHOLNPGM("Acceleration limited.");
           NOMORE(accel, max_accel_steps_per_s2);
         }
       }
     #endif
 
     // Limit acceleration per axis
-    if (block->step_event_count <= cutoff_long) {
+    if (block->step_event_count <= acceleration_long_cutoff) {
       LIMIT_ACCEL_LONG(A_AXIS, 0);
       LIMIT_ACCEL_LONG(B_AXIS, 0);
       LIMIT_ACCEL_LONG(C_AXIS, 0);
       LIMIT_ACCEL_LONG(E_AXIS, E_INDEX_N(extruder));
     }
     else {
       LIMIT_ACCEL_FLOAT(A_AXIS, 0);
       LIMIT_ACCEL_FLOAT(B_AXIS, 0);
       LIMIT_ACCEL_FLOAT(C_AXIS, 0);
       LIMIT_ACCEL_FLOAT(E_AXIS, E_INDEX_N(extruder));
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
-    block->acceleration_rate = (uint32_t)(accel * (4096.0f * 4096.0f / (STEPPER_TIMER_RATE)));
+    block->acceleration_rate = (uint32_t)(accel * (sq(4096.0f) / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
       block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * settings.axis_steps_per_mm[E_AXIS_N(extruder)]);
       #if ENABLED(LA_DEBUG)
         if (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * 2 < SQRT(block->nominal_speed_sqr) * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif
@@ -3013,21 +3012,21 @@ void Planner::reset_acceleration_rates() {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define AXIS_CONDITION (i < E_AXIS || i == E_AXIS_N(active_extruder))
   #else
     #define AXIS_CONDITION true
   #endif
   uint32_t highest_rate = 1;
   LOOP_XYZE_N(i) {
     max_acceleration_steps_per_s2[i] = settings.max_acceleration_mm_per_s2[i] * settings.axis_steps_per_mm[i];
     if (AXIS_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   }
-  cutoff_long = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
+  acceleration_long_cutoff = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
   TERN_(HAS_LINEAR_E_JERK, recalculate_max_e_jerk());
 }
 
 /**
  * Recalculate 'position' and 'steps_to_mm'.
  * Must be called whenever settings.axis_steps_per_mm changes!
  */
 void Planner::refresh_positioning() {
   LOOP_XYZE_N(i) steps_to_mm[i] = 1.0f / settings.axis_steps_per_mm[i];
   set_position_mm(current_position);

commit 1a2cbe100c279b0dd12a70f5e9179a6f9b555e32
Author: Ramiro Polla <ramiropolla@users.noreply.github.com>
Date:   Fri Apr 9 04:03:34 2021 +0200

    Macros to eliminate 'f + 0.0' (#21568)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e111a808b2..d6356432e7 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2990,21 +2990,21 @@ void Planner::set_position_mm(const_float_t rx, const_float_t ry, const_float_t
   #endif
 }
 
 /**
  * Setters for planner position (also setting stepper position).
  */
 void Planner::set_e_position_mm(const_float_t e) {
   const uint8_t axis_index = E_AXIS_N(active_extruder);
   TERN_(DISTINCT_E_FACTORS, last_extruder = active_extruder);
 
-  const float e_new = e - TERN0(FWRETRACT, fwretract.current_retract[active_extruder]);
+  const float e_new = DIFF_TERN(FWRETRACT, e, fwretract.current_retract[active_extruder]);
   position.e = LROUND(settings.axis_steps_per_mm[axis_index] * e_new);
   TERN_(HAS_POSITION_FLOAT, position_float.e = e_new);
   TERN_(IS_KINEMATIC, position_cart.e = e);
 
   if (has_blocks_queued())
     buffer_sync_block();
   else
     stepper.set_axis_position(E_AXIS, position.e);
 }
 

commit ed14731146006442f1cc4045b70cefdec00aaa8f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 5 21:27:05 2021 -0500

    getHighESpeed => autotemp_task

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 891f6a7ab0..e111a808b2 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1375,21 +1375,21 @@ void Planner::check_axes_activity() {
   if (TERN0(DISABLE_E, !axis_active.e)) disable_e_steppers();
 
   //
   // Update Fan speeds
   // Only if synchronous M106/M107 is disabled
   //
   #if HAS_TAIL_FAN_SPEED
     sync_fan_speeds(tail_fan_speed);
   #endif
 
-  TERN_(AUTOTEMP, getHighESpeed());
+  TERN_(AUTOTEMP, autotemp_task());
 
   #if ENABLED(BARICUDA)
     TERN_(HAS_HEATER_1, analogWrite(pin_t(HEATER_1_PIN), tail_valve_pressure));
     TERN_(HAS_HEATER_2, analogWrite(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
   #endif
 }
 
 #if ENABLED(AUTOTEMP)
 
   #if ENABLED(AUTOTEMP_PROPORTIONAL)
@@ -1425,21 +1425,21 @@ void Planner::check_axes_activity() {
     // Normally, leaving off F also disables autotemp.
     autotemp_factor = parser.seen('F') ? parser.value_float() : TERN(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P, 0);
     autotemp_enabled = autotemp_factor != 0;
   }
 
   /**
    * Called every so often to adjust the hotend target temperature
    * based on the extrusion speed, which is calculated from the blocks
    * currently in the planner.
    */
-  void Planner::getHighESpeed() {
+  void Planner::autotemp_task() {
     static float oldt = 0;
 
     if (!autotemp_enabled) return;
     if (thermalManager.degTargetHotend(active_extruder) < autotemp_min - 2) return; // Below the min?
 
     float high = 0.0;
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block_t *block = &block_buffer[b];
       if (block->steps.x || block->steps.y || block->steps.z) {
         const float se = (float)block->steps.e / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index eee1a9f269..891f6a7ab0 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -768,21 +768,21 @@ block_t* Planner::get_current_block() {
 /**
  * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
  * by the provided factors.
  **
  * ############ VERY IMPORTANT ############
  * NOTE that the PRECONDITION to call this function is that the block is
  * NOT BUSY and it is marked as RECALCULATE. That WARRANTIES the Stepper ISR
  * is not and will not use the block while we modify it, so it is safe to
  * alter its values.
  */
-void Planner::calculate_trapezoid_for_block(block_t * const block, const float &entry_factor, const float &exit_factor) {
+void Planner::calculate_trapezoid_for_block(block_t * const block, const_float_t entry_factor, const_float_t exit_factor) {
 
   uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
            final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
 
   // Limit minimal step rate (Otherwise the timer will overflow.)
   NOLESS(initial_rate, uint32_t(MINIMAL_STEP_RATE));
   NOLESS(final_rate, uint32_t(MINIMAL_STEP_RATE));
 
   #if ENABLED(S_CURVE_ACCELERATION)
     uint32_t cruise_rate = initial_rate;
@@ -1456,21 +1456,21 @@ void Planner::check_axes_activity() {
 
 #endif
 
 #if DISABLED(NO_VOLUMETRICS)
 
   /**
    * Get a volumetric multiplier from a filament diameter.
    * This is the reciprocal of the circular cross-section area.
    * Return 1.0 with volumetric off or a diameter of 0.0.
    */
-  inline float calculate_volumetric_multiplier(const float &diameter) {
+  inline float calculate_volumetric_multiplier(const_float_t diameter) {
     return (parser.volumetric_enabled && diameter) ? 1.0f / CIRCLE_AREA(diameter * 0.5f) : 1;
   }
 
   /**
    * Convert the filament sizes into volumetric multipliers.
    * The multiplier converts a given E value into a length.
    */
   void Planner::calculate_volumetric_multipliers() {
     LOOP_L_N(i, COUNT(filament_size)) {
       volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
@@ -1738,21 +1738,21 @@ void Planner::synchronize() {
  *
  * Returns true if movement was properly queued, false otherwise (if cleaning)
  */
 bool Planner::_buffer_steps(const xyze_long_t &target
   #if HAS_POSITION_FLOAT
     , const xyze_pos_t &target_float
   #endif
   #if HAS_DIST_MM_ARG
     , const xyze_float_t &cart_dist_mm
   #endif
-  , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters
+  , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters
 ) {
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // If we are cleaning, do not accept queuing of movements
   // This must be after get_next_free_block() because it calls idle()
   // where cleaning_buffer_counter can be changed
   if (cleaning_buffer_counter) return false;
@@ -1804,21 +1804,21 @@ bool Planner::_buffer_steps(const xyze_long_t &target
  * Returns true if movement is acceptable, false otherwise
  */
 bool Planner::_populate_block(block_t * const block, bool split_move,
   const abce_long_t &target
   #if HAS_POSITION_FLOAT
     , const xyze_pos_t &target_float
   #endif
   #if HAS_DIST_MM_ARG
     , const xyze_float_t &cart_dist_mm
   #endif
-  , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
+  , feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters/*=0.0*/
 ) {
 
   const int32_t da = target.a - position.a,
                 db = target.b - position.b,
                 dc = target.c - position.c;
 
   #if EXTRUDERS
     int32_t de = target.e - position.e;
   #else
     constexpr int32_t de = 0;
@@ -2738,25 +2738,25 @@ void Planner::buffer_sync_block(TERN_(LASER_SYNCHRONOUS_M106_M107, uint8_t sync_
  *
  * Leveling and kinematics should be applied ahead of calling this.
  *
  *  a,b,c,e     - target positions in mm and/or degrees
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *  millimeters - the length of the movement, if known
  *
  * Return 'false' if no segment was queued due to cleaning, cold extrusion, full queue, etc.
  */
-bool Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e
+bool Planner::buffer_segment(const_float_t a, const_float_t b, const_float_t c, const_float_t e
   #if HAS_DIST_MM_ARG
     , const xyze_float_t &cart_dist_mm
   #endif
-  , const feedRate_t &fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
+  , const_feedRate_t fr_mm_s, const uint8_t extruder, const_float_t millimeters/*=0.0*/
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
     if (last_extruder != extruder && settings.axis_steps_per_mm[E_AXIS_N(extruder)] != settings.axis_steps_per_mm[E_AXIS_N(last_extruder)]) {
       position.e = LROUND(position.e * settings.axis_steps_per_mm[E_AXIS_N(extruder)] * steps_to_mm[E_AXIS_N(last_extruder)]);
       last_extruder = extruder;
@@ -2832,23 +2832,23 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
  * Add a new linear movement to the buffer.
  * The target is cartesian. It's translated to
  * delta/scara if needed.
  *
  *  rx,ry,rz,e   - target position in mm or degrees
  *  fr_mm_s      - (target) speed of the move (mm/s)
  *  extruder     - target extruder
  *  millimeters  - the length of the movement, if known
  *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
  */
-bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, const float &e, const feedRate_t &fr_mm_s, const uint8_t extruder, const float millimeters
+bool Planner::buffer_line(const_float_t rx, const_float_t ry, const_float_t rz, const_float_t e, const_feedRate_t fr_mm_s, const uint8_t extruder, const float millimeters
   #if ENABLED(SCARA_FEEDRATE_SCALING)
-    , const float &inv_duration
+    , const_float_t inv_duration
   #endif
 ) {
   xyze_pos_t machine = { rx, ry, rz, e };
   TERN_(HAS_POSITION_MODIFIERS, apply_modifiers(machine));
 
   #if IS_KINEMATIC
 
     #if HAS_JUNCTION_DEVIATION
       const xyze_pos_t cart_dist_mm = {
         rx - position_cart.x, ry - position_cart.y,
@@ -2953,54 +2953,54 @@ bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, con
 
 #endif // DIRECT_STEPPING
 
 /**
  * Directly set the planner ABC position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * The provided ABC position is in machine units.
  */
 
-void Planner::set_machine_position_mm(const float &a, const float &b, const float &c, const float &e) {
+void Planner::set_machine_position_mm(const_float_t a, const_float_t b, const_float_t c, const_float_t e) {
   TERN_(DISTINCT_E_FACTORS, last_extruder = active_extruder);
   TERN_(HAS_POSITION_FLOAT, position_float.set(a, b, c, e));
   position.set(LROUND(a * settings.axis_steps_per_mm[A_AXIS]),
                LROUND(b * settings.axis_steps_per_mm[B_AXIS]),
                LROUND(c * settings.axis_steps_per_mm[C_AXIS]),
                LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(active_extruder)]));
   if (has_blocks_queued()) {
     //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.
     //previous_speed.reset();
     buffer_sync_block();
   }
   else
     stepper.set_position(position);
 }
 
-void Planner::set_position_mm(const float &rx, const float &ry, const float &rz, const float &e) {
+void Planner::set_position_mm(const_float_t rx, const_float_t ry, const_float_t rz, const_float_t e) {
   xyze_pos_t machine = { rx, ry, rz, e };
   #if HAS_POSITION_MODIFIERS
     apply_modifiers(machine, true);
   #endif
   #if IS_KINEMATIC
     position_cart.set(rx, ry, rz, e);
     inverse_kinematics(machine);
     set_machine_position_mm(delta.a, delta.b, delta.c, machine.e);
   #else
     set_machine_position_mm(machine);
   #endif
 }
 
 /**
  * Setters for planner position (also setting stepper position).
  */
-void Planner::set_e_position_mm(const float &e) {
+void Planner::set_e_position_mm(const_float_t e) {
   const uint8_t axis_index = E_AXIS_N(active_extruder);
   TERN_(DISTINCT_E_FACTORS, last_extruder = active_extruder);
 
   const float e_new = e - TERN0(FWRETRACT, fwretract.current_retract[active_extruder]);
   position.e = LROUND(settings.axis_steps_per_mm[axis_index] * e_new);
   TERN_(HAS_POSITION_FLOAT, position_float.e = e_new);
   TERN_(IS_KINEMATIC, position_cart.e = e);
 
   if (has_blocks_queued())
     buffer_sync_block();

commit be775ed72db983ea150669ad6e0e094285b2fec2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 30 23:16:29 2021 -0500

    Move apply_rotation_xyz into matrix_3x3

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 832d6e316a..eee1a9f269 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1527,21 +1527,21 @@ void Planner::check_axes_activity() {
   /**
    * rx, ry, rz - Cartesian positions in mm
    *              Leveled XYZ on completion
    */
   void Planner::apply_leveling(xyz_pos_t &raw) {
     if (!leveling_active) return;
 
     #if ABL_PLANAR
 
       xy_pos_t d = raw - level_fulcrum;
-      apply_rotation_xyz(bed_level_matrix, d.x, d.y, raw.z);
+      bed_level_matrix.apply_rotation_xyz(d.x, d.y, raw.z);
       raw = d + level_fulcrum;
 
     #elif HAS_MESH
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         const float fade_scaling_factor = fade_scaling_factor_for_z(raw.z);
       #elif DISABLED(MESH_BED_LEVELING)
         constexpr float fade_scaling_factor = 1.0;
       #endif
 
@@ -1564,21 +1564,21 @@ void Planner::check_axes_activity() {
 
   void Planner::unapply_leveling(xyz_pos_t &raw) {
 
     if (leveling_active) {
 
       #if ABL_PLANAR
 
         matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
 
         xy_pos_t d = raw - level_fulcrum;
-        apply_rotation_xyz(inverse, d.x, d.y, raw.z);
+        inverse.apply_rotation_xyz(d.x, d.y, raw.z);
         raw = d + level_fulcrum;
 
       #elif HAS_MESH
 
         #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
           const float fade_scaling_factor = fade_scaling_factor_for_z(raw.z);
         #elif DISABLED(MESH_BED_LEVELING)
           constexpr float fade_scaling_factor = 1.0;
         #endif
 

commit 3b73b115ca9366f0155986b717d4c85c31ed2f80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 29 20:36:37 2021 -0500

    Apply pointer formatting

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index b20d1e273b..832d6e316a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -374,21 +374,21 @@ void Planner::init() {
         174762,172960,171196,169466,167772,166111,164482,162885,161319,159783,158275,156796,155344,153919,152520
       };
 
       // For small divisors, it is best to directly retrieve the results
       if (d <= 110) return pgm_read_dword(&small_inv_tab[d]);
 
       uint8_t r8 = d & 0xFF,
               r9 = (d >> 8) & 0xFF,
               r10 = (d >> 16) & 0xFF,
               r2,r3,r4,r5,r6,r7,r11,r12,r13,r14,r15,r16,r17,r18;
-      const uint8_t* ptab = inv_tab;
+      const uint8_t *ptab = inv_tab;
 
       __asm__ __volatile__(
         // %8:%7:%6 = interval
         // r31:r30: MUST be those registers, and they must point to the inv_tab
 
         A("clr %13")                       // %13 = 0
 
         // Now we must compute
         // result = 0xFFFFFF / d
         // %8:%7:%6 = interval
@@ -768,21 +768,21 @@ block_t* Planner::get_current_block() {
 /**
  * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
  * by the provided factors.
  **
  * ############ VERY IMPORTANT ############
  * NOTE that the PRECONDITION to call this function is that the block is
  * NOT BUSY and it is marked as RECALCULATE. That WARRANTIES the Stepper ISR
  * is not and will not use the block while we modify it, so it is safe to
  * alter its values.
  */
-void Planner::calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor) {
+void Planner::calculate_trapezoid_for_block(block_t * const block, const float &entry_factor, const float &exit_factor) {
 
   uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
            final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
 
   // Limit minimal step rate (Otherwise the timer will overflow.)
   NOLESS(initial_rate, uint32_t(MINIMAL_STEP_RATE));
   NOLESS(final_rate, uint32_t(MINIMAL_STEP_RATE));
 
   #if ENABLED(S_CURVE_ACCELERATION)
     uint32_t cruise_rate = initial_rate;
@@ -935,21 +935,21 @@ void Planner::calculate_trapezoid_for_block(block_t* const block, const float &e
   decelerate to a complete stop at the end of the buffer, as stated by the guidelines. If this happens and
   becomes an annoyance, there are a few simple solutions: (1) Maximize the machine acceleration. The planner
   will be able to compute higher velocity profiles within the same combined distance. (2) Maximize line
   motion(s) distance per block to a desired tolerance. The more combined distance the planner has to use,
   the faster it can go. (3) Maximize the planner buffer size. This also will increase the combined distance
   for the planner to compute over. It also increases the number of computations the planner has to perform
   to compute an optimal plan, so select carefully.
 */
 
 // The kernel called by recalculate() when scanning the plan from last to first entry.
-void Planner::reverse_pass_kernel(block_t* const current, const block_t * const next) {
+void Planner::reverse_pass_kernel(block_t * const current, const block_t * const next) {
   if (current) {
     // If entry speed is already at the maximum entry speed, and there was no change of speed
     // in the next block, there is no need to recheck. Block is cruising and there is no need to
     // compute anything for this block,
     // If not, block entry speed needs to be recalculated to ensure maximum possible planned speed.
     const float max_entry_speed_sqr = current->max_entry_speed_sqr;
 
     // Compute maximum entry speed decelerating over the current block from its exit speed.
     // If not at the maximum entry speed, or the previous block entry speed changed
     if (current->entry_speed_sqr != max_entry_speed_sqr || (next && TEST(next->flag, BLOCK_BIT_RECALCULATE))) {
@@ -1032,21 +1032,21 @@ void Planner::reverse_pass() {
       // If we reached the busy block or an already processed block, break the loop now
       if (block_index == planned_block_index) return;
 
       // Advance the pointer, following the busy block
       planned_block_index = next_block_index(planned_block_index);
     }
   }
 }
 
 // The kernel called by recalculate() when scanning the plan from first to last entry.
-void Planner::forward_pass_kernel(const block_t* const previous, block_t* const current, const uint8_t block_index) {
+void Planner::forward_pass_kernel(const block_t * const previous, block_t * const current, const uint8_t block_index) {
   if (previous) {
     // If the previous block is an acceleration block, too short to complete the full speed
     // change, adjust the entry speed accordingly. Entry speeds have already been reset,
     // maximized, and reverse-planned. If nominal length is set, max junction speed is
     // guaranteed to be reached. No need to recheck.
     if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH) &&
       previous->entry_speed_sqr < current->entry_speed_sqr) {
 
       // Compute the maximum allowable speed
       const float new_entry_speed_sqr = max_allowable_speed_sqr(-previous->acceleration, previous->entry_speed_sqr, previous->millimeters);
@@ -1433,21 +1433,21 @@ void Planner::check_axes_activity() {
    * currently in the planner.
    */
   void Planner::getHighESpeed() {
     static float oldt = 0;
 
     if (!autotemp_enabled) return;
     if (thermalManager.degTargetHotend(active_extruder) < autotemp_min - 2) return; // Below the min?
 
     float high = 0.0;
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
-      block_t* block = &block_buffer[b];
+      block_t *block = &block_buffer[b];
       if (block->steps.x || block->steps.y || block->steps.z) {
         const float se = (float)block->steps.e / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;
         NOLESS(high, se);
       }
     }
 
     float t = autotemp_min + high * autotemp_factor;
     LIMIT(t, autotemp_min, autotemp_max);
     if (t < oldt) t *= (1.0f - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
     oldt = t;

commit 30e7e2c2766d7dbbe0144344287994f1969dfadd
Author: Martijn Bosgraaf <drywfiltiarn+github@gmail.com>
Date:   Wed Mar 24 18:21:11 2021 +0100

    Extend M106/M107 for better laser module support (#16082)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 84c93e5296..b20d1e273b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1008,22 +1008,22 @@ void Planner::reverse_pass() {
 
   // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
   // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
   // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
   const block_t *next = nullptr;
   while (block_index != planned_block_index) {
 
     // Perform the reverse pass
     block_t *current = &block_buffer[block_index];
 
-    // Only consider non sync and page blocks
-    if (!TEST(current->flag, BLOCK_BIT_SYNC_POSITION) && !IS_PAGE(current)) {
+    // Only consider non sync-and-page blocks
+    if (!(current->flag & BLOCK_MASK_SYNC) && !IS_PAGE(current)) {
       reverse_pass_kernel(current, next);
       next = current;
     }
 
     // Advance to the next
     block_index = prev_block_index(block_index);
 
     // The ISR could advance the block_buffer_planned while we were doing the reverse pass.
     // We must try to avoid using an already consumed block as the last one - So follow
     // changes to the pointer and make sure to limit the loop to the currently busy block
@@ -1104,21 +1104,21 @@ void Planner::forward_pass() {
   uint8_t block_index = block_buffer_planned;
 
   block_t *block;
   const block_t * previous = nullptr;
   while (block_index != block_buffer_head) {
 
     // Perform the forward pass
     block = &block_buffer[block_index];
 
     // Skip SYNC and page blocks
-    if (!TEST(block->flag, BLOCK_BIT_SYNC_POSITION) && !IS_PAGE(block)) {
+    if (!(block->flag & BLOCK_MASK_SYNC) && !IS_PAGE(block)) {
       // If there's no previous block or the previous block is not
       // BUSY (thus, modifiable) run the forward_pass_kernel. Otherwise,
       // the previous block became BUSY, so assume the current block's
       // entry speed can't be altered (since that would also require
       // updating the exit speed of the previous block).
       if (!previous || !stepper.is_block_busy(previous))
         forward_pass_kernel(previous, block, block_index);
       previous = block;
     }
     // Advance to the previous
@@ -1140,35 +1140,35 @@ void Planner::recalculate_trapezoids() {
   // specially handled), scan backwards to the first non-SYNC block.
   while (head_block_index != block_index) {
 
     // Go back (head always point to the first free block)
     const uint8_t prev_index = prev_block_index(head_block_index);
 
     // Get the pointer to the block
     block_t *prev = &block_buffer[prev_index];
 
     // If not dealing with a sync block, we are done. The last block is not a SYNC block
-    if (!TEST(prev->flag, BLOCK_BIT_SYNC_POSITION)) break;
+    if (!(prev->flag & BLOCK_MASK_SYNC)) break;
 
     // Examine the previous block. This and all following are SYNC blocks
     head_block_index = prev_index;
   }
 
   // Go from the tail (currently executed block) to the first block, without including it)
   block_t *block = nullptr, *next = nullptr;
   float current_entry_speed = 0.0, next_entry_speed = 0.0;
   while (block_index != head_block_index) {
 
     next = &block_buffer[block_index];
 
     // Skip sync and page blocks
-    if (!TEST(next->flag, BLOCK_BIT_SYNC_POSITION) && !IS_PAGE(next)) {
+    if (!(next->flag & BLOCK_MASK_SYNC) && !IS_PAGE(next)) {
       next_entry_speed = SQRT(next->entry_speed_sqr);
 
       if (block) {
         // Recalculate if current block entry or exit junction speed has changed.
         if (TEST(block->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
 
           // Mark the current block as RECALCULATE, to protect it from the Stepper ISR running it.
           // Note that due to the above condition, there's a chance the current block isn't marked as
           // RECALCULATE yet, but the next one is. That's the reason for the following line.
           SBI(block->flag, BLOCK_BIT_RECALCULATE);
@@ -1241,51 +1241,107 @@ void Planner::recalculate() {
   // Initialize block index to the last block in the planner buffer.
   const uint8_t block_index = prev_block_index(block_buffer_head);
   // If there is just one block, no planning can be done. Avoid it!
   if (block_index != block_buffer_planned) {
     reverse_pass();
     forward_pass();
   }
   recalculate_trapezoids();
 }
 
+#if HAS_FAN && DISABLED(LASER_SYNCHRONOUS_M106_M107)
+  #define HAS_TAIL_FAN_SPEED 1
+#endif
+
+/**
+ * Apply fan speeds
+ */
+#if HAS_FAN
+
+  void Planner::sync_fan_speeds(uint8_t (&fan_speed)[FAN_COUNT]) {
+
+    #if FAN_MIN_PWM != 0 || FAN_MAX_PWM != 255
+      #define CALC_FAN_SPEED(f) (fan_speed[f] ? map(fan_speed[f], 1, 255, FAN_MIN_PWM, FAN_MAX_PWM) : FAN_OFF_PWM)
+    #else
+      #define CALC_FAN_SPEED(f) (fan_speed[f] ?: FAN_OFF_PWM)
+    #endif
+
+    #if ENABLED(FAN_SOFT_PWM)
+      #define _FAN_SET(F) thermalManager.soft_pwm_amount_fan[F] = CALC_FAN_SPEED(F);
+    #elif ENABLED(FAST_PWM_FAN)
+      #define _FAN_SET(F) set_pwm_duty(FAN##F##_PIN, CALC_FAN_SPEED(F));
+    #else
+      #define _FAN_SET(F) analogWrite(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(F));
+    #endif
+    #define FAN_SET(F) do{ kickstart_fan(fan_speed, ms, F); _FAN_SET(F); }while(0)
+
+    const millis_t ms = millis();
+    TERN_(HAS_FAN0, FAN_SET(0));
+    TERN_(HAS_FAN1, FAN_SET(1));
+    TERN_(HAS_FAN2, FAN_SET(2));
+    TERN_(HAS_FAN3, FAN_SET(3));
+    TERN_(HAS_FAN4, FAN_SET(4));
+    TERN_(HAS_FAN5, FAN_SET(5));
+    TERN_(HAS_FAN6, FAN_SET(6));
+    TERN_(HAS_FAN7, FAN_SET(7));
+  }
+
+  #if FAN_KICKSTART_TIME
+
+    void Planner::kickstart_fan(uint8_t (&fan_speed)[FAN_COUNT], const millis_t &ms, const uint8_t f) {
+      static millis_t fan_kick_end[FAN_COUNT] = { 0 };
+      if (fan_speed[f]) {
+        if (fan_kick_end[f] == 0) {
+          fan_kick_end[f] = ms + FAN_KICKSTART_TIME;
+          fan_speed[f] = 255;
+        }
+        else if (PENDING(ms, fan_kick_end[f]))
+          fan_speed[f] = 255;
+      }
+      else
+        fan_kick_end[f] = 0;
+    }
+
+  #endif
+
+#endif // HAS_FAN
+
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
 
   #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
     xyze_bool_t axis_active = { false };
   #endif
 
-  #if HAS_FAN
+  #if HAS_TAIL_FAN_SPEED
     uint8_t tail_fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
     #endif
     #if HAS_HEATER_2
       uint8_t tail_e_to_p_pressure;
     #endif
   #endif
 
   if (has_blocks_queued()) {
 
-    #if HAS_FAN || ENABLED(BARICUDA)
+    #if EITHER(HAS_TAIL_FAN_SPEED, BARICUDA)
       block_t *block = &block_buffer[block_buffer_tail];
     #endif
 
-    #if HAS_FAN
-      FANS_LOOP(i)
-        tail_fan_speed[i] = thermalManager.scaledFanSpeed(i, block->fan_speed[i]);
+    #if HAS_TAIL_FAN_SPEED
+      FANS_LOOP(i) tail_fan_speed[i] = thermalManager.scaledFanSpeed(i, block->fan_speed[i]);
     #endif
 
     #if ENABLED(BARICUDA)
       TERN_(HAS_HEATER_1, tail_valve_pressure = block->valve_pressure);
       TERN_(HAS_HEATER_2, tail_e_to_p_pressure = block->e_to_p_pressure);
     #endif
 
     #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
       for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
         block_t *block = &block_buffer[b];
@@ -1293,83 +1349,45 @@ void Planner::check_axes_activity() {
         if (ENABLED(DISABLE_Y) && block->steps.y) axis_active.y = true;
         if (ENABLED(DISABLE_Z) && block->steps.z) axis_active.z = true;
         if (ENABLED(DISABLE_E) && block->steps.e) axis_active.e = true;
       }
     #endif
   }
   else {
 
     TERN_(HAS_CUTTER, cutter.refresh());
 
-    #if HAS_FAN
-      FANS_LOOP(i)
-        tail_fan_speed[i] = thermalManager.scaledFanSpeed(i);
+    #if HAS_TAIL_FAN_SPEED
+      FANS_LOOP(i) tail_fan_speed[i] = thermalManager.scaledFanSpeed(i);
     #endif
 
     #if ENABLED(BARICUDA)
       TERN_(HAS_HEATER_1, tail_valve_pressure = baricuda_valve_pressure);
       TERN_(HAS_HEATER_2, tail_e_to_p_pressure = baricuda_e_to_p_pressure);
     #endif
   }
 
   //
   // Disable inactive axes
   //
   if (TERN0(DISABLE_X, !axis_active.x)) DISABLE_AXIS_X();
   if (TERN0(DISABLE_Y, !axis_active.y)) DISABLE_AXIS_Y();
   if (TERN0(DISABLE_Z, !axis_active.z)) DISABLE_AXIS_Z();
   if (TERN0(DISABLE_E, !axis_active.e)) disable_e_steppers();
 
   //
   // Update Fan speeds
+  // Only if synchronous M106/M107 is disabled
   //
-  #if HAS_FAN
-
-    #if FAN_KICKSTART_TIME > 0
-      static millis_t fan_kick_end[FAN_COUNT] = { 0 };
-      #define KICKSTART_FAN(f)                         \
-        if (tail_fan_speed[f]) {                       \
-          millis_t ms = millis();                      \
-          if (fan_kick_end[f] == 0) {                  \
-            fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \
-            tail_fan_speed[f] = 255;                   \
-          } else if (PENDING(ms, fan_kick_end[f]))     \
-            tail_fan_speed[f] = 255;                   \
-        } else fan_kick_end[f] = 0
-    #else
-      #define KICKSTART_FAN(f) NOOP
-    #endif
-
-    #if FAN_MIN_PWM != 0 || FAN_MAX_PWM != 255
-      #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ? map(tail_fan_speed[f], 1, 255, FAN_MIN_PWM, FAN_MAX_PWM) : FAN_OFF_PWM)
-    #else
-      #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ?: FAN_OFF_PWM)
-    #endif
-
-    #if ENABLED(FAN_SOFT_PWM)
-      #define _FAN_SET(F) thermalManager.soft_pwm_amount_fan[F] = CALC_FAN_SPEED(F);
-    #elif ENABLED(FAST_PWM_FAN)
-      #define _FAN_SET(F) set_pwm_duty(FAN##F##_PIN, CALC_FAN_SPEED(F));
-    #else
-      #define _FAN_SET(F) analogWrite(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(F));
-    #endif
-    #define FAN_SET(F) do{ KICKSTART_FAN(F); _FAN_SET(F); }while(0)
-
-    TERN_(HAS_FAN0, FAN_SET(0));
-    TERN_(HAS_FAN1, FAN_SET(1));
-    TERN_(HAS_FAN2, FAN_SET(2));
-    TERN_(HAS_FAN3, FAN_SET(3));
-    TERN_(HAS_FAN4, FAN_SET(4));
-    TERN_(HAS_FAN5, FAN_SET(5));
-    TERN_(HAS_FAN6, FAN_SET(6));
-    TERN_(HAS_FAN7, FAN_SET(7));
-  #endif // HAS_FAN
+  #if HAS_TAIL_FAN_SPEED
+    sync_fan_speeds(tail_fan_speed);
+  #endif
 
   TERN_(AUTOTEMP, getHighESpeed());
 
   #if ENABLED(BARICUDA)
     TERN_(HAS_HEATER_1, analogWrite(pin_t(HEATER_1_PIN), tail_valve_pressure));
     TERN_(HAS_HEATER_2, analogWrite(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
   #endif
 }
 
 #if ENABLED(AUTOTEMP)
@@ -2668,34 +2686,43 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   TERN_(HAS_POSITION_FLOAT, position_float = target_float);
   TERN_(GRADIENT_MIX, mixer.gradient_control(target_float.z));
   TERN_(POWER_LOSS_RECOVERY, block->sdpos = recovery.command_sdpos());
 
   return true;        // Movement was accepted
 
 } // _populate_block()
 
 /**
  * Planner::buffer_sync_block
- * Add a block to the buffer that just updates the position
+ * Add a block to the buffer that just updates the position,
+ * or in case of LASER_SYNCHRONOUS_M106_M107 the fan PWM
  */
-void Planner::buffer_sync_block() {
+void Planner::buffer_sync_block(TERN_(LASER_SYNCHRONOUS_M106_M107, uint8_t sync_flag)) {
+  #if DISABLED(LASER_SYNCHRONOUS_M106_M107)
+    constexpr uint8_t sync_flag = BLOCK_FLAG_SYNC_POSITION;
+  #endif
+
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Clear block
   memset(block, 0, sizeof(block_t));
 
-  block->flag = BLOCK_FLAG_SYNC_POSITION;
+  block->flag = sync_flag;
 
   block->position = position;
 
+  #if BOTH(HAS_FAN, LASER_SYNCHRONOUS_M106_M107)
+    FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
+  #endif
+
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
     // give the planner an opportunity to queue more movements and plan them
     // As there are no queued movements, the Stepper ISR will not touch this
     // variable, so there is no risk setting this here (but it MUST be done
     // before the following line!!)
     delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
   }
 
@@ -2869,21 +2896,21 @@ bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, con
     if (!last_page_step_rate) {
       kill(GET_TEXT(MSG_BAD_PAGE_SPEED));
       return;
     }
 
     uint8_t next_buffer_head;
     block_t * const block = get_next_free_block(next_buffer_head);
 
     block->flag = BLOCK_FLAG_IS_PAGE;
 
-    #if FAN_COUNT > 0
+    #if HAS_FAN
       FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
     #endif
 
     #if HAS_MULTI_EXTRUDER
       block->extruder = extruder;
     #endif
 
     block->page_idx = page_idx;
 
     block->step_event_count = num_steps;

commit 2d2291d00eab6159de24eb7ff74001b1d6dd29e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 24 05:40:28 2021 -0500

    More IntelliSense-friendly declarations

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 8c320925be..84c93e5296 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2012,23 +2012,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   #if EXTRUDERS
     block->steps.e = esteps;
   #endif
 
   block->step_event_count = _MAX(block->steps.a, block->steps.b, block->steps.c, esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
-  #if ENABLED(MIXING_EXTRUDER)
-    MIXER_POPULATE_BLOCK();
-  #endif
+  TERN_(MIXING_EXTRUDER, mixer.populate_block(block->b_color))
 
   TERN_(HAS_CUTTER, block->cutter_power = cutter.power);
 
   #if HAS_FAN
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;

commit e5ff55a1be7646b6159e6dedac50bfbe57e6dfa0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 24 04:11:43 2021 -0500

    Add typedef celsius_t (#21374)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 594671f87a..8c320925be 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -190,23 +190,23 @@ float Planner::steps_to_mm[XYZE_N];             // (mm) Millimeters per step
           Planner::inverse_z_fade_height,
           Planner::last_fade_z;
   #endif
 #else
   constexpr bool Planner::leveling_active;
 #endif
 
 skew_factor_t Planner::skew_factor; // Initialized by settings.load()
 
 #if ENABLED(AUTOTEMP)
-  float Planner::autotemp_max = 250,
-        Planner::autotemp_min = 210,
-        Planner::autotemp_factor = 0.1f;
+  celsius_t Planner::autotemp_max = 250,
+            Planner::autotemp_min = 210;
+  float Planner::autotemp_factor = 0.1f;
   bool Planner::autotemp_enabled = false;
 #endif
 
 // private:
 
 xyze_long_t Planner::position{0};
 
 uint32_t Planner::cutoff_long;
 
 xyze_float_t Planner::previous_speed;
@@ -1369,21 +1369,21 @@ void Planner::check_axes_activity() {
   #if ENABLED(BARICUDA)
     TERN_(HAS_HEATER_1, analogWrite(pin_t(HEATER_1_PIN), tail_valve_pressure));
     TERN_(HAS_HEATER_2, analogWrite(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
   #endif
 }
 
 #if ENABLED(AUTOTEMP)
 
   #if ENABLED(AUTOTEMP_PROPORTIONAL)
     void Planner::_autotemp_update_from_hotend() {
-      const int16_t target = thermalManager.degTargetHotend(active_extruder);
+      const celsius_t target = thermalManager.degTargetHotend(active_extruder);
       autotemp_min = target + AUTOTEMP_MIN_P;
       autotemp_max = target + AUTOTEMP_MAX_P;
     }
   #endif
 
   /**
    * Called after changing tools to:
    *  - Reset or re-apply the default proportional autotemp factor.
    *  - Enable autotemp if the factor is non-zero.
    */

commit ad907a51e245a908024ff2736f95455d89e9571d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Mar 18 00:11:06 2021 -0500

    Followup to planner cleanup

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c60e9f6cd3..594671f87a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -3022,21 +3022,21 @@ inline void limit_and_warn(float &val, const uint8_t axis, PGM_P const setting_n
   }
 }
 
 /**
  * For the specified 'axis' set the Maximum Acceleration to the given value (mm/s^2)
  * The value may be limited with warning feedback, if configured.
  * Calls reset_acceleration_rates to precalculate planner terms in steps.
  *
  * This hard limit is applied as a block is being added to the planner queue.
  */
-void Planner::set_max_acceleration(const uint8_t axis, const float &inMaxAccelMMS2) {
+void Planner::set_max_acceleration(const uint8_t axis, float inMaxAccelMMS2) {
   #if ENABLED(LIMITED_MAX_ACCEL_EDITING)
     #ifdef MAX_ACCEL_EDIT_VALUES
       constexpr xyze_float_t max_accel_edit = MAX_ACCEL_EDIT_VALUES;
       const xyze_float_t &max_acc_edit_scaled = max_accel_edit;
     #else
       constexpr xyze_float_t max_accel_edit = DEFAULT_MAX_ACCELERATION;
       const xyze_float_t max_acc_edit_scaled = max_accel_edit * 2;
     #endif
     limit_and_warn(inMaxAccelMMS2, axis, PSTR("Acceleration"), max_acc_edit_scaled);
   #endif
@@ -3045,21 +3045,21 @@ void Planner::set_max_acceleration(const uint8_t axis, const float &inMaxAccelMM
   // Update steps per s2 to agree with the units per s2 (since they are used in the planner)
   reset_acceleration_rates();
 }
 
 /**
  * For the specified 'axis' set the Maximum Feedrate to the given value (mm/s)
  * The value may be limited with warning feedback, if configured.
  *
  * This hard limit is applied as a block is being added to the planner queue.
  */
-void Planner::set_max_feedrate(const uint8_t axis, const float &inMaxFeedrateMMS) {
+void Planner::set_max_feedrate(const uint8_t axis, float inMaxFeedrateMMS) {
   #if ENABLED(LIMITED_MAX_FR_EDITING)
     #ifdef MAX_FEEDRATE_EDIT_VALUES
       constexpr xyze_float_t max_fr_edit = MAX_FEEDRATE_EDIT_VALUES;
       const xyze_float_t &max_fr_edit_scaled = max_fr_edit;
     #else
       constexpr xyze_float_t max_fr_edit = DEFAULT_MAX_FEEDRATE;
       const xyze_float_t max_fr_edit_scaled = max_fr_edit * 2;
     #endif
     limit_and_warn(inMaxFeedrateMMS, axis, PSTR("Feedrate"), max_fr_edit_scaled);
   #endif
@@ -3067,33 +3067,33 @@ void Planner::set_max_feedrate(const uint8_t axis, const float &inMaxFeedrateMMS
 }
 
 #if HAS_CLASSIC_JERK
 
   /**
    * For the specified 'axis' set the Maximum Jerk (instant change) to the given value (mm/s)
    * The value may be limited with warning feedback, if configured.
    *
    * This hard limit is applied (to the block start speed) as the block is being added to the planner queue.
    */
-  void Planner::set_max_jerk(const AxisEnum axis, const float &targetValue) {
+  void Planner::set_max_jerk(const AxisEnum axis, float inMaxJerkMMS) {
     #if ENABLED(LIMITED_JERK_EDITING)
       constexpr xyze_float_t max_jerk_edit =
         #ifdef MAX_JERK_EDIT_VALUES
           MAX_JERK_EDIT_VALUES
         #else
           { (DEFAULT_XJERK) * 2, (DEFAULT_YJERK) * 2,
             (DEFAULT_ZJERK) * 2, (DEFAULT_EJERK) * 2 }
         #endif
       ;
-      limit_and_warn(targetValue, axis, PSTR("Jerk"), max_jerk_edit);
+      limit_and_warn(inMaxJerkMMS, axis, PSTR("Jerk"), max_jerk_edit);
     #endif
-    max_jerk[axis] = targetValue;
+    max_jerk[axis] = inMaxJerkMMS;
   }
 
 #endif
 
 #if HAS_WIRED_LCD
 
   uint16_t Planner::block_buffer_runtime() {
     #ifdef __AVR__
       // Protect the access to the variable. Only required for AVR, as
       //  any 32bit CPU offers atomic access to 32bit variables

commit 9823a37362c86f8f722c01af2147075d70234ada
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 16 15:12:28 2021 -0500

    E1+ Autotemp and Planner comments

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index dd87a0d24d..c60e9f6cd3 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1241,46 +1241,20 @@ void Planner::recalculate() {
   // Initialize block index to the last block in the planner buffer.
   const uint8_t block_index = prev_block_index(block_buffer_head);
   // If there is just one block, no planning can be done. Avoid it!
   if (block_index != block_buffer_planned) {
     reverse_pass();
     forward_pass();
   }
   recalculate_trapezoids();
 }
 
-#if ENABLED(AUTOTEMP)
-
-  void Planner::getHighESpeed() {
-    static float oldt = 0;
-
-    if (!autotemp_enabled) return;
-    if (thermalManager.degTargetHotend(0) + 2 < autotemp_min) return; // probably temperature set to zero.
-
-    float high = 0.0;
-    for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
-      block_t* block = &block_buffer[b];
-      if (block->steps.x || block->steps.y || block->steps.z) {
-        const float se = (float)block->steps.e / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;
-        NOLESS(high, se);
-      }
-    }
-
-    float t = autotemp_min + high * autotemp_factor;
-    LIMIT(t, autotemp_min, autotemp_max);
-    if (t < oldt) t = t * (1 - float(AUTOTEMP_OLDWEIGHT)) + oldt * float(AUTOTEMP_OLDWEIGHT);
-    oldt = t;
-    thermalManager.setTargetHotend(t, 0);
-  }
-
-#endif // AUTOTEMP
-
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
 
   #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
     xyze_bool_t axis_active = { false };
   #endif
 
   #if HAS_FAN
@@ -1391,20 +1365,86 @@ void Planner::check_axes_activity() {
   #endif // HAS_FAN
 
   TERN_(AUTOTEMP, getHighESpeed());
 
   #if ENABLED(BARICUDA)
     TERN_(HAS_HEATER_1, analogWrite(pin_t(HEATER_1_PIN), tail_valve_pressure));
     TERN_(HAS_HEATER_2, analogWrite(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
   #endif
 }
 
+#if ENABLED(AUTOTEMP)
+
+  #if ENABLED(AUTOTEMP_PROPORTIONAL)
+    void Planner::_autotemp_update_from_hotend() {
+      const int16_t target = thermalManager.degTargetHotend(active_extruder);
+      autotemp_min = target + AUTOTEMP_MIN_P;
+      autotemp_max = target + AUTOTEMP_MAX_P;
+    }
+  #endif
+
+  /**
+   * Called after changing tools to:
+   *  - Reset or re-apply the default proportional autotemp factor.
+   *  - Enable autotemp if the factor is non-zero.
+   */
+  void Planner::autotemp_update() {
+    _autotemp_update_from_hotend();
+    autotemp_factor = TERN(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P, 0);
+    autotemp_enabled = autotemp_factor != 0;
+  }
+
+  /**
+   * Called by the M104/M109 commands after setting Hotend Temperature
+   *
+   */
+  void Planner::autotemp_M104_M109() {
+    _autotemp_update_from_hotend();
+
+    if (parser.seenval('S')) autotemp_min = parser.value_celsius();
+    if (parser.seenval('B')) autotemp_max = parser.value_celsius();
+
+    // When AUTOTEMP_PROPORTIONAL is enabled, F0 disables autotemp.
+    // Normally, leaving off F also disables autotemp.
+    autotemp_factor = parser.seen('F') ? parser.value_float() : TERN(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P, 0);
+    autotemp_enabled = autotemp_factor != 0;
+  }
+
+  /**
+   * Called every so often to adjust the hotend target temperature
+   * based on the extrusion speed, which is calculated from the blocks
+   * currently in the planner.
+   */
+  void Planner::getHighESpeed() {
+    static float oldt = 0;
+
+    if (!autotemp_enabled) return;
+    if (thermalManager.degTargetHotend(active_extruder) < autotemp_min - 2) return; // Below the min?
+
+    float high = 0.0;
+    for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
+      block_t* block = &block_buffer[b];
+      if (block->steps.x || block->steps.y || block->steps.z) {
+        const float se = (float)block->steps.e / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;
+        NOLESS(high, se);
+      }
+    }
+
+    float t = autotemp_min + high * autotemp_factor;
+    LIMIT(t, autotemp_min, autotemp_max);
+    if (t < oldt) t *= (1.0f - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
+    oldt = t;
+    thermalManager.setTargetHotend(t, active_extruder);
+  }
+
+#endif
+
 #if DISABLED(NO_VOLUMETRICS)
 
   /**
    * Get a volumetric multiplier from a filament diameter.
    * This is the reciprocal of the circular cross-section area.
    * Return 1.0 with volumetric off or a diameter of 0.0.
    */
   inline float calculate_volumetric_multiplier(const float &diameter) {
     return (parser.volumetric_enabled && diameter) ? 1.0f / CIRCLE_AREA(diameter * 0.5f) : 1;
   }
@@ -2952,88 +2992,111 @@ void Planner::reset_acceleration_rates() {
   #endif
   uint32_t highest_rate = 1;
   LOOP_XYZE_N(i) {
     max_acceleration_steps_per_s2[i] = settings.max_acceleration_mm_per_s2[i] * settings.axis_steps_per_mm[i];
     if (AXIS_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   }
   cutoff_long = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
   TERN_(HAS_LINEAR_E_JERK, recalculate_max_e_jerk());
 }
 
-// Recalculate position, steps_to_mm if settings.axis_steps_per_mm changes!
+/**
+ * Recalculate 'position' and 'steps_to_mm'.
+ * Must be called whenever settings.axis_steps_per_mm changes!
+ */
 void Planner::refresh_positioning() {
   LOOP_XYZE_N(i) steps_to_mm[i] = 1.0f / settings.axis_steps_per_mm[i];
   set_position_mm(current_position);
   reset_acceleration_rates();
 }
 
+// Apply limits to a variable and give a warning if the value was out of range
 inline void limit_and_warn(float &val, const uint8_t axis, PGM_P const setting_name, const xyze_float_t &max_limit) {
   const uint8_t lim_axis = axis > E_AXIS ? E_AXIS : axis;
   const float before = val;
   LIMIT(val, 0.1, max_limit[lim_axis]);
   if (before != val) {
     SERIAL_CHAR(axis_codes[lim_axis]);
     SERIAL_ECHOPGM(" Max ");
     SERIAL_ECHOPGM_P(setting_name);
     SERIAL_ECHOLNPAIR(" limited to ", val);
   }
 }
 
-void Planner::set_max_acceleration(const uint8_t axis, float targetValue) {
+/**
+ * For the specified 'axis' set the Maximum Acceleration to the given value (mm/s^2)
+ * The value may be limited with warning feedback, if configured.
+ * Calls reset_acceleration_rates to precalculate planner terms in steps.
+ *
+ * This hard limit is applied as a block is being added to the planner queue.
+ */
+void Planner::set_max_acceleration(const uint8_t axis, const float &inMaxAccelMMS2) {
   #if ENABLED(LIMITED_MAX_ACCEL_EDITING)
     #ifdef MAX_ACCEL_EDIT_VALUES
       constexpr xyze_float_t max_accel_edit = MAX_ACCEL_EDIT_VALUES;
       const xyze_float_t &max_acc_edit_scaled = max_accel_edit;
     #else
       constexpr xyze_float_t max_accel_edit = DEFAULT_MAX_ACCELERATION;
       const xyze_float_t max_acc_edit_scaled = max_accel_edit * 2;
     #endif
-    limit_and_warn(targetValue, axis, PSTR("Acceleration"), max_acc_edit_scaled);
+    limit_and_warn(inMaxAccelMMS2, axis, PSTR("Acceleration"), max_acc_edit_scaled);
   #endif
-  settings.max_acceleration_mm_per_s2[axis] = targetValue;
+  settings.max_acceleration_mm_per_s2[axis] = inMaxAccelMMS2;
 
   // Update steps per s2 to agree with the units per s2 (since they are used in the planner)
   reset_acceleration_rates();
 }
 
-void Planner::set_max_feedrate(const uint8_t axis, float targetValue) {
+/**
+ * For the specified 'axis' set the Maximum Feedrate to the given value (mm/s)
+ * The value may be limited with warning feedback, if configured.
+ *
+ * This hard limit is applied as a block is being added to the planner queue.
+ */
+void Planner::set_max_feedrate(const uint8_t axis, const float &inMaxFeedrateMMS) {
   #if ENABLED(LIMITED_MAX_FR_EDITING)
     #ifdef MAX_FEEDRATE_EDIT_VALUES
       constexpr xyze_float_t max_fr_edit = MAX_FEEDRATE_EDIT_VALUES;
       const xyze_float_t &max_fr_edit_scaled = max_fr_edit;
     #else
       constexpr xyze_float_t max_fr_edit = DEFAULT_MAX_FEEDRATE;
       const xyze_float_t max_fr_edit_scaled = max_fr_edit * 2;
     #endif
-    limit_and_warn(targetValue, axis, PSTR("Feedrate"), max_fr_edit_scaled);
+    limit_and_warn(inMaxFeedrateMMS, axis, PSTR("Feedrate"), max_fr_edit_scaled);
   #endif
-  settings.max_feedrate_mm_s[axis] = targetValue;
+  settings.max_feedrate_mm_s[axis] = inMaxFeedrateMMS;
 }
 
-void Planner::set_max_jerk(const AxisEnum axis, float targetValue) {
-  #if HAS_CLASSIC_JERK
+#if HAS_CLASSIC_JERK
+
+  /**
+   * For the specified 'axis' set the Maximum Jerk (instant change) to the given value (mm/s)
+   * The value may be limited with warning feedback, if configured.
+   *
+   * This hard limit is applied (to the block start speed) as the block is being added to the planner queue.
+   */
+  void Planner::set_max_jerk(const AxisEnum axis, const float &targetValue) {
     #if ENABLED(LIMITED_JERK_EDITING)
       constexpr xyze_float_t max_jerk_edit =
         #ifdef MAX_JERK_EDIT_VALUES
           MAX_JERK_EDIT_VALUES
         #else
           { (DEFAULT_XJERK) * 2, (DEFAULT_YJERK) * 2,
             (DEFAULT_ZJERK) * 2, (DEFAULT_EJERK) * 2 }
         #endif
       ;
       limit_and_warn(targetValue, axis, PSTR("Jerk"), max_jerk_edit);
     #endif
     max_jerk[axis] = targetValue;
-  #else
-    UNUSED(axis); UNUSED(targetValue);
-  #endif
-}
+  }
+
+#endif
 
 #if HAS_WIRED_LCD
 
   uint16_t Planner::block_buffer_runtime() {
     #ifdef __AVR__
       // Protect the access to the variable. Only required for AVR, as
       //  any 32bit CPU offers atomic access to 32bit variables
       const bool was_enabled = stepper.suspend();
     #endif
 
@@ -3062,40 +3125,10 @@ void Planner::set_max_jerk(const AxisEnum axis, float targetValue) {
 
     block_buffer_runtime_us = 0;
 
     #ifdef __AVR__
       // Reenable Stepper ISR
       if (was_enabled) stepper.wake_up();
     #endif
   }
 
 #endif
-
-#if ENABLED(AUTOTEMP)
-
-void Planner::autotemp_update() {
-  #if ENABLED(AUTOTEMP_PROPORTIONAL)
-    const int16_t target = thermalManager.degTargetHotend(active_extruder);
-    autotemp_min = target + AUTOTEMP_MIN_P;
-    autotemp_max = target + AUTOTEMP_MAX_P;
-  #endif
-  autotemp_factor = TERN(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P, 0);
-  autotemp_enabled = autotemp_factor != 0;
-}
-
-  void Planner::autotemp_M104_M109() {
-
-    #if ENABLED(AUTOTEMP_PROPORTIONAL)
-      const int16_t target = thermalManager.degTargetHotend(active_extruder);
-      autotemp_min = target + AUTOTEMP_MIN_P;
-      autotemp_max = target + AUTOTEMP_MAX_P;
-    #endif
-
-    if (parser.seenval('S')) autotemp_min = parser.value_celsius();
-    if (parser.seenval('B')) autotemp_max = parser.value_celsius();
-
-    // When AUTOTEMP_PROPORTIONAL is enabled, F0 disables autotemp.
-    // Normally, leaving off F also disables autotemp.
-    autotemp_factor = parser.seen('F') ? parser.value_float() : TERN(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P, 0);
-    autotemp_enabled = autotemp_factor != 0;
-  }
-#endif

commit dd42831cba7334c5d106ba435bdb41b6135971bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 28 19:43:46 2021 -0600

    Serial macros cleanup

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7fcf37e044..dd87a0d24d 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2966,21 +2966,21 @@ void Planner::refresh_positioning() {
   reset_acceleration_rates();
 }
 
 inline void limit_and_warn(float &val, const uint8_t axis, PGM_P const setting_name, const xyze_float_t &max_limit) {
   const uint8_t lim_axis = axis > E_AXIS ? E_AXIS : axis;
   const float before = val;
   LIMIT(val, 0.1, max_limit[lim_axis]);
   if (before != val) {
     SERIAL_CHAR(axis_codes[lim_axis]);
     SERIAL_ECHOPGM(" Max ");
-    serialprintPGM(setting_name);
+    SERIAL_ECHOPGM_P(setting_name);
     SERIAL_ECHOLNPAIR(" limited to ", val);
   }
 }
 
 void Planner::set_max_acceleration(const uint8_t axis, float targetValue) {
   #if ENABLED(LIMITED_MAX_ACCEL_EDITING)
     #ifdef MAX_ACCEL_EDIT_VALUES
       constexpr xyze_float_t max_accel_edit = MAX_ACCEL_EDIT_VALUES;
       const xyze_float_t &max_acc_edit_scaled = max_accel_edit;
     #else

commit a4c73860a12ae67083a294b8c2eaad78c11c5081
Author: espr14 <espr14@gmail.com>
Date:   Thu Feb 18 06:22:29 2021 +0100

    Fix cleaning_buffer_counter check (#21115)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 541aed943e..7fcf37e044 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1683,27 +1683,29 @@ void Planner::synchronize() {
 bool Planner::_buffer_steps(const xyze_long_t &target
   #if HAS_POSITION_FLOAT
     , const xyze_pos_t &target_float
   #endif
   #if HAS_DIST_MM_ARG
     , const xyze_float_t &cart_dist_mm
   #endif
   , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters
 ) {
 
-  // If we are cleaning, do not accept queuing of movements
-  if (cleaning_buffer_counter) return false;
-
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
+  // If we are cleaning, do not accept queuing of movements
+  // This must be after get_next_free_block() because it calls idle()
+  // where cleaning_buffer_counter can be changed
+  if (cleaning_buffer_counter) return false;
+
   // Fill the block with the specified movement
   if (!_populate_block(block, false, target
     #if HAS_POSITION_FLOAT
       , target_float
     #endif
     #if HAS_DIST_MM_ARG
       , cart_dist_mm
     #endif
     , fr_mm_s, extruder, millimeters
   )) {

commit 49564e5310184079c53ff322cd27e35e22877017
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 4 19:37:59 2021 -0600

    Nybbles & Bits

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 5897d10cd5..541aed943e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -411,25 +411,25 @@ void Planner::init() {
         A("tst %16")                      // nr & 0xFF0000 == 0 ?
         A("brne 2f")                      // No, skip this
         A("mov %16,%15")                  // nr <<= 8, %14 not needed
         A("clr %15")                      // We clear %14
         A("subi %3,-8")                   // idx += 8
 
         // here %16 != 0 and %16:%15 contains at least 9 MSBits, or both %16:%15 are 0
         L("2")
         A("cpi %16,0x10")                 // (nr & 0xF00000) == 0 ?
         A("brcc 3f")                      // No, skip this
-        A("swap %15")                     // Swap nibbles
-        A("swap %16")                     // Swap nibbles. Low nibble is 0
+        A("swap %15")                     // Swap nybbles
+        A("swap %16")                     // Swap nybbles. Low nybble is 0
         A("mov %14, %15")
-        A("andi %14,0x0F")                // Isolate low nibble
-        A("andi %15,0xF0")                // Keep proper nibble in %15
+        A("andi %14,0x0F")                // Isolate low nybble
+        A("andi %15,0xF0")                // Keep proper nybble in %15
         A("or %16, %14")                  // %16:%15 <<= 4
         A("subi %3,-4")                   // idx += 4
 
         L("3")
         A("cpi %16,0x40")                 // (nr & 0xC00000) == 0 ?
         A("brcc 4f")                      // No, skip this
         A("add %15,%15")
         A("adc %16,%16")
         A("add %15,%15")
         A("adc %16,%16")                  // %16:%15 <<= 2
@@ -466,24 +466,24 @@ void Planner::init() {
         L("8")
         A("sbrs %3,1")                    // shift by 2bit position?
         A("rjmp 9f")                      // No
         A("add %14,%14")
         A("adc %15,%15")
         A("add %14,%14")
         A("adc %15,%15")                  // %15:16 <<= 1
         L("9")
         A("sbrs %3,2")                    // shift by 4bits position?
         A("rjmp 16f")                     // No
-        A("swap %15")                     // Swap nibbles. lo nibble of %15 will always be 0
-        A("swap %14")                     // Swap nibbles
+        A("swap %15")                     // Swap nybbles. lo nybble of %15 will always be 0
+        A("swap %14")                     // Swap nybbles
         A("mov %12,%14")
-        A("andi %12,0x0F")                // isolate low nibble
+        A("andi %12,0x0F")                // isolate low nybble
         A("andi %14,0xF0")                // and clear it
         A("or %15,%12")                   // %15:%16 <<= 4
         L("16")
         A("sbrs %3,3")                    // shift by 8bits position?
         A("rjmp 6f")                      // No, we are done
         A("mov %16,%15")
         A("mov %15,%14")
         A("clr %14")
         A("jmp 6f")
 
@@ -497,25 +497,25 @@ void Planner::init() {
         L("10")
         A("sbrs %3,1")                    // shift by 2 bit position ?
         A("rjmp 11f")                     // No, skip it
         A("asr %15")                      // (bit7 is always 0 here)
         A("ror %14")
         A("asr %15")                      // (bit7 is always 0 here)
         A("ror %14")
         L("11")
         A("sbrs %3,2")                    // shift by 4 bit position ?
         A("rjmp 12f")                     // No, skip it
-        A("swap %15")                     // Swap nibbles
-        A("andi %14, 0xF0")               // Lose the lowest nibble
-        A("swap %14")                     // Swap nibbles. Upper nibble is 0
-        A("or %14,%15")                   // Pass nibble from upper byte
-        A("andi %15, 0x0F")               // And get rid of that nibble
+        A("swap %15")                     // Swap nybbles
+        A("andi %14, 0xF0")               // Lose the lowest nybble
+        A("swap %14")                     // Swap nybbles. Upper nybble is 0
+        A("or %14,%15")                   // Pass nybble from upper byte
+        A("andi %15, 0x0F")               // And get rid of that nybble
         L("12")
         A("sbrs %3,3")                    // shift by 8 bit position ?
         A("rjmp 6f")                      // No, skip it
         A("mov %14,%15")
         A("clr %15")
         L("6")                            // %16:%15:%14 = initial estimation of 0x1000000 / d
 
         // Now, we must refine the estimation present on %16:%15:%14 using 1 iteration
         // of Newton-Raphson. As it has a quadratic convergence, 1 iteration is enough
         // to get more than 18bits of precision (the initial table lookup gives 9 bits of

commit c824086825c6763f45f145326adf33e050d88490
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Dec 13 01:53:21 2020 -0600

    Adjust planner debugging

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 147adb12e3..5897d10cd5 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1758,28 +1758,29 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
                 db = target.b - position.b,
                 dc = target.c - position.c;
 
   #if EXTRUDERS
     int32_t de = target.e - position.e;
   #else
     constexpr int32_t de = 0;
   #endif
 
   /* <-- add a slash to enable
-    SERIAL_ECHOLNPAIR("  _populate_block FR:", fr_mm_s,
-                      " A:", target.a, " (", da, " steps)"
-                      " B:", target.b, " (", db, " steps)"
-                      " C:", target.c, " (", dc, " steps)"
-                      #if EXTRUDERS
-                        " E:", target.e, " (", de, " steps)"
-                      #endif
-                    );
+    SERIAL_ECHOLNPAIR(
+      "  _populate_block FR:", fr_mm_s,
+      " A:", target.a, " (", da, " steps)"
+      " B:", target.b, " (", db, " steps)"
+      " C:", target.c, " (", dc, " steps)"
+      #if EXTRUDERS
+        " E:", target.e, " (", de, " steps)"
+      #endif
+    );
   //*/
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position.e = target.e; // Behave as if the move really took place, but ignore E part
           TERN_(HAS_POSITION_FLOAT, position_float.e = target_float.e);
           de = 0; // no difference
           SERIAL_ECHO_MSG(STR_ERR_COLD_EXTRUDE_STOP);

commit 110e0d782f50082819101ca39ad4e38300046467
Author: FanDjango <51046875+FanDjango@users.noreply.github.com>
Date:   Mon Nov 16 21:56:05 2020 +0100

    Guards for large BLOCK_BUFFER_SIZE (>=128) (#20130)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 74535df1f9..147adb12e3 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -206,21 +206,21 @@ skew_factor_t Planner::skew_factor; // Initialized by settings.load()
 // private:
 
 xyze_long_t Planner::position{0};
 
 uint32_t Planner::cutoff_long;
 
 xyze_float_t Planner::previous_speed;
 float Planner::previous_nominal_speed_sqr;
 
 #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
-  uint8_t Planner::g_uc_extruder_last_move[EXTRUDERS] = { 0 };
+  last_move_t Planner::g_uc_extruder_last_move[EXTRUDERS] = { 0 };
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
   int8_t Planner::xy_freq_limit_hz = XY_FREQUENCY_LIMIT;
   float Planner::xy_freq_min_speed_factor = (XY_FREQUENCY_MIN_PERCENT) * 0.01f;
   int32_t Planner::xy_freq_min_interval_us = LROUND(1000000.0 / (XY_FREQUENCY_LIMIT));
 #endif
 
 #if ENABLED(LIN_ADVANCE)
   float Planner::extruder_advance_K[EXTRUDERS]; // Initialized by settings.load()
@@ -2030,36 +2030,34 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #endif
 
   // Enable extruder(s)
   #if EXTRUDERS
     if (esteps) {
       TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
         LOOP_L_N(i, EXTRUDERS)
-          if (g_uc_extruder_last_move[i] > 0) g_uc_extruder_last_move[i]--;
-
-        #if HAS_DUPLICATION_MODE
-          if (extruder_duplication_enabled && extruder == 0) {
-            ENABLE_AXIS_E1();
-            g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
-          }
-        #endif
+          if (g_uc_extruder_last_move[i]) g_uc_extruder_last_move[i]--;
 
         #define ENABLE_ONE_E(N) do{ \
           if (extruder == N) { \
             ENABLE_AXIS_E##N(); \
             g_uc_extruder_last_move[N] = (BLOCK_BUFFER_SIZE) * 2; \
+            if ((N) == 0 && TERN0(HAS_DUPLICATION_MODE, extruder_duplication_enabled)) \
+              ENABLE_AXIS_E1(); \
           } \
-          else if (!g_uc_extruder_last_move[N]) \
+          else if (!g_uc_extruder_last_move[N]) { \
             DISABLE_AXIS_E##N(); \
+            if ((N) == 0 && TERN0(HAS_DUPLICATION_MODE, extruder_duplication_enabled)) \
+              DISABLE_AXIS_E1(); \
+          } \
         }while(0);
 
       #else
 
         #define ENABLE_ONE_E(N) ENABLE_AXIS_E##N();
 
       #endif
 
       REPEAT(EXTRUDERS, ENABLE_ONE_E); // (ENABLE_ONE_E must end with semicolon)
     }

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 4ad7c4ccf0..74535df1f9 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -59,21 +59,21 @@
  * --
  *
  * The fast inverse function needed for B√©zier interpolation for AVR
  * was designed, written and tested by Eduardo Jos√© Tagle on April/2018
  */
 
 #include "planner.h"
 #include "stepper.h"
 #include "motion.h"
 #include "temperature.h"
-#include "../lcd/ultralcd.h"
+#include "../lcd/marlinui.h"
 #include "../gcode/parser.h"
 
 #include "../MarlinCore.h"
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"

commit 4424645e04c9e75462d36de8f7a82e67cc9c262e
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Mon Sep 28 21:53:50 2020 +0200

    Multi-line comments cleanup (#19535)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 2ef00f7959..4ad7c4ccf0 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -332,21 +332,20 @@ void Planner::init() {
      *
      *  // Isolate top 9 bits of the denominator, to be used as index into the initial estimation table
      *  uint32_t tidx = nr >> 15,                                       // top 9 bits. bit8 is always set
      *           ie = inv_tab[tidx & 0xFF] + 256,                       // Get the table value. bit9 is always set
      *           x = idx <= 8 ? (ie >> (8 - idx)) : (ie << (idx - 8));  // Position the estimation at the proper place
      *
      *  x = uint32_t((x * uint64_t(_BV(25) - x * d)) >> 24);            // Refine estimation by newton-raphson. 1 iteration is enough
      *  const uint32_t r = _BV(24) - x * d;                             // Estimate remainder
      *  if (r >= d) x++;                                                // Check whether to adjust result
      *  return uint32_t(x);                                             // x holds the proper estimation
-     *
      */
     static uint32_t get_period_inverse(uint32_t d) {
 
       static const uint8_t inv_tab[256] PROGMEM = {
         255,253,252,250,248,246,244,242,240,238,236,234,233,231,229,227,
         225,224,222,220,218,217,215,213,212,210,208,207,205,203,202,200,
         199,197,195,194,192,191,189,188,186,185,183,182,180,179,178,176,
         175,173,172,170,169,168,166,165,164,162,161,160,158,157,156,154,
         153,152,151,149,148,147,146,144,143,142,141,139,138,137,136,135,
         134,132,131,130,129,128,127,126,125,123,122,121,120,119,118,117,
@@ -2236,21 +2235,20 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     }while(0)
 
     // Start with print or travel acceleration
     accel = CEIL((esteps ? settings.acceleration : settings.travel_acceleration) * steps_per_mm);
 
     #if ENABLED(LIN_ADVANCE)
 
       #define MAX_E_JERK(N) TERN(HAS_LINEAR_E_JERK, max_e_jerk[E_INDEX_N(N)], max_jerk.e)
 
       /**
-       *
        * Use LIN_ADVANCE for blocks if all these are true:
        *
        * esteps             : This is a print move, because we checked for A, B, C steps before.
        *
        * extruder_advance_K[active_extruder] : There is an advance factor set for this extruder.
        *
        * de > 0             : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
        */
       block->use_advance_lead =  esteps
                               && extruder_advance_K[active_extruder]

commit c2c6a679ea4bdf48ce1800a8831fcec36c09ce53
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 28 01:13:27 2020 -0500

    Rename LCD conditionals (#19533)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 30e1ffb0ca..2ef00f7959 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -227,21 +227,21 @@ float Planner::previous_nominal_speed_sqr;
 #endif
 
 #if HAS_POSITION_FLOAT
   xyze_pos_t Planner::position_float; // Needed for accurate maths. Steps cannot be used!
 #endif
 
 #if IS_KINEMATIC
   xyze_pos_t Planner::position_cart;
 #endif
 
-#if HAS_SPI_LCD
+#if HAS_WIRED_LCD
   volatile uint32_t Planner::block_buffer_runtime_us = 0;
 #endif
 
 /**
  * Class and Instance Methods
  */
 
 Planner::Planner() { init(); }
 
 void Planner::init() {
@@ -740,35 +740,35 @@ block_t* Planner::get_current_block() {
       delay_before_delivering = 0;
     }
 
     // If we are here, there is no excuse to deliver the block
     block_t * const block = &block_buffer[block_buffer_tail];
 
     // No trapezoid calculated? Don't execute yet.
     if (TEST(block->flag, BLOCK_BIT_RECALCULATE)) return nullptr;
 
     // We can't be sure how long an active block will take, so don't count it.
-    TERN_(HAS_SPI_LCD, block_buffer_runtime_us -= block->segment_time_us);
+    TERN_(HAS_WIRED_LCD, block_buffer_runtime_us -= block->segment_time_us);
 
     // As this block is busy, advance the nonbusy block pointer
     block_buffer_nonbusy = next_block_index(block_buffer_tail);
 
     // Push block_buffer_planned pointer, if encountered.
     if (block_buffer_tail == block_buffer_planned)
       block_buffer_planned = block_buffer_nonbusy;
 
     // Return the block
     return block;
   }
 
   // The queue became empty
-  TERN_(HAS_SPI_LCD, clear_block_buffer_runtime()); // paranoia. Buffer is empty now - so reset accumulated time to zero.
+  TERN_(HAS_WIRED_LCD, clear_block_buffer_runtime()); // paranoia. Buffer is empty now - so reset accumulated time to zero.
 
   return nullptr;
 }
 
 /**
  * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
  * by the provided factors.
  **
  * ############ VERY IMPORTANT ############
  * NOTE that the PRECONDITION to call this function is that the block is
@@ -1571,21 +1571,21 @@ void Planner::quick_stop() {
 
   const bool was_enabled = stepper.suspend();
 
   // Drop all queue entries
   block_buffer_nonbusy = block_buffer_planned = block_buffer_head = block_buffer_tail;
 
   // Restart the block delay for the first movement - As the queue was
   // forced to empty, there's no risk the ISR will touch this.
   delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
 
-  #if HAS_SPI_LCD
+  #if HAS_WIRED_LCD
     // Clear the accumulated runtime
     clear_block_buffer_runtime();
   #endif
 
   // Make sure to drop any attempt of queuing moves for 1 second
   cleaning_buffer_counter = TEMP_TIMER_FREQUENCY;
 
   // Reenable Stepper ISR
   if (was_enabled) stepper.wake_up();
 
@@ -2074,43 +2074,43 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   const float inverse_millimeters = 1.0f / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate inverse time for this move. No divide by zero due to previous checks.
   // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   float inverse_secs = fr_mm_s * inverse_millimeters;
 
   // Get the number of non busy movements in queue (non busy means that they can be altered)
   const uint8_t moves_queued = nonbusy_movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
-  #if EITHER(SLOWDOWN, HAS_SPI_LCD) || defined(XY_FREQUENCY_LIMIT)
+  #if EITHER(SLOWDOWN, HAS_WIRED_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time im micro seconds
     int32_t segment_time_us = LROUND(1000000.0f / inverse_secs);
   #endif
 
   #if ENABLED(SLOWDOWN)
     #ifndef SLOWDOWN_DIVISOR
       #define SLOWDOWN_DIVISOR 2
     #endif
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / (SLOWDOWN_DIVISOR) - 1)) {
       const int32_t time_diff = settings.min_segment_time_us - segment_time_us;
       if (time_diff > 0) {
         // Buffer is draining so add extra time. The amount of time added increases if the buffer is still emptied more.
         const int32_t nst = segment_time_us + LROUND(2 * time_diff / moves_queued);
         inverse_secs = 1000000.0f / nst;
-        #if defined(XY_FREQUENCY_LIMIT) || HAS_SPI_LCD
+        #if defined(XY_FREQUENCY_LIMIT) || HAS_WIRED_LCD
           segment_time_us = nst;
         #endif
       }
     }
   #endif
 
-  #if HAS_SPI_LCD
+  #if HAS_WIRED_LCD
     // Protect the access to the position.
     const bool was_enabled = stepper.suspend();
 
     block_buffer_runtime_us += segment_time_us;
     block->segment_time_us = segment_time_us;
 
     if (was_enabled) stepper.wake_up();
   #endif
 
   block->nominal_speed_sqr = sq(block->millimeters * inverse_secs);   // (mm/sec)^2 Always > 0
@@ -3022,21 +3022,21 @@ void Planner::set_max_jerk(const AxisEnum axis, float targetValue) {
         #endif
       ;
       limit_and_warn(targetValue, axis, PSTR("Jerk"), max_jerk_edit);
     #endif
     max_jerk[axis] = targetValue;
   #else
     UNUSED(axis); UNUSED(targetValue);
   #endif
 }
 
-#if HAS_SPI_LCD
+#if HAS_WIRED_LCD
 
   uint16_t Planner::block_buffer_runtime() {
     #ifdef __AVR__
       // Protect the access to the variable. Only required for AVR, as
       //  any 32bit CPU offers atomic access to 32bit variables
       const bool was_enabled = stepper.suspend();
     #endif
 
     uint32_t bbru = block_buffer_runtime_us;
 

commit 76d8d1742c1d4a1efe0fd6c0645d3fc656bfd0b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 20 18:29:08 2020 -0500

    Add multi-extruder condition

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 82c62ed579..30e1ffb0ca 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1985,21 +1985,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   #if HAS_FAN
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
-  #if EXTRUDERS > 1
+  #if HAS_MULTI_EXTRUDER
     block->extruder = extruder;
   #endif
 
   #if ENABLED(AUTO_POWER_CONTROL)
     if (block->steps.x || block->steps.y || block->steps.z)
       powerManager.power_on();
   #endif
 
   // Enable active axes
   #if EITHER(CORE_IS_XY, MARKFORGED_XY)
@@ -2836,21 +2836,21 @@ bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, con
 
     uint8_t next_buffer_head;
     block_t * const block = get_next_free_block(next_buffer_head);
 
     block->flag = BLOCK_FLAG_IS_PAGE;
 
     #if FAN_COUNT > 0
       FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
     #endif
 
-    #if EXTRUDERS > 1
+    #if HAS_MULTI_EXTRUDER
       block->extruder = extruder;
     #endif
 
     block->page_idx = page_idx;
 
     block->step_event_count = num_steps;
     block->initial_rate =
       block->final_rate =
       block->nominal_rate = last_page_step_rate; // steps/s
 

commit e97e6865c3e587a04ae2878e72a8dfb137534b7e
Author: Victor Sokolov <gzigzigzeo@gmail.com>
Date:   Fri Sep 4 05:12:53 2020 +0400

    MarkForged kinematics (#19235)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 931daa3322..82c62ed579 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1607,40 +1607,62 @@ void Planner::finish_and_disable() {
   disable_all_steppers();
 }
 
 /**
  * Get an axis position according to stepper position(s)
  * For CORE machines apply translation from ABC to XYZ.
  */
 float Planner::get_axis_position_mm(const AxisEnum axis) {
   float axis_steps;
   #if IS_CORE
+
     // Requesting one of the "core" axes?
     if (axis == CORE_AXIS_1 || axis == CORE_AXIS_2) {
 
       // Protect the access to the position.
       const bool was_enabled = stepper.suspend();
 
       const int32_t p1 = stepper.position(CORE_AXIS_1),
                     p2 = stepper.position(CORE_AXIS_2);
 
       if (was_enabled) stepper.wake_up();
 
       // ((a1+a2)+(a1-a2))/2 -> (a1+a2+a1-a2)/2 -> (a1+a1)/2 -> a1
       // ((a1+a2)-(a1-a2))/2 -> (a1+a2-a1+a2)/2 -> (a2+a2)/2 -> a2
       axis_steps = (axis == CORE_AXIS_2 ? CORESIGN(p1 - p2) : p1 + p2) * 0.5f;
     }
     else
       axis_steps = stepper.position(axis);
+
+  #elif ENABLED(MARKFORGED_XY)
+
+    // Requesting one of the joined axes?
+    if (axis == CORE_AXIS_1 || axis == CORE_AXIS_2) {
+      // Protect the access to the position.
+      const bool was_enabled = stepper.suspend();
+
+      const int32_t p1 = stepper.position(CORE_AXIS_1),
+                    p2 = stepper.position(CORE_AXIS_2);
+
+      if (was_enabled) stepper.wake_up();
+
+      axis_steps = ((axis == CORE_AXIS_1) ? p1 - p2 : p2);
+    }
+    else
+      axis_steps = stepper.position(axis);
+
   #else
+
     axis_steps = stepper.position(axis);
+
   #endif
+
   return axis_steps * steps_to_mm[axis];
 }
 
 /**
  * Block until all buffered steps are executed / cleaned
  */
 void Planner::synchronize() {
   while (has_blocks_queued() || cleaning_buffer_counter
       || TERN0(EXTERNAL_CLOSED_LOOP_CONTROLLER, CLOSED_LOOP_WAITING())
   ) idle();
@@ -1801,20 +1823,26 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     if (db < 0) SBI(dm, Y_AXIS);
     if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
     if (da + dc < 0) SBI(dm, A_AXIS);           // Motor A direction
     if (CORESIGN(da - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
   #elif CORE_IS_YZ
     if (da < 0) SBI(dm, X_AXIS);
     if (db < 0) SBI(dm, Y_HEAD);                // Save the real Extruder (head) direction in Y Axis
     if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
     if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
     if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
+  #elif ENABLED(MARKFORGED_XY)
+    if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
+    if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
+    if (dc < 0) SBI(dm, Z_AXIS);
+    if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
+    if (db < 0) SBI(dm, B_AXIS);                // Motor B direction
   #else
     if (da < 0) SBI(dm, X_AXIS);
     if (db < 0) SBI(dm, Y_AXIS);
     if (dc < 0) SBI(dm, Z_AXIS);
   #endif
   if (de < 0) SBI(dm, E_AXIS);
 
   #if EXTRUDERS
     const float esteps_float = de * e_factor[extruder];
     const uint32_t esteps = ABS(esteps_float) + 0.5f;
@@ -1836,37 +1864,41 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #endif
 
   // Number of steps for each axis
   // See https://www.corexy.com/theory.html
   #if CORE_IS_XY
     block->steps.set(ABS(da + db), ABS(da - db), ABS(dc));
   #elif CORE_IS_XZ
     block->steps.set(ABS(da + dc), ABS(db), ABS(da - dc));
   #elif CORE_IS_YZ
     block->steps.set(ABS(da), ABS(db + dc), ABS(db - dc));
+  #elif ENABLED(MARKFORGED_XY)
+    block->steps.set(ABS(da + db), ABS(db), ABS(dc));
   #elif IS_SCARA
     block->steps.set(ABS(da), ABS(db), ABS(dc));
   #else
     // default non-h-bot planning
     block->steps.set(ABS(da), ABS(db), ABS(dc));
   #endif
 
   /**
    * This part of the code calculates the total length of the movement.
    * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
    * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
    * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
    * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
    * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
    */
   struct DistanceMM : abce_float_t {
-    TERN_(IS_CORE, xyz_pos_t head);
+    #if EITHER(IS_CORE, MARKFORGED_XY)
+      xyz_pos_t head;
+    #endif
   } steps_dist_mm;
   #if IS_CORE
     #if CORE_IS_XY
       steps_dist_mm.head.x = da * steps_to_mm[A_AXIS];
       steps_dist_mm.head.y = db * steps_to_mm[B_AXIS];
       steps_dist_mm.z      = dc * steps_to_mm[Z_AXIS];
       steps_dist_mm.a      = (da + db) * steps_to_mm[A_AXIS];
       steps_dist_mm.b      = CORESIGN(da - db) * steps_to_mm[B_AXIS];
     #elif CORE_IS_XZ
       steps_dist_mm.head.x = da * steps_to_mm[A_AXIS];
@@ -1874,20 +1906,26 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       steps_dist_mm.head.z = dc * steps_to_mm[C_AXIS];
       steps_dist_mm.a      = (da + dc) * steps_to_mm[A_AXIS];
       steps_dist_mm.c      = CORESIGN(da - dc) * steps_to_mm[C_AXIS];
     #elif CORE_IS_YZ
       steps_dist_mm.x      = da * steps_to_mm[X_AXIS];
       steps_dist_mm.head.y = db * steps_to_mm[B_AXIS];
       steps_dist_mm.head.z = dc * steps_to_mm[C_AXIS];
       steps_dist_mm.b      = (db + dc) * steps_to_mm[B_AXIS];
       steps_dist_mm.c      = CORESIGN(db - dc) * steps_to_mm[C_AXIS];
     #endif
+  #elif ENABLED(MARKFORGED_XY)
+    steps_dist_mm.head.x = da * steps_to_mm[A_AXIS];
+    steps_dist_mm.head.y = db * steps_to_mm[B_AXIS];
+    steps_dist_mm.z      = dc * steps_to_mm[Z_AXIS];
+    steps_dist_mm.a      = (da - db) * steps_to_mm[A_AXIS];
+    steps_dist_mm.b      = db * steps_to_mm[B_AXIS];
   #else
     steps_dist_mm.a = da * steps_to_mm[A_AXIS];
     steps_dist_mm.b = db * steps_to_mm[B_AXIS];
     steps_dist_mm.c = dc * steps_to_mm[C_AXIS];
   #endif
 
   #if EXTRUDERS
     steps_dist_mm.e = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
   #else
     steps_dist_mm.e = 0.0f;
@@ -1900,21 +1938,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       #if EXTRUDERS
         + ABS(steps_dist_mm.e)
       #endif
     );
   }
   else {
     if (millimeters)
       block->millimeters = millimeters;
     else
       block->millimeters = SQRT(
-        #if CORE_IS_XY
+        #if EITHER(CORE_IS_XY, MARKFORGED_XY)
           sq(steps_dist_mm.head.x) + sq(steps_dist_mm.head.y) + sq(steps_dist_mm.z)
         #elif CORE_IS_XZ
           sq(steps_dist_mm.head.x) + sq(steps_dist_mm.y) + sq(steps_dist_mm.head.z)
         #elif CORE_IS_YZ
           sq(steps_dist_mm.x) + sq(steps_dist_mm.head.y) + sq(steps_dist_mm.head.z)
         #else
           sq(steps_dist_mm.x) + sq(steps_dist_mm.y) + sq(steps_dist_mm.z)
         #endif
       );
 
@@ -1957,21 +1995,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #if EXTRUDERS > 1
     block->extruder = extruder;
   #endif
 
   #if ENABLED(AUTO_POWER_CONTROL)
     if (block->steps.x || block->steps.y || block->steps.z)
       powerManager.power_on();
   #endif
 
   // Enable active axes
-  #if CORE_IS_XY
+  #if EITHER(CORE_IS_XY, MARKFORGED_XY)
     if (block->steps.a || block->steps.b) {
       ENABLE_AXIS_X();
       ENABLE_AXIS_Y();
     }
     #if DISABLED(Z_LATE_ENABLE)
       if (block->steps.z) ENABLE_AXIS_Z();
     #endif
   #elif CORE_IS_XZ
     if (block->steps.a || block->steps.c) {
       ENABLE_AXIS_X();
@@ -2318,23 +2356,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         cart_dist_mm
       #else
         { steps_dist_mm.x, steps_dist_mm.y, steps_dist_mm.z, steps_dist_mm.e }
       #endif
     ;
 
     /**
      * On CoreXY the length of the vector [A,B] is SQRT(2) times the length of the head movement vector [X,Y].
      * So taking Z and E into account, we cannot scale to a unit vector with "inverse_millimeters".
      * => normalize the complete junction vector.
-     * Elsewise, when needed JD factors in the E component
+     * Elsewise, when needed JD will factor-in the E component
      */
-    if (ENABLED(IS_CORE) || esteps > 0)
+    if (EITHER(IS_CORE, MARKFORGED_XY) || esteps > 0)
       normalize_junction_vector(unit_vec);  // Normalize with XYZE components
     else
       unit_vec *= inverse_millimeters;      // Use pre-calculated (1 / SQRT(x^2 + y^2 + z^2))
 
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
       float junction_cos_theta = (-prev_unit_vec.x * unit_vec.x) + (-prev_unit_vec.y * unit_vec.y)
                                + (-prev_unit_vec.z * unit_vec.z) + (-prev_unit_vec.e * unit_vec.e);

commit ce3df42e229ea563ef319f42cf5283f5a2ba3fa3
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Mon Aug 10 03:48:57 2020 +0200

    Fix DISABLE_[XYZE] code (#18970)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c2a9e6ac77..931daa3322 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1274,21 +1274,21 @@ void Planner::recalculate() {
   }
 
 #endif // AUTOTEMP
 
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
 
   #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
-    xyze_bool_t axis_active = { true, true, true, true };
+    xyze_bool_t axis_active = { false };
   #endif
 
   #if HAS_FAN
     uint8_t tail_fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
     #endif
@@ -1309,24 +1309,24 @@ void Planner::check_axes_activity() {
     #endif
 
     #if ENABLED(BARICUDA)
       TERN_(HAS_HEATER_1, tail_valve_pressure = block->valve_pressure);
       TERN_(HAS_HEATER_2, tail_e_to_p_pressure = block->e_to_p_pressure);
     #endif
 
     #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
       for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
         block_t *block = &block_buffer[b];
-        if (ENABLED(DISABLE_X) && block->steps[X_AXIS]) axis_active[X_AXIS] = true;
-        if (ENABLED(DISABLE_Y) && block->steps[Y_AXIS]) axis_active[Y_AXIS] = true;
-        if (ENABLED(DISABLE_Z) && block->steps[Z_AXIS]) axis_active[Z_AXIS] = true;
-        if (ENABLED(DISABLE_E) && block->steps[E_AXIS]) axis_active[E_AXIS] = true;
+        if (ENABLED(DISABLE_X) && block->steps.x) axis_active.x = true;
+        if (ENABLED(DISABLE_Y) && block->steps.y) axis_active.y = true;
+        if (ENABLED(DISABLE_Z) && block->steps.z) axis_active.z = true;
+        if (ENABLED(DISABLE_E) && block->steps.e) axis_active.e = true;
       }
     #endif
   }
   else {
 
     TERN_(HAS_CUTTER, cutter.refresh());
 
     #if HAS_FAN
       FANS_LOOP(i)
         tail_fan_speed[i] = thermalManager.scaledFanSpeed(i);

commit 4856ac50281291790405a0fd35be88d035416b7a
Author: swissnorp <67485708+swissnorp@users.noreply.github.com>
Date:   Tue Aug 4 07:31:45 2020 +0200

    Add Z_AFTER_DEACTIVATE to account for gravity (#18906)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 65a9e4e059..c2a9e6ac77 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1274,21 +1274,21 @@ void Planner::recalculate() {
   }
 
 #endif // AUTOTEMP
 
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
 
   #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
-    xyze_bool_t axis_active = { false };
+    xyze_bool_t axis_active = { true, true, true, true };
   #endif
 
   #if HAS_FAN
     uint8_t tail_fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
     #endif
@@ -1309,21 +1309,24 @@ void Planner::check_axes_activity() {
     #endif
 
     #if ENABLED(BARICUDA)
       TERN_(HAS_HEATER_1, tail_valve_pressure = block->valve_pressure);
       TERN_(HAS_HEATER_2, tail_e_to_p_pressure = block->e_to_p_pressure);
     #endif
 
     #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
       for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
         block_t *block = &block_buffer[b];
-        LOOP_XYZE(i) if (block->steps[i]) axis_active[i] = true;
+        if (ENABLED(DISABLE_X) && block->steps[X_AXIS]) axis_active[X_AXIS] = true;
+        if (ENABLED(DISABLE_Y) && block->steps[Y_AXIS]) axis_active[Y_AXIS] = true;
+        if (ENABLED(DISABLE_Z) && block->steps[Z_AXIS]) axis_active[Z_AXIS] = true;
+        if (ENABLED(DISABLE_E) && block->steps[E_AXIS]) axis_active[E_AXIS] = true;
       }
     #endif
   }
   else {
 
     TERN_(HAS_CUTTER, cutter.refresh());
 
     #if HAS_FAN
       FANS_LOOP(i)
         tail_fan_speed[i] = thermalManager.scaledFanSpeed(i);

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 8352c2b3a6..65a9e4e059 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * planner.cpp
  *
  * Buffer movement commands and manage the acceleration profile plan
  *
  * Derived from Grbl
  * Copyright (c) 2009-2011 Simen Svale Skogsrud
@@ -1826,21 +1826,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   block->direction_bits = dm;
 
   // Update block laser power
   #if ENABLED(LASER_POWER_INLINE)
     laser_inline.status.isPlanned = true;
     block->laser.status = laser_inline.status;
     block->laser.power = laser_inline.power;
   #endif
 
   // Number of steps for each axis
-  // See http://www.corexy.com/theory.html
+  // See https://www.corexy.com/theory.html
   #if CORE_IS_XY
     block->steps.set(ABS(da + db), ABS(da - db), ABS(dc));
   #elif CORE_IS_XZ
     block->steps.set(ABS(da + dc), ABS(db), ABS(da - dc));
   #elif CORE_IS_YZ
     block->steps.set(ABS(da), ABS(db + dc), ABS(db - dc));
   #elif IS_SCARA
     block->steps.set(ABS(da), ABS(db), ABS(dc));
   #else
     // default non-h-bot planning

commit f6a2b6409192c4e349321f42a5c0ebfd4e278b82
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 3 09:53:22 2020 -0500

    Clean up LCD Manual Move / UBL Mesh Edit (#18373)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 1beb63c1a4..8352c2b3a6 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1647,21 +1647,21 @@ void Planner::synchronize() {
  * Planner::_buffer_steps
  *
  * Add a new linear movement to the planner queue (in terms of steps).
  *
  *  target        - target position in steps units
  *  target_float  - target position in direct (mm, degrees) units. optional
  *  fr_mm_s       - (target) speed of the move
  *  extruder      - target extruder
  *  millimeters   - the length of the movement, if known
  *
- * Returns true if movement was properly queued, false otherwise
+ * Returns true if movement was properly queued, false otherwise (if cleaning)
  */
 bool Planner::_buffer_steps(const xyze_long_t &target
   #if HAS_POSITION_FLOAT
     , const xyze_pos_t &target_float
   #endif
   #if HAS_DIST_MM_ARG
     , const xyze_float_t &cart_dist_mm
   #endif
   , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters
 ) {
@@ -2630,20 +2630,22 @@ void Planner::buffer_sync_block() {
  * Planner::buffer_segment
  *
  * Add a new linear movement to the buffer in axis units.
  *
  * Leveling and kinematics should be applied ahead of calling this.
  *
  *  a,b,c,e     - target positions in mm and/or degrees
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *  millimeters - the length of the movement, if known
+ *
+ * Return 'false' if no segment was queued due to cleaning, cold extrusion, full queue, etc.
  */
 bool Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e
   #if HAS_DIST_MM_ARG
     , const xyze_float_t &cart_dist_mm
   #endif
   , const feedRate_t &fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
@@ -2699,21 +2701,21 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
     #endif
     SERIAL_ECHOPAIR(" (", position.z);
     SERIAL_ECHOPAIR("->", target.z);
     SERIAL_CHAR(')');
     SERIAL_ECHOPAIR_P(SP_E_LBL, e);
     SERIAL_ECHOPAIR(" (", position.e);
     SERIAL_ECHOPAIR("->", target.e);
     SERIAL_ECHOLNPGM(")");
   //*/
 
-  // Queue the movement
+  // Queue the movement. Return 'false' if the move was not queued.
   if (!_buffer_steps(target
       #if HAS_POSITION_FLOAT
         , target_float
       #endif
       #if HAS_DIST_MM_ARG
         , cart_dist_mm
       #endif
       , fr_mm_s, extruder, millimeters)
   ) return false;
 

commit 48151d177890d102c3e7adbc00ec5ee6f367a8fb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jun 28 13:48:48 2020 -0500

    ClosedLoop as singleton

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 5715399e49..1beb63c1a4 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -84,20 +84,24 @@
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"
 #endif
 
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
+#if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
+  #include "../feature/closedloop.h"
+#endif
+
 #if ENABLED(BACKLASH_COMPENSATION)
   #include "../feature/backlash.h"
 #endif
 
 #if ENABLED(CANCEL_OBJECTS)
   #include "../feature/cancel_object.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/powerloss.h"
@@ -1627,25 +1631,22 @@ float Planner::get_axis_position_mm(const AxisEnum axis) {
   #else
     axis_steps = stepper.position(axis);
   #endif
   return axis_steps * steps_to_mm[axis];
 }
 
 /**
  * Block until all buffered steps are executed / cleaned
  */
 void Planner::synchronize() {
-  while (
-    has_blocks_queued() || cleaning_buffer_counter
-    #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
-      || (READ(CLOSED_LOOP_ENABLE_PIN) && !READ(CLOSED_LOOP_MOVE_COMPLETE_PIN))
-    #endif
+  while (has_blocks_queued() || cleaning_buffer_counter
+      || TERN0(EXTERNAL_CLOSED_LOOP_CONTROLLER, CLOSED_LOOP_WAITING())
   ) idle();
 }
 
 /**
  * Planner::_buffer_steps
  *
  * Add a new linear movement to the planner queue (in terms of steps).
  *
  *  target        - target position in steps units
  *  target_float  - target position in direct (mm, degrees) units. optional

commit f445bc26e52de36239e595ee3fbd2d25abc97258
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 25 16:39:22 2020 -0500

    Minor LCD cleanup, improvement

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 2703cd64cf..5715399e49 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2032,21 +2032,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   const float inverse_millimeters = 1.0f / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate inverse time for this move. No divide by zero due to previous checks.
   // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   float inverse_secs = fr_mm_s * inverse_millimeters;
 
   // Get the number of non busy movements in queue (non busy means that they can be altered)
   const uint8_t moves_queued = nonbusy_movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
-  #if EITHER(SLOWDOWN, ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
+  #if EITHER(SLOWDOWN, HAS_SPI_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time im micro seconds
     int32_t segment_time_us = LROUND(1000000.0f / inverse_secs);
   #endif
 
   #if ENABLED(SLOWDOWN)
     #ifndef SLOWDOWN_DIVISOR
       #define SLOWDOWN_DIVISOR 2
     #endif
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / (SLOWDOWN_DIVISOR) - 1)) {
       const int32_t time_diff = settings.min_segment_time_us - segment_time_us;

commit a4b46eaf8f45ef9f8c212b9f17692682cae08aaa
Author: XDA-Bam <1209896+XDA-Bam@users.noreply.github.com>
Date:   Tue Jun 16 01:54:00 2020 +0200

    Add JD_HANDLE_SMALL_SEGMENTS option (#18316)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index bc6a067f59..2703cd64cf 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2345,103 +2345,107 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
         // Convert delta vector to unit vector
         xyze_float_t junction_unit_vec = unit_vec - prev_unit_vec;
         normalize_junction_vector(junction_unit_vec);
 
         const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec),
                     sin_theta_d2 = SQRT(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
 
         vmax_junction_sqr = junction_acceleration * junction_deviation_mm * sin_theta_d2 / (1.0f - sin_theta_d2);
 
-        // For small moves with >135¬∞ junction (octagon) find speed for approximate arc
-        if (block->millimeters < 1 && junction_cos_theta < -0.7071067812f) {
-
-          #if ENABLED(JD_USE_MATH_ACOS)
-
-            #error "TODO: Inline maths with the MCU / FPU."
-
-          #elif ENABLED(JD_USE_LOOKUP_TABLE)
-
-            // Fast acos approximation (max. error +-0.01 rads)
-            // Based on LUT table and linear interpolation
-
-            /**
-             *  // Generate the JD Lookup Table
-             *  constexpr float c = 1.00751495f; // Correction factor to center error around 0
-             *  for (int i = 0; i < jd_lut_count - 1; ++i) {
-             *    const float x0 = (sq(i) - 1) / sq(i),
-             *                y0 = acos(x0) * (i == 0 ? 1 : c),
-             *                x1 = i < jd_lut_count - 1 ?  0.5 * x0 + 0.5 : 0.999999f,
-             *                y1 = acos(x1) * (i < jd_lut_count - 1 ? c : 1);
-             *    jd_lut_k[i] = (y0 - y1) / (x0 - x1);
-             *    jd_lut_b[i] = (y1 * x0 - y0 * x1) / (x0 - x1);
-             *  }
-             *
-             *  // Compute correction factor (Set c to 1.0f first!)
-             *  float min = INFINITY, max = -min;
-             *  for (float t = 0; t <= 1; t += 0.0003f) {
-             *    const float e = acos(t) / approx(t);
-             *    if (isfinite(e)) {
-             *      if (e < min) min = e;
-             *      if (e > max) max = e;
-             *    }
-             *  }
-             *  fprintf(stderr, "%.9gf, ", (min + max) / 2);
-             */
-            static constexpr int16_t  jd_lut_count = 16;
-            static constexpr uint16_t jd_lut_tll   = _BV(jd_lut_count - 1);
-            static constexpr int16_t  jd_lut_tll0  = __builtin_clz(jd_lut_tll) + 1; // i.e., 16 - jd_lut_count + 1
-            static constexpr float jd_lut_k[jd_lut_count] PROGMEM = {
-              -1.03145837f, -1.30760646f, -1.75205851f, -2.41705704f,
-              -3.37769222f, -4.74888992f, -6.69649887f, -9.45661736f,
-              -13.3640480f, -18.8928222f, -26.7136841f, -37.7754593f,
-              -53.4201813f, -75.5458374f, -106.836761f, -218.532821f };
-            static constexpr float jd_lut_b[jd_lut_count] PROGMEM = {
-               1.57079637f,  1.70887053f,  2.04220939f,  2.62408352f,
-               3.52467871f,  4.85302639f,  6.77020454f,  9.50875854f,
-               13.4009285f,  18.9188995f,  26.7321243f,  37.7885055f,
-               53.4293975f,  75.5523529f,  106.841369f,  218.534011f };
-
-            const float neg = junction_cos_theta < 0 ? -1 : 1,
-                        t = neg * junction_cos_theta;
-
-            const int16_t idx = (t < 0.00000003f) ? 0 : __builtin_clz(uint16_t((1.0f - t) * jd_lut_tll)) - jd_lut_tll0;
-
-            float junction_theta = t * pgm_read_float(&jd_lut_k[idx]) + pgm_read_float(&jd_lut_b[idx]);
-            if (neg > 0) junction_theta = RADIANS(180) - junction_theta; // acos(-t)
+        #if ENABLED(JD_HANDLE_SMALL_SEGMENTS)
+
+          // For small moves with >135¬∞ junction (octagon) find speed for approximate arc
+          if (block->millimeters < 1 && junction_cos_theta < -0.7071067812f) {
+
+            #if ENABLED(JD_USE_MATH_ACOS)
+
+              #error "TODO: Inline maths with the MCU / FPU."
+
+            #elif ENABLED(JD_USE_LOOKUP_TABLE)
+
+              // Fast acos approximation (max. error +-0.01 rads)
+              // Based on LUT table and linear interpolation
+
+              /**
+               *  // Generate the JD Lookup Table
+               *  constexpr float c = 1.00751495f; // Correction factor to center error around 0
+               *  for (int i = 0; i < jd_lut_count - 1; ++i) {
+               *    const float x0 = (sq(i) - 1) / sq(i),
+               *                y0 = acos(x0) * (i == 0 ? 1 : c),
+               *                x1 = i < jd_lut_count - 1 ?  0.5 * x0 + 0.5 : 0.999999f,
+               *                y1 = acos(x1) * (i < jd_lut_count - 1 ? c : 1);
+               *    jd_lut_k[i] = (y0 - y1) / (x0 - x1);
+               *    jd_lut_b[i] = (y1 * x0 - y0 * x1) / (x0 - x1);
+               *  }
+               *
+               *  // Compute correction factor (Set c to 1.0f first!)
+               *  float min = INFINITY, max = -min;
+               *  for (float t = 0; t <= 1; t += 0.0003f) {
+               *    const float e = acos(t) / approx(t);
+               *    if (isfinite(e)) {
+               *      if (e < min) min = e;
+               *      if (e > max) max = e;
+               *    }
+               *  }
+               *  fprintf(stderr, "%.9gf, ", (min + max) / 2);
+               */
+              static constexpr int16_t  jd_lut_count = 16;
+              static constexpr uint16_t jd_lut_tll   = _BV(jd_lut_count - 1);
+              static constexpr int16_t  jd_lut_tll0  = __builtin_clz(jd_lut_tll) + 1; // i.e., 16 - jd_lut_count + 1
+              static constexpr float jd_lut_k[jd_lut_count] PROGMEM = {
+                -1.03145837f, -1.30760646f, -1.75205851f, -2.41705704f,
+                -3.37769222f, -4.74888992f, -6.69649887f, -9.45661736f,
+                -13.3640480f, -18.8928222f, -26.7136841f, -37.7754593f,
+                -53.4201813f, -75.5458374f, -106.836761f, -218.532821f };
+              static constexpr float jd_lut_b[jd_lut_count] PROGMEM = {
+                 1.57079637f,  1.70887053f,  2.04220939f,  2.62408352f,
+                 3.52467871f,  4.85302639f,  6.77020454f,  9.50875854f,
+                 13.4009285f,  18.9188995f,  26.7321243f,  37.7885055f,
+                 53.4293975f,  75.5523529f,  106.841369f,  218.534011f };
+
+              const float neg = junction_cos_theta < 0 ? -1 : 1,
+                          t = neg * junction_cos_theta;
+
+              const int16_t idx = (t < 0.00000003f) ? 0 : __builtin_clz(uint16_t((1.0f - t) * jd_lut_tll)) - jd_lut_tll0;
+
+              float junction_theta = t * pgm_read_float(&jd_lut_k[idx]) + pgm_read_float(&jd_lut_b[idx]);
+              if (neg > 0) junction_theta = RADIANS(180) - junction_theta; // acos(-t)
+
+            #else
+
+              // Fast acos(-t) approximation (max. error +-0.033rad = 1.89¬∞)
+              // Based on MinMax polynomial published by W. Randolph Franklin, see
+              // https://wrf.ecse.rpi.edu/Research/Short_Notes/arcsin/onlyelem.html
+              //  acos( t) = pi / 2 - asin(x)
+              //  acos(-t) = pi - acos(t) ... pi / 2 + asin(x)
+
+              const float neg = junction_cos_theta < 0 ? -1 : 1,
+                          t = neg * junction_cos_theta,
+                          asinx =       0.032843707f
+                                + t * (-1.451838349f
+                                + t * ( 29.66153956f
+                                + t * (-131.1123477f
+                                + t * ( 262.8130562f
+                                + t * (-242.7199627f
+                                + t * ( 84.31466202f ) ))))),
+                          junction_theta = RADIANS(90) + neg * asinx; // acos(-t)
+
+              // NOTE: junction_theta bottoms out at 0.033 which avoids divide by 0.
 
-          #else
-
-            // Fast acos(-t) approximation (max. error +-0.033rad = 1.89¬∞)
-            // Based on MinMax polynomial published by W. Randolph Franklin, see
-            // https://wrf.ecse.rpi.edu/Research/Short_Notes/arcsin/onlyelem.html
-            //  acos( t) = pi / 2 - asin(x)
-            //  acos(-t) = pi - acos(t) ... pi / 2 + asin(x)
-
-            const float neg = junction_cos_theta < 0 ? -1 : 1,
-                        t = neg * junction_cos_theta,
-                        asinx =       0.032843707f
-                              + t * (-1.451838349f
-                              + t * ( 29.66153956f
-                              + t * (-131.1123477f
-                              + t * ( 262.8130562f
-                              + t * (-242.7199627f
-                              + t * ( 84.31466202f ) ))))),
-                        junction_theta = RADIANS(90) + neg * asinx; // acos(-t)
-
-            // NOTE: junction_theta bottoms out at 0.033 which avoids divide by 0.
+            #endif
 
-          #endif
+            const float limit_sqr = (block->millimeters * junction_acceleration) / junction_theta;
+            NOMORE(vmax_junction_sqr, limit_sqr);
+          }
 
-          const float limit_sqr = (block->millimeters * junction_acceleration) / junction_theta;
-          NOMORE(vmax_junction_sqr, limit_sqr);
-        }
+        #endif // JD_HANDLE_SMALL_SEGMENTS
       }
 
       // Get the lowest speed
       vmax_junction_sqr = _MIN(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
       vmax_junction_sqr = 0;
 
     prev_unit_vec = unit_vec;
 

commit aea60d94507da282c182a065c226734bc83f4d52
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 15 18:11:19 2020 -0500

    Clean up trailing spaces

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index f6a0909034..bc6a067f59 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2100,23 +2100,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         // Move all mixing extruders at the specified rate
         if (mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)
           current_speed.e *= MIXING_STEPPERS;
       #endif
 
       const feedRate_t cs = ABS(current_speed.e),
                    max_fr = settings.max_feedrate_mm_s[E_AXIS_N(extruder)]
                             * TERN(HAS_MIXER_SYNC_CHANNEL, MIXING_STEPPERS, 1);
 
       if (cs > max_fr) NOMORE(speed_factor, max_fr / cs); //respect max feedrate on any movement (doesn't matter if E axes only or not)
-      
+
       #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
-        const feedRate_t max_vfr = volumetric_extruder_feedrate_limit[extruder] 
+        const feedRate_t max_vfr = volumetric_extruder_feedrate_limit[extruder]
                                    * TERN(HAS_MIXER_SYNC_CHANNEL, MIXING_STEPPERS, 1);
 
         // TODO: Doesn't work properly for joined segments. Set MIN_STEPS_PER_SEGMENT 1 as workaround.
 
         if (block->steps.a || block->steps.b || block->steps.c) {
 
           if (max_vfr > 0 && cs > max_vfr) {
             NOMORE(speed_factor, max_vfr / cs); // respect volumetric extruder limit (if any)
             /* <-- add a slash to enable
             SERIAL_ECHOPAIR("volumetric extruder limit enforced: ", (cs * CIRCLE_AREA(filament_size[extruder] * 0.5f)));

commit 0fa345f98f7223f2546a9a6808d5c67039fb3aab
Author: Luu Lac <45380455+shitcreek@users.noreply.github.com>
Date:   Mon Jun 8 19:53:39 2020 -0500

    Laser updates followup (#18237)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index cd425ef174..f6a0909034 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1819,20 +1819,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #endif
 
   // Clear all flags, including the "busy" bit
   block->flag = 0x00;
 
   // Set direction bits
   block->direction_bits = dm;
 
   // Update block laser power
   #if ENABLED(LASER_POWER_INLINE)
+    laser_inline.status.isPlanned = true;
     block->laser.status = laser_inline.status;
     block->laser.power = laser_inline.power;
   #endif
 
   // Number of steps for each axis
   // See http://www.corexy.com/theory.html
   #if CORE_IS_XY
     block->steps.set(ABS(da + db), ABS(da - db), ABS(dc));
   #elif CORE_IS_XZ
     block->steps.set(ABS(da + dc), ABS(db), ABS(da - dc));

commit bac760207c3e85b9ac97a36c37aeb4ad601102a3
Author: MoellerDi <MoellerDi@users.noreply.github.com>
Date:   Mon Jun 8 10:24:46 2020 +0200

    Add volumetric extrusion limit (#17017)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index f04c63060d..cd425ef174 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -164,20 +164,25 @@ float Planner::steps_to_mm[XYZE_N];             // (mm) Millimeters per step
   int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
   float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0f); // The flow percentage and volumetric multiplier combine to scale E movement
 #endif
 
 #if DISABLED(NO_VOLUMETRICS)
   float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
         Planner::volumetric_area_nominal = CIRCLE_AREA(float(DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5f), // Nominal cross-sectional area
         Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
 #endif
 
+#if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+  float Planner::volumetric_extruder_limit[EXTRUDERS],          // max mm^3/sec the extruder is able to handle
+        Planner::volumetric_extruder_feedrate_limit[EXTRUDERS]; // pre calculated extruder feedrate limit based on volumetric_extruder_limit; pre-calculated to reduce computation in the planner
+#endif
+
 #if HAS_LEVELING
   bool Planner::leveling_active = false; // Flag that auto bed leveling is enabled
   #if ABL_PLANAR
     matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
   #endif
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
     float Planner::z_fade_height,      // Initialized by settings.load()
           Planner::inverse_z_fade_height,
           Planner::last_fade_z;
   #endif
@@ -1400,24 +1405,42 @@ void Planner::check_axes_activity() {
 
   /**
    * Convert the filament sizes into volumetric multipliers.
    * The multiplier converts a given E value into a length.
    */
   void Planner::calculate_volumetric_multipliers() {
     LOOP_L_N(i, COUNT(filament_size)) {
       volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
       refresh_e_factor(i);
     }
+    #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+      calculate_volumetric_extruder_limits(); // update volumetric_extruder_limits as well.
+    #endif
   }
 
 #endif // !NO_VOLUMETRICS
 
+#if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+
+  /**
+   * Convert volumetric based limits into pre calculated extruder feedrate limits.
+   */
+  void Planner::calculate_volumetric_extruder_limit(const uint8_t e) {
+    const float &lim = volumetric_extruder_limit[e], &siz = filament_size[e];
+    volumetric_extruder_feedrate_limit[e] = (lim && siz) ? lim / CIRCLE_AREA(siz * 0.5f) : 0;
+  }
+  void Planner::calculate_volumetric_extruder_limits() {
+    LOOP_L_N(e, EXTRUDERS) calculate_volumetric_extruder_limit(e);
+  }
+
+#endif
+
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   /**
    * Convert the ratio value given by the filament width sensor
    * into a volumetric multiplier. Conversion differs when using
    * linear extrusion vs volumetric extrusion.
    */
   void Planner::apply_filament_width_sensor(const int8_t encoded_ratio) {
     // Reconstitute the nominal/measured ratio
     const float nom_meas_ratio = 1 + 0.01f * encoded_ratio,
                 ratio_2 = sq(nom_meas_ratio);
@@ -2070,24 +2093,47 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   // Limit speed on extruders, if any
   #if EXTRUDERS
     {
       current_speed.e = steps_dist_mm.e * inverse_secs;
       #if HAS_MIXER_SYNC_CHANNEL
         // Move all mixing extruders at the specified rate
         if (mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)
           current_speed.e *= MIXING_STEPPERS;
       #endif
+
       const feedRate_t cs = ABS(current_speed.e),
                    max_fr = settings.max_feedrate_mm_s[E_AXIS_N(extruder)]
                             * TERN(HAS_MIXER_SYNC_CHANNEL, MIXING_STEPPERS, 1);
-      if (cs > max_fr) NOMORE(speed_factor, max_fr / cs);
+
+      if (cs > max_fr) NOMORE(speed_factor, max_fr / cs); //respect max feedrate on any movement (doesn't matter if E axes only or not)
+      
+      #if ENABLED(VOLUMETRIC_EXTRUDER_LIMIT)
+        const feedRate_t max_vfr = volumetric_extruder_feedrate_limit[extruder] 
+                                   * TERN(HAS_MIXER_SYNC_CHANNEL, MIXING_STEPPERS, 1);
+
+        // TODO: Doesn't work properly for joined segments. Set MIN_STEPS_PER_SEGMENT 1 as workaround.
+
+        if (block->steps.a || block->steps.b || block->steps.c) {
+
+          if (max_vfr > 0 && cs > max_vfr) {
+            NOMORE(speed_factor, max_vfr / cs); // respect volumetric extruder limit (if any)
+            /* <-- add a slash to enable
+            SERIAL_ECHOPAIR("volumetric extruder limit enforced: ", (cs * CIRCLE_AREA(filament_size[extruder] * 0.5f)));
+            SERIAL_ECHOPAIR(" mm^3/s (", cs);
+            SERIAL_ECHOPAIR(" mm/s) limited to ", (max_vfr * CIRCLE_AREA(filament_size[extruder] * 0.5f)));
+            SERIAL_ECHOPAIR(" mm^3/s (", max_vfr);
+            SERIAL_ECHOLNPGM(" mm/s)");
+            //*/
+          }
+        }
+      #endif
     }
   #endif
 
   #ifdef XY_FREQUENCY_LIMIT
 
     static uint8_t old_direction_bits; // = 0
 
     if (xy_freq_limit_hz) {
       // Check and limit the xy direction change frequency
       const uint8_t direction_change = block->direction_bits ^ old_direction_bits;

commit eda2fd8dbea69cb8f571f2992cb11334b2cb7a2f
Author: Luu Lac <45380455+shitcreek@users.noreply.github.com>
Date:   Mon Jun 8 00:47:31 2020 -0500

    Improvements for Laser / Spindle (#17661)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 5602495b47..f04c63060d 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -122,21 +122,21 @@ block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head,    // Index of the next block to be pushed
                  Planner::block_buffer_nonbusy, // Index of the first non-busy block
                  Planner::block_buffer_planned, // Index of the optimally planned block
                  Planner::block_buffer_tail;    // Index of the busy block, if any
 uint16_t Planner::cleaning_buffer_counter;      // A counter to disable queuing of blocks
 uint8_t Planner::delay_before_delivering;       // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
 planner_settings_t Planner::settings;           // Initialized by settings.load()
 
 #if ENABLED(LASER_POWER_INLINE)
-  laser_state_t Planner::laser;              // Current state for blocks
+  laser_state_t Planner::laser_inline;          // Current state for blocks
 #endif
 
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
 
 float Planner::steps_to_mm[XYZE_N];             // (mm) Millimeters per step
 
 #if HAS_JUNCTION_DEVIATION
   float Planner::junction_deviation_mm;         // (mm) M205 J
   #if HAS_LINEAR_E_JERK
     float Planner::max_e_jerk[DISTINCT_E];      // Calculated from junction_deviation_mm
@@ -1686,21 +1686,21 @@ bool Planner::_buffer_steps(const xyze_long_t &target
 
 /**
  * Planner::_populate_block
  *
  * Fills a new linear movement in the block (in terms of steps).
  *
  *  target      - target position in steps units
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *
- * Returns true is movement is acceptable, false otherwise
+ * Returns true if movement is acceptable, false otherwise
  */
 bool Planner::_populate_block(block_t * const block, bool split_move,
   const abce_long_t &target
   #if HAS_POSITION_FLOAT
     , const xyze_pos_t &target_float
   #endif
   #if HAS_DIST_MM_ARG
     , const xyze_float_t &cart_dist_mm
   #endif
   , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
@@ -1796,22 +1796,22 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #endif
 
   // Clear all flags, including the "busy" bit
   block->flag = 0x00;
 
   // Set direction bits
   block->direction_bits = dm;
 
   // Update block laser power
   #if ENABLED(LASER_POWER_INLINE)
-    block->laser.status = laser.status;
-    block->laser.power = laser.power;
+    block->laser.status = laser_inline.status;
+    block->laser.power = laser_inline.power;
   #endif
 
   // Number of steps for each axis
   // See http://www.corexy.com/theory.html
   #if CORE_IS_XY
     block->steps.set(ABS(da + db), ABS(da - db), ABS(dc));
   #elif CORE_IS_XZ
     block->steps.set(ABS(da + dc), ABS(db), ABS(da - dc));
   #elif CORE_IS_YZ
     block->steps.set(ABS(da), ABS(db + dc), ABS(db - dc));

commit a0b27e67022859bf2d9cad5be8fdc02301e50d1a
Author: XDA-Bam <1209896+XDA-Bam@users.noreply.github.com>
Date:   Wed Jun 3 02:30:43 2020 +0200

    Fix JD LUT math & bugs (#18175)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 38442d7b96..5602495b47 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2312,58 +2312,59 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
             #error "TODO: Inline maths with the MCU / FPU."
 
           #elif ENABLED(JD_USE_LOOKUP_TABLE)
 
             // Fast acos approximation (max. error +-0.01 rads)
             // Based on LUT table and linear interpolation
 
             /**
              *  // Generate the JD Lookup Table
-             *  constexpr float c = 1.00751317f; // Correction factor to center error around 0
+             *  constexpr float c = 1.00751495f; // Correction factor to center error around 0
              *  for (int i = 0; i < jd_lut_count - 1; ++i) {
              *    const float x0 = (sq(i) - 1) / sq(i),
-             *                y0 = acos(x0) * (i ? c : 1),
-             *                x1 = 0.5 * x0 + 0.5,
-             *                y1 = acos(x1) * c;
+             *                y0 = acos(x0) * (i == 0 ? 1 : c),
+             *                x1 = i < jd_lut_count - 1 ?  0.5 * x0 + 0.5 : 0.999999f,
+             *                y1 = acos(x1) * (i < jd_lut_count - 1 ? c : 1);
              *    jd_lut_k[i] = (y0 - y1) / (x0 - x1);
              *    jd_lut_b[i] = (y1 * x0 - y0 * x1) / (x0 - x1);
              *  }
-             *  jd_lut_k[jd_lut_count - 1] = jd_lut_b[jd_lut_count - 1] = 0;
              *
              *  // Compute correction factor (Set c to 1.0f first!)
              *  float min = INFINITY, max = -min;
              *  for (float t = 0; t <= 1; t += 0.0003f) {
              *    const float e = acos(t) / approx(t);
              *    if (isfinite(e)) {
              *      if (e < min) min = e;
              *      if (e > max) max = e;
              *    }
              *  }
              *  fprintf(stderr, "%.9gf, ", (min + max) / 2);
              */
-            static constexpr int16_t  jd_lut_count = 15;
-            static constexpr uint16_t jd_lut_tll   = 1 << jd_lut_count;
-            static constexpr int16_t  jd_lut_tll0  = __builtin_clz(jd_lut_tll) + 1; // i.e., 16 - jd_lut_count
+            static constexpr int16_t  jd_lut_count = 16;
+            static constexpr uint16_t jd_lut_tll   = _BV(jd_lut_count - 1);
+            static constexpr int16_t  jd_lut_tll0  = __builtin_clz(jd_lut_tll) + 1; // i.e., 16 - jd_lut_count + 1
             static constexpr float jd_lut_k[jd_lut_count] PROGMEM = {
-              -1.03146219f, -1.30760407f, -1.75205469f, -2.41705418f, -3.37768555f,
-              -4.74888229f, -6.69648552f, -9.45659828f, -13.3640289f, -18.8927879f,
-              -26.7136307f, -37.7754059f, -53.4200745f, -75.5457306f,   0.0f };
+              -1.03145837f, -1.30760646f, -1.75205851f, -2.41705704f,
+              -3.37769222f, -4.74888992f, -6.69649887f, -9.45661736f,
+              -13.3640480f, -18.8928222f, -26.7136841f, -37.7754593f,
+              -53.4201813f, -75.5458374f, -106.836761f, -218.532821f };
             static constexpr float jd_lut_b[jd_lut_count] PROGMEM = {
-              1.57079637f, 1.70886743f, 2.04220533f, 2.62408018f, 3.52467203f,
-              4.85301876f, 6.77019119f, 9.50873947f, 13.4009094f, 18.9188652f,
-              26.7320709f, 37.7884521f, 53.4292908f, 75.5522461f,  0.0f };
+               1.57079637f,  1.70887053f,  2.04220939f,  2.62408352f,
+               3.52467871f,  4.85302639f,  6.77020454f,  9.50875854f,
+               13.4009285f,  18.9188995f,  26.7321243f,  37.7885055f,
+               53.4293975f,  75.5523529f,  106.841369f,  218.534011f };
 
             const float neg = junction_cos_theta < 0 ? -1 : 1,
                         t = neg * junction_cos_theta;
 
-            const int16_t idx = (t == 0.0f) ? 0 : __builtin_clz(uint16_t((1.0f - t) * jd_lut_tll)) - jd_lut_tll0;
+            const int16_t idx = (t < 0.00000003f) ? 0 : __builtin_clz(uint16_t((1.0f - t) * jd_lut_tll)) - jd_lut_tll0;
 
             float junction_theta = t * pgm_read_float(&jd_lut_k[idx]) + pgm_read_float(&jd_lut_b[idx]);
             if (neg > 0) junction_theta = RADIANS(180) - junction_theta; // acos(-t)
 
           #else
 
             // Fast acos(-t) approximation (max. error +-0.033rad = 1.89¬∞)
             // Based on MinMax polynomial published by W. Randolph Franklin, see
             // https://wrf.ecse.rpi.edu/Research/Short_Notes/arcsin/onlyelem.html
             //  acos( t) = pi / 2 - asin(x)

commit 5fbea83840dd947790128ec19fab90da29679d20
Author: XDA-Bam <1209896+XDA-Bam@users.noreply.github.com>
Date:   Tue May 26 00:29:02 2020 +0200

    Explicitly optimize x/x in Classic Jerk (#18112)
    
    Can we outsmart the compiler?

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 6058486510..38442d7b96 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2449,30 +2449,30 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
 
       // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
       float v_factor = 1;
       limited = 0;
 
       // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
       // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
       CACHED_SQRT(previous_nominal_speed, previous_nominal_speed_sqr);
 
-      vmax_junction = _MIN(nominal_speed, previous_nominal_speed);
+      float smaller_speed_factor = 1.0f;
+      if (nominal_speed < previous_nominal_speed) {
+        vmax_junction = nominal_speed;
+        smaller_speed_factor = vmax_junction / previous_nominal_speed;
+      }
+      else
+        vmax_junction = previous_nominal_speed;
 
       // Now limit the jerk in all axes.
-      const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
-      #if HAS_LINEAR_E_JERK
-        LOOP_XYZ(axis)
-      #else
-        LOOP_XYZE(axis)
-      #endif
-      {
+      TERN(HAS_LINEAR_E_JERK, LOOP_XYZ, LOOP_XYZE)(axis) {
         // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
         float v_exit = previous_speed[axis] * smaller_speed_factor,
               v_entry = current_speed[axis];
         if (limited) {
           v_exit *= v_factor;
           v_entry *= v_factor;
         }
 
         // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
         const float jerk = (v_exit > v_entry)

commit 181739d0d1a54ab01c4f97678f04ae43ebb1facd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 12 00:09:18 2020 -0500

    Move inline laser state to fix EEPROM error

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 3d026c4dae..6058486510 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -121,20 +121,24 @@ Planner planner;
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head,    // Index of the next block to be pushed
                  Planner::block_buffer_nonbusy, // Index of the first non-busy block
                  Planner::block_buffer_planned, // Index of the optimally planned block
                  Planner::block_buffer_tail;    // Index of the busy block, if any
 uint16_t Planner::cleaning_buffer_counter;      // A counter to disable queuing of blocks
 uint8_t Planner::delay_before_delivering;       // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
 planner_settings_t Planner::settings;           // Initialized by settings.load()
 
+#if ENABLED(LASER_POWER_INLINE)
+  laser_state_t Planner::laser;              // Current state for blocks
+#endif
+
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
 
 float Planner::steps_to_mm[XYZE_N];             // (mm) Millimeters per step
 
 #if HAS_JUNCTION_DEVIATION
   float Planner::junction_deviation_mm;         // (mm) M205 J
   #if HAS_LINEAR_E_JERK
     float Planner::max_e_jerk[DISTINCT_E];      // Calculated from junction_deviation_mm
   #endif
 #endif
@@ -1792,22 +1796,22 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #endif
 
   // Clear all flags, including the "busy" bit
   block->flag = 0x00;
 
   // Set direction bits
   block->direction_bits = dm;
 
   // Update block laser power
   #if ENABLED(LASER_POWER_INLINE)
-    block->laser.status = settings.laser.status;
-    block->laser.power = settings.laser.power;
+    block->laser.status = laser.status;
+    block->laser.power = laser.power;
   #endif
 
   // Number of steps for each axis
   // See http://www.corexy.com/theory.html
   #if CORE_IS_XY
     block->steps.set(ABS(da + db), ABS(da - db), ABS(dc));
   #elif CORE_IS_XZ
     block->steps.set(ABS(da + dc), ABS(db), ABS(da - dc));
   #elif CORE_IS_YZ
     block->steps.set(ABS(da), ABS(db + dc), ABS(db - dc));

commit c2d66a5df05caf15cd2af16562cec87a16971626
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 11 23:20:43 2020 -0500

    Tweak JD + Jerk limit

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index dea51ac67f..3d026c4dae 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2490,23 +2490,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       const float vmax_junction_threshold = vmax_junction * 0.99f;
       if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold)
         vmax_junction = safe_speed;
     }
     else
       vmax_junction = safe_speed;
 
     previous_safe_speed = safe_speed;
 
     #if HAS_JUNCTION_DEVIATION
-      vmax_junction_sqr = _MIN(vmax_junction_sqr, sq(vmax_junction));
+      NOMORE(vmax_junction_sqr, sq(vmax_junction));   // Throttle down to max speed
     #else
-      vmax_junction_sqr = sq(vmax_junction);
+      vmax_junction_sqr = sq(vmax_junction);          // Go up or down to the new speed
     #endif
 
   #endif // Classic Jerk Limiting
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed_sqr = vmax_junction_sqr;
 
   // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
   const float v_allowable_sqr = max_allowable_speed_sqr(-block->acceleration, sq(float(MINIMUM_PLANNER_SPEED)), block->millimeters);
 

commit 8a22ef0c83a94f742be39005f259226e005ded2d
Author: Colin Godsey <crgodsey@gmail.com>
Date:   Mon May 11 18:22:41 2020 -0600

    G6 Direct Stepping (#17853)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7d23789df1..dea51ac67f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -144,20 +144,25 @@ float Planner::steps_to_mm[XYZE_N];             // (mm) Millimeters per step
 #endif
 
 #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
+#if ENABLED(DIRECT_STEPPING)
+  uint32_t Planner::last_page_step_rate = 0;
+  xyze_bool_t Planner::last_page_dir{0};
+#endif
+
 #if EXTRUDERS
   int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
   float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0f); // The flow percentage and volumetric multiplier combine to scale E movement
 #endif
 
 #if DISABLED(NO_VOLUMETRICS)
   float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
         Planner::volumetric_area_nominal = CIRCLE_AREA(float(DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5f), // Nominal cross-sectional area
         Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
 #endif
@@ -228,20 +233,24 @@ Planner::Planner() { init(); }
 
 void Planner::init() {
   position.reset();
   TERN_(HAS_POSITION_FLOAT, position_float.reset());
   TERN_(IS_KINEMATIC, position_cart.reset());
   previous_speed.reset();
   previous_nominal_speed_sqr = 0;
   TERN_(ABL_PLANAR, bed_level_matrix.set_to_identity());
   clear_block_buffer();
   delay_before_delivering = 0;
+  #if ENABLED(DIRECT_STEPPING)
+    last_page_step_rate = 0;
+    last_page_dir.reset();
+  #endif
 }
 
 #if ENABLED(S_CURVE_ACCELERATION)
   #ifdef __AVR__
     /**
      * This routine returns 0x1000000 / d, getting the inverse as fast as possible.
      * A fast-converging iterative Newton-Raphson method can reach full precision in
      * just 1 iteration, and takes 211 cycles (worst case; the mean case is less, up
      * to 30 cycles for small divisors), instead of the 500 cycles a normal division
      * would take.
@@ -899,21 +908,21 @@ void Planner::calculate_trapezoid_for_block(block_t* const block, const float &e
   recomputed as stated in the general guidelines.
 
   Planner buffer index mapping:
   - block_buffer_tail: Points to the beginning of the planner buffer. First to be executed or being executed.
   - block_buffer_head: Points to the buffer block after the last block in the buffer. Used to indicate whether
       the buffer is full or empty. As described for standard ring buffers, this block is always empty.
   - block_buffer_planned: Points to the first buffer block after the last optimally planned block for normal
       streaming operating conditions. Use for planning optimizations by avoiding recomputing parts of the
       planner buffer that don't change with the addition of a new block, as describe above. In addition,
       this block can never be less than block_buffer_tail and will always be pushed forward and maintain
-      this requirement when encountered by the Planner::discard_current_block() routine during a cycle.
+      this requirement when encountered by the Planner::release_current_block() routine during a cycle.
 
   NOTE: Since the planner only computes on what's in the planner buffer, some motions with lots of short
   line segments, like G2/3 arcs or complex curves, may seem to move slow. This is because there simply isn't
   enough combined distance traveled in the entire buffer to accelerate up to the nominal speed and then
   decelerate to a complete stop at the end of the buffer, as stated by the guidelines. If this happens and
   becomes an annoyance, there are a few simple solutions: (1) Maximize the machine acceleration. The planner
   will be able to compute higher velocity profiles within the same combined distance. (2) Maximize line
   motion(s) distance per block to a desired tolerance. The more combined distance the planner has to use,
   the faster it can go. (3) Maximize the planner buffer size. This also will increase the combined distance
   for the planner to compute over. It also increases the number of computations the planner has to perform
@@ -987,22 +996,22 @@ void Planner::reverse_pass() {
 
   // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
   // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
   // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
   const block_t *next = nullptr;
   while (block_index != planned_block_index) {
 
     // Perform the reverse pass
     block_t *current = &block_buffer[block_index];
 
-    // Only consider non sync blocks
-    if (!TEST(current->flag, BLOCK_BIT_SYNC_POSITION)) {
+    // Only consider non sync and page blocks
+    if (!TEST(current->flag, BLOCK_BIT_SYNC_POSITION) && !IS_PAGE(current)) {
       reverse_pass_kernel(current, next);
       next = current;
     }
 
     // Advance to the next
     block_index = prev_block_index(block_index);
 
     // The ISR could advance the block_buffer_planned while we were doing the reverse pass.
     // We must try to avoid using an already consumed block as the last one - So follow
     // changes to the pointer and make sure to limit the loop to the currently busy block
@@ -1082,22 +1091,22 @@ void Planner::forward_pass() {
   //  pass will never modify the values at the tail.
   uint8_t block_index = block_buffer_planned;
 
   block_t *block;
   const block_t * previous = nullptr;
   while (block_index != block_buffer_head) {
 
     // Perform the forward pass
     block = &block_buffer[block_index];
 
-    // Skip SYNC blocks
-    if (!TEST(block->flag, BLOCK_BIT_SYNC_POSITION)) {
+    // Skip SYNC and page blocks
+    if (!TEST(block->flag, BLOCK_BIT_SYNC_POSITION) && !IS_PAGE(block)) {
       // If there's no previous block or the previous block is not
       // BUSY (thus, modifiable) run the forward_pass_kernel. Otherwise,
       // the previous block became BUSY, so assume the current block's
       // entry speed can't be altered (since that would also require
       // updating the exit speed of the previous block).
       if (!previous || !stepper.is_block_busy(previous))
         forward_pass_kernel(previous, block, block_index);
       previous = block;
     }
     // Advance to the previous
@@ -1132,22 +1141,22 @@ void Planner::recalculate_trapezoids() {
     head_block_index = prev_index;
   }
 
   // Go from the tail (currently executed block) to the first block, without including it)
   block_t *block = nullptr, *next = nullptr;
   float current_entry_speed = 0.0, next_entry_speed = 0.0;
   while (block_index != head_block_index) {
 
     next = &block_buffer[block_index];
 
-    // Skip sync blocks
-    if (!TEST(next->flag, BLOCK_BIT_SYNC_POSITION)) {
+    // Skip sync and page blocks
+    if (!TEST(next->flag, BLOCK_BIT_SYNC_POSITION) && !IS_PAGE(next)) {
       next_entry_speed = SQRT(next->entry_speed_sqr);
 
       if (block) {
         // Recalculate if current block entry or exit junction speed has changed.
         if (TEST(block->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
 
           // Mark the current block as RECALCULATE, to protect it from the Stepper ISR running it.
           // Note that due to the above condition, there's a chance the current block isn't marked as
           // RECALCULATE yet, but the next one is. That's the reason for the following line.
           SBI(block->flag, BLOCK_BIT_RECALCULATE);
@@ -2710,20 +2719,83 @@ bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, con
       position_cart.set(rx, ry, rz, e);
       return true;
     }
     else
       return false;
   #else
     return buffer_segment(machine, fr_mm_s, extruder, millimeters);
   #endif
 } // buffer_line()
 
+#if ENABLED(DIRECT_STEPPING)
+
+  void Planner::buffer_page(const page_idx_t page_idx, const uint8_t extruder, const uint16_t num_steps) {
+    if (!last_page_step_rate) {
+      kill(GET_TEXT(MSG_BAD_PAGE_SPEED));
+      return;
+    }
+
+    uint8_t next_buffer_head;
+    block_t * const block = get_next_free_block(next_buffer_head);
+
+    block->flag = BLOCK_FLAG_IS_PAGE;
+
+    #if FAN_COUNT > 0
+      FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
+    #endif
+
+    #if EXTRUDERS > 1
+      block->extruder = extruder;
+    #endif
+
+    block->page_idx = page_idx;
+
+    block->step_event_count = num_steps;
+    block->initial_rate =
+      block->final_rate =
+      block->nominal_rate = last_page_step_rate; // steps/s
+
+    block->accelerate_until = 0;
+    block->decelerate_after = block->step_event_count;
+
+    // Will be set to last direction later if directional format.
+    block->direction_bits = 0;
+
+    #define PAGE_UPDATE_DIR(AXIS) \
+      if (!last_page_dir[_AXIS(AXIS)]) SBI(block->direction_bits, _AXIS(AXIS));
+
+    if (!DirectStepping::Config::DIRECTIONAL) {
+      PAGE_UPDATE_DIR(X);
+      PAGE_UPDATE_DIR(Y);
+      PAGE_UPDATE_DIR(Z);
+      PAGE_UPDATE_DIR(E);
+    }
+
+    // If this is the first added movement, reload the delay, otherwise, cancel it.
+    if (block_buffer_head == block_buffer_tail) {
+      // If it was the first queued block, restart the 1st block delivery delay, to
+      // give the planner an opportunity to queue more movements and plan them
+      // As there are no queued movements, the Stepper ISR will not touch this
+      // variable, so there is no risk setting this here (but it MUST be done
+      // before the following line!!)
+      delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
+    }
+
+    // Move buffer head
+    block_buffer_head = next_buffer_head;
+
+    enable_all_steppers();
+    stepper.wake_up();
+  }
+
+#endif // DIRECT_STEPPING
+
 /**
  * Directly set the planner ABC position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * The provided ABC position is in machine units.
  */
 
 void Planner::set_machine_position_mm(const float &a, const float &b, const float &c, const float &e) {
   TERN_(DISTINCT_E_FACTORS, last_extruder = active_extruder);
   TERN_(HAS_POSITION_FLOAT, position_float.set(a, b, c, e));

commit 3381a4ab0322af75124e920e61840c7a753ffadf
Author: XDA-Bam <1209896+XDA-Bam@users.noreply.github.com>
Date:   Mon May 11 08:06:35 2020 +0200

    Fix vector normalization in JD (#17938)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 9c1071c6fb..7d23789df1 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2249,30 +2249,31 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     // Unit vector of previous path line segment
     static xyze_float_t prev_unit_vec;
 
     xyze_float_t unit_vec =
       #if HAS_DIST_MM_ARG
         cart_dist_mm
       #else
         { steps_dist_mm.x, steps_dist_mm.y, steps_dist_mm.z, steps_dist_mm.e }
       #endif
     ;
-    unit_vec *= inverse_millimeters;
 
-    #if IS_CORE && HAS_JUNCTION_DEVIATION
-      /**
-       * On CoreXY the length of the vector [A,B] is SQRT(2) times the length of the head movement vector [X,Y].
-       * So taking Z and E into account, we cannot scale to a unit vector with "inverse_millimeters".
-       * => normalize the complete junction vector
-       */
-      normalize_junction_vector(unit_vec);
-    #endif
+    /**
+     * On CoreXY the length of the vector [A,B] is SQRT(2) times the length of the head movement vector [X,Y].
+     * So taking Z and E into account, we cannot scale to a unit vector with "inverse_millimeters".
+     * => normalize the complete junction vector.
+     * Elsewise, when needed JD factors in the E component
+     */
+    if (ENABLED(IS_CORE) || esteps > 0)
+      normalize_junction_vector(unit_vec);  // Normalize with XYZE components
+    else
+      unit_vec *= inverse_millimeters;      // Use pre-calculated (1 / SQRT(x^2 + y^2 + z^2))
 
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
       float junction_cos_theta = (-prev_unit_vec.x * unit_vec.x) + (-prev_unit_vec.y * unit_vec.y)
                                + (-prev_unit_vec.z * unit_vec.z) + (-prev_unit_vec.e * unit_vec.e);
 
       // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
       if (junction_cos_theta > 0.999999f) {

commit 7a2cc782b406f7e89a0a61d168cc7a5d90835c06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 5 03:09:40 2020 -0500

    Clean up planner modifier methods

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index aec1e48402..9c1071c6fb 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2735,25 +2735,21 @@ void Planner::set_machine_position_mm(const float &a, const float &b, const floa
     //previous_speed.reset();
     buffer_sync_block();
   }
   else
     stepper.set_position(position);
 }
 
 void Planner::set_position_mm(const float &rx, const float &ry, const float &rz, const float &e) {
   xyze_pos_t machine = { rx, ry, rz, e };
   #if HAS_POSITION_MODIFIERS
-    apply_modifiers(machine
-      #if HAS_LEVELING
-        , true
-      #endif
-    );
+    apply_modifiers(machine, true);
   #endif
   #if IS_KINEMATIC
     position_cart.set(rx, ry, rz, e);
     inverse_kinematics(machine);
     set_machine_position_mm(delta.a, delta.b, delta.c, machine.e);
   #else
     set_machine_position_mm(machine);
   #endif
 }
 

commit eeabe66fc49501222fc458f5c298893e4d88ee17
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 5 00:28:39 2020 -0500

    Some distinct E helpers

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 2d68022c10..aec1e48402 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -127,23 +127,22 @@ uint16_t Planner::cleaning_buffer_counter;      // A counter to disable queuing
 uint8_t Planner::delay_before_delivering;       // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
 planner_settings_t Planner::settings;           // Initialized by settings.load()
 
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
 
 float Planner::steps_to_mm[XYZE_N];             // (mm) Millimeters per step
 
 #if HAS_JUNCTION_DEVIATION
   float Planner::junction_deviation_mm;         // (mm) M205 J
-  #if ENABLED(LIN_ADVANCE)
-    float Planner::max_e_jerk                   // Calculated from junction_deviation_mm
-      [TERN(DISTINCT_E_FACTORS, EXTRUDERS, 1)];
+  #if HAS_LINEAR_E_JERK
+    float Planner::max_e_jerk[DISTINCT_E];      // Calculated from junction_deviation_mm
   #endif
 #endif
 
 #if HAS_CLASSIC_JERK
   TERN(HAS_LINEAR_E_JERK, xyz_pos_t, xyze_pos_t) Planner::max_jerk;
 #endif
 
 #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
   bool Planner::abort_on_endstop_hit = false;
 #endif
@@ -2132,21 +2131,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         const float comp = (float)max_acceleration_steps_per_s2[AXIS+INDX] * (float)block->step_event_count; \
         if ((float)accel * (float)block->steps[AXIS] > comp) accel = comp / (float)block->steps[AXIS]; \
       } \
     }while(0)
 
     // Start with print or travel acceleration
     accel = CEIL((esteps ? settings.acceleration : settings.travel_acceleration) * steps_per_mm);
 
     #if ENABLED(LIN_ADVANCE)
 
-      #define MAX_E_JERK(N) TERN(HAS_JUNCTION_DEVIATION, max_e_jerk[E_AXIS_N(N)], max_jerk.e)
+      #define MAX_E_JERK(N) TERN(HAS_LINEAR_E_JERK, max_e_jerk[E_INDEX_N(N)], max_jerk.e)
 
       /**
        *
        * Use LIN_ADVANCE for blocks if all these are true:
        *
        * esteps             : This is a print move, because we checked for A, B, C steps before.
        *
        * extruder_advance_K[active_extruder] : There is an advance factor set for this extruder.
        *
        * de > 0             : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
@@ -2172,38 +2171,32 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           block->use_advance_lead = false;
         else {
           const uint32_t max_accel_steps_per_s2 = MAX_E_JERK(extruder) / (extruder_advance_K[active_extruder] * block->e_D_ratio) * steps_per_mm;
           if (TERN0(LA_DEBUG, accel > max_accel_steps_per_s2))
             SERIAL_ECHOLNPGM("Acceleration limited.");
           NOMORE(accel, max_accel_steps_per_s2);
         }
       }
     #endif
 
-    #if ENABLED(DISTINCT_E_FACTORS)
-      #define ACCEL_IDX extruder
-    #else
-      #define ACCEL_IDX 0
-    #endif
-
     // Limit acceleration per axis
     if (block->step_event_count <= cutoff_long) {
       LIMIT_ACCEL_LONG(A_AXIS, 0);
       LIMIT_ACCEL_LONG(B_AXIS, 0);
       LIMIT_ACCEL_LONG(C_AXIS, 0);
-      LIMIT_ACCEL_LONG(E_AXIS, ACCEL_IDX);
+      LIMIT_ACCEL_LONG(E_AXIS, E_INDEX_N(extruder));
     }
     else {
       LIMIT_ACCEL_FLOAT(A_AXIS, 0);
       LIMIT_ACCEL_FLOAT(B_AXIS, 0);
       LIMIT_ACCEL_FLOAT(C_AXIS, 0);
-      LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
+      LIMIT_ACCEL_FLOAT(E_AXIS, E_INDEX_N(extruder));
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
     block->acceleration_rate = (uint32_t)(accel * (4096.0f * 4096.0f / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
       block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * settings.axis_steps_per_mm[E_AXIS_N(extruder)]);

commit 90e1035e9bcb4dedee41e698a8923c71fbbaf060
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 4 23:07:54 2020 -0500

    Define max_e_jerk as array always

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ee357179c0..2d68022c10 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -123,27 +123,27 @@ volatile uint8_t Planner::block_buffer_head,    // Index of the next block to be
                  Planner::block_buffer_nonbusy, // Index of the first non-busy block
                  Planner::block_buffer_planned, // Index of the optimally planned block
                  Planner::block_buffer_tail;    // Index of the busy block, if any
 uint16_t Planner::cleaning_buffer_counter;      // A counter to disable queuing of blocks
 uint8_t Planner::delay_before_delivering;       // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
 planner_settings_t Planner::settings;           // Initialized by settings.load()
 
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
 
-float Planner::steps_to_mm[XYZE_N];           // (mm) Millimeters per step
+float Planner::steps_to_mm[XYZE_N];             // (mm) Millimeters per step
 
 #if HAS_JUNCTION_DEVIATION
-  float Planner::junction_deviation_mm;       // (mm) M205 J
+  float Planner::junction_deviation_mm;         // (mm) M205 J
   #if ENABLED(LIN_ADVANCE)
-    float Planner::max_e_jerk               // Calculated from junction_deviation_mm
-      TERN_(DISTINCT_E_FACTORS, [EXTRUDERS]);
+    float Planner::max_e_jerk                   // Calculated from junction_deviation_mm
+      [TERN(DISTINCT_E_FACTORS, EXTRUDERS, 1)];
   #endif
 #endif
 
 #if HAS_CLASSIC_JERK
   TERN(HAS_LINEAR_E_JERK, xyz_pos_t, xyze_pos_t) Planner::max_jerk;
 #endif
 
 #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
   bool Planner::abort_on_endstop_hit = false;
 #endif
@@ -2132,29 +2132,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         const float comp = (float)max_acceleration_steps_per_s2[AXIS+INDX] * (float)block->step_event_count; \
         if ((float)accel * (float)block->steps[AXIS] > comp) accel = comp / (float)block->steps[AXIS]; \
       } \
     }while(0)
 
     // Start with print or travel acceleration
     accel = CEIL((esteps ? settings.acceleration : settings.travel_acceleration) * steps_per_mm);
 
     #if ENABLED(LIN_ADVANCE)
 
-      #if HAS_JUNCTION_DEVIATION
-        #if ENABLED(DISTINCT_E_FACTORS)
-          #define MAX_E_JERK max_e_jerk[extruder]
-        #else
-          #define MAX_E_JERK max_e_jerk
-        #endif
-      #else
-        #define MAX_E_JERK max_jerk.e
-      #endif
+      #define MAX_E_JERK(N) TERN(HAS_JUNCTION_DEVIATION, max_e_jerk[E_AXIS_N(N)], max_jerk.e)
 
       /**
        *
        * Use LIN_ADVANCE for blocks if all these are true:
        *
        * esteps             : This is a print move, because we checked for A, B, C steps before.
        *
        * extruder_advance_K[active_extruder] : There is an advance factor set for this extruder.
        *
        * de > 0             : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
@@ -2172,21 +2164,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
                + sq(target_float.y - position_float.y)
                + sq(target_float.z - position_float.z))
           #endif
         ;
 
         // Check for unusual high e_D ratio to detect if a retract move was combined with the last print move due to min. steps per segment. Never execute this with advance!
         // This assumes no one will use a retract length of 0mm < retr_length < ~0.2mm and no one will print 100mm wide lines using 3mm filament or 35mm wide lines using 1.75mm filament.
         if (block->e_D_ratio > 3.0f)
           block->use_advance_lead = false;
         else {
-          const uint32_t max_accel_steps_per_s2 = MAX_E_JERK / (extruder_advance_K[active_extruder] * block->e_D_ratio) * steps_per_mm;
+          const uint32_t max_accel_steps_per_s2 = MAX_E_JERK(extruder) / (extruder_advance_K[active_extruder] * block->e_D_ratio) * steps_per_mm;
           if (TERN0(LA_DEBUG, accel > max_accel_steps_per_s2))
             SERIAL_ECHOLNPGM("Acceleration limited.");
           NOMORE(accel, max_accel_steps_per_s2);
         }
       }
     #endif
 
     #if ENABLED(DISTINCT_E_FACTORS)
       #define ACCEL_IDX extruder
     #else

commit c55475e8e7c7b389b30ca1d154618d73faba52ab
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 4 19:01:54 2020 -0500

    Fix and combine JD condition

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 6d2a0edc31..ee357179c0 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2299,101 +2299,101 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
         // Convert delta vector to unit vector
         xyze_float_t junction_unit_vec = unit_vec - prev_unit_vec;
         normalize_junction_vector(junction_unit_vec);
 
         const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec),
                     sin_theta_d2 = SQRT(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
 
         vmax_junction_sqr = junction_acceleration * junction_deviation_mm * sin_theta_d2 / (1.0f - sin_theta_d2);
 
-        if (block->millimeters < 1) {
-          const float neg = junction_cos_theta < 0 ? -1 : 1,
-                      t = neg * junction_cos_theta;
-
-          // If angle is greater than 135 degrees (octagon), find speed for approximate arc
-          if (t > 0.7071067812f) {
-
-            #if ENABLED(JD_USE_MATH_ACOS)
-
-              #error "TODO: Inline maths with the MCU / FPU."
-
-            #elif ENABLED(JD_USE_LOOKUP_TABLE)
-
-              // Fast acos approximation (max. error +-0.01 rads)
-              // Based on LUT table and linear interpolation
-
-              /**
-               *  // Generate the JD Lookup Table
-               *  constexpr float c = 1.00751317f; // Correction factor to center error around 0
-               *  for (int i = 0; i < jd_lut_count - 1; ++i) {
-               *    const float x0 = (sq(i) - 1) / sq(i),
-               *                y0 = acos(x0) * (i ? c : 1),
-               *                x1 = 0.5 * x0 + 0.5,
-               *                y1 = acos(x1) * c;
-               *    jd_lut_k[i] = (y0 - y1) / (x0 - x1);
-               *    jd_lut_b[i] = (y1 * x0 - y0 * x1) / (x0 - x1);
-               *  }
-               *  jd_lut_k[jd_lut_count - 1] = jd_lut_b[jd_lut_count - 1] = 0;
-               *
-               *  // Compute correction factor (Set c to 1.0f first!)
-               *  float min = INFINITY, max = -min;
-               *  for (float t = 0; t <= 1; t += 0.0003f) {
-               *    const float e = acos(t) / approx(t);
-               *    if (isfinite(e)) {
-               *      if (e < min) min = e;
-               *      if (e > max) max = e;
-               *    }
-               *  }
-               *  fprintf(stderr, "%.9gf, ", (min + max) / 2);
-               */
-              static constexpr int16_t  jd_lut_count = 15;
-              static constexpr uint16_t jd_lut_tll   = 1 << jd_lut_count;
-              static constexpr int16_t  jd_lut_tll0  = __builtin_clz(jd_lut_tll) + 1; // i.e., 16 - jd_lut_count
-              static constexpr float jd_lut_k[jd_lut_count] PROGMEM = {
-                -1.03146219f, -1.30760407f, -1.75205469f, -2.41705418f, -3.37768555f,
-                -4.74888229f, -6.69648552f, -9.45659828f, -13.3640289f, -18.8927879f,
-                -26.7136307f, -37.7754059f, -53.4200745f, -75.5457306f,   0.0f };
-              static constexpr float jd_lut_b[jd_lut_count] PROGMEM = {
-                1.57079637f, 1.70886743f, 2.04220533f, 2.62408018f, 3.52467203f,
-                4.85301876f, 6.77019119f, 9.50873947f, 13.4009094f, 18.9188652f,
-                26.7320709f, 37.7884521f, 53.4292908f, 75.5522461f,  0.0f };
-
-              const int16_t idx = (t == 0.0f) ? 0 : __builtin_clz(uint16_t((1.0f - t) * jd_lut_tll)) - jd_lut_tll0;
-
-              float junction_theta = t * pgm_read_float(&jd_lut_k[idx]) + pgm_read_float(&jd_lut_b[idx]);
-              if (neg > 0) junction_theta = RADIANS(180) - junction_theta;
-
-            #else
-
-              // Fast acos(-t) approximation (max. error +-0.033rad = 1.89¬∞)
-              // Based on MinMax polynomial published by W. Randolph Franklin, see
-              // https://wrf.ecse.rpi.edu/Research/Short_Notes/arcsin/onlyelem.html
-              //  acos( t) = pi / 2 - asin(x)
-              //  acos(-t) = pi - acos(t) ... pi / 2 + asin(x)
-
-              const float asinx =       0.032843707f
-                                + t * (-1.451838349f
-                                + t * ( 29.66153956f
-                                + t * (-131.1123477f
-                                + t * ( 262.8130562f
-                                + t * (-242.7199627f
-                                + t * ( 84.31466202f ) ))))),
-                          junction_theta = RADIANS(90) + neg * asinx; // acos(-t)
-
-              // NOTE: junction_theta bottoms out at 0.033 which avoids divide by 0.
+        // For small moves with >135¬∞ junction (octagon) find speed for approximate arc
+        if (block->millimeters < 1 && junction_cos_theta < -0.7071067812f) {
+
+          #if ENABLED(JD_USE_MATH_ACOS)
+
+            #error "TODO: Inline maths with the MCU / FPU."
+
+          #elif ENABLED(JD_USE_LOOKUP_TABLE)
+
+            // Fast acos approximation (max. error +-0.01 rads)
+            // Based on LUT table and linear interpolation
+
+            /**
+             *  // Generate the JD Lookup Table
+             *  constexpr float c = 1.00751317f; // Correction factor to center error around 0
+             *  for (int i = 0; i < jd_lut_count - 1; ++i) {
+             *    const float x0 = (sq(i) - 1) / sq(i),
+             *                y0 = acos(x0) * (i ? c : 1),
+             *                x1 = 0.5 * x0 + 0.5,
+             *                y1 = acos(x1) * c;
+             *    jd_lut_k[i] = (y0 - y1) / (x0 - x1);
+             *    jd_lut_b[i] = (y1 * x0 - y0 * x1) / (x0 - x1);
+             *  }
+             *  jd_lut_k[jd_lut_count - 1] = jd_lut_b[jd_lut_count - 1] = 0;
+             *
+             *  // Compute correction factor (Set c to 1.0f first!)
+             *  float min = INFINITY, max = -min;
+             *  for (float t = 0; t <= 1; t += 0.0003f) {
+             *    const float e = acos(t) / approx(t);
+             *    if (isfinite(e)) {
+             *      if (e < min) min = e;
+             *      if (e > max) max = e;
+             *    }
+             *  }
+             *  fprintf(stderr, "%.9gf, ", (min + max) / 2);
+             */
+            static constexpr int16_t  jd_lut_count = 15;
+            static constexpr uint16_t jd_lut_tll   = 1 << jd_lut_count;
+            static constexpr int16_t  jd_lut_tll0  = __builtin_clz(jd_lut_tll) + 1; // i.e., 16 - jd_lut_count
+            static constexpr float jd_lut_k[jd_lut_count] PROGMEM = {
+              -1.03146219f, -1.30760407f, -1.75205469f, -2.41705418f, -3.37768555f,
+              -4.74888229f, -6.69648552f, -9.45659828f, -13.3640289f, -18.8927879f,
+              -26.7136307f, -37.7754059f, -53.4200745f, -75.5457306f,   0.0f };
+            static constexpr float jd_lut_b[jd_lut_count] PROGMEM = {
+              1.57079637f, 1.70886743f, 2.04220533f, 2.62408018f, 3.52467203f,
+              4.85301876f, 6.77019119f, 9.50873947f, 13.4009094f, 18.9188652f,
+              26.7320709f, 37.7884521f, 53.4292908f, 75.5522461f,  0.0f };
+
+            const float neg = junction_cos_theta < 0 ? -1 : 1,
+                        t = neg * junction_cos_theta;
+
+            const int16_t idx = (t == 0.0f) ? 0 : __builtin_clz(uint16_t((1.0f - t) * jd_lut_tll)) - jd_lut_tll0;
+
+            float junction_theta = t * pgm_read_float(&jd_lut_k[idx]) + pgm_read_float(&jd_lut_b[idx]);
+            if (neg > 0) junction_theta = RADIANS(180) - junction_theta; // acos(-t)
 
-            #endif
+          #else
 
-            const float limit_sqr = (block->millimeters * junction_acceleration) / junction_theta;
-            NOMORE(vmax_junction_sqr, limit_sqr);
-          }
+            // Fast acos(-t) approximation (max. error +-0.033rad = 1.89¬∞)
+            // Based on MinMax polynomial published by W. Randolph Franklin, see
+            // https://wrf.ecse.rpi.edu/Research/Short_Notes/arcsin/onlyelem.html
+            //  acos( t) = pi / 2 - asin(x)
+            //  acos(-t) = pi - acos(t) ... pi / 2 + asin(x)
+
+            const float neg = junction_cos_theta < 0 ? -1 : 1,
+                        t = neg * junction_cos_theta,
+                        asinx =       0.032843707f
+                              + t * (-1.451838349f
+                              + t * ( 29.66153956f
+                              + t * (-131.1123477f
+                              + t * ( 262.8130562f
+                              + t * (-242.7199627f
+                              + t * ( 84.31466202f ) ))))),
+                        junction_theta = RADIANS(90) + neg * asinx; // acos(-t)
+
+            // NOTE: junction_theta bottoms out at 0.033 which avoids divide by 0.
+
+          #endif
+
+          const float limit_sqr = (block->millimeters * junction_acceleration) / junction_theta;
+          NOMORE(vmax_junction_sqr, limit_sqr);
         }
       }
 
       // Get the lowest speed
       vmax_junction_sqr = _MIN(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
       vmax_junction_sqr = 0;
 
     prev_unit_vec = unit_vec;

commit b8947ac8a5182b6b54165fb6ddc4177efb32091a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 4 15:13:37 2020 -0500

    More explicit junction/jerk math

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index bb9e7b92fe..6d2a0edc31 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2297,21 +2297,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       else {
         NOLESS(junction_cos_theta, -0.999999f); // Check for numerical round-off to avoid divide by zero.
 
         // Convert delta vector to unit vector
         xyze_float_t junction_unit_vec = unit_vec - prev_unit_vec;
         normalize_junction_vector(junction_unit_vec);
 
         const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec),
                     sin_theta_d2 = SQRT(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
 
-        vmax_junction_sqr = JUNC_SQ(junction_acceleration, sin_theta_d2);
+        vmax_junction_sqr = junction_acceleration * junction_deviation_mm * sin_theta_d2 / (1.0f - sin_theta_d2);
 
         if (block->millimeters < 1) {
           const float neg = junction_cos_theta < 0 ? -1 : 1,
                       t = neg * junction_cos_theta;
 
           // If angle is greater than 135 degrees (octagon), find speed for approximate arc
           if (t > 0.7071067812f) {
 
             #if ENABLED(JD_USE_MATH_ACOS)
 
@@ -2333,22 +2333,22 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
                *    jd_lut_k[i] = (y0 - y1) / (x0 - x1);
                *    jd_lut_b[i] = (y1 * x0 - y0 * x1) / (x0 - x1);
                *  }
                *  jd_lut_k[jd_lut_count - 1] = jd_lut_b[jd_lut_count - 1] = 0;
                *
                *  // Compute correction factor (Set c to 1.0f first!)
                *  float min = INFINITY, max = -min;
                *  for (float t = 0; t <= 1; t += 0.0003f) {
                *    const float e = acos(t) / approx(t);
                *    if (isfinite(e)) {
-               *      NOMORE(min, e);
-               *      NOLESS(max, e);
+               *      if (e < min) min = e;
+               *      if (e > max) max = e;
                *    }
                *  }
                *  fprintf(stderr, "%.9gf, ", (min + max) / 2);
                */
               static constexpr int16_t  jd_lut_count = 15;
               static constexpr uint16_t jd_lut_tll   = 1 << jd_lut_count;
               static constexpr int16_t  jd_lut_tll0  = __builtin_clz(jd_lut_tll) + 1; // i.e., 16 - jd_lut_count
               static constexpr float jd_lut_k[jd_lut_count] PROGMEM = {
                 -1.03146219f, -1.30760407f, -1.75205469f, -2.41705418f, -3.37768555f,
                 -4.74888229f, -6.69648552f, -9.45659828f, -13.3640289f, -18.8927879f,

commit ebe8f2c605b6d07d067db3e013cb26741bf1e207
Author: ≈†tƒõp√°n Daleck√Ω <36531759+daleckystepan@users.noreply.github.com>
Date:   Mon May 4 21:39:51 2020 +0200

    Fix acosx condition (#17846)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 54714715f2..bb9e7b92fe 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2304,21 +2304,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec),
                     sin_theta_d2 = SQRT(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
 
         vmax_junction_sqr = JUNC_SQ(junction_acceleration, sin_theta_d2);
 
         if (block->millimeters < 1) {
           const float neg = junction_cos_theta < 0 ? -1 : 1,
                       t = neg * junction_cos_theta;
 
           // If angle is greater than 135 degrees (octagon), find speed for approximate arc
-          if (t < -0.7071067812f) {
+          if (t > 0.7071067812f) {
 
             #if ENABLED(JD_USE_MATH_ACOS)
 
               #error "TODO: Inline maths with the MCU / FPU."
 
             #elif ENABLED(JD_USE_LOOKUP_TABLE)
 
               // Fast acos approximation (max. error +-0.01 rads)
               // Based on LUT table and linear interpolation
 
@@ -2351,21 +2351,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
               static constexpr int16_t  jd_lut_tll0  = __builtin_clz(jd_lut_tll) + 1; // i.e., 16 - jd_lut_count
               static constexpr float jd_lut_k[jd_lut_count] PROGMEM = {
                 -1.03146219f, -1.30760407f, -1.75205469f, -2.41705418f, -3.37768555f,
                 -4.74888229f, -6.69648552f, -9.45659828f, -13.3640289f, -18.8927879f,
                 -26.7136307f, -37.7754059f, -53.4200745f, -75.5457306f,   0.0f };
               static constexpr float jd_lut_b[jd_lut_count] PROGMEM = {
                 1.57079637f, 1.70886743f, 2.04220533f, 2.62408018f, 3.52467203f,
                 4.85301876f, 6.77019119f, 9.50873947f, 13.4009094f, 18.9188652f,
                 26.7320709f, 37.7884521f, 53.4292908f, 75.5522461f,  0.0f };
 
-              const int16_t idx = (t == 0.0f) ? 0 : __builtin_clz(int16_t((1.0f - t) * jd_lut_tll)) - jd_lut_tll0;
+              const int16_t idx = (t == 0.0f) ? 0 : __builtin_clz(uint16_t((1.0f - t) * jd_lut_tll)) - jd_lut_tll0;
 
               float junction_theta = t * pgm_read_float(&jd_lut_k[idx]) + pgm_read_float(&jd_lut_b[idx]);
               if (neg > 0) junction_theta = RADIANS(180) - junction_theta;
 
             #else
 
               // Fast acos(-t) approximation (max. error +-0.033rad = 1.89¬∞)
               // Based on MinMax polynomial published by W. Randolph Franklin, see
               // https://wrf.ecse.rpi.edu/Research/Short_Notes/arcsin/onlyelem.html
               //  acos( t) = pi / 2 - asin(x)

commit 0c68794fa920838c289373314c9e1b172bbfa676
Author: ≈†tƒõp√°n Daleck√Ω <36531759+daleckystepan@users.noreply.github.com>
Date:   Sun May 3 06:59:09 2020 +0200

    Improve JD acosx implementation (#17817)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 117a8b6fda..54714715f2 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2297,42 +2297,101 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       else {
         NOLESS(junction_cos_theta, -0.999999f); // Check for numerical round-off to avoid divide by zero.
 
         // Convert delta vector to unit vector
         xyze_float_t junction_unit_vec = unit_vec - prev_unit_vec;
         normalize_junction_vector(junction_unit_vec);
 
         const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec),
                     sin_theta_d2 = SQRT(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
 
-        vmax_junction_sqr = (junction_acceleration * junction_deviation_mm * sin_theta_d2) / (1.0f - sin_theta_d2);
+        vmax_junction_sqr = JUNC_SQ(junction_acceleration, sin_theta_d2);
 
         if (block->millimeters < 1) {
-          // Fast acos approximation (max. error +-0.033 rads)
-          // Based on MinMax polynomial published by W. Randolph Franklin, see
-          // https://wrf.ecse.rpi.edu/Research/Short_Notes/arcsin/onlyelem.html
-          // (acos(x) = pi / 2 - asin(x))
-
           const float neg = junction_cos_theta < 0 ? -1 : 1,
-                      t = neg * junction_cos_theta,
-                      asinx =       0.032843707f
-                            + t * (-1.451838349f
-                            + t * ( 29.66153956f
-                            + t * (-131.1123477f
-                            + t * ( 262.8130562f
-                            + t * (-242.7199627f + t * 84.31466202f) )))),
-                      junction_theta = RADIANS(90) - neg * asinx;
+                      t = neg * junction_cos_theta;
 
           // If angle is greater than 135 degrees (octagon), find speed for approximate arc
-          if (junction_theta > RADIANS(135)) {
-            // NOTE: MinMax acos approximation and thereby also junction_theta top out at pi-0.033, which avoids division by 0
-            const float limit_sqr = block->millimeters / (RADIANS(180) - junction_theta) * junction_acceleration;
+          if (t < -0.7071067812f) {
+
+            #if ENABLED(JD_USE_MATH_ACOS)
+
+              #error "TODO: Inline maths with the MCU / FPU."
+
+            #elif ENABLED(JD_USE_LOOKUP_TABLE)
+
+              // Fast acos approximation (max. error +-0.01 rads)
+              // Based on LUT table and linear interpolation
+
+              /**
+               *  // Generate the JD Lookup Table
+               *  constexpr float c = 1.00751317f; // Correction factor to center error around 0
+               *  for (int i = 0; i < jd_lut_count - 1; ++i) {
+               *    const float x0 = (sq(i) - 1) / sq(i),
+               *                y0 = acos(x0) * (i ? c : 1),
+               *                x1 = 0.5 * x0 + 0.5,
+               *                y1 = acos(x1) * c;
+               *    jd_lut_k[i] = (y0 - y1) / (x0 - x1);
+               *    jd_lut_b[i] = (y1 * x0 - y0 * x1) / (x0 - x1);
+               *  }
+               *  jd_lut_k[jd_lut_count - 1] = jd_lut_b[jd_lut_count - 1] = 0;
+               *
+               *  // Compute correction factor (Set c to 1.0f first!)
+               *  float min = INFINITY, max = -min;
+               *  for (float t = 0; t <= 1; t += 0.0003f) {
+               *    const float e = acos(t) / approx(t);
+               *    if (isfinite(e)) {
+               *      NOMORE(min, e);
+               *      NOLESS(max, e);
+               *    }
+               *  }
+               *  fprintf(stderr, "%.9gf, ", (min + max) / 2);
+               */
+              static constexpr int16_t  jd_lut_count = 15;
+              static constexpr uint16_t jd_lut_tll   = 1 << jd_lut_count;
+              static constexpr int16_t  jd_lut_tll0  = __builtin_clz(jd_lut_tll) + 1; // i.e., 16 - jd_lut_count
+              static constexpr float jd_lut_k[jd_lut_count] PROGMEM = {
+                -1.03146219f, -1.30760407f, -1.75205469f, -2.41705418f, -3.37768555f,
+                -4.74888229f, -6.69648552f, -9.45659828f, -13.3640289f, -18.8927879f,
+                -26.7136307f, -37.7754059f, -53.4200745f, -75.5457306f,   0.0f };
+              static constexpr float jd_lut_b[jd_lut_count] PROGMEM = {
+                1.57079637f, 1.70886743f, 2.04220533f, 2.62408018f, 3.52467203f,
+                4.85301876f, 6.77019119f, 9.50873947f, 13.4009094f, 18.9188652f,
+                26.7320709f, 37.7884521f, 53.4292908f, 75.5522461f,  0.0f };
+
+              const int16_t idx = (t == 0.0f) ? 0 : __builtin_clz(int16_t((1.0f - t) * jd_lut_tll)) - jd_lut_tll0;
+
+              float junction_theta = t * pgm_read_float(&jd_lut_k[idx]) + pgm_read_float(&jd_lut_b[idx]);
+              if (neg > 0) junction_theta = RADIANS(180) - junction_theta;
+
+            #else
+
+              // Fast acos(-t) approximation (max. error +-0.033rad = 1.89¬∞)
+              // Based on MinMax polynomial published by W. Randolph Franklin, see
+              // https://wrf.ecse.rpi.edu/Research/Short_Notes/arcsin/onlyelem.html
+              //  acos( t) = pi / 2 - asin(x)
+              //  acos(-t) = pi - acos(t) ... pi / 2 + asin(x)
+
+              const float asinx =       0.032843707f
+                                + t * (-1.451838349f
+                                + t * ( 29.66153956f
+                                + t * (-131.1123477f
+                                + t * ( 262.8130562f
+                                + t * (-242.7199627f
+                                + t * ( 84.31466202f ) ))))),
+                          junction_theta = RADIANS(90) + neg * asinx; // acos(-t)
+
+              // NOTE: junction_theta bottoms out at 0.033 which avoids divide by 0.
+
+            #endif
+
+            const float limit_sqr = (block->millimeters * junction_acceleration) / junction_theta;
             NOMORE(vmax_junction_sqr, limit_sqr);
           }
         }
       }
 
       // Get the lowest speed
       vmax_junction_sqr = _MIN(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
       vmax_junction_sqr = 0;
@@ -2356,25 +2415,24 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
      * https://github.com/prusa3d/Prusa-Firmware
      */
     CACHED_SQRT(nominal_speed, block->nominal_speed_sqr);
 
     // Exit speed limited by a jerk to full halt of a previous last segment
     static float previous_safe_speed;
 
     // Start with a safe speed (from which the machine may halt to stop immediately).
     float safe_speed = nominal_speed;
 
-    #ifdef TRAVEL_EXTRA_XYJERK
-      const float extra_xyjerk = (de <= 0) ? TRAVEL_EXTRA_XYJERK : 0;
-    #else
-      constexpr float extra_xyjerk = 0;
+    #ifndef TRAVEL_EXTRA_XYJERK
+      #define TRAVEL_EXTRA_XYJERK 0
     #endif
+    const float extra_xyjerk = (de <= 0) ? TRAVEL_EXTRA_XYJERK : 0;
 
     uint8_t limited = 0;
     TERN(HAS_LINEAR_E_JERK, LOOP_XYZ, LOOP_XYZE)(i) {
       const float jerk = ABS(current_speed[i]),   // cs : Starting from zero, change in speed for this axis
                   maxj = (max_jerk[i] + (i == X_AXIS || i == Y_AXIS ? extra_xyjerk : 0.0f)); // mj : The max jerk setting for this axis
       if (jerk > maxj) {                          // cs > mj : New current speed too fast?
         if (limited) {                            // limited already?
           const float mjerk = nominal_speed * maxj; // ns*mj
           if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk; // ns*mj/cs
         }

commit 2c959123e5972920bfb40ac519bfaa5b0b7c6d67
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 28 04:31:59 2020 -0500

    Clean up whitespace

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 4e675f075d..117a8b6fda 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2855,21 +2855,20 @@ void Planner::set_max_jerk(const AxisEnum axis, float targetValue) {
       // Reenable Stepper ISR
       if (was_enabled) stepper.wake_up();
     #endif
   }
 
 #endif
 
 #if ENABLED(AUTOTEMP)
 
 void Planner::autotemp_update() {
-  
   #if ENABLED(AUTOTEMP_PROPORTIONAL)
     const int16_t target = thermalManager.degTargetHotend(active_extruder);
     autotemp_min = target + AUTOTEMP_MIN_P;
     autotemp_max = target + AUTOTEMP_MAX_P;
   #endif
   autotemp_factor = TERN(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P, 0);
   autotemp_enabled = autotemp_factor != 0;
 }
 
   void Planner::autotemp_M104_M109() {

commit 89b17b54637200838e52ae39a9e4b23f3c2f8d35
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Tue Apr 28 07:21:23 2020 +0200

    Followup fixes for singlenozzle, etc. (#17712)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ad9dffe4ea..4e675f075d 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2854,20 +2854,31 @@ void Planner::set_max_jerk(const AxisEnum axis, float targetValue) {
     #ifdef __AVR__
       // Reenable Stepper ISR
       if (was_enabled) stepper.wake_up();
     #endif
   }
 
 #endif
 
 #if ENABLED(AUTOTEMP)
 
+void Planner::autotemp_update() {
+  
+  #if ENABLED(AUTOTEMP_PROPORTIONAL)
+    const int16_t target = thermalManager.degTargetHotend(active_extruder);
+    autotemp_min = target + AUTOTEMP_MIN_P;
+    autotemp_max = target + AUTOTEMP_MAX_P;
+  #endif
+  autotemp_factor = TERN(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P, 0);
+  autotemp_enabled = autotemp_factor != 0;
+}
+
   void Planner::autotemp_M104_M109() {
 
     #if ENABLED(AUTOTEMP_PROPORTIONAL)
       const int16_t target = thermalManager.degTargetHotend(active_extruder);
       autotemp_min = target + AUTOTEMP_MIN_P;
       autotemp_max = target + AUTOTEMP_MAX_P;
     #endif
 
     if (parser.seenval('S')) autotemp_min = parser.value_celsius();
     if (parser.seenval('B')) autotemp_max = parser.value_celsius();

commit 5ae45bab1826fc9c743d62a52f55cea5fe124b6b
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Mon Apr 27 12:59:52 2020 +0200

    Adjustable XY_FREQUENCY_LIMIT (#17583)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 0643ba1cb3..ad9dffe4ea 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -106,21 +106,21 @@
 #if HAS_CUTTER
   #include "../feature/spindle_laser.h"
 #endif
 
 // Delay for delivery of first block to the stepper ISR, if the queue contains 2 or
 // fewer movements. The delay is measured in milliseconds, and must be less than 250ms
 #define BLOCK_DELAY_FOR_1ST_MOVE 100
 
 Planner planner;
 
-  // public:
+// public:
 
 /**
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head,    // Index of the next block to be pushed
                  Planner::block_buffer_nonbusy, // Index of the first non-busy block
                  Planner::block_buffer_planned, // Index of the optimally planned block
                  Planner::block_buffer_tail;    // Index of the busy block, if any
 uint16_t Planner::cleaning_buffer_counter;      // A counter to disable queuing of blocks
@@ -193,24 +193,23 @@ xyze_long_t Planner::position{0};
 uint32_t Planner::cutoff_long;
 
 xyze_float_t Planner::previous_speed;
 float Planner::previous_nominal_speed_sqr;
 
 #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
   uint8_t Planner::g_uc_extruder_last_move[EXTRUDERS] = { 0 };
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
-  // Old direction bits. Used for speed calculations
-  unsigned char Planner::old_direction_bits = 0;
-  // Segment times (in ¬µs). Used for speed calculations
-  xy_ulong_t Planner::axis_segment_time_us[3] = { { MAX_FREQ_TIME_US + 1, MAX_FREQ_TIME_US + 1 } };
+  int8_t Planner::xy_freq_limit_hz = XY_FREQUENCY_LIMIT;
+  float Planner::xy_freq_min_speed_factor = (XY_FREQUENCY_MIN_PERCENT) * 0.01f;
+  int32_t Planner::xy_freq_min_interval_us = LROUND(1000000.0 / (XY_FREQUENCY_LIMIT));
 #endif
 
 #if ENABLED(LIN_ADVANCE)
   float Planner::extruder_advance_K[EXTRUDERS]; // Initialized by settings.load()
 #endif
 
 #if HAS_POSITION_FLOAT
   xyze_pos_t Planner::position_float; // Needed for accurate maths. Steps cannot be used!
 #endif
 
@@ -1999,31 +1998,32 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   // Calculate inverse time for this move. No divide by zero due to previous checks.
   // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   float inverse_secs = fr_mm_s * inverse_millimeters;
 
   // Get the number of non busy movements in queue (non busy means that they can be altered)
   const uint8_t moves_queued = nonbusy_movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if EITHER(SLOWDOWN, ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time im micro seconds
-    uint32_t segment_time_us = LROUND(1000000.0f / inverse_secs);
+    int32_t segment_time_us = LROUND(1000000.0f / inverse_secs);
   #endif
 
   #if ENABLED(SLOWDOWN)
     #ifndef SLOWDOWN_DIVISOR
       #define SLOWDOWN_DIVISOR 2
     #endif
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / (SLOWDOWN_DIVISOR) - 1)) {
-      if (segment_time_us < settings.min_segment_time_us) {
-        // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
-        const uint32_t nst = segment_time_us + LROUND(2 * (settings.min_segment_time_us - segment_time_us) / moves_queued);
+      const int32_t time_diff = settings.min_segment_time_us - segment_time_us;
+      if (time_diff > 0) {
+        // Buffer is draining so add extra time. The amount of time added increases if the buffer is still emptied more.
+        const int32_t nst = segment_time_us + LROUND(2 * time_diff / moves_queued);
         inverse_secs = 1000000.0f / nst;
         #if defined(XY_FREQUENCY_LIMIT) || HAS_SPI_LCD
           segment_time_us = nst;
         #endif
       }
     }
   #endif
 
   #if HAS_SPI_LCD
     // Protect the access to the position.
@@ -2065,56 +2065,50 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         if (mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)
           current_speed.e *= MIXING_STEPPERS;
       #endif
       const feedRate_t cs = ABS(current_speed.e),
                    max_fr = settings.max_feedrate_mm_s[E_AXIS_N(extruder)]
                             * TERN(HAS_MIXER_SYNC_CHANNEL, MIXING_STEPPERS, 1);
       if (cs > max_fr) NOMORE(speed_factor, max_fr / cs);
     }
   #endif
 
-  // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT
 
-    // Check and limit the xy direction change frequency
-    const unsigned char direction_change = block->direction_bits ^ old_direction_bits;
-    old_direction_bits = block->direction_bits;
-    segment_time_us = LROUND((float)segment_time_us / speed_factor);
-
-    uint32_t xs0 = axis_segment_time_us[0].x,
-             xs1 = axis_segment_time_us[1].x,
-             xs2 = axis_segment_time_us[2].x,
-             ys0 = axis_segment_time_us[0].y,
-             ys1 = axis_segment_time_us[1].y,
-             ys2 = axis_segment_time_us[2].y;
-
-    if (TEST(direction_change, X_AXIS)) {
-      xs2 = axis_segment_time_us[2].x = xs1;
-      xs1 = axis_segment_time_us[1].x = xs0;
-      xs0 = 0;
-    }
-    xs0 = axis_segment_time_us[0].x = xs0 + segment_time_us;
+    static uint8_t old_direction_bits; // = 0
 
-    if (TEST(direction_change, Y_AXIS)) {
-      ys2 = axis_segment_time_us[2].y = axis_segment_time_us[1].y;
-      ys1 = axis_segment_time_us[1].y = axis_segment_time_us[0].y;
-      ys0 = 0;
-    }
-    ys0 = axis_segment_time_us[0].y = ys0 + segment_time_us;
-
-    const uint32_t max_x_segment_time = _MAX(xs0, xs1, xs2),
-                   max_y_segment_time = _MAX(ys0, ys1, ys2),
-                   min_xy_segment_time = _MIN(max_x_segment_time, max_y_segment_time);
-    if (min_xy_segment_time < MAX_FREQ_TIME_US) {
-      const float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME_US);
-      NOMORE(speed_factor, low_sf);
+    if (xy_freq_limit_hz) {
+      // Check and limit the xy direction change frequency
+      const uint8_t direction_change = block->direction_bits ^ old_direction_bits;
+      old_direction_bits = block->direction_bits;
+      segment_time_us = LROUND(float(segment_time_us) / speed_factor);
+
+      static int32_t xs0, xs1, xs2, ys0, ys1, ys2;
+      if (segment_time_us > xy_freq_min_interval_us)
+        xs2 = xs1 = ys2 = ys1 = xy_freq_min_interval_us;
+      else {
+        xs2 = xs1; xs1 = xs0;
+        ys2 = ys1; ys1 = ys0;
+      }
+      xs0 = TEST(direction_change, X_AXIS) ? segment_time_us : xy_freq_min_interval_us;
+      ys0 = TEST(direction_change, Y_AXIS) ? segment_time_us : xy_freq_min_interval_us;
+
+      if (segment_time_us < xy_freq_min_interval_us) {
+        const int32_t least_xy_segment_time = _MIN(_MAX(xs0, xs1, xs2), _MAX(ys0, ys1, ys2));
+        if (least_xy_segment_time < xy_freq_min_interval_us) {
+          float freq_xy_feedrate = (speed_factor * least_xy_segment_time) / xy_freq_min_interval_us;
+          NOLESS(freq_xy_feedrate, xy_freq_min_speed_factor);
+          NOMORE(speed_factor, freq_xy_feedrate);
+        }
+      }
     }
+
   #endif // XY_FREQUENCY_LIMIT
 
   // Correct the speed
   if (speed_factor < 1.0f) {
     current_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
     block->nominal_speed_sqr = block->nominal_speed_sqr * sq(speed_factor);
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
@@ -2825,33 +2819,33 @@ void Planner::set_max_jerk(const AxisEnum axis, float targetValue) {
 
 #if HAS_SPI_LCD
 
   uint16_t Planner::block_buffer_runtime() {
     #ifdef __AVR__
       // Protect the access to the variable. Only required for AVR, as
       //  any 32bit CPU offers atomic access to 32bit variables
       const bool was_enabled = stepper.suspend();
     #endif
 
-    millis_t bbru = block_buffer_runtime_us;
+    uint32_t bbru = block_buffer_runtime_us;
 
     #ifdef __AVR__
       // Reenable Stepper ISR
       if (was_enabled) stepper.wake_up();
     #endif
 
     // To translate ¬µs to ms a division by 1000 would be required.
     // We introduce 2.4% error here by dividing by 1024.
     // Doesn't matter because block_buffer_runtime_us is already too small an estimation.
     bbru >>= 10;
     // limit to about a minute.
-    NOMORE(bbru, 0xFFFFul);
+    NOMORE(bbru, 0x0000FFFFUL);
     return bbru;
   }
 
   void Planner::clear_block_buffer_runtime() {
     #ifdef __AVR__
       // Protect the access to the variable. Only required for AVR, as
       //  any 32bit CPU offers atomic access to 32bit variables
       const bool was_enabled = stepper.suspend();
     #endif
 

commit 8b3c7dda755ebce5bd57a7ce52891a137ea12b35
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 04:41:18 2020 -0500

    Add HAS_FAN and others

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index b7dc639246..0643ba1cb3 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1257,61 +1257,61 @@ void Planner::recalculate() {
 
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
 
   #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
     xyze_bool_t axis_active = { false };
   #endif
 
-  #if FAN_COUNT > 0
+  #if HAS_FAN
     uint8_t tail_fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
     #endif
     #if HAS_HEATER_2
       uint8_t tail_e_to_p_pressure;
     #endif
   #endif
 
   if (has_blocks_queued()) {
 
-    #if FAN_COUNT > 0 || ENABLED(BARICUDA)
+    #if HAS_FAN || ENABLED(BARICUDA)
       block_t *block = &block_buffer[block_buffer_tail];
     #endif
 
-    #if FAN_COUNT > 0
+    #if HAS_FAN
       FANS_LOOP(i)
         tail_fan_speed[i] = thermalManager.scaledFanSpeed(i, block->fan_speed[i]);
     #endif
 
     #if ENABLED(BARICUDA)
       TERN_(HAS_HEATER_1, tail_valve_pressure = block->valve_pressure);
       TERN_(HAS_HEATER_2, tail_e_to_p_pressure = block->e_to_p_pressure);
     #endif
 
     #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
       for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
         block_t *block = &block_buffer[b];
         LOOP_XYZE(i) if (block->steps[i]) axis_active[i] = true;
       }
     #endif
   }
   else {
 
     TERN_(HAS_CUTTER, cutter.refresh());
 
-    #if FAN_COUNT > 0
+    #if HAS_FAN
       FANS_LOOP(i)
         tail_fan_speed[i] = thermalManager.scaledFanSpeed(i);
     #endif
 
     #if ENABLED(BARICUDA)
       TERN_(HAS_HEATER_1, tail_valve_pressure = baricuda_valve_pressure);
       TERN_(HAS_HEATER_2, tail_e_to_p_pressure = baricuda_e_to_p_pressure);
     #endif
   }
 
@@ -1319,21 +1319,21 @@ void Planner::check_axes_activity() {
   // Disable inactive axes
   //
   if (TERN0(DISABLE_X, !axis_active.x)) DISABLE_AXIS_X();
   if (TERN0(DISABLE_Y, !axis_active.y)) DISABLE_AXIS_Y();
   if (TERN0(DISABLE_Z, !axis_active.z)) DISABLE_AXIS_Z();
   if (TERN0(DISABLE_E, !axis_active.e)) disable_e_steppers();
 
   //
   // Update Fan speeds
   //
-  #if FAN_COUNT > 0
+  #if HAS_FAN
 
     #if FAN_KICKSTART_TIME > 0
       static millis_t fan_kick_end[FAN_COUNT] = { 0 };
       #define KICKSTART_FAN(f)                         \
         if (tail_fan_speed[f]) {                       \
           millis_t ms = millis();                      \
           if (fan_kick_end[f] == 0) {                  \
             fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \
             tail_fan_speed[f] = 255;                   \
           } else if (PENDING(ms, fan_kick_end[f]))     \
@@ -1359,21 +1359,21 @@ void Planner::check_axes_activity() {
     #define FAN_SET(F) do{ KICKSTART_FAN(F); _FAN_SET(F); }while(0)
 
     TERN_(HAS_FAN0, FAN_SET(0));
     TERN_(HAS_FAN1, FAN_SET(1));
     TERN_(HAS_FAN2, FAN_SET(2));
     TERN_(HAS_FAN3, FAN_SET(3));
     TERN_(HAS_FAN4, FAN_SET(4));
     TERN_(HAS_FAN5, FAN_SET(5));
     TERN_(HAS_FAN6, FAN_SET(6));
     TERN_(HAS_FAN7, FAN_SET(7));
-  #endif // FAN_COUNT > 0
+  #endif // HAS_FAN
 
   TERN_(AUTOTEMP, getHighESpeed());
 
   #if ENABLED(BARICUDA)
     TERN_(HAS_HEATER_1, analogWrite(pin_t(HEATER_1_PIN), tail_valve_pressure));
     TERN_(HAS_HEATER_2, analogWrite(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
   #endif
 }
 
 #if DISABLED(NO_VOLUMETRICS)
@@ -1899,21 +1899,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   #if ENABLED(MIXING_EXTRUDER)
     MIXER_POPULATE_BLOCK();
   #endif
 
   TERN_(HAS_CUTTER, block->cutter_power = cutter.power);
 
-  #if FAN_COUNT > 0
+  #if HAS_FAN
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
   #if EXTRUDERS > 1
     block->extruder = extruder;

commit e25402b5411c8ea77e05f7f925e588b40b7e02a8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 24 17:41:20 2020 -0500

    Apply TERN

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 310e86f2e5..b7dc639246 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -128,33 +128,27 @@ uint8_t Planner::delay_before_delivering;       // This counter delays delivery
 
 planner_settings_t Planner::settings;           // Initialized by settings.load()
 
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
 
 float Planner::steps_to_mm[XYZE_N];           // (mm) Millimeters per step
 
 #if HAS_JUNCTION_DEVIATION
   float Planner::junction_deviation_mm;       // (mm) M205 J
   #if ENABLED(LIN_ADVANCE)
-    #if ENABLED(DISTINCT_E_FACTORS)
-      float Planner::max_e_jerk[EXTRUDERS];   // Calculated from junction_deviation_mm
-    #else
-      float Planner::max_e_jerk;
-    #endif
+    float Planner::max_e_jerk               // Calculated from junction_deviation_mm
+      TERN_(DISTINCT_E_FACTORS, [EXTRUDERS]);
   #endif
 #endif
+
 #if HAS_CLASSIC_JERK
-  #if HAS_LINEAR_E_JERK
-    xyz_pos_t Planner::max_jerk;              // (mm/s^2) M205 XYZ - The largest speed change requiring no acceleration.
-  #else
-    xyze_pos_t Planner::max_jerk;             // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
-  #endif
+  TERN(HAS_LINEAR_E_JERK, xyz_pos_t, xyze_pos_t) Planner::max_jerk;
 #endif
 
 #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
@@ -2375,26 +2369,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     // Start with a safe speed (from which the machine may halt to stop immediately).
     float safe_speed = nominal_speed;
 
     #ifdef TRAVEL_EXTRA_XYJERK
       const float extra_xyjerk = (de <= 0) ? TRAVEL_EXTRA_XYJERK : 0;
     #else
       constexpr float extra_xyjerk = 0;
     #endif
 
     uint8_t limited = 0;
-    #if HAS_LINEAR_E_JERK
-      LOOP_XYZ(i)
-    #else
-      LOOP_XYZE(i)
-    #endif
-    {
+    TERN(HAS_LINEAR_E_JERK, LOOP_XYZ, LOOP_XYZE)(i) {
       const float jerk = ABS(current_speed[i]),   // cs : Starting from zero, change in speed for this axis
                   maxj = (max_jerk[i] + (i == X_AXIS || i == Y_AXIS ? extra_xyjerk : 0.0f)); // mj : The max jerk setting for this axis
       if (jerk > maxj) {                          // cs > mj : New current speed too fast?
         if (limited) {                            // limited already?
           const float mjerk = nominal_speed * maxj; // ns*mj
           if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk; // ns*mj/cs
         }
         else {
           safe_speed *= maxj / jerk;              // Initial limit: ns*mj/cs
           ++limited;                              // Initially limited

commit 55d66fb8971d9e5dbfb15e7ae5c952839b488f59
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 20:49:11 2020 -0500

    Add HAS_JUNCTION_DEVIATION

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c2a6365417..310e86f2e5 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -125,21 +125,21 @@ volatile uint8_t Planner::block_buffer_head,    // Index of the next block to be
                  Planner::block_buffer_tail;    // Index of the busy block, if any
 uint16_t Planner::cleaning_buffer_counter;      // A counter to disable queuing of blocks
 uint8_t Planner::delay_before_delivering;       // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
 planner_settings_t Planner::settings;           // Initialized by settings.load()
 
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
 
 float Planner::steps_to_mm[XYZE_N];           // (mm) Millimeters per step
 
-#if DISABLED(CLASSIC_JERK)
+#if HAS_JUNCTION_DEVIATION
   float Planner::junction_deviation_mm;       // (mm) M205 J
   #if ENABLED(LIN_ADVANCE)
     #if ENABLED(DISTINCT_E_FACTORS)
       float Planner::max_e_jerk[EXTRUDERS];   // Calculated from junction_deviation_mm
     #else
       float Planner::max_e_jerk;
     #endif
   #endif
 #endif
 #if HAS_CLASSIC_JERK
@@ -2144,21 +2144,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         const float comp = (float)max_acceleration_steps_per_s2[AXIS+INDX] * (float)block->step_event_count; \
         if ((float)accel * (float)block->steps[AXIS] > comp) accel = comp / (float)block->steps[AXIS]; \
       } \
     }while(0)
 
     // Start with print or travel acceleration
     accel = CEIL((esteps ? settings.acceleration : settings.travel_acceleration) * steps_per_mm);
 
     #if ENABLED(LIN_ADVANCE)
 
-      #if DISABLED(CLASSIC_JERK)
+      #if HAS_JUNCTION_DEVIATION
         #if ENABLED(DISTINCT_E_FACTORS)
           #define MAX_E_JERK max_e_jerk[extruder]
         #else
           #define MAX_E_JERK max_e_jerk
         #endif
       #else
         #define MAX_E_JERK max_jerk.e
       #endif
 
       /**
@@ -2231,21 +2231,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         if (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * 2 < SQRT(block->nominal_speed_sqr) * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif
     }
   #endif
 
   float vmax_junction_sqr; // Initial limit on the segment entry velocity (mm/s)^2
 
-  #if DISABLED(CLASSIC_JERK)
+  #if HAS_JUNCTION_DEVIATION
     /**
      * Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
      * Let a circle be tangent to both previous and current path line segments, where the junction
      * deviation is defined as the distance from the junction to the closest edge of the circle,
      * colinear with the circle center. The circular segment joining the two paths represents the
      * path of centripetal acceleration. Solve for max velocity based on max acceleration about the
      * radius of the circle, defined indirectly by junction deviation. This may be also viewed as
      * path width or max_jerk in the previous Grbl version. This approach does not actually deviate
      * from path, but used as a robust way to compute cornering speeds, as it takes into account the
      * nonlinearities of both the junction angle and junction velocity.
@@ -2278,21 +2278,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
     xyze_float_t unit_vec =
       #if HAS_DIST_MM_ARG
         cart_dist_mm
       #else
         { steps_dist_mm.x, steps_dist_mm.y, steps_dist_mm.z, steps_dist_mm.e }
       #endif
     ;
     unit_vec *= inverse_millimeters;
 
-    #if IS_CORE && DISABLED(CLASSIC_JERK)
+    #if IS_CORE && HAS_JUNCTION_DEVIATION
       /**
        * On CoreXY the length of the vector [A,B] is SQRT(2) times the length of the head movement vector [X,Y].
        * So taking Z and E into account, we cannot scale to a unit vector with "inverse_millimeters".
        * => normalize the complete junction vector
        */
       normalize_junction_vector(unit_vec);
     #endif
 
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
@@ -2453,21 +2453,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
       const float vmax_junction_threshold = vmax_junction * 0.99f;
       if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold)
         vmax_junction = safe_speed;
     }
     else
       vmax_junction = safe_speed;
 
     previous_safe_speed = safe_speed;
 
-    #if DISABLED(CLASSIC_JERK)
+    #if HAS_JUNCTION_DEVIATION
       vmax_junction_sqr = _MIN(vmax_junction_sqr, sq(vmax_junction));
     #else
       vmax_junction_sqr = sq(vmax_junction);
     #endif
 
   #endif // Classic Jerk Limiting
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed_sqr = vmax_junction_sqr;
 
@@ -2642,21 +2642,21 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
 bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, const float &e, const feedRate_t &fr_mm_s, const uint8_t extruder, const float millimeters
   #if ENABLED(SCARA_FEEDRATE_SCALING)
     , const float &inv_duration
   #endif
 ) {
   xyze_pos_t machine = { rx, ry, rz, e };
   TERN_(HAS_POSITION_MODIFIERS, apply_modifiers(machine));
 
   #if IS_KINEMATIC
 
-    #if DISABLED(CLASSIC_JERK)
+    #if HAS_JUNCTION_DEVIATION
       const xyze_pos_t cart_dist_mm = {
         rx - position_cart.x, ry - position_cart.y,
         rz - position_cart.z, e  - position_cart.e
       };
     #else
       const xyz_pos_t cart_dist_mm = { rx - position_cart.x, ry - position_cart.y, rz - position_cart.z };
     #endif
 
     float mm = millimeters;
     if (mm == 0.0)
@@ -2668,21 +2668,21 @@ bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, con
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
       const float duration_recip = inv_duration ?: fr_mm_s / mm;
       const xyz_pos_t diff = delta - position_float;
       const feedRate_t feedrate = diff.magnitude() * duration_recip;
     #else
       const feedRate_t feedrate = fr_mm_s;
     #endif
     if (buffer_segment(delta.a, delta.b, delta.c, machine.e
-      #if DISABLED(CLASSIC_JERK)
+      #if HAS_JUNCTION_DEVIATION
         , cart_dist_mm
       #endif
       , feedrate, extruder, mm
     )) {
       position_cart.set(rx, ry, rz, e);
       return true;
     }
     else
       return false;
   #else

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 5cd83fd8d8..c2a6365417 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -229,31 +229,25 @@ float Planner::previous_nominal_speed_sqr;
 #endif
 
 /**
  * Class and Instance Methods
  */
 
 Planner::Planner() { init(); }
 
 void Planner::init() {
   position.reset();
-  #if HAS_POSITION_FLOAT
-    position_float.reset();
-  #endif
-  #if IS_KINEMATIC
-    position_cart.reset();
-  #endif
+  TERN_(HAS_POSITION_FLOAT, position_float.reset());
+  TERN_(IS_KINEMATIC, position_cart.reset());
   previous_speed.reset();
   previous_nominal_speed_sqr = 0;
-  #if ABL_PLANAR
-    bed_level_matrix.set_to_identity();
-  #endif
+  TERN_(ABL_PLANAR, bed_level_matrix.set_to_identity());
   clear_block_buffer();
   delay_before_delivering = 0;
 }
 
 #if ENABLED(S_CURVE_ACCELERATION)
   #ifdef __AVR__
     /**
      * This routine returns 0x1000000 / d, getting the inverse as fast as possible.
      * A fast-converging iterative Newton-Raphson method can reach full precision in
      * just 1 iteration, and takes 211 cycles (worst case; the mean case is less, up
@@ -731,39 +725,36 @@ block_t* Planner::get_current_block() {
       if (nr_moves < 3 && delay_before_delivering) return nullptr;
       delay_before_delivering = 0;
     }
 
     // If we are here, there is no excuse to deliver the block
     block_t * const block = &block_buffer[block_buffer_tail];
 
     // No trapezoid calculated? Don't execute yet.
     if (TEST(block->flag, BLOCK_BIT_RECALCULATE)) return nullptr;
 
-    #if HAS_SPI_LCD
-      block_buffer_runtime_us -= block->segment_time_us; // We can't be sure how long an active block will take, so don't count it.
-    #endif
+    // We can't be sure how long an active block will take, so don't count it.
+    TERN_(HAS_SPI_LCD, block_buffer_runtime_us -= block->segment_time_us);
 
     // As this block is busy, advance the nonbusy block pointer
     block_buffer_nonbusy = next_block_index(block_buffer_tail);
 
     // Push block_buffer_planned pointer, if encountered.
     if (block_buffer_tail == block_buffer_planned)
       block_buffer_planned = block_buffer_nonbusy;
 
     // Return the block
     return block;
   }
 
   // The queue became empty
-  #if HAS_SPI_LCD
-    clear_block_buffer_runtime(); // paranoia. Buffer is empty now - so reset accumulated time to zero.
-  #endif
+  TERN_(HAS_SPI_LCD, clear_block_buffer_runtime()); // paranoia. Buffer is empty now - so reset accumulated time to zero.
 
   return nullptr;
 }
 
 /**
  * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
  * by the provided factors.
  **
  * ############ VERY IMPORTANT ############
  * NOTE that the PRECONDITION to call this function is that the block is
@@ -1297,71 +1288,53 @@ void Planner::check_axes_activity() {
     #if FAN_COUNT > 0 || ENABLED(BARICUDA)
       block_t *block = &block_buffer[block_buffer_tail];
     #endif
 
     #if FAN_COUNT > 0
       FANS_LOOP(i)
         tail_fan_speed[i] = thermalManager.scaledFanSpeed(i, block->fan_speed[i]);
     #endif
 
     #if ENABLED(BARICUDA)
-      #if HAS_HEATER_1
-        tail_valve_pressure = block->valve_pressure;
-      #endif
-      #if HAS_HEATER_2
-        tail_e_to_p_pressure = block->e_to_p_pressure;
-      #endif
+      TERN_(HAS_HEATER_1, tail_valve_pressure = block->valve_pressure);
+      TERN_(HAS_HEATER_2, tail_e_to_p_pressure = block->e_to_p_pressure);
     #endif
 
     #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
       for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
         block_t *block = &block_buffer[b];
         LOOP_XYZE(i) if (block->steps[i]) axis_active[i] = true;
       }
     #endif
   }
   else {
 
-    #if HAS_CUTTER
-      cutter.refresh();
-    #endif
+    TERN_(HAS_CUTTER, cutter.refresh());
 
     #if FAN_COUNT > 0
       FANS_LOOP(i)
         tail_fan_speed[i] = thermalManager.scaledFanSpeed(i);
     #endif
 
     #if ENABLED(BARICUDA)
-      #if HAS_HEATER_1
-        tail_valve_pressure = baricuda_valve_pressure;
-      #endif
-      #if HAS_HEATER_2
-        tail_e_to_p_pressure = baricuda_e_to_p_pressure;
-      #endif
+      TERN_(HAS_HEATER_1, tail_valve_pressure = baricuda_valve_pressure);
+      TERN_(HAS_HEATER_2, tail_e_to_p_pressure = baricuda_e_to_p_pressure);
     #endif
   }
 
   //
   // Disable inactive axes
   //
-  #if ENABLED(DISABLE_X)
-    if (!axis_active.x) DISABLE_AXIS_X();
-  #endif
-  #if ENABLED(DISABLE_Y)
-    if (!axis_active.y) DISABLE_AXIS_Y();
-  #endif
-  #if ENABLED(DISABLE_Z)
-    if (!axis_active.z) DISABLE_AXIS_Z();
-  #endif
-  #if ENABLED(DISABLE_E)
-    if (!axis_active.e) disable_e_steppers();
-  #endif
+  if (TERN0(DISABLE_X, !axis_active.x)) DISABLE_AXIS_X();
+  if (TERN0(DISABLE_Y, !axis_active.y)) DISABLE_AXIS_Y();
+  if (TERN0(DISABLE_Z, !axis_active.z)) DISABLE_AXIS_Z();
+  if (TERN0(DISABLE_E, !axis_active.e)) disable_e_steppers();
 
   //
   // Update Fan speeds
   //
   #if FAN_COUNT > 0
 
     #if FAN_KICKSTART_TIME > 0
       static millis_t fan_kick_end[FAN_COUNT] = { 0 };
       #define KICKSTART_FAN(f)                         \
         if (tail_fan_speed[f]) {                       \
@@ -1384,57 +1357,35 @@ void Planner::check_axes_activity() {
 
     #if ENABLED(FAN_SOFT_PWM)
       #define _FAN_SET(F) thermalManager.soft_pwm_amount_fan[F] = CALC_FAN_SPEED(F);
     #elif ENABLED(FAST_PWM_FAN)
       #define _FAN_SET(F) set_pwm_duty(FAN##F##_PIN, CALC_FAN_SPEED(F));
     #else
       #define _FAN_SET(F) analogWrite(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(F));
     #endif
     #define FAN_SET(F) do{ KICKSTART_FAN(F); _FAN_SET(F); }while(0)
 
-    #if HAS_FAN0
-      FAN_SET(0);
-    #endif
-    #if HAS_FAN1
-      FAN_SET(1);
-    #endif
-    #if HAS_FAN2
-      FAN_SET(2);
-    #endif
-    #if HAS_FAN3
-      FAN_SET(3);
-    #endif
-    #if HAS_FAN4
-      FAN_SET(4);
-    #endif
-    #if HAS_FAN5
-      FAN_SET(5);
-    #endif
-    #if HAS_FAN6
-      FAN_SET(6);
-    #endif
-    #if HAS_FAN7
-      FAN_SET(7);
-    #endif
+    TERN_(HAS_FAN0, FAN_SET(0));
+    TERN_(HAS_FAN1, FAN_SET(1));
+    TERN_(HAS_FAN2, FAN_SET(2));
+    TERN_(HAS_FAN3, FAN_SET(3));
+    TERN_(HAS_FAN4, FAN_SET(4));
+    TERN_(HAS_FAN5, FAN_SET(5));
+    TERN_(HAS_FAN6, FAN_SET(6));
+    TERN_(HAS_FAN7, FAN_SET(7));
   #endif // FAN_COUNT > 0
 
-  #if ENABLED(AUTOTEMP)
-    getHighESpeed();
-  #endif
+  TERN_(AUTOTEMP, getHighESpeed());
 
   #if ENABLED(BARICUDA)
-    #if HAS_HEATER_1
-      analogWrite(pin_t(HEATER_1_PIN), tail_valve_pressure);
-    #endif
-    #if HAS_HEATER_2
-      analogWrite(pin_t(HEATER_2_PIN), tail_e_to_p_pressure);
-    #endif
+    TERN_(HAS_HEATER_1, analogWrite(pin_t(HEATER_1_PIN), tail_valve_pressure));
+    TERN_(HAS_HEATER_2, analogWrite(pin_t(HEATER_2_PIN), tail_e_to_p_pressure));
   #endif
 }
 
 #if DISABLED(NO_VOLUMETRICS)
 
   /**
    * Get a volumetric multiplier from a filament diameter.
    * This is the reciprocal of the circular cross-section area.
    * Return 1.0 with volumetric off or a diameter of 0.0.
    */
@@ -1470,25 +1421,22 @@ void Planner::check_axes_activity() {
       ? ratio_2 / CIRCLE_AREA(filwidth.nominal_mm * 0.5f) // Volumetric uses a true volumetric multiplier
       : ratio_2;                                          // Linear squares the ratio, which scales the volume
 
     refresh_e_factor(FILAMENT_SENSOR_EXTRUDER_NUM);
   }
 #endif
 
 #if HAS_LEVELING
 
   constexpr xy_pos_t level_fulcrum = {
-    #if ENABLED(Z_SAFE_HOMING)
-      Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT
-    #else
-      X_HOME_POS, Y_HOME_POS
-    #endif
+    TERN(Z_SAFE_HOMING, Z_SAFE_HOMING_X_POINT, X_HOME_POS),
+    TERN(Z_SAFE_HOMING, Z_SAFE_HOMING_Y_POINT, Y_HOME_POS)
   };
 
   /**
    * rx, ry, rz - Cartesian positions in mm
    *              Leveled XYZ on completion
    */
   void Planner::apply_leveling(xyz_pos_t &raw) {
     if (!leveling_active) return;
 
     #if ABL_PLANAR
@@ -1772,45 +1720,41 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
                         " E:", target.e, " (", de, " steps)"
                       #endif
                     );
   //*/
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position.e = target.e; // Behave as if the move really took place, but ignore E part
-          #if HAS_POSITION_FLOAT
-            position_float.e = target_float.e;
-          #endif
+          TERN_(HAS_POSITION_FLOAT, position_float.e = target_float.e);
           de = 0; // no difference
           SERIAL_ECHO_MSG(STR_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
         const float e_steps = ABS(de * e_factor[extruder]);
         const float max_e_steps = settings.axis_steps_per_mm[E_AXIS_N(extruder)] * (EXTRUDE_MAXLENGTH);
         if (e_steps > max_e_steps) {
           #if ENABLED(MIXING_EXTRUDER)
             bool ignore_e = false;
             float collector[MIXING_STEPPERS];
             mixer.refresh_collector(1.0, mixer.get_current_vtool(), collector);
             MIXER_STEPPER_LOOP(e)
               if (e_steps * collector[e] > max_e_steps) { ignore_e = true; break; }
           #else
             constexpr bool ignore_e = true;
           #endif
           if (ignore_e) {
             position.e = target.e; // Behave as if the move really took place, but ignore E part
-            #if HAS_POSITION_FLOAT
-              position_float.e = target_float.e;
-            #endif
+            TERN_(HAS_POSITION_FLOAT, position_float.e = target_float.e);
             de = 0; // no difference
             SERIAL_ECHO_MSG(STR_ERR_LONG_EXTRUDE_STOP);
           }
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   // Compute direction bit-mask for this block
   uint8_t dm = 0;
@@ -1875,23 +1819,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   /**
    * This part of the code calculates the total length of the movement.
    * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
    * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
    * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
    * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
    * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
    */
   struct DistanceMM : abce_float_t {
-    #if IS_CORE
-      xyz_pos_t head;
-    #endif
+    TERN_(IS_CORE, xyz_pos_t head);
   } steps_dist_mm;
   #if IS_CORE
     #if CORE_IS_XY
       steps_dist_mm.head.x = da * steps_to_mm[A_AXIS];
       steps_dist_mm.head.y = db * steps_to_mm[B_AXIS];
       steps_dist_mm.z      = dc * steps_to_mm[Z_AXIS];
       steps_dist_mm.a      = (da + db) * steps_to_mm[A_AXIS];
       steps_dist_mm.b      = CORESIGN(da - db) * steps_to_mm[B_AXIS];
     #elif CORE_IS_XZ
       steps_dist_mm.head.x = da * steps_to_mm[A_AXIS];
@@ -1911,23 +1853,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     steps_dist_mm.b = db * steps_to_mm[B_AXIS];
     steps_dist_mm.c = dc * steps_to_mm[C_AXIS];
   #endif
 
   #if EXTRUDERS
     steps_dist_mm.e = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
   #else
     steps_dist_mm.e = 0.0f;
   #endif
 
-  #if ENABLED(LCD_SHOW_E_TOTAL)
-    e_move_accumulator += steps_dist_mm.e;
-  #endif
+  TERN_(LCD_SHOW_E_TOTAL, e_move_accumulator += steps_dist_mm.e);
 
   if (block->steps.a < MIN_STEPS_PER_SEGMENT && block->steps.b < MIN_STEPS_PER_SEGMENT && block->steps.c < MIN_STEPS_PER_SEGMENT) {
     block->millimeters = (0
       #if EXTRUDERS
         + ABS(steps_dist_mm.e)
       #endif
     );
   }
   else {
     if (millimeters)
@@ -1947,41 +1887,37 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
     /**
      * At this point at least one of the axes has more steps than
      * MIN_STEPS_PER_SEGMENT, ensuring the segment won't get dropped as
      * zero-length. It's important to not apply corrections
      * to blocks that would get dropped!
      *
      * A correction function is permitted to add steps to an axis, it
      * should *never* remove steps!
      */
-    #if ENABLED(BACKLASH_COMPENSATION)
-      backlash.add_correction_steps(da, db, dc, dm, block);
-    #endif
+    TERN_(BACKLASH_COMPENSATION, backlash.add_correction_steps(da, db, dc, dm, block));
   }
 
   #if EXTRUDERS
     block->steps.e = esteps;
   #endif
 
   block->step_event_count = _MAX(block->steps.a, block->steps.b, block->steps.c, esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   #if ENABLED(MIXING_EXTRUDER)
     MIXER_POPULATE_BLOCK();
   #endif
 
-  #if HAS_CUTTER
-    block->cutter_power = cutter.power;
-  #endif
+  TERN_(HAS_CUTTER, block->cutter_power = cutter.power);
 
   #if FAN_COUNT > 0
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
@@ -2019,23 +1955,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     if (block->steps.x) ENABLE_AXIS_X();
     if (block->steps.y) ENABLE_AXIS_Y();
     #if DISABLED(Z_LATE_ENABLE)
       if (block->steps.z) ENABLE_AXIS_Z();
     #endif
   #endif
 
   // Enable extruder(s)
   #if EXTRUDERS
     if (esteps) {
-      #if ENABLED(AUTO_POWER_CONTROL)
-        powerManager.power_on();
-      #endif
+      TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
         LOOP_L_N(i, EXTRUDERS)
           if (g_uc_extruder_last_move[i] > 0) g_uc_extruder_last_move[i]--;
 
         #if HAS_DUPLICATION_MODE
           if (extruder_duplication_enabled && extruder == 0) {
             ENABLE_AXIS_E1();
             g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
@@ -2188,23 +2122,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     block->nominal_rate *= speed_factor;
     block->nominal_speed_sqr = block->nominal_speed_sqr * sq(speed_factor);
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
   if (!block->steps.a && !block->steps.b && !block->steps.c) {
     // convert to: acceleration steps/sec^2
     accel = CEIL(settings.retract_acceleration * steps_per_mm);
-    #if ENABLED(LIN_ADVANCE)
-      block->use_advance_lead = false;
-    #endif
+    TERN_(LIN_ADVANCE, block->use_advance_lead = false);
   }
   else {
     #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
         const uint32_t comp = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count; \
         if (accel * block->steps[AXIS] > comp) accel = comp / block->steps[AXIS]; \
       } \
     }while(0)
 
     #define LIMIT_ACCEL_FLOAT(AXIS,INDX) do{ \
@@ -2253,23 +2185,22 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
                + sq(target_float.z - position_float.z))
           #endif
         ;
 
         // Check for unusual high e_D ratio to detect if a retract move was combined with the last print move due to min. steps per segment. Never execute this with advance!
         // This assumes no one will use a retract length of 0mm < retr_length < ~0.2mm and no one will print 100mm wide lines using 3mm filament or 35mm wide lines using 1.75mm filament.
         if (block->e_D_ratio > 3.0f)
           block->use_advance_lead = false;
         else {
           const uint32_t max_accel_steps_per_s2 = MAX_E_JERK / (extruder_advance_K[active_extruder] * block->e_D_ratio) * steps_per_mm;
-          #if ENABLED(LA_DEBUG)
-            if (accel > max_accel_steps_per_s2) SERIAL_ECHOLNPGM("Acceleration limited.");
-          #endif
+          if (TERN0(LA_DEBUG, accel > max_accel_steps_per_s2))
+            SERIAL_ECHOLNPGM("Acceleration limited.");
           NOMORE(accel, max_accel_steps_per_s2);
         }
       }
     #endif
 
     #if ENABLED(DISTINCT_E_FACTORS)
       #define ACCEL_IDX extruder
     #else
       #define ACCEL_IDX 0
     #endif
@@ -2554,36 +2485,28 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   // junction speeds in deceleration and acceleration, respectively. This is due to how the current
   // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
   block->flag |= block->nominal_speed_sqr <= v_allowable_sqr ? BLOCK_FLAG_RECALCULATE | BLOCK_FLAG_NOMINAL_LENGTH : BLOCK_FLAG_RECALCULATE;
 
   // Update previous path unit_vector and nominal speed
   previous_speed = current_speed;
   previous_nominal_speed_sqr = block->nominal_speed_sqr;
 
-  // Update the position
-  position = target;
-  #if HAS_POSITION_FLOAT
-    position_float = target_float;
-  #endif
+  position = target;  // Update the position
 
-  #if ENABLED(GRADIENT_MIX)
-    mixer.gradient_control(target_float.z);
-  #endif
+  TERN_(HAS_POSITION_FLOAT, position_float = target_float);
+  TERN_(GRADIENT_MIX, mixer.gradient_control(target_float.z));
+  TERN_(POWER_LOSS_RECOVERY, block->sdpos = recovery.command_sdpos());
 
-  #if ENABLED(POWER_LOSS_RECOVERY)
-    block->sdpos = recovery.command_sdpos();
-  #endif
+  return true;        // Movement was accepted
 
-  // Movement was accepted
-  return true;
 } // _populate_block()
 
 /**
  * Planner::buffer_sync_block
  * Add a block to the buffer that just updates the position
  */
 void Planner::buffer_sync_block() {
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
@@ -2647,29 +2570,23 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
     int32_t(LROUND(b * settings.axis_steps_per_mm[B_AXIS])),
     int32_t(LROUND(c * settings.axis_steps_per_mm[C_AXIS])),
     int32_t(LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(extruder)]))
   };
 
   #if HAS_POSITION_FLOAT
     const xyze_pos_t target_float = { a, b, c, e };
   #endif
 
   // DRYRUN prevents E moves from taking place
-  if (DEBUGGING(DRYRUN)
-    #if ENABLED(CANCEL_OBJECTS)
-      || cancelable.skipping
-    #endif
-  ) {
+  if (DEBUGGING(DRYRUN) || TERN0(CANCEL_OBJECTS, cancelable.skipping)) {
     position.e = target.e;
-    #if HAS_POSITION_FLOAT
-      position_float.e = e;
-    #endif
+    TERN_(HAS_POSITION_FLOAT, position_float.e = e);
   }
 
   /* <-- add a slash to enable
     SERIAL_ECHOPAIR("  buffer_segment FR:", fr_mm_s);
     #if IS_KINEMATIC
       SERIAL_ECHOPAIR(" A:", a);
       SERIAL_ECHOPAIR(" (", position.a);
       SERIAL_ECHOPAIR("->", target.a);
       SERIAL_ECHOPAIR(") B:", b);
     #else
@@ -2690,30 +2607,28 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
     SERIAL_ECHOPAIR(" (", position.z);
     SERIAL_ECHOPAIR("->", target.z);
     SERIAL_CHAR(')');
     SERIAL_ECHOPAIR_P(SP_E_LBL, e);
     SERIAL_ECHOPAIR(" (", position.e);
     SERIAL_ECHOPAIR("->", target.e);
     SERIAL_ECHOLNPGM(")");
   //*/
 
   // Queue the movement
-  if (
-    !_buffer_steps(target
+  if (!_buffer_steps(target
       #if HAS_POSITION_FLOAT
         , target_float
       #endif
       #if HAS_DIST_MM_ARG
         , cart_dist_mm
       #endif
-      , fr_mm_s, extruder, millimeters
-    )
+      , fr_mm_s, extruder, millimeters)
   ) return false;
 
   stepper.wake_up();
   return true;
 } // buffer_segment()
 
 /**
  * Add a new linear movement to the buffer.
  * The target is cartesian. It's translated to
  * delta/scara if needed.
@@ -2723,23 +2638,21 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
  *  extruder     - target extruder
  *  millimeters  - the length of the movement, if known
  *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
  */
 bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, const float &e, const feedRate_t &fr_mm_s, const uint8_t extruder, const float millimeters
   #if ENABLED(SCARA_FEEDRATE_SCALING)
     , const float &inv_duration
   #endif
 ) {
   xyze_pos_t machine = { rx, ry, rz, e };
-  #if HAS_POSITION_MODIFIERS
-    apply_modifiers(machine);
-  #endif
+  TERN_(HAS_POSITION_MODIFIERS, apply_modifiers(machine));
 
   #if IS_KINEMATIC
 
     #if DISABLED(CLASSIC_JERK)
       const xyze_pos_t cart_dist_mm = {
         rx - position_cart.x, ry - position_cart.y,
         rz - position_cart.z, e  - position_cart.e
       };
     #else
       const xyz_pos_t cart_dist_mm = { rx - position_cart.x, ry - position_cart.y, rz - position_cart.z };
@@ -2778,101 +2691,85 @@ bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, con
 } // buffer_line()
 
 /**
  * Directly set the planner ABC position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * The provided ABC position is in machine units.
  */
 
 void Planner::set_machine_position_mm(const float &a, const float &b, const float &c, const float &e) {
-  #if ENABLED(DISTINCT_E_FACTORS)
-    last_extruder = active_extruder;
-  #endif
-  #if HAS_POSITION_FLOAT
-    position_float.set(a, b, c, e);
-  #endif
+  TERN_(DISTINCT_E_FACTORS, last_extruder = active_extruder);
+  TERN_(HAS_POSITION_FLOAT, position_float.set(a, b, c, e));
   position.set(LROUND(a * settings.axis_steps_per_mm[A_AXIS]),
                LROUND(b * settings.axis_steps_per_mm[B_AXIS]),
                LROUND(c * settings.axis_steps_per_mm[C_AXIS]),
                LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(active_extruder)]));
   if (has_blocks_queued()) {
     //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.
     //previous_speed.reset();
     buffer_sync_block();
   }
   else
     stepper.set_position(position);
 }
 
 void Planner::set_position_mm(const float &rx, const float &ry, const float &rz, const float &e) {
   xyze_pos_t machine = { rx, ry, rz, e };
   #if HAS_POSITION_MODIFIERS
-  {
     apply_modifiers(machine
       #if HAS_LEVELING
         , true
       #endif
     );
-  }
   #endif
   #if IS_KINEMATIC
     position_cart.set(rx, ry, rz, e);
     inverse_kinematics(machine);
     set_machine_position_mm(delta.a, delta.b, delta.c, machine.e);
   #else
     set_machine_position_mm(machine);
   #endif
 }
 
 /**
  * Setters for planner position (also setting stepper position).
  */
 void Planner::set_e_position_mm(const float &e) {
   const uint8_t axis_index = E_AXIS_N(active_extruder);
-  #if ENABLED(DISTINCT_E_FACTORS)
-    last_extruder = active_extruder;
-  #endif
-  #if ENABLED(FWRETRACT)
-    float e_new = e - fwretract.current_retract[active_extruder];
-  #else
-    const float e_new = e;
-  #endif
+  TERN_(DISTINCT_E_FACTORS, last_extruder = active_extruder);
+
+  const float e_new = e - TERN0(FWRETRACT, fwretract.current_retract[active_extruder]);
   position.e = LROUND(settings.axis_steps_per_mm[axis_index] * e_new);
-  #if HAS_POSITION_FLOAT
-    position_float.e = e_new;
-  #endif
-  #if IS_KINEMATIC
-    position_cart.e = e;
-  #endif
+  TERN_(HAS_POSITION_FLOAT, position_float.e = e_new);
+  TERN_(IS_KINEMATIC, position_cart.e = e);
+
   if (has_blocks_queued())
     buffer_sync_block();
   else
     stepper.set_axis_position(E_AXIS, position.e);
 }
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define AXIS_CONDITION (i < E_AXIS || i == E_AXIS_N(active_extruder))
   #else
     #define AXIS_CONDITION true
   #endif
   uint32_t highest_rate = 1;
   LOOP_XYZE_N(i) {
     max_acceleration_steps_per_s2[i] = settings.max_acceleration_mm_per_s2[i] * settings.axis_steps_per_mm[i];
     if (AXIS_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   }
   cutoff_long = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
-  #if HAS_LINEAR_E_JERK
-    recalculate_max_e_jerk();
-  #endif
+  TERN_(HAS_LINEAR_E_JERK, recalculate_max_e_jerk());
 }
 
 // Recalculate position, steps_to_mm if settings.axis_steps_per_mm changes!
 void Planner::refresh_positioning() {
   LOOP_XYZE_N(i) steps_to_mm[i] = 1.0f / settings.axis_steps_per_mm[i];
   set_position_mm(current_position);
   reset_acceleration_rates();
 }
 
 inline void limit_and_warn(float &val, const uint8_t axis, PGM_P const setting_name, const xyze_float_t &max_limit) {

commit 000ec9fc139413c7702e8e295a29a21f6a6226e8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 20 09:43:15 2020 -0500

    Ensure language.h include order
    
    See #17604

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index b7e2681141..5cd83fd8d8 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -60,21 +60,20 @@
  *
  * The fast inverse function needed for B√©zier interpolation for AVR
  * was designed, written and tested by Eduardo Jos√© Tagle on April/2018
  */
 
 #include "planner.h"
 #include "stepper.h"
 #include "motion.h"
 #include "temperature.h"
 #include "../lcd/ultralcd.h"
-#include "../core/language.h"
 #include "../gcode/parser.h"
 
 #include "../MarlinCore.h"
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"

commit 87875e0de8fe2107642dce3cad0928504ed58d74
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 19 02:01:30 2020 -0500

    Fix mixing with "unload all" compile

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index f55ef37bc4..b7e2681141 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2126,31 +2126,28 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     current_speed[i] = steps_dist_mm[i] * inverse_secs;
     const feedRate_t cs = ABS(current_speed[i]),
                  max_fr = settings.max_feedrate_mm_s[i];
     if (cs > max_fr) NOMORE(speed_factor, max_fr / cs);
   }
 
   // Limit speed on extruders, if any
   #if EXTRUDERS
     {
       current_speed.e = steps_dist_mm.e * inverse_secs;
-      #if BOTH(MIXING_EXTRUDER, RETRACT_SYNC_MIXING)
+      #if HAS_MIXER_SYNC_CHANNEL
         // Move all mixing extruders at the specified rate
         if (mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)
           current_speed.e *= MIXING_STEPPERS;
       #endif
       const feedRate_t cs = ABS(current_speed.e),
-                   max_fr = (settings.max_feedrate_mm_s[E_AXIS_N(extruder)]
-                              #if BOTH(MIXING_EXTRUDER, RETRACT_SYNC_MIXING)
-                                * MIXING_STEPPERS
-                              #endif
-                            );
+                   max_fr = settings.max_feedrate_mm_s[E_AXIS_N(extruder)]
+                            * TERN(HAS_MIXER_SYNC_CHANNEL, MIXING_STEPPERS, 1);
       if (cs > max_fr) NOMORE(speed_factor, max_fr / cs);
     }
   #endif
 
   // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT
 
     // Check and limit the xy direction change frequency
     const unsigned char direction_change = block->direction_bits ^ old_direction_bits;
     old_direction_bits = block->direction_bits;

commit 50fa87f1cfad92ff88f7c14ecaa39e1c2b33639f
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Fri Apr 17 18:19:31 2020 +0200

    Proportional Autotemp followup (#17585)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e053676574..f55ef37bc4 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2984,20 +2984,21 @@ void Planner::set_max_jerk(const AxisEnum axis, float targetValue) {
 #endif
 
 #if ENABLED(AUTOTEMP)
 
   void Planner::autotemp_M104_M109() {
 
     #if ENABLED(AUTOTEMP_PROPORTIONAL)
       const int16_t target = thermalManager.degTargetHotend(active_extruder);
       autotemp_min = target + AUTOTEMP_MIN_P;
       autotemp_max = target + AUTOTEMP_MAX_P;
-      autotemp_factor = AUTOTEMP_FACTOR_P;
     #endif
 
     if (parser.seenval('S')) autotemp_min = parser.value_celsius();
     if (parser.seenval('B')) autotemp_max = parser.value_celsius();
-    if (parser.seenval('F')) autotemp_factor = parser.value_float();
-    if (!autotemp_factor) autotemp_enabled = false; // F0 will disable autotemp
-  }
 
+    // When AUTOTEMP_PROPORTIONAL is enabled, F0 disables autotemp.
+    // Normally, leaving off F also disables autotemp.
+    autotemp_factor = parser.seen('F') ? parser.value_float() : TERN(AUTOTEMP_PROPORTIONAL, AUTOTEMP_FACTOR_P, 0);
+    autotemp_enabled = autotemp_factor != 0;
+  }
 #endif

commit bbe2cb75adce137bfd11cd1283ca4e0f9c0ca647
Author: XDA-Bam <1209896+XDA-Bam@users.noreply.github.com>
Date:   Fri Apr 17 04:51:05 2020 +0200

    More accurate Junction Deviation fast-acos (#17575)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c203306f65..e053676574 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2383,27 +2383,40 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         NOLESS(junction_cos_theta, -0.999999f); // Check for numerical round-off to avoid divide by zero.
 
         // Convert delta vector to unit vector
         xyze_float_t junction_unit_vec = unit_vec - prev_unit_vec;
         normalize_junction_vector(junction_unit_vec);
 
         const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec),
                     sin_theta_d2 = SQRT(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
 
         vmax_junction_sqr = (junction_acceleration * junction_deviation_mm * sin_theta_d2) / (1.0f - sin_theta_d2);
-        if (block->millimeters < 1) {
 
-          // Fast acos approximation, minus the error bar to be safe
-          const float junction_theta = (RADIANS(-40) * sq(junction_cos_theta) - RADIANS(50)) * junction_cos_theta + RADIANS(90) - 0.18f;
+        if (block->millimeters < 1) {
+          // Fast acos approximation (max. error +-0.033 rads)
+          // Based on MinMax polynomial published by W. Randolph Franklin, see
+          // https://wrf.ecse.rpi.edu/Research/Short_Notes/arcsin/onlyelem.html
+          // (acos(x) = pi / 2 - asin(x))
+
+          const float neg = junction_cos_theta < 0 ? -1 : 1,
+                      t = neg * junction_cos_theta,
+                      asinx =       0.032843707f
+                            + t * (-1.451838349f
+                            + t * ( 29.66153956f
+                            + t * (-131.1123477f
+                            + t * ( 262.8130562f
+                            + t * (-242.7199627f + t * 84.31466202f) )))),
+                      junction_theta = RADIANS(90) - neg * asinx;
 
           // If angle is greater than 135 degrees (octagon), find speed for approximate arc
           if (junction_theta > RADIANS(135)) {
+            // NOTE: MinMax acos approximation and thereby also junction_theta top out at pi-0.033, which avoids division by 0
             const float limit_sqr = block->millimeters / (RADIANS(180) - junction_theta) * junction_acceleration;
             NOMORE(vmax_junction_sqr, limit_sqr);
           }
         }
       }
 
       // Get the lowest speed
       vmax_junction_sqr = _MIN(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.

commit 9110f756add41410a00559aafc603b89fd2d0af0
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Fri Apr 17 02:03:53 2020 +0200

    AUTOTEMP default proportions (#17560)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index f6be8df9c9..c203306f65 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2966,16 +2966,25 @@ void Planner::set_max_jerk(const AxisEnum axis, float targetValue) {
       // Reenable Stepper ISR
       if (was_enabled) stepper.wake_up();
     #endif
   }
 
 #endif
 
 #if ENABLED(AUTOTEMP)
 
   void Planner::autotemp_M104_M109() {
-    if ((autotemp_enabled = parser.seen('F'))) autotemp_factor = parser.value_float();
-    if (parser.seen('S')) autotemp_min = parser.value_celsius();
-    if (parser.seen('B')) autotemp_max = parser.value_celsius();
+
+    #if ENABLED(AUTOTEMP_PROPORTIONAL)
+      const int16_t target = thermalManager.degTargetHotend(active_extruder);
+      autotemp_min = target + AUTOTEMP_MIN_P;
+      autotemp_max = target + AUTOTEMP_MAX_P;
+      autotemp_factor = AUTOTEMP_FACTOR_P;
+    #endif
+
+    if (parser.seenval('S')) autotemp_min = parser.value_celsius();
+    if (parser.seenval('B')) autotemp_max = parser.value_celsius();
+    if (parser.seenval('F')) autotemp_factor = parser.value_float();
+    if (!autotemp_factor) autotemp_enabled = false; // F0 will disable autotemp
   }
 
 #endif

commit 7aed32df00ae33b6ab2815006ad4c422a9231b69
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 11 21:27:49 2020 -0500

    Fix SD_FINISHED_RELEASECOMMAND bug
    
    Fixes #17401 bug that was introduced in 8f26c3a

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 4ad7a79431..f6be8df9c9 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1594,22 +1594,22 @@ void Planner::quick_stop() {
 
   // Restart the block delay for the first movement - As the queue was
   // forced to empty, there's no risk the ISR will touch this.
   delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
 
   #if HAS_SPI_LCD
     // Clear the accumulated runtime
     clear_block_buffer_runtime();
   #endif
 
-  // Make sure to drop any attempt of queuing moves for at least 1 second
-  cleaning_buffer_counter = 1000;
+  // Make sure to drop any attempt of queuing moves for 1 second
+  cleaning_buffer_counter = TEMP_TIMER_FREQUENCY;
 
   // Reenable Stepper ISR
   if (was_enabled) stepper.wake_up();
 
   // And stop the stepper ISR
   stepper.quick_stop();
 }
 
 void Planner::endstop_triggered(const AxisEnum axis) {
   // Record stepper position and discard the current block

commit a1523d64199b69878d9208c335eaca293260077e
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Wed Apr 8 22:00:31 2020 +0200

    Fix: const needed for operator* (#17443)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 2de46373b2..4ad7a79431 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2878,38 +2878,38 @@ inline void limit_and_warn(float &val, const uint8_t axis, PGM_P const setting_n
   }
 }
 
 void Planner::set_max_acceleration(const uint8_t axis, float targetValue) {
   #if ENABLED(LIMITED_MAX_ACCEL_EDITING)
     #ifdef MAX_ACCEL_EDIT_VALUES
       constexpr xyze_float_t max_accel_edit = MAX_ACCEL_EDIT_VALUES;
       const xyze_float_t &max_acc_edit_scaled = max_accel_edit;
     #else
       constexpr xyze_float_t max_accel_edit = DEFAULT_MAX_ACCELERATION;
-      constexpr xyze_float_t max_acc_edit_scaled = max_accel_edit * 2;
+      const xyze_float_t max_acc_edit_scaled = max_accel_edit * 2;
     #endif
     limit_and_warn(targetValue, axis, PSTR("Acceleration"), max_acc_edit_scaled);
   #endif
   settings.max_acceleration_mm_per_s2[axis] = targetValue;
 
   // Update steps per s2 to agree with the units per s2 (since they are used in the planner)
   reset_acceleration_rates();
 }
 
 void Planner::set_max_feedrate(const uint8_t axis, float targetValue) {
   #if ENABLED(LIMITED_MAX_FR_EDITING)
     #ifdef MAX_FEEDRATE_EDIT_VALUES
       constexpr xyze_float_t max_fr_edit = MAX_FEEDRATE_EDIT_VALUES;
       const xyze_float_t &max_fr_edit_scaled = max_fr_edit;
     #else
       constexpr xyze_float_t max_fr_edit = DEFAULT_MAX_FEEDRATE;
-      constexpr xyze_float_t max_fr_edit_scaled = max_fr_edit * 2;
+      const xyze_float_t max_fr_edit_scaled = max_fr_edit * 2;
     #endif
     limit_and_warn(targetValue, axis, PSTR("Feedrate"), max_fr_edit_scaled);
   #endif
   settings.max_feedrate_mm_s[axis] = targetValue;
 }
 
 void Planner::set_max_jerk(const AxisEnum axis, float targetValue) {
   #if HAS_CLASSIC_JERK
     #if ENABLED(LIMITED_JERK_EDITING)
       constexpr xyze_float_t max_jerk_edit =

commit df8b7dfc406be095a62b5445b69c40034d418823
Author: Ben <jediminer543@users.noreply.github.com>
Date:   Fri Apr 3 01:31:08 2020 +0100

    Various Laser / Spindle improvements (#15335)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e1a050a459..2de46373b2 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -808,39 +808,79 @@ void Planner::calculate_trapezoid_for_block(block_t* const block, const float &e
     #endif
   }
   #if ENABLED(S_CURVE_ACCELERATION)
     else // We have some plateau time, so the cruise rate will be the nominal rate
       cruise_rate = block->nominal_rate;
   #endif
 
   #if ENABLED(S_CURVE_ACCELERATION)
     // Jerk controlled speed requires to express speed versus time, NOT steps
     uint32_t acceleration_time = ((float)(cruise_rate - initial_rate) / accel) * (STEPPER_TIMER_RATE),
-             deceleration_time = ((float)(cruise_rate - final_rate) / accel) * (STEPPER_TIMER_RATE);
-
+             deceleration_time = ((float)(cruise_rate - final_rate) / accel) * (STEPPER_TIMER_RATE),
     // And to offload calculations from the ISR, we also calculate the inverse of those times here
-    uint32_t acceleration_time_inverse = get_period_inverse(acceleration_time);
-    uint32_t deceleration_time_inverse = get_period_inverse(deceleration_time);
+             acceleration_time_inverse = get_period_inverse(acceleration_time),
+             deceleration_time_inverse = get_period_inverse(deceleration_time);
   #endif
 
   // Store new block parameters
   block->accelerate_until = accelerate_steps;
   block->decelerate_after = accelerate_steps + plateau_steps;
   block->initial_rate = initial_rate;
   #if ENABLED(S_CURVE_ACCELERATION)
     block->acceleration_time = acceleration_time;
     block->deceleration_time = deceleration_time;
     block->acceleration_time_inverse = acceleration_time_inverse;
     block->deceleration_time_inverse = deceleration_time_inverse;
     block->cruise_rate = cruise_rate;
   #endif
   block->final_rate = final_rate;
+
+  /**
+   * Laser trapezoid calculations
+   *
+   * Approximate the trapezoid with the laser, incrementing the power every `entry_per` while accelerating
+   * and decrementing it every `exit_power_per` while decelerating, thus ensuring power is related to feedrate.
+   *
+   * LASER_POWER_INLINE_TRAPEZOID_CONT doesn't need this as it continuously approximates
+   *
+   * Note this may behave unreliably when running with S_CURVE_ACCELERATION
+   */
+  #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
+    if (block->laser.power > 0) { // No need to care if power == 0
+      const uint8_t entry_power = block->laser.power * entry_factor; // Power on block entry
+      #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
+        // Speedup power
+        const uint8_t entry_power_diff = block->laser.power - entry_power;
+        if (entry_power_diff) {
+          block->laser.entry_per = accelerate_steps / entry_power_diff;
+          block->laser.power_entry = entry_power;
+        }
+        else {
+          block->laser.entry_per = 0;
+          block->laser.power_entry = block->laser.power;
+        }
+        // Slowdown power
+        const uint8_t exit_power = block->laser.power * exit_factor, // Power on block entry
+                      exit_power_diff = block->laser.power - exit_power;
+        if (exit_power_diff) {
+          block->laser.exit_per = (block->step_event_count - block->decelerate_after) / exit_power_diff;
+          block->laser.power_exit = exit_power;
+        }
+        else {
+          block->laser.exit_per = 0;
+          block->laser.power_exit = block->laser.power;
+        }
+      #else
+        block->laser.power_entry = entry_power;
+      #endif
+    }
+  #endif
 }
 
 /*                            PLANNER SPEED DEFINITION
                                      +--------+   <- current->nominal_speed
                                     /          \
          current->entry_speed ->   +            \
                                    |             + <- next->entry_speed (aka exit speed)
                                    +-------------+
                                        time -->
 
@@ -1806,20 +1846,26 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #else
     constexpr uint32_t esteps = 0;
   #endif
 
   // Clear all flags, including the "busy" bit
   block->flag = 0x00;
 
   // Set direction bits
   block->direction_bits = dm;
 
+  // Update block laser power
+  #if ENABLED(LASER_POWER_INLINE)
+    block->laser.status = settings.laser.status;
+    block->laser.power = settings.laser.power;
+  #endif
+
   // Number of steps for each axis
   // See http://www.corexy.com/theory.html
   #if CORE_IS_XY
     block->steps.set(ABS(da + db), ABS(da - db), ABS(dc));
   #elif CORE_IS_XZ
     block->steps.set(ABS(da + dc), ABS(db), ABS(da - dc));
   #elif CORE_IS_YZ
     block->steps.set(ABS(da), ABS(db + dc), ABS(db - dc));
   #elif IS_SCARA
     block->steps.set(ABS(da), ABS(db), ABS(dc));

commit fc11e7217460056473f91dfb7dd574884319f567
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 29 16:10:55 2020 -0500

    Fix extra unskew call
    
    Fixes #17264

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c71a0f61cc..e1a050a459 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1512,24 +1512,20 @@ void Planner::check_axes_activity() {
             )
           #elif ENABLED(AUTO_BED_LEVELING_UBL)
             fade_scaling_factor ? fade_scaling_factor * ubl.get_z_correction(raw) : 0.0
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
             fade_scaling_factor ? fade_scaling_factor * bilinear_z_offset(raw) : 0.0
           #endif
         );
 
       #endif
     }
-
-    #if ENABLED(SKEW_CORRECTION)
-      unskew(raw);
-    #endif
   }
 
 #endif // HAS_LEVELING
 
 #if ENABLED(FWRETRACT)
   /**
    * rz, e - Cartesian positions in mm
    */
   void Planner::apply_retract(float &rz, float &e) {
     rz += fwretract.current_hop;

commit adb6334ba031166e33f256344fc2b01e909cd99f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 25 17:55:36 2020 -0500

    Use "dist" instead of "delta" for clarity

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 3b2daf1812..c71a0f61cc 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1641,40 +1641,40 @@ void Planner::synchronize() {
  *  fr_mm_s       - (target) speed of the move
  *  extruder      - target extruder
  *  millimeters   - the length of the movement, if known
  *
  * Returns true if movement was properly queued, false otherwise
  */
 bool Planner::_buffer_steps(const xyze_long_t &target
   #if HAS_POSITION_FLOAT
     , const xyze_pos_t &target_float
   #endif
-  #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
-    , const xyze_float_t &delta_mm_cart
+  #if HAS_DIST_MM_ARG
+    , const xyze_float_t &cart_dist_mm
   #endif
   , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Fill the block with the specified movement
   if (!_populate_block(block, false, target
     #if HAS_POSITION_FLOAT
       , target_float
     #endif
-    #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
-      , delta_mm_cart
+    #if HAS_DIST_MM_ARG
+      , cart_dist_mm
     #endif
     , fr_mm_s, extruder, millimeters
   )) {
     // Movement was not queued, probably because it was too short.
     //  Simply accept that as movement queued and done
     return true;
   }
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
@@ -1705,22 +1705,22 @@ bool Planner::_buffer_steps(const xyze_long_t &target
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *
  * Returns true is movement is acceptable, false otherwise
  */
 bool Planner::_populate_block(block_t * const block, bool split_move,
   const abce_long_t &target
   #if HAS_POSITION_FLOAT
     , const xyze_pos_t &target_float
   #endif
-  #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
-    , const xyze_float_t &delta_mm_cart
+  #if HAS_DIST_MM_ARG
+    , const xyze_float_t &cart_dist_mm
   #endif
   , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
   const int32_t da = target.a - position.a,
                 db = target.b - position.b,
                 dc = target.c - position.c;
 
   #if EXTRUDERS
     int32_t de = target.e - position.e;
@@ -1833,81 +1833,81 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #endif
 
   /**
    * This part of the code calculates the total length of the movement.
    * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
    * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
    * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
    * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
    * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
    */
-  struct DeltaMM : abce_float_t {
+  struct DistanceMM : abce_float_t {
     #if IS_CORE
       xyz_pos_t head;
     #endif
-  } delta_mm;
+  } steps_dist_mm;
   #if IS_CORE
     #if CORE_IS_XY
-      delta_mm.head.x = da * steps_to_mm[A_AXIS];
-      delta_mm.head.y = db * steps_to_mm[B_AXIS];
-      delta_mm.z      = dc * steps_to_mm[Z_AXIS];
-      delta_mm.a      = (da + db) * steps_to_mm[A_AXIS];
-      delta_mm.b      = CORESIGN(da - db) * steps_to_mm[B_AXIS];
+      steps_dist_mm.head.x = da * steps_to_mm[A_AXIS];
+      steps_dist_mm.head.y = db * steps_to_mm[B_AXIS];
+      steps_dist_mm.z      = dc * steps_to_mm[Z_AXIS];
+      steps_dist_mm.a      = (da + db) * steps_to_mm[A_AXIS];
+      steps_dist_mm.b      = CORESIGN(da - db) * steps_to_mm[B_AXIS];
     #elif CORE_IS_XZ
-      delta_mm.head.x = da * steps_to_mm[A_AXIS];
-      delta_mm.y      = db * steps_to_mm[Y_AXIS];
-      delta_mm.head.z = dc * steps_to_mm[C_AXIS];
-      delta_mm.a      = (da + dc) * steps_to_mm[A_AXIS];
-      delta_mm.c      = CORESIGN(da - dc) * steps_to_mm[C_AXIS];
+      steps_dist_mm.head.x = da * steps_to_mm[A_AXIS];
+      steps_dist_mm.y      = db * steps_to_mm[Y_AXIS];
+      steps_dist_mm.head.z = dc * steps_to_mm[C_AXIS];
+      steps_dist_mm.a      = (da + dc) * steps_to_mm[A_AXIS];
+      steps_dist_mm.c      = CORESIGN(da - dc) * steps_to_mm[C_AXIS];
     #elif CORE_IS_YZ
-      delta_mm.x      = da * steps_to_mm[X_AXIS];
-      delta_mm.head.y = db * steps_to_mm[B_AXIS];
-      delta_mm.head.z = dc * steps_to_mm[C_AXIS];
-      delta_mm.b      = (db + dc) * steps_to_mm[B_AXIS];
-      delta_mm.c      = CORESIGN(db - dc) * steps_to_mm[C_AXIS];
+      steps_dist_mm.x      = da * steps_to_mm[X_AXIS];
+      steps_dist_mm.head.y = db * steps_to_mm[B_AXIS];
+      steps_dist_mm.head.z = dc * steps_to_mm[C_AXIS];
+      steps_dist_mm.b      = (db + dc) * steps_to_mm[B_AXIS];
+      steps_dist_mm.c      = CORESIGN(db - dc) * steps_to_mm[C_AXIS];
     #endif
   #else
-    delta_mm.a = da * steps_to_mm[A_AXIS];
-    delta_mm.b = db * steps_to_mm[B_AXIS];
-    delta_mm.c = dc * steps_to_mm[C_AXIS];
+    steps_dist_mm.a = da * steps_to_mm[A_AXIS];
+    steps_dist_mm.b = db * steps_to_mm[B_AXIS];
+    steps_dist_mm.c = dc * steps_to_mm[C_AXIS];
   #endif
 
   #if EXTRUDERS
-    delta_mm.e = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
+    steps_dist_mm.e = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
   #else
-    delta_mm.e = 0.0f;
+    steps_dist_mm.e = 0.0f;
   #endif
 
   #if ENABLED(LCD_SHOW_E_TOTAL)
-    e_move_accumulator += delta_mm.e;
+    e_move_accumulator += steps_dist_mm.e;
   #endif
 
   if (block->steps.a < MIN_STEPS_PER_SEGMENT && block->steps.b < MIN_STEPS_PER_SEGMENT && block->steps.c < MIN_STEPS_PER_SEGMENT) {
     block->millimeters = (0
       #if EXTRUDERS
-        + ABS(delta_mm.e)
+        + ABS(steps_dist_mm.e)
       #endif
     );
   }
   else {
     if (millimeters)
       block->millimeters = millimeters;
     else
       block->millimeters = SQRT(
         #if CORE_IS_XY
-          sq(delta_mm.head.x) + sq(delta_mm.head.y) + sq(delta_mm.z)
+          sq(steps_dist_mm.head.x) + sq(steps_dist_mm.head.y) + sq(steps_dist_mm.z)
         #elif CORE_IS_XZ
-          sq(delta_mm.head.x) + sq(delta_mm.y) + sq(delta_mm.head.z)
+          sq(steps_dist_mm.head.x) + sq(steps_dist_mm.y) + sq(steps_dist_mm.head.z)
         #elif CORE_IS_YZ
-          sq(delta_mm.x) + sq(delta_mm.head.y) + sq(delta_mm.head.z)
+          sq(steps_dist_mm.x) + sq(steps_dist_mm.head.y) + sq(steps_dist_mm.head.z)
         #else
-          sq(delta_mm.x) + sq(delta_mm.y) + sq(delta_mm.z)
+          sq(steps_dist_mm.x) + sq(steps_dist_mm.y) + sq(steps_dist_mm.z)
         #endif
       );
 
     /**
      * At this point at least one of the axes has more steps than
      * MIN_STEPS_PER_SEGMENT, ensuring the segment won't get dropped as
      * zero-length. It's important to not apply corrections
      * to blocks that would get dropped!
      *
      * A correction function is permitted to add steps to an axis, it
@@ -2064,40 +2064,40 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     block->segment_time_us = segment_time_us;
 
     if (was_enabled) stepper.wake_up();
   #endif
 
   block->nominal_speed_sqr = sq(block->millimeters * inverse_secs);   // (mm/sec)^2 Always > 0
   block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM)   // Only for extruder with filament sensor
-      filwidth.advance_e(delta_mm.e);
+      filwidth.advance_e(steps_dist_mm.e);
   #endif
 
   // Calculate and limit speed in mm/sec
 
   xyze_float_t current_speed;
   float speed_factor = 1.0f; // factor <1 decreases speed
 
   // Linear axes first with less logic
   LOOP_XYZ(i) {
-    current_speed[i] = delta_mm[i] * inverse_secs;
+    current_speed[i] = steps_dist_mm[i] * inverse_secs;
     const feedRate_t cs = ABS(current_speed[i]),
                  max_fr = settings.max_feedrate_mm_s[i];
     if (cs > max_fr) NOMORE(speed_factor, max_fr / cs);
   }
 
   // Limit speed on extruders, if any
   #if EXTRUDERS
     {
-      current_speed.e = delta_mm.e * inverse_secs;
+      current_speed.e = steps_dist_mm.e * inverse_secs;
       #if BOTH(MIXING_EXTRUDER, RETRACT_SYNC_MIXING)
         // Move all mixing extruders at the specified rate
         if (mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)
           current_speed.e *= MIXING_STEPPERS;
       #endif
       const feedRate_t cs = ABS(current_speed.e),
                    max_fr = (settings.max_feedrate_mm_s[E_AXIS_N(extruder)]
                               #if BOTH(MIXING_EXTRUDER, RETRACT_SYNC_MIXING)
                                 * MIXING_STEPPERS
                               #endif
@@ -2301,24 +2301,24 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           on then on anything with less sides than an octagon. With this, and the
           reverse pass actually recalculating things, a corner acceleration value
           of 1000 junction deviation of .05 are pretty reasonable. If the cycles
           can be spared, a better acos could be used. For all I know, it may be
           already calculated in a different place. */
 
     // Unit vector of previous path line segment
     static xyze_float_t prev_unit_vec;
 
     xyze_float_t unit_vec =
-      #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
-        delta_mm_cart
+      #if HAS_DIST_MM_ARG
+        cart_dist_mm
       #else
-        { delta_mm.x, delta_mm.y, delta_mm.z, delta_mm.e }
+        { steps_dist_mm.x, steps_dist_mm.y, steps_dist_mm.z, steps_dist_mm.e }
       #endif
     ;
     unit_vec *= inverse_millimeters;
 
     #if IS_CORE && DISABLED(CLASSIC_JERK)
       /**
        * On CoreXY the length of the vector [A,B] is SQRT(2) times the length of the head movement vector [X,Y].
        * So taking Z and E into account, we cannot scale to a unit vector with "inverse_millimeters".
        * => normalize the complete junction vector
        */
@@ -2565,22 +2565,22 @@ void Planner::buffer_sync_block() {
  * Add a new linear movement to the buffer in axis units.
  *
  * Leveling and kinematics should be applied ahead of calling this.
  *
  *  a,b,c,e     - target positions in mm and/or degrees
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *  millimeters - the length of the movement, if known
  */
 bool Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e
-  #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
-    , const xyze_float_t &delta_mm_cart
+  #if HAS_DIST_MM_ARG
+    , const xyze_float_t &cart_dist_mm
   #endif
   , const feedRate_t &fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
     if (last_extruder != extruder && settings.axis_steps_per_mm[E_AXIS_N(extruder)] != settings.axis_steps_per_mm[E_AXIS_N(last_extruder)]) {
@@ -2644,22 +2644,22 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
     SERIAL_ECHOPAIR("->", target.e);
     SERIAL_ECHOLNPGM(")");
   //*/
 
   // Queue the movement
   if (
     !_buffer_steps(target
       #if HAS_POSITION_FLOAT
         , target_float
       #endif
-      #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
-        , delta_mm_cart
+      #if HAS_DIST_MM_ARG
+        , cart_dist_mm
       #endif
       , fr_mm_s, extruder, millimeters
     )
   ) return false;
 
   stepper.wake_up();
   return true;
 } // buffer_segment()
 
 /**
@@ -2679,47 +2679,47 @@ bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, con
   #endif
 ) {
   xyze_pos_t machine = { rx, ry, rz, e };
   #if HAS_POSITION_MODIFIERS
     apply_modifiers(machine);
   #endif
 
   #if IS_KINEMATIC
 
     #if DISABLED(CLASSIC_JERK)
-      const xyze_pos_t delta_mm_cart = {
+      const xyze_pos_t cart_dist_mm = {
         rx - position_cart.x, ry - position_cart.y,
         rz - position_cart.z, e  - position_cart.e
       };
     #else
-      const xyz_pos_t delta_mm_cart = { rx - position_cart.x, ry - position_cart.y, rz - position_cart.z };
+      const xyz_pos_t cart_dist_mm = { rx - position_cart.x, ry - position_cart.y, rz - position_cart.z };
     #endif
 
     float mm = millimeters;
     if (mm == 0.0)
-      mm = (delta_mm_cart.x != 0.0 || delta_mm_cart.y != 0.0) ? delta_mm_cart.magnitude() : ABS(delta_mm_cart.z);
+      mm = (cart_dist_mm.x != 0.0 || cart_dist_mm.y != 0.0) ? cart_dist_mm.magnitude() : ABS(cart_dist_mm.z);
 
     // Cartesian XYZ to kinematic ABC, stored in global 'delta'
     inverse_kinematics(machine);
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
       const float duration_recip = inv_duration ?: fr_mm_s / mm;
       const xyz_pos_t diff = delta - position_float;
       const feedRate_t feedrate = diff.magnitude() * duration_recip;
     #else
       const feedRate_t feedrate = fr_mm_s;
     #endif
     if (buffer_segment(delta.a, delta.b, delta.c, machine.e
       #if DISABLED(CLASSIC_JERK)
-        , delta_mm_cart
+        , cart_dist_mm
       #endif
       , feedrate, extruder, mm
     )) {
       position_cart.set(rx, ry, rz, e);
       return true;
     }
     else
       return false;
   #else
     return buffer_segment(machine, fr_mm_s, extruder, millimeters);

commit 775a4294fc280d7e8c90e429118a2e1dacfb115e
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Mar 15 19:29:18 2020 -0400

    Configurable SLOWDOWN divisor (#17171)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7417749088..3b2daf1812 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2034,21 +2034,24 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   // Get the number of non busy movements in queue (non busy means that they can be altered)
   const uint8_t moves_queued = nonbusy_movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if EITHER(SLOWDOWN, ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time im micro seconds
     uint32_t segment_time_us = LROUND(1000000.0f / inverse_secs);
   #endif
 
   #if ENABLED(SLOWDOWN)
-    if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
+    #ifndef SLOWDOWN_DIVISOR
+      #define SLOWDOWN_DIVISOR 2
+    #endif
+    if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / (SLOWDOWN_DIVISOR) - 1)) {
       if (segment_time_us < settings.min_segment_time_us) {
         // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
         const uint32_t nst = segment_time_us + LROUND(2 * (settings.min_segment_time_us - segment_time_us) / moves_queued);
         inverse_secs = 1000000.0f / nst;
         #if defined(XY_FREQUENCY_LIMIT) || HAS_SPI_LCD
           segment_time_us = nst;
         #endif
       }
     }
   #endif

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index efe4d31ccf..7417749088 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1401,21 +1401,21 @@ void Planner::check_axes_activity() {
    */
   inline float calculate_volumetric_multiplier(const float &diameter) {
     return (parser.volumetric_enabled && diameter) ? 1.0f / CIRCLE_AREA(diameter * 0.5f) : 1;
   }
 
   /**
    * Convert the filament sizes into volumetric multipliers.
    * The multiplier converts a given E value into a length.
    */
   void Planner::calculate_volumetric_multipliers() {
-    for (uint8_t i = 0; i < COUNT(filament_size); i++) {
+    LOOP_L_N(i, COUNT(filament_size)) {
       volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
       refresh_e_factor(i);
     }
   }
 
 #endif // !NO_VOLUMETRICS
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   /**
    * Convert the ratio value given by the filament width sensor
@@ -1984,21 +1984,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   // Enable extruder(s)
   #if EXTRUDERS
     if (esteps) {
       #if ENABLED(AUTO_POWER_CONTROL)
         powerManager.power_on();
       #endif
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
-        for (uint8_t i = 0; i < EXTRUDERS; i++)
+        LOOP_L_N(i, EXTRUDERS)
           if (g_uc_extruder_last_move[i] > 0) g_uc_extruder_last_move[i]--;
 
         #if HAS_DUPLICATION_MODE
           if (extruder_duplication_enabled && extruder == 0) {
             ENABLE_AXIS_E1();
             g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
           }
         #endif
 
         #define ENABLE_ONE_E(N) do{ \

commit 6bead0c1b04152f6a291d851f6cd4029fe0fc616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 16:29:29 2020 -0500

    Shorter paths to HAL, ExtUI (#17156)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index b42cadc3b7..efe4d31ccf 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -94,21 +94,21 @@
 
 #if ENABLED(BACKLASH_COMPENSATION)
   #include "../feature/backlash.h"
 #endif
 
 #if ENABLED(CANCEL_OBJECTS)
   #include "../feature/cancel_object.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
-  #include "../feature/power_loss_recovery.h"
+  #include "../feature/powerloss.h"
 #endif
 
 #if HAS_CUTTER
   #include "../feature/spindle_laser.h"
 #endif
 
 // Delay for delivery of first block to the stepper ISR, if the queue contains 2 or
 // fewer movements. The delay is measured in milliseconds, and must be less than 250ms
 #define BLOCK_DELAY_FOR_1ST_MOVE 100
 

commit 362c9ae79a9f37bddca4cf13d0cf889b84b7e40e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 1 19:08:21 2020 -0600

    Clean up use of extra_xyjerk

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index fe1eec459f..b42cadc3b7 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2397,26 +2397,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     #endif
 
     uint8_t limited = 0;
     #if HAS_LINEAR_E_JERK
       LOOP_XYZ(i)
     #else
       LOOP_XYZE(i)
     #endif
     {
       const float jerk = ABS(current_speed[i]),   // cs : Starting from zero, change in speed for this axis
-                  maxj = (max_jerk[i]             // mj : The max jerk setting for this axis
-                    #ifdef TRAVEL_EXTRA_XYJERK
-                      + (i == X_AXIS || i == Y_AXIS ? extra_xyjerk : 0)
-                    #endif
-                  );
-
+                  maxj = (max_jerk[i] + (i == X_AXIS || i == Y_AXIS ? extra_xyjerk : 0.0f)); // mj : The max jerk setting for this axis
       if (jerk > maxj) {                          // cs > mj : New current speed too fast?
         if (limited) {                            // limited already?
           const float mjerk = nominal_speed * maxj; // ns*mj
           if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk; // ns*mj/cs
         }
         else {
           safe_speed *= maxj / jerk;              // Initial limit: ns*mj/cs
           ++limited;                              // Initially limited
         }
       }
@@ -2454,25 +2449,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           v_entry *= v_factor;
         }
 
         // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
         const float jerk = (v_exit > v_entry)
             ? //                                  coasting             axis reversal
               ( (v_entry > 0 || v_exit < 0) ? (v_exit - v_entry) : _MAX(v_exit, -v_entry) )
             : // v_exit <= v_entry                coasting             axis reversal
               ( (v_entry < 0 || v_exit > 0) ? (v_entry - v_exit) : _MAX(-v_exit, v_entry) );
 
-        const float maxj = (max_jerk[axis]
-          #ifdef TRAVEL_EXTRA_XYJERK
-            + (axis == X_AXIS || axis == Y_AXIS ? extra_xyjerk : 0)
-          #endif
-        );
+        const float maxj = (max_jerk[axis] + (axis == X_AXIS || axis == Y_AXIS ? extra_xyjerk : 0.0f));
 
         if (jerk > maxj) {
           v_factor *= maxj / jerk;
           ++limited;
         }
       }
       if (limited) vmax_junction *= v_factor;
       // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
       // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
       const float vmax_junction_threshold = vmax_junction * 0.99f;

commit 5e9a10dbaeaa885a670af0bd7ef3e7c068f5a7b8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 1 07:36:25 2020 -0600

    Use PSTR for common labels

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 2067ecc23f..fe1eec459f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2621,35 +2621,38 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
   }
 
   /* <-- add a slash to enable
     SERIAL_ECHOPAIR("  buffer_segment FR:", fr_mm_s);
     #if IS_KINEMATIC
       SERIAL_ECHOPAIR(" A:", a);
       SERIAL_ECHOPAIR(" (", position.a);
       SERIAL_ECHOPAIR("->", target.a);
       SERIAL_ECHOPAIR(") B:", b);
     #else
-      SERIAL_ECHOPAIR(" X:", a);
+      SERIAL_ECHOPAIR_P(SP_X_LBL, a);
       SERIAL_ECHOPAIR(" (", position.x);
       SERIAL_ECHOPAIR("->", target.x);
-      SERIAL_ECHOPAIR(") Y:", b);
+      SERIAL_CHAR(')');
+      SERIAL_ECHOPAIR_P(SP_Y_LBL, b);
     #endif
     SERIAL_ECHOPAIR(" (", position.y);
     SERIAL_ECHOPAIR("->", target.y);
     #if ENABLED(DELTA)
       SERIAL_ECHOPAIR(") C:", c);
     #else
-      SERIAL_ECHOPAIR(") Z:", c);
+      SERIAL_CHAR(')');
+      SERIAL_ECHOPAIR_P(SP_Z_LBL, c);
     #endif
     SERIAL_ECHOPAIR(" (", position.z);
     SERIAL_ECHOPAIR("->", target.z);
-    SERIAL_ECHOPAIR(") E:", e);
+    SERIAL_CHAR(')');
+    SERIAL_ECHOPAIR_P(SP_E_LBL, e);
     SERIAL_ECHOPAIR(" (", position.e);
     SERIAL_ECHOPAIR("->", target.e);
     SERIAL_ECHOLNPGM(")");
   //*/
 
   // Queue the movement
   if (
     !_buffer_steps(target
       #if HAS_POSITION_FLOAT
         , target_float

commit 8164cac79703a7e73577539eb267357113b239b2
Author: Makoto Schoppert <makotosan@gmail.com>
Date:   Thu Feb 27 04:29:44 2020 -0500

    Fix planner.cpp compile (#16996)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7c387ac753..2067ecc23f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2396,24 +2396,24 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       constexpr float extra_xyjerk = 0;
     #endif
 
     uint8_t limited = 0;
     #if HAS_LINEAR_E_JERK
       LOOP_XYZ(i)
     #else
       LOOP_XYZE(i)
     #endif
     {
-      const float jerk = ABS(current_speed[i]);   // cs : Starting from zero, change in speed for this axis
-                  maxj = (max_jerk[axis]          // mj : The max jerk setting for this axis
+      const float jerk = ABS(current_speed[i]),   // cs : Starting from zero, change in speed for this axis
+                  maxj = (max_jerk[i]             // mj : The max jerk setting for this axis
                     #ifdef TRAVEL_EXTRA_XYJERK
-                      + (axis == X_AXIS || axis == Y_AXIS ? extra_xyjerk : 0)
+                      + (i == X_AXIS || i == Y_AXIS ? extra_xyjerk : 0)
                     #endif
                   );
 
       if (jerk > maxj) {                          // cs > mj : New current speed too fast?
         if (limited) {                            // limited already?
           const float mjerk = nominal_speed * maxj; // ns*mj
           if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk; // ns*mj/cs
         }
         else {
           safe_speed *= maxj / jerk;              // Initial limit: ns*mj/cs

commit 263a7beeb53a619cc319be2e369ef7604f32af4d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 07:24:36 2020 -0600

    More extra travel jerk changes
    
    Co-Authored-By: josedpedroso <josedpedroso@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index dd1109011e..7c387ac753 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2383,35 +2383,39 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
      * https://github.com/prusa3d/Prusa-Firmware
      */
     CACHED_SQRT(nominal_speed, block->nominal_speed_sqr);
 
     // Exit speed limited by a jerk to full halt of a previous last segment
     static float previous_safe_speed;
 
     // Start with a safe speed (from which the machine may halt to stop immediately).
     float safe_speed = nominal_speed;
 
+    #ifdef TRAVEL_EXTRA_XYJERK
+      const float extra_xyjerk = (de <= 0) ? TRAVEL_EXTRA_XYJERK : 0;
+    #else
+      constexpr float extra_xyjerk = 0;
+    #endif
+
     uint8_t limited = 0;
     #if HAS_LINEAR_E_JERK
       LOOP_XYZ(i)
     #else
       LOOP_XYZE(i)
     #endif
     {
       const float jerk = ABS(current_speed[i]);   // cs : Starting from zero, change in speed for this axis
-
-      float maxj = max_jerk[i];                   // mj : The max jerk setting for this axis
-
-      #ifdef TRAVEL_EXTRA_XYJERK
-        if ((TRAVEL_EXTRA_XYJERK) && !de <= 0 && (i == X_AXIS || i == Y_AXIS))
-          maxj += TRAVEL_EXTRA_XYJERK;            // Extra jerk allowance for travel moves
-      #endif
+                  maxj = (max_jerk[axis]          // mj : The max jerk setting for this axis
+                    #ifdef TRAVEL_EXTRA_XYJERK
+                      + (axis == X_AXIS || axis == Y_AXIS ? extra_xyjerk : 0)
+                    #endif
+                  );
 
       if (jerk > maxj) {                          // cs > mj : New current speed too fast?
         if (limited) {                            // limited already?
           const float mjerk = nominal_speed * maxj; // ns*mj
           if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk; // ns*mj/cs
         }
         else {
           safe_speed *= maxj / jerk;              // Initial limit: ns*mj/cs
           ++limited;                              // Initially limited
         }
@@ -2450,22 +2454,28 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           v_entry *= v_factor;
         }
 
         // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
         const float jerk = (v_exit > v_entry)
             ? //                                  coasting             axis reversal
               ( (v_entry > 0 || v_exit < 0) ? (v_exit - v_entry) : _MAX(v_exit, -v_entry) )
             : // v_exit <= v_entry                coasting             axis reversal
               ( (v_entry < 0 || v_exit > 0) ? (v_entry - v_exit) : _MAX(-v_exit, v_entry) );
 
-        if (jerk > max_jerk[axis]) {
-          v_factor *= max_jerk[axis] / jerk;
+        const float maxj = (max_jerk[axis]
+          #ifdef TRAVEL_EXTRA_XYJERK
+            + (axis == X_AXIS || axis == Y_AXIS ? extra_xyjerk : 0)
+          #endif
+        );
+
+        if (jerk > maxj) {
+          v_factor *= maxj / jerk;
           ++limited;
         }
       }
       if (limited) vmax_junction *= v_factor;
       // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
       // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
       const float vmax_junction_threshold = vmax_junction * 0.99f;
       if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold)
         vmax_junction = safe_speed;
     }

commit 02cce7d4b40e229338619813912ad62f0480fa3a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 06:39:29 2020 -0600

    Add TRAVEL_EXTRA_XYJERK option
    
    See #16949
    
    Co-Authored-By: josedpedroso <josedpedroso@users.noreply.github.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index bf01c771ae..dd1109011e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2390,22 +2390,29 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     // Start with a safe speed (from which the machine may halt to stop immediately).
     float safe_speed = nominal_speed;
 
     uint8_t limited = 0;
     #if HAS_LINEAR_E_JERK
       LOOP_XYZ(i)
     #else
       LOOP_XYZE(i)
     #endif
     {
-      const float jerk = ABS(current_speed[i]),   // cs : Starting from zero, change in speed for this axis
-                  maxj = max_jerk[i];             // mj : The max jerk setting for this axis
+      const float jerk = ABS(current_speed[i]);   // cs : Starting from zero, change in speed for this axis
+
+      float maxj = max_jerk[i];                   // mj : The max jerk setting for this axis
+
+      #ifdef TRAVEL_EXTRA_XYJERK
+        if ((TRAVEL_EXTRA_XYJERK) && !de <= 0 && (i == X_AXIS || i == Y_AXIS))
+          maxj += TRAVEL_EXTRA_XYJERK;            // Extra jerk allowance for travel moves
+      #endif
+
       if (jerk > maxj) {                          // cs > mj : New current speed too fast?
         if (limited) {                            // limited already?
           const float mjerk = nominal_speed * maxj; // ns*mj
           if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk; // ns*mj/cs
         }
         else {
           safe_speed *= maxj / jerk;              // Initial limit: ns*mj/cs
           ++limited;                              // Initially limited
         }
       }

commit e78f607ef33044eecde744e77beea87532817c47
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 03:02:03 2020 -0600

    Use a STR_ prefix for non-translated strings

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index b39ac993b4..bf01c771ae 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1741,21 +1741,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position.e = target.e; // Behave as if the move really took place, but ignore E part
           #if HAS_POSITION_FLOAT
             position_float.e = target_float.e;
           #endif
           de = 0; // no difference
-          SERIAL_ECHO_MSG(MSG_ERR_COLD_EXTRUDE_STOP);
+          SERIAL_ECHO_MSG(STR_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
         const float e_steps = ABS(de * e_factor[extruder]);
         const float max_e_steps = settings.axis_steps_per_mm[E_AXIS_N(extruder)] * (EXTRUDE_MAXLENGTH);
         if (e_steps > max_e_steps) {
           #if ENABLED(MIXING_EXTRUDER)
             bool ignore_e = false;
             float collector[MIXING_STEPPERS];
             mixer.refresh_collector(1.0, mixer.get_current_vtool(), collector);
@@ -1763,21 +1763,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
               if (e_steps * collector[e] > max_e_steps) { ignore_e = true; break; }
           #else
             constexpr bool ignore_e = true;
           #endif
           if (ignore_e) {
             position.e = target.e; // Behave as if the move really took place, but ignore E part
             #if HAS_POSITION_FLOAT
               position_float.e = target_float.e;
             #endif
             de = 0; // no difference
-            SERIAL_ECHO_MSG(MSG_ERR_LONG_EXTRUDE_STOP);
+            SERIAL_ECHO_MSG(STR_ERR_LONG_EXTRUDE_STOP);
           }
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   // Compute direction bit-mask for this block
   uint8_t dm = 0;
   #if CORE_IS_XY
     if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis

commit 0b984519c30f453fdb5b4efb8008a07c69688824
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Feb 14 05:14:37 2020 -0600

    Clean up stepper and babystep (#16857)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 72dfeed46f..b39ac993b4 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -702,20 +702,73 @@ void Planner::init() {
     // so we don't need to reduce precision or to use assembly language at all.
     // This routine, for all other archs, returns 0x100000000 / d ~= 0xFFFFFFFF / d
     static FORCE_INLINE uint32_t get_period_inverse(const uint32_t d) {
       return d ? 0xFFFFFFFF / d : 0xFFFFFFFF;
     }
   #endif
 #endif
 
 #define MINIMAL_STEP_RATE 120
 
+/**
+ * Get the current block for processing
+ * and mark the block as busy.
+ * Return nullptr if the buffer is empty
+ * or if there is a first-block delay.
+ *
+ * WARNING: Called from Stepper ISR context!
+ */
+block_t* Planner::get_current_block() {
+  // Get the number of moves in the planner queue so far
+  const uint8_t nr_moves = movesplanned();
+
+  // If there are any moves queued ...
+  if (nr_moves) {
+
+    // If there is still delay of delivery of blocks running, decrement it
+    if (delay_before_delivering) {
+      --delay_before_delivering;
+      // If the number of movements queued is less than 3, and there is still time
+      //  to wait, do not deliver anything
+      if (nr_moves < 3 && delay_before_delivering) return nullptr;
+      delay_before_delivering = 0;
+    }
+
+    // If we are here, there is no excuse to deliver the block
+    block_t * const block = &block_buffer[block_buffer_tail];
+
+    // No trapezoid calculated? Don't execute yet.
+    if (TEST(block->flag, BLOCK_BIT_RECALCULATE)) return nullptr;
+
+    #if HAS_SPI_LCD
+      block_buffer_runtime_us -= block->segment_time_us; // We can't be sure how long an active block will take, so don't count it.
+    #endif
+
+    // As this block is busy, advance the nonbusy block pointer
+    block_buffer_nonbusy = next_block_index(block_buffer_tail);
+
+    // Push block_buffer_planned pointer, if encountered.
+    if (block_buffer_tail == block_buffer_planned)
+      block_buffer_planned = block_buffer_nonbusy;
+
+    // Return the block
+    return block;
+  }
+
+  // The queue became empty
+  #if HAS_SPI_LCD
+    clear_block_buffer_runtime(); // paranoia. Buffer is empty now - so reset accumulated time to zero.
+  #endif
+
+  return nullptr;
+}
+
 /**
  * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
  * by the provided factors.
  **
  * ############ VERY IMPORTANT ############
  * NOTE that the PRECONDITION to call this function is that the block is
  * NOT BUSY and it is marked as RECALCULATE. That WARRANTIES the Stepper ISR
  * is not and will not use the block while we modify it, so it is safe to
  * alter its values.
  */
@@ -1491,40 +1544,39 @@ void Planner::check_axes_activity() {
 #endif
 
 void Planner::quick_stop() {
 
   // Remove all the queued blocks. Note that this function is NOT
   // called from the Stepper ISR, so we must consider tail as readonly!
   // that is why we set head to tail - But there is a race condition that
   // must be handled: The tail could change between the read and the assignment
   // so this must be enclosed in a critical section
 
-  const bool was_enabled = STEPPER_ISR_ENABLED();
-  if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+  const bool was_enabled = stepper.suspend();
 
   // Drop all queue entries
   block_buffer_nonbusy = block_buffer_planned = block_buffer_head = block_buffer_tail;
 
   // Restart the block delay for the first movement - As the queue was
   // forced to empty, there's no risk the ISR will touch this.
   delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
 
   #if HAS_SPI_LCD
     // Clear the accumulated runtime
     clear_block_buffer_runtime();
   #endif
 
   // Make sure to drop any attempt of queuing moves for at least 1 second
   cleaning_buffer_counter = 1000;
 
   // Reenable Stepper ISR
-  if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+  if (was_enabled) stepper.wake_up();
 
   // And stop the stepper ISR
   stepper.quick_stop();
 }
 
 void Planner::endstop_triggered(const AxisEnum axis) {
   // Record stepper position and discard the current block
   stepper.endstop_triggered(axis);
 }
 
@@ -1541,27 +1593,26 @@ void Planner::finish_and_disable() {
  * Get an axis position according to stepper position(s)
  * For CORE machines apply translation from ABC to XYZ.
  */
 float Planner::get_axis_position_mm(const AxisEnum axis) {
   float axis_steps;
   #if IS_CORE
     // Requesting one of the "core" axes?
     if (axis == CORE_AXIS_1 || axis == CORE_AXIS_2) {
 
       // Protect the access to the position.
-      const bool was_enabled = STEPPER_ISR_ENABLED();
-      if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+      const bool was_enabled = stepper.suspend();
 
       const int32_t p1 = stepper.position(CORE_AXIS_1),
                     p2 = stepper.position(CORE_AXIS_2);
 
-      if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+      if (was_enabled) stepper.wake_up();
 
       // ((a1+a2)+(a1-a2))/2 -> (a1+a2+a1-a2)/2 -> (a1+a1)/2 -> a1
       // ((a1+a2)-(a1-a2))/2 -> (a1+a2-a1+a2)/2 -> (a2+a2)/2 -> a2
       axis_steps = (axis == CORE_AXIS_2 ? CORESIGN(p1 - p2) : p1 + p2) * 0.5f;
     }
     else
       axis_steps = stepper.position(axis);
   #else
     axis_steps = stepper.position(axis);
   #endif
@@ -1997,27 +2048,26 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         inverse_secs = 1000000.0f / nst;
         #if defined(XY_FREQUENCY_LIMIT) || HAS_SPI_LCD
           segment_time_us = nst;
         #endif
       }
     }
   #endif
 
   #if HAS_SPI_LCD
     // Protect the access to the position.
-    const bool was_enabled = STEPPER_ISR_ENABLED();
-    if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+    const bool was_enabled = stepper.suspend();
 
     block_buffer_runtime_us += segment_time_us;
     block->segment_time_us = segment_time_us;
 
-    if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+    if (was_enabled) stepper.wake_up();
   #endif
 
   block->nominal_speed_sqr = sq(block->millimeters * inverse_secs);   // (mm/sec)^2 Always > 0
   block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM)   // Only for extruder with filament sensor
       filwidth.advance_e(delta_mm.e);
   #endif
 
@@ -2815,19 +2865,61 @@ void Planner::set_max_jerk(const AxisEnum axis, float targetValue) {
         #endif
       ;
       limit_and_warn(targetValue, axis, PSTR("Jerk"), max_jerk_edit);
     #endif
     max_jerk[axis] = targetValue;
   #else
     UNUSED(axis); UNUSED(targetValue);
   #endif
 }
 
+#if HAS_SPI_LCD
+
+  uint16_t Planner::block_buffer_runtime() {
+    #ifdef __AVR__
+      // Protect the access to the variable. Only required for AVR, as
+      //  any 32bit CPU offers atomic access to 32bit variables
+      const bool was_enabled = stepper.suspend();
+    #endif
+
+    millis_t bbru = block_buffer_runtime_us;
+
+    #ifdef __AVR__
+      // Reenable Stepper ISR
+      if (was_enabled) stepper.wake_up();
+    #endif
+
+    // To translate ¬µs to ms a division by 1000 would be required.
+    // We introduce 2.4% error here by dividing by 1024.
+    // Doesn't matter because block_buffer_runtime_us is already too small an estimation.
+    bbru >>= 10;
+    // limit to about a minute.
+    NOMORE(bbru, 0xFFFFul);
+    return bbru;
+  }
+
+  void Planner::clear_block_buffer_runtime() {
+    #ifdef __AVR__
+      // Protect the access to the variable. Only required for AVR, as
+      //  any 32bit CPU offers atomic access to 32bit variables
+      const bool was_enabled = stepper.suspend();
+    #endif
+
+    block_buffer_runtime_us = 0;
+
+    #ifdef __AVR__
+      // Reenable Stepper ISR
+      if (was_enabled) stepper.wake_up();
+    #endif
+  }
+
+#endif
+
 #if ENABLED(AUTOTEMP)
 
   void Planner::autotemp_M104_M109() {
     if ((autotemp_enabled = parser.seen('F'))) autotemp_factor = parser.value_float();
     if (parser.seen('S')) autotemp_min = parser.value_celsius();
     if (parser.seen('B')) autotemp_max = parser.value_celsius();
   }
 
 #endif

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 9f5a5c5c5e..72dfeed46f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 90b6324563b806ea7dc24ddf299f055dc4854341
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 04:21:36 2020 -0600

    Encapsulate probe as singleton class (#16751)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 351b089895..9f5a5c5c5e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2772,38 +2772,38 @@ inline void limit_and_warn(float &val, const uint8_t axis, PGM_P const setting_n
   }
 }
 
 void Planner::set_max_acceleration(const uint8_t axis, float targetValue) {
   #if ENABLED(LIMITED_MAX_ACCEL_EDITING)
     #ifdef MAX_ACCEL_EDIT_VALUES
       constexpr xyze_float_t max_accel_edit = MAX_ACCEL_EDIT_VALUES;
       const xyze_float_t &max_acc_edit_scaled = max_accel_edit;
     #else
       constexpr xyze_float_t max_accel_edit = DEFAULT_MAX_ACCELERATION;
-      const xyze_float_t max_acc_edit_scaled = max_accel_edit * 2;
+      constexpr xyze_float_t max_acc_edit_scaled = max_accel_edit * 2;
     #endif
     limit_and_warn(targetValue, axis, PSTR("Acceleration"), max_acc_edit_scaled);
   #endif
   settings.max_acceleration_mm_per_s2[axis] = targetValue;
 
   // Update steps per s2 to agree with the units per s2 (since they are used in the planner)
   reset_acceleration_rates();
 }
 
 void Planner::set_max_feedrate(const uint8_t axis, float targetValue) {
   #if ENABLED(LIMITED_MAX_FR_EDITING)
     #ifdef MAX_FEEDRATE_EDIT_VALUES
       constexpr xyze_float_t max_fr_edit = MAX_FEEDRATE_EDIT_VALUES;
       const xyze_float_t &max_fr_edit_scaled = max_fr_edit;
     #else
       constexpr xyze_float_t max_fr_edit = DEFAULT_MAX_FEEDRATE;
-      const xyze_float_t max_fr_edit_scaled = max_fr_edit * 2;
+      constexpr xyze_float_t max_fr_edit_scaled = max_fr_edit * 2;
     #endif
     limit_and_warn(targetValue, axis, PSTR("Feedrate"), max_fr_edit_scaled);
   #endif
   settings.max_feedrate_mm_s[axis] = targetValue;
 }
 
 void Planner::set_max_jerk(const AxisEnum axis, float targetValue) {
   #if HAS_CLASSIC_JERK
     #if ENABLED(LIMITED_JERK_EDITING)
       constexpr xyze_float_t max_jerk_edit =

commit 50889c0f94778c378357bcc4d4a966fa869bc5c1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 30 03:24:23 2020 -0600

    Move L64XX index_to_axis to progmem (#16697)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 0552206315..351b089895 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1245,27 +1245,27 @@ void Planner::check_axes_activity() {
       #if HAS_HEATER_2
         tail_e_to_p_pressure = baricuda_e_to_p_pressure;
       #endif
     #endif
   }
 
   //
   // Disable inactive axes
   //
   #if ENABLED(DISABLE_X)
-    if (!axis_active.x) disable_X();
+    if (!axis_active.x) DISABLE_AXIS_X();
   #endif
   #if ENABLED(DISABLE_Y)
-    if (!axis_active.y) disable_Y();
+    if (!axis_active.y) DISABLE_AXIS_Y();
   #endif
   #if ENABLED(DISABLE_Z)
-    if (!axis_active.z) disable_Z();
+    if (!axis_active.z) DISABLE_AXIS_Z();
   #endif
   #if ENABLED(DISABLE_E)
     if (!axis_active.e) disable_e_steppers();
   #endif
 
   //
   // Update Fan speeds
   //
   #if FAN_COUNT > 0
 
@@ -1898,81 +1898,81 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #endif
 
   #if ENABLED(AUTO_POWER_CONTROL)
     if (block->steps.x || block->steps.y || block->steps.z)
       powerManager.power_on();
   #endif
 
   // Enable active axes
   #if CORE_IS_XY
     if (block->steps.a || block->steps.b) {
-      enable_X();
-      enable_Y();
+      ENABLE_AXIS_X();
+      ENABLE_AXIS_Y();
     }
     #if DISABLED(Z_LATE_ENABLE)
-      if (block->steps.z) enable_Z();
+      if (block->steps.z) ENABLE_AXIS_Z();
     #endif
   #elif CORE_IS_XZ
     if (block->steps.a || block->steps.c) {
-      enable_X();
-      enable_Z();
+      ENABLE_AXIS_X();
+      ENABLE_AXIS_Z();
     }
-    if (block->steps.y) enable_Y();
+    if (block->steps.y) ENABLE_AXIS_Y();
   #elif CORE_IS_YZ
     if (block->steps.b || block->steps.c) {
-      enable_Y();
-      enable_Z();
+      ENABLE_AXIS_Y();
+      ENABLE_AXIS_Z();
     }
-    if (block->steps.x) enable_X();
+    if (block->steps.x) ENABLE_AXIS_X();
   #else
-    if (block->steps.x) enable_X();
-    if (block->steps.y) enable_Y();
+    if (block->steps.x) ENABLE_AXIS_X();
+    if (block->steps.y) ENABLE_AXIS_Y();
     #if DISABLED(Z_LATE_ENABLE)
-      if (block->steps.z) enable_Z();
+      if (block->steps.z) ENABLE_AXIS_Z();
     #endif
   #endif
 
   // Enable extruder(s)
   #if EXTRUDERS
     if (esteps) {
       #if ENABLED(AUTO_POWER_CONTROL)
         powerManager.power_on();
       #endif
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
         for (uint8_t i = 0; i < EXTRUDERS; i++)
           if (g_uc_extruder_last_move[i] > 0) g_uc_extruder_last_move[i]--;
 
         #if HAS_DUPLICATION_MODE
           if (extruder_duplication_enabled && extruder == 0) {
-            enable_E1();
+            ENABLE_AXIS_E1();
             g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
           }
         #endif
 
         #define ENABLE_ONE_E(N) do{ \
           if (extruder == N) { \
-            enable_E##N(); \
+            ENABLE_AXIS_E##N(); \
             g_uc_extruder_last_move[N] = (BLOCK_BUFFER_SIZE) * 2; \
           } \
           else if (!g_uc_extruder_last_move[N]) \
-            disable_E##N(); \
+            DISABLE_AXIS_E##N(); \
         }while(0);
 
       #else
 
-        #define ENABLE_ONE_E(N) enable_E##N();
+        #define ENABLE_ONE_E(N) ENABLE_AXIS_E##N();
 
       #endif
 
-      REPEAT(EXTRUDERS, ENABLE_ONE_E);
+      REPEAT(EXTRUDERS, ENABLE_ONE_E); // (ENABLE_ONE_E must end with semicolon)
     }
   #endif // EXTRUDERS
 
   if (esteps)
     NOLESS(fr_mm_s, settings.min_feedrate_mm_s);
   else
     NOLESS(fr_mm_s, settings.min_travel_feedrate_mm_s);
 
   const float inverse_millimeters = 1.0f / block->millimeters;  // Inverse millimeters to remove multiple divides
 

commit 248b7dfa591a34a8aa1c6960944e1a3a468ad1de
Author: yangwenxiong <46896566+yangwenxiong@users.noreply.github.com>
Date:   Sat Jan 25 16:13:39 2020 +0800

    BigTreeTech GTR V1.0 / Support 8 extruders, heaters, temp sensors, fans (#16595)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 4c3513c20a..0552206315 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1301,21 +1301,35 @@ void Planner::check_axes_activity() {
 
     #if HAS_FAN0
       FAN_SET(0);
     #endif
     #if HAS_FAN1
       FAN_SET(1);
     #endif
     #if HAS_FAN2
       FAN_SET(2);
     #endif
-
+    #if HAS_FAN3
+      FAN_SET(3);
+    #endif
+    #if HAS_FAN4
+      FAN_SET(4);
+    #endif
+    #if HAS_FAN5
+      FAN_SET(5);
+    #endif
+    #if HAS_FAN6
+      FAN_SET(6);
+    #endif
+    #if HAS_FAN7
+      FAN_SET(7);
+    #endif
   #endif // FAN_COUNT > 0
 
   #if ENABLED(AUTOTEMP)
     getHighESpeed();
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       analogWrite(pin_t(HEATER_1_PIN), tail_valve_pressure);
     #endif

commit c305c2cc6bb71283bf675e92c120aa99ceb030b5
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Jan 14 23:55:26 2020 -0800

    Fix some warnings, Melzi pins

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index cbd320e4c6..4c3513c20a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1388,21 +1388,21 @@ void Planner::check_axes_activity() {
     #if ABL_PLANAR
 
       xy_pos_t d = raw - level_fulcrum;
       apply_rotation_xyz(bed_level_matrix, d.x, d.y, raw.z);
       raw = d + level_fulcrum;
 
     #elif HAS_MESH
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         const float fade_scaling_factor = fade_scaling_factor_for_z(raw.z);
-      #else
+      #elif DISABLED(MESH_BED_LEVELING)
         constexpr float fade_scaling_factor = 1.0;
       #endif
 
       raw.z += (
         #if ENABLED(MESH_BED_LEVELING)
           mbl.get_z(raw
             #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
               , fade_scaling_factor
             #endif
           )
@@ -1425,21 +1425,21 @@ void Planner::check_axes_activity() {
         matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
 
         xy_pos_t d = raw - level_fulcrum;
         apply_rotation_xyz(inverse, d.x, d.y, raw.z);
         raw = d + level_fulcrum;
 
       #elif HAS_MESH
 
         #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
           const float fade_scaling_factor = fade_scaling_factor_for_z(raw.z);
-        #else
+        #elif DISABLED(MESH_BED_LEVELING)
           constexpr float fade_scaling_factor = 1.0;
         #endif
 
         raw.z -= (
           #if ENABLED(MESH_BED_LEVELING)
             mbl.get_z(raw
               #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
                 , fade_scaling_factor
               #endif
             )

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ebf4c1d2eb..cbd320e4c6 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -63,21 +63,21 @@
  */
 
 #include "planner.h"
 #include "stepper.h"
 #include "motion.h"
 #include "temperature.h"
 #include "../lcd/ultralcd.h"
 #include "../core/language.h"
 #include "../gcode/parser.h"
 
-#include "../Marlin.h"
+#include "../MarlinCore.h"
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
 #if ENABLED(BARICUDA)

commit 47edbd92207beb5df761edcf23a0a20927f72152
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Thu Jan 2 03:38:33 2020 +0100

    Fix min limit for acc, feed, jerk (#16416)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 90d688687c..ebf4c1d2eb 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2742,21 +2742,21 @@ void Planner::reset_acceleration_rates() {
 // Recalculate position, steps_to_mm if settings.axis_steps_per_mm changes!
 void Planner::refresh_positioning() {
   LOOP_XYZE_N(i) steps_to_mm[i] = 1.0f / settings.axis_steps_per_mm[i];
   set_position_mm(current_position);
   reset_acceleration_rates();
 }
 
 inline void limit_and_warn(float &val, const uint8_t axis, PGM_P const setting_name, const xyze_float_t &max_limit) {
   const uint8_t lim_axis = axis > E_AXIS ? E_AXIS : axis;
   const float before = val;
-  LIMIT(val, 1, max_limit[lim_axis]);
+  LIMIT(val, 0.1, max_limit[lim_axis]);
   if (before != val) {
     SERIAL_CHAR(axis_codes[lim_axis]);
     SERIAL_ECHOPGM(" Max ");
     serialprintPGM(setting_name);
     SERIAL_ECHOLNPAIR(" limited to ", val);
   }
 }
 
 void Planner::set_max_acceleration(const uint8_t axis, float targetValue) {
   #if ENABLED(LIMITED_MAX_ACCEL_EDITING)

commit 856013cc0fe4c10518a9610561885bbfb01b76f7
Author: Markus Towara <towara@stce.rwth-aachen.de>
Date:   Sat Dec 21 05:04:49 2019 +0100

    Fix planner compile error (#16272)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 50a9beb4d2..90d688687c 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2757,39 +2757,39 @@ inline void limit_and_warn(float &val, const uint8_t axis, PGM_P const setting_n
     SERIAL_ECHOLNPAIR(" limited to ", val);
   }
 }
 
 void Planner::set_max_acceleration(const uint8_t axis, float targetValue) {
   #if ENABLED(LIMITED_MAX_ACCEL_EDITING)
     #ifdef MAX_ACCEL_EDIT_VALUES
       constexpr xyze_float_t max_accel_edit = MAX_ACCEL_EDIT_VALUES;
       const xyze_float_t &max_acc_edit_scaled = max_accel_edit;
     #else
-      constexpr xyze_float_t max_accel_edit = DEFAULT_MAX_ACCELERATION,
-                             max_acc_edit_scaled = max_accel_edit * 2;
+      constexpr xyze_float_t max_accel_edit = DEFAULT_MAX_ACCELERATION;
+      const xyze_float_t max_acc_edit_scaled = max_accel_edit * 2;
     #endif
     limit_and_warn(targetValue, axis, PSTR("Acceleration"), max_acc_edit_scaled);
   #endif
   settings.max_acceleration_mm_per_s2[axis] = targetValue;
 
   // Update steps per s2 to agree with the units per s2 (since they are used in the planner)
   reset_acceleration_rates();
 }
 
 void Planner::set_max_feedrate(const uint8_t axis, float targetValue) {
   #if ENABLED(LIMITED_MAX_FR_EDITING)
     #ifdef MAX_FEEDRATE_EDIT_VALUES
       constexpr xyze_float_t max_fr_edit = MAX_FEEDRATE_EDIT_VALUES;
       const xyze_float_t &max_fr_edit_scaled = max_fr_edit;
     #else
-      constexpr xyze_float_t max_fr_edit = DEFAULT_MAX_FEEDRATE,
-                             max_fr_edit_scaled = max_fr_edit * 2;
+      constexpr xyze_float_t max_fr_edit = DEFAULT_MAX_FEEDRATE;
+      const xyze_float_t max_fr_edit_scaled = max_fr_edit * 2;
     #endif
     limit_and_warn(targetValue, axis, PSTR("Feedrate"), max_fr_edit_scaled);
   #endif
   settings.max_feedrate_mm_s[axis] = targetValue;
 }
 
 void Planner::set_max_jerk(const AxisEnum axis, float targetValue) {
   #if HAS_CLASSIC_JERK
     #if ENABLED(LIMITED_JERK_EDITING)
       constexpr xyze_float_t max_jerk_edit =

commit 98382fcea559020e6e0e242fe22f59c9c151a4c4
Author: Bo Herrmannsen <bo.herrmannsen@gmail.com>
Date:   Fri Dec 13 00:13:49 2019 +0100

    Include Z in SCARA steps feedrate (#16193)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c95426154f..50a9beb4d2 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2613,27 +2613,29 @@ bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, con
         rz - position_cart.z, e  - position_cart.e
       };
     #else
       const xyz_pos_t delta_mm_cart = { rx - position_cart.x, ry - position_cart.y, rz - position_cart.z };
     #endif
 
     float mm = millimeters;
     if (mm == 0.0)
       mm = (delta_mm_cart.x != 0.0 || delta_mm_cart.y != 0.0) ? delta_mm_cart.magnitude() : ABS(delta_mm_cart.z);
 
+    // Cartesian XYZ to kinematic ABC, stored in global 'delta'
     inverse_kinematics(machine);
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
       const float duration_recip = inv_duration ?: fr_mm_s / mm;
-      const feedRate_t feedrate = HYPOT(delta.a - position_float.a, delta.b - position_float.b) * duration_recip;
+      const xyz_pos_t diff = delta - position_float;
+      const feedRate_t feedrate = diff.magnitude() * duration_recip;
     #else
       const feedRate_t feedrate = fr_mm_s;
     #endif
     if (buffer_segment(delta.a, delta.b, delta.c, machine.e
       #if DISABLED(CLASSIC_JERK)
         , delta_mm_cart
       #endif
       , feedrate, extruder, mm
     )) {
       position_cart.set(rx, ry, rz, e);

commit 077eeaa0f45309f353072d0be8c3c256e5f2b100
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Nov 26 18:03:59 2019 -0600

    Fix mixing extruder feedrate (#15905)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 04e8ec5bba..c95426154f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1992,50 +1992,60 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     // Protect the access to the position.
     const bool was_enabled = STEPPER_ISR_ENABLED();
     if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
 
     block_buffer_runtime_us += segment_time_us;
     block->segment_time_us = segment_time_us;
 
     if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
   #endif
 
-  block->nominal_speed_sqr = sq(block->millimeters * inverse_secs);   //   (mm/sec)^2 Always > 0
+  block->nominal_speed_sqr = sq(block->millimeters * inverse_secs);   // (mm/sec)^2 Always > 0
   block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM)   // Only for extruder with filament sensor
       filwidth.advance_e(delta_mm.e);
   #endif
 
-  // Calculate and limit speed in mm/sec for each axis
+  // Calculate and limit speed in mm/sec
+
   xyze_float_t current_speed;
   float speed_factor = 1.0f; // factor <1 decreases speed
-  LOOP_XYZE(i) {
-    #if BOTH(MIXING_EXTRUDER, RETRACT_SYNC_MIXING)
-      // In worst case, only one extruder running, no change is needed.
-      // In best case, all extruders run the same amount, we can divide by MIXING_STEPPERS
-      float delta_mm_i = 0;
-      if (i == E_AXIS && mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)
-        delta_mm_i = delta_mm.e / MIXING_STEPPERS;
-      else
-        delta_mm_i = delta_mm.e;
-    #else
-      const float delta_mm_i = delta_mm[i];
-    #endif
-    const feedRate_t cs = ABS(current_speed[i] = delta_mm_i * inverse_secs);
-    #if ENABLED(DISTINCT_E_FACTORS)
-      if (i == E_AXIS) i += extruder;
-    #endif
-    if (cs > settings.max_feedrate_mm_s[i]) NOMORE(speed_factor, settings.max_feedrate_mm_s[i] / cs);
+
+  // Linear axes first with less logic
+  LOOP_XYZ(i) {
+    current_speed[i] = delta_mm[i] * inverse_secs;
+    const feedRate_t cs = ABS(current_speed[i]),
+                 max_fr = settings.max_feedrate_mm_s[i];
+    if (cs > max_fr) NOMORE(speed_factor, max_fr / cs);
   }
 
+  // Limit speed on extruders, if any
+  #if EXTRUDERS
+    {
+      current_speed.e = delta_mm.e * inverse_secs;
+      #if BOTH(MIXING_EXTRUDER, RETRACT_SYNC_MIXING)
+        // Move all mixing extruders at the specified rate
+        if (mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)
+          current_speed.e *= MIXING_STEPPERS;
+      #endif
+      const feedRate_t cs = ABS(current_speed.e),
+                   max_fr = (settings.max_feedrate_mm_s[E_AXIS_N(extruder)]
+                              #if BOTH(MIXING_EXTRUDER, RETRACT_SYNC_MIXING)
+                                * MIXING_STEPPERS
+                              #endif
+                            );
+      if (cs > max_fr) NOMORE(speed_factor, max_fr / cs);
+    }
+  #endif
+
   // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT
 
     // Check and limit the xy direction change frequency
     const unsigned char direction_change = block->direction_bits ^ old_direction_bits;
     old_direction_bits = block->direction_bits;
     segment_time_us = LROUND((float)segment_time_us / speed_factor);
 
     uint32_t xs0 = axis_segment_time_us[0].x,
              xs1 = axis_segment_time_us[1].x,

commit c1aac3a0c91cd160bfbf242786dc12f09f500eee
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Tue Nov 26 08:58:17 2019 +0000

    Fix delta_mm.e with zero extruders (#15996)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 8b38cef499..04e8ec5bba 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1801,20 +1801,22 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       delta_mm.c      = CORESIGN(db - dc) * steps_to_mm[C_AXIS];
     #endif
   #else
     delta_mm.a = da * steps_to_mm[A_AXIS];
     delta_mm.b = db * steps_to_mm[B_AXIS];
     delta_mm.c = dc * steps_to_mm[C_AXIS];
   #endif
 
   #if EXTRUDERS
     delta_mm.e = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
+  #else
+    delta_mm.e = 0.0f;
   #endif
 
   #if ENABLED(LCD_SHOW_E_TOTAL)
     e_move_accumulator += delta_mm.e;
   #endif
 
   if (block->steps.a < MIN_STEPS_PER_SEGMENT && block->steps.b < MIN_STEPS_PER_SEGMENT && block->steps.c < MIN_STEPS_PER_SEGMENT) {
     block->millimeters = (0
       #if EXTRUDERS
         + ABS(delta_mm.e)

commit 48b7a1e66e9aa96ce2c915843df0ba9e824f783c
Author: LinFor <linfor@gmail.com>
Date:   Mon Nov 11 01:33:56 2019 +0300

    Allow non-zero "fan off" PWM value (#15709)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 99b944ae12..8b38cef499 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1278,23 +1278,23 @@ void Planner::check_axes_activity() {
             fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \
             tail_fan_speed[f] = 255;                   \
           } else if (PENDING(ms, fan_kick_end[f]))     \
             tail_fan_speed[f] = 255;                   \
         } else fan_kick_end[f] = 0
     #else
       #define KICKSTART_FAN(f) NOOP
     #endif
 
     #if FAN_MIN_PWM != 0 || FAN_MAX_PWM != 255
-      #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ? map(tail_fan_speed[f], 1, 255, FAN_MIN_PWM, FAN_MAX_PWM) : 0)
+      #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ? map(tail_fan_speed[f], 1, 255, FAN_MIN_PWM, FAN_MAX_PWM) : FAN_OFF_PWM)
     #else
-      #define CALC_FAN_SPEED(f) tail_fan_speed[f]
+      #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ?: FAN_OFF_PWM)
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       #define _FAN_SET(F) thermalManager.soft_pwm_amount_fan[F] = CALC_FAN_SPEED(F);
     #elif ENABLED(FAST_PWM_FAN)
       #define _FAN_SET(F) set_pwm_duty(FAN##F##_PIN, CALC_FAN_SPEED(F));
     #else
       #define _FAN_SET(F) analogWrite(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(F));
     #endif
     #define FAN_SET(F) do{ KICKSTART_FAN(F); _FAN_SET(F); }while(0)

commit 776632c503540c3bd2061b1b0812c091b3a4f6b4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 9 17:59:04 2019 -0600

    Add and apply REPEAT macro (#15829)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 14319826ef..99b944ae12 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1917,135 +1917,46 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   // Enable extruder(s)
   #if EXTRUDERS
     if (esteps) {
       #if ENABLED(AUTO_POWER_CONTROL)
         powerManager.power_on();
       #endif
 
       #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
-        #define DISABLE_IDLE_E(N) if (!g_uc_extruder_last_move[N]) disable_E##N();
-
         for (uint8_t i = 0; i < EXTRUDERS; i++)
           if (g_uc_extruder_last_move[i] > 0) g_uc_extruder_last_move[i]--;
 
-        switch (extruder) {
-          case 0:
-            #if EXTRUDERS > 1
-              DISABLE_IDLE_E(1);
-              #if EXTRUDERS > 2
-                DISABLE_IDLE_E(2);
-                #if EXTRUDERS > 3
-                  DISABLE_IDLE_E(3);
-                  #if EXTRUDERS > 4
-                    DISABLE_IDLE_E(4);
-                    #if EXTRUDERS > 5
-                      DISABLE_IDLE_E(5);
-                    #endif // EXTRUDERS > 5
-                  #endif // EXTRUDERS > 4
-                #endif // EXTRUDERS > 3
-              #endif // EXTRUDERS > 2
-            #endif // EXTRUDERS > 1
-            enable_E0();
-            g_uc_extruder_last_move[0] = (BLOCK_BUFFER_SIZE) * 2;
-            #if HAS_DUPLICATION_MODE
-              if (extruder_duplication_enabled) {
-                enable_E1();
-                g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
-              }
-            #endif
-          break;
-          #if EXTRUDERS > 1
-            case 1:
-              DISABLE_IDLE_E(0);
-              #if EXTRUDERS > 2
-                DISABLE_IDLE_E(2);
-                #if EXTRUDERS > 3
-                  DISABLE_IDLE_E(3);
-                  #if EXTRUDERS > 4
-                    DISABLE_IDLE_E(4);
-                    #if EXTRUDERS > 5
-                      DISABLE_IDLE_E(5);
-                    #endif // EXTRUDERS > 5
-                  #endif // EXTRUDERS > 4
-                #endif // EXTRUDERS > 3
-              #endif // EXTRUDERS > 2
-              enable_E1();
-              g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
-            break;
-            #if EXTRUDERS > 2
-              case 2:
-                DISABLE_IDLE_E(0);
-                DISABLE_IDLE_E(1);
-                #if EXTRUDERS > 3
-                  DISABLE_IDLE_E(3);
-                  #if EXTRUDERS > 4
-                    DISABLE_IDLE_E(4);
-                    #if EXTRUDERS > 5
-                      DISABLE_IDLE_E(5);
-                    #endif
-                  #endif
-                #endif
-                enable_E2();
-                g_uc_extruder_last_move[2] = (BLOCK_BUFFER_SIZE) * 2;
-              break;
-              #if EXTRUDERS > 3
-                case 3:
-                  DISABLE_IDLE_E(0);
-                  DISABLE_IDLE_E(1);
-                  DISABLE_IDLE_E(2);
-                  #if EXTRUDERS > 4
-                    DISABLE_IDLE_E(4);
-                    #if EXTRUDERS > 5
-                      DISABLE_IDLE_E(5);
-                    #endif
-                  #endif
-                  enable_E3();
-                  g_uc_extruder_last_move[3] = (BLOCK_BUFFER_SIZE) * 2;
-                break;
-                #if EXTRUDERS > 4
-                  case 4:
-                    DISABLE_IDLE_E(0);
-                    DISABLE_IDLE_E(1);
-                    DISABLE_IDLE_E(2);
-                    DISABLE_IDLE_E(3);
-                    #if EXTRUDERS > 5
-                      DISABLE_IDLE_E(5);
-                    #endif
-                    enable_E4();
-                    g_uc_extruder_last_move[4] = (BLOCK_BUFFER_SIZE) * 2;
-                  break;
-                  #if EXTRUDERS > 5
-                    case 5:
-                      DISABLE_IDLE_E(0);
-                      DISABLE_IDLE_E(1);
-                      DISABLE_IDLE_E(2);
-                      DISABLE_IDLE_E(3);
-                      DISABLE_IDLE_E(4);
-                      enable_E5();
-                      g_uc_extruder_last_move[5] = (BLOCK_BUFFER_SIZE) * 2;
-                    break;
-                  #endif // EXTRUDERS > 5
-                #endif // EXTRUDERS > 4
-              #endif // EXTRUDERS > 3
-            #endif // EXTRUDERS > 2
-          #endif // EXTRUDERS > 1
-        }
+        #if HAS_DUPLICATION_MODE
+          if (extruder_duplication_enabled && extruder == 0) {
+            enable_E1();
+            g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
+          }
+        #endif
+
+        #define ENABLE_ONE_E(N) do{ \
+          if (extruder == N) { \
+            enable_E##N(); \
+            g_uc_extruder_last_move[N] = (BLOCK_BUFFER_SIZE) * 2; \
+          } \
+          else if (!g_uc_extruder_last_move[N]) \
+            disable_E##N(); \
+        }while(0);
+
       #else
-        enable_E0();
-        enable_E1();
-        enable_E2();
-        enable_E3();
-        enable_E4();
-        enable_E5();
+
+        #define ENABLE_ONE_E(N) enable_E##N();
+
       #endif
+
+      REPEAT(EXTRUDERS, ENABLE_ONE_E);
     }
   #endif // EXTRUDERS
 
   if (esteps)
     NOLESS(fr_mm_s, settings.min_feedrate_mm_s);
   else
     NOLESS(fr_mm_s, settings.min_travel_feedrate_mm_s);
 
   const float inverse_millimeters = 1.0f / block->millimeters;  // Inverse millimeters to remove multiple divides
 

commit 7a342ecb935e421abfef2f8ed9a8d004f4d30a9f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 27 17:49:27 2019 -0500

    Show Total E during print (#15703)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 9871d4342c..14319826ef 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1803,20 +1803,24 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #else
     delta_mm.a = da * steps_to_mm[A_AXIS];
     delta_mm.b = db * steps_to_mm[B_AXIS];
     delta_mm.c = dc * steps_to_mm[C_AXIS];
   #endif
 
   #if EXTRUDERS
     delta_mm.e = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
   #endif
 
+  #if ENABLED(LCD_SHOW_E_TOTAL)
+    e_move_accumulator += delta_mm.e;
+  #endif
+
   if (block->steps.a < MIN_STEPS_PER_SEGMENT && block->steps.b < MIN_STEPS_PER_SEGMENT && block->steps.c < MIN_STEPS_PER_SEGMENT) {
     block->millimeters = (0
       #if EXTRUDERS
         + ABS(delta_mm.e)
       #endif
     );
   }
   else {
     if (millimeters)
       block->millimeters = millimeters;

commit 93f001295988a335552d8fea5463a112e3aa64e4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 24 15:35:40 2019 -0500

    Cancel Objects - As seen at ERRF2019 (#15590)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 3037ae97fc..9871d4342c 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -89,20 +89,24 @@
 #endif
 
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
 #if ENABLED(BACKLASH_COMPENSATION)
   #include "../feature/backlash.h"
 #endif
 
+#if ENABLED(CANCEL_OBJECTS)
+  #include "../feature/cancel_object.h"
+#endif
+
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/power_loss_recovery.h"
 #endif
 
 #if HAS_CUTTER
   #include "../feature/spindle_laser.h"
 #endif
 
 // Delay for delivery of first block to the stepper ISR, if the queue contains 2 or
 // fewer movements. The delay is measured in milliseconds, and must be less than 250ms
@@ -2590,21 +2594,25 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
     int32_t(LROUND(b * settings.axis_steps_per_mm[B_AXIS])),
     int32_t(LROUND(c * settings.axis_steps_per_mm[C_AXIS])),
     int32_t(LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(extruder)]))
   };
 
   #if HAS_POSITION_FLOAT
     const xyze_pos_t target_float = { a, b, c, e };
   #endif
 
   // DRYRUN prevents E moves from taking place
-  if (DEBUGGING(DRYRUN)) {
+  if (DEBUGGING(DRYRUN)
+    #if ENABLED(CANCEL_OBJECTS)
+      || cancelable.skipping
+    #endif
+  ) {
     position.e = target.e;
     #if HAS_POSITION_FLOAT
       position_float.e = e;
     #endif
   }
 
   /* <-- add a slash to enable
     SERIAL_ECHOPAIR("  buffer_segment FR:", fr_mm_s);
     #if IS_KINEMATIC
       SERIAL_ECHOPAIR(" A:", a);

commit b7b303f4bfbced9f7a242a87af0f50d4cb24d8ae
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 15 16:10:20 2019 -0500

    Spindle/Laser power in planner blocks (#14437)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index d79d96d954..3037ae97fc 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -93,20 +93,24 @@
 #endif
 
 #if ENABLED(BACKLASH_COMPENSATION)
   #include "../feature/backlash.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/power_loss_recovery.h"
 #endif
 
+#if HAS_CUTTER
+  #include "../feature/spindle_laser.h"
+#endif
+
 // Delay for delivery of first block to the stepper ISR, if the queue contains 2 or
 // fewer movements. The delay is measured in milliseconds, and must be less than 250ms
 #define BLOCK_DELAY_FOR_1ST_MOVE 100
 
 Planner planner;
 
   // public:
 
 /**
  * A ring buffer of moves described in steps
@@ -1213,48 +1217,59 @@ void Planner::check_axes_activity() {
     #endif
 
     #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
       for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
         block_t *block = &block_buffer[b];
         LOOP_XYZE(i) if (block->steps[i]) axis_active[i] = true;
       }
     #endif
   }
   else {
+
+    #if HAS_CUTTER
+      cutter.refresh();
+    #endif
+
     #if FAN_COUNT > 0
       FANS_LOOP(i)
         tail_fan_speed[i] = thermalManager.scaledFanSpeed(i);
     #endif
 
     #if ENABLED(BARICUDA)
       #if HAS_HEATER_1
         tail_valve_pressure = baricuda_valve_pressure;
       #endif
       #if HAS_HEATER_2
         tail_e_to_p_pressure = baricuda_e_to_p_pressure;
       #endif
     #endif
   }
 
+  //
+  // Disable inactive axes
+  //
   #if ENABLED(DISABLE_X)
     if (!axis_active.x) disable_X();
   #endif
   #if ENABLED(DISABLE_Y)
     if (!axis_active.y) disable_Y();
   #endif
   #if ENABLED(DISABLE_Z)
     if (!axis_active.z) disable_Z();
   #endif
   #if ENABLED(DISABLE_E)
     if (!axis_active.e) disable_e_steppers();
   #endif
 
+  //
+  // Update Fan speeds
+  //
   #if FAN_COUNT > 0
 
     #if FAN_KICKSTART_TIME > 0
       static millis_t fan_kick_end[FAN_COUNT] = { 0 };
       #define KICKSTART_FAN(f)                         \
         if (tail_fan_speed[f]) {                       \
           millis_t ms = millis();                      \
           if (fan_kick_end[f] == 0) {                  \
             fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \
             tail_fan_speed[f] = 255;                   \
@@ -1834,20 +1849,24 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   block->step_event_count = _MAX(block->steps.a, block->steps.b, block->steps.c, esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   #if ENABLED(MIXING_EXTRUDER)
     MIXER_POPULATE_BLOCK();
   #endif
 
+  #if HAS_CUTTER
+    block->cutter_power = cutter.power;
+  #endif
+
   #if FAN_COUNT > 0
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
   #if EXTRUDERS > 1
@@ -2347,27 +2366,35 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       // Get the lowest speed
       vmax_junction_sqr = _MIN(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
       vmax_junction_sqr = 0;
 
     prev_unit_vec = unit_vec;
 
   #endif
 
+  #ifdef USE_CACHED_SQRT
+    #define CACHED_SQRT(N, V) \
+      static float saved_V, N; \
+      if (V != saved_V) { N = SQRT(V); saved_V = V; }
+  #else
+    #define CACHED_SQRT(N, V) const float N = SQRT(V)
+  #endif
+
   #if HAS_CLASSIC_JERK
 
     /**
      * Adapted from Pr≈Ø≈°a MKS firmware
      * https://github.com/prusa3d/Prusa-Firmware
      */
-    const float nominal_speed = SQRT(block->nominal_speed_sqr);
+    CACHED_SQRT(nominal_speed, block->nominal_speed_sqr);
 
     // Exit speed limited by a jerk to full halt of a previous last segment
     static float previous_safe_speed;
 
     // Start with a safe speed (from which the machine may halt to stop immediately).
     float safe_speed = nominal_speed;
 
     uint8_t limited = 0;
     #if HAS_LINEAR_E_JERK
       LOOP_XYZ(i)
@@ -2394,21 +2421,22 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       // Estimate a maximum velocity allowed at a joint of two successive segments.
       // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
       // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
 
       // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
       float v_factor = 1;
       limited = 0;
 
       // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
       // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
-      const float previous_nominal_speed = SQRT(previous_nominal_speed_sqr);
+      CACHED_SQRT(previous_nominal_speed, previous_nominal_speed_sqr);
+
       vmax_junction = _MIN(nominal_speed, previous_nominal_speed);
 
       // Now limit the jerk in all axes.
       const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
       #if HAS_LINEAR_E_JERK
         LOOP_XYZ(axis)
       #else
         LOOP_XYZE(axis)
       #endif
       {

commit c0005e939cf9c1d9db16f20e605c3228bc41a758
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 8 19:42:18 2019 -0500

    Enable junction deviation by default (#15481)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 17308e48fe..d79d96d954 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -118,32 +118,32 @@ volatile uint8_t Planner::block_buffer_head,    // Index of the next block to be
                  Planner::block_buffer_tail;    // Index of the busy block, if any
 uint16_t Planner::cleaning_buffer_counter;      // A counter to disable queuing of blocks
 uint8_t Planner::delay_before_delivering;       // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
 planner_settings_t Planner::settings;           // Initialized by settings.load()
 
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
 
 float Planner::steps_to_mm[XYZE_N];           // (mm) Millimeters per step
 
-#if ENABLED(JUNCTION_DEVIATION)
+#if DISABLED(CLASSIC_JERK)
   float Planner::junction_deviation_mm;       // (mm) M205 J
   #if ENABLED(LIN_ADVANCE)
     #if ENABLED(DISTINCT_E_FACTORS)
       float Planner::max_e_jerk[EXTRUDERS];   // Calculated from junction_deviation_mm
     #else
       float Planner::max_e_jerk;
     #endif
   #endif
 #endif
 #if HAS_CLASSIC_JERK
-  #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
+  #if HAS_LINEAR_E_JERK
     xyz_pos_t Planner::max_jerk;              // (mm/s^2) M205 XYZ - The largest speed change requiring no acceleration.
   #else
     xyze_pos_t Planner::max_jerk;             // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
   #endif
 #endif
 
 #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
@@ -1557,39 +1557,39 @@ void Planner::synchronize() {
  *  fr_mm_s       - (target) speed of the move
  *  extruder      - target extruder
  *  millimeters   - the length of the movement, if known
  *
  * Returns true if movement was properly queued, false otherwise
  */
 bool Planner::_buffer_steps(const xyze_long_t &target
   #if HAS_POSITION_FLOAT
     , const xyze_pos_t &target_float
   #endif
-  #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+  #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
     , const xyze_float_t &delta_mm_cart
   #endif
   , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Fill the block with the specified movement
   if (!_populate_block(block, false, target
     #if HAS_POSITION_FLOAT
       , target_float
     #endif
-    #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+    #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
       , delta_mm_cart
     #endif
     , fr_mm_s, extruder, millimeters
   )) {
     // Movement was not queued, probably because it was too short.
     //  Simply accept that as movement queued and done
     return true;
   }
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
@@ -1621,21 +1621,21 @@ bool Planner::_buffer_steps(const xyze_long_t &target
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *
  * Returns true is movement is acceptable, false otherwise
  */
 bool Planner::_populate_block(block_t * const block, bool split_move,
   const abce_long_t &target
   #if HAS_POSITION_FLOAT
     , const xyze_pos_t &target_float
   #endif
-  #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+  #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
     , const xyze_float_t &delta_mm_cart
   #endif
   , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
   const int32_t da = target.a - position.a,
                 db = target.b - position.b,
                 dc = target.c - position.c;
 
   #if EXTRUDERS
@@ -2157,21 +2157,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         const float comp = (float)max_acceleration_steps_per_s2[AXIS+INDX] * (float)block->step_event_count; \
         if ((float)accel * (float)block->steps[AXIS] > comp) accel = comp / (float)block->steps[AXIS]; \
       } \
     }while(0)
 
     // Start with print or travel acceleration
     accel = CEIL((esteps ? settings.acceleration : settings.travel_acceleration) * steps_per_mm);
 
     #if ENABLED(LIN_ADVANCE)
 
-      #if ENABLED(JUNCTION_DEVIATION)
+      #if DISABLED(CLASSIC_JERK)
         #if ENABLED(DISTINCT_E_FACTORS)
           #define MAX_E_JERK max_e_jerk[extruder]
         #else
           #define MAX_E_JERK max_e_jerk
         #endif
       #else
         #define MAX_E_JERK max_jerk.e
       #endif
 
       /**
@@ -2245,21 +2245,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         if (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * 2 < SQRT(block->nominal_speed_sqr) * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif
     }
   #endif
 
   float vmax_junction_sqr; // Initial limit on the segment entry velocity (mm/s)^2
 
-  #if ENABLED(JUNCTION_DEVIATION)
+  #if DISABLED(CLASSIC_JERK)
     /**
      * Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
      * Let a circle be tangent to both previous and current path line segments, where the junction
      * deviation is defined as the distance from the junction to the closest edge of the circle,
      * colinear with the circle center. The circular segment joining the two paths represents the
      * path of centripetal acceleration. Solve for max velocity based on max acceleration about the
      * radius of the circle, defined indirectly by junction deviation. This may be also viewed as
      * path width or max_jerk in the previous Grbl version. This approach does not actually deviate
      * from path, but used as a robust way to compute cornering speeds, as it takes into account the
      * nonlinearities of both the junction angle and junction velocity.
@@ -2284,29 +2284,29 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           on then on anything with less sides than an octagon. With this, and the
           reverse pass actually recalculating things, a corner acceleration value
           of 1000 junction deviation of .05 are pretty reasonable. If the cycles
           can be spared, a better acos could be used. For all I know, it may be
           already calculated in a different place. */
 
     // Unit vector of previous path line segment
     static xyze_float_t prev_unit_vec;
 
     xyze_float_t unit_vec =
-      #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+      #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
         delta_mm_cart
       #else
         { delta_mm.x, delta_mm.y, delta_mm.z, delta_mm.e }
       #endif
     ;
     unit_vec *= inverse_millimeters;
 
-    #if IS_CORE && ENABLED(JUNCTION_DEVIATION)
+    #if IS_CORE && DISABLED(CLASSIC_JERK)
       /**
        * On CoreXY the length of the vector [A,B] is SQRT(2) times the length of the head movement vector [X,Y].
        * So taking Z and E into account, we cannot scale to a unit vector with "inverse_millimeters".
        * => normalize the complete junction vector
        */
       normalize_junction_vector(unit_vec);
     #endif
 
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
@@ -2362,21 +2362,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
      */
     const float nominal_speed = SQRT(block->nominal_speed_sqr);
 
     // Exit speed limited by a jerk to full halt of a previous last segment
     static float previous_safe_speed;
 
     // Start with a safe speed (from which the machine may halt to stop immediately).
     float safe_speed = nominal_speed;
 
     uint8_t limited = 0;
-    #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
+    #if HAS_LINEAR_E_JERK
       LOOP_XYZ(i)
     #else
       LOOP_XYZE(i)
     #endif
     {
       const float jerk = ABS(current_speed[i]),   // cs : Starting from zero, change in speed for this axis
                   maxj = max_jerk[i];             // mj : The max jerk setting for this axis
       if (jerk > maxj) {                          // cs > mj : New current speed too fast?
         if (limited) {                            // limited already?
           const float mjerk = nominal_speed * maxj; // ns*mj
@@ -2399,21 +2399,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       float v_factor = 1;
       limited = 0;
 
       // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
       // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
       const float previous_nominal_speed = SQRT(previous_nominal_speed_sqr);
       vmax_junction = _MIN(nominal_speed, previous_nominal_speed);
 
       // Now limit the jerk in all axes.
       const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
-      #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
+      #if HAS_LINEAR_E_JERK
         LOOP_XYZ(axis)
       #else
         LOOP_XYZE(axis)
       #endif
       {
         // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
         float v_exit = previous_speed[axis] * smaller_speed_factor,
               v_entry = current_speed[axis];
         if (limited) {
           v_exit *= v_factor;
@@ -2437,21 +2437,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
       const float vmax_junction_threshold = vmax_junction * 0.99f;
       if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold)
         vmax_junction = safe_speed;
     }
     else
       vmax_junction = safe_speed;
 
     previous_safe_speed = safe_speed;
 
-    #if ENABLED(JUNCTION_DEVIATION)
+    #if DISABLED(CLASSIC_JERK)
       vmax_junction_sqr = _MIN(vmax_junction_sqr, sq(vmax_junction));
     #else
       vmax_junction_sqr = sq(vmax_junction);
     #endif
 
   #endif // Classic Jerk Limiting
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed_sqr = vmax_junction_sqr;
 
@@ -2531,21 +2531,21 @@ void Planner::buffer_sync_block() {
  * Add a new linear movement to the buffer in axis units.
  *
  * Leveling and kinematics should be applied ahead of calling this.
  *
  *  a,b,c,e     - target positions in mm and/or degrees
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *  millimeters - the length of the movement, if known
  */
 bool Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e
-  #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+  #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
     , const xyze_float_t &delta_mm_cart
   #endif
   , const feedRate_t &fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
@@ -2603,21 +2603,21 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
     SERIAL_ECHOPAIR("->", target.e);
     SERIAL_ECHOLNPGM(")");
   //*/
 
   // Queue the movement
   if (
     !_buffer_steps(target
       #if HAS_POSITION_FLOAT
         , target_float
       #endif
-      #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+      #if IS_KINEMATIC && DISABLED(CLASSIC_JERK)
         , delta_mm_cart
       #endif
       , fr_mm_s, extruder, millimeters
     )
   ) return false;
 
   stepper.wake_up();
   return true;
 } // buffer_segment()
 
@@ -2637,21 +2637,21 @@ bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, con
     , const float &inv_duration
   #endif
 ) {
   xyze_pos_t machine = { rx, ry, rz, e };
   #if HAS_POSITION_MODIFIERS
     apply_modifiers(machine);
   #endif
 
   #if IS_KINEMATIC
 
-    #if ENABLED(JUNCTION_DEVIATION)
+    #if DISABLED(CLASSIC_JERK)
       const xyze_pos_t delta_mm_cart = {
         rx - position_cart.x, ry - position_cart.y,
         rz - position_cart.z, e  - position_cart.e
       };
     #else
       const xyz_pos_t delta_mm_cart = { rx - position_cart.x, ry - position_cart.y, rz - position_cart.z };
     #endif
 
     float mm = millimeters;
     if (mm == 0.0)
@@ -2661,21 +2661,21 @@ bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, con
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
       const float duration_recip = inv_duration ?: fr_mm_s / mm;
       const feedRate_t feedrate = HYPOT(delta.a - position_float.a, delta.b - position_float.b) * duration_recip;
     #else
       const feedRate_t feedrate = fr_mm_s;
     #endif
     if (buffer_segment(delta.a, delta.b, delta.c, machine.e
-      #if ENABLED(JUNCTION_DEVIATION)
+      #if DISABLED(CLASSIC_JERK)
         , delta_mm_cart
       #endif
       , feedrate, extruder, mm
     )) {
       position_cart.set(rx, ry, rz, e);
       return true;
     }
     else
       return false;
   #else
@@ -2762,21 +2762,21 @@ void Planner::reset_acceleration_rates() {
     #define AXIS_CONDITION (i < E_AXIS || i == E_AXIS_N(active_extruder))
   #else
     #define AXIS_CONDITION true
   #endif
   uint32_t highest_rate = 1;
   LOOP_XYZE_N(i) {
     max_acceleration_steps_per_s2[i] = settings.max_acceleration_mm_per_s2[i] * settings.axis_steps_per_mm[i];
     if (AXIS_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   }
   cutoff_long = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
-  #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
+  #if HAS_LINEAR_E_JERK
     recalculate_max_e_jerk();
   #endif
 }
 
 // Recalculate position, steps_to_mm if settings.axis_steps_per_mm changes!
 void Planner::refresh_positioning() {
   LOOP_XYZE_N(i) steps_to_mm[i] = 1.0f / settings.axis_steps_per_mm[i];
   set_position_mm(current_position);
   reset_acceleration_rates();
 }

commit 1df6c7a46c3be610377ee2fe33cef36cad5ef255
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 8 19:27:03 2019 -0500

    Work around a compiler bug
    
    See #15478

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 62747af431..17308e48fe 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1343,20 +1343,29 @@ void Planner::check_axes_activity() {
 
     volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = parser.volumetric_enabled
       ? ratio_2 / CIRCLE_AREA(filwidth.nominal_mm * 0.5f) // Volumetric uses a true volumetric multiplier
       : ratio_2;                                          // Linear squares the ratio, which scales the volume
 
     refresh_e_factor(FILAMENT_SENSOR_EXTRUDER_NUM);
   }
 #endif
 
 #if HAS_LEVELING
+
+  constexpr xy_pos_t level_fulcrum = {
+    #if ENABLED(Z_SAFE_HOMING)
+      Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT
+    #else
+      X_HOME_POS, Y_HOME_POS
+    #endif
+  };
+
   /**
    * rx, ry, rz - Cartesian positions in mm
    *              Leveled XYZ on completion
    */
   void Planner::apply_leveling(xyz_pos_t &raw) {
     if (!leveling_active) return;
 
     #if ABL_PLANAR
 
       xy_pos_t d = raw - level_fulcrum;

commit 438835f6a52ab23c9b0114a27d35941a34648592
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Oct 1 20:59:48 2019 -0400

    Configurable Max Accel, Max Feedrate, Max Jerk edit limits (#13929)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 8d488e1f98..62747af431 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2646,21 +2646,21 @@ bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, con
 
     float mm = millimeters;
     if (mm == 0.0)
       mm = (delta_mm_cart.x != 0.0 || delta_mm_cart.y != 0.0) ? delta_mm_cart.magnitude() : ABS(delta_mm_cart.z);
 
     inverse_kinematics(machine);
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
-      const float duration_recip = inv_duration ? inv_duration : fr_mm_s / mm;
+      const float duration_recip = inv_duration ?: fr_mm_s / mm;
       const feedRate_t feedrate = HYPOT(delta.a - position_float.a, delta.b - position_float.b) * duration_recip;
     #else
       const feedRate_t feedrate = fr_mm_s;
     #endif
     if (buffer_segment(delta.a, delta.b, delta.c, machine.e
       #if ENABLED(JUNCTION_DEVIATION)
         , delta_mm_cart
       #endif
       , feedrate, extruder, mm
     )) {
@@ -2765,19 +2765,81 @@ void Planner::reset_acceleration_rates() {
   #endif
 }
 
 // Recalculate position, steps_to_mm if settings.axis_steps_per_mm changes!
 void Planner::refresh_positioning() {
   LOOP_XYZE_N(i) steps_to_mm[i] = 1.0f / settings.axis_steps_per_mm[i];
   set_position_mm(current_position);
   reset_acceleration_rates();
 }
 
+inline void limit_and_warn(float &val, const uint8_t axis, PGM_P const setting_name, const xyze_float_t &max_limit) {
+  const uint8_t lim_axis = axis > E_AXIS ? E_AXIS : axis;
+  const float before = val;
+  LIMIT(val, 1, max_limit[lim_axis]);
+  if (before != val) {
+    SERIAL_CHAR(axis_codes[lim_axis]);
+    SERIAL_ECHOPGM(" Max ");
+    serialprintPGM(setting_name);
+    SERIAL_ECHOLNPAIR(" limited to ", val);
+  }
+}
+
+void Planner::set_max_acceleration(const uint8_t axis, float targetValue) {
+  #if ENABLED(LIMITED_MAX_ACCEL_EDITING)
+    #ifdef MAX_ACCEL_EDIT_VALUES
+      constexpr xyze_float_t max_accel_edit = MAX_ACCEL_EDIT_VALUES;
+      const xyze_float_t &max_acc_edit_scaled = max_accel_edit;
+    #else
+      constexpr xyze_float_t max_accel_edit = DEFAULT_MAX_ACCELERATION,
+                             max_acc_edit_scaled = max_accel_edit * 2;
+    #endif
+    limit_and_warn(targetValue, axis, PSTR("Acceleration"), max_acc_edit_scaled);
+  #endif
+  settings.max_acceleration_mm_per_s2[axis] = targetValue;
+
+  // Update steps per s2 to agree with the units per s2 (since they are used in the planner)
+  reset_acceleration_rates();
+}
+
+void Planner::set_max_feedrate(const uint8_t axis, float targetValue) {
+  #if ENABLED(LIMITED_MAX_FR_EDITING)
+    #ifdef MAX_FEEDRATE_EDIT_VALUES
+      constexpr xyze_float_t max_fr_edit = MAX_FEEDRATE_EDIT_VALUES;
+      const xyze_float_t &max_fr_edit_scaled = max_fr_edit;
+    #else
+      constexpr xyze_float_t max_fr_edit = DEFAULT_MAX_FEEDRATE,
+                             max_fr_edit_scaled = max_fr_edit * 2;
+    #endif
+    limit_and_warn(targetValue, axis, PSTR("Feedrate"), max_fr_edit_scaled);
+  #endif
+  settings.max_feedrate_mm_s[axis] = targetValue;
+}
+
+void Planner::set_max_jerk(const AxisEnum axis, float targetValue) {
+  #if HAS_CLASSIC_JERK
+    #if ENABLED(LIMITED_JERK_EDITING)
+      constexpr xyze_float_t max_jerk_edit =
+        #ifdef MAX_JERK_EDIT_VALUES
+          MAX_JERK_EDIT_VALUES
+        #else
+          { (DEFAULT_XJERK) * 2, (DEFAULT_YJERK) * 2,
+            (DEFAULT_ZJERK) * 2, (DEFAULT_EJERK) * 2 }
+        #endif
+      ;
+      limit_and_warn(targetValue, axis, PSTR("Jerk"), max_jerk_edit);
+    #endif
+    max_jerk[axis] = targetValue;
+  #else
+    UNUSED(axis); UNUSED(targetValue);
+  #endif
+}
+
 #if ENABLED(AUTOTEMP)
 
   void Planner::autotemp_M104_M109() {
     if ((autotemp_enabled = parser.seen('F'))) autotemp_factor = parser.value_float();
     if (parser.seen('S')) autotemp_min = parser.value_celsius();
     if (parser.seen('B')) autotemp_max = parser.value_celsius();
   }
 
 #endif

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 2715221f32..8d488e1f98 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -130,23 +130,23 @@ float Planner::steps_to_mm[XYZE_N];           // (mm) Millimeters per step
   #if ENABLED(LIN_ADVANCE)
     #if ENABLED(DISTINCT_E_FACTORS)
       float Planner::max_e_jerk[EXTRUDERS];   // Calculated from junction_deviation_mm
     #else
       float Planner::max_e_jerk;
     #endif
   #endif
 #endif
 #if HAS_CLASSIC_JERK
   #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
-    float Planner::max_jerk[XYZ];             // (mm/s^2) M205 XYZ - The largest speed change requiring no acceleration.
+    xyz_pos_t Planner::max_jerk;              // (mm/s^2) M205 XYZ - The largest speed change requiring no acceleration.
   #else
-    float Planner::max_jerk[XYZE];            // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
+    xyze_pos_t Planner::max_jerk;             // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
   #endif
 #endif
 
 #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
@@ -180,69 +180,69 @@ skew_factor_t Planner::skew_factor; // Initialized by settings.load()
 
 #if ENABLED(AUTOTEMP)
   float Planner::autotemp_max = 250,
         Planner::autotemp_min = 210,
         Planner::autotemp_factor = 0.1f;
   bool Planner::autotemp_enabled = false;
 #endif
 
 // private:
 
-int32_t Planner::position[NUM_AXIS] = { 0 };
+xyze_long_t Planner::position{0};
 
 uint32_t Planner::cutoff_long;
 
-float Planner::previous_speed[NUM_AXIS],
-      Planner::previous_nominal_speed_sqr;
+xyze_float_t Planner::previous_speed;
+float Planner::previous_nominal_speed_sqr;
 
 #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
   uint8_t Planner::g_uc_extruder_last_move[EXTRUDERS] = { 0 };
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
   // Old direction bits. Used for speed calculations
   unsigned char Planner::old_direction_bits = 0;
   // Segment times (in ¬µs). Used for speed calculations
-  uint32_t Planner::axis_segment_time_us[2][3] = { { MAX_FREQ_TIME_US + 1, 0, 0 }, { MAX_FREQ_TIME_US + 1, 0, 0 } };
+  xy_ulong_t Planner::axis_segment_time_us[3] = { { MAX_FREQ_TIME_US + 1, MAX_FREQ_TIME_US + 1 } };
 #endif
 
 #if ENABLED(LIN_ADVANCE)
   float Planner::extruder_advance_K[EXTRUDERS]; // Initialized by settings.load()
 #endif
 
 #if HAS_POSITION_FLOAT
-  float Planner::position_float[XYZE]; // Needed for accurate maths. Steps cannot be used!
+  xyze_pos_t Planner::position_float; // Needed for accurate maths. Steps cannot be used!
 #endif
 
 #if IS_KINEMATIC
-  float Planner::position_cart[XYZE];
+  xyze_pos_t Planner::position_cart;
 #endif
 
 #if HAS_SPI_LCD
   volatile uint32_t Planner::block_buffer_runtime_us = 0;
 #endif
 
 /**
  * Class and Instance Methods
  */
 
 Planner::Planner() { init(); }
 
 void Planner::init() {
-  ZERO(position);
+  position.reset();
   #if HAS_POSITION_FLOAT
-    ZERO(position_float);
+    position_float.reset();
   #endif
   #if IS_KINEMATIC
-    ZERO(position_cart);
+    position_cart.reset();
   #endif
-  ZERO(previous_speed);
+  previous_speed.reset();
   previous_nominal_speed_sqr = 0;
   #if ABL_PLANAR
     bed_level_matrix.set_to_identity();
   #endif
   clear_block_buffer();
   delay_before_delivering = 0;
 }
 
 #if ENABLED(S_CURVE_ACCELERATION)
   #ifdef __AVR__
@@ -1148,42 +1148,42 @@ void Planner::recalculate() {
 
   void Planner::getHighESpeed() {
     static float oldt = 0;
 
     if (!autotemp_enabled) return;
     if (thermalManager.degTargetHotend(0) + 2 < autotemp_min) return; // probably temperature set to zero.
 
     float high = 0.0;
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block_t* block = &block_buffer[b];
-      if (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS]) {
-        const float se = (float)block->steps[E_AXIS] / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;
+      if (block->steps.x || block->steps.y || block->steps.z) {
+        const float se = (float)block->steps.e / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;
         NOLESS(high, se);
       }
     }
 
     float t = autotemp_min + high * autotemp_factor;
     LIMIT(t, autotemp_min, autotemp_max);
     if (t < oldt) t = t * (1 - float(AUTOTEMP_OLDWEIGHT)) + oldt * float(AUTOTEMP_OLDWEIGHT);
     oldt = t;
     thermalManager.setTargetHotend(t, 0);
   }
 
 #endif // AUTOTEMP
 
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
 
   #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
-    uint8_t axis_active[NUM_AXIS] = { 0 };
+    xyze_bool_t axis_active = { false };
   #endif
 
   #if FAN_COUNT > 0
     uint8_t tail_fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
     #endif
@@ -1229,30 +1229,30 @@ void Planner::check_axes_activity() {
       #if HAS_HEATER_1
         tail_valve_pressure = baricuda_valve_pressure;
       #endif
       #if HAS_HEATER_2
         tail_e_to_p_pressure = baricuda_e_to_p_pressure;
       #endif
     #endif
   }
 
   #if ENABLED(DISABLE_X)
-    if (!axis_active[X_AXIS]) disable_X();
+    if (!axis_active.x) disable_X();
   #endif
   #if ENABLED(DISABLE_Y)
-    if (!axis_active[Y_AXIS]) disable_Y();
+    if (!axis_active.y) disable_Y();
   #endif
   #if ENABLED(DISABLE_Z)
-    if (!axis_active[Z_AXIS]) disable_Z();
+    if (!axis_active.z) disable_Z();
   #endif
   #if ENABLED(DISABLE_E)
-    if (!axis_active[E_AXIS]) disable_e_steppers();
+    if (!axis_active.e) disable_e_steppers();
   #endif
 
   #if FAN_COUNT > 0
 
     #if FAN_KICKSTART_TIME > 0
       static millis_t fan_kick_end[FAN_COUNT] = { 0 };
       #define KICKSTART_FAN(f)                         \
         if (tail_fan_speed[f]) {                       \
           millis_t ms = millis();                      \
           if (fan_kick_end[f] == 0) {                  \
@@ -1347,105 +1347,93 @@ void Planner::check_axes_activity() {
 
     refresh_e_factor(FILAMENT_SENSOR_EXTRUDER_NUM);
   }
 #endif
 
 #if HAS_LEVELING
   /**
    * rx, ry, rz - Cartesian positions in mm
    *              Leveled XYZ on completion
    */
-  void Planner::apply_leveling(float &rx, float &ry, float &rz) {
+  void Planner::apply_leveling(xyz_pos_t &raw) {
     if (!leveling_active) return;
 
     #if ABL_PLANAR
 
-      float dx = rx - (X_TILT_FULCRUM),
-            dy = ry - (Y_TILT_FULCRUM);
-
-      apply_rotation_xyz(bed_level_matrix, dx, dy, rz);
-
-      rx = dx + X_TILT_FULCRUM;
-      ry = dy + Y_TILT_FULCRUM;
+      xy_pos_t d = raw - level_fulcrum;
+      apply_rotation_xyz(bed_level_matrix, d.x, d.y, raw.z);
+      raw = d + level_fulcrum;
 
     #elif HAS_MESH
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        const float fade_scaling_factor = fade_scaling_factor_for_z(rz);
+        const float fade_scaling_factor = fade_scaling_factor_for_z(raw.z);
       #else
         constexpr float fade_scaling_factor = 1.0;
       #endif
 
-      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-        const float raw[XYZ] = { rx, ry, 0 };
-      #endif
-
-      rz += (
+      raw.z += (
         #if ENABLED(MESH_BED_LEVELING)
-          mbl.get_z(rx, ry
+          mbl.get_z(raw
             #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
               , fade_scaling_factor
             #endif
           )
         #elif ENABLED(AUTO_BED_LEVELING_UBL)
-          fade_scaling_factor ? fade_scaling_factor * ubl.get_z_correction(rx, ry) : 0.0
+          fade_scaling_factor ? fade_scaling_factor * ubl.get_z_correction(raw) : 0.0
         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
           fade_scaling_factor ? fade_scaling_factor * bilinear_z_offset(raw) : 0.0
         #endif
       );
 
     #endif
   }
 
-  void Planner::unapply_leveling(float raw[XYZ]) {
+  void Planner::unapply_leveling(xyz_pos_t &raw) {
 
     if (leveling_active) {
 
       #if ABL_PLANAR
 
         matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
 
-        float dx = raw[X_AXIS] - (X_TILT_FULCRUM),
-              dy = raw[Y_AXIS] - (Y_TILT_FULCRUM);
-
-        apply_rotation_xyz(inverse, dx, dy, raw[Z_AXIS]);
-
-        raw[X_AXIS] = dx + X_TILT_FULCRUM;
-        raw[Y_AXIS] = dy + Y_TILT_FULCRUM;
+        xy_pos_t d = raw - level_fulcrum;
+        apply_rotation_xyz(inverse, d.x, d.y, raw.z);
+        raw = d + level_fulcrum;
 
       #elif HAS_MESH
 
         #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-          const float fade_scaling_factor = fade_scaling_factor_for_z(raw[Z_AXIS]);
+          const float fade_scaling_factor = fade_scaling_factor_for_z(raw.z);
         #else
           constexpr float fade_scaling_factor = 1.0;
         #endif
 
-        raw[Z_AXIS] -= (
+        raw.z -= (
           #if ENABLED(MESH_BED_LEVELING)
-            mbl.get_z(raw[X_AXIS], raw[Y_AXIS]
+            mbl.get_z(raw
               #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
                 , fade_scaling_factor
               #endif
             )
           #elif ENABLED(AUTO_BED_LEVELING_UBL)
-            fade_scaling_factor ? fade_scaling_factor * ubl.get_z_correction(raw[X_AXIS], raw[Y_AXIS]) : 0.0
+            fade_scaling_factor ? fade_scaling_factor * ubl.get_z_correction(raw) : 0.0
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
             fade_scaling_factor ? fade_scaling_factor * bilinear_z_offset(raw) : 0.0
           #endif
         );
 
       #endif
     }
 
     #if ENABLED(SKEW_CORRECTION)
-      unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]);
+      unskew(raw);
     #endif
   }
 
 #endif // HAS_LEVELING
 
 #if ENABLED(FWRETRACT)
   /**
    * rz, e - Cartesian positions in mm
    */
   void Planner::apply_retract(float &rz, float &e) {
@@ -1556,26 +1544,26 @@ void Planner::synchronize() {
  * Add a new linear movement to the planner queue (in terms of steps).
  *
  *  target        - target position in steps units
  *  target_float  - target position in direct (mm, degrees) units. optional
  *  fr_mm_s       - (target) speed of the move
  *  extruder      - target extruder
  *  millimeters   - the length of the movement, if known
  *
  * Returns true if movement was properly queued, false otherwise
  */
-bool Planner::_buffer_steps(const int32_t (&target)[XYZE]
+bool Planner::_buffer_steps(const xyze_long_t &target
   #if HAS_POSITION_FLOAT
-    , const float (&target_float)[ABCE]
+    , const xyze_pos_t &target_float
   #endif
   #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
-    , const float (&delta_mm_cart)[XYZE]
+    , const xyze_float_t &delta_mm_cart
   #endif
   , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
@@ -1620,80 +1608,80 @@ bool Planner::_buffer_steps(const int32_t (&target)[XYZE]
  *
  * Fills a new linear movement in the block (in terms of steps).
  *
  *  target      - target position in steps units
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *
  * Returns true is movement is acceptable, false otherwise
  */
 bool Planner::_populate_block(block_t * const block, bool split_move,
-  const int32_t (&target)[ABCE]
+  const abce_long_t &target
   #if HAS_POSITION_FLOAT
-    , const float (&target_float)[ABCE]
+    , const xyze_pos_t &target_float
   #endif
   #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
-    , const float (&delta_mm_cart)[XYZE]
+    , const xyze_float_t &delta_mm_cart
   #endif
   , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
-  const int32_t da = target[A_AXIS] - position[A_AXIS],
-                db = target[B_AXIS] - position[B_AXIS],
-                dc = target[C_AXIS] - position[C_AXIS];
+  const int32_t da = target.a - position.a,
+                db = target.b - position.b,
+                dc = target.c - position.c;
 
   #if EXTRUDERS
-    int32_t de = target[E_AXIS] - position[E_AXIS];
+    int32_t de = target.e - position.e;
   #else
     constexpr int32_t de = 0;
   #endif
 
   /* <-- add a slash to enable
     SERIAL_ECHOLNPAIR("  _populate_block FR:", fr_mm_s,
-                      " A:", target[A_AXIS], " (", da, " steps)"
-                      " B:", target[B_AXIS], " (", db, " steps)"
-                      " C:", target[C_AXIS], " (", dc, " steps)"
+                      " A:", target.a, " (", da, " steps)"
+                      " B:", target.b, " (", db, " steps)"
+                      " C:", target.c, " (", dc, " steps)"
                       #if EXTRUDERS
-                        " E:", target[E_AXIS], " (", de, " steps)"
+                        " E:", target.e, " (", de, " steps)"
                       #endif
                     );
   //*/
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
-          position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
+          position.e = target.e; // Behave as if the move really took place, but ignore E part
           #if HAS_POSITION_FLOAT
-            position_float[E_AXIS] = target_float[E_AXIS];
+            position_float.e = target_float.e;
           #endif
           de = 0; // no difference
           SERIAL_ECHO_MSG(MSG_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
         const float e_steps = ABS(de * e_factor[extruder]);
         const float max_e_steps = settings.axis_steps_per_mm[E_AXIS_N(extruder)] * (EXTRUDE_MAXLENGTH);
         if (e_steps > max_e_steps) {
           #if ENABLED(MIXING_EXTRUDER)
             bool ignore_e = false;
             float collector[MIXING_STEPPERS];
             mixer.refresh_collector(1.0, mixer.get_current_vtool(), collector);
             MIXER_STEPPER_LOOP(e)
               if (e_steps * collector[e] > max_e_steps) { ignore_e = true; break; }
           #else
             constexpr bool ignore_e = true;
           #endif
           if (ignore_e) {
-            position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
+            position.e = target.e; // Behave as if the move really took place, but ignore E part
             #if HAS_POSITION_FLOAT
-              position_float[E_AXIS] = target_float[E_AXIS];
+              position_float.e = target_float.e;
             #endif
             de = 0; // no difference
             SERIAL_ECHO_MSG(MSG_ERR_LONG_EXTRUDE_STOP);
           }
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   // Compute direction bit-mask for this block
@@ -1732,124 +1720,117 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   // Clear all flags, including the "busy" bit
   block->flag = 0x00;
 
   // Set direction bits
   block->direction_bits = dm;
 
   // Number of steps for each axis
   // See http://www.corexy.com/theory.html
   #if CORE_IS_XY
-    block->steps[A_AXIS] = ABS(da + db);
-    block->steps[B_AXIS] = ABS(da - db);
-    block->steps[Z_AXIS] = ABS(dc);
+    block->steps.set(ABS(da + db), ABS(da - db), ABS(dc));
   #elif CORE_IS_XZ
-    block->steps[A_AXIS] = ABS(da + dc);
-    block->steps[Y_AXIS] = ABS(db);
-    block->steps[C_AXIS] = ABS(da - dc);
+    block->steps.set(ABS(da + dc), ABS(db), ABS(da - dc));
   #elif CORE_IS_YZ
-    block->steps[X_AXIS] = ABS(da);
-    block->steps[B_AXIS] = ABS(db + dc);
-    block->steps[C_AXIS] = ABS(db - dc);
+    block->steps.set(ABS(da), ABS(db + dc), ABS(db - dc));
   #elif IS_SCARA
-    block->steps[A_AXIS] = ABS(da);
-    block->steps[B_AXIS] = ABS(db);
-    block->steps[Z_AXIS] = ABS(dc);
+    block->steps.set(ABS(da), ABS(db), ABS(dc));
   #else
     // default non-h-bot planning
-    block->steps[A_AXIS] = ABS(da);
-    block->steps[B_AXIS] = ABS(db);
-    block->steps[C_AXIS] = ABS(dc);
+    block->steps.set(ABS(da), ABS(db), ABS(dc));
   #endif
 
   /**
    * This part of the code calculates the total length of the movement.
    * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
    * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
    * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
    * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
    * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
    */
+  struct DeltaMM : abce_float_t {
+    #if IS_CORE
+      xyz_pos_t head;
+    #endif
+  } delta_mm;
   #if IS_CORE
-    float delta_mm[Z_HEAD + 1];
     #if CORE_IS_XY
-      delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
-      delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
-      delta_mm[Z_AXIS] = dc * steps_to_mm[Z_AXIS];
-      delta_mm[A_AXIS] = (da + db) * steps_to_mm[A_AXIS];
-      delta_mm[B_AXIS] = CORESIGN(da - db) * steps_to_mm[B_AXIS];
+      delta_mm.head.x = da * steps_to_mm[A_AXIS];
+      delta_mm.head.y = db * steps_to_mm[B_AXIS];
+      delta_mm.z      = dc * steps_to_mm[Z_AXIS];
+      delta_mm.a      = (da + db) * steps_to_mm[A_AXIS];
+      delta_mm.b      = CORESIGN(da - db) * steps_to_mm[B_AXIS];
     #elif CORE_IS_XZ
-      delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
-      delta_mm[Y_AXIS] = db * steps_to_mm[Y_AXIS];
-      delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
-      delta_mm[A_AXIS] = (da + dc) * steps_to_mm[A_AXIS];
-      delta_mm[C_AXIS] = CORESIGN(da - dc) * steps_to_mm[C_AXIS];
+      delta_mm.head.x = da * steps_to_mm[A_AXIS];
+      delta_mm.y      = db * steps_to_mm[Y_AXIS];
+      delta_mm.head.z = dc * steps_to_mm[C_AXIS];
+      delta_mm.a      = (da + dc) * steps_to_mm[A_AXIS];
+      delta_mm.c      = CORESIGN(da - dc) * steps_to_mm[C_AXIS];
     #elif CORE_IS_YZ
-      delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
-      delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
-      delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
-      delta_mm[B_AXIS] = (db + dc) * steps_to_mm[B_AXIS];
-      delta_mm[C_AXIS] = CORESIGN(db - dc) * steps_to_mm[C_AXIS];
+      delta_mm.x      = da * steps_to_mm[X_AXIS];
+      delta_mm.head.y = db * steps_to_mm[B_AXIS];
+      delta_mm.head.z = dc * steps_to_mm[C_AXIS];
+      delta_mm.b      = (db + dc) * steps_to_mm[B_AXIS];
+      delta_mm.c      = CORESIGN(db - dc) * steps_to_mm[C_AXIS];
     #endif
   #else
-    float delta_mm[ABCE];
-    delta_mm[A_AXIS] = da * steps_to_mm[A_AXIS];
-    delta_mm[B_AXIS] = db * steps_to_mm[B_AXIS];
-    delta_mm[C_AXIS] = dc * steps_to_mm[C_AXIS];
+    delta_mm.a = da * steps_to_mm[A_AXIS];
+    delta_mm.b = db * steps_to_mm[B_AXIS];
+    delta_mm.c = dc * steps_to_mm[C_AXIS];
   #endif
 
   #if EXTRUDERS
-    delta_mm[E_AXIS] = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
+    delta_mm.e = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
   #endif
 
-  if (block->steps[A_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[B_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[C_AXIS] < MIN_STEPS_PER_SEGMENT) {
+  if (block->steps.a < MIN_STEPS_PER_SEGMENT && block->steps.b < MIN_STEPS_PER_SEGMENT && block->steps.c < MIN_STEPS_PER_SEGMENT) {
     block->millimeters = (0
       #if EXTRUDERS
-        + ABS(delta_mm[E_AXIS])
+        + ABS(delta_mm.e)
       #endif
     );
   }
   else {
     if (millimeters)
       block->millimeters = millimeters;
     else
       block->millimeters = SQRT(
         #if CORE_IS_XY
-          sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS])
+          sq(delta_mm.head.x) + sq(delta_mm.head.y) + sq(delta_mm.z)
         #elif CORE_IS_XZ
-          sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
+          sq(delta_mm.head.x) + sq(delta_mm.y) + sq(delta_mm.head.z)
         #elif CORE_IS_YZ
-          sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
+          sq(delta_mm.x) + sq(delta_mm.head.y) + sq(delta_mm.head.z)
         #else
-          sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS])
+          sq(delta_mm.x) + sq(delta_mm.y) + sq(delta_mm.z)
         #endif
       );
 
     /**
      * At this point at least one of the axes has more steps than
      * MIN_STEPS_PER_SEGMENT, ensuring the segment won't get dropped as
      * zero-length. It's important to not apply corrections
      * to blocks that would get dropped!
      *
      * A correction function is permitted to add steps to an axis, it
      * should *never* remove steps!
      */
     #if ENABLED(BACKLASH_COMPENSATION)
       backlash.add_correction_steps(da, db, dc, dm, block);
     #endif
   }
 
   #if EXTRUDERS
-    block->steps[E_AXIS] = esteps;
+    block->steps.e = esteps;
   #endif
 
-  block->step_event_count = _MAX(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
+  block->step_event_count = _MAX(block->steps.a, block->steps.b, block->steps.c, esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   #if ENABLED(MIXING_EXTRUDER)
     MIXER_POPULATE_BLOCK();
   #endif
 
   #if FAN_COUNT > 0
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
@@ -1858,50 +1839,50 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
   #if EXTRUDERS > 1
     block->extruder = extruder;
   #endif
 
   #if ENABLED(AUTO_POWER_CONTROL)
-    if (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS])
+    if (block->steps.x || block->steps.y || block->steps.z)
       powerManager.power_on();
   #endif
 
   // Enable active axes
   #if CORE_IS_XY
-    if (block->steps[A_AXIS] || block->steps[B_AXIS]) {
+    if (block->steps.a || block->steps.b) {
       enable_X();
       enable_Y();
     }
     #if DISABLED(Z_LATE_ENABLE)
-      if (block->steps[Z_AXIS]) enable_Z();
+      if (block->steps.z) enable_Z();
     #endif
   #elif CORE_IS_XZ
-    if (block->steps[A_AXIS] || block->steps[C_AXIS]) {
+    if (block->steps.a || block->steps.c) {
       enable_X();
       enable_Z();
     }
-    if (block->steps[Y_AXIS]) enable_Y();
+    if (block->steps.y) enable_Y();
   #elif CORE_IS_YZ
-    if (block->steps[B_AXIS] || block->steps[C_AXIS]) {
+    if (block->steps.b || block->steps.c) {
       enable_Y();
       enable_Z();
     }
-    if (block->steps[X_AXIS]) enable_X();
+    if (block->steps.x) enable_X();
   #else
-    if (block->steps[X_AXIS]) enable_X();
-    if (block->steps[Y_AXIS]) enable_Y();
+    if (block->steps.x) enable_X();
+    if (block->steps.y) enable_Y();
     #if DISABLED(Z_LATE_ENABLE)
-      if (block->steps[Z_AXIS]) enable_Z();
+      if (block->steps.z) enable_Z();
     #endif
   #endif
 
   // Enable extruder(s)
   #if EXTRUDERS
     if (esteps) {
       #if ENABLED(AUTO_POWER_CONTROL)
         powerManager.power_on();
       #endif
 
@@ -2067,93 +2048,94 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     block->segment_time_us = segment_time_us;
 
     if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
   #endif
 
   block->nominal_speed_sqr = sq(block->millimeters * inverse_secs);   //   (mm/sec)^2 Always > 0
   block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM)   // Only for extruder with filament sensor
-      filwidth.advance_e(delta_mm[E_AXIS]);
+      filwidth.advance_e(delta_mm.e);
   #endif
 
   // Calculate and limit speed in mm/sec for each axis
-  float current_speed[NUM_AXIS], speed_factor = 1.0f; // factor <1 decreases speed
+  xyze_float_t current_speed;
+  float speed_factor = 1.0f; // factor <1 decreases speed
   LOOP_XYZE(i) {
     #if BOTH(MIXING_EXTRUDER, RETRACT_SYNC_MIXING)
       // In worst case, only one extruder running, no change is needed.
       // In best case, all extruders run the same amount, we can divide by MIXING_STEPPERS
       float delta_mm_i = 0;
       if (i == E_AXIS && mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)
-        delta_mm_i = delta_mm[i] / MIXING_STEPPERS;
+        delta_mm_i = delta_mm.e / MIXING_STEPPERS;
       else
-        delta_mm_i = delta_mm[i];
+        delta_mm_i = delta_mm.e;
     #else
       const float delta_mm_i = delta_mm[i];
     #endif
     const feedRate_t cs = ABS(current_speed[i] = delta_mm_i * inverse_secs);
     #if ENABLED(DISTINCT_E_FACTORS)
       if (i == E_AXIS) i += extruder;
     #endif
     if (cs > settings.max_feedrate_mm_s[i]) NOMORE(speed_factor, settings.max_feedrate_mm_s[i] / cs);
   }
 
   // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT
 
     // Check and limit the xy direction change frequency
     const unsigned char direction_change = block->direction_bits ^ old_direction_bits;
     old_direction_bits = block->direction_bits;
     segment_time_us = LROUND((float)segment_time_us / speed_factor);
 
-    uint32_t xs0 = axis_segment_time_us[X_AXIS][0],
-             xs1 = axis_segment_time_us[X_AXIS][1],
-             xs2 = axis_segment_time_us[X_AXIS][2],
-             ys0 = axis_segment_time_us[Y_AXIS][0],
-             ys1 = axis_segment_time_us[Y_AXIS][1],
-             ys2 = axis_segment_time_us[Y_AXIS][2];
+    uint32_t xs0 = axis_segment_time_us[0].x,
+             xs1 = axis_segment_time_us[1].x,
+             xs2 = axis_segment_time_us[2].x,
+             ys0 = axis_segment_time_us[0].y,
+             ys1 = axis_segment_time_us[1].y,
+             ys2 = axis_segment_time_us[2].y;
 
     if (TEST(direction_change, X_AXIS)) {
-      xs2 = axis_segment_time_us[X_AXIS][2] = xs1;
-      xs1 = axis_segment_time_us[X_AXIS][1] = xs0;
+      xs2 = axis_segment_time_us[2].x = xs1;
+      xs1 = axis_segment_time_us[1].x = xs0;
       xs0 = 0;
     }
-    xs0 = axis_segment_time_us[X_AXIS][0] = xs0 + segment_time_us;
+    xs0 = axis_segment_time_us[0].x = xs0 + segment_time_us;
 
     if (TEST(direction_change, Y_AXIS)) {
-      ys2 = axis_segment_time_us[Y_AXIS][2] = axis_segment_time_us[Y_AXIS][1];
-      ys1 = axis_segment_time_us[Y_AXIS][1] = axis_segment_time_us[Y_AXIS][0];
+      ys2 = axis_segment_time_us[2].y = axis_segment_time_us[1].y;
+      ys1 = axis_segment_time_us[1].y = axis_segment_time_us[0].y;
       ys0 = 0;
     }
-    ys0 = axis_segment_time_us[Y_AXIS][0] = ys0 + segment_time_us;
+    ys0 = axis_segment_time_us[0].y = ys0 + segment_time_us;
 
     const uint32_t max_x_segment_time = _MAX(xs0, xs1, xs2),
                    max_y_segment_time = _MAX(ys0, ys1, ys2),
                    min_xy_segment_time = _MIN(max_x_segment_time, max_y_segment_time);
     if (min_xy_segment_time < MAX_FREQ_TIME_US) {
       const float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME_US);
       NOMORE(speed_factor, low_sf);
     }
   #endif // XY_FREQUENCY_LIMIT
 
   // Correct the speed
   if (speed_factor < 1.0f) {
-    LOOP_XYZE(i) current_speed[i] *= speed_factor;
+    current_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
     block->nominal_speed_sqr = block->nominal_speed_sqr * sq(speed_factor);
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
-  if (!block->steps[A_AXIS] && !block->steps[B_AXIS] && !block->steps[C_AXIS]) {
+  if (!block->steps.a && !block->steps.b && !block->steps.c) {
     // convert to: acceleration steps/sec^2
     accel = CEIL(settings.retract_acceleration * steps_per_mm);
     #if ENABLED(LIN_ADVANCE)
       block->use_advance_lead = false;
     #endif
   }
   else {
     #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
         const uint32_t comp = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count; \
@@ -2173,45 +2155,45 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
     #if ENABLED(LIN_ADVANCE)
 
       #if ENABLED(JUNCTION_DEVIATION)
         #if ENABLED(DISTINCT_E_FACTORS)
           #define MAX_E_JERK max_e_jerk[extruder]
         #else
           #define MAX_E_JERK max_e_jerk
         #endif
       #else
-        #define MAX_E_JERK max_jerk[E_AXIS]
+        #define MAX_E_JERK max_jerk.e
       #endif
 
       /**
        *
        * Use LIN_ADVANCE for blocks if all these are true:
        *
        * esteps             : This is a print move, because we checked for A, B, C steps before.
        *
        * extruder_advance_K[active_extruder] : There is an advance factor set for this extruder.
        *
        * de > 0             : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
        */
       block->use_advance_lead =  esteps
                               && extruder_advance_K[active_extruder]
                               && de > 0;
 
       if (block->use_advance_lead) {
-        block->e_D_ratio = (target_float[E_AXIS] - position_float[E_AXIS]) /
+        block->e_D_ratio = (target_float.e - position_float.e) /
           #if IS_KINEMATIC
             block->millimeters
           #else
-            SQRT(sq(target_float[X_AXIS] - position_float[X_AXIS])
-               + sq(target_float[Y_AXIS] - position_float[Y_AXIS])
-               + sq(target_float[Z_AXIS] - position_float[Z_AXIS]))
+            SQRT(sq(target_float.x - position_float.x)
+               + sq(target_float.y - position_float.y)
+               + sq(target_float.z - position_float.z))
           #endif
         ;
 
         // Check for unusual high e_D ratio to detect if a retract move was combined with the last print move due to min. steps per segment. Never execute this with advance!
         // This assumes no one will use a retract length of 0mm < retr_length < ~0.2mm and no one will print 100mm wide lines using 3mm filament or 35mm wide lines using 1.75mm filament.
         if (block->e_D_ratio > 3.0f)
           block->use_advance_lead = false;
         else {
           const uint32_t max_accel_steps_per_s2 = MAX_E_JERK / (extruder_advance_K[active_extruder] * block->e_D_ratio) * steps_per_mm;
           #if ENABLED(LA_DEBUG)
@@ -2290,72 +2272,57 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
      *
      * hoffbaked: on May 10 2018 tuned and improved the GRBL algorithm for Marlin:
           Okay! It seems to be working good. I somewhat arbitrarily cut it off at 1mm
           on then on anything with less sides than an octagon. With this, and the
           reverse pass actually recalculating things, a corner acceleration value
           of 1000 junction deviation of .05 are pretty reasonable. If the cycles
           can be spared, a better acos could be used. For all I know, it may be
           already calculated in a different place. */
 
     // Unit vector of previous path line segment
-    static float previous_unit_vec[XYZE];
+    static xyze_float_t prev_unit_vec;
 
-    #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
-      float unit_vec[] = {
-        delta_mm_cart[X_AXIS] * inverse_millimeters,
-        delta_mm_cart[Y_AXIS] * inverse_millimeters,
-        delta_mm_cart[Z_AXIS] * inverse_millimeters,
-        delta_mm_cart[E_AXIS] * inverse_millimeters
-      };
-    #else
-      float unit_vec[] = {
-        delta_mm[X_AXIS] * inverse_millimeters,
-        delta_mm[Y_AXIS] * inverse_millimeters,
-        delta_mm[Z_AXIS] * inverse_millimeters,
-        delta_mm[E_AXIS] * inverse_millimeters
-      };
-    #endif
+    xyze_float_t unit_vec =
+      #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+        delta_mm_cart
+      #else
+        { delta_mm.x, delta_mm.y, delta_mm.z, delta_mm.e }
+      #endif
+    ;
+    unit_vec *= inverse_millimeters;
 
     #if IS_CORE && ENABLED(JUNCTION_DEVIATION)
       /**
        * On CoreXY the length of the vector [A,B] is SQRT(2) times the length of the head movement vector [X,Y].
        * So taking Z and E into account, we cannot scale to a unit vector with "inverse_millimeters".
        * => normalize the complete junction vector
        */
       normalize_junction_vector(unit_vec);
     #endif
 
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
-      float junction_cos_theta = -previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
-                                 -previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
-                                 -previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS]
-                                 -previous_unit_vec[E_AXIS] * unit_vec[E_AXIS]
-                                ;
+      float junction_cos_theta = (-prev_unit_vec.x * unit_vec.x) + (-prev_unit_vec.y * unit_vec.y)
+                               + (-prev_unit_vec.z * unit_vec.z) + (-prev_unit_vec.e * unit_vec.e);
 
       // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
       if (junction_cos_theta > 0.999999f) {
         // For a 0 degree acute junction, just set minimum junction speed.
         vmax_junction_sqr = sq(float(MINIMUM_PLANNER_SPEED));
       }
       else {
         NOLESS(junction_cos_theta, -0.999999f); // Check for numerical round-off to avoid divide by zero.
 
         // Convert delta vector to unit vector
-        float junction_unit_vec[XYZE] = {
-          unit_vec[X_AXIS] - previous_unit_vec[X_AXIS],
-          unit_vec[Y_AXIS] - previous_unit_vec[Y_AXIS],
-          unit_vec[Z_AXIS] - previous_unit_vec[Z_AXIS],
-          unit_vec[E_AXIS] - previous_unit_vec[E_AXIS]
-        };
+        xyze_float_t junction_unit_vec = unit_vec - prev_unit_vec;
         normalize_junction_vector(junction_unit_vec);
 
         const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec),
                     sin_theta_d2 = SQRT(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
 
         vmax_junction_sqr = (junction_acceleration * junction_deviation_mm * sin_theta_d2) / (1.0f - sin_theta_d2);
         if (block->millimeters < 1) {
 
           // Fast acos approximation, minus the error bar to be safe
           const float junction_theta = (RADIANS(-40) * sq(junction_cos_theta) - RADIANS(50)) * junction_cos_theta + RADIANS(90) - 0.18f;
@@ -2367,21 +2334,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           }
         }
       }
 
       // Get the lowest speed
       vmax_junction_sqr = _MIN(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
       vmax_junction_sqr = 0;
 
-    COPY(previous_unit_vec, unit_vec);
+    prev_unit_vec = unit_vec;
 
   #endif
 
   #if HAS_CLASSIC_JERK
 
     /**
      * Adapted from Pr≈Ø≈°a MKS firmware
      * https://github.com/prusa3d/Prusa-Firmware
      */
     const float nominal_speed = SQRT(block->nominal_speed_sqr);
@@ -2490,32 +2457,31 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
   // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
   // the current block and next block junction speeds are guaranteed to always be at their maximum
   // junction speeds in deceleration and acceleration, respectively. This is due to how the current
   // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
   block->flag |= block->nominal_speed_sqr <= v_allowable_sqr ? BLOCK_FLAG_RECALCULATE | BLOCK_FLAG_NOMINAL_LENGTH : BLOCK_FLAG_RECALCULATE;
 
   // Update previous path unit_vector and nominal speed
-  COPY(previous_speed, current_speed);
+  previous_speed = current_speed;
   previous_nominal_speed_sqr = block->nominal_speed_sqr;
 
   // Update the position
-  static_assert(COUNT(target) > 1, "Parameter to _buffer_steps must be (&target)[XYZE]!");
-  COPY(position, target);
+  position = target;
   #if HAS_POSITION_FLOAT
-    COPY(position_float, target_float);
+    position_float = target_float;
   #endif
 
   #if ENABLED(GRADIENT_MIX)
-    mixer.gradient_control(target_float[Z_AXIS]);
+    mixer.gradient_control(target_float.z);
   #endif
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     block->sdpos = recovery.command_sdpos();
   #endif
 
   // Movement was accepted
   return true;
 } // _populate_block()
 
@@ -2526,24 +2492,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 void Planner::buffer_sync_block() {
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Clear block
   memset(block, 0, sizeof(block_t));
 
   block->flag = BLOCK_FLAG_SYNC_POSITION;
 
-  block->position[A_AXIS] = position[A_AXIS];
-  block->position[B_AXIS] = position[B_AXIS];
-  block->position[C_AXIS] = position[C_AXIS];
-  block->position[E_AXIS] = position[E_AXIS];
+  block->position = position;
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
     // give the planner an opportunity to queue more movements and plan them
     // As there are no queued movements, the Stepper ISR will not touch this
     // variable, so there is no risk setting this here (but it MUST be done
     // before the following line!!)
     delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
   }
@@ -2560,82 +2523,82 @@ void Planner::buffer_sync_block() {
  *
  * Leveling and kinematics should be applied ahead of calling this.
  *
  *  a,b,c,e     - target positions in mm and/or degrees
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *  millimeters - the length of the movement, if known
  */
 bool Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e
   #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
-    , const float (&delta_mm_cart)[XYZE]
+    , const xyze_float_t &delta_mm_cart
   #endif
   , const feedRate_t &fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
     if (last_extruder != extruder && settings.axis_steps_per_mm[E_AXIS_N(extruder)] != settings.axis_steps_per_mm[E_AXIS_N(last_extruder)]) {
-      position[E_AXIS] = LROUND(position[E_AXIS] * settings.axis_steps_per_mm[E_AXIS_N(extruder)] * steps_to_mm[E_AXIS_N(last_extruder)]);
+      position.e = LROUND(position.e * settings.axis_steps_per_mm[E_AXIS_N(extruder)] * steps_to_mm[E_AXIS_N(last_extruder)]);
       last_extruder = extruder;
     }
   #endif
 
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
-  const int32_t target[ABCE] = {
+  const abce_long_t target = {
     int32_t(LROUND(a * settings.axis_steps_per_mm[A_AXIS])),
     int32_t(LROUND(b * settings.axis_steps_per_mm[B_AXIS])),
     int32_t(LROUND(c * settings.axis_steps_per_mm[C_AXIS])),
     int32_t(LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(extruder)]))
   };
 
   #if HAS_POSITION_FLOAT
-    const float target_float[XYZE] = { a, b, c, e };
+    const xyze_pos_t target_float = { a, b, c, e };
   #endif
 
   // DRYRUN prevents E moves from taking place
   if (DEBUGGING(DRYRUN)) {
-    position[E_AXIS] = target[E_AXIS];
+    position.e = target.e;
     #if HAS_POSITION_FLOAT
-      position_float[E_AXIS] = e;
+      position_float.e = e;
     #endif
   }
 
   /* <-- add a slash to enable
     SERIAL_ECHOPAIR("  buffer_segment FR:", fr_mm_s);
     #if IS_KINEMATIC
       SERIAL_ECHOPAIR(" A:", a);
-      SERIAL_ECHOPAIR(" (", position[A_AXIS]);
-      SERIAL_ECHOPAIR("->", target[A_AXIS]);
+      SERIAL_ECHOPAIR(" (", position.a);
+      SERIAL_ECHOPAIR("->", target.a);
       SERIAL_ECHOPAIR(") B:", b);
     #else
       SERIAL_ECHOPAIR(" X:", a);
-      SERIAL_ECHOPAIR(" (", position[X_AXIS]);
-      SERIAL_ECHOPAIR("->", target[X_AXIS]);
+      SERIAL_ECHOPAIR(" (", position.x);
+      SERIAL_ECHOPAIR("->", target.x);
       SERIAL_ECHOPAIR(") Y:", b);
     #endif
-    SERIAL_ECHOPAIR(" (", position[Y_AXIS]);
-    SERIAL_ECHOPAIR("->", target[Y_AXIS]);
+    SERIAL_ECHOPAIR(" (", position.y);
+    SERIAL_ECHOPAIR("->", target.y);
     #if ENABLED(DELTA)
       SERIAL_ECHOPAIR(") C:", c);
     #else
       SERIAL_ECHOPAIR(") Z:", c);
     #endif
-    SERIAL_ECHOPAIR(" (", position[Z_AXIS]);
-    SERIAL_ECHOPAIR("->", target[Z_AXIS]);
+    SERIAL_ECHOPAIR(" (", position.z);
+    SERIAL_ECHOPAIR("->", target.z);
     SERIAL_ECHOPAIR(") E:", e);
-    SERIAL_ECHOPAIR(" (", position[E_AXIS]);
-    SERIAL_ECHOPAIR("->", target[E_AXIS]);
+    SERIAL_ECHOPAIR(" (", position.e);
+    SERIAL_ECHOPAIR("->", target.e);
     SERIAL_ECHOLNPGM(")");
   //*/
 
   // Queue the movement
   if (
     !_buffer_steps(target
       #if HAS_POSITION_FLOAT
         , target_float
       #endif
       #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
@@ -2658,146 +2621,137 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
  *  fr_mm_s      - (target) speed of the move (mm/s)
  *  extruder     - target extruder
  *  millimeters  - the length of the movement, if known
  *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
  */
 bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, const float &e, const feedRate_t &fr_mm_s, const uint8_t extruder, const float millimeters
   #if ENABLED(SCARA_FEEDRATE_SCALING)
     , const float &inv_duration
   #endif
 ) {
-  float raw[XYZE] = { rx, ry, rz, e };
+  xyze_pos_t machine = { rx, ry, rz, e };
   #if HAS_POSITION_MODIFIERS
-    apply_modifiers(raw);
+    apply_modifiers(machine);
   #endif
 
   #if IS_KINEMATIC
-    const float delta_mm_cart[] = {
-      rx - position_cart[X_AXIS],
-      ry - position_cart[Y_AXIS],
-      rz - position_cart[Z_AXIS]
-      #if ENABLED(JUNCTION_DEVIATION)
-        , e - position_cart[E_AXIS]
-      #endif
-    };
+
+    #if ENABLED(JUNCTION_DEVIATION)
+      const xyze_pos_t delta_mm_cart = {
+        rx - position_cart.x, ry - position_cart.y,
+        rz - position_cart.z, e  - position_cart.e
+      };
+    #else
+      const xyz_pos_t delta_mm_cart = { rx - position_cart.x, ry - position_cart.y, rz - position_cart.z };
+    #endif
 
     float mm = millimeters;
     if (mm == 0.0)
-      mm = (delta_mm_cart[X_AXIS] != 0.0 || delta_mm_cart[Y_AXIS] != 0.0) ? SQRT(sq(delta_mm_cart[X_AXIS]) + sq(delta_mm_cart[Y_AXIS]) + sq(delta_mm_cart[Z_AXIS])) : ABS(delta_mm_cart[Z_AXIS]);
+      mm = (delta_mm_cart.x != 0.0 || delta_mm_cart.y != 0.0) ? delta_mm_cart.magnitude() : ABS(delta_mm_cart.z);
 
-    inverse_kinematics(raw);
+    inverse_kinematics(machine);
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
       const float duration_recip = inv_duration ? inv_duration : fr_mm_s / mm;
-      const feedRate_t feedrate = HYPOT(delta[A_AXIS] - position_float[A_AXIS], delta[B_AXIS] - position_float[B_AXIS]) * duration_recip;
+      const feedRate_t feedrate = HYPOT(delta.a - position_float.a, delta.b - position_float.b) * duration_recip;
     #else
       const feedRate_t feedrate = fr_mm_s;
     #endif
-    if (buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS]
+    if (buffer_segment(delta.a, delta.b, delta.c, machine.e
       #if ENABLED(JUNCTION_DEVIATION)
         , delta_mm_cart
       #endif
       , feedrate, extruder, mm
     )) {
-      position_cart[X_AXIS] = rx;
-      position_cart[Y_AXIS] = ry;
-      position_cart[Z_AXIS] = rz;
-      position_cart[E_AXIS] = e;
+      position_cart.set(rx, ry, rz, e);
       return true;
     }
     else
       return false;
   #else
-    return buffer_segment(raw, fr_mm_s, extruder, millimeters);
+    return buffer_segment(machine, fr_mm_s, extruder, millimeters);
   #endif
 } // buffer_line()
 
 /**
  * Directly set the planner ABC position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * The provided ABC position is in machine units.
  */
 
 void Planner::set_machine_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)
     last_extruder = active_extruder;
   #endif
-  position[A_AXIS] = LROUND(a * settings.axis_steps_per_mm[A_AXIS]);
-  position[B_AXIS] = LROUND(b * settings.axis_steps_per_mm[B_AXIS]);
-  position[C_AXIS] = LROUND(c * settings.axis_steps_per_mm[C_AXIS]);
-  position[E_AXIS] = LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(active_extruder)]);
   #if HAS_POSITION_FLOAT
-    position_float[A_AXIS] = a;
-    position_float[B_AXIS] = b;
-    position_float[C_AXIS] = c;
-    position_float[E_AXIS] = e;
+    position_float.set(a, b, c, e);
   #endif
+  position.set(LROUND(a * settings.axis_steps_per_mm[A_AXIS]),
+               LROUND(b * settings.axis_steps_per_mm[B_AXIS]),
+               LROUND(c * settings.axis_steps_per_mm[C_AXIS]),
+               LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(active_extruder)]));
   if (has_blocks_queued()) {
     //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.
-    //ZERO(previous_speed);
+    //previous_speed.reset();
     buffer_sync_block();
   }
   else
-    stepper.set_position(position[A_AXIS], position[B_AXIS], position[C_AXIS], position[E_AXIS]);
+    stepper.set_position(position);
 }
 
 void Planner::set_position_mm(const float &rx, const float &ry, const float &rz, const float &e) {
-  float raw[XYZE] = { rx, ry, rz, e };
+  xyze_pos_t machine = { rx, ry, rz, e };
   #if HAS_POSITION_MODIFIERS
   {
-    apply_modifiers(raw
+    apply_modifiers(machine
       #if HAS_LEVELING
         , true
       #endif
     );
   }
   #endif
   #if IS_KINEMATIC
-    position_cart[X_AXIS] = rx;
-    position_cart[Y_AXIS] = ry;
-    position_cart[Z_AXIS] = rz;
-    position_cart[E_AXIS] = e;
-
-    inverse_kinematics(raw);
-    set_machine_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS]);
+    position_cart.set(rx, ry, rz, e);
+    inverse_kinematics(machine);
+    set_machine_position_mm(delta.a, delta.b, delta.c, machine.e);
   #else
-    set_machine_position_mm(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], raw[E_AXIS]);
+    set_machine_position_mm(machine);
   #endif
 }
 
 /**
  * Setters for planner position (also setting stepper position).
  */
 void Planner::set_e_position_mm(const float &e) {
   const uint8_t axis_index = E_AXIS_N(active_extruder);
   #if ENABLED(DISTINCT_E_FACTORS)
     last_extruder = active_extruder;
   #endif
   #if ENABLED(FWRETRACT)
     float e_new = e - fwretract.current_retract[active_extruder];
   #else
     const float e_new = e;
   #endif
-  position[E_AXIS] = LROUND(settings.axis_steps_per_mm[axis_index] * e_new);
+  position.e = LROUND(settings.axis_steps_per_mm[axis_index] * e_new);
   #if HAS_POSITION_FLOAT
-    position_float[E_AXIS] = e_new;
+    position_float.e = e_new;
   #endif
   #if IS_KINEMATIC
-    position_cart[E_AXIS] = e;
+    position_cart.e = e;
   #endif
   if (has_blocks_queued())
     buffer_sync_block();
   else
-    stepper.set_position(E_AXIS, position[E_AXIS]);
+    stepper.set_axis_position(E_AXIS, position.e);
 }
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define AXIS_CONDITION (i < E_AXIS || i == E_AXIS_N(active_extruder))
   #else
     #define AXIS_CONDITION true
   #endif
   uint32_t highest_rate = 1;

commit 455dabb18334c89878a75be62bccebd9f537574d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 26 01:28:09 2019 -0500

    Add a feedRate_t data type (#15349)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 13e411b9b8..2715221f32 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1563,21 +1563,21 @@ void Planner::synchronize() {
  *
  * Returns true if movement was properly queued, false otherwise
  */
 bool Planner::_buffer_steps(const int32_t (&target)[XYZE]
   #if HAS_POSITION_FLOAT
     , const float (&target_float)[ABCE]
   #endif
   #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
     , const float (&delta_mm_cart)[XYZE]
   #endif
-  , float fr_mm_s, const uint8_t extruder, const float &millimeters
+  , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Fill the block with the specified movement
@@ -1627,21 +1627,21 @@ bool Planner::_buffer_steps(const int32_t (&target)[XYZE]
  * Returns true is movement is acceptable, false otherwise
  */
 bool Planner::_populate_block(block_t * const block, bool split_move,
   const int32_t (&target)[ABCE]
   #if HAS_POSITION_FLOAT
     , const float (&target_float)[ABCE]
   #endif
   #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
     , const float (&delta_mm_cart)[XYZE]
   #endif
-  , float fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
+  , feedRate_t fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
   const int32_t da = target[A_AXIS] - position[A_AXIS],
                 db = target[B_AXIS] - position[B_AXIS],
                 dc = target[C_AXIS] - position[C_AXIS];
 
   #if EXTRUDERS
     int32_t de = target[E_AXIS] - position[E_AXIS];
   #else
     constexpr int32_t de = 0;
@@ -2084,21 +2084,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       // In worst case, only one extruder running, no change is needed.
       // In best case, all extruders run the same amount, we can divide by MIXING_STEPPERS
       float delta_mm_i = 0;
       if (i == E_AXIS && mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)
         delta_mm_i = delta_mm[i] / MIXING_STEPPERS;
       else
         delta_mm_i = delta_mm[i];
     #else
       const float delta_mm_i = delta_mm[i];
     #endif
-    const float cs = ABS(current_speed[i] = delta_mm_i * inverse_secs);
+    const feedRate_t cs = ABS(current_speed[i] = delta_mm_i * inverse_secs);
     #if ENABLED(DISTINCT_E_FACTORS)
       if (i == E_AXIS) i += extruder;
     #endif
     if (cs > settings.max_feedrate_mm_s[i]) NOMORE(speed_factor, settings.max_feedrate_mm_s[i] / cs);
   }
 
   // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT
 
     // Check and limit the xy direction change frequency
@@ -2562,21 +2562,21 @@ void Planner::buffer_sync_block() {
  *
  *  a,b,c,e     - target positions in mm and/or degrees
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *  millimeters - the length of the movement, if known
  */
 bool Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e
   #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
     , const float (&delta_mm_cart)[XYZE]
   #endif
-  , const float &fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
+  , const feedRate_t &fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
     if (last_extruder != extruder && settings.axis_steps_per_mm[E_AXIS_N(extruder)] != settings.axis_steps_per_mm[E_AXIS_N(last_extruder)]) {
       position[E_AXIS] = LROUND(position[E_AXIS] * settings.axis_steps_per_mm[E_AXIS_N(extruder)] * steps_to_mm[E_AXIS_N(last_extruder)]);
       last_extruder = extruder;
@@ -2644,31 +2644,30 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
       , fr_mm_s, extruder, millimeters
     )
   ) return false;
 
   stepper.wake_up();
   return true;
 } // buffer_segment()
 
 /**
  * Add a new linear movement to the buffer.
- * The target is cartesian, it's translated to delta/scara if
- * needed.
- *
+ * The target is cartesian. It's translated to
+ * delta/scara if needed.
  *
  *  rx,ry,rz,e   - target position in mm or degrees
  *  fr_mm_s      - (target) speed of the move (mm/s)
  *  extruder     - target extruder
  *  millimeters  - the length of the movement, if known
  *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
  */
-bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, const float &e, const float &fr_mm_s, const uint8_t extruder, const float millimeters
+bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, const float &e, const feedRate_t &fr_mm_s, const uint8_t extruder, const float millimeters
   #if ENABLED(SCARA_FEEDRATE_SCALING)
     , const float &inv_duration
   #endif
 ) {
   float raw[XYZE] = { rx, ry, rz, e };
   #if HAS_POSITION_MODIFIERS
     apply_modifiers(raw);
   #endif
 
   #if IS_KINEMATIC
@@ -2683,24 +2682,24 @@ bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, con
 
     float mm = millimeters;
     if (mm == 0.0)
       mm = (delta_mm_cart[X_AXIS] != 0.0 || delta_mm_cart[Y_AXIS] != 0.0) ? SQRT(sq(delta_mm_cart[X_AXIS]) + sq(delta_mm_cart[Y_AXIS]) + sq(delta_mm_cart[Z_AXIS])) : ABS(delta_mm_cart[Z_AXIS]);
 
     inverse_kinematics(raw);
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
-      const float duration_recip = inv_duration ? inv_duration : fr_mm_s / mm,
-                  feedrate = HYPOT(delta[A_AXIS] - position_float[A_AXIS], delta[B_AXIS] - position_float[B_AXIS]) * duration_recip;
+      const float duration_recip = inv_duration ? inv_duration : fr_mm_s / mm;
+      const feedRate_t feedrate = HYPOT(delta[A_AXIS] - position_float[A_AXIS], delta[B_AXIS] - position_float[B_AXIS]) * duration_recip;
     #else
-      const float feedrate = fr_mm_s;
+      const feedRate_t feedrate = fr_mm_s;
     #endif
     if (buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS]
       #if ENABLED(JUNCTION_DEVIATION)
         , delta_mm_cart
       #endif
       , feedrate, extruder, mm
     )) {
       position_cart[X_AXIS] = rx;
       position_cart[Y_AXIS] = ry;
       position_cart[Z_AXIS] = rz;

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 9618846f31..13e411b9b8 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1167,60 +1167,64 @@ void Planner::recalculate() {
     oldt = t;
     thermalManager.setTargetHotend(t, 0);
   }
 
 #endif // AUTOTEMP
 
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
-  uint8_t axis_active[NUM_AXIS] = { 0 };
+
+  #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
+    uint8_t axis_active[NUM_AXIS] = { 0 };
+  #endif
 
   #if FAN_COUNT > 0
     uint8_t tail_fan_speed[FAN_COUNT];
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
     #endif
     #if HAS_HEATER_2
       uint8_t tail_e_to_p_pressure;
     #endif
   #endif
 
   if (has_blocks_queued()) {
-    block_t* block;
 
     #if FAN_COUNT > 0 || ENABLED(BARICUDA)
-      block = &block_buffer[block_buffer_tail];
+      block_t *block = &block_buffer[block_buffer_tail];
     #endif
 
     #if FAN_COUNT > 0
       FANS_LOOP(i)
         tail_fan_speed[i] = thermalManager.scaledFanSpeed(i, block->fan_speed[i]);
     #endif
 
     #if ENABLED(BARICUDA)
       #if HAS_HEATER_1
         tail_valve_pressure = block->valve_pressure;
       #endif
       #if HAS_HEATER_2
         tail_e_to_p_pressure = block->e_to_p_pressure;
       #endif
     #endif
 
-    for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
-      block = &block_buffer[b];
-      LOOP_XYZE(i) if (block->steps[i]) axis_active[i]++;
-    }
+    #if ANY(DISABLE_X, DISABLE_Y, DISABLE_Z, DISABLE_E)
+      for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
+        block_t *block = &block_buffer[b];
+        LOOP_XYZE(i) if (block->steps[i]) axis_active[i] = true;
+      }
+    #endif
   }
   else {
     #if FAN_COUNT > 0
       FANS_LOOP(i)
         tail_fan_speed[i] = thermalManager.scaledFanSpeed(i);
     #endif
 
     #if ENABLED(BARICUDA)
       #if HAS_HEATER_1
         tail_valve_pressure = baricuda_valve_pressure;
@@ -1510,28 +1514,28 @@ void Planner::finish_and_disable() {
 float Planner::get_axis_position_mm(const AxisEnum axis) {
   float axis_steps;
   #if IS_CORE
     // Requesting one of the "core" axes?
     if (axis == CORE_AXIS_1 || axis == CORE_AXIS_2) {
 
       // Protect the access to the position.
       const bool was_enabled = STEPPER_ISR_ENABLED();
       if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
 
-      // ((a1+a2)+(a1-a2))/2 -> (a1+a2+a1-a2)/2 -> (a1+a1)/2 -> a1
-      // ((a1+a2)-(a1-a2))/2 -> (a1+a2-a1+a2)/2 -> (a2+a2)/2 -> a2
-      axis_steps = 0.5f * (
-        axis == CORE_AXIS_2 ? CORESIGN(stepper.position(CORE_AXIS_1) - stepper.position(CORE_AXIS_2))
-                            : stepper.position(CORE_AXIS_1) + stepper.position(CORE_AXIS_2)
-      );
+      const int32_t p1 = stepper.position(CORE_AXIS_1),
+                    p2 = stepper.position(CORE_AXIS_2);
 
       if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+
+      // ((a1+a2)+(a1-a2))/2 -> (a1+a2+a1-a2)/2 -> (a1+a1)/2 -> a1
+      // ((a1+a2)-(a1-a2))/2 -> (a1+a2-a1+a2)/2 -> (a2+a2)/2 -> a2
+      axis_steps = (axis == CORE_AXIS_2 ? CORESIGN(p1 - p2) : p1 + p2) * 0.5f;
     }
     else
       axis_steps = stepper.position(axis);
   #else
     axis_steps = stepper.position(axis);
   #endif
   return axis_steps * steps_to_mm[axis];
 }
 
 /**
@@ -1544,25 +1548,25 @@ void Planner::synchronize() {
       || (READ(CLOSED_LOOP_ENABLE_PIN) && !READ(CLOSED_LOOP_MOVE_COMPLETE_PIN))
     #endif
   ) idle();
 }
 
 /**
  * Planner::_buffer_steps
  *
  * Add a new linear movement to the planner queue (in terms of steps).
  *
- *  target      - target position in steps units
- *  target_float - target position in direct (mm, degrees) units. optional
- *  fr_mm_s     - (target) speed of the move
- *  extruder    - target extruder
- *  millimeters - the length of the movement, if known
+ *  target        - target position in steps units
+ *  target_float  - target position in direct (mm, degrees) units. optional
+ *  fr_mm_s       - (target) speed of the move
+ *  extruder      - target extruder
+ *  millimeters   - the length of the movement, if known
  *
  * Returns true if movement was properly queued, false otherwise
  */
 bool Planner::_buffer_steps(const int32_t (&target)[XYZE]
   #if HAS_POSITION_FLOAT
     , const float (&target_float)[ABCE]
   #endif
   #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
     , const float (&delta_mm_cart)[XYZE]
   #endif
@@ -1637,32 +1641,28 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
                 db = target[B_AXIS] - position[B_AXIS],
                 dc = target[C_AXIS] - position[C_AXIS];
 
   #if EXTRUDERS
     int32_t de = target[E_AXIS] - position[E_AXIS];
   #else
     constexpr int32_t de = 0;
   #endif
 
   /* <-- add a slash to enable
-    SERIAL_ECHOPAIR("  _populate_block FR:", fr_mm_s);
-    SERIAL_ECHOPAIR(" A:", target[A_AXIS]);
-    SERIAL_ECHOPAIR(" (", da);
-    SERIAL_ECHOPAIR(" steps) B:", target[B_AXIS]);
-    SERIAL_ECHOPAIR(" (", db);
-    SERIAL_ECHOPAIR(" steps) C:", target[C_AXIS]);
-    SERIAL_ECHOPAIR(" (", dc);
-    #if EXTRUDERS
-      SERIAL_ECHOPAIR(" steps) E:", target[E_AXIS]);
-      SERIAL_ECHOPAIR(" (", de);
-    #endif
-    SERIAL_ECHOLNPGM(" steps)");
+    SERIAL_ECHOLNPAIR("  _populate_block FR:", fr_mm_s,
+                      " A:", target[A_AXIS], " (", da, " steps)"
+                      " B:", target[B_AXIS], " (", db, " steps)"
+                      " C:", target[C_AXIS], " (", dc, " steps)"
+                      #if EXTRUDERS
+                        " E:", target[E_AXIS], " (", de, " steps)"
+                      #endif
+                    );
   //*/
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           #if HAS_POSITION_FLOAT
             position_float[E_AXIS] = target_float[E_AXIS];
           #endif
@@ -2626,21 +2626,21 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
     #endif
     SERIAL_ECHOPAIR(" (", position[Z_AXIS]);
     SERIAL_ECHOPAIR("->", target[Z_AXIS]);
     SERIAL_ECHOPAIR(") E:", e);
     SERIAL_ECHOPAIR(" (", position[E_AXIS]);
     SERIAL_ECHOPAIR("->", target[E_AXIS]);
     SERIAL_ECHOLNPGM(")");
   //*/
 
   // Queue the movement
-    if (
+  if (
     !_buffer_steps(target
       #if HAS_POSITION_FLOAT
         , target_float
       #endif
       #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
         , delta_mm_cart
       #endif
       , fr_mm_s, extruder, millimeters
     )
   ) return false;

commit c590e8ac05c3b417aa42ecd1f4967c4f70cfdd71
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 18:52:41 2019 -0500

    Improve Power-loss Recovery (#15135)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index d01acd8426..9618846f31 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -89,20 +89,24 @@
 #endif
 
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
 #if ENABLED(BACKLASH_COMPENSATION)
   #include "../feature/backlash.h"
 #endif
 
+#if ENABLED(POWER_LOSS_RECOVERY)
+  #include "../feature/power_loss_recovery.h"
+#endif
+
 // Delay for delivery of first block to the stepper ISR, if the queue contains 2 or
 // fewer movements. The delay is measured in milliseconds, and must be less than 250ms
 #define BLOCK_DELAY_FOR_1ST_MOVE 100
 
 Planner planner;
 
   // public:
 
 /**
  * A ring buffer of moves described in steps
@@ -2500,20 +2504,24 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   static_assert(COUNT(target) > 1, "Parameter to _buffer_steps must be (&target)[XYZE]!");
   COPY(position, target);
   #if HAS_POSITION_FLOAT
     COPY(position_float, target_float);
   #endif
 
   #if ENABLED(GRADIENT_MIX)
     mixer.gradient_control(target_float[Z_AXIS]);
   #endif
 
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    block->sdpos = recovery.command_sdpos();
+  #endif
+
   // Movement was accepted
   return true;
 } // _populate_block()
 
 /**
  * Planner::buffer_sync_block
  * Add a block to the buffer that just updates the position
  */
 void Planner::buffer_sync_block() {
   // Wait for the next available block

commit 75927e17dd2114c14a593c12394d941eff684685
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 18:48:58 2019 -0500

    Filament Width Sensor singleton (#15191)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 55e8462861..d01acd8426 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1321,28 +1321,28 @@ void Planner::check_axes_activity() {
   }
 
 #endif // !NO_VOLUMETRICS
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   /**
    * Convert the ratio value given by the filament width sensor
    * into a volumetric multiplier. Conversion differs when using
    * linear extrusion vs volumetric extrusion.
    */
-  void Planner::calculate_volumetric_for_width_sensor(const int8_t encoded_ratio) {
+  void Planner::apply_filament_width_sensor(const int8_t encoded_ratio) {
     // Reconstitute the nominal/measured ratio
     const float nom_meas_ratio = 1 + 0.01f * encoded_ratio,
                 ratio_2 = sq(nom_meas_ratio);
 
     volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = parser.volumetric_enabled
-      ? ratio_2 / CIRCLE_AREA(filament_width_nominal * 0.5f) // Volumetric uses a true volumetric multiplier
-      : ratio_2;                                             // Linear squares the ratio, which scales the volume
+      ? ratio_2 / CIRCLE_AREA(filwidth.nominal_mm * 0.5f) // Volumetric uses a true volumetric multiplier
+      : ratio_2;                                          // Linear squares the ratio, which scales the volume
 
     refresh_e_factor(FILAMENT_SENSOR_EXTRUDER_NUM);
   }
 #endif
 
 #if HAS_LEVELING
   /**
    * rx, ry, rz - Cartesian positions in mm
    *              Leveled XYZ on completion
    */
@@ -2062,51 +2062,22 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     block_buffer_runtime_us += segment_time_us;
     block->segment_time_us = segment_time_us;
 
     if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
   #endif
 
   block->nominal_speed_sqr = sq(block->millimeters * inverse_secs);   //   (mm/sec)^2 Always > 0
   block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
-    static float filwidth_e_count = 0, filwidth_delay_dist = 0;
-
-    //FMM update ring buffer used for delay with filament measurements
-    if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && filwidth_delay_index[1] >= 0) {  //only for extruder with filament sensor and if ring buffer is initialized
-
-      constexpr int MMD_CM = MAX_MEASUREMENT_DELAY + 1, MMD_MM = MMD_CM * 10;
-
-      // increment counters with next move in e axis
-      filwidth_e_count += delta_mm[E_AXIS];
-      filwidth_delay_dist += delta_mm[E_AXIS];
-
-      // Only get new measurements on forward E movement
-      if (!UNEAR_ZERO(filwidth_e_count)) {
-
-        // Loop the delay distance counter (modulus by the mm length)
-        while (filwidth_delay_dist >= MMD_MM) filwidth_delay_dist -= MMD_MM;
-
-        // Convert into an index into the measurement array
-        filwidth_delay_index[0] = int8_t(filwidth_delay_dist * 0.1f);
-
-        // If the index has changed (must have gone forward)...
-        if (filwidth_delay_index[0] != filwidth_delay_index[1]) {
-          filwidth_e_count = 0; // Reset the E movement counter
-          const int8_t meas_sample = thermalManager.widthFil_to_size_ratio();
-          do {
-            filwidth_delay_index[1] = (filwidth_delay_index[1] + 1) % MMD_CM; // The next unused slot
-            measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
-          } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
-        }
-      }
-    }
+    if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM)   // Only for extruder with filament sensor
+      filwidth.advance_e(delta_mm[E_AXIS]);
   #endif
 
   // Calculate and limit speed in mm/sec for each axis
   float current_speed[NUM_AXIS], speed_factor = 1.0f; // factor <1 decreases speed
   LOOP_XYZE(i) {
     #if BOTH(MIXING_EXTRUDER, RETRACT_SYNC_MIXING)
       // In worst case, only one extruder running, no change is needed.
       // In best case, all extruders run the same amount, we can divide by MIXING_STEPPERS
       float delta_mm_i = 0;
       if (i == E_AXIS && mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)

commit 584c86bed1d81548da03681bd3b3c6bd54ae0fe3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 02:20:49 2019 -0500

    More "zero extruders" changes (#15213)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 58934a467b..55e8462861 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -140,23 +140,24 @@ float Planner::steps_to_mm[XYZE_N];           // (mm) Millimeters per step
 #endif
 
 #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
-int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
-
-float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0f); // The flow percentage and volumetric multiplier combine to scale E movement
+#if EXTRUDERS
+  int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
+  float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0f); // The flow percentage and volumetric multiplier combine to scale E movement
+#endif
 
 #if DISABLED(NO_VOLUMETRICS)
   float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
         Planner::volumetric_area_nominal = CIRCLE_AREA(float(DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5f), // Nominal cross-sectional area
         Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
 #endif
 
 #if HAS_LEVELING
   bool Planner::leveling_active = false; // Flag that auto bed leveling is enabled
   #if ABL_PLANAR
@@ -1625,32 +1626,38 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
     , const float (&delta_mm_cart)[XYZE]
   #endif
   , float fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
   const int32_t da = target[A_AXIS] - position[A_AXIS],
                 db = target[B_AXIS] - position[B_AXIS],
                 dc = target[C_AXIS] - position[C_AXIS];
 
-  int32_t de = target[E_AXIS] - position[E_AXIS];
+  #if EXTRUDERS
+    int32_t de = target[E_AXIS] - position[E_AXIS];
+  #else
+    constexpr int32_t de = 0;
+  #endif
 
   /* <-- add a slash to enable
     SERIAL_ECHOPAIR("  _populate_block FR:", fr_mm_s);
     SERIAL_ECHOPAIR(" A:", target[A_AXIS]);
     SERIAL_ECHOPAIR(" (", da);
     SERIAL_ECHOPAIR(" steps) B:", target[B_AXIS]);
     SERIAL_ECHOPAIR(" (", db);
     SERIAL_ECHOPAIR(" steps) C:", target[C_AXIS]);
     SERIAL_ECHOPAIR(" (", dc);
-    SERIAL_ECHOPAIR(" steps) E:", target[E_AXIS]);
-    SERIAL_ECHOPAIR(" (", de);
+    #if EXTRUDERS
+      SERIAL_ECHOPAIR(" steps) E:", target[E_AXIS]);
+      SERIAL_ECHOPAIR(" (", de);
+    #endif
     SERIAL_ECHOLNPGM(" steps)");
   //*/
 
   #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           #if HAS_POSITION_FLOAT
             position_float[E_AXIS] = target_float[E_AXIS];
@@ -1705,22 +1712,26 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
     if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
     if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
   #else
     if (da < 0) SBI(dm, X_AXIS);
     if (db < 0) SBI(dm, Y_AXIS);
     if (dc < 0) SBI(dm, Z_AXIS);
   #endif
   if (de < 0) SBI(dm, E_AXIS);
 
-  const float esteps_float = de * e_factor[extruder];
-  const uint32_t esteps = ABS(esteps_float) + 0.5f;
+  #if EXTRUDERS
+    const float esteps_float = de * e_factor[extruder];
+    const uint32_t esteps = ABS(esteps_float) + 0.5f;
+  #else
+    constexpr uint32_t esteps = 0;
+  #endif
 
   // Clear all flags, including the "busy" bit
   block->flag = 0x00;
 
   // Set direction bits
   block->direction_bits = dm;
 
   // Number of steps for each axis
   // See http://www.corexy.com/theory.html
   #if CORE_IS_XY
@@ -1774,24 +1785,31 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
       delta_mm[B_AXIS] = (db + dc) * steps_to_mm[B_AXIS];
       delta_mm[C_AXIS] = CORESIGN(db - dc) * steps_to_mm[C_AXIS];
     #endif
   #else
     float delta_mm[ABCE];
     delta_mm[A_AXIS] = da * steps_to_mm[A_AXIS];
     delta_mm[B_AXIS] = db * steps_to_mm[B_AXIS];
     delta_mm[C_AXIS] = dc * steps_to_mm[C_AXIS];
   #endif
-  delta_mm[E_AXIS] = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
+
+  #if EXTRUDERS
+    delta_mm[E_AXIS] = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
+  #endif
 
   if (block->steps[A_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[B_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[C_AXIS] < MIN_STEPS_PER_SEGMENT) {
-    block->millimeters = ABS(delta_mm[E_AXIS]);
+    block->millimeters = (0
+      #if EXTRUDERS
+        + ABS(delta_mm[E_AXIS])
+      #endif
+    );
   }
   else {
     if (millimeters)
       block->millimeters = millimeters;
     else
       block->millimeters = SQRT(
         #if CORE_IS_XY
           sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS])
         #elif CORE_IS_XZ
           sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
@@ -1809,21 +1827,24 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
      * to blocks that would get dropped!
      *
      * A correction function is permitted to add steps to an axis, it
      * should *never* remove steps!
      */
     #if ENABLED(BACKLASH_COMPENSATION)
       backlash.add_correction_steps(da, db, dc, dm, block);
     #endif
   }
 
-  block->steps[E_AXIS] = esteps;
+  #if EXTRUDERS
+    block->steps[E_AXIS] = esteps;
+  #endif
+
   block->step_event_count = _MAX(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   #if ENABLED(MIXING_EXTRUDER)
     MIXER_POPULATE_BLOCK();
   #endif
 
   #if FAN_COUNT > 0
@@ -1867,143 +1888,145 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     if (block->steps[X_AXIS]) enable_X();
   #else
     if (block->steps[X_AXIS]) enable_X();
     if (block->steps[Y_AXIS]) enable_Y();
     #if DISABLED(Z_LATE_ENABLE)
       if (block->steps[Z_AXIS]) enable_Z();
     #endif
   #endif
 
   // Enable extruder(s)
-  if (esteps) {
-    #if ENABLED(AUTO_POWER_CONTROL)
-      powerManager.power_on();
-    #endif
+  #if EXTRUDERS
+    if (esteps) {
+      #if ENABLED(AUTO_POWER_CONTROL)
+        powerManager.power_on();
+      #endif
 
-    #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
+      #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
-      #define DISABLE_IDLE_E(N) if (!g_uc_extruder_last_move[N]) disable_E##N();
+        #define DISABLE_IDLE_E(N) if (!g_uc_extruder_last_move[N]) disable_E##N();
 
-      for (uint8_t i = 0; i < EXTRUDERS; i++)
-        if (g_uc_extruder_last_move[i] > 0) g_uc_extruder_last_move[i]--;
+        for (uint8_t i = 0; i < EXTRUDERS; i++)
+          if (g_uc_extruder_last_move[i] > 0) g_uc_extruder_last_move[i]--;
 
-      switch (extruder) {
-        case 0:
+        switch (extruder) {
+          case 0:
+            #if EXTRUDERS > 1
+              DISABLE_IDLE_E(1);
+              #if EXTRUDERS > 2
+                DISABLE_IDLE_E(2);
+                #if EXTRUDERS > 3
+                  DISABLE_IDLE_E(3);
+                  #if EXTRUDERS > 4
+                    DISABLE_IDLE_E(4);
+                    #if EXTRUDERS > 5
+                      DISABLE_IDLE_E(5);
+                    #endif // EXTRUDERS > 5
+                  #endif // EXTRUDERS > 4
+                #endif // EXTRUDERS > 3
+              #endif // EXTRUDERS > 2
+            #endif // EXTRUDERS > 1
+            enable_E0();
+            g_uc_extruder_last_move[0] = (BLOCK_BUFFER_SIZE) * 2;
+            #if HAS_DUPLICATION_MODE
+              if (extruder_duplication_enabled) {
+                enable_E1();
+                g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
+              }
+            #endif
+          break;
           #if EXTRUDERS > 1
-            DISABLE_IDLE_E(1);
-            #if EXTRUDERS > 2
-              DISABLE_IDLE_E(2);
-              #if EXTRUDERS > 3
-                DISABLE_IDLE_E(3);
-                #if EXTRUDERS > 4
-                  DISABLE_IDLE_E(4);
-                  #if EXTRUDERS > 5
-                    DISABLE_IDLE_E(5);
-                  #endif // EXTRUDERS > 5
-                #endif // EXTRUDERS > 4
-              #endif // EXTRUDERS > 3
-            #endif // EXTRUDERS > 2
-          #endif // EXTRUDERS > 1
-          enable_E0();
-          g_uc_extruder_last_move[0] = (BLOCK_BUFFER_SIZE) * 2;
-          #if HAS_DUPLICATION_MODE
-            if (extruder_duplication_enabled) {
+            case 1:
+              DISABLE_IDLE_E(0);
+              #if EXTRUDERS > 2
+                DISABLE_IDLE_E(2);
+                #if EXTRUDERS > 3
+                  DISABLE_IDLE_E(3);
+                  #if EXTRUDERS > 4
+                    DISABLE_IDLE_E(4);
+                    #if EXTRUDERS > 5
+                      DISABLE_IDLE_E(5);
+                    #endif // EXTRUDERS > 5
+                  #endif // EXTRUDERS > 4
+                #endif // EXTRUDERS > 3
+              #endif // EXTRUDERS > 2
               enable_E1();
               g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
-            }
-          #endif
-        break;
-        #if EXTRUDERS > 1
-          case 1:
-            DISABLE_IDLE_E(0);
-            #if EXTRUDERS > 2
-              DISABLE_IDLE_E(2);
-              #if EXTRUDERS > 3
-                DISABLE_IDLE_E(3);
-                #if EXTRUDERS > 4
-                  DISABLE_IDLE_E(4);
-                  #if EXTRUDERS > 5
-                    DISABLE_IDLE_E(5);
-                  #endif // EXTRUDERS > 5
-                #endif // EXTRUDERS > 4
-              #endif // EXTRUDERS > 3
-            #endif // EXTRUDERS > 2
-            enable_E1();
-            g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
-          break;
-          #if EXTRUDERS > 2
-            case 2:
-              DISABLE_IDLE_E(0);
-              DISABLE_IDLE_E(1);
-              #if EXTRUDERS > 3
-                DISABLE_IDLE_E(3);
-                #if EXTRUDERS > 4
-                  DISABLE_IDLE_E(4);
-                  #if EXTRUDERS > 5
-                    DISABLE_IDLE_E(5);
-                  #endif
-                #endif
-              #endif
-              enable_E2();
-              g_uc_extruder_last_move[2] = (BLOCK_BUFFER_SIZE) * 2;
             break;
-            #if EXTRUDERS > 3
-              case 3:
+            #if EXTRUDERS > 2
+              case 2:
                 DISABLE_IDLE_E(0);
                 DISABLE_IDLE_E(1);
-                DISABLE_IDLE_E(2);
-                #if EXTRUDERS > 4
-                  DISABLE_IDLE_E(4);
-                  #if EXTRUDERS > 5
-                    DISABLE_IDLE_E(5);
+                #if EXTRUDERS > 3
+                  DISABLE_IDLE_E(3);
+                  #if EXTRUDERS > 4
+                    DISABLE_IDLE_E(4);
+                    #if EXTRUDERS > 5
+                      DISABLE_IDLE_E(5);
+                    #endif
                   #endif
                 #endif
-                enable_E3();
-                g_uc_extruder_last_move[3] = (BLOCK_BUFFER_SIZE) * 2;
+                enable_E2();
+                g_uc_extruder_last_move[2] = (BLOCK_BUFFER_SIZE) * 2;
               break;
-              #if EXTRUDERS > 4
-                case 4:
+              #if EXTRUDERS > 3
+                case 3:
                   DISABLE_IDLE_E(0);
                   DISABLE_IDLE_E(1);
                   DISABLE_IDLE_E(2);
-                  DISABLE_IDLE_E(3);
-                  #if EXTRUDERS > 5
-                    DISABLE_IDLE_E(5);
+                  #if EXTRUDERS > 4
+                    DISABLE_IDLE_E(4);
+                    #if EXTRUDERS > 5
+                      DISABLE_IDLE_E(5);
+                    #endif
                   #endif
-                  enable_E4();
-                  g_uc_extruder_last_move[4] = (BLOCK_BUFFER_SIZE) * 2;
+                  enable_E3();
+                  g_uc_extruder_last_move[3] = (BLOCK_BUFFER_SIZE) * 2;
                 break;
-                #if EXTRUDERS > 5
-                  case 5:
+                #if EXTRUDERS > 4
+                  case 4:
                     DISABLE_IDLE_E(0);
                     DISABLE_IDLE_E(1);
                     DISABLE_IDLE_E(2);
                     DISABLE_IDLE_E(3);
-                    DISABLE_IDLE_E(4);
-                    enable_E5();
-                    g_uc_extruder_last_move[5] = (BLOCK_BUFFER_SIZE) * 2;
+                    #if EXTRUDERS > 5
+                      DISABLE_IDLE_E(5);
+                    #endif
+                    enable_E4();
+                    g_uc_extruder_last_move[4] = (BLOCK_BUFFER_SIZE) * 2;
                   break;
-                #endif // EXTRUDERS > 5
-              #endif // EXTRUDERS > 4
-            #endif // EXTRUDERS > 3
-          #endif // EXTRUDERS > 2
-        #endif // EXTRUDERS > 1
-      }
-    #else
-      enable_E0();
-      enable_E1();
-      enable_E2();
-      enable_E3();
-      enable_E4();
-      enable_E5();
-    #endif
-  }
+                  #if EXTRUDERS > 5
+                    case 5:
+                      DISABLE_IDLE_E(0);
+                      DISABLE_IDLE_E(1);
+                      DISABLE_IDLE_E(2);
+                      DISABLE_IDLE_E(3);
+                      DISABLE_IDLE_E(4);
+                      enable_E5();
+                      g_uc_extruder_last_move[5] = (BLOCK_BUFFER_SIZE) * 2;
+                    break;
+                  #endif // EXTRUDERS > 5
+                #endif // EXTRUDERS > 4
+              #endif // EXTRUDERS > 3
+            #endif // EXTRUDERS > 2
+          #endif // EXTRUDERS > 1
+        }
+      #else
+        enable_E0();
+        enable_E1();
+        enable_E2();
+        enable_E3();
+        enable_E4();
+        enable_E5();
+      #endif
+    }
+  #endif // EXTRUDERS
 
   if (esteps)
     NOLESS(fr_mm_s, settings.min_feedrate_mm_s);
   else
     NOLESS(fr_mm_s, settings.min_travel_feedrate_mm_s);
 
   const float inverse_millimeters = 1.0f / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate inverse time for this move. No divide by zero due to previous checks.
   // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.

commit 565a0e11ed2d386ef343bf68274334c884dc6dbf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 9 02:56:23 2019 -0500

    Prevent 'current' name conflict, if needed

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 77da3a0c35..58934a467b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -987,37 +987,37 @@ void Planner::forward_pass() {
 
   // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
   // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
 
   // Begin at buffer planned pointer. Note that block_buffer_planned can be modified
   //  by the stepper ISR,  so read it ONCE. It it guaranteed that block_buffer_planned
   //  will never lead head, so the loop is safe to execute. Also note that the forward
   //  pass will never modify the values at the tail.
   uint8_t block_index = block_buffer_planned;
 
-  block_t *current;
+  block_t *block;
   const block_t * previous = nullptr;
   while (block_index != block_buffer_head) {
 
     // Perform the forward pass
-    current = &block_buffer[block_index];
+    block = &block_buffer[block_index];
 
     // Skip SYNC blocks
-    if (!TEST(current->flag, BLOCK_BIT_SYNC_POSITION)) {
+    if (!TEST(block->flag, BLOCK_BIT_SYNC_POSITION)) {
       // If there's no previous block or the previous block is not
       // BUSY (thus, modifiable) run the forward_pass_kernel. Otherwise,
       // the previous block became BUSY, so assume the current block's
       // entry speed can't be altered (since that would also require
       // updating the exit speed of the previous block).
       if (!previous || !stepper.is_block_busy(previous))
-        forward_pass_kernel(previous, current, block_index);
-      previous = current;
+        forward_pass_kernel(previous, block, block_index);
+      previous = block;
     }
     // Advance to the previous
     block_index = next_block_index(block_index);
   }
 }
 
 /**
  * Recalculate the trapezoid speed profiles for all blocks in the plan
  * according to the entry_factor for each junction. Must be called by
  * recalculate() after updating the blocks.
@@ -1038,83 +1038,83 @@ void Planner::recalculate_trapezoids() {
     block_t *prev = &block_buffer[prev_index];
 
     // If not dealing with a sync block, we are done. The last block is not a SYNC block
     if (!TEST(prev->flag, BLOCK_BIT_SYNC_POSITION)) break;
 
     // Examine the previous block. This and all following are SYNC blocks
     head_block_index = prev_index;
   }
 
   // Go from the tail (currently executed block) to the first block, without including it)
-  block_t *current = nullptr, *next = nullptr;
+  block_t *block = nullptr, *next = nullptr;
   float current_entry_speed = 0.0, next_entry_speed = 0.0;
   while (block_index != head_block_index) {
 
     next = &block_buffer[block_index];
 
     // Skip sync blocks
     if (!TEST(next->flag, BLOCK_BIT_SYNC_POSITION)) {
       next_entry_speed = SQRT(next->entry_speed_sqr);
 
-      if (current) {
+      if (block) {
         // Recalculate if current block entry or exit junction speed has changed.
-        if (TEST(current->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
+        if (TEST(block->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
 
           // Mark the current block as RECALCULATE, to protect it from the Stepper ISR running it.
           // Note that due to the above condition, there's a chance the current block isn't marked as
           // RECALCULATE yet, but the next one is. That's the reason for the following line.
-          SBI(current->flag, BLOCK_BIT_RECALCULATE);
+          SBI(block->flag, BLOCK_BIT_RECALCULATE);
 
           // But there is an inherent race condition here, as the block maybe
           // became BUSY, just before it was marked as RECALCULATE, so check
           // if that is the case!
-          if (!stepper.is_block_busy(current)) {
+          if (!stepper.is_block_busy(block)) {
             // Block is not BUSY, we won the race against the Stepper ISR:
 
             // NOTE: Entry and exit factors always > 0 by all previous logic operations.
-            const float current_nominal_speed = SQRT(current->nominal_speed_sqr),
+            const float current_nominal_speed = SQRT(block->nominal_speed_sqr),
                         nomr = 1.0f / current_nominal_speed;
-            calculate_trapezoid_for_block(current, current_entry_speed * nomr, next_entry_speed * nomr);
+            calculate_trapezoid_for_block(block, current_entry_speed * nomr, next_entry_speed * nomr);
             #if ENABLED(LIN_ADVANCE)
-              if (current->use_advance_lead) {
-                const float comp = current->e_D_ratio * extruder_advance_K[active_extruder] * settings.axis_steps_per_mm[E_AXIS];
-                current->max_adv_steps = current_nominal_speed * comp;
-                current->final_adv_steps = next_entry_speed * comp;
+              if (block->use_advance_lead) {
+                const float comp = block->e_D_ratio * extruder_advance_K[active_extruder] * settings.axis_steps_per_mm[E_AXIS];
+                block->max_adv_steps = current_nominal_speed * comp;
+                block->final_adv_steps = next_entry_speed * comp;
               }
             #endif
           }
 
           // Reset current only to ensure next trapezoid is computed - The
           // stepper is free to use the block from now on.
-          CBI(current->flag, BLOCK_BIT_RECALCULATE);
+          CBI(block->flag, BLOCK_BIT_RECALCULATE);
         }
       }
 
-      current = next;
+      block = next;
       current_entry_speed = next_entry_speed;
     }
 
     block_index = next_block_index(block_index);
   }
 
   // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
   if (next) {
 
     // Mark the next(last) block as RECALCULATE, to prevent the Stepper ISR running it.
     // As the last block is always recalculated here, there is a chance the block isn't
     // marked as RECALCULATE yet. That's the reason for the following line.
     SBI(next->flag, BLOCK_BIT_RECALCULATE);
 
     // But there is an inherent race condition here, as the block maybe
     // became BUSY, just before it was marked as RECALCULATE, so check
     // if that is the case!
-    if (!stepper.is_block_busy(current)) {
+    if (!stepper.is_block_busy(block)) {
       // Block is not BUSY, we won the race against the Stepper ISR:
 
       const float next_nominal_speed = SQRT(next->nominal_speed_sqr),
                   nomr = 1.0f / next_nominal_speed;
       calculate_trapezoid_for_block(next, next_entry_speed * nomr, float(MINIMUM_PLANNER_SPEED) * nomr);
       #if ENABLED(LIN_ADVANCE)
         if (next->use_advance_lead) {
           const float comp = next->e_D_ratio * extruder_advance_K[active_extruder] * settings.axis_steps_per_mm[E_AXIS];
           next->max_adv_steps = next_nominal_speed * comp;
           next->final_adv_steps = (MINIMUM_PLANNER_SPEED) * comp;

commit ec3f29a33a656b2c1901d4dc3124adf44e9199a1
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sun Sep 8 03:30:47 2019 +0200

    Fix linux_native long to int32 warnings (#15192)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 56695f3a9b..77da3a0c35 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2577,24 +2577,24 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
   #if ENABLED(DISTINCT_E_FACTORS)
     if (last_extruder != extruder && settings.axis_steps_per_mm[E_AXIS_N(extruder)] != settings.axis_steps_per_mm[E_AXIS_N(last_extruder)]) {
       position[E_AXIS] = LROUND(position[E_AXIS] * settings.axis_steps_per_mm[E_AXIS_N(extruder)] * steps_to_mm[E_AXIS_N(last_extruder)]);
       last_extruder = extruder;
     }
   #endif
 
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
   const int32_t target[ABCE] = {
-    LROUND(a * settings.axis_steps_per_mm[A_AXIS]),
-    LROUND(b * settings.axis_steps_per_mm[B_AXIS]),
-    LROUND(c * settings.axis_steps_per_mm[C_AXIS]),
-    LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(extruder)])
+    int32_t(LROUND(a * settings.axis_steps_per_mm[A_AXIS])),
+    int32_t(LROUND(b * settings.axis_steps_per_mm[B_AXIS])),
+    int32_t(LROUND(c * settings.axis_steps_per_mm[C_AXIS])),
+    int32_t(LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(extruder)]))
   };
 
   #if HAS_POSITION_FLOAT
     const float target_float[XYZE] = { a, b, c, e };
   #endif
 
   // DRYRUN prevents E moves from taking place
   if (DEBUGGING(DRYRUN)) {
     position[E_AXIS] = target[E_AXIS];
     #if HAS_POSITION_FLOAT

commit 587d4a63731be776bb3deba878bd0509d386a72a
Author: AnHardt <github@kitelab.de>
Date:   Sat Aug 17 04:17:10 2019 +0200

    Repair display throttling (#14960)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index b8bc07069e..56695f3a9b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2030,20 +2030,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       }
     }
   #endif
 
   #if HAS_SPI_LCD
     // Protect the access to the position.
     const bool was_enabled = STEPPER_ISR_ENABLED();
     if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
 
     block_buffer_runtime_us += segment_time_us;
+    block->segment_time_us = segment_time_us;
 
     if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
   #endif
 
   block->nominal_speed_sqr = sq(block->millimeters * inverse_secs);   //   (mm/sec)^2 Always > 0
   block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     static float filwidth_e_count = 0, filwidth_delay_dist = 0;
 

commit eae543adf34268505f9321b7576495db20293c09
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jul 29 18:45:01 2019 -0500

    Apply HAS_SPI_LCD as needed

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index a755cafca4..b8bc07069e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -205,21 +205,21 @@ float Planner::previous_speed[NUM_AXIS],
 #endif
 
 #if HAS_POSITION_FLOAT
   float Planner::position_float[XYZE]; // Needed for accurate maths. Steps cannot be used!
 #endif
 
 #if IS_KINEMATIC
   float Planner::position_cart[XYZE];
 #endif
 
-#if ENABLED(ULTRA_LCD)
+#if HAS_SPI_LCD
   volatile uint32_t Planner::block_buffer_runtime_us = 0;
 #endif
 
 /**
  * Class and Instance Methods
  */
 
 Planner::Planner() { init(); }
 
 void Planner::init() {
@@ -1462,21 +1462,21 @@ void Planner::quick_stop() {
   const bool was_enabled = STEPPER_ISR_ENABLED();
   if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
 
   // Drop all queue entries
   block_buffer_nonbusy = block_buffer_planned = block_buffer_head = block_buffer_tail;
 
   // Restart the block delay for the first movement - As the queue was
   // forced to empty, there's no risk the ISR will touch this.
   delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
 
-  #if ENABLED(ULTRA_LCD)
+  #if HAS_SPI_LCD
     // Clear the accumulated runtime
     clear_block_buffer_runtime();
   #endif
 
   // Make sure to drop any attempt of queuing moves for at least 1 second
   cleaning_buffer_counter = 1000;
 
   // Reenable Stepper ISR
   if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
 
@@ -2017,28 +2017,28 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     // Segment time im micro seconds
     uint32_t segment_time_us = LROUND(1000000.0f / inverse_secs);
   #endif
 
   #if ENABLED(SLOWDOWN)
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
       if (segment_time_us < settings.min_segment_time_us) {
         // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
         const uint32_t nst = segment_time_us + LROUND(2 * (settings.min_segment_time_us - segment_time_us) / moves_queued);
         inverse_secs = 1000000.0f / nst;
-        #if defined(XY_FREQUENCY_LIMIT) || ENABLED(ULTRA_LCD)
+        #if defined(XY_FREQUENCY_LIMIT) || HAS_SPI_LCD
           segment_time_us = nst;
         #endif
       }
     }
   #endif
 
-  #if ENABLED(ULTRA_LCD)
+  #if HAS_SPI_LCD
     // Protect the access to the position.
     const bool was_enabled = STEPPER_ISR_ENABLED();
     if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
 
     block_buffer_runtime_us += segment_time_us;
 
     if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
   #endif
 
   block->nominal_speed_sqr = sq(block->millimeters * inverse_secs);   //   (mm/sec)^2 Always > 0

commit ed0e6afacbbd5ef8836166feccbd4b50fc9da009
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 10 03:33:28 2019 -0500

    Apply LIMIT macro

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 561d2b6469..a755cafca4 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1150,21 +1150,21 @@ void Planner::recalculate() {
     float high = 0.0;
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block_t* block = &block_buffer[b];
       if (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS]) {
         const float se = (float)block->steps[E_AXIS] / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;
         NOLESS(high, se);
       }
     }
 
     float t = autotemp_min + high * autotemp_factor;
-    t = constrain(t, autotemp_min, autotemp_max);
+    LIMIT(t, autotemp_min, autotemp_max);
     if (t < oldt) t = t * (1 - float(AUTOTEMP_OLDWEIGHT)) + oldt * float(AUTOTEMP_OLDWEIGHT);
     oldt = t;
     thermalManager.setTargetHotend(t, 0);
   }
 
 #endif // AUTOTEMP
 
 /**
  * Maintain fans, paste extruder pressure,
  */

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 6f531c7208..561d2b6469 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -726,21 +726,21 @@ void Planner::calculate_trapezoid_for_block(block_t* const block, const float &e
            decelerate_steps = FLOOR(estimate_acceleration_distance(block->nominal_rate, final_rate, -accel));
           // Steps between acceleration and deceleration, if any
   int32_t plateau_steps = block->step_event_count - accelerate_steps - decelerate_steps;
 
   // Does accelerate_steps + decelerate_steps exceed step_event_count?
   // Then we can't possibly reach the nominal rate, there will be no cruising.
   // Use intersection_distance() to calculate accel / braking time in order to
   // reach the final_rate exactly at the end of this block.
   if (plateau_steps < 0) {
     const float accelerate_steps_float = CEIL(intersection_distance(initial_rate, final_rate, accel, block->step_event_count));
-    accelerate_steps = MIN(uint32_t(MAX(accelerate_steps_float, 0)), block->step_event_count);
+    accelerate_steps = _MIN(uint32_t(_MAX(accelerate_steps_float, 0)), block->step_event_count);
     plateau_steps = 0;
 
     #if ENABLED(S_CURVE_ACCELERATION)
       // We won't reach the cruising rate. Let's calculate the speed we will reach
       cruise_rate = final_speed(initial_rate, accel, accelerate_steps);
     #endif
   }
   #if ENABLED(S_CURVE_ACCELERATION)
     else // We have some plateau time, so the cruise rate will be the nominal rate
       cruise_rate = block->nominal_rate;
@@ -848,21 +848,21 @@ void Planner::reverse_pass_kernel(block_t* const current, const block_t * const
       // If nominal length true, max junction speed is guaranteed to be reached.
       // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
       // the current block and next block junction speeds are guaranteed to always be at their maximum
       // junction speeds in deceleration and acceleration, respectively. This is due to how the current
       // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
       // the reverse and forward planners, the corresponding block junction speed will always be at the
       // the maximum junction speed and may always be ignored for any speed reduction checks.
 
       const float new_entry_speed_sqr = TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH)
         ? max_entry_speed_sqr
-        : MIN(max_entry_speed_sqr, max_allowable_speed_sqr(-current->acceleration, next ? next->entry_speed_sqr : sq(float(MINIMUM_PLANNER_SPEED)), current->millimeters));
+        : _MIN(max_entry_speed_sqr, max_allowable_speed_sqr(-current->acceleration, next ? next->entry_speed_sqr : sq(float(MINIMUM_PLANNER_SPEED)), current->millimeters));
       if (current->entry_speed_sqr != new_entry_speed_sqr) {
 
         // Need to recalculate the block speed - Mark it now, so the stepper
         // ISR does not consume the block before being recalculated
         SBI(current->flag, BLOCK_BIT_RECALCULATE);
 
         // But there is an inherent race condition here, as the block may have
         // become BUSY just before being marked RECALCULATE, so check for that!
         if (stepper.is_block_busy(current)) {
           // Block became busy. Clear the RECALCULATE flag (no point in
@@ -1810,21 +1810,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
      *
      * A correction function is permitted to add steps to an axis, it
      * should *never* remove steps!
      */
     #if ENABLED(BACKLASH_COMPENSATION)
       backlash.add_correction_steps(da, db, dc, dm, block);
     #endif
   }
 
   block->steps[E_AXIS] = esteps;
-  block->step_event_count = MAX(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
+  block->step_event_count = _MAX(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   #if ENABLED(MIXING_EXTRUDER)
     MIXER_POPULATE_BLOCK();
   #endif
 
   #if FAN_COUNT > 0
     FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
@@ -2121,23 +2121,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     }
     xs0 = axis_segment_time_us[X_AXIS][0] = xs0 + segment_time_us;
 
     if (TEST(direction_change, Y_AXIS)) {
       ys2 = axis_segment_time_us[Y_AXIS][2] = axis_segment_time_us[Y_AXIS][1];
       ys1 = axis_segment_time_us[Y_AXIS][1] = axis_segment_time_us[Y_AXIS][0];
       ys0 = 0;
     }
     ys0 = axis_segment_time_us[Y_AXIS][0] = ys0 + segment_time_us;
 
-    const uint32_t max_x_segment_time = MAX(xs0, xs1, xs2),
-                   max_y_segment_time = MAX(ys0, ys1, ys2),
-                   min_xy_segment_time = MIN(max_x_segment_time, max_y_segment_time);
+    const uint32_t max_x_segment_time = _MAX(xs0, xs1, xs2),
+                   max_y_segment_time = _MAX(ys0, ys1, ys2),
+                   min_xy_segment_time = _MIN(max_x_segment_time, max_y_segment_time);
     if (min_xy_segment_time < MAX_FREQ_TIME_US) {
       const float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME_US);
       NOMORE(speed_factor, low_sf);
     }
   #endif // XY_FREQUENCY_LIMIT
 
   // Correct the speed
   if (speed_factor < 1.0f) {
     LOOP_XYZE(i) current_speed[i] *= speed_factor;
     block->nominal_rate *= speed_factor;
@@ -2363,21 +2363,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
           // If angle is greater than 135 degrees (octagon), find speed for approximate arc
           if (junction_theta > RADIANS(135)) {
             const float limit_sqr = block->millimeters / (RADIANS(180) - junction_theta) * junction_acceleration;
             NOMORE(vmax_junction_sqr, limit_sqr);
           }
         }
       }
 
       // Get the lowest speed
-      vmax_junction_sqr = MIN(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
+      vmax_junction_sqr = _MIN(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
       vmax_junction_sqr = 0;
 
     COPY(previous_unit_vec, unit_vec);
 
   #endif
 
   #if HAS_CLASSIC_JERK
 
@@ -2420,79 +2420,79 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
       // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
 
       // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
       float v_factor = 1;
       limited = 0;
 
       // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
       // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
       const float previous_nominal_speed = SQRT(previous_nominal_speed_sqr);
-      vmax_junction = MIN(nominal_speed, previous_nominal_speed);
+      vmax_junction = _MIN(nominal_speed, previous_nominal_speed);
 
       // Now limit the jerk in all axes.
       const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
       #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
         LOOP_XYZ(axis)
       #else
         LOOP_XYZE(axis)
       #endif
       {
         // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
         float v_exit = previous_speed[axis] * smaller_speed_factor,
               v_entry = current_speed[axis];
         if (limited) {
           v_exit *= v_factor;
           v_entry *= v_factor;
         }
 
         // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
         const float jerk = (v_exit > v_entry)
             ? //                                  coasting             axis reversal
-              ( (v_entry > 0 || v_exit < 0) ? (v_exit - v_entry) : MAX(v_exit, -v_entry) )
+              ( (v_entry > 0 || v_exit < 0) ? (v_exit - v_entry) : _MAX(v_exit, -v_entry) )
             : // v_exit <= v_entry                coasting             axis reversal
-              ( (v_entry < 0 || v_exit > 0) ? (v_entry - v_exit) : MAX(-v_exit, v_entry) );
+              ( (v_entry < 0 || v_exit > 0) ? (v_entry - v_exit) : _MAX(-v_exit, v_entry) );
 
         if (jerk > max_jerk[axis]) {
           v_factor *= max_jerk[axis] / jerk;
           ++limited;
         }
       }
       if (limited) vmax_junction *= v_factor;
       // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
       // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
       const float vmax_junction_threshold = vmax_junction * 0.99f;
       if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold)
         vmax_junction = safe_speed;
     }
     else
       vmax_junction = safe_speed;
 
     previous_safe_speed = safe_speed;
 
     #if ENABLED(JUNCTION_DEVIATION)
-      vmax_junction_sqr = MIN(vmax_junction_sqr, sq(vmax_junction));
+      vmax_junction_sqr = _MIN(vmax_junction_sqr, sq(vmax_junction));
     #else
       vmax_junction_sqr = sq(vmax_junction);
     #endif
 
   #endif // Classic Jerk Limiting
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed_sqr = vmax_junction_sqr;
 
   // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
   const float v_allowable_sqr = max_allowable_speed_sqr(-block->acceleration, sq(float(MINIMUM_PLANNER_SPEED)), block->millimeters);
 
   // If we are trying to add a split block, start with the
   // max. allowed speed to avoid an interrupted first move.
-  block->entry_speed_sqr = !split_move ? sq(float(MINIMUM_PLANNER_SPEED)) : MIN(vmax_junction_sqr, v_allowable_sqr);
+  block->entry_speed_sqr = !split_move ? sq(float(MINIMUM_PLANNER_SPEED)) : _MIN(vmax_junction_sqr, v_allowable_sqr);
 
   // Initialize planner efficiency flags
   // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
   // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
   // the current block and next block junction speeds are guaranteed to always be at their maximum
   // junction speeds in deceleration and acceleration, respectively. This is due to how the current
   // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
   block->flag |= block->nominal_speed_sqr <= v_allowable_sqr ? BLOCK_FLAG_RECALCULATE | BLOCK_FLAG_NOMINAL_LENGTH : BLOCK_FLAG_RECALCULATE;

commit d4415dcf592bbb1db869316a3020d92fa5a23edb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 2 04:04:49 2019 -0500

    Fix analogWrite ambiguity

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e6f07b66c5..6f531c7208 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1282,24 +1282,24 @@ void Planner::check_axes_activity() {
     #endif
 
   #endif // FAN_COUNT > 0
 
   #if ENABLED(AUTOTEMP)
     getHighESpeed();
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
-      analogWrite(HEATER_1_PIN, tail_valve_pressure);
+      analogWrite(pin_t(HEATER_1_PIN), tail_valve_pressure);
     #endif
     #if HAS_HEATER_2
-      analogWrite(HEATER_2_PIN, tail_e_to_p_pressure);
+      analogWrite(pin_t(HEATER_2_PIN), tail_e_to_p_pressure);
     #endif
   #endif
 }
 
 #if DISABLED(NO_VOLUMETRICS)
 
   /**
    * Get a volumetric multiplier from a filament diameter.
    * This is the reciprocal of the circular cross-section area.
    * Return 1.0 with volumetric off or a diameter of 0.0.

commit 4d5a1984e216098b49cf1c590272b45d4177e86f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 28 17:03:43 2019 -0500

    Simplified fan handling code

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 06612bd8ba..e6f07b66c5 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1162,42 +1162,48 @@ void Planner::recalculate() {
     oldt = t;
     thermalManager.setTargetHotend(t, 0);
   }
 
 #endif // AUTOTEMP
 
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
-  uint8_t axis_active[NUM_AXIS] = { 0 },
-          tail_fan_speed[FAN_COUNT];
+  uint8_t axis_active[NUM_AXIS] = { 0 };
+
+  #if FAN_COUNT > 0
+    uint8_t tail_fan_speed[FAN_COUNT];
+  #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
     #endif
     #if HAS_HEATER_2
       uint8_t tail_e_to_p_pressure;
     #endif
   #endif
 
   if (has_blocks_queued()) {
+    block_t* block;
+
+    #if FAN_COUNT > 0 || ENABLED(BARICUDA)
+      block = &block_buffer[block_buffer_tail];
+    #endif
+
     #if FAN_COUNT > 0
       FANS_LOOP(i)
-        tail_fan_speed[i] = thermalManager.scaledFanSpeed(i, block_buffer[block_buffer_tail].fan_speed[i]);
+        tail_fan_speed[i] = thermalManager.scaledFanSpeed(i, block->fan_speed[i]);
     #endif
 
-    block_t* block;
-
     #if ENABLED(BARICUDA)
-      block = &block_buffer[block_buffer_tail];
       #if HAS_HEATER_1
         tail_valve_pressure = block->valve_pressure;
       #endif
       #if HAS_HEATER_2
         tail_e_to_p_pressure = block->e_to_p_pressure;
       #endif
     #endif
 
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block = &block_buffer[b];
@@ -1229,89 +1235,59 @@ void Planner::check_axes_activity() {
   #if ENABLED(DISABLE_Z)
     if (!axis_active[Z_AXIS]) disable_Z();
   #endif
   #if ENABLED(DISABLE_E)
     if (!axis_active[E_AXIS]) disable_e_steppers();
   #endif
 
   #if FAN_COUNT > 0
 
     #if FAN_KICKSTART_TIME > 0
-
       static millis_t fan_kick_end[FAN_COUNT] = { 0 };
-
-      #define KICKSTART_FAN(f) \
-        if (tail_fan_speed[f]) { \
-          millis_t ms = millis(); \
-          if (fan_kick_end[f] == 0) { \
+      #define KICKSTART_FAN(f)                         \
+        if (tail_fan_speed[f]) {                       \
+          millis_t ms = millis();                      \
+          if (fan_kick_end[f] == 0) {                  \
             fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \
-            tail_fan_speed[f] = 255; \
-          } else if (PENDING(ms, fan_kick_end[f])) \
-            tail_fan_speed[f] = 255; \
+            tail_fan_speed[f] = 255;                   \
+          } else if (PENDING(ms, fan_kick_end[f]))     \
+            tail_fan_speed[f] = 255;                   \
         } else fan_kick_end[f] = 0
-
-      #if HAS_FAN0
-        KICKSTART_FAN(0);
-      #endif
-      #if HAS_FAN1
-        KICKSTART_FAN(1);
-      #endif
-      #if HAS_FAN2
-        KICKSTART_FAN(2);
-      #endif
-
-    #endif // FAN_KICKSTART_TIME > 0
+    #else
+      #define KICKSTART_FAN(f) NOOP
+    #endif
 
     #if FAN_MIN_PWM != 0 || FAN_MAX_PWM != 255
       #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ? map(tail_fan_speed[f], 1, 255, FAN_MIN_PWM, FAN_MAX_PWM) : 0)
     #else
       #define CALC_FAN_SPEED(f) tail_fan_speed[f]
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
-
-      #if HAS_FAN0
-        thermalManager.soft_pwm_amount_fan[0] = CALC_FAN_SPEED(0);
-      #endif
-      #if HAS_FAN1
-        thermalManager.soft_pwm_amount_fan[1] = CALC_FAN_SPEED(1);
-      #endif
-      #if HAS_FAN2
-        thermalManager.soft_pwm_amount_fan[2] = CALC_FAN_SPEED(2);
-      #endif
-
+      #define _FAN_SET(F) thermalManager.soft_pwm_amount_fan[F] = CALC_FAN_SPEED(F);
     #elif ENABLED(FAST_PWM_FAN)
-
-      #if HAS_FAN0
-        set_pwm_duty(FAN_PIN, CALC_FAN_SPEED(0));
-      #endif
-      #if HAS_FAN1
-        set_pwm_duty(FAN1_PIN, CALC_FAN_SPEED(1));
-      #endif
-      #if HAS_FAN2
-        set_pwm_duty(FAN2_PIN, CALC_FAN_SPEED(2));
-      #endif
-
+      #define _FAN_SET(F) set_pwm_duty(FAN##F##_PIN, CALC_FAN_SPEED(F));
     #else
+      #define _FAN_SET(F) analogWrite(pin_t(FAN##F##_PIN), CALC_FAN_SPEED(F));
+    #endif
+    #define FAN_SET(F) do{ KICKSTART_FAN(F); _FAN_SET(F); }while(0)
 
-      #if HAS_FAN0
-        analogWrite(pin_t(FAN_PIN), CALC_FAN_SPEED(0));
-      #endif
-      #if HAS_FAN1
-        analogWrite(pin_t(FAN1_PIN), CALC_FAN_SPEED(1));
-      #endif
-      #if HAS_FAN2
-        analogWrite(pin_t(FAN2_PIN), CALC_FAN_SPEED(2));
-      #endif
+    #if HAS_FAN0
+      FAN_SET(0);
     #endif
-  #else
-    UNUSED(tail_fan_speed);
+    #if HAS_FAN1
+      FAN_SET(1);
+    #endif
+    #if HAS_FAN2
+      FAN_SET(2);
+    #endif
+
   #endif // FAN_COUNT > 0
 
   #if ENABLED(AUTOTEMP)
     getHighESpeed();
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       analogWrite(HEATER_1_PIN, tail_valve_pressure);
     #endif

commit a8d68b7c8a5ed440b2d12aea077ad05cadbaadfd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 28 13:58:40 2019 -0500

    Common method for scaled fan speed

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index d402604743..06612bd8ba 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1177,21 +1177,21 @@ void Planner::check_axes_activity() {
       uint8_t tail_valve_pressure;
     #endif
     #if HAS_HEATER_2
       uint8_t tail_e_to_p_pressure;
     #endif
   #endif
 
   if (has_blocks_queued()) {
     #if FAN_COUNT > 0
       FANS_LOOP(i)
-        tail_fan_speed[i] = (block_buffer[block_buffer_tail].fan_speed[i] * uint16_t(thermalManager.fan_speed_scaler[i])) >> 7;
+        tail_fan_speed[i] = thermalManager.scaledFanSpeed(i, block_buffer[block_buffer_tail].fan_speed[i]);
     #endif
 
     block_t* block;
 
     #if ENABLED(BARICUDA)
       block = &block_buffer[block_buffer_tail];
       #if HAS_HEATER_1
         tail_valve_pressure = block->valve_pressure;
       #endif
       #if HAS_HEATER_2
@@ -1200,21 +1200,21 @@ void Planner::check_axes_activity() {
     #endif
 
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block = &block_buffer[b];
       LOOP_XYZE(i) if (block->steps[i]) axis_active[i]++;
     }
   }
   else {
     #if FAN_COUNT > 0
       FANS_LOOP(i)
-        tail_fan_speed[i] = (thermalManager.fan_speed[i] * uint16_t(thermalManager.fan_speed_scaler[i])) >> 7;
+        tail_fan_speed[i] = thermalManager.scaledFanSpeed(i);
     #endif
 
     #if ENABLED(BARICUDA)
       #if HAS_HEATER_1
         tail_valve_pressure = baricuda_valve_pressure;
       #endif
       #if HAS_HEATER_2
         tail_e_to_p_pressure = baricuda_e_to_p_pressure;
       #endif
     #endif

commit 9da02d21149c5731e3da6af3bdabc32d541d1612
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 28 13:40:05 2019 -0500

    Help syntax highlighting (Sublime, et. al.)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index bf07c30878..d402604743 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2761,25 +2761,27 @@ void Planner::set_machine_position_mm(const float &a, const float &b, const floa
     //ZERO(previous_speed);
     buffer_sync_block();
   }
   else
     stepper.set_position(position[A_AXIS], position[B_AXIS], position[C_AXIS], position[E_AXIS]);
 }
 
 void Planner::set_position_mm(const float &rx, const float &ry, const float &rz, const float &e) {
   float raw[XYZE] = { rx, ry, rz, e };
   #if HAS_POSITION_MODIFIERS
+  {
     apply_modifiers(raw
       #if HAS_LEVELING
         , true
       #endif
     );
+  }
   #endif
   #if IS_KINEMATIC
     position_cart[X_AXIS] = rx;
     position_cart[Y_AXIS] = ry;
     position_cart[Z_AXIS] = rz;
     position_cart[E_AXIS] = e;
 
     inverse_kinematics(raw);
     set_machine_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS]);
   #else

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index de4ed3ddde..bf07c30878 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit 52383633e7062bf5ffd72d9c41c4cf7df05c544c
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Fri Jun 21 08:20:17 2019 +0200

    STM32F1: M43 PINS_DEBUGGING (#14072)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 25cba8cb03..de4ed3ddde 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1287,27 +1287,27 @@ void Planner::check_axes_activity() {
       #if HAS_FAN1
         set_pwm_duty(FAN1_PIN, CALC_FAN_SPEED(1));
       #endif
       #if HAS_FAN2
         set_pwm_duty(FAN2_PIN, CALC_FAN_SPEED(2));
       #endif
 
     #else
 
       #if HAS_FAN0
-        analogWrite(FAN_PIN, CALC_FAN_SPEED(0));
+        analogWrite(pin_t(FAN_PIN), CALC_FAN_SPEED(0));
       #endif
       #if HAS_FAN1
-        analogWrite(FAN1_PIN, CALC_FAN_SPEED(1));
+        analogWrite(pin_t(FAN1_PIN), CALC_FAN_SPEED(1));
       #endif
       #if HAS_FAN2
-        analogWrite(FAN2_PIN, CALC_FAN_SPEED(2));
+        analogWrite(pin_t(FAN2_PIN), CALC_FAN_SPEED(2));
       #endif
     #endif
   #else
     UNUSED(tail_fan_speed);
   #endif // FAN_COUNT > 0
 
   #if ENABLED(AUTOTEMP)
     getHighESpeed();
   #endif
 

commit 2290b269dc862709c7055784d2e130517a02231c
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Tue Jun 18 07:15:41 2019 +0200

    Unused variable (#14301)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 56591e9afe..25cba8cb03 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1296,21 +1296,22 @@ void Planner::check_axes_activity() {
       #if HAS_FAN0
         analogWrite(FAN_PIN, CALC_FAN_SPEED(0));
       #endif
       #if HAS_FAN1
         analogWrite(FAN1_PIN, CALC_FAN_SPEED(1));
       #endif
       #if HAS_FAN2
         analogWrite(FAN2_PIN, CALC_FAN_SPEED(2));
       #endif
     #endif
-
+  #else
+    UNUSED(tail_fan_speed);
   #endif // FAN_COUNT > 0
 
   #if ENABLED(AUTOTEMP)
     getHighESpeed();
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       analogWrite(HEATER_1_PIN, tail_valve_pressure);
     #endif

commit 0ca2073625fcf1eb35de8c37d49960bf20bed4b6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 10 17:25:43 2019 -0500

    ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED => SD_ABORT_ON_ENDSTOP_HIT

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ff6e0e71c7..56591e9afe 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -132,21 +132,21 @@ float Planner::steps_to_mm[XYZE_N];           // (mm) Millimeters per step
   #endif
 #endif
 #if HAS_CLASSIC_JERK
   #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
     float Planner::max_jerk[XYZ];             // (mm/s^2) M205 XYZ - The largest speed change requiring no acceleration.
   #else
     float Planner::max_jerk[XYZE];            // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
   #endif
 #endif
 
-#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+#if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
 
 float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0f); // The flow percentage and volumetric multiplier combine to scale E movement

commit ad4ffa1d2fbd17ac09c816ba2052cdf714261042
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 9 11:45:55 2019 -0500

    Use C++ language supported 'nullptr' (#13944)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 9c8a6f078f..ff6e0e71c7 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -893,21 +893,21 @@ void Planner::reverse_pass() {
   uint8_t planned_block_index = block_buffer_planned;
 
   // If there was a race condition and block_buffer_planned was incremented
   //  or was pointing at the head (queue empty) break loop now and avoid
   //  planning already consumed blocks
   if (planned_block_index == block_buffer_head) return;
 
   // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
   // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
   // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
-  const block_t *next = NULL;
+  const block_t *next = nullptr;
   while (block_index != planned_block_index) {
 
     // Perform the reverse pass
     block_t *current = &block_buffer[block_index];
 
     // Only consider non sync blocks
     if (!TEST(current->flag, BLOCK_BIT_SYNC_POSITION)) {
       reverse_pass_kernel(current, next);
       next = current;
     }
@@ -988,21 +988,21 @@ void Planner::forward_pass() {
   // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
   // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
 
   // Begin at buffer planned pointer. Note that block_buffer_planned can be modified
   //  by the stepper ISR,  so read it ONCE. It it guaranteed that block_buffer_planned
   //  will never lead head, so the loop is safe to execute. Also note that the forward
   //  pass will never modify the values at the tail.
   uint8_t block_index = block_buffer_planned;
 
   block_t *current;
-  const block_t * previous = NULL;
+  const block_t * previous = nullptr;
   while (block_index != block_buffer_head) {
 
     // Perform the forward pass
     current = &block_buffer[block_index];
 
     // Skip SYNC blocks
     if (!TEST(current->flag, BLOCK_BIT_SYNC_POSITION)) {
       // If there's no previous block or the previous block is not
       // BUSY (thus, modifiable) run the forward_pass_kernel. Otherwise,
       // the previous block became BUSY, so assume the current block's
@@ -1038,21 +1038,21 @@ void Planner::recalculate_trapezoids() {
     block_t *prev = &block_buffer[prev_index];
 
     // If not dealing with a sync block, we are done. The last block is not a SYNC block
     if (!TEST(prev->flag, BLOCK_BIT_SYNC_POSITION)) break;
 
     // Examine the previous block. This and all following are SYNC blocks
     head_block_index = prev_index;
   }
 
   // Go from the tail (currently executed block) to the first block, without including it)
-  block_t *current = NULL, *next = NULL;
+  block_t *current = nullptr, *next = nullptr;
   float current_entry_speed = 0.0, next_entry_speed = 0.0;
   while (block_index != head_block_index) {
 
     next = &block_buffer[block_index];
 
     // Skip sync blocks
     if (!TEST(next->flag, BLOCK_BIT_SYNC_POSITION)) {
       next_entry_speed = SQRT(next->entry_speed_sqr);
 
       if (current) {

commit 15357af67ceb74b14606eba9fbb75d20914f8909
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri May 3 22:53:15 2019 -0600

    Backlash cleanup (#13659)
    
    ‚Ä¶And save backlash, fil. sensor, ExtUI userdata to EEPROM.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 5073d903da..9c8a6f078f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -85,20 +85,24 @@
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"
 #endif
 
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
+#if ENABLED(BACKLASH_COMPENSATION)
+  #include "../feature/backlash.h"
+#endif
+
 // Delay for delivery of first block to the stepper ISR, if the queue contains 2 or
 // fewer movements. The delay is measured in milliseconds, and must be less than 250ms
 #define BLOCK_DELAY_FOR_1ST_MOVE 100
 
 Planner planner;
 
   // public:
 
 /**
  * A ring buffer of moves described in steps
@@ -1553,108 +1557,20 @@ float Planner::get_axis_position_mm(const AxisEnum axis) {
  */
 void Planner::synchronize() {
   while (
     has_blocks_queued() || cleaning_buffer_counter
     #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
       || (READ(CLOSED_LOOP_ENABLE_PIN) && !READ(CLOSED_LOOP_MOVE_COMPLETE_PIN))
     #endif
   ) idle();
 }
 
-/**
- * The following implements axis backlash correction. To minimize seams
- * on the printed part, the backlash correction only adds steps to the
- * current segment (instead of creating a new segment, which causes
- * discontinuities and print artifacts).
- *
- * When BACKLASH_SMOOTHING_MM is enabled and non-zero, the backlash
- * correction is spread over multiple segments, smoothing out print
- * artifacts even more.
- */
-#if ENABLED(BACKLASH_COMPENSATION)
-  #if ENABLED(BACKLASH_GCODE)
-    extern float backlash_distance_mm[];
-    extern uint8_t backlash_correction;
-    #ifdef BACKLASH_SMOOTHING_MM
-      extern float backlash_smoothing_mm;
-    #endif
-  #else
-    constexpr float backlash_distance_mm[XYZ] = BACKLASH_DISTANCE_MM,
-    constexpr uint8_t backlash_correction = BACKLASH_CORRECTION * 255;
-    #ifdef BACKLASH_SMOOTHING_MM
-      constexpr float backlash_smoothing_mm = BACKLASH_SMOOTHING_MM;
-    #endif
-  #endif
-
-  void Planner::add_backlash_correction_steps(const int32_t da, const int32_t db, const int32_t dc, const uint8_t dm, block_t * const block) {
-    static uint8_t last_direction_bits;
-    uint8_t changed_dir = last_direction_bits ^ dm;
-    // Ignore direction change if no steps are taken in that direction
-    if (da == 0) CBI(changed_dir, X_AXIS);
-    if (db == 0) CBI(changed_dir, Y_AXIS);
-    if (dc == 0) CBI(changed_dir, Z_AXIS);
-    last_direction_bits ^= changed_dir;
-
-    if (backlash_correction == 0) return;
-
-    #ifdef BACKLASH_SMOOTHING_MM
-      // The segment proportion is a value greater than 0.0 indicating how much residual_error
-      // is corrected for in this segment. The contribution is based on segment length and the
-      // smoothing distance. Since the computation of this proportion involves a floating point
-      // division, defer computation until needed.
-      float segment_proportion = 0;
-
-      // Residual error carried forward across multiple segments, so correction can be applied
-      // to segments where there is no direction change.
-      static int32_t residual_error[XYZ] = { 0 };
-    #else
-      // No leftover residual error from segment to segment
-      int32_t residual_error[XYZ] = { 0 };
-      // No direction change, no correction.
-      if (!changed_dir) return;
-    #endif
-
-    const float f_corr = float(backlash_correction) / 255.0f;
-
-    LOOP_XYZ(axis) {
-      if (backlash_distance_mm[axis]) {
-        const bool reversing = TEST(dm,axis);
-
-        // When an axis changes direction, add axis backlash to the residual error
-        if (TEST(changed_dir, axis))
-          residual_error[axis] += (reversing ? -f_corr : f_corr) * backlash_distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
-
-        // Decide how much of the residual error to correct in this segment
-        int32_t error_correction = residual_error[axis];
-        #ifdef BACKLASH_SMOOTHING_MM
-          if (error_correction && backlash_smoothing_mm != 0) {
-            // Take up a portion of the residual_error in this segment, but only when
-            // the current segment travels in the same direction as the correction
-            if (reversing == (error_correction < 0)) {
-              if (segment_proportion == 0)
-                segment_proportion = MIN(1.0f, block->millimeters / backlash_smoothing_mm);
-              error_correction = ceil(segment_proportion * error_correction);
-            }
-            else
-              error_correction = 0; // Don't take up any backlash in this segment, as it would subtract steps
-          }
-        #endif
-        // Making a correction reduces the residual error and modifies delta_mm
-        if (error_correction) {
-          block->steps[axis] += ABS(error_correction);
-          residual_error[axis] -= error_correction;
-        }
-      }
-    }
-  }
-#endif // BACKLASH_COMPENSATION
-
 /**
  * Planner::_buffer_steps
  *
  * Add a new linear movement to the planner queue (in terms of steps).
  *
  *  target      - target position in steps units
  *  target_float - target position in direct (mm, degrees) units. optional
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *  millimeters - the length of the movement, if known
@@ -1912,21 +1828,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     /**
      * At this point at least one of the axes has more steps than
      * MIN_STEPS_PER_SEGMENT, ensuring the segment won't get dropped as
      * zero-length. It's important to not apply corrections
      * to blocks that would get dropped!
      *
      * A correction function is permitted to add steps to an axis, it
      * should *never* remove steps!
      */
     #if ENABLED(BACKLASH_COMPENSATION)
-      add_backlash_correction_steps(da, db, dc, dm, block);
+      backlash.add_correction_steps(da, db, dc, dm, block);
     #endif
   }
 
   block->steps[E_AXIS] = esteps;
   block->step_event_count = MAX(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   #if ENABLED(MIXING_EXTRUDER)

commit ee243e4edfe45fa855d4ff71abf8a9a118b66369
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Wed May 1 22:55:58 2019 -0400

    Fix mixing extruder filament change (#13803)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ff4f13e1d7..5073d903da 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1760,27 +1760,40 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         if (thermalManager.tooColdToExtrude(extruder)) {
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           #if HAS_POSITION_FLOAT
             position_float[E_AXIS] = target_float[E_AXIS];
           #endif
           de = 0; // no difference
           SERIAL_ECHO_MSG(MSG_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-        if (ABS(de * e_factor[extruder]) > (int32_t)settings.axis_steps_per_mm[E_AXIS_N(extruder)] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
-          position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
-          #if HAS_POSITION_FLOAT
-            position_float[E_AXIS] = target_float[E_AXIS];
+        const float e_steps = ABS(de * e_factor[extruder]);
+        const float max_e_steps = settings.axis_steps_per_mm[E_AXIS_N(extruder)] * (EXTRUDE_MAXLENGTH);
+        if (e_steps > max_e_steps) {
+          #if ENABLED(MIXING_EXTRUDER)
+            bool ignore_e = false;
+            float collector[MIXING_STEPPERS];
+            mixer.refresh_collector(1.0, mixer.get_current_vtool(), collector);
+            MIXER_STEPPER_LOOP(e)
+              if (e_steps * collector[e] > max_e_steps) { ignore_e = true; break; }
+          #else
+            constexpr bool ignore_e = true;
           #endif
-          de = 0; // no difference
-          SERIAL_ECHO_MSG(MSG_ERR_LONG_EXTRUDE_STOP);
+          if (ignore_e) {
+            position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
+            #if HAS_POSITION_FLOAT
+              position_float[E_AXIS] = target_float[E_AXIS];
+            #endif
+            de = 0; // no difference
+            SERIAL_ECHO_MSG(MSG_ERR_LONG_EXTRUDE_STOP);
+          }
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   // Compute direction bit-mask for this block
   uint8_t dm = 0;
   #if CORE_IS_XY
     if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
     if (db < 0) SBI(dm, Y_HEAD);                // ...and Y

commit 5679fae11efbc7e8b9de2f0e68dc9a879757ff88
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Mar 29 13:07:43 2019 -0600

    UltraLCD enhancements (lower fan resolution, backlash menu) (#13519)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 5da05d0161..ff4f13e1d7 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1565,27 +1565,28 @@ void Planner::synchronize() {
  * on the printed part, the backlash correction only adds steps to the
  * current segment (instead of creating a new segment, which causes
  * discontinuities and print artifacts).
  *
  * When BACKLASH_SMOOTHING_MM is enabled and non-zero, the backlash
  * correction is spread over multiple segments, smoothing out print
  * artifacts even more.
  */
 #if ENABLED(BACKLASH_COMPENSATION)
   #if ENABLED(BACKLASH_GCODE)
-    extern float backlash_distance_mm[], backlash_correction;
+    extern float backlash_distance_mm[];
+    extern uint8_t backlash_correction;
     #ifdef BACKLASH_SMOOTHING_MM
       extern float backlash_smoothing_mm;
     #endif
   #else
     constexpr float backlash_distance_mm[XYZ] = BACKLASH_DISTANCE_MM,
-                    backlash_correction = BACKLASH_CORRECTION;
+    constexpr uint8_t backlash_correction = BACKLASH_CORRECTION * 255;
     #ifdef BACKLASH_SMOOTHING_MM
       constexpr float backlash_smoothing_mm = BACKLASH_SMOOTHING_MM;
     #endif
   #endif
 
   void Planner::add_backlash_correction_steps(const int32_t da, const int32_t db, const int32_t dc, const uint8_t dm, block_t * const block) {
     static uint8_t last_direction_bits;
     uint8_t changed_dir = last_direction_bits ^ dm;
     // Ignore direction change if no steps are taken in that direction
     if (da == 0) CBI(changed_dir, X_AXIS);
@@ -1605,27 +1606,29 @@ void Planner::synchronize() {
       // Residual error carried forward across multiple segments, so correction can be applied
       // to segments where there is no direction change.
       static int32_t residual_error[XYZ] = { 0 };
     #else
       // No leftover residual error from segment to segment
       int32_t residual_error[XYZ] = { 0 };
       // No direction change, no correction.
       if (!changed_dir) return;
     #endif
 
+    const float f_corr = float(backlash_correction) / 255.0f;
+
     LOOP_XYZ(axis) {
       if (backlash_distance_mm[axis]) {
         const bool reversing = TEST(dm,axis);
 
         // When an axis changes direction, add axis backlash to the residual error
         if (TEST(changed_dir, axis))
-          residual_error[axis] += backlash_correction * (reversing ? -1.0f : 1.0f) * backlash_distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
+          residual_error[axis] += (reversing ? -f_corr : f_corr) * backlash_distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
 
         // Decide how much of the residual error to correct in this segment
         int32_t error_correction = residual_error[axis];
         #ifdef BACKLASH_SMOOTHING_MM
           if (error_correction && backlash_smoothing_mm != 0) {
             // Take up a portion of the residual_error in this segment, but only when
             // the current segment travels in the same direction as the correction
             if (reversing == (error_correction < 0)) {
               if (segment_proportion == 0)
                 segment_proportion = MIN(1.0f, block->millimeters / backlash_smoothing_mm);

commit ffc2c2d7c5ced5e6e4cb33698d30a779f3bcfe66
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Tue Mar 26 06:03:23 2019 +0000

    Move FAST_PWM_FAN code to HALs (#13491)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 14c700245d..5da05d0161 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1271,27 +1271,27 @@ void Planner::check_axes_activity() {
       #if HAS_FAN1
         thermalManager.soft_pwm_amount_fan[1] = CALC_FAN_SPEED(1);
       #endif
       #if HAS_FAN2
         thermalManager.soft_pwm_amount_fan[2] = CALC_FAN_SPEED(2);
       #endif
 
     #elif ENABLED(FAST_PWM_FAN)
 
       #if HAS_FAN0
-        thermalManager.set_pwm_duty(FAN_PIN, CALC_FAN_SPEED(0));
+        set_pwm_duty(FAN_PIN, CALC_FAN_SPEED(0));
       #endif
       #if HAS_FAN1
-        thermalManager.set_pwm_duty(FAN1_PIN, CALC_FAN_SPEED(1));
+        set_pwm_duty(FAN1_PIN, CALC_FAN_SPEED(1));
       #endif
       #if HAS_FAN2
-        thermalManager.set_pwm_duty(FAN2_PIN, CALC_FAN_SPEED(2));
+        set_pwm_duty(FAN2_PIN, CALC_FAN_SPEED(2));
       #endif
 
     #else
 
       #if HAS_FAN0
         analogWrite(FAN_PIN, CALC_FAN_SPEED(0));
       #endif
       #if HAS_FAN1
         analogWrite(FAN1_PIN, CALC_FAN_SPEED(1));
       #endif

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index fbe6ca7e1a..14c700245d 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -121,21 +121,21 @@ float Planner::steps_to_mm[XYZE_N];           // (mm) Millimeters per step
   float Planner::junction_deviation_mm;       // (mm) M205 J
   #if ENABLED(LIN_ADVANCE)
     #if ENABLED(DISTINCT_E_FACTORS)
       float Planner::max_e_jerk[EXTRUDERS];   // Calculated from junction_deviation_mm
     #else
       float Planner::max_e_jerk;
     #endif
   #endif
 #endif
 #if HAS_CLASSIC_JERK
-  #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+  #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
     float Planner::max_jerk[XYZ];             // (mm/s^2) M205 XYZ - The largest speed change requiring no acceleration.
   #else
     float Planner::max_jerk[XYZE];            // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
   #endif
 #endif
 
 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
@@ -1744,21 +1744,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     SERIAL_ECHOPAIR(" (", da);
     SERIAL_ECHOPAIR(" steps) B:", target[B_AXIS]);
     SERIAL_ECHOPAIR(" (", db);
     SERIAL_ECHOPAIR(" steps) C:", target[C_AXIS]);
     SERIAL_ECHOPAIR(" (", dc);
     SERIAL_ECHOPAIR(" steps) E:", target[E_AXIS]);
     SERIAL_ECHOPAIR(" (", de);
     SERIAL_ECHOLNPGM(" steps)");
   //*/
 
-  #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
+  #if EITHER(PREVENT_COLD_EXTRUSION, PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           #if HAS_POSITION_FLOAT
             position_float[E_AXIS] = target_float[E_AXIS];
           #endif
           de = 0; // no difference
           SERIAL_ECHO_MSG(MSG_ERR_COLD_EXTRUDE_STOP);
         }
@@ -2097,21 +2097,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   const float inverse_millimeters = 1.0f / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate inverse time for this move. No divide by zero due to previous checks.
   // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   float inverse_secs = fr_mm_s * inverse_millimeters;
 
   // Get the number of non busy movements in queue (non busy means that they can be altered)
   const uint8_t moves_queued = nonbusy_movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
-  #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
+  #if EITHER(SLOWDOWN, ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time im micro seconds
     uint32_t segment_time_us = LROUND(1000000.0f / inverse_secs);
   #endif
 
   #if ENABLED(SLOWDOWN)
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
       if (segment_time_us < settings.min_segment_time_us) {
         // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
         const uint32_t nst = segment_time_us + LROUND(2 * (settings.min_segment_time_us - segment_time_us) / moves_queued);
         inverse_secs = 1000000.0f / nst;
@@ -2165,21 +2165,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
             measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
           } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
         }
       }
     }
   #endif
 
   // Calculate and limit speed in mm/sec for each axis
   float current_speed[NUM_AXIS], speed_factor = 1.0f; // factor <1 decreases speed
   LOOP_XYZE(i) {
-    #if ENABLED(MIXING_EXTRUDER) && ENABLED(RETRACT_SYNC_MIXING)
+    #if BOTH(MIXING_EXTRUDER, RETRACT_SYNC_MIXING)
       // In worst case, only one extruder running, no change is needed.
       // In best case, all extruders run the same amount, we can divide by MIXING_STEPPERS
       float delta_mm_i = 0;
       if (i == E_AXIS && mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)
         delta_mm_i = delta_mm[i] / MIXING_STEPPERS;
       else
         delta_mm_i = delta_mm[i];
     #else
       const float delta_mm_i = delta_mm[i];
     #endif
@@ -2478,21 +2478,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
      */
     const float nominal_speed = SQRT(block->nominal_speed_sqr);
 
     // Exit speed limited by a jerk to full halt of a previous last segment
     static float previous_safe_speed;
 
     // Start with a safe speed (from which the machine may halt to stop immediately).
     float safe_speed = nominal_speed;
 
     uint8_t limited = 0;
-    #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+    #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
       LOOP_XYZ(i)
     #else
       LOOP_XYZE(i)
     #endif
     {
       const float jerk = ABS(current_speed[i]),   // cs : Starting from zero, change in speed for this axis
                   maxj = max_jerk[i];             // mj : The max jerk setting for this axis
       if (jerk > maxj) {                          // cs > mj : New current speed too fast?
         if (limited) {                            // limited already?
           const float mjerk = nominal_speed * maxj; // ns*mj
@@ -2515,21 +2515,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       float v_factor = 1;
       limited = 0;
 
       // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
       // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
       const float previous_nominal_speed = SQRT(previous_nominal_speed_sqr);
       vmax_junction = MIN(nominal_speed, previous_nominal_speed);
 
       // Now limit the jerk in all axes.
       const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
-      #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+      #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
         LOOP_XYZ(axis)
       #else
         LOOP_XYZE(axis)
       #endif
       {
         // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
         float v_exit = previous_speed[axis] * smaller_speed_factor,
               v_entry = current_speed[axis];
         if (limited) {
           v_exit *= v_factor;
@@ -2886,21 +2886,21 @@ void Planner::reset_acceleration_rates() {
     #define AXIS_CONDITION (i < E_AXIS || i == E_AXIS_N(active_extruder))
   #else
     #define AXIS_CONDITION true
   #endif
   uint32_t highest_rate = 1;
   LOOP_XYZE_N(i) {
     max_acceleration_steps_per_s2[i] = settings.max_acceleration_mm_per_s2[i] * settings.axis_steps_per_mm[i];
     if (AXIS_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   }
   cutoff_long = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
-  #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+  #if BOTH(JUNCTION_DEVIATION, LIN_ADVANCE)
     recalculate_max_e_jerk();
   #endif
 }
 
 // Recalculate position, steps_to_mm if settings.axis_steps_per_mm changes!
 void Planner::refresh_positioning() {
   LOOP_XYZE_N(i) steps_to_mm[i] = 1.0f / settings.axis_steps_per_mm[i];
   set_position_mm(current_position);
   reset_acceleration_rates();
 }

commit 67bee06e4371fca6511aae99125337b6e63560d8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 13 07:21:10 2019 -0500

    No patch needed for non-libmaple analogWrite
    
    See https://github.com/pinchies/Marlin/pull/1#issuecomment-471388743

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e5234a5b35..fbe6ca7e1a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1283,42 +1283,42 @@ void Planner::check_axes_activity() {
       #if HAS_FAN1
         thermalManager.set_pwm_duty(FAN1_PIN, CALC_FAN_SPEED(1));
       #endif
       #if HAS_FAN2
         thermalManager.set_pwm_duty(FAN2_PIN, CALC_FAN_SPEED(2));
       #endif
 
     #else
 
       #if HAS_FAN0
-        ANALOG_WRITE(FAN_PIN, CALC_FAN_SPEED(0));
+        analogWrite(FAN_PIN, CALC_FAN_SPEED(0));
       #endif
       #if HAS_FAN1
-        ANALOG_WRITE(FAN1_PIN, CALC_FAN_SPEED(1));
+        analogWrite(FAN1_PIN, CALC_FAN_SPEED(1));
       #endif
       #if HAS_FAN2
-        ANALOG_WRITE(FAN2_PIN, CALC_FAN_SPEED(2));
+        analogWrite(FAN2_PIN, CALC_FAN_SPEED(2));
       #endif
     #endif
 
   #endif // FAN_COUNT > 0
 
   #if ENABLED(AUTOTEMP)
     getHighESpeed();
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
-      ANALOG_WRITE(HEATER_1_PIN, tail_valve_pressure);
+      analogWrite(HEATER_1_PIN, tail_valve_pressure);
     #endif
     #if HAS_HEATER_2
-      ANALOG_WRITE(HEATER_2_PIN, tail_e_to_p_pressure);
+      analogWrite(HEATER_2_PIN, tail_e_to_p_pressure);
     #endif
   #endif
 }
 
 #if DISABLED(NO_VOLUMETRICS)
 
   /**
    * Get a volumetric multiplier from a filament diameter.
    * This is the reciprocal of the circular cross-section area.
    * Return 1.0 with volumetric off or a diameter of 0.0.

commit f89b375fb9ca9730a4165ac3bf9f0f9dc100a338
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 13 06:51:15 2019 -0500

    Fixes and improvements for PWM pins (#13383)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index fbe6ca7e1a..e5234a5b35 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1283,42 +1283,42 @@ void Planner::check_axes_activity() {
       #if HAS_FAN1
         thermalManager.set_pwm_duty(FAN1_PIN, CALC_FAN_SPEED(1));
       #endif
       #if HAS_FAN2
         thermalManager.set_pwm_duty(FAN2_PIN, CALC_FAN_SPEED(2));
       #endif
 
     #else
 
       #if HAS_FAN0
-        analogWrite(FAN_PIN, CALC_FAN_SPEED(0));
+        ANALOG_WRITE(FAN_PIN, CALC_FAN_SPEED(0));
       #endif
       #if HAS_FAN1
-        analogWrite(FAN1_PIN, CALC_FAN_SPEED(1));
+        ANALOG_WRITE(FAN1_PIN, CALC_FAN_SPEED(1));
       #endif
       #if HAS_FAN2
-        analogWrite(FAN2_PIN, CALC_FAN_SPEED(2));
+        ANALOG_WRITE(FAN2_PIN, CALC_FAN_SPEED(2));
       #endif
     #endif
 
   #endif // FAN_COUNT > 0
 
   #if ENABLED(AUTOTEMP)
     getHighESpeed();
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
-      analogWrite(HEATER_1_PIN, tail_valve_pressure);
+      ANALOG_WRITE(HEATER_1_PIN, tail_valve_pressure);
     #endif
     #if HAS_HEATER_2
-      analogWrite(HEATER_2_PIN, tail_e_to_p_pressure);
+      ANALOG_WRITE(HEATER_2_PIN, tail_e_to_p_pressure);
     #endif
   #endif
 }
 
 #if DISABLED(NO_VOLUMETRICS)
 
   /**
    * Get a volumetric multiplier from a filament diameter.
    * This is the reciprocal of the circular cross-section area.
    * Return 1.0 with volumetric off or a diameter of 0.0.

commit 050eac03afb67743131b5537bf7464e3dafbce23
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Mar 13 01:42:50 2019 -0400

    Single X Duplication Extension (#13373)
    
    * Multi-nozzle selective duplication
    * Use a bit-mask, reduce stepper_indirection.h size
    * Tweak the multi-nozzle duplication description
    * Use 'S' as a bool in M605
    * Add HAS_DUPLICATION_MODE conditional
    * Remove '_MODE' from the option name
    * M605 in the style of Stacker M280
    * Also include direct mask style (P)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index a19cf47a6b..fbe6ca7e1a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1989,21 +1989,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
                   DISABLE_IDLE_E(4);
                   #if EXTRUDERS > 5
                     DISABLE_IDLE_E(5);
                   #endif // EXTRUDERS > 5
                 #endif // EXTRUDERS > 4
               #endif // EXTRUDERS > 3
             #endif // EXTRUDERS > 2
           #endif // EXTRUDERS > 1
           enable_E0();
           g_uc_extruder_last_move[0] = (BLOCK_BUFFER_SIZE) * 2;
-          #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+          #if HAS_DUPLICATION_MODE
             if (extruder_duplication_enabled) {
               enable_E1();
               g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
             }
           #endif
         break;
         #if EXTRUDERS > 1
           case 1:
             DISABLE_IDLE_E(0);
             #if EXTRUDERS > 2

commit 3419099f0a1c3b7c558b93a4562071bfff23fa45
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 10 19:09:19 2019 -0500

    Clean up whitespace

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c383dae753..a19cf47a6b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1257,42 +1257,45 @@ void Planner::check_axes_activity() {
 
     #endif // FAN_KICKSTART_TIME > 0
 
     #if FAN_MIN_PWM != 0 || FAN_MAX_PWM != 255
       #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ? map(tail_fan_speed[f], 1, 255, FAN_MIN_PWM, FAN_MAX_PWM) : 0)
     #else
       #define CALC_FAN_SPEED(f) tail_fan_speed[f]
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
+
       #if HAS_FAN0
         thermalManager.soft_pwm_amount_fan[0] = CALC_FAN_SPEED(0);
       #endif
       #if HAS_FAN1
         thermalManager.soft_pwm_amount_fan[1] = CALC_FAN_SPEED(1);
       #endif
       #if HAS_FAN2
         thermalManager.soft_pwm_amount_fan[2] = CALC_FAN_SPEED(2);
       #endif
 
     #elif ENABLED(FAST_PWM_FAN)
+
       #if HAS_FAN0
         thermalManager.set_pwm_duty(FAN_PIN, CALC_FAN_SPEED(0));
       #endif
       #if HAS_FAN1
         thermalManager.set_pwm_duty(FAN1_PIN, CALC_FAN_SPEED(1));
       #endif
       #if HAS_FAN2
         thermalManager.set_pwm_duty(FAN2_PIN, CALC_FAN_SPEED(2));
       #endif
 
     #else
+
       #if HAS_FAN0
         analogWrite(FAN_PIN, CALC_FAN_SPEED(0));
       #endif
       #if HAS_FAN1
         analogWrite(FAN1_PIN, CALC_FAN_SPEED(1));
       #endif
       #if HAS_FAN2
         analogWrite(FAN2_PIN, CALC_FAN_SPEED(2));
       #endif
     #endif

commit 00fc43144af99b257cdc5e935a50688a3448ace2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Mar 8 21:13:24 2019 -0700

    Follow up fixes to various PRs. (#13334)
    
    - Ensure `MarlinUI:get_progress` is defined for `ExtUI`.
    - Fix for `BACKLASH_SMOOTHING` with small segments.
      `BACKLASH_SMOOTHING` with extremely small segments failed to fully correct due to the correction factor being rounded down. Rounding up ensures the entire backlash will converge to zero even for small segments.
    - Add pinout for the beta revision `EINSY_RETRO`.
    - Update soft endstops with tool offsets (for toolchange et. al. move clamping) (#12568)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index dc7458a257..c383dae753 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1619,21 +1619,21 @@ void Planner::synchronize() {
 
         // Decide how much of the residual error to correct in this segment
         int32_t error_correction = residual_error[axis];
         #ifdef BACKLASH_SMOOTHING_MM
           if (error_correction && backlash_smoothing_mm != 0) {
             // Take up a portion of the residual_error in this segment, but only when
             // the current segment travels in the same direction as the correction
             if (reversing == (error_correction < 0)) {
               if (segment_proportion == 0)
                 segment_proportion = MIN(1.0f, block->millimeters / backlash_smoothing_mm);
-              error_correction *= segment_proportion;
+              error_correction = ceil(segment_proportion * error_correction);
             }
             else
               error_correction = 0; // Don't take up any backlash in this segment, as it would subtract steps
           }
         #endif
         // Making a correction reduces the residual error and modifies delta_mm
         if (error_correction) {
           block->steps[axis] += ABS(error_correction);
           residual_error[axis] -= error_correction;
         }

commit dbead66988b138e67d0e8cc5901fa38672feb390
Author: Reece Kibble <reece.kibble@gmail.com>
Date:   Fri Mar 8 16:15:42 2019 +0800

    Allows user to set (almost) any PWM frequency (#12638)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index f6d581a6b9..dc7458a257 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1266,20 +1266,32 @@ void Planner::check_axes_activity() {
     #if ENABLED(FAN_SOFT_PWM)
       #if HAS_FAN0
         thermalManager.soft_pwm_amount_fan[0] = CALC_FAN_SPEED(0);
       #endif
       #if HAS_FAN1
         thermalManager.soft_pwm_amount_fan[1] = CALC_FAN_SPEED(1);
       #endif
       #if HAS_FAN2
         thermalManager.soft_pwm_amount_fan[2] = CALC_FAN_SPEED(2);
       #endif
+
+    #elif ENABLED(FAST_PWM_FAN)
+      #if HAS_FAN0
+        thermalManager.set_pwm_duty(FAN_PIN, CALC_FAN_SPEED(0));
+      #endif
+      #if HAS_FAN1
+        thermalManager.set_pwm_duty(FAN1_PIN, CALC_FAN_SPEED(1));
+      #endif
+      #if HAS_FAN2
+        thermalManager.set_pwm_duty(FAN2_PIN, CALC_FAN_SPEED(2));
+      #endif
+
     #else
       #if HAS_FAN0
         analogWrite(FAN_PIN, CALC_FAN_SPEED(0));
       #endif
       #if HAS_FAN1
         analogWrite(FAN1_PIN, CALC_FAN_SPEED(1));
       #endif
       #if HAS_FAN2
         analogWrite(FAN2_PIN, CALC_FAN_SPEED(2));
       #endif

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index deb7e3c3ef..f6d581a6b9 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 6de3d3437849c0710881311bc9ad4069b0aee55d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 10 04:54:23 2019 -0600

    M166 Gradients, LCD Menu for 2-channel Mixer (Geeetech A10M/A20M) (#13022)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ed498574e6..deb7e3c3ef 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2577,20 +2577,24 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   COPY(previous_speed, current_speed);
   previous_nominal_speed_sqr = block->nominal_speed_sqr;
 
   // Update the position
   static_assert(COUNT(target) > 1, "Parameter to _buffer_steps must be (&target)[XYZE]!");
   COPY(position, target);
   #if HAS_POSITION_FLOAT
     COPY(position_float, target_float);
   #endif
 
+  #if ENABLED(GRADIENT_MIX)
+    mixer.gradient_control(target_float[Z_AXIS]);
+  #endif
+
   // Movement was accepted
   return true;
 } // _populate_block()
 
 /**
  * Planner::buffer_sync_block
  * Add a block to the buffer that just updates the position
  */
 void Planner::buffer_sync_block() {
   // Wait for the next available block

commit b35a7c2c872eab907fcbd986e9969142c301f86d
Author: Sam Lane <9569766+SJ-Innovation@users.noreply.github.com>
Date:   Mon Feb 4 13:43:09 2019 +0000

    Fixed closed-loop planner stall (#13005)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ec7af5c1e1..ed498574e6 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1533,21 +1533,21 @@ float Planner::get_axis_position_mm(const AxisEnum axis) {
   return axis_steps * steps_to_mm[axis];
 }
 
 /**
  * Block until all buffered steps are executed / cleaned
  */
 void Planner::synchronize() {
   while (
     has_blocks_queued() || cleaning_buffer_counter
     #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
-      || !READ(CLOSED_LOOP_MOVE_COMPLETE_PIN)
+      || (READ(CLOSED_LOOP_ENABLE_PIN) && !READ(CLOSED_LOOP_MOVE_COMPLETE_PIN))
     #endif
   ) idle();
 }
 
 /**
  * The following implements axis backlash correction. To minimize seams
  * on the printed part, the backlash correction only adds steps to the
  * current segment (instead of creating a new segment, which causes
  * discontinuities and print artifacts).
  *

commit d4d1b28a06caa57d26e300c1b814b2b8b62120cd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 4 03:41:55 2019 -0600

    Fix some include paths

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c563547ec1..ec7af5c1e1 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -58,21 +58,21 @@
  *
  * --
  *
  * The fast inverse function needed for B√©zier interpolation for AVR
  * was designed, written and tested by Eduardo Jos√© Tagle on April/2018
  */
 
 #include "planner.h"
 #include "stepper.h"
 #include "motion.h"
-#include "../module/temperature.h"
+#include "temperature.h"
 #include "../lcd/ultralcd.h"
 #include "../core/language.h"
 #include "../gcode/parser.h"
 
 #include "../Marlin.h"
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 

commit a5e33846916e5415146399d03eac334fc5cc71c8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 2 23:30:26 2019 -0600

    Pre-apply cosmetic changes to mixing

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 056817c8dd..c563547ec1 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2154,21 +2154,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     }
   #endif
 
   // Calculate and limit speed in mm/sec for each axis
   float current_speed[NUM_AXIS], speed_factor = 1.0f; // factor <1 decreases speed
   LOOP_XYZE(i) {
     #if ENABLED(MIXING_EXTRUDER) && ENABLED(RETRACT_SYNC_MIXING)
       // In worst case, only one extruder running, no change is needed.
       // In best case, all extruders run the same amount, we can divide by MIXING_STEPPERS
       float delta_mm_i = 0;
-      if (i == E_AXIS && mixer.get_current_v_tool() == MIXER_AUTORETRACT_TOOL)
+      if (i == E_AXIS && mixer.get_current_vtool() == MIXER_AUTORETRACT_TOOL)
         delta_mm_i = delta_mm[i] / MIXING_STEPPERS;
       else
         delta_mm_i = delta_mm[i];
     #else
       const float delta_mm_i = delta_mm[i];
     #endif
     const float cs = ABS(current_speed[i] = delta_mm_i * inverse_secs);
     #if ENABLED(DISTINCT_E_FACTORS)
       if (i == E_AXIS) i += extruder;
     #endif

commit 082f6a27dece8d1883751d3f2af1c2b0f0b6802c
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Jan 12 01:41:48 2019 -0500

    ADAPTIVE_FAN_SLOWING extension to hotend thermal protection (#12853)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 523cfcaf94..056817c8dd 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1171,24 +1171,23 @@ void Planner::check_axes_activity() {
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
     #endif
     #if HAS_HEATER_2
       uint8_t tail_e_to_p_pressure;
     #endif
   #endif
 
   if (has_blocks_queued()) {
-
     #if FAN_COUNT > 0
       FANS_LOOP(i)
-        tail_fan_speed[i] = block_buffer[block_buffer_tail].fan_speed[i];
+        tail_fan_speed[i] = (block_buffer[block_buffer_tail].fan_speed[i] * uint16_t(thermalManager.fan_speed_scaler[i])) >> 7;
     #endif
 
     block_t* block;
 
     #if ENABLED(BARICUDA)
       block = &block_buffer[block_buffer_tail];
       #if HAS_HEATER_1
         tail_valve_pressure = block->valve_pressure;
       #endif
       #if HAS_HEATER_2
@@ -1196,21 +1195,22 @@ void Planner::check_axes_activity() {
       #endif
     #endif
 
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block = &block_buffer[b];
       LOOP_XYZE(i) if (block->steps[i]) axis_active[i]++;
     }
   }
   else {
     #if FAN_COUNT > 0
-      FANS_LOOP(i) tail_fan_speed[i] = fan_speed[i];
+      FANS_LOOP(i)
+        tail_fan_speed[i] = (thermalManager.fan_speed[i] * uint16_t(thermalManager.fan_speed_scaler[i])) >> 7;
     #endif
 
     #if ENABLED(BARICUDA)
       #if HAS_HEATER_1
         tail_valve_pressure = baricuda_valve_pressure;
       #endif
       #if HAS_HEATER_2
         tail_e_to_p_pressure = baricuda_e_to_p_pressure;
       #endif
     #endif
@@ -1896,21 +1896,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   block->step_event_count = MAX(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   #if ENABLED(MIXING_EXTRUDER)
     MIXER_POPULATE_BLOCK();
   #endif
 
   #if FAN_COUNT > 0
-    FANS_LOOP(i) block->fan_speed[i] = fan_speed[i];
+    FANS_LOOP(i) block->fan_speed[i] = thermalManager.fan_speed[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
   #if EXTRUDERS > 1
     block->extruder = extruder;
   #endif

commit 19fea772e5eba0b850512123f10c9c72868d75a4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jan 11 19:37:20 2019 -0600

    Use E_AXIS_N where it makes sense

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c111df7b95..523cfcaf94 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2639,22 +2639,22 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
     , const float (&delta_mm_cart)[XYZE]
   #endif
   , const float &fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
-    if (last_extruder != extruder && settings.axis_steps_per_mm[E_AXIS_N(extruder)] != settings.axis_steps_per_mm[E_AXIS + last_extruder]) {
-      position[E_AXIS] = LROUND(position[E_AXIS] * settings.axis_steps_per_mm[E_AXIS_N(extruder)] * steps_to_mm[E_AXIS + last_extruder]);
+    if (last_extruder != extruder && settings.axis_steps_per_mm[E_AXIS_N(extruder)] != settings.axis_steps_per_mm[E_AXIS_N(last_extruder)]) {
+      position[E_AXIS] = LROUND(position[E_AXIS] * settings.axis_steps_per_mm[E_AXIS_N(extruder)] * steps_to_mm[E_AXIS_N(last_extruder)]);
       last_extruder = extruder;
     }
   #endif
 
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
   const int32_t target[ABCE] = {
     LROUND(a * settings.axis_steps_per_mm[A_AXIS]),
     LROUND(b * settings.axis_steps_per_mm[B_AXIS]),
     LROUND(c * settings.axis_steps_per_mm[C_AXIS]),

commit 1fd8e2c6492bff0448450303ebf544f1bd89f064
Author: HackingGulliver <onthomas@gmx.de>
Date:   Sat Jan 12 02:25:48 2019 +0100

    Fix: Junction Deviation calculates wrong cos(theta) on CoreXY (#12879)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 8de2db5c06..c111df7b95 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2385,20 +2385,29 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       };
     #else
       float unit_vec[] = {
         delta_mm[X_AXIS] * inverse_millimeters,
         delta_mm[Y_AXIS] * inverse_millimeters,
         delta_mm[Z_AXIS] * inverse_millimeters,
         delta_mm[E_AXIS] * inverse_millimeters
       };
     #endif
 
+    #if IS_CORE && ENABLED(JUNCTION_DEVIATION)
+      /**
+       * On CoreXY the length of the vector [A,B] is SQRT(2) times the length of the head movement vector [X,Y].
+       * So taking Z and E into account, we cannot scale to a unit vector with "inverse_millimeters".
+       * => normalize the complete junction vector
+       */
+      normalize_junction_vector(unit_vec);
+    #endif
+
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
       float junction_cos_theta = -previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
                                  -previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
                                  -previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS]
                                  -previous_unit_vec[E_AXIS] * unit_vec[E_AXIS]
                                 ;
 

commit 6a8fb0f25f65b2547a1f5cf723d523f5b3d4972c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Jan 4 12:30:56 2019 -0700

    Simplify backlash compensation code. (#12813)
    
    - Use `TEST(dm,axis)` to determine directions instead of doing comparisons.
    - Remove recomputation of `millimeters` and `delta_mm` since backlash compensation should not affect the distance over which material is extruded.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 22a086ac56..8de2db5c06 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -229,21 +229,20 @@ void Planner::init() {
   ZERO(previous_speed);
   previous_nominal_speed_sqr = 0;
   #if ABL_PLANAR
     bed_level_matrix.set_to_identity();
   #endif
   clear_block_buffer();
   delay_before_delivering = 0;
 }
 
 #if ENABLED(S_CURVE_ACCELERATION)
-
   #ifdef __AVR__
     /**
      * This routine returns 0x1000000 / d, getting the inverse as fast as possible.
      * A fast-converging iterative Newton-Raphson method can reach full precision in
      * just 1 iteration, and takes 211 cycles (worst case; the mean case is less, up
      * to 30 cycles for small divisors), instead of the 500 cycles a normal division
      * would take.
      *
      * Inspired by the following page:
      *  https://stackoverflow.com/questions/27801397/newton-raphson-division-with-big-integers
@@ -1563,21 +1562,21 @@ void Planner::synchronize() {
       extern float backlash_smoothing_mm;
     #endif
   #else
     constexpr float backlash_distance_mm[XYZ] = BACKLASH_DISTANCE_MM,
                     backlash_correction = BACKLASH_CORRECTION;
     #ifdef BACKLASH_SMOOTHING_MM
       constexpr float backlash_smoothing_mm = BACKLASH_SMOOTHING_MM;
     #endif
   #endif
 
-  void Planner::add_backlash_correction_steps(const int32_t da, const int32_t db, const int32_t dc, const uint8_t dm, block_t * const block, float (&delta_mm)[ABCE]) {
+  void Planner::add_backlash_correction_steps(const int32_t da, const int32_t db, const int32_t dc, const uint8_t dm, block_t * const block) {
     static uint8_t last_direction_bits;
     uint8_t changed_dir = last_direction_bits ^ dm;
     // Ignore direction change if no steps are taken in that direction
     if (da == 0) CBI(changed_dir, X_AXIS);
     if (db == 0) CBI(changed_dir, Y_AXIS);
     if (dc == 0) CBI(changed_dir, Z_AXIS);
     last_direction_bits ^= changed_dir;
 
     if (backlash_correction == 0) return;
 
@@ -1591,60 +1590,50 @@ void Planner::synchronize() {
       // Residual error carried forward across multiple segments, so correction can be applied
       // to segments where there is no direction change.
       static int32_t residual_error[XYZ] = { 0 };
     #else
       // No leftover residual error from segment to segment
       int32_t residual_error[XYZ] = { 0 };
       // No direction change, no correction.
       if (!changed_dir) return;
     #endif
 
-    const bool positive[XYZ] = {  da > 0,  db > 0, dc > 0 };
-    #ifdef BACKLASH_SMOOTHING_MM
-      const bool non_zero[XYZ] = { da != 0, db != 0, dc != 0 };
-    #endif
-    bool made_adjustment = false;
+    LOOP_XYZ(axis) {
+      if (backlash_distance_mm[axis]) {
+        const bool reversing = TEST(dm,axis);
 
-    LOOP_XYZ(i) {
-      if (backlash_distance_mm[i]) {
         // When an axis changes direction, add axis backlash to the residual error
-        if (TEST(changed_dir, i))
-          residual_error[i] += backlash_correction * (positive[i] ? 1.0f : -1.0f) * backlash_distance_mm[i] * planner.settings.axis_steps_per_mm[i];
+        if (TEST(changed_dir, axis))
+          residual_error[axis] += backlash_correction * (reversing ? -1.0f : 1.0f) * backlash_distance_mm[axis] * planner.settings.axis_steps_per_mm[axis];
 
         // Decide how much of the residual error to correct in this segment
-        int32_t error_correction = residual_error[i];
+        int32_t error_correction = residual_error[axis];
         #ifdef BACKLASH_SMOOTHING_MM
           if (error_correction && backlash_smoothing_mm != 0) {
             // Take up a portion of the residual_error in this segment, but only when
             // the current segment travels in the same direction as the correction
-            if (non_zero[i] && positive[i] == (error_correction > 0)) {
+            if (reversing == (error_correction < 0)) {
               if (segment_proportion == 0)
                 segment_proportion = MIN(1.0f, block->millimeters / backlash_smoothing_mm);
               error_correction *= segment_proportion;
             }
             else
               error_correction = 0; // Don't take up any backlash in this segment, as it would subtract steps
           }
         #endif
         // Making a correction reduces the residual error and modifies delta_mm
         if (error_correction) {
-          block->steps[i] += ABS(error_correction);
-          residual_error[i] -= error_correction;
-          delta_mm[i] = (positive[i] ? 1.0f : -1.0f) * block->steps[i] * steps_to_mm[i];
-          made_adjustment = true;
+          block->steps[axis] += ABS(error_correction);
+          residual_error[axis] -= error_correction;
         }
       }
     }
-
-    // If any of the axes were adjusted, recompute block->millimeters
-    if (made_adjustment)
-      block->millimeters = SQRT(sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS]));
   }
 #endif // BACKLASH_COMPENSATION
 
 /**
  * Planner::_buffer_steps
  *
  * Add a new linear movement to the planner queue (in terms of steps).
  *
  *  target      - target position in steps units
  *  target_float - target position in direct (mm, degrees) units. optional
@@ -1882,25 +1871,31 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS])
         #elif CORE_IS_XZ
           sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
         #elif CORE_IS_YZ
           sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
         #else
           sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS])
         #endif
       );
 
+    /**
+     * At this point at least one of the axes has more steps than
+     * MIN_STEPS_PER_SEGMENT, ensuring the segment won't get dropped as
+     * zero-length. It's important to not apply corrections
+     * to blocks that would get dropped!
+     *
+     * A correction function is permitted to add steps to an axis, it
+     * should *never* remove steps!
+     */
     #if ENABLED(BACKLASH_COMPENSATION)
-      // If we make it here, at least one of the axes has more steps than
-      // MIN_STEPS_PER_SEGMENT, so the segment won't get dropped by Marlin
-      // and it is okay to add steps for backlash correction.
-      add_backlash_correction_steps(da, db, dc, dm, block, delta_mm);
+      add_backlash_correction_steps(da, db, dc, dm, block);
     #endif
   }
 
   block->steps[E_AXIS] = esteps;
   block->step_event_count = MAX(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   #if ENABLED(MIXING_EXTRUDER)
@@ -2337,21 +2332,20 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif
     }
   #endif
 
   float vmax_junction_sqr; // Initial limit on the segment entry velocity (mm/s)^2
 
   #if ENABLED(JUNCTION_DEVIATION)
-
     /**
      * Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
      * Let a circle be tangent to both previous and current path line segments, where the junction
      * deviation is defined as the distance from the junction to the closest edge of the circle,
      * colinear with the circle center. The circular segment joining the two paths represents the
      * path of centripetal acceleration. Solve for max velocity based on max acceleration about the
      * radius of the circle, defined indirectly by junction deviation. This may be also viewed as
      * path width or max_jerk in the previous Grbl version. This approach does not actually deviate
      * from path, but used as a robust way to compute cornering speeds, as it takes into account the
      * nonlinearities of both the junction angle and junction velocity.

commit 8dcc28c9ae1dead09367d76674ec81382e73b8b8
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu Dec 20 14:34:24 2018 -0700

    Squelch warning mentioned in #11061 (#12676)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 9c618096c5..22a086ac56 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1591,22 +1591,24 @@ void Planner::synchronize() {
       // Residual error carried forward across multiple segments, so correction can be applied
       // to segments where there is no direction change.
       static int32_t residual_error[XYZ] = { 0 };
     #else
       // No leftover residual error from segment to segment
       int32_t residual_error[XYZ] = { 0 };
       // No direction change, no correction.
       if (!changed_dir) return;
     #endif
 
-    const bool positive[XYZ] = {  da > 0,  db > 0, dc > 0 },
-               non_zero[XYZ] = { da != 0, db != 0, dc != 0 };
+    const bool positive[XYZ] = {  da > 0,  db > 0, dc > 0 };
+    #ifdef BACKLASH_SMOOTHING_MM
+      const bool non_zero[XYZ] = { da != 0, db != 0, dc != 0 };
+    #endif
     bool made_adjustment = false;
 
     LOOP_XYZ(i) {
       if (backlash_distance_mm[i]) {
         // When an axis changes direction, add axis backlash to the residual error
         if (TEST(changed_dir, i))
           residual_error[i] += backlash_correction * (positive[i] ? 1.0f : -1.0f) * backlash_distance_mm[i] * planner.settings.axis_steps_per_mm[i];
 
         // Decide how much of the residual error to correct in this segment
         int32_t error_correction = residual_error[i];

commit b22716e938397d8beb64f5855b64f6fdb375b5d2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sat Dec 8 13:36:46 2018 -0700

    M425 Backlash Correction (#11061)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index dcbd688686..9c618096c5 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1539,20 +1539,113 @@ float Planner::get_axis_position_mm(const AxisEnum axis) {
  */
 void Planner::synchronize() {
   while (
     has_blocks_queued() || cleaning_buffer_counter
     #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
       || !READ(CLOSED_LOOP_MOVE_COMPLETE_PIN)
     #endif
   ) idle();
 }
 
+/**
+ * The following implements axis backlash correction. To minimize seams
+ * on the printed part, the backlash correction only adds steps to the
+ * current segment (instead of creating a new segment, which causes
+ * discontinuities and print artifacts).
+ *
+ * When BACKLASH_SMOOTHING_MM is enabled and non-zero, the backlash
+ * correction is spread over multiple segments, smoothing out print
+ * artifacts even more.
+ */
+#if ENABLED(BACKLASH_COMPENSATION)
+  #if ENABLED(BACKLASH_GCODE)
+    extern float backlash_distance_mm[], backlash_correction;
+    #ifdef BACKLASH_SMOOTHING_MM
+      extern float backlash_smoothing_mm;
+    #endif
+  #else
+    constexpr float backlash_distance_mm[XYZ] = BACKLASH_DISTANCE_MM,
+                    backlash_correction = BACKLASH_CORRECTION;
+    #ifdef BACKLASH_SMOOTHING_MM
+      constexpr float backlash_smoothing_mm = BACKLASH_SMOOTHING_MM;
+    #endif
+  #endif
+
+  void Planner::add_backlash_correction_steps(const int32_t da, const int32_t db, const int32_t dc, const uint8_t dm, block_t * const block, float (&delta_mm)[ABCE]) {
+    static uint8_t last_direction_bits;
+    uint8_t changed_dir = last_direction_bits ^ dm;
+    // Ignore direction change if no steps are taken in that direction
+    if (da == 0) CBI(changed_dir, X_AXIS);
+    if (db == 0) CBI(changed_dir, Y_AXIS);
+    if (dc == 0) CBI(changed_dir, Z_AXIS);
+    last_direction_bits ^= changed_dir;
+
+    if (backlash_correction == 0) return;
+
+    #ifdef BACKLASH_SMOOTHING_MM
+      // The segment proportion is a value greater than 0.0 indicating how much residual_error
+      // is corrected for in this segment. The contribution is based on segment length and the
+      // smoothing distance. Since the computation of this proportion involves a floating point
+      // division, defer computation until needed.
+      float segment_proportion = 0;
+
+      // Residual error carried forward across multiple segments, so correction can be applied
+      // to segments where there is no direction change.
+      static int32_t residual_error[XYZ] = { 0 };
+    #else
+      // No leftover residual error from segment to segment
+      int32_t residual_error[XYZ] = { 0 };
+      // No direction change, no correction.
+      if (!changed_dir) return;
+    #endif
+
+    const bool positive[XYZ] = {  da > 0,  db > 0, dc > 0 },
+               non_zero[XYZ] = { da != 0, db != 0, dc != 0 };
+    bool made_adjustment = false;
+
+    LOOP_XYZ(i) {
+      if (backlash_distance_mm[i]) {
+        // When an axis changes direction, add axis backlash to the residual error
+        if (TEST(changed_dir, i))
+          residual_error[i] += backlash_correction * (positive[i] ? 1.0f : -1.0f) * backlash_distance_mm[i] * planner.settings.axis_steps_per_mm[i];
+
+        // Decide how much of the residual error to correct in this segment
+        int32_t error_correction = residual_error[i];
+        #ifdef BACKLASH_SMOOTHING_MM
+          if (error_correction && backlash_smoothing_mm != 0) {
+            // Take up a portion of the residual_error in this segment, but only when
+            // the current segment travels in the same direction as the correction
+            if (non_zero[i] && positive[i] == (error_correction > 0)) {
+              if (segment_proportion == 0)
+                segment_proportion = MIN(1.0f, block->millimeters / backlash_smoothing_mm);
+              error_correction *= segment_proportion;
+            }
+            else
+              error_correction = 0; // Don't take up any backlash in this segment, as it would subtract steps
+          }
+        #endif
+        // Making a correction reduces the residual error and modifies delta_mm
+        if (error_correction) {
+          block->steps[i] += ABS(error_correction);
+          residual_error[i] -= error_correction;
+          delta_mm[i] = (positive[i] ? 1.0f : -1.0f) * block->steps[i] * steps_to_mm[i];
+          made_adjustment = true;
+        }
+      }
+    }
+
+    // If any of the axes were adjusted, recompute block->millimeters
+    if (made_adjustment)
+      block->millimeters = SQRT(sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS]));
+  }
+#endif // BACKLASH_COMPENSATION
+
 /**
  * Planner::_buffer_steps
  *
  * Add a new linear movement to the planner queue (in terms of steps).
  *
  *  target      - target position in steps units
  *  target_float - target position in direct (mm, degrees) units. optional
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *  millimeters - the length of the movement, if known
@@ -1731,20 +1824,84 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     block->steps[A_AXIS] = ABS(da);
     block->steps[B_AXIS] = ABS(db);
     block->steps[Z_AXIS] = ABS(dc);
   #else
     // default non-h-bot planning
     block->steps[A_AXIS] = ABS(da);
     block->steps[B_AXIS] = ABS(db);
     block->steps[C_AXIS] = ABS(dc);
   #endif
 
+  /**
+   * This part of the code calculates the total length of the movement.
+   * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
+   * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
+   * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
+   * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
+   * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
+   */
+  #if IS_CORE
+    float delta_mm[Z_HEAD + 1];
+    #if CORE_IS_XY
+      delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
+      delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
+      delta_mm[Z_AXIS] = dc * steps_to_mm[Z_AXIS];
+      delta_mm[A_AXIS] = (da + db) * steps_to_mm[A_AXIS];
+      delta_mm[B_AXIS] = CORESIGN(da - db) * steps_to_mm[B_AXIS];
+    #elif CORE_IS_XZ
+      delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
+      delta_mm[Y_AXIS] = db * steps_to_mm[Y_AXIS];
+      delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
+      delta_mm[A_AXIS] = (da + dc) * steps_to_mm[A_AXIS];
+      delta_mm[C_AXIS] = CORESIGN(da - dc) * steps_to_mm[C_AXIS];
+    #elif CORE_IS_YZ
+      delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
+      delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
+      delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
+      delta_mm[B_AXIS] = (db + dc) * steps_to_mm[B_AXIS];
+      delta_mm[C_AXIS] = CORESIGN(db - dc) * steps_to_mm[C_AXIS];
+    #endif
+  #else
+    float delta_mm[ABCE];
+    delta_mm[A_AXIS] = da * steps_to_mm[A_AXIS];
+    delta_mm[B_AXIS] = db * steps_to_mm[B_AXIS];
+    delta_mm[C_AXIS] = dc * steps_to_mm[C_AXIS];
+  #endif
+  delta_mm[E_AXIS] = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
+
+  if (block->steps[A_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[B_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[C_AXIS] < MIN_STEPS_PER_SEGMENT) {
+    block->millimeters = ABS(delta_mm[E_AXIS]);
+  }
+  else {
+    if (millimeters)
+      block->millimeters = millimeters;
+    else
+      block->millimeters = SQRT(
+        #if CORE_IS_XY
+          sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS])
+        #elif CORE_IS_XZ
+          sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
+        #elif CORE_IS_YZ
+          sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
+        #else
+          sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS])
+        #endif
+      );
+
+    #if ENABLED(BACKLASH_COMPENSATION)
+      // If we make it here, at least one of the axes has more steps than
+      // MIN_STEPS_PER_SEGMENT, so the segment won't get dropped by Marlin
+      // and it is okay to add steps for backlash correction.
+      add_backlash_correction_steps(da, db, dc, dm, block, delta_mm);
+    #endif
+  }
+
   block->steps[E_AXIS] = esteps;
   block->step_event_count = MAX(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   #if ENABLED(MIXING_EXTRUDER)
     MIXER_POPULATE_BLOCK();
   #endif
 
@@ -1918,76 +2075,20 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       enable_E4();
       enable_E5();
     #endif
   }
 
   if (esteps)
     NOLESS(fr_mm_s, settings.min_feedrate_mm_s);
   else
     NOLESS(fr_mm_s, settings.min_travel_feedrate_mm_s);
 
-  /**
-   * This part of the code calculates the total length of the movement.
-   * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
-   * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
-   * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
-   * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
-   * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
-   */
-  #if IS_CORE
-    float delta_mm[Z_HEAD + 1];
-    #if CORE_IS_XY
-      delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
-      delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
-      delta_mm[Z_AXIS] = dc * steps_to_mm[Z_AXIS];
-      delta_mm[A_AXIS] = (da + db) * steps_to_mm[A_AXIS];
-      delta_mm[B_AXIS] = CORESIGN(da - db) * steps_to_mm[B_AXIS];
-    #elif CORE_IS_XZ
-      delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
-      delta_mm[Y_AXIS] = db * steps_to_mm[Y_AXIS];
-      delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
-      delta_mm[A_AXIS] = (da + dc) * steps_to_mm[A_AXIS];
-      delta_mm[C_AXIS] = CORESIGN(da - dc) * steps_to_mm[C_AXIS];
-    #elif CORE_IS_YZ
-      delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
-      delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
-      delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
-      delta_mm[B_AXIS] = (db + dc) * steps_to_mm[B_AXIS];
-      delta_mm[C_AXIS] = CORESIGN(db - dc) * steps_to_mm[C_AXIS];
-    #endif
-  #else
-    float delta_mm[ABCE];
-    delta_mm[A_AXIS] = da * steps_to_mm[A_AXIS];
-    delta_mm[B_AXIS] = db * steps_to_mm[B_AXIS];
-    delta_mm[C_AXIS] = dc * steps_to_mm[C_AXIS];
-  #endif
-  delta_mm[E_AXIS] = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
-
-  if (block->steps[A_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[B_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[C_AXIS] < MIN_STEPS_PER_SEGMENT) {
-    block->millimeters = ABS(delta_mm[E_AXIS]);
-  }
-  else if (!millimeters) {
-    block->millimeters = SQRT(
-      #if CORE_IS_XY
-        sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS])
-      #elif CORE_IS_XZ
-        sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
-      #elif CORE_IS_YZ
-        sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
-      #else
-        sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS])
-      #endif
-    );
-  }
-  else
-    block->millimeters = millimeters;
-
   const float inverse_millimeters = 1.0f / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate inverse time for this move. No divide by zero due to previous checks.
   // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   float inverse_secs = fr_mm_s * inverse_millimeters;
 
   // Get the number of non busy movements in queue (non busy means that they can be altered)
   const uint8_t moves_queued = nonbusy_movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 01eac0249d..dcbd688686 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1654,33 +1654,31 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           #if HAS_POSITION_FLOAT
             position_float[E_AXIS] = target_float[E_AXIS];
           #endif
           de = 0; // no difference
-          SERIAL_ECHO_START();
-          SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
+          SERIAL_ECHO_MSG(MSG_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
         if (ABS(de * e_factor[extruder]) > (int32_t)settings.axis_steps_per_mm[E_AXIS_N(extruder)] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           #if HAS_POSITION_FLOAT
             position_float[E_AXIS] = target_float[E_AXIS];
           #endif
           de = 0; // no difference
-          SERIAL_ECHO_START();
-          SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
+          SERIAL_ECHO_MSG(MSG_ERR_LONG_EXTRUDE_STOP);
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   // Compute direction bit-mask for this block
   uint8_t dm = 0;
   #if CORE_IS_XY
     if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
     if (db < 0) SBI(dm, Y_HEAD);                // ...and Y

commit 95d154a91fef67289a7bdbc2e57c8767f24aadd4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 28 15:35:18 2018 -0600

    Fans loop macro

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c185678ad0..01eac0249d 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1174,21 +1174,21 @@ void Planner::check_axes_activity() {
       uint8_t tail_valve_pressure;
     #endif
     #if HAS_HEATER_2
       uint8_t tail_e_to_p_pressure;
     #endif
   #endif
 
   if (has_blocks_queued()) {
 
     #if FAN_COUNT > 0
-      for (uint8_t i = 0; i < FAN_COUNT; i++)
+      FANS_LOOP(i)
         tail_fan_speed[i] = block_buffer[block_buffer_tail].fan_speed[i];
     #endif
 
     block_t* block;
 
     #if ENABLED(BARICUDA)
       block = &block_buffer[block_buffer_tail];
       #if HAS_HEATER_1
         tail_valve_pressure = block->valve_pressure;
       #endif
@@ -1197,21 +1197,21 @@ void Planner::check_axes_activity() {
       #endif
     #endif
 
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block = &block_buffer[b];
       LOOP_XYZE(i) if (block->steps[i]) axis_active[i]++;
     }
   }
   else {
     #if FAN_COUNT > 0
-      for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = fan_speed[i];
+      FANS_LOOP(i) tail_fan_speed[i] = fan_speed[i];
     #endif
 
     #if ENABLED(BARICUDA)
       #if HAS_HEATER_1
         tail_valve_pressure = baricuda_valve_pressure;
       #endif
       #if HAS_HEATER_2
         tail_e_to_p_pressure = baricuda_e_to_p_pressure;
       #endif
     #endif
@@ -1744,21 +1744,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   block->step_event_count = MAX(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   #if ENABLED(MIXING_EXTRUDER)
     MIXER_POPULATE_BLOCK();
   #endif
 
   #if FAN_COUNT > 0
-    for (uint8_t i = 0; i < FAN_COUNT; i++) block->fan_speed[i] = fan_speed[i];
+    FANS_LOOP(i) block->fan_speed[i] = fan_speed[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
   #if EXTRUDERS > 1
     block->extruder = extruder;
   #endif

commit e0956bb5724a18485c98e79fe1c05a758a9251c2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 4 16:17:13 2018 -0600

    Drop 'register' storage specifier

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 6181528c03..c185678ad0 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -348,25 +348,25 @@ void Planner::init() {
         524288,508400,493447,479349,466033,453438,441505,430185,419430,409200,399457,390167,381300,372827,364722,356962,
         349525,342392,335544,328965,322638,316551,310689,305040,299593,294337,289262,284359,279620,275036,270600,266305,
         262144,258111,254200,250406,246723,243148,239674,236298,233016,229824,226719,223696,220752,217885,215092,212369,
         209715,207126,204600,202135,199728,197379,195083,192841,190650,188508,186413,184365,182361,180400,178481,176602,
         174762,172960,171196,169466,167772,166111,164482,162885,161319,159783,158275,156796,155344,153919,152520
       };
 
       // For small divisors, it is best to directly retrieve the results
       if (d <= 110) return pgm_read_dword(&small_inv_tab[d]);
 
-      register uint8_t r8 = d & 0xFF,
-                       r9 = (d >> 8) & 0xFF,
-                       r10 = (d >> 16) & 0xFF,
-                       r2,r3,r4,r5,r6,r7,r11,r12,r13,r14,r15,r16,r17,r18;
-      register const uint8_t* ptab = inv_tab;
+      uint8_t r8 = d & 0xFF,
+              r9 = (d >> 8) & 0xFF,
+              r10 = (d >> 16) & 0xFF,
+              r2,r3,r4,r5,r6,r7,r11,r12,r13,r14,r15,r16,r17,r18;
+      const uint8_t* ptab = inv_tab;
 
       __asm__ __volatile__(
         // %8:%7:%6 = interval
         // r31:r30: MUST be those registers, and they must point to the inv_tab
 
         A("clr %13")                       // %13 = 0
 
         // Now we must compute
         // result = 0xFFFFFF / d
         // %8:%7:%6 = interval

commit ac5f2762b70343520c8c72e5dea034b93cbdf629
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 28 15:46:22 2018 -0500

    Use E_AXIS_N where possible

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 18d30ffe11..6181528c03 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -134,23 +134,20 @@ float Planner::steps_to_mm[XYZE_N];           // (mm) Millimeters per step
     float Planner::max_jerk[XYZE];            // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
   #endif
 #endif
 
 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
-  #define _EINDEX (E_AXIS + active_extruder)
-#else
-  #define _EINDEX E_AXIS
 #endif
 
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
 
 float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0f); // The flow percentage and volumetric multiplier combine to scale E movement
 
 #if DISABLED(NO_VOLUMETRICS)
   float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
         Planner::volumetric_area_nominal = CIRCLE_AREA(float(DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5f), // Nominal cross-sectional area
         Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
@@ -2689,21 +2686,21 @@ bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, con
  * The provided ABC position is in machine units.
  */
 
 void Planner::set_machine_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)
     last_extruder = active_extruder;
   #endif
   position[A_AXIS] = LROUND(a * settings.axis_steps_per_mm[A_AXIS]);
   position[B_AXIS] = LROUND(b * settings.axis_steps_per_mm[B_AXIS]);
   position[C_AXIS] = LROUND(c * settings.axis_steps_per_mm[C_AXIS]);
-  position[E_AXIS] = LROUND(e * settings.axis_steps_per_mm[_EINDEX]);
+  position[E_AXIS] = LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(active_extruder)]);
   #if HAS_POSITION_FLOAT
     position_float[A_AXIS] = a;
     position_float[B_AXIS] = b;
     position_float[C_AXIS] = c;
     position_float[E_AXIS] = e;
   #endif
   if (has_blocks_queued()) {
     //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.
     //ZERO(previous_speed);
     buffer_sync_block();
@@ -2731,25 +2728,23 @@ void Planner::set_position_mm(const float &rx, const float &ry, const float &rz,
     set_machine_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS]);
   #else
     set_machine_position_mm(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], raw[E_AXIS]);
   #endif
 }
 
 /**
  * Setters for planner position (also setting stepper position).
  */
 void Planner::set_e_position_mm(const float &e) {
+  const uint8_t axis_index = E_AXIS_N(active_extruder);
   #if ENABLED(DISTINCT_E_FACTORS)
-    const uint8_t axis_index = E_AXIS + active_extruder;
     last_extruder = active_extruder;
-  #else
-    const uint8_t axis_index = E_AXIS;
   #endif
   #if ENABLED(FWRETRACT)
     float e_new = e - fwretract.current_retract[active_extruder];
   #else
     const float e_new = e;
   #endif
   position[E_AXIS] = LROUND(settings.axis_steps_per_mm[axis_index] * e_new);
   #if HAS_POSITION_FLOAT
     position_float[E_AXIS] = e_new;
   #endif
@@ -2758,21 +2753,21 @@ void Planner::set_e_position_mm(const float &e) {
   #endif
   if (has_blocks_queued())
     buffer_sync_block();
   else
     stepper.set_position(E_AXIS, position[E_AXIS]);
 }
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
   #if ENABLED(DISTINCT_E_FACTORS)
-    #define AXIS_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)
+    #define AXIS_CONDITION (i < E_AXIS || i == E_AXIS_N(active_extruder))
   #else
     #define AXIS_CONDITION true
   #endif
   uint32_t highest_rate = 1;
   LOOP_XYZE_N(i) {
     max_acceleration_steps_per_s2[i] = settings.max_acceleration_mm_per_s2[i] * settings.axis_steps_per_mm[i];
     if (AXIS_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   }
   cutoff_long = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
   #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)

commit 2ecb124e42479566c33d2c5da2e48f611bd42464
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 16 03:49:42 2018 -0500

    Fix trailing whitespace

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 68302a2aa8..18d30ffe11 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2061,21 +2061,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     }
   #endif
 
   // Calculate and limit speed in mm/sec for each axis
   float current_speed[NUM_AXIS], speed_factor = 1.0f; // factor <1 decreases speed
   LOOP_XYZE(i) {
     #if ENABLED(MIXING_EXTRUDER) && ENABLED(RETRACT_SYNC_MIXING)
       // In worst case, only one extruder running, no change is needed.
       // In best case, all extruders run the same amount, we can divide by MIXING_STEPPERS
       float delta_mm_i = 0;
-      if (i == E_AXIS && mixer.get_current_v_tool() == MIXER_AUTORETRACT_TOOL) 
+      if (i == E_AXIS && mixer.get_current_v_tool() == MIXER_AUTORETRACT_TOOL)
         delta_mm_i = delta_mm[i] / MIXING_STEPPERS;
       else
         delta_mm_i = delta_mm[i];
     #else
       const float delta_mm_i = delta_mm[i];
     #endif
     const float cs = ABS(current_speed[i] = delta_mm_i * inverse_secs);
     #if ENABLED(DISTINCT_E_FACTORS)
       if (i == E_AXIS) i += extruder;
     #endif

commit f56968ba0b8d4eaccbc9b0c7834cf0cd2f5872d8
Author: AnHardt <github@kitelab.de>
Date:   Tue Oct 16 10:38:57 2018 +0200

    New Continuous Filament Mixer (#12098)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7d1f30f5d8..68302a2aa8 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1742,37 +1742,35 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     block->steps[B_AXIS] = ABS(db);
     block->steps[C_AXIS] = ABS(dc);
   #endif
 
   block->steps[E_AXIS] = esteps;
   block->step_event_count = MAX(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
-  // For a mixing extruder, get a magnified esteps for each
   #if ENABLED(MIXING_EXTRUDER)
-    for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
-      block->mix_steps[i] = mixing_factor[i] * esteps;
+    MIXER_POPULATE_BLOCK();
   #endif
 
   #if FAN_COUNT > 0
     for (uint8_t i = 0; i < FAN_COUNT; i++) block->fan_speed[i] = fan_speed[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
   #if EXTRUDERS > 1
-    block->active_extruder = extruder;
+    block->extruder = extruder;
   #endif
 
   #if ENABLED(AUTO_POWER_CONTROL)
     if (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS])
       powerManager.power_on();
   #endif
 
   // Enable active axes
   #if CORE_IS_XY
     if (block->steps[A_AXIS] || block->steps[B_AXIS]) {
@@ -2059,29 +2057,28 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
             measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
           } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
         }
       }
     }
   #endif
 
   // Calculate and limit speed in mm/sec for each axis
   float current_speed[NUM_AXIS], speed_factor = 1.0f; // factor <1 decreases speed
   LOOP_XYZE(i) {
-    #if ENABLED(MIXING_EXTRUDER)
+    #if ENABLED(MIXING_EXTRUDER) && ENABLED(RETRACT_SYNC_MIXING)
+      // In worst case, only one extruder running, no change is needed.
+      // In best case, all extruders run the same amount, we can divide by MIXING_STEPPERS
       float delta_mm_i = 0;
-      if (i == E_AXIS) {
-        for (uint8_t s = 0; s < MIXING_STEPPERS; s++) {
-          const float delta_mm_s = mixing_factor[s] * delta_mm[i];
-          if (ABS(delta_mm_s) > ABS(delta_mm_i)) delta_mm_i = delta_mm_s;
-        }
-      }
-      else delta_mm_i = delta_mm[i];
+      if (i == E_AXIS && mixer.get_current_v_tool() == MIXER_AUTORETRACT_TOOL) 
+        delta_mm_i = delta_mm[i] / MIXING_STEPPERS;
+      else
+        delta_mm_i = delta_mm[i];
     #else
       const float delta_mm_i = delta_mm[i];
     #endif
     const float cs = ABS(current_speed[i] = delta_mm_i * inverse_secs);
     #if ENABLED(DISTINCT_E_FACTORS)
       if (i == E_AXIS) i += extruder;
     #endif
     if (cs > settings.max_feedrate_mm_s[i]) NOMORE(speed_factor, settings.max_feedrate_mm_s[i] / cs);
   }
 

commit d556dc18650e2185791834d7fe70b4acf45254bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 10 09:45:20 2018 -0500

    Fix and improve EEPROM storage (#12054)
    
    * Clean up Temperature PID
    * Improve EEPROM read/write/validate
    * Group `SINGLENOZZLE` saved settings
    * Group planner saved settings
    * Group filament change saved settings
    * Group skew saved settings
    * Group `FWRETRACT` saved settings

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 3395e759e2..7d1f30f5d8 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -104,32 +104,25 @@ Planner planner;
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head,    // Index of the next block to be pushed
                  Planner::block_buffer_nonbusy, // Index of the first non-busy block
                  Planner::block_buffer_planned, // Index of the optimally planned block
                  Planner::block_buffer_tail;    // Index of the busy block, if any
 uint16_t Planner::cleaning_buffer_counter;      // A counter to disable queuing of blocks
 uint8_t Planner::delay_before_delivering;       // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
-uint32_t Planner::max_acceleration_mm_per_s2[XYZE_N],    // (mm/s^2) M201 XYZE
-         Planner::max_acceleration_steps_per_s2[XYZE_N], // (steps/s^2) Derived from mm_per_s2
-         Planner::min_segment_time_us;                   // (¬µs) M205 B
-
-float Planner::max_feedrate_mm_s[XYZE_N],     // (mm/s) M203 XYZE - Max speeds
-      Planner::axis_steps_per_mm[XYZE_N],     // (steps) M92 XYZE - Steps per millimeter
-      Planner::steps_to_mm[XYZE_N],           // (mm) Millimeters per step
-      Planner::min_feedrate_mm_s,             // (mm/s) M205 S - Minimum linear feedrate
-      Planner::acceleration,                  // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
-      Planner::retract_acceleration,          // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
-      Planner::travel_acceleration,           // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
-      Planner::min_travel_feedrate_mm_s;      // (mm/s) M205 T - Minimum travel feedrate
+planner_settings_t Planner::settings;           // Initialized by settings.load()
+
+uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N]; // (steps/s^2) Derived from mm_per_s2
+
+float Planner::steps_to_mm[XYZE_N];           // (mm) Millimeters per step
 
 #if ENABLED(JUNCTION_DEVIATION)
   float Planner::junction_deviation_mm;       // (mm) M205 J
   #if ENABLED(LIN_ADVANCE)
     #if ENABLED(DISTINCT_E_FACTORS)
       float Planner::max_e_jerk[EXTRUDERS];   // Calculated from junction_deviation_mm
     #else
       float Planner::max_e_jerk;
     #endif
   #endif
@@ -170,32 +163,21 @@ float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0f); // The flow perc
   #endif
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
     float Planner::z_fade_height,      // Initialized by settings.load()
           Planner::inverse_z_fade_height,
           Planner::last_fade_z;
   #endif
 #else
   constexpr bool Planner::leveling_active;
 #endif
 
-#if ENABLED(SKEW_CORRECTION)
-  #if ENABLED(SKEW_CORRECTION_GCODE)
-    float Planner::xy_skew_factor;
-  #else
-    constexpr float Planner::xy_skew_factor;
-  #endif
-  #if ENABLED(SKEW_CORRECTION_FOR_Z) && ENABLED(SKEW_CORRECTION_GCODE)
-    float Planner::xz_skew_factor, Planner::yz_skew_factor;
-  #else
-    constexpr float Planner::xz_skew_factor, Planner::yz_skew_factor;
-  #endif
-#endif
+skew_factor_t Planner::skew_factor; // Initialized by settings.load()
 
 #if ENABLED(AUTOTEMP)
   float Planner::autotemp_max = 250,
         Planner::autotemp_min = 210,
         Planner::autotemp_factor = 0.1f;
   bool Planner::autotemp_enabled = false;
 #endif
 
 // private:
 
@@ -1087,21 +1069,21 @@ void Planner::recalculate_trapezoids() {
           // if that is the case!
           if (!stepper.is_block_busy(current)) {
             // Block is not BUSY, we won the race against the Stepper ISR:
 
             // NOTE: Entry and exit factors always > 0 by all previous logic operations.
             const float current_nominal_speed = SQRT(current->nominal_speed_sqr),
                         nomr = 1.0f / current_nominal_speed;
             calculate_trapezoid_for_block(current, current_entry_speed * nomr, next_entry_speed * nomr);
             #if ENABLED(LIN_ADVANCE)
               if (current->use_advance_lead) {
-                const float comp = current->e_D_ratio * extruder_advance_K[active_extruder] * axis_steps_per_mm[E_AXIS];
+                const float comp = current->e_D_ratio * extruder_advance_K[active_extruder] * settings.axis_steps_per_mm[E_AXIS];
                 current->max_adv_steps = current_nominal_speed * comp;
                 current->final_adv_steps = next_entry_speed * comp;
               }
             #endif
           }
 
           // Reset current only to ensure next trapezoid is computed - The
           // stepper is free to use the block from now on.
           CBI(current->flag, BLOCK_BIT_RECALCULATE);
         }
@@ -1126,21 +1108,21 @@ void Planner::recalculate_trapezoids() {
     // became BUSY, just before it was marked as RECALCULATE, so check
     // if that is the case!
     if (!stepper.is_block_busy(current)) {
       // Block is not BUSY, we won the race against the Stepper ISR:
 
       const float next_nominal_speed = SQRT(next->nominal_speed_sqr),
                   nomr = 1.0f / next_nominal_speed;
       calculate_trapezoid_for_block(next, next_entry_speed * nomr, float(MINIMUM_PLANNER_SPEED) * nomr);
       #if ENABLED(LIN_ADVANCE)
         if (next->use_advance_lead) {
-          const float comp = next->e_D_ratio * extruder_advance_K[active_extruder] * axis_steps_per_mm[E_AXIS];
+          const float comp = next->e_D_ratio * extruder_advance_K[active_extruder] * settings.axis_steps_per_mm[E_AXIS];
           next->max_adv_steps = next_nominal_speed * comp;
           next->final_adv_steps = (MINIMUM_PLANNER_SPEED) * comp;
         }
       #endif
     }
 
     // Reset next only to ensure its trapezoid is computed - The stepper is free to use
     // the block from now on.
     CBI(next->flag, BLOCK_BIT_RECALCULATE);
   }
@@ -1680,21 +1662,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           #if HAS_POSITION_FLOAT
             position_float[E_AXIS] = target_float[E_AXIS];
           #endif
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-        if (ABS(de * e_factor[extruder]) > (int32_t)axis_steps_per_mm[E_AXIS_N(extruder)] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
+        if (ABS(de * e_factor[extruder]) > (int32_t)settings.axis_steps_per_mm[E_AXIS_N(extruder)] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           #if HAS_POSITION_FLOAT
             position_float[E_AXIS] = target_float[E_AXIS];
           #endif
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
@@ -1939,23 +1921,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       enable_E0();
       enable_E1();
       enable_E2();
       enable_E3();
       enable_E4();
       enable_E5();
     #endif
   }
 
   if (esteps)
-    NOLESS(fr_mm_s, min_feedrate_mm_s);
+    NOLESS(fr_mm_s, settings.min_feedrate_mm_s);
   else
-    NOLESS(fr_mm_s, min_travel_feedrate_mm_s);
+    NOLESS(fr_mm_s, settings.min_travel_feedrate_mm_s);
 
   /**
    * This part of the code calculates the total length of the movement.
    * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
    * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
    * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
    * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
    * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
    */
   #if IS_CORE
@@ -2016,23 +1998,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   const uint8_t moves_queued = nonbusy_movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time im micro seconds
     uint32_t segment_time_us = LROUND(1000000.0f / inverse_secs);
   #endif
 
   #if ENABLED(SLOWDOWN)
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
-      if (segment_time_us < min_segment_time_us) {
+      if (segment_time_us < settings.min_segment_time_us) {
         // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
-        const uint32_t nst = segment_time_us + LROUND(2 * (min_segment_time_us - segment_time_us) / moves_queued);
+        const uint32_t nst = segment_time_us + LROUND(2 * (settings.min_segment_time_us - segment_time_us) / moves_queued);
         inverse_secs = 1000000.0f / nst;
         #if defined(XY_FREQUENCY_LIMIT) || ENABLED(ULTRA_LCD)
           segment_time_us = nst;
         #endif
       }
     }
   #endif
 
   #if ENABLED(ULTRA_LCD)
     // Protect the access to the position.
@@ -2093,21 +2075,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         }
       }
       else delta_mm_i = delta_mm[i];
     #else
       const float delta_mm_i = delta_mm[i];
     #endif
     const float cs = ABS(current_speed[i] = delta_mm_i * inverse_secs);
     #if ENABLED(DISTINCT_E_FACTORS)
       if (i == E_AXIS) i += extruder;
     #endif
-    if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
+    if (cs > settings.max_feedrate_mm_s[i]) NOMORE(speed_factor, settings.max_feedrate_mm_s[i] / cs);
   }
 
   // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT
 
     // Check and limit the xy direction change frequency
     const unsigned char direction_change = block->direction_bits ^ old_direction_bits;
     old_direction_bits = block->direction_bits;
     segment_time_us = LROUND((float)segment_time_us / speed_factor);
 
@@ -2146,42 +2128,42 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     LOOP_XYZE(i) current_speed[i] *= speed_factor;
     block->nominal_rate *= speed_factor;
     block->nominal_speed_sqr = block->nominal_speed_sqr * sq(speed_factor);
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
   if (!block->steps[A_AXIS] && !block->steps[B_AXIS] && !block->steps[C_AXIS]) {
     // convert to: acceleration steps/sec^2
-    accel = CEIL(retract_acceleration * steps_per_mm);
+    accel = CEIL(settings.retract_acceleration * steps_per_mm);
     #if ENABLED(LIN_ADVANCE)
       block->use_advance_lead = false;
     #endif
   }
   else {
     #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
         const uint32_t comp = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count; \
         if (accel * block->steps[AXIS] > comp) accel = comp / block->steps[AXIS]; \
       } \
     }while(0)
 
     #define LIMIT_ACCEL_FLOAT(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
         const float comp = (float)max_acceleration_steps_per_s2[AXIS+INDX] * (float)block->step_event_count; \
         if ((float)accel * (float)block->steps[AXIS] > comp) accel = comp / (float)block->steps[AXIS]; \
       } \
     }while(0)
 
     // Start with print or travel acceleration
-    accel = CEIL((esteps ? acceleration : travel_acceleration) * steps_per_mm);
+    accel = CEIL((esteps ? settings.acceleration : settings.travel_acceleration) * steps_per_mm);
 
     #if ENABLED(LIN_ADVANCE)
 
       #if ENABLED(JUNCTION_DEVIATION)
         #if ENABLED(DISTINCT_E_FACTORS)
           #define MAX_E_JERK max_e_jerk[extruder]
         #else
           #define MAX_E_JERK max_e_jerk
         #endif
       #else
@@ -2247,21 +2229,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
     block->acceleration_rate = (uint32_t)(accel * (4096.0f * 4096.0f / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
-      block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * axis_steps_per_mm[E_AXIS_N(extruder)]);
+      block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * settings.axis_steps_per_mm[E_AXIS_N(extruder)]);
       #if ENABLED(LA_DEBUG)
         if (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * 2 < SQRT(block->nominal_speed_sqr) * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif
     }
   #endif
 
   float vmax_junction_sqr; // Initial limit on the segment entry velocity (mm/s)^2
@@ -2559,33 +2541,33 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
     , const float (&delta_mm_cart)[XYZE]
   #endif
   , const float &fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
-    if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N(extruder)] != axis_steps_per_mm[E_AXIS + last_extruder]) {
-      position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N(extruder)] * steps_to_mm[E_AXIS + last_extruder]);
+    if (last_extruder != extruder && settings.axis_steps_per_mm[E_AXIS_N(extruder)] != settings.axis_steps_per_mm[E_AXIS + last_extruder]) {
+      position[E_AXIS] = LROUND(position[E_AXIS] * settings.axis_steps_per_mm[E_AXIS_N(extruder)] * steps_to_mm[E_AXIS + last_extruder]);
       last_extruder = extruder;
     }
   #endif
 
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
   const int32_t target[ABCE] = {
-    LROUND(a * axis_steps_per_mm[A_AXIS]),
-    LROUND(b * axis_steps_per_mm[B_AXIS]),
-    LROUND(c * axis_steps_per_mm[C_AXIS]),
-    LROUND(e * axis_steps_per_mm[E_AXIS_N(extruder)])
+    LROUND(a * settings.axis_steps_per_mm[A_AXIS]),
+    LROUND(b * settings.axis_steps_per_mm[B_AXIS]),
+    LROUND(c * settings.axis_steps_per_mm[C_AXIS]),
+    LROUND(e * settings.axis_steps_per_mm[E_AXIS_N(extruder)])
   };
 
   #if HAS_POSITION_FLOAT
     const float target_float[XYZE] = { a, b, c, e };
   #endif
 
   // DRYRUN prevents E moves from taking place
   if (DEBUGGING(DRYRUN)) {
     position[E_AXIS] = target[E_AXIS];
     #if HAS_POSITION_FLOAT
@@ -2707,24 +2689,24 @@ bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, con
  * Directly set the planner ABC position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * The provided ABC position is in machine units.
  */
 
 void Planner::set_machine_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)
     last_extruder = active_extruder;
   #endif
-  position[A_AXIS] = LROUND(a * axis_steps_per_mm[A_AXIS]);
-  position[B_AXIS] = LROUND(b * axis_steps_per_mm[B_AXIS]);
-  position[C_AXIS] = LROUND(c * axis_steps_per_mm[C_AXIS]);
-  position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
+  position[A_AXIS] = LROUND(a * settings.axis_steps_per_mm[A_AXIS]);
+  position[B_AXIS] = LROUND(b * settings.axis_steps_per_mm[B_AXIS]);
+  position[C_AXIS] = LROUND(c * settings.axis_steps_per_mm[C_AXIS]);
+  position[E_AXIS] = LROUND(e * settings.axis_steps_per_mm[_EINDEX]);
   #if HAS_POSITION_FLOAT
     position_float[A_AXIS] = a;
     position_float[B_AXIS] = b;
     position_float[C_AXIS] = c;
     position_float[E_AXIS] = e;
   #endif
   if (has_blocks_queued()) {
     //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.
     //ZERO(previous_speed);
     buffer_sync_block();
@@ -2763,21 +2745,21 @@ void Planner::set_e_position_mm(const float &e) {
     const uint8_t axis_index = E_AXIS + active_extruder;
     last_extruder = active_extruder;
   #else
     const uint8_t axis_index = E_AXIS;
   #endif
   #if ENABLED(FWRETRACT)
     float e_new = e - fwretract.current_retract[active_extruder];
   #else
     const float e_new = e;
   #endif
-  position[E_AXIS] = LROUND(axis_steps_per_mm[axis_index] * e_new);
+  position[E_AXIS] = LROUND(settings.axis_steps_per_mm[axis_index] * e_new);
   #if HAS_POSITION_FLOAT
     position_float[E_AXIS] = e_new;
   #endif
   #if IS_KINEMATIC
     position_cart[E_AXIS] = e;
   #endif
   if (has_blocks_queued())
     buffer_sync_block();
   else
     stepper.set_position(E_AXIS, position[E_AXIS]);
@@ -2785,32 +2767,32 @@ void Planner::set_e_position_mm(const float &e) {
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define AXIS_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)
   #else
     #define AXIS_CONDITION true
   #endif
   uint32_t highest_rate = 1;
   LOOP_XYZE_N(i) {
-    max_acceleration_steps_per_s2[i] = max_acceleration_mm_per_s2[i] * axis_steps_per_mm[i];
+    max_acceleration_steps_per_s2[i] = settings.max_acceleration_mm_per_s2[i] * settings.axis_steps_per_mm[i];
     if (AXIS_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   }
   cutoff_long = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
   #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
     recalculate_max_e_jerk();
   #endif
 }
 
-// Recalculate position, steps_to_mm if axis_steps_per_mm changes!
+// Recalculate position, steps_to_mm if settings.axis_steps_per_mm changes!
 void Planner::refresh_positioning() {
-  LOOP_XYZE_N(i) steps_to_mm[i] = 1.0f / axis_steps_per_mm[i];
+  LOOP_XYZE_N(i) steps_to_mm[i] = 1.0f / settings.axis_steps_per_mm[i];
   set_position_mm(current_position);
   reset_acceleration_rates();
 }
 
 #if ENABLED(AUTOTEMP)
 
   void Planner::autotemp_M104_M109() {
     if ((autotemp_enabled = parser.seen('F'))) autotemp_factor = parser.value_float();
     if (parser.seen('S')) autotemp_min = parser.value_celsius();
     if (parser.seen('B')) autotemp_max = parser.value_celsius();

commit 7db0113b53632946ad85836b309190ae2d98f9c4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 7 18:19:52 2018 -0500

    Improve E_AXIS_N macro

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 278011042e..3395e759e2 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1680,21 +1680,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           #if HAS_POSITION_FLOAT
             position_float[E_AXIS] = target_float[E_AXIS];
           #endif
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-        if (ABS(de * e_factor[extruder]) > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
+        if (ABS(de * e_factor[extruder]) > (int32_t)axis_steps_per_mm[E_AXIS_N(extruder)] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           #if HAS_POSITION_FLOAT
             position_float[E_AXIS] = target_float[E_AXIS];
           #endif
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
@@ -1978,21 +1978,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
       delta_mm[B_AXIS] = (db + dc) * steps_to_mm[B_AXIS];
       delta_mm[C_AXIS] = CORESIGN(db - dc) * steps_to_mm[C_AXIS];
     #endif
   #else
     float delta_mm[ABCE];
     delta_mm[A_AXIS] = da * steps_to_mm[A_AXIS];
     delta_mm[B_AXIS] = db * steps_to_mm[B_AXIS];
     delta_mm[C_AXIS] = dc * steps_to_mm[C_AXIS];
   #endif
-  delta_mm[E_AXIS] = esteps_float * steps_to_mm[E_AXIS_N];
+  delta_mm[E_AXIS] = esteps_float * steps_to_mm[E_AXIS_N(extruder)];
 
   if (block->steps[A_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[B_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[C_AXIS] < MIN_STEPS_PER_SEGMENT) {
     block->millimeters = ABS(delta_mm[E_AXIS]);
   }
   else if (!millimeters) {
     block->millimeters = SQRT(
       #if CORE_IS_XY
         sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS])
       #elif CORE_IS_XZ
         sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
@@ -2247,21 +2247,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
     block->acceleration_rate = (uint32_t)(accel * (4096.0f * 4096.0f / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
-      block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * axis_steps_per_mm[E_AXIS_N]);
+      block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * axis_steps_per_mm[E_AXIS_N(extruder)]);
       #if ENABLED(LA_DEBUG)
         if (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * 2 < SQRT(block->nominal_speed_sqr) * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif
     }
   #endif
 
   float vmax_junction_sqr; // Initial limit on the segment entry velocity (mm/s)^2
@@ -2559,33 +2559,33 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
     , const float (&delta_mm_cart)[XYZE]
   #endif
   , const float &fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
-    if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
-      position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
+    if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N(extruder)] != axis_steps_per_mm[E_AXIS + last_extruder]) {
+      position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N(extruder)] * steps_to_mm[E_AXIS + last_extruder]);
       last_extruder = extruder;
     }
   #endif
 
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
   const int32_t target[ABCE] = {
     LROUND(a * axis_steps_per_mm[A_AXIS]),
     LROUND(b * axis_steps_per_mm[B_AXIS]),
     LROUND(c * axis_steps_per_mm[C_AXIS]),
-    LROUND(e * axis_steps_per_mm[E_AXIS_N])
+    LROUND(e * axis_steps_per_mm[E_AXIS_N(extruder)])
   };
 
   #if HAS_POSITION_FLOAT
     const float target_float[XYZE] = { a, b, c, e };
   #endif
 
   // DRYRUN prevents E moves from taking place
   if (DEBUGGING(DRYRUN)) {
     position[E_AXIS] = target[E_AXIS];
     #if HAS_POSITION_FLOAT

commit d6b0fbd7715da67a2aaeeeafb0d4dc7c1563ef98
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 7 15:34:41 2018 -0500

    Use uint8_t for all fan speeds (#12032)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c502976095..278011042e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1180,22 +1180,22 @@ void Planner::recalculate() {
     oldt = t;
     thermalManager.setTargetHotend(t, 0);
   }
 
 #endif // AUTOTEMP
 
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
-  unsigned char axis_active[NUM_AXIS] = { 0 },
-                tail_fan_speed[FAN_COUNT];
+  uint8_t axis_active[NUM_AXIS] = { 0 },
+          tail_fan_speed[FAN_COUNT];
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
     #endif
     #if HAS_HEATER_2
       uint8_t tail_e_to_p_pressure;
     #endif
   #endif
 
@@ -1218,21 +1218,21 @@ void Planner::check_axes_activity() {
       #endif
     #endif
 
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block = &block_buffer[b];
       LOOP_XYZE(i) if (block->steps[i]) axis_active[i]++;
     }
   }
   else {
     #if FAN_COUNT > 0
-      for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = fanSpeeds[i];
+      for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = fan_speed[i];
     #endif
 
     #if ENABLED(BARICUDA)
       #if HAS_HEATER_1
         tail_valve_pressure = baricuda_valve_pressure;
       #endif
       #if HAS_HEATER_2
         tail_e_to_p_pressure = baricuda_e_to_p_pressure;
       #endif
     #endif
@@ -1767,21 +1767,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   // For a mixing extruder, get a magnified esteps for each
   #if ENABLED(MIXING_EXTRUDER)
     for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
       block->mix_steps[i] = mixing_factor[i] * esteps;
   #endif
 
   #if FAN_COUNT > 0
-    for (uint8_t i = 0; i < FAN_COUNT; i++) block->fan_speed[i] = fanSpeeds[i];
+    for (uint8_t i = 0; i < FAN_COUNT; i++) block->fan_speed[i] = fan_speed[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
   #if EXTRUDERS > 1
     block->active_extruder = extruder;
   #endif

commit 49823a4939874ae9befdce315f54d3e4ee8869c7
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sat Oct 6 13:02:50 2018 -0400

    Fix broken jerk handling (#12019)
    
    Fix #12004

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 5b1f11638f..c502976095 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2080,28 +2080,30 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       }
     }
   #endif
 
   // Calculate and limit speed in mm/sec for each axis
   float current_speed[NUM_AXIS], speed_factor = 1.0f; // factor <1 decreases speed
   LOOP_XYZE(i) {
     #if ENABLED(MIXING_EXTRUDER)
       float delta_mm_i = 0;
       if (i == E_AXIS) {
-        for (uint8_t s = 0; s < MIXING_STEPPERS; s++)
-          delta_mm_i = MAX(mixing_factor[s] * ABS(delta_mm[i]), delta_mm_i);
+        for (uint8_t s = 0; s < MIXING_STEPPERS; s++) {
+          const float delta_mm_s = mixing_factor[s] * delta_mm[i];
+          if (ABS(delta_mm_s) > ABS(delta_mm_i)) delta_mm_i = delta_mm_s;
+        }
       }
-      else delta_mm_i = ABS(delta_mm[i]);
+      else delta_mm_i = delta_mm[i];
     #else
-      const float delta_mm_i = ABS(delta_mm[i]);
+      const float delta_mm_i = delta_mm[i];
     #endif
-    const float cs = current_speed[i] = delta_mm_i * inverse_secs;
+    const float cs = ABS(current_speed[i] = delta_mm_i * inverse_secs);
     #if ENABLED(DISTINCT_E_FACTORS)
       if (i == E_AXIS) i += extruder;
     #endif
     if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
   }
 
   // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT
 
     // Check and limit the xy direction change frequency

commit ab4549d2bcbd01ca5f5fbe2de4b6ddda0fb499f8
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Tue Oct 2 00:32:02 2018 -0400

    [2.0.x] Add simultaneous retraction for mixing extruder (#11941)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7fffee08b0..5b1f11638f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2077,21 +2077,31 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
             measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
           } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
         }
       }
     }
   #endif
 
   // Calculate and limit speed in mm/sec for each axis
   float current_speed[NUM_AXIS], speed_factor = 1.0f; // factor <1 decreases speed
   LOOP_XYZE(i) {
-    const float cs = ABS((current_speed[i] = delta_mm[i] * inverse_secs));
+    #if ENABLED(MIXING_EXTRUDER)
+      float delta_mm_i = 0;
+      if (i == E_AXIS) {
+        for (uint8_t s = 0; s < MIXING_STEPPERS; s++)
+          delta_mm_i = MAX(mixing_factor[s] * ABS(delta_mm[i]), delta_mm_i);
+      }
+      else delta_mm_i = ABS(delta_mm[i]);
+    #else
+      const float delta_mm_i = ABS(delta_mm[i]);
+    #endif
+    const float cs = current_speed[i] = delta_mm_i * inverse_secs;
     #if ENABLED(DISTINCT_E_FACTORS)
       if (i == E_AXIS) i += extruder;
     #endif
     if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
   }
 
   // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT
 
     // Check and limit the xy direction change frequency

commit b30ca652aed417be0ba8857922c1cf2b4df26f2d
Author: AnoNymous <dgdanielf@gmail.com>
Date:   Sun Sep 30 11:59:14 2018 +0200

    Replace MIN# / MAX# with variadic MIN / MAX (#11960)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index d659615847..7fffee08b0 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1755,21 +1755,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     block->steps[B_AXIS] = ABS(db);
     block->steps[Z_AXIS] = ABS(dc);
   #else
     // default non-h-bot planning
     block->steps[A_AXIS] = ABS(da);
     block->steps[B_AXIS] = ABS(db);
     block->steps[C_AXIS] = ABS(dc);
   #endif
 
   block->steps[E_AXIS] = esteps;
-  block->step_event_count = MAX4(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
+  block->step_event_count = MAX(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   // For a mixing extruder, get a magnified esteps for each
   #if ENABLED(MIXING_EXTRUDER)
     for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
       block->mix_steps[i] = mixing_factor[i] * esteps;
   #endif
 
@@ -2113,22 +2113,22 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     }
     xs0 = axis_segment_time_us[X_AXIS][0] = xs0 + segment_time_us;
 
     if (TEST(direction_change, Y_AXIS)) {
       ys2 = axis_segment_time_us[Y_AXIS][2] = axis_segment_time_us[Y_AXIS][1];
       ys1 = axis_segment_time_us[Y_AXIS][1] = axis_segment_time_us[Y_AXIS][0];
       ys0 = 0;
     }
     ys0 = axis_segment_time_us[Y_AXIS][0] = ys0 + segment_time_us;
 
-    const uint32_t max_x_segment_time = MAX3(xs0, xs1, xs2),
-                   max_y_segment_time = MAX3(ys0, ys1, ys2),
+    const uint32_t max_x_segment_time = MAX(xs0, xs1, xs2),
+                   max_y_segment_time = MAX(ys0, ys1, ys2),
                    min_xy_segment_time = MIN(max_x_segment_time, max_y_segment_time);
     if (min_xy_segment_time < MAX_FREQ_TIME_US) {
       const float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME_US);
       NOMORE(speed_factor, low_sf);
     }
   #endif // XY_FREQUENCY_LIMIT
 
   // Correct the speed
   if (speed_factor < 1.0f) {
     LOOP_XYZE(i) current_speed[i] *= speed_factor;
@@ -2347,21 +2347,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
           // If angle is greater than 135 degrees (octagon), find speed for approximate arc
           if (junction_theta > RADIANS(135)) {
             const float limit_sqr = block->millimeters / (RADIANS(180) - junction_theta) * junction_acceleration;
             NOMORE(vmax_junction_sqr, limit_sqr);
           }
         }
       }
 
       // Get the lowest speed
-      vmax_junction_sqr = MIN3(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
+      vmax_junction_sqr = MIN(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
       vmax_junction_sqr = 0;
 
     COPY(previous_unit_vec, unit_vec);
 
   #endif
 
   #if HAS_CLASSIC_JERK
 

commit 14df753086a1914f182368c8acb7143213cd3abf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 29 19:13:17 2018 -0500

    Correction for block->mix_steps
    
    Fix #11484

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 26a386a5f9..d659615847 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1763,27 +1763,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   block->steps[E_AXIS] = esteps;
   block->step_event_count = MAX4(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   // For a mixing extruder, get a magnified esteps for each
   #if ENABLED(MIXING_EXTRUDER)
     for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
-      block->mix_steps[i] = mixing_factor[i] * (
-        #if ENABLED(LIN_ADVANCE)
-          esteps
-        #else
-          block->step_event_count
-        #endif
-      );
+      block->mix_steps[i] = mixing_factor[i] * esteps;
   #endif
 
   #if FAN_COUNT > 0
     for (uint8_t i = 0; i < FAN_COUNT; i++) block->fan_speed[i] = fanSpeeds[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif

commit c5e5cc5e9f20e82cbd15b47a85bf08bbca542961
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 17 17:30:04 2018 -0500

    Fix some trailing whitespace, macros

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 190e2f75cc..26a386a5f9 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2635,21 +2635,21 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
 /**
  * Add a new linear movement to the buffer.
  * The target is cartesian, it's translated to delta/scara if
  * needed.
  *
  *
  *  rx,ry,rz,e   - target position in mm or degrees
  *  fr_mm_s      - (target) speed of the move (mm/s)
  *  extruder     - target extruder
  *  millimeters  - the length of the movement, if known
- *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled) 
+ *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled)
  */
 bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, const float &e, const float &fr_mm_s, const uint8_t extruder, const float millimeters
   #if ENABLED(SCARA_FEEDRATE_SCALING)
     , const float &inv_duration
   #endif
 ) {
   float raw[XYZE] = { rx, ry, rz, e };
   #if HAS_POSITION_MODIFIERS
     apply_modifiers(raw);
   #endif
@@ -2659,21 +2659,21 @@ bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, con
       rx - position_cart[X_AXIS],
       ry - position_cart[Y_AXIS],
       rz - position_cart[Z_AXIS]
       #if ENABLED(JUNCTION_DEVIATION)
         , e - position_cart[E_AXIS]
       #endif
     };
 
     float mm = millimeters;
     if (mm == 0.0)
-      mm = (delta_mm_cart[X_AXIS] != 0.0 || delta_mm_cart[Y_AXIS] != 0.0) ? SQRT(sq(delta_mm_cart[X_AXIS]) + sq(delta_mm_cart[Y_AXIS]) + sq(delta_mm_cart[Z_AXIS])) : fabs(delta_mm_cart[Z_AXIS]);
+      mm = (delta_mm_cart[X_AXIS] != 0.0 || delta_mm_cart[Y_AXIS] != 0.0) ? SQRT(sq(delta_mm_cart[X_AXIS]) + sq(delta_mm_cart[Y_AXIS]) + sq(delta_mm_cart[Z_AXIS])) : ABS(delta_mm_cart[Z_AXIS]);
 
     inverse_kinematics(raw);
 
     #if ENABLED(SCARA_FEEDRATE_SCALING)
       // For SCARA scale the feed rate from mm/s to degrees/s
       // i.e., Complete the angular vector in the given time.
       const float duration_recip = inv_duration ? inv_duration : fr_mm_s / mm,
                   feedrate = HYPOT(delta[A_AXIS] - position_float[A_AXIS], delta[B_AXIS] - position_float[B_AXIS]) * duration_recip;
     #else
       const float feedrate = fr_mm_s;

commit 1718eff54adefc7cc95851f28df0c7e02eae3a36
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 13 01:35:55 2018 -0500

    Code changes supporting up to 6 extruders

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 98a40fcca1..190e2f75cc 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1842,20 +1842,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       switch (extruder) {
         case 0:
           #if EXTRUDERS > 1
             DISABLE_IDLE_E(1);
             #if EXTRUDERS > 2
               DISABLE_IDLE_E(2);
               #if EXTRUDERS > 3
                 DISABLE_IDLE_E(3);
                 #if EXTRUDERS > 4
                   DISABLE_IDLE_E(4);
+                  #if EXTRUDERS > 5
+                    DISABLE_IDLE_E(5);
+                  #endif // EXTRUDERS > 5
                 #endif // EXTRUDERS > 4
               #endif // EXTRUDERS > 3
             #endif // EXTRUDERS > 2
           #endif // EXTRUDERS > 1
           enable_E0();
           g_uc_extruder_last_move[0] = (BLOCK_BUFFER_SIZE) * 2;
           #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
             if (extruder_duplication_enabled) {
               enable_E1();
               g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
@@ -1864,70 +1867,94 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         break;
         #if EXTRUDERS > 1
           case 1:
             DISABLE_IDLE_E(0);
             #if EXTRUDERS > 2
               DISABLE_IDLE_E(2);
               #if EXTRUDERS > 3
                 DISABLE_IDLE_E(3);
                 #if EXTRUDERS > 4
                   DISABLE_IDLE_E(4);
+                  #if EXTRUDERS > 5
+                    DISABLE_IDLE_E(5);
+                  #endif // EXTRUDERS > 5
                 #endif // EXTRUDERS > 4
               #endif // EXTRUDERS > 3
             #endif // EXTRUDERS > 2
             enable_E1();
             g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
           break;
           #if EXTRUDERS > 2
             case 2:
               DISABLE_IDLE_E(0);
               DISABLE_IDLE_E(1);
               #if EXTRUDERS > 3
                 DISABLE_IDLE_E(3);
                 #if EXTRUDERS > 4
                   DISABLE_IDLE_E(4);
+                  #if EXTRUDERS > 5
+                    DISABLE_IDLE_E(5);
+                  #endif
                 #endif
               #endif
               enable_E2();
               g_uc_extruder_last_move[2] = (BLOCK_BUFFER_SIZE) * 2;
             break;
             #if EXTRUDERS > 3
               case 3:
                 DISABLE_IDLE_E(0);
                 DISABLE_IDLE_E(1);
                 DISABLE_IDLE_E(2);
                 #if EXTRUDERS > 4
                   DISABLE_IDLE_E(4);
+                  #if EXTRUDERS > 5
+                    DISABLE_IDLE_E(5);
+                  #endif
                 #endif
                 enable_E3();
                 g_uc_extruder_last_move[3] = (BLOCK_BUFFER_SIZE) * 2;
               break;
               #if EXTRUDERS > 4
                 case 4:
                   DISABLE_IDLE_E(0);
                   DISABLE_IDLE_E(1);
                   DISABLE_IDLE_E(2);
                   DISABLE_IDLE_E(3);
+                  #if EXTRUDERS > 5
+                    DISABLE_IDLE_E(5);
+                  #endif
                   enable_E4();
                   g_uc_extruder_last_move[4] = (BLOCK_BUFFER_SIZE) * 2;
                 break;
+                #if EXTRUDERS > 5
+                  case 5:
+                    DISABLE_IDLE_E(0);
+                    DISABLE_IDLE_E(1);
+                    DISABLE_IDLE_E(2);
+                    DISABLE_IDLE_E(3);
+                    DISABLE_IDLE_E(4);
+                    enable_E5();
+                    g_uc_extruder_last_move[5] = (BLOCK_BUFFER_SIZE) * 2;
+                  break;
+                #endif // EXTRUDERS > 5
               #endif // EXTRUDERS > 4
             #endif // EXTRUDERS > 3
           #endif // EXTRUDERS > 2
         #endif // EXTRUDERS > 1
       }
     #else
       enable_E0();
       enable_E1();
       enable_E2();
       enable_E3();
       enable_E4();
+      enable_E5();
     #endif
   }
 
   if (esteps)
     NOLESS(fr_mm_s, min_feedrate_mm_s);
   else
     NOLESS(fr_mm_s, min_travel_feedrate_mm_s);
 
   /**
    * This part of the code calculates the total length of the movement.

commit c437bb08f12f1c0535cc78a761b49a18f2dc2a12
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Sep 16 22:24:15 2018 -0400

    Overhaul of the planner (#11578)
    
    - Move FWRETRACT to the planner
    - Combine leveling, skew, etc. in a single modifier method
    - Have kinematic and non-kinematic moves call one planner method

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index fe286a2acf..98a40fcca1 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -126,22 +126,27 @@ float Planner::max_feedrate_mm_s[XYZE_N],     // (mm/s) M203 XYZE - Max speeds
 
 #if ENABLED(JUNCTION_DEVIATION)
   float Planner::junction_deviation_mm;       // (mm) M205 J
   #if ENABLED(LIN_ADVANCE)
     #if ENABLED(DISTINCT_E_FACTORS)
       float Planner::max_e_jerk[EXTRUDERS];   // Calculated from junction_deviation_mm
     #else
       float Planner::max_e_jerk;
     #endif
   #endif
-#else
-  float Planner::max_jerk[XYZE];              // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
+#endif
+#if HAS_CLASSIC_JERK
+  #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+    float Planner::max_jerk[XYZ];             // (mm/s^2) M205 XYZ - The largest speed change requiring no acceleration.
+  #else
+    float Planner::max_jerk[XYZE];            // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
+  #endif
 #endif
 
 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
   #define _EINDEX (E_AXIS + active_extruder)
 #else
@@ -213,35 +218,42 @@ float Planner::previous_speed[NUM_AXIS],
 #endif
 
 #if ENABLED(LIN_ADVANCE)
   float Planner::extruder_advance_K[EXTRUDERS]; // Initialized by settings.load()
 #endif
 
 #if HAS_POSITION_FLOAT
   float Planner::position_float[XYZE]; // Needed for accurate maths. Steps cannot be used!
 #endif
 
+#if IS_KINEMATIC
+  float Planner::position_cart[XYZE];
+#endif
+
 #if ENABLED(ULTRA_LCD)
   volatile uint32_t Planner::block_buffer_runtime_us = 0;
 #endif
 
 /**
  * Class and Instance Methods
  */
 
 Planner::Planner() { init(); }
 
 void Planner::init() {
   ZERO(position);
   #if HAS_POSITION_FLOAT
     ZERO(position_float);
   #endif
+  #if IS_KINEMATIC
+    ZERO(position_cart);
+  #endif
   ZERO(previous_speed);
   previous_nominal_speed_sqr = 0;
   #if ABL_PLANAR
     bed_level_matrix.set_to_identity();
   #endif
   clear_block_buffer();
   delay_before_delivering = 0;
 }
 
 #if ENABLED(S_CURVE_ACCELERATION)
@@ -1347,31 +1359,26 @@ void Planner::check_axes_activity() {
                 ratio_2 = sq(nom_meas_ratio);
 
     volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = parser.volumetric_enabled
       ? ratio_2 / CIRCLE_AREA(filament_width_nominal * 0.5f) // Volumetric uses a true volumetric multiplier
       : ratio_2;                                             // Linear squares the ratio, which scales the volume
 
     refresh_e_factor(FILAMENT_SENSOR_EXTRUDER_NUM);
   }
 #endif
 
-#if PLANNER_LEVELING || HAS_UBL_AND_CURVES
+#if HAS_LEVELING
   /**
    * rx, ry, rz - Cartesian positions in mm
    *              Leveled XYZ on completion
    */
   void Planner::apply_leveling(float &rx, float &ry, float &rz) {
-
-    #if ENABLED(SKEW_CORRECTION)
-      skew(rx, ry, rz);
-    #endif
-
     if (!leveling_active) return;
 
     #if ABL_PLANAR
 
       float dx = rx - (X_TILT_FULCRUM),
             dy = ry - (Y_TILT_FULCRUM);
 
       apply_rotation_xyz(bed_level_matrix, dx, dy, rz);
 
       rx = dx + X_TILT_FULCRUM;
@@ -1399,24 +1406,20 @@ void Planner::check_axes_activity() {
         #elif ENABLED(AUTO_BED_LEVELING_UBL)
           fade_scaling_factor ? fade_scaling_factor * ubl.get_z_correction(rx, ry) : 0.0
         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
           fade_scaling_factor ? fade_scaling_factor * bilinear_z_offset(raw) : 0.0
         #endif
       );
 
     #endif
   }
 
-#endif
-
-#if PLANNER_LEVELING
-
   void Planner::unapply_leveling(float raw[XYZ]) {
 
     if (leveling_active) {
 
       #if ABL_PLANAR
 
         matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
 
         float dx = raw[X_AXIS] - (X_TILT_FULCRUM),
               dy = raw[Y_AXIS] - (Y_TILT_FULCRUM);
@@ -1449,21 +1452,37 @@ void Planner::check_axes_activity() {
         );
 
       #endif
     }
 
     #if ENABLED(SKEW_CORRECTION)
       unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]);
     #endif
   }
 
-#endif // PLANNER_LEVELING
+#endif // HAS_LEVELING
+
+#if ENABLED(FWRETRACT)
+  /**
+   * rz, e - Cartesian positions in mm
+   */
+  void Planner::apply_retract(float &rz, float &e) {
+    rz += fwretract.current_hop;
+    e -= fwretract.current_retract[active_extruder];
+  }
+
+  void Planner::unapply_retract(float &rz, float &e) {
+    rz -= fwretract.current_hop;
+    e += fwretract.current_retract[active_extruder];
+  }
+
+#endif
 
 void Planner::quick_stop() {
 
   // Remove all the queued blocks. Note that this function is NOT
   // called from the Stepper ISR, so we must consider tail as readonly!
   // that is why we set head to tail - But there is a race condition that
   // must be handled: The tail could change between the read and the assignment
   // so this must be enclosed in a critical section
 
   const bool was_enabled = STEPPER_ISR_ENABLED();
@@ -1547,45 +1566,52 @@ void Planner::synchronize() {
     #endif
   ) idle();
 }
 
 /**
  * Planner::_buffer_steps
  *
  * Add a new linear movement to the planner queue (in terms of steps).
  *
  *  target      - target position in steps units
+ *  target_float - target position in direct (mm, degrees) units. optional
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *  millimeters - the length of the movement, if known
  *
  * Returns true if movement was properly queued, false otherwise
  */
 bool Planner::_buffer_steps(const int32_t (&target)[XYZE]
   #if HAS_POSITION_FLOAT
-    , const float (&target_float)[XYZE]
+    , const float (&target_float)[ABCE]
+  #endif
+  #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+    , const float (&delta_mm_cart)[XYZE]
   #endif
   , float fr_mm_s, const uint8_t extruder, const float &millimeters
 ) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Fill the block with the specified movement
   if (!_populate_block(block, false, target
     #if HAS_POSITION_FLOAT
       , target_float
     #endif
+    #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+      , delta_mm_cart
+    #endif
     , fr_mm_s, extruder, millimeters
   )) {
     // Movement was not queued, probably because it was too short.
     //  Simply accept that as movement queued and done
     return true;
   }
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to
@@ -1611,23 +1637,26 @@ bool Planner::_buffer_steps(const int32_t (&target)[XYZE]
  *
  * Fills a new linear movement in the block (in terms of steps).
  *
  *  target      - target position in steps units
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *
  * Returns true is movement is acceptable, false otherwise
  */
 bool Planner::_populate_block(block_t * const block, bool split_move,
-  const int32_t (&target)[XYZE]
+  const int32_t (&target)[ABCE]
   #if HAS_POSITION_FLOAT
-    , const float (&target_float)[XYZE]
+    , const float (&target_float)[ABCE]
+  #endif
+  #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+    , const float (&delta_mm_cart)[XYZE]
   #endif
   , float fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
   const int32_t da = target[A_AXIS] - position[A_AXIS],
                 db = target[B_AXIS] - position[B_AXIS],
                 dc = target[C_AXIS] - position[C_AXIS];
 
   int32_t de = target[E_AXIS] - position[E_AXIS];
 
@@ -2236,26 +2265,35 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           Okay! It seems to be working good. I somewhat arbitrarily cut it off at 1mm
           on then on anything with less sides than an octagon. With this, and the
           reverse pass actually recalculating things, a corner acceleration value
           of 1000 junction deviation of .05 are pretty reasonable. If the cycles
           can be spared, a better acos could be used. For all I know, it may be
           already calculated in a different place. */
 
     // Unit vector of previous path line segment
     static float previous_unit_vec[XYZE];
 
-    float unit_vec[] = {
-      delta_mm[A_AXIS] * inverse_millimeters,
-      delta_mm[B_AXIS] * inverse_millimeters,
-      delta_mm[C_AXIS] * inverse_millimeters,
-      delta_mm[E_AXIS] * inverse_millimeters
-    };
+    #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+      float unit_vec[] = {
+        delta_mm_cart[X_AXIS] * inverse_millimeters,
+        delta_mm_cart[Y_AXIS] * inverse_millimeters,
+        delta_mm_cart[Z_AXIS] * inverse_millimeters,
+        delta_mm_cart[E_AXIS] * inverse_millimeters
+      };
+    #else
+      float unit_vec[] = {
+        delta_mm[X_AXIS] * inverse_millimeters,
+        delta_mm[Y_AXIS] * inverse_millimeters,
+        delta_mm[Z_AXIS] * inverse_millimeters,
+        delta_mm[E_AXIS] * inverse_millimeters
+      };
+    #endif
 
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
       float junction_cos_theta = -previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
                                  -previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
                                  -previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS]
                                  -previous_unit_vec[E_AXIS] * unit_vec[E_AXIS]
                                 ;
@@ -2295,36 +2333,43 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       }
 
       // Get the lowest speed
       vmax_junction_sqr = MIN3(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
       vmax_junction_sqr = 0;
 
     COPY(previous_unit_vec, unit_vec);
 
-  #else // Classic Jerk Limiting
+  #endif
+
+  #if HAS_CLASSIC_JERK
 
     /**
      * Adapted from Pr≈Ø≈°a MKS firmware
      * https://github.com/prusa3d/Prusa-Firmware
      */
     const float nominal_speed = SQRT(block->nominal_speed_sqr);
 
     // Exit speed limited by a jerk to full halt of a previous last segment
     static float previous_safe_speed;
 
     // Start with a safe speed (from which the machine may halt to stop immediately).
     float safe_speed = nominal_speed;
 
     uint8_t limited = 0;
-    LOOP_XYZE(i) {
+    #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+      LOOP_XYZ(i)
+    #else
+      LOOP_XYZE(i)
+    #endif
+    {
       const float jerk = ABS(current_speed[i]),   // cs : Starting from zero, change in speed for this axis
                   maxj = max_jerk[i];             // mj : The max jerk setting for this axis
       if (jerk > maxj) {                          // cs > mj : New current speed too fast?
         if (limited) {                            // limited already?
           const float mjerk = nominal_speed * maxj; // ns*mj
           if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk; // ns*mj/cs
         }
         else {
           safe_speed *= maxj / jerk;              // Initial limit: ns*mj/cs
           ++limited;                              // Initially limited
@@ -2342,21 +2387,26 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       float v_factor = 1;
       limited = 0;
 
       // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
       // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
       const float previous_nominal_speed = SQRT(previous_nominal_speed_sqr);
       vmax_junction = MIN(nominal_speed, previous_nominal_speed);
 
       // Now limit the jerk in all axes.
       const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
-      LOOP_XYZE(axis) {
+      #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+        LOOP_XYZ(axis)
+      #else
+        LOOP_XYZE(axis)
+      #endif
+      {
         // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
         float v_exit = previous_speed[axis] * smaller_speed_factor,
               v_entry = current_speed[axis];
         if (limited) {
           v_exit *= v_factor;
           v_entry *= v_factor;
         }
 
         // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
         const float jerk = (v_exit > v_entry)
@@ -2374,21 +2424,26 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
       // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
       const float vmax_junction_threshold = vmax_junction * 0.99f;
       if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold)
         vmax_junction = safe_speed;
     }
     else
       vmax_junction = safe_speed;
 
     previous_safe_speed = safe_speed;
-    vmax_junction_sqr = sq(vmax_junction);
+
+    #if ENABLED(JUNCTION_DEVIATION)
+      vmax_junction_sqr = MIN(vmax_junction_sqr, sq(vmax_junction));
+    #else
+      vmax_junction_sqr = sq(vmax_junction);
+    #endif
 
   #endif // Classic Jerk Limiting
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed_sqr = vmax_junction_sqr;
 
   // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
   const float v_allowable_sqr = max_allowable_speed_sqr(-block->acceleration, sq(float(MINIMUM_PLANNER_SPEED)), block->millimeters);
 
   // If we are trying to add a split block, start with the
@@ -2459,21 +2514,26 @@ void Planner::buffer_sync_block() {
  *
  * Add a new linear movement to the buffer in axis units.
  *
  * Leveling and kinematics should be applied ahead of calling this.
  *
  *  a,b,c,e     - target positions in mm and/or degrees
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *  millimeters - the length of the movement, if known
  */
-bool Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/) {
+bool Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e
+  #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+    , const float (&delta_mm_cart)[XYZE]
+  #endif
+  , const float &fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
+) {
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
     if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
       position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
       last_extruder = extruder;
     }
@@ -2527,101 +2587,174 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
     SERIAL_ECHOPAIR("->", target[E_AXIS]);
     SERIAL_ECHOLNPGM(")");
   //*/
 
   // Queue the movement
     if (
     !_buffer_steps(target
       #if HAS_POSITION_FLOAT
         , target_float
       #endif
+      #if IS_KINEMATIC && ENABLED(JUNCTION_DEVIATION)
+        , delta_mm_cart
+      #endif
       , fr_mm_s, extruder, millimeters
     )
   ) return false;
 
   stepper.wake_up();
   return true;
 } // buffer_segment()
 
 /**
- * Directly set the planner XYZ position (and stepper positions)
+ * Add a new linear movement to the buffer.
+ * The target is cartesian, it's translated to delta/scara if
+ * needed.
+ *
+ *
+ *  rx,ry,rz,e   - target position in mm or degrees
+ *  fr_mm_s      - (target) speed of the move (mm/s)
+ *  extruder     - target extruder
+ *  millimeters  - the length of the movement, if known
+ *  inv_duration - the reciprocal if the duration of the movement, if known (kinematic only if feeedrate scaling is enabled) 
+ */
+bool Planner::buffer_line(const float &rx, const float &ry, const float &rz, const float &e, const float &fr_mm_s, const uint8_t extruder, const float millimeters
+  #if ENABLED(SCARA_FEEDRATE_SCALING)
+    , const float &inv_duration
+  #endif
+) {
+  float raw[XYZE] = { rx, ry, rz, e };
+  #if HAS_POSITION_MODIFIERS
+    apply_modifiers(raw);
+  #endif
+
+  #if IS_KINEMATIC
+    const float delta_mm_cart[] = {
+      rx - position_cart[X_AXIS],
+      ry - position_cart[Y_AXIS],
+      rz - position_cart[Z_AXIS]
+      #if ENABLED(JUNCTION_DEVIATION)
+        , e - position_cart[E_AXIS]
+      #endif
+    };
+
+    float mm = millimeters;
+    if (mm == 0.0)
+      mm = (delta_mm_cart[X_AXIS] != 0.0 || delta_mm_cart[Y_AXIS] != 0.0) ? SQRT(sq(delta_mm_cart[X_AXIS]) + sq(delta_mm_cart[Y_AXIS]) + sq(delta_mm_cart[Z_AXIS])) : fabs(delta_mm_cart[Z_AXIS]);
+
+    inverse_kinematics(raw);
+
+    #if ENABLED(SCARA_FEEDRATE_SCALING)
+      // For SCARA scale the feed rate from mm/s to degrees/s
+      // i.e., Complete the angular vector in the given time.
+      const float duration_recip = inv_duration ? inv_duration : fr_mm_s / mm,
+                  feedrate = HYPOT(delta[A_AXIS] - position_float[A_AXIS], delta[B_AXIS] - position_float[B_AXIS]) * duration_recip;
+    #else
+      const float feedrate = fr_mm_s;
+    #endif
+    if (buffer_segment(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS]
+      #if ENABLED(JUNCTION_DEVIATION)
+        , delta_mm_cart
+      #endif
+      , feedrate, extruder, mm
+    )) {
+      position_cart[X_AXIS] = rx;
+      position_cart[Y_AXIS] = ry;
+      position_cart[Z_AXIS] = rz;
+      position_cart[E_AXIS] = e;
+      return true;
+    }
+    else
+      return false;
+  #else
+    return buffer_segment(raw, fr_mm_s, extruder, millimeters);
+  #endif
+} // buffer_line()
+
+/**
+ * Directly set the planner ABC position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
- * On CORE machines stepper ABC will be translated from the given XYZ.
+ * The provided ABC position is in machine units.
  */
 
-void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
+void Planner::set_machine_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)
     last_extruder = active_extruder;
   #endif
   position[A_AXIS] = LROUND(a * axis_steps_per_mm[A_AXIS]);
   position[B_AXIS] = LROUND(b * axis_steps_per_mm[B_AXIS]);
-  position[C_AXIS] = LROUND(axis_steps_per_mm[C_AXIS] * (c +(
-    #if !IS_KINEMATIC && ENABLED(AUTO_BED_LEVELING_UBL)
-      leveling_active ? ubl.get_z_correction(a, b) :
-    #endif
-    0)
-  ));
+  position[C_AXIS] = LROUND(c * axis_steps_per_mm[C_AXIS]);
   position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
   #if HAS_POSITION_FLOAT
     position_float[A_AXIS] = a;
     position_float[B_AXIS] = b;
     position_float[C_AXIS] = c;
     position_float[E_AXIS] = e;
   #endif
   if (has_blocks_queued()) {
     //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.
     //ZERO(previous_speed);
     buffer_sync_block();
   }
   else
     stepper.set_position(position[A_AXIS], position[B_AXIS], position[C_AXIS], position[E_AXIS]);
 }
 
-void Planner::set_position_mm_kinematic(const float (&cart)[XYZE]) {
-  #if PLANNER_LEVELING
-    float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
-    apply_leveling(raw);
-  #else
-    const float (&raw)[XYZE] = cart;
+void Planner::set_position_mm(const float &rx, const float &ry, const float &rz, const float &e) {
+  float raw[XYZE] = { rx, ry, rz, e };
+  #if HAS_POSITION_MODIFIERS
+    apply_modifiers(raw
+      #if HAS_LEVELING
+        , true
+      #endif
+    );
   #endif
   #if IS_KINEMATIC
+    position_cart[X_AXIS] = rx;
+    position_cart[Y_AXIS] = ry;
+    position_cart[Z_AXIS] = rz;
+    position_cart[E_AXIS] = e;
+
     inverse_kinematics(raw);
-    _set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS]);
+    set_machine_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS]);
   #else
-    _set_position_mm(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS]);
+    set_machine_position_mm(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], raw[E_AXIS]);
   #endif
 }
 
 /**
  * Setters for planner position (also setting stepper position).
  */
-void Planner::set_position_mm(const AxisEnum axis, const float &v) {
+void Planner::set_e_position_mm(const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)
-    const uint8_t axis_index = axis + (axis == E_AXIS ? active_extruder : 0);
+    const uint8_t axis_index = E_AXIS + active_extruder;
     last_extruder = active_extruder;
   #else
-    const uint8_t axis_index = axis;
+    const uint8_t axis_index = E_AXIS;
   #endif
-  position[axis] = LROUND(axis_steps_per_mm[axis_index] * (v + (
-    #if ENABLED(AUTO_BED_LEVELING_UBL)
-      axis == Z_AXIS && leveling_active ? ubl.get_z_correction(current_position[X_AXIS], current_position[Y_AXIS]) :
-    #endif
-    0)
-  ));
+  #if ENABLED(FWRETRACT)
+    float e_new = e - fwretract.current_retract[active_extruder];
+  #else
+    const float e_new = e;
+  #endif
+  position[E_AXIS] = LROUND(axis_steps_per_mm[axis_index] * e_new);
   #if HAS_POSITION_FLOAT
-    position_float[axis] = v;
+    position_float[E_AXIS] = e_new;
+  #endif
+  #if IS_KINEMATIC
+    position_cart[E_AXIS] = e;
   #endif
   if (has_blocks_queued())
     buffer_sync_block();
   else
-    stepper.set_position(axis, position[axis]);
+    stepper.set_position(E_AXIS, position[E_AXIS]);
 }
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define AXIS_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)
   #else
     #define AXIS_CONDITION true
   #endif
   uint32_t highest_rate = 1;
@@ -2631,21 +2764,21 @@ void Planner::reset_acceleration_rates() {
   }
   cutoff_long = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
   #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
     recalculate_max_e_jerk();
   #endif
 }
 
 // Recalculate position, steps_to_mm if axis_steps_per_mm changes!
 void Planner::refresh_positioning() {
   LOOP_XYZE_N(i) steps_to_mm[i] = 1.0f / axis_steps_per_mm[i];
-  set_position_mm_kinematic(current_position);
+  set_position_mm(current_position);
   reset_acceleration_rates();
 }
 
 #if ENABLED(AUTOTEMP)
 
   void Planner::autotemp_M104_M109() {
     if ((autotemp_enabled = parser.seen('F'))) autotemp_factor = parser.value_float();
     if (parser.seen('S')) autotemp_min = parser.value_celsius();
     if (parser.seen('B')) autotemp_max = parser.value_celsius();
   }

commit d882717d98d08ba7a47234eacf291b2d82288f13
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 10 23:09:26 2018 -0500

    Save some PROGMEM with constexpr (#11798)
    
    When possible, make `active_extruder` a `constexpr` to save some PROGMEM.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index fbbce90eaa..fe286a2acf 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1752,21 +1752,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
   #if FAN_COUNT > 0
     for (uint8_t i = 0; i < FAN_COUNT; i++) block->fan_speed[i] = fanSpeeds[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
-  block->active_extruder = extruder;
+  #if EXTRUDERS > 1
+    block->active_extruder = extruder;
+  #endif
 
   #if ENABLED(AUTO_POWER_CONTROL)
     if (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS])
       powerManager.power_on();
   #endif
 
   // Enable active axes
   #if CORE_IS_XY
     if (block->steps[A_AXIS] || block->steps[B_AXIS]) {
       enable_X();

commit 4f883d59712608d82d33d387d13571c8a0b7dfd4
Author: Sam Lane <9569766+SJ-Innovation@users.noreply.github.com>
Date:   Tue Sep 11 04:37:32 2018 +0100

    [2.0.x] Extruder-Distinct Linear Advance K Factors (#11789)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 4db6e58d48..fbbce90eaa 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -206,21 +206,21 @@ float Planner::previous_speed[NUM_AXIS],
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
   // Old direction bits. Used for speed calculations
   unsigned char Planner::old_direction_bits = 0;
   // Segment times (in ¬µs). Used for speed calculations
   uint32_t Planner::axis_segment_time_us[2][3] = { { MAX_FREQ_TIME_US + 1, 0, 0 }, { MAX_FREQ_TIME_US + 1, 0, 0 } };
 #endif
 
 #if ENABLED(LIN_ADVANCE)
-  float Planner::extruder_advance_K; // Initialized by settings.load()
+  float Planner::extruder_advance_K[EXTRUDERS]; // Initialized by settings.load()
 #endif
 
 #if HAS_POSITION_FLOAT
   float Planner::position_float[XYZE]; // Needed for accurate maths. Steps cannot be used!
 #endif
 
 #if ENABLED(ULTRA_LCD)
   volatile uint32_t Planner::block_buffer_runtime_us = 0;
 #endif
 
@@ -1075,21 +1075,21 @@ void Planner::recalculate_trapezoids() {
           // if that is the case!
           if (!stepper.is_block_busy(current)) {
             // Block is not BUSY, we won the race against the Stepper ISR:
 
             // NOTE: Entry and exit factors always > 0 by all previous logic operations.
             const float current_nominal_speed = SQRT(current->nominal_speed_sqr),
                         nomr = 1.0f / current_nominal_speed;
             calculate_trapezoid_for_block(current, current_entry_speed * nomr, next_entry_speed * nomr);
             #if ENABLED(LIN_ADVANCE)
               if (current->use_advance_lead) {
-                const float comp = current->e_D_ratio * extruder_advance_K * axis_steps_per_mm[E_AXIS];
+                const float comp = current->e_D_ratio * extruder_advance_K[active_extruder] * axis_steps_per_mm[E_AXIS];
                 current->max_adv_steps = current_nominal_speed * comp;
                 current->final_adv_steps = next_entry_speed * comp;
               }
             #endif
           }
 
           // Reset current only to ensure next trapezoid is computed - The
           // stepper is free to use the block from now on.
           CBI(current->flag, BLOCK_BIT_RECALCULATE);
         }
@@ -1114,21 +1114,21 @@ void Planner::recalculate_trapezoids() {
     // became BUSY, just before it was marked as RECALCULATE, so check
     // if that is the case!
     if (!stepper.is_block_busy(current)) {
       // Block is not BUSY, we won the race against the Stepper ISR:
 
       const float next_nominal_speed = SQRT(next->nominal_speed_sqr),
                   nomr = 1.0f / next_nominal_speed;
       calculate_trapezoid_for_block(next, next_entry_speed * nomr, float(MINIMUM_PLANNER_SPEED) * nomr);
       #if ENABLED(LIN_ADVANCE)
         if (next->use_advance_lead) {
-          const float comp = next->e_D_ratio * extruder_advance_K * axis_steps_per_mm[E_AXIS];
+          const float comp = next->e_D_ratio * extruder_advance_K[active_extruder] * axis_steps_per_mm[E_AXIS];
           next->max_adv_steps = next_nominal_speed * comp;
           next->final_adv_steps = (MINIMUM_PLANNER_SPEED) * comp;
         }
       #endif
     }
 
     // Reset next only to ensure its trapezoid is computed - The stepper is free to use
     // the block from now on.
     CBI(next->flag, BLOCK_BIT_RECALCULATE);
   }
@@ -2123,45 +2123,45 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       #else
         #define MAX_E_JERK max_jerk[E_AXIS]
       #endif
 
       /**
        *
        * Use LIN_ADVANCE for blocks if all these are true:
        *
        * esteps             : This is a print move, because we checked for A, B, C steps before.
        *
-       * extruder_advance_K : There is an advance factor set.
+       * extruder_advance_K[active_extruder] : There is an advance factor set for this extruder.
        *
        * de > 0             : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
        */
       block->use_advance_lead =  esteps
-                              && extruder_advance_K
+                              && extruder_advance_K[active_extruder]
                               && de > 0;
 
       if (block->use_advance_lead) {
         block->e_D_ratio = (target_float[E_AXIS] - position_float[E_AXIS]) /
           #if IS_KINEMATIC
             block->millimeters
           #else
             SQRT(sq(target_float[X_AXIS] - position_float[X_AXIS])
                + sq(target_float[Y_AXIS] - position_float[Y_AXIS])
                + sq(target_float[Z_AXIS] - position_float[Z_AXIS]))
           #endif
         ;
 
         // Check for unusual high e_D ratio to detect if a retract move was combined with the last print move due to min. steps per segment. Never execute this with advance!
         // This assumes no one will use a retract length of 0mm < retr_length < ~0.2mm and no one will print 100mm wide lines using 3mm filament or 35mm wide lines using 1.75mm filament.
         if (block->e_D_ratio > 3.0f)
           block->use_advance_lead = false;
         else {
-          const uint32_t max_accel_steps_per_s2 = MAX_E_JERK / (extruder_advance_K * block->e_D_ratio) * steps_per_mm;
+          const uint32_t max_accel_steps_per_s2 = MAX_E_JERK / (extruder_advance_K[active_extruder] * block->e_D_ratio) * steps_per_mm;
           #if ENABLED(LA_DEBUG)
             if (accel > max_accel_steps_per_s2) SERIAL_ECHOLNPGM("Acceleration limited.");
           #endif
           NOMORE(accel, max_accel_steps_per_s2);
         }
       }
     #endif
 
     #if ENABLED(DISTINCT_E_FACTORS)
       #define ACCEL_IDX extruder
@@ -2183,23 +2183,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
     block->acceleration_rate = (uint32_t)(accel * (4096.0f * 4096.0f / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
-      block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K * block->e_D_ratio * block->acceleration * axis_steps_per_mm[E_AXIS_N]);
+      block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * axis_steps_per_mm[E_AXIS_N]);
       #if ENABLED(LA_DEBUG)
-        if (extruder_advance_K * block->e_D_ratio * block->acceleration * 2 < SQRT(block->nominal_speed_sqr) * block->e_D_ratio)
+        if (extruder_advance_K[active_extruder] * block->e_D_ratio * block->acceleration * 2 < SQRT(block->nominal_speed_sqr) * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif
     }
   #endif
 
   float vmax_junction_sqr; // Initial limit on the segment entry velocity (mm/s)^2
 
   #if ENABLED(JUNCTION_DEVIATION)

commit 1b6bc194279b24e24df29bdd677a112236deac34
Author: Sam Lane <sl01172@surrey.ac.uk>
Date:   Sat Sep 8 18:08:31 2018 +0100

    Add external closed loop controller support

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 43f7a40a41..4db6e58d48 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1532,21 +1532,28 @@ float Planner::get_axis_position_mm(const AxisEnum axis) {
       axis_steps = stepper.position(axis);
   #else
     axis_steps = stepper.position(axis);
   #endif
   return axis_steps * steps_to_mm[axis];
 }
 
 /**
  * Block until all buffered steps are executed / cleaned
  */
-void Planner::synchronize() { while (has_blocks_queued() || cleaning_buffer_counter) idle(); }
+void Planner::synchronize() {
+  while (
+    has_blocks_queued() || cleaning_buffer_counter
+    #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
+      || !READ(CLOSED_LOOP_MOVE_COMPLETE_PIN)
+    #endif
+  ) idle();
+}
 
 /**
  * Planner::_buffer_steps
  *
  * Add a new linear movement to the planner queue (in terms of steps).
  *
  *  target      - target position in steps units
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *  millimeters - the length of the movement, if known

commit 59e76e5fdf815448d320412d104940bfae21f61a
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Mon Sep 3 07:29:29 2018 +0200

    [2.0.x] Fix planner computation (#11708)
    
    Fix #11697

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 19b985cbf5..43f7a40a41 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2586,25 +2586,25 @@ void Planner::set_position_mm_kinematic(const float (&cart)[XYZE]) {
 /**
  * Setters for planner position (also setting stepper position).
  */
 void Planner::set_position_mm(const AxisEnum axis, const float &v) {
   #if ENABLED(DISTINCT_E_FACTORS)
     const uint8_t axis_index = axis + (axis == E_AXIS ? active_extruder : 0);
     last_extruder = active_extruder;
   #else
     const uint8_t axis_index = axis;
   #endif
-  position[axis] = LROUND(axis_steps_per_mm[axis_index] * (v +
+  position[axis] = LROUND(axis_steps_per_mm[axis_index] * (v + (
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       axis == Z_AXIS && leveling_active ? ubl.get_z_correction(current_position[X_AXIS], current_position[Y_AXIS]) :
     #endif
-    0
+    0)
   ));
   #if HAS_POSITION_FLOAT
     position_float[axis] = v;
   #endif
   if (has_blocks_queued())
     buffer_sync_block();
   else
     stepper.set_position(axis, position[axis]);
 }
 

commit db306507311862946a966e006a626dfc28f69ad6
Author: Kevin <kevinbayer8@gmail.com>
Date:   Thu Aug 16 15:28:40 2018 +0200

    Fix UBL/Homing (#11566)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index f673b656a3..19b985cbf5 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2539,25 +2539,25 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
  *
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
 
 void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)
     last_extruder = active_extruder;
   #endif
   position[A_AXIS] = LROUND(a * axis_steps_per_mm[A_AXIS]);
   position[B_AXIS] = LROUND(b * axis_steps_per_mm[B_AXIS]);
-  position[C_AXIS] = LROUND(axis_steps_per_mm[C_AXIS] * (c +
+  position[C_AXIS] = LROUND(axis_steps_per_mm[C_AXIS] * (c +(
     #if !IS_KINEMATIC && ENABLED(AUTO_BED_LEVELING_UBL)
       leveling_active ? ubl.get_z_correction(a, b) :
     #endif
-    0
+    0)
   ));
   position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
   #if HAS_POSITION_FLOAT
     position_float[A_AXIS] = a;
     position_float[B_AXIS] = b;
     position_float[C_AXIS] = c;
     position_float[E_AXIS] = e;
   #endif
   if (has_blocks_queued()) {
     //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.

commit c93538e9f3d409c9b96921d0d9ed4681fa0226b6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Aug 11 22:48:44 2018 -0500

    UBL/planner patch tweaks

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e911b6f28b..f673b656a3 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -147,21 +147,21 @@ float Planner::max_feedrate_mm_s[XYZE_N],     // (mm/s) M203 XYZE - Max speeds
 #else
   #define _EINDEX E_AXIS
 #endif
 
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
 
 float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0f); // The flow percentage and volumetric multiplier combine to scale E movement
 
 #if DISABLED(NO_VOLUMETRICS)
   float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
-        Planner::volumetric_area_nominal = CIRCLE_AREA((float(DEFAULT_NOMINAL_FILAMENT_DIA)) * 0.5f), // Nominal cross-sectional area
+        Planner::volumetric_area_nominal = CIRCLE_AREA(float(DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5f), // Nominal cross-sectional area
         Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
 #endif
 
 #if HAS_LEVELING
   bool Planner::leveling_active = false; // Flag that auto bed leveling is enabled
   #if ABL_PLANAR
     matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
   #endif
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
     float Planner::z_fade_height,      // Initialized by settings.load()
@@ -2539,26 +2539,26 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
  *
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
 
 void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)
     last_extruder = active_extruder;
   #endif
   position[A_AXIS] = LROUND(a * axis_steps_per_mm[A_AXIS]);
   position[B_AXIS] = LROUND(b * axis_steps_per_mm[B_AXIS]);
-  #if !IS_KINEMATIC && ENABLED(AUTO_BED_LEVELING_UBL)
-    if (leveling_active)
-      position[C_AXIS] = LROUND((c + ubl.get_z_correction(a, b)) * axis_steps_per_mm[Z_AXIS]);
-    else
-  #endif
-  position[C_AXIS] = LROUND(c * axis_steps_per_mm[C_AXIS]);
+  position[C_AXIS] = LROUND(axis_steps_per_mm[C_AXIS] * (c +
+    #if !IS_KINEMATIC && ENABLED(AUTO_BED_LEVELING_UBL)
+      leveling_active ? ubl.get_z_correction(a, b) :
+    #endif
+    0
+  ));
   position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
   #if HAS_POSITION_FLOAT
     position_float[A_AXIS] = a;
     position_float[B_AXIS] = b;
     position_float[C_AXIS] = c;
     position_float[E_AXIS] = e;
   #endif
   if (has_blocks_queued()) {
     //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.
     //ZERO(previous_speed);
@@ -2586,33 +2586,31 @@ void Planner::set_position_mm_kinematic(const float (&cart)[XYZE]) {
 /**
  * Setters for planner position (also setting stepper position).
  */
 void Planner::set_position_mm(const AxisEnum axis, const float &v) {
   #if ENABLED(DISTINCT_E_FACTORS)
     const uint8_t axis_index = axis + (axis == E_AXIS ? active_extruder : 0);
     last_extruder = active_extruder;
   #else
     const uint8_t axis_index = axis;
   #endif
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-    if (axis == Z_AXIS && leveling_active)
-      position[axis] = LROUND((v + ubl.get_z_correction(current_position[X_AXIS], current_position[Y_AXIS])) * axis_steps_per_mm[axis_index]);
-    else
-  #endif
-  position[axis] = LROUND(v * axis_steps_per_mm[axis_index]);
+  position[axis] = LROUND(axis_steps_per_mm[axis_index] * (v +
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+      axis == Z_AXIS && leveling_active ? ubl.get_z_correction(current_position[X_AXIS], current_position[Y_AXIS]) :
+    #endif
+    0
+  ));
   #if HAS_POSITION_FLOAT
     position_float[axis] = v;
   #endif
-  if (has_blocks_queued()) {
-    //previous_speed[axis] = 0.0;
+  if (has_blocks_queued())
     buffer_sync_block();
-  }
   else
     stepper.set_position(axis, position[axis]);
 }
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define AXIS_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)
   #else
     #define AXIS_CONDITION true

commit fc55f1da015ee351c78f349d92bb5ce392cfa951
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Fri Aug 10 14:00:50 2018 -0400

    Account for UBL correction when setting the planner position (#11486)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c93d811271..e911b6f28b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2537,23 +2537,28 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
  * Directly set the planner XYZ position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
 
 void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)
     last_extruder = active_extruder;
   #endif
-  position[A_AXIS] = LROUND(a * axis_steps_per_mm[A_AXIS]),
-  position[B_AXIS] = LROUND(b * axis_steps_per_mm[B_AXIS]),
-  position[C_AXIS] = LROUND(c * axis_steps_per_mm[C_AXIS]),
+  position[A_AXIS] = LROUND(a * axis_steps_per_mm[A_AXIS]);
+  position[B_AXIS] = LROUND(b * axis_steps_per_mm[B_AXIS]);
+  #if !IS_KINEMATIC && ENABLED(AUTO_BED_LEVELING_UBL)
+    if (leveling_active)
+      position[C_AXIS] = LROUND((c + ubl.get_z_correction(a, b)) * axis_steps_per_mm[Z_AXIS]);
+    else
+  #endif
+  position[C_AXIS] = LROUND(c * axis_steps_per_mm[C_AXIS]);
   position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
   #if HAS_POSITION_FLOAT
     position_float[A_AXIS] = a;
     position_float[B_AXIS] = b;
     position_float[C_AXIS] = c;
     position_float[E_AXIS] = e;
   #endif
   if (has_blocks_queued()) {
     //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.
     //ZERO(previous_speed);
@@ -2581,20 +2586,25 @@ void Planner::set_position_mm_kinematic(const float (&cart)[XYZE]) {
 /**
  * Setters for planner position (also setting stepper position).
  */
 void Planner::set_position_mm(const AxisEnum axis, const float &v) {
   #if ENABLED(DISTINCT_E_FACTORS)
     const uint8_t axis_index = axis + (axis == E_AXIS ? active_extruder : 0);
     last_extruder = active_extruder;
   #else
     const uint8_t axis_index = axis;
   #endif
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+    if (axis == Z_AXIS && leveling_active)
+      position[axis] = LROUND((v + ubl.get_z_correction(current_position[X_AXIS], current_position[Y_AXIS])) * axis_steps_per_mm[axis_index]);
+    else
+  #endif
   position[axis] = LROUND(v * axis_steps_per_mm[axis_index]);
   #if HAS_POSITION_FLOAT
     position_float[axis] = v;
   #endif
   if (has_blocks_queued()) {
     //previous_speed[axis] = 0.0;
     buffer_sync_block();
   }
   else
     stepper.set_position(axis, position[axis]);

commit b826bf41945b453067c3516eafe67b8ed035f0ed
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jul 30 22:50:08 2018 -0500

    Fix initial safe_speed in jerk code (#11417)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 22fda4ab98..c93d811271 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1341,21 +1341,21 @@ void Planner::check_axes_activity() {
    * into a volumetric multiplier. Conversion differs when using
    * linear extrusion vs volumetric extrusion.
    */
   void Planner::calculate_volumetric_for_width_sensor(const int8_t encoded_ratio) {
     // Reconstitute the nominal/measured ratio
     const float nom_meas_ratio = 1 + 0.01f * encoded_ratio,
                 ratio_2 = sq(nom_meas_ratio);
 
     volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = parser.volumetric_enabled
       ? ratio_2 / CIRCLE_AREA(filament_width_nominal * 0.5f) // Volumetric uses a true volumetric multiplier
-      : ratio_2;                                            // Linear squares the ratio, which scales the volume
+      : ratio_2;                                             // Linear squares the ratio, which scales the volume
 
     refresh_e_factor(FILAMENT_SENSOR_EXTRUDER_NUM);
   }
 #endif
 
 #if PLANNER_LEVELING || HAS_UBL_AND_CURVES
   /**
    * rx, ry, rz - Cartesian positions in mm
    *              Leveled XYZ on completion
    */
@@ -1940,21 +1940,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       #elif CORE_IS_YZ
         sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
       #else
         sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS])
       #endif
     );
   }
   else
     block->millimeters = millimeters;
 
-  const float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
+  const float inverse_millimeters = 1.0f / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate inverse time for this move. No divide by zero due to previous checks.
   // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   float inverse_secs = fr_mm_s * inverse_millimeters;
 
   // Get the number of non busy movements in queue (non busy means that they can be altered)
   const uint8_t moves_queued = nonbusy_movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
@@ -2291,41 +2291,41 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
       vmax_junction_sqr = 0;
 
     COPY(previous_unit_vec, unit_vec);
 
   #else // Classic Jerk Limiting
 
     /**
      * Adapted from Pr≈Ø≈°a MKS firmware
      * https://github.com/prusa3d/Prusa-Firmware
-     *
-     * Start with a safe speed (from which the machine may halt to stop immediately).
      */
+    const float nominal_speed = SQRT(block->nominal_speed_sqr);
 
     // Exit speed limited by a jerk to full halt of a previous last segment
     static float previous_safe_speed;
 
-    const float nominal_speed = SQRT(block->nominal_speed_sqr);
+    // Start with a safe speed (from which the machine may halt to stop immediately).
     float safe_speed = nominal_speed;
 
     uint8_t limited = 0;
     LOOP_XYZE(i) {
-      const float jerk = ABS(current_speed[i]), maxj = max_jerk[i];
-      if (jerk > maxj) {
-        if (limited) {
-          const float mjerk = maxj * nominal_speed;
-          if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk;
+      const float jerk = ABS(current_speed[i]),   // cs : Starting from zero, change in speed for this axis
+                  maxj = max_jerk[i];             // mj : The max jerk setting for this axis
+      if (jerk > maxj) {                          // cs > mj : New current speed too fast?
+        if (limited) {                            // limited already?
+          const float mjerk = nominal_speed * maxj; // ns*mj
+          if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk; // ns*mj/cs
         }
         else {
-          ++limited;
-          safe_speed = maxj;
+          safe_speed *= maxj / jerk;              // Initial limit: ns*mj/cs
+          ++limited;                              // Initially limited
         }
       }
     }
 
     float vmax_junction;
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
       // Estimate a maximum velocity allowed at a joint of two successive segments.
       // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
       // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
 
@@ -2613,21 +2613,21 @@ void Planner::reset_acceleration_rates() {
     if (AXIS_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   }
   cutoff_long = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
   #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
     recalculate_max_e_jerk();
   #endif
 }
 
 // Recalculate position, steps_to_mm if axis_steps_per_mm changes!
 void Planner::refresh_positioning() {
-  LOOP_XYZE_N(i) steps_to_mm[i] = 1.0 / axis_steps_per_mm[i];
+  LOOP_XYZE_N(i) steps_to_mm[i] = 1.0f / axis_steps_per_mm[i];
   set_position_mm_kinematic(current_position);
   reset_acceleration_rates();
 }
 
 #if ENABLED(AUTOTEMP)
 
   void Planner::autotemp_M104_M109() {
     if ((autotemp_enabled = parser.seen('F'))) autotemp_factor = parser.value_float();
     if (parser.seen('S')) autotemp_min = parser.value_celsius();
     if (parser.seen('B')) autotemp_max = parser.value_celsius();

commit fbdbe5329041bb018317d498bd22f6c5dbc2963a
Author: Eyal <eyalsoha@gmail.com>
Date:   Wed Jul 25 09:58:40 2018 +0300

    Fix get_period_inverse(0) so it doesn't crash (#11334)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ed69d729fa..22fda4ab98 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -687,21 +687,23 @@ void Planner::init() {
         : "r0", "r1", "cc"
       );
 
       // Return the result
       return r11 | (uint16_t(r12) << 8) | (uint32_t(r13) << 16);
     }
   #else
     // All other 32-bit MPUs can easily do inverse using hardware division,
     // so we don't need to reduce precision or to use assembly language at all.
     // This routine, for all other archs, returns 0x100000000 / d ~= 0xFFFFFFFF / d
-    static FORCE_INLINE uint32_t get_period_inverse(const uint32_t d) { return 0xFFFFFFFF / d; }
+    static FORCE_INLINE uint32_t get_period_inverse(const uint32_t d) {
+      return d ? 0xFFFFFFFF / d : 0xFFFFFFFF;
+    }
   #endif
 #endif
 
 #define MINIMAL_STEP_RATE 120
 
 /**
  * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
  * by the provided factors.
  **
  * ############ VERY IMPORTANT ############

commit 63f4c9bdb923d8ec4d11f9b261ebed88d192274a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 6 20:41:08 2018 -0500

    Followup to float maths patch

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ccac328e4e..ed69d729fa 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1310,21 +1310,21 @@ void Planner::check_axes_activity() {
 }
 
 #if DISABLED(NO_VOLUMETRICS)
 
   /**
    * Get a volumetric multiplier from a filament diameter.
    * This is the reciprocal of the circular cross-section area.
    * Return 1.0 with volumetric off or a diameter of 0.0.
    */
   inline float calculate_volumetric_multiplier(const float &diameter) {
-    return (parser.volumetric_enabled && diameter) ? RECIPROCAL(CIRCLE_AREA(diameter * 0.5f)) : 1;
+    return (parser.volumetric_enabled && diameter) ? 1.0f / CIRCLE_AREA(diameter * 0.5f) : 1;
   }
 
   /**
    * Convert the filament sizes into volumetric multipliers.
    * The multiplier converts a given E value into a length.
    */
   void Planner::calculate_volumetric_multipliers() {
     for (uint8_t i = 0; i < COUNT(filament_size); i++) {
       volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
       refresh_e_factor(i);

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7da5403c6b..ccac328e4e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -143,25 +143,25 @@ float Planner::max_feedrate_mm_s[XYZE_N],     // (mm/s) M203 XYZE - Max speeds
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
   #define _EINDEX (E_AXIS + active_extruder)
 #else
   #define _EINDEX E_AXIS
 #endif
 
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
 
-float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0); // The flow percentage and volumetric multiplier combine to scale E movement
+float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0f); // The flow percentage and volumetric multiplier combine to scale E movement
 
 #if DISABLED(NO_VOLUMETRICS)
   float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
-        Planner::volumetric_area_nominal = CIRCLE_AREA((DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5), // Nominal cross-sectional area
+        Planner::volumetric_area_nominal = CIRCLE_AREA((float(DEFAULT_NOMINAL_FILAMENT_DIA)) * 0.5f), // Nominal cross-sectional area
         Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
 #endif
 
 #if HAS_LEVELING
   bool Planner::leveling_active = false; // Flag that auto bed leveling is enabled
   #if ABL_PLANAR
     matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
   #endif
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
     float Planner::z_fade_height,      // Initialized by settings.load()
@@ -181,21 +181,21 @@ float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0); // The flow perce
   #if ENABLED(SKEW_CORRECTION_FOR_Z) && ENABLED(SKEW_CORRECTION_GCODE)
     float Planner::xz_skew_factor, Planner::yz_skew_factor;
   #else
     constexpr float Planner::xz_skew_factor, Planner::yz_skew_factor;
   #endif
 #endif
 
 #if ENABLED(AUTOTEMP)
   float Planner::autotemp_max = 250,
         Planner::autotemp_min = 210,
-        Planner::autotemp_factor = 0.1;
+        Planner::autotemp_factor = 0.1f;
   bool Planner::autotemp_enabled = false;
 #endif
 
 // private:
 
 int32_t Planner::position[NUM_AXIS] = { 0 };
 
 uint32_t Planner::cutoff_long;
 
 float Planner::previous_speed[NUM_AXIS],
@@ -229,21 +229,21 @@ float Planner::previous_speed[NUM_AXIS],
  */
 
 Planner::Planner() { init(); }
 
 void Planner::init() {
   ZERO(position);
   #if HAS_POSITION_FLOAT
     ZERO(position_float);
   #endif
   ZERO(previous_speed);
-  previous_nominal_speed_sqr = 0.0;
+  previous_nominal_speed_sqr = 0;
   #if ABL_PLANAR
     bed_level_matrix.set_to_identity();
   #endif
   clear_block_buffer();
   delay_before_delivering = 0;
 }
 
 #if ENABLED(S_CURVE_ACCELERATION)
 
   #ifdef __AVR__
@@ -852,21 +852,21 @@ void Planner::reverse_pass_kernel(block_t* const current, const block_t * const
       // If nominal length true, max junction speed is guaranteed to be reached.
       // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
       // the current block and next block junction speeds are guaranteed to always be at their maximum
       // junction speeds in deceleration and acceleration, respectively. This is due to how the current
       // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
       // the reverse and forward planners, the corresponding block junction speed will always be at the
       // the maximum junction speed and may always be ignored for any speed reduction checks.
 
       const float new_entry_speed_sqr = TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH)
         ? max_entry_speed_sqr
-        : MIN(max_entry_speed_sqr, max_allowable_speed_sqr(-current->acceleration, next ? next->entry_speed_sqr : sq(MINIMUM_PLANNER_SPEED), current->millimeters));
+        : MIN(max_entry_speed_sqr, max_allowable_speed_sqr(-current->acceleration, next ? next->entry_speed_sqr : sq(float(MINIMUM_PLANNER_SPEED)), current->millimeters));
       if (current->entry_speed_sqr != new_entry_speed_sqr) {
 
         // Need to recalculate the block speed - Mark it now, so the stepper
         // ISR does not consume the block before being recalculated
         SBI(current->flag, BLOCK_BIT_RECALCULATE);
 
         // But there is an inherent race condition here, as the block may have
         // become BUSY just before being marked RECALCULATE, so check for that!
         if (stepper.is_block_busy(current)) {
           // Block became busy. Clear the RECALCULATE flag (no point in
@@ -1069,21 +1069,21 @@ void Planner::recalculate_trapezoids() {
           SBI(current->flag, BLOCK_BIT_RECALCULATE);
 
           // But there is an inherent race condition here, as the block maybe
           // became BUSY, just before it was marked as RECALCULATE, so check
           // if that is the case!
           if (!stepper.is_block_busy(current)) {
             // Block is not BUSY, we won the race against the Stepper ISR:
 
             // NOTE: Entry and exit factors always > 0 by all previous logic operations.
             const float current_nominal_speed = SQRT(current->nominal_speed_sqr),
-                        nomr = 1.0 / current_nominal_speed;
+                        nomr = 1.0f / current_nominal_speed;
             calculate_trapezoid_for_block(current, current_entry_speed * nomr, next_entry_speed * nomr);
             #if ENABLED(LIN_ADVANCE)
               if (current->use_advance_lead) {
                 const float comp = current->e_D_ratio * extruder_advance_K * axis_steps_per_mm[E_AXIS];
                 current->max_adv_steps = current_nominal_speed * comp;
                 current->final_adv_steps = next_entry_speed * comp;
               }
             #endif
           }
 
@@ -1108,22 +1108,22 @@ void Planner::recalculate_trapezoids() {
     // marked as RECALCULATE yet. That's the reason for the following line.
     SBI(next->flag, BLOCK_BIT_RECALCULATE);
 
     // But there is an inherent race condition here, as the block maybe
     // became BUSY, just before it was marked as RECALCULATE, so check
     // if that is the case!
     if (!stepper.is_block_busy(current)) {
       // Block is not BUSY, we won the race against the Stepper ISR:
 
       const float next_nominal_speed = SQRT(next->nominal_speed_sqr),
-                  nomr = 1.0 / next_nominal_speed;
-      calculate_trapezoid_for_block(next, next_entry_speed * nomr, (MINIMUM_PLANNER_SPEED) * nomr);
+                  nomr = 1.0f / next_nominal_speed;
+      calculate_trapezoid_for_block(next, next_entry_speed * nomr, float(MINIMUM_PLANNER_SPEED) * nomr);
       #if ENABLED(LIN_ADVANCE)
         if (next->use_advance_lead) {
           const float comp = next->e_D_ratio * extruder_advance_K * axis_steps_per_mm[E_AXIS];
           next->max_adv_steps = next_nominal_speed * comp;
           next->final_adv_steps = (MINIMUM_PLANNER_SPEED) * comp;
         }
       #endif
     }
 
     // Reset next only to ensure its trapezoid is computed - The stepper is free to use
@@ -1155,21 +1155,21 @@ void Planner::recalculate() {
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block_t* block = &block_buffer[b];
       if (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS]) {
         const float se = (float)block->steps[E_AXIS] / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;
         NOLESS(high, se);
       }
     }
 
     float t = autotemp_min + high * autotemp_factor;
     t = constrain(t, autotemp_min, autotemp_max);
-    if (t < oldt) t = t * (1 - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
+    if (t < oldt) t = t * (1 - float(AUTOTEMP_OLDWEIGHT)) + oldt * float(AUTOTEMP_OLDWEIGHT);
     oldt = t;
     thermalManager.setTargetHotend(t, 0);
   }
 
 #endif // AUTOTEMP
 
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
@@ -1310,21 +1310,21 @@ void Planner::check_axes_activity() {
 }
 
 #if DISABLED(NO_VOLUMETRICS)
 
   /**
    * Get a volumetric multiplier from a filament diameter.
    * This is the reciprocal of the circular cross-section area.
    * Return 1.0 with volumetric off or a diameter of 0.0.
    */
   inline float calculate_volumetric_multiplier(const float &diameter) {
-    return (parser.volumetric_enabled && diameter) ? 1.0 / CIRCLE_AREA(diameter * 0.5) : 1.0;
+    return (parser.volumetric_enabled && diameter) ? RECIPROCAL(CIRCLE_AREA(diameter * 0.5f)) : 1;
   }
 
   /**
    * Convert the filament sizes into volumetric multipliers.
    * The multiplier converts a given E value into a length.
    */
   void Planner::calculate_volumetric_multipliers() {
     for (uint8_t i = 0; i < COUNT(filament_size); i++) {
       volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
       refresh_e_factor(i);
@@ -1334,25 +1334,25 @@ void Planner::check_axes_activity() {
 #endif // !NO_VOLUMETRICS
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   /**
    * Convert the ratio value given by the filament width sensor
    * into a volumetric multiplier. Conversion differs when using
    * linear extrusion vs volumetric extrusion.
    */
   void Planner::calculate_volumetric_for_width_sensor(const int8_t encoded_ratio) {
     // Reconstitute the nominal/measured ratio
-    const float nom_meas_ratio = 1.0 + 0.01 * encoded_ratio,
+    const float nom_meas_ratio = 1 + 0.01f * encoded_ratio,
                 ratio_2 = sq(nom_meas_ratio);
 
     volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = parser.volumetric_enabled
-      ? ratio_2 / CIRCLE_AREA(filament_width_nominal * 0.5) // Volumetric uses a true volumetric multiplier
+      ? ratio_2 / CIRCLE_AREA(filament_width_nominal * 0.5f) // Volumetric uses a true volumetric multiplier
       : ratio_2;                                            // Linear squares the ratio, which scales the volume
 
     refresh_e_factor(FILAMENT_SENSOR_EXTRUDER_NUM);
   }
 #endif
 
 #if PLANNER_LEVELING || HAS_UBL_AND_CURVES
   /**
    * rx, ry, rz - Cartesian positions in mm
    *              Leveled XYZ on completion
@@ -1683,21 +1683,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
     if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
   #else
     if (da < 0) SBI(dm, X_AXIS);
     if (db < 0) SBI(dm, Y_AXIS);
     if (dc < 0) SBI(dm, Z_AXIS);
   #endif
   if (de < 0) SBI(dm, E_AXIS);
 
   const float esteps_float = de * e_factor[extruder];
-  const uint32_t esteps = ABS(esteps_float) + 0.5;
+  const uint32_t esteps = ABS(esteps_float) + 0.5f;
 
   // Clear all flags, including the "busy" bit
   block->flag = 0x00;
 
   // Set direction bits
   block->direction_bits = dm;
 
   // Number of steps for each axis
   // See http://www.corexy.com/theory.html
   #if CORE_IS_XY
@@ -1950,29 +1950,29 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   // Calculate inverse time for this move. No divide by zero due to previous checks.
   // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   float inverse_secs = fr_mm_s * inverse_millimeters;
 
   // Get the number of non busy movements in queue (non busy means that they can be altered)
   const uint8_t moves_queued = nonbusy_movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time im micro seconds
-    uint32_t segment_time_us = LROUND(1000000.0 / inverse_secs);
+    uint32_t segment_time_us = LROUND(1000000.0f / inverse_secs);
   #endif
 
   #if ENABLED(SLOWDOWN)
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
       if (segment_time_us < min_segment_time_us) {
         // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
         const uint32_t nst = segment_time_us + LROUND(2 * (min_segment_time_us - segment_time_us) / moves_queued);
-        inverse_secs = 1000000.0 / nst;
+        inverse_secs = 1000000.0f / nst;
         #if defined(XY_FREQUENCY_LIMIT) || ENABLED(ULTRA_LCD)
           segment_time_us = nst;
         #endif
       }
     }
   #endif
 
   #if ENABLED(ULTRA_LCD)
     // Protect the access to the position.
     const bool was_enabled = STEPPER_ISR_ENABLED();
@@ -1998,37 +1998,37 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       filwidth_e_count += delta_mm[E_AXIS];
       filwidth_delay_dist += delta_mm[E_AXIS];
 
       // Only get new measurements on forward E movement
       if (!UNEAR_ZERO(filwidth_e_count)) {
 
         // Loop the delay distance counter (modulus by the mm length)
         while (filwidth_delay_dist >= MMD_MM) filwidth_delay_dist -= MMD_MM;
 
         // Convert into an index into the measurement array
-        filwidth_delay_index[0] = int8_t(filwidth_delay_dist * 0.1);
+        filwidth_delay_index[0] = int8_t(filwidth_delay_dist * 0.1f);
 
         // If the index has changed (must have gone forward)...
         if (filwidth_delay_index[0] != filwidth_delay_index[1]) {
           filwidth_e_count = 0; // Reset the E movement counter
           const int8_t meas_sample = thermalManager.widthFil_to_size_ratio();
           do {
             filwidth_delay_index[1] = (filwidth_delay_index[1] + 1) % MMD_CM; // The next unused slot
             measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
           } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
         }
       }
     }
   #endif
 
   // Calculate and limit speed in mm/sec for each axis
-  float current_speed[NUM_AXIS], speed_factor = 1.0; // factor <1 decreases speed
+  float current_speed[NUM_AXIS], speed_factor = 1.0f; // factor <1 decreases speed
   LOOP_XYZE(i) {
     const float cs = ABS((current_speed[i] = delta_mm[i] * inverse_secs));
     #if ENABLED(DISTINCT_E_FACTORS)
       if (i == E_AXIS) i += extruder;
     #endif
     if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
   }
 
   // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT
@@ -2062,21 +2062,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     const uint32_t max_x_segment_time = MAX3(xs0, xs1, xs2),
                    max_y_segment_time = MAX3(ys0, ys1, ys2),
                    min_xy_segment_time = MIN(max_x_segment_time, max_y_segment_time);
     if (min_xy_segment_time < MAX_FREQ_TIME_US) {
       const float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME_US);
       NOMORE(speed_factor, low_sf);
     }
   #endif // XY_FREQUENCY_LIMIT
 
   // Correct the speed
-  if (speed_factor < 1.0) {
+  if (speed_factor < 1.0f) {
     LOOP_XYZE(i) current_speed[i] *= speed_factor;
     block->nominal_rate *= speed_factor;
     block->nominal_speed_sqr = block->nominal_speed_sqr * sq(speed_factor);
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
   if (!block->steps[A_AXIS] && !block->steps[B_AXIS] && !block->steps[C_AXIS]) {
     // convert to: acceleration steps/sec^2
@@ -2135,21 +2135,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
             block->millimeters
           #else
             SQRT(sq(target_float[X_AXIS] - position_float[X_AXIS])
                + sq(target_float[Y_AXIS] - position_float[Y_AXIS])
                + sq(target_float[Z_AXIS] - position_float[Z_AXIS]))
           #endif
         ;
 
         // Check for unusual high e_D ratio to detect if a retract move was combined with the last print move due to min. steps per segment. Never execute this with advance!
         // This assumes no one will use a retract length of 0mm < retr_length < ~0.2mm and no one will print 100mm wide lines using 3mm filament or 35mm wide lines using 1.75mm filament.
-        if (block->e_D_ratio > 3.0)
+        if (block->e_D_ratio > 3.0f)
           block->use_advance_lead = false;
         else {
           const uint32_t max_accel_steps_per_s2 = MAX_E_JERK / (extruder_advance_K * block->e_D_ratio) * steps_per_mm;
           #if ENABLED(LA_DEBUG)
             if (accel > max_accel_steps_per_s2) SERIAL_ECHOLNPGM("Acceleration limited.");
           #endif
           NOMORE(accel, max_accel_steps_per_s2);
         }
       }
     #endif
@@ -2170,21 +2170,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     else {
       LIMIT_ACCEL_FLOAT(A_AXIS, 0);
       LIMIT_ACCEL_FLOAT(B_AXIS, 0);
       LIMIT_ACCEL_FLOAT(C_AXIS, 0);
       LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
-    block->acceleration_rate = (uint32_t)(accel * (4096.0 * 4096.0 / (STEPPER_TIMER_RATE)));
+    block->acceleration_rate = (uint32_t)(accel * (4096.0f * 4096.0f / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
       block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K * block->e_D_ratio * block->acceleration * axis_steps_per_mm[E_AXIS_N]);
       #if ENABLED(LA_DEBUG)
         if (extruder_advance_K * block->e_D_ratio * block->acceleration * 2 < SQRT(block->nominal_speed_sqr) * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif
@@ -2243,58 +2243,58 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
       float junction_cos_theta = -previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
                                  -previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
                                  -previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS]
                                  -previous_unit_vec[E_AXIS] * unit_vec[E_AXIS]
                                 ;
 
       // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
-      if (junction_cos_theta > 0.999999) {
+      if (junction_cos_theta > 0.999999f) {
         // For a 0 degree acute junction, just set minimum junction speed.
-        vmax_junction_sqr = sq(MINIMUM_PLANNER_SPEED);
+        vmax_junction_sqr = sq(float(MINIMUM_PLANNER_SPEED));
       }
       else {
-        NOLESS(junction_cos_theta, -0.999999); // Check for numerical round-off to avoid divide by zero.
+        NOLESS(junction_cos_theta, -0.999999f); // Check for numerical round-off to avoid divide by zero.
 
         // Convert delta vector to unit vector
         float junction_unit_vec[XYZE] = {
           unit_vec[X_AXIS] - previous_unit_vec[X_AXIS],
           unit_vec[Y_AXIS] - previous_unit_vec[Y_AXIS],
           unit_vec[Z_AXIS] - previous_unit_vec[Z_AXIS],
           unit_vec[E_AXIS] - previous_unit_vec[E_AXIS]
         };
         normalize_junction_vector(junction_unit_vec);
 
         const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec),
-                    sin_theta_d2 = SQRT(0.5 * (1.0 - junction_cos_theta)); // Trig half angle identity. Always positive.
+                    sin_theta_d2 = SQRT(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
 
-        vmax_junction_sqr = (junction_acceleration * junction_deviation_mm * sin_theta_d2) / (1.0 - sin_theta_d2);
-        if (block->millimeters < 1.0) {
+        vmax_junction_sqr = (junction_acceleration * junction_deviation_mm * sin_theta_d2) / (1.0f - sin_theta_d2);
+        if (block->millimeters < 1) {
 
           // Fast acos approximation, minus the error bar to be safe
-          const float junction_theta = (RADIANS(-40) * sq(junction_cos_theta) - RADIANS(50)) * junction_cos_theta + RADIANS(90) - 0.18;
+          const float junction_theta = (RADIANS(-40) * sq(junction_cos_theta) - RADIANS(50)) * junction_cos_theta + RADIANS(90) - 0.18f;
 
           // If angle is greater than 135 degrees (octagon), find speed for approximate arc
           if (junction_theta > RADIANS(135)) {
             const float limit_sqr = block->millimeters / (RADIANS(180) - junction_theta) * junction_acceleration;
             NOMORE(vmax_junction_sqr, limit_sqr);
           }
         }
       }
 
       // Get the lowest speed
       vmax_junction_sqr = MIN3(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
-      vmax_junction_sqr = 0.0;
+      vmax_junction_sqr = 0;
 
     COPY(previous_unit_vec, unit_vec);
 
   #else // Classic Jerk Limiting
 
     /**
      * Adapted from Pr≈Ø≈°a MKS firmware
      * https://github.com/prusa3d/Prusa-Firmware
      *
      * Start with a safe speed (from which the machine may halt to stop immediately).
@@ -2371,25 +2371,25 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
 
     previous_safe_speed = safe_speed;
     vmax_junction_sqr = sq(vmax_junction);
 
   #endif // Classic Jerk Limiting
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed_sqr = vmax_junction_sqr;
 
   // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
-  const float v_allowable_sqr = max_allowable_speed_sqr(-block->acceleration, sq(MINIMUM_PLANNER_SPEED), block->millimeters);
+  const float v_allowable_sqr = max_allowable_speed_sqr(-block->acceleration, sq(float(MINIMUM_PLANNER_SPEED)), block->millimeters);
 
   // If we are trying to add a split block, start with the
   // max. allowed speed to avoid an interrupted first move.
-  block->entry_speed_sqr = !split_move ? sq(MINIMUM_PLANNER_SPEED) : MIN(vmax_junction_sqr, v_allowable_sqr);
+  block->entry_speed_sqr = !split_move ? sq(float(MINIMUM_PLANNER_SPEED)) : MIN(vmax_junction_sqr, v_allowable_sqr);
 
   // Initialize planner efficiency flags
   // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
   // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
   // the current block and next block junction speeds are guaranteed to always be at their maximum
   // junction speeds in deceleration and acceleration, respectively. This is due to how the current
   // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
   block->flag |= block->nominal_speed_sqr <= v_allowable_sqr ? BLOCK_FLAG_RECALCULATE | BLOCK_FLAG_NOMINAL_LENGTH : BLOCK_FLAG_RECALCULATE;

commit 8eaac0dab37b4376ac06f1fefd469cdd6bc80673
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 30 13:44:27 2018 -0500

    Add delta feedrate scaling (#11153)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 4152d2e0d6..7da5403c6b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1560,23 +1560,23 @@ bool Planner::_buffer_steps(const int32_t (&target)[XYZE]
 
   // If we are cleaning, do not accept queuing of movements
   if (cleaning_buffer_counter) return false;
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Fill the block with the specified movement
   if (!_populate_block(block, false, target
-  #if HAS_POSITION_FLOAT
-    , target_float
-  #endif
+    #if HAS_POSITION_FLOAT
+      , target_float
+    #endif
     , fr_mm_s, extruder, millimeters
   )) {
     // Movement was not queued, probably because it was too short.
     //  Simply accept that as movement queued and done
     return true;
   }
 
   // If this is the first added movement, reload the delay, otherwise, cancel it.
   if (block_buffer_head == block_buffer_tail) {
     // If it was the first queued block, restart the 1st block delivery delay, to

commit bd7f5848f1a87b5db4709178bf1024de8aff694e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 29 22:42:05 2018 -0500

    Remove JUNCTION_DEVIATION_INCLUDE_E option (#11147)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 20e4410ce9..4152d2e0d6 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2223,66 +2223,54 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
      *
      * hoffbaked: on May 10 2018 tuned and improved the GRBL algorithm for Marlin:
           Okay! It seems to be working good. I somewhat arbitrarily cut it off at 1mm
           on then on anything with less sides than an octagon. With this, and the
           reverse pass actually recalculating things, a corner acceleration value
           of 1000 junction deviation of .05 are pretty reasonable. If the cycles
           can be spared, a better acos could be used. For all I know, it may be
           already calculated in a different place. */
 
     // Unit vector of previous path line segment
-    static float previous_unit_vec[
-      #if ENABLED(JUNCTION_DEVIATION_INCLUDE_E)
-        XYZE
-      #else
-        XYZ
-      #endif
-    ];
+    static float previous_unit_vec[XYZE];
 
     float unit_vec[] = {
       delta_mm[A_AXIS] * inverse_millimeters,
       delta_mm[B_AXIS] * inverse_millimeters,
-      delta_mm[C_AXIS] * inverse_millimeters
-      #if ENABLED(JUNCTION_DEVIATION_INCLUDE_E)
-        , delta_mm[E_AXIS] * inverse_millimeters
-      #endif
+      delta_mm[C_AXIS] * inverse_millimeters,
+      delta_mm[E_AXIS] * inverse_millimeters
     };
 
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
       float junction_cos_theta = -previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
                                  -previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
                                  -previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS]
-                                  #if ENABLED(JUNCTION_DEVIATION_INCLUDE_E)
-                                    -previous_unit_vec[E_AXIS] * unit_vec[E_AXIS]
-                                  #endif
+                                 -previous_unit_vec[E_AXIS] * unit_vec[E_AXIS]
                                 ;
 
       // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
       if (junction_cos_theta > 0.999999) {
         // For a 0 degree acute junction, just set minimum junction speed.
         vmax_junction_sqr = sq(MINIMUM_PLANNER_SPEED);
       }
       else {
         NOLESS(junction_cos_theta, -0.999999); // Check for numerical round-off to avoid divide by zero.
 
-        float junction_unit_vec[JD_AXES] = {
+        // Convert delta vector to unit vector
+        float junction_unit_vec[XYZE] = {
           unit_vec[X_AXIS] - previous_unit_vec[X_AXIS],
           unit_vec[Y_AXIS] - previous_unit_vec[Y_AXIS],
-          unit_vec[Z_AXIS] - previous_unit_vec[Z_AXIS]
-          #if ENABLED(JUNCTION_DEVIATION_INCLUDE_E)
-            , unit_vec[E_AXIS] - previous_unit_vec[E_AXIS]
-          #endif
+          unit_vec[Z_AXIS] - previous_unit_vec[Z_AXIS],
+          unit_vec[E_AXIS] - previous_unit_vec[E_AXIS]
         };
-        // Convert delta vector to unit vector
         normalize_junction_vector(junction_unit_vec);
 
         const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec),
                     sin_theta_d2 = SQRT(0.5 * (1.0 - junction_cos_theta)); // Trig half angle identity. Always positive.
 
         vmax_junction_sqr = (junction_acceleration * junction_deviation_mm * sin_theta_d2) / (1.0 - sin_theta_d2);
         if (block->millimeters < 1.0) {
 
           // Fast acos approximation, minus the error bar to be safe
           const float junction_theta = (RADIANS(-40) * sq(junction_cos_theta) - RADIANS(50)) * junction_cos_theta + RADIANS(90) - 0.18;

commit edb21f349ad18d2948ff6c313c6d43132bad5118
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Wed Jun 27 20:11:16 2018 -0300

    Fix stepper/planner block handling, race conditions (#11098)
    
    - Allow planner to alter the deceleration phase of the currently executing block.
    - Remove BUSY flag, as it is NON ATOMIC to set bits in the Stepper ISR and Planner at the same time.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e9e9b6393c..20e4410ce9 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -97,25 +97,26 @@
 #define BLOCK_DELAY_FOR_1ST_MOVE 100
 
 Planner planner;
 
   // public:
 
 /**
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
-volatile uint8_t Planner::block_buffer_head,  // Index of the next block to be pushed
-                 Planner::block_buffer_tail;  // Index of the busy block, if any
-uint16_t Planner::cleaning_buffer_counter;    // A counter to disable queuing of blocks
-uint8_t Planner::delay_before_delivering,     // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
-        Planner::block_buffer_planned;        // Index of the optimally planned block
+volatile uint8_t Planner::block_buffer_head,    // Index of the next block to be pushed
+                 Planner::block_buffer_nonbusy, // Index of the first non-busy block
+                 Planner::block_buffer_planned, // Index of the optimally planned block
+                 Planner::block_buffer_tail;    // Index of the busy block, if any
+uint16_t Planner::cleaning_buffer_counter;      // A counter to disable queuing of blocks
+uint8_t Planner::delay_before_delivering;       // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
 uint32_t Planner::max_acceleration_mm_per_s2[XYZE_N],    // (mm/s^2) M201 XYZE
          Planner::max_acceleration_steps_per_s2[XYZE_N], // (steps/s^2) Derived from mm_per_s2
          Planner::min_segment_time_us;                   // (¬µs) M205 B
 
 float Planner::max_feedrate_mm_s[XYZE_N],     // (mm/s) M203 XYZE - Max speeds
       Planner::axis_steps_per_mm[XYZE_N],     // (steps) M92 XYZE - Steps per millimeter
       Planner::steps_to_mm[XYZE_N],           // (mm) Millimeters per step
       Planner::min_feedrate_mm_s,             // (mm/s) M205 S - Minimum linear feedrate
       Planner::acceleration,                  // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
@@ -233,21 +234,20 @@ void Planner::init() {
   ZERO(position);
   #if HAS_POSITION_FLOAT
     ZERO(position_float);
   #endif
   ZERO(previous_speed);
   previous_nominal_speed_sqr = 0.0;
   #if ABL_PLANAR
     bed_level_matrix.set_to_identity();
   #endif
   clear_block_buffer();
-  block_buffer_planned = 0;
   delay_before_delivering = 0;
 }
 
 #if ENABLED(S_CURVE_ACCELERATION)
 
   #ifdef __AVR__
     /**
      * This routine returns 0x1000000 / d, getting the inverse as fast as possible.
      * A fast-converging iterative Newton-Raphson method can reach full precision in
      * just 1 iteration, and takes 211 cycles (worst case; the mean case is less, up
@@ -696,20 +696,26 @@ void Planner::init() {
     // This routine, for all other archs, returns 0x100000000 / d ~= 0xFFFFFFFF / d
     static FORCE_INLINE uint32_t get_period_inverse(const uint32_t d) { return 0xFFFFFFFF / d; }
   #endif
 #endif
 
 #define MINIMAL_STEP_RATE 120
 
 /**
  * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
  * by the provided factors.
+ **
+ * ############ VERY IMPORTANT ############
+ * NOTE that the PRECONDITION to call this function is that the block is
+ * NOT BUSY and it is marked as RECALCULATE. That WARRANTIES the Stepper ISR
+ * is not and will not use the block while we modify it, so it is safe to
+ * alter its values.
  */
 void Planner::calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor) {
 
   uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
            final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
 
   // Limit minimal step rate (Otherwise the timer will overflow.)
   NOLESS(initial_rate, uint32_t(MINIMAL_STEP_RATE));
   NOLESS(final_rate, uint32_t(MINIMAL_STEP_RATE));
 
@@ -737,57 +743,42 @@ void Planner::calculate_trapezoid_for_block(block_t* const block, const float &e
     #if ENABLED(S_CURVE_ACCELERATION)
       // We won't reach the cruising rate. Let's calculate the speed we will reach
       cruise_rate = final_speed(initial_rate, accel, accelerate_steps);
     #endif
   }
   #if ENABLED(S_CURVE_ACCELERATION)
     else // We have some plateau time, so the cruise rate will be the nominal rate
       cruise_rate = block->nominal_rate;
   #endif
 
-  // block->accelerate_until = accelerate_steps;
-  // block->decelerate_after = accelerate_steps+plateau_steps;
-
   #if ENABLED(S_CURVE_ACCELERATION)
     // Jerk controlled speed requires to express speed versus time, NOT steps
     uint32_t acceleration_time = ((float)(cruise_rate - initial_rate) / accel) * (STEPPER_TIMER_RATE),
              deceleration_time = ((float)(cruise_rate - final_rate) / accel) * (STEPPER_TIMER_RATE);
 
     // And to offload calculations from the ISR, we also calculate the inverse of those times here
     uint32_t acceleration_time_inverse = get_period_inverse(acceleration_time);
     uint32_t deceleration_time_inverse = get_period_inverse(deceleration_time);
-
   #endif
 
-  // Fill variables used by the stepper in a critical section
-  const bool was_enabled = STEPPER_ISR_ENABLED();
-  if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
-
-  // Don't update variables if block is busy; it is being interpreted by the planner.
-  // If this happens, there's a problem... The block speed is inconsistent. Some values
-  // have already been updated, but the Stepper ISR is already using the block. Fortunately,
-  // the values being used by the Stepper ISR weren't touched, so just stop here...
-  // TODO: There may be a way to update a running block, depending on the stepper ISR position.
-  if (!TEST(block->flag, BLOCK_BIT_BUSY)) {
-    block->accelerate_until = accelerate_steps;
-    block->decelerate_after = accelerate_steps + plateau_steps;
-    block->initial_rate = initial_rate;
-    #if ENABLED(S_CURVE_ACCELERATION)
-      block->acceleration_time = acceleration_time;
-      block->deceleration_time = deceleration_time;
-      block->acceleration_time_inverse = acceleration_time_inverse;
-      block->deceleration_time_inverse = deceleration_time_inverse;
-      block->cruise_rate = cruise_rate;
-    #endif
-    block->final_rate = final_rate;
-  }
-  if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+  // Store new block parameters
+  block->accelerate_until = accelerate_steps;
+  block->decelerate_after = accelerate_steps + plateau_steps;
+  block->initial_rate = initial_rate;
+  #if ENABLED(S_CURVE_ACCELERATION)
+    block->acceleration_time = acceleration_time;
+    block->deceleration_time = deceleration_time;
+    block->acceleration_time_inverse = acceleration_time_inverse;
+    block->deceleration_time_inverse = deceleration_time_inverse;
+    block->cruise_rate = cruise_rate;
+  #endif
+  block->final_rate = final_rate;
 }
 
 /*                            PLANNER SPEED DEFINITION
                                      +--------+   <- current->nominal_speed
                                     /          \
          current->entry_speed ->   +            \
                                    |             + <- next->entry_speed (aka exit speed)
                                    +-------------+
                                        time -->
 
@@ -824,21 +815,21 @@ void Planner::calculate_trapezoid_for_block(block_t* const block, const float &e
   recomputed as stated in the general guidelines.
 
   Planner buffer index mapping:
   - block_buffer_tail: Points to the beginning of the planner buffer. First to be executed or being executed.
   - block_buffer_head: Points to the buffer block after the last block in the buffer. Used to indicate whether
       the buffer is full or empty. As described for standard ring buffers, this block is always empty.
   - block_buffer_planned: Points to the first buffer block after the last optimally planned block for normal
       streaming operating conditions. Use for planning optimizations by avoiding recomputing parts of the
       planner buffer that don't change with the addition of a new block, as describe above. In addition,
       this block can never be less than block_buffer_tail and will always be pushed forward and maintain
-      this requirement when encountered by the plan_discard_current_block() routine during a cycle.
+      this requirement when encountered by the Planner::discard_current_block() routine during a cycle.
 
   NOTE: Since the planner only computes on what's in the planner buffer, some motions with lots of short
   line segments, like G2/3 arcs or complex curves, may seem to move slow. This is because there simply isn't
   enough combined distance traveled in the entire buffer to accelerate up to the nominal speed and then
   decelerate to a complete stop at the end of the buffer, as stated by the guidelines. If this happens and
   becomes an annoyance, there are a few simple solutions: (1) Maximize the machine acceleration. The planner
   will be able to compute higher velocity profiles within the same combined distance. (2) Maximize line
   motion(s) distance per block to a desired tolerance. The more combined distance the planner has to use,
   the faster it can go. (3) Maximize the planner buffer size. This also will increase the combined distance
   for the planner to compute over. It also increases the number of computations the planner has to perform
@@ -868,22 +859,33 @@ void Planner::reverse_pass_kernel(block_t* const current, const block_t * const
 
       const float new_entry_speed_sqr = TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH)
         ? max_entry_speed_sqr
         : MIN(max_entry_speed_sqr, max_allowable_speed_sqr(-current->acceleration, next ? next->entry_speed_sqr : sq(MINIMUM_PLANNER_SPEED), current->millimeters));
       if (current->entry_speed_sqr != new_entry_speed_sqr) {
 
         // Need to recalculate the block speed - Mark it now, so the stepper
         // ISR does not consume the block before being recalculated
         SBI(current->flag, BLOCK_BIT_RECALCULATE);
 
-        // Set the new entry speed
-        current->entry_speed_sqr = new_entry_speed_sqr;
+        // But there is an inherent race condition here, as the block may have
+        // become BUSY just before being marked RECALCULATE, so check for that!
+        if (stepper.is_block_busy(current)) {
+          // Block became busy. Clear the RECALCULATE flag (no point in
+          // recalculating BUSY blocks). And don't set its speed, as it can't
+          // be updated at this time.
+          CBI(current->flag, BLOCK_BIT_RECALCULATE);
+        }
+        else {
+          // Block is not BUSY so this is ahead of the Stepper ISR:
+          // Just Set the new entry speed.
+          current->entry_speed_sqr = new_entry_speed_sqr;
+        }
       }
     }
   }
 }
 
 /**
  * recalculate() needs to go over the current plan twice.
  * Once in reverse and once forward. This implements the reverse pass.
  */
 void Planner::reverse_pass() {
@@ -895,35 +897,46 @@ void Planner::reverse_pass() {
   uint8_t planned_block_index = block_buffer_planned;
 
   // If there was a race condition and block_buffer_planned was incremented
   //  or was pointing at the head (queue empty) break loop now and avoid
   //  planning already consumed blocks
   if (planned_block_index == block_buffer_head) return;
 
   // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
   // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
   // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
-  block_t *current;
   const block_t *next = NULL;
   while (block_index != planned_block_index) {
 
     // Perform the reverse pass
-    current = &block_buffer[block_index];
+    block_t *current = &block_buffer[block_index];
 
     // Only consider non sync blocks
     if (!TEST(current->flag, BLOCK_BIT_SYNC_POSITION)) {
       reverse_pass_kernel(current, next);
       next = current;
     }
 
     // Advance to the next
     block_index = prev_block_index(block_index);
+
+    // The ISR could advance the block_buffer_planned while we were doing the reverse pass.
+    // We must try to avoid using an already consumed block as the last one - So follow
+    // changes to the pointer and make sure to limit the loop to the currently busy block
+    while (planned_block_index != block_buffer_planned) {
+
+      // If we reached the busy block or an already processed block, break the loop now
+      if (block_index == planned_block_index) return;
+
+      // Advance the pointer, following the busy block
+      planned_block_index = next_block_index(planned_block_index);
+    }
   }
 }
 
 // The kernel called by recalculate() when scanning the plan from first to last entry.
 void Planner::forward_pass_kernel(const block_t* const previous, block_t* const current, const uint8_t block_index) {
   if (previous) {
     // If the previous block is an acceleration block, too short to complete the full speed
     // change, adjust the entry speed accordingly. Entry speeds have already been reset,
     // maximized, and reverse-planned. If nominal length is set, max junction speed is
     // guaranteed to be reached. No need to recheck.
@@ -933,25 +946,38 @@ void Planner::forward_pass_kernel(const block_t* const previous, block_t* const
       // Compute the maximum allowable speed
       const float new_entry_speed_sqr = max_allowable_speed_sqr(-previous->acceleration, previous->entry_speed_sqr, previous->millimeters);
 
       // If true, current block is full-acceleration and we can move the planned pointer forward.
       if (new_entry_speed_sqr < current->entry_speed_sqr) {
 
         // Mark we need to recompute the trapezoidal shape, and do it now,
         // so the stepper ISR does not consume the block before being recalculated
         SBI(current->flag, BLOCK_BIT_RECALCULATE);
 
-        // Always <= max_entry_speed_sqr. Backward pass sets this.
-        current->entry_speed_sqr = new_entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass sets this.
+        // But there is an inherent race condition here, as the block maybe
+        // became BUSY, just before it was marked as RECALCULATE, so check
+        // if that is the case!
+        if (stepper.is_block_busy(current)) {
+          // Block became busy. Clear the RECALCULATE flag (no point in
+          //  recalculating BUSY blocks and don't set its speed, as it can't
+          //  be updated at this time.
+          CBI(current->flag, BLOCK_BIT_RECALCULATE);
+        }
+        else {
+          // Block is not BUSY, we won the race against the Stepper ISR:
+
+          // Always <= max_entry_speed_sqr. Backward pass sets this.
+          current->entry_speed_sqr = new_entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass sets this.
 
-        // Set optimal plan pointer.
-        block_buffer_planned = block_index;
+          // Set optimal plan pointer.
+          block_buffer_planned = block_index;
+        }
       }
     }
 
     // Any block set at its maximum entry speed also creates an optimal plan up to this
     // point in the buffer. When the plan is bracketed by either the beginning of the
     // buffer and a maximum entry speed or two maximum entry speeds, every block in between
     // cannot logically be further improved. Hence, we don't have to recompute them anymore.
     if (current->entry_speed_sqr == current->max_entry_speed_sqr)
       block_buffer_planned = block_index;
   }
@@ -974,55 +1000,60 @@ void Planner::forward_pass() {
 
   block_t *current;
   const block_t * previous = NULL;
   while (block_index != block_buffer_head) {
 
     // Perform the forward pass
     current = &block_buffer[block_index];
 
     // Skip SYNC blocks
     if (!TEST(current->flag, BLOCK_BIT_SYNC_POSITION)) {
-      forward_pass_kernel(previous, current, block_index);
+      // If there's no previous block or the previous block is not
+      // BUSY (thus, modifiable) run the forward_pass_kernel. Otherwise,
+      // the previous block became BUSY, so assume the current block's
+      // entry speed can't be altered (since that would also require
+      // updating the exit speed of the previous block).
+      if (!previous || !stepper.is_block_busy(previous))
+        forward_pass_kernel(previous, current, block_index);
       previous = current;
     }
     // Advance to the previous
     block_index = next_block_index(block_index);
   }
 }
 
 /**
  * Recalculate the trapezoid speed profiles for all blocks in the plan
  * according to the entry_factor for each junction. Must be called by
  * recalculate() after updating the blocks.
  */
 void Planner::recalculate_trapezoids() {
   // The tail may be changed by the ISR so get a local copy.
-  uint8_t block_index = block_buffer_tail;
-
-  // As there could be a sync block in the head of the queue, and the next loop must not
-  // recalculate the head block (as it needs to be specially handled), scan backwards until
-  // we find the first non SYNC block
-  uint8_t head_block_index = block_buffer_head;
+  uint8_t block_index = block_buffer_tail,
+          head_block_index = block_buffer_head;
+  // Since there could be a sync block in the head of the queue, and the
+  // next loop must not recalculate the head block (as it needs to be
+  // specially handled), scan backwards to the first non-SYNC block.
   while (head_block_index != block_index) {
 
     // Go back (head always point to the first free block)
-    uint8_t prev_index = prev_block_index(head_block_index);
+    const uint8_t prev_index = prev_block_index(head_block_index);
 
     // Get the pointer to the block
     block_t *prev = &block_buffer[prev_index];
 
     // If not dealing with a sync block, we are done. The last block is not a SYNC block
     if (!TEST(prev->flag, BLOCK_BIT_SYNC_POSITION)) break;
 
     // Examine the previous block. This and all following are SYNC blocks
     head_block_index = prev_index;
-  };
+  }
 
   // Go from the tail (currently executed block) to the first block, without including it)
   block_t *current = NULL, *next = NULL;
   float current_entry_speed = 0.0, next_entry_speed = 0.0;
   while (block_index != head_block_index) {
 
     next = &block_buffer[block_index];
 
     // Skip sync blocks
     if (!TEST(next->flag, BLOCK_BIT_SYNC_POSITION)) {
@@ -1030,31 +1061,38 @@ void Planner::recalculate_trapezoids() {
 
       if (current) {
         // Recalculate if current block entry or exit junction speed has changed.
         if (TEST(current->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
 
           // Mark the current block as RECALCULATE, to protect it from the Stepper ISR running it.
           // Note that due to the above condition, there's a chance the current block isn't marked as
           // RECALCULATE yet, but the next one is. That's the reason for the following line.
           SBI(current->flag, BLOCK_BIT_RECALCULATE);
 
-          // NOTE: Entry and exit factors always > 0 by all previous logic operations.
-          const float current_nominal_speed = SQRT(current->nominal_speed_sqr),
-                      nomr = 1.0 / current_nominal_speed;
-          calculate_trapezoid_for_block(current, current_entry_speed * nomr, next_entry_speed * nomr);
-          #if ENABLED(LIN_ADVANCE)
-            if (current->use_advance_lead) {
-              const float comp = current->e_D_ratio * extruder_advance_K * axis_steps_per_mm[E_AXIS];
-              current->max_adv_steps = current_nominal_speed * comp;
-              current->final_adv_steps = next_entry_speed * comp;
-            }
-          #endif
+          // But there is an inherent race condition here, as the block maybe
+          // became BUSY, just before it was marked as RECALCULATE, so check
+          // if that is the case!
+          if (!stepper.is_block_busy(current)) {
+            // Block is not BUSY, we won the race against the Stepper ISR:
+
+            // NOTE: Entry and exit factors always > 0 by all previous logic operations.
+            const float current_nominal_speed = SQRT(current->nominal_speed_sqr),
+                        nomr = 1.0 / current_nominal_speed;
+            calculate_trapezoid_for_block(current, current_entry_speed * nomr, next_entry_speed * nomr);
+            #if ENABLED(LIN_ADVANCE)
+              if (current->use_advance_lead) {
+                const float comp = current->e_D_ratio * extruder_advance_K * axis_steps_per_mm[E_AXIS];
+                current->max_adv_steps = current_nominal_speed * comp;
+                current->final_adv_steps = next_entry_speed * comp;
+              }
+            #endif
+          }
 
           // Reset current only to ensure next trapezoid is computed - The
           // stepper is free to use the block from now on.
           CBI(current->flag, BLOCK_BIT_RECALCULATE);
         }
       }
 
       current = next;
       current_entry_speed = next_entry_speed;
     }
@@ -1063,30 +1101,37 @@ void Planner::recalculate_trapezoids() {
   }
 
   // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
   if (next) {
 
     // Mark the next(last) block as RECALCULATE, to prevent the Stepper ISR running it.
     // As the last block is always recalculated here, there is a chance the block isn't
     // marked as RECALCULATE yet. That's the reason for the following line.
     SBI(next->flag, BLOCK_BIT_RECALCULATE);
 
-    const float next_nominal_speed = SQRT(next->nominal_speed_sqr),
-                nomr = 1.0 / next_nominal_speed;
-    calculate_trapezoid_for_block(next, next_entry_speed * nomr, (MINIMUM_PLANNER_SPEED) * nomr);
-    #if ENABLED(LIN_ADVANCE)
-      if (next->use_advance_lead) {
-        const float comp = next->e_D_ratio * extruder_advance_K * axis_steps_per_mm[E_AXIS];
-        next->max_adv_steps = next_nominal_speed * comp;
-        next->final_adv_steps = (MINIMUM_PLANNER_SPEED) * comp;
-      }
-    #endif
+    // But there is an inherent race condition here, as the block maybe
+    // became BUSY, just before it was marked as RECALCULATE, so check
+    // if that is the case!
+    if (!stepper.is_block_busy(current)) {
+      // Block is not BUSY, we won the race against the Stepper ISR:
+
+      const float next_nominal_speed = SQRT(next->nominal_speed_sqr),
+                  nomr = 1.0 / next_nominal_speed;
+      calculate_trapezoid_for_block(next, next_entry_speed * nomr, (MINIMUM_PLANNER_SPEED) * nomr);
+      #if ENABLED(LIN_ADVANCE)
+        if (next->use_advance_lead) {
+          const float comp = next->e_D_ratio * extruder_advance_K * axis_steps_per_mm[E_AXIS];
+          next->max_adv_steps = next_nominal_speed * comp;
+          next->final_adv_steps = (MINIMUM_PLANNER_SPEED) * comp;
+        }
+      #endif
+    }
 
     // Reset next only to ensure its trapezoid is computed - The stepper is free to use
     // the block from now on.
     CBI(next->flag, BLOCK_BIT_RECALCULATE);
   }
 }
 
 void Planner::recalculate() {
   // Initialize block index to the last block in the planner buffer.
   const uint8_t block_index = prev_block_index(block_buffer_head);
@@ -1416,21 +1461,21 @@ void Planner::quick_stop() {
   // Remove all the queued blocks. Note that this function is NOT
   // called from the Stepper ISR, so we must consider tail as readonly!
   // that is why we set head to tail - But there is a race condition that
   // must be handled: The tail could change between the read and the assignment
   // so this must be enclosed in a critical section
 
   const bool was_enabled = STEPPER_ISR_ENABLED();
   if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
 
   // Drop all queue entries
-  block_buffer_planned = block_buffer_head = block_buffer_tail;
+  block_buffer_nonbusy = block_buffer_planned = block_buffer_head = block_buffer_tail;
 
   // Restart the block delay for the first movement - As the queue was
   // forced to empty, there's no risk the ISR will touch this.
   delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
 
   #if ENABLED(ULTRA_LCD)
     // Clear the accumulated runtime
     clear_block_buffer_runtime();
   #endif
 
@@ -1899,21 +1944,22 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
   }
   else
     block->millimeters = millimeters;
 
   const float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate inverse time for this move. No divide by zero due to previous checks.
   // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   float inverse_secs = fr_mm_s * inverse_millimeters;
 
-  const uint8_t moves_queued = movesplanned();
+  // Get the number of non busy movements in queue (non busy means that they can be altered)
+  const uint8_t moves_queued = nonbusy_movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time im micro seconds
     uint32_t segment_time_us = LROUND(1000000.0 / inverse_secs);
   #endif
 
   #if ENABLED(SLOWDOWN)
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
       if (segment_time_us < min_segment_time_us) {

commit 4d3a9930c55550366ed9dae7d5692f5b376606c6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jun 27 17:26:37 2018 -0500

    Match ASM comment spacing to 1.1.x

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index f5148b0241..e9e9b6393c 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -379,294 +379,294 @@ void Planner::init() {
         // Now we must compute
         // result = 0xFFFFFF / d
         // %8:%7:%6 = interval
         // %16:%15:%14 = nr
         // %13 = 0
 
         // A plain division of 24x24 bits should take 388 cycles to complete. We will
         // use Newton-Raphson for the calculation, and will strive to get way less cycles
         // for the same result - Using C division, it takes 500cycles to complete .
 
-        A("clr %3")                        // idx = 0
+        A("clr %3")                       // idx = 0
         A("mov %14,%6")
         A("mov %15,%7")
-        A("mov %16,%8")                    // nr = interval
-        A("tst %16")                       // nr & 0xFF0000 == 0 ?
-        A("brne 2f")                       // No, skip this
+        A("mov %16,%8")                   // nr = interval
+        A("tst %16")                      // nr & 0xFF0000 == 0 ?
+        A("brne 2f")                      // No, skip this
         A("mov %16,%15")
-        A("mov %15,%14")                   // nr <<= 8, %14 not needed
-        A("subi %3,-8")                    // idx += 8
-        A("tst %16")                       // nr & 0xFF0000 == 0 ?
-        A("brne 2f")                       // No, skip this
-        A("mov %16,%15")                   // nr <<= 8, %14 not needed
-        A("clr %15")                       // We clear %14
-        A("subi %3,-8")                    // idx += 8
+        A("mov %15,%14")                  // nr <<= 8, %14 not needed
+        A("subi %3,-8")                   // idx += 8
+        A("tst %16")                      // nr & 0xFF0000 == 0 ?
+        A("brne 2f")                      // No, skip this
+        A("mov %16,%15")                  // nr <<= 8, %14 not needed
+        A("clr %15")                      // We clear %14
+        A("subi %3,-8")                   // idx += 8
 
         // here %16 != 0 and %16:%15 contains at least 9 MSBits, or both %16:%15 are 0
         L("2")
-        A("cpi %16,0x10")                  // (nr & 0xF00000) == 0 ?
-        A("brcc 3f")                       // No, skip this
-        A("swap %15")                      // Swap nibbles
-        A("swap %16")                      // Swap nibbles. Low nibble is 0
+        A("cpi %16,0x10")                 // (nr & 0xF00000) == 0 ?
+        A("brcc 3f")                      // No, skip this
+        A("swap %15")                     // Swap nibbles
+        A("swap %16")                     // Swap nibbles. Low nibble is 0
         A("mov %14, %15")
-        A("andi %14,0x0F")                 // Isolate low nibble
-        A("andi %15,0xF0")                 // Keep proper nibble in %15
-        A("or %16, %14")                   // %16:%15 <<= 4
-        A("subi %3,-4")                    // idx += 4
+        A("andi %14,0x0F")                // Isolate low nibble
+        A("andi %15,0xF0")                // Keep proper nibble in %15
+        A("or %16, %14")                  // %16:%15 <<= 4
+        A("subi %3,-4")                   // idx += 4
 
         L("3")
-        A("cpi %16,0x40")                  // (nr & 0xC00000) == 0 ?
-        A("brcc 4f")                       // No, skip this
+        A("cpi %16,0x40")                 // (nr & 0xC00000) == 0 ?
+        A("brcc 4f")                      // No, skip this
         A("add %15,%15")
         A("adc %16,%16")
         A("add %15,%15")
-        A("adc %16,%16")                   // %16:%15 <<= 2
-        A("subi %3,-2")                    // idx += 2
+        A("adc %16,%16")                  // %16:%15 <<= 2
+        A("subi %3,-2")                   // idx += 2
 
         L("4")
-        A("cpi %16,0x80")                  // (nr & 0x800000) == 0 ?
-        A("brcc 5f")                       // No, skip this
+        A("cpi %16,0x80")                 // (nr & 0x800000) == 0 ?
+        A("brcc 5f")                      // No, skip this
         A("add %15,%15")
-        A("adc %16,%16")                   // %16:%15 <<= 1
-        A("inc %3")                        // idx += 1
+        A("adc %16,%16")                  // %16:%15 <<= 1
+        A("inc %3")                       // idx += 1
 
         // Now %16:%15 contains its MSBit set to 1, or %16:%15 is == 0. We are now absolutely sure
         // we have at least 9 MSBits available to enter the initial estimation table
         L("5")
         A("add %15,%15")
-        A("adc %16,%16")                   // %16:%15 = tidx = (nr <<= 1), we lose the top MSBit (always set to 1, %16 is the index into the inverse table)
-        A("add r30,%16")                   // Only use top 8 bits
-        A("adc r31,%13")                   // r31:r30 = inv_tab + (tidx)
-        A("lpm %14, Z")                    // %14 = inv_tab[tidx]
-        A("ldi %15, 1")                    // %15 = 1  %15:%14 = inv_tab[tidx] + 256
+        A("adc %16,%16")                  // %16:%15 = tidx = (nr <<= 1), we lose the top MSBit (always set to 1, %16 is the index into the inverse table)
+        A("add r30,%16")                  // Only use top 8 bits
+        A("adc r31,%13")                  // r31:r30 = inv_tab + (tidx)
+        A("lpm %14, Z")                   // %14 = inv_tab[tidx]
+        A("ldi %15, 1")                   // %15 = 1  %15:%14 = inv_tab[tidx] + 256
 
         // We must scale the approximation to the proper place
-        A("clr %16")                       // %16 will always be 0 here
-        A("subi %3,8")                     // idx == 8 ?
-        A("breq 6f")                       // yes, no need to scale
-        A("brcs 7f")                       // If C=1, means idx < 8, result was negative!
+        A("clr %16")                      // %16 will always be 0 here
+        A("subi %3,8")                    // idx == 8 ?
+        A("breq 6f")                      // yes, no need to scale
+        A("brcs 7f")                      // If C=1, means idx < 8, result was negative!
 
         // idx > 8, now %3 = idx - 8. We must perform a left shift. idx range:[1-8]
-        A("sbrs %3,0")                     // shift by 1bit position?
-        A("rjmp 8f")                       // No
+        A("sbrs %3,0")                    // shift by 1bit position?
+        A("rjmp 8f")                      // No
         A("add %14,%14")
-        A("adc %15,%15")                   // %15:16 <<= 1
+        A("adc %15,%15")                  // %15:16 <<= 1
         L("8")
-        A("sbrs %3,1")                     // shift by 2bit position?
-        A("rjmp 9f")                       // No
+        A("sbrs %3,1")                    // shift by 2bit position?
+        A("rjmp 9f")                      // No
         A("add %14,%14")
         A("adc %15,%15")
         A("add %14,%14")
-        A("adc %15,%15")                   // %15:16 <<= 1
+        A("adc %15,%15")                  // %15:16 <<= 1
         L("9")
-        A("sbrs %3,2")                     // shift by 4bits position?
-        A("rjmp 16f")                      // No
-        A("swap %15")                      // Swap nibbles. lo nibble of %15 will always be 0
-        A("swap %14")                      // Swap nibbles
+        A("sbrs %3,2")                    // shift by 4bits position?
+        A("rjmp 16f")                     // No
+        A("swap %15")                     // Swap nibbles. lo nibble of %15 will always be 0
+        A("swap %14")                     // Swap nibbles
         A("mov %12,%14")
-        A("andi %12,0x0F")                 // isolate low nibble
-        A("andi %14,0xF0")                 // and clear it
-        A("or %15,%12")                    // %15:%16 <<= 4
+        A("andi %12,0x0F")                // isolate low nibble
+        A("andi %14,0xF0")                // and clear it
+        A("or %15,%12")                   // %15:%16 <<= 4
         L("16")
-        A("sbrs %3,3")                     // shift by 8bits position?
-        A("rjmp 6f")                       // No, we are done
+        A("sbrs %3,3")                    // shift by 8bits position?
+        A("rjmp 6f")                      // No, we are done
         A("mov %16,%15")
         A("mov %15,%14")
         A("clr %14")
         A("jmp 6f")
 
         // idx < 8, now %3 = idx - 8. Get the count of bits
         L("7")
-        A("neg %3")                        // %3 = -idx = count of bits to move right. idx range:[1...8]
-        A("sbrs %3,0")                     // shift by 1 bit position ?
-        A("rjmp 10f")                      // No, skip it
-        A("asr %15")                       // (bit7 is always 0 here)
+        A("neg %3")                       // %3 = -idx = count of bits to move right. idx range:[1...8]
+        A("sbrs %3,0")                    // shift by 1 bit position ?
+        A("rjmp 10f")                     // No, skip it
+        A("asr %15")                      // (bit7 is always 0 here)
         A("ror %14")
         L("10")
-        A("sbrs %3,1")                     // shift by 2 bit position ?
-        A("rjmp 11f")                      // No, skip it
-        A("asr %15")                       // (bit7 is always 0 here)
+        A("sbrs %3,1")                    // shift by 2 bit position ?
+        A("rjmp 11f")                     // No, skip it
+        A("asr %15")                      // (bit7 is always 0 here)
         A("ror %14")
-        A("asr %15")                       // (bit7 is always 0 here)
+        A("asr %15")                      // (bit7 is always 0 here)
         A("ror %14")
         L("11")
-        A("sbrs %3,2")                     // shift by 4 bit position ?
-        A("rjmp 12f")                      // No, skip it
-        A("swap %15")                      // Swap nibbles
-        A("andi %14, 0xF0")                // Lose the lowest nibble
-        A("swap %14")                      // Swap nibbles. Upper nibble is 0
-        A("or %14,%15")                    // Pass nibble from upper byte
-        A("andi %15, 0x0F")                // And get rid of that nibble
+        A("sbrs %3,2")                    // shift by 4 bit position ?
+        A("rjmp 12f")                     // No, skip it
+        A("swap %15")                     // Swap nibbles
+        A("andi %14, 0xF0")               // Lose the lowest nibble
+        A("swap %14")                     // Swap nibbles. Upper nibble is 0
+        A("or %14,%15")                   // Pass nibble from upper byte
+        A("andi %15, 0x0F")               // And get rid of that nibble
         L("12")
-        A("sbrs %3,3")                     // shift by 8 bit position ?
-        A("rjmp 6f")                       // No, skip it
+        A("sbrs %3,3")                    // shift by 8 bit position ?
+        A("rjmp 6f")                      // No, skip it
         A("mov %14,%15")
         A("clr %15")
-        L("6")                       // %16:%15:%14 = initial estimation of 0x1000000 / d
+        L("6")                            // %16:%15:%14 = initial estimation of 0x1000000 / d
 
         // Now, we must refine the estimation present on %16:%15:%14 using 1 iteration
         // of Newton-Raphson. As it has a quadratic convergence, 1 iteration is enough
         // to get more than 18bits of precision (the initial table lookup gives 9 bits of
         // precision to start from). 18bits of precision is all what is needed here for result
 
         // %8:%7:%6 = d = interval
         // %16:%15:%14 = x = initial estimation of 0x1000000 / d
         // %13 = 0
         // %3:%2:%1:%0 = working accumulator
 
         // Compute 1<<25 - x*d. Result should never exceed 25 bits and should always be positive
         A("clr %0")
         A("clr %1")
         A("clr %2")
-        A("ldi %3,2")                      // %3:%2:%1:%0 = 0x2000000
-        A("mul %6,%14")                    // r1:r0 = LO(d) * LO(x)
+        A("ldi %3,2")                     // %3:%2:%1:%0 = 0x2000000
+        A("mul %6,%14")                   // r1:r0 = LO(d) * LO(x)
         A("sub %0,r0")
         A("sbc %1,r1")
         A("sbc %2,%13")
-        A("sbc %3,%13")                    // %3:%2:%1:%0 -= LO(d) * LO(x)
-        A("mul %7,%14")                    // r1:r0 = MI(d) * LO(x)
+        A("sbc %3,%13")                   // %3:%2:%1:%0 -= LO(d) * LO(x)
+        A("mul %7,%14")                   // r1:r0 = MI(d) * LO(x)
         A("sub %1,r0")
         A("sbc %2,r1" )
-        A("sbc %3,%13")                    // %3:%2:%1:%0 -= MI(d) * LO(x) << 8
-        A("mul %8,%14")                    // r1:r0 = HI(d) * LO(x)
+        A("sbc %3,%13")                   // %3:%2:%1:%0 -= MI(d) * LO(x) << 8
+        A("mul %8,%14")                   // r1:r0 = HI(d) * LO(x)
         A("sub %2,r0")
-        A("sbc %3,r1")                     // %3:%2:%1:%0 -= MIL(d) * LO(x) << 16
-        A("mul %6,%15")                    // r1:r0 = LO(d) * MI(x)
+        A("sbc %3,r1")                    // %3:%2:%1:%0 -= MIL(d) * LO(x) << 16
+        A("mul %6,%15")                   // r1:r0 = LO(d) * MI(x)
         A("sub %1,r0")
         A("sbc %2,r1")
-        A("sbc %3,%13")                    // %3:%2:%1:%0 -= LO(d) * MI(x) << 8
-        A("mul %7,%15")                    // r1:r0 = MI(d) * MI(x)
+        A("sbc %3,%13")                   // %3:%2:%1:%0 -= LO(d) * MI(x) << 8
+        A("mul %7,%15")                   // r1:r0 = MI(d) * MI(x)
         A("sub %2,r0")
-        A("sbc %3,r1")                     // %3:%2:%1:%0 -= MI(d) * MI(x) << 16
-        A("mul %8,%15")                    // r1:r0 = HI(d) * MI(x)
-        A("sub %3,r0")                     // %3:%2:%1:%0 -= MIL(d) * MI(x) << 24
-        A("mul %6,%16")                    // r1:r0 = LO(d) * HI(x)
+        A("sbc %3,r1")                    // %3:%2:%1:%0 -= MI(d) * MI(x) << 16
+        A("mul %8,%15")                   // r1:r0 = HI(d) * MI(x)
+        A("sub %3,r0")                    // %3:%2:%1:%0 -= MIL(d) * MI(x) << 24
+        A("mul %6,%16")                   // r1:r0 = LO(d) * HI(x)
         A("sub %2,r0")
-        A("sbc %3,r1")                     // %3:%2:%1:%0 -= LO(d) * HI(x) << 16
-        A("mul %7,%16")                    // r1:r0 = MI(d) * HI(x)
-        A("sub %3,r0")                     // %3:%2:%1:%0 -= MI(d) * HI(x) << 24
+        A("sbc %3,r1")                    // %3:%2:%1:%0 -= LO(d) * HI(x) << 16
+        A("mul %7,%16")                   // r1:r0 = MI(d) * HI(x)
+        A("sub %3,r0")                    // %3:%2:%1:%0 -= MI(d) * HI(x) << 24
         // %3:%2:%1:%0 = (1<<25) - x*d     [169]
 
         // We need to multiply that result by x, and we are only interested in the top 24bits of that multiply
 
         // %16:%15:%14 = x = initial estimation of 0x1000000 / d
         // %3:%2:%1:%0 = (1<<25) - x*d = acc
         // %13 = 0
 
         // result = %11:%10:%9:%5:%4
-        A("mul %14,%0")                    // r1:r0 = LO(x) * LO(acc)
+        A("mul %14,%0")                   // r1:r0 = LO(x) * LO(acc)
         A("mov %4,r1")
         A("clr %5")
         A("clr %9")
         A("clr %10")
-        A("clr %11")                       // %11:%10:%9:%5:%4 = LO(x) * LO(acc) >> 8
-        A("mul %15,%0")                    // r1:r0 = MI(x) * LO(acc)
+        A("clr %11")                      // %11:%10:%9:%5:%4 = LO(x) * LO(acc) >> 8
+        A("mul %15,%0")                   // r1:r0 = MI(x) * LO(acc)
         A("add %4,r0")
         A("adc %5,r1")
         A("adc %9,%13")
         A("adc %10,%13")
-        A("adc %11,%13")                   // %11:%10:%9:%5:%4 += MI(x) * LO(acc)
-        A("mul %16,%0")                    // r1:r0 = HI(x) * LO(acc)
+        A("adc %11,%13")                  // %11:%10:%9:%5:%4 += MI(x) * LO(acc)
+        A("mul %16,%0")                   // r1:r0 = HI(x) * LO(acc)
         A("add %5,r0")
         A("adc %9,r1")
         A("adc %10,%13")
-        A("adc %11,%13")                   // %11:%10:%9:%5:%4 += MI(x) * LO(acc) << 8
+        A("adc %11,%13")                  // %11:%10:%9:%5:%4 += MI(x) * LO(acc) << 8
 
-        A("mul %14,%1")                    // r1:r0 = LO(x) * MIL(acc)
+        A("mul %14,%1")                   // r1:r0 = LO(x) * MIL(acc)
         A("add %4,r0")
         A("adc %5,r1")
         A("adc %9,%13")
         A("adc %10,%13")
-        A("adc %11,%13")                   // %11:%10:%9:%5:%4 = LO(x) * MIL(acc)
-        A("mul %15,%1")                    // r1:r0 = MI(x) * MIL(acc)
+        A("adc %11,%13")                  // %11:%10:%9:%5:%4 = LO(x) * MIL(acc)
+        A("mul %15,%1")                   // r1:r0 = MI(x) * MIL(acc)
         A("add %5,r0")
         A("adc %9,r1")
         A("adc %10,%13")
-        A("adc %11,%13")                   // %11:%10:%9:%5:%4 += MI(x) * MIL(acc) << 8
-        A("mul %16,%1")                    // r1:r0 = HI(x) * MIL(acc)
+        A("adc %11,%13")                  // %11:%10:%9:%5:%4 += MI(x) * MIL(acc) << 8
+        A("mul %16,%1")                   // r1:r0 = HI(x) * MIL(acc)
         A("add %9,r0")
         A("adc %10,r1")
-        A("adc %11,%13")                   // %11:%10:%9:%5:%4 += MI(x) * MIL(acc) << 16
+        A("adc %11,%13")                  // %11:%10:%9:%5:%4 += MI(x) * MIL(acc) << 16
 
-        A("mul %14,%2")                    // r1:r0 = LO(x) * MIH(acc)
+        A("mul %14,%2")                   // r1:r0 = LO(x) * MIH(acc)
         A("add %5,r0")
         A("adc %9,r1")
         A("adc %10,%13")
-        A("adc %11,%13")                   // %11:%10:%9:%5:%4 = LO(x) * MIH(acc) << 8
-        A("mul %15,%2")                    // r1:r0 = MI(x) * MIH(acc)
+        A("adc %11,%13")                  // %11:%10:%9:%5:%4 = LO(x) * MIH(acc) << 8
+        A("mul %15,%2")                   // r1:r0 = MI(x) * MIH(acc)
         A("add %9,r0")
         A("adc %10,r1")
-        A("adc %11,%13")                   // %11:%10:%9:%5:%4 += MI(x) * MIH(acc) << 16
-        A("mul %16,%2")                    // r1:r0 = HI(x) * MIH(acc)
+        A("adc %11,%13")                  // %11:%10:%9:%5:%4 += MI(x) * MIH(acc) << 16
+        A("mul %16,%2")                   // r1:r0 = HI(x) * MIH(acc)
         A("add %10,r0")
-        A("adc %11,r1")                    // %11:%10:%9:%5:%4 += MI(x) * MIH(acc) << 24
+        A("adc %11,r1")                   // %11:%10:%9:%5:%4 += MI(x) * MIH(acc) << 24
 
-        A("mul %14,%3")                    // r1:r0 = LO(x) * HI(acc)
+        A("mul %14,%3")                   // r1:r0 = LO(x) * HI(acc)
         A("add %9,r0")
         A("adc %10,r1")
-        A("adc %11,%13")                   // %11:%10:%9:%5:%4 = LO(x) * HI(acc) << 16
-        A("mul %15,%3")                    // r1:r0 = MI(x) * HI(acc)
+        A("adc %11,%13")                  // %11:%10:%9:%5:%4 = LO(x) * HI(acc) << 16
+        A("mul %15,%3")                   // r1:r0 = MI(x) * HI(acc)
         A("add %10,r0")
-        A("adc %11,r1")                    // %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 24
-        A("mul %16,%3")                    // r1:r0 = HI(x) * HI(acc)
-        A("add %11,r0")                    // %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 32
+        A("adc %11,r1")                   // %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 24
+        A("mul %16,%3")                   // r1:r0 = HI(x) * HI(acc)
+        A("add %11,r0")                   // %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 32
 
         // At this point, %11:%10:%9 contains the new estimation of x.
 
         // Finally, we must correct the result. Estimate remainder as
         // (1<<24) - x*d
         // %11:%10:%9 = x
         // %8:%7:%6 = d = interval" "\n\t"
         A("ldi %3,1")
         A("clr %2")
         A("clr %1")
-        A("clr %0")                        // %3:%2:%1:%0 = 0x1000000
-        A("mul %6,%9")                     // r1:r0 = LO(d) * LO(x)
+        A("clr %0")                       // %3:%2:%1:%0 = 0x1000000
+        A("mul %6,%9")                    // r1:r0 = LO(d) * LO(x)
         A("sub %0,r0")
         A("sbc %1,r1")
         A("sbc %2,%13")
-        A("sbc %3,%13")                    // %3:%2:%1:%0 -= LO(d) * LO(x)
-        A("mul %7,%9")                     // r1:r0 = MI(d) * LO(x)
+        A("sbc %3,%13")                   // %3:%2:%1:%0 -= LO(d) * LO(x)
+        A("mul %7,%9")                    // r1:r0 = MI(d) * LO(x)
         A("sub %1,r0")
         A("sbc %2,r1")
-        A("sbc %3,%13")                    // %3:%2:%1:%0 -= MI(d) * LO(x) << 8
-        A("mul %8,%9")                     // r1:r0 = HI(d) * LO(x)
+        A("sbc %3,%13")                   // %3:%2:%1:%0 -= MI(d) * LO(x) << 8
+        A("mul %8,%9")                    // r1:r0 = HI(d) * LO(x)
         A("sub %2,r0")
-        A("sbc %3,r1")                     // %3:%2:%1:%0 -= MIL(d) * LO(x) << 16
-        A("mul %6,%10")                    // r1:r0 = LO(d) * MI(x)
+        A("sbc %3,r1")                    // %3:%2:%1:%0 -= MIL(d) * LO(x) << 16
+        A("mul %6,%10")                   // r1:r0 = LO(d) * MI(x)
         A("sub %1,r0")
         A("sbc %2,r1")
-        A("sbc %3,%13")                    // %3:%2:%1:%0 -= LO(d) * MI(x) << 8
-        A("mul %7,%10")                    // r1:r0 = MI(d) * MI(x)
+        A("sbc %3,%13")                   // %3:%2:%1:%0 -= LO(d) * MI(x) << 8
+        A("mul %7,%10")                   // r1:r0 = MI(d) * MI(x)
         A("sub %2,r0")
-        A("sbc %3,r1")                     // %3:%2:%1:%0 -= MI(d) * MI(x) << 16
-        A("mul %8,%10")                    // r1:r0 = HI(d) * MI(x)
-        A("sub %3,r0")                     // %3:%2:%1:%0 -= MIL(d) * MI(x) << 24
-        A("mul %6,%11")                    // r1:r0 = LO(d) * HI(x)
+        A("sbc %3,r1")                    // %3:%2:%1:%0 -= MI(d) * MI(x) << 16
+        A("mul %8,%10")                   // r1:r0 = HI(d) * MI(x)
+        A("sub %3,r0")                    // %3:%2:%1:%0 -= MIL(d) * MI(x) << 24
+        A("mul %6,%11")                   // r1:r0 = LO(d) * HI(x)
         A("sub %2,r0")
-        A("sbc %3,r1")                     // %3:%2:%1:%0 -= LO(d) * HI(x) << 16
-        A("mul %7,%11")                    // r1:r0 = MI(d) * HI(x)
-        A("sub %3,r0")                     // %3:%2:%1:%0 -= MI(d) * HI(x) << 24
+        A("sbc %3,r1")                    // %3:%2:%1:%0 -= LO(d) * HI(x) << 16
+        A("mul %7,%11")                   // r1:r0 = MI(d) * HI(x)
+        A("sub %3,r0")                    // %3:%2:%1:%0 -= MI(d) * HI(x) << 24
         // %3:%2:%1:%0 = r = (1<<24) - x*d
         // %8:%7:%6 = d = interval
 
         // Perform the final correction
         A("sub %0,%6")
         A("sbc %1,%7")
-        A("sbc %2,%8")                     // r -= d
-        A("brcs 14f")                      // if ( r >= d)
+        A("sbc %2,%8")                    // r -= d
+        A("brcs 14f")                     // if ( r >= d)
 
         // %11:%10:%9 = x
         A("ldi %3,1")
         A("add %9,%3")
         A("adc %10,%13")
-        A("adc %11,%13")                   // x++
+        A("adc %11,%13")                  // x++
         L("14")
 
         // Estimation is done. %11:%10:%9 = x
         A("clr __zero_reg__")              // Make C runtime happy
         // [211 cycles total]
         : "=r" (r2),
           "=r" (r3),
           "=r" (r4),
           "=d" (r5),
           "=r" (r6),

commit 3b3029c4bfd785c19f791493fbea68fe312abf9a
Author: Andy Shaw <andy-git@gloomy-place.com>
Date:   Wed Jun 27 03:38:31 2018 +0100

    Make max_e_jerk an array to reduce CPU usage (#11118)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 9083c77594..f5148b0241 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -119,21 +119,25 @@ float Planner::max_feedrate_mm_s[XYZE_N],     // (mm/s) M203 XYZE - Max speeds
       Planner::steps_to_mm[XYZE_N],           // (mm) Millimeters per step
       Planner::min_feedrate_mm_s,             // (mm/s) M205 S - Minimum linear feedrate
       Planner::acceleration,                  // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
       Planner::retract_acceleration,          // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
       Planner::travel_acceleration,           // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
       Planner::min_travel_feedrate_mm_s;      // (mm/s) M205 T - Minimum travel feedrate
 
 #if ENABLED(JUNCTION_DEVIATION)
   float Planner::junction_deviation_mm;       // (mm) M205 J
   #if ENABLED(LIN_ADVANCE)
-    float Planner::max_e_jerk_factor;         // Calculated from junction_deviation_mm
+    #if ENABLED(DISTINCT_E_FACTORS)
+      float Planner::max_e_jerk[EXTRUDERS];   // Calculated from junction_deviation_mm
+    #else
+      float Planner::max_e_jerk;
+    #endif
   #endif
 #else
   float Planner::max_jerk[XYZE];              // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
 #endif
 
 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
 #if ENABLED(DISTINCT_E_FACTORS)
@@ -2049,21 +2053,25 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
         if ((float)accel * (float)block->steps[AXIS] > comp) accel = comp / (float)block->steps[AXIS]; \
       } \
     }while(0)
 
     // Start with print or travel acceleration
     accel = CEIL((esteps ? acceleration : travel_acceleration) * steps_per_mm);
 
     #if ENABLED(LIN_ADVANCE)
 
       #if ENABLED(JUNCTION_DEVIATION)
-        #define MAX_E_JERK (max_e_jerk_factor * max_acceleration_mm_per_s2[_EINDEX])
+        #if ENABLED(DISTINCT_E_FACTORS)
+          #define MAX_E_JERK max_e_jerk[extruder]
+        #else
+          #define MAX_E_JERK max_e_jerk
+        #endif
       #else
         #define MAX_E_JERK max_jerk[E_AXIS]
       #endif
 
       /**
        *
        * Use LIN_ADVANCE for blocks if all these are true:
        *
        * esteps             : This is a print move, because we checked for A, B, C steps before.
        *
@@ -2562,20 +2570,23 @@ void Planner::reset_acceleration_rates() {
     #define AXIS_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)
   #else
     #define AXIS_CONDITION true
   #endif
   uint32_t highest_rate = 1;
   LOOP_XYZE_N(i) {
     max_acceleration_steps_per_s2[i] = max_acceleration_mm_per_s2[i] * axis_steps_per_mm[i];
     if (AXIS_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   }
   cutoff_long = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
+  #if ENABLED(JUNCTION_DEVIATION) && ENABLED(LIN_ADVANCE)
+    recalculate_max_e_jerk();
+  #endif
 }
 
 // Recalculate position, steps_to_mm if axis_steps_per_mm changes!
 void Planner::refresh_positioning() {
   LOOP_XYZE_N(i) steps_to_mm[i] = 1.0 / axis_steps_per_mm[i];
   set_position_mm_kinematic(current_position);
   reset_acceleration_rates();
 }
 
 #if ENABLED(AUTOTEMP)

commit 48a15d1c7e78eaa716bedecb80feeae780c7234a
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Fri Jun 22 11:15:37 2018 -0300

    [2.0.x] Fix stepper/planner race condition and Stepper pulse timer (#11081)
    
    * Planner: Removal of some race conditions between Stepper ISR and Planner, some of them pointed out by @AnHardt, some of my own findings
    * Fixing timing on stepper pulses adding a compensation for the non-null time required to set ports.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 6393829fe9..9083c77594 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -751,21 +751,25 @@ void Planner::calculate_trapezoid_for_block(block_t* const block, const float &e
     // And to offload calculations from the ISR, we also calculate the inverse of those times here
     uint32_t acceleration_time_inverse = get_period_inverse(acceleration_time);
     uint32_t deceleration_time_inverse = get_period_inverse(deceleration_time);
 
   #endif
 
   // Fill variables used by the stepper in a critical section
   const bool was_enabled = STEPPER_ISR_ENABLED();
   if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
 
-  // Don't update variables if block is busy: It is being interpreted by the planner
+  // Don't update variables if block is busy; it is being interpreted by the planner.
+  // If this happens, there's a problem... The block speed is inconsistent. Some values
+  // have already been updated, but the Stepper ISR is already using the block. Fortunately,
+  // the values being used by the Stepper ISR weren't touched, so just stop here...
+  // TODO: There may be a way to update a running block, depending on the stepper ISR position.
   if (!TEST(block->flag, BLOCK_BIT_BUSY)) {
     block->accelerate_until = accelerate_steps;
     block->decelerate_after = accelerate_steps + plateau_steps;
     block->initial_rate = initial_rate;
     #if ENABLED(S_CURVE_ACCELERATION)
       block->acceleration_time = acceleration_time;
       block->deceleration_time = deceleration_time;
       block->acceleration_time_inverse = acceleration_time_inverse;
       block->deceleration_time_inverse = deceleration_time_inverse;
       block->cruise_rate = cruise_rate;
@@ -855,24 +859,27 @@ void Planner::reverse_pass_kernel(block_t* const current, const block_t * const
       // the current block and next block junction speeds are guaranteed to always be at their maximum
       // junction speeds in deceleration and acceleration, respectively. This is due to how the current
       // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
       // the reverse and forward planners, the corresponding block junction speed will always be at the
       // the maximum junction speed and may always be ignored for any speed reduction checks.
 
       const float new_entry_speed_sqr = TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH)
         ? max_entry_speed_sqr
         : MIN(max_entry_speed_sqr, max_allowable_speed_sqr(-current->acceleration, next ? next->entry_speed_sqr : sq(MINIMUM_PLANNER_SPEED), current->millimeters));
       if (current->entry_speed_sqr != new_entry_speed_sqr) {
-        current->entry_speed_sqr = new_entry_speed_sqr;
 
-        // Need to recalculate the block speed
+        // Need to recalculate the block speed - Mark it now, so the stepper
+        // ISR does not consume the block before being recalculated
         SBI(current->flag, BLOCK_BIT_RECALCULATE);
+
+        // Set the new entry speed
+        current->entry_speed_sqr = new_entry_speed_sqr;
       }
     }
   }
 }
 
 /**
  * recalculate() needs to go over the current plan twice.
  * Once in reverse and once forward. This implements the reverse pass.
  */
 void Planner::reverse_pass() {
@@ -918,28 +925,29 @@ void Planner::forward_pass_kernel(const block_t* const previous, block_t* const
     // guaranteed to be reached. No need to recheck.
     if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH) &&
       previous->entry_speed_sqr < current->entry_speed_sqr) {
 
       // Compute the maximum allowable speed
       const float new_entry_speed_sqr = max_allowable_speed_sqr(-previous->acceleration, previous->entry_speed_sqr, previous->millimeters);
 
       // If true, current block is full-acceleration and we can move the planned pointer forward.
       if (new_entry_speed_sqr < current->entry_speed_sqr) {
 
+        // Mark we need to recompute the trapezoidal shape, and do it now,
+        // so the stepper ISR does not consume the block before being recalculated
+        SBI(current->flag, BLOCK_BIT_RECALCULATE);
+
         // Always <= max_entry_speed_sqr. Backward pass sets this.
         current->entry_speed_sqr = new_entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass sets this.
 
         // Set optimal plan pointer.
         block_buffer_planned = block_index;
-
-        // And mark we need to recompute the trapezoidal shape
-        SBI(current->flag, BLOCK_BIT_RECALCULATE);
       }
     }
 
     // Any block set at its maximum entry speed also creates an optimal plan up to this
     // point in the buffer. When the plan is bracketed by either the beginning of the
     // buffer and a maximum entry speed or two maximum entry speeds, every block in between
     // cannot logically be further improved. Hence, we don't have to recompute them anymore.
     if (current->entry_speed_sqr == current->max_entry_speed_sqr)
       block_buffer_planned = block_index;
   }
@@ -1012,54 +1020,72 @@ void Planner::recalculate_trapezoids() {
 
     next = &block_buffer[block_index];
 
     // Skip sync blocks
     if (!TEST(next->flag, BLOCK_BIT_SYNC_POSITION)) {
       next_entry_speed = SQRT(next->entry_speed_sqr);
 
       if (current) {
         // Recalculate if current block entry or exit junction speed has changed.
         if (TEST(current->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
+
+          // Mark the current block as RECALCULATE, to protect it from the Stepper ISR running it.
+          // Note that due to the above condition, there's a chance the current block isn't marked as
+          // RECALCULATE yet, but the next one is. That's the reason for the following line.
+          SBI(current->flag, BLOCK_BIT_RECALCULATE);
+
           // NOTE: Entry and exit factors always > 0 by all previous logic operations.
           const float current_nominal_speed = SQRT(current->nominal_speed_sqr),
                       nomr = 1.0 / current_nominal_speed;
           calculate_trapezoid_for_block(current, current_entry_speed * nomr, next_entry_speed * nomr);
           #if ENABLED(LIN_ADVANCE)
             if (current->use_advance_lead) {
               const float comp = current->e_D_ratio * extruder_advance_K * axis_steps_per_mm[E_AXIS];
               current->max_adv_steps = current_nominal_speed * comp;
               current->final_adv_steps = next_entry_speed * comp;
             }
           #endif
-          CBI(current->flag, BLOCK_BIT_RECALCULATE); // Reset current only to ensure next trapezoid is computed
+
+          // Reset current only to ensure next trapezoid is computed - The
+          // stepper is free to use the block from now on.
+          CBI(current->flag, BLOCK_BIT_RECALCULATE);
         }
       }
 
       current = next;
       current_entry_speed = next_entry_speed;
     }
 
     block_index = next_block_index(block_index);
   }
 
   // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
   if (next) {
+
+    // Mark the next(last) block as RECALCULATE, to prevent the Stepper ISR running it.
+    // As the last block is always recalculated here, there is a chance the block isn't
+    // marked as RECALCULATE yet. That's the reason for the following line.
+    SBI(next->flag, BLOCK_BIT_RECALCULATE);
+
     const float next_nominal_speed = SQRT(next->nominal_speed_sqr),
                 nomr = 1.0 / next_nominal_speed;
     calculate_trapezoid_for_block(next, next_entry_speed * nomr, (MINIMUM_PLANNER_SPEED) * nomr);
     #if ENABLED(LIN_ADVANCE)
       if (next->use_advance_lead) {
         const float comp = next->e_D_ratio * extruder_advance_K * axis_steps_per_mm[E_AXIS];
         next->max_adv_steps = next_nominal_speed * comp;
         next->final_adv_steps = (MINIMUM_PLANNER_SPEED) * comp;
       }
     #endif
+
+    // Reset next only to ensure its trapezoid is computed - The stepper is free to use
+    // the block from now on.
     CBI(next->flag, BLOCK_BIT_RECALCULATE);
   }
 }
 
 void Planner::recalculate() {
   // Initialize block index to the last block in the planner buffer.
   const uint8_t block_index = prev_block_index(block_buffer_head);
   // If there is just one block, no planning can be done. Avoid it!
   if (block_index != block_buffer_planned) {
     reverse_pass();

commit 4dbec774b5839df5c0ec0b078f21bb2e07b86707
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 12 16:32:22 2018 -0500

    HAL_*_TIMER_RATE => *_TIMER_RATE

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index db02c8f438..6393829fe9 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -738,22 +738,22 @@ void Planner::calculate_trapezoid_for_block(block_t* const block, const float &e
   #if ENABLED(S_CURVE_ACCELERATION)
     else // We have some plateau time, so the cruise rate will be the nominal rate
       cruise_rate = block->nominal_rate;
   #endif
 
   // block->accelerate_until = accelerate_steps;
   // block->decelerate_after = accelerate_steps+plateau_steps;
 
   #if ENABLED(S_CURVE_ACCELERATION)
     // Jerk controlled speed requires to express speed versus time, NOT steps
-    uint32_t acceleration_time = ((float)(cruise_rate - initial_rate) / accel) * (HAL_STEPPER_TIMER_RATE),
-             deceleration_time = ((float)(cruise_rate - final_rate) / accel) * (HAL_STEPPER_TIMER_RATE);
+    uint32_t acceleration_time = ((float)(cruise_rate - initial_rate) / accel) * (STEPPER_TIMER_RATE),
+             deceleration_time = ((float)(cruise_rate - final_rate) / accel) * (STEPPER_TIMER_RATE);
 
     // And to offload calculations from the ISR, we also calculate the inverse of those times here
     uint32_t acceleration_time_inverse = get_period_inverse(acceleration_time);
     uint32_t deceleration_time_inverse = get_period_inverse(deceleration_time);
 
   #endif
 
   // Fill variables used by the stepper in a critical section
   const bool was_enabled = STEPPER_ISR_ENABLED();
   if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
@@ -2090,25 +2090,25 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     else {
       LIMIT_ACCEL_FLOAT(A_AXIS, 0);
       LIMIT_ACCEL_FLOAT(B_AXIS, 0);
       LIMIT_ACCEL_FLOAT(C_AXIS, 0);
       LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(S_CURVE_ACCELERATION)
-    block->acceleration_rate = (uint32_t)(accel * (4096.0 * 4096.0 / (HAL_STEPPER_TIMER_RATE)));
+    block->acceleration_rate = (uint32_t)(accel * (4096.0 * 4096.0 / (STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
-      block->advance_speed = (HAL_STEPPER_TIMER_RATE) / (extruder_advance_K * block->e_D_ratio * block->acceleration * axis_steps_per_mm[E_AXIS_N]);
+      block->advance_speed = (STEPPER_TIMER_RATE) / (extruder_advance_K * block->e_D_ratio * block->acceleration * axis_steps_per_mm[E_AXIS_N]);
       #if ENABLED(LA_DEBUG)
         if (extruder_advance_K * block->e_D_ratio * block->acceleration * 2 < SQRT(block->nominal_speed_sqr) * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif
     }
   #endif
 
   float vmax_junction_sqr; // Initial limit on the segment entry velocity (mm/s)^2

commit 9d04f47d9809a22f2ed41cb8cc093ce68e5f5753
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 11 18:49:08 2018 -0500

    Improvements for junction_deviation_mm
    
    - Drop `max_jerk` with `JUNCTION_DEVIATION`
    - Add `max_e_jerk_factor` for use by `LIN_ADVANCE`
    - Recalculate `max_e_jerk_factor` when `junction_deviation_mm` changes
    - Fix LCD editing of `junction_deviation_mm`

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 87a3d1a2ae..db02c8f438 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -114,33 +114,40 @@ uint32_t Planner::max_acceleration_mm_per_s2[XYZE_N],    // (mm/s^2) M201 XYZE
          Planner::max_acceleration_steps_per_s2[XYZE_N], // (steps/s^2) Derived from mm_per_s2
          Planner::min_segment_time_us;                   // (¬µs) M205 B
 
 float Planner::max_feedrate_mm_s[XYZE_N],     // (mm/s) M203 XYZE - Max speeds
       Planner::axis_steps_per_mm[XYZE_N],     // (steps) M92 XYZE - Steps per millimeter
       Planner::steps_to_mm[XYZE_N],           // (mm) Millimeters per step
       Planner::min_feedrate_mm_s,             // (mm/s) M205 S - Minimum linear feedrate
       Planner::acceleration,                  // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
       Planner::retract_acceleration,          // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
       Planner::travel_acceleration,           // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
-      Planner::max_jerk[XYZE],                // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
       Planner::min_travel_feedrate_mm_s;      // (mm/s) M205 T - Minimum travel feedrate
 
 #if ENABLED(JUNCTION_DEVIATION)
   float Planner::junction_deviation_mm;       // (mm) M205 J
+  #if ENABLED(LIN_ADVANCE)
+    float Planner::max_e_jerk_factor;         // Calculated from junction_deviation_mm
+  #endif
+#else
+  float Planner::max_jerk[XYZE];              // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
 #endif
 
 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
+  #define _EINDEX (E_AXIS + active_extruder)
+#else
+  #define _EINDEX E_AXIS
 #endif
 
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
 
 float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0); // The flow percentage and volumetric multiplier combine to scale E movement
 
 #if DISABLED(NO_VOLUMETRICS)
   float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
         Planner::volumetric_area_nominal = CIRCLE_AREA((DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5), // Nominal cross-sectional area
         Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
@@ -2014,20 +2021,27 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
         const float comp = (float)max_acceleration_steps_per_s2[AXIS+INDX] * (float)block->step_event_count; \
         if ((float)accel * (float)block->steps[AXIS] > comp) accel = comp / (float)block->steps[AXIS]; \
       } \
     }while(0)
 
     // Start with print or travel acceleration
     accel = CEIL((esteps ? acceleration : travel_acceleration) * steps_per_mm);
 
     #if ENABLED(LIN_ADVANCE)
+
+      #if ENABLED(JUNCTION_DEVIATION)
+        #define MAX_E_JERK (max_e_jerk_factor * max_acceleration_mm_per_s2[_EINDEX])
+      #else
+        #define MAX_E_JERK max_jerk[E_AXIS]
+      #endif
+
       /**
        *
        * Use LIN_ADVANCE for blocks if all these are true:
        *
        * esteps             : This is a print move, because we checked for A, B, C steps before.
        *
        * extruder_advance_K : There is an advance factor set.
        *
        * de > 0             : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
        */
@@ -2044,24 +2058,23 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
                + sq(target_float[Y_AXIS] - position_float[Y_AXIS])
                + sq(target_float[Z_AXIS] - position_float[Z_AXIS]))
           #endif
         ;
 
         // Check for unusual high e_D ratio to detect if a retract move was combined with the last print move due to min. steps per segment. Never execute this with advance!
         // This assumes no one will use a retract length of 0mm < retr_length < ~0.2mm and no one will print 100mm wide lines using 3mm filament or 35mm wide lines using 1.75mm filament.
         if (block->e_D_ratio > 3.0)
           block->use_advance_lead = false;
         else {
-          const uint32_t max_accel_steps_per_s2 = max_jerk[E_AXIS] / (extruder_advance_K * block->e_D_ratio) * steps_per_mm;
+          const uint32_t max_accel_steps_per_s2 = MAX_E_JERK / (extruder_advance_K * block->e_D_ratio) * steps_per_mm;
           #if ENABLED(LA_DEBUG)
-            if (accel > max_accel_steps_per_s2)
-              SERIAL_ECHOLNPGM("Acceleration limited.");
+            if (accel > max_accel_steps_per_s2) SERIAL_ECHOLNPGM("Acceleration limited.");
           #endif
           NOMORE(accel, max_accel_steps_per_s2);
         }
       }
     #endif
 
     #if ENABLED(DISTINCT_E_FACTORS)
       #define ACCEL_IDX extruder
     #else
       #define ACCEL_IDX 0
@@ -2452,24 +2465,21 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
 
 /**
  * Directly set the planner XYZ position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
 
 void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)
-    #define _EINDEX (E_AXIS + active_extruder)
     last_extruder = active_extruder;
-  #else
-    #define _EINDEX E_AXIS
   #endif
   position[A_AXIS] = LROUND(a * axis_steps_per_mm[A_AXIS]),
   position[B_AXIS] = LROUND(b * axis_steps_per_mm[B_AXIS]),
   position[C_AXIS] = LROUND(c * axis_steps_per_mm[C_AXIS]),
   position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
   #if HAS_POSITION_FLOAT
     position_float[A_AXIS] = a;
     position_float[B_AXIS] = b;
     position_float[C_AXIS] = c;
     position_float[E_AXIS] = e;

commit a2f521d34b7a500bcaea996e1f386b57ff40d2f7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 10 18:02:54 2018 -0500

    Add Junction Deviation mm runtime setting (#10990)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index d1e423c3d0..87a3d1a2ae 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -103,55 +103,56 @@ Planner planner;
 /**
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head,  // Index of the next block to be pushed
                  Planner::block_buffer_tail;  // Index of the busy block, if any
 uint16_t Planner::cleaning_buffer_counter;    // A counter to disable queuing of blocks
 uint8_t Planner::delay_before_delivering,     // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
         Planner::block_buffer_planned;        // Index of the optimally planned block
 
-float Planner::max_feedrate_mm_s[XYZE_N],   // Max speeds in mm per second
-      Planner::axis_steps_per_mm[XYZE_N],
-      Planner::steps_to_mm[XYZE_N];
+uint32_t Planner::max_acceleration_mm_per_s2[XYZE_N],    // (mm/s^2) M201 XYZE
+         Planner::max_acceleration_steps_per_s2[XYZE_N], // (steps/s^2) Derived from mm_per_s2
+         Planner::min_segment_time_us;                   // (¬µs) M205 B
+
+float Planner::max_feedrate_mm_s[XYZE_N],     // (mm/s) M203 XYZE - Max speeds
+      Planner::axis_steps_per_mm[XYZE_N],     // (steps) M92 XYZE - Steps per millimeter
+      Planner::steps_to_mm[XYZE_N],           // (mm) Millimeters per step
+      Planner::min_feedrate_mm_s,             // (mm/s) M205 S - Minimum linear feedrate
+      Planner::acceleration,                  // (mm/s^2) M204 S - Normal acceleration. DEFAULT ACCELERATION for all printing moves.
+      Planner::retract_acceleration,          // (mm/s^2) M204 R - Retract acceleration. Filament pull-back and push-forward while standing still in the other axes
+      Planner::travel_acceleration,           // (mm/s^2) M204 T - Travel acceleration. DEFAULT ACCELERATION for all NON printing moves.
+      Planner::max_jerk[XYZE],                // (mm/s^2) M205 XYZE - The largest speed change requiring no acceleration.
+      Planner::min_travel_feedrate_mm_s;      // (mm/s) M205 T - Minimum travel feedrate
+
+#if ENABLED(JUNCTION_DEVIATION)
+  float Planner::junction_deviation_mm;       // (mm) M205 J
+#endif
 
 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
 
 float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0); // The flow percentage and volumetric multiplier combine to scale E movement
 
 #if DISABLED(NO_VOLUMETRICS)
   float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
         Planner::volumetric_area_nominal = CIRCLE_AREA((DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5), // Nominal cross-sectional area
         Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
 #endif
 
-uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N],
-         Planner::max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
-
-uint32_t Planner::min_segment_time_us;
-
-// Initialized by settings.load()
-float Planner::min_feedrate_mm_s,
-      Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
-      Planner::retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
-      Planner::travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
-      Planner::max_jerk[XYZE],       // The largest speed change requiring no acceleration
-      Planner::min_travel_feedrate_mm_s;
-
 #if HAS_LEVELING
   bool Planner::leveling_active = false; // Flag that auto bed leveling is enabled
   #if ABL_PLANAR
     matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
   #endif
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
     float Planner::z_fade_height,      // Initialized by settings.load()
           Planner::inverse_z_fade_height,
           Planner::last_fade_z;
   #endif
@@ -2180,21 +2181,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
           #if ENABLED(JUNCTION_DEVIATION_INCLUDE_E)
             , unit_vec[E_AXIS] - previous_unit_vec[E_AXIS]
           #endif
         };
         // Convert delta vector to unit vector
         normalize_junction_vector(junction_unit_vec);
 
         const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec),
                     sin_theta_d2 = SQRT(0.5 * (1.0 - junction_cos_theta)); // Trig half angle identity. Always positive.
 
-        vmax_junction_sqr = (junction_acceleration * JUNCTION_DEVIATION_MM * sin_theta_d2) / (1.0 - sin_theta_d2);
+        vmax_junction_sqr = (junction_acceleration * junction_deviation_mm * sin_theta_d2) / (1.0 - sin_theta_d2);
         if (block->millimeters < 1.0) {
 
           // Fast acos approximation, minus the error bar to be safe
           const float junction_theta = (RADIANS(-40) * sq(junction_cos_theta) - RADIANS(50)) * junction_cos_theta + RADIANS(90) - 0.18;
 
           // If angle is greater than 135 degrees (octagon), find speed for approximate arc
           if (junction_theta > RADIANS(135)) {
             const float limit_sqr = block->millimeters / (RADIANS(180) - junction_theta) * junction_acceleration;
             NOMORE(vmax_junction_sqr, limit_sqr);
           }

commit 39a7e7720d0b14e7c55b65d7da7973b528d184c7
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jun 3 00:59:21 2018 -0300

    Adaptive multiaxis step smoothing
    
    - Stepper bugs fixed
    - Support MIXING_EXTRUDER with Linear Advance
    - Miscellaneous cleanup

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index af16e6d55f..d1e423c3d0 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -672,23 +672,23 @@ void Planner::init() {
           "=d" (r18),
           "+z" (ptab)
         :
         : "r0", "r1", "cc"
       );
 
       // Return the result
       return r11 | (uint16_t(r12) << 8) | (uint32_t(r13) << 16);
     }
   #else
-    // All the other 32 CPUs can easily perform the inverse using hardware division,
+    // All other 32-bit MPUs can easily do inverse using hardware division,
     // so we don't need to reduce precision or to use assembly language at all.
-    // This routine, for all the other archs, returns 0x100000000 / d ~= 0xFFFFFFFF / d
+    // This routine, for all other archs, returns 0x100000000 / d ~= 0xFFFFFFFF / d
     static FORCE_INLINE uint32_t get_period_inverse(const uint32_t d) { return 0xFFFFFFFF / d; }
   #endif
 #endif
 
 #define MINIMAL_STEP_RATE 120
 
 /**
  * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
  * by the provided factors.
  */
@@ -1639,24 +1639,30 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     block->steps[B_AXIS] = ABS(db);
     block->steps[C_AXIS] = ABS(dc);
   #endif
 
   block->steps[E_AXIS] = esteps;
   block->step_event_count = MAX4(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
-  // For a mixing extruder, get a magnified step_event_count for each
+  // For a mixing extruder, get a magnified esteps for each
   #if ENABLED(MIXING_EXTRUDER)
     for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
-      block->mix_event_count[i] = mixing_factor[i] * block->step_event_count;
+      block->mix_steps[i] = mixing_factor[i] * (
+        #if ENABLED(LIN_ADVANCE)
+          esteps
+        #else
+          block->step_event_count
+        #endif
+      );
   #endif
 
   #if FAN_COUNT > 0
     for (uint8_t i = 0; i < FAN_COUNT; i++) block->fan_speed[i] = fanSpeeds[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif

commit d82704354fc491c88c76dea6f48016b0687fd422
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jun 3 20:01:45 2018 -0300

    Increase the planner first block HOLD delay to 100mS

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 18d45af509..af16e6d55f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -87,21 +87,21 @@
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"
 #endif
 
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
 // Delay for delivery of first block to the stepper ISR, if the queue contains 2 or
 // fewer movements. The delay is measured in milliseconds, and must be less than 250ms
-#define BLOCK_DELAY_FOR_1ST_MOVE 50
+#define BLOCK_DELAY_FOR_1ST_MOVE 100
 
 Planner planner;
 
   // public:
 
 /**
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head,  // Index of the next block to be pushed

commit d3c02410a84b369443654ef77f925562e9b87830
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Fri Jun 1 21:02:22 2018 -0300

    [2.0.x] Small assorted collection of fixes and improvements (#10911)
    
    * Misc fixes and improvements
    
    - Get rid of most critical sections on the Serial port drivers for AVR and DUE. Proper usage of FIFOs should allow interrupts to stay enabled without harm to queuing and dequeuing.
      Also, with 8-bit indices (for AVR) and up to 32-bit indices (for ARM), there is no need to protect reads and writes to those indices.
    - Simplify the XON/XOFF logic quite a bit. Much cleaner now (both for AVR and ARM)
    - Prevent a race condition (edge case) that could happen when estimating the proper value for the stepper timer (by reading it) and writing the calculated value for the time to the next ISR by disabling interrupts in those critical and small sections of the code - The problem could lead to lost steps.
    - Fix dual endstops not properly homing bug (maybe).
    
    * Set position immediately when possible

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 1d358495a9..18d45af509 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2460,23 +2460,27 @@ void Planner::_set_position_mm(const float &a, const float &b, const float &c, c
   position[A_AXIS] = LROUND(a * axis_steps_per_mm[A_AXIS]),
   position[B_AXIS] = LROUND(b * axis_steps_per_mm[B_AXIS]),
   position[C_AXIS] = LROUND(c * axis_steps_per_mm[C_AXIS]),
   position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
   #if HAS_POSITION_FLOAT
     position_float[A_AXIS] = a;
     position_float[B_AXIS] = b;
     position_float[C_AXIS] = c;
     position_float[E_AXIS] = e;
   #endif
-  previous_nominal_speed_sqr = 0.0; // Resets planner junction speeds. Assumes start from rest.
-  ZERO(previous_speed);
-  buffer_sync_block();
+  if (has_blocks_queued()) {
+    //previous_nominal_speed_sqr = 0.0; // Reset planner junction speeds. Assume start from rest.
+    //ZERO(previous_speed);
+    buffer_sync_block();
+  }
+  else
+    stepper.set_position(position[A_AXIS], position[B_AXIS], position[C_AXIS], position[E_AXIS]);
 }
 
 void Planner::set_position_mm_kinematic(const float (&cart)[XYZE]) {
   #if PLANNER_LEVELING
     float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
     apply_leveling(raw);
   #else
     const float (&raw)[XYZE] = cart;
   #endif
   #if IS_KINEMATIC
@@ -2494,22 +2498,26 @@ void Planner::set_position_mm(const AxisEnum axis, const float &v) {
   #if ENABLED(DISTINCT_E_FACTORS)
     const uint8_t axis_index = axis + (axis == E_AXIS ? active_extruder : 0);
     last_extruder = active_extruder;
   #else
     const uint8_t axis_index = axis;
   #endif
   position[axis] = LROUND(v * axis_steps_per_mm[axis_index]);
   #if HAS_POSITION_FLOAT
     position_float[axis] = v;
   #endif
-  previous_speed[axis] = 0.0;
-  buffer_sync_block();
+  if (has_blocks_queued()) {
+    //previous_speed[axis] = 0.0;
+    buffer_sync_block();
+  }
+  else
+    stepper.set_position(axis, position[axis]);
 }
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define AXIS_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)
   #else
     #define AXIS_CONDITION true
   #endif
   uint32_t highest_rate = 1;

commit 2deff0d9b96e117fc03870169b52ac785d7bf430
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 31 20:09:53 2018 -0500

    Fix/Improve junction deviation
    
    - Respect axis max acceleration limits instead of forcing a fixed acceleration value.
    - The `junction_unit_vec` ensures proper handling of entry and exit speeds even when the axes involved have different limits.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 4676d32433..1d358495a9 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2159,33 +2159,44 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
                                   #endif
                                 ;
 
       // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
       if (junction_cos_theta > 0.999999) {
         // For a 0 degree acute junction, just set minimum junction speed.
         vmax_junction_sqr = sq(MINIMUM_PLANNER_SPEED);
       }
       else {
         NOLESS(junction_cos_theta, -0.999999); // Check for numerical round-off to avoid divide by zero.
-        const float sin_theta_d2 = SQRT(0.5 * (1.0 - junction_cos_theta)); // Trig half angle identity. Always positive.
 
-        // TODO: Technically, the acceleration used in calculation needs to be limited by the minimum of the
-        // two junctions. However, this shouldn't be a significant problem except in extreme circumstances.
-        vmax_junction_sqr = (JUNCTION_ACCELERATION * JUNCTION_DEVIATION_MM * sin_theta_d2) / (1.0 - sin_theta_d2);
+        float junction_unit_vec[JD_AXES] = {
+          unit_vec[X_AXIS] - previous_unit_vec[X_AXIS],
+          unit_vec[Y_AXIS] - previous_unit_vec[Y_AXIS],
+          unit_vec[Z_AXIS] - previous_unit_vec[Z_AXIS]
+          #if ENABLED(JUNCTION_DEVIATION_INCLUDE_E)
+            , unit_vec[E_AXIS] - previous_unit_vec[E_AXIS]
+          #endif
+        };
+        // Convert delta vector to unit vector
+        normalize_junction_vector(junction_unit_vec);
+
+        const float junction_acceleration = limit_value_by_axis_maximum(block->acceleration, junction_unit_vec),
+                    sin_theta_d2 = SQRT(0.5 * (1.0 - junction_cos_theta)); // Trig half angle identity. Always positive.
+
+        vmax_junction_sqr = (junction_acceleration * JUNCTION_DEVIATION_MM * sin_theta_d2) / (1.0 - sin_theta_d2);
         if (block->millimeters < 1.0) {
 
           // Fast acos approximation, minus the error bar to be safe
           const float junction_theta = (RADIANS(-40) * sq(junction_cos_theta) - RADIANS(50)) * junction_cos_theta + RADIANS(90) - 0.18;
 
           // If angle is greater than 135 degrees (octagon), find speed for approximate arc
           if (junction_theta > RADIANS(135)) {
-            const float limit_sqr = block->millimeters / (RADIANS(180) - junction_theta) * JUNCTION_ACCELERATION;
+            const float limit_sqr = block->millimeters / (RADIANS(180) - junction_theta) * junction_acceleration;
             NOMORE(vmax_junction_sqr, limit_sqr);
           }
         }
       }
 
       // Get the lowest speed
       vmax_junction_sqr = MIN3(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
       vmax_junction_sqr = 0.0;

commit 8f14ef855de42ac3535dd6b9b135162d8716dd14
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 28 19:24:51 2018 -0500

    More concise commentary in planner.cpp

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7d7e36982b..4676d32433 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -228,159 +228,100 @@ void Planner::init() {
     bed_level_matrix.set_to_identity();
   #endif
   clear_block_buffer();
   block_buffer_planned = 0;
   delay_before_delivering = 0;
 }
 
 #if ENABLED(S_CURVE_ACCELERATION)
 
   #ifdef __AVR__
-    // This routine, for AVR, returns 0x1000000 / d, but trying to get the inverse as
-    //  fast as possible. A fast converging iterative Newton-Raphson method is able to
-    //  reach full precision in just 1 iteration, and takes 211 cycles (worst case, mean
-    //  case is less, up to 30 cycles for small divisors), instead of the 500 cycles a
-    //  normal division would take.
-    //
-    // Inspired by the following page,
-    //  https://stackoverflow.com/questions/27801397/newton-raphson-division-with-big-integers
-    //
-    // Suppose we want to calculate
-    //  floor(2 ^ k / B)    where B is a positive integer
-    // Then
-    //  B must be <= 2^k, otherwise, the quotient is 0.
-    //
-    // The Newton - Raphson iteration for x = B / 2 ^ k yields:
-    //  q[n + 1] = q[n] * (2 - q[n] * B / 2 ^ k)
-    //
-    // We can rearrange it as:
-    //  q[n + 1] = q[n] * (2 ^ (k + 1) - q[n] * B) >> k
-    //
-    //  Each iteration of this kind requires only integer multiplications
-    // and bit shifts.
-    //  Does it converge to floor(2 ^ k / B) ?:  Not necessarily, but, in
-    // the worst case, it eventually alternates between floor(2 ^ k / B)
-    // and ceiling(2 ^ k / B)).
-    //  So we can use some not-so-clever test to see if we are in this
-    // case, and extract floor(2 ^ k / B).
-    //  Lastly, a simple but important optimization for this approach is to
-    // truncate multiplications (i.e.calculate only the higher bits of the
-    // product) in the early iterations of the Newton - Raphson method.The
-    // reason to do so, is that the results of the early iterations are far
-    // from the quotient, and it doesn't matter to perform them inaccurately.
-    //  Finally, we should pick a good starting value for x. Knowing how many
-    // digits the divisor has, we can estimate it:
-    //
-    // 2^k / x = 2 ^ log2(2^k / x)
-    // 2^k / x = 2 ^(log2(2^k)-log2(x))
-    // 2^k / x = 2 ^(k*log2(2)-log2(x))
-    // 2^k / x = 2 ^ (k-log2(x))
-    // 2^k / x >= 2 ^ (k-floor(log2(x)))
-    // floor(log2(x)) simply is the index of the most significant bit set.
-    //
-    //  If we could improve this estimation even further, then the number of
-    // iterations can be dropped quite a bit, thus saving valuable execution time.
-    //  The paper "Software Integer Division" by Thomas L.Rodeheffer, Microsoft
-    // Research, Silicon Valley,August 26, 2008, that is available at
-    // https://www.microsoft.com/en-us/research/wp-content/uploads/2008/08/tr-2008-141.pdf
-    // suggests , for its integer division algorithm, that using a table to supply the
-    // first 8 bits of precision, and due to the quadratic convergence nature of the
-    // Newton-Raphon iteration, then just 2 iterations should be enough to get
-    // maximum precision of the division.
-    //  If we precompute values of inverses for small denominator values, then
-    // just one Newton-Raphson iteration is enough to reach full precision
-    //  We will use the top 9 bits of the denominator as index.
-    //
-    //  The AVR assembly function is implementing the following C code, included
-    // here as reference:
-    //
-    // uint32_t get_period_inverse(uint32_t d) {
-    //  static const uint8_t inv_tab[256] = {
-    //    255,253,252,250,248,246,244,242,240,238,236,234,233,231,229,227,
-    //    225,224,222,220,218,217,215,213,212,210,208,207,205,203,202,200,
-    //    199,197,195,194,192,191,189,188,186,185,183,182,180,179,178,176,
-    //    175,173,172,170,169,168,166,165,164,162,161,160,158,157,156,154,
-    //    153,152,151,149,148,147,146,144,143,142,141,139,138,137,136,135,
-    //    134,132,131,130,129,128,127,126,125,123,122,121,120,119,118,117,
-    //    116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101,
-    //    100,99,98,97,96,95,94,93,92,91,90,89,88,88,87,86,
-    //    85,84,83,82,81,80,80,79,78,77,76,75,74,74,73,72,
-    //    71,70,70,69,68,67,66,66,65,64,63,62,62,61,60,59,
-    //    59,58,57,56,56,55,54,53,53,52,51,50,50,49,48,48,
-    //    47,46,46,45,44,43,43,42,41,41,40,39,39,38,37,37,
-    //    36,35,35,34,33,33,32,32,31,30,30,29,28,28,27,27,
-    //    26,25,25,24,24,23,22,22,21,21,20,19,19,18,18,17,
-    //    17,16,15,15,14,14,13,13,12,12,11,10,10,9,9,8,
-    //    8,7,7,6,6,5,5,4,4,3,3,2,2,1,0,0
-    //  };
-    //
-    //  // For small denominators, it is cheaper to directly store the result,
-    //  //  because those denominators would require 2 Newton-Raphson iterations
-    //  //  to converge to the required result precision. For bigger ones, just
-    //  //  ONE Newton-Raphson iteration is enough to get maximum precision!
-    //  static const uint32_t small_inv_tab[111] PROGMEM = {
-    //    16777216,16777216,8388608,5592405,4194304,3355443,2796202,2396745,2097152,1864135,1677721,1525201,1398101,1290555,1198372,1118481,
-    //    1048576,986895,932067,883011,838860,798915,762600,729444,699050,671088,645277,621378,599186,578524,559240,541200,
-    //    524288,508400,493447,479349,466033,453438,441505,430185,419430,409200,399457,390167,381300,372827,364722,356962,
-    //    349525,342392,335544,328965,322638,316551,310689,305040,299593,294337,289262,284359,279620,275036,270600,266305,
-    //    262144,258111,254200,250406,246723,243148,239674,236298,233016,229824,226719,223696,220752,217885,215092,212369,
-    //    209715,207126,204600,202135,199728,197379,195083,192841,190650,188508,186413,184365,182361,180400,178481,176602,
-    //    174762,172960,171196,169466,167772,166111,164482,162885,161319,159783,158275,156796,155344,153919,152520
-    //  };
-    //
-    //  // For small divisors, it is best to directly retrieve the results
-    //  if (d <= 110)
-    //    return pgm_read_dword(&small_inv_tab[d]);
-    //
-    //  // Compute initial estimation of 0x1000000/x -
-    //  // Get most significant bit set on divider
-    //  uint8_t idx = 0;
-    //  uint32_t nr = d;
-    //  if (!(nr & 0xFF0000)) {
-    //    nr <<= 8;
-    //    idx += 8;
-    //    if (!(nr & 0xFF0000)) {
-    //      nr <<= 8;
-    //      idx += 8;
-    //    }
-    //  }
-    //  if (!(nr & 0xF00000)) {
-    //    nr <<= 4;
-    //    idx += 4;
-    //  }
-    //  if (!(nr & 0xC00000)) {
-    //    nr <<= 2;
-    //    idx += 2;
-    //  }
-    //  if (!(nr & 0x800000)) {
-    //    nr <<= 1;
-    //    idx += 1;
-    //  }
-    //
-    //  // Isolate top 9 bits of the denominator, to be used as index into the initial estimation table
-    //  uint32_t tidx = nr >> 15;         // top 9 bits. bit8 is always set
-    //  uint32_t ie = inv_tab[tidx & 0xFF] + 256; // Get the table value. bit9 is always set
-    //  uint32_t x = idx <= 8 ? (ie >> (8 - idx)) : (ie << (idx - 8)); // Position the estimation at the proper place
-    //
-    //  // Now, refine estimation by newton-raphson. 1 iteration is enough
-    //  x = uint32_t((x * uint64_t((1 << 25) - x * d)) >> 24);
-    //
-    //  // Estimate remainder
-    //  uint32_t r = (1 << 24) - x * d;
-    //
-    //  // Check if we must adjust result
-    //  if (r >= d) x++;
-    //
-    //  // x holds the proper estimation
-    //  return uint32_t(x);
-    // }
-    //
+    /**
+     * This routine returns 0x1000000 / d, getting the inverse as fast as possible.
+     * A fast-converging iterative Newton-Raphson method can reach full precision in
+     * just 1 iteration, and takes 211 cycles (worst case; the mean case is less, up
+     * to 30 cycles for small divisors), instead of the 500 cycles a normal division
+     * would take.
+     *
+     * Inspired by the following page:
+     *  https://stackoverflow.com/questions/27801397/newton-raphson-division-with-big-integers
+     *
+     * Suppose we want to calculate  floor(2 ^ k / B)  where B is a positive integer
+     * Then, B must be <= 2^k, otherwise, the quotient is 0.
+     *
+     * The Newton - Raphson iteration for x = B / 2 ^ k yields:
+     *  q[n + 1] = q[n] * (2 - q[n] * B / 2 ^ k)
+     *
+     * This can be rearranged to:
+     *  q[n + 1] = q[n] * (2 ^ (k + 1) - q[n] * B) >> k
+     *
+     * Each iteration requires only integer multiplications and bit shifts.
+     * It doesn't necessarily converge to floor(2 ^ k / B) but in the worst case
+     * it eventually alternates between floor(2 ^ k / B) and ceil(2 ^ k / B).
+     * So it checks for this case and extracts floor(2 ^ k / B).
+     *
+     * A simple but important optimization for this approach is to truncate
+     * multiplications (i.e., calculate only the higher bits of the product) in the
+     * early iterations of the Newton - Raphson method. This is done so the results
+     * of the early iterations are far from the quotient. Then it doesn't matter if
+     * they are done inaccurately.
+     * It's important to pick a good starting value for x. Knowing how many
+     * digits the divisor has, it can be estimated:
+     *
+     *   2^k / x = 2 ^ log2(2^k / x)
+     *   2^k / x = 2 ^(log2(2^k)-log2(x))
+     *   2^k / x = 2 ^(k*log2(2)-log2(x))
+     *   2^k / x = 2 ^ (k-log2(x))
+     *   2^k / x >= 2 ^ (k-floor(log2(x)))
+     *   floor(log2(x)) is simply the index of the most significant bit set.
+     *
+     * If this estimation can be improved even further the number of iterations can be
+     * reduced a lot, saving valuable execution time.
+     * The paper "Software Integer Division" by Thomas L.Rodeheffer, Microsoft
+     * Research, Silicon Valley,August 26, 2008, available at
+     * https://www.microsoft.com/en-us/research/wp-content/uploads/2008/08/tr-2008-141.pdf
+     * suggests, for its integer division algorithm, using a table to supply the first
+     * 8 bits of precision, then, due to the quadratic convergence nature of the
+     * Newton-Raphon iteration, just 2 iterations should be enough to get maximum
+     * precision of the division.
+     * By precomputing values of inverses for small denominator values, just one
+     * Newton-Raphson iteration is enough to reach full precision.
+     * This code uses the top 9 bits of the denominator as index.
+     *
+     * The AVR assembly function implements this C code using the data below:
+     *
+     *  // For small divisors, it is best to directly retrieve the results
+     *  if (d <= 110) return pgm_read_dword(&small_inv_tab[d]);
+     *
+     *  // Compute initial estimation of 0x1000000/x -
+     *  // Get most significant bit set on divider
+     *  uint8_t idx = 0;
+     *  uint32_t nr = d;
+     *  if (!(nr & 0xFF0000)) {
+     *    nr <<= 8; idx += 8;
+     *    if (!(nr & 0xFF0000)) { nr <<= 8; idx += 8; }
+     *  }
+     *  if (!(nr & 0xF00000)) { nr <<= 4; idx += 4; }
+     *  if (!(nr & 0xC00000)) { nr <<= 2; idx += 2; }
+     *  if (!(nr & 0x800000)) { nr <<= 1; idx += 1; }
+     *
+     *  // Isolate top 9 bits of the denominator, to be used as index into the initial estimation table
+     *  uint32_t tidx = nr >> 15,                                       // top 9 bits. bit8 is always set
+     *           ie = inv_tab[tidx & 0xFF] + 256,                       // Get the table value. bit9 is always set
+     *           x = idx <= 8 ? (ie >> (8 - idx)) : (ie << (idx - 8));  // Position the estimation at the proper place
+     *
+     *  x = uint32_t((x * uint64_t(_BV(25) - x * d)) >> 24);            // Refine estimation by newton-raphson. 1 iteration is enough
+     *  const uint32_t r = _BV(24) - x * d;                             // Estimate remainder
+     *  if (r >= d) x++;                                                // Check whether to adjust result
+     *  return uint32_t(x);                                             // x holds the proper estimation
+     *
+     */
     static uint32_t get_period_inverse(uint32_t d) {
 
       static const uint8_t inv_tab[256] PROGMEM = {
         255,253,252,250,248,246,244,242,240,238,236,234,233,231,229,227,
         225,224,222,220,218,217,215,213,212,210,208,207,205,203,202,200,
         199,197,195,194,192,191,189,188,186,185,183,182,180,179,178,176,
         175,173,172,170,169,168,166,165,164,162,161,160,158,157,156,154,
         153,152,151,149,148,147,146,144,143,142,141,139,138,137,136,135,
         134,132,131,130,129,128,127,126,125,123,122,121,120,119,118,117,
         116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101,
@@ -402,27 +343,26 @@ void Planner::init() {
         16777216,16777216,8388608,5592405,4194304,3355443,2796202,2396745,2097152,1864135,1677721,1525201,1398101,1290555,1198372,1118481,
         1048576,986895,932067,883011,838860,798915,762600,729444,699050,671088,645277,621378,599186,578524,559240,541200,
         524288,508400,493447,479349,466033,453438,441505,430185,419430,409200,399457,390167,381300,372827,364722,356962,
         349525,342392,335544,328965,322638,316551,310689,305040,299593,294337,289262,284359,279620,275036,270600,266305,
         262144,258111,254200,250406,246723,243148,239674,236298,233016,229824,226719,223696,220752,217885,215092,212369,
         209715,207126,204600,202135,199728,197379,195083,192841,190650,188508,186413,184365,182361,180400,178481,176602,
         174762,172960,171196,169466,167772,166111,164482,162885,161319,159783,158275,156796,155344,153919,152520
       };
 
       // For small divisors, it is best to directly retrieve the results
-      if (d <= 110)
-        return pgm_read_dword(&small_inv_tab[d]);
+      if (d <= 110) return pgm_read_dword(&small_inv_tab[d]);
 
-      register uint8_t r8 = d & 0xFF;
-      register uint8_t r9 = (d >> 8) & 0xFF;
-      register uint8_t r10 = (d >> 16) & 0xFF;
-      register uint8_t r2,r3,r4,r5,r6,r7,r11,r12,r13,r14,r15,r16,r17,r18;
+      register uint8_t r8 = d & 0xFF,
+                       r9 = (d >> 8) & 0xFF,
+                       r10 = (d >> 16) & 0xFF,
+                       r2,r3,r4,r5,r6,r7,r11,r12,r13,r14,r15,r16,r17,r18;
       register const uint8_t* ptab = inv_tab;
 
       __asm__ __volatile__(
         // %8:%7:%6 = interval
         // r31:r30: MUST be those registers, and they must point to the inv_tab
 
         A("clr %13")                       // %13 = 0
 
         // Now we must compute
         // result = 0xFFFFFF / d

commit 931ab4ec403092db36c44fb4ffd780e3d08184c0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 26 02:19:28 2018 -0500

    Rename Junction Deviation options

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index f480c0a90d..7d7e36982b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2223,29 +2223,29 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       if (junction_cos_theta > 0.999999) {
         // For a 0 degree acute junction, just set minimum junction speed.
         vmax_junction_sqr = sq(MINIMUM_PLANNER_SPEED);
       }
       else {
         NOLESS(junction_cos_theta, -0.999999); // Check for numerical round-off to avoid divide by zero.
         const float sin_theta_d2 = SQRT(0.5 * (1.0 - junction_cos_theta)); // Trig half angle identity. Always positive.
 
         // TODO: Technically, the acceleration used in calculation needs to be limited by the minimum of the
         // two junctions. However, this shouldn't be a significant problem except in extreme circumstances.
-        vmax_junction_sqr = (JUNCTION_ACCELERATION_FACTOR * JUNCTION_DEVIATION_FACTOR * sin_theta_d2) / (1.0 - sin_theta_d2);
+        vmax_junction_sqr = (JUNCTION_ACCELERATION * JUNCTION_DEVIATION_MM * sin_theta_d2) / (1.0 - sin_theta_d2);
         if (block->millimeters < 1.0) {
 
           // Fast acos approximation, minus the error bar to be safe
           const float junction_theta = (RADIANS(-40) * sq(junction_cos_theta) - RADIANS(50)) * junction_cos_theta + RADIANS(90) - 0.18;
 
           // If angle is greater than 135 degrees (octagon), find speed for approximate arc
           if (junction_theta > RADIANS(135)) {
-            const float limit_sqr = block->millimeters / (RADIANS(180) - junction_theta) * JUNCTION_ACCELERATION_FACTOR;
+            const float limit_sqr = block->millimeters / (RADIANS(180) - junction_theta) * JUNCTION_ACCELERATION;
             NOMORE(vmax_junction_sqr, limit_sqr);
           }
         }
       }
 
       // Get the lowest speed
       vmax_junction_sqr = MIN3(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
       vmax_junction_sqr = 0.0;

commit aaaf09bda27eff38d773b4b73925442f61d34866
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 26 02:02:39 2018 -0500

    BEZIER_JERK_CONTROL => S_CURVE_ACCELERATION

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index f56c581c9a..f480c0a90d 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -225,21 +225,21 @@ void Planner::init() {
   ZERO(previous_speed);
   previous_nominal_speed_sqr = 0.0;
   #if ABL_PLANAR
     bed_level_matrix.set_to_identity();
   #endif
   clear_block_buffer();
   block_buffer_planned = 0;
   delay_before_delivering = 0;
 }
 
-#if ENABLED(BEZIER_JERK_CONTROL)
+#if ENABLED(S_CURVE_ACCELERATION)
 
   #ifdef __AVR__
     // This routine, for AVR, returns 0x1000000 / d, but trying to get the inverse as
     //  fast as possible. A fast converging iterative Newton-Raphson method is able to
     //  reach full precision in just 1 iteration, and takes 211 cycles (worst case, mean
     //  case is less, up to 30 cycles for small divisors), instead of the 500 cycles a
     //  normal division would take.
     //
     // Inspired by the following page,
     //  https://stackoverflow.com/questions/27801397/newton-raphson-division-with-big-integers
@@ -754,75 +754,75 @@ void Planner::init() {
  */
 void Planner::calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor) {
 
   uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
            final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
 
   // Limit minimal step rate (Otherwise the timer will overflow.)
   NOLESS(initial_rate, uint32_t(MINIMAL_STEP_RATE));
   NOLESS(final_rate, uint32_t(MINIMAL_STEP_RATE));
 
-  #if ENABLED(BEZIER_JERK_CONTROL)
+  #if ENABLED(S_CURVE_ACCELERATION)
     uint32_t cruise_rate = initial_rate;
   #endif
 
   const int32_t accel = block->acceleration_steps_per_s2;
 
           // Steps required for acceleration, deceleration to/from nominal rate
   uint32_t accelerate_steps = CEIL(estimate_acceleration_distance(initial_rate, block->nominal_rate, accel)),
            decelerate_steps = FLOOR(estimate_acceleration_distance(block->nominal_rate, final_rate, -accel));
           // Steps between acceleration and deceleration, if any
   int32_t plateau_steps = block->step_event_count - accelerate_steps - decelerate_steps;
 
   // Does accelerate_steps + decelerate_steps exceed step_event_count?
   // Then we can't possibly reach the nominal rate, there will be no cruising.
   // Use intersection_distance() to calculate accel / braking time in order to
   // reach the final_rate exactly at the end of this block.
   if (plateau_steps < 0) {
     const float accelerate_steps_float = CEIL(intersection_distance(initial_rate, final_rate, accel, block->step_event_count));
     accelerate_steps = MIN(uint32_t(MAX(accelerate_steps_float, 0)), block->step_event_count);
     plateau_steps = 0;
 
-    #if ENABLED(BEZIER_JERK_CONTROL)
+    #if ENABLED(S_CURVE_ACCELERATION)
       // We won't reach the cruising rate. Let's calculate the speed we will reach
       cruise_rate = final_speed(initial_rate, accel, accelerate_steps);
     #endif
   }
-  #if ENABLED(BEZIER_JERK_CONTROL)
+  #if ENABLED(S_CURVE_ACCELERATION)
     else // We have some plateau time, so the cruise rate will be the nominal rate
       cruise_rate = block->nominal_rate;
   #endif
 
   // block->accelerate_until = accelerate_steps;
   // block->decelerate_after = accelerate_steps+plateau_steps;
 
-  #if ENABLED(BEZIER_JERK_CONTROL)
+  #if ENABLED(S_CURVE_ACCELERATION)
     // Jerk controlled speed requires to express speed versus time, NOT steps
     uint32_t acceleration_time = ((float)(cruise_rate - initial_rate) / accel) * (HAL_STEPPER_TIMER_RATE),
              deceleration_time = ((float)(cruise_rate - final_rate) / accel) * (HAL_STEPPER_TIMER_RATE);
 
     // And to offload calculations from the ISR, we also calculate the inverse of those times here
     uint32_t acceleration_time_inverse = get_period_inverse(acceleration_time);
     uint32_t deceleration_time_inverse = get_period_inverse(deceleration_time);
 
   #endif
 
   // Fill variables used by the stepper in a critical section
   const bool was_enabled = STEPPER_ISR_ENABLED();
   if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
 
   // Don't update variables if block is busy: It is being interpreted by the planner
   if (!TEST(block->flag, BLOCK_BIT_BUSY)) {
     block->accelerate_until = accelerate_steps;
     block->decelerate_after = accelerate_steps + plateau_steps;
     block->initial_rate = initial_rate;
-    #if ENABLED(BEZIER_JERK_CONTROL)
+    #if ENABLED(S_CURVE_ACCELERATION)
       block->acceleration_time = acceleration_time;
       block->deceleration_time = deceleration_time;
       block->acceleration_time_inverse = acceleration_time_inverse;
       block->deceleration_time_inverse = deceleration_time_inverse;
       block->cruise_rate = cruise_rate;
     #endif
     block->final_rate = final_rate;
   }
   if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
 }
@@ -2129,21 +2129,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     }
     else {
       LIMIT_ACCEL_FLOAT(A_AXIS, 0);
       LIMIT_ACCEL_FLOAT(B_AXIS, 0);
       LIMIT_ACCEL_FLOAT(C_AXIS, 0);
       LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
-  #if DISABLED(BEZIER_JERK_CONTROL)
+  #if DISABLED(S_CURVE_ACCELERATION)
     block->acceleration_rate = (uint32_t)(accel * (4096.0 * 4096.0 / (HAL_STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
       block->advance_speed = (HAL_STEPPER_TIMER_RATE) / (extruder_advance_K * block->e_D_ratio * block->acceleration * axis_steps_per_mm[E_AXIS_N]);
       #if ENABLED(LA_DEBUG)
         if (extruder_advance_K * block->e_D_ratio * block->acceleration * 2 < SQRT(block->nominal_speed_sqr) * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");

commit 435ecb6b67e285becad4e6ca8375ffc8b5cb6025
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 20 22:20:11 2018 -0500

    Followup to stepper/planner refactor

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 8644a69f0e..f56c581c9a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -955,21 +955,21 @@ void Planner::reverse_pass() {
       reverse_pass_kernel(current, next);
       next = current;
     }
 
     // Advance to the next
     block_index = prev_block_index(block_index);
   }
 }
 
 // The kernel called by recalculate() when scanning the plan from first to last entry.
-void Planner::forward_pass_kernel(const block_t * const previous, block_t* const current, uint8_t block_index) {
+void Planner::forward_pass_kernel(const block_t* const previous, block_t* const current, const uint8_t block_index) {
   if (previous) {
     // If the previous block is an acceleration block, too short to complete the full speed
     // change, adjust the entry speed accordingly. Entry speeds have already been reset,
     // maximized, and reverse-planned. If nominal length is set, max junction speed is
     // guaranteed to be reached. No need to recheck.
     if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH) &&
       previous->entry_speed_sqr < current->entry_speed_sqr) {
 
       // Compute the maximum allowable speed
       const float new_entry_speed_sqr = max_allowable_speed_sqr(-previous->acceleration, previous->entry_speed_sqr, previous->millimeters);
@@ -1579,21 +1579,21 @@ bool Planner::_buffer_steps(const int32_t (&target)[XYZE]
  *
  * Fills a new linear movement in the block (in terms of steps).
  *
  *  target      - target position in steps units
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *
  * Returns true is movement is acceptable, false otherwise
  */
 bool Planner::_populate_block(block_t * const block, bool split_move,
-    const int32_t (&target)[XYZE]
+  const int32_t (&target)[XYZE]
   #if HAS_POSITION_FLOAT
     , const float (&target_float)[XYZE]
   #endif
   , float fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
   const int32_t da = target[A_AXIS] - position[A_AXIS],
                 db = target[B_AXIS] - position[B_AXIS],
                 dc = target[C_AXIS] - position[C_AXIS];
 
@@ -2227,21 +2227,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
       else {
         NOLESS(junction_cos_theta, -0.999999); // Check for numerical round-off to avoid divide by zero.
         const float sin_theta_d2 = SQRT(0.5 * (1.0 - junction_cos_theta)); // Trig half angle identity. Always positive.
 
         // TODO: Technically, the acceleration used in calculation needs to be limited by the minimum of the
         // two junctions. However, this shouldn't be a significant problem except in extreme circumstances.
         vmax_junction_sqr = (JUNCTION_ACCELERATION_FACTOR * JUNCTION_DEVIATION_FACTOR * sin_theta_d2) / (1.0 - sin_theta_d2);
         if (block->millimeters < 1.0) {
 
           // Fast acos approximation, minus the error bar to be safe
-          float junction_theta = (RADIANS(-40) * sq(junction_cos_theta) - RADIANS(50)) * junction_cos_theta + RADIANS(90) - 0.18;
+          const float junction_theta = (RADIANS(-40) * sq(junction_cos_theta) - RADIANS(50)) * junction_cos_theta + RADIANS(90) - 0.18;
 
           // If angle is greater than 135 degrees (octagon), find speed for approximate arc
           if (junction_theta > RADIANS(135)) {
             const float limit_sqr = block->millimeters / (RADIANS(180) - junction_theta) * JUNCTION_ACCELERATION_FACTOR;
             NOMORE(vmax_junction_sqr, limit_sqr);
           }
         }
       }
 
       // Get the lowest speed

commit 569df3fc0ccb8b000cc56dd55e6369008ed3f7a2
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 16 04:08:43 2018 -0300

    Fix interrupt-based endstop detection
    
    - Also implemented real endstop reading on interrupt.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 0171f3d21c..8644a69f0e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -751,22 +751,22 @@ void Planner::init() {
 /**
  * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
  * by the provided factors.
  */
 void Planner::calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor) {
 
   uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
            final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
 
   // Limit minimal step rate (Otherwise the timer will overflow.)
-  NOLESS(initial_rate, MINIMAL_STEP_RATE);
-  NOLESS(final_rate, MINIMAL_STEP_RATE);
+  NOLESS(initial_rate, uint32_t(MINIMAL_STEP_RATE));
+  NOLESS(final_rate, uint32_t(MINIMAL_STEP_RATE));
 
   #if ENABLED(BEZIER_JERK_CONTROL)
     uint32_t cruise_rate = initial_rate;
   #endif
 
   const int32_t accel = block->acceleration_steps_per_s2;
 
           // Steps required for acceleration, deceleration to/from nominal rate
   uint32_t accelerate_steps = CEIL(estimate_acceleration_distance(initial_rate, block->nominal_rate, accel)),
            decelerate_steps = FLOOR(estimate_acceleration_distance(block->nominal_rate, final_rate, -accel));
@@ -1460,37 +1460,22 @@ void Planner::quick_stop() {
   cleaning_buffer_counter = 1000;
 
   // Reenable Stepper ISR
   if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
 
   // And stop the stepper ISR
   stepper.quick_stop();
 }
 
 void Planner::endstop_triggered(const AxisEnum axis) {
-
-  /*NB: This will be called via endstops.update()
-    and endstops.update() can be called from the temperature
-    ISR. So Stepper interrupts are enabled */
-
-  // Disable stepper ISR
-  bool stepper_isr_enabled = STEPPER_ISR_ENABLED();
-  DISABLE_STEPPER_DRIVER_INTERRUPT();
-
-  // Record stepper position
+  // Record stepper position and discard the current block
   stepper.endstop_triggered(axis);
-
-  // Discard the active block that led to the trigger
-  discard_current_block();
-
-  // Reenable stepper ISR if it was enabled
-  if (stepper_isr_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
 }
 
 float Planner::triggered_position_mm(const AxisEnum axis) {
   return stepper.triggered_position(axis) * steps_to_mm[axis];
 }
 
 void Planner::finish_and_disable() {
   while (has_blocks_queued() || cleaning_buffer_counter) idle();
   disable_all_steppers();
 }
@@ -1675,21 +1660,21 @@ bool Planner::_populate_block(block_t * const block, bool split_move,
     if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
     if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
   #else
     if (da < 0) SBI(dm, X_AXIS);
     if (db < 0) SBI(dm, Y_AXIS);
     if (dc < 0) SBI(dm, Z_AXIS);
   #endif
   if (de < 0) SBI(dm, E_AXIS);
 
   const float esteps_float = de * e_factor[extruder];
-  const int32_t esteps = ABS(esteps_float) + 0.5;
+  const uint32_t esteps = ABS(esteps_float) + 0.5;
 
   // Clear all flags, including the "busy" bit
   block->flag = 0x00;
 
   // Set direction bits
   block->direction_bits = dm;
 
   // Number of steps for each axis
   // See http://www.corexy.com/theory.html
   #if CORE_IS_XY

commit a4af975873c7b0c75d986cb829eb5d869a4a6b8e
Author: etagle <ejtagle@hotmail.com>
Date:   Fri May 18 04:04:01 2018 -0300

    Fix planner block optimization
    
    - Fixed the planner incorrectly avoiding optimization of the block following the active one.
    - Added extra conditions to terminate planner early and avoid redundant computations.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 78634f7994..0171f3d21c 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -100,21 +100,22 @@ Planner planner;
 
   // public:
 
 /**
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head,  // Index of the next block to be pushed
                  Planner::block_buffer_tail;  // Index of the busy block, if any
 uint16_t Planner::cleaning_buffer_counter;    // A counter to disable queuing of blocks
-uint8_t Planner::delay_before_delivering;     // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
+uint8_t Planner::delay_before_delivering,     // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
+        Planner::block_buffer_planned;        // Index of the optimally planned block
 
 float Planner::max_feedrate_mm_s[XYZE_N],   // Max speeds in mm per second
       Planner::axis_steps_per_mm[XYZE_N],
       Planner::steps_to_mm[XYZE_N];
 
 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
 #if ENABLED(DISTINCT_E_FACTORS)
@@ -220,20 +221,21 @@ void Planner::init() {
   ZERO(position);
   #if HAS_POSITION_FLOAT
     ZERO(position_float);
   #endif
   ZERO(previous_speed);
   previous_nominal_speed_sqr = 0.0;
   #if ABL_PLANAR
     bed_level_matrix.set_to_identity();
   #endif
   clear_block_buffer();
+  block_buffer_planned = 0;
   delay_before_delivering = 0;
 }
 
 #if ENABLED(BEZIER_JERK_CONTROL)
 
   #ifdef __AVR__
     // This routine, for AVR, returns 0x1000000 / d, but trying to get the inverse as
     //  fast as possible. A fast converging iterative Newton-Raphson method is able to
     //  reach full precision in just 1 iteration, and takes 211 cycles (worst case, mean
     //  case is less, up to 30 cycles for small divisors), instead of the 500 cycles a
@@ -818,20 +820,82 @@ void Planner::calculate_trapezoid_for_block(block_t* const block, const float &e
       block->deceleration_time = deceleration_time;
       block->acceleration_time_inverse = acceleration_time_inverse;
       block->deceleration_time_inverse = deceleration_time_inverse;
       block->cruise_rate = cruise_rate;
     #endif
     block->final_rate = final_rate;
   }
   if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
 }
 
+/*                            PLANNER SPEED DEFINITION
+                                     +--------+   <- current->nominal_speed
+                                    /          \
+         current->entry_speed ->   +            \
+                                   |             + <- next->entry_speed (aka exit speed)
+                                   +-------------+
+                                       time -->
+
+  Recalculates the motion plan according to the following basic guidelines:
+
+    1. Go over every feasible block sequentially in reverse order and calculate the junction speeds
+        (i.e. current->entry_speed) such that:
+      a. No junction speed exceeds the pre-computed maximum junction speed limit or nominal speeds of
+         neighboring blocks.
+      b. A block entry speed cannot exceed one reverse-computed from its exit speed (next->entry_speed)
+         with a maximum allowable deceleration over the block travel distance.
+      c. The last (or newest appended) block is planned from a complete stop (an exit speed of zero).
+    2. Go over every block in chronological (forward) order and dial down junction speed values if
+      a. The exit speed exceeds the one forward-computed from its entry speed with the maximum allowable
+         acceleration over the block travel distance.
+
+  When these stages are complete, the planner will have maximized the velocity profiles throughout the all
+  of the planner blocks, where every block is operating at its maximum allowable acceleration limits. In
+  other words, for all of the blocks in the planner, the plan is optimal and no further speed improvements
+  are possible. If a new block is added to the buffer, the plan is recomputed according to the said
+  guidelines for a new optimal plan.
+
+  To increase computational efficiency of these guidelines, a set of planner block pointers have been
+  created to indicate stop-compute points for when the planner guidelines cannot logically make any further
+  changes or improvements to the plan when in normal operation and new blocks are streamed and added to the
+  planner buffer. For example, if a subset of sequential blocks in the planner have been planned and are
+  bracketed by junction velocities at their maximums (or by the first planner block as well), no new block
+  added to the planner buffer will alter the velocity profiles within them. So we no longer have to compute
+  them. Or, if a set of sequential blocks from the first block in the planner (or a optimal stop-compute
+  point) are all accelerating, they are all optimal and can not be altered by a new block added to the
+  planner buffer, as this will only further increase the plan speed to chronological blocks until a maximum
+  junction velocity is reached. However, if the operational conditions of the plan changes from infrequently
+  used feed holds or feedrate overrides, the stop-compute pointers will be reset and the entire plan is
+  recomputed as stated in the general guidelines.
+
+  Planner buffer index mapping:
+  - block_buffer_tail: Points to the beginning of the planner buffer. First to be executed or being executed.
+  - block_buffer_head: Points to the buffer block after the last block in the buffer. Used to indicate whether
+      the buffer is full or empty. As described for standard ring buffers, this block is always empty.
+  - block_buffer_planned: Points to the first buffer block after the last optimally planned block for normal
+      streaming operating conditions. Use for planning optimizations by avoiding recomputing parts of the
+      planner buffer that don't change with the addition of a new block, as describe above. In addition,
+      this block can never be less than block_buffer_tail and will always be pushed forward and maintain
+      this requirement when encountered by the plan_discard_current_block() routine during a cycle.
+
+  NOTE: Since the planner only computes on what's in the planner buffer, some motions with lots of short
+  line segments, like G2/3 arcs or complex curves, may seem to move slow. This is because there simply isn't
+  enough combined distance traveled in the entire buffer to accelerate up to the nominal speed and then
+  decelerate to a complete stop at the end of the buffer, as stated by the guidelines. If this happens and
+  becomes an annoyance, there are a few simple solutions: (1) Maximize the machine acceleration. The planner
+  will be able to compute higher velocity profiles within the same combined distance. (2) Maximize line
+  motion(s) distance per block to a desired tolerance. The more combined distance the planner has to use,
+  the faster it can go. (3) Maximize the planner buffer size. This also will increase the combined distance
+  for the planner to compute over. It also increases the number of computations the planner has to perform
+  to compute an optimal plan, so select carefully.
+*/
+
 // The kernel called by recalculate() when scanning the plan from last to first entry.
 void Planner::reverse_pass_kernel(block_t* const current, const block_t * const next) {
   if (current) {
     // If entry speed is already at the maximum entry speed, and there was no change of speed
     // in the next block, there is no need to recheck. Block is cruising and there is no need to
     // compute anything for this block,
     // If not, block entry speed needs to be recalculated to ensure maximum possible planned speed.
     const float max_entry_speed_sqr = current->max_entry_speed_sqr;
 
     // Compute maximum entry speed decelerating over the current block from its exit speed.
@@ -844,100 +908,141 @@ void Planner::reverse_pass_kernel(block_t* const current, const block_t * const
       // junction speeds in deceleration and acceleration, respectively. This is due to how the current
       // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
       // the reverse and forward planners, the corresponding block junction speed will always be at the
       // the maximum junction speed and may always be ignored for any speed reduction checks.
 
       const float new_entry_speed_sqr = TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH)
         ? max_entry_speed_sqr
         : MIN(max_entry_speed_sqr, max_allowable_speed_sqr(-current->acceleration, next ? next->entry_speed_sqr : sq(MINIMUM_PLANNER_SPEED), current->millimeters));
       if (current->entry_speed_sqr != new_entry_speed_sqr) {
         current->entry_speed_sqr = new_entry_speed_sqr;
+
+        // Need to recalculate the block speed
         SBI(current->flag, BLOCK_BIT_RECALCULATE);
       }
     }
   }
 }
 
 /**
  * recalculate() needs to go over the current plan twice.
  * Once in reverse and once forward. This implements the reverse pass.
  */
 void Planner::reverse_pass() {
-  if (movesplanned() > 2) {
-    const uint8_t endnr = next_block_index(block_buffer_tail); // tail is running. tail+1 shouldn't be altered because it's connected to the running block.
-    uint8_t blocknr = prev_block_index(block_buffer_head);
+  // Initialize block index to the last block in the planner buffer.
+  uint8_t block_index = prev_block_index(block_buffer_head);
+
+  // Read the index of the last buffer planned block.
+  // The ISR may change it so get a stable local copy.
+  uint8_t planned_block_index = block_buffer_planned;
+
+  // If there was a race condition and block_buffer_planned was incremented
+  //  or was pointing at the head (queue empty) break loop now and avoid
+  //  planning already consumed blocks
+  if (planned_block_index == block_buffer_head) return;
+
+  // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
+  // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
+  // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
+  block_t *current;
+  const block_t *next = NULL;
+  while (block_index != planned_block_index) {
 
     // Perform the reverse pass
-    block_t *current, *next = NULL;
-    while (blocknr != endnr) {
-      // Perform the reverse pass - Only consider non sync blocks
-      current = &block_buffer[blocknr];
-      if (!TEST(current->flag, BLOCK_BIT_SYNC_POSITION)) {
-        reverse_pass_kernel(current, next);
-        next = current;
-      }
-      // Advance to the next
-      blocknr = prev_block_index(blocknr);
+    current = &block_buffer[block_index];
+
+    // Only consider non sync blocks
+    if (!TEST(current->flag, BLOCK_BIT_SYNC_POSITION)) {
+      reverse_pass_kernel(current, next);
+      next = current;
     }
+
+    // Advance to the next
+    block_index = prev_block_index(block_index);
   }
 }
 
 // The kernel called by recalculate() when scanning the plan from first to last entry.
-void Planner::forward_pass_kernel(const block_t * const previous, block_t* const current) {
+void Planner::forward_pass_kernel(const block_t * const previous, block_t* const current, uint8_t block_index) {
   if (previous) {
     // If the previous block is an acceleration block, too short to complete the full speed
     // change, adjust the entry speed accordingly. Entry speeds have already been reset,
     // maximized, and reverse-planned. If nominal length is set, max junction speed is
     // guaranteed to be reached. No need to recheck.
-    if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH)) {
-      if (previous->entry_speed_sqr < current->entry_speed_sqr) {
-        // Compute the maximum allowable speed
-        const float new_entry_speed_sqr = max_allowable_speed_sqr(-previous->acceleration, previous->entry_speed_sqr, previous->millimeters);
-        // If true, current block is full-acceleration
-        if (current->entry_speed_sqr > new_entry_speed_sqr) {
-          // Always <= max_entry_speed_sqr. Backward pass sets this.
-          current->entry_speed_sqr = new_entry_speed_sqr;
-          SBI(current->flag, BLOCK_BIT_RECALCULATE);
-        }
+    if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH) &&
+      previous->entry_speed_sqr < current->entry_speed_sqr) {
+
+      // Compute the maximum allowable speed
+      const float new_entry_speed_sqr = max_allowable_speed_sqr(-previous->acceleration, previous->entry_speed_sqr, previous->millimeters);
+
+      // If true, current block is full-acceleration and we can move the planned pointer forward.
+      if (new_entry_speed_sqr < current->entry_speed_sqr) {
+
+        // Always <= max_entry_speed_sqr. Backward pass sets this.
+        current->entry_speed_sqr = new_entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass sets this.
+
+        // Set optimal plan pointer.
+        block_buffer_planned = block_index;
+
+        // And mark we need to recompute the trapezoidal shape
+        SBI(current->flag, BLOCK_BIT_RECALCULATE);
       }
     }
+
+    // Any block set at its maximum entry speed also creates an optimal plan up to this
+    // point in the buffer. When the plan is bracketed by either the beginning of the
+    // buffer and a maximum entry speed or two maximum entry speeds, every block in between
+    // cannot logically be further improved. Hence, we don't have to recompute them anymore.
+    if (current->entry_speed_sqr == current->max_entry_speed_sqr)
+      block_buffer_planned = block_index;
   }
 }
 
 /**
  * recalculate() needs to go over the current plan twice.
  * Once in reverse and once forward. This implements the forward pass.
  */
 void Planner::forward_pass() {
-  const uint8_t endnr = block_buffer_head;
-  uint8_t blocknr = block_buffer_tail;
-
-  // Perform the forward pass
-  block_t *current, *previous = NULL;
-  while (blocknr != endnr) {
-    // Perform the forward pass - Only consider non-sync blocks
-    current = &block_buffer[blocknr];
+
+  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
+  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
+
+  // Begin at buffer planned pointer. Note that block_buffer_planned can be modified
+  //  by the stepper ISR,  so read it ONCE. It it guaranteed that block_buffer_planned
+  //  will never lead head, so the loop is safe to execute. Also note that the forward
+  //  pass will never modify the values at the tail.
+  uint8_t block_index = block_buffer_planned;
+
+  block_t *current;
+  const block_t * previous = NULL;
+  while (block_index != block_buffer_head) {
+
+    // Perform the forward pass
+    current = &block_buffer[block_index];
+
+    // Skip SYNC blocks
     if (!TEST(current->flag, BLOCK_BIT_SYNC_POSITION)) {
-      forward_pass_kernel(previous, current);
+      forward_pass_kernel(previous, current, block_index);
       previous = current;
     }
     // Advance to the previous
-    blocknr = next_block_index(blocknr);
+    block_index = next_block_index(block_index);
   }
 }
 
 /**
  * Recalculate the trapezoid speed profiles for all blocks in the plan
  * according to the entry_factor for each junction. Must be called by
  * recalculate() after updating the blocks.
  */
 void Planner::recalculate_trapezoids() {
+  // The tail may be changed by the ISR so get a local copy.
   uint8_t block_index = block_buffer_tail;
 
   // As there could be a sync block in the head of the queue, and the next loop must not
   // recalculate the head block (as it needs to be specially handled), scan backwards until
   // we find the first non SYNC block
   uint8_t head_block_index = block_buffer_head;
   while (head_block_index != block_index) {
 
     // Go back (head always point to the first free block)
     uint8_t prev_index = prev_block_index(head_block_index);
@@ -997,47 +1102,28 @@ void Planner::recalculate_trapezoids() {
       if (next->use_advance_lead) {
         const float comp = next->e_D_ratio * extruder_advance_K * axis_steps_per_mm[E_AXIS];
         next->max_adv_steps = next_nominal_speed * comp;
         next->final_adv_steps = (MINIMUM_PLANNER_SPEED) * comp;
       }
     #endif
     CBI(next->flag, BLOCK_BIT_RECALCULATE);
   }
 }
 
-/**
- * Recalculate the motion plan according to the following algorithm:
- *
- *   1. Go over every block in reverse order...
- *
- *      Calculate a junction speed reduction (block_t.entry_factor) so:
- *
- *      a. The junction jerk is within the set limit, and
- *
- *      b. No speed reduction within one block requires faster
- *         deceleration than the one, true constant acceleration.
- *
- *   2. Go over every block in chronological order...
- *
- *      Dial down junction speed reduction values if:
- *      a. The speed increase within one block would require faster
- *         acceleration than the one, true constant acceleration.
- *
- * After that, all blocks will have an entry_factor allowing all speed changes to
- * be performed using only the one, true constant acceleration, and where no junction
- * jerk is jerkier than the set limit, Jerky. Finally it will:
- *
- *   3. Recalculate "trapezoids" for all blocks.
- */
 void Planner::recalculate() {
-  reverse_pass();
-  forward_pass();
+  // Initialize block index to the last block in the planner buffer.
+  const uint8_t block_index = prev_block_index(block_buffer_head);
+  // If there is just one block, no planning can be done. Avoid it!
+  if (block_index != block_buffer_planned) {
+    reverse_pass();
+    forward_pass();
+  }
   recalculate_trapezoids();
 }
 
 #if ENABLED(AUTOTEMP)
 
   void Planner::getHighESpeed() {
     static float oldt = 0;
 
     if (!autotemp_enabled) return;
     if (thermalManager.degTargetHotend(0) + 2 < autotemp_min) return; // probably temperature set to zero.
@@ -1341,37 +1427,48 @@ void Planner::check_axes_activity() {
     }
 
     #if ENABLED(SKEW_CORRECTION)
       unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]);
     #endif
   }
 
 #endif // PLANNER_LEVELING
 
 void Planner::quick_stop() {
+
   // Remove all the queued blocks. Note that this function is NOT
   // called from the Stepper ISR, so we must consider tail as readonly!
-  // that is why we set head to tail!
-  block_buffer_head = block_buffer_tail;
+  // that is why we set head to tail - But there is a race condition that
+  // must be handled: The tail could change between the read and the assignment
+  // so this must be enclosed in a critical section
+
+  const bool was_enabled = STEPPER_ISR_ENABLED();
+  if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+
+  // Drop all queue entries
+  block_buffer_planned = block_buffer_head = block_buffer_tail;
 
   // Restart the block delay for the first movement - As the queue was
   // forced to empty, there's no risk the ISR will touch this.
   delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
 
   #if ENABLED(ULTRA_LCD)
     // Clear the accumulated runtime
     clear_block_buffer_runtime();
   #endif
 
   // Make sure to drop any attempt of queuing moves for at least 1 second
   cleaning_buffer_counter = 1000;
 
+  // Reenable Stepper ISR
+  if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+
   // And stop the stepper ISR
   stepper.quick_stop();
 }
 
 void Planner::endstop_triggered(const AxisEnum axis) {
 
   /*NB: This will be called via endstops.update()
     and endstops.update() can be called from the temperature
     ISR. So Stepper interrupts are enabled */
 

commit e0ca627033504dd7bf8d9b87ce9ec526ee792276
Author: etagle <ejtagle@hotmail.com>
Date:   Sun May 13 00:49:54 2018 -0300

    Planner block HOLD flag
    
    Allows the Stepper ISR to wait until a given block is free for use. Allows Planner to plan the first move, which is split into two.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index d301971cf6..78634f7994 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -85,31 +85,36 @@
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"
 #endif
 
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
+// Delay for delivery of first block to the stepper ISR, if the queue contains 2 or
+// fewer movements. The delay is measured in milliseconds, and must be less than 250ms
+#define BLOCK_DELAY_FOR_1ST_MOVE 50
+
 Planner planner;
 
   // public:
 
 /**
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head,  // Index of the next block to be pushed
                  Planner::block_buffer_tail;  // Index of the busy block, if any
-uint16_t Planner::cleaning_buffer_counter;   // A counter to disable queuing of blocks
+uint16_t Planner::cleaning_buffer_counter;    // A counter to disable queuing of blocks
+uint8_t Planner::delay_before_delivering;     // This counter delays delivery of blocks when queue becomes empty to allow the opportunity of merging blocks
 
 float Planner::max_feedrate_mm_s[XYZE_N],   // Max speeds in mm per second
       Planner::axis_steps_per_mm[XYZE_N],
       Planner::steps_to_mm[XYZE_N];
 
 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
   bool Planner::abort_on_endstop_hit = false;
 #endif
 
 #if ENABLED(DISTINCT_E_FACTORS)
@@ -215,20 +220,21 @@ void Planner::init() {
   ZERO(position);
   #if HAS_POSITION_FLOAT
     ZERO(position_float);
   #endif
   ZERO(previous_speed);
   previous_nominal_speed_sqr = 0.0;
   #if ABL_PLANAR
     bed_level_matrix.set_to_identity();
   #endif
   clear_block_buffer();
+  delay_before_delivering = 0;
 }
 
 #if ENABLED(BEZIER_JERK_CONTROL)
 
   #ifdef __AVR__
     // This routine, for AVR, returns 0x1000000 / d, but trying to get the inverse as
     //  fast as possible. A fast converging iterative Newton-Raphson method is able to
     //  reach full precision in just 1 iteration, and takes 211 cycles (worst case, mean
     //  case is less, up to 30 cycles for small divisors), instead of the 500 cycles a
     //  normal division would take.
@@ -795,21 +801,22 @@ void Planner::calculate_trapezoid_for_block(block_t* const block, const float &e
     // And to offload calculations from the ISR, we also calculate the inverse of those times here
     uint32_t acceleration_time_inverse = get_period_inverse(acceleration_time);
     uint32_t deceleration_time_inverse = get_period_inverse(deceleration_time);
 
   #endif
 
   // Fill variables used by the stepper in a critical section
   const bool was_enabled = STEPPER_ISR_ENABLED();
   if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
 
-  if (!TEST(block->flag, BLOCK_BIT_BUSY)) { // Don't update variables if block is busy.
+  // Don't update variables if block is busy: It is being interpreted by the planner
+  if (!TEST(block->flag, BLOCK_BIT_BUSY)) {
     block->accelerate_until = accelerate_steps;
     block->decelerate_after = accelerate_steps + plateau_steps;
     block->initial_rate = initial_rate;
     #if ENABLED(BEZIER_JERK_CONTROL)
       block->acceleration_time = acceleration_time;
       block->deceleration_time = deceleration_time;
       block->acceleration_time_inverse = acceleration_time_inverse;
       block->deceleration_time_inverse = deceleration_time_inverse;
       block->cruise_rate = cruise_rate;
     #endif
@@ -1339,20 +1346,24 @@ void Planner::check_axes_activity() {
   }
 
 #endif // PLANNER_LEVELING
 
 void Planner::quick_stop() {
   // Remove all the queued blocks. Note that this function is NOT
   // called from the Stepper ISR, so we must consider tail as readonly!
   // that is why we set head to tail!
   block_buffer_head = block_buffer_tail;
 
+  // Restart the block delay for the first movement - As the queue was
+  // forced to empty, there's no risk the ISR will touch this.
+  delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
+
   #if ENABLED(ULTRA_LCD)
     // Clear the accumulated runtime
     clear_block_buffer_runtime();
   #endif
 
   // Make sure to drop any attempt of queuing moves for at least 1 second
   cleaning_buffer_counter = 1000;
 
   // And stop the stepper ISR
   stepper.quick_stop();
@@ -1367,26 +1378,20 @@ void Planner::endstop_triggered(const AxisEnum axis) {
   // Disable stepper ISR
   bool stepper_isr_enabled = STEPPER_ISR_ENABLED();
   DISABLE_STEPPER_DRIVER_INTERRUPT();
 
   // Record stepper position
   stepper.endstop_triggered(axis);
 
   // Discard the active block that led to the trigger
   discard_current_block();
 
-  // Discard the CONTINUED block, if any. Note the planner can only queue 1 continued
-  // block after a previous non continued block, as the condition to queue them
-  // is that there are no queued blocks at the time a new block is queued.
-  const bool discard = has_blocks_queued() && TEST(block_buffer[block_buffer_tail].flag, BLOCK_BIT_CONTINUED);
-  if (discard) discard_current_block();
-
   // Reenable stepper ISR if it was enabled
   if (stepper_isr_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
 }
 
 float Planner::triggered_position_mm(const AxisEnum axis) {
   return stepper.triggered_position(axis) * steps_to_mm[axis];
 }
 
 void Planner::finish_and_disable() {
   while (has_blocks_queued() || cleaning_buffer_counter) idle();
@@ -1460,20 +1465,30 @@ bool Planner::_buffer_steps(const int32_t (&target)[XYZE]
   #if HAS_POSITION_FLOAT
     , target_float
   #endif
     , fr_mm_s, extruder, millimeters
   )) {
     // Movement was not queued, probably because it was too short.
     //  Simply accept that as movement queued and done
     return true;
   }
 
+  // If this is the first added movement, reload the delay, otherwise, cancel it.
+  if (block_buffer_head == block_buffer_tail) {
+    // If it was the first queued block, restart the 1st block delivery delay, to
+    // give the planner an opportunity to queue more movements and plan them
+    // As there are no queued movements, the Stepper ISR will not touch this
+    // variable, so there is no risk setting this here (but it MUST be done
+    // before the following line!!)
+    delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
+  }
+
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
   // Recalculate and optimize trapezoidal speed profiles
   recalculate();
 
   // Movement successfully queued!
   return true;
 }
 
@@ -2285,21 +2300,32 @@ void Planner::buffer_sync_block() {
   // Clear block
   memset(block, 0, sizeof(block_t));
 
   block->flag = BLOCK_FLAG_SYNC_POSITION;
 
   block->position[A_AXIS] = position[A_AXIS];
   block->position[B_AXIS] = position[B_AXIS];
   block->position[C_AXIS] = position[C_AXIS];
   block->position[E_AXIS] = position[E_AXIS];
 
+  // If this is the first added movement, reload the delay, otherwise, cancel it.
+  if (block_buffer_head == block_buffer_tail) {
+    // If it was the first queued block, restart the 1st block delivery delay, to
+    // give the planner an opportunity to queue more movements and plan them
+    // As there are no queued movements, the Stepper ISR will not touch this
+    // variable, so there is no risk setting this here (but it MUST be done
+    // before the following line!!)
+    delay_before_delivering = BLOCK_DELAY_FOR_1ST_MOVE;
+  }
+
   block_buffer_head = next_buffer_head;
+
   stepper.wake_up();
 } // buffer_sync_block()
 
 /**
  * Planner::buffer_segment
  *
  * Add a new linear movement to the buffer in axis units.
  *
  * Leveling and kinematics should be applied ahead of calling this.
  *
@@ -2363,95 +2389,22 @@ bool Planner::buffer_segment(const float &a, const float &b, const float &c, con
       SERIAL_ECHOPAIR(") Z:", c);
     #endif
     SERIAL_ECHOPAIR(" (", position[Z_AXIS]);
     SERIAL_ECHOPAIR("->", target[Z_AXIS]);
     SERIAL_ECHOPAIR(") E:", e);
     SERIAL_ECHOPAIR(" (", position[E_AXIS]);
     SERIAL_ECHOPAIR("->", target[E_AXIS]);
     SERIAL_ECHOLNPGM(")");
   //*/
 
-  // Always split the first move into two (if not homing or probing)
-  if (!has_blocks_queued()) {
-
-    #define _BETWEEN(A) (position[_AXIS(A)] + target[_AXIS(A)]) >> 1
-    const int32_t between[ABCE] = { _BETWEEN(A), _BETWEEN(B), _BETWEEN(C), _BETWEEN(E) };
-
-    #if HAS_POSITION_FLOAT
-      #define _BETWEEN_F(A) (position_float[_AXIS(A)] + target_float[_AXIS(A)]) * 0.5
-      const float between_float[ABCE] = { _BETWEEN_F(A), _BETWEEN_F(B), _BETWEEN_F(C), _BETWEEN_F(E) };
-    #endif
-
-    // The new head value is not assigned yet
-    uint8_t buffer_head = 0;
-    bool added = false;
-
-    uint8_t next_buffer_head;
-    block_t *block = get_next_free_block(next_buffer_head, 2);
-
-    // Fill the block with the specified movement
+  // Queue the movement
     if (
-      _populate_block(block, true, between
-        #if HAS_POSITION_FLOAT
-          , between_float
-        #endif
-        , fr_mm_s, extruder, millimeters * 0.5
-      )
-    ) {
-      // Movement accepted - Point to the next reserved block
-      block = &block_buffer[next_buffer_head];
-
-      // Store into the new to be stored head
-      buffer_head = next_buffer_head;
-      added = true;
-
-      // And advance the pointer to the next unused slot
-      next_buffer_head = next_block_index(next_buffer_head);
-    }
-
-    // Fill the second part of the block with the 2nd part of the movement
-    if (
-      _populate_block(block, true, target
-        #if HAS_POSITION_FLOAT
-          , target_float
-        #endif
-        , fr_mm_s, extruder, millimeters * 0.5
-      )
-    ) {
-      // Movement accepted - If this block is a continuation
-      // of the previous one, mark it as such
-      if (added) SBI(block->flag, BLOCK_BIT_CONTINUED);
-
-      // Store into the new to be stored head
-      buffer_head = next_buffer_head;
-      added = true;
-    }
-
-    // If any of the movements was added
-    if (added) {
-
-      // Move buffer head and add all the blocks that were filled
-      // successfully to the movement queue.
-      block_buffer_head = buffer_head;
-
-      // Update the position (only when a move was queued)
-      static_assert(COUNT(target) > 1, "Parameter to _buffer_steps must be (&target)[XYZE]!");
-      COPY(position, target);
-      #if HAS_POSITION_FLOAT
-        COPY(position_float, target_float);
-      #endif
-
-      // Recalculate and optimize trapezoidal speed profiles
-      recalculate();
-    }
-  }
-  else if (
     !_buffer_steps(target
       #if HAS_POSITION_FLOAT
         , target_float
       #endif
       , fr_mm_s, extruder, millimeters
     )
   ) return false;
 
   stepper.wake_up();
   return true;

commit a11eb50a3eab6d58d595a67e526fb51190018db3
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 9 02:17:53 2018 -0300

    Refactor and optimize Stepper/Planner
    
    Better encapsulation and considerably reduce stepper jitter

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e1f5f10238..d301971cf6 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -93,27 +93,32 @@
 #endif
 
 Planner planner;
 
   // public:
 
 /**
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
-volatile uint8_t Planner::block_buffer_head, // Index of the next block to be pushed
-                 Planner::block_buffer_tail;
+volatile uint8_t Planner::block_buffer_head,  // Index of the next block to be pushed
+                 Planner::block_buffer_tail;  // Index of the busy block, if any
+uint16_t Planner::cleaning_buffer_counter;   // A counter to disable queuing of blocks
 
-float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
+float Planner::max_feedrate_mm_s[XYZE_N],   // Max speeds in mm per second
       Planner::axis_steps_per_mm[XYZE_N],
       Planner::steps_to_mm[XYZE_N];
 
+#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+  bool Planner::abort_on_endstop_hit = false;
+#endif
+
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
 
 float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0); // The flow percentage and volumetric multiplier combine to scale E movement
 
 #if DISABLED(NO_VOLUMETRICS)
   float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
@@ -168,21 +173,21 @@ float Planner::min_feedrate_mm_s,
   bool Planner::autotemp_enabled = false;
 #endif
 
 // private:
 
 int32_t Planner::position[NUM_AXIS] = { 0 };
 
 uint32_t Planner::cutoff_long;
 
 float Planner::previous_speed[NUM_AXIS],
-      Planner::previous_nominal_speed;
+      Planner::previous_nominal_speed_sqr;
 
 #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
   uint8_t Planner::g_uc_extruder_last_move[EXTRUDERS] = { 0 };
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
   // Old direction bits. Used for speed calculations
   unsigned char Planner::old_direction_bits = 0;
   // Segment times (in ¬µs). Used for speed calculations
   uint32_t Planner::axis_segment_time_us[2][3] = { { MAX_FREQ_TIME_US + 1, 0, 0 }, { MAX_FREQ_TIME_US + 1, 0, 0 } };
@@ -205,21 +210,21 @@ float Planner::previous_speed[NUM_AXIS],
  */
 
 Planner::Planner() { init(); }
 
 void Planner::init() {
   ZERO(position);
   #if HAS_POSITION_FLOAT
     ZERO(position_float);
   #endif
   ZERO(previous_speed);
-  previous_nominal_speed = 0.0;
+  previous_nominal_speed_sqr = 0.0;
   #if ABL_PLANAR
     bed_level_matrix.set_to_identity();
   #endif
   clear_block_buffer();
 }
 
 #if ENABLED(BEZIER_JERK_CONTROL)
 
   #ifdef __AVR__
     // This routine, for AVR, returns 0x1000000 / d, but trying to get the inverse as
@@ -356,21 +361,21 @@ void Planner::init() {
     //
     //  // Check if we must adjust result
     //  if (r >= d) x++;
     //
     //  // x holds the proper estimation
     //  return uint32_t(x);
     // }
     //
     static uint32_t get_period_inverse(uint32_t d) {
 
-       static const uint8_t inv_tab[256] PROGMEM = {
+      static const uint8_t inv_tab[256] PROGMEM = {
         255,253,252,250,248,246,244,242,240,238,236,234,233,231,229,227,
         225,224,222,220,218,217,215,213,212,210,208,207,205,203,202,200,
         199,197,195,194,192,191,189,188,186,185,183,182,180,179,178,176,
         175,173,172,170,169,168,166,165,164,162,161,160,158,157,156,154,
         153,152,151,149,148,147,146,144,143,142,141,139,138,137,136,135,
         134,132,131,130,129,128,127,126,125,123,122,121,120,119,118,117,
         116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101,
         100,99,98,97,96,95,94,93,92,91,90,89,88,88,87,86,
         85,84,83,82,81,80,80,79,78,77,76,75,74,74,73,72,
         71,70,70,69,68,67,66,66,65,64,63,62,62,61,60,59,
@@ -720,63 +725,60 @@ void Planner::init() {
           "+z" (ptab)
         :
         : "r0", "r1", "cc"
       );
 
       // Return the result
       return r11 | (uint16_t(r12) << 8) | (uint32_t(r13) << 16);
     }
   #else
     // All the other 32 CPUs can easily perform the inverse using hardware division,
-    // so we don¬¥t need to reduce precision or to use assembly language at all.
-
+    // so we don't need to reduce precision or to use assembly language at all.
     // This routine, for all the other archs, returns 0x100000000 / d ~= 0xFFFFFFFF / d
-    static FORCE_INLINE uint32_t get_period_inverse(uint32_t d) {
-      return 0xFFFFFFFF / d;
-    }
+    static FORCE_INLINE uint32_t get_period_inverse(const uint32_t d) { return 0xFFFFFFFF / d; }
   #endif
 #endif
 
 #define MINIMAL_STEP_RATE 120
 
 /**
  * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
  * by the provided factors.
  */
 void Planner::calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor) {
+
   uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
            final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
 
   // Limit minimal step rate (Otherwise the timer will overflow.)
   NOLESS(initial_rate, MINIMAL_STEP_RATE);
   NOLESS(final_rate, MINIMAL_STEP_RATE);
 
   #if ENABLED(BEZIER_JERK_CONTROL)
     uint32_t cruise_rate = initial_rate;
   #endif
 
   const int32_t accel = block->acceleration_steps_per_s2;
 
           // Steps required for acceleration, deceleration to/from nominal rate
-  int32_t accelerate_steps = CEIL(estimate_acceleration_distance(initial_rate, block->nominal_rate, accel)),
-          decelerate_steps = FLOOR(estimate_acceleration_distance(block->nominal_rate, final_rate, -accel)),
+  uint32_t accelerate_steps = CEIL(estimate_acceleration_distance(initial_rate, block->nominal_rate, accel)),
+           decelerate_steps = FLOOR(estimate_acceleration_distance(block->nominal_rate, final_rate, -accel));
           // Steps between acceleration and deceleration, if any
-          plateau_steps = block->step_event_count - accelerate_steps - decelerate_steps;
+  int32_t plateau_steps = block->step_event_count - accelerate_steps - decelerate_steps;
 
   // Does accelerate_steps + decelerate_steps exceed step_event_count?
   // Then we can't possibly reach the nominal rate, there will be no cruising.
   // Use intersection_distance() to calculate accel / braking time in order to
   // reach the final_rate exactly at the end of this block.
   if (plateau_steps < 0) {
-    accelerate_steps = CEIL(intersection_distance(initial_rate, final_rate, accel, block->step_event_count));
-    NOLESS(accelerate_steps, 0); // Check limits due to numerical round-off
-    accelerate_steps = min((uint32_t)accelerate_steps, block->step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)
+    const float accelerate_steps_float = CEIL(intersection_distance(initial_rate, final_rate, accel, block->step_event_count));
+    accelerate_steps = MIN(uint32_t(MAX(accelerate_steps_float, 0)), block->step_event_count);
     plateau_steps = 0;
 
     #if ENABLED(BEZIER_JERK_CONTROL)
       // We won't reach the cruising rate. Let's calculate the speed we will reach
       cruise_rate = final_speed(initial_rate, accel, accelerate_steps);
     #endif
   }
   #if ENABLED(BEZIER_JERK_CONTROL)
     else // We have some plateau time, so the cruise rate will be the nominal rate
       cruise_rate = block->nominal_rate;
@@ -789,173 +791,212 @@ void Planner::calculate_trapezoid_for_block(block_t* const block, const float &e
     // Jerk controlled speed requires to express speed versus time, NOT steps
     uint32_t acceleration_time = ((float)(cruise_rate - initial_rate) / accel) * (HAL_STEPPER_TIMER_RATE),
              deceleration_time = ((float)(cruise_rate - final_rate) / accel) * (HAL_STEPPER_TIMER_RATE);
 
     // And to offload calculations from the ISR, we also calculate the inverse of those times here
     uint32_t acceleration_time_inverse = get_period_inverse(acceleration_time);
     uint32_t deceleration_time_inverse = get_period_inverse(deceleration_time);
 
   #endif
 
-  CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section
+  // Fill variables used by the stepper in a critical section
+  const bool was_enabled = STEPPER_ISR_ENABLED();
+  if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+
   if (!TEST(block->flag, BLOCK_BIT_BUSY)) { // Don't update variables if block is busy.
     block->accelerate_until = accelerate_steps;
     block->decelerate_after = accelerate_steps + plateau_steps;
     block->initial_rate = initial_rate;
     #if ENABLED(BEZIER_JERK_CONTROL)
       block->acceleration_time = acceleration_time;
       block->deceleration_time = deceleration_time;
       block->acceleration_time_inverse = acceleration_time_inverse;
       block->deceleration_time_inverse = deceleration_time_inverse;
       block->cruise_rate = cruise_rate;
     #endif
     block->final_rate = final_rate;
   }
-  CRITICAL_SECTION_END;
+  if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
 }
 
-// "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.
-// This method will calculate the junction jerk as the euclidean distance between the nominal
-// velocities of the respective blocks.
-//inline float junction_jerk(block_t *before, block_t *after) {
-//  return SQRT(
-//    POW((before->speed_x-after->speed_x), 2)+POW((before->speed_y-after->speed_y), 2));
-//}
-
 // The kernel called by recalculate() when scanning the plan from last to first entry.
-void Planner::reverse_pass_kernel(block_t* const current, const block_t* const next) {
-  if (current && next) {
-    // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.
-    // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and
-    // check for maximum allowable speed reductions to ensure maximum possible planned speed.
-    const float max_entry_speed = current->max_entry_speed;
-    if (current->entry_speed != max_entry_speed || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
-      // If nominal length true, max junction speed is guaranteed to be reached. Only compute
-      // for max allowable speed if block is decelerating and nominal length is false.
-      const float new_entry_speed = (TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH) || max_entry_speed <= next->entry_speed)
-        ? max_entry_speed
-        : MIN(max_entry_speed, max_allowable_speed(-current->acceleration, next->entry_speed, current->millimeters));
-      if (new_entry_speed != current->entry_speed) {
-        current->entry_speed = new_entry_speed;
+void Planner::reverse_pass_kernel(block_t* const current, const block_t * const next) {
+  if (current) {
+    // If entry speed is already at the maximum entry speed, and there was no change of speed
+    // in the next block, there is no need to recheck. Block is cruising and there is no need to
+    // compute anything for this block,
+    // If not, block entry speed needs to be recalculated to ensure maximum possible planned speed.
+    const float max_entry_speed_sqr = current->max_entry_speed_sqr;
+
+    // Compute maximum entry speed decelerating over the current block from its exit speed.
+    // If not at the maximum entry speed, or the previous block entry speed changed
+    if (current->entry_speed_sqr != max_entry_speed_sqr || (next && TEST(next->flag, BLOCK_BIT_RECALCULATE))) {
+
+      // If nominal length true, max junction speed is guaranteed to be reached.
+      // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
+      // the current block and next block junction speeds are guaranteed to always be at their maximum
+      // junction speeds in deceleration and acceleration, respectively. This is due to how the current
+      // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
+      // the reverse and forward planners, the corresponding block junction speed will always be at the
+      // the maximum junction speed and may always be ignored for any speed reduction checks.
+
+      const float new_entry_speed_sqr = TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH)
+        ? max_entry_speed_sqr
+        : MIN(max_entry_speed_sqr, max_allowable_speed_sqr(-current->acceleration, next ? next->entry_speed_sqr : sq(MINIMUM_PLANNER_SPEED), current->millimeters));
+      if (current->entry_speed_sqr != new_entry_speed_sqr) {
+        current->entry_speed_sqr = new_entry_speed_sqr;
         SBI(current->flag, BLOCK_BIT_RECALCULATE);
       }
     }
   }
 }
 
 /**
  * recalculate() needs to go over the current plan twice.
  * Once in reverse and once forward. This implements the reverse pass.
  */
 void Planner::reverse_pass() {
   if (movesplanned() > 2) {
     const uint8_t endnr = next_block_index(block_buffer_tail); // tail is running. tail+1 shouldn't be altered because it's connected to the running block.
     uint8_t blocknr = prev_block_index(block_buffer_head);
-    block_t* current = &block_buffer[blocknr];
-
-    // Last/newest block in buffer:
-    const float max_entry_speed = current->max_entry_speed;
-    if (current->entry_speed != max_entry_speed) {
-      // If nominal length true, max junction speed is guaranteed to be reached. Only compute
-      // for max allowable speed if block is decelerating and nominal length is false.
-      const float new_entry_speed = TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH)
-        ? max_entry_speed
-        : MIN(max_entry_speed, max_allowable_speed(-current->acceleration, MINIMUM_PLANNER_SPEED, current->millimeters));
-      if (current->entry_speed != new_entry_speed) {
-        current->entry_speed = new_entry_speed;
-        SBI(current->flag, BLOCK_BIT_RECALCULATE);
-      }
-    }
 
-    do {
-      const block_t * const next = current;
-      blocknr = prev_block_index(blocknr);
+    // Perform the reverse pass
+    block_t *current, *next = NULL;
+    while (blocknr != endnr) {
+      // Perform the reverse pass - Only consider non sync blocks
       current = &block_buffer[blocknr];
-      reverse_pass_kernel(current, next);
-    } while (blocknr != endnr);
+      if (!TEST(current->flag, BLOCK_BIT_SYNC_POSITION)) {
+        reverse_pass_kernel(current, next);
+        next = current;
+      }
+      // Advance to the next
+      blocknr = prev_block_index(blocknr);
+    }
   }
 }
 
 // The kernel called by recalculate() when scanning the plan from first to last entry.
-void Planner::forward_pass_kernel(const block_t* const previous, block_t* const current) {
+void Planner::forward_pass_kernel(const block_t * const previous, block_t* const current) {
   if (previous) {
     // If the previous block is an acceleration block, too short to complete the full speed
     // change, adjust the entry speed accordingly. Entry speeds have already been reset,
     // maximized, and reverse-planned. If nominal length is set, max junction speed is
     // guaranteed to be reached. No need to recheck.
     if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH)) {
-      if (previous->entry_speed < current->entry_speed) {
-        const float new_entry_speed = MIN(current->entry_speed, max_allowable_speed(-previous->acceleration, previous->entry_speed, previous->millimeters));
-        // Check for junction speed change
-        if (current->entry_speed != new_entry_speed) {
-          current->entry_speed = new_entry_speed;
+      if (previous->entry_speed_sqr < current->entry_speed_sqr) {
+        // Compute the maximum allowable speed
+        const float new_entry_speed_sqr = max_allowable_speed_sqr(-previous->acceleration, previous->entry_speed_sqr, previous->millimeters);
+        // If true, current block is full-acceleration
+        if (current->entry_speed_sqr > new_entry_speed_sqr) {
+          // Always <= max_entry_speed_sqr. Backward pass sets this.
+          current->entry_speed_sqr = new_entry_speed_sqr;
           SBI(current->flag, BLOCK_BIT_RECALCULATE);
         }
       }
     }
   }
 }
 
 /**
  * recalculate() needs to go over the current plan twice.
  * Once in reverse and once forward. This implements the forward pass.
  */
 void Planner::forward_pass() {
-  block_t* block[3] = { NULL, NULL, NULL };
-
-  for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
-    block[0] = block[1];
-    block[1] = block[2];
-    block[2] = &block_buffer[b];
-    forward_pass_kernel(block[0], block[1]);
+  const uint8_t endnr = block_buffer_head;
+  uint8_t blocknr = block_buffer_tail;
+
+  // Perform the forward pass
+  block_t *current, *previous = NULL;
+  while (blocknr != endnr) {
+    // Perform the forward pass - Only consider non-sync blocks
+    current = &block_buffer[blocknr];
+    if (!TEST(current->flag, BLOCK_BIT_SYNC_POSITION)) {
+      forward_pass_kernel(previous, current);
+      previous = current;
+    }
+    // Advance to the previous
+    blocknr = next_block_index(blocknr);
   }
-  forward_pass_kernel(block[1], block[2]);
 }
 
 /**
  * Recalculate the trapezoid speed profiles for all blocks in the plan
  * according to the entry_factor for each junction. Must be called by
  * recalculate() after updating the blocks.
  */
 void Planner::recalculate_trapezoids() {
-  int8_t block_index = block_buffer_tail;
-  block_t *current, *next = NULL;
+  uint8_t block_index = block_buffer_tail;
+
+  // As there could be a sync block in the head of the queue, and the next loop must not
+  // recalculate the head block (as it needs to be specially handled), scan backwards until
+  // we find the first non SYNC block
+  uint8_t head_block_index = block_buffer_head;
+  while (head_block_index != block_index) {
+
+    // Go back (head always point to the first free block)
+    uint8_t prev_index = prev_block_index(head_block_index);
+
+    // Get the pointer to the block
+    block_t *prev = &block_buffer[prev_index];
+
+    // If not dealing with a sync block, we are done. The last block is not a SYNC block
+    if (!TEST(prev->flag, BLOCK_BIT_SYNC_POSITION)) break;
+
+    // Examine the previous block. This and all following are SYNC blocks
+    head_block_index = prev_index;
+  };
+
+  // Go from the tail (currently executed block) to the first block, without including it)
+  block_t *current = NULL, *next = NULL;
+  float current_entry_speed = 0.0, next_entry_speed = 0.0;
+  while (block_index != head_block_index) {
 
-  while (block_index != block_buffer_head) {
-    current = next;
     next = &block_buffer[block_index];
-    if (current) {
-      // Recalculate if current block entry or exit junction speed has changed.
-      if (TEST(current->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
-        // NOTE: Entry and exit factors always > 0 by all previous logic operations.
-        const float nomr = 1.0 / current->nominal_speed;
-        calculate_trapezoid_for_block(current, current->entry_speed * nomr, next->entry_speed * nomr);
-        #if ENABLED(LIN_ADVANCE)
-          if (current->use_advance_lead) {
-            const float comp = current->e_D_ratio * extruder_advance_K * axis_steps_per_mm[E_AXIS];
-            current->max_adv_steps = current->nominal_speed * comp;
-            current->final_adv_steps = next->entry_speed * comp;
-          }
-        #endif
-        CBI(current->flag, BLOCK_BIT_RECALCULATE); // Reset current only to ensure next trapezoid is computed
+
+    // Skip sync blocks
+    if (!TEST(next->flag, BLOCK_BIT_SYNC_POSITION)) {
+      next_entry_speed = SQRT(next->entry_speed_sqr);
+
+      if (current) {
+        // Recalculate if current block entry or exit junction speed has changed.
+        if (TEST(current->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
+          // NOTE: Entry and exit factors always > 0 by all previous logic operations.
+          const float current_nominal_speed = SQRT(current->nominal_speed_sqr),
+                      nomr = 1.0 / current_nominal_speed;
+          calculate_trapezoid_for_block(current, current_entry_speed * nomr, next_entry_speed * nomr);
+          #if ENABLED(LIN_ADVANCE)
+            if (current->use_advance_lead) {
+              const float comp = current->e_D_ratio * extruder_advance_K * axis_steps_per_mm[E_AXIS];
+              current->max_adv_steps = current_nominal_speed * comp;
+              current->final_adv_steps = next_entry_speed * comp;
+            }
+          #endif
+          CBI(current->flag, BLOCK_BIT_RECALCULATE); // Reset current only to ensure next trapezoid is computed
+        }
       }
+
+      current = next;
+      current_entry_speed = next_entry_speed;
     }
+
     block_index = next_block_index(block_index);
   }
+
   // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
   if (next) {
-    const float nomr = 1.0 / next->nominal_speed;
-    calculate_trapezoid_for_block(next, next->entry_speed * nomr, (MINIMUM_PLANNER_SPEED) * nomr);
+    const float next_nominal_speed = SQRT(next->nominal_speed_sqr),
+                nomr = 1.0 / next_nominal_speed;
+    calculate_trapezoid_for_block(next, next_entry_speed * nomr, (MINIMUM_PLANNER_SPEED) * nomr);
     #if ENABLED(LIN_ADVANCE)
       if (next->use_advance_lead) {
         const float comp = next->e_D_ratio * extruder_advance_K * axis_steps_per_mm[E_AXIS];
-        next->max_adv_steps = next->nominal_speed * comp;
+        next->max_adv_steps = next_nominal_speed * comp;
         next->final_adv_steps = (MINIMUM_PLANNER_SPEED) * comp;
       }
     #endif
     CBI(next->flag, BLOCK_BIT_RECALCULATE);
   }
 }
 
 /**
  * Recalculate the motion plan according to the following algorithm:
  *
@@ -991,21 +1032,21 @@ void Planner::recalculate() {
   void Planner::getHighESpeed() {
     static float oldt = 0;
 
     if (!autotemp_enabled) return;
     if (thermalManager.degTargetHotend(0) + 2 < autotemp_min) return; // probably temperature set to zero.
 
     float high = 0.0;
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block_t* block = &block_buffer[b];
       if (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS]) {
-        float se = (float)block->steps[E_AXIS] / block->step_event_count * block->nominal_speed; // mm/sec;
+        const float se = (float)block->steps[E_AXIS] / block->step_event_count * SQRT(block->nominal_speed_sqr); // mm/sec;
         NOLESS(high, se);
       }
     }
 
     float t = autotemp_min + high * autotemp_factor;
     t = constrain(t, autotemp_min, autotemp_max);
     if (t < oldt) t = t * (1 - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
     oldt = t;
     thermalManager.setTargetHotend(t, 0);
   }
@@ -1292,33 +1333,86 @@ void Planner::check_axes_activity() {
       #endif
     }
 
     #if ENABLED(SKEW_CORRECTION)
       unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]);
     #endif
   }
 
 #endif // PLANNER_LEVELING
 
+void Planner::quick_stop() {
+  // Remove all the queued blocks. Note that this function is NOT
+  // called from the Stepper ISR, so we must consider tail as readonly!
+  // that is why we set head to tail!
+  block_buffer_head = block_buffer_tail;
+
+  #if ENABLED(ULTRA_LCD)
+    // Clear the accumulated runtime
+    clear_block_buffer_runtime();
+  #endif
+
+  // Make sure to drop any attempt of queuing moves for at least 1 second
+  cleaning_buffer_counter = 1000;
+
+  // And stop the stepper ISR
+  stepper.quick_stop();
+}
+
+void Planner::endstop_triggered(const AxisEnum axis) {
+
+  /*NB: This will be called via endstops.update()
+    and endstops.update() can be called from the temperature
+    ISR. So Stepper interrupts are enabled */
+
+  // Disable stepper ISR
+  bool stepper_isr_enabled = STEPPER_ISR_ENABLED();
+  DISABLE_STEPPER_DRIVER_INTERRUPT();
+
+  // Record stepper position
+  stepper.endstop_triggered(axis);
+
+  // Discard the active block that led to the trigger
+  discard_current_block();
+
+  // Discard the CONTINUED block, if any. Note the planner can only queue 1 continued
+  // block after a previous non continued block, as the condition to queue them
+  // is that there are no queued blocks at the time a new block is queued.
+  const bool discard = has_blocks_queued() && TEST(block_buffer[block_buffer_tail].flag, BLOCK_BIT_CONTINUED);
+  if (discard) discard_current_block();
+
+  // Reenable stepper ISR if it was enabled
+  if (stepper_isr_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+}
+
+float Planner::triggered_position_mm(const AxisEnum axis) {
+  return stepper.triggered_position(axis) * steps_to_mm[axis];
+}
+
+void Planner::finish_and_disable() {
+  while (has_blocks_queued() || cleaning_buffer_counter) idle();
+  disable_all_steppers();
+}
+
 /**
  * Get an axis position according to stepper position(s)
  * For CORE machines apply translation from ABC to XYZ.
  */
 float Planner::get_axis_position_mm(const AxisEnum axis) {
   float axis_steps;
   #if IS_CORE
     // Requesting one of the "core" axes?
     if (axis == CORE_AXIS_1 || axis == CORE_AXIS_2) {
 
       // Protect the access to the position.
       const bool was_enabled = STEPPER_ISR_ENABLED();
-      DISABLE_STEPPER_DRIVER_INTERRUPT();
+      if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
 
       // ((a1+a2)+(a1-a2))/2 -> (a1+a2+a1-a2)/2 -> (a1+a1)/2 -> a1
       // ((a1+a2)-(a1-a2))/2 -> (a1+a2-a1+a2)/2 -> (a2+a2)/2 -> a2
       axis_steps = 0.5f * (
         axis == CORE_AXIS_2 ? CORESIGN(stepper.position(CORE_AXIS_1) - stepper.position(CORE_AXIS_2))
                             : stepper.position(CORE_AXIS_1) + stepper.position(CORE_AXIS_2)
       );
 
       if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
     }
@@ -1326,46 +1420,97 @@ float Planner::get_axis_position_mm(const AxisEnum axis) {
       axis_steps = stepper.position(axis);
   #else
     axis_steps = stepper.position(axis);
   #endif
   return axis_steps * steps_to_mm[axis];
 }
 
 /**
  * Block until all buffered steps are executed / cleaned
  */
-void Planner::synchronize() { while (has_blocks_queued() || stepper.cleaning_buffer_counter) idle(); }
+void Planner::synchronize() { while (has_blocks_queued() || cleaning_buffer_counter) idle(); }
 
 /**
  * Planner::_buffer_steps
  *
- * Add a new linear movement to the buffer (in terms of steps).
+ * Add a new linear movement to the planner queue (in terms of steps).
+ *
+ *  target      - target position in steps units
+ *  fr_mm_s     - (target) speed of the move
+ *  extruder    - target extruder
+ *  millimeters - the length of the movement, if known
+ *
+ * Returns true if movement was properly queued, false otherwise
+ */
+bool Planner::_buffer_steps(const int32_t (&target)[XYZE]
+  #if HAS_POSITION_FLOAT
+    , const float (&target_float)[XYZE]
+  #endif
+  , float fr_mm_s, const uint8_t extruder, const float &millimeters
+) {
+
+  // If we are cleaning, do not accept queuing of movements
+  if (cleaning_buffer_counter) return false;
+
+  // Wait for the next available block
+  uint8_t next_buffer_head;
+  block_t * const block = get_next_free_block(next_buffer_head);
+
+  // Fill the block with the specified movement
+  if (!_populate_block(block, false, target
+  #if HAS_POSITION_FLOAT
+    , target_float
+  #endif
+    , fr_mm_s, extruder, millimeters
+  )) {
+    // Movement was not queued, probably because it was too short.
+    //  Simply accept that as movement queued and done
+    return true;
+  }
+
+  // Move buffer head
+  block_buffer_head = next_buffer_head;
+
+  // Recalculate and optimize trapezoidal speed profiles
+  recalculate();
+
+  // Movement successfully queued!
+  return true;
+}
+
+/**
+ * Planner::_populate_block
+ *
+ * Fills a new linear movement in the block (in terms of steps).
  *
  *  target      - target position in steps units
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
+ *
+ * Returns true is movement is acceptable, false otherwise
  */
-void Planner::_buffer_steps(const int32_t (&target)[XYZE]
+bool Planner::_populate_block(block_t * const block, bool split_move,
+    const int32_t (&target)[XYZE]
   #if HAS_POSITION_FLOAT
     , const float (&target_float)[XYZE]
   #endif
   , float fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
   const int32_t da = target[A_AXIS] - position[A_AXIS],
                 db = target[B_AXIS] - position[B_AXIS],
                 dc = target[C_AXIS] - position[C_AXIS];
 
   int32_t de = target[E_AXIS] - position[E_AXIS];
 
   /* <-- add a slash to enable
-    SERIAL_ECHOPAIR("  _buffer_steps FR:", fr_mm_s);
+    SERIAL_ECHOPAIR("  _populate_block FR:", fr_mm_s);
     SERIAL_ECHOPAIR(" A:", target[A_AXIS]);
     SERIAL_ECHOPAIR(" (", da);
     SERIAL_ECHOPAIR(" steps) B:", target[B_AXIS]);
     SERIAL_ECHOPAIR(" (", db);
     SERIAL_ECHOPAIR(" steps) C:", target[C_AXIS]);
     SERIAL_ECHOPAIR(" (", dc);
     SERIAL_ECHOPAIR(" steps) E:", target[E_AXIS]);
     SERIAL_ECHOPAIR(" (", de);
     SERIAL_ECHOLNPGM(" steps)");
   //*/
@@ -1420,24 +1565,20 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
   #else
     if (da < 0) SBI(dm, X_AXIS);
     if (db < 0) SBI(dm, Y_AXIS);
     if (dc < 0) SBI(dm, Z_AXIS);
   #endif
   if (de < 0) SBI(dm, E_AXIS);
 
   const float esteps_float = de * e_factor[extruder];
   const int32_t esteps = ABS(esteps_float) + 0.5;
 
-  // Wait for the next available block
-  uint8_t next_buffer_head;
-  block_t * const block = get_next_free_block(next_buffer_head);
-
   // Clear all flags, including the "busy" bit
   block->flag = 0x00;
 
   // Set direction bits
   block->direction_bits = dm;
 
   // Number of steps for each axis
   // See http://www.corexy.com/theory.html
   #if CORE_IS_XY
     block->steps[A_AXIS] = ABS(da + db);
@@ -1459,21 +1600,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
     // default non-h-bot planning
     block->steps[A_AXIS] = ABS(da);
     block->steps[B_AXIS] = ABS(db);
     block->steps[C_AXIS] = ABS(dc);
   #endif
 
   block->steps[E_AXIS] = esteps;
   block->step_event_count = MAX4(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
 
   // Bail if this is a zero-length block
-  if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return;
+  if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return false;
 
   // For a mixing extruder, get a magnified step_event_count for each
   #if ENABLED(MIXING_EXTRUDER)
     for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
       block->mix_event_count[i] = mixing_factor[i] * block->step_event_count;
   #endif
 
   #if FAN_COUNT > 0
     for (uint8_t i = 0; i < FAN_COUNT; i++) block->fan_speed[i] = fanSpeeds[i];
   #endif
@@ -1699,26 +1840,30 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
         const uint32_t nst = segment_time_us + LROUND(2 * (min_segment_time_us - segment_time_us) / moves_queued);
         inverse_secs = 1000000.0 / nst;
         #if defined(XY_FREQUENCY_LIMIT) || ENABLED(ULTRA_LCD)
           segment_time_us = nst;
         #endif
       }
     }
   #endif
 
   #if ENABLED(ULTRA_LCD)
-    CRITICAL_SECTION_START
-      block_buffer_runtime_us += segment_time_us;
-    CRITICAL_SECTION_END
+    // Protect the access to the position.
+    const bool was_enabled = STEPPER_ISR_ENABLED();
+    if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+
+    block_buffer_runtime_us += segment_time_us;
+
+    if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
   #endif
 
-  block->nominal_speed = block->millimeters * inverse_secs;           //   (mm/sec) Always > 0
+  block->nominal_speed_sqr = sq(block->millimeters * inverse_secs);   //   (mm/sec)^2 Always > 0
   block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     static float filwidth_e_count = 0, filwidth_delay_dist = 0;
 
     //FMM update ring buffer used for delay with filament measurements
     if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && filwidth_delay_index[1] >= 0) {  //only for extruder with filament sensor and if ring buffer is initialized
 
       constexpr int MMD_CM = MAX_MEASUREMENT_DELAY + 1, MMD_MM = MMD_CM * 10;
 
@@ -1792,22 +1937,22 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
                    min_xy_segment_time = MIN(max_x_segment_time, max_y_segment_time);
     if (min_xy_segment_time < MAX_FREQ_TIME_US) {
       const float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME_US);
       NOMORE(speed_factor, low_sf);
     }
   #endif // XY_FREQUENCY_LIMIT
 
   // Correct the speed
   if (speed_factor < 1.0) {
     LOOP_XYZE(i) current_speed[i] *= speed_factor;
-    block->nominal_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
+    block->nominal_speed_sqr = block->nominal_speed_sqr * sq(speed_factor);
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
   if (!block->steps[A_AXIS] && !block->steps[B_AXIS] && !block->steps[C_AXIS]) {
     // convert to: acceleration steps/sec^2
     accel = CEIL(retract_acceleration * steps_per_mm);
     #if ENABLED(LIN_ADVANCE)
       block->use_advance_lead = false;
@@ -1888,35 +2033,35 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
     else {
       LIMIT_ACCEL_FLOAT(A_AXIS, 0);
       LIMIT_ACCEL_FLOAT(B_AXIS, 0);
       LIMIT_ACCEL_FLOAT(C_AXIS, 0);
       LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   #if DISABLED(BEZIER_JERK_CONTROL)
-    block->acceleration_rate = (long)(accel * (4096.0 * 4096.0 / (HAL_STEPPER_TIMER_RATE)));
+    block->acceleration_rate = (uint32_t)(accel * (4096.0 * 4096.0 / (HAL_STEPPER_TIMER_RATE)));
   #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
       block->advance_speed = (HAL_STEPPER_TIMER_RATE) / (extruder_advance_K * block->e_D_ratio * block->acceleration * axis_steps_per_mm[E_AXIS_N]);
       #if ENABLED(LA_DEBUG)
-        if (extruder_advance_K * block->e_D_ratio * block->acceleration * 2 < block->nominal_speed * block->e_D_ratio)
+        if (extruder_advance_K * block->e_D_ratio * block->acceleration * 2 < SQRT(block->nominal_speed_sqr) * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif
     }
   #endif
 
-  float vmax_junction; // Initial limit on the segment entry velocity
+  float vmax_junction_sqr; // Initial limit on the segment entry velocity (mm/s)^2
 
   #if ENABLED(JUNCTION_DEVIATION)
 
     /**
      * Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
      * Let a circle be tangent to both previous and current path line segments, where the junction
      * deviation is defined as the distance from the junction to the closest edge of the circle,
      * colinear with the circle center. The circular segment joining the two paths represents the
      * path of centripetal acceleration. Solve for max velocity based on max acceleration about the
      * radius of the circle, defined indirectly by junction deviation. This may be also viewed as
@@ -1928,114 +2073,140 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
      * mode (G61). If the junction deviation value is zero, Grbl will execute the motion in an exact
      * stop mode (G61.1) manner. In the future, if continuous mode (G64) is desired, the math here
      * is exactly the same. Instead of motioning all the way to junction point, the machine will
      * just follow the arc circle defined here. The Arduino doesn't have the CPU cycles to perform
      * a continuous mode path, but ARM-based microcontrollers most certainly do.
      *
      * NOTE: The max junction speed is a fixed value, since machine acceleration limits cannot be
      * changed dynamically during operation nor can the line move geometry. This must be kept in
      * memory in the event of a feedrate override changing the nominal speeds of blocks, which can
      * change the overall maximum entry speed conditions of all blocks.
-     */
+     *
+     * #######
+     * https://github.com/MarlinFirmware/Marlin/issues/10341#issuecomment-388191754
+     *
+     * hoffbaked: on May 10 2018 tuned and improved the GRBL algorithm for Marlin:
+          Okay! It seems to be working good. I somewhat arbitrarily cut it off at 1mm
+          on then on anything with less sides than an octagon. With this, and the
+          reverse pass actually recalculating things, a corner acceleration value
+          of 1000 junction deviation of .05 are pretty reasonable. If the cycles
+          can be spared, a better acos could be used. For all I know, it may be
+          already calculated in a different place. */
 
     // Unit vector of previous path line segment
     static float previous_unit_vec[
       #if ENABLED(JUNCTION_DEVIATION_INCLUDE_E)
         XYZE
       #else
         XYZ
       #endif
     ];
 
     float unit_vec[] = {
       delta_mm[A_AXIS] * inverse_millimeters,
       delta_mm[B_AXIS] * inverse_millimeters,
       delta_mm[C_AXIS] * inverse_millimeters
       #if ENABLED(JUNCTION_DEVIATION_INCLUDE_E)
         , delta_mm[E_AXIS] * inverse_millimeters
       #endif
     };
 
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
-    if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
+    if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
       float junction_cos_theta = -previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
                                  -previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
                                  -previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS]
                                   #if ENABLED(JUNCTION_DEVIATION_INCLUDE_E)
                                     -previous_unit_vec[E_AXIS] * unit_vec[E_AXIS]
                                   #endif
                                 ;
 
       // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
       if (junction_cos_theta > 0.999999) {
         // For a 0 degree acute junction, just set minimum junction speed.
-        vmax_junction = MINIMUM_PLANNER_SPEED;
+        vmax_junction_sqr = sq(MINIMUM_PLANNER_SPEED);
       }
       else {
-        junction_cos_theta = MAX(junction_cos_theta, -0.999999); // Check for numerical round-off to avoid divide by zero.
+        NOLESS(junction_cos_theta, -0.999999); // Check for numerical round-off to avoid divide by zero.
         const float sin_theta_d2 = SQRT(0.5 * (1.0 - junction_cos_theta)); // Trig half angle identity. Always positive.
 
         // TODO: Technically, the acceleration used in calculation needs to be limited by the minimum of the
         // two junctions. However, this shouldn't be a significant problem except in extreme circumstances.
-        vmax_junction = SQRT((block->acceleration * JUNCTION_DEVIATION_FACTOR * sin_theta_d2) / (1.0 - sin_theta_d2));
+        vmax_junction_sqr = (JUNCTION_ACCELERATION_FACTOR * JUNCTION_DEVIATION_FACTOR * sin_theta_d2) / (1.0 - sin_theta_d2);
+        if (block->millimeters < 1.0) {
+
+          // Fast acos approximation, minus the error bar to be safe
+          float junction_theta = (RADIANS(-40) * sq(junction_cos_theta) - RADIANS(50)) * junction_cos_theta + RADIANS(90) - 0.18;
+
+          // If angle is greater than 135 degrees (octagon), find speed for approximate arc
+          if (junction_theta > RADIANS(135)) {
+            const float limit_sqr = block->millimeters / (RADIANS(180) - junction_theta) * JUNCTION_ACCELERATION_FACTOR;
+            NOMORE(vmax_junction_sqr, limit_sqr);
+          }
+        }
       }
 
-      vmax_junction = MIN3(vmax_junction, block->nominal_speed, previous_nominal_speed);
+      // Get the lowest speed
+      vmax_junction_sqr = MIN3(vmax_junction_sqr, block->nominal_speed_sqr, previous_nominal_speed_sqr);
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
-      vmax_junction = 0.0;
+      vmax_junction_sqr = 0.0;
 
     COPY(previous_unit_vec, unit_vec);
 
   #else // Classic Jerk Limiting
 
     /**
      * Adapted from Pr≈Ø≈°a MKS firmware
      * https://github.com/prusa3d/Prusa-Firmware
      *
      * Start with a safe speed (from which the machine may halt to stop immediately).
      */
 
     // Exit speed limited by a jerk to full halt of a previous last segment
     static float previous_safe_speed;
 
-    float safe_speed = block->nominal_speed;
+    const float nominal_speed = SQRT(block->nominal_speed_sqr);
+    float safe_speed = nominal_speed;
+
     uint8_t limited = 0;
     LOOP_XYZE(i) {
       const float jerk = ABS(current_speed[i]), maxj = max_jerk[i];
       if (jerk > maxj) {
         if (limited) {
-          const float mjerk = maxj * block->nominal_speed;
+          const float mjerk = maxj * nominal_speed;
           if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk;
         }
         else {
           ++limited;
           safe_speed = maxj;
         }
       }
     }
 
-    if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
+    float vmax_junction;
+    if (moves_queued && !UNEAR_ZERO(previous_nominal_speed_sqr)) {
       // Estimate a maximum velocity allowed at a joint of two successive segments.
       // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
       // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
 
-      // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
-      // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
-      vmax_junction = MIN(block->nominal_speed, previous_nominal_speed);
-
       // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
       float v_factor = 1;
       limited = 0;
 
+      // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
+      // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
+      const float previous_nominal_speed = SQRT(previous_nominal_speed_sqr);
+      vmax_junction = MIN(nominal_speed, previous_nominal_speed);
+
       // Now limit the jerk in all axes.
       const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
       LOOP_XYZE(axis) {
         // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
         float v_exit = previous_speed[axis] * smaller_speed_factor,
               v_entry = current_speed[axis];
         if (limited) {
           v_exit *= v_factor;
           v_entry *= v_factor;
         }
@@ -2056,109 +2227,99 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
       // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
       // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
       const float vmax_junction_threshold = vmax_junction * 0.99f;
       if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold)
         vmax_junction = safe_speed;
     }
     else
       vmax_junction = safe_speed;
 
     previous_safe_speed = safe_speed;
+    vmax_junction_sqr = sq(vmax_junction);
+
   #endif // Classic Jerk Limiting
 
   // Max entry speed of this block equals the max exit speed of the previous block.
-  block->max_entry_speed = vmax_junction;
+  block->max_entry_speed_sqr = vmax_junction_sqr;
 
   // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
-  const float v_allowable = max_allowable_speed(-block->acceleration, MINIMUM_PLANNER_SPEED, block->millimeters);
-  // If stepper ISR is disabled, this indicates buffer_segment wants to add a split block.
-  // In this case start with the max. allowed speed to avoid an interrupted first move.
-  block->entry_speed = STEPPER_ISR_ENABLED() ? MINIMUM_PLANNER_SPEED : MIN(vmax_junction, v_allowable);
+  const float v_allowable_sqr = max_allowable_speed_sqr(-block->acceleration, sq(MINIMUM_PLANNER_SPEED), block->millimeters);
+
+  // If we are trying to add a split block, start with the
+  // max. allowed speed to avoid an interrupted first move.
+  block->entry_speed_sqr = !split_move ? sq(MINIMUM_PLANNER_SPEED) : MIN(vmax_junction_sqr, v_allowable_sqr);
 
   // Initialize planner efficiency flags
   // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
   // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
   // the current block and next block junction speeds are guaranteed to always be at their maximum
   // junction speeds in deceleration and acceleration, respectively. This is due to how the current
   // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
-  block->flag |= block->nominal_speed <= v_allowable ? BLOCK_FLAG_RECALCULATE | BLOCK_FLAG_NOMINAL_LENGTH : BLOCK_FLAG_RECALCULATE;
+  block->flag |= block->nominal_speed_sqr <= v_allowable_sqr ? BLOCK_FLAG_RECALCULATE | BLOCK_FLAG_NOMINAL_LENGTH : BLOCK_FLAG_RECALCULATE;
 
   // Update previous path unit_vector and nominal speed
   COPY(previous_speed, current_speed);
-  previous_nominal_speed = block->nominal_speed;
-
-  // Move buffer head
-  block_buffer_head = next_buffer_head;
+  previous_nominal_speed_sqr = block->nominal_speed_sqr;
 
-  // Update the position (only when a move was queued)
+  // Update the position
   static_assert(COUNT(target) > 1, "Parameter to _buffer_steps must be (&target)[XYZE]!");
   COPY(position, target);
   #if HAS_POSITION_FLOAT
     COPY(position_float, target_float);
   #endif
 
-  recalculate();
-
-} // _buffer_steps()
+  // Movement was accepted
+  return true;
+} // _populate_block()
 
 /**
  * Planner::buffer_sync_block
  * Add a block to the buffer that just updates the position
  */
 void Planner::buffer_sync_block() {
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
-  block->flag = BLOCK_FLAG_SYNC_POSITION;
+  // Clear block
+  memset(block, 0, sizeof(block_t));
 
-  block->steps[A_AXIS] = position[A_AXIS];
-  block->steps[B_AXIS] = position[B_AXIS];
-  block->steps[C_AXIS] = position[C_AXIS];
-  block->steps[E_AXIS] = position[E_AXIS];
-
-  #if ENABLED(LIN_ADVANCE)
-    block->use_advance_lead = false;
-  #endif
-
-  block->nominal_speed   =
-  block->entry_speed     =
-  block->max_entry_speed =
-  block->millimeters     =
-  block->acceleration    = 0;
+  block->flag = BLOCK_FLAG_SYNC_POSITION;
 
-  block->step_event_count          =
-  block->nominal_rate              =
-  block->initial_rate              =
-  block->final_rate                =
-  block->acceleration_steps_per_s2 =
-  block->segment_time_us           = 0;
+  block->position[A_AXIS] = position[A_AXIS];
+  block->position[B_AXIS] = position[B_AXIS];
+  block->position[C_AXIS] = position[C_AXIS];
+  block->position[E_AXIS] = position[E_AXIS];
 
   block_buffer_head = next_buffer_head;
   stepper.wake_up();
 } // buffer_sync_block()
 
 /**
  * Planner::buffer_segment
  *
  * Add a new linear movement to the buffer in axis units.
  *
  * Leveling and kinematics should be applied ahead of calling this.
  *
  *  a,b,c,e     - target positions in mm and/or degrees
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *  millimeters - the length of the movement, if known
  */
-void Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/) {
+bool Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/) {
+
+  // If we are cleaning, do not accept queuing of movements
+  if (cleaning_buffer_counter) return false;
+
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
     if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
       position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
       last_extruder = extruder;
     }
   #endif
 
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
@@ -2213,51 +2374,94 @@ void Planner::buffer_segment(const float &a, const float &b, const float &c, con
   if (!has_blocks_queued()) {
 
     #define _BETWEEN(A) (position[_AXIS(A)] + target[_AXIS(A)]) >> 1
     const int32_t between[ABCE] = { _BETWEEN(A), _BETWEEN(B), _BETWEEN(C), _BETWEEN(E) };
 
     #if HAS_POSITION_FLOAT
       #define _BETWEEN_F(A) (position_float[_AXIS(A)] + target_float[_AXIS(A)]) * 0.5
       const float between_float[ABCE] = { _BETWEEN_F(A), _BETWEEN_F(B), _BETWEEN_F(C), _BETWEEN_F(E) };
     #endif
 
-    DISABLE_STEPPER_DRIVER_INTERRUPT();
+    // The new head value is not assigned yet
+    uint8_t buffer_head = 0;
+    bool added = false;
 
-    _buffer_steps(between
-      #if HAS_POSITION_FLOAT
-        , between_float
-      #endif
-      , fr_mm_s, extruder, millimeters * 0.5
-    );
+    uint8_t next_buffer_head;
+    block_t *block = get_next_free_block(next_buffer_head, 2);
 
-    const uint8_t next = block_buffer_head;
+    // Fill the block with the specified movement
+    if (
+      _populate_block(block, true, between
+        #if HAS_POSITION_FLOAT
+          , between_float
+        #endif
+        , fr_mm_s, extruder, millimeters * 0.5
+      )
+    ) {
+      // Movement accepted - Point to the next reserved block
+      block = &block_buffer[next_buffer_head];
+
+      // Store into the new to be stored head
+      buffer_head = next_buffer_head;
+      added = true;
+
+      // And advance the pointer to the next unused slot
+      next_buffer_head = next_block_index(next_buffer_head);
+    }
+
+    // Fill the second part of the block with the 2nd part of the movement
+    if (
+      _populate_block(block, true, target
+        #if HAS_POSITION_FLOAT
+          , target_float
+        #endif
+        , fr_mm_s, extruder, millimeters * 0.5
+      )
+    ) {
+      // Movement accepted - If this block is a continuation
+      // of the previous one, mark it as such
+      if (added) SBI(block->flag, BLOCK_BIT_CONTINUED);
+
+      // Store into the new to be stored head
+      buffer_head = next_buffer_head;
+      added = true;
+    }
 
-    _buffer_steps(target
+    // If any of the movements was added
+    if (added) {
+
+      // Move buffer head and add all the blocks that were filled
+      // successfully to the movement queue.
+      block_buffer_head = buffer_head;
+
+      // Update the position (only when a move was queued)
+      static_assert(COUNT(target) > 1, "Parameter to _buffer_steps must be (&target)[XYZE]!");
+      COPY(position, target);
       #if HAS_POSITION_FLOAT
-        , target_float
+        COPY(position_float, target_float);
       #endif
-      , fr_mm_s, extruder, millimeters * 0.5
-    );
 
-    SBI(block_buffer[next].flag, BLOCK_BIT_CONTINUED);
-    ENABLE_STEPPER_DRIVER_INTERRUPT();
+      // Recalculate and optimize trapezoidal speed profiles
+      recalculate();
+    }
   }
-  else
-    _buffer_steps(target
+  else if (
+    !_buffer_steps(target
       #if HAS_POSITION_FLOAT
         , target_float
       #endif
       , fr_mm_s, extruder, millimeters
-    );
+    )
+  ) return false;
 
   stepper.wake_up();
-
+  return true;
 } // buffer_segment()
 
 /**
  * Directly set the planner XYZ position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
 
 void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
@@ -2270,56 +2474,40 @@ void Planner::_set_position_mm(const float &a, const float &b, const float &c, c
   position[A_AXIS] = LROUND(a * axis_steps_per_mm[A_AXIS]),
   position[B_AXIS] = LROUND(b * axis_steps_per_mm[B_AXIS]),
   position[C_AXIS] = LROUND(c * axis_steps_per_mm[C_AXIS]),
   position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
   #if HAS_POSITION_FLOAT
     position_float[A_AXIS] = a;
     position_float[B_AXIS] = b;
     position_float[C_AXIS] = c;
     position_float[E_AXIS] = e;
   #endif
-  previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
+  previous_nominal_speed_sqr = 0.0; // Resets planner junction speeds. Assumes start from rest.
   ZERO(previous_speed);
   buffer_sync_block();
 }
 
 void Planner::set_position_mm_kinematic(const float (&cart)[XYZE]) {
   #if PLANNER_LEVELING
     float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
     apply_leveling(raw);
   #else
     const float (&raw)[XYZE] = cart;
   #endif
   #if IS_KINEMATIC
     inverse_kinematics(raw);
     _set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS]);
   #else
     _set_position_mm(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS]);
   #endif
 }
 
-/**
- * Sync from the stepper positions. (e.g., after an interrupted move)
- */
-void Planner::sync_from_steppers() {
-  LOOP_XYZE(i) {
-    position[i] = stepper.position((AxisEnum)i);
-    #if HAS_POSITION_FLOAT
-      position_float[i] = position[i] * steps_to_mm[i
-        #if ENABLED(DISTINCT_E_FACTORS)
-          + (i == E_AXIS ? active_extruder : 0)
-        #endif
-      ];
-    #endif
-  }
-}
-
 /**
  * Setters for planner position (also setting stepper position).
  */
 void Planner::set_position_mm(const AxisEnum axis, const float &v) {
   #if ENABLED(DISTINCT_E_FACTORS)
     const uint8_t axis_index = axis + (axis == E_AXIS ? active_extruder : 0);
     last_extruder = active_extruder;
   #else
     const uint8_t axis_index = axis;
   #endif

commit 43ddb29f9ed0eae0b0e1851d6b60b372df6006f0
Author: Jiri Jaburek <comps@nomail.dom>
Date:   Tue May 15 19:56:48 2018 +0200

    Add FAN_MAX_PWM for M106-controlled fans

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index a8da978c85..e1f5f10238 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1101,22 +1101,22 @@ void Planner::check_axes_activity() {
       #endif
       #if HAS_FAN1
         KICKSTART_FAN(1);
       #endif
       #if HAS_FAN2
         KICKSTART_FAN(2);
       #endif
 
     #endif // FAN_KICKSTART_TIME > 0
 
-    #ifdef FAN_MIN_PWM
-      #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ? ( FAN_MIN_PWM + (tail_fan_speed[f] * (255 - FAN_MIN_PWM)) / 255 ) : 0)
+    #if FAN_MIN_PWM != 0 || FAN_MAX_PWM != 255
+      #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ? map(tail_fan_speed[f], 1, 255, FAN_MIN_PWM, FAN_MAX_PWM) : 0)
     #else
       #define CALC_FAN_SPEED(f) tail_fan_speed[f]
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       #if HAS_FAN0
         thermalManager.soft_pwm_amount_fan[0] = CALC_FAN_SPEED(0);
       #endif
       #if HAS_FAN1
         thermalManager.soft_pwm_amount_fan[1] = CALC_FAN_SPEED(1);

commit 08e36e264e72f56bada1f25c1a784d6e3f9d2135
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 03:44:24 2018 -0500

    Apply _AXIS macro

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index a087ab9517..a8da978c85 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2205,25 +2205,25 @@ void Planner::buffer_segment(const float &a, const float &b, const float &c, con
     SERIAL_ECHOPAIR("->", target[Z_AXIS]);
     SERIAL_ECHOPAIR(") E:", e);
     SERIAL_ECHOPAIR(" (", position[E_AXIS]);
     SERIAL_ECHOPAIR("->", target[E_AXIS]);
     SERIAL_ECHOLNPGM(")");
   //*/
 
   // Always split the first move into two (if not homing or probing)
   if (!has_blocks_queued()) {
 
-    #define _BETWEEN(A) (position[A##_AXIS] + target[A##_AXIS]) >> 1
+    #define _BETWEEN(A) (position[_AXIS(A)] + target[_AXIS(A)]) >> 1
     const int32_t between[ABCE] = { _BETWEEN(A), _BETWEEN(B), _BETWEEN(C), _BETWEEN(E) };
 
     #if HAS_POSITION_FLOAT
-      #define _BETWEEN_F(A) (position_float[A##_AXIS] + target_float[A##_AXIS]) * 0.5
+      #define _BETWEEN_F(A) (position_float[_AXIS(A)] + target_float[_AXIS(A)]) * 0.5
       const float between_float[ABCE] = { _BETWEEN_F(A), _BETWEEN_F(B), _BETWEEN_F(C), _BETWEEN_F(E) };
     #endif
 
     DISABLE_STEPPER_DRIVER_INTERRUPT();
 
     _buffer_steps(between
       #if HAS_POSITION_FLOAT
         , between_float
       #endif
       , fr_mm_s, extruder, millimeters * 0.5

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ac8ae8aaaa..a087ab9517 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -826,21 +826,21 @@ void Planner::reverse_pass_kernel(block_t* const current, const block_t* const n
   if (current && next) {
     // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.
     // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and
     // check for maximum allowable speed reductions to ensure maximum possible planned speed.
     const float max_entry_speed = current->max_entry_speed;
     if (current->entry_speed != max_entry_speed || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
       // If nominal length true, max junction speed is guaranteed to be reached. Only compute
       // for max allowable speed if block is decelerating and nominal length is false.
       const float new_entry_speed = (TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH) || max_entry_speed <= next->entry_speed)
         ? max_entry_speed
-        : min(max_entry_speed, max_allowable_speed(-current->acceleration, next->entry_speed, current->millimeters));
+        : MIN(max_entry_speed, max_allowable_speed(-current->acceleration, next->entry_speed, current->millimeters));
       if (new_entry_speed != current->entry_speed) {
         current->entry_speed = new_entry_speed;
         SBI(current->flag, BLOCK_BIT_RECALCULATE);
       }
     }
   }
 }
 
 /**
  * recalculate() needs to go over the current plan twice.
@@ -852,21 +852,21 @@ void Planner::reverse_pass() {
     uint8_t blocknr = prev_block_index(block_buffer_head);
     block_t* current = &block_buffer[blocknr];
 
     // Last/newest block in buffer:
     const float max_entry_speed = current->max_entry_speed;
     if (current->entry_speed != max_entry_speed) {
       // If nominal length true, max junction speed is guaranteed to be reached. Only compute
       // for max allowable speed if block is decelerating and nominal length is false.
       const float new_entry_speed = TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH)
         ? max_entry_speed
-        : min(max_entry_speed, max_allowable_speed(-current->acceleration, MINIMUM_PLANNER_SPEED, current->millimeters));
+        : MIN(max_entry_speed, max_allowable_speed(-current->acceleration, MINIMUM_PLANNER_SPEED, current->millimeters));
       if (current->entry_speed != new_entry_speed) {
         current->entry_speed = new_entry_speed;
         SBI(current->flag, BLOCK_BIT_RECALCULATE);
       }
     }
 
     do {
       const block_t * const next = current;
       blocknr = prev_block_index(blocknr);
       current = &block_buffer[blocknr];
@@ -877,21 +877,21 @@ void Planner::reverse_pass() {
 
 // The kernel called by recalculate() when scanning the plan from first to last entry.
 void Planner::forward_pass_kernel(const block_t* const previous, block_t* const current) {
   if (previous) {
     // If the previous block is an acceleration block, too short to complete the full speed
     // change, adjust the entry speed accordingly. Entry speeds have already been reset,
     // maximized, and reverse-planned. If nominal length is set, max junction speed is
     // guaranteed to be reached. No need to recheck.
     if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH)) {
       if (previous->entry_speed < current->entry_speed) {
-        const float new_entry_speed = min(current->entry_speed, max_allowable_speed(-previous->acceleration, previous->entry_speed, previous->millimeters));
+        const float new_entry_speed = MIN(current->entry_speed, max_allowable_speed(-previous->acceleration, previous->entry_speed, previous->millimeters));
         // Check for junction speed change
         if (current->entry_speed != new_entry_speed) {
           current->entry_speed = new_entry_speed;
           SBI(current->flag, BLOCK_BIT_RECALCULATE);
         }
       }
     }
   }
 }
 
@@ -1377,21 +1377,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           #if HAS_POSITION_FLOAT
             position_float[E_AXIS] = target_float[E_AXIS];
           #endif
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-        if (labs(de * e_factor[extruder]) > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
+        if (ABS(de * e_factor[extruder]) > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           #if HAS_POSITION_FLOAT
             position_float[E_AXIS] = target_float[E_AXIS];
           #endif
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
@@ -1418,55 +1418,55 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
     if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
     if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
   #else
     if (da < 0) SBI(dm, X_AXIS);
     if (db < 0) SBI(dm, Y_AXIS);
     if (dc < 0) SBI(dm, Z_AXIS);
   #endif
   if (de < 0) SBI(dm, E_AXIS);
 
   const float esteps_float = de * e_factor[extruder];
-  const int32_t esteps = abs(esteps_float) + 0.5;
+  const int32_t esteps = ABS(esteps_float) + 0.5;
 
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
   // Clear all flags, including the "busy" bit
   block->flag = 0x00;
 
   // Set direction bits
   block->direction_bits = dm;
 
   // Number of steps for each axis
   // See http://www.corexy.com/theory.html
   #if CORE_IS_XY
-    block->steps[A_AXIS] = labs(da + db);
-    block->steps[B_AXIS] = labs(da - db);
-    block->steps[Z_AXIS] = labs(dc);
+    block->steps[A_AXIS] = ABS(da + db);
+    block->steps[B_AXIS] = ABS(da - db);
+    block->steps[Z_AXIS] = ABS(dc);
   #elif CORE_IS_XZ
-    block->steps[A_AXIS] = labs(da + dc);
-    block->steps[Y_AXIS] = labs(db);
-    block->steps[C_AXIS] = labs(da - dc);
+    block->steps[A_AXIS] = ABS(da + dc);
+    block->steps[Y_AXIS] = ABS(db);
+    block->steps[C_AXIS] = ABS(da - dc);
   #elif CORE_IS_YZ
-    block->steps[X_AXIS] = labs(da);
-    block->steps[B_AXIS] = labs(db + dc);
-    block->steps[C_AXIS] = labs(db - dc);
+    block->steps[X_AXIS] = ABS(da);
+    block->steps[B_AXIS] = ABS(db + dc);
+    block->steps[C_AXIS] = ABS(db - dc);
   #elif IS_SCARA
-    block->steps[A_AXIS] = labs(da);
-    block->steps[B_AXIS] = labs(db);
-    block->steps[Z_AXIS] = labs(dc);
+    block->steps[A_AXIS] = ABS(da);
+    block->steps[B_AXIS] = ABS(db);
+    block->steps[Z_AXIS] = ABS(dc);
   #else
     // default non-h-bot planning
-    block->steps[A_AXIS] = labs(da);
-    block->steps[B_AXIS] = labs(db);
-    block->steps[C_AXIS] = labs(dc);
+    block->steps[A_AXIS] = ABS(da);
+    block->steps[B_AXIS] = ABS(db);
+    block->steps[C_AXIS] = ABS(dc);
   #endif
 
   block->steps[E_AXIS] = esteps;
   block->step_event_count = MAX4(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return;
 
   // For a mixing extruder, get a magnified step_event_count for each
   #if ENABLED(MIXING_EXTRUDER)
@@ -1653,21 +1653,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
     #endif
   #else
     float delta_mm[ABCE];
     delta_mm[A_AXIS] = da * steps_to_mm[A_AXIS];
     delta_mm[B_AXIS] = db * steps_to_mm[B_AXIS];
     delta_mm[C_AXIS] = dc * steps_to_mm[C_AXIS];
   #endif
   delta_mm[E_AXIS] = esteps_float * steps_to_mm[E_AXIS_N];
 
   if (block->steps[A_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[B_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[C_AXIS] < MIN_STEPS_PER_SEGMENT) {
-    block->millimeters = FABS(delta_mm[E_AXIS]);
+    block->millimeters = ABS(delta_mm[E_AXIS]);
   }
   else if (!millimeters) {
     block->millimeters = SQRT(
       #if CORE_IS_XY
         sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS])
       #elif CORE_IS_XZ
         sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
       #elif CORE_IS_YZ
         sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
       #else
@@ -1744,21 +1744,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
             measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
           } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
         }
       }
     }
   #endif
 
   // Calculate and limit speed in mm/sec for each axis
   float current_speed[NUM_AXIS], speed_factor = 1.0; // factor <1 decreases speed
   LOOP_XYZE(i) {
-    const float cs = FABS((current_speed[i] = delta_mm[i] * inverse_secs));
+    const float cs = ABS((current_speed[i] = delta_mm[i] * inverse_secs));
     #if ENABLED(DISTINCT_E_FACTORS)
       if (i == E_AXIS) i += extruder;
     #endif
     if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
   }
 
   // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT
 
     // Check and limit the xy direction change frequency
@@ -1782,21 +1782,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
 
     if (TEST(direction_change, Y_AXIS)) {
       ys2 = axis_segment_time_us[Y_AXIS][2] = axis_segment_time_us[Y_AXIS][1];
       ys1 = axis_segment_time_us[Y_AXIS][1] = axis_segment_time_us[Y_AXIS][0];
       ys0 = 0;
     }
     ys0 = axis_segment_time_us[Y_AXIS][0] = ys0 + segment_time_us;
 
     const uint32_t max_x_segment_time = MAX3(xs0, xs1, xs2),
                    max_y_segment_time = MAX3(ys0, ys1, ys2),
-                   min_xy_segment_time = min(max_x_segment_time, max_y_segment_time);
+                   min_xy_segment_time = MIN(max_x_segment_time, max_y_segment_time);
     if (min_xy_segment_time < MAX_FREQ_TIME_US) {
       const float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME_US);
       NOMORE(speed_factor, low_sf);
     }
   #endif // XY_FREQUENCY_LIMIT
 
   // Correct the speed
   if (speed_factor < 1.0) {
     LOOP_XYZE(i) current_speed[i] *= speed_factor;
     block->nominal_speed *= speed_factor;
@@ -1966,21 +1966,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
                                     -previous_unit_vec[E_AXIS] * unit_vec[E_AXIS]
                                   #endif
                                 ;
 
       // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
       if (junction_cos_theta > 0.999999) {
         // For a 0 degree acute junction, just set minimum junction speed.
         vmax_junction = MINIMUM_PLANNER_SPEED;
       }
       else {
-        junction_cos_theta = max(junction_cos_theta, -0.999999); // Check for numerical round-off to avoid divide by zero.
+        junction_cos_theta = MAX(junction_cos_theta, -0.999999); // Check for numerical round-off to avoid divide by zero.
         const float sin_theta_d2 = SQRT(0.5 * (1.0 - junction_cos_theta)); // Trig half angle identity. Always positive.
 
         // TODO: Technically, the acceleration used in calculation needs to be limited by the minimum of the
         // two junctions. However, this shouldn't be a significant problem except in extreme circumstances.
         vmax_junction = SQRT((block->acceleration * JUNCTION_DEVIATION_FACTOR * sin_theta_d2) / (1.0 - sin_theta_d2));
       }
 
       vmax_junction = MIN3(vmax_junction, block->nominal_speed, previous_nominal_speed);
     }
     else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
@@ -1996,63 +1996,63 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
      *
      * Start with a safe speed (from which the machine may halt to stop immediately).
      */
 
     // Exit speed limited by a jerk to full halt of a previous last segment
     static float previous_safe_speed;
 
     float safe_speed = block->nominal_speed;
     uint8_t limited = 0;
     LOOP_XYZE(i) {
-      const float jerk = FABS(current_speed[i]), maxj = max_jerk[i];
+      const float jerk = ABS(current_speed[i]), maxj = max_jerk[i];
       if (jerk > maxj) {
         if (limited) {
           const float mjerk = maxj * block->nominal_speed;
           if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk;
         }
         else {
           ++limited;
           safe_speed = maxj;
         }
       }
     }
 
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
       // Estimate a maximum velocity allowed at a joint of two successive segments.
       // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
       // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
 
       // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
       // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
-      vmax_junction = min(block->nominal_speed, previous_nominal_speed);
+      vmax_junction = MIN(block->nominal_speed, previous_nominal_speed);
 
       // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
       float v_factor = 1;
       limited = 0;
 
       // Now limit the jerk in all axes.
       const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
       LOOP_XYZE(axis) {
         // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
         float v_exit = previous_speed[axis] * smaller_speed_factor,
               v_entry = current_speed[axis];
         if (limited) {
           v_exit *= v_factor;
           v_entry *= v_factor;
         }
 
         // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
         const float jerk = (v_exit > v_entry)
             ? //                                  coasting             axis reversal
-              ( (v_entry > 0 || v_exit < 0) ? (v_exit - v_entry) : max(v_exit, -v_entry) )
+              ( (v_entry > 0 || v_exit < 0) ? (v_exit - v_entry) : MAX(v_exit, -v_entry) )
             : // v_exit <= v_entry                coasting             axis reversal
-              ( (v_entry < 0 || v_exit > 0) ? (v_entry - v_exit) : max(-v_exit, v_entry) );
+              ( (v_entry < 0 || v_exit > 0) ? (v_entry - v_exit) : MAX(-v_exit, v_entry) );
 
         if (jerk > max_jerk[axis]) {
           v_factor *= max_jerk[axis] / jerk;
           ++limited;
         }
       }
       if (limited) vmax_junction *= v_factor;
       // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
       // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
       const float vmax_junction_threshold = vmax_junction * 0.99f;
@@ -2065,21 +2065,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
     previous_safe_speed = safe_speed;
   #endif // Classic Jerk Limiting
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed = vmax_junction;
 
   // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
   const float v_allowable = max_allowable_speed(-block->acceleration, MINIMUM_PLANNER_SPEED, block->millimeters);
   // If stepper ISR is disabled, this indicates buffer_segment wants to add a split block.
   // In this case start with the max. allowed speed to avoid an interrupted first move.
-  block->entry_speed = STEPPER_ISR_ENABLED() ? MINIMUM_PLANNER_SPEED : min(vmax_junction, v_allowable);
+  block->entry_speed = STEPPER_ISR_ENABLED() ? MINIMUM_PLANNER_SPEED : MIN(vmax_junction, v_allowable);
 
   // Initialize planner efficiency flags
   // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
   // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
   // the current block and next block junction speeds are guaranteed to always be at their maximum
   // junction speeds in deceleration and acceleration, respectively. This is due to how the current
   // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
   block->flag |= block->nominal_speed <= v_allowable ? BLOCK_FLAG_RECALCULATE | BLOCK_FLAG_NOMINAL_LENGTH : BLOCK_FLAG_RECALCULATE;

commit 8f8c6a9bc4f1c8b2d927e74339a48217d9b48ec7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 09:59:11 2018 -0500

    Move get_axis_position_mm to Planner (#10718)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 99d814ce4b..ac8ae8aaaa 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1292,20 +1292,51 @@ void Planner::check_axes_activity() {
       #endif
     }
 
     #if ENABLED(SKEW_CORRECTION)
       unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]);
     #endif
   }
 
 #endif // PLANNER_LEVELING
 
+/**
+ * Get an axis position according to stepper position(s)
+ * For CORE machines apply translation from ABC to XYZ.
+ */
+float Planner::get_axis_position_mm(const AxisEnum axis) {
+  float axis_steps;
+  #if IS_CORE
+    // Requesting one of the "core" axes?
+    if (axis == CORE_AXIS_1 || axis == CORE_AXIS_2) {
+
+      // Protect the access to the position.
+      const bool was_enabled = STEPPER_ISR_ENABLED();
+      DISABLE_STEPPER_DRIVER_INTERRUPT();
+
+      // ((a1+a2)+(a1-a2))/2 -> (a1+a2+a1-a2)/2 -> (a1+a1)/2 -> a1
+      // ((a1+a2)-(a1-a2))/2 -> (a1+a2-a1+a2)/2 -> (a2+a2)/2 -> a2
+      axis_steps = 0.5f * (
+        axis == CORE_AXIS_2 ? CORESIGN(stepper.position(CORE_AXIS_1) - stepper.position(CORE_AXIS_2))
+                            : stepper.position(CORE_AXIS_1) + stepper.position(CORE_AXIS_2)
+      );
+
+      if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+    }
+    else
+      axis_steps = stepper.position(axis);
+  #else
+    axis_steps = stepper.position(axis);
+  #endif
+  return axis_steps * steps_to_mm[axis];
+}
+
 /**
  * Block until all buffered steps are executed / cleaned
  */
 void Planner::synchronize() { while (has_blocks_queued() || stepper.cleaning_buffer_counter) idle(); }
 
 /**
  * Planner::_buffer_steps
  *
  * Add a new linear movement to the buffer (in terms of steps).
  *

commit 306f0f2135e4b2aed749a0d1b870abf17d883e38
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 01:38:02 2018 -0500

    Move Stepper::synchronize to Planner (#10713)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index a1d099767e..99d814ce4b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1292,20 +1292,25 @@ void Planner::check_axes_activity() {
       #endif
     }
 
     #if ENABLED(SKEW_CORRECTION)
       unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]);
     #endif
   }
 
 #endif // PLANNER_LEVELING
 
+/**
+ * Block until all buffered steps are executed / cleaned
+ */
+void Planner::synchronize() { while (has_blocks_queued() || stepper.cleaning_buffer_counter) idle(); }
+
 /**
  * Planner::_buffer_steps
  *
  * Add a new linear movement to the buffer (in terms of steps).
  *
  *  target      - target position in steps units
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  */
 void Planner::_buffer_steps(const int32_t (&target)[XYZE]

commit 439e0cdd0f8b0701e5468111c37d5f2036e2d0d6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 10 01:30:55 2018 -0500

    Patch up reverse_pass_kernel (and other planner code) (#10674)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index d4da89c0fd..a1d099767e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -814,84 +814,89 @@ void Planner::calculate_trapezoid_for_block(block_t* const block, const float &e
 }
 
 // "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.
 // This method will calculate the junction jerk as the euclidean distance between the nominal
 // velocities of the respective blocks.
 //inline float junction_jerk(block_t *before, block_t *after) {
 //  return SQRT(
 //    POW((before->speed_x-after->speed_x), 2)+POW((before->speed_y-after->speed_y), 2));
 //}
 
-
 // The kernel called by recalculate() when scanning the plan from last to first entry.
-void Planner::reverse_pass_kernel(block_t* const current, const block_t * const next) {
-  if (!current || !next) return;
-  // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.
-  // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and
-  // check for maximum allowable speed reductions to ensure maximum possible planned speed.
-  float max_entry_speed = current->max_entry_speed;
-  if (current->entry_speed != max_entry_speed) {
-    // If nominal length true, max junction speed is guaranteed to be reached. Only compute
-    // for max allowable speed if block is decelerating and nominal length is false.
-    current->entry_speed = (TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH) || max_entry_speed <= next->entry_speed)
-      ? max_entry_speed
-      : min(max_entry_speed, max_allowable_speed(-current->acceleration, next->entry_speed, current->millimeters));
-    SBI(current->flag, BLOCK_BIT_RECALCULATE);
+void Planner::reverse_pass_kernel(block_t* const current, const block_t* const next) {
+  if (current && next) {
+    // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.
+    // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and
+    // check for maximum allowable speed reductions to ensure maximum possible planned speed.
+    const float max_entry_speed = current->max_entry_speed;
+    if (current->entry_speed != max_entry_speed || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
+      // If nominal length true, max junction speed is guaranteed to be reached. Only compute
+      // for max allowable speed if block is decelerating and nominal length is false.
+      const float new_entry_speed = (TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH) || max_entry_speed <= next->entry_speed)
+        ? max_entry_speed
+        : min(max_entry_speed, max_allowable_speed(-current->acceleration, next->entry_speed, current->millimeters));
+      if (new_entry_speed != current->entry_speed) {
+        current->entry_speed = new_entry_speed;
+        SBI(current->flag, BLOCK_BIT_RECALCULATE);
+      }
+    }
   }
 }
 
 /**
  * recalculate() needs to go over the current plan twice.
  * Once in reverse and once forward. This implements the reverse pass.
  */
 void Planner::reverse_pass() {
   if (movesplanned() > 2) {
-    const uint8_t endnr = BLOCK_MOD(block_buffer_tail + 1); // tail is running. tail+1 shouldn't be altered because it's connected to the running block.
+    const uint8_t endnr = next_block_index(block_buffer_tail); // tail is running. tail+1 shouldn't be altered because it's connected to the running block.
     uint8_t blocknr = prev_block_index(block_buffer_head);
     block_t* current = &block_buffer[blocknr];
 
     // Last/newest block in buffer:
     const float max_entry_speed = current->max_entry_speed;
     if (current->entry_speed != max_entry_speed) {
       // If nominal length true, max junction speed is guaranteed to be reached. Only compute
       // for max allowable speed if block is decelerating and nominal length is false.
-      current->entry_speed = TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH)
+      const float new_entry_speed = TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH)
         ? max_entry_speed
         : min(max_entry_speed, max_allowable_speed(-current->acceleration, MINIMUM_PLANNER_SPEED, current->millimeters));
-      SBI(current->flag, BLOCK_BIT_RECALCULATE);
+      if (current->entry_speed != new_entry_speed) {
+        current->entry_speed = new_entry_speed;
+        SBI(current->flag, BLOCK_BIT_RECALCULATE);
+      }
     }
 
     do {
       const block_t * const next = current;
       blocknr = prev_block_index(blocknr);
       current = &block_buffer[blocknr];
       reverse_pass_kernel(current, next);
     } while (blocknr != endnr);
   }
 }
 
 // The kernel called by recalculate() when scanning the plan from first to last entry.
-void Planner::forward_pass_kernel(const block_t * const previous, block_t* const current) {
-  if (!previous) return;
-
-  // If the previous block is an acceleration block, but it is not long enough to complete the
-  // full speed change within the block, we need to adjust the entry speed accordingly. Entry
-  // speeds have already been reset, maximized, and reverse planned by reverse planner.
-  // If nominal length is true, max junction speed is guaranteed to be reached. No need to recheck.
-  if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH)) {
-    if (previous->entry_speed < current->entry_speed) {
-      float entry_speed = min(current->entry_speed,
-                               max_allowable_speed(-previous->acceleration, previous->entry_speed, previous->millimeters));
-      // Check for junction speed change
-      if (current->entry_speed != entry_speed) {
-        current->entry_speed = entry_speed;
-        SBI(current->flag, BLOCK_BIT_RECALCULATE);
+void Planner::forward_pass_kernel(const block_t* const previous, block_t* const current) {
+  if (previous) {
+    // If the previous block is an acceleration block, too short to complete the full speed
+    // change, adjust the entry speed accordingly. Entry speeds have already been reset,
+    // maximized, and reverse-planned. If nominal length is set, max junction speed is
+    // guaranteed to be reached. No need to recheck.
+    if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH)) {
+      if (previous->entry_speed < current->entry_speed) {
+        const float new_entry_speed = min(current->entry_speed, max_allowable_speed(-previous->acceleration, previous->entry_speed, previous->millimeters));
+        // Check for junction speed change
+        if (current->entry_speed != new_entry_speed) {
+          current->entry_speed = new_entry_speed;
+          SBI(current->flag, BLOCK_BIT_RECALCULATE);
+        }
       }
     }
   }
 }
 
 /**
  * recalculate() needs to go over the current plan twice.
  * Once in reverse and once forward. This implements the forward pass.
  */
 void Planner::forward_pass() {

commit 57c2f8d2f6abc3f769b11ed3008e0f2febd773fe
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 10 00:16:51 2018 -0500

    Trailing whitespace cleanup

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index abbf9e4723..d4da89c0fd 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -415,292 +415,292 @@ void Planner::init() {
         // result = 0xFFFFFF / d
         // %8:%7:%6 = interval
         // %16:%15:%14 = nr
         // %13 = 0
 
         // A plain division of 24x24 bits should take 388 cycles to complete. We will
         // use Newton-Raphson for the calculation, and will strive to get way less cycles
         // for the same result - Using C division, it takes 500cycles to complete .
 
         A("clr %3")                        // idx = 0
-        A("mov %14,%6")      
-        A("mov %15,%7")      
+        A("mov %14,%6")
+        A("mov %15,%7")
         A("mov %16,%8")                    // nr = interval
         A("tst %16")                       // nr & 0xFF0000 == 0 ?
         A("brne 2f")                       // No, skip this
-        A("mov %16,%15")      
+        A("mov %16,%15")
         A("mov %15,%14")                   // nr <<= 8, %14 not needed
         A("subi %3,-8")                    // idx += 8
         A("tst %16")                       // nr & 0xFF0000 == 0 ?
         A("brne 2f")                       // No, skip this
         A("mov %16,%15")                   // nr <<= 8, %14 not needed
         A("clr %15")                       // We clear %14
         A("subi %3,-8")                    // idx += 8
 
         // here %16 != 0 and %16:%15 contains at least 9 MSBits, or both %16:%15 are 0
         L("2")
         A("cpi %16,0x10")                  // (nr & 0xF00000) == 0 ?
         A("brcc 3f")                       // No, skip this
         A("swap %15")                      // Swap nibbles
         A("swap %16")                      // Swap nibbles. Low nibble is 0
-        A("mov %14, %15")      
+        A("mov %14, %15")
         A("andi %14,0x0F")                 // Isolate low nibble
         A("andi %15,0xF0")                 // Keep proper nibble in %15
         A("or %16, %14")                   // %16:%15 <<= 4
         A("subi %3,-4")                    // idx += 4
 
         L("3")
         A("cpi %16,0x40")                  // (nr & 0xC00000) == 0 ?
         A("brcc 4f")                       // No, skip this
-        A("add %15,%15")      
-        A("adc %16,%16")      
-        A("add %15,%15")      
+        A("add %15,%15")
+        A("adc %16,%16")
+        A("add %15,%15")
         A("adc %16,%16")                   // %16:%15 <<= 2
         A("subi %3,-2")                    // idx += 2
 
         L("4")
         A("cpi %16,0x80")                  // (nr & 0x800000) == 0 ?
         A("brcc 5f")                       // No, skip this
-        A("add %15,%15")      
+        A("add %15,%15")
         A("adc %16,%16")                   // %16:%15 <<= 1
         A("inc %3")                        // idx += 1
 
         // Now %16:%15 contains its MSBit set to 1, or %16:%15 is == 0. We are now absolutely sure
         // we have at least 9 MSBits available to enter the initial estimation table
         L("5")
-        A("add %15,%15")      
+        A("add %15,%15")
         A("adc %16,%16")                   // %16:%15 = tidx = (nr <<= 1), we lose the top MSBit (always set to 1, %16 is the index into the inverse table)
         A("add r30,%16")                   // Only use top 8 bits
         A("adc r31,%13")                   // r31:r30 = inv_tab + (tidx)
         A("lpm %14, Z")                    // %14 = inv_tab[tidx]
         A("ldi %15, 1")                    // %15 = 1  %15:%14 = inv_tab[tidx] + 256
 
         // We must scale the approximation to the proper place
         A("clr %16")                       // %16 will always be 0 here
         A("subi %3,8")                     // idx == 8 ?
         A("breq 6f")                       // yes, no need to scale
         A("brcs 7f")                       // If C=1, means idx < 8, result was negative!
 
         // idx > 8, now %3 = idx - 8. We must perform a left shift. idx range:[1-8]
         A("sbrs %3,0")                     // shift by 1bit position?
         A("rjmp 8f")                       // No
-        A("add %14,%14")      
+        A("add %14,%14")
         A("adc %15,%15")                   // %15:16 <<= 1
         L("8")
         A("sbrs %3,1")                     // shift by 2bit position?
         A("rjmp 9f")                       // No
-        A("add %14,%14")      
-        A("adc %15,%15")      
-        A("add %14,%14")      
+        A("add %14,%14")
+        A("adc %15,%15")
+        A("add %14,%14")
         A("adc %15,%15")                   // %15:16 <<= 1
         L("9")
         A("sbrs %3,2")                     // shift by 4bits position?
         A("rjmp 16f")                      // No
         A("swap %15")                      // Swap nibbles. lo nibble of %15 will always be 0
         A("swap %14")                      // Swap nibbles
-        A("mov %12,%14")      
+        A("mov %12,%14")
         A("andi %12,0x0F")                 // isolate low nibble
         A("andi %14,0xF0")                 // and clear it
         A("or %15,%12")                    // %15:%16 <<= 4
         L("16")
         A("sbrs %3,3")                     // shift by 8bits position?
         A("rjmp 6f")                       // No, we are done
-        A("mov %16,%15")      
-        A("mov %15,%14")      
-        A("clr %14")      
-        A("jmp 6f")      
+        A("mov %16,%15")
+        A("mov %15,%14")
+        A("clr %14")
+        A("jmp 6f")
 
         // idx < 8, now %3 = idx - 8. Get the count of bits
         L("7")
         A("neg %3")                        // %3 = -idx = count of bits to move right. idx range:[1...8]
         A("sbrs %3,0")                     // shift by 1 bit position ?
         A("rjmp 10f")                      // No, skip it
         A("asr %15")                       // (bit7 is always 0 here)
-        A("ror %14")      
+        A("ror %14")
         L("10")
         A("sbrs %3,1")                     // shift by 2 bit position ?
         A("rjmp 11f")                      // No, skip it
         A("asr %15")                       // (bit7 is always 0 here)
-        A("ror %14")      
+        A("ror %14")
         A("asr %15")                       // (bit7 is always 0 here)
-        A("ror %14")      
+        A("ror %14")
         L("11")
         A("sbrs %3,2")                     // shift by 4 bit position ?
         A("rjmp 12f")                      // No, skip it
         A("swap %15")                      // Swap nibbles
         A("andi %14, 0xF0")                // Lose the lowest nibble
         A("swap %14")                      // Swap nibbles. Upper nibble is 0
         A("or %14,%15")                    // Pass nibble from upper byte
         A("andi %15, 0x0F")                // And get rid of that nibble
         L("12")
         A("sbrs %3,3")                     // shift by 8 bit position ?
         A("rjmp 6f")                       // No, skip it
-        A("mov %14,%15")      
-        A("clr %15")      
+        A("mov %14,%15")
+        A("clr %15")
         L("6")                       // %16:%15:%14 = initial estimation of 0x1000000 / d
 
         // Now, we must refine the estimation present on %16:%15:%14 using 1 iteration
         // of Newton-Raphson. As it has a quadratic convergence, 1 iteration is enough
         // to get more than 18bits of precision (the initial table lookup gives 9 bits of
         // precision to start from). 18bits of precision is all what is needed here for result
 
         // %8:%7:%6 = d = interval
         // %16:%15:%14 = x = initial estimation of 0x1000000 / d
         // %13 = 0
         // %3:%2:%1:%0 = working accumulator
 
         // Compute 1<<25 - x*d. Result should never exceed 25 bits and should always be positive
-        A("clr %0")      
-        A("clr %1")      
-        A("clr %2")      
+        A("clr %0")
+        A("clr %1")
+        A("clr %2")
         A("ldi %3,2")                      // %3:%2:%1:%0 = 0x2000000
         A("mul %6,%14")                    // r1:r0 = LO(d) * LO(x)
-        A("sub %0,r0")      
-        A("sbc %1,r1")      
-        A("sbc %2,%13")      
+        A("sub %0,r0")
+        A("sbc %1,r1")
+        A("sbc %2,%13")
         A("sbc %3,%13")                    // %3:%2:%1:%0 -= LO(d) * LO(x)
         A("mul %7,%14")                    // r1:r0 = MI(d) * LO(x)
-        A("sub %1,r0")      
-        A("sbc %2,r1" )      
+        A("sub %1,r0")
+        A("sbc %2,r1" )
         A("sbc %3,%13")                    // %3:%2:%1:%0 -= MI(d) * LO(x) << 8
         A("mul %8,%14")                    // r1:r0 = HI(d) * LO(x)
-        A("sub %2,r0")      
+        A("sub %2,r0")
         A("sbc %3,r1")                     // %3:%2:%1:%0 -= MIL(d) * LO(x) << 16
         A("mul %6,%15")                    // r1:r0 = LO(d) * MI(x)
-        A("sub %1,r0")      
-        A("sbc %2,r1")      
+        A("sub %1,r0")
+        A("sbc %2,r1")
         A("sbc %3,%13")                    // %3:%2:%1:%0 -= LO(d) * MI(x) << 8
         A("mul %7,%15")                    // r1:r0 = MI(d) * MI(x)
-        A("sub %2,r0")      
+        A("sub %2,r0")
         A("sbc %3,r1")                     // %3:%2:%1:%0 -= MI(d) * MI(x) << 16
         A("mul %8,%15")                    // r1:r0 = HI(d) * MI(x)
         A("sub %3,r0")                     // %3:%2:%1:%0 -= MIL(d) * MI(x) << 24
         A("mul %6,%16")                    // r1:r0 = LO(d) * HI(x)
-        A("sub %2,r0")      
+        A("sub %2,r0")
         A("sbc %3,r1")                     // %3:%2:%1:%0 -= LO(d) * HI(x) << 16
         A("mul %7,%16")                    // r1:r0 = MI(d) * HI(x)
         A("sub %3,r0")                     // %3:%2:%1:%0 -= MI(d) * HI(x) << 24
         // %3:%2:%1:%0 = (1<<25) - x*d     [169]
 
         // We need to multiply that result by x, and we are only interested in the top 24bits of that multiply
 
         // %16:%15:%14 = x = initial estimation of 0x1000000 / d
         // %3:%2:%1:%0 = (1<<25) - x*d = acc
         // %13 = 0
 
         // result = %11:%10:%9:%5:%4
         A("mul %14,%0")                    // r1:r0 = LO(x) * LO(acc)
-        A("mov %4,r1")      
-        A("clr %5")      
-        A("clr %9")      
-        A("clr %10")      
+        A("mov %4,r1")
+        A("clr %5")
+        A("clr %9")
+        A("clr %10")
         A("clr %11")                       // %11:%10:%9:%5:%4 = LO(x) * LO(acc) >> 8
         A("mul %15,%0")                    // r1:r0 = MI(x) * LO(acc)
-        A("add %4,r0")      
-        A("adc %5,r1")      
-        A("adc %9,%13")      
-        A("adc %10,%13")      
+        A("add %4,r0")
+        A("adc %5,r1")
+        A("adc %9,%13")
+        A("adc %10,%13")
         A("adc %11,%13")                   // %11:%10:%9:%5:%4 += MI(x) * LO(acc)
         A("mul %16,%0")                    // r1:r0 = HI(x) * LO(acc)
-        A("add %5,r0")      
-        A("adc %9,r1")      
-        A("adc %10,%13")      
+        A("add %5,r0")
+        A("adc %9,r1")
+        A("adc %10,%13")
         A("adc %11,%13")                   // %11:%10:%9:%5:%4 += MI(x) * LO(acc) << 8
 
         A("mul %14,%1")                    // r1:r0 = LO(x) * MIL(acc)
-        A("add %4,r0")      
-        A("adc %5,r1")      
-        A("adc %9,%13")      
-        A("adc %10,%13")      
+        A("add %4,r0")
+        A("adc %5,r1")
+        A("adc %9,%13")
+        A("adc %10,%13")
         A("adc %11,%13")                   // %11:%10:%9:%5:%4 = LO(x) * MIL(acc)
         A("mul %15,%1")                    // r1:r0 = MI(x) * MIL(acc)
-        A("add %5,r0")      
-        A("adc %9,r1")      
-        A("adc %10,%13")      
+        A("add %5,r0")
+        A("adc %9,r1")
+        A("adc %10,%13")
         A("adc %11,%13")                   // %11:%10:%9:%5:%4 += MI(x) * MIL(acc) << 8
         A("mul %16,%1")                    // r1:r0 = HI(x) * MIL(acc)
-        A("add %9,r0")      
-        A("adc %10,r1")      
+        A("add %9,r0")
+        A("adc %10,r1")
         A("adc %11,%13")                   // %11:%10:%9:%5:%4 += MI(x) * MIL(acc) << 16
 
         A("mul %14,%2")                    // r1:r0 = LO(x) * MIH(acc)
-        A("add %5,r0")      
-        A("adc %9,r1")      
-        A("adc %10,%13")      
+        A("add %5,r0")
+        A("adc %9,r1")
+        A("adc %10,%13")
         A("adc %11,%13")                   // %11:%10:%9:%5:%4 = LO(x) * MIH(acc) << 8
         A("mul %15,%2")                    // r1:r0 = MI(x) * MIH(acc)
-        A("add %9,r0")      
-        A("adc %10,r1")      
+        A("add %9,r0")
+        A("adc %10,r1")
         A("adc %11,%13")                   // %11:%10:%9:%5:%4 += MI(x) * MIH(acc) << 16
         A("mul %16,%2")                    // r1:r0 = HI(x) * MIH(acc)
-        A("add %10,r0")      
+        A("add %10,r0")
         A("adc %11,r1")                    // %11:%10:%9:%5:%4 += MI(x) * MIH(acc) << 24
 
         A("mul %14,%3")                    // r1:r0 = LO(x) * HI(acc)
-        A("add %9,r0")      
-        A("adc %10,r1")      
+        A("add %9,r0")
+        A("adc %10,r1")
         A("adc %11,%13")                   // %11:%10:%9:%5:%4 = LO(x) * HI(acc) << 16
         A("mul %15,%3")                    // r1:r0 = MI(x) * HI(acc)
-        A("add %10,r0")      
+        A("add %10,r0")
         A("adc %11,r1")                    // %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 24
         A("mul %16,%3")                    // r1:r0 = HI(x) * HI(acc)
         A("add %11,r0")                    // %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 32
 
         // At this point, %11:%10:%9 contains the new estimation of x.
 
         // Finally, we must correct the result. Estimate remainder as
         // (1<<24) - x*d
         // %11:%10:%9 = x
         // %8:%7:%6 = d = interval" "\n\t"
-        A("ldi %3,1")      
-        A("clr %2")      
-        A("clr %1")      
+        A("ldi %3,1")
+        A("clr %2")
+        A("clr %1")
         A("clr %0")                        // %3:%2:%1:%0 = 0x1000000
         A("mul %6,%9")                     // r1:r0 = LO(d) * LO(x)
-        A("sub %0,r0")      
-        A("sbc %1,r1")      
-        A("sbc %2,%13")      
+        A("sub %0,r0")
+        A("sbc %1,r1")
+        A("sbc %2,%13")
         A("sbc %3,%13")                    // %3:%2:%1:%0 -= LO(d) * LO(x)
         A("mul %7,%9")                     // r1:r0 = MI(d) * LO(x)
-        A("sub %1,r0")      
-        A("sbc %2,r1")      
+        A("sub %1,r0")
+        A("sbc %2,r1")
         A("sbc %3,%13")                    // %3:%2:%1:%0 -= MI(d) * LO(x) << 8
         A("mul %8,%9")                     // r1:r0 = HI(d) * LO(x)
-        A("sub %2,r0")      
+        A("sub %2,r0")
         A("sbc %3,r1")                     // %3:%2:%1:%0 -= MIL(d) * LO(x) << 16
         A("mul %6,%10")                    // r1:r0 = LO(d) * MI(x)
-        A("sub %1,r0")      
-        A("sbc %2,r1")      
+        A("sub %1,r0")
+        A("sbc %2,r1")
         A("sbc %3,%13")                    // %3:%2:%1:%0 -= LO(d) * MI(x) << 8
         A("mul %7,%10")                    // r1:r0 = MI(d) * MI(x)
-        A("sub %2,r0")      
+        A("sub %2,r0")
         A("sbc %3,r1")                     // %3:%2:%1:%0 -= MI(d) * MI(x) << 16
         A("mul %8,%10")                    // r1:r0 = HI(d) * MI(x)
         A("sub %3,r0")                     // %3:%2:%1:%0 -= MIL(d) * MI(x) << 24
         A("mul %6,%11")                    // r1:r0 = LO(d) * HI(x)
-        A("sub %2,r0")      
+        A("sub %2,r0")
         A("sbc %3,r1")                     // %3:%2:%1:%0 -= LO(d) * HI(x) << 16
         A("mul %7,%11")                    // r1:r0 = MI(d) * HI(x)
         A("sub %3,r0")                     // %3:%2:%1:%0 -= MI(d) * HI(x) << 24
         // %3:%2:%1:%0 = r = (1<<24) - x*d
         // %8:%7:%6 = d = interval
 
         // Perform the final correction
-        A("sub %0,%6")      
-        A("sbc %1,%7")      
+        A("sub %0,%6")
+        A("sbc %1,%7")
         A("sbc %2,%8")                     // r -= d
         A("brcs 14f")                      // if ( r >= d)
 
         // %11:%10:%9 = x
-        A("ldi %3,1")      
-        A("add %9,%3")      
-        A("adc %10,%13")      
+        A("ldi %3,1")
+        A("add %9,%3")
+        A("adc %10,%13")
         A("adc %11,%13")                   // x++
         L("14")
 
         // Estimation is done. %11:%10:%9 = x
         A("clr __zero_reg__")              // Make C runtime happy
         // [211 cycles total]
         : "=r" (r2),
           "=r" (r3),
           "=r" (r4),
           "=d" (r5),
@@ -1867,39 +1867,39 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
       #endif
     }
   #endif
 
   float vmax_junction; // Initial limit on the segment entry velocity
 
   #if ENABLED(JUNCTION_DEVIATION)
 
     /**
      * Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
-     * Let a circle be tangent to both previous and current path line segments, where the junction 
-     * deviation is defined as the distance from the junction to the closest edge of the circle, 
-     * colinear with the circle center. The circular segment joining the two paths represents the 
+     * Let a circle be tangent to both previous and current path line segments, where the junction
+     * deviation is defined as the distance from the junction to the closest edge of the circle,
+     * colinear with the circle center. The circular segment joining the two paths represents the
      * path of centripetal acceleration. Solve for max velocity based on max acceleration about the
-     * radius of the circle, defined indirectly by junction deviation. This may be also viewed as 
-     * path width or max_jerk in the previous Grbl version. This approach does not actually deviate 
+     * radius of the circle, defined indirectly by junction deviation. This may be also viewed as
+     * path width or max_jerk in the previous Grbl version. This approach does not actually deviate
      * from path, but used as a robust way to compute cornering speeds, as it takes into account the
      * nonlinearities of both the junction angle and junction velocity.
      *
-     * NOTE: If the junction deviation value is finite, Grbl executes the motions in an exact path 
+     * NOTE: If the junction deviation value is finite, Grbl executes the motions in an exact path
      * mode (G61). If the junction deviation value is zero, Grbl will execute the motion in an exact
      * stop mode (G61.1) manner. In the future, if continuous mode (G64) is desired, the math here
      * is exactly the same. Instead of motioning all the way to junction point, the machine will
      * just follow the arc circle defined here. The Arduino doesn't have the CPU cycles to perform
-     * a continuous mode path, but ARM-based microcontrollers most certainly do. 
-     * 
+     * a continuous mode path, but ARM-based microcontrollers most certainly do.
+     *
      * NOTE: The max junction speed is a fixed value, since machine acceleration limits cannot be
      * changed dynamically during operation nor can the line move geometry. This must be kept in
-     * memory in the event of a feedrate override changing the nominal speeds of blocks, which can 
+     * memory in the event of a feedrate override changing the nominal speeds of blocks, which can
      * change the overall maximum entry speed conditions of all blocks.
      */
 
     // Unit vector of previous path line segment
     static float previous_unit_vec[
       #if ENABLED(JUNCTION_DEVIATION_INCLUDE_E)
         XYZE
       #else
         XYZ
       #endif
@@ -2013,21 +2013,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
       }
       if (limited) vmax_junction *= v_factor;
       // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
       // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
       const float vmax_junction_threshold = vmax_junction * 0.99f;
       if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold)
         vmax_junction = safe_speed;
     }
     else
       vmax_junction = safe_speed;
-  
+
     previous_safe_speed = safe_speed;
   #endif // Classic Jerk Limiting
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed = vmax_junction;
 
   // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
   const float v_allowable = max_allowable_speed(-block->acceleration, MINIMUM_PLANNER_SPEED, block->millimeters);
   // If stepper ISR is disabled, this indicates buffer_segment wants to add a split block.
   // In this case start with the max. allowed speed to avoid an interrupted first move.
@@ -2077,21 +2077,21 @@ void Planner::buffer_sync_block() {
   block->steps[C_AXIS] = position[C_AXIS];
   block->steps[E_AXIS] = position[E_AXIS];
 
   #if ENABLED(LIN_ADVANCE)
     block->use_advance_lead = false;
   #endif
 
   block->nominal_speed   =
   block->entry_speed     =
   block->max_entry_speed =
-  block->millimeters     =  
+  block->millimeters     =
   block->acceleration    = 0;
 
   block->step_event_count          =
   block->nominal_rate              =
   block->initial_rate              =
   block->final_rate                =
   block->acceleration_steps_per_s2 =
   block->segment_time_us           = 0;
 
   block_buffer_head = next_buffer_head;

commit 19f189b4e5e10bdbdb3b28d94fa180f74cdbd654
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 8 11:10:45 2018 -0500

    Add UBL support for G2/G3 and G5 (#10648)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 109e745526..abbf9e4723 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1183,21 +1183,21 @@ void Planner::check_axes_activity() {
                 ratio_2 = sq(nom_meas_ratio);
 
     volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = parser.volumetric_enabled
       ? ratio_2 / CIRCLE_AREA(filament_width_nominal * 0.5) // Volumetric uses a true volumetric multiplier
       : ratio_2;                                            // Linear squares the ratio, which scales the volume
 
     refresh_e_factor(FILAMENT_SENSOR_EXTRUDER_NUM);
   }
 #endif
 
-#if PLANNER_LEVELING
+#if PLANNER_LEVELING || HAS_UBL_AND_CURVES
   /**
    * rx, ry, rz - Cartesian positions in mm
    *              Leveled XYZ on completion
    */
   void Planner::apply_leveling(float &rx, float &ry, float &rz) {
 
     #if ENABLED(SKEW_CORRECTION)
       skew(rx, ry, rz);
     #endif
 
@@ -1235,20 +1235,24 @@ void Planner::check_axes_activity() {
         #elif ENABLED(AUTO_BED_LEVELING_UBL)
           fade_scaling_factor ? fade_scaling_factor * ubl.get_z_correction(rx, ry) : 0.0
         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
           fade_scaling_factor ? fade_scaling_factor * bilinear_z_offset(raw) : 0.0
         #endif
       );
 
     #endif
   }
 
+#endif
+
+#if PLANNER_LEVELING
+
   void Planner::unapply_leveling(float raw[XYZ]) {
 
     if (leveling_active) {
 
       #if ABL_PLANAR
 
         matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
 
         float dx = raw[X_AXIS] - (X_TILT_FULCRUM),
               dy = raw[Y_AXIS] - (Y_TILT_FULCRUM);

commit 4d4bf7897d1f99ce26062126d3ec9982642b7a3a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 8 03:13:43 2018 -0500

    Junction Deviation jerk limiting option

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7cbbbfaf75..109e745526 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -780,22 +780,22 @@ void Planner::calculate_trapezoid_for_block(block_t* const block, const float &e
   #if ENABLED(BEZIER_JERK_CONTROL)
     else // We have some plateau time, so the cruise rate will be the nominal rate
       cruise_rate = block->nominal_rate;
   #endif
 
   // block->accelerate_until = accelerate_steps;
   // block->decelerate_after = accelerate_steps+plateau_steps;
 
   #if ENABLED(BEZIER_JERK_CONTROL)
     // Jerk controlled speed requires to express speed versus time, NOT steps
-    uint32_t acceleration_time = ((float)(cruise_rate - initial_rate) / accel) * HAL_STEPPER_TIMER_RATE,
-             deceleration_time = ((float)(cruise_rate - final_rate) / accel) * HAL_STEPPER_TIMER_RATE;
+    uint32_t acceleration_time = ((float)(cruise_rate - initial_rate) / accel) * (HAL_STEPPER_TIMER_RATE),
+             deceleration_time = ((float)(cruise_rate - final_rate) / accel) * (HAL_STEPPER_TIMER_RATE);
 
     // And to offload calculations from the ISR, we also calculate the inverse of those times here
     uint32_t acceleration_time_inverse = get_period_inverse(acceleration_time);
     uint32_t deceleration_time_inverse = get_period_inverse(deceleration_time);
 
   #endif
 
   CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section
   if (!TEST(block->flag, BLOCK_BIT_BUSY)) { // Don't update variables if block is busy.
     block->accelerate_until = accelerate_steps;
@@ -1857,143 +1857,175 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
       block->advance_speed = (HAL_STEPPER_TIMER_RATE) / (extruder_advance_K * block->e_D_ratio * block->acceleration * axis_steps_per_mm[E_AXIS_N]);
       #if ENABLED(LA_DEBUG)
         if (extruder_advance_K * block->e_D_ratio * block->acceleration * 2 < block->nominal_speed * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif
     }
   #endif
 
-  // Initial limit on the segment entry velocity
-  float vmax_junction;
-
-  #if 0  // Use old jerk for now
+  float vmax_junction; // Initial limit on the segment entry velocity
+
+  #if ENABLED(JUNCTION_DEVIATION)
+
+    /**
+     * Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
+     * Let a circle be tangent to both previous and current path line segments, where the junction 
+     * deviation is defined as the distance from the junction to the closest edge of the circle, 
+     * colinear with the circle center. The circular segment joining the two paths represents the 
+     * path of centripetal acceleration. Solve for max velocity based on max acceleration about the
+     * radius of the circle, defined indirectly by junction deviation. This may be also viewed as 
+     * path width or max_jerk in the previous Grbl version. This approach does not actually deviate 
+     * from path, but used as a robust way to compute cornering speeds, as it takes into account the
+     * nonlinearities of both the junction angle and junction velocity.
+     *
+     * NOTE: If the junction deviation value is finite, Grbl executes the motions in an exact path 
+     * mode (G61). If the junction deviation value is zero, Grbl will execute the motion in an exact
+     * stop mode (G61.1) manner. In the future, if continuous mode (G64) is desired, the math here
+     * is exactly the same. Instead of motioning all the way to junction point, the machine will
+     * just follow the arc circle defined here. The Arduino doesn't have the CPU cycles to perform
+     * a continuous mode path, but ARM-based microcontrollers most certainly do. 
+     * 
+     * NOTE: The max junction speed is a fixed value, since machine acceleration limits cannot be
+     * changed dynamically during operation nor can the line move geometry. This must be kept in
+     * memory in the event of a feedrate override changing the nominal speeds of blocks, which can 
+     * change the overall maximum entry speed conditions of all blocks.
+     */
 
-    float junction_deviation = 0.1;
+    // Unit vector of previous path line segment
+    static float previous_unit_vec[
+      #if ENABLED(JUNCTION_DEVIATION_INCLUDE_E)
+        XYZE
+      #else
+        XYZ
+      #endif
+    ];
 
-    // Compute path unit vector
-    double unit_vec[XYZ] = {
+    float unit_vec[] = {
       delta_mm[A_AXIS] * inverse_millimeters,
       delta_mm[B_AXIS] * inverse_millimeters,
       delta_mm[C_AXIS] * inverse_millimeters
+      #if ENABLED(JUNCTION_DEVIATION_INCLUDE_E)
+        , delta_mm[E_AXIS] * inverse_millimeters
+      #endif
     };
 
-    /*
-       Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
-
-       Let a circle be tangent to both previous and current path line segments, where the junction
-       deviation is defined as the distance from the junction to the closest edge of the circle,
-       collinear with the circle center.
-
-       The circular segment joining the two paths represents the path of centripetal acceleration.
-       Solve for max velocity based on max acceleration about the radius of the circle, defined
-       indirectly by junction deviation.
-
-       This may be also viewed as path width or max_jerk in the previous grbl version. This approach
-       does not actually deviate from path, but used as a robust way to compute cornering speeds, as
-       it takes into account the nonlinearities of both the junction angle and junction velocity.
-     */
-
-    vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed
-
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
     if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
-      const float cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
-                              - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
-                              - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS];
-      // Skip and use default max junction speed for 0 degree acute junction.
-      if (cos_theta < 0.95) {
-        vmax_junction = min(previous_nominal_speed, block->nominal_speed);
-        // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.
-        if (cos_theta > -0.95) {
-          // Compute maximum junction velocity based on maximum acceleration and junction deviation
-          float sin_theta_d2 = SQRT(0.5 * (1.0 - cos_theta)); // Trig half angle identity. Always positive.
-          NOMORE(vmax_junction, SQRT(block->acceleration * junction_deviation * sin_theta_d2 / (1.0 - sin_theta_d2)));
-        }
+      float junction_cos_theta = -previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
+                                 -previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
+                                 -previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS]
+                                  #if ENABLED(JUNCTION_DEVIATION_INCLUDE_E)
+                                    -previous_unit_vec[E_AXIS] * unit_vec[E_AXIS]
+                                  #endif
+                                ;
+
+      // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
+      if (junction_cos_theta > 0.999999) {
+        // For a 0 degree acute junction, just set minimum junction speed.
+        vmax_junction = MINIMUM_PLANNER_SPEED;
+      }
+      else {
+        junction_cos_theta = max(junction_cos_theta, -0.999999); // Check for numerical round-off to avoid divide by zero.
+        const float sin_theta_d2 = SQRT(0.5 * (1.0 - junction_cos_theta)); // Trig half angle identity. Always positive.
+
+        // TODO: Technically, the acceleration used in calculation needs to be limited by the minimum of the
+        // two junctions. However, this shouldn't be a significant problem except in extreme circumstances.
+        vmax_junction = SQRT((block->acceleration * JUNCTION_DEVIATION_FACTOR * sin_theta_d2) / (1.0 - sin_theta_d2));
       }
+
+      vmax_junction = MIN3(vmax_junction, block->nominal_speed, previous_nominal_speed);
     }
-  #endif
+    else // Init entry speed to zero. Assume it starts from rest. Planner will correct this later.
+      vmax_junction = 0.0;
 
-  /**
-   * Adapted from Pr≈Ø≈°a MKS firmware
-   * https://github.com/prusa3d/Prusa-Firmware
-   *
-   * Start with a safe speed (from which the machine may halt to stop immediately).
-   */
+    COPY(previous_unit_vec, unit_vec);
 
-  // Exit speed limited by a jerk to full halt of a previous last segment
-  static float previous_safe_speed;
+  #else // Classic Jerk Limiting
 
-  float safe_speed = block->nominal_speed;
-  uint8_t limited = 0;
-  LOOP_XYZE(i) {
-    const float jerk = FABS(current_speed[i]), maxj = max_jerk[i];
-    if (jerk > maxj) {
-      if (limited) {
-        const float mjerk = maxj * block->nominal_speed;
-        if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk;
-      }
-      else {
-        ++limited;
-        safe_speed = maxj;
+    /**
+     * Adapted from Pr≈Ø≈°a MKS firmware
+     * https://github.com/prusa3d/Prusa-Firmware
+     *
+     * Start with a safe speed (from which the machine may halt to stop immediately).
+     */
+
+    // Exit speed limited by a jerk to full halt of a previous last segment
+    static float previous_safe_speed;
+
+    float safe_speed = block->nominal_speed;
+    uint8_t limited = 0;
+    LOOP_XYZE(i) {
+      const float jerk = FABS(current_speed[i]), maxj = max_jerk[i];
+      if (jerk > maxj) {
+        if (limited) {
+          const float mjerk = maxj * block->nominal_speed;
+          if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk;
+        }
+        else {
+          ++limited;
+          safe_speed = maxj;
+        }
       }
     }
-  }
 
-  if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
-    // Estimate a maximum velocity allowed at a joint of two successive segments.
-    // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
-    // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
-
-    // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
-    // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
-    vmax_junction = min(block->nominal_speed, previous_nominal_speed);
-
-    // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
-    float v_factor = 1;
-    limited = 0;
-
-    // Now limit the jerk in all axes.
-    const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
-    LOOP_XYZE(axis) {
-      // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
-      float v_exit = previous_speed[axis] * smaller_speed_factor,
-            v_entry = current_speed[axis];
-      if (limited) {
-        v_exit *= v_factor;
-        v_entry *= v_factor;
-      }
+    if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
+      // Estimate a maximum velocity allowed at a joint of two successive segments.
+      // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
+      // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
+
+      // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
+      // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
+      vmax_junction = min(block->nominal_speed, previous_nominal_speed);
+
+      // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
+      float v_factor = 1;
+      limited = 0;
+
+      // Now limit the jerk in all axes.
+      const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
+      LOOP_XYZE(axis) {
+        // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
+        float v_exit = previous_speed[axis] * smaller_speed_factor,
+              v_entry = current_speed[axis];
+        if (limited) {
+          v_exit *= v_factor;
+          v_entry *= v_factor;
+        }
 
-      // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
-      const float jerk = (v_exit > v_entry)
-          ? //                                  coasting             axis reversal
-            ( (v_entry > 0 || v_exit < 0) ? (v_exit - v_entry) : max(v_exit, -v_entry) )
-          : // v_exit <= v_entry                coasting             axis reversal
-            ( (v_entry < 0 || v_exit > 0) ? (v_entry - v_exit) : max(-v_exit, v_entry) );
+        // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
+        const float jerk = (v_exit > v_entry)
+            ? //                                  coasting             axis reversal
+              ( (v_entry > 0 || v_exit < 0) ? (v_exit - v_entry) : max(v_exit, -v_entry) )
+            : // v_exit <= v_entry                coasting             axis reversal
+              ( (v_entry < 0 || v_exit > 0) ? (v_entry - v_exit) : max(-v_exit, v_entry) );
 
-      if (jerk > max_jerk[axis]) {
-        v_factor *= max_jerk[axis] / jerk;
-        ++limited;
+        if (jerk > max_jerk[axis]) {
+          v_factor *= max_jerk[axis] / jerk;
+          ++limited;
+        }
       }
+      if (limited) vmax_junction *= v_factor;
+      // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
+      // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
+      const float vmax_junction_threshold = vmax_junction * 0.99f;
+      if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold)
+        vmax_junction = safe_speed;
     }
-    if (limited) vmax_junction *= v_factor;
-    // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
-    // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
-    const float vmax_junction_threshold = vmax_junction * 0.99f;
-    if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold)
+    else
       vmax_junction = safe_speed;
-  }
-  else
-    vmax_junction = safe_speed;
+  
+    previous_safe_speed = safe_speed;
+  #endif // Classic Jerk Limiting
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed = vmax_junction;
 
   // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
   const float v_allowable = max_allowable_speed(-block->acceleration, MINIMUM_PLANNER_SPEED, block->millimeters);
   // If stepper ISR is disabled, this indicates buffer_segment wants to add a split block.
   // In this case start with the max. allowed speed to avoid an interrupted first move.
   block->entry_speed = STEPPER_ISR_ENABLED() ? MINIMUM_PLANNER_SPEED : min(vmax_junction, v_allowable);
 
@@ -2003,21 +2035,20 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
   // the current block and next block junction speeds are guaranteed to always be at their maximum
   // junction speeds in deceleration and acceleration, respectively. This is due to how the current
   // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
   block->flag |= block->nominal_speed <= v_allowable ? BLOCK_FLAG_RECALCULATE | BLOCK_FLAG_NOMINAL_LENGTH : BLOCK_FLAG_RECALCULATE;
 
   // Update previous path unit_vector and nominal speed
   COPY(previous_speed, current_speed);
   previous_nominal_speed = block->nominal_speed;
-  previous_safe_speed = safe_speed;
 
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
   // Update the position (only when a move was queued)
   static_assert(COUNT(target) > 1, "Parameter to _buffer_steps must be (&target)[XYZE]!");
   COPY(position, target);
   #if HAS_POSITION_FLOAT
     COPY(position_float, target_float);
   #endif

commit 0436e16fb22ce411311bce5994a315a991ec3219
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 8 05:10:27 2018 -0500

    Apply shorthand Assembler macros

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7a68cc6283..7cbbbfaf75 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -402,310 +402,310 @@ void Planner::init() {
       register uint8_t r8 = d & 0xFF;
       register uint8_t r9 = (d >> 8) & 0xFF;
       register uint8_t r10 = (d >> 16) & 0xFF;
       register uint8_t r2,r3,r4,r5,r6,r7,r11,r12,r13,r14,r15,r16,r17,r18;
       register const uint8_t* ptab = inv_tab;
 
       __asm__ __volatile__(
         // %8:%7:%6 = interval
         // r31:r30: MUST be those registers, and they must point to the inv_tab
 
-        " clr %13" "\n\t"                 // %13 = 0
+        A("clr %13")                       // %13 = 0
 
         // Now we must compute
         // result = 0xFFFFFF / d
         // %8:%7:%6 = interval
         // %16:%15:%14 = nr
         // %13 = 0
 
         // A plain division of 24x24 bits should take 388 cycles to complete. We will
         // use Newton-Raphson for the calculation, and will strive to get way less cycles
         // for the same result - Using C division, it takes 500cycles to complete .
 
-        " clr %3" "\n\t"                  // idx = 0
-        " mov %14,%6" "\n\t"
-        " mov %15,%7" "\n\t"
-        " mov %16,%8" "\n\t"              // nr = interval
-        " tst %16" "\n\t"                 // nr & 0xFF0000 == 0 ?
-        " brne 2f" "\n\t"                 // No, skip this
-        " mov %16,%15" "\n\t"
-        " mov %15,%14" "\n\t"             // nr <<= 8, %14 not needed
-        " subi %3,-8" "\n\t"              // idx += 8
-        " tst %16" "\n\t"                 // nr & 0xFF0000 == 0 ?
-        " brne 2f" "\n\t"                 // No, skip this
-        " mov %16,%15" "\n\t"             // nr <<= 8, %14 not needed
-        " clr %15" "\n\t"                 // We clear %14
-        " subi %3,-8" "\n\t"              // idx += 8
+        A("clr %3")                        // idx = 0
+        A("mov %14,%6")      
+        A("mov %15,%7")      
+        A("mov %16,%8")                    // nr = interval
+        A("tst %16")                       // nr & 0xFF0000 == 0 ?
+        A("brne 2f")                       // No, skip this
+        A("mov %16,%15")      
+        A("mov %15,%14")                   // nr <<= 8, %14 not needed
+        A("subi %3,-8")                    // idx += 8
+        A("tst %16")                       // nr & 0xFF0000 == 0 ?
+        A("brne 2f")                       // No, skip this
+        A("mov %16,%15")                   // nr <<= 8, %14 not needed
+        A("clr %15")                       // We clear %14
+        A("subi %3,-8")                    // idx += 8
 
         // here %16 != 0 and %16:%15 contains at least 9 MSBits, or both %16:%15 are 0
-        "2:" "\n\t"
-        " cpi %16,0x10" "\n\t"            // (nr & 0xf00000) == 0 ?
-        " brcc 3f" "\n\t"                 // No, skip this
-        " swap %15" "\n\t"                // Swap nibbles
-        " swap %16" "\n\t"                // Swap nibbles. Low nibble is 0
-        " mov %14, %15" "\n\t"
-        " andi %14,0x0f" "\n\t"           // Isolate low nibble
-        " andi %15,0xf0" "\n\t"           // Keep proper nibble in %15
-        " or %16, %14" "\n\t"             // %16:%15 <<= 4
-        " subi %3,-4" "\n\t"              // idx += 4
-
-        "3:" "\n\t"
-        " cpi %16,0x40" "\n\t"            // (nr & 0xc00000) == 0 ?
-        " brcc 4f" "\n\t"                 // No, skip this
-        " add %15,%15" "\n\t"
-        " adc %16,%16" "\n\t"
-        " add %15,%15" "\n\t"
-        " adc %16,%16" "\n\t"             // %16:%15 <<= 2
-        " subi %3,-2" "\n\t"              // idx += 2
-
-        "4:" "\n\t"
-        " cpi %16,0x80" "\n\t"            // (nr & 0x800000) == 0 ?
-        " brcc 5f" "\n\t"                 // No, skip this
-        " add %15,%15" "\n\t"
-        " adc %16,%16" "\n\t"             // %16:%15 <<= 1
-        " inc %3" "\n\t"                  // idx += 1
+        L("2")
+        A("cpi %16,0x10")                  // (nr & 0xF00000) == 0 ?
+        A("brcc 3f")                       // No, skip this
+        A("swap %15")                      // Swap nibbles
+        A("swap %16")                      // Swap nibbles. Low nibble is 0
+        A("mov %14, %15")      
+        A("andi %14,0x0F")                 // Isolate low nibble
+        A("andi %15,0xF0")                 // Keep proper nibble in %15
+        A("or %16, %14")                   // %16:%15 <<= 4
+        A("subi %3,-4")                    // idx += 4
+
+        L("3")
+        A("cpi %16,0x40")                  // (nr & 0xC00000) == 0 ?
+        A("brcc 4f")                       // No, skip this
+        A("add %15,%15")      
+        A("adc %16,%16")      
+        A("add %15,%15")      
+        A("adc %16,%16")                   // %16:%15 <<= 2
+        A("subi %3,-2")                    // idx += 2
+
+        L("4")
+        A("cpi %16,0x80")                  // (nr & 0x800000) == 0 ?
+        A("brcc 5f")                       // No, skip this
+        A("add %15,%15")      
+        A("adc %16,%16")                   // %16:%15 <<= 1
+        A("inc %3")                        // idx += 1
 
         // Now %16:%15 contains its MSBit set to 1, or %16:%15 is == 0. We are now absolutely sure
         // we have at least 9 MSBits available to enter the initial estimation table
-        "5:" "\n\t"
-        " add %15,%15" "\n\t"
-        " adc %16,%16" "\n\t"             // %16:%15 = tidx = (nr <<= 1), we lose the top MSBit (always set to 1, %16 is the index into the inverse table)
-        " add r30,%16" "\n\t"             // Only use top 8 bits
-        " adc r31,%13" "\n\t"             // r31:r30 = inv_tab + (tidx)
-        " lpm %14, Z" "\n\t"              // %14 = inv_tab[tidx]
-        " ldi %15, 1" "\n\t"              // %15 = 1  %15:%14 = inv_tab[tidx] + 256
+        L("5")
+        A("add %15,%15")      
+        A("adc %16,%16")                   // %16:%15 = tidx = (nr <<= 1), we lose the top MSBit (always set to 1, %16 is the index into the inverse table)
+        A("add r30,%16")                   // Only use top 8 bits
+        A("adc r31,%13")                   // r31:r30 = inv_tab + (tidx)
+        A("lpm %14, Z")                    // %14 = inv_tab[tidx]
+        A("ldi %15, 1")                    // %15 = 1  %15:%14 = inv_tab[tidx] + 256
 
         // We must scale the approximation to the proper place
-        " clr %16" "\n\t"                 // %16 will always be 0 here
-        " subi %3,8" "\n\t"               // idx == 8 ?
-        " breq 6f" "\n\t"                 // yes, no need to scale
-        " brcs 7f" "\n\t"                 // If C=1, means idx < 8, result was negative!
+        A("clr %16")                       // %16 will always be 0 here
+        A("subi %3,8")                     // idx == 8 ?
+        A("breq 6f")                       // yes, no need to scale
+        A("brcs 7f")                       // If C=1, means idx < 8, result was negative!
 
         // idx > 8, now %3 = idx - 8. We must perform a left shift. idx range:[1-8]
-        " sbrs %3,0" "\n\t"               // shift by 1bit position?
-        " rjmp 8f" "\n\t"                 // No
-        " add %14,%14" "\n\t"
-        " adc %15,%15" "\n\t"             // %15:16 <<= 1
-        "8:" "\n\t"
-        " sbrs %3,1" "\n\t"               // shift by 2bit position?
-        " rjmp 9f" "\n\t"                 // No
-        " add %14,%14" "\n\t"
-        " adc %15,%15" "\n\t"
-        " add %14,%14" "\n\t"
-        " adc %15,%15" "\n\t"             // %15:16 <<= 1
-        "9:" "\n\t"
-        " sbrs %3,2" "\n\t"               // shift by 4bits position?
-        " rjmp 16f" "\n\t"                // No
-        " swap %15" "\n\t"                // Swap nibbles. lo nibble of %15 will always be 0
-        " swap %14" "\n\t"                // Swap nibbles
-        " mov %12,%14" "\n\t"
-        " andi %12,0x0f" "\n\t"           // isolate low nibble
-        " andi %14,0xf0" "\n\t"           // and clear it
-        " or %15,%12" "\n\t"              // %15:%16 <<= 4
-        "16:" "\n\t"
-        " sbrs %3,3" "\n\t"               // shift by 8bits position?
-        " rjmp 6f" "\n\t"                 // No, we are done
-        " mov %16,%15" "\n\t"
-        " mov %15,%14" "\n\t"
-        " clr %14" "\n\t"
-        " jmp 6f" "\n\t"
+        A("sbrs %3,0")                     // shift by 1bit position?
+        A("rjmp 8f")                       // No
+        A("add %14,%14")      
+        A("adc %15,%15")                   // %15:16 <<= 1
+        L("8")
+        A("sbrs %3,1")                     // shift by 2bit position?
+        A("rjmp 9f")                       // No
+        A("add %14,%14")      
+        A("adc %15,%15")      
+        A("add %14,%14")      
+        A("adc %15,%15")                   // %15:16 <<= 1
+        L("9")
+        A("sbrs %3,2")                     // shift by 4bits position?
+        A("rjmp 16f")                      // No
+        A("swap %15")                      // Swap nibbles. lo nibble of %15 will always be 0
+        A("swap %14")                      // Swap nibbles
+        A("mov %12,%14")      
+        A("andi %12,0x0F")                 // isolate low nibble
+        A("andi %14,0xF0")                 // and clear it
+        A("or %15,%12")                    // %15:%16 <<= 4
+        L("16")
+        A("sbrs %3,3")                     // shift by 8bits position?
+        A("rjmp 6f")                       // No, we are done
+        A("mov %16,%15")      
+        A("mov %15,%14")      
+        A("clr %14")      
+        A("jmp 6f")      
 
         // idx < 8, now %3 = idx - 8. Get the count of bits
-        "7:" "\n\t"
-        " neg %3" "\n\t"                  // %3 = -idx = count of bits to move right. idx range:[1...8]
-        " sbrs %3,0" "\n\t"               // shift by 1 bit position ?
-        " rjmp 10f" "\n\t"                // No, skip it
-        " asr %15" "\n\t"                 // (bit7 is always 0 here)
-        " ror %14" "\n\t"
-        "10:" "\n\t"
-        " sbrs %3,1" "\n\t"               // shift by 2 bit position ?
-        " rjmp 11f" "\n\t"                // No, skip it
-        " asr %15" "\n\t"                 // (bit7 is always 0 here)
-        " ror %14" "\n\t"
-        " asr %15" "\n\t"                 // (bit7 is always 0 here)
-        " ror %14" "\n\t"
-        "11:" "\n\t"
-        " sbrs %3,2" "\n\t"               // shift by 4 bit position ?
-        " rjmp 12f" "\n\t"                // No, skip it
-        " swap %15" "\n\t"                // Swap nibbles
-        " andi %14, 0xf0" "\n\t"          // Lose the lowest nibble
-        " swap %14" "\n\t"                // Swap nibbles. Upper nibble is 0
-        " or %14,%15" "\n\t"              // Pass nibble from upper byte
-        " andi %15, 0x0f" "\n\t"          // And get rid of that nibble
-        "12:" "\n\t"
-        " sbrs %3,3" "\n\t"               // shift by 8 bit position ?
-        " rjmp 6f" "\n\t"                 // No, skip it
-        " mov %14,%15" "\n\t"
-        " clr %15" "\n\t"
-        "6:" "\n\t"                       // %16:%15:%14 = initial estimation of 0x1000000 / d
+        L("7")
+        A("neg %3")                        // %3 = -idx = count of bits to move right. idx range:[1...8]
+        A("sbrs %3,0")                     // shift by 1 bit position ?
+        A("rjmp 10f")                      // No, skip it
+        A("asr %15")                       // (bit7 is always 0 here)
+        A("ror %14")      
+        L("10")
+        A("sbrs %3,1")                     // shift by 2 bit position ?
+        A("rjmp 11f")                      // No, skip it
+        A("asr %15")                       // (bit7 is always 0 here)
+        A("ror %14")      
+        A("asr %15")                       // (bit7 is always 0 here)
+        A("ror %14")      
+        L("11")
+        A("sbrs %3,2")                     // shift by 4 bit position ?
+        A("rjmp 12f")                      // No, skip it
+        A("swap %15")                      // Swap nibbles
+        A("andi %14, 0xF0")                // Lose the lowest nibble
+        A("swap %14")                      // Swap nibbles. Upper nibble is 0
+        A("or %14,%15")                    // Pass nibble from upper byte
+        A("andi %15, 0x0F")                // And get rid of that nibble
+        L("12")
+        A("sbrs %3,3")                     // shift by 8 bit position ?
+        A("rjmp 6f")                       // No, skip it
+        A("mov %14,%15")      
+        A("clr %15")      
+        L("6")                       // %16:%15:%14 = initial estimation of 0x1000000 / d
 
         // Now, we must refine the estimation present on %16:%15:%14 using 1 iteration
         // of Newton-Raphson. As it has a quadratic convergence, 1 iteration is enough
         // to get more than 18bits of precision (the initial table lookup gives 9 bits of
         // precision to start from). 18bits of precision is all what is needed here for result
 
         // %8:%7:%6 = d = interval
         // %16:%15:%14 = x = initial estimation of 0x1000000 / d
         // %13 = 0
         // %3:%2:%1:%0 = working accumulator
 
         // Compute 1<<25 - x*d. Result should never exceed 25 bits and should always be positive
-        " clr %0" "\n\t"
-        " clr %1" "\n\t"
-        " clr %2" "\n\t"
-        " ldi %3,2" "\n\t"                // %3:%2:%1:%0 = 0x2000000
-        " mul %6,%14" "\n\t"              // r1:r0 = LO(d) * LO(x)
-        " sub %0,r0" "\n\t"
-        " sbc %1,r1" "\n\t"
-        " sbc %2,%13" "\n\t"
-        " sbc %3,%13" "\n\t"              // %3:%2:%1:%0 -= LO(d) * LO(x)
-        " mul %7,%14" "\n\t"              // r1:r0 = MI(d) * LO(x)
-        " sub %1,r0" "\n\t"
-        " sbc %2,r1"  "\n\t"
-        " sbc %3,%13" "\n\t"              // %3:%2:%1:%0 -= MI(d) * LO(x) << 8
-        " mul %8,%14" "\n\t"              // r1:r0 = HI(d) * LO(x)
-        " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"               // %3:%2:%1:%0 -= MIL(d) * LO(x) << 16
-        " mul %6,%15" "\n\t"              // r1:r0 = LO(d) * MI(x)
-        " sub %1,r0" "\n\t"
-        " sbc %2,r1" "\n\t"
-        " sbc %3,%13" "\n\t"              // %3:%2:%1:%0 -= LO(d) * MI(x) << 8
-        " mul %7,%15" "\n\t"              // r1:r0 = MI(d) * MI(x)
-        " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"               // %3:%2:%1:%0 -= MI(d) * MI(x) << 16
-        " mul %8,%15" "\n\t"              // r1:r0 = HI(d) * MI(x)
-        " sub %3,r0" "\n\t"               // %3:%2:%1:%0 -= MIL(d) * MI(x) << 24
-        " mul %6,%16" "\n\t"              // r1:r0 = LO(d) * HI(x)
-        " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"               // %3:%2:%1:%0 -= LO(d) * HI(x) << 16
-        " mul %7,%16" "\n\t"              // r1:r0 = MI(d) * HI(x)
-        " sub %3,r0" "\n\t"               // %3:%2:%1:%0 -= MI(d) * HI(x) << 24
+        A("clr %0")      
+        A("clr %1")      
+        A("clr %2")      
+        A("ldi %3,2")                      // %3:%2:%1:%0 = 0x2000000
+        A("mul %6,%14")                    // r1:r0 = LO(d) * LO(x)
+        A("sub %0,r0")      
+        A("sbc %1,r1")      
+        A("sbc %2,%13")      
+        A("sbc %3,%13")                    // %3:%2:%1:%0 -= LO(d) * LO(x)
+        A("mul %7,%14")                    // r1:r0 = MI(d) * LO(x)
+        A("sub %1,r0")      
+        A("sbc %2,r1" )      
+        A("sbc %3,%13")                    // %3:%2:%1:%0 -= MI(d) * LO(x) << 8
+        A("mul %8,%14")                    // r1:r0 = HI(d) * LO(x)
+        A("sub %2,r0")      
+        A("sbc %3,r1")                     // %3:%2:%1:%0 -= MIL(d) * LO(x) << 16
+        A("mul %6,%15")                    // r1:r0 = LO(d) * MI(x)
+        A("sub %1,r0")      
+        A("sbc %2,r1")      
+        A("sbc %3,%13")                    // %3:%2:%1:%0 -= LO(d) * MI(x) << 8
+        A("mul %7,%15")                    // r1:r0 = MI(d) * MI(x)
+        A("sub %2,r0")      
+        A("sbc %3,r1")                     // %3:%2:%1:%0 -= MI(d) * MI(x) << 16
+        A("mul %8,%15")                    // r1:r0 = HI(d) * MI(x)
+        A("sub %3,r0")                     // %3:%2:%1:%0 -= MIL(d) * MI(x) << 24
+        A("mul %6,%16")                    // r1:r0 = LO(d) * HI(x)
+        A("sub %2,r0")      
+        A("sbc %3,r1")                     // %3:%2:%1:%0 -= LO(d) * HI(x) << 16
+        A("mul %7,%16")                    // r1:r0 = MI(d) * HI(x)
+        A("sub %3,r0")                     // %3:%2:%1:%0 -= MI(d) * HI(x) << 24
         // %3:%2:%1:%0 = (1<<25) - x*d     [169]
 
         // We need to multiply that result by x, and we are only interested in the top 24bits of that multiply
 
         // %16:%15:%14 = x = initial estimation of 0x1000000 / d
         // %3:%2:%1:%0 = (1<<25) - x*d = acc
         // %13 = 0
 
         // result = %11:%10:%9:%5:%4
-        " mul %14,%0" "\n\t"              // r1:r0 = LO(x) * LO(acc)
-        " mov %4,r1" "\n\t"
-        " clr %5" "\n\t"
-        " clr %9" "\n\t"
-        " clr %10" "\n\t"
-        " clr %11" "\n\t"                 // %11:%10:%9:%5:%4 = LO(x) * LO(acc) >> 8
-        " mul %15,%0" "\n\t"              // r1:r0 = MI(x) * LO(acc)
-        " add %4,r0" "\n\t"
-        " adc %5,r1" "\n\t"
-        " adc %9,%13" "\n\t"
-        " adc %10,%13" "\n\t"
-        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 += MI(x) * LO(acc)
-        " mul %16,%0" "\n\t"              // r1:r0 = HI(x) * LO(acc)
-        " add %5,r0" "\n\t"
-        " adc %9,r1" "\n\t"
-        " adc %10,%13" "\n\t"
-        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 += MI(x) * LO(acc) << 8
-
-        " mul %14,%1" "\n\t"              // r1:r0 = LO(x) * MIL(acc)
-        " add %4,r0" "\n\t"
-        " adc %5,r1" "\n\t"
-        " adc %9,%13" "\n\t"
-        " adc %10,%13" "\n\t"
-        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 = LO(x) * MIL(acc)
-        " mul %15,%1" "\n\t"              // r1:r0 = MI(x) * MIL(acc)
-        " add %5,r0" "\n\t"
-        " adc %9,r1" "\n\t"
-        " adc %10,%13" "\n\t"
-        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 += MI(x) * MIL(acc) << 8
-        " mul %16,%1" "\n\t"              // r1:r0 = HI(x) * MIL(acc)
-        " add %9,r0" "\n\t"
-        " adc %10,r1" "\n\t"
-        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 += MI(x) * MIL(acc) << 16
-
-        " mul %14,%2" "\n\t"              // r1:r0 = LO(x) * MIH(acc)
-        " add %5,r0" "\n\t"
-        " adc %9,r1" "\n\t"
-        " adc %10,%13" "\n\t"
-        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 = LO(x) * MIH(acc) << 8
-        " mul %15,%2" "\n\t"              // r1:r0 = MI(x) * MIH(acc)
-        " add %9,r0" "\n\t"
-        " adc %10,r1" "\n\t"
-        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 += MI(x) * MIH(acc) << 16
-        " mul %16,%2" "\n\t"              // r1:r0 = HI(x) * MIH(acc)
-        " add %10,r0" "\n\t"
-        " adc %11,r1" "\n\t"              // %11:%10:%9:%5:%4 += MI(x) * MIH(acc) << 24
-
-        " mul %14,%3" "\n\t"              // r1:r0 = LO(x) * HI(acc)
-        " add %9,r0" "\n\t"
-        " adc %10,r1" "\n\t"
-        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 = LO(x) * HI(acc) << 16
-        " mul %15,%3" "\n\t"              // r1:r0 = MI(x) * HI(acc)
-        " add %10,r0" "\n\t"
-        " adc %11,r1" "\n\t"              // %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 24
-        " mul %16,%3" "\n\t"              // r1:r0 = HI(x) * HI(acc)
-        " add %11,r0" "\n\t"              // %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 32
+        A("mul %14,%0")                    // r1:r0 = LO(x) * LO(acc)
+        A("mov %4,r1")      
+        A("clr %5")      
+        A("clr %9")      
+        A("clr %10")      
+        A("clr %11")                       // %11:%10:%9:%5:%4 = LO(x) * LO(acc) >> 8
+        A("mul %15,%0")                    // r1:r0 = MI(x) * LO(acc)
+        A("add %4,r0")      
+        A("adc %5,r1")      
+        A("adc %9,%13")      
+        A("adc %10,%13")      
+        A("adc %11,%13")                   // %11:%10:%9:%5:%4 += MI(x) * LO(acc)
+        A("mul %16,%0")                    // r1:r0 = HI(x) * LO(acc)
+        A("add %5,r0")      
+        A("adc %9,r1")      
+        A("adc %10,%13")      
+        A("adc %11,%13")                   // %11:%10:%9:%5:%4 += MI(x) * LO(acc) << 8
+
+        A("mul %14,%1")                    // r1:r0 = LO(x) * MIL(acc)
+        A("add %4,r0")      
+        A("adc %5,r1")      
+        A("adc %9,%13")      
+        A("adc %10,%13")      
+        A("adc %11,%13")                   // %11:%10:%9:%5:%4 = LO(x) * MIL(acc)
+        A("mul %15,%1")                    // r1:r0 = MI(x) * MIL(acc)
+        A("add %5,r0")      
+        A("adc %9,r1")      
+        A("adc %10,%13")      
+        A("adc %11,%13")                   // %11:%10:%9:%5:%4 += MI(x) * MIL(acc) << 8
+        A("mul %16,%1")                    // r1:r0 = HI(x) * MIL(acc)
+        A("add %9,r0")      
+        A("adc %10,r1")      
+        A("adc %11,%13")                   // %11:%10:%9:%5:%4 += MI(x) * MIL(acc) << 16
+
+        A("mul %14,%2")                    // r1:r0 = LO(x) * MIH(acc)
+        A("add %5,r0")      
+        A("adc %9,r1")      
+        A("adc %10,%13")      
+        A("adc %11,%13")                   // %11:%10:%9:%5:%4 = LO(x) * MIH(acc) << 8
+        A("mul %15,%2")                    // r1:r0 = MI(x) * MIH(acc)
+        A("add %9,r0")      
+        A("adc %10,r1")      
+        A("adc %11,%13")                   // %11:%10:%9:%5:%4 += MI(x) * MIH(acc) << 16
+        A("mul %16,%2")                    // r1:r0 = HI(x) * MIH(acc)
+        A("add %10,r0")      
+        A("adc %11,r1")                    // %11:%10:%9:%5:%4 += MI(x) * MIH(acc) << 24
+
+        A("mul %14,%3")                    // r1:r0 = LO(x) * HI(acc)
+        A("add %9,r0")      
+        A("adc %10,r1")      
+        A("adc %11,%13")                   // %11:%10:%9:%5:%4 = LO(x) * HI(acc) << 16
+        A("mul %15,%3")                    // r1:r0 = MI(x) * HI(acc)
+        A("add %10,r0")      
+        A("adc %11,r1")                    // %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 24
+        A("mul %16,%3")                    // r1:r0 = HI(x) * HI(acc)
+        A("add %11,r0")                    // %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 32
 
         // At this point, %11:%10:%9 contains the new estimation of x.
 
         // Finally, we must correct the result. Estimate remainder as
         // (1<<24) - x*d
         // %11:%10:%9 = x
         // %8:%7:%6 = d = interval" "\n\t"
-        " ldi %3,1" "\n\t"
-        " clr %2" "\n\t"
-        " clr %1" "\n\t"
-        " clr %0" "\n\t"                  // %3:%2:%1:%0 = 0x1000000
-        " mul %6,%9" "\n\t"               // r1:r0 = LO(d) * LO(x)
-        " sub %0,r0" "\n\t"
-        " sbc %1,r1" "\n\t"
-        " sbc %2,%13" "\n\t"
-        " sbc %3,%13" "\n\t"              // %3:%2:%1:%0 -= LO(d) * LO(x)
-        " mul %7,%9" "\n\t"               // r1:r0 = MI(d) * LO(x)
-        " sub %1,r0" "\n\t"
-        " sbc %2,r1" "\n\t"
-        " sbc %3,%13" "\n\t"              // %3:%2:%1:%0 -= MI(d) * LO(x) << 8
-        " mul %8,%9" "\n\t"               // r1:r0 = HI(d) * LO(x)
-        " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"               // %3:%2:%1:%0 -= MIL(d) * LO(x) << 16
-        " mul %6,%10" "\n\t"              // r1:r0 = LO(d) * MI(x)
-        " sub %1,r0" "\n\t"
-        " sbc %2,r1" "\n\t"
-        " sbc %3,%13" "\n\t"              // %3:%2:%1:%0 -= LO(d) * MI(x) << 8
-        " mul %7,%10" "\n\t"              // r1:r0 = MI(d) * MI(x)
-        " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"               // %3:%2:%1:%0 -= MI(d) * MI(x) << 16
-        " mul %8,%10" "\n\t"              // r1:r0 = HI(d) * MI(x)
-        " sub %3,r0" "\n\t"               // %3:%2:%1:%0 -= MIL(d) * MI(x) << 24
-        " mul %6,%11" "\n\t"              // r1:r0 = LO(d) * HI(x)
-        " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"               // %3:%2:%1:%0 -= LO(d) * HI(x) << 16
-        " mul %7,%11" "\n\t"              // r1:r0 = MI(d) * HI(x)
-        " sub %3,r0" "\n\t"               // %3:%2:%1:%0 -= MI(d) * HI(x) << 24
+        A("ldi %3,1")      
+        A("clr %2")      
+        A("clr %1")      
+        A("clr %0")                        // %3:%2:%1:%0 = 0x1000000
+        A("mul %6,%9")                     // r1:r0 = LO(d) * LO(x)
+        A("sub %0,r0")      
+        A("sbc %1,r1")      
+        A("sbc %2,%13")      
+        A("sbc %3,%13")                    // %3:%2:%1:%0 -= LO(d) * LO(x)
+        A("mul %7,%9")                     // r1:r0 = MI(d) * LO(x)
+        A("sub %1,r0")      
+        A("sbc %2,r1")      
+        A("sbc %3,%13")                    // %3:%2:%1:%0 -= MI(d) * LO(x) << 8
+        A("mul %8,%9")                     // r1:r0 = HI(d) * LO(x)
+        A("sub %2,r0")      
+        A("sbc %3,r1")                     // %3:%2:%1:%0 -= MIL(d) * LO(x) << 16
+        A("mul %6,%10")                    // r1:r0 = LO(d) * MI(x)
+        A("sub %1,r0")      
+        A("sbc %2,r1")      
+        A("sbc %3,%13")                    // %3:%2:%1:%0 -= LO(d) * MI(x) << 8
+        A("mul %7,%10")                    // r1:r0 = MI(d) * MI(x)
+        A("sub %2,r0")      
+        A("sbc %3,r1")                     // %3:%2:%1:%0 -= MI(d) * MI(x) << 16
+        A("mul %8,%10")                    // r1:r0 = HI(d) * MI(x)
+        A("sub %3,r0")                     // %3:%2:%1:%0 -= MIL(d) * MI(x) << 24
+        A("mul %6,%11")                    // r1:r0 = LO(d) * HI(x)
+        A("sub %2,r0")      
+        A("sbc %3,r1")                     // %3:%2:%1:%0 -= LO(d) * HI(x) << 16
+        A("mul %7,%11")                    // r1:r0 = MI(d) * HI(x)
+        A("sub %3,r0")                     // %3:%2:%1:%0 -= MI(d) * HI(x) << 24
         // %3:%2:%1:%0 = r = (1<<24) - x*d
         // %8:%7:%6 = d = interval
 
         // Perform the final correction
-        " sub %0,%6" "\n\t"
-        " sbc %1,%7" "\n\t"
-        " sbc %2,%8" "\n\t"               // r -= d
-        " brcs 14f" "\n\t"                // if ( r >= d)
+        A("sub %0,%6")      
+        A("sbc %1,%7")      
+        A("sbc %2,%8")                     // r -= d
+        A("brcs 14f")                      // if ( r >= d)
 
         // %11:%10:%9 = x
-        " ldi %3,1" "\n\t"
-        " add %9,%3" "\n\t"
-        " adc %10,%13" "\n\t"
-        " adc %11,%13" "\n\t"             // x++
-        "14:" "\n\t"
+        A("ldi %3,1")      
+        A("add %9,%3")      
+        A("adc %10,%13")      
+        A("adc %11,%13")                   // x++
+        L("14")
 
         // Estimation is done. %11:%10:%9 = x
-        " clr __zero_reg__" "\n\t"        // Make C runtime happy
+        A("clr __zero_reg__")              // Make C runtime happy
         // [211 cycles total]
         : "=r" (r2),
           "=r" (r3),
           "=r" (r4),
           "=d" (r5),
           "=r" (r6),
           "=r" (r7),
           "+r" (r8),
           "+r" (r9),
           "+r" (r10),

commit d1b619be52c7af5c506add9ee78d4a4742e22b9c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 8 09:17:44 2018 -0500

    Standardize some hexadecimals

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 9eac9e2617..7a68cc6283 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -315,33 +315,33 @@ void Planner::init() {
     //  };
     //
     //  // For small divisors, it is best to directly retrieve the results
     //  if (d <= 110)
     //    return pgm_read_dword(&small_inv_tab[d]);
     //
     //  // Compute initial estimation of 0x1000000/x -
     //  // Get most significant bit set on divider
     //  uint8_t idx = 0;
     //  uint32_t nr = d;
-    //  if (!(nr & 0xff0000)) {
+    //  if (!(nr & 0xFF0000)) {
     //    nr <<= 8;
     //    idx += 8;
-    //    if (!(nr & 0xff0000)) {
+    //    if (!(nr & 0xFF0000)) {
     //      nr <<= 8;
     //      idx += 8;
     //    }
     //  }
-    //  if (!(nr & 0xf00000)) {
+    //  if (!(nr & 0xF00000)) {
     //    nr <<= 4;
     //    idx += 4;
     //  }
-    //  if (!(nr & 0xc00000)) {
+    //  if (!(nr & 0xC00000)) {
     //    nr <<= 2;
     //    idx += 2;
     //  }
     //  if (!(nr & 0x800000)) {
     //    nr <<= 1;
     //    idx += 1;
     //  }
     //
     //  // Isolate top 9 bits of the denominator, to be used as index into the initial estimation table
     //  uint32_t tidx = nr >> 15;         // top 9 bits. bit8 is always set

commit 1f11b0f612ffc1087df6a46c422fcef4f2b1eb86
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 6 04:21:33 2018 -0500

    Fully init planner sync block

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 4be4b2af59..9eac9e2617 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2028,26 +2028,43 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
 
 /**
  * Planner::buffer_sync_block
  * Add a block to the buffer that just updates the position
  */
 void Planner::buffer_sync_block() {
   // Wait for the next available block
   uint8_t next_buffer_head;
   block_t * const block = get_next_free_block(next_buffer_head);
 
+  block->flag = BLOCK_FLAG_SYNC_POSITION;
+
   block->steps[A_AXIS] = position[A_AXIS];
   block->steps[B_AXIS] = position[B_AXIS];
   block->steps[C_AXIS] = position[C_AXIS];
   block->steps[E_AXIS] = position[E_AXIS];
 
-  block->flag = BLOCK_FLAG_SYNC_POSITION;
+  #if ENABLED(LIN_ADVANCE)
+    block->use_advance_lead = false;
+  #endif
+
+  block->nominal_speed   =
+  block->entry_speed     =
+  block->max_entry_speed =
+  block->millimeters     =  
+  block->acceleration    = 0;
+
+  block->step_event_count          =
+  block->nominal_rate              =
+  block->initial_rate              =
+  block->final_rate                =
+  block->acceleration_steps_per_s2 =
+  block->segment_time_us           = 0;
 
   block_buffer_head = next_buffer_head;
   stepper.wake_up();
 } // buffer_sync_block()
 
 /**
  * Planner::buffer_segment
  *
  * Add a new linear movement to the buffer in axis units.
  *

commit af1950a63e4049c6f870fffcc12bf6e0f15dddac
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 3 17:45:13 2018 -0500

    Improve sync of stepper positions

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 8aa08cd54b..4be4b2af59 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1375,29 +1375,23 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
   #else
     if (da < 0) SBI(dm, X_AXIS);
     if (db < 0) SBI(dm, Y_AXIS);
     if (dc < 0) SBI(dm, Z_AXIS);
   #endif
   if (de < 0) SBI(dm, E_AXIS);
 
   const float esteps_float = de * e_factor[extruder];
   const int32_t esteps = abs(esteps_float) + 0.5;
 
-  // Calculate the buffer head after we push this byte
-  const uint8_t next_buffer_head = next_block_index(block_buffer_head);
-
-  // If the buffer is full: good! That means we are well ahead of the robot.
-  // Rest here until there is room in the buffer.
-  while (block_buffer_tail == next_buffer_head) idle();
-
-  // Prepare to set up new block
-  block_t* block = &block_buffer[block_buffer_head];
+  // Wait for the next available block
+  uint8_t next_buffer_head;
+  block_t * const block = get_next_free_block(next_buffer_head);
 
   // Clear all flags, including the "busy" bit
   block->flag = 0x00;
 
   // Set direction bits
   block->direction_bits = dm;
 
   // Number of steps for each axis
   // See http://www.corexy.com/theory.html
   #if CORE_IS_XY
@@ -2025,20 +2019,40 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
   static_assert(COUNT(target) > 1, "Parameter to _buffer_steps must be (&target)[XYZE]!");
   COPY(position, target);
   #if HAS_POSITION_FLOAT
     COPY(position_float, target_float);
   #endif
 
   recalculate();
 
 } // _buffer_steps()
 
+/**
+ * Planner::buffer_sync_block
+ * Add a block to the buffer that just updates the position
+ */
+void Planner::buffer_sync_block() {
+  // Wait for the next available block
+  uint8_t next_buffer_head;
+  block_t * const block = get_next_free_block(next_buffer_head);
+
+  block->steps[A_AXIS] = position[A_AXIS];
+  block->steps[B_AXIS] = position[B_AXIS];
+  block->steps[C_AXIS] = position[C_AXIS];
+  block->steps[E_AXIS] = position[E_AXIS];
+
+  block->flag = BLOCK_FLAG_SYNC_POSITION;
+
+  block_buffer_head = next_buffer_head;
+  stepper.wake_up();
+} // buffer_sync_block()
+
 /**
  * Planner::buffer_segment
  *
  * Add a new linear movement to the buffer in axis units.
  *
  * Leveling and kinematics should be applied ahead of calling this.
  *
  *  a,b,c,e     - target positions in mm and/or degrees
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
@@ -2153,33 +2167,33 @@ void Planner::buffer_segment(const float &a, const float &b, const float &c, con
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
 
 void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define _EINDEX (E_AXIS + active_extruder)
     last_extruder = active_extruder;
   #else
     #define _EINDEX E_AXIS
   #endif
-  const int32_t na = position[A_AXIS] = LROUND(a * axis_steps_per_mm[A_AXIS]),
-                nb = position[B_AXIS] = LROUND(b * axis_steps_per_mm[B_AXIS]),
-                nc = position[C_AXIS] = LROUND(c * axis_steps_per_mm[C_AXIS]),
-                ne = position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
+  position[A_AXIS] = LROUND(a * axis_steps_per_mm[A_AXIS]),
+  position[B_AXIS] = LROUND(b * axis_steps_per_mm[B_AXIS]),
+  position[C_AXIS] = LROUND(c * axis_steps_per_mm[C_AXIS]),
+  position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
   #if HAS_POSITION_FLOAT
-    position_float[X_AXIS] = a;
-    position_float[Y_AXIS] = b;
-    position_float[Z_AXIS] = c;
+    position_float[A_AXIS] = a;
+    position_float[B_AXIS] = b;
+    position_float[C_AXIS] = c;
     position_float[E_AXIS] = e;
   #endif
-  stepper.set_position(na, nb, nc, ne);
   previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
   ZERO(previous_speed);
+  buffer_sync_block();
 }
 
 void Planner::set_position_mm_kinematic(const float (&cart)[XYZE]) {
   #if PLANNER_LEVELING
     float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
     apply_leveling(raw);
   #else
     const float (&raw)[XYZE] = cart;
   #endif
   #if IS_KINEMATIC
@@ -2213,37 +2227,37 @@ void Planner::set_position_mm(const AxisEnum axis, const float &v) {
   #if ENABLED(DISTINCT_E_FACTORS)
     const uint8_t axis_index = axis + (axis == E_AXIS ? active_extruder : 0);
     last_extruder = active_extruder;
   #else
     const uint8_t axis_index = axis;
   #endif
   position[axis] = LROUND(v * axis_steps_per_mm[axis_index]);
   #if HAS_POSITION_FLOAT
     position_float[axis] = v;
   #endif
-  stepper.set_position(axis, position[axis]);
   previous_speed[axis] = 0.0;
+  buffer_sync_block();
 }
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
   #if ENABLED(DISTINCT_E_FACTORS)
-    #define HIGHEST_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)
+    #define AXIS_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)
   #else
-    #define HIGHEST_CONDITION true
+    #define AXIS_CONDITION true
   #endif
   uint32_t highest_rate = 1;
   LOOP_XYZE_N(i) {
     max_acceleration_steps_per_s2[i] = max_acceleration_mm_per_s2[i] * axis_steps_per_mm[i];
-    if (HIGHEST_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
+    if (AXIS_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   }
-  cutoff_long = 4294967295UL / highest_rate;
+  cutoff_long = 4294967295UL / highest_rate; // 0xFFFFFFFFUL
 }
 
 // Recalculate position, steps_to_mm if axis_steps_per_mm changes!
 void Planner::refresh_positioning() {
   LOOP_XYZE_N(i) steps_to_mm[i] = 1.0 / axis_steps_per_mm[i];
   set_position_mm_kinematic(current_position);
   reset_acceleration_rates();
 }
 
 #if ENABLED(AUTOTEMP)

commit f423e54f77d82bc2d70e035ec4a6f8d50ce6f6f9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 23 18:00:06 2018 -0500

    Strip trailing spaces

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 2b257056c4..8aa08cd54b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -400,90 +400,90 @@ void Planner::init() {
         return pgm_read_dword(&small_inv_tab[d]);
 
       register uint8_t r8 = d & 0xFF;
       register uint8_t r9 = (d >> 8) & 0xFF;
       register uint8_t r10 = (d >> 16) & 0xFF;
       register uint8_t r2,r3,r4,r5,r6,r7,r11,r12,r13,r14,r15,r16,r17,r18;
       register const uint8_t* ptab = inv_tab;
 
       __asm__ __volatile__(
         // %8:%7:%6 = interval
-        // r31:r30: MUST be those registers, and they must point to the inv_tab 
+        // r31:r30: MUST be those registers, and they must point to the inv_tab
 
-        " clr %13" "\n\t"                 // %13 = 0 
+        " clr %13" "\n\t"                 // %13 = 0
 
-        // Now we must compute 
-        // result = 0xFFFFFF / d 
+        // Now we must compute
+        // result = 0xFFFFFF / d
         // %8:%7:%6 = interval
-        // %16:%15:%14 = nr 
+        // %16:%15:%14 = nr
         // %13 = 0
 
-        // A plain division of 24x24 bits should take 388 cycles to complete. We will 
+        // A plain division of 24x24 bits should take 388 cycles to complete. We will
         // use Newton-Raphson for the calculation, and will strive to get way less cycles
         // for the same result - Using C division, it takes 500cycles to complete .
 
-        " clr %3" "\n\t"                  // idx = 0 
+        " clr %3" "\n\t"                  // idx = 0
         " mov %14,%6" "\n\t"
         " mov %15,%7" "\n\t"
-        " mov %16,%8" "\n\t"              // nr = interval 
-        " tst %16" "\n\t"                 // nr & 0xFF0000 == 0 ? 
-        " brne 2f" "\n\t"                 // No, skip this 
+        " mov %16,%8" "\n\t"              // nr = interval
+        " tst %16" "\n\t"                 // nr & 0xFF0000 == 0 ?
+        " brne 2f" "\n\t"                 // No, skip this
         " mov %16,%15" "\n\t"
-        " mov %15,%14" "\n\t"             // nr <<= 8, %14 not needed 
-        " subi %3,-8" "\n\t"              // idx += 8 
-        " tst %16" "\n\t"                 // nr & 0xFF0000 == 0 ? 
-        " brne 2f" "\n\t"                 // No, skip this 
-        " mov %16,%15" "\n\t"             // nr <<= 8, %14 not needed 
-        " clr %15" "\n\t"                 // We clear %14 
-        " subi %3,-8" "\n\t"              // idx += 8 
-
-        // here %16 != 0 and %16:%15 contains at least 9 MSBits, or both %16:%15 are 0 
+        " mov %15,%14" "\n\t"             // nr <<= 8, %14 not needed
+        " subi %3,-8" "\n\t"              // idx += 8
+        " tst %16" "\n\t"                 // nr & 0xFF0000 == 0 ?
+        " brne 2f" "\n\t"                 // No, skip this
+        " mov %16,%15" "\n\t"             // nr <<= 8, %14 not needed
+        " clr %15" "\n\t"                 // We clear %14
+        " subi %3,-8" "\n\t"              // idx += 8
+
+        // here %16 != 0 and %16:%15 contains at least 9 MSBits, or both %16:%15 are 0
         "2:" "\n\t"
-        " cpi %16,0x10" "\n\t"            // (nr & 0xf00000) == 0 ? 
-        " brcc 3f" "\n\t"                 // No, skip this 
-        " swap %15" "\n\t"                // Swap nibbles 
-        " swap %16" "\n\t"                // Swap nibbles. Low nibble is 0 
+        " cpi %16,0x10" "\n\t"            // (nr & 0xf00000) == 0 ?
+        " brcc 3f" "\n\t"                 // No, skip this
+        " swap %15" "\n\t"                // Swap nibbles
+        " swap %16" "\n\t"                // Swap nibbles. Low nibble is 0
         " mov %14, %15" "\n\t"
-        " andi %14,0x0f" "\n\t"           // Isolate low nibble 
-        " andi %15,0xf0" "\n\t"           // Keep proper nibble in %15 
-        " or %16, %14" "\n\t"             // %16:%15 <<= 4 
-        " subi %3,-4" "\n\t"              // idx += 4 
+        " andi %14,0x0f" "\n\t"           // Isolate low nibble
+        " andi %15,0xf0" "\n\t"           // Keep proper nibble in %15
+        " or %16, %14" "\n\t"             // %16:%15 <<= 4
+        " subi %3,-4" "\n\t"              // idx += 4
 
         "3:" "\n\t"
-        " cpi %16,0x40" "\n\t"            // (nr & 0xc00000) == 0 ? 
+        " cpi %16,0x40" "\n\t"            // (nr & 0xc00000) == 0 ?
         " brcc 4f" "\n\t"                 // No, skip this
         " add %15,%15" "\n\t"
         " adc %16,%16" "\n\t"
         " add %15,%15" "\n\t"
-        " adc %16,%16" "\n\t"             // %16:%15 <<= 2 
-        " subi %3,-2" "\n\t"              // idx += 2 
+        " adc %16,%16" "\n\t"             // %16:%15 <<= 2
+        " subi %3,-2" "\n\t"              // idx += 2
 
         "4:" "\n\t"
-        " cpi %16,0x80" "\n\t"            // (nr & 0x800000) == 0 ? 
-        " brcc 5f" "\n\t"                 // No, skip this 
+        " cpi %16,0x80" "\n\t"            // (nr & 0x800000) == 0 ?
+        " brcc 5f" "\n\t"                 // No, skip this
         " add %15,%15" "\n\t"
-        " adc %16,%16" "\n\t"             // %16:%15 <<= 1 
-        " inc %3" "\n\t"                  // idx += 1 
+        " adc %16,%16" "\n\t"             // %16:%15 <<= 1
+        " inc %3" "\n\t"                  // idx += 1
 
         // Now %16:%15 contains its MSBit set to 1, or %16:%15 is == 0. We are now absolutely sure
         // we have at least 9 MSBits available to enter the initial estimation table
         "5:" "\n\t"
         " add %15,%15" "\n\t"
         " adc %16,%16" "\n\t"             // %16:%15 = tidx = (nr <<= 1), we lose the top MSBit (always set to 1, %16 is the index into the inverse table)
-        " add r30,%16" "\n\t"             // Only use top 8 bits 
-        " adc r31,%13" "\n\t"             // r31:r30 = inv_tab + (tidx) 
-        " lpm %14, Z" "\n\t"              // %14 = inv_tab[tidx] 
-        " ldi %15, 1" "\n\t"              // %15 = 1  %15:%14 = inv_tab[tidx] + 256 
+        " add r30,%16" "\n\t"             // Only use top 8 bits
+        " adc r31,%13" "\n\t"             // r31:r30 = inv_tab + (tidx)
+        " lpm %14, Z" "\n\t"              // %14 = inv_tab[tidx]
+        " ldi %15, 1" "\n\t"              // %15 = 1  %15:%14 = inv_tab[tidx] + 256
 
         // We must scale the approximation to the proper place
-        " clr %16" "\n\t"                 // %16 will always be 0 here 
-        " subi %3,8" "\n\t"               // idx == 8 ? 
+        " clr %16" "\n\t"                 // %16 will always be 0 here
+        " subi %3,8" "\n\t"               // idx == 8 ?
         " breq 6f" "\n\t"                 // yes, no need to scale
         " brcs 7f" "\n\t"                 // If C=1, means idx < 8, result was negative!
 
         // idx > 8, now %3 = idx - 8. We must perform a left shift. idx range:[1-8]
         " sbrs %3,0" "\n\t"               // shift by 1bit position?
         " rjmp 8f" "\n\t"                 // No
         " add %14,%14" "\n\t"
         " adc %15,%15" "\n\t"             // %15:16 <<= 1
         "8:" "\n\t"
         " sbrs %3,1" "\n\t"               // shift by 2bit position?
@@ -496,27 +496,27 @@ void Planner::init() {
         " sbrs %3,2" "\n\t"               // shift by 4bits position?
         " rjmp 16f" "\n\t"                // No
         " swap %15" "\n\t"                // Swap nibbles. lo nibble of %15 will always be 0
         " swap %14" "\n\t"                // Swap nibbles
         " mov %12,%14" "\n\t"
         " andi %12,0x0f" "\n\t"           // isolate low nibble
         " andi %14,0xf0" "\n\t"           // and clear it
         " or %15,%12" "\n\t"              // %15:%16 <<= 4
         "16:" "\n\t"
         " sbrs %3,3" "\n\t"               // shift by 8bits position?
-        " rjmp 6f" "\n\t"                 // No, we are done 
+        " rjmp 6f" "\n\t"                 // No, we are done
         " mov %16,%15" "\n\t"
         " mov %15,%14" "\n\t"
         " clr %14" "\n\t"
         " jmp 6f" "\n\t"
 
-        // idx < 8, now %3 = idx - 8. Get the count of bits 
+        // idx < 8, now %3 = idx - 8. Get the count of bits
         "7:" "\n\t"
         " neg %3" "\n\t"                  // %3 = -idx = count of bits to move right. idx range:[1...8]
         " sbrs %3,0" "\n\t"               // shift by 1 bit position ?
         " rjmp 10f" "\n\t"                // No, skip it
         " asr %15" "\n\t"                 // (bit7 is always 0 here)
         " ror %14" "\n\t"
         "10:" "\n\t"
         " sbrs %3,1" "\n\t"               // shift by 2 bit position ?
         " rjmp 11f" "\n\t"                // No, skip it
         " asr %15" "\n\t"                 // (bit7 is always 0 here)
@@ -534,21 +534,21 @@ void Planner::init() {
         "12:" "\n\t"
         " sbrs %3,3" "\n\t"               // shift by 8 bit position ?
         " rjmp 6f" "\n\t"                 // No, skip it
         " mov %14,%15" "\n\t"
         " clr %15" "\n\t"
         "6:" "\n\t"                       // %16:%15:%14 = initial estimation of 0x1000000 / d
 
         // Now, we must refine the estimation present on %16:%15:%14 using 1 iteration
         // of Newton-Raphson. As it has a quadratic convergence, 1 iteration is enough
         // to get more than 18bits of precision (the initial table lookup gives 9 bits of
-        // precision to start from). 18bits of precision is all what is needed here for result 
+        // precision to start from). 18bits of precision is all what is needed here for result
 
         // %8:%7:%6 = d = interval
         // %16:%15:%14 = x = initial estimation of 0x1000000 / d
         // %13 = 0
         // %3:%2:%1:%0 = working accumulator
 
         // Compute 1<<25 - x*d. Result should never exceed 25 bits and should always be positive
         " clr %0" "\n\t"
         " clr %1" "\n\t"
         " clr %2" "\n\t"
@@ -578,35 +578,35 @@ void Planner::init() {
         " sub %2,r0" "\n\t"
         " sbc %3,r1" "\n\t"               // %3:%2:%1:%0 -= LO(d) * HI(x) << 16
         " mul %7,%16" "\n\t"              // r1:r0 = MI(d) * HI(x)
         " sub %3,r0" "\n\t"               // %3:%2:%1:%0 -= MI(d) * HI(x) << 24
         // %3:%2:%1:%0 = (1<<25) - x*d     [169]
 
         // We need to multiply that result by x, and we are only interested in the top 24bits of that multiply
 
         // %16:%15:%14 = x = initial estimation of 0x1000000 / d
         // %3:%2:%1:%0 = (1<<25) - x*d = acc
-        // %13 = 0 
+        // %13 = 0
 
         // result = %11:%10:%9:%5:%4
         " mul %14,%0" "\n\t"              // r1:r0 = LO(x) * LO(acc)
         " mov %4,r1" "\n\t"
         " clr %5" "\n\t"
         " clr %9" "\n\t"
         " clr %10" "\n\t"
         " clr %11" "\n\t"                 // %11:%10:%9:%5:%4 = LO(x) * LO(acc) >> 8
         " mul %15,%0" "\n\t"              // r1:r0 = MI(x) * LO(acc)
         " add %4,r0" "\n\t"
         " adc %5,r1" "\n\t"
         " adc %9,%13" "\n\t"
         " adc %10,%13" "\n\t"
-        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 += MI(x) * LO(acc) 
+        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 += MI(x) * LO(acc)
         " mul %16,%0" "\n\t"              // r1:r0 = HI(x) * LO(acc)
         " add %5,r0" "\n\t"
         " adc %9,r1" "\n\t"
         " adc %10,%13" "\n\t"
         " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 += MI(x) * LO(acc) << 8
 
         " mul %14,%1" "\n\t"              // r1:r0 = LO(x) * MIL(acc)
         " add %4,r0" "\n\t"
         " adc %5,r1" "\n\t"
         " adc %9,%13" "\n\t"
@@ -638,26 +638,26 @@ void Planner::init() {
         " mul %14,%3" "\n\t"              // r1:r0 = LO(x) * HI(acc)
         " add %9,r0" "\n\t"
         " adc %10,r1" "\n\t"
         " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 = LO(x) * HI(acc) << 16
         " mul %15,%3" "\n\t"              // r1:r0 = MI(x) * HI(acc)
         " add %10,r0" "\n\t"
         " adc %11,r1" "\n\t"              // %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 24
         " mul %16,%3" "\n\t"              // r1:r0 = HI(x) * HI(acc)
         " add %11,r0" "\n\t"              // %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 32
 
-        // At this point, %11:%10:%9 contains the new estimation of x. 
+        // At this point, %11:%10:%9 contains the new estimation of x.
 
         // Finally, we must correct the result. Estimate remainder as
-        // (1<<24) - x*d 
-        // %11:%10:%9 = x 
-        // %8:%7:%6 = d = interval" "\n\t"  
+        // (1<<24) - x*d
+        // %11:%10:%9 = x
+        // %8:%7:%6 = d = interval" "\n\t"
         " ldi %3,1" "\n\t"
         " clr %2" "\n\t"
         " clr %1" "\n\t"
         " clr %0" "\n\t"                  // %3:%2:%1:%0 = 0x1000000
         " mul %6,%9" "\n\t"               // r1:r0 = LO(d) * LO(x)
         " sub %0,r0" "\n\t"
         " sbc %1,r1" "\n\t"
         " sbc %2,%13" "\n\t"
         " sbc %3,%13" "\n\t"              // %3:%2:%1:%0 -= LO(d) * LO(x)
         " mul %7,%9" "\n\t"               // r1:r0 = MI(d) * LO(x)
@@ -675,37 +675,37 @@ void Planner::init() {
         " sub %2,r0" "\n\t"
         " sbc %3,r1" "\n\t"               // %3:%2:%1:%0 -= MI(d) * MI(x) << 16
         " mul %8,%10" "\n\t"              // r1:r0 = HI(d) * MI(x)
         " sub %3,r0" "\n\t"               // %3:%2:%1:%0 -= MIL(d) * MI(x) << 24
         " mul %6,%11" "\n\t"              // r1:r0 = LO(d) * HI(x)
         " sub %2,r0" "\n\t"
         " sbc %3,r1" "\n\t"               // %3:%2:%1:%0 -= LO(d) * HI(x) << 16
         " mul %7,%11" "\n\t"              // r1:r0 = MI(d) * HI(x)
         " sub %3,r0" "\n\t"               // %3:%2:%1:%0 -= MI(d) * HI(x) << 24
         // %3:%2:%1:%0 = r = (1<<24) - x*d
-        // %8:%7:%6 = d = interval 
+        // %8:%7:%6 = d = interval
 
         // Perform the final correction
         " sub %0,%6" "\n\t"
         " sbc %1,%7" "\n\t"
         " sbc %2,%8" "\n\t"               // r -= d
-        " brcs 14f" "\n\t"                // if ( r >= d) 
+        " brcs 14f" "\n\t"                // if ( r >= d)
 
-        // %11:%10:%9 = x 
+        // %11:%10:%9 = x
         " ldi %3,1" "\n\t"
         " add %9,%3" "\n\t"
         " adc %10,%13" "\n\t"
         " adc %11,%13" "\n\t"             // x++
         "14:" "\n\t"
 
-        // Estimation is done. %11:%10:%9 = x 
-        " clr __zero_reg__" "\n\t"        // Make C runtime happy 
+        // Estimation is done. %11:%10:%9 = x
+        " clr __zero_reg__" "\n\t"        // Make C runtime happy
         // [211 cycles total]
         : "=r" (r2),
           "=r" (r3),
           "=r" (r4),
           "=d" (r5),
           "=r" (r6),
           "=r" (r7),
           "+r" (r8),
           "+r" (r9),
           "+r" (r10),

commit 5a064d0e94c823de5787105c31c536d5fed7c089
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 16 04:19:58 2018 -0500

    Fix bug in planner.set_position_mm

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 5a5ef562ed..2b257056c4 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -2213,21 +2213,21 @@ void Planner::set_position_mm(const AxisEnum axis, const float &v) {
   #if ENABLED(DISTINCT_E_FACTORS)
     const uint8_t axis_index = axis + (axis == E_AXIS ? active_extruder : 0);
     last_extruder = active_extruder;
   #else
     const uint8_t axis_index = axis;
   #endif
   position[axis] = LROUND(v * axis_steps_per_mm[axis_index]);
   #if HAS_POSITION_FLOAT
     position_float[axis] = v;
   #endif
-  stepper.set_position(axis, v);
+  stepper.set_position(axis, position[axis]);
   previous_speed[axis] = 0.0;
 }
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define HIGHEST_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)
   #else
     #define HIGHEST_CONDITION true
   #endif

commit 8f57e098deca8d42867e45fc1bcb2f8d7e5f76d4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 15 19:02:30 2018 -0500

    Use end-of-line comments in planner.cpp

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 43d01d3dc6..5a5ef562ed 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -399,314 +399,314 @@ void Planner::init() {
       if (d <= 110)
         return pgm_read_dword(&small_inv_tab[d]);
 
       register uint8_t r8 = d & 0xFF;
       register uint8_t r9 = (d >> 8) & 0xFF;
       register uint8_t r10 = (d >> 16) & 0xFF;
       register uint8_t r2,r3,r4,r5,r6,r7,r11,r12,r13,r14,r15,r16,r17,r18;
       register const uint8_t* ptab = inv_tab;
 
       __asm__ __volatile__(
-        /*  %8:%7:%6 = interval*/
-        /*  r31:r30: MUST be those registers, and they must point to the inv_tab */
+        // %8:%7:%6 = interval
+        // r31:r30: MUST be those registers, and they must point to the inv_tab 
 
-        " clr %13" "\n\t"                 /* %13 = 0 */
+        " clr %13" "\n\t"                 // %13 = 0 
 
-        /*  Now we must compute */
-        /*   result = 0xFFFFFF / d */
-        /*  %8:%7:%6 = interval*/
-        /*  %16:%15:%14 = nr */
-        /*  %13 = 0*/
+        // Now we must compute 
+        // result = 0xFFFFFF / d 
+        // %8:%7:%6 = interval
+        // %16:%15:%14 = nr 
+        // %13 = 0
 
-        /*  A plain division of 24x24 bits should take 388 cycles to complete. We will */
-        /*  use Newton-Raphson for the calculation, and will strive to get way less cycles*/
-        /*  for the same result - Using C division, it takes 500cycles to complete .*/
+        // A plain division of 24x24 bits should take 388 cycles to complete. We will 
+        // use Newton-Raphson for the calculation, and will strive to get way less cycles
+        // for the same result - Using C division, it takes 500cycles to complete .
 
-        " clr %3" "\n\t"                  /* idx = 0 */
+        " clr %3" "\n\t"                  // idx = 0 
         " mov %14,%6" "\n\t"
         " mov %15,%7" "\n\t"
-        " mov %16,%8" "\n\t"              /* nr = interval */
-        " tst %16" "\n\t"                 /* nr & 0xFF0000 == 0 ? */
-        " brne 2f" "\n\t"                 /* No, skip this */
+        " mov %16,%8" "\n\t"              // nr = interval 
+        " tst %16" "\n\t"                 // nr & 0xFF0000 == 0 ? 
+        " brne 2f" "\n\t"                 // No, skip this 
         " mov %16,%15" "\n\t"
-        " mov %15,%14" "\n\t"             /* nr <<= 8, %14 not needed */
-        " subi %3,-8" "\n\t"              /* idx += 8 */
-        " tst %16" "\n\t"                 /* nr & 0xFF0000 == 0 ? */
-        " brne 2f" "\n\t"                 /* No, skip this */
-        " mov %16,%15" "\n\t"             /* nr <<= 8, %14 not needed */
-        " clr %15" "\n\t"                 /* We clear %14 */
-        " subi %3,-8" "\n\t"              /* idx += 8 */
-
-        /*  here %16 != 0 and %16:%15 contains at least 9 MSBits, or both %16:%15 are 0 */
+        " mov %15,%14" "\n\t"             // nr <<= 8, %14 not needed 
+        " subi %3,-8" "\n\t"              // idx += 8 
+        " tst %16" "\n\t"                 // nr & 0xFF0000 == 0 ? 
+        " brne 2f" "\n\t"                 // No, skip this 
+        " mov %16,%15" "\n\t"             // nr <<= 8, %14 not needed 
+        " clr %15" "\n\t"                 // We clear %14 
+        " subi %3,-8" "\n\t"              // idx += 8 
+
+        // here %16 != 0 and %16:%15 contains at least 9 MSBits, or both %16:%15 are 0 
         "2:" "\n\t"
-        " cpi %16,0x10" "\n\t"            /* (nr & 0xf00000) == 0 ? */
-        " brcc 3f" "\n\t"                 /* No, skip this */
-        " swap %15" "\n\t"                /* Swap nibbles */
-        " swap %16" "\n\t"                /* Swap nibbles. Low nibble is 0 */
+        " cpi %16,0x10" "\n\t"            // (nr & 0xf00000) == 0 ? 
+        " brcc 3f" "\n\t"                 // No, skip this 
+        " swap %15" "\n\t"                // Swap nibbles 
+        " swap %16" "\n\t"                // Swap nibbles. Low nibble is 0 
         " mov %14, %15" "\n\t"
-        " andi %14,0x0f" "\n\t"           /* Isolate low nibble */
-        " andi %15,0xf0" "\n\t"           /* Keep proper nibble in %15 */
-        " or %16, %14" "\n\t"             /* %16:%15 <<= 4 */
-        " subi %3,-4" "\n\t"              /* idx += 4 */
+        " andi %14,0x0f" "\n\t"           // Isolate low nibble 
+        " andi %15,0xf0" "\n\t"           // Keep proper nibble in %15 
+        " or %16, %14" "\n\t"             // %16:%15 <<= 4 
+        " subi %3,-4" "\n\t"              // idx += 4 
 
         "3:" "\n\t"
-        " cpi %16,0x40" "\n\t"            /* (nr & 0xc00000) == 0 ? */
-        " brcc 4f" "\n\t"                 /* No, skip this*/
+        " cpi %16,0x40" "\n\t"            // (nr & 0xc00000) == 0 ? 
+        " brcc 4f" "\n\t"                 // No, skip this
         " add %15,%15" "\n\t"
         " adc %16,%16" "\n\t"
         " add %15,%15" "\n\t"
-        " adc %16,%16" "\n\t"             /* %16:%15 <<= 2 */
-        " subi %3,-2" "\n\t"              /* idx += 2 */
+        " adc %16,%16" "\n\t"             // %16:%15 <<= 2 
+        " subi %3,-2" "\n\t"              // idx += 2 
 
         "4:" "\n\t"
-        " cpi %16,0x80" "\n\t"            /* (nr & 0x800000) == 0 ? */
-        " brcc 5f" "\n\t"                 /* No, skip this */
+        " cpi %16,0x80" "\n\t"            // (nr & 0x800000) == 0 ? 
+        " brcc 5f" "\n\t"                 // No, skip this 
         " add %15,%15" "\n\t"
-        " adc %16,%16" "\n\t"             /* %16:%15 <<= 1 */
-        " inc %3" "\n\t"                  /* idx += 1 */
+        " adc %16,%16" "\n\t"             // %16:%15 <<= 1 
+        " inc %3" "\n\t"                  // idx += 1 
 
-        /*  Now %16:%15 contains its MSBit set to 1, or %16:%15 is == 0. We are now absolutely sure*/
-        /*  we have at least 9 MSBits available to enter the initial estimation table*/
+        // Now %16:%15 contains its MSBit set to 1, or %16:%15 is == 0. We are now absolutely sure
+        // we have at least 9 MSBits available to enter the initial estimation table
         "5:" "\n\t"
         " add %15,%15" "\n\t"
-        " adc %16,%16" "\n\t"             /* %16:%15 = tidx = (nr <<= 1), we lose the top MSBit (always set to 1, %16 is the index into the inverse table)*/
-        " add r30,%16" "\n\t"             /* Only use top 8 bits */
-        " adc r31,%13" "\n\t"             /* r31:r30 = inv_tab + (tidx) */
-        " lpm %14, Z" "\n\t"              /* %14 = inv_tab[tidx] */
-        " ldi %15, 1" "\n\t"              /* %15 = 1  %15:%14 = inv_tab[tidx] + 256 */
-
-        /*  We must scale the approximation to the proper place*/
-        " clr %16" "\n\t"                 /* %16 will always be 0 here */
-        " subi %3,8" "\n\t"               /* idx == 8 ? */
-        " breq 6f" "\n\t"                 /* yes, no need to scale*/
-        " brcs 7f" "\n\t"                 /* If C=1, means idx < 8, result was negative!*/
-
-        /*  idx > 8, now %3 = idx - 8. We must perform a left shift. idx range:[1-8]*/
-        " sbrs %3,0" "\n\t"               /* shift by 1bit position?*/
-        " rjmp 8f" "\n\t"                 /* No*/
+        " adc %16,%16" "\n\t"             // %16:%15 = tidx = (nr <<= 1), we lose the top MSBit (always set to 1, %16 is the index into the inverse table)
+        " add r30,%16" "\n\t"             // Only use top 8 bits 
+        " adc r31,%13" "\n\t"             // r31:r30 = inv_tab + (tidx) 
+        " lpm %14, Z" "\n\t"              // %14 = inv_tab[tidx] 
+        " ldi %15, 1" "\n\t"              // %15 = 1  %15:%14 = inv_tab[tidx] + 256 
+
+        // We must scale the approximation to the proper place
+        " clr %16" "\n\t"                 // %16 will always be 0 here 
+        " subi %3,8" "\n\t"               // idx == 8 ? 
+        " breq 6f" "\n\t"                 // yes, no need to scale
+        " brcs 7f" "\n\t"                 // If C=1, means idx < 8, result was negative!
+
+        // idx > 8, now %3 = idx - 8. We must perform a left shift. idx range:[1-8]
+        " sbrs %3,0" "\n\t"               // shift by 1bit position?
+        " rjmp 8f" "\n\t"                 // No
         " add %14,%14" "\n\t"
-        " adc %15,%15" "\n\t"             /* %15:16 <<= 1*/
+        " adc %15,%15" "\n\t"             // %15:16 <<= 1
         "8:" "\n\t"
-        " sbrs %3,1" "\n\t"               /* shift by 2bit position?*/
-        " rjmp 9f" "\n\t"                 /* No*/
+        " sbrs %3,1" "\n\t"               // shift by 2bit position?
+        " rjmp 9f" "\n\t"                 // No
         " add %14,%14" "\n\t"
         " adc %15,%15" "\n\t"
         " add %14,%14" "\n\t"
-        " adc %15,%15" "\n\t"             /* %15:16 <<= 1*/
+        " adc %15,%15" "\n\t"             // %15:16 <<= 1
         "9:" "\n\t"
-        " sbrs %3,2" "\n\t"               /* shift by 4bits position?*/
-        " rjmp 16f" "\n\t"                /* No*/
-        " swap %15" "\n\t"                /* Swap nibbles. lo nibble of %15 will always be 0*/
-        " swap %14" "\n\t"                /* Swap nibbles*/
+        " sbrs %3,2" "\n\t"               // shift by 4bits position?
+        " rjmp 16f" "\n\t"                // No
+        " swap %15" "\n\t"                // Swap nibbles. lo nibble of %15 will always be 0
+        " swap %14" "\n\t"                // Swap nibbles
         " mov %12,%14" "\n\t"
-        " andi %12,0x0f" "\n\t"           /* isolate low nibble*/
-        " andi %14,0xf0" "\n\t"           /* and clear it*/
-        " or %15,%12" "\n\t"              /* %15:%16 <<= 4*/
+        " andi %12,0x0f" "\n\t"           // isolate low nibble
+        " andi %14,0xf0" "\n\t"           // and clear it
+        " or %15,%12" "\n\t"              // %15:%16 <<= 4
         "16:" "\n\t"
-        " sbrs %3,3" "\n\t"               /* shift by 8bits position?*/
-        " rjmp 6f" "\n\t"                 /* No, we are done */
+        " sbrs %3,3" "\n\t"               // shift by 8bits position?
+        " rjmp 6f" "\n\t"                 // No, we are done 
         " mov %16,%15" "\n\t"
         " mov %15,%14" "\n\t"
         " clr %14" "\n\t"
         " jmp 6f" "\n\t"
 
-        /*  idx < 8, now %3 = idx - 8. Get the count of bits */
+        // idx < 8, now %3 = idx - 8. Get the count of bits 
         "7:" "\n\t"
-        " neg %3" "\n\t"                  /* %3 = -idx = count of bits to move right. idx range:[1...8]*/
-        " sbrs %3,0" "\n\t"               /* shift by 1 bit position ?*/
-        " rjmp 10f" "\n\t"                /* No, skip it*/
-        " asr %15" "\n\t"                 /* (bit7 is always 0 here)*/
+        " neg %3" "\n\t"                  // %3 = -idx = count of bits to move right. idx range:[1...8]
+        " sbrs %3,0" "\n\t"               // shift by 1 bit position ?
+        " rjmp 10f" "\n\t"                // No, skip it
+        " asr %15" "\n\t"                 // (bit7 is always 0 here)
         " ror %14" "\n\t"
         "10:" "\n\t"
-        " sbrs %3,1" "\n\t"               /* shift by 2 bit position ?*/
-        " rjmp 11f" "\n\t"                /* No, skip it*/
-        " asr %15" "\n\t"                 /* (bit7 is always 0 here)*/
+        " sbrs %3,1" "\n\t"               // shift by 2 bit position ?
+        " rjmp 11f" "\n\t"                // No, skip it
+        " asr %15" "\n\t"                 // (bit7 is always 0 here)
         " ror %14" "\n\t"
-        " asr %15" "\n\t"                 /* (bit7 is always 0 here)*/
+        " asr %15" "\n\t"                 // (bit7 is always 0 here)
         " ror %14" "\n\t"
         "11:" "\n\t"
-        " sbrs %3,2" "\n\t"               /* shift by 4 bit position ?*/
-        " rjmp 12f" "\n\t"                /* No, skip it*/
-        " swap %15" "\n\t"                /* Swap nibbles*/
-        " andi %14, 0xf0" "\n\t"          /* Lose the lowest nibble*/
-        " swap %14" "\n\t"                /* Swap nibbles. Upper nibble is 0*/
-        " or %14,%15" "\n\t"              /* Pass nibble from upper byte*/
-        " andi %15, 0x0f" "\n\t"          /* And get rid of that nibble*/
+        " sbrs %3,2" "\n\t"               // shift by 4 bit position ?
+        " rjmp 12f" "\n\t"                // No, skip it
+        " swap %15" "\n\t"                // Swap nibbles
+        " andi %14, 0xf0" "\n\t"          // Lose the lowest nibble
+        " swap %14" "\n\t"                // Swap nibbles. Upper nibble is 0
+        " or %14,%15" "\n\t"              // Pass nibble from upper byte
+        " andi %15, 0x0f" "\n\t"          // And get rid of that nibble
         "12:" "\n\t"
-        " sbrs %3,3" "\n\t"               /* shift by 8 bit position ?*/
-        " rjmp 6f" "\n\t"                 /* No, skip it*/
+        " sbrs %3,3" "\n\t"               // shift by 8 bit position ?
+        " rjmp 6f" "\n\t"                 // No, skip it
         " mov %14,%15" "\n\t"
         " clr %15" "\n\t"
-        "6:" "\n\t"                       /* %16:%15:%14 = initial estimation of 0x1000000 / d*/
+        "6:" "\n\t"                       // %16:%15:%14 = initial estimation of 0x1000000 / d
 
-        /*  Now, we must refine the estimation present on %16:%15:%14 using 1 iteration*/
-        /*   of Newton-Raphson. As it has a quadratic convergence, 1 iteration is enough*/
-        /*   to get more than 18bits of precision (the initial table lookup gives 9 bits of*/
-        /*   precision to start from). 18bits of precision is all what is needed here for result */
+        // Now, we must refine the estimation present on %16:%15:%14 using 1 iteration
+        // of Newton-Raphson. As it has a quadratic convergence, 1 iteration is enough
+        // to get more than 18bits of precision (the initial table lookup gives 9 bits of
+        // precision to start from). 18bits of precision is all what is needed here for result 
 
-        /*  %8:%7:%6 = d = interval*/
-        /*  %16:%15:%14 = x = initial estimation of 0x1000000 / d*/
-        /*  %13 = 0*/
-        /*  %3:%2:%1:%0 = working accumulator*/
+        // %8:%7:%6 = d = interval
+        // %16:%15:%14 = x = initial estimation of 0x1000000 / d
+        // %13 = 0
+        // %3:%2:%1:%0 = working accumulator
 
-        /*  Compute 1<<25 - x*d. Result should never exceed 25 bits and should always be positive*/
+        // Compute 1<<25 - x*d. Result should never exceed 25 bits and should always be positive
         " clr %0" "\n\t"
         " clr %1" "\n\t"
         " clr %2" "\n\t"
-        " ldi %3,2" "\n\t"                /* %3:%2:%1:%0 = 0x2000000*/
-        " mul %6,%14" "\n\t"              /* r1:r0 = LO(d) * LO(x)*/
+        " ldi %3,2" "\n\t"                // %3:%2:%1:%0 = 0x2000000
+        " mul %6,%14" "\n\t"              // r1:r0 = LO(d) * LO(x)
         " sub %0,r0" "\n\t"
         " sbc %1,r1" "\n\t"
         " sbc %2,%13" "\n\t"
-        " sbc %3,%13" "\n\t"              /* %3:%2:%1:%0 -= LO(d) * LO(x)*/
-        " mul %7,%14" "\n\t"              /* r1:r0 = MI(d) * LO(x)*/
+        " sbc %3,%13" "\n\t"              // %3:%2:%1:%0 -= LO(d) * LO(x)
+        " mul %7,%14" "\n\t"              // r1:r0 = MI(d) * LO(x)
         " sub %1,r0" "\n\t"
         " sbc %2,r1"  "\n\t"
-        " sbc %3,%13" "\n\t"              /* %3:%2:%1:%0 -= MI(d) * LO(x) << 8*/
-        " mul %8,%14" "\n\t"              /* r1:r0 = HI(d) * LO(x)*/
+        " sbc %3,%13" "\n\t"              // %3:%2:%1:%0 -= MI(d) * LO(x) << 8
+        " mul %8,%14" "\n\t"              // r1:r0 = HI(d) * LO(x)
         " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"               /* %3:%2:%1:%0 -= MIL(d) * LO(x) << 16*/
-        " mul %6,%15" "\n\t"              /* r1:r0 = LO(d) * MI(x)*/
+        " sbc %3,r1" "\n\t"               // %3:%2:%1:%0 -= MIL(d) * LO(x) << 16
+        " mul %6,%15" "\n\t"              // r1:r0 = LO(d) * MI(x)
         " sub %1,r0" "\n\t"
         " sbc %2,r1" "\n\t"
-        " sbc %3,%13" "\n\t"              /* %3:%2:%1:%0 -= LO(d) * MI(x) << 8*/
-        " mul %7,%15" "\n\t"              /* r1:r0 = MI(d) * MI(x)*/
+        " sbc %3,%13" "\n\t"              // %3:%2:%1:%0 -= LO(d) * MI(x) << 8
+        " mul %7,%15" "\n\t"              // r1:r0 = MI(d) * MI(x)
         " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"               /* %3:%2:%1:%0 -= MI(d) * MI(x) << 16*/
-        " mul %8,%15" "\n\t"              /* r1:r0 = HI(d) * MI(x)*/
-        " sub %3,r0" "\n\t"               /* %3:%2:%1:%0 -= MIL(d) * MI(x) << 24*/
-        " mul %6,%16" "\n\t"              /* r1:r0 = LO(d) * HI(x)*/
+        " sbc %3,r1" "\n\t"               // %3:%2:%1:%0 -= MI(d) * MI(x) << 16
+        " mul %8,%15" "\n\t"              // r1:r0 = HI(d) * MI(x)
+        " sub %3,r0" "\n\t"               // %3:%2:%1:%0 -= MIL(d) * MI(x) << 24
+        " mul %6,%16" "\n\t"              // r1:r0 = LO(d) * HI(x)
         " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"               /* %3:%2:%1:%0 -= LO(d) * HI(x) << 16*/
-        " mul %7,%16" "\n\t"              /* r1:r0 = MI(d) * HI(x)*/
-        " sub %3,r0" "\n\t"               /* %3:%2:%1:%0 -= MI(d) * HI(x) << 24*/
-        /*  %3:%2:%1:%0 = (1<<25) - x*d     [169]*/
+        " sbc %3,r1" "\n\t"               // %3:%2:%1:%0 -= LO(d) * HI(x) << 16
+        " mul %7,%16" "\n\t"              // r1:r0 = MI(d) * HI(x)
+        " sub %3,r0" "\n\t"               // %3:%2:%1:%0 -= MI(d) * HI(x) << 24
+        // %3:%2:%1:%0 = (1<<25) - x*d     [169]
 
-        /*  We need to multiply that result by x, and we are only interested in the top 24bits of that multiply*/
+        // We need to multiply that result by x, and we are only interested in the top 24bits of that multiply
 
-        /*  %16:%15:%14 = x = initial estimation of 0x1000000 / d*/
-        /*  %3:%2:%1:%0 = (1<<25) - x*d = acc*/
-        /*  %13 = 0 */
+        // %16:%15:%14 = x = initial estimation of 0x1000000 / d
+        // %3:%2:%1:%0 = (1<<25) - x*d = acc
+        // %13 = 0 
 
-        /*  result = %11:%10:%9:%5:%4*/
-        " mul %14,%0" "\n\t"              /* r1:r0 = LO(x) * LO(acc)*/
+        // result = %11:%10:%9:%5:%4
+        " mul %14,%0" "\n\t"              // r1:r0 = LO(x) * LO(acc)
         " mov %4,r1" "\n\t"
         " clr %5" "\n\t"
         " clr %9" "\n\t"
         " clr %10" "\n\t"
-        " clr %11" "\n\t"                 /* %11:%10:%9:%5:%4 = LO(x) * LO(acc) >> 8*/
-        " mul %15,%0" "\n\t"              /* r1:r0 = MI(x) * LO(acc)*/
+        " clr %11" "\n\t"                 // %11:%10:%9:%5:%4 = LO(x) * LO(acc) >> 8
+        " mul %15,%0" "\n\t"              // r1:r0 = MI(x) * LO(acc)
         " add %4,r0" "\n\t"
         " adc %5,r1" "\n\t"
         " adc %9,%13" "\n\t"
         " adc %10,%13" "\n\t"
-        " adc %11,%13" "\n\t"             /* %11:%10:%9:%5:%4 += MI(x) * LO(acc) */
-        " mul %16,%0" "\n\t"              /* r1:r0 = HI(x) * LO(acc)*/
+        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 += MI(x) * LO(acc) 
+        " mul %16,%0" "\n\t"              // r1:r0 = HI(x) * LO(acc)
         " add %5,r0" "\n\t"
         " adc %9,r1" "\n\t"
         " adc %10,%13" "\n\t"
-        " adc %11,%13" "\n\t"             /* %11:%10:%9:%5:%4 += MI(x) * LO(acc) << 8*/
+        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 += MI(x) * LO(acc) << 8
 
-        " mul %14,%1" "\n\t"              /* r1:r0 = LO(x) * MIL(acc)*/
+        " mul %14,%1" "\n\t"              // r1:r0 = LO(x) * MIL(acc)
         " add %4,r0" "\n\t"
         " adc %5,r1" "\n\t"
         " adc %9,%13" "\n\t"
         " adc %10,%13" "\n\t"
-        " adc %11,%13" "\n\t"             /* %11:%10:%9:%5:%4 = LO(x) * MIL(acc)*/
-        " mul %15,%1" "\n\t"              /* r1:r0 = MI(x) * MIL(acc)*/
+        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 = LO(x) * MIL(acc)
+        " mul %15,%1" "\n\t"              // r1:r0 = MI(x) * MIL(acc)
         " add %5,r0" "\n\t"
         " adc %9,r1" "\n\t"
         " adc %10,%13" "\n\t"
-        " adc %11,%13" "\n\t"             /* %11:%10:%9:%5:%4 += MI(x) * MIL(acc) << 8*/
-        " mul %16,%1" "\n\t"              /* r1:r0 = HI(x) * MIL(acc)*/
+        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 += MI(x) * MIL(acc) << 8
+        " mul %16,%1" "\n\t"              // r1:r0 = HI(x) * MIL(acc)
         " add %9,r0" "\n\t"
         " adc %10,r1" "\n\t"
-        " adc %11,%13" "\n\t"             /* %11:%10:%9:%5:%4 += MI(x) * MIL(acc) << 16*/
+        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 += MI(x) * MIL(acc) << 16
 
-        " mul %14,%2" "\n\t"              /* r1:r0 = LO(x) * MIH(acc)*/
+        " mul %14,%2" "\n\t"              // r1:r0 = LO(x) * MIH(acc)
         " add %5,r0" "\n\t"
         " adc %9,r1" "\n\t"
         " adc %10,%13" "\n\t"
-        " adc %11,%13" "\n\t"             /* %11:%10:%9:%5:%4 = LO(x) * MIH(acc) << 8*/
-        " mul %15,%2" "\n\t"              /* r1:r0 = MI(x) * MIH(acc)*/
+        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 = LO(x) * MIH(acc) << 8
+        " mul %15,%2" "\n\t"              // r1:r0 = MI(x) * MIH(acc)
         " add %9,r0" "\n\t"
         " adc %10,r1" "\n\t"
-        " adc %11,%13" "\n\t"             /* %11:%10:%9:%5:%4 += MI(x) * MIH(acc) << 16*/
-        " mul %16,%2" "\n\t"              /* r1:r0 = HI(x) * MIH(acc)*/
+        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 += MI(x) * MIH(acc) << 16
+        " mul %16,%2" "\n\t"              // r1:r0 = HI(x) * MIH(acc)
         " add %10,r0" "\n\t"
-        " adc %11,r1" "\n\t"              /* %11:%10:%9:%5:%4 += MI(x) * MIH(acc) << 24*/
+        " adc %11,r1" "\n\t"              // %11:%10:%9:%5:%4 += MI(x) * MIH(acc) << 24
 
-        " mul %14,%3" "\n\t"              /* r1:r0 = LO(x) * HI(acc)*/
+        " mul %14,%3" "\n\t"              // r1:r0 = LO(x) * HI(acc)
         " add %9,r0" "\n\t"
         " adc %10,r1" "\n\t"
-        " adc %11,%13" "\n\t"             /* %11:%10:%9:%5:%4 = LO(x) * HI(acc) << 16*/
-        " mul %15,%3" "\n\t"              /* r1:r0 = MI(x) * HI(acc)*/
+        " adc %11,%13" "\n\t"             // %11:%10:%9:%5:%4 = LO(x) * HI(acc) << 16
+        " mul %15,%3" "\n\t"              // r1:r0 = MI(x) * HI(acc)
         " add %10,r0" "\n\t"
-        " adc %11,r1" "\n\t"              /* %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 24*/
-        " mul %16,%3" "\n\t"              /* r1:r0 = HI(x) * HI(acc)*/
-        " add %11,r0" "\n\t"              /* %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 32*/
+        " adc %11,r1" "\n\t"              // %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 24
+        " mul %16,%3" "\n\t"              // r1:r0 = HI(x) * HI(acc)
+        " add %11,r0" "\n\t"              // %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 32
 
-        /*  At this point, %11:%10:%9 contains the new estimation of x. */
+        // At this point, %11:%10:%9 contains the new estimation of x. 
 
-        /*  Finally, we must correct the result. Estimate remainder as*/
-        /*  (1<<24) - x*d*/
-        /*  %11:%10:%9 = x*/
-        /*  %8:%7:%6 = d = interval" "\n\t" /*  */
+        // Finally, we must correct the result. Estimate remainder as
+        // (1<<24) - x*d 
+        // %11:%10:%9 = x 
+        // %8:%7:%6 = d = interval" "\n\t"  
         " ldi %3,1" "\n\t"
         " clr %2" "\n\t"
         " clr %1" "\n\t"
-        " clr %0" "\n\t"                  /* %3:%2:%1:%0 = 0x1000000*/
-        " mul %6,%9" "\n\t"              /* r1:r0 = LO(d) * LO(x)*/
+        " clr %0" "\n\t"                  // %3:%2:%1:%0 = 0x1000000
+        " mul %6,%9" "\n\t"               // r1:r0 = LO(d) * LO(x)
         " sub %0,r0" "\n\t"
         " sbc %1,r1" "\n\t"
         " sbc %2,%13" "\n\t"
-        " sbc %3,%13" "\n\t"              /* %3:%2:%1:%0 -= LO(d) * LO(x)*/
-        " mul %7,%9" "\n\t"              /* r1:r0 = MI(d) * LO(x)*/
+        " sbc %3,%13" "\n\t"              // %3:%2:%1:%0 -= LO(d) * LO(x)
+        " mul %7,%9" "\n\t"               // r1:r0 = MI(d) * LO(x)
         " sub %1,r0" "\n\t"
         " sbc %2,r1" "\n\t"
-        " sbc %3,%13" "\n\t"              /* %3:%2:%1:%0 -= MI(d) * LO(x) << 8*/
-        " mul %8,%9" "\n\t"              /* r1:r0 = HI(d) * LO(x)*/
+        " sbc %3,%13" "\n\t"              // %3:%2:%1:%0 -= MI(d) * LO(x) << 8
+        " mul %8,%9" "\n\t"               // r1:r0 = HI(d) * LO(x)
         " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"               /* %3:%2:%1:%0 -= MIL(d) * LO(x) << 16*/
-        " mul %6,%10" "\n\t"              /* r1:r0 = LO(d) * MI(x)*/
+        " sbc %3,r1" "\n\t"               // %3:%2:%1:%0 -= MIL(d) * LO(x) << 16
+        " mul %6,%10" "\n\t"              // r1:r0 = LO(d) * MI(x)
         " sub %1,r0" "\n\t"
         " sbc %2,r1" "\n\t"
-        " sbc %3,%13" "\n\t"              /* %3:%2:%1:%0 -= LO(d) * MI(x) << 8*/
-        " mul %7,%10" "\n\t"              /* r1:r0 = MI(d) * MI(x)*/
+        " sbc %3,%13" "\n\t"              // %3:%2:%1:%0 -= LO(d) * MI(x) << 8
+        " mul %7,%10" "\n\t"              // r1:r0 = MI(d) * MI(x)
         " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"               /* %3:%2:%1:%0 -= MI(d) * MI(x) << 16*/
-        " mul %8,%10" "\n\t"              /* r1:r0 = HI(d) * MI(x)*/
-        " sub %3,r0" "\n\t"               /* %3:%2:%1:%0 -= MIL(d) * MI(x) << 24*/
-        " mul %6,%11" "\n\t"              /* r1:r0 = LO(d) * HI(x)*/
+        " sbc %3,r1" "\n\t"               // %3:%2:%1:%0 -= MI(d) * MI(x) << 16
+        " mul %8,%10" "\n\t"              // r1:r0 = HI(d) * MI(x)
+        " sub %3,r0" "\n\t"               // %3:%2:%1:%0 -= MIL(d) * MI(x) << 24
+        " mul %6,%11" "\n\t"              // r1:r0 = LO(d) * HI(x)
         " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"               /* %3:%2:%1:%0 -= LO(d) * HI(x) << 16*/
-        " mul %7,%11" "\n\t"              /* r1:r0 = MI(d) * HI(x)*/
-        " sub %3,r0" "\n\t"               /* %3:%2:%1:%0 -= MI(d) * HI(x) << 24*/
-        /*  %3:%2:%1:%0 = r = (1<<24) - x*d*/
-        /*  %8:%7:%6 = d = interval */
+        " sbc %3,r1" "\n\t"               // %3:%2:%1:%0 -= LO(d) * HI(x) << 16
+        " mul %7,%11" "\n\t"              // r1:r0 = MI(d) * HI(x)
+        " sub %3,r0" "\n\t"               // %3:%2:%1:%0 -= MI(d) * HI(x) << 24
+        // %3:%2:%1:%0 = r = (1<<24) - x*d
+        // %8:%7:%6 = d = interval 
 
-        /*  Perform the final correction*/
+        // Perform the final correction
         " sub %0,%6" "\n\t"
         " sbc %1,%7" "\n\t"
-        " sbc %2,%8" "\n\t"              /* r -= d*/
-        " brcs 14f" "\n\t"                /* if ( r >= d) */
+        " sbc %2,%8" "\n\t"               // r -= d
+        " brcs 14f" "\n\t"                // if ( r >= d) 
 
-        /*  %11:%10:%9 = x */
+        // %11:%10:%9 = x 
         " ldi %3,1" "\n\t"
         " add %9,%3" "\n\t"
         " adc %10,%13" "\n\t"
-        " adc %11,%13" "\n\t"             /* x++*/
+        " adc %11,%13" "\n\t"             // x++
         "14:" "\n\t"
 
-        /*  Estimation is done. %11:%10:%9 = x */
-        " clr __zero_reg__" "\n\t"        /* Make C runtime happy */
-        /*  [211 cycles total]*/
+        // Estimation is done. %11:%10:%9 = x 
+        " clr __zero_reg__" "\n\t"        // Make C runtime happy 
+        // [211 cycles total]
         : "=r" (r2),
           "=r" (r3),
           "=r" (r4),
           "=d" (r5),
           "=r" (r6),
           "=r" (r7),
           "+r" (r8),
           "+r" (r9),
           "+r" (r10),
           "=d" (r11),

commit 36b97bde9f92b6ebf899f5240cec62ca8abdcd94
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 13 22:04:53 2018 -0500

    clear_block_buffer, kill_current_block in quick_stop

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index bb0cb8eb2e..43d01d3dc6 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -93,22 +93,22 @@
 #endif
 
 Planner planner;
 
   // public:
 
 /**
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
-volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next block to be pushed
-                 Planner::block_buffer_tail = 0;
+volatile uint8_t Planner::block_buffer_head, // Index of the next block to be pushed
+                 Planner::block_buffer_tail;
 
 float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
       Planner::axis_steps_per_mm[XYZE_N],
       Planner::steps_to_mm[XYZE_N];
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
@@ -200,30 +200,30 @@ float Planner::previous_speed[NUM_AXIS],
   volatile uint32_t Planner::block_buffer_runtime_us = 0;
 #endif
 
 /**
  * Class and Instance Methods
  */
 
 Planner::Planner() { init(); }
 
 void Planner::init() {
-  block_buffer_head = block_buffer_tail = 0;
   ZERO(position);
   #if HAS_POSITION_FLOAT
     ZERO(position_float);
   #endif
   ZERO(previous_speed);
   previous_nominal_speed = 0.0;
   #if ABL_PLANAR
     bed_level_matrix.set_to_identity();
   #endif
+  clear_block_buffer();
 }
 
 #if ENABLED(BEZIER_JERK_CONTROL)
 
   #ifdef __AVR__
     // This routine, for AVR, returns 0x1000000 / d, but trying to get the inverse as
     //  fast as possible. A fast converging iterative Newton-Raphson method is able to
     //  reach full precision in just 1 iteration, and takes 211 cycles (worst case, mean
     //  case is less, up to 30 cycles for small divisors), instead of the 500 cycles a
     //  normal division would take.

commit 57a899a412b0d45c159423925c1f63164dcd9308
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Wed Apr 11 20:13:42 2018 -0300

    [2.0.x] 6th-order jerk-controlled motion planning in real-time for AVR (#10373)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index cd95bb04f9..bb0cb8eb2e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -49,20 +49,24 @@
  *
  * DestinationSpeed[s_, a_, d_] := Sqrt[2 a d + s^2]
  *
  * When to start braking (di) to reach a specified destination speed (s2) after accelerating
  * from initial speed s1 without ever stopping at a plateau:
  *   Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]
  *   di -> (2 a d - s1^2 + s2^2)/(4 a) --> intersection_distance()
  *
  * IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)
  *
+ * --
+ *
+ * The fast inverse function needed for B√©zier interpolation for AVR
+ * was designed, written and tested by Eduardo Jos√© Tagle on April/2018
  */
 
 #include "planner.h"
 #include "stepper.h"
 #include "motion.h"
 #include "../module/temperature.h"
 #include "../lcd/ultralcd.h"
 #include "../core/language.h"
 #include "../gcode/parser.h"
 
@@ -208,20 +212,537 @@ void Planner::init() {
   #if HAS_POSITION_FLOAT
     ZERO(position_float);
   #endif
   ZERO(previous_speed);
   previous_nominal_speed = 0.0;
   #if ABL_PLANAR
     bed_level_matrix.set_to_identity();
   #endif
 }
 
+#if ENABLED(BEZIER_JERK_CONTROL)
+
+  #ifdef __AVR__
+    // This routine, for AVR, returns 0x1000000 / d, but trying to get the inverse as
+    //  fast as possible. A fast converging iterative Newton-Raphson method is able to
+    //  reach full precision in just 1 iteration, and takes 211 cycles (worst case, mean
+    //  case is less, up to 30 cycles for small divisors), instead of the 500 cycles a
+    //  normal division would take.
+    //
+    // Inspired by the following page,
+    //  https://stackoverflow.com/questions/27801397/newton-raphson-division-with-big-integers
+    //
+    // Suppose we want to calculate
+    //  floor(2 ^ k / B)    where B is a positive integer
+    // Then
+    //  B must be <= 2^k, otherwise, the quotient is 0.
+    //
+    // The Newton - Raphson iteration for x = B / 2 ^ k yields:
+    //  q[n + 1] = q[n] * (2 - q[n] * B / 2 ^ k)
+    //
+    // We can rearrange it as:
+    //  q[n + 1] = q[n] * (2 ^ (k + 1) - q[n] * B) >> k
+    //
+    //  Each iteration of this kind requires only integer multiplications
+    // and bit shifts.
+    //  Does it converge to floor(2 ^ k / B) ?:  Not necessarily, but, in
+    // the worst case, it eventually alternates between floor(2 ^ k / B)
+    // and ceiling(2 ^ k / B)).
+    //  So we can use some not-so-clever test to see if we are in this
+    // case, and extract floor(2 ^ k / B).
+    //  Lastly, a simple but important optimization for this approach is to
+    // truncate multiplications (i.e.calculate only the higher bits of the
+    // product) in the early iterations of the Newton - Raphson method.The
+    // reason to do so, is that the results of the early iterations are far
+    // from the quotient, and it doesn't matter to perform them inaccurately.
+    //  Finally, we should pick a good starting value for x. Knowing how many
+    // digits the divisor has, we can estimate it:
+    //
+    // 2^k / x = 2 ^ log2(2^k / x)
+    // 2^k / x = 2 ^(log2(2^k)-log2(x))
+    // 2^k / x = 2 ^(k*log2(2)-log2(x))
+    // 2^k / x = 2 ^ (k-log2(x))
+    // 2^k / x >= 2 ^ (k-floor(log2(x)))
+    // floor(log2(x)) simply is the index of the most significant bit set.
+    //
+    //  If we could improve this estimation even further, then the number of
+    // iterations can be dropped quite a bit, thus saving valuable execution time.
+    //  The paper "Software Integer Division" by Thomas L.Rodeheffer, Microsoft
+    // Research, Silicon Valley,August 26, 2008, that is available at
+    // https://www.microsoft.com/en-us/research/wp-content/uploads/2008/08/tr-2008-141.pdf
+    // suggests , for its integer division algorithm, that using a table to supply the
+    // first 8 bits of precision, and due to the quadratic convergence nature of the
+    // Newton-Raphon iteration, then just 2 iterations should be enough to get
+    // maximum precision of the division.
+    //  If we precompute values of inverses for small denominator values, then
+    // just one Newton-Raphson iteration is enough to reach full precision
+    //  We will use the top 9 bits of the denominator as index.
+    //
+    //  The AVR assembly function is implementing the following C code, included
+    // here as reference:
+    //
+    // uint32_t get_period_inverse(uint32_t d) {
+    //  static const uint8_t inv_tab[256] = {
+    //    255,253,252,250,248,246,244,242,240,238,236,234,233,231,229,227,
+    //    225,224,222,220,218,217,215,213,212,210,208,207,205,203,202,200,
+    //    199,197,195,194,192,191,189,188,186,185,183,182,180,179,178,176,
+    //    175,173,172,170,169,168,166,165,164,162,161,160,158,157,156,154,
+    //    153,152,151,149,148,147,146,144,143,142,141,139,138,137,136,135,
+    //    134,132,131,130,129,128,127,126,125,123,122,121,120,119,118,117,
+    //    116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101,
+    //    100,99,98,97,96,95,94,93,92,91,90,89,88,88,87,86,
+    //    85,84,83,82,81,80,80,79,78,77,76,75,74,74,73,72,
+    //    71,70,70,69,68,67,66,66,65,64,63,62,62,61,60,59,
+    //    59,58,57,56,56,55,54,53,53,52,51,50,50,49,48,48,
+    //    47,46,46,45,44,43,43,42,41,41,40,39,39,38,37,37,
+    //    36,35,35,34,33,33,32,32,31,30,30,29,28,28,27,27,
+    //    26,25,25,24,24,23,22,22,21,21,20,19,19,18,18,17,
+    //    17,16,15,15,14,14,13,13,12,12,11,10,10,9,9,8,
+    //    8,7,7,6,6,5,5,4,4,3,3,2,2,1,0,0
+    //  };
+    //
+    //  // For small denominators, it is cheaper to directly store the result,
+    //  //  because those denominators would require 2 Newton-Raphson iterations
+    //  //  to converge to the required result precision. For bigger ones, just
+    //  //  ONE Newton-Raphson iteration is enough to get maximum precision!
+    //  static const uint32_t small_inv_tab[111] PROGMEM = {
+    //    16777216,16777216,8388608,5592405,4194304,3355443,2796202,2396745,2097152,1864135,1677721,1525201,1398101,1290555,1198372,1118481,
+    //    1048576,986895,932067,883011,838860,798915,762600,729444,699050,671088,645277,621378,599186,578524,559240,541200,
+    //    524288,508400,493447,479349,466033,453438,441505,430185,419430,409200,399457,390167,381300,372827,364722,356962,
+    //    349525,342392,335544,328965,322638,316551,310689,305040,299593,294337,289262,284359,279620,275036,270600,266305,
+    //    262144,258111,254200,250406,246723,243148,239674,236298,233016,229824,226719,223696,220752,217885,215092,212369,
+    //    209715,207126,204600,202135,199728,197379,195083,192841,190650,188508,186413,184365,182361,180400,178481,176602,
+    //    174762,172960,171196,169466,167772,166111,164482,162885,161319,159783,158275,156796,155344,153919,152520
+    //  };
+    //
+    //  // For small divisors, it is best to directly retrieve the results
+    //  if (d <= 110)
+    //    return pgm_read_dword(&small_inv_tab[d]);
+    //
+    //  // Compute initial estimation of 0x1000000/x -
+    //  // Get most significant bit set on divider
+    //  uint8_t idx = 0;
+    //  uint32_t nr = d;
+    //  if (!(nr & 0xff0000)) {
+    //    nr <<= 8;
+    //    idx += 8;
+    //    if (!(nr & 0xff0000)) {
+    //      nr <<= 8;
+    //      idx += 8;
+    //    }
+    //  }
+    //  if (!(nr & 0xf00000)) {
+    //    nr <<= 4;
+    //    idx += 4;
+    //  }
+    //  if (!(nr & 0xc00000)) {
+    //    nr <<= 2;
+    //    idx += 2;
+    //  }
+    //  if (!(nr & 0x800000)) {
+    //    nr <<= 1;
+    //    idx += 1;
+    //  }
+    //
+    //  // Isolate top 9 bits of the denominator, to be used as index into the initial estimation table
+    //  uint32_t tidx = nr >> 15;         // top 9 bits. bit8 is always set
+    //  uint32_t ie = inv_tab[tidx & 0xFF] + 256; // Get the table value. bit9 is always set
+    //  uint32_t x = idx <= 8 ? (ie >> (8 - idx)) : (ie << (idx - 8)); // Position the estimation at the proper place
+    //
+    //  // Now, refine estimation by newton-raphson. 1 iteration is enough
+    //  x = uint32_t((x * uint64_t((1 << 25) - x * d)) >> 24);
+    //
+    //  // Estimate remainder
+    //  uint32_t r = (1 << 24) - x * d;
+    //
+    //  // Check if we must adjust result
+    //  if (r >= d) x++;
+    //
+    //  // x holds the proper estimation
+    //  return uint32_t(x);
+    // }
+    //
+    static uint32_t get_period_inverse(uint32_t d) {
+
+       static const uint8_t inv_tab[256] PROGMEM = {
+        255,253,252,250,248,246,244,242,240,238,236,234,233,231,229,227,
+        225,224,222,220,218,217,215,213,212,210,208,207,205,203,202,200,
+        199,197,195,194,192,191,189,188,186,185,183,182,180,179,178,176,
+        175,173,172,170,169,168,166,165,164,162,161,160,158,157,156,154,
+        153,152,151,149,148,147,146,144,143,142,141,139,138,137,136,135,
+        134,132,131,130,129,128,127,126,125,123,122,121,120,119,118,117,
+        116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101,
+        100,99,98,97,96,95,94,93,92,91,90,89,88,88,87,86,
+        85,84,83,82,81,80,80,79,78,77,76,75,74,74,73,72,
+        71,70,70,69,68,67,66,66,65,64,63,62,62,61,60,59,
+        59,58,57,56,56,55,54,53,53,52,51,50,50,49,48,48,
+        47,46,46,45,44,43,43,42,41,41,40,39,39,38,37,37,
+        36,35,35,34,33,33,32,32,31,30,30,29,28,28,27,27,
+        26,25,25,24,24,23,22,22,21,21,20,19,19,18,18,17,
+        17,16,15,15,14,14,13,13,12,12,11,10,10,9,9,8,
+        8,7,7,6,6,5,5,4,4,3,3,2,2,1,0,0
+      };
+
+      // For small denominators, it is cheaper to directly store the result.
+      //  For bigger ones, just ONE Newton-Raphson iteration is enough to get
+      //  maximum precision we need
+      static const uint32_t small_inv_tab[111] PROGMEM = {
+        16777216,16777216,8388608,5592405,4194304,3355443,2796202,2396745,2097152,1864135,1677721,1525201,1398101,1290555,1198372,1118481,
+        1048576,986895,932067,883011,838860,798915,762600,729444,699050,671088,645277,621378,599186,578524,559240,541200,
+        524288,508400,493447,479349,466033,453438,441505,430185,419430,409200,399457,390167,381300,372827,364722,356962,
+        349525,342392,335544,328965,322638,316551,310689,305040,299593,294337,289262,284359,279620,275036,270600,266305,
+        262144,258111,254200,250406,246723,243148,239674,236298,233016,229824,226719,223696,220752,217885,215092,212369,
+        209715,207126,204600,202135,199728,197379,195083,192841,190650,188508,186413,184365,182361,180400,178481,176602,
+        174762,172960,171196,169466,167772,166111,164482,162885,161319,159783,158275,156796,155344,153919,152520
+      };
+
+      // For small divisors, it is best to directly retrieve the results
+      if (d <= 110)
+        return pgm_read_dword(&small_inv_tab[d]);
+
+      register uint8_t r8 = d & 0xFF;
+      register uint8_t r9 = (d >> 8) & 0xFF;
+      register uint8_t r10 = (d >> 16) & 0xFF;
+      register uint8_t r2,r3,r4,r5,r6,r7,r11,r12,r13,r14,r15,r16,r17,r18;
+      register const uint8_t* ptab = inv_tab;
+
+      __asm__ __volatile__(
+        /*  %8:%7:%6 = interval*/
+        /*  r31:r30: MUST be those registers, and they must point to the inv_tab */
+
+        " clr %13" "\n\t"                 /* %13 = 0 */
+
+        /*  Now we must compute */
+        /*   result = 0xFFFFFF / d */
+        /*  %8:%7:%6 = interval*/
+        /*  %16:%15:%14 = nr */
+        /*  %13 = 0*/
+
+        /*  A plain division of 24x24 bits should take 388 cycles to complete. We will */
+        /*  use Newton-Raphson for the calculation, and will strive to get way less cycles*/
+        /*  for the same result - Using C division, it takes 500cycles to complete .*/
+
+        " clr %3" "\n\t"                  /* idx = 0 */
+        " mov %14,%6" "\n\t"
+        " mov %15,%7" "\n\t"
+        " mov %16,%8" "\n\t"              /* nr = interval */
+        " tst %16" "\n\t"                 /* nr & 0xFF0000 == 0 ? */
+        " brne 2f" "\n\t"                 /* No, skip this */
+        " mov %16,%15" "\n\t"
+        " mov %15,%14" "\n\t"             /* nr <<= 8, %14 not needed */
+        " subi %3,-8" "\n\t"              /* idx += 8 */
+        " tst %16" "\n\t"                 /* nr & 0xFF0000 == 0 ? */
+        " brne 2f" "\n\t"                 /* No, skip this */
+        " mov %16,%15" "\n\t"             /* nr <<= 8, %14 not needed */
+        " clr %15" "\n\t"                 /* We clear %14 */
+        " subi %3,-8" "\n\t"              /* idx += 8 */
+
+        /*  here %16 != 0 and %16:%15 contains at least 9 MSBits, or both %16:%15 are 0 */
+        "2:" "\n\t"
+        " cpi %16,0x10" "\n\t"            /* (nr & 0xf00000) == 0 ? */
+        " brcc 3f" "\n\t"                 /* No, skip this */
+        " swap %15" "\n\t"                /* Swap nibbles */
+        " swap %16" "\n\t"                /* Swap nibbles. Low nibble is 0 */
+        " mov %14, %15" "\n\t"
+        " andi %14,0x0f" "\n\t"           /* Isolate low nibble */
+        " andi %15,0xf0" "\n\t"           /* Keep proper nibble in %15 */
+        " or %16, %14" "\n\t"             /* %16:%15 <<= 4 */
+        " subi %3,-4" "\n\t"              /* idx += 4 */
+
+        "3:" "\n\t"
+        " cpi %16,0x40" "\n\t"            /* (nr & 0xc00000) == 0 ? */
+        " brcc 4f" "\n\t"                 /* No, skip this*/
+        " add %15,%15" "\n\t"
+        " adc %16,%16" "\n\t"
+        " add %15,%15" "\n\t"
+        " adc %16,%16" "\n\t"             /* %16:%15 <<= 2 */
+        " subi %3,-2" "\n\t"              /* idx += 2 */
+
+        "4:" "\n\t"
+        " cpi %16,0x80" "\n\t"            /* (nr & 0x800000) == 0 ? */
+        " brcc 5f" "\n\t"                 /* No, skip this */
+        " add %15,%15" "\n\t"
+        " adc %16,%16" "\n\t"             /* %16:%15 <<= 1 */
+        " inc %3" "\n\t"                  /* idx += 1 */
+
+        /*  Now %16:%15 contains its MSBit set to 1, or %16:%15 is == 0. We are now absolutely sure*/
+        /*  we have at least 9 MSBits available to enter the initial estimation table*/
+        "5:" "\n\t"
+        " add %15,%15" "\n\t"
+        " adc %16,%16" "\n\t"             /* %16:%15 = tidx = (nr <<= 1), we lose the top MSBit (always set to 1, %16 is the index into the inverse table)*/
+        " add r30,%16" "\n\t"             /* Only use top 8 bits */
+        " adc r31,%13" "\n\t"             /* r31:r30 = inv_tab + (tidx) */
+        " lpm %14, Z" "\n\t"              /* %14 = inv_tab[tidx] */
+        " ldi %15, 1" "\n\t"              /* %15 = 1  %15:%14 = inv_tab[tidx] + 256 */
+
+        /*  We must scale the approximation to the proper place*/
+        " clr %16" "\n\t"                 /* %16 will always be 0 here */
+        " subi %3,8" "\n\t"               /* idx == 8 ? */
+        " breq 6f" "\n\t"                 /* yes, no need to scale*/
+        " brcs 7f" "\n\t"                 /* If C=1, means idx < 8, result was negative!*/
+
+        /*  idx > 8, now %3 = idx - 8. We must perform a left shift. idx range:[1-8]*/
+        " sbrs %3,0" "\n\t"               /* shift by 1bit position?*/
+        " rjmp 8f" "\n\t"                 /* No*/
+        " add %14,%14" "\n\t"
+        " adc %15,%15" "\n\t"             /* %15:16 <<= 1*/
+        "8:" "\n\t"
+        " sbrs %3,1" "\n\t"               /* shift by 2bit position?*/
+        " rjmp 9f" "\n\t"                 /* No*/
+        " add %14,%14" "\n\t"
+        " adc %15,%15" "\n\t"
+        " add %14,%14" "\n\t"
+        " adc %15,%15" "\n\t"             /* %15:16 <<= 1*/
+        "9:" "\n\t"
+        " sbrs %3,2" "\n\t"               /* shift by 4bits position?*/
+        " rjmp 16f" "\n\t"                /* No*/
+        " swap %15" "\n\t"                /* Swap nibbles. lo nibble of %15 will always be 0*/
+        " swap %14" "\n\t"                /* Swap nibbles*/
+        " mov %12,%14" "\n\t"
+        " andi %12,0x0f" "\n\t"           /* isolate low nibble*/
+        " andi %14,0xf0" "\n\t"           /* and clear it*/
+        " or %15,%12" "\n\t"              /* %15:%16 <<= 4*/
+        "16:" "\n\t"
+        " sbrs %3,3" "\n\t"               /* shift by 8bits position?*/
+        " rjmp 6f" "\n\t"                 /* No, we are done */
+        " mov %16,%15" "\n\t"
+        " mov %15,%14" "\n\t"
+        " clr %14" "\n\t"
+        " jmp 6f" "\n\t"
+
+        /*  idx < 8, now %3 = idx - 8. Get the count of bits */
+        "7:" "\n\t"
+        " neg %3" "\n\t"                  /* %3 = -idx = count of bits to move right. idx range:[1...8]*/
+        " sbrs %3,0" "\n\t"               /* shift by 1 bit position ?*/
+        " rjmp 10f" "\n\t"                /* No, skip it*/
+        " asr %15" "\n\t"                 /* (bit7 is always 0 here)*/
+        " ror %14" "\n\t"
+        "10:" "\n\t"
+        " sbrs %3,1" "\n\t"               /* shift by 2 bit position ?*/
+        " rjmp 11f" "\n\t"                /* No, skip it*/
+        " asr %15" "\n\t"                 /* (bit7 is always 0 here)*/
+        " ror %14" "\n\t"
+        " asr %15" "\n\t"                 /* (bit7 is always 0 here)*/
+        " ror %14" "\n\t"
+        "11:" "\n\t"
+        " sbrs %3,2" "\n\t"               /* shift by 4 bit position ?*/
+        " rjmp 12f" "\n\t"                /* No, skip it*/
+        " swap %15" "\n\t"                /* Swap nibbles*/
+        " andi %14, 0xf0" "\n\t"          /* Lose the lowest nibble*/
+        " swap %14" "\n\t"                /* Swap nibbles. Upper nibble is 0*/
+        " or %14,%15" "\n\t"              /* Pass nibble from upper byte*/
+        " andi %15, 0x0f" "\n\t"          /* And get rid of that nibble*/
+        "12:" "\n\t"
+        " sbrs %3,3" "\n\t"               /* shift by 8 bit position ?*/
+        " rjmp 6f" "\n\t"                 /* No, skip it*/
+        " mov %14,%15" "\n\t"
+        " clr %15" "\n\t"
+        "6:" "\n\t"                       /* %16:%15:%14 = initial estimation of 0x1000000 / d*/
+
+        /*  Now, we must refine the estimation present on %16:%15:%14 using 1 iteration*/
+        /*   of Newton-Raphson. As it has a quadratic convergence, 1 iteration is enough*/
+        /*   to get more than 18bits of precision (the initial table lookup gives 9 bits of*/
+        /*   precision to start from). 18bits of precision is all what is needed here for result */
+
+        /*  %8:%7:%6 = d = interval*/
+        /*  %16:%15:%14 = x = initial estimation of 0x1000000 / d*/
+        /*  %13 = 0*/
+        /*  %3:%2:%1:%0 = working accumulator*/
+
+        /*  Compute 1<<25 - x*d. Result should never exceed 25 bits and should always be positive*/
+        " clr %0" "\n\t"
+        " clr %1" "\n\t"
+        " clr %2" "\n\t"
+        " ldi %3,2" "\n\t"                /* %3:%2:%1:%0 = 0x2000000*/
+        " mul %6,%14" "\n\t"              /* r1:r0 = LO(d) * LO(x)*/
+        " sub %0,r0" "\n\t"
+        " sbc %1,r1" "\n\t"
+        " sbc %2,%13" "\n\t"
+        " sbc %3,%13" "\n\t"              /* %3:%2:%1:%0 -= LO(d) * LO(x)*/
+        " mul %7,%14" "\n\t"              /* r1:r0 = MI(d) * LO(x)*/
+        " sub %1,r0" "\n\t"
+        " sbc %2,r1"  "\n\t"
+        " sbc %3,%13" "\n\t"              /* %3:%2:%1:%0 -= MI(d) * LO(x) << 8*/
+        " mul %8,%14" "\n\t"              /* r1:r0 = HI(d) * LO(x)*/
+        " sub %2,r0" "\n\t"
+        " sbc %3,r1" "\n\t"               /* %3:%2:%1:%0 -= MIL(d) * LO(x) << 16*/
+        " mul %6,%15" "\n\t"              /* r1:r0 = LO(d) * MI(x)*/
+        " sub %1,r0" "\n\t"
+        " sbc %2,r1" "\n\t"
+        " sbc %3,%13" "\n\t"              /* %3:%2:%1:%0 -= LO(d) * MI(x) << 8*/
+        " mul %7,%15" "\n\t"              /* r1:r0 = MI(d) * MI(x)*/
+        " sub %2,r0" "\n\t"
+        " sbc %3,r1" "\n\t"               /* %3:%2:%1:%0 -= MI(d) * MI(x) << 16*/
+        " mul %8,%15" "\n\t"              /* r1:r0 = HI(d) * MI(x)*/
+        " sub %3,r0" "\n\t"               /* %3:%2:%1:%0 -= MIL(d) * MI(x) << 24*/
+        " mul %6,%16" "\n\t"              /* r1:r0 = LO(d) * HI(x)*/
+        " sub %2,r0" "\n\t"
+        " sbc %3,r1" "\n\t"               /* %3:%2:%1:%0 -= LO(d) * HI(x) << 16*/
+        " mul %7,%16" "\n\t"              /* r1:r0 = MI(d) * HI(x)*/
+        " sub %3,r0" "\n\t"               /* %3:%2:%1:%0 -= MI(d) * HI(x) << 24*/
+        /*  %3:%2:%1:%0 = (1<<25) - x*d     [169]*/
+
+        /*  We need to multiply that result by x, and we are only interested in the top 24bits of that multiply*/
+
+        /*  %16:%15:%14 = x = initial estimation of 0x1000000 / d*/
+        /*  %3:%2:%1:%0 = (1<<25) - x*d = acc*/
+        /*  %13 = 0 */
+
+        /*  result = %11:%10:%9:%5:%4*/
+        " mul %14,%0" "\n\t"              /* r1:r0 = LO(x) * LO(acc)*/
+        " mov %4,r1" "\n\t"
+        " clr %5" "\n\t"
+        " clr %9" "\n\t"
+        " clr %10" "\n\t"
+        " clr %11" "\n\t"                 /* %11:%10:%9:%5:%4 = LO(x) * LO(acc) >> 8*/
+        " mul %15,%0" "\n\t"              /* r1:r0 = MI(x) * LO(acc)*/
+        " add %4,r0" "\n\t"
+        " adc %5,r1" "\n\t"
+        " adc %9,%13" "\n\t"
+        " adc %10,%13" "\n\t"
+        " adc %11,%13" "\n\t"             /* %11:%10:%9:%5:%4 += MI(x) * LO(acc) */
+        " mul %16,%0" "\n\t"              /* r1:r0 = HI(x) * LO(acc)*/
+        " add %5,r0" "\n\t"
+        " adc %9,r1" "\n\t"
+        " adc %10,%13" "\n\t"
+        " adc %11,%13" "\n\t"             /* %11:%10:%9:%5:%4 += MI(x) * LO(acc) << 8*/
+
+        " mul %14,%1" "\n\t"              /* r1:r0 = LO(x) * MIL(acc)*/
+        " add %4,r0" "\n\t"
+        " adc %5,r1" "\n\t"
+        " adc %9,%13" "\n\t"
+        " adc %10,%13" "\n\t"
+        " adc %11,%13" "\n\t"             /* %11:%10:%9:%5:%4 = LO(x) * MIL(acc)*/
+        " mul %15,%1" "\n\t"              /* r1:r0 = MI(x) * MIL(acc)*/
+        " add %5,r0" "\n\t"
+        " adc %9,r1" "\n\t"
+        " adc %10,%13" "\n\t"
+        " adc %11,%13" "\n\t"             /* %11:%10:%9:%5:%4 += MI(x) * MIL(acc) << 8*/
+        " mul %16,%1" "\n\t"              /* r1:r0 = HI(x) * MIL(acc)*/
+        " add %9,r0" "\n\t"
+        " adc %10,r1" "\n\t"
+        " adc %11,%13" "\n\t"             /* %11:%10:%9:%5:%4 += MI(x) * MIL(acc) << 16*/
+
+        " mul %14,%2" "\n\t"              /* r1:r0 = LO(x) * MIH(acc)*/
+        " add %5,r0" "\n\t"
+        " adc %9,r1" "\n\t"
+        " adc %10,%13" "\n\t"
+        " adc %11,%13" "\n\t"             /* %11:%10:%9:%5:%4 = LO(x) * MIH(acc) << 8*/
+        " mul %15,%2" "\n\t"              /* r1:r0 = MI(x) * MIH(acc)*/
+        " add %9,r0" "\n\t"
+        " adc %10,r1" "\n\t"
+        " adc %11,%13" "\n\t"             /* %11:%10:%9:%5:%4 += MI(x) * MIH(acc) << 16*/
+        " mul %16,%2" "\n\t"              /* r1:r0 = HI(x) * MIH(acc)*/
+        " add %10,r0" "\n\t"
+        " adc %11,r1" "\n\t"              /* %11:%10:%9:%5:%4 += MI(x) * MIH(acc) << 24*/
+
+        " mul %14,%3" "\n\t"              /* r1:r0 = LO(x) * HI(acc)*/
+        " add %9,r0" "\n\t"
+        " adc %10,r1" "\n\t"
+        " adc %11,%13" "\n\t"             /* %11:%10:%9:%5:%4 = LO(x) * HI(acc) << 16*/
+        " mul %15,%3" "\n\t"              /* r1:r0 = MI(x) * HI(acc)*/
+        " add %10,r0" "\n\t"
+        " adc %11,r1" "\n\t"              /* %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 24*/
+        " mul %16,%3" "\n\t"              /* r1:r0 = HI(x) * HI(acc)*/
+        " add %11,r0" "\n\t"              /* %11:%10:%9:%5:%4 += MI(x) * HI(acc) << 32*/
+
+        /*  At this point, %11:%10:%9 contains the new estimation of x. */
+
+        /*  Finally, we must correct the result. Estimate remainder as*/
+        /*  (1<<24) - x*d*/
+        /*  %11:%10:%9 = x*/
+        /*  %8:%7:%6 = d = interval" "\n\t" /*  */
+        " ldi %3,1" "\n\t"
+        " clr %2" "\n\t"
+        " clr %1" "\n\t"
+        " clr %0" "\n\t"                  /* %3:%2:%1:%0 = 0x1000000*/
+        " mul %6,%9" "\n\t"              /* r1:r0 = LO(d) * LO(x)*/
+        " sub %0,r0" "\n\t"
+        " sbc %1,r1" "\n\t"
+        " sbc %2,%13" "\n\t"
+        " sbc %3,%13" "\n\t"              /* %3:%2:%1:%0 -= LO(d) * LO(x)*/
+        " mul %7,%9" "\n\t"              /* r1:r0 = MI(d) * LO(x)*/
+        " sub %1,r0" "\n\t"
+        " sbc %2,r1" "\n\t"
+        " sbc %3,%13" "\n\t"              /* %3:%2:%1:%0 -= MI(d) * LO(x) << 8*/
+        " mul %8,%9" "\n\t"              /* r1:r0 = HI(d) * LO(x)*/
+        " sub %2,r0" "\n\t"
+        " sbc %3,r1" "\n\t"               /* %3:%2:%1:%0 -= MIL(d) * LO(x) << 16*/
+        " mul %6,%10" "\n\t"              /* r1:r0 = LO(d) * MI(x)*/
+        " sub %1,r0" "\n\t"
+        " sbc %2,r1" "\n\t"
+        " sbc %3,%13" "\n\t"              /* %3:%2:%1:%0 -= LO(d) * MI(x) << 8*/
+        " mul %7,%10" "\n\t"              /* r1:r0 = MI(d) * MI(x)*/
+        " sub %2,r0" "\n\t"
+        " sbc %3,r1" "\n\t"               /* %3:%2:%1:%0 -= MI(d) * MI(x) << 16*/
+        " mul %8,%10" "\n\t"              /* r1:r0 = HI(d) * MI(x)*/
+        " sub %3,r0" "\n\t"               /* %3:%2:%1:%0 -= MIL(d) * MI(x) << 24*/
+        " mul %6,%11" "\n\t"              /* r1:r0 = LO(d) * HI(x)*/
+        " sub %2,r0" "\n\t"
+        " sbc %3,r1" "\n\t"               /* %3:%2:%1:%0 -= LO(d) * HI(x) << 16*/
+        " mul %7,%11" "\n\t"              /* r1:r0 = MI(d) * HI(x)*/
+        " sub %3,r0" "\n\t"               /* %3:%2:%1:%0 -= MI(d) * HI(x) << 24*/
+        /*  %3:%2:%1:%0 = r = (1<<24) - x*d*/
+        /*  %8:%7:%6 = d = interval */
+
+        /*  Perform the final correction*/
+        " sub %0,%6" "\n\t"
+        " sbc %1,%7" "\n\t"
+        " sbc %2,%8" "\n\t"              /* r -= d*/
+        " brcs 14f" "\n\t"                /* if ( r >= d) */
+
+        /*  %11:%10:%9 = x */
+        " ldi %3,1" "\n\t"
+        " add %9,%3" "\n\t"
+        " adc %10,%13" "\n\t"
+        " adc %11,%13" "\n\t"             /* x++*/
+        "14:" "\n\t"
+
+        /*  Estimation is done. %11:%10:%9 = x */
+        " clr __zero_reg__" "\n\t"        /* Make C runtime happy */
+        /*  [211 cycles total]*/
+        : "=r" (r2),
+          "=r" (r3),
+          "=r" (r4),
+          "=d" (r5),
+          "=r" (r6),
+          "=r" (r7),
+          "+r" (r8),
+          "+r" (r9),
+          "+r" (r10),
+          "=d" (r11),
+          "=r" (r12),
+          "=r" (r13),
+          "=d" (r14),
+          "=d" (r15),
+          "=d" (r16),
+          "=d" (r17),
+          "=d" (r18),
+          "+z" (ptab)
+        :
+        : "r0", "r1", "cc"
+      );
+
+      // Return the result
+      return r11 | (uint16_t(r12) << 8) | (uint32_t(r13) << 16);
+    }
+  #else
+    // All the other 32 CPUs can easily perform the inverse using hardware division,
+    // so we don¬¥t need to reduce precision or to use assembly language at all.
+
+    // This routine, for all the other archs, returns 0x100000000 / d ~= 0xFFFFFFFF / d
+    static FORCE_INLINE uint32_t get_period_inverse(uint32_t d) {
+      return 0xFFFFFFFF / d;
+    }
+  #endif
+#endif
+
 #define MINIMAL_STEP_RATE 120
 
 /**
  * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
  * by the provided factors.
  */
 void Planner::calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor) {
   uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
            final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
 
@@ -259,32 +780,39 @@ void Planner::calculate_trapezoid_for_block(block_t* const block, const float &e
   #if ENABLED(BEZIER_JERK_CONTROL)
     else // We have some plateau time, so the cruise rate will be the nominal rate
       cruise_rate = block->nominal_rate;
   #endif
 
   // block->accelerate_until = accelerate_steps;
   // block->decelerate_after = accelerate_steps+plateau_steps;
 
   #if ENABLED(BEZIER_JERK_CONTROL)
     // Jerk controlled speed requires to express speed versus time, NOT steps
-    int32_t acceleration_time = ((float)(cruise_rate - initial_rate) / accel) * HAL_STEPPER_TIMER_RATE,
-            deceleration_time = ((float)(cruise_rate - final_rate) / accel) * HAL_STEPPER_TIMER_RATE;
+    uint32_t acceleration_time = ((float)(cruise_rate - initial_rate) / accel) * HAL_STEPPER_TIMER_RATE,
+             deceleration_time = ((float)(cruise_rate - final_rate) / accel) * HAL_STEPPER_TIMER_RATE;
+
+    // And to offload calculations from the ISR, we also calculate the inverse of those times here
+    uint32_t acceleration_time_inverse = get_period_inverse(acceleration_time);
+    uint32_t deceleration_time_inverse = get_period_inverse(deceleration_time);
+
   #endif
 
   CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section
   if (!TEST(block->flag, BLOCK_BIT_BUSY)) { // Don't update variables if block is busy.
     block->accelerate_until = accelerate_steps;
     block->decelerate_after = accelerate_steps + plateau_steps;
     block->initial_rate = initial_rate;
     #if ENABLED(BEZIER_JERK_CONTROL)
       block->acceleration_time = acceleration_time;
       block->deceleration_time = deceleration_time;
+      block->acceleration_time_inverse = acceleration_time_inverse;
+      block->deceleration_time_inverse = deceleration_time_inverse;
       block->cruise_rate = cruise_rate;
     #endif
     block->final_rate = final_rate;
   }
   CRITICAL_SECTION_END;
 }
 
 // "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.
 // This method will calculate the junction jerk as the euclidean distance between the nominal
 // velocities of the respective blocks.

commit a29adde5c0706a572261c40a02c61e1c966928a4
Author: etagle <ejtagle@hotmail.com>
Date:   Fri Apr 6 22:48:06 2018 -0300

    Implement BEZIER_JERK_CONTROL
    
    Enable 6th-order jerk-controlled motion planning in real-time.
    Only for 32bit MCUs. (AVR simply does not have enough processing power for this!)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 3d0e871344..cd95bb04f9 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -222,47 +222,71 @@ void Planner::init() {
  * by the provided factors.
  */
 void Planner::calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor) {
   uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
            final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
 
   // Limit minimal step rate (Otherwise the timer will overflow.)
   NOLESS(initial_rate, MINIMAL_STEP_RATE);
   NOLESS(final_rate, MINIMAL_STEP_RATE);
 
+  #if ENABLED(BEZIER_JERK_CONTROL)
+    uint32_t cruise_rate = initial_rate;
+  #endif
+
   const int32_t accel = block->acceleration_steps_per_s2;
 
           // Steps required for acceleration, deceleration to/from nominal rate
   int32_t accelerate_steps = CEIL(estimate_acceleration_distance(initial_rate, block->nominal_rate, accel)),
           decelerate_steps = FLOOR(estimate_acceleration_distance(block->nominal_rate, final_rate, -accel)),
           // Steps between acceleration and deceleration, if any
           plateau_steps = block->step_event_count - accelerate_steps - decelerate_steps;
 
   // Does accelerate_steps + decelerate_steps exceed step_event_count?
   // Then we can't possibly reach the nominal rate, there will be no cruising.
   // Use intersection_distance() to calculate accel / braking time in order to
   // reach the final_rate exactly at the end of this block.
   if (plateau_steps < 0) {
     accelerate_steps = CEIL(intersection_distance(initial_rate, final_rate, accel, block->step_event_count));
     NOLESS(accelerate_steps, 0); // Check limits due to numerical round-off
     accelerate_steps = min((uint32_t)accelerate_steps, block->step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)
     plateau_steps = 0;
+
+    #if ENABLED(BEZIER_JERK_CONTROL)
+      // We won't reach the cruising rate. Let's calculate the speed we will reach
+      cruise_rate = final_speed(initial_rate, accel, accelerate_steps);
+    #endif
   }
+  #if ENABLED(BEZIER_JERK_CONTROL)
+    else // We have some plateau time, so the cruise rate will be the nominal rate
+      cruise_rate = block->nominal_rate;
+  #endif
 
   // block->accelerate_until = accelerate_steps;
   // block->decelerate_after = accelerate_steps+plateau_steps;
 
+  #if ENABLED(BEZIER_JERK_CONTROL)
+    // Jerk controlled speed requires to express speed versus time, NOT steps
+    int32_t acceleration_time = ((float)(cruise_rate - initial_rate) / accel) * HAL_STEPPER_TIMER_RATE,
+            deceleration_time = ((float)(cruise_rate - final_rate) / accel) * HAL_STEPPER_TIMER_RATE;
+  #endif
+
   CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section
   if (!TEST(block->flag, BLOCK_BIT_BUSY)) { // Don't update variables if block is busy.
     block->accelerate_until = accelerate_steps;
     block->decelerate_after = accelerate_steps + plateau_steps;
     block->initial_rate = initial_rate;
+    #if ENABLED(BEZIER_JERK_CONTROL)
+      block->acceleration_time = acceleration_time;
+      block->deceleration_time = deceleration_time;
+      block->cruise_rate = cruise_rate;
+    #endif
     block->final_rate = final_rate;
   }
   CRITICAL_SECTION_END;
 }
 
 // "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.
 // This method will calculate the junction jerk as the euclidean distance between the nominal
 // velocities of the respective blocks.
 //inline float junction_jerk(block_t *before, block_t *after) {
 //  return SQRT(
@@ -1296,21 +1320,23 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
     }
     else {
       LIMIT_ACCEL_FLOAT(A_AXIS, 0);
       LIMIT_ACCEL_FLOAT(B_AXIS, 0);
       LIMIT_ACCEL_FLOAT(C_AXIS, 0);
       LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
-  block->acceleration_rate = (long)(accel * (4096.0 * 4096.0 / (HAL_STEPPER_TIMER_RATE)));
+  #if DISABLED(BEZIER_JERK_CONTROL)
+    block->acceleration_rate = (long)(accel * (4096.0 * 4096.0 / (HAL_STEPPER_TIMER_RATE)));
+  #endif
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
       block->advance_speed = (HAL_STEPPER_TIMER_RATE) / (extruder_advance_K * block->e_D_ratio * block->acceleration * axis_steps_per_mm[E_AXIS_N]);
       #if ENABLED(LA_DEBUG)
         if (extruder_advance_K * block->e_D_ratio * block->acceleration * 2 < block->nominal_speed * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif
     }

commit e8e60263c8e454454d126f9154cf5c7ac3213725
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 5 15:47:56 2018 -0500

    Scale feedrate (mm/s to deg/s) for SCARA

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 04cfc2811e..3d0e871344 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -178,38 +178,41 @@ float Planner::previous_speed[NUM_AXIS],
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
   // Old direction bits. Used for speed calculations
   unsigned char Planner::old_direction_bits = 0;
   // Segment times (in ¬µs). Used for speed calculations
   uint32_t Planner::axis_segment_time_us[2][3] = { { MAX_FREQ_TIME_US + 1, 0, 0 }, { MAX_FREQ_TIME_US + 1, 0, 0 } };
 #endif
 
 #if ENABLED(LIN_ADVANCE)
-  float Planner::extruder_advance_K, // Initialized by settings.load()
-        Planner::position_float[XYZE]; // Needed for accurate maths. Steps cannot be used!
+  float Planner::extruder_advance_K; // Initialized by settings.load()
+#endif
+
+#if HAS_POSITION_FLOAT
+  float Planner::position_float[XYZE]; // Needed for accurate maths. Steps cannot be used!
 #endif
 
 #if ENABLED(ULTRA_LCD)
   volatile uint32_t Planner::block_buffer_runtime_us = 0;
 #endif
 
 /**
  * Class and Instance Methods
  */
 
 Planner::Planner() { init(); }
 
 void Planner::init() {
   block_buffer_head = block_buffer_tail = 0;
   ZERO(position);
-  #if ENABLED(LIN_ADVANCE)
+  #if HAS_POSITION_FLOAT
     ZERO(position_float);
   #endif
   ZERO(previous_speed);
   previous_nominal_speed = 0.0;
   #if ABL_PLANAR
     bed_level_matrix.set_to_identity();
   #endif
 }
 
 #define MINIMAL_STEP_RATE 120
@@ -738,21 +741,21 @@ void Planner::check_axes_activity() {
 /**
  * Planner::_buffer_steps
  *
  * Add a new linear movement to the buffer (in terms of steps).
  *
  *  target      - target position in steps units
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  */
 void Planner::_buffer_steps(const int32_t (&target)[XYZE]
-  #if ENABLED(LIN_ADVANCE)
+  #if HAS_POSITION_FLOAT
     , const float (&target_float)[XYZE]
   #endif
   , float fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
 ) {
 
   const int32_t da = target[A_AXIS] - position[A_AXIS],
                 db = target[B_AXIS] - position[B_AXIS],
                 dc = target[C_AXIS] - position[C_AXIS];
 
   int32_t de = target[E_AXIS] - position[E_AXIS];
@@ -768,32 +771,32 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
     SERIAL_ECHOPAIR(" steps) E:", target[E_AXIS]);
     SERIAL_ECHOPAIR(" (", de);
     SERIAL_ECHOLNPGM(" steps)");
   //*/
 
   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
-          #if ENABLED(LIN_ADVANCE)
+          #if HAS_POSITION_FLOAT
             position_float[E_AXIS] = target_float[E_AXIS];
           #endif
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
         if (labs(de * e_factor[extruder]) > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
-          #if ENABLED(LIN_ADVANCE)
+          #if HAS_POSITION_FLOAT
             position_float[E_AXIS] = target_float[E_AXIS];
           #endif
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
@@ -850,20 +853,24 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
     block->steps[B_AXIS] = labs(da - db);
     block->steps[Z_AXIS] = labs(dc);
   #elif CORE_IS_XZ
     block->steps[A_AXIS] = labs(da + dc);
     block->steps[Y_AXIS] = labs(db);
     block->steps[C_AXIS] = labs(da - dc);
   #elif CORE_IS_YZ
     block->steps[X_AXIS] = labs(da);
     block->steps[B_AXIS] = labs(db + dc);
     block->steps[C_AXIS] = labs(db - dc);
+  #elif IS_SCARA
+    block->steps[A_AXIS] = labs(da);
+    block->steps[B_AXIS] = labs(db);
+    block->steps[Z_AXIS] = labs(dc);
   #else
     // default non-h-bot planning
     block->steps[A_AXIS] = labs(da);
     block->steps[B_AXIS] = labs(db);
     block->steps[C_AXIS] = labs(dc);
   #endif
 
   block->steps[E_AXIS] = esteps;
   block->step_event_count = MAX4(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
 
@@ -885,21 +892,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
   block->active_extruder = extruder;
 
   #if ENABLED(AUTO_POWER_CONTROL)
     if (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS])
       powerManager.power_on();
   #endif
 
-  //enable active axes
+  // Enable active axes
   #if CORE_IS_XY
     if (block->steps[A_AXIS] || block->steps[B_AXIS]) {
       enable_X();
       enable_Y();
     }
     #if DISABLED(Z_LATE_ENABLE)
       if (block->steps[Z_AXIS]) enable_Z();
     #endif
   #elif CORE_IS_XZ
     if (block->steps[A_AXIS] || block->steps[C_AXIS]) {
@@ -1456,21 +1463,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
   COPY(previous_speed, current_speed);
   previous_nominal_speed = block->nominal_speed;
   previous_safe_speed = safe_speed;
 
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
   // Update the position (only when a move was queued)
   static_assert(COUNT(target) > 1, "Parameter to _buffer_steps must be (&target)[XYZE]!");
   COPY(position, target);
-  #if ENABLED(LIN_ADVANCE)
+  #if HAS_POSITION_FLOAT
     COPY(position_float, target_float);
   #endif
 
   recalculate();
 
 } // _buffer_steps()
 
 /**
  * Planner::buffer_segment
  *
@@ -1494,28 +1501,28 @@ void Planner::buffer_segment(const float &a, const float &b, const float &c, con
 
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
   const int32_t target[ABCE] = {
     LROUND(a * axis_steps_per_mm[A_AXIS]),
     LROUND(b * axis_steps_per_mm[B_AXIS]),
     LROUND(c * axis_steps_per_mm[C_AXIS]),
     LROUND(e * axis_steps_per_mm[E_AXIS_N])
   };
 
-  #if ENABLED(LIN_ADVANCE)
+  #if HAS_POSITION_FLOAT
     const float target_float[XYZE] = { a, b, c, e };
   #endif
 
   // DRYRUN prevents E moves from taking place
   if (DEBUGGING(DRYRUN)) {
     position[E_AXIS] = target[E_AXIS];
-    #if ENABLED(LIN_ADVANCE)
+    #if HAS_POSITION_FLOAT
       position_float[E_AXIS] = e;
     #endif
   }
 
   /* <-- add a slash to enable
     SERIAL_ECHOPAIR("  buffer_segment FR:", fr_mm_s);
     #if IS_KINEMATIC
       SERIAL_ECHOPAIR(" A:", a);
       SERIAL_ECHOPAIR(" (", position[A_AXIS]);
       SERIAL_ECHOPAIR("->", target[A_AXIS]);
@@ -1540,49 +1547,49 @@ void Planner::buffer_segment(const float &a, const float &b, const float &c, con
     SERIAL_ECHOPAIR("->", target[E_AXIS]);
     SERIAL_ECHOLNPGM(")");
   //*/
 
   // Always split the first move into two (if not homing or probing)
   if (!has_blocks_queued()) {
 
     #define _BETWEEN(A) (position[A##_AXIS] + target[A##_AXIS]) >> 1
     const int32_t between[ABCE] = { _BETWEEN(A), _BETWEEN(B), _BETWEEN(C), _BETWEEN(E) };
 
-    #if ENABLED(LIN_ADVANCE)
+    #if HAS_POSITION_FLOAT
       #define _BETWEEN_F(A) (position_float[A##_AXIS] + target_float[A##_AXIS]) * 0.5
       const float between_float[ABCE] = { _BETWEEN_F(A), _BETWEEN_F(B), _BETWEEN_F(C), _BETWEEN_F(E) };
     #endif
 
     DISABLE_STEPPER_DRIVER_INTERRUPT();
 
     _buffer_steps(between
-      #if ENABLED(LIN_ADVANCE)
+      #if HAS_POSITION_FLOAT
         , between_float
       #endif
       , fr_mm_s, extruder, millimeters * 0.5
     );
 
     const uint8_t next = block_buffer_head;
 
     _buffer_steps(target
-      #if ENABLED(LIN_ADVANCE)
+      #if HAS_POSITION_FLOAT
         , target_float
       #endif
       , fr_mm_s, extruder, millimeters * 0.5
     );
 
     SBI(block_buffer[next].flag, BLOCK_BIT_CONTINUED);
     ENABLE_STEPPER_DRIVER_INTERRUPT();
   }
   else
     _buffer_steps(target
-      #if ENABLED(LIN_ADVANCE)
+      #if HAS_POSITION_FLOAT
         , target_float
       #endif
       , fr_mm_s, extruder, millimeters
     );
 
   stepper.wake_up();
 
 } // buffer_segment()
 
 /**
@@ -1596,21 +1603,21 @@ void Planner::_set_position_mm(const float &a, const float &b, const float &c, c
   #if ENABLED(DISTINCT_E_FACTORS)
     #define _EINDEX (E_AXIS + active_extruder)
     last_extruder = active_extruder;
   #else
     #define _EINDEX E_AXIS
   #endif
   const int32_t na = position[A_AXIS] = LROUND(a * axis_steps_per_mm[A_AXIS]),
                 nb = position[B_AXIS] = LROUND(b * axis_steps_per_mm[B_AXIS]),
                 nc = position[C_AXIS] = LROUND(c * axis_steps_per_mm[C_AXIS]),
                 ne = position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
-  #if ENABLED(LIN_ADVANCE)
+  #if HAS_POSITION_FLOAT
     position_float[X_AXIS] = a;
     position_float[Y_AXIS] = b;
     position_float[Z_AXIS] = c;
     position_float[E_AXIS] = e;
   #endif
   stepper.set_position(na, nb, nc, ne);
   previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
   ZERO(previous_speed);
 }
 
@@ -1628,42 +1635,42 @@ void Planner::set_position_mm_kinematic(const float (&cart)[XYZE]) {
     _set_position_mm(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS]);
   #endif
 }
 
 /**
  * Sync from the stepper positions. (e.g., after an interrupted move)
  */
 void Planner::sync_from_steppers() {
   LOOP_XYZE(i) {
     position[i] = stepper.position((AxisEnum)i);
-    #if ENABLED(LIN_ADVANCE)
+    #if HAS_POSITION_FLOAT
       position_float[i] = position[i] * steps_to_mm[i
         #if ENABLED(DISTINCT_E_FACTORS)
           + (i == E_AXIS ? active_extruder : 0)
         #endif
       ];
     #endif
   }
 }
 
 /**
  * Setters for planner position (also setting stepper position).
  */
 void Planner::set_position_mm(const AxisEnum axis, const float &v) {
   #if ENABLED(DISTINCT_E_FACTORS)
     const uint8_t axis_index = axis + (axis == E_AXIS ? active_extruder : 0);
     last_extruder = active_extruder;
   #else
     const uint8_t axis_index = axis;
   #endif
   position[axis] = LROUND(v * axis_steps_per_mm[axis_index]);
-  #if ENABLED(LIN_ADVANCE)
+  #if HAS_POSITION_FLOAT
     position_float[axis] = v;
   #endif
   stepper.set_position(axis, v);
   previous_speed[axis] = 0.0;
 }
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define HIGHEST_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)

commit fe915143959129faf93b79bfcf9cf2a1f2e30a94
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 4 18:57:33 2018 -0500

    MBL should add z_offset regardless of fade (#10308)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7c8051770d..04cfc2811e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -651,93 +651,88 @@ void Planner::check_axes_activity() {
     #if ABL_PLANAR
 
       float dx = rx - (X_TILT_FULCRUM),
             dy = ry - (Y_TILT_FULCRUM);
 
       apply_rotation_xyz(bed_level_matrix, dx, dy, rz);
 
       rx = dx + X_TILT_FULCRUM;
       ry = dy + Y_TILT_FULCRUM;
 
-    #else
+    #elif HAS_MESH
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         const float fade_scaling_factor = fade_scaling_factor_for_z(rz);
-        if (!fade_scaling_factor) return;
-      #elif HAS_MESH
+      #else
         constexpr float fade_scaling_factor = 1.0;
       #endif
 
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
         const float raw[XYZ] = { rx, ry, 0 };
       #endif
 
       rz += (
-        #if ENABLED(AUTO_BED_LEVELING_UBL)
-          ubl.get_z_correction(rx, ry) * fade_scaling_factor
-        #elif ENABLED(MESH_BED_LEVELING)
+        #if ENABLED(MESH_BED_LEVELING)
           mbl.get_z(rx, ry
             #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
               , fade_scaling_factor
             #endif
           )
+        #elif ENABLED(AUTO_BED_LEVELING_UBL)
+          fade_scaling_factor ? fade_scaling_factor * ubl.get_z_correction(rx, ry) : 0.0
         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-          bilinear_z_offset(raw) * fade_scaling_factor
-        #else
-          0
+          fade_scaling_factor ? fade_scaling_factor * bilinear_z_offset(raw) : 0.0
         #endif
       );
 
     #endif
   }
 
   void Planner::unapply_leveling(float raw[XYZ]) {
 
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      const float fade_scaling_factor = fade_scaling_factor_for_z(raw[Z_AXIS]);
-    #else
-      constexpr float fade_scaling_factor = 1.0;
-    #endif
-
-    if (leveling_active && fade_scaling_factor) {
+    if (leveling_active) {
 
       #if ABL_PLANAR
 
         matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
 
         float dx = raw[X_AXIS] - (X_TILT_FULCRUM),
               dy = raw[Y_AXIS] - (Y_TILT_FULCRUM);
 
         apply_rotation_xyz(inverse, dx, dy, raw[Z_AXIS]);
 
         raw[X_AXIS] = dx + X_TILT_FULCRUM;
         raw[Y_AXIS] = dy + Y_TILT_FULCRUM;
 
-      #else // !ABL_PLANAR
+      #elif HAS_MESH
+
+        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+          const float fade_scaling_factor = fade_scaling_factor_for_z(raw[Z_AXIS]);
+        #else
+          constexpr float fade_scaling_factor = 1.0;
+        #endif
 
         raw[Z_AXIS] -= (
-          #if ENABLED(AUTO_BED_LEVELING_UBL)
-            ubl.get_z_correction(raw[X_AXIS], raw[Y_AXIS]) * fade_scaling_factor
-          #elif ENABLED(MESH_BED_LEVELING)
+          #if ENABLED(MESH_BED_LEVELING)
             mbl.get_z(raw[X_AXIS], raw[Y_AXIS]
               #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
                 , fade_scaling_factor
               #endif
             )
+          #elif ENABLED(AUTO_BED_LEVELING_UBL)
+            fade_scaling_factor ? fade_scaling_factor * ubl.get_z_correction(raw[X_AXIS], raw[Y_AXIS]) : 0.0
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-            bilinear_z_offset(raw) * fade_scaling_factor
-          #else
-            0
+            fade_scaling_factor ? fade_scaling_factor * bilinear_z_offset(raw) : 0.0
           #endif
         );
 
-      #endif // !ABL_PLANAR
+      #endif
     }
 
     #if ENABLED(SKEW_CORRECTION)
       unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]);
     #endif
   }
 
 #endif // PLANNER_LEVELING
 
 /**

commit ac7e97f4feb8310681a330d757d414c132e6563a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 30 15:07:11 2018 -0500

    Change order of inactive stepper disable/enable
    
    This ensures that steppers that share an enable pin will only be disabled for a miniscule time.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index f00798d992..7c8051770d 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -932,90 +932,90 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
       powerManager.power_on();
     #endif
 
     #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
       #define DISABLE_IDLE_E(N) if (!g_uc_extruder_last_move[N]) disable_E##N();
 
       for (uint8_t i = 0; i < EXTRUDERS; i++)
         if (g_uc_extruder_last_move[i] > 0) g_uc_extruder_last_move[i]--;
 
-      switch(extruder) {
+      switch (extruder) {
         case 0:
-          enable_E0();
-          g_uc_extruder_last_move[0] = (BLOCK_BUFFER_SIZE) * 2;
-          #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
-            if (extruder_duplication_enabled) {
-              enable_E1();
-              g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
-            }
-          #endif
           #if EXTRUDERS > 1
             DISABLE_IDLE_E(1);
             #if EXTRUDERS > 2
               DISABLE_IDLE_E(2);
               #if EXTRUDERS > 3
                 DISABLE_IDLE_E(3);
                 #if EXTRUDERS > 4
                   DISABLE_IDLE_E(4);
                 #endif // EXTRUDERS > 4
               #endif // EXTRUDERS > 3
             #endif // EXTRUDERS > 2
           #endif // EXTRUDERS > 1
+          enable_E0();
+          g_uc_extruder_last_move[0] = (BLOCK_BUFFER_SIZE) * 2;
+          #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+            if (extruder_duplication_enabled) {
+              enable_E1();
+              g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
+            }
+          #endif
         break;
         #if EXTRUDERS > 1
           case 1:
-            enable_E1();
-            g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
             DISABLE_IDLE_E(0);
             #if EXTRUDERS > 2
               DISABLE_IDLE_E(2);
               #if EXTRUDERS > 3
                 DISABLE_IDLE_E(3);
                 #if EXTRUDERS > 4
                   DISABLE_IDLE_E(4);
                 #endif // EXTRUDERS > 4
               #endif // EXTRUDERS > 3
             #endif // EXTRUDERS > 2
+            enable_E1();
+            g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
           break;
           #if EXTRUDERS > 2
             case 2:
-              enable_E2();
-              g_uc_extruder_last_move[2] = (BLOCK_BUFFER_SIZE) * 2;
               DISABLE_IDLE_E(0);
               DISABLE_IDLE_E(1);
               #if EXTRUDERS > 3
                 DISABLE_IDLE_E(3);
                 #if EXTRUDERS > 4
                   DISABLE_IDLE_E(4);
                 #endif
               #endif
+              enable_E2();
+              g_uc_extruder_last_move[2] = (BLOCK_BUFFER_SIZE) * 2;
             break;
             #if EXTRUDERS > 3
               case 3:
-                enable_E3();
-                g_uc_extruder_last_move[3] = (BLOCK_BUFFER_SIZE) * 2;
                 DISABLE_IDLE_E(0);
                 DISABLE_IDLE_E(1);
                 DISABLE_IDLE_E(2);
                 #if EXTRUDERS > 4
                   DISABLE_IDLE_E(4);
                 #endif
+                enable_E3();
+                g_uc_extruder_last_move[3] = (BLOCK_BUFFER_SIZE) * 2;
               break;
               #if EXTRUDERS > 4
                 case 4:
-                  enable_E4();
-                  g_uc_extruder_last_move[4] = (BLOCK_BUFFER_SIZE) * 2;
                   DISABLE_IDLE_E(0);
                   DISABLE_IDLE_E(1);
                   DISABLE_IDLE_E(2);
                   DISABLE_IDLE_E(3);
+                  enable_E4();
+                  g_uc_extruder_last_move[4] = (BLOCK_BUFFER_SIZE) * 2;
                 break;
               #endif // EXTRUDERS > 4
             #endif // EXTRUDERS > 3
           #endif // EXTRUDERS > 2
         #endif // EXTRUDERS > 1
       }
     #else
       enable_E0();
       enable_E1();
       enable_E2();

commit 1cb810ff1c04065daa29182a6c22ecf6b0c0098b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 21 19:30:06 2018 -0500

    [2.0.x] Automatically reset stepper timeout (#10179)
    
    * Automatically reset stepper timeout in manage_inactivity
    
    Any code that adds moves to the planner can skip resetting the stepper timeout. We can let `idle` / `manage_inactivity` reset the timer whenever it detects any moves in the planner.
    
    * blocks_queued => has_blocks_queued

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 602e4691d1..f00798d992 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -461,21 +461,21 @@ void Planner::check_axes_activity() {
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       uint8_t tail_valve_pressure;
     #endif
     #if HAS_HEATER_2
       uint8_t tail_e_to_p_pressure;
     #endif
   #endif
 
-  if (blocks_queued()) {
+  if (has_blocks_queued()) {
 
     #if FAN_COUNT > 0
       for (uint8_t i = 0; i < FAN_COUNT; i++)
         tail_fan_speed[i] = block_buffer[block_buffer_tail].fan_speed[i];
     #endif
 
     block_t* block;
 
     #if ENABLED(BARICUDA)
       block = &block_buffer[block_buffer_tail];
@@ -1540,21 +1540,21 @@ void Planner::buffer_segment(const float &a, const float &b, const float &c, con
     #endif
     SERIAL_ECHOPAIR(" (", position[Z_AXIS]);
     SERIAL_ECHOPAIR("->", target[Z_AXIS]);
     SERIAL_ECHOPAIR(") E:", e);
     SERIAL_ECHOPAIR(" (", position[E_AXIS]);
     SERIAL_ECHOPAIR("->", target[E_AXIS]);
     SERIAL_ECHOLNPGM(")");
   //*/
 
   // Always split the first move into two (if not homing or probing)
-  if (!blocks_queued()) {
+  if (!has_blocks_queued()) {
 
     #define _BETWEEN(A) (position[A##_AXIS] + target[A##_AXIS]) >> 1
     const int32_t between[ABCE] = { _BETWEEN(A), _BETWEEN(B), _BETWEEN(C), _BETWEEN(E) };
 
     #if ENABLED(LIN_ADVANCE)
       #define _BETWEEN_F(A) (position_float[A##_AXIS] + target_float[A##_AXIS]) * 0.5
       const float between_float[ABCE] = { _BETWEEN_F(A), _BETWEEN_F(B), _BETWEEN_F(C), _BETWEEN_F(E) };
     #endif
 
     DISABLE_STEPPER_DRIVER_INTERRUPT();

commit 3c2bfa5e533b9f1d659baec30770f6e274cb539e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 8 18:56:47 2018 -0600

    Update powersupply_on in power_on/off (#10015)
    
    Fix #10004

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index fdee276d3f..602e4691d1 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -887,21 +887,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
   block->active_extruder = extruder;
 
   #if ENABLED(AUTO_POWER_CONTROL)
     if (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS])
-        powerManager.power_on();
+      powerManager.power_on();
   #endif
 
   //enable active axes
   #if CORE_IS_XY
     if (block->steps[A_AXIS] || block->steps[B_AXIS]) {
       enable_X();
       enable_Y();
     }
     #if DISABLED(Z_LATE_ENABLE)
       if (block->steps[Z_AXIS]) enable_Z();

commit 930720bbbb7ba69df066684cf598583fd6c49ab9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 4 21:19:06 2018 -0600

    Fix broken reverse planner (#9943)
    
    From #9914 by @Sebastianv650

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 0aa76d0240..fdee276d3f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -282,32 +282,40 @@ void Planner::reverse_pass_kernel(block_t* const current, const block_t * const
       : min(max_entry_speed, max_allowable_speed(-current->acceleration, next->entry_speed, current->millimeters));
     SBI(current->flag, BLOCK_BIT_RECALCULATE);
   }
 }
 
 /**
  * recalculate() needs to go over the current plan twice.
  * Once in reverse and once forward. This implements the reverse pass.
  */
 void Planner::reverse_pass() {
-  if (movesplanned() > 3) {
-    const uint8_t endnr = BLOCK_MOD(block_buffer_tail + 2); // tail is running. tail+1 shouldn't be altered because it's connected to the running block.
-                                                            // tail+2 because the index is not yet advanced when checked
+  if (movesplanned() > 2) {
+    const uint8_t endnr = BLOCK_MOD(block_buffer_tail + 1); // tail is running. tail+1 shouldn't be altered because it's connected to the running block.
     uint8_t blocknr = prev_block_index(block_buffer_head);
     block_t* current = &block_buffer[blocknr];
 
+    // Last/newest block in buffer:
+    const float max_entry_speed = current->max_entry_speed;
+    if (current->entry_speed != max_entry_speed) {
+      // If nominal length true, max junction speed is guaranteed to be reached. Only compute
+      // for max allowable speed if block is decelerating and nominal length is false.
+      current->entry_speed = TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH)
+        ? max_entry_speed
+        : min(max_entry_speed, max_allowable_speed(-current->acceleration, MINIMUM_PLANNER_SPEED, current->millimeters));
+      SBI(current->flag, BLOCK_BIT_RECALCULATE);
+    }
+
     do {
       const block_t * const next = current;
       blocknr = prev_block_index(blocknr);
       current = &block_buffer[blocknr];
-      if (TEST(current->flag, BLOCK_BIT_START_FROM_FULL_HALT)) // Up to this every block is already optimized.
-        break;
       reverse_pass_kernel(current, next);
     } while (blocknr != endnr);
   }
 }
 
 // The kernel called by recalculate() when scanning the plan from first to last entry.
 void Planner::forward_pass_kernel(const block_t * const previous, block_t* const current) {
   if (!previous) return;
 
   // If the previous block is an acceleration block, but it is not long enough to complete the
@@ -913,21 +921,20 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
   #else
     if (block->steps[X_AXIS]) enable_X();
     if (block->steps[Y_AXIS]) enable_Y();
     #if DISABLED(Z_LATE_ENABLE)
       if (block->steps[Z_AXIS]) enable_Z();
     #endif
   #endif
 
   // Enable extruder(s)
   if (esteps) {
-
     #if ENABLED(AUTO_POWER_CONTROL)
       powerManager.power_on();
     #endif
 
     #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
       #define DISABLE_IDLE_E(N) if (!g_uc_extruder_last_move[N]) disable_E##N();
 
       for (uint8_t i = 0; i < EXTRUDERS; i++)
         if (g_uc_extruder_last_move[i] > 0) g_uc_extruder_last_move[i]--;
@@ -1418,31 +1425,25 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
 
       if (jerk > max_jerk[axis]) {
         v_factor *= max_jerk[axis] / jerk;
         ++limited;
       }
     }
     if (limited) vmax_junction *= v_factor;
     // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
     // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
     const float vmax_junction_threshold = vmax_junction * 0.99f;
-    if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold) {
-      // Not coasting. The machine will stop and start the movements anyway,
-      // better to start the segment from start.
-      SBI(block->flag, BLOCK_BIT_START_FROM_FULL_HALT);
+    if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold)
       vmax_junction = safe_speed;
-    }
   }
-  else {
-    SBI(block->flag, BLOCK_BIT_START_FROM_FULL_HALT);
+  else
     vmax_junction = safe_speed;
-  }
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed = vmax_junction;
 
   // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
   const float v_allowable = max_allowable_speed(-block->acceleration, MINIMUM_PLANNER_SPEED, block->millimeters);
   // If stepper ISR is disabled, this indicates buffer_segment wants to add a split block.
   // In this case start with the max. allowed speed to avoid an interrupted first move.
   block->entry_speed = STEPPER_ISR_ENABLED() ? MINIMUM_PLANNER_SPEED : min(vmax_junction, v_allowable);
 

commit d1dc863962f94a09bd8443657b559ade1a2f5614
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 3 23:27:02 2018 -0600

    autotemp_factor is not value_celsius_diff
    
    See https://github.com/MarlinFirmware/Marlin/issues/9852#issuecomment-369861822

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index cb8f3ea99e..0aa76d0240 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1685,17 +1685,16 @@ void Planner::reset_acceleration_rates() {
 // Recalculate position, steps_to_mm if axis_steps_per_mm changes!
 void Planner::refresh_positioning() {
   LOOP_XYZE_N(i) steps_to_mm[i] = 1.0 / axis_steps_per_mm[i];
   set_position_mm_kinematic(current_position);
   reset_acceleration_rates();
 }
 
 #if ENABLED(AUTOTEMP)
 
   void Planner::autotemp_M104_M109() {
-    autotemp_enabled = parser.seen('F');
-    if (autotemp_enabled) autotemp_factor = parser.value_celsius_diff();
+    if ((autotemp_enabled = parser.seen('F'))) autotemp_factor = parser.value_float();
     if (parser.seen('S')) autotemp_min = parser.value_celsius();
     if (parser.seen('B')) autotemp_max = parser.value_celsius();
   }
 
 #endif

commit 689bc994029c2029b094213bfeef66c763a42ba5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 24 11:09:19 2018 -0600

    Correction to acceleration

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index edac7b9111..cb8f3ea99e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1287,24 +1287,24 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE]
     }
     else {
       LIMIT_ACCEL_FLOAT(A_AXIS, 0);
       LIMIT_ACCEL_FLOAT(B_AXIS, 0);
       LIMIT_ACCEL_FLOAT(C_AXIS, 0);
       LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
-  block->acceleration_rate = (long)(accel * 16777216.0 / ((F_CPU) * 0.125)); // * 8.388608
+  block->acceleration_rate = (long)(accel * (4096.0 * 4096.0 / (HAL_STEPPER_TIMER_RATE)));
   #if ENABLED(LIN_ADVANCE)
     if (block->use_advance_lead) {
-      block->advance_speed = ((F_CPU) * 0.125) / (extruder_advance_K * block->e_D_ratio * block->acceleration * axis_steps_per_mm[E_AXIS_N]);
+      block->advance_speed = (HAL_STEPPER_TIMER_RATE) / (extruder_advance_K * block->e_D_ratio * block->acceleration * axis_steps_per_mm[E_AXIS_N]);
       #if ENABLED(LA_DEBUG)
         if (extruder_advance_K * block->e_D_ratio * block->acceleration * 2 < block->nominal_speed * block->e_D_ratio)
           SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
         if (block->advance_speed < 200)
           SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
       #endif
     }
   #endif
 
   // Initial limit on the segment entry velocity

commit 2bd252b50149c860cf37d488762abcf70a83f78d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Feb 23 00:53:29 2018 -0600

    [2.0.x] LIN_ADVANCE v1.5 (#9712)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e06b0f43f5..edac7b9111 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -178,25 +178,22 @@ float Planner::previous_speed[NUM_AXIS],
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
   // Old direction bits. Used for speed calculations
   unsigned char Planner::old_direction_bits = 0;
   // Segment times (in ¬µs). Used for speed calculations
   uint32_t Planner::axis_segment_time_us[2][3] = { { MAX_FREQ_TIME_US + 1, 0, 0 }, { MAX_FREQ_TIME_US + 1, 0, 0 } };
 #endif
 
 #if ENABLED(LIN_ADVANCE)
-  float Planner::extruder_advance_k, // Initialized by settings.load()
-        Planner::advance_ed_ratio,   // Initialized by settings.load()
-        Planner::position_float[XYZE], // Needed for accurate maths. Steps cannot be used!
-        Planner::lin_dist_xy,
-        Planner::lin_dist_e;
+  float Planner::extruder_advance_K, // Initialized by settings.load()
+        Planner::position_float[XYZE]; // Needed for accurate maths. Steps cannot be used!
 #endif
 
 #if ENABLED(ULTRA_LCD)
   volatile uint32_t Planner::block_buffer_runtime_us = 0;
 #endif
 
 /**
  * Class and Instance Methods
  */
 
@@ -357,29 +354,43 @@ void Planner::recalculate_trapezoids() {
 
   while (block_index != block_buffer_head) {
     current = next;
     next = &block_buffer[block_index];
     if (current) {
       // Recalculate if current block entry or exit junction speed has changed.
       if (TEST(current->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
         // NOTE: Entry and exit factors always > 0 by all previous logic operations.
         const float nomr = 1.0 / current->nominal_speed;
         calculate_trapezoid_for_block(current, current->entry_speed * nomr, next->entry_speed * nomr);
+        #if ENABLED(LIN_ADVANCE)
+          if (current->use_advance_lead) {
+            const float comp = current->e_D_ratio * extruder_advance_K * axis_steps_per_mm[E_AXIS];
+            current->max_adv_steps = current->nominal_speed * comp;
+            current->final_adv_steps = next->entry_speed * comp;
+          }
+        #endif
         CBI(current->flag, BLOCK_BIT_RECALCULATE); // Reset current only to ensure next trapezoid is computed
       }
     }
     block_index = next_block_index(block_index);
   }
   // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
   if (next) {
     const float nomr = 1.0 / next->nominal_speed;
     calculate_trapezoid_for_block(next, next->entry_speed * nomr, (MINIMUM_PLANNER_SPEED) * nomr);
+    #if ENABLED(LIN_ADVANCE)
+      if (next->use_advance_lead) {
+        const float comp = next->e_D_ratio * extruder_advance_K * axis_steps_per_mm[E_AXIS];
+        next->max_adv_steps = next->nominal_speed * comp;
+        next->final_adv_steps = (MINIMUM_PLANNER_SPEED) * comp;
+      }
+    #endif
     CBI(next->flag, BLOCK_BIT_RECALCULATE);
   }
 }
 
 /**
  * Recalculate the motion plan according to the following algorithm:
  *
  *   1. Go over every block in reverse order...
  *
  *      Calculate a junction speed reduction (block_t.entry_factor) so:
@@ -723,63 +734,72 @@ void Planner::check_axes_activity() {
 
 /**
  * Planner::_buffer_steps
  *
  * Add a new linear movement to the buffer (in terms of steps).
  *
  *  target      - target position in steps units
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  */
-void Planner::_buffer_steps(const int32_t (&target)[ABCE], float fr_mm_s, const uint8_t extruder, const float &millimeters /*= 0.0*/) {
+void Planner::_buffer_steps(const int32_t (&target)[XYZE]
+  #if ENABLED(LIN_ADVANCE)
+    , const float (&target_float)[XYZE]
+  #endif
+  , float fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/
+) {
 
   const int32_t da = target[A_AXIS] - position[A_AXIS],
                 db = target[B_AXIS] - position[B_AXIS],
                 dc = target[C_AXIS] - position[C_AXIS];
 
   int32_t de = target[E_AXIS] - position[E_AXIS];
 
   /* <-- add a slash to enable
     SERIAL_ECHOPAIR("  _buffer_steps FR:", fr_mm_s);
     SERIAL_ECHOPAIR(" A:", target[A_AXIS]);
     SERIAL_ECHOPAIR(" (", da);
     SERIAL_ECHOPAIR(" steps) B:", target[B_AXIS]);
     SERIAL_ECHOPAIR(" (", db);
     SERIAL_ECHOPAIR(" steps) C:", target[C_AXIS]);
     SERIAL_ECHOPAIR(" (", dc);
     SERIAL_ECHOPAIR(" steps) E:", target[E_AXIS]);
     SERIAL_ECHOPAIR(" (", de);
     SERIAL_ECHOLNPGM(" steps)");
   //*/
 
-  // If LIN_ADVANCE is disabled then do E move prevention with integers
-  // Otherwise it's done in _buffer_segment.
-  #if DISABLED(LIN_ADVANCE) && (ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE))
+  #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
+          #if ENABLED(LIN_ADVANCE)
+            position_float[E_AXIS] = target_float[E_AXIS];
+          #endif
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
         if (labs(de * e_factor[extruder]) > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
+          #if ENABLED(LIN_ADVANCE)
+            position_float[E_AXIS] = target_float[E_AXIS];
+          #endif
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
-  #endif // !LIN_ADVANCE && (PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE)
+  #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   // Compute direction bit-mask for this block
   uint8_t dm = 0;
   #if CORE_IS_XY
     if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
     if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
     if (dc < 0) SBI(dm, Z_AXIS);
     if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
     if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
   #elif CORE_IS_XZ
@@ -1182,39 +1202,83 @@ void Planner::_buffer_steps(const int32_t (&target)[ABCE], float fr_mm_s, const
     block->nominal_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
   if (!block->steps[A_AXIS] && !block->steps[B_AXIS] && !block->steps[C_AXIS]) {
     // convert to: acceleration steps/sec^2
     accel = CEIL(retract_acceleration * steps_per_mm);
+    #if ENABLED(LIN_ADVANCE)
+      block->use_advance_lead = false;
+    #endif
   }
   else {
     #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
         const uint32_t comp = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count; \
         if (accel * block->steps[AXIS] > comp) accel = comp / block->steps[AXIS]; \
       } \
     }while(0)
 
     #define LIMIT_ACCEL_FLOAT(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
         const float comp = (float)max_acceleration_steps_per_s2[AXIS+INDX] * (float)block->step_event_count; \
         if ((float)accel * (float)block->steps[AXIS] > comp) accel = comp / (float)block->steps[AXIS]; \
       } \
     }while(0)
 
     // Start with print or travel acceleration
     accel = CEIL((esteps ? acceleration : travel_acceleration) * steps_per_mm);
 
+    #if ENABLED(LIN_ADVANCE)
+      /**
+       *
+       * Use LIN_ADVANCE for blocks if all these are true:
+       *
+       * esteps             : This is a print move, because we checked for A, B, C steps before.
+       *
+       * extruder_advance_K : There is an advance factor set.
+       *
+       * de > 0             : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
+       */
+      block->use_advance_lead =  esteps
+                              && extruder_advance_K
+                              && de > 0;
+
+      if (block->use_advance_lead) {
+        block->e_D_ratio = (target_float[E_AXIS] - position_float[E_AXIS]) /
+          #if IS_KINEMATIC
+            block->millimeters
+          #else
+            SQRT(sq(target_float[X_AXIS] - position_float[X_AXIS])
+               + sq(target_float[Y_AXIS] - position_float[Y_AXIS])
+               + sq(target_float[Z_AXIS] - position_float[Z_AXIS]))
+          #endif
+        ;
+
+        // Check for unusual high e_D ratio to detect if a retract move was combined with the last print move due to min. steps per segment. Never execute this with advance!
+        // This assumes no one will use a retract length of 0mm < retr_length < ~0.2mm and no one will print 100mm wide lines using 3mm filament or 35mm wide lines using 1.75mm filament.
+        if (block->e_D_ratio > 3.0)
+          block->use_advance_lead = false;
+        else {
+          const uint32_t max_accel_steps_per_s2 = max_jerk[E_AXIS] / (extruder_advance_K * block->e_D_ratio) * steps_per_mm;
+          #if ENABLED(LA_DEBUG)
+            if (accel > max_accel_steps_per_s2)
+              SERIAL_ECHOLNPGM("Acceleration limited.");
+          #endif
+          NOMORE(accel, max_accel_steps_per_s2);
+        }
+      }
+    #endif
+
     #if ENABLED(DISTINCT_E_FACTORS)
       #define ACCEL_IDX extruder
     #else
       #define ACCEL_IDX 0
     #endif
 
     // Limit acceleration per axis
     if (block->step_event_count <= cutoff_long) {
       LIMIT_ACCEL_LONG(A_AXIS, 0);
       LIMIT_ACCEL_LONG(B_AXIS, 0);
@@ -1223,21 +1287,32 @@ void Planner::_buffer_steps(const int32_t (&target)[ABCE], float fr_mm_s, const
     }
     else {
       LIMIT_ACCEL_FLOAT(A_AXIS, 0);
       LIMIT_ACCEL_FLOAT(B_AXIS, 0);
       LIMIT_ACCEL_FLOAT(C_AXIS, 0);
       LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
-  block->acceleration_rate = (long)(accel * 16777216.0 / (HAL_STEPPER_TIMER_RATE)); // 16777216 = <<24
+  block->acceleration_rate = (long)(accel * 16777216.0 / ((F_CPU) * 0.125)); // * 8.388608
+  #if ENABLED(LIN_ADVANCE)
+    if (block->use_advance_lead) {
+      block->advance_speed = ((F_CPU) * 0.125) / (extruder_advance_K * block->e_D_ratio * block->acceleration * axis_steps_per_mm[E_AXIS_N]);
+      #if ENABLED(LA_DEBUG)
+        if (extruder_advance_K * block->e_D_ratio * block->acceleration * 2 < block->nominal_speed * block->e_D_ratio)
+          SERIAL_ECHOLNPGM("More than 2 steps per eISR loop executed.");
+        if (block->advance_speed < 200)
+          SERIAL_ECHOLNPGM("eISR running at > 10kHz.");
+      #endif
+    }
+  #endif
 
   // Initial limit on the segment entry velocity
   float vmax_junction;
 
   #if 0  // Use old jerk for now
 
     float junction_deviation = 0.1;
 
     // Compute path unit vector
     double unit_vec[XYZ] = {
@@ -1379,90 +1454,76 @@ void Planner::_buffer_steps(const int32_t (&target)[ABCE], float fr_mm_s, const
   // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
   block->flag |= block->nominal_speed <= v_allowable ? BLOCK_FLAG_RECALCULATE | BLOCK_FLAG_NOMINAL_LENGTH : BLOCK_FLAG_RECALCULATE;
 
   // Update previous path unit_vector and nominal speed
   COPY(previous_speed, current_speed);
   previous_nominal_speed = block->nominal_speed;
   previous_safe_speed = safe_speed;
 
-  #if ENABLED(LIN_ADVANCE)
-    /**
-     *
-     * Use LIN_ADVANCE for blocks if all these are true:
-     *
-     * esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS]) : This is a print move
-     *
-     * extruder_advance_k                 : There is an advance factor set.
-     *
-     * esteps != block->step_event_count  : A problem occurs if the move before a retract is too small.
-     *                                      In that case, the retract and move will be executed together.
-     *                                      This leads to too many advance steps due to a huge e_acceleration.
-     *                                      The math is good, but we must avoid retract moves with advance!
-     * lin_dist_e > 0                       : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
-     */
-    block->use_advance_lead =  esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS])
-                            && extruder_advance_k
-                            && (uint32_t)esteps != block->step_event_count
-                            && lin_dist_e > 0;
-    if (block->use_advance_lead)
-      block->abs_adv_steps_multiplier8 = LROUND(
-        extruder_advance_k
-        * (UNEAR_ZERO(advance_ed_ratio) ? lin_dist_e / lin_dist_xy : advance_ed_ratio) // Use the fixed ratio, if set
-        * (block->nominal_speed / (float)block->nominal_rate)
-        * axis_steps_per_mm[E_AXIS_N] * 256.0
-      );
-
-  #endif // LIN_ADVANCE
-
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
   // Update the position (only when a move was queued)
   static_assert(COUNT(target) > 1, "Parameter to _buffer_steps must be (&target)[XYZE]!");
   COPY(position, target);
+  #if ENABLED(LIN_ADVANCE)
+    COPY(position_float, target_float);
+  #endif
 
   recalculate();
 
 } // _buffer_steps()
 
 /**
  * Planner::buffer_segment
  *
  * Add a new linear movement to the buffer in axis units.
  *
  * Leveling and kinematics should be applied ahead of calling this.
  *
  *  a,b,c,e     - target positions in mm and/or degrees
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  *  millimeters - the length of the movement, if known
  */
-void Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder, const float &millimeters /*= 0.0*/) {
+void Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder, const float &millimeters/*=0.0*/) {
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
     if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
       position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
       last_extruder = extruder;
     }
   #endif
 
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
   const int32_t target[ABCE] = {
     LROUND(a * axis_steps_per_mm[A_AXIS]),
     LROUND(b * axis_steps_per_mm[B_AXIS]),
     LROUND(c * axis_steps_per_mm[C_AXIS]),
     LROUND(e * axis_steps_per_mm[E_AXIS_N])
   };
 
+  #if ENABLED(LIN_ADVANCE)
+    const float target_float[XYZE] = { a, b, c, e };
+  #endif
+
+  // DRYRUN prevents E moves from taking place
+  if (DEBUGGING(DRYRUN)) {
+    position[E_AXIS] = target[E_AXIS];
+    #if ENABLED(LIN_ADVANCE)
+      position_float[E_AXIS] = e;
+    #endif
+  }
+
   /* <-- add a slash to enable
     SERIAL_ECHOPAIR("  buffer_segment FR:", fr_mm_s);
     #if IS_KINEMATIC
       SERIAL_ECHOPAIR(" A:", a);
       SERIAL_ECHOPAIR(" (", position[A_AXIS]);
       SERIAL_ECHOPAIR("->", target[A_AXIS]);
       SERIAL_ECHOPAIR(") B:", b);
     #else
       SERIAL_ECHOPAIR(" X:", a);
       SERIAL_ECHOPAIR(" (", position[X_AXIS]);
@@ -1477,99 +1538,62 @@ void Planner::buffer_segment(const float &a, const float &b, const float &c, con
       SERIAL_ECHOPAIR(") Z:", c);
     #endif
     SERIAL_ECHOPAIR(" (", position[Z_AXIS]);
     SERIAL_ECHOPAIR("->", target[Z_AXIS]);
     SERIAL_ECHOPAIR(") E:", e);
     SERIAL_ECHOPAIR(" (", position[E_AXIS]);
     SERIAL_ECHOPAIR("->", target[E_AXIS]);
     SERIAL_ECHOLNPGM(")");
   //*/
 
-  // DRYRUN prevents E moves from taking place
-  if (DEBUGGING(DRYRUN)) {
-    position[E_AXIS] = target[E_AXIS];
-    #if ENABLED(LIN_ADVANCE)
-      position_float[E_AXIS] = e;
-    #endif
-  }
-
-  #if ENABLED(LIN_ADVANCE)
-    lin_dist_e = e - position_float[E_AXIS];
-  #endif
-
-  // If LIN_ADVANCE is enabled then do E move prevention with floats
-  // Otherwise it's done in _buffer_steps.
-  #if ENABLED(LIN_ADVANCE) && (ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE))
-    if (lin_dist_e) {
-      #if ENABLED(PREVENT_COLD_EXTRUSION)
-        if (thermalManager.tooColdToExtrude(extruder)) {
-          position_float[E_AXIS] = e; // Behave as if the move really took place, but ignore E part
-          position[E_AXIS] = target[E_AXIS];
-          lin_dist_e = 0;
-          SERIAL_ECHO_START();
-          SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
-        }
-      #endif // PREVENT_COLD_EXTRUSION
-      #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-        if (lin_dist_e * e_factor[extruder] > (EXTRUDE_MAXLENGTH)) {
-          position_float[E_AXIS] = e; // Behave as if the move really took place, but ignore E part
-          position[E_AXIS] = target[E_AXIS];
-          lin_dist_e = 0;
-          SERIAL_ECHO_START();
-          SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
-        }
-      #endif // PREVENT_LENGTHY_EXTRUDE
-    }
-  #endif // LIN_ADVANCE && (PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE)
-
-  #if ENABLED(LIN_ADVANCE)
-    if (lin_dist_e > 0)
-      lin_dist_xy = HYPOT(a - position_float[X_AXIS], b - position_float[Y_AXIS]);
-  #endif
-
   // Always split the first move into two (if not homing or probing)
   if (!blocks_queued()) {
 
     #define _BETWEEN(A) (position[A##_AXIS] + target[A##_AXIS]) >> 1
     const int32_t between[ABCE] = { _BETWEEN(A), _BETWEEN(B), _BETWEEN(C), _BETWEEN(E) };
-    DISABLE_STEPPER_DRIVER_INTERRUPT();
 
     #if ENABLED(LIN_ADVANCE)
-      lin_dist_xy *= 0.5;
-      lin_dist_e *= 0.5;
+      #define _BETWEEN_F(A) (position_float[A##_AXIS] + target_float[A##_AXIS]) * 0.5
+      const float between_float[ABCE] = { _BETWEEN_F(A), _BETWEEN_F(B), _BETWEEN_F(C), _BETWEEN_F(E) };
     #endif
 
-    _buffer_steps(between, fr_mm_s, extruder, millimeters * 0.5);
+    DISABLE_STEPPER_DRIVER_INTERRUPT();
 
-    #if ENABLED(LIN_ADVANCE)
-      position_float[X_AXIS] = (position_float[X_AXIS] + a) * 0.5;
-      position_float[Y_AXIS] = (position_float[Y_AXIS] + b) * 0.5;
-      //position_float[Z_AXIS] = (position_float[Z_AXIS] + c) * 0.5;
-      position_float[E_AXIS] = (position_float[E_AXIS] + e) * 0.5;
-    #endif
+    _buffer_steps(between
+      #if ENABLED(LIN_ADVANCE)
+        , between_float
+      #endif
+      , fr_mm_s, extruder, millimeters * 0.5
+    );
 
     const uint8_t next = block_buffer_head;
-    _buffer_steps(target, fr_mm_s, extruder, millimeters * 0.5);
+
+    _buffer_steps(target
+      #if ENABLED(LIN_ADVANCE)
+        , target_float
+      #endif
+      , fr_mm_s, extruder, millimeters * 0.5
+    );
+
     SBI(block_buffer[next].flag, BLOCK_BIT_CONTINUED);
     ENABLE_STEPPER_DRIVER_INTERRUPT();
   }
   else
-    _buffer_steps(target, fr_mm_s, extruder, millimeters);
+    _buffer_steps(target
+      #if ENABLED(LIN_ADVANCE)
+        , target_float
+      #endif
+      , fr_mm_s, extruder, millimeters
+    );
 
   stepper.wake_up();
 
-  #if ENABLED(LIN_ADVANCE)
-    position_float[X_AXIS] = a;
-    position_float[Y_AXIS] = b;
-    //position_float[Z_AXIS] = c;
-    position_float[E_AXIS] = e;
-  #endif
 } // buffer_segment()
 
 /**
  * Directly set the planner XYZ position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
 
 void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
@@ -1579,21 +1603,21 @@ void Planner::_set_position_mm(const float &a, const float &b, const float &c, c
   #else
     #define _EINDEX E_AXIS
   #endif
   const int32_t na = position[A_AXIS] = LROUND(a * axis_steps_per_mm[A_AXIS]),
                 nb = position[B_AXIS] = LROUND(b * axis_steps_per_mm[B_AXIS]),
                 nc = position[C_AXIS] = LROUND(c * axis_steps_per_mm[C_AXIS]),
                 ne = position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
   #if ENABLED(LIN_ADVANCE)
     position_float[X_AXIS] = a;
     position_float[Y_AXIS] = b;
-    //position_float[Z_AXIS] = c;
+    position_float[Z_AXIS] = c;
     position_float[E_AXIS] = e;
   #endif
   stepper.set_position(na, nb, nc, ne);
   previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
   ZERO(previous_speed);
 }
 
 void Planner::set_position_mm_kinematic(const float (&cart)[XYZE]) {
   #if PLANNER_LEVELING
     float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };

commit 73cd34b121023feb9cff4faec505138013a6b232
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 19 16:12:04 2018 -0600

    Finish AUTO_POWER_CONTROL implementation
    
    Followup to #9503

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 8d01afad7e..e06b0f43f5 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -77,20 +77,24 @@
 #endif
 
 #if ENABLED(BARICUDA)
   #include "../feature/baricuda.h"
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"
 #endif
 
+#if ENABLED(AUTO_POWER_CONTROL)
+  #include "../feature/power.h"
+#endif
+
 Planner planner;
 
   // public:
 
 /**
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next block to be pushed
                  Planner::block_buffer_tail = 0;
@@ -853,20 +857,25 @@ void Planner::_buffer_steps(const int32_t (&target)[ABCE], float fr_mm_s, const
     for (uint8_t i = 0; i < FAN_COUNT; i++) block->fan_speed[i] = fanSpeeds[i];
   #endif
 
   #if ENABLED(BARICUDA)
     block->valve_pressure = baricuda_valve_pressure;
     block->e_to_p_pressure = baricuda_e_to_p_pressure;
   #endif
 
   block->active_extruder = extruder;
 
+  #if ENABLED(AUTO_POWER_CONTROL)
+    if (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS])
+        powerManager.power_on();
+  #endif
+
   //enable active axes
   #if CORE_IS_XY
     if (block->steps[A_AXIS] || block->steps[B_AXIS]) {
       enable_X();
       enable_Y();
     }
     #if DISABLED(Z_LATE_ENABLE)
       if (block->steps[Z_AXIS]) enable_Z();
     #endif
   #elif CORE_IS_XZ
@@ -885,20 +894,24 @@ void Planner::_buffer_steps(const int32_t (&target)[ABCE], float fr_mm_s, const
     if (block->steps[X_AXIS]) enable_X();
     if (block->steps[Y_AXIS]) enable_Y();
     #if DISABLED(Z_LATE_ENABLE)
       if (block->steps[Z_AXIS]) enable_Z();
     #endif
   #endif
 
   // Enable extruder(s)
   if (esteps) {
 
+    #if ENABLED(AUTO_POWER_CONTROL)
+      powerManager.power_on();
+    #endif
+
     #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
 
       #define DISABLE_IDLE_E(N) if (!g_uc_extruder_last_move[N]) disable_E##N();
 
       for (uint8_t i = 0; i < EXTRUDERS; i++)
         if (g_uc_extruder_last_move[i] > 0) g_uc_extruder_last_move[i]--;
 
       switch(extruder) {
         case 0:
           enable_E0();

commit 786746404b8aa58c44a93734afd61c701d2abecb
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Feb 4 00:26:05 2018 -0600

    [2.0.x] Apply feedrate to nozzle movement for kinematic machines (#8778)

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index cb2915382e..8d01afad7e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -719,25 +719,25 @@ void Planner::check_axes_activity() {
 
 /**
  * Planner::_buffer_steps
  *
  * Add a new linear movement to the buffer (in terms of steps).
  *
  *  target      - target position in steps units
  *  fr_mm_s     - (target) speed of the move
  *  extruder    - target extruder
  */
-void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const uint8_t extruder) {
+void Planner::_buffer_steps(const int32_t (&target)[ABCE], float fr_mm_s, const uint8_t extruder, const float &millimeters /*= 0.0*/) {
 
-  const int32_t da = target[X_AXIS] - position[X_AXIS],
-                db = target[Y_AXIS] - position[Y_AXIS],
-                dc = target[Z_AXIS] - position[Z_AXIS];
+  const int32_t da = target[A_AXIS] - position[A_AXIS],
+                db = target[B_AXIS] - position[B_AXIS],
+                dc = target[C_AXIS] - position[C_AXIS];
 
   int32_t de = target[E_AXIS] - position[E_AXIS];
 
   /* <-- add a slash to enable
     SERIAL_ECHOPAIR("  _buffer_steps FR:", fr_mm_s);
     SERIAL_ECHOPAIR(" A:", target[A_AXIS]);
     SERIAL_ECHOPAIR(" (", da);
     SERIAL_ECHOPAIR(" steps) B:", target[B_AXIS]);
     SERIAL_ECHOPAIR(" (", db);
     SERIAL_ECHOPAIR(" steps) C:", target[C_AXIS]);
@@ -825,27 +825,27 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
   #elif CORE_IS_XZ
     block->steps[A_AXIS] = labs(da + dc);
     block->steps[Y_AXIS] = labs(db);
     block->steps[C_AXIS] = labs(da - dc);
   #elif CORE_IS_YZ
     block->steps[X_AXIS] = labs(da);
     block->steps[B_AXIS] = labs(db + dc);
     block->steps[C_AXIS] = labs(db - dc);
   #else
     // default non-h-bot planning
-    block->steps[X_AXIS] = labs(da);
-    block->steps[Y_AXIS] = labs(db);
-    block->steps[Z_AXIS] = labs(dc);
+    block->steps[A_AXIS] = labs(da);
+    block->steps[B_AXIS] = labs(db);
+    block->steps[C_AXIS] = labs(dc);
   #endif
 
   block->steps[E_AXIS] = esteps;
-  block->step_event_count = MAX4(block->steps[X_AXIS], block->steps[Y_AXIS], block->steps[Z_AXIS], esteps);
+  block->step_event_count = MAX4(block->steps[A_AXIS], block->steps[B_AXIS], block->steps[C_AXIS], esteps);
 
   // Bail if this is a zero-length block
   if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return;
 
   // For a mixing extruder, get a magnified step_event_count for each
   #if ENABLED(MIXING_EXTRUDER)
     for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
       block->mix_event_count[i] = mixing_factor[i] * block->step_event_count;
   #endif
 
@@ -1012,43 +1012,46 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
       delta_mm[A_AXIS] = (da + dc) * steps_to_mm[A_AXIS];
       delta_mm[C_AXIS] = CORESIGN(da - dc) * steps_to_mm[C_AXIS];
     #elif CORE_IS_YZ
       delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
       delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
       delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
       delta_mm[B_AXIS] = (db + dc) * steps_to_mm[B_AXIS];
       delta_mm[C_AXIS] = CORESIGN(db - dc) * steps_to_mm[C_AXIS];
     #endif
   #else
-    float delta_mm[XYZE];
-    delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
-    delta_mm[Y_AXIS] = db * steps_to_mm[Y_AXIS];
-    delta_mm[Z_AXIS] = dc * steps_to_mm[Z_AXIS];
+    float delta_mm[ABCE];
+    delta_mm[A_AXIS] = da * steps_to_mm[A_AXIS];
+    delta_mm[B_AXIS] = db * steps_to_mm[B_AXIS];
+    delta_mm[C_AXIS] = dc * steps_to_mm[C_AXIS];
   #endif
   delta_mm[E_AXIS] = esteps_float * steps_to_mm[E_AXIS_N];
 
-  if (block->steps[X_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[Y_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[Z_AXIS] < MIN_STEPS_PER_SEGMENT) {
+  if (block->steps[A_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[B_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[C_AXIS] < MIN_STEPS_PER_SEGMENT) {
     block->millimeters = FABS(delta_mm[E_AXIS]);
   }
-  else {
+  else if (!millimeters) {
     block->millimeters = SQRT(
       #if CORE_IS_XY
         sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS])
       #elif CORE_IS_XZ
         sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
       #elif CORE_IS_YZ
         sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
       #else
         sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS])
       #endif
     );
   }
+  else
+    block->millimeters = millimeters;
+
   const float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate inverse time for this move. No divide by zero due to previous checks.
   // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   float inverse_secs = fr_mm_s * inverse_millimeters;
 
   const uint8_t moves_queued = movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
@@ -1163,21 +1166,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
   // Correct the speed
   if (speed_factor < 1.0) {
     LOOP_XYZE(i) current_speed[i] *= speed_factor;
     block->nominal_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
   }
 
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
-  if (!block->steps[X_AXIS] && !block->steps[Y_AXIS] && !block->steps[Z_AXIS]) {
+  if (!block->steps[A_AXIS] && !block->steps[B_AXIS] && !block->steps[C_AXIS]) {
     // convert to: acceleration steps/sec^2
     accel = CEIL(retract_acceleration * steps_per_mm);
   }
   else {
     #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
         const uint32_t comp = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count; \
         if (accel * block->steps[AXIS] > comp) accel = comp / block->steps[AXIS]; \
       } \
     }while(0)
@@ -1193,48 +1196,48 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
     accel = CEIL((esteps ? acceleration : travel_acceleration) * steps_per_mm);
 
     #if ENABLED(DISTINCT_E_FACTORS)
       #define ACCEL_IDX extruder
     #else
       #define ACCEL_IDX 0
     #endif
 
     // Limit acceleration per axis
     if (block->step_event_count <= cutoff_long) {
-      LIMIT_ACCEL_LONG(X_AXIS, 0);
-      LIMIT_ACCEL_LONG(Y_AXIS, 0);
-      LIMIT_ACCEL_LONG(Z_AXIS, 0);
+      LIMIT_ACCEL_LONG(A_AXIS, 0);
+      LIMIT_ACCEL_LONG(B_AXIS, 0);
+      LIMIT_ACCEL_LONG(C_AXIS, 0);
       LIMIT_ACCEL_LONG(E_AXIS, ACCEL_IDX);
     }
     else {
-      LIMIT_ACCEL_FLOAT(X_AXIS, 0);
-      LIMIT_ACCEL_FLOAT(Y_AXIS, 0);
-      LIMIT_ACCEL_FLOAT(Z_AXIS, 0);
+      LIMIT_ACCEL_FLOAT(A_AXIS, 0);
+      LIMIT_ACCEL_FLOAT(B_AXIS, 0);
+      LIMIT_ACCEL_FLOAT(C_AXIS, 0);
       LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
     }
   }
   block->acceleration_steps_per_s2 = accel;
   block->acceleration = accel / steps_per_mm;
   block->acceleration_rate = (long)(accel * 16777216.0 / (HAL_STEPPER_TIMER_RATE)); // 16777216 = <<24
 
   // Initial limit on the segment entry velocity
   float vmax_junction;
 
   #if 0  // Use old jerk for now
 
     float junction_deviation = 0.1;
 
     // Compute path unit vector
     double unit_vec[XYZ] = {
-      delta_mm[X_AXIS] * inverse_millimeters,
-      delta_mm[Y_AXIS] * inverse_millimeters,
-      delta_mm[Z_AXIS] * inverse_millimeters
+      delta_mm[A_AXIS] * inverse_millimeters,
+      delta_mm[B_AXIS] * inverse_millimeters,
+      delta_mm[C_AXIS] * inverse_millimeters
     };
 
     /*
        Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
 
        Let a circle be tangent to both previous and current path line segments, where the junction
        deviation is defined as the distance from the junction to the closest edge of the circle,
        collinear with the circle center.
 
        The circular segment joining the two paths represents the path of centripetal acceleration.
@@ -1410,39 +1413,40 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
 
 } // _buffer_steps()
 
 /**
  * Planner::buffer_segment
  *
  * Add a new linear movement to the buffer in axis units.
  *
  * Leveling and kinematics should be applied ahead of calling this.
  *
- *  a,b,c,e   - target positions in mm and/or degrees
- *  fr_mm_s   - (target) speed of the move
- *  extruder  - target extruder
+ *  a,b,c,e     - target positions in mm and/or degrees
+ *  fr_mm_s     - (target) speed of the move
+ *  extruder    - target extruder
+ *  millimeters - the length of the movement, if known
  */
-void Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder) {
+void Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder, const float &millimeters /*= 0.0*/) {
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
     if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
       position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
       last_extruder = extruder;
     }
   #endif
 
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
-  const int32_t target[XYZE] = {
-    LROUND(a * axis_steps_per_mm[X_AXIS]),
-    LROUND(b * axis_steps_per_mm[Y_AXIS]),
-    LROUND(c * axis_steps_per_mm[Z_AXIS]),
+  const int32_t target[ABCE] = {
+    LROUND(a * axis_steps_per_mm[A_AXIS]),
+    LROUND(b * axis_steps_per_mm[B_AXIS]),
+    LROUND(c * axis_steps_per_mm[C_AXIS]),
     LROUND(e * axis_steps_per_mm[E_AXIS_N])
   };
 
   /* <-- add a slash to enable
     SERIAL_ECHOPAIR("  buffer_segment FR:", fr_mm_s);
     #if IS_KINEMATIC
       SERIAL_ECHOPAIR(" A:", a);
       SERIAL_ECHOPAIR(" (", position[A_AXIS]);
       SERIAL_ECHOPAIR("->", target[A_AXIS]);
       SERIAL_ECHOPAIR(") B:", b);
@@ -1506,44 +1510,44 @@ void Planner::buffer_segment(const float &a, const float &b, const float &c, con
 
   #if ENABLED(LIN_ADVANCE)
     if (lin_dist_e > 0)
       lin_dist_xy = HYPOT(a - position_float[X_AXIS], b - position_float[Y_AXIS]);
   #endif
 
   // Always split the first move into two (if not homing or probing)
   if (!blocks_queued()) {
 
     #define _BETWEEN(A) (position[A##_AXIS] + target[A##_AXIS]) >> 1
-    const int32_t between[XYZE] = { _BETWEEN(X), _BETWEEN(Y), _BETWEEN(Z), _BETWEEN(E) };
+    const int32_t between[ABCE] = { _BETWEEN(A), _BETWEEN(B), _BETWEEN(C), _BETWEEN(E) };
     DISABLE_STEPPER_DRIVER_INTERRUPT();
 
     #if ENABLED(LIN_ADVANCE)
       lin_dist_xy *= 0.5;
       lin_dist_e *= 0.5;
     #endif
 
-    _buffer_steps(between, fr_mm_s, extruder);
+    _buffer_steps(between, fr_mm_s, extruder, millimeters * 0.5);
 
     #if ENABLED(LIN_ADVANCE)
       position_float[X_AXIS] = (position_float[X_AXIS] + a) * 0.5;
       position_float[Y_AXIS] = (position_float[Y_AXIS] + b) * 0.5;
       //position_float[Z_AXIS] = (position_float[Z_AXIS] + c) * 0.5;
       position_float[E_AXIS] = (position_float[E_AXIS] + e) * 0.5;
     #endif
 
     const uint8_t next = block_buffer_head;
-    _buffer_steps(target, fr_mm_s, extruder);
+    _buffer_steps(target, fr_mm_s, extruder, millimeters * 0.5);
     SBI(block_buffer[next].flag, BLOCK_BIT_CONTINUED);
     ENABLE_STEPPER_DRIVER_INTERRUPT();
   }
   else
-    _buffer_steps(target, fr_mm_s, extruder);
+    _buffer_steps(target, fr_mm_s, extruder, millimeters);
 
   stepper.wake_up();
 
   #if ENABLED(LIN_ADVANCE)
     position_float[X_AXIS] = a;
     position_float[Y_AXIS] = b;
     //position_float[Z_AXIS] = c;
     position_float[E_AXIS] = e;
   #endif
 } // buffer_segment()
@@ -1555,23 +1559,23 @@ void Planner::buffer_segment(const float &a, const float &b, const float &c, con
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
 
 void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define _EINDEX (E_AXIS + active_extruder)
     last_extruder = active_extruder;
   #else
     #define _EINDEX E_AXIS
   #endif
-  const int32_t na = position[X_AXIS] = LROUND(a * axis_steps_per_mm[X_AXIS]),
-                nb = position[Y_AXIS] = LROUND(b * axis_steps_per_mm[Y_AXIS]),
-                nc = position[Z_AXIS] = LROUND(c * axis_steps_per_mm[Z_AXIS]),
+  const int32_t na = position[A_AXIS] = LROUND(a * axis_steps_per_mm[A_AXIS]),
+                nb = position[B_AXIS] = LROUND(b * axis_steps_per_mm[B_AXIS]),
+                nc = position[C_AXIS] = LROUND(c * axis_steps_per_mm[C_AXIS]),
                 ne = position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
   #if ENABLED(LIN_ADVANCE)
     position_float[X_AXIS] = a;
     position_float[Y_AXIS] = b;
     //position_float[Z_AXIS] = c;
     position_float[E_AXIS] = e;
   #endif
   stepper.set_position(na, nb, nc, ne);
   previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
   ZERO(previous_speed);

commit 9644fe1839429bba2ac5fd61a001d6ad79d5c1d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 23 19:04:05 2018 -0600

    Lightly optimize arc length calculation

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 2d0e4ce389..cb2915382e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -366,21 +366,21 @@ void Planner::recalculate_trapezoids() {
     block_index = next_block_index(block_index);
   }
   // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
   if (next) {
     const float nomr = 1.0 / next->nominal_speed;
     calculate_trapezoid_for_block(next, next->entry_speed * nomr, (MINIMUM_PLANNER_SPEED) * nomr);
     CBI(next->flag, BLOCK_BIT_RECALCULATE);
   }
 }
 
-/*
+/**
  * Recalculate the motion plan according to the following algorithm:
  *
  *   1. Go over every block in reverse order...
  *
  *      Calculate a junction speed reduction (block_t.entry_factor) so:
  *
  *      a. The junction jerk is within the set limit, and
  *
  *      b. No speed reduction within one block requires faster
  *         deceleration than the one, true constant acceleration.
@@ -396,21 +396,20 @@ void Planner::recalculate_trapezoids() {
  * jerk is jerkier than the set limit, Jerky. Finally it will:
  *
  *   3. Recalculate "trapezoids" for all blocks.
  */
 void Planner::recalculate() {
   reverse_pass();
   forward_pass();
   recalculate_trapezoids();
 }
 
-
 #if ENABLED(AUTOTEMP)
 
   void Planner::getHighESpeed() {
     static float oldt = 0;
 
     if (!autotemp_enabled) return;
     if (thermalManager.degTargetHotend(0) + 2 < autotemp_min) return; // probably temperature set to zero.
 
     float high = 0.0;
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {

commit 4f5e087ff49a57790b3e02ca895b15795e595713
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 11 21:02:13 2018 -0600

    Planner anti-stutter by Sebastian Popp

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 701fe0e36b..2d0e4ce389 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1345,69 +1345,68 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
   else {
     SBI(block->flag, BLOCK_BIT_START_FROM_FULL_HALT);
     vmax_junction = safe_speed;
   }
 
   // Max entry speed of this block equals the max exit speed of the previous block.
   block->max_entry_speed = vmax_junction;
 
   // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
   const float v_allowable = max_allowable_speed(-block->acceleration, MINIMUM_PLANNER_SPEED, block->millimeters);
-  block->entry_speed = min(vmax_junction, v_allowable);
+  // If stepper ISR is disabled, this indicates buffer_segment wants to add a split block.
+  // In this case start with the max. allowed speed to avoid an interrupted first move.
+  block->entry_speed = STEPPER_ISR_ENABLED() ? MINIMUM_PLANNER_SPEED : min(vmax_junction, v_allowable);
 
   // Initialize planner efficiency flags
   // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
   // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
   // the current block and next block junction speeds are guaranteed to always be at their maximum
   // junction speeds in deceleration and acceleration, respectively. This is due to how the current
   // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
-  block->flag |= BLOCK_FLAG_RECALCULATE | (block->nominal_speed <= v_allowable ? BLOCK_FLAG_NOMINAL_LENGTH : 0);
+  block->flag |= block->nominal_speed <= v_allowable ? BLOCK_FLAG_RECALCULATE | BLOCK_FLAG_NOMINAL_LENGTH : BLOCK_FLAG_RECALCULATE;
 
   // Update previous path unit_vector and nominal speed
   COPY(previous_speed, current_speed);
   previous_nominal_speed = block->nominal_speed;
   previous_safe_speed = safe_speed;
 
   #if ENABLED(LIN_ADVANCE)
     /**
      *
      * Use LIN_ADVANCE for blocks if all these are true:
      *
      * esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS]) : This is a print move
      *
      * extruder_advance_k                 : There is an advance factor set.
      *
      * esteps != block->step_event_count  : A problem occurs if the move before a retract is too small.
      *                                      In that case, the retract and move will be executed together.
      *                                      This leads to too many advance steps due to a huge e_acceleration.
      *                                      The math is good, but we must avoid retract moves with advance!
-     * lin_dist_e > 0                     : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
+     * lin_dist_e > 0                       : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
      */
     block->use_advance_lead =  esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS])
                             && extruder_advance_k
                             && (uint32_t)esteps != block->step_event_count
                             && lin_dist_e > 0;
     if (block->use_advance_lead)
       block->abs_adv_steps_multiplier8 = LROUND(
         extruder_advance_k
         * (UNEAR_ZERO(advance_ed_ratio) ? lin_dist_e / lin_dist_xy : advance_ed_ratio) // Use the fixed ratio, if set
         * (block->nominal_speed / (float)block->nominal_rate)
         * axis_steps_per_mm[E_AXIS_N] * 256.0
       );
 
   #endif // LIN_ADVANCE
 
-  const float bnsr = 1.0 / block->nominal_speed;
-  calculate_trapezoid_for_block(block, block->entry_speed * bnsr, safe_speed * bnsr);
-
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
   // Update the position (only when a move was queued)
   static_assert(COUNT(target) > 1, "Parameter to _buffer_steps must be (&target)[XYZE]!");
   COPY(position, target);
 
   recalculate();
 
 } // _buffer_steps()

commit 5effe1590c01e271ae2c4474bbdd8fbdfa1f57be
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 26 20:04:39 2017 -0600

    Fix NO_VOLUMETRICS bug

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 90dfaf8476..701fe0e36b 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -98,21 +98,21 @@ volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next
 float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
       Planner::axis_steps_per_mm[XYZE_N],
       Planner::steps_to_mm[XYZE_N];
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
 
-float Planner::e_factor[EXTRUDERS];               // The flow percentage and volumetric multiplier combine to scale E movement
+float Planner::e_factor[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0); // The flow percentage and volumetric multiplier combine to scale E movement
 
 #if DISABLED(NO_VOLUMETRICS)
   float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
         Planner::volumetric_area_nominal = CIRCLE_AREA((DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5), // Nominal cross-sectional area
         Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
 #endif
 
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N],
          Planner::max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
 

commit 2917d1217d41527ff7122bad57f57cc04f5c3c21
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sat Dec 23 17:00:33 2017 -0600

    Revert "Followup to #8698"
    
    This reverts commit 4e891e9fb7af63f1cf8691e0d6810b414d574e45.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index d17b5535c2..90dfaf8476 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1069,20 +1069,23 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
       }
     }
   #endif
 
   #if ENABLED(ULTRA_LCD)
     CRITICAL_SECTION_START
       block_buffer_runtime_us += segment_time_us;
     CRITICAL_SECTION_END
   #endif
 
+  block->nominal_speed = block->millimeters * inverse_secs;           //   (mm/sec) Always > 0
+  block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
+
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     static float filwidth_e_count = 0, filwidth_delay_dist = 0;
 
     //FMM update ring buffer used for delay with filament measurements
     if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && filwidth_delay_index[1] >= 0) {  //only for extruder with filament sensor and if ring buffer is initialized
 
       constexpr int MMD_CM = MAX_MEASUREMENT_DELAY + 1, MMD_MM = MMD_CM * 10;
 
       // increment counters with next move in e axis
       filwidth_e_count += delta_mm[E_AXIS];

commit 97d509d4d281ec8cafd6815aa9f2a4d7ba647548
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Dec 21 16:51:08 2017 -0600

    Revert "Improved Core-compatible jerk code"
    
    Reverting commit 3cd7659

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c344640852..d17b5535c2 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1103,28 +1103,24 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
           const int8_t meas_sample = thermalManager.widthFil_to_size_ratio();
           do {
             filwidth_delay_index[1] = (filwidth_delay_index[1] + 1) % MMD_CM; // The next unused slot
             measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
           } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
         }
       }
     }
   #endif
 
-  // Calculate and limit speed in mm/sec for each axis, calculate minimum acceleration ratio
+  // Calculate and limit speed in mm/sec for each axis
   float current_speed[NUM_AXIS], speed_factor = 1.0; // factor <1 decreases speed
-  float max_stepper_speed = 0, min_axis_accel_ratio = 1; // ratio < 1 means acceleration ramp needed
   LOOP_XYZE(i) {
     const float cs = FABS((current_speed[i] = delta_mm[i] * inverse_secs));
-    if (cs > max_jerk[i])
-      NOMORE(min_axis_accel_ratio, max_jerk[i] / cs);
-    NOLESS(max_stepper_speed, cs);
     #if ENABLED(DISTINCT_E_FACTORS)
       if (i == E_AXIS) i += extruder;
     #endif
     if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
   }
 
   // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT
 
     // Check and limit the xy direction change frequency
@@ -1155,33 +1151,27 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
 
     const uint32_t max_x_segment_time = MAX3(xs0, xs1, xs2),
                    max_y_segment_time = MAX3(ys0, ys1, ys2),
                    min_xy_segment_time = min(max_x_segment_time, max_y_segment_time);
     if (min_xy_segment_time < MAX_FREQ_TIME_US) {
       const float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME_US);
       NOMORE(speed_factor, low_sf);
     }
   #endif // XY_FREQUENCY_LIMIT
 
-  block->nominal_speed = max_stepper_speed; // (mm/sec) Always > 0
-  block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
-
   // Correct the speed
   if (speed_factor < 1.0) {
     LOOP_XYZE(i) current_speed[i] *= speed_factor;
     block->nominal_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
   }
 
-  float safe_speed = block->nominal_speed * min_axis_accel_ratio;
-  static float previous_safe_speed;
-
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
   if (!block->steps[X_AXIS] && !block->steps[Y_AXIS] && !block->steps[Z_AXIS]) {
     // convert to: acceleration steps/sec^2
     accel = CEIL(retract_acceleration * steps_per_mm);
   }
   else {
     #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
@@ -1269,32 +1259,58 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
         // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.
         if (cos_theta > -0.95) {
           // Compute maximum junction velocity based on maximum acceleration and junction deviation
           float sin_theta_d2 = SQRT(0.5 * (1.0 - cos_theta)); // Trig half angle identity. Always positive.
           NOMORE(vmax_junction, SQRT(block->acceleration * junction_deviation * sin_theta_d2 / (1.0 - sin_theta_d2)));
         }
       }
     }
   #endif
 
+  /**
+   * Adapted from Pr≈Ø≈°a MKS firmware
+   * https://github.com/prusa3d/Prusa-Firmware
+   *
+   * Start with a safe speed (from which the machine may halt to stop immediately).
+   */
+
+  // Exit speed limited by a jerk to full halt of a previous last segment
+  static float previous_safe_speed;
+
+  float safe_speed = block->nominal_speed;
+  uint8_t limited = 0;
+  LOOP_XYZE(i) {
+    const float jerk = FABS(current_speed[i]), maxj = max_jerk[i];
+    if (jerk > maxj) {
+      if (limited) {
+        const float mjerk = maxj * block->nominal_speed;
+        if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk;
+      }
+      else {
+        ++limited;
+        safe_speed = maxj;
+      }
+    }
+  }
+
   if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
     // Estimate a maximum velocity allowed at a joint of two successive segments.
     // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
     // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
 
     // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
     // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
     vmax_junction = min(block->nominal_speed, previous_nominal_speed);
 
     // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
     float v_factor = 1;
-    uint8_t limited = 0;
+    limited = 0;
 
     // Now limit the jerk in all axes.
     const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
     LOOP_XYZE(axis) {
       // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
       float v_exit = previous_speed[axis] * smaller_speed_factor,
             v_entry = current_speed[axis];
       if (limited) {
         v_exit *= v_factor;
         v_entry *= v_factor;

commit 5bc2acc0728b08a296cc5cdf16ac63c68d2aae68
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Dec 21 16:39:18 2017 -0600

    Restore position_float to fix LIN_ADVANCE

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 85c0f2010a..c344640852 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -175,36 +175,42 @@ float Planner::previous_speed[NUM_AXIS],
 
 #ifdef XY_FREQUENCY_LIMIT
   // Old direction bits. Used for speed calculations
   unsigned char Planner::old_direction_bits = 0;
   // Segment times (in ¬µs). Used for speed calculations
   uint32_t Planner::axis_segment_time_us[2][3] = { { MAX_FREQ_TIME_US + 1, 0, 0 }, { MAX_FREQ_TIME_US + 1, 0, 0 } };
 #endif
 
 #if ENABLED(LIN_ADVANCE)
   float Planner::extruder_advance_k, // Initialized by settings.load()
-        Planner::advance_ed_ratio;   // Initialized by settings.load()
+        Planner::advance_ed_ratio,   // Initialized by settings.load()
+        Planner::position_float[XYZE], // Needed for accurate maths. Steps cannot be used!
+        Planner::lin_dist_xy,
+        Planner::lin_dist_e;
 #endif
 
 #if ENABLED(ULTRA_LCD)
   volatile uint32_t Planner::block_buffer_runtime_us = 0;
 #endif
 
 /**
  * Class and Instance Methods
  */
 
 Planner::Planner() { init(); }
 
 void Planner::init() {
   block_buffer_head = block_buffer_tail = 0;
   ZERO(position);
+  #if ENABLED(LIN_ADVANCE)
+    ZERO(position_float);
+  #endif
   ZERO(previous_speed);
   previous_nominal_speed = 0.0;
   #if ABL_PLANAR
     bed_level_matrix.set_to_identity();
   #endif
 }
 
 #define MINIMAL_STEP_RATE 120
 
 /**
@@ -735,40 +741,42 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
     SERIAL_ECHOPAIR(" (", da);
     SERIAL_ECHOPAIR(" steps) B:", target[B_AXIS]);
     SERIAL_ECHOPAIR(" (", db);
     SERIAL_ECHOPAIR(" steps) C:", target[C_AXIS]);
     SERIAL_ECHOPAIR(" (", dc);
     SERIAL_ECHOPAIR(" steps) E:", target[E_AXIS]);
     SERIAL_ECHOPAIR(" (", de);
     SERIAL_ECHOLNPGM(" steps)");
   //*/
 
-  #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
+  // If LIN_ADVANCE is disabled then do E move prevention with integers
+  // Otherwise it's done in _buffer_segment.
+  #if DISABLED(LIN_ADVANCE) && (ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE))
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
         if (labs(de * e_factor[extruder]) > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
-  #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
+  #endif // !LIN_ADVANCE && (PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE)
 
   // Compute direction bit-mask for this block
   uint8_t dm = 0;
   #if CORE_IS_XY
     if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
     if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
     if (dc < 0) SBI(dm, Z_AXIS);
     if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
     if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
   #elif CORE_IS_XZ
@@ -1348,30 +1356,30 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
      * Use LIN_ADVANCE for blocks if all these are true:
      *
      * esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS]) : This is a print move
      *
      * extruder_advance_k                 : There is an advance factor set.
      *
      * esteps != block->step_event_count  : A problem occurs if the move before a retract is too small.
      *                                      In that case, the retract and move will be executed together.
      *                                      This leads to too many advance steps due to a huge e_acceleration.
      *                                      The math is good, but we must avoid retract moves with advance!
-     * de > 0                             : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
+     * lin_dist_e > 0                     : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
      */
     block->use_advance_lead =  esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS])
                             && extruder_advance_k
                             && (uint32_t)esteps != block->step_event_count
-                            && de > 0;
+                            && lin_dist_e > 0;
     if (block->use_advance_lead)
       block->abs_adv_steps_multiplier8 = LROUND(
         extruder_advance_k
-        * (UNEAR_ZERO(advance_ed_ratio) ? de * steps_to_mm[E_AXIS_N] / HYPOT(da * steps_to_mm[X_AXIS], db * steps_to_mm[Y_AXIS]) : advance_ed_ratio) // Use the fixed ratio, if set
+        * (UNEAR_ZERO(advance_ed_ratio) ? lin_dist_e / lin_dist_xy : advance_ed_ratio) // Use the fixed ratio, if set
         * (block->nominal_speed / (float)block->nominal_rate)
         * axis_steps_per_mm[E_AXIS_N] * 256.0
       );
 
   #endif // LIN_ADVANCE
 
   const float bnsr = 1.0 / block->nominal_speed;
   calculate_trapezoid_for_block(block, block->entry_speed * bnsr, safe_speed * bnsr);
 
   // Move buffer head
@@ -1435,60 +1443,125 @@ void Planner::buffer_segment(const float &a, const float &b, const float &c, con
       SERIAL_ECHOPAIR(") Z:", c);
     #endif
     SERIAL_ECHOPAIR(" (", position[Z_AXIS]);
     SERIAL_ECHOPAIR("->", target[Z_AXIS]);
     SERIAL_ECHOPAIR(") E:", e);
     SERIAL_ECHOPAIR(" (", position[E_AXIS]);
     SERIAL_ECHOPAIR("->", target[E_AXIS]);
     SERIAL_ECHOLNPGM(")");
   //*/
 
-  // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
-  if (DEBUGGING(DRYRUN))
+  // DRYRUN prevents E moves from taking place
+  if (DEBUGGING(DRYRUN)) {
     position[E_AXIS] = target[E_AXIS];
+    #if ENABLED(LIN_ADVANCE)
+      position_float[E_AXIS] = e;
+    #endif
+  }
+
+  #if ENABLED(LIN_ADVANCE)
+    lin_dist_e = e - position_float[E_AXIS];
+  #endif
+
+  // If LIN_ADVANCE is enabled then do E move prevention with floats
+  // Otherwise it's done in _buffer_steps.
+  #if ENABLED(LIN_ADVANCE) && (ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE))
+    if (lin_dist_e) {
+      #if ENABLED(PREVENT_COLD_EXTRUSION)
+        if (thermalManager.tooColdToExtrude(extruder)) {
+          position_float[E_AXIS] = e; // Behave as if the move really took place, but ignore E part
+          position[E_AXIS] = target[E_AXIS];
+          lin_dist_e = 0;
+          SERIAL_ECHO_START();
+          SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
+        }
+      #endif // PREVENT_COLD_EXTRUSION
+      #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
+        if (lin_dist_e * e_factor[extruder] > (EXTRUDE_MAXLENGTH)) {
+          position_float[E_AXIS] = e; // Behave as if the move really took place, but ignore E part
+          position[E_AXIS] = target[E_AXIS];
+          lin_dist_e = 0;
+          SERIAL_ECHO_START();
+          SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
+        }
+      #endif // PREVENT_LENGTHY_EXTRUDE
+    }
+  #endif // LIN_ADVANCE && (PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE)
+
+  #if ENABLED(LIN_ADVANCE)
+    if (lin_dist_e > 0)
+      lin_dist_xy = HYPOT(a - position_float[X_AXIS], b - position_float[Y_AXIS]);
+  #endif
 
   // Always split the first move into two (if not homing or probing)
   if (!blocks_queued()) {
+
     #define _BETWEEN(A) (position[A##_AXIS] + target[A##_AXIS]) >> 1
     const int32_t between[XYZE] = { _BETWEEN(X), _BETWEEN(Y), _BETWEEN(Z), _BETWEEN(E) };
     DISABLE_STEPPER_DRIVER_INTERRUPT();
+
+    #if ENABLED(LIN_ADVANCE)
+      lin_dist_xy *= 0.5;
+      lin_dist_e *= 0.5;
+    #endif
+
     _buffer_steps(between, fr_mm_s, extruder);
+
+    #if ENABLED(LIN_ADVANCE)
+      position_float[X_AXIS] = (position_float[X_AXIS] + a) * 0.5;
+      position_float[Y_AXIS] = (position_float[Y_AXIS] + b) * 0.5;
+      //position_float[Z_AXIS] = (position_float[Z_AXIS] + c) * 0.5;
+      position_float[E_AXIS] = (position_float[E_AXIS] + e) * 0.5;
+    #endif
+
     const uint8_t next = block_buffer_head;
     _buffer_steps(target, fr_mm_s, extruder);
     SBI(block_buffer[next].flag, BLOCK_BIT_CONTINUED);
     ENABLE_STEPPER_DRIVER_INTERRUPT();
   }
   else
     _buffer_steps(target, fr_mm_s, extruder);
 
   stepper.wake_up();
 
+  #if ENABLED(LIN_ADVANCE)
+    position_float[X_AXIS] = a;
+    position_float[Y_AXIS] = b;
+    //position_float[Z_AXIS] = c;
+    position_float[E_AXIS] = e;
+  #endif
 } // buffer_segment()
 
 /**
  * Directly set the planner XYZ position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
 
 void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define _EINDEX (E_AXIS + active_extruder)
     last_extruder = active_extruder;
   #else
     #define _EINDEX E_AXIS
   #endif
   const int32_t na = position[X_AXIS] = LROUND(a * axis_steps_per_mm[X_AXIS]),
                 nb = position[Y_AXIS] = LROUND(b * axis_steps_per_mm[Y_AXIS]),
                 nc = position[Z_AXIS] = LROUND(c * axis_steps_per_mm[Z_AXIS]),
                 ne = position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
+  #if ENABLED(LIN_ADVANCE)
+    position_float[X_AXIS] = a;
+    position_float[Y_AXIS] = b;
+    //position_float[Z_AXIS] = c;
+    position_float[E_AXIS] = e;
+  #endif
   stepper.set_position(na, nb, nc, ne);
   previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
   ZERO(previous_speed);
 }
 
 void Planner::set_position_mm_kinematic(const float (&cart)[XYZE]) {
   #if PLANNER_LEVELING
     float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
     apply_leveling(raw);
   #else
@@ -1499,35 +1572,46 @@ void Planner::set_position_mm_kinematic(const float (&cart)[XYZE]) {
     _set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS]);
   #else
     _set_position_mm(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS]);
   #endif
 }
 
 /**
  * Sync from the stepper positions. (e.g., after an interrupted move)
  */
 void Planner::sync_from_steppers() {
-  LOOP_XYZE(i)
+  LOOP_XYZE(i) {
     position[i] = stepper.position((AxisEnum)i);
+    #if ENABLED(LIN_ADVANCE)
+      position_float[i] = position[i] * steps_to_mm[i
+        #if ENABLED(DISTINCT_E_FACTORS)
+          + (i == E_AXIS ? active_extruder : 0)
+        #endif
+      ];
+    #endif
+  }
 }
 
 /**
  * Setters for planner position (also setting stepper position).
  */
 void Planner::set_position_mm(const AxisEnum axis, const float &v) {
   #if ENABLED(DISTINCT_E_FACTORS)
     const uint8_t axis_index = axis + (axis == E_AXIS ? active_extruder : 0);
     last_extruder = active_extruder;
   #else
     const uint8_t axis_index = axis;
   #endif
   position[axis] = LROUND(v * axis_steps_per_mm[axis_index]);
+  #if ENABLED(LIN_ADVANCE)
+    position_float[axis] = v;
+  #endif
   stepper.set_position(axis, v);
   previous_speed[axis] = 0.0;
 }
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define HIGHEST_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)
   #else
     #define HIGHEST_CONDITION true

commit 913d9e9a59221fec5c7bff15dc4ae9dc9b98b57d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 20 00:17:19 2017 -0600

    Matching sign across filwidth vars

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 1155d1d58c..85c0f2010a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1085,21 +1085,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
 
         // Loop the delay distance counter (modulus by the mm length)
         while (filwidth_delay_dist >= MMD_MM) filwidth_delay_dist -= MMD_MM;
 
         // Convert into an index into the measurement array
         filwidth_delay_index[0] = int8_t(filwidth_delay_dist * 0.1);
 
         // If the index has changed (must have gone forward)...
         if (filwidth_delay_index[0] != filwidth_delay_index[1]) {
           filwidth_e_count = 0; // Reset the E movement counter
-          const uint8_t meas_sample = thermalManager.widthFil_to_size_ratio();
+          const int8_t meas_sample = thermalManager.widthFil_to_size_ratio();
           do {
             filwidth_delay_index[1] = (filwidth_delay_index[1] + 1) % MMD_CM; // The next unused slot
             measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
           } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
         }
       }
     }
   #endif
 
   // Calculate and limit speed in mm/sec for each axis, calculate minimum acceleration ratio

commit 933f76fda3a2e8ecd9b3e8493b2885f4356b0430
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 19 19:44:11 2017 -0600

    Option to disable all volumetric extrusion

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 80c2ec1f77..1155d1d58c 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -98,24 +98,27 @@ volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next
 float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
       Planner::axis_steps_per_mm[XYZE_N],
       Planner::steps_to_mm[XYZE_N];
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
 
-float Planner::e_factor[EXTRUDERS],               // The flow percentage and volumetric multiplier combine to scale E movement
-      Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
-      Planner::volumetric_area_nominal = CIRCLE_AREA((DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5), // Nominal cross-sectional area
-      Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
+float Planner::e_factor[EXTRUDERS];               // The flow percentage and volumetric multiplier combine to scale E movement
+
+#if DISABLED(NO_VOLUMETRICS)
+  float Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
+        Planner::volumetric_area_nominal = CIRCLE_AREA((DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5), // Nominal cross-sectional area
+        Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
+#endif
 
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N],
          Planner::max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
 
 uint32_t Planner::min_segment_time_us;
 
 // Initialized by settings.load()
 float Planner::min_feedrate_mm_s,
       Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
       Planner::retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
@@ -554,39 +557,43 @@ void Planner::check_axes_activity() {
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       analogWrite(HEATER_1_PIN, tail_valve_pressure);
     #endif
     #if HAS_HEATER_2
       analogWrite(HEATER_2_PIN, tail_e_to_p_pressure);
     #endif
   #endif
 }
 
-/**
- * Get a volumetric multiplier from a filament diameter.
- * This is the reciprocal of the circular cross-section area.
- * Return 1.0 with volumetric off or a diameter of 0.0.
- */
-inline float calculate_volumetric_multiplier(const float &diameter) {
-  return (parser.volumetric_enabled && diameter) ? 1.0 / CIRCLE_AREA(diameter * 0.5) : 1.0;
-}
+#if DISABLED(NO_VOLUMETRICS)
 
-/**
- * Convert the filament sizes into volumetric multipliers.
- * The multiplier converts a given E value into a length.
- */
-void Planner::calculate_volumetric_multipliers() {
-  for (uint8_t i = 0; i < COUNT(filament_size); i++) {
-    volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
-    refresh_e_factor(i);
+  /**
+   * Get a volumetric multiplier from a filament diameter.
+   * This is the reciprocal of the circular cross-section area.
+   * Return 1.0 with volumetric off or a diameter of 0.0.
+   */
+  inline float calculate_volumetric_multiplier(const float &diameter) {
+    return (parser.volumetric_enabled && diameter) ? 1.0 / CIRCLE_AREA(diameter * 0.5) : 1.0;
   }
-}
+
+  /**
+   * Convert the filament sizes into volumetric multipliers.
+   * The multiplier converts a given E value into a length.
+   */
+  void Planner::calculate_volumetric_multipliers() {
+    for (uint8_t i = 0; i < COUNT(filament_size); i++) {
+      volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
+      refresh_e_factor(i);
+    }
+  }
+
+#endif // !NO_VOLUMETRICS
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   /**
    * Convert the ratio value given by the filament width sensor
    * into a volumetric multiplier. Conversion differs when using
    * linear extrusion vs volumetric extrusion.
    */
   void Planner::calculate_volumetric_for_width_sensor(const int8_t encoded_ratio) {
     // Reconstitute the nominal/measured ratio
     const float nom_meas_ratio = 1.0 + 0.01 * encoded_ratio,

commit de5ca96654313a4c9cecaafe265035f6654128bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 19 18:36:16 2017 -0600

    More parity with 1.1.x, plus whitespace

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index f1ecb25267..80c2ec1f77 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1093,21 +1093,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
         }
       }
     }
   #endif
 
   // Calculate and limit speed in mm/sec for each axis, calculate minimum acceleration ratio
   float current_speed[NUM_AXIS], speed_factor = 1.0; // factor <1 decreases speed
   float max_stepper_speed = 0, min_axis_accel_ratio = 1; // ratio < 1 means acceleration ramp needed
   LOOP_XYZE(i) {
     const float cs = FABS((current_speed[i] = delta_mm[i] * inverse_secs));
-    if (cs >  max_jerk[i]) 
+    if (cs > max_jerk[i])
       NOMORE(min_axis_accel_ratio, max_jerk[i] / cs);
     NOLESS(max_stepper_speed, cs);
     #if ENABLED(DISTINCT_E_FACTORS)
       if (i == E_AXIS) i += extruder;
     #endif
     if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
   }
 
   // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT

commit cf2193c07ffc07597ece619da2db8cc587f68479
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 13 02:32:34 2017 -0600

    Comment, fix filament width sensor

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index cf3a316059..f1ecb25267 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -554,31 +554,59 @@ void Planner::check_axes_activity() {
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       analogWrite(HEATER_1_PIN, tail_valve_pressure);
     #endif
     #if HAS_HEATER_2
       analogWrite(HEATER_2_PIN, tail_e_to_p_pressure);
     #endif
   #endif
 }
 
+/**
+ * Get a volumetric multiplier from a filament diameter.
+ * This is the reciprocal of the circular cross-section area.
+ * Return 1.0 with volumetric off or a diameter of 0.0.
+ */
 inline float calculate_volumetric_multiplier(const float &diameter) {
   return (parser.volumetric_enabled && diameter) ? 1.0 / CIRCLE_AREA(diameter * 0.5) : 1.0;
 }
 
+/**
+ * Convert the filament sizes into volumetric multipliers.
+ * The multiplier converts a given E value into a length.
+ */
 void Planner::calculate_volumetric_multipliers() {
   for (uint8_t i = 0; i < COUNT(filament_size); i++) {
     volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
     refresh_e_factor(i);
   }
 }
 
+#if ENABLED(FILAMENT_WIDTH_SENSOR)
+  /**
+   * Convert the ratio value given by the filament width sensor
+   * into a volumetric multiplier. Conversion differs when using
+   * linear extrusion vs volumetric extrusion.
+   */
+  void Planner::calculate_volumetric_for_width_sensor(const int8_t encoded_ratio) {
+    // Reconstitute the nominal/measured ratio
+    const float nom_meas_ratio = 1.0 + 0.01 * encoded_ratio,
+                ratio_2 = sq(nom_meas_ratio);
+
+    volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = parser.volumetric_enabled
+      ? ratio_2 / CIRCLE_AREA(filament_width_nominal * 0.5) // Volumetric uses a true volumetric multiplier
+      : ratio_2;                                            // Linear squares the ratio, which scales the volume
+
+    refresh_e_factor(FILAMENT_SENSOR_EXTRUDER_NUM);
+  }
+#endif
+
 #if PLANNER_LEVELING
   /**
    * rx, ry, rz - Cartesian positions in mm
    *              Leveled XYZ on completion
    */
   void Planner::apply_leveling(float &rx, float &ry, float &rz) {
 
     #if ENABLED(SKEW_CORRECTION)
       skew(rx, ry, rz);
     #endif
@@ -1050,21 +1078,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
 
         // Loop the delay distance counter (modulus by the mm length)
         while (filwidth_delay_dist >= MMD_MM) filwidth_delay_dist -= MMD_MM;
 
         // Convert into an index into the measurement array
         filwidth_delay_index[0] = int8_t(filwidth_delay_dist * 0.1);
 
         // If the index has changed (must have gone forward)...
         if (filwidth_delay_index[0] != filwidth_delay_index[1]) {
           filwidth_e_count = 0; // Reset the E movement counter
-          const uint8_t meas_sample = thermalManager.widthFil_to_size_ratio() - 100; // Subtract 100 to reduce magnitude - to store in a signed char
+          const uint8_t meas_sample = thermalManager.widthFil_to_size_ratio();
           do {
             filwidth_delay_index[1] = (filwidth_delay_index[1] + 1) % MMD_CM; // The next unused slot
             measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
           } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
         }
       }
     }
   #endif
 
   // Calculate and limit speed in mm/sec for each axis, calculate minimum acceleration ratio

commit 3255712343fdc9177cc94c86b2c31bf94ffbb8ca
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 07:50:55 2017 -0600

    Skew Correction for UBL
    
    Also remove unused grid slicing function when using UBL segmented.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 0d3f9c9562..cf3a316059 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -573,28 +573,21 @@ void Planner::calculate_volumetric_multipliers() {
 }
 
 #if PLANNER_LEVELING
   /**
    * rx, ry, rz - Cartesian positions in mm
    *              Leveled XYZ on completion
    */
   void Planner::apply_leveling(float &rx, float &ry, float &rz) {
 
     #if ENABLED(SKEW_CORRECTION)
-      if (WITHIN(rx, X_MIN_POS + 1, X_MAX_POS) && WITHIN(ry, Y_MIN_POS + 1, Y_MAX_POS)) {
-        const float tempry = ry - (rz * planner.yz_skew_factor),
-                    temprx = rx - (ry * planner.xy_skew_factor) - (rz * (planner.xz_skew_factor - (planner.xy_skew_factor * planner.yz_skew_factor)));
-        if (WITHIN(temprx, X_MIN_POS, X_MAX_POS) && WITHIN(tempry, Y_MIN_POS, Y_MAX_POS)) {
-          rx = temprx;
-          ry = tempry;
-        }
-      }
+      skew(rx, ry, rz);
     #endif
 
     if (!leveling_active) return;
 
     #if ABL_PLANAR
 
       float dx = rx - (X_TILT_FULCRUM),
             dy = ry - (Y_TILT_FULCRUM);
 
       apply_rotation_xyz(bed_level_matrix, dx, dy, rz);
@@ -671,28 +664,21 @@ void Planner::calculate_volumetric_multipliers() {
             bilinear_z_offset(raw) * fade_scaling_factor
           #else
             0
           #endif
         );
 
       #endif // !ABL_PLANAR
     }
 
     #if ENABLED(SKEW_CORRECTION)
-      if (WITHIN(raw[X_AXIS], X_MIN_POS, X_MAX_POS) && WITHIN(raw[Y_AXIS], Y_MIN_POS, Y_MAX_POS)) {
-        const float temprx = raw[X_AXIS] + raw[Y_AXIS] * planner.xy_skew_factor + raw[Z_AXIS] * planner.xz_skew_factor,
-                    tempry = raw[Y_AXIS] + raw[Z_AXIS] * planner.yz_skew_factor;
-        if (WITHIN(temprx, X_MIN_POS, X_MAX_POS) && WITHIN(tempry, Y_MIN_POS, Y_MAX_POS)) {
-          raw[X_AXIS] = temprx;
-          raw[Y_AXIS] = tempry;
-        }
-      }
+      unskew(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS]);
     #endif
   }
 
 #endif // PLANNER_LEVELING
 
 /**
  * Planner::_buffer_steps
  *
  * Add a new linear movement to the buffer (in terms of steps).
  *

commit 3db5303bfeed53180fb6a53caffcdf822fcfb285
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 07:41:19 2017 -0600

    _buffer_line => buffer_segment

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index eef3a47305..0d3f9c9562 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1358,50 +1358,50 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
 
   // Update the position (only when a move was queued)
   static_assert(COUNT(target) > 1, "Parameter to _buffer_steps must be (&target)[XYZE]!");
   COPY(position, target);
 
   recalculate();
 
 } // _buffer_steps()
 
 /**
- * Planner::_buffer_line
+ * Planner::buffer_segment
  *
  * Add a new linear movement to the buffer in axis units.
  *
  * Leveling and kinematics should be applied ahead of calling this.
  *
  *  a,b,c,e   - target positions in mm and/or degrees
  *  fr_mm_s   - (target) speed of the move
  *  extruder  - target extruder
  */
-void Planner::_buffer_line(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder) {
+void Planner::buffer_segment(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder) {
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
     if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
       position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
       last_extruder = extruder;
     }
   #endif
 
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
   const int32_t target[XYZE] = {
     LROUND(a * axis_steps_per_mm[X_AXIS]),
     LROUND(b * axis_steps_per_mm[Y_AXIS]),
     LROUND(c * axis_steps_per_mm[Z_AXIS]),
     LROUND(e * axis_steps_per_mm[E_AXIS_N])
   };
 
   /* <-- add a slash to enable
-    SERIAL_ECHOPAIR("  _buffer_line FR:", fr_mm_s);
+    SERIAL_ECHOPAIR("  buffer_segment FR:", fr_mm_s);
     #if IS_KINEMATIC
       SERIAL_ECHOPAIR(" A:", a);
       SERIAL_ECHOPAIR(" (", position[A_AXIS]);
       SERIAL_ECHOPAIR("->", target[A_AXIS]);
       SERIAL_ECHOPAIR(") B:", b);
     #else
       SERIAL_ECHOPAIR(" X:", a);
       SERIAL_ECHOPAIR(" (", position[X_AXIS]);
       SERIAL_ECHOPAIR("->", target[X_AXIS]);
       SERIAL_ECHOPAIR(") Y:", b);
@@ -1434,21 +1434,21 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
     const uint8_t next = block_buffer_head;
     _buffer_steps(target, fr_mm_s, extruder);
     SBI(block_buffer[next].flag, BLOCK_BIT_CONTINUED);
     ENABLE_STEPPER_DRIVER_INTERRUPT();
   }
   else
     _buffer_steps(target, fr_mm_s, extruder);
 
   stepper.wake_up();
 
-} // _buffer_line()
+} // buffer_segment()
 
 /**
  * Directly set the planner XYZ position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
 
 void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)

commit a71d2f3f40639945676eede207a9b4f4f5c6d122
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 02:11:31 2017 -0600

    UBL_DELTA => UBL_SEGMENTED

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index a7a01cbe8e..eef3a47305 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -609,21 +609,21 @@ void Planner::calculate_volumetric_multipliers() {
         if (!fade_scaling_factor) return;
       #elif HAS_MESH
         constexpr float fade_scaling_factor = 1.0;
       #endif
 
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
         const float raw[XYZ] = { rx, ry, 0 };
       #endif
 
       rz += (
-        #if ENABLED(AUTO_BED_LEVELING_UBL) // UBL_DELTA
+        #if ENABLED(AUTO_BED_LEVELING_UBL)
           ubl.get_z_correction(rx, ry) * fade_scaling_factor
         #elif ENABLED(MESH_BED_LEVELING)
           mbl.get_z(rx, ry
             #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
               , fade_scaling_factor
             #endif
           )
         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
           bilinear_z_offset(raw) * fade_scaling_factor
         #else

commit 73e32925e4b140fe23f62eeb658f807e4477d872
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 02:10:54 2017 -0600

    References are better for array args

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 3bf6fa5a76..a7a01cbe8e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1459,32 +1459,32 @@ void Planner::_set_position_mm(const float &a, const float &b, const float &c, c
   #endif
   const int32_t na = position[X_AXIS] = LROUND(a * axis_steps_per_mm[X_AXIS]),
                 nb = position[Y_AXIS] = LROUND(b * axis_steps_per_mm[Y_AXIS]),
                 nc = position[Z_AXIS] = LROUND(c * axis_steps_per_mm[Z_AXIS]),
                 ne = position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
   stepper.set_position(na, nb, nc, ne);
   previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
   ZERO(previous_speed);
 }
 
-void Planner::set_position_mm_kinematic(const float position[NUM_AXIS]) {
+void Planner::set_position_mm_kinematic(const float (&cart)[XYZE]) {
   #if PLANNER_LEVELING
-    float lpos[XYZ] = { position[X_AXIS], position[Y_AXIS], position[Z_AXIS] };
-    apply_leveling(lpos);
+    float raw[XYZ] = { cart[X_AXIS], cart[Y_AXIS], cart[Z_AXIS] };
+    apply_leveling(raw);
   #else
-    const float * const lpos = position;
+    const float (&raw)[XYZE] = cart;
   #endif
   #if IS_KINEMATIC
-    inverse_kinematics(lpos);
-    _set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], position[E_AXIS]);
+    inverse_kinematics(raw);
+    _set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], cart[E_AXIS]);
   #else
-    _set_position_mm(lpos[X_AXIS], lpos[Y_AXIS], lpos[Z_AXIS], position[E_AXIS]);
+    _set_position_mm(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], cart[E_AXIS]);
   #endif
 }
 
 /**
  * Sync from the stepper positions. (e.g., after an interrupted move)
  */
 void Planner::sync_from_steppers() {
   LOOP_XYZE(i)
     position[i] = stepper.position((AxisEnum)i);
 }

commit b3daf6b5db951abeda8246d207faf27474465784
Author: AnHardt <github@kitelab.de>
Date:   Sat Dec 9 04:38:45 2017 +0100

    [2.0.x] better reverse pass (#8722)
    
    * repair reverse_pass()
    
    And make it readeble.
    This was broken a long time ago.
    Not competely unfunctional but far from optimal.
    
    * Minor speedup when calling calculate_trapezoid_for_block
    
    2 float / to 1 foat / and 2 float *
    
    * Various style changes

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7f6ba21272..3bf6fa5a76 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -251,66 +251,60 @@ void Planner::calculate_trapezoid_for_block(block_t* const block, const float &e
 // "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.
 // This method will calculate the junction jerk as the euclidean distance between the nominal
 // velocities of the respective blocks.
 //inline float junction_jerk(block_t *before, block_t *after) {
 //  return SQRT(
 //    POW((before->speed_x-after->speed_x), 2)+POW((before->speed_y-after->speed_y), 2));
 //}
 
 
 // The kernel called by recalculate() when scanning the plan from last to first entry.
-void Planner::reverse_pass_kernel(block_t* const current, const block_t *next) {
+void Planner::reverse_pass_kernel(block_t* const current, const block_t * const next) {
   if (!current || !next) return;
   // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.
   // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and
   // check for maximum allowable speed reductions to ensure maximum possible planned speed.
   float max_entry_speed = current->max_entry_speed;
   if (current->entry_speed != max_entry_speed) {
     // If nominal length true, max junction speed is guaranteed to be reached. Only compute
     // for max allowable speed if block is decelerating and nominal length is false.
     current->entry_speed = (TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH) || max_entry_speed <= next->entry_speed)
       ? max_entry_speed
       : min(max_entry_speed, max_allowable_speed(-current->acceleration, next->entry_speed, current->millimeters));
     SBI(current->flag, BLOCK_BIT_RECALCULATE);
   }
 }
 
 /**
  * recalculate() needs to go over the current plan twice.
  * Once in reverse and once forward. This implements the reverse pass.
  */
 void Planner::reverse_pass() {
-
   if (movesplanned() > 3) {
-
-    block_t* block[3] = { NULL, NULL, NULL };
-
-    // Make a local copy of block_buffer_tail, because the interrupt can alter it
-    // Is a critical section REALLY needed for a single byte change?
-    //CRITICAL_SECTION_START;
-    uint8_t tail = block_buffer_tail;
-    //CRITICAL_SECTION_END
-
-    uint8_t b = BLOCK_MOD(block_buffer_head - 3);
-    while (b != tail) {
-      if (block[0] && TEST(block[0]->flag, BLOCK_BIT_START_FROM_FULL_HALT)) break;
-      b = prev_block_index(b);
-      block[2] = block[1];
-      block[1] = block[0];
-      block[0] = &block_buffer[b];
-      reverse_pass_kernel(block[1], block[2]);
-    }
+    const uint8_t endnr = BLOCK_MOD(block_buffer_tail + 2); // tail is running. tail+1 shouldn't be altered because it's connected to the running block.
+                                                            // tail+2 because the index is not yet advanced when checked
+    uint8_t blocknr = prev_block_index(block_buffer_head);
+    block_t* current = &block_buffer[blocknr];
+
+    do {
+      const block_t * const next = current;
+      blocknr = prev_block_index(blocknr);
+      current = &block_buffer[blocknr];
+      if (TEST(current->flag, BLOCK_BIT_START_FROM_FULL_HALT)) // Up to this every block is already optimized.
+        break;
+      reverse_pass_kernel(current, next);
+    } while (blocknr != endnr);
   }
 }
 
 // The kernel called by recalculate() when scanning the plan from first to last entry.
-void Planner::forward_pass_kernel(const block_t* previous, block_t* const current) {
+void Planner::forward_pass_kernel(const block_t * const previous, block_t* const current) {
   if (!previous) return;
 
   // If the previous block is an acceleration block, but it is not long enough to complete the
   // full speed change within the block, we need to adjust the entry speed accordingly. Entry
   // speeds have already been reset, maximized, and reverse planned by reverse planner.
   // If nominal length is true, max junction speed is guaranteed to be reached. No need to recheck.
   if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH)) {
     if (previous->entry_speed < current->entry_speed) {
       float entry_speed = min(current->entry_speed,
                                max_allowable_speed(-previous->acceleration, previous->entry_speed, previous->millimeters));
@@ -348,31 +342,31 @@ void Planner::recalculate_trapezoids() {
   int8_t block_index = block_buffer_tail;
   block_t *current, *next = NULL;
 
   while (block_index != block_buffer_head) {
     current = next;
     next = &block_buffer[block_index];
     if (current) {
       // Recalculate if current block entry or exit junction speed has changed.
       if (TEST(current->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
         // NOTE: Entry and exit factors always > 0 by all previous logic operations.
-        float nom = current->nominal_speed;
-        calculate_trapezoid_for_block(current, current->entry_speed / nom, next->entry_speed / nom);
+        const float nomr = 1.0 / current->nominal_speed;
+        calculate_trapezoid_for_block(current, current->entry_speed * nomr, next->entry_speed * nomr);
         CBI(current->flag, BLOCK_BIT_RECALCULATE); // Reset current only to ensure next trapezoid is computed
       }
     }
     block_index = next_block_index(block_index);
   }
   // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
   if (next) {
-    float nom = next->nominal_speed;
-    calculate_trapezoid_for_block(next, next->entry_speed / nom, (MINIMUM_PLANNER_SPEED) / nom);
+    const float nomr = 1.0 / next->nominal_speed;
+    calculate_trapezoid_for_block(next, next->entry_speed * nomr, (MINIMUM_PLANNER_SPEED) * nomr);
     CBI(next->flag, BLOCK_BIT_RECALCULATE);
   }
 }
 
 /*
  * Recalculate the motion plan according to the following algorithm:
  *
  *   1. Go over every block in reverse order...
  *
  *      Calculate a junction speed reduction (block_t.entry_factor) so:
@@ -1013,21 +1007,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
         sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS])
       #elif CORE_IS_XZ
         sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
       #elif CORE_IS_YZ
         sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
       #else
         sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS])
       #endif
     );
   }
-  float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
+  const float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate inverse time for this move. No divide by zero due to previous checks.
   // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   float inverse_secs = fr_mm_s * inverse_millimeters;
 
   const uint8_t moves_queued = movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time im micro seconds
@@ -1052,21 +1046,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
       block_buffer_runtime_us += segment_time_us;
     CRITICAL_SECTION_END
   #endif
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     static float filwidth_e_count = 0, filwidth_delay_dist = 0;
 
     //FMM update ring buffer used for delay with filament measurements
     if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && filwidth_delay_index[1] >= 0) {  //only for extruder with filament sensor and if ring buffer is initialized
 
-      const int MMD_CM = MAX_MEASUREMENT_DELAY + 1, MMD_MM = MMD_CM * 10;
+      constexpr int MMD_CM = MAX_MEASUREMENT_DELAY + 1, MMD_MM = MMD_CM * 10;
 
       // increment counters with next move in e axis
       filwidth_e_count += delta_mm[E_AXIS];
       filwidth_delay_dist += delta_mm[E_AXIS];
 
       // Only get new measurements on forward E movement
       if (!UNEAR_ZERO(filwidth_e_count)) {
 
         // Loop the delay distance counter (modulus by the mm length)
         while (filwidth_delay_dist >= MMD_MM) filwidth_delay_dist -= MMD_MM;
@@ -1349,27 +1343,28 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
     if (block->use_advance_lead)
       block->abs_adv_steps_multiplier8 = LROUND(
         extruder_advance_k
         * (UNEAR_ZERO(advance_ed_ratio) ? de * steps_to_mm[E_AXIS_N] / HYPOT(da * steps_to_mm[X_AXIS], db * steps_to_mm[Y_AXIS]) : advance_ed_ratio) // Use the fixed ratio, if set
         * (block->nominal_speed / (float)block->nominal_rate)
         * axis_steps_per_mm[E_AXIS_N] * 256.0
       );
 
   #endif // LIN_ADVANCE
 
-  calculate_trapezoid_for_block(block, block->entry_speed / block->nominal_speed, safe_speed / block->nominal_speed);
+  const float bnsr = 1.0 / block->nominal_speed;
+  calculate_trapezoid_for_block(block, block->entry_speed * bnsr, safe_speed * bnsr);
 
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
   // Update the position (only when a move was queued)
-  static_assert(COUNT(target) > 1, "array as function parameter should be declared as reference and with count");
+  static_assert(COUNT(target) > 1, "Parameter to _buffer_steps must be (&target)[XYZE]!");
   COPY(position, target);
 
   recalculate();
 
 } // _buffer_steps()
 
 /**
  * Planner::_buffer_line
  *
  * Add a new linear movement to the buffer in axis units.

commit 65d0f32f821782a9507c6432c585389685719790
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Fri Dec 8 18:14:27 2017 -0600

    divide only when required

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index bc84657bf2..7f6ba21272 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1085,21 +1085,22 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
         }
       }
     }
   #endif
 
   // Calculate and limit speed in mm/sec for each axis, calculate minimum acceleration ratio
   float current_speed[NUM_AXIS], speed_factor = 1.0; // factor <1 decreases speed
   float max_stepper_speed = 0, min_axis_accel_ratio = 1; // ratio < 1 means acceleration ramp needed
   LOOP_XYZE(i) {
     const float cs = FABS((current_speed[i] = delta_mm[i] * inverse_secs));
-    NOMORE(min_axis_accel_ratio, max_jerk[i] / cs);
+    if (cs >  max_jerk[i]) 
+      NOMORE(min_axis_accel_ratio, max_jerk[i] / cs);
     NOLESS(max_stepper_speed, cs);
     #if ENABLED(DISTINCT_E_FACTORS)
       if (i == E_AXIS) i += extruder;
     #endif
     if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
   }
 
   // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT
 

commit 85c6ffbe0d411cd223f345705e2b1235239bd91e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Dec 7 23:03:36 2017 -0600

    Discard all "continued" blocks on interrupted move

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7ca6965025..bc84657bf2 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -782,21 +782,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
   const uint8_t next_buffer_head = next_block_index(block_buffer_head);
 
   // If the buffer is full: good! That means we are well ahead of the robot.
   // Rest here until there is room in the buffer.
   while (block_buffer_tail == next_buffer_head) idle();
 
   // Prepare to set up new block
   block_t* block = &block_buffer[block_buffer_head];
 
   // Clear all flags, including the "busy" bit
-  block->flag = 0;
+  block->flag = 0x00;
 
   // Set direction bits
   block->direction_bits = dm;
 
   // Number of steps for each axis
   // See http://www.corexy.com/theory.html
   #if CORE_IS_XY
     block->steps[A_AXIS] = labs(da + db);
     block->steps[B_AXIS] = labs(da - db);
     block->steps[Z_AXIS] = labs(dc);
@@ -1428,21 +1428,23 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
   // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
   if (DEBUGGING(DRYRUN))
     position[E_AXIS] = target[E_AXIS];
 
   // Always split the first move into two (if not homing or probing)
   if (!blocks_queued()) {
     #define _BETWEEN(A) (position[A##_AXIS] + target[A##_AXIS]) >> 1
     const int32_t between[XYZE] = { _BETWEEN(X), _BETWEEN(Y), _BETWEEN(Z), _BETWEEN(E) };
     DISABLE_STEPPER_DRIVER_INTERRUPT();
     _buffer_steps(between, fr_mm_s, extruder);
+    const uint8_t next = block_buffer_head;
     _buffer_steps(target, fr_mm_s, extruder);
+    SBI(block_buffer[next].flag, BLOCK_BIT_CONTINUED);
     ENABLE_STEPPER_DRIVER_INTERRUPT();
   }
   else
     _buffer_steps(target, fr_mm_s, extruder);
 
   stepper.wake_up();
 
 } // _buffer_line()
 
 /**

commit 4e891e9fb7af63f1cf8691e0d6810b414d574e45
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 8 01:00:36 2017 -0600

    Followup to #8698

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 0bdd3ef303..7ca6965025 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1046,23 +1046,20 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
       }
     }
   #endif
 
   #if ENABLED(ULTRA_LCD)
     CRITICAL_SECTION_START
       block_buffer_runtime_us += segment_time_us;
     CRITICAL_SECTION_END
   #endif
 
-  block->nominal_speed = block->millimeters * inverse_secs;           //   (mm/sec) Always > 0
-  block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
-
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     static float filwidth_e_count = 0, filwidth_delay_dist = 0;
 
     //FMM update ring buffer used for delay with filament measurements
     if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && filwidth_delay_index[1] >= 0) {  //only for extruder with filament sensor and if ring buffer is initialized
 
       const int MMD_CM = MAX_MEASUREMENT_DELAY + 1, MMD_MM = MMD_CM * 10;
 
       // increment counters with next move in e axis
       filwidth_e_count += delta_mm[E_AXIS];

commit 3cd7659924830e5639737f92766f796c0b632f62
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 23:57:57 2017 -0600

    Improved Core-compatible jerk code

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index fc2dd2acd1..0bdd3ef303 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1083,24 +1083,27 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
           const uint8_t meas_sample = thermalManager.widthFil_to_size_ratio() - 100; // Subtract 100 to reduce magnitude - to store in a signed char
           do {
             filwidth_delay_index[1] = (filwidth_delay_index[1] + 1) % MMD_CM; // The next unused slot
             measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
           } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
         }
       }
     }
   #endif
 
-  // Calculate and limit speed in mm/sec for each axis
+  // Calculate and limit speed in mm/sec for each axis, calculate minimum acceleration ratio
   float current_speed[NUM_AXIS], speed_factor = 1.0; // factor <1 decreases speed
+  float max_stepper_speed = 0, min_axis_accel_ratio = 1; // ratio < 1 means acceleration ramp needed
   LOOP_XYZE(i) {
     const float cs = FABS((current_speed[i] = delta_mm[i] * inverse_secs));
+    NOMORE(min_axis_accel_ratio, max_jerk[i] / cs);
+    NOLESS(max_stepper_speed, cs);
     #if ENABLED(DISTINCT_E_FACTORS)
       if (i == E_AXIS) i += extruder;
     #endif
     if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
   }
 
   // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT
 
     // Check and limit the xy direction change frequency
@@ -1131,27 +1134,33 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
 
     const uint32_t max_x_segment_time = MAX3(xs0, xs1, xs2),
                    max_y_segment_time = MAX3(ys0, ys1, ys2),
                    min_xy_segment_time = min(max_x_segment_time, max_y_segment_time);
     if (min_xy_segment_time < MAX_FREQ_TIME_US) {
       const float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME_US);
       NOMORE(speed_factor, low_sf);
     }
   #endif // XY_FREQUENCY_LIMIT
 
+  block->nominal_speed = max_stepper_speed; // (mm/sec) Always > 0
+  block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
+
   // Correct the speed
   if (speed_factor < 1.0) {
     LOOP_XYZE(i) current_speed[i] *= speed_factor;
     block->nominal_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
   }
 
+  float safe_speed = block->nominal_speed * min_axis_accel_ratio;
+  static float previous_safe_speed;
+
   // Compute and limit the acceleration rate for the trapezoid generator.
   const float steps_per_mm = block->step_event_count * inverse_millimeters;
   uint32_t accel;
   if (!block->steps[X_AXIS] && !block->steps[Y_AXIS] && !block->steps[Z_AXIS]) {
     // convert to: acceleration steps/sec^2
     accel = CEIL(retract_acceleration * steps_per_mm);
   }
   else {
     #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
       if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
@@ -1239,58 +1248,32 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
         // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.
         if (cos_theta > -0.95) {
           // Compute maximum junction velocity based on maximum acceleration and junction deviation
           float sin_theta_d2 = SQRT(0.5 * (1.0 - cos_theta)); // Trig half angle identity. Always positive.
           NOMORE(vmax_junction, SQRT(block->acceleration * junction_deviation * sin_theta_d2 / (1.0 - sin_theta_d2)));
         }
       }
     }
   #endif
 
-  /**
-   * Adapted from Pr≈Ø≈°a MKS firmware
-   * https://github.com/prusa3d/Prusa-Firmware
-   *
-   * Start with a safe speed (from which the machine may halt to stop immediately).
-   */
-
-  // Exit speed limited by a jerk to full halt of a previous last segment
-  static float previous_safe_speed;
-
-  float safe_speed = block->nominal_speed;
-  uint8_t limited = 0;
-  LOOP_XYZE(i) {
-    const float jerk = FABS(current_speed[i]), maxj = max_jerk[i];
-    if (jerk > maxj) {
-      if (limited) {
-        const float mjerk = maxj * block->nominal_speed;
-        if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk;
-      }
-      else {
-        ++limited;
-        safe_speed = maxj;
-      }
-    }
-  }
-
   if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
     // Estimate a maximum velocity allowed at a joint of two successive segments.
     // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
     // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
 
     // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
     // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
     vmax_junction = min(block->nominal_speed, previous_nominal_speed);
 
     // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
     float v_factor = 1;
-    limited = 0;
+    uint8_t limited = 0;
 
     // Now limit the jerk in all axes.
     const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
     LOOP_XYZE(axis) {
       // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
       float v_exit = previous_speed[axis] * smaller_speed_factor,
             v_entry = current_speed[axis];
       if (limited) {
         v_exit *= v_factor;
         v_entry *= v_factor;

commit 840289e7ccaa79846acfdceee63ffc1baa77168c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 12:44:44 2017 -0600

    Use block cleaning instead of split flag

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 64f11a8e02..fc2dd2acd1 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -96,22 +96,20 @@ volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next
                  Planner::block_buffer_tail = 0;
 
 float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
       Planner::axis_steps_per_mm[XYZE_N],
       Planner::steps_to_mm[XYZE_N];
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
-bool Planner::split_first_move = true;
-
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
 
 float Planner::e_factor[EXTRUDERS],               // The flow percentage and volumetric multiplier combine to scale E movement
       Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
       Planner::volumetric_area_nominal = CIRCLE_AREA((DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5), // Nominal cross-sectional area
       Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
 
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N],
          Planner::max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
 
@@ -1445,21 +1443,21 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
     SERIAL_ECHOPAIR(" (", position[E_AXIS]);
     SERIAL_ECHOPAIR("->", target[E_AXIS]);
     SERIAL_ECHOLNPGM(")");
   //*/
 
   // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
   if (DEBUGGING(DRYRUN))
     position[E_AXIS] = target[E_AXIS];
 
   // Always split the first move into two (if not homing or probing)
-  if (!blocks_queued() && split_first_move) {
+  if (!blocks_queued()) {
     #define _BETWEEN(A) (position[A##_AXIS] + target[A##_AXIS]) >> 1
     const int32_t between[XYZE] = { _BETWEEN(X), _BETWEEN(Y), _BETWEEN(Z), _BETWEEN(E) };
     DISABLE_STEPPER_DRIVER_INTERRUPT();
     _buffer_steps(between, fr_mm_s, extruder);
     _buffer_steps(target, fr_mm_s, extruder);
     ENABLE_STEPPER_DRIVER_INTERRUPT();
   }
   else
     _buffer_steps(target, fr_mm_s, extruder);
 

commit 2fde60da124fddb6cf2a8f15479680f3410b53af
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 16:56:30 2017 -0600

    Changes for parity with 1.1.x

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 007b1dadfc..64f11a8e02 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -128,29 +128,34 @@ float Planner::min_feedrate_mm_s,
 #if HAS_LEVELING
   bool Planner::leveling_active = false; // Flag that auto bed leveling is enabled
   #if ABL_PLANAR
     matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
   #endif
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
     float Planner::z_fade_height,      // Initialized by settings.load()
           Planner::inverse_z_fade_height,
           Planner::last_fade_z;
   #endif
+#else
+  constexpr bool Planner::leveling_active;
 #endif
 
 #if ENABLED(SKEW_CORRECTION)
   #if ENABLED(SKEW_CORRECTION_GCODE)
-    // Initialized by settings.load()
     float Planner::xy_skew_factor;
-    #if ENABLED(SKEW_CORRECTION_FOR_Z)
-      float Planner::xz_skew_factor, Planner::yz_skew_factor;
-    #endif
+  #else
+    constexpr float Planner::xy_skew_factor;
+  #endif
+  #if ENABLED(SKEW_CORRECTION_FOR_Z) && ENABLED(SKEW_CORRECTION_GCODE)
+    float Planner::xz_skew_factor, Planner::yz_skew_factor;
+  #else
+    constexpr float Planner::xz_skew_factor, Planner::yz_skew_factor;
   #endif
 #endif
 
 #if ENABLED(AUTOTEMP)
   float Planner::autotemp_max = 250,
         Planner::autotemp_min = 210,
         Planner::autotemp_factor = 0.1;
   bool Planner::autotemp_enabled = false;
 #endif
 

commit a993c5227d4b48106798b08b327a36a53d60d302
Author: AnHardt <github@kitelab.de>
Date:   Wed Dec 6 14:08:49 2017 +0100

    Don't split first_move while homing or probing
    While homing or probing it might be bad if the stop/trobe triggers during the first part and the second is still in the buffer.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e4e452c782..007b1dadfc 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -96,20 +96,22 @@ volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next
                  Planner::block_buffer_tail = 0;
 
 float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
       Planner::axis_steps_per_mm[XYZE_N],
       Planner::steps_to_mm[XYZE_N];
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
+bool Planner::split_first_move = true;
+
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
 
 float Planner::e_factor[EXTRUDERS],               // The flow percentage and volumetric multiplier combine to scale E movement
       Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
       Planner::volumetric_area_nominal = CIRCLE_AREA((DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5), // Nominal cross-sectional area
       Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
 
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N],
          Planner::max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
 
@@ -1437,22 +1439,22 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
     SERIAL_ECHOPAIR(") E:", e);
     SERIAL_ECHOPAIR(" (", position[E_AXIS]);
     SERIAL_ECHOPAIR("->", target[E_AXIS]);
     SERIAL_ECHOLNPGM(")");
   //*/
 
   // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
   if (DEBUGGING(DRYRUN))
     position[E_AXIS] = target[E_AXIS];
 
-  // Always split the first move into one longer and one shorter move
-  if (!blocks_queued()) {
+  // Always split the first move into two (if not homing or probing)
+  if (!blocks_queued() && split_first_move) {
     #define _BETWEEN(A) (position[A##_AXIS] + target[A##_AXIS]) >> 1
     const int32_t between[XYZE] = { _BETWEEN(X), _BETWEEN(Y), _BETWEEN(Z), _BETWEEN(E) };
     DISABLE_STEPPER_DRIVER_INTERRUPT();
     _buffer_steps(between, fr_mm_s, extruder);
     _buffer_steps(target, fr_mm_s, extruder);
     ENABLE_STEPPER_DRIVER_INTERRUPT();
   }
   else
     _buffer_steps(target, fr_mm_s, extruder);
 

commit 5fbb2f121e9dac99ba9a28e77f82591e4919b0a7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 5 20:27:20 2017 -0600

    Remove skew warning that could crash the planner

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 0bfff8de27..e4e452c782 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -581,22 +581,20 @@ void Planner::calculate_volumetric_multipliers() {
   void Planner::apply_leveling(float &rx, float &ry, float &rz) {
 
     #if ENABLED(SKEW_CORRECTION)
       if (WITHIN(rx, X_MIN_POS + 1, X_MAX_POS) && WITHIN(ry, Y_MIN_POS + 1, Y_MAX_POS)) {
         const float tempry = ry - (rz * planner.yz_skew_factor),
                     temprx = rx - (ry * planner.xy_skew_factor) - (rz * (planner.xz_skew_factor - (planner.xy_skew_factor * planner.yz_skew_factor)));
         if (WITHIN(temprx, X_MIN_POS, X_MAX_POS) && WITHIN(tempry, Y_MIN_POS, Y_MAX_POS)) {
           rx = temprx;
           ry = tempry;
         }
-        else
-          SERIAL_ECHOLN(MSG_SKEW_WARN);
       }
     #endif
 
     if (!leveling_active) return;
 
     #if ABL_PLANAR
 
       float dx = rx - (X_TILT_FULCRUM),
             dy = ry - (Y_TILT_FULCRUM);
 

commit d8b444c14493bde04edc64ee0b055dd292b2f17d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 5 18:55:57 2017 -0600

    Cleanup constextpr in planner.cpp

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 5782db4454..0bfff8de27 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -134,25 +134,21 @@ float Planner::min_feedrate_mm_s,
           Planner::last_fade_z;
   #endif
 #endif
 
 #if ENABLED(SKEW_CORRECTION)
   #if ENABLED(SKEW_CORRECTION_GCODE)
     // Initialized by settings.load()
     float Planner::xy_skew_factor;
     #if ENABLED(SKEW_CORRECTION_FOR_Z)
       float Planner::xz_skew_factor, Planner::yz_skew_factor;
-    #else
-      constexpr float Planner::xz_skew_factor, Planner::yz_skew_factor;
     #endif
-  #else
-    constexpr float Planner::xy_skew_factor, Planner::xz_skew_factor, Planner::yz_skew_factor;
   #endif
 #endif
 
 #if ENABLED(AUTOTEMP)
   float Planner::autotemp_max = 250,
         Planner::autotemp_min = 210,
         Planner::autotemp_factor = 0.1;
   bool Planner::autotemp_enabled = false;
 #endif
 

commit 53694ebaa18551efc847bfbb0df0c85674c175cf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Dec 4 18:55:23 2017 -0600

    Folllwup to planner splitting

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e4f7e62f72..5782db4454 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1221,21 +1221,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
        indirectly by junction deviation.
 
        This may be also viewed as path width or max_jerk in the previous grbl version. This approach
        does not actually deviate from path, but used as a robust way to compute cornering speeds, as
        it takes into account the nonlinearities of both the junction angle and junction velocity.
      */
 
     vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed
 
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
-    if (moves_queued() && !UNEAR_ZERO(previous_nominal_speed)) {
+    if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
       const float cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
                               - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
                               - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS];
       // Skip and use default max junction speed for 0 degree acute junction.
       if (cos_theta < 0.95) {
         vmax_junction = min(previous_nominal_speed, block->nominal_speed);
         // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.
         if (cos_theta > -0.95) {
@@ -1266,21 +1266,21 @@ void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const
         const float mjerk = maxj * block->nominal_speed;
         if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk;
       }
       else {
         ++limited;
         safe_speed = maxj;
       }
     }
   }
 
-  if (moves_queued > 1 && !UNEAR_ZERO(previous_nominal_speed)) {
+  if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
     // Estimate a maximum velocity allowed at a joint of two successive segments.
     // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
     // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
 
     // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
     // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
     vmax_junction = min(block->nominal_speed, previous_nominal_speed);
 
     // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
     float v_factor = 1;

commit 4b612f590c730a1e8b757da717dbba45debb45e7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 30 16:40:42 2017 -0600

    Split first move to planner for better chaining

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 44065e82fa..e4f7e62f72 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -573,20 +573,21 @@ inline float calculate_volumetric_multiplier(const float &diameter) {
 void Planner::calculate_volumetric_multipliers() {
   for (uint8_t i = 0; i < COUNT(filament_size); i++) {
     volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
     refresh_e_factor(i);
   }
 }
 
 #if PLANNER_LEVELING
   /**
    * rx, ry, rz - Cartesian positions in mm
+   *              Leveled XYZ on completion
    */
   void Planner::apply_leveling(float &rx, float &ry, float &rz) {
 
     #if ENABLED(SKEW_CORRECTION)
       if (WITHIN(rx, X_MIN_POS + 1, X_MAX_POS) && WITHIN(ry, Y_MIN_POS + 1, Y_MAX_POS)) {
         const float tempry = ry - (rz * planner.yz_skew_factor),
                     temprx = rx - (ry * planner.xy_skew_factor) - (rz * (planner.xz_skew_factor - (planner.xy_skew_factor * planner.yz_skew_factor)));
         if (WITHIN(temprx, X_MIN_POS, X_MAX_POS) && WITHIN(tempry, Y_MIN_POS, Y_MAX_POS)) {
           rx = temprx;
           ry = tempry;
@@ -615,21 +616,21 @@ void Planner::calculate_volumetric_multipliers() {
         if (!fade_scaling_factor) return;
       #elif HAS_MESH
         constexpr float fade_scaling_factor = 1.0;
       #endif
 
       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
         const float raw[XYZ] = { rx, ry, 0 };
       #endif
 
       rz += (
-        #if ENABLED(AUTO_BED_LEVELING_UBL)
+        #if ENABLED(AUTO_BED_LEVELING_UBL) // UBL_DELTA
           ubl.get_z_correction(rx, ry) * fade_scaling_factor
         #elif ENABLED(MESH_BED_LEVELING)
           mbl.get_z(rx, ry
             #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
               , fade_scaling_factor
             #endif
           )
         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
           bilinear_z_offset(raw) * fade_scaling_factor
         #else
@@ -691,83 +692,49 @@ void Planner::calculate_volumetric_multipliers() {
           raw[X_AXIS] = temprx;
           raw[Y_AXIS] = tempry;
         }
       }
     #endif
   }
 
 #endif // PLANNER_LEVELING
 
 /**
- * Planner::_buffer_line
- *
- * Add a new linear movement to the buffer in axis units.
+ * Planner::_buffer_steps
  *
- * Leveling and kinematics should be applied ahead of calling this.
+ * Add a new linear movement to the buffer (in terms of steps).
  *
- *  a,b,c,e   - target positions in mm and/or degrees
- *  fr_mm_s   - (target) speed of the move
- *  extruder  - target extruder
+ *  target      - target position in steps units
+ *  fr_mm_s     - (target) speed of the move
+ *  extruder    - target extruder
  */
-void Planner::_buffer_line(const float &a, const float &b, const float &c, const float &e, float fr_mm_s, const uint8_t extruder) {
-
-  // The target position of the tool in absolute steps
-  // Calculate target position in absolute steps
-  //this should be done after the wait, because otherwise a M92 code within the gcode disrupts this calculation somehow
-  const long target[XYZE] = {
-    LROUND(a * axis_steps_per_mm[X_AXIS]),
-    LROUND(b * axis_steps_per_mm[Y_AXIS]),
-    LROUND(c * axis_steps_per_mm[Z_AXIS]),
-    LROUND(e * axis_steps_per_mm[E_AXIS_N])
-  };
-
-  // When changing extruders recalculate steps corresponding to the E position
-  #if ENABLED(DISTINCT_E_FACTORS)
-    if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
-      position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
-      last_extruder = extruder;
-    }
-  #endif
+void Planner::_buffer_steps(const int32_t (&target)[XYZE], float fr_mm_s, const uint8_t extruder) {
 
   const int32_t da = target[X_AXIS] - position[X_AXIS],
                 db = target[Y_AXIS] - position[Y_AXIS],
                 dc = target[Z_AXIS] - position[Z_AXIS];
 
-  /*
-  SERIAL_ECHOPAIR("  Planner FR:", fr_mm_s);
-  SERIAL_CHAR(' ');
-  #if IS_KINEMATIC
-    SERIAL_ECHOPAIR("A:", a);
-    SERIAL_ECHOPAIR(" (", da);
-    SERIAL_ECHOPAIR(") B:", b);
-  #else
-    SERIAL_ECHOPAIR("X:", a);
+  int32_t de = target[E_AXIS] - position[E_AXIS];
+
+  /* <-- add a slash to enable
+    SERIAL_ECHOPAIR("  _buffer_steps FR:", fr_mm_s);
+    SERIAL_ECHOPAIR(" A:", target[A_AXIS]);
     SERIAL_ECHOPAIR(" (", da);
-    SERIAL_ECHOPAIR(") Y:", b);
-  #endif
-  SERIAL_ECHOPAIR(" (", db);
-  #if ENABLED(DELTA)
-    SERIAL_ECHOPAIR(") C:", c);
-  #else
-    SERIAL_ECHOPAIR(") Z:", c);
-  #endif
-  SERIAL_ECHOPAIR(" (", dc);
-  SERIAL_CHAR(')');
-  SERIAL_EOL();
+    SERIAL_ECHOPAIR(" steps) B:", target[B_AXIS]);
+    SERIAL_ECHOPAIR(" (", db);
+    SERIAL_ECHOPAIR(" steps) C:", target[C_AXIS]);
+    SERIAL_ECHOPAIR(" (", dc);
+    SERIAL_ECHOPAIR(" steps) E:", target[E_AXIS]);
+    SERIAL_ECHOPAIR(" (", de);
+    SERIAL_ECHOLNPGM(" steps)");
   //*/
 
-  // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
-  if (DEBUGGING(DRYRUN))
-    position[E_AXIS] = target[E_AXIS];
-
-  int32_t de = target[E_AXIS] - position[E_AXIS];
-
   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
@@ -1060,20 +1027,21 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
   // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   float inverse_secs = fr_mm_s * inverse_millimeters;
 
   const uint8_t moves_queued = movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time im micro seconds
     uint32_t segment_time_us = LROUND(1000000.0 / inverse_secs);
   #endif
+
   #if ENABLED(SLOWDOWN)
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
       if (segment_time_us < min_segment_time_us) {
         // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
         const uint32_t nst = segment_time_us + LROUND(2 * (min_segment_time_us - segment_time_us) / moves_queued);
         inverse_secs = 1000000.0 / nst;
         #if defined(XY_FREQUENCY_LIMIT) || ENABLED(ULTRA_LCD)
           segment_time_us = nst;
         #endif
       }
@@ -1307,26 +1275,26 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
 
   if (moves_queued > 1 && !UNEAR_ZERO(previous_nominal_speed)) {
     // Estimate a maximum velocity allowed at a joint of two successive segments.
     // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
     // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
 
     // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
     // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
     vmax_junction = min(block->nominal_speed, previous_nominal_speed);
 
-    const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
-
     // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
     float v_factor = 1;
     limited = 0;
+
     // Now limit the jerk in all axes.
+    const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
     LOOP_XYZE(axis) {
       // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
       float v_exit = previous_speed[axis] * smaller_speed_factor,
             v_entry = current_speed[axis];
       if (limited) {
         v_exit *= v_factor;
         v_entry *= v_factor;
       }
 
       // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
@@ -1407,27 +1375,103 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
       );
 
   #endif // LIN_ADVANCE
 
   calculate_trapezoid_for_block(block, block->entry_speed / block->nominal_speed, safe_speed / block->nominal_speed);
 
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
   // Update the position (only when a move was queued)
+  static_assert(COUNT(target) > 1, "array as function parameter should be declared as reference and with count");
   COPY(position, target);
 
   recalculate();
 
+} // _buffer_steps()
+
+/**
+ * Planner::_buffer_line
+ *
+ * Add a new linear movement to the buffer in axis units.
+ *
+ * Leveling and kinematics should be applied ahead of calling this.
+ *
+ *  a,b,c,e   - target positions in mm and/or degrees
+ *  fr_mm_s   - (target) speed of the move
+ *  extruder  - target extruder
+ */
+void Planner::_buffer_line(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder) {
+  // When changing extruders recalculate steps corresponding to the E position
+  #if ENABLED(DISTINCT_E_FACTORS)
+    if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
+      position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
+      last_extruder = extruder;
+    }
+  #endif
+
+  // The target position of the tool in absolute steps
+  // Calculate target position in absolute steps
+  const int32_t target[XYZE] = {
+    LROUND(a * axis_steps_per_mm[X_AXIS]),
+    LROUND(b * axis_steps_per_mm[Y_AXIS]),
+    LROUND(c * axis_steps_per_mm[Z_AXIS]),
+    LROUND(e * axis_steps_per_mm[E_AXIS_N])
+  };
+
+  /* <-- add a slash to enable
+    SERIAL_ECHOPAIR("  _buffer_line FR:", fr_mm_s);
+    #if IS_KINEMATIC
+      SERIAL_ECHOPAIR(" A:", a);
+      SERIAL_ECHOPAIR(" (", position[A_AXIS]);
+      SERIAL_ECHOPAIR("->", target[A_AXIS]);
+      SERIAL_ECHOPAIR(") B:", b);
+    #else
+      SERIAL_ECHOPAIR(" X:", a);
+      SERIAL_ECHOPAIR(" (", position[X_AXIS]);
+      SERIAL_ECHOPAIR("->", target[X_AXIS]);
+      SERIAL_ECHOPAIR(") Y:", b);
+    #endif
+    SERIAL_ECHOPAIR(" (", position[Y_AXIS]);
+    SERIAL_ECHOPAIR("->", target[Y_AXIS]);
+    #if ENABLED(DELTA)
+      SERIAL_ECHOPAIR(") C:", c);
+    #else
+      SERIAL_ECHOPAIR(") Z:", c);
+    #endif
+    SERIAL_ECHOPAIR(" (", position[Z_AXIS]);
+    SERIAL_ECHOPAIR("->", target[Z_AXIS]);
+    SERIAL_ECHOPAIR(") E:", e);
+    SERIAL_ECHOPAIR(" (", position[E_AXIS]);
+    SERIAL_ECHOPAIR("->", target[E_AXIS]);
+    SERIAL_ECHOLNPGM(")");
+  //*/
+
+  // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
+  if (DEBUGGING(DRYRUN))
+    position[E_AXIS] = target[E_AXIS];
+
+  // Always split the first move into one longer and one shorter move
+  if (!blocks_queued()) {
+    #define _BETWEEN(A) (position[A##_AXIS] + target[A##_AXIS]) >> 1
+    const int32_t between[XYZE] = { _BETWEEN(X), _BETWEEN(Y), _BETWEEN(Z), _BETWEEN(E) };
+    DISABLE_STEPPER_DRIVER_INTERRUPT();
+    _buffer_steps(between, fr_mm_s, extruder);
+    _buffer_steps(target, fr_mm_s, extruder);
+    ENABLE_STEPPER_DRIVER_INTERRUPT();
+  }
+  else
+    _buffer_steps(target, fr_mm_s, extruder);
+
   stepper.wake_up();
 
-} // buffer_line()
+} // _buffer_line()
 
 /**
  * Directly set the planner XYZ position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
 
 void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)

commit dd8febca1a29c08b002a31dd960279b28b7f2f12
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 3 16:52:48 2017 -0600

    Revert "Merge pull request #8611 from thinkyhead/bf2_planner_split_first"
    
    This reverts commit 824980e70eaec5598716b9bbfde1e98a5c1e2420, reversing
    changes made to aa7efb96bfffbbfc45d3a3e4a41810ef1b4b7c7a.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index bc0ffa9417..44065e82fa 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -691,49 +691,83 @@ void Planner::calculate_volumetric_multipliers() {
           raw[X_AXIS] = temprx;
           raw[Y_AXIS] = tempry;
         }
       }
     #endif
   }
 
 #endif // PLANNER_LEVELING
 
 /**
- * Planner::_buffer_steps
+ * Planner::_buffer_line
  *
- * Add a new linear movement to the buffer (in terms of steps).
+ * Add a new linear movement to the buffer in axis units.
  *
- *  target    - target position in steps units
+ * Leveling and kinematics should be applied ahead of calling this.
+ *
+ *  a,b,c,e   - target positions in mm and/or degrees
  *  fr_mm_s   - (target) speed of the move
  *  extruder  - target extruder
  */
-void Planner::_buffer_steps(const int32_t target[XYZE], float fr_mm_s, const uint8_t extruder) {
+void Planner::_buffer_line(const float &a, const float &b, const float &c, const float &e, float fr_mm_s, const uint8_t extruder) {
+
+  // The target position of the tool in absolute steps
+  // Calculate target position in absolute steps
+  //this should be done after the wait, because otherwise a M92 code within the gcode disrupts this calculation somehow
+  const long target[XYZE] = {
+    LROUND(a * axis_steps_per_mm[X_AXIS]),
+    LROUND(b * axis_steps_per_mm[Y_AXIS]),
+    LROUND(c * axis_steps_per_mm[Z_AXIS]),
+    LROUND(e * axis_steps_per_mm[E_AXIS_N])
+  };
+
+  // When changing extruders recalculate steps corresponding to the E position
+  #if ENABLED(DISTINCT_E_FACTORS)
+    if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
+      position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
+      last_extruder = extruder;
+    }
+  #endif
 
   const int32_t da = target[X_AXIS] - position[X_AXIS],
                 db = target[Y_AXIS] - position[Y_AXIS],
                 dc = target[Z_AXIS] - position[Z_AXIS];
 
-  int32_t de = target[E_AXIS] - position[E_AXIS];
-
-  /* <-- add a slash to enable
-    SERIAL_ECHOPAIR("  _buffer_steps FR:", fr_mm_s);
-    SERIAL_ECHOPAIR(" A:", target[A_AXIS]);
+  /*
+  SERIAL_ECHOPAIR("  Planner FR:", fr_mm_s);
+  SERIAL_CHAR(' ');
+  #if IS_KINEMATIC
+    SERIAL_ECHOPAIR("A:", a);
+    SERIAL_ECHOPAIR(" (", da);
+    SERIAL_ECHOPAIR(") B:", b);
+  #else
+    SERIAL_ECHOPAIR("X:", a);
     SERIAL_ECHOPAIR(" (", da);
-    SERIAL_ECHOPAIR(" steps) B:", target[B_AXIS]);
-    SERIAL_ECHOPAIR(" (", db);
-    SERIAL_ECHOLNPGM(" steps) C:", target[C_AXIS]);
-    SERIAL_ECHOPAIR(" (", dc);
-    SERIAL_ECHOLNPGM(" steps) E:", target[E_AXIS]);
-    SERIAL_ECHOPAIR(" (", de);
-    SERIAL_ECHOLNPGM(" steps)");
+    SERIAL_ECHOPAIR(") Y:", b);
+  #endif
+  SERIAL_ECHOPAIR(" (", db);
+  #if ENABLED(DELTA)
+    SERIAL_ECHOPAIR(") C:", c);
+  #else
+    SERIAL_ECHOPAIR(") Z:", c);
+  #endif
+  SERIAL_ECHOPAIR(" (", dc);
+  SERIAL_CHAR(')');
+  SERIAL_EOL();
   //*/
 
+  // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
+  if (DEBUGGING(DRYRUN))
+    position[E_AXIS] = target[E_AXIS];
+
+  int32_t de = target[E_AXIS] - position[E_AXIS];
+
   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
@@ -1026,21 +1060,20 @@ void Planner::_buffer_steps(const int32_t target[XYZE], float fr_mm_s, const uin
   // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   float inverse_secs = fr_mm_s * inverse_millimeters;
 
   const uint8_t moves_queued = movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time im micro seconds
     uint32_t segment_time_us = LROUND(1000000.0 / inverse_secs);
   #endif
-
   #if ENABLED(SLOWDOWN)
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
       if (segment_time_us < min_segment_time_us) {
         // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
         const uint32_t nst = segment_time_us + LROUND(2 * (min_segment_time_us - segment_time_us) / moves_queued);
         inverse_secs = 1000000.0 / nst;
         #if defined(XY_FREQUENCY_LIMIT) || ENABLED(ULTRA_LCD)
           segment_time_us = nst;
         #endif
       }
@@ -1220,26 +1253,26 @@ void Planner::_buffer_steps(const int32_t target[XYZE], float fr_mm_s, const uin
        indirectly by junction deviation.
 
        This may be also viewed as path width or max_jerk in the previous grbl version. This approach
        does not actually deviate from path, but used as a robust way to compute cornering speeds, as
        it takes into account the nonlinearities of both the junction angle and junction velocity.
      */
 
     vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed
 
     // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
-    if (block_buffer_head != block_buffer_tail && previous_nominal_speed > 0.0) {
+    if (moves_queued() && !UNEAR_ZERO(previous_nominal_speed)) {
       // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
       // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
-      float cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
-                        - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
-                        - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS] ;
+      const float cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
+                              - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
+                              - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS];
       // Skip and use default max junction speed for 0 degree acute junction.
       if (cos_theta < 0.95) {
         vmax_junction = min(previous_nominal_speed, block->nominal_speed);
         // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.
         if (cos_theta > -0.95) {
           // Compute maximum junction velocity based on maximum acceleration and junction deviation
           float sin_theta_d2 = SQRT(0.5 * (1.0 - cos_theta)); // Trig half angle identity. Always positive.
           NOMORE(vmax_junction, SQRT(block->acceleration * junction_deviation * sin_theta_d2 / (1.0 - sin_theta_d2)));
         }
       }
@@ -1265,38 +1298,39 @@ void Planner::_buffer_steps(const int32_t target[XYZE], float fr_mm_s, const uin
         const float mjerk = maxj * block->nominal_speed;
         if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk;
       }
       else {
         ++limited;
         safe_speed = maxj;
       }
     }
   }
 
-  if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
+  if (moves_queued > 1 && !UNEAR_ZERO(previous_nominal_speed)) {
     // Estimate a maximum velocity allowed at a joint of two successive segments.
     // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
     // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
 
     // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
-    const bool prev_speed_larger = previous_nominal_speed > block->nominal_speed;
-    const float smaller_speed_factor = prev_speed_larger ? (block->nominal_speed / previous_nominal_speed) : (previous_nominal_speed / block->nominal_speed);
     // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
-    vmax_junction = prev_speed_larger ? block->nominal_speed : previous_nominal_speed;
+    vmax_junction = min(block->nominal_speed, previous_nominal_speed);
+
+    const float smaller_speed_factor = vmax_junction / previous_nominal_speed;
+
     // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
     float v_factor = 1;
     limited = 0;
     // Now limit the jerk in all axes.
     LOOP_XYZE(axis) {
       // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
-      float v_exit = previous_speed[axis], v_entry = current_speed[axis];
-      if (prev_speed_larger) v_exit *= smaller_speed_factor;
+      float v_exit = previous_speed[axis] * smaller_speed_factor,
+            v_entry = current_speed[axis];
       if (limited) {
         v_exit *= v_factor;
         v_entry *= v_factor;
       }
 
       // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
       const float jerk = (v_exit > v_entry)
           ? //                                  coasting             axis reversal
             ( (v_entry > 0 || v_exit < 0) ? (v_exit - v_entry) : max(v_exit, -v_entry) )
           : // v_exit <= v_entry                coasting             axis reversal
@@ -1377,93 +1411,23 @@ void Planner::_buffer_steps(const int32_t target[XYZE], float fr_mm_s, const uin
   calculate_trapezoid_for_block(block, block->entry_speed / block->nominal_speed, safe_speed / block->nominal_speed);
 
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
   // Update the position (only when a move was queued)
   COPY(position, target);
 
   recalculate();
 
-} // _buffer_steps()
-
-/**
- * Planner::_buffer_line
- *
- * Add a new linear movement to the buffer in axis units.
- *
- * Leveling and kinematics should be applied ahead of calling this.
- *
- *  a,b,c,e   - target positions in mm and/or degrees
- *  fr_mm_s   - (target) speed of the move
- *  extruder  - target extruder
- */
-void Planner::_buffer_line(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder) {
-  // When changing extruders recalculate steps corresponding to the E position
-  #if ENABLED(DISTINCT_E_FACTORS)
-    if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
-      position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
-      last_extruder = extruder;
-    }
-  #endif
-
-  // The target position of the tool in absolute steps
-  // Calculate target position in absolute steps
-  const int32_t target[XYZE] = {
-    LROUND(a * axis_steps_per_mm[X_AXIS]),
-    LROUND(b * axis_steps_per_mm[Y_AXIS]),
-    LROUND(c * axis_steps_per_mm[Z_AXIS]),
-    LROUND(e * axis_steps_per_mm[E_AXIS_N])
-  };
-
-  /* <-- add a slash to enable
-    SERIAL_ECHOPAIR("  _buffer_line FR:", fr_mm_s);
-    #if IS_KINEMATIC
-      SERIAL_ECHOPAIR(" A:", a);
-      SERIAL_ECHOPAIR(" (", target[A_AXIS]);
-      SERIAL_ECHOPAIR(" steps) B:", b);
-    #else
-      SERIAL_ECHOPAIR(" X:", a);
-      SERIAL_ECHOPAIR(" (", target[X_AXIS]);
-      SERIAL_ECHOPAIR(" steps) Y:", b);
-    #endif
-    SERIAL_ECHOPAIR(" (", target[Y_AXIS]);
-    #if ENABLED(DELTA)
-      SERIAL_ECHOPAIR(" steps) C:", c);
-    #else
-      SERIAL_ECHOPAIR(" steps) Z:", c);
-    #endif
-    SERIAL_ECHOPAIR(" (", target[Z_AXIS]);
-    SERIAL_ECHOPAIR(" steps) E:", e);
-    SERIAL_ECHOPAIR(" (", target[E_AXIS]);
-    SERIAL_ECHOLNPGM(" steps)");
-  //*/
-
-  // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
-  if (DEBUGGING(DRYRUN))
-    position[E_AXIS] = target[E_AXIS];
-
-  // Always split the first move in two so it can chain
-  if (!blocks_queued()) {
-    DISABLE_STEPPER_DRIVER_INTERRUPT();
-    #define _BETWEEN(A) (position[A##_AXIS] + target[A##_AXIS]) >> 1
-    const int32_t between[XYZE] = { _BETWEEN(X), _BETWEEN(Y), _BETWEEN(Z), _BETWEEN(E) };
-    _buffer_steps(between, fr_mm_s, extruder);
-    _buffer_steps(target, fr_mm_s, extruder);
-    ENABLE_STEPPER_DRIVER_INTERRUPT();
-  }
-  else
-    _buffer_steps(target, fr_mm_s, extruder);
-
   stepper.wake_up();
 
-} // _buffer_line()
+} // buffer_line()
 
 /**
  * Directly set the planner XYZ position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
 
 void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)

commit 3a97de52ef6bc178e34af54db70f803b4d6ab451
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 30 16:40:42 2017 -0600

    Split first move to planner for better chaining
    
    Address #8573, #8595

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 374e4e0a19..bc0ffa9417 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -691,83 +691,49 @@ void Planner::calculate_volumetric_multipliers() {
           raw[X_AXIS] = temprx;
           raw[Y_AXIS] = tempry;
         }
       }
     #endif
   }
 
 #endif // PLANNER_LEVELING
 
 /**
- * Planner::_buffer_line
+ * Planner::_buffer_steps
  *
- * Add a new linear movement to the buffer in axis units.
+ * Add a new linear movement to the buffer (in terms of steps).
  *
- * Leveling and kinematics should be applied ahead of calling this.
- *
- *  a,b,c,e   - target positions in mm and/or degrees
+ *  target    - target position in steps units
  *  fr_mm_s   - (target) speed of the move
  *  extruder  - target extruder
  */
-void Planner::_buffer_line(const float &a, const float &b, const float &c, const float &e, float fr_mm_s, const uint8_t extruder) {
-
-  // The target position of the tool in absolute steps
-  // Calculate target position in absolute steps
-  //this should be done after the wait, because otherwise a M92 code within the gcode disrupts this calculation somehow
-  const long target[XYZE] = {
-    LROUND(a * axis_steps_per_mm[X_AXIS]),
-    LROUND(b * axis_steps_per_mm[Y_AXIS]),
-    LROUND(c * axis_steps_per_mm[Z_AXIS]),
-    LROUND(e * axis_steps_per_mm[E_AXIS_N])
-  };
-
-  // When changing extruders recalculate steps corresponding to the E position
-  #if ENABLED(DISTINCT_E_FACTORS)
-    if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
-      position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
-      last_extruder = extruder;
-    }
-  #endif
+void Planner::_buffer_steps(const int32_t target[XYZE], float fr_mm_s, const uint8_t extruder) {
 
   const int32_t da = target[X_AXIS] - position[X_AXIS],
                 db = target[Y_AXIS] - position[Y_AXIS],
                 dc = target[Z_AXIS] - position[Z_AXIS];
 
-  /*
-  SERIAL_ECHOPAIR("  Planner FR:", fr_mm_s);
-  SERIAL_CHAR(' ');
-  #if IS_KINEMATIC
-    SERIAL_ECHOPAIR("A:", a);
-    SERIAL_ECHOPAIR(" (", da);
-    SERIAL_ECHOPAIR(") B:", b);
-  #else
-    SERIAL_ECHOPAIR("X:", a);
+  int32_t de = target[E_AXIS] - position[E_AXIS];
+
+  /* <-- add a slash to enable
+    SERIAL_ECHOPAIR("  _buffer_steps FR:", fr_mm_s);
+    SERIAL_ECHOPAIR(" A:", target[A_AXIS]);
     SERIAL_ECHOPAIR(" (", da);
-    SERIAL_ECHOPAIR(") Y:", b);
-  #endif
-  SERIAL_ECHOPAIR(" (", db);
-  #if ENABLED(DELTA)
-    SERIAL_ECHOPAIR(") C:", c);
-  #else
-    SERIAL_ECHOPAIR(") Z:", c);
-  #endif
-  SERIAL_ECHOPAIR(" (", dc);
-  SERIAL_CHAR(')');
-  SERIAL_EOL();
+    SERIAL_ECHOPAIR(" steps) B:", target[B_AXIS]);
+    SERIAL_ECHOPAIR(" (", db);
+    SERIAL_ECHOLNPGM(" steps) C:", target[C_AXIS]);
+    SERIAL_ECHOPAIR(" (", dc);
+    SERIAL_ECHOLNPGM(" steps) E:", target[E_AXIS]);
+    SERIAL_ECHOPAIR(" (", de);
+    SERIAL_ECHOLNPGM(" steps)");
   //*/
 
-  // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
-  if (DEBUGGING(DRYRUN))
-    position[E_AXIS] = target[E_AXIS];
-
-  int32_t de = target[E_AXIS] - position[E_AXIS];
-
   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
@@ -1060,20 +1026,21 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
   // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
   float inverse_secs = fr_mm_s * inverse_millimeters;
 
   const uint8_t moves_queued = movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time im micro seconds
     uint32_t segment_time_us = LROUND(1000000.0 / inverse_secs);
   #endif
+
   #if ENABLED(SLOWDOWN)
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
       if (segment_time_us < min_segment_time_us) {
         // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
         const uint32_t nst = segment_time_us + LROUND(2 * (min_segment_time_us - segment_time_us) / moves_queued);
         inverse_secs = 1000000.0 / nst;
         #if defined(XY_FREQUENCY_LIMIT) || ENABLED(ULTRA_LCD)
           segment_time_us = nst;
         #endif
       }
@@ -1298,21 +1265,21 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
         const float mjerk = maxj * block->nominal_speed;
         if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk;
       }
       else {
         ++limited;
         safe_speed = maxj;
       }
     }
   }
 
-  if (moves_queued > 1 && !UNEAR_ZERO(previous_nominal_speed)) {
+  if (moves_queued && !UNEAR_ZERO(previous_nominal_speed)) {
     // Estimate a maximum velocity allowed at a joint of two successive segments.
     // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
     // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
 
     // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
     const bool prev_speed_larger = previous_nominal_speed > block->nominal_speed;
     const float smaller_speed_factor = prev_speed_larger ? (block->nominal_speed / previous_nominal_speed) : (previous_nominal_speed / block->nominal_speed);
     // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
     vmax_junction = prev_speed_larger ? block->nominal_speed : previous_nominal_speed;
     // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
@@ -1410,23 +1377,93 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
   calculate_trapezoid_for_block(block, block->entry_speed / block->nominal_speed, safe_speed / block->nominal_speed);
 
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
   // Update the position (only when a move was queued)
   COPY(position, target);
 
   recalculate();
 
+} // _buffer_steps()
+
+/**
+ * Planner::_buffer_line
+ *
+ * Add a new linear movement to the buffer in axis units.
+ *
+ * Leveling and kinematics should be applied ahead of calling this.
+ *
+ *  a,b,c,e   - target positions in mm and/or degrees
+ *  fr_mm_s   - (target) speed of the move
+ *  extruder  - target extruder
+ */
+void Planner::_buffer_line(const float &a, const float &b, const float &c, const float &e, const float &fr_mm_s, const uint8_t extruder) {
+  // When changing extruders recalculate steps corresponding to the E position
+  #if ENABLED(DISTINCT_E_FACTORS)
+    if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
+      position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
+      last_extruder = extruder;
+    }
+  #endif
+
+  // The target position of the tool in absolute steps
+  // Calculate target position in absolute steps
+  const int32_t target[XYZE] = {
+    LROUND(a * axis_steps_per_mm[X_AXIS]),
+    LROUND(b * axis_steps_per_mm[Y_AXIS]),
+    LROUND(c * axis_steps_per_mm[Z_AXIS]),
+    LROUND(e * axis_steps_per_mm[E_AXIS_N])
+  };
+
+  /* <-- add a slash to enable
+    SERIAL_ECHOPAIR("  _buffer_line FR:", fr_mm_s);
+    #if IS_KINEMATIC
+      SERIAL_ECHOPAIR(" A:", a);
+      SERIAL_ECHOPAIR(" (", target[A_AXIS]);
+      SERIAL_ECHOPAIR(" steps) B:", b);
+    #else
+      SERIAL_ECHOPAIR(" X:", a);
+      SERIAL_ECHOPAIR(" (", target[X_AXIS]);
+      SERIAL_ECHOPAIR(" steps) Y:", b);
+    #endif
+    SERIAL_ECHOPAIR(" (", target[Y_AXIS]);
+    #if ENABLED(DELTA)
+      SERIAL_ECHOPAIR(" steps) C:", c);
+    #else
+      SERIAL_ECHOPAIR(" steps) Z:", c);
+    #endif
+    SERIAL_ECHOPAIR(" (", target[Z_AXIS]);
+    SERIAL_ECHOPAIR(" steps) E:", e);
+    SERIAL_ECHOPAIR(" (", target[E_AXIS]);
+    SERIAL_ECHOLNPGM(" steps)");
+  //*/
+
+  // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
+  if (DEBUGGING(DRYRUN))
+    position[E_AXIS] = target[E_AXIS];
+
+  // Always split the first move in two so it can chain
+  if (!blocks_queued()) {
+    DISABLE_STEPPER_DRIVER_INTERRUPT();
+    #define _BETWEEN(A) (position[A##_AXIS] + target[A##_AXIS]) >> 1
+    const int32_t between[XYZE] = { _BETWEEN(X), _BETWEEN(Y), _BETWEEN(Z), _BETWEEN(E) };
+    _buffer_steps(between, fr_mm_s, extruder);
+    _buffer_steps(target, fr_mm_s, extruder);
+    ENABLE_STEPPER_DRIVER_INTERRUPT();
+  }
+  else
+    _buffer_steps(target, fr_mm_s, extruder);
+
   stepper.wake_up();
 
-} // buffer_line()
+} // _buffer_line()
 
 /**
  * Directly set the planner XYZ position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
  *
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
 
 void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)

commit 805612019553ad105b34760fbadf15abcea47187
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 2 20:17:51 2017 -0600

    Rename inverse_mm_s => inverse_secs

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 4712592c45..374e4e0a19 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -208,28 +208,32 @@ void Planner::init() {
  * by the provided factors.
  */
 void Planner::calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor) {
   uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
            final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
 
   // Limit minimal step rate (Otherwise the timer will overflow.)
   NOLESS(initial_rate, MINIMAL_STEP_RATE);
   NOLESS(final_rate, MINIMAL_STEP_RATE);
 
-  int32_t accel = block->acceleration_steps_per_s2,
-          accelerate_steps = CEIL(estimate_acceleration_distance(initial_rate, block->nominal_rate, accel)),
+  const int32_t accel = block->acceleration_steps_per_s2;
+
+          // Steps required for acceleration, deceleration to/from nominal rate
+  int32_t accelerate_steps = CEIL(estimate_acceleration_distance(initial_rate, block->nominal_rate, accel)),
           decelerate_steps = FLOOR(estimate_acceleration_distance(block->nominal_rate, final_rate, -accel)),
+          // Steps between acceleration and deceleration, if any
           plateau_steps = block->step_event_count - accelerate_steps - decelerate_steps;
 
-  // Is the Plateau of Nominal Rate smaller than nothing? That means no cruising, and we will
-  // have to use intersection_distance() to calculate when to abort accel and start braking
-  // in order to reach the final_rate exactly at the end of this block.
+  // Does accelerate_steps + decelerate_steps exceed step_event_count?
+  // Then we can't possibly reach the nominal rate, there will be no cruising.
+  // Use intersection_distance() to calculate accel / braking time in order to
+  // reach the final_rate exactly at the end of this block.
   if (plateau_steps < 0) {
     accelerate_steps = CEIL(intersection_distance(initial_rate, final_rate, accel, block->step_event_count));
     NOLESS(accelerate_steps, 0); // Check limits due to numerical round-off
     accelerate_steps = min((uint32_t)accelerate_steps, block->step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)
     plateau_steps = 0;
   }
 
   // block->accelerate_until = accelerate_steps;
   // block->decelerate_after = accelerate_steps+plateau_steps;
 
@@ -1045,51 +1049,52 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
         sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
       #elif CORE_IS_YZ
         sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
       #else
         sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS])
       #endif
     );
   }
   float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
 
-  // Calculate moves/second for this move. No divide by zero due to previous checks.
-  float inverse_mm_s = fr_mm_s * inverse_millimeters;
+  // Calculate inverse time for this move. No divide by zero due to previous checks.
+  // Example: At 120mm/s a 60mm move takes 0.5s. So this will give 2.0.
+  float inverse_secs = fr_mm_s * inverse_millimeters;
 
   const uint8_t moves_queued = movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time im micro seconds
-    uint32_t segment_time_us = LROUND(1000000.0 / inverse_mm_s);
+    uint32_t segment_time_us = LROUND(1000000.0 / inverse_secs);
   #endif
   #if ENABLED(SLOWDOWN)
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
       if (segment_time_us < min_segment_time_us) {
         // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
         const uint32_t nst = segment_time_us + LROUND(2 * (min_segment_time_us - segment_time_us) / moves_queued);
-        inverse_mm_s = 1000000.0 / nst;
+        inverse_secs = 1000000.0 / nst;
         #if defined(XY_FREQUENCY_LIMIT) || ENABLED(ULTRA_LCD)
           segment_time_us = nst;
         #endif
       }
     }
   #endif
 
   #if ENABLED(ULTRA_LCD)
     CRITICAL_SECTION_START
       block_buffer_runtime_us += segment_time_us;
     CRITICAL_SECTION_END
   #endif
 
-  block->nominal_speed = block->millimeters * inverse_mm_s; // (mm/sec) Always > 0
-  block->nominal_rate = CEIL(block->step_event_count * inverse_mm_s); // (step/sec) Always > 0
+  block->nominal_speed = block->millimeters * inverse_secs;           //   (mm/sec) Always > 0
+  block->nominal_rate = CEIL(block->step_event_count * inverse_secs); // (step/sec) Always > 0
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     static float filwidth_e_count = 0, filwidth_delay_dist = 0;
 
     //FMM update ring buffer used for delay with filament measurements
     if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && filwidth_delay_index[1] >= 0) {  //only for extruder with filament sensor and if ring buffer is initialized
 
       const int MMD_CM = MAX_MEASUREMENT_DELAY + 1, MMD_MM = MMD_CM * 10;
 
       // increment counters with next move in e axis
@@ -1114,21 +1119,21 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
             measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
           } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
         }
       }
     }
   #endif
 
   // Calculate and limit speed in mm/sec for each axis
   float current_speed[NUM_AXIS], speed_factor = 1.0; // factor <1 decreases speed
   LOOP_XYZE(i) {
-    const float cs = FABS((current_speed[i] = delta_mm[i] * inverse_mm_s));
+    const float cs = FABS((current_speed[i] = delta_mm[i] * inverse_secs));
     #if ENABLED(DISTINCT_E_FACTORS)
       if (i == E_AXIS) i += extruder;
     #endif
     if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
   }
 
   // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT
 
     // Check and limit the xy direction change frequency
@@ -1367,21 +1372,20 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
   block->flag |= BLOCK_FLAG_RECALCULATE | (block->nominal_speed <= v_allowable ? BLOCK_FLAG_NOMINAL_LENGTH : 0);
 
   // Update previous path unit_vector and nominal speed
   COPY(previous_speed, current_speed);
   previous_nominal_speed = block->nominal_speed;
   previous_safe_speed = safe_speed;
 
   #if ENABLED(LIN_ADVANCE)
-
     /**
      *
      * Use LIN_ADVANCE for blocks if all these are true:
      *
      * esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS]) : This is a print move
      *
      * extruder_advance_k                 : There is an advance factor set.
      *
      * esteps != block->step_event_count  : A problem occurs if the move before a retract is too small.
      *                                      In that case, the retract and move will be executed together.

commit 23557f8e778ce19f5f83b354a69472eb0ffe63b9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 2 20:19:07 2017 -0600

    Remove obsolete de_float

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 9b0fe167ca..4712592c45 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -771,24 +771,20 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
         if (labs(de * e_factor[extruder]) > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
-  #if ENABLED(LIN_ADVANCE)
-    float de_float = de * steps_to_mm[E_AXIS_N];
-  #endif
-
   // Compute direction bit-mask for this block
   uint8_t dm = 0;
   #if CORE_IS_XY
     if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
     if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
     if (dc < 0) SBI(dm, Z_AXIS);
     if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
     if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
   #elif CORE_IS_XZ
     if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis

commit 0154e3480c44bf9d96d662382da25afaaf3fd854
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 1 16:42:23 2017 -0600

    New feature: BED_SKEW_CORRECTION

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index a7e211aa3e..9b0fe167ca 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -128,20 +128,34 @@ float Planner::min_feedrate_mm_s,
   #if ABL_PLANAR
     matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
   #endif
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
     float Planner::z_fade_height,      // Initialized by settings.load()
           Planner::inverse_z_fade_height,
           Planner::last_fade_z;
   #endif
 #endif
 
+#if ENABLED(SKEW_CORRECTION)
+  #if ENABLED(SKEW_CORRECTION_GCODE)
+    // Initialized by settings.load()
+    float Planner::xy_skew_factor;
+    #if ENABLED(SKEW_CORRECTION_FOR_Z)
+      float Planner::xz_skew_factor, Planner::yz_skew_factor;
+    #else
+      constexpr float Planner::xz_skew_factor, Planner::yz_skew_factor;
+    #endif
+  #else
+    constexpr float Planner::xy_skew_factor, Planner::xz_skew_factor, Planner::yz_skew_factor;
+  #endif
+#endif
+
 #if ENABLED(AUTOTEMP)
   float Planner::autotemp_max = 250,
         Planner::autotemp_min = 210,
         Planner::autotemp_factor = 0.1;
   bool Planner::autotemp_enabled = false;
 #endif
 
 // private:
 
 int32_t Planner::position[NUM_AXIS] = { 0 };
@@ -558,20 +572,33 @@ void Planner::calculate_volumetric_multipliers() {
     refresh_e_factor(i);
   }
 }
 
 #if PLANNER_LEVELING
   /**
    * rx, ry, rz - Cartesian positions in mm
    */
   void Planner::apply_leveling(float &rx, float &ry, float &rz) {
 
+    #if ENABLED(SKEW_CORRECTION)
+      if (WITHIN(rx, X_MIN_POS + 1, X_MAX_POS) && WITHIN(ry, Y_MIN_POS + 1, Y_MAX_POS)) {
+        const float tempry = ry - (rz * planner.yz_skew_factor),
+                    temprx = rx - (ry * planner.xy_skew_factor) - (rz * (planner.xz_skew_factor - (planner.xy_skew_factor * planner.yz_skew_factor)));
+        if (WITHIN(temprx, X_MIN_POS, X_MAX_POS) && WITHIN(tempry, Y_MIN_POS, Y_MAX_POS)) {
+          rx = temprx;
+          ry = tempry;
+        }
+        else
+          SERIAL_ECHOLN(MSG_SKEW_WARN);
+      }
+    #endif
+
     if (!leveling_active) return;
 
     #if ABL_PLANAR
 
       float dx = rx - (X_TILT_FULCRUM),
             dy = ry - (Y_TILT_FULCRUM);
 
       apply_rotation_xyz(bed_level_matrix, dx, dy, rz);
 
       rx = dx + X_TILT_FULCRUM;
@@ -604,74 +631,85 @@ void Planner::calculate_volumetric_multipliers() {
         #else
           0
         #endif
       );
 
     #endif
   }
 
   void Planner::unapply_leveling(float raw[XYZ]) {
 
-    if (!leveling_active) return;
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      const float fade_scaling_factor = fade_scaling_factor_for_z(raw[Z_AXIS]);
+    #else
+      constexpr float fade_scaling_factor = 1.0;
+    #endif
 
-    #if ABL_PLANAR
+    if (leveling_active && fade_scaling_factor) {
 
-      matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
+      #if ABL_PLANAR
 
-      float dx = raw[X_AXIS] - (X_TILT_FULCRUM),
-            dy = raw[Y_AXIS] - (Y_TILT_FULCRUM);
+        matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
 
-      apply_rotation_xyz(inverse, dx, dy, raw[Z_AXIS]);
+        float dx = raw[X_AXIS] - (X_TILT_FULCRUM),
+              dy = raw[Y_AXIS] - (Y_TILT_FULCRUM);
 
-      raw[X_AXIS] = dx + X_TILT_FULCRUM;
-      raw[Y_AXIS] = dy + Y_TILT_FULCRUM;
+        apply_rotation_xyz(inverse, dx, dy, raw[Z_AXIS]);
 
-    #else
+        raw[X_AXIS] = dx + X_TILT_FULCRUM;
+        raw[Y_AXIS] = dy + Y_TILT_FULCRUM;
 
-      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        const float fade_scaling_factor = fade_scaling_factor_for_z(raw[Z_AXIS]);
-        if (!fade_scaling_factor) return;
-      #elif HAS_MESH
-        constexpr float fade_scaling_factor = 1.0;
-      #endif
+      #else // !ABL_PLANAR
 
-      raw[Z_AXIS] -= (
-        #if ENABLED(AUTO_BED_LEVELING_UBL)
-          ubl.get_z_correction(raw[X_AXIS], raw[Y_AXIS]) * fade_scaling_factor
-        #elif ENABLED(MESH_BED_LEVELING)
-          mbl.get_z(raw[X_AXIS], raw[Y_AXIS]
-            #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-              , fade_scaling_factor
-            #endif
-          )
-        #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-          bilinear_z_offset(raw) * fade_scaling_factor
-        #else
-          0
-        #endif
-      );
+        raw[Z_AXIS] -= (
+          #if ENABLED(AUTO_BED_LEVELING_UBL)
+            ubl.get_z_correction(raw[X_AXIS], raw[Y_AXIS]) * fade_scaling_factor
+          #elif ENABLED(MESH_BED_LEVELING)
+            mbl.get_z(raw[X_AXIS], raw[Y_AXIS]
+              #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+                , fade_scaling_factor
+              #endif
+            )
+          #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+            bilinear_z_offset(raw) * fade_scaling_factor
+          #else
+            0
+          #endif
+        );
+
+      #endif // !ABL_PLANAR
+    }
 
+    #if ENABLED(SKEW_CORRECTION)
+      if (WITHIN(raw[X_AXIS], X_MIN_POS, X_MAX_POS) && WITHIN(raw[Y_AXIS], Y_MIN_POS, Y_MAX_POS)) {
+        const float temprx = raw[X_AXIS] + raw[Y_AXIS] * planner.xy_skew_factor + raw[Z_AXIS] * planner.xz_skew_factor,
+                    tempry = raw[Y_AXIS] + raw[Z_AXIS] * planner.yz_skew_factor;
+        if (WITHIN(temprx, X_MIN_POS, X_MAX_POS) && WITHIN(tempry, Y_MIN_POS, Y_MAX_POS)) {
+          raw[X_AXIS] = temprx;
+          raw[Y_AXIS] = tempry;
+        }
+      }
     #endif
   }
 
 #endif // PLANNER_LEVELING
 
 /**
  * Planner::_buffer_line
  *
- * Add a new linear movement to the buffer.
+ * Add a new linear movement to the buffer in axis units.
  *
  * Leveling and kinematics should be applied ahead of calling this.
  *
- *  a,b,c,e     - target positions in mm or degrees
- *  fr_mm_s     - (target) speed of the move
- *  extruder    - target extruder
+ *  a,b,c,e   - target positions in mm and/or degrees
+ *  fr_mm_s   - (target) speed of the move
+ *  extruder  - target extruder
  */
 void Planner::_buffer_line(const float &a, const float &b, const float &c, const float &e, float fr_mm_s, const uint8_t extruder) {
 
   // The target position of the tool in absolute steps
   // Calculate target position in absolute steps
   //this should be done after the wait, because otherwise a M92 code within the gcode disrupts this calculation somehow
   const long target[XYZE] = {
     LROUND(a * axis_steps_per_mm[X_AXIS]),
     LROUND(b * axis_steps_per_mm[Y_AXIS]),
     LROUND(c * axis_steps_per_mm[Z_AXIS]),
@@ -706,20 +744,24 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
   #if ENABLED(DELTA)
     SERIAL_ECHOPAIR(") C:", c);
   #else
     SERIAL_ECHOPAIR(") Z:", c);
   #endif
   SERIAL_ECHOPAIR(" (", dc);
   SERIAL_CHAR(')');
   SERIAL_EOL();
   //*/
 
+  // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
+  if (DEBUGGING(DRYRUN))
+    position[E_AXIS] = target[E_AXIS];
+
   int32_t de = target[E_AXIS] - position[E_AXIS];
 
   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
@@ -729,20 +771,24 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
         if (labs(de * e_factor[extruder]) > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           de = 0; // no difference
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
+  #if ENABLED(LIN_ADVANCE)
+    float de_float = de * steps_to_mm[E_AXIS_N];
+  #endif
+
   // Compute direction bit-mask for this block
   uint8_t dm = 0;
   #if CORE_IS_XY
     if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
     if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
     if (dc < 0) SBI(dm, Z_AXIS);
     if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
     if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
   #elif CORE_IS_XZ
     if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
@@ -1325,20 +1371,21 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
   block->flag |= BLOCK_FLAG_RECALCULATE | (block->nominal_speed <= v_allowable ? BLOCK_FLAG_NOMINAL_LENGTH : 0);
 
   // Update previous path unit_vector and nominal speed
   COPY(previous_speed, current_speed);
   previous_nominal_speed = block->nominal_speed;
   previous_safe_speed = safe_speed;
 
   #if ENABLED(LIN_ADVANCE)
+
     /**
      *
      * Use LIN_ADVANCE for blocks if all these are true:
      *
      * esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS]) : This is a print move
      *
      * extruder_advance_k                 : There is an advance factor set.
      *
      * esteps != block->step_event_count  : A problem occurs if the move before a retract is too small.
      *                                      In that case, the retract and move will be executed together.

commit dd3ce408261cb44fa698ea648d6d258bc9f49f40
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 30 16:38:35 2017 -0600

    Drop Planner::position_float, use int types

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 4d2ee993b0..a7e211aa3e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -137,60 +137,56 @@ float Planner::min_feedrate_mm_s,
 
 #if ENABLED(AUTOTEMP)
   float Planner::autotemp_max = 250,
         Planner::autotemp_min = 210,
         Planner::autotemp_factor = 0.1;
   bool Planner::autotemp_enabled = false;
 #endif
 
 // private:
 
-long Planner::position[NUM_AXIS] = { 0 };
+int32_t Planner::position[NUM_AXIS] = { 0 };
 
 uint32_t Planner::cutoff_long;
 
 float Planner::previous_speed[NUM_AXIS],
       Planner::previous_nominal_speed;
 
 #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
   uint8_t Planner::g_uc_extruder_last_move[EXTRUDERS] = { 0 };
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
   // Old direction bits. Used for speed calculations
   unsigned char Planner::old_direction_bits = 0;
   // Segment times (in ¬µs). Used for speed calculations
   uint32_t Planner::axis_segment_time_us[2][3] = { { MAX_FREQ_TIME_US + 1, 0, 0 }, { MAX_FREQ_TIME_US + 1, 0, 0 } };
 #endif
 
 #if ENABLED(LIN_ADVANCE)
   float Planner::extruder_advance_k, // Initialized by settings.load()
-        Planner::advance_ed_ratio,   // Initialized by settings.load()
-        Planner::position_float[NUM_AXIS] = { 0 };
+        Planner::advance_ed_ratio;   // Initialized by settings.load()
 #endif
 
 #if ENABLED(ULTRA_LCD)
   volatile uint32_t Planner::block_buffer_runtime_us = 0;
 #endif
 
 /**
  * Class and Instance Methods
  */
 
 Planner::Planner() { init(); }
 
 void Planner::init() {
   block_buffer_head = block_buffer_tail = 0;
   ZERO(position);
-  #if ENABLED(LIN_ADVANCE)
-    ZERO(position_float);
-  #endif
   ZERO(previous_speed);
   previous_nominal_speed = 0.0;
   #if ABL_PLANAR
     bed_level_matrix.set_to_identity();
   #endif
 }
 
 #define MINIMAL_STEP_RATE 120
 
 /**
@@ -683,27 +679,23 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
   };
 
   // When changing extruders recalculate steps corresponding to the E position
   #if ENABLED(DISTINCT_E_FACTORS)
     if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
       position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
       last_extruder = extruder;
     }
   #endif
 
-  #if ENABLED(LIN_ADVANCE)
-    const float mm_D_float = SQRT(sq(a - position_float[X_AXIS]) + sq(b - position_float[Y_AXIS]));
-  #endif
-
-  const long da = target[X_AXIS] - position[X_AXIS],
-             db = target[Y_AXIS] - position[Y_AXIS],
-             dc = target[Z_AXIS] - position[Z_AXIS];
+  const int32_t da = target[X_AXIS] - position[X_AXIS],
+                db = target[Y_AXIS] - position[Y_AXIS],
+                dc = target[Z_AXIS] - position[Z_AXIS];
 
   /*
   SERIAL_ECHOPAIR("  Planner FR:", fr_mm_s);
   SERIAL_CHAR(' ');
   #if IS_KINEMATIC
     SERIAL_ECHOPAIR("A:", a);
     SERIAL_ECHOPAIR(" (", da);
     SERIAL_ECHOPAIR(") B:", b);
   #else
     SERIAL_ECHOPAIR("X:", a);
@@ -714,56 +706,36 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
   #if ENABLED(DELTA)
     SERIAL_ECHOPAIR(") C:", c);
   #else
     SERIAL_ECHOPAIR(") Z:", c);
   #endif
   SERIAL_ECHOPAIR(" (", dc);
   SERIAL_CHAR(')');
   SERIAL_EOL();
   //*/
 
-  // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
-  if (DEBUGGING(DRYRUN)) {
-    position[E_AXIS] = target[E_AXIS];
-    #if ENABLED(LIN_ADVANCE)
-      position_float[E_AXIS] = e;
-    #endif
-  }
-
-  long de = target[E_AXIS] - position[E_AXIS];
-
-  #if ENABLED(LIN_ADVANCE)
-    float de_float = e - position_float[E_AXIS]; // Should this include e_factor?
-  #endif
+  int32_t de = target[E_AXIS] - position[E_AXIS];
 
   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           de = 0; // no difference
-          #if ENABLED(LIN_ADVANCE)
-            position_float[E_AXIS] = e;
-            de_float = 0;
-          #endif
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
         if (labs(de * e_factor[extruder]) > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           de = 0; // no difference
-          #if ENABLED(LIN_ADVANCE)
-            position_float[E_AXIS] = e;
-            de_float = 0;
-          #endif
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
     }
   #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   // Compute direction bit-mask for this block
   uint8_t dm = 0;
   #if CORE_IS_XY
@@ -1029,21 +1001,21 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
         sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS])
       #elif CORE_IS_XZ
         sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
       #elif CORE_IS_YZ
         sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
       #else
         sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS])
       #endif
     );
   }
-  const float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
+  float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate moves/second for this move. No divide by zero due to previous checks.
   float inverse_mm_s = fr_mm_s * inverse_millimeters;
 
   const uint8_t moves_queued = movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time im micro seconds
     uint32_t segment_time_us = LROUND(1000000.0 / inverse_mm_s);
@@ -1353,64 +1325,55 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
   // the reverse and forward planners, the corresponding block junction speed will always be at the
   // the maximum junction speed and may always be ignored for any speed reduction checks.
   block->flag |= BLOCK_FLAG_RECALCULATE | (block->nominal_speed <= v_allowable ? BLOCK_FLAG_NOMINAL_LENGTH : 0);
 
   // Update previous path unit_vector and nominal speed
   COPY(previous_speed, current_speed);
   previous_nominal_speed = block->nominal_speed;
   previous_safe_speed = safe_speed;
 
   #if ENABLED(LIN_ADVANCE)
-
-    //
-    // Use LIN_ADVANCE for blocks if all these are true:
-    //
-    // esteps                                          : We have E steps todo (a printing move)
-    //
-    // block->steps[X_AXIS] || block->steps[Y_AXIS]    : We have a movement in XY direction (i.e., not retract / prime).
-    //
-    // extruder_advance_k                              : There is an advance factor set.
-    //
-    // block->steps[E_AXIS] != block->step_event_count : A problem occurs if the move before a retract is too small.
-    //                                                   In that case, the retract and move will be executed together.
-    //                                                   This leads to too many advance steps due to a huge e_acceleration.
-    //                                                   The math is good, but we must avoid retract moves with advance!
-    // de_float > 0.0                                  : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
-    //
-    block->use_advance_lead =  esteps
-                            && (block->steps[X_AXIS] || block->steps[Y_AXIS])
+    /**
+     *
+     * Use LIN_ADVANCE for blocks if all these are true:
+     *
+     * esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS]) : This is a print move
+     *
+     * extruder_advance_k                 : There is an advance factor set.
+     *
+     * esteps != block->step_event_count  : A problem occurs if the move before a retract is too small.
+     *                                      In that case, the retract and move will be executed together.
+     *                                      This leads to too many advance steps due to a huge e_acceleration.
+     *                                      The math is good, but we must avoid retract moves with advance!
+     * de > 0                             : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
+     */
+    block->use_advance_lead =  esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS])
                             && extruder_advance_k
                             && (uint32_t)esteps != block->step_event_count
-                            && de_float > 0.0;
+                            && de > 0;
     if (block->use_advance_lead)
       block->abs_adv_steps_multiplier8 = LROUND(
         extruder_advance_k
-        * (UNEAR_ZERO(advance_ed_ratio) ? de_float / mm_D_float : advance_ed_ratio) // Use the fixed ratio, if set
+        * (UNEAR_ZERO(advance_ed_ratio) ? de * steps_to_mm[E_AXIS_N] / HYPOT(da * steps_to_mm[X_AXIS], db * steps_to_mm[Y_AXIS]) : advance_ed_ratio) // Use the fixed ratio, if set
         * (block->nominal_speed / (float)block->nominal_rate)
         * axis_steps_per_mm[E_AXIS_N] * 256.0
       );
 
   #endif // LIN_ADVANCE
 
   calculate_trapezoid_for_block(block, block->entry_speed / block->nominal_speed, safe_speed / block->nominal_speed);
 
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
   // Update the position (only when a move was queued)
   COPY(position, target);
-  #if ENABLED(LIN_ADVANCE)
-    position_float[X_AXIS] = a;
-    position_float[Y_AXIS] = b;
-    position_float[Z_AXIS] = c;
-    position_float[E_AXIS] = e;
-  #endif
 
   recalculate();
 
   stepper.wake_up();
 
 } // buffer_line()
 
 /**
  * Directly set the planner XYZ position (and stepper positions)
  * converting mm (or angles for SCARA) into steps.
@@ -1418,30 +1381,24 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
 
 void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define _EINDEX (E_AXIS + active_extruder)
     last_extruder = active_extruder;
   #else
     #define _EINDEX E_AXIS
   #endif
-  const long na = position[X_AXIS] = LROUND(a * axis_steps_per_mm[X_AXIS]),
-             nb = position[Y_AXIS] = LROUND(b * axis_steps_per_mm[Y_AXIS]),
-             nc = position[Z_AXIS] = LROUND(c * axis_steps_per_mm[Z_AXIS]),
-             ne = position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
-  #if ENABLED(LIN_ADVANCE)
-    position_float[X_AXIS] = a;
-    position_float[Y_AXIS] = b;
-    position_float[Z_AXIS] = c;
-    position_float[E_AXIS] = e;
-  #endif
+  const int32_t na = position[X_AXIS] = LROUND(a * axis_steps_per_mm[X_AXIS]),
+                nb = position[Y_AXIS] = LROUND(b * axis_steps_per_mm[Y_AXIS]),
+                nc = position[Z_AXIS] = LROUND(c * axis_steps_per_mm[Z_AXIS]),
+                ne = position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
   stepper.set_position(na, nb, nc, ne);
   previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
   ZERO(previous_speed);
 }
 
 void Planner::set_position_mm_kinematic(const float position[NUM_AXIS]) {
   #if PLANNER_LEVELING
     float lpos[XYZ] = { position[X_AXIS], position[Y_AXIS], position[Z_AXIS] };
     apply_leveling(lpos);
   #else
@@ -1452,46 +1409,35 @@ void Planner::set_position_mm_kinematic(const float position[NUM_AXIS]) {
     _set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], position[E_AXIS]);
   #else
     _set_position_mm(lpos[X_AXIS], lpos[Y_AXIS], lpos[Z_AXIS], position[E_AXIS]);
   #endif
 }
 
 /**
  * Sync from the stepper positions. (e.g., after an interrupted move)
  */
 void Planner::sync_from_steppers() {
-  LOOP_XYZE(i) {
+  LOOP_XYZE(i)
     position[i] = stepper.position((AxisEnum)i);
-    #if ENABLED(LIN_ADVANCE)
-      position_float[i] = position[i] * steps_to_mm[i
-        #if ENABLED(DISTINCT_E_FACTORS)
-          + (i == E_AXIS ? active_extruder : 0)
-        #endif
-      ];
-    #endif
-  }
 }
 
 /**
  * Setters for planner position (also setting stepper position).
  */
 void Planner::set_position_mm(const AxisEnum axis, const float &v) {
   #if ENABLED(DISTINCT_E_FACTORS)
     const uint8_t axis_index = axis + (axis == E_AXIS ? active_extruder : 0);
     last_extruder = active_extruder;
   #else
     const uint8_t axis_index = axis;
   #endif
   position[axis] = LROUND(v * axis_steps_per_mm[axis_index]);
-  #if ENABLED(LIN_ADVANCE)
-    position_float[axis] = v;
-  #endif
   stepper.set_position(axis, v);
   previous_speed[axis] = 0.0;
 }
 
 // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
 void Planner::reset_acceleration_rates() {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define HIGHEST_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)
   #else
     #define HIGHEST_CONDITION true

commit ec6ca37ed3d7905a98138e78c5ba5af378eca7b0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 30 16:32:20 2017 -0600

    Fix (un)apply_leveling fade bug

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 151ec22e93..4d2ee993b0 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -564,131 +564,103 @@ void Planner::calculate_volumetric_multipliers() {
 }
 
 #if PLANNER_LEVELING
   /**
    * rx, ry, rz - Cartesian positions in mm
    */
   void Planner::apply_leveling(float &rx, float &ry, float &rz) {
 
     if (!leveling_active) return;
 
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      const float fade_scaling_factor = fade_scaling_factor_for_z(rz);
-      if (!fade_scaling_factor) return;
-    #else
-      constexpr float fade_scaling_factor = 1.0;
-    #endif
-
-    #if ENABLED(AUTO_BED_LEVELING_UBL)
-
-      rz += ubl.get_z_correction(rx, ry) * fade_scaling_factor;
-
-    #elif ENABLED(MESH_BED_LEVELING)
-
-      rz += mbl.get_z(rx, ry
-        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-          , fade_scaling_factor
-        #endif
-      );
-
-    #elif ABL_PLANAR
-
-      UNUSED(fade_scaling_factor);
+    #if ABL_PLANAR
 
       float dx = rx - (X_TILT_FULCRUM),
             dy = ry - (Y_TILT_FULCRUM);
 
       apply_rotation_xyz(bed_level_matrix, dx, dy, rz);
 
       rx = dx + X_TILT_FULCRUM;
       ry = dy + Y_TILT_FULCRUM;
 
-    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-
-      float tmp[XYZ] = { rx, ry, 0 };
-      rz += bilinear_z_offset(tmp) * fade_scaling_factor;
-
-    #endif
-  }
-
-  void Planner::unapply_leveling(float raw[XYZ]) {
-
-    if (!leveling_active) return;
-
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      if (!leveling_active_at_z(raw[Z_AXIS])) return;
-    #endif
-
-    #if ENABLED(AUTO_BED_LEVELING_UBL)
-
-      const float z_physical = raw[Z_AXIS],
-                  z_correct = ubl.get_z_correction(raw[X_AXIS], raw[Y_AXIS]),
-                  z_virtual = z_physical - z_correct;
-            float z_raw = z_virtual;
+    #else
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        const float fade_scaling_factor = fade_scaling_factor_for_z(rz);
+        if (!fade_scaling_factor) return;
+      #elif HAS_MESH
+        constexpr float fade_scaling_factor = 1.0;
+      #endif
 
-        // for P=physical_z, L=logical_z, M=mesh_z, H=fade_height,
-        // Given P=L+M(1-L/H) (faded mesh correction formula for L<H)
-        //  then L=P-M(1-L/H)
-        //    so L=P-M+ML/H
-        //    so L-ML/H=P-M
-        //    so L(1-M/H)=P-M
-        //    so L=(P-M)/(1-M/H) for L<H
-
-        if (planner.z_fade_height) {
-          if (z_raw >= planner.z_fade_height)
-            z_raw = z_physical;
-          else
-            z_raw /= 1.0 - z_correct * planner.inverse_z_fade_height;
-        }
-
-      #endif // ENABLE_LEVELING_FADE_HEIGHT
-
-      raw[Z_AXIS] = z_raw;
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        const float raw[XYZ] = { rx, ry, 0 };
+      #endif
 
-      return; // don't fall thru to other ENABLE_LEVELING_FADE_HEIGHT logic
+      rz += (
+        #if ENABLED(AUTO_BED_LEVELING_UBL)
+          ubl.get_z_correction(rx, ry) * fade_scaling_factor
+        #elif ENABLED(MESH_BED_LEVELING)
+          mbl.get_z(rx, ry
+            #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+              , fade_scaling_factor
+            #endif
+          )
+        #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+          bilinear_z_offset(raw) * fade_scaling_factor
+        #else
+          0
+        #endif
+      );
 
     #endif
+  }
 
-    #if ENABLED(MESH_BED_LEVELING)
+  void Planner::unapply_leveling(float raw[XYZ]) {
 
-      if (leveling_active) {
-        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-          const float c = mbl.get_z(raw[X_AXIS], raw[Y_AXIS], 1.0);
-          raw[Z_AXIS] = (z_fade_height * (raw[Z_AXIS]) - c) / (z_fade_height - c);
-        #else
-          raw[Z_AXIS] -= mbl.get_z(raw[X_AXIS], raw[Y_AXIS]);
-        #endif
-      }
+    if (!leveling_active) return;
 
-    #elif ABL_PLANAR
+    #if ABL_PLANAR
 
       matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
 
       float dx = raw[X_AXIS] - (X_TILT_FULCRUM),
             dy = raw[Y_AXIS] - (Y_TILT_FULCRUM);
 
       apply_rotation_xyz(inverse, dx, dy, raw[Z_AXIS]);
 
       raw[X_AXIS] = dx + X_TILT_FULCRUM;
       raw[Y_AXIS] = dy + Y_TILT_FULCRUM;
 
-    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+    #else
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        const float c = bilinear_z_offset(raw);
-        raw[Z_AXIS] = (z_fade_height * (raw[Z_AXIS]) - c) / (z_fade_height - c);
-      #else
-        raw[Z_AXIS] -= bilinear_z_offset(raw);
+        const float fade_scaling_factor = fade_scaling_factor_for_z(raw[Z_AXIS]);
+        if (!fade_scaling_factor) return;
+      #elif HAS_MESH
+        constexpr float fade_scaling_factor = 1.0;
       #endif
 
+      raw[Z_AXIS] -= (
+        #if ENABLED(AUTO_BED_LEVELING_UBL)
+          ubl.get_z_correction(raw[X_AXIS], raw[Y_AXIS]) * fade_scaling_factor
+        #elif ENABLED(MESH_BED_LEVELING)
+          mbl.get_z(raw[X_AXIS], raw[Y_AXIS]
+            #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+              , fade_scaling_factor
+            #endif
+          )
+        #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+          bilinear_z_offset(raw) * fade_scaling_factor
+        #else
+          0
+        #endif
+      );
+
     #endif
   }
 
 #endif // PLANNER_LEVELING
 
 /**
  * Planner::_buffer_line
  *
  * Add a new linear movement to the buffer.
  *

commit a52fec6ac49e47dc390ccb41990921970479d6da
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 30 15:55:08 2017 -0600

    Planner class parity with 1.1.x

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e5141429e7..151ec22e93 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -98,50 +98,48 @@ volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next
 float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
       Planner::axis_steps_per_mm[XYZE_N],
       Planner::steps_to_mm[XYZE_N];
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
 
-// Initialized by settings.load()
-float Planner::e_factor[EXTRUDERS],              // The flow percentage and volumetric multiplier combine to scale E movement
-      Planner::filament_size[EXTRUDERS],         // As a baseline for the multiplier, filament diameter
+float Planner::e_factor[EXTRUDERS],               // The flow percentage and volumetric multiplier combine to scale E movement
+      Planner::filament_size[EXTRUDERS],          // diameter of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder
       Planner::volumetric_area_nominal = CIRCLE_AREA((DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5), // Nominal cross-sectional area
-      Planner::volumetric_multiplier[EXTRUDERS]; // May be auto-adjusted by a filament width sensor
+      Planner::volumetric_multiplier[EXTRUDERS];  // Reciprocal of cross-sectional area of filament (in mm^2). Pre-calculated to reduce computation in the planner
 
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N],
          Planner::max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
 
 uint32_t Planner::min_segment_time_us;
 
 // Initialized by settings.load()
 float Planner::min_feedrate_mm_s,
       Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
       Planner::retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
       Planner::travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
       Planner::max_jerk[XYZE],       // The largest speed change requiring no acceleration
       Planner::min_travel_feedrate_mm_s;
 
 #if HAS_LEVELING
   bool Planner::leveling_active = false; // Flag that auto bed leveling is enabled
   #if ABL_PLANAR
     matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
   #endif
-#endif
-
-#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-  float Planner::z_fade_height, // Initialized by settings.load()
-        Planner::inverse_z_fade_height,
-        Planner::last_fade_z;
+  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+    float Planner::z_fade_height,      // Initialized by settings.load()
+          Planner::inverse_z_fade_height,
+          Planner::last_fade_z;
+  #endif
 #endif
 
 #if ENABLED(AUTOTEMP)
   float Planner::autotemp_max = 250,
         Planner::autotemp_min = 210,
         Planner::autotemp_factor = 0.1;
   bool Planner::autotemp_enabled = false;
 #endif
 
 // private:
@@ -564,21 +562,21 @@ void Planner::calculate_volumetric_multipliers() {
     refresh_e_factor(i);
   }
 }
 
 #if PLANNER_LEVELING
   /**
    * rx, ry, rz - Cartesian positions in mm
    */
   void Planner::apply_leveling(float &rx, float &ry, float &rz) {
 
-    if (!planner.leveling_active) return;
+    if (!leveling_active) return;
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       const float fade_scaling_factor = fade_scaling_factor_for_z(rz);
       if (!fade_scaling_factor) return;
     #else
       constexpr float fade_scaling_factor = 1.0;
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
 
@@ -607,74 +605,80 @@ void Planner::calculate_volumetric_multipliers() {
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       float tmp[XYZ] = { rx, ry, 0 };
       rz += bilinear_z_offset(tmp) * fade_scaling_factor;
 
     #endif
   }
 
   void Planner::unapply_leveling(float raw[XYZ]) {
 
-    if (!planner.leveling_active) return;
+    if (!leveling_active) return;
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      if (z_fade_height && raw[Z_AXIS] >= z_fade_height) return;
+      if (!leveling_active_at_z(raw[Z_AXIS])) return;
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
 
-      const float z_correct = ubl.get_z_correction(raw[X_AXIS], raw[Y_AXIS]);
-            float z_raw = raw[Z_AXIS] - z_correct;
+      const float z_physical = raw[Z_AXIS],
+                  z_correct = ubl.get_z_correction(raw[X_AXIS], raw[Y_AXIS]),
+                  z_virtual = z_physical - z_correct;
+            float z_raw = z_virtual;
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
 
-        // for P=physical_z, L=raw_z, M=mesh_z, H=fade_height,
+        // for P=physical_z, L=logical_z, M=mesh_z, H=fade_height,
         // Given P=L+M(1-L/H) (faded mesh correction formula for L<H)
         //  then L=P-M(1-L/H)
         //    so L=P-M+ML/H
         //    so L-ML/H=P-M
         //    so L(1-M/H)=P-M
         //    so L=(P-M)/(1-M/H) for L<H
 
         if (planner.z_fade_height) {
           if (z_raw >= planner.z_fade_height)
-            z_raw = raw[Z_AXIS];
+            z_raw = z_physical;
           else
             z_raw /= 1.0 - z_correct * planner.inverse_z_fade_height;
         }
 
       #endif // ENABLE_LEVELING_FADE_HEIGHT
 
       raw[Z_AXIS] = z_raw;
 
-    #elif ENABLED(MESH_BED_LEVELING)
+      return; // don't fall thru to other ENABLE_LEVELING_FADE_HEIGHT logic
 
-      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        const float c = mbl.get_z(raw[X_AXIS], raw[Y_AXIS], 1.0);
-        raw[Z_AXIS] = (z_fade_height * (raw[Z_AXIS] - c)) / (z_fade_height - c);
-      #else
-        raw[Z_AXIS] -= mbl.get_z(raw[X_AXIS], raw[Y_AXIS]);
-      #endif
+    #endif
+
+    #if ENABLED(MESH_BED_LEVELING)
+
+      if (leveling_active) {
+        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+          const float c = mbl.get_z(raw[X_AXIS], raw[Y_AXIS], 1.0);
+          raw[Z_AXIS] = (z_fade_height * (raw[Z_AXIS]) - c) / (z_fade_height - c);
+        #else
+          raw[Z_AXIS] -= mbl.get_z(raw[X_AXIS], raw[Y_AXIS]);
+        #endif
+      }
 
     #elif ABL_PLANAR
 
       matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
 
       float dx = raw[X_AXIS] - (X_TILT_FULCRUM),
-            dy = raw[Y_AXIS] - (Y_TILT_FULCRUM),
-            dz = raw[Z_AXIS];
+            dy = raw[Y_AXIS] - (Y_TILT_FULCRUM);
 
-      apply_rotation_xyz(inverse, dx, dy, dz);
+      apply_rotation_xyz(inverse, dx, dy, raw[Z_AXIS]);
 
       raw[X_AXIS] = dx + X_TILT_FULCRUM;
       raw[Y_AXIS] = dy + Y_TILT_FULCRUM;
-      raw[Z_AXIS] = dz;
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         const float c = bilinear_z_offset(raw);
         raw[Z_AXIS] = (z_fade_height * (raw[Z_AXIS]) - c) / (z_fade_height - c);
       #else
         raw[Z_AXIS] -= bilinear_z_offset(raw);
       #endif
 

commit 23e45fa3c499a1c30a84deee36477f19a0ab452e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 29 21:02:29 2017 -0600

    Apply const to some planner vars

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index ed71c70310..e5141429e7 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1309,22 +1309,22 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
       }
     }
   }
 
   if (moves_queued > 1 && !UNEAR_ZERO(previous_nominal_speed)) {
     // Estimate a maximum velocity allowed at a joint of two successive segments.
     // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
     // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
 
     // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
-    bool prev_speed_larger = previous_nominal_speed > block->nominal_speed;
-    float smaller_speed_factor = prev_speed_larger ? (block->nominal_speed / previous_nominal_speed) : (previous_nominal_speed / block->nominal_speed);
+    const bool prev_speed_larger = previous_nominal_speed > block->nominal_speed;
+    const float smaller_speed_factor = prev_speed_larger ? (block->nominal_speed / previous_nominal_speed) : (previous_nominal_speed / block->nominal_speed);
     // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
     vmax_junction = prev_speed_larger ? block->nominal_speed : previous_nominal_speed;
     // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
     float v_factor = 1;
     limited = 0;
     // Now limit the jerk in all axes.
     LOOP_XYZE(axis) {
       // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
       float v_exit = previous_speed[axis], v_entry = current_speed[axis];
       if (prev_speed_larger) v_exit *= smaller_speed_factor;
@@ -1442,24 +1442,24 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
  * On CORE machines stepper ABC will be translated from the given XYZ.
  */
 
 void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   #if ENABLED(DISTINCT_E_FACTORS)
     #define _EINDEX (E_AXIS + active_extruder)
     last_extruder = active_extruder;
   #else
     #define _EINDEX E_AXIS
   #endif
-  long na = position[X_AXIS] = LROUND(a * axis_steps_per_mm[X_AXIS]),
-       nb = position[Y_AXIS] = LROUND(b * axis_steps_per_mm[Y_AXIS]),
-       nc = position[Z_AXIS] = LROUND(c * axis_steps_per_mm[Z_AXIS]),
-       ne = position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
+  const long na = position[X_AXIS] = LROUND(a * axis_steps_per_mm[X_AXIS]),
+             nb = position[Y_AXIS] = LROUND(b * axis_steps_per_mm[Y_AXIS]),
+             nc = position[Z_AXIS] = LROUND(c * axis_steps_per_mm[Z_AXIS]),
+             ne = position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
   #if ENABLED(LIN_ADVANCE)
     position_float[X_AXIS] = a;
     position_float[Y_AXIS] = b;
     position_float[Z_AXIS] = c;
     position_float[E_AXIS] = e;
   #endif
   stepper.set_position(na, nb, nc, ne);
   previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
   ZERO(previous_speed);
 }

commit 285b868e9b1d64c1c9b60370630f6d9bad32600f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 29 15:11:31 2017 -0600

    Tweak planner code style

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 3c8d7a76fb..ed71c70310 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1053,39 +1053,40 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
         sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS])
       #elif CORE_IS_XZ
         sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
       #elif CORE_IS_YZ
         sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
       #else
         sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS])
       #endif
     );
   }
-  float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
+  const float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate moves/second for this move. No divide by zero due to previous checks.
   float inverse_mm_s = fr_mm_s * inverse_millimeters;
 
   const uint8_t moves_queued = movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time im micro seconds
     uint32_t segment_time_us = LROUND(1000000.0 / inverse_mm_s);
   #endif
   #if ENABLED(SLOWDOWN)
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
       if (segment_time_us < min_segment_time_us) {
         // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
-        inverse_mm_s = 1000000.0 / (segment_time_us + LROUND(2 * (min_segment_time_us - segment_time_us) / moves_queued));
+        const uint32_t nst = segment_time_us + LROUND(2 * (min_segment_time_us - segment_time_us) / moves_queued);
+        inverse_mm_s = 1000000.0 / nst;
         #if defined(XY_FREQUENCY_LIMIT) || ENABLED(ULTRA_LCD)
-          segment_time_us = LROUND(1000000.0 / inverse_mm_s);
+          segment_time_us = nst;
         #endif
       }
     }
   #endif
 
   #if ENABLED(ULTRA_LCD)
     CRITICAL_SECTION_START
       block_buffer_runtime_us += segment_time_us;
     CRITICAL_SECTION_END
   #endif
@@ -1099,21 +1100,21 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
     //FMM update ring buffer used for delay with filament measurements
     if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && filwidth_delay_index[1] >= 0) {  //only for extruder with filament sensor and if ring buffer is initialized
 
       const int MMD_CM = MAX_MEASUREMENT_DELAY + 1, MMD_MM = MMD_CM * 10;
 
       // increment counters with next move in e axis
       filwidth_e_count += delta_mm[E_AXIS];
       filwidth_delay_dist += delta_mm[E_AXIS];
 
       // Only get new measurements on forward E movement
-      if (filwidth_e_count > 0.0001) {
+      if (!UNEAR_ZERO(filwidth_e_count)) {
 
         // Loop the delay distance counter (modulus by the mm length)
         while (filwidth_delay_dist >= MMD_MM) filwidth_delay_dist -= MMD_MM;
 
         // Convert into an index into the measurement array
         filwidth_delay_index[0] = int8_t(filwidth_delay_dist * 0.1);
 
         // If the index has changed (must have gone forward)...
         if (filwidth_delay_index[0] != filwidth_delay_index[1]) {
           filwidth_e_count = 0; // Reset the E movement counter
@@ -1302,49 +1303,49 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
         const float mjerk = maxj * block->nominal_speed;
         if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk;
       }
       else {
         ++limited;
         safe_speed = maxj;
       }
     }
   }
 
-  if (moves_queued > 1 && previous_nominal_speed > 0.0001) {
+  if (moves_queued > 1 && !UNEAR_ZERO(previous_nominal_speed)) {
     // Estimate a maximum velocity allowed at a joint of two successive segments.
     // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
     // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
 
     // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
     bool prev_speed_larger = previous_nominal_speed > block->nominal_speed;
     float smaller_speed_factor = prev_speed_larger ? (block->nominal_speed / previous_nominal_speed) : (previous_nominal_speed / block->nominal_speed);
     // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
     vmax_junction = prev_speed_larger ? block->nominal_speed : previous_nominal_speed;
     // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
-    float v_factor = 1.f;
+    float v_factor = 1;
     limited = 0;
     // Now limit the jerk in all axes.
     LOOP_XYZE(axis) {
       // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
       float v_exit = previous_speed[axis], v_entry = current_speed[axis];
       if (prev_speed_larger) v_exit *= smaller_speed_factor;
       if (limited) {
         v_exit *= v_factor;
         v_entry *= v_factor;
       }
 
       // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
       const float jerk = (v_exit > v_entry)
           ? //                                  coasting             axis reversal
-            ( (v_entry > 0.f || v_exit < 0.f) ? (v_exit - v_entry) : max(v_exit, -v_entry) )
+            ( (v_entry > 0 || v_exit < 0) ? (v_exit - v_entry) : max(v_exit, -v_entry) )
           : // v_exit <= v_entry                coasting             axis reversal
-            ( (v_entry < 0.f || v_exit > 0.f) ? (v_entry - v_exit) : max(-v_exit, v_entry) );
+            ( (v_entry < 0 || v_exit > 0) ? (v_entry - v_exit) : max(-v_exit, v_entry) );
 
       if (jerk > max_jerk[axis]) {
         v_factor *= max_jerk[axis] / jerk;
         ++limited;
       }
     }
     if (limited) vmax_junction *= v_factor;
     // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
     // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
     const float vmax_junction_threshold = vmax_junction * 0.99f;

commit 1f2acc33bcdb4fa1079616597effdf973fb6fea6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 28 18:41:13 2017 -0600

    Tweaks for check_axes_activity

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7e98f68468..3c8d7a76fb 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -416,31 +416,27 @@ void Planner::recalculate() {
 
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
   unsigned char axis_active[NUM_AXIS] = { 0 },
                 tail_fan_speed[FAN_COUNT];
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
-      uint8_t tail_valve_pressure = baricuda_valve_pressure;
+      uint8_t tail_valve_pressure;
     #endif
     #if HAS_HEATER_2
-      uint8_t tail_e_to_p_pressure = baricuda_e_to_p_pressure;
+      uint8_t tail_e_to_p_pressure;
     #endif
   #endif
 
-  #if FAN_COUNT > 0
-    for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = fanSpeeds[i];
-  #endif
-
   if (blocks_queued()) {
 
     #if FAN_COUNT > 0
       for (uint8_t i = 0; i < FAN_COUNT; i++)
         tail_fan_speed[i] = block_buffer[block_buffer_tail].fan_speed[i];
     #endif
 
     block_t* block;
 
     #if ENABLED(BARICUDA)
@@ -451,20 +447,34 @@ void Planner::check_axes_activity() {
       #if HAS_HEATER_2
         tail_e_to_p_pressure = block->e_to_p_pressure;
       #endif
     #endif
 
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block = &block_buffer[b];
       LOOP_XYZE(i) if (block->steps[i]) axis_active[i]++;
     }
   }
+  else {
+    #if FAN_COUNT > 0
+      for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = fanSpeeds[i];
+    #endif
+
+    #if ENABLED(BARICUDA)
+      #if HAS_HEATER_1
+        tail_valve_pressure = baricuda_valve_pressure;
+      #endif
+      #if HAS_HEATER_2
+        tail_e_to_p_pressure = baricuda_e_to_p_pressure;
+      #endif
+    #endif
+  }
 
   #if ENABLED(DISABLE_X)
     if (!axis_active[X_AXIS]) disable_X();
   #endif
   #if ENABLED(DISABLE_Y)
     if (!axis_active[Y_AXIS]) disable_Y();
   #endif
   #if ENABLED(DISABLE_Z)
     if (!axis_active[Z_AXIS]) disable_Z();
   #endif

commit 16baa48699ce22f1363764d7b1933f29307caaf3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 28 16:12:14 2017 -0600

    Fix #8579
    
    Fan speed code fell into a curly brace

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 769aca36c6..7e98f68468 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -416,135 +416,127 @@ void Planner::recalculate() {
 
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
   unsigned char axis_active[NUM_AXIS] = { 0 },
                 tail_fan_speed[FAN_COUNT];
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
-      uint8_t tail_valve_pressure;
+      uint8_t tail_valve_pressure = baricuda_valve_pressure;
     #endif
     #if HAS_HEATER_2
-      uint8_t tail_e_to_p_pressure;
+      uint8_t tail_e_to_p_pressure = baricuda_e_to_p_pressure;
     #endif
   #endif
 
+  #if FAN_COUNT > 0
+    for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = fanSpeeds[i];
+  #endif
+
   if (blocks_queued()) {
 
     #if FAN_COUNT > 0
-
       for (uint8_t i = 0; i < FAN_COUNT; i++)
         tail_fan_speed[i] = block_buffer[block_buffer_tail].fan_speed[i];
-
-      #ifdef FAN_KICKSTART_TIME
-
-        static millis_t fan_kick_end[FAN_COUNT] = { 0 };
-
-        #define KICKSTART_FAN(f) \
-          if (tail_fan_speed[f]) { \
-            millis_t ms = millis(); \
-            if (fan_kick_end[f] == 0) { \
-              fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \
-              tail_fan_speed[f] = 255; \
-            } else if (PENDING(ms, fan_kick_end[f])) \
-              tail_fan_speed[f] = 255; \
-          } else fan_kick_end[f] = 0
-
-        #if HAS_FAN0
-          KICKSTART_FAN(0);
-        #endif
-        #if HAS_FAN1
-          KICKSTART_FAN(1);
-        #endif
-        #if HAS_FAN2
-          KICKSTART_FAN(2);
-        #endif
-
-      #endif // FAN_KICKSTART_TIME
-
-      #ifdef FAN_MIN_PWM
-        #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ? ( FAN_MIN_PWM + (tail_fan_speed[f] * (255 - FAN_MIN_PWM)) / 255 ) : 0)
-      #else
-        #define CALC_FAN_SPEED(f) tail_fan_speed[f]
-      #endif
-
-      #if ENABLED(FAN_SOFT_PWM)
-        #if HAS_FAN0
-          thermalManager.soft_pwm_amount_fan[0] = CALC_FAN_SPEED(0);
-        #endif
-        #if HAS_FAN1
-          thermalManager.soft_pwm_amount_fan[1] = CALC_FAN_SPEED(1);
-        #endif
-        #if HAS_FAN2
-          thermalManager.soft_pwm_amount_fan[2] = CALC_FAN_SPEED(2);
-        #endif
-      #else
-        #if HAS_FAN0
-          analogWrite(FAN_PIN, CALC_FAN_SPEED(0));
-        #endif
-        #if HAS_FAN1
-          analogWrite(FAN1_PIN, CALC_FAN_SPEED(1));
-        #endif
-        #if HAS_FAN2
-          analogWrite(FAN2_PIN, CALC_FAN_SPEED(2));
-        #endif
-      #endif
-
-    #endif // FAN_COUNT > 0
+    #endif
 
     block_t* block;
 
     #if ENABLED(BARICUDA)
       block = &block_buffer[block_buffer_tail];
       #if HAS_HEATER_1
         tail_valve_pressure = block->valve_pressure;
       #endif
       #if HAS_HEATER_2
         tail_e_to_p_pressure = block->e_to_p_pressure;
       #endif
     #endif
 
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block = &block_buffer[b];
       LOOP_XYZE(i) if (block->steps[i]) axis_active[i]++;
     }
   }
-  else {
-    #if FAN_COUNT > 0
-      for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = fanSpeeds[i];
-    #endif
-
-    #if ENABLED(BARICUDA)
-      #if HAS_HEATER_1
-        tail_valve_pressure = baricuda_valve_pressure;
-      #endif
-      #if HAS_HEATER_2
-        tail_e_to_p_pressure = baricuda_e_to_p_pressure;
-      #endif
-    #endif
-  }
 
   #if ENABLED(DISABLE_X)
     if (!axis_active[X_AXIS]) disable_X();
   #endif
   #if ENABLED(DISABLE_Y)
     if (!axis_active[Y_AXIS]) disable_Y();
   #endif
   #if ENABLED(DISABLE_Z)
     if (!axis_active[Z_AXIS]) disable_Z();
   #endif
   #if ENABLED(DISABLE_E)
     if (!axis_active[E_AXIS]) disable_e_steppers();
   #endif
 
+  #if FAN_COUNT > 0
+
+    #if FAN_KICKSTART_TIME > 0
+
+      static millis_t fan_kick_end[FAN_COUNT] = { 0 };
+
+      #define KICKSTART_FAN(f) \
+        if (tail_fan_speed[f]) { \
+          millis_t ms = millis(); \
+          if (fan_kick_end[f] == 0) { \
+            fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \
+            tail_fan_speed[f] = 255; \
+          } else if (PENDING(ms, fan_kick_end[f])) \
+            tail_fan_speed[f] = 255; \
+        } else fan_kick_end[f] = 0
+
+      #if HAS_FAN0
+        KICKSTART_FAN(0);
+      #endif
+      #if HAS_FAN1
+        KICKSTART_FAN(1);
+      #endif
+      #if HAS_FAN2
+        KICKSTART_FAN(2);
+      #endif
+
+    #endif // FAN_KICKSTART_TIME > 0
+
+    #ifdef FAN_MIN_PWM
+      #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ? ( FAN_MIN_PWM + (tail_fan_speed[f] * (255 - FAN_MIN_PWM)) / 255 ) : 0)
+    #else
+      #define CALC_FAN_SPEED(f) tail_fan_speed[f]
+    #endif
+
+    #if ENABLED(FAN_SOFT_PWM)
+      #if HAS_FAN0
+        thermalManager.soft_pwm_amount_fan[0] = CALC_FAN_SPEED(0);
+      #endif
+      #if HAS_FAN1
+        thermalManager.soft_pwm_amount_fan[1] = CALC_FAN_SPEED(1);
+      #endif
+      #if HAS_FAN2
+        thermalManager.soft_pwm_amount_fan[2] = CALC_FAN_SPEED(2);
+      #endif
+    #else
+      #if HAS_FAN0
+        analogWrite(FAN_PIN, CALC_FAN_SPEED(0));
+      #endif
+      #if HAS_FAN1
+        analogWrite(FAN1_PIN, CALC_FAN_SPEED(1));
+      #endif
+      #if HAS_FAN2
+        analogWrite(FAN2_PIN, CALC_FAN_SPEED(2));
+      #endif
+    #endif
+
+  #endif // FAN_COUNT > 0
+
   #if ENABLED(AUTOTEMP)
     getHighESpeed();
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       analogWrite(HEATER_1_PIN, tail_valve_pressure);
     #endif
     #if HAS_HEATER_2
       analogWrite(HEATER_2_PIN, tail_e_to_p_pressure);

commit 27c5692b132c680ecf626f817cb81ef8c3374fd9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 25 18:13:36 2017 -0600

    Syntax tweaks

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 742528241d..769aca36c6 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1121,21 +1121,21 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
             measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
           } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
         }
       }
     }
   #endif
 
   // Calculate and limit speed in mm/sec for each axis
   float current_speed[NUM_AXIS], speed_factor = 1.0; // factor <1 decreases speed
   LOOP_XYZE(i) {
-    const float cs = FABS(current_speed[i] = delta_mm[i] * inverse_mm_s);
+    const float cs = FABS((current_speed[i] = delta_mm[i] * inverse_mm_s));
     #if ENABLED(DISTINCT_E_FACTORS)
       if (i == E_AXIS) i += extruder;
     #endif
     if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
   }
 
   // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT
 
     // Check and limit the xy direction change frequency

commit a03f93bab4ac3f775e413994c416b874528dab3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 23 21:42:45 2017 -0600

    Fix fan kickstart

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 5b8f0d30ca..742528241d 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -434,29 +434,29 @@ void Planner::check_axes_activity() {
 
     #if FAN_COUNT > 0
 
       for (uint8_t i = 0; i < FAN_COUNT; i++)
         tail_fan_speed[i] = block_buffer[block_buffer_tail].fan_speed[i];
 
       #ifdef FAN_KICKSTART_TIME
 
         static millis_t fan_kick_end[FAN_COUNT] = { 0 };
 
-        #define KICKSTART_FAN(f)                         \
-          if (tail_fan_speed[f]) {                       \ // is the fan turned on?
-            millis_t ms = millis();                      \
-            if (fan_kick_end[f] == 0) {                  \ // not yet kickstarted?
-              fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \ // kickstart until this time
-              tail_fan_speed[f] = 255;                   \ // full speed
-            } else if (PENDING(ms, fan_kick_end[f]))     \ // kickstart in progress?
-              tail_fan_speed[f] = 255;                   \ // keep full speed going
-          } else fan_kick_end[f] = 0                       // fan off? kick next time
+        #define KICKSTART_FAN(f) \
+          if (tail_fan_speed[f]) { \
+            millis_t ms = millis(); \
+            if (fan_kick_end[f] == 0) { \
+              fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \
+              tail_fan_speed[f] = 255; \
+            } else if (PENDING(ms, fan_kick_end[f])) \
+              tail_fan_speed[f] = 255; \
+          } else fan_kick_end[f] = 0
 
         #if HAS_FAN0
           KICKSTART_FAN(0);
         #endif
         #if HAS_FAN1
           KICKSTART_FAN(1);
         #endif
         #if HAS_FAN2
           KICKSTART_FAN(2);
         #endif

commit 9e3c41f9e8c7b579ef221d9ae401651826db5e1b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 21 19:04:09 2017 -0600

    Tweak fan kickstart / speed code

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index e88935e5eb..5b8f0d30ca 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -414,127 +414,137 @@ void Planner::recalculate() {
 
 #endif // AUTOTEMP
 
 /**
  * Maintain fans, paste extruder pressure,
  */
 void Planner::check_axes_activity() {
   unsigned char axis_active[NUM_AXIS] = { 0 },
                 tail_fan_speed[FAN_COUNT];
 
-  #if FAN_COUNT > 0
-    for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = fanSpeeds[i];
-  #endif
-
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
-      uint8_t tail_valve_pressure = baricuda_valve_pressure;
+      uint8_t tail_valve_pressure;
     #endif
     #if HAS_HEATER_2
-      uint8_t tail_e_to_p_pressure = baricuda_e_to_p_pressure;
+      uint8_t tail_e_to_p_pressure;
     #endif
   #endif
 
   if (blocks_queued()) {
 
     #if FAN_COUNT > 0
-      for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = block_buffer[block_buffer_tail].fan_speed[i];
-    #endif
+
+      for (uint8_t i = 0; i < FAN_COUNT; i++)
+        tail_fan_speed[i] = block_buffer[block_buffer_tail].fan_speed[i];
+
+      #ifdef FAN_KICKSTART_TIME
+
+        static millis_t fan_kick_end[FAN_COUNT] = { 0 };
+
+        #define KICKSTART_FAN(f)                         \
+          if (tail_fan_speed[f]) {                       \ // is the fan turned on?
+            millis_t ms = millis();                      \
+            if (fan_kick_end[f] == 0) {                  \ // not yet kickstarted?
+              fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \ // kickstart until this time
+              tail_fan_speed[f] = 255;                   \ // full speed
+            } else if (PENDING(ms, fan_kick_end[f]))     \ // kickstart in progress?
+              tail_fan_speed[f] = 255;                   \ // keep full speed going
+          } else fan_kick_end[f] = 0                       // fan off? kick next time
+
+        #if HAS_FAN0
+          KICKSTART_FAN(0);
+        #endif
+        #if HAS_FAN1
+          KICKSTART_FAN(1);
+        #endif
+        #if HAS_FAN2
+          KICKSTART_FAN(2);
+        #endif
+
+      #endif // FAN_KICKSTART_TIME
+
+      #ifdef FAN_MIN_PWM
+        #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ? ( FAN_MIN_PWM + (tail_fan_speed[f] * (255 - FAN_MIN_PWM)) / 255 ) : 0)
+      #else
+        #define CALC_FAN_SPEED(f) tail_fan_speed[f]
+      #endif
+
+      #if ENABLED(FAN_SOFT_PWM)
+        #if HAS_FAN0
+          thermalManager.soft_pwm_amount_fan[0] = CALC_FAN_SPEED(0);
+        #endif
+        #if HAS_FAN1
+          thermalManager.soft_pwm_amount_fan[1] = CALC_FAN_SPEED(1);
+        #endif
+        #if HAS_FAN2
+          thermalManager.soft_pwm_amount_fan[2] = CALC_FAN_SPEED(2);
+        #endif
+      #else
+        #if HAS_FAN0
+          analogWrite(FAN_PIN, CALC_FAN_SPEED(0));
+        #endif
+        #if HAS_FAN1
+          analogWrite(FAN1_PIN, CALC_FAN_SPEED(1));
+        #endif
+        #if HAS_FAN2
+          analogWrite(FAN2_PIN, CALC_FAN_SPEED(2));
+        #endif
+      #endif
+
+    #endif // FAN_COUNT > 0
 
     block_t* block;
 
     #if ENABLED(BARICUDA)
       block = &block_buffer[block_buffer_tail];
       #if HAS_HEATER_1
         tail_valve_pressure = block->valve_pressure;
       #endif
       #if HAS_HEATER_2
         tail_e_to_p_pressure = block->e_to_p_pressure;
       #endif
     #endif
 
     for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
       block = &block_buffer[b];
       LOOP_XYZE(i) if (block->steps[i]) axis_active[i]++;
     }
   }
+  else {
+    #if FAN_COUNT > 0
+      for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = fanSpeeds[i];
+    #endif
+
+    #if ENABLED(BARICUDA)
+      #if HAS_HEATER_1
+        tail_valve_pressure = baricuda_valve_pressure;
+      #endif
+      #if HAS_HEATER_2
+        tail_e_to_p_pressure = baricuda_e_to_p_pressure;
+      #endif
+    #endif
+  }
+
   #if ENABLED(DISABLE_X)
     if (!axis_active[X_AXIS]) disable_X();
   #endif
   #if ENABLED(DISABLE_Y)
     if (!axis_active[Y_AXIS]) disable_Y();
   #endif
   #if ENABLED(DISABLE_Z)
     if (!axis_active[Z_AXIS]) disable_Z();
   #endif
   #if ENABLED(DISABLE_E)
     if (!axis_active[E_AXIS]) disable_e_steppers();
   #endif
 
-  #if FAN_COUNT > 0
-
-    #ifdef FAN_MIN_PWM
-      #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ? ( FAN_MIN_PWM + (tail_fan_speed[f] * (255 - FAN_MIN_PWM)) / 255 ) : 0)
-    #else
-      #define CALC_FAN_SPEED(f) tail_fan_speed[f]
-    #endif
-
-    #ifdef FAN_KICKSTART_TIME
-
-      static millis_t fan_kick_end[FAN_COUNT] = { 0 };
-
-      #define KICKSTART_FAN(f) \
-        if (tail_fan_speed[f]) { \
-          millis_t ms = millis(); \
-          if (fan_kick_end[f] == 0) { \
-            fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \
-            tail_fan_speed[f] = 255; \
-          } else if (PENDING(ms, fan_kick_end[f])) \
-            tail_fan_speed[f] = 255; \
-        } else fan_kick_end[f] = 0
-
-      #if HAS_FAN0
-        KICKSTART_FAN(0);
-      #endif
-      #if HAS_FAN1
-        KICKSTART_FAN(1);
-      #endif
-      #if HAS_FAN2
-        KICKSTART_FAN(2);
-      #endif
-
-    #endif // FAN_KICKSTART_TIME
-
-    #if ENABLED(FAN_SOFT_PWM)
-      #if HAS_FAN0
-        thermalManager.soft_pwm_amount_fan[0] = CALC_FAN_SPEED(0);
-      #endif
-      #if HAS_FAN1
-        thermalManager.soft_pwm_amount_fan[1] = CALC_FAN_SPEED(1);
-      #endif
-      #if HAS_FAN2
-        thermalManager.soft_pwm_amount_fan[2] = CALC_FAN_SPEED(2);
-      #endif
-    #else
-      #if HAS_FAN0
-        analogWrite(FAN_PIN, CALC_FAN_SPEED(0));
-      #endif
-      #if HAS_FAN1
-        analogWrite(FAN1_PIN, CALC_FAN_SPEED(1));
-      #endif
-      #if HAS_FAN2
-        analogWrite(FAN2_PIN, CALC_FAN_SPEED(2));
-      #endif
-    #endif
-
-  #endif // FAN_COUNT > 0
-
   #if ENABLED(AUTOTEMP)
     getHighESpeed();
   #endif
 
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       analogWrite(HEATER_1_PIN, tail_valve_pressure);
     #endif
     #if HAS_HEATER_2
       analogWrite(HEATER_2_PIN, tail_e_to_p_pressure);

commit 60adc6ff0213c6989cd31b9e76e4ac6ab314cc66
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 18 07:01:49 2017 -0600

    Display filwidth ratio in terms of E mm

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 30c9315bf0..e88935e5eb 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -101,20 +101,21 @@ float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
 
 // Initialized by settings.load()
 float Planner::e_factor[EXTRUDERS],              // The flow percentage and volumetric multiplier combine to scale E movement
       Planner::filament_size[EXTRUDERS],         // As a baseline for the multiplier, filament diameter
+      Planner::volumetric_area_nominal = CIRCLE_AREA((DEFAULT_NOMINAL_FILAMENT_DIA) * 0.5), // Nominal cross-sectional area
       Planner::volumetric_multiplier[EXTRUDERS]; // May be auto-adjusted by a filament width sensor
 
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N],
          Planner::max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
 
 uint32_t Planner::min_segment_time_us;
 
 // Initialized by settings.load()
 float Planner::min_feedrate_mm_s,
       Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX

commit 50f09cc029e21341cfe993025cf1854746ac2990
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 16 00:27:24 2017 -0600

    Miscellaneous cleanup

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 8b20c91581..30c9315bf0 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -535,22 +535,21 @@ void Planner::check_axes_activity() {
     #if HAS_HEATER_1
       analogWrite(HEATER_1_PIN, tail_valve_pressure);
     #endif
     #if HAS_HEATER_2
       analogWrite(HEATER_2_PIN, tail_e_to_p_pressure);
     #endif
   #endif
 }
 
 inline float calculate_volumetric_multiplier(const float &diameter) {
-  if (!parser.volumetric_enabled || diameter == 0) return 1.0;
-  return 1.0 / CIRCLE_AREA(diameter * 0.5);
+  return (parser.volumetric_enabled && diameter) ? 1.0 / CIRCLE_AREA(diameter * 0.5) : 1.0;
 }
 
 void Planner::calculate_volumetric_multipliers() {
   for (uint8_t i = 0; i < COUNT(filament_size); i++) {
     volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
     refresh_e_factor(i);
   }
 }
 
 #if PLANNER_LEVELING

commit cba9c1cf9e7831a86acbdc35fe405fb600e0f6e3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 10 02:26:49 2017 -0600

    Add pre-calculated planner.e_factor

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index a761a649c1..8b20c91581 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -99,21 +99,22 @@ float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
       Planner::axis_steps_per_mm[XYZE_N],
       Planner::steps_to_mm[XYZE_N];
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
 
 // Initialized by settings.load()
-float Planner::filament_size[EXTRUDERS],         // As a baseline for the multiplier, filament diameter
+float Planner::e_factor[EXTRUDERS],              // The flow percentage and volumetric multiplier combine to scale E movement
+      Planner::filament_size[EXTRUDERS],         // As a baseline for the multiplier, filament diameter
       Planner::volumetric_multiplier[EXTRUDERS]; // May be auto-adjusted by a filament width sensor
 
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N],
          Planner::max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
 
 uint32_t Planner::min_segment_time_us;
 
 // Initialized by settings.load()
 float Planner::min_feedrate_mm_s,
       Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
@@ -539,22 +540,24 @@ void Planner::check_axes_activity() {
     #endif
   #endif
 }
 
 inline float calculate_volumetric_multiplier(const float &diameter) {
   if (!parser.volumetric_enabled || diameter == 0) return 1.0;
   return 1.0 / CIRCLE_AREA(diameter * 0.5);
 }
 
 void Planner::calculate_volumetric_multipliers() {
-  for (uint8_t i = 0; i < COUNT(filament_size); i++)
+  for (uint8_t i = 0; i < COUNT(filament_size); i++) {
     volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
+    refresh_e_factor(i);
+  }
 }
 
 #if PLANNER_LEVELING
   /**
    * rx, ry, rz - Cartesian positions in mm
    */
   void Planner::apply_leveling(float &rx, float &ry, float &rz) {
 
     if (!planner.leveling_active) return;
 
@@ -733,43 +736,40 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
   // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
   if (DEBUGGING(DRYRUN)) {
     position[E_AXIS] = target[E_AXIS];
     #if ENABLED(LIN_ADVANCE)
       position_float[E_AXIS] = e;
     #endif
   }
 
   long de = target[E_AXIS] - position[E_AXIS];
 
-  const float e_factor = volumetric_multiplier[extruder] * flow_percentage[extruder] * 0.01;
-
   #if ENABLED(LIN_ADVANCE)
     float de_float = e - position_float[E_AXIS]; // Should this include e_factor?
   #endif
 
   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
     if (de) {
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         if (thermalManager.tooColdToExtrude(extruder)) {
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           de = 0; // no difference
           #if ENABLED(LIN_ADVANCE)
             position_float[E_AXIS] = e;
             de_float = 0;
           #endif
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
         }
       #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-        const int32_t de_mm = labs(de * e_factor);
-        if (de_mm > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
+        if (labs(de * e_factor[extruder]) > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           de = 0; // no difference
           #if ENABLED(LIN_ADVANCE)
             position_float[E_AXIS] = e;
             de_float = 0;
           #endif
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
         }
       #endif // PREVENT_LENGTHY_EXTRUDE
@@ -796,21 +796,21 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
     if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
     if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
     if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
   #else
     if (da < 0) SBI(dm, X_AXIS);
     if (db < 0) SBI(dm, Y_AXIS);
     if (dc < 0) SBI(dm, Z_AXIS);
   #endif
   if (de < 0) SBI(dm, E_AXIS);
 
-  const float esteps_float = de * e_factor;
+  const float esteps_float = de * e_factor[extruder];
   const int32_t esteps = abs(esteps_float) + 0.5;
 
   // Calculate the buffer head after we push this byte
   const uint8_t next_buffer_head = next_block_index(block_buffer_head);
 
   // If the buffer is full: good! That means we are well ahead of the robot.
   // Rest here until there is room in the buffer.
   while (block_buffer_tail == next_buffer_head) idle();
 
   // Prepare to set up new block

commit 600c85226ec85ca5851f0a2472f87c2b083f78af
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Thu Nov 9 22:50:32 2017 -0600

    Normalize load/unload length in M600

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index dde261ffc4..a761a649c1 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -733,50 +733,55 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
   // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
   if (DEBUGGING(DRYRUN)) {
     position[E_AXIS] = target[E_AXIS];
     #if ENABLED(LIN_ADVANCE)
       position_float[E_AXIS] = e;
     #endif
   }
 
   long de = target[E_AXIS] - position[E_AXIS];
 
+  const float e_factor = volumetric_multiplier[extruder] * flow_percentage[extruder] * 0.01;
+
   #if ENABLED(LIN_ADVANCE)
-    float de_float = e - position_float[E_AXIS];
+    float de_float = e - position_float[E_AXIS]; // Should this include e_factor?
   #endif
 
-  #if ENABLED(PREVENT_COLD_EXTRUSION)
+  #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
     if (de) {
-      if (thermalManager.tooColdToExtrude(extruder)) {
-        position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
-        de = 0; // no difference
-        #if ENABLED(LIN_ADVANCE)
-          position_float[E_AXIS] = e;
-          de_float = 0;
-        #endif
-        SERIAL_ECHO_START();
-        SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
-      }
+      #if ENABLED(PREVENT_COLD_EXTRUSION)
+        if (thermalManager.tooColdToExtrude(extruder)) {
+          position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
+          de = 0; // no difference
+          #if ENABLED(LIN_ADVANCE)
+            position_float[E_AXIS] = e;
+            de_float = 0;
+          #endif
+          SERIAL_ECHO_START();
+          SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
+        }
+      #endif // PREVENT_COLD_EXTRUSION
       #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-        if (labs(de) > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
+        const int32_t de_mm = labs(de * e_factor);
+        if (de_mm > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
           position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
           de = 0; // no difference
           #if ENABLED(LIN_ADVANCE)
             position_float[E_AXIS] = e;
             de_float = 0;
           #endif
           SERIAL_ECHO_START();
           SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
         }
-      #endif
+      #endif // PREVENT_LENGTHY_EXTRUDE
     }
-  #endif
+  #endif // PREVENT_COLD_EXTRUSION || PREVENT_LENGTHY_EXTRUDE
 
   // Compute direction bit-mask for this block
   uint8_t dm = 0;
   #if CORE_IS_XY
     if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
     if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
     if (dc < 0) SBI(dm, Z_AXIS);
     if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
     if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
   #elif CORE_IS_XZ
@@ -791,21 +796,21 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
     if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
     if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
     if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
   #else
     if (da < 0) SBI(dm, X_AXIS);
     if (db < 0) SBI(dm, Y_AXIS);
     if (dc < 0) SBI(dm, Z_AXIS);
   #endif
   if (de < 0) SBI(dm, E_AXIS);
 
-  const float esteps_float = de * volumetric_multiplier[extruder] * flow_percentage[extruder] * 0.01;
+  const float esteps_float = de * e_factor;
   const int32_t esteps = abs(esteps_float) + 0.5;
 
   // Calculate the buffer head after we push this byte
   const uint8_t next_buffer_head = next_block_index(block_buffer_head);
 
   // If the buffer is full: good! That means we are well ahead of the robot.
   // Rest here until there is room in the buffer.
   while (block_buffer_tail == next_buffer_head) idle();
 
   // Prepare to set up new block

commit f8393a09086f01eafbb8563411da3b237c96b982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 2 23:59:42 2017 -0500

    Operate in Native Machine Space

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 56063e744a..dde261ffc4 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -125,21 +125,21 @@ float Planner::min_feedrate_mm_s,
 #if HAS_LEVELING
   bool Planner::leveling_active = false; // Flag that auto bed leveling is enabled
   #if ABL_PLANAR
     matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
   #endif
 #endif
 
 #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
   float Planner::z_fade_height, // Initialized by settings.load()
         Planner::inverse_z_fade_height,
-        Planner::last_raw_lz;
+        Planner::last_fade_z;
 #endif
 
 #if ENABLED(AUTOTEMP)
   float Planner::autotemp_max = 250,
         Planner::autotemp_min = 210,
         Planner::autotemp_factor = 0.1;
   bool Planner::autotemp_enabled = false;
 #endif
 
 // private:
@@ -545,133 +545,129 @@ inline float calculate_volumetric_multiplier(const float &diameter) {
   return 1.0 / CIRCLE_AREA(diameter * 0.5);
 }
 
 void Planner::calculate_volumetric_multipliers() {
   for (uint8_t i = 0; i < COUNT(filament_size); i++)
     volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
 }
 
 #if PLANNER_LEVELING
   /**
-   * lx, ly, lz - logical (cartesian, not delta) positions in mm
+   * rx, ry, rz - Cartesian positions in mm
    */
-  void Planner::apply_leveling(float &lx, float &ly, float &lz) {
+  void Planner::apply_leveling(float &rx, float &ry, float &rz) {
 
     if (!planner.leveling_active) return;
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      const float fade_scaling_factor = fade_scaling_factor_for_z(lz);
+      const float fade_scaling_factor = fade_scaling_factor_for_z(rz);
       if (!fade_scaling_factor) return;
     #else
       constexpr float fade_scaling_factor = 1.0;
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
 
-      lz += ubl.get_z_correction(lx, ly) * fade_scaling_factor;
+      rz += ubl.get_z_correction(rx, ry) * fade_scaling_factor;
 
     #elif ENABLED(MESH_BED_LEVELING)
 
-      lz += mbl.get_z(RAW_X_POSITION(lx), RAW_Y_POSITION(ly)
+      rz += mbl.get_z(rx, ry
         #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
           , fade_scaling_factor
         #endif
       );
 
     #elif ABL_PLANAR
 
       UNUSED(fade_scaling_factor);
 
-      float dx = RAW_X_POSITION(lx) - (X_TILT_FULCRUM),
-            dy = RAW_Y_POSITION(ly) - (Y_TILT_FULCRUM),
-            dz = RAW_Z_POSITION(lz);
+      float dx = rx - (X_TILT_FULCRUM),
+            dy = ry - (Y_TILT_FULCRUM);
 
-      apply_rotation_xyz(bed_level_matrix, dx, dy, dz);
+      apply_rotation_xyz(bed_level_matrix, dx, dy, rz);
 
-      lx = LOGICAL_X_POSITION(dx + X_TILT_FULCRUM);
-      ly = LOGICAL_Y_POSITION(dy + Y_TILT_FULCRUM);
-      lz = LOGICAL_Z_POSITION(dz);
+      rx = dx + X_TILT_FULCRUM;
+      ry = dy + Y_TILT_FULCRUM;
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
-      float tmp[XYZ] = { lx, ly, 0 };
-      lz += bilinear_z_offset(tmp) * fade_scaling_factor;
+      float tmp[XYZ] = { rx, ry, 0 };
+      rz += bilinear_z_offset(tmp) * fade_scaling_factor;
 
     #endif
   }
 
-  void Planner::unapply_leveling(float logical[XYZ]) {
+  void Planner::unapply_leveling(float raw[XYZ]) {
 
     if (!planner.leveling_active) return;
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      if (z_fade_height && RAW_Z_POSITION(logical[Z_AXIS]) >= z_fade_height) return;
+      if (z_fade_height && raw[Z_AXIS] >= z_fade_height) return;
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
 
-      const float z_physical = RAW_Z_POSITION(logical[Z_AXIS]),
-                  z_correct = ubl.get_z_correction(logical[X_AXIS], logical[Y_AXIS]),
-                  z_virtual = z_physical - z_correct;
-            float z_logical = LOGICAL_Z_POSITION(z_virtual);
+      const float z_correct = ubl.get_z_correction(raw[X_AXIS], raw[Y_AXIS]);
+            float z_raw = raw[Z_AXIS] - z_correct;
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
 
-        // for P=physical_z, L=logical_z, M=mesh_z, H=fade_height,
+        // for P=physical_z, L=raw_z, M=mesh_z, H=fade_height,
         // Given P=L+M(1-L/H) (faded mesh correction formula for L<H)
         //  then L=P-M(1-L/H)
         //    so L=P-M+ML/H
         //    so L-ML/H=P-M
         //    so L(1-M/H)=P-M
         //    so L=(P-M)/(1-M/H) for L<H
 
         if (planner.z_fade_height) {
-          if (z_logical >= planner.z_fade_height)
-            z_logical = LOGICAL_Z_POSITION(z_physical);
+          if (z_raw >= planner.z_fade_height)
+            z_raw = raw[Z_AXIS];
           else
-            z_logical /= 1.0 - z_correct * planner.inverse_z_fade_height;
+            z_raw /= 1.0 - z_correct * planner.inverse_z_fade_height;
         }
 
       #endif // ENABLE_LEVELING_FADE_HEIGHT
 
-      logical[Z_AXIS] = z_logical;
+      raw[Z_AXIS] = z_raw;
 
     #elif ENABLED(MESH_BED_LEVELING)
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        const float c = mbl.get_z(RAW_X_POSITION(logical[X_AXIS]), RAW_Y_POSITION(logical[Y_AXIS]), 1.0);
-        logical[Z_AXIS] = (z_fade_height * (RAW_Z_POSITION(logical[Z_AXIS]) - c)) / (z_fade_height - c);
+        const float c = mbl.get_z(raw[X_AXIS], raw[Y_AXIS], 1.0);
+        raw[Z_AXIS] = (z_fade_height * (raw[Z_AXIS] - c)) / (z_fade_height - c);
       #else
-        logical[Z_AXIS] -= mbl.get_z(RAW_X_POSITION(logical[X_AXIS]), RAW_Y_POSITION(logical[Y_AXIS]));
+        raw[Z_AXIS] -= mbl.get_z(raw[X_AXIS], raw[Y_AXIS]);
       #endif
 
     #elif ABL_PLANAR
 
       matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
 
-      float dx = RAW_X_POSITION(logical[X_AXIS]) - (X_TILT_FULCRUM),
-            dy = RAW_Y_POSITION(logical[Y_AXIS]) - (Y_TILT_FULCRUM),
-            dz = RAW_Z_POSITION(logical[Z_AXIS]);
+      float dx = raw[X_AXIS] - (X_TILT_FULCRUM),
+            dy = raw[Y_AXIS] - (Y_TILT_FULCRUM),
+            dz = raw[Z_AXIS];
 
       apply_rotation_xyz(inverse, dx, dy, dz);
 
-      logical[X_AXIS] = LOGICAL_X_POSITION(dx + X_TILT_FULCRUM);
-      logical[Y_AXIS] = LOGICAL_Y_POSITION(dy + Y_TILT_FULCRUM);
-      logical[Z_AXIS] = LOGICAL_Z_POSITION(dz);
+      raw[X_AXIS] = dx + X_TILT_FULCRUM;
+      raw[Y_AXIS] = dy + Y_TILT_FULCRUM;
+      raw[Z_AXIS] = dz;
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        const float c = bilinear_z_offset(logical);
-        logical[Z_AXIS] = (z_fade_height * (RAW_Z_POSITION(logical[Z_AXIS]) - c)) / (z_fade_height - c);
+        const float c = bilinear_z_offset(raw);
+        raw[Z_AXIS] = (z_fade_height * (raw[Z_AXIS]) - c) / (z_fade_height - c);
       #else
-        logical[Z_AXIS] -= bilinear_z_offset(logical);
+        raw[Z_AXIS] -= bilinear_z_offset(raw);
       #endif
 
     #endif
   }
 
 #endif // PLANNER_LEVELING
 
 /**
  * Planner::_buffer_line
  *

commit 3e8754a38a57f0b37e6880b1ddc6214890f6cf5e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 29 18:21:15 2017 -0500

    Add/correct time units on planner vars / M205 B

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7da09c8c1f..56063e744a 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -105,21 +105,21 @@ float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
 
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
 
 // Initialized by settings.load()
 float Planner::filament_size[EXTRUDERS],         // As a baseline for the multiplier, filament diameter
       Planner::volumetric_multiplier[EXTRUDERS]; // May be auto-adjusted by a filament width sensor
 
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N],
          Planner::max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
 
-millis_t Planner::min_segment_time;
+uint32_t Planner::min_segment_time_us;
 
 // Initialized by settings.load()
 float Planner::min_feedrate_mm_s,
       Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
       Planner::retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
       Planner::travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
       Planner::max_jerk[XYZE],       // The largest speed change requiring no acceleration
       Planner::min_travel_feedrate_mm_s;
 
 #if HAS_LEVELING
@@ -152,21 +152,21 @@ float Planner::previous_speed[NUM_AXIS],
       Planner::previous_nominal_speed;
 
 #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
   uint8_t Planner::g_uc_extruder_last_move[EXTRUDERS] = { 0 };
 #endif
 
 #ifdef XY_FREQUENCY_LIMIT
   // Old direction bits. Used for speed calculations
   unsigned char Planner::old_direction_bits = 0;
   // Segment times (in ¬µs). Used for speed calculations
-  long Planner::axis_segment_time[2][3] = { {MAX_FREQ_TIME + 1, 0, 0}, {MAX_FREQ_TIME + 1, 0, 0} };
+  uint32_t Planner::axis_segment_time_us[2][3] = { { MAX_FREQ_TIME_US + 1, 0, 0 }, { MAX_FREQ_TIME_US + 1, 0, 0 } };
 #endif
 
 #if ENABLED(LIN_ADVANCE)
   float Planner::extruder_advance_k, // Initialized by settings.load()
         Planner::advance_ed_ratio,   // Initialized by settings.load()
         Planner::position_float[NUM_AXIS] = { 0 };
 #endif
 
 #if ENABLED(ULTRA_LCD)
   volatile uint32_t Planner::block_buffer_runtime_us = 0;
@@ -1050,37 +1050,37 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
   float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
 
   // Calculate moves/second for this move. No divide by zero due to previous checks.
   float inverse_mm_s = fr_mm_s * inverse_millimeters;
 
   const uint8_t moves_queued = movesplanned();
 
   // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
     // Segment time im micro seconds
-    unsigned long segment_time = LROUND(1000000.0 / inverse_mm_s);
+    uint32_t segment_time_us = LROUND(1000000.0 / inverse_mm_s);
   #endif
   #if ENABLED(SLOWDOWN)
     if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
-      if (segment_time < min_segment_time) {
+      if (segment_time_us < min_segment_time_us) {
         // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
-        inverse_mm_s = 1000000.0 / (segment_time + LROUND(2 * (min_segment_time - segment_time) / moves_queued));
+        inverse_mm_s = 1000000.0 / (segment_time_us + LROUND(2 * (min_segment_time_us - segment_time_us) / moves_queued));
         #if defined(XY_FREQUENCY_LIMIT) || ENABLED(ULTRA_LCD)
-          segment_time = LROUND(1000000.0 / inverse_mm_s);
+          segment_time_us = LROUND(1000000.0 / inverse_mm_s);
         #endif
       }
     }
   #endif
 
   #if ENABLED(ULTRA_LCD)
     CRITICAL_SECTION_START
-      block_buffer_runtime_us += segment_time;
+      block_buffer_runtime_us += segment_time_us;
     CRITICAL_SECTION_END
   #endif
 
   block->nominal_speed = block->millimeters * inverse_mm_s; // (mm/sec) Always > 0
   block->nominal_rate = CEIL(block->step_event_count * inverse_mm_s); // (step/sec) Always > 0
 
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     static float filwidth_e_count = 0, filwidth_delay_dist = 0;
 
     //FMM update ring buffer used for delay with filament measurements
@@ -1123,48 +1123,48 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
     #endif
     if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
   }
 
   // Max segment time in ¬µs.
   #ifdef XY_FREQUENCY_LIMIT
 
     // Check and limit the xy direction change frequency
     const unsigned char direction_change = block->direction_bits ^ old_direction_bits;
     old_direction_bits = block->direction_bits;
-    segment_time = LROUND((float)segment_time / speed_factor);
+    segment_time_us = LROUND((float)segment_time_us / speed_factor);
 
-    long xs0 = axis_segment_time[X_AXIS][0],
-         xs1 = axis_segment_time[X_AXIS][1],
-         xs2 = axis_segment_time[X_AXIS][2],
-         ys0 = axis_segment_time[Y_AXIS][0],
-         ys1 = axis_segment_time[Y_AXIS][1],
-         ys2 = axis_segment_time[Y_AXIS][2];
+    uint32_t xs0 = axis_segment_time_us[X_AXIS][0],
+             xs1 = axis_segment_time_us[X_AXIS][1],
+             xs2 = axis_segment_time_us[X_AXIS][2],
+             ys0 = axis_segment_time_us[Y_AXIS][0],
+             ys1 = axis_segment_time_us[Y_AXIS][1],
+             ys2 = axis_segment_time_us[Y_AXIS][2];
 
     if (TEST(direction_change, X_AXIS)) {
-      xs2 = axis_segment_time[X_AXIS][2] = xs1;
-      xs1 = axis_segment_time[X_AXIS][1] = xs0;
+      xs2 = axis_segment_time_us[X_AXIS][2] = xs1;
+      xs1 = axis_segment_time_us[X_AXIS][1] = xs0;
       xs0 = 0;
     }
-    xs0 = axis_segment_time[X_AXIS][0] = xs0 + segment_time;
+    xs0 = axis_segment_time_us[X_AXIS][0] = xs0 + segment_time_us;
 
     if (TEST(direction_change, Y_AXIS)) {
-      ys2 = axis_segment_time[Y_AXIS][2] = axis_segment_time[Y_AXIS][1];
-      ys1 = axis_segment_time[Y_AXIS][1] = axis_segment_time[Y_AXIS][0];
+      ys2 = axis_segment_time_us[Y_AXIS][2] = axis_segment_time_us[Y_AXIS][1];
+      ys1 = axis_segment_time_us[Y_AXIS][1] = axis_segment_time_us[Y_AXIS][0];
       ys0 = 0;
     }
-    ys0 = axis_segment_time[Y_AXIS][0] = ys0 + segment_time;
+    ys0 = axis_segment_time_us[Y_AXIS][0] = ys0 + segment_time_us;
 
-    const long max_x_segment_time = MAX3(xs0, xs1, xs2),
-               max_y_segment_time = MAX3(ys0, ys1, ys2),
-               min_xy_segment_time = min(max_x_segment_time, max_y_segment_time);
-    if (min_xy_segment_time < MAX_FREQ_TIME) {
-      const float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME);
+    const uint32_t max_x_segment_time = MAX3(xs0, xs1, xs2),
+                   max_y_segment_time = MAX3(ys0, ys1, ys2),
+                   min_xy_segment_time = min(max_x_segment_time, max_y_segment_time);
+    if (min_xy_segment_time < MAX_FREQ_TIME_US) {
+      const float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME_US);
       NOMORE(speed_factor, low_sf);
     }
   #endif // XY_FREQUENCY_LIMIT
 
   // Correct the speed
   if (speed_factor < 1.0) {
     LOOP_XYZE(i) current_speed[i] *= speed_factor;
     block->nominal_speed *= speed_factor;
     block->nominal_rate *= speed_factor;
   }

commit 3e3911fb81cef6f17f7e77c54f520e2a4579225b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 17:21:25 2017 -0500

    Use planner.leveling_active for all leveling systems

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 57bd730f20..7da09c8c1f 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -115,22 +115,22 @@ uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N],
 millis_t Planner::min_segment_time;
 
 // Initialized by settings.load()
 float Planner::min_feedrate_mm_s,
       Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
       Planner::retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
       Planner::travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
       Planner::max_jerk[XYZE],       // The largest speed change requiring no acceleration
       Planner::min_travel_feedrate_mm_s;
 
-#if OLDSCHOOL_ABL
-  bool Planner::abl_enabled = false; // Flag that auto bed leveling is enabled
+#if HAS_LEVELING
+  bool Planner::leveling_active = false; // Flag that auto bed leveling is enabled
   #if ABL_PLANAR
     matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
   #endif
 #endif
 
 #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
   float Planner::z_fade_height, // Initialized by settings.load()
         Planner::inverse_z_fade_height,
         Planner::last_raw_lz;
 #endif
@@ -549,21 +549,21 @@ void Planner::calculate_volumetric_multipliers() {
   for (uint8_t i = 0; i < COUNT(filament_size); i++)
     volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
 }
 
 #if PLANNER_LEVELING
   /**
    * lx, ly, lz - logical (cartesian, not delta) positions in mm
    */
   void Planner::apply_leveling(float &lx, float &ly, float &lz) {
 
-    if (!LEVELING_IS_ACTIVE()) return;
+    if (!planner.leveling_active) return;
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       const float fade_scaling_factor = fade_scaling_factor_for_z(lz);
       if (!fade_scaling_factor) return;
     #else
       constexpr float fade_scaling_factor = 1.0;
     #endif
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
 
@@ -594,62 +594,55 @@ void Planner::calculate_volumetric_multipliers() {
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       float tmp[XYZ] = { lx, ly, 0 };
       lz += bilinear_z_offset(tmp) * fade_scaling_factor;
 
     #endif
   }
 
   void Planner::unapply_leveling(float logical[XYZ]) {
 
-    #if ENABLED(AUTO_BED_LEVELING_UBL)
-
-      if (ubl.state.active) {
-
-        const float z_physical = RAW_Z_POSITION(logical[Z_AXIS]),
-                    z_correct = ubl.get_z_correction(logical[X_AXIS], logical[Y_AXIS]),
-                    z_virtual = z_physical - z_correct;
-              float z_logical = LOGICAL_Z_POSITION(z_virtual);
-
-        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-
-          // for P=physical_z, L=logical_z, M=mesh_z, H=fade_height,
-          // Given P=L+M(1-L/H) (faded mesh correction formula for L<H)
-          //  then L=P-M(1-L/H)
-          //    so L=P-M+ML/H
-          //    so L-ML/H=P-M
-          //    so L(1-M/H)=P-M
-          //    so L=(P-M)/(1-M/H) for L<H
+    if (!planner.leveling_active) return;
 
-          if (planner.z_fade_height) {
-            if (z_logical >= planner.z_fade_height)
-              z_logical = LOGICAL_Z_POSITION(z_physical);
-            else
-              z_logical /= 1.0 - z_correct * planner.inverse_z_fade_height;
-          }
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      if (z_fade_height && RAW_Z_POSITION(logical[Z_AXIS]) >= z_fade_height) return;
+    #endif
 
-        #endif // ENABLE_LEVELING_FADE_HEIGHT
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
 
-        logical[Z_AXIS] = z_logical;
-      }
+      const float z_physical = RAW_Z_POSITION(logical[Z_AXIS]),
+                  z_correct = ubl.get_z_correction(logical[X_AXIS], logical[Y_AXIS]),
+                  z_virtual = z_physical - z_correct;
+            float z_logical = LOGICAL_Z_POSITION(z_virtual);
 
-      return; // don't fall thru to other ENABLE_LEVELING_FADE_HEIGHT logic
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
 
-    #endif
+        // for P=physical_z, L=logical_z, M=mesh_z, H=fade_height,
+        // Given P=L+M(1-L/H) (faded mesh correction formula for L<H)
+        //  then L=P-M(1-L/H)
+        //    so L=P-M+ML/H
+        //    so L-ML/H=P-M
+        //    so L(1-M/H)=P-M
+        //    so L=(P-M)/(1-M/H) for L<H
+
+        if (planner.z_fade_height) {
+          if (z_logical >= planner.z_fade_height)
+            z_logical = LOGICAL_Z_POSITION(z_physical);
+          else
+            z_logical /= 1.0 - z_correct * planner.inverse_z_fade_height;
+        }
 
-    if (!LEVELING_IS_ACTIVE()) return;
+      #endif // ENABLE_LEVELING_FADE_HEIGHT
 
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      if (z_fade_height && RAW_Z_POSITION(logical[Z_AXIS]) >= z_fade_height) return;
-    #endif
+      logical[Z_AXIS] = z_logical;
 
-    #if ENABLED(MESH_BED_LEVELING)
+    #elif ENABLED(MESH_BED_LEVELING)
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         const float c = mbl.get_z(RAW_X_POSITION(logical[X_AXIS]), RAW_Y_POSITION(logical[Y_AXIS]), 1.0);
         logical[Z_AXIS] = (z_fade_height * (RAW_Z_POSITION(logical[Z_AXIS]) - c)) / (z_fade_height - c);
       #else
         logical[Z_AXIS] -= mbl.get_z(RAW_X_POSITION(logical[X_AXIS]), RAW_Y_POSITION(logical[Y_AXIS]));
       #endif
 
     #elif ABL_PLANAR
 

commit ca1e47375c71e6ddd4973a63a7a8cbf125a439bd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 10:39:11 2017 -0500

    Move fade_scaling_factor_for_z to Planner

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index a7fed29e15..57bd730f20 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -124,21 +124,22 @@ float Planner::min_feedrate_mm_s,
 
 #if OLDSCHOOL_ABL
   bool Planner::abl_enabled = false; // Flag that auto bed leveling is enabled
   #if ABL_PLANAR
     matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
   #endif
 #endif
 
 #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
   float Planner::z_fade_height, // Initialized by settings.load()
-        Planner::inverse_z_fade_height;
+        Planner::inverse_z_fade_height,
+        Planner::last_raw_lz;
 #endif
 
 #if ENABLED(AUTOTEMP)
   float Planner::autotemp_max = 250,
         Planner::autotemp_min = 210,
         Planner::autotemp_factor = 0.1;
   bool Planner::autotemp_enabled = false;
 #endif
 
 // private:
@@ -550,72 +551,57 @@ void Planner::calculate_volumetric_multipliers() {
 }
 
 #if PLANNER_LEVELING
   /**
    * lx, ly, lz - logical (cartesian, not delta) positions in mm
    */
   void Planner::apply_leveling(float &lx, float &ly, float &lz) {
 
     if (!LEVELING_IS_ACTIVE()) return;
 
-    #if ENABLED(AUTO_BED_LEVELING_UBL)
-      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        // if z_fade_height enabled (nonzero) and raw_z above it, no leveling required
-        if (planner.z_fade_height && planner.z_fade_height <= RAW_Z_POSITION(lz)) return;
-        lz += ubl.get_z_correction(lx, ly) * ubl.fade_scaling_factor_for_z(lz);
-      #else // no fade
-        lz += ubl.get_z_correction(lx, ly);
-      #endif // FADE
-    #endif // UBL
-
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT) && DISABLED(AUTO_BED_LEVELING_UBL)
-      static float z_fade_factor = 1.0, last_raw_lz = -999.0;
-      if (z_fade_height) {
-        const float raw_lz = RAW_Z_POSITION(lz);
-        if (raw_lz >= z_fade_height) return;
-        if (last_raw_lz != raw_lz) {
-          last_raw_lz = raw_lz;
-          z_fade_factor = 1.0 - raw_lz * inverse_z_fade_height;
-        }
-      }
-      else
-        z_fade_factor = 1.0;
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      const float fade_scaling_factor = fade_scaling_factor_for_z(lz);
+      if (!fade_scaling_factor) return;
+    #else
+      constexpr float fade_scaling_factor = 1.0;
     #endif
 
-    #if ENABLED(MESH_BED_LEVELING)
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+
+      lz += ubl.get_z_correction(lx, ly) * fade_scaling_factor;
+
+    #elif ENABLED(MESH_BED_LEVELING)
 
       lz += mbl.get_z(RAW_X_POSITION(lx), RAW_Y_POSITION(ly)
         #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-          , z_fade_factor
+          , fade_scaling_factor
         #endif
-        );
+      );
 
     #elif ABL_PLANAR
 
+      UNUSED(fade_scaling_factor);
+
       float dx = RAW_X_POSITION(lx) - (X_TILT_FULCRUM),
             dy = RAW_Y_POSITION(ly) - (Y_TILT_FULCRUM),
             dz = RAW_Z_POSITION(lz);
 
       apply_rotation_xyz(bed_level_matrix, dx, dy, dz);
 
       lx = LOGICAL_X_POSITION(dx + X_TILT_FULCRUM);
       ly = LOGICAL_Y_POSITION(dy + Y_TILT_FULCRUM);
       lz = LOGICAL_Z_POSITION(dz);
 
     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
       float tmp[XYZ] = { lx, ly, 0 };
-      lz += bilinear_z_offset(tmp)
-        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-          * z_fade_factor
-        #endif
-      ;
+      lz += bilinear_z_offset(tmp) * fade_scaling_factor;
 
     #endif
   }
 
   void Planner::unapply_leveling(float logical[XYZ]) {
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
 
       if (ubl.state.active) {
 

commit 9a930ebec27008d2e47161d050e7d1f9dd534b66
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 10:25:05 2017 -0500

    Make leveling_is_active a macro

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 7d55a0df9e..a7fed29e15 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -548,57 +548,53 @@ void Planner::calculate_volumetric_multipliers() {
   for (uint8_t i = 0; i < COUNT(filament_size); i++)
     volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
 }
 
 #if PLANNER_LEVELING
   /**
    * lx, ly, lz - logical (cartesian, not delta) positions in mm
    */
   void Planner::apply_leveling(float &lx, float &ly, float &lz) {
 
+    if (!LEVELING_IS_ACTIVE()) return;
+
     #if ENABLED(AUTO_BED_LEVELING_UBL)
-      if (!ubl.state.active) return;
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         // if z_fade_height enabled (nonzero) and raw_z above it, no leveling required
         if (planner.z_fade_height && planner.z_fade_height <= RAW_Z_POSITION(lz)) return;
         lz += ubl.get_z_correction(lx, ly) * ubl.fade_scaling_factor_for_z(lz);
       #else // no fade
         lz += ubl.get_z_correction(lx, ly);
       #endif // FADE
     #endif // UBL
 
-    #if OLDSCHOOL_ABL
-      if (!abl_enabled) return;
-    #endif
-
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT) && DISABLED(AUTO_BED_LEVELING_UBL)
       static float z_fade_factor = 1.0, last_raw_lz = -999.0;
       if (z_fade_height) {
         const float raw_lz = RAW_Z_POSITION(lz);
         if (raw_lz >= z_fade_height) return;
         if (last_raw_lz != raw_lz) {
           last_raw_lz = raw_lz;
           z_fade_factor = 1.0 - raw_lz * inverse_z_fade_height;
         }
       }
       else
         z_fade_factor = 1.0;
     #endif
 
     #if ENABLED(MESH_BED_LEVELING)
 
-      if (mbl.active())
-        lz += mbl.get_z(RAW_X_POSITION(lx), RAW_Y_POSITION(ly)
-          #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-            , z_fade_factor
-          #endif
-          );
+      lz += mbl.get_z(RAW_X_POSITION(lx), RAW_Y_POSITION(ly)
+        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+          , z_fade_factor
+        #endif
+        );
 
     #elif ABL_PLANAR
 
       float dx = RAW_X_POSITION(lx) - (X_TILT_FULCRUM),
             dy = RAW_Y_POSITION(ly) - (Y_TILT_FULCRUM),
             dz = RAW_Z_POSITION(lz);
 
       apply_rotation_xyz(bed_level_matrix, dx, dy, dz);
 
       lx = LOGICAL_X_POSITION(dx + X_TILT_FULCRUM);
@@ -647,38 +643,34 @@ void Planner::calculate_volumetric_multipliers() {
 
         #endif // ENABLE_LEVELING_FADE_HEIGHT
 
         logical[Z_AXIS] = z_logical;
       }
 
       return; // don't fall thru to other ENABLE_LEVELING_FADE_HEIGHT logic
 
     #endif
 
-    #if OLDSCHOOL_ABL
-      if (!abl_enabled) return;
-    #endif
+    if (!LEVELING_IS_ACTIVE()) return;
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       if (z_fade_height && RAW_Z_POSITION(logical[Z_AXIS]) >= z_fade_height) return;
     #endif
 
     #if ENABLED(MESH_BED_LEVELING)
 
-      if (mbl.active()) {
-        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-          const float c = mbl.get_z(RAW_X_POSITION(logical[X_AXIS]), RAW_Y_POSITION(logical[Y_AXIS]), 1.0);
-          logical[Z_AXIS] = (z_fade_height * (RAW_Z_POSITION(logical[Z_AXIS]) - c)) / (z_fade_height - c);
-        #else
-          logical[Z_AXIS] -= mbl.get_z(RAW_X_POSITION(logical[X_AXIS]), RAW_Y_POSITION(logical[Y_AXIS]));
-        #endif
-      }
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        const float c = mbl.get_z(RAW_X_POSITION(logical[X_AXIS]), RAW_Y_POSITION(logical[Y_AXIS]), 1.0);
+        logical[Z_AXIS] = (z_fade_height * (RAW_Z_POSITION(logical[Z_AXIS]) - c)) / (z_fade_height - c);
+      #else
+        logical[Z_AXIS] -= mbl.get_z(RAW_X_POSITION(logical[X_AXIS]), RAW_Y_POSITION(logical[Y_AXIS]));
+      #endif
 
     #elif ABL_PLANAR
 
       matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
 
       float dx = RAW_X_POSITION(logical[X_AXIS]) - (X_TILT_FULCRUM),
             dy = RAW_Y_POSITION(logical[Y_AXIS]) - (Y_TILT_FULCRUM),
             dz = RAW_Z_POSITION(logical[Z_AXIS]);
 
       apply_rotation_xyz(inverse, dx, dy, dz);

commit 1adb5a6a4800e65e04cef5833dc1cf21c7e13c2e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 12 22:20:02 2017 -0500

    Remove obsolete UBL z_offset

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 37d9f6e132..7d55a0df9e 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -553,23 +553,23 @@ void Planner::calculate_volumetric_multipliers() {
   /**
    * lx, ly, lz - logical (cartesian, not delta) positions in mm
    */
   void Planner::apply_leveling(float &lx, float &ly, float &lz) {
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       if (!ubl.state.active) return;
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         // if z_fade_height enabled (nonzero) and raw_z above it, no leveling required
         if (planner.z_fade_height && planner.z_fade_height <= RAW_Z_POSITION(lz)) return;
-        lz += ubl.state.z_offset + ubl.get_z_correction(lx, ly) * ubl.fade_scaling_factor_for_z(lz);
+        lz += ubl.get_z_correction(lx, ly) * ubl.fade_scaling_factor_for_z(lz);
       #else // no fade
-        lz += ubl.state.z_offset + ubl.get_z_correction(lx, ly);
+        lz += ubl.get_z_correction(lx, ly);
       #endif // FADE
     #endif // UBL
 
     #if OLDSCHOOL_ABL
       if (!abl_enabled) return;
     #endif
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT) && DISABLED(AUTO_BED_LEVELING_UBL)
       static float z_fade_factor = 1.0, last_raw_lz = -999.0;
       if (z_fade_height) {
@@ -618,36 +618,36 @@ void Planner::calculate_volumetric_multipliers() {
   }
 
   void Planner::unapply_leveling(float logical[XYZ]) {
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
 
       if (ubl.state.active) {
 
         const float z_physical = RAW_Z_POSITION(logical[Z_AXIS]),
                     z_correct = ubl.get_z_correction(logical[X_AXIS], logical[Y_AXIS]),
-                    z_virtual = z_physical - ubl.state.z_offset - z_correct;
+                    z_virtual = z_physical - z_correct;
               float z_logical = LOGICAL_Z_POSITION(z_virtual);
 
         #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
 
-          // for P=physical_z, L=logical_z, M=mesh_z, O=z_offset, H=fade_height,
-          // Given P=L+O+M(1-L/H) (faded mesh correction formula for L<H)
-          //  then L=P-O-M(1-L/H)
-          //    so L=P-O-M+ML/H
-          //    so L-ML/H=P-O-M
-          //    so L(1-M/H)=P-O-M
-          //    so L=(P-O-M)/(1-M/H) for L<H
+          // for P=physical_z, L=logical_z, M=mesh_z, H=fade_height,
+          // Given P=L+M(1-L/H) (faded mesh correction formula for L<H)
+          //  then L=P-M(1-L/H)
+          //    so L=P-M+ML/H
+          //    so L-ML/H=P-M
+          //    so L(1-M/H)=P-M
+          //    so L=(P-M)/(1-M/H) for L<H
 
           if (planner.z_fade_height) {
             if (z_logical >= planner.z_fade_height)
-              z_logical = LOGICAL_Z_POSITION(z_physical - ubl.state.z_offset);
+              z_logical = LOGICAL_Z_POSITION(z_physical);
             else
               z_logical /= 1.0 - z_correct * planner.inverse_z_fade_height;
           }
 
         #endif // ENABLE_LEVELING_FADE_HEIGHT
 
         logical[Z_AXIS] = z_logical;
       }
 
       return; // don't fall thru to other ENABLE_LEVELING_FADE_HEIGHT logic

commit 03f4891fb98c032509643b6fbc8b6d24df6630b6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 9 04:25:18 2017 -0500

    Remove legacy ADVANCE feature

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 0373f342c0..37d9f6e132 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -221,24 +221,20 @@ void Planner::calculate_trapezoid_for_block(block_t* const block, const float &e
 
   // block->accelerate_until = accelerate_steps;
   // block->decelerate_after = accelerate_steps+plateau_steps;
 
   CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section
   if (!TEST(block->flag, BLOCK_BIT_BUSY)) { // Don't update variables if block is busy.
     block->accelerate_until = accelerate_steps;
     block->decelerate_after = accelerate_steps + plateau_steps;
     block->initial_rate = initial_rate;
     block->final_rate = final_rate;
-    #if ENABLED(ADVANCE)
-      block->initial_advance = block->advance * sq(entry_factor);
-      block->final_advance = block->advance * sq(exit_factor);
-    #endif
   }
   CRITICAL_SECTION_END;
 }
 
 // "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.
 // This method will calculate the junction jerk as the euclidean distance between the nominal
 // velocities of the respective blocks.
 //inline float junction_jerk(block_t *before, block_t *after) {
 //  return SQRT(
 //    POW((before->speed_x-after->speed_x), 2)+POW((before->speed_y-after->speed_y), 2));
@@ -1425,41 +1421,21 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
                             && (uint32_t)esteps != block->step_event_count
                             && de_float > 0.0;
     if (block->use_advance_lead)
       block->abs_adv_steps_multiplier8 = LROUND(
         extruder_advance_k
         * (UNEAR_ZERO(advance_ed_ratio) ? de_float / mm_D_float : advance_ed_ratio) // Use the fixed ratio, if set
         * (block->nominal_speed / (float)block->nominal_rate)
         * axis_steps_per_mm[E_AXIS_N] * 256.0
       );
 
-  #elif ENABLED(ADVANCE)
-
-    // Calculate advance rate
-    if (esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS])) {
-      const long acc_dist = estimate_acceleration_distance(0, block->nominal_rate, block->acceleration_steps_per_s2);
-      const float advance = ((STEPS_PER_CUBIC_MM_E) * (EXTRUDER_ADVANCE_K)) * HYPOT(current_speed[E_AXIS], EXTRUSION_AREA) * 256;
-      block->advance = advance;
-      block->advance_rate = acc_dist ? advance / (float)acc_dist : 0;
-    }
-    else
-      block->advance_rate = block->advance = 0;
-
-    /**
-     SERIAL_ECHO_START();
-     SERIAL_ECHOPGM("advance :");
-     SERIAL_ECHO(block->advance/256.0);
-     SERIAL_ECHOPGM("advance rate :");
-     SERIAL_ECHOLN(block->advance_rate/256.0);
-     */
-
-  #endif // ADVANCE or LIN_ADVANCE
+  #endif // LIN_ADVANCE
 
   calculate_trapezoid_for_block(block, block->entry_speed / block->nominal_speed, safe_speed / block->nominal_speed);
 
   // Move buffer head
   block_buffer_head = next_buffer_head;
 
   // Update the position (only when a move was queued)
   COPY(position, target);
   #if ENABLED(LIN_ADVANCE)
     position_float[X_AXIS] = a;

commit a10451ceed61e16a62d5395c27ad4ebe8ed06029
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 05:51:45 2017 -0500

    Move Volumetric methods to Planner

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index f906f769ea..0373f342c0 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -98,20 +98,24 @@ volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next
 float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
       Planner::axis_steps_per_mm[XYZE_N],
       Planner::steps_to_mm[XYZE_N];
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
 int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
 
+// Initialized by settings.load()
+float Planner::filament_size[EXTRUDERS],         // As a baseline for the multiplier, filament diameter
+      Planner::volumetric_multiplier[EXTRUDERS]; // May be auto-adjusted by a filament width sensor
+
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N],
          Planner::max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
 
 millis_t Planner::min_segment_time;
 
 // Initialized by settings.load()
 float Planner::min_feedrate_mm_s,
       Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
       Planner::retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
       Planner::travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
@@ -532,20 +536,30 @@ void Planner::check_axes_activity() {
   #if ENABLED(BARICUDA)
     #if HAS_HEATER_1
       analogWrite(HEATER_1_PIN, tail_valve_pressure);
     #endif
     #if HAS_HEATER_2
       analogWrite(HEATER_2_PIN, tail_e_to_p_pressure);
     #endif
   #endif
 }
 
+inline float calculate_volumetric_multiplier(const float &diameter) {
+  if (!parser.volumetric_enabled || diameter == 0) return 1.0;
+  return 1.0 / CIRCLE_AREA(diameter * 0.5);
+}
+
+void Planner::calculate_volumetric_multipliers() {
+  for (uint8_t i = 0; i < COUNT(filament_size); i++)
+    volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
+}
+
 #if PLANNER_LEVELING
   /**
    * lx, ly, lz - logical (cartesian, not delta) positions in mm
    */
   void Planner::apply_leveling(float &lx, float &ly, float &lz) {
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
       if (!ubl.state.active) return;
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         // if z_fade_height enabled (nonzero) and raw_z above it, no leveling required

commit 1a37ebc76dfc2a1e27fcd71590fcea7bc49d980a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 00:06:16 2017 -0500

    Move M163-M165 MIXING_EXTRUDER to cpp

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 1dc983c334..f906f769ea 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -73,20 +73,24 @@
 #endif
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
 #if ENABLED(BARICUDA)
   #include "../feature/baricuda.h"
 #endif
 
+#if ENABLED(MIXING_EXTRUDER)
+  #include "../feature/mixing.h"
+#endif
+
 Planner planner;
 
   // public:
 
 /**
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next block to be pushed
                  Planner::block_buffer_tail = 0;

commit b464887ea198d92bb3b5eac07e72decf074861b6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 22:58:13 2017 -0500

    Make BARICUDA a feature

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index d17a321aa3..1dc983c334 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -69,20 +69,24 @@
 #include "../Marlin.h"
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
   #include "../feature/filwidth.h"
 #endif
 
+#if ENABLED(BARICUDA)
+  #include "../feature/baricuda.h"
+#endif
+
 Planner planner;
 
   // public:
 
 /**
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next block to be pushed
                  Planner::block_buffer_tail = 0;

commit 4f1eadf41f1e2d79f7c62c60a1ead6ae34b63be5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 12 15:02:17 2017 -0500

    FILAMENT_WIDTH_SENSOR feature

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c37fe01bb9..d17a321aa3 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -65,20 +65,24 @@
 #include "../lcd/ultralcd.h"
 #include "../core/language.h"
 #include "../gcode/parser.h"
 
 #include "../Marlin.h"
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
+#if ENABLED(FILAMENT_WIDTH_SENSOR)
+  #include "../feature/filwidth.h"
+#endif
+
 Planner planner;
 
   // public:
 
 /**
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
 volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next block to be pushed
                  Planner::block_buffer_tail = 0;

commit 551752eac73a6f60de45b6465e2f224b2b2dca24
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 15:35:25 2017 -0500

    Consolidate "bedlevel" code

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 6e5aca6c1c..c37fe01bb9 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -57,27 +57,26 @@
  * IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)
  *
  */
 
 #include "planner.h"
 #include "stepper.h"
 #include "motion.h"
 #include "../module/temperature.h"
 #include "../lcd/ultralcd.h"
 #include "../core/language.h"
-#include "../feature/ubl/ubl.h"
 #include "../gcode/parser.h"
 
 #include "../Marlin.h"
 
-#if ENABLED(MESH_BED_LEVELING)
-  #include "../feature/mbl/mesh_bed_leveling.h"
+#if HAS_LEVELING
+  #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 Planner planner;
 
   // public:
 
 /**
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
@@ -100,26 +99,25 @@ uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N],
 millis_t Planner::min_segment_time;
 
 // Initialized by settings.load()
 float Planner::min_feedrate_mm_s,
       Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
       Planner::retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
       Planner::travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
       Planner::max_jerk[XYZE],       // The largest speed change requiring no acceleration
       Planner::min_travel_feedrate_mm_s;
 
-#if HAS_ABL
+#if OLDSCHOOL_ABL
   bool Planner::abl_enabled = false; // Flag that auto bed leveling is enabled
-#endif
-
-#if ABL_PLANAR
-  matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
+  #if ABL_PLANAR
+    matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
+  #endif
 #endif
 
 #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
   float Planner::z_fade_height, // Initialized by settings.load()
         Planner::inverse_z_fade_height;
 #endif
 
 #if ENABLED(AUTOTEMP)
   float Planner::autotemp_max = 250,
         Planner::autotemp_min = 210,
@@ -539,21 +537,21 @@ void Planner::check_axes_activity() {
       if (!ubl.state.active) return;
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         // if z_fade_height enabled (nonzero) and raw_z above it, no leveling required
         if (planner.z_fade_height && planner.z_fade_height <= RAW_Z_POSITION(lz)) return;
         lz += ubl.state.z_offset + ubl.get_z_correction(lx, ly) * ubl.fade_scaling_factor_for_z(lz);
       #else // no fade
         lz += ubl.state.z_offset + ubl.get_z_correction(lx, ly);
       #endif // FADE
     #endif // UBL
 
-    #if HAS_ABL
+    #if OLDSCHOOL_ABL
       if (!abl_enabled) return;
     #endif
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT) && DISABLED(AUTO_BED_LEVELING_UBL)
       static float z_fade_factor = 1.0, last_raw_lz = -999.0;
       if (z_fade_height) {
         const float raw_lz = RAW_Z_POSITION(lz);
         if (raw_lz >= z_fade_height) return;
         if (last_raw_lz != raw_lz) {
           last_raw_lz = raw_lz;
@@ -627,21 +625,21 @@ void Planner::check_axes_activity() {
 
         #endif // ENABLE_LEVELING_FADE_HEIGHT
 
         logical[Z_AXIS] = z_logical;
       }
 
       return; // don't fall thru to other ENABLE_LEVELING_FADE_HEIGHT logic
 
     #endif
 
-    #if HAS_ABL
+    #if OLDSCHOOL_ABL
       if (!abl_enabled) return;
     #endif
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       if (z_fade_height && RAW_Z_POSITION(logical[Z_AXIS]) >= z_fade_height) return;
     #endif
 
     #if ENABLED(MESH_BED_LEVELING)
 
       if (mbl.active()) {

commit bf7af95db361d57e844894278fcb0a5d5ea4eba5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 23:50:46 2017 -0500

    Move flow_percentage to Planner

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c239b324b4..6e5aca6c1c 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -85,20 +85,22 @@ volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next
                  Planner::block_buffer_tail = 0;
 
 float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
       Planner::axis_steps_per_mm[XYZE_N],
       Planner::steps_to_mm[XYZE_N];
 
 #if ENABLED(DISTINCT_E_FACTORS)
   uint8_t Planner::last_extruder = 0;     // Respond to extruder change
 #endif
 
+int16_t Planner::flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100); // Extrusion factor for each extruder
+
 uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N],
          Planner::max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
 
 millis_t Planner::min_segment_time;
 
 // Initialized by settings.load()
 float Planner::min_feedrate_mm_s,
       Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
       Planner::retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
       Planner::travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX

commit 722786966ad284a708502d18ac5daad02012bfc8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 7 22:33:16 2017 -0500

    Add gcode.cpp, motion.*, queue.* - Apply to some G-codes.

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index c0e3b3a675..c239b324b4 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -53,20 +53,21 @@
  * from initial speed s1 without ever stopping at a plateau:
  *   Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]
  *   di -> (2 a d - s1^2 + s2^2)/(4 a) --> intersection_distance()
  *
  * IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)
  *
  */
 
 #include "planner.h"
 #include "stepper.h"
+#include "motion.h"
 #include "../module/temperature.h"
 #include "../lcd/ultralcd.h"
 #include "../core/language.h"
 #include "../feature/ubl/ubl.h"
 #include "../gcode/parser.h"
 
 #include "../Marlin.h"
 
 #if ENABLED(MESH_BED_LEVELING)
   #include "../feature/mbl/mesh_bed_leveling.h"

commit 3d8a0ab4b215a3869a0388e5c0ef35a6372ed7d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:32 2017 -0500

    Module updates

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 5f93c6d8a2..c0e3b3a675 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -53,30 +53,30 @@
  * from initial speed s1 without ever stopping at a plateau:
  *   Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]
  *   di -> (2 a d - s1^2 + s2^2)/(4 a) --> intersection_distance()
  *
  * IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)
  *
  */
 
 #include "planner.h"
 #include "stepper.h"
-#include "temperature.h"
-#include "ultralcd.h"
-#include "language.h"
-#include "ubl.h"
-#include "gcode.h"
+#include "../module/temperature.h"
+#include "../lcd/ultralcd.h"
+#include "../core/language.h"
+#include "../feature/ubl/ubl.h"
+#include "../gcode/parser.h"
 
-#include "Marlin.h"
+#include "../Marlin.h"
 
 #if ENABLED(MESH_BED_LEVELING)
-  #include "mesh_bed_leveling.h"
+  #include "../feature/mbl/mesh_bed_leveling.h"
 #endif
 
 Planner planner;
 
   // public:
 
 /**
  * A ring buffer of moves described in steps
  */
 block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];

commit 0c9231fd04798c30830513a0cad8b204a6b9633f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:30 2017 -0500

    Move 'module' files

diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
new file mode 100644
index 0000000000..5f93c6d8a2
--- /dev/null
+++ b/Marlin/src/module/planner.cpp
@@ -0,0 +1,1559 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * planner.cpp
+ *
+ * Buffer movement commands and manage the acceleration profile plan
+ *
+ * Derived from Grbl
+ * Copyright (c) 2009-2011 Simen Svale Skogsrud
+ *
+ * The ring buffer implementation gleaned from the wiring_serial library by David A. Mellis.
+ *
+ *
+ * Reasoning behind the mathematics in this module (in the key of 'Mathematica'):
+ *
+ * s == speed, a == acceleration, t == time, d == distance
+ *
+ * Basic definitions:
+ *   Speed[s_, a_, t_] := s + (a*t)
+ *   Travel[s_, a_, t_] := Integrate[Speed[s, a, t], t]
+ *
+ * Distance to reach a specific speed with a constant acceleration:
+ *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, d, t]
+ *   d -> (m^2 - s^2)/(2 a) --> estimate_acceleration_distance()
+ *
+ * Speed after a given distance of travel with constant acceleration:
+ *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, m, t]
+ *   m -> Sqrt[2 a d + s^2]
+ *
+ * DestinationSpeed[s_, a_, d_] := Sqrt[2 a d + s^2]
+ *
+ * When to start braking (di) to reach a specified destination speed (s2) after accelerating
+ * from initial speed s1 without ever stopping at a plateau:
+ *   Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]
+ *   di -> (2 a d - s1^2 + s2^2)/(4 a) --> intersection_distance()
+ *
+ * IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)
+ *
+ */
+
+#include "planner.h"
+#include "stepper.h"
+#include "temperature.h"
+#include "ultralcd.h"
+#include "language.h"
+#include "ubl.h"
+#include "gcode.h"
+
+#include "Marlin.h"
+
+#if ENABLED(MESH_BED_LEVELING)
+  #include "mesh_bed_leveling.h"
+#endif
+
+Planner planner;
+
+  // public:
+
+/**
+ * A ring buffer of moves described in steps
+ */
+block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
+volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next block to be pushed
+                 Planner::block_buffer_tail = 0;
+
+float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
+      Planner::axis_steps_per_mm[XYZE_N],
+      Planner::steps_to_mm[XYZE_N];
+
+#if ENABLED(DISTINCT_E_FACTORS)
+  uint8_t Planner::last_extruder = 0;     // Respond to extruder change
+#endif
+
+uint32_t Planner::max_acceleration_steps_per_s2[XYZE_N],
+         Planner::max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
+
+millis_t Planner::min_segment_time;
+
+// Initialized by settings.load()
+float Planner::min_feedrate_mm_s,
+      Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
+      Planner::retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
+      Planner::travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
+      Planner::max_jerk[XYZE],       // The largest speed change requiring no acceleration
+      Planner::min_travel_feedrate_mm_s;
+
+#if HAS_ABL
+  bool Planner::abl_enabled = false; // Flag that auto bed leveling is enabled
+#endif
+
+#if ABL_PLANAR
+  matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
+#endif
+
+#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+  float Planner::z_fade_height, // Initialized by settings.load()
+        Planner::inverse_z_fade_height;
+#endif
+
+#if ENABLED(AUTOTEMP)
+  float Planner::autotemp_max = 250,
+        Planner::autotemp_min = 210,
+        Planner::autotemp_factor = 0.1;
+  bool Planner::autotemp_enabled = false;
+#endif
+
+// private:
+
+long Planner::position[NUM_AXIS] = { 0 };
+
+uint32_t Planner::cutoff_long;
+
+float Planner::previous_speed[NUM_AXIS],
+      Planner::previous_nominal_speed;
+
+#if ENABLED(DISABLE_INACTIVE_EXTRUDER)
+  uint8_t Planner::g_uc_extruder_last_move[EXTRUDERS] = { 0 };
+#endif
+
+#ifdef XY_FREQUENCY_LIMIT
+  // Old direction bits. Used for speed calculations
+  unsigned char Planner::old_direction_bits = 0;
+  // Segment times (in ¬µs). Used for speed calculations
+  long Planner::axis_segment_time[2][3] = { {MAX_FREQ_TIME + 1, 0, 0}, {MAX_FREQ_TIME + 1, 0, 0} };
+#endif
+
+#if ENABLED(LIN_ADVANCE)
+  float Planner::extruder_advance_k, // Initialized by settings.load()
+        Planner::advance_ed_ratio,   // Initialized by settings.load()
+        Planner::position_float[NUM_AXIS] = { 0 };
+#endif
+
+#if ENABLED(ULTRA_LCD)
+  volatile uint32_t Planner::block_buffer_runtime_us = 0;
+#endif
+
+/**
+ * Class and Instance Methods
+ */
+
+Planner::Planner() { init(); }
+
+void Planner::init() {
+  block_buffer_head = block_buffer_tail = 0;
+  ZERO(position);
+  #if ENABLED(LIN_ADVANCE)
+    ZERO(position_float);
+  #endif
+  ZERO(previous_speed);
+  previous_nominal_speed = 0.0;
+  #if ABL_PLANAR
+    bed_level_matrix.set_to_identity();
+  #endif
+}
+
+#define MINIMAL_STEP_RATE 120
+
+/**
+ * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
+ * by the provided factors.
+ */
+void Planner::calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor) {
+  uint32_t initial_rate = CEIL(block->nominal_rate * entry_factor),
+           final_rate = CEIL(block->nominal_rate * exit_factor); // (steps per second)
+
+  // Limit minimal step rate (Otherwise the timer will overflow.)
+  NOLESS(initial_rate, MINIMAL_STEP_RATE);
+  NOLESS(final_rate, MINIMAL_STEP_RATE);
+
+  int32_t accel = block->acceleration_steps_per_s2,
+          accelerate_steps = CEIL(estimate_acceleration_distance(initial_rate, block->nominal_rate, accel)),
+          decelerate_steps = FLOOR(estimate_acceleration_distance(block->nominal_rate, final_rate, -accel)),
+          plateau_steps = block->step_event_count - accelerate_steps - decelerate_steps;
+
+  // Is the Plateau of Nominal Rate smaller than nothing? That means no cruising, and we will
+  // have to use intersection_distance() to calculate when to abort accel and start braking
+  // in order to reach the final_rate exactly at the end of this block.
+  if (plateau_steps < 0) {
+    accelerate_steps = CEIL(intersection_distance(initial_rate, final_rate, accel, block->step_event_count));
+    NOLESS(accelerate_steps, 0); // Check limits due to numerical round-off
+    accelerate_steps = min((uint32_t)accelerate_steps, block->step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)
+    plateau_steps = 0;
+  }
+
+  // block->accelerate_until = accelerate_steps;
+  // block->decelerate_after = accelerate_steps+plateau_steps;
+
+  CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section
+  if (!TEST(block->flag, BLOCK_BIT_BUSY)) { // Don't update variables if block is busy.
+    block->accelerate_until = accelerate_steps;
+    block->decelerate_after = accelerate_steps + plateau_steps;
+    block->initial_rate = initial_rate;
+    block->final_rate = final_rate;
+    #if ENABLED(ADVANCE)
+      block->initial_advance = block->advance * sq(entry_factor);
+      block->final_advance = block->advance * sq(exit_factor);
+    #endif
+  }
+  CRITICAL_SECTION_END;
+}
+
+// "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.
+// This method will calculate the junction jerk as the euclidean distance between the nominal
+// velocities of the respective blocks.
+//inline float junction_jerk(block_t *before, block_t *after) {
+//  return SQRT(
+//    POW((before->speed_x-after->speed_x), 2)+POW((before->speed_y-after->speed_y), 2));
+//}
+
+
+// The kernel called by recalculate() when scanning the plan from last to first entry.
+void Planner::reverse_pass_kernel(block_t* const current, const block_t *next) {
+  if (!current || !next) return;
+  // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.
+  // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and
+  // check for maximum allowable speed reductions to ensure maximum possible planned speed.
+  float max_entry_speed = current->max_entry_speed;
+  if (current->entry_speed != max_entry_speed) {
+    // If nominal length true, max junction speed is guaranteed to be reached. Only compute
+    // for max allowable speed if block is decelerating and nominal length is false.
+    current->entry_speed = (TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH) || max_entry_speed <= next->entry_speed)
+      ? max_entry_speed
+      : min(max_entry_speed, max_allowable_speed(-current->acceleration, next->entry_speed, current->millimeters));
+    SBI(current->flag, BLOCK_BIT_RECALCULATE);
+  }
+}
+
+/**
+ * recalculate() needs to go over the current plan twice.
+ * Once in reverse and once forward. This implements the reverse pass.
+ */
+void Planner::reverse_pass() {
+
+  if (movesplanned() > 3) {
+
+    block_t* block[3] = { NULL, NULL, NULL };
+
+    // Make a local copy of block_buffer_tail, because the interrupt can alter it
+    // Is a critical section REALLY needed for a single byte change?
+    //CRITICAL_SECTION_START;
+    uint8_t tail = block_buffer_tail;
+    //CRITICAL_SECTION_END
+
+    uint8_t b = BLOCK_MOD(block_buffer_head - 3);
+    while (b != tail) {
+      if (block[0] && TEST(block[0]->flag, BLOCK_BIT_START_FROM_FULL_HALT)) break;
+      b = prev_block_index(b);
+      block[2] = block[1];
+      block[1] = block[0];
+      block[0] = &block_buffer[b];
+      reverse_pass_kernel(block[1], block[2]);
+    }
+  }
+}
+
+// The kernel called by recalculate() when scanning the plan from first to last entry.
+void Planner::forward_pass_kernel(const block_t* previous, block_t* const current) {
+  if (!previous) return;
+
+  // If the previous block is an acceleration block, but it is not long enough to complete the
+  // full speed change within the block, we need to adjust the entry speed accordingly. Entry
+  // speeds have already been reset, maximized, and reverse planned by reverse planner.
+  // If nominal length is true, max junction speed is guaranteed to be reached. No need to recheck.
+  if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH)) {
+    if (previous->entry_speed < current->entry_speed) {
+      float entry_speed = min(current->entry_speed,
+                               max_allowable_speed(-previous->acceleration, previous->entry_speed, previous->millimeters));
+      // Check for junction speed change
+      if (current->entry_speed != entry_speed) {
+        current->entry_speed = entry_speed;
+        SBI(current->flag, BLOCK_BIT_RECALCULATE);
+      }
+    }
+  }
+}
+
+/**
+ * recalculate() needs to go over the current plan twice.
+ * Once in reverse and once forward. This implements the forward pass.
+ */
+void Planner::forward_pass() {
+  block_t* block[3] = { NULL, NULL, NULL };
+
+  for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
+    block[0] = block[1];
+    block[1] = block[2];
+    block[2] = &block_buffer[b];
+    forward_pass_kernel(block[0], block[1]);
+  }
+  forward_pass_kernel(block[1], block[2]);
+}
+
+/**
+ * Recalculate the trapezoid speed profiles for all blocks in the plan
+ * according to the entry_factor for each junction. Must be called by
+ * recalculate() after updating the blocks.
+ */
+void Planner::recalculate_trapezoids() {
+  int8_t block_index = block_buffer_tail;
+  block_t *current, *next = NULL;
+
+  while (block_index != block_buffer_head) {
+    current = next;
+    next = &block_buffer[block_index];
+    if (current) {
+      // Recalculate if current block entry or exit junction speed has changed.
+      if (TEST(current->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
+        // NOTE: Entry and exit factors always > 0 by all previous logic operations.
+        float nom = current->nominal_speed;
+        calculate_trapezoid_for_block(current, current->entry_speed / nom, next->entry_speed / nom);
+        CBI(current->flag, BLOCK_BIT_RECALCULATE); // Reset current only to ensure next trapezoid is computed
+      }
+    }
+    block_index = next_block_index(block_index);
+  }
+  // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
+  if (next) {
+    float nom = next->nominal_speed;
+    calculate_trapezoid_for_block(next, next->entry_speed / nom, (MINIMUM_PLANNER_SPEED) / nom);
+    CBI(next->flag, BLOCK_BIT_RECALCULATE);
+  }
+}
+
+/*
+ * Recalculate the motion plan according to the following algorithm:
+ *
+ *   1. Go over every block in reverse order...
+ *
+ *      Calculate a junction speed reduction (block_t.entry_factor) so:
+ *
+ *      a. The junction jerk is within the set limit, and
+ *
+ *      b. No speed reduction within one block requires faster
+ *         deceleration than the one, true constant acceleration.
+ *
+ *   2. Go over every block in chronological order...
+ *
+ *      Dial down junction speed reduction values if:
+ *      a. The speed increase within one block would require faster
+ *         acceleration than the one, true constant acceleration.
+ *
+ * After that, all blocks will have an entry_factor allowing all speed changes to
+ * be performed using only the one, true constant acceleration, and where no junction
+ * jerk is jerkier than the set limit, Jerky. Finally it will:
+ *
+ *   3. Recalculate "trapezoids" for all blocks.
+ */
+void Planner::recalculate() {
+  reverse_pass();
+  forward_pass();
+  recalculate_trapezoids();
+}
+
+
+#if ENABLED(AUTOTEMP)
+
+  void Planner::getHighESpeed() {
+    static float oldt = 0;
+
+    if (!autotemp_enabled) return;
+    if (thermalManager.degTargetHotend(0) + 2 < autotemp_min) return; // probably temperature set to zero.
+
+    float high = 0.0;
+    for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
+      block_t* block = &block_buffer[b];
+      if (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS]) {
+        float se = (float)block->steps[E_AXIS] / block->step_event_count * block->nominal_speed; // mm/sec;
+        NOLESS(high, se);
+      }
+    }
+
+    float t = autotemp_min + high * autotemp_factor;
+    t = constrain(t, autotemp_min, autotemp_max);
+    if (t < oldt) t = t * (1 - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
+    oldt = t;
+    thermalManager.setTargetHotend(t, 0);
+  }
+
+#endif // AUTOTEMP
+
+/**
+ * Maintain fans, paste extruder pressure,
+ */
+void Planner::check_axes_activity() {
+  unsigned char axis_active[NUM_AXIS] = { 0 },
+                tail_fan_speed[FAN_COUNT];
+
+  #if FAN_COUNT > 0
+    for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = fanSpeeds[i];
+  #endif
+
+  #if ENABLED(BARICUDA)
+    #if HAS_HEATER_1
+      uint8_t tail_valve_pressure = baricuda_valve_pressure;
+    #endif
+    #if HAS_HEATER_2
+      uint8_t tail_e_to_p_pressure = baricuda_e_to_p_pressure;
+    #endif
+  #endif
+
+  if (blocks_queued()) {
+
+    #if FAN_COUNT > 0
+      for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = block_buffer[block_buffer_tail].fan_speed[i];
+    #endif
+
+    block_t* block;
+
+    #if ENABLED(BARICUDA)
+      block = &block_buffer[block_buffer_tail];
+      #if HAS_HEATER_1
+        tail_valve_pressure = block->valve_pressure;
+      #endif
+      #if HAS_HEATER_2
+        tail_e_to_p_pressure = block->e_to_p_pressure;
+      #endif
+    #endif
+
+    for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
+      block = &block_buffer[b];
+      LOOP_XYZE(i) if (block->steps[i]) axis_active[i]++;
+    }
+  }
+  #if ENABLED(DISABLE_X)
+    if (!axis_active[X_AXIS]) disable_X();
+  #endif
+  #if ENABLED(DISABLE_Y)
+    if (!axis_active[Y_AXIS]) disable_Y();
+  #endif
+  #if ENABLED(DISABLE_Z)
+    if (!axis_active[Z_AXIS]) disable_Z();
+  #endif
+  #if ENABLED(DISABLE_E)
+    if (!axis_active[E_AXIS]) disable_e_steppers();
+  #endif
+
+  #if FAN_COUNT > 0
+
+    #ifdef FAN_MIN_PWM
+      #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ? ( FAN_MIN_PWM + (tail_fan_speed[f] * (255 - FAN_MIN_PWM)) / 255 ) : 0)
+    #else
+      #define CALC_FAN_SPEED(f) tail_fan_speed[f]
+    #endif
+
+    #ifdef FAN_KICKSTART_TIME
+
+      static millis_t fan_kick_end[FAN_COUNT] = { 0 };
+
+      #define KICKSTART_FAN(f) \
+        if (tail_fan_speed[f]) { \
+          millis_t ms = millis(); \
+          if (fan_kick_end[f] == 0) { \
+            fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \
+            tail_fan_speed[f] = 255; \
+          } else if (PENDING(ms, fan_kick_end[f])) \
+            tail_fan_speed[f] = 255; \
+        } else fan_kick_end[f] = 0
+
+      #if HAS_FAN0
+        KICKSTART_FAN(0);
+      #endif
+      #if HAS_FAN1
+        KICKSTART_FAN(1);
+      #endif
+      #if HAS_FAN2
+        KICKSTART_FAN(2);
+      #endif
+
+    #endif // FAN_KICKSTART_TIME
+
+    #if ENABLED(FAN_SOFT_PWM)
+      #if HAS_FAN0
+        thermalManager.soft_pwm_amount_fan[0] = CALC_FAN_SPEED(0);
+      #endif
+      #if HAS_FAN1
+        thermalManager.soft_pwm_amount_fan[1] = CALC_FAN_SPEED(1);
+      #endif
+      #if HAS_FAN2
+        thermalManager.soft_pwm_amount_fan[2] = CALC_FAN_SPEED(2);
+      #endif
+    #else
+      #if HAS_FAN0
+        analogWrite(FAN_PIN, CALC_FAN_SPEED(0));
+      #endif
+      #if HAS_FAN1
+        analogWrite(FAN1_PIN, CALC_FAN_SPEED(1));
+      #endif
+      #if HAS_FAN2
+        analogWrite(FAN2_PIN, CALC_FAN_SPEED(2));
+      #endif
+    #endif
+
+  #endif // FAN_COUNT > 0
+
+  #if ENABLED(AUTOTEMP)
+    getHighESpeed();
+  #endif
+
+  #if ENABLED(BARICUDA)
+    #if HAS_HEATER_1
+      analogWrite(HEATER_1_PIN, tail_valve_pressure);
+    #endif
+    #if HAS_HEATER_2
+      analogWrite(HEATER_2_PIN, tail_e_to_p_pressure);
+    #endif
+  #endif
+}
+
+#if PLANNER_LEVELING
+  /**
+   * lx, ly, lz - logical (cartesian, not delta) positions in mm
+   */
+  void Planner::apply_leveling(float &lx, float &ly, float &lz) {
+
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+      if (!ubl.state.active) return;
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        // if z_fade_height enabled (nonzero) and raw_z above it, no leveling required
+        if (planner.z_fade_height && planner.z_fade_height <= RAW_Z_POSITION(lz)) return;
+        lz += ubl.state.z_offset + ubl.get_z_correction(lx, ly) * ubl.fade_scaling_factor_for_z(lz);
+      #else // no fade
+        lz += ubl.state.z_offset + ubl.get_z_correction(lx, ly);
+      #endif // FADE
+    #endif // UBL
+
+    #if HAS_ABL
+      if (!abl_enabled) return;
+    #endif
+
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT) && DISABLED(AUTO_BED_LEVELING_UBL)
+      static float z_fade_factor = 1.0, last_raw_lz = -999.0;
+      if (z_fade_height) {
+        const float raw_lz = RAW_Z_POSITION(lz);
+        if (raw_lz >= z_fade_height) return;
+        if (last_raw_lz != raw_lz) {
+          last_raw_lz = raw_lz;
+          z_fade_factor = 1.0 - raw_lz * inverse_z_fade_height;
+        }
+      }
+      else
+        z_fade_factor = 1.0;
+    #endif
+
+    #if ENABLED(MESH_BED_LEVELING)
+
+      if (mbl.active())
+        lz += mbl.get_z(RAW_X_POSITION(lx), RAW_Y_POSITION(ly)
+          #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+            , z_fade_factor
+          #endif
+          );
+
+    #elif ABL_PLANAR
+
+      float dx = RAW_X_POSITION(lx) - (X_TILT_FULCRUM),
+            dy = RAW_Y_POSITION(ly) - (Y_TILT_FULCRUM),
+            dz = RAW_Z_POSITION(lz);
+
+      apply_rotation_xyz(bed_level_matrix, dx, dy, dz);
+
+      lx = LOGICAL_X_POSITION(dx + X_TILT_FULCRUM);
+      ly = LOGICAL_Y_POSITION(dy + Y_TILT_FULCRUM);
+      lz = LOGICAL_Z_POSITION(dz);
+
+    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+      float tmp[XYZ] = { lx, ly, 0 };
+      lz += bilinear_z_offset(tmp)
+        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+          * z_fade_factor
+        #endif
+      ;
+
+    #endif
+  }
+
+  void Planner::unapply_leveling(float logical[XYZ]) {
+
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+
+      if (ubl.state.active) {
+
+        const float z_physical = RAW_Z_POSITION(logical[Z_AXIS]),
+                    z_correct = ubl.get_z_correction(logical[X_AXIS], logical[Y_AXIS]),
+                    z_virtual = z_physical - ubl.state.z_offset - z_correct;
+              float z_logical = LOGICAL_Z_POSITION(z_virtual);
+
+        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+
+          // for P=physical_z, L=logical_z, M=mesh_z, O=z_offset, H=fade_height,
+          // Given P=L+O+M(1-L/H) (faded mesh correction formula for L<H)
+          //  then L=P-O-M(1-L/H)
+          //    so L=P-O-M+ML/H
+          //    so L-ML/H=P-O-M
+          //    so L(1-M/H)=P-O-M
+          //    so L=(P-O-M)/(1-M/H) for L<H
+
+          if (planner.z_fade_height) {
+            if (z_logical >= planner.z_fade_height)
+              z_logical = LOGICAL_Z_POSITION(z_physical - ubl.state.z_offset);
+            else
+              z_logical /= 1.0 - z_correct * planner.inverse_z_fade_height;
+          }
+
+        #endif // ENABLE_LEVELING_FADE_HEIGHT
+
+        logical[Z_AXIS] = z_logical;
+      }
+
+      return; // don't fall thru to other ENABLE_LEVELING_FADE_HEIGHT logic
+
+    #endif
+
+    #if HAS_ABL
+      if (!abl_enabled) return;
+    #endif
+
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      if (z_fade_height && RAW_Z_POSITION(logical[Z_AXIS]) >= z_fade_height) return;
+    #endif
+
+    #if ENABLED(MESH_BED_LEVELING)
+
+      if (mbl.active()) {
+        #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+          const float c = mbl.get_z(RAW_X_POSITION(logical[X_AXIS]), RAW_Y_POSITION(logical[Y_AXIS]), 1.0);
+          logical[Z_AXIS] = (z_fade_height * (RAW_Z_POSITION(logical[Z_AXIS]) - c)) / (z_fade_height - c);
+        #else
+          logical[Z_AXIS] -= mbl.get_z(RAW_X_POSITION(logical[X_AXIS]), RAW_Y_POSITION(logical[Y_AXIS]));
+        #endif
+      }
+
+    #elif ABL_PLANAR
+
+      matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
+
+      float dx = RAW_X_POSITION(logical[X_AXIS]) - (X_TILT_FULCRUM),
+            dy = RAW_Y_POSITION(logical[Y_AXIS]) - (Y_TILT_FULCRUM),
+            dz = RAW_Z_POSITION(logical[Z_AXIS]);
+
+      apply_rotation_xyz(inverse, dx, dy, dz);
+
+      logical[X_AXIS] = LOGICAL_X_POSITION(dx + X_TILT_FULCRUM);
+      logical[Y_AXIS] = LOGICAL_Y_POSITION(dy + Y_TILT_FULCRUM);
+      logical[Z_AXIS] = LOGICAL_Z_POSITION(dz);
+
+    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        const float c = bilinear_z_offset(logical);
+        logical[Z_AXIS] = (z_fade_height * (RAW_Z_POSITION(logical[Z_AXIS]) - c)) / (z_fade_height - c);
+      #else
+        logical[Z_AXIS] -= bilinear_z_offset(logical);
+      #endif
+
+    #endif
+  }
+
+#endif // PLANNER_LEVELING
+
+/**
+ * Planner::_buffer_line
+ *
+ * Add a new linear movement to the buffer.
+ *
+ * Leveling and kinematics should be applied ahead of calling this.
+ *
+ *  a,b,c,e     - target positions in mm or degrees
+ *  fr_mm_s     - (target) speed of the move
+ *  extruder    - target extruder
+ */
+void Planner::_buffer_line(const float &a, const float &b, const float &c, const float &e, float fr_mm_s, const uint8_t extruder) {
+
+  // The target position of the tool in absolute steps
+  // Calculate target position in absolute steps
+  //this should be done after the wait, because otherwise a M92 code within the gcode disrupts this calculation somehow
+  const long target[XYZE] = {
+    LROUND(a * axis_steps_per_mm[X_AXIS]),
+    LROUND(b * axis_steps_per_mm[Y_AXIS]),
+    LROUND(c * axis_steps_per_mm[Z_AXIS]),
+    LROUND(e * axis_steps_per_mm[E_AXIS_N])
+  };
+
+  // When changing extruders recalculate steps corresponding to the E position
+  #if ENABLED(DISTINCT_E_FACTORS)
+    if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
+      position[E_AXIS] = LROUND(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
+      last_extruder = extruder;
+    }
+  #endif
+
+  #if ENABLED(LIN_ADVANCE)
+    const float mm_D_float = SQRT(sq(a - position_float[X_AXIS]) + sq(b - position_float[Y_AXIS]));
+  #endif
+
+  const long da = target[X_AXIS] - position[X_AXIS],
+             db = target[Y_AXIS] - position[Y_AXIS],
+             dc = target[Z_AXIS] - position[Z_AXIS];
+
+  /*
+  SERIAL_ECHOPAIR("  Planner FR:", fr_mm_s);
+  SERIAL_CHAR(' ');
+  #if IS_KINEMATIC
+    SERIAL_ECHOPAIR("A:", a);
+    SERIAL_ECHOPAIR(" (", da);
+    SERIAL_ECHOPAIR(") B:", b);
+  #else
+    SERIAL_ECHOPAIR("X:", a);
+    SERIAL_ECHOPAIR(" (", da);
+    SERIAL_ECHOPAIR(") Y:", b);
+  #endif
+  SERIAL_ECHOPAIR(" (", db);
+  #if ENABLED(DELTA)
+    SERIAL_ECHOPAIR(") C:", c);
+  #else
+    SERIAL_ECHOPAIR(") Z:", c);
+  #endif
+  SERIAL_ECHOPAIR(" (", dc);
+  SERIAL_CHAR(')');
+  SERIAL_EOL();
+  //*/
+
+  // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
+  if (DEBUGGING(DRYRUN)) {
+    position[E_AXIS] = target[E_AXIS];
+    #if ENABLED(LIN_ADVANCE)
+      position_float[E_AXIS] = e;
+    #endif
+  }
+
+  long de = target[E_AXIS] - position[E_AXIS];
+
+  #if ENABLED(LIN_ADVANCE)
+    float de_float = e - position_float[E_AXIS];
+  #endif
+
+  #if ENABLED(PREVENT_COLD_EXTRUSION)
+    if (de) {
+      if (thermalManager.tooColdToExtrude(extruder)) {
+        position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
+        de = 0; // no difference
+        #if ENABLED(LIN_ADVANCE)
+          position_float[E_AXIS] = e;
+          de_float = 0;
+        #endif
+        SERIAL_ECHO_START();
+        SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
+      }
+      #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
+        if (labs(de) > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
+          position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
+          de = 0; // no difference
+          #if ENABLED(LIN_ADVANCE)
+            position_float[E_AXIS] = e;
+            de_float = 0;
+          #endif
+          SERIAL_ECHO_START();
+          SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
+        }
+      #endif
+    }
+  #endif
+
+  // Compute direction bit-mask for this block
+  uint8_t dm = 0;
+  #if CORE_IS_XY
+    if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
+    if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
+    if (dc < 0) SBI(dm, Z_AXIS);
+    if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
+    if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
+  #elif CORE_IS_XZ
+    if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
+    if (db < 0) SBI(dm, Y_AXIS);
+    if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
+    if (da + dc < 0) SBI(dm, A_AXIS);           // Motor A direction
+    if (CORESIGN(da - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
+  #elif CORE_IS_YZ
+    if (da < 0) SBI(dm, X_AXIS);
+    if (db < 0) SBI(dm, Y_HEAD);                // Save the real Extruder (head) direction in Y Axis
+    if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
+    if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
+    if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
+  #else
+    if (da < 0) SBI(dm, X_AXIS);
+    if (db < 0) SBI(dm, Y_AXIS);
+    if (dc < 0) SBI(dm, Z_AXIS);
+  #endif
+  if (de < 0) SBI(dm, E_AXIS);
+
+  const float esteps_float = de * volumetric_multiplier[extruder] * flow_percentage[extruder] * 0.01;
+  const int32_t esteps = abs(esteps_float) + 0.5;
+
+  // Calculate the buffer head after we push this byte
+  const uint8_t next_buffer_head = next_block_index(block_buffer_head);
+
+  // If the buffer is full: good! That means we are well ahead of the robot.
+  // Rest here until there is room in the buffer.
+  while (block_buffer_tail == next_buffer_head) idle();
+
+  // Prepare to set up new block
+  block_t* block = &block_buffer[block_buffer_head];
+
+  // Clear all flags, including the "busy" bit
+  block->flag = 0;
+
+  // Set direction bits
+  block->direction_bits = dm;
+
+  // Number of steps for each axis
+  // See http://www.corexy.com/theory.html
+  #if CORE_IS_XY
+    block->steps[A_AXIS] = labs(da + db);
+    block->steps[B_AXIS] = labs(da - db);
+    block->steps[Z_AXIS] = labs(dc);
+  #elif CORE_IS_XZ
+    block->steps[A_AXIS] = labs(da + dc);
+    block->steps[Y_AXIS] = labs(db);
+    block->steps[C_AXIS] = labs(da - dc);
+  #elif CORE_IS_YZ
+    block->steps[X_AXIS] = labs(da);
+    block->steps[B_AXIS] = labs(db + dc);
+    block->steps[C_AXIS] = labs(db - dc);
+  #else
+    // default non-h-bot planning
+    block->steps[X_AXIS] = labs(da);
+    block->steps[Y_AXIS] = labs(db);
+    block->steps[Z_AXIS] = labs(dc);
+  #endif
+
+  block->steps[E_AXIS] = esteps;
+  block->step_event_count = MAX4(block->steps[X_AXIS], block->steps[Y_AXIS], block->steps[Z_AXIS], esteps);
+
+  // Bail if this is a zero-length block
+  if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return;
+
+  // For a mixing extruder, get a magnified step_event_count for each
+  #if ENABLED(MIXING_EXTRUDER)
+    for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
+      block->mix_event_count[i] = mixing_factor[i] * block->step_event_count;
+  #endif
+
+  #if FAN_COUNT > 0
+    for (uint8_t i = 0; i < FAN_COUNT; i++) block->fan_speed[i] = fanSpeeds[i];
+  #endif
+
+  #if ENABLED(BARICUDA)
+    block->valve_pressure = baricuda_valve_pressure;
+    block->e_to_p_pressure = baricuda_e_to_p_pressure;
+  #endif
+
+  block->active_extruder = extruder;
+
+  //enable active axes
+  #if CORE_IS_XY
+    if (block->steps[A_AXIS] || block->steps[B_AXIS]) {
+      enable_X();
+      enable_Y();
+    }
+    #if DISABLED(Z_LATE_ENABLE)
+      if (block->steps[Z_AXIS]) enable_Z();
+    #endif
+  #elif CORE_IS_XZ
+    if (block->steps[A_AXIS] || block->steps[C_AXIS]) {
+      enable_X();
+      enable_Z();
+    }
+    if (block->steps[Y_AXIS]) enable_Y();
+  #elif CORE_IS_YZ
+    if (block->steps[B_AXIS] || block->steps[C_AXIS]) {
+      enable_Y();
+      enable_Z();
+    }
+    if (block->steps[X_AXIS]) enable_X();
+  #else
+    if (block->steps[X_AXIS]) enable_X();
+    if (block->steps[Y_AXIS]) enable_Y();
+    #if DISABLED(Z_LATE_ENABLE)
+      if (block->steps[Z_AXIS]) enable_Z();
+    #endif
+  #endif
+
+  // Enable extruder(s)
+  if (esteps) {
+
+    #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
+
+      #define DISABLE_IDLE_E(N) if (!g_uc_extruder_last_move[N]) disable_E##N();
+
+      for (uint8_t i = 0; i < EXTRUDERS; i++)
+        if (g_uc_extruder_last_move[i] > 0) g_uc_extruder_last_move[i]--;
+
+      switch(extruder) {
+        case 0:
+          enable_E0();
+          g_uc_extruder_last_move[0] = (BLOCK_BUFFER_SIZE) * 2;
+          #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+            if (extruder_duplication_enabled) {
+              enable_E1();
+              g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
+            }
+          #endif
+          #if EXTRUDERS > 1
+            DISABLE_IDLE_E(1);
+            #if EXTRUDERS > 2
+              DISABLE_IDLE_E(2);
+              #if EXTRUDERS > 3
+                DISABLE_IDLE_E(3);
+                #if EXTRUDERS > 4
+                  DISABLE_IDLE_E(4);
+                #endif // EXTRUDERS > 4
+              #endif // EXTRUDERS > 3
+            #endif // EXTRUDERS > 2
+          #endif // EXTRUDERS > 1
+        break;
+        #if EXTRUDERS > 1
+          case 1:
+            enable_E1();
+            g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
+            DISABLE_IDLE_E(0);
+            #if EXTRUDERS > 2
+              DISABLE_IDLE_E(2);
+              #if EXTRUDERS > 3
+                DISABLE_IDLE_E(3);
+                #if EXTRUDERS > 4
+                  DISABLE_IDLE_E(4);
+                #endif // EXTRUDERS > 4
+              #endif // EXTRUDERS > 3
+            #endif // EXTRUDERS > 2
+          break;
+          #if EXTRUDERS > 2
+            case 2:
+              enable_E2();
+              g_uc_extruder_last_move[2] = (BLOCK_BUFFER_SIZE) * 2;
+              DISABLE_IDLE_E(0);
+              DISABLE_IDLE_E(1);
+              #if EXTRUDERS > 3
+                DISABLE_IDLE_E(3);
+                #if EXTRUDERS > 4
+                  DISABLE_IDLE_E(4);
+                #endif
+              #endif
+            break;
+            #if EXTRUDERS > 3
+              case 3:
+                enable_E3();
+                g_uc_extruder_last_move[3] = (BLOCK_BUFFER_SIZE) * 2;
+                DISABLE_IDLE_E(0);
+                DISABLE_IDLE_E(1);
+                DISABLE_IDLE_E(2);
+                #if EXTRUDERS > 4
+                  DISABLE_IDLE_E(4);
+                #endif
+              break;
+              #if EXTRUDERS > 4
+                case 4:
+                  enable_E4();
+                  g_uc_extruder_last_move[4] = (BLOCK_BUFFER_SIZE) * 2;
+                  DISABLE_IDLE_E(0);
+                  DISABLE_IDLE_E(1);
+                  DISABLE_IDLE_E(2);
+                  DISABLE_IDLE_E(3);
+                break;
+              #endif // EXTRUDERS > 4
+            #endif // EXTRUDERS > 3
+          #endif // EXTRUDERS > 2
+        #endif // EXTRUDERS > 1
+      }
+    #else
+      enable_E0();
+      enable_E1();
+      enable_E2();
+      enable_E3();
+      enable_E4();
+    #endif
+  }
+
+  if (esteps)
+    NOLESS(fr_mm_s, min_feedrate_mm_s);
+  else
+    NOLESS(fr_mm_s, min_travel_feedrate_mm_s);
+
+  /**
+   * This part of the code calculates the total length of the movement.
+   * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
+   * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
+   * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
+   * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
+   * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
+   */
+  #if IS_CORE
+    float delta_mm[Z_HEAD + 1];
+    #if CORE_IS_XY
+      delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
+      delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
+      delta_mm[Z_AXIS] = dc * steps_to_mm[Z_AXIS];
+      delta_mm[A_AXIS] = (da + db) * steps_to_mm[A_AXIS];
+      delta_mm[B_AXIS] = CORESIGN(da - db) * steps_to_mm[B_AXIS];
+    #elif CORE_IS_XZ
+      delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
+      delta_mm[Y_AXIS] = db * steps_to_mm[Y_AXIS];
+      delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
+      delta_mm[A_AXIS] = (da + dc) * steps_to_mm[A_AXIS];
+      delta_mm[C_AXIS] = CORESIGN(da - dc) * steps_to_mm[C_AXIS];
+    #elif CORE_IS_YZ
+      delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
+      delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
+      delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
+      delta_mm[B_AXIS] = (db + dc) * steps_to_mm[B_AXIS];
+      delta_mm[C_AXIS] = CORESIGN(db - dc) * steps_to_mm[C_AXIS];
+    #endif
+  #else
+    float delta_mm[XYZE];
+    delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
+    delta_mm[Y_AXIS] = db * steps_to_mm[Y_AXIS];
+    delta_mm[Z_AXIS] = dc * steps_to_mm[Z_AXIS];
+  #endif
+  delta_mm[E_AXIS] = esteps_float * steps_to_mm[E_AXIS_N];
+
+  if (block->steps[X_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[Y_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[Z_AXIS] < MIN_STEPS_PER_SEGMENT) {
+    block->millimeters = FABS(delta_mm[E_AXIS]);
+  }
+  else {
+    block->millimeters = SQRT(
+      #if CORE_IS_XY
+        sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS])
+      #elif CORE_IS_XZ
+        sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
+      #elif CORE_IS_YZ
+        sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
+      #else
+        sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS])
+      #endif
+    );
+  }
+  float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
+
+  // Calculate moves/second for this move. No divide by zero due to previous checks.
+  float inverse_mm_s = fr_mm_s * inverse_millimeters;
+
+  const uint8_t moves_queued = movesplanned();
+
+  // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
+  #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
+    // Segment time im micro seconds
+    unsigned long segment_time = LROUND(1000000.0 / inverse_mm_s);
+  #endif
+  #if ENABLED(SLOWDOWN)
+    if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
+      if (segment_time < min_segment_time) {
+        // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
+        inverse_mm_s = 1000000.0 / (segment_time + LROUND(2 * (min_segment_time - segment_time) / moves_queued));
+        #if defined(XY_FREQUENCY_LIMIT) || ENABLED(ULTRA_LCD)
+          segment_time = LROUND(1000000.0 / inverse_mm_s);
+        #endif
+      }
+    }
+  #endif
+
+  #if ENABLED(ULTRA_LCD)
+    CRITICAL_SECTION_START
+      block_buffer_runtime_us += segment_time;
+    CRITICAL_SECTION_END
+  #endif
+
+  block->nominal_speed = block->millimeters * inverse_mm_s; // (mm/sec) Always > 0
+  block->nominal_rate = CEIL(block->step_event_count * inverse_mm_s); // (step/sec) Always > 0
+
+  #if ENABLED(FILAMENT_WIDTH_SENSOR)
+    static float filwidth_e_count = 0, filwidth_delay_dist = 0;
+
+    //FMM update ring buffer used for delay with filament measurements
+    if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && filwidth_delay_index[1] >= 0) {  //only for extruder with filament sensor and if ring buffer is initialized
+
+      const int MMD_CM = MAX_MEASUREMENT_DELAY + 1, MMD_MM = MMD_CM * 10;
+
+      // increment counters with next move in e axis
+      filwidth_e_count += delta_mm[E_AXIS];
+      filwidth_delay_dist += delta_mm[E_AXIS];
+
+      // Only get new measurements on forward E movement
+      if (filwidth_e_count > 0.0001) {
+
+        // Loop the delay distance counter (modulus by the mm length)
+        while (filwidth_delay_dist >= MMD_MM) filwidth_delay_dist -= MMD_MM;
+
+        // Convert into an index into the measurement array
+        filwidth_delay_index[0] = int8_t(filwidth_delay_dist * 0.1);
+
+        // If the index has changed (must have gone forward)...
+        if (filwidth_delay_index[0] != filwidth_delay_index[1]) {
+          filwidth_e_count = 0; // Reset the E movement counter
+          const uint8_t meas_sample = thermalManager.widthFil_to_size_ratio() - 100; // Subtract 100 to reduce magnitude - to store in a signed char
+          do {
+            filwidth_delay_index[1] = (filwidth_delay_index[1] + 1) % MMD_CM; // The next unused slot
+            measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
+          } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
+        }
+      }
+    }
+  #endif
+
+  // Calculate and limit speed in mm/sec for each axis
+  float current_speed[NUM_AXIS], speed_factor = 1.0; // factor <1 decreases speed
+  LOOP_XYZE(i) {
+    const float cs = FABS(current_speed[i] = delta_mm[i] * inverse_mm_s);
+    #if ENABLED(DISTINCT_E_FACTORS)
+      if (i == E_AXIS) i += extruder;
+    #endif
+    if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
+  }
+
+  // Max segment time in ¬µs.
+  #ifdef XY_FREQUENCY_LIMIT
+
+    // Check and limit the xy direction change frequency
+    const unsigned char direction_change = block->direction_bits ^ old_direction_bits;
+    old_direction_bits = block->direction_bits;
+    segment_time = LROUND((float)segment_time / speed_factor);
+
+    long xs0 = axis_segment_time[X_AXIS][0],
+         xs1 = axis_segment_time[X_AXIS][1],
+         xs2 = axis_segment_time[X_AXIS][2],
+         ys0 = axis_segment_time[Y_AXIS][0],
+         ys1 = axis_segment_time[Y_AXIS][1],
+         ys2 = axis_segment_time[Y_AXIS][2];
+
+    if (TEST(direction_change, X_AXIS)) {
+      xs2 = axis_segment_time[X_AXIS][2] = xs1;
+      xs1 = axis_segment_time[X_AXIS][1] = xs0;
+      xs0 = 0;
+    }
+    xs0 = axis_segment_time[X_AXIS][0] = xs0 + segment_time;
+
+    if (TEST(direction_change, Y_AXIS)) {
+      ys2 = axis_segment_time[Y_AXIS][2] = axis_segment_time[Y_AXIS][1];
+      ys1 = axis_segment_time[Y_AXIS][1] = axis_segment_time[Y_AXIS][0];
+      ys0 = 0;
+    }
+    ys0 = axis_segment_time[Y_AXIS][0] = ys0 + segment_time;
+
+    const long max_x_segment_time = MAX3(xs0, xs1, xs2),
+               max_y_segment_time = MAX3(ys0, ys1, ys2),
+               min_xy_segment_time = min(max_x_segment_time, max_y_segment_time);
+    if (min_xy_segment_time < MAX_FREQ_TIME) {
+      const float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME);
+      NOMORE(speed_factor, low_sf);
+    }
+  #endif // XY_FREQUENCY_LIMIT
+
+  // Correct the speed
+  if (speed_factor < 1.0) {
+    LOOP_XYZE(i) current_speed[i] *= speed_factor;
+    block->nominal_speed *= speed_factor;
+    block->nominal_rate *= speed_factor;
+  }
+
+  // Compute and limit the acceleration rate for the trapezoid generator.
+  const float steps_per_mm = block->step_event_count * inverse_millimeters;
+  uint32_t accel;
+  if (!block->steps[X_AXIS] && !block->steps[Y_AXIS] && !block->steps[Z_AXIS]) {
+    // convert to: acceleration steps/sec^2
+    accel = CEIL(retract_acceleration * steps_per_mm);
+  }
+  else {
+    #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
+      if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
+        const uint32_t comp = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count; \
+        if (accel * block->steps[AXIS] > comp) accel = comp / block->steps[AXIS]; \
+      } \
+    }while(0)
+
+    #define LIMIT_ACCEL_FLOAT(AXIS,INDX) do{ \
+      if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
+        const float comp = (float)max_acceleration_steps_per_s2[AXIS+INDX] * (float)block->step_event_count; \
+        if ((float)accel * (float)block->steps[AXIS] > comp) accel = comp / (float)block->steps[AXIS]; \
+      } \
+    }while(0)
+
+    // Start with print or travel acceleration
+    accel = CEIL((esteps ? acceleration : travel_acceleration) * steps_per_mm);
+
+    #if ENABLED(DISTINCT_E_FACTORS)
+      #define ACCEL_IDX extruder
+    #else
+      #define ACCEL_IDX 0
+    #endif
+
+    // Limit acceleration per axis
+    if (block->step_event_count <= cutoff_long) {
+      LIMIT_ACCEL_LONG(X_AXIS, 0);
+      LIMIT_ACCEL_LONG(Y_AXIS, 0);
+      LIMIT_ACCEL_LONG(Z_AXIS, 0);
+      LIMIT_ACCEL_LONG(E_AXIS, ACCEL_IDX);
+    }
+    else {
+      LIMIT_ACCEL_FLOAT(X_AXIS, 0);
+      LIMIT_ACCEL_FLOAT(Y_AXIS, 0);
+      LIMIT_ACCEL_FLOAT(Z_AXIS, 0);
+      LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
+    }
+  }
+  block->acceleration_steps_per_s2 = accel;
+  block->acceleration = accel / steps_per_mm;
+  block->acceleration_rate = (long)(accel * 16777216.0 / (HAL_STEPPER_TIMER_RATE)); // 16777216 = <<24
+
+  // Initial limit on the segment entry velocity
+  float vmax_junction;
+
+  #if 0  // Use old jerk for now
+
+    float junction_deviation = 0.1;
+
+    // Compute path unit vector
+    double unit_vec[XYZ] = {
+      delta_mm[X_AXIS] * inverse_millimeters,
+      delta_mm[Y_AXIS] * inverse_millimeters,
+      delta_mm[Z_AXIS] * inverse_millimeters
+    };
+
+    /*
+       Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
+
+       Let a circle be tangent to both previous and current path line segments, where the junction
+       deviation is defined as the distance from the junction to the closest edge of the circle,
+       collinear with the circle center.
+
+       The circular segment joining the two paths represents the path of centripetal acceleration.
+       Solve for max velocity based on max acceleration about the radius of the circle, defined
+       indirectly by junction deviation.
+
+       This may be also viewed as path width or max_jerk in the previous grbl version. This approach
+       does not actually deviate from path, but used as a robust way to compute cornering speeds, as
+       it takes into account the nonlinearities of both the junction angle and junction velocity.
+     */
+
+    vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed
+
+    // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
+    if (block_buffer_head != block_buffer_tail && previous_nominal_speed > 0.0) {
+      // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
+      // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
+      float cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
+                        - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
+                        - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS] ;
+      // Skip and use default max junction speed for 0 degree acute junction.
+      if (cos_theta < 0.95) {
+        vmax_junction = min(previous_nominal_speed, block->nominal_speed);
+        // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.
+        if (cos_theta > -0.95) {
+          // Compute maximum junction velocity based on maximum acceleration and junction deviation
+          float sin_theta_d2 = SQRT(0.5 * (1.0 - cos_theta)); // Trig half angle identity. Always positive.
+          NOMORE(vmax_junction, SQRT(block->acceleration * junction_deviation * sin_theta_d2 / (1.0 - sin_theta_d2)));
+        }
+      }
+    }
+  #endif
+
+  /**
+   * Adapted from Pr≈Ø≈°a MKS firmware
+   * https://github.com/prusa3d/Prusa-Firmware
+   *
+   * Start with a safe speed (from which the machine may halt to stop immediately).
+   */
+
+  // Exit speed limited by a jerk to full halt of a previous last segment
+  static float previous_safe_speed;
+
+  float safe_speed = block->nominal_speed;
+  uint8_t limited = 0;
+  LOOP_XYZE(i) {
+    const float jerk = FABS(current_speed[i]), maxj = max_jerk[i];
+    if (jerk > maxj) {
+      if (limited) {
+        const float mjerk = maxj * block->nominal_speed;
+        if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk;
+      }
+      else {
+        ++limited;
+        safe_speed = maxj;
+      }
+    }
+  }
+
+  if (moves_queued > 1 && previous_nominal_speed > 0.0001) {
+    // Estimate a maximum velocity allowed at a joint of two successive segments.
+    // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
+    // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
+
+    // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
+    bool prev_speed_larger = previous_nominal_speed > block->nominal_speed;
+    float smaller_speed_factor = prev_speed_larger ? (block->nominal_speed / previous_nominal_speed) : (previous_nominal_speed / block->nominal_speed);
+    // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
+    vmax_junction = prev_speed_larger ? block->nominal_speed : previous_nominal_speed;
+    // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
+    float v_factor = 1.f;
+    limited = 0;
+    // Now limit the jerk in all axes.
+    LOOP_XYZE(axis) {
+      // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
+      float v_exit = previous_speed[axis], v_entry = current_speed[axis];
+      if (prev_speed_larger) v_exit *= smaller_speed_factor;
+      if (limited) {
+        v_exit *= v_factor;
+        v_entry *= v_factor;
+      }
+
+      // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
+      const float jerk = (v_exit > v_entry)
+          ? //                                  coasting             axis reversal
+            ( (v_entry > 0.f || v_exit < 0.f) ? (v_exit - v_entry) : max(v_exit, -v_entry) )
+          : // v_exit <= v_entry                coasting             axis reversal
+            ( (v_entry < 0.f || v_exit > 0.f) ? (v_entry - v_exit) : max(-v_exit, v_entry) );
+
+      if (jerk > max_jerk[axis]) {
+        v_factor *= max_jerk[axis] / jerk;
+        ++limited;
+      }
+    }
+    if (limited) vmax_junction *= v_factor;
+    // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
+    // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
+    const float vmax_junction_threshold = vmax_junction * 0.99f;
+    if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold) {
+      // Not coasting. The machine will stop and start the movements anyway,
+      // better to start the segment from start.
+      SBI(block->flag, BLOCK_BIT_START_FROM_FULL_HALT);
+      vmax_junction = safe_speed;
+    }
+  }
+  else {
+    SBI(block->flag, BLOCK_BIT_START_FROM_FULL_HALT);
+    vmax_junction = safe_speed;
+  }
+
+  // Max entry speed of this block equals the max exit speed of the previous block.
+  block->max_entry_speed = vmax_junction;
+
+  // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
+  const float v_allowable = max_allowable_speed(-block->acceleration, MINIMUM_PLANNER_SPEED, block->millimeters);
+  block->entry_speed = min(vmax_junction, v_allowable);
+
+  // Initialize planner efficiency flags
+  // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
+  // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
+  // the current block and next block junction speeds are guaranteed to always be at their maximum
+  // junction speeds in deceleration and acceleration, respectively. This is due to how the current
+  // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
+  // the reverse and forward planners, the corresponding block junction speed will always be at the
+  // the maximum junction speed and may always be ignored for any speed reduction checks.
+  block->flag |= BLOCK_FLAG_RECALCULATE | (block->nominal_speed <= v_allowable ? BLOCK_FLAG_NOMINAL_LENGTH : 0);
+
+  // Update previous path unit_vector and nominal speed
+  COPY(previous_speed, current_speed);
+  previous_nominal_speed = block->nominal_speed;
+  previous_safe_speed = safe_speed;
+
+  #if ENABLED(LIN_ADVANCE)
+
+    //
+    // Use LIN_ADVANCE for blocks if all these are true:
+    //
+    // esteps                                          : We have E steps todo (a printing move)
+    //
+    // block->steps[X_AXIS] || block->steps[Y_AXIS]    : We have a movement in XY direction (i.e., not retract / prime).
+    //
+    // extruder_advance_k                              : There is an advance factor set.
+    //
+    // block->steps[E_AXIS] != block->step_event_count : A problem occurs if the move before a retract is too small.
+    //                                                   In that case, the retract and move will be executed together.
+    //                                                   This leads to too many advance steps due to a huge e_acceleration.
+    //                                                   The math is good, but we must avoid retract moves with advance!
+    // de_float > 0.0                                  : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
+    //
+    block->use_advance_lead =  esteps
+                            && (block->steps[X_AXIS] || block->steps[Y_AXIS])
+                            && extruder_advance_k
+                            && (uint32_t)esteps != block->step_event_count
+                            && de_float > 0.0;
+    if (block->use_advance_lead)
+      block->abs_adv_steps_multiplier8 = LROUND(
+        extruder_advance_k
+        * (UNEAR_ZERO(advance_ed_ratio) ? de_float / mm_D_float : advance_ed_ratio) // Use the fixed ratio, if set
+        * (block->nominal_speed / (float)block->nominal_rate)
+        * axis_steps_per_mm[E_AXIS_N] * 256.0
+      );
+
+  #elif ENABLED(ADVANCE)
+
+    // Calculate advance rate
+    if (esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS])) {
+      const long acc_dist = estimate_acceleration_distance(0, block->nominal_rate, block->acceleration_steps_per_s2);
+      const float advance = ((STEPS_PER_CUBIC_MM_E) * (EXTRUDER_ADVANCE_K)) * HYPOT(current_speed[E_AXIS], EXTRUSION_AREA) * 256;
+      block->advance = advance;
+      block->advance_rate = acc_dist ? advance / (float)acc_dist : 0;
+    }
+    else
+      block->advance_rate = block->advance = 0;
+
+    /**
+     SERIAL_ECHO_START();
+     SERIAL_ECHOPGM("advance :");
+     SERIAL_ECHO(block->advance/256.0);
+     SERIAL_ECHOPGM("advance rate :");
+     SERIAL_ECHOLN(block->advance_rate/256.0);
+     */
+
+  #endif // ADVANCE or LIN_ADVANCE
+
+  calculate_trapezoid_for_block(block, block->entry_speed / block->nominal_speed, safe_speed / block->nominal_speed);
+
+  // Move buffer head
+  block_buffer_head = next_buffer_head;
+
+  // Update the position (only when a move was queued)
+  COPY(position, target);
+  #if ENABLED(LIN_ADVANCE)
+    position_float[X_AXIS] = a;
+    position_float[Y_AXIS] = b;
+    position_float[Z_AXIS] = c;
+    position_float[E_AXIS] = e;
+  #endif
+
+  recalculate();
+
+  stepper.wake_up();
+
+} // buffer_line()
+
+/**
+ * Directly set the planner XYZ position (and stepper positions)
+ * converting mm (or angles for SCARA) into steps.
+ *
+ * On CORE machines stepper ABC will be translated from the given XYZ.
+ */
+
+void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
+  #if ENABLED(DISTINCT_E_FACTORS)
+    #define _EINDEX (E_AXIS + active_extruder)
+    last_extruder = active_extruder;
+  #else
+    #define _EINDEX E_AXIS
+  #endif
+  long na = position[X_AXIS] = LROUND(a * axis_steps_per_mm[X_AXIS]),
+       nb = position[Y_AXIS] = LROUND(b * axis_steps_per_mm[Y_AXIS]),
+       nc = position[Z_AXIS] = LROUND(c * axis_steps_per_mm[Z_AXIS]),
+       ne = position[E_AXIS] = LROUND(e * axis_steps_per_mm[_EINDEX]);
+  #if ENABLED(LIN_ADVANCE)
+    position_float[X_AXIS] = a;
+    position_float[Y_AXIS] = b;
+    position_float[Z_AXIS] = c;
+    position_float[E_AXIS] = e;
+  #endif
+  stepper.set_position(na, nb, nc, ne);
+  previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
+  ZERO(previous_speed);
+}
+
+void Planner::set_position_mm_kinematic(const float position[NUM_AXIS]) {
+  #if PLANNER_LEVELING
+    float lpos[XYZ] = { position[X_AXIS], position[Y_AXIS], position[Z_AXIS] };
+    apply_leveling(lpos);
+  #else
+    const float * const lpos = position;
+  #endif
+  #if IS_KINEMATIC
+    inverse_kinematics(lpos);
+    _set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], position[E_AXIS]);
+  #else
+    _set_position_mm(lpos[X_AXIS], lpos[Y_AXIS], lpos[Z_AXIS], position[E_AXIS]);
+  #endif
+}
+
+/**
+ * Sync from the stepper positions. (e.g., after an interrupted move)
+ */
+void Planner::sync_from_steppers() {
+  LOOP_XYZE(i) {
+    position[i] = stepper.position((AxisEnum)i);
+    #if ENABLED(LIN_ADVANCE)
+      position_float[i] = position[i] * steps_to_mm[i
+        #if ENABLED(DISTINCT_E_FACTORS)
+          + (i == E_AXIS ? active_extruder : 0)
+        #endif
+      ];
+    #endif
+  }
+}
+
+/**
+ * Setters for planner position (also setting stepper position).
+ */
+void Planner::set_position_mm(const AxisEnum axis, const float &v) {
+  #if ENABLED(DISTINCT_E_FACTORS)
+    const uint8_t axis_index = axis + (axis == E_AXIS ? active_extruder : 0);
+    last_extruder = active_extruder;
+  #else
+    const uint8_t axis_index = axis;
+  #endif
+  position[axis] = LROUND(v * axis_steps_per_mm[axis_index]);
+  #if ENABLED(LIN_ADVANCE)
+    position_float[axis] = v;
+  #endif
+  stepper.set_position(axis, v);
+  previous_speed[axis] = 0.0;
+}
+
+// Recalculate the steps/s^2 acceleration rates, based on the mm/s^2
+void Planner::reset_acceleration_rates() {
+  #if ENABLED(DISTINCT_E_FACTORS)
+    #define HIGHEST_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)
+  #else
+    #define HIGHEST_CONDITION true
+  #endif
+  uint32_t highest_rate = 1;
+  LOOP_XYZE_N(i) {
+    max_acceleration_steps_per_s2[i] = max_acceleration_mm_per_s2[i] * axis_steps_per_mm[i];
+    if (HIGHEST_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
+  }
+  cutoff_long = 4294967295UL / highest_rate;
+}
+
+// Recalculate position, steps_to_mm if axis_steps_per_mm changes!
+void Planner::refresh_positioning() {
+  LOOP_XYZE_N(i) steps_to_mm[i] = 1.0 / axis_steps_per_mm[i];
+  set_position_mm_kinematic(current_position);
+  reset_acceleration_rates();
+}
+
+#if ENABLED(AUTOTEMP)
+
+  void Planner::autotemp_M104_M109() {
+    autotemp_enabled = parser.seen('F');
+    if (autotemp_enabled) autotemp_factor = parser.value_celsius_diff();
+    if (parser.seen('S')) autotemp_min = parser.value_celsius();
+    if (parser.seen('B')) autotemp_max = parser.value_celsius();
+  }
+
+#endif
