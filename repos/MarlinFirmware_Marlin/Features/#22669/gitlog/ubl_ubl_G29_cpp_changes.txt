commit 49348716f538a16f7232efb0eed5d4e01d5a1494
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon May 6 19:58:00 2024 -0400

    🩹 Fix printf et.al. expecting F-strings (#27032)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index fcf408b34e..4637bf87e8 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -758,21 +758,21 @@ void unified_bed_leveling::shift_mesh_height() {
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
     grid_count_t count = GRID_MAX_POINTS;
 
     mesh_index_pair best;
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_START));
     do {
       if (do_ubl_mesh_map) display_map(param.T_map_type);
 
       const grid_count_t point_num = (GRID_MAX_POINTS - count) + 1;
       SERIAL_ECHOLNPGM("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
-      TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), point_num, int(GRID_MAX_POINTS)));
+      TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT_F(MSG_PROBING_POINT), point_num, int(GRID_MAX_POINTS)));
       TERN_(HAS_BACKLIGHT_TIMEOUT, ui.refresh_backlight_timeout());
 
       #if HAS_MARLINUI_MENU
         if (ui.button_pressed()) {
           ui.quick_feedback(false); // Preserve button state for click-and-hold
           SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
@@ -1487,21 +1487,21 @@ void unified_bed_leveling::smart_fill_mesh() {
           points[ix] = cpos[ix].meshpos();
         }
       #endif
 
       #if ENABLED(VALIDATE_MESH_TILT)
         float gotz[3];  // Used for algorithm validation below
       #endif
 
       for (uint8_t i = 0; i < 3; ++i) {
         SERIAL_ECHOLNPGM("Tilting mesh (", i + 1, "/3)");
-        TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/3"), GET_TEXT(MSG_LCD_TILTING_MESH), i + 1));
+        TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/3"), GET_TEXT_F(MSG_LCD_TILTING_MESH), i + 1));
 
         measured_z = probe.probe_at_point(points[i], i < 2 ? PROBE_PT_RAISE : PROBE_PT_LAST_STOW, param.V_verbosity);
         if ((abort_flag = isnan(measured_z))) break;
 
         measured_z -= TERN(UBL_TILT_ON_MESH_POINTS_3POINT, z_values[cpos[i].pos.x][cpos[i].pos.y], get_z_correction(points[i]));
         TERN_(VALIDATE_MESH_TILT, gotz[i] = measured_z);
 
         if (param.V_verbosity > 3) { SERIAL_ECHO_SP(16); SERIAL_ECHOLNPGM("Corrected_Z=", measured_z); }
 
         incremental_LSF(&lsf_results, points[i], measured_z);
@@ -1543,21 +1543,21 @@ void unified_bed_leveling::smart_fill_mesh() {
               xy_pos_t oldRpos;
               if (DEBUGGING(LEVELING)) oldRpos = rpos;
             #endif
             mesh_index_pair cpos;
             rpos -= probe.offset;
             cpos = find_closest_mesh_point_of_type(REAL, rpos, true);
             rpos = cpos.meshpos();
           #endif
 
           SERIAL_ECHOLNPGM("Tilting mesh point ", point_num, "/", total_points, "\n");
-          TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
+          TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT_F(MSG_LCD_TILTING_MESH), point_num, total_points));
 
           measured_z = probe.probe_at_point(rpos, parser.seen_test('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity); // TODO: Needs error handling
 
           if ((abort_flag = isnan(measured_z))) break;
 
           const float zcorr = TERN(UBL_TILT_ON_MESH_POINTS, z_values[cpos.pos.x][cpos.pos.y], get_z_correction(rpos));
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               #if ENABLED(UBL_TILT_ON_MESH_POINTS)

commit 87e94f456348e944ba4487aed436c762dd718966
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon Apr 1 16:05:11 2024 -0400

    🚸 Update ProUI Plot graph - part 2 (#26563)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 2e7ea74327..fcf408b34e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -302,21 +302,21 @@ void unified_bed_leveling::G29() {
 
   const uint8_t p_val = parser.byteval('P');
   const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen_test('J');
 
   // Check for commands that require the printer to be homed
   if (may_move) {
     planner.synchronize();
     #if ALL(DWIN_LCD_PROUI, ZHOME_BEFORE_LEVELING)
       save_ubl_active_state_and_disable();
       gcode.process_subcommands_now(F("G28Z"));
-      restore_ubl_active_state_and_leave();
+      restore_ubl_active_state(false); // ...without telling ExtUI "done"
     #else
       // Send 'N' to force homing before G29 (internal only)
       if (axes_should_home() || parser.seen_test('N')) gcode.home_all_axes();
     #endif
     probe.use_probing_tool();
 
     // Position bed horizontally and Z probe vertically.
     #if HAS_SAFE_BED_LEVELING
       xyze_pos_t safe_position = current_position;
       #ifdef SAFE_BED_LEVELING_START_X
@@ -418,21 +418,21 @@ void unified_bed_leveling::G29() {
           }
         break;
     }
   }
 
   #if HAS_BED_PROBE
 
     if (parser.seen_test('J')) {
       save_ubl_active_state_and_disable();
       tilt_mesh_based_on_probed_grid(param.J_grid_size == 0); // Zero size does 3-Point
-      restore_ubl_active_state_and_leave();
+      restore_ubl_active_state();
       #if ENABLED(UBL_G29_J_RECENTER)
         do_blocking_move_to_xy(0.5f * ((MESH_MIN_X) + (MESH_MAX_X)), 0.5f * ((MESH_MIN_Y) + (MESH_MAX_Y)));
       #endif
       report_current_position();
       probe_deployed = true;
     }
 
   #endif // HAS_BED_PROBE
 
   if (parser.seen_test('P')) {
@@ -747,46 +747,43 @@ void unified_bed_leveling::shift_mesh_height() {
   /**
    * G29 P1 T<maptype> V<verbosity> : Probe Entire Mesh
    *   Probe all invalidated locations of the mesh that can be reached by the probe.
    *   This attempts to fill in locations closest to the nozzle's start location first.
    */
   void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &nearby, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
     probe.deploy(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
 
     TERN_(HAS_MARLINUI_MENU, ui.capture());
     TERN_(EXTENSIBLE_UI, ExtUI::onLevelingStart());
-    TERN_(DWIN_LCD_PROUI, dwinLevelingStart());
 
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
     grid_count_t count = GRID_MAX_POINTS;
 
     mesh_index_pair best;
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_START));
     do {
       if (do_ubl_mesh_map) display_map(param.T_map_type);
 
       const grid_count_t point_num = (GRID_MAX_POINTS - count) + 1;
       SERIAL_ECHOLNPGM("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
       TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), point_num, int(GRID_MAX_POINTS)));
       TERN_(HAS_BACKLIGHT_TIMEOUT, ui.refresh_backlight_timeout());
-      TERN_(DWIN_LCD_PROUI, dwinRedrawScreen());
 
       #if HAS_MARLINUI_MENU
         if (ui.button_pressed()) {
           ui.quick_feedback(false); // Preserve button state for click-and-hold
           SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
-          TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
-          return restore_ubl_active_state_and_leave();
+          return restore_ubl_active_state();
         }
       #endif
 
       #ifndef HUGE_VALF
         #define HUGE_VALF __FLT_MAX__
       #endif
 
       best = do_furthest // Points with valid data or HUGE_VALF are skipped
         ? find_furthest_invalid_mesh_point()
         : find_closest_mesh_point_of_type(INVALID, nearby, true);
@@ -808,29 +805,26 @@ void unified_bed_leveling::shift_mesh_height() {
 
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_FINISH));
 
     // Release UI during stow to allow for PAUSE_BEFORE_DEPLOY_STOW
     TERN_(HAS_MARLINUI_MENU, ui.release());
     probe.stow();
     TERN_(HAS_MARLINUI_MENU, ui.capture());
 
     probe.move_z_after_probing();
 
-    restore_ubl_active_state_and_leave();
-
     do_blocking_move_to_xy(
       constrain(nearby.x - probe.offset_xy.x, MESH_MIN_X, MESH_MAX_X),
       constrain(nearby.y - probe.offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
     );
 
-    TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
-    TERN_(DWIN_LCD_PROUI, dwinLevelingDone());
+    restore_ubl_active_state();
   }
 
 #endif // HAS_BED_PROBE
 
 void set_message_with_feedback(FSTR_P const fstr) {
   #if HAS_MARLINUI_MENU
     ui.set_status(fstr);
     ui.quick_feedback();
   #else
     UNUSED(fstr);
@@ -925,21 +919,21 @@ void set_message_with_feedback(FSTR_P const fstr) {
     echo_and_take_a_measurement();
 
     const float z2 = measure_point_with_encoder();
     do_z_clearance_by(Z_CLEARANCE_BETWEEN_PROBES);
 
     const float thickness = ABS(z1 - z2);
 
     if (param.V_verbosity > 1)
       SERIAL_ECHOLNPGM("Business Card is ", p_float_t(thickness, 4), "mm thick.");
 
-    restore_ubl_active_state_and_leave();
+    restore_ubl_active_state();
 
     return thickness;
   }
 
   /**
    * G29 P2 : Manually Probe Remaining Mesh Points.
    *          Move to INVALID points and
    *          NOTE: Blocks the G-code queue and captures Marlin UI during use.
    */
   void unified_bed_leveling::manually_probe_remaining_mesh(const xy_pos_t &pos, const_float_t z_clearance, const_float_t thick, const bool do_ubl_mesh_map) {
@@ -980,39 +974,37 @@ void set_message_with_feedback(FSTR_P const fstr) {
         SERIAL_ECHOPGM("Measure");
         LCD_MESSAGE(MSG_UBL_BC_INSERT2);
       }
 
       const float z_step = 0.01f;                         // 0.01mm per encoder tick, occasionally step
       move_z_with_encoder(z_step);
 
       if (_click_and_hold([]{
         SERIAL_ECHOLNPGM("\nMesh only partially populated.");
         do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
-      })) return restore_ubl_active_state_and_leave();
+      })) return restore_ubl_active_state();
 
       // Store the Z position minus the shim height
       z_values[lpos.x][lpos.y] = current_position.z - thick;
 
       // Tell the external UI to update
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, z_values[lpos.x][lpos.y]));
 
       if (param.V_verbosity > 2)
         SERIAL_ECHOLNPGM("Mesh Point Measured at: ", p_float_t(z_values[lpos.x][lpos.y], 6));
       SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
     } while (location.valid());
 
     if (do_ubl_mesh_map) display_map(param.T_map_type);  // show user where we're probing
 
-    restore_ubl_active_state_and_leave();
+    restore_ubl_active_state();
     do_blocking_move_to_xy_z(pos, Z_CLEARANCE_DEPLOY_PROBE);
-
-    TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
   }
 
   /**
    * G29 P4 : Mesh Fine-Tuning. Go to point(s) and adjust values with the LCD.
    *          NOTE: Blocks the G-code queue and captures Marlin UI during use.
    */
   void unified_bed_leveling::fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) {
     if (!parser.seen_test('R')) // fine_tune_mesh() is special. If no repetition count flag is specified
       param.R_repetition = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 
@@ -1104,21 +1096,21 @@ void set_message_with_feedback(FSTR_P const fstr) {
       // TODO: Re-enable leveling here so Z is correctly based on the updated mesh.
 
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, new_z));
 
       serial_delay(20);                                   // No switch noise
       ui.refresh();
 
     } while (lpos.x >= 0 && --param.R_repetition > 0);
 
     if (do_ubl_mesh_map) display_map(param.T_map_type);
-    restore_ubl_active_state_and_leave();
+    restore_ubl_active_state();
 
     do_blocking_move_to_xy_z(pos, Z_TWEEN_SAFE_CLEARANCE);
 
     LCD_MESSAGE(MSG_UBL_DONE_EDITING_MESH);
     SERIAL_ECHOLNPGM("Done Editing Mesh");
 
     if (lcd_map_control)
       ui.goto_screen(ubl_map_screen);
     else
       ui.return_to_status();
@@ -1256,31 +1248,34 @@ void unified_bed_leveling::save_ubl_active_state_and_disable() {
     if (ubl_state_recursion_chk != 1) {
       SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
       set_message_with_feedback(GET_TEXT_F(MSG_UBL_SAVE_ERROR));
       return;
     }
   #endif
   ubl_state_at_invocation = planner.leveling_active;
   set_bed_leveling_enabled(false);
 }
 
-void unified_bed_leveling::restore_ubl_active_state_and_leave() {
+void unified_bed_leveling::restore_ubl_active_state(const bool is_done/*=true*/) {
   TERN_(HAS_MARLINUI_MENU, ui.release());
   #if ENABLED(UBL_DEVEL_DEBUGGING)
     if (--ubl_state_recursion_chk) {
-      SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
+      SERIAL_ECHOLNPGM("restore_ubl_active_state() called too many times.");
       set_message_with_feedback(GET_TEXT_F(MSG_UBL_RESTORE_ERROR));
       return;
     }
   #endif
   set_bed_leveling_enabled(ubl_state_at_invocation);
-  TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
+
+  if (is_done) {
+    TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
+  }
 }
 
 mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
   bool found_a_NAN = false, found_a_real = false;
 
   mesh_index_pair farthest { -1, -1, -99999.99 };
 
   GRID_LOOP(i, j) {
     if (!isnan(z_values[i][j])) continue;  // Skip valid mesh points

commit 5639237e2b174715413f9ffc6f6421db9150d9d6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 29 20:38:03 2024 -0600

    🎨 Misc. cleanup 29-01

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 6fccde8e89..2e7ea74327 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -608,21 +608,20 @@ void unified_bed_leveling::G29() {
     //
     // When we are fully debugged, this may go away. But there are some valid
     // use cases for the users. So we can wait and see what to do with it.
     //
 
     if (parser.seen('K')) // Kompare Current Mesh Data to Specified Stored Mesh
       g29_compare_current_mesh_to_stored_mesh();
 
   #endif // UBL_DEVEL_DEBUGGING
 
-
   //
   // Load a Mesh from the EEPROM
   //
 
   if (parser.seen('L')) {     // Load Current Mesh Data
     param.KLS_storage_slot = parser.has_value() ? (int8_t)parser.value_int() : storage_slot;
 
     int16_t a = settings.calc_num_meshes();
 
     if (!a) {

commit 01094ea6aa7b843f830ec350e5886fcab6b652ff
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Thu Jan 25 19:18:49 2024 -0500

    ✨🔨 EEPROM exclusion zone (#26729)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 560ff71e84..6fccde8e89 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1810,21 +1810,22 @@ void unified_bed_leveling::smart_fill_mesh() {
   void unified_bed_leveling::g29_eeprom_dump() {
     uint8_t cccc;
 
     SERIAL_ECHO_MSG("EEPROM Dump:");
     persistentStore.access_start();
     for (uint16_t i = 0; i < persistentStore.capacity(); i += 16) {
       if (!(i & 0x3)) idle();
       print_hex_word(i);
       SERIAL_ECHOPGM(": ");
       for (uint16_t j = 0; j < 16; j++) {
-        persistentStore.read_data(i + j, &cccc, sizeof(uint8_t));
+        int pos = i + j;
+        persistentStore.read_data(pos, &cccc, sizeof(uint8_t));
         print_hex_byte(cccc);
         SERIAL_CHAR(' ');
       }
       SERIAL_EOL();
     }
     SERIAL_EOL();
     persistentStore.access_finish();
   }
 
   /**

commit f4eafed188189d2a77c53a2a68bd931ee838b584
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 7 21:59:25 2024 -0600

    🔧 Z_PROBE_END_SCRIPT => EVENT_GCODE_AFTER_G29

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 720c86769d..560ff71e84 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -674,25 +674,25 @@ void unified_bed_leveling::G29() {
 
   LEAVE:
 
   #if HAS_MARLINUI_MENU
     ui.reset_alert_level();
     ui.quick_feedback();
     ui.reset_status();
     ui.release();
   #endif
 
-  #ifdef Z_PROBE_END_SCRIPT
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
+  #ifdef EVENT_GCODE_AFTER_G29
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z Probe End Script: ", EVENT_GCODE_AFTER_G29);
     if (probe_deployed) {
       planner.synchronize();
-      gcode.process_subcommands_now(F(Z_PROBE_END_SCRIPT));
+      gcode.process_subcommands_now(F(EVENT_GCODE_AFTER_G29));
     }
   #else
     UNUSED(probe_deployed);
   #endif
 
   probe.use_probing_tool(false);
   return;
 }
 
 /**

commit 52693f72afca243ace00a7a57365301f5f8c42c0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 4 13:01:45 2024 -0600

    🎨 Clean up some checks & includes

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index c61a84894a..720c86769d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -30,24 +30,20 @@
 #include "../../../HAL/shared/eeprom_api.h"
 #include "../../../libs/hex_print.h"
 #include "../../../module/settings.h"
 #include "../../../lcd/marlinui.h"
 #include "../../../module/planner.h"
 #include "../../../module/motion.h"
 #include "../../../module/probe.h"
 #include "../../../gcode/gcode.h"
 #include "../../../libs/least_squares_fit.h"
 
-#if HAS_MULTI_HOTEND
-  #include "../../../module/tool_change.h"
-#endif
-
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extui/ui_api.h"
 #endif
 
 #if ENABLED(UBL_HILBERT_CURVE)
   #include "../hilbert_curve.h"
 #endif

commit 15f26b402123d087f62728e1f1763a2b96f8d21d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Dec 27 01:25:51 2023 -0600

    🧑‍💻 AS_CHAR => C (#26569)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 3d0013b6d2..c61a84894a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -458,21 +458,21 @@ void unified_bed_leveling::G29() {
 
         case 1: {
           //
           // Invalidate Entire Mesh and Automatically Probe Mesh in areas that can be reached by the probe
           //
           if (!parser.seen_test('C')) {
             invalidate();
             SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
           }
           if (param.V_verbosity > 1)
-            SERIAL_ECHOLN(F("Probing around ("), param.XY_pos.x, AS_CHAR(','), param.XY_pos.y, F(").\n"));
+            SERIAL_ECHOLN(F("Probing around ("), param.XY_pos.x, C(','), param.XY_pos.y, F(").\n"));
           probe_entire_mesh(param.XY_pos, parser.seen_test('T'), parser.seen_test('E'), parser.seen_test('U'));
 
           report_current_position();
           probe_deployed = true;
         } break;
 
       #endif // HAS_BED_PROBE
 
       case 2: {
         #if HAS_MARLINUI_MENU
@@ -1565,28 +1565,28 @@ void unified_bed_leveling::smart_fill_mesh() {
           measured_z = probe.probe_at_point(rpos, parser.seen_test('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity); // TODO: Needs error handling
 
           if ((abort_flag = isnan(measured_z))) break;
 
           const float zcorr = TERN(UBL_TILT_ON_MESH_POINTS, z_values[cpos.pos.x][cpos.pos.y], get_z_correction(rpos));
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               #if ENABLED(UBL_TILT_ON_MESH_POINTS)
                 const xy_pos_t oldLpos = oldRpos.asLogical();
-                DEBUG_ECHO(F("Calculated point: ("), p_float_t(oldRpos.x, 7), AS_CHAR(','), p_float_t(oldRpos.y, 7),
-                           F(")   logical: ("), p_float_t(oldLpos.x, 7), AS_CHAR(','), p_float_t(oldLpos.y, 7),
+                DEBUG_ECHO(F("Calculated point: ("), p_float_t(oldRpos.x, 7), C(','), p_float_t(oldRpos.y, 7),
+                           F(")   logical: ("), p_float_t(oldLpos.x, 7), C(','), p_float_t(oldLpos.y, 7),
                            F(")\nSelected mesh point: ")
                 );
               #endif
               const xy_pos_t lpos = rpos.asLogical();
-              DEBUG_ECHO(      AS_CHAR('('), p_float_t(rpos.x, 7), AS_CHAR(','), p_float_t(rpos.y, 7),
-                         F(")  logical: ("), p_float_t(lpos.x, 7), AS_CHAR(','), p_float_t(lpos.y, 7),
+              DEBUG_ECHO(      C('('), p_float_t(rpos.x, 7), C(','), p_float_t(rpos.y, 7),
+                         F(")  logical: ("), p_float_t(lpos.x, 7), C(','), p_float_t(lpos.y, 7),
                          F(")  measured: "), p_float_t(measured_z, 7),
                          F("  correction: "), p_float_t(zcorr, 7)
               );
             }
           #endif
 
           measured_z -= zcorr;
 
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("  final >>>---> ", p_float_t(measured_z, 7));
 
@@ -1607,75 +1607,75 @@ void unified_bed_leveling::smart_fill_mesh() {
     probe.move_z_after_probing();
 
     if (abort_flag || finish_incremental_LSF(&lsf_results)) {
       SERIAL_ECHOLNPGM("Could not complete LSF!");
       return;
     }
 
     vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1).get_normal();
 
     if (param.V_verbosity > 2)
-      SERIAL_ECHOLN(F("bed plane normal = ["), p_float_t(normal.x, 7), AS_CHAR(','), p_float_t(normal.y, 7), AS_CHAR(','), p_float_t(normal.z, 7), AS_CHAR(']'));
+      SERIAL_ECHOLN(F("bed plane normal = ["), p_float_t(normal.x, 7), C(','), p_float_t(normal.y, 7), C(','), p_float_t(normal.z, 7), C(']'));
 
     matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
 
     GRID_LOOP(i, j) {
       float mx = get_mesh_x(i), my = get_mesh_y(j), mz = z_values[i][j];
 
       if (DEBUGGING(LEVELING)) {
-        DEBUG_ECHOLN(F("before rotation = ["), p_float_t(mx, 7), AS_CHAR(','), p_float_t(my, 7), AS_CHAR(','), p_float_t(mz, 7), F("]   ---> "));
+        DEBUG_ECHOLN(F("before rotation = ["), p_float_t(mx, 7), C(','), p_float_t(my, 7), C(','), p_float_t(mz, 7), F("]   ---> "));
         DEBUG_DELAY(20);
       }
 
       rotation.apply_rotation_xyz(mx, my, mz);
 
       if (DEBUGGING(LEVELING)) {
-        DEBUG_ECHOLN(F("after rotation = ["), p_float_t(mx, 7), AS_CHAR(','), p_float_t(my, 7), AS_CHAR(','), p_float_t(mz, 7), F("]   ---> "));
+        DEBUG_ECHOLN(F("after rotation = ["), p_float_t(mx, 7), C(','), p_float_t(my, 7), C(','), p_float_t(mz, 7), F("]   ---> "));
         DEBUG_DELAY(20);
       }
 
       z_values[i][j] = mz - lsf_results.D;
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(i, j, z_values[i][j]));
     }
 
     if (DEBUGGING(LEVELING)) {
       rotation.debug(F("rotation matrix:\n"));
       DEBUG_ECHOLN(F("LSF Results A="), p_float_t(lsf_results.A, 7), F("  B="), p_float_t(lsf_results.B, 7), F("  D="), p_float_t(lsf_results.D, 7));
       DEBUG_DELAY(55);
-      DEBUG_ECHOLN(F("bed plane normal = ["), p_float_t(normal.x, 7), AS_CHAR(','), p_float_t(normal.y, 7), AS_CHAR(','), p_float_t(normal.z, 7), AS_CHAR(']'));
+      DEBUG_ECHOLN(F("bed plane normal = ["), p_float_t(normal.x, 7), C(','), p_float_t(normal.y, 7), C(','), p_float_t(normal.z, 7), C(']'));
       DEBUG_EOL();
 
       /**
        * Use the code below to check the validity of the mesh tilting algorithm.
        * 3-Point Mesh Tilt uses the same algorithm as grid-based tilting, but only
        * three points are used in the calculation. This guarantees that each probed point
        * has an exact match when get_z_correction() for that location is calculated.
        * The Z error between the probed point locations and the get_z_correction()
        * numbers for those locations should be 0.
        */
       #if ENABLED(VALIDATE_MESH_TILT)
         auto d_from = []{ DEBUG_ECHOPGM("D from "); };
         auto normed = [&](const xy_pos_t &pos, const_float_t zadd) {
           return normal.x * pos.x + normal.y * pos.y + zadd;
         };
         auto debug_pt = [](const int num, const xy_pos_t &pos, const_float_t zadd) {
           d_from();
-          DEBUG_ECHOLN(F("Point "), num, AS_CHAR(':'), p_float_t(normed(pos, zadd), 6), F("   Z error = "), p_float_t(zadd - get_z_correction(pos), 6));
+          DEBUG_ECHOLN(F("Point "), num, C(':'), p_float_t(normed(pos, zadd), 6), F("   Z error = "), p_float_t(zadd - get_z_correction(pos), 6));
         };
         debug_pt(1, probe_pt[0], normal.z * gotz[0]);
         debug_pt(2, probe_pt[1], normal.z * gotz[1]);
         debug_pt(3, probe_pt[2], normal.z * gotz[2]);
         #if ENABLED(Z_SAFE_HOMING)
           constexpr xy_float_t safe_xy = { Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT };
           d_from(); DEBUG_ECHOLN(F("safe home with Z="), F("0 : "), p_float_t(normed(safe_xy, 0), 6));
           d_from(); DEBUG_ECHOLN(F("safe home with Z="), F("mesh value "), p_float_t(normed(safe_xy, get_z_correction(safe_xy)), 6));
-          DEBUG_ECHO(F("   Z error = ("), Z_SAFE_HOMING_X_POINT, AS_CHAR(','), Z_SAFE_HOMING_Y_POINT, F(") = "), p_float_t(get_z_correction(safe_xy), 6));
+          DEBUG_ECHO(F("   Z error = ("), Z_SAFE_HOMING_X_POINT, C(','), Z_SAFE_HOMING_Y_POINT, F(") = "), p_float_t(get_z_correction(safe_xy), 6));
         #endif
       #endif
     } // DEBUGGING(LEVELING)
 
   }
 
 #endif // HAS_BED_PROBE
 
 #if ENABLED(UBL_G29_P31)
   void unified_bed_leveling::smart_fill_wlsf(const_float_t weight_factor) {

commit 06710e54de8c83af77a4f57d458f6463fbfcad93
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Wed Dec 13 00:33:03 2023 -0500

    ✨ EDITABLE_DISPLAY_TIMEOUT (#26517)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index d136f0000d..3d0013b6d2 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -765,21 +765,22 @@ void unified_bed_leveling::shift_mesh_height() {
     grid_count_t count = GRID_MAX_POINTS;
 
     mesh_index_pair best;
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_START));
     do {
       if (do_ubl_mesh_map) display_map(param.T_map_type);
 
       const grid_count_t point_num = (GRID_MAX_POINTS - count) + 1;
       SERIAL_ECHOLNPGM("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
       TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), point_num, int(GRID_MAX_POINTS)));
-      TERN_(LCD_BACKLIGHT_TIMEOUT_MINS, ui.refresh_backlight_timeout());
+      TERN_(HAS_BACKLIGHT_TIMEOUT, ui.refresh_backlight_timeout());
+      TERN_(DWIN_LCD_PROUI, dwinRedrawScreen());
 
       #if HAS_MARLINUI_MENU
         if (ui.button_pressed()) {
           ui.quick_feedback(false); // Preserve button state for click-and-hold
           SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
           TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());

commit bdfe4a108c347544d4aa50936ac15e71550cb545
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 8 23:18:50 2023 -0600

    🩹  Fix UBL debug output

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 7496c9e9b5..d136f0000d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1783,22 +1783,22 @@ void unified_bed_leveling::smart_fill_mesh() {
 
     SERIAL_EOL();
     serial_delay(50);
 
     SERIAL_ECHOLNPGM("ubl_state_at_invocation :", ubl_state_at_invocation, "\nubl_state_recursion_chk :", ubl_state_recursion_chk);
     serial_delay(50);
 
     SERIAL_ECHOLNPGM("Meshes go from ", hex_address((void*)settings.meshes_start_index()), " to ", hex_address((void*)settings.meshes_end_index()));
     serial_delay(50);
 
-    SERIAL_ECHOLNPGM("sizeof(ubl) :  ", sizeof(ubl));         SERIAL_EOL();
-    SERIAL_ECHOLNPGM("z_value[][] size: ", sizeof(z_values)); SERIAL_EOL();
+    SERIAL_ECHOLNPGM("sizeof(unified_bed_leveling) :  ", sizeof(unified_bed_leveling));
+    SERIAL_ECHOLNPGM("z_value[][] size: ", sizeof(z_values));
     serial_delay(25);
 
     SERIAL_ECHOLNPGM("EEPROM free for UBL: ", hex_address((void*)(settings.meshes_end_index() - settings.meshes_start_index())));
     serial_delay(50);
 
     SERIAL_ECHOLNPGM("EEPROM can hold ", settings.calc_num_meshes(), " meshes.\n");
     serial_delay(25);
 
     if (!sanity_check()) {
       echo_name();

commit bf5612c0ed3818d5a61e053a5cfb53f9914ef45f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 9 16:05:11 2023 -0600

    🧑‍💻 Use __FLT_MAX__ for HUGE_VALF

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index df3faaa50f..7496c9e9b5 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -781,21 +781,21 @@ void unified_bed_leveling::shift_mesh_height() {
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
           TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
           return restore_ubl_active_state_and_leave();
         }
       #endif
 
       #ifndef HUGE_VALF
-        #define HUGE_VALF FLT_MAX
+        #define HUGE_VALF __FLT_MAX__
       #endif
 
       best = do_furthest // Points with valid data or HUGE_VALF are skipped
         ? find_furthest_invalid_mesh_point()
         : find_closest_mesh_point_of_type(INVALID, nearby, true);
 
       if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_POINT_START));
         const float measured_z = probe.probe_at_point(best.meshpos(), stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity);
         z_values[best.pos.x][best.pos.y] = isnan(measured_z) ? HUGE_VALF : measured_z;  // Mark invalid point already probed with HUGE_VALF to omit it in the next loop

commit 3341683db23c1aef9aaa538439df7a079f200166
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 5 21:30:04 2023 -0600

    🧑‍💻 Use FLT_MAX for HUGE_VALF

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 15e36ac678..df3faaa50f 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -781,21 +781,21 @@ void unified_bed_leveling::shift_mesh_height() {
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
           TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
           return restore_ubl_active_state_and_leave();
         }
       #endif
 
       #ifndef HUGE_VALF
-        #define HUGE_VALF (10e100F)
+        #define HUGE_VALF FLT_MAX
       #endif
 
       best = do_furthest // Points with valid data or HUGE_VALF are skipped
         ? find_furthest_invalid_mesh_point()
         : find_closest_mesh_point_of_type(INVALID, nearby, true);
 
       if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_POINT_START));
         const float measured_z = probe.probe_at_point(best.meshpos(), stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity);
         z_values[best.pos.x][best.pos.y] = isnan(measured_z) ? HUGE_VALF : measured_z;  // Mark invalid point already probed with HUGE_VALF to omit it in the next loop

commit 8fa6a4da2eebc1dbe120dcac87b159e389e17dc3
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Fri Aug 25 19:33:49 2023 -0400

    🚸 Fixes for ProUI, JyersUI, backlight, etc. (#26086)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index ed4363acbc..15e36ac678 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -765,20 +765,21 @@ void unified_bed_leveling::shift_mesh_height() {
     grid_count_t count = GRID_MAX_POINTS;
 
     mesh_index_pair best;
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_START));
     do {
       if (do_ubl_mesh_map) display_map(param.T_map_type);
 
       const grid_count_t point_num = (GRID_MAX_POINTS - count) + 1;
       SERIAL_ECHOLNPGM("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
       TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), point_num, int(GRID_MAX_POINTS)));
+      TERN_(LCD_BACKLIGHT_TIMEOUT_MINS, ui.refresh_backlight_timeout());
 
       #if HAS_MARLINUI_MENU
         if (ui.button_pressed()) {
           ui.quick_feedback(false); // Preserve button state for click-and-hold
           SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
           TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());

commit 88f5e2c6394cde42969fd4a21ba579cf2cd2db77
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Mon Aug 7 16:11:12 2023 -0500

    🐛 Fix UBL probe_entire_mesh skips points (#26141)
    
    Fixes #26132

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 6f5187cc9f..ed4363acbc 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -779,37 +779,43 @@ void unified_bed_leveling::shift_mesh_height() {
           SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
           TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
           return restore_ubl_active_state_and_leave();
         }
       #endif
 
-      best = do_furthest
+      #ifndef HUGE_VALF
+        #define HUGE_VALF (10e100F)
+      #endif
+
+      best = do_furthest // Points with valid data or HUGE_VALF are skipped
         ? find_furthest_invalid_mesh_point()
         : find_closest_mesh_point_of_type(INVALID, nearby, true);
 
       if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_POINT_START));
         const float measured_z = probe.probe_at_point(best.meshpos(), stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity);
-        z_values[best.pos.x][best.pos.y] = measured_z;
+        z_values[best.pos.x][best.pos.y] = isnan(measured_z) ? HUGE_VALF : measured_z;  // Mark invalid point already probed with HUGE_VALF to omit it in the next loop
         #if ENABLED(EXTENSIBLE_UI)
           ExtUI::onMeshUpdate(best.pos, ExtUI::G29_POINT_FINISH);
           ExtUI::onMeshUpdate(best.pos, measured_z);
         #endif
       }
       SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
 
     } while (best.pos.x >= 0 && --count);
 
+    GRID_LOOP(x, y) if (z_values[x][y] == HUGE_VALF) z_values[x][y] = NAN; // Restore NAN for HUGE_VALF marks
+
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_FINISH));
 
     // Release UI during stow to allow for PAUSE_BEFORE_DEPLOY_STOW
     TERN_(HAS_MARLINUI_MENU, ui.release());
     probe.stow();
     TERN_(HAS_MARLINUI_MENU, ui.capture());
 
     probe.move_z_after_probing();
 
     restore_ubl_active_state_and_leave();

commit f14f1be168ebf252dd458c935271aed1a57cfa0b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 30 19:16:00 2023 -0500

    🎨 Standardize naming (ProUI) (#25982)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 3b8ee33730..6f5187cc9f 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -752,21 +752,21 @@ void unified_bed_leveling::shift_mesh_height() {
   /**
    * G29 P1 T<maptype> V<verbosity> : Probe Entire Mesh
    *   Probe all invalidated locations of the mesh that can be reached by the probe.
    *   This attempts to fill in locations closest to the nozzle's start location first.
    */
   void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &nearby, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
     probe.deploy(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
 
     TERN_(HAS_MARLINUI_MENU, ui.capture());
     TERN_(EXTENSIBLE_UI, ExtUI::onLevelingStart());
-    TERN_(DWIN_LCD_PROUI, DWIN_LevelingStart());
+    TERN_(DWIN_LCD_PROUI, dwinLevelingStart());
 
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
     grid_count_t count = GRID_MAX_POINTS;
 
     mesh_index_pair best;
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_START));
     do {
       if (do_ubl_mesh_map) display_map(param.T_map_type);
 
       const grid_count_t point_num = (GRID_MAX_POINTS - count) + 1;
@@ -813,21 +813,21 @@ void unified_bed_leveling::shift_mesh_height() {
     probe.move_z_after_probing();
 
     restore_ubl_active_state_and_leave();
 
     do_blocking_move_to_xy(
       constrain(nearby.x - probe.offset_xy.x, MESH_MIN_X, MESH_MAX_X),
       constrain(nearby.y - probe.offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
     );
 
     TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
-    TERN_(DWIN_LCD_PROUI, DWIN_LevelingDone());
+    TERN_(DWIN_LCD_PROUI, dwinLevelingDone());
   }
 
 #endif // HAS_BED_PROBE
 
 void set_message_with_feedback(FSTR_P const fstr) {
   #if HAS_MARLINUI_MENU
     ui.set_status(fstr);
     ui.quick_feedback();
   #else
     UNUSED(fstr);

commit 858916d628526b5d56c34c5c9663e3535bfc7788
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Fri Jun 23 04:57:22 2023 -0500

    🚸 Update DWIN ProUI (#26003)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 1c43af1884..3b8ee33730 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -303,22 +303,28 @@ void unified_bed_leveling::G29() {
 
   bool probe_deployed = false;
   if (G29_parse_parameters()) return; // Abort on parameter error
 
   const uint8_t p_val = parser.byteval('P');
   const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen_test('J');
 
   // Check for commands that require the printer to be homed
   if (may_move) {
     planner.synchronize();
-    // Send 'N' to force homing before G29 (internal only)
-    if (axes_should_home() || parser.seen_test('N')) gcode.home_all_axes();
+    #if ALL(DWIN_LCD_PROUI, ZHOME_BEFORE_LEVELING)
+      save_ubl_active_state_and_disable();
+      gcode.process_subcommands_now(F("G28Z"));
+      restore_ubl_active_state_and_leave();
+    #else
+      // Send 'N' to force homing before G29 (internal only)
+      if (axes_should_home() || parser.seen_test('N')) gcode.home_all_axes();
+    #endif
     probe.use_probing_tool();
 
     // Position bed horizontally and Z probe vertically.
     #if HAS_SAFE_BED_LEVELING
       xyze_pos_t safe_position = current_position;
       #ifdef SAFE_BED_LEVELING_START_X
         safe_position.x = SAFE_BED_LEVELING_START_X;
       #endif
       #ifdef SAFE_BED_LEVELING_START_Y
         safe_position.y = SAFE_BED_LEVELING_START_Y;

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ♻️ Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 551277c35d..1c43af1884 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -451,26 +451,22 @@ void unified_bed_leveling::G29() {
       #if HAS_BED_PROBE
 
         case 1: {
           //
           // Invalidate Entire Mesh and Automatically Probe Mesh in areas that can be reached by the probe
           //
           if (!parser.seen_test('C')) {
             invalidate();
             SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
           }
-          if (param.V_verbosity > 1) {
-            SERIAL_ECHOPGM("Probing around (", param.XY_pos.x);
-            SERIAL_CHAR(',');
-            SERIAL_DECIMAL(param.XY_pos.y);
-            SERIAL_ECHOLNPGM(").\n");
-          }
+          if (param.V_verbosity > 1)
+            SERIAL_ECHOLN(F("Probing around ("), param.XY_pos.x, AS_CHAR(','), param.XY_pos.y, F(").\n"));
           probe_entire_mesh(param.XY_pos, parser.seen_test('T'), parser.seen_test('E'), parser.seen_test('U'));
 
           report_current_position();
           probe_deployed = true;
         } break;
 
       #endif // HAS_BED_PROBE
 
       case 2: {
         #if HAS_MARLINUI_MENU
@@ -715,24 +711,24 @@ void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const_float_t o
 
   //
   // Sum the squares of difference from mean
   //
   float sum_of_diff_squared = 0;
   GRID_LOOP(x, y)
     if (!isnan(z_values[x][y]))
       sum_of_diff_squared += sq(z_values[x][y] - mean);
 
   SERIAL_ECHOLNPGM("# of samples: ", n);
-  SERIAL_ECHOLNPAIR_F("Mean Mesh Height: ", mean, 6);
+  SERIAL_ECHOLNPGM("Mean Mesh Height: ", p_float_t(mean, 6));
 
   const float sigma = SQRT(sum_of_diff_squared / (n + 1));
-  SERIAL_ECHOLNPAIR_F("Standard Deviation: ", sigma, 6);
+  SERIAL_ECHOLNPGM("Standard Deviation: ", p_float_t(sigma, 6));
 
   if (cflag)
     GRID_LOOP(x, y)
       if (!isnan(z_values[x][y])) {
         z_values[x][y] -= mean + offset;
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
       }
 }
 
 /**
@@ -917,24 +913,22 @@ void set_message_with_feedback(FSTR_P const fstr) {
 
     SERIAL_ECHOPGM("Remove shim");
     LCD_MESSAGE(MSG_UBL_BC_REMOVE);
     echo_and_take_a_measurement();
 
     const float z2 = measure_point_with_encoder();
     do_z_clearance_by(Z_CLEARANCE_BETWEEN_PROBES);
 
     const float thickness = ABS(z1 - z2);
 
-    if (param.V_verbosity > 1) {
-      SERIAL_ECHOPAIR_F("Business Card is ", thickness, 4);
-      SERIAL_ECHOLNPGM("mm thick.");
-    }
+    if (param.V_verbosity > 1)
+      SERIAL_ECHOLNPGM("Business Card is ", p_float_t(thickness, 4), "mm thick.");
 
     restore_ubl_active_state_and_leave();
 
     return thickness;
   }
 
   /**
    * G29 P2 : Manually Probe Remaining Mesh Points.
    *          Move to INVALID points and
    *          NOTE: Blocks the G-code queue and captures Marlin UI during use.
@@ -986,21 +980,21 @@ void set_message_with_feedback(FSTR_P const fstr) {
         do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
       })) return restore_ubl_active_state_and_leave();
 
       // Store the Z position minus the shim height
       z_values[lpos.x][lpos.y] = current_position.z - thick;
 
       // Tell the external UI to update
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, z_values[lpos.x][lpos.y]));
 
       if (param.V_verbosity > 2)
-        SERIAL_ECHOLNPAIR_F("Mesh Point Measured at: ", z_values[lpos.x][lpos.y], 6);
+        SERIAL_ECHOLNPGM("Mesh Point Measured at: ", p_float_t(z_values[lpos.x][lpos.y], 6));
       SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
     } while (location.valid());
 
     if (do_ubl_mesh_map) display_map(param.T_map_type);  // show user where we're probing
 
     restore_ubl_active_state_and_leave();
     do_blocking_move_to_xy_z(pos, Z_CLEARANCE_DEPLOY_PROBE);
 
     TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
   }
@@ -1497,21 +1491,21 @@ void unified_bed_leveling::smart_fill_mesh() {
       for (uint8_t i = 0; i < 3; ++i) {
         SERIAL_ECHOLNPGM("Tilting mesh (", i + 1, "/3)");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/3"), GET_TEXT(MSG_LCD_TILTING_MESH), i + 1));
 
         measured_z = probe.probe_at_point(points[i], i < 2 ? PROBE_PT_RAISE : PROBE_PT_LAST_STOW, param.V_verbosity);
         if ((abort_flag = isnan(measured_z))) break;
 
         measured_z -= TERN(UBL_TILT_ON_MESH_POINTS_3POINT, z_values[cpos[i].pos.x][cpos[i].pos.y], get_z_correction(points[i]));
         TERN_(VALIDATE_MESH_TILT, gotz[i] = measured_z);
 
-        if (param.V_verbosity > 3) { serial_spaces(16); SERIAL_ECHOLNPGM("Corrected_Z=", measured_z); }
+        if (param.V_verbosity > 3) { SERIAL_ECHO_SP(16); SERIAL_ECHOLNPGM("Corrected_Z=", measured_z); }
 
         incremental_LSF(&lsf_results, points[i], measured_z);
       }
 
       probe.stow();
       probe.move_z_after_probing();
 
       if (abort_flag) {
         SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");
         return;
@@ -1555,145 +1549,119 @@ void unified_bed_leveling::smart_fill_mesh() {
           TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
 
           measured_z = probe.probe_at_point(rpos, parser.seen_test('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity); // TODO: Needs error handling
 
           if ((abort_flag = isnan(measured_z))) break;
 
           const float zcorr = TERN(UBL_TILT_ON_MESH_POINTS, z_values[cpos.pos.x][cpos.pos.y], get_z_correction(rpos));
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
-              const xy_pos_t lpos = rpos.asLogical();
               #if ENABLED(UBL_TILT_ON_MESH_POINTS)
                 const xy_pos_t oldLpos = oldRpos.asLogical();
-                DEBUG_ECHOPGM("Calculated point: ("); DEBUG_ECHO_F(oldRpos.x, 7); DEBUG_CHAR(','); DEBUG_ECHO_F(oldRpos.y, 7);
-                DEBUG_ECHOPAIR_F(")   logical: (", oldLpos.x, 7); DEBUG_CHAR(','); DEBUG_ECHO_F(oldLpos.y, 7);
-                DEBUG_ECHOPGM(")\nSelected mesh point: ");
+                DEBUG_ECHO(F("Calculated point: ("), p_float_t(oldRpos.x, 7), AS_CHAR(','), p_float_t(oldRpos.y, 7),
+                           F(")   logical: ("), p_float_t(oldLpos.x, 7), AS_CHAR(','), p_float_t(oldLpos.y, 7),
+                           F(")\nSelected mesh point: ")
+                );
               #endif
-              DEBUG_CHAR('('); DEBUG_ECHO_F(rpos.x, 7); DEBUG_CHAR(','); DEBUG_ECHO_F(rpos.y, 7);
-              DEBUG_ECHOPAIR_F(")  logical: (", lpos.x, 7); DEBUG_CHAR(','); DEBUG_ECHO_F(lpos.y, 7);
-              DEBUG_ECHOPAIR_F(")  measured: ", measured_z, 7);
-              DEBUG_ECHOPAIR_F("  correction: ", zcorr, 7);
+              const xy_pos_t lpos = rpos.asLogical();
+              DEBUG_ECHO(      AS_CHAR('('), p_float_t(rpos.x, 7), AS_CHAR(','), p_float_t(rpos.y, 7),
+                         F(")  logical: ("), p_float_t(lpos.x, 7), AS_CHAR(','), p_float_t(lpos.y, 7),
+                         F(")  measured: "), p_float_t(measured_z, 7),
+                         F("  correction: "), p_float_t(zcorr, 7)
+              );
             }
           #endif
 
           measured_z -= zcorr;
 
-          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("  final >>>---> ", measured_z, 7);
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("  final >>>---> ", p_float_t(measured_z, 7));
 
           if (param.V_verbosity > 3) {
-            serial_spaces(16);
+            SERIAL_ECHO_SP(16);
             SERIAL_ECHOLNPGM("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, rpos, measured_z);
 
           point_num++;
         }
 
         if (abort_flag) break;
         zig_zag ^= true;
       }
     }
     probe.stow();
     probe.move_z_after_probing();
 
     if (abort_flag || finish_incremental_LSF(&lsf_results)) {
-      SERIAL_ECHOPGM("Could not complete LSF!");
+      SERIAL_ECHOLNPGM("Could not complete LSF!");
       return;
     }
 
     vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1).get_normal();
 
-    if (param.V_verbosity > 2) {
-      SERIAL_ECHOPAIR_F("bed plane normal = [", normal.x, 7);
-      SERIAL_CHAR(',');
-      SERIAL_ECHO_F(normal.y, 7);
-      SERIAL_CHAR(',');
-      SERIAL_ECHO_F(normal.z, 7);
-      SERIAL_ECHOLNPGM("]");
-    }
+    if (param.V_verbosity > 2)
+      SERIAL_ECHOLN(F("bed plane normal = ["), p_float_t(normal.x, 7), AS_CHAR(','), p_float_t(normal.y, 7), AS_CHAR(','), p_float_t(normal.z, 7), AS_CHAR(']'));
 
     matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
 
     GRID_LOOP(i, j) {
       float mx = get_mesh_x(i), my = get_mesh_y(j), mz = z_values[i][j];
 
       if (DEBUGGING(LEVELING)) {
-        DEBUG_ECHOPAIR_F("before rotation = [", mx, 7);
-        DEBUG_CHAR(',');
-        DEBUG_ECHO_F(my, 7);
-        DEBUG_CHAR(',');
-        DEBUG_ECHO_F(mz, 7);
-        DEBUG_ECHOPGM("]   ---> ");
+        DEBUG_ECHOLN(F("before rotation = ["), p_float_t(mx, 7), AS_CHAR(','), p_float_t(my, 7), AS_CHAR(','), p_float_t(mz, 7), F("]   ---> "));
         DEBUG_DELAY(20);
       }
 
       rotation.apply_rotation_xyz(mx, my, mz);
 
       if (DEBUGGING(LEVELING)) {
-        DEBUG_ECHOPAIR_F("after rotation = [", mx, 7);
-        DEBUG_CHAR(',');
-        DEBUG_ECHO_F(my, 7);
-        DEBUG_CHAR(',');
-        DEBUG_ECHO_F(mz, 7);
-        DEBUG_ECHOLNPGM("]");
+        DEBUG_ECHOLN(F("after rotation = ["), p_float_t(mx, 7), AS_CHAR(','), p_float_t(my, 7), AS_CHAR(','), p_float_t(mz, 7), F("]   ---> "));
         DEBUG_DELAY(20);
       }
 
       z_values[i][j] = mz - lsf_results.D;
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(i, j, z_values[i][j]));
     }
 
     if (DEBUGGING(LEVELING)) {
       rotation.debug(F("rotation matrix:\n"));
-      DEBUG_ECHOPAIR_F("LSF Results A=", lsf_results.A, 7);
-      DEBUG_ECHOPAIR_F("  B=", lsf_results.B, 7);
-      DEBUG_ECHOLNPAIR_F("  D=", lsf_results.D, 7);
+      DEBUG_ECHOLN(F("LSF Results A="), p_float_t(lsf_results.A, 7), F("  B="), p_float_t(lsf_results.B, 7), F("  D="), p_float_t(lsf_results.D, 7));
       DEBUG_DELAY(55);
-
-      DEBUG_ECHOPAIR_F("bed plane normal = [", normal.x, 7);
-      DEBUG_CHAR(',');
-      DEBUG_ECHO_F(normal.y, 7);
-      DEBUG_CHAR(',');
-      DEBUG_ECHO_F(normal.z, 7);
-      DEBUG_ECHOLNPGM("]");
+      DEBUG_ECHOLN(F("bed plane normal = ["), p_float_t(normal.x, 7), AS_CHAR(','), p_float_t(normal.y, 7), AS_CHAR(','), p_float_t(normal.z, 7), AS_CHAR(']'));
       DEBUG_EOL();
 
       /**
        * Use the code below to check the validity of the mesh tilting algorithm.
        * 3-Point Mesh Tilt uses the same algorithm as grid-based tilting, but only
        * three points are used in the calculation. This guarantees that each probed point
        * has an exact match when get_z_correction() for that location is calculated.
        * The Z error between the probed point locations and the get_z_correction()
        * numbers for those locations should be 0.
        */
       #if ENABLED(VALIDATE_MESH_TILT)
         auto d_from = []{ DEBUG_ECHOPGM("D from "); };
         auto normed = [&](const xy_pos_t &pos, const_float_t zadd) {
           return normal.x * pos.x + normal.y * pos.y + zadd;
         };
         auto debug_pt = [](const int num, const xy_pos_t &pos, const_float_t zadd) {
-          d_from(); DEBUG_ECHOPGM("Point ", num, ":");
-          DEBUG_ECHO_F(normed(pos, zadd), 6);
-          DEBUG_ECHOLNPAIR_F("   Z error = ", zadd - get_z_correction(pos), 6);
+          d_from();
+          DEBUG_ECHOLN(F("Point "), num, AS_CHAR(':'), p_float_t(normed(pos, zadd), 6), F("   Z error = "), p_float_t(zadd - get_z_correction(pos), 6));
         };
         debug_pt(1, probe_pt[0], normal.z * gotz[0]);
         debug_pt(2, probe_pt[1], normal.z * gotz[1]);
         debug_pt(3, probe_pt[2], normal.z * gotz[2]);
         #if ENABLED(Z_SAFE_HOMING)
           constexpr xy_float_t safe_xy = { Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT };
-          d_from(); DEBUG_ECHOPGM("safe home with Z=");
-          DEBUG_ECHOLNPAIR_F("0 : ", normed(safe_xy, 0), 6);
-          d_from(); DEBUG_ECHOPGM("safe home with Z=");
-          DEBUG_ECHOLNPAIR_F("mesh value ", normed(safe_xy, get_z_correction(safe_xy)), 6);
-          DEBUG_ECHOPGM("   Z error = (", Z_SAFE_HOMING_X_POINT, ",", Z_SAFE_HOMING_Y_POINT);
-          DEBUG_ECHOLNPAIR_F(") = ", get_z_correction(safe_xy), 6);
+          d_from(); DEBUG_ECHOLN(F("safe home with Z="), F("0 : "), p_float_t(normed(safe_xy, 0), 6));
+          d_from(); DEBUG_ECHOLN(F("safe home with Z="), F("mesh value "), p_float_t(normed(safe_xy, get_z_correction(safe_xy)), 6));
+          DEBUG_ECHO(F("   Z error = ("), Z_SAFE_HOMING_X_POINT, AS_CHAR(','), Z_SAFE_HOMING_Y_POINT, F(") = "), p_float_t(get_z_correction(safe_xy), 6));
         #endif
       #endif
     } // DEBUGGING(LEVELING)
 
   }
 
 #endif // HAS_BED_PROBE
 
 #if ENABLED(UBL_G29_P31)
   void unified_bed_leveling::smart_fill_wlsf(const_float_t weight_factor) {
@@ -1727,109 +1695,104 @@ void unified_bed_leveling::smart_fill_mesh() {
             for (uint8_t jy = 0; jy < GRID_MAX_POINTS_Y; ++jy) {
               if (TEST(bitmap[jx], jy)) {
                 rpos.y = get_mesh_y(jy);
                 const float rz = z_values[jx][jy],
                              w = 1.0f + weight_scaled / (rpos - ppos).magnitude();
                 incremental_WLSF(&lsf_results, rpos, rz, w);
               }
             }
           }
           if (finish_incremental_LSF(&lsf_results)) {
-            SERIAL_ECHOLNPGM("Insufficient data");
+            SERIAL_ECHOLNPGM(" Insufficient data");
             return;
           }
           const float ez = -lsf_results.D - lsf_results.A * ppos.x - lsf_results.B * ppos.y;
           z_values[ix][iy] = ez;
           TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(ix, iy, z_values[ix][iy]));
           idle(); // housekeeping
         }
       }
     }
 
-    SERIAL_ECHOLNPGM("done");
+    SERIAL_ECHOLNPGM(" done.");
   }
 #endif // UBL_G29_P31
 
 #if ENABLED(UBL_DEVEL_DEBUGGING)
   /**
    * Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
    * good to have the extra information. Soon... we prune this to just a few items
    */
   void unified_bed_leveling::g29_what_command() {
     report_state();
 
     if (storage_slot == -1)
-      SERIAL_ECHOPGM("No Mesh Loaded.");
+      SERIAL_ECHOLNPGM("No Mesh Loaded.");
     else
-      SERIAL_ECHOPGM("Mesh ", storage_slot, " Loaded.");
-    SERIAL_EOL();
+      SERIAL_ECHOLNPGM("Mesh ", storage_slot, " Loaded.");
     serial_delay(50);
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      SERIAL_ECHOLNPAIR_F("Fade Height M420 Z", planner.z_fade_height, 4);
+      SERIAL_ECHOLN(F("Fade Height M420 Z"), p_float_t(planner.z_fade_height, 4));
     #endif
 
     adjust_mesh_to_mean(param.C_seen, param.C_constant);
 
     #if HAS_BED_PROBE
-      SERIAL_ECHOLNPAIR_F("Probe Offset M851 Z", probe.offset.z, 7);
+      SERIAL_ECHOLNPGM("Probe Offset M851 Z", p_float_t(probe.offset.z, 7));
     #endif
 
     SERIAL_ECHOLNPGM("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X); serial_delay(50);
     SERIAL_ECHOLNPGM("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); serial_delay(50);
     SERIAL_ECHOLNPGM("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); serial_delay(50);
     SERIAL_ECHOLNPGM("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); serial_delay(50);
     SERIAL_ECHOLNPGM("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             serial_delay(50);
     SERIAL_ECHOLNPGM("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);             serial_delay(50);
     SERIAL_ECHOLNPGM("MESH_X_DIST  ", MESH_X_DIST);
     SERIAL_ECHOLNPGM("MESH_Y_DIST  ", MESH_Y_DIST);                         serial_delay(50);
 
     SERIAL_ECHOPGM("X-Axis Mesh Points at: ");
     for (uint8_t i = 0; i < GRID_MAX_POINTS_X; ++i) {
-      SERIAL_ECHO_F(LOGICAL_X_POSITION(get_mesh_x(i)), 3);
-      SERIAL_ECHOPGM("  ");
+      SERIAL_ECHO(p_float_t(LOGICAL_X_POSITION(get_mesh_x(i)), 3), F("  "));
       serial_delay(25);
     }
     SERIAL_EOL();
 
     SERIAL_ECHOPGM("Y-Axis Mesh Points at: ");
     for (uint8_t i = 0; i < GRID_MAX_POINTS_Y; ++i) {
-      SERIAL_ECHO_F(LOGICAL_Y_POSITION(get_mesh_y(i)), 3);
-      SERIAL_ECHOPGM("  ");
+      SERIAL_ECHO(p_float_t(LOGICAL_Y_POSITION(get_mesh_y(i)), 3), F("  "));
       serial_delay(25);
     }
     SERIAL_EOL();
 
     #if HAS_KILL
       SERIAL_ECHOLNPGM("Kill pin on :", KILL_PIN, "  state:", kill_state());
     #endif
 
     SERIAL_EOL();
     serial_delay(50);
 
-    #if ENABLED(UBL_DEVEL_DEBUGGING)
-      SERIAL_ECHOLNPGM("ubl_state_at_invocation :", ubl_state_at_invocation, "\nubl_state_recursion_chk :", ubl_state_recursion_chk);
-      serial_delay(50);
+    SERIAL_ECHOLNPGM("ubl_state_at_invocation :", ubl_state_at_invocation, "\nubl_state_recursion_chk :", ubl_state_recursion_chk);
+    serial_delay(50);
 
-      SERIAL_ECHOLNPGM("Meshes go from ", hex_address((void*)settings.meshes_start_index()), " to ", hex_address((void*)settings.meshes_end_index()));
-      serial_delay(50);
+    SERIAL_ECHOLNPGM("Meshes go from ", hex_address((void*)settings.meshes_start_index()), " to ", hex_address((void*)settings.meshes_end_index()));
+    serial_delay(50);
 
-      SERIAL_ECHOLNPGM("sizeof(ubl) :  ", sizeof(ubl));         SERIAL_EOL();
-      SERIAL_ECHOLNPGM("z_value[][] size: ", sizeof(z_values)); SERIAL_EOL();
-      serial_delay(25);
+    SERIAL_ECHOLNPGM("sizeof(ubl) :  ", sizeof(ubl));         SERIAL_EOL();
+    SERIAL_ECHOLNPGM("z_value[][] size: ", sizeof(z_values)); SERIAL_EOL();
+    serial_delay(25);
 
-      SERIAL_ECHOLNPGM("EEPROM free for UBL: ", hex_address((void*)(settings.meshes_end_index() - settings.meshes_start_index())));
-      serial_delay(50);
+    SERIAL_ECHOLNPGM("EEPROM free for UBL: ", hex_address((void*)(settings.meshes_end_index() - settings.meshes_start_index())));
+    serial_delay(50);
 
-      SERIAL_ECHOLNPGM("EEPROM can hold ", settings.calc_num_meshes(), " meshes.\n");
-      serial_delay(25);
-    #endif // UBL_DEVEL_DEBUGGING
+    SERIAL_ECHOLNPGM("EEPROM can hold ", settings.calc_num_meshes(), " meshes.\n");
+    serial_delay(25);
 
     if (!sanity_check()) {
       echo_name();
       SERIAL_ECHOLNPGM(" sanity checks passed.");
     }
   }
 
   /**
    * When we are fully debugged, the EEPROM dump command will get deleted also. But
    * right now, it is good to have the extra information. Soon... we prune this.

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    🧑‍💻 Remove LOOP macros (#25917)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index ecbf76ec6e..551277c35d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -389,21 +389,21 @@ void unified_bed_leveling::G29() {
       case 0:
         GRID_LOOP(x, y) {                                     // Create a bowl shape similar to a poorly-calibrated Delta
           const float p1 = 0.5f * (GRID_MAX_POINTS_X) - x,
                       p2 = 0.5f * (GRID_MAX_POINTS_Y) - y;
           z_values[x][y] += 2.0f * HYPOT(p1, p2);
           TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
         }
         break;
 
       case 1:
-        LOOP_L_N(x, GRID_MAX_POINTS_X) {                     // Create a diagonal line several Mesh cells thick that is raised
+        for (uint8_t x = 0; x < GRID_MAX_POINTS_X; ++x) {                     // Create a diagonal line several Mesh cells thick that is raised
           const uint8_t x2 = x + (x < (GRID_MAX_POINTS_Y) - 1 ? 1 : -1);
           z_values[x][x] += 9.999f;
           z_values[x][x2] += 9.999f; // We want the altered line several mesh points thick
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(x, x, z_values[x][x]);
             ExtUI::onMeshUpdate(x, x2, z_values[x][x2]);
           #endif
         }
         break;
 
@@ -1438,21 +1438,21 @@ bool unified_bed_leveling::smart_fill_one(const uint8_t x, const uint8_t y, cons
 typedef struct { uint8_t sx, ex, sy, ey; bool yfirst; } smart_fill_info;
 
 void unified_bed_leveling::smart_fill_mesh() {
   static const smart_fill_info
     info0 PROGMEM = { 0, GRID_MAX_POINTS_X,       0, (GRID_MAX_POINTS_Y) - 2, false },  // Bottom of the mesh looking up
     info1 PROGMEM = { 0, GRID_MAX_POINTS_X,     (GRID_MAX_POINTS_Y) - 1, 0,   false },  // Top of the mesh looking down
     info2 PROGMEM = { 0, (GRID_MAX_POINTS_X) - 2, 0, GRID_MAX_POINTS_Y,       true  },  // Left side of the mesh looking right
     info3 PROGMEM = { (GRID_MAX_POINTS_X) - 1, 0, 0, GRID_MAX_POINTS_Y,       true  };  // Right side of the mesh looking left
   static const smart_fill_info * const info[] PROGMEM = { &info0, &info1, &info2, &info3 };
 
-  LOOP_L_N(i, COUNT(info)) {
+  for (uint8_t i = 0; i < COUNT(info); ++i) {
     const smart_fill_info *f = (smart_fill_info*)pgm_read_ptr(&info[i]);
     const int8_t sx = pgm_read_byte(&f->sx), sy = pgm_read_byte(&f->sy),
                  ex = pgm_read_byte(&f->ex), ey = pgm_read_byte(&f->ey);
     if (pgm_read_byte(&f->yfirst)) {
       const int8_t dir = ex > sx ? 1 : -1;
       for (uint8_t y = sy; y != ey; ++y)
         for (uint8_t x = sx; x != ex; x += dir)
           if (smart_fill_one(x, y, dir, 0)) break;
     }
     else {
@@ -1477,31 +1477,31 @@ void unified_bed_leveling::smart_fill_mesh() {
 
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
 
     if (do_3_pt_leveling) {
       xy_float_t points[3];
       probe.get_three_points(points);
 
       #if ENABLED(UBL_TILT_ON_MESH_POINTS_3POINT)
         mesh_index_pair cpos[3];
-        LOOP_L_N(ix, 3) { // Convert points to coordinates of mesh points
+        for (uint8_t ix = 0; ix < 3; ++ix) { // Convert points to coordinates of mesh points
           cpos[ix] = find_closest_mesh_point_of_type(REAL, points[ix], true);
           points[ix] = cpos[ix].meshpos();
         }
       #endif
 
       #if ENABLED(VALIDATE_MESH_TILT)
         float gotz[3];  // Used for algorithm validation below
       #endif
 
-      LOOP_L_N(i, 3) {
+      for (uint8_t i = 0; i < 3; ++i) {
         SERIAL_ECHOLNPGM("Tilting mesh (", i + 1, "/3)");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/3"), GET_TEXT(MSG_LCD_TILTING_MESH), i + 1));
 
         measured_z = probe.probe_at_point(points[i], i < 2 ? PROBE_PT_RAISE : PROBE_PT_LAST_STOW, param.V_verbosity);
         if ((abort_flag = isnan(measured_z))) break;
 
         measured_z -= TERN(UBL_TILT_ON_MESH_POINTS_3POINT, z_values[cpos[i].pos.x][cpos[i].pos.y], get_z_correction(points[i]));
         TERN_(VALIDATE_MESH_TILT, gotz[i] = measured_z);
 
         if (param.V_verbosity > 3) { serial_spaces(16); SERIAL_ECHOLNPGM("Corrected_Z=", measured_z); }
@@ -1527,24 +1527,24 @@ void unified_bed_leveling::smart_fill_mesh() {
                   y_min = _MAX((Y_MIN_POS) + (G29J_MESH_TILT_MARGIN), MESH_MIN_Y, probe.min_y()),
                   y_max = _MIN((Y_MAX_POS) - (G29J_MESH_TILT_MARGIN), MESH_MAX_Y, probe.max_y()),
                   dx = (x_max - x_min) / (param.J_grid_size - 1),
                   dy = (y_max - y_min) / (param.J_grid_size - 1);
 
       bool zig_zag = false;
 
       const uint16_t total_points = sq(param.J_grid_size);
       uint16_t point_num = 1;
 
-      LOOP_L_N(ix, param.J_grid_size) {
+      for (uint8_t ix = 0; ix < param.J_grid_size; ++ix) {
         xy_pos_t rpos;
         rpos.x = x_min + ix * dx;
-        LOOP_L_N(iy, param.J_grid_size) {
+        for (uint8_t iy = 0; iy < param.J_grid_size; ++iy) {
           rpos.y = y_min + dy * (zig_zag ? param.J_grid_size - 1 - iy : iy);
 
           #if ENABLED(UBL_TILT_ON_MESH_POINTS)
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               xy_pos_t oldRpos;
               if (DEBUGGING(LEVELING)) oldRpos = rpos;
             #endif
             mesh_index_pair cpos;
             rpos -= probe.offset;
             cpos = find_closest_mesh_point_of_type(REAL, rpos, true);
@@ -1707,31 +1707,31 @@ void unified_bed_leveling::smart_fill_mesh() {
     uint16_t bitmap[GRID_MAX_POINTS_X] = { 0 };
     struct linear_fit_data lsf_results;
 
     SERIAL_ECHOPGM("Extrapolating mesh...");
 
     const float weight_scaled = weight_factor * _MAX(MESH_X_DIST, MESH_Y_DIST);
 
     GRID_LOOP(jx, jy) if (!isnan(z_values[jx][jy])) SBI(bitmap[jx], jy);
 
     xy_pos_t ppos;
-    LOOP_L_N(ix, GRID_MAX_POINTS_X) {
+    for (uint8_t ix = 0; ix < GRID_MAX_POINTS_X; ++ix) {
       ppos.x = get_mesh_x(ix);
-      LOOP_L_N(iy, GRID_MAX_POINTS_Y) {
+      for (uint8_t iy = 0; iy < GRID_MAX_POINTS_Y; ++iy) {
         ppos.y = get_mesh_y(iy);
         if (isnan(z_values[ix][iy])) {
           // undefined mesh point at (ppos.x,ppos.y), compute weighted LSF from original valid mesh points.
           incremental_LSF_reset(&lsf_results);
           xy_pos_t rpos;
-          LOOP_L_N(jx, GRID_MAX_POINTS_X) {
+          for (uint8_t jx = 0; jx < GRID_MAX_POINTS_X; ++jx) {
             rpos.x = get_mesh_x(jx);
-            LOOP_L_N(jy, GRID_MAX_POINTS_Y) {
+            for (uint8_t jy = 0; jy < GRID_MAX_POINTS_Y; ++jy) {
               if (TEST(bitmap[jx], jy)) {
                 rpos.y = get_mesh_y(jy);
                 const float rz = z_values[jx][jy],
                              w = 1.0f + weight_scaled / (rpos - ppos).magnitude();
                 incremental_WLSF(&lsf_results, rpos, rz, w);
               }
             }
           }
           if (finish_incremental_LSF(&lsf_results)) {
             SERIAL_ECHOLNPGM("Insufficient data");
@@ -1777,29 +1777,29 @@ void unified_bed_leveling::smart_fill_mesh() {
     SERIAL_ECHOLNPGM("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X); serial_delay(50);
     SERIAL_ECHOLNPGM("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); serial_delay(50);
     SERIAL_ECHOLNPGM("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); serial_delay(50);
     SERIAL_ECHOLNPGM("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); serial_delay(50);
     SERIAL_ECHOLNPGM("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             serial_delay(50);
     SERIAL_ECHOLNPGM("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);             serial_delay(50);
     SERIAL_ECHOLNPGM("MESH_X_DIST  ", MESH_X_DIST);
     SERIAL_ECHOLNPGM("MESH_Y_DIST  ", MESH_Y_DIST);                         serial_delay(50);
 
     SERIAL_ECHOPGM("X-Axis Mesh Points at: ");
-    LOOP_L_N(i, GRID_MAX_POINTS_X) {
+    for (uint8_t i = 0; i < GRID_MAX_POINTS_X; ++i) {
       SERIAL_ECHO_F(LOGICAL_X_POSITION(get_mesh_x(i)), 3);
       SERIAL_ECHOPGM("  ");
       serial_delay(25);
     }
     SERIAL_EOL();
 
     SERIAL_ECHOPGM("Y-Axis Mesh Points at: ");
-    LOOP_L_N(i, GRID_MAX_POINTS_Y) {
+    for (uint8_t i = 0; i < GRID_MAX_POINTS_Y; ++i) {
       SERIAL_ECHO_F(LOGICAL_Y_POSITION(get_mesh_y(i)), 3);
       SERIAL_ECHOPGM("  ");
       serial_delay(25);
     }
     SERIAL_EOL();
 
     #if HAS_KILL
       SERIAL_ECHOLNPGM("Kill pin on :", KILL_PIN, "  state:", kill_state());
     #endif
 

commit 060ddf5e950b104b00f5d20adf858a9ad00ab72e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 16 02:52:52 2023 -0500

    🚸 Support Bed Leveling Mesh > 16x16
    
    Co-Authored-By: raTmole <ratmole@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 2fbd3bfbeb..ecbf76ec6e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -344,21 +344,21 @@ void unified_bed_leveling::G29() {
       #ifdef SAFE_BED_LEVELING_START_W
         safe_position.w = SAFE_BED_LEVELING_START_W;
       #endif
 
       do_blocking_move_to(safe_position);
     #endif // HAS_SAFE_BED_LEVELING
   }
 
   // Invalidate one or more nearby mesh points, possibly all.
   if (parser.seen('I')) {
-    uint8_t count = parser.has_value() ? parser.value_byte() : 1;
+    grid_count_t count = parser.has_value() ? parser.value_ushort() : 1;
     bool invalidate_all = count >= GRID_MAX_POINTS;
     if (!invalidate_all) {
       while (count--) {
         if ((count & 0x0F) == 0x0F) idle();
         const mesh_index_pair closest = find_closest_mesh_point_of_type(REAL, param.XY_pos);
         // No more REAL mesh points to invalidate? Assume the user meant
         // to invalidate the ENTIRE mesh, which can't be done with
         // find_closest_mesh_point (which only returns REAL points).
         if (closest.pos.x < 0) { invalidate_all = true; break; }
         z_values[closest.pos.x][closest.pos.y] = NAN;
@@ -753,28 +753,28 @@ void unified_bed_leveling::shift_mesh_height() {
    *   This attempts to fill in locations closest to the nozzle's start location first.
    */
   void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &nearby, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
     probe.deploy(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
 
     TERN_(HAS_MARLINUI_MENU, ui.capture());
     TERN_(EXTENSIBLE_UI, ExtUI::onLevelingStart());
     TERN_(DWIN_LCD_PROUI, DWIN_LevelingStart());
 
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
-    uint8_t count = GRID_MAX_POINTS;
+    grid_count_t count = GRID_MAX_POINTS;
 
     mesh_index_pair best;
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_START));
     do {
       if (do_ubl_mesh_map) display_map(param.T_map_type);
 
-      const uint8_t point_num = (GRID_MAX_POINTS - count) + 1;
+      const grid_count_t point_num = (GRID_MAX_POINTS - count) + 1;
       SERIAL_ECHOLNPGM("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
       TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), point_num, int(GRID_MAX_POINTS)));
 
       #if HAS_MARLINUI_MENU
         if (ui.button_pressed()) {
           ui.quick_feedback(false); // Preserve button state for click-and-hold
           SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
@@ -1128,21 +1128,21 @@ void set_message_with_feedback(FSTR_P const fstr) {
  */
 bool unified_bed_leveling::G29_parse_parameters() {
   bool err_flag = false;
 
   set_message_with_feedback(GET_TEXT_F(MSG_UBL_DOING_G29));
 
   param.C_constant = 0;
   param.R_repetition = 0;
 
   if (parser.seen('R')) {
-    param.R_repetition = parser.has_value() ? parser.value_byte() : GRID_MAX_POINTS;
+    param.R_repetition = parser.has_value() ? parser.value_ushort() : GRID_MAX_POINTS;
     NOMORE(param.R_repetition, GRID_MAX_POINTS);
     if (param.R_repetition < 1) {
       SERIAL_ECHOLNPGM("?(R)epetition count invalid (1+).\n");
       return UBL_ERR;
     }
   }
 
   param.V_verbosity = parser.byteval('V');
   if (!WITHIN(param.V_verbosity, 0, 4)) {
     SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-4).\n");

commit c5a2e41647a12ef16b280975ab713e080e831e46
Author: James Pearson <jamespearson04@hotmail.co.uk>
Date:   Fri Apr 28 23:30:15 2023 +0100

    🐛 Probe behavior corrections (#25631)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: David Fries <2767875+dfries@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 7277b293aa..2fbd3bfbeb 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -105,21 +105,21 @@
  *   E     Stow_probe Stow the probe after each sampled point.
  *
  *   F #   Fade       Fade the amount of Mesh Based Compensation over a specified height. At the
  *                    specified height, no correction is applied and natural printer kenimatics take over. If no
  *                    number is specified for the command, 10mm is assumed to be reasonable.
  *
  *   H #   Height     With P2, 'H' specifies the Height to raise the nozzle after each manual probe of the bed.
  *                    If omitted, the nozzle will raise by Z_CLEARANCE_BETWEEN_PROBES.
  *
  *   H #   Offset     With P4, 'H' specifies the Offset above the mesh height to place the nozzle.
- *                    If omitted, Z_CLEARANCE_BETWEEN_PROBES will be used.
+ *                    If omitted, Z_TWEEN_SAFE_CLEARANCE will be used.
  *
  *   I #   Invalidate Invalidate the specified number of Mesh Points near the given 'X' 'Y'. If X or Y are omitted,
  *                    the nozzle location is used. If no 'I' value is given, only the point nearest to the location
  *                    is invalidated. Use 'T' to produce a map afterward. This command is useful to invalidate a
  *                    portion of the Mesh so it can be adjusted using other UBL tools. When attempting to invalidate
  *                    an isolated bad mesh point, the 'T' option shows the nozzle position in the Mesh with (#). You
  *                    can move the nozzle around and use this feature to select the center of the area (or cell) to
  *                    invalidate.
  *
  *   J #   Grid       Perform a Grid Based Leveling of the current Mesh using a grid with n points on a side.
@@ -783,24 +783,21 @@ void unified_bed_leveling::shift_mesh_height() {
           return restore_ubl_active_state_and_leave();
         }
       #endif
 
       best = do_furthest
         ? find_furthest_invalid_mesh_point()
         : find_closest_mesh_point_of_type(INVALID, nearby, true);
 
       if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_POINT_START));
-        const float measured_z = probe.probe_at_point(
-                      best.meshpos(),
-                      stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity
-                    );
+        const float measured_z = probe.probe_at_point(best.meshpos(), stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity);
         z_values[best.pos.x][best.pos.y] = measured_z;
         #if ENABLED(EXTENSIBLE_UI)
           ExtUI::onMeshUpdate(best.pos, ExtUI::G29_POINT_FINISH);
           ExtUI::onMeshUpdate(best.pos, measured_z);
         #endif
       }
       SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
 
     } while (best.pos.x >= 0 && --count);
 
@@ -1027,50 +1024,50 @@ void set_message_with_feedback(FSTR_P const fstr) {
     mesh_index_pair location;
 
     if (!position_is_reachable(pos)) {
       SERIAL_ECHOLNPGM("(X,Y) outside printable radius.");
       return;
     }
 
     save_ubl_active_state_and_disable();
 
     LCD_MESSAGE(MSG_UBL_FINE_TUNE_MESH);
-    ui.capture();                                               // Take over control of the LCD encoder
+    ui.capture();                                         // Take over control of the LCD encoder
 
-    do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES);  // Move to the given XY with probe clearance
+    do_blocking_move_to_xy_z(pos, Z_TWEEN_SAFE_CLEARANCE);  // Move to the given XY with probe clearance
 
     MeshFlags done_flags{0};
     const xy_int8_t &lpos = location.pos;
 
     #if IS_TFTGLCD_PANEL
       ui.ubl_mesh_edit_start(0);                          // Change current screen before calling ui.ubl_plot
       safe_delay(50);
     #endif
 
     do {
       location = find_closest_mesh_point_of_type(SET_IN_BITMAP, pos, false, &done_flags);
 
       if (lpos.x < 0) break;                              // Stop when there are no more reachable points
 
       done_flags.mark(lpos);                              // Mark this location as 'adjusted' so a new
                                                           // location is used on the next loop
-      const xyz_pos_t raw = { get_mesh_x(lpos.x), get_mesh_y(lpos.y), Z_CLEARANCE_BETWEEN_PROBES };
+      const xyz_pos_t raw = { get_mesh_x(lpos.x), get_mesh_y(lpos.y), Z_TWEEN_SAFE_CLEARANCE };
 
       if (!position_is_reachable(raw)) break;             // SHOULD NOT OCCUR (find_closest_mesh_point_of_type only returns reachable)
 
       do_blocking_move_to(raw);                           // Move the nozzle to the edit point with probe clearance
 
       TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset)); // Move Z to the given 'H' offset before editing
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
 
-      if (do_ubl_mesh_map) display_map(param.T_map_type);     // Display the current point
+      if (do_ubl_mesh_map) display_map(param.T_map_type); // Display the current point
 
       #if IS_TFTGLCD_PANEL
         ui.ubl_plot(lpos.x, lpos.y);   // update plot screen
       #endif
 
       ui.refresh();
 
       float new_z = z_values[lpos.x][lpos.y];
       if (isnan(new_z)) new_z = 0;                        // Invalid points begin at 0
       new_z = FLOOR(new_z * 1000) * 0.001f;               // Chop off digits after the 1000ths place
@@ -1086,41 +1083,41 @@ void set_message_with_feedback(FSTR_P const fstr) {
         SERIAL_FLUSH();                                   // Prevent host M105 buffer overrun.
       } while (!ui.button_pressed());
 
       SET_SOFT_ENDSTOP_LOOSE(false);
 
       if (!lcd_map_control) ui.return_to_status();        // Just editing a single point? Return to status
 
       // Button held down? Abort editing
       if (_click_and_hold([]{
         ui.return_to_status();
-        do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
+        do_z_clearance(Z_TWEEN_SAFE_CLEARANCE);
         set_message_with_feedback(GET_TEXT_F(MSG_EDITING_STOPPED));
       })) break;
 
       // TODO: Disable leveling here so the Z value becomes the 'native' Z value.
 
       z_values[lpos.x][lpos.y] = new_z;                   // Save the updated Z value
 
       // TODO: Re-enable leveling here so Z is correctly based on the updated mesh.
 
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, new_z));
 
       serial_delay(20);                                   // No switch noise
       ui.refresh();
 
     } while (lpos.x >= 0 && --param.R_repetition > 0);
 
     if (do_ubl_mesh_map) display_map(param.T_map_type);
     restore_ubl_active_state_and_leave();
 
-    do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES);
+    do_blocking_move_to_xy_z(pos, Z_TWEEN_SAFE_CLEARANCE);
 
     LCD_MESSAGE(MSG_UBL_DONE_EDITING_MESH);
     SERIAL_ECHOLNPGM("Done Editing Mesh");
 
     if (lcd_map_control)
       ui.goto_screen(ubl_map_screen);
     else
       ui.return_to_status();
   }
 

commit aaf55a21ad9fa0f72e166b4b3f74fda427ccf91f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 23 02:07:42 2023 -0500

    🩹 Fix UBL safe measure move with extra axes
    
    Followup to 7e79fc5b

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 5bc5e6ec61..7277b293aa 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -876,21 +876,21 @@ void set_message_with_feedback(FSTR_P const fstr) {
     return current_position.z;
   }
 
   static void echo_and_take_a_measurement() { SERIAL_ECHOLNPGM(" and take a measurement."); }
 
   float unified_bed_leveling::measure_business_card_thickness() {
     ui.capture();
     save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
     do_blocking_move_to(
-      NUM_AXIS_LIST(
+      xyz_pos_t({
         0.5f * ((MESH_MAX_X) - (MESH_MIN_X)),
         0.5f * ((MESH_MAX_Y) - (MESH_MIN_Y)),
         MANUAL_PROBE_START_Z
         #ifdef SAFE_BED_LEVELING_START_I
           , SAFE_BED_LEVELING_START_I
         #endif
         #ifdef SAFE_BED_LEVELING_START_J
           , SAFE_BED_LEVELING_START_J
         #endif
         #ifdef SAFE_BED_LEVELING_START_K
@@ -898,21 +898,21 @@ void set_message_with_feedback(FSTR_P const fstr) {
         #endif
         #ifdef SAFE_BED_LEVELING_START_U
           , SAFE_BED_LEVELING_START_U
         #endif
         #ifdef SAFE_BED_LEVELING_START_V
           , SAFE_BED_LEVELING_START_V
         #endif
         #ifdef SAFE_BED_LEVELING_START_W
           , SAFE_BED_LEVELING_START_W
         #endif
-      )
+      })
       //, _MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f
     );
     planner.synchronize();
 
     SERIAL_ECHOPGM("Place shim under nozzle");
     LCD_MESSAGE(MSG_UBL_BC_INSERT);
     ui.return_to_status();
     echo_and_take_a_measurement();
 
     const float z1 = measure_point_with_encoder();

commit 2fcc140c0d4353149c24fa8a3845b417738d7620
Author: XDA-Bam <1209896+XDA-Bam@users.noreply.github.com>
Date:   Sun Apr 16 05:26:46 2023 +0200

    🩹 Fix 'G29 J' status message (#25677)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index a6206b398e..5bc5e6ec61 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1492,21 +1492,21 @@ void unified_bed_leveling::smart_fill_mesh() {
           points[ix] = cpos[ix].meshpos();
         }
       #endif
 
       #if ENABLED(VALIDATE_MESH_TILT)
         float gotz[3];  // Used for algorithm validation below
       #endif
 
       LOOP_L_N(i, 3) {
         SERIAL_ECHOLNPGM("Tilting mesh (", i + 1, "/3)");
-        TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/3"), i + 1, GET_TEXT(MSG_LCD_TILTING_MESH)));
+        TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/3"), GET_TEXT(MSG_LCD_TILTING_MESH), i + 1));
 
         measured_z = probe.probe_at_point(points[i], i < 2 ? PROBE_PT_RAISE : PROBE_PT_LAST_STOW, param.V_verbosity);
         if ((abort_flag = isnan(measured_z))) break;
 
         measured_z -= TERN(UBL_TILT_ON_MESH_POINTS_3POINT, z_values[cpos[i].pos.x][cpos[i].pos.y], get_z_correction(points[i]));
         TERN_(VALIDATE_MESH_TILT, gotz[i] = measured_z);
 
         if (param.V_verbosity > 3) { serial_spaces(16); SERIAL_ECHOLNPGM("Corrected_Z=", measured_z); }
 
         incremental_LSF(&lsf_results, points[i], measured_z);

commit f53217b2c5bf7d61d21ee6784ec251bc7a670eb3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 11 18:43:01 2023 -0500

    🧑‍💻 Probe flag in do_z_clearance

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index d9205b7577..a6206b398e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -909,29 +909,28 @@ void set_message_with_feedback(FSTR_P const fstr) {
       //, _MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f
     );
     planner.synchronize();
 
     SERIAL_ECHOPGM("Place shim under nozzle");
     LCD_MESSAGE(MSG_UBL_BC_INSERT);
     ui.return_to_status();
     echo_and_take_a_measurement();
 
     const float z1 = measure_point_with_encoder();
-    do_blocking_move_to_z(current_position.z + SIZE_OF_LITTLE_RAISE);
-    planner.synchronize();
+    do_z_clearance_by(SIZE_OF_LITTLE_RAISE);
 
     SERIAL_ECHOPGM("Remove shim");
     LCD_MESSAGE(MSG_UBL_BC_REMOVE);
     echo_and_take_a_measurement();
 
     const float z2 = measure_point_with_encoder();
-    do_blocking_move_to_z(current_position.z + Z_CLEARANCE_BETWEEN_PROBES);
+    do_z_clearance_by(Z_CLEARANCE_BETWEEN_PROBES);
 
     const float thickness = ABS(z1 - z2);
 
     if (param.V_verbosity > 1) {
       SERIAL_ECHOPAIR_F("Business Card is ", thickness, 4);
       SERIAL_ECHOLNPGM("mm thick.");
     }
 
     restore_ubl_active_state_and_leave();
 

commit 06cfd9c54af1537adf458a719b840cd501395278
Author: John Lagonikas <39417467+zeleps@users.noreply.github.com>
Date:   Wed Mar 22 02:15:51 2023 +0200

    ✨ PROBING_TOOL (#24411)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 7b9783bfac..d9205b7577 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -299,30 +299,27 @@
 
 G29_parameters_t unified_bed_leveling::param;
 
 void unified_bed_leveling::G29() {
 
   bool probe_deployed = false;
   if (G29_parse_parameters()) return; // Abort on parameter error
 
   const uint8_t p_val = parser.byteval('P');
   const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen_test('J');
-  #if HAS_MULTI_HOTEND
-    const uint8_t old_tool_index = active_extruder;
-  #endif
 
   // Check for commands that require the printer to be homed
   if (may_move) {
     planner.synchronize();
     // Send 'N' to force homing before G29 (internal only)
     if (axes_should_home() || parser.seen_test('N')) gcode.home_all_axes();
-    TERN_(HAS_MULTI_HOTEND, if (active_extruder != 0) tool_change(0, true));
+    probe.use_probing_tool();
 
     // Position bed horizontally and Z probe vertically.
     #if HAS_SAFE_BED_LEVELING
       xyze_pos_t safe_position = current_position;
       #ifdef SAFE_BED_LEVELING_START_X
         safe_position.x = SAFE_BED_LEVELING_START_X;
       #endif
       #ifdef SAFE_BED_LEVELING_START_Y
         safe_position.y = SAFE_BED_LEVELING_START_Y;
       #endif
@@ -689,21 +686,21 @@ void unified_bed_leveling::G29() {
   #ifdef Z_PROBE_END_SCRIPT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     if (probe_deployed) {
       planner.synchronize();
       gcode.process_subcommands_now(F(Z_PROBE_END_SCRIPT));
     }
   #else
     UNUSED(probe_deployed);
   #endif
 
-  TERN_(HAS_MULTI_HOTEND, if (old_tool_index != 0) tool_change(old_tool_index));
+  probe.use_probing_tool(false);
   return;
 }
 
 /**
  * M420 C<value>
  * G29 P5 C<value> : Adjust Mesh To Mean (and subtract the given offset).
  *                   Find the mean average and shift the mesh to center on that value.
  */
 void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const_float_t offset) {
   float sum = 0;

commit 89e8257008507821543af8811ab78ef0365b2741
Author: jamespearson04 <jamespearson04@hotmail.co.uk>
Date:   Fri Mar 17 01:06:55 2023 +0000

    🚸 Refinements for UBL G29 J (tilt mesh) (#25486)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index e504379848..7b9783bfac 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1482,84 +1482,107 @@ void unified_bed_leveling::smart_fill_mesh() {
     float measured_z;
     bool abort_flag = false;
 
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
 
     if (do_3_pt_leveling) {
       xy_float_t points[3];
       probe.get_three_points(points);
 
+      #if ENABLED(UBL_TILT_ON_MESH_POINTS_3POINT)
+        mesh_index_pair cpos[3];
+        LOOP_L_N(ix, 3) { // Convert points to coordinates of mesh points
+          cpos[ix] = find_closest_mesh_point_of_type(REAL, points[ix], true);
+          points[ix] = cpos[ix].meshpos();
+        }
+      #endif
+
       #if ENABLED(VALIDATE_MESH_TILT)
         float gotz[3];  // Used for algorithm validation below
       #endif
 
       LOOP_L_N(i, 3) {
         SERIAL_ECHOLNPGM("Tilting mesh (", i + 1, "/3)");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/3"), i + 1, GET_TEXT(MSG_LCD_TILTING_MESH)));
 
         measured_z = probe.probe_at_point(points[i], i < 2 ? PROBE_PT_RAISE : PROBE_PT_LAST_STOW, param.V_verbosity);
         if ((abort_flag = isnan(measured_z))) break;
 
-        measured_z -= get_z_correction(points[i]);
+        measured_z -= TERN(UBL_TILT_ON_MESH_POINTS_3POINT, z_values[cpos[i].pos.x][cpos[i].pos.y], get_z_correction(points[i]));
         TERN_(VALIDATE_MESH_TILT, gotz[i] = measured_z);
 
         if (param.V_verbosity > 3) { serial_spaces(16); SERIAL_ECHOLNPGM("Corrected_Z=", measured_z); }
 
         incremental_LSF(&lsf_results, points[i], measured_z);
       }
 
       probe.stow();
       probe.move_z_after_probing();
 
       if (abort_flag) {
         SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");
         return;
       }
     }
     else { // !do_3_pt_leveling
 
-      #ifdef G29J_MESH_TILT_MARGIN
-        const float x_min = _MAX(probe.min_x() + (G29J_MESH_TILT_MARGIN), X_MIN_POS),
-                    x_max = _MIN(probe.max_x() - (G29J_MESH_TILT_MARGIN), X_MAX_POS),
-                    y_min = _MAX(probe.min_y() + (G29J_MESH_TILT_MARGIN), Y_MIN_POS),
-                    y_max = _MIN(probe.max_y() - (G29J_MESH_TILT_MARGIN), Y_MAX_POS);
-      #else
-        const float x_min = probe.min_x(), x_max = probe.max_x(),
-                    y_min = probe.min_y(), y_max = probe.max_y();
+      #ifndef G29J_MESH_TILT_MARGIN
+        #define G29J_MESH_TILT_MARGIN 0
       #endif
-      const float dx = (x_max - x_min) / (param.J_grid_size - 1),
+      const float x_min = _MAX((X_MIN_POS) + (G29J_MESH_TILT_MARGIN), MESH_MIN_X, probe.min_x()),
+                  x_max = _MIN((X_MAX_POS) - (G29J_MESH_TILT_MARGIN), MESH_MAX_X, probe.max_x()),
+                  y_min = _MAX((Y_MIN_POS) + (G29J_MESH_TILT_MARGIN), MESH_MIN_Y, probe.min_y()),
+                  y_max = _MIN((Y_MAX_POS) - (G29J_MESH_TILT_MARGIN), MESH_MAX_Y, probe.max_y()),
+                  dx = (x_max - x_min) / (param.J_grid_size - 1),
                   dy = (y_max - y_min) / (param.J_grid_size - 1);
 
       bool zig_zag = false;
 
       const uint16_t total_points = sq(param.J_grid_size);
       uint16_t point_num = 1;
 
       LOOP_L_N(ix, param.J_grid_size) {
         xy_pos_t rpos;
         rpos.x = x_min + ix * dx;
         LOOP_L_N(iy, param.J_grid_size) {
           rpos.y = y_min + dy * (zig_zag ? param.J_grid_size - 1 - iy : iy);
 
+          #if ENABLED(UBL_TILT_ON_MESH_POINTS)
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              xy_pos_t oldRpos;
+              if (DEBUGGING(LEVELING)) oldRpos = rpos;
+            #endif
+            mesh_index_pair cpos;
+            rpos -= probe.offset;
+            cpos = find_closest_mesh_point_of_type(REAL, rpos, true);
+            rpos = cpos.meshpos();
+          #endif
+
           SERIAL_ECHOLNPGM("Tilting mesh point ", point_num, "/", total_points, "\n");
           TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
 
           measured_z = probe.probe_at_point(rpos, parser.seen_test('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity); // TODO: Needs error handling
 
           if ((abort_flag = isnan(measured_z))) break;
 
-          const float zcorr = get_z_correction(rpos);
+          const float zcorr = TERN(UBL_TILT_ON_MESH_POINTS, z_values[cpos.pos.x][cpos.pos.y], get_z_correction(rpos));
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               const xy_pos_t lpos = rpos.asLogical();
+              #if ENABLED(UBL_TILT_ON_MESH_POINTS)
+                const xy_pos_t oldLpos = oldRpos.asLogical();
+                DEBUG_ECHOPGM("Calculated point: ("); DEBUG_ECHO_F(oldRpos.x, 7); DEBUG_CHAR(','); DEBUG_ECHO_F(oldRpos.y, 7);
+                DEBUG_ECHOPAIR_F(")   logical: (", oldLpos.x, 7); DEBUG_CHAR(','); DEBUG_ECHO_F(oldLpos.y, 7);
+                DEBUG_ECHOPGM(")\nSelected mesh point: ");
+              #endif
               DEBUG_CHAR('('); DEBUG_ECHO_F(rpos.x, 7); DEBUG_CHAR(','); DEBUG_ECHO_F(rpos.y, 7);
               DEBUG_ECHOPAIR_F(")  logical: (", lpos.x, 7); DEBUG_CHAR(','); DEBUG_ECHO_F(lpos.y, 7);
               DEBUG_ECHOPAIR_F(")  measured: ", measured_z, 7);
               DEBUG_ECHOPAIR_F("  correction: ", zcorr, 7);
             }
           #endif
 
           measured_z -= zcorr;
 
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("  final >>>---> ", measured_z, 7);

commit 507c122fcff686bc83d6c8b06bc05f3bf01bcc73
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 15 22:21:03 2023 -0500

    ♻️ Refactor UBL 'G29 J'

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 02efb3e065..e504379848 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1472,156 +1472,115 @@ void unified_bed_leveling::smart_fill_mesh() {
 }
 
 #if HAS_BED_PROBE
 
   //#define VALIDATE_MESH_TILT
 
   #include "../../../libs/vector_3.h"
 
   void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
 
-    #ifdef G29J_MESH_TILT_MARGIN
-      const float x_min = _MAX(probe.min_x() + (G29J_MESH_TILT_MARGIN), X_MIN_POS),
-                  x_max = _MIN(probe.max_x() - (G29J_MESH_TILT_MARGIN), X_MAX_POS),
-                  y_min = _MAX(probe.min_y() + (G29J_MESH_TILT_MARGIN), Y_MIN_POS),
-                  y_max = _MIN(probe.max_y() - (G29J_MESH_TILT_MARGIN), Y_MAX_POS);
-    #else
-      const float x_min = probe.min_x(), x_max = probe.max_x(),
-                  y_min = probe.min_y(), y_max = probe.max_y();
-    #endif
-    const float dx = (x_max - x_min) / (param.J_grid_size - 1),
-                dy = (y_max - y_min) / (param.J_grid_size - 1);
-
-    xy_float_t points[3];
-    probe.get_three_points(points);
-
     float measured_z;
     bool abort_flag = false;
 
-    #if ENABLED(VALIDATE_MESH_TILT)
-      float z1, z2, z3;  // Needed for algorithm validation below
-    #endif
-
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
 
     if (do_3_pt_leveling) {
-      SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
-      TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " 1/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
+      xy_float_t points[3];
+      probe.get_three_points(points);
 
-      measured_z = probe.probe_at_point(points[0], PROBE_PT_RAISE, param.V_verbosity);
-      if (isnan(measured_z))
-        abort_flag = true;
-      else {
-        measured_z -= get_z_correction(points[0]);
-        TERN_(VALIDATE_MESH_TILT, z1 = measured_z);
-        if (param.V_verbosity > 3) {
-          serial_spaces(16);
-          SERIAL_ECHOLNPGM("Corrected_Z=", measured_z);
-        }
-        incremental_LSF(&lsf_results, points[0], measured_z);
-      }
+      #if ENABLED(VALIDATE_MESH_TILT)
+        float gotz[3];  // Used for algorithm validation below
+      #endif
 
-      if (!abort_flag) {
-        SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
-        TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " 2/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
+      LOOP_L_N(i, 3) {
+        SERIAL_ECHOLNPGM("Tilting mesh (", i + 1, "/3)");
+        TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/3"), i + 1, GET_TEXT(MSG_LCD_TILTING_MESH)));
 
-        measured_z = probe.probe_at_point(points[1], PROBE_PT_RAISE, param.V_verbosity);
-        TERN_(VALIDATE_MESH_TILT, z2 = measured_z);
-        if (isnan(measured_z))
-          abort_flag = true;
-        else {
-          measured_z -= get_z_correction(points[1]);
-          if (param.V_verbosity > 3) {
-            serial_spaces(16);
-            SERIAL_ECHOLNPGM("Corrected_Z=", measured_z);
-          }
-          incremental_LSF(&lsf_results, points[1], measured_z);
-        }
-      }
+        measured_z = probe.probe_at_point(points[i], i < 2 ? PROBE_PT_RAISE : PROBE_PT_LAST_STOW, param.V_verbosity);
+        if ((abort_flag = isnan(measured_z))) break;
 
-      if (!abort_flag) {
-        SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
-        TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
+        measured_z -= get_z_correction(points[i]);
+        TERN_(VALIDATE_MESH_TILT, gotz[i] = measured_z);
 
-        measured_z = probe.probe_at_point(points[2], PROBE_PT_LAST_STOW, param.V_verbosity);
-        TERN_(VALIDATE_MESH_TILT, z3 = measured_z);
-        if (isnan(measured_z))
-          abort_flag = true;
-        else {
-          measured_z -= get_z_correction(points[2]);
-          if (param.V_verbosity > 3) {
-            serial_spaces(16);
-            SERIAL_ECHOLNPGM("Corrected_Z=", measured_z);
-          }
-          incremental_LSF(&lsf_results, points[2], measured_z);
-        }
+        if (param.V_verbosity > 3) { serial_spaces(16); SERIAL_ECHOLNPGM("Corrected_Z=", measured_z); }
+
+        incremental_LSF(&lsf_results, points[i], measured_z);
       }
 
       probe.stow();
       probe.move_z_after_probing();
 
       if (abort_flag) {
         SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");
         return;
       }
     }
     else { // !do_3_pt_leveling
 
+      #ifdef G29J_MESH_TILT_MARGIN
+        const float x_min = _MAX(probe.min_x() + (G29J_MESH_TILT_MARGIN), X_MIN_POS),
+                    x_max = _MIN(probe.max_x() - (G29J_MESH_TILT_MARGIN), X_MAX_POS),
+                    y_min = _MAX(probe.min_y() + (G29J_MESH_TILT_MARGIN), Y_MIN_POS),
+                    y_max = _MIN(probe.max_y() - (G29J_MESH_TILT_MARGIN), Y_MAX_POS);
+      #else
+        const float x_min = probe.min_x(), x_max = probe.max_x(),
+                    y_min = probe.min_y(), y_max = probe.max_y();
+      #endif
+      const float dx = (x_max - x_min) / (param.J_grid_size - 1),
+                  dy = (y_max - y_min) / (param.J_grid_size - 1);
+
       bool zig_zag = false;
 
       const uint16_t total_points = sq(param.J_grid_size);
       uint16_t point_num = 1;
 
-      xy_pos_t rpos;
       LOOP_L_N(ix, param.J_grid_size) {
+        xy_pos_t rpos;
         rpos.x = x_min + ix * dx;
         LOOP_L_N(iy, param.J_grid_size) {
           rpos.y = y_min + dy * (zig_zag ? param.J_grid_size - 1 - iy : iy);
 
-          if (!abort_flag) {
-            SERIAL_ECHOLNPGM("Tilting mesh point ", point_num, "/", total_points, "\n");
-            TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
-
-            measured_z = probe.probe_at_point(rpos, parser.seen_test('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity); // TODO: Needs error handling
-
-            abort_flag = isnan(measured_z);
-
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) {
-                const xy_pos_t lpos = rpos.asLogical();
-                DEBUG_CHAR('(');
-                DEBUG_ECHO_F(rpos.x, 7);
-                DEBUG_CHAR(',');
-                DEBUG_ECHO_F(rpos.y, 7);
-                DEBUG_ECHOPAIR_F(")   logical: (", lpos.x, 7);
-                DEBUG_CHAR(',');
-                DEBUG_ECHO_F(lpos.y, 7);
-                DEBUG_ECHOPAIR_F(")   measured: ", measured_z, 7);
-                DEBUG_ECHOPAIR_F("   correction: ", get_z_correction(rpos), 7);
-              }
-            #endif
+          SERIAL_ECHOLNPGM("Tilting mesh point ", point_num, "/", total_points, "\n");
+          TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
 
-            measured_z -= get_z_correction(rpos) /* + probe.offset.z */ ;
+          measured_z = probe.probe_at_point(rpos, parser.seen_test('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity); // TODO: Needs error handling
 
-            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("   final >>>---> ", measured_z, 7);
+          if ((abort_flag = isnan(measured_z))) break;
 
-            if (param.V_verbosity > 3) {
-              serial_spaces(16);
-              SERIAL_ECHOLNPGM("Corrected_Z=", measured_z);
+          const float zcorr = get_z_correction(rpos);
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) {
+              const xy_pos_t lpos = rpos.asLogical();
+              DEBUG_CHAR('('); DEBUG_ECHO_F(rpos.x, 7); DEBUG_CHAR(','); DEBUG_ECHO_F(rpos.y, 7);
+              DEBUG_ECHOPAIR_F(")  logical: (", lpos.x, 7); DEBUG_CHAR(','); DEBUG_ECHO_F(lpos.y, 7);
+              DEBUG_ECHOPAIR_F(")  measured: ", measured_z, 7);
+              DEBUG_ECHOPAIR_F("  correction: ", zcorr, 7);
             }
-            incremental_LSF(&lsf_results, rpos, measured_z);
+          #endif
+
+          measured_z -= zcorr;
+
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("  final >>>---> ", measured_z, 7);
+
+          if (param.V_verbosity > 3) {
+            serial_spaces(16);
+            SERIAL_ECHOLNPGM("Corrected_Z=", measured_z);
           }
+          incremental_LSF(&lsf_results, rpos, measured_z);
 
           point_num++;
         }
 
+        if (abort_flag) break;
         zig_zag ^= true;
       }
     }
     probe.stow();
     probe.move_z_after_probing();
 
     if (abort_flag || finish_incremental_LSF(&lsf_results)) {
       SERIAL_ECHOPGM("Could not complete LSF!");
       return;
     }
@@ -1689,34 +1648,37 @@ void unified_bed_leveling::smart_fill_mesh() {
        * three points are used in the calculation. This guarantees that each probed point
        * has an exact match when get_z_correction() for that location is calculated.
        * The Z error between the probed point locations and the get_z_correction()
        * numbers for those locations should be 0.
        */
       #if ENABLED(VALIDATE_MESH_TILT)
         auto d_from = []{ DEBUG_ECHOPGM("D from "); };
         auto normed = [&](const xy_pos_t &pos, const_float_t zadd) {
           return normal.x * pos.x + normal.y * pos.y + zadd;
         };
-        auto debug_pt = [](FSTR_P const pre, const xy_pos_t &pos, const_float_t zadd) {
-          d_from(); SERIAL_ECHOF(pre);
+        auto debug_pt = [](const int num, const xy_pos_t &pos, const_float_t zadd) {
+          d_from(); DEBUG_ECHOPGM("Point ", num, ":");
           DEBUG_ECHO_F(normed(pos, zadd), 6);
           DEBUG_ECHOLNPAIR_F("   Z error = ", zadd - get_z_correction(pos), 6);
         };
-        debug_pt(F("1st point: "), probe_pt[0], normal.z * z1);
-        debug_pt(F("2nd point: "), probe_pt[1], normal.z * z2);
-        debug_pt(F("3rd point: "), probe_pt[2], normal.z * z3);
-        d_from(); DEBUG_ECHOPGM("safe home with Z=");
-        DEBUG_ECHOLNPAIR_F("0 : ", normed(safe_homing_xy, 0), 6);
-        d_from(); DEBUG_ECHOPGM("safe home with Z=");
-        DEBUG_ECHOLNPAIR_F("mesh value ", normed(safe_homing_xy, get_z_correction(safe_homing_xy)), 6);
-        DEBUG_ECHOPGM("   Z error = (", Z_SAFE_HOMING_X_POINT, ",", Z_SAFE_HOMING_Y_POINT);
-        DEBUG_ECHOLNPAIR_F(") = ", get_z_correction(safe_homing_xy), 6);
+        debug_pt(1, probe_pt[0], normal.z * gotz[0]);
+        debug_pt(2, probe_pt[1], normal.z * gotz[1]);
+        debug_pt(3, probe_pt[2], normal.z * gotz[2]);
+        #if ENABLED(Z_SAFE_HOMING)
+          constexpr xy_float_t safe_xy = { Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT };
+          d_from(); DEBUG_ECHOPGM("safe home with Z=");
+          DEBUG_ECHOLNPAIR_F("0 : ", normed(safe_xy, 0), 6);
+          d_from(); DEBUG_ECHOPGM("safe home with Z=");
+          DEBUG_ECHOLNPAIR_F("mesh value ", normed(safe_xy, get_z_correction(safe_xy)), 6);
+          DEBUG_ECHOPGM("   Z error = (", Z_SAFE_HOMING_X_POINT, ",", Z_SAFE_HOMING_Y_POINT);
+          DEBUG_ECHOLNPAIR_F(") = ", get_z_correction(safe_xy), 6);
+        #endif
       #endif
     } // DEBUGGING(LEVELING)
 
   }
 
 #endif // HAS_BED_PROBE
 
 #if ENABLED(UBL_G29_P31)
   void unified_bed_leveling::smart_fill_wlsf(const_float_t weight_factor) {
 

commit fc20533583e6a1f9bd2840208a72fbbf362e4bb4
Author: apulver <apulver@users.noreply.github.com>
Date:   Wed Feb 15 01:38:54 2023 -0500

    ✨ AVOID_OBSTACLES for UBL (#25256)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 354597b601..02efb3e065 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1471,23 +1471,31 @@ void unified_bed_leveling::smart_fill_mesh() {
   }
 }
 
 #if HAS_BED_PROBE
 
   //#define VALIDATE_MESH_TILT
 
   #include "../../../libs/vector_3.h"
 
   void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
-    const float x_min = probe.min_x(), x_max = probe.max_x(),
-                y_min = probe.min_y(), y_max = probe.max_y(),
-                dx = (x_max - x_min) / (param.J_grid_size - 1),
+
+    #ifdef G29J_MESH_TILT_MARGIN
+      const float x_min = _MAX(probe.min_x() + (G29J_MESH_TILT_MARGIN), X_MIN_POS),
+                  x_max = _MIN(probe.max_x() - (G29J_MESH_TILT_MARGIN), X_MAX_POS),
+                  y_min = _MAX(probe.min_y() + (G29J_MESH_TILT_MARGIN), Y_MIN_POS),
+                  y_max = _MIN(probe.max_y() - (G29J_MESH_TILT_MARGIN), Y_MAX_POS);
+    #else
+      const float x_min = probe.min_x(), x_max = probe.max_x(),
+                  y_min = probe.min_y(), y_max = probe.max_y();
+    #endif
+    const float dx = (x_max - x_min) / (param.J_grid_size - 1),
                 dy = (y_max - y_min) / (param.J_grid_size - 1);
 
     xy_float_t points[3];
     probe.get_three_points(points);
 
     float measured_z;
     bool abort_flag = false;
 
     #if ENABLED(VALIDATE_MESH_TILT)
       float z1, z2, z3;  // Needed for algorithm validation below

commit 2b86daa30bb4705f8369ca27dd5fe723c90ef634
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Feb 14 22:29:47 2023 -0600

    🎨 Tweak VALIDATE_MESH_TILT

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index f5c370aa68..354597b601 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1482,74 +1482,68 @@ void unified_bed_leveling::smart_fill_mesh() {
                 y_min = probe.min_y(), y_max = probe.max_y(),
                 dx = (x_max - x_min) / (param.J_grid_size - 1),
                 dy = (y_max - y_min) / (param.J_grid_size - 1);
 
     xy_float_t points[3];
     probe.get_three_points(points);
 
     float measured_z;
     bool abort_flag = false;
 
-    #ifdef VALIDATE_MESH_TILT
+    #if ENABLED(VALIDATE_MESH_TILT)
       float z1, z2, z3;  // Needed for algorithm validation below
     #endif
 
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
 
     if (do_3_pt_leveling) {
       SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
       TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " 1/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
       measured_z = probe.probe_at_point(points[0], PROBE_PT_RAISE, param.V_verbosity);
       if (isnan(measured_z))
         abort_flag = true;
       else {
         measured_z -= get_z_correction(points[0]);
-        #ifdef VALIDATE_MESH_TILT
-          z1 = measured_z;
-        #endif
+        TERN_(VALIDATE_MESH_TILT, z1 = measured_z);
         if (param.V_verbosity > 3) {
           serial_spaces(16);
           SERIAL_ECHOLNPGM("Corrected_Z=", measured_z);
         }
         incremental_LSF(&lsf_results, points[0], measured_z);
       }
 
       if (!abort_flag) {
         SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " 2/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
         measured_z = probe.probe_at_point(points[1], PROBE_PT_RAISE, param.V_verbosity);
-        #ifdef VALIDATE_MESH_TILT
-          z2 = measured_z;
-        #endif
+        TERN_(VALIDATE_MESH_TILT, z2 = measured_z);
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[1]);
           if (param.V_verbosity > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPGM("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, points[1], measured_z);
         }
       }
 
       if (!abort_flag) {
         SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
         measured_z = probe.probe_at_point(points[2], PROBE_PT_LAST_STOW, param.V_verbosity);
-        #ifdef VALIDATE_MESH_TILT
-          z3 = measured_z;
-        #endif
+        TERN_(VALIDATE_MESH_TILT, z3 = measured_z);
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[2]);
           if (param.V_verbosity > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPGM("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, points[2], measured_z);
         }
@@ -1682,21 +1676,21 @@ void unified_bed_leveling::smart_fill_mesh() {
       DEBUG_EOL();
 
       /**
        * Use the code below to check the validity of the mesh tilting algorithm.
        * 3-Point Mesh Tilt uses the same algorithm as grid-based tilting, but only
        * three points are used in the calculation. This guarantees that each probed point
        * has an exact match when get_z_correction() for that location is calculated.
        * The Z error between the probed point locations and the get_z_correction()
        * numbers for those locations should be 0.
        */
-      #ifdef VALIDATE_MESH_TILT
+      #if ENABLED(VALIDATE_MESH_TILT)
         auto d_from = []{ DEBUG_ECHOPGM("D from "); };
         auto normed = [&](const xy_pos_t &pos, const_float_t zadd) {
           return normal.x * pos.x + normal.y * pos.y + zadd;
         };
         auto debug_pt = [](FSTR_P const pre, const xy_pos_t &pos, const_float_t zadd) {
           d_from(); SERIAL_ECHOF(pre);
           DEBUG_ECHO_F(normed(pos, zadd), 6);
           DEBUG_ECHOLNPAIR_F("   Z error = ", zadd - get_z_correction(pos), 6);
         };
         debug_pt(F("1st point: "), probe_pt[0], normal.z * z1);

commit 7e79fc5b8e04e0614d8ae09f908a73728f3e596e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 8 20:26:59 2023 -0600

    🩹 Safe Bed Leveling updates

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index d6cb0b762f..f5c370aa68 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -311,23 +311,21 @@ void unified_bed_leveling::G29() {
   #endif
 
   // Check for commands that require the printer to be homed
   if (may_move) {
     planner.synchronize();
     // Send 'N' to force homing before G29 (internal only)
     if (axes_should_home() || parser.seen_test('N')) gcode.home_all_axes();
     TERN_(HAS_MULTI_HOTEND, if (active_extruder != 0) tool_change(0, true));
 
     // Position bed horizontally and Z probe vertically.
-    #if    defined(SAFE_BED_LEVELING_START_X) || defined(SAFE_BED_LEVELING_START_Y) || defined(SAFE_BED_LEVELING_START_Z) \
-        || defined(SAFE_BED_LEVELING_START_I) || defined(SAFE_BED_LEVELING_START_J) || defined(SAFE_BED_LEVELING_START_K) \
-        || defined(SAFE_BED_LEVELING_START_U) || defined(SAFE_BED_LEVELING_START_V) || defined(SAFE_BED_LEVELING_START_W)
+    #if HAS_SAFE_BED_LEVELING
       xyze_pos_t safe_position = current_position;
       #ifdef SAFE_BED_LEVELING_START_X
         safe_position.x = SAFE_BED_LEVELING_START_X;
       #endif
       #ifdef SAFE_BED_LEVELING_START_Y
         safe_position.y = SAFE_BED_LEVELING_START_Y;
       #endif
       #ifdef SAFE_BED_LEVELING_START_Z
         safe_position.z = SAFE_BED_LEVELING_START_Z;
       #endif
@@ -344,21 +342,21 @@ void unified_bed_leveling::G29() {
         safe_position.u = SAFE_BED_LEVELING_START_U;
       #endif
       #ifdef SAFE_BED_LEVELING_START_V
         safe_position.v = SAFE_BED_LEVELING_START_V;
       #endif
       #ifdef SAFE_BED_LEVELING_START_W
         safe_position.w = SAFE_BED_LEVELING_START_W;
       #endif
 
       do_blocking_move_to(safe_position);
-    #endif
+    #endif // HAS_SAFE_BED_LEVELING
   }
 
   // Invalidate one or more nearby mesh points, possibly all.
   if (parser.seen('I')) {
     uint8_t count = parser.has_value() ? parser.value_byte() : 1;
     bool invalidate_all = count >= GRID_MAX_POINTS;
     if (!invalidate_all) {
       while (count--) {
         if ((count & 0x0F) == 0x0F) idle();
         const mesh_index_pair closest = find_closest_mesh_point_of_type(REAL, param.XY_pos);
@@ -880,22 +878,46 @@ void set_message_with_feedback(FSTR_P const fstr) {
     move_z_with_encoder(z_step);
     return current_position.z;
   }
 
   static void echo_and_take_a_measurement() { SERIAL_ECHOLNPGM(" and take a measurement."); }
 
   float unified_bed_leveling::measure_business_card_thickness() {
     ui.capture();
     save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
-    do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), MANUAL_PROBE_START_Z);
-      //, _MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f);
+    do_blocking_move_to(
+      NUM_AXIS_LIST(
+        0.5f * ((MESH_MAX_X) - (MESH_MIN_X)),
+        0.5f * ((MESH_MAX_Y) - (MESH_MIN_Y)),
+        MANUAL_PROBE_START_Z
+        #ifdef SAFE_BED_LEVELING_START_I
+          , SAFE_BED_LEVELING_START_I
+        #endif
+        #ifdef SAFE_BED_LEVELING_START_J
+          , SAFE_BED_LEVELING_START_J
+        #endif
+        #ifdef SAFE_BED_LEVELING_START_K
+          , SAFE_BED_LEVELING_START_K
+        #endif
+        #ifdef SAFE_BED_LEVELING_START_U
+          , SAFE_BED_LEVELING_START_U
+        #endif
+        #ifdef SAFE_BED_LEVELING_START_V
+          , SAFE_BED_LEVELING_START_V
+        #endif
+        #ifdef SAFE_BED_LEVELING_START_W
+          , SAFE_BED_LEVELING_START_W
+        #endif
+      )
+      //, _MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f
+    );
     planner.synchronize();
 
     SERIAL_ECHOPGM("Place shim under nozzle");
     LCD_MESSAGE(MSG_UBL_BC_INSERT);
     ui.return_to_status();
     echo_and_take_a_measurement();
 
     const float z1 = measure_point_with_encoder();
     do_blocking_move_to_z(current_position.z + SIZE_OF_LITTLE_RAISE);
     planner.synchronize();

commit a4297ff492ba62b1da8ad9c7611ae30de0028a8e
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Thu Sep 22 12:54:49 2022 -0500

    Fix UBL regression (#24622)
    
    Fix regression from #24188

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index f1e88006ff..d6cb0b762f 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -400,21 +400,21 @@ void unified_bed_leveling::G29() {
         }
         break;
 
       case 1:
         LOOP_L_N(x, GRID_MAX_POINTS_X) {                     // Create a diagonal line several Mesh cells thick that is raised
           const uint8_t x2 = x + (x < (GRID_MAX_POINTS_Y) - 1 ? 1 : -1);
           z_values[x][x] += 9.999f;
           z_values[x][x2] += 9.999f; // We want the altered line several mesh points thick
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(x, x, z_values[x][x]);
-            ExtUI::onMeshUpdate(x, (x2), z_values[x][x2]);
+            ExtUI::onMeshUpdate(x, x2, z_values[x][x2]);
           #endif
         }
         break;
 
       case 2:
         // Allow the user to specify the height because 10mm is a little extreme in some cases.
         for (uint8_t x = (GRID_MAX_POINTS_X) / 3; x < 2 * (GRID_MAX_POINTS_X) / 3; x++)     // Create a rectangular raised area in
           for (uint8_t y = (GRID_MAX_POINTS_Y) / 3; y < 2 * (GRID_MAX_POINTS_Y) / 3; y++) { // the center of the bed
             z_values[x][y] += parser.seen_test('C') ? param.C_constant : 9.99f;
             TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));

commit 21c48d9f927c81d7b7cf6fc3641ce01a831a16ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 27 04:24:50 2022 -0500

    🧑‍💻  Update planner/stepper includes

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index a02918ff29..f1e88006ff 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -24,21 +24,20 @@
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
 #include "../bedlevel.h"
 
 #include "../../../MarlinCore.h"
 #include "../../../HAL/shared/eeprom_api.h"
 #include "../../../libs/hex_print.h"
 #include "../../../module/settings.h"
 #include "../../../lcd/marlinui.h"
-#include "../../../module/stepper.h"
 #include "../../../module/planner.h"
 #include "../../../module/motion.h"
 #include "../../../module/probe.h"
 #include "../../../gcode/gcode.h"
 #include "../../../libs/least_squares_fit.h"
 
 #if HAS_MULTI_HOTEND
   #include "../../../module/tool_change.h"
 #endif
 

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ♻️ Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 278d982f70..a02918ff29 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -934,25 +934,21 @@ void set_message_with_feedback(FSTR_P const fstr) {
 
     ui.return_to_status();
 
     mesh_index_pair location;
     const xy_int8_t &lpos = location.pos;
     do {
       location = find_closest_mesh_point_of_type(INVALID, pos);
       // It doesn't matter if the probe can't reach the NAN location. This is a manual probe.
       if (!location.valid()) continue;
 
-      const xyz_pos_t ppos = {
-        mesh_index_to_xpos(lpos.x),
-        mesh_index_to_ypos(lpos.y),
-        z_clearance
-      };
+      const xyz_pos_t ppos = { get_mesh_x(lpos.x), get_mesh_y(lpos.y), z_clearance };
 
       if (!position_is_reachable(ppos)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
 
       LCD_MESSAGE(MSG_UBL_MOVING_TO_NEXT);
 
       do_blocking_move_to(ppos);
       do_z_clearance(z_clearance);
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       ui.capture();
@@ -1033,25 +1029,21 @@ void set_message_with_feedback(FSTR_P const fstr) {
       safe_delay(50);
     #endif
 
     do {
       location = find_closest_mesh_point_of_type(SET_IN_BITMAP, pos, false, &done_flags);
 
       if (lpos.x < 0) break;                              // Stop when there are no more reachable points
 
       done_flags.mark(lpos);                              // Mark this location as 'adjusted' so a new
                                                           // location is used on the next loop
-      const xyz_pos_t raw = {
-        mesh_index_to_xpos(lpos.x),
-        mesh_index_to_ypos(lpos.y),
-        Z_CLEARANCE_BETWEEN_PROBES
-      };
+      const xyz_pos_t raw = { get_mesh_x(lpos.x), get_mesh_y(lpos.y), Z_CLEARANCE_BETWEEN_PROBES };
 
       if (!position_is_reachable(raw)) break;             // SHOULD NOT OCCUR (find_closest_mesh_point_of_type only returns reachable)
 
       do_blocking_move_to(raw);                           // Move the nozzle to the edit point with probe clearance
 
       TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset)); // Move Z to the given 'H' offset before editing
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
 
       if (do_ubl_mesh_map) display_map(param.T_map_type);     // Display the current point
@@ -1270,21 +1262,21 @@ void unified_bed_leveling::restore_ubl_active_state_and_leave() {
 mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
   bool found_a_NAN = false, found_a_real = false;
 
   mesh_index_pair farthest { -1, -1, -99999.99 };
 
   GRID_LOOP(i, j) {
     if (!isnan(z_values[i][j])) continue;  // Skip valid mesh points
 
     // Skip unreachable points
-    if (!probe.can_reach(mesh_index_to_xpos(i), mesh_index_to_ypos(j)))
+    if (!probe.can_reach(get_mesh_x(i), get_mesh_y(j)))
       continue;
 
     found_a_NAN = true;
 
     xy_int8_t nearby { -1, -1 };
     float d1, d2 = 99999.9f;
     GRID_LOOP(k, l) {
       if (isnan(z_values[k][l])) continue;
 
       found_a_real = true;
@@ -1322,25 +1314,25 @@ mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
   typedef struct {
     MeshPointType   type;
     MeshFlags       *done_flags;
     bool            probe_relative;
     mesh_index_pair closest;
   } find_closest_t;
 
   static bool test_func(uint8_t i, uint8_t j, void *data) {
     find_closest_t *d = (find_closest_t*)data;
-    if (  d->type == CLOSEST || d->type == (isnan(ubl.z_values[i][j]) ? INVALID : REAL)
+    if (  d->type == CLOSEST || d->type == (isnan(bedlevel.z_values[i][j]) ? INVALID : REAL)
       || (d->type == SET_IN_BITMAP && !d->done_flags->marked(i, j))
     ) {
       // Found a Mesh Point of the specified type!
-      const xy_pos_t mpos = { ubl.mesh_index_to_xpos(i), ubl.mesh_index_to_ypos(j) };
+      const xy_pos_t mpos = { bedlevel.get_mesh_x(i), bedlevel.get_mesh_y(j) };
 
       // If using the probe as the reference there are some unreachable locations.
       // Also for round beds, there are grid points outside the bed the nozzle can't reach.
       // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
       if (!(d->probe_relative ? probe.can_reach(mpos) : position_is_reachable(mpos)))
         return false;
       d->closest.pos.set(i, j);
       return true;
     }
@@ -1370,21 +1362,21 @@ mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const Mesh
     // Get the reference position, either nozzle or probe
     const xy_pos_t ref = probe_relative ? pos + probe.offset_xy : pos;
 
     float best_so_far = 99999.99f;
 
     GRID_LOOP(i, j) {
       if (  type == CLOSEST || type == (isnan(z_values[i][j]) ? INVALID : REAL)
         || (type == SET_IN_BITMAP && !done_flags->marked(i, j))
       ) {
         // Found a Mesh Point of the specified type!
-        const xy_pos_t mpos = { mesh_index_to_xpos(i), mesh_index_to_ypos(j) };
+        const xy_pos_t mpos = { get_mesh_x(i), get_mesh_y(j) };
 
         // If using the probe as the reference there are some unreachable locations.
         // Also for round beds, there are grid points outside the bed the nozzle can't reach.
         // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
         if (!(probe_relative ? probe.can_reach(mpos) : position_is_reachable(mpos)))
           continue;
 
         // Reachable. Check if it's the best_so_far location to the nozzle.
 
@@ -1426,24 +1418,24 @@ bool unified_bed_leveling::smart_fill_one(const uint8_t x, const uint8_t y, cons
       }
     }
   }
   return false;
 }
 
 typedef struct { uint8_t sx, ex, sy, ey; bool yfirst; } smart_fill_info;
 
 void unified_bed_leveling::smart_fill_mesh() {
   static const smart_fill_info
-    info0 PROGMEM = { 0, GRID_MAX_POINTS_X,      0, GRID_MAX_POINTS_Y - 2,  false },  // Bottom of the mesh looking up
-    info1 PROGMEM = { 0, GRID_MAX_POINTS_X,      GRID_MAX_POINTS_Y - 1, 0,  false },  // Top of the mesh looking down
-    info2 PROGMEM = { 0, GRID_MAX_POINTS_X - 2,  0, GRID_MAX_POINTS_Y,      true  },  // Left side of the mesh looking right
-    info3 PROGMEM = { GRID_MAX_POINTS_X - 1, 0,  0, GRID_MAX_POINTS_Y,      true  };  // Right side of the mesh looking left
+    info0 PROGMEM = { 0, GRID_MAX_POINTS_X,       0, (GRID_MAX_POINTS_Y) - 2, false },  // Bottom of the mesh looking up
+    info1 PROGMEM = { 0, GRID_MAX_POINTS_X,     (GRID_MAX_POINTS_Y) - 1, 0,   false },  // Top of the mesh looking down
+    info2 PROGMEM = { 0, (GRID_MAX_POINTS_X) - 2, 0, GRID_MAX_POINTS_Y,       true  },  // Left side of the mesh looking right
+    info3 PROGMEM = { (GRID_MAX_POINTS_X) - 1, 0, 0, GRID_MAX_POINTS_Y,       true  };  // Right side of the mesh looking left
   static const smart_fill_info * const info[] PROGMEM = { &info0, &info1, &info2, &info3 };
 
   LOOP_L_N(i, COUNT(info)) {
     const smart_fill_info *f = (smart_fill_info*)pgm_read_ptr(&info[i]);
     const int8_t sx = pgm_read_byte(&f->sx), sy = pgm_read_byte(&f->sy),
                  ex = pgm_read_byte(&f->ex), ey = pgm_read_byte(&f->ey);
     if (pgm_read_byte(&f->yfirst)) {
       const int8_t dir = ex > sx ? 1 : -1;
       for (uint8_t y = sy; y != ey; ++y)
         for (uint8_t x = sx; x != ex; x += dir)
@@ -1618,23 +1610,21 @@ void unified_bed_leveling::smart_fill_mesh() {
       SERIAL_CHAR(',');
       SERIAL_ECHO_F(normal.y, 7);
       SERIAL_CHAR(',');
       SERIAL_ECHO_F(normal.z, 7);
       SERIAL_ECHOLNPGM("]");
     }
 
     matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
 
     GRID_LOOP(i, j) {
-      float mx = mesh_index_to_xpos(i),
-            my = mesh_index_to_ypos(j),
-            mz = z_values[i][j];
+      float mx = get_mesh_x(i), my = get_mesh_y(j), mz = z_values[i][j];
 
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOPAIR_F("before rotation = [", mx, 7);
         DEBUG_CHAR(',');
         DEBUG_ECHO_F(my, 7);
         DEBUG_CHAR(',');
         DEBUG_ECHO_F(mz, 7);
         DEBUG_ECHOPGM("]   ---> ");
         DEBUG_DELAY(20);
       }
@@ -1717,32 +1707,32 @@ void unified_bed_leveling::smart_fill_mesh() {
     struct linear_fit_data lsf_results;
 
     SERIAL_ECHOPGM("Extrapolating mesh...");
 
     const float weight_scaled = weight_factor * _MAX(MESH_X_DIST, MESH_Y_DIST);
 
     GRID_LOOP(jx, jy) if (!isnan(z_values[jx][jy])) SBI(bitmap[jx], jy);
 
     xy_pos_t ppos;
     LOOP_L_N(ix, GRID_MAX_POINTS_X) {
-      ppos.x = mesh_index_to_xpos(ix);
+      ppos.x = get_mesh_x(ix);
       LOOP_L_N(iy, GRID_MAX_POINTS_Y) {
-        ppos.y = mesh_index_to_ypos(iy);
+        ppos.y = get_mesh_y(iy);
         if (isnan(z_values[ix][iy])) {
           // undefined mesh point at (ppos.x,ppos.y), compute weighted LSF from original valid mesh points.
           incremental_LSF_reset(&lsf_results);
           xy_pos_t rpos;
           LOOP_L_N(jx, GRID_MAX_POINTS_X) {
-            rpos.x = mesh_index_to_xpos(jx);
+            rpos.x = get_mesh_x(jx);
             LOOP_L_N(jy, GRID_MAX_POINTS_Y) {
               if (TEST(bitmap[jx], jy)) {
-                rpos.y = mesh_index_to_ypos(jy);
+                rpos.y = get_mesh_y(jy);
                 const float rz = z_values[jx][jy],
                              w = 1.0f + weight_scaled / (rpos - ppos).magnitude();
                 incremental_WLSF(&lsf_results, rpos, rz, w);
               }
             }
           }
           if (finish_incremental_LSF(&lsf_results)) {
             SERIAL_ECHOLNPGM("Insufficient data");
             return;
           }
@@ -1787,29 +1777,29 @@ void unified_bed_leveling::smart_fill_mesh() {
     SERIAL_ECHOLNPGM("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); serial_delay(50);
     SERIAL_ECHOLNPGM("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); serial_delay(50);
     SERIAL_ECHOLNPGM("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); serial_delay(50);
     SERIAL_ECHOLNPGM("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             serial_delay(50);
     SERIAL_ECHOLNPGM("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);             serial_delay(50);
     SERIAL_ECHOLNPGM("MESH_X_DIST  ", MESH_X_DIST);
     SERIAL_ECHOLNPGM("MESH_Y_DIST  ", MESH_Y_DIST);                         serial_delay(50);
 
     SERIAL_ECHOPGM("X-Axis Mesh Points at: ");
     LOOP_L_N(i, GRID_MAX_POINTS_X) {
-      SERIAL_ECHO_F(LOGICAL_X_POSITION(mesh_index_to_xpos(i)), 3);
+      SERIAL_ECHO_F(LOGICAL_X_POSITION(get_mesh_x(i)), 3);
       SERIAL_ECHOPGM("  ");
       serial_delay(25);
     }
     SERIAL_EOL();
 
     SERIAL_ECHOPGM("Y-Axis Mesh Points at: ");
     LOOP_L_N(i, GRID_MAX_POINTS_Y) {
-      SERIAL_ECHO_F(LOGICAL_Y_POSITION(mesh_index_to_ypos(i)), 3);
+      SERIAL_ECHO_F(LOGICAL_Y_POSITION(get_mesh_y(i)), 3);
       SERIAL_ECHOPGM("  ");
       serial_delay(25);
     }
     SERIAL_EOL();
 
     #if HAS_KILL
       SERIAL_ECHOLNPGM("Kill pin on :", KILL_PIN, "  state:", kill_state());
     #endif
 
     SERIAL_EOL();

commit a65e4edb1c794dcd22980f3cce9bf2993da1514b
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Tue May 17 15:44:30 2022 -0500

    🚸 ProUI APRIL2022 updates (#24084)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 0ae3e301cc..278d982f70 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -756,20 +756,21 @@ void unified_bed_leveling::shift_mesh_height() {
   /**
    * G29 P1 T<maptype> V<verbosity> : Probe Entire Mesh
    *   Probe all invalidated locations of the mesh that can be reached by the probe.
    *   This attempts to fill in locations closest to the nozzle's start location first.
    */
   void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &nearby, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
     probe.deploy(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
 
     TERN_(HAS_MARLINUI_MENU, ui.capture());
     TERN_(EXTENSIBLE_UI, ExtUI::onLevelingStart());
+    TERN_(DWIN_LCD_PROUI, DWIN_LevelingStart());
 
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
     uint8_t count = GRID_MAX_POINTS;
 
     mesh_index_pair best;
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_START));
     do {
       if (do_ubl_mesh_map) display_map(param.T_map_type);
 
       const uint8_t point_num = (GRID_MAX_POINTS - count) + 1;
@@ -819,20 +820,21 @@ void unified_bed_leveling::shift_mesh_height() {
     probe.move_z_after_probing();
 
     restore_ubl_active_state_and_leave();
 
     do_blocking_move_to_xy(
       constrain(nearby.x - probe.offset_xy.x, MESH_MIN_X, MESH_MAX_X),
       constrain(nearby.y - probe.offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
     );
 
     TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
+    TERN_(DWIN_LCD_PROUI, DWIN_LevelingDone());
   }
 
 #endif // HAS_BED_PROBE
 
 void set_message_with_feedback(FSTR_P const fstr) {
   #if HAS_MARLINUI_MENU
     ui.set_status(fstr);
     ui.quick_feedback();
   #else
     UNUSED(fstr);

commit fe745fdef051e5c0cce4368d5a3f2a95140f57a5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 22 01:12:43 2022 -0500

    🚸 More ExtUI events for ABL / UBL

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 9d2aaf8247..0ae3e301cc 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -755,20 +755,21 @@ void unified_bed_leveling::shift_mesh_height() {
 #if HAS_BED_PROBE
   /**
    * G29 P1 T<maptype> V<verbosity> : Probe Entire Mesh
    *   Probe all invalidated locations of the mesh that can be reached by the probe.
    *   This attempts to fill in locations closest to the nozzle's start location first.
    */
   void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &nearby, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
     probe.deploy(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
 
     TERN_(HAS_MARLINUI_MENU, ui.capture());
+    TERN_(EXTENSIBLE_UI, ExtUI::onLevelingStart());
 
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
     uint8_t count = GRID_MAX_POINTS;
 
     mesh_index_pair best;
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_START));
     do {
       if (do_ubl_mesh_map) display_map(param.T_map_type);
 
       const uint8_t point_num = (GRID_MAX_POINTS - count) + 1;
@@ -776,20 +777,21 @@ void unified_bed_leveling::shift_mesh_height() {
       TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), point_num, int(GRID_MAX_POINTS)));
 
       #if HAS_MARLINUI_MENU
         if (ui.button_pressed()) {
           ui.quick_feedback(false); // Preserve button state for click-and-hold
           SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
+          TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
           return restore_ubl_active_state_and_leave();
         }
       #endif
 
       best = do_furthest
         ? find_furthest_invalid_mesh_point()
         : find_closest_mesh_point_of_type(INVALID, nearby, true);
 
       if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_POINT_START));
@@ -815,20 +817,22 @@ void unified_bed_leveling::shift_mesh_height() {
     TERN_(HAS_MARLINUI_MENU, ui.capture());
 
     probe.move_z_after_probing();
 
     restore_ubl_active_state_and_leave();
 
     do_blocking_move_to_xy(
       constrain(nearby.x - probe.offset_xy.x, MESH_MIN_X, MESH_MAX_X),
       constrain(nearby.y - probe.offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
     );
+
+    TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
   }
 
 #endif // HAS_BED_PROBE
 
 void set_message_with_feedback(FSTR_P const fstr) {
   #if HAS_MARLINUI_MENU
     ui.set_status(fstr);
     ui.quick_feedback();
   #else
     UNUSED(fstr);
@@ -914,20 +918,21 @@ void set_message_with_feedback(FSTR_P const fstr) {
     return thickness;
   }
 
   /**
    * G29 P2 : Manually Probe Remaining Mesh Points.
    *          Move to INVALID points and
    *          NOTE: Blocks the G-code queue and captures Marlin UI during use.
    */
   void unified_bed_leveling::manually_probe_remaining_mesh(const xy_pos_t &pos, const_float_t z_clearance, const_float_t thick, const bool do_ubl_mesh_map) {
     ui.capture();
+    TERN_(EXTENSIBLE_UI, ExtUI::onLevelingStart());
 
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
     do_blocking_move_to_xy_z(current_position, z_clearance);
 
     ui.return_to_status();
 
     mesh_index_pair location;
     const xy_int8_t &lpos = location.pos;
     do {
       location = find_closest_mesh_point_of_type(INVALID, pos);
@@ -977,20 +982,22 @@ void set_message_with_feedback(FSTR_P const fstr) {
 
       if (param.V_verbosity > 2)
         SERIAL_ECHOLNPAIR_F("Mesh Point Measured at: ", z_values[lpos.x][lpos.y], 6);
       SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
     } while (location.valid());
 
     if (do_ubl_mesh_map) display_map(param.T_map_type);  // show user where we're probing
 
     restore_ubl_active_state_and_leave();
     do_blocking_move_to_xy_z(pos, Z_CLEARANCE_DEPLOY_PROBE);
+
+    TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
   }
 
   /**
    * G29 P4 : Mesh Fine-Tuning. Go to point(s) and adjust values with the LCD.
    *          NOTE: Blocks the G-code queue and captures Marlin UI during use.
    */
   void unified_bed_leveling::fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) {
     if (!parser.seen_test('R')) // fine_tune_mesh() is special. If no repetition count flag is specified
       param.R_repetition = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ✨ Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 0d00296b5b..9d2aaf8247 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -310,20 +310,56 @@ void unified_bed_leveling::G29() {
   #if HAS_MULTI_HOTEND
     const uint8_t old_tool_index = active_extruder;
   #endif
 
   // Check for commands that require the printer to be homed
   if (may_move) {
     planner.synchronize();
     // Send 'N' to force homing before G29 (internal only)
     if (axes_should_home() || parser.seen_test('N')) gcode.home_all_axes();
     TERN_(HAS_MULTI_HOTEND, if (active_extruder != 0) tool_change(0, true));
+
+    // Position bed horizontally and Z probe vertically.
+    #if    defined(SAFE_BED_LEVELING_START_X) || defined(SAFE_BED_LEVELING_START_Y) || defined(SAFE_BED_LEVELING_START_Z) \
+        || defined(SAFE_BED_LEVELING_START_I) || defined(SAFE_BED_LEVELING_START_J) || defined(SAFE_BED_LEVELING_START_K) \
+        || defined(SAFE_BED_LEVELING_START_U) || defined(SAFE_BED_LEVELING_START_V) || defined(SAFE_BED_LEVELING_START_W)
+      xyze_pos_t safe_position = current_position;
+      #ifdef SAFE_BED_LEVELING_START_X
+        safe_position.x = SAFE_BED_LEVELING_START_X;
+      #endif
+      #ifdef SAFE_BED_LEVELING_START_Y
+        safe_position.y = SAFE_BED_LEVELING_START_Y;
+      #endif
+      #ifdef SAFE_BED_LEVELING_START_Z
+        safe_position.z = SAFE_BED_LEVELING_START_Z;
+      #endif
+      #ifdef SAFE_BED_LEVELING_START_I
+        safe_position.i = SAFE_BED_LEVELING_START_I;
+      #endif
+      #ifdef SAFE_BED_LEVELING_START_J
+        safe_position.j = SAFE_BED_LEVELING_START_J;
+      #endif
+      #ifdef SAFE_BED_LEVELING_START_K
+        safe_position.k = SAFE_BED_LEVELING_START_K;
+      #endif
+      #ifdef SAFE_BED_LEVELING_START_U
+        safe_position.u = SAFE_BED_LEVELING_START_U;
+      #endif
+      #ifdef SAFE_BED_LEVELING_START_V
+        safe_position.v = SAFE_BED_LEVELING_START_V;
+      #endif
+      #ifdef SAFE_BED_LEVELING_START_W
+        safe_position.w = SAFE_BED_LEVELING_START_W;
+      #endif
+
+      do_blocking_move_to(safe_position);
+    #endif
   }
 
   // Invalidate one or more nearby mesh points, possibly all.
   if (parser.seen('I')) {
     uint8_t count = parser.has_value() ? parser.value_byte() : 1;
     bool invalidate_all = count >= GRID_MAX_POINTS;
     if (!invalidate_all) {
       while (count--) {
         if ((count & 0x0F) == 0x0F) idle();
         const mesh_index_pair closest = find_closest_mesh_point_of_type(REAL, param.XY_pos);

commit bff55ea6054498dc40a54f747cb54ceb84c2e8b0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 12 15:59:01 2022 -0600

    🐛 Fix UBL 'G29 Q1' bug

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index f62e83e070..0d00296b5b 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -360,27 +360,27 @@ void unified_bed_leveling::G29() {
         GRID_LOOP(x, y) {                                     // Create a bowl shape similar to a poorly-calibrated Delta
           const float p1 = 0.5f * (GRID_MAX_POINTS_X) - x,
                       p2 = 0.5f * (GRID_MAX_POINTS_Y) - y;
           z_values[x][y] += 2.0f * HYPOT(p1, p2);
           TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
         }
         break;
 
       case 1:
         LOOP_L_N(x, GRID_MAX_POINTS_X) {                     // Create a diagonal line several Mesh cells thick that is raised
+          const uint8_t x2 = x + (x < (GRID_MAX_POINTS_Y) - 1 ? 1 : -1);
           z_values[x][x] += 9.999f;
-          z_values[x][x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1] += 9.999f; // We want the altered line several mesh points thick
+          z_values[x][x2] += 9.999f; // We want the altered line several mesh points thick
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(x, x, z_values[x][x]);
-            ExtUI::onMeshUpdate(x, (x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1), z_values[x][x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1]);
+            ExtUI::onMeshUpdate(x, (x2), z_values[x][x2]);
           #endif
-
         }
         break;
 
       case 2:
         // Allow the user to specify the height because 10mm is a little extreme in some cases.
         for (uint8_t x = (GRID_MAX_POINTS_X) / 3; x < 2 * (GRID_MAX_POINTS_X) / 3; x++)     // Create a rectangular raised area in
           for (uint8_t y = (GRID_MAX_POINTS_Y) / 3; y < 2 * (GRID_MAX_POINTS_Y) / 3; y++) { // the center of the bed
             z_values[x][y] += parser.seen_test('C') ? param.C_constant : 9.99f;
             TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
           }

commit 623c6b720b0d9b14934fb8ccb895d421ab043cc9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 12 15:58:28 2022 -0600

    🧑‍💻 Add ExtUI::onLevelingDone, match DWIN to ExtUI

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 023d0c5b1d..f62e83e070 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1212,20 +1212,21 @@ void unified_bed_leveling::save_ubl_active_state_and_disable() {
 void unified_bed_leveling::restore_ubl_active_state_and_leave() {
   TERN_(HAS_MARLINUI_MENU, ui.release());
   #if ENABLED(UBL_DEVEL_DEBUGGING)
     if (--ubl_state_recursion_chk) {
       SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
       set_message_with_feedback(GET_TEXT_F(MSG_UBL_RESTORE_ERROR));
       return;
     }
   #endif
   set_bed_leveling_enabled(ubl_state_at_invocation);
+  TERN_(EXTENSIBLE_UI, ExtUI::onLevelingDone());
 }
 
 mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
   bool found_a_NAN = false, found_a_real = false;
 
   mesh_index_pair farthest { -1, -1, -99999.99 };
 
   GRID_LOOP(i, j) {
     if (!isnan(z_values[i][j])) continue;  // Skip valid mesh points

commit 0a24f858f3009b358c3c0841654521146949261a
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Thu Feb 10 05:46:53 2022 +1300

    🚸 Restore active tool after ABL G29 (#23692)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 15395bcc8d..023d0c5b1d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -309,21 +309,21 @@ void unified_bed_leveling::G29() {
   const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen_test('J');
   #if HAS_MULTI_HOTEND
     const uint8_t old_tool_index = active_extruder;
   #endif
 
   // Check for commands that require the printer to be homed
   if (may_move) {
     planner.synchronize();
     // Send 'N' to force homing before G29 (internal only)
     if (axes_should_home() || parser.seen_test('N')) gcode.home_all_axes();
-    TERN_(HAS_MULTI_HOTEND, if (active_extruder) tool_change(0));
+    TERN_(HAS_MULTI_HOTEND, if (active_extruder != 0) tool_change(0, true));
   }
 
   // Invalidate one or more nearby mesh points, possibly all.
   if (parser.seen('I')) {
     uint8_t count = parser.has_value() ? parser.value_byte() : 1;
     bool invalidate_all = count >= GRID_MAX_POINTS;
     if (!invalidate_all) {
       while (count--) {
         if ((count & 0x0F) == 0x0F) idle();
         const mesh_index_pair closest = find_closest_mesh_point_of_type(REAL, param.XY_pos);
@@ -656,21 +656,21 @@ void unified_bed_leveling::G29() {
   #ifdef Z_PROBE_END_SCRIPT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     if (probe_deployed) {
       planner.synchronize();
       gcode.process_subcommands_now(F(Z_PROBE_END_SCRIPT));
     }
   #else
     UNUSED(probe_deployed);
   #endif
 
-  TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index));
+  TERN_(HAS_MULTI_HOTEND, if (old_tool_index != 0) tool_change(old_tool_index));
   return;
 }
 
 /**
  * M420 C<value>
  * G29 P5 C<value> : Adjust Mesh To Mean (and subtract the given offset).
  *                   Find the mean average and shift the mesh to center on that value.
  */
 void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const_float_t offset) {
   float sum = 0;

commit ab46b7e2f298826a5512569d6e79bb59a7a6b8ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 25 15:33:03 2022 -0600

    🧑‍💻 HAS_MARLINUI_MENU, HAS_MANUAL_MOVE_MENU

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index df83923fef..15395bcc8d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -50,21 +50,21 @@
 #endif
 
 #if ENABLED(UBL_HILBERT_CURVE)
   #include "../hilbert_curve.h"
 #endif
 
 #include <math.h>
 
 #define UBL_G29_P31
 
-#if HAS_LCD_MENU
+#if HAS_MARLINUI_MENU
 
   bool unified_bed_leveling::lcd_map_control = false;
 
   void unified_bed_leveling::steppers_were_disabled() {
     if (lcd_map_control) {
       lcd_map_control = false;
       ui.defer_status_screen(false);
     }
   }
 
@@ -436,21 +436,21 @@ void unified_bed_leveling::G29() {
           }
           probe_entire_mesh(param.XY_pos, parser.seen_test('T'), parser.seen_test('E'), parser.seen_test('U'));
 
           report_current_position();
           probe_deployed = true;
         } break;
 
       #endif // HAS_BED_PROBE
 
       case 2: {
-        #if HAS_LCD_MENU
+        #if HAS_MARLINUI_MENU
           //
           // Manually Probe Mesh in areas that can't be reached by the probe
           //
           SERIAL_ECHOLNPGM("Manually probing unreachable points.");
           do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
 
           if (parser.seen_test('C') && !param.XY_seen) {
 
             /**
              * Use a good default location for the path.
@@ -548,21 +548,21 @@ void unified_bed_leveling::G29() {
             case 0:   // P3 or P3.0
             default:  // and anything P3.x that's not P3.1
               smart_fill_mesh();  // Do a 'Smart' fill using nearby known values
               break;
           }
         }
         break;
       }
 
       case 4: // Fine Tune (i.e., Edit) the Mesh
-        #if HAS_LCD_MENU
+        #if HAS_MARLINUI_MENU
           fine_tune_mesh(param.XY_pos, parser.seen_test('T'));
         #else
           SERIAL_ECHOLNPGM("?P4 is only available when an LCD is present.");
           return;
         #endif
         break;
 
       case 5: adjust_mesh_to_mean(param.C_seen, param.C_constant); break;
 
       case 6: shift_mesh_height(); break;
@@ -639,21 +639,21 @@ void unified_bed_leveling::G29() {
     storage_slot = param.KLS_storage_slot;
 
     SERIAL_ECHOLNPGM(STR_DONE);
   }
 
   if (parser.seen_test('T'))
     display_map(param.T_map_type);
 
   LEAVE:
 
-  #if HAS_LCD_MENU
+  #if HAS_MARLINUI_MENU
     ui.reset_alert_level();
     ui.quick_feedback();
     ui.reset_status();
     ui.release();
   #endif
 
   #ifdef Z_PROBE_END_SCRIPT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     if (probe_deployed) {
       planner.synchronize();
@@ -718,35 +718,35 @@ void unified_bed_leveling::shift_mesh_height() {
 
 #if HAS_BED_PROBE
   /**
    * G29 P1 T<maptype> V<verbosity> : Probe Entire Mesh
    *   Probe all invalidated locations of the mesh that can be reached by the probe.
    *   This attempts to fill in locations closest to the nozzle's start location first.
    */
   void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &nearby, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
     probe.deploy(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
 
-    TERN_(HAS_LCD_MENU, ui.capture());
+    TERN_(HAS_MARLINUI_MENU, ui.capture());
 
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
     uint8_t count = GRID_MAX_POINTS;
 
     mesh_index_pair best;
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_START));
     do {
       if (do_ubl_mesh_map) display_map(param.T_map_type);
 
       const uint8_t point_num = (GRID_MAX_POINTS - count) + 1;
       SERIAL_ECHOLNPGM("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
       TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), point_num, int(GRID_MAX_POINTS)));
 
-      #if HAS_LCD_MENU
+      #if HAS_MARLINUI_MENU
         if (ui.button_pressed()) {
           ui.quick_feedback(false); // Preserve button state for click-and-hold
           SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
           return restore_ubl_active_state_and_leave();
         }
       #endif
@@ -767,46 +767,46 @@ void unified_bed_leveling::shift_mesh_height() {
           ExtUI::onMeshUpdate(best.pos, measured_z);
         #endif
       }
       SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
 
     } while (best.pos.x >= 0 && --count);
 
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_FINISH));
 
     // Release UI during stow to allow for PAUSE_BEFORE_DEPLOY_STOW
-    TERN_(HAS_LCD_MENU, ui.release());
+    TERN_(HAS_MARLINUI_MENU, ui.release());
     probe.stow();
-    TERN_(HAS_LCD_MENU, ui.capture());
+    TERN_(HAS_MARLINUI_MENU, ui.capture());
 
     probe.move_z_after_probing();
 
     restore_ubl_active_state_and_leave();
 
     do_blocking_move_to_xy(
       constrain(nearby.x - probe.offset_xy.x, MESH_MIN_X, MESH_MAX_X),
       constrain(nearby.y - probe.offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
     );
   }
 
 #endif // HAS_BED_PROBE
 
 void set_message_with_feedback(FSTR_P const fstr) {
-  #if HAS_LCD_MENU
+  #if HAS_MARLINUI_MENU
     ui.set_status(fstr);
     ui.quick_feedback();
   #else
     UNUSED(fstr);
   #endif
 }
 
-#if HAS_LCD_MENU
+#if HAS_MARLINUI_MENU
 
   typedef void (*clickFunc_t)();
 
   bool _click_and_hold(const clickFunc_t func=nullptr) {
     if (ui.button_pressed()) {
       ui.quick_feedback(false);         // Preserve button state for click-and-hold
       const millis_t nxt = millis() + 1500UL;
       while (ui.button_pressed()) {     // Loop while the encoder is pressed. Uses hardware flag!
         idle();                         // idle, of course
         if (ELAPSED(millis(), nxt)) {   // After 1.5 seconds
@@ -1063,21 +1063,21 @@ void set_message_with_feedback(FSTR_P const fstr) {
 
     LCD_MESSAGE(MSG_UBL_DONE_EDITING_MESH);
     SERIAL_ECHOLNPGM("Done Editing Mesh");
 
     if (lcd_map_control)
       ui.goto_screen(ubl_map_screen);
     else
       ui.return_to_status();
   }
 
-#endif // HAS_LCD_MENU
+#endif // HAS_MARLINUI_MENU
 
 /**
  * Parse and validate most G29 parameters, store for use by G29 functions.
  */
 bool unified_bed_leveling::G29_parse_parameters() {
   bool err_flag = false;
 
   set_message_with_feedback(GET_TEXT_F(MSG_UBL_DOING_G29));
 
   param.C_constant = 0;
@@ -1203,21 +1203,21 @@ void unified_bed_leveling::save_ubl_active_state_and_disable() {
       SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
       set_message_with_feedback(GET_TEXT_F(MSG_UBL_SAVE_ERROR));
       return;
     }
   #endif
   ubl_state_at_invocation = planner.leveling_active;
   set_bed_leveling_enabled(false);
 }
 
 void unified_bed_leveling::restore_ubl_active_state_and_leave() {
-  TERN_(HAS_LCD_MENU, ui.release());
+  TERN_(HAS_MARLINUI_MENU, ui.release());
   #if ENABLED(UBL_DEVEL_DEBUGGING)
     if (--ubl_state_recursion_chk) {
       SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
       set_message_with_feedback(GET_TEXT_F(MSG_UBL_RESTORE_ERROR));
       return;
     }
   #endif
   set_bed_leveling_enabled(ubl_state_at_invocation);
 }
 

commit 65dfc407a5a57eaaa036475b079153efdd1a51da
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 26 19:36:16 2021 -0500

    🚸 Tweaks to UBL G29 Q

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index d78a5e2578..df83923fef 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -339,27 +339,28 @@ void unified_bed_leveling::G29() {
       invalidate();
       SERIAL_ECHOPGM("Entire Mesh");
     }
     else
       SERIAL_ECHOPGM("Locations");
     SERIAL_ECHOLNPGM(" invalidated.\n");
   }
 
   if (parser.seen('Q')) {
     const int16_t test_pattern = parser.has_value() ? parser.value_int() : -99;
-    if (!WITHIN(test_pattern, -1, 2)) {
-      SERIAL_ECHOLNPGM("Invalid test_pattern value. (-1 to 2)\n");
+    if (!WITHIN(test_pattern, TERN0(UBL_DEVEL_DEBUGGING, -1), 2)) {
+      SERIAL_ECHOLNPGM("?Invalid (Q) test pattern. (" TERN(UBL_DEVEL_DEBUGGING, "-1", "0") " to 2)\n");
       return;
     }
-    SERIAL_ECHOLNPGM("Loading test_pattern values.\n");
+    SERIAL_ECHOLNPGM("Applying test pattern.\n");
     switch (test_pattern) {
 
+      default:
       case -1: TERN_(UBL_DEVEL_DEBUGGING, g29_eeprom_dump()); break;
 
       case 0:
         GRID_LOOP(x, y) {                                     // Create a bowl shape similar to a poorly-calibrated Delta
           const float p1 = 0.5f * (GRID_MAX_POINTS_X) - x,
                       p2 = 0.5f * (GRID_MAX_POINTS_Y) - y;
           z_values[x][y] += 2.0f * HYPOT(p1, p2);
           TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
         }
         break;

commit 1dafd1887e40399faf16e3455e3670ed3acfac52
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 13:46:42 2021 -0500

    🎨 Apply F() to various reports

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 051cb6a4d6..d78a5e2578 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1602,21 +1602,21 @@ void unified_bed_leveling::smart_fill_mesh() {
         DEBUG_ECHO_F(mz, 7);
         DEBUG_ECHOLNPGM("]");
         DEBUG_DELAY(20);
       }
 
       z_values[i][j] = mz - lsf_results.D;
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(i, j, z_values[i][j]));
     }
 
     if (DEBUGGING(LEVELING)) {
-      rotation.debug(PSTR("rotation matrix:\n"));
+      rotation.debug(F("rotation matrix:\n"));
       DEBUG_ECHOPAIR_F("LSF Results A=", lsf_results.A, 7);
       DEBUG_ECHOPAIR_F("  B=", lsf_results.B, 7);
       DEBUG_ECHOLNPAIR_F("  D=", lsf_results.D, 7);
       DEBUG_DELAY(55);
 
       DEBUG_ECHOPAIR_F("bed plane normal = [", normal.x, 7);
       DEBUG_CHAR(',');
       DEBUG_ECHO_F(normal.y, 7);
       DEBUG_CHAR(',');
       DEBUG_ECHO_F(normal.z, 7);
@@ -1629,28 +1629,28 @@ void unified_bed_leveling::smart_fill_mesh() {
        * three points are used in the calculation. This guarantees that each probed point
        * has an exact match when get_z_correction() for that location is calculated.
        * The Z error between the probed point locations and the get_z_correction()
        * numbers for those locations should be 0.
        */
       #ifdef VALIDATE_MESH_TILT
         auto d_from = []{ DEBUG_ECHOPGM("D from "); };
         auto normed = [&](const xy_pos_t &pos, const_float_t zadd) {
           return normal.x * pos.x + normal.y * pos.y + zadd;
         };
-        auto debug_pt = [](PGM_P const pre, const xy_pos_t &pos, const_float_t zadd) {
-          d_from(); SERIAL_ECHOPGM_P(pre);
+        auto debug_pt = [](FSTR_P const pre, const xy_pos_t &pos, const_float_t zadd) {
+          d_from(); SERIAL_ECHOF(pre);
           DEBUG_ECHO_F(normed(pos, zadd), 6);
           DEBUG_ECHOLNPAIR_F("   Z error = ", zadd - get_z_correction(pos), 6);
         };
-        debug_pt(PSTR("1st point: "), probe_pt[0], normal.z * z1);
-        debug_pt(PSTR("2nd point: "), probe_pt[1], normal.z * z2);
-        debug_pt(PSTR("3rd point: "), probe_pt[2], normal.z * z3);
+        debug_pt(F("1st point: "), probe_pt[0], normal.z * z1);
+        debug_pt(F("2nd point: "), probe_pt[1], normal.z * z2);
+        debug_pt(F("3rd point: "), probe_pt[2], normal.z * z3);
         d_from(); DEBUG_ECHOPGM("safe home with Z=");
         DEBUG_ECHOLNPAIR_F("0 : ", normed(safe_homing_xy, 0), 6);
         d_from(); DEBUG_ECHOPGM("safe home with Z=");
         DEBUG_ECHOLNPAIR_F("mesh value ", normed(safe_homing_xy, get_z_correction(safe_homing_xy)), 6);
         DEBUG_ECHOPGM("   Z error = (", Z_SAFE_HOMING_X_POINT, ",", Z_SAFE_HOMING_Y_POINT);
         DEBUG_ECHOLNPAIR_F(") = ", get_z_correction(safe_homing_xy), 6);
       #endif
     } // DEBUGGING(LEVELING)
 
   }

commit 7f1286a11f87065c4e666985e679cf9c77d668bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 17:05:11 2021 -0500

    🎨 Apply F() to status message

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 9b85b5b972..051cb6a4d6 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -729,21 +729,21 @@ void unified_bed_leveling::shift_mesh_height() {
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
     uint8_t count = GRID_MAX_POINTS;
 
     mesh_index_pair best;
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_START));
     do {
       if (do_ubl_mesh_map) display_map(param.T_map_type);
 
       const uint8_t point_num = (GRID_MAX_POINTS - count) + 1;
       SERIAL_ECHOLNPGM("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
-      TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), point_num, int(GRID_MAX_POINTS)));
+      TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), point_num, int(GRID_MAX_POINTS)));
 
       #if HAS_LCD_MENU
         if (ui.button_pressed()) {
           ui.quick_feedback(false); // Preserve button state for click-and-hold
           SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
           return restore_ubl_active_state_and_leave();
@@ -782,26 +782,26 @@ void unified_bed_leveling::shift_mesh_height() {
     restore_ubl_active_state_and_leave();
 
     do_blocking_move_to_xy(
       constrain(nearby.x - probe.offset_xy.x, MESH_MIN_X, MESH_MAX_X),
       constrain(nearby.y - probe.offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
     );
   }
 
 #endif // HAS_BED_PROBE
 
-void set_message_with_feedback(PGM_P const msg_P) {
+void set_message_with_feedback(FSTR_P const fstr) {
   #if HAS_LCD_MENU
-    ui.set_status_P(msg_P);
+    ui.set_status(fstr);
     ui.quick_feedback();
   #else
-    UNUSED(msg_P);
+    UNUSED(fstr);
   #endif
 }
 
 #if HAS_LCD_MENU
 
   typedef void (*clickFunc_t)();
 
   bool _click_and_hold(const clickFunc_t func=nullptr) {
     if (ui.button_pressed()) {
       ui.quick_feedback(false);         // Preserve button state for click-and-hold
@@ -843,30 +843,30 @@ void set_message_with_feedback(PGM_P const msg_P) {
 
   float unified_bed_leveling::measure_business_card_thickness() {
     ui.capture();
     save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
     do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), MANUAL_PROBE_START_Z);
       //, _MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f);
     planner.synchronize();
 
     SERIAL_ECHOPGM("Place shim under nozzle");
-    LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
+    LCD_MESSAGE(MSG_UBL_BC_INSERT);
     ui.return_to_status();
     echo_and_take_a_measurement();
 
     const float z1 = measure_point_with_encoder();
     do_blocking_move_to_z(current_position.z + SIZE_OF_LITTLE_RAISE);
     planner.synchronize();
 
     SERIAL_ECHOPGM("Remove shim");
-    LCD_MESSAGEPGM(MSG_UBL_BC_REMOVE);
+    LCD_MESSAGE(MSG_UBL_BC_REMOVE);
     echo_and_take_a_measurement();
 
     const float z2 = measure_point_with_encoder();
     do_blocking_move_to_z(current_position.z + Z_CLEARANCE_BETWEEN_PROBES);
 
     const float thickness = ABS(z1 - z2);
 
     if (param.V_verbosity > 1) {
       SERIAL_ECHOPAIR_F("Business Card is ", thickness, 4);
       SERIAL_ECHOLNPGM("mm thick.");
@@ -898,37 +898,37 @@ void set_message_with_feedback(PGM_P const msg_P) {
       if (!location.valid()) continue;
 
       const xyz_pos_t ppos = {
         mesh_index_to_xpos(lpos.x),
         mesh_index_to_ypos(lpos.y),
         z_clearance
       };
 
       if (!position_is_reachable(ppos)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
 
-      LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
+      LCD_MESSAGE(MSG_UBL_MOVING_TO_NEXT);
 
       do_blocking_move_to(ppos);
       do_z_clearance(z_clearance);
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       ui.capture();
 
       if (do_ubl_mesh_map) display_map(param.T_map_type);   // Show user where we're probing
 
       if (parser.seen_test('B')) {
         SERIAL_ECHOPGM("Place Shim & Measure");
-        LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
+        LCD_MESSAGE(MSG_UBL_BC_INSERT);
       }
       else {
         SERIAL_ECHOPGM("Measure");
-        LCD_MESSAGEPGM(MSG_UBL_BC_INSERT2);
+        LCD_MESSAGE(MSG_UBL_BC_INSERT2);
       }
 
       const float z_step = 0.01f;                         // 0.01mm per encoder tick, occasionally step
       move_z_with_encoder(z_step);
 
       if (_click_and_hold([]{
         SERIAL_ECHOLNPGM("\nMesh only partially populated.");
         do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
       })) return restore_ubl_active_state_and_leave();
 
@@ -967,21 +967,21 @@ void set_message_with_feedback(PGM_P const msg_P) {
 
     mesh_index_pair location;
 
     if (!position_is_reachable(pos)) {
       SERIAL_ECHOLNPGM("(X,Y) outside printable radius.");
       return;
     }
 
     save_ubl_active_state_and_disable();
 
-    LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
+    LCD_MESSAGE(MSG_UBL_FINE_TUNE_MESH);
     ui.capture();                                               // Take over control of the LCD encoder
 
     do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES);  // Move to the given XY with probe clearance
 
     MeshFlags done_flags{0};
     const xy_int8_t &lpos = location.pos;
 
     #if IS_TFTGLCD_PANEL
       ui.ubl_mesh_edit_start(0);                          // Change current screen before calling ui.ubl_plot
       safe_delay(50);
@@ -1032,59 +1032,59 @@ void set_message_with_feedback(PGM_P const msg_P) {
       } while (!ui.button_pressed());
 
       SET_SOFT_ENDSTOP_LOOSE(false);
 
       if (!lcd_map_control) ui.return_to_status();        // Just editing a single point? Return to status
 
       // Button held down? Abort editing
       if (_click_and_hold([]{
         ui.return_to_status();
         do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
-        set_message_with_feedback(GET_TEXT(MSG_EDITING_STOPPED));
+        set_message_with_feedback(GET_TEXT_F(MSG_EDITING_STOPPED));
       })) break;
 
       // TODO: Disable leveling here so the Z value becomes the 'native' Z value.
 
       z_values[lpos.x][lpos.y] = new_z;                   // Save the updated Z value
 
       // TODO: Re-enable leveling here so Z is correctly based on the updated mesh.
 
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, new_z));
 
       serial_delay(20);                                   // No switch noise
       ui.refresh();
 
     } while (lpos.x >= 0 && --param.R_repetition > 0);
 
     if (do_ubl_mesh_map) display_map(param.T_map_type);
     restore_ubl_active_state_and_leave();
 
     do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES);
 
-    LCD_MESSAGEPGM(MSG_UBL_DONE_EDITING_MESH);
+    LCD_MESSAGE(MSG_UBL_DONE_EDITING_MESH);
     SERIAL_ECHOLNPGM("Done Editing Mesh");
 
     if (lcd_map_control)
       ui.goto_screen(ubl_map_screen);
     else
       ui.return_to_status();
   }
 
 #endif // HAS_LCD_MENU
 
 /**
  * Parse and validate most G29 parameters, store for use by G29 functions.
  */
 bool unified_bed_leveling::G29_parse_parameters() {
   bool err_flag = false;
 
-  set_message_with_feedback(GET_TEXT(MSG_UBL_DOING_G29));
+  set_message_with_feedback(GET_TEXT_F(MSG_UBL_DOING_G29));
 
   param.C_constant = 0;
   param.R_repetition = 0;
 
   if (parser.seen('R')) {
     param.R_repetition = parser.has_value() ? parser.value_byte() : GRID_MAX_POINTS;
     NOMORE(param.R_repetition, GRID_MAX_POINTS);
     if (param.R_repetition < 1) {
       SERIAL_ECHOLNPGM("?(R)epetition count invalid (1+).\n");
       return UBL_ERR;
@@ -1193,34 +1193,34 @@ static uint8_t ubl_state_at_invocation = 0;
 
 #if ENABLED(UBL_DEVEL_DEBUGGING)
   static uint8_t ubl_state_recursion_chk = 0;
 #endif
 
 void unified_bed_leveling::save_ubl_active_state_and_disable() {
   #if ENABLED(UBL_DEVEL_DEBUGGING)
     ubl_state_recursion_chk++;
     if (ubl_state_recursion_chk != 1) {
       SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
-      set_message_with_feedback(GET_TEXT(MSG_UBL_SAVE_ERROR));
+      set_message_with_feedback(GET_TEXT_F(MSG_UBL_SAVE_ERROR));
       return;
     }
   #endif
   ubl_state_at_invocation = planner.leveling_active;
   set_bed_leveling_enabled(false);
 }
 
 void unified_bed_leveling::restore_ubl_active_state_and_leave() {
   TERN_(HAS_LCD_MENU, ui.release());
   #if ENABLED(UBL_DEVEL_DEBUGGING)
     if (--ubl_state_recursion_chk) {
       SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
-      set_message_with_feedback(GET_TEXT(MSG_UBL_RESTORE_ERROR));
+      set_message_with_feedback(GET_TEXT_F(MSG_UBL_RESTORE_ERROR));
       return;
     }
   #endif
   set_bed_leveling_enabled(ubl_state_at_invocation);
 }
 
 mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
   bool found_a_NAN = false, found_a_real = false;
 
@@ -1431,60 +1431,60 @@ void unified_bed_leveling::smart_fill_mesh() {
 
     #ifdef VALIDATE_MESH_TILT
       float z1, z2, z3;  // Needed for algorithm validation below
     #endif
 
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
 
     if (do_3_pt_leveling) {
       SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
-      TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " 1/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
+      TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " 1/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
       measured_z = probe.probe_at_point(points[0], PROBE_PT_RAISE, param.V_verbosity);
       if (isnan(measured_z))
         abort_flag = true;
       else {
         measured_z -= get_z_correction(points[0]);
         #ifdef VALIDATE_MESH_TILT
           z1 = measured_z;
         #endif
         if (param.V_verbosity > 3) {
           serial_spaces(16);
           SERIAL_ECHOLNPGM("Corrected_Z=", measured_z);
         }
         incremental_LSF(&lsf_results, points[0], measured_z);
       }
 
       if (!abort_flag) {
         SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
-        TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " 2/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
+        TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " 2/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
         measured_z = probe.probe_at_point(points[1], PROBE_PT_RAISE, param.V_verbosity);
         #ifdef VALIDATE_MESH_TILT
           z2 = measured_z;
         #endif
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[1]);
           if (param.V_verbosity > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPGM("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, points[1], measured_z);
         }
       }
 
       if (!abort_flag) {
         SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
-        TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
+        TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
         measured_z = probe.probe_at_point(points[2], PROBE_PT_LAST_STOW, param.V_verbosity);
         #ifdef VALIDATE_MESH_TILT
           z3 = measured_z;
         #endif
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[2]);
           if (param.V_verbosity > 3) {
@@ -1511,21 +1511,21 @@ void unified_bed_leveling::smart_fill_mesh() {
       uint16_t point_num = 1;
 
       xy_pos_t rpos;
       LOOP_L_N(ix, param.J_grid_size) {
         rpos.x = x_min + ix * dx;
         LOOP_L_N(iy, param.J_grid_size) {
           rpos.y = y_min + dy * (zig_zag ? param.J_grid_size - 1 - iy : iy);
 
           if (!abort_flag) {
             SERIAL_ECHOLNPGM("Tilting mesh point ", point_num, "/", total_points, "\n");
-            TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
+            TERN_(HAS_STATUS_MESSAGE, ui.status_printf(0, F(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
 
             measured_z = probe.probe_at_point(rpos, parser.seen_test('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity); // TODO: Needs error handling
 
             abort_flag = isnan(measured_z);
 
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) {
                 const xy_pos_t lpos = rpos.asLogical();
                 DEBUG_CHAR('(');
                 DEBUG_ECHO_F(rpos.x, 7);

commit 59dac3a7e41ae7964686d9dff56baba821a278f7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 18:43:52 2021 -0500

    🎨 Apply F() to G-code subcommands

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 750c63f7c6..9b85b5b972 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -649,21 +649,21 @@ void unified_bed_leveling::G29() {
     ui.reset_alert_level();
     ui.quick_feedback();
     ui.reset_status();
     ui.release();
   #endif
 
   #ifdef Z_PROBE_END_SCRIPT
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     if (probe_deployed) {
       planner.synchronize();
-      gcode.process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
+      gcode.process_subcommands_now(F(Z_PROBE_END_SCRIPT));
     }
   #else
     UNUSED(probe_deployed);
   #endif
 
   TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index));
   return;
 }
 
 /**

commit fede20fbe69d4d3687a07b4a9cb70b681f5c51b3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 17 18:58:55 2021 -0500

    💬 Add non-translated STR_DONE

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 747c61a8b9..750c63f7c6 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -602,21 +602,21 @@ void unified_bed_leveling::G29() {
     }
 
     if (!WITHIN(param.KLS_storage_slot, 0, a - 1)) {
       SERIAL_ECHOLNPGM("?Invalid storage slot.\n?Use 0 to ", a - 1);
       return;
     }
 
     settings.load_mesh(param.KLS_storage_slot);
     storage_slot = param.KLS_storage_slot;
 
-    SERIAL_ECHOLNPGM("Done.");
+    SERIAL_ECHOLNPGM(STR_DONE);
   }
 
   //
   // Store a Mesh in the EEPROM
   //
 
   if (parser.seen('S')) {     // Store (or Save) Current Mesh Data
     param.KLS_storage_slot = parser.has_value() ? (int8_t)parser.value_int() : storage_slot;
 
     if (param.KLS_storage_slot == -1)               // Special case: 'Export' the mesh to the
@@ -630,21 +630,21 @@ void unified_bed_leveling::G29() {
     }
 
     if (!WITHIN(param.KLS_storage_slot, 0, a - 1)) {
       SERIAL_ECHOLNPGM("?Invalid storage slot.\n?Use 0 to ", a - 1);
       goto LEAVE;
     }
 
     settings.store_mesh(param.KLS_storage_slot);
     storage_slot = param.KLS_storage_slot;
 
-    SERIAL_ECHOLNPGM("Done.");
+    SERIAL_ECHOLNPGM(STR_DONE);
   }
 
   if (parser.seen_test('T'))
     display_map(param.T_map_type);
 
   LEAVE:
 
   #if HAS_LCD_MENU
     ui.reset_alert_level();
     ui.quick_feedback();

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    🎨 Fewer serial macros

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index ceedd316e3..747c61a8b9 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -421,21 +421,21 @@ void unified_bed_leveling::G29() {
 
         case 1: {
           //
           // Invalidate Entire Mesh and Automatically Probe Mesh in areas that can be reached by the probe
           //
           if (!parser.seen_test('C')) {
             invalidate();
             SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
           }
           if (param.V_verbosity > 1) {
-            SERIAL_ECHOPAIR("Probing around (", param.XY_pos.x);
+            SERIAL_ECHOPGM("Probing around (", param.XY_pos.x);
             SERIAL_CHAR(',');
             SERIAL_DECIMAL(param.XY_pos.y);
             SERIAL_ECHOLNPGM(").\n");
           }
           probe_entire_mesh(param.XY_pos, parser.seen_test('T'), parser.seen_test('E'), parser.seen_test('U'));
 
           report_current_position();
           probe_deployed = true;
         } break;
 
@@ -595,21 +595,21 @@ void unified_bed_leveling::G29() {
     param.KLS_storage_slot = parser.has_value() ? (int8_t)parser.value_int() : storage_slot;
 
     int16_t a = settings.calc_num_meshes();
 
     if (!a) {
       SERIAL_ECHOLNPGM("?EEPROM storage not available.");
       return;
     }
 
     if (!WITHIN(param.KLS_storage_slot, 0, a - 1)) {
-      SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
+      SERIAL_ECHOLNPGM("?Invalid storage slot.\n?Use 0 to ", a - 1);
       return;
     }
 
     settings.load_mesh(param.KLS_storage_slot);
     storage_slot = param.KLS_storage_slot;
 
     SERIAL_ECHOLNPGM("Done.");
   }
 
   //
@@ -623,21 +623,21 @@ void unified_bed_leveling::G29() {
       return report_current_mesh();                 // host so it can be saved in a file.
 
     int16_t a = settings.calc_num_meshes();
 
     if (!a) {
       SERIAL_ECHOLNPGM("?EEPROM storage not available.");
       goto LEAVE;
     }
 
     if (!WITHIN(param.KLS_storage_slot, 0, a - 1)) {
-      SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
+      SERIAL_ECHOLNPGM("?Invalid storage slot.\n?Use 0 to ", a - 1);
       goto LEAVE;
     }
 
     settings.store_mesh(param.KLS_storage_slot);
     storage_slot = param.KLS_storage_slot;
 
     SERIAL_ECHOLNPGM("Done.");
   }
 
   if (parser.seen_test('T'))
@@ -646,21 +646,21 @@ void unified_bed_leveling::G29() {
   LEAVE:
 
   #if HAS_LCD_MENU
     ui.reset_alert_level();
     ui.quick_feedback();
     ui.reset_status();
     ui.release();
   #endif
 
   #ifdef Z_PROBE_END_SCRIPT
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
     if (probe_deployed) {
       planner.synchronize();
       gcode.process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
     }
   #else
     UNUSED(probe_deployed);
   #endif
 
   TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index));
   return;
@@ -683,21 +683,21 @@ void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const_float_t o
   const float mean = sum / n;
 
   //
   // Sum the squares of difference from mean
   //
   float sum_of_diff_squared = 0;
   GRID_LOOP(x, y)
     if (!isnan(z_values[x][y]))
       sum_of_diff_squared += sq(z_values[x][y] - mean);
 
-  SERIAL_ECHOLNPAIR("# of samples: ", n);
+  SERIAL_ECHOLNPGM("# of samples: ", n);
   SERIAL_ECHOLNPAIR_F("Mean Mesh Height: ", mean, 6);
 
   const float sigma = SQRT(sum_of_diff_squared / (n + 1));
   SERIAL_ECHOLNPAIR_F("Standard Deviation: ", sigma, 6);
 
   if (cflag)
     GRID_LOOP(x, y)
       if (!isnan(z_values[x][y])) {
         z_values[x][y] -= mean + offset;
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
@@ -728,21 +728,21 @@ void unified_bed_leveling::shift_mesh_height() {
 
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
     uint8_t count = GRID_MAX_POINTS;
 
     mesh_index_pair best;
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_START));
     do {
       if (do_ubl_mesh_map) display_map(param.T_map_type);
 
       const uint8_t point_num = (GRID_MAX_POINTS - count) + 1;
-      SERIAL_ECHOLNPAIR("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
+      SERIAL_ECHOLNPGM("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
       TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), point_num, int(GRID_MAX_POINTS)));
 
       #if HAS_LCD_MENU
         if (ui.button_pressed()) {
           ui.quick_feedback(false); // Preserve button state for click-and-hold
           SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
@@ -1443,60 +1443,60 @@ void unified_bed_leveling::smart_fill_mesh() {
       measured_z = probe.probe_at_point(points[0], PROBE_PT_RAISE, param.V_verbosity);
       if (isnan(measured_z))
         abort_flag = true;
       else {
         measured_z -= get_z_correction(points[0]);
         #ifdef VALIDATE_MESH_TILT
           z1 = measured_z;
         #endif
         if (param.V_verbosity > 3) {
           serial_spaces(16);
-          SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
+          SERIAL_ECHOLNPGM("Corrected_Z=", measured_z);
         }
         incremental_LSF(&lsf_results, points[0], measured_z);
       }
 
       if (!abort_flag) {
         SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " 2/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
         measured_z = probe.probe_at_point(points[1], PROBE_PT_RAISE, param.V_verbosity);
         #ifdef VALIDATE_MESH_TILT
           z2 = measured_z;
         #endif
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[1]);
           if (param.V_verbosity > 3) {
             serial_spaces(16);
-            SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
+            SERIAL_ECHOLNPGM("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, points[1], measured_z);
         }
       }
 
       if (!abort_flag) {
         SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
         measured_z = probe.probe_at_point(points[2], PROBE_PT_LAST_STOW, param.V_verbosity);
         #ifdef VALIDATE_MESH_TILT
           z3 = measured_z;
         #endif
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[2]);
           if (param.V_verbosity > 3) {
             serial_spaces(16);
-            SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
+            SERIAL_ECHOLNPGM("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, points[2], measured_z);
         }
       }
 
       probe.stow();
       probe.move_z_after_probing();
 
       if (abort_flag) {
         SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");
@@ -1510,21 +1510,21 @@ void unified_bed_leveling::smart_fill_mesh() {
       const uint16_t total_points = sq(param.J_grid_size);
       uint16_t point_num = 1;
 
       xy_pos_t rpos;
       LOOP_L_N(ix, param.J_grid_size) {
         rpos.x = x_min + ix * dx;
         LOOP_L_N(iy, param.J_grid_size) {
           rpos.y = y_min + dy * (zig_zag ? param.J_grid_size - 1 - iy : iy);
 
           if (!abort_flag) {
-            SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
+            SERIAL_ECHOLNPGM("Tilting mesh point ", point_num, "/", total_points, "\n");
             TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
 
             measured_z = probe.probe_at_point(rpos, parser.seen_test('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity); // TODO: Needs error handling
 
             abort_flag = isnan(measured_z);
 
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) {
                 const xy_pos_t lpos = rpos.asLogical();
                 DEBUG_CHAR('(');
@@ -1538,21 +1538,21 @@ void unified_bed_leveling::smart_fill_mesh() {
                 DEBUG_ECHOPAIR_F("   correction: ", get_z_correction(rpos), 7);
               }
             #endif
 
             measured_z -= get_z_correction(rpos) /* + probe.offset.z */ ;
 
             if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("   final >>>---> ", measured_z, 7);
 
             if (param.V_verbosity > 3) {
               serial_spaces(16);
-              SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
+              SERIAL_ECHOLNPGM("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, rpos, measured_z);
           }
 
           point_num++;
         }
 
         zig_zag ^= true;
       }
     }
@@ -1641,21 +1641,21 @@ void unified_bed_leveling::smart_fill_mesh() {
           DEBUG_ECHO_F(normed(pos, zadd), 6);
           DEBUG_ECHOLNPAIR_F("   Z error = ", zadd - get_z_correction(pos), 6);
         };
         debug_pt(PSTR("1st point: "), probe_pt[0], normal.z * z1);
         debug_pt(PSTR("2nd point: "), probe_pt[1], normal.z * z2);
         debug_pt(PSTR("3rd point: "), probe_pt[2], normal.z * z3);
         d_from(); DEBUG_ECHOPGM("safe home with Z=");
         DEBUG_ECHOLNPAIR_F("0 : ", normed(safe_homing_xy, 0), 6);
         d_from(); DEBUG_ECHOPGM("safe home with Z=");
         DEBUG_ECHOLNPAIR_F("mesh value ", normed(safe_homing_xy, get_z_correction(safe_homing_xy)), 6);
-        DEBUG_ECHOPAIR("   Z error = (", Z_SAFE_HOMING_X_POINT, ",", Z_SAFE_HOMING_Y_POINT);
+        DEBUG_ECHOPGM("   Z error = (", Z_SAFE_HOMING_X_POINT, ",", Z_SAFE_HOMING_Y_POINT);
         DEBUG_ECHOLNPAIR_F(") = ", get_z_correction(safe_homing_xy), 6);
       #endif
     } // DEBUGGING(LEVELING)
 
   }
 
 #endif // HAS_BED_PROBE
 
 #if ENABLED(UBL_G29_P31)
   void unified_bed_leveling::smart_fill_wlsf(const_float_t weight_factor) {
@@ -1715,81 +1715,81 @@ void unified_bed_leveling::smart_fill_mesh() {
   /**
    * Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
    * good to have the extra information. Soon... we prune this to just a few items
    */
   void unified_bed_leveling::g29_what_command() {
     report_state();
 
     if (storage_slot == -1)
       SERIAL_ECHOPGM("No Mesh Loaded.");
     else
-      SERIAL_ECHOPAIR("Mesh ", storage_slot, " Loaded.");
+      SERIAL_ECHOPGM("Mesh ", storage_slot, " Loaded.");
     SERIAL_EOL();
     serial_delay(50);
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       SERIAL_ECHOLNPAIR_F("Fade Height M420 Z", planner.z_fade_height, 4);
     #endif
 
     adjust_mesh_to_mean(param.C_seen, param.C_constant);
 
     #if HAS_BED_PROBE
       SERIAL_ECHOLNPAIR_F("Probe Offset M851 Z", probe.offset.z, 7);
     #endif
 
-    SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X); serial_delay(50);
-    SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); serial_delay(50);
-    SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); serial_delay(50);
-    SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); serial_delay(50);
-    SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             serial_delay(50);
-    SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);             serial_delay(50);
-    SERIAL_ECHOLNPAIR("MESH_X_DIST  ", MESH_X_DIST);
-    SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);                         serial_delay(50);
+    SERIAL_ECHOLNPGM("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X); serial_delay(50);
+    SERIAL_ECHOLNPGM("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); serial_delay(50);
+    SERIAL_ECHOLNPGM("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); serial_delay(50);
+    SERIAL_ECHOLNPGM("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); serial_delay(50);
+    SERIAL_ECHOLNPGM("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             serial_delay(50);
+    SERIAL_ECHOLNPGM("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);             serial_delay(50);
+    SERIAL_ECHOLNPGM("MESH_X_DIST  ", MESH_X_DIST);
+    SERIAL_ECHOLNPGM("MESH_Y_DIST  ", MESH_Y_DIST);                         serial_delay(50);
 
     SERIAL_ECHOPGM("X-Axis Mesh Points at: ");
     LOOP_L_N(i, GRID_MAX_POINTS_X) {
       SERIAL_ECHO_F(LOGICAL_X_POSITION(mesh_index_to_xpos(i)), 3);
       SERIAL_ECHOPGM("  ");
       serial_delay(25);
     }
     SERIAL_EOL();
 
     SERIAL_ECHOPGM("Y-Axis Mesh Points at: ");
     LOOP_L_N(i, GRID_MAX_POINTS_Y) {
       SERIAL_ECHO_F(LOGICAL_Y_POSITION(mesh_index_to_ypos(i)), 3);
       SERIAL_ECHOPGM("  ");
       serial_delay(25);
     }
     SERIAL_EOL();
 
     #if HAS_KILL
-      SERIAL_ECHOLNPAIR("Kill pin on :", KILL_PIN, "  state:", kill_state());
+      SERIAL_ECHOLNPGM("Kill pin on :", KILL_PIN, "  state:", kill_state());
     #endif
 
     SERIAL_EOL();
     serial_delay(50);
 
     #if ENABLED(UBL_DEVEL_DEBUGGING)
-      SERIAL_ECHOLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation, "\nubl_state_recursion_chk :", ubl_state_recursion_chk);
+      SERIAL_ECHOLNPGM("ubl_state_at_invocation :", ubl_state_at_invocation, "\nubl_state_recursion_chk :", ubl_state_recursion_chk);
       serial_delay(50);
 
-      SERIAL_ECHOLNPAIR("Meshes go from ", hex_address((void*)settings.meshes_start_index()), " to ", hex_address((void*)settings.meshes_end_index()));
+      SERIAL_ECHOLNPGM("Meshes go from ", hex_address((void*)settings.meshes_start_index()), " to ", hex_address((void*)settings.meshes_end_index()));
       serial_delay(50);
 
-      SERIAL_ECHOLNPAIR("sizeof(ubl) :  ", sizeof(ubl));         SERIAL_EOL();
-      SERIAL_ECHOLNPAIR("z_value[][] size: ", sizeof(z_values)); SERIAL_EOL();
+      SERIAL_ECHOLNPGM("sizeof(ubl) :  ", sizeof(ubl));         SERIAL_EOL();
+      SERIAL_ECHOLNPGM("z_value[][] size: ", sizeof(z_values)); SERIAL_EOL();
       serial_delay(25);
 
-      SERIAL_ECHOLNPAIR("EEPROM free for UBL: ", hex_address((void*)(settings.meshes_end_index() - settings.meshes_start_index())));
+      SERIAL_ECHOLNPGM("EEPROM free for UBL: ", hex_address((void*)(settings.meshes_end_index() - settings.meshes_start_index())));
       serial_delay(50);
 
-      SERIAL_ECHOLNPAIR("EEPROM can hold ", settings.calc_num_meshes(), " meshes.\n");
+      SERIAL_ECHOLNPGM("EEPROM can hold ", settings.calc_num_meshes(), " meshes.\n");
       serial_delay(25);
     #endif // UBL_DEVEL_DEBUGGING
 
     if (!sanity_check()) {
       echo_name();
       SERIAL_ECHOLNPGM(" sanity checks passed.");
     }
   }
 
   /**
@@ -1822,30 +1822,30 @@ void unified_bed_leveling::smart_fill_mesh() {
    */
   void unified_bed_leveling::g29_compare_current_mesh_to_stored_mesh() {
     const int16_t a = settings.calc_num_meshes();
 
     if (!a) {
       SERIAL_ECHOLNPGM("?EEPROM storage not available.");
       return;
     }
 
     if (!parser.has_value() || !WITHIN(parser.value_int(), 0, a - 1)) {
-      SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
+      SERIAL_ECHOLNPGM("?Invalid storage slot.\n?Use 0 to ", a - 1);
       return;
     }
 
     param.KLS_storage_slot = (int8_t)parser.value_int();
 
     float tmp_z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
     settings.load_mesh(param.KLS_storage_slot, &tmp_z_values);
 
-    SERIAL_ECHOLNPAIR("Subtracting mesh in slot ", param.KLS_storage_slot, " from current mesh.");
+    SERIAL_ECHOLNPGM("Subtracting mesh in slot ", param.KLS_storage_slot, " from current mesh.");
 
     GRID_LOOP(x, y) {
       z_values[x][y] -= tmp_z_values[x][y];
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
     }
   }
 
 #endif // UBL_DEVEL_DEBUGGING
 
 #endif // AUTO_BED_LEVELING_UBL

commit eccd82b7c1049b098546334fab7ac152e1fa1ce7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 11 18:15:36 2020 -0600

    ⚡️ Add PROBE_PT_LAST_STOW

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 84bb7f9c4c..ceedd316e3 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1472,21 +1472,21 @@ void unified_bed_leveling::smart_fill_mesh() {
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, points[1], measured_z);
         }
       }
 
       if (!abort_flag) {
         SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
-        measured_z = probe.probe_at_point(points[2], PROBE_PT_STOW, param.V_verbosity);
+        measured_z = probe.probe_at_point(points[2], PROBE_PT_LAST_STOW, param.V_verbosity);
         #ifdef VALIDATE_MESH_TILT
           z3 = measured_z;
         #endif
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[2]);
           if (param.V_verbosity > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);

commit d95d452b29b80e66d534b36c78262454664ce5a1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Aug 29 23:02:53 2021 -0500

    🌐 MSG_PROBING_MESH => MSG_PROBING_POINT

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index f8e446cf81..84bb7f9c4c 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -729,21 +729,21 @@ void unified_bed_leveling::shift_mesh_height() {
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
     uint8_t count = GRID_MAX_POINTS;
 
     mesh_index_pair best;
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_START));
     do {
       if (do_ubl_mesh_map) display_map(param.T_map_type);
 
       const uint8_t point_num = (GRID_MAX_POINTS - count) + 1;
       SERIAL_ECHOLNPAIR("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
-      TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), point_num, int(GRID_MAX_POINTS)));
+      TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_POINT), point_num, int(GRID_MAX_POINTS)));
 
       #if HAS_LCD_MENU
         if (ui.button_pressed()) {
           ui.quick_feedback(false); // Preserve button state for click-and-hold
           SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
           return restore_ubl_active_state_and_leave();

commit 9d86241d30da0946aa1b16d77fe5f8ef95a9996b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 18 00:45:17 2021 -0500

    🐛 No translated serial strings

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index e1ed013cf2..f8e446cf81 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -909,25 +909,25 @@ void set_message_with_feedback(PGM_P const msg_P) {
 
       do_blocking_move_to(ppos);
       do_z_clearance(z_clearance);
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       ui.capture();
 
       if (do_ubl_mesh_map) display_map(param.T_map_type);   // Show user where we're probing
 
       if (parser.seen_test('B')) {
-        SERIAL_ECHOPGM_P(GET_TEXT(MSG_UBL_BC_INSERT));
+        SERIAL_ECHOPGM("Place Shim & Measure");
         LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       }
       else {
-        SERIAL_ECHOPGM_P(GET_TEXT(MSG_UBL_BC_INSERT2));
+        SERIAL_ECHOPGM("Measure");
         LCD_MESSAGEPGM(MSG_UBL_BC_INSERT2);
       }
 
       const float z_step = 0.01f;                         // 0.01mm per encoder tick, occasionally step
       move_z_with_encoder(z_step);
 
       if (_click_and_hold([]{
         SERIAL_ECHOLNPGM("\nMesh only partially populated.");
         do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
       })) return restore_ubl_active_state_and_leave();

commit 26bfc267977ddc444513c793c18f76847e23310e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 9 17:09:58 2021 -0500

    🎨 Check flags without ENABLED

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index e144390c8d..e1ed013cf2 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -300,21 +300,21 @@
 
 G29_parameters_t unified_bed_leveling::param;
 
 void unified_bed_leveling::G29() {
 
   bool probe_deployed = false;
   if (G29_parse_parameters()) return; // Abort on parameter error
 
   const uint8_t p_val = parser.byteval('P');
   const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen_test('J');
-  #if ENABLED(HAS_MULTI_HOTEND)
+  #if HAS_MULTI_HOTEND
     const uint8_t old_tool_index = active_extruder;
   #endif
 
   // Check for commands that require the printer to be homed
   if (may_move) {
     planner.synchronize();
     // Send 'N' to force homing before G29 (internal only)
     if (axes_should_home() || parser.seen_test('N')) gcode.home_all_axes();
     TERN_(HAS_MULTI_HOTEND, if (active_extruder) tool_change(0));
   }

commit 6b3dc80b551e2a46776f157060e92cc7727d3bc9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 14 18:44:27 2021 -0500

    🐛 Prevent stepper sleep during long UBL idle (#22137)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 11c05f6054..e144390c8d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1018,21 +1018,21 @@ void set_message_with_feedback(PGM_P const msg_P) {
 
       float new_z = z_values[lpos.x][lpos.y];
       if (isnan(new_z)) new_z = 0;                        // Invalid points begin at 0
       new_z = FLOOR(new_z * 1000) * 0.001f;               // Chop off digits after the 1000ths place
 
       ui.ubl_mesh_edit_start(new_z);
 
       SET_SOFT_ENDSTOP_LOOSE(true);
 
       do {
-        idle();
+        idle_no_sleep();
         new_z = ui.ubl_mesh_value();
         TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset + new_z)); // Move the nozzle as the point is edited
         SERIAL_FLUSH();                                   // Prevent host M105 buffer overrun.
       } while (!ui.button_pressed());
 
       SET_SOFT_ENDSTOP_LOOSE(false);
 
       if (!lcd_map_control) ui.return_to_status();        // Just editing a single point? Return to status
 
       // Button held down? Abort editing

commit 3a03f76f3c82e93800a07dd2b28a34d0c53245e3
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Sun Jun 13 18:43:43 2021 -0700

    🐛 Fix UBL 'R' parameter and adjust 'P' (#22129)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index b5773b0d46..11c05f6054 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -298,37 +298,37 @@
  *   features of all three systems combined.
  */
 
 G29_parameters_t unified_bed_leveling::param;
 
 void unified_bed_leveling::G29() {
 
   bool probe_deployed = false;
   if (G29_parse_parameters()) return; // Abort on parameter error
 
-  const int8_t p_val = parser.intval('P', -1);
+  const uint8_t p_val = parser.byteval('P');
   const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen_test('J');
   #if ENABLED(HAS_MULTI_HOTEND)
     const uint8_t old_tool_index = active_extruder;
   #endif
 
   // Check for commands that require the printer to be homed
   if (may_move) {
     planner.synchronize();
     // Send 'N' to force homing before G29 (internal only)
     if (axes_should_home() || parser.seen_test('N')) gcode.home_all_axes();
     TERN_(HAS_MULTI_HOTEND, if (active_extruder) tool_change(0));
   }
 
   // Invalidate one or more nearby mesh points, possibly all.
   if (parser.seen('I')) {
-    int16_t count = parser.has_value() ? parser.value_int() : 1;
+    uint8_t count = parser.has_value() ? parser.value_byte() : 1;
     bool invalidate_all = count >= GRID_MAX_POINTS;
     if (!invalidate_all) {
       while (count--) {
         if ((count & 0x0F) == 0x0F) idle();
         const mesh_index_pair closest = find_closest_mesh_point_of_type(REAL, param.XY_pos);
         // No more REAL mesh points to invalidate? Assume the user meant
         // to invalidate the ENTIRE mesh, which can't be done with
         // find_closest_mesh_point (which only returns REAL points).
         if (closest.pos.x < 0) { invalidate_all = true; break; }
         z_values[closest.pos.x][closest.pos.y] = NAN;
@@ -338,21 +338,21 @@ void unified_bed_leveling::G29() {
     if (invalidate_all) {
       invalidate();
       SERIAL_ECHOPGM("Entire Mesh");
     }
     else
       SERIAL_ECHOPGM("Locations");
     SERIAL_ECHOLNPGM(" invalidated.\n");
   }
 
   if (parser.seen('Q')) {
-    const int test_pattern = parser.has_value() ? parser.value_int() : -99;
+    const int16_t test_pattern = parser.has_value() ? parser.value_int() : -99;
     if (!WITHIN(test_pattern, -1, 2)) {
       SERIAL_ECHOLNPGM("Invalid test_pattern value. (-1 to 2)\n");
       return;
     }
     SERIAL_ECHOLNPGM("Loading test_pattern values.\n");
     switch (test_pattern) {
 
       case -1: TERN_(UBL_DEVEL_DEBUGGING, g29_eeprom_dump()); break;
 
       case 0:
@@ -585,21 +585,21 @@ void unified_bed_leveling::G29() {
       g29_compare_current_mesh_to_stored_mesh();
 
   #endif // UBL_DEVEL_DEBUGGING
 
 
   //
   // Load a Mesh from the EEPROM
   //
 
   if (parser.seen('L')) {     // Load Current Mesh Data
-    param.KLS_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
+    param.KLS_storage_slot = parser.has_value() ? (int8_t)parser.value_int() : storage_slot;
 
     int16_t a = settings.calc_num_meshes();
 
     if (!a) {
       SERIAL_ECHOLNPGM("?EEPROM storage not available.");
       return;
     }
 
     if (!WITHIN(param.KLS_storage_slot, 0, a - 1)) {
       SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
@@ -610,24 +610,24 @@ void unified_bed_leveling::G29() {
     storage_slot = param.KLS_storage_slot;
 
     SERIAL_ECHOLNPGM("Done.");
   }
 
   //
   // Store a Mesh in the EEPROM
   //
 
   if (parser.seen('S')) {     // Store (or Save) Current Mesh Data
-    param.KLS_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
+    param.KLS_storage_slot = parser.has_value() ? (int8_t)parser.value_int() : storage_slot;
 
-    if (param.KLS_storage_slot == -1)                     // Special case, the user wants to 'Export' the mesh to the
-      return report_current_mesh();                 // host program to be saved on the user's computer
+    if (param.KLS_storage_slot == -1)               // Special case: 'Export' the mesh to the
+      return report_current_mesh();                 // host so it can be saved in a file.
 
     int16_t a = settings.calc_num_meshes();
 
     if (!a) {
       SERIAL_ECHOLNPGM("?EEPROM storage not available.");
       goto LEAVE;
     }
 
     if (!WITHIN(param.KLS_storage_slot, 0, a - 1)) {
       SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
@@ -666,21 +666,21 @@ void unified_bed_leveling::G29() {
   return;
 }
 
 /**
  * M420 C<value>
  * G29 P5 C<value> : Adjust Mesh To Mean (and subtract the given offset).
  *                   Find the mean average and shift the mesh to center on that value.
  */
 void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const_float_t offset) {
   float sum = 0;
-  int n = 0;
+  uint8_t n = 0;
   GRID_LOOP(x, y)
     if (!isnan(z_values[x][y])) {
       sum += z_values[x][y];
       n++;
     }
 
   const float mean = sum / n;
 
   //
   // Sum the squares of difference from mean
@@ -727,21 +727,21 @@ void unified_bed_leveling::shift_mesh_height() {
     TERN_(HAS_LCD_MENU, ui.capture());
 
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
     uint8_t count = GRID_MAX_POINTS;
 
     mesh_index_pair best;
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_START));
     do {
       if (do_ubl_mesh_map) display_map(param.T_map_type);
 
-      const int point_num = (GRID_MAX_POINTS) - count + 1;
+      const uint8_t point_num = (GRID_MAX_POINTS - count) + 1;
       SERIAL_ECHOLNPAIR("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
       TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), point_num, int(GRID_MAX_POINTS)));
 
       #if HAS_LCD_MENU
         if (ui.button_pressed()) {
           ui.quick_feedback(false); // Preserve button state for click-and-hold
           SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
@@ -1076,36 +1076,36 @@ void set_message_with_feedback(PGM_P const msg_P) {
  */
 bool unified_bed_leveling::G29_parse_parameters() {
   bool err_flag = false;
 
   set_message_with_feedback(GET_TEXT(MSG_UBL_DOING_G29));
 
   param.C_constant = 0;
   param.R_repetition = 0;
 
   if (parser.seen('R')) {
-    param.R_repetition = parser.has_value() ? parser.value_int() : GRID_MAX_POINTS;
+    param.R_repetition = parser.has_value() ? parser.value_byte() : GRID_MAX_POINTS;
     NOMORE(param.R_repetition, GRID_MAX_POINTS);
     if (param.R_repetition < 1) {
       SERIAL_ECHOLNPGM("?(R)epetition count invalid (1+).\n");
       return UBL_ERR;
     }
   }
 
-  param.V_verbosity = parser.intval('V');
+  param.V_verbosity = parser.byteval('V');
   if (!WITHIN(param.V_verbosity, 0, 4)) {
     SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-4).\n");
     err_flag = true;
   }
 
   if (parser.seen('P')) {
-    const int pv = parser.value_int();
+    const uint8_t pv = parser.value_byte();
     #if !HAS_BED_PROBE
       if (pv == 1) {
         SERIAL_ECHOLNPGM("G29 P1 requires a probe.\n");
         err_flag = true;
       }
       else
     #endif
       {
         param.P_phase = pv;
         if (!WITHIN(param.P_phase, 0, 6)) {
@@ -1174,21 +1174,21 @@ bool unified_bed_leveling::G29_parse_parameters() {
     if (parser.seenval('F')) {
       const float fh = parser.value_float();
       if (!WITHIN(fh, 0, 100)) {
         SERIAL_ECHOLNPGM("?(F)ade height for Bed Level Correction not plausible.\n");
         return UBL_ERR;
       }
       set_z_fade_height(fh);
     }
   #endif
 
-  param.T_map_type = parser.intval('T');
+  param.T_map_type = parser.byteval('T');
   if (!WITHIN(param.T_map_type, 0, 2)) {
     SERIAL_ECHOLNPGM("Invalid map type.\n");
     return UBL_ERR;
   }
   return UBL_OK;
 }
 
 static uint8_t ubl_state_at_invocation = 0;
 
 #if ENABLED(UBL_DEVEL_DEBUGGING)
@@ -1826,21 +1826,21 @@ void unified_bed_leveling::smart_fill_mesh() {
     if (!a) {
       SERIAL_ECHOLNPGM("?EEPROM storage not available.");
       return;
     }
 
     if (!parser.has_value() || !WITHIN(parser.value_int(), 0, a - 1)) {
       SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
       return;
     }
 
-    param.KLS_storage_slot = parser.value_int();
+    param.KLS_storage_slot = (int8_t)parser.value_int();
 
     float tmp_z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
     settings.load_mesh(param.KLS_storage_slot, &tmp_z_values);
 
     SERIAL_ECHOLNPAIR("Subtracting mesh in slot ", param.KLS_storage_slot, " from current mesh.");
 
     GRID_LOOP(x, y) {
       z_values[x][y] -= tmp_z_values[x][y];
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
     }

commit 50355f46074fe0b1f64bd8700086f30b90cc7c8f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 19 22:02:28 2021 -0500

    Fix 'G29 K' value

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 6f1425b60c..b5773b0d46 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -574,21 +574,21 @@ void unified_bed_leveling::G29() {
     // Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
     // good to have the extra information. Soon... we prune this to just a few items
     //
     if (parser.seen_test('W')) g29_what_command();
 
     //
     // When we are fully debugged, this may go away. But there are some valid
     // use cases for the users. So we can wait and see what to do with it.
     //
 
-    if (parser.seen_test('K')) // Kompare Current Mesh Data to Specified Stored Mesh
+    if (parser.seen('K')) // Kompare Current Mesh Data to Specified Stored Mesh
       g29_compare_current_mesh_to_stored_mesh();
 
   #endif // UBL_DEVEL_DEBUGGING
 
 
   //
   // Load a Mesh from the EEPROM
   //
 
   if (parser.seen('L')) {     // Load Current Mesh Data

commit 49548c343deb1e7f38f6027af20c02a79dbe5031
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 9 03:50:51 2021 -0500

    Optimize G-code flag parameters (#21849)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 6130123f7a..6f1425b60c 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -299,30 +299,30 @@
  */
 
 G29_parameters_t unified_bed_leveling::param;
 
 void unified_bed_leveling::G29() {
 
   bool probe_deployed = false;
   if (G29_parse_parameters()) return; // Abort on parameter error
 
   const int8_t p_val = parser.intval('P', -1);
-  const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J');
+  const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen_test('J');
   #if ENABLED(HAS_MULTI_HOTEND)
     const uint8_t old_tool_index = active_extruder;
   #endif
 
   // Check for commands that require the printer to be homed
   if (may_move) {
     planner.synchronize();
     // Send 'N' to force homing before G29 (internal only)
-    if (axes_should_home() || parser.seen('N')) gcode.home_all_axes();
+    if (axes_should_home() || parser.seen_test('N')) gcode.home_all_axes();
     TERN_(HAS_MULTI_HOTEND, if (active_extruder) tool_change(0));
   }
 
   // Invalidate one or more nearby mesh points, possibly all.
   if (parser.seen('I')) {
     int16_t count = parser.has_value() ? parser.value_int() : 1;
     bool invalidate_all = count >= GRID_MAX_POINTS;
     if (!invalidate_all) {
       while (count--) {
         if ((count & 0x0F) == 0x0F) idle();
@@ -373,90 +373,90 @@ void unified_bed_leveling::G29() {
             ExtUI::onMeshUpdate(x, (x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1), z_values[x][x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1]);
           #endif
 
         }
         break;
 
       case 2:
         // Allow the user to specify the height because 10mm is a little extreme in some cases.
         for (uint8_t x = (GRID_MAX_POINTS_X) / 3; x < 2 * (GRID_MAX_POINTS_X) / 3; x++)     // Create a rectangular raised area in
           for (uint8_t y = (GRID_MAX_POINTS_Y) / 3; y < 2 * (GRID_MAX_POINTS_Y) / 3; y++) { // the center of the bed
-            z_values[x][y] += parser.seen('C') ? param.C_constant : 9.99f;
+            z_values[x][y] += parser.seen_test('C') ? param.C_constant : 9.99f;
             TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
           }
         break;
     }
   }
 
   #if HAS_BED_PROBE
 
-    if (parser.seen('J')) {
+    if (parser.seen_test('J')) {
       save_ubl_active_state_and_disable();
       tilt_mesh_based_on_probed_grid(param.J_grid_size == 0); // Zero size does 3-Point
       restore_ubl_active_state_and_leave();
       #if ENABLED(UBL_G29_J_RECENTER)
         do_blocking_move_to_xy(0.5f * ((MESH_MIN_X) + (MESH_MAX_X)), 0.5f * ((MESH_MIN_Y) + (MESH_MAX_Y)));
       #endif
       report_current_position();
       probe_deployed = true;
     }
 
   #endif // HAS_BED_PROBE
 
-  if (parser.seen('P')) {
+  if (parser.seen_test('P')) {
     if (WITHIN(param.P_phase, 0, 1) && storage_slot == -1) {
       storage_slot = 0;
       SERIAL_ECHOLNPGM("Default storage slot 0 selected.");
     }
 
     switch (param.P_phase) {
       case 0:
         //
         // Zero Mesh Data
         //
         reset();
         SERIAL_ECHOLNPGM("Mesh zeroed.");
         break;
 
       #if HAS_BED_PROBE
 
         case 1: {
           //
           // Invalidate Entire Mesh and Automatically Probe Mesh in areas that can be reached by the probe
           //
-          if (!parser.seen('C')) {
+          if (!parser.seen_test('C')) {
             invalidate();
             SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
           }
           if (param.V_verbosity > 1) {
             SERIAL_ECHOPAIR("Probing around (", param.XY_pos.x);
             SERIAL_CHAR(',');
             SERIAL_DECIMAL(param.XY_pos.y);
             SERIAL_ECHOLNPGM(").\n");
           }
-          probe_entire_mesh(param.XY_pos, parser.seen('T'), parser.seen('E'), parser.seen('U'));
+          probe_entire_mesh(param.XY_pos, parser.seen_test('T'), parser.seen_test('E'), parser.seen_test('U'));
 
           report_current_position();
           probe_deployed = true;
         } break;
 
       #endif // HAS_BED_PROBE
 
       case 2: {
         #if HAS_LCD_MENU
           //
           // Manually Probe Mesh in areas that can't be reached by the probe
           //
           SERIAL_ECHOLNPGM("Manually probing unreachable points.");
           do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
 
-          if (parser.seen('C') && !param.XY_seen) {
+          if (parser.seen_test('C') && !param.XY_seen) {
 
             /**
              * Use a good default location for the path.
              * The flipped > and < operators in these comparisons is intentional.
              * It should cause the probed points to follow a nice path on Cartesian printers.
              * It may make sense to have Delta printers default to the center of the bed.
              * Until that is decided, this can be forced with the X and Y parameters.
              */
             param.XY_pos.set(
               #if IS_KINEMATIC
@@ -476,21 +476,21 @@ void unified_bed_leveling::G29() {
             }
             probe_deployed = true;
           }
 
           if (!position_is_reachable(param.XY_pos)) {
             SERIAL_ECHOLNPGM("XY outside printable radius.");
             return;
           }
 
           const float height = parser.floatval('H', Z_CLEARANCE_BETWEEN_PROBES);
-          manually_probe_remaining_mesh(param.XY_pos, height, param.B_shim_thickness, parser.seen('T'));
+          manually_probe_remaining_mesh(param.XY_pos, height, param.B_shim_thickness, parser.seen_test('T'));
 
           SERIAL_ECHOLNPGM("G29 P2 finished.");
 
           report_current_position();
 
         #else
 
           SERIAL_ECHOLNPGM("?P2 is only available when an LCD is present.");
           return;
 
@@ -548,47 +548,47 @@ void unified_bed_leveling::G29() {
             default:  // and anything P3.x that's not P3.1
               smart_fill_mesh();  // Do a 'Smart' fill using nearby known values
               break;
           }
         }
         break;
       }
 
       case 4: // Fine Tune (i.e., Edit) the Mesh
         #if HAS_LCD_MENU
-          fine_tune_mesh(param.XY_pos, parser.seen('T'));
+          fine_tune_mesh(param.XY_pos, parser.seen_test('T'));
         #else
           SERIAL_ECHOLNPGM("?P4 is only available when an LCD is present.");
           return;
         #endif
         break;
 
       case 5: adjust_mesh_to_mean(param.C_seen, param.C_constant); break;
 
       case 6: shift_mesh_height(); break;
     }
   }
 
   #if ENABLED(UBL_DEVEL_DEBUGGING)
 
     //
     // Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
     // good to have the extra information. Soon... we prune this to just a few items
     //
-    if (parser.seen('W')) g29_what_command();
+    if (parser.seen_test('W')) g29_what_command();
 
     //
     // When we are fully debugged, this may go away. But there are some valid
     // use cases for the users. So we can wait and see what to do with it.
     //
 
-    if (parser.seen('K')) // Kompare Current Mesh Data to Specified Stored Mesh
+    if (parser.seen_test('K')) // Kompare Current Mesh Data to Specified Stored Mesh
       g29_compare_current_mesh_to_stored_mesh();
 
   #endif // UBL_DEVEL_DEBUGGING
 
 
   //
   // Load a Mesh from the EEPROM
   //
 
   if (parser.seen('L')) {     // Load Current Mesh Data
@@ -633,21 +633,21 @@ void unified_bed_leveling::G29() {
       SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
       goto LEAVE;
     }
 
     settings.store_mesh(param.KLS_storage_slot);
     storage_slot = param.KLS_storage_slot;
 
     SERIAL_ECHOLNPGM("Done.");
   }
 
-  if (parser.seen('T'))
+  if (parser.seen_test('T'))
     display_map(param.T_map_type);
 
   LEAVE:
 
   #if HAS_LCD_MENU
     ui.reset_alert_level();
     ui.quick_feedback();
     ui.reset_status();
     ui.release();
   #endif
@@ -908,21 +908,21 @@ void set_message_with_feedback(PGM_P const msg_P) {
       LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
 
       do_blocking_move_to(ppos);
       do_z_clearance(z_clearance);
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       ui.capture();
 
       if (do_ubl_mesh_map) display_map(param.T_map_type);   // Show user where we're probing
 
-      if (parser.seen('B')) {
+      if (parser.seen_test('B')) {
         SERIAL_ECHOPGM_P(GET_TEXT(MSG_UBL_BC_INSERT));
         LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       }
       else {
         SERIAL_ECHOPGM_P(GET_TEXT(MSG_UBL_BC_INSERT2));
         LCD_MESSAGEPGM(MSG_UBL_BC_INSERT2);
       }
 
       const float z_step = 0.01f;                         // 0.01mm per encoder tick, occasionally step
       move_z_with_encoder(z_step);
@@ -947,21 +947,21 @@ void set_message_with_feedback(PGM_P const msg_P) {
 
     restore_ubl_active_state_and_leave();
     do_blocking_move_to_xy_z(pos, Z_CLEARANCE_DEPLOY_PROBE);
   }
 
   /**
    * G29 P4 : Mesh Fine-Tuning. Go to point(s) and adjust values with the LCD.
    *          NOTE: Blocks the G-code queue and captures Marlin UI during use.
    */
   void unified_bed_leveling::fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) {
-    if (!parser.seen('R'))        // fine_tune_mesh() is special. If no repetition count flag is specified
+    if (!parser.seen_test('R')) // fine_tune_mesh() is special. If no repetition count flag is specified
       param.R_repetition = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 
     #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
       const float h_offset = parser.seenval('H') ? parser.value_linear_units() : MANUAL_PROBE_START_Z;
       if (!WITHIN(h_offset, 0, 10)) {
         SERIAL_ECHOLNPGM("Offset out of bounds. (0 to 10mm)\n");
         return;
       }
     #endif
 
@@ -1084,21 +1084,21 @@ bool unified_bed_leveling::G29_parse_parameters() {
 
   if (parser.seen('R')) {
     param.R_repetition = parser.has_value() ? parser.value_int() : GRID_MAX_POINTS;
     NOMORE(param.R_repetition, GRID_MAX_POINTS);
     if (param.R_repetition < 1) {
       SERIAL_ECHOLNPGM("?(R)epetition count invalid (1+).\n");
       return UBL_ERR;
     }
   }
 
-  param.V_verbosity = parser.seen('V') ? parser.value_int() : 0;
+  param.V_verbosity = parser.intval('V');
   if (!WITHIN(param.V_verbosity, 0, 4)) {
     SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-4).\n");
     err_flag = true;
   }
 
   if (parser.seen('P')) {
     const int pv = parser.value_int();
     #if !HAS_BED_PROBE
       if (pv == 1) {
         SERIAL_ECHOLNPGM("G29 P1 requires a probe.\n");
@@ -1146,29 +1146,29 @@ bool unified_bed_leveling::G29_parse_parameters() {
   if (err_flag) return UBL_ERR;
 
   param.XY_pos.set(sx, sy);
 
   /**
    * Activate or deactivate UBL
    * Note: UBL's G29 restores the state set here when done.
    *       Leveling is being enabled here with old data, possibly
    *       none. Error handling should disable for safety...
    */
-  if (parser.seen('A')) {
-    if (parser.seen('D')) {
+  if (parser.seen_test('A')) {
+    if (parser.seen_test('D')) {
       SERIAL_ECHOLNPGM("?Can't activate and deactivate at the same time.\n");
       return UBL_ERR;
     }
     set_bed_leveling_enabled(true);
     report_state();
   }
-  else if (parser.seen('D')) {
+  else if (parser.seen_test('D')) {
     set_bed_leveling_enabled(false);
     report_state();
   }
 
   // Set global 'C' flag and its value
   if ((param.C_seen = parser.seen('C')))
     param.C_constant = parser.value_float();
 
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
     if (parser.seenval('F')) {
@@ -1513,21 +1513,21 @@ void unified_bed_leveling::smart_fill_mesh() {
       xy_pos_t rpos;
       LOOP_L_N(ix, param.J_grid_size) {
         rpos.x = x_min + ix * dx;
         LOOP_L_N(iy, param.J_grid_size) {
           rpos.y = y_min + dy * (zig_zag ? param.J_grid_size - 1 - iy : iy);
 
           if (!abort_flag) {
             SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
             TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
 
-            measured_z = probe.probe_at_point(rpos, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity); // TODO: Needs error handling
+            measured_z = probe.probe_at_point(rpos, parser.seen_test('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity); // TODO: Needs error handling
 
             abort_flag = isnan(measured_z);
 
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) {
                 const xy_pos_t lpos = rpos.asLogical();
                 DEBUG_CHAR('(');
                 DEBUG_ECHO_F(rpos.x, 7);
                 DEBUG_CHAR(',');
                 DEBUG_ECHO_F(rpos.y, 7);

commit 4428affc20eb5ab99a4c0855919f26e5dad1fa1f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri May 7 00:55:39 2021 -0500

    Let M421 C select any point
    
    Fixing #21147

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 361f3f1285..6130123f7a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1275,21 +1275,21 @@ mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
   typedef struct {
     MeshPointType   type;
     MeshFlags       *done_flags;
     bool            probe_relative;
     mesh_index_pair closest;
   } find_closest_t;
 
   static bool test_func(uint8_t i, uint8_t j, void *data) {
     find_closest_t *d = (find_closest_t*)data;
-    if ( (d->type == (isnan(ubl.z_values[i][j]) ? INVALID : REAL))
+    if (  d->type == CLOSEST || d->type == (isnan(ubl.z_values[i][j]) ? INVALID : REAL)
       || (d->type == SET_IN_BITMAP && !d->done_flags->marked(i, j))
     ) {
       // Found a Mesh Point of the specified type!
       const xy_pos_t mpos = { ubl.mesh_index_to_xpos(i), ubl.mesh_index_to_ypos(j) };
 
       // If using the probe as the reference there are some unreachable locations.
       // Also for round beds, there are grid points outside the bed the nozzle can't reach.
       // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
       if (!(d->probe_relative ? probe.can_reach(mpos) : position_is_reachable(mpos)))
@@ -1319,21 +1319,21 @@ mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const Mesh
     mesh_index_pair closest;
     closest.invalidate();
     closest.distance = -99999.9f;
 
     // Get the reference position, either nozzle or probe
     const xy_pos_t ref = probe_relative ? pos + probe.offset_xy : pos;
 
     float best_so_far = 99999.99f;
 
     GRID_LOOP(i, j) {
-      if ( (type == (isnan(z_values[i][j]) ? INVALID : REAL))
+      if (  type == CLOSEST || type == (isnan(z_values[i][j]) ? INVALID : REAL)
         || (type == SET_IN_BITMAP && !done_flags->marked(i, j))
       ) {
         // Found a Mesh Point of the specified type!
         const xy_pos_t mpos = { mesh_index_to_xpos(i), mesh_index_to_ypos(j) };
 
         // If using the probe as the reference there are some unreachable locations.
         // Also for round beds, there are grid points outside the bed the nozzle can't reach.
         // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
         if (!(probe_relative ? probe.can_reach(mpos) : position_is_reachable(mpos)))

commit 528b9bd8729656d7ebcd3dc7898ceddc2f377354
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 16 02:43:59 2021 -0500

    Revert experimental NAN patch
    
    Hold changes from #21575 (24a095c) for more testing.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index ed2d4c6a94..361f3f1285 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -324,21 +324,21 @@ void unified_bed_leveling::G29() {
     int16_t count = parser.has_value() ? parser.value_int() : 1;
     bool invalidate_all = count >= GRID_MAX_POINTS;
     if (!invalidate_all) {
       while (count--) {
         if ((count & 0x0F) == 0x0F) idle();
         const mesh_index_pair closest = find_closest_mesh_point_of_type(REAL, param.XY_pos);
         // No more REAL mesh points to invalidate? Assume the user meant
         // to invalidate the ENTIRE mesh, which can't be done with
         // find_closest_mesh_point (which only returns REAL points).
         if (closest.pos.x < 0) { invalidate_all = true; break; }
-        z_values[closest.pos.x][closest.pos.y] = MFNAN;
+        z_values[closest.pos.x][closest.pos.y] = NAN;
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(closest.pos, 0.0f));
       }
     }
     if (invalidate_all) {
       invalidate();
       SERIAL_ECHOPGM("Entire Mesh");
     }
     else
       SERIAL_ECHOPGM("Locations");
     SERIAL_ECHOLNPGM(" invalidated.\n");
@@ -509,21 +509,21 @@ void unified_bed_leveling::G29() {
           if (param.R_repetition >= GRID_MAX_POINTS) {
             set_all_mesh_points_to_value(param.C_constant);
           }
           else {
             while (param.R_repetition--) {  // this only populates reachable mesh points near
               const mesh_index_pair closest = find_closest_mesh_point_of_type(INVALID, param.XY_pos);
               const xy_int8_t &cpos = closest.pos;
               if (cpos.x < 0) {
                 // No more REAL INVALID mesh points to populate, so we ASSUME
                 // user meant to populate ALL INVALID mesh points to value
-                GRID_LOOP(x, y) if (ISNAN(z_values[x][y])) z_values[x][y] = param.C_constant;
+                GRID_LOOP(x, y) if (isnan(z_values[x][y])) z_values[x][y] = param.C_constant;
                 break; // No more invalid Mesh Points to populate
               }
               else {
                 z_values[cpos.x][cpos.y] = param.C_constant;
                 TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(cpos, param.C_constant));
               }
             }
           }
         }
         else {
@@ -668,55 +668,55 @@ void unified_bed_leveling::G29() {
 
 /**
  * M420 C<value>
  * G29 P5 C<value> : Adjust Mesh To Mean (and subtract the given offset).
  *                   Find the mean average and shift the mesh to center on that value.
  */
 void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const_float_t offset) {
   float sum = 0;
   int n = 0;
   GRID_LOOP(x, y)
-    if (!ISNAN(z_values[x][y])) {
+    if (!isnan(z_values[x][y])) {
       sum += z_values[x][y];
       n++;
     }
 
   const float mean = sum / n;
 
   //
   // Sum the squares of difference from mean
   //
   float sum_of_diff_squared = 0;
   GRID_LOOP(x, y)
-    if (!ISNAN(z_values[x][y]))
+    if (!isnan(z_values[x][y]))
       sum_of_diff_squared += sq(z_values[x][y] - mean);
 
   SERIAL_ECHOLNPAIR("# of samples: ", n);
   SERIAL_ECHOLNPAIR_F("Mean Mesh Height: ", mean, 6);
 
   const float sigma = SQRT(sum_of_diff_squared / (n + 1));
   SERIAL_ECHOLNPAIR_F("Standard Deviation: ", sigma, 6);
 
   if (cflag)
     GRID_LOOP(x, y)
-      if (!ISNAN(z_values[x][y])) {
+      if (!isnan(z_values[x][y])) {
         z_values[x][y] -= mean + offset;
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
       }
 }
 
 /**
  * G29 P6 C<offset> : Shift Mesh Height by a uniform constant.
  */
 void unified_bed_leveling::shift_mesh_height() {
   GRID_LOOP(x, y)
-    if (!ISNAN(z_values[x][y])) {
+    if (!isnan(z_values[x][y])) {
       z_values[x][y] += param.C_constant;
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
     }
 }
 
 #if HAS_BED_PROBE
   /**
    * G29 P1 T<maptype> V<verbosity> : Probe Entire Mesh
    *   Probe all invalidated locations of the mesh that can be reached by the probe.
    *   This attempts to fill in locations closest to the nozzle's start location first.
@@ -1010,21 +1010,21 @@ void set_message_with_feedback(PGM_P const msg_P) {
 
       if (do_ubl_mesh_map) display_map(param.T_map_type);     // Display the current point
 
       #if IS_TFTGLCD_PANEL
         ui.ubl_plot(lpos.x, lpos.y);   // update plot screen
       #endif
 
       ui.refresh();
 
       float new_z = z_values[lpos.x][lpos.y];
-      if (ISNAN(new_z)) new_z = 0;                        // Invalid points begin at 0
+      if (isnan(new_z)) new_z = 0;                        // Invalid points begin at 0
       new_z = FLOOR(new_z * 1000) * 0.001f;               // Chop off digits after the 1000ths place
 
       ui.ubl_mesh_edit_start(new_z);
 
       SET_SOFT_ENDSTOP_LOOSE(true);
 
       do {
         idle();
         new_z = ui.ubl_mesh_value();
         TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset + new_z)); // Move the nozzle as the point is edited
@@ -1220,32 +1220,32 @@ void unified_bed_leveling::restore_ubl_active_state_and_leave() {
   set_bed_leveling_enabled(ubl_state_at_invocation);
 }
 
 mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
   bool found_a_NAN = false, found_a_real = false;
 
   mesh_index_pair farthest { -1, -1, -99999.99 };
 
   GRID_LOOP(i, j) {
-    if (!ISNAN(z_values[i][j])) continue;  // Skip valid mesh points
+    if (!isnan(z_values[i][j])) continue;  // Skip valid mesh points
 
     // Skip unreachable points
     if (!probe.can_reach(mesh_index_to_xpos(i), mesh_index_to_ypos(j)))
       continue;
 
     found_a_NAN = true;
 
     xy_int8_t nearby { -1, -1 };
     float d1, d2 = 99999.9f;
     GRID_LOOP(k, l) {
-      if (ISNAN(z_values[k][l])) continue;
+      if (isnan(z_values[k][l])) continue;
 
       found_a_real = true;
 
       // Add in a random weighting factor that scrambles the probing of the
       // last half of the mesh (when every unprobed mesh point is one index
       // from a probed location).
 
       d1 = HYPOT(i - k, j - l) + (1.0f / ((millis() % 47) + 13));
 
       if (d1 < d2) {    // Invalid mesh point (i,j) is closer to the defined point (k,l)
@@ -1275,21 +1275,21 @@ mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
   typedef struct {
     MeshPointType   type;
     MeshFlags       *done_flags;
     bool            probe_relative;
     mesh_index_pair closest;
   } find_closest_t;
 
   static bool test_func(uint8_t i, uint8_t j, void *data) {
     find_closest_t *d = (find_closest_t*)data;
-    if ( (d->type == (ISNAN(ubl.z_values[i][j]) ? INVALID : REAL))
+    if ( (d->type == (isnan(ubl.z_values[i][j]) ? INVALID : REAL))
       || (d->type == SET_IN_BITMAP && !d->done_flags->marked(i, j))
     ) {
       // Found a Mesh Point of the specified type!
       const xy_pos_t mpos = { ubl.mesh_index_to_xpos(i), ubl.mesh_index_to_ypos(j) };
 
       // If using the probe as the reference there are some unreachable locations.
       // Also for round beds, there are grid points outside the bed the nozzle can't reach.
       // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
       if (!(d->probe_relative ? probe.can_reach(mpos) : position_is_reachable(mpos)))
@@ -1319,21 +1319,21 @@ mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const Mesh
     mesh_index_pair closest;
     closest.invalidate();
     closest.distance = -99999.9f;
 
     // Get the reference position, either nozzle or probe
     const xy_pos_t ref = probe_relative ? pos + probe.offset_xy : pos;
 
     float best_so_far = 99999.99f;
 
     GRID_LOOP(i, j) {
-      if ( (type == (ISNAN(z_values[i][j]) ? INVALID : REAL))
+      if ( (type == (isnan(z_values[i][j]) ? INVALID : REAL))
         || (type == SET_IN_BITMAP && !done_flags->marked(i, j))
       ) {
         // Found a Mesh Point of the specified type!
         const xy_pos_t mpos = { mesh_index_to_xpos(i), mesh_index_to_ypos(j) };
 
         // If using the probe as the reference there are some unreachable locations.
         // Also for round beds, there are grid points outside the bed the nozzle can't reach.
         // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
         if (!(probe_relative ? probe.can_reach(mpos) : position_is_reachable(mpos)))
@@ -1360,26 +1360,26 @@ mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const Mesh
 }
 
 /**
  * 'Smart Fill': Scan from the outward edges of the mesh towards the center.
  * If an invalid location is found, use the next two points (if valid) to
  * calculate a 'reasonable' value for the unprobed mesh point.
  */
 
 bool unified_bed_leveling::smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
   const float v = z_values[x][y];
-  if (ISNAN(v)) {                           // A NAN...
+  if (isnan(v)) {                           // A NAN...
     const int8_t dx = x + xdir, dy = y + ydir;
     const float v1 = z_values[dx][dy];
-    if (!ISNAN(v1)) {                       // ...next to a pair of real values?
+    if (!isnan(v1)) {                       // ...next to a pair of real values?
       const float v2 = z_values[dx + xdir][dy + ydir];
-      if (!ISNAN(v2)) {
+      if (!isnan(v2)) {
         z_values[x][y] = v1 < v2 ? v1 : v1 + v1 - v2;
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
         return true;
       }
     }
   }
   return false;
 }
 
 typedef struct { uint8_t sx, ex, sy, ey; bool yfirst; } smart_fill_info;
@@ -1434,21 +1434,21 @@ void unified_bed_leveling::smart_fill_mesh() {
     #endif
 
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
 
     if (do_3_pt_leveling) {
       SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
       TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " 1/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
       measured_z = probe.probe_at_point(points[0], PROBE_PT_RAISE, param.V_verbosity);
-      if (ISNAN(measured_z))
+      if (isnan(measured_z))
         abort_flag = true;
       else {
         measured_z -= get_z_correction(points[0]);
         #ifdef VALIDATE_MESH_TILT
           z1 = measured_z;
         #endif
         if (param.V_verbosity > 3) {
           serial_spaces(16);
           SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
         }
@@ -1456,41 +1456,41 @@ void unified_bed_leveling::smart_fill_mesh() {
       }
 
       if (!abort_flag) {
         SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " 2/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
         measured_z = probe.probe_at_point(points[1], PROBE_PT_RAISE, param.V_verbosity);
         #ifdef VALIDATE_MESH_TILT
           z2 = measured_z;
         #endif
-        if (ISNAN(measured_z))
+        if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[1]);
           if (param.V_verbosity > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, points[1], measured_z);
         }
       }
 
       if (!abort_flag) {
         SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
         measured_z = probe.probe_at_point(points[2], PROBE_PT_STOW, param.V_verbosity);
         #ifdef VALIDATE_MESH_TILT
           z3 = measured_z;
         #endif
-        if (ISNAN(measured_z))
+        if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[2]);
           if (param.V_verbosity > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, points[2], measured_z);
         }
       }
@@ -1515,21 +1515,21 @@ void unified_bed_leveling::smart_fill_mesh() {
         rpos.x = x_min + ix * dx;
         LOOP_L_N(iy, param.J_grid_size) {
           rpos.y = y_min + dy * (zig_zag ? param.J_grid_size - 1 - iy : iy);
 
           if (!abort_flag) {
             SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
             TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
 
             measured_z = probe.probe_at_point(rpos, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity); // TODO: Needs error handling
 
-            abort_flag = ISNAN(measured_z);
+            abort_flag = isnan(measured_z);
 
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) {
                 const xy_pos_t lpos = rpos.asLogical();
                 DEBUG_CHAR('(');
                 DEBUG_ECHO_F(rpos.x, 7);
                 DEBUG_CHAR(',');
                 DEBUG_ECHO_F(rpos.y, 7);
                 DEBUG_ECHOPAIR_F(")   logical: (", lpos.x, 7);
                 DEBUG_CHAR(',');
@@ -1666,28 +1666,28 @@ void unified_bed_leveling::smart_fill_mesh() {
     // the point being extrapolated.  Then extrapolate the mesh point from WLSF.
 
     static_assert((GRID_MAX_POINTS_Y) <= 16, "GRID_MAX_POINTS_Y too big");
     uint16_t bitmap[GRID_MAX_POINTS_X] = { 0 };
     struct linear_fit_data lsf_results;
 
     SERIAL_ECHOPGM("Extrapolating mesh...");
 
     const float weight_scaled = weight_factor * _MAX(MESH_X_DIST, MESH_Y_DIST);
 
-    GRID_LOOP(jx, jy) if (!ISNAN(z_values[jx][jy])) SBI(bitmap[jx], jy);
+    GRID_LOOP(jx, jy) if (!isnan(z_values[jx][jy])) SBI(bitmap[jx], jy);
 
     xy_pos_t ppos;
     LOOP_L_N(ix, GRID_MAX_POINTS_X) {
       ppos.x = mesh_index_to_xpos(ix);
       LOOP_L_N(iy, GRID_MAX_POINTS_Y) {
         ppos.y = mesh_index_to_ypos(iy);
-        if (ISNAN(z_values[ix][iy])) {
+        if (isnan(z_values[ix][iy])) {
           // undefined mesh point at (ppos.x,ppos.y), compute weighted LSF from original valid mesh points.
           incremental_LSF_reset(&lsf_results);
           xy_pos_t rpos;
           LOOP_L_N(jx, GRID_MAX_POINTS_X) {
             rpos.x = mesh_index_to_xpos(jx);
             LOOP_L_N(jy, GRID_MAX_POINTS_Y) {
               if (TEST(bitmap[jx], jy)) {
                 rpos.y = mesh_index_to_ypos(jy);
                 const float rz = z_values[jx][jy],
                              w = 1.0f + weight_scaled / (rpos - ppos).magnitude();

commit 24a095c5c14b60bcbffc2807d2c8cc8e9af46e90
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 12 16:49:53 2021 -0500

    Reduce math library code size by 3.4KB (#21575)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 361f3f1285..ed2d4c6a94 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -324,21 +324,21 @@ void unified_bed_leveling::G29() {
     int16_t count = parser.has_value() ? parser.value_int() : 1;
     bool invalidate_all = count >= GRID_MAX_POINTS;
     if (!invalidate_all) {
       while (count--) {
         if ((count & 0x0F) == 0x0F) idle();
         const mesh_index_pair closest = find_closest_mesh_point_of_type(REAL, param.XY_pos);
         // No more REAL mesh points to invalidate? Assume the user meant
         // to invalidate the ENTIRE mesh, which can't be done with
         // find_closest_mesh_point (which only returns REAL points).
         if (closest.pos.x < 0) { invalidate_all = true; break; }
-        z_values[closest.pos.x][closest.pos.y] = NAN;
+        z_values[closest.pos.x][closest.pos.y] = MFNAN;
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(closest.pos, 0.0f));
       }
     }
     if (invalidate_all) {
       invalidate();
       SERIAL_ECHOPGM("Entire Mesh");
     }
     else
       SERIAL_ECHOPGM("Locations");
     SERIAL_ECHOLNPGM(" invalidated.\n");
@@ -509,21 +509,21 @@ void unified_bed_leveling::G29() {
           if (param.R_repetition >= GRID_MAX_POINTS) {
             set_all_mesh_points_to_value(param.C_constant);
           }
           else {
             while (param.R_repetition--) {  // this only populates reachable mesh points near
               const mesh_index_pair closest = find_closest_mesh_point_of_type(INVALID, param.XY_pos);
               const xy_int8_t &cpos = closest.pos;
               if (cpos.x < 0) {
                 // No more REAL INVALID mesh points to populate, so we ASSUME
                 // user meant to populate ALL INVALID mesh points to value
-                GRID_LOOP(x, y) if (isnan(z_values[x][y])) z_values[x][y] = param.C_constant;
+                GRID_LOOP(x, y) if (ISNAN(z_values[x][y])) z_values[x][y] = param.C_constant;
                 break; // No more invalid Mesh Points to populate
               }
               else {
                 z_values[cpos.x][cpos.y] = param.C_constant;
                 TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(cpos, param.C_constant));
               }
             }
           }
         }
         else {
@@ -668,55 +668,55 @@ void unified_bed_leveling::G29() {
 
 /**
  * M420 C<value>
  * G29 P5 C<value> : Adjust Mesh To Mean (and subtract the given offset).
  *                   Find the mean average and shift the mesh to center on that value.
  */
 void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const_float_t offset) {
   float sum = 0;
   int n = 0;
   GRID_LOOP(x, y)
-    if (!isnan(z_values[x][y])) {
+    if (!ISNAN(z_values[x][y])) {
       sum += z_values[x][y];
       n++;
     }
 
   const float mean = sum / n;
 
   //
   // Sum the squares of difference from mean
   //
   float sum_of_diff_squared = 0;
   GRID_LOOP(x, y)
-    if (!isnan(z_values[x][y]))
+    if (!ISNAN(z_values[x][y]))
       sum_of_diff_squared += sq(z_values[x][y] - mean);
 
   SERIAL_ECHOLNPAIR("# of samples: ", n);
   SERIAL_ECHOLNPAIR_F("Mean Mesh Height: ", mean, 6);
 
   const float sigma = SQRT(sum_of_diff_squared / (n + 1));
   SERIAL_ECHOLNPAIR_F("Standard Deviation: ", sigma, 6);
 
   if (cflag)
     GRID_LOOP(x, y)
-      if (!isnan(z_values[x][y])) {
+      if (!ISNAN(z_values[x][y])) {
         z_values[x][y] -= mean + offset;
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
       }
 }
 
 /**
  * G29 P6 C<offset> : Shift Mesh Height by a uniform constant.
  */
 void unified_bed_leveling::shift_mesh_height() {
   GRID_LOOP(x, y)
-    if (!isnan(z_values[x][y])) {
+    if (!ISNAN(z_values[x][y])) {
       z_values[x][y] += param.C_constant;
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
     }
 }
 
 #if HAS_BED_PROBE
   /**
    * G29 P1 T<maptype> V<verbosity> : Probe Entire Mesh
    *   Probe all invalidated locations of the mesh that can be reached by the probe.
    *   This attempts to fill in locations closest to the nozzle's start location first.
@@ -1010,21 +1010,21 @@ void set_message_with_feedback(PGM_P const msg_P) {
 
       if (do_ubl_mesh_map) display_map(param.T_map_type);     // Display the current point
 
       #if IS_TFTGLCD_PANEL
         ui.ubl_plot(lpos.x, lpos.y);   // update plot screen
       #endif
 
       ui.refresh();
 
       float new_z = z_values[lpos.x][lpos.y];
-      if (isnan(new_z)) new_z = 0;                        // Invalid points begin at 0
+      if (ISNAN(new_z)) new_z = 0;                        // Invalid points begin at 0
       new_z = FLOOR(new_z * 1000) * 0.001f;               // Chop off digits after the 1000ths place
 
       ui.ubl_mesh_edit_start(new_z);
 
       SET_SOFT_ENDSTOP_LOOSE(true);
 
       do {
         idle();
         new_z = ui.ubl_mesh_value();
         TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset + new_z)); // Move the nozzle as the point is edited
@@ -1220,32 +1220,32 @@ void unified_bed_leveling::restore_ubl_active_state_and_leave() {
   set_bed_leveling_enabled(ubl_state_at_invocation);
 }
 
 mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
   bool found_a_NAN = false, found_a_real = false;
 
   mesh_index_pair farthest { -1, -1, -99999.99 };
 
   GRID_LOOP(i, j) {
-    if (!isnan(z_values[i][j])) continue;  // Skip valid mesh points
+    if (!ISNAN(z_values[i][j])) continue;  // Skip valid mesh points
 
     // Skip unreachable points
     if (!probe.can_reach(mesh_index_to_xpos(i), mesh_index_to_ypos(j)))
       continue;
 
     found_a_NAN = true;
 
     xy_int8_t nearby { -1, -1 };
     float d1, d2 = 99999.9f;
     GRID_LOOP(k, l) {
-      if (isnan(z_values[k][l])) continue;
+      if (ISNAN(z_values[k][l])) continue;
 
       found_a_real = true;
 
       // Add in a random weighting factor that scrambles the probing of the
       // last half of the mesh (when every unprobed mesh point is one index
       // from a probed location).
 
       d1 = HYPOT(i - k, j - l) + (1.0f / ((millis() % 47) + 13));
 
       if (d1 < d2) {    // Invalid mesh point (i,j) is closer to the defined point (k,l)
@@ -1275,21 +1275,21 @@ mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
   typedef struct {
     MeshPointType   type;
     MeshFlags       *done_flags;
     bool            probe_relative;
     mesh_index_pair closest;
   } find_closest_t;
 
   static bool test_func(uint8_t i, uint8_t j, void *data) {
     find_closest_t *d = (find_closest_t*)data;
-    if ( (d->type == (isnan(ubl.z_values[i][j]) ? INVALID : REAL))
+    if ( (d->type == (ISNAN(ubl.z_values[i][j]) ? INVALID : REAL))
       || (d->type == SET_IN_BITMAP && !d->done_flags->marked(i, j))
     ) {
       // Found a Mesh Point of the specified type!
       const xy_pos_t mpos = { ubl.mesh_index_to_xpos(i), ubl.mesh_index_to_ypos(j) };
 
       // If using the probe as the reference there are some unreachable locations.
       // Also for round beds, there are grid points outside the bed the nozzle can't reach.
       // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
       if (!(d->probe_relative ? probe.can_reach(mpos) : position_is_reachable(mpos)))
@@ -1319,21 +1319,21 @@ mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const Mesh
     mesh_index_pair closest;
     closest.invalidate();
     closest.distance = -99999.9f;
 
     // Get the reference position, either nozzle or probe
     const xy_pos_t ref = probe_relative ? pos + probe.offset_xy : pos;
 
     float best_so_far = 99999.99f;
 
     GRID_LOOP(i, j) {
-      if ( (type == (isnan(z_values[i][j]) ? INVALID : REAL))
+      if ( (type == (ISNAN(z_values[i][j]) ? INVALID : REAL))
         || (type == SET_IN_BITMAP && !done_flags->marked(i, j))
       ) {
         // Found a Mesh Point of the specified type!
         const xy_pos_t mpos = { mesh_index_to_xpos(i), mesh_index_to_ypos(j) };
 
         // If using the probe as the reference there are some unreachable locations.
         // Also for round beds, there are grid points outside the bed the nozzle can't reach.
         // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
         if (!(probe_relative ? probe.can_reach(mpos) : position_is_reachable(mpos)))
@@ -1360,26 +1360,26 @@ mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const Mesh
 }
 
 /**
  * 'Smart Fill': Scan from the outward edges of the mesh towards the center.
  * If an invalid location is found, use the next two points (if valid) to
  * calculate a 'reasonable' value for the unprobed mesh point.
  */
 
 bool unified_bed_leveling::smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
   const float v = z_values[x][y];
-  if (isnan(v)) {                           // A NAN...
+  if (ISNAN(v)) {                           // A NAN...
     const int8_t dx = x + xdir, dy = y + ydir;
     const float v1 = z_values[dx][dy];
-    if (!isnan(v1)) {                       // ...next to a pair of real values?
+    if (!ISNAN(v1)) {                       // ...next to a pair of real values?
       const float v2 = z_values[dx + xdir][dy + ydir];
-      if (!isnan(v2)) {
+      if (!ISNAN(v2)) {
         z_values[x][y] = v1 < v2 ? v1 : v1 + v1 - v2;
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
         return true;
       }
     }
   }
   return false;
 }
 
 typedef struct { uint8_t sx, ex, sy, ey; bool yfirst; } smart_fill_info;
@@ -1434,21 +1434,21 @@ void unified_bed_leveling::smart_fill_mesh() {
     #endif
 
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
 
     if (do_3_pt_leveling) {
       SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
       TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " 1/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
       measured_z = probe.probe_at_point(points[0], PROBE_PT_RAISE, param.V_verbosity);
-      if (isnan(measured_z))
+      if (ISNAN(measured_z))
         abort_flag = true;
       else {
         measured_z -= get_z_correction(points[0]);
         #ifdef VALIDATE_MESH_TILT
           z1 = measured_z;
         #endif
         if (param.V_verbosity > 3) {
           serial_spaces(16);
           SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
         }
@@ -1456,41 +1456,41 @@ void unified_bed_leveling::smart_fill_mesh() {
       }
 
       if (!abort_flag) {
         SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " 2/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
         measured_z = probe.probe_at_point(points[1], PROBE_PT_RAISE, param.V_verbosity);
         #ifdef VALIDATE_MESH_TILT
           z2 = measured_z;
         #endif
-        if (isnan(measured_z))
+        if (ISNAN(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[1]);
           if (param.V_verbosity > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, points[1], measured_z);
         }
       }
 
       if (!abort_flag) {
         SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
         TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
         measured_z = probe.probe_at_point(points[2], PROBE_PT_STOW, param.V_verbosity);
         #ifdef VALIDATE_MESH_TILT
           z3 = measured_z;
         #endif
-        if (isnan(measured_z))
+        if (ISNAN(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[2]);
           if (param.V_verbosity > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, points[2], measured_z);
         }
       }
@@ -1515,21 +1515,21 @@ void unified_bed_leveling::smart_fill_mesh() {
         rpos.x = x_min + ix * dx;
         LOOP_L_N(iy, param.J_grid_size) {
           rpos.y = y_min + dy * (zig_zag ? param.J_grid_size - 1 - iy : iy);
 
           if (!abort_flag) {
             SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
             TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
 
             measured_z = probe.probe_at_point(rpos, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity); // TODO: Needs error handling
 
-            abort_flag = isnan(measured_z);
+            abort_flag = ISNAN(measured_z);
 
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) {
                 const xy_pos_t lpos = rpos.asLogical();
                 DEBUG_CHAR('(');
                 DEBUG_ECHO_F(rpos.x, 7);
                 DEBUG_CHAR(',');
                 DEBUG_ECHO_F(rpos.y, 7);
                 DEBUG_ECHOPAIR_F(")   logical: (", lpos.x, 7);
                 DEBUG_CHAR(',');
@@ -1666,28 +1666,28 @@ void unified_bed_leveling::smart_fill_mesh() {
     // the point being extrapolated.  Then extrapolate the mesh point from WLSF.
 
     static_assert((GRID_MAX_POINTS_Y) <= 16, "GRID_MAX_POINTS_Y too big");
     uint16_t bitmap[GRID_MAX_POINTS_X] = { 0 };
     struct linear_fit_data lsf_results;
 
     SERIAL_ECHOPGM("Extrapolating mesh...");
 
     const float weight_scaled = weight_factor * _MAX(MESH_X_DIST, MESH_Y_DIST);
 
-    GRID_LOOP(jx, jy) if (!isnan(z_values[jx][jy])) SBI(bitmap[jx], jy);
+    GRID_LOOP(jx, jy) if (!ISNAN(z_values[jx][jy])) SBI(bitmap[jx], jy);
 
     xy_pos_t ppos;
     LOOP_L_N(ix, GRID_MAX_POINTS_X) {
       ppos.x = mesh_index_to_xpos(ix);
       LOOP_L_N(iy, GRID_MAX_POINTS_Y) {
         ppos.y = mesh_index_to_ypos(iy);
-        if (isnan(z_values[ix][iy])) {
+        if (ISNAN(z_values[ix][iy])) {
           // undefined mesh point at (ppos.x,ppos.y), compute weighted LSF from original valid mesh points.
           incremental_LSF_reset(&lsf_results);
           xy_pos_t rpos;
           LOOP_L_N(jx, GRID_MAX_POINTS_X) {
             rpos.x = mesh_index_to_xpos(jx);
             LOOP_L_N(jy, GRID_MAX_POINTS_Y) {
               if (TEST(bitmap[jx], jy)) {
                 rpos.y = mesh_index_to_ypos(jy);
                 const float rz = z_values[jx][jy],
                              w = 1.0f + weight_scaled / (rpos - ppos).magnitude();

commit 75b790376d1b20e0345efc2b8d2a58e9b201f9d3
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Sun Apr 4 17:58:03 2021 -0600

    Touch UI Bed Mesh Screen refactor, enhancements (#21521)
    
    - Split mesh view and edit screen into two screens
    - The editor now live-updates the graphics
    - Added Touch UI mesh progress feedback to `G26`
    - Show positive / negative mesh values in different colors

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 9153f369bd..361f3f1285 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -723,21 +723,21 @@ void unified_bed_leveling::shift_mesh_height() {
    */
   void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &nearby, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
     probe.deploy(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
 
     TERN_(HAS_LCD_MENU, ui.capture());
 
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
     uint8_t count = GRID_MAX_POINTS;
 
     mesh_index_pair best;
-    TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::MESH_START));
+    TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_START));
     do {
       if (do_ubl_mesh_map) display_map(param.T_map_type);
 
       const int point_num = (GRID_MAX_POINTS) - count + 1;
       SERIAL_ECHOLNPAIR("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
       TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), point_num, int(GRID_MAX_POINTS)));
 
       #if HAS_LCD_MENU
         if (ui.button_pressed()) {
           ui.quick_feedback(false); // Preserve button state for click-and-hold
@@ -748,36 +748,36 @@ void unified_bed_leveling::shift_mesh_height() {
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
           return restore_ubl_active_state_and_leave();
         }
       #endif
 
       best = do_furthest
         ? find_furthest_invalid_mesh_point()
         : find_closest_mesh_point_of_type(INVALID, nearby, true);
 
       if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
-        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_START));
+        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_POINT_START));
         const float measured_z = probe.probe_at_point(
                       best.meshpos(),
                       stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity
                     );
         z_values[best.pos.x][best.pos.y] = measured_z;
         #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_FINISH);
+          ExtUI::onMeshUpdate(best.pos, ExtUI::G29_POINT_FINISH);
           ExtUI::onMeshUpdate(best.pos, measured_z);
         #endif
       }
       SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
 
     } while (best.pos.x >= 0 && --count);
 
-    TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::MESH_FINISH));
+    TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::G29_FINISH));
 
     // Release UI during stow to allow for PAUSE_BEFORE_DEPLOY_STOW
     TERN_(HAS_LCD_MENU, ui.release());
     probe.stow();
     TERN_(HAS_LCD_MENU, ui.capture());
 
     probe.move_z_after_probing();
 
     restore_ubl_active_state_and_leave();
 

commit 45c1432946547cef4cbe9ac832394ff68526687d
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Thu Apr 1 18:12:00 2021 -0600

    G26 Hilbert Curve followup (#21480)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 545d95676e..9153f369bd 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -426,22 +426,21 @@ void unified_bed_leveling::G29() {
           if (!parser.seen('C')) {
             invalidate();
             SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
           }
           if (param.V_verbosity > 1) {
             SERIAL_ECHOPAIR("Probing around (", param.XY_pos.x);
             SERIAL_CHAR(',');
             SERIAL_DECIMAL(param.XY_pos.y);
             SERIAL_ECHOLNPGM(").\n");
           }
-          const xy_pos_t near_probe_xy = param.XY_pos + probe.offset_xy;
-          probe_entire_mesh(near_probe_xy, parser.seen('T'), parser.seen('E'), parser.seen('U'));
+          probe_entire_mesh(param.XY_pos, parser.seen('T'), parser.seen('E'), parser.seen('U'));
 
           report_current_position();
           probe_deployed = true;
         } break;
 
       #endif // HAS_BED_PROBE
 
       case 2: {
         #if HAS_LCD_MENU
           //
@@ -1133,22 +1132,23 @@ bool unified_bed_leveling::G29_parse_parameters() {
   float sx = param.XY_seen.x ? parser.value_float() : current_position.x;
   param.XY_seen.y = parser.seenval('Y');
   float sy = param.XY_seen.y ? parser.value_float() : current_position.y;
 
   if (param.XY_seen.x != param.XY_seen.y) {
     SERIAL_ECHOLNPGM("Both X & Y locations must be specified.\n");
     err_flag = true;
   }
 
   // If X or Y are not valid, use center of the bed values
-  if (!COORDINATE_OKAY(sx, X_MIN_BED, X_MAX_BED)) sx = X_CENTER;
-  if (!COORDINATE_OKAY(sy, Y_MIN_BED, Y_MAX_BED)) sy = Y_CENTER;
+  // (for UBL_HILBERT_CURVE default to lower-left corner instead)
+  if (!COORDINATE_OKAY(sx, X_MIN_BED, X_MAX_BED)) sx = TERN(UBL_HILBERT_CURVE, 0, X_CENTER);
+  if (!COORDINATE_OKAY(sy, Y_MIN_BED, Y_MAX_BED)) sy = TERN(UBL_HILBERT_CURVE, 0, Y_CENTER);
 
   if (err_flag) return UBL_ERR;
 
   param.XY_pos.set(sx, sy);
 
   /**
    * Activate or deactivate UBL
    * Note: UBL's G29 restores the state set here when done.
    *       Leveling is being enabled here with old data, possibly
    *       none. Error handling should disable for safety...

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 3282ebe620..545d95676e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -665,21 +665,21 @@ void unified_bed_leveling::G29() {
 
   TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index));
   return;
 }
 
 /**
  * M420 C<value>
  * G29 P5 C<value> : Adjust Mesh To Mean (and subtract the given offset).
  *                   Find the mean average and shift the mesh to center on that value.
  */
-void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float offset) {
+void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const_float_t offset) {
   float sum = 0;
   int n = 0;
   GRID_LOOP(x, y)
     if (!isnan(z_values[x][y])) {
       sum += z_values[x][y];
       n++;
     }
 
   const float mean = sum / n;
 
@@ -814,21 +814,21 @@ void set_message_with_feedback(PGM_P const msg_P) {
           if (func) (*func)();
           ui.wait_for_release();
           return true;
         }
       }
     }
     serial_delay(15);
     return false;
   }
 
-  void unified_bed_leveling::move_z_with_encoder(const float &multiplier) {
+  void unified_bed_leveling::move_z_with_encoder(const_float_t multiplier) {
     ui.wait_for_release();
     while (!ui.button_pressed()) {
       idle();
       gcode.reset_stepper_timeout(); // Keep steppers powered
       if (encoder_diff) {
         do_blocking_move_to_z(current_position.z + float(encoder_diff) * multiplier);
         encoder_diff = 0;
       }
     }
   }
@@ -876,21 +876,21 @@ void set_message_with_feedback(PGM_P const msg_P) {
     restore_ubl_active_state_and_leave();
 
     return thickness;
   }
 
   /**
    * G29 P2 : Manually Probe Remaining Mesh Points.
    *          Move to INVALID points and
    *          NOTE: Blocks the G-code queue and captures Marlin UI during use.
    */
-  void unified_bed_leveling::manually_probe_remaining_mesh(const xy_pos_t &pos, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
+  void unified_bed_leveling::manually_probe_remaining_mesh(const xy_pos_t &pos, const_float_t z_clearance, const_float_t thick, const bool do_ubl_mesh_map) {
     ui.capture();
 
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
     do_blocking_move_to_xy_z(current_position, z_clearance);
 
     ui.return_to_status();
 
     mesh_index_pair location;
     const xy_int8_t &lpos = location.pos;
     do {
@@ -1626,24 +1626,24 @@ void unified_bed_leveling::smart_fill_mesh() {
       /**
        * Use the code below to check the validity of the mesh tilting algorithm.
        * 3-Point Mesh Tilt uses the same algorithm as grid-based tilting, but only
        * three points are used in the calculation. This guarantees that each probed point
        * has an exact match when get_z_correction() for that location is calculated.
        * The Z error between the probed point locations and the get_z_correction()
        * numbers for those locations should be 0.
        */
       #ifdef VALIDATE_MESH_TILT
         auto d_from = []{ DEBUG_ECHOPGM("D from "); };
-        auto normed = [&](const xy_pos_t &pos, const float &zadd) {
+        auto normed = [&](const xy_pos_t &pos, const_float_t zadd) {
           return normal.x * pos.x + normal.y * pos.y + zadd;
         };
-        auto debug_pt = [](PGM_P const pre, const xy_pos_t &pos, const float &zadd) {
+        auto debug_pt = [](PGM_P const pre, const xy_pos_t &pos, const_float_t zadd) {
           d_from(); SERIAL_ECHOPGM_P(pre);
           DEBUG_ECHO_F(normed(pos, zadd), 6);
           DEBUG_ECHOLNPAIR_F("   Z error = ", zadd - get_z_correction(pos), 6);
         };
         debug_pt(PSTR("1st point: "), probe_pt[0], normal.z * z1);
         debug_pt(PSTR("2nd point: "), probe_pt[1], normal.z * z2);
         debug_pt(PSTR("3rd point: "), probe_pt[2], normal.z * z3);
         d_from(); DEBUG_ECHOPGM("safe home with Z=");
         DEBUG_ECHOLNPAIR_F("0 : ", normed(safe_homing_xy, 0), 6);
         d_from(); DEBUG_ECHOPGM("safe home with Z=");
@@ -1651,21 +1651,21 @@ void unified_bed_leveling::smart_fill_mesh() {
         DEBUG_ECHOPAIR("   Z error = (", Z_SAFE_HOMING_X_POINT, ",", Z_SAFE_HOMING_Y_POINT);
         DEBUG_ECHOLNPAIR_F(") = ", get_z_correction(safe_homing_xy), 6);
       #endif
     } // DEBUGGING(LEVELING)
 
   }
 
 #endif // HAS_BED_PROBE
 
 #if ENABLED(UBL_G29_P31)
-  void unified_bed_leveling::smart_fill_wlsf(const float &weight_factor) {
+  void unified_bed_leveling::smart_fill_wlsf(const_float_t weight_factor) {
 
     // For each undefined mesh point, compute a distance-weighted least squares fit
     // from all the originally populated mesh points, weighted toward the point
     // being extrapolated so that nearby points will have greater influence on
     // the point being extrapolated.  Then extrapolate the mesh point from WLSF.
 
     static_assert((GRID_MAX_POINTS_Y) <= 16, "GRID_MAX_POINTS_Y too big");
     uint16_t bitmap[GRID_MAX_POINTS_X] = { 0 };
     struct linear_fit_data lsf_results;
 

commit bfdd1f4662f74c9db1cb62cc4f134d4e66a2da4f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 30 23:57:57 2021 -0500

    Update UBL param

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index c11962bf9d..3282ebe620 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -384,21 +384,21 @@ void unified_bed_leveling::G29() {
             TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
           }
         break;
     }
   }
 
   #if HAS_BED_PROBE
 
     if (parser.seen('J')) {
       save_ubl_active_state_and_disable();
-      tilt_mesh_based_on_probed_grid(param.grid_size == 0); // Zero size does 3-Point
+      tilt_mesh_based_on_probed_grid(param.J_grid_size == 0); // Zero size does 3-Point
       restore_ubl_active_state_and_leave();
       #if ENABLED(UBL_G29_J_RECENTER)
         do_blocking_move_to_xy(0.5f * ((MESH_MIN_X) + (MESH_MAX_X)), 0.5f * ((MESH_MIN_Y) + (MESH_MAX_Y)));
       #endif
       report_current_position();
       probe_deployed = true;
     }
 
   #endif // HAS_BED_PROBE
 
@@ -1111,22 +1111,22 @@ bool unified_bed_leveling::G29_parse_parameters() {
         param.P_phase = pv;
         if (!WITHIN(param.P_phase, 0, 6)) {
           SERIAL_ECHOLNPGM("?(P)hase value invalid (0-6).\n");
           err_flag = true;
         }
       }
   }
 
   if (parser.seen('J')) {
     #if HAS_BED_PROBE
-      param.grid_size = parser.has_value() ? parser.value_int() : 0;
-      if (param.grid_size && !WITHIN(param.grid_size, 2, 9)) {
+      param.J_grid_size = parser.value_byte();
+      if (param.J_grid_size && !WITHIN(param.J_grid_size, 2, 9)) {
         SERIAL_ECHOLNPGM("?Invalid grid size (J) specified (2-9).\n");
         err_flag = true;
       }
     #else
       SERIAL_ECHOLNPGM("G29 J action requires a probe.\n");
       err_flag = true;
     #endif
   }
 
   param.XY_seen.x = parser.seenval('X');
@@ -1413,22 +1413,22 @@ void unified_bed_leveling::smart_fill_mesh() {
 
 #if HAS_BED_PROBE
 
   //#define VALIDATE_MESH_TILT
 
   #include "../../../libs/vector_3.h"
 
   void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
     const float x_min = probe.min_x(), x_max = probe.max_x(),
                 y_min = probe.min_y(), y_max = probe.max_y(),
-                dx = (x_max - x_min) / (param.grid_size - 1),
-                dy = (y_max - y_min) / (param.grid_size - 1);
+                dx = (x_max - x_min) / (param.J_grid_size - 1),
+                dy = (y_max - y_min) / (param.J_grid_size - 1);
 
     xy_float_t points[3];
     probe.get_three_points(points);
 
     float measured_z;
     bool abort_flag = false;
 
     #ifdef VALIDATE_MESH_TILT
       float z1, z2, z3;  // Needed for algorithm validation below
     #endif
@@ -1500,28 +1500,28 @@ void unified_bed_leveling::smart_fill_mesh() {
 
       if (abort_flag) {
         SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");
         return;
       }
     }
     else { // !do_3_pt_leveling
 
       bool zig_zag = false;
 
-      const uint16_t total_points = sq(param.grid_size);
+      const uint16_t total_points = sq(param.J_grid_size);
       uint16_t point_num = 1;
 
       xy_pos_t rpos;
-      LOOP_L_N(ix, param.grid_size) {
+      LOOP_L_N(ix, param.J_grid_size) {
         rpos.x = x_min + ix * dx;
-        LOOP_L_N(iy, param.grid_size) {
-          rpos.y = y_min + dy * (zig_zag ? param.grid_size - 1 - iy : iy);
+        LOOP_L_N(iy, param.J_grid_size) {
+          rpos.y = y_min + dy * (zig_zag ? param.J_grid_size - 1 - iy : iy);
 
           if (!abort_flag) {
             SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
             TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
 
             measured_z = probe.probe_at_point(rpos, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity); // TODO: Needs error handling
 
             abort_flag = isnan(measured_z);
 
             #if ENABLED(DEBUG_LEVELING_FEATURE)

commit be775ed72db983ea150669ad6e0e094285b2fec2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 30 23:16:29 2021 -0500

    Move apply_rotation_xyz into matrix_3x3

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 2003e9b6f5..c11962bf9d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1585,21 +1585,21 @@ void unified_bed_leveling::smart_fill_mesh() {
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOPAIR_F("before rotation = [", mx, 7);
         DEBUG_CHAR(',');
         DEBUG_ECHO_F(my, 7);
         DEBUG_CHAR(',');
         DEBUG_ECHO_F(mz, 7);
         DEBUG_ECHOPGM("]   ---> ");
         DEBUG_DELAY(20);
       }
 
-      apply_rotation_xyz(rotation, mx, my, mz);
+      rotation.apply_rotation_xyz(mx, my, mz);
 
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOPAIR_F("after rotation = [", mx, 7);
         DEBUG_CHAR(',');
         DEBUG_ECHO_F(my, 7);
         DEBUG_CHAR(',');
         DEBUG_ECHO_F(mz, 7);
         DEBUG_ECHOLNPGM("]");
         DEBUG_DELAY(20);
       }

commit c45b91aa94c7008e3fd8ea297df57948af9158a3
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Sat Mar 27 21:57:12 2021 -0600

    Refactor Hilbert curve. Enhance Touch UI Bed Level Screen. (#21453)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index c1f824714c..2003e9b6f5 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -42,20 +42,24 @@
   #include "../../../module/tool_change.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "../../../lcd/extui/ui_api.h"
 #endif
 
+#if ENABLED(UBL_HILBERT_CURVE)
+  #include "../hilbert_curve.h"
+#endif
+
 #include <math.h>
 
 #define UBL_G29_P31
 
 #if HAS_LCD_MENU
 
   bool unified_bed_leveling::lcd_map_control = false;
 
   void unified_bed_leveling::steppers_were_disabled() {
     if (lcd_map_control) {
@@ -740,25 +744,23 @@ void unified_bed_leveling::shift_mesh_height() {
           ui.quick_feedback(false); // Preserve button state for click-and-hold
           SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
           return restore_ubl_active_state_and_leave();
         }
       #endif
 
-      best = do_furthest  ? find_furthest_invalid_mesh_point()
-                          : TERN(UBL_HILBERT_CURVE,
-                              find_next_mesh_point(),
-                              find_closest_mesh_point_of_type(INVALID, nearby, true)
-                            );
+      best = do_furthest
+        ? find_furthest_invalid_mesh_point()
+        : find_closest_mesh_point_of_type(INVALID, nearby, true);
 
       if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_START));
         const float measured_z = probe.probe_at_point(
                       best.meshpos(),
                       stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity
                     );
         z_values[best.pos.x][best.pos.y] = measured_z;
         #if ENABLED(EXTENSIBLE_UI)
           ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_FINISH);
@@ -1262,111 +1264,107 @@ mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
     }
   } // GRID_LOOP
 
   if (!found_a_real && found_a_NAN) {        // if the mesh is totally unpopulated, start the probing
     farthest.pos.set((GRID_MAX_POINTS_X) / 2, (GRID_MAX_POINTS_Y) / 2);
     farthest.distance = 1;
   }
   return farthest;
 }
 
-mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const xy_pos_t &pos, const bool probe_relative/*=false*/, MeshFlags *done_flags/*=nullptr*/) {
-  mesh_index_pair closest;
-  closest.invalidate();
-  closest.distance = -99999.9f;
-
-  // Get the reference position, either nozzle or probe
-  const xy_pos_t ref = probe_relative ? pos + probe.offset_xy : pos;
-
-  float best_so_far = 99999.99f;
+#if ENABLED(UBL_HILBERT_CURVE)
 
-  GRID_LOOP(i, j) {
-    if ( (type == (isnan(z_values[i][j]) ? INVALID : REAL))
-      || (type == SET_IN_BITMAP && !done_flags->marked(i, j))
+  typedef struct {
+    MeshPointType   type;
+    MeshFlags       *done_flags;
+    bool            probe_relative;
+    mesh_index_pair closest;
+  } find_closest_t;
+
+  static bool test_func(uint8_t i, uint8_t j, void *data) {
+    find_closest_t *d = (find_closest_t*)data;
+    if ( (d->type == (isnan(ubl.z_values[i][j]) ? INVALID : REAL))
+      || (d->type == SET_IN_BITMAP && !d->done_flags->marked(i, j))
     ) {
       // Found a Mesh Point of the specified type!
-      const xy_pos_t mpos = { mesh_index_to_xpos(i), mesh_index_to_ypos(j) };
+      const xy_pos_t mpos = { ubl.mesh_index_to_xpos(i), ubl.mesh_index_to_ypos(j) };
 
       // If using the probe as the reference there are some unreachable locations.
       // Also for round beds, there are grid points outside the bed the nozzle can't reach.
       // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
-      if (!(probe_relative ? probe.can_reach(mpos) : position_is_reachable(mpos)))
-        continue;
+      if (!(d->probe_relative ? probe.can_reach(mpos) : position_is_reachable(mpos)))
+        return false;
+      d->closest.pos.set(i, j);
+      return true;
+    }
+    return false;
+  }
 
-      // Reachable. Check if it's the best_so_far location to the nozzle.
+#endif
 
-      const xy_pos_t diff = current_position - mpos;
-      const float distance = (ref - mpos).magnitude() + diff.magnitude() * 0.1f;
+mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const xy_pos_t &pos, const bool probe_relative/*=false*/, MeshFlags *done_flags/*=nullptr*/) {
 
-      // factor in the distance from the current location for the normal case
-      // so the nozzle isn't running all over the bed.
-      if (distance < best_so_far) {
-        best_so_far = distance;   // Found a closer location with the desired value type.
-        closest.pos.set(i, j);
-        closest.distance = best_so_far;
-      }
-    }
-  } // GRID_LOOP
+  #if ENABLED(UBL_HILBERT_CURVE)
 
-  return closest;
-}
+    find_closest_t d;
+    d.type           = type;
+    d.done_flags     = done_flags;
+    d.probe_relative = probe_relative;
+    d.closest.invalidate();
+    hilbert_curve::search_from_closest(pos, test_func, &d);
+    return d.closest;
 
-#if ENABLED(UBL_HILBERT_CURVE)
+  #else
 
-  constexpr int8_t  to_fix(int8_t  v) { return v << 1; }
-  constexpr int8_t  to_int(int8_t  v) { return v >> 1; }
-  constexpr uint8_t   log2(uint8_t n) { return (n > 1) ? 1 + log2(n >> 1) : 0; }
-  constexpr uint8_t  order(uint8_t n) { return uint8_t(log2(n - 1)) + 1; }
-
-  void unified_bed_leveling::hilbert(mesh_index_pair &pt, int8_t x, int8_t y, int8_t xi, int8_t xj, int8_t yi, int8_t yj, uint8_t n) {
-    /* Hilbert space filling curve implementation
-     *
-     * x and y are the coordinates of the bottom left corner
-     * xi & xj are the i & j components of the unit x vector of the frame
-     * similarly yi and yj
-     *
-     * From: http://www.fundza.com/algorithmic/space_filling/hilbert/basics/index.html
-     */
-    if (n <= 0)
-      check_if_missing(pt, to_int(x+(xi+yi)/2),to_int(y+(xj+yj)/2));
-    else {
-      hilbert(pt, x,           y,           yi/2,  yj/2,  xi/2,  xj/2, n-1);
-      hilbert(pt, x+xi/2,      y+xj/2,      xi/2,  xj/2,  yi/2,  yj/2, n-1);
-      hilbert(pt, x+xi/2+yi/2, y+xj/2+yj/2, xi/2,  xj/2,  yi/2,  yj/2, n-1);
-      hilbert(pt, x+xi/2+yi,   y+xj/2+yj,  -yi/2, -yj/2, -xi/2, -xj/2, n-1);
-    }
-  }
+    mesh_index_pair closest;
+    closest.invalidate();
+    closest.distance = -99999.9f;
+
+    // Get the reference position, either nozzle or probe
+    const xy_pos_t ref = probe_relative ? pos + probe.offset_xy : pos;
 
-  void unified_bed_leveling::check_if_missing(mesh_index_pair &pt, int x, int y) {
-      if (   pt.distance < 0
-          && x < GRID_MAX_POINTS_X
-          && y < GRID_MAX_POINTS_Y
-          && isnan(z_values[x][y])
-          && probe.can_reach(mesh_index_to_xpos(x), mesh_index_to_ypos(y))
+    float best_so_far = 99999.99f;
+
+    GRID_LOOP(i, j) {
+      if ( (type == (isnan(z_values[i][j]) ? INVALID : REAL))
+        || (type == SET_IN_BITMAP && !done_flags->marked(i, j))
       ) {
-        pt.pos.set(x, y);
-        pt.distance = 1;
+        // Found a Mesh Point of the specified type!
+        const xy_pos_t mpos = { mesh_index_to_xpos(i), mesh_index_to_ypos(j) };
+
+        // If using the probe as the reference there are some unreachable locations.
+        // Also for round beds, there are grid points outside the bed the nozzle can't reach.
+        // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
+
+        if (!(probe_relative ? probe.can_reach(mpos) : position_is_reachable(mpos)))
+          continue;
+
+        // Reachable. Check if it's the best_so_far location to the nozzle.
+
+        const xy_pos_t diff = current_position - mpos;
+        const float distance = (ref - mpos).magnitude() + diff.magnitude() * 0.1f;
+
+        // factor in the distance from the current location for the normal case
+        // so the nozzle isn't running all over the bed.
+        if (distance < best_so_far) {
+          best_so_far = distance;   // Found a closer location with the desired value type.
+          closest.pos.set(i, j);
+          closest.distance = best_so_far;
+        }
       }
-   }
-
-   mesh_index_pair unified_bed_leveling::find_next_mesh_point() {
-     mesh_index_pair pt;
-     pt.invalidate();
-     pt.distance = -99999.9f;
-     constexpr uint8_t ord = order(_MAX(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y));
-     constexpr uint8_t dim = _BV(ord);
-     hilbert(pt, to_fix(0), to_fix(0), to_fix(dim), to_fix(0), to_fix(0), to_fix(dim), ord);
-     return pt;
-   }
-
-#endif // UBL_HILBERT_CURVE
+    } // GRID_LOOP
+
+    return closest;
+
+  #endif
+}
 
 /**
  * 'Smart Fill': Scan from the outward edges of the mesh towards the center.
  * If an invalid location is found, use the next two points (if valid) to
  * calculate a 'reasonable' value for the unprobed mesh point.
  */
 
 bool unified_bed_leveling::smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
   const float v = z_values[x][y];
   if (isnan(v)) {                           // A NAN...

commit 930752d46e6aacb484ea89dacae6baf823d78d62
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Wed Mar 24 10:12:57 2021 -0500

    Ender 3 V2 Status Line (#21369)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 06b91002b8..c1f824714c 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -726,21 +726,21 @@ void unified_bed_leveling::shift_mesh_height() {
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
     uint8_t count = GRID_MAX_POINTS;
 
     mesh_index_pair best;
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::MESH_START));
     do {
       if (do_ubl_mesh_map) display_map(param.T_map_type);
 
       const int point_num = (GRID_MAX_POINTS) - count + 1;
       SERIAL_ECHOLNPAIR("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
-      TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), point_num, int(GRID_MAX_POINTS)));
+      TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), point_num, int(GRID_MAX_POINTS)));
 
       #if HAS_LCD_MENU
         if (ui.button_pressed()) {
           ui.quick_feedback(false); // Preserve button state for click-and-hold
           SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
           return restore_ubl_active_state_and_leave();
@@ -1433,60 +1433,60 @@ void unified_bed_leveling::smart_fill_mesh() {
 
     #ifdef VALIDATE_MESH_TILT
       float z1, z2, z3;  // Needed for algorithm validation below
     #endif
 
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
 
     if (do_3_pt_leveling) {
       SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
-      TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " 1/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
+      TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " 1/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
       measured_z = probe.probe_at_point(points[0], PROBE_PT_RAISE, param.V_verbosity);
       if (isnan(measured_z))
         abort_flag = true;
       else {
         measured_z -= get_z_correction(points[0]);
         #ifdef VALIDATE_MESH_TILT
           z1 = measured_z;
         #endif
         if (param.V_verbosity > 3) {
           serial_spaces(16);
           SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
         }
         incremental_LSF(&lsf_results, points[0], measured_z);
       }
 
       if (!abort_flag) {
         SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
-        TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " 2/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
+        TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " 2/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
         measured_z = probe.probe_at_point(points[1], PROBE_PT_RAISE, param.V_verbosity);
         #ifdef VALIDATE_MESH_TILT
           z2 = measured_z;
         #endif
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[1]);
           if (param.V_verbosity > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, points[1], measured_z);
         }
       }
 
       if (!abort_flag) {
         SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
-        TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
+        TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
         measured_z = probe.probe_at_point(points[2], PROBE_PT_STOW, param.V_verbosity);
         #ifdef VALIDATE_MESH_TILT
           z3 = measured_z;
         #endif
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[2]);
           if (param.V_verbosity > 3) {
@@ -1513,21 +1513,21 @@ void unified_bed_leveling::smart_fill_mesh() {
       uint16_t point_num = 1;
 
       xy_pos_t rpos;
       LOOP_L_N(ix, param.grid_size) {
         rpos.x = x_min + ix * dx;
         LOOP_L_N(iy, param.grid_size) {
           rpos.y = y_min + dy * (zig_zag ? param.grid_size - 1 - iy : iy);
 
           if (!abort_flag) {
             SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
-            TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
+            TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
 
             measured_z = probe.probe_at_point(rpos, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity); // TODO: Needs error handling
 
             abort_flag = isnan(measured_z);
 
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) {
                 const xy_pos_t lpos = rpos.asLogical();
                 DEBUG_CHAR('(');
                 DEBUG_ECHO_F(rpos.x, 7);

commit 2d2291d00eab6159de24eb7ff74001b1d6dd29e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 24 05:40:28 2021 -0500

    More IntelliSense-friendly declarations

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 42a3018561..06b91002b8 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -296,21 +296,23 @@
 
 G29_parameters_t unified_bed_leveling::param;
 
 void unified_bed_leveling::G29() {
 
   bool probe_deployed = false;
   if (G29_parse_parameters()) return; // Abort on parameter error
 
   const int8_t p_val = parser.intval('P', -1);
   const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J');
-  TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index = active_extruder);
+  #if ENABLED(HAS_MULTI_HOTEND)
+    const uint8_t old_tool_index = active_extruder;
+  #endif
 
   // Check for commands that require the printer to be homed
   if (may_move) {
     planner.synchronize();
     // Send 'N' to force homing before G29 (internal only)
     if (axes_should_home() || parser.seen('N')) gcode.home_all_axes();
     TERN_(HAS_MULTI_HOTEND, if (active_extruder) tool_change(0));
   }
 
   // Invalidate one or more nearby mesh points, possibly all.

commit da4b6896f7e4f102d8c2164e7aecf22cf2922fe2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 24 03:28:48 2021 -0500

    Group UBL parameters, add comments

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index bcda183366..42a3018561 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -64,35 +64,20 @@
     }
   }
 
   void ubl_map_screen();
 
 #endif
 
 #define SIZE_OF_LITTLE_RAISE 1
 #define BIG_RAISE_NOT_NEEDED 0
 
-int    unified_bed_leveling::g29_verbose_level,
-       unified_bed_leveling::g29_phase_value,
-       unified_bed_leveling::g29_repetition_cnt,
-       unified_bed_leveling::g29_storage_slot = 0,
-       unified_bed_leveling::g29_map_type;
-bool   unified_bed_leveling::g29_c_flag;
-float  unified_bed_leveling::g29_card_thickness = 0,
-       unified_bed_leveling::g29_constant = 0;
-xy_bool_t unified_bed_leveling::xy_seen;
-xy_pos_t unified_bed_leveling::g29_pos;
-
-#if HAS_BED_PROBE
-  int  unified_bed_leveling::g29_grid_size;
-#endif
-
 /**
  *   G29: Unified Bed Leveling by Roxy
  *
  *   Parameters understood by this leveling system:
  *
  *   A     Activate   Activate the Unified Bed Leveling system.
  *
  *   B #   Business   Use the 'Business Card' mode of the Manual Probe subsystem with P2.
  *                    Note: A non-compressible Spark Gap feeler gauge is recommended over a business card.
  *                    In this mode of G29 P2, a business or index card is used as a shim that the nozzle can
@@ -302,80 +287,74 @@ xy_pos_t unified_bed_leveling::g29_pos;
  *
  *   Unified Bed Leveling uses a lot of EEPROM storage to hold its data, and it takes some effort to get
  *   the mesh just right. To prevent this valuable data from being destroyed as the EEPROM structure
  *   evolves, UBL stores all mesh data at the end of EEPROM.
  *
  *   UBL is founded on Edward Patel's Mesh Bed Leveling code. A big 'Thanks!' to him and the creators of
  *   3-Point and Grid Based leveling. Combining their contributions we now have the functionality and
  *   features of all three systems combined.
  */
 
+G29_parameters_t unified_bed_leveling::param;
+
 void unified_bed_leveling::G29() {
 
   bool probe_deployed = false;
-  if (g29_parameter_parsing()) return; // Abort on parameter error
+  if (G29_parse_parameters()) return; // Abort on parameter error
 
   const int8_t p_val = parser.intval('P', -1);
   const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J');
   TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index = active_extruder);
 
   // Check for commands that require the printer to be homed
   if (may_move) {
     planner.synchronize();
     // Send 'N' to force homing before G29 (internal only)
     if (axes_should_home() || parser.seen('N')) gcode.home_all_axes();
     TERN_(HAS_MULTI_HOTEND, if (active_extruder) tool_change(0));
   }
 
-  // Invalidate Mesh Points. This command is a little bit asymmetrical because
-  // it directly specifies the repetition count and does not use the 'R' parameter.
+  // Invalidate one or more nearby mesh points, possibly all.
   if (parser.seen('I')) {
-    uint8_t cnt = 0;
-    g29_repetition_cnt = parser.has_value() ? parser.value_int() : 1;
-    if (g29_repetition_cnt >= GRID_MAX_POINTS) {
-      set_all_mesh_points_to_value(NAN);
-    }
-    else {
-      while (g29_repetition_cnt--) {
-        if (cnt > 20) { cnt = 0; idle(); }
-        const mesh_index_pair closest = find_closest_mesh_point_of_type(REAL, g29_pos);
-        const xy_int8_t &cpos = closest.pos;
-        if (cpos.x < 0) {
-          // No more REAL mesh points to invalidate, so we ASSUME the user
-          // meant to invalidate the ENTIRE mesh, which cannot be done with
-          // find_closest_mesh_point loop which only returns REAL points.
-          set_all_mesh_points_to_value(NAN);
-          SERIAL_ECHOLNPGM("Entire Mesh invalidated.\n");
-          break;            // No more invalid Mesh Points to populate
-        }
-        z_values[cpos.x][cpos.y] = NAN;
-        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(cpos, 0.0f));
-        cnt++;
+    int16_t count = parser.has_value() ? parser.value_int() : 1;
+    bool invalidate_all = count >= GRID_MAX_POINTS;
+    if (!invalidate_all) {
+      while (count--) {
+        if ((count & 0x0F) == 0x0F) idle();
+        const mesh_index_pair closest = find_closest_mesh_point_of_type(REAL, param.XY_pos);
+        // No more REAL mesh points to invalidate? Assume the user meant
+        // to invalidate the ENTIRE mesh, which can't be done with
+        // find_closest_mesh_point (which only returns REAL points).
+        if (closest.pos.x < 0) { invalidate_all = true; break; }
+        z_values[closest.pos.x][closest.pos.y] = NAN;
+        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(closest.pos, 0.0f));
       }
     }
-    SERIAL_ECHOLNPGM("Locations invalidated.\n");
+    if (invalidate_all) {
+      invalidate();
+      SERIAL_ECHOPGM("Entire Mesh");
+    }
+    else
+      SERIAL_ECHOPGM("Locations");
+    SERIAL_ECHOLNPGM(" invalidated.\n");
   }
 
   if (parser.seen('Q')) {
     const int test_pattern = parser.has_value() ? parser.value_int() : -99;
     if (!WITHIN(test_pattern, -1, 2)) {
       SERIAL_ECHOLNPGM("Invalid test_pattern value. (-1 to 2)\n");
       return;
     }
     SERIAL_ECHOLNPGM("Loading test_pattern values.\n");
     switch (test_pattern) {
 
-      #if ENABLED(UBL_DEVEL_DEBUGGING)
-        case -1:
-          g29_eeprom_dump();
-          break;
-      #endif
+      case -1: TERN_(UBL_DEVEL_DEBUGGING, g29_eeprom_dump()); break;
 
       case 0:
         GRID_LOOP(x, y) {                                     // Create a bowl shape similar to a poorly-calibrated Delta
           const float p1 = 0.5f * (GRID_MAX_POINTS_X) - x,
                       p2 = 0.5f * (GRID_MAX_POINTS_Y) - y;
           z_values[x][y] += 2.0f * HYPOT(p1, p2);
           TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
         }
         break;
 
@@ -388,125 +367,125 @@ void unified_bed_leveling::G29() {
             ExtUI::onMeshUpdate(x, (x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1), z_values[x][x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1]);
           #endif
 
         }
         break;
 
       case 2:
         // Allow the user to specify the height because 10mm is a little extreme in some cases.
         for (uint8_t x = (GRID_MAX_POINTS_X) / 3; x < 2 * (GRID_MAX_POINTS_X) / 3; x++)     // Create a rectangular raised area in
           for (uint8_t y = (GRID_MAX_POINTS_Y) / 3; y < 2 * (GRID_MAX_POINTS_Y) / 3; y++) { // the center of the bed
-            z_values[x][y] += parser.seen('C') ? g29_constant : 9.99f;
+            z_values[x][y] += parser.seen('C') ? param.C_constant : 9.99f;
             TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
           }
         break;
     }
   }
 
   #if HAS_BED_PROBE
 
     if (parser.seen('J')) {
       save_ubl_active_state_and_disable();
-      tilt_mesh_based_on_probed_grid(g29_grid_size == 0); // Zero size does 3-Point
+      tilt_mesh_based_on_probed_grid(param.grid_size == 0); // Zero size does 3-Point
       restore_ubl_active_state_and_leave();
       #if ENABLED(UBL_G29_J_RECENTER)
         do_blocking_move_to_xy(0.5f * ((MESH_MIN_X) + (MESH_MAX_X)), 0.5f * ((MESH_MIN_Y) + (MESH_MAX_Y)));
       #endif
       report_current_position();
       probe_deployed = true;
     }
 
   #endif // HAS_BED_PROBE
 
   if (parser.seen('P')) {
-    if (WITHIN(g29_phase_value, 0, 1) && storage_slot == -1) {
+    if (WITHIN(param.P_phase, 0, 1) && storage_slot == -1) {
       storage_slot = 0;
       SERIAL_ECHOLNPGM("Default storage slot 0 selected.");
     }
 
-    switch (g29_phase_value) {
+    switch (param.P_phase) {
       case 0:
         //
         // Zero Mesh Data
         //
         reset();
         SERIAL_ECHOLNPGM("Mesh zeroed.");
         break;
 
       #if HAS_BED_PROBE
 
         case 1: {
           //
           // Invalidate Entire Mesh and Automatically Probe Mesh in areas that can be reached by the probe
           //
           if (!parser.seen('C')) {
             invalidate();
             SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
           }
-          if (g29_verbose_level > 1) {
-            SERIAL_ECHOPAIR("Probing around (", g29_pos.x);
+          if (param.V_verbosity > 1) {
+            SERIAL_ECHOPAIR("Probing around (", param.XY_pos.x);
             SERIAL_CHAR(',');
-            SERIAL_DECIMAL(g29_pos.y);
+            SERIAL_DECIMAL(param.XY_pos.y);
             SERIAL_ECHOLNPGM(").\n");
           }
-          const xy_pos_t near_probe_xy = g29_pos + probe.offset_xy;
+          const xy_pos_t near_probe_xy = param.XY_pos + probe.offset_xy;
           probe_entire_mesh(near_probe_xy, parser.seen('T'), parser.seen('E'), parser.seen('U'));
 
           report_current_position();
           probe_deployed = true;
         } break;
 
       #endif // HAS_BED_PROBE
 
       case 2: {
         #if HAS_LCD_MENU
           //
           // Manually Probe Mesh in areas that can't be reached by the probe
           //
           SERIAL_ECHOLNPGM("Manually probing unreachable points.");
           do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
 
-          if (parser.seen('C') && !xy_seen) {
+          if (parser.seen('C') && !param.XY_seen) {
 
             /**
              * Use a good default location for the path.
              * The flipped > and < operators in these comparisons is intentional.
              * It should cause the probed points to follow a nice path on Cartesian printers.
              * It may make sense to have Delta printers default to the center of the bed.
              * Until that is decided, this can be forced with the X and Y parameters.
              */
-            g29_pos.set(
+            param.XY_pos.set(
               #if IS_KINEMATIC
                 X_HOME_POS, Y_HOME_POS
               #else
                 probe.offset_xy.x > 0 ? X_BED_SIZE : 0,
                 probe.offset_xy.y < 0 ? Y_BED_SIZE : 0
               #endif
             );
           }
 
           if (parser.seen('B')) {
-            g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness();
-            if (ABS(g29_card_thickness) > 1.5f) {
+            param.B_shim_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness();
+            if (ABS(param.B_shim_thickness) > 1.5f) {
               SERIAL_ECHOLNPGM("?Error in Business Card measurement.");
               return;
             }
             probe_deployed = true;
           }
 
-          if (!position_is_reachable(g29_pos)) {
+          if (!position_is_reachable(param.XY_pos)) {
             SERIAL_ECHOLNPGM("XY outside printable radius.");
             return;
           }
 
           const float height = parser.floatval('H', Z_CLEARANCE_BETWEEN_PROBES);
-          manually_probe_remaining_mesh(g29_pos, height, g29_card_thickness, parser.seen('T'));
+          manually_probe_remaining_mesh(param.XY_pos, height, param.B_shim_thickness, parser.seen('T'));
 
           SERIAL_ECHOLNPGM("G29 P2 finished.");
 
           report_current_position();
 
         #else
 
           SERIAL_ECHOLNPGM("?P2 is only available when an LCD is present.");
           return;
 
@@ -514,37 +493,37 @@ void unified_bed_leveling::G29() {
       } break;
 
       case 3: {
         /**
          * Populate invalid mesh areas. Proceed with caution.
          * Two choices are available:
          *   - Specify a constant with the 'C' parameter.
          *   - Allow 'G29 P3' to choose a 'reasonable' constant.
          */
 
-        if (g29_c_flag) {
-          if (g29_repetition_cnt >= GRID_MAX_POINTS) {
-            set_all_mesh_points_to_value(g29_constant);
+        if (param.C_seen) {
+          if (param.R_repetition >= GRID_MAX_POINTS) {
+            set_all_mesh_points_to_value(param.C_constant);
           }
           else {
-            while (g29_repetition_cnt--) {  // this only populates reachable mesh points near
-              const mesh_index_pair closest = find_closest_mesh_point_of_type(INVALID, g29_pos);
+            while (param.R_repetition--) {  // this only populates reachable mesh points near
+              const mesh_index_pair closest = find_closest_mesh_point_of_type(INVALID, param.XY_pos);
               const xy_int8_t &cpos = closest.pos;
               if (cpos.x < 0) {
                 // No more REAL INVALID mesh points to populate, so we ASSUME
                 // user meant to populate ALL INVALID mesh points to value
-                GRID_LOOP(x, y) if (isnan(z_values[x][y])) z_values[x][y] = g29_constant;
+                GRID_LOOP(x, y) if (isnan(z_values[x][y])) z_values[x][y] = param.C_constant;
                 break; // No more invalid Mesh Points to populate
               }
               else {
-                z_values[cpos.x][cpos.y] = g29_constant;
-                TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(cpos, g29_constant));
+                z_values[cpos.x][cpos.y] = param.C_constant;
+                TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(cpos, param.C_constant));
               }
             }
           }
         }
         else {
           const float cvf = parser.value_float();
           switch ((int)TRUNC(cvf * 10.0f) - 30) {   // 3.1 -> 1
             #if ENABLED(UBL_G29_P31)
               case 1: {
 
@@ -564,28 +543,28 @@ void unified_bed_leveling::G29() {
             default:  // and anything P3.x that's not P3.1
               smart_fill_mesh();  // Do a 'Smart' fill using nearby known values
               break;
           }
         }
         break;
       }
 
       case 4: // Fine Tune (i.e., Edit) the Mesh
         #if HAS_LCD_MENU
-          fine_tune_mesh(g29_pos, parser.seen('T'));
+          fine_tune_mesh(param.XY_pos, parser.seen('T'));
         #else
           SERIAL_ECHOLNPGM("?P4 is only available when an LCD is present.");
           return;
         #endif
         break;
 
-      case 5: adjust_mesh_to_mean(g29_c_flag, g29_constant); break;
+      case 5: adjust_mesh_to_mean(param.C_seen, param.C_constant); break;
 
       case 6: shift_mesh_height(); break;
     }
   }
 
   #if ENABLED(UBL_DEVEL_DEBUGGING)
 
     //
     // Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
     // good to have the extra information. Soon... we prune this to just a few items
@@ -601,70 +580,70 @@ void unified_bed_leveling::G29() {
       g29_compare_current_mesh_to_stored_mesh();
 
   #endif // UBL_DEVEL_DEBUGGING
 
 
   //
   // Load a Mesh from the EEPROM
   //
 
   if (parser.seen('L')) {     // Load Current Mesh Data
-    g29_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
+    param.KLS_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
 
     int16_t a = settings.calc_num_meshes();
 
     if (!a) {
       SERIAL_ECHOLNPGM("?EEPROM storage not available.");
       return;
     }
 
-    if (!WITHIN(g29_storage_slot, 0, a - 1)) {
+    if (!WITHIN(param.KLS_storage_slot, 0, a - 1)) {
       SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
       return;
     }
 
-    settings.load_mesh(g29_storage_slot);
-    storage_slot = g29_storage_slot;
+    settings.load_mesh(param.KLS_storage_slot);
+    storage_slot = param.KLS_storage_slot;
 
     SERIAL_ECHOLNPGM("Done.");
   }
 
   //
   // Store a Mesh in the EEPROM
   //
 
   if (parser.seen('S')) {     // Store (or Save) Current Mesh Data
-    g29_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
+    param.KLS_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
 
-    if (g29_storage_slot == -1)                     // Special case, the user wants to 'Export' the mesh to the
+    if (param.KLS_storage_slot == -1)                     // Special case, the user wants to 'Export' the mesh to the
       return report_current_mesh();                 // host program to be saved on the user's computer
 
     int16_t a = settings.calc_num_meshes();
 
     if (!a) {
       SERIAL_ECHOLNPGM("?EEPROM storage not available.");
       goto LEAVE;
     }
 
-    if (!WITHIN(g29_storage_slot, 0, a - 1)) {
+    if (!WITHIN(param.KLS_storage_slot, 0, a - 1)) {
       SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
       goto LEAVE;
     }
 
-    settings.store_mesh(g29_storage_slot);
-    storage_slot = g29_storage_slot;
+    settings.store_mesh(param.KLS_storage_slot);
+    storage_slot = param.KLS_storage_slot;
 
     SERIAL_ECHOLNPGM("Done.");
   }
 
   if (parser.seen('T'))
-    display_map(g29_map_type);
+    display_map(param.T_map_type);
 
   LEAVE:
 
   #if HAS_LCD_MENU
     ui.reset_alert_level();
     ui.quick_feedback();
     ui.reset_status();
     ui.release();
   #endif
 
@@ -675,21 +654,26 @@ void unified_bed_leveling::G29() {
       gcode.process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
     }
   #else
     UNUSED(probe_deployed);
   #endif
 
   TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index));
   return;
 }
 
-void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float value) {
+/**
+ * M420 C<value>
+ * G29 P5 C<value> : Adjust Mesh To Mean (and subtract the given offset).
+ *                   Find the mean average and shift the mesh to center on that value.
+ */
+void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float offset) {
   float sum = 0;
   int n = 0;
   GRID_LOOP(x, y)
     if (!isnan(z_values[x][y])) {
       sum += z_values[x][y];
       n++;
     }
 
   const float mean = sum / n;
 
@@ -703,50 +687,54 @@ void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float val
 
   SERIAL_ECHOLNPAIR("# of samples: ", n);
   SERIAL_ECHOLNPAIR_F("Mean Mesh Height: ", mean, 6);
 
   const float sigma = SQRT(sum_of_diff_squared / (n + 1));
   SERIAL_ECHOLNPAIR_F("Standard Deviation: ", sigma, 6);
 
   if (cflag)
     GRID_LOOP(x, y)
       if (!isnan(z_values[x][y])) {
-        z_values[x][y] -= mean + value;
+        z_values[x][y] -= mean + offset;
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
       }
 }
 
+/**
+ * G29 P6 C<offset> : Shift Mesh Height by a uniform constant.
+ */
 void unified_bed_leveling::shift_mesh_height() {
   GRID_LOOP(x, y)
     if (!isnan(z_values[x][y])) {
-      z_values[x][y] += g29_constant;
+      z_values[x][y] += param.C_constant;
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
     }
 }
 
 #if HAS_BED_PROBE
   /**
-   * Probe all invalidated locations of the mesh that can be reached by the probe.
-   * This attempts to fill in locations closest to the nozzle's start location first.
+   * G29 P1 T<maptype> V<verbosity> : Probe Entire Mesh
+   *   Probe all invalidated locations of the mesh that can be reached by the probe.
+   *   This attempts to fill in locations closest to the nozzle's start location first.
    */
   void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &nearby, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
     probe.deploy(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
 
     TERN_(HAS_LCD_MENU, ui.capture());
 
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
     uint8_t count = GRID_MAX_POINTS;
 
     mesh_index_pair best;
     TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::MESH_START));
     do {
-      if (do_ubl_mesh_map) display_map(g29_map_type);
+      if (do_ubl_mesh_map) display_map(param.T_map_type);
 
       const int point_num = (GRID_MAX_POINTS) - count + 1;
       SERIAL_ECHOLNPAIR("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
       TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), point_num, int(GRID_MAX_POINTS)));
 
       #if HAS_LCD_MENU
         if (ui.button_pressed()) {
           ui.quick_feedback(false); // Preserve button state for click-and-hold
           SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
           ui.wait_for_release();
@@ -760,21 +748,21 @@ void unified_bed_leveling::shift_mesh_height() {
       best = do_furthest  ? find_furthest_invalid_mesh_point()
                           : TERN(UBL_HILBERT_CURVE,
                               find_next_mesh_point(),
                               find_closest_mesh_point_of_type(INVALID, nearby, true)
                             );
 
       if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_START));
         const float measured_z = probe.probe_at_point(
                       best.meshpos(),
-                      stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level
+                      stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity
                     );
         z_values[best.pos.x][best.pos.y] = measured_z;
         #if ENABLED(EXTENSIBLE_UI)
           ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_FINISH);
           ExtUI::onMeshUpdate(best.pos, measured_z);
         #endif
       }
       SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
 
     } while (best.pos.x >= 0 && --count);
@@ -791,25 +779,34 @@ void unified_bed_leveling::shift_mesh_height() {
     restore_ubl_active_state_and_leave();
 
     do_blocking_move_to_xy(
       constrain(nearby.x - probe.offset_xy.x, MESH_MIN_X, MESH_MAX_X),
       constrain(nearby.y - probe.offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
     );
   }
 
 #endif // HAS_BED_PROBE
 
+void set_message_with_feedback(PGM_P const msg_P) {
+  #if HAS_LCD_MENU
+    ui.set_status_P(msg_P);
+    ui.quick_feedback();
+  #else
+    UNUSED(msg_P);
+  #endif
+}
+
 #if HAS_LCD_MENU
 
   typedef void (*clickFunc_t)();
 
-  bool click_and_hold(const clickFunc_t func=nullptr) {
+  bool _click_and_hold(const clickFunc_t func=nullptr) {
     if (ui.button_pressed()) {
       ui.quick_feedback(false);         // Preserve button state for click-and-hold
       const millis_t nxt = millis() + 1500UL;
       while (ui.button_pressed()) {     // Loop while the encoder is pressed. Uses hardware flag!
         idle();                         // idle, of course
         if (ELAPSED(millis(), nxt)) {   // After 1.5 seconds
           ui.quick_feedback();
           if (func) (*func)();
           ui.wait_for_release();
           return true;
@@ -827,21 +824,22 @@ void unified_bed_leveling::shift_mesh_height() {
       gcode.reset_stepper_timeout(); // Keep steppers powered
       if (encoder_diff) {
         do_blocking_move_to_z(current_position.z + float(encoder_diff) * multiplier);
         encoder_diff = 0;
       }
     }
   }
 
   float unified_bed_leveling::measure_point_with_encoder() {
     KEEPALIVE_STATE(PAUSED_FOR_USER);
-    move_z_with_encoder(0.01f);
+    const float z_step = 0.01f;
+    move_z_with_encoder(z_step);
     return current_position.z;
   }
 
   static void echo_and_take_a_measurement() { SERIAL_ECHOLNPGM(" and take a measurement."); }
 
   float unified_bed_leveling::measure_business_card_thickness() {
     ui.capture();
     save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
     do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), MANUAL_PROBE_START_Z);
@@ -859,30 +857,35 @@ void unified_bed_leveling::shift_mesh_height() {
 
     SERIAL_ECHOPGM("Remove shim");
     LCD_MESSAGEPGM(MSG_UBL_BC_REMOVE);
     echo_and_take_a_measurement();
 
     const float z2 = measure_point_with_encoder();
     do_blocking_move_to_z(current_position.z + Z_CLEARANCE_BETWEEN_PROBES);
 
     const float thickness = ABS(z1 - z2);
 
-    if (g29_verbose_level > 1) {
+    if (param.V_verbosity > 1) {
       SERIAL_ECHOPAIR_F("Business Card is ", thickness, 4);
       SERIAL_ECHOLNPGM("mm thick.");
     }
 
     restore_ubl_active_state_and_leave();
 
     return thickness;
   }
 
+  /**
+   * G29 P2 : Manually Probe Remaining Mesh Points.
+   *          Move to INVALID points and
+   *          NOTE: Blocks the G-code queue and captures Marlin UI during use.
+   */
   void unified_bed_leveling::manually_probe_remaining_mesh(const xy_pos_t &pos, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
     ui.capture();
 
     save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
     do_blocking_move_to_xy_z(current_position, z_clearance);
 
     ui.return_to_status();
 
     mesh_index_pair location;
     const xy_int8_t &lpos = location.pos;
@@ -900,70 +903,63 @@ void unified_bed_leveling::shift_mesh_height() {
       if (!position_is_reachable(ppos)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
 
       LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
 
       do_blocking_move_to(ppos);
       do_z_clearance(z_clearance);
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       ui.capture();
 
-      if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
+      if (do_ubl_mesh_map) display_map(param.T_map_type);   // Show user where we're probing
 
       if (parser.seen('B')) {
         SERIAL_ECHOPGM_P(GET_TEXT(MSG_UBL_BC_INSERT));
         LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       }
       else {
         SERIAL_ECHOPGM_P(GET_TEXT(MSG_UBL_BC_INSERT2));
         LCD_MESSAGEPGM(MSG_UBL_BC_INSERT2);
       }
 
-      const float z_step = 0.01f;                         // existing behavior: 0.01mm per click, occasionally step
-      //const float z_step = planner.steps_to_mm[Z_AXIS]; // approx one step each click
-
+      const float z_step = 0.01f;                         // 0.01mm per encoder tick, occasionally step
       move_z_with_encoder(z_step);
 
-      if (click_and_hold()) {
+      if (_click_and_hold([]{
         SERIAL_ECHOLNPGM("\nMesh only partially populated.");
         do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
-        return restore_ubl_active_state_and_leave();
-      }
+      })) return restore_ubl_active_state_and_leave();
 
+      // Store the Z position minus the shim height
       z_values[lpos.x][lpos.y] = current_position.z - thick;
+
+      // Tell the external UI to update
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, z_values[lpos.x][lpos.y]));
 
-      if (g29_verbose_level > 2)
+      if (param.V_verbosity > 2)
         SERIAL_ECHOLNPAIR_F("Mesh Point Measured at: ", z_values[lpos.x][lpos.y], 6);
       SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
     } while (location.valid());
 
-    if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
+    if (do_ubl_mesh_map) display_map(param.T_map_type);  // show user where we're probing
 
     restore_ubl_active_state_and_leave();
     do_blocking_move_to_xy_z(pos, Z_CLEARANCE_DEPLOY_PROBE);
   }
 
-  inline void set_message_with_feedback(PGM_P const msg_P) {
-    ui.set_status_P(msg_P);
-    ui.quick_feedback();
-  }
-
-  void abort_fine_tune() {
-    ui.return_to_status();
-    do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
-    set_message_with_feedback(GET_TEXT(MSG_EDITING_STOPPED));
-  }
-
+  /**
+   * G29 P4 : Mesh Fine-Tuning. Go to point(s) and adjust values with the LCD.
+   *          NOTE: Blocks the G-code queue and captures Marlin UI during use.
+   */
   void unified_bed_leveling::fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) {
-    if (!parser.seen('R'))      // fine_tune_mesh() is special. If no repetition count flag is specified
-      g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
+    if (!parser.seen('R'))        // fine_tune_mesh() is special. If no repetition count flag is specified
+      param.R_repetition = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 
     #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
       const float h_offset = parser.seenval('H') ? parser.value_linear_units() : MANUAL_PROBE_START_Z;
       if (!WITHIN(h_offset, 0, 10)) {
         SERIAL_ECHOLNPGM("Offset out of bounds. (0 to 10mm)\n");
         return;
       }
     #endif
 
     mesh_index_pair location;
@@ -977,21 +973,21 @@ void unified_bed_leveling::shift_mesh_height() {
 
     LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
     ui.capture();                                               // Take over control of the LCD encoder
 
     do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES);  // Move to the given XY with probe clearance
 
     MeshFlags done_flags{0};
     const xy_int8_t &lpos = location.pos;
 
     #if IS_TFTGLCD_PANEL
-      lcd_mesh_edit_setup(0);                             // Change current screen before calling ui.ubl_plot
+      ui.ubl_mesh_edit_start(0);                          // Change current screen before calling ui.ubl_plot
       safe_delay(50);
     #endif
 
     do {
       location = find_closest_mesh_point_of_type(SET_IN_BITMAP, pos, false, &done_flags);
 
       if (lpos.x < 0) break;                              // Stop when there are no more reachable points
 
       done_flags.mark(lpos);                              // Mark this location as 'adjusted' so a new
                                                           // location is used on the next loop
@@ -1002,144 +998,157 @@ void unified_bed_leveling::shift_mesh_height() {
       };
 
       if (!position_is_reachable(raw)) break;             // SHOULD NOT OCCUR (find_closest_mesh_point_of_type only returns reachable)
 
       do_blocking_move_to(raw);                           // Move the nozzle to the edit point with probe clearance
 
       TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset)); // Move Z to the given 'H' offset before editing
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
 
-      if (do_ubl_mesh_map) display_map(g29_map_type);     // Display the current point
+      if (do_ubl_mesh_map) display_map(param.T_map_type);     // Display the current point
 
       #if IS_TFTGLCD_PANEL
         ui.ubl_plot(lpos.x, lpos.y);   // update plot screen
       #endif
 
       ui.refresh();
 
       float new_z = z_values[lpos.x][lpos.y];
       if (isnan(new_z)) new_z = 0;                        // Invalid points begin at 0
       new_z = FLOOR(new_z * 1000) * 0.001f;               // Chop off digits after the 1000ths place
 
-      lcd_mesh_edit_setup(new_z);
+      ui.ubl_mesh_edit_start(new_z);
 
       SET_SOFT_ENDSTOP_LOOSE(true);
 
       do {
         idle();
-        new_z = lcd_mesh_edit();
+        new_z = ui.ubl_mesh_value();
         TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset + new_z)); // Move the nozzle as the point is edited
         SERIAL_FLUSH();                                   // Prevent host M105 buffer overrun.
       } while (!ui.button_pressed());
 
       SET_SOFT_ENDSTOP_LOOSE(false);
 
       if (!lcd_map_control) ui.return_to_status();        // Just editing a single point? Return to status
 
-      if (click_and_hold(abort_fine_tune)) break;         // Button held down? Abort editing
+      // Button held down? Abort editing
+      if (_click_and_hold([]{
+        ui.return_to_status();
+        do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
+        set_message_with_feedback(GET_TEXT(MSG_EDITING_STOPPED));
+      })) break;
+
+      // TODO: Disable leveling here so the Z value becomes the 'native' Z value.
 
       z_values[lpos.x][lpos.y] = new_z;                   // Save the updated Z value
+
+      // TODO: Re-enable leveling here so Z is correctly based on the updated mesh.
+
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, new_z));
 
       serial_delay(20);                                   // No switch noise
       ui.refresh();
 
-    } while (lpos.x >= 0 && --g29_repetition_cnt > 0);
+    } while (lpos.x >= 0 && --param.R_repetition > 0);
 
-    if (do_ubl_mesh_map) display_map(g29_map_type);
+    if (do_ubl_mesh_map) display_map(param.T_map_type);
     restore_ubl_active_state_and_leave();
 
     do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES);
 
     LCD_MESSAGEPGM(MSG_UBL_DONE_EDITING_MESH);
     SERIAL_ECHOLNPGM("Done Editing Mesh");
 
     if (lcd_map_control)
       ui.goto_screen(ubl_map_screen);
     else
       ui.return_to_status();
   }
 
 #endif // HAS_LCD_MENU
 
-bool unified_bed_leveling::g29_parameter_parsing() {
+/**
+ * Parse and validate most G29 parameters, store for use by G29 functions.
+ */
+bool unified_bed_leveling::G29_parse_parameters() {
   bool err_flag = false;
 
-  TERN_(HAS_LCD_MENU, set_message_with_feedback(GET_TEXT(MSG_UBL_DOING_G29)));
+  set_message_with_feedback(GET_TEXT(MSG_UBL_DOING_G29));
 
-  g29_constant = 0;
-  g29_repetition_cnt = 0;
+  param.C_constant = 0;
+  param.R_repetition = 0;
 
   if (parser.seen('R')) {
-    g29_repetition_cnt = parser.has_value() ? parser.value_int() : GRID_MAX_POINTS;
-    NOMORE(g29_repetition_cnt, GRID_MAX_POINTS);
-    if (g29_repetition_cnt < 1) {
+    param.R_repetition = parser.has_value() ? parser.value_int() : GRID_MAX_POINTS;
+    NOMORE(param.R_repetition, GRID_MAX_POINTS);
+    if (param.R_repetition < 1) {
       SERIAL_ECHOLNPGM("?(R)epetition count invalid (1+).\n");
       return UBL_ERR;
     }
   }
 
-  g29_verbose_level = parser.seen('V') ? parser.value_int() : 0;
-  if (!WITHIN(g29_verbose_level, 0, 4)) {
+  param.V_verbosity = parser.seen('V') ? parser.value_int() : 0;
+  if (!WITHIN(param.V_verbosity, 0, 4)) {
     SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-4).\n");
     err_flag = true;
   }
 
   if (parser.seen('P')) {
     const int pv = parser.value_int();
     #if !HAS_BED_PROBE
       if (pv == 1) {
         SERIAL_ECHOLNPGM("G29 P1 requires a probe.\n");
         err_flag = true;
       }
       else
     #endif
       {
-        g29_phase_value = pv;
-        if (!WITHIN(g29_phase_value, 0, 6)) {
+        param.P_phase = pv;
+        if (!WITHIN(param.P_phase, 0, 6)) {
           SERIAL_ECHOLNPGM("?(P)hase value invalid (0-6).\n");
           err_flag = true;
         }
       }
   }
 
   if (parser.seen('J')) {
     #if HAS_BED_PROBE
-      g29_grid_size = parser.has_value() ? parser.value_int() : 0;
-      if (g29_grid_size && !WITHIN(g29_grid_size, 2, 9)) {
+      param.grid_size = parser.has_value() ? parser.value_int() : 0;
+      if (param.grid_size && !WITHIN(param.grid_size, 2, 9)) {
         SERIAL_ECHOLNPGM("?Invalid grid size (J) specified (2-9).\n");
         err_flag = true;
       }
     #else
       SERIAL_ECHOLNPGM("G29 J action requires a probe.\n");
       err_flag = true;
     #endif
   }
 
-  xy_seen.x = parser.seenval('X');
-  float sx = xy_seen.x ? parser.value_float() : current_position.x;
-  xy_seen.y = parser.seenval('Y');
-  float sy = xy_seen.y ? parser.value_float() : current_position.y;
+  param.XY_seen.x = parser.seenval('X');
+  float sx = param.XY_seen.x ? parser.value_float() : current_position.x;
+  param.XY_seen.y = parser.seenval('Y');
+  float sy = param.XY_seen.y ? parser.value_float() : current_position.y;
 
-  if (xy_seen.x != xy_seen.y) {
+  if (param.XY_seen.x != param.XY_seen.y) {
     SERIAL_ECHOLNPGM("Both X & Y locations must be specified.\n");
     err_flag = true;
   }
 
   // If X or Y are not valid, use center of the bed values
   if (!COORDINATE_OKAY(sx, X_MIN_BED, X_MAX_BED)) sx = X_CENTER;
   if (!COORDINATE_OKAY(sy, Y_MIN_BED, Y_MAX_BED)) sy = Y_CENTER;
 
   if (err_flag) return UBL_ERR;
 
-  g29_pos.set(sx, sy);
+  param.XY_pos.set(sx, sy);
 
   /**
    * Activate or deactivate UBL
    * Note: UBL's G29 restores the state set here when done.
    *       Leveling is being enabled here with old data, possibly
    *       none. Error handling should disable for safety...
    */
   if (parser.seen('A')) {
     if (parser.seen('D')) {
       SERIAL_ECHOLNPGM("?Can't activate and deactivate at the same time.\n");
@@ -1147,67 +1156,67 @@ bool unified_bed_leveling::g29_parameter_parsing() {
     }
     set_bed_leveling_enabled(true);
     report_state();
   }
   else if (parser.seen('D')) {
     set_bed_leveling_enabled(false);
     report_state();
   }
 
   // Set global 'C' flag and its value
-  if ((g29_c_flag = parser.seen('C')))
-    g29_constant = parser.value_float();
+  if ((param.C_seen = parser.seen('C')))
+    param.C_constant = parser.value_float();
 
   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
     if (parser.seenval('F')) {
       const float fh = parser.value_float();
       if (!WITHIN(fh, 0, 100)) {
         SERIAL_ECHOLNPGM("?(F)ade height for Bed Level Correction not plausible.\n");
         return UBL_ERR;
       }
       set_z_fade_height(fh);
     }
   #endif
 
-  g29_map_type = parser.intval('T');
-  if (!WITHIN(g29_map_type, 0, 2)) {
+  param.T_map_type = parser.intval('T');
+  if (!WITHIN(param.T_map_type, 0, 2)) {
     SERIAL_ECHOLNPGM("Invalid map type.\n");
     return UBL_ERR;
   }
   return UBL_OK;
 }
 
 static uint8_t ubl_state_at_invocation = 0;
 
 #if ENABLED(UBL_DEVEL_DEBUGGING)
   static uint8_t ubl_state_recursion_chk = 0;
 #endif
 
 void unified_bed_leveling::save_ubl_active_state_and_disable() {
   #if ENABLED(UBL_DEVEL_DEBUGGING)
     ubl_state_recursion_chk++;
     if (ubl_state_recursion_chk != 1) {
       SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
-      TERN_(HAS_LCD_MENU, set_message_with_feedback(GET_TEXT(MSG_UBL_SAVE_ERROR)));
+      set_message_with_feedback(GET_TEXT(MSG_UBL_SAVE_ERROR));
       return;
     }
   #endif
   ubl_state_at_invocation = planner.leveling_active;
   set_bed_leveling_enabled(false);
 }
 
 void unified_bed_leveling::restore_ubl_active_state_and_leave() {
   TERN_(HAS_LCD_MENU, ui.release());
   #if ENABLED(UBL_DEVEL_DEBUGGING)
     if (--ubl_state_recursion_chk) {
       SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
-      TERN_(HAS_LCD_MENU, set_message_with_feedback(GET_TEXT(MSG_UBL_RESTORE_ERROR)));
+      set_message_with_feedback(GET_TEXT(MSG_UBL_RESTORE_ERROR));
       return;
     }
   #endif
   set_bed_leveling_enabled(ubl_state_at_invocation);
 }
 
 mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
   bool found_a_NAN = false, found_a_real = false;
 
@@ -1404,121 +1413,121 @@ void unified_bed_leveling::smart_fill_mesh() {
 
 #if HAS_BED_PROBE
 
   //#define VALIDATE_MESH_TILT
 
   #include "../../../libs/vector_3.h"
 
   void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
     const float x_min = probe.min_x(), x_max = probe.max_x(),
                 y_min = probe.min_y(), y_max = probe.max_y(),
-                dx = (x_max - x_min) / (g29_grid_size - 1),
-                dy = (y_max - y_min) / (g29_grid_size - 1);
+                dx = (x_max - x_min) / (param.grid_size - 1),
+                dy = (y_max - y_min) / (param.grid_size - 1);
 
     xy_float_t points[3];
     probe.get_three_points(points);
 
     float measured_z;
     bool abort_flag = false;
 
     #ifdef VALIDATE_MESH_TILT
       float z1, z2, z3;  // Needed for algorithm validation below
     #endif
 
     struct linear_fit_data lsf_results;
     incremental_LSF_reset(&lsf_results);
 
     if (do_3_pt_leveling) {
       SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
       TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " 1/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
-      measured_z = probe.probe_at_point(points[0], PROBE_PT_RAISE, g29_verbose_level);
+      measured_z = probe.probe_at_point(points[0], PROBE_PT_RAISE, param.V_verbosity);
       if (isnan(measured_z))
         abort_flag = true;
       else {
         measured_z -= get_z_correction(points[0]);
         #ifdef VALIDATE_MESH_TILT
           z1 = measured_z;
         #endif
-        if (g29_verbose_level > 3) {
+        if (param.V_verbosity > 3) {
           serial_spaces(16);
           SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
         }
         incremental_LSF(&lsf_results, points[0], measured_z);
       }
 
       if (!abort_flag) {
         SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
         TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " 2/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
-        measured_z = probe.probe_at_point(points[1], PROBE_PT_RAISE, g29_verbose_level);
+        measured_z = probe.probe_at_point(points[1], PROBE_PT_RAISE, param.V_verbosity);
         #ifdef VALIDATE_MESH_TILT
           z2 = measured_z;
         #endif
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[1]);
-          if (g29_verbose_level > 3) {
+          if (param.V_verbosity > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, points[1], measured_z);
         }
       }
 
       if (!abort_flag) {
         SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
         TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
-        measured_z = probe.probe_at_point(points[2], PROBE_PT_STOW, g29_verbose_level);
+        measured_z = probe.probe_at_point(points[2], PROBE_PT_STOW, param.V_verbosity);
         #ifdef VALIDATE_MESH_TILT
           z3 = measured_z;
         #endif
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[2]);
-          if (g29_verbose_level > 3) {
+          if (param.V_verbosity > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, points[2], measured_z);
         }
       }
 
       probe.stow();
       probe.move_z_after_probing();
 
       if (abort_flag) {
         SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");
         return;
       }
     }
     else { // !do_3_pt_leveling
 
       bool zig_zag = false;
 
-      const uint16_t total_points = sq(g29_grid_size);
+      const uint16_t total_points = sq(param.grid_size);
       uint16_t point_num = 1;
 
       xy_pos_t rpos;
-      LOOP_L_N(ix, g29_grid_size) {
+      LOOP_L_N(ix, param.grid_size) {
         rpos.x = x_min + ix * dx;
-        LOOP_L_N(iy, g29_grid_size) {
-          rpos.y = y_min + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
+        LOOP_L_N(iy, param.grid_size) {
+          rpos.y = y_min + dy * (zig_zag ? param.grid_size - 1 - iy : iy);
 
           if (!abort_flag) {
             SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
             TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
 
-            measured_z = probe.probe_at_point(rpos, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
+            measured_z = probe.probe_at_point(rpos, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, param.V_verbosity); // TODO: Needs error handling
 
             abort_flag = isnan(measured_z);
 
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(LEVELING)) {
                 const xy_pos_t lpos = rpos.asLogical();
                 DEBUG_CHAR('(');
                 DEBUG_ECHO_F(rpos.x, 7);
                 DEBUG_CHAR(',');
                 DEBUG_ECHO_F(rpos.y, 7);
@@ -1527,21 +1536,21 @@ void unified_bed_leveling::smart_fill_mesh() {
                 DEBUG_ECHO_F(lpos.y, 7);
                 DEBUG_ECHOPAIR_F(")   measured: ", measured_z, 7);
                 DEBUG_ECHOPAIR_F("   correction: ", get_z_correction(rpos), 7);
               }
             #endif
 
             measured_z -= get_z_correction(rpos) /* + probe.offset.z */ ;
 
             if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("   final >>>---> ", measured_z, 7);
 
-            if (g29_verbose_level > 3) {
+            if (param.V_verbosity > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, rpos, measured_z);
           }
 
           point_num++;
         }
 
         zig_zag ^= true;
@@ -1550,21 +1559,21 @@ void unified_bed_leveling::smart_fill_mesh() {
     probe.stow();
     probe.move_z_after_probing();
 
     if (abort_flag || finish_incremental_LSF(&lsf_results)) {
       SERIAL_ECHOPGM("Could not complete LSF!");
       return;
     }
 
     vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1).get_normal();
 
-    if (g29_verbose_level > 2) {
+    if (param.V_verbosity > 2) {
       SERIAL_ECHOPAIR_F("bed plane normal = [", normal.x, 7);
       SERIAL_CHAR(',');
       SERIAL_ECHO_F(normal.y, 7);
       SERIAL_CHAR(',');
       SERIAL_ECHO_F(normal.z, 7);
       SERIAL_ECHOLNPGM("]");
     }
 
     matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
 
@@ -1714,21 +1723,21 @@ void unified_bed_leveling::smart_fill_mesh() {
       SERIAL_ECHOPGM("No Mesh Loaded.");
     else
       SERIAL_ECHOPAIR("Mesh ", storage_slot, " Loaded.");
     SERIAL_EOL();
     serial_delay(50);
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       SERIAL_ECHOLNPAIR_F("Fade Height M420 Z", planner.z_fade_height, 4);
     #endif
 
-    adjust_mesh_to_mean(g29_c_flag, g29_constant);
+    adjust_mesh_to_mean(param.C_seen, param.C_constant);
 
     #if HAS_BED_PROBE
       SERIAL_ECHOLNPAIR_F("Probe Offset M851 Z", probe.offset.z, 7);
     #endif
 
     SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X); serial_delay(50);
     SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); serial_delay(50);
     SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); serial_delay(50);
     SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); serial_delay(50);
     SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             serial_delay(50);
@@ -1812,31 +1821,31 @@ void unified_bed_leveling::smart_fill_mesh() {
    * use cases for the users. So we can wait and see what to do with it.
    */
   void unified_bed_leveling::g29_compare_current_mesh_to_stored_mesh() {
     const int16_t a = settings.calc_num_meshes();
 
     if (!a) {
       SERIAL_ECHOLNPGM("?EEPROM storage not available.");
       return;
     }
 
-    if (!parser.has_value() || !WITHIN(g29_storage_slot, 0, a - 1)) {
+    if (!parser.has_value() || !WITHIN(parser.value_int(), 0, a - 1)) {
       SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
       return;
     }
 
-    g29_storage_slot = parser.value_int();
+    param.KLS_storage_slot = parser.value_int();
 
     float tmp_z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
-    settings.load_mesh(g29_storage_slot, &tmp_z_values);
+    settings.load_mesh(param.KLS_storage_slot, &tmp_z_values);
 
-    SERIAL_ECHOLNPAIR("Subtracting mesh in slot ", g29_storage_slot, " from current mesh.");
+    SERIAL_ECHOLNPAIR("Subtracting mesh in slot ", param.KLS_storage_slot, " from current mesh.");
 
     GRID_LOOP(x, y) {
       z_values[x][y] -= tmp_z_values[x][y];
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
     }
   }
 
 #endif // UBL_DEVEL_DEBUGGING
 
 #endif // AUTO_BED_LEVELING_UBL

commit dd92c8e927ba6146b06f486ef5356ea30cd87f6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 23 05:54:41 2021 -0500

    Followup to UBL Hilbert

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 3ea777fd9a..bcda183366 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -752,21 +752,21 @@ void unified_bed_leveling::shift_mesh_height() {
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
           return restore_ubl_active_state_and_leave();
         }
       #endif
 
       best = do_furthest  ? find_furthest_invalid_mesh_point()
                           : TERN(UBL_HILBERT_CURVE,
-                              next_point_in_grid(),
+                              find_next_mesh_point(),
                               find_closest_mesh_point_of_type(INVALID, nearby, true)
                             );
 
       if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_START));
         const float measured_z = probe.probe_at_point(
                       best.meshpos(),
                       stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level
                     );
         z_values[best.pos.x][best.pos.y] = measured_z;

commit eee726ec7dfa774677e86d84573e04524eff64be
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Tue Mar 23 00:45:51 2021 -0600

    UBL - Hilbert space-filling curve probing sequence (#21387)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 8c70feb661..3ea777fd9a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -750,23 +750,25 @@ void unified_bed_leveling::shift_mesh_height() {
           ui.quick_feedback(false); // Preserve button state for click-and-hold
           SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
           ui.wait_for_release();
           ui.quick_feedback();
           ui.release();
           probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
           return restore_ubl_active_state_and_leave();
         }
       #endif
 
-      best = do_furthest
-        ? find_furthest_invalid_mesh_point()
-        : find_closest_mesh_point_of_type(INVALID, nearby, true);
+      best = do_furthest  ? find_furthest_invalid_mesh_point()
+                          : TERN(UBL_HILBERT_CURVE,
+                              next_point_in_grid(),
+                              find_closest_mesh_point_of_type(INVALID, nearby, true)
+                            );
 
       if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_START));
         const float measured_z = probe.probe_at_point(
                       best.meshpos(),
                       stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level
                     );
         z_values[best.pos.x][best.pos.y] = measured_z;
         #if ENABLED(EXTENSIBLE_UI)
           ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_FINISH);
@@ -1291,20 +1293,70 @@ mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const Mesh
         best_so_far = distance;   // Found a closer location with the desired value type.
         closest.pos.set(i, j);
         closest.distance = best_so_far;
       }
     }
   } // GRID_LOOP
 
   return closest;
 }
 
+#if ENABLED(UBL_HILBERT_CURVE)
+
+  constexpr int8_t  to_fix(int8_t  v) { return v << 1; }
+  constexpr int8_t  to_int(int8_t  v) { return v >> 1; }
+  constexpr uint8_t   log2(uint8_t n) { return (n > 1) ? 1 + log2(n >> 1) : 0; }
+  constexpr uint8_t  order(uint8_t n) { return uint8_t(log2(n - 1)) + 1; }
+
+  void unified_bed_leveling::hilbert(mesh_index_pair &pt, int8_t x, int8_t y, int8_t xi, int8_t xj, int8_t yi, int8_t yj, uint8_t n) {
+    /* Hilbert space filling curve implementation
+     *
+     * x and y are the coordinates of the bottom left corner
+     * xi & xj are the i & j components of the unit x vector of the frame
+     * similarly yi and yj
+     *
+     * From: http://www.fundza.com/algorithmic/space_filling/hilbert/basics/index.html
+     */
+    if (n <= 0)
+      check_if_missing(pt, to_int(x+(xi+yi)/2),to_int(y+(xj+yj)/2));
+    else {
+      hilbert(pt, x,           y,           yi/2,  yj/2,  xi/2,  xj/2, n-1);
+      hilbert(pt, x+xi/2,      y+xj/2,      xi/2,  xj/2,  yi/2,  yj/2, n-1);
+      hilbert(pt, x+xi/2+yi/2, y+xj/2+yj/2, xi/2,  xj/2,  yi/2,  yj/2, n-1);
+      hilbert(pt, x+xi/2+yi,   y+xj/2+yj,  -yi/2, -yj/2, -xi/2, -xj/2, n-1);
+    }
+  }
+
+  void unified_bed_leveling::check_if_missing(mesh_index_pair &pt, int x, int y) {
+      if (   pt.distance < 0
+          && x < GRID_MAX_POINTS_X
+          && y < GRID_MAX_POINTS_Y
+          && isnan(z_values[x][y])
+          && probe.can_reach(mesh_index_to_xpos(x), mesh_index_to_ypos(y))
+      ) {
+        pt.pos.set(x, y);
+        pt.distance = 1;
+      }
+   }
+
+   mesh_index_pair unified_bed_leveling::find_next_mesh_point() {
+     mesh_index_pair pt;
+     pt.invalidate();
+     pt.distance = -99999.9f;
+     constexpr uint8_t ord = order(_MAX(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y));
+     constexpr uint8_t dim = _BV(ord);
+     hilbert(pt, to_fix(0), to_fix(0), to_fix(dim), to_fix(0), to_fix(0), to_fix(dim), ord);
+     return pt;
+   }
+
+#endif // UBL_HILBERT_CURVE
+
 /**
  * 'Smart Fill': Scan from the outward edges of the mesh towards the center.
  * If an invalid location is found, use the next two points (if valid) to
  * calculate a 'reasonable' value for the unprobed mesh point.
  */
 
 bool unified_bed_leveling::smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
   const float v = z_values[x][y];
   if (isnan(v)) {                           // A NAN...
     const int8_t dx = x + xdir, dy = y + ydir;

commit dd42831cba7334c5d106ba435bdb41b6135971bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 28 19:43:46 2021 -0600

    Serial macros cleanup

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 044f6b610c..8c70feb661 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -901,25 +901,25 @@ void unified_bed_leveling::shift_mesh_height() {
 
       do_blocking_move_to(ppos);
       do_z_clearance(z_clearance);
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       ui.capture();
 
       if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
       if (parser.seen('B')) {
-        serialprintPGM(GET_TEXT(MSG_UBL_BC_INSERT));
+        SERIAL_ECHOPGM_P(GET_TEXT(MSG_UBL_BC_INSERT));
         LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       }
       else {
-        serialprintPGM(GET_TEXT(MSG_UBL_BC_INSERT2));
+        SERIAL_ECHOPGM_P(GET_TEXT(MSG_UBL_BC_INSERT2));
         LCD_MESSAGEPGM(MSG_UBL_BC_INSERT2);
       }
 
       const float z_step = 0.01f;                         // existing behavior: 0.01mm per click, occasionally step
       //const float z_step = planner.steps_to_mm[Z_AXIS]; // approx one step each click
 
       move_z_with_encoder(z_step);
 
       if (click_and_hold()) {
         SERIAL_ECHOLNPGM("\nMesh only partially populated.");
@@ -1569,21 +1569,21 @@ void unified_bed_leveling::smart_fill_mesh() {
        * has an exact match when get_z_correction() for that location is calculated.
        * The Z error between the probed point locations and the get_z_correction()
        * numbers for those locations should be 0.
        */
       #ifdef VALIDATE_MESH_TILT
         auto d_from = []{ DEBUG_ECHOPGM("D from "); };
         auto normed = [&](const xy_pos_t &pos, const float &zadd) {
           return normal.x * pos.x + normal.y * pos.y + zadd;
         };
         auto debug_pt = [](PGM_P const pre, const xy_pos_t &pos, const float &zadd) {
-          d_from(); serialprintPGM(pre);
+          d_from(); SERIAL_ECHOPGM_P(pre);
           DEBUG_ECHO_F(normed(pos, zadd), 6);
           DEBUG_ECHOLNPAIR_F("   Z error = ", zadd - get_z_correction(pos), 6);
         };
         debug_pt(PSTR("1st point: "), probe_pt[0], normal.z * z1);
         debug_pt(PSTR("2nd point: "), probe_pt[1], normal.z * z2);
         debug_pt(PSTR("3rd point: "), probe_pt[2], normal.z * z3);
         d_from(); DEBUG_ECHOPGM("safe home with Z=");
         DEBUG_ECHOLNPAIR_F("0 : ", normed(safe_homing_xy, 0), 6);
         d_from(); DEBUG_ECHOPGM("safe home with Z=");
         DEBUG_ECHOLNPAIR_F("mesh value ", normed(safe_homing_xy, get_z_correction(safe_homing_xy)), 6);

commit a21d4c06aeb38b2b93bcfa21bd5773105d8df9be
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Thu Feb 25 06:14:24 2021 -0800

    Use 'H' value for UBL G29 z-clearance (#21114)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 6ceb571ee2..044f6b610c 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -885,36 +885,43 @@ void unified_bed_leveling::shift_mesh_height() {
     mesh_index_pair location;
     const xy_int8_t &lpos = location.pos;
     do {
       location = find_closest_mesh_point_of_type(INVALID, pos);
       // It doesn't matter if the probe can't reach the NAN location. This is a manual probe.
       if (!location.valid()) continue;
 
       const xyz_pos_t ppos = {
         mesh_index_to_xpos(lpos.x),
         mesh_index_to_ypos(lpos.y),
-        Z_CLEARANCE_BETWEEN_PROBES
+        z_clearance
       };
 
       if (!position_is_reachable(ppos)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
 
       LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
 
       do_blocking_move_to(ppos);
       do_z_clearance(z_clearance);
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       ui.capture();
 
       if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
-      serialprintPGM(parser.seen('B') ? GET_TEXT(MSG_UBL_BC_INSERT) : GET_TEXT(MSG_UBL_BC_INSERT2));
+      if (parser.seen('B')) {
+        serialprintPGM(GET_TEXT(MSG_UBL_BC_INSERT));
+        LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
+      }
+      else {
+        serialprintPGM(GET_TEXT(MSG_UBL_BC_INSERT2));
+        LCD_MESSAGEPGM(MSG_UBL_BC_INSERT2);
+      }
 
       const float z_step = 0.01f;                         // existing behavior: 0.01mm per click, occasionally step
       //const float z_step = planner.steps_to_mm[Z_AXIS]; // approx one step each click
 
       move_z_with_encoder(z_step);
 
       if (click_and_hold()) {
         SERIAL_ECHOLNPGM("\nMesh only partially populated.");
         do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
         return restore_ubl_active_state_and_leave();

commit 468e437390afdb1de7059e7f9049d0b30c312024
Author: deirdreobyrne <deirdre.dub@gmail.com>
Date:   Thu Feb 25 10:49:34 2021 +0000

    Allow Zero Endstops (e.g., for CNC) (#21120)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 9bd7f63a7e..6ceb571ee2 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1111,22 +1111,22 @@ bool unified_bed_leveling::g29_parameter_parsing() {
   float sx = xy_seen.x ? parser.value_float() : current_position.x;
   xy_seen.y = parser.seenval('Y');
   float sy = xy_seen.y ? parser.value_float() : current_position.y;
 
   if (xy_seen.x != xy_seen.y) {
     SERIAL_ECHOLNPGM("Both X & Y locations must be specified.\n");
     err_flag = true;
   }
 
   // If X or Y are not valid, use center of the bed values
-  if (!WITHIN(sx, X_MIN_BED, X_MAX_BED)) sx = X_CENTER;
-  if (!WITHIN(sy, Y_MIN_BED, Y_MAX_BED)) sy = Y_CENTER;
+  if (!COORDINATE_OKAY(sx, X_MIN_BED, X_MAX_BED)) sx = X_CENTER;
+  if (!COORDINATE_OKAY(sy, Y_MIN_BED, Y_MAX_BED)) sy = Y_CENTER;
 
   if (err_flag) return UBL_ERR;
 
   g29_pos.set(sx, sy);
 
   /**
    * Activate or deactivate UBL
    * Note: UBL's G29 restores the state set here when done.
    *       Leveling is being enabled here with old data, possibly
    *       none. Error handling should disable for safety...

commit bdb8c07bb22bed1ca78f4b7d14651a8e04828e82
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 23 16:09:54 2021 -0600

    Outdent UBL code

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 36acc96d6e..9bd7f63a7e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -17,1767 +17,1767 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
-  #include "../bedlevel.h"
-
-  #include "../../../MarlinCore.h"
-  #include "../../../HAL/shared/eeprom_api.h"
-  #include "../../../libs/hex_print.h"
-  #include "../../../module/settings.h"
-  #include "../../../lcd/marlinui.h"
-  #include "../../../module/stepper.h"
-  #include "../../../module/planner.h"
-  #include "../../../module/motion.h"
-  #include "../../../module/probe.h"
-  #include "../../../gcode/gcode.h"
-  #include "../../../libs/least_squares_fit.h"
-
-  #if HAS_MULTI_HOTEND
-    #include "../../../module/tool_change.h"
-  #endif
+#include "../bedlevel.h"
 
-  #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
-  #include "../../../core/debug_out.h"
+#include "../../../MarlinCore.h"
+#include "../../../HAL/shared/eeprom_api.h"
+#include "../../../libs/hex_print.h"
+#include "../../../module/settings.h"
+#include "../../../lcd/marlinui.h"
+#include "../../../module/stepper.h"
+#include "../../../module/planner.h"
+#include "../../../module/motion.h"
+#include "../../../module/probe.h"
+#include "../../../gcode/gcode.h"
+#include "../../../libs/least_squares_fit.h"
 
-  #if ENABLED(EXTENSIBLE_UI)
-    #include "../../../lcd/extui/ui_api.h"
-  #endif
+#if HAS_MULTI_HOTEND
+  #include "../../../module/tool_change.h"
+#endif
 
-  #include <math.h>
+#define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
+#include "../../../core/debug_out.h"
 
-  #define UBL_G29_P31
+#if ENABLED(EXTENSIBLE_UI)
+  #include "../../../lcd/extui/ui_api.h"
+#endif
 
-  #if HAS_LCD_MENU
+#include <math.h>
 
-    bool unified_bed_leveling::lcd_map_control = false;
+#define UBL_G29_P31
 
-    void unified_bed_leveling::steppers_were_disabled() {
-      if (lcd_map_control) {
-        lcd_map_control = false;
-        ui.defer_status_screen(false);
-      }
+#if HAS_LCD_MENU
+
+  bool unified_bed_leveling::lcd_map_control = false;
+
+  void unified_bed_leveling::steppers_were_disabled() {
+    if (lcd_map_control) {
+      lcd_map_control = false;
+      ui.defer_status_screen(false);
     }
+  }
 
-    void ubl_map_screen();
+  void ubl_map_screen();
 
-  #endif
+#endif
 
-  #define SIZE_OF_LITTLE_RAISE 1
-  #define BIG_RAISE_NOT_NEEDED 0
+#define SIZE_OF_LITTLE_RAISE 1
+#define BIG_RAISE_NOT_NEEDED 0
 
-  int    unified_bed_leveling::g29_verbose_level,
-         unified_bed_leveling::g29_phase_value,
-         unified_bed_leveling::g29_repetition_cnt,
-         unified_bed_leveling::g29_storage_slot = 0,
-         unified_bed_leveling::g29_map_type;
-  bool   unified_bed_leveling::g29_c_flag;
-  float  unified_bed_leveling::g29_card_thickness = 0,
-         unified_bed_leveling::g29_constant = 0;
-  xy_bool_t unified_bed_leveling::xy_seen;
-  xy_pos_t unified_bed_leveling::g29_pos;
+int    unified_bed_leveling::g29_verbose_level,
+       unified_bed_leveling::g29_phase_value,
+       unified_bed_leveling::g29_repetition_cnt,
+       unified_bed_leveling::g29_storage_slot = 0,
+       unified_bed_leveling::g29_map_type;
+bool   unified_bed_leveling::g29_c_flag;
+float  unified_bed_leveling::g29_card_thickness = 0,
+       unified_bed_leveling::g29_constant = 0;
+xy_bool_t unified_bed_leveling::xy_seen;
+xy_pos_t unified_bed_leveling::g29_pos;
 
-  #if HAS_BED_PROBE
-    int  unified_bed_leveling::g29_grid_size;
-  #endif
+#if HAS_BED_PROBE
+  int  unified_bed_leveling::g29_grid_size;
+#endif
 
-  /**
-   *   G29: Unified Bed Leveling by Roxy
-   *
-   *   Parameters understood by this leveling system:
-   *
-   *   A     Activate   Activate the Unified Bed Leveling system.
-   *
-   *   B #   Business   Use the 'Business Card' mode of the Manual Probe subsystem with P2.
-   *                    Note: A non-compressible Spark Gap feeler gauge is recommended over a business card.
-   *                    In this mode of G29 P2, a business or index card is used as a shim that the nozzle can
-   *                    grab onto as it is lowered. In principle, the nozzle-bed distance is the same when the
-   *                    same resistance is felt in the shim. You can omit the numerical value on first invocation
-   *                    of G29 P2 B to measure shim thickness. Subsequent use of 'B' will apply the previously-
-   *                    measured thickness by default.
-   *
-   *   C     Continue   G29 P1 C continues the generation of a partially-constructed Mesh without invalidating
-   *                    previous measurements.
-   *
-   *   C                G29 P2 C tells the Manual Probe subsystem to not use the current nozzle
-   *                    location in its search for the closest unmeasured Mesh Point. Instead, attempt to
-   *                    start at one end of the uprobed points and Continue sequentially.
-   *
-   *                    G29 P3 C specifies the Constant for the fill. Otherwise, uses a "reasonable" value.
-   *
-   *   C     Current    G29 Z C uses the Current location (instead of bed center or nearest edge).
-   *
-   *   D     Disable    Disable the Unified Bed Leveling system.
-   *
-   *   E     Stow_probe Stow the probe after each sampled point.
-   *
-   *   F #   Fade       Fade the amount of Mesh Based Compensation over a specified height. At the
-   *                    specified height, no correction is applied and natural printer kenimatics take over. If no
-   *                    number is specified for the command, 10mm is assumed to be reasonable.
-   *
-   *   H #   Height     With P2, 'H' specifies the Height to raise the nozzle after each manual probe of the bed.
-   *                    If omitted, the nozzle will raise by Z_CLEARANCE_BETWEEN_PROBES.
-   *
-   *   H #   Offset     With P4, 'H' specifies the Offset above the mesh height to place the nozzle.
-   *                    If omitted, Z_CLEARANCE_BETWEEN_PROBES will be used.
-   *
-   *   I #   Invalidate Invalidate the specified number of Mesh Points near the given 'X' 'Y'. If X or Y are omitted,
-   *                    the nozzle location is used. If no 'I' value is given, only the point nearest to the location
-   *                    is invalidated. Use 'T' to produce a map afterward. This command is useful to invalidate a
-   *                    portion of the Mesh so it can be adjusted using other UBL tools. When attempting to invalidate
-   *                    an isolated bad mesh point, the 'T' option shows the nozzle position in the Mesh with (#). You
-   *                    can move the nozzle around and use this feature to select the center of the area (or cell) to
-   *                    invalidate.
-   *
-   *   J #   Grid       Perform a Grid Based Leveling of the current Mesh using a grid with n points on a side.
-   *                    Not specifying a grid size will invoke the 3-Point leveling function.
-   *
-   *   L     Load       Load Mesh from the previously activated location in the EEPROM.
-   *
-   *   L #   Load       Load Mesh from the specified location in the EEPROM. Set this location as activated
-   *                    for subsequent Load and Store operations.
-   *
-   *   The P or Phase commands are used for the bulk of the work to setup a Mesh. In general, your Mesh will
-   *   start off being initialized with a G29 P0 or a G29 P1. Further refinement of the Mesh happens with
-   *   each additional Phase that processes it.
-   *
-   *   P0    Phase 0    Zero Mesh Data and turn off the Mesh Compensation System. This reverts the
-   *                    3D Printer to the same state it was in before the Unified Bed Leveling Compensation
-   *                    was turned on. Setting the entire Mesh to Zero is a special case that allows
-   *                    a subsequent G or T leveling operation for backward compatibility.
-   *
-   *   P1    Phase 1    Invalidate entire Mesh and continue with automatic generation of the Mesh data using
-   *                    the Z-Probe. Usually the probe can't reach all areas that the nozzle can reach. For delta
-   *                    printers only the areas where the probe and nozzle can both reach will be automatically probed.
-   *
-   *                    Unreachable points will be handled in Phase 2 and Phase 3.
-   *
-   *                    Use 'C' to leave the previous mesh intact and automatically probe needed points. This allows you
-   *                    to invalidate parts of the Mesh but still use Automatic Probing.
-   *
-   *                    The 'X' and 'Y' parameters prioritize where to try and measure points. If omitted, the current
-   *                    probe position is used.
-   *
-   *                    Use 'T' (Topology) to generate a report of mesh generation.
-   *
-   *                    P1 will suspend Mesh generation if the controller button is held down. Note that you may need
-   *                    to press and hold the switch for several seconds if moves are underway.
-   *
-   *   P2    Phase 2    Probe unreachable points.
-   *
-   *                    Use 'H' to set the height between Mesh points. If omitted, Z_CLEARANCE_BETWEEN_PROBES is used.
-   *                    Smaller values will be quicker. Move the nozzle down till it barely touches the bed. Make sure the
-   *                    nozzle is clean and unobstructed. Use caution and move slowly. This can damage your printer!
-   *                    (Uses SIZE_OF_LITTLE_RAISE mm if the nozzle is moving less than BIG_RAISE_NOT_NEEDED mm.)
-   *
-   *                    The 'H' value can be negative if the Mesh dips in a large area. Press and hold the
-   *                    controller button to terminate the current Phase 2 command. You can then re-issue "G29 P 2"
-   *                    with an 'H' parameter more suitable for the area you're manually probing. Note that the command
-   *                    tries to start in a corner of the bed where movement will be predictable. Override the distance
-   *                    calculation location with the X and Y parameters. You can print a Mesh Map (G29 T) to see where
-   *                    the mesh is invalidated and where the nozzle needs to move to complete the command. Use 'C' to
-   *                    indicate that the search should be based on the current position.
-   *
-   *                    The 'B' parameter for this command is described above. It places the manual probe subsystem into
-   *                    Business Card mode where the thickness of a business card is measured and then used to accurately
-   *                    set the nozzle height in all manual probing for the duration of the command. A Business card can
-   *                    be used, but you'll get better results with a flexible Shim that doesn't compress. This makes it
-   *                    easier to produce similar amounts of force and get more accurate measurements. Google if you're
-   *                    not sure how to use a shim.
-   *
-   *                    The 'T' (Map) parameter helps track Mesh building progress.
-   *
-   *                    NOTE: P2 requires an LCD controller!
-   *
-   *   P3    Phase 3    Fill the unpopulated regions of the Mesh with a fixed value. There are two different paths to
-   *                    go down:
-   *
-   *                    - If a 'C' constant is specified, the closest invalid mesh points to the nozzle will be filled,
-   *                      and a repeat count can then also be specified with 'R'.
-   *
-   *                    - Leaving out 'C' invokes Smart Fill, which scans the mesh from the edges inward looking for
-   *                      invalid mesh points. Adjacent points are used to determine the bed slope. If the bed is sloped
-   *                      upward from the invalid point, it takes the value of the nearest point. If sloped downward, it's
-   *                      replaced by a value that puts all three points in a line. This version of G29 P3 is a quick, easy
-   *                      and (usually) safe way to populate unprobed mesh regions before continuing to G26 Mesh Validation
-   *                      Pattern. Note that this populates the mesh with unverified values. Pay attention and use caution.
-   *
-   *   P4    Phase 4    Fine tune the Mesh. The Delta Mesh Compensation System assumes the existence of
-   *                    an LCD Panel. It is possible to fine tune the mesh without an LCD Panel using
-   *                    G42 and M421. See the UBL documentation for further details.
-   *
-   *                    Phase 4 is meant to be used with G26 Mesh Validation to fine tune the mesh by direct editing
-   *                    of Mesh Points. Raise and lower points to fine tune the mesh until it gives consistently reliable
-   *                    adhesion.
-   *
-   *                    P4 moves to the closest Mesh Point (and/or the given X Y), raises the nozzle above the mesh height
-   *                    by the given 'H' offset (or default 0), and waits while the controller is used to adjust the nozzle
-   *                    height. On click the displayed height is saved in the mesh.
-   *
-   *                    Start Phase 4 at a specific location with X and Y. Adjust a specific number of Mesh Points with
-   *                    the 'R' (Repeat) parameter. (If 'R' is left out, the whole matrix is assumed.) This command can be
-   *                    terminated early (e.g., after editing the area of interest) by pressing and holding the encoder button.
-   *
-   *                    The general form is G29 P4 [R points] [X position] [Y position]
-   *
-   *                    The H [offset] parameter is useful if a shim is used to fine-tune the mesh. For a 0.4mm shim the
-   *                    command would be G29 P4 H0.4. The nozzle is moved to the shim height, you adjust height to the shim,
-   *                    and on click the height minus the shim thickness will be saved in the mesh.
-   *
-   *                    !!Use with caution, as a very poor mesh could cause the nozzle to crash into the bed!!
-   *
-   *                    NOTE:  P4 is not available unless you have LCD support enabled!
-   *
-   *   P5    Phase 5    Find Mean Mesh Height and Standard Deviation. Typically, it is easier to use and
-   *                    work with the Mesh if it is Mean Adjusted. You can specify a C parameter to
-   *                    Correct the Mesh to a 0.00 Mean Height. Adding a C parameter will automatically
-   *                    execute a G29 P6 C <mean height>.
-   *
-   *   P6    Phase 6    Shift Mesh height. The entire Mesh's height is adjusted by the height specified
-   *                    with the C parameter. Being able to adjust the height of a Mesh is useful tool. It
-   *                    can be used to compensate for poorly calibrated Z-Probes and other errors. Ideally,
-   *                    you should have the Mesh adjusted for a Mean Height of 0.00 and the Z-Probe measuring
-   *                    0.000 at the Z Home location.
-   *
-   *   Q     Test       Load specified Test Pattern to assist in checking correct operation of system. This
-   *                    command is not anticipated to be of much value to the typical user. It is intended
-   *                    for developers to help them verify correct operation of the Unified Bed Leveling System.
-   *
-   *   R #   Repeat     Repeat this command the specified number of times. If no number is specified the
-   *                    command will be repeated GRID_MAX_POINTS_X * GRID_MAX_POINTS_Y times.
-   *
-   *   S     Store      Store the current Mesh in the Activated area of the EEPROM. It will also store the
-   *                    current state of the Unified Bed Leveling system in the EEPROM.
-   *
-   *   S #   Store      Store the current Mesh at the specified location in EEPROM. Activate this location
-   *                    for subsequent Load and Store operations. Valid storage slot numbers begin at 0 and
-   *                    extend to a limit related to the available EEPROM storage.
-   *
-   *   S -1  Store      Print the current Mesh as G-code that can be used to restore the mesh anytime.
-   *
-   *   T     Topology   Display the Mesh Map Topology.
-   *                    'T' can be used alone (e.g., G29 T) or in combination with most of the other commands.
-   *                    This option works with all Phase commands (e.g., G29 P4 R 5 T X 50 Y100 C -.1 O)
-   *                    This parameter can also specify a Map Type. T0 (the default) is user-readable. T1
-   *                    is suitable to paste into a spreadsheet for a 3D graph of the mesh.
-   *
-   *   U     Unlevel    Perform a probe of the outer perimeter to assist in physically leveling unlevel beds.
-   *                    Only used for G29 P1 T U. This speeds up the probing of the edge of the bed. Useful
-   *                    when the entire bed doesn't need to be probed because it will be adjusted.
-   *
-   *   V #   Verbosity  Set the verbosity level (0-4) for extra details. (Default 0)
-   *
-   *   X #              X Location for this command
-   *
-   *   Y #              Y Location for this command
-   *
-   * With UBL_DEVEL_DEBUGGING:
-   *
-   *   K #  Kompare     Kompare current Mesh with stored Mesh #, replacing current Mesh with the result.
-   *                    This command literally performs a diff between two Meshes.
-   *
-   *   Q-1  Dump EEPROM Dump the UBL contents stored in EEPROM as HEX format. Useful for developers to help
-   *                    verify correct operation of the UBL.
-   *
-   *   W    What?       Display valuable UBL data.
-   *
-   *
-   *   Release Notes:
-   *   You MUST do M502, M500 to initialize the storage. Failure to do this will cause all
-   *   kinds of problems. Enabling EEPROM Storage is required.
-   *
-   *   When you do a G28 and G29 P1 to automatically build your first mesh, you are going to notice that
-   *   UBL probes points increasingly further from the starting location. (The starting location defaults
-   *   to the center of the bed.) In contrast, ABL and MBL follow a zigzag pattern. The spiral pattern is
-   *   especially better for Delta printers, since it populates the center of the mesh first, allowing for
-   *   a quicker test print to verify settings. You don't need to populate the entire mesh to use it.
-   *   After all, you don't want to spend a lot of time generating a mesh only to realize the resolution
-   *   or probe offsets are incorrect. Mesh-generation gathers points starting closest to the nozzle unless
-   *   an (X,Y) coordinate pair is given.
-   *
-   *   Unified Bed Leveling uses a lot of EEPROM storage to hold its data, and it takes some effort to get
-   *   the mesh just right. To prevent this valuable data from being destroyed as the EEPROM structure
-   *   evolves, UBL stores all mesh data at the end of EEPROM.
-   *
-   *   UBL is founded on Edward Patel's Mesh Bed Leveling code. A big 'Thanks!' to him and the creators of
-   *   3-Point and Grid Based leveling. Combining their contributions we now have the functionality and
-   *   features of all three systems combined.
-   */
+/**
+ *   G29: Unified Bed Leveling by Roxy
+ *
+ *   Parameters understood by this leveling system:
+ *
+ *   A     Activate   Activate the Unified Bed Leveling system.
+ *
+ *   B #   Business   Use the 'Business Card' mode of the Manual Probe subsystem with P2.
+ *                    Note: A non-compressible Spark Gap feeler gauge is recommended over a business card.
+ *                    In this mode of G29 P2, a business or index card is used as a shim that the nozzle can
+ *                    grab onto as it is lowered. In principle, the nozzle-bed distance is the same when the
+ *                    same resistance is felt in the shim. You can omit the numerical value on first invocation
+ *                    of G29 P2 B to measure shim thickness. Subsequent use of 'B' will apply the previously-
+ *                    measured thickness by default.
+ *
+ *   C     Continue   G29 P1 C continues the generation of a partially-constructed Mesh without invalidating
+ *                    previous measurements.
+ *
+ *   C                G29 P2 C tells the Manual Probe subsystem to not use the current nozzle
+ *                    location in its search for the closest unmeasured Mesh Point. Instead, attempt to
+ *                    start at one end of the uprobed points and Continue sequentially.
+ *
+ *                    G29 P3 C specifies the Constant for the fill. Otherwise, uses a "reasonable" value.
+ *
+ *   C     Current    G29 Z C uses the Current location (instead of bed center or nearest edge).
+ *
+ *   D     Disable    Disable the Unified Bed Leveling system.
+ *
+ *   E     Stow_probe Stow the probe after each sampled point.
+ *
+ *   F #   Fade       Fade the amount of Mesh Based Compensation over a specified height. At the
+ *                    specified height, no correction is applied and natural printer kenimatics take over. If no
+ *                    number is specified for the command, 10mm is assumed to be reasonable.
+ *
+ *   H #   Height     With P2, 'H' specifies the Height to raise the nozzle after each manual probe of the bed.
+ *                    If omitted, the nozzle will raise by Z_CLEARANCE_BETWEEN_PROBES.
+ *
+ *   H #   Offset     With P4, 'H' specifies the Offset above the mesh height to place the nozzle.
+ *                    If omitted, Z_CLEARANCE_BETWEEN_PROBES will be used.
+ *
+ *   I #   Invalidate Invalidate the specified number of Mesh Points near the given 'X' 'Y'. If X or Y are omitted,
+ *                    the nozzle location is used. If no 'I' value is given, only the point nearest to the location
+ *                    is invalidated. Use 'T' to produce a map afterward. This command is useful to invalidate a
+ *                    portion of the Mesh so it can be adjusted using other UBL tools. When attempting to invalidate
+ *                    an isolated bad mesh point, the 'T' option shows the nozzle position in the Mesh with (#). You
+ *                    can move the nozzle around and use this feature to select the center of the area (or cell) to
+ *                    invalidate.
+ *
+ *   J #   Grid       Perform a Grid Based Leveling of the current Mesh using a grid with n points on a side.
+ *                    Not specifying a grid size will invoke the 3-Point leveling function.
+ *
+ *   L     Load       Load Mesh from the previously activated location in the EEPROM.
+ *
+ *   L #   Load       Load Mesh from the specified location in the EEPROM. Set this location as activated
+ *                    for subsequent Load and Store operations.
+ *
+ *   The P or Phase commands are used for the bulk of the work to setup a Mesh. In general, your Mesh will
+ *   start off being initialized with a G29 P0 or a G29 P1. Further refinement of the Mesh happens with
+ *   each additional Phase that processes it.
+ *
+ *   P0    Phase 0    Zero Mesh Data and turn off the Mesh Compensation System. This reverts the
+ *                    3D Printer to the same state it was in before the Unified Bed Leveling Compensation
+ *                    was turned on. Setting the entire Mesh to Zero is a special case that allows
+ *                    a subsequent G or T leveling operation for backward compatibility.
+ *
+ *   P1    Phase 1    Invalidate entire Mesh and continue with automatic generation of the Mesh data using
+ *                    the Z-Probe. Usually the probe can't reach all areas that the nozzle can reach. For delta
+ *                    printers only the areas where the probe and nozzle can both reach will be automatically probed.
+ *
+ *                    Unreachable points will be handled in Phase 2 and Phase 3.
+ *
+ *                    Use 'C' to leave the previous mesh intact and automatically probe needed points. This allows you
+ *                    to invalidate parts of the Mesh but still use Automatic Probing.
+ *
+ *                    The 'X' and 'Y' parameters prioritize where to try and measure points. If omitted, the current
+ *                    probe position is used.
+ *
+ *                    Use 'T' (Topology) to generate a report of mesh generation.
+ *
+ *                    P1 will suspend Mesh generation if the controller button is held down. Note that you may need
+ *                    to press and hold the switch for several seconds if moves are underway.
+ *
+ *   P2    Phase 2    Probe unreachable points.
+ *
+ *                    Use 'H' to set the height between Mesh points. If omitted, Z_CLEARANCE_BETWEEN_PROBES is used.
+ *                    Smaller values will be quicker. Move the nozzle down till it barely touches the bed. Make sure the
+ *                    nozzle is clean and unobstructed. Use caution and move slowly. This can damage your printer!
+ *                    (Uses SIZE_OF_LITTLE_RAISE mm if the nozzle is moving less than BIG_RAISE_NOT_NEEDED mm.)
+ *
+ *                    The 'H' value can be negative if the Mesh dips in a large area. Press and hold the
+ *                    controller button to terminate the current Phase 2 command. You can then re-issue "G29 P 2"
+ *                    with an 'H' parameter more suitable for the area you're manually probing. Note that the command
+ *                    tries to start in a corner of the bed where movement will be predictable. Override the distance
+ *                    calculation location with the X and Y parameters. You can print a Mesh Map (G29 T) to see where
+ *                    the mesh is invalidated and where the nozzle needs to move to complete the command. Use 'C' to
+ *                    indicate that the search should be based on the current position.
+ *
+ *                    The 'B' parameter for this command is described above. It places the manual probe subsystem into
+ *                    Business Card mode where the thickness of a business card is measured and then used to accurately
+ *                    set the nozzle height in all manual probing for the duration of the command. A Business card can
+ *                    be used, but you'll get better results with a flexible Shim that doesn't compress. This makes it
+ *                    easier to produce similar amounts of force and get more accurate measurements. Google if you're
+ *                    not sure how to use a shim.
+ *
+ *                    The 'T' (Map) parameter helps track Mesh building progress.
+ *
+ *                    NOTE: P2 requires an LCD controller!
+ *
+ *   P3    Phase 3    Fill the unpopulated regions of the Mesh with a fixed value. There are two different paths to
+ *                    go down:
+ *
+ *                    - If a 'C' constant is specified, the closest invalid mesh points to the nozzle will be filled,
+ *                      and a repeat count can then also be specified with 'R'.
+ *
+ *                    - Leaving out 'C' invokes Smart Fill, which scans the mesh from the edges inward looking for
+ *                      invalid mesh points. Adjacent points are used to determine the bed slope. If the bed is sloped
+ *                      upward from the invalid point, it takes the value of the nearest point. If sloped downward, it's
+ *                      replaced by a value that puts all three points in a line. This version of G29 P3 is a quick, easy
+ *                      and (usually) safe way to populate unprobed mesh regions before continuing to G26 Mesh Validation
+ *                      Pattern. Note that this populates the mesh with unverified values. Pay attention and use caution.
+ *
+ *   P4    Phase 4    Fine tune the Mesh. The Delta Mesh Compensation System assumes the existence of
+ *                    an LCD Panel. It is possible to fine tune the mesh without an LCD Panel using
+ *                    G42 and M421. See the UBL documentation for further details.
+ *
+ *                    Phase 4 is meant to be used with G26 Mesh Validation to fine tune the mesh by direct editing
+ *                    of Mesh Points. Raise and lower points to fine tune the mesh until it gives consistently reliable
+ *                    adhesion.
+ *
+ *                    P4 moves to the closest Mesh Point (and/or the given X Y), raises the nozzle above the mesh height
+ *                    by the given 'H' offset (or default 0), and waits while the controller is used to adjust the nozzle
+ *                    height. On click the displayed height is saved in the mesh.
+ *
+ *                    Start Phase 4 at a specific location with X and Y. Adjust a specific number of Mesh Points with
+ *                    the 'R' (Repeat) parameter. (If 'R' is left out, the whole matrix is assumed.) This command can be
+ *                    terminated early (e.g., after editing the area of interest) by pressing and holding the encoder button.
+ *
+ *                    The general form is G29 P4 [R points] [X position] [Y position]
+ *
+ *                    The H [offset] parameter is useful if a shim is used to fine-tune the mesh. For a 0.4mm shim the
+ *                    command would be G29 P4 H0.4. The nozzle is moved to the shim height, you adjust height to the shim,
+ *                    and on click the height minus the shim thickness will be saved in the mesh.
+ *
+ *                    !!Use with caution, as a very poor mesh could cause the nozzle to crash into the bed!!
+ *
+ *                    NOTE:  P4 is not available unless you have LCD support enabled!
+ *
+ *   P5    Phase 5    Find Mean Mesh Height and Standard Deviation. Typically, it is easier to use and
+ *                    work with the Mesh if it is Mean Adjusted. You can specify a C parameter to
+ *                    Correct the Mesh to a 0.00 Mean Height. Adding a C parameter will automatically
+ *                    execute a G29 P6 C <mean height>.
+ *
+ *   P6    Phase 6    Shift Mesh height. The entire Mesh's height is adjusted by the height specified
+ *                    with the C parameter. Being able to adjust the height of a Mesh is useful tool. It
+ *                    can be used to compensate for poorly calibrated Z-Probes and other errors. Ideally,
+ *                    you should have the Mesh adjusted for a Mean Height of 0.00 and the Z-Probe measuring
+ *                    0.000 at the Z Home location.
+ *
+ *   Q     Test       Load specified Test Pattern to assist in checking correct operation of system. This
+ *                    command is not anticipated to be of much value to the typical user. It is intended
+ *                    for developers to help them verify correct operation of the Unified Bed Leveling System.
+ *
+ *   R #   Repeat     Repeat this command the specified number of times. If no number is specified the
+ *                    command will be repeated GRID_MAX_POINTS_X * GRID_MAX_POINTS_Y times.
+ *
+ *   S     Store      Store the current Mesh in the Activated area of the EEPROM. It will also store the
+ *                    current state of the Unified Bed Leveling system in the EEPROM.
+ *
+ *   S #   Store      Store the current Mesh at the specified location in EEPROM. Activate this location
+ *                    for subsequent Load and Store operations. Valid storage slot numbers begin at 0 and
+ *                    extend to a limit related to the available EEPROM storage.
+ *
+ *   S -1  Store      Print the current Mesh as G-code that can be used to restore the mesh anytime.
+ *
+ *   T     Topology   Display the Mesh Map Topology.
+ *                    'T' can be used alone (e.g., G29 T) or in combination with most of the other commands.
+ *                    This option works with all Phase commands (e.g., G29 P4 R 5 T X 50 Y100 C -.1 O)
+ *                    This parameter can also specify a Map Type. T0 (the default) is user-readable. T1
+ *                    is suitable to paste into a spreadsheet for a 3D graph of the mesh.
+ *
+ *   U     Unlevel    Perform a probe of the outer perimeter to assist in physically leveling unlevel beds.
+ *                    Only used for G29 P1 T U. This speeds up the probing of the edge of the bed. Useful
+ *                    when the entire bed doesn't need to be probed because it will be adjusted.
+ *
+ *   V #   Verbosity  Set the verbosity level (0-4) for extra details. (Default 0)
+ *
+ *   X #              X Location for this command
+ *
+ *   Y #              Y Location for this command
+ *
+ * With UBL_DEVEL_DEBUGGING:
+ *
+ *   K #  Kompare     Kompare current Mesh with stored Mesh #, replacing current Mesh with the result.
+ *                    This command literally performs a diff between two Meshes.
+ *
+ *   Q-1  Dump EEPROM Dump the UBL contents stored in EEPROM as HEX format. Useful for developers to help
+ *                    verify correct operation of the UBL.
+ *
+ *   W    What?       Display valuable UBL data.
+ *
+ *
+ *   Release Notes:
+ *   You MUST do M502, M500 to initialize the storage. Failure to do this will cause all
+ *   kinds of problems. Enabling EEPROM Storage is required.
+ *
+ *   When you do a G28 and G29 P1 to automatically build your first mesh, you are going to notice that
+ *   UBL probes points increasingly further from the starting location. (The starting location defaults
+ *   to the center of the bed.) In contrast, ABL and MBL follow a zigzag pattern. The spiral pattern is
+ *   especially better for Delta printers, since it populates the center of the mesh first, allowing for
+ *   a quicker test print to verify settings. You don't need to populate the entire mesh to use it.
+ *   After all, you don't want to spend a lot of time generating a mesh only to realize the resolution
+ *   or probe offsets are incorrect. Mesh-generation gathers points starting closest to the nozzle unless
+ *   an (X,Y) coordinate pair is given.
+ *
+ *   Unified Bed Leveling uses a lot of EEPROM storage to hold its data, and it takes some effort to get
+ *   the mesh just right. To prevent this valuable data from being destroyed as the EEPROM structure
+ *   evolves, UBL stores all mesh data at the end of EEPROM.
+ *
+ *   UBL is founded on Edward Patel's Mesh Bed Leveling code. A big 'Thanks!' to him and the creators of
+ *   3-Point and Grid Based leveling. Combining their contributions we now have the functionality and
+ *   features of all three systems combined.
+ */
 
-  void unified_bed_leveling::G29() {
+void unified_bed_leveling::G29() {
 
-    bool probe_deployed = false;
-    if (g29_parameter_parsing()) return; // Abort on parameter error
+  bool probe_deployed = false;
+  if (g29_parameter_parsing()) return; // Abort on parameter error
 
-    const int8_t p_val = parser.intval('P', -1);
-    const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J');
-    TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index = active_extruder);
+  const int8_t p_val = parser.intval('P', -1);
+  const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J');
+  TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index = active_extruder);
 
-    // Check for commands that require the printer to be homed
-    if (may_move) {
-      planner.synchronize();
-      // Send 'N' to force homing before G29 (internal only)
-      if (axes_should_home() || parser.seen('N')) gcode.home_all_axes();
-      TERN_(HAS_MULTI_HOTEND, if (active_extruder) tool_change(0));
-    }
+  // Check for commands that require the printer to be homed
+  if (may_move) {
+    planner.synchronize();
+    // Send 'N' to force homing before G29 (internal only)
+    if (axes_should_home() || parser.seen('N')) gcode.home_all_axes();
+    TERN_(HAS_MULTI_HOTEND, if (active_extruder) tool_change(0));
+  }
 
-    // Invalidate Mesh Points. This command is a little bit asymmetrical because
-    // it directly specifies the repetition count and does not use the 'R' parameter.
-    if (parser.seen('I')) {
-      uint8_t cnt = 0;
-      g29_repetition_cnt = parser.has_value() ? parser.value_int() : 1;
-      if (g29_repetition_cnt >= GRID_MAX_POINTS) {
-        set_all_mesh_points_to_value(NAN);
-      }
-      else {
-        while (g29_repetition_cnt--) {
-          if (cnt > 20) { cnt = 0; idle(); }
-          const mesh_index_pair closest = find_closest_mesh_point_of_type(REAL, g29_pos);
-          const xy_int8_t &cpos = closest.pos;
-          if (cpos.x < 0) {
-            // No more REAL mesh points to invalidate, so we ASSUME the user
-            // meant to invalidate the ENTIRE mesh, which cannot be done with
-            // find_closest_mesh_point loop which only returns REAL points.
-            set_all_mesh_points_to_value(NAN);
-            SERIAL_ECHOLNPGM("Entire Mesh invalidated.\n");
-            break;            // No more invalid Mesh Points to populate
-          }
-          z_values[cpos.x][cpos.y] = NAN;
-          TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(cpos, 0.0f));
-          cnt++;
+  // Invalidate Mesh Points. This command is a little bit asymmetrical because
+  // it directly specifies the repetition count and does not use the 'R' parameter.
+  if (parser.seen('I')) {
+    uint8_t cnt = 0;
+    g29_repetition_cnt = parser.has_value() ? parser.value_int() : 1;
+    if (g29_repetition_cnt >= GRID_MAX_POINTS) {
+      set_all_mesh_points_to_value(NAN);
+    }
+    else {
+      while (g29_repetition_cnt--) {
+        if (cnt > 20) { cnt = 0; idle(); }
+        const mesh_index_pair closest = find_closest_mesh_point_of_type(REAL, g29_pos);
+        const xy_int8_t &cpos = closest.pos;
+        if (cpos.x < 0) {
+          // No more REAL mesh points to invalidate, so we ASSUME the user
+          // meant to invalidate the ENTIRE mesh, which cannot be done with
+          // find_closest_mesh_point loop which only returns REAL points.
+          set_all_mesh_points_to_value(NAN);
+          SERIAL_ECHOLNPGM("Entire Mesh invalidated.\n");
+          break;            // No more invalid Mesh Points to populate
         }
+        z_values[cpos.x][cpos.y] = NAN;
+        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(cpos, 0.0f));
+        cnt++;
       }
-      SERIAL_ECHOLNPGM("Locations invalidated.\n");
     }
+    SERIAL_ECHOLNPGM("Locations invalidated.\n");
+  }
 
-    if (parser.seen('Q')) {
-      const int test_pattern = parser.has_value() ? parser.value_int() : -99;
-      if (!WITHIN(test_pattern, -1, 2)) {
-        SERIAL_ECHOLNPGM("Invalid test_pattern value. (-1 to 2)\n");
-        return;
-      }
-      SERIAL_ECHOLNPGM("Loading test_pattern values.\n");
-      switch (test_pattern) {
-
-        #if ENABLED(UBL_DEVEL_DEBUGGING)
-          case -1:
-            g29_eeprom_dump();
-            break;
-        #endif
+  if (parser.seen('Q')) {
+    const int test_pattern = parser.has_value() ? parser.value_int() : -99;
+    if (!WITHIN(test_pattern, -1, 2)) {
+      SERIAL_ECHOLNPGM("Invalid test_pattern value. (-1 to 2)\n");
+      return;
+    }
+    SERIAL_ECHOLNPGM("Loading test_pattern values.\n");
+    switch (test_pattern) {
 
-        case 0:
-          GRID_LOOP(x, y) {                                     // Create a bowl shape similar to a poorly-calibrated Delta
-            const float p1 = 0.5f * (GRID_MAX_POINTS_X) - x,
-                        p2 = 0.5f * (GRID_MAX_POINTS_Y) - y;
-            z_values[x][y] += 2.0f * HYPOT(p1, p2);
-            TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
-          }
+      #if ENABLED(UBL_DEVEL_DEBUGGING)
+        case -1:
+          g29_eeprom_dump();
           break;
+      #endif
 
-        case 1:
-          LOOP_L_N(x, GRID_MAX_POINTS_X) {                     // Create a diagonal line several Mesh cells thick that is raised
-            z_values[x][x] += 9.999f;
-            z_values[x][x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1] += 9.999f; // We want the altered line several mesh points thick
-            #if ENABLED(EXTENSIBLE_UI)
-              ExtUI::onMeshUpdate(x, x, z_values[x][x]);
-              ExtUI::onMeshUpdate(x, (x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1), z_values[x][x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1]);
-            #endif
+      case 0:
+        GRID_LOOP(x, y) {                                     // Create a bowl shape similar to a poorly-calibrated Delta
+          const float p1 = 0.5f * (GRID_MAX_POINTS_X) - x,
+                      p2 = 0.5f * (GRID_MAX_POINTS_Y) - y;
+          z_values[x][y] += 2.0f * HYPOT(p1, p2);
+          TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
+        }
+        break;
+
+      case 1:
+        LOOP_L_N(x, GRID_MAX_POINTS_X) {                     // Create a diagonal line several Mesh cells thick that is raised
+          z_values[x][x] += 9.999f;
+          z_values[x][x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1] += 9.999f; // We want the altered line several mesh points thick
+          #if ENABLED(EXTENSIBLE_UI)
+            ExtUI::onMeshUpdate(x, x, z_values[x][x]);
+            ExtUI::onMeshUpdate(x, (x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1), z_values[x][x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1]);
+          #endif
 
+        }
+        break;
+
+      case 2:
+        // Allow the user to specify the height because 10mm is a little extreme in some cases.
+        for (uint8_t x = (GRID_MAX_POINTS_X) / 3; x < 2 * (GRID_MAX_POINTS_X) / 3; x++)     // Create a rectangular raised area in
+          for (uint8_t y = (GRID_MAX_POINTS_Y) / 3; y < 2 * (GRID_MAX_POINTS_Y) / 3; y++) { // the center of the bed
+            z_values[x][y] += parser.seen('C') ? g29_constant : 9.99f;
+            TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
           }
-          break;
+        break;
+    }
+  }
 
-        case 2:
-          // Allow the user to specify the height because 10mm is a little extreme in some cases.
-          for (uint8_t x = (GRID_MAX_POINTS_X) / 3; x < 2 * (GRID_MAX_POINTS_X) / 3; x++)     // Create a rectangular raised area in
-            for (uint8_t y = (GRID_MAX_POINTS_Y) / 3; y < 2 * (GRID_MAX_POINTS_Y) / 3; y++) { // the center of the bed
-              z_values[x][y] += parser.seen('C') ? g29_constant : 9.99f;
-              TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
-            }
-          break;
-      }
+  #if HAS_BED_PROBE
+
+    if (parser.seen('J')) {
+      save_ubl_active_state_and_disable();
+      tilt_mesh_based_on_probed_grid(g29_grid_size == 0); // Zero size does 3-Point
+      restore_ubl_active_state_and_leave();
+      #if ENABLED(UBL_G29_J_RECENTER)
+        do_blocking_move_to_xy(0.5f * ((MESH_MIN_X) + (MESH_MAX_X)), 0.5f * ((MESH_MIN_Y) + (MESH_MAX_Y)));
+      #endif
+      report_current_position();
+      probe_deployed = true;
     }
 
-    #if HAS_BED_PROBE
+  #endif // HAS_BED_PROBE
 
-      if (parser.seen('J')) {
-        save_ubl_active_state_and_disable();
-        tilt_mesh_based_on_probed_grid(g29_grid_size == 0); // Zero size does 3-Point
-        restore_ubl_active_state_and_leave();
-        #if ENABLED(UBL_G29_J_RECENTER)
-          do_blocking_move_to_xy(0.5f * ((MESH_MIN_X) + (MESH_MAX_X)), 0.5f * ((MESH_MIN_Y) + (MESH_MAX_Y)));
-        #endif
-        report_current_position();
-        probe_deployed = true;
-      }
+  if (parser.seen('P')) {
+    if (WITHIN(g29_phase_value, 0, 1) && storage_slot == -1) {
+      storage_slot = 0;
+      SERIAL_ECHOLNPGM("Default storage slot 0 selected.");
+    }
 
-    #endif // HAS_BED_PROBE
+    switch (g29_phase_value) {
+      case 0:
+        //
+        // Zero Mesh Data
+        //
+        reset();
+        SERIAL_ECHOLNPGM("Mesh zeroed.");
+        break;
 
-    if (parser.seen('P')) {
-      if (WITHIN(g29_phase_value, 0, 1) && storage_slot == -1) {
-        storage_slot = 0;
-        SERIAL_ECHOLNPGM("Default storage slot 0 selected.");
-      }
+      #if HAS_BED_PROBE
 
-      switch (g29_phase_value) {
-        case 0:
+        case 1: {
           //
-          // Zero Mesh Data
+          // Invalidate Entire Mesh and Automatically Probe Mesh in areas that can be reached by the probe
           //
-          reset();
-          SERIAL_ECHOLNPGM("Mesh zeroed.");
-          break;
-
-        #if HAS_BED_PROBE
+          if (!parser.seen('C')) {
+            invalidate();
+            SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
+          }
+          if (g29_verbose_level > 1) {
+            SERIAL_ECHOPAIR("Probing around (", g29_pos.x);
+            SERIAL_CHAR(',');
+            SERIAL_DECIMAL(g29_pos.y);
+            SERIAL_ECHOLNPGM(").\n");
+          }
+          const xy_pos_t near_probe_xy = g29_pos + probe.offset_xy;
+          probe_entire_mesh(near_probe_xy, parser.seen('T'), parser.seen('E'), parser.seen('U'));
 
-          case 1: {
-            //
-            // Invalidate Entire Mesh and Automatically Probe Mesh in areas that can be reached by the probe
-            //
-            if (!parser.seen('C')) {
-              invalidate();
-              SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
-            }
-            if (g29_verbose_level > 1) {
-              SERIAL_ECHOPAIR("Probing around (", g29_pos.x);
-              SERIAL_CHAR(',');
-              SERIAL_DECIMAL(g29_pos.y);
-              SERIAL_ECHOLNPGM(").\n");
-            }
-            const xy_pos_t near_probe_xy = g29_pos + probe.offset_xy;
-            probe_entire_mesh(near_probe_xy, parser.seen('T'), parser.seen('E'), parser.seen('U'));
+          report_current_position();
+          probe_deployed = true;
+        } break;
 
-            report_current_position();
-            probe_deployed = true;
-          } break;
-
-        #endif // HAS_BED_PROBE
-
-        case 2: {
-          #if HAS_LCD_MENU
-            //
-            // Manually Probe Mesh in areas that can't be reached by the probe
-            //
-            SERIAL_ECHOLNPGM("Manually probing unreachable points.");
-            do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
-
-            if (parser.seen('C') && !xy_seen) {
-
-              /**
-               * Use a good default location for the path.
-               * The flipped > and < operators in these comparisons is intentional.
-               * It should cause the probed points to follow a nice path on Cartesian printers.
-               * It may make sense to have Delta printers default to the center of the bed.
-               * Until that is decided, this can be forced with the X and Y parameters.
-               */
-              g29_pos.set(
-                #if IS_KINEMATIC
-                  X_HOME_POS, Y_HOME_POS
-                #else
-                  probe.offset_xy.x > 0 ? X_BED_SIZE : 0,
-                  probe.offset_xy.y < 0 ? Y_BED_SIZE : 0
-                #endif
-              );
-            }
+      #endif // HAS_BED_PROBE
 
-            if (parser.seen('B')) {
-              g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness();
-              if (ABS(g29_card_thickness) > 1.5f) {
-                SERIAL_ECHOLNPGM("?Error in Business Card measurement.");
-                return;
-              }
-              probe_deployed = true;
-            }
+      case 2: {
+        #if HAS_LCD_MENU
+          //
+          // Manually Probe Mesh in areas that can't be reached by the probe
+          //
+          SERIAL_ECHOLNPGM("Manually probing unreachable points.");
+          do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
+
+          if (parser.seen('C') && !xy_seen) {
+
+            /**
+             * Use a good default location for the path.
+             * The flipped > and < operators in these comparisons is intentional.
+             * It should cause the probed points to follow a nice path on Cartesian printers.
+             * It may make sense to have Delta printers default to the center of the bed.
+             * Until that is decided, this can be forced with the X and Y parameters.
+             */
+            g29_pos.set(
+              #if IS_KINEMATIC
+                X_HOME_POS, Y_HOME_POS
+              #else
+                probe.offset_xy.x > 0 ? X_BED_SIZE : 0,
+                probe.offset_xy.y < 0 ? Y_BED_SIZE : 0
+              #endif
+            );
+          }
 
-            if (!position_is_reachable(g29_pos)) {
-              SERIAL_ECHOLNPGM("XY outside printable radius.");
+          if (parser.seen('B')) {
+            g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness();
+            if (ABS(g29_card_thickness) > 1.5f) {
+              SERIAL_ECHOLNPGM("?Error in Business Card measurement.");
               return;
             }
+            probe_deployed = true;
+          }
 
-            const float height = parser.floatval('H', Z_CLEARANCE_BETWEEN_PROBES);
-            manually_probe_remaining_mesh(g29_pos, height, g29_card_thickness, parser.seen('T'));
+          if (!position_is_reachable(g29_pos)) {
+            SERIAL_ECHOLNPGM("XY outside printable radius.");
+            return;
+          }
 
-            SERIAL_ECHOLNPGM("G29 P2 finished.");
+          const float height = parser.floatval('H', Z_CLEARANCE_BETWEEN_PROBES);
+          manually_probe_remaining_mesh(g29_pos, height, g29_card_thickness, parser.seen('T'));
 
-            report_current_position();
+          SERIAL_ECHOLNPGM("G29 P2 finished.");
 
-          #else
+          report_current_position();
 
-            SERIAL_ECHOLNPGM("?P2 is only available when an LCD is present.");
-            return;
+        #else
 
-          #endif
-        } break;
+          SERIAL_ECHOLNPGM("?P2 is only available when an LCD is present.");
+          return;
 
-        case 3: {
-          /**
-           * Populate invalid mesh areas. Proceed with caution.
-           * Two choices are available:
-           *   - Specify a constant with the 'C' parameter.
-           *   - Allow 'G29 P3' to choose a 'reasonable' constant.
-           */
-
-          if (g29_c_flag) {
-            if (g29_repetition_cnt >= GRID_MAX_POINTS) {
-              set_all_mesh_points_to_value(g29_constant);
-            }
-            else {
-              while (g29_repetition_cnt--) {  // this only populates reachable mesh points near
-                const mesh_index_pair closest = find_closest_mesh_point_of_type(INVALID, g29_pos);
-                const xy_int8_t &cpos = closest.pos;
-                if (cpos.x < 0) {
-                  // No more REAL INVALID mesh points to populate, so we ASSUME
-                  // user meant to populate ALL INVALID mesh points to value
-                  GRID_LOOP(x, y) if (isnan(z_values[x][y])) z_values[x][y] = g29_constant;
-                  break; // No more invalid Mesh Points to populate
-                }
-                else {
-                  z_values[cpos.x][cpos.y] = g29_constant;
-                  TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(cpos, g29_constant));
-                }
-              }
-            }
+        #endif
+      } break;
+
+      case 3: {
+        /**
+         * Populate invalid mesh areas. Proceed with caution.
+         * Two choices are available:
+         *   - Specify a constant with the 'C' parameter.
+         *   - Allow 'G29 P3' to choose a 'reasonable' constant.
+         */
+
+        if (g29_c_flag) {
+          if (g29_repetition_cnt >= GRID_MAX_POINTS) {
+            set_all_mesh_points_to_value(g29_constant);
           }
           else {
-            const float cvf = parser.value_float();
-            switch ((int)TRUNC(cvf * 10.0f) - 30) {   // 3.1 -> 1
-              #if ENABLED(UBL_G29_P31)
-                case 1: {
-
-                  // P3.1  use least squares fit to fill missing mesh values
-                  // P3.10 zero weighting for distance, all grid points equal, best fit tilted plane
-                  // P3.11 10X weighting for nearest grid points versus farthest grid points
-                  // P3.12 100X distance weighting
-                  // P3.13 1000X distance weighting, approaches simple average of nearest points
-
-                  const float weight_power  = (cvf - 3.10f) * 100.0f,  // 3.12345 -> 2.345
-                              weight_factor = weight_power ? POW(10.0f, weight_power) : 0;
-                  smart_fill_wlsf(weight_factor);
-                }
-                break;
-              #endif
-              case 0:   // P3 or P3.0
-              default:  // and anything P3.x that's not P3.1
-                smart_fill_mesh();  // Do a 'Smart' fill using nearby known values
-                break;
+            while (g29_repetition_cnt--) {  // this only populates reachable mesh points near
+              const mesh_index_pair closest = find_closest_mesh_point_of_type(INVALID, g29_pos);
+              const xy_int8_t &cpos = closest.pos;
+              if (cpos.x < 0) {
+                // No more REAL INVALID mesh points to populate, so we ASSUME
+                // user meant to populate ALL INVALID mesh points to value
+                GRID_LOOP(x, y) if (isnan(z_values[x][y])) z_values[x][y] = g29_constant;
+                break; // No more invalid Mesh Points to populate
+              }
+              else {
+                z_values[cpos.x][cpos.y] = g29_constant;
+                TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(cpos, g29_constant));
+              }
             }
           }
-          break;
         }
-
-        case 4: // Fine Tune (i.e., Edit) the Mesh
-          #if HAS_LCD_MENU
-            fine_tune_mesh(g29_pos, parser.seen('T'));
-          #else
-            SERIAL_ECHOLNPGM("?P4 is only available when an LCD is present.");
-            return;
-          #endif
-          break;
-
-        case 5: adjust_mesh_to_mean(g29_c_flag, g29_constant); break;
-
-        case 6: shift_mesh_height(); break;
+        else {
+          const float cvf = parser.value_float();
+          switch ((int)TRUNC(cvf * 10.0f) - 30) {   // 3.1 -> 1
+            #if ENABLED(UBL_G29_P31)
+              case 1: {
+
+                // P3.1  use least squares fit to fill missing mesh values
+                // P3.10 zero weighting for distance, all grid points equal, best fit tilted plane
+                // P3.11 10X weighting for nearest grid points versus farthest grid points
+                // P3.12 100X distance weighting
+                // P3.13 1000X distance weighting, approaches simple average of nearest points
+
+                const float weight_power  = (cvf - 3.10f) * 100.0f,  // 3.12345 -> 2.345
+                            weight_factor = weight_power ? POW(10.0f, weight_power) : 0;
+                smart_fill_wlsf(weight_factor);
+              }
+              break;
+            #endif
+            case 0:   // P3 or P3.0
+            default:  // and anything P3.x that's not P3.1
+              smart_fill_mesh();  // Do a 'Smart' fill using nearby known values
+              break;
+          }
+        }
+        break;
       }
-    }
-
-    #if ENABLED(UBL_DEVEL_DEBUGGING)
 
-      //
-      // Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
-      // good to have the extra information. Soon... we prune this to just a few items
-      //
-      if (parser.seen('W')) g29_what_command();
+      case 4: // Fine Tune (i.e., Edit) the Mesh
+        #if HAS_LCD_MENU
+          fine_tune_mesh(g29_pos, parser.seen('T'));
+        #else
+          SERIAL_ECHOLNPGM("?P4 is only available when an LCD is present.");
+          return;
+        #endif
+        break;
 
-      //
-      // When we are fully debugged, this may go away. But there are some valid
-      // use cases for the users. So we can wait and see what to do with it.
-      //
+      case 5: adjust_mesh_to_mean(g29_c_flag, g29_constant); break;
 
-      if (parser.seen('K')) // Kompare Current Mesh Data to Specified Stored Mesh
-        g29_compare_current_mesh_to_stored_mesh();
+      case 6: shift_mesh_height(); break;
+    }
+  }
 
-    #endif // UBL_DEVEL_DEBUGGING
+  #if ENABLED(UBL_DEVEL_DEBUGGING)
 
+    //
+    // Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
+    // good to have the extra information. Soon... we prune this to just a few items
+    //
+    if (parser.seen('W')) g29_what_command();
 
     //
-    // Load a Mesh from the EEPROM
+    // When we are fully debugged, this may go away. But there are some valid
+    // use cases for the users. So we can wait and see what to do with it.
     //
 
-    if (parser.seen('L')) {     // Load Current Mesh Data
-      g29_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
+    if (parser.seen('K')) // Kompare Current Mesh Data to Specified Stored Mesh
+      g29_compare_current_mesh_to_stored_mesh();
 
-      int16_t a = settings.calc_num_meshes();
+  #endif // UBL_DEVEL_DEBUGGING
 
-      if (!a) {
-        SERIAL_ECHOLNPGM("?EEPROM storage not available.");
-        return;
-      }
 
-      if (!WITHIN(g29_storage_slot, 0, a - 1)) {
-        SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
-        return;
-      }
+  //
+  // Load a Mesh from the EEPROM
+  //
+
+  if (parser.seen('L')) {     // Load Current Mesh Data
+    g29_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
 
-      settings.load_mesh(g29_storage_slot);
-      storage_slot = g29_storage_slot;
+    int16_t a = settings.calc_num_meshes();
 
-      SERIAL_ECHOLNPGM("Done.");
+    if (!a) {
+      SERIAL_ECHOLNPGM("?EEPROM storage not available.");
+      return;
     }
 
-    //
-    // Store a Mesh in the EEPROM
-    //
+    if (!WITHIN(g29_storage_slot, 0, a - 1)) {
+      SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
+      return;
+    }
 
-    if (parser.seen('S')) {     // Store (or Save) Current Mesh Data
-      g29_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
+    settings.load_mesh(g29_storage_slot);
+    storage_slot = g29_storage_slot;
 
-      if (g29_storage_slot == -1)                     // Special case, the user wants to 'Export' the mesh to the
-        return report_current_mesh();                 // host program to be saved on the user's computer
+    SERIAL_ECHOLNPGM("Done.");
+  }
 
-      int16_t a = settings.calc_num_meshes();
+  //
+  // Store a Mesh in the EEPROM
+  //
 
-      if (!a) {
-        SERIAL_ECHOLNPGM("?EEPROM storage not available.");
-        goto LEAVE;
-      }
+  if (parser.seen('S')) {     // Store (or Save) Current Mesh Data
+    g29_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
 
-      if (!WITHIN(g29_storage_slot, 0, a - 1)) {
-        SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
-        goto LEAVE;
-      }
+    if (g29_storage_slot == -1)                     // Special case, the user wants to 'Export' the mesh to the
+      return report_current_mesh();                 // host program to be saved on the user's computer
 
-      settings.store_mesh(g29_storage_slot);
-      storage_slot = g29_storage_slot;
+    int16_t a = settings.calc_num_meshes();
 
-      SERIAL_ECHOLNPGM("Done.");
+    if (!a) {
+      SERIAL_ECHOLNPGM("?EEPROM storage not available.");
+      goto LEAVE;
     }
 
-    if (parser.seen('T'))
-      display_map(g29_map_type);
+    if (!WITHIN(g29_storage_slot, 0, a - 1)) {
+      SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
+      goto LEAVE;
+    }
 
-    LEAVE:
+    settings.store_mesh(g29_storage_slot);
+    storage_slot = g29_storage_slot;
 
-    #if HAS_LCD_MENU
-      ui.reset_alert_level();
-      ui.quick_feedback();
-      ui.reset_status();
-      ui.release();
-    #endif
+    SERIAL_ECHOLNPGM("Done.");
+  }
 
-    #ifdef Z_PROBE_END_SCRIPT
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
-      if (probe_deployed) {
-        planner.synchronize();
-        gcode.process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
-      }
-    #else
-      UNUSED(probe_deployed);
-    #endif
+  if (parser.seen('T'))
+    display_map(g29_map_type);
 
-    TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index));
-    return;
-  }
+  LEAVE:
 
-  void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float value) {
-    float sum = 0;
-    int n = 0;
-    GRID_LOOP(x, y)
-      if (!isnan(z_values[x][y])) {
-        sum += z_values[x][y];
-        n++;
-      }
+  #if HAS_LCD_MENU
+    ui.reset_alert_level();
+    ui.quick_feedback();
+    ui.reset_status();
+    ui.release();
+  #endif
+
+  #ifdef Z_PROBE_END_SCRIPT
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
+    if (probe_deployed) {
+      planner.synchronize();
+      gcode.process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
+    }
+  #else
+    UNUSED(probe_deployed);
+  #endif
 
-    const float mean = sum / n;
+  TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index));
+  return;
+}
+
+void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float value) {
+  float sum = 0;
+  int n = 0;
+  GRID_LOOP(x, y)
+    if (!isnan(z_values[x][y])) {
+      sum += z_values[x][y];
+      n++;
+    }
 
-    //
-    // Sum the squares of difference from mean
-    //
-    float sum_of_diff_squared = 0;
-    GRID_LOOP(x, y)
-      if (!isnan(z_values[x][y]))
-        sum_of_diff_squared += sq(z_values[x][y] - mean);
+  const float mean = sum / n;
 
-    SERIAL_ECHOLNPAIR("# of samples: ", n);
-    SERIAL_ECHOLNPAIR_F("Mean Mesh Height: ", mean, 6);
+  //
+  // Sum the squares of difference from mean
+  //
+  float sum_of_diff_squared = 0;
+  GRID_LOOP(x, y)
+    if (!isnan(z_values[x][y]))
+      sum_of_diff_squared += sq(z_values[x][y] - mean);
 
-    const float sigma = SQRT(sum_of_diff_squared / (n + 1));
-    SERIAL_ECHOLNPAIR_F("Standard Deviation: ", sigma, 6);
+  SERIAL_ECHOLNPAIR("# of samples: ", n);
+  SERIAL_ECHOLNPAIR_F("Mean Mesh Height: ", mean, 6);
 
-    if (cflag)
-      GRID_LOOP(x, y)
-        if (!isnan(z_values[x][y])) {
-          z_values[x][y] -= mean + value;
-          TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
-        }
-  }
+  const float sigma = SQRT(sum_of_diff_squared / (n + 1));
+  SERIAL_ECHOLNPAIR_F("Standard Deviation: ", sigma, 6);
 
-  void unified_bed_leveling::shift_mesh_height() {
+  if (cflag)
     GRID_LOOP(x, y)
       if (!isnan(z_values[x][y])) {
-        z_values[x][y] += g29_constant;
+        z_values[x][y] -= mean + value;
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
       }
-  }
+}
 
-  #if HAS_BED_PROBE
-    /**
-     * Probe all invalidated locations of the mesh that can be reached by the probe.
-     * This attempts to fill in locations closest to the nozzle's start location first.
-     */
-    void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &nearby, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
-      probe.deploy(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
+void unified_bed_leveling::shift_mesh_height() {
+  GRID_LOOP(x, y)
+    if (!isnan(z_values[x][y])) {
+      z_values[x][y] += g29_constant;
+      TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
+    }
+}
 
-      TERN_(HAS_LCD_MENU, ui.capture());
+#if HAS_BED_PROBE
+  /**
+   * Probe all invalidated locations of the mesh that can be reached by the probe.
+   * This attempts to fill in locations closest to the nozzle's start location first.
+   */
+  void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &nearby, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
+    probe.deploy(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
 
-      save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
-      uint8_t count = GRID_MAX_POINTS;
+    TERN_(HAS_LCD_MENU, ui.capture());
 
-      mesh_index_pair best;
-      TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::MESH_START));
-      do {
-        if (do_ubl_mesh_map) display_map(g29_map_type);
+    save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
+    uint8_t count = GRID_MAX_POINTS;
 
-        const int point_num = (GRID_MAX_POINTS) - count + 1;
-        SERIAL_ECHOLNPAIR("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
-        TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), point_num, int(GRID_MAX_POINTS)));
+    mesh_index_pair best;
+    TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::MESH_START));
+    do {
+      if (do_ubl_mesh_map) display_map(g29_map_type);
 
-        #if HAS_LCD_MENU
-          if (ui.button_pressed()) {
-            ui.quick_feedback(false); // Preserve button state for click-and-hold
-            SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
-            ui.wait_for_release();
-            ui.quick_feedback();
-            ui.release();
-            probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
-            return restore_ubl_active_state_and_leave();
-          }
+      const int point_num = (GRID_MAX_POINTS) - count + 1;
+      SERIAL_ECHOLNPAIR("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
+      TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), point_num, int(GRID_MAX_POINTS)));
+
+      #if HAS_LCD_MENU
+        if (ui.button_pressed()) {
+          ui.quick_feedback(false); // Preserve button state for click-and-hold
+          SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
+          ui.wait_for_release();
+          ui.quick_feedback();
+          ui.release();
+          probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
+          return restore_ubl_active_state_and_leave();
+        }
+      #endif
+
+      best = do_furthest
+        ? find_furthest_invalid_mesh_point()
+        : find_closest_mesh_point_of_type(INVALID, nearby, true);
+
+      if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
+        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_START));
+        const float measured_z = probe.probe_at_point(
+                      best.meshpos(),
+                      stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level
+                    );
+        z_values[best.pos.x][best.pos.y] = measured_z;
+        #if ENABLED(EXTENSIBLE_UI)
+          ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_FINISH);
+          ExtUI::onMeshUpdate(best.pos, measured_z);
         #endif
+      }
+      SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
 
-        best = do_furthest
-          ? find_furthest_invalid_mesh_point()
-          : find_closest_mesh_point_of_type(INVALID, nearby, true);
-
-        if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
-          TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_START));
-          const float measured_z = probe.probe_at_point(
-                        best.meshpos(),
-                        stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level
-                      );
-          z_values[best.pos.x][best.pos.y] = measured_z;
-          #if ENABLED(EXTENSIBLE_UI)
-            ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_FINISH);
-            ExtUI::onMeshUpdate(best.pos, measured_z);
-          #endif
-        }
-        SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
+    } while (best.pos.x >= 0 && --count);
 
-      } while (best.pos.x >= 0 && --count);
+    TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::MESH_FINISH));
 
-      TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::MESH_FINISH));
+    // Release UI during stow to allow for PAUSE_BEFORE_DEPLOY_STOW
+    TERN_(HAS_LCD_MENU, ui.release());
+    probe.stow();
+    TERN_(HAS_LCD_MENU, ui.capture());
 
-      // Release UI during stow to allow for PAUSE_BEFORE_DEPLOY_STOW
-      TERN_(HAS_LCD_MENU, ui.release());
-      probe.stow();
-      TERN_(HAS_LCD_MENU, ui.capture());
+    probe.move_z_after_probing();
 
-      probe.move_z_after_probing();
+    restore_ubl_active_state_and_leave();
 
-      restore_ubl_active_state_and_leave();
+    do_blocking_move_to_xy(
+      constrain(nearby.x - probe.offset_xy.x, MESH_MIN_X, MESH_MAX_X),
+      constrain(nearby.y - probe.offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
+    );
+  }
 
-      do_blocking_move_to_xy(
-        constrain(nearby.x - probe.offset_xy.x, MESH_MIN_X, MESH_MAX_X),
-        constrain(nearby.y - probe.offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
-      );
-    }
+#endif // HAS_BED_PROBE
 
-  #endif // HAS_BED_PROBE
+#if HAS_LCD_MENU
 
-  #if HAS_LCD_MENU
+  typedef void (*clickFunc_t)();
 
-    typedef void (*clickFunc_t)();
-
-    bool click_and_hold(const clickFunc_t func=nullptr) {
-      if (ui.button_pressed()) {
-        ui.quick_feedback(false);         // Preserve button state for click-and-hold
-        const millis_t nxt = millis() + 1500UL;
-        while (ui.button_pressed()) {     // Loop while the encoder is pressed. Uses hardware flag!
-          idle();                         // idle, of course
-          if (ELAPSED(millis(), nxt)) {   // After 1.5 seconds
-            ui.quick_feedback();
-            if (func) (*func)();
-            ui.wait_for_release();
-            return true;
-          }
+  bool click_and_hold(const clickFunc_t func=nullptr) {
+    if (ui.button_pressed()) {
+      ui.quick_feedback(false);         // Preserve button state for click-and-hold
+      const millis_t nxt = millis() + 1500UL;
+      while (ui.button_pressed()) {     // Loop while the encoder is pressed. Uses hardware flag!
+        idle();                         // idle, of course
+        if (ELAPSED(millis(), nxt)) {   // After 1.5 seconds
+          ui.quick_feedback();
+          if (func) (*func)();
+          ui.wait_for_release();
+          return true;
         }
       }
-      serial_delay(15);
-      return false;
     }
+    serial_delay(15);
+    return false;
+  }
 
-    void unified_bed_leveling::move_z_with_encoder(const float &multiplier) {
-      ui.wait_for_release();
-      while (!ui.button_pressed()) {
-        idle();
-        gcode.reset_stepper_timeout(); // Keep steppers powered
-        if (encoder_diff) {
-          do_blocking_move_to_z(current_position.z + float(encoder_diff) * multiplier);
-          encoder_diff = 0;
-        }
+  void unified_bed_leveling::move_z_with_encoder(const float &multiplier) {
+    ui.wait_for_release();
+    while (!ui.button_pressed()) {
+      idle();
+      gcode.reset_stepper_timeout(); // Keep steppers powered
+      if (encoder_diff) {
+        do_blocking_move_to_z(current_position.z + float(encoder_diff) * multiplier);
+        encoder_diff = 0;
       }
     }
+  }
 
-    float unified_bed_leveling::measure_point_with_encoder() {
-      KEEPALIVE_STATE(PAUSED_FOR_USER);
-      move_z_with_encoder(0.01f);
-      return current_position.z;
-    }
-
-    static void echo_and_take_a_measurement() { SERIAL_ECHOLNPGM(" and take a measurement."); }
-
-    float unified_bed_leveling::measure_business_card_thickness() {
-      ui.capture();
-      save_ubl_active_state_and_disable();   // Disable bed level correction for probing
+  float unified_bed_leveling::measure_point_with_encoder() {
+    KEEPALIVE_STATE(PAUSED_FOR_USER);
+    move_z_with_encoder(0.01f);
+    return current_position.z;
+  }
 
-      do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), MANUAL_PROBE_START_Z);
-        //, _MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f);
-      planner.synchronize();
+  static void echo_and_take_a_measurement() { SERIAL_ECHOLNPGM(" and take a measurement."); }
 
-      SERIAL_ECHOPGM("Place shim under nozzle");
-      LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
-      ui.return_to_status();
-      echo_and_take_a_measurement();
+  float unified_bed_leveling::measure_business_card_thickness() {
+    ui.capture();
+    save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
-      const float z1 = measure_point_with_encoder();
-      do_blocking_move_to_z(current_position.z + SIZE_OF_LITTLE_RAISE);
-      planner.synchronize();
+    do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), MANUAL_PROBE_START_Z);
+      //, _MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f);
+    planner.synchronize();
 
-      SERIAL_ECHOPGM("Remove shim");
-      LCD_MESSAGEPGM(MSG_UBL_BC_REMOVE);
-      echo_and_take_a_measurement();
+    SERIAL_ECHOPGM("Place shim under nozzle");
+    LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
+    ui.return_to_status();
+    echo_and_take_a_measurement();
 
-      const float z2 = measure_point_with_encoder();
-      do_blocking_move_to_z(current_position.z + Z_CLEARANCE_BETWEEN_PROBES);
+    const float z1 = measure_point_with_encoder();
+    do_blocking_move_to_z(current_position.z + SIZE_OF_LITTLE_RAISE);
+    planner.synchronize();
 
-      const float thickness = ABS(z1 - z2);
+    SERIAL_ECHOPGM("Remove shim");
+    LCD_MESSAGEPGM(MSG_UBL_BC_REMOVE);
+    echo_and_take_a_measurement();
 
-      if (g29_verbose_level > 1) {
-        SERIAL_ECHOPAIR_F("Business Card is ", thickness, 4);
-        SERIAL_ECHOLNPGM("mm thick.");
-      }
+    const float z2 = measure_point_with_encoder();
+    do_blocking_move_to_z(current_position.z + Z_CLEARANCE_BETWEEN_PROBES);
 
-      restore_ubl_active_state_and_leave();
+    const float thickness = ABS(z1 - z2);
 
-      return thickness;
+    if (g29_verbose_level > 1) {
+      SERIAL_ECHOPAIR_F("Business Card is ", thickness, 4);
+      SERIAL_ECHOLNPGM("mm thick.");
     }
 
-    void unified_bed_leveling::manually_probe_remaining_mesh(const xy_pos_t &pos, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
-      ui.capture();
+    restore_ubl_active_state_and_leave();
 
-      save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
-      do_blocking_move_to_xy_z(current_position, z_clearance);
+    return thickness;
+  }
 
-      ui.return_to_status();
+  void unified_bed_leveling::manually_probe_remaining_mesh(const xy_pos_t &pos, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
+    ui.capture();
 
-      mesh_index_pair location;
-      const xy_int8_t &lpos = location.pos;
-      do {
-        location = find_closest_mesh_point_of_type(INVALID, pos);
-        // It doesn't matter if the probe can't reach the NAN location. This is a manual probe.
-        if (!location.valid()) continue;
-
-        const xyz_pos_t ppos = {
-          mesh_index_to_xpos(lpos.x),
-          mesh_index_to_ypos(lpos.y),
-          Z_CLEARANCE_BETWEEN_PROBES
-        };
+    save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
+    do_blocking_move_to_xy_z(current_position, z_clearance);
 
-        if (!position_is_reachable(ppos)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
+    ui.return_to_status();
 
-        LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
+    mesh_index_pair location;
+    const xy_int8_t &lpos = location.pos;
+    do {
+      location = find_closest_mesh_point_of_type(INVALID, pos);
+      // It doesn't matter if the probe can't reach the NAN location. This is a manual probe.
+      if (!location.valid()) continue;
 
-        do_blocking_move_to(ppos);
-        do_z_clearance(z_clearance);
+      const xyz_pos_t ppos = {
+        mesh_index_to_xpos(lpos.x),
+        mesh_index_to_ypos(lpos.y),
+        Z_CLEARANCE_BETWEEN_PROBES
+      };
 
-        KEEPALIVE_STATE(PAUSED_FOR_USER);
-        ui.capture();
+      if (!position_is_reachable(ppos)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
 
-        if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
+      LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
 
-        serialprintPGM(parser.seen('B') ? GET_TEXT(MSG_UBL_BC_INSERT) : GET_TEXT(MSG_UBL_BC_INSERT2));
+      do_blocking_move_to(ppos);
+      do_z_clearance(z_clearance);
 
-        const float z_step = 0.01f;                         // existing behavior: 0.01mm per click, occasionally step
-        //const float z_step = planner.steps_to_mm[Z_AXIS]; // approx one step each click
+      KEEPALIVE_STATE(PAUSED_FOR_USER);
+      ui.capture();
 
-        move_z_with_encoder(z_step);
+      if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
-        if (click_and_hold()) {
-          SERIAL_ECHOLNPGM("\nMesh only partially populated.");
-          do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
-          return restore_ubl_active_state_and_leave();
-        }
+      serialprintPGM(parser.seen('B') ? GET_TEXT(MSG_UBL_BC_INSERT) : GET_TEXT(MSG_UBL_BC_INSERT2));
 
-        z_values[lpos.x][lpos.y] = current_position.z - thick;
-        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, z_values[lpos.x][lpos.y]));
+      const float z_step = 0.01f;                         // existing behavior: 0.01mm per click, occasionally step
+      //const float z_step = planner.steps_to_mm[Z_AXIS]; // approx one step each click
 
-        if (g29_verbose_level > 2)
-          SERIAL_ECHOLNPAIR_F("Mesh Point Measured at: ", z_values[lpos.x][lpos.y], 6);
-        SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
-      } while (location.valid());
+      move_z_with_encoder(z_step);
 
-      if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
+      if (click_and_hold()) {
+        SERIAL_ECHOLNPGM("\nMesh only partially populated.");
+        do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
+        return restore_ubl_active_state_and_leave();
+      }
 
-      restore_ubl_active_state_and_leave();
-      do_blocking_move_to_xy_z(pos, Z_CLEARANCE_DEPLOY_PROBE);
-    }
+      z_values[lpos.x][lpos.y] = current_position.z - thick;
+      TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, z_values[lpos.x][lpos.y]));
 
-    inline void set_message_with_feedback(PGM_P const msg_P) {
-      ui.set_status_P(msg_P);
-      ui.quick_feedback();
-    }
+      if (g29_verbose_level > 2)
+        SERIAL_ECHOLNPAIR_F("Mesh Point Measured at: ", z_values[lpos.x][lpos.y], 6);
+      SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
+    } while (location.valid());
 
-    void abort_fine_tune() {
-      ui.return_to_status();
-      do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
-      set_message_with_feedback(GET_TEXT(MSG_EDITING_STOPPED));
-    }
+    if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
-    void unified_bed_leveling::fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) {
-      if (!parser.seen('R'))      // fine_tune_mesh() is special. If no repetition count flag is specified
-        g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
+    restore_ubl_active_state_and_leave();
+    do_blocking_move_to_xy_z(pos, Z_CLEARANCE_DEPLOY_PROBE);
+  }
 
-      #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
-        const float h_offset = parser.seenval('H') ? parser.value_linear_units() : MANUAL_PROBE_START_Z;
-        if (!WITHIN(h_offset, 0, 10)) {
-          SERIAL_ECHOLNPGM("Offset out of bounds. (0 to 10mm)\n");
-          return;
-        }
-      #endif
+  inline void set_message_with_feedback(PGM_P const msg_P) {
+    ui.set_status_P(msg_P);
+    ui.quick_feedback();
+  }
+
+  void abort_fine_tune() {
+    ui.return_to_status();
+    do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
+    set_message_with_feedback(GET_TEXT(MSG_EDITING_STOPPED));
+  }
 
-      mesh_index_pair location;
+  void unified_bed_leveling::fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) {
+    if (!parser.seen('R'))      // fine_tune_mesh() is special. If no repetition count flag is specified
+      g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 
-      if (!position_is_reachable(pos)) {
-        SERIAL_ECHOLNPGM("(X,Y) outside printable radius.");
+    #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
+      const float h_offset = parser.seenval('H') ? parser.value_linear_units() : MANUAL_PROBE_START_Z;
+      if (!WITHIN(h_offset, 0, 10)) {
+        SERIAL_ECHOLNPGM("Offset out of bounds. (0 to 10mm)\n");
         return;
       }
+    #endif
+
+    mesh_index_pair location;
+
+    if (!position_is_reachable(pos)) {
+      SERIAL_ECHOLNPGM("(X,Y) outside printable radius.");
+      return;
+    }
 
-      save_ubl_active_state_and_disable();
+    save_ubl_active_state_and_disable();
 
-      LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
-      ui.capture();                                               // Take over control of the LCD encoder
+    LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
+    ui.capture();                                               // Take over control of the LCD encoder
 
-      do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES);  // Move to the given XY with probe clearance
+    do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES);  // Move to the given XY with probe clearance
 
-      MeshFlags done_flags{0};
-      const xy_int8_t &lpos = location.pos;
+    MeshFlags done_flags{0};
+    const xy_int8_t &lpos = location.pos;
 
-      #if IS_TFTGLCD_PANEL
-        lcd_mesh_edit_setup(0);                             // Change current screen before calling ui.ubl_plot
-        safe_delay(50);
-      #endif
+    #if IS_TFTGLCD_PANEL
+      lcd_mesh_edit_setup(0);                             // Change current screen before calling ui.ubl_plot
+      safe_delay(50);
+    #endif
 
-      do {
-        location = find_closest_mesh_point_of_type(SET_IN_BITMAP, pos, false, &done_flags);
+    do {
+      location = find_closest_mesh_point_of_type(SET_IN_BITMAP, pos, false, &done_flags);
 
-        if (lpos.x < 0) break;                              // Stop when there are no more reachable points
+      if (lpos.x < 0) break;                              // Stop when there are no more reachable points
 
-        done_flags.mark(lpos);                              // Mark this location as 'adjusted' so a new
-                                                            // location is used on the next loop
-        const xyz_pos_t raw = {
-          mesh_index_to_xpos(lpos.x),
-          mesh_index_to_ypos(lpos.y),
-          Z_CLEARANCE_BETWEEN_PROBES
-        };
+      done_flags.mark(lpos);                              // Mark this location as 'adjusted' so a new
+                                                          // location is used on the next loop
+      const xyz_pos_t raw = {
+        mesh_index_to_xpos(lpos.x),
+        mesh_index_to_ypos(lpos.y),
+        Z_CLEARANCE_BETWEEN_PROBES
+      };
 
-        if (!position_is_reachable(raw)) break;             // SHOULD NOT OCCUR (find_closest_mesh_point_of_type only returns reachable)
+      if (!position_is_reachable(raw)) break;             // SHOULD NOT OCCUR (find_closest_mesh_point_of_type only returns reachable)
 
-        do_blocking_move_to(raw);                           // Move the nozzle to the edit point with probe clearance
+      do_blocking_move_to(raw);                           // Move the nozzle to the edit point with probe clearance
 
-        TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset)); // Move Z to the given 'H' offset before editing
+      TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset)); // Move Z to the given 'H' offset before editing
 
-        KEEPALIVE_STATE(PAUSED_FOR_USER);
+      KEEPALIVE_STATE(PAUSED_FOR_USER);
 
-        if (do_ubl_mesh_map) display_map(g29_map_type);     // Display the current point
+      if (do_ubl_mesh_map) display_map(g29_map_type);     // Display the current point
 
-        #if IS_TFTGLCD_PANEL
-          ui.ubl_plot(lpos.x, lpos.y);   // update plot screen
-        #endif
+      #if IS_TFTGLCD_PANEL
+        ui.ubl_plot(lpos.x, lpos.y);   // update plot screen
+      #endif
 
-        ui.refresh();
+      ui.refresh();
 
-        float new_z = z_values[lpos.x][lpos.y];
-        if (isnan(new_z)) new_z = 0;                        // Invalid points begin at 0
-        new_z = FLOOR(new_z * 1000) * 0.001f;               // Chop off digits after the 1000ths place
+      float new_z = z_values[lpos.x][lpos.y];
+      if (isnan(new_z)) new_z = 0;                        // Invalid points begin at 0
+      new_z = FLOOR(new_z * 1000) * 0.001f;               // Chop off digits after the 1000ths place
 
-        lcd_mesh_edit_setup(new_z);
+      lcd_mesh_edit_setup(new_z);
 
-        SET_SOFT_ENDSTOP_LOOSE(true);
+      SET_SOFT_ENDSTOP_LOOSE(true);
 
-        do {
-          idle();
-          new_z = lcd_mesh_edit();
-          TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset + new_z)); // Move the nozzle as the point is edited
-          SERIAL_FLUSH();                                   // Prevent host M105 buffer overrun.
-        } while (!ui.button_pressed());
+      do {
+        idle();
+        new_z = lcd_mesh_edit();
+        TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset + new_z)); // Move the nozzle as the point is edited
+        SERIAL_FLUSH();                                   // Prevent host M105 buffer overrun.
+      } while (!ui.button_pressed());
 
-        SET_SOFT_ENDSTOP_LOOSE(false);
+      SET_SOFT_ENDSTOP_LOOSE(false);
 
-        if (!lcd_map_control) ui.return_to_status();        // Just editing a single point? Return to status
+      if (!lcd_map_control) ui.return_to_status();        // Just editing a single point? Return to status
 
-        if (click_and_hold(abort_fine_tune)) break;         // Button held down? Abort editing
+      if (click_and_hold(abort_fine_tune)) break;         // Button held down? Abort editing
 
-        z_values[lpos.x][lpos.y] = new_z;                   // Save the updated Z value
-        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, new_z));
+      z_values[lpos.x][lpos.y] = new_z;                   // Save the updated Z value
+      TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, new_z));
 
-        serial_delay(20);                                   // No switch noise
-        ui.refresh();
+      serial_delay(20);                                   // No switch noise
+      ui.refresh();
 
-      } while (lpos.x >= 0 && --g29_repetition_cnt > 0);
+    } while (lpos.x >= 0 && --g29_repetition_cnt > 0);
 
-      if (do_ubl_mesh_map) display_map(g29_map_type);
-      restore_ubl_active_state_and_leave();
+    if (do_ubl_mesh_map) display_map(g29_map_type);
+    restore_ubl_active_state_and_leave();
 
-      do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES);
+    do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES);
 
-      LCD_MESSAGEPGM(MSG_UBL_DONE_EDITING_MESH);
-      SERIAL_ECHOLNPGM("Done Editing Mesh");
+    LCD_MESSAGEPGM(MSG_UBL_DONE_EDITING_MESH);
+    SERIAL_ECHOLNPGM("Done Editing Mesh");
 
-      if (lcd_map_control)
-        ui.goto_screen(ubl_map_screen);
-      else
-        ui.return_to_status();
-    }
+    if (lcd_map_control)
+      ui.goto_screen(ubl_map_screen);
+    else
+      ui.return_to_status();
+  }
 
-  #endif // HAS_LCD_MENU
+#endif // HAS_LCD_MENU
 
-  bool unified_bed_leveling::g29_parameter_parsing() {
-    bool err_flag = false;
+bool unified_bed_leveling::g29_parameter_parsing() {
+  bool err_flag = false;
 
-    TERN_(HAS_LCD_MENU, set_message_with_feedback(GET_TEXT(MSG_UBL_DOING_G29)));
+  TERN_(HAS_LCD_MENU, set_message_with_feedback(GET_TEXT(MSG_UBL_DOING_G29)));
 
-    g29_constant = 0;
-    g29_repetition_cnt = 0;
+  g29_constant = 0;
+  g29_repetition_cnt = 0;
 
-    if (parser.seen('R')) {
-      g29_repetition_cnt = parser.has_value() ? parser.value_int() : GRID_MAX_POINTS;
-      NOMORE(g29_repetition_cnt, GRID_MAX_POINTS);
-      if (g29_repetition_cnt < 1) {
-        SERIAL_ECHOLNPGM("?(R)epetition count invalid (1+).\n");
-        return UBL_ERR;
-      }
+  if (parser.seen('R')) {
+    g29_repetition_cnt = parser.has_value() ? parser.value_int() : GRID_MAX_POINTS;
+    NOMORE(g29_repetition_cnt, GRID_MAX_POINTS);
+    if (g29_repetition_cnt < 1) {
+      SERIAL_ECHOLNPGM("?(R)epetition count invalid (1+).\n");
+      return UBL_ERR;
     }
+  }
 
-    g29_verbose_level = parser.seen('V') ? parser.value_int() : 0;
-    if (!WITHIN(g29_verbose_level, 0, 4)) {
-      SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-4).\n");
-      err_flag = true;
-    }
+  g29_verbose_level = parser.seen('V') ? parser.value_int() : 0;
+  if (!WITHIN(g29_verbose_level, 0, 4)) {
+    SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-4).\n");
+    err_flag = true;
+  }
 
-    if (parser.seen('P')) {
-      const int pv = parser.value_int();
-      #if !HAS_BED_PROBE
-        if (pv == 1) {
-          SERIAL_ECHOLNPGM("G29 P1 requires a probe.\n");
+  if (parser.seen('P')) {
+    const int pv = parser.value_int();
+    #if !HAS_BED_PROBE
+      if (pv == 1) {
+        SERIAL_ECHOLNPGM("G29 P1 requires a probe.\n");
+        err_flag = true;
+      }
+      else
+    #endif
+      {
+        g29_phase_value = pv;
+        if (!WITHIN(g29_phase_value, 0, 6)) {
+          SERIAL_ECHOLNPGM("?(P)hase value invalid (0-6).\n");
           err_flag = true;
         }
-        else
-      #endif
-        {
-          g29_phase_value = pv;
-          if (!WITHIN(g29_phase_value, 0, 6)) {
-            SERIAL_ECHOLNPGM("?(P)hase value invalid (0-6).\n");
-            err_flag = true;
-          }
-        }
-    }
+      }
+  }
 
-    if (parser.seen('J')) {
-      #if HAS_BED_PROBE
-        g29_grid_size = parser.has_value() ? parser.value_int() : 0;
-        if (g29_grid_size && !WITHIN(g29_grid_size, 2, 9)) {
-          SERIAL_ECHOLNPGM("?Invalid grid size (J) specified (2-9).\n");
-          err_flag = true;
-        }
-      #else
-        SERIAL_ECHOLNPGM("G29 J action requires a probe.\n");
+  if (parser.seen('J')) {
+    #if HAS_BED_PROBE
+      g29_grid_size = parser.has_value() ? parser.value_int() : 0;
+      if (g29_grid_size && !WITHIN(g29_grid_size, 2, 9)) {
+        SERIAL_ECHOLNPGM("?Invalid grid size (J) specified (2-9).\n");
         err_flag = true;
-      #endif
-    }
-
-    xy_seen.x = parser.seenval('X');
-    float sx = xy_seen.x ? parser.value_float() : current_position.x;
-    xy_seen.y = parser.seenval('Y');
-    float sy = xy_seen.y ? parser.value_float() : current_position.y;
-
-    if (xy_seen.x != xy_seen.y) {
-      SERIAL_ECHOLNPGM("Both X & Y locations must be specified.\n");
+      }
+    #else
+      SERIAL_ECHOLNPGM("G29 J action requires a probe.\n");
       err_flag = true;
-    }
-
-    // If X or Y are not valid, use center of the bed values
-    if (!WITHIN(sx, X_MIN_BED, X_MAX_BED)) sx = X_CENTER;
-    if (!WITHIN(sy, Y_MIN_BED, Y_MAX_BED)) sy = Y_CENTER;
+    #endif
+  }
 
-    if (err_flag) return UBL_ERR;
+  xy_seen.x = parser.seenval('X');
+  float sx = xy_seen.x ? parser.value_float() : current_position.x;
+  xy_seen.y = parser.seenval('Y');
+  float sy = xy_seen.y ? parser.value_float() : current_position.y;
 
-    g29_pos.set(sx, sy);
+  if (xy_seen.x != xy_seen.y) {
+    SERIAL_ECHOLNPGM("Both X & Y locations must be specified.\n");
+    err_flag = true;
+  }
 
-    /**
-     * Activate or deactivate UBL
-     * Note: UBL's G29 restores the state set here when done.
-     *       Leveling is being enabled here with old data, possibly
-     *       none. Error handling should disable for safety...
-     */
-    if (parser.seen('A')) {
-      if (parser.seen('D')) {
-        SERIAL_ECHOLNPGM("?Can't activate and deactivate at the same time.\n");
-        return UBL_ERR;
-      }
-      set_bed_leveling_enabled(true);
-      report_state();
-    }
-    else if (parser.seen('D')) {
-      set_bed_leveling_enabled(false);
-      report_state();
-    }
+  // If X or Y are not valid, use center of the bed values
+  if (!WITHIN(sx, X_MIN_BED, X_MAX_BED)) sx = X_CENTER;
+  if (!WITHIN(sy, Y_MIN_BED, Y_MAX_BED)) sy = Y_CENTER;
 
-    // Set global 'C' flag and its value
-    if ((g29_c_flag = parser.seen('C')))
-      g29_constant = parser.value_float();
+  if (err_flag) return UBL_ERR;
 
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      if (parser.seenval('F')) {
-        const float fh = parser.value_float();
-        if (!WITHIN(fh, 0, 100)) {
-          SERIAL_ECHOLNPGM("?(F)ade height for Bed Level Correction not plausible.\n");
-          return UBL_ERR;
-        }
-        set_z_fade_height(fh);
-      }
-    #endif
+  g29_pos.set(sx, sy);
 
-    g29_map_type = parser.intval('T');
-    if (!WITHIN(g29_map_type, 0, 2)) {
-      SERIAL_ECHOLNPGM("Invalid map type.\n");
+  /**
+   * Activate or deactivate UBL
+   * Note: UBL's G29 restores the state set here when done.
+   *       Leveling is being enabled here with old data, possibly
+   *       none. Error handling should disable for safety...
+   */
+  if (parser.seen('A')) {
+    if (parser.seen('D')) {
+      SERIAL_ECHOLNPGM("?Can't activate and deactivate at the same time.\n");
       return UBL_ERR;
     }
-    return UBL_OK;
+    set_bed_leveling_enabled(true);
+    report_state();
+  }
+  else if (parser.seen('D')) {
+    set_bed_leveling_enabled(false);
+    report_state();
   }
 
-  static uint8_t ubl_state_at_invocation = 0;
+  // Set global 'C' flag and its value
+  if ((g29_c_flag = parser.seen('C')))
+    g29_constant = parser.value_float();
 
-  #if ENABLED(UBL_DEVEL_DEBUGGING)
-    static uint8_t ubl_state_recursion_chk = 0;
+  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+    if (parser.seenval('F')) {
+      const float fh = parser.value_float();
+      if (!WITHIN(fh, 0, 100)) {
+        SERIAL_ECHOLNPGM("?(F)ade height for Bed Level Correction not plausible.\n");
+        return UBL_ERR;
+      }
+      set_z_fade_height(fh);
+    }
   #endif
 
-  void unified_bed_leveling::save_ubl_active_state_and_disable() {
-    #if ENABLED(UBL_DEVEL_DEBUGGING)
-      ubl_state_recursion_chk++;
-      if (ubl_state_recursion_chk != 1) {
-        SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
-        TERN_(HAS_LCD_MENU, set_message_with_feedback(GET_TEXT(MSG_UBL_SAVE_ERROR)));
-        return;
-      }
-    #endif
-    ubl_state_at_invocation = planner.leveling_active;
-    set_bed_leveling_enabled(false);
+  g29_map_type = parser.intval('T');
+  if (!WITHIN(g29_map_type, 0, 2)) {
+    SERIAL_ECHOLNPGM("Invalid map type.\n");
+    return UBL_ERR;
   }
+  return UBL_OK;
+}
 
-  void unified_bed_leveling::restore_ubl_active_state_and_leave() {
-    TERN_(HAS_LCD_MENU, ui.release());
-    #if ENABLED(UBL_DEVEL_DEBUGGING)
-      if (--ubl_state_recursion_chk) {
-        SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
-        TERN_(HAS_LCD_MENU, set_message_with_feedback(GET_TEXT(MSG_UBL_RESTORE_ERROR)));
-        return;
-      }
-    #endif
-    set_bed_leveling_enabled(ubl_state_at_invocation);
-  }
+static uint8_t ubl_state_at_invocation = 0;
 
-  mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
+#if ENABLED(UBL_DEVEL_DEBUGGING)
+  static uint8_t ubl_state_recursion_chk = 0;
+#endif
+
+void unified_bed_leveling::save_ubl_active_state_and_disable() {
+  #if ENABLED(UBL_DEVEL_DEBUGGING)
+    ubl_state_recursion_chk++;
+    if (ubl_state_recursion_chk != 1) {
+      SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
+      TERN_(HAS_LCD_MENU, set_message_with_feedback(GET_TEXT(MSG_UBL_SAVE_ERROR)));
+      return;
+    }
+  #endif
+  ubl_state_at_invocation = planner.leveling_active;
+  set_bed_leveling_enabled(false);
+}
 
-    bool found_a_NAN = false, found_a_real = false;
+void unified_bed_leveling::restore_ubl_active_state_and_leave() {
+  TERN_(HAS_LCD_MENU, ui.release());
+  #if ENABLED(UBL_DEVEL_DEBUGGING)
+    if (--ubl_state_recursion_chk) {
+      SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
+      TERN_(HAS_LCD_MENU, set_message_with_feedback(GET_TEXT(MSG_UBL_RESTORE_ERROR)));
+      return;
+    }
+  #endif
+  set_bed_leveling_enabled(ubl_state_at_invocation);
+}
 
-    mesh_index_pair farthest { -1, -1, -99999.99 };
+mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
-    GRID_LOOP(i, j) {
-      if (!isnan(z_values[i][j])) continue;  // Skip valid mesh points
+  bool found_a_NAN = false, found_a_real = false;
 
-      // Skip unreachable points
-      if (!probe.can_reach(mesh_index_to_xpos(i), mesh_index_to_ypos(j)))
-        continue;
+  mesh_index_pair farthest { -1, -1, -99999.99 };
 
-      found_a_NAN = true;
+  GRID_LOOP(i, j) {
+    if (!isnan(z_values[i][j])) continue;  // Skip valid mesh points
 
-      xy_int8_t nearby { -1, -1 };
-      float d1, d2 = 99999.9f;
-      GRID_LOOP(k, l) {
-        if (isnan(z_values[k][l])) continue;
+    // Skip unreachable points
+    if (!probe.can_reach(mesh_index_to_xpos(i), mesh_index_to_ypos(j)))
+      continue;
 
-        found_a_real = true;
+    found_a_NAN = true;
 
-        // Add in a random weighting factor that scrambles the probing of the
-        // last half of the mesh (when every unprobed mesh point is one index
-        // from a probed location).
+    xy_int8_t nearby { -1, -1 };
+    float d1, d2 = 99999.9f;
+    GRID_LOOP(k, l) {
+      if (isnan(z_values[k][l])) continue;
 
-        d1 = HYPOT(i - k, j - l) + (1.0f / ((millis() % 47) + 13));
+      found_a_real = true;
 
-        if (d1 < d2) {    // Invalid mesh point (i,j) is closer to the defined point (k,l)
-          d2 = d1;
-          nearby.set(i, j);
-        }
-      }
+      // Add in a random weighting factor that scrambles the probing of the
+      // last half of the mesh (when every unprobed mesh point is one index
+      // from a probed location).
 
-      //
-      // At this point d2 should have the near defined mesh point to invalid mesh point (i,j)
-      //
+      d1 = HYPOT(i - k, j - l) + (1.0f / ((millis() % 47) + 13));
 
-      if (found_a_real && nearby.x >= 0 && d2 > farthest.distance) {
-        farthest.pos = nearby; // Found an invalid location farther from the defined mesh point
-        farthest.distance = d2;
+      if (d1 < d2) {    // Invalid mesh point (i,j) is closer to the defined point (k,l)
+        d2 = d1;
+        nearby.set(i, j);
       }
-    } // GRID_LOOP
+    }
+
+    //
+    // At this point d2 should have the near defined mesh point to invalid mesh point (i,j)
+    //
 
-    if (!found_a_real && found_a_NAN) {        // if the mesh is totally unpopulated, start the probing
-      farthest.pos.set((GRID_MAX_POINTS_X) / 2, (GRID_MAX_POINTS_Y) / 2);
-      farthest.distance = 1;
+    if (found_a_real && nearby.x >= 0 && d2 > farthest.distance) {
+      farthest.pos = nearby; // Found an invalid location farther from the defined mesh point
+      farthest.distance = d2;
     }
-    return farthest;
+  } // GRID_LOOP
+
+  if (!found_a_real && found_a_NAN) {        // if the mesh is totally unpopulated, start the probing
+    farthest.pos.set((GRID_MAX_POINTS_X) / 2, (GRID_MAX_POINTS_Y) / 2);
+    farthest.distance = 1;
   }
+  return farthest;
+}
 
-  mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const xy_pos_t &pos, const bool probe_relative/*=false*/, MeshFlags *done_flags/*=nullptr*/) {
-    mesh_index_pair closest;
-    closest.invalidate();
-    closest.distance = -99999.9f;
+mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const xy_pos_t &pos, const bool probe_relative/*=false*/, MeshFlags *done_flags/*=nullptr*/) {
+  mesh_index_pair closest;
+  closest.invalidate();
+  closest.distance = -99999.9f;
 
-    // Get the reference position, either nozzle or probe
-    const xy_pos_t ref = probe_relative ? pos + probe.offset_xy : pos;
+  // Get the reference position, either nozzle or probe
+  const xy_pos_t ref = probe_relative ? pos + probe.offset_xy : pos;
 
-    float best_so_far = 99999.99f;
+  float best_so_far = 99999.99f;
 
-    GRID_LOOP(i, j) {
-      if ( (type == (isnan(z_values[i][j]) ? INVALID : REAL))
-        || (type == SET_IN_BITMAP && !done_flags->marked(i, j))
-      ) {
-        // Found a Mesh Point of the specified type!
-        const xy_pos_t mpos = { mesh_index_to_xpos(i), mesh_index_to_ypos(j) };
-
-        // If using the probe as the reference there are some unreachable locations.
-        // Also for round beds, there are grid points outside the bed the nozzle can't reach.
-        // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
-
-        if (!(probe_relative ? probe.can_reach(mpos) : position_is_reachable(mpos)))
-          continue;
-
-        // Reachable. Check if it's the best_so_far location to the nozzle.
-
-        const xy_pos_t diff = current_position - mpos;
-        const float distance = (ref - mpos).magnitude() + diff.magnitude() * 0.1f;
-
-        // factor in the distance from the current location for the normal case
-        // so the nozzle isn't running all over the bed.
-        if (distance < best_so_far) {
-          best_so_far = distance;   // Found a closer location with the desired value type.
-          closest.pos.set(i, j);
-          closest.distance = best_so_far;
-        }
-      }
-    } // GRID_LOOP
+  GRID_LOOP(i, j) {
+    if ( (type == (isnan(z_values[i][j]) ? INVALID : REAL))
+      || (type == SET_IN_BITMAP && !done_flags->marked(i, j))
+    ) {
+      // Found a Mesh Point of the specified type!
+      const xy_pos_t mpos = { mesh_index_to_xpos(i), mesh_index_to_ypos(j) };
 
-    return closest;
-  }
+      // If using the probe as the reference there are some unreachable locations.
+      // Also for round beds, there are grid points outside the bed the nozzle can't reach.
+      // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
-  /**
-   * 'Smart Fill': Scan from the outward edges of the mesh towards the center.
-   * If an invalid location is found, use the next two points (if valid) to
-   * calculate a 'reasonable' value for the unprobed mesh point.
-   */
+      if (!(probe_relative ? probe.can_reach(mpos) : position_is_reachable(mpos)))
+        continue;
 
-  bool unified_bed_leveling::smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
-    const float v = z_values[x][y];
-    if (isnan(v)) {                           // A NAN...
-      const int8_t dx = x + xdir, dy = y + ydir;
-      const float v1 = z_values[dx][dy];
-      if (!isnan(v1)) {                       // ...next to a pair of real values?
-        const float v2 = z_values[dx + xdir][dy + ydir];
-        if (!isnan(v2)) {
-          z_values[x][y] = v1 < v2 ? v1 : v1 + v1 - v2;
-          TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
-          return true;
-        }
+      // Reachable. Check if it's the best_so_far location to the nozzle.
+
+      const xy_pos_t diff = current_position - mpos;
+      const float distance = (ref - mpos).magnitude() + diff.magnitude() * 0.1f;
+
+      // factor in the distance from the current location for the normal case
+      // so the nozzle isn't running all over the bed.
+      if (distance < best_so_far) {
+        best_so_far = distance;   // Found a closer location with the desired value type.
+        closest.pos.set(i, j);
+        closest.distance = best_so_far;
       }
     }
-    return false;
-  }
+  } // GRID_LOOP
 
-  typedef struct { uint8_t sx, ex, sy, ey; bool yfirst; } smart_fill_info;
-
-  void unified_bed_leveling::smart_fill_mesh() {
-    static const smart_fill_info
-      info0 PROGMEM = { 0, GRID_MAX_POINTS_X,      0, GRID_MAX_POINTS_Y - 2,  false },  // Bottom of the mesh looking up
-      info1 PROGMEM = { 0, GRID_MAX_POINTS_X,      GRID_MAX_POINTS_Y - 1, 0,  false },  // Top of the mesh looking down
-      info2 PROGMEM = { 0, GRID_MAX_POINTS_X - 2,  0, GRID_MAX_POINTS_Y,      true  },  // Left side of the mesh looking right
-      info3 PROGMEM = { GRID_MAX_POINTS_X - 1, 0,  0, GRID_MAX_POINTS_Y,      true  };  // Right side of the mesh looking left
-    static const smart_fill_info * const info[] PROGMEM = { &info0, &info1, &info2, &info3 };
-
-    LOOP_L_N(i, COUNT(info)) {
-      const smart_fill_info *f = (smart_fill_info*)pgm_read_ptr(&info[i]);
-      const int8_t sx = pgm_read_byte(&f->sx), sy = pgm_read_byte(&f->sy),
-                   ex = pgm_read_byte(&f->ex), ey = pgm_read_byte(&f->ey);
-      if (pgm_read_byte(&f->yfirst)) {
-        const int8_t dir = ex > sx ? 1 : -1;
-        for (uint8_t y = sy; y != ey; ++y)
-          for (uint8_t x = sx; x != ex; x += dir)
-            if (smart_fill_one(x, y, dir, 0)) break;
-      }
-      else {
-        const int8_t dir = ey > sy ? 1 : -1;
-         for (uint8_t x = sx; x != ex; ++x)
-          for (uint8_t y = sy; y != ey; y += dir)
-            if (smart_fill_one(x, y, 0, dir)) break;
+  return closest;
+}
+
+/**
+ * 'Smart Fill': Scan from the outward edges of the mesh towards the center.
+ * If an invalid location is found, use the next two points (if valid) to
+ * calculate a 'reasonable' value for the unprobed mesh point.
+ */
+
+bool unified_bed_leveling::smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
+  const float v = z_values[x][y];
+  if (isnan(v)) {                           // A NAN...
+    const int8_t dx = x + xdir, dy = y + ydir;
+    const float v1 = z_values[dx][dy];
+    if (!isnan(v1)) {                       // ...next to a pair of real values?
+      const float v2 = z_values[dx + xdir][dy + ydir];
+      if (!isnan(v2)) {
+        z_values[x][y] = v1 < v2 ? v1 : v1 + v1 - v2;
+        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
+        return true;
       }
     }
   }
+  return false;
+}
+
+typedef struct { uint8_t sx, ex, sy, ey; bool yfirst; } smart_fill_info;
+
+void unified_bed_leveling::smart_fill_mesh() {
+  static const smart_fill_info
+    info0 PROGMEM = { 0, GRID_MAX_POINTS_X,      0, GRID_MAX_POINTS_Y - 2,  false },  // Bottom of the mesh looking up
+    info1 PROGMEM = { 0, GRID_MAX_POINTS_X,      GRID_MAX_POINTS_Y - 1, 0,  false },  // Top of the mesh looking down
+    info2 PROGMEM = { 0, GRID_MAX_POINTS_X - 2,  0, GRID_MAX_POINTS_Y,      true  },  // Left side of the mesh looking right
+    info3 PROGMEM = { GRID_MAX_POINTS_X - 1, 0,  0, GRID_MAX_POINTS_Y,      true  };  // Right side of the mesh looking left
+  static const smart_fill_info * const info[] PROGMEM = { &info0, &info1, &info2, &info3 };
+
+  LOOP_L_N(i, COUNT(info)) {
+    const smart_fill_info *f = (smart_fill_info*)pgm_read_ptr(&info[i]);
+    const int8_t sx = pgm_read_byte(&f->sx), sy = pgm_read_byte(&f->sy),
+                 ex = pgm_read_byte(&f->ex), ey = pgm_read_byte(&f->ey);
+    if (pgm_read_byte(&f->yfirst)) {
+      const int8_t dir = ex > sx ? 1 : -1;
+      for (uint8_t y = sy; y != ey; ++y)
+        for (uint8_t x = sx; x != ex; x += dir)
+          if (smart_fill_one(x, y, dir, 0)) break;
+    }
+    else {
+      const int8_t dir = ey > sy ? 1 : -1;
+       for (uint8_t x = sx; x != ex; ++x)
+        for (uint8_t y = sy; y != ey; y += dir)
+          if (smart_fill_one(x, y, 0, dir)) break;
+    }
+  }
+}
 
-  #if HAS_BED_PROBE
+#if HAS_BED_PROBE
 
-    //#define VALIDATE_MESH_TILT
+  //#define VALIDATE_MESH_TILT
 
-    #include "../../../libs/vector_3.h"
+  #include "../../../libs/vector_3.h"
 
-    void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
-      const float x_min = probe.min_x(), x_max = probe.max_x(),
-                  y_min = probe.min_y(), y_max = probe.max_y(),
-                  dx = (x_max - x_min) / (g29_grid_size - 1),
-                  dy = (y_max - y_min) / (g29_grid_size - 1);
+  void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
+    const float x_min = probe.min_x(), x_max = probe.max_x(),
+                y_min = probe.min_y(), y_max = probe.max_y(),
+                dx = (x_max - x_min) / (g29_grid_size - 1),
+                dy = (y_max - y_min) / (g29_grid_size - 1);
 
-      xy_float_t points[3];
-      probe.get_three_points(points);
+    xy_float_t points[3];
+    probe.get_three_points(points);
 
-      float measured_z;
-      bool abort_flag = false;
+    float measured_z;
+    bool abort_flag = false;
 
-      #ifdef VALIDATE_MESH_TILT
-        float z1, z2, z3;  // Needed for algorithm validation below
-      #endif
+    #ifdef VALIDATE_MESH_TILT
+      float z1, z2, z3;  // Needed for algorithm validation below
+    #endif
+
+    struct linear_fit_data lsf_results;
+    incremental_LSF_reset(&lsf_results);
+
+    if (do_3_pt_leveling) {
+      SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
+      TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " 1/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
-      struct linear_fit_data lsf_results;
-      incremental_LSF_reset(&lsf_results);
+      measured_z = probe.probe_at_point(points[0], PROBE_PT_RAISE, g29_verbose_level);
+      if (isnan(measured_z))
+        abort_flag = true;
+      else {
+        measured_z -= get_z_correction(points[0]);
+        #ifdef VALIDATE_MESH_TILT
+          z1 = measured_z;
+        #endif
+        if (g29_verbose_level > 3) {
+          serial_spaces(16);
+          SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
+        }
+        incremental_LSF(&lsf_results, points[0], measured_z);
+      }
 
-      if (do_3_pt_leveling) {
-        SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
-        TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " 1/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
+      if (!abort_flag) {
+        SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
+        TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " 2/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
-        measured_z = probe.probe_at_point(points[0], PROBE_PT_RAISE, g29_verbose_level);
+        measured_z = probe.probe_at_point(points[1], PROBE_PT_RAISE, g29_verbose_level);
+        #ifdef VALIDATE_MESH_TILT
+          z2 = measured_z;
+        #endif
         if (isnan(measured_z))
           abort_flag = true;
         else {
-          measured_z -= get_z_correction(points[0]);
-          #ifdef VALIDATE_MESH_TILT
-            z1 = measured_z;
-          #endif
+          measured_z -= get_z_correction(points[1]);
           if (g29_verbose_level > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
-          incremental_LSF(&lsf_results, points[0], measured_z);
-        }
-
-        if (!abort_flag) {
-          SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
-          TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " 2/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
-
-          measured_z = probe.probe_at_point(points[1], PROBE_PT_RAISE, g29_verbose_level);
-          #ifdef VALIDATE_MESH_TILT
-            z2 = measured_z;
-          #endif
-          if (isnan(measured_z))
-            abort_flag = true;
-          else {
-            measured_z -= get_z_correction(points[1]);
-            if (g29_verbose_level > 3) {
-              serial_spaces(16);
-              SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
-            }
-            incremental_LSF(&lsf_results, points[1], measured_z);
-          }
+          incremental_LSF(&lsf_results, points[1], measured_z);
         }
+      }
 
-        if (!abort_flag) {
-          SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
-          TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
+      if (!abort_flag) {
+        SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
+        TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
-          measured_z = probe.probe_at_point(points[2], PROBE_PT_STOW, g29_verbose_level);
-          #ifdef VALIDATE_MESH_TILT
-            z3 = measured_z;
-          #endif
-          if (isnan(measured_z))
-            abort_flag = true;
-          else {
-            measured_z -= get_z_correction(points[2]);
-            if (g29_verbose_level > 3) {
-              serial_spaces(16);
-              SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
-            }
-            incremental_LSF(&lsf_results, points[2], measured_z);
+        measured_z = probe.probe_at_point(points[2], PROBE_PT_STOW, g29_verbose_level);
+        #ifdef VALIDATE_MESH_TILT
+          z3 = measured_z;
+        #endif
+        if (isnan(measured_z))
+          abort_flag = true;
+        else {
+          measured_z -= get_z_correction(points[2]);
+          if (g29_verbose_level > 3) {
+            serial_spaces(16);
+            SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
+          incremental_LSF(&lsf_results, points[2], measured_z);
         }
+      }
 
-        probe.stow();
-        probe.move_z_after_probing();
+      probe.stow();
+      probe.move_z_after_probing();
 
-        if (abort_flag) {
-          SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");
-          return;
-        }
+      if (abort_flag) {
+        SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");
+        return;
       }
-      else { // !do_3_pt_leveling
-
-        bool zig_zag = false;
-
-        const uint16_t total_points = sq(g29_grid_size);
-        uint16_t point_num = 1;
-
-        xy_pos_t rpos;
-        LOOP_L_N(ix, g29_grid_size) {
-          rpos.x = x_min + ix * dx;
-          LOOP_L_N(iy, g29_grid_size) {
-            rpos.y = y_min + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
-
-            if (!abort_flag) {
-              SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
-              TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
-
-              measured_z = probe.probe_at_point(rpos, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
-
-              abort_flag = isnan(measured_z);
-
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                if (DEBUGGING(LEVELING)) {
-                  const xy_pos_t lpos = rpos.asLogical();
-                  DEBUG_CHAR('(');
-                  DEBUG_ECHO_F(rpos.x, 7);
-                  DEBUG_CHAR(',');
-                  DEBUG_ECHO_F(rpos.y, 7);
-                  DEBUG_ECHOPAIR_F(")   logical: (", lpos.x, 7);
-                  DEBUG_CHAR(',');
-                  DEBUG_ECHO_F(lpos.y, 7);
-                  DEBUG_ECHOPAIR_F(")   measured: ", measured_z, 7);
-                  DEBUG_ECHOPAIR_F("   correction: ", get_z_correction(rpos), 7);
-                }
-              #endif
+    }
+    else { // !do_3_pt_leveling
+
+      bool zig_zag = false;
+
+      const uint16_t total_points = sq(g29_grid_size);
+      uint16_t point_num = 1;
+
+      xy_pos_t rpos;
+      LOOP_L_N(ix, g29_grid_size) {
+        rpos.x = x_min + ix * dx;
+        LOOP_L_N(iy, g29_grid_size) {
+          rpos.y = y_min + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
+
+          if (!abort_flag) {
+            SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
+            TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
+
+            measured_z = probe.probe_at_point(rpos, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
+
+            abort_flag = isnan(measured_z);
+
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) {
+                const xy_pos_t lpos = rpos.asLogical();
+                DEBUG_CHAR('(');
+                DEBUG_ECHO_F(rpos.x, 7);
+                DEBUG_CHAR(',');
+                DEBUG_ECHO_F(rpos.y, 7);
+                DEBUG_ECHOPAIR_F(")   logical: (", lpos.x, 7);
+                DEBUG_CHAR(',');
+                DEBUG_ECHO_F(lpos.y, 7);
+                DEBUG_ECHOPAIR_F(")   measured: ", measured_z, 7);
+                DEBUG_ECHOPAIR_F("   correction: ", get_z_correction(rpos), 7);
+              }
+            #endif
 
-              measured_z -= get_z_correction(rpos) /* + probe.offset.z */ ;
+            measured_z -= get_z_correction(rpos) /* + probe.offset.z */ ;
 
-              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("   final >>>---> ", measured_z, 7);
+            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("   final >>>---> ", measured_z, 7);
 
-              if (g29_verbose_level > 3) {
-                serial_spaces(16);
-                SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
-              }
-              incremental_LSF(&lsf_results, rpos, measured_z);
+            if (g29_verbose_level > 3) {
+              serial_spaces(16);
+              SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
-
-            point_num++;
+            incremental_LSF(&lsf_results, rpos, measured_z);
           }
 
-          zig_zag ^= true;
+          point_num++;
         }
-      }
-      probe.stow();
-      probe.move_z_after_probing();
 
-      if (abort_flag || finish_incremental_LSF(&lsf_results)) {
-        SERIAL_ECHOPGM("Could not complete LSF!");
-        return;
+        zig_zag ^= true;
       }
+    }
+    probe.stow();
+    probe.move_z_after_probing();
 
-      vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1).get_normal();
+    if (abort_flag || finish_incremental_LSF(&lsf_results)) {
+      SERIAL_ECHOPGM("Could not complete LSF!");
+      return;
+    }
 
-      if (g29_verbose_level > 2) {
-        SERIAL_ECHOPAIR_F("bed plane normal = [", normal.x, 7);
-        SERIAL_CHAR(',');
-        SERIAL_ECHO_F(normal.y, 7);
-        SERIAL_CHAR(',');
-        SERIAL_ECHO_F(normal.z, 7);
-        SERIAL_ECHOLNPGM("]");
-      }
+    vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1).get_normal();
 
-      matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
-
-      GRID_LOOP(i, j) {
-        float mx = mesh_index_to_xpos(i),
-              my = mesh_index_to_ypos(j),
-              mz = z_values[i][j];
-
-        if (DEBUGGING(LEVELING)) {
-          DEBUG_ECHOPAIR_F("before rotation = [", mx, 7);
-          DEBUG_CHAR(',');
-          DEBUG_ECHO_F(my, 7);
-          DEBUG_CHAR(',');
-          DEBUG_ECHO_F(mz, 7);
-          DEBUG_ECHOPGM("]   ---> ");
-          DEBUG_DELAY(20);
-        }
+    if (g29_verbose_level > 2) {
+      SERIAL_ECHOPAIR_F("bed plane normal = [", normal.x, 7);
+      SERIAL_CHAR(',');
+      SERIAL_ECHO_F(normal.y, 7);
+      SERIAL_CHAR(',');
+      SERIAL_ECHO_F(normal.z, 7);
+      SERIAL_ECHOLNPGM("]");
+    }
 
-        apply_rotation_xyz(rotation, mx, my, mz);
+    matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
 
-        if (DEBUGGING(LEVELING)) {
-          DEBUG_ECHOPAIR_F("after rotation = [", mx, 7);
-          DEBUG_CHAR(',');
-          DEBUG_ECHO_F(my, 7);
-          DEBUG_CHAR(',');
-          DEBUG_ECHO_F(mz, 7);
-          DEBUG_ECHOLNPGM("]");
-          DEBUG_DELAY(20);
-        }
+    GRID_LOOP(i, j) {
+      float mx = mesh_index_to_xpos(i),
+            my = mesh_index_to_ypos(j),
+            mz = z_values[i][j];
 
-        z_values[i][j] = mz - lsf_results.D;
-        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(i, j, z_values[i][j]));
+      if (DEBUGGING(LEVELING)) {
+        DEBUG_ECHOPAIR_F("before rotation = [", mx, 7);
+        DEBUG_CHAR(',');
+        DEBUG_ECHO_F(my, 7);
+        DEBUG_CHAR(',');
+        DEBUG_ECHO_F(mz, 7);
+        DEBUG_ECHOPGM("]   ---> ");
+        DEBUG_DELAY(20);
       }
 
-      if (DEBUGGING(LEVELING)) {
-        rotation.debug(PSTR("rotation matrix:\n"));
-        DEBUG_ECHOPAIR_F("LSF Results A=", lsf_results.A, 7);
-        DEBUG_ECHOPAIR_F("  B=", lsf_results.B, 7);
-        DEBUG_ECHOLNPAIR_F("  D=", lsf_results.D, 7);
-        DEBUG_DELAY(55);
+      apply_rotation_xyz(rotation, mx, my, mz);
 
-        DEBUG_ECHOPAIR_F("bed plane normal = [", normal.x, 7);
+      if (DEBUGGING(LEVELING)) {
+        DEBUG_ECHOPAIR_F("after rotation = [", mx, 7);
         DEBUG_CHAR(',');
-        DEBUG_ECHO_F(normal.y, 7);
+        DEBUG_ECHO_F(my, 7);
         DEBUG_CHAR(',');
-        DEBUG_ECHO_F(normal.z, 7);
+        DEBUG_ECHO_F(mz, 7);
         DEBUG_ECHOLNPGM("]");
-        DEBUG_EOL();
-
-        /**
-         * Use the code below to check the validity of the mesh tilting algorithm.
-         * 3-Point Mesh Tilt uses the same algorithm as grid-based tilting, but only
-         * three points are used in the calculation. This guarantees that each probed point
-         * has an exact match when get_z_correction() for that location is calculated.
-         * The Z error between the probed point locations and the get_z_correction()
-         * numbers for those locations should be 0.
-         */
-        #ifdef VALIDATE_MESH_TILT
-          auto d_from = []{ DEBUG_ECHOPGM("D from "); };
-          auto normed = [&](const xy_pos_t &pos, const float &zadd) {
-            return normal.x * pos.x + normal.y * pos.y + zadd;
-          };
-          auto debug_pt = [](PGM_P const pre, const xy_pos_t &pos, const float &zadd) {
-            d_from(); serialprintPGM(pre);
-            DEBUG_ECHO_F(normed(pos, zadd), 6);
-            DEBUG_ECHOLNPAIR_F("   Z error = ", zadd - get_z_correction(pos), 6);
-          };
-          debug_pt(PSTR("1st point: "), probe_pt[0], normal.z * z1);
-          debug_pt(PSTR("2nd point: "), probe_pt[1], normal.z * z2);
-          debug_pt(PSTR("3rd point: "), probe_pt[2], normal.z * z3);
-          d_from(); DEBUG_ECHOPGM("safe home with Z=");
-          DEBUG_ECHOLNPAIR_F("0 : ", normed(safe_homing_xy, 0), 6);
-          d_from(); DEBUG_ECHOPGM("safe home with Z=");
-          DEBUG_ECHOLNPAIR_F("mesh value ", normed(safe_homing_xy, get_z_correction(safe_homing_xy)), 6);
-          DEBUG_ECHOPAIR("   Z error = (", Z_SAFE_HOMING_X_POINT, ",", Z_SAFE_HOMING_Y_POINT);
-          DEBUG_ECHOLNPAIR_F(") = ", get_z_correction(safe_homing_xy), 6);
-        #endif
-      } // DEBUGGING(LEVELING)
+        DEBUG_DELAY(20);
+      }
 
+      z_values[i][j] = mz - lsf_results.D;
+      TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(i, j, z_values[i][j]));
     }
 
-  #endif // HAS_BED_PROBE
+    if (DEBUGGING(LEVELING)) {
+      rotation.debug(PSTR("rotation matrix:\n"));
+      DEBUG_ECHOPAIR_F("LSF Results A=", lsf_results.A, 7);
+      DEBUG_ECHOPAIR_F("  B=", lsf_results.B, 7);
+      DEBUG_ECHOLNPAIR_F("  D=", lsf_results.D, 7);
+      DEBUG_DELAY(55);
+
+      DEBUG_ECHOPAIR_F("bed plane normal = [", normal.x, 7);
+      DEBUG_CHAR(',');
+      DEBUG_ECHO_F(normal.y, 7);
+      DEBUG_CHAR(',');
+      DEBUG_ECHO_F(normal.z, 7);
+      DEBUG_ECHOLNPGM("]");
+      DEBUG_EOL();
+
+      /**
+       * Use the code below to check the validity of the mesh tilting algorithm.
+       * 3-Point Mesh Tilt uses the same algorithm as grid-based tilting, but only
+       * three points are used in the calculation. This guarantees that each probed point
+       * has an exact match when get_z_correction() for that location is calculated.
+       * The Z error between the probed point locations and the get_z_correction()
+       * numbers for those locations should be 0.
+       */
+      #ifdef VALIDATE_MESH_TILT
+        auto d_from = []{ DEBUG_ECHOPGM("D from "); };
+        auto normed = [&](const xy_pos_t &pos, const float &zadd) {
+          return normal.x * pos.x + normal.y * pos.y + zadd;
+        };
+        auto debug_pt = [](PGM_P const pre, const xy_pos_t &pos, const float &zadd) {
+          d_from(); serialprintPGM(pre);
+          DEBUG_ECHO_F(normed(pos, zadd), 6);
+          DEBUG_ECHOLNPAIR_F("   Z error = ", zadd - get_z_correction(pos), 6);
+        };
+        debug_pt(PSTR("1st point: "), probe_pt[0], normal.z * z1);
+        debug_pt(PSTR("2nd point: "), probe_pt[1], normal.z * z2);
+        debug_pt(PSTR("3rd point: "), probe_pt[2], normal.z * z3);
+        d_from(); DEBUG_ECHOPGM("safe home with Z=");
+        DEBUG_ECHOLNPAIR_F("0 : ", normed(safe_homing_xy, 0), 6);
+        d_from(); DEBUG_ECHOPGM("safe home with Z=");
+        DEBUG_ECHOLNPAIR_F("mesh value ", normed(safe_homing_xy, get_z_correction(safe_homing_xy)), 6);
+        DEBUG_ECHOPAIR("   Z error = (", Z_SAFE_HOMING_X_POINT, ",", Z_SAFE_HOMING_Y_POINT);
+        DEBUG_ECHOLNPAIR_F(") = ", get_z_correction(safe_homing_xy), 6);
+      #endif
+    } // DEBUGGING(LEVELING)
+
+  }
 
-  #if ENABLED(UBL_G29_P31)
-    void unified_bed_leveling::smart_fill_wlsf(const float &weight_factor) {
-
-      // For each undefined mesh point, compute a distance-weighted least squares fit
-      // from all the originally populated mesh points, weighted toward the point
-      // being extrapolated so that nearby points will have greater influence on
-      // the point being extrapolated.  Then extrapolate the mesh point from WLSF.
-
-      static_assert((GRID_MAX_POINTS_Y) <= 16, "GRID_MAX_POINTS_Y too big");
-      uint16_t bitmap[GRID_MAX_POINTS_X] = { 0 };
-      struct linear_fit_data lsf_results;
-
-      SERIAL_ECHOPGM("Extrapolating mesh...");
-
-      const float weight_scaled = weight_factor * _MAX(MESH_X_DIST, MESH_Y_DIST);
-
-      GRID_LOOP(jx, jy) if (!isnan(z_values[jx][jy])) SBI(bitmap[jx], jy);
-
-      xy_pos_t ppos;
-      LOOP_L_N(ix, GRID_MAX_POINTS_X) {
-        ppos.x = mesh_index_to_xpos(ix);
-        LOOP_L_N(iy, GRID_MAX_POINTS_Y) {
-          ppos.y = mesh_index_to_ypos(iy);
-          if (isnan(z_values[ix][iy])) {
-            // undefined mesh point at (ppos.x,ppos.y), compute weighted LSF from original valid mesh points.
-            incremental_LSF_reset(&lsf_results);
-            xy_pos_t rpos;
-            LOOP_L_N(jx, GRID_MAX_POINTS_X) {
-              rpos.x = mesh_index_to_xpos(jx);
-              LOOP_L_N(jy, GRID_MAX_POINTS_Y) {
-                if (TEST(bitmap[jx], jy)) {
-                  rpos.y = mesh_index_to_ypos(jy);
-                  const float rz = z_values[jx][jy],
-                               w = 1.0f + weight_scaled / (rpos - ppos).magnitude();
-                  incremental_WLSF(&lsf_results, rpos, rz, w);
-                }
+#endif // HAS_BED_PROBE
+
+#if ENABLED(UBL_G29_P31)
+  void unified_bed_leveling::smart_fill_wlsf(const float &weight_factor) {
+
+    // For each undefined mesh point, compute a distance-weighted least squares fit
+    // from all the originally populated mesh points, weighted toward the point
+    // being extrapolated so that nearby points will have greater influence on
+    // the point being extrapolated.  Then extrapolate the mesh point from WLSF.
+
+    static_assert((GRID_MAX_POINTS_Y) <= 16, "GRID_MAX_POINTS_Y too big");
+    uint16_t bitmap[GRID_MAX_POINTS_X] = { 0 };
+    struct linear_fit_data lsf_results;
+
+    SERIAL_ECHOPGM("Extrapolating mesh...");
+
+    const float weight_scaled = weight_factor * _MAX(MESH_X_DIST, MESH_Y_DIST);
+
+    GRID_LOOP(jx, jy) if (!isnan(z_values[jx][jy])) SBI(bitmap[jx], jy);
+
+    xy_pos_t ppos;
+    LOOP_L_N(ix, GRID_MAX_POINTS_X) {
+      ppos.x = mesh_index_to_xpos(ix);
+      LOOP_L_N(iy, GRID_MAX_POINTS_Y) {
+        ppos.y = mesh_index_to_ypos(iy);
+        if (isnan(z_values[ix][iy])) {
+          // undefined mesh point at (ppos.x,ppos.y), compute weighted LSF from original valid mesh points.
+          incremental_LSF_reset(&lsf_results);
+          xy_pos_t rpos;
+          LOOP_L_N(jx, GRID_MAX_POINTS_X) {
+            rpos.x = mesh_index_to_xpos(jx);
+            LOOP_L_N(jy, GRID_MAX_POINTS_Y) {
+              if (TEST(bitmap[jx], jy)) {
+                rpos.y = mesh_index_to_ypos(jy);
+                const float rz = z_values[jx][jy],
+                             w = 1.0f + weight_scaled / (rpos - ppos).magnitude();
+                incremental_WLSF(&lsf_results, rpos, rz, w);
               }
             }
-            if (finish_incremental_LSF(&lsf_results)) {
-              SERIAL_ECHOLNPGM("Insufficient data");
-              return;
-            }
-            const float ez = -lsf_results.D - lsf_results.A * ppos.x - lsf_results.B * ppos.y;
-            z_values[ix][iy] = ez;
-            TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(ix, iy, z_values[ix][iy]));
-            idle(); // housekeeping
           }
+          if (finish_incremental_LSF(&lsf_results)) {
+            SERIAL_ECHOLNPGM("Insufficient data");
+            return;
+          }
+          const float ez = -lsf_results.D - lsf_results.A * ppos.x - lsf_results.B * ppos.y;
+          z_values[ix][iy] = ez;
+          TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(ix, iy, z_values[ix][iy]));
+          idle(); // housekeeping
         }
       }
-
-      SERIAL_ECHOLNPGM("done");
     }
-  #endif // UBL_G29_P31
 
-  #if ENABLED(UBL_DEVEL_DEBUGGING)
-    /**
-     * Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
-     * good to have the extra information. Soon... we prune this to just a few items
-     */
-    void unified_bed_leveling::g29_what_command() {
-      report_state();
-
-      if (storage_slot == -1)
-        SERIAL_ECHOPGM("No Mesh Loaded.");
-      else
-        SERIAL_ECHOPAIR("Mesh ", storage_slot, " Loaded.");
-      SERIAL_EOL();
-      serial_delay(50);
+    SERIAL_ECHOLNPGM("done");
+  }
+#endif // UBL_G29_P31
 
-      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        SERIAL_ECHOLNPAIR_F("Fade Height M420 Z", planner.z_fade_height, 4);
-      #endif
+#if ENABLED(UBL_DEVEL_DEBUGGING)
+  /**
+   * Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
+   * good to have the extra information. Soon... we prune this to just a few items
+   */
+  void unified_bed_leveling::g29_what_command() {
+    report_state();
 
-      adjust_mesh_to_mean(g29_c_flag, g29_constant);
+    if (storage_slot == -1)
+      SERIAL_ECHOPGM("No Mesh Loaded.");
+    else
+      SERIAL_ECHOPAIR("Mesh ", storage_slot, " Loaded.");
+    SERIAL_EOL();
+    serial_delay(50);
 
-      #if HAS_BED_PROBE
-        SERIAL_ECHOLNPAIR_F("Probe Offset M851 Z", probe.offset.z, 7);
-      #endif
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      SERIAL_ECHOLNPAIR_F("Fade Height M420 Z", planner.z_fade_height, 4);
+    #endif
 
-      SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X); serial_delay(50);
-      SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); serial_delay(50);
-      SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); serial_delay(50);
-      SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); serial_delay(50);
-      SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             serial_delay(50);
-      SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);             serial_delay(50);
-      SERIAL_ECHOLNPAIR("MESH_X_DIST  ", MESH_X_DIST);
-      SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);                         serial_delay(50);
-
-      SERIAL_ECHOPGM("X-Axis Mesh Points at: ");
-      LOOP_L_N(i, GRID_MAX_POINTS_X) {
-        SERIAL_ECHO_F(LOGICAL_X_POSITION(mesh_index_to_xpos(i)), 3);
-        SERIAL_ECHOPGM("  ");
-        serial_delay(25);
-      }
-      SERIAL_EOL();
+    adjust_mesh_to_mean(g29_c_flag, g29_constant);
 
-      SERIAL_ECHOPGM("Y-Axis Mesh Points at: ");
-      LOOP_L_N(i, GRID_MAX_POINTS_Y) {
-        SERIAL_ECHO_F(LOGICAL_Y_POSITION(mesh_index_to_ypos(i)), 3);
-        SERIAL_ECHOPGM("  ");
-        serial_delay(25);
-      }
-      SERIAL_EOL();
+    #if HAS_BED_PROBE
+      SERIAL_ECHOLNPAIR_F("Probe Offset M851 Z", probe.offset.z, 7);
+    #endif
 
-      #if HAS_KILL
-        SERIAL_ECHOLNPAIR("Kill pin on :", KILL_PIN, "  state:", kill_state());
-      #endif
+    SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X); serial_delay(50);
+    SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); serial_delay(50);
+    SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); serial_delay(50);
+    SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); serial_delay(50);
+    SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             serial_delay(50);
+    SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);             serial_delay(50);
+    SERIAL_ECHOLNPAIR("MESH_X_DIST  ", MESH_X_DIST);
+    SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);                         serial_delay(50);
+
+    SERIAL_ECHOPGM("X-Axis Mesh Points at: ");
+    LOOP_L_N(i, GRID_MAX_POINTS_X) {
+      SERIAL_ECHO_F(LOGICAL_X_POSITION(mesh_index_to_xpos(i)), 3);
+      SERIAL_ECHOPGM("  ");
+      serial_delay(25);
+    }
+    SERIAL_EOL();
 
-      SERIAL_EOL();
-      serial_delay(50);
+    SERIAL_ECHOPGM("Y-Axis Mesh Points at: ");
+    LOOP_L_N(i, GRID_MAX_POINTS_Y) {
+      SERIAL_ECHO_F(LOGICAL_Y_POSITION(mesh_index_to_ypos(i)), 3);
+      SERIAL_ECHOPGM("  ");
+      serial_delay(25);
+    }
+    SERIAL_EOL();
 
-      #if ENABLED(UBL_DEVEL_DEBUGGING)
-        SERIAL_ECHOLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation, "\nubl_state_recursion_chk :", ubl_state_recursion_chk);
-        serial_delay(50);
+    #if HAS_KILL
+      SERIAL_ECHOLNPAIR("Kill pin on :", KILL_PIN, "  state:", kill_state());
+    #endif
+
+    SERIAL_EOL();
+    serial_delay(50);
 
-        SERIAL_ECHOLNPAIR("Meshes go from ", hex_address((void*)settings.meshes_start_index()), " to ", hex_address((void*)settings.meshes_end_index()));
-        serial_delay(50);
+    #if ENABLED(UBL_DEVEL_DEBUGGING)
+      SERIAL_ECHOLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation, "\nubl_state_recursion_chk :", ubl_state_recursion_chk);
+      serial_delay(50);
+
+      SERIAL_ECHOLNPAIR("Meshes go from ", hex_address((void*)settings.meshes_start_index()), " to ", hex_address((void*)settings.meshes_end_index()));
+      serial_delay(50);
 
-        SERIAL_ECHOLNPAIR("sizeof(ubl) :  ", sizeof(ubl));         SERIAL_EOL();
-        SERIAL_ECHOLNPAIR("z_value[][] size: ", sizeof(z_values)); SERIAL_EOL();
-        serial_delay(25);
+      SERIAL_ECHOLNPAIR("sizeof(ubl) :  ", sizeof(ubl));         SERIAL_EOL();
+      SERIAL_ECHOLNPAIR("z_value[][] size: ", sizeof(z_values)); SERIAL_EOL();
+      serial_delay(25);
 
-        SERIAL_ECHOLNPAIR("EEPROM free for UBL: ", hex_address((void*)(settings.meshes_end_index() - settings.meshes_start_index())));
-        serial_delay(50);
+      SERIAL_ECHOLNPAIR("EEPROM free for UBL: ", hex_address((void*)(settings.meshes_end_index() - settings.meshes_start_index())));
+      serial_delay(50);
 
-        SERIAL_ECHOLNPAIR("EEPROM can hold ", settings.calc_num_meshes(), " meshes.\n");
-        serial_delay(25);
-      #endif // UBL_DEVEL_DEBUGGING
+      SERIAL_ECHOLNPAIR("EEPROM can hold ", settings.calc_num_meshes(), " meshes.\n");
+      serial_delay(25);
+    #endif // UBL_DEVEL_DEBUGGING
 
-      if (!sanity_check()) {
-        echo_name();
-        SERIAL_ECHOLNPGM(" sanity checks passed.");
-      }
+    if (!sanity_check()) {
+      echo_name();
+      SERIAL_ECHOLNPGM(" sanity checks passed.");
     }
+  }
 
-    /**
-     * When we are fully debugged, the EEPROM dump command will get deleted also. But
-     * right now, it is good to have the extra information. Soon... we prune this.
-     */
-    void unified_bed_leveling::g29_eeprom_dump() {
-      uint8_t cccc;
-
-      SERIAL_ECHO_MSG("EEPROM Dump:");
-      persistentStore.access_start();
-      for (uint16_t i = 0; i < persistentStore.capacity(); i += 16) {
-        if (!(i & 0x3)) idle();
-        print_hex_word(i);
-        SERIAL_ECHOPGM(": ");
-        for (uint16_t j = 0; j < 16; j++) {
-          persistentStore.read_data(i + j, &cccc, sizeof(uint8_t));
-          print_hex_byte(cccc);
-          SERIAL_CHAR(' ');
-        }
-        SERIAL_EOL();
+  /**
+   * When we are fully debugged, the EEPROM dump command will get deleted also. But
+   * right now, it is good to have the extra information. Soon... we prune this.
+   */
+  void unified_bed_leveling::g29_eeprom_dump() {
+    uint8_t cccc;
+
+    SERIAL_ECHO_MSG("EEPROM Dump:");
+    persistentStore.access_start();
+    for (uint16_t i = 0; i < persistentStore.capacity(); i += 16) {
+      if (!(i & 0x3)) idle();
+      print_hex_word(i);
+      SERIAL_ECHOPGM(": ");
+      for (uint16_t j = 0; j < 16; j++) {
+        persistentStore.read_data(i + j, &cccc, sizeof(uint8_t));
+        print_hex_byte(cccc);
+        SERIAL_CHAR(' ');
       }
       SERIAL_EOL();
-      persistentStore.access_finish();
     }
+    SERIAL_EOL();
+    persistentStore.access_finish();
+  }
 
-    /**
-     * When we are fully debugged, this may go away. But there are some valid
-     * use cases for the users. So we can wait and see what to do with it.
-     */
-    void unified_bed_leveling::g29_compare_current_mesh_to_stored_mesh() {
-      const int16_t a = settings.calc_num_meshes();
+  /**
+   * When we are fully debugged, this may go away. But there are some valid
+   * use cases for the users. So we can wait and see what to do with it.
+   */
+  void unified_bed_leveling::g29_compare_current_mesh_to_stored_mesh() {
+    const int16_t a = settings.calc_num_meshes();
 
-      if (!a) {
-        SERIAL_ECHOLNPGM("?EEPROM storage not available.");
-        return;
-      }
+    if (!a) {
+      SERIAL_ECHOLNPGM("?EEPROM storage not available.");
+      return;
+    }
 
-      if (!parser.has_value() || !WITHIN(g29_storage_slot, 0, a - 1)) {
-        SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
-        return;
-      }
+    if (!parser.has_value() || !WITHIN(g29_storage_slot, 0, a - 1)) {
+      SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
+      return;
+    }
 
-      g29_storage_slot = parser.value_int();
+    g29_storage_slot = parser.value_int();
 
-      float tmp_z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
-      settings.load_mesh(g29_storage_slot, &tmp_z_values);
+    float tmp_z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
+    settings.load_mesh(g29_storage_slot, &tmp_z_values);
 
-      SERIAL_ECHOLNPAIR("Subtracting mesh in slot ", g29_storage_slot, " from current mesh.");
+    SERIAL_ECHOLNPAIR("Subtracting mesh in slot ", g29_storage_slot, " from current mesh.");
 
-      GRID_LOOP(x, y) {
-        z_values[x][y] -= tmp_z_values[x][y];
-        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
-      }
+    GRID_LOOP(x, y) {
+      z_values[x][y] -= tmp_z_values[x][y];
+      TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
     }
+  }
 
-  #endif // UBL_DEVEL_DEBUGGING
+#endif // UBL_DEVEL_DEBUGGING
 
 #endif // AUTO_BED_LEVELING_UBL

commit e7c711996bd3080f5e343eff5556736cbf2e2416
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 8 07:37:24 2021 +0100

    Serial refactor. Default 8-bit ECHO to int, not char (#20985)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 41d2a36359..36acc96d6e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -735,21 +735,21 @@
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       uint8_t count = GRID_MAX_POINTS;
 
       mesh_index_pair best;
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::MESH_START));
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
         const int point_num = (GRID_MAX_POINTS) - count + 1;
-        SERIAL_ECHOLNPAIR("Probing mesh point ", point_num, "/", int(GRID_MAX_POINTS), ".");
+        SERIAL_ECHOLNPAIR("Probing mesh point ", point_num, "/", GRID_MAX_POINTS, ".");
         TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), point_num, int(GRID_MAX_POINTS)));
 
         #if HAS_LCD_MENU
           if (ui.button_pressed()) {
             ui.quick_feedback(false); // Preserve button state for click-and-hold
             SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
             ui.wait_for_release();
             ui.quick_feedback();
             ui.release();
             probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
@@ -1687,35 +1687,35 @@
 
       SERIAL_ECHOPGM("Y-Axis Mesh Points at: ");
       LOOP_L_N(i, GRID_MAX_POINTS_Y) {
         SERIAL_ECHO_F(LOGICAL_Y_POSITION(mesh_index_to_ypos(i)), 3);
         SERIAL_ECHOPGM("  ");
         serial_delay(25);
       }
       SERIAL_EOL();
 
       #if HAS_KILL
-        SERIAL_ECHOLNPAIR("Kill pin on :", int(KILL_PIN), "  state:", int(kill_state()));
+        SERIAL_ECHOLNPAIR("Kill pin on :", KILL_PIN, "  state:", kill_state());
       #endif
 
       SERIAL_EOL();
       serial_delay(50);
 
       #if ENABLED(UBL_DEVEL_DEBUGGING)
         SERIAL_ECHOLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation, "\nubl_state_recursion_chk :", ubl_state_recursion_chk);
         serial_delay(50);
 
         SERIAL_ECHOLNPAIR("Meshes go from ", hex_address((void*)settings.meshes_start_index()), " to ", hex_address((void*)settings.meshes_end_index()));
         serial_delay(50);
 
-        SERIAL_ECHOLNPAIR("sizeof(ubl) :  ", (int)sizeof(ubl));         SERIAL_EOL();
-        SERIAL_ECHOLNPAIR("z_value[][] size: ", (int)sizeof(z_values)); SERIAL_EOL();
+        SERIAL_ECHOLNPAIR("sizeof(ubl) :  ", sizeof(ubl));         SERIAL_EOL();
+        SERIAL_ECHOLNPAIR("z_value[][] size: ", sizeof(z_values)); SERIAL_EOL();
         serial_delay(25);
 
         SERIAL_ECHOLNPAIR("EEPROM free for UBL: ", hex_address((void*)(settings.meshes_end_index() - settings.meshes_start_index())));
         serial_delay(50);
 
         SERIAL_ECHOLNPAIR("EEPROM can hold ", settings.calc_num_meshes(), " meshes.\n");
         serial_delay(25);
       #endif // UBL_DEVEL_DEBUGGING
 
       if (!sanity_check()) {

commit c91a91008cad53ca64806e0b8f6abb65341faa0c
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Sun Jan 31 23:47:16 2021 +0100

    Remove extra G29 V newlines (#20955)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 3f7b2d7d96..41d2a36359 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -735,21 +735,21 @@
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       uint8_t count = GRID_MAX_POINTS;
 
       mesh_index_pair best;
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::MESH_START));
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
         const int point_num = (GRID_MAX_POINTS) - count + 1;
-        SERIAL_ECHOLNPAIR("\nProbing mesh point ", point_num, "/", int(GRID_MAX_POINTS), ".\n");
+        SERIAL_ECHOLNPAIR("Probing mesh point ", point_num, "/", int(GRID_MAX_POINTS), ".");
         TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), point_num, int(GRID_MAX_POINTS)));
 
         #if HAS_LCD_MENU
           if (ui.button_pressed()) {
             ui.quick_feedback(false); // Preserve button state for click-and-hold
             SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
             ui.wait_for_release();
             ui.quick_feedback();
             ui.release();
             probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW

commit bb597dcf66ac0baa3f3528bb34c3b4aad78ad520
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 17 12:08:40 2021 -0600

    Internal G29N for G28+G29 (#20800)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 598bfeee50..3f7b2d7d96 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -314,21 +314,22 @@
     bool probe_deployed = false;
     if (g29_parameter_parsing()) return; // Abort on parameter error
 
     const int8_t p_val = parser.intval('P', -1);
     const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J');
     TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index = active_extruder);
 
     // Check for commands that require the printer to be homed
     if (may_move) {
       planner.synchronize();
-      if (axes_should_home()) gcode.home_all_axes();
+      // Send 'N' to force homing before G29 (internal only)
+      if (axes_should_home() || parser.seen('N')) gcode.home_all_axes();
       TERN_(HAS_MULTI_HOTEND, if (active_extruder) tool_change(0));
     }
 
     // Invalidate Mesh Points. This command is a little bit asymmetrical because
     // it directly specifies the repetition count and does not use the 'R' parameter.
     if (parser.seen('I')) {
       uint8_t cnt = 0;
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : 1;
       if (g29_repetition_cnt >= GRID_MAX_POINTS) {
         set_all_mesh_points_to_value(NAN);

commit 844a8c7074d555bda31a53ae834cee5fac020ca8
Author: ubik2 <ubik2@users.noreply.github.com>
Date:   Wed Dec 23 16:19:48 2020 -0800

    Add OPTIMIZED_MESH_STORAGE option (for UBL) (#20371)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 549fd7721f..598bfeee50 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -536,21 +536,21 @@
                 }
                 else {
                   z_values[cpos.x][cpos.y] = g29_constant;
                   TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(cpos, g29_constant));
                 }
               }
             }
           }
           else {
             const float cvf = parser.value_float();
-            switch ((int)truncf(cvf * 10.0f) - 30) {   // 3.1 -> 1
+            switch ((int)TRUNC(cvf * 10.0f) - 30) {   // 3.1 -> 1
               #if ENABLED(UBL_G29_P31)
                 case 1: {
 
                   // P3.1  use least squares fit to fill missing mesh values
                   // P3.10 zero weighting for distance, all grid points equal, best fit tilted plane
                   // P3.11 10X weighting for nearest grid points versus farthest grid points
                   // P3.12 100X distance weighting
                   // P3.13 1000X distance weighting, approaches simple average of nearest points
 
                   const float weight_power  = (cvf - 3.10f) * 100.0f,  // 3.12345 -> 2.345

commit 0b3b4da7d0ec2015ca7b8bd346e4f6af3c6f5886
Author: Serhiy-K <52166448+Serhiy-K@users.noreply.github.com>
Date:   Tue Dec 22 14:56:00 2020 +0200

    STM32F1xx support for TFTGLCD (#20515)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 11bea18c81..549fd7721f 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -965,20 +965,26 @@
 
       save_ubl_active_state_and_disable();
 
       LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
       ui.capture();                                               // Take over control of the LCD encoder
 
       do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES);  // Move to the given XY with probe clearance
 
       MeshFlags done_flags{0};
       const xy_int8_t &lpos = location.pos;
+
+      #if IS_TFTGLCD_PANEL
+        lcd_mesh_edit_setup(0);                             // Change current screen before calling ui.ubl_plot
+        safe_delay(50);
+      #endif
+
       do {
         location = find_closest_mesh_point_of_type(SET_IN_BITMAP, pos, false, &done_flags);
 
         if (lpos.x < 0) break;                              // Stop when there are no more reachable points
 
         done_flags.mark(lpos);                              // Mark this location as 'adjusted' so a new
                                                             // location is used on the next loop
         const xyz_pos_t raw = {
           mesh_index_to_xpos(lpos.x),
           mesh_index_to_ypos(lpos.y),

commit bf4c08bce1c6bbb5c2e7a44b9bfc253b242022ce
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 5 18:21:56 2020 -0600

    Use 'nearby' for 'near'

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 9ab7861a01..11bea18c81 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -720,21 +720,21 @@
         z_values[x][y] += g29_constant;
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
       }
   }
 
   #if HAS_BED_PROBE
     /**
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
-    void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
+    void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &nearby, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
       probe.deploy(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
 
       TERN_(HAS_LCD_MENU, ui.capture());
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       uint8_t count = GRID_MAX_POINTS;
 
       mesh_index_pair best;
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::MESH_START));
       do {
@@ -751,21 +751,21 @@
             ui.wait_for_release();
             ui.quick_feedback();
             ui.release();
             probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
             return restore_ubl_active_state_and_leave();
           }
         #endif
 
         best = do_furthest
           ? find_furthest_invalid_mesh_point()
-          : find_closest_mesh_point_of_type(INVALID, pos, true);
+          : find_closest_mesh_point_of_type(INVALID, nearby, true);
 
         if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
           TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_START));
           const float measured_z = probe.probe_at_point(
                         best.meshpos(),
                         stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level
                       );
           z_values[best.pos.x][best.pos.y] = measured_z;
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_FINISH);
@@ -781,22 +781,22 @@
       // Release UI during stow to allow for PAUSE_BEFORE_DEPLOY_STOW
       TERN_(HAS_LCD_MENU, ui.release());
       probe.stow();
       TERN_(HAS_LCD_MENU, ui.capture());
 
       probe.move_z_after_probing();
 
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
-        constrain(pos.x - probe.offset_xy.x, MESH_MIN_X, MESH_MAX_X),
-        constrain(pos.y - probe.offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
+        constrain(nearby.x - probe.offset_xy.x, MESH_MIN_X, MESH_MAX_X),
+        constrain(nearby.y - probe.offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 
   #endif // HAS_BED_PROBE
 
   #if HAS_LCD_MENU
 
     typedef void (*clickFunc_t)();
 
     bool click_and_hold(const clickFunc_t func=nullptr) {
@@ -1199,45 +1199,45 @@
 
     GRID_LOOP(i, j) {
       if (!isnan(z_values[i][j])) continue;  // Skip valid mesh points
 
       // Skip unreachable points
       if (!probe.can_reach(mesh_index_to_xpos(i), mesh_index_to_ypos(j)))
         continue;
 
       found_a_NAN = true;
 
-      xy_int8_t near_pos { -1, -1 };
+      xy_int8_t nearby { -1, -1 };
       float d1, d2 = 99999.9f;
       GRID_LOOP(k, l) {
         if (isnan(z_values[k][l])) continue;
 
         found_a_real = true;
 
         // Add in a random weighting factor that scrambles the probing of the
         // last half of the mesh (when every unprobed mesh point is one index
         // from a probed location).
 
         d1 = HYPOT(i - k, j - l) + (1.0f / ((millis() % 47) + 13));
 
         if (d1 < d2) {    // Invalid mesh point (i,j) is closer to the defined point (k,l)
           d2 = d1;
-          near_pos.set(i, j);
+          nearby.set(i, j);
         }
       }
 
       //
       // At this point d2 should have the near defined mesh point to invalid mesh point (i,j)
       //
 
-      if (found_a_real && near_pos.x >= 0 && d2 > farthest.distance) {
-        farthest.pos = near_pos; // Found an invalid location farther from the defined mesh point
+      if (found_a_real && nearby.x >= 0 && d2 > farthest.distance) {
+        farthest.pos = nearby; // Found an invalid location farther from the defined mesh point
         farthest.distance = d2;
       }
     } // GRID_LOOP
 
     if (!found_a_real && found_a_NAN) {        // if the mesh is totally unpopulated, start the probing
       farthest.pos.set((GRID_MAX_POINTS_X) / 2, (GRID_MAX_POINTS_Y) / 2);
       farthest.distance = 1;
     }
     return farthest;
   }

commit 0a03ef4b6fb4fe52769f4d84255e7fee10c04b95
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sat Dec 5 05:29:55 2020 +0100

    Don’t use near keyword as variable name (#20374)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 94bec99194..9ab7861a01 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -720,21 +720,21 @@
         z_values[x][y] += g29_constant;
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
       }
   }
 
   #if HAS_BED_PROBE
     /**
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
-    void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &near, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
+    void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
       probe.deploy(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
 
       TERN_(HAS_LCD_MENU, ui.capture());
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       uint8_t count = GRID_MAX_POINTS;
 
       mesh_index_pair best;
       TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::MESH_START));
       do {
@@ -751,21 +751,21 @@
             ui.wait_for_release();
             ui.quick_feedback();
             ui.release();
             probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
             return restore_ubl_active_state_and_leave();
           }
         #endif
 
         best = do_furthest
           ? find_furthest_invalid_mesh_point()
-          : find_closest_mesh_point_of_type(INVALID, near, true);
+          : find_closest_mesh_point_of_type(INVALID, pos, true);
 
         if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
           TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_START));
           const float measured_z = probe.probe_at_point(
                         best.meshpos(),
                         stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level
                       );
           z_values[best.pos.x][best.pos.y] = measured_z;
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_FINISH);
@@ -781,22 +781,22 @@
       // Release UI during stow to allow for PAUSE_BEFORE_DEPLOY_STOW
       TERN_(HAS_LCD_MENU, ui.release());
       probe.stow();
       TERN_(HAS_LCD_MENU, ui.capture());
 
       probe.move_z_after_probing();
 
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
-        constrain(near.x - probe.offset_xy.x, MESH_MIN_X, MESH_MAX_X),
-        constrain(near.y - probe.offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
+        constrain(pos.x - probe.offset_xy.x, MESH_MIN_X, MESH_MAX_X),
+        constrain(pos.y - probe.offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 
   #endif // HAS_BED_PROBE
 
   #if HAS_LCD_MENU
 
     typedef void (*clickFunc_t)();
 
     bool click_and_hold(const clickFunc_t func=nullptr) {
@@ -1199,45 +1199,45 @@
 
     GRID_LOOP(i, j) {
       if (!isnan(z_values[i][j])) continue;  // Skip valid mesh points
 
       // Skip unreachable points
       if (!probe.can_reach(mesh_index_to_xpos(i), mesh_index_to_ypos(j)))
         continue;
 
       found_a_NAN = true;
 
-      xy_int8_t near { -1, -1 };
+      xy_int8_t near_pos { -1, -1 };
       float d1, d2 = 99999.9f;
       GRID_LOOP(k, l) {
         if (isnan(z_values[k][l])) continue;
 
         found_a_real = true;
 
         // Add in a random weighting factor that scrambles the probing of the
         // last half of the mesh (when every unprobed mesh point is one index
         // from a probed location).
 
         d1 = HYPOT(i - k, j - l) + (1.0f / ((millis() % 47) + 13));
 
         if (d1 < d2) {    // Invalid mesh point (i,j) is closer to the defined point (k,l)
           d2 = d1;
-          near.set(i, j);
+          near_pos.set(i, j);
         }
       }
 
       //
       // At this point d2 should have the near defined mesh point to invalid mesh point (i,j)
       //
 
-      if (found_a_real && near.x >= 0 && d2 > farthest.distance) {
-        farthest.pos = near;      // Found an invalid location farther from the defined mesh point
+      if (found_a_real && near_pos.x >= 0 && d2 > farthest.distance) {
+        farthest.pos = near_pos; // Found an invalid location farther from the defined mesh point
         farthest.distance = d2;
       }
     } // GRID_LOOP
 
     if (!found_a_real && found_a_NAN) {        // if the mesh is totally unpopulated, start the probing
       farthest.pos.set((GRID_MAX_POINTS_X) / 2, (GRID_MAX_POINTS_Y) / 2);
       farthest.distance = 1;
     }
     return farthest;
   }

commit 9dedd121bf789b5289380978979e2aed5ce58b38
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Nov 22 16:20:33 2020 -0800

    Fix UBL manual mesh adjust behavior (#20248)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index e8524da368..94bec99194 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -942,43 +942,41 @@
       ui.return_to_status();
       do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
       set_message_with_feedback(GET_TEXT(MSG_EDITING_STOPPED));
     }
 
     void unified_bed_leveling::fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) {
       if (!parser.seen('R'))      // fine_tune_mesh() is special. If no repetition count flag is specified
         g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 
       #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
-        const float h_offset = parser.seenval('H') ? parser.value_linear_units() : 0;
+        const float h_offset = parser.seenval('H') ? parser.value_linear_units() : MANUAL_PROBE_START_Z;
         if (!WITHIN(h_offset, 0, 10)) {
           SERIAL_ECHOLNPGM("Offset out of bounds. (0 to 10mm)\n");
           return;
         }
       #endif
 
       mesh_index_pair location;
 
       if (!position_is_reachable(pos)) {
         SERIAL_ECHOLNPGM("(X,Y) outside printable radius.");
         return;
       }
 
       save_ubl_active_state_and_disable();
 
       LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
       ui.capture();                                               // Take over control of the LCD encoder
 
       do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES);  // Move to the given XY with probe clearance
 
-      TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset));  // Move Z to the given 'H' offset
-
       MeshFlags done_flags{0};
       const xy_int8_t &lpos = location.pos;
       do {
         location = find_closest_mesh_point_of_type(SET_IN_BITMAP, pos, false, &done_flags);
 
         if (lpos.x < 0) break;                              // Stop when there are no more reachable points
 
         done_flags.mark(lpos);                              // Mark this location as 'adjusted' so a new
                                                             // location is used on the next loop
         const xyz_pos_t raw = {

commit 39305aa47c74822badee716996369b12976ba668
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Nov 17 21:59:48 2020 -0800

    Use MANUAL_PROBE_START_Z for UBL manual probing (#20160)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index ea2e62dd51..e8524da368 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -477,21 +477,21 @@
                 #if IS_KINEMATIC
                   X_HOME_POS, Y_HOME_POS
                 #else
                   probe.offset_xy.x > 0 ? X_BED_SIZE : 0,
                   probe.offset_xy.y < 0 ? Y_BED_SIZE : 0
                 #endif
               );
             }
 
             if (parser.seen('B')) {
-              g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness(float(Z_CLEARANCE_BETWEEN_PROBES));
+              g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness();
               if (ABS(g29_card_thickness) > 1.5f) {
                 SERIAL_ECHOLNPGM("?Error in Business Card measurement.");
                 return;
               }
               probe_deployed = true;
             }
 
             if (!position_is_reachable(g29_pos)) {
               SERIAL_ECHOLNPGM("XY outside printable radius.");
               return;
@@ -830,25 +830,25 @@
     }
 
     float unified_bed_leveling::measure_point_with_encoder() {
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       move_z_with_encoder(0.01f);
       return current_position.z;
     }
 
     static void echo_and_take_a_measurement() { SERIAL_ECHOLNPGM(" and take a measurement."); }
 
-    float unified_bed_leveling::measure_business_card_thickness(float in_height) {
+    float unified_bed_leveling::measure_business_card_thickness() {
       ui.capture();
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
-      do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
+      do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), MANUAL_PROBE_START_Z);
         //, _MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f);
       planner.synchronize();
 
       SERIAL_ECHOPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       ui.return_to_status();
       echo_and_take_a_measurement();
 
       const float z1 = measure_point_with_encoder();
       do_blocking_move_to_z(current_position.z + SIZE_OF_LITTLE_RAISE);

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index e41af9f3cd..ea2e62dd51 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -23,21 +23,21 @@
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
   #include "../bedlevel.h"
 
   #include "../../../MarlinCore.h"
   #include "../../../HAL/shared/eeprom_api.h"
   #include "../../../libs/hex_print.h"
   #include "../../../module/settings.h"
-  #include "../../../lcd/ultralcd.h"
+  #include "../../../lcd/marlinui.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
   #include "../../../module/motion.h"
   #include "../../../module/probe.h"
   #include "../../../gcode/gcode.h"
   #include "../../../libs/least_squares_fit.h"
 
   #if HAS_MULTI_HOTEND
     #include "../../../module/tool_change.h"
   #endif

commit 193c0a52d9f1fbd31e42a29734f551aa26ed269a
Author: Earle F. Philhower, III <earlephilhower@yahoo.com>
Date:   Mon Oct 12 14:48:04 2020 -0700

    Add loose soft endstop state, apply to UBL fine-tune (#19681)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index dc91b7d6b1..e41af9f3cd 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1002,27 +1002,31 @@
         #endif
 
         ui.refresh();
 
         float new_z = z_values[lpos.x][lpos.y];
         if (isnan(new_z)) new_z = 0;                        // Invalid points begin at 0
         new_z = FLOOR(new_z * 1000) * 0.001f;               // Chop off digits after the 1000ths place
 
         lcd_mesh_edit_setup(new_z);
 
+        SET_SOFT_ENDSTOP_LOOSE(true);
+
         do {
           idle();
           new_z = lcd_mesh_edit();
           TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset + new_z)); // Move the nozzle as the point is edited
           SERIAL_FLUSH();                                   // Prevent host M105 buffer overrun.
         } while (!ui.button_pressed());
 
+        SET_SOFT_ENDSTOP_LOOSE(false);
+
         if (!lcd_map_control) ui.return_to_status();        // Just editing a single point? Return to status
 
         if (click_and_hold(abort_fine_tune)) break;         // Button held down? Abort editing
 
         z_values[lpos.x][lpos.y] = new_z;                   // Save the updated Z value
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, new_z));
 
         serial_delay(20);                                   // No switch noise
         ui.refresh();
 

commit 27bdf4b24e8da06ea7923b6382f38b5fb6292914
Author: Serhiy-K <52166448+Serhiy-K@users.noreply.github.com>
Date:   Mon Sep 28 09:52:38 2020 +0300

    MarlinUI for SPI/I2C TFT-GLCD character-based display bridge (#19375)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 9fc9ec099e..dc91b7d6b1 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -990,20 +990,24 @@
         if (!position_is_reachable(raw)) break;             // SHOULD NOT OCCUR (find_closest_mesh_point_of_type only returns reachable)
 
         do_blocking_move_to(raw);                           // Move the nozzle to the edit point with probe clearance
 
         TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset)); // Move Z to the given 'H' offset before editing
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
 
         if (do_ubl_mesh_map) display_map(g29_map_type);     // Display the current point
 
+        #if IS_TFTGLCD_PANEL
+          ui.ubl_plot(lpos.x, lpos.y);   // update plot screen
+        #endif
+
         ui.refresh();
 
         float new_z = z_values[lpos.x][lpos.y];
         if (isnan(new_z)) new_z = 0;                        // Invalid points begin at 0
         new_z = FLOOR(new_z * 1000) * 0.001f;               // Chop off digits after the 1000ths place
 
         lcd_mesh_edit_setup(new_z);
 
         do {
           idle();

commit 872516f9f903157fbd927bf6083996da70ab4e63
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Sat Sep 12 22:32:00 2020 -0600

    Touch UI "Leveling" menu, misc. fixes (#19349)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index d13a8c3dc4..9fc9ec099e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -729,20 +729,21 @@
      */
     void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &near, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
       probe.deploy(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
 
       TERN_(HAS_LCD_MENU, ui.capture());
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       uint8_t count = GRID_MAX_POINTS;
 
       mesh_index_pair best;
+      TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::MESH_START));
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
         const int point_num = (GRID_MAX_POINTS) - count + 1;
         SERIAL_ECHOLNPAIR("\nProbing mesh point ", point_num, "/", int(GRID_MAX_POINTS), ".\n");
         TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), point_num, int(GRID_MAX_POINTS)));
 
         #if HAS_LCD_MENU
           if (ui.button_pressed()) {
             ui.quick_feedback(false); // Preserve button state for click-and-hold
@@ -768,20 +769,22 @@
           z_values[best.pos.x][best.pos.y] = measured_z;
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_FINISH);
             ExtUI::onMeshUpdate(best.pos, measured_z);
           #endif
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
 
       } while (best.pos.x >= 0 && --count);
 
+      TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::MESH_FINISH));
+
       // Release UI during stow to allow for PAUSE_BEFORE_DEPLOY_STOW
       TERN_(HAS_LCD_MENU, ui.release());
       probe.stow();
       TERN_(HAS_LCD_MENU, ui.capture());
 
       probe.move_z_after_probing();
 
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(

commit a12ac5e1754f0f66babde400a0406b6cdbff983e
Author: swissnorp <67485708+swissnorp@users.noreply.github.com>
Date:   Thu Aug 27 23:05:53 2020 +0200

    Mark axes not-homed with HOME_AFTER_DEACTIVATE (#18907)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 69a66420f8..d13a8c3dc4 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -314,21 +314,21 @@
     bool probe_deployed = false;
     if (g29_parameter_parsing()) return; // Abort on parameter error
 
     const int8_t p_val = parser.intval('P', -1);
     const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J');
     TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index = active_extruder);
 
     // Check for commands that require the printer to be homed
     if (may_move) {
       planner.synchronize();
-      if (axes_need_homing()) gcode.home_all_axes();
+      if (axes_should_home()) gcode.home_all_axes();
       TERN_(HAS_MULTI_HOTEND, if (active_extruder) tool_change(0));
     }
 
     // Invalidate Mesh Points. This command is a little bit asymmetrical because
     // it directly specifies the repetition count and does not use the 'R' parameter.
     if (parser.seen('I')) {
       uint8_t cnt = 0;
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : 1;
       if (g29_repetition_cnt >= GRID_MAX_POINTS) {
         set_all_mesh_points_to_value(NAN);

commit 18adfe87bcd516436db001b53a0e09e58246c9e2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Aug 7 20:51:40 2020 -0500

    configuration_store => settings

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 760d2cdd1e..69a66420f8 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -22,21 +22,21 @@
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
   #include "../bedlevel.h"
 
   #include "../../../MarlinCore.h"
   #include "../../../HAL/shared/eeprom_api.h"
   #include "../../../libs/hex_print.h"
-  #include "../../../module/configuration_store.h"
+  #include "../../../module/settings.h"
   #include "../../../lcd/ultralcd.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
   #include "../../../module/motion.h"
   #include "../../../module/probe.h"
   #include "../../../gcode/gcode.h"
   #include "../../../libs/least_squares_fit.h"
 
   #if HAS_MULTI_HOTEND
     #include "../../../module/tool_change.h"

commit d69c2a90b7721c2b779d31572faff5fd848d8ea0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Aug 5 23:21:41 2020 -0500

    Simple rename of hex_print

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index f8219ac7e7..760d2cdd1e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -21,21 +21,21 @@
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
   #include "../bedlevel.h"
 
   #include "../../../MarlinCore.h"
   #include "../../../HAL/shared/eeprom_api.h"
-  #include "../../../libs/hex_print_routines.h"
+  #include "../../../libs/hex_print.h"
   #include "../../../module/configuration_store.h"
   #include "../../../lcd/ultralcd.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
   #include "../../../module/motion.h"
   #include "../../../module/probe.h"
   #include "../../../gcode/gcode.h"
   #include "../../../libs/least_squares_fit.h"
 
   #if HAS_MULTI_HOTEND

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 7981600d0a..f8219ac7e7 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
   #include "../bedlevel.h"
 
   #include "../../../MarlinCore.h"

commit 73fc0778b864ab1f5e5c3f065f5d8db75a0bbb7c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 8 21:44:21 2020 -0500

    Consolidate probe clearance, add section debug (#18576)
    
    * Better section / function log
    * Add do_z_clearance motion function

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index da3477078a..7981600d0a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -455,21 +455,21 @@
           } break;
 
         #endif // HAS_BED_PROBE
 
         case 2: {
           #if HAS_LCD_MENU
             //
             // Manually Probe Mesh in areas that can't be reached by the probe
             //
             SERIAL_ECHOLNPGM("Manually probing unreachable points.");
-            do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
+            do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
 
             if (parser.seen('C') && !xy_seen) {
 
               /**
                * Use a good default location for the path.
                * The flipped > and < operators in these comparisons is intentional.
                * It should cause the probed points to follow a nice path on Cartesian printers.
                * It may make sense to have Delta printers default to the center of the bed.
                * Until that is decided, this can be forced with the X and Y parameters.
                */
@@ -773,23 +773,21 @@
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
 
       } while (best.pos.x >= 0 && --count);
 
       // Release UI during stow to allow for PAUSE_BEFORE_DEPLOY_STOW
       TERN_(HAS_LCD_MENU, ui.release());
       probe.stow();
       TERN_(HAS_LCD_MENU, ui.capture());
 
-      #ifdef Z_AFTER_PROBING
-        probe.move_z_after_probing();
-      #endif
+      probe.move_z_after_probing();
 
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
         constrain(near.x - probe.offset_xy.x, MESH_MIN_X, MESH_MAX_X),
         constrain(near.y - probe.offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 
   #endif // HAS_BED_PROBE
@@ -851,21 +849,20 @@
 
       const float z1 = measure_point_with_encoder();
       do_blocking_move_to_z(current_position.z + SIZE_OF_LITTLE_RAISE);
       planner.synchronize();
 
       SERIAL_ECHOPGM("Remove shim");
       LCD_MESSAGEPGM(MSG_UBL_BC_REMOVE);
       echo_and_take_a_measurement();
 
       const float z2 = measure_point_with_encoder();
-
       do_blocking_move_to_z(current_position.z + Z_CLEARANCE_BETWEEN_PROBES);
 
       const float thickness = ABS(z1 - z2);
 
       if (g29_verbose_level > 1) {
         SERIAL_ECHOPAIR_F("Business Card is ", thickness, 4);
         SERIAL_ECHOLNPGM("mm thick.");
       }
 
       restore_ubl_active_state_and_leave();
@@ -892,37 +889,37 @@
           mesh_index_to_xpos(lpos.x),
           mesh_index_to_ypos(lpos.y),
           Z_CLEARANCE_BETWEEN_PROBES
         };
 
         if (!position_is_reachable(ppos)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
 
         LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
 
         do_blocking_move_to(ppos);
-        do_blocking_move_to_z(z_clearance);
+        do_z_clearance(z_clearance);
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         ui.capture();
 
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
         serialprintPGM(parser.seen('B') ? GET_TEXT(MSG_UBL_BC_INSERT) : GET_TEXT(MSG_UBL_BC_INSERT2));
 
         const float z_step = 0.01f;                         // existing behavior: 0.01mm per click, occasionally step
         //const float z_step = planner.steps_to_mm[Z_AXIS]; // approx one step each click
 
         move_z_with_encoder(z_step);
 
         if (click_and_hold()) {
           SERIAL_ECHOLNPGM("\nMesh only partially populated.");
-          do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
+          do_z_clearance(Z_CLEARANCE_DEPLOY_PROBE);
           return restore_ubl_active_state_and_leave();
         }
 
         z_values[lpos.x][lpos.y] = current_position.z - thick;
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, z_values[lpos.x][lpos.y]));
 
         if (g29_verbose_level > 2)
           SERIAL_ECHOLNPAIR_F("Mesh Point Measured at: ", z_values[lpos.x][lpos.y], 6);
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.valid());
@@ -933,21 +930,21 @@
       do_blocking_move_to_xy_z(pos, Z_CLEARANCE_DEPLOY_PROBE);
     }
 
     inline void set_message_with_feedback(PGM_P const msg_P) {
       ui.set_status_P(msg_P);
       ui.quick_feedback();
     }
 
     void abort_fine_tune() {
       ui.return_to_status();
-      do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
+      do_z_clearance(Z_CLEARANCE_BETWEEN_PROBES);
       set_message_with_feedback(GET_TEXT(MSG_EDITING_STOPPED));
     }
 
     void unified_bed_leveling::fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) {
       if (!parser.seen('R'))      // fine_tune_mesh() is special. If no repetition count flag is specified
         g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 
       #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
         const float h_offset = parser.seenval('H') ? parser.value_linear_units() : 0;
         if (!WITHIN(h_offset, 0, 10)) {
@@ -1408,23 +1405,21 @@
             measured_z -= get_z_correction(points[2]);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, points[2], measured_z);
           }
         }
 
         probe.stow();
-        #ifdef Z_AFTER_PROBING
-          probe.move_z_after_probing();
-        #endif
+        probe.move_z_after_probing();
 
         if (abort_flag) {
           SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");
           return;
         }
       }
       else { // !do_3_pt_leveling
 
         bool zig_zag = false;
 
@@ -1471,23 +1466,21 @@
               incremental_LSF(&lsf_results, rpos, measured_z);
             }
 
             point_num++;
           }
 
           zig_zag ^= true;
         }
       }
       probe.stow();
-      #ifdef Z_AFTER_PROBING
-        probe.move_z_after_probing();
-      #endif
+      probe.move_z_after_probing();
 
       if (abort_flag || finish_incremental_LSF(&lsf_results)) {
         SERIAL_ECHOPGM("Could not complete LSF!");
         return;
       }
 
       vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1).get_normal();
 
       if (g29_verbose_level > 2) {
         SERIAL_ECHOPAIR_F("bed plane normal = [", normal.x, 7);

commit f6a2b6409192c4e349321f42a5c0ebfd4e278b82
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 3 09:53:22 2020 -0500

    Clean up LCD Manual Move / UBL Mesh Edit (#18373)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index a3d45169bc..da3477078a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -47,21 +47,32 @@
 
   #if ENABLED(EXTENSIBLE_UI)
     #include "../../../lcd/extui/ui_api.h"
   #endif
 
   #include <math.h>
 
   #define UBL_G29_P31
 
   #if HAS_LCD_MENU
-    void _lcd_ubl_output_map_lcd();
+
+    bool unified_bed_leveling::lcd_map_control = false;
+
+    void unified_bed_leveling::steppers_were_disabled() {
+      if (lcd_map_control) {
+        lcd_map_control = false;
+        ui.defer_status_screen(false);
+      }
+    }
+
+    void ubl_map_screen();
+
   #endif
 
   #define SIZE_OF_LITTLE_RAISE 1
   #define BIG_RAISE_NOT_NEEDED 0
 
   int    unified_bed_leveling::g29_verbose_level,
          unified_bed_leveling::g29_phase_value,
          unified_bed_leveling::g29_repetition_cnt,
          unified_bed_leveling::g29_storage_slot = 0,
          unified_bed_leveling::g29_map_type;
@@ -782,25 +793,25 @@
     }
 
   #endif // HAS_BED_PROBE
 
   #if HAS_LCD_MENU
 
     typedef void (*clickFunc_t)();
 
     bool click_and_hold(const clickFunc_t func=nullptr) {
       if (ui.button_pressed()) {
-        ui.quick_feedback(false);                // Preserve button state for click-and-hold
+        ui.quick_feedback(false);         // Preserve button state for click-and-hold
         const millis_t nxt = millis() + 1500UL;
-        while (ui.button_pressed()) {                // Loop while the encoder is pressed. Uses hardware flag!
-          idle();                                 // idle, of course
-          if (ELAPSED(millis(), nxt)) {           // After 1.5 seconds
+        while (ui.button_pressed()) {     // Loop while the encoder is pressed. Uses hardware flag!
+          idle();                         // idle, of course
+          if (ELAPSED(millis(), nxt)) {   // After 1.5 seconds
             ui.quick_feedback();
             if (func) (*func)();
             ui.wait_for_release();
             return true;
           }
         }
       }
       serial_delay(15);
       return false;
     }
@@ -988,23 +999,23 @@
 
         ui.refresh();
 
         float new_z = z_values[lpos.x][lpos.y];
         if (isnan(new_z)) new_z = 0;                        // Invalid points begin at 0
         new_z = FLOOR(new_z * 1000) * 0.001f;               // Chop off digits after the 1000ths place
 
         lcd_mesh_edit_setup(new_z);
 
         do {
+          idle();
           new_z = lcd_mesh_edit();
           TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset + new_z)); // Move the nozzle as the point is edited
-          idle();
           SERIAL_FLUSH();                                   // Prevent host M105 buffer overrun.
         } while (!ui.button_pressed());
 
         if (!lcd_map_control) ui.return_to_status();        // Just editing a single point? Return to status
 
         if (click_and_hold(abort_fine_tune)) break;         // Button held down? Abort editing
 
         z_values[lpos.x][lpos.y] = new_z;                   // Save the updated Z value
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, new_z));
 
@@ -1015,21 +1026,21 @@
 
       if (do_ubl_mesh_map) display_map(g29_map_type);
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES);
 
       LCD_MESSAGEPGM(MSG_UBL_DONE_EDITING_MESH);
       SERIAL_ECHOLNPGM("Done Editing Mesh");
 
       if (lcd_map_control)
-        ui.goto_screen(_lcd_ubl_output_map_lcd);
+        ui.goto_screen(ubl_map_screen);
       else
         ui.return_to_status();
     }
 
   #endif // HAS_LCD_MENU
 
   bool unified_bed_leveling::g29_parameter_parsing() {
     bool err_flag = false;
 
     TERN_(HAS_LCD_MENU, set_message_with_feedback(GET_TEXT(MSG_UBL_DOING_G29)));

commit f445bc26e52de36239e595ee3fbd2d25abc97258
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 25 16:39:22 2020 -0500

    Minor LCD cleanup, improvement

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 3c604168a6..a3d45169bc 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -819,21 +819,21 @@
 
     float unified_bed_leveling::measure_point_with_encoder() {
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       move_z_with_encoder(0.01f);
       return current_position.z;
     }
 
     static void echo_and_take_a_measurement() { SERIAL_ECHOLNPGM(" and take a measurement."); }
 
     float unified_bed_leveling::measure_business_card_thickness(float in_height) {
-      TERN_(HAS_LCD_MENU, ui.capture());
+      ui.capture();
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
       do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
         //, _MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f);
       planner.synchronize();
 
       SERIAL_ECHOPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       ui.return_to_status();
       echo_and_take_a_measurement();
@@ -850,29 +850,27 @@
 
       do_blocking_move_to_z(current_position.z + Z_CLEARANCE_BETWEEN_PROBES);
 
       const float thickness = ABS(z1 - z2);
 
       if (g29_verbose_level > 1) {
         SERIAL_ECHOPAIR_F("Business Card is ", thickness, 4);
         SERIAL_ECHOLNPGM("mm thick.");
       }
 
-      ui.release();
-
       restore_ubl_active_state_and_leave();
 
       return thickness;
     }
 
     void unified_bed_leveling::manually_probe_remaining_mesh(const xy_pos_t &pos, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
-      TERN_(HAS_LCD_MENU, ui.capture());
+      ui.capture();
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       do_blocking_move_to_xy_z(current_position, z_clearance);
 
       ui.return_to_status();
 
       mesh_index_pair location;
       const xy_int8_t &lpos = location.pos;
       do {
         location = find_closest_mesh_point_of_type(INVALID, pos);
@@ -886,35 +884,34 @@
         };
 
         if (!position_is_reachable(ppos)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
 
         LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
 
         do_blocking_move_to(ppos);
         do_blocking_move_to_z(z_clearance);
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
-        TERN_(HAS_LCD_MENU, ui.capture());
+        ui.capture();
 
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
         serialprintPGM(parser.seen('B') ? GET_TEXT(MSG_UBL_BC_INSERT) : GET_TEXT(MSG_UBL_BC_INSERT2));
 
         const float z_step = 0.01f;                         // existing behavior: 0.01mm per click, occasionally step
         //const float z_step = planner.steps_to_mm[Z_AXIS]; // approx one step each click
 
         move_z_with_encoder(z_step);
 
         if (click_and_hold()) {
           SERIAL_ECHOLNPGM("\nMesh only partially populated.");
           do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
-          ui.release();
           return restore_ubl_active_state_and_leave();
         }
 
         z_values[lpos.x][lpos.y] = current_position.z - thick;
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, z_values[lpos.x][lpos.y]));
 
         if (g29_verbose_level > 2)
           SERIAL_ECHOLNPAIR_F("Mesh Point Measured at: ", z_values[lpos.x][lpos.y], 6);
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.valid());
@@ -951,23 +948,23 @@
       mesh_index_pair location;
 
       if (!position_is_reachable(pos)) {
         SERIAL_ECHOLNPGM("(X,Y) outside printable radius.");
         return;
       }
 
       save_ubl_active_state_and_disable();
 
       LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
-      TERN_(HAS_LCD_MENU, ui.capture());                    // Take over control of the LCD encoder
+      ui.capture();                                               // Take over control of the LCD encoder
 
-      do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES); // Move to the given XY with probe clearance
+      do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES);  // Move to the given XY with probe clearance
 
       TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset));  // Move Z to the given 'H' offset
 
       MeshFlags done_flags{0};
       const xy_int8_t &lpos = location.pos;
       do {
         location = find_closest_mesh_point_of_type(SET_IN_BITMAP, pos, false, &done_flags);
 
         if (lpos.x < 0) break;                              // Stop when there are no more reachable points
 
@@ -1009,22 +1006,20 @@
         if (click_and_hold(abort_fine_tune)) break;         // Button held down? Abort editing
 
         z_values[lpos.x][lpos.y] = new_z;                   // Save the updated Z value
         TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, new_z));
 
         serial_delay(20);                                   // No switch noise
         ui.refresh();
 
       } while (lpos.x >= 0 && --g29_repetition_cnt > 0);
 
-      ui.release();
-
       if (do_ubl_mesh_map) display_map(g29_map_type);
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES);
 
       LCD_MESSAGEPGM(MSG_UBL_DONE_EDITING_MESH);
       SERIAL_ECHOLNPGM("Done Editing Mesh");
 
       if (lcd_map_control)
         ui.goto_screen(_lcd_ubl_output_map_lcd);
@@ -1161,20 +1156,21 @@
         SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
         TERN_(HAS_LCD_MENU, set_message_with_feedback(GET_TEXT(MSG_UBL_SAVE_ERROR)));
         return;
       }
     #endif
     ubl_state_at_invocation = planner.leveling_active;
     set_bed_leveling_enabled(false);
   }
 
   void unified_bed_leveling::restore_ubl_active_state_and_leave() {
+    TERN_(HAS_LCD_MENU, ui.release());
     #if ENABLED(UBL_DEVEL_DEBUGGING)
       if (--ubl_state_recursion_chk) {
         SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
         TERN_(HAS_LCD_MENU, set_message_with_feedback(GET_TEXT(MSG_UBL_RESTORE_ERROR)));
         return;
       }
     #endif
     set_bed_leveling_enabled(ubl_state_at_invocation);
   }
 

commit 25c7c43a829e3bbc581aae20d24b724a7ad8fbdb
Author: Fabio Santos <fabiosan@live.com>
Date:   Mon Jun 22 19:12:45 2020 -0700

    Add SERIAL_FLOAT_PRECISION option (#18367)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 95addd6c12..3c604168a6 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -426,21 +426,21 @@
             //
             // Invalidate Entire Mesh and Automatically Probe Mesh in areas that can be reached by the probe
             //
             if (!parser.seen('C')) {
               invalidate();
               SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
             }
             if (g29_verbose_level > 1) {
               SERIAL_ECHOPAIR("Probing around (", g29_pos.x);
               SERIAL_CHAR(',');
-              SERIAL_ECHO(g29_pos.y);
+              SERIAL_DECIMAL(g29_pos.y);
               SERIAL_ECHOLNPGM(").\n");
             }
             const xy_pos_t near_probe_xy = g29_pos + probe.offset_xy;
             probe_entire_mesh(near_probe_xy, parser.seen('T'), parser.seen('E'), parser.seen('U'));
 
             report_current_position();
             probe_deployed = true;
           } break;
 
         #endif // HAS_BED_PROBE

commit 8982756b4034226f7c17e4fdfde36a42cb8cf3b7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jun 21 20:55:19 2020 -0500

    Misc tweaks

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 251be5c196..95addd6c12 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -466,21 +466,21 @@
                 #if IS_KINEMATIC
                   X_HOME_POS, Y_HOME_POS
                 #else
                   probe.offset_xy.x > 0 ? X_BED_SIZE : 0,
                   probe.offset_xy.y < 0 ? Y_BED_SIZE : 0
                 #endif
               );
             }
 
             if (parser.seen('B')) {
-              g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness((float) Z_CLEARANCE_BETWEEN_PROBES);
+              g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness(float(Z_CLEARANCE_BETWEEN_PROBES));
               if (ABS(g29_card_thickness) > 1.5f) {
                 SERIAL_ECHOLNPGM("?Error in Business Card measurement.");
                 return;
               }
               probe_deployed = true;
             }
 
             if (!position_is_reachable(g29_pos)) {
               SERIAL_ECHOLNPGM("XY outside printable radius.");
               return;

commit c7b553c7b2ff4772c9a9b4da6629087e8869d195
Author: chestwood96 <adi.joachim12@gmail.com>
Date:   Wed Jun 17 19:43:17 2020 +0200

    Optional move-to-center after UBL G29 J (3-point) (#17964)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 8385c4bdf9..251be5c196 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -386,31 +386,26 @@
               z_values[x][y] += parser.seen('C') ? g29_constant : 9.99f;
               TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
             }
           break;
       }
     }
 
     #if HAS_BED_PROBE
 
       if (parser.seen('J')) {
-        if (g29_grid_size) {  // if not 0 it is a normal n x n grid being probed
-          save_ubl_active_state_and_disable();
-          tilt_mesh_based_on_probed_grid(false /* false says to do normal grid probing */ );
-          restore_ubl_active_state_and_leave();
-        }
-        else { // grid_size == 0 : A 3-Point leveling has been requested
-          save_ubl_active_state_and_disable();
-          tilt_mesh_based_on_probed_grid(true /* true says to do 3-Point leveling */ );
-          restore_ubl_active_state_and_leave();
-        }
-        do_blocking_move_to_xy(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)));
+        save_ubl_active_state_and_disable();
+        tilt_mesh_based_on_probed_grid(g29_grid_size == 0); // Zero size does 3-Point
+        restore_ubl_active_state_and_leave();
+        #if ENABLED(UBL_G29_J_RECENTER)
+          do_blocking_move_to_xy(0.5f * ((MESH_MIN_X) + (MESH_MAX_X)), 0.5f * ((MESH_MIN_Y) + (MESH_MAX_Y)));
+        #endif
         report_current_position();
         probe_deployed = true;
       }
 
     #endif // HAS_BED_PROBE
 
     if (parser.seen('P')) {
       if (WITHIN(g29_phase_value, 0, 1) && storage_slot == -1) {
         storage_slot = 0;
         SERIAL_ECHOLNPGM("Default storage slot 0 selected.");

commit 852a8d6685ec1137eb65e78fa748cae41fbd36b6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 5 03:31:03 2020 -0500

    Configurable kill pin state
    
    Co-Authored-By: AbdullahGheith <abdullahgheith@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 7d991fcccd..8385c4bdf9 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1676,22 +1676,23 @@
 
       SERIAL_ECHOPGM("Y-Axis Mesh Points at: ");
       LOOP_L_N(i, GRID_MAX_POINTS_Y) {
         SERIAL_ECHO_F(LOGICAL_Y_POSITION(mesh_index_to_ypos(i)), 3);
         SERIAL_ECHOPGM("  ");
         serial_delay(25);
       }
       SERIAL_EOL();
 
       #if HAS_KILL
-        SERIAL_ECHOLNPAIR("Kill pin on :", int(KILL_PIN), "  state:", READ(KILL_PIN));
+        SERIAL_ECHOLNPAIR("Kill pin on :", int(KILL_PIN), "  state:", int(kill_state()));
       #endif
+
       SERIAL_EOL();
       serial_delay(50);
 
       #if ENABLED(UBL_DEVEL_DEBUGGING)
         SERIAL_ECHOLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation, "\nubl_state_recursion_chk :", ubl_state_recursion_chk);
         serial_delay(50);
 
         SERIAL_ECHOLNPAIR("Meshes go from ", hex_address((void*)settings.meshes_start_index()), " to ", hex_address((void*)settings.meshes_end_index()));
         serial_delay(50);
 

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 86a08afbff..7d991fcccd 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -298,31 +298,27 @@
    *   features of all three systems combined.
    */
 
   void unified_bed_leveling::G29() {
 
     bool probe_deployed = false;
     if (g29_parameter_parsing()) return; // Abort on parameter error
 
     const int8_t p_val = parser.intval('P', -1);
     const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J');
-    #if HOTENDS > 1
-      const uint8_t old_tool_index = active_extruder;
-    #endif
+    TERN_(HAS_MULTI_HOTEND, const uint8_t old_tool_index = active_extruder);
 
     // Check for commands that require the printer to be homed
     if (may_move) {
       planner.synchronize();
       if (axes_need_homing()) gcode.home_all_axes();
-      #if HOTENDS > 1
-        if (active_extruder != 0) tool_change(0);
-      #endif
+      TERN_(HAS_MULTI_HOTEND, if (active_extruder) tool_change(0));
     }
 
     // Invalidate Mesh Points. This command is a little bit asymmetrical because
     // it directly specifies the repetition count and does not use the 'R' parameter.
     if (parser.seen('I')) {
       uint8_t cnt = 0;
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : 1;
       if (g29_repetition_cnt >= GRID_MAX_POINTS) {
         set_all_mesh_points_to_value(NAN);
       }
@@ -333,23 +329,21 @@
           const xy_int8_t &cpos = closest.pos;
           if (cpos.x < 0) {
             // No more REAL mesh points to invalidate, so we ASSUME the user
             // meant to invalidate the ENTIRE mesh, which cannot be done with
             // find_closest_mesh_point loop which only returns REAL points.
             set_all_mesh_points_to_value(NAN);
             SERIAL_ECHOLNPGM("Entire Mesh invalidated.\n");
             break;            // No more invalid Mesh Points to populate
           }
           z_values[cpos.x][cpos.y] = NAN;
-          #if ENABLED(EXTENSIBLE_UI)
-            ExtUI::onMeshUpdate(cpos, 0.0f);
-          #endif
+          TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(cpos, 0.0f));
           cnt++;
         }
       }
       SERIAL_ECHOLNPGM("Locations invalidated.\n");
     }
 
     if (parser.seen('Q')) {
       const int test_pattern = parser.has_value() ? parser.value_int() : -99;
       if (!WITHIN(test_pattern, -1, 2)) {
         SERIAL_ECHOLNPGM("Invalid test_pattern value. (-1 to 2)\n");
@@ -362,46 +356,42 @@
           case -1:
             g29_eeprom_dump();
             break;
         #endif
 
         case 0:
           GRID_LOOP(x, y) {                                     // Create a bowl shape similar to a poorly-calibrated Delta
             const float p1 = 0.5f * (GRID_MAX_POINTS_X) - x,
                         p2 = 0.5f * (GRID_MAX_POINTS_Y) - y;
             z_values[x][y] += 2.0f * HYPOT(p1, p2);
-            #if ENABLED(EXTENSIBLE_UI)
-              ExtUI::onMeshUpdate(x, y, z_values[x][y]);
-            #endif
+            TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
           }
           break;
 
         case 1:
           LOOP_L_N(x, GRID_MAX_POINTS_X) {                     // Create a diagonal line several Mesh cells thick that is raised
             z_values[x][x] += 9.999f;
             z_values[x][x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1] += 9.999f; // We want the altered line several mesh points thick
             #if ENABLED(EXTENSIBLE_UI)
               ExtUI::onMeshUpdate(x, x, z_values[x][x]);
               ExtUI::onMeshUpdate(x, (x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1), z_values[x][x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1]);
             #endif
 
           }
           break;
 
         case 2:
           // Allow the user to specify the height because 10mm is a little extreme in some cases.
           for (uint8_t x = (GRID_MAX_POINTS_X) / 3; x < 2 * (GRID_MAX_POINTS_X) / 3; x++)     // Create a rectangular raised area in
             for (uint8_t y = (GRID_MAX_POINTS_Y) / 3; y < 2 * (GRID_MAX_POINTS_Y) / 3; y++) { // the center of the bed
               z_values[x][y] += parser.seen('C') ? g29_constant : 9.99f;
-              #if ENABLED(EXTENSIBLE_UI)
-                ExtUI::onMeshUpdate(x, y, z_values[x][y]);
-              #endif
+              TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
             }
           break;
       }
     }
 
     #if HAS_BED_PROBE
 
       if (parser.seen('J')) {
         if (g29_grid_size) {  // if not 0 it is a normal n x n grid being probed
           save_ubl_active_state_and_disable();
@@ -533,23 +523,21 @@
                 const mesh_index_pair closest = find_closest_mesh_point_of_type(INVALID, g29_pos);
                 const xy_int8_t &cpos = closest.pos;
                 if (cpos.x < 0) {
                   // No more REAL INVALID mesh points to populate, so we ASSUME
                   // user meant to populate ALL INVALID mesh points to value
                   GRID_LOOP(x, y) if (isnan(z_values[x][y])) z_values[x][y] = g29_constant;
                   break; // No more invalid Mesh Points to populate
                 }
                 else {
                   z_values[cpos.x][cpos.y] = g29_constant;
-                  #if ENABLED(EXTENSIBLE_UI)
-                    ExtUI::onMeshUpdate(cpos, g29_constant);
-                  #endif
+                  TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(cpos, g29_constant));
                 }
               }
             }
           }
           else {
             const float cvf = parser.value_float();
             switch ((int)truncf(cvf * 10.0f) - 30) {   // 3.1 -> 1
               #if ENABLED(UBL_G29_P31)
                 case 1: {
 
@@ -676,23 +664,21 @@
     #ifdef Z_PROBE_END_SCRIPT
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
       if (probe_deployed) {
         planner.synchronize();
         gcode.process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
       }
     #else
       UNUSED(probe_deployed);
     #endif
 
-    #if HOTENDS > 1
-      tool_change(old_tool_index);
-    #endif
+    TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index));
     return;
   }
 
   void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float value) {
     float sum = 0;
     int n = 0;
     GRID_LOOP(x, y)
       if (!isnan(z_values[x][y])) {
         sum += z_values[x][y];
         n++;
@@ -711,102 +697,89 @@
     SERIAL_ECHOLNPAIR("# of samples: ", n);
     SERIAL_ECHOLNPAIR_F("Mean Mesh Height: ", mean, 6);
 
     const float sigma = SQRT(sum_of_diff_squared / (n + 1));
     SERIAL_ECHOLNPAIR_F("Standard Deviation: ", sigma, 6);
 
     if (cflag)
       GRID_LOOP(x, y)
         if (!isnan(z_values[x][y])) {
           z_values[x][y] -= mean + value;
-          #if ENABLED(EXTENSIBLE_UI)
-            ExtUI::onMeshUpdate(x, y, z_values[x][y]);
-          #endif
+          TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
         }
   }
 
   void unified_bed_leveling::shift_mesh_height() {
     GRID_LOOP(x, y)
       if (!isnan(z_values[x][y])) {
         z_values[x][y] += g29_constant;
-        #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::onMeshUpdate(x, y, z_values[x][y]);
-        #endif
+        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
       }
   }
 
   #if HAS_BED_PROBE
     /**
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
     void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &near, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
       probe.deploy(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
 
-      #if HAS_LCD_MENU
-        ui.capture();
-      #endif
+      TERN_(HAS_LCD_MENU, ui.capture());
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       uint8_t count = GRID_MAX_POINTS;
 
       mesh_index_pair best;
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
         const int point_num = (GRID_MAX_POINTS) - count + 1;
         SERIAL_ECHOLNPAIR("\nProbing mesh point ", point_num, "/", int(GRID_MAX_POINTS), ".\n");
-        #if HAS_DISPLAY
-          ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), point_num, int(GRID_MAX_POINTS));
-        #endif
+        TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), point_num, int(GRID_MAX_POINTS)));
 
         #if HAS_LCD_MENU
           if (ui.button_pressed()) {
             ui.quick_feedback(false); // Preserve button state for click-and-hold
             SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
             ui.wait_for_release();
             ui.quick_feedback();
             ui.release();
             probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
             return restore_ubl_active_state_and_leave();
           }
         #endif
 
         best = do_furthest
           ? find_furthest_invalid_mesh_point()
           : find_closest_mesh_point_of_type(INVALID, near, true);
 
         if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
-          #if ENABLED(EXTENSIBLE_UI)
-            ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_START);
-          #endif
+          TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_START));
           const float measured_z = probe.probe_at_point(
                         best.meshpos(),
                         stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level
                       );
           z_values[best.pos.x][best.pos.y] = measured_z;
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_FINISH);
             ExtUI::onMeshUpdate(best.pos, measured_z);
           #endif
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
 
       } while (best.pos.x >= 0 && --count);
 
-      #if HAS_LCD_MENU
-        ui.release();
-      #endif
-      probe.stow(); // Release UI during stow to allow for PAUSE_BEFORE_DEPLOY_STOW
-      #if HAS_LCD_MENU
-        ui.capture();
-      #endif
+      // Release UI during stow to allow for PAUSE_BEFORE_DEPLOY_STOW
+      TERN_(HAS_LCD_MENU, ui.release());
+      probe.stow();
+      TERN_(HAS_LCD_MENU, ui.capture());
 
       #ifdef Z_AFTER_PROBING
         probe.move_z_after_probing();
       #endif
 
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
         constrain(near.x - probe.offset_xy.x, MESH_MIN_X, MESH_MAX_X),
         constrain(near.y - probe.offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
@@ -851,23 +824,21 @@
 
     float unified_bed_leveling::measure_point_with_encoder() {
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       move_z_with_encoder(0.01f);
       return current_position.z;
     }
 
     static void echo_and_take_a_measurement() { SERIAL_ECHOLNPGM(" and take a measurement."); }
 
     float unified_bed_leveling::measure_business_card_thickness(float in_height) {
-      #if HAS_LCD_MENU
-        ui.capture();
-      #endif
+      TERN_(HAS_LCD_MENU, ui.capture());
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
       do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
         //, _MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f);
       planner.synchronize();
 
       SERIAL_ECHOPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       ui.return_to_status();
       echo_and_take_a_measurement();
@@ -892,23 +863,21 @@
       }
 
       ui.release();
 
       restore_ubl_active_state_and_leave();
 
       return thickness;
     }
 
     void unified_bed_leveling::manually_probe_remaining_mesh(const xy_pos_t &pos, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
-      #if HAS_LCD_MENU
-        ui.capture();
-      #endif
+      TERN_(HAS_LCD_MENU, ui.capture());
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       do_blocking_move_to_xy_z(current_position, z_clearance);
 
       ui.return_to_status();
 
       mesh_index_pair location;
       const xy_int8_t &lpos = location.pos;
       do {
         location = find_closest_mesh_point_of_type(INVALID, pos);
@@ -922,44 +891,40 @@
         };
 
         if (!position_is_reachable(ppos)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
 
         LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
 
         do_blocking_move_to(ppos);
         do_blocking_move_to_z(z_clearance);
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
-        #if HAS_LCD_MENU
-          ui.capture();
-        #endif
+        TERN_(HAS_LCD_MENU, ui.capture());
 
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
         serialprintPGM(parser.seen('B') ? GET_TEXT(MSG_UBL_BC_INSERT) : GET_TEXT(MSG_UBL_BC_INSERT2));
 
         const float z_step = 0.01f;                         // existing behavior: 0.01mm per click, occasionally step
         //const float z_step = planner.steps_to_mm[Z_AXIS]; // approx one step each click
 
         move_z_with_encoder(z_step);
 
         if (click_and_hold()) {
           SERIAL_ECHOLNPGM("\nMesh only partially populated.");
           do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
           ui.release();
           return restore_ubl_active_state_and_leave();
         }
 
         z_values[lpos.x][lpos.y] = current_position.z - thick;
-        #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::onMeshUpdate(location, z_values[lpos.x][lpos.y]);
-        #endif
+        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, z_values[lpos.x][lpos.y]));
 
         if (g29_verbose_level > 2)
           SERIAL_ECHOLNPAIR_F("Mesh Point Measured at: ", z_values[lpos.x][lpos.y], 6);
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.valid());
 
       if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
       restore_ubl_active_state_and_leave();
       do_blocking_move_to_xy_z(pos, Z_CLEARANCE_DEPLOY_PROBE);
@@ -991,81 +956,72 @@
       mesh_index_pair location;
 
       if (!position_is_reachable(pos)) {
         SERIAL_ECHOLNPGM("(X,Y) outside printable radius.");
         return;
       }
 
       save_ubl_active_state_and_disable();
 
       LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
-      #if HAS_LCD_MENU
-        ui.capture();                                         // Take over control of the LCD encoder
-      #endif
+      TERN_(HAS_LCD_MENU, ui.capture());                    // Take over control of the LCD encoder
+
       do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES); // Move to the given XY with probe clearance
 
-      #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
-        do_blocking_move_to_z(h_offset);                    // Move Z to the given 'H' offset
-      #endif
+      TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset));  // Move Z to the given 'H' offset
 
       MeshFlags done_flags{0};
       const xy_int8_t &lpos = location.pos;
       do {
         location = find_closest_mesh_point_of_type(SET_IN_BITMAP, pos, false, &done_flags);
 
         if (lpos.x < 0) break;                              // Stop when there are no more reachable points
 
         done_flags.mark(lpos);                              // Mark this location as 'adjusted' so a new
                                                             // location is used on the next loop
         const xyz_pos_t raw = {
           mesh_index_to_xpos(lpos.x),
           mesh_index_to_ypos(lpos.y),
           Z_CLEARANCE_BETWEEN_PROBES
         };
 
         if (!position_is_reachable(raw)) break;             // SHOULD NOT OCCUR (find_closest_mesh_point_of_type only returns reachable)
 
         do_blocking_move_to(raw);                           // Move the nozzle to the edit point with probe clearance
 
-        #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
-          do_blocking_move_to_z(h_offset);                  // Move Z to the given 'H' offset before editing
-        #endif
+        TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset)); // Move Z to the given 'H' offset before editing
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
 
         if (do_ubl_mesh_map) display_map(g29_map_type);     // Display the current point
 
         ui.refresh();
 
         float new_z = z_values[lpos.x][lpos.y];
         if (isnan(new_z)) new_z = 0;                        // Invalid points begin at 0
         new_z = FLOOR(new_z * 1000) * 0.001f;               // Chop off digits after the 1000ths place
 
         lcd_mesh_edit_setup(new_z);
 
         do {
           new_z = lcd_mesh_edit();
-          #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
-            do_blocking_move_to_z(h_offset + new_z);        // Move the nozzle as the point is edited
-          #endif
+          TERN_(UBL_MESH_EDIT_MOVES_Z, do_blocking_move_to_z(h_offset + new_z)); // Move the nozzle as the point is edited
           idle();
           SERIAL_FLUSH();                                   // Prevent host M105 buffer overrun.
         } while (!ui.button_pressed());
 
         if (!lcd_map_control) ui.return_to_status();        // Just editing a single point? Return to status
 
         if (click_and_hold(abort_fine_tune)) break;         // Button held down? Abort editing
 
         z_values[lpos.x][lpos.y] = new_z;                   // Save the updated Z value
-        #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::onMeshUpdate(location, new_z);
-        #endif
+        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(location, new_z));
 
         serial_delay(20);                                   // No switch noise
         ui.refresh();
 
       } while (lpos.x >= 0 && --g29_repetition_cnt > 0);
 
       ui.release();
 
       if (do_ubl_mesh_map) display_map(g29_map_type);
       restore_ubl_active_state_and_leave();
@@ -1079,23 +1035,21 @@
         ui.goto_screen(_lcd_ubl_output_map_lcd);
       else
         ui.return_to_status();
     }
 
   #endif // HAS_LCD_MENU
 
   bool unified_bed_leveling::g29_parameter_parsing() {
     bool err_flag = false;
 
-    #if HAS_LCD_MENU
-      set_message_with_feedback(GET_TEXT(MSG_UBL_DOING_G29));
-    #endif
+    TERN_(HAS_LCD_MENU, set_message_with_feedback(GET_TEXT(MSG_UBL_DOING_G29)));
 
     g29_constant = 0;
     g29_repetition_cnt = 0;
 
     if (parser.seen('R')) {
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : GRID_MAX_POINTS;
       NOMORE(g29_repetition_cnt, GRID_MAX_POINTS);
       if (g29_repetition_cnt < 1) {
         SERIAL_ECHOLNPGM("?(R)epetition count invalid (1+).\n");
         return UBL_ERR;
@@ -1203,37 +1157,33 @@
 
   #if ENABLED(UBL_DEVEL_DEBUGGING)
     static uint8_t ubl_state_recursion_chk = 0;
   #endif
 
   void unified_bed_leveling::save_ubl_active_state_and_disable() {
     #if ENABLED(UBL_DEVEL_DEBUGGING)
       ubl_state_recursion_chk++;
       if (ubl_state_recursion_chk != 1) {
         SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
-        #if HAS_LCD_MENU
-          set_message_with_feedback(GET_TEXT(MSG_UBL_SAVE_ERROR));
-        #endif
+        TERN_(HAS_LCD_MENU, set_message_with_feedback(GET_TEXT(MSG_UBL_SAVE_ERROR)));
         return;
       }
     #endif
     ubl_state_at_invocation = planner.leveling_active;
     set_bed_leveling_enabled(false);
   }
 
   void unified_bed_leveling::restore_ubl_active_state_and_leave() {
     #if ENABLED(UBL_DEVEL_DEBUGGING)
       if (--ubl_state_recursion_chk) {
         SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
-        #if HAS_LCD_MENU
-          set_message_with_feedback(GET_TEXT(MSG_UBL_RESTORE_ERROR));
-        #endif
+        TERN_(HAS_LCD_MENU, set_message_with_feedback(GET_TEXT(MSG_UBL_RESTORE_ERROR)));
         return;
       }
     #endif
     set_bed_leveling_enabled(ubl_state_at_invocation);
   }
 
   mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
     bool found_a_NAN = false, found_a_real = false;
 
@@ -1334,23 +1284,21 @@
 
   bool unified_bed_leveling::smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
     const float v = z_values[x][y];
     if (isnan(v)) {                           // A NAN...
       const int8_t dx = x + xdir, dy = y + ydir;
       const float v1 = z_values[dx][dy];
       if (!isnan(v1)) {                       // ...next to a pair of real values?
         const float v2 = z_values[dx + xdir][dy + ydir];
         if (!isnan(v2)) {
           z_values[x][y] = v1 < v2 ? v1 : v1 + v1 - v2;
-          #if ENABLED(EXTENSIBLE_UI)
-            ExtUI::onMeshUpdate(x, y, z_values[x][y]);
-          #endif
+          TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
           return true;
         }
       }
     }
     return false;
   }
 
   typedef struct { uint8_t sx, ex, sy, ey; bool yfirst; } smart_fill_info;
 
   void unified_bed_leveling::smart_fill_mesh() {
@@ -1400,66 +1348,60 @@
 
       #ifdef VALIDATE_MESH_TILT
         float z1, z2, z3;  // Needed for algorithm validation below
       #endif
 
       struct linear_fit_data lsf_results;
       incremental_LSF_reset(&lsf_results);
 
       if (do_3_pt_leveling) {
         SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
-        #if HAS_DISPLAY
-          ui.status_printf_P(0, PSTR(S_FMT " 1/3"), GET_TEXT(MSG_LCD_TILTING_MESH));
-        #endif
+        TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " 1/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
         measured_z = probe.probe_at_point(points[0], PROBE_PT_RAISE, g29_verbose_level);
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[0]);
           #ifdef VALIDATE_MESH_TILT
             z1 = measured_z;
           #endif
           if (g29_verbose_level > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, points[0], measured_z);
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
-          #if HAS_DISPLAY
-            ui.status_printf_P(0, PSTR(S_FMT " 2/3"), GET_TEXT(MSG_LCD_TILTING_MESH));
-          #endif
+          TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " 2/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
           measured_z = probe.probe_at_point(points[1], PROBE_PT_RAISE, g29_verbose_level);
           #ifdef VALIDATE_MESH_TILT
             z2 = measured_z;
           #endif
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(points[1]);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, points[1], measured_z);
           }
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
-          #if HAS_DISPLAY
-            ui.status_printf_P(0, PSTR(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH));
-          #endif
+          TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH)));
 
           measured_z = probe.probe_at_point(points[2], PROBE_PT_STOW, g29_verbose_level);
           #ifdef VALIDATE_MESH_TILT
             z3 = measured_z;
           #endif
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(points[2]);
             if (g29_verbose_level > 3) {
@@ -1488,23 +1430,21 @@
         uint16_t point_num = 1;
 
         xy_pos_t rpos;
         LOOP_L_N(ix, g29_grid_size) {
           rpos.x = x_min + ix * dx;
           LOOP_L_N(iy, g29_grid_size) {
             rpos.y = y_min + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
 
             if (!abort_flag) {
               SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
-              #if HAS_DISPLAY
-                ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points);
-              #endif
+              TERN_(HAS_DISPLAY, ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points));
 
               measured_z = probe.probe_at_point(rpos, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
 
               abort_flag = isnan(measured_z);
 
               #if ENABLED(DEBUG_LEVELING_FEATURE)
                 if (DEBUGGING(LEVELING)) {
                   const xy_pos_t lpos = rpos.asLogical();
                   DEBUG_CHAR('(');
                   DEBUG_ECHO_F(rpos.x, 7);
@@ -1579,23 +1519,21 @@
           DEBUG_ECHOPAIR_F("after rotation = [", mx, 7);
           DEBUG_CHAR(',');
           DEBUG_ECHO_F(my, 7);
           DEBUG_CHAR(',');
           DEBUG_ECHO_F(mz, 7);
           DEBUG_ECHOLNPGM("]");
           DEBUG_DELAY(20);
         }
 
         z_values[i][j] = mz - lsf_results.D;
-        #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::onMeshUpdate(i, j, z_values[i][j]);
-        #endif
+        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(i, j, z_values[i][j]));
       }
 
       if (DEBUGGING(LEVELING)) {
         rotation.debug(PSTR("rotation matrix:\n"));
         DEBUG_ECHOPAIR_F("LSF Results A=", lsf_results.A, 7);
         DEBUG_ECHOPAIR_F("  B=", lsf_results.B, 7);
         DEBUG_ECHOLNPAIR_F("  D=", lsf_results.D, 7);
         DEBUG_DELAY(55);
 
         DEBUG_ECHOPAIR_F("bed plane normal = [", normal.x, 7);
@@ -1677,23 +1615,21 @@
                   incremental_WLSF(&lsf_results, rpos, rz, w);
                 }
               }
             }
             if (finish_incremental_LSF(&lsf_results)) {
               SERIAL_ECHOLNPGM("Insufficient data");
               return;
             }
             const float ez = -lsf_results.D - lsf_results.A * ppos.x - lsf_results.B * ppos.y;
             z_values[ix][iy] = ez;
-            #if ENABLED(EXTENSIBLE_UI)
-              ExtUI::onMeshUpdate(ix, iy, z_values[ix][iy]);
-            #endif
+            TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(ix, iy, z_values[ix][iy]));
             idle(); // housekeeping
           }
         }
       }
 
       SERIAL_ECHOLNPGM("done");
     }
   #endif // UBL_G29_P31
 
   #if ENABLED(UBL_DEVEL_DEBUGGING)
@@ -1819,19 +1755,17 @@
 
       g29_storage_slot = parser.value_int();
 
       float tmp_z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
       settings.load_mesh(g29_storage_slot, &tmp_z_values);
 
       SERIAL_ECHOLNPAIR("Subtracting mesh in slot ", g29_storage_slot, " from current mesh.");
 
       GRID_LOOP(x, y) {
         z_values[x][y] -= tmp_z_values[x][y];
-        #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::onMeshUpdate(x, y, z_values[x][y]);
-        #endif
+        TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
       }
     }
 
   #endif // UBL_DEVEL_DEBUGGING
 
 #endif // AUTO_BED_LEVELING_UBL

commit 15f6f53638a6778d22a17e1900fb3a9fdc92dade
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 19 23:56:55 2020 -0500

    Add HAS_HOTEND, etc.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index d451f7246f..86a08afbff 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -31,21 +31,21 @@
   #include "../../../libs/hex_print_routines.h"
   #include "../../../module/configuration_store.h"
   #include "../../../lcd/ultralcd.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
   #include "../../../module/motion.h"
   #include "../../../module/probe.h"
   #include "../../../gcode/gcode.h"
   #include "../../../libs/least_squares_fit.h"
 
-  #if HOTENDS > 1
+  #if HAS_MULTI_HOTEND
     #include "../../../module/tool_change.h"
   #endif
 
   #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
   #include "../../../core/debug_out.h"
 
   #if ENABLED(EXTENSIBLE_UI)
     #include "../../../lcd/extui/ui_api.h"
   #endif
 

commit 3645e59893825133924a8af1f6ad5773d21f7f15
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 9 12:30:43 2020 -0500

    Minor style tweaks

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 940b4eaeb4..d451f7246f 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -444,22 +444,22 @@
             if (!parser.seen('C')) {
               invalidate();
               SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
             }
             if (g29_verbose_level > 1) {
               SERIAL_ECHOPAIR("Probing around (", g29_pos.x);
               SERIAL_CHAR(',');
               SERIAL_ECHO(g29_pos.y);
               SERIAL_ECHOLNPGM(").\n");
             }
-            const xy_pos_t near = g29_pos + probe.offset_xy;
-            probe_entire_mesh(near, parser.seen('T'), parser.seen('E'), parser.seen('U'));
+            const xy_pos_t near_probe_xy = g29_pos + probe.offset_xy;
+            probe_entire_mesh(near_probe_xy, parser.seen('T'), parser.seen('E'), parser.seen('U'));
 
             report_current_position();
             probe_deployed = true;
           } break;
 
         #endif // HAS_BED_PROBE
 
         case 2: {
           #if HAS_LCD_MENU
             //

commit be0e313c078c7425de7bc45a0371756ee2571056
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Thu Apr 2 13:24:55 2020 -0600

    Touch UI additions, bug fixes (#17379)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 217d894543..940b4eaeb4 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -769,26 +769,30 @@
             probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
             return restore_ubl_active_state_and_leave();
           }
         #endif
 
         best = do_furthest
           ? find_furthest_invalid_mesh_point()
           : find_closest_mesh_point_of_type(INVALID, near, true);
 
         if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
+          #if ENABLED(EXTENSIBLE_UI)
+            ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_START);
+          #endif
           const float measured_z = probe.probe_at_point(
                         best.meshpos(),
                         stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level
                       );
           z_values[best.pos.x][best.pos.y] = measured_z;
           #if ENABLED(EXTENSIBLE_UI)
+            ExtUI::onMeshUpdate(best.pos, ExtUI::PROBE_FINISH);
             ExtUI::onMeshUpdate(best.pos, measured_z);
           #endif
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
 
       } while (best.pos.x >= 0 && --count);
 
       #if HAS_LCD_MENU
         ui.release();
       #endif

commit 129b270628781eae776764e63fd514553e6c2204
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Fri Mar 27 23:29:17 2020 +0100

    QSPI EEPROM for SAMD51 (#17292)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 1ac036e5bc..217d894543 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -20,21 +20,21 @@
  *
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
   #include "../bedlevel.h"
 
   #include "../../../MarlinCore.h"
-  #include "../../../HAL/shared/persistent_store_api.h"
+  #include "../../../HAL/shared/eeprom_api.h"
   #include "../../../libs/hex_print_routines.h"
   #include "../../../module/configuration_store.h"
   #include "../../../lcd/ultralcd.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
   #include "../../../module/motion.h"
   #include "../../../module/probe.h"
   #include "../../../gcode/gcode.h"
   #include "../../../libs/least_squares_fit.h"
 

commit abea6d5787654dc67bc86ac75207a997da9a7219
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 18 10:30:19 2020 -0500

    Tweak some lambdas

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 1aad462f16..1ac036e5bc 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1604,21 +1604,21 @@
 
         /**
          * Use the code below to check the validity of the mesh tilting algorithm.
          * 3-Point Mesh Tilt uses the same algorithm as grid-based tilting, but only
          * three points are used in the calculation. This guarantees that each probed point
          * has an exact match when get_z_correction() for that location is calculated.
          * The Z error between the probed point locations and the get_z_correction()
          * numbers for those locations should be 0.
          */
         #ifdef VALIDATE_MESH_TILT
-          auto d_from = []() { DEBUG_ECHOPGM("D from "); };
+          auto d_from = []{ DEBUG_ECHOPGM("D from "); };
           auto normed = [&](const xy_pos_t &pos, const float &zadd) {
             return normal.x * pos.x + normal.y * pos.y + zadd;
           };
           auto debug_pt = [](PGM_P const pre, const xy_pos_t &pos, const float &zadd) {
             d_from(); serialprintPGM(pre);
             DEBUG_ECHO_F(normed(pos, zadd), 6);
             DEBUG_ECHOLNPAIR_F("   Z error = ", zadd - get_z_correction(pos), 6);
           };
           debug_pt(PSTR("1st point: "), probe_pt[0], normal.z * z1);
           debug_pt(PSTR("2nd point: "), probe_pt[1], normal.z * z2);

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 3c18760ba0..1aad462f16 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -358,39 +358,37 @@
       SERIAL_ECHOLNPGM("Loading test_pattern values.\n");
       switch (test_pattern) {
 
         #if ENABLED(UBL_DEVEL_DEBUGGING)
           case -1:
             g29_eeprom_dump();
             break;
         #endif
 
         case 0:
-          for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++) {   // Create a bowl shape - similar to
-            for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++) { // a poorly calibrated Delta.
-              const float p1 = 0.5f * (GRID_MAX_POINTS_X) - x,
-                          p2 = 0.5f * (GRID_MAX_POINTS_Y) - y;
-              z_values[x][y] += 2.0f * HYPOT(p1, p2);
-              #if ENABLED(EXTENSIBLE_UI)
-                ExtUI::onMeshUpdate(x, y, z_values[x][y]);
-              #endif
-            }
+          GRID_LOOP(x, y) {                                     // Create a bowl shape similar to a poorly-calibrated Delta
+            const float p1 = 0.5f * (GRID_MAX_POINTS_X) - x,
+                        p2 = 0.5f * (GRID_MAX_POINTS_Y) - y;
+            z_values[x][y] += 2.0f * HYPOT(p1, p2);
+            #if ENABLED(EXTENSIBLE_UI)
+              ExtUI::onMeshUpdate(x, y, z_values[x][y]);
+            #endif
           }
           break;
 
         case 1:
-          for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++) {  // Create a diagonal line several Mesh cells thick that is raised
+          LOOP_L_N(x, GRID_MAX_POINTS_X) {                     // Create a diagonal line several Mesh cells thick that is raised
             z_values[x][x] += 9.999f;
-            z_values[x][x + (x < GRID_MAX_POINTS_Y - 1) ? 1 : -1] += 9.999f; // We want the altered line several mesh points thick
+            z_values[x][x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1] += 9.999f; // We want the altered line several mesh points thick
             #if ENABLED(EXTENSIBLE_UI)
               ExtUI::onMeshUpdate(x, x, z_values[x][x]);
-              ExtUI::onMeshUpdate(x, (x + (x < GRID_MAX_POINTS_Y - 1) ? 1 : -1), z_values[x][x + (x < GRID_MAX_POINTS_Y - 1) ? 1 : -1]);
+              ExtUI::onMeshUpdate(x, (x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1), z_values[x][x + (x < (GRID_MAX_POINTS_Y) - 1) ? 1 : -1]);
             #endif
 
           }
           break;
 
         case 2:
           // Allow the user to specify the height because 10mm is a little extreme in some cases.
           for (uint8_t x = (GRID_MAX_POINTS_X) / 3; x < 2 * (GRID_MAX_POINTS_X) / 3; x++)     // Create a rectangular raised area in
             for (uint8_t y = (GRID_MAX_POINTS_Y) / 3; y < 2 * (GRID_MAX_POINTS_Y) / 3; y++) { // the center of the bed
               z_values[x][y] += parser.seen('C') ? g29_constant : 9.99f;
@@ -460,21 +458,21 @@
             probe_deployed = true;
           } break;
 
         #endif // HAS_BED_PROBE
 
         case 2: {
           #if HAS_LCD_MENU
             //
             // Manually Probe Mesh in areas that can't be reached by the probe
             //
-            SERIAL_ECHOLNPGM("Manually probing unreachable mesh locations.");
+            SERIAL_ECHOLNPGM("Manually probing unreachable points.");
             do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
 
             if (parser.seen('C') && !xy_seen) {
 
               /**
                * Use a good default location for the path.
                * The flipped > and < operators in these comparisons is intentional.
                * It should cause the probed points to follow a nice path on Cartesian printers.
                * It may make sense to have Delta printers default to the center of the bed.
                * Until that is decided, this can be forced with the X and Y parameters.
@@ -530,23 +528,21 @@
             if (g29_repetition_cnt >= GRID_MAX_POINTS) {
               set_all_mesh_points_to_value(g29_constant);
             }
             else {
               while (g29_repetition_cnt--) {  // this only populates reachable mesh points near
                 const mesh_index_pair closest = find_closest_mesh_point_of_type(INVALID, g29_pos);
                 const xy_int8_t &cpos = closest.pos;
                 if (cpos.x < 0) {
                   // No more REAL INVALID mesh points to populate, so we ASSUME
                   // user meant to populate ALL INVALID mesh points to value
-                  for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
-                    for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
-                      if (isnan(z_values[x][y])) z_values[x][y] = g29_constant;
+                  GRID_LOOP(x, y) if (isnan(z_values[x][y])) z_values[x][y] = g29_constant;
                   break; // No more invalid Mesh Points to populate
                 }
                 else {
                   z_values[cpos.x][cpos.y] = g29_constant;
                   #if ENABLED(EXTENSIBLE_UI)
                     ExtUI::onMeshUpdate(cpos, g29_constant);
                   #endif
                 }
               }
             }
@@ -689,66 +685,62 @@
 
     #if HOTENDS > 1
       tool_change(old_tool_index);
     #endif
     return;
   }
 
   void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float value) {
     float sum = 0;
     int n = 0;
-    for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
-      for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
-        if (!isnan(z_values[x][y])) {
-          sum += z_values[x][y];
-          n++;
-        }
+    GRID_LOOP(x, y)
+      if (!isnan(z_values[x][y])) {
+        sum += z_values[x][y];
+        n++;
+      }
 
     const float mean = sum / n;
 
     //
     // Sum the squares of difference from mean
     //
     float sum_of_diff_squared = 0;
-    for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
-      for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
-        if (!isnan(z_values[x][y]))
-          sum_of_diff_squared += sq(z_values[x][y] - mean);
+    GRID_LOOP(x, y)
+      if (!isnan(z_values[x][y]))
+        sum_of_diff_squared += sq(z_values[x][y] - mean);
 
     SERIAL_ECHOLNPAIR("# of samples: ", n);
     SERIAL_ECHOLNPAIR_F("Mean Mesh Height: ", mean, 6);
 
     const float sigma = SQRT(sum_of_diff_squared / (n + 1));
     SERIAL_ECHOLNPAIR_F("Standard Deviation: ", sigma, 6);
 
     if (cflag)
-      for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
-        for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
-          if (!isnan(z_values[x][y])) {
-            z_values[x][y] -= mean + value;
-            #if ENABLED(EXTENSIBLE_UI)
-              ExtUI::onMeshUpdate(x, y, z_values[x][y]);
-            #endif
-          }
-  }
-
-  void unified_bed_leveling::shift_mesh_height() {
-    for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
-      for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
+      GRID_LOOP(x, y)
         if (!isnan(z_values[x][y])) {
-          z_values[x][y] += g29_constant;
+          z_values[x][y] -= mean + value;
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(x, y, z_values[x][y]);
           #endif
         }
   }
 
+  void unified_bed_leveling::shift_mesh_height() {
+    GRID_LOOP(x, y)
+      if (!isnan(z_values[x][y])) {
+        z_values[x][y] += g29_constant;
+        #if ENABLED(EXTENSIBLE_UI)
+          ExtUI::onMeshUpdate(x, y, z_values[x][y]);
+        #endif
+      }
+  }
+
   #if HAS_BED_PROBE
     /**
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
     void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &near, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
       probe.deploy(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
 
       #if HAS_LCD_MENU
         ui.capture();
@@ -1236,111 +1228,103 @@
     #endif
     set_bed_leveling_enabled(ubl_state_at_invocation);
   }
 
   mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
     bool found_a_NAN = false, found_a_real = false;
 
     mesh_index_pair farthest { -1, -1, -99999.99 };
 
-    for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
-      for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
+    GRID_LOOP(i, j) {
+      if (!isnan(z_values[i][j])) continue;  // Skip valid mesh points
 
-        if (isnan(z_values[i][j])) {                  // Invalid mesh point?
+      // Skip unreachable points
+      if (!probe.can_reach(mesh_index_to_xpos(i), mesh_index_to_ypos(j)))
+        continue;
 
-          // Skip points the probe can't reach
-          if (!probe.can_reach(mesh_index_to_xpos(i), mesh_index_to_ypos(j)))
-            continue;
+      found_a_NAN = true;
 
-          found_a_NAN = true;
+      xy_int8_t near { -1, -1 };
+      float d1, d2 = 99999.9f;
+      GRID_LOOP(k, l) {
+        if (isnan(z_values[k][l])) continue;
 
-          xy_int8_t near { -1, -1 };
-          float d1, d2 = 99999.9f;
-          for (int8_t k = 0; k < GRID_MAX_POINTS_X; k++) {
-            for (int8_t l = 0; l < GRID_MAX_POINTS_Y; l++) {
-              if (!isnan(z_values[k][l])) {
-                found_a_real = true;
+        found_a_real = true;
 
-                // Add in a random weighting factor that scrambles the probing of the
-                // last half of the mesh (when every unprobed mesh point is one index
-                // from a probed location).
+        // Add in a random weighting factor that scrambles the probing of the
+        // last half of the mesh (when every unprobed mesh point is one index
+        // from a probed location).
 
-                d1 = HYPOT(i - k, j - l) + (1.0f / ((millis() % 47) + 13));
+        d1 = HYPOT(i - k, j - l) + (1.0f / ((millis() % 47) + 13));
 
-                if (d1 < d2) {    // Invalid mesh point (i,j) is closer to the defined point (k,l)
-                  d2 = d1;
-                  near.set(i, j);
-                }
-              }
-            }
-          }
+        if (d1 < d2) {    // Invalid mesh point (i,j) is closer to the defined point (k,l)
+          d2 = d1;
+          near.set(i, j);
+        }
+      }
 
-          //
-          // At this point d2 should have the near defined mesh point to invalid mesh point (i,j)
-          //
+      //
+      // At this point d2 should have the near defined mesh point to invalid mesh point (i,j)
+      //
 
-          if (found_a_real && near.x >= 0 && d2 > farthest.distance) {
-            farthest.pos = near;      // Found an invalid location farther from the defined mesh point
-            farthest.distance = d2;
-          }
-        }
-      } // for j
-    } // for i
+      if (found_a_real && near.x >= 0 && d2 > farthest.distance) {
+        farthest.pos = near;      // Found an invalid location farther from the defined mesh point
+        farthest.distance = d2;
+      }
+    } // GRID_LOOP
 
     if (!found_a_real && found_a_NAN) {        // if the mesh is totally unpopulated, start the probing
-      farthest.pos.set(GRID_MAX_POINTS_X / 2, GRID_MAX_POINTS_Y / 2);
+      farthest.pos.set((GRID_MAX_POINTS_X) / 2, (GRID_MAX_POINTS_Y) / 2);
       farthest.distance = 1;
     }
     return farthest;
   }
 
   mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const xy_pos_t &pos, const bool probe_relative/*=false*/, MeshFlags *done_flags/*=nullptr*/) {
     mesh_index_pair closest;
     closest.invalidate();
     closest.distance = -99999.9f;
 
     // Get the reference position, either nozzle or probe
     const xy_pos_t ref = probe_relative ? pos + probe.offset_xy : pos;
 
     float best_so_far = 99999.99f;
 
-    for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
-      for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
-        if ( (type == (isnan(z_values[i][j]) ? INVALID : REAL))
-          || (type == SET_IN_BITMAP && !done_flags->marked(i, j))
-        ) {
-          // Found a Mesh Point of the specified type!
-          const xy_pos_t mpos = { mesh_index_to_xpos(i), mesh_index_to_ypos(j) };
+    GRID_LOOP(i, j) {
+      if ( (type == (isnan(z_values[i][j]) ? INVALID : REAL))
+        || (type == SET_IN_BITMAP && !done_flags->marked(i, j))
+      ) {
+        // Found a Mesh Point of the specified type!
+        const xy_pos_t mpos = { mesh_index_to_xpos(i), mesh_index_to_ypos(j) };
 
-          // If using the probe as the reference there are some unreachable locations.
-          // Also for round beds, there are grid points outside the bed the nozzle can't reach.
-          // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
+        // If using the probe as the reference there are some unreachable locations.
+        // Also for round beds, there are grid points outside the bed the nozzle can't reach.
+        // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
-          if (!(probe_relative ? probe.can_reach(mpos) : position_is_reachable(mpos)))
-            continue;
+        if (!(probe_relative ? probe.can_reach(mpos) : position_is_reachable(mpos)))
+          continue;
 
-          // Reachable. Check if it's the best_so_far location to the nozzle.
+        // Reachable. Check if it's the best_so_far location to the nozzle.
 
-          const xy_pos_t diff = current_position - mpos;
-          const float distance = (ref - mpos).magnitude() + diff.magnitude() * 0.1f;
+        const xy_pos_t diff = current_position - mpos;
+        const float distance = (ref - mpos).magnitude() + diff.magnitude() * 0.1f;
 
-          // factor in the distance from the current location for the normal case
-          // so the nozzle isn't running all over the bed.
-          if (distance < best_so_far) {
-            best_so_far = distance;   // Found a closer location with the desired value type.
-            closest.pos.set(i, j);
-            closest.distance = best_so_far;
-          }
+        // factor in the distance from the current location for the normal case
+        // so the nozzle isn't running all over the bed.
+        if (distance < best_so_far) {
+          best_so_far = distance;   // Found a closer location with the desired value type.
+          closest.pos.set(i, j);
+          closest.distance = best_so_far;
         }
-      } // for j
-    } // for i
+      }
+    } // GRID_LOOP
 
     return closest;
   }
 
   /**
    * 'Smart Fill': Scan from the outward edges of the mesh towards the center.
    * If an invalid location is found, use the next two points (if valid) to
    * calculate a 'reasonable' value for the unprobed mesh point.
    */
 
@@ -1366,21 +1350,21 @@
   typedef struct { uint8_t sx, ex, sy, ey; bool yfirst; } smart_fill_info;
 
   void unified_bed_leveling::smart_fill_mesh() {
     static const smart_fill_info
       info0 PROGMEM = { 0, GRID_MAX_POINTS_X,      0, GRID_MAX_POINTS_Y - 2,  false },  // Bottom of the mesh looking up
       info1 PROGMEM = { 0, GRID_MAX_POINTS_X,      GRID_MAX_POINTS_Y - 1, 0,  false },  // Top of the mesh looking down
       info2 PROGMEM = { 0, GRID_MAX_POINTS_X - 2,  0, GRID_MAX_POINTS_Y,      true  },  // Left side of the mesh looking right
       info3 PROGMEM = { GRID_MAX_POINTS_X - 1, 0,  0, GRID_MAX_POINTS_Y,      true  };  // Right side of the mesh looking left
     static const smart_fill_info * const info[] PROGMEM = { &info0, &info1, &info2, &info3 };
 
-    for (uint8_t i = 0; i < COUNT(info); ++i) {
+    LOOP_L_N(i, COUNT(info)) {
       const smart_fill_info *f = (smart_fill_info*)pgm_read_ptr(&info[i]);
       const int8_t sx = pgm_read_byte(&f->sx), sy = pgm_read_byte(&f->sy),
                    ex = pgm_read_byte(&f->ex), ey = pgm_read_byte(&f->ey);
       if (pgm_read_byte(&f->yfirst)) {
         const int8_t dir = ex > sx ? 1 : -1;
         for (uint8_t y = sy; y != ey; ++y)
           for (uint8_t x = sx; x != ex; x += dir)
             if (smart_fill_one(x, y, dir, 0)) break;
       }
       else {
@@ -1489,26 +1473,27 @@
 
         if (abort_flag) {
           SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");
           return;
         }
       }
       else { // !do_3_pt_leveling
 
         bool zig_zag = false;
 
-        uint16_t total_points = g29_grid_size * g29_grid_size, point_num = 1;
+        const uint16_t total_points = sq(g29_grid_size);
+        uint16_t point_num = 1;
 
         xy_pos_t rpos;
-        for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
+        LOOP_L_N(ix, g29_grid_size) {
           rpos.x = x_min + ix * dx;
-          for (int8_t iy = 0; iy < g29_grid_size; iy++) {
+          LOOP_L_N(iy, g29_grid_size) {
             rpos.y = y_min + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
 
             if (!abort_flag) {
               SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
               #if HAS_DISPLAY
                 ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points);
               #endif
 
               measured_z = probe.probe_at_point(rpos, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
 
@@ -1562,53 +1547,51 @@
         SERIAL_ECHOPAIR_F("bed plane normal = [", normal.x, 7);
         SERIAL_CHAR(',');
         SERIAL_ECHO_F(normal.y, 7);
         SERIAL_CHAR(',');
         SERIAL_ECHO_F(normal.z, 7);
         SERIAL_ECHOLNPGM("]");
       }
 
       matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
 
-      for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
-        for (uint8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
-          float mx = mesh_index_to_xpos(i),
-                my = mesh_index_to_ypos(j),
-                mz = z_values[i][j];
-
-          if (DEBUGGING(LEVELING)) {
-            DEBUG_ECHOPAIR_F("before rotation = [", mx, 7);
-            DEBUG_CHAR(',');
-            DEBUG_ECHO_F(my, 7);
-            DEBUG_CHAR(',');
-            DEBUG_ECHO_F(mz, 7);
-            DEBUG_ECHOPGM("]   ---> ");
-            DEBUG_DELAY(20);
-          }
+      GRID_LOOP(i, j) {
+        float mx = mesh_index_to_xpos(i),
+              my = mesh_index_to_ypos(j),
+              mz = z_values[i][j];
+
+        if (DEBUGGING(LEVELING)) {
+          DEBUG_ECHOPAIR_F("before rotation = [", mx, 7);
+          DEBUG_CHAR(',');
+          DEBUG_ECHO_F(my, 7);
+          DEBUG_CHAR(',');
+          DEBUG_ECHO_F(mz, 7);
+          DEBUG_ECHOPGM("]   ---> ");
+          DEBUG_DELAY(20);
+        }
 
-          apply_rotation_xyz(rotation, mx, my, mz);
+        apply_rotation_xyz(rotation, mx, my, mz);
 
-          if (DEBUGGING(LEVELING)) {
-            DEBUG_ECHOPAIR_F("after rotation = [", mx, 7);
-            DEBUG_CHAR(',');
-            DEBUG_ECHO_F(my, 7);
-            DEBUG_CHAR(',');
-            DEBUG_ECHO_F(mz, 7);
-            DEBUG_ECHOLNPGM("]");
-            DEBUG_DELAY(20);
-          }
-
-          z_values[i][j] = mz - lsf_results.D;
-          #if ENABLED(EXTENSIBLE_UI)
-            ExtUI::onMeshUpdate(i, j, z_values[i][j]);
-          #endif
+        if (DEBUGGING(LEVELING)) {
+          DEBUG_ECHOPAIR_F("after rotation = [", mx, 7);
+          DEBUG_CHAR(',');
+          DEBUG_ECHO_F(my, 7);
+          DEBUG_CHAR(',');
+          DEBUG_ECHO_F(mz, 7);
+          DEBUG_ECHOLNPGM("]");
+          DEBUG_DELAY(20);
         }
+
+        z_values[i][j] = mz - lsf_results.D;
+        #if ENABLED(EXTENSIBLE_UI)
+          ExtUI::onMeshUpdate(i, j, z_values[i][j]);
+        #endif
       }
 
       if (DEBUGGING(LEVELING)) {
         rotation.debug(PSTR("rotation matrix:\n"));
         DEBUG_ECHOPAIR_F("LSF Results A=", lsf_results.A, 7);
         DEBUG_ECHOPAIR_F("  B=", lsf_results.B, 7);
         DEBUG_ECHOLNPAIR_F("  D=", lsf_results.D, 7);
         DEBUG_DELAY(55);
 
         DEBUG_ECHOPAIR_F("bed plane normal = [", normal.x, 7);
@@ -1654,45 +1637,42 @@
   #endif // HAS_BED_PROBE
 
   #if ENABLED(UBL_G29_P31)
     void unified_bed_leveling::smart_fill_wlsf(const float &weight_factor) {
 
       // For each undefined mesh point, compute a distance-weighted least squares fit
       // from all the originally populated mesh points, weighted toward the point
       // being extrapolated so that nearby points will have greater influence on
       // the point being extrapolated.  Then extrapolate the mesh point from WLSF.
 
-      static_assert(GRID_MAX_POINTS_Y <= 16, "GRID_MAX_POINTS_Y too big");
+      static_assert((GRID_MAX_POINTS_Y) <= 16, "GRID_MAX_POINTS_Y too big");
       uint16_t bitmap[GRID_MAX_POINTS_X] = { 0 };
       struct linear_fit_data lsf_results;
 
       SERIAL_ECHOPGM("Extrapolating mesh...");
 
       const float weight_scaled = weight_factor * _MAX(MESH_X_DIST, MESH_Y_DIST);
 
-      for (uint8_t jx = 0; jx < GRID_MAX_POINTS_X; jx++)
-        for (uint8_t jy = 0; jy < GRID_MAX_POINTS_Y; jy++)
-          if (!isnan(z_values[jx][jy]))
-            SBI(bitmap[jx], jy);
+      GRID_LOOP(jx, jy) if (!isnan(z_values[jx][jy])) SBI(bitmap[jx], jy);
 
       xy_pos_t ppos;
-      for (uint8_t ix = 0; ix < GRID_MAX_POINTS_X; ix++) {
+      LOOP_L_N(ix, GRID_MAX_POINTS_X) {
         ppos.x = mesh_index_to_xpos(ix);
-        for (uint8_t iy = 0; iy < GRID_MAX_POINTS_Y; iy++) {
+        LOOP_L_N(iy, GRID_MAX_POINTS_Y) {
           ppos.y = mesh_index_to_ypos(iy);
           if (isnan(z_values[ix][iy])) {
             // undefined mesh point at (ppos.x,ppos.y), compute weighted LSF from original valid mesh points.
             incremental_LSF_reset(&lsf_results);
             xy_pos_t rpos;
-            for (uint8_t jx = 0; jx < GRID_MAX_POINTS_X; jx++) {
+            LOOP_L_N(jx, GRID_MAX_POINTS_X) {
               rpos.x = mesh_index_to_xpos(jx);
-              for (uint8_t jy = 0; jy < GRID_MAX_POINTS_Y; jy++) {
+              LOOP_L_N(jy, GRID_MAX_POINTS_Y) {
                 if (TEST(bitmap[jx], jy)) {
                   rpos.y = mesh_index_to_ypos(jy);
                   const float rz = z_values[jx][jy],
                                w = 1.0f + weight_scaled / (rpos - ppos).magnitude();
                   incremental_WLSF(&lsf_results, rpos, rz, w);
                 }
               }
             }
             if (finish_incremental_LSF(&lsf_results)) {
               SERIAL_ECHOLNPGM("Insufficient data");
@@ -1740,29 +1720,29 @@
       SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); serial_delay(50);
       SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             serial_delay(50);
       SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);             serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_X_DIST  ", MESH_X_DIST);
       SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);                         serial_delay(50);
 
       SERIAL_ECHOPGM("X-Axis Mesh Points at: ");
-      for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
+      LOOP_L_N(i, GRID_MAX_POINTS_X) {
         SERIAL_ECHO_F(LOGICAL_X_POSITION(mesh_index_to_xpos(i)), 3);
         SERIAL_ECHOPGM("  ");
         serial_delay(25);
       }
       SERIAL_EOL();
 
       SERIAL_ECHOPGM("Y-Axis Mesh Points at: ");
-      for (uint8_t i = 0; i < GRID_MAX_POINTS_Y; i++) {
+      LOOP_L_N(i, GRID_MAX_POINTS_Y) {
         SERIAL_ECHO_F(LOGICAL_Y_POSITION(mesh_index_to_ypos(i)), 3);
         SERIAL_ECHOPGM("  ");
         serial_delay(25);
       }
       SERIAL_EOL();
 
       #if HAS_KILL
         SERIAL_ECHOLNPAIR("Kill pin on :", int(KILL_PIN), "  state:", READ(KILL_PIN));
       #endif
       SERIAL_EOL();
@@ -1833,22 +1813,21 @@
         return;
       }
 
       g29_storage_slot = parser.value_int();
 
       float tmp_z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
       settings.load_mesh(g29_storage_slot, &tmp_z_values);
 
       SERIAL_ECHOLNPAIR("Subtracting mesh in slot ", g29_storage_slot, " from current mesh.");
 
-      for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
-        for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++) {
-          z_values[x][y] -= tmp_z_values[x][y];
-          #if ENABLED(EXTENSIBLE_UI)
-            ExtUI::onMeshUpdate(x, y, z_values[x][y]);
-          #endif
-        }
+      GRID_LOOP(x, y) {
+        z_values[x][y] -= tmp_z_values[x][y];
+        #if ENABLED(EXTENSIBLE_UI)
+          ExtUI::onMeshUpdate(x, y, z_values[x][y]);
+        #endif
+      }
     }
 
   #endif // UBL_DEVEL_DEBUGGING
 
 #endif // AUTO_BED_LEVELING_UBL

commit 6bead0c1b04152f6a291d851f6cd4029fe0fc616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 16:29:29 2020 -0500

    Shorter paths to HAL, ExtUI (#17156)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index fa82cccdac..3c18760ba0 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -39,21 +39,21 @@
   #include "../../../libs/least_squares_fit.h"
 
   #if HOTENDS > 1
     #include "../../../module/tool_change.h"
   #endif
 
   #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
   #include "../../../core/debug_out.h"
 
   #if ENABLED(EXTENSIBLE_UI)
-    #include "../../../lcd/extensible_ui/ui_api.h"
+    #include "../../../lcd/extui/ui_api.h"
   #endif
 
   #include <math.h>
 
   #define UBL_G29_P31
 
   #if HAS_LCD_MENU
     void _lcd_ubl_output_map_lcd();
   #endif
 

commit be62ab2d02f58634013a78a2e243a50c1cd4a1c4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 27 06:16:33 2020 -0600

    Move reachable test to Probe class

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index a0a12ea621..fa82cccdac 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1242,21 +1242,21 @@
     bool found_a_NAN = false, found_a_real = false;
 
     mesh_index_pair farthest { -1, -1, -99999.99 };
 
     for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
 
         if (isnan(z_values[i][j])) {                  // Invalid mesh point?
 
           // Skip points the probe can't reach
-          if (!position_is_reachable_by_probe(mesh_index_to_xpos(i), mesh_index_to_ypos(j)))
+          if (!probe.can_reach(mesh_index_to_xpos(i), mesh_index_to_ypos(j)))
             continue;
 
           found_a_NAN = true;
 
           xy_int8_t near { -1, -1 };
           float d1, d2 = 99999.9f;
           for (int8_t k = 0; k < GRID_MAX_POINTS_X; k++) {
             for (int8_t l = 0; l < GRID_MAX_POINTS_Y; l++) {
               if (!isnan(z_values[k][l])) {
                 found_a_real = true;
@@ -1309,21 +1309,21 @@
         if ( (type == (isnan(z_values[i][j]) ? INVALID : REAL))
           || (type == SET_IN_BITMAP && !done_flags->marked(i, j))
         ) {
           // Found a Mesh Point of the specified type!
           const xy_pos_t mpos = { mesh_index_to_xpos(i), mesh_index_to_ypos(j) };
 
           // If using the probe as the reference there are some unreachable locations.
           // Also for round beds, there are grid points outside the bed the nozzle can't reach.
           // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
-          if (probe_relative ? !position_is_reachable_by_probe(mpos) : !position_is_reachable(mpos))
+          if (!(probe_relative ? probe.can_reach(mpos) : position_is_reachable(mpos)))
             continue;
 
           // Reachable. Check if it's the best_so_far location to the nozzle.
 
           const xy_pos_t diff = current_position - mpos;
           const float distance = (ref - mpos).magnitude() + diff.magnitude() * 0.1f;
 
           // factor in the distance from the current location for the normal case
           // so the nozzle isn't running all over the bed.
           if (distance < best_so_far) {

commit 62d9e3f50e02d5c8e1f480bce14e9a8d3091f667
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Feb 3 21:58:44 2020 -0500

    Force T0 in UBL G29 on all multi-hotend setups (#16774)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 4bef0dd747..a0a12ea621 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -31,21 +31,21 @@
   #include "../../../libs/hex_print_routines.h"
   #include "../../../module/configuration_store.h"
   #include "../../../lcd/ultralcd.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
   #include "../../../module/motion.h"
   #include "../../../module/probe.h"
   #include "../../../gcode/gcode.h"
   #include "../../../libs/least_squares_fit.h"
 
-  #if ENABLED(DUAL_X_CARRIAGE)
+  #if HOTENDS > 1
     #include "../../../module/tool_change.h"
   #endif
 
   #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
   #include "../../../core/debug_out.h"
 
   #if ENABLED(EXTENSIBLE_UI)
     #include "../../../lcd/extensible_ui/ui_api.h"
   #endif
 
@@ -298,26 +298,29 @@
    *   features of all three systems combined.
    */
 
   void unified_bed_leveling::G29() {
 
     bool probe_deployed = false;
     if (g29_parameter_parsing()) return; // Abort on parameter error
 
     const int8_t p_val = parser.intval('P', -1);
     const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J');
+    #if HOTENDS > 1
+      const uint8_t old_tool_index = active_extruder;
+    #endif
 
     // Check for commands that require the printer to be homed
     if (may_move) {
       planner.synchronize();
       if (axes_need_homing()) gcode.home_all_axes();
-      #if ENABLED(DUAL_X_CARRIAGE)
+      #if HOTENDS > 1
         if (active_extruder != 0) tool_change(0);
       #endif
     }
 
     // Invalidate Mesh Points. This command is a little bit asymmetrical because
     // it directly specifies the repetition count and does not use the 'R' parameter.
     if (parser.seen('I')) {
       uint8_t cnt = 0;
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : 1;
       if (g29_repetition_cnt >= GRID_MAX_POINTS) {
@@ -677,20 +680,23 @@
     #ifdef Z_PROBE_END_SCRIPT
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
       if (probe_deployed) {
         planner.synchronize();
         gcode.process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
       }
     #else
       UNUSED(probe_deployed);
     #endif
 
+    #if HOTENDS > 1
+      tool_change(old_tool_index);
+    #endif
     return;
   }
 
   void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float value) {
     float sum = 0;
     int n = 0;
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
         if (!isnan(z_values[x][y])) {
           sum += z_values[x][y];

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 693a4b9b23..4bef0dd747 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 90b6324563b806ea7dc24ddf299f055dc4854341
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 04:21:36 2020 -0600

    Encapsulate probe as singleton class (#16751)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index c8f3b45b0d..693a4b9b23 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -443,21 +443,21 @@
             if (!parser.seen('C')) {
               invalidate();
               SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
             }
             if (g29_verbose_level > 1) {
               SERIAL_ECHOPAIR("Probing around (", g29_pos.x);
               SERIAL_CHAR(',');
               SERIAL_ECHO(g29_pos.y);
               SERIAL_ECHOLNPGM(").\n");
             }
-            const xy_pos_t near = g29_pos + probe_offset_xy;
+            const xy_pos_t near = g29_pos + probe.offset_xy;
             probe_entire_mesh(near, parser.seen('T'), parser.seen('E'), parser.seen('U'));
 
             report_current_position();
             probe_deployed = true;
           } break;
 
         #endif // HAS_BED_PROBE
 
         case 2: {
           #if HAS_LCD_MENU
@@ -473,22 +473,22 @@
                * Use a good default location for the path.
                * The flipped > and < operators in these comparisons is intentional.
                * It should cause the probed points to follow a nice path on Cartesian printers.
                * It may make sense to have Delta printers default to the center of the bed.
                * Until that is decided, this can be forced with the X and Y parameters.
                */
               g29_pos.set(
                 #if IS_KINEMATIC
                   X_HOME_POS, Y_HOME_POS
                 #else
-                  probe_offset_xy.x > 0 ? X_BED_SIZE : 0,
-                  probe_offset_xy.y < 0 ? Y_BED_SIZE : 0
+                  probe.offset_xy.x > 0 ? X_BED_SIZE : 0,
+                  probe.offset_xy.y < 0 ? Y_BED_SIZE : 0
                 #endif
               );
             }
 
             if (parser.seen('B')) {
               g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness((float) Z_CLEARANCE_BETWEEN_PROBES);
               if (ABS(g29_card_thickness) > 1.5f) {
                 SERIAL_ECHOLNPGM("?Error in Business Card measurement.");
                 return;
               }
@@ -735,21 +735,21 @@
           #endif
         }
   }
 
   #if HAS_BED_PROBE
     /**
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
     void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &near, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
-      DEPLOY_PROBE(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
+      probe.deploy(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
 
       #if HAS_LCD_MENU
         ui.capture();
       #endif
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       uint8_t count = GRID_MAX_POINTS;
 
       mesh_index_pair best;
       do {
@@ -761,60 +761,60 @@
           ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), point_num, int(GRID_MAX_POINTS));
         #endif
 
         #if HAS_LCD_MENU
           if (ui.button_pressed()) {
             ui.quick_feedback(false); // Preserve button state for click-and-hold
             SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
             ui.wait_for_release();
             ui.quick_feedback();
             ui.release();
-            STOW_PROBE(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
+            probe.stow(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
             return restore_ubl_active_state_and_leave();
           }
         #endif
 
         best = do_furthest
           ? find_furthest_invalid_mesh_point()
           : find_closest_mesh_point_of_type(INVALID, near, true);
 
         if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
-          const float measured_z = probe_at_point(
+          const float measured_z = probe.probe_at_point(
                         best.meshpos(),
                         stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level
                       );
           z_values[best.pos.x][best.pos.y] = measured_z;
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(best.pos, measured_z);
           #endif
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
 
       } while (best.pos.x >= 0 && --count);
 
       #if HAS_LCD_MENU
         ui.release();
       #endif
-      STOW_PROBE(); // Release UI during stow to allow for PAUSE_BEFORE_DEPLOY_STOW
+      probe.stow(); // Release UI during stow to allow for PAUSE_BEFORE_DEPLOY_STOW
       #if HAS_LCD_MENU
         ui.capture();
       #endif
 
       #ifdef Z_AFTER_PROBING
-        move_z_after_probing();
+        probe.move_z_after_probing();
       #endif
 
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
-        constrain(near.x - probe_offset_xy.x, MESH_MIN_X, MESH_MAX_X),
-        constrain(near.y - probe_offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
+        constrain(near.x - probe.offset_xy.x, MESH_MIN_X, MESH_MAX_X),
+        constrain(near.y - probe.offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 
   #endif // HAS_BED_PROBE
 
   #if HAS_LCD_MENU
 
     typedef void (*clickFunc_t)();
 
     bool click_and_hold(const clickFunc_t func=nullptr) {
@@ -900,21 +900,21 @@
       #if HAS_LCD_MENU
         ui.capture();
       #endif
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       do_blocking_move_to_xy_z(current_position, z_clearance);
 
       ui.return_to_status();
 
       mesh_index_pair location;
-      xy_int8_t &lpos = location.pos;
+      const xy_int8_t &lpos = location.pos;
       do {
         location = find_closest_mesh_point_of_type(INVALID, pos);
         // It doesn't matter if the probe can't reach the NAN location. This is a manual probe.
         if (!location.valid()) continue;
 
         const xyz_pos_t ppos = {
           mesh_index_to_xpos(lpos.x),
           mesh_index_to_ypos(lpos.y),
           Z_CLEARANCE_BETWEEN_PROBES
         };
@@ -999,21 +999,21 @@
       #if HAS_LCD_MENU
         ui.capture();                                         // Take over control of the LCD encoder
       #endif
       do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES); // Move to the given XY with probe clearance
 
       #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
         do_blocking_move_to_z(h_offset);                    // Move Z to the given 'H' offset
       #endif
 
       MeshFlags done_flags{0};
-      xy_int8_t &lpos = location.pos;
+      const xy_int8_t &lpos = location.pos;
       do {
         location = find_closest_mesh_point_of_type(SET_IN_BITMAP, pos, false, &done_flags);
 
         if (lpos.x < 0) break;                              // Stop when there are no more reachable points
 
         done_flags.mark(lpos);                              // Mark this location as 'adjusted' so a new
                                                             // location is used on the next loop
         const xyz_pos_t raw = {
           mesh_index_to_xpos(lpos.x),
           mesh_index_to_ypos(lpos.y),
@@ -1287,21 +1287,21 @@
     }
     return farthest;
   }
 
   mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const xy_pos_t &pos, const bool probe_relative/*=false*/, MeshFlags *done_flags/*=nullptr*/) {
     mesh_index_pair closest;
     closest.invalidate();
     closest.distance = -99999.9f;
 
     // Get the reference position, either nozzle or probe
-    const xy_pos_t ref = probe_relative ? pos + probe_offset_xy : pos;
+    const xy_pos_t ref = probe_relative ? pos + probe.offset_xy : pos;
 
     float best_so_far = 99999.99f;
 
     for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
         if ( (type == (isnan(z_values[i][j]) ? INVALID : REAL))
           || (type == SET_IN_BITMAP && !done_flags->marked(i, j))
         ) {
           // Found a Mesh Point of the specified type!
           const xy_pos_t mpos = { mesh_index_to_xpos(i), mesh_index_to_ypos(j) };
@@ -1386,66 +1386,66 @@
     }
   }
 
   #if HAS_BED_PROBE
 
     //#define VALIDATE_MESH_TILT
 
     #include "../../../libs/vector_3.h"
 
     void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
-      const float x_min = probe_min_x(), x_max = probe_max_x(),
-                  y_min = probe_min_y(), y_max = probe_max_y(),
+      const float x_min = probe.min_x(), x_max = probe.max_x(),
+                  y_min = probe.min_y(), y_max = probe.max_y(),
                   dx = (x_max - x_min) / (g29_grid_size - 1),
                   dy = (y_max - y_min) / (g29_grid_size - 1);
 
       xy_float_t points[3];
-      get_three_probe_points(points);
+      probe.get_three_points(points);
 
       float measured_z;
       bool abort_flag = false;
 
       #ifdef VALIDATE_MESH_TILT
         float z1, z2, z3;  // Needed for algorithm validation below
       #endif
 
       struct linear_fit_data lsf_results;
       incremental_LSF_reset(&lsf_results);
 
       if (do_3_pt_leveling) {
         SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
         #if HAS_DISPLAY
           ui.status_printf_P(0, PSTR(S_FMT " 1/3"), GET_TEXT(MSG_LCD_TILTING_MESH));
         #endif
 
-        measured_z = probe_at_point(points[0], PROBE_PT_RAISE, g29_verbose_level);
+        measured_z = probe.probe_at_point(points[0], PROBE_PT_RAISE, g29_verbose_level);
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[0]);
           #ifdef VALIDATE_MESH_TILT
             z1 = measured_z;
           #endif
           if (g29_verbose_level > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, points[0], measured_z);
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
           #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(S_FMT " 2/3"), GET_TEXT(MSG_LCD_TILTING_MESH));
           #endif
 
-          measured_z = probe_at_point(points[1], PROBE_PT_RAISE, g29_verbose_level);
+          measured_z = probe.probe_at_point(points[1], PROBE_PT_RAISE, g29_verbose_level);
           #ifdef VALIDATE_MESH_TILT
             z2 = measured_z;
           #endif
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(points[1]);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
@@ -1453,39 +1453,39 @@
             incremental_LSF(&lsf_results, points[1], measured_z);
           }
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
           #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH));
           #endif
 
-          measured_z = probe_at_point(points[2], PROBE_PT_STOW, g29_verbose_level);
+          measured_z = probe.probe_at_point(points[2], PROBE_PT_STOW, g29_verbose_level);
           #ifdef VALIDATE_MESH_TILT
             z3 = measured_z;
           #endif
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(points[2]);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, points[2], measured_z);
           }
         }
 
-        STOW_PROBE();
+        probe.stow();
         #ifdef Z_AFTER_PROBING
-          move_z_after_probing();
+          probe.move_z_after_probing();
         #endif
 
         if (abort_flag) {
           SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");
           return;
         }
       }
       else { // !do_3_pt_leveling
 
         bool zig_zag = false;
@@ -1497,59 +1497,59 @@
           rpos.x = x_min + ix * dx;
           for (int8_t iy = 0; iy < g29_grid_size; iy++) {
             rpos.y = y_min + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
 
             if (!abort_flag) {
               SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
               #if HAS_DISPLAY
                 ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points);
               #endif
 
-              measured_z = probe_at_point(rpos, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
+              measured_z = probe.probe_at_point(rpos, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
 
               abort_flag = isnan(measured_z);
 
               #if ENABLED(DEBUG_LEVELING_FEATURE)
                 if (DEBUGGING(LEVELING)) {
                   const xy_pos_t lpos = rpos.asLogical();
                   DEBUG_CHAR('(');
                   DEBUG_ECHO_F(rpos.x, 7);
                   DEBUG_CHAR(',');
                   DEBUG_ECHO_F(rpos.y, 7);
                   DEBUG_ECHOPAIR_F(")   logical: (", lpos.x, 7);
                   DEBUG_CHAR(',');
                   DEBUG_ECHO_F(lpos.y, 7);
                   DEBUG_ECHOPAIR_F(")   measured: ", measured_z, 7);
                   DEBUG_ECHOPAIR_F("   correction: ", get_z_correction(rpos), 7);
                 }
               #endif
 
-              measured_z -= get_z_correction(rpos) /* + probe_offset.z */ ;
+              measured_z -= get_z_correction(rpos) /* + probe.offset.z */ ;
 
               if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("   final >>>---> ", measured_z, 7);
 
               if (g29_verbose_level > 3) {
                 serial_spaces(16);
                 SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
               }
               incremental_LSF(&lsf_results, rpos, measured_z);
             }
 
             point_num++;
           }
 
           zig_zag ^= true;
         }
       }
-      STOW_PROBE();
+      probe.stow();
       #ifdef Z_AFTER_PROBING
-        move_z_after_probing();
+        probe.move_z_after_probing();
       #endif
 
       if (abort_flag || finish_incremental_LSF(&lsf_results)) {
         SERIAL_ECHOPGM("Could not complete LSF!");
         return;
       }
 
       vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1).get_normal();
 
       if (g29_verbose_level > 2) {
@@ -1721,21 +1721,21 @@
       SERIAL_EOL();
       serial_delay(50);
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         SERIAL_ECHOLNPAIR_F("Fade Height M420 Z", planner.z_fade_height, 4);
       #endif
 
       adjust_mesh_to_mean(g29_c_flag, g29_constant);
 
       #if HAS_BED_PROBE
-        SERIAL_ECHOLNPAIR_F("Probe Offset M851 Z", probe_offset.z, 7);
+        SERIAL_ECHOLNPAIR_F("Probe Offset M851 Z", probe.offset.z, 7);
       #endif
 
       SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); serial_delay(50);
       SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             serial_delay(50);
       SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);             serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_X_DIST  ", MESH_X_DIST);
       SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);                         serial_delay(50);

commit e64b7a3ab27dd1f0dc56e227b42295e5c931df62
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 1 00:57:14 2020 -0600

    Clean up i2c encoder, sanitize serial

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 203d7c7150..c8f3b45b0d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1622,30 +1622,30 @@
          * numbers for those locations should be 0.
          */
         #ifdef VALIDATE_MESH_TILT
           auto d_from = []() { DEBUG_ECHOPGM("D from "); };
           auto normed = [&](const xy_pos_t &pos, const float &zadd) {
             return normal.x * pos.x + normal.y * pos.y + zadd;
           };
           auto debug_pt = [](PGM_P const pre, const xy_pos_t &pos, const float &zadd) {
             d_from(); serialprintPGM(pre);
             DEBUG_ECHO_F(normed(pos, zadd), 6);
-            DEBUG_ECHOLNPAIR_F("   Z error: ", zadd - get_z_correction(pos), 6);
+            DEBUG_ECHOLNPAIR_F("   Z error = ", zadd - get_z_correction(pos), 6);
           };
           debug_pt(PSTR("1st point: "), probe_pt[0], normal.z * z1);
           debug_pt(PSTR("2nd point: "), probe_pt[1], normal.z * z2);
           debug_pt(PSTR("3rd point: "), probe_pt[2], normal.z * z3);
           d_from(); DEBUG_ECHOPGM("safe home with Z=");
           DEBUG_ECHOLNPAIR_F("0 : ", normed(safe_homing_xy, 0), 6);
           d_from(); DEBUG_ECHOPGM("safe home with Z=");
           DEBUG_ECHOLNPAIR_F("mesh value ", normed(safe_homing_xy, get_z_correction(safe_homing_xy)), 6);
-          DEBUG_ECHOPAIR("   Z error: (", Z_SAFE_HOMING_X_POINT, ",", Z_SAFE_HOMING_Y_POINT);
+          DEBUG_ECHOPAIR("   Z error = (", Z_SAFE_HOMING_X_POINT, ",", Z_SAFE_HOMING_Y_POINT);
           DEBUG_ECHOLNPAIR_F(") = ", get_z_correction(safe_homing_xy), 6);
         #endif
       } // DEBUGGING(LEVELING)
 
     }
 
   #endif // HAS_BED_PROBE
 
   #if ENABLED(UBL_G29_P31)
     void unified_bed_leveling::smart_fill_wlsf(const float &weight_factor) {

commit 3cade6245e851af9a33d1f395758b898c4a06a30
Author: Jason Smith <jason.inet@gmail.com>
Date:   Fri Jan 3 17:46:26 2020 -0600

    Fix MIN_PROBE_EDGE bug in default ABL G29 (#16367)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index ba494aefc5..203d7c7150 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -443,51 +443,52 @@
             if (!parser.seen('C')) {
               invalidate();
               SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
             }
             if (g29_verbose_level > 1) {
               SERIAL_ECHOPAIR("Probing around (", g29_pos.x);
               SERIAL_CHAR(',');
               SERIAL_ECHO(g29_pos.y);
               SERIAL_ECHOLNPGM(").\n");
             }
-            const xy_pos_t near = g29_pos + probe_offset;
+            const xy_pos_t near = g29_pos + probe_offset_xy;
             probe_entire_mesh(near, parser.seen('T'), parser.seen('E'), parser.seen('U'));
 
             report_current_position();
             probe_deployed = true;
           } break;
 
         #endif // HAS_BED_PROBE
 
         case 2: {
           #if HAS_LCD_MENU
             //
             // Manually Probe Mesh in areas that can't be reached by the probe
             //
             SERIAL_ECHOLNPGM("Manually probing unreachable mesh locations.");
             do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
 
             if (parser.seen('C') && !xy_seen) {
+
               /**
                * Use a good default location for the path.
                * The flipped > and < operators in these comparisons is intentional.
                * It should cause the probed points to follow a nice path on Cartesian printers.
                * It may make sense to have Delta printers default to the center of the bed.
                * Until that is decided, this can be forced with the X and Y parameters.
                */
               g29_pos.set(
                 #if IS_KINEMATIC
                   X_HOME_POS, Y_HOME_POS
                 #else
-                  probe_offset.x > 0 ? X_BED_SIZE : 0,
-                  probe_offset.y < 0 ? Y_BED_SIZE : 0
+                  probe_offset_xy.x > 0 ? X_BED_SIZE : 0,
+                  probe_offset_xy.y < 0 ? Y_BED_SIZE : 0
                 #endif
               );
             }
 
             if (parser.seen('B')) {
               g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness((float) Z_CLEARANCE_BETWEEN_PROBES);
               if (ABS(g29_card_thickness) > 1.5f) {
                 SERIAL_ECHOLNPGM("?Error in Business Card measurement.");
                 return;
               }
@@ -798,22 +799,22 @@
         ui.capture();
       #endif
 
       #ifdef Z_AFTER_PROBING
         move_z_after_probing();
       #endif
 
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
-        constrain(near.x - probe_offset.x, MESH_MIN_X, MESH_MAX_X),
-        constrain(near.y - probe_offset.y, MESH_MIN_Y, MESH_MAX_Y)
+        constrain(near.x - probe_offset_xy.x, MESH_MIN_X, MESH_MAX_X),
+        constrain(near.y - probe_offset_xy.y, MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 
   #endif // HAS_BED_PROBE
 
   #if HAS_LCD_MENU
 
     typedef void (*clickFunc_t)();
 
     bool click_and_hold(const clickFunc_t func=nullptr) {
@@ -1286,21 +1287,21 @@
     }
     return farthest;
   }
 
   mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const xy_pos_t &pos, const bool probe_relative/*=false*/, MeshFlags *done_flags/*=nullptr*/) {
     mesh_index_pair closest;
     closest.invalidate();
     closest.distance = -99999.9f;
 
     // Get the reference position, either nozzle or probe
-    const xy_pos_t ref = probe_relative ? pos + probe_offset : pos;
+    const xy_pos_t ref = probe_relative ? pos + probe_offset_xy : pos;
 
     float best_so_far = 99999.99f;
 
     for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
         if ( (type == (isnan(z_values[i][j]) ? INVALID : REAL))
           || (type == SET_IN_BITMAP && !done_flags->marked(i, j))
         ) {
           // Found a Mesh Point of the specified type!
           const xy_pos_t mpos = { mesh_index_to_xpos(i), mesh_index_to_ypos(j) };

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 8b2e046e45..ba494aefc5 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -19,21 +19,21 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
   #include "../bedlevel.h"
 
-  #include "../../../Marlin.h"
+  #include "../../../MarlinCore.h"
   #include "../../../HAL/shared/persistent_store_api.h"
   #include "../../../libs/hex_print_routines.h"
   #include "../../../module/configuration_store.h"
   #include "../../../lcd/ultralcd.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
   #include "../../../module/motion.h"
   #include "../../../module/probe.h"
   #include "../../../gcode/gcode.h"
   #include "../../../libs/least_squares_fit.h"

commit 2142beb2e5f87bea0f861413f6ef729d3e0d5c84
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Nov 24 18:04:19 2019 -0500

    Fix UI compile error in UBL (#15981)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index fefc65756e..8b2e046e45 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -783,23 +783,27 @@
                       );
           z_values[best.pos.x][best.pos.y] = measured_z;
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(best.pos, measured_z);
           #endif
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
 
       } while (best.pos.x >= 0 && --count);
 
-      ui.release();
+      #if HAS_LCD_MENU
+        ui.release();
+      #endif
       STOW_PROBE(); // Release UI during stow to allow for PAUSE_BEFORE_DEPLOY_STOW
-      ui.capture();
+      #if HAS_LCD_MENU
+        ui.capture();
+      #endif
 
       #ifdef Z_AFTER_PROBING
         move_z_after_probing();
       #endif
 
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
         constrain(near.x - probe_offset.x, MESH_MIN_X, MESH_MAX_X),
         constrain(near.y - probe_offset.y, MESH_MIN_Y, MESH_MAX_Y)
@@ -844,21 +848,23 @@
 
     float unified_bed_leveling::measure_point_with_encoder() {
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       move_z_with_encoder(0.01f);
       return current_position.z;
     }
 
     static void echo_and_take_a_measurement() { SERIAL_ECHOLNPGM(" and take a measurement."); }
 
     float unified_bed_leveling::measure_business_card_thickness(float in_height) {
-      ui.capture();
+      #if HAS_LCD_MENU
+        ui.capture();
+      #endif
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
       do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
         //, _MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f);
       planner.synchronize();
 
       SERIAL_ECHOPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       ui.return_to_status();
       echo_and_take_a_measurement();
@@ -883,22 +889,23 @@
       }
 
       ui.release();
 
       restore_ubl_active_state_and_leave();
 
       return thickness;
     }
 
     void unified_bed_leveling::manually_probe_remaining_mesh(const xy_pos_t &pos, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
-
-      ui.capture();
+      #if HAS_LCD_MENU
+        ui.capture();
+      #endif
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       do_blocking_move_to_xy_z(current_position, z_clearance);
 
       ui.return_to_status();
 
       mesh_index_pair location;
       xy_int8_t &lpos = location.pos;
       do {
         location = find_closest_mesh_point_of_type(INVALID, pos);
@@ -912,21 +919,23 @@
         };
 
         if (!position_is_reachable(ppos)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
 
         LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
 
         do_blocking_move_to(ppos);
         do_blocking_move_to_z(z_clearance);
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
-        ui.capture();
+        #if HAS_LCD_MENU
+          ui.capture();
+        #endif
 
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
         serialprintPGM(parser.seen('B') ? GET_TEXT(MSG_UBL_BC_INSERT) : GET_TEXT(MSG_UBL_BC_INSERT2));
 
         const float z_step = 0.01f;                         // existing behavior: 0.01mm per click, occasionally step
         //const float z_step = planner.steps_to_mm[Z_AXIS]; // approx one step each click
 
         move_z_with_encoder(z_step);
 
@@ -979,22 +988,23 @@
       mesh_index_pair location;
 
       if (!position_is_reachable(pos)) {
         SERIAL_ECHOLNPGM("(X,Y) outside printable radius.");
         return;
       }
 
       save_ubl_active_state_and_disable();
 
       LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
-      ui.capture();                                         // Take over control of the LCD encoder
-
+      #if HAS_LCD_MENU
+        ui.capture();                                         // Take over control of the LCD encoder
+      #endif
       do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES); // Move to the given XY with probe clearance
 
       #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
         do_blocking_move_to_z(h_offset);                    // Move Z to the given 'H' offset
       #endif
 
       MeshFlags done_flags{0};
       xy_int8_t &lpos = location.pos;
       do {
         location = find_closest_mesh_point_of_type(SET_IN_BITMAP, pos, false, &done_flags);

commit b904ba0f291cdcb9759464f064f85ba066b778ce
Author: Jason Smith <jason.inet@gmail.com>
Date:   Thu Nov 21 01:26:00 2019 -0800

    Improve Delta probing / calibration (#15887)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 72b67e65bd..fefc65756e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1380,31 +1380,22 @@
     //#define VALIDATE_MESH_TILT
 
     #include "../../../libs/vector_3.h"
 
     void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
       const float x_min = probe_min_x(), x_max = probe_max_x(),
                   y_min = probe_min_y(), y_max = probe_max_y(),
                   dx = (x_max - x_min) / (g29_grid_size - 1),
                   dy = (y_max - y_min) / (g29_grid_size - 1);
 
-      const vector_3 points[3] = {
-        #if ENABLED(HAS_FIXED_3POINT)
-          { PROBE_PT_1_X, PROBE_PT_1_Y, 0 },
-          { PROBE_PT_2_X, PROBE_PT_2_Y, 0 },
-          { PROBE_PT_3_X, PROBE_PT_3_Y, 0 }
-        #else
-          { x_min, y_min, 0 },
-          { x_max, y_min, 0 },
-          { (x_max - x_min) / 2, y_max, 0 }
-        #endif
-      };
+      xy_float_t points[3];
+      get_three_probe_points(points);
 
       float measured_z;
       bool abort_flag = false;
 
       #ifdef VALIDATE_MESH_TILT
         float z1, z2, z3;  // Needed for algorithm validation below
       #endif
 
       struct linear_fit_data lsf_results;
       incremental_LSF_reset(&lsf_results);

commit 9906e96ffb3d1376ad5981f47dd1c02477502a1e
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Nov 19 21:26:38 2019 -0800

    Allow UBL G29 J1 with PAUSE_BEFORE_DEPLOY_STOW (#15934)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 57256b9071..72b67e65bd 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -734,47 +734,47 @@
           #endif
         }
   }
 
   #if HAS_BED_PROBE
     /**
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
     void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &near, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
+      DEPLOY_PROBE(); // Deploy before ui.capture() to allow for PAUSE_BEFORE_DEPLOY_STOW
+
       #if HAS_LCD_MENU
         ui.capture();
       #endif
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
-      DEPLOY_PROBE();
-
       uint8_t count = GRID_MAX_POINTS;
 
       mesh_index_pair best;
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
         const int point_num = (GRID_MAX_POINTS) - count + 1;
         SERIAL_ECHOLNPAIR("\nProbing mesh point ", point_num, "/", int(GRID_MAX_POINTS), ".\n");
         #if HAS_DISPLAY
           ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), point_num, int(GRID_MAX_POINTS));
         #endif
 
         #if HAS_LCD_MENU
           if (ui.button_pressed()) {
             ui.quick_feedback(false); // Preserve button state for click-and-hold
             SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
-            STOW_PROBE();
             ui.wait_for_release();
             ui.quick_feedback();
             ui.release();
+            STOW_PROBE(); // Release UI before stow to allow for PAUSE_BEFORE_DEPLOY_STOW
             return restore_ubl_active_state_and_leave();
           }
         #endif
 
         best = do_furthest
           ? find_furthest_invalid_mesh_point()
           : find_closest_mesh_point_of_type(INVALID, near, true);
 
         if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
           const float measured_z = probe_at_point(
@@ -783,21 +783,23 @@
                       );
           z_values[best.pos.x][best.pos.y] = measured_z;
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(best.pos, measured_z);
           #endif
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
 
       } while (best.pos.x >= 0 && --count);
 
-      STOW_PROBE();
+      ui.release();
+      STOW_PROBE(); // Release UI during stow to allow for PAUSE_BEFORE_DEPLOY_STOW
+      ui.capture();
 
       #ifdef Z_AFTER_PROBING
         move_z_after_probing();
       #endif
 
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
         constrain(near.x - probe_offset.x, MESH_MIN_X, MESH_MAX_X),
         constrain(near.y - probe_offset.y, MESH_MIN_Y, MESH_MAX_Y)
@@ -1497,32 +1499,34 @@
             if (!abort_flag) {
               SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
               #if HAS_DISPLAY
                 ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points);
               #endif
 
               measured_z = probe_at_point(rpos, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
 
               abort_flag = isnan(measured_z);
 
-              if (DEBUGGING(LEVELING)) {
-                const xy_pos_t lpos = rpos.asLogical();
-                DEBUG_CHAR('(');
-                DEBUG_ECHO_F(rpos.x, 7);
-                DEBUG_CHAR(',');
-                DEBUG_ECHO_F(rpos.y, 7);
-                DEBUG_ECHOPAIR_F(")   logical: (", lpos.x, 7);
-                DEBUG_CHAR(',');
-                DEBUG_ECHO_F(lpos.y, 7);
-                DEBUG_ECHOPAIR_F(")   measured: ", measured_z, 7);
-                DEBUG_ECHOPAIR_F("   correction: ", get_z_correction(rpos), 7);
-              }
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                if (DEBUGGING(LEVELING)) {
+                  const xy_pos_t lpos = rpos.asLogical();
+                  DEBUG_CHAR('(');
+                  DEBUG_ECHO_F(rpos.x, 7);
+                  DEBUG_CHAR(',');
+                  DEBUG_ECHO_F(rpos.y, 7);
+                  DEBUG_ECHOPAIR_F(")   logical: (", lpos.x, 7);
+                  DEBUG_CHAR(',');
+                  DEBUG_ECHO_F(lpos.y, 7);
+                  DEBUG_ECHOPAIR_F(")   measured: ", measured_z, 7);
+                  DEBUG_ECHOPAIR_F("   correction: ", get_z_correction(rpos), 7);
+                }
+              #endif
 
               measured_z -= get_z_correction(rpos) /* + probe_offset.z */ ;
 
               if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("   final >>>---> ", measured_z, 7);
 
               if (g29_verbose_level > 3) {
                 serial_spaces(16);
                 SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
               }
               incremental_LSF(&lsf_results, rpos, measured_z);

commit cc4d3a215ea57007a846d9ea760dcb06a8a5b958
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Oct 28 16:50:27 2019 -0400

    Fix ExtUI UBL method calls (#15704)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 69c3d2d997..57256b9071 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -331,21 +331,21 @@
           if (cpos.x < 0) {
             // No more REAL mesh points to invalidate, so we ASSUME the user
             // meant to invalidate the ENTIRE mesh, which cannot be done with
             // find_closest_mesh_point loop which only returns REAL points.
             set_all_mesh_points_to_value(NAN);
             SERIAL_ECHOLNPGM("Entire Mesh invalidated.\n");
             break;            // No more invalid Mesh Points to populate
           }
           z_values[cpos.x][cpos.y] = NAN;
           #if ENABLED(EXTENSIBLE_UI)
-            ExtUI::onMeshUpdate(closest, 0);
+            ExtUI::onMeshUpdate(cpos, 0.0f);
           #endif
           cnt++;
         }
       }
       SERIAL_ECHOLNPGM("Locations invalidated.\n");
     }
 
     if (parser.seen('Q')) {
       const int test_pattern = parser.has_value() ? parser.value_int() : -99;
       if (!WITHIN(test_pattern, -1, 2)) {
@@ -534,21 +534,21 @@
                   // No more REAL INVALID mesh points to populate, so we ASSUME
                   // user meant to populate ALL INVALID mesh points to value
                   for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
                     for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
                       if (isnan(z_values[x][y])) z_values[x][y] = g29_constant;
                   break; // No more invalid Mesh Points to populate
                 }
                 else {
                   z_values[cpos.x][cpos.y] = g29_constant;
                   #if ENABLED(EXTENSIBLE_UI)
-                    ExtUI::onMeshUpdate(closest, g29_constant);
+                    ExtUI::onMeshUpdate(cpos, g29_constant);
                   #endif
                 }
               }
             }
           }
           else {
             const float cvf = parser.value_float();
             switch ((int)truncf(cvf * 10.0f) - 30) {   // 3.1 -> 1
               #if ENABLED(UBL_G29_P31)
                 case 1: {
@@ -776,21 +776,21 @@
           ? find_furthest_invalid_mesh_point()
           : find_closest_mesh_point_of_type(INVALID, near, true);
 
         if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
           const float measured_z = probe_at_point(
                         best.meshpos(),
                         stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level
                       );
           z_values[best.pos.x][best.pos.y] = measured_z;
           #if ENABLED(EXTENSIBLE_UI)
-            ExtUI::onMeshUpdate(best, measured_z);
+            ExtUI::onMeshUpdate(best.pos, measured_z);
           #endif
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
 
       } while (best.pos.x >= 0 && --count);
 
       STOW_PROBE();
 
       #ifdef Z_AFTER_PROBING
         move_z_after_probing();
@@ -1328,21 +1328,21 @@
   bool unified_bed_leveling::smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
     const float v = z_values[x][y];
     if (isnan(v)) {                           // A NAN...
       const int8_t dx = x + xdir, dy = y + ydir;
       const float v1 = z_values[dx][dy];
       if (!isnan(v1)) {                       // ...next to a pair of real values?
         const float v2 = z_values[dx + xdir][dy + ydir];
         if (!isnan(v2)) {
           z_values[x][y] = v1 < v2 ? v1 : v1 + v1 - v2;
           #if ENABLED(EXTENSIBLE_UI)
-            ExtUI::onMeshUpdate(x, y, z_values[pos.x][pos.y]);
+            ExtUI::onMeshUpdate(x, y, z_values[x][y]);
           #endif
           return true;
         }
       }
     }
     return false;
   }
 
   typedef struct { uint8_t sx, ex, sy, ey; bool yfirst; } smart_fill_info;
 

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index d016667e44..69c3d2d997 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -750,21 +750,21 @@
 
       uint8_t count = GRID_MAX_POINTS;
 
       mesh_index_pair best;
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
         const int point_num = (GRID_MAX_POINTS) - count + 1;
         SERIAL_ECHOLNPAIR("\nProbing mesh point ", point_num, "/", int(GRID_MAX_POINTS), ".\n");
         #if HAS_DISPLAY
-          ui.status_printf_P(0, PSTR(MSG_PROBING_MESH " %i/%i"), point_num, int(GRID_MAX_POINTS));
+          ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_PROBING_MESH), point_num, int(GRID_MAX_POINTS));
         #endif
 
         #if HAS_LCD_MENU
           if (ui.button_pressed()) {
             ui.quick_feedback(false); // Preserve button state for click-and-hold
             SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
             STOW_PROBE();
             ui.wait_for_release();
             ui.quick_feedback();
             ui.release();
@@ -914,21 +914,21 @@
         LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
 
         do_blocking_move_to(ppos);
         do_blocking_move_to_z(z_clearance);
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         ui.capture();
 
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
-        serialprintPGM(parser.seen('B') ? PSTR(MSG_UBL_BC_INSERT) : PSTR(MSG_UBL_BC_INSERT2));
+        serialprintPGM(parser.seen('B') ? GET_TEXT(MSG_UBL_BC_INSERT) : GET_TEXT(MSG_UBL_BC_INSERT2));
 
         const float z_step = 0.01f;                         // existing behavior: 0.01mm per click, occasionally step
         //const float z_step = planner.steps_to_mm[Z_AXIS]; // approx one step each click
 
         move_z_with_encoder(z_step);
 
         if (click_and_hold()) {
           SERIAL_ECHOLNPGM("\nMesh only partially populated.");
           do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
           ui.release();
@@ -952,21 +952,21 @@
     }
 
     inline void set_message_with_feedback(PGM_P const msg_P) {
       ui.set_status_P(msg_P);
       ui.quick_feedback();
     }
 
     void abort_fine_tune() {
       ui.return_to_status();
       do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
-      set_message_with_feedback(PSTR(MSG_EDITING_STOPPED));
+      set_message_with_feedback(GET_TEXT(MSG_EDITING_STOPPED));
     }
 
     void unified_bed_leveling::fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) {
       if (!parser.seen('R'))      // fine_tune_mesh() is special. If no repetition count flag is specified
         g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 
       #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
         const float h_offset = parser.seenval('H') ? parser.value_linear_units() : 0;
         if (!WITHIN(h_offset, 0, 10)) {
           SERIAL_ECHOLNPGM("Offset out of bounds. (0 to 10mm)\n");
@@ -1065,21 +1065,21 @@
       else
         ui.return_to_status();
     }
 
   #endif // HAS_LCD_MENU
 
   bool unified_bed_leveling::g29_parameter_parsing() {
     bool err_flag = false;
 
     #if HAS_LCD_MENU
-      set_message_with_feedback(PSTR(MSG_UBL_DOING_G29));
+      set_message_with_feedback(GET_TEXT(MSG_UBL_DOING_G29));
     #endif
 
     g29_constant = 0;
     g29_repetition_cnt = 0;
 
     if (parser.seen('R')) {
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : GRID_MAX_POINTS;
       NOMORE(g29_repetition_cnt, GRID_MAX_POINTS);
       if (g29_repetition_cnt < 1) {
         SERIAL_ECHOLNPGM("?(R)epetition count invalid (1+).\n");
@@ -1189,35 +1189,35 @@
   #if ENABLED(UBL_DEVEL_DEBUGGING)
     static uint8_t ubl_state_recursion_chk = 0;
   #endif
 
   void unified_bed_leveling::save_ubl_active_state_and_disable() {
     #if ENABLED(UBL_DEVEL_DEBUGGING)
       ubl_state_recursion_chk++;
       if (ubl_state_recursion_chk != 1) {
         SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
         #if HAS_LCD_MENU
-          set_message_with_feedback(PSTR(MSG_UBL_SAVE_ERROR));
+          set_message_with_feedback(GET_TEXT(MSG_UBL_SAVE_ERROR));
         #endif
         return;
       }
     #endif
     ubl_state_at_invocation = planner.leveling_active;
     set_bed_leveling_enabled(false);
   }
 
   void unified_bed_leveling::restore_ubl_active_state_and_leave() {
     #if ENABLED(UBL_DEVEL_DEBUGGING)
       if (--ubl_state_recursion_chk) {
         SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
         #if HAS_LCD_MENU
-          set_message_with_feedback(PSTR(MSG_UBL_RESTORE_ERROR));
+          set_message_with_feedback(GET_TEXT(MSG_UBL_RESTORE_ERROR));
         #endif
         return;
       }
     #endif
     set_bed_leveling_enabled(ubl_state_at_invocation);
   }
 
   mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
     bool found_a_NAN = false, found_a_real = false;
@@ -1403,42 +1403,42 @@
       #ifdef VALIDATE_MESH_TILT
         float z1, z2, z3;  // Needed for algorithm validation below
       #endif
 
       struct linear_fit_data lsf_results;
       incremental_LSF_reset(&lsf_results);
 
       if (do_3_pt_leveling) {
         SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
         #if HAS_DISPLAY
-          ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 1/3"));
+          ui.status_printf_P(0, PSTR(S_FMT " 1/3"), GET_TEXT(MSG_LCD_TILTING_MESH));
         #endif
 
         measured_z = probe_at_point(points[0], PROBE_PT_RAISE, g29_verbose_level);
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(points[0]);
           #ifdef VALIDATE_MESH_TILT
             z1 = measured_z;
           #endif
           if (g29_verbose_level > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, points[0], measured_z);
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
           #if HAS_DISPLAY
-            ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 2/3"));
+            ui.status_printf_P(0, PSTR(S_FMT " 2/3"), GET_TEXT(MSG_LCD_TILTING_MESH));
           #endif
 
           measured_z = probe_at_point(points[1], PROBE_PT_RAISE, g29_verbose_level);
           #ifdef VALIDATE_MESH_TILT
             z2 = measured_z;
           #endif
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(points[1]);
@@ -1446,21 +1446,21 @@
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, points[1], measured_z);
           }
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
           #if HAS_DISPLAY
-            ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 3/3"));
+            ui.status_printf_P(0, PSTR(S_FMT " 3/3"), GET_TEXT(MSG_LCD_TILTING_MESH));
           #endif
 
           measured_z = probe_at_point(points[2], PROBE_PT_STOW, g29_verbose_level);
           #ifdef VALIDATE_MESH_TILT
             z3 = measured_z;
           #endif
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(points[2]);
@@ -1490,21 +1490,21 @@
 
         xy_pos_t rpos;
         for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
           rpos.x = x_min + ix * dx;
           for (int8_t iy = 0; iy < g29_grid_size; iy++) {
             rpos.y = y_min + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
 
             if (!abort_flag) {
               SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
               #if HAS_DISPLAY
-                ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " %i/%i"), point_num, total_points);
+                ui.status_printf_P(0, PSTR(S_FMT " %i/%i"), GET_TEXT(MSG_LCD_TILTING_MESH), point_num, total_points);
               #endif
 
               measured_z = probe_at_point(rpos, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
 
               abort_flag = isnan(measured_z);
 
               if (DEBUGGING(LEVELING)) {
                 const xy_pos_t lpos = rpos.asLogical();
                 DEBUG_CHAR('(');
                 DEBUG_ECHO_F(rpos.x, 7);

commit 211ff674405d1291a177d071fb40f3da8c13c93c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 6 23:58:19 2019 -0500

    Patch blocking and manual moves

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 6005e9881f..d016667e44 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -885,21 +885,21 @@
       restore_ubl_active_state_and_leave();
 
       return thickness;
     }
 
     void unified_bed_leveling::manually_probe_remaining_mesh(const xy_pos_t &pos, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
 
       ui.capture();
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
-      do_blocking_move_to(current_position.x, current_position.y, z_clearance);
+      do_blocking_move_to_xy_z(current_position, z_clearance);
 
       ui.return_to_status();
 
       mesh_index_pair location;
       xy_int8_t &lpos = location.pos;
       do {
         location = find_closest_mesh_point_of_type(INVALID, pos);
         // It doesn't matter if the probe can't reach the NAN location. This is a manual probe.
         if (!location.valid()) continue;
 
@@ -941,21 +941,21 @@
         #endif
 
         if (g29_verbose_level > 2)
           SERIAL_ECHOLNPAIR_F("Mesh Point Measured at: ", z_values[lpos.x][lpos.y], 6);
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.valid());
 
       if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
       restore_ubl_active_state_and_leave();
-      do_blocking_move_to(pos, Z_CLEARANCE_DEPLOY_PROBE);
+      do_blocking_move_to_xy_z(pos, Z_CLEARANCE_DEPLOY_PROBE);
     }
 
     inline void set_message_with_feedback(PGM_P const msg_P) {
       ui.set_status_P(msg_P);
       ui.quick_feedback();
     }
 
     void abort_fine_tune() {
       ui.return_to_status();
       do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
@@ -979,21 +979,21 @@
       if (!position_is_reachable(pos)) {
         SERIAL_ECHOLNPGM("(X,Y) outside printable radius.");
         return;
       }
 
       save_ubl_active_state_and_disable();
 
       LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
       ui.capture();                                         // Take over control of the LCD encoder
 
-      do_blocking_move_to(pos, Z_CLEARANCE_BETWEEN_PROBES); // Move to the given XY with probe clearance
+      do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES); // Move to the given XY with probe clearance
 
       #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
         do_blocking_move_to_z(h_offset);                    // Move Z to the given 'H' offset
       #endif
 
       MeshFlags done_flags{0};
       xy_int8_t &lpos = location.pos;
       do {
         location = find_closest_mesh_point_of_type(SET_IN_BITMAP, pos, false, &done_flags);
 
@@ -1048,21 +1048,21 @@
         serial_delay(20);                                   // No switch noise
         ui.refresh();
 
       } while (lpos.x >= 0 && --g29_repetition_cnt > 0);
 
       ui.release();
 
       if (do_ubl_mesh_map) display_map(g29_map_type);
       restore_ubl_active_state_and_leave();
 
-      do_blocking_move_to(pos, Z_CLEARANCE_BETWEEN_PROBES);
+      do_blocking_move_to_xy_z(pos, Z_CLEARANCE_BETWEEN_PROBES);
 
       LCD_MESSAGEPGM(MSG_UBL_DONE_EDITING_MESH);
       SERIAL_ECHOLNPGM("Done Editing Mesh");
 
       if (lcd_map_control)
         ui.goto_screen(_lcd_ubl_output_map_lcd);
       else
         ui.return_to_status();
     }
 

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 54c7666bac..6005e9881f 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -46,41 +46,37 @@
   #include "../../../core/debug_out.h"
 
   #if ENABLED(EXTENSIBLE_UI)
     #include "../../../lcd/extensible_ui/ui_api.h"
   #endif
 
   #include <math.h>
 
   #define UBL_G29_P31
 
-  extern float destination[XYZE], current_position[XYZE];
-
   #if HAS_LCD_MENU
     void _lcd_ubl_output_map_lcd();
   #endif
 
   #define SIZE_OF_LITTLE_RAISE 1
   #define BIG_RAISE_NOT_NEEDED 0
 
   int    unified_bed_leveling::g29_verbose_level,
          unified_bed_leveling::g29_phase_value,
          unified_bed_leveling::g29_repetition_cnt,
          unified_bed_leveling::g29_storage_slot = 0,
          unified_bed_leveling::g29_map_type;
-  bool   unified_bed_leveling::g29_c_flag,
-         unified_bed_leveling::g29_x_flag,
-         unified_bed_leveling::g29_y_flag;
-  float  unified_bed_leveling::g29_x_pos,
-         unified_bed_leveling::g29_y_pos,
-         unified_bed_leveling::g29_card_thickness = 0,
+  bool   unified_bed_leveling::g29_c_flag;
+  float  unified_bed_leveling::g29_card_thickness = 0,
          unified_bed_leveling::g29_constant = 0;
+  xy_bool_t unified_bed_leveling::xy_seen;
+  xy_pos_t unified_bed_leveling::g29_pos;
 
   #if HAS_BED_PROBE
     int  unified_bed_leveling::g29_grid_size;
   #endif
 
   /**
    *   G29: Unified Bed Leveling by Roxy
    *
    *   Parameters understood by this leveling system:
    *
@@ -323,32 +319,33 @@
     // it directly specifies the repetition count and does not use the 'R' parameter.
     if (parser.seen('I')) {
       uint8_t cnt = 0;
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : 1;
       if (g29_repetition_cnt >= GRID_MAX_POINTS) {
         set_all_mesh_points_to_value(NAN);
       }
       else {
         while (g29_repetition_cnt--) {
           if (cnt > 20) { cnt = 0; idle(); }
-          const mesh_index_pair location = find_closest_mesh_point_of_type(REAL, g29_x_pos, g29_y_pos, USE_NOZZLE_AS_REFERENCE, nullptr);
-          if (location.x_index < 0) {
-            // No more REACHABLE mesh points to invalidate, so we ASSUME the user
+          const mesh_index_pair closest = find_closest_mesh_point_of_type(REAL, g29_pos);
+          const xy_int8_t &cpos = closest.pos;
+          if (cpos.x < 0) {
+            // No more REAL mesh points to invalidate, so we ASSUME the user
             // meant to invalidate the ENTIRE mesh, which cannot be done with
-            // find_closest_mesh_point loop which only returns REACHABLE points.
+            // find_closest_mesh_point loop which only returns REAL points.
             set_all_mesh_points_to_value(NAN);
             SERIAL_ECHOLNPGM("Entire Mesh invalidated.\n");
             break;            // No more invalid Mesh Points to populate
           }
-          z_values[location.x_index][location.y_index] = NAN;
+          z_values[cpos.x][cpos.y] = NAN;
           #if ENABLED(EXTENSIBLE_UI)
-            ExtUI::onMeshUpdate(location.x_index, location.y_index, 0);
+            ExtUI::onMeshUpdate(closest, 0);
           #endif
           cnt++;
         }
       }
       SERIAL_ECHOLNPGM("Locations invalidated.\n");
     }
 
     if (parser.seen('Q')) {
       const int test_pattern = parser.has_value() ? parser.value_int() : -99;
       if (!WITHIN(test_pattern, -1, 2)) {
@@ -441,75 +438,76 @@
 
           case 1: {
             //
             // Invalidate Entire Mesh and Automatically Probe Mesh in areas that can be reached by the probe
             //
             if (!parser.seen('C')) {
               invalidate();
               SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
             }
             if (g29_verbose_level > 1) {
-              SERIAL_ECHOPAIR("Probing around (", g29_x_pos);
+              SERIAL_ECHOPAIR("Probing around (", g29_pos.x);
               SERIAL_CHAR(',');
-              SERIAL_ECHO(g29_y_pos);
+              SERIAL_ECHO(g29_pos.y);
               SERIAL_ECHOLNPGM(").\n");
             }
-            probe_entire_mesh(g29_x_pos + probe_offset[X_AXIS], g29_y_pos + probe_offset[Y_AXIS],
-                              parser.seen('T'), parser.seen('E'), parser.seen('U'));
+            const xy_pos_t near = g29_pos + probe_offset;
+            probe_entire_mesh(near, parser.seen('T'), parser.seen('E'), parser.seen('U'));
 
             report_current_position();
             probe_deployed = true;
           } break;
 
         #endif // HAS_BED_PROBE
 
         case 2: {
           #if HAS_LCD_MENU
             //
             // Manually Probe Mesh in areas that can't be reached by the probe
             //
             SERIAL_ECHOLNPGM("Manually probing unreachable mesh locations.");
             do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
 
-            if (parser.seen('C') && !g29_x_flag && !g29_y_flag) {
+            if (parser.seen('C') && !xy_seen) {
               /**
                * Use a good default location for the path.
                * The flipped > and < operators in these comparisons is intentional.
                * It should cause the probed points to follow a nice path on Cartesian printers.
                * It may make sense to have Delta printers default to the center of the bed.
                * Until that is decided, this can be forced with the X and Y parameters.
                */
-              #if IS_KINEMATIC
-                g29_x_pos = X_HOME_POS;
-                g29_y_pos = Y_HOME_POS;
-              #else // cartesian
-                g29_x_pos = probe_offset[X_AXIS] > 0 ? X_BED_SIZE : 0;
-                g29_y_pos = probe_offset[Y_AXIS] < 0 ? Y_BED_SIZE : 0;
-              #endif
+              g29_pos.set(
+                #if IS_KINEMATIC
+                  X_HOME_POS, Y_HOME_POS
+                #else
+                  probe_offset.x > 0 ? X_BED_SIZE : 0,
+                  probe_offset.y < 0 ? Y_BED_SIZE : 0
+                #endif
+              );
             }
 
             if (parser.seen('B')) {
               g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness((float) Z_CLEARANCE_BETWEEN_PROBES);
               if (ABS(g29_card_thickness) > 1.5f) {
                 SERIAL_ECHOLNPGM("?Error in Business Card measurement.");
                 return;
               }
               probe_deployed = true;
             }
 
-            if (!position_is_reachable(g29_x_pos, g29_y_pos)) {
+            if (!position_is_reachable(g29_pos)) {
               SERIAL_ECHOLNPGM("XY outside printable radius.");
               return;
             }
 
             const float height = parser.floatval('H', Z_CLEARANCE_BETWEEN_PROBES);
-            manually_probe_remaining_mesh(g29_x_pos, g29_y_pos, height, g29_card_thickness, parser.seen('T'));
+            manually_probe_remaining_mesh(g29_pos, height, g29_card_thickness, parser.seen('T'));
 
             SERIAL_ECHOLNPGM("G29 P2 finished.");
 
             report_current_position();
 
           #else
 
             SERIAL_ECHOLNPGM("?P2 is only available when an LCD is present.");
             return;
 
@@ -523,34 +521,36 @@
            *   - Specify a constant with the 'C' parameter.
            *   - Allow 'G29 P3' to choose a 'reasonable' constant.
            */
 
           if (g29_c_flag) {
             if (g29_repetition_cnt >= GRID_MAX_POINTS) {
               set_all_mesh_points_to_value(g29_constant);
             }
             else {
               while (g29_repetition_cnt--) {  // this only populates reachable mesh points near
-                const mesh_index_pair location = find_closest_mesh_point_of_type(INVALID, g29_x_pos, g29_y_pos, USE_NOZZLE_AS_REFERENCE, nullptr);
-                if (location.x_index < 0) {
-                  // No more REACHABLE INVALID mesh points to populate, so we ASSUME
+                const mesh_index_pair closest = find_closest_mesh_point_of_type(INVALID, g29_pos);
+                const xy_int8_t &cpos = closest.pos;
+                if (cpos.x < 0) {
+                  // No more REAL INVALID mesh points to populate, so we ASSUME
                   // user meant to populate ALL INVALID mesh points to value
                   for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
                     for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
-                      if (isnan(z_values[x][y]))
-                        z_values[x][y] = g29_constant;
+                      if (isnan(z_values[x][y])) z_values[x][y] = g29_constant;
                   break; // No more invalid Mesh Points to populate
                 }
-                z_values[location.x_index][location.y_index] = g29_constant;
-                #if ENABLED(EXTENSIBLE_UI)
-                  ExtUI::onMeshUpdate(location.x_index, location.y_index, z_values[location.x_index][location.y_index]);
-                #endif
+                else {
+                  z_values[cpos.x][cpos.y] = g29_constant;
+                  #if ENABLED(EXTENSIBLE_UI)
+                    ExtUI::onMeshUpdate(closest, g29_constant);
+                  #endif
+                }
               }
             }
           }
           else {
             const float cvf = parser.value_float();
             switch ((int)truncf(cvf * 10.0f) - 30) {   // 3.1 -> 1
               #if ENABLED(UBL_G29_P31)
                 case 1: {
 
                   // P3.1  use least squares fit to fill missing mesh values
@@ -569,21 +569,21 @@
               default:  // and anything P3.x that's not P3.1
                 smart_fill_mesh();  // Do a 'Smart' fill using nearby known values
                 break;
             }
           }
           break;
         }
 
         case 4: // Fine Tune (i.e., Edit) the Mesh
           #if HAS_LCD_MENU
-            fine_tune_mesh(g29_x_pos, g29_y_pos, parser.seen('T'));
+            fine_tune_mesh(g29_pos, parser.seen('T'));
           #else
             SERIAL_ECHOLNPGM("?P4 is only available when an LCD is present.");
             return;
           #endif
           break;
 
         case 5: adjust_mesh_to_mean(g29_c_flag, g29_constant); break;
 
         case 6: shift_mesh_height(); break;
       }
@@ -733,32 +733,31 @@
             ExtUI::onMeshUpdate(x, y, z_values[x][y]);
           #endif
         }
   }
 
   #if HAS_BED_PROBE
     /**
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
-    void unified_bed_leveling::probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
-      mesh_index_pair location;
-
+    void unified_bed_leveling::probe_entire_mesh(const xy_pos_t &near, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
       #if HAS_LCD_MENU
         ui.capture();
       #endif
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       DEPLOY_PROBE();
 
       uint8_t count = GRID_MAX_POINTS;
 
+      mesh_index_pair best;
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
         const int point_num = (GRID_MAX_POINTS) - count + 1;
         SERIAL_ECHOLNPAIR("\nProbing mesh point ", point_num, "/", int(GRID_MAX_POINTS), ".\n");
         #if HAS_DISPLAY
           ui.status_printf_P(0, PSTR(MSG_PROBING_MESH " %i/%i"), point_num, int(GRID_MAX_POINTS));
         #endif
 
         #if HAS_LCD_MENU
@@ -766,49 +765,49 @@
             ui.quick_feedback(false); // Preserve button state for click-and-hold
             SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
             STOW_PROBE();
             ui.wait_for_release();
             ui.quick_feedback();
             ui.release();
             return restore_ubl_active_state_and_leave();
           }
         #endif
 
-        if (do_furthest)
-          location = find_furthest_invalid_mesh_point();
-        else
-          location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, nullptr);
+        best = do_furthest
+          ? find_furthest_invalid_mesh_point()
+          : find_closest_mesh_point_of_type(INVALID, near, true);
 
-        if (location.x_index >= 0) {    // mesh point found and is reachable by probe
-          const float rawx = mesh_index_to_xpos(location.x_index),
-                      rawy = mesh_index_to_ypos(location.y_index),
-                      measured_z = probe_at_point(rawx, rawy, stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
-          z_values[location.x_index][location.y_index] = measured_z;
+        if (best.pos.x >= 0) {    // mesh point found and is reachable by probe
+          const float measured_z = probe_at_point(
+                        best.meshpos(),
+                        stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level
+                      );
+          z_values[best.pos.x][best.pos.y] = measured_z;
           #if ENABLED(EXTENSIBLE_UI)
-            ExtUI::onMeshUpdate(location.x_index, location.y_index, measured_z);
+            ExtUI::onMeshUpdate(best, measured_z);
           #endif
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
 
-      } while (location.x_index >= 0 && --count);
+      } while (best.pos.x >= 0 && --count);
 
       STOW_PROBE();
 
       #ifdef Z_AFTER_PROBING
         move_z_after_probing();
       #endif
 
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
-        constrain(rx - probe_offset[X_AXIS], MESH_MIN_X, MESH_MAX_X),
-        constrain(ry - probe_offset[Y_AXIS], MESH_MIN_Y, MESH_MAX_Y)
+        constrain(near.x - probe_offset.x, MESH_MIN_X, MESH_MAX_X),
+        constrain(near.y - probe_offset.y, MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 
   #endif // HAS_BED_PROBE
 
   #if HAS_LCD_MENU
 
     typedef void (*clickFunc_t)();
 
     bool click_and_hold(const clickFunc_t func=nullptr) {
@@ -828,96 +827,100 @@
       serial_delay(15);
       return false;
     }
 
     void unified_bed_leveling::move_z_with_encoder(const float &multiplier) {
       ui.wait_for_release();
       while (!ui.button_pressed()) {
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
         if (encoder_diff) {
-          do_blocking_move_to_z(current_position[Z_AXIS] + float(encoder_diff) * multiplier);
+          do_blocking_move_to_z(current_position.z + float(encoder_diff) * multiplier);
           encoder_diff = 0;
         }
       }
     }
 
     float unified_bed_leveling::measure_point_with_encoder() {
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       move_z_with_encoder(0.01f);
-      return current_position[Z_AXIS];
+      return current_position.z;
     }
 
     static void echo_and_take_a_measurement() { SERIAL_ECHOLNPGM(" and take a measurement."); }
 
     float unified_bed_leveling::measure_business_card_thickness(float in_height) {
       ui.capture();
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
       do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
         //, _MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f);
       planner.synchronize();
 
       SERIAL_ECHOPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       ui.return_to_status();
       echo_and_take_a_measurement();
 
       const float z1 = measure_point_with_encoder();
-      do_blocking_move_to_z(current_position[Z_AXIS] + SIZE_OF_LITTLE_RAISE);
+      do_blocking_move_to_z(current_position.z + SIZE_OF_LITTLE_RAISE);
       planner.synchronize();
 
       SERIAL_ECHOPGM("Remove shim");
       LCD_MESSAGEPGM(MSG_UBL_BC_REMOVE);
       echo_and_take_a_measurement();
 
       const float z2 = measure_point_with_encoder();
 
-      do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES);
+      do_blocking_move_to_z(current_position.z + Z_CLEARANCE_BETWEEN_PROBES);
 
       const float thickness = ABS(z1 - z2);
 
       if (g29_verbose_level > 1) {
         SERIAL_ECHOPAIR_F("Business Card is ", thickness, 4);
         SERIAL_ECHOLNPGM("mm thick.");
       }
 
       ui.release();
 
       restore_ubl_active_state_and_leave();
 
       return thickness;
     }
 
-    void unified_bed_leveling::manually_probe_remaining_mesh(const float &rx, const float &ry, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
+    void unified_bed_leveling::manually_probe_remaining_mesh(const xy_pos_t &pos, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
 
       ui.capture();
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
-      do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z_clearance);
+      do_blocking_move_to(current_position.x, current_position.y, z_clearance);
 
       ui.return_to_status();
 
       mesh_index_pair location;
+      xy_int8_t &lpos = location.pos;
       do {
-        location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_NOZZLE_AS_REFERENCE, nullptr);
+        location = find_closest_mesh_point_of_type(INVALID, pos);
         // It doesn't matter if the probe can't reach the NAN location. This is a manual probe.
-        if (location.x_index < 0 && location.y_index < 0) continue;
+        if (!location.valid()) continue;
 
-        const float xProbe = mesh_index_to_xpos(location.x_index),
-                    yProbe = mesh_index_to_ypos(location.y_index);
+        const xyz_pos_t ppos = {
+          mesh_index_to_xpos(lpos.x),
+          mesh_index_to_ypos(lpos.y),
+          Z_CLEARANCE_BETWEEN_PROBES
+        };
 
-        if (!position_is_reachable(xProbe, yProbe)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
+        if (!position_is_reachable(ppos)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
 
         LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
 
-        do_blocking_move_to(xProbe, yProbe, Z_CLEARANCE_BETWEEN_PROBES);
+        do_blocking_move_to(ppos);
         do_blocking_move_to_z(z_clearance);
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         ui.capture();
 
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
         serialprintPGM(parser.seen('B') ? PSTR(MSG_UBL_BC_INSERT) : PSTR(MSG_UBL_BC_INSERT2));
 
         const float z_step = 0.01f;                         // existing behavior: 0.01mm per click, occasionally step
@@ -925,139 +928,141 @@
 
         move_z_with_encoder(z_step);
 
         if (click_and_hold()) {
           SERIAL_ECHOLNPGM("\nMesh only partially populated.");
           do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
           ui.release();
           return restore_ubl_active_state_and_leave();
         }
 
-        z_values[location.x_index][location.y_index] = current_position[Z_AXIS] - thick;
+        z_values[lpos.x][lpos.y] = current_position.z - thick;
         #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::onMeshUpdate(location.x_index, location.y_index, z_values[location.x_index][location.y_index]);
+          ExtUI::onMeshUpdate(location, z_values[lpos.x][lpos.y]);
         #endif
 
         if (g29_verbose_level > 2)
-          SERIAL_ECHOLNPAIR_F("Mesh Point Measured at: ", z_values[location.x_index][location.y_index], 6);
+          SERIAL_ECHOLNPAIR_F("Mesh Point Measured at: ", z_values[lpos.x][lpos.y], 6);
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
-      } while (location.x_index >= 0 && location.y_index >= 0);
+      } while (location.valid());
 
       if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
       restore_ubl_active_state_and_leave();
-      do_blocking_move_to(rx, ry, Z_CLEARANCE_DEPLOY_PROBE);
+      do_blocking_move_to(pos, Z_CLEARANCE_DEPLOY_PROBE);
     }
 
     inline void set_message_with_feedback(PGM_P const msg_P) {
       ui.set_status_P(msg_P);
       ui.quick_feedback();
     }
 
     void abort_fine_tune() {
       ui.return_to_status();
       do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
       set_message_with_feedback(PSTR(MSG_EDITING_STOPPED));
     }
 
-    void unified_bed_leveling::fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map) {
-      if (!parser.seen('R'))    // fine_tune_mesh() is special. If no repetition count flag is specified
+    void unified_bed_leveling::fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) {
+      if (!parser.seen('R'))      // fine_tune_mesh() is special. If no repetition count flag is specified
         g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 
       #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
         const float h_offset = parser.seenval('H') ? parser.value_linear_units() : 0;
         if (!WITHIN(h_offset, 0, 10)) {
           SERIAL_ECHOLNPGM("Offset out of bounds. (0 to 10mm)\n");
           return;
         }
       #endif
 
       mesh_index_pair location;
 
-      if (!position_is_reachable(rx, ry)) {
+      if (!position_is_reachable(pos)) {
         SERIAL_ECHOLNPGM("(X,Y) outside printable radius.");
         return;
       }
 
       save_ubl_active_state_and_disable();
 
       LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
-      ui.capture();                                                 // Take over control of the LCD encoder
+      ui.capture();                                         // Take over control of the LCD encoder
 
-      do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);      // Move to the given XY with probe clearance
+      do_blocking_move_to(pos, Z_CLEARANCE_BETWEEN_PROBES); // Move to the given XY with probe clearance
 
       #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
-        do_blocking_move_to_z(h_offset);                            // Move Z to the given 'H' offset
+        do_blocking_move_to_z(h_offset);                    // Move Z to the given 'H' offset
       #endif
 
-      uint16_t not_done[16];
-      memset(not_done, 0xFF, sizeof(not_done));
+      MeshFlags done_flags{0};
+      xy_int8_t &lpos = location.pos;
       do {
-        location = find_closest_mesh_point_of_type(SET_IN_BITMAP, rx, ry, USE_NOZZLE_AS_REFERENCE, not_done);
-
-        if (location.x_index < 0) break;                            // Stop when there are no more reachable points
+        location = find_closest_mesh_point_of_type(SET_IN_BITMAP, pos, false, &done_flags);
 
-        bitmap_clear(not_done, location.x_index, location.y_index); // Mark this location as 'adjusted' so a new
-                                                                    // location is used on the next loop
+        if (lpos.x < 0) break;                              // Stop when there are no more reachable points
 
-        const float rawx = mesh_index_to_xpos(location.x_index),
-                    rawy = mesh_index_to_ypos(location.y_index);
+        done_flags.mark(lpos);                              // Mark this location as 'adjusted' so a new
+                                                            // location is used on the next loop
+        const xyz_pos_t raw = {
+          mesh_index_to_xpos(lpos.x),
+          mesh_index_to_ypos(lpos.y),
+          Z_CLEARANCE_BETWEEN_PROBES
+        };
 
-        if (!position_is_reachable(rawx, rawy)) break;              // SHOULD NOT OCCUR because find_closest_mesh_point_of_type will only return reachable
+        if (!position_is_reachable(raw)) break;             // SHOULD NOT OCCUR (find_closest_mesh_point_of_type only returns reachable)
 
-        do_blocking_move_to(rawx, rawy, Z_CLEARANCE_BETWEEN_PROBES); // Move the nozzle to the edit point with probe clearance
+        do_blocking_move_to(raw);                           // Move the nozzle to the edit point with probe clearance
 
         #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
-          do_blocking_move_to_z(h_offset);                          // Move Z to the given 'H' offset before editing
+          do_blocking_move_to_z(h_offset);                  // Move Z to the given 'H' offset before editing
         #endif
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
 
-        if (do_ubl_mesh_map) display_map(g29_map_type);             // Display the current point
+        if (do_ubl_mesh_map) display_map(g29_map_type);     // Display the current point
 
         ui.refresh();
 
-        float new_z = z_values[location.x_index][location.y_index];
-        if (isnan(new_z)) new_z = 0;                                // Invalid points begin at 0
-        new_z = FLOOR(new_z * 1000) * 0.001f;                       // Chop off digits after the 1000ths place
+        float new_z = z_values[lpos.x][lpos.y];
+        if (isnan(new_z)) new_z = 0;                        // Invalid points begin at 0
+        new_z = FLOOR(new_z * 1000) * 0.001f;               // Chop off digits after the 1000ths place
 
         lcd_mesh_edit_setup(new_z);
 
         do {
           new_z = lcd_mesh_edit();
           #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
-            do_blocking_move_to_z(h_offset + new_z);                // Move the nozzle as the point is edited
+            do_blocking_move_to_z(h_offset + new_z);        // Move the nozzle as the point is edited
           #endif
           idle();
-          SERIAL_FLUSH();                                           // Prevent host M105 buffer overrun.
+          SERIAL_FLUSH();                                   // Prevent host M105 buffer overrun.
         } while (!ui.button_pressed());
 
-        if (!lcd_map_control) ui.return_to_status();                // Just editing a single point? Return to status
+        if (!lcd_map_control) ui.return_to_status();        // Just editing a single point? Return to status
 
-        if (click_and_hold(abort_fine_tune)) break;                 // Button held down? Abort editing
+        if (click_and_hold(abort_fine_tune)) break;         // Button held down? Abort editing
 
-        z_values[location.x_index][location.y_index] = new_z;       // Save the updated Z value
+        z_values[lpos.x][lpos.y] = new_z;                   // Save the updated Z value
         #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::onMeshUpdate(location.x_index, location.y_index, new_z);
+          ExtUI::onMeshUpdate(location, new_z);
         #endif
 
-        serial_delay(20);                                           // No switch noise
+        serial_delay(20);                                   // No switch noise
         ui.refresh();
 
-      } while (location.x_index >= 0 && --g29_repetition_cnt > 0);
+      } while (lpos.x >= 0 && --g29_repetition_cnt > 0);
 
       ui.release();
 
       if (do_ubl_mesh_map) display_map(g29_map_type);
       restore_ubl_active_state_and_leave();
 
-      do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);
+      do_blocking_move_to(pos, Z_CLEARANCE_BETWEEN_PROBES);
 
       LCD_MESSAGEPGM(MSG_UBL_DONE_EDITING_MESH);
       SERIAL_ECHOLNPGM("Done Editing Mesh");
 
       if (lcd_map_control)
         ui.goto_screen(_lcd_ubl_output_map_lcd);
       else
         ui.return_to_status();
     }
 
@@ -1066,25 +1071,20 @@
   bool unified_bed_leveling::g29_parameter_parsing() {
     bool err_flag = false;
 
     #if HAS_LCD_MENU
       set_message_with_feedback(PSTR(MSG_UBL_DOING_G29));
     #endif
 
     g29_constant = 0;
     g29_repetition_cnt = 0;
 
-    g29_x_flag = parser.seenval('X');
-    g29_x_pos = g29_x_flag ? parser.value_float() : current_position[X_AXIS];
-    g29_y_flag = parser.seenval('Y');
-    g29_y_pos = g29_y_flag ? parser.value_float() : current_position[Y_AXIS];
-
     if (parser.seen('R')) {
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : GRID_MAX_POINTS;
       NOMORE(g29_repetition_cnt, GRID_MAX_POINTS);
       if (g29_repetition_cnt < 1) {
         SERIAL_ECHOLNPGM("?(R)epetition count invalid (1+).\n");
         return UBL_ERR;
       }
     }
 
     g29_verbose_level = parser.seen('V') ? parser.value_int() : 0;
@@ -1117,31 +1117,38 @@
         if (g29_grid_size && !WITHIN(g29_grid_size, 2, 9)) {
           SERIAL_ECHOLNPGM("?Invalid grid size (J) specified (2-9).\n");
           err_flag = true;
         }
       #else
         SERIAL_ECHOLNPGM("G29 J action requires a probe.\n");
         err_flag = true;
       #endif
     }
 
-    if (g29_x_flag != g29_y_flag) {
+    xy_seen.x = parser.seenval('X');
+    float sx = xy_seen.x ? parser.value_float() : current_position.x;
+    xy_seen.y = parser.seenval('Y');
+    float sy = xy_seen.y ? parser.value_float() : current_position.y;
+
+    if (xy_seen.x != xy_seen.y) {
       SERIAL_ECHOLNPGM("Both X & Y locations must be specified.\n");
       err_flag = true;
     }
 
     // If X or Y are not valid, use center of the bed values
-    if (!WITHIN(g29_x_pos, X_MIN_BED, X_MAX_BED)) g29_x_pos = X_CENTER;
-    if (!WITHIN(g29_y_pos, Y_MIN_BED, Y_MAX_BED)) g29_y_pos = Y_CENTER;
+    if (!WITHIN(sx, X_MIN_BED, X_MAX_BED)) sx = X_CENTER;
+    if (!WITHIN(sy, Y_MIN_BED, Y_MAX_BED)) sy = Y_CENTER;
 
     if (err_flag) return UBL_ERR;
 
+    g29_pos.set(sx, sy);
+
     /**
      * Activate or deactivate UBL
      * Note: UBL's G29 restores the state set here when done.
      *       Leveling is being enabled here with old data, possibly
      *       none. Error handling should disable for safety...
      */
     if (parser.seen('A')) {
       if (parser.seen('D')) {
         SERIAL_ECHOLNPGM("?Can't activate and deactivate at the same time.\n");
         return UBL_ERR;
@@ -1206,153 +1213,140 @@
           set_message_with_feedback(PSTR(MSG_UBL_RESTORE_ERROR));
         #endif
         return;
       }
     #endif
     set_bed_leveling_enabled(ubl_state_at_invocation);
   }
 
   mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
-    bool found_a_NAN  = false, found_a_real = false;
+    bool found_a_NAN = false, found_a_real = false;
 
-    mesh_index_pair out_mesh;
-    out_mesh.x_index = out_mesh.y_index = -1;
-    out_mesh.distance = -99999.99f;
+    mesh_index_pair farthest { -1, -1, -99999.99 };
 
     for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
 
-        if (isnan(z_values[i][j])) { // Check to see if this location holds an invalid mesh point
-
-          const float mx = mesh_index_to_xpos(i),
-                      my = mesh_index_to_ypos(j);
+        if (isnan(z_values[i][j])) {                  // Invalid mesh point?
 
-          if (!position_is_reachable_by_probe(mx, my))  // make sure the probe can get to the mesh point
+          // Skip points the probe can't reach
+          if (!position_is_reachable_by_probe(mesh_index_to_xpos(i), mesh_index_to_ypos(j)))
             continue;
 
           found_a_NAN = true;
 
-          int8_t closest_x = -1, closest_y = -1;
+          xy_int8_t near { -1, -1 };
           float d1, d2 = 99999.9f;
           for (int8_t k = 0; k < GRID_MAX_POINTS_X; k++) {
             for (int8_t l = 0; l < GRID_MAX_POINTS_Y; l++) {
               if (!isnan(z_values[k][l])) {
                 found_a_real = true;
 
                 // Add in a random weighting factor that scrambles the probing of the
                 // last half of the mesh (when every unprobed mesh point is one index
                 // from a probed location).
 
                 d1 = HYPOT(i - k, j - l) + (1.0f / ((millis() % 47) + 13));
 
-                if (d1 < d2) {    // found a closer distance from invalid mesh point at (i,j) to defined mesh point at (k,l)
-                  d2 = d1;        // found a closer location with
-                  closest_x = i;  // an assigned mesh point value
-                  closest_y = j;
+                if (d1 < d2) {    // Invalid mesh point (i,j) is closer to the defined point (k,l)
+                  d2 = d1;
+                  near.set(i, j);
                 }
               }
             }
           }
 
           //
-          // At this point d2 should have the closest defined mesh point to invalid mesh point (i,j)
+          // At this point d2 should have the near defined mesh point to invalid mesh point (i,j)
           //
 
-          if (found_a_real && (closest_x >= 0) && (d2 > out_mesh.distance)) {
-            out_mesh.distance = d2;         // found an invalid location with a greater distance
-            out_mesh.x_index = closest_x;   // to a defined mesh point
-            out_mesh.y_index = closest_y;
+          if (found_a_real && near.x >= 0 && d2 > farthest.distance) {
+            farthest.pos = near;      // Found an invalid location farther from the defined mesh point
+            farthest.distance = d2;
           }
         }
       } // for j
     } // for i
 
     if (!found_a_real && found_a_NAN) {        // if the mesh is totally unpopulated, start the probing
-      out_mesh.x_index = GRID_MAX_POINTS_X / 2;
-      out_mesh.y_index = GRID_MAX_POINTS_Y / 2;
-      out_mesh.distance = 1;
+      farthest.pos.set(GRID_MAX_POINTS_X / 2, GRID_MAX_POINTS_Y / 2);
+      farthest.distance = 1;
     }
-    return out_mesh;
+    return farthest;
   }
 
-  mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const float &rx, const float &ry, const bool probe_as_reference, uint16_t bits[16]) {
-    mesh_index_pair out_mesh;
-    out_mesh.x_index = out_mesh.y_index = -1;
-    out_mesh.distance = -99999.9f;
+  mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const xy_pos_t &pos, const bool probe_relative/*=false*/, MeshFlags *done_flags/*=nullptr*/) {
+    mesh_index_pair closest;
+    closest.invalidate();
+    closest.distance = -99999.9f;
 
-    // Get our reference position. Either the nozzle or probe location.
-    const float px = rx + (probe_as_reference == USE_PROBE_AS_REFERENCE ? probe_offset[X_AXIS] : 0),
-                py = ry + (probe_as_reference == USE_PROBE_AS_REFERENCE ? probe_offset[Y_AXIS] : 0);
+    // Get the reference position, either nozzle or probe
+    const xy_pos_t ref = probe_relative ? pos + probe_offset : pos;
 
     float best_so_far = 99999.99f;
 
     for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
-
-        if ( (type == INVALID && isnan(z_values[i][j]))  // Check to see if this location holds the right thing
-          || (type == REAL && !isnan(z_values[i][j]))
-          || (type == SET_IN_BITMAP && is_bitmap_set(bits, i, j))
+        if ( (type == (isnan(z_values[i][j]) ? INVALID : REAL))
+          || (type == SET_IN_BITMAP && !done_flags->marked(i, j))
         ) {
-          // We only get here if we found a Mesh Point of the specified type
-
-          const float mx = mesh_index_to_xpos(i),
-                      my = mesh_index_to_ypos(j);
+          // Found a Mesh Point of the specified type!
+          const xy_pos_t mpos = { mesh_index_to_xpos(i), mesh_index_to_ypos(j) };
 
           // If using the probe as the reference there are some unreachable locations.
           // Also for round beds, there are grid points outside the bed the nozzle can't reach.
           // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
-          if (probe_as_reference ? !position_is_reachable_by_probe(mx, my) : !position_is_reachable(mx, my))
+          if (probe_relative ? !position_is_reachable_by_probe(mpos) : !position_is_reachable(mpos))
             continue;
 
           // Reachable. Check if it's the best_so_far location to the nozzle.
 
-          float distance = HYPOT(px - mx, py - my);
+          const xy_pos_t diff = current_position - mpos;
+          const float distance = (ref - mpos).magnitude() + diff.magnitude() * 0.1f;
 
           // factor in the distance from the current location for the normal case
           // so the nozzle isn't running all over the bed.
-          distance += HYPOT(current_position[X_AXIS] - mx, current_position[Y_AXIS] - my) * 0.1f;
           if (distance < best_so_far) {
-            best_so_far = distance;   // We found a closer location with
-            out_mesh.x_index = i;     // the specified type of mesh value.
-            out_mesh.y_index = j;
-            out_mesh.distance = best_so_far;
+            best_so_far = distance;   // Found a closer location with the desired value type.
+            closest.pos.set(i, j);
+            closest.distance = best_so_far;
           }
         }
       } // for j
     } // for i
 
-    return out_mesh;
+    return closest;
   }
 
   /**
    * 'Smart Fill': Scan from the outward edges of the mesh towards the center.
    * If an invalid location is found, use the next two points (if valid) to
    * calculate a 'reasonable' value for the unprobed mesh point.
    */
 
   bool unified_bed_leveling::smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
-    const int8_t x1 = x + xdir, x2 = x1 + xdir,
-                 y1 = y + ydir, y2 = y1 + ydir;
-    // A NAN next to a pair of real values?
-    if (isnan(z_values[x][y]) && !isnan(z_values[x1][y1]) && !isnan(z_values[x2][y2])) {
-      if (z_values[x1][y1] < z_values[x2][y2])                  // Angled downward?
-        z_values[x][y] = z_values[x1][y1];                      // Use nearest (maybe a little too high.)
-      else
-        z_values[x][y] = 2.0f * z_values[x1][y1] - z_values[x2][y2];   // Angled upward...
-
-      #if ENABLED(EXTENSIBLE_UI)
-        ExtUI::onMeshUpdate(x, y, z_values[x][y]);
-      #endif
-
-      return true;
+    const float v = z_values[x][y];
+    if (isnan(v)) {                           // A NAN...
+      const int8_t dx = x + xdir, dy = y + ydir;
+      const float v1 = z_values[dx][dy];
+      if (!isnan(v1)) {                       // ...next to a pair of real values?
+        const float v2 = z_values[dx + xdir][dy + ydir];
+        if (!isnan(v2)) {
+          z_values[x][y] = v1 < v2 ? v1 : v1 + v1 - v2;
+          #if ENABLED(EXTENSIBLE_UI)
+            ExtUI::onMeshUpdate(x, y, z_values[pos.x][pos.y]);
+          #endif
+          return true;
+        }
+      }
     }
     return false;
   }
 
   typedef struct { uint8_t sx, ex, sy, ey; bool yfirst; } smart_fill_info;
 
   void unified_bed_leveling::smart_fill_mesh() {
     static const smart_fill_info
       info0 PROGMEM = { 0, GRID_MAX_POINTS_X,      0, GRID_MAX_POINTS_Y - 2,  false },  // Bottom of the mesh looking up
       info1 PROGMEM = { 0, GRID_MAX_POINTS_X,      GRID_MAX_POINTS_Y - 1, 0,  false },  // Top of the mesh looking down
@@ -1384,160 +1378,161 @@
     //#define VALIDATE_MESH_TILT
 
     #include "../../../libs/vector_3.h"
 
     void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
       const float x_min = probe_min_x(), x_max = probe_max_x(),
                   y_min = probe_min_y(), y_max = probe_max_y(),
                   dx = (x_max - x_min) / (g29_grid_size - 1),
                   dy = (y_max - y_min) / (g29_grid_size - 1);
 
-      vector_3 points[3] = {
+      const vector_3 points[3] = {
         #if ENABLED(HAS_FIXED_3POINT)
-          vector_3(PROBE_PT_1_X, PROBE_PT_1_Y, 0),
-          vector_3(PROBE_PT_2_X, PROBE_PT_2_Y, 0),
-          vector_3(PROBE_PT_3_X, PROBE_PT_3_Y, 0)
+          { PROBE_PT_1_X, PROBE_PT_1_Y, 0 },
+          { PROBE_PT_2_X, PROBE_PT_2_Y, 0 },
+          { PROBE_PT_3_X, PROBE_PT_3_Y, 0 }
         #else
-          vector_3(x_min, y_min, 0),
-          vector_3(x_max, y_min, 0),
-          vector_3((x_max - x_min) / 2, y_max, 0)
+          { x_min, y_min, 0 },
+          { x_max, y_min, 0 },
+          { (x_max - x_min) / 2, y_max, 0 }
         #endif
       };
 
       float measured_z;
       bool abort_flag = false;
 
       #ifdef VALIDATE_MESH_TILT
         float z1, z2, z3;  // Needed for algorithm validation below
       #endif
 
       struct linear_fit_data lsf_results;
       incremental_LSF_reset(&lsf_results);
 
       if (do_3_pt_leveling) {
         SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
         #if HAS_DISPLAY
           ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 1/3"));
         #endif
 
-        measured_z = probe_at_point(points[0].x, points[0].y, PROBE_PT_RAISE, g29_verbose_level);
+        measured_z = probe_at_point(points[0], PROBE_PT_RAISE, g29_verbose_level);
         if (isnan(measured_z))
           abort_flag = true;
         else {
-          measured_z -= get_z_correction(points[0].x, points[0].y);
+          measured_z -= get_z_correction(points[0]);
           #ifdef VALIDATE_MESH_TILT
             z1 = measured_z;
           #endif
           if (g29_verbose_level > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
-          incremental_LSF(&lsf_results, points[0].x, points[0].y, measured_z);
+          incremental_LSF(&lsf_results, points[0], measured_z);
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
           #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 2/3"));
           #endif
 
-          measured_z = probe_at_point(points[1].x, points[1].y, PROBE_PT_RAISE, g29_verbose_level);
+          measured_z = probe_at_point(points[1], PROBE_PT_RAISE, g29_verbose_level);
           #ifdef VALIDATE_MESH_TILT
             z2 = measured_z;
           #endif
           if (isnan(measured_z))
             abort_flag = true;
           else {
-            measured_z -= get_z_correction(points[1].x, points[1].y);
+            measured_z -= get_z_correction(points[1]);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
-            incremental_LSF(&lsf_results, points[1].x, points[1].y, measured_z);
+            incremental_LSF(&lsf_results, points[1], measured_z);
           }
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
           #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 3/3"));
           #endif
 
-          measured_z = probe_at_point(points[2].x, points[2].y, PROBE_PT_STOW, g29_verbose_level);
+          measured_z = probe_at_point(points[2], PROBE_PT_STOW, g29_verbose_level);
           #ifdef VALIDATE_MESH_TILT
             z3 = measured_z;
           #endif
           if (isnan(measured_z))
             abort_flag = true;
           else {
-            measured_z -= get_z_correction(points[2].x, points[2].y);
+            measured_z -= get_z_correction(points[2]);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
-            incremental_LSF(&lsf_results, points[2].x, points[2].y, measured_z);
+            incremental_LSF(&lsf_results, points[2], measured_z);
           }
         }
 
         STOW_PROBE();
         #ifdef Z_AFTER_PROBING
           move_z_after_probing();
         #endif
 
         if (abort_flag) {
           SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");
           return;
         }
       }
       else { // !do_3_pt_leveling
 
         bool zig_zag = false;
 
         uint16_t total_points = g29_grid_size * g29_grid_size, point_num = 1;
 
+        xy_pos_t rpos;
         for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
-          const float rx = x_min + ix * dx;
+          rpos.x = x_min + ix * dx;
           for (int8_t iy = 0; iy < g29_grid_size; iy++) {
-            const float ry = y_min + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
+            rpos.y = y_min + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
 
             if (!abort_flag) {
               SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
               #if HAS_DISPLAY
                 ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " %i/%i"), point_num, total_points);
               #endif
 
-              measured_z = probe_at_point(rx, ry, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
+              measured_z = probe_at_point(rpos, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
 
               abort_flag = isnan(measured_z);
 
               if (DEBUGGING(LEVELING)) {
+                const xy_pos_t lpos = rpos.asLogical();
                 DEBUG_CHAR('(');
-                DEBUG_ECHO_F(rx, 7);
+                DEBUG_ECHO_F(rpos.x, 7);
                 DEBUG_CHAR(',');
-                DEBUG_ECHO_F(ry, 7);
-                DEBUG_ECHOPGM(")   logical: (");
-                DEBUG_ECHO_F(LOGICAL_X_POSITION(rx), 7);
+                DEBUG_ECHO_F(rpos.y, 7);
+                DEBUG_ECHOPAIR_F(")   logical: (", lpos.x, 7);
                 DEBUG_CHAR(',');
-                DEBUG_ECHO_F(LOGICAL_Y_POSITION(ry), 7);
+                DEBUG_ECHO_F(lpos.y, 7);
                 DEBUG_ECHOPAIR_F(")   measured: ", measured_z, 7);
-                DEBUG_ECHOPAIR_F("   correction: ", get_z_correction(rx, ry), 7);
+                DEBUG_ECHOPAIR_F("   correction: ", get_z_correction(rpos), 7);
               }
 
-              measured_z -= get_z_correction(rx, ry) /* + probe_offset[Z_AXIS] */ ;
+              measured_z -= get_z_correction(rpos) /* + probe_offset.z */ ;
 
               if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("   final >>>---> ", measured_z, 7);
 
               if (g29_verbose_level > 3) {
                 serial_spaces(16);
                 SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
               }
-              incremental_LSF(&lsf_results, rx, ry, measured_z);
+              incremental_LSF(&lsf_results, rpos, measured_z);
             }
 
             point_num++;
           }
 
           zig_zag ^= true;
         }
       }
       STOW_PROBE();
       #ifdef Z_AFTER_PROBING
@@ -1557,47 +1552,47 @@
         SERIAL_ECHO_F(normal.y, 7);
         SERIAL_CHAR(',');
         SERIAL_ECHO_F(normal.z, 7);
         SERIAL_ECHOLNPGM("]");
       }
 
       matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
 
       for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
         for (uint8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
-          float x_tmp = mesh_index_to_xpos(i),
-                y_tmp = mesh_index_to_ypos(j),
-                z_tmp = z_values[i][j];
+          float mx = mesh_index_to_xpos(i),
+                my = mesh_index_to_ypos(j),
+                mz = z_values[i][j];
 
           if (DEBUGGING(LEVELING)) {
-            DEBUG_ECHOPAIR_F("before rotation = [", x_tmp, 7);
+            DEBUG_ECHOPAIR_F("before rotation = [", mx, 7);
             DEBUG_CHAR(',');
-            DEBUG_ECHO_F(y_tmp, 7);
+            DEBUG_ECHO_F(my, 7);
             DEBUG_CHAR(',');
-            DEBUG_ECHO_F(z_tmp, 7);
+            DEBUG_ECHO_F(mz, 7);
             DEBUG_ECHOPGM("]   ---> ");
             DEBUG_DELAY(20);
           }
 
-          apply_rotation_xyz(rotation, x_tmp, y_tmp, z_tmp);
+          apply_rotation_xyz(rotation, mx, my, mz);
 
           if (DEBUGGING(LEVELING)) {
-            DEBUG_ECHOPAIR_F("after rotation = [", x_tmp, 7);
+            DEBUG_ECHOPAIR_F("after rotation = [", mx, 7);
             DEBUG_CHAR(',');
-            DEBUG_ECHO_F(y_tmp, 7);
+            DEBUG_ECHO_F(my, 7);
             DEBUG_CHAR(',');
-            DEBUG_ECHO_F(z_tmp, 7);
+            DEBUG_ECHO_F(mz, 7);
             DEBUG_ECHOLNPGM("]");
-            DEBUG_DELAY(55);
+            DEBUG_DELAY(20);
           }
 
-          z_values[i][j] = z_tmp - lsf_results.D;
+          z_values[i][j] = mz - lsf_results.D;
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(i, j, z_values[i][j]);
           #endif
         }
       }
 
       if (DEBUGGING(LEVELING)) {
         rotation.debug(PSTR("rotation matrix:\n"));
         DEBUG_ECHOPAIR_F("LSF Results A=", lsf_results.A, 7);
         DEBUG_ECHOPAIR_F("  B=", lsf_results.B, 7);
@@ -1606,55 +1601,46 @@
 
         DEBUG_ECHOPAIR_F("bed plane normal = [", normal.x, 7);
         DEBUG_CHAR(',');
         DEBUG_ECHO_F(normal.y, 7);
         DEBUG_CHAR(',');
         DEBUG_ECHO_F(normal.z, 7);
         DEBUG_ECHOLNPGM("]");
         DEBUG_EOL();
 
         /**
-         * The following code can be used to check the validity of the mesh tilting algorithm.
-         * When a 3-Point Mesh Tilt is done, the same algorithm is used as the grid based tilting.
-         * The only difference is just 3 points are used in the calculations.   That fact guarantees
-         * each probed point should have an exact match when a get_z_correction() for that location
-         * is calculated.  The Z error between the probed point locations and the get_z_correction()
+         * Use the code below to check the validity of the mesh tilting algorithm.
+         * 3-Point Mesh Tilt uses the same algorithm as grid-based tilting, but only
+         * three points are used in the calculation. This guarantees that each probed point
+         * has an exact match when get_z_correction() for that location is calculated.
+         * The Z error between the probed point locations and the get_z_correction()
          * numbers for those locations should be 0.
          */
         #ifdef VALIDATE_MESH_TILT
-          float t, t1, d;
-          t = normal.x * x_min + normal.y * y_min;
-          d = t + normal.z * z1;
-          DEBUG_ECHOPAIR_F("D from 1st point: ", d, 6);
-          DEBUG_ECHOLNPAIR_F("   Z error: ", normal.z * z1 - get_z_correction(x_min, y_min), 6);
-
-          t = normal.x * x_max + normal.y * y_min;
-          d = t + normal.z * z2;
-          DEBUG_EOL();
-          DEBUG_ECHOPAIR_F("D from 2nd point: ", d, 6);
-          DEBUG_ECHOLNPAIR_F("   Z error: ", normal.z * z2 - get_z_correction(x_max, y_min), 6);
-
-          t = normal.x * ((x_max - x_min) / 2) + normal.y * (y_min);
-          d = t + normal.z * z3;
-          DEBUG_ECHOPAIR_F("D from 3rd point: ", d, 6);
-          DEBUG_ECHOLNPAIR_F("   Z error: ", normal.z * z3 - get_z_correction((x_max - x_min) / 2, y_max), 6);
-
-          t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
-          d = t + normal.z * 0;
-          DEBUG_ECHOLNPAIR_F("D from home location with Z=0 : ", d, 6);
-
-          t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
-          d = t + get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT); // normal.z * 0;
-          DEBUG_ECHOPAIR_F("D from home location using mesh value for Z: ", d, 6);
-
+          auto d_from = []() { DEBUG_ECHOPGM("D from "); };
+          auto normed = [&](const xy_pos_t &pos, const float &zadd) {
+            return normal.x * pos.x + normal.y * pos.y + zadd;
+          };
+          auto debug_pt = [](PGM_P const pre, const xy_pos_t &pos, const float &zadd) {
+            d_from(); serialprintPGM(pre);
+            DEBUG_ECHO_F(normed(pos, zadd), 6);
+            DEBUG_ECHOLNPAIR_F("   Z error: ", zadd - get_z_correction(pos), 6);
+          };
+          debug_pt(PSTR("1st point: "), probe_pt[0], normal.z * z1);
+          debug_pt(PSTR("2nd point: "), probe_pt[1], normal.z * z2);
+          debug_pt(PSTR("3rd point: "), probe_pt[2], normal.z * z3);
+          d_from(); DEBUG_ECHOPGM("safe home with Z=");
+          DEBUG_ECHOLNPAIR_F("0 : ", normed(safe_homing_xy, 0), 6);
+          d_from(); DEBUG_ECHOPGM("safe home with Z=");
+          DEBUG_ECHOLNPAIR_F("mesh value ", normed(safe_homing_xy, get_z_correction(safe_homing_xy)), 6);
           DEBUG_ECHOPAIR("   Z error: (", Z_SAFE_HOMING_X_POINT, ",", Z_SAFE_HOMING_Y_POINT);
-          DEBUG_ECHOLNPAIR_F(") = ", get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT), 6);
+          DEBUG_ECHOLNPAIR_F(") = ", get_z_correction(safe_homing_xy), 6);
         #endif
       } // DEBUGGING(LEVELING)
 
     }
 
   #endif // HAS_BED_PROBE
 
   #if ENABLED(UBL_G29_P31)
     void unified_bed_leveling::smart_fill_wlsf(const float &weight_factor) {
 
@@ -1669,48 +1655,50 @@
 
       SERIAL_ECHOPGM("Extrapolating mesh...");
 
       const float weight_scaled = weight_factor * _MAX(MESH_X_DIST, MESH_Y_DIST);
 
       for (uint8_t jx = 0; jx < GRID_MAX_POINTS_X; jx++)
         for (uint8_t jy = 0; jy < GRID_MAX_POINTS_Y; jy++)
           if (!isnan(z_values[jx][jy]))
             SBI(bitmap[jx], jy);
 
+      xy_pos_t ppos;
       for (uint8_t ix = 0; ix < GRID_MAX_POINTS_X; ix++) {
-        const float px = mesh_index_to_xpos(ix);
+        ppos.x = mesh_index_to_xpos(ix);
         for (uint8_t iy = 0; iy < GRID_MAX_POINTS_Y; iy++) {
-          const float py = mesh_index_to_ypos(iy);
+          ppos.y = mesh_index_to_ypos(iy);
           if (isnan(z_values[ix][iy])) {
-            // undefined mesh point at (px,py), compute weighted LSF from original valid mesh points.
+            // undefined mesh point at (ppos.x,ppos.y), compute weighted LSF from original valid mesh points.
             incremental_LSF_reset(&lsf_results);
+            xy_pos_t rpos;
             for (uint8_t jx = 0; jx < GRID_MAX_POINTS_X; jx++) {
-              const float rx = mesh_index_to_xpos(jx);
+              rpos.x = mesh_index_to_xpos(jx);
               for (uint8_t jy = 0; jy < GRID_MAX_POINTS_Y; jy++) {
                 if (TEST(bitmap[jx], jy)) {
-                  const float ry = mesh_index_to_ypos(jy),
-                              rz = z_values[jx][jy],
-                              w  = 1 + weight_scaled / HYPOT((rx - px), (ry - py));
-                  incremental_WLSF(&lsf_results, rx, ry, rz, w);
+                  rpos.y = mesh_index_to_ypos(jy);
+                  const float rz = z_values[jx][jy],
+                               w = 1.0f + weight_scaled / (rpos - ppos).magnitude();
+                  incremental_WLSF(&lsf_results, rpos, rz, w);
                 }
               }
             }
             if (finish_incremental_LSF(&lsf_results)) {
               SERIAL_ECHOLNPGM("Insufficient data");
               return;
             }
-            const float ez = -lsf_results.D - lsf_results.A * px - lsf_results.B * py;
+            const float ez = -lsf_results.D - lsf_results.A * ppos.x - lsf_results.B * ppos.y;
             z_values[ix][iy] = ez;
             #if ENABLED(EXTENSIBLE_UI)
               ExtUI::onMeshUpdate(ix, iy, z_values[ix][iy]);
             #endif
-            idle();   // housekeeping
+            idle(); // housekeeping
           }
         }
       }
 
       SERIAL_ECHOLNPGM("done");
     }
   #endif // UBL_G29_P31
 
   #if ENABLED(UBL_DEVEL_DEBUGGING)
     /**
@@ -1727,21 +1715,21 @@
       SERIAL_EOL();
       serial_delay(50);
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         SERIAL_ECHOLNPAIR_F("Fade Height M420 Z", planner.z_fade_height, 4);
       #endif
 
       adjust_mesh_to_mean(g29_c_flag, g29_constant);
 
       #if HAS_BED_PROBE
-        SERIAL_ECHOLNPAIR_F("Probe Offset M851 Z", probe_offset[Z_AXIS], 7);
+        SERIAL_ECHOLNPAIR_F("Probe Offset M851 Z", probe_offset.z, 7);
       #endif
 
       SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); serial_delay(50);
       SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             serial_delay(50);
       SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);             serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_X_DIST  ", MESH_X_DIST);
       SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);                         serial_delay(50);

commit a6b0223eead964237e7920c35bb3c7757b722139
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Sep 28 02:19:11 2019 -0400

    Revive and improve DELTA probe bounds, LRFB options (#15372)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 2ffeb17e2f..54c7666bac 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1384,93 +1384,104 @@
     //#define VALIDATE_MESH_TILT
 
     #include "../../../libs/vector_3.h"
 
     void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
       const float x_min = probe_min_x(), x_max = probe_max_x(),
                   y_min = probe_min_y(), y_max = probe_max_y(),
                   dx = (x_max - x_min) / (g29_grid_size - 1),
                   dy = (y_max - y_min) / (g29_grid_size - 1);
 
+      vector_3 points[3] = {
+        #if ENABLED(HAS_FIXED_3POINT)
+          vector_3(PROBE_PT_1_X, PROBE_PT_1_Y, 0),
+          vector_3(PROBE_PT_2_X, PROBE_PT_2_Y, 0),
+          vector_3(PROBE_PT_3_X, PROBE_PT_3_Y, 0)
+        #else
+          vector_3(x_min, y_min, 0),
+          vector_3(x_max, y_min, 0),
+          vector_3((x_max - x_min) / 2, y_max, 0)
+        #endif
+      };
+
       float measured_z;
       bool abort_flag = false;
 
       #ifdef VALIDATE_MESH_TILT
         float z1, z2, z3;  // Needed for algorithm validation below
       #endif
 
       struct linear_fit_data lsf_results;
       incremental_LSF_reset(&lsf_results);
 
       if (do_3_pt_leveling) {
         SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
         #if HAS_DISPLAY
           ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 1/3"));
         #endif
 
-        measured_z = probe_at_point(x_min, y_min, PROBE_PT_RAISE, g29_verbose_level);
+        measured_z = probe_at_point(points[0].x, points[0].y, PROBE_PT_RAISE, g29_verbose_level);
         if (isnan(measured_z))
           abort_flag = true;
         else {
-          measured_z -= get_z_correction(x_min, y_min);
+          measured_z -= get_z_correction(points[0].x, points[0].y);
           #ifdef VALIDATE_MESH_TILT
             z1 = measured_z;
           #endif
           if (g29_verbose_level > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
-          incremental_LSF(&lsf_results, x_min, y_min, measured_z);
+          incremental_LSF(&lsf_results, points[0].x, points[0].y, measured_z);
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
           #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 2/3"));
           #endif
 
-          measured_z = probe_at_point(x_max, y_min, PROBE_PT_RAISE, g29_verbose_level);
+          measured_z = probe_at_point(points[1].x, points[1].y, PROBE_PT_RAISE, g29_verbose_level);
           #ifdef VALIDATE_MESH_TILT
             z2 = measured_z;
           #endif
           if (isnan(measured_z))
             abort_flag = true;
           else {
-            measured_z -= get_z_correction(x_max, y_min);
+            measured_z -= get_z_correction(points[1].x, points[1].y);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
-            incremental_LSF(&lsf_results, x_max, y_min, measured_z);
+            incremental_LSF(&lsf_results, points[1].x, points[1].y, measured_z);
           }
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
           #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 3/3"));
           #endif
 
-          const float center_probe = (x_max - x_min) / 2;
-          measured_z = probe_at_point(center_probe, y_max, PROBE_PT_STOW, g29_verbose_level);
+          measured_z = probe_at_point(points[2].x, points[2].y, PROBE_PT_STOW, g29_verbose_level);
           #ifdef VALIDATE_MESH_TILT
             z3 = measured_z;
           #endif
           if (isnan(measured_z))
             abort_flag = true;
           else {
-            measured_z -= get_z_correction(center_probe, y_max);
+            measured_z -= get_z_correction(points[2].x, points[2].y);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
-            incremental_LSF(&lsf_results, center_probe, y_max, measured_z);
+            incremental_LSF(&lsf_results, points[2].x, points[2].y, measured_z);
           }
         }
 
         STOW_PROBE();
         #ifdef Z_AFTER_PROBING
           move_z_after_probing();
         #endif
 
         if (abort_flag) {
           SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");

commit b2e1f77f58a67ac02503cbe36b22a21e5afaeac0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 25 21:01:29 2019 -0500

    Fix extraneous "Home XYZ First" message

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 9e29042778..2ffeb17e2f 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -306,21 +306,21 @@
 
     bool probe_deployed = false;
     if (g29_parameter_parsing()) return; // Abort on parameter error
 
     const int8_t p_val = parser.intval('P', -1);
     const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J');
 
     // Check for commands that require the printer to be homed
     if (may_move) {
       planner.synchronize();
-      if (axis_unhomed_error()) gcode.home_all_axes();
+      if (axes_need_homing()) gcode.home_all_axes();
       #if ENABLED(DUAL_X_CARRIAGE)
         if (active_extruder != 0) tool_change(0);
       #endif
     }
 
     // Invalidate Mesh Points. This command is a little bit asymmetrical because
     // it directly specifies the repetition count and does not use the 'R' parameter.
     if (parser.seen('I')) {
       uint8_t cnt = 0;
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : 1;

commit e9cf46a9a5d0f6aa5521497d25aab5ff4e12399c
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Sep 25 03:43:41 2019 -0400

    M851 XY 3 point followup (incomplete) (#15361)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 253c9159ad..9e29042778 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1374,92 +1374,103 @@
         const int8_t dir = ey > sy ? 1 : -1;
          for (uint8_t x = sx; x != ex; ++x)
           for (uint8_t y = sy; y != ey; y += dir)
             if (smart_fill_one(x, y, 0, dir)) break;
       }
     }
   }
 
   #if HAS_BED_PROBE
 
+    //#define VALIDATE_MESH_TILT
+
     #include "../../../libs/vector_3.h"
 
     void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
       const float x_min = probe_min_x(), x_max = probe_max_x(),
                   y_min = probe_min_y(), y_max = probe_max_y(),
                   dx = (x_max - x_min) / (g29_grid_size - 1),
                   dy = (y_max - y_min) / (g29_grid_size - 1);
 
       float measured_z;
       bool abort_flag = false;
 
-      //float z1, z2, z3;  // Needed for algorithm validation below
+      #ifdef VALIDATE_MESH_TILT
+        float z1, z2, z3;  // Needed for algorithm validation below
+      #endif
 
       struct linear_fit_data lsf_results;
       incremental_LSF_reset(&lsf_results);
 
       if (do_3_pt_leveling) {
         SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
         #if HAS_DISPLAY
           ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 1/3"));
         #endif
 
-        measured_z = probe_at_point(PROBE_PT_1_X, PROBE_PT_1_Y, PROBE_PT_RAISE, g29_verbose_level);
+        measured_z = probe_at_point(x_min, y_min, PROBE_PT_RAISE, g29_verbose_level);
         if (isnan(measured_z))
           abort_flag = true;
         else {
-          measured_z -= get_z_correction(PROBE_PT_1_X, PROBE_PT_1_Y);
-          //z1 = measured_z;
+          measured_z -= get_z_correction(x_min, y_min);
+          #ifdef VALIDATE_MESH_TILT
+            z1 = measured_z;
+          #endif
           if (g29_verbose_level > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
-          incremental_LSF(&lsf_results, PROBE_PT_1_X, PROBE_PT_1_Y, measured_z);
+          incremental_LSF(&lsf_results, x_min, y_min, measured_z);
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
           #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 2/3"));
           #endif
 
-          measured_z = probe_at_point(PROBE_PT_2_X, PROBE_PT_2_Y, PROBE_PT_RAISE, g29_verbose_level);
-          //z2 = measured_z;
+          measured_z = probe_at_point(x_max, y_min, PROBE_PT_RAISE, g29_verbose_level);
+          #ifdef VALIDATE_MESH_TILT
+            z2 = measured_z;
+          #endif
           if (isnan(measured_z))
             abort_flag = true;
           else {
-            measured_z -= get_z_correction(PROBE_PT_2_X, PROBE_PT_2_Y);
+            measured_z -= get_z_correction(x_max, y_min);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
-            incremental_LSF(&lsf_results, PROBE_PT_2_X, PROBE_PT_2_Y, measured_z);
+            incremental_LSF(&lsf_results, x_max, y_min, measured_z);
           }
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
           #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 3/3"));
           #endif
 
-          measured_z = probe_at_point(PROBE_PT_3_X, PROBE_PT_3_Y, PROBE_PT_STOW, g29_verbose_level);
-          //z3 = measured_z;
+          const float center_probe = (x_max - x_min) / 2;
+          measured_z = probe_at_point(center_probe, y_max, PROBE_PT_STOW, g29_verbose_level);
+          #ifdef VALIDATE_MESH_TILT
+            z3 = measured_z;
+          #endif
           if (isnan(measured_z))
             abort_flag = true;
           else {
-            measured_z -= get_z_correction(PROBE_PT_3_X, PROBE_PT_3_Y);
+            measured_z -= get_z_correction(center_probe, y_max);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
-            incremental_LSF(&lsf_results, PROBE_PT_3_X, PROBE_PT_3_Y, measured_z);
+            incremental_LSF(&lsf_results, center_probe, y_max, measured_z);
           }
         }
 
         STOW_PROBE();
         #ifdef Z_AFTER_PROBING
           move_z_after_probing();
         #endif
 
         if (abort_flag) {
           SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");
@@ -1591,48 +1602,48 @@
         DEBUG_EOL();
 
         /**
          * The following code can be used to check the validity of the mesh tilting algorithm.
          * When a 3-Point Mesh Tilt is done, the same algorithm is used as the grid based tilting.
          * The only difference is just 3 points are used in the calculations.   That fact guarantees
          * each probed point should have an exact match when a get_z_correction() for that location
          * is calculated.  The Z error between the probed point locations and the get_z_correction()
          * numbers for those locations should be 0.
          */
-        #if 0
-        float t, t1, d;
-        t = normal.x * (PROBE_PT_1_X) + normal.y * (PROBE_PT_1_Y);
-        d = t + normal.z * z1;
-        DEBUG_ECHOPAIR_F("D from 1st point: ", d, 6);
-        DEBUG_ECHOLNPAIR_F("   Z error: ", normal.z*z1-get_z_correction(PROBE_PT_1_X, PROBE_PT_1_Y), 6);
-
-        t = normal.x * (PROBE_PT_2_X) + normal.y * (PROBE_PT_2_Y);
-        d = t + normal.z * z2;
-        DEBUG_EOL();
-        DEBUG_ECHOPAIR_F("D from 2nd point: ", d, 6);
-        DEBUG_ECHOLNPAIR_F("   Z error: ", normal.z*z2-get_z_correction(PROBE_PT_2_X, PROBE_PT_2_Y), 6);
-
-        t = normal.x * (PROBE_PT_3_X) + normal.y * (PROBE_PT_3_Y);
-        d = t + normal.z * z3;
-        DEBUG_ECHOPAIR_F("D from 3rd point: ", d, 6);
-        DEBUG_ECHOLNPAIR_F("   Z error: ", normal.z*z3-get_z_correction(PROBE_PT_3_X, PROBE_PT_3_Y), 6);
-
-        t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
-        d = t + normal.z * 0;
-        DEBUG_ECHOLNPAIR_F("D from home location with Z=0 : ", d, 6);
-
-        t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
-        d = t + get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT); // normal.z * 0;
-        DEBUG_ECHOPAIR_F("D from home location using mesh value for Z: ", d, 6);
-
-        DEBUG_ECHOPAIR("   Z error: (", Z_SAFE_HOMING_X_POINT, ",", Z_SAFE_HOMING_Y_POINT);
-        DEBUG_ECHOLNPAIR_F(") = ", get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT), 6);
+        #ifdef VALIDATE_MESH_TILT
+          float t, t1, d;
+          t = normal.x * x_min + normal.y * y_min;
+          d = t + normal.z * z1;
+          DEBUG_ECHOPAIR_F("D from 1st point: ", d, 6);
+          DEBUG_ECHOLNPAIR_F("   Z error: ", normal.z * z1 - get_z_correction(x_min, y_min), 6);
+
+          t = normal.x * x_max + normal.y * y_min;
+          d = t + normal.z * z2;
+          DEBUG_EOL();
+          DEBUG_ECHOPAIR_F("D from 2nd point: ", d, 6);
+          DEBUG_ECHOLNPAIR_F("   Z error: ", normal.z * z2 - get_z_correction(x_max, y_min), 6);
+
+          t = normal.x * ((x_max - x_min) / 2) + normal.y * (y_min);
+          d = t + normal.z * z3;
+          DEBUG_ECHOPAIR_F("D from 3rd point: ", d, 6);
+          DEBUG_ECHOLNPAIR_F("   Z error: ", normal.z * z3 - get_z_correction((x_max - x_min) / 2, y_max), 6);
+
+          t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
+          d = t + normal.z * 0;
+          DEBUG_ECHOLNPAIR_F("D from home location with Z=0 : ", d, 6);
+
+          t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
+          d = t + get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT); // normal.z * 0;
+          DEBUG_ECHOPAIR_F("D from home location using mesh value for Z: ", d, 6);
+
+          DEBUG_ECHOPAIR("   Z error: (", Z_SAFE_HOMING_X_POINT, ",", Z_SAFE_HOMING_Y_POINT);
+          DEBUG_ECHOLNPAIR_F(") = ", get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT), 6);
         #endif
       } // DEBUGGING(LEVELING)
 
     }
 
   #endif // HAS_BED_PROBE
 
   #if ENABLED(UBL_G29_P31)
     void unified_bed_leveling::smart_fill_wlsf(const float &weight_factor) {
 

commit 4e8d9fe59b53fc5937d907fcf6d79b58233ab6ef
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 24 23:35:49 2019 -0500

    zprobe_offset => probe_offset

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index e588515f62..253c9159ad 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -446,21 +446,21 @@
             if (!parser.seen('C')) {
               invalidate();
               SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
             }
             if (g29_verbose_level > 1) {
               SERIAL_ECHOPAIR("Probing around (", g29_x_pos);
               SERIAL_CHAR(',');
               SERIAL_ECHO(g29_y_pos);
               SERIAL_ECHOLNPGM(").\n");
             }
-            probe_entire_mesh(g29_x_pos + zprobe_offset[X_AXIS], g29_y_pos + zprobe_offset[Y_AXIS],
+            probe_entire_mesh(g29_x_pos + probe_offset[X_AXIS], g29_y_pos + probe_offset[Y_AXIS],
                               parser.seen('T'), parser.seen('E'), parser.seen('U'));
 
             report_current_position();
             probe_deployed = true;
           } break;
 
         #endif // HAS_BED_PROBE
 
         case 2: {
           #if HAS_LCD_MENU
@@ -475,22 +475,22 @@
                * Use a good default location for the path.
                * The flipped > and < operators in these comparisons is intentional.
                * It should cause the probed points to follow a nice path on Cartesian printers.
                * It may make sense to have Delta printers default to the center of the bed.
                * Until that is decided, this can be forced with the X and Y parameters.
                */
               #if IS_KINEMATIC
                 g29_x_pos = X_HOME_POS;
                 g29_y_pos = Y_HOME_POS;
               #else // cartesian
-                g29_x_pos = zprobe_offset[X_AXIS] > 0 ? X_BED_SIZE : 0;
-                g29_y_pos = zprobe_offset[Y_AXIS] < 0 ? Y_BED_SIZE : 0;
+                g29_x_pos = probe_offset[X_AXIS] > 0 ? X_BED_SIZE : 0;
+                g29_y_pos = probe_offset[Y_AXIS] < 0 ? Y_BED_SIZE : 0;
               #endif
             }
 
             if (parser.seen('B')) {
               g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness((float) Z_CLEARANCE_BETWEEN_PROBES);
               if (ABS(g29_card_thickness) > 1.5f) {
                 SERIAL_ECHOLNPGM("?Error in Business Card measurement.");
                 return;
               }
               probe_deployed = true;
@@ -793,22 +793,22 @@
 
       STOW_PROBE();
 
       #ifdef Z_AFTER_PROBING
         move_z_after_probing();
       #endif
 
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
-        constrain(rx - zprobe_offset[X_AXIS], MESH_MIN_X, MESH_MAX_X),
-        constrain(ry - zprobe_offset[Y_AXIS], MESH_MIN_Y, MESH_MAX_Y)
+        constrain(rx - probe_offset[X_AXIS], MESH_MIN_X, MESH_MAX_X),
+        constrain(ry - probe_offset[Y_AXIS], MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 
   #endif // HAS_BED_PROBE
 
   #if HAS_LCD_MENU
 
     typedef void (*clickFunc_t)();
 
     bool click_and_hold(const clickFunc_t func=nullptr) {
@@ -1274,22 +1274,22 @@
     }
     return out_mesh;
   }
 
   mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const float &rx, const float &ry, const bool probe_as_reference, uint16_t bits[16]) {
     mesh_index_pair out_mesh;
     out_mesh.x_index = out_mesh.y_index = -1;
     out_mesh.distance = -99999.9f;
 
     // Get our reference position. Either the nozzle or probe location.
-    const float px = rx + (probe_as_reference == USE_PROBE_AS_REFERENCE ? zprobe_offset[X_AXIS] : 0),
-                py = ry + (probe_as_reference == USE_PROBE_AS_REFERENCE ? zprobe_offset[Y_AXIS] : 0);
+    const float px = rx + (probe_as_reference == USE_PROBE_AS_REFERENCE ? probe_offset[X_AXIS] : 0),
+                py = ry + (probe_as_reference == USE_PROBE_AS_REFERENCE ? probe_offset[Y_AXIS] : 0);
 
     float best_so_far = 99999.99f;
 
     for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
 
         if ( (type == INVALID && isnan(z_values[i][j]))  // Check to see if this location holds the right thing
           || (type == REAL && !isnan(z_values[i][j]))
           || (type == SET_IN_BITMAP && is_bitmap_set(bits, i, j))
         ) {
@@ -1493,21 +1493,21 @@
                 DEBUG_CHAR(',');
                 DEBUG_ECHO_F(ry, 7);
                 DEBUG_ECHOPGM(")   logical: (");
                 DEBUG_ECHO_F(LOGICAL_X_POSITION(rx), 7);
                 DEBUG_CHAR(',');
                 DEBUG_ECHO_F(LOGICAL_Y_POSITION(ry), 7);
                 DEBUG_ECHOPAIR_F(")   measured: ", measured_z, 7);
                 DEBUG_ECHOPAIR_F("   correction: ", get_z_correction(rx, ry), 7);
               }
 
-              measured_z -= get_z_correction(rx, ry) /* + zprobe_offset[Z_AXIS] */ ;
+              measured_z -= get_z_correction(rx, ry) /* + probe_offset[Z_AXIS] */ ;
 
               if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("   final >>>---> ", measured_z, 7);
 
               if (g29_verbose_level > 3) {
                 serial_spaces(16);
                 SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
               }
               incremental_LSF(&lsf_results, rx, ry, measured_z);
             }
 
@@ -1705,21 +1705,21 @@
       SERIAL_EOL();
       serial_delay(50);
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         SERIAL_ECHOLNPAIR_F("Fade Height M420 Z", planner.z_fade_height, 4);
       #endif
 
       adjust_mesh_to_mean(g29_c_flag, g29_constant);
 
       #if HAS_BED_PROBE
-        SERIAL_ECHOLNPAIR_F("Probe Offset M851 Z", zprobe_offset[Z_AXIS], 7);
+        SERIAL_ECHOLNPAIR_F("Probe Offset M851 Z", probe_offset[Z_AXIS], 7);
       #endif
 
       SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); serial_delay(50);
       SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             serial_delay(50);
       SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);             serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_X_DIST  ", MESH_X_DIST);
       SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);                         serial_delay(50);

commit df1e51258a8bcc432deed9f5bd60df41a75b2c32
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Sep 24 22:29:21 2019 -0400

    Add M851 X Y probe offsets (#15202)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 9ee05a5a73..e588515f62 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -283,21 +283,21 @@
    *   Release Notes:
    *   You MUST do M502, M500 to initialize the storage. Failure to do this will cause all
    *   kinds of problems. Enabling EEPROM Storage is required.
    *
    *   When you do a G28 and G29 P1 to automatically build your first mesh, you are going to notice that
    *   UBL probes points increasingly further from the starting location. (The starting location defaults
    *   to the center of the bed.) In contrast, ABL and MBL follow a zigzag pattern. The spiral pattern is
    *   especially better for Delta printers, since it populates the center of the mesh first, allowing for
    *   a quicker test print to verify settings. You don't need to populate the entire mesh to use it.
    *   After all, you don't want to spend a lot of time generating a mesh only to realize the resolution
-   *   or zprobe_zoffset are incorrect. Mesh-generation gathers points starting closest to the nozzle unless
+   *   or probe offsets are incorrect. Mesh-generation gathers points starting closest to the nozzle unless
    *   an (X,Y) coordinate pair is given.
    *
    *   Unified Bed Leveling uses a lot of EEPROM storage to hold its data, and it takes some effort to get
    *   the mesh just right. To prevent this valuable data from being destroyed as the EEPROM structure
    *   evolves, UBL stores all mesh data at the end of EEPROM.
    *
    *   UBL is founded on Edward Patel's Mesh Bed Leveling code. A big 'Thanks!' to him and the creators of
    *   3-Point and Grid Based leveling. Combining their contributions we now have the functionality and
    *   features of all three systems combined.
    */
@@ -446,21 +446,21 @@
             if (!parser.seen('C')) {
               invalidate();
               SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
             }
             if (g29_verbose_level > 1) {
               SERIAL_ECHOPAIR("Probing around (", g29_x_pos);
               SERIAL_CHAR(',');
               SERIAL_ECHO(g29_y_pos);
               SERIAL_ECHOLNPGM(").\n");
             }
-            probe_entire_mesh(g29_x_pos + X_PROBE_OFFSET_FROM_EXTRUDER, g29_y_pos + Y_PROBE_OFFSET_FROM_EXTRUDER,
+            probe_entire_mesh(g29_x_pos + zprobe_offset[X_AXIS], g29_y_pos + zprobe_offset[Y_AXIS],
                               parser.seen('T'), parser.seen('E'), parser.seen('U'));
 
             report_current_position();
             probe_deployed = true;
           } break;
 
         #endif // HAS_BED_PROBE
 
         case 2: {
           #if HAS_LCD_MENU
@@ -475,22 +475,22 @@
                * Use a good default location for the path.
                * The flipped > and < operators in these comparisons is intentional.
                * It should cause the probed points to follow a nice path on Cartesian printers.
                * It may make sense to have Delta printers default to the center of the bed.
                * Until that is decided, this can be forced with the X and Y parameters.
                */
               #if IS_KINEMATIC
                 g29_x_pos = X_HOME_POS;
                 g29_y_pos = Y_HOME_POS;
               #else // cartesian
-                g29_x_pos = X_PROBE_OFFSET_FROM_EXTRUDER > 0 ? X_BED_SIZE : 0;
-                g29_y_pos = Y_PROBE_OFFSET_FROM_EXTRUDER < 0 ? Y_BED_SIZE : 0;
+                g29_x_pos = zprobe_offset[X_AXIS] > 0 ? X_BED_SIZE : 0;
+                g29_y_pos = zprobe_offset[Y_AXIS] < 0 ? Y_BED_SIZE : 0;
               #endif
             }
 
             if (parser.seen('B')) {
               g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness((float) Z_CLEARANCE_BETWEEN_PROBES);
               if (ABS(g29_card_thickness) > 1.5f) {
                 SERIAL_ECHOLNPGM("?Error in Business Card measurement.");
                 return;
               }
               probe_deployed = true;
@@ -793,22 +793,22 @@
 
       STOW_PROBE();
 
       #ifdef Z_AFTER_PROBING
         move_z_after_probing();
       #endif
 
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
-        constrain(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_X, MESH_MAX_X),
-        constrain(ry - (Y_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_Y, MESH_MAX_Y)
+        constrain(rx - zprobe_offset[X_AXIS], MESH_MIN_X, MESH_MAX_X),
+        constrain(ry - zprobe_offset[Y_AXIS], MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 
   #endif // HAS_BED_PROBE
 
   #if HAS_LCD_MENU
 
     typedef void (*clickFunc_t)();
 
     bool click_and_hold(const clickFunc_t func=nullptr) {
@@ -1274,22 +1274,22 @@
     }
     return out_mesh;
   }
 
   mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const float &rx, const float &ry, const bool probe_as_reference, uint16_t bits[16]) {
     mesh_index_pair out_mesh;
     out_mesh.x_index = out_mesh.y_index = -1;
     out_mesh.distance = -99999.9f;
 
     // Get our reference position. Either the nozzle or probe location.
-    const float px = rx + (probe_as_reference == USE_PROBE_AS_REFERENCE ? X_PROBE_OFFSET_FROM_EXTRUDER : 0),
-                py = ry + (probe_as_reference == USE_PROBE_AS_REFERENCE ? Y_PROBE_OFFSET_FROM_EXTRUDER : 0);
+    const float px = rx + (probe_as_reference == USE_PROBE_AS_REFERENCE ? zprobe_offset[X_AXIS] : 0),
+                py = ry + (probe_as_reference == USE_PROBE_AS_REFERENCE ? zprobe_offset[Y_AXIS] : 0);
 
     float best_so_far = 99999.99f;
 
     for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
 
         if ( (type == INVALID && isnan(z_values[i][j]))  // Check to see if this location holds the right thing
           || (type == REAL && !isnan(z_values[i][j]))
           || (type == SET_IN_BITMAP && is_bitmap_set(bits, i, j))
         ) {
@@ -1377,36 +1377,31 @@
             if (smart_fill_one(x, y, 0, dir)) break;
       }
     }
   }
 
   #if HAS_BED_PROBE
 
     #include "../../../libs/vector_3.h"
 
     void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
-      constexpr int16_t x_min = _MAX(MIN_PROBE_X, MESH_MIN_X),
-                        x_max = _MIN(MAX_PROBE_X, MESH_MAX_X),
-                        y_min = _MAX(MIN_PROBE_Y, MESH_MIN_Y),
-                        y_max = _MIN(MAX_PROBE_Y, MESH_MAX_Y);
-
-      bool abort_flag = false;
+      const float x_min = probe_min_x(), x_max = probe_max_x(),
+                  y_min = probe_min_y(), y_max = probe_max_y(),
+                  dx = (x_max - x_min) / (g29_grid_size - 1),
+                  dy = (y_max - y_min) / (g29_grid_size - 1);
 
       float measured_z;
+      bool abort_flag = false;
 
-      const float dx = float(x_max - x_min) / (g29_grid_size - 1),
-                  dy = float(y_max - y_min) / (g29_grid_size - 1);
+      //float z1, z2, z3;  // Needed for algorithm validation below
 
       struct linear_fit_data lsf_results;
-
-      //float z1, z2, z3;  // Needed for algorithm validation down below.
-
       incremental_LSF_reset(&lsf_results);
 
       if (do_3_pt_leveling) {
         SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
         #if HAS_DISPLAY
           ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 1/3"));
         #endif
 
         measured_z = probe_at_point(PROBE_PT_1_X, PROBE_PT_1_Y, PROBE_PT_RAISE, g29_verbose_level);
         if (isnan(measured_z))
@@ -1471,23 +1466,23 @@
           return;
         }
       }
       else { // !do_3_pt_leveling
 
         bool zig_zag = false;
 
         uint16_t total_points = g29_grid_size * g29_grid_size, point_num = 1;
 
         for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
-          const float rx = float(x_min) + ix * dx;
+          const float rx = x_min + ix * dx;
           for (int8_t iy = 0; iy < g29_grid_size; iy++) {
-            const float ry = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
+            const float ry = y_min + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
 
             if (!abort_flag) {
               SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
               #if HAS_DISPLAY
                 ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " %i/%i"), point_num, total_points);
               #endif
 
               measured_z = probe_at_point(rx, ry, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
 
               abort_flag = isnan(measured_z);
@@ -1498,21 +1493,21 @@
                 DEBUG_CHAR(',');
                 DEBUG_ECHO_F(ry, 7);
                 DEBUG_ECHOPGM(")   logical: (");
                 DEBUG_ECHO_F(LOGICAL_X_POSITION(rx), 7);
                 DEBUG_CHAR(',');
                 DEBUG_ECHO_F(LOGICAL_Y_POSITION(ry), 7);
                 DEBUG_ECHOPAIR_F(")   measured: ", measured_z, 7);
                 DEBUG_ECHOPAIR_F("   correction: ", get_z_correction(rx, ry), 7);
               }
 
-              measured_z -= get_z_correction(rx, ry) /* + zprobe_zoffset */ ;
+              measured_z -= get_z_correction(rx, ry) /* + zprobe_offset[Z_AXIS] */ ;
 
               if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("   final >>>---> ", measured_z, 7);
 
               if (g29_verbose_level > 3) {
                 serial_spaces(16);
                 SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
               }
               incremental_LSF(&lsf_results, rx, ry, measured_z);
             }
 
@@ -1704,27 +1699,27 @@
       report_state();
 
       if (storage_slot == -1)
         SERIAL_ECHOPGM("No Mesh Loaded.");
       else
         SERIAL_ECHOPAIR("Mesh ", storage_slot, " Loaded.");
       SERIAL_EOL();
       serial_delay(50);
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        SERIAL_ECHOLNPAIR_F("planner.z_fade_height : ", planner.z_fade_height, 4);
+        SERIAL_ECHOLNPAIR_F("Fade Height M420 Z", planner.z_fade_height, 4);
       #endif
 
       adjust_mesh_to_mean(g29_c_flag, g29_constant);
 
       #if HAS_BED_PROBE
-        SERIAL_ECHOLNPAIR_F("zprobe_zoffset: ", zprobe_zoffset, 7);
+        SERIAL_ECHOLNPAIR_F("Probe Offset M851 Z", zprobe_offset[Z_AXIS], 7);
       #endif
 
       SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); serial_delay(50);
       SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             serial_delay(50);
       SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);             serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_X_DIST  ", MESH_X_DIST);
       SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);                         serial_delay(50);

commit c353eaa14630eb9d74f185e2b6aae1630ca21525
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 17 18:16:28 2019 -0500

    Misc changes from struct refactor (#15289)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 650e9f9a62..9ee05a5a73 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -17,34 +17,32 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
-  #include "ubl.h"
+  #include "../bedlevel.h"
 
   #include "../../../Marlin.h"
   #include "../../../HAL/shared/persistent_store_api.h"
   #include "../../../libs/hex_print_routines.h"
   #include "../../../module/configuration_store.h"
   #include "../../../lcd/ultralcd.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
+  #include "../../../module/motion.h"
   #include "../../../module/probe.h"
   #include "../../../gcode/gcode.h"
-  #include "../../../core/serial.h"
-  #include "../../../gcode/parser.h"
-  #include "../../../feature/bedlevel/bedlevel.h"
   #include "../../../libs/least_squares_fit.h"
 
   #if ENABLED(DUAL_X_CARRIAGE)
     #include "../../../module/tool_change.h"
   #endif
 
   #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
   #include "../../../core/debug_out.h"
 
   #if ENABLED(EXTENSIBLE_UI)
@@ -776,21 +774,21 @@
         #endif
 
         if (do_furthest)
           location = find_furthest_invalid_mesh_point();
         else
           location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, nullptr);
 
         if (location.x_index >= 0) {    // mesh point found and is reachable by probe
           const float rawx = mesh_index_to_xpos(location.x_index),
                       rawy = mesh_index_to_ypos(location.y_index),
-                      measured_z = probe_pt(rawx, rawy, stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
+                      measured_z = probe_at_point(rawx, rawy, stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
           z_values[location.x_index][location.y_index] = measured_z;
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(location.x_index, location.y_index, measured_z);
           #endif
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
 
       } while (location.x_index >= 0 && --count);
 
       STOW_PROBE();
@@ -1403,60 +1401,60 @@
       //float z1, z2, z3;  // Needed for algorithm validation down below.
 
       incremental_LSF_reset(&lsf_results);
 
       if (do_3_pt_leveling) {
         SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
         #if HAS_DISPLAY
           ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 1/3"));
         #endif
 
-        measured_z = probe_pt(PROBE_PT_1_X, PROBE_PT_1_Y, PROBE_PT_RAISE, g29_verbose_level);
+        measured_z = probe_at_point(PROBE_PT_1_X, PROBE_PT_1_Y, PROBE_PT_RAISE, g29_verbose_level);
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(PROBE_PT_1_X, PROBE_PT_1_Y);
           //z1 = measured_z;
           if (g29_verbose_level > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, PROBE_PT_1_X, PROBE_PT_1_Y, measured_z);
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
           #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 2/3"));
           #endif
 
-          measured_z = probe_pt(PROBE_PT_2_X, PROBE_PT_2_Y, PROBE_PT_RAISE, g29_verbose_level);
+          measured_z = probe_at_point(PROBE_PT_2_X, PROBE_PT_2_Y, PROBE_PT_RAISE, g29_verbose_level);
           //z2 = measured_z;
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(PROBE_PT_2_X, PROBE_PT_2_Y);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, PROBE_PT_2_X, PROBE_PT_2_Y, measured_z);
           }
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
           #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 3/3"));
           #endif
 
-          measured_z = probe_pt(PROBE_PT_3_X, PROBE_PT_3_Y, PROBE_PT_STOW, g29_verbose_level);
+          measured_z = probe_at_point(PROBE_PT_3_X, PROBE_PT_3_Y, PROBE_PT_STOW, g29_verbose_level);
           //z3 = measured_z;
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(PROBE_PT_3_X, PROBE_PT_3_Y);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, PROBE_PT_3_X, PROBE_PT_3_Y, measured_z);
@@ -1483,21 +1481,21 @@
           const float rx = float(x_min) + ix * dx;
           for (int8_t iy = 0; iy < g29_grid_size; iy++) {
             const float ry = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
 
             if (!abort_flag) {
               SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
               #if HAS_DISPLAY
                 ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " %i/%i"), point_num, total_points);
               #endif
 
-              measured_z = probe_pt(rx, ry, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
+              measured_z = probe_at_point(rx, ry, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
 
               abort_flag = isnan(measured_z);
 
               if (DEBUGGING(LEVELING)) {
                 DEBUG_CHAR('(');
                 DEBUG_ECHO_F(rx, 7);
                 DEBUG_CHAR(',');
                 DEBUG_ECHO_F(ry, 7);
                 DEBUG_ECHOPGM(")   logical: (");
                 DEBUG_ECHO_F(LOGICAL_X_POSITION(rx), 7);

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index d49c9346fb..650e9f9a62 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -434,40 +434,40 @@
         case 0:
           //
           // Zero Mesh Data
           //
           reset();
           SERIAL_ECHOLNPGM("Mesh zeroed.");
           break;
 
         #if HAS_BED_PROBE
 
-          case 1:
+          case 1: {
             //
             // Invalidate Entire Mesh and Automatically Probe Mesh in areas that can be reached by the probe
             //
             if (!parser.seen('C')) {
               invalidate();
               SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
             }
             if (g29_verbose_level > 1) {
               SERIAL_ECHOPAIR("Probing around (", g29_x_pos);
               SERIAL_CHAR(',');
               SERIAL_ECHO(g29_y_pos);
               SERIAL_ECHOLNPGM(").\n");
             }
             probe_entire_mesh(g29_x_pos + X_PROBE_OFFSET_FROM_EXTRUDER, g29_y_pos + Y_PROBE_OFFSET_FROM_EXTRUDER,
                               parser.seen('T'), parser.seen('E'), parser.seen('U'));
 
             report_current_position();
             probe_deployed = true;
-            break;
+          } break;
 
         #endif // HAS_BED_PROBE
 
         case 2: {
           #if HAS_LCD_MENU
             //
             // Manually Probe Mesh in areas that can't be reached by the probe
             //
             SERIAL_ECHOLNPGM("Manually probing unreachable mesh locations.");
             do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);

commit f9992c5f33d954da1a70a03acf8b58d86def601b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 11 02:46:52 2019 -0500

    Implausible

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index ecd8981458..d49c9346fb 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1084,21 +1084,21 @@
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : GRID_MAX_POINTS;
       NOMORE(g29_repetition_cnt, GRID_MAX_POINTS);
       if (g29_repetition_cnt < 1) {
         SERIAL_ECHOLNPGM("?(R)epetition count invalid (1+).\n");
         return UBL_ERR;
       }
     }
 
     g29_verbose_level = parser.seen('V') ? parser.value_int() : 0;
     if (!WITHIN(g29_verbose_level, 0, 4)) {
-      SERIAL_ECHOLNPGM("?(V)erbose level is implausible (0-4).\n");
+      SERIAL_ECHOLNPGM("?(V)erbose level implausible (0-4).\n");
       err_flag = true;
     }
 
     if (parser.seen('P')) {
       const int pv = parser.value_int();
       #if !HAS_BED_PROBE
         if (pv == 1) {
           SERIAL_ECHOLNPGM("G29 P1 requires a probe.\n");
           err_flag = true;
         }

commit 565a0e11ed2d386ef343bf68274334c884dc6dbf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 9 02:56:23 2019 -0500

    Prevent 'current' name conflict, if needed

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 6b6233f826..ecd8981458 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -750,24 +750,24 @@
       #endif
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       DEPLOY_PROBE();
 
       uint8_t count = GRID_MAX_POINTS;
 
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
-        const int current = (GRID_MAX_POINTS) - count + 1;
-        SERIAL_ECHOLNPAIR("\nProbing mesh point ", current, "/", int(GRID_MAX_POINTS), ".\n");
+        const int point_num = (GRID_MAX_POINTS) - count + 1;
+        SERIAL_ECHOLNPAIR("\nProbing mesh point ", point_num, "/", int(GRID_MAX_POINTS), ".\n");
         #if HAS_DISPLAY
-          ui.status_printf_P(0, PSTR(MSG_PROBING_MESH " %i/%i"), current, int(GRID_MAX_POINTS));
+          ui.status_printf_P(0, PSTR(MSG_PROBING_MESH " %i/%i"), point_num, int(GRID_MAX_POINTS));
         #endif
 
         #if HAS_LCD_MENU
           if (ui.button_pressed()) {
             ui.quick_feedback(false); // Preserve button state for click-and-hold
             SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
             STOW_PROBE();
             ui.wait_for_release();
             ui.quick_feedback();
             ui.release();
@@ -1470,31 +1470,31 @@
 
         if (abort_flag) {
           SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");
           return;
         }
       }
       else { // !do_3_pt_leveling
 
         bool zig_zag = false;
 
-        uint16_t total_points = g29_grid_size * g29_grid_size, current = 1;
+        uint16_t total_points = g29_grid_size * g29_grid_size, point_num = 1;
 
         for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
           const float rx = float(x_min) + ix * dx;
           for (int8_t iy = 0; iy < g29_grid_size; iy++) {
             const float ry = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
 
             if (!abort_flag) {
-              SERIAL_ECHOLNPAIR("Tilting mesh point ", current, "/", total_points, "\n");
+              SERIAL_ECHOLNPAIR("Tilting mesh point ", point_num, "/", total_points, "\n");
               #if HAS_DISPLAY
-                ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " %i/%i"), current, total_points);
+                ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " %i/%i"), point_num, total_points);
               #endif
 
               measured_z = probe_pt(rx, ry, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
 
               abort_flag = isnan(measured_z);
 
               if (DEBUGGING(LEVELING)) {
                 DEBUG_CHAR('(');
                 DEBUG_ECHO_F(rx, 7);
                 DEBUG_CHAR(',');
@@ -1511,21 +1511,21 @@
 
               if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("   final >>>---> ", measured_z, 7);
 
               if (g29_verbose_level > 3) {
                 serial_spaces(16);
                 SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
               }
               incremental_LSF(&lsf_results, rx, ry, measured_z);
             }
 
-            current++;
+            point_num++;
           }
 
           zig_zag ^= true;
         }
       }
       STOW_PROBE();
       #ifdef Z_AFTER_PROBING
         move_z_after_probing();
       #endif
 

commit 9d9e2deb9b63d5d10beb528254ac2e18fa71fb1a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Aug 17 20:14:14 2019 -0500

    Tweak UBL G29 status print

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 568f766150..6b6233f826 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -745,30 +745,29 @@
     void unified_bed_leveling::probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
       mesh_index_pair location;
 
       #if HAS_LCD_MENU
         ui.capture();
       #endif
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       DEPLOY_PROBE();
 
-      uint8_t count = GRID_MAX_POINTS, current = 1;
+      uint8_t count = GRID_MAX_POINTS;
 
       do {
-        current = (GRID_MAX_POINTS) - count + 1;
-
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
-        SERIAL_ECHOLNPAIR("\nProbing mesh point ", int(current), "/", int(GRID_MAX_POINTS), ".\n");
+        const int current = (GRID_MAX_POINTS) - count + 1;
+        SERIAL_ECHOLNPAIR("\nProbing mesh point ", current, "/", int(GRID_MAX_POINTS), ".\n");
         #if HAS_DISPLAY
-          ui.status_printf_P(0, PSTR(MSG_PROBING_MESH " %i/%i"), int(current), int(GRID_MAX_POINTS));
+          ui.status_printf_P(0, PSTR(MSG_PROBING_MESH " %i/%i"), current, int(GRID_MAX_POINTS));
         #endif
 
         #if HAS_LCD_MENU
           if (ui.button_pressed()) {
             ui.quick_feedback(false); // Preserve button state for click-and-hold
             SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
             STOW_PROBE();
             ui.wait_for_release();
             ui.quick_feedback();
             ui.release();
@@ -1493,22 +1492,21 @@
 
               measured_z = probe_pt(rx, ry, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
 
               abort_flag = isnan(measured_z);
 
               if (DEBUGGING(LEVELING)) {
                 DEBUG_CHAR('(');
                 DEBUG_ECHO_F(rx, 7);
                 DEBUG_CHAR(',');
                 DEBUG_ECHO_F(ry, 7);
-                DEBUG_ECHOPGM(")   logical: ");
-                DEBUG_CHAR('(');
+                DEBUG_ECHOPGM(")   logical: (");
                 DEBUG_ECHO_F(LOGICAL_X_POSITION(rx), 7);
                 DEBUG_CHAR(',');
                 DEBUG_ECHO_F(LOGICAL_Y_POSITION(ry), 7);
                 DEBUG_ECHOPAIR_F(")   measured: ", measured_z, 7);
                 DEBUG_ECHOPAIR_F("   correction: ", get_z_correction(rx, ry), 7);
               }
 
               measured_z -= get_z_correction(rx, ry) /* + zprobe_zoffset */ ;
 
               if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("   final >>>---> ", measured_z, 7);

commit f59a7e8b0747b4b1a336f7766ee4cd6f3eab071d
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Aug 1 21:11:26 2019 -0400

    Print/display ABL current probe point (#14788)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index c5b4500196..568f766150 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -745,31 +745,33 @@
     void unified_bed_leveling::probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
       mesh_index_pair location;
 
       #if HAS_LCD_MENU
         ui.capture();
       #endif
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       DEPLOY_PROBE();
 
-      uint16_t count = GRID_MAX_POINTS, current = 1;
+      uint8_t count = GRID_MAX_POINTS, current = 1;
 
       do {
         current = (GRID_MAX_POINTS) - count + 1;
 
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
-        SERIAL_ECHOLNPAIR("\nProbing mesh point ", current, "/", GRID_MAX_POINTS, ".\n");
-        #if HAS_LCD_MENU
-          ui.status_printf_P(0, PSTR(MSG_LCD_PROBING_MESH " %i/%i"), current, int(GRID_MAX_POINTS));
+        SERIAL_ECHOLNPAIR("\nProbing mesh point ", int(current), "/", int(GRID_MAX_POINTS), ".\n");
+        #if HAS_DISPLAY
+          ui.status_printf_P(0, PSTR(MSG_PROBING_MESH " %i/%i"), int(current), int(GRID_MAX_POINTS));
+        #endif
 
+        #if HAS_LCD_MENU
           if (ui.button_pressed()) {
             ui.quick_feedback(false); // Preserve button state for click-and-hold
             SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
             STOW_PROBE();
             ui.wait_for_release();
             ui.quick_feedback();
             ui.release();
             return restore_ubl_active_state_and_leave();
           }
         #endif
@@ -1398,60 +1400,60 @@
                   dy = float(y_max - y_min) / (g29_grid_size - 1);
 
       struct linear_fit_data lsf_results;
 
       //float z1, z2, z3;  // Needed for algorithm validation down below.
 
       incremental_LSF_reset(&lsf_results);
 
       if (do_3_pt_leveling) {
         SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
-        #if HAS_LCD_MENU
+        #if HAS_DISPLAY
           ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 1/3"));
         #endif
 
         measured_z = probe_pt(PROBE_PT_1_X, PROBE_PT_1_Y, PROBE_PT_RAISE, g29_verbose_level);
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(PROBE_PT_1_X, PROBE_PT_1_Y);
           //z1 = measured_z;
           if (g29_verbose_level > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, PROBE_PT_1_X, PROBE_PT_1_Y, measured_z);
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
-          #if HAS_LCD_MENU
+          #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 2/3"));
           #endif
 
           measured_z = probe_pt(PROBE_PT_2_X, PROBE_PT_2_Y, PROBE_PT_RAISE, g29_verbose_level);
           //z2 = measured_z;
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(PROBE_PT_2_X, PROBE_PT_2_Y);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, PROBE_PT_2_X, PROBE_PT_2_Y, measured_z);
           }
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
-          #if HAS_LCD_MENU
+          #if HAS_DISPLAY
             ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 3/3"));
           #endif
 
           measured_z = probe_pt(PROBE_PT_3_X, PROBE_PT_3_Y, PROBE_PT_STOW, g29_verbose_level);
           //z3 = measured_z;
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(PROBE_PT_3_X, PROBE_PT_3_Y);
             if (g29_verbose_level > 3) {
@@ -1478,21 +1480,21 @@
 
         uint16_t total_points = g29_grid_size * g29_grid_size, current = 1;
 
         for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
           const float rx = float(x_min) + ix * dx;
           for (int8_t iy = 0; iy < g29_grid_size; iy++) {
             const float ry = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
 
             if (!abort_flag) {
               SERIAL_ECHOLNPAIR("Tilting mesh point ", current, "/", total_points, "\n");
-              #if HAS_LCD_MENU
+              #if HAS_DISPLAY
                 ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " %i/%i"), current, total_points);
               #endif
 
               measured_z = probe_pt(rx, ry, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
 
               abort_flag = isnan(measured_z);
 
               if (DEBUGGING(LEVELING)) {
                 DEBUG_CHAR('(');
                 DEBUG_ECHO_F(rx, 7);

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index afbbf313ad..c5b4500196 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -848,21 +848,21 @@
       return current_position[Z_AXIS];
     }
 
     static void echo_and_take_a_measurement() { SERIAL_ECHOLNPGM(" and take a measurement."); }
 
     float unified_bed_leveling::measure_business_card_thickness(float in_height) {
       ui.capture();
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
       do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
-        //, MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f);
+        //, _MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f);
       planner.synchronize();
 
       SERIAL_ECHOPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       ui.return_to_status();
       echo_and_take_a_measurement();
 
       const float z1 = measure_point_with_encoder();
       do_blocking_move_to_z(current_position[Z_AXIS] + SIZE_OF_LITTLE_RAISE);
       planner.synchronize();
@@ -1378,24 +1378,24 @@
             if (smart_fill_one(x, y, 0, dir)) break;
       }
     }
   }
 
   #if HAS_BED_PROBE
 
     #include "../../../libs/vector_3.h"
 
     void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
-      constexpr int16_t x_min = MAX(MIN_PROBE_X, MESH_MIN_X),
-                        x_max = MIN(MAX_PROBE_X, MESH_MAX_X),
-                        y_min = MAX(MIN_PROBE_Y, MESH_MIN_Y),
-                        y_max = MIN(MAX_PROBE_Y, MESH_MAX_Y);
+      constexpr int16_t x_min = _MAX(MIN_PROBE_X, MESH_MIN_X),
+                        x_max = _MIN(MAX_PROBE_X, MESH_MAX_X),
+                        y_min = _MAX(MIN_PROBE_Y, MESH_MIN_Y),
+                        y_max = _MIN(MAX_PROBE_Y, MESH_MAX_Y);
 
       bool abort_flag = false;
 
       float measured_z;
 
       const float dx = float(x_max - x_min) / (g29_grid_size - 1),
                   dy = float(y_max - y_min) / (g29_grid_size - 1);
 
       struct linear_fit_data lsf_results;
 
@@ -1647,21 +1647,21 @@
       // from all the originally populated mesh points, weighted toward the point
       // being extrapolated so that nearby points will have greater influence on
       // the point being extrapolated.  Then extrapolate the mesh point from WLSF.
 
       static_assert(GRID_MAX_POINTS_Y <= 16, "GRID_MAX_POINTS_Y too big");
       uint16_t bitmap[GRID_MAX_POINTS_X] = { 0 };
       struct linear_fit_data lsf_results;
 
       SERIAL_ECHOPGM("Extrapolating mesh...");
 
-      const float weight_scaled = weight_factor * MAX(MESH_X_DIST, MESH_Y_DIST);
+      const float weight_scaled = weight_factor * _MAX(MESH_X_DIST, MESH_Y_DIST);
 
       for (uint8_t jx = 0; jx < GRID_MAX_POINTS_X; jx++)
         for (uint8_t jy = 0; jy < GRID_MAX_POINTS_Y; jy++)
           if (!isnan(z_values[jx][jy]))
             SBI(bitmap[jx], jy);
 
       for (uint8_t ix = 0; ix < GRID_MAX_POINTS_X; ix++) {
         const float px = mesh_index_to_xpos(ix);
         for (uint8_t iy = 0; iy < GRID_MAX_POINTS_Y; iy++) {
           const float py = mesh_index_to_ypos(iy);

commit 41b7f16ab84908544091882a924a80aa4201b3d6
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Wed Jul 3 19:26:43 2019 -0500

    Fix grammar of comment for G29 T command

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 37b60f9d08..afbbf313ad 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -251,21 +251,21 @@
    *
    *   S #   Store      Store the current Mesh at the specified location in EEPROM. Activate this location
    *                    for subsequent Load and Store operations. Valid storage slot numbers begin at 0 and
    *                    extend to a limit related to the available EEPROM storage.
    *
    *   S -1  Store      Print the current Mesh as G-code that can be used to restore the mesh anytime.
    *
    *   T     Topology   Display the Mesh Map Topology.
    *                    'T' can be used alone (e.g., G29 T) or in combination with most of the other commands.
    *                    This option works with all Phase commands (e.g., G29 P4 R 5 T X 50 Y100 C -.1 O)
-   *                    This parameter can also specify a Map Type. T0 (the default) is user-readable. T1 can
+   *                    This parameter can also specify a Map Type. T0 (the default) is user-readable. T1
    *                    is suitable to paste into a spreadsheet for a 3D graph of the mesh.
    *
    *   U     Unlevel    Perform a probe of the outer perimeter to assist in physically leveling unlevel beds.
    *                    Only used for G29 P1 T U. This speeds up the probing of the edge of the bed. Useful
    *                    when the entire bed doesn't need to be probed because it will be adjusted.
    *
    *   V #   Verbosity  Set the verbosity level (0-4) for extra details. (Default 0)
    *
    *   X #              X Location for this command
    *

commit dab2f0c89c848de5b745b7a70576b5fd2e9bccbd
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Mon Jul 1 05:29:33 2019 +0200

    Mask unused var, update (c) comments (#14455)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index f3473edcfd..37b60f9d08 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -674,20 +674,22 @@
       ui.reset_status();
       ui.release();
     #endif
 
     #ifdef Z_PROBE_END_SCRIPT
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
       if (probe_deployed) {
         planner.synchronize();
         gcode.process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
       }
+    #else
+      UNUSED(probe_deployed);
     #endif
 
     return;
   }
 
   void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float value) {
     float sum = 0;
     int n = 0;
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)

commit 0ca64a0ea34f5bf96c4122b2f8341ccbcb0f6f2f
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sun Jun 30 06:20:49 2019 +0200

    Fix compile error with Z_PROBE_END_SCRIPT (#14447)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 8b61e8bf0d..f3473edcfd 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -672,21 +672,21 @@
       ui.reset_alert_level();
       ui.quick_feedback();
       ui.reset_status();
       ui.release();
     #endif
 
     #ifdef Z_PROBE_END_SCRIPT
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
       if (probe_deployed) {
         planner.synchronize();
-        process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
+        gcode.process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
       }
     #endif
 
     return;
   }
 
   void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float value) {
     float sum = 0;
     int n = 0;
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)

commit d16954dc885f75869b572549c5e90561b89a95bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 29 22:49:50 2019 -0500

    Make KEEPALIVE_STATE a scoped auto-restore (#14446)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 90749a9f3c..8b61e8bf0d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -761,22 +761,21 @@
         #if HAS_LCD_MENU
           ui.status_printf_P(0, PSTR(MSG_LCD_PROBING_MESH " %i/%i"), current, int(GRID_MAX_POINTS));
 
           if (ui.button_pressed()) {
             ui.quick_feedback(false); // Preserve button state for click-and-hold
             SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
             STOW_PROBE();
             ui.wait_for_release();
             ui.quick_feedback();
             ui.release();
-            restore_ubl_active_state_and_leave();
-            return;
+            return restore_ubl_active_state_and_leave();
           }
         #endif
 
         if (do_furthest)
           location = find_furthest_invalid_mesh_point();
         else
           location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, nullptr);
 
         if (location.x_index >= 0) {    // mesh point found and is reachable by probe
           const float rawx = mesh_index_to_xpos(location.x_index),
@@ -837,21 +836,20 @@
         if (encoder_diff) {
           do_blocking_move_to_z(current_position[Z_AXIS] + float(encoder_diff) * multiplier);
           encoder_diff = 0;
         }
       }
     }
 
     float unified_bed_leveling::measure_point_with_encoder() {
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       move_z_with_encoder(0.01f);
-      KEEPALIVE_STATE(IN_HANDLER);
       return current_position[Z_AXIS];
     }
 
     static void echo_and_take_a_measurement() { SERIAL_ECHOLNPGM(" and take a measurement."); }
 
     float unified_bed_leveling::measure_business_card_thickness(float in_height) {
       ui.capture();
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
       do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
@@ -882,29 +880,20 @@
         SERIAL_ECHOLNPGM("mm thick.");
       }
 
       ui.release();
 
       restore_ubl_active_state_and_leave();
 
       return thickness;
     }
 
-    void abort_manual_probe_remaining_mesh() {
-      SERIAL_ECHOLNPGM("\nMesh only partially populated.");
-      do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
-      ui.release();
-      KEEPALIVE_STATE(IN_HANDLER);
-      ui.quick_feedback();
-      ubl.restore_ubl_active_state_and_leave();
-    }
-
     void unified_bed_leveling::manually_probe_remaining_mesh(const float &rx, const float &ry, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
 
       ui.capture();
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z_clearance);
 
       ui.return_to_status();
 
       mesh_index_pair location;
@@ -932,39 +921,36 @@
 
         const float z_step = 0.01f;                         // existing behavior: 0.01mm per click, occasionally step
         //const float z_step = planner.steps_to_mm[Z_AXIS]; // approx one step each click
 
         move_z_with_encoder(z_step);
 
         if (click_and_hold()) {
           SERIAL_ECHOLNPGM("\nMesh only partially populated.");
           do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
           ui.release();
-          KEEPALIVE_STATE(IN_HANDLER);
-          restore_ubl_active_state_and_leave();
-          return;
+          return restore_ubl_active_state_and_leave();
         }
 
         z_values[location.x_index][location.y_index] = current_position[Z_AXIS] - thick;
         #if ENABLED(EXTENSIBLE_UI)
           ExtUI::onMeshUpdate(location.x_index, location.y_index, z_values[location.x_index][location.y_index]);
         #endif
 
         if (g29_verbose_level > 2)
           SERIAL_ECHOLNPAIR_F("Mesh Point Measured at: ", z_values[location.x_index][location.y_index], 6);
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.x_index >= 0 && location.y_index >= 0);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
       restore_ubl_active_state_and_leave();
-      KEEPALIVE_STATE(IN_HANDLER);
       do_blocking_move_to(rx, ry, Z_CLEARANCE_DEPLOY_PROBE);
     }
 
     inline void set_message_with_feedback(PGM_P const msg_P) {
       ui.set_status_P(msg_P);
       ui.quick_feedback();
     }
 
     void abort_fine_tune() {
       ui.return_to_status();
@@ -1039,36 +1025,33 @@
           new_z = lcd_mesh_edit();
           #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
             do_blocking_move_to_z(h_offset + new_z);                // Move the nozzle as the point is edited
           #endif
           idle();
           SERIAL_FLUSH();                                           // Prevent host M105 buffer overrun.
         } while (!ui.button_pressed());
 
         if (!lcd_map_control) ui.return_to_status();                // Just editing a single point? Return to status
 
-        if (click_and_hold(abort_fine_tune)) goto FINE_TUNE_EXIT;   // If the click is held down, abort editing
+        if (click_and_hold(abort_fine_tune)) break;                 // Button held down? Abort editing
 
         z_values[location.x_index][location.y_index] = new_z;       // Save the updated Z value
         #if ENABLED(EXTENSIBLE_UI)
           ExtUI::onMeshUpdate(location.x_index, location.y_index, new_z);
         #endif
 
         serial_delay(20);                                           // No switch noise
         ui.refresh();
 
       } while (location.x_index >= 0 && --g29_repetition_cnt > 0);
 
-      FINE_TUNE_EXIT:
-
       ui.release();
-      KEEPALIVE_STATE(IN_HANDLER);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);
 
       LCD_MESSAGEPGM(MSG_UBL_DONE_EDITING_MESH);
       SERIAL_ECHOLNPGM("Done Editing Mesh");
 
       if (lcd_map_control)

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 2ecaab692b..90749a9f3c 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit b961251899ff045a4d3da4d8e3816ed9876befd0
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Jun 27 14:00:55 2019 -0400

    Add Z_PROBE_END_SCRIPT to UBL (#14419)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 7a1eb112fc..2ecaab692b 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -299,20 +299,21 @@
    *   the mesh just right. To prevent this valuable data from being destroyed as the EEPROM structure
    *   evolves, UBL stores all mesh data at the end of EEPROM.
    *
    *   UBL is founded on Edward Patel's Mesh Bed Leveling code. A big 'Thanks!' to him and the creators of
    *   3-Point and Grid Based leveling. Combining their contributions we now have the functionality and
    *   features of all three systems combined.
    */
 
   void unified_bed_leveling::G29() {
 
+    bool probe_deployed = false;
     if (g29_parameter_parsing()) return; // Abort on parameter error
 
     const int8_t p_val = parser.intval('P', -1);
     const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J');
 
     // Check for commands that require the printer to be homed
     if (may_move) {
       planner.synchronize();
       if (axis_unhomed_error()) gcode.home_all_axes();
       #if ENABLED(DUAL_X_CARRIAGE)
@@ -411,20 +412,21 @@
           tilt_mesh_based_on_probed_grid(false /* false says to do normal grid probing */ );
           restore_ubl_active_state_and_leave();
         }
         else { // grid_size == 0 : A 3-Point leveling has been requested
           save_ubl_active_state_and_disable();
           tilt_mesh_based_on_probed_grid(true /* true says to do 3-Point leveling */ );
           restore_ubl_active_state_and_leave();
         }
         do_blocking_move_to_xy(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)));
         report_current_position();
+        probe_deployed = true;
       }
 
     #endif // HAS_BED_PROBE
 
     if (parser.seen('P')) {
       if (WITHIN(g29_phase_value, 0, 1) && storage_slot == -1) {
         storage_slot = 0;
         SERIAL_ECHOLNPGM("Default storage slot 0 selected.");
       }
 
@@ -450,20 +452,21 @@
             if (g29_verbose_level > 1) {
               SERIAL_ECHOPAIR("Probing around (", g29_x_pos);
               SERIAL_CHAR(',');
               SERIAL_ECHO(g29_y_pos);
               SERIAL_ECHOLNPGM(").\n");
             }
             probe_entire_mesh(g29_x_pos + X_PROBE_OFFSET_FROM_EXTRUDER, g29_y_pos + Y_PROBE_OFFSET_FROM_EXTRUDER,
                               parser.seen('T'), parser.seen('E'), parser.seen('U'));
 
             report_current_position();
+            probe_deployed = true;
             break;
 
         #endif // HAS_BED_PROBE
 
         case 2: {
           #if HAS_LCD_MENU
             //
             // Manually Probe Mesh in areas that can't be reached by the probe
             //
             SERIAL_ECHOLNPGM("Manually probing unreachable mesh locations.");
@@ -485,20 +488,21 @@
                 g29_y_pos = Y_PROBE_OFFSET_FROM_EXTRUDER < 0 ? Y_BED_SIZE : 0;
               #endif
             }
 
             if (parser.seen('B')) {
               g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness((float) Z_CLEARANCE_BETWEEN_PROBES);
               if (ABS(g29_card_thickness) > 1.5f) {
                 SERIAL_ECHOLNPGM("?Error in Business Card measurement.");
                 return;
               }
+              probe_deployed = true;
             }
 
             if (!position_is_reachable(g29_x_pos, g29_y_pos)) {
               SERIAL_ECHOLNPGM("XY outside printable radius.");
               return;
             }
 
             const float height = parser.floatval('H', Z_CLEARANCE_BETWEEN_PROBES);
             manually_probe_remaining_mesh(g29_x_pos, g29_y_pos, height, g29_card_thickness, parser.seen('T'));
 
@@ -664,20 +668,28 @@
 
     LEAVE:
 
     #if HAS_LCD_MENU
       ui.reset_alert_level();
       ui.quick_feedback();
       ui.reset_status();
       ui.release();
     #endif
 
+    #ifdef Z_PROBE_END_SCRIPT
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
+      if (probe_deployed) {
+        planner.synchronize();
+        process_subcommands_now_P(PSTR(Z_PROBE_END_SCRIPT));
+      }
+    #endif
+
     return;
   }
 
   void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float value) {
     float sum = 0;
     int n = 0;
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
         if (!isnan(z_values[x][y])) {
           sum += z_values[x][y];

commit 78557076ff9a22feafd8677b8eb07a266d06e941
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 22 17:22:09 2019 -0500

    Add planner.synchronize to UBL G29

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index ca06e66704..7a1eb112fc 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -306,20 +306,21 @@
 
   void unified_bed_leveling::G29() {
 
     if (g29_parameter_parsing()) return; // Abort on parameter error
 
     const int8_t p_val = parser.intval('P', -1);
     const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J');
 
     // Check for commands that require the printer to be homed
     if (may_move) {
+      planner.synchronize();
       if (axis_unhomed_error()) gcode.home_all_axes();
       #if ENABLED(DUAL_X_CARRIAGE)
         if (active_extruder != 0) tool_change(0);
       #endif
     }
 
     // Invalidate Mesh Points. This command is a little bit asymmetrical because
     // it directly specifies the repetition count and does not use the 'R' parameter.
     if (parser.seen('I')) {
       uint8_t cnt = 0;

commit c6d39319dedd7304ddd171cf35f6f02b6925ac8f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 26 15:24:10 2019 -0500

    Fix some whitespace

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 09bb7a23e1..ca06e66704 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1442,21 +1442,21 @@
             }
             incremental_LSF(&lsf_results, PROBE_PT_2_X, PROBE_PT_2_Y, measured_z);
           }
         }
 
         if (!abort_flag) {
           SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
           #if HAS_LCD_MENU
             ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 3/3"));
           #endif
-          
+
           measured_z = probe_pt(PROBE_PT_3_X, PROBE_PT_3_Y, PROBE_PT_STOW, g29_verbose_level);
           //z3 = measured_z;
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(PROBE_PT_3_X, PROBE_PT_3_Y);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
@@ -1470,21 +1470,21 @@
         #endif
 
         if (abort_flag) {
           SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");
           return;
         }
       }
       else { // !do_3_pt_leveling
 
         bool zig_zag = false;
-        
+
         uint16_t total_points = g29_grid_size * g29_grid_size, current = 1;
 
         for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
           const float rx = float(x_min) + ix * dx;
           for (int8_t iy = 0; iy < g29_grid_size; iy++) {
             const float ry = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
 
             if (!abort_flag) {
               SERIAL_ECHOLNPAIR("Tilting mesh point ", current, "/", total_points, "\n");
               #if HAS_LCD_MENU

commit 62ef54cb81846ef40b108ec483900eff54f204eb
Author: GUEST.it <3944655+guestisp@users.noreply.github.com>
Date:   Sat May 18 02:02:21 2019 +0200

    UBL: Log and display G29 progress (#14036)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index dfd16014be..09bb7a23e1 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -404,21 +404,20 @@
 
     #if HAS_BED_PROBE
 
       if (parser.seen('J')) {
         if (g29_grid_size) {  // if not 0 it is a normal n x n grid being probed
           save_ubl_active_state_and_disable();
           tilt_mesh_based_on_probed_grid(false /* false says to do normal grid probing */ );
           restore_ubl_active_state_and_leave();
         }
         else { // grid_size == 0 : A 3-Point leveling has been requested
-
           save_ubl_active_state_and_disable();
           tilt_mesh_based_on_probed_grid(true /* true says to do 3-Point leveling */ );
           restore_ubl_active_state_and_leave();
         }
         do_blocking_move_to_xy(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)));
         report_current_position();
       }
 
     #endif // HAS_BED_PROBE
 
@@ -731,26 +730,31 @@
     void unified_bed_leveling::probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
       mesh_index_pair location;
 
       #if HAS_LCD_MENU
         ui.capture();
       #endif
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       DEPLOY_PROBE();
 
-      uint16_t count = GRID_MAX_POINTS;
+      uint16_t count = GRID_MAX_POINTS, current = 1;
 
       do {
+        current = (GRID_MAX_POINTS) - count + 1;
+
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
+        SERIAL_ECHOLNPAIR("\nProbing mesh point ", current, "/", GRID_MAX_POINTS, ".\n");
         #if HAS_LCD_MENU
+          ui.status_printf_P(0, PSTR(MSG_LCD_PROBING_MESH " %i/%i"), current, int(GRID_MAX_POINTS));
+
           if (ui.button_pressed()) {
             ui.quick_feedback(false); // Preserve button state for click-and-hold
             SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
             STOW_PROBE();
             ui.wait_for_release();
             ui.quick_feedback();
             ui.release();
             restore_ubl_active_state_and_leave();
             return;
           }
@@ -764,20 +768,21 @@
         if (location.x_index >= 0) {    // mesh point found and is reachable by probe
           const float rawx = mesh_index_to_xpos(location.x_index),
                       rawy = mesh_index_to_ypos(location.y_index),
                       measured_z = probe_pt(rawx, rawy, stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
           z_values[location.x_index][location.y_index] = measured_z;
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(location.x_index, location.y_index, measured_z);
           #endif
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
+
       } while (location.x_index >= 0 && --count);
 
       STOW_PROBE();
 
       #ifdef Z_AFTER_PROBING
         move_z_after_probing();
       #endif
 
       restore_ubl_active_state_and_leave();
 
@@ -1394,82 +1399,105 @@
       const float dx = float(x_max - x_min) / (g29_grid_size - 1),
                   dy = float(y_max - y_min) / (g29_grid_size - 1);
 
       struct linear_fit_data lsf_results;
 
       //float z1, z2, z3;  // Needed for algorithm validation down below.
 
       incremental_LSF_reset(&lsf_results);
 
       if (do_3_pt_leveling) {
+        SERIAL_ECHOLNPGM("Tilting mesh (1/3)");
+        #if HAS_LCD_MENU
+          ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 1/3"));
+        #endif
+
         measured_z = probe_pt(PROBE_PT_1_X, PROBE_PT_1_Y, PROBE_PT_RAISE, g29_verbose_level);
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(PROBE_PT_1_X, PROBE_PT_1_Y);
           //z1 = measured_z;
           if (g29_verbose_level > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, PROBE_PT_1_X, PROBE_PT_1_Y, measured_z);
         }
 
         if (!abort_flag) {
+          SERIAL_ECHOLNPGM("Tilting mesh (2/3)");
+          #if HAS_LCD_MENU
+            ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 2/3"));
+          #endif
+
           measured_z = probe_pt(PROBE_PT_2_X, PROBE_PT_2_Y, PROBE_PT_RAISE, g29_verbose_level);
           //z2 = measured_z;
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(PROBE_PT_2_X, PROBE_PT_2_Y);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, PROBE_PT_2_X, PROBE_PT_2_Y, measured_z);
           }
         }
 
         if (!abort_flag) {
+          SERIAL_ECHOLNPGM("Tilting mesh (3/3)");
+          #if HAS_LCD_MENU
+            ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " 3/3"));
+          #endif
+          
           measured_z = probe_pt(PROBE_PT_3_X, PROBE_PT_3_Y, PROBE_PT_STOW, g29_verbose_level);
           //z3 = measured_z;
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(PROBE_PT_3_X, PROBE_PT_3_Y);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, PROBE_PT_3_X, PROBE_PT_3_Y, measured_z);
           }
         }
 
         STOW_PROBE();
         #ifdef Z_AFTER_PROBING
           move_z_after_probing();
         #endif
 
         if (abort_flag) {
-          SERIAL_ECHOLNPGM("?Error probing point.  Aborting operation.");
+          SERIAL_ECHOLNPGM("?Error probing point. Aborting operation.");
           return;
         }
       }
       else { // !do_3_pt_leveling
 
         bool zig_zag = false;
+        
+        uint16_t total_points = g29_grid_size * g29_grid_size, current = 1;
+
         for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
           const float rx = float(x_min) + ix * dx;
           for (int8_t iy = 0; iy < g29_grid_size; iy++) {
             const float ry = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
 
             if (!abort_flag) {
+              SERIAL_ECHOLNPAIR("Tilting mesh point ", current, "/", total_points, "\n");
+              #if HAS_LCD_MENU
+                ui.status_printf_P(0, PSTR(MSG_LCD_TILTING_MESH " %i/%i"), current, total_points);
+              #endif
+
               measured_z = probe_pt(rx, ry, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
 
               abort_flag = isnan(measured_z);
 
               if (DEBUGGING(LEVELING)) {
                 DEBUG_CHAR('(');
                 DEBUG_ECHO_F(rx, 7);
                 DEBUG_CHAR(',');
                 DEBUG_ECHO_F(ry, 7);
                 DEBUG_ECHOPGM(")   logical: ");
@@ -1484,20 +1512,22 @@
               measured_z -= get_z_correction(rx, ry) /* + zprobe_zoffset */ ;
 
               if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("   final >>>---> ", measured_z, 7);
 
               if (g29_verbose_level > 3) {
                 serial_spaces(16);
                 SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
               }
               incremental_LSF(&lsf_results, rx, ry, measured_z);
             }
+
+            current++;
           }
 
           zig_zag ^= true;
         }
       }
       STOW_PROBE();
       #ifdef Z_AFTER_PROBING
         move_z_after_probing();
       #endif
 

commit ad4ffa1d2fbd17ac09c816ba2052cdf714261042
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 9 11:45:55 2019 -0500

    Use C++ language supported 'nullptr' (#13944)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index ba9205b9c3..dfd16014be 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -323,21 +323,21 @@
     // it directly specifies the repetition count and does not use the 'R' parameter.
     if (parser.seen('I')) {
       uint8_t cnt = 0;
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : 1;
       if (g29_repetition_cnt >= GRID_MAX_POINTS) {
         set_all_mesh_points_to_value(NAN);
       }
       else {
         while (g29_repetition_cnt--) {
           if (cnt > 20) { cnt = 0; idle(); }
-          const mesh_index_pair location = find_closest_mesh_point_of_type(REAL, g29_x_pos, g29_y_pos, USE_NOZZLE_AS_REFERENCE, NULL);
+          const mesh_index_pair location = find_closest_mesh_point_of_type(REAL, g29_x_pos, g29_y_pos, USE_NOZZLE_AS_REFERENCE, nullptr);
           if (location.x_index < 0) {
             // No more REACHABLE mesh points to invalidate, so we ASSUME the user
             // meant to invalidate the ENTIRE mesh, which cannot be done with
             // find_closest_mesh_point loop which only returns REACHABLE points.
             set_all_mesh_points_to_value(NAN);
             SERIAL_ECHOLNPGM("Entire Mesh invalidated.\n");
             break;            // No more invalid Mesh Points to populate
           }
           z_values[location.x_index][location.y_index] = NAN;
           #if ENABLED(EXTENSIBLE_UI)
@@ -521,21 +521,21 @@
            *   - Specify a constant with the 'C' parameter.
            *   - Allow 'G29 P3' to choose a 'reasonable' constant.
            */
 
           if (g29_c_flag) {
             if (g29_repetition_cnt >= GRID_MAX_POINTS) {
               set_all_mesh_points_to_value(g29_constant);
             }
             else {
               while (g29_repetition_cnt--) {  // this only populates reachable mesh points near
-                const mesh_index_pair location = find_closest_mesh_point_of_type(INVALID, g29_x_pos, g29_y_pos, USE_NOZZLE_AS_REFERENCE, NULL);
+                const mesh_index_pair location = find_closest_mesh_point_of_type(INVALID, g29_x_pos, g29_y_pos, USE_NOZZLE_AS_REFERENCE, nullptr);
                 if (location.x_index < 0) {
                   // No more REACHABLE INVALID mesh points to populate, so we ASSUME
                   // user meant to populate ALL INVALID mesh points to value
                   for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
                     for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
                       if (isnan(z_values[x][y]))
                         z_values[x][y] = g29_constant;
                   break; // No more invalid Mesh Points to populate
                 }
                 z_values[location.x_index][location.y_index] = g29_constant;
@@ -752,21 +752,21 @@
             ui.quick_feedback();
             ui.release();
             restore_ubl_active_state_and_leave();
             return;
           }
         #endif
 
         if (do_furthest)
           location = find_furthest_invalid_mesh_point();
         else
-          location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, NULL);
+          location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, nullptr);
 
         if (location.x_index >= 0) {    // mesh point found and is reachable by probe
           const float rawx = mesh_index_to_xpos(location.x_index),
                       rawy = mesh_index_to_ypos(location.y_index),
                       measured_z = probe_pt(rawx, rawy, stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
           z_values[location.x_index][location.y_index] = measured_z;
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(location.x_index, location.y_index, measured_z);
           #endif
         }
@@ -786,21 +786,21 @@
         constrain(ry - (Y_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 
   #endif // HAS_BED_PROBE
 
   #if HAS_LCD_MENU
 
     typedef void (*clickFunc_t)();
 
-    bool click_and_hold(const clickFunc_t func=NULL) {
+    bool click_and_hold(const clickFunc_t func=nullptr) {
       if (ui.button_pressed()) {
         ui.quick_feedback(false);                // Preserve button state for click-and-hold
         const millis_t nxt = millis() + 1500UL;
         while (ui.button_pressed()) {                // Loop while the encoder is pressed. Uses hardware flag!
           idle();                                 // idle, of course
           if (ELAPSED(millis(), nxt)) {           // After 1.5 seconds
             ui.quick_feedback();
             if (func) (*func)();
             ui.wait_for_release();
             return true;
@@ -884,21 +884,21 @@
 
       ui.capture();
 
       save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z_clearance);
 
       ui.return_to_status();
 
       mesh_index_pair location;
       do {
-        location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_NOZZLE_AS_REFERENCE, NULL);
+        location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_NOZZLE_AS_REFERENCE, nullptr);
         // It doesn't matter if the probe can't reach the NAN location. This is a manual probe.
         if (location.x_index < 0 && location.y_index < 0) continue;
 
         const float xProbe = mesh_index_to_xpos(location.x_index),
                     yProbe = mesh_index_to_ypos(location.y_index);
 
         if (!position_is_reachable(xProbe, yProbe)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
 
         LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
 

commit cf12fc8366f2ffbc3811173769d5428236af0dd9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 5 20:02:46 2019 -0500

    Expand on serial debugging (#13577)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index ff5d3128f9..ba9205b9c3 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -17,22 +17,20 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
-  //#define UBL_DEVEL_DEBUGGING
-
   #include "ubl.h"
 
   #include "../../../Marlin.h"
   #include "../../../HAL/shared/persistent_store_api.h"
   #include "../../../libs/hex_print_routines.h"
   #include "../../../module/configuration_store.h"
   #include "../../../lcd/ultralcd.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
   #include "../../../module/probe.h"

commit cacec5764aee0d1fb5b439d550287970e19f1686
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Apr 3 20:21:06 2019 -0500

    Clean up whitespace

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index e588bd2b50..ff5d3128f9 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -758,28 +758,26 @@
           }
         #endif
 
         if (do_furthest)
           location = find_furthest_invalid_mesh_point();
         else
           location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, NULL);
 
         if (location.x_index >= 0) {    // mesh point found and is reachable by probe
           const float rawx = mesh_index_to_xpos(location.x_index),
-                      rawy = mesh_index_to_ypos(location.y_index);
-
-          const float measured_z = probe_pt(rawx, rawy, stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
+                      rawy = mesh_index_to_ypos(location.y_index),
+                      measured_z = probe_pt(rawx, rawy, stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
           z_values[location.x_index][location.y_index] = measured_z;
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(location.x_index, location.y_index, measured_z);
           #endif
-          
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.x_index >= 0 && --count);
 
       STOW_PROBE();
 
       #ifdef Z_AFTER_PROBING
         move_z_after_probing();
       #endif
 

commit 3fb8489ae333b76412f38d48d6475249abcdfdde
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Mar 17 08:57:54 2019 -0400

    EXTUI and UBL compilation fixes (#13420)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index cf8e89fa61..e588bd2b50 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -42,20 +42,24 @@
   #include "../../../feature/bedlevel/bedlevel.h"
   #include "../../../libs/least_squares_fit.h"
 
   #if ENABLED(DUAL_X_CARRIAGE)
     #include "../../../module/tool_change.h"
   #endif
 
   #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
   #include "../../../core/debug_out.h"
 
+  #if ENABLED(EXTENSIBLE_UI)
+    #include "../../../lcd/extensible_ui/ui_api.h"
+  #endif
+
   #include <math.h>
 
   #define UBL_G29_P31
 
   extern float destination[XYZE], current_position[XYZE];
 
   #if HAS_LCD_MENU
     void _lcd_ubl_output_map_lcd();
   #endif
 
@@ -382,26 +386,27 @@
             #if ENABLED(EXTENSIBLE_UI)
               ExtUI::onMeshUpdate(x, x, z_values[x][x]);
               ExtUI::onMeshUpdate(x, (x + (x < GRID_MAX_POINTS_Y - 1) ? 1 : -1), z_values[x][x + (x < GRID_MAX_POINTS_Y - 1) ? 1 : -1]);
             #endif
 
           }
           break;
 
         case 2:
           // Allow the user to specify the height because 10mm is a little extreme in some cases.
-          for (uint8_t x = (GRID_MAX_POINTS_X) / 3; x < 2 * (GRID_MAX_POINTS_X) / 3; x++)   // Create a rectangular raised area in
-            for (uint8_t y = (GRID_MAX_POINTS_Y) / 3; y < 2 * (GRID_MAX_POINTS_Y) / 3; y++) // the center of the bed
+          for (uint8_t x = (GRID_MAX_POINTS_X) / 3; x < 2 * (GRID_MAX_POINTS_X) / 3; x++)     // Create a rectangular raised area in
+            for (uint8_t y = (GRID_MAX_POINTS_Y) / 3; y < 2 * (GRID_MAX_POINTS_Y) / 3; y++) { // the center of the bed
               z_values[x][y] += parser.seen('C') ? g29_constant : 9.99f;
               #if ENABLED(EXTENSIBLE_UI)
                 ExtUI::onMeshUpdate(x, y, z_values[x][y]);
               #endif
+            }
           break;
       }
     }
 
     #if HAS_BED_PROBE
 
       if (parser.seen('J')) {
         if (g29_grid_size) {  // if not 0 it is a normal n x n grid being probed
           save_ubl_active_state_and_disable();
           tilt_mesh_based_on_probed_grid(false /* false says to do normal grid probing */ );

commit f5bcc00570bd5ae2ba0deaa7af0ba4d3ce7c3b02
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 14 02:25:42 2019 -0500

    Unify debugging output with debug_out.h (#13388)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 8cdae56b0e..cf8e89fa61 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -39,20 +39,23 @@
   #include "../../../gcode/gcode.h"
   #include "../../../core/serial.h"
   #include "../../../gcode/parser.h"
   #include "../../../feature/bedlevel/bedlevel.h"
   #include "../../../libs/least_squares_fit.h"
 
   #if ENABLED(DUAL_X_CARRIAGE)
     #include "../../../module/tool_change.h"
   #endif
 
+  #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
+  #include "../../../core/debug_out.h"
+
   #include <math.h>
 
   #define UBL_G29_P31
 
   extern float destination[XYZE], current_position[XYZE];
 
   #if HAS_LCD_MENU
     void _lcd_ubl_output_map_lcd();
   #endif
 
@@ -435,21 +438,21 @@
 
           case 1:
             //
             // Invalidate Entire Mesh and Automatically Probe Mesh in areas that can be reached by the probe
             //
             if (!parser.seen('C')) {
               invalidate();
               SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
             }
             if (g29_verbose_level > 1) {
-              SERIAL_ECHOPAIR("Probing Mesh Points Closest to (", g29_x_pos);
+              SERIAL_ECHOPAIR("Probing around (", g29_x_pos);
               SERIAL_CHAR(',');
               SERIAL_ECHO(g29_y_pos);
               SERIAL_ECHOLNPGM(").\n");
             }
             probe_entire_mesh(g29_x_pos + X_PROBE_OFFSET_FROM_EXTRUDER, g29_y_pos + Y_PROBE_OFFSET_FROM_EXTRUDER,
                               parser.seen('T'), parser.seen('E'), parser.seen('U'));
 
             report_current_position();
             break;
 
@@ -1456,41 +1459,38 @@
         for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
           const float rx = float(x_min) + ix * dx;
           for (int8_t iy = 0; iy < g29_grid_size; iy++) {
             const float ry = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
 
             if (!abort_flag) {
               measured_z = probe_pt(rx, ry, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
 
               abort_flag = isnan(measured_z);
 
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                if (DEBUGGING(LEVELING)) {
-                  SERIAL_CHAR('(');
-                  SERIAL_ECHO_F(rx, 7);
-                  SERIAL_CHAR(',');
-                  SERIAL_ECHO_F(ry, 7);
-                  SERIAL_ECHOPGM(")   logical: ");
-                  SERIAL_CHAR('(');
-                  SERIAL_ECHO_F(LOGICAL_X_POSITION(rx), 7);
-                  SERIAL_CHAR(',');
-                  SERIAL_ECHO_F(LOGICAL_Y_POSITION(ry), 7);
-                  SERIAL_ECHOPAIR_F(")   measured: ", measured_z, 7);
-                  SERIAL_ECHOPAIR_F("   correction: ", get_z_correction(rx, ry), 7);
-                }
-              #endif
+              if (DEBUGGING(LEVELING)) {
+                DEBUG_CHAR('(');
+                DEBUG_ECHO_F(rx, 7);
+                DEBUG_CHAR(',');
+                DEBUG_ECHO_F(ry, 7);
+                DEBUG_ECHOPGM(")   logical: ");
+                DEBUG_CHAR('(');
+                DEBUG_ECHO_F(LOGICAL_X_POSITION(rx), 7);
+                DEBUG_CHAR(',');
+                DEBUG_ECHO_F(LOGICAL_Y_POSITION(ry), 7);
+                DEBUG_ECHOPAIR_F(")   measured: ", measured_z, 7);
+                DEBUG_ECHOPAIR_F("   correction: ", get_z_correction(rx, ry), 7);
+              }
 
               measured_z -= get_z_correction(rx, ry) /* + zprobe_zoffset */ ;
 
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR_F("   final >>>---> ", measured_z, 7);
-              #endif
+              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR_F("   final >>>---> ", measured_z, 7);
+
               if (g29_verbose_level > 3) {
                 serial_spaces(16);
                 SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
               }
               incremental_LSF(&lsf_results, rx, ry, measured_z);
             }
           }
 
           zig_zag ^= true;
         }
@@ -1517,109 +1517,102 @@
       }
 
       matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
 
       for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
         for (uint8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
           float x_tmp = mesh_index_to_xpos(i),
                 y_tmp = mesh_index_to_ypos(j),
                 z_tmp = z_values[i][j];
 
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOPAIR_F("before rotation = [", x_tmp, 7);
-              SERIAL_CHAR(',');
-              SERIAL_ECHO_F(y_tmp, 7);
-              SERIAL_CHAR(',');
-              SERIAL_ECHO_F(z_tmp, 7);
-              SERIAL_ECHOPGM("]   ---> ");
-              serial_delay(20);
-            }
-          #endif
+          if (DEBUGGING(LEVELING)) {
+            DEBUG_ECHOPAIR_F("before rotation = [", x_tmp, 7);
+            DEBUG_CHAR(',');
+            DEBUG_ECHO_F(y_tmp, 7);
+            DEBUG_CHAR(',');
+            DEBUG_ECHO_F(z_tmp, 7);
+            DEBUG_ECHOPGM("]   ---> ");
+            DEBUG_DELAY(20);
+          }
 
           apply_rotation_xyz(rotation, x_tmp, y_tmp, z_tmp);
 
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOPAIR_F("after rotation = [", x_tmp, 7);
-              SERIAL_CHAR(',');
-              SERIAL_ECHO_F(y_tmp, 7);
-              SERIAL_CHAR(',');
-              SERIAL_ECHO_F(z_tmp, 7);
-              SERIAL_ECHOLNPGM("]");
-              serial_delay(55);
-            }
-          #endif
+          if (DEBUGGING(LEVELING)) {
+            DEBUG_ECHOPAIR_F("after rotation = [", x_tmp, 7);
+            DEBUG_CHAR(',');
+            DEBUG_ECHO_F(y_tmp, 7);
+            DEBUG_CHAR(',');
+            DEBUG_ECHO_F(z_tmp, 7);
+            DEBUG_ECHOLNPGM("]");
+            DEBUG_DELAY(55);
+          }
 
           z_values[i][j] = z_tmp - lsf_results.D;
           #if ENABLED(EXTENSIBLE_UI)
             ExtUI::onMeshUpdate(i, j, z_values[i][j]);
           #endif
         }
       }
 
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          rotation.debug(PSTR("rotation matrix:\n"));
-          SERIAL_ECHOPAIR_F("LSF Results A=", lsf_results.A, 7);
-          SERIAL_ECHOPAIR_F("  B=", lsf_results.B, 7);
-          SERIAL_ECHOLNPAIR_F("  D=", lsf_results.D, 7);
-          serial_delay(55);
-
-          SERIAL_ECHOPAIR_F("bed plane normal = [", normal.x, 7);
-          SERIAL_CHAR(',');
-          SERIAL_ECHO_F(normal.y, 7);
-          SERIAL_CHAR(',');
-          SERIAL_ECHO_F(normal.z, 7);
-          SERIAL_ECHOLNPGM("]");
-          SERIAL_EOL();
-
-          /**
-           * The following code can be used to check the validity of the mesh tilting algorithm.
-           * When a 3-Point Mesh Tilt is done, the same algorithm is used as the grid based tilting.
-           * The only difference is just 3 points are used in the calculations.   That fact guarantees
-           * each probed point should have an exact match when a get_z_correction() for that location
-           * is calculated.  The Z error between the probed point locations and the get_z_correction()
-           * numbers for those locations should be 0.
-           */
-          #if 0
-          float t, t1, d;
-          t = normal.x * (PROBE_PT_1_X) + normal.y * (PROBE_PT_1_Y);
-          d = t + normal.z * z1;
-          SERIAL_ECHOPAIR_F("D from 1st point: ", d, 6);
-          SERIAL_ECHOLNPAIR_F("   Z error: ", normal.z*z1-get_z_correction(PROBE_PT_1_X, PROBE_PT_1_Y), 6);
-
-          t = normal.x * (PROBE_PT_2_X) + normal.y * (PROBE_PT_2_Y);
-          d = t + normal.z * z2;
-          SERIAL_EOL();
-          SERIAL_ECHOPAIR_F("D from 2nd point: ", d, 6);
-          SERIAL_ECHOLNPAIR_F("   Z error: ", normal.z*z2-get_z_correction(PROBE_PT_2_X, PROBE_PT_2_Y), 6);
-
-          t = normal.x * (PROBE_PT_3_X) + normal.y * (PROBE_PT_3_Y);
-          d = t + normal.z * z3;
-          SERIAL_ECHOPAIR_F("D from 3rd point: ", d, 6);
-          SERIAL_ECHOLNPAIR_F("   Z error: ", normal.z*z3-get_z_correction(PROBE_PT_3_X, PROBE_PT_3_Y), 6);
-
-          t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
-          d = t + normal.z * 0;
-          SERIAL_ECHOLNPAIR_F("D from home location with Z=0 : ", d, 6);
-
-          t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
-          d = t + get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT); // normal.z * 0;
-          SERIAL_ECHOPAIR_F("D from home location using mesh value for Z: ", d, 6);
-
-          SERIAL_ECHOPAIR("   Z error: (", Z_SAFE_HOMING_X_POINT);
-          SERIAL_ECHOPAIR(",", Z_SAFE_HOMING_Y_POINT);
-          SERIAL_ECHOLNPAIR_F(") = ", get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT), 6);
-          #endif
-        } // DEBUGGING(LEVELING)
-      #endif
+      if (DEBUGGING(LEVELING)) {
+        rotation.debug(PSTR("rotation matrix:\n"));
+        DEBUG_ECHOPAIR_F("LSF Results A=", lsf_results.A, 7);
+        DEBUG_ECHOPAIR_F("  B=", lsf_results.B, 7);
+        DEBUG_ECHOLNPAIR_F("  D=", lsf_results.D, 7);
+        DEBUG_DELAY(55);
+
+        DEBUG_ECHOPAIR_F("bed plane normal = [", normal.x, 7);
+        DEBUG_CHAR(',');
+        DEBUG_ECHO_F(normal.y, 7);
+        DEBUG_CHAR(',');
+        DEBUG_ECHO_F(normal.z, 7);
+        DEBUG_ECHOLNPGM("]");
+        DEBUG_EOL();
+
+        /**
+         * The following code can be used to check the validity of the mesh tilting algorithm.
+         * When a 3-Point Mesh Tilt is done, the same algorithm is used as the grid based tilting.
+         * The only difference is just 3 points are used in the calculations.   That fact guarantees
+         * each probed point should have an exact match when a get_z_correction() for that location
+         * is calculated.  The Z error between the probed point locations and the get_z_correction()
+         * numbers for those locations should be 0.
+         */
+        #if 0
+        float t, t1, d;
+        t = normal.x * (PROBE_PT_1_X) + normal.y * (PROBE_PT_1_Y);
+        d = t + normal.z * z1;
+        DEBUG_ECHOPAIR_F("D from 1st point: ", d, 6);
+        DEBUG_ECHOLNPAIR_F("   Z error: ", normal.z*z1-get_z_correction(PROBE_PT_1_X, PROBE_PT_1_Y), 6);
+
+        t = normal.x * (PROBE_PT_2_X) + normal.y * (PROBE_PT_2_Y);
+        d = t + normal.z * z2;
+        DEBUG_EOL();
+        DEBUG_ECHOPAIR_F("D from 2nd point: ", d, 6);
+        DEBUG_ECHOLNPAIR_F("   Z error: ", normal.z*z2-get_z_correction(PROBE_PT_2_X, PROBE_PT_2_Y), 6);
+
+        t = normal.x * (PROBE_PT_3_X) + normal.y * (PROBE_PT_3_Y);
+        d = t + normal.z * z3;
+        DEBUG_ECHOPAIR_F("D from 3rd point: ", d, 6);
+        DEBUG_ECHOLNPAIR_F("   Z error: ", normal.z*z3-get_z_correction(PROBE_PT_3_X, PROBE_PT_3_Y), 6);
+
+        t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
+        d = t + normal.z * 0;
+        DEBUG_ECHOLNPAIR_F("D from home location with Z=0 : ", d, 6);
+
+        t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
+        d = t + get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT); // normal.z * 0;
+        DEBUG_ECHOPAIR_F("D from home location using mesh value for Z: ", d, 6);
+
+        DEBUG_ECHOPAIR("   Z error: (", Z_SAFE_HOMING_X_POINT, ",", Z_SAFE_HOMING_Y_POINT);
+        DEBUG_ECHOLNPAIR_F(") = ", get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT), 6);
+        #endif
+      } // DEBUGGING(LEVELING)
 
     }
 
   #endif // HAS_BED_PROBE
 
   #if ENABLED(UBL_G29_P31)
     void unified_bed_leveling::smart_fill_wlsf(const float &weight_factor) {
 
       // For each undefined mesh point, compute a distance-weighted least squares fit
       // from all the originally populated mesh points, weighted toward the point

commit c03df89921ba0327dda27c5df52aadd3754074aa
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Mar 13 01:45:52 2019 -0400

    ExtUI Mesh Leveling Extensions (#13363)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index b04ffac15d..8cdae56b0e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -328,20 +328,23 @@
           const mesh_index_pair location = find_closest_mesh_point_of_type(REAL, g29_x_pos, g29_y_pos, USE_NOZZLE_AS_REFERENCE, NULL);
           if (location.x_index < 0) {
             // No more REACHABLE mesh points to invalidate, so we ASSUME the user
             // meant to invalidate the ENTIRE mesh, which cannot be done with
             // find_closest_mesh_point loop which only returns REACHABLE points.
             set_all_mesh_points_to_value(NAN);
             SERIAL_ECHOLNPGM("Entire Mesh invalidated.\n");
             break;            // No more invalid Mesh Points to populate
           }
           z_values[location.x_index][location.y_index] = NAN;
+          #if ENABLED(EXTENSIBLE_UI)
+            ExtUI::onMeshUpdate(location.x_index, location.y_index, 0);
+          #endif
           cnt++;
         }
       }
       SERIAL_ECHOLNPGM("Locations invalidated.\n");
     }
 
     if (parser.seen('Q')) {
       const int test_pattern = parser.has_value() ? parser.value_int() : -99;
       if (!WITHIN(test_pattern, -1, 2)) {
         SERIAL_ECHOLNPGM("Invalid test_pattern value. (-1 to 2)\n");
@@ -355,36 +358,47 @@
             g29_eeprom_dump();
             break;
         #endif
 
         case 0:
           for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++) {   // Create a bowl shape - similar to
             for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++) { // a poorly calibrated Delta.
               const float p1 = 0.5f * (GRID_MAX_POINTS_X) - x,
                           p2 = 0.5f * (GRID_MAX_POINTS_Y) - y;
               z_values[x][y] += 2.0f * HYPOT(p1, p2);
+              #if ENABLED(EXTENSIBLE_UI)
+                ExtUI::onMeshUpdate(x, y, z_values[x][y]);
+              #endif
             }
           }
           break;
 
         case 1:
           for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++) {  // Create a diagonal line several Mesh cells thick that is raised
             z_values[x][x] += 9.999f;
             z_values[x][x + (x < GRID_MAX_POINTS_Y - 1) ? 1 : -1] += 9.999f; // We want the altered line several mesh points thick
+            #if ENABLED(EXTENSIBLE_UI)
+              ExtUI::onMeshUpdate(x, x, z_values[x][x]);
+              ExtUI::onMeshUpdate(x, (x + (x < GRID_MAX_POINTS_Y - 1) ? 1 : -1), z_values[x][x + (x < GRID_MAX_POINTS_Y - 1) ? 1 : -1]);
+            #endif
+
           }
           break;
 
         case 2:
           // Allow the user to specify the height because 10mm is a little extreme in some cases.
           for (uint8_t x = (GRID_MAX_POINTS_X) / 3; x < 2 * (GRID_MAX_POINTS_X) / 3; x++)   // Create a rectangular raised area in
             for (uint8_t y = (GRID_MAX_POINTS_Y) / 3; y < 2 * (GRID_MAX_POINTS_Y) / 3; y++) // the center of the bed
               z_values[x][y] += parser.seen('C') ? g29_constant : 9.99f;
+              #if ENABLED(EXTENSIBLE_UI)
+                ExtUI::onMeshUpdate(x, y, z_values[x][y]);
+              #endif
           break;
       }
     }
 
     #if HAS_BED_PROBE
 
       if (parser.seen('J')) {
         if (g29_grid_size) {  // if not 0 it is a normal n x n grid being probed
           save_ubl_active_state_and_disable();
           tilt_mesh_based_on_probed_grid(false /* false says to do normal grid probing */ );
@@ -512,20 +526,23 @@
                 if (location.x_index < 0) {
                   // No more REACHABLE INVALID mesh points to populate, so we ASSUME
                   // user meant to populate ALL INVALID mesh points to value
                   for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
                     for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
                       if (isnan(z_values[x][y]))
                         z_values[x][y] = g29_constant;
                   break; // No more invalid Mesh Points to populate
                 }
                 z_values[location.x_index][location.y_index] = g29_constant;
+                #if ENABLED(EXTENSIBLE_UI)
+                  ExtUI::onMeshUpdate(location.x_index, location.y_index, z_values[location.x_index][location.y_index]);
+                #endif
               }
             }
           }
           else {
             const float cvf = parser.value_float();
             switch ((int)truncf(cvf * 10.0f) - 30) {   // 3.1 -> 1
               #if ENABLED(UBL_G29_P31)
                 case 1: {
 
                   // P3.1  use least squares fit to fill missing mesh values
@@ -674,29 +691,37 @@
 
     SERIAL_ECHOLNPAIR("# of samples: ", n);
     SERIAL_ECHOLNPAIR_F("Mean Mesh Height: ", mean, 6);
 
     const float sigma = SQRT(sum_of_diff_squared / (n + 1));
     SERIAL_ECHOLNPAIR_F("Standard Deviation: ", sigma, 6);
 
     if (cflag)
       for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
         for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
-          if (!isnan(z_values[x][y]))
+          if (!isnan(z_values[x][y])) {
             z_values[x][y] -= mean + value;
+            #if ENABLED(EXTENSIBLE_UI)
+              ExtUI::onMeshUpdate(x, y, z_values[x][y]);
+            #endif
+          }
   }
 
   void unified_bed_leveling::shift_mesh_height() {
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
-        if (!isnan(z_values[x][y]))
+        if (!isnan(z_values[x][y])) {
           z_values[x][y] += g29_constant;
+          #if ENABLED(EXTENSIBLE_UI)
+            ExtUI::onMeshUpdate(x, y, z_values[x][y]);
+          #endif
+        }
   }
 
   #if HAS_BED_PROBE
     /**
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
     void unified_bed_leveling::probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
       mesh_index_pair location;
 
@@ -729,20 +754,24 @@
           location = find_furthest_invalid_mesh_point();
         else
           location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, NULL);
 
         if (location.x_index >= 0) {    // mesh point found and is reachable by probe
           const float rawx = mesh_index_to_xpos(location.x_index),
                       rawy = mesh_index_to_ypos(location.y_index);
 
           const float measured_z = probe_pt(rawx, rawy, stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
           z_values[location.x_index][location.y_index] = measured_z;
+          #if ENABLED(EXTENSIBLE_UI)
+            ExtUI::onMeshUpdate(location.x_index, location.y_index, measured_z);
+          #endif
+          
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.x_index >= 0 && --count);
 
       STOW_PROBE();
 
       #ifdef Z_AFTER_PROBING
         move_z_after_probing();
       #endif
 
@@ -887,20 +916,24 @@
         if (click_and_hold()) {
           SERIAL_ECHOLNPGM("\nMesh only partially populated.");
           do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
           ui.release();
           KEEPALIVE_STATE(IN_HANDLER);
           restore_ubl_active_state_and_leave();
           return;
         }
 
         z_values[location.x_index][location.y_index] = current_position[Z_AXIS] - thick;
+        #if ENABLED(EXTENSIBLE_UI)
+          ExtUI::onMeshUpdate(location.x_index, location.y_index, z_values[location.x_index][location.y_index]);
+        #endif
+
         if (g29_verbose_level > 2)
           SERIAL_ECHOLNPAIR_F("Mesh Point Measured at: ", z_values[location.x_index][location.y_index], 6);
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.x_index >= 0 && location.y_index >= 0);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
       restore_ubl_active_state_and_leave();
       KEEPALIVE_STATE(IN_HANDLER);
       do_blocking_move_to(rx, ry, Z_CLEARANCE_DEPLOY_PROBE);
@@ -987,20 +1020,23 @@
           #endif
           idle();
           SERIAL_FLUSH();                                           // Prevent host M105 buffer overrun.
         } while (!ui.button_pressed());
 
         if (!lcd_map_control) ui.return_to_status();                // Just editing a single point? Return to status
 
         if (click_and_hold(abort_fine_tune)) goto FINE_TUNE_EXIT;   // If the click is held down, abort editing
 
         z_values[location.x_index][location.y_index] = new_z;       // Save the updated Z value
+        #if ENABLED(EXTENSIBLE_UI)
+          ExtUI::onMeshUpdate(location.x_index, location.y_index, new_z);
+        #endif
 
         serial_delay(20);                                           // No switch noise
         ui.refresh();
 
       } while (location.x_index >= 0 && --g29_repetition_cnt > 0);
 
       FINE_TUNE_EXIT:
 
       ui.release();
       KEEPALIVE_STATE(IN_HANDLER);
@@ -1291,20 +1327,25 @@
 
   bool unified_bed_leveling::smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
     const int8_t x1 = x + xdir, x2 = x1 + xdir,
                  y1 = y + ydir, y2 = y1 + ydir;
     // A NAN next to a pair of real values?
     if (isnan(z_values[x][y]) && !isnan(z_values[x1][y1]) && !isnan(z_values[x2][y2])) {
       if (z_values[x1][y1] < z_values[x2][y2])                  // Angled downward?
         z_values[x][y] = z_values[x1][y1];                      // Use nearest (maybe a little too high.)
       else
         z_values[x][y] = 2.0f * z_values[x1][y1] - z_values[x2][y2];   // Angled upward...
+
+      #if ENABLED(EXTENSIBLE_UI)
+        ExtUI::onMeshUpdate(x, y, z_values[x][y]);
+      #endif
+
       return true;
     }
     return false;
   }
 
   typedef struct { uint8_t sx, ex, sy, ey; bool yfirst; } smart_fill_info;
 
   void unified_bed_leveling::smart_fill_mesh() {
     static const smart_fill_info
       info0 PROGMEM = { 0, GRID_MAX_POINTS_X,      0, GRID_MAX_POINTS_Y - 2,  false },  // Bottom of the mesh looking up
@@ -1503,20 +1544,23 @@
               SERIAL_CHAR(',');
               SERIAL_ECHO_F(y_tmp, 7);
               SERIAL_CHAR(',');
               SERIAL_ECHO_F(z_tmp, 7);
               SERIAL_ECHOLNPGM("]");
               serial_delay(55);
             }
           #endif
 
           z_values[i][j] = z_tmp - lsf_results.D;
+          #if ENABLED(EXTENSIBLE_UI)
+            ExtUI::onMeshUpdate(i, j, z_values[i][j]);
+          #endif
         }
       }
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
           rotation.debug(PSTR("rotation matrix:\n"));
           SERIAL_ECHOPAIR_F("LSF Results A=", lsf_results.A, 7);
           SERIAL_ECHOPAIR_F("  B=", lsf_results.B, 7);
           SERIAL_ECHOLNPAIR_F("  D=", lsf_results.D, 7);
           serial_delay(55);
@@ -1612,20 +1656,23 @@
                   incremental_WLSF(&lsf_results, rx, ry, rz, w);
                 }
               }
             }
             if (finish_incremental_LSF(&lsf_results)) {
               SERIAL_ECHOLNPGM("Insufficient data");
               return;
             }
             const float ez = -lsf_results.D - lsf_results.A * px - lsf_results.B * py;
             z_values[ix][iy] = ez;
+            #if ENABLED(EXTENSIBLE_UI)
+              ExtUI::onMeshUpdate(ix, iy, z_values[ix][iy]);
+            #endif
             idle();   // housekeeping
           }
         }
       }
 
       SERIAL_ECHOLNPGM("done");
     }
   #endif // UBL_G29_P31
 
   #if ENABLED(UBL_DEVEL_DEBUGGING)
@@ -1750,17 +1797,21 @@
       }
 
       g29_storage_slot = parser.value_int();
 
       float tmp_z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
       settings.load_mesh(g29_storage_slot, &tmp_z_values);
 
       SERIAL_ECHOLNPAIR("Subtracting mesh in slot ", g29_storage_slot, " from current mesh.");
 
       for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
-        for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
+        for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++) {
           z_values[x][y] -= tmp_z_values[x][y];
+          #if ENABLED(EXTENSIBLE_UI)
+            ExtUI::onMeshUpdate(x, y, z_values[x][y]);
+          #endif
+        }
     }
 
   #endif // UBL_DEVEL_DEBUGGING
 
 #endif // AUTO_BED_LEVELING_UBL

commit 39f1222060fd34ec8e61159432a4169811b10d5a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 5 07:53:15 2019 -0600

    One fewer G29 error string

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 42659c920d..b04ffac15d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1730,39 +1730,34 @@
       }
       SERIAL_EOL();
       persistentStore.access_finish();
     }
 
     /**
      * When we are fully debugged, this may go away. But there are some valid
      * use cases for the users. So we can wait and see what to do with it.
      */
     void unified_bed_leveling::g29_compare_current_mesh_to_stored_mesh() {
-      int16_t a = settings.calc_num_meshes();
+      const int16_t a = settings.calc_num_meshes();
 
       if (!a) {
         SERIAL_ECHOLNPGM("?EEPROM storage not available.");
         return;
       }
 
-      if (!parser.has_value()) {
-        SERIAL_ECHOLNPAIR("?Storage slot # required.\n?Use 0 to ", a - 1);
+      if (!parser.has_value() || !WITHIN(g29_storage_slot, 0, a - 1)) {
+        SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
         return;
       }
 
       g29_storage_slot = parser.value_int();
 
-      if (!WITHIN(g29_storage_slot, 0, a - 1)) {
-        SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
-        return;
-      }
-
       float tmp_z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
       settings.load_mesh(g29_storage_slot, &tmp_z_values);
 
       SERIAL_ECHOLNPAIR("Subtracting mesh in slot ", g29_storage_slot, " from current mesh.");
 
       for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
         for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
           z_values[x][y] -= tmp_z_values[x][y];
     }
 

commit cfdb38eda4b4d993bac4a0e8600e776429b42b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 5 06:46:19 2019 -0600

    Allow SERIAL_ECHOPAIR to take up to 12 pairs (#13311)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 637f9bda4a..42659c920d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -591,22 +591,21 @@
       g29_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
 
       int16_t a = settings.calc_num_meshes();
 
       if (!a) {
         SERIAL_ECHOLNPGM("?EEPROM storage not available.");
         return;
       }
 
       if (!WITHIN(g29_storage_slot, 0, a - 1)) {
-        SERIAL_ECHOLNPGM("?Invalid storage slot.");
-        SERIAL_ECHOLNPAIR("?Use 0 to ", a - 1);
+        SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
         return;
       }
 
       settings.load_mesh(g29_storage_slot);
       storage_slot = g29_storage_slot;
 
       SERIAL_ECHOLNPGM("Done.");
     }
 
     //
@@ -620,22 +619,21 @@
         return report_current_mesh();                 // host program to be saved on the user's computer
 
       int16_t a = settings.calc_num_meshes();
 
       if (!a) {
         SERIAL_ECHOLNPGM("?EEPROM storage not available.");
         goto LEAVE;
       }
 
       if (!WITHIN(g29_storage_slot, 0, a - 1)) {
-        SERIAL_ECHOLNPGM("?Invalid storage slot.");
-        SERIAL_ECHOLNPAIR("?Use 0 to ", a - 1);
+        SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
         goto LEAVE;
       }
 
       settings.store_mesh(g29_storage_slot);
       storage_slot = g29_storage_slot;
 
       SERIAL_ECHOLNPGM("Done.");
     }
 
     if (parser.seen('T'))
@@ -1633,24 +1631,22 @@
   #if ENABLED(UBL_DEVEL_DEBUGGING)
     /**
      * Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
      * good to have the extra information. Soon... we prune this to just a few items
      */
     void unified_bed_leveling::g29_what_command() {
       report_state();
 
       if (storage_slot == -1)
         SERIAL_ECHOPGM("No Mesh Loaded.");
-      else {
-        SERIAL_ECHOPAIR("Mesh ", storage_slot);
-        SERIAL_ECHOPGM(" Loaded.");
-      }
+      else
+        SERIAL_ECHOPAIR("Mesh ", storage_slot, " Loaded.");
       SERIAL_EOL();
       serial_delay(50);
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         SERIAL_ECHOLNPAIR_F("planner.z_fade_height : ", planner.z_fade_height, 4);
       #endif
 
       adjust_mesh_to_mean(g29_c_flag, g29_constant);
 
       #if HAS_BED_PROBE
@@ -1676,44 +1672,40 @@
 
       SERIAL_ECHOPGM("Y-Axis Mesh Points at: ");
       for (uint8_t i = 0; i < GRID_MAX_POINTS_Y; i++) {
         SERIAL_ECHO_F(LOGICAL_Y_POSITION(mesh_index_to_ypos(i)), 3);
         SERIAL_ECHOPGM("  ");
         serial_delay(25);
       }
       SERIAL_EOL();
 
       #if HAS_KILL
-        SERIAL_ECHOPAIR("Kill pin on :", KILL_PIN);
-        SERIAL_ECHOLNPAIR("  state:", READ(KILL_PIN));
+        SERIAL_ECHOLNPAIR("Kill pin on :", int(KILL_PIN), "  state:", READ(KILL_PIN));
       #endif
       SERIAL_EOL();
       serial_delay(50);
 
       #if ENABLED(UBL_DEVEL_DEBUGGING)
-        SERIAL_ECHOLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation); SERIAL_EOL();
-        SERIAL_ECHOLNPAIR("ubl_state_recursion_chk :", ubl_state_recursion_chk); SERIAL_EOL();
+        SERIAL_ECHOLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation, "\nubl_state_recursion_chk :", ubl_state_recursion_chk);
         serial_delay(50);
 
-        SERIAL_ECHOPAIR("Meshes go from ", hex_address((void*)settings.meshes_start_index()));
-        SERIAL_ECHOLNPAIR(" to ", hex_address((void*)settings.meshes_end_index()));
+        SERIAL_ECHOLNPAIR("Meshes go from ", hex_address((void*)settings.meshes_start_index()), " to ", hex_address((void*)settings.meshes_end_index()));
         serial_delay(50);
 
         SERIAL_ECHOLNPAIR("sizeof(ubl) :  ", (int)sizeof(ubl));         SERIAL_EOL();
         SERIAL_ECHOLNPAIR("z_value[][] size: ", (int)sizeof(z_values)); SERIAL_EOL();
         serial_delay(25);
 
         SERIAL_ECHOLNPAIR("EEPROM free for UBL: ", hex_address((void*)(settings.meshes_end_index() - settings.meshes_start_index())));
         serial_delay(50);
 
-        SERIAL_ECHOPAIR("EEPROM can hold ", settings.calc_num_meshes());
-        SERIAL_ECHOLNPGM(" meshes.\n");
+        SERIAL_ECHOLNPAIR("EEPROM can hold ", settings.calc_num_meshes(), " meshes.\n");
         serial_delay(25);
       #endif // UBL_DEVEL_DEBUGGING
 
       if (!sanity_check()) {
         echo_name();
         SERIAL_ECHOLNPGM(" sanity checks passed.");
       }
     }
 
     /**
@@ -1746,37 +1738,34 @@
      */
     void unified_bed_leveling::g29_compare_current_mesh_to_stored_mesh() {
       int16_t a = settings.calc_num_meshes();
 
       if (!a) {
         SERIAL_ECHOLNPGM("?EEPROM storage not available.");
         return;
       }
 
       if (!parser.has_value()) {
-        SERIAL_ECHOLNPGM("?Storage slot # required.");
-        SERIAL_ECHOLNPAIR("?Use 0 to ", a - 1);
+        SERIAL_ECHOLNPAIR("?Storage slot # required.\n?Use 0 to ", a - 1);
         return;
       }
 
       g29_storage_slot = parser.value_int();
 
       if (!WITHIN(g29_storage_slot, 0, a - 1)) {
-        SERIAL_ECHOLNPGM("?Invalid storage slot.");
-        SERIAL_ECHOLNPAIR("?Use 0 to ", a - 1);
+        SERIAL_ECHOLNPAIR("?Invalid storage slot.\n?Use 0 to ", a - 1);
         return;
       }
 
       float tmp_z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
       settings.load_mesh(g29_storage_slot, &tmp_z_values);
 
-      SERIAL_ECHOPAIR("Subtracting mesh in slot ", g29_storage_slot);
-      SERIAL_ECHOLNPGM(" from current mesh.");
+      SERIAL_ECHOLNPAIR("Subtracting mesh in slot ", g29_storage_slot, " from current mesh.");
 
       for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
         for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
           z_values[x][y] -= tmp_z_values[x][y];
     }
 
   #endif // UBL_DEVEL_DEBUGGING
 
 #endif // AUTO_BED_LEVELING_UBL

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 574cacd47a..637f9bda4a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit ab6908a513e9ffde6caf41b3f65b6b9a31e8b355
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Tue Feb 5 20:30:20 2019 -0700

    Fix Probe Offset bug...

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index b0e0adc73b..574cacd47a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1234,22 +1234,22 @@
     }
     return out_mesh;
   }
 
   mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const float &rx, const float &ry, const bool probe_as_reference, uint16_t bits[16]) {
     mesh_index_pair out_mesh;
     out_mesh.x_index = out_mesh.y_index = -1;
     out_mesh.distance = -99999.9f;
 
     // Get our reference position. Either the nozzle or probe location.
-    const float px = rx - (probe_as_reference == USE_PROBE_AS_REFERENCE ? X_PROBE_OFFSET_FROM_EXTRUDER : 0),
-                py = ry - (probe_as_reference == USE_PROBE_AS_REFERENCE ? Y_PROBE_OFFSET_FROM_EXTRUDER : 0);
+    const float px = rx + (probe_as_reference == USE_PROBE_AS_REFERENCE ? X_PROBE_OFFSET_FROM_EXTRUDER : 0),
+                py = ry + (probe_as_reference == USE_PROBE_AS_REFERENCE ? Y_PROBE_OFFSET_FROM_EXTRUDER : 0);
 
     float best_so_far = 99999.99f;
 
     for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
 
         if ( (type == INVALID && isnan(z_values[i][j]))  // Check to see if this location holds the right thing
           || (type == REAL && !isnan(z_values[i][j]))
           || (type == SET_IN_BITMAP && is_bitmap_set(bits, i, j))
         ) {

commit 4fa1c52688917b139f1a2a68dd9028a592d4567a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 2 23:32:48 2019 -0600

    Tweak serial output code

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 57f21124b2..b0e0adc73b 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1400,21 +1400,21 @@
             incremental_LSF(&lsf_results, PROBE_PT_3_X, PROBE_PT_3_Y, measured_z);
           }
         }
 
         STOW_PROBE();
         #ifdef Z_AFTER_PROBING
           move_z_after_probing();
         #endif
 
         if (abort_flag) {
-          SERIAL_ECHOPGM("?Error probing point.  Aborting operation.\n");
+          SERIAL_ECHOLNPGM("?Error probing point.  Aborting operation.");
           return;
         }
       }
       else { // !do_3_pt_leveling
 
         bool zig_zag = false;
         for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
           const float rx = float(x_min) + ix * dx;
           for (int8_t iy = 0; iy < g29_grid_size; iy++) {
             const float ry = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 11aec93455..57f21124b2 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -324,37 +324,37 @@
       }
       else {
         while (g29_repetition_cnt--) {
           if (cnt > 20) { cnt = 0; idle(); }
           const mesh_index_pair location = find_closest_mesh_point_of_type(REAL, g29_x_pos, g29_y_pos, USE_NOZZLE_AS_REFERENCE, NULL);
           if (location.x_index < 0) {
             // No more REACHABLE mesh points to invalidate, so we ASSUME the user
             // meant to invalidate the ENTIRE mesh, which cannot be done with
             // find_closest_mesh_point loop which only returns REACHABLE points.
             set_all_mesh_points_to_value(NAN);
-            SERIAL_PROTOCOLLNPGM("Entire Mesh invalidated.\n");
+            SERIAL_ECHOLNPGM("Entire Mesh invalidated.\n");
             break;            // No more invalid Mesh Points to populate
           }
           z_values[location.x_index][location.y_index] = NAN;
           cnt++;
         }
       }
-      SERIAL_PROTOCOLLNPGM("Locations invalidated.\n");
+      SERIAL_ECHOLNPGM("Locations invalidated.\n");
     }
 
     if (parser.seen('Q')) {
       const int test_pattern = parser.has_value() ? parser.value_int() : -99;
       if (!WITHIN(test_pattern, -1, 2)) {
-        SERIAL_PROTOCOLLNPGM("Invalid test_pattern value. (-1 to 2)\n");
+        SERIAL_ECHOLNPGM("Invalid test_pattern value. (-1 to 2)\n");
         return;
       }
-      SERIAL_PROTOCOLLNPGM("Loading test_pattern values.\n");
+      SERIAL_ECHOLNPGM("Loading test_pattern values.\n");
       switch (test_pattern) {
 
         #if ENABLED(UBL_DEVEL_DEBUGGING)
           case -1:
             g29_eeprom_dump();
             break;
         #endif
 
         case 0:
           for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++) {   // Create a bowl shape - similar to
@@ -398,62 +398,62 @@
         }
         do_blocking_move_to_xy(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)));
         report_current_position();
       }
 
     #endif // HAS_BED_PROBE
 
     if (parser.seen('P')) {
       if (WITHIN(g29_phase_value, 0, 1) && storage_slot == -1) {
         storage_slot = 0;
-        SERIAL_PROTOCOLLNPGM("Default storage slot 0 selected.");
+        SERIAL_ECHOLNPGM("Default storage slot 0 selected.");
       }
 
       switch (g29_phase_value) {
         case 0:
           //
           // Zero Mesh Data
           //
           reset();
-          SERIAL_PROTOCOLLNPGM("Mesh zeroed.");
+          SERIAL_ECHOLNPGM("Mesh zeroed.");
           break;
 
         #if HAS_BED_PROBE
 
           case 1:
             //
             // Invalidate Entire Mesh and Automatically Probe Mesh in areas that can be reached by the probe
             //
             if (!parser.seen('C')) {
               invalidate();
-              SERIAL_PROTOCOLLNPGM("Mesh invalidated. Probing mesh.");
+              SERIAL_ECHOLNPGM("Mesh invalidated. Probing mesh.");
             }
             if (g29_verbose_level > 1) {
-              SERIAL_PROTOCOLPAIR("Probing Mesh Points Closest to (", g29_x_pos);
-              SERIAL_PROTOCOLCHAR(',');
-              SERIAL_PROTOCOL(g29_y_pos);
-              SERIAL_PROTOCOLLNPGM(").\n");
+              SERIAL_ECHOPAIR("Probing Mesh Points Closest to (", g29_x_pos);
+              SERIAL_CHAR(',');
+              SERIAL_ECHO(g29_y_pos);
+              SERIAL_ECHOLNPGM(").\n");
             }
             probe_entire_mesh(g29_x_pos + X_PROBE_OFFSET_FROM_EXTRUDER, g29_y_pos + Y_PROBE_OFFSET_FROM_EXTRUDER,
                               parser.seen('T'), parser.seen('E'), parser.seen('U'));
 
             report_current_position();
             break;
 
         #endif // HAS_BED_PROBE
 
         case 2: {
           #if HAS_LCD_MENU
             //
             // Manually Probe Mesh in areas that can't be reached by the probe
             //
-            SERIAL_PROTOCOLLNPGM("Manually probing unreachable mesh locations.");
+            SERIAL_ECHOLNPGM("Manually probing unreachable mesh locations.");
             do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
 
             if (parser.seen('C') && !g29_x_flag && !g29_y_flag) {
               /**
                * Use a good default location for the path.
                * The flipped > and < operators in these comparisons is intentional.
                * It should cause the probed points to follow a nice path on Cartesian printers.
                * It may make sense to have Delta printers default to the center of the bed.
                * Until that is decided, this can be forced with the X and Y parameters.
                */
@@ -462,40 +462,40 @@
                 g29_y_pos = Y_HOME_POS;
               #else // cartesian
                 g29_x_pos = X_PROBE_OFFSET_FROM_EXTRUDER > 0 ? X_BED_SIZE : 0;
                 g29_y_pos = Y_PROBE_OFFSET_FROM_EXTRUDER < 0 ? Y_BED_SIZE : 0;
               #endif
             }
 
             if (parser.seen('B')) {
               g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness((float) Z_CLEARANCE_BETWEEN_PROBES);
               if (ABS(g29_card_thickness) > 1.5f) {
-                SERIAL_PROTOCOLLNPGM("?Error in Business Card measurement.");
+                SERIAL_ECHOLNPGM("?Error in Business Card measurement.");
                 return;
               }
             }
 
             if (!position_is_reachable(g29_x_pos, g29_y_pos)) {
-              SERIAL_PROTOCOLLNPGM("XY outside printable radius.");
+              SERIAL_ECHOLNPGM("XY outside printable radius.");
               return;
             }
 
             const float height = parser.floatval('H', Z_CLEARANCE_BETWEEN_PROBES);
             manually_probe_remaining_mesh(g29_x_pos, g29_y_pos, height, g29_card_thickness, parser.seen('T'));
 
-            SERIAL_PROTOCOLLNPGM("G29 P2 finished.");
+            SERIAL_ECHOLNPGM("G29 P2 finished.");
 
             report_current_position();
 
           #else
 
-            SERIAL_PROTOCOLLNPGM("?P2 is only available when an LCD is present.");
+            SERIAL_ECHOLNPGM("?P2 is only available when an LCD is present.");
             return;
 
           #endif
         } break;
 
         case 3: {
           /**
            * Populate invalid mesh areas. Proceed with caution.
            * Two choices are available:
            *   - Specify a constant with the 'C' parameter.
@@ -546,21 +546,21 @@
                 break;
             }
           }
           break;
         }
 
         case 4: // Fine Tune (i.e., Edit) the Mesh
           #if HAS_LCD_MENU
             fine_tune_mesh(g29_x_pos, g29_y_pos, parser.seen('T'));
           #else
-            SERIAL_PROTOCOLLNPGM("?P4 is only available when an LCD is present.");
+            SERIAL_ECHOLNPGM("?P4 is only available when an LCD is present.");
             return;
           #endif
           break;
 
         case 5: adjust_mesh_to_mean(g29_c_flag, g29_constant); break;
 
         case 6: shift_mesh_height(); break;
       }
     }
 
@@ -586,63 +586,63 @@
     //
     // Load a Mesh from the EEPROM
     //
 
     if (parser.seen('L')) {     // Load Current Mesh Data
       g29_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
 
       int16_t a = settings.calc_num_meshes();
 
       if (!a) {
-        SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
+        SERIAL_ECHOLNPGM("?EEPROM storage not available.");
         return;
       }
 
       if (!WITHIN(g29_storage_slot, 0, a - 1)) {
-        SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
-        SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
+        SERIAL_ECHOLNPGM("?Invalid storage slot.");
+        SERIAL_ECHOLNPAIR("?Use 0 to ", a - 1);
         return;
       }
 
       settings.load_mesh(g29_storage_slot);
       storage_slot = g29_storage_slot;
 
-      SERIAL_PROTOCOLLNPGM("Done.");
+      SERIAL_ECHOLNPGM("Done.");
     }
 
     //
     // Store a Mesh in the EEPROM
     //
 
     if (parser.seen('S')) {     // Store (or Save) Current Mesh Data
       g29_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
 
       if (g29_storage_slot == -1)                     // Special case, the user wants to 'Export' the mesh to the
         return report_current_mesh();                 // host program to be saved on the user's computer
 
       int16_t a = settings.calc_num_meshes();
 
       if (!a) {
-        SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
+        SERIAL_ECHOLNPGM("?EEPROM storage not available.");
         goto LEAVE;
       }
 
       if (!WITHIN(g29_storage_slot, 0, a - 1)) {
-        SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
-        SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
+        SERIAL_ECHOLNPGM("?Invalid storage slot.");
+        SERIAL_ECHOLNPAIR("?Use 0 to ", a - 1);
         goto LEAVE;
       }
 
       settings.store_mesh(g29_storage_slot);
       storage_slot = g29_storage_slot;
 
-      SERIAL_PROTOCOLLNPGM("Done.");
+      SERIAL_ECHOLNPGM("Done.");
     }
 
     if (parser.seen('T'))
       display_map(g29_map_type);
 
     LEAVE:
 
     #if HAS_LCD_MENU
       ui.reset_alert_level();
       ui.quick_feedback();
@@ -668,28 +668,24 @@
     //
     // Sum the squares of difference from mean
     //
     float sum_of_diff_squared = 0;
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
         if (!isnan(z_values[x][y]))
           sum_of_diff_squared += sq(z_values[x][y] - mean);
 
     SERIAL_ECHOLNPAIR("# of samples: ", n);
-    SERIAL_ECHOPGM("Mean Mesh Height: ");
-    SERIAL_ECHO_F(mean, 6);
-    SERIAL_EOL();
+    SERIAL_ECHOLNPAIR_F("Mean Mesh Height: ", mean, 6);
 
     const float sigma = SQRT(sum_of_diff_squared / (n + 1));
-    SERIAL_ECHOPGM("Standard Deviation: ");
-    SERIAL_ECHO_F(sigma, 6);
-    SERIAL_EOL();
+    SERIAL_ECHOLNPAIR_F("Standard Deviation: ", sigma, 6);
 
     if (cflag)
       for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
         for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
           if (!isnan(z_values[x][y]))
             z_values[x][y] -= mean + value;
   }
 
   void unified_bed_leveling::shift_mesh_height() {
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
@@ -714,21 +710,21 @@
       DEPLOY_PROBE();
 
       uint16_t count = GRID_MAX_POINTS;
 
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
         #if HAS_LCD_MENU
           if (ui.button_pressed()) {
             ui.quick_feedback(false); // Preserve button state for click-and-hold
-            SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.\n");
+            SERIAL_ECHOLNPGM("\nMesh only partially populated.\n");
             STOW_PROBE();
             ui.wait_for_release();
             ui.quick_feedback();
             ui.release();
             restore_ubl_active_state_and_leave();
             return;
           }
         #endif
 
         if (do_furthest)
@@ -796,64 +792,63 @@
       }
     }
 
     float unified_bed_leveling::measure_point_with_encoder() {
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       move_z_with_encoder(0.01f);
       KEEPALIVE_STATE(IN_HANDLER);
       return current_position[Z_AXIS];
     }
 
-    static void echo_and_take_a_measurement() { SERIAL_PROTOCOLLNPGM(" and take a measurement."); }
+    static void echo_and_take_a_measurement() { SERIAL_ECHOLNPGM(" and take a measurement."); }
 
     float unified_bed_leveling::measure_business_card_thickness(float in_height) {
       ui.capture();
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
       do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
         //, MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f);
       planner.synchronize();
 
-      SERIAL_PROTOCOLPGM("Place shim under nozzle");
+      SERIAL_ECHOPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       ui.return_to_status();
       echo_and_take_a_measurement();
 
       const float z1 = measure_point_with_encoder();
       do_blocking_move_to_z(current_position[Z_AXIS] + SIZE_OF_LITTLE_RAISE);
       planner.synchronize();
 
-      SERIAL_PROTOCOLPGM("Remove shim");
+      SERIAL_ECHOPGM("Remove shim");
       LCD_MESSAGEPGM(MSG_UBL_BC_REMOVE);
       echo_and_take_a_measurement();
 
       const float z2 = measure_point_with_encoder();
 
       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES);
 
       const float thickness = ABS(z1 - z2);
 
       if (g29_verbose_level > 1) {
-        SERIAL_PROTOCOLPGM("Business Card is ");
-        SERIAL_PROTOCOL_F(thickness, 4);
-        SERIAL_PROTOCOLLNPGM("mm thick.");
+        SERIAL_ECHOPAIR_F("Business Card is ", thickness, 4);
+        SERIAL_ECHOLNPGM("mm thick.");
       }
 
       ui.release();
 
       restore_ubl_active_state_and_leave();
 
       return thickness;
     }
 
     void abort_manual_probe_remaining_mesh() {
-      SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.");
+      SERIAL_ECHOLNPGM("\nMesh only partially populated.");
       do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
       ui.release();
       KEEPALIVE_STATE(IN_HANDLER);
       ui.quick_feedback();
       ubl.restore_ubl_active_state_and_leave();
     }
 
     void unified_bed_leveling::manually_probe_remaining_mesh(const float &rx, const float &ry, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
 
       ui.capture();
@@ -885,34 +880,31 @@
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
         serialprintPGM(parser.seen('B') ? PSTR(MSG_UBL_BC_INSERT) : PSTR(MSG_UBL_BC_INSERT2));
 
         const float z_step = 0.01f;                         // existing behavior: 0.01mm per click, occasionally step
         //const float z_step = planner.steps_to_mm[Z_AXIS]; // approx one step each click
 
         move_z_with_encoder(z_step);
 
         if (click_and_hold()) {
-          SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.");
+          SERIAL_ECHOLNPGM("\nMesh only partially populated.");
           do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
           ui.release();
           KEEPALIVE_STATE(IN_HANDLER);
           restore_ubl_active_state_and_leave();
           return;
         }
 
         z_values[location.x_index][location.y_index] = current_position[Z_AXIS] - thick;
-        if (g29_verbose_level > 2) {
-          SERIAL_PROTOCOLPGM("Mesh Point Measured at: ");
-          SERIAL_PROTOCOL_F(z_values[location.x_index][location.y_index], 6);
-          SERIAL_EOL();
-        }
+        if (g29_verbose_level > 2)
+          SERIAL_ECHOLNPAIR_F("Mesh Point Measured at: ", z_values[location.x_index][location.y_index], 6);
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.x_index >= 0 && location.y_index >= 0);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
       restore_ubl_active_state_and_leave();
       KEEPALIVE_STATE(IN_HANDLER);
       do_blocking_move_to(rx, ry, Z_CLEARANCE_DEPLOY_PROBE);
     }
 
@@ -927,29 +919,29 @@
       set_message_with_feedback(PSTR(MSG_EDITING_STOPPED));
     }
 
     void unified_bed_leveling::fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map) {
       if (!parser.seen('R'))    // fine_tune_mesh() is special. If no repetition count flag is specified
         g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 
       #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
         const float h_offset = parser.seenval('H') ? parser.value_linear_units() : 0;
         if (!WITHIN(h_offset, 0, 10)) {
-          SERIAL_PROTOCOLLNPGM("Offset out of bounds. (0 to 10mm)\n");
+          SERIAL_ECHOLNPGM("Offset out of bounds. (0 to 10mm)\n");
           return;
         }
       #endif
 
       mesh_index_pair location;
 
       if (!position_is_reachable(rx, ry)) {
-        SERIAL_PROTOCOLLNPGM("(X,Y) outside printable radius.");
+        SERIAL_ECHOLNPGM("(X,Y) outside printable radius.");
         return;
       }
 
       save_ubl_active_state_and_disable();
 
       LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
       ui.capture();                                                 // Take over control of the LCD encoder
 
       do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);      // Move to the given XY with probe clearance
 
@@ -1043,110 +1035,110 @@
 
     g29_x_flag = parser.seenval('X');
     g29_x_pos = g29_x_flag ? parser.value_float() : current_position[X_AXIS];
     g29_y_flag = parser.seenval('Y');
     g29_y_pos = g29_y_flag ? parser.value_float() : current_position[Y_AXIS];
 
     if (parser.seen('R')) {
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : GRID_MAX_POINTS;
       NOMORE(g29_repetition_cnt, GRID_MAX_POINTS);
       if (g29_repetition_cnt < 1) {
-        SERIAL_PROTOCOLLNPGM("?(R)epetition count invalid (1+).\n");
+        SERIAL_ECHOLNPGM("?(R)epetition count invalid (1+).\n");
         return UBL_ERR;
       }
     }
 
     g29_verbose_level = parser.seen('V') ? parser.value_int() : 0;
     if (!WITHIN(g29_verbose_level, 0, 4)) {
-      SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).\n");
+      SERIAL_ECHOLNPGM("?(V)erbose level is implausible (0-4).\n");
       err_flag = true;
     }
 
     if (parser.seen('P')) {
       const int pv = parser.value_int();
       #if !HAS_BED_PROBE
         if (pv == 1) {
-          SERIAL_PROTOCOLLNPGM("G29 P1 requires a probe.\n");
+          SERIAL_ECHOLNPGM("G29 P1 requires a probe.\n");
           err_flag = true;
         }
         else
       #endif
         {
           g29_phase_value = pv;
           if (!WITHIN(g29_phase_value, 0, 6)) {
-            SERIAL_PROTOCOLLNPGM("?(P)hase value invalid (0-6).\n");
+            SERIAL_ECHOLNPGM("?(P)hase value invalid (0-6).\n");
             err_flag = true;
           }
         }
     }
 
     if (parser.seen('J')) {
       #if HAS_BED_PROBE
         g29_grid_size = parser.has_value() ? parser.value_int() : 0;
         if (g29_grid_size && !WITHIN(g29_grid_size, 2, 9)) {
-          SERIAL_PROTOCOLLNPGM("?Invalid grid size (J) specified (2-9).\n");
+          SERIAL_ECHOLNPGM("?Invalid grid size (J) specified (2-9).\n");
           err_flag = true;
         }
       #else
-        SERIAL_PROTOCOLLNPGM("G29 J action requires a probe.\n");
+        SERIAL_ECHOLNPGM("G29 J action requires a probe.\n");
         err_flag = true;
       #endif
     }
 
     if (g29_x_flag != g29_y_flag) {
-      SERIAL_PROTOCOLLNPGM("Both X & Y locations must be specified.\n");
+      SERIAL_ECHOLNPGM("Both X & Y locations must be specified.\n");
       err_flag = true;
     }
 
     // If X or Y are not valid, use center of the bed values
     if (!WITHIN(g29_x_pos, X_MIN_BED, X_MAX_BED)) g29_x_pos = X_CENTER;
     if (!WITHIN(g29_y_pos, Y_MIN_BED, Y_MAX_BED)) g29_y_pos = Y_CENTER;
 
     if (err_flag) return UBL_ERR;
 
     /**
      * Activate or deactivate UBL
      * Note: UBL's G29 restores the state set here when done.
      *       Leveling is being enabled here with old data, possibly
      *       none. Error handling should disable for safety...
      */
     if (parser.seen('A')) {
       if (parser.seen('D')) {
-        SERIAL_PROTOCOLLNPGM("?Can't activate and deactivate at the same time.\n");
+        SERIAL_ECHOLNPGM("?Can't activate and deactivate at the same time.\n");
         return UBL_ERR;
       }
       set_bed_leveling_enabled(true);
       report_state();
     }
     else if (parser.seen('D')) {
       set_bed_leveling_enabled(false);
       report_state();
     }
 
     // Set global 'C' flag and its value
     if ((g29_c_flag = parser.seen('C')))
       g29_constant = parser.value_float();
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       if (parser.seenval('F')) {
         const float fh = parser.value_float();
         if (!WITHIN(fh, 0, 100)) {
-          SERIAL_PROTOCOLLNPGM("?(F)ade height for Bed Level Correction not plausible.\n");
+          SERIAL_ECHOLNPGM("?(F)ade height for Bed Level Correction not plausible.\n");
           return UBL_ERR;
         }
         set_z_fade_height(fh);
       }
     #endif
 
     g29_map_type = parser.intval('T');
     if (!WITHIN(g29_map_type, 0, 2)) {
-      SERIAL_PROTOCOLLNPGM("Invalid map type.\n");
+      SERIAL_ECHOLNPGM("Invalid map type.\n");
       return UBL_ERR;
     }
     return UBL_OK;
   }
 
   static uint8_t ubl_state_at_invocation = 0;
 
   #if ENABLED(UBL_DEVEL_DEBUGGING)
     static uint8_t ubl_state_recursion_chk = 0;
   #endif
@@ -1428,43 +1420,37 @@
             const float ry = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
 
             if (!abort_flag) {
               measured_z = probe_pt(rx, ry, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
 
               abort_flag = isnan(measured_z);
 
               #if ENABLED(DEBUG_LEVELING_FEATURE)
                 if (DEBUGGING(LEVELING)) {
                   SERIAL_CHAR('(');
-                  SERIAL_PROTOCOL_F(rx, 7);
+                  SERIAL_ECHO_F(rx, 7);
                   SERIAL_CHAR(',');
-                  SERIAL_PROTOCOL_F(ry, 7);
+                  SERIAL_ECHO_F(ry, 7);
                   SERIAL_ECHOPGM(")   logical: ");
                   SERIAL_CHAR('(');
-                  SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 7);
+                  SERIAL_ECHO_F(LOGICAL_X_POSITION(rx), 7);
                   SERIAL_CHAR(',');
-                  SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 7);
-                  SERIAL_ECHOPGM(")   measured: ");
-                  SERIAL_PROTOCOL_F(measured_z, 7);
-                  SERIAL_ECHOPGM("   correction: ");
-                  SERIAL_PROTOCOL_F(get_z_correction(rx, ry), 7);
+                  SERIAL_ECHO_F(LOGICAL_Y_POSITION(ry), 7);
+                  SERIAL_ECHOPAIR_F(")   measured: ", measured_z, 7);
+                  SERIAL_ECHOPAIR_F("   correction: ", get_z_correction(rx, ry), 7);
                 }
               #endif
 
               measured_z -= get_z_correction(rx, ry) /* + zprobe_zoffset */ ;
 
               #if ENABLED(DEBUG_LEVELING_FEATURE)
-                if (DEBUGGING(LEVELING)) {
-                  SERIAL_ECHOPGM("   final >>>---> ");
-                  SERIAL_PROTOCOL_F(measured_z, 7);
-                  SERIAL_EOL();
-                }
+                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR_F("   final >>>---> ", measured_z, 7);
               #endif
               if (g29_verbose_level > 3) {
                 serial_spaces(16);
                 SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
               }
               incremental_LSF(&lsf_results, rx, ry, measured_z);
             }
           }
 
           zig_zag ^= true;
@@ -1476,141 +1462,119 @@
       #endif
 
       if (abort_flag || finish_incremental_LSF(&lsf_results)) {
         SERIAL_ECHOPGM("Could not complete LSF!");
         return;
       }
 
       vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1).get_normal();
 
       if (g29_verbose_level > 2) {
-        SERIAL_ECHOPGM("bed plane normal = [");
-        SERIAL_PROTOCOL_F(normal.x, 7);
-        SERIAL_PROTOCOLCHAR(',');
-        SERIAL_PROTOCOL_F(normal.y, 7);
-        SERIAL_PROTOCOLCHAR(',');
-        SERIAL_PROTOCOL_F(normal.z, 7);
+        SERIAL_ECHOPAIR_F("bed plane normal = [", normal.x, 7);
+        SERIAL_CHAR(',');
+        SERIAL_ECHO_F(normal.y, 7);
+        SERIAL_CHAR(',');
+        SERIAL_ECHO_F(normal.z, 7);
         SERIAL_ECHOLNPGM("]");
       }
 
       matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
 
       for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
         for (uint8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
           float x_tmp = mesh_index_to_xpos(i),
                 y_tmp = mesh_index_to_ypos(j),
                 z_tmp = z_values[i][j];
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOPGM("before rotation = [");
-              SERIAL_PROTOCOL_F(x_tmp, 7);
-              SERIAL_PROTOCOLCHAR(',');
-              SERIAL_PROTOCOL_F(y_tmp, 7);
-              SERIAL_PROTOCOLCHAR(',');
-              SERIAL_PROTOCOL_F(z_tmp, 7);
+              SERIAL_ECHOPAIR_F("before rotation = [", x_tmp, 7);
+              SERIAL_CHAR(',');
+              SERIAL_ECHO_F(y_tmp, 7);
+              SERIAL_CHAR(',');
+              SERIAL_ECHO_F(z_tmp, 7);
               SERIAL_ECHOPGM("]   ---> ");
               serial_delay(20);
             }
           #endif
 
           apply_rotation_xyz(rotation, x_tmp, y_tmp, z_tmp);
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOPGM("after rotation = [");
-              SERIAL_PROTOCOL_F(x_tmp, 7);
-              SERIAL_PROTOCOLCHAR(',');
-              SERIAL_PROTOCOL_F(y_tmp, 7);
-              SERIAL_PROTOCOLCHAR(',');
-              SERIAL_PROTOCOL_F(z_tmp, 7);
+              SERIAL_ECHOPAIR_F("after rotation = [", x_tmp, 7);
+              SERIAL_CHAR(',');
+              SERIAL_ECHO_F(y_tmp, 7);
+              SERIAL_CHAR(',');
+              SERIAL_ECHO_F(z_tmp, 7);
               SERIAL_ECHOLNPGM("]");
               serial_delay(55);
             }
           #endif
 
           z_values[i][j] = z_tmp - lsf_results.D;
         }
       }
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
           rotation.debug(PSTR("rotation matrix:\n"));
-          SERIAL_ECHOPGM("LSF Results A=");
-          SERIAL_PROTOCOL_F(lsf_results.A, 7);
-          SERIAL_ECHOPGM("  B=");
-          SERIAL_PROTOCOL_F(lsf_results.B, 7);
-          SERIAL_ECHOPGM("  D=");
-          SERIAL_PROTOCOL_F(lsf_results.D, 7);
-          SERIAL_EOL();
+          SERIAL_ECHOPAIR_F("LSF Results A=", lsf_results.A, 7);
+          SERIAL_ECHOPAIR_F("  B=", lsf_results.B, 7);
+          SERIAL_ECHOLNPAIR_F("  D=", lsf_results.D, 7);
           serial_delay(55);
 
-          SERIAL_ECHOPGM("bed plane normal = [");
-          SERIAL_PROTOCOL_F(normal.x, 7);
-          SERIAL_PROTOCOLCHAR(',');
-          SERIAL_PROTOCOL_F(normal.y, 7);
-          SERIAL_PROTOCOLCHAR(',');
-          SERIAL_PROTOCOL_F(normal.z, 7);
-          SERIAL_ECHOPGM("]\n");
+          SERIAL_ECHOPAIR_F("bed plane normal = [", normal.x, 7);
+          SERIAL_CHAR(',');
+          SERIAL_ECHO_F(normal.y, 7);
+          SERIAL_CHAR(',');
+          SERIAL_ECHO_F(normal.z, 7);
+          SERIAL_ECHOLNPGM("]");
           SERIAL_EOL();
 
           /**
            * The following code can be used to check the validity of the mesh tilting algorithm.
            * When a 3-Point Mesh Tilt is done, the same algorithm is used as the grid based tilting.
            * The only difference is just 3 points are used in the calculations.   That fact guarantees
            * each probed point should have an exact match when a get_z_correction() for that location
            * is calculated.  The Z error between the probed point locations and the get_z_correction()
            * numbers for those locations should be 0.
            */
           #if 0
           float t, t1, d;
           t = normal.x * (PROBE_PT_1_X) + normal.y * (PROBE_PT_1_Y);
           d = t + normal.z * z1;
-          SERIAL_ECHOPGM("D from 1st point: ");
-          SERIAL_ECHO_F(d, 6);
-          SERIAL_ECHOPGM("   Z error: ");
-          SERIAL_ECHO_F(normal.z*z1-get_z_correction(PROBE_PT_1_X, PROBE_PT_1_Y), 6);
-          SERIAL_EOL();
+          SERIAL_ECHOPAIR_F("D from 1st point: ", d, 6);
+          SERIAL_ECHOLNPAIR_F("   Z error: ", normal.z*z1-get_z_correction(PROBE_PT_1_X, PROBE_PT_1_Y), 6);
 
           t = normal.x * (PROBE_PT_2_X) + normal.y * (PROBE_PT_2_Y);
           d = t + normal.z * z2;
           SERIAL_EOL();
-          SERIAL_ECHOPGM("D from 2nd point: ");
-          SERIAL_ECHO_F(d, 6);
-          SERIAL_ECHOPGM("   Z error: ");
-          SERIAL_ECHO_F(normal.z*z2-get_z_correction(PROBE_PT_2_X, PROBE_PT_2_Y), 6);
-          SERIAL_EOL();
+          SERIAL_ECHOPAIR_F("D from 2nd point: ", d, 6);
+          SERIAL_ECHOLNPAIR_F("   Z error: ", normal.z*z2-get_z_correction(PROBE_PT_2_X, PROBE_PT_2_Y), 6);
 
           t = normal.x * (PROBE_PT_3_X) + normal.y * (PROBE_PT_3_Y);
           d = t + normal.z * z3;
-          SERIAL_ECHOPGM("D from 3rd point: ");
-          SERIAL_ECHO_F(d, 6);
-          SERIAL_ECHOPGM("   Z error: ");
-          SERIAL_ECHO_F(normal.z*z3-get_z_correction(PROBE_PT_3_X, PROBE_PT_3_Y), 6);
-          SERIAL_EOL();
+          SERIAL_ECHOPAIR_F("D from 3rd point: ", d, 6);
+          SERIAL_ECHOLNPAIR_F("   Z error: ", normal.z*z3-get_z_correction(PROBE_PT_3_X, PROBE_PT_3_Y), 6);
 
           t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
           d = t + normal.z * 0;
-          SERIAL_ECHOPGM("D from home location with Z=0 : ");
-          SERIAL_ECHO_F(d, 6);
-          SERIAL_EOL();
+          SERIAL_ECHOLNPAIR_F("D from home location with Z=0 : ", d, 6);
 
           t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
           d = t + get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT); // normal.z * 0;
-          SERIAL_ECHOPGM("D from home location using mesh value for Z: ");
-          SERIAL_ECHO_F(d, 6);
+          SERIAL_ECHOPAIR_F("D from home location using mesh value for Z: ", d, 6);
 
           SERIAL_ECHOPAIR("   Z error: (", Z_SAFE_HOMING_X_POINT);
-          SERIAL_ECHOPAIR(",", Z_SAFE_HOMING_Y_POINT );
-          SERIAL_ECHOPGM(") = ");
-          SERIAL_ECHO_F(get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT), 6);
-          SERIAL_EOL();
+          SERIAL_ECHOPAIR(",", Z_SAFE_HOMING_Y_POINT);
+          SERIAL_ECHOLNPAIR_F(") = ", get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT), 6);
           #endif
         } // DEBUGGING(LEVELING)
       #endif
 
     }
 
   #endif // HAS_BED_PROBE
 
   #if ENABLED(UBL_G29_P31)
     void unified_bed_leveling::smart_fill_wlsf(const float &weight_factor) {
@@ -1668,156 +1632,151 @@
 
   #if ENABLED(UBL_DEVEL_DEBUGGING)
     /**
      * Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
      * good to have the extra information. Soon... we prune this to just a few items
      */
     void unified_bed_leveling::g29_what_command() {
       report_state();
 
       if (storage_slot == -1)
-        SERIAL_PROTOCOLPGM("No Mesh Loaded.");
+        SERIAL_ECHOPGM("No Mesh Loaded.");
       else {
-        SERIAL_PROTOCOLPAIR("Mesh ", storage_slot);
-        SERIAL_PROTOCOLPGM(" Loaded.");
+        SERIAL_ECHOPAIR("Mesh ", storage_slot);
+        SERIAL_ECHOPGM(" Loaded.");
       }
       SERIAL_EOL();
       serial_delay(50);
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-        SERIAL_PROTOCOLPGM("planner.z_fade_height : ");
-        SERIAL_PROTOCOL_F(planner.z_fade_height, 4);
-        SERIAL_EOL();
+        SERIAL_ECHOLNPAIR_F("planner.z_fade_height : ", planner.z_fade_height, 4);
       #endif
 
       adjust_mesh_to_mean(g29_c_flag, g29_constant);
 
       #if HAS_BED_PROBE
-        SERIAL_PROTOCOLPGM("zprobe_zoffset: ");
-        SERIAL_PROTOCOL_F(zprobe_zoffset, 7);
-        SERIAL_EOL();
+        SERIAL_ECHOLNPAIR_F("zprobe_zoffset: ", zprobe_zoffset, 7);
       #endif
 
       SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); serial_delay(50);
       SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             serial_delay(50);
       SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);             serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_X_DIST  ", MESH_X_DIST);
       SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);                         serial_delay(50);
 
-      SERIAL_PROTOCOLPGM("X-Axis Mesh Points at: ");
+      SERIAL_ECHOPGM("X-Axis Mesh Points at: ");
       for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
-        SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(mesh_index_to_xpos(i)), 3);
-        SERIAL_PROTOCOLPGM("  ");
+        SERIAL_ECHO_F(LOGICAL_X_POSITION(mesh_index_to_xpos(i)), 3);
+        SERIAL_ECHOPGM("  ");
         serial_delay(25);
       }
       SERIAL_EOL();
 
-      SERIAL_PROTOCOLPGM("Y-Axis Mesh Points at: ");
+      SERIAL_ECHOPGM("Y-Axis Mesh Points at: ");
       for (uint8_t i = 0; i < GRID_MAX_POINTS_Y; i++) {
-        SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(mesh_index_to_ypos(i)), 3);
-        SERIAL_PROTOCOLPGM("  ");
+        SERIAL_ECHO_F(LOGICAL_Y_POSITION(mesh_index_to_ypos(i)), 3);
+        SERIAL_ECHOPGM("  ");
         serial_delay(25);
       }
       SERIAL_EOL();
 
       #if HAS_KILL
-        SERIAL_PROTOCOLPAIR("Kill pin on :", KILL_PIN);
-        SERIAL_PROTOCOLLNPAIR("  state:", READ(KILL_PIN));
+        SERIAL_ECHOPAIR("Kill pin on :", KILL_PIN);
+        SERIAL_ECHOLNPAIR("  state:", READ(KILL_PIN));
       #endif
       SERIAL_EOL();
       serial_delay(50);
 
       #if ENABLED(UBL_DEVEL_DEBUGGING)
-        SERIAL_PROTOCOLLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation); SERIAL_EOL();
-        SERIAL_PROTOCOLLNPAIR("ubl_state_recursion_chk :", ubl_state_recursion_chk); SERIAL_EOL();
+        SERIAL_ECHOLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation); SERIAL_EOL();
+        SERIAL_ECHOLNPAIR("ubl_state_recursion_chk :", ubl_state_recursion_chk); SERIAL_EOL();
         serial_delay(50);
 
-        SERIAL_PROTOCOLPAIR("Meshes go from ", hex_address((void*)settings.meshes_start_index()));
-        SERIAL_PROTOCOLLNPAIR(" to ", hex_address((void*)settings.meshes_end_index()));
+        SERIAL_ECHOPAIR("Meshes go from ", hex_address((void*)settings.meshes_start_index()));
+        SERIAL_ECHOLNPAIR(" to ", hex_address((void*)settings.meshes_end_index()));
         serial_delay(50);
 
-        SERIAL_PROTOCOLLNPAIR("sizeof(ubl) :  ", (int)sizeof(ubl));         SERIAL_EOL();
-        SERIAL_PROTOCOLLNPAIR("z_value[][] size: ", (int)sizeof(z_values)); SERIAL_EOL();
+        SERIAL_ECHOLNPAIR("sizeof(ubl) :  ", (int)sizeof(ubl));         SERIAL_EOL();
+        SERIAL_ECHOLNPAIR("z_value[][] size: ", (int)sizeof(z_values)); SERIAL_EOL();
         serial_delay(25);
 
-        SERIAL_PROTOCOLLNPAIR("EEPROM free for UBL: ", hex_address((void*)(settings.meshes_end_index() - settings.meshes_start_index())));
+        SERIAL_ECHOLNPAIR("EEPROM free for UBL: ", hex_address((void*)(settings.meshes_end_index() - settings.meshes_start_index())));
         serial_delay(50);
 
-        SERIAL_PROTOCOLPAIR("EEPROM can hold ", settings.calc_num_meshes());
-        SERIAL_PROTOCOLLNPGM(" meshes.\n");
+        SERIAL_ECHOPAIR("EEPROM can hold ", settings.calc_num_meshes());
+        SERIAL_ECHOLNPGM(" meshes.\n");
         serial_delay(25);
       #endif // UBL_DEVEL_DEBUGGING
 
       if (!sanity_check()) {
         echo_name();
-        SERIAL_PROTOCOLLNPGM(" sanity checks passed.");
+        SERIAL_ECHOLNPGM(" sanity checks passed.");
       }
     }
 
     /**
      * When we are fully debugged, the EEPROM dump command will get deleted also. But
      * right now, it is good to have the extra information. Soon... we prune this.
      */
     void unified_bed_leveling::g29_eeprom_dump() {
       uint8_t cccc;
 
-      SERIAL_ECHO_START();
-      SERIAL_ECHOLNPGM("EEPROM Dump:");
+      SERIAL_ECHO_MSG("EEPROM Dump:");
       persistentStore.access_start();
       for (uint16_t i = 0; i < persistentStore.capacity(); i += 16) {
         if (!(i & 0x3)) idle();
         print_hex_word(i);
         SERIAL_ECHOPGM(": ");
         for (uint16_t j = 0; j < 16; j++) {
           persistentStore.read_data(i + j, &cccc, sizeof(uint8_t));
           print_hex_byte(cccc);
-          SERIAL_ECHO(' ');
+          SERIAL_CHAR(' ');
         }
         SERIAL_EOL();
       }
       SERIAL_EOL();
       persistentStore.access_finish();
     }
 
     /**
      * When we are fully debugged, this may go away. But there are some valid
      * use cases for the users. So we can wait and see what to do with it.
      */
     void unified_bed_leveling::g29_compare_current_mesh_to_stored_mesh() {
       int16_t a = settings.calc_num_meshes();
 
       if (!a) {
-        SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
+        SERIAL_ECHOLNPGM("?EEPROM storage not available.");
         return;
       }
 
       if (!parser.has_value()) {
-        SERIAL_PROTOCOLLNPGM("?Storage slot # required.");
-        SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
+        SERIAL_ECHOLNPGM("?Storage slot # required.");
+        SERIAL_ECHOLNPAIR("?Use 0 to ", a - 1);
         return;
       }
 
       g29_storage_slot = parser.value_int();
 
       if (!WITHIN(g29_storage_slot, 0, a - 1)) {
-        SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
-        SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
+        SERIAL_ECHOLNPGM("?Invalid storage slot.");
+        SERIAL_ECHOLNPAIR("?Use 0 to ", a - 1);
         return;
       }
 
       float tmp_z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
       settings.load_mesh(g29_storage_slot, &tmp_z_values);
 
-      SERIAL_PROTOCOLPAIR("Subtracting mesh in slot ", g29_storage_slot);
-      SERIAL_PROTOCOLLNPGM(" from current mesh.");
+      SERIAL_ECHOPAIR("Subtracting mesh in slot ", g29_storage_slot);
+      SERIAL_ECHOLNPGM(" from current mesh.");
 
       for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
         for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
           z_values[x][y] -= tmp_z_values[x][y];
     }
 
   #endif // UBL_DEVEL_DEBUGGING
 
 #endif // AUTO_BED_LEVELING_UBL

commit 1fcc13b01162c2a59fcb4867cab4256a7bf6a42e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 23 21:05:59 2018 -0600

    Allow Serial Overrun Protection to be disabled

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 3e03dd0fd5..11aec93455 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -773,21 +773,21 @@
         while (ui.button_pressed()) {                // Loop while the encoder is pressed. Uses hardware flag!
           idle();                                 // idle, of course
           if (ELAPSED(millis(), nxt)) {           // After 1.5 seconds
             ui.quick_feedback();
             if (func) (*func)();
             ui.wait_for_release();
             return true;
           }
         }
       }
-      safe_delay(15);
+      serial_delay(15);
       return false;
     }
 
     void unified_bed_leveling::move_z_with_encoder(const float &multiplier) {
       ui.wait_for_release();
       while (!ui.button_pressed()) {
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
         if (encoder_diff) {
           do_blocking_move_to_z(current_position[Z_AXIS] + float(encoder_diff) * multiplier);
@@ -992,27 +992,27 @@
 
         do {
           new_z = lcd_mesh_edit();
           #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
             do_blocking_move_to_z(h_offset + new_z);                // Move the nozzle as the point is edited
           #endif
           idle();
           SERIAL_FLUSH();                                           // Prevent host M105 buffer overrun.
         } while (!ui.button_pressed());
 
-        if (!lcd_map_control) ui.return_to_status();               // Just editing a single point? Return to status
+        if (!lcd_map_control) ui.return_to_status();                // Just editing a single point? Return to status
 
         if (click_and_hold(abort_fine_tune)) goto FINE_TUNE_EXIT;   // If the click is held down, abort editing
 
         z_values[location.x_index][location.y_index] = new_z;       // Save the updated Z value
 
-        safe_delay(20);                                             // No switch noise
+        serial_delay(20);                                           // No switch noise
         ui.refresh();
 
       } while (location.x_index >= 0 && --g29_repetition_cnt > 0);
 
       FINE_TUNE_EXIT:
 
       ui.release();
       KEEPALIVE_STATE(IN_HANDLER);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);
@@ -1502,54 +1502,54 @@
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPGM("before rotation = [");
               SERIAL_PROTOCOL_F(x_tmp, 7);
               SERIAL_PROTOCOLCHAR(',');
               SERIAL_PROTOCOL_F(y_tmp, 7);
               SERIAL_PROTOCOLCHAR(',');
               SERIAL_PROTOCOL_F(z_tmp, 7);
               SERIAL_ECHOPGM("]   ---> ");
-              safe_delay(20);
+              serial_delay(20);
             }
           #endif
 
           apply_rotation_xyz(rotation, x_tmp, y_tmp, z_tmp);
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPGM("after rotation = [");
               SERIAL_PROTOCOL_F(x_tmp, 7);
               SERIAL_PROTOCOLCHAR(',');
               SERIAL_PROTOCOL_F(y_tmp, 7);
               SERIAL_PROTOCOLCHAR(',');
               SERIAL_PROTOCOL_F(z_tmp, 7);
               SERIAL_ECHOLNPGM("]");
-              safe_delay(55);
+              serial_delay(55);
             }
           #endif
 
           z_values[i][j] = z_tmp - lsf_results.D;
         }
       }
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
           rotation.debug(PSTR("rotation matrix:\n"));
           SERIAL_ECHOPGM("LSF Results A=");
           SERIAL_PROTOCOL_F(lsf_results.A, 7);
           SERIAL_ECHOPGM("  B=");
           SERIAL_PROTOCOL_F(lsf_results.B, 7);
           SERIAL_ECHOPGM("  D=");
           SERIAL_PROTOCOL_F(lsf_results.D, 7);
           SERIAL_EOL();
-          safe_delay(55);
+          serial_delay(55);
 
           SERIAL_ECHOPGM("bed plane normal = [");
           SERIAL_PROTOCOL_F(normal.x, 7);
           SERIAL_PROTOCOLCHAR(',');
           SERIAL_PROTOCOL_F(normal.y, 7);
           SERIAL_PROTOCOLCHAR(',');
           SERIAL_PROTOCOL_F(normal.z, 7);
           SERIAL_ECHOPGM("]\n");
           SERIAL_EOL();
 
@@ -1674,87 +1674,87 @@
     void unified_bed_leveling::g29_what_command() {
       report_state();
 
       if (storage_slot == -1)
         SERIAL_PROTOCOLPGM("No Mesh Loaded.");
       else {
         SERIAL_PROTOCOLPAIR("Mesh ", storage_slot);
         SERIAL_PROTOCOLPGM(" Loaded.");
       }
       SERIAL_EOL();
-      safe_delay(50);
+      serial_delay(50);
 
       #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
         SERIAL_PROTOCOLPGM("planner.z_fade_height : ");
         SERIAL_PROTOCOL_F(planner.z_fade_height, 4);
         SERIAL_EOL();
       #endif
 
       adjust_mesh_to_mean(g29_c_flag, g29_constant);
 
       #if HAS_BED_PROBE
         SERIAL_PROTOCOLPGM("zprobe_zoffset: ");
         SERIAL_PROTOCOL_F(zprobe_zoffset, 7);
         SERIAL_EOL();
       #endif
 
-      SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X); safe_delay(50);
-      SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); safe_delay(50);
-      SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); safe_delay(50);
-      SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); safe_delay(50);
-      SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             safe_delay(50);
-      SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);             safe_delay(50);
+      SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X); serial_delay(50);
+      SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); serial_delay(50);
+      SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); serial_delay(50);
+      SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); serial_delay(50);
+      SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             serial_delay(50);
+      SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);             serial_delay(50);
       SERIAL_ECHOLNPAIR("MESH_X_DIST  ", MESH_X_DIST);
-      SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);                         safe_delay(50);
+      SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);                         serial_delay(50);
 
       SERIAL_PROTOCOLPGM("X-Axis Mesh Points at: ");
       for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
         SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(mesh_index_to_xpos(i)), 3);
         SERIAL_PROTOCOLPGM("  ");
-        safe_delay(25);
+        serial_delay(25);
       }
       SERIAL_EOL();
 
       SERIAL_PROTOCOLPGM("Y-Axis Mesh Points at: ");
       for (uint8_t i = 0; i < GRID_MAX_POINTS_Y; i++) {
         SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(mesh_index_to_ypos(i)), 3);
         SERIAL_PROTOCOLPGM("  ");
-        safe_delay(25);
+        serial_delay(25);
       }
       SERIAL_EOL();
 
       #if HAS_KILL
         SERIAL_PROTOCOLPAIR("Kill pin on :", KILL_PIN);
         SERIAL_PROTOCOLLNPAIR("  state:", READ(KILL_PIN));
       #endif
       SERIAL_EOL();
-      safe_delay(50);
+      serial_delay(50);
 
       #if ENABLED(UBL_DEVEL_DEBUGGING)
         SERIAL_PROTOCOLLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation); SERIAL_EOL();
         SERIAL_PROTOCOLLNPAIR("ubl_state_recursion_chk :", ubl_state_recursion_chk); SERIAL_EOL();
-        safe_delay(50);
+        serial_delay(50);
 
         SERIAL_PROTOCOLPAIR("Meshes go from ", hex_address((void*)settings.meshes_start_index()));
         SERIAL_PROTOCOLLNPAIR(" to ", hex_address((void*)settings.meshes_end_index()));
-        safe_delay(50);
+        serial_delay(50);
 
         SERIAL_PROTOCOLLNPAIR("sizeof(ubl) :  ", (int)sizeof(ubl));         SERIAL_EOL();
         SERIAL_PROTOCOLLNPAIR("z_value[][] size: ", (int)sizeof(z_values)); SERIAL_EOL();
-        safe_delay(25);
+        serial_delay(25);
 
         SERIAL_PROTOCOLLNPAIR("EEPROM free for UBL: ", hex_address((void*)(settings.meshes_end_index() - settings.meshes_start_index())));
-        safe_delay(50);
+        serial_delay(50);
 
         SERIAL_PROTOCOLPAIR("EEPROM can hold ", settings.calc_num_meshes());
         SERIAL_PROTOCOLLNPGM(" meshes.\n");
-        safe_delay(25);
+        serial_delay(25);
       #endif // UBL_DEVEL_DEBUGGING
 
       if (!sanity_check()) {
         echo_name();
         SERIAL_PROTOCOLLNPGM(" sanity checks passed.");
       }
     }
 
     /**
      * When we are fully debugged, the EEPROM dump command will get deleted also. But

commit c1e17037e55cfb3220a0f3b190d3f2df8fd72724
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sat Nov 17 21:21:44 2018 -0700

    Various fixes for MarlinUI and ExtUI (#12439)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 9decaeafb3..3e03dd0fd5 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -910,21 +910,21 @@
       } while (location.x_index >= 0 && location.y_index >= 0);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
       restore_ubl_active_state_and_leave();
       KEEPALIVE_STATE(IN_HANDLER);
       do_blocking_move_to(rx, ry, Z_CLEARANCE_DEPLOY_PROBE);
     }
 
     inline void set_message_with_feedback(PGM_P const msg_P) {
-      ui.setstatusPGM(msg_P);
+      ui.set_status_P(msg_P);
       ui.quick_feedback();
     }
 
     void abort_fine_tune() {
       ui.return_to_status();
       do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
       set_message_with_feedback(PSTR(MSG_EDITING_STOPPED));
     }
 
     void unified_bed_leveling::fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map) {

commit df907a905fc95bd7f9d1647e6feeee46e03d5c4b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Nov 12 03:46:41 2018 -0600

    Update UBL comments for debug change

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 80016c2f46..9decaeafb3 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -120,23 +120,20 @@
    *                    the nozzle location is used. If no 'I' value is given, only the point nearest to the location
    *                    is invalidated. Use 'T' to produce a map afterward. This command is useful to invalidate a
    *                    portion of the Mesh so it can be adjusted using other UBL tools. When attempting to invalidate
    *                    an isolated bad mesh point, the 'T' option shows the nozzle position in the Mesh with (#). You
    *                    can move the nozzle around and use this feature to select the center of the area (or cell) to
    *                    invalidate.
    *
    *   J #   Grid       Perform a Grid Based Leveling of the current Mesh using a grid with n points on a side.
    *                    Not specifying a grid size will invoke the 3-Point leveling function.
    *
-   *   K #   Kompare    Kompare current Mesh with stored Mesh # replacing current Mesh with the result. This
-   *                    command literally performs a diff between two Meshes.
-   *
    *   L     Load       Load Mesh from the previously activated location in the EEPROM.
    *
    *   L #   Load       Load Mesh from the specified location in the EEPROM. Set this location as activated
    *                    for subsequent Load and Store operations.
    *
    *   The P or Phase commands are used for the bulk of the work to setup a Mesh. In general, your Mesh will
    *   start off being initialized with a G29 P0 or a G29 P1. Further refinement of the Mesh happens with
    *   each additional Phase that processes it.
    *
    *   P0    Phase 0    Zero Mesh Data and turn off the Mesh Compensation System. This reverts the
@@ -258,26 +255,34 @@
    *                    This option works with all Phase commands (e.g., G29 P4 R 5 T X 50 Y100 C -.1 O)
    *                    This parameter can also specify a Map Type. T0 (the default) is user-readable. T1 can
    *                    is suitable to paste into a spreadsheet for a 3D graph of the mesh.
    *
    *   U     Unlevel    Perform a probe of the outer perimeter to assist in physically leveling unlevel beds.
    *                    Only used for G29 P1 T U. This speeds up the probing of the edge of the bed. Useful
    *                    when the entire bed doesn't need to be probed because it will be adjusted.
    *
    *   V #   Verbosity  Set the verbosity level (0-4) for extra details. (Default 0)
    *
-   *   W     What?      Display valuable Unified Bed Leveling System data.
-   *
    *   X #              X Location for this command
    *
    *   Y #              Y Location for this command
    *
+   * With UBL_DEVEL_DEBUGGING:
+   *
+   *   K #  Kompare     Kompare current Mesh with stored Mesh #, replacing current Mesh with the result.
+   *                    This command literally performs a diff between two Meshes.
+   *
+   *   Q-1  Dump EEPROM Dump the UBL contents stored in EEPROM as HEX format. Useful for developers to help
+   *                    verify correct operation of the UBL.
+   *
+   *   W    What?       Display valuable UBL data.
+   *
    *
    *   Release Notes:
    *   You MUST do M502, M500 to initialize the storage. Failure to do this will cause all
    *   kinds of problems. Enabling EEPROM Storage is required.
    *
    *   When you do a G28 and G29 P1 to automatically build your first mesh, you are going to notice that
    *   UBL probes points increasingly further from the starting location. (The starting location defaults
    *   to the center of the bed.) In contrast, ABL and MBL follow a zigzag pattern. The spiral pattern is
    *   especially better for Delta printers, since it populates the center of the mesh first, allowing for
    *   a quicker test print to verify settings. You don't need to populate the entire mesh to use it.

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 71c0097f78..80016c2f46 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -46,21 +46,20 @@
     #include "../../../module/tool_change.h"
   #endif
 
   #include <math.h>
 
   #define UBL_G29_P31
 
   extern float destination[XYZE], current_position[XYZE];
 
   #if HAS_LCD_MENU
-    void lcd_return_to_status();
     void _lcd_ubl_output_map_lcd();
   #endif
 
   #define SIZE_OF_LITTLE_RAISE 1
   #define BIG_RAISE_NOT_NEEDED 0
 
   int    unified_bed_leveling::g29_verbose_level,
          unified_bed_leveling::g29_phase_value,
          unified_bed_leveling::g29_repetition_cnt,
          unified_bed_leveling::g29_storage_slot = 0,
@@ -338,38 +337,44 @@
     }
 
     if (parser.seen('Q')) {
       const int test_pattern = parser.has_value() ? parser.value_int() : -99;
       if (!WITHIN(test_pattern, -1, 2)) {
         SERIAL_PROTOCOLLNPGM("Invalid test_pattern value. (-1 to 2)\n");
         return;
       }
       SERIAL_PROTOCOLLNPGM("Loading test_pattern values.\n");
       switch (test_pattern) {
-        case -1:
-          g29_eeprom_dump();
-          break;
+
+        #if ENABLED(UBL_DEVEL_DEBUGGING)
+          case -1:
+            g29_eeprom_dump();
+            break;
+        #endif
+
         case 0:
           for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++) {   // Create a bowl shape - similar to
             for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++) { // a poorly calibrated Delta.
               const float p1 = 0.5f * (GRID_MAX_POINTS_X) - x,
                           p2 = 0.5f * (GRID_MAX_POINTS_Y) - y;
               z_values[x][y] += 2.0f * HYPOT(p1, p2);
             }
           }
           break;
+
         case 1:
           for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++) {  // Create a diagonal line several Mesh cells thick that is raised
             z_values[x][x] += 9.999f;
             z_values[x][x + (x < GRID_MAX_POINTS_Y - 1) ? 1 : -1] += 9.999f; // We want the altered line several mesh points thick
           }
           break;
+
         case 2:
           // Allow the user to specify the height because 10mm is a little extreme in some cases.
           for (uint8_t x = (GRID_MAX_POINTS_X) / 3; x < 2 * (GRID_MAX_POINTS_X) / 3; x++)   // Create a rectangular raised area in
             for (uint8_t y = (GRID_MAX_POINTS_Y) / 3; y < 2 * (GRID_MAX_POINTS_Y) / 3; y++) // the center of the bed
               z_values[x][y] += parser.seen('C') ? g29_constant : 9.99f;
           break;
       }
     }
 
     #if HAS_BED_PROBE
@@ -547,33 +552,38 @@
             return;
           #endif
           break;
 
         case 5: adjust_mesh_to_mean(g29_c_flag, g29_constant); break;
 
         case 6: shift_mesh_height(); break;
       }
     }
 
-    //
-    // Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
-    // good to have the extra information. Soon... we prune this to just a few items
-    //
-    if (parser.seen('W')) g29_what_command();
+    #if ENABLED(UBL_DEVEL_DEBUGGING)
 
-    //
-    // When we are fully debugged, this may go away. But there are some valid
-    // use cases for the users. So we can wait and see what to do with it.
-    //
+      //
+      // Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
+      // good to have the extra information. Soon... we prune this to just a few items
+      //
+      if (parser.seen('W')) g29_what_command();
+
+      //
+      // When we are fully debugged, this may go away. But there are some valid
+      // use cases for the users. So we can wait and see what to do with it.
+      //
+
+      if (parser.seen('K')) // Kompare Current Mesh Data to Specified Stored Mesh
+        g29_compare_current_mesh_to_stored_mesh();
+
+    #endif // UBL_DEVEL_DEBUGGING
 
-    if (parser.seen('K')) // Kompare Current Mesh Data to Specified Stored Mesh
-      g29_compare_current_mesh_to_stored_mesh();
 
     //
     // Load a Mesh from the EEPROM
     //
 
     if (parser.seen('L')) {     // Load Current Mesh Data
       g29_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
 
       int16_t a = settings.calc_num_meshes();
 
@@ -622,24 +632,24 @@
 
       SERIAL_PROTOCOLLNPGM("Done.");
     }
 
     if (parser.seen('T'))
       display_map(g29_map_type);
 
     LEAVE:
 
     #if HAS_LCD_MENU
-      lcd_reset_alert_level();
-      lcd_quick_feedback();
-      lcd_reset_status();
-      lcd_external_control = false;
+      ui.reset_alert_level();
+      ui.quick_feedback();
+      ui.reset_status();
+      ui.release();
     #endif
 
     return;
   }
 
   void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float value) {
     float sum = 0;
     int n = 0;
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
@@ -676,72 +686,48 @@
             z_values[x][y] -= mean + value;
   }
 
   void unified_bed_leveling::shift_mesh_height() {
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
         if (!isnan(z_values[x][y]))
           z_values[x][y] += g29_constant;
   }
 
-  #if HAS_LCD_MENU
-
-    typedef void (*clickFunc_t)();
-
-    bool click_and_hold(const clickFunc_t func=NULL) {
-      if (is_lcd_clicked()) {
-        lcd_quick_feedback(false);                // Preserve button state for click-and-hold
-        const millis_t nxt = millis() + 1500UL;
-        while (is_lcd_clicked()) {                // Loop while the encoder is pressed. Uses hardware flag!
-          idle();                                 // idle, of course
-          if (ELAPSED(millis(), nxt)) {           // After 1.5 seconds
-            lcd_quick_feedback();
-            if (func) (*func)();
-            wait_for_release();
-            return true;
-          }
-        }
-      }
-      safe_delay(15);
-      return false;
-    }
-
-  #endif // HAS_LCD_MENU
-
   #if HAS_BED_PROBE
     /**
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
     void unified_bed_leveling::probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
       mesh_index_pair location;
 
       #if HAS_LCD_MENU
-        lcd_external_control = true;
+        ui.capture();
       #endif
 
-      save_ubl_active_state_and_disable();   // No bed level correction so only raw data is obtained
+      save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       DEPLOY_PROBE();
 
       uint16_t count = GRID_MAX_POINTS;
 
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
         #if HAS_LCD_MENU
-          if (is_lcd_clicked()) {
-            lcd_quick_feedback(false); // Preserve button state for click-and-hold
+          if (ui.button_pressed()) {
+            ui.quick_feedback(false); // Preserve button state for click-and-hold
             SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.\n");
             STOW_PROBE();
-            wait_for_release();
-            lcd_quick_feedback();
-            lcd_external_control = false;
+            ui.wait_for_release();
+            ui.quick_feedback();
+            ui.release();
             restore_ubl_active_state_and_leave();
             return;
           }
         #endif
 
         if (do_furthest)
           location = find_furthest_invalid_mesh_point();
         else
           location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, NULL);
 
@@ -762,57 +748,76 @@
       #endif
 
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
         constrain(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_X, MESH_MAX_X),
         constrain(ry - (Y_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 
-
   #endif // HAS_BED_PROBE
 
   #if HAS_LCD_MENU
 
+    typedef void (*clickFunc_t)();
+
+    bool click_and_hold(const clickFunc_t func=NULL) {
+      if (ui.button_pressed()) {
+        ui.quick_feedback(false);                // Preserve button state for click-and-hold
+        const millis_t nxt = millis() + 1500UL;
+        while (ui.button_pressed()) {                // Loop while the encoder is pressed. Uses hardware flag!
+          idle();                                 // idle, of course
+          if (ELAPSED(millis(), nxt)) {           // After 1.5 seconds
+            ui.quick_feedback();
+            if (func) (*func)();
+            ui.wait_for_release();
+            return true;
+          }
+        }
+      }
+      safe_delay(15);
+      return false;
+    }
+
     void unified_bed_leveling::move_z_with_encoder(const float &multiplier) {
-      wait_for_release();
-      while (!is_lcd_clicked()) {
+      ui.wait_for_release();
+      while (!ui.button_pressed()) {
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
         if (encoder_diff) {
           do_blocking_move_to_z(current_position[Z_AXIS] + float(encoder_diff) * multiplier);
           encoder_diff = 0;
         }
       }
     }
 
     float unified_bed_leveling::measure_point_with_encoder() {
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       move_z_with_encoder(0.01f);
       KEEPALIVE_STATE(IN_HANDLER);
       return current_position[Z_AXIS];
     }
 
     static void echo_and_take_a_measurement() { SERIAL_PROTOCOLLNPGM(" and take a measurement."); }
 
     float unified_bed_leveling::measure_business_card_thickness(float in_height) {
-      lcd_external_control = true;
+      ui.capture();
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
       do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
         //, MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f);
       planner.synchronize();
 
       SERIAL_PROTOCOLPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
-      lcd_return_to_status();
+      ui.return_to_status();
       echo_and_take_a_measurement();
 
       const float z1 = measure_point_with_encoder();
       do_blocking_move_to_z(current_position[Z_AXIS] + SIZE_OF_LITTLE_RAISE);
       planner.synchronize();
 
       SERIAL_PROTOCOLPGM("Remove shim");
       LCD_MESSAGEPGM(MSG_UBL_BC_REMOVE);
       echo_and_take_a_measurement();
 
@@ -821,103 +826,212 @@
       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES);
 
       const float thickness = ABS(z1 - z2);
 
       if (g29_verbose_level > 1) {
         SERIAL_PROTOCOLPGM("Business Card is ");
         SERIAL_PROTOCOL_F(thickness, 4);
         SERIAL_PROTOCOLLNPGM("mm thick.");
       }
 
-      lcd_external_control = false;
+      ui.release();
 
       restore_ubl_active_state_and_leave();
 
       return thickness;
     }
 
     void abort_manual_probe_remaining_mesh() {
       SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.");
       do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
-      lcd_external_control = false;
+      ui.release();
       KEEPALIVE_STATE(IN_HANDLER);
-      lcd_quick_feedback();
+      ui.quick_feedback();
       ubl.restore_ubl_active_state_and_leave();
     }
 
     void unified_bed_leveling::manually_probe_remaining_mesh(const float &rx, const float &ry, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
 
-      lcd_external_control = true;
+      ui.capture();
 
-      save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
+      save_ubl_active_state_and_disable();  // No bed level correction so only raw data is obtained
       do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z_clearance);
 
-      lcd_return_to_status();
+      ui.return_to_status();
 
       mesh_index_pair location;
       do {
         location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_NOZZLE_AS_REFERENCE, NULL);
         // It doesn't matter if the probe can't reach the NAN location. This is a manual probe.
         if (location.x_index < 0 && location.y_index < 0) continue;
 
         const float xProbe = mesh_index_to_xpos(location.x_index),
                     yProbe = mesh_index_to_ypos(location.y_index);
 
         if (!position_is_reachable(xProbe, yProbe)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
 
         LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
 
         do_blocking_move_to(xProbe, yProbe, Z_CLEARANCE_BETWEEN_PROBES);
         do_blocking_move_to_z(z_clearance);
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
-        lcd_external_control = true;
+        ui.capture();
 
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
         serialprintPGM(parser.seen('B') ? PSTR(MSG_UBL_BC_INSERT) : PSTR(MSG_UBL_BC_INSERT2));
 
         const float z_step = 0.01f;                         // existing behavior: 0.01mm per click, occasionally step
         //const float z_step = planner.steps_to_mm[Z_AXIS]; // approx one step each click
 
         move_z_with_encoder(z_step);
 
         if (click_and_hold()) {
           SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.");
           do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
-          lcd_external_control = false;
+          ui.release();
           KEEPALIVE_STATE(IN_HANDLER);
           restore_ubl_active_state_and_leave();
           return;
         }
 
         z_values[location.x_index][location.y_index] = current_position[Z_AXIS] - thick;
         if (g29_verbose_level > 2) {
           SERIAL_PROTOCOLPGM("Mesh Point Measured at: ");
           SERIAL_PROTOCOL_F(z_values[location.x_index][location.y_index], 6);
           SERIAL_EOL();
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.x_index >= 0 && location.y_index >= 0);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
       restore_ubl_active_state_and_leave();
       KEEPALIVE_STATE(IN_HANDLER);
       do_blocking_move_to(rx, ry, Z_CLEARANCE_DEPLOY_PROBE);
     }
-  #endif // HAS_LCD_MENU
 
-  inline void set_message_with_feedback(PGM_P const msg_P) {
-    lcd_setstatusPGM(msg_P);
-    lcd_quick_feedback();
-  }
+    inline void set_message_with_feedback(PGM_P const msg_P) {
+      ui.setstatusPGM(msg_P);
+      ui.quick_feedback();
+    }
+
+    void abort_fine_tune() {
+      ui.return_to_status();
+      do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
+      set_message_with_feedback(PSTR(MSG_EDITING_STOPPED));
+    }
+
+    void unified_bed_leveling::fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map) {
+      if (!parser.seen('R'))    // fine_tune_mesh() is special. If no repetition count flag is specified
+        g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
+
+      #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
+        const float h_offset = parser.seenval('H') ? parser.value_linear_units() : 0;
+        if (!WITHIN(h_offset, 0, 10)) {
+          SERIAL_PROTOCOLLNPGM("Offset out of bounds. (0 to 10mm)\n");
+          return;
+        }
+      #endif
+
+      mesh_index_pair location;
+
+      if (!position_is_reachable(rx, ry)) {
+        SERIAL_PROTOCOLLNPGM("(X,Y) outside printable radius.");
+        return;
+      }
+
+      save_ubl_active_state_and_disable();
+
+      LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
+      ui.capture();                                                 // Take over control of the LCD encoder
+
+      do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);      // Move to the given XY with probe clearance
+
+      #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
+        do_blocking_move_to_z(h_offset);                            // Move Z to the given 'H' offset
+      #endif
+
+      uint16_t not_done[16];
+      memset(not_done, 0xFF, sizeof(not_done));
+      do {
+        location = find_closest_mesh_point_of_type(SET_IN_BITMAP, rx, ry, USE_NOZZLE_AS_REFERENCE, not_done);
+
+        if (location.x_index < 0) break;                            // Stop when there are no more reachable points
+
+        bitmap_clear(not_done, location.x_index, location.y_index); // Mark this location as 'adjusted' so a new
+                                                                    // location is used on the next loop
+
+        const float rawx = mesh_index_to_xpos(location.x_index),
+                    rawy = mesh_index_to_ypos(location.y_index);
+
+        if (!position_is_reachable(rawx, rawy)) break;              // SHOULD NOT OCCUR because find_closest_mesh_point_of_type will only return reachable
+
+        do_blocking_move_to(rawx, rawy, Z_CLEARANCE_BETWEEN_PROBES); // Move the nozzle to the edit point with probe clearance
+
+        #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
+          do_blocking_move_to_z(h_offset);                          // Move Z to the given 'H' offset before editing
+        #endif
+
+        KEEPALIVE_STATE(PAUSED_FOR_USER);
+
+        if (do_ubl_mesh_map) display_map(g29_map_type);             // Display the current point
+
+        ui.refresh();
+
+        float new_z = z_values[location.x_index][location.y_index];
+        if (isnan(new_z)) new_z = 0;                                // Invalid points begin at 0
+        new_z = FLOOR(new_z * 1000) * 0.001f;                       // Chop off digits after the 1000ths place
+
+        lcd_mesh_edit_setup(new_z);
+
+        do {
+          new_z = lcd_mesh_edit();
+          #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
+            do_blocking_move_to_z(h_offset + new_z);                // Move the nozzle as the point is edited
+          #endif
+          idle();
+          SERIAL_FLUSH();                                           // Prevent host M105 buffer overrun.
+        } while (!ui.button_pressed());
+
+        if (!lcd_map_control) ui.return_to_status();               // Just editing a single point? Return to status
+
+        if (click_and_hold(abort_fine_tune)) goto FINE_TUNE_EXIT;   // If the click is held down, abort editing
+
+        z_values[location.x_index][location.y_index] = new_z;       // Save the updated Z value
+
+        safe_delay(20);                                             // No switch noise
+        ui.refresh();
+
+      } while (location.x_index >= 0 && --g29_repetition_cnt > 0);
+
+      FINE_TUNE_EXIT:
+
+      ui.release();
+      KEEPALIVE_STATE(IN_HANDLER);
+
+      if (do_ubl_mesh_map) display_map(g29_map_type);
+      restore_ubl_active_state_and_leave();
+
+      do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);
+
+      LCD_MESSAGEPGM(MSG_UBL_DONE_EDITING_MESH);
+      SERIAL_ECHOLNPGM("Done Editing Mesh");
+
+      if (lcd_map_control)
+        ui.goto_screen(_lcd_ubl_output_map_lcd);
+      else
+        ui.return_to_status();
+    }
+
+  #endif // HAS_LCD_MENU
 
   bool unified_bed_leveling::g29_parameter_parsing() {
     bool err_flag = false;
 
     #if HAS_LCD_MENU
       set_message_with_feedback(PSTR(MSG_UBL_DOING_G29));
     #endif
 
     g29_constant = 0;
     g29_repetition_cnt = 0;
@@ -1053,184 +1167,20 @@
         SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
         #if HAS_LCD_MENU
           set_message_with_feedback(PSTR(MSG_UBL_RESTORE_ERROR));
         #endif
         return;
       }
     #endif
     set_bed_leveling_enabled(ubl_state_at_invocation);
   }
 
-  /**
-   * Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
-   * good to have the extra information. Soon... we prune this to just a few items
-   */
-  void unified_bed_leveling::g29_what_command() {
-    report_state();
-
-    if (storage_slot == -1)
-      SERIAL_PROTOCOLPGM("No Mesh Loaded.");
-    else {
-      SERIAL_PROTOCOLPAIR("Mesh ", storage_slot);
-      SERIAL_PROTOCOLPGM(" Loaded.");
-    }
-    SERIAL_EOL();
-    safe_delay(50);
-
-    SERIAL_PROTOCOLLNPAIR("UBL object count: ", (int)ubl_cnt);
-
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      SERIAL_PROTOCOLPGM("planner.z_fade_height : ");
-      SERIAL_PROTOCOL_F(planner.z_fade_height, 4);
-      SERIAL_EOL();
-    #endif
-
-    adjust_mesh_to_mean(g29_c_flag, g29_constant);
-
-    #if HAS_BED_PROBE
-      SERIAL_PROTOCOLPGM("zprobe_zoffset: ");
-      SERIAL_PROTOCOL_F(zprobe_zoffset, 7);
-      SERIAL_EOL();
-    #endif
-
-    SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X);
-    safe_delay(50);
-    SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y);
-    safe_delay(50);
-    SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X);
-    safe_delay(50);
-    SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y);
-    safe_delay(50);
-    SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);
-    safe_delay(50);
-    SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);
-    safe_delay(50);
-    SERIAL_ECHOLNPAIR("MESH_X_DIST  ", MESH_X_DIST);
-    SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);
-    safe_delay(50);
-
-    SERIAL_PROTOCOLPGM("X-Axis Mesh Points at: ");
-    for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
-      SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(mesh_index_to_xpos(i)), 3);
-      SERIAL_PROTOCOLPGM("  ");
-      safe_delay(25);
-    }
-    SERIAL_EOL();
-
-    SERIAL_PROTOCOLPGM("Y-Axis Mesh Points at: ");
-    for (uint8_t i = 0; i < GRID_MAX_POINTS_Y; i++) {
-      SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(mesh_index_to_ypos(i)), 3);
-      SERIAL_PROTOCOLPGM("  ");
-      safe_delay(25);
-    }
-    SERIAL_EOL();
-
-    #if HAS_KILL
-      SERIAL_PROTOCOLPAIR("Kill pin on :", KILL_PIN);
-      SERIAL_PROTOCOLLNPAIR("  state:", READ(KILL_PIN));
-    #endif
-    SERIAL_EOL();
-    safe_delay(50);
-
-    #if ENABLED(UBL_DEVEL_DEBUGGING)
-      SERIAL_PROTOCOLLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation);
-      SERIAL_EOL();
-      SERIAL_PROTOCOLLNPAIR("ubl_state_recursion_chk :", ubl_state_recursion_chk);
-      SERIAL_EOL();
-      safe_delay(50);
-
-      SERIAL_PROTOCOLPAIR("Meshes go from ", hex_address((void*)settings.meshes_start_index()));
-      SERIAL_PROTOCOLLNPAIR(" to ", hex_address((void*)settings.meshes_end_index()));
-      safe_delay(50);
-
-      SERIAL_PROTOCOLLNPAIR("sizeof(ubl) :  ", (int)sizeof(ubl));
-      SERIAL_EOL();
-      SERIAL_PROTOCOLLNPAIR("z_value[][] size: ", (int)sizeof(z_values));
-      SERIAL_EOL();
-      safe_delay(25);
-
-      SERIAL_PROTOCOLLNPAIR("EEPROM free for UBL: ", hex_address((void*)(settings.meshes_end_index() - settings.meshes_start_index())));
-      safe_delay(50);
-
-      SERIAL_PROTOCOLPAIR("EEPROM can hold ", settings.calc_num_meshes());
-      SERIAL_PROTOCOLLNPGM(" meshes.\n");
-      safe_delay(25);
-    #endif // UBL_DEVEL_DEBUGGING
-
-    if (!sanity_check()) {
-      echo_name();
-      SERIAL_PROTOCOLLNPGM(" sanity checks passed.");
-    }
-  }
-
-  /**
-   * When we are fully debugged, the EEPROM dump command will get deleted also. But
-   * right now, it is good to have the extra information. Soon... we prune this.
-   */
-  void unified_bed_leveling::g29_eeprom_dump() {
-    uint8_t cccc;
-
-    SERIAL_ECHO_START();
-    SERIAL_ECHOLNPGM("EEPROM Dump:");
-    persistentStore.access_start();
-    for (uint16_t i = 0; i < persistentStore.capacity(); i += 16) {
-      if (!(i & 0x3)) idle();
-      print_hex_word(i);
-      SERIAL_ECHOPGM(": ");
-      for (uint16_t j = 0; j < 16; j++) {
-        persistentStore.read_data(i + j, &cccc, sizeof(uint8_t));
-        print_hex_byte(cccc);
-        SERIAL_ECHO(' ');
-      }
-      SERIAL_EOL();
-    }
-    SERIAL_EOL();
-    persistentStore.access_finish();
-  }
-
-  /**
-   * When we are fully debugged, this may go away. But there are some valid
-   * use cases for the users. So we can wait and see what to do with it.
-   */
-  void unified_bed_leveling::g29_compare_current_mesh_to_stored_mesh() {
-    int16_t a = settings.calc_num_meshes();
-
-    if (!a) {
-      SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
-      return;
-    }
-
-    if (!parser.has_value()) {
-      SERIAL_PROTOCOLLNPGM("?Storage slot # required.");
-      SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
-      return;
-    }
-
-    g29_storage_slot = parser.value_int();
-
-    if (!WITHIN(g29_storage_slot, 0, a - 1)) {
-      SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
-      SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
-      return;
-    }
-
-    float tmp_z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
-    settings.load_mesh(g29_storage_slot, &tmp_z_values);
-
-    SERIAL_PROTOCOLPAIR("Subtracting mesh in slot ", g29_storage_slot);
-    SERIAL_PROTOCOLLNPGM(" from current mesh.");
-
-    for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
-      for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
-        z_values[x][y] -= tmp_z_values[x][y];
-  }
-
   mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
     bool found_a_NAN  = false, found_a_real = false;
 
     mesh_index_pair out_mesh;
     out_mesh.x_index = out_mesh.y_index = -1;
     out_mesh.distance = -99999.99f;
 
     for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
@@ -1331,132 +1281,20 @@
             out_mesh.y_index = j;
             out_mesh.distance = best_so_far;
           }
         }
       } // for j
     } // for i
 
     return out_mesh;
   }
 
-  #if HAS_LCD_MENU
-
-    void abort_fine_tune() {
-      lcd_return_to_status();
-      do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
-      set_message_with_feedback(PSTR(MSG_EDITING_STOPPED));
-    }
-
-    void unified_bed_leveling::fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map) {
-      if (!parser.seen('R'))    // fine_tune_mesh() is special. If no repetition count flag is specified
-        g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
-
-      #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
-        const float h_offset = parser.seenval('H') ? parser.value_linear_units() : 0;
-        if (!WITHIN(h_offset, 0, 10)) {
-          SERIAL_PROTOCOLLNPGM("Offset out of bounds. (0 to 10mm)\n");
-          return;
-        }
-      #endif
-
-      mesh_index_pair location;
-
-      if (!position_is_reachable(rx, ry)) {
-        SERIAL_PROTOCOLLNPGM("(X,Y) outside printable radius.");
-        return;
-      }
-
-      save_ubl_active_state_and_disable();
-
-      LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
-      lcd_external_control = true;                                  // Take over control of the LCD encoder
-
-      do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);      // Move to the given XY with probe clearance
-
-      #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
-        do_blocking_move_to_z(h_offset);                            // Move Z to the given 'H' offset
-      #endif
-
-      uint16_t not_done[16];
-      memset(not_done, 0xFF, sizeof(not_done));
-      do {
-        location = find_closest_mesh_point_of_type(SET_IN_BITMAP, rx, ry, USE_NOZZLE_AS_REFERENCE, not_done);
-
-        if (location.x_index < 0) break;                            // Stop when there are no more reachable points
-
-        bitmap_clear(not_done, location.x_index, location.y_index); // Mark this location as 'adjusted' so a new
-                                                                    // location is used on the next loop
-
-        const float rawx = mesh_index_to_xpos(location.x_index),
-                    rawy = mesh_index_to_ypos(location.y_index);
-
-        if (!position_is_reachable(rawx, rawy)) break;              // SHOULD NOT OCCUR because find_closest_mesh_point_of_type will only return reachable
-
-        do_blocking_move_to(rawx, rawy, Z_CLEARANCE_BETWEEN_PROBES); // Move the nozzle to the edit point with probe clearance
-
-        #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
-          do_blocking_move_to_z(h_offset);                          // Move Z to the given 'H' offset before editing
-        #endif
-
-        KEEPALIVE_STATE(PAUSED_FOR_USER);
-
-        if (do_ubl_mesh_map) display_map(g29_map_type);             // Display the current point
-
-        lcd_refresh();
-
-        float new_z = z_values[location.x_index][location.y_index];
-        if (isnan(new_z)) new_z = 0;                                // Invalid points begin at 0
-        new_z = FLOOR(new_z * 1000) * 0.001f;                       // Chop off digits after the 1000ths place
-
-        lcd_mesh_edit_setup(new_z);
-
-        do {
-          new_z = lcd_mesh_edit();
-          #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
-            do_blocking_move_to_z(h_offset + new_z);                // Move the nozzle as the point is edited
-          #endif
-          idle();
-          SERIAL_FLUSH();                                           // Prevent host M105 buffer overrun.
-        } while (!is_lcd_clicked());
-
-        if (!lcd_map_control) lcd_return_to_status();               // Just editing a single point? Return to status
-
-        if (click_and_hold(abort_fine_tune)) goto FINE_TUNE_EXIT;   // If the click is held down, abort editing
-
-        z_values[location.x_index][location.y_index] = new_z;       // Save the updated Z value
-
-        safe_delay(20);                                             // No switch noise
-        lcd_refresh();
-
-      } while (location.x_index >= 0 && --g29_repetition_cnt > 0);
-
-      FINE_TUNE_EXIT:
-
-      lcd_external_control = false;
-      KEEPALIVE_STATE(IN_HANDLER);
-
-      if (do_ubl_mesh_map) display_map(g29_map_type);
-      restore_ubl_active_state_and_leave();
-
-      do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);
-
-      LCD_MESSAGEPGM(MSG_UBL_DONE_EDITING_MESH);
-      SERIAL_ECHOLNPGM("Done Editing Mesh");
-
-      if (lcd_map_control)
-        lcd_goto_screen(_lcd_ubl_output_map_lcd);
-      else
-        lcd_return_to_status();
-    }
-
-  #endif // HAS_LCD_MENU
-
   /**
    * 'Smart Fill': Scan from the outward edges of the mesh towards the center.
    * If an invalid location is found, use the next two points (if valid) to
    * calculate a 'reasonable' value for the unprobed mesh point.
    */
 
   bool unified_bed_leveling::smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
     const int8_t x1 = x + xdir, x2 = x1 + xdir,
                  y1 = y + ydir, y2 = y1 + ydir;
     // A NAN next to a pair of real values?
@@ -1816,11 +1654,165 @@
             z_values[ix][iy] = ez;
             idle();   // housekeeping
           }
         }
       }
 
       SERIAL_ECHOLNPGM("done");
     }
   #endif // UBL_G29_P31
 
+  #if ENABLED(UBL_DEVEL_DEBUGGING)
+    /**
+     * Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
+     * good to have the extra information. Soon... we prune this to just a few items
+     */
+    void unified_bed_leveling::g29_what_command() {
+      report_state();
+
+      if (storage_slot == -1)
+        SERIAL_PROTOCOLPGM("No Mesh Loaded.");
+      else {
+        SERIAL_PROTOCOLPAIR("Mesh ", storage_slot);
+        SERIAL_PROTOCOLPGM(" Loaded.");
+      }
+      SERIAL_EOL();
+      safe_delay(50);
+
+      #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+        SERIAL_PROTOCOLPGM("planner.z_fade_height : ");
+        SERIAL_PROTOCOL_F(planner.z_fade_height, 4);
+        SERIAL_EOL();
+      #endif
+
+      adjust_mesh_to_mean(g29_c_flag, g29_constant);
+
+      #if HAS_BED_PROBE
+        SERIAL_PROTOCOLPGM("zprobe_zoffset: ");
+        SERIAL_PROTOCOL_F(zprobe_zoffset, 7);
+        SERIAL_EOL();
+      #endif
+
+      SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X); safe_delay(50);
+      SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y); safe_delay(50);
+      SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X); safe_delay(50);
+      SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y); safe_delay(50);
+      SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);             safe_delay(50);
+      SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);             safe_delay(50);
+      SERIAL_ECHOLNPAIR("MESH_X_DIST  ", MESH_X_DIST);
+      SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);                         safe_delay(50);
+
+      SERIAL_PROTOCOLPGM("X-Axis Mesh Points at: ");
+      for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
+        SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(mesh_index_to_xpos(i)), 3);
+        SERIAL_PROTOCOLPGM("  ");
+        safe_delay(25);
+      }
+      SERIAL_EOL();
+
+      SERIAL_PROTOCOLPGM("Y-Axis Mesh Points at: ");
+      for (uint8_t i = 0; i < GRID_MAX_POINTS_Y; i++) {
+        SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(mesh_index_to_ypos(i)), 3);
+        SERIAL_PROTOCOLPGM("  ");
+        safe_delay(25);
+      }
+      SERIAL_EOL();
+
+      #if HAS_KILL
+        SERIAL_PROTOCOLPAIR("Kill pin on :", KILL_PIN);
+        SERIAL_PROTOCOLLNPAIR("  state:", READ(KILL_PIN));
+      #endif
+      SERIAL_EOL();
+      safe_delay(50);
+
+      #if ENABLED(UBL_DEVEL_DEBUGGING)
+        SERIAL_PROTOCOLLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation); SERIAL_EOL();
+        SERIAL_PROTOCOLLNPAIR("ubl_state_recursion_chk :", ubl_state_recursion_chk); SERIAL_EOL();
+        safe_delay(50);
+
+        SERIAL_PROTOCOLPAIR("Meshes go from ", hex_address((void*)settings.meshes_start_index()));
+        SERIAL_PROTOCOLLNPAIR(" to ", hex_address((void*)settings.meshes_end_index()));
+        safe_delay(50);
+
+        SERIAL_PROTOCOLLNPAIR("sizeof(ubl) :  ", (int)sizeof(ubl));         SERIAL_EOL();
+        SERIAL_PROTOCOLLNPAIR("z_value[][] size: ", (int)sizeof(z_values)); SERIAL_EOL();
+        safe_delay(25);
+
+        SERIAL_PROTOCOLLNPAIR("EEPROM free for UBL: ", hex_address((void*)(settings.meshes_end_index() - settings.meshes_start_index())));
+        safe_delay(50);
+
+        SERIAL_PROTOCOLPAIR("EEPROM can hold ", settings.calc_num_meshes());
+        SERIAL_PROTOCOLLNPGM(" meshes.\n");
+        safe_delay(25);
+      #endif // UBL_DEVEL_DEBUGGING
+
+      if (!sanity_check()) {
+        echo_name();
+        SERIAL_PROTOCOLLNPGM(" sanity checks passed.");
+      }
+    }
+
+    /**
+     * When we are fully debugged, the EEPROM dump command will get deleted also. But
+     * right now, it is good to have the extra information. Soon... we prune this.
+     */
+    void unified_bed_leveling::g29_eeprom_dump() {
+      uint8_t cccc;
+
+      SERIAL_ECHO_START();
+      SERIAL_ECHOLNPGM("EEPROM Dump:");
+      persistentStore.access_start();
+      for (uint16_t i = 0; i < persistentStore.capacity(); i += 16) {
+        if (!(i & 0x3)) idle();
+        print_hex_word(i);
+        SERIAL_ECHOPGM(": ");
+        for (uint16_t j = 0; j < 16; j++) {
+          persistentStore.read_data(i + j, &cccc, sizeof(uint8_t));
+          print_hex_byte(cccc);
+          SERIAL_ECHO(' ');
+        }
+        SERIAL_EOL();
+      }
+      SERIAL_EOL();
+      persistentStore.access_finish();
+    }
+
+    /**
+     * When we are fully debugged, this may go away. But there are some valid
+     * use cases for the users. So we can wait and see what to do with it.
+     */
+    void unified_bed_leveling::g29_compare_current_mesh_to_stored_mesh() {
+      int16_t a = settings.calc_num_meshes();
+
+      if (!a) {
+        SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
+        return;
+      }
+
+      if (!parser.has_value()) {
+        SERIAL_PROTOCOLLNPGM("?Storage slot # required.");
+        SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
+        return;
+      }
+
+      g29_storage_slot = parser.value_int();
+
+      if (!WITHIN(g29_storage_slot, 0, a - 1)) {
+        SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
+        SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
+        return;
+      }
+
+      float tmp_z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
+      settings.load_mesh(g29_storage_slot, &tmp_z_values);
+
+      SERIAL_PROTOCOLPAIR("Subtracting mesh in slot ", g29_storage_slot);
+      SERIAL_PROTOCOLLNPGM(" from current mesh.");
+
+      for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
+        for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
+          z_values[x][y] -= tmp_z_values[x][y];
+    }
+
+  #endif // UBL_DEVEL_DEBUGGING
+
 #endif // AUTO_BED_LEVELING_UBL

commit 6093df11dc91273764d0bf5607fa4314391793a2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 10 18:07:38 2018 -0600

    Allow G26 to use the active extruder (#12387)
    
    * Make lcd_quick_feedback argument optional
    * Add click_to_cancel option to wait_for_hotend/bed
    * Have G26 use the active nozzle and wait_for_hotend/bed
    * Use wait_for_release in UBL G29
    * Add 'T' parameter to G26 for an initial tool-change

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index a261581e5d..71c0097f78 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -623,21 +623,21 @@
       SERIAL_PROTOCOLLNPGM("Done.");
     }
 
     if (parser.seen('T'))
       display_map(g29_map_type);
 
     LEAVE:
 
     #if HAS_LCD_MENU
       lcd_reset_alert_level();
-      lcd_quick_feedback(true);
+      lcd_quick_feedback();
       lcd_reset_status();
       lcd_external_control = false;
     #endif
 
     return;
   }
 
   void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float value) {
     float sum = 0;
     int n = 0;
@@ -682,30 +682,28 @@
         if (!isnan(z_values[x][y]))
           z_values[x][y] += g29_constant;
   }
 
   #if HAS_LCD_MENU
 
     typedef void (*clickFunc_t)();
 
     bool click_and_hold(const clickFunc_t func=NULL) {
       if (is_lcd_clicked()) {
-        lcd_quick_feedback(false); // Do NOT clear button status!  If cleared, the code
-                                   // code can not look for a 'click and hold'
+        lcd_quick_feedback(false);                // Preserve button state for click-and-hold
         const millis_t nxt = millis() + 1500UL;
         while (is_lcd_clicked()) {                // Loop while the encoder is pressed. Uses hardware flag!
           idle();                                 // idle, of course
           if (ELAPSED(millis(), nxt)) {           // After 1.5 seconds
-            lcd_quick_feedback(true);
+            lcd_quick_feedback();
             if (func) (*func)();
             wait_for_release();
-            safe_delay(50);                       // Debounce the Encoder wheel
             return true;
           }
         }
       }
       safe_delay(15);
       return false;
     }
 
   #endif // HAS_LCD_MENU
 
@@ -714,38 +712,37 @@
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
     void unified_bed_leveling::probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
       mesh_index_pair location;
 
       #if HAS_LCD_MENU
         lcd_external_control = true;
       #endif
 
-      save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
+      save_ubl_active_state_and_disable();   // No bed level correction so only raw data is obtained
       DEPLOY_PROBE();
 
       uint16_t count = GRID_MAX_POINTS;
 
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
         #if HAS_LCD_MENU
           if (is_lcd_clicked()) {
+            lcd_quick_feedback(false); // Preserve button state for click-and-hold
             SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.\n");
-            lcd_quick_feedback(false);
             STOW_PROBE();
-            while (is_lcd_clicked()) idle();
+            wait_for_release();
+            lcd_quick_feedback();
             lcd_external_control = false;
             restore_ubl_active_state_and_leave();
-            lcd_quick_feedback(true);
-            safe_delay(50);  // Debounce the Encoder wheel
             return;
           }
         #endif
 
         if (do_furthest)
           location = find_furthest_invalid_mesh_point();
         else
           location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, NULL);
 
         if (location.x_index >= 0) {    // mesh point found and is reachable by probe
@@ -836,21 +833,21 @@
       restore_ubl_active_state_and_leave();
 
       return thickness;
     }
 
     void abort_manual_probe_remaining_mesh() {
       SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.");
       do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
       lcd_external_control = false;
       KEEPALIVE_STATE(IN_HANDLER);
-      lcd_quick_feedback(true);
+      lcd_quick_feedback();
       ubl.restore_ubl_active_state_and_leave();
     }
 
     void unified_bed_leveling::manually_probe_remaining_mesh(const float &rx, const float &ry, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
 
       lcd_external_control = true;
 
       save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
       do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z_clearance);
 
@@ -903,26 +900,30 @@
       } while (location.x_index >= 0 && location.y_index >= 0);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
       restore_ubl_active_state_and_leave();
       KEEPALIVE_STATE(IN_HANDLER);
       do_blocking_move_to(rx, ry, Z_CLEARANCE_DEPLOY_PROBE);
     }
   #endif // HAS_LCD_MENU
 
+  inline void set_message_with_feedback(PGM_P const msg_P) {
+    lcd_setstatusPGM(msg_P);
+    lcd_quick_feedback();
+  }
+
   bool unified_bed_leveling::g29_parameter_parsing() {
     bool err_flag = false;
 
     #if HAS_LCD_MENU
-      LCD_MESSAGEPGM(MSG_UBL_DOING_G29);
-      lcd_quick_feedback(true);
+      set_message_with_feedback(PSTR(MSG_UBL_DOING_G29));
     #endif
 
     g29_constant = 0;
     g29_repetition_cnt = 0;
 
     g29_x_flag = parser.seenval('X');
     g29_x_pos = g29_x_flag ? parser.value_float() : current_position[X_AXIS];
     g29_y_flag = parser.seenval('Y');
     g29_y_pos = g29_y_flag ? parser.value_float() : current_position[Y_AXIS];
 
@@ -1030,37 +1031,35 @@
   #if ENABLED(UBL_DEVEL_DEBUGGING)
     static uint8_t ubl_state_recursion_chk = 0;
   #endif
 
   void unified_bed_leveling::save_ubl_active_state_and_disable() {
     #if ENABLED(UBL_DEVEL_DEBUGGING)
       ubl_state_recursion_chk++;
       if (ubl_state_recursion_chk != 1) {
         SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
         #if HAS_LCD_MENU
-          LCD_MESSAGEPGM(MSG_UBL_SAVE_ERROR);
-          lcd_quick_feedback(true);
+          set_message_with_feedback(PSTR(MSG_UBL_SAVE_ERROR));
         #endif
         return;
       }
     #endif
     ubl_state_at_invocation = planner.leveling_active;
     set_bed_leveling_enabled(false);
   }
 
   void unified_bed_leveling::restore_ubl_active_state_and_leave() {
     #if ENABLED(UBL_DEVEL_DEBUGGING)
       if (--ubl_state_recursion_chk) {
         SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
         #if HAS_LCD_MENU
-          LCD_MESSAGEPGM(MSG_UBL_RESTORE_ERROR);
-          lcd_quick_feedback(true);
+          set_message_with_feedback(PSTR(MSG_UBL_RESTORE_ERROR));
         #endif
         return;
       }
     #endif
     set_bed_leveling_enabled(ubl_state_at_invocation);
   }
 
   /**
    * Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
    * good to have the extra information. Soon... we prune this to just a few items
@@ -1337,22 +1336,21 @@
     } // for i
 
     return out_mesh;
   }
 
   #if HAS_LCD_MENU
 
     void abort_fine_tune() {
       lcd_return_to_status();
       do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
-      LCD_MESSAGEPGM(MSG_EDITING_STOPPED);
-      lcd_quick_feedback(true);
+      set_message_with_feedback(PSTR(MSG_EDITING_STOPPED));
     }
 
     void unified_bed_leveling::fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map) {
       if (!parser.seen('R'))    // fine_tune_mesh() is special. If no repetition count flag is specified
         g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 
       #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
         const float h_offset = parser.seenval('H') ? parser.value_linear_units() : 0;
         if (!WITHIN(h_offset, 0, 10)) {
           SERIAL_PROTOCOLLNPGM("Offset out of bounds. (0 to 10mm)\n");

commit cc2bc67440bdd17851cd76fcda301c9bffb788cf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 3 02:07:53 2018 -0500

    ENABLED(NEWPANEL) => HAS_LCD_MENU

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 5a8087bf3e..a261581e5d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -45,21 +45,21 @@
   #if ENABLED(DUAL_X_CARRIAGE)
     #include "../../../module/tool_change.h"
   #endif
 
   #include <math.h>
 
   #define UBL_G29_P31
 
   extern float destination[XYZE], current_position[XYZE];
 
-  #if ENABLED(NEWPANEL)
+  #if HAS_LCD_MENU
     void lcd_return_to_status();
     void _lcd_ubl_output_map_lcd();
   #endif
 
   #define SIZE_OF_LITTLE_RAISE 1
   #define BIG_RAISE_NOT_NEEDED 0
 
   int    unified_bed_leveling::g29_verbose_level,
          unified_bed_leveling::g29_phase_value,
          unified_bed_leveling::g29_repetition_cnt,
@@ -425,21 +425,21 @@
             }
             probe_entire_mesh(g29_x_pos + X_PROBE_OFFSET_FROM_EXTRUDER, g29_y_pos + Y_PROBE_OFFSET_FROM_EXTRUDER,
                               parser.seen('T'), parser.seen('E'), parser.seen('U'));
 
             report_current_position();
             break;
 
         #endif // HAS_BED_PROBE
 
         case 2: {
-          #if ENABLED(NEWPANEL)
+          #if HAS_LCD_MENU
             //
             // Manually Probe Mesh in areas that can't be reached by the probe
             //
             SERIAL_PROTOCOLLNPGM("Manually probing unreachable mesh locations.");
             do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
 
             if (parser.seen('C') && !g29_x_flag && !g29_y_flag) {
               /**
                * Use a good default location for the path.
                * The flipped > and < operators in these comparisons is intentional.
@@ -533,21 +533,21 @@
               case 0:   // P3 or P3.0
               default:  // and anything P3.x that's not P3.1
                 smart_fill_mesh();  // Do a 'Smart' fill using nearby known values
                 break;
             }
           }
           break;
         }
 
         case 4: // Fine Tune (i.e., Edit) the Mesh
-          #if ENABLED(NEWPANEL)
+          #if HAS_LCD_MENU
             fine_tune_mesh(g29_x_pos, g29_y_pos, parser.seen('T'));
           #else
             SERIAL_PROTOCOLLNPGM("?P4 is only available when an LCD is present.");
             return;
           #endif
           break;
 
         case 5: adjust_mesh_to_mean(g29_c_flag, g29_constant); break;
 
         case 6: shift_mesh_height(); break;
@@ -676,21 +676,21 @@
             z_values[x][y] -= mean + value;
   }
 
   void unified_bed_leveling::shift_mesh_height() {
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
         if (!isnan(z_values[x][y]))
           z_values[x][y] += g29_constant;
   }
 
-  #if ENABLED(NEWPANEL)
+  #if HAS_LCD_MENU
 
     typedef void (*clickFunc_t)();
 
     bool click_and_hold(const clickFunc_t func=NULL) {
       if (is_lcd_clicked()) {
         lcd_quick_feedback(false); // Do NOT clear button status!  If cleared, the code
                                    // code can not look for a 'click and hold'
         const millis_t nxt = millis() + 1500UL;
         while (is_lcd_clicked()) {                // Loop while the encoder is pressed. Uses hardware flag!
           idle();                                 // idle, of course
@@ -700,43 +700,43 @@
             wait_for_release();
             safe_delay(50);                       // Debounce the Encoder wheel
             return true;
           }
         }
       }
       safe_delay(15);
       return false;
     }
 
-  #endif // NEWPANEL
+  #endif // HAS_LCD_MENU
 
   #if HAS_BED_PROBE
     /**
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
     void unified_bed_leveling::probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
       mesh_index_pair location;
 
-      #if ENABLED(NEWPANEL)
+      #if HAS_LCD_MENU
         lcd_external_control = true;
       #endif
 
       save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
       DEPLOY_PROBE();
 
       uint16_t count = GRID_MAX_POINTS;
 
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
-        #if ENABLED(NEWPANEL)
+        #if HAS_LCD_MENU
           if (is_lcd_clicked()) {
             SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.\n");
             lcd_quick_feedback(false);
             STOW_PROBE();
             while (is_lcd_clicked()) idle();
             lcd_external_control = false;
             restore_ubl_active_state_and_leave();
             lcd_quick_feedback(true);
             safe_delay(50);  // Debounce the Encoder wheel
             return;
@@ -768,21 +768,21 @@
 
       do_blocking_move_to_xy(
         constrain(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_X, MESH_MAX_X),
         constrain(ry - (Y_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 
 
   #endif // HAS_BED_PROBE
 
-  #if ENABLED(NEWPANEL)
+  #if HAS_LCD_MENU
 
     void unified_bed_leveling::move_z_with_encoder(const float &multiplier) {
       wait_for_release();
       while (!is_lcd_clicked()) {
         idle();
         gcode.reset_stepper_timeout(); // Keep steppers powered
         if (encoder_diff) {
           do_blocking_move_to_z(current_position[Z_AXIS] + float(encoder_diff) * multiplier);
           encoder_diff = 0;
         }
@@ -901,26 +901,26 @@
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.x_index >= 0 && location.y_index >= 0);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
       restore_ubl_active_state_and_leave();
       KEEPALIVE_STATE(IN_HANDLER);
       do_blocking_move_to(rx, ry, Z_CLEARANCE_DEPLOY_PROBE);
     }
-  #endif // NEWPANEL
+  #endif // HAS_LCD_MENU
 
   bool unified_bed_leveling::g29_parameter_parsing() {
     bool err_flag = false;
 
-    #if ENABLED(NEWPANEL)
+    #if HAS_LCD_MENU
       LCD_MESSAGEPGM(MSG_UBL_DOING_G29);
       lcd_quick_feedback(true);
     #endif
 
     g29_constant = 0;
     g29_repetition_cnt = 0;
 
     g29_x_flag = parser.seenval('X');
     g29_x_pos = g29_x_flag ? parser.value_float() : current_position[X_AXIS];
     g29_y_flag = parser.seenval('Y');
@@ -1029,36 +1029,36 @@
 
   #if ENABLED(UBL_DEVEL_DEBUGGING)
     static uint8_t ubl_state_recursion_chk = 0;
   #endif
 
   void unified_bed_leveling::save_ubl_active_state_and_disable() {
     #if ENABLED(UBL_DEVEL_DEBUGGING)
       ubl_state_recursion_chk++;
       if (ubl_state_recursion_chk != 1) {
         SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
-        #if ENABLED(NEWPANEL)
+        #if HAS_LCD_MENU
           LCD_MESSAGEPGM(MSG_UBL_SAVE_ERROR);
           lcd_quick_feedback(true);
         #endif
         return;
       }
     #endif
     ubl_state_at_invocation = planner.leveling_active;
     set_bed_leveling_enabled(false);
   }
 
   void unified_bed_leveling::restore_ubl_active_state_and_leave() {
     #if ENABLED(UBL_DEVEL_DEBUGGING)
       if (--ubl_state_recursion_chk) {
         SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
-        #if ENABLED(NEWPANEL)
+        #if HAS_LCD_MENU
           LCD_MESSAGEPGM(MSG_UBL_RESTORE_ERROR);
           lcd_quick_feedback(true);
         #endif
         return;
       }
     #endif
     set_bed_leveling_enabled(ubl_state_at_invocation);
   }
 
   /**
@@ -1332,21 +1332,21 @@
             out_mesh.y_index = j;
             out_mesh.distance = best_so_far;
           }
         }
       } // for j
     } // for i
 
     return out_mesh;
   }
 
-  #if ENABLED(NEWPANEL)
+  #if HAS_LCD_MENU
 
     void abort_fine_tune() {
       lcd_return_to_status();
       do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
       LCD_MESSAGEPGM(MSG_EDITING_STOPPED);
       lcd_quick_feedback(true);
     }
 
     void unified_bed_leveling::fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map) {
       if (!parser.seen('R'))    // fine_tune_mesh() is special. If no repetition count flag is specified
@@ -1443,21 +1443,21 @@
 
       LCD_MESSAGEPGM(MSG_UBL_DONE_EDITING_MESH);
       SERIAL_ECHOLNPGM("Done Editing Mesh");
 
       if (lcd_map_control)
         lcd_goto_screen(_lcd_ubl_output_map_lcd);
       else
         lcd_return_to_status();
     }
 
-  #endif // NEWPANEL
+  #endif // HAS_LCD_MENU
 
   /**
    * 'Smart Fill': Scan from the outward edges of the mesh towards the center.
    * If an invalid location is found, use the next two points (if valid) to
    * calculate a 'reasonable' value for the unprobed mesh point.
    */
 
   bool unified_bed_leveling::smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
     const int8_t x1 = x + xdir, x2 = x1 + xdir,
                  y1 = y + ydir, y2 = y1 + ydir;

commit 3583e2b4490e8fd6778d18003641c2fdd333e8a5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 30 16:34:45 2018 -0500

    Followup to Menu Refactor (#12275)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 438c41b6a2..5a8087bf3e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -621,21 +621,21 @@
       storage_slot = g29_storage_slot;
 
       SERIAL_PROTOCOLLNPGM("Done.");
     }
 
     if (parser.seen('T'))
       display_map(g29_map_type);
 
     LEAVE:
 
-    #if ENABLED(ULTIPANEL)
+    #if HAS_LCD_MENU
       lcd_reset_alert_level();
       lcd_quick_feedback(true);
       lcd_reset_status();
       lcd_external_control = false;
     #endif
 
     return;
   }
 
   void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float value) {

commit 2bf18950ab2070e842c91057d5812dcaa1bff9a2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 23 16:00:34 2018 -0500

    Refactor LCD menus

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 99b91bf5a7..438c41b6a2 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -621,21 +621,21 @@
       storage_slot = g29_storage_slot;
 
       SERIAL_PROTOCOLLNPGM("Done.");
     }
 
     if (parser.seen('T'))
       display_map(g29_map_type);
 
     LEAVE:
 
-    #if ENABLED(NEWPANEL)
+    #if ENABLED(ULTIPANEL)
       lcd_reset_alert_level();
       lcd_quick_feedback(true);
       lcd_reset_status();
       lcd_external_control = false;
     #endif
 
     return;
   }
 
   void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float value) {

commit d556dc18650e2185791834d7fe70b4acf45254bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 10 09:45:20 2018 -0500

    Fix and improve EEPROM storage (#12054)
    
    * Clean up Temperature PID
    * Improve EEPROM read/write/validate
    * Group `SINGLENOZZLE` saved settings
    * Group planner saved settings
    * Group filament change saved settings
    * Group skew saved settings
    * Group `FWRETRACT` saved settings

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 73046fda31..99b91bf5a7 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -796,21 +796,21 @@
       return current_position[Z_AXIS];
     }
 
     static void echo_and_take_a_measurement() { SERIAL_PROTOCOLLNPGM(" and take a measurement."); }
 
     float unified_bed_leveling::measure_business_card_thickness(float in_height) {
       lcd_external_control = true;
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
       do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
-        //, MIN(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]) * 0.5f);
+        //, MIN(planner.settings.max_feedrate_mm_s[X_AXIS], planner.settings.max_feedrate_mm_s[Y_AXIS]) * 0.5f);
       planner.synchronize();
 
       SERIAL_PROTOCOLPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       lcd_return_to_status();
       echo_and_take_a_measurement();
 
       const float z1 = measure_point_with_encoder();
       do_blocking_move_to_z(current_position[Z_AXIS] + SIZE_OF_LITTLE_RAISE);
       planner.synchronize();

commit 07d33849b0ba5fa19700140c5741041e40c9b6c2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 9 21:31:20 2018 -0500

    Fix unused var warning, apply ENABLED

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 671ed79947..73046fda31 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1020,42 +1020,42 @@
     g29_map_type = parser.intval('T');
     if (!WITHIN(g29_map_type, 0, 2)) {
       SERIAL_PROTOCOLLNPGM("Invalid map type.\n");
       return UBL_ERR;
     }
     return UBL_OK;
   }
 
   static uint8_t ubl_state_at_invocation = 0;
 
-  #ifdef UBL_DEVEL_DEBUGGING
+  #if ENABLED(UBL_DEVEL_DEBUGGING)
     static uint8_t ubl_state_recursion_chk = 0;
   #endif
 
   void unified_bed_leveling::save_ubl_active_state_and_disable() {
-    #ifdef UBL_DEVEL_DEBUGGING
+    #if ENABLED(UBL_DEVEL_DEBUGGING)
       ubl_state_recursion_chk++;
       if (ubl_state_recursion_chk != 1) {
         SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
         #if ENABLED(NEWPANEL)
           LCD_MESSAGEPGM(MSG_UBL_SAVE_ERROR);
           lcd_quick_feedback(true);
         #endif
         return;
       }
     #endif
     ubl_state_at_invocation = planner.leveling_active;
     set_bed_leveling_enabled(false);
   }
 
   void unified_bed_leveling::restore_ubl_active_state_and_leave() {
-    #ifdef UBL_DEVEL_DEBUGGING
+    #if ENABLED(UBL_DEVEL_DEBUGGING)
       if (--ubl_state_recursion_chk) {
         SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
         #if ENABLED(NEWPANEL)
           LCD_MESSAGEPGM(MSG_UBL_RESTORE_ERROR);
           lcd_quick_feedback(true);
         #endif
         return;
       }
     #endif
     set_bed_leveling_enabled(ubl_state_at_invocation);
@@ -1125,21 +1125,21 @@
     }
     SERIAL_EOL();
 
     #if HAS_KILL
       SERIAL_PROTOCOLPAIR("Kill pin on :", KILL_PIN);
       SERIAL_PROTOCOLLNPAIR("  state:", READ(KILL_PIN));
     #endif
     SERIAL_EOL();
     safe_delay(50);
 
-    #ifdef UBL_DEVEL_DEBUGGING
+    #if ENABLED(UBL_DEVEL_DEBUGGING)
       SERIAL_PROTOCOLLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation);
       SERIAL_EOL();
       SERIAL_PROTOCOLLNPAIR("ubl_state_recursion_chk :", ubl_state_recursion_chk);
       SERIAL_EOL();
       safe_delay(50);
 
       SERIAL_PROTOCOLPAIR("Meshes go from ", hex_address((void*)settings.meshes_start_index()));
       SERIAL_PROTOCOLLNPAIR(" to ", hex_address((void*)settings.meshes_end_index()));
       safe_delay(50);
 

commit c2553f9888e1fa7e23f0e3da26e289eb2d51e473
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Aug 15 14:26:11 2018 -0400

    2.0.x - Idex match119 (#11556)
    
    * Update ubl_G29.cpp
    
    * Update ultralcd.cpp

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 422513840b..671ed79947 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -297,24 +297,24 @@
 
   void unified_bed_leveling::G29() {
 
     if (g29_parameter_parsing()) return; // Abort on parameter error
 
     const int8_t p_val = parser.intval('P', -1);
     const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J');
 
     // Check for commands that require the printer to be homed
     if (may_move) {
+      if (axis_unhomed_error()) gcode.home_all_axes();
       #if ENABLED(DUAL_X_CARRIAGE)
         if (active_extruder != 0) tool_change(0);
       #endif
-      if (axis_unhomed_error()) gcode.home_all_axes();
     }
 
     // Invalidate Mesh Points. This command is a little bit asymmetrical because
     // it directly specifies the repetition count and does not use the 'R' parameter.
     if (parser.seen('I')) {
       uint8_t cnt = 0;
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : 1;
       if (g29_repetition_cnt >= GRID_MAX_POINTS) {
         set_all_mesh_points_to_value(NAN);
       }

commit b37bfeffebc0013c621a09e4b8bb3ea811517a12
Author: Nils Hasenbanck <hasenbanck@users.noreply.github.com>
Date:   Wed Aug 15 01:35:36 2018 +0200

    [2.0.x] Use the new const functions of the persistentStore api  (#11544)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 73a0cfdeb3..422513840b 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1162,33 +1162,30 @@
       SERIAL_PROTOCOLLNPGM(" sanity checks passed.");
     }
   }
 
   /**
    * When we are fully debugged, the EEPROM dump command will get deleted also. But
    * right now, it is good to have the extra information. Soon... we prune this.
    */
   void unified_bed_leveling::g29_eeprom_dump() {
     uint8_t cccc;
-    int kkkk;
-    uint16_t crc = 0;
 
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPGM("EEPROM Dump:");
     persistentStore.access_start();
     for (uint16_t i = 0; i < persistentStore.capacity(); i += 16) {
       if (!(i & 0x3)) idle();
       print_hex_word(i);
       SERIAL_ECHOPGM(": ");
       for (uint16_t j = 0; j < 16; j++) {
-        kkkk = i + j;
-        persistentStore.read_data(kkkk, &cccc, sizeof(uint8_t), &crc);
+        persistentStore.read_data(i + j, &cccc, sizeof(uint8_t));
         print_hex_byte(cccc);
         SERIAL_ECHO(' ');
       }
       SERIAL_EOL();
     }
     SERIAL_EOL();
     persistentStore.access_finish();
   }
 
   /**

commit c64199941e058abb18a06be90002f5f03009347b
Author: Dave Johnson <davejohnson3000@gmail.com>
Date:   Tue Aug 14 01:28:52 2018 -0700

    Compile only selected PIO environment (#11519)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index e1771c91f7..73a0cfdeb3 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -22,21 +22,21 @@
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
   //#define UBL_DEVEL_DEBUGGING
 
   #include "ubl.h"
 
   #include "../../../Marlin.h"
-  #include "../../../HAL/persistent_store_api.h"
+  #include "../../../HAL/shared/persistent_store_api.h"
   #include "../../../libs/hex_print_routines.h"
   #include "../../../module/configuration_store.h"
   #include "../../../lcd/ultralcd.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
   #include "../../../module/probe.h"
   #include "../../../gcode/gcode.h"
   #include "../../../core/serial.h"
   #include "../../../gcode/parser.h"
   #include "../../../feature/bedlevel/bedlevel.h"

commit 577aeb4aa91c2f9ebc9b7e44cde23da647893a32
Author: Nils Hasenbanck <nils@hasenbanck.de>
Date:   Sun Aug 12 09:50:39 2018 +0200

    All EEPROM access uses persistentStore

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index b2de3c96bb..e1771c91f7 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -22,20 +22,21 @@
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
   //#define UBL_DEVEL_DEBUGGING
 
   #include "ubl.h"
 
   #include "../../../Marlin.h"
+  #include "../../../HAL/persistent_store_api.h"
   #include "../../../libs/hex_print_routines.h"
   #include "../../../module/configuration_store.h"
   #include "../../../lcd/ultralcd.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
   #include "../../../module/probe.h"
   #include "../../../gcode/gcode.h"
   #include "../../../core/serial.h"
   #include "../../../gcode/parser.h"
   #include "../../../feature/bedlevel/bedlevel.h"
@@ -1160,38 +1161,41 @@
       echo_name();
       SERIAL_PROTOCOLLNPGM(" sanity checks passed.");
     }
   }
 
   /**
    * When we are fully debugged, the EEPROM dump command will get deleted also. But
    * right now, it is good to have the extra information. Soon... we prune this.
    */
   void unified_bed_leveling::g29_eeprom_dump() {
-    unsigned char cccc;
-    unsigned int  kkkk;  // Needs to be of unspecfied size to compile clean on all platforms
+    uint8_t cccc;
+    int kkkk;
+    uint16_t crc = 0;
 
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPGM("EEPROM Dump:");
+    persistentStore.access_start();
     for (uint16_t i = 0; i < persistentStore.capacity(); i += 16) {
       if (!(i & 0x3)) idle();
       print_hex_word(i);
       SERIAL_ECHOPGM(": ");
       for (uint16_t j = 0; j < 16; j++) {
         kkkk = i + j;
-        eeprom_read_block(&cccc, (const void *)kkkk, sizeof(unsigned char));
+        persistentStore.read_data(kkkk, &cccc, sizeof(uint8_t), &crc);
         print_hex_byte(cccc);
         SERIAL_ECHO(' ');
       }
       SERIAL_EOL();
     }
     SERIAL_EOL();
+    persistentStore.access_finish();
   }
 
   /**
    * When we are fully debugged, this may go away. But there are some valid
    * use cases for the users. So we can wait and see what to do with it.
    */
   void unified_bed_leveling::g29_compare_current_mesh_to_stored_mesh() {
     int16_t a = settings.calc_num_meshes();
 
     if (!a) {

commit 66d2b48b5995a4225029f7fed84a2dfe0ee9300a
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Mon Aug 13 23:30:26 2018 +0100

    Update PersistentStore api (#11538)
    
    - Clean up the API to use a `static` class instance to adhere to Marlin convention
    - Add `const` position data access for read/write
    - Add Storage capacity to the interface

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 654b4c193c..b2de3c96bb 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1165,21 +1165,21 @@
   /**
    * When we are fully debugged, the EEPROM dump command will get deleted also. But
    * right now, it is good to have the extra information. Soon... we prune this.
    */
   void unified_bed_leveling::g29_eeprom_dump() {
     unsigned char cccc;
     unsigned int  kkkk;  // Needs to be of unspecfied size to compile clean on all platforms
 
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPGM("EEPROM Dump:");
-    for (uint16_t i = 0; i <= E2END; i += 16) {
+    for (uint16_t i = 0; i < persistentStore.capacity(); i += 16) {
       if (!(i & 0x3)) idle();
       print_hex_word(i);
       SERIAL_ECHOPGM(": ");
       for (uint16_t j = 0; j < 16; j++) {
         kkkk = i + j;
         eeprom_read_block(&cccc, (const void *)kkkk, sizeof(unsigned char));
         print_hex_byte(cccc);
         SERIAL_ECHO(' ');
       }
       SERIAL_EOL();

commit e05e95cf9721262d241fe313e9a4f15a779c18d9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 25 18:49:32 2018 -0500

    Clean trailing whitespace

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 726928742d..654b4c193c 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1559,26 +1559,26 @@
             abort_flag = true;
           else {
             measured_z -= get_z_correction(PROBE_PT_3_X, PROBE_PT_3_Y);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, PROBE_PT_3_X, PROBE_PT_3_Y, measured_z);
           }
         }
-        
+
         STOW_PROBE();
         #ifdef Z_AFTER_PROBING
           move_z_after_probing();
         #endif
-        
+
         if (abort_flag) {
           SERIAL_ECHOPGM("?Error probing point.  Aborting operation.\n");
           return;
         }
       }
       else { // !do_3_pt_leveling
 
         bool zig_zag = false;
         for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
           const float rx = float(x_min) + ix * dx;
@@ -1625,21 +1625,21 @@
             }
           }
 
           zig_zag ^= true;
         }
       }
       STOW_PROBE();
       #ifdef Z_AFTER_PROBING
         move_z_after_probing();
       #endif
-      
+
       if (abort_flag || finish_incremental_LSF(&lsf_results)) {
         SERIAL_ECHOPGM("Could not complete LSF!");
         return;
       }
 
       vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1).get_normal();
 
       if (g29_verbose_level > 2) {
         SERIAL_ECHOPGM("bed plane normal = [");
         SERIAL_PROTOCOL_F(normal.x, 7);

commit 62fa028155a66b110a2030ef40995ad868254404
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Tue Jul 24 15:34:53 2018 -0500

    Handle dual gantry machines better

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 626f78b0ed..726928742d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -296,24 +296,24 @@
 
   void unified_bed_leveling::G29() {
 
     if (g29_parameter_parsing()) return; // Abort on parameter error
 
     const int8_t p_val = parser.intval('P', -1);
     const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J');
 
     // Check for commands that require the printer to be homed
     if (may_move) {
-      if (axis_unhomed_error()) gcode.home_all_axes();
       #if ENABLED(DUAL_X_CARRIAGE)
         if (active_extruder != 0) tool_change(0);
       #endif
+      if (axis_unhomed_error()) gcode.home_all_axes();
     }
 
     // Invalidate Mesh Points. This command is a little bit asymmetrical because
     // it directly specifies the repetition count and does not use the 'R' parameter.
     if (parser.seen('I')) {
       uint8_t cnt = 0;
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : 1;
       if (g29_repetition_cnt >= GRID_MAX_POINTS) {
         set_all_mesh_points_to_value(NAN);
       }

commit 17ed0f815cbdbc38d62b3f5228e4ba435ce99555
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 18 20:29:34 2018 -0500

    Fix tool_change call in UBL G29
    
    Fix #11279, #11252

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index a0e1a810bc..626f78b0ed 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -34,20 +34,24 @@
   #include "../../../lcd/ultralcd.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
   #include "../../../module/probe.h"
   #include "../../../gcode/gcode.h"
   #include "../../../core/serial.h"
   #include "../../../gcode/parser.h"
   #include "../../../feature/bedlevel/bedlevel.h"
   #include "../../../libs/least_squares_fit.h"
 
+  #if ENABLED(DUAL_X_CARRIAGE)
+    #include "../../../module/tool_change.h"
+  #endif
+
   #include <math.h>
 
   #define UBL_G29_P31
 
   extern float destination[XYZE], current_position[XYZE];
 
   #if ENABLED(NEWPANEL)
     void lcd_return_to_status();
     void _lcd_ubl_output_map_lcd();
   #endif

commit 63f4c9bdb923d8ec4d11f9b261ebed88d192274a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 6 20:41:08 2018 -0500

    Followup to float maths patch

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 956238ba50..a0e1a810bc 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -58,22 +58,22 @@
   int    unified_bed_leveling::g29_verbose_level,
          unified_bed_leveling::g29_phase_value,
          unified_bed_leveling::g29_repetition_cnt,
          unified_bed_leveling::g29_storage_slot = 0,
          unified_bed_leveling::g29_map_type;
   bool   unified_bed_leveling::g29_c_flag,
          unified_bed_leveling::g29_x_flag,
          unified_bed_leveling::g29_y_flag;
   float  unified_bed_leveling::g29_x_pos,
          unified_bed_leveling::g29_y_pos,
-         unified_bed_leveling::g29_card_thickness = 0.0,
-         unified_bed_leveling::g29_constant = 0.0;
+         unified_bed_leveling::g29_card_thickness = 0,
+         unified_bed_leveling::g29_constant = 0;
 
   #if HAS_BED_PROBE
     int  unified_bed_leveling::g29_grid_size;
   #endif
 
   /**
    *   G29: Unified Bed Leveling by Roxy
    *
    *   Parameters understood by this leveling system:
    *
@@ -339,56 +339,56 @@
         return;
       }
       SERIAL_PROTOCOLLNPGM("Loading test_pattern values.\n");
       switch (test_pattern) {
         case -1:
           g29_eeprom_dump();
           break;
         case 0:
           for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++) {   // Create a bowl shape - similar to
             for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++) { // a poorly calibrated Delta.
-              const float p1 = 0.5 * (GRID_MAX_POINTS_X) - x,
-                          p2 = 0.5 * (GRID_MAX_POINTS_Y) - y;
-              z_values[x][y] += 2.0 * HYPOT(p1, p2);
+              const float p1 = 0.5f * (GRID_MAX_POINTS_X) - x,
+                          p2 = 0.5f * (GRID_MAX_POINTS_Y) - y;
+              z_values[x][y] += 2.0f * HYPOT(p1, p2);
             }
           }
           break;
         case 1:
           for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++) {  // Create a diagonal line several Mesh cells thick that is raised
-            z_values[x][x] += 9.999;
-            z_values[x][x + (x < GRID_MAX_POINTS_Y - 1) ? 1 : -1] += 9.999; // We want the altered line several mesh points thick
+            z_values[x][x] += 9.999f;
+            z_values[x][x + (x < GRID_MAX_POINTS_Y - 1) ? 1 : -1] += 9.999f; // We want the altered line several mesh points thick
           }
           break;
         case 2:
           // Allow the user to specify the height because 10mm is a little extreme in some cases.
           for (uint8_t x = (GRID_MAX_POINTS_X) / 3; x < 2 * (GRID_MAX_POINTS_X) / 3; x++)   // Create a rectangular raised area in
             for (uint8_t y = (GRID_MAX_POINTS_Y) / 3; y < 2 * (GRID_MAX_POINTS_Y) / 3; y++) // the center of the bed
-              z_values[x][y] += parser.seen('C') ? g29_constant : 9.99;
+              z_values[x][y] += parser.seen('C') ? g29_constant : 9.99f;
           break;
       }
     }
 
     #if HAS_BED_PROBE
 
       if (parser.seen('J')) {
         if (g29_grid_size) {  // if not 0 it is a normal n x n grid being probed
           save_ubl_active_state_and_disable();
           tilt_mesh_based_on_probed_grid(false /* false says to do normal grid probing */ );
           restore_ubl_active_state_and_leave();
         }
         else { // grid_size == 0 : A 3-Point leveling has been requested
 
           save_ubl_active_state_and_disable();
           tilt_mesh_based_on_probed_grid(true /* true says to do 3-Point leveling */ );
           restore_ubl_active_state_and_leave();
         }
-        do_blocking_move_to_xy(0.5 * (MESH_MAX_X - (MESH_MIN_X)), 0.5 * (MESH_MAX_Y - (MESH_MIN_Y)));
+        do_blocking_move_to_xy(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)));
         report_current_position();
       }
 
     #endif // HAS_BED_PROBE
 
     if (parser.seen('P')) {
       if (WITHIN(g29_phase_value, 0, 1) && storage_slot == -1) {
         storage_slot = 0;
         SERIAL_PROTOCOLLNPGM("Default storage slot 0 selected.");
       }
@@ -446,21 +446,21 @@
                 g29_x_pos = X_HOME_POS;
                 g29_y_pos = Y_HOME_POS;
               #else // cartesian
                 g29_x_pos = X_PROBE_OFFSET_FROM_EXTRUDER > 0 ? X_BED_SIZE : 0;
                 g29_y_pos = Y_PROBE_OFFSET_FROM_EXTRUDER < 0 ? Y_BED_SIZE : 0;
               #endif
             }
 
             if (parser.seen('B')) {
               g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness((float) Z_CLEARANCE_BETWEEN_PROBES);
-              if (ABS(g29_card_thickness) > 1.5) {
+              if (ABS(g29_card_thickness) > 1.5f) {
                 SERIAL_PROTOCOLLNPGM("?Error in Business Card measurement.");
                 return;
               }
             }
 
             if (!position_is_reachable(g29_x_pos, g29_y_pos)) {
               SERIAL_PROTOCOLLNPGM("XY outside printable radius.");
               return;
             }
 
@@ -502,32 +502,32 @@
                       if (isnan(z_values[x][y]))
                         z_values[x][y] = g29_constant;
                   break; // No more invalid Mesh Points to populate
                 }
                 z_values[location.x_index][location.y_index] = g29_constant;
               }
             }
           }
           else {
             const float cvf = parser.value_float();
-            switch ((int)truncf(cvf * 10.0) - 30) {   // 3.1 -> 1
+            switch ((int)truncf(cvf * 10.0f) - 30) {   // 3.1 -> 1
               #if ENABLED(UBL_G29_P31)
                 case 1: {
 
                   // P3.1  use least squares fit to fill missing mesh values
                   // P3.10 zero weighting for distance, all grid points equal, best fit tilted plane
                   // P3.11 10X weighting for nearest grid points versus farthest grid points
                   // P3.12 100X distance weighting
                   // P3.13 1000X distance weighting, approaches simple average of nearest points
 
-                  const float weight_power  = (cvf - 3.10) * 100.0,  // 3.12345 -> 2.345
-                              weight_factor = weight_power ? POW(10.0, weight_power) : 0;
+                  const float weight_power  = (cvf - 3.10f) * 100.0f,  // 3.12345 -> 2.345
+                              weight_factor = weight_power ? POW(10.0f, weight_power) : 0;
                   smart_fill_wlsf(weight_factor);
                 }
                 break;
               #endif
               case 0:   // P3 or P3.0
               default:  // and anything P3.x that's not P3.1
                 smart_fill_mesh();  // Do a 'Smart' fill using nearby known values
                 break;
             }
           }
@@ -627,35 +627,35 @@
       lcd_reset_alert_level();
       lcd_quick_feedback(true);
       lcd_reset_status();
       lcd_external_control = false;
     #endif
 
     return;
   }
 
   void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float value) {
-    float sum = 0.0;
+    float sum = 0;
     int n = 0;
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
         if (!isnan(z_values[x][y])) {
           sum += z_values[x][y];
           n++;
         }
 
     const float mean = sum / n;
 
     //
     // Sum the squares of difference from mean
     //
-    float sum_of_diff_squared = 0.0;
+    float sum_of_diff_squared = 0;
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
         if (!isnan(z_values[x][y]))
           sum_of_diff_squared += sq(z_values[x][y] - mean);
 
     SERIAL_ECHOLNPAIR("# of samples: ", n);
     SERIAL_ECHOPGM("Mean Mesh Height: ");
     SERIAL_ECHO_F(mean, 6);
     SERIAL_EOL();
 
@@ -779,33 +779,33 @@
         gcode.reset_stepper_timeout(); // Keep steppers powered
         if (encoder_diff) {
           do_blocking_move_to_z(current_position[Z_AXIS] + float(encoder_diff) * multiplier);
           encoder_diff = 0;
         }
       }
     }
 
     float unified_bed_leveling::measure_point_with_encoder() {
       KEEPALIVE_STATE(PAUSED_FOR_USER);
-      move_z_with_encoder(0.01);
+      move_z_with_encoder(0.01f);
       KEEPALIVE_STATE(IN_HANDLER);
       return current_position[Z_AXIS];
     }
 
     static void echo_and_take_a_measurement() { SERIAL_PROTOCOLLNPGM(" and take a measurement."); }
 
     float unified_bed_leveling::measure_business_card_thickness(float in_height) {
       lcd_external_control = true;
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
-      do_blocking_move_to(0.5 * (MESH_MAX_X - (MESH_MIN_X)), 0.5 * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
-        //, MIN(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]) / 2.0);
+      do_blocking_move_to(0.5f * (MESH_MAX_X - (MESH_MIN_X)), 0.5f * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
+        //, MIN(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]) * 0.5f);
       planner.synchronize();
 
       SERIAL_PROTOCOLPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       lcd_return_to_status();
       echo_and_take_a_measurement();
 
       const float z1 = measure_point_with_encoder();
       do_blocking_move_to_z(current_position[Z_AXIS] + SIZE_OF_LITTLE_RAISE);
       planner.synchronize();
@@ -867,21 +867,21 @@
         do_blocking_move_to(xProbe, yProbe, Z_CLEARANCE_BETWEEN_PROBES);
         do_blocking_move_to_z(z_clearance);
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         lcd_external_control = true;
 
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
         serialprintPGM(parser.seen('B') ? PSTR(MSG_UBL_BC_INSERT) : PSTR(MSG_UBL_BC_INSERT2));
 
-        const float z_step = 0.01;                          // existing behavior: 0.01mm per click, occasionally step
+        const float z_step = 0.01f;                         // existing behavior: 0.01mm per click, occasionally step
         //const float z_step = planner.steps_to_mm[Z_AXIS]; // approx one step each click
 
         move_z_with_encoder(z_step);
 
         if (click_and_hold()) {
           SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.");
           do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
           lcd_external_control = false;
           KEEPALIVE_STATE(IN_HANDLER);
           restore_ubl_active_state_and_leave();
@@ -906,21 +906,21 @@
   #endif // NEWPANEL
 
   bool unified_bed_leveling::g29_parameter_parsing() {
     bool err_flag = false;
 
     #if ENABLED(NEWPANEL)
       LCD_MESSAGEPGM(MSG_UBL_DOING_G29);
       lcd_quick_feedback(true);
     #endif
 
-    g29_constant = 0.0;
+    g29_constant = 0;
     g29_repetition_cnt = 0;
 
     g29_x_flag = parser.seenval('X');
     g29_x_pos = g29_x_flag ? parser.value_float() : current_position[X_AXIS];
     g29_y_flag = parser.seenval('Y');
     g29_y_pos = g29_y_flag ? parser.value_float() : current_position[Y_AXIS];
 
     if (parser.seen('R')) {
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : GRID_MAX_POINTS;
       NOMORE(g29_repetition_cnt, GRID_MAX_POINTS);
@@ -997,21 +997,21 @@
       report_state();
     }
 
     // Set global 'C' flag and its value
     if ((g29_c_flag = parser.seen('C')))
       g29_constant = parser.value_float();
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       if (parser.seenval('F')) {
         const float fh = parser.value_float();
-        if (!WITHIN(fh, 0.0, 100.0)) {
+        if (!WITHIN(fh, 0, 100)) {
           SERIAL_PROTOCOLLNPGM("?(F)ade height for Bed Level Correction not plausible.\n");
           return UBL_ERR;
         }
         set_z_fade_height(fh);
       }
     #endif
 
     g29_map_type = parser.intval('T');
     if (!WITHIN(g29_map_type, 0, 2)) {
       SERIAL_PROTOCOLLNPGM("Invalid map type.\n");
@@ -1219,37 +1219,37 @@
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
         z_values[x][y] -= tmp_z_values[x][y];
   }
 
   mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
     bool found_a_NAN  = false, found_a_real = false;
 
     mesh_index_pair out_mesh;
     out_mesh.x_index = out_mesh.y_index = -1;
-    out_mesh.distance = -99999.99;
+    out_mesh.distance = -99999.99f;
 
     for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
 
         if (isnan(z_values[i][j])) { // Check to see if this location holds an invalid mesh point
 
           const float mx = mesh_index_to_xpos(i),
                       my = mesh_index_to_ypos(j);
 
           if (!position_is_reachable_by_probe(mx, my))  // make sure the probe can get to the mesh point
             continue;
 
           found_a_NAN = true;
 
           int8_t closest_x = -1, closest_y = -1;
-          float d1, d2 = 99999.9;
+          float d1, d2 = 99999.9f;
           for (int8_t k = 0; k < GRID_MAX_POINTS_X; k++) {
             for (int8_t l = 0; l < GRID_MAX_POINTS_Y; l++) {
               if (!isnan(z_values[k][l])) {
                 found_a_real = true;
 
                 // Add in a random weighting factor that scrambles the probing of the
                 // last half of the mesh (when every unprobed mesh point is one index
                 // from a probed location).
 
                 d1 = HYPOT(i - k, j - l) + (1.0f / ((millis() % 47) + 13));
@@ -1272,35 +1272,35 @@
             out_mesh.x_index = closest_x;   // to a defined mesh point
             out_mesh.y_index = closest_y;
           }
         }
       } // for j
     } // for i
 
     if (!found_a_real && found_a_NAN) {        // if the mesh is totally unpopulated, start the probing
       out_mesh.x_index = GRID_MAX_POINTS_X / 2;
       out_mesh.y_index = GRID_MAX_POINTS_Y / 2;
-      out_mesh.distance = 1.0;
+      out_mesh.distance = 1;
     }
     return out_mesh;
   }
 
   mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const float &rx, const float &ry, const bool probe_as_reference, uint16_t bits[16]) {
     mesh_index_pair out_mesh;
     out_mesh.x_index = out_mesh.y_index = -1;
-    out_mesh.distance = -99999.9;
+    out_mesh.distance = -99999.9f;
 
     // Get our reference position. Either the nozzle or probe location.
     const float px = rx - (probe_as_reference == USE_PROBE_AS_REFERENCE ? X_PROBE_OFFSET_FROM_EXTRUDER : 0),
                 py = ry - (probe_as_reference == USE_PROBE_AS_REFERENCE ? Y_PROBE_OFFSET_FROM_EXTRUDER : 0);
 
-    float best_so_far = 99999.99;
+    float best_so_far = 99999.99f;
 
     for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
 
         if ( (type == INVALID && isnan(z_values[i][j]))  // Check to see if this location holds the right thing
           || (type == REAL && !isnan(z_values[i][j]))
           || (type == SET_IN_BITMAP && is_bitmap_set(bits, i, j))
         ) {
           // We only get here if we found a Mesh Point of the specified type
 
@@ -1313,21 +1313,21 @@
 
           if (probe_as_reference ? !position_is_reachable_by_probe(mx, my) : !position_is_reachable(mx, my))
             continue;
 
           // Reachable. Check if it's the best_so_far location to the nozzle.
 
           float distance = HYPOT(px - mx, py - my);
 
           // factor in the distance from the current location for the normal case
           // so the nozzle isn't running all over the bed.
-          distance += HYPOT(current_position[X_AXIS] - mx, current_position[Y_AXIS] - my) * 0.1;
+          distance += HYPOT(current_position[X_AXIS] - mx, current_position[Y_AXIS] - my) * 0.1f;
           if (distance < best_so_far) {
             best_so_far = distance;   // We found a closer location with
             out_mesh.x_index = i;     // the specified type of mesh value.
             out_mesh.y_index = j;
             out_mesh.distance = best_so_far;
           }
         }
       } // for j
     } // for i
 
@@ -1394,22 +1394,22 @@
           do_blocking_move_to_z(h_offset);                          // Move Z to the given 'H' offset before editing
         #endif
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
 
         if (do_ubl_mesh_map) display_map(g29_map_type);             // Display the current point
 
         lcd_refresh();
 
         float new_z = z_values[location.x_index][location.y_index];
-        if (isnan(new_z)) new_z = 0.0;                              // Invalid points begin at 0
-        new_z = FLOOR(new_z * 1000.0) * 0.001;                      // Chop off digits after the 1000ths place
+        if (isnan(new_z)) new_z = 0;                                // Invalid points begin at 0
+        new_z = FLOOR(new_z * 1000) * 0.001f;                       // Chop off digits after the 1000ths place
 
         lcd_mesh_edit_setup(new_z);
 
         do {
           new_z = lcd_mesh_edit();
           #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
             do_blocking_move_to_z(h_offset + new_z);                // Move the nozzle as the point is edited
           #endif
           idle();
           SERIAL_FLUSH();                                           // Prevent host M105 buffer overrun.
@@ -1454,21 +1454,21 @@
    */
 
   bool unified_bed_leveling::smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
     const int8_t x1 = x + xdir, x2 = x1 + xdir,
                  y1 = y + ydir, y2 = y1 + ydir;
     // A NAN next to a pair of real values?
     if (isnan(z_values[x][y]) && !isnan(z_values[x1][y1]) && !isnan(z_values[x2][y2])) {
       if (z_values[x1][y1] < z_values[x2][y2])                  // Angled downward?
         z_values[x][y] = z_values[x1][y1];                      // Use nearest (maybe a little too high.)
       else
-        z_values[x][y] = 2.0 * z_values[x1][y1] - z_values[x2][y2];   // Angled upward...
+        z_values[x][y] = 2.0f * z_values[x1][y1] - z_values[x2][y2];   // Angled upward...
       return true;
     }
     return false;
   }
 
   typedef struct { uint8_t sx, ex, sy, ey; bool yfirst; } smart_fill_info;
 
   void unified_bed_leveling::smart_fill_mesh() {
     static const smart_fill_info
       info0 PROGMEM = { 0, GRID_MAX_POINTS_X,      0, GRID_MAX_POINTS_Y - 2,  false },  // Bottom of the mesh looking up
@@ -1503,22 +1503,22 @@
     void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
       constexpr int16_t x_min = MAX(MIN_PROBE_X, MESH_MIN_X),
                         x_max = MIN(MAX_PROBE_X, MESH_MAX_X),
                         y_min = MAX(MIN_PROBE_Y, MESH_MIN_Y),
                         y_max = MIN(MAX_PROBE_Y, MESH_MAX_Y);
 
       bool abort_flag = false;
 
       float measured_z;
 
-      const float dx = float(x_max - x_min) / (g29_grid_size - 1.0),
-                  dy = float(y_max - y_min) / (g29_grid_size - 1.0);
+      const float dx = float(x_max - x_min) / (g29_grid_size - 1),
+                  dy = float(y_max - y_min) / (g29_grid_size - 1);
 
       struct linear_fit_data lsf_results;
 
       //float z1, z2, z3;  // Needed for algorithm validation down below.
 
       incremental_LSF_reset(&lsf_results);
 
       if (do_3_pt_leveling) {
         measured_z = probe_pt(PROBE_PT_1_X, PROBE_PT_1_Y, PROBE_PT_RAISE, g29_verbose_level);
         if (isnan(measured_z))
@@ -1627,21 +1627,21 @@
       STOW_PROBE();
       #ifdef Z_AFTER_PROBING
         move_z_after_probing();
       #endif
       
       if (abort_flag || finish_incremental_LSF(&lsf_results)) {
         SERIAL_ECHOPGM("Could not complete LSF!");
         return;
       }
 
-      vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1.0000).get_normal();
+      vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1).get_normal();
 
       if (g29_verbose_level > 2) {
         SERIAL_ECHOPGM("bed plane normal = [");
         SERIAL_PROTOCOL_F(normal.x, 7);
         SERIAL_PROTOCOLCHAR(',');
         SERIAL_PROTOCOL_F(normal.y, 7);
         SERIAL_PROTOCOLCHAR(',');
         SERIAL_PROTOCOL_F(normal.z, 7);
         SERIAL_ECHOLNPGM("]");
       }
@@ -1706,21 +1706,21 @@
           SERIAL_PROTOCOL_F(normal.z, 7);
           SERIAL_ECHOPGM("]\n");
           SERIAL_EOL();
 
           /**
            * The following code can be used to check the validity of the mesh tilting algorithm.
            * When a 3-Point Mesh Tilt is done, the same algorithm is used as the grid based tilting.
            * The only difference is just 3 points are used in the calculations.   That fact guarantees
            * each probed point should have an exact match when a get_z_correction() for that location
            * is calculated.  The Z error between the probed point locations and the get_z_correction()
-           * numbers for those locations should be 0.000
+           * numbers for those locations should be 0.
            */
           #if 0
           float t, t1, d;
           t = normal.x * (PROBE_PT_1_X) + normal.y * (PROBE_PT_1_Y);
           d = t + normal.z * z1;
           SERIAL_ECHOPGM("D from 1st point: ");
           SERIAL_ECHO_F(d, 6);
           SERIAL_ECHOPGM("   Z error: ");
           SERIAL_ECHO_F(normal.z*z1-get_z_correction(PROBE_PT_1_X, PROBE_PT_1_Y), 6);
           SERIAL_EOL();
@@ -1736,27 +1736,27 @@
 
           t = normal.x * (PROBE_PT_3_X) + normal.y * (PROBE_PT_3_Y);
           d = t + normal.z * z3;
           SERIAL_ECHOPGM("D from 3rd point: ");
           SERIAL_ECHO_F(d, 6);
           SERIAL_ECHOPGM("   Z error: ");
           SERIAL_ECHO_F(normal.z*z3-get_z_correction(PROBE_PT_3_X, PROBE_PT_3_Y), 6);
           SERIAL_EOL();
 
           t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
-          d = t + normal.z * 0.000;
+          d = t + normal.z * 0;
           SERIAL_ECHOPGM("D from home location with Z=0 : ");
           SERIAL_ECHO_F(d, 6);
           SERIAL_EOL();
 
           t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
-          d = t + get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT); // normal.z * 0.000;
+          d = t + get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT); // normal.z * 0;
           SERIAL_ECHOPGM("D from home location using mesh value for Z: ");
           SERIAL_ECHO_F(d, 6);
 
           SERIAL_ECHOPAIR("   Z error: (", Z_SAFE_HOMING_X_POINT);
           SERIAL_ECHOPAIR(",", Z_SAFE_HOMING_Y_POINT );
           SERIAL_ECHOPGM(") = ");
           SERIAL_ECHO_F(get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT), 6);
           SERIAL_EOL();
           #endif
         } // DEBUGGING(LEVELING)
@@ -1793,21 +1793,21 @@
           const float py = mesh_index_to_ypos(iy);
           if (isnan(z_values[ix][iy])) {
             // undefined mesh point at (px,py), compute weighted LSF from original valid mesh points.
             incremental_LSF_reset(&lsf_results);
             for (uint8_t jx = 0; jx < GRID_MAX_POINTS_X; jx++) {
               const float rx = mesh_index_to_xpos(jx);
               for (uint8_t jy = 0; jy < GRID_MAX_POINTS_Y; jy++) {
                 if (TEST(bitmap[jx], jy)) {
                   const float ry = mesh_index_to_ypos(jy),
                               rz = z_values[jx][jy],
-                              w  = 1.0 + weight_scaled / HYPOT((rx - px), (ry - py));
+                              w  = 1 + weight_scaled / HYPOT((rx - px), (ry - py));
                   incremental_WLSF(&lsf_results, rx, ry, rz, w);
                 }
               }
             }
             if (finish_incremental_LSF(&lsf_results)) {
               SERIAL_ECHOLNPGM("Insufficient data");
               return;
             }
             const float ez = -lsf_results.D - lsf_results.A * px - lsf_results.B * py;
             z_values[ix][iy] = ez;

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index c7c0352dfd..956238ba50 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -867,22 +867,22 @@
         do_blocking_move_to(xProbe, yProbe, Z_CLEARANCE_BETWEEN_PROBES);
         do_blocking_move_to_z(z_clearance);
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         lcd_external_control = true;
 
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
         serialprintPGM(parser.seen('B') ? PSTR(MSG_UBL_BC_INSERT) : PSTR(MSG_UBL_BC_INSERT2));
 
-        const float z_step = 0.01;                                        // existing behavior: 0.01mm per click, occasionally step
-        //const float z_step = 1.0 / planner.axis_steps_per_mm[Z_AXIS];   // approx one step each click
+        const float z_step = 0.01;                          // existing behavior: 0.01mm per click, occasionally step
+        //const float z_step = planner.steps_to_mm[Z_AXIS]; // approx one step each click
 
         move_z_with_encoder(z_step);
 
         if (click_and_hold()) {
           SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.");
           do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
           lcd_external_control = false;
           KEEPALIVE_STATE(IN_HANDLER);
           restore_ubl_active_state_and_leave();
           return;
@@ -1245,21 +1245,21 @@
           float d1, d2 = 99999.9;
           for (int8_t k = 0; k < GRID_MAX_POINTS_X; k++) {
             for (int8_t l = 0; l < GRID_MAX_POINTS_Y; l++) {
               if (!isnan(z_values[k][l])) {
                 found_a_real = true;
 
                 // Add in a random weighting factor that scrambles the probing of the
                 // last half of the mesh (when every unprobed mesh point is one index
                 // from a probed location).
 
-                d1 = HYPOT(i - k, j - l) + (1.0 / ((millis() % 47) + 13));
+                d1 = HYPOT(i - k, j - l) + (1.0f / ((millis() % 47) + 13));
 
                 if (d1 < d2) {    // found a closer distance from invalid mesh point at (i,j) to defined mesh point at (k,l)
                   d2 = d1;        // found a closer location with
                   closest_x = i;  // an assigned mesh point value
                   closest_y = j;
                 }
               }
             }
           }
 

commit 1d7dd0edfdb96c0701289fb008986ee572292dec
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Thu Jun 21 13:26:20 2018 -0500

    Add the move_z_after_probing() functionality to UBL's G29 J

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 7ebcd78cef..c7c0352dfd 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1555,21 +1555,26 @@
             abort_flag = true;
           else {
             measured_z -= get_z_correction(PROBE_PT_3_X, PROBE_PT_3_Y);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, PROBE_PT_3_X, PROBE_PT_3_Y, measured_z);
           }
         }
-
+        
+        STOW_PROBE();
+        #ifdef Z_AFTER_PROBING
+          move_z_after_probing();
+        #endif
+        
         if (abort_flag) {
           SERIAL_ECHOPGM("?Error probing point.  Aborting operation.\n");
           return;
         }
       }
       else { // !do_3_pt_leveling
 
         bool zig_zag = false;
         for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
           const float rx = float(x_min) + ix * dx;
@@ -1611,23 +1616,26 @@
               if (g29_verbose_level > 3) {
                 serial_spaces(16);
                 SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
               }
               incremental_LSF(&lsf_results, rx, ry, measured_z);
             }
           }
 
           zig_zag ^= true;
         }
-        STOW_PROBE();
       }
-
+      STOW_PROBE();
+      #ifdef Z_AFTER_PROBING
+        move_z_after_probing();
+      #endif
+      
       if (abort_flag || finish_incremental_LSF(&lsf_results)) {
         SERIAL_ECHOPGM("Could not complete LSF!");
         return;
       }
 
       vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1.0000).get_normal();
 
       if (g29_verbose_level > 2) {
         SERIAL_ECHOPGM("bed plane normal = [");
         SERIAL_PROTOCOL_F(normal.x, 7);

commit a2a30ff0ac2be6c915d7b0193c827bae3395638c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 19 22:54:20 2018 -0500

    Use Tool 0 for Dual X Axis G29
    
    See https://github.com/MarlinFirmware/Marlin/issues/5597#issuecomment-397683325

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 53a7f7252d..7ebcd78cef 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -285,27 +285,31 @@
    *   the mesh just right. To prevent this valuable data from being destroyed as the EEPROM structure
    *   evolves, UBL stores all mesh data at the end of EEPROM.
    *
    *   UBL is founded on Edward Patel's Mesh Bed Leveling code. A big 'Thanks!' to him and the creators of
    *   3-Point and Grid Based leveling. Combining their contributions we now have the functionality and
    *   features of all three systems combined.
    */
 
   void unified_bed_leveling::G29() {
 
-    if (g29_parameter_parsing()) return; // abort if parsing the simple parameters causes a problem,
+    if (g29_parameter_parsing()) return; // Abort on parameter error
+
+    const int8_t p_val = parser.intval('P', -1);
+    const bool may_move = p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J');
 
     // Check for commands that require the printer to be homed
-    if (axis_unhomed_error()) {
-      const int8_t p_val = parser.intval('P', -1);
-      if (p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J'))
-        gcode.home_all_axes();
+    if (may_move) {
+      if (axis_unhomed_error()) gcode.home_all_axes();
+      #if ENABLED(DUAL_X_CARRIAGE)
+        if (active_extruder != 0) tool_change(0);
+      #endif
     }
 
     // Invalidate Mesh Points. This command is a little bit asymmetrical because
     // it directly specifies the repetition count and does not use the 'R' parameter.
     if (parser.seen('I')) {
       uint8_t cnt = 0;
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : 1;
       if (g29_repetition_cnt >= GRID_MAX_POINTS) {
         set_all_mesh_points_to_value(NAN);
       }

commit d4795e5b8eff93fcab4a80d16cd7bc5ceb2ebc51
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 18 22:04:03 2018 -0500

    [2.0.x] Tweaks and additions for MAX7219 (#11034)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 2ed21e4acc..53a7f7252d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -34,22 +34,20 @@
   #include "../../../lcd/ultralcd.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
   #include "../../../module/probe.h"
   #include "../../../gcode/gcode.h"
   #include "../../../core/serial.h"
   #include "../../../gcode/parser.h"
   #include "../../../feature/bedlevel/bedlevel.h"
   #include "../../../libs/least_squares_fit.h"
 
-  #include "../../../feature/Max7219_Debug_LEDs.h"
-
   #include <math.h>
 
   #define UBL_G29_P31
 
   extern float destination[XYZE], current_position[XYZE];
 
   #if ENABLED(NEWPANEL)
     void lcd_return_to_status();
     void _lcd_ubl_output_map_lcd();
   #endif

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index c4b1dc73d1..2ed21e4acc 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -444,21 +444,21 @@
                 g29_x_pos = X_HOME_POS;
                 g29_y_pos = Y_HOME_POS;
               #else // cartesian
                 g29_x_pos = X_PROBE_OFFSET_FROM_EXTRUDER > 0 ? X_BED_SIZE : 0;
                 g29_y_pos = Y_PROBE_OFFSET_FROM_EXTRUDER < 0 ? Y_BED_SIZE : 0;
               #endif
             }
 
             if (parser.seen('B')) {
               g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness((float) Z_CLEARANCE_BETWEEN_PROBES);
-              if (FABS(g29_card_thickness) > 1.5) {
+              if (ABS(g29_card_thickness) > 1.5) {
                 SERIAL_PROTOCOLLNPGM("?Error in Business Card measurement.");
                 return;
               }
             }
 
             if (!position_is_reachable(g29_x_pos, g29_y_pos)) {
               SERIAL_PROTOCOLLNPGM("XY outside printable radius.");
               return;
             }
 
@@ -789,41 +789,41 @@
       return current_position[Z_AXIS];
     }
 
     static void echo_and_take_a_measurement() { SERIAL_PROTOCOLLNPGM(" and take a measurement."); }
 
     float unified_bed_leveling::measure_business_card_thickness(float in_height) {
       lcd_external_control = true;
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
       do_blocking_move_to(0.5 * (MESH_MAX_X - (MESH_MIN_X)), 0.5 * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
-        //, min(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]) / 2.0);
+        //, MIN(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]) / 2.0);
       planner.synchronize();
 
       SERIAL_PROTOCOLPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       lcd_return_to_status();
       echo_and_take_a_measurement();
 
       const float z1 = measure_point_with_encoder();
       do_blocking_move_to_z(current_position[Z_AXIS] + SIZE_OF_LITTLE_RAISE);
       planner.synchronize();
 
       SERIAL_PROTOCOLPGM("Remove shim");
       LCD_MESSAGEPGM(MSG_UBL_BC_REMOVE);
       echo_and_take_a_measurement();
 
       const float z2 = measure_point_with_encoder();
 
       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES);
 
-      const float thickness = abs(z1 - z2);
+      const float thickness = ABS(z1 - z2);
 
       if (g29_verbose_level > 1) {
         SERIAL_PROTOCOLPGM("Business Card is ");
         SERIAL_PROTOCOL_F(thickness, 4);
         SERIAL_PROTOCOLLNPGM("mm thick.");
       }
 
       lcd_external_control = false;
 
       restore_ubl_active_state_and_leave();
@@ -1492,24 +1492,24 @@
             if (smart_fill_one(x, y, 0, dir)) break;
       }
     }
   }
 
   #if HAS_BED_PROBE
 
     #include "../../../libs/vector_3.h"
 
     void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
-      constexpr int16_t x_min = max(MIN_PROBE_X, MESH_MIN_X),
-                        x_max = min(MAX_PROBE_X, MESH_MAX_X),
-                        y_min = max(MIN_PROBE_Y, MESH_MIN_Y),
-                        y_max = min(MAX_PROBE_Y, MESH_MAX_Y);
+      constexpr int16_t x_min = MAX(MIN_PROBE_X, MESH_MIN_X),
+                        x_max = MIN(MAX_PROBE_X, MESH_MAX_X),
+                        y_min = MAX(MIN_PROBE_Y, MESH_MIN_Y),
+                        y_max = MIN(MAX_PROBE_Y, MESH_MAX_Y);
 
       bool abort_flag = false;
 
       float measured_z;
 
       const float dx = float(x_max - x_min) / (g29_grid_size - 1.0),
                   dy = float(y_max - y_min) / (g29_grid_size - 1.0);
 
       struct linear_fit_data lsf_results;
 
@@ -1763,21 +1763,21 @@
       // from all the originally populated mesh points, weighted toward the point
       // being extrapolated so that nearby points will have greater influence on
       // the point being extrapolated.  Then extrapolate the mesh point from WLSF.
 
       static_assert(GRID_MAX_POINTS_Y <= 16, "GRID_MAX_POINTS_Y too big");
       uint16_t bitmap[GRID_MAX_POINTS_X] = { 0 };
       struct linear_fit_data lsf_results;
 
       SERIAL_ECHOPGM("Extrapolating mesh...");
 
-      const float weight_scaled = weight_factor * max(MESH_X_DIST, MESH_Y_DIST);
+      const float weight_scaled = weight_factor * MAX(MESH_X_DIST, MESH_Y_DIST);
 
       for (uint8_t jx = 0; jx < GRID_MAX_POINTS_X; jx++)
         for (uint8_t jy = 0; jy < GRID_MAX_POINTS_Y; jy++)
           if (!isnan(z_values[jx][jy]))
             SBI(bitmap[jx], jy);
 
       for (uint8_t ix = 0; ix < GRID_MAX_POINTS_X; ix++) {
         const float px = mesh_index_to_xpos(ix);
         for (uint8_t iy = 0; iy < GRID_MAX_POINTS_Y; iy++) {
           const float py = mesh_index_to_ypos(iy);

commit 306f0f2135e4b2aed749a0d1b870abf17d883e38
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 01:38:02 2018 -0500

    Move Stepper::synchronize to Planner (#10713)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 1537239ad4..c4b1dc73d1 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -790,30 +790,30 @@
     }
 
     static void echo_and_take_a_measurement() { SERIAL_PROTOCOLLNPGM(" and take a measurement."); }
 
     float unified_bed_leveling::measure_business_card_thickness(float in_height) {
       lcd_external_control = true;
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
       do_blocking_move_to(0.5 * (MESH_MAX_X - (MESH_MIN_X)), 0.5 * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
         //, min(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]) / 2.0);
-      stepper.synchronize();
+      planner.synchronize();
 
       SERIAL_PROTOCOLPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       lcd_return_to_status();
       echo_and_take_a_measurement();
 
       const float z1 = measure_point_with_encoder();
       do_blocking_move_to_z(current_position[Z_AXIS] + SIZE_OF_LITTLE_RAISE);
-      stepper.synchronize();
+      planner.synchronize();
 
       SERIAL_PROTOCOLPGM("Remove shim");
       LCD_MESSAGEPGM(MSG_UBL_BC_REMOVE);
       echo_and_take_a_measurement();
 
       const float z2 = measure_point_with_encoder();
 
       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES);
 
       const float thickness = abs(z1 - z2);

commit d7b699ec340caf0c14efda13c7ced4fec78ecff9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 1 07:05:18 2018 -0500

    Fewer includes of vector_3.h

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 03b1d582ca..1537239ad4 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -34,21 +34,21 @@
   #include "../../../lcd/ultralcd.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
   #include "../../../module/probe.h"
   #include "../../../gcode/gcode.h"
   #include "../../../core/serial.h"
   #include "../../../gcode/parser.h"
   #include "../../../feature/bedlevel/bedlevel.h"
   #include "../../../libs/least_squares_fit.h"
 
-#include "../../../feature/Max7219_Debug_LEDs.h"
+  #include "../../../feature/Max7219_Debug_LEDs.h"
 
   #include <math.h>
 
   #define UBL_G29_P31
 
   extern float destination[XYZE], current_position[XYZE];
 
   #if ENABLED(NEWPANEL)
     void lcd_return_to_status();
     void _lcd_ubl_output_map_lcd();
@@ -1489,20 +1489,22 @@
         const int8_t dir = ey > sy ? 1 : -1;
          for (uint8_t x = sx; x != ex; ++x)
           for (uint8_t y = sy; y != ey; y += dir)
             if (smart_fill_one(x, y, 0, dir)) break;
       }
     }
   }
 
   #if HAS_BED_PROBE
 
+    #include "../../../libs/vector_3.h"
+
     void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
       constexpr int16_t x_min = max(MIN_PROBE_X, MESH_MIN_X),
                         x_max = min(MAX_PROBE_X, MESH_MAX_X),
                         y_min = max(MIN_PROBE_Y, MESH_MIN_Y),
                         y_max = min(MAX_PROBE_Y, MESH_MAX_Y);
 
       bool abort_flag = false;
 
       float measured_z;
 

commit 05c33833e70c143b726fa32d0052618d178fa0ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 30 21:16:31 2018 -0500

    [2.0.x] Add NO_LCD_MENUS option (#10582)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 0f6f0008af..03b1d582ca 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -47,23 +47,20 @@
 
   #define UBL_G29_P31
 
   extern float destination[XYZE], current_position[XYZE];
 
   #if ENABLED(NEWPANEL)
     void lcd_return_to_status();
     void _lcd_ubl_output_map_lcd();
   #endif
 
-  extern float meshedit_done;
-  extern long babysteps_done;
-
   #define SIZE_OF_LITTLE_RAISE 1
   #define BIG_RAISE_NOT_NEEDED 0
 
   int    unified_bed_leveling::g29_verbose_level,
          unified_bed_leveling::g29_phase_value,
          unified_bed_leveling::g29_repetition_cnt,
          unified_bed_leveling::g29_storage_slot = 0,
          unified_bed_leveling::g29_map_type;
   bool   unified_bed_leveling::g29_c_flag,
          unified_bed_leveling::g29_x_flag,

commit 59fda986ea429c83b0e20cd8b1a172fd2a550852
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 30 03:25:47 2018 -0500

    Allow Z_AFTER_PROBING to be 0

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 8a1cb40c36..0f6f0008af 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -749,21 +749,21 @@
                       rawy = mesh_index_to_ypos(location.y_index);
 
           const float measured_z = probe_pt(rawx, rawy, stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
           z_values[location.x_index][location.y_index] = measured_z;
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.x_index >= 0 && --count);
 
       STOW_PROBE();
 
-      #if Z_AFTER_PROBING
+      #ifdef Z_AFTER_PROBING
         move_z_after_probing();
       #endif
 
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
         constrain(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_X, MESH_MAX_X),
         constrain(ry - (Y_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_Y, MESH_MAX_Y)
       );
     }

commit 8db7fb226a515a0b0dd1ca009ea2e27f2a03c5f0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 28 08:14:20 2018 -0500

    Fix M420 C for UBL

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 433e36cbfe..8a1cb40c36 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -537,21 +537,21 @@
 
         case 4: // Fine Tune (i.e., Edit) the Mesh
           #if ENABLED(NEWPANEL)
             fine_tune_mesh(g29_x_pos, g29_y_pos, parser.seen('T'));
           #else
             SERIAL_PROTOCOLLNPGM("?P4 is only available when an LCD is present.");
             return;
           #endif
           break;
 
-        case 5: adjust_mesh_to_mean(g29_constant); break;
+        case 5: adjust_mesh_to_mean(g29_c_flag, g29_constant); break;
 
         case 6: shift_mesh_height(); break;
       }
     }
 
     //
     // Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
     // good to have the extra information. Soon... we prune this to just a few items
     //
     if (parser.seen('W')) g29_what_command();
@@ -627,21 +627,21 @@
     #if ENABLED(NEWPANEL)
       lcd_reset_alert_level();
       lcd_quick_feedback(true);
       lcd_reset_status();
       lcd_external_control = false;
     #endif
 
     return;
   }
 
-  void unified_bed_leveling::adjust_mesh_to_mean(const float value) {
+  void unified_bed_leveling::adjust_mesh_to_mean(const bool cflag, const float value) {
     float sum = 0.0;
     int n = 0;
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
         if (!isnan(z_values[x][y])) {
           sum += z_values[x][y];
           n++;
         }
 
     const float mean = sum / n;
@@ -658,21 +658,21 @@
     SERIAL_ECHOLNPAIR("# of samples: ", n);
     SERIAL_ECHOPGM("Mean Mesh Height: ");
     SERIAL_ECHO_F(mean, 6);
     SERIAL_EOL();
 
     const float sigma = SQRT(sum_of_diff_squared / (n + 1));
     SERIAL_ECHOPGM("Standard Deviation: ");
     SERIAL_ECHO_F(sigma, 6);
     SERIAL_EOL();
 
-    if (g29_c_flag)
+    if (cflag)
       for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
         for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
           if (!isnan(z_values[x][y]))
             z_values[x][y] -= mean + value;
   }
 
   void unified_bed_leveling::shift_mesh_height() {
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
         if (!isnan(z_values[x][y]))
@@ -1074,21 +1074,21 @@
     safe_delay(50);
 
     SERIAL_PROTOCOLLNPAIR("UBL object count: ", (int)ubl_cnt);
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       SERIAL_PROTOCOLPGM("planner.z_fade_height : ");
       SERIAL_PROTOCOL_F(planner.z_fade_height, 4);
       SERIAL_EOL();
     #endif
 
-    adjust_mesh_to_mean(g29_constant);
+    adjust_mesh_to_mean(g29_c_flag, g29_constant);
 
     #if HAS_BED_PROBE
       SERIAL_PROTOCOLPGM("zprobe_zoffset: ");
       SERIAL_PROTOCOL_F(zprobe_zoffset, 7);
       SERIAL_EOL();
     #endif
 
     SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X);
     safe_delay(50);
     SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y);

commit eef0248a1c66cf30482253359f8bebe672ef56a9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 25 06:43:45 2018 -0500

    Add M420 C to adjust the whole mesh (#10522)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 7da88d7c87..433e36cbfe 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -537,21 +537,21 @@
 
         case 4: // Fine Tune (i.e., Edit) the Mesh
           #if ENABLED(NEWPANEL)
             fine_tune_mesh(g29_x_pos, g29_y_pos, parser.seen('T'));
           #else
             SERIAL_PROTOCOLLNPGM("?P4 is only available when an LCD is present.");
             return;
           #endif
           break;
 
-        case 5: find_mean_mesh_height(); break;
+        case 5: adjust_mesh_to_mean(g29_constant); break;
 
         case 6: shift_mesh_height(); break;
       }
     }
 
     //
     // Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
     // good to have the extra information. Soon... we prune this to just a few items
     //
     if (parser.seen('W')) g29_what_command();
@@ -627,21 +627,21 @@
     #if ENABLED(NEWPANEL)
       lcd_reset_alert_level();
       lcd_quick_feedback(true);
       lcd_reset_status();
       lcd_external_control = false;
     #endif
 
     return;
   }
 
-  void unified_bed_leveling::find_mean_mesh_height() {
+  void unified_bed_leveling::adjust_mesh_to_mean(const float value) {
     float sum = 0.0;
     int n = 0;
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
         if (!isnan(z_values[x][y])) {
           sum += z_values[x][y];
           n++;
         }
 
     const float mean = sum / n;
@@ -662,21 +662,21 @@
 
     const float sigma = SQRT(sum_of_diff_squared / (n + 1));
     SERIAL_ECHOPGM("Standard Deviation: ");
     SERIAL_ECHO_F(sigma, 6);
     SERIAL_EOL();
 
     if (g29_c_flag)
       for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
         for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
           if (!isnan(z_values[x][y]))
-            z_values[x][y] -= mean + g29_constant;
+            z_values[x][y] -= mean + value;
   }
 
   void unified_bed_leveling::shift_mesh_height() {
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
         if (!isnan(z_values[x][y]))
           z_values[x][y] += g29_constant;
   }
 
   #if ENABLED(NEWPANEL)
@@ -1074,21 +1074,21 @@
     safe_delay(50);
 
     SERIAL_PROTOCOLLNPAIR("UBL object count: ", (int)ubl_cnt);
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       SERIAL_PROTOCOLPGM("planner.z_fade_height : ");
       SERIAL_PROTOCOL_F(planner.z_fade_height, 4);
       SERIAL_EOL();
     #endif
 
-    find_mean_mesh_height();
+    adjust_mesh_to_mean(g29_constant);
 
     #if HAS_BED_PROBE
       SERIAL_PROTOCOLPGM("zprobe_zoffset: ");
       SERIAL_PROTOCOL_F(zprobe_zoffset, 7);
       SERIAL_EOL();
     #endif
 
     SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X);
     safe_delay(50);
     SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y);

commit c82dd5129f1be748a38a2af7e0ea0a9967ca0275
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 24 08:04:13 2018 -0500

    Revert potentially-not-redundant UBL test
    
    Response to #10435

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 886d79f852..7da88d7c87 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1380,21 +1380,21 @@
         location = find_closest_mesh_point_of_type(SET_IN_BITMAP, rx, ry, USE_NOZZLE_AS_REFERENCE, not_done);
 
         if (location.x_index < 0) break;                            // Stop when there are no more reachable points
 
         bitmap_clear(not_done, location.x_index, location.y_index); // Mark this location as 'adjusted' so a new
                                                                     // location is used on the next loop
 
         const float rawx = mesh_index_to_xpos(location.x_index),
                     rawy = mesh_index_to_ypos(location.y_index);
 
-        //if (!position_is_reachable(rawx, rawy)) break;            // SHOULD NOT OCCUR because find_closest_mesh_point_of_type will only return reachable
+        if (!position_is_reachable(rawx, rawy)) break;              // SHOULD NOT OCCUR because find_closest_mesh_point_of_type will only return reachable
 
         do_blocking_move_to(rawx, rawy, Z_CLEARANCE_BETWEEN_PROBES); // Move the nozzle to the edit point with probe clearance
 
         #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
           do_blocking_move_to_z(h_offset);                          // Move Z to the given 'H' offset before editing
         #endif
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
 
         if (do_ubl_mesh_map) display_map(g29_map_type);             // Display the current point

commit 33966710119b64f83a19075875a8d27452cca9a4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 22 00:16:30 2018 -0500

    [2.0.x] Reset LCD status to fallbacks (#10470)
    
    * Remove obsolete strings
    * Tweak some static consts
    * Reset LCD status to fallbacks

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 7a3fb55372..886d79f852 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -619,22 +619,22 @@
       SERIAL_PROTOCOLLNPGM("Done.");
     }
 
     if (parser.seen('T'))
       display_map(g29_map_type);
 
     LEAVE:
 
     #if ENABLED(NEWPANEL)
       lcd_reset_alert_level();
-      LCD_MESSAGEPGM("");
       lcd_quick_feedback(true);
+      lcd_reset_status();
       lcd_external_control = false;
     #endif
 
     return;
   }
 
   void unified_bed_leveling::find_mean_mesh_height() {
     float sum = 0.0;
     int n = 0;
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)

commit 0746aff595fde79b62f01fca8588ac803bc3521c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 17 15:52:56 2018 -0500

    Improve UBL mesh report. Add M420 T, M421 N

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index c5d575d40d..7a3fb55372 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -245,23 +245,21 @@
    *   R #   Repeat     Repeat this command the specified number of times. If no number is specified the
    *                    command will be repeated GRID_MAX_POINTS_X * GRID_MAX_POINTS_Y times.
    *
    *   S     Store      Store the current Mesh in the Activated area of the EEPROM. It will also store the
    *                    current state of the Unified Bed Leveling system in the EEPROM.
    *
    *   S #   Store      Store the current Mesh at the specified location in EEPROM. Activate this location
    *                    for subsequent Load and Store operations. Valid storage slot numbers begin at 0 and
    *                    extend to a limit related to the available EEPROM storage.
    *
-   *   S -1  Store      Store the current Mesh as a print out that is suitable to be feed back into the system
-   *                    at a later date. The GCode output can be saved and later replayed by the host software
-   *                    to reconstruct the current mesh on another machine.
+   *   S -1  Store      Print the current Mesh as G-code that can be used to restore the mesh anytime.
    *
    *   T     Topology   Display the Mesh Map Topology.
    *                    'T' can be used alone (e.g., G29 T) or in combination with most of the other commands.
    *                    This option works with all Phase commands (e.g., G29 P4 R 5 T X 50 Y100 C -.1 O)
    *                    This parameter can also specify a Map Type. T0 (the default) is user-readable. T1 can
    *                    is suitable to paste into a spreadsheet for a 3D graph of the mesh.
    *
    *   U     Unlevel    Perform a probe of the outer perimeter to assist in physically leveling unlevel beds.
    *                    Only used for G29 P1 T U. This speeds up the probing of the edge of the bed. Useful
    *                    when the entire bed doesn't need to be probed because it will be adjusted.

commit 0945674ba237747756b85b96ffc05ffc7eb63dce
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 15 20:49:14 2018 -0500

    Use H0 by default with UBL_MESH_EDIT_MOVES_Z (#10428)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 1e4bf6d150..c5d575d40d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -203,22 +203,22 @@
    *
    *   P4    Phase 4    Fine tune the Mesh. The Delta Mesh Compensation System assumes the existence of
    *                    an LCD Panel. It is possible to fine tune the mesh without an LCD Panel using
    *                    G42 and M421. See the UBL documentation for further details.
    *
    *                    Phase 4 is meant to be used with G26 Mesh Validation to fine tune the mesh by direct editing
    *                    of Mesh Points. Raise and lower points to fine tune the mesh until it gives consistently reliable
    *                    adhesion.
    *
    *                    P4 moves to the closest Mesh Point (and/or the given X Y), raises the nozzle above the mesh height
-   *                    by the given 'H' offset (or default Z_CLEARANCE_BETWEEN_PROBES), and waits while the controller is
-   *                    used to adjust the nozzle height. On click the displayed height is saved in the mesh.
+   *                    by the given 'H' offset (or default 0), and waits while the controller is used to adjust the nozzle
+   *                    height. On click the displayed height is saved in the mesh.
    *
    *                    Start Phase 4 at a specific location with X and Y. Adjust a specific number of Mesh Points with
    *                    the 'R' (Repeat) parameter. (If 'R' is left out, the whole matrix is assumed.) This command can be
    *                    terminated early (e.g., after editing the area of interest) by pressing and holding the encoder button.
    *
    *                    The general form is G29 P4 [R points] [X position] [Y position]
    *
    *                    The H [offset] parameter is useful if a shim is used to fine-tune the mesh. For a 0.4mm shim the
    *                    command would be G29 P4 H0.4. The nozzle is moved to the shim height, you adjust height to the shim,
    *                    and on click the height minus the shim thickness will be saved in the mesh.
@@ -1344,95 +1344,94 @@
       do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
       LCD_MESSAGEPGM(MSG_EDITING_STOPPED);
       lcd_quick_feedback(true);
     }
 
     void unified_bed_leveling::fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map) {
       if (!parser.seen('R'))    // fine_tune_mesh() is special. If no repetition count flag is specified
         g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 
       #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
-        const bool is_offset = parser.seen('H');
-        const float h_offset = is_offset ? parser.value_linear_units() : Z_CLEARANCE_BETWEEN_PROBES;
-        if (is_offset && !WITHIN(h_offset, 0, 10)) {
+        const float h_offset = parser.seenval('H') ? parser.value_linear_units() : 0;
+        if (!WITHIN(h_offset, 0, 10)) {
           SERIAL_PROTOCOLLNPGM("Offset out of bounds. (0 to 10mm)\n");
           return;
         }
       #endif
 
       mesh_index_pair location;
 
       if (!position_is_reachable(rx, ry)) {
         SERIAL_PROTOCOLLNPGM("(X,Y) outside printable radius.");
         return;
       }
 
       save_ubl_active_state_and_disable();
 
       LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
+      lcd_external_control = true;                                  // Take over control of the LCD encoder
 
-      do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);
+      do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);      // Move to the given XY with probe clearance
+
+      #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
+        do_blocking_move_to_z(h_offset);                            // Move Z to the given 'H' offset
+      #endif
 
       uint16_t not_done[16];
       memset(not_done, 0xFF, sizeof(not_done));
       do {
         location = find_closest_mesh_point_of_type(SET_IN_BITMAP, rx, ry, USE_NOZZLE_AS_REFERENCE, not_done);
 
-        if (location.x_index < 0) break; // stop when we can't find any more reachable points.
+        if (location.x_index < 0) break;                            // Stop when there are no more reachable points
 
-        bitmap_clear(not_done, location.x_index, location.y_index); // Mark this location as 'adjusted' so we will find a
-                                                                    // different location the next time through the loop
+        bitmap_clear(not_done, location.x_index, location.y_index); // Mark this location as 'adjusted' so a new
+                                                                    // location is used on the next loop
 
         const float rawx = mesh_index_to_xpos(location.x_index),
                     rawy = mesh_index_to_ypos(location.y_index);
 
-        if (!position_is_reachable(rawx, rawy)) // SHOULD NOT OCCUR because find_closest_mesh_point_of_type will only return reachable
-          break;
+        //if (!position_is_reachable(rawx, rawy)) break;            // SHOULD NOT OCCUR because find_closest_mesh_point_of_type will only return reachable
 
-        do_blocking_move_to(rawx, rawy, Z_CLEARANCE_BETWEEN_PROBES); // Move the nozzle to the edit point
+        do_blocking_move_to(rawx, rawy, Z_CLEARANCE_BETWEEN_PROBES); // Move the nozzle to the edit point with probe clearance
+
+        #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
+          do_blocking_move_to_z(h_offset);                          // Move Z to the given 'H' offset before editing
+        #endif
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
-        lcd_external_control = true;
 
-        if (do_ubl_mesh_map) display_map(g29_map_type);  // show the user which point is being adjusted
+        if (do_ubl_mesh_map) display_map(g29_map_type);             // Display the current point
 
         lcd_refresh();
 
         float new_z = z_values[location.x_index][location.y_index];
-        if (isnan(new_z)) new_z = 0.0;          // Set invalid mesh points to 0.0 so they can be edited
-        new_z = FLOOR(new_z * 1000.0) * 0.001;  // Chop off digits after the 1000ths place
+        if (isnan(new_z)) new_z = 0.0;                              // Invalid points begin at 0
+        new_z = FLOOR(new_z * 1000.0) * 0.001;                      // Chop off digits after the 1000ths place
 
         lcd_mesh_edit_setup(new_z);
 
         do {
           new_z = lcd_mesh_edit();
           #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
-            do_blocking_move_to_z(h_offset + new_z); // Move the nozzle as the point is edited
+            do_blocking_move_to_z(h_offset + new_z);                // Move the nozzle as the point is edited
           #endif
           idle();
-          SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
+          SERIAL_FLUSH();                                           // Prevent host M105 buffer overrun.
         } while (!is_lcd_clicked());
 
-        if (!lcd_map_control) lcd_return_to_status();
-
-        // The technique used here generates a race condition for the encoder click.
-        // It could get detected in lcd_mesh_edit (actually _lcd_mesh_fine_tune) or here.
-        // Let's work on specifying a proper API for the LCD ASAP, OK?
-        lcd_external_control = true;
-
-        if (click_and_hold(abort_fine_tune))
-          goto FINE_TUNE_EXIT;
+        if (!lcd_map_control) lcd_return_to_status();               // Just editing a single point? Return to status
 
-        safe_delay(20);                       // We don't want any switch noise.
+        if (click_and_hold(abort_fine_tune)) goto FINE_TUNE_EXIT;   // If the click is held down, abort editing
 
-        z_values[location.x_index][location.y_index] = new_z;
+        z_values[location.x_index][location.y_index] = new_z;       // Save the updated Z value
 
+        safe_delay(20);                                             // No switch noise
         lcd_refresh();
 
       } while (location.x_index >= 0 && --g29_repetition_cnt > 0);
 
       FINE_TUNE_EXIT:
 
       lcd_external_control = false;
       KEEPALIVE_STATE(IN_HANDLER);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);

commit 21f13f9e57b0a4db44f742e591ac679505cd417e
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Fri Apr 13 14:46:47 2018 -0500

    Stow Probe at end of G29 J3

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index ceefbb1569..1e4bf6d150 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1603,28 +1603,31 @@
 
               measured_z -= get_z_correction(rx, ry) /* + zprobe_zoffset */ ;
 
               #if ENABLED(DEBUG_LEVELING_FEATURE)
                 if (DEBUGGING(LEVELING)) {
                   SERIAL_ECHOPGM("   final >>>---> ");
                   SERIAL_PROTOCOL_F(measured_z, 7);
                   SERIAL_EOL();
                 }
               #endif
-
+              if (g29_verbose_level > 3) {
+                serial_spaces(16);
+                SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
+              }
               incremental_LSF(&lsf_results, rx, ry, measured_z);
             }
           }
 
           zig_zag ^= true;
         }
-
+        STOW_PROBE();
       }
 
       if (abort_flag || finish_incremental_LSF(&lsf_results)) {
         SERIAL_ECHOPGM("Could not complete LSF!");
         return;
       }
 
       vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1.0000).get_normal();
 
       if (g29_verbose_level > 2) {

commit 1cb810ff1c04065daa29182a6c22ecf6b0c0098b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 21 19:30:06 2018 -0500

    [2.0.x] Automatically reset stepper timeout (#10179)
    
    * Automatically reset stepper timeout in manage_inactivity
    
    Any code that adds moves to the planner can skip resetting the stepper timeout. We can let `idle` / `manage_inactivity` reset the timer whenever it detects any moves in the planner.
    
    * blocks_queued => has_blocks_queued

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 686487f922..ceefbb1569 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -772,21 +772,21 @@
 
 
   #endif // HAS_BED_PROBE
 
   #if ENABLED(NEWPANEL)
 
     void unified_bed_leveling::move_z_with_encoder(const float &multiplier) {
       wait_for_release();
       while (!is_lcd_clicked()) {
         idle();
-        gcode.refresh_cmd_timeout();
+        gcode.reset_stepper_timeout(); // Keep steppers powered
         if (encoder_diff) {
           do_blocking_move_to_z(current_position[Z_AXIS] + float(encoder_diff) * multiplier);
           encoder_diff = 0;
         }
       }
     }
 
     float unified_bed_leveling::measure_point_with_encoder() {
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       move_z_with_encoder(0.01);

commit c3c264978f6846c57c3a0da251f914dccda80b39
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Wed Mar 21 16:54:45 2018 -0500

    correct truncated comment

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 7c398dcb73..686487f922 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -592,22 +592,22 @@
       SERIAL_PROTOCOLLNPGM("Done.");
     }
 
     //
     // Store a Mesh in the EEPROM
     //
 
     if (parser.seen('S')) {     // Store (or Save) Current Mesh Data
       g29_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
 
-      if (g29_storage_slot == -1)                     // Special case, we are going to 'Export' the mesh to the
-        return report_current_mesh();
+      if (g29_storage_slot == -1)                     // Special case, the user wants to 'Export' the mesh to the
+        return report_current_mesh();                 // host program to be saved on the user's computer
 
       int16_t a = settings.calc_num_meshes();
 
       if (!a) {
         SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
         goto LEAVE;
       }
 
       if (!WITHIN(g29_storage_slot, 0, a - 1)) {
         SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");

commit bc45fb6b131598403c8fdc5089697d98dc878299
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 21 01:08:44 2018 -0500

    Tweak use of move_z_after_probing

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index b6b9486bee..7c398dcb73 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -750,21 +750,24 @@
           const float rawx = mesh_index_to_xpos(location.x_index),
                       rawy = mesh_index_to_ypos(location.y_index);
 
           const float measured_z = probe_pt(rawx, rawy, stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
           z_values[location.x_index][location.y_index] = measured_z;
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.x_index >= 0 && --count);
 
       STOW_PROBE();
-      move_z_after_probing();
+
+      #if Z_AFTER_PROBING
+        move_z_after_probing();
+      #endif
 
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
         constrain(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_X, MESH_MAX_X),
         constrain(ry - (Y_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 
 

commit c352954882bc931377ece338b3f5fa459c55ea07
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 21 01:01:43 2018 -0500

    Allow no raise after run_z_probe in probe_pt

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 438a2b25dc..b6b9486bee 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -743,21 +743,21 @@
 
         if (do_furthest)
           location = find_furthest_invalid_mesh_point();
         else
           location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, NULL);
 
         if (location.x_index >= 0) {    // mesh point found and is reachable by probe
           const float rawx = mesh_index_to_xpos(location.x_index),
                       rawy = mesh_index_to_ypos(location.y_index);
 
-          const float measured_z = probe_pt(rawx, rawy, stow_probe, g29_verbose_level); // TODO: Needs error handling
+          const float measured_z = probe_pt(rawx, rawy, stow_probe ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
           z_values[location.x_index][location.y_index] = measured_z;
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.x_index >= 0 && --count);
 
       STOW_PROBE();
       move_z_after_probing();
 
       restore_ubl_active_state_and_leave();
 
@@ -1512,50 +1512,50 @@
       const float dx = float(x_max - x_min) / (g29_grid_size - 1.0),
                   dy = float(y_max - y_min) / (g29_grid_size - 1.0);
 
       struct linear_fit_data lsf_results;
 
       //float z1, z2, z3;  // Needed for algorithm validation down below.
 
       incremental_LSF_reset(&lsf_results);
 
       if (do_3_pt_leveling) {
-        measured_z = probe_pt(PROBE_PT_1_X, PROBE_PT_1_Y, false, g29_verbose_level);
+        measured_z = probe_pt(PROBE_PT_1_X, PROBE_PT_1_Y, PROBE_PT_RAISE, g29_verbose_level);
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(PROBE_PT_1_X, PROBE_PT_1_Y);
           //z1 = measured_z;
           if (g29_verbose_level > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, PROBE_PT_1_X, PROBE_PT_1_Y, measured_z);
         }
 
         if (!abort_flag) {
-          measured_z = probe_pt(PROBE_PT_2_X, PROBE_PT_2_Y, false, g29_verbose_level);
+          measured_z = probe_pt(PROBE_PT_2_X, PROBE_PT_2_Y, PROBE_PT_RAISE, g29_verbose_level);
           //z2 = measured_z;
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(PROBE_PT_2_X, PROBE_PT_2_Y);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, PROBE_PT_2_X, PROBE_PT_2_Y, measured_z);
           }
         }
 
         if (!abort_flag) {
-          measured_z = probe_pt(PROBE_PT_3_X, PROBE_PT_3_Y, true, g29_verbose_level);
+          measured_z = probe_pt(PROBE_PT_3_X, PROBE_PT_3_Y, PROBE_PT_STOW, g29_verbose_level);
           //z3 = measured_z;
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(PROBE_PT_3_X, PROBE_PT_3_Y);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, PROBE_PT_3_X, PROBE_PT_3_Y, measured_z);
@@ -1569,21 +1569,21 @@
       }
       else { // !do_3_pt_leveling
 
         bool zig_zag = false;
         for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
           const float rx = float(x_min) + ix * dx;
           for (int8_t iy = 0; iy < g29_grid_size; iy++) {
             const float ry = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
 
             if (!abort_flag) {
-              measured_z = probe_pt(rx, ry, parser.seen('E'), g29_verbose_level); // TODO: Needs error handling
+              measured_z = probe_pt(rx, ry, parser.seen('E') ? PROBE_PT_STOW : PROBE_PT_RAISE, g29_verbose_level); // TODO: Needs error handling
 
               abort_flag = isnan(measured_z);
 
               #if ENABLED(DEBUG_LEVELING_FEATURE)
                 if (DEBUGGING(LEVELING)) {
                   SERIAL_CHAR('(');
                   SERIAL_PROTOCOL_F(rx, 7);
                   SERIAL_CHAR(',');
                   SERIAL_PROTOCOL_F(ry, 7);
                   SERIAL_ECHOPGM(")   logical: ");

commit dd2949922bfbfec08c3f77714325cb88b7df61de
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 19 01:22:21 2018 -0500

    Consolidate 3-point leveling point options

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 1d8d73782a..438a2b25dc 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1512,60 +1512,60 @@
       const float dx = float(x_max - x_min) / (g29_grid_size - 1.0),
                   dy = float(y_max - y_min) / (g29_grid_size - 1.0);
 
       struct linear_fit_data lsf_results;
 
       //float z1, z2, z3;  // Needed for algorithm validation down below.
 
       incremental_LSF_reset(&lsf_results);
 
       if (do_3_pt_leveling) {
-        measured_z = probe_pt(UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y, false, g29_verbose_level);
+        measured_z = probe_pt(PROBE_PT_1_X, PROBE_PT_1_Y, false, g29_verbose_level);
         if (isnan(measured_z))
           abort_flag = true;
         else {
-          measured_z -= get_z_correction(UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y);
+          measured_z -= get_z_correction(PROBE_PT_1_X, PROBE_PT_1_Y);
           //z1 = measured_z;
           if (g29_verbose_level > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
-          incremental_LSF(&lsf_results, UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y, measured_z);
+          incremental_LSF(&lsf_results, PROBE_PT_1_X, PROBE_PT_1_Y, measured_z);
         }
 
         if (!abort_flag) {
-          measured_z = probe_pt(UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y, false, g29_verbose_level);
+          measured_z = probe_pt(PROBE_PT_2_X, PROBE_PT_2_Y, false, g29_verbose_level);
           //z2 = measured_z;
           if (isnan(measured_z))
             abort_flag = true;
           else {
-            measured_z -= get_z_correction(UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y);
+            measured_z -= get_z_correction(PROBE_PT_2_X, PROBE_PT_2_Y);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
-            incremental_LSF(&lsf_results, UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y, measured_z);
+            incremental_LSF(&lsf_results, PROBE_PT_2_X, PROBE_PT_2_Y, measured_z);
           }
         }
 
         if (!abort_flag) {
-          measured_z = probe_pt(UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y, true, g29_verbose_level);
+          measured_z = probe_pt(PROBE_PT_3_X, PROBE_PT_3_Y, true, g29_verbose_level);
           //z3 = measured_z;
           if (isnan(measured_z))
             abort_flag = true;
           else {
-            measured_z -= get_z_correction(UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y);
+            measured_z -= get_z_correction(PROBE_PT_3_X, PROBE_PT_3_Y);
             if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
-            incremental_LSF(&lsf_results, UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y, measured_z);
+            incremental_LSF(&lsf_results, PROBE_PT_3_X, PROBE_PT_3_Y, measured_z);
           }
         }
 
         if (abort_flag) {
           SERIAL_ECHOPGM("?Error probing point.  Aborting operation.\n");
           return;
         }
       }
       else { // !do_3_pt_leveling
 
@@ -1698,43 +1698,43 @@
           /**
            * The following code can be used to check the validity of the mesh tilting algorithm.
            * When a 3-Point Mesh Tilt is done, the same algorithm is used as the grid based tilting.
            * The only difference is just 3 points are used in the calculations.   That fact guarantees
            * each probed point should have an exact match when a get_z_correction() for that location
            * is calculated.  The Z error between the probed point locations and the get_z_correction()
            * numbers for those locations should be 0.000
            */
           #if 0
           float t, t1, d;
-          t = normal.x * (UBL_PROBE_PT_1_X) + normal.y * (UBL_PROBE_PT_1_Y);
+          t = normal.x * (PROBE_PT_1_X) + normal.y * (PROBE_PT_1_Y);
           d = t + normal.z * z1;
           SERIAL_ECHOPGM("D from 1st point: ");
           SERIAL_ECHO_F(d, 6);
           SERIAL_ECHOPGM("   Z error: ");
-          SERIAL_ECHO_F(normal.z*z1-get_z_correction(UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y), 6);
+          SERIAL_ECHO_F(normal.z*z1-get_z_correction(PROBE_PT_1_X, PROBE_PT_1_Y), 6);
           SERIAL_EOL();
 
-          t = normal.x * (UBL_PROBE_PT_2_X) + normal.y * (UBL_PROBE_PT_2_Y);
+          t = normal.x * (PROBE_PT_2_X) + normal.y * (PROBE_PT_2_Y);
           d = t + normal.z * z2;
           SERIAL_EOL();
           SERIAL_ECHOPGM("D from 2nd point: ");
           SERIAL_ECHO_F(d, 6);
           SERIAL_ECHOPGM("   Z error: ");
-          SERIAL_ECHO_F(normal.z*z2-get_z_correction(UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y), 6);
+          SERIAL_ECHO_F(normal.z*z2-get_z_correction(PROBE_PT_2_X, PROBE_PT_2_Y), 6);
           SERIAL_EOL();
 
-          t = normal.x * (UBL_PROBE_PT_3_X) + normal.y * (UBL_PROBE_PT_3_Y);
+          t = normal.x * (PROBE_PT_3_X) + normal.y * (PROBE_PT_3_Y);
           d = t + normal.z * z3;
           SERIAL_ECHOPGM("D from 3rd point: ");
           SERIAL_ECHO_F(d, 6);
           SERIAL_ECHOPGM("   Z error: ");
-          SERIAL_ECHO_F(normal.z*z3-get_z_correction(UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y), 6);
+          SERIAL_ECHO_F(normal.z*z3-get_z_correction(PROBE_PT_3_X, PROBE_PT_3_Y), 6);
           SERIAL_EOL();
 
           t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
           d = t + normal.z * 0.000;
           SERIAL_ECHOPGM("D from home location with Z=0 : ");
           SERIAL_ECHO_F(d, 6);
           SERIAL_EOL();
 
           t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
           d = t + get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT); // normal.z * 0.000;

commit 1d22609473db1dc2ff9bf290a0741cc38ff8a728
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 19 01:18:57 2018 -0500

    MIN_PROBE_EDGE replaces DELTA_PROBEABLE_RADIUS

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index e1f8816b96..1d8d73782a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -139,24 +139,22 @@
    *   The P or Phase commands are used for the bulk of the work to setup a Mesh. In general, your Mesh will
    *   start off being initialized with a G29 P0 or a G29 P1. Further refinement of the Mesh happens with
    *   each additional Phase that processes it.
    *
    *   P0    Phase 0    Zero Mesh Data and turn off the Mesh Compensation System. This reverts the
    *                    3D Printer to the same state it was in before the Unified Bed Leveling Compensation
    *                    was turned on. Setting the entire Mesh to Zero is a special case that allows
    *                    a subsequent G or T leveling operation for backward compatibility.
    *
    *   P1    Phase 1    Invalidate entire Mesh and continue with automatic generation of the Mesh data using
-   *                    the Z-Probe. Usually the probe can't reach all areas that the nozzle can reach. On
-   *                    Cartesian printers, points within the X_PROBE_OFFSET_FROM_EXTRUDER and Y_PROBE_OFFSET_FROM_EXTRUDER
-   *                    area cannot be automatically probed. For Delta printers the area in which DELTA_PROBEABLE_RADIUS
-   *                    and DELTA_PRINTABLE_RADIUS do not overlap will not be automatically probed.
+   *                    the Z-Probe. Usually the probe can't reach all areas that the nozzle can reach. For delta
+   *                    printers only the areas where the probe and nozzle can both reach will be automatically probed.
    *
    *                    Unreachable points will be handled in Phase 2 and Phase 3.
    *
    *                    Use 'C' to leave the previous mesh intact and automatically probe needed points. This allows you
    *                    to invalidate parts of the Mesh but still use Automatic Probing.
    *
    *                    The 'X' and 'Y' parameters prioritize where to try and measure points. If omitted, the current
    *                    probe position is used.
    *
    *                    Use 'T' (Topology) to generate a report of mesh generation.

commit c0d694d5d3bf4c7ccb19b9d63368e63b28bbc30f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 18 18:56:09 2018 -0500

    Squash UBL postscript comment

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index ad9aa9aedd..e1f8816b96 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -274,40 +274,36 @@
    *
    *   X #              X Location for this command
    *
    *   Y #              Y Location for this command
    *
    *
    *   Release Notes:
    *   You MUST do M502, M500 to initialize the storage. Failure to do this will cause all
    *   kinds of problems. Enabling EEPROM Storage is required.
    *
-   *   When you do a G28 and then a G29 P1 to automatically build your first mesh, you are going to notice
-   *   the Unified Bed Leveling probes points further and further away from the starting location. (The
-   *   starting location defaults to the center of the bed.)   The original Grid and Mesh leveling used
-   *   a Zig Zag pattern. The new pattern is better, especially for people with Delta printers. This
-   *   allows you to get the center area of the Mesh populated (and edited) quicker. This allows you to
-   *   perform a small print and check out your settings quicker. You do not need to populate the
-   *   entire mesh to use it. (You don't want to spend a lot of time generating a mesh only to realize
-   *   you don't have the resolution or zprobe_zoffset set correctly. The Mesh generation
-   *   gathers points closest to where the nozzle is located unless you specify an (X,Y) coordinate pair.
+   *   When you do a G28 and G29 P1 to automatically build your first mesh, you are going to notice that
+   *   UBL probes points increasingly further from the starting location. (The starting location defaults
+   *   to the center of the bed.) In contrast, ABL and MBL follow a zigzag pattern. The spiral pattern is
+   *   especially better for Delta printers, since it populates the center of the mesh first, allowing for
+   *   a quicker test print to verify settings. You don't need to populate the entire mesh to use it.
+   *   After all, you don't want to spend a lot of time generating a mesh only to realize the resolution
+   *   or zprobe_zoffset are incorrect. Mesh-generation gathers points starting closest to the nozzle unless
+   *   an (X,Y) coordinate pair is given.
    *
-   *   The Unified Bed Leveling uses a lot of EEPROM storage to hold its data. And it takes some effort
-   *   to get this Mesh data correct for a user's printer. We do not want this data destroyed as
-   *   new versions of Marlin add or subtract to the items stored in EEPROM. So, for the benefit of
-   *   the users, we store the Mesh data at the end of the EEPROM and do not keep it contiguous with the
-   *   other data stored in the EEPROM. (For sure the developers are going to complain about this, but
-   *   this is going to be helpful to the users!)
+   *   Unified Bed Leveling uses a lot of EEPROM storage to hold its data, and it takes some effort to get
+   *   the mesh just right. To prevent this valuable data from being destroyed as the EEPROM structure
+   *   evolves, UBL stores all mesh data at the end of EEPROM.
    *
-   *   The foundation of this Bed Leveling System is built on Epatel's Mesh Bed Leveling code. A big
-   *   'Thanks!' to him and the creators of 3-Point and Grid Based leveling. Combining their contributions
-   *   we now have the functionality and features of all three systems combined.
+   *   UBL is founded on Edward Patel's Mesh Bed Leveling code. A big 'Thanks!' to him and the creators of
+   *   3-Point and Grid Based leveling. Combining their contributions we now have the functionality and
+   *   features of all three systems combined.
    */
 
   void unified_bed_leveling::G29() {
 
     if (g29_parameter_parsing()) return; // abort if parsing the simple parameters causes a problem,
 
     // Check for commands that require the printer to be homed
     if (axis_unhomed_error()) {
       const int8_t p_val = parser.intval('P', -1);
       if (p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J'))

commit 28f1276286da94f4a1b3a7bffa103a35a3ee8352
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 11 13:07:55 2018 -0500

    [2.0.x] Add Z_AFTER_PROBING option (#10058)
    
    Some "fix-mounted" probes need manual stowing. And after probing some may prefer to raise or lower the nozzle. This restores an old option but tailors it to allow raise or lower as preferred.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 0c7f640869..ad9aa9aedd 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -384,20 +384,21 @@
           tilt_mesh_based_on_probed_grid(false /* false says to do normal grid probing */ );
           restore_ubl_active_state_and_leave();
         }
         else { // grid_size == 0 : A 3-Point leveling has been requested
 
           save_ubl_active_state_and_disable();
           tilt_mesh_based_on_probed_grid(true /* true says to do 3-Point leveling */ );
           restore_ubl_active_state_and_leave();
         }
         do_blocking_move_to_xy(0.5 * (MESH_MAX_X - (MESH_MIN_X)), 0.5 * (MESH_MAX_Y - (MESH_MIN_Y)));
+        report_current_position();
       }
 
     #endif // HAS_BED_PROBE
 
     if (parser.seen('P')) {
       if (WITHIN(g29_phase_value, 0, 1) && storage_slot == -1) {
         storage_slot = 0;
         SERIAL_PROTOCOLLNPGM("Default storage slot 0 selected.");
       }
 
@@ -421,20 +422,22 @@
               SERIAL_PROTOCOLLNPGM("Mesh invalidated. Probing mesh.");
             }
             if (g29_verbose_level > 1) {
               SERIAL_PROTOCOLPAIR("Probing Mesh Points Closest to (", g29_x_pos);
               SERIAL_PROTOCOLCHAR(',');
               SERIAL_PROTOCOL(g29_y_pos);
               SERIAL_PROTOCOLLNPGM(").\n");
             }
             probe_entire_mesh(g29_x_pos + X_PROBE_OFFSET_FROM_EXTRUDER, g29_y_pos + Y_PROBE_OFFSET_FROM_EXTRUDER,
                               parser.seen('T'), parser.seen('E'), parser.seen('U'));
+
+            report_current_position();
             break;
 
         #endif // HAS_BED_PROBE
 
         case 2: {
           #if ENABLED(NEWPANEL)
             //
             // Manually Probe Mesh in areas that can't be reached by the probe
             //
             SERIAL_PROTOCOLLNPGM("Manually probing unreachable mesh locations.");
@@ -468,20 +471,22 @@
             if (!position_is_reachable(g29_x_pos, g29_y_pos)) {
               SERIAL_PROTOCOLLNPGM("XY outside printable radius.");
               return;
             }
 
             const float height = parser.floatval('H', Z_CLEARANCE_BETWEEN_PROBES);
             manually_probe_remaining_mesh(g29_x_pos, g29_y_pos, height, g29_card_thickness, parser.seen('T'));
 
             SERIAL_PROTOCOLLNPGM("G29 P2 finished.");
 
+            report_current_position();
+
           #else
 
             SERIAL_PROTOCOLLNPGM("?P2 is only available when an LCD is present.");
             return;
 
           #endif
         } break;
 
         case 3: {
           /**
@@ -751,20 +756,22 @@
           const float rawx = mesh_index_to_xpos(location.x_index),
                       rawy = mesh_index_to_ypos(location.y_index);
 
           const float measured_z = probe_pt(rawx, rawy, stow_probe, g29_verbose_level); // TODO: Needs error handling
           z_values[location.x_index][location.y_index] = measured_z;
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.x_index >= 0 && --count);
 
       STOW_PROBE();
+      move_z_after_probing();
+
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
         constrain(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_X, MESH_MAX_X),
         constrain(ry - (Y_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 
 
   #endif // HAS_BED_PROBE

commit 239902f8615d37a95a8296195fe37c1b35c2e383
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 10 03:02:53 2018 -0600

    Fix E2END and add EEPROM to Smart RAMPS
    
    Reference #9983

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index af99ac08dc..0c7f640869 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1160,27 +1160,27 @@
   /**
    * When we are fully debugged, the EEPROM dump command will get deleted also. But
    * right now, it is good to have the extra information. Soon... we prune this.
    */
   void unified_bed_leveling::g29_eeprom_dump() {
     unsigned char cccc;
     unsigned int  kkkk;  // Needs to be of unspecfied size to compile clean on all platforms
 
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPGM("EEPROM Dump:");
-    for (uint16_t i = 0; i < E2END + 1; i += 16) {
+    for (uint16_t i = 0; i <= E2END; i += 16) {
       if (!(i & 0x3)) idle();
       print_hex_word(i);
       SERIAL_ECHOPGM(": ");
       for (uint16_t j = 0; j < 16; j++) {
         kkkk = i + j;
-        eeprom_read_block(&cccc, (const void *) kkkk, sizeof(unsigned char));
+        eeprom_read_block(&cccc, (const void *)kkkk, sizeof(unsigned char));
         print_hex_byte(cccc);
         SERIAL_ECHO(' ');
       }
       SERIAL_EOL();
     }
     SERIAL_EOL();
   }
 
   /**
    * When we are fully debugged, this may go away. But there are some valid

commit 26dc594ebbb9bc785f864773f9b6850d54da635c
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Fri Mar 9 17:56:00 2018 -0700

    prevent steppers from turning off during manual probes

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index e65e6c0b33..af99ac08dc 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -768,20 +768,21 @@
 
 
   #endif // HAS_BED_PROBE
 
   #if ENABLED(NEWPANEL)
 
     void unified_bed_leveling::move_z_with_encoder(const float &multiplier) {
       wait_for_release();
       while (!is_lcd_clicked()) {
         idle();
+        gcode.refresh_cmd_timeout();
         if (encoder_diff) {
           do_blocking_move_to_z(current_position[Z_AXIS] + float(encoder_diff) * multiplier);
           encoder_diff = 0;
         }
       }
     }
 
     float unified_bed_leveling::measure_point_with_encoder() {
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       move_z_with_encoder(0.01);

commit ca577c16380009abd0e64770ee6c7c1e44b937c8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 7 20:30:19 2018 -0600

    Fix up various spacing, comments, and typos

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index fc1144be7b..e65e6c0b33 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -506,21 +506,21 @@
                       if (isnan(z_values[x][y]))
                         z_values[x][y] = g29_constant;
                   break; // No more invalid Mesh Points to populate
                 }
                 z_values[location.x_index][location.y_index] = g29_constant;
               }
             }
           }
           else {
             const float cvf = parser.value_float();
-            switch((int)truncf(cvf * 10.0) - 30) {   // 3.1 -> 1
+            switch ((int)truncf(cvf * 10.0) - 30) {   // 3.1 -> 1
               #if ENABLED(UBL_G29_P31)
                 case 1: {
 
                   // P3.1  use least squares fit to fill missing mesh values
                   // P3.10 zero weighting for distance, all grid points equal, best fit tilted plane
                   // P3.11 10X weighting for nearest grid points versus farthest grid points
                   // P3.12 100X distance weighting
                   // P3.13 1000X distance weighting, approaches simple average of nearest points
 
                   const float weight_power  = (cvf - 3.10) * 100.0,  // 3.12345 -> 2.345

commit 24b9c1923f2c0720fd98a626f95420416a23fdeb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 26 20:45:51 2018 -0600

    ubl G29 tweaks

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index fe2fa14ad6..fc1144be7b 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -706,63 +706,63 @@
       return false;
     }
 
   #endif // NEWPANEL
 
   #if HAS_BED_PROBE
     /**
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
-    void unified_bed_leveling::probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, bool close_or_far) {
+    void unified_bed_leveling::probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) {
       mesh_index_pair location;
 
       #if ENABLED(NEWPANEL)
         lcd_external_control = true;
       #endif
 
       save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
       DEPLOY_PROBE();
 
-      uint16_t max_iterations = GRID_MAX_POINTS;
+      uint16_t count = GRID_MAX_POINTS;
 
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
         #if ENABLED(NEWPANEL)
           if (is_lcd_clicked()) {
             SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.\n");
             lcd_quick_feedback(false);
             STOW_PROBE();
             while (is_lcd_clicked()) idle();
             lcd_external_control = false;
             restore_ubl_active_state_and_leave();
             lcd_quick_feedback(true);
             safe_delay(50);  // Debounce the Encoder wheel
             return;
           }
         #endif
 
-        if (close_or_far)
+        if (do_furthest)
           location = find_furthest_invalid_mesh_point();
         else
           location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, NULL);
 
         if (location.x_index >= 0) {    // mesh point found and is reachable by probe
           const float rawx = mesh_index_to_xpos(location.x_index),
                       rawy = mesh_index_to_ypos(location.y_index);
 
           const float measured_z = probe_pt(rawx, rawy, stow_probe, g29_verbose_level); // TODO: Needs error handling
           z_values[location.x_index][location.y_index] = measured_z;
         }
         SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
-      } while (location.x_index >= 0 && --max_iterations);
+      } while (location.x_index >= 0 && --count);
 
       STOW_PROBE();
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
         constrain(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_X, MESH_MAX_X),
         constrain(ry - (Y_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 

commit 7bdb98c94697d096070b158dabb4582d9e9fb57e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 26 15:02:19 2018 -0600

    Fix #9826. Solution by @gloomyandy

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index f11d060778..fe2fa14ad6 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1661,21 +1661,21 @@
               SERIAL_PROTOCOL_F(x_tmp, 7);
               SERIAL_PROTOCOLCHAR(',');
               SERIAL_PROTOCOL_F(y_tmp, 7);
               SERIAL_PROTOCOLCHAR(',');
               SERIAL_PROTOCOL_F(z_tmp, 7);
               SERIAL_ECHOLNPGM("]");
               safe_delay(55);
             }
           #endif
 
-          z_values[i][j] += z_tmp - lsf_results.D;
+          z_values[i][j] = z_tmp - lsf_results.D;
         }
       }
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
           rotation.debug(PSTR("rotation matrix:\n"));
           SERIAL_ECHOPGM("LSF Results A=");
           SERIAL_PROTOCOL_F(lsf_results.A, 7);
           SERIAL_ECHOPGM("  B=");
           SERIAL_PROTOCOL_F(lsf_results.B, 7);

commit 966d9af98acdb43cca9f15de7f258565270b9704
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 25 08:07:48 2018 -0600

    Mesh export in Bilinear + UBL M503

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index c9524b07a6..f11d060778 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -593,35 +593,22 @@
       SERIAL_PROTOCOLLNPGM("Done.");
     }
 
     //
     // Store a Mesh in the EEPROM
     //
 
     if (parser.seen('S')) {     // Store (or Save) Current Mesh Data
       g29_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
 
-      if (g29_storage_slot == -1) {                     // Special case, we are going to 'Export' the mesh to the
-        SERIAL_ECHOLNPGM("G29 I 999");              // host in a form it can be reconstructed on a different machine
-        for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
-          for (uint8_t y = 0;  y < GRID_MAX_POINTS_Y; y++)
-            if (!isnan(z_values[x][y])) {
-              SERIAL_ECHOPAIR("M421 I ", x);
-              SERIAL_ECHOPAIR(" J ", y);
-              SERIAL_ECHOPGM(" Z ");
-              SERIAL_ECHO_F(z_values[x][y], 6);
-              SERIAL_ECHOPAIR(" ; X ", LOGICAL_X_POSITION(mesh_index_to_xpos(x)));
-              SERIAL_ECHOPAIR(", Y ", LOGICAL_Y_POSITION(mesh_index_to_ypos(y)));
-              SERIAL_EOL();
-            }
-        return;
-      }
+      if (g29_storage_slot == -1)                     // Special case, we are going to 'Export' the mesh to the
+        return report_current_mesh();
 
       int16_t a = settings.calc_num_meshes();
 
       if (!a) {
         SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
         goto LEAVE;
       }
 
       if (!WITHIN(g29_storage_slot, 0, a - 1)) {
         SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");

commit 241e55ef3b555ff46408cae329a037def27964eb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Feb 16 17:32:12 2018 -0600

    Apply SERIAL_FLUSH macro

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 30ed82c1c1..c9524b07a6 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -760,21 +760,21 @@
         else
           location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, NULL);
 
         if (location.x_index >= 0) {    // mesh point found and is reachable by probe
           const float rawx = mesh_index_to_xpos(location.x_index),
                       rawy = mesh_index_to_ypos(location.y_index);
 
           const float measured_z = probe_pt(rawx, rawy, stow_probe, g29_verbose_level); // TODO: Needs error handling
           z_values[location.x_index][location.y_index] = measured_z;
         }
-        MYSERIAL0.flush(); // Prevent host M105 buffer overrun.
+        SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.x_index >= 0 && --max_iterations);
 
       STOW_PROBE();
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
         constrain(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_X, MESH_MAX_X),
         constrain(ry - (Y_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_Y, MESH_MAX_Y)
       );
     }
@@ -898,21 +898,21 @@
           restore_ubl_active_state_and_leave();
           return;
         }
 
         z_values[location.x_index][location.y_index] = current_position[Z_AXIS] - thick;
         if (g29_verbose_level > 2) {
           SERIAL_PROTOCOLPGM("Mesh Point Measured at: ");
           SERIAL_PROTOCOL_F(z_values[location.x_index][location.y_index], 6);
           SERIAL_EOL();
         }
-        MYSERIAL0.flush(); // Prevent host M105 buffer overrun.
+        SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
       } while (location.x_index >= 0 && location.y_index >= 0);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
       restore_ubl_active_state_and_leave();
       KEEPALIVE_STATE(IN_HANDLER);
       do_blocking_move_to(rx, ry, Z_CLEARANCE_DEPLOY_PROBE);
     }
   #endif // NEWPANEL
 
@@ -1410,21 +1410,21 @@
         new_z = FLOOR(new_z * 1000.0) * 0.001;  // Chop off digits after the 1000ths place
 
         lcd_mesh_edit_setup(new_z);
 
         do {
           new_z = lcd_mesh_edit();
           #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
             do_blocking_move_to_z(h_offset + new_z); // Move the nozzle as the point is edited
           #endif
           idle();
-          MYSERIAL0.flush(); // Prevent host M105 buffer overrun.
+          SERIAL_FLUSH(); // Prevent host M105 buffer overrun.
         } while (!is_lcd_clicked());
 
         if (!lcd_map_control) lcd_return_to_status();
 
         // The technique used here generates a race condition for the encoder click.
         // It could get detected in lcd_mesh_edit (actually _lcd_mesh_fine_tune) or here.
         // Let's work on specifying a proper API for the LCD ASAP, OK?
         lcd_external_control = true;
 
         if (click_and_hold(abort_fine_tune))

commit 8d71ad37cb4934c29d38304133c7315d6339df2d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 14 02:55:57 2018 -0600

    flush comment to match 1.1.x

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index d0a8999123..30ed82c1c1 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -760,24 +760,21 @@
         else
           location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, NULL);
 
         if (location.x_index >= 0) {    // mesh point found and is reachable by probe
           const float rawx = mesh_index_to_xpos(location.x_index),
                       rawy = mesh_index_to_ypos(location.y_index);
 
           const float measured_z = probe_pt(rawx, rawy, stow_probe, g29_verbose_level); // TODO: Needs error handling
           z_values[location.x_index][location.y_index] = measured_z;
         }
-        MYSERIAL0.flush(); // G29 P2's take a long time to complete.   PronterFace can
-                           // over run the serial character buffer with M105's without
-                           // this fix
-
+        MYSERIAL0.flush(); // Prevent host M105 buffer overrun.
       } while (location.x_index >= 0 && --max_iterations);
 
       STOW_PROBE();
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
         constrain(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_X, MESH_MAX_X),
         constrain(ry - (Y_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_Y, MESH_MAX_Y)
       );
     }
@@ -901,23 +898,21 @@
           restore_ubl_active_state_and_leave();
           return;
         }
 
         z_values[location.x_index][location.y_index] = current_position[Z_AXIS] - thick;
         if (g29_verbose_level > 2) {
           SERIAL_PROTOCOLPGM("Mesh Point Measured at: ");
           SERIAL_PROTOCOL_F(z_values[location.x_index][location.y_index], 6);
           SERIAL_EOL();
         }
-        MYSERIAL0.flush(); // G29 P2's take a long time to complete.   PronterFace can
-                           // over run the serial character buffer with M105's without
-                           // this fix
+        MYSERIAL0.flush(); // Prevent host M105 buffer overrun.
       } while (location.x_index >= 0 && location.y_index >= 0);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
       restore_ubl_active_state_and_leave();
       KEEPALIVE_STATE(IN_HANDLER);
       do_blocking_move_to(rx, ry, Z_CLEARANCE_DEPLOY_PROBE);
     }
   #endif // NEWPANEL
 
@@ -1415,23 +1410,21 @@
         new_z = FLOOR(new_z * 1000.0) * 0.001;  // Chop off digits after the 1000ths place
 
         lcd_mesh_edit_setup(new_z);
 
         do {
           new_z = lcd_mesh_edit();
           #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
             do_blocking_move_to_z(h_offset + new_z); // Move the nozzle as the point is edited
           #endif
           idle();
-          MYSERIAL0.flush(); // G29 P2's take a long time to complete.   PronterFace can
-                             // over run the serial character buffer with M105's without
-                             // this fix
+          MYSERIAL0.flush(); // Prevent host M105 buffer overrun.
         } while (!is_lcd_clicked());
 
         if (!lcd_map_control) lcd_return_to_status();
 
         // The technique used here generates a race condition for the encoder click.
         // It could get detected in lcd_mesh_edit (actually _lcd_mesh_fine_tune) or here.
         // Let's work on specifying a proper API for the LCD ASAP, OK?
         lcd_external_control = true;
 
         if (click_and_hold(abort_fine_tune))

commit 89165326b4bc627ee080cd2acd073c0097d80ddd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 11 05:43:03 2018 -0600

    Cleanup after vim and vigor

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index d66b2e7223..d0a8999123 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -44,21 +44,21 @@
 #include "../../../feature/Max7219_Debug_LEDs.h"
 
   #include <math.h>
 
   #define UBL_G29_P31
 
   extern float destination[XYZE], current_position[XYZE];
 
   #if ENABLED(NEWPANEL)
     void lcd_return_to_status();
-    extern void _lcd_ubl_output_map_lcd();
+    void _lcd_ubl_output_map_lcd();
   #endif
 
   extern float meshedit_done;
   extern long babysteps_done;
 
   #define SIZE_OF_LITTLE_RAISE 1
   #define BIG_RAISE_NOT_NEEDED 0
 
   int    unified_bed_leveling::g29_verbose_level,
          unified_bed_leveling::g29_phase_value,
@@ -89,22 +89,22 @@
    *                    In this mode of G29 P2, a business or index card is used as a shim that the nozzle can
    *                    grab onto as it is lowered. In principle, the nozzle-bed distance is the same when the
    *                    same resistance is felt in the shim. You can omit the numerical value on first invocation
    *                    of G29 P2 B to measure shim thickness. Subsequent use of 'B' will apply the previously-
    *                    measured thickness by default.
    *
    *   C     Continue   G29 P1 C continues the generation of a partially-constructed Mesh without invalidating
    *                    previous measurements.
    *
    *   C                G29 P2 C tells the Manual Probe subsystem to not use the current nozzle
-   *                    location in its search for the closest unmeasured Mesh Point.  Instead, attempt to
-   *                    start at one end of the uprobed points and Continue sequentually.
+   *                    location in its search for the closest unmeasured Mesh Point. Instead, attempt to
+   *                    start at one end of the uprobed points and Continue sequentially.
    *
    *                    G29 P3 C specifies the Constant for the fill. Otherwise, uses a "reasonable" value.
    *
    *   C     Current    G29 Z C uses the Current location (instead of bed center or nearest edge).
    *
    *   D     Disable    Disable the Unified Bed Leveling system.
    *
    *   E     Stow_probe Stow the probe after each sampled point.
    *
    *   F #   Fade       Fade the amount of Mesh Based Compensation over a specified height. At the
@@ -1031,42 +1031,42 @@
     g29_map_type = parser.intval('T');
     if (!WITHIN(g29_map_type, 0, 2)) {
       SERIAL_PROTOCOLLNPGM("Invalid map type.\n");
       return UBL_ERR;
     }
     return UBL_OK;
   }
 
   static uint8_t ubl_state_at_invocation = 0;
 
-  #if ENABLED(UBL_DEVEL_DEBUGGING)
+  #ifdef UBL_DEVEL_DEBUGGING
     static uint8_t ubl_state_recursion_chk = 0;
   #endif
 
   void unified_bed_leveling::save_ubl_active_state_and_disable() {
-    #if ENABLED(UBL_DEVEL_DEBUGGING)
+    #ifdef UBL_DEVEL_DEBUGGING
       ubl_state_recursion_chk++;
       if (ubl_state_recursion_chk != 1) {
         SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
         #if ENABLED(NEWPANEL)
           LCD_MESSAGEPGM(MSG_UBL_SAVE_ERROR);
           lcd_quick_feedback(true);
         #endif
         return;
       }
     #endif
     ubl_state_at_invocation = planner.leveling_active;
     set_bed_leveling_enabled(false);
   }
 
   void unified_bed_leveling::restore_ubl_active_state_and_leave() {
-    #if ENABLED(UBL_DEVEL_DEBUGGING)
+    #ifdef UBL_DEVEL_DEBUGGING
       if (--ubl_state_recursion_chk) {
         SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
         #if ENABLED(NEWPANEL)
           LCD_MESSAGEPGM(MSG_UBL_RESTORE_ERROR);
           lcd_quick_feedback(true);
         #endif
         return;
       }
     #endif
     set_bed_leveling_enabled(ubl_state_at_invocation);
@@ -1136,21 +1136,21 @@
     }
     SERIAL_EOL();
 
     #if HAS_KILL
       SERIAL_PROTOCOLPAIR("Kill pin on :", KILL_PIN);
       SERIAL_PROTOCOLLNPAIR("  state:", READ(KILL_PIN));
     #endif
     SERIAL_EOL();
     safe_delay(50);
 
-    #if ENABLED(UBL_DEVEL_DEBUGGING)
+    #ifdef UBL_DEVEL_DEBUGGING
       SERIAL_PROTOCOLLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation);
       SERIAL_EOL();
       SERIAL_PROTOCOLLNPAIR("ubl_state_recursion_chk :", ubl_state_recursion_chk);
       SERIAL_EOL();
       safe_delay(50);
 
       SERIAL_PROTOCOLPAIR("Meshes go from ", hex_address((void*)settings.meshes_start_index()));
       SERIAL_PROTOCOLLNPAIR(" to ", hex_address((void*)settings.meshes_end_index()));
       safe_delay(50);
 
@@ -1250,44 +1250,44 @@
         if (isnan(z_values[i][j])) { // Check to see if this location holds an invalid mesh point
 
           const float mx = mesh_index_to_xpos(i),
                       my = mesh_index_to_ypos(j);
 
           if (!position_is_reachable_by_probe(mx, my))  // make sure the probe can get to the mesh point
             continue;
 
           found_a_NAN = true;
 
-          int8_t closest_x=-1, closest_y=-1;
+          int8_t closest_x = -1, closest_y = -1;
           float d1, d2 = 99999.9;
           for (int8_t k = 0; k < GRID_MAX_POINTS_X; k++) {
             for (int8_t l = 0; l < GRID_MAX_POINTS_Y; l++) {
               if (!isnan(z_values[k][l])) {
                 found_a_real = true;
 
-          // Add in a random weighting factor that scrambles the probing of the
-          // last half of the mesh (when every unprobed mesh point is one index
-          // from a probed location).
+                // Add in a random weighting factor that scrambles the probing of the
+                // last half of the mesh (when every unprobed mesh point is one index
+                // from a probed location).
 
                 d1 = HYPOT(i - k, j - l) + (1.0 / ((millis() % 47) + 13));
 
                 if (d1 < d2) {    // found a closer distance from invalid mesh point at (i,j) to defined mesh point at (k,l)
-                  d2 = d1;       // found a closer location with
-                  closest_x = i;    // an assigned mesh point value
+                  d2 = d1;        // found a closer location with
+                  closest_x = i;  // an assigned mesh point value
                   closest_y = j;
                 }
               }
             }
           }
 
           //
-          // at this point d2 should have the closest defined mesh point to invalid mesh point (i,j)
+          // At this point d2 should have the closest defined mesh point to invalid mesh point (i,j)
           //
 
           if (found_a_real && (closest_x >= 0) && (d2 > out_mesh.distance)) {
             out_mesh.distance = d2;         // found an invalid location with a greater distance
             out_mesh.x_index = closest_x;   // to a defined mesh point
             out_mesh.y_index = closest_y;
           }
         }
       } // for j
     } // for i
@@ -1516,138 +1516,137 @@
   }
 
   #if HAS_BED_PROBE
 
     void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
       constexpr int16_t x_min = max(MIN_PROBE_X, MESH_MIN_X),
                         x_max = min(MAX_PROBE_X, MESH_MAX_X),
                         y_min = max(MIN_PROBE_Y, MESH_MIN_Y),
                         y_max = min(MAX_PROBE_Y, MESH_MAX_Y);
 
-      bool abort_flag=false;
+      bool abort_flag = false;
 
       float measured_z;
 
       const float dx = float(x_max - x_min) / (g29_grid_size - 1.0),
                   dy = float(y_max - y_min) / (g29_grid_size - 1.0);
 
       struct linear_fit_data lsf_results;
 
-//    float z1, z2, z3;  // Needed for algorithm validation down below.
+      //float z1, z2, z3;  // Needed for algorithm validation down below.
 
       incremental_LSF_reset(&lsf_results);
 
       if (do_3_pt_leveling) {
         measured_z = probe_pt(UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y, false, g29_verbose_level);
         if (isnan(measured_z))
           abort_flag = true;
         else {
           measured_z -= get_z_correction(UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y);
-//        z1 = measured_z;
-          if (g29_verbose_level>3) {
+          //z1 = measured_z;
+          if (g29_verbose_level > 3) {
             serial_spaces(16);
             SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
           }
           incremental_LSF(&lsf_results, UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y, measured_z);
         }
 
         if (!abort_flag) {
           measured_z = probe_pt(UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y, false, g29_verbose_level);
-//        z2 = measured_z;
+          //z2 = measured_z;
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y);
-            if (g29_verbose_level>3) {
+            if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y, measured_z);
           }
         }
 
         if (!abort_flag) {
           measured_z = probe_pt(UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y, true, g29_verbose_level);
-//        z3 = measured_z;
+          //z3 = measured_z;
           if (isnan(measured_z))
             abort_flag = true;
           else {
             measured_z -= get_z_correction(UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y);
-            if (g29_verbose_level>3) {
+            if (g29_verbose_level > 3) {
               serial_spaces(16);
               SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
             }
             incremental_LSF(&lsf_results, UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y, measured_z);
           }
         }
 
         if (abort_flag) {
           SERIAL_ECHOPGM("?Error probing point.  Aborting operation.\n");
           return;
         }
-      } else {
+      }
+      else { // !do_3_pt_leveling
 
-      bool zig_zag = false;
-      for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
-        const float rx = float(x_min) + ix * dx;
-        for (int8_t iy = 0; iy < g29_grid_size; iy++) {
-          const float ry = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
+        bool zig_zag = false;
+        for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
+          const float rx = float(x_min) + ix * dx;
+          for (int8_t iy = 0; iy < g29_grid_size; iy++) {
+            const float ry = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
 
             if (!abort_flag) {
               measured_z = probe_pt(rx, ry, parser.seen('E'), g29_verbose_level); // TODO: Needs error handling
 
-              if (isnan(measured_z))
-                abort_flag = true;
+              abort_flag = isnan(measured_z);
+
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                if (DEBUGGING(LEVELING)) {
+                  SERIAL_CHAR('(');
+                  SERIAL_PROTOCOL_F(rx, 7);
+                  SERIAL_CHAR(',');
+                  SERIAL_PROTOCOL_F(ry, 7);
+                  SERIAL_ECHOPGM(")   logical: ");
+                  SERIAL_CHAR('(');
+                  SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 7);
+                  SERIAL_CHAR(',');
+                  SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 7);
+                  SERIAL_ECHOPGM(")   measured: ");
+                  SERIAL_PROTOCOL_F(measured_z, 7);
+                  SERIAL_ECHOPGM("   correction: ");
+                  SERIAL_PROTOCOL_F(get_z_correction(rx, ry), 7);
+                }
+              #endif
 
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) {
-              SERIAL_CHAR('(');
-              SERIAL_PROTOCOL_F(rx, 7);
-              SERIAL_CHAR(',');
-              SERIAL_PROTOCOL_F(ry, 7);
-              SERIAL_ECHOPGM(")   logical: ");
-              SERIAL_CHAR('(');
-              SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 7);
-              SERIAL_CHAR(',');
-              SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 7);
-              SERIAL_ECHOPGM(")   measured: ");
-              SERIAL_PROTOCOL_F(measured_z, 7);
-              SERIAL_ECHOPGM("   correction: ");
-              SERIAL_PROTOCOL_F(get_z_correction(rx, ry), 7);
-            }
-          #endif
+              measured_z -= get_z_correction(rx, ry) /* + zprobe_zoffset */ ;
 
-          measured_z -= get_z_correction(rx, ry) /* + zprobe_zoffset */ ;
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                if (DEBUGGING(LEVELING)) {
+                  SERIAL_ECHOPGM("   final >>>---> ");
+                  SERIAL_PROTOCOL_F(measured_z, 7);
+                  SERIAL_EOL();
+                }
+              #endif
 
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOPGM("   final >>>---> ");
-              SERIAL_PROTOCOL_F(measured_z, 7);
-              SERIAL_EOL();
+              incremental_LSF(&lsf_results, rx, ry, measured_z);
             }
-          #endif
-
-          incremental_LSF(&lsf_results, rx, ry, measured_z);
-        }
           }
 
-        zig_zag ^= true;
-      }
+          zig_zag ^= true;
+        }
 
       }
 
       if (abort_flag || finish_incremental_LSF(&lsf_results)) {
         SERIAL_ECHOPGM("Could not complete LSF!");
         return;
       }
 
-
       vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1.0000).get_normal();
 
       if (g29_verbose_level > 2) {
         SERIAL_ECHOPGM("bed plane normal = [");
         SERIAL_PROTOCOL_F(normal.x, 7);
         SERIAL_PROTOCOLCHAR(',');
         SERIAL_PROTOCOL_F(normal.y, 7);
         SERIAL_PROTOCOLCHAR(',');
         SERIAL_PROTOCOL_F(normal.z, 7);
         SERIAL_ECHOLNPGM("]");
@@ -1707,73 +1706,73 @@
 
           SERIAL_ECHOPGM("bed plane normal = [");
           SERIAL_PROTOCOL_F(normal.x, 7);
           SERIAL_PROTOCOLCHAR(',');
           SERIAL_PROTOCOL_F(normal.y, 7);
           SERIAL_PROTOCOLCHAR(',');
           SERIAL_PROTOCOL_F(normal.z, 7);
           SERIAL_ECHOPGM("]\n");
           SERIAL_EOL();
 
-/*
- * The following code can be used to check the validity of the mesh tilting algorithm.
- * When a 3-Point Mesh Tilt is done, the same algorithm is used as the grid based tilting.
- * The only difference is just 3 points are used in the calculations.   That fact guarantees
- * each probed point should have an exact match when a get_z_correction() for that location
- * is calculated.  The Z error between the probed point locations and the get_z_correction()
- * numbers for those locations should be 0.000
- */
-/*
+          /**
+           * The following code can be used to check the validity of the mesh tilting algorithm.
+           * When a 3-Point Mesh Tilt is done, the same algorithm is used as the grid based tilting.
+           * The only difference is just 3 points are used in the calculations.   That fact guarantees
+           * each probed point should have an exact match when a get_z_correction() for that location
+           * is calculated.  The Z error between the probed point locations and the get_z_correction()
+           * numbers for those locations should be 0.000
+           */
+          #if 0
           float t, t1, d;
           t = normal.x * (UBL_PROBE_PT_1_X) + normal.y * (UBL_PROBE_PT_1_Y);
           d = t + normal.z * z1;
           SERIAL_ECHOPGM("D from 1st point: ");
           SERIAL_ECHO_F(d, 6);
           SERIAL_ECHOPGM("   Z error: ");
-          SERIAL_ECHO_F(normal.z*z1-get_z_correction(UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y),6);
+          SERIAL_ECHO_F(normal.z*z1-get_z_correction(UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y), 6);
           SERIAL_EOL();
 
           t = normal.x * (UBL_PROBE_PT_2_X) + normal.y * (UBL_PROBE_PT_2_Y);
           d = t + normal.z * z2;
           SERIAL_EOL();
           SERIAL_ECHOPGM("D from 2nd point: ");
           SERIAL_ECHO_F(d, 6);
           SERIAL_ECHOPGM("   Z error: ");
-          SERIAL_ECHO_F(normal.z*z2-get_z_correction(UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y),6);
+          SERIAL_ECHO_F(normal.z*z2-get_z_correction(UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y), 6);
           SERIAL_EOL();
 
           t = normal.x * (UBL_PROBE_PT_3_X) + normal.y * (UBL_PROBE_PT_3_Y);
           d = t + normal.z * z3;
           SERIAL_ECHOPGM("D from 3rd point: ");
           SERIAL_ECHO_F(d, 6);
           SERIAL_ECHOPGM("   Z error: ");
-          SERIAL_ECHO_F(normal.z*z3-get_z_correction(UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y),6);
+          SERIAL_ECHO_F(normal.z*z3-get_z_correction(UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y), 6);
           SERIAL_EOL();
 
           t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
           d = t + normal.z * 0.000;
           SERIAL_ECHOPGM("D from home location with Z=0 : ");
           SERIAL_ECHO_F(d, 6);
           SERIAL_EOL();
 
           t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
           d = t + get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT); // normal.z * 0.000;
           SERIAL_ECHOPGM("D from home location using mesh value for Z: ");
           SERIAL_ECHO_F(d, 6);
 
-          SERIAL_ECHOPAIR("   Z error: (", Z_SAFE_HOMING_X_POINT );
+          SERIAL_ECHOPAIR("   Z error: (", Z_SAFE_HOMING_X_POINT);
           SERIAL_ECHOPAIR(",", Z_SAFE_HOMING_Y_POINT );
           SERIAL_ECHOPGM(") = ");
-          SERIAL_ECHO_F( get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT),6);
+          SERIAL_ECHO_F(get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT), 6);
           SERIAL_EOL();
-*/
-        }
+          #endif
+        } // DEBUGGING(LEVELING)
       #endif
 
     }
 
   #endif // HAS_BED_PROBE
 
   #if ENABLED(UBL_G29_P31)
     void unified_bed_leveling::smart_fill_wlsf(const float &weight_factor) {
 
       // For each undefined mesh point, compute a distance-weighted least squares fit

commit e5ee0b6f6c9a2236a460ca1cd104b9745d9c7a28
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 4 00:39:01 2018 -0600

    Implement MALYAN_LCD

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 531dcadbfd..d66b2e7223 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -44,25 +44,21 @@
 #include "../../../feature/Max7219_Debug_LEDs.h"
 
   #include <math.h>
 
   #define UBL_G29_P31
 
   extern float destination[XYZE], current_position[XYZE];
 
   #if ENABLED(NEWPANEL)
     void lcd_return_to_status();
-    void lcd_mesh_edit_setup(float initial);
-    float lcd_mesh_edit();
-    void lcd_z_offset_edit_setup(float);
     extern void _lcd_ubl_output_map_lcd();
-    float lcd_z_offset_edit();
   #endif
 
   extern float meshedit_done;
   extern long babysteps_done;
 
   #define SIZE_OF_LITTLE_RAISE 1
   #define BIG_RAISE_NOT_NEEDED 0
 
   int    unified_bed_leveling::g29_verbose_level,
          unified_bed_leveling::g29_phase_value,

commit 2bea1bda569ac7aecc87c0f79a7ceaa7a073a0b4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 23 21:17:33 2018 -0600

    Move more strings to PROGMEM

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index b951962e6e..531dcadbfd 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1088,21 +1088,21 @@
     else {
       SERIAL_PROTOCOLPAIR("Mesh ", storage_slot);
       SERIAL_PROTOCOLPGM(" Loaded.");
     }
     SERIAL_EOL();
     safe_delay(50);
 
     SERIAL_PROTOCOLLNPAIR("UBL object count: ", (int)ubl_cnt);
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      SERIAL_PROTOCOL("planner.z_fade_height : ");
+      SERIAL_PROTOCOLPGM("planner.z_fade_height : ");
       SERIAL_PROTOCOL_F(planner.z_fade_height, 4);
       SERIAL_EOL();
     #endif
 
     find_mean_mesh_height();
 
     #if HAS_BED_PROBE
       SERIAL_PROTOCOLPGM("zprobe_zoffset: ");
       SERIAL_PROTOCOL_F(zprobe_zoffset, 7);
       SERIAL_EOL();

commit 1dcfe193acaac8a26d789dcd4e949bb9613f3b58
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 23 19:09:40 2018 -0600

    Optimize some serial strings

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 4acde7fe4a..b951962e6e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1725,55 +1725,55 @@
  * each probed point should have an exact match when a get_z_correction() for that location
  * is calculated.  The Z error between the probed point locations and the get_z_correction()
  * numbers for those locations should be 0.000
  */
 /*
           float t, t1, d;
           t = normal.x * (UBL_PROBE_PT_1_X) + normal.y * (UBL_PROBE_PT_1_Y);
           d = t + normal.z * z1;
           SERIAL_ECHOPGM("D from 1st point: ");
           SERIAL_ECHO_F(d, 6);
-          SERIAL_ECHO("   Z error: ");
+          SERIAL_ECHOPGM("   Z error: ");
           SERIAL_ECHO_F(normal.z*z1-get_z_correction(UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y),6);
           SERIAL_EOL();
 
           t = normal.x * (UBL_PROBE_PT_2_X) + normal.y * (UBL_PROBE_PT_2_Y);
           d = t + normal.z * z2;
           SERIAL_EOL();
           SERIAL_ECHOPGM("D from 2nd point: ");
           SERIAL_ECHO_F(d, 6);
-          SERIAL_ECHO("   Z error: ");
+          SERIAL_ECHOPGM("   Z error: ");
           SERIAL_ECHO_F(normal.z*z2-get_z_correction(UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y),6);
           SERIAL_EOL();
 
           t = normal.x * (UBL_PROBE_PT_3_X) + normal.y * (UBL_PROBE_PT_3_Y);
           d = t + normal.z * z3;
           SERIAL_ECHOPGM("D from 3rd point: ");
           SERIAL_ECHO_F(d, 6);
-          SERIAL_ECHO("   Z error: ");
+          SERIAL_ECHOPGM("   Z error: ");
           SERIAL_ECHO_F(normal.z*z3-get_z_correction(UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y),6);
           SERIAL_EOL();
 
           t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
           d = t + normal.z * 0.000;
           SERIAL_ECHOPGM("D from home location with Z=0 : ");
           SERIAL_ECHO_F(d, 6);
           SERIAL_EOL();
 
           t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
           d = t + get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT); // normal.z * 0.000;
           SERIAL_ECHOPGM("D from home location using mesh value for Z: ");
           SERIAL_ECHO_F(d, 6);
 
           SERIAL_ECHOPAIR("   Z error: (", Z_SAFE_HOMING_X_POINT );
           SERIAL_ECHOPAIR(",", Z_SAFE_HOMING_Y_POINT );
-          SERIAL_ECHO(") = ");
+          SERIAL_ECHOPGM(") = ");
           SERIAL_ECHO_F( get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT),6);
           SERIAL_EOL();
 */
         }
       #endif
 
     }
 
   #endif // HAS_BED_PROBE
 

commit bfd9728cf4c4adb426c926584f42501949ca74c8
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Thu Jan 18 19:57:18 2018 -0600

    Serial buffer over run work around for v2.0.0 (#9236)
    
    * Work around for serial buffer over run
    
    PronterFace sends a lot of M105 commands.  During long operations such
    as UBL's G29 P1, G29 P2, G29 P4 and G26 this can over run the serial
    buffer.   This results (very often) in a M1 (actually a M1M105) ending
    up in the command queue.
    
    Until we figure out a better way to resolve this issue, this will keep
    the UBL commands from experiencing bogus commands at thier completion.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 9482e6b7b6..4acde7fe4a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -29,20 +29,21 @@
   #include "ubl.h"
 
   #include "../../../Marlin.h"
   #include "../../../libs/hex_print_routines.h"
   #include "../../../module/configuration_store.h"
   #include "../../../lcd/ultralcd.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
   #include "../../../module/probe.h"
   #include "../../../gcode/gcode.h"
+  #include "../../../core/serial.h"
   #include "../../../gcode/parser.h"
   #include "../../../feature/bedlevel/bedlevel.h"
   #include "../../../libs/least_squares_fit.h"
 
 #include "../../../feature/Max7219_Debug_LEDs.h"
 
   #include <math.h>
 
   #define UBL_G29_P31
 
@@ -52,22 +53,20 @@
     void lcd_return_to_status();
     void lcd_mesh_edit_setup(float initial);
     float lcd_mesh_edit();
     void lcd_z_offset_edit_setup(float);
     extern void _lcd_ubl_output_map_lcd();
     float lcd_z_offset_edit();
   #endif
 
   extern float meshedit_done;
   extern long babysteps_done;
-  //extern bool set_probe_deployed(bool);
-  //extern void set_bed_leveling_enabled(bool);
 
   #define SIZE_OF_LITTLE_RAISE 1
   #define BIG_RAISE_NOT_NEEDED 0
 
   int    unified_bed_leveling::g29_verbose_level,
          unified_bed_leveling::g29_phase_value,
          unified_bed_leveling::g29_repetition_cnt,
          unified_bed_leveling::g29_storage_slot = 0,
          unified_bed_leveling::g29_map_type;
   bool   unified_bed_leveling::g29_c_flag,
@@ -713,21 +712,21 @@
           idle();                                 // idle, of course
           if (ELAPSED(millis(), nxt)) {           // After 1.5 seconds
             lcd_quick_feedback(true);
             if (func) (*func)();
             wait_for_release();
             safe_delay(50);                       // Debounce the Encoder wheel
             return true;
           }
         }
       }
-      safe_delay(5);
+      safe_delay(15);
       return false;
     }
 
   #endif // NEWPANEL
 
   #if HAS_BED_PROBE
     /**
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
@@ -747,37 +746,41 @@
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
         #if ENABLED(NEWPANEL)
           if (is_lcd_clicked()) {
             SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.\n");
             lcd_quick_feedback(false);
             STOW_PROBE();
             while (is_lcd_clicked()) idle();
             lcd_external_control = false;
             restore_ubl_active_state_and_leave();
+            lcd_quick_feedback(true);
             safe_delay(50);  // Debounce the Encoder wheel
             return;
           }
         #endif
 
         if (close_or_far)
           location = find_furthest_invalid_mesh_point();
         else
           location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, NULL);
 
         if (location.x_index >= 0) {    // mesh point found and is reachable by probe
           const float rawx = mesh_index_to_xpos(location.x_index),
                       rawy = mesh_index_to_ypos(location.y_index);
 
           const float measured_z = probe_pt(rawx, rawy, stow_probe, g29_verbose_level); // TODO: Needs error handling
           z_values[location.x_index][location.y_index] = measured_z;
         }
+        MYSERIAL0.flush(); // G29 P2's take a long time to complete.   PronterFace can
+                           // over run the serial character buffer with M105's without
+                           // this fix
 
       } while (location.x_index >= 0 && --max_iterations);
 
       STOW_PROBE();
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
         constrain(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_X, MESH_MAX_X),
         constrain(ry - (Y_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_Y, MESH_MAX_Y)
       );
@@ -846,20 +849,21 @@
       restore_ubl_active_state_and_leave();
 
       return thickness;
     }
 
     void abort_manual_probe_remaining_mesh() {
       SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.");
       do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
       lcd_external_control = false;
       KEEPALIVE_STATE(IN_HANDLER);
+      lcd_quick_feedback(true);
       ubl.restore_ubl_active_state_and_leave();
     }
 
     void unified_bed_leveling::manually_probe_remaining_mesh(const float &rx, const float &ry, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
 
       lcd_external_control = true;
 
       save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
       do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z_clearance);
 
@@ -901,23 +905,26 @@
           restore_ubl_active_state_and_leave();
           return;
         }
 
         z_values[location.x_index][location.y_index] = current_position[Z_AXIS] - thick;
         if (g29_verbose_level > 2) {
           SERIAL_PROTOCOLPGM("Mesh Point Measured at: ");
           SERIAL_PROTOCOL_F(z_values[location.x_index][location.y_index], 6);
           SERIAL_EOL();
         }
+        MYSERIAL0.flush(); // G29 P2's take a long time to complete.   PronterFace can
+                           // over run the serial character buffer with M105's without
+                           // this fix
       } while (location.x_index >= 0 && location.y_index >= 0);
 
-      if (do_ubl_mesh_map) display_map(g29_map_type);
+      if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
       restore_ubl_active_state_and_leave();
       KEEPALIVE_STATE(IN_HANDLER);
       do_blocking_move_to(rx, ry, Z_CLEARANCE_DEPLOY_PROBE);
     }
   #endif // NEWPANEL
 
   bool unified_bed_leveling::g29_parameter_parsing() {
     bool err_flag = false;
 
@@ -1028,42 +1035,42 @@
     g29_map_type = parser.intval('T');
     if (!WITHIN(g29_map_type, 0, 2)) {
       SERIAL_PROTOCOLLNPGM("Invalid map type.\n");
       return UBL_ERR;
     }
     return UBL_OK;
   }
 
   static uint8_t ubl_state_at_invocation = 0;
 
-  #ifdef UBL_DEVEL_DEBUGGING
+  #if ENABLED(UBL_DEVEL_DEBUGGING)
     static uint8_t ubl_state_recursion_chk = 0;
   #endif
 
   void unified_bed_leveling::save_ubl_active_state_and_disable() {
-    #ifdef UBL_DEVEL_DEBUGGING
+    #if ENABLED(UBL_DEVEL_DEBUGGING)
       ubl_state_recursion_chk++;
       if (ubl_state_recursion_chk != 1) {
         SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
         #if ENABLED(NEWPANEL)
           LCD_MESSAGEPGM(MSG_UBL_SAVE_ERROR);
           lcd_quick_feedback(true);
         #endif
         return;
       }
     #endif
     ubl_state_at_invocation = planner.leveling_active;
     set_bed_leveling_enabled(false);
   }
 
   void unified_bed_leveling::restore_ubl_active_state_and_leave() {
-    #ifdef UBL_DEVEL_DEBUGGING
+    #if ENABLED(UBL_DEVEL_DEBUGGING)
       if (--ubl_state_recursion_chk) {
         SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
         #if ENABLED(NEWPANEL)
           LCD_MESSAGEPGM(MSG_UBL_RESTORE_ERROR);
           lcd_quick_feedback(true);
         #endif
         return;
       }
     #endif
     set_bed_leveling_enabled(ubl_state_at_invocation);
@@ -1103,25 +1110,26 @@
 
     SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X);
     safe_delay(50);
     SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y);
     safe_delay(50);
     SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X);
     safe_delay(50);
     SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y);
     safe_delay(50);
     SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);
+    safe_delay(50);
     SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);
-    safe_delay(25);
+    safe_delay(50);
     SERIAL_ECHOLNPAIR("MESH_X_DIST  ", MESH_X_DIST);
     SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);
-    safe_delay(25);
+    safe_delay(50);
 
     SERIAL_PROTOCOLPGM("X-Axis Mesh Points at: ");
     for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(mesh_index_to_xpos(i)), 3);
       SERIAL_PROTOCOLPGM("  ");
       safe_delay(25);
     }
     SERIAL_EOL();
 
     SERIAL_PROTOCOLPGM("Y-Axis Mesh Points at: ");
@@ -1132,21 +1140,21 @@
     }
     SERIAL_EOL();
 
     #if HAS_KILL
       SERIAL_PROTOCOLPAIR("Kill pin on :", KILL_PIN);
       SERIAL_PROTOCOLLNPAIR("  state:", READ(KILL_PIN));
     #endif
     SERIAL_EOL();
     safe_delay(50);
 
-    #ifdef UBL_DEVEL_DEBUGGING
+    #if ENABLED(UBL_DEVEL_DEBUGGING)
       SERIAL_PROTOCOLLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation);
       SERIAL_EOL();
       SERIAL_PROTOCOLLNPAIR("ubl_state_recursion_chk :", ubl_state_recursion_chk);
       SERIAL_EOL();
       safe_delay(50);
 
       SERIAL_PROTOCOLPAIR("Meshes go from ", hex_address((void*)settings.meshes_start_index()));
       SERIAL_PROTOCOLLNPAIR(" to ", hex_address((void*)settings.meshes_end_index()));
       safe_delay(50);
 
@@ -1345,20 +1353,21 @@
 
     return out_mesh;
   }
 
   #if ENABLED(NEWPANEL)
 
     void abort_fine_tune() {
       lcd_return_to_status();
       do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
       LCD_MESSAGEPGM(MSG_EDITING_STOPPED);
+      lcd_quick_feedback(true);
     }
 
     void unified_bed_leveling::fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map) {
       if (!parser.seen('R'))    // fine_tune_mesh() is special. If no repetition count flag is specified
         g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 
       #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
         const bool is_offset = parser.seen('H');
         const float h_offset = is_offset ? parser.value_linear_units() : Z_CLEARANCE_BETWEEN_PROBES;
         if (is_offset && !WITHIN(h_offset, 0, 10)) {
@@ -1410,32 +1419,32 @@
         new_z = FLOOR(new_z * 1000.0) * 0.001;  // Chop off digits after the 1000ths place
 
         lcd_mesh_edit_setup(new_z);
 
         do {
           new_z = lcd_mesh_edit();
           #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
             do_blocking_move_to_z(h_offset + new_z); // Move the nozzle as the point is edited
           #endif
           idle();
+          MYSERIAL0.flush(); // G29 P2's take a long time to complete.   PronterFace can
+                             // over run the serial character buffer with M105's without
+                             // this fix
         } while (!is_lcd_clicked());
 
         if (!lcd_map_control) lcd_return_to_status();
 
         // The technique used here generates a race condition for the encoder click.
         // It could get detected in lcd_mesh_edit (actually _lcd_mesh_fine_tune) or here.
         // Let's work on specifying a proper API for the LCD ASAP, OK?
         lcd_external_control = true;
 
-        // this sequence to detect an is_lcd_clicked() debounce it and leave if it is
-        // a Press and Hold is repeated in a lot of places (including G26_Mesh_Validation.cpp).   This
-        // should be redone and compressed.
         if (click_and_hold(abort_fine_tune))
           goto FINE_TUNE_EXIT;
 
         safe_delay(20);                       // We don't want any switch noise.
 
         z_values[location.x_index][location.y_index] = new_z;
 
         lcd_refresh();
 
       } while (location.x_index >= 0 && --g29_repetition_cnt > 0);

commit af9b32e3b9a95947583162e89dede06efc8bf2c7
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Tue Jan 16 18:00:57 2018 -0600

    Give PronterFace time to print the UBL What information...
    
    Give PronterFace time to print the UBL What information...

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 910417f783..9482e6b7b6 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1095,25 +1095,27 @@
 
     find_mean_mesh_height();
 
     #if HAS_BED_PROBE
       SERIAL_PROTOCOLPGM("zprobe_zoffset: ");
       SERIAL_PROTOCOL_F(zprobe_zoffset, 7);
       SERIAL_EOL();
     #endif
 
     SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X);
+    safe_delay(50);
     SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y);
-    safe_delay(25);
+    safe_delay(50);
     SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X);
+    safe_delay(50);
     SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y);
-    safe_delay(25);
+    safe_delay(50);
     SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);
     SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);
     safe_delay(25);
     SERIAL_ECHOLNPAIR("MESH_X_DIST  ", MESH_X_DIST);
     SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);
     safe_delay(25);
 
     SERIAL_PROTOCOLPGM("X-Axis Mesh Points at: ");
     for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(mesh_index_to_xpos(i)), 3);

commit f5f1b069ade516793995870bac4d6707cff43407
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Tue Jan 16 11:08:00 2018 -0600

    Convert UBL mesh tilting to all use the same algorithm  (#9204)
    
    A number of regressions were patched also. The UBL G29 P2 and P4 Press and Hold had stopped working. It is very possible this is broken in the bugfix_v1.1.x branch also.
    
    The main purpose of the Pull Request is to get the 3-Point mesh tilting to use the LSF algorithm just like the grid based mesh tilt. This simplifies the logic and reduces the code size some what. But the real reason to do it is the 3-Point case can be solved exactly. And by feeding these numbers into the LSF algorithm it provides a way to check all that code for 'correctness'.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 96a827fad2..910417f783 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -33,20 +33,22 @@
   #include "../../../module/configuration_store.h"
   #include "../../../lcd/ultralcd.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
   #include "../../../module/probe.h"
   #include "../../../gcode/gcode.h"
   #include "../../../gcode/parser.h"
   #include "../../../feature/bedlevel/bedlevel.h"
   #include "../../../libs/least_squares_fit.h"
 
+#include "../../../feature/Max7219_Debug_LEDs.h"
+
   #include <math.h>
 
   #define UBL_G29_P31
 
   extern float destination[XYZE], current_position[XYZE];
 
   #if ENABLED(NEWPANEL)
     void lcd_return_to_status();
     void lcd_mesh_edit_setup(float initial);
     float lcd_mesh_edit();
@@ -91,22 +93,23 @@
    *                    Note: A non-compressible Spark Gap feeler gauge is recommended over a business card.
    *                    In this mode of G29 P2, a business or index card is used as a shim that the nozzle can
    *                    grab onto as it is lowered. In principle, the nozzle-bed distance is the same when the
    *                    same resistance is felt in the shim. You can omit the numerical value on first invocation
    *                    of G29 P2 B to measure shim thickness. Subsequent use of 'B' will apply the previously-
    *                    measured thickness by default.
    *
    *   C     Continue   G29 P1 C continues the generation of a partially-constructed Mesh without invalidating
    *                    previous measurements.
    *
-   *   C     Constant   G29 P2 C specifies a Constant and tells the Manual Probe subsystem to use the current
-   *                    location in its search for the closest unmeasured Mesh Point.
+   *   C                G29 P2 C tells the Manual Probe subsystem to not use the current nozzle
+   *                    location in its search for the closest unmeasured Mesh Point.  Instead, attempt to
+   *                    start at one end of the uprobed points and Continue sequentually.
    *
    *                    G29 P3 C specifies the Constant for the fill. Otherwise, uses a "reasonable" value.
    *
    *   C     Current    G29 Z C uses the Current location (instead of bed center or nearest edge).
    *
    *   D     Disable    Disable the Unified Bed Leveling system.
    *
    *   E     Stow_probe Stow the probe after each sampled point.
    *
    *   F #   Fade       Fade the amount of Mesh Based Compensation over a specified height. At the
@@ -274,23 +277,21 @@
    *
    *   W     What?      Display valuable Unified Bed Leveling System data.
    *
    *   X #              X Location for this command
    *
    *   Y #              Y Location for this command
    *
    *
    *   Release Notes:
    *   You MUST do M502, M500 to initialize the storage. Failure to do this will cause all
-   *   kinds of problems. Enabling EEPROM Storage is highly recommended. With EEPROM Storage
-   *   of the mesh, you are limited to 3-Point and Grid Leveling. (G29 P0 T and G29 P0 G
-   *   respectively.)
+   *   kinds of problems. Enabling EEPROM Storage is required.
    *
    *   When you do a G28 and then a G29 P1 to automatically build your first mesh, you are going to notice
    *   the Unified Bed Leveling probes points further and further away from the starting location. (The
    *   starting location defaults to the center of the bed.)   The original Grid and Mesh leveling used
    *   a Zig Zag pattern. The new pattern is better, especially for people with Delta printers. This
    *   allows you to get the center area of the Mesh populated (and edited) quicker. This allows you to
    *   perform a small print and check out your settings quicker. You do not need to populate the
    *   entire mesh to use it. (You don't want to spend a lot of time generating a mesh only to realize
    *   you don't have the resolution or zprobe_zoffset set correctly. The Mesh generation
    *   gathers points closest to where the nozzle is located unless you specify an (X,Y) coordinate pair.
@@ -378,50 +379,30 @@
               z_values[x][y] += parser.seen('C') ? g29_constant : 9.99;
           break;
       }
     }
 
     #if HAS_BED_PROBE
 
       if (parser.seen('J')) {
         if (g29_grid_size) {  // if not 0 it is a normal n x n grid being probed
           save_ubl_active_state_and_disable();
-          tilt_mesh_based_on_probed_grid(parser.seen('T'));
+          tilt_mesh_based_on_probed_grid(false /* false says to do normal grid probing */ );
           restore_ubl_active_state_and_leave();
         }
         else { // grid_size == 0 : A 3-Point leveling has been requested
-          float z3, z2, z1 = probe_pt(UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y, false, g29_verbose_level);
-          if (!isnan(z1)) {
-            z2 = probe_pt(UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y, false, g29_verbose_level);
-            if (!isnan(z2))
-              z3 = probe_pt(UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y, true, g29_verbose_level);
-          }
-
-          if (isnan(z1) || isnan(z2) || isnan(z3)) { // probe_pt will return NAN if unreachable
-            SERIAL_ERROR_START();
-            SERIAL_ERRORLNPGM("Attempt to probe off the bed.");
-            goto LEAVE;
-          }
-
-          // Adjust z1, z2, z3 by the Mesh Height at these points. Just because they're non-zero
-          // doesn't mean the Mesh is tilted! (Compensate each probe point by what the Mesh says
-          // its height is.)
 
           save_ubl_active_state_and_disable();
-          z1 -= get_z_correction(UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y) /* + zprobe_zoffset */ ;
-          z2 -= get_z_correction(UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y) /* + zprobe_zoffset */ ;
-          z3 -= get_z_correction(UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y) /* + zprobe_zoffset */ ;
-
-          do_blocking_move_to_xy(0.5 * (MESH_MAX_X - (MESH_MIN_X)), 0.5 * (MESH_MAX_Y - (MESH_MIN_Y)));
-          tilt_mesh_based_on_3pts(z1, z2, z3);
+          tilt_mesh_based_on_probed_grid(true /* true says to do 3-Point leveling */ );
           restore_ubl_active_state_and_leave();
         }
+        do_blocking_move_to_xy(0.5 * (MESH_MAX_X - (MESH_MIN_X)), 0.5 * (MESH_MAX_Y - (MESH_MIN_Y)));
       }
 
     #endif // HAS_BED_PROBE
 
     if (parser.seen('P')) {
       if (WITHIN(g29_phase_value, 0, 1) && storage_slot == -1) {
         storage_slot = 0;
         SERIAL_PROTOCOLLNPGM("Default storage slot 0 selected.");
       }
 
@@ -457,44 +438,39 @@
         #endif // HAS_BED_PROBE
 
         case 2: {
           #if ENABLED(NEWPANEL)
             //
             // Manually Probe Mesh in areas that can't be reached by the probe
             //
             SERIAL_PROTOCOLLNPGM("Manually probing unreachable mesh locations.");
             do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
 
-            if (!g29_x_flag && !g29_y_flag) {
+            if (parser.seen('C') && !g29_x_flag && !g29_y_flag) {
               /**
                * Use a good default location for the path.
                * The flipped > and < operators in these comparisons is intentional.
                * It should cause the probed points to follow a nice path on Cartesian printers.
                * It may make sense to have Delta printers default to the center of the bed.
                * Until that is decided, this can be forced with the X and Y parameters.
                */
               #if IS_KINEMATIC
                 g29_x_pos = X_HOME_POS;
                 g29_y_pos = Y_HOME_POS;
               #else // cartesian
                 g29_x_pos = X_PROBE_OFFSET_FROM_EXTRUDER > 0 ? X_BED_SIZE : 0;
                 g29_y_pos = Y_PROBE_OFFSET_FROM_EXTRUDER < 0 ? Y_BED_SIZE : 0;
               #endif
             }
 
-            if (parser.seen('C')) {
-              g29_x_pos = current_position[X_AXIS];
-              g29_y_pos = current_position[Y_AXIS];
-            }
-
             if (parser.seen('B')) {
-              g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness(Z_CLEARANCE_BETWEEN_PROBES);
+              g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness((float) Z_CLEARANCE_BETWEEN_PROBES);
               if (FABS(g29_card_thickness) > 1.5) {
                 SERIAL_PROTOCOLLNPGM("?Error in Business Card measurement.");
                 return;
               }
             }
 
             if (!position_is_reachable(g29_x_pos, g29_y_pos)) {
               SERIAL_PROTOCOLLNPGM("XY outside printable radius.");
               return;
             }
@@ -665,21 +641,21 @@
     }
 
     if (parser.seen('T'))
       display_map(g29_map_type);
 
     LEAVE:
 
     #if ENABLED(NEWPANEL)
       lcd_reset_alert_level();
       LCD_MESSAGEPGM("");
-      lcd_quick_feedback();
+      lcd_quick_feedback(true);
       lcd_external_control = false;
     #endif
 
     return;
   }
 
   void unified_bed_leveling::find_mean_mesh_height() {
     float sum = 0.0;
     int n = 0;
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
@@ -723,33 +699,35 @@
         if (!isnan(z_values[x][y]))
           z_values[x][y] += g29_constant;
   }
 
   #if ENABLED(NEWPANEL)
 
     typedef void (*clickFunc_t)();
 
     bool click_and_hold(const clickFunc_t func=NULL) {
       if (is_lcd_clicked()) {
-        lcd_quick_feedback();
+        lcd_quick_feedback(false); // Do NOT clear button status!  If cleared, the code
+                                   // code can not look for a 'click and hold'
         const millis_t nxt = millis() + 1500UL;
         while (is_lcd_clicked()) {                // Loop while the encoder is pressed. Uses hardware flag!
           idle();                                 // idle, of course
           if (ELAPSED(millis(), nxt)) {           // After 1.5 seconds
-            lcd_quick_feedback();
+            lcd_quick_feedback(true);
             if (func) (*func)();
             wait_for_release();
             safe_delay(50);                       // Debounce the Encoder wheel
             return true;
           }
         }
       }
+      safe_delay(5);
       return false;
     }
 
   #endif // NEWPANEL
 
   #if HAS_BED_PROBE
     /**
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
@@ -764,25 +742,26 @@
       DEPLOY_PROBE();
 
       uint16_t max_iterations = GRID_MAX_POINTS;
 
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
         #if ENABLED(NEWPANEL)
           if (is_lcd_clicked()) {
             SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.\n");
-            lcd_quick_feedback();
+            lcd_quick_feedback(false);
             STOW_PROBE();
-            wait_for_release();
+            while (is_lcd_clicked()) idle();
             lcd_external_control = false;
             restore_ubl_active_state_and_leave();
+            safe_delay(50);  // Debounce the Encoder wheel
             return;
           }
         #endif
 
         if (close_or_far)
           location = find_furthest_invalid_mesh_point();
         else
           location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, NULL);
 
         if (location.x_index >= 0) {    // mesh point found and is reachable by probe
@@ -797,123 +776,20 @@
 
       STOW_PROBE();
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
         constrain(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_X, MESH_MAX_X),
         constrain(ry - (Y_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 
-    void unified_bed_leveling::tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3) {
-      matrix_3x3 rotation;
-      vector_3 v1 = vector_3( (UBL_PROBE_PT_1_X - UBL_PROBE_PT_2_X),
-                              (UBL_PROBE_PT_1_Y - UBL_PROBE_PT_2_Y),
-                              (z1 - z2) ),
-
-               v2 = vector_3( (UBL_PROBE_PT_3_X - UBL_PROBE_PT_2_X),
-                              (UBL_PROBE_PT_3_Y - UBL_PROBE_PT_2_Y),
-                              (z3 - z2) ),
-
-               normal = vector_3::cross(v1, v2);
-
-      normal = normal.get_normal();
-
-      /**
-       * This vector is normal to the tilted plane.
-       * However, we don't know its direction. We need it to point up. So if
-       * Z is negative, we need to invert the sign of all components of the vector
-       */
-      if (normal.z < 0.0) {
-        normal.x = -normal.x;
-        normal.y = -normal.y;
-        normal.z = -normal.z;
-      }
-
-      rotation = matrix_3x3::create_look_at(vector_3(normal.x, normal.y, 1));
-
-      if (g29_verbose_level > 2) {
-        SERIAL_ECHOPGM("bed plane normal = [");
-        SERIAL_PROTOCOL_F(normal.x, 7);
-        SERIAL_PROTOCOLCHAR(',');
-        SERIAL_PROTOCOL_F(normal.y, 7);
-        SERIAL_PROTOCOLCHAR(',');
-        SERIAL_PROTOCOL_F(normal.z, 7);
-        SERIAL_ECHOLNPGM("]");
-        rotation.debug(PSTR("rotation matrix:"));
-      }
-
-      //
-      // All of 3 of these points should give us the same d constant
-      //
-
-      float t = normal.x * (UBL_PROBE_PT_1_X) + normal.y * (UBL_PROBE_PT_1_Y),
-            d = t + normal.z * z1;
-
-      if (g29_verbose_level>2) {
-        SERIAL_ECHOPGM("D constant: ");
-        SERIAL_PROTOCOL_F(d, 7);
-        SERIAL_ECHOLNPGM(" ");
-      }
-
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          SERIAL_ECHOPGM("d from 1st point: ");
-          SERIAL_ECHO_F(d, 6);
-          SERIAL_EOL();
-          t = normal.x * (UBL_PROBE_PT_2_X) + normal.y * (UBL_PROBE_PT_2_Y);
-          d = t + normal.z * z2;
-          SERIAL_ECHOPGM("d from 2nd point: ");
-          SERIAL_ECHO_F(d, 6);
-          SERIAL_EOL();
-          t = normal.x * (UBL_PROBE_PT_3_X) + normal.y * (UBL_PROBE_PT_3_Y);
-          d = t + normal.z * z3;
-          SERIAL_ECHOPGM("d from 3rd point: ");
-          SERIAL_ECHO_F(d, 6);
-          SERIAL_EOL();
-        }
-      #endif
-
-      for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
-        for (uint8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
-          float x_tmp = mesh_index_to_xpos(i),
-                y_tmp = mesh_index_to_ypos(j),
-                z_tmp = z_values[i][j];
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOPGM("before rotation = [");
-              SERIAL_PROTOCOL_F(x_tmp, 7);
-              SERIAL_PROTOCOLCHAR(',');
-              SERIAL_PROTOCOL_F(y_tmp, 7);
-              SERIAL_PROTOCOLCHAR(',');
-              SERIAL_PROTOCOL_F(z_tmp, 7);
-              SERIAL_ECHOPGM("]   ---> ");
-              safe_delay(20);
-            }
-          #endif
-          apply_rotation_xyz(rotation, x_tmp, y_tmp, z_tmp);
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOPGM("after rotation = [");
-              SERIAL_PROTOCOL_F(x_tmp, 7);
-              SERIAL_PROTOCOLCHAR(',');
-              SERIAL_PROTOCOL_F(y_tmp, 7);
-              SERIAL_PROTOCOLCHAR(',');
-              SERIAL_PROTOCOL_F(z_tmp, 7);
-              SERIAL_ECHOLNPGM("]");
-              safe_delay(55);
-            }
-          #endif
-          z_values[i][j] += z_tmp - d;
-        }
-      }
-    }
 
   #endif // HAS_BED_PROBE
 
   #if ENABLED(NEWPANEL)
 
     void unified_bed_leveling::move_z_with_encoder(const float &multiplier) {
       wait_for_release();
       while (!is_lcd_clicked()) {
         idle();
         if (encoder_diff) {
@@ -925,21 +801,21 @@
 
     float unified_bed_leveling::measure_point_with_encoder() {
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       move_z_with_encoder(0.01);
       KEEPALIVE_STATE(IN_HANDLER);
       return current_position[Z_AXIS];
     }
 
     static void echo_and_take_a_measurement() { SERIAL_PROTOCOLLNPGM(" and take a measurement."); }
 
-    float unified_bed_leveling::measure_business_card_thickness(const float &in_height) {
+    float unified_bed_leveling::measure_business_card_thickness(float in_height) {
       lcd_external_control = true;
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
       do_blocking_move_to(0.5 * (MESH_MAX_X - (MESH_MIN_X)), 0.5 * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
         //, min(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]) / 2.0);
       stepper.synchronize();
 
       SERIAL_PROTOCOLPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       lcd_return_to_status();
@@ -978,21 +854,21 @@
       lcd_external_control = false;
       KEEPALIVE_STATE(IN_HANDLER);
       ubl.restore_ubl_active_state_and_leave();
     }
 
     void unified_bed_leveling::manually_probe_remaining_mesh(const float &rx, const float &ry, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
 
       lcd_external_control = true;
 
       save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
-      do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);
+      do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z_clearance);
 
       lcd_return_to_status();
 
       mesh_index_pair location;
       do {
         location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_NOZZLE_AS_REFERENCE, NULL);
         // It doesn't matter if the probe can't reach the NAN location. This is a manual probe.
         if (location.x_index < 0 && location.y_index < 0) continue;
 
         const float xProbe = mesh_index_to_xpos(location.x_index),
@@ -1040,21 +916,21 @@
       KEEPALIVE_STATE(IN_HANDLER);
       do_blocking_move_to(rx, ry, Z_CLEARANCE_DEPLOY_PROBE);
     }
   #endif // NEWPANEL
 
   bool unified_bed_leveling::g29_parameter_parsing() {
     bool err_flag = false;
 
     #if ENABLED(NEWPANEL)
       LCD_MESSAGEPGM(MSG_UBL_DOING_G29);
-      lcd_quick_feedback();
+      lcd_quick_feedback(true);
     #endif
 
     g29_constant = 0.0;
     g29_repetition_cnt = 0;
 
     g29_x_flag = parser.seenval('X');
     g29_x_pos = g29_x_flag ? parser.value_float() : current_position[X_AXIS];
     g29_y_flag = parser.seenval('Y');
     g29_y_pos = g29_y_flag ? parser.value_float() : current_position[Y_AXIS];
 
@@ -1163,36 +1039,36 @@
     static uint8_t ubl_state_recursion_chk = 0;
   #endif
 
   void unified_bed_leveling::save_ubl_active_state_and_disable() {
     #ifdef UBL_DEVEL_DEBUGGING
       ubl_state_recursion_chk++;
       if (ubl_state_recursion_chk != 1) {
         SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
         #if ENABLED(NEWPANEL)
           LCD_MESSAGEPGM(MSG_UBL_SAVE_ERROR);
-          lcd_quick_feedback();
+          lcd_quick_feedback(true);
         #endif
         return;
       }
     #endif
     ubl_state_at_invocation = planner.leveling_active;
     set_bed_leveling_enabled(false);
   }
 
   void unified_bed_leveling::restore_ubl_active_state_and_leave() {
     #ifdef UBL_DEVEL_DEBUGGING
       if (--ubl_state_recursion_chk) {
         SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
         #if ENABLED(NEWPANEL)
           LCD_MESSAGEPGM(MSG_UBL_RESTORE_ERROR);
-          lcd_quick_feedback();
+          lcd_quick_feedback(true);
         #endif
         return;
       }
     #endif
     set_bed_leveling_enabled(ubl_state_at_invocation);
   }
 
   /**
    * Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
    * good to have the extra information. Soon... we prune this to just a few items
@@ -1210,20 +1086,22 @@
     safe_delay(50);
 
     SERIAL_PROTOCOLLNPAIR("UBL object count: ", (int)ubl_cnt);
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       SERIAL_PROTOCOL("planner.z_fade_height : ");
       SERIAL_PROTOCOL_F(planner.z_fade_height, 4);
       SERIAL_EOL();
     #endif
 
+    find_mean_mesh_height();
+
     #if HAS_BED_PROBE
       SERIAL_PROTOCOLPGM("zprobe_zoffset: ");
       SERIAL_PROTOCOL_F(zprobe_zoffset, 7);
       SERIAL_EOL();
     #endif
 
     SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X);
     SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y);
     safe_delay(25);
     SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X);
@@ -1524,27 +1402,27 @@
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show the user which point is being adjusted
 
         lcd_refresh();
 
         float new_z = z_values[location.x_index][location.y_index];
         if (isnan(new_z)) new_z = 0.0;          // Set invalid mesh points to 0.0 so they can be edited
         new_z = FLOOR(new_z * 1000.0) * 0.001;  // Chop off digits after the 1000ths place
 
         lcd_mesh_edit_setup(new_z);
 
-        while (!is_lcd_clicked()) {
+        do {
           new_z = lcd_mesh_edit();
           #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
             do_blocking_move_to_z(h_offset + new_z); // Move the nozzle as the point is edited
           #endif
           idle();
-        }
+        } while (!is_lcd_clicked());
 
         if (!lcd_map_control) lcd_return_to_status();
 
         // The technique used here generates a race condition for the encoder click.
         // It could get detected in lcd_mesh_edit (actually _lcd_mesh_fine_tune) or here.
         // Let's work on specifying a proper API for the LCD ASAP, OK?
         lcd_external_control = true;
 
         // this sequence to detect an is_lcd_clicked() debounce it and leave if it is
         // a Press and Hold is repeated in a lot of places (including G26_Mesh_Validation.cpp).   This
@@ -1625,38 +1503,101 @@
         const int8_t dir = ey > sy ? 1 : -1;
          for (uint8_t x = sx; x != ex; ++x)
           for (uint8_t y = sy; y != ey; y += dir)
             if (smart_fill_one(x, y, 0, dir)) break;
       }
     }
   }
 
   #if HAS_BED_PROBE
 
-    void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map) {
+    void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_3_pt_leveling) {
       constexpr int16_t x_min = max(MIN_PROBE_X, MESH_MIN_X),
                         x_max = min(MAX_PROBE_X, MESH_MAX_X),
                         y_min = max(MIN_PROBE_Y, MESH_MIN_Y),
                         y_max = min(MAX_PROBE_Y, MESH_MAX_Y);
 
+      bool abort_flag=false;
+
+      float measured_z;
+
       const float dx = float(x_max - x_min) / (g29_grid_size - 1.0),
                   dy = float(y_max - y_min) / (g29_grid_size - 1.0);
 
       struct linear_fit_data lsf_results;
+
+//    float z1, z2, z3;  // Needed for algorithm validation down below.
+
       incremental_LSF_reset(&lsf_results);
 
+      if (do_3_pt_leveling) {
+        measured_z = probe_pt(UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y, false, g29_verbose_level);
+        if (isnan(measured_z))
+          abort_flag = true;
+        else {
+          measured_z -= get_z_correction(UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y);
+//        z1 = measured_z;
+          if (g29_verbose_level>3) {
+            serial_spaces(16);
+            SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
+          }
+          incremental_LSF(&lsf_results, UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y, measured_z);
+        }
+
+        if (!abort_flag) {
+          measured_z = probe_pt(UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y, false, g29_verbose_level);
+//        z2 = measured_z;
+          if (isnan(measured_z))
+            abort_flag = true;
+          else {
+            measured_z -= get_z_correction(UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y);
+            if (g29_verbose_level>3) {
+              serial_spaces(16);
+              SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
+            }
+            incremental_LSF(&lsf_results, UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y, measured_z);
+          }
+        }
+
+        if (!abort_flag) {
+          measured_z = probe_pt(UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y, true, g29_verbose_level);
+//        z3 = measured_z;
+          if (isnan(measured_z))
+            abort_flag = true;
+          else {
+            measured_z -= get_z_correction(UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y);
+            if (g29_verbose_level>3) {
+              serial_spaces(16);
+              SERIAL_ECHOLNPAIR("Corrected_Z=", measured_z);
+            }
+            incremental_LSF(&lsf_results, UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y, measured_z);
+          }
+        }
+
+        if (abort_flag) {
+          SERIAL_ECHOPGM("?Error probing point.  Aborting operation.\n");
+          return;
+        }
+      } else {
+
       bool zig_zag = false;
       for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
         const float rx = float(x_min) + ix * dx;
         for (int8_t iy = 0; iy < g29_grid_size; iy++) {
           const float ry = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
-          float measured_z = probe_pt(rx, ry, parser.seen('E'), g29_verbose_level); // TODO: Needs error handling
+
+            if (!abort_flag) {
+              measured_z = probe_pt(rx, ry, parser.seen('E'), g29_verbose_level); // TODO: Needs error handling
+
+              if (isnan(measured_z))
+                abort_flag = true;
+
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_CHAR('(');
               SERIAL_PROTOCOL_F(rx, 7);
               SERIAL_CHAR(',');
               SERIAL_PROTOCOL_F(ry, 7);
               SERIAL_ECHOPGM(")   logical: ");
               SERIAL_CHAR('(');
               SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 7);
               SERIAL_CHAR(',');
@@ -1673,38 +1614,32 @@
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPGM("   final >>>---> ");
               SERIAL_PROTOCOL_F(measured_z, 7);
               SERIAL_EOL();
             }
           #endif
 
           incremental_LSF(&lsf_results, rx, ry, measured_z);
         }
+          }
 
         zig_zag ^= true;
       }
 
-      if (finish_incremental_LSF(&lsf_results)) {
+      }
+
+      if (abort_flag || finish_incremental_LSF(&lsf_results)) {
         SERIAL_ECHOPGM("Could not complete LSF!");
         return;
       }
 
-      if (g29_verbose_level > 3) {
-        SERIAL_ECHOPGM("LSF Results A=");
-        SERIAL_PROTOCOL_F(lsf_results.A, 7);
-        SERIAL_ECHOPGM("  B=");
-        SERIAL_PROTOCOL_F(lsf_results.B, 7);
-        SERIAL_ECHOPGM("  D=");
-        SERIAL_PROTOCOL_F(lsf_results.D, 7);
-        SERIAL_EOL();
-      }
 
       vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1.0000).get_normal();
 
       if (g29_verbose_level > 2) {
         SERIAL_ECHOPGM("bed plane normal = [");
         SERIAL_PROTOCOL_F(normal.x, 7);
         SERIAL_PROTOCOLCHAR(',');
         SERIAL_PROTOCOL_F(normal.y, 7);
         SERIAL_PROTOCOLCHAR(',');
         SERIAL_PROTOCOL_F(normal.z, 7);
@@ -1746,42 +1681,94 @@
               safe_delay(55);
             }
           #endif
 
           z_values[i][j] += z_tmp - lsf_results.D;
         }
       }
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
-          rotation.debug(PSTR("rotation matrix:"));
+          rotation.debug(PSTR("rotation matrix:\n"));
           SERIAL_ECHOPGM("LSF Results A=");
           SERIAL_PROTOCOL_F(lsf_results.A, 7);
           SERIAL_ECHOPGM("  B=");
           SERIAL_PROTOCOL_F(lsf_results.B, 7);
           SERIAL_ECHOPGM("  D=");
           SERIAL_PROTOCOL_F(lsf_results.D, 7);
           SERIAL_EOL();
           safe_delay(55);
 
           SERIAL_ECHOPGM("bed plane normal = [");
           SERIAL_PROTOCOL_F(normal.x, 7);
           SERIAL_PROTOCOLCHAR(',');
           SERIAL_PROTOCOL_F(normal.y, 7);
           SERIAL_PROTOCOLCHAR(',');
           SERIAL_PROTOCOL_F(normal.z, 7);
           SERIAL_ECHOPGM("]\n");
           SERIAL_EOL();
+
+/*
+ * The following code can be used to check the validity of the mesh tilting algorithm.
+ * When a 3-Point Mesh Tilt is done, the same algorithm is used as the grid based tilting.
+ * The only difference is just 3 points are used in the calculations.   That fact guarantees
+ * each probed point should have an exact match when a get_z_correction() for that location
+ * is calculated.  The Z error between the probed point locations and the get_z_correction()
+ * numbers for those locations should be 0.000
+ */
+/*
+          float t, t1, d;
+          t = normal.x * (UBL_PROBE_PT_1_X) + normal.y * (UBL_PROBE_PT_1_Y);
+          d = t + normal.z * z1;
+          SERIAL_ECHOPGM("D from 1st point: ");
+          SERIAL_ECHO_F(d, 6);
+          SERIAL_ECHO("   Z error: ");
+          SERIAL_ECHO_F(normal.z*z1-get_z_correction(UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y),6);
+          SERIAL_EOL();
+
+          t = normal.x * (UBL_PROBE_PT_2_X) + normal.y * (UBL_PROBE_PT_2_Y);
+          d = t + normal.z * z2;
+          SERIAL_EOL();
+          SERIAL_ECHOPGM("D from 2nd point: ");
+          SERIAL_ECHO_F(d, 6);
+          SERIAL_ECHO("   Z error: ");
+          SERIAL_ECHO_F(normal.z*z2-get_z_correction(UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y),6);
+          SERIAL_EOL();
+
+          t = normal.x * (UBL_PROBE_PT_3_X) + normal.y * (UBL_PROBE_PT_3_Y);
+          d = t + normal.z * z3;
+          SERIAL_ECHOPGM("D from 3rd point: ");
+          SERIAL_ECHO_F(d, 6);
+          SERIAL_ECHO("   Z error: ");
+          SERIAL_ECHO_F(normal.z*z3-get_z_correction(UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y),6);
+          SERIAL_EOL();
+
+          t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
+          d = t + normal.z * 0.000;
+          SERIAL_ECHOPGM("D from home location with Z=0 : ");
+          SERIAL_ECHO_F(d, 6);
+          SERIAL_EOL();
+
+          t = normal.x * (Z_SAFE_HOMING_X_POINT) + normal.y * (Z_SAFE_HOMING_Y_POINT);
+          d = t + get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT); // normal.z * 0.000;
+          SERIAL_ECHOPGM("D from home location using mesh value for Z: ");
+          SERIAL_ECHO_F(d, 6);
+
+          SERIAL_ECHOPAIR("   Z error: (", Z_SAFE_HOMING_X_POINT );
+          SERIAL_ECHOPAIR(",", Z_SAFE_HOMING_Y_POINT );
+          SERIAL_ECHO(") = ");
+          SERIAL_ECHO_F( get_z_correction(Z_SAFE_HOMING_X_POINT, Z_SAFE_HOMING_Y_POINT),6);
+          SERIAL_EOL();
+*/
         }
       #endif
 
-      if (do_ubl_mesh_map) display_map(g29_map_type);
     }
 
   #endif // HAS_BED_PROBE
 
   #if ENABLED(UBL_G29_P31)
     void unified_bed_leveling::smart_fill_wlsf(const float &weight_factor) {
 
       // For each undefined mesh point, compute a distance-weighted least squares fit
       // from all the originally populated mesh points, weighted toward the point
       // being extrapolated so that nearby points will have greater influence on

commit e89f1453ab75cd2e1cdb0a314bc61e46082234a9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 4 21:09:56 2018 -0600

    UBL G29 works without settings.load()

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 8d9a98025a..96a827fad2 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -302,26 +302,20 @@
    *   other data stored in the EEPROM. (For sure the developers are going to complain about this, but
    *   this is going to be helpful to the users!)
    *
    *   The foundation of this Bed Leveling System is built on Epatel's Mesh Bed Leveling code. A big
    *   'Thanks!' to him and the creators of 3-Point and Grid Based leveling. Combining their contributions
    *   we now have the functionality and features of all three systems combined.
    */
 
   void unified_bed_leveling::G29() {
 
-    if (!settings.calc_num_meshes()) {
-      SERIAL_PROTOCOLLNPGM("?Enable EEPROM and init with");
-      SERIAL_PROTOCOLLNPGM("M502, M500, M501 in that order.\n");
-      return;
-    }
-
     if (g29_parameter_parsing()) return; // abort if parsing the simple parameters causes a problem,
 
     // Check for commands that require the printer to be homed
     if (axis_unhomed_error()) {
       const int8_t p_val = parser.intval('P', -1);
       if (p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J'))
         gcode.home_all_axes();
     }
 
     // Invalidate Mesh Points. This command is a little bit asymmetrical because
@@ -1265,31 +1259,31 @@
     SERIAL_EOL();
     safe_delay(50);
 
     #ifdef UBL_DEVEL_DEBUGGING
       SERIAL_PROTOCOLLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation);
       SERIAL_EOL();
       SERIAL_PROTOCOLLNPAIR("ubl_state_recursion_chk :", ubl_state_recursion_chk);
       SERIAL_EOL();
       safe_delay(50);
 
-      SERIAL_PROTOCOLPAIR("Meshes go from ", hex_address((void*)settings.get_start_of_meshes()));
-      SERIAL_PROTOCOLLNPAIR(" to ", hex_address((void*)settings.get_end_of_meshes()));
+      SERIAL_PROTOCOLPAIR("Meshes go from ", hex_address((void*)settings.meshes_start_index()));
+      SERIAL_PROTOCOLLNPAIR(" to ", hex_address((void*)settings.meshes_end_index()));
       safe_delay(50);
 
       SERIAL_PROTOCOLLNPAIR("sizeof(ubl) :  ", (int)sizeof(ubl));
       SERIAL_EOL();
       SERIAL_PROTOCOLLNPAIR("z_value[][] size: ", (int)sizeof(z_values));
       SERIAL_EOL();
       safe_delay(25);
 
-      SERIAL_PROTOCOLLNPAIR("EEPROM free for UBL: ", hex_address((void*)(settings.get_end_of_meshes() - settings.get_start_of_meshes())));
+      SERIAL_PROTOCOLLNPAIR("EEPROM free for UBL: ", hex_address((void*)(settings.meshes_end_index() - settings.meshes_start_index())));
       safe_delay(50);
 
       SERIAL_PROTOCOLPAIR("EEPROM can hold ", settings.calc_num_meshes());
       SERIAL_PROTOCOLLNPGM(" meshes.\n");
       safe_delay(25);
     #endif // UBL_DEVEL_DEBUGGING
 
     if (!sanity_check()) {
       echo_name();
       SERIAL_PROTOCOLLNPGM(" sanity checks passed.");

commit 4ef965cc4024fd8801f9cdc19eda20802a38e2a2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Dec 25 08:48:54 2017 -0600

    Fix compiler warnings

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 9c8e452076..8d9a98025a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -602,21 +602,21 @@
     if (parser.seen('K')) // Kompare Current Mesh Data to Specified Stored Mesh
       g29_compare_current_mesh_to_stored_mesh();
 
     //
     // Load a Mesh from the EEPROM
     //
 
     if (parser.seen('L')) {     // Load Current Mesh Data
       g29_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
 
-      uint16_t a = settings.calc_num_meshes();
+      int16_t a = settings.calc_num_meshes();
 
       if (!a) {
         SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
         return;
       }
 
       if (!WITHIN(g29_storage_slot, 0, a - 1)) {
         SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
         SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
         return;
@@ -644,21 +644,21 @@
               SERIAL_ECHOPAIR(" J ", y);
               SERIAL_ECHOPGM(" Z ");
               SERIAL_ECHO_F(z_values[x][y], 6);
               SERIAL_ECHOPAIR(" ; X ", LOGICAL_X_POSITION(mesh_index_to_xpos(x)));
               SERIAL_ECHOPAIR(", Y ", LOGICAL_Y_POSITION(mesh_index_to_ypos(y)));
               SERIAL_EOL();
             }
         return;
       }
 
-      uint16_t a = settings.calc_num_meshes();
+      int16_t a = settings.calc_num_meshes();
 
       if (!a) {
         SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
         goto LEAVE;
       }
 
       if (!WITHIN(g29_storage_slot, 0, a - 1)) {
         SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
         SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
         goto LEAVE;

commit 4b49ea1e92d2963f261bfc7ea1233b49200407af
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Dec 25 03:32:31 2017 -0600

    General cleanup of config-store, reset_bed_level

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index e70ff6121c..9c8e452076 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -303,21 +303,22 @@
    *   this is going to be helpful to the users!)
    *
    *   The foundation of this Bed Leveling System is built on Epatel's Mesh Bed Leveling code. A big
    *   'Thanks!' to him and the creators of 3-Point and Grid Based leveling. Combining their contributions
    *   we now have the functionality and features of all three systems combined.
    */
 
   void unified_bed_leveling::G29() {
 
     if (!settings.calc_num_meshes()) {
-      SERIAL_PROTOCOLLNPGM("?Enable EEPROM and init with M502, M500.\n");
+      SERIAL_PROTOCOLLNPGM("?Enable EEPROM and init with");
+      SERIAL_PROTOCOLLNPGM("M502, M500, M501 in that order.\n");
       return;
     }
 
     if (g29_parameter_parsing()) return; // abort if parsing the simple parameters causes a problem,
 
     // Check for commands that require the printer to be homed
     if (axis_unhomed_error()) {
       const int8_t p_val = parser.intval('P', -1);
       if (p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J'))
         gcode.home_all_axes();
@@ -601,21 +602,21 @@
     if (parser.seen('K')) // Kompare Current Mesh Data to Specified Stored Mesh
       g29_compare_current_mesh_to_stored_mesh();
 
     //
     // Load a Mesh from the EEPROM
     //
 
     if (parser.seen('L')) {     // Load Current Mesh Data
       g29_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
 
-      int16_t a = settings.calc_num_meshes();
+      uint16_t a = settings.calc_num_meshes();
 
       if (!a) {
         SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
         return;
       }
 
       if (!WITHIN(g29_storage_slot, 0, a - 1)) {
         SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
         SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
         return;
@@ -643,21 +644,21 @@
               SERIAL_ECHOPAIR(" J ", y);
               SERIAL_ECHOPGM(" Z ");
               SERIAL_ECHO_F(z_values[x][y], 6);
               SERIAL_ECHOPAIR(" ; X ", LOGICAL_X_POSITION(mesh_index_to_xpos(x)));
               SERIAL_ECHOPAIR(", Y ", LOGICAL_Y_POSITION(mesh_index_to_ypos(y)));
               SERIAL_EOL();
             }
         return;
       }
 
-      int16_t a = settings.calc_num_meshes();
+      uint16_t a = settings.calc_num_meshes();
 
       if (!a) {
         SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
         goto LEAVE;
       }
 
       if (!WITHIN(g29_storage_slot, 0, a - 1)) {
         SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
         SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
         goto LEAVE;

commit cdfabbc507d6a2655672618839437af78496b5fc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 21:44:48 2017 -0600

    Shorten error text in G29

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index a4208a1636..e70ff6121c 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -303,22 +303,21 @@
    *   this is going to be helpful to the users!)
    *
    *   The foundation of this Bed Leveling System is built on Epatel's Mesh Bed Leveling code. A big
    *   'Thanks!' to him and the creators of 3-Point and Grid Based leveling. Combining their contributions
    *   we now have the functionality and features of all three systems combined.
    */
 
   void unified_bed_leveling::G29() {
 
     if (!settings.calc_num_meshes()) {
-      SERIAL_PROTOCOLLNPGM("?You need to enable your EEPROM and initialize it");
-      SERIAL_PROTOCOLLNPGM("with M502, M500, M501 in that order.\n");
+      SERIAL_PROTOCOLLNPGM("?Enable EEPROM and init with M502, M500.\n");
       return;
     }
 
     if (g29_parameter_parsing()) return; // abort if parsing the simple parameters causes a problem,
 
     // Check for commands that require the printer to be homed
     if (axis_unhomed_error()) {
       const int8_t p_val = parser.intval('P', -1);
       if (p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J'))
         gcode.home_all_axes();

commit c846388a65d96e8ce804c7682d226bb67722ac7a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 21:28:04 2017 -0600

    Standardize LCD interface code for UBL a little

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 573ab10ea8..a4208a1636 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -17,20 +17,22 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
+  //#define UBL_DEVEL_DEBUGGING
+
   #include "ubl.h"
 
   #include "../../../Marlin.h"
   #include "../../../libs/hex_print_routines.h"
   #include "../../../module/configuration_store.h"
   #include "../../../lcd/ultralcd.h"
   #include "../../../module/stepper.h"
   #include "../../../module/planner.h"
   #include "../../../module/probe.h"
   #include "../../../gcode/gcode.h"
@@ -721,22 +723,45 @@
             z_values[x][y] -= mean + g29_constant;
   }
 
   void unified_bed_leveling::shift_mesh_height() {
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
         if (!isnan(z_values[x][y]))
           z_values[x][y] += g29_constant;
   }
 
-  #if HAS_BED_PROBE
+  #if ENABLED(NEWPANEL)
+
+    typedef void (*clickFunc_t)();
+
+    bool click_and_hold(const clickFunc_t func=NULL) {
+      if (is_lcd_clicked()) {
+        lcd_quick_feedback();
+        const millis_t nxt = millis() + 1500UL;
+        while (is_lcd_clicked()) {                // Loop while the encoder is pressed. Uses hardware flag!
+          idle();                                 // idle, of course
+          if (ELAPSED(millis(), nxt)) {           // After 1.5 seconds
+            lcd_quick_feedback();
+            if (func) (*func)();
+            wait_for_release();
+            safe_delay(50);                       // Debounce the Encoder wheel
+            return true;
+          }
+        }
+      }
+      return false;
+    }
 
+  #endif // NEWPANEL
+
+  #if HAS_BED_PROBE
     /**
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
     void unified_bed_leveling::probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, bool close_or_far) {
       mesh_index_pair location;
 
       #if ENABLED(NEWPANEL)
         lcd_external_control = true;
       #endif
@@ -747,24 +772,23 @@
       uint16_t max_iterations = GRID_MAX_POINTS;
 
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
         #if ENABLED(NEWPANEL)
           if (is_lcd_clicked()) {
             SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.\n");
             lcd_quick_feedback();
             STOW_PROBE();
-            while (is_lcd_clicked()) idle();
+            wait_for_release();
             lcd_external_control = false;
             restore_ubl_active_state_and_leave();
-            safe_delay(50);  // Debounce the Encoder wheel
             return;
           }
         #endif
 
         if (close_or_far)
           location = find_furthest_invalid_mesh_point();
         else
           location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, NULL);
 
         if (location.x_index >= 0) {    // mesh point found and is reachable by probe
@@ -887,33 +911,34 @@
           #endif
           z_values[i][j] += z_tmp - d;
         }
       }
     }
 
   #endif // HAS_BED_PROBE
 
   #if ENABLED(NEWPANEL)
 
-    float unified_bed_leveling::measure_point_with_encoder() {
-
-      while (is_lcd_clicked()) delay(50);  // wait for user to release encoder wheel
-      delay(50);  // debounce
-
-      KEEPALIVE_STATE(PAUSED_FOR_USER);
-      while (!is_lcd_clicked()) {     // we need the loop to move the nozzle based on the encoder wheel here!
+    void unified_bed_leveling::move_z_with_encoder(const float &multiplier) {
+      wait_for_release();
+      while (!is_lcd_clicked()) {
         idle();
         if (encoder_diff) {
-          do_blocking_move_to_z(current_position[Z_AXIS] + 0.01 * float(encoder_diff));
+          do_blocking_move_to_z(current_position[Z_AXIS] + float(encoder_diff) * multiplier);
           encoder_diff = 0;
         }
       }
+    }
+
+    float unified_bed_leveling::measure_point_with_encoder() {
+      KEEPALIVE_STATE(PAUSED_FOR_USER);
+      move_z_with_encoder(0.01);
       KEEPALIVE_STATE(IN_HANDLER);
       return current_position[Z_AXIS];
     }
 
     static void echo_and_take_a_measurement() { SERIAL_PROTOCOLLNPGM(" and take a measurement."); }
 
     float unified_bed_leveling::measure_business_card_thickness(const float &in_height) {
       lcd_external_control = true;
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
@@ -946,26 +971,33 @@
         SERIAL_PROTOCOLLNPGM("mm thick.");
       }
 
       lcd_external_control = false;
 
       restore_ubl_active_state_and_leave();
 
       return thickness;
     }
 
+    void abort_manual_probe_remaining_mesh() {
+      SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.");
+      do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
+      lcd_external_control = false;
+      KEEPALIVE_STATE(IN_HANDLER);
+      ubl.restore_ubl_active_state_and_leave();
+    }
+
     void unified_bed_leveling::manually_probe_remaining_mesh(const float &rx, const float &ry, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
 
       lcd_external_control = true;
 
       save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
-
       do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);
 
       lcd_return_to_status();
 
       mesh_index_pair location;
       do {
         location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_NOZZLE_AS_REFERENCE, NULL);
         // It doesn't matter if the probe can't reach the NAN location. This is a manual probe.
         if (location.x_index < 0 && location.y_index < 0) continue;
 
@@ -982,48 +1014,29 @@
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         lcd_external_control = true;
 
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
         serialprintPGM(parser.seen('B') ? PSTR(MSG_UBL_BC_INSERT) : PSTR(MSG_UBL_BC_INSERT2));
 
         const float z_step = 0.01;                                        // existing behavior: 0.01mm per click, occasionally step
         //const float z_step = 1.0 / planner.axis_steps_per_mm[Z_AXIS];   // approx one step each click
 
-        while (is_lcd_clicked()) delay(50);             // wait for user to release encoder wheel
-        delay(50);                                       // debounce
-        while (!is_lcd_clicked()) {                     // we need the loop to move the nozzle based on the encoder wheel here!
-          idle();
-          if (encoder_diff) {
-            do_blocking_move_to_z(current_position[Z_AXIS] + float(encoder_diff) * z_step);
-            encoder_diff = 0;
-          }
-        }
-
-        // this sequence to detect an is_lcd_clicked() debounce it and leave if it is
-        // a Press and Hold is repeated in a lot of places (including G26_Mesh_Validation.cpp).   This
-        // should be redone and compressed.
-        const millis_t nxt = millis() + 1500L;
-        while (is_lcd_clicked()) {     // debounce and watch for abort
-          idle();
-          if (ELAPSED(millis(), nxt)) {
-            SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.");
-            do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
-
-            lcd_quick_feedback();
-            while (is_lcd_clicked()) idle();
-            lcd_external_control = false;
+        move_z_with_encoder(z_step);
 
-            KEEPALIVE_STATE(IN_HANDLER);
-            restore_ubl_active_state_and_leave();
-            return;
-          }
+        if (click_and_hold()) {
+          SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.");
+          do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
+          lcd_external_control = false;
+          KEEPALIVE_STATE(IN_HANDLER);
+          restore_ubl_active_state_and_leave();
+          return;
         }
 
         z_values[location.x_index][location.y_index] = current_position[Z_AXIS] - thick;
         if (g29_verbose_level > 2) {
           SERIAL_PROTOCOLPGM("Mesh Point Measured at: ");
           SERIAL_PROTOCOL_F(z_values[location.x_index][location.y_index], 6);
           SERIAL_EOL();
         }
       } while (location.x_index >= 0 && location.y_index >= 0);
 
@@ -1143,50 +1156,53 @@
     #endif
 
     g29_map_type = parser.intval('T');
     if (!WITHIN(g29_map_type, 0, 2)) {
       SERIAL_PROTOCOLLNPGM("Invalid map type.\n");
       return UBL_ERR;
     }
     return UBL_OK;
   }
 
-  static int ubl_state_at_invocation = 0,
-             ubl_state_recursion_chk = 0;
-
-  void unified_bed_leveling::save_ubl_active_state_and_disable() {
-    ubl_state_recursion_chk++;
-    if (ubl_state_recursion_chk != 1) {
-      SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
+  static uint8_t ubl_state_at_invocation = 0;
 
-      #if ENABLED(NEWPANEL)
-        LCD_MESSAGEPGM(MSG_UBL_SAVE_ERROR);
-        lcd_quick_feedback();
-      #endif
+  #ifdef UBL_DEVEL_DEBUGGING
+    static uint8_t ubl_state_recursion_chk = 0;
+  #endif
 
-      return;
-    }
+  void unified_bed_leveling::save_ubl_active_state_and_disable() {
+    #ifdef UBL_DEVEL_DEBUGGING
+      ubl_state_recursion_chk++;
+      if (ubl_state_recursion_chk != 1) {
+        SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
+        #if ENABLED(NEWPANEL)
+          LCD_MESSAGEPGM(MSG_UBL_SAVE_ERROR);
+          lcd_quick_feedback();
+        #endif
+        return;
+      }
+    #endif
     ubl_state_at_invocation = planner.leveling_active;
     set_bed_leveling_enabled(false);
   }
 
   void unified_bed_leveling::restore_ubl_active_state_and_leave() {
-    if (--ubl_state_recursion_chk) {
-      SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
-
-      #if ENABLED(NEWPANEL)
-        LCD_MESSAGEPGM(MSG_UBL_RESTORE_ERROR);
-        lcd_quick_feedback();
-      #endif
-
-      return;
-    }
+    #ifdef UBL_DEVEL_DEBUGGING
+      if (--ubl_state_recursion_chk) {
+        SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
+        #if ENABLED(NEWPANEL)
+          LCD_MESSAGEPGM(MSG_UBL_RESTORE_ERROR);
+          lcd_quick_feedback();
+        #endif
+        return;
+      }
+    #endif
     set_bed_leveling_enabled(ubl_state_at_invocation);
   }
 
   /**
    * Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
    * good to have the extra information. Soon... we prune this to just a few items
    */
   void unified_bed_leveling::g29_what_command() {
     report_state();
 
@@ -1242,42 +1258,44 @@
     }
     SERIAL_EOL();
 
     #if HAS_KILL
       SERIAL_PROTOCOLPAIR("Kill pin on :", KILL_PIN);
       SERIAL_PROTOCOLLNPAIR("  state:", READ(KILL_PIN));
     #endif
     SERIAL_EOL();
     safe_delay(50);
 
-    SERIAL_PROTOCOLLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation);
-    SERIAL_EOL();
-    SERIAL_PROTOCOLLNPAIR("ubl_state_recursion_chk :", ubl_state_recursion_chk);
-    SERIAL_EOL();
-    safe_delay(50);
+    #ifdef UBL_DEVEL_DEBUGGING
+      SERIAL_PROTOCOLLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation);
+      SERIAL_EOL();
+      SERIAL_PROTOCOLLNPAIR("ubl_state_recursion_chk :", ubl_state_recursion_chk);
+      SERIAL_EOL();
+      safe_delay(50);
 
-    SERIAL_PROTOCOLPAIR("Meshes go from ", hex_address((void*)settings.get_start_of_meshes()));
-    SERIAL_PROTOCOLLNPAIR(" to ", hex_address((void*)settings.get_end_of_meshes()));
-    safe_delay(50);
+      SERIAL_PROTOCOLPAIR("Meshes go from ", hex_address((void*)settings.get_start_of_meshes()));
+      SERIAL_PROTOCOLLNPAIR(" to ", hex_address((void*)settings.get_end_of_meshes()));
+      safe_delay(50);
 
-    SERIAL_PROTOCOLLNPAIR("sizeof(ubl) :  ", (int)sizeof(ubl));
-    SERIAL_EOL();
-    SERIAL_PROTOCOLLNPAIR("z_value[][] size: ", (int)sizeof(z_values));
-    SERIAL_EOL();
-    safe_delay(25);
+      SERIAL_PROTOCOLLNPAIR("sizeof(ubl) :  ", (int)sizeof(ubl));
+      SERIAL_EOL();
+      SERIAL_PROTOCOLLNPAIR("z_value[][] size: ", (int)sizeof(z_values));
+      SERIAL_EOL();
+      safe_delay(25);
 
-    SERIAL_PROTOCOLLNPAIR("EEPROM free for UBL: ", hex_address((void*)(settings.get_end_of_meshes() - settings.get_start_of_meshes())));
-    safe_delay(50);
+      SERIAL_PROTOCOLLNPAIR("EEPROM free for UBL: ", hex_address((void*)(settings.get_end_of_meshes() - settings.get_start_of_meshes())));
+      safe_delay(50);
 
-    SERIAL_PROTOCOLPAIR("EEPROM can hold ", settings.calc_num_meshes());
-    SERIAL_PROTOCOLLNPGM(" meshes.\n");
-    safe_delay(25);
+      SERIAL_PROTOCOLPAIR("EEPROM can hold ", settings.calc_num_meshes());
+      SERIAL_PROTOCOLLNPGM(" meshes.\n");
+      safe_delay(25);
+    #endif // UBL_DEVEL_DEBUGGING
 
     if (!sanity_check()) {
       echo_name();
       SERIAL_PROTOCOLLNPGM(" sanity checks passed.");
     }
   }
 
   /**
    * When we are fully debugged, the EEPROM dump command will get deleted also. But
    * right now, it is good to have the extra information. Soon... we prune this.
@@ -1449,20 +1467,26 @@
           }
         }
       } // for j
     } // for i
 
     return out_mesh;
   }
 
   #if ENABLED(NEWPANEL)
 
+    void abort_fine_tune() {
+      lcd_return_to_status();
+      do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
+      LCD_MESSAGEPGM(MSG_EDITING_STOPPED);
+    }
+
     void unified_bed_leveling::fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map) {
       if (!parser.seen('R'))    // fine_tune_mesh() is special. If no repetition count flag is specified
         g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 
       #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
         const bool is_offset = parser.seen('H');
         const float h_offset = is_offset ? parser.value_linear_units() : Z_CLEARANCE_BETWEEN_PROBES;
         if (is_offset && !WITHIN(h_offset, 0, 10)) {
           SERIAL_PROTOCOLLNPGM("Offset out of bounds. (0 to 10mm)\n");
           return;
@@ -1506,51 +1530,40 @@
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show the user which point is being adjusted
 
         lcd_refresh();
 
         float new_z = z_values[location.x_index][location.y_index];
         if (isnan(new_z)) new_z = 0.0;          // Set invalid mesh points to 0.0 so they can be edited
         new_z = FLOOR(new_z * 1000.0) * 0.001;  // Chop off digits after the 1000ths place
 
         lcd_mesh_edit_setup(new_z);
 
-        do {
+        while (!is_lcd_clicked()) {
           new_z = lcd_mesh_edit();
           #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
             do_blocking_move_to_z(h_offset + new_z); // Move the nozzle as the point is edited
           #endif
           idle();
-        } while (!is_lcd_clicked());
+        }
 
         if (!lcd_map_control) lcd_return_to_status();
 
         // The technique used here generates a race condition for the encoder click.
         // It could get detected in lcd_mesh_edit (actually _lcd_mesh_fine_tune) or here.
         // Let's work on specifying a proper API for the LCD ASAP, OK?
         lcd_external_control = true;
 
         // this sequence to detect an is_lcd_clicked() debounce it and leave if it is
         // a Press and Hold is repeated in a lot of places (including G26_Mesh_Validation.cpp).   This
         // should be redone and compressed.
-        const millis_t nxt = millis() + 1500UL;
-        while (is_lcd_clicked()) { // debounce and watch for abort
-          idle();
-          if (ELAPSED(millis(), nxt)) {
-            lcd_return_to_status();
-            do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
-            LCD_MESSAGEPGM(MSG_EDITING_STOPPED);
-
-            while (is_lcd_clicked()) idle();
-
-            goto FINE_TUNE_EXIT;
-          }
-        }
+        if (click_and_hold(abort_fine_tune))
+          goto FINE_TUNE_EXIT;
 
         safe_delay(20);                       // We don't want any switch noise.
 
         z_values[location.x_index][location.y_index] = new_z;
 
         lcd_refresh();
 
       } while (location.x_index >= 0 && --g29_repetition_cnt > 0);
 
       FINE_TUNE_EXIT:

commit 2fde60da124fddb6cf2a8f15479680f3410b53af
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 16:56:30 2017 -0600

    Changes for parity with 1.1.x

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 641d67ed8f..573ab10ea8 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -451,21 +451,21 @@
             if (g29_verbose_level > 1) {
               SERIAL_PROTOCOLPAIR("Probing Mesh Points Closest to (", g29_x_pos);
               SERIAL_PROTOCOLCHAR(',');
               SERIAL_PROTOCOL(g29_y_pos);
               SERIAL_PROTOCOLLNPGM(").\n");
             }
             probe_entire_mesh(g29_x_pos + X_PROBE_OFFSET_FROM_EXTRUDER, g29_y_pos + Y_PROBE_OFFSET_FROM_EXTRUDER,
                               parser.seen('T'), parser.seen('E'), parser.seen('U'));
             break;
 
-        #endif
+        #endif // HAS_BED_PROBE
 
         case 2: {
           #if ENABLED(NEWPANEL)
             //
             // Manually Probe Mesh in areas that can't be reached by the probe
             //
             SERIAL_PROTOCOLLNPGM("Manually probing unreachable mesh locations.");
             do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
 
             if (!g29_x_flag && !g29_y_flag) {
@@ -906,21 +906,21 @@
           do_blocking_move_to_z(current_position[Z_AXIS] + 0.01 * float(encoder_diff));
           encoder_diff = 0;
         }
       }
       KEEPALIVE_STATE(IN_HANDLER);
       return current_position[Z_AXIS];
     }
 
     static void echo_and_take_a_measurement() { SERIAL_PROTOCOLLNPGM(" and take a measurement."); }
 
-    float unified_bed_leveling::measure_business_card_thickness(const float in_height) {
+    float unified_bed_leveling::measure_business_card_thickness(const float &in_height) {
       lcd_external_control = true;
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
       do_blocking_move_to(0.5 * (MESH_MAX_X - (MESH_MIN_X)), 0.5 * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
         //, min(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]) / 2.0);
       stepper.synchronize();
 
       SERIAL_PROTOCOLPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       lcd_return_to_status();
@@ -1026,21 +1026,20 @@
           SERIAL_EOL();
         }
       } while (location.x_index >= 0 && location.y_index >= 0);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);
 
       restore_ubl_active_state_and_leave();
       KEEPALIVE_STATE(IN_HANDLER);
       do_blocking_move_to(rx, ry, Z_CLEARANCE_DEPLOY_PROBE);
     }
-
   #endif // NEWPANEL
 
   bool unified_bed_leveling::g29_parameter_parsing() {
     bool err_flag = false;
 
     #if ENABLED(NEWPANEL)
       LCD_MESSAGEPGM(MSG_UBL_DOING_G29);
       lcd_quick_feedback();
     #endif
 
@@ -1071,25 +1070,25 @@
       const int pv = parser.value_int();
       #if !HAS_BED_PROBE
         if (pv == 1) {
           SERIAL_PROTOCOLLNPGM("G29 P1 requires a probe.\n");
           err_flag = true;
         }
         else
       #endif
         {
           g29_phase_value = pv;
-           if (!WITHIN(g29_phase_value, 0, 6)) {
-             SERIAL_PROTOCOLLNPGM("?(P)hase value invalid (0-6).\n");
-             err_flag = true;
-           }
-         }
+          if (!WITHIN(g29_phase_value, 0, 6)) {
+            SERIAL_PROTOCOLLNPGM("?(P)hase value invalid (0-6).\n");
+            err_flag = true;
+          }
+        }
     }
 
     if (parser.seen('J')) {
       #if HAS_BED_PROBE
         g29_grid_size = parser.has_value() ? parser.value_int() : 0;
         if (g29_grid_size && !WITHIN(g29_grid_size, 2, 9)) {
           SERIAL_PROTOCOLLNPGM("?Invalid grid size (J) specified (2-9).\n");
           err_flag = true;
         }
       #else
@@ -1334,38 +1333,37 @@
     settings.load_mesh(g29_storage_slot, &tmp_z_values);
 
     SERIAL_PROTOCOLPAIR("Subtracting mesh in slot ", g29_storage_slot);
     SERIAL_PROTOCOLLNPGM(" from current mesh.");
 
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
         z_values[x][y] -= tmp_z_values[x][y];
   }
 
-
   mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
 
-    bool found_a_NAN  = false;
-    bool found_a_real = false;
+    bool found_a_NAN  = false, found_a_real = false;
+
     mesh_index_pair out_mesh;
     out_mesh.x_index = out_mesh.y_index = -1;
     out_mesh.distance = -99999.99;
 
     for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
 
-        if ( isnan(z_values[i][j])) { // Check to see if this location holds an invalid mesh point
+        if (isnan(z_values[i][j])) { // Check to see if this location holds an invalid mesh point
 
           const float mx = mesh_index_to_xpos(i),
                       my = mesh_index_to_ypos(j);
 
-          if ( !position_is_reachable_by_probe(mx, my))  // make sure the probe can get to the mesh point
+          if (!position_is_reachable_by_probe(mx, my))  // make sure the probe can get to the mesh point
             continue;
 
           found_a_NAN = true;
 
           int8_t closest_x=-1, closest_y=-1;
           float d1, d2 = 99999.9;
           for (int8_t k = 0; k < GRID_MAX_POINTS_X; k++) {
             for (int8_t l = 0; l < GRID_MAX_POINTS_Y; l++) {
               if (!isnan(z_values[k][l])) {
                 found_a_real = true;
@@ -1445,20 +1443,21 @@
           distance += HYPOT(current_position[X_AXIS] - mx, current_position[Y_AXIS] - my) * 0.1;
           if (distance < best_so_far) {
             best_so_far = distance;   // We found a closer location with
             out_mesh.x_index = i;     // the specified type of mesh value.
             out_mesh.y_index = j;
             out_mesh.distance = best_so_far;
           }
         }
       } // for j
     } // for i
+
     return out_mesh;
   }
 
   #if ENABLED(NEWPANEL)
 
     void unified_bed_leveling::fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map) {
       if (!parser.seen('R'))    // fine_tune_mesh() is special. If no repetition count flag is specified
         g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 
       #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
@@ -1492,36 +1491,33 @@
 
         bitmap_clear(not_done, location.x_index, location.y_index); // Mark this location as 'adjusted' so we will find a
                                                                     // different location the next time through the loop
 
         const float rawx = mesh_index_to_xpos(location.x_index),
                     rawy = mesh_index_to_ypos(location.y_index);
 
         if (!position_is_reachable(rawx, rawy)) // SHOULD NOT OCCUR because find_closest_mesh_point_of_type will only return reachable
           break;
 
-        float new_z = z_values[location.x_index][location.y_index];
-
-        if (isnan(new_z)) // if the mesh point is invalid, set it to 0.0 so it can be edited
-          new_z = 0.0;
-
         do_blocking_move_to(rawx, rawy, Z_CLEARANCE_BETWEEN_PROBES); // Move the nozzle to the edit point
 
-        new_z = FLOOR(new_z * 1000.0) * 0.001; // Chop off digits after the 1000ths place
-
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         lcd_external_control = true;
 
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show the user which point is being adjusted
 
         lcd_refresh();
 
+        float new_z = z_values[location.x_index][location.y_index];
+        if (isnan(new_z)) new_z = 0.0;          // Set invalid mesh points to 0.0 so they can be edited
+        new_z = FLOOR(new_z * 1000.0) * 0.001;  // Chop off digits after the 1000ths place
+
         lcd_mesh_edit_setup(new_z);
 
         do {
           new_z = lcd_mesh_edit();
           #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
             do_blocking_move_to_z(h_offset + new_z); // Move the nozzle as the point is edited
           #endif
           idle();
         } while (!is_lcd_clicked());
 

commit e48fcad615092e34ae0dcf2e08753fb03f525b8f
Author: Roxy-3D <Roxanne.Rae.Neufeld@gmail.com>
Date:   Sat Nov 25 19:35:27 2017 -0600

    change G26 and G29 bit function names to avoid HAL collision

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 14e04bcf73..641d67ed8f 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1415,21 +1415,21 @@
     const float px = rx - (probe_as_reference == USE_PROBE_AS_REFERENCE ? X_PROBE_OFFSET_FROM_EXTRUDER : 0),
                 py = ry - (probe_as_reference == USE_PROBE_AS_REFERENCE ? Y_PROBE_OFFSET_FROM_EXTRUDER : 0);
 
     float best_so_far = 99999.99;
 
     for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
 
         if ( (type == INVALID && isnan(z_values[i][j]))  // Check to see if this location holds the right thing
           || (type == REAL && !isnan(z_values[i][j]))
-          || (type == SET_IN_BITMAP && is_bit_set(bits, i, j))
+          || (type == SET_IN_BITMAP && is_bitmap_set(bits, i, j))
         ) {
           // We only get here if we found a Mesh Point of the specified type
 
           const float mx = mesh_index_to_xpos(i),
                       my = mesh_index_to_ypos(j);
 
           // If using the probe as the reference there are some unreachable locations.
           // Also for round beds, there are grid points outside the bed the nozzle can't reach.
           // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
@@ -1483,22 +1483,22 @@
 
       do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);
 
       uint16_t not_done[16];
       memset(not_done, 0xFF, sizeof(not_done));
       do {
         location = find_closest_mesh_point_of_type(SET_IN_BITMAP, rx, ry, USE_NOZZLE_AS_REFERENCE, not_done);
 
         if (location.x_index < 0) break; // stop when we can't find any more reachable points.
 
-        bit_clear(not_done, location.x_index, location.y_index);  // Mark this location as 'adjusted' so we will find a
-                                                                  // different location the next time through the loop
+        bitmap_clear(not_done, location.x_index, location.y_index); // Mark this location as 'adjusted' so we will find a
+                                                                    // different location the next time through the loop
 
         const float rawx = mesh_index_to_xpos(location.x_index),
                     rawy = mesh_index_to_ypos(location.y_index);
 
         if (!position_is_reachable(rawx, rawy)) // SHOULD NOT OCCUR because find_closest_mesh_point_of_type will only return reachable
           break;
 
         float new_z = z_values[location.x_index][location.y_index];
 
         if (isnan(new_z)) // if the mesh point is invalid, set it to 0.0 so it can be edited

commit b49acce0352c7fda835f0b6b1db042ee20747579
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 24 15:46:45 2017 -0600

    Tweaks for lcd_external_control

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 4b1ce5936a..14e04bcf73 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1002,25 +1002,23 @@
         // this sequence to detect an is_lcd_clicked() debounce it and leave if it is
         // a Press and Hold is repeated in a lot of places (including G26_Mesh_Validation.cpp).   This
         // should be redone and compressed.
         const millis_t nxt = millis() + 1500L;
         while (is_lcd_clicked()) {     // debounce and watch for abort
           idle();
           if (ELAPSED(millis(), nxt)) {
             SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.");
             do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
 
-            #if ENABLED(NEWPANEL)
-              lcd_quick_feedback();
-              while (is_lcd_clicked()) idle();
-              lcd_external_control = false;
-            #endif
+            lcd_quick_feedback();
+            while (is_lcd_clicked()) idle();
+            lcd_external_control = false;
 
             KEEPALIVE_STATE(IN_HANDLER);
             restore_ubl_active_state_and_leave();
             return;
           }
         }
 
         z_values[location.x_index][location.y_index] = current_position[Z_AXIS] - thick;
         if (g29_verbose_level > 2) {
           SERIAL_PROTOCOLPGM("Mesh Point Measured at: ");

commit c6b0c104bbab04d4d59c4f3f8fddb728e9b99603
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 23 17:59:43 2017 -0600

    Adapt G26 to work for all meshes

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 94bc875f00..4b1ce5936a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -670,22 +670,21 @@
 
     if (parser.seen('T'))
       display_map(g29_map_type);
 
     LEAVE:
 
     #if ENABLED(NEWPANEL)
       lcd_reset_alert_level();
       LCD_MESSAGEPGM("");
       lcd_quick_feedback();
-
-      has_control_of_lcd_panel = false;
+      lcd_external_control = false;
     #endif
 
     return;
   }
 
   void unified_bed_leveling::find_mean_mesh_height() {
     float sum = 0.0;
     int n = 0;
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
@@ -731,36 +730,39 @@
 
   #if HAS_BED_PROBE
 
     /**
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
     void unified_bed_leveling::probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, bool close_or_far) {
       mesh_index_pair location;
 
-      has_control_of_lcd_panel = true;
+      #if ENABLED(NEWPANEL)
+        lcd_external_control = true;
+      #endif
+
       save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
       DEPLOY_PROBE();
 
       uint16_t max_iterations = GRID_MAX_POINTS;
 
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
 
         #if ENABLED(NEWPANEL)
-          if (ubl_lcd_clicked()) {
+          if (is_lcd_clicked()) {
             SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.\n");
             lcd_quick_feedback();
             STOW_PROBE();
-            while (ubl_lcd_clicked()) idle();
-            has_control_of_lcd_panel = false;
+            while (is_lcd_clicked()) idle();
+            lcd_external_control = false;
             restore_ubl_active_state_and_leave();
             safe_delay(50);  // Debounce the Encoder wheel
             return;
           }
         #endif
 
         if (close_or_far)
           location = find_furthest_invalid_mesh_point();
         else
           location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, NULL);
@@ -887,39 +889,39 @@
         }
       }
     }
 
   #endif // HAS_BED_PROBE
 
   #if ENABLED(NEWPANEL)
 
     float unified_bed_leveling::measure_point_with_encoder() {
 
-      while (ubl_lcd_clicked()) delay(50);  // wait for user to release encoder wheel
+      while (is_lcd_clicked()) delay(50);  // wait for user to release encoder wheel
       delay(50);  // debounce
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
-      while (!ubl_lcd_clicked()) {     // we need the loop to move the nozzle based on the encoder wheel here!
+      while (!is_lcd_clicked()) {     // we need the loop to move the nozzle based on the encoder wheel here!
         idle();
         if (encoder_diff) {
           do_blocking_move_to_z(current_position[Z_AXIS] + 0.01 * float(encoder_diff));
           encoder_diff = 0;
         }
       }
       KEEPALIVE_STATE(IN_HANDLER);
       return current_position[Z_AXIS];
     }
 
     static void echo_and_take_a_measurement() { SERIAL_PROTOCOLLNPGM(" and take a measurement."); }
 
     float unified_bed_leveling::measure_business_card_thickness(const float in_height) {
-      has_control_of_lcd_panel = true;
+      lcd_external_control = true;
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
       do_blocking_move_to(0.5 * (MESH_MAX_X - (MESH_MIN_X)), 0.5 * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
         //, min(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]) / 2.0);
       stepper.synchronize();
 
       SERIAL_PROTOCOLPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       lcd_return_to_status();
       echo_and_take_a_measurement();
@@ -937,30 +939,30 @@
       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES);
 
       const float thickness = abs(z1 - z2);
 
       if (g29_verbose_level > 1) {
         SERIAL_PROTOCOLPGM("Business Card is ");
         SERIAL_PROTOCOL_F(thickness, 4);
         SERIAL_PROTOCOLLNPGM("mm thick.");
       }
 
-      has_control_of_lcd_panel = false;
+      lcd_external_control = false;
 
       restore_ubl_active_state_and_leave();
 
       return thickness;
     }
 
     void unified_bed_leveling::manually_probe_remaining_mesh(const float &rx, const float &ry, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
 
-      has_control_of_lcd_panel = true;
+      lcd_external_control = true;
 
       save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
 
       do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);
 
       lcd_return_to_status();
 
       mesh_index_pair location;
       do {
         location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_NOZZLE_AS_REFERENCE, NULL);
@@ -971,53 +973,53 @@
                     yProbe = mesh_index_to_ypos(location.y_index);
 
         if (!position_is_reachable(xProbe, yProbe)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
 
         LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
 
         do_blocking_move_to(xProbe, yProbe, Z_CLEARANCE_BETWEEN_PROBES);
         do_blocking_move_to_z(z_clearance);
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
-        has_control_of_lcd_panel = true;
+        lcd_external_control = true;
 
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
         serialprintPGM(parser.seen('B') ? PSTR(MSG_UBL_BC_INSERT) : PSTR(MSG_UBL_BC_INSERT2));
 
         const float z_step = 0.01;                                        // existing behavior: 0.01mm per click, occasionally step
         //const float z_step = 1.0 / planner.axis_steps_per_mm[Z_AXIS];   // approx one step each click
 
-        while (ubl_lcd_clicked()) delay(50);             // wait for user to release encoder wheel
+        while (is_lcd_clicked()) delay(50);             // wait for user to release encoder wheel
         delay(50);                                       // debounce
-        while (!ubl_lcd_clicked()) {                     // we need the loop to move the nozzle based on the encoder wheel here!
+        while (!is_lcd_clicked()) {                     // we need the loop to move the nozzle based on the encoder wheel here!
           idle();
           if (encoder_diff) {
             do_blocking_move_to_z(current_position[Z_AXIS] + float(encoder_diff) * z_step);
             encoder_diff = 0;
           }
         }
 
-        // this sequence to detect an ubl_lcd_clicked() debounce it and leave if it is
+        // this sequence to detect an is_lcd_clicked() debounce it and leave if it is
         // a Press and Hold is repeated in a lot of places (including G26_Mesh_Validation.cpp).   This
         // should be redone and compressed.
         const millis_t nxt = millis() + 1500L;
-        while (ubl_lcd_clicked()) {     // debounce and watch for abort
+        while (is_lcd_clicked()) {     // debounce and watch for abort
           idle();
           if (ELAPSED(millis(), nxt)) {
             SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.");
             do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
 
             #if ENABLED(NEWPANEL)
               lcd_quick_feedback();
-              while (ubl_lcd_clicked()) idle();
-              has_control_of_lcd_panel = false;
+              while (is_lcd_clicked()) idle();
+              lcd_external_control = false;
             #endif
 
             KEEPALIVE_STATE(IN_HANDLER);
             restore_ubl_active_state_and_leave();
             return;
           }
         }
 
         z_values[location.x_index][location.y_index] = current_position[Z_AXIS] - thick;
         if (g29_verbose_level > 2) {
@@ -1502,71 +1504,71 @@
         float new_z = z_values[location.x_index][location.y_index];
 
         if (isnan(new_z)) // if the mesh point is invalid, set it to 0.0 so it can be edited
           new_z = 0.0;
 
         do_blocking_move_to(rawx, rawy, Z_CLEARANCE_BETWEEN_PROBES); // Move the nozzle to the edit point
 
         new_z = FLOOR(new_z * 1000.0) * 0.001; // Chop off digits after the 1000ths place
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
-        has_control_of_lcd_panel = true;
+        lcd_external_control = true;
 
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show the user which point is being adjusted
 
         lcd_refresh();
 
         lcd_mesh_edit_setup(new_z);
 
         do {
           new_z = lcd_mesh_edit();
           #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
             do_blocking_move_to_z(h_offset + new_z); // Move the nozzle as the point is edited
           #endif
           idle();
-        } while (!ubl_lcd_clicked());
+        } while (!is_lcd_clicked());
 
         if (!lcd_map_control) lcd_return_to_status();
 
         // The technique used here generates a race condition for the encoder click.
         // It could get detected in lcd_mesh_edit (actually _lcd_mesh_fine_tune) or here.
         // Let's work on specifying a proper API for the LCD ASAP, OK?
-        has_control_of_lcd_panel = true;
+        lcd_external_control = true;
 
-        // this sequence to detect an ubl_lcd_clicked() debounce it and leave if it is
+        // this sequence to detect an is_lcd_clicked() debounce it and leave if it is
         // a Press and Hold is repeated in a lot of places (including G26_Mesh_Validation.cpp).   This
         // should be redone and compressed.
         const millis_t nxt = millis() + 1500UL;
-        while (ubl_lcd_clicked()) { // debounce and watch for abort
+        while (is_lcd_clicked()) { // debounce and watch for abort
           idle();
           if (ELAPSED(millis(), nxt)) {
             lcd_return_to_status();
             do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
             LCD_MESSAGEPGM(MSG_EDITING_STOPPED);
 
-            while (ubl_lcd_clicked()) idle();
+            while (is_lcd_clicked()) idle();
 
             goto FINE_TUNE_EXIT;
           }
         }
 
         safe_delay(20);                       // We don't want any switch noise.
 
         z_values[location.x_index][location.y_index] = new_z;
 
         lcd_refresh();
 
       } while (location.x_index >= 0 && --g29_repetition_cnt > 0);
 
       FINE_TUNE_EXIT:
 
-      has_control_of_lcd_panel = false;
+      lcd_external_control = false;
       KEEPALIVE_STATE(IN_HANDLER);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);
 
       LCD_MESSAGEPGM(MSG_UBL_DONE_EDITING_MESH);
       SERIAL_ECHOLNPGM("Done Editing Mesh");
 

commit d4a1154c25093c35d4bc940c5f0017e4ff48d2c7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 10 20:49:37 2017 -0600

    Use do_blocking_move_to where possible

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 57bcabf35e..94bc875f00 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -460,20 +460,21 @@
 
         #endif
 
         case 2: {
           #if ENABLED(NEWPANEL)
             //
             // Manually Probe Mesh in areas that can't be reached by the probe
             //
             SERIAL_PROTOCOLLNPGM("Manually probing unreachable mesh locations.");
             do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
+
             if (!g29_x_flag && !g29_y_flag) {
               /**
                * Use a good default location for the path.
                * The flipped > and < operators in these comparisons is intentional.
                * It should cause the probed points to follow a nice path on Cartesian printers.
                * It may make sense to have Delta printers default to the center of the bed.
                * Until that is decided, this can be forced with the X and Y parameters.
                */
               #if IS_KINEMATIC
                 g29_x_pos = X_HOME_POS;
@@ -903,26 +904,25 @@
           do_blocking_move_to_z(current_position[Z_AXIS] + 0.01 * float(encoder_diff));
           encoder_diff = 0;
         }
       }
       KEEPALIVE_STATE(IN_HANDLER);
       return current_position[Z_AXIS];
     }
 
     static void echo_and_take_a_measurement() { SERIAL_PROTOCOLLNPGM(" and take a measurement."); }
 
-    float unified_bed_leveling::measure_business_card_thickness(float in_height) {
+    float unified_bed_leveling::measure_business_card_thickness(const float in_height) {
       has_control_of_lcd_panel = true;
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
-      do_blocking_move_to_z(in_height);
-      do_blocking_move_to_xy(0.5 * (MESH_MAX_X - (MESH_MIN_X)), 0.5 * (MESH_MAX_Y - (MESH_MIN_Y)));
+      do_blocking_move_to(0.5 * (MESH_MAX_X - (MESH_MIN_X)), 0.5 * (MESH_MAX_Y - (MESH_MIN_Y)), in_height);
         //, min(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]) / 2.0);
       stepper.synchronize();
 
       SERIAL_PROTOCOLPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       lcd_return_to_status();
       echo_and_take_a_measurement();
 
       const float z1 = measure_point_with_encoder();
       do_blocking_move_to_z(current_position[Z_AXIS] + SIZE_OF_LITTLE_RAISE);
@@ -937,55 +937,51 @@
       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES);
 
       const float thickness = abs(z1 - z2);
 
       if (g29_verbose_level > 1) {
         SERIAL_PROTOCOLPGM("Business Card is ");
         SERIAL_PROTOCOL_F(thickness, 4);
         SERIAL_PROTOCOLLNPGM("mm thick.");
       }
 
-      in_height = current_position[Z_AXIS]; // do manual probing at lower height
-
       has_control_of_lcd_panel = false;
 
       restore_ubl_active_state_and_leave();
 
       return thickness;
     }
 
     void unified_bed_leveling::manually_probe_remaining_mesh(const float &rx, const float &ry, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
 
       has_control_of_lcd_panel = true;
 
       save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
-      do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
-      do_blocking_move_to_xy(rx, ry);
+
+      do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);
 
       lcd_return_to_status();
 
       mesh_index_pair location;
       do {
         location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_NOZZLE_AS_REFERENCE, NULL);
         // It doesn't matter if the probe can't reach the NAN location. This is a manual probe.
         if (location.x_index < 0 && location.y_index < 0) continue;
 
         const float xProbe = mesh_index_to_xpos(location.x_index),
                     yProbe = mesh_index_to_ypos(location.y_index);
 
         if (!position_is_reachable(xProbe, yProbe)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
 
-        do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
-
         LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
 
-        do_blocking_move_to_xy(xProbe, yProbe);
+        do_blocking_move_to(xProbe, yProbe, Z_CLEARANCE_BETWEEN_PROBES);
         do_blocking_move_to_z(z_clearance);
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         has_control_of_lcd_panel = true;
 
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
 
         serialprintPGM(parser.seen('B') ? PSTR(MSG_UBL_BC_INSERT) : PSTR(MSG_UBL_BC_INSERT2));
 
         const float z_step = 0.01;                                        // existing behavior: 0.01mm per click, occasionally step
@@ -1028,22 +1024,21 @@
           SERIAL_PROTOCOLPGM("Mesh Point Measured at: ");
           SERIAL_PROTOCOL_F(z_values[location.x_index][location.y_index], 6);
           SERIAL_EOL();
         }
       } while (location.x_index >= 0 && location.y_index >= 0);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);
 
       restore_ubl_active_state_and_leave();
       KEEPALIVE_STATE(IN_HANDLER);
-      do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
-      do_blocking_move_to_xy(rx, ry);
+      do_blocking_move_to(rx, ry, Z_CLEARANCE_DEPLOY_PROBE);
     }
 
   #endif // NEWPANEL
 
   bool unified_bed_leveling::g29_parameter_parsing() {
     bool err_flag = false;
 
     #if ENABLED(NEWPANEL)
       LCD_MESSAGEPGM(MSG_UBL_DOING_G29);
       lcd_quick_feedback();
@@ -1479,22 +1474,21 @@
 
       if (!position_is_reachable(rx, ry)) {
         SERIAL_PROTOCOLLNPGM("(X,Y) outside printable radius.");
         return;
       }
 
       save_ubl_active_state_and_disable();
 
       LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
 
-      do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
-      do_blocking_move_to_xy(rx, ry);
+      do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);
 
       uint16_t not_done[16];
       memset(not_done, 0xFF, sizeof(not_done));
       do {
         location = find_closest_mesh_point_of_type(SET_IN_BITMAP, rx, ry, USE_NOZZLE_AS_REFERENCE, not_done);
 
         if (location.x_index < 0) break; // stop when we can't find any more reachable points.
 
         bit_clear(not_done, location.x_index, location.y_index);  // Mark this location as 'adjusted' so we will find a
                                                                   // different location the next time through the loop
@@ -1503,22 +1497,21 @@
                     rawy = mesh_index_to_ypos(location.y_index);
 
         if (!position_is_reachable(rawx, rawy)) // SHOULD NOT OCCUR because find_closest_mesh_point_of_type will only return reachable
           break;
 
         float new_z = z_values[location.x_index][location.y_index];
 
         if (isnan(new_z)) // if the mesh point is invalid, set it to 0.0 so it can be edited
           new_z = 0.0;
 
-        do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);    // Move the nozzle to where we are going to edit
-        do_blocking_move_to_xy(rawx, rawy);
+        do_blocking_move_to(rawx, rawy, Z_CLEARANCE_BETWEEN_PROBES); // Move the nozzle to the edit point
 
         new_z = FLOOR(new_z * 1000.0) * 0.001; // Chop off digits after the 1000ths place
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         has_control_of_lcd_panel = true;
 
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show the user which point is being adjusted
 
         lcd_refresh();
 
@@ -1564,23 +1557,22 @@
 
       } while (location.x_index >= 0 && --g29_repetition_cnt > 0);
 
       FINE_TUNE_EXIT:
 
       has_control_of_lcd_panel = false;
       KEEPALIVE_STATE(IN_HANDLER);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);
       restore_ubl_active_state_and_leave();
-      do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
 
-      do_blocking_move_to_xy(rx, ry);
+      do_blocking_move_to(rx, ry, Z_CLEARANCE_BETWEEN_PROBES);
 
       LCD_MESSAGEPGM(MSG_UBL_DONE_EDITING_MESH);
       SERIAL_ECHOLNPGM("Done Editing Mesh");
 
       if (lcd_map_control)
         lcd_goto_screen(_lcd_ubl_output_map_lcd);
       else
         lcd_return_to_status();
     }
 

commit 8805e24cc7f52059bd8ac18fd61670d03286e616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 8 20:06:20 2017 -0600

    Fix tilt_mesh_based_on_probed_grid output bug

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index fef48bac9e..57bcabf35e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1658,21 +1658,21 @@
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_CHAR('(');
               SERIAL_PROTOCOL_F(rx, 7);
               SERIAL_CHAR(',');
               SERIAL_PROTOCOL_F(ry, 7);
               SERIAL_ECHOPGM(")   logical: ");
               SERIAL_CHAR('(');
               SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 7);
               SERIAL_CHAR(',');
-              SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(ry), 7);
+              SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 7);
               SERIAL_ECHOPGM(")   measured: ");
               SERIAL_PROTOCOL_F(measured_z, 7);
               SERIAL_ECHOPGM("   correction: ");
               SERIAL_PROTOCOL_F(get_z_correction(rx, ry), 7);
             }
           #endif
 
           measured_z -= get_z_correction(rx, ry) /* + zprobe_zoffset */ ;
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)

commit f8393a09086f01eafbb8563411da3b237c96b982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 2 23:59:42 2017 -0500

    Operate in Native Machine Space

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index edb862ce11..fef48bac9e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -386,41 +386,41 @@
 
     #if HAS_BED_PROBE
 
       if (parser.seen('J')) {
         if (g29_grid_size) {  // if not 0 it is a normal n x n grid being probed
           save_ubl_active_state_and_disable();
           tilt_mesh_based_on_probed_grid(parser.seen('T'));
           restore_ubl_active_state_and_leave();
         }
         else { // grid_size == 0 : A 3-Point leveling has been requested
-          float z3, z2, z1 = probe_pt(LOGICAL_X_POSITION(UBL_PROBE_PT_1_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_1_Y), false, g29_verbose_level);
+          float z3, z2, z1 = probe_pt(UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y, false, g29_verbose_level);
           if (!isnan(z1)) {
-            z2 = probe_pt(LOGICAL_X_POSITION(UBL_PROBE_PT_2_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_2_Y), false, g29_verbose_level);
+            z2 = probe_pt(UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y, false, g29_verbose_level);
             if (!isnan(z2))
-              z3 = probe_pt(LOGICAL_X_POSITION(UBL_PROBE_PT_3_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_3_Y), true, g29_verbose_level);
+              z3 = probe_pt(UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y, true, g29_verbose_level);
           }
 
           if (isnan(z1) || isnan(z2) || isnan(z3)) { // probe_pt will return NAN if unreachable
             SERIAL_ERROR_START();
             SERIAL_ERRORLNPGM("Attempt to probe off the bed.");
             goto LEAVE;
           }
 
           // Adjust z1, z2, z3 by the Mesh Height at these points. Just because they're non-zero
           // doesn't mean the Mesh is tilted! (Compensate each probe point by what the Mesh says
           // its height is.)
 
           save_ubl_active_state_and_disable();
-          z1 -= get_z_correction(LOGICAL_X_POSITION(UBL_PROBE_PT_1_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_1_Y)) /* + zprobe_zoffset */ ;
-          z2 -= get_z_correction(LOGICAL_X_POSITION(UBL_PROBE_PT_2_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_2_Y)) /* + zprobe_zoffset */ ;
-          z3 -= get_z_correction(LOGICAL_X_POSITION(UBL_PROBE_PT_3_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_3_Y)) /* + zprobe_zoffset */ ;
+          z1 -= get_z_correction(UBL_PROBE_PT_1_X, UBL_PROBE_PT_1_Y) /* + zprobe_zoffset */ ;
+          z2 -= get_z_correction(UBL_PROBE_PT_2_X, UBL_PROBE_PT_2_Y) /* + zprobe_zoffset */ ;
+          z3 -= get_z_correction(UBL_PROBE_PT_3_X, UBL_PROBE_PT_3_Y) /* + zprobe_zoffset */ ;
 
           do_blocking_move_to_xy(0.5 * (MESH_MAX_X - (MESH_MIN_X)), 0.5 * (MESH_MAX_Y - (MESH_MIN_Y)));
           tilt_mesh_based_on_3pts(z1, z2, z3);
           restore_ubl_active_state_and_leave();
         }
       }
 
     #endif // HAS_BED_PROBE
 
     if (parser.seen('P')) {
@@ -490,21 +490,21 @@
             }
 
             if (parser.seen('B')) {
               g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness(Z_CLEARANCE_BETWEEN_PROBES);
               if (FABS(g29_card_thickness) > 1.5) {
                 SERIAL_PROTOCOLLNPGM("?Error in Business Card measurement.");
                 return;
               }
             }
 
-            if (!position_is_reachable_xy(g29_x_pos, g29_y_pos)) {
+            if (!position_is_reachable(g29_x_pos, g29_y_pos)) {
               SERIAL_PROTOCOLLNPGM("XY outside printable radius.");
               return;
             }
 
             const float height = parser.floatval('H', Z_CLEARANCE_BETWEEN_PROBES);
             manually_probe_remaining_mesh(g29_x_pos, g29_y_pos, height, g29_card_thickness, parser.seen('T'));
 
             SERIAL_PROTOCOLLNPGM("G29 P2 finished.");
 
           #else
@@ -727,21 +727,21 @@
         if (!isnan(z_values[x][y]))
           z_values[x][y] += g29_constant;
   }
 
   #if HAS_BED_PROBE
 
     /**
      * Probe all invalidated locations of the mesh that can be reached by the probe.
      * This attempts to fill in locations closest to the nozzle's start location first.
      */
-    void unified_bed_leveling::probe_entire_mesh(const float &lx, const float &ly, const bool do_ubl_mesh_map, const bool stow_probe, bool close_or_far) {
+    void unified_bed_leveling::probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, bool close_or_far) {
       mesh_index_pair location;
 
       has_control_of_lcd_panel = true;
       save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
       DEPLOY_PROBE();
 
       uint16_t max_iterations = GRID_MAX_POINTS;
 
       do {
         if (do_ubl_mesh_map) display_map(g29_map_type);
@@ -755,38 +755,38 @@
             has_control_of_lcd_panel = false;
             restore_ubl_active_state_and_leave();
             safe_delay(50);  // Debounce the Encoder wheel
             return;
           }
         #endif
 
         if (close_or_far)
           location = find_furthest_invalid_mesh_point();
         else
-          location = find_closest_mesh_point_of_type(INVALID, lx, ly, USE_PROBE_AS_REFERENCE, NULL);
+          location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_PROBE_AS_REFERENCE, NULL);
 
         if (location.x_index >= 0) {    // mesh point found and is reachable by probe
           const float rawx = mesh_index_to_xpos(location.x_index),
                       rawy = mesh_index_to_ypos(location.y_index);
 
-          const float measured_z = probe_pt(LOGICAL_X_POSITION(rawx), LOGICAL_Y_POSITION(rawy), stow_probe, g29_verbose_level); // TODO: Needs error handling
+          const float measured_z = probe_pt(rawx, rawy, stow_probe, g29_verbose_level); // TODO: Needs error handling
           z_values[location.x_index][location.y_index] = measured_z;
         }
 
       } while (location.x_index >= 0 && --max_iterations);
 
       STOW_PROBE();
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
-        constrain(lx - (X_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_X, MESH_MAX_X),
-        constrain(ly - (Y_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_Y, MESH_MAX_Y)
+        constrain(rx - (X_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_X, MESH_MAX_X),
+        constrain(ry - (Y_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 
     void unified_bed_leveling::tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3) {
       matrix_3x3 rotation;
       vector_3 v1 = vector_3( (UBL_PROBE_PT_1_X - UBL_PROBE_PT_2_X),
                               (UBL_PROBE_PT_1_Y - UBL_PROBE_PT_2_Y),
                               (z1 - z2) ),
 
                v2 = vector_3( (UBL_PROBE_PT_3_X - UBL_PROBE_PT_2_X),
@@ -946,42 +946,40 @@
 
       in_height = current_position[Z_AXIS]; // do manual probing at lower height
 
       has_control_of_lcd_panel = false;
 
       restore_ubl_active_state_and_leave();
 
       return thickness;
     }
 
-    void unified_bed_leveling::manually_probe_remaining_mesh(const float &lx, const float &ly, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
+    void unified_bed_leveling::manually_probe_remaining_mesh(const float &rx, const float &ry, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
 
       has_control_of_lcd_panel = true;
 
       save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
       do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
-      do_blocking_move_to_xy(lx, ly);
+      do_blocking_move_to_xy(rx, ry);
 
       lcd_return_to_status();
 
       mesh_index_pair location;
       do {
-        location = find_closest_mesh_point_of_type(INVALID, lx, ly, USE_NOZZLE_AS_REFERENCE, NULL);
+        location = find_closest_mesh_point_of_type(INVALID, rx, ry, USE_NOZZLE_AS_REFERENCE, NULL);
         // It doesn't matter if the probe can't reach the NAN location. This is a manual probe.
         if (location.x_index < 0 && location.y_index < 0) continue;
 
-        const float rawx = mesh_index_to_xpos(location.x_index),
-                    rawy = mesh_index_to_ypos(location.y_index),
-                    xProbe = LOGICAL_X_POSITION(rawx),
-                    yProbe = LOGICAL_Y_POSITION(rawy);
+        const float xProbe = mesh_index_to_xpos(location.x_index),
+                    yProbe = mesh_index_to_ypos(location.y_index);
 
-        if (!position_is_reachable_raw_xy(rawx, rawy)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
+        if (!position_is_reachable(xProbe, yProbe)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
 
         do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
 
         LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
 
         do_blocking_move_to_xy(xProbe, yProbe);
         do_blocking_move_to_z(z_clearance);
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         has_control_of_lcd_panel = true;
@@ -1031,21 +1029,21 @@
           SERIAL_PROTOCOL_F(z_values[location.x_index][location.y_index], 6);
           SERIAL_EOL();
         }
       } while (location.x_index >= 0 && location.y_index >= 0);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);
 
       restore_ubl_active_state_and_leave();
       KEEPALIVE_STATE(IN_HANDLER);
       do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
-      do_blocking_move_to_xy(lx, ly);
+      do_blocking_move_to_xy(rx, ry);
     }
 
   #endif // NEWPANEL
 
   bool unified_bed_leveling::g29_parameter_parsing() {
     bool err_flag = false;
 
     #if ENABLED(NEWPANEL)
       LCD_MESSAGEPGM(MSG_UBL_DOING_G29);
       lcd_quick_feedback();
@@ -1104,22 +1102,22 @@
         err_flag = true;
       #endif
     }
 
     if (g29_x_flag != g29_y_flag) {
       SERIAL_PROTOCOLLNPGM("Both X & Y locations must be specified.\n");
       err_flag = true;
     }
 
     // If X or Y are not valid, use center of the bed values
-    if (!WITHIN(RAW_X_POSITION(g29_x_pos), X_MIN_BED, X_MAX_BED)) g29_x_pos = LOGICAL_X_POSITION(X_CENTER);
-    if (!WITHIN(RAW_Y_POSITION(g29_y_pos), Y_MIN_BED, Y_MAX_BED)) g29_y_pos = LOGICAL_Y_POSITION(Y_CENTER);
+    if (!WITHIN(g29_x_pos, X_MIN_BED, X_MAX_BED)) g29_x_pos = X_CENTER;
+    if (!WITHIN(g29_y_pos, Y_MIN_BED, Y_MAX_BED)) g29_y_pos = Y_CENTER;
 
     if (err_flag) return UBL_ERR;
 
     /**
      * Activate or deactivate UBL
      * Note: UBL's G29 restores the state set here when done.
      *       Leveling is being enabled here with old data, possibly
      *       none. Error handling should disable for safety...
      */
     if (parser.seen('A')) {
@@ -1358,21 +1356,21 @@
     out_mesh.distance = -99999.99;
 
     for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
 
         if ( isnan(z_values[i][j])) { // Check to see if this location holds an invalid mesh point
 
           const float mx = mesh_index_to_xpos(i),
                       my = mesh_index_to_ypos(j);
 
-          if ( !position_is_reachable_by_probe_raw_xy(mx, my))  // make sure the probe can get to the mesh point
+          if ( !position_is_reachable_by_probe(mx, my))  // make sure the probe can get to the mesh point
             continue;
 
           found_a_NAN = true;
 
           int8_t closest_x=-1, closest_y=-1;
           float d1, d2 = 99999.9;
           for (int8_t k = 0; k < GRID_MAX_POINTS_X; k++) {
             for (int8_t l = 0; l < GRID_MAX_POINTS_Y; l++) {
               if (!isnan(z_values[k][l])) {
                 found_a_real = true;
@@ -1406,122 +1404,121 @@
     } // for i
 
     if (!found_a_real && found_a_NAN) {        // if the mesh is totally unpopulated, start the probing
       out_mesh.x_index = GRID_MAX_POINTS_X / 2;
       out_mesh.y_index = GRID_MAX_POINTS_Y / 2;
       out_mesh.distance = 1.0;
     }
     return out_mesh;
   }
 
-  mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const float &lx, const float &ly, const bool probe_as_reference, uint16_t bits[16]) {
+  mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const float &rx, const float &ry, const bool probe_as_reference, uint16_t bits[16]) {
     mesh_index_pair out_mesh;
     out_mesh.x_index = out_mesh.y_index = -1;
     out_mesh.distance = -99999.9;
 
     // Get our reference position. Either the nozzle or probe location.
-    const float px = RAW_X_POSITION(lx) - (probe_as_reference == USE_PROBE_AS_REFERENCE ? X_PROBE_OFFSET_FROM_EXTRUDER : 0),
-                py = RAW_Y_POSITION(ly) - (probe_as_reference == USE_PROBE_AS_REFERENCE ? Y_PROBE_OFFSET_FROM_EXTRUDER : 0);
+    const float px = rx - (probe_as_reference == USE_PROBE_AS_REFERENCE ? X_PROBE_OFFSET_FROM_EXTRUDER : 0),
+                py = ry - (probe_as_reference == USE_PROBE_AS_REFERENCE ? Y_PROBE_OFFSET_FROM_EXTRUDER : 0);
 
     float best_so_far = 99999.99;
 
     for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
       for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
 
         if ( (type == INVALID && isnan(z_values[i][j]))  // Check to see if this location holds the right thing
           || (type == REAL && !isnan(z_values[i][j]))
           || (type == SET_IN_BITMAP && is_bit_set(bits, i, j))
         ) {
           // We only get here if we found a Mesh Point of the specified type
 
-          float raw_x = RAW_CURRENT_POSITION(X), raw_y = RAW_CURRENT_POSITION(Y);
           const float mx = mesh_index_to_xpos(i),
                       my = mesh_index_to_ypos(j);
 
           // If using the probe as the reference there are some unreachable locations.
           // Also for round beds, there are grid points outside the bed the nozzle can't reach.
           // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
-          if (probe_as_reference ? !position_is_reachable_by_probe_raw_xy(mx, my) : !position_is_reachable_raw_xy(mx, my))
+          if (probe_as_reference ? !position_is_reachable_by_probe(mx, my) : !position_is_reachable(mx, my))
             continue;
 
           // Reachable. Check if it's the best_so_far location to the nozzle.
 
           float distance = HYPOT(px - mx, py - my);
 
           // factor in the distance from the current location for the normal case
           // so the nozzle isn't running all over the bed.
-          distance += HYPOT(raw_x - mx, raw_y - my) * 0.1;
+          distance += HYPOT(current_position[X_AXIS] - mx, current_position[Y_AXIS] - my) * 0.1;
           if (distance < best_so_far) {
             best_so_far = distance;   // We found a closer location with
             out_mesh.x_index = i;     // the specified type of mesh value.
             out_mesh.y_index = j;
             out_mesh.distance = best_so_far;
           }
         }
       } // for j
     } // for i
     return out_mesh;
   }
 
   #if ENABLED(NEWPANEL)
 
-    void unified_bed_leveling::fine_tune_mesh(const float &lx, const float &ly, const bool do_ubl_mesh_map) {
+    void unified_bed_leveling::fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map) {
       if (!parser.seen('R'))    // fine_tune_mesh() is special. If no repetition count flag is specified
         g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 
       #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
         const bool is_offset = parser.seen('H');
         const float h_offset = is_offset ? parser.value_linear_units() : Z_CLEARANCE_BETWEEN_PROBES;
         if (is_offset && !WITHIN(h_offset, 0, 10)) {
           SERIAL_PROTOCOLLNPGM("Offset out of bounds. (0 to 10mm)\n");
           return;
         }
       #endif
 
       mesh_index_pair location;
 
-      if (!position_is_reachable_xy(lx, ly)) {
+      if (!position_is_reachable(rx, ry)) {
         SERIAL_PROTOCOLLNPGM("(X,Y) outside printable radius.");
         return;
       }
 
       save_ubl_active_state_and_disable();
 
       LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
 
       do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
-      do_blocking_move_to_xy(lx, ly);
+      do_blocking_move_to_xy(rx, ry);
 
       uint16_t not_done[16];
       memset(not_done, 0xFF, sizeof(not_done));
       do {
-        location = find_closest_mesh_point_of_type(SET_IN_BITMAP, lx, ly, USE_NOZZLE_AS_REFERENCE, not_done);
+        location = find_closest_mesh_point_of_type(SET_IN_BITMAP, rx, ry, USE_NOZZLE_AS_REFERENCE, not_done);
 
         if (location.x_index < 0) break; // stop when we can't find any more reachable points.
 
         bit_clear(not_done, location.x_index, location.y_index);  // Mark this location as 'adjusted' so we will find a
                                                                   // different location the next time through the loop
 
         const float rawx = mesh_index_to_xpos(location.x_index),
                     rawy = mesh_index_to_ypos(location.y_index);
 
-        if (!position_is_reachable_raw_xy(rawx, rawy)) // SHOULD NOT OCCUR because find_closest_mesh_point_of_type will only return reachable
+        if (!position_is_reachable(rawx, rawy)) // SHOULD NOT OCCUR because find_closest_mesh_point_of_type will only return reachable
           break;
 
         float new_z = z_values[location.x_index][location.y_index];
 
         if (isnan(new_z)) // if the mesh point is invalid, set it to 0.0 so it can be edited
           new_z = 0.0;
 
         do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);    // Move the nozzle to where we are going to edit
-        do_blocking_move_to_xy(LOGICAL_X_POSITION(rawx), LOGICAL_Y_POSITION(rawy));
+        do_blocking_move_to_xy(rawx, rawy);
 
         new_z = FLOOR(new_z * 1000.0) * 0.001; // Chop off digits after the 1000ths place
 
         KEEPALIVE_STATE(PAUSED_FOR_USER);
         has_control_of_lcd_panel = true;
 
         if (do_ubl_mesh_map) display_map(g29_map_type);  // show the user which point is being adjusted
 
         lcd_refresh();
 
@@ -1569,21 +1566,21 @@
 
       FINE_TUNE_EXIT:
 
       has_control_of_lcd_panel = false;
       KEEPALIVE_STATE(IN_HANDLER);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);
       restore_ubl_active_state_and_leave();
       do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
 
-      do_blocking_move_to_xy(lx, ly);
+      do_blocking_move_to_xy(rx, ry);
 
       LCD_MESSAGEPGM(MSG_UBL_DONE_EDITING_MESH);
       SERIAL_ECHOLNPGM("Done Editing Mesh");
 
       if (lcd_map_control)
         lcd_goto_screen(_lcd_ubl_output_map_lcd);
       else
         lcd_return_to_status();
     }
 
@@ -1647,53 +1644,53 @@
                         y_max = min(MAX_PROBE_Y, MESH_MAX_Y);
 
       const float dx = float(x_max - x_min) / (g29_grid_size - 1.0),
                   dy = float(y_max - y_min) / (g29_grid_size - 1.0);
 
       struct linear_fit_data lsf_results;
       incremental_LSF_reset(&lsf_results);
 
       bool zig_zag = false;
       for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
-        const float x = float(x_min) + ix * dx;
+        const float rx = float(x_min) + ix * dx;
         for (int8_t iy = 0; iy < g29_grid_size; iy++) {
-          const float y = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
-          float measured_z = probe_pt(LOGICAL_X_POSITION(x), LOGICAL_Y_POSITION(y), parser.seen('E'), g29_verbose_level); // TODO: Needs error handling
+          const float ry = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
+          float measured_z = probe_pt(rx, ry, parser.seen('E'), g29_verbose_level); // TODO: Needs error handling
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_CHAR('(');
-              SERIAL_PROTOCOL_F(x, 7);
+              SERIAL_PROTOCOL_F(rx, 7);
               SERIAL_CHAR(',');
-              SERIAL_PROTOCOL_F(y, 7);
+              SERIAL_PROTOCOL_F(ry, 7);
               SERIAL_ECHOPGM(")   logical: ");
               SERIAL_CHAR('(');
-              SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(x), 7);
+              SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 7);
               SERIAL_CHAR(',');
-              SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(y), 7);
+              SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(ry), 7);
               SERIAL_ECHOPGM(")   measured: ");
               SERIAL_PROTOCOL_F(measured_z, 7);
               SERIAL_ECHOPGM("   correction: ");
-              SERIAL_PROTOCOL_F(get_z_correction(LOGICAL_X_POSITION(x), LOGICAL_Y_POSITION(y)), 7);
+              SERIAL_PROTOCOL_F(get_z_correction(rx, ry), 7);
             }
           #endif
 
-          measured_z -= get_z_correction(LOGICAL_X_POSITION(x), LOGICAL_Y_POSITION(y)) /* + zprobe_zoffset */ ;
+          measured_z -= get_z_correction(rx, ry) /* + zprobe_zoffset */ ;
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPGM("   final >>>---> ");
               SERIAL_PROTOCOL_F(measured_z, 7);
               SERIAL_EOL();
             }
           #endif
 
-          incremental_LSF(&lsf_results, x, y, measured_z);
+          incremental_LSF(&lsf_results, rx, ry, measured_z);
         }
 
         zig_zag ^= true;
       }
 
       if (finish_incremental_LSF(&lsf_results)) {
         SERIAL_ECHOPGM("Could not complete LSF!");
         return;
       }
 

commit 580b6e9089cefa7cf85c33ef53af4d02a6b59f37
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 19 01:39:39 2017 -0500

    Apply physical limits to mesh bounds

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index f1eb6b7f00..edb862ce11 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -408,21 +408,21 @@
 
           // Adjust z1, z2, z3 by the Mesh Height at these points. Just because they're non-zero
           // doesn't mean the Mesh is tilted! (Compensate each probe point by what the Mesh says
           // its height is.)
 
           save_ubl_active_state_and_disable();
           z1 -= get_z_correction(LOGICAL_X_POSITION(UBL_PROBE_PT_1_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_1_Y)) /* + zprobe_zoffset */ ;
           z2 -= get_z_correction(LOGICAL_X_POSITION(UBL_PROBE_PT_2_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_2_Y)) /* + zprobe_zoffset */ ;
           z3 -= get_z_correction(LOGICAL_X_POSITION(UBL_PROBE_PT_3_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_3_Y)) /* + zprobe_zoffset */ ;
 
-          do_blocking_move_to_xy(0.5 * (UBL_MESH_MAX_X - (UBL_MESH_MIN_X)), 0.5 * (UBL_MESH_MAX_Y - (UBL_MESH_MIN_Y)));
+          do_blocking_move_to_xy(0.5 * (MESH_MAX_X - (MESH_MIN_X)), 0.5 * (MESH_MAX_Y - (MESH_MIN_Y)));
           tilt_mesh_based_on_3pts(z1, z2, z3);
           restore_ubl_active_state_and_leave();
         }
       }
 
     #endif // HAS_BED_PROBE
 
     if (parser.seen('P')) {
       if (WITHIN(g29_phase_value, 0, 1) && storage_slot == -1) {
         storage_slot = 0;
@@ -771,22 +771,22 @@
           const float measured_z = probe_pt(LOGICAL_X_POSITION(rawx), LOGICAL_Y_POSITION(rawy), stow_probe, g29_verbose_level); // TODO: Needs error handling
           z_values[location.x_index][location.y_index] = measured_z;
         }
 
       } while (location.x_index >= 0 && --max_iterations);
 
       STOW_PROBE();
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
-        constrain(lx - (X_PROBE_OFFSET_FROM_EXTRUDER), UBL_MESH_MIN_X, UBL_MESH_MAX_X),
-        constrain(ly - (Y_PROBE_OFFSET_FROM_EXTRUDER), UBL_MESH_MIN_Y, UBL_MESH_MAX_Y)
+        constrain(lx - (X_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_X, MESH_MAX_X),
+        constrain(ly - (Y_PROBE_OFFSET_FROM_EXTRUDER), MESH_MIN_Y, MESH_MAX_Y)
       );
     }
 
     void unified_bed_leveling::tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3) {
       matrix_3x3 rotation;
       vector_3 v1 = vector_3( (UBL_PROBE_PT_1_X - UBL_PROBE_PT_2_X),
                               (UBL_PROBE_PT_1_Y - UBL_PROBE_PT_2_Y),
                               (z1 - z2) ),
 
                v2 = vector_3( (UBL_PROBE_PT_3_X - UBL_PROBE_PT_2_X),
@@ -908,21 +908,21 @@
       return current_position[Z_AXIS];
     }
 
     static void echo_and_take_a_measurement() { SERIAL_PROTOCOLLNPGM(" and take a measurement."); }
 
     float unified_bed_leveling::measure_business_card_thickness(float in_height) {
       has_control_of_lcd_panel = true;
       save_ubl_active_state_and_disable();   // Disable bed level correction for probing
 
       do_blocking_move_to_z(in_height);
-      do_blocking_move_to_xy(0.5 * (UBL_MESH_MAX_X - (UBL_MESH_MIN_X)), 0.5 * (UBL_MESH_MAX_Y - (UBL_MESH_MIN_Y)));
+      do_blocking_move_to_xy(0.5 * (MESH_MAX_X - (MESH_MIN_X)), 0.5 * (MESH_MAX_Y - (MESH_MIN_Y)));
         //, min(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]) / 2.0);
       stepper.synchronize();
 
       SERIAL_PROTOCOLPGM("Place shim under nozzle");
       LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
       lcd_return_to_status();
       echo_and_take_a_measurement();
 
       const float z1 = measure_point_with_encoder();
       do_blocking_move_to_z(current_position[Z_AXIS] + SIZE_OF_LITTLE_RAISE);
@@ -1214,25 +1214,25 @@
       SERIAL_PROTOCOL_F(planner.z_fade_height, 4);
       SERIAL_EOL();
     #endif
 
     #if HAS_BED_PROBE
       SERIAL_PROTOCOLPGM("zprobe_zoffset: ");
       SERIAL_PROTOCOL_F(zprobe_zoffset, 7);
       SERIAL_EOL();
     #endif
 
-    SERIAL_ECHOLNPAIR("UBL_MESH_MIN_X  " STRINGIFY(UBL_MESH_MIN_X) "=", UBL_MESH_MIN_X);
-    SERIAL_ECHOLNPAIR("UBL_MESH_MIN_Y  " STRINGIFY(UBL_MESH_MIN_Y) "=", UBL_MESH_MIN_Y);
+    SERIAL_ECHOLNPAIR("MESH_MIN_X  " STRINGIFY(MESH_MIN_X) "=", MESH_MIN_X);
+    SERIAL_ECHOLNPAIR("MESH_MIN_Y  " STRINGIFY(MESH_MIN_Y) "=", MESH_MIN_Y);
     safe_delay(25);
-    SERIAL_ECHOLNPAIR("UBL_MESH_MAX_X  " STRINGIFY(UBL_MESH_MAX_X) "=", UBL_MESH_MAX_X);
-    SERIAL_ECHOLNPAIR("UBL_MESH_MAX_Y  " STRINGIFY(UBL_MESH_MAX_Y) "=", UBL_MESH_MAX_Y);
+    SERIAL_ECHOLNPAIR("MESH_MAX_X  " STRINGIFY(MESH_MAX_X) "=", MESH_MAX_X);
+    SERIAL_ECHOLNPAIR("MESH_MAX_Y  " STRINGIFY(MESH_MAX_Y) "=", MESH_MAX_Y);
     safe_delay(25);
     SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);
     SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);
     safe_delay(25);
     SERIAL_ECHOLNPAIR("MESH_X_DIST  ", MESH_X_DIST);
     SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);
     safe_delay(25);
 
     SERIAL_PROTOCOLPGM("X-Axis Mesh Points at: ");
     for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
@@ -1634,24 +1634,24 @@
          for (uint8_t x = sx; x != ex; ++x)
           for (uint8_t y = sy; y != ey; y += dir)
             if (smart_fill_one(x, y, 0, dir)) break;
       }
     }
   }
 
   #if HAS_BED_PROBE
 
     void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map) {
-      constexpr int16_t x_min = max(MIN_PROBE_X, UBL_MESH_MIN_X),
-                        x_max = min(MAX_PROBE_X, UBL_MESH_MAX_X),
-                        y_min = max(MIN_PROBE_Y, UBL_MESH_MIN_Y),
-                        y_max = min(MAX_PROBE_Y, UBL_MESH_MAX_Y);
+      constexpr int16_t x_min = max(MIN_PROBE_X, MESH_MIN_X),
+                        x_max = min(MAX_PROBE_X, MESH_MAX_X),
+                        y_min = max(MIN_PROBE_Y, MESH_MIN_Y),
+                        y_max = min(MAX_PROBE_Y, MESH_MAX_Y);
 
       const float dx = float(x_max - x_min) / (g29_grid_size - 1.0),
                   dy = float(y_max - y_min) / (g29_grid_size - 1.0);
 
       struct linear_fit_data lsf_results;
       incremental_LSF_reset(&lsf_results);
 
       bool zig_zag = false;
       for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
         const float x = float(x_min) + ix * dx;

commit 543935828134831a3129247fcfcf3cb071048011
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Thu Oct 19 10:44:45 2017 -0500

    Basic UBL operations working on 32-bit platforms (#8024)
    
    * 32-bit work for UBL
    
    * Update FT i3-2020 reference file

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 74e26f8442..f1eb6b7f00 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -326,21 +326,21 @@
     // it directly specifies the repetition count and does not use the 'R' parameter.
     if (parser.seen('I')) {
       uint8_t cnt = 0;
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : 1;
       if (g29_repetition_cnt >= GRID_MAX_POINTS) {
         set_all_mesh_points_to_value(NAN);
       }
       else {
         while (g29_repetition_cnt--) {
           if (cnt > 20) { cnt = 0; idle(); }
-          const mesh_index_pair location = find_closest_mesh_point_of_type(REAL, g29_x_pos, g29_y_pos, USE_NOZZLE_AS_REFERENCE, NULL, false);
+          const mesh_index_pair location = find_closest_mesh_point_of_type(REAL, g29_x_pos, g29_y_pos, USE_NOZZLE_AS_REFERENCE, NULL);
           if (location.x_index < 0) {
             // No more REACHABLE mesh points to invalidate, so we ASSUME the user
             // meant to invalidate the ENTIRE mesh, which cannot be done with
             // find_closest_mesh_point loop which only returns REACHABLE points.
             set_all_mesh_points_to_value(NAN);
             SERIAL_PROTOCOLLNPGM("Entire Mesh invalidated.\n");
             break;            // No more invalid Mesh Points to populate
           }
           z_values[location.x_index][location.y_index] = NAN;
           cnt++;
@@ -522,21 +522,21 @@
            *   - Specify a constant with the 'C' parameter.
            *   - Allow 'G29 P3' to choose a 'reasonable' constant.
            */
 
           if (g29_c_flag) {
             if (g29_repetition_cnt >= GRID_MAX_POINTS) {
               set_all_mesh_points_to_value(g29_constant);
             }
             else {
               while (g29_repetition_cnt--) {  // this only populates reachable mesh points near
-                const mesh_index_pair location = find_closest_mesh_point_of_type(INVALID, g29_x_pos, g29_y_pos, USE_NOZZLE_AS_REFERENCE, NULL, false);
+                const mesh_index_pair location = find_closest_mesh_point_of_type(INVALID, g29_x_pos, g29_y_pos, USE_NOZZLE_AS_REFERENCE, NULL);
                 if (location.x_index < 0) {
                   // No more REACHABLE INVALID mesh points to populate, so we ASSUME
                   // user meant to populate ALL INVALID mesh points to value
                   for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
                     for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
                       if (isnan(z_values[x][y]))
                         z_values[x][y] = g29_constant;
                   break; // No more invalid Mesh Points to populate
                 }
                 z_values[location.x_index][location.y_index] = g29_constant;
@@ -737,45 +737,48 @@
     void unified_bed_leveling::probe_entire_mesh(const float &lx, const float &ly, const bool do_ubl_mesh_map, const bool stow_probe, bool close_or_far) {
       mesh_index_pair location;
 
       has_control_of_lcd_panel = true;
       save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
       DEPLOY_PROBE();
 
       uint16_t max_iterations = GRID_MAX_POINTS;
 
       do {
+        if (do_ubl_mesh_map) display_map(g29_map_type);
+
         #if ENABLED(NEWPANEL)
           if (ubl_lcd_clicked()) {
             SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.\n");
             lcd_quick_feedback();
             STOW_PROBE();
             while (ubl_lcd_clicked()) idle();
             has_control_of_lcd_panel = false;
             restore_ubl_active_state_and_leave();
             safe_delay(50);  // Debounce the Encoder wheel
             return;
           }
         #endif
 
-        location = find_closest_mesh_point_of_type(INVALID, lx, ly, USE_PROBE_AS_REFERENCE, NULL, close_or_far);
+        if (close_or_far)
+          location = find_furthest_invalid_mesh_point();
+        else
+          location = find_closest_mesh_point_of_type(INVALID, lx, ly, USE_PROBE_AS_REFERENCE, NULL);
 
         if (location.x_index >= 0) {    // mesh point found and is reachable by probe
           const float rawx = mesh_index_to_xpos(location.x_index),
                       rawy = mesh_index_to_ypos(location.y_index);
 
           const float measured_z = probe_pt(LOGICAL_X_POSITION(rawx), LOGICAL_Y_POSITION(rawy), stow_probe, g29_verbose_level); // TODO: Needs error handling
           z_values[location.x_index][location.y_index] = measured_z;
         }
 
-        if (do_ubl_mesh_map) display_map(g29_map_type);
-
       } while (location.x_index >= 0 && --max_iterations);
 
       STOW_PROBE();
       restore_ubl_active_state_and_leave();
 
       do_blocking_move_to_xy(
         constrain(lx - (X_PROBE_OFFSET_FROM_EXTRUDER), UBL_MESH_MIN_X, UBL_MESH_MAX_X),
         constrain(ly - (Y_PROBE_OFFSET_FROM_EXTRUDER), UBL_MESH_MIN_Y, UBL_MESH_MAX_Y)
       );
     }
@@ -955,21 +958,21 @@
       has_control_of_lcd_panel = true;
 
       save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
       do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
       do_blocking_move_to_xy(lx, ly);
 
       lcd_return_to_status();
 
       mesh_index_pair location;
       do {
-        location = find_closest_mesh_point_of_type(INVALID, lx, ly, USE_NOZZLE_AS_REFERENCE, NULL, false);
+        location = find_closest_mesh_point_of_type(INVALID, lx, ly, USE_NOZZLE_AS_REFERENCE, NULL);
         // It doesn't matter if the probe can't reach the NAN location. This is a manual probe.
         if (location.x_index < 0 && location.y_index < 0) continue;
 
         const float rawx = mesh_index_to_xpos(location.x_index),
                     rawy = mesh_index_to_ypos(location.y_index),
                     xProbe = LOGICAL_X_POSITION(rawx),
                     yProbe = LOGICAL_Y_POSITION(rawy);
 
         if (!position_is_reachable_raw_xy(rawx, rawy)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
 
@@ -1282,31 +1285,31 @@
       SERIAL_PROTOCOLLNPGM(" sanity checks passed.");
     }
   }
 
   /**
    * When we are fully debugged, the EEPROM dump command will get deleted also. But
    * right now, it is good to have the extra information. Soon... we prune this.
    */
   void unified_bed_leveling::g29_eeprom_dump() {
     unsigned char cccc;
-    uint16_t kkkk;
+    unsigned int  kkkk;  // Needs to be of unspecfied size to compile clean on all platforms
 
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPGM("EEPROM Dump:");
     for (uint16_t i = 0; i < E2END + 1; i += 16) {
       if (!(i & 0x3)) idle();
       print_hex_word(i);
       SERIAL_ECHOPGM(": ");
       for (uint16_t j = 0; j < 16; j++) {
         kkkk = i + j;
-        eeprom_read_block(&cccc, (void *)kkkk, 1);
+        eeprom_read_block(&cccc, (const void *) kkkk, sizeof(unsigned char));
         print_hex_byte(cccc);
         SERIAL_ECHO(' ');
       }
       SERIAL_EOL();
     }
     SERIAL_EOL();
   }
 
   /**
    * When we are fully debugged, this may go away. But there are some valid
@@ -1338,88 +1341,132 @@
     settings.load_mesh(g29_storage_slot, &tmp_z_values);
 
     SERIAL_PROTOCOLPAIR("Subtracting mesh in slot ", g29_storage_slot);
     SERIAL_PROTOCOLLNPGM(" from current mesh.");
 
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
         z_values[x][y] -= tmp_z_values[x][y];
   }
 
-  mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const float &lx, const float &ly, const bool probe_as_reference, uint16_t bits[16], const bool far_flag) {
+
+  mesh_index_pair unified_bed_leveling::find_furthest_invalid_mesh_point() {
+
+    bool found_a_NAN  = false;
+    bool found_a_real = false;
     mesh_index_pair out_mesh;
     out_mesh.x_index = out_mesh.y_index = -1;
+    out_mesh.distance = -99999.99;
+
+    for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
+      for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
+
+        if ( isnan(z_values[i][j])) { // Check to see if this location holds an invalid mesh point
+
+          const float mx = mesh_index_to_xpos(i),
+                      my = mesh_index_to_ypos(j);
+
+          if ( !position_is_reachable_by_probe_raw_xy(mx, my))  // make sure the probe can get to the mesh point
+            continue;
+
+          found_a_NAN = true;
+
+          int8_t closest_x=-1, closest_y=-1;
+          float d1, d2 = 99999.9;
+          for (int8_t k = 0; k < GRID_MAX_POINTS_X; k++) {
+            for (int8_t l = 0; l < GRID_MAX_POINTS_Y; l++) {
+              if (!isnan(z_values[k][l])) {
+                found_a_real = true;
+
+          // Add in a random weighting factor that scrambles the probing of the
+          // last half of the mesh (when every unprobed mesh point is one index
+          // from a probed location).
+
+                d1 = HYPOT(i - k, j - l) + (1.0 / ((millis() % 47) + 13));
+
+                if (d1 < d2) {    // found a closer distance from invalid mesh point at (i,j) to defined mesh point at (k,l)
+                  d2 = d1;       // found a closer location with
+                  closest_x = i;    // an assigned mesh point value
+                  closest_y = j;
+                }
+              }
+            }
+          }
+
+          //
+          // at this point d2 should have the closest defined mesh point to invalid mesh point (i,j)
+          //
+
+          if (found_a_real && (closest_x >= 0) && (d2 > out_mesh.distance)) {
+            out_mesh.distance = d2;         // found an invalid location with a greater distance
+            out_mesh.x_index = closest_x;   // to a defined mesh point
+            out_mesh.y_index = closest_y;
+          }
+        }
+      } // for j
+    } // for i
+
+    if (!found_a_real && found_a_NAN) {        // if the mesh is totally unpopulated, start the probing
+      out_mesh.x_index = GRID_MAX_POINTS_X / 2;
+      out_mesh.y_index = GRID_MAX_POINTS_Y / 2;
+      out_mesh.distance = 1.0;
+    }
+    return out_mesh;
+  }
+
+  mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const float &lx, const float &ly, const bool probe_as_reference, uint16_t bits[16]) {
+    mesh_index_pair out_mesh;
+    out_mesh.x_index = out_mesh.y_index = -1;
+    out_mesh.distance = -99999.9;
 
     // Get our reference position. Either the nozzle or probe location.
     const float px = RAW_X_POSITION(lx) - (probe_as_reference == USE_PROBE_AS_REFERENCE ? X_PROBE_OFFSET_FROM_EXTRUDER : 0),
                 py = RAW_Y_POSITION(ly) - (probe_as_reference == USE_PROBE_AS_REFERENCE ? Y_PROBE_OFFSET_FROM_EXTRUDER : 0);
 
-    float best_so_far = far_flag ? -99999.99 : 99999.99;
+    float best_so_far = 99999.99;
 
-    for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
-      for (uint8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
+    for (int8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
+      for (int8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
 
         if ( (type == INVALID && isnan(z_values[i][j]))  // Check to see if this location holds the right thing
           || (type == REAL && !isnan(z_values[i][j]))
           || (type == SET_IN_BITMAP && is_bit_set(bits, i, j))
         ) {
           // We only get here if we found a Mesh Point of the specified type
 
           float raw_x = RAW_CURRENT_POSITION(X), raw_y = RAW_CURRENT_POSITION(Y);
           const float mx = mesh_index_to_xpos(i),
                       my = mesh_index_to_ypos(j);
 
           // If using the probe as the reference there are some unreachable locations.
           // Also for round beds, there are grid points outside the bed the nozzle can't reach.
           // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
           if (probe_as_reference ? !position_is_reachable_by_probe_raw_xy(mx, my) : !position_is_reachable_raw_xy(mx, my))
             continue;
 
           // Reachable. Check if it's the best_so_far location to the nozzle.
-          // Add in a weighting factor that considers the current location of the nozzle.
 
           float distance = HYPOT(px - mx, py - my);
 
-          /**
-           * If doing the far_flag action, we want to be as far as possible
-           * from the starting point and from any other probed points. We
-           * want the next point spread out and filling in any blank spaces
-           * in the mesh. So we add in some of the distance to every probed
-           * point we can find.
-           */
-          if (far_flag) {
-            for (uint8_t k = 0; k < GRID_MAX_POINTS_X; k++) {
-              for (uint8_t l = 0; l < GRID_MAX_POINTS_Y; l++) {
-                if (i != k && j != l && !isnan(z_values[k][l])) {
-                  //distance += pow((float) abs(i - k) * (MESH_X_DIST), 2) + pow((float) abs(j - l) * (MESH_Y_DIST), 2);  // working here
-                  distance += HYPOT(MESH_X_DIST, MESH_Y_DIST) / log(HYPOT((i - k) * (MESH_X_DIST) + .001, (j - l) * (MESH_Y_DIST)) + .001);
-                }
-              }
-            }
-          }
-          else
           // factor in the distance from the current location for the normal case
           // so the nozzle isn't running all over the bed.
-            distance += HYPOT(raw_x - mx, raw_y - my) * 0.1;
-
-          // if far_flag, look for farthest point
-          if (far_flag == (distance > best_so_far) && distance != best_so_far) {
-            best_so_far = distance;   // We found a closer/farther location with
+          distance += HYPOT(raw_x - mx, raw_y - my) * 0.1;
+          if (distance < best_so_far) {
+            best_so_far = distance;   // We found a closer location with
             out_mesh.x_index = i;     // the specified type of mesh value.
             out_mesh.y_index = j;
             out_mesh.distance = best_so_far;
           }
         }
       } // for j
     } // for i
-
     return out_mesh;
   }
 
   #if ENABLED(NEWPANEL)
 
     void unified_bed_leveling::fine_tune_mesh(const float &lx, const float &ly, const bool do_ubl_mesh_map) {
       if (!parser.seen('R'))    // fine_tune_mesh() is special. If no repetition count flag is specified
         g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
 
       #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
@@ -1441,21 +1488,21 @@
       save_ubl_active_state_and_disable();
 
       LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
 
       do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
       do_blocking_move_to_xy(lx, ly);
 
       uint16_t not_done[16];
       memset(not_done, 0xFF, sizeof(not_done));
       do {
-        location = find_closest_mesh_point_of_type(SET_IN_BITMAP, lx, ly, USE_NOZZLE_AS_REFERENCE, not_done, false);
+        location = find_closest_mesh_point_of_type(SET_IN_BITMAP, lx, ly, USE_NOZZLE_AS_REFERENCE, not_done);
 
         if (location.x_index < 0) break; // stop when we can't find any more reachable points.
 
         bit_clear(not_done, location.x_index, location.y_index);  // Mark this location as 'adjusted' so we will find a
                                                                   // different location the next time through the loop
 
         const float rawx = mesh_index_to_xpos(location.x_index),
                     rawy = mesh_index_to_ypos(location.y_index);
 
         if (!position_is_reachable_raw_xy(rawx, rawy)) // SHOULD NOT OCCUR because find_closest_mesh_point_of_type will only return reachable
@@ -1565,30 +1612,24 @@
   typedef struct { uint8_t sx, ex, sy, ey; bool yfirst; } smart_fill_info;
 
   void unified_bed_leveling::smart_fill_mesh() {
     static const smart_fill_info
       info0 PROGMEM = { 0, GRID_MAX_POINTS_X,      0, GRID_MAX_POINTS_Y - 2,  false },  // Bottom of the mesh looking up
       info1 PROGMEM = { 0, GRID_MAX_POINTS_X,      GRID_MAX_POINTS_Y - 1, 0,  false },  // Top of the mesh looking down
       info2 PROGMEM = { 0, GRID_MAX_POINTS_X - 2,  0, GRID_MAX_POINTS_Y,      true  },  // Left side of the mesh looking right
       info3 PROGMEM = { GRID_MAX_POINTS_X - 1, 0,  0, GRID_MAX_POINTS_Y,      true  };  // Right side of the mesh looking left
     static const smart_fill_info * const info[] PROGMEM = { &info0, &info1, &info2, &info3 };
 
-    // static const smart_fill_info info[] PROGMEM = {
-    //   { 0, GRID_MAX_POINTS_X,      0, GRID_MAX_POINTS_Y - 2,  false } PROGMEM,  // Bottom of the mesh looking up
-    //   { 0, GRID_MAX_POINTS_X,      GRID_MAX_POINTS_Y - 1, 0,  false } PROGMEM,  // Top of the mesh looking down
-    //   { 0, GRID_MAX_POINTS_X - 2,  0, GRID_MAX_POINTS_Y,      true  } PROGMEM,  // Left side of the mesh looking right
-    //   { GRID_MAX_POINTS_X - 1, 0,  0, GRID_MAX_POINTS_Y,      true  } PROGMEM   // Right side of the mesh looking left
-    // };
     for (uint8_t i = 0; i < COUNT(info); ++i) {
       const smart_fill_info *f = (smart_fill_info*)pgm_read_ptr(&info[i]);
-      const int8_t sx = pgm_read_word(&f->sx), sy = pgm_read_word(&f->sy),
-                   ex = pgm_read_word(&f->ex), ey = pgm_read_word(&f->ey);
+      const int8_t sx = pgm_read_byte(&f->sx), sy = pgm_read_byte(&f->sy),
+                   ex = pgm_read_byte(&f->ex), ey = pgm_read_byte(&f->ey);
       if (pgm_read_byte(&f->yfirst)) {
         const int8_t dir = ex > sx ? 1 : -1;
         for (uint8_t y = sy; y != ey; ++y)
           for (uint8_t x = sx; x != ex; x += dir)
             if (smart_fill_one(x, y, dir, 0)) break;
       }
       else {
         const int8_t dir = ey > sy ? 1 : -1;
          for (uint8_t x = sx; x != ex; ++x)
           for (uint8_t y = sy; y != ey; y += dir)

commit 572cf0ec951f9a1703d50d2e10b62f323b76941f
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Wed Oct 18 14:00:29 2017 -0500

    UBL able to generate mesh and save and load it on 32-bit platforms (#8015)
    
    * Get UBL Mesh Generation, Mesh Save & Mesh Load working with 32-Bit platforms
    
    * clean up read_data() and write_data() for non-LPC1768 HAL's
    
    * Get read_data() and write_data() return codes consistent
    
    All HAL's read_data() and write_data() return false if they succeed.
    
    * Get read_data() and write_data() return codes to be consistent
    
    Make read_data() and write_data() return true if an error happens.
    
    * Say UBL is now checked out on machine types in default Configuration.h file.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 9c4f552160..74e26f8442 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -661,21 +661,21 @@
         goto LEAVE;
       }
 
       settings.store_mesh(g29_storage_slot);
       storage_slot = g29_storage_slot;
 
       SERIAL_PROTOCOLLNPGM("Done.");
     }
 
     if (parser.seen('T'))
-      display_map(parser.has_value() ? parser.value_int() : 0);
+      display_map(g29_map_type);
 
     LEAVE:
 
     #if ENABLED(NEWPANEL)
       lcd_reset_alert_level();
       LCD_MESSAGEPGM("");
       lcd_quick_feedback();
 
       has_control_of_lcd_panel = false;
     #endif

commit 1344ca4b2fa6c9dea4e6ea257908302add185018
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 21:56:27 2017 -0500

    UBL no longer needs ubl_state

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 69a690ff19..9c4f552160 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -417,22 +417,22 @@
 
           do_blocking_move_to_xy(0.5 * (UBL_MESH_MAX_X - (UBL_MESH_MIN_X)), 0.5 * (UBL_MESH_MAX_Y - (UBL_MESH_MIN_Y)));
           tilt_mesh_based_on_3pts(z1, z2, z3);
           restore_ubl_active_state_and_leave();
         }
       }
 
     #endif // HAS_BED_PROBE
 
     if (parser.seen('P')) {
-      if (WITHIN(g29_phase_value, 0, 1) && state.storage_slot == -1) {
-        state.storage_slot = 0;
+      if (WITHIN(g29_phase_value, 0, 1) && storage_slot == -1) {
+        storage_slot = 0;
         SERIAL_PROTOCOLLNPGM("Default storage slot 0 selected.");
       }
 
       switch (g29_phase_value) {
         case 0:
           //
           // Zero Mesh Data
           //
           reset();
           SERIAL_PROTOCOLLNPGM("Mesh zeroed.");
@@ -597,47 +597,47 @@
     //
 
     if (parser.seen('K')) // Kompare Current Mesh Data to Specified Stored Mesh
       g29_compare_current_mesh_to_stored_mesh();
 
     //
     // Load a Mesh from the EEPROM
     //
 
     if (parser.seen('L')) {     // Load Current Mesh Data
-      g29_storage_slot = parser.has_value() ? parser.value_int() : state.storage_slot;
+      g29_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
 
       int16_t a = settings.calc_num_meshes();
 
       if (!a) {
         SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
         return;
       }
 
       if (!WITHIN(g29_storage_slot, 0, a - 1)) {
         SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
         SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
         return;
       }
 
       settings.load_mesh(g29_storage_slot);
-      state.storage_slot = g29_storage_slot;
+      storage_slot = g29_storage_slot;
 
       SERIAL_PROTOCOLLNPGM("Done.");
     }
 
     //
     // Store a Mesh in the EEPROM
     //
 
     if (parser.seen('S')) {     // Store (or Save) Current Mesh Data
-      g29_storage_slot = parser.has_value() ? parser.value_int() : state.storage_slot;
+      g29_storage_slot = parser.has_value() ? parser.value_int() : storage_slot;
 
       if (g29_storage_slot == -1) {                     // Special case, we are going to 'Export' the mesh to the
         SERIAL_ECHOLNPGM("G29 I 999");              // host in a form it can be reconstructed on a different machine
         for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
           for (uint8_t y = 0;  y < GRID_MAX_POINTS_Y; y++)
             if (!isnan(z_values[x][y])) {
               SERIAL_ECHOPAIR("M421 I ", x);
               SERIAL_ECHOPAIR(" J ", y);
               SERIAL_ECHOPGM(" Z ");
               SERIAL_ECHO_F(z_values[x][y], 6);
@@ -655,21 +655,21 @@
         goto LEAVE;
       }
 
       if (!WITHIN(g29_storage_slot, 0, a - 1)) {
         SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
         SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
         goto LEAVE;
       }
 
       settings.store_mesh(g29_storage_slot);
-      state.storage_slot = g29_storage_slot;
+      storage_slot = g29_storage_slot;
 
       SERIAL_PROTOCOLLNPGM("Done.");
     }
 
     if (parser.seen('T'))
       display_map(parser.has_value() ? parser.value_int() : 0);
 
     LEAVE:
 
     #if ENABLED(NEWPANEL)
@@ -1188,24 +1188,24 @@
     set_bed_leveling_enabled(ubl_state_at_invocation);
   }
 
   /**
    * Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
    * good to have the extra information. Soon... we prune this to just a few items
    */
   void unified_bed_leveling::g29_what_command() {
     report_state();
 
-    if (state.storage_slot == -1)
+    if (storage_slot == -1)
       SERIAL_PROTOCOLPGM("No Mesh Loaded.");
     else {
-      SERIAL_PROTOCOLPAIR("Mesh ", state.storage_slot);
+      SERIAL_PROTOCOLPAIR("Mesh ", storage_slot);
       SERIAL_PROTOCOLPGM(" Loaded.");
     }
     SERIAL_EOL();
     safe_delay(50);
 
     SERIAL_PROTOCOLLNPAIR("UBL object count: ", (int)ubl_cnt);
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       SERIAL_PROTOCOL("planner.z_fade_height : ");
       SERIAL_PROTOCOL_F(planner.z_fade_height, 4);

commit 3e3911fb81cef6f17f7e77c54f520e2a4579225b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 17:21:25 2017 -0500

    Use planner.leveling_active for all leveling systems

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 2c58750119..69a690ff19 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -1163,21 +1163,21 @@
     if (ubl_state_recursion_chk != 1) {
       SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
 
       #if ENABLED(NEWPANEL)
         LCD_MESSAGEPGM(MSG_UBL_SAVE_ERROR);
         lcd_quick_feedback();
       #endif
 
       return;
     }
-    ubl_state_at_invocation = state.active;
+    ubl_state_at_invocation = planner.leveling_active;
     set_bed_leveling_enabled(false);
   }
 
   void unified_bed_leveling::restore_ubl_active_state_and_leave() {
     if (--ubl_state_recursion_chk) {
       SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
 
       #if ENABLED(NEWPANEL)
         LCD_MESSAGEPGM(MSG_UBL_RESTORE_ERROR);
         lcd_quick_feedback();

commit 1adb5a6a4800e65e04cef5833dc1cf21c7e13c2e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 12 22:20:02 2017 -0500

    Remove obsolete UBL z_offset

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 1dd0899281..2c58750119 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -663,79 +663,20 @@
 
       settings.store_mesh(g29_storage_slot);
       state.storage_slot = g29_storage_slot;
 
       SERIAL_PROTOCOLLNPGM("Done.");
     }
 
     if (parser.seen('T'))
       display_map(parser.has_value() ? parser.value_int() : 0);
 
-    /**
-     * This code may not be needed...  Prepare for its removal...
-     *
-     */
-    #if 0
-    if (parser.seen('Z')) {
-      if (parser.has_value())
-        state.z_offset = parser.value_float();   // do the simple case. Just lock in the specified value
-      else {
-        save_ubl_active_state_and_disable();
-        //float measured_z = probe_pt(g29_x_pos + X_PROBE_OFFSET_FROM_EXTRUDER, g29_y_pos + Y_PROBE_OFFSET_FROM_EXTRUDER, ProbeDeployAndStow, g29_verbose_level);
-
-        has_control_of_lcd_panel = true;     // Grab the LCD Hardware
-        float measured_z = 1.5;
-        do_blocking_move_to_z(measured_z);  // Get close to the bed, but leave some space so we don't damage anything
-                                            // The user is not going to be locking in a new Z-Offset very often so
-                                            // it won't be that painful to spin the Encoder Wheel for 1.5mm
-        lcd_refresh();
-        lcd_z_offset_edit_setup(measured_z);
-
-        KEEPALIVE_STATE(PAUSED_FOR_USER);
-
-        do {
-          measured_z = lcd_z_offset_edit();
-          idle();
-          do_blocking_move_to_z(measured_z);
-        } while (!ubl_lcd_clicked());
-
-        has_control_of_lcd_panel = true;   // There is a race condition for the encoder click.
-                                               // It could get detected in lcd_mesh_edit (actually _lcd_mesh_fine_tune)
-                                               // or here. So, until we are done looking for a long encoder press,
-                                               // we need to take control of the panel
-
-        KEEPALIVE_STATE(IN_HANDLER);
-
-        lcd_return_to_status();
-
-        const millis_t nxt = millis() + 1500UL;
-        while (ubl_lcd_clicked()) { // debounce and watch for abort
-          idle();
-          if (ELAPSED(millis(), nxt)) {
-            SERIAL_PROTOCOLLNPGM("\nZ-Offset Adjustment Stopped.");
-            do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
-            LCD_MESSAGEPGM(MSG_UBL_Z_OFFSET_STOPPED);
-            restore_ubl_active_state_and_leave();
-            goto LEAVE;
-          }
-        }
-        has_control_of_lcd_panel = false;
-        safe_delay(20); // We don't want any switch noise.
-
-        state.z_offset = measured_z;
-
-        lcd_refresh();
-        restore_ubl_active_state_and_leave();
-      }
-    }
-    #endif
-
     LEAVE:
 
     #if ENABLED(NEWPANEL)
       lcd_reset_alert_level();
       LCD_MESSAGEPGM("");
       lcd_quick_feedback();
 
       has_control_of_lcd_panel = false;
     #endif
 

commit 442669d23ce1116ddc58035615dd2b52a30c67c9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 9 18:26:52 2017 -0500

    Allow UBL to build without a probe

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
index 8449050285..1dd0899281 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -58,30 +58,33 @@
   //extern bool set_probe_deployed(bool);
   //extern void set_bed_leveling_enabled(bool);
 
   #define SIZE_OF_LITTLE_RAISE 1
   #define BIG_RAISE_NOT_NEEDED 0
 
   int    unified_bed_leveling::g29_verbose_level,
          unified_bed_leveling::g29_phase_value,
          unified_bed_leveling::g29_repetition_cnt,
          unified_bed_leveling::g29_storage_slot = 0,
-         unified_bed_leveling::g29_map_type,
-         unified_bed_leveling::g29_grid_size;
+         unified_bed_leveling::g29_map_type;
   bool   unified_bed_leveling::g29_c_flag,
          unified_bed_leveling::g29_x_flag,
          unified_bed_leveling::g29_y_flag;
   float  unified_bed_leveling::g29_x_pos,
          unified_bed_leveling::g29_y_pos,
          unified_bed_leveling::g29_card_thickness = 0.0,
          unified_bed_leveling::g29_constant = 0.0;
 
+  #if HAS_BED_PROBE
+    int  unified_bed_leveling::g29_grid_size;
+  #endif
+
   /**
    *   G29: Unified Bed Leveling by Roxy
    *
    *   Parameters understood by this leveling system:
    *
    *   A     Activate   Activate the Unified Bed Leveling system.
    *
    *   B #   Business   Use the 'Business Card' mode of the Manual Probe subsystem with P2.
    *                    Note: A non-compressible Spark Gap feeler gauge is recommended over a business card.
    *                    In this mode of G29 P2, a business or index card is used as a shim that the nozzle can
@@ -303,29 +306,29 @@
    */
 
   void unified_bed_leveling::G29() {
 
     if (!settings.calc_num_meshes()) {
       SERIAL_PROTOCOLLNPGM("?You need to enable your EEPROM and initialize it");
       SERIAL_PROTOCOLLNPGM("with M502, M500, M501 in that order.\n");
       return;
     }
 
+    if (g29_parameter_parsing()) return; // abort if parsing the simple parameters causes a problem,
+
     // Check for commands that require the printer to be homed
     if (axis_unhomed_error()) {
       const int8_t p_val = parser.intval('P', -1);
       if (p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J'))
         gcode.home_all_axes();
     }
 
-    if (g29_parameter_parsing()) return; // abort if parsing the simple parameters causes a problem,
-
     // Invalidate Mesh Points. This command is a little bit asymmetrical because
     // it directly specifies the repetition count and does not use the 'R' parameter.
     if (parser.seen('I')) {
       uint8_t cnt = 0;
       g29_repetition_cnt = parser.has_value() ? parser.value_int() : 1;
       if (g29_repetition_cnt >= GRID_MAX_POINTS) {
         set_all_mesh_points_to_value(NAN);
       }
       else {
         while (g29_repetition_cnt--) {
@@ -374,87 +377,95 @@
           break;
         case 2:
           // Allow the user to specify the height because 10mm is a little extreme in some cases.
           for (uint8_t x = (GRID_MAX_POINTS_X) / 3; x < 2 * (GRID_MAX_POINTS_X) / 3; x++)   // Create a rectangular raised area in
             for (uint8_t y = (GRID_MAX_POINTS_Y) / 3; y < 2 * (GRID_MAX_POINTS_Y) / 3; y++) // the center of the bed
               z_values[x][y] += parser.seen('C') ? g29_constant : 9.99;
           break;
       }
     }
 
-    if (parser.seen('J')) {
-      if (g29_grid_size) {  // if not 0 it is a normal n x n grid being probed
-        save_ubl_active_state_and_disable();
-        tilt_mesh_based_on_probed_grid(parser.seen('T'));
-        restore_ubl_active_state_and_leave();
-      }
-      else { // grid_size == 0 : A 3-Point leveling has been requested
-        float z3, z2, z1 = probe_pt(LOGICAL_X_POSITION(UBL_PROBE_PT_1_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_1_Y), false, g29_verbose_level);
-        if (!isnan(z1)) {
-          z2 = probe_pt(LOGICAL_X_POSITION(UBL_PROBE_PT_2_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_2_Y), false, g29_verbose_level);
-          if (!isnan(z2))
-            z3 = probe_pt(LOGICAL_X_POSITION(UBL_PROBE_PT_3_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_3_Y), true, g29_verbose_level);
-        }
+    #if HAS_BED_PROBE
 
-        if (isnan(z1) || isnan(z2) || isnan(z3)) { // probe_pt will return NAN if unreachable
-          SERIAL_ERROR_START();
-          SERIAL_ERRORLNPGM("Attempt to probe off the bed.");
-          goto LEAVE;
+      if (parser.seen('J')) {
+        if (g29_grid_size) {  // if not 0 it is a normal n x n grid being probed
+          save_ubl_active_state_and_disable();
+          tilt_mesh_based_on_probed_grid(parser.seen('T'));
+          restore_ubl_active_state_and_leave();
         }
+        else { // grid_size == 0 : A 3-Point leveling has been requested
+          float z3, z2, z1 = probe_pt(LOGICAL_X_POSITION(UBL_PROBE_PT_1_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_1_Y), false, g29_verbose_level);
+          if (!isnan(z1)) {
+            z2 = probe_pt(LOGICAL_X_POSITION(UBL_PROBE_PT_2_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_2_Y), false, g29_verbose_level);
+            if (!isnan(z2))
+              z3 = probe_pt(LOGICAL_X_POSITION(UBL_PROBE_PT_3_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_3_Y), true, g29_verbose_level);
+          }
 
-        // Adjust z1, z2, z3 by the Mesh Height at these points. Just because they're non-zero
-        // doesn't mean the Mesh is tilted! (Compensate each probe point by what the Mesh says
-        // its height is.)
+          if (isnan(z1) || isnan(z2) || isnan(z3)) { // probe_pt will return NAN if unreachable
+            SERIAL_ERROR_START();
+            SERIAL_ERRORLNPGM("Attempt to probe off the bed.");
+            goto LEAVE;
+          }
 
-        save_ubl_active_state_and_disable();
-        z1 -= get_z_correction(LOGICAL_X_POSITION(UBL_PROBE_PT_1_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_1_Y)) /* + zprobe_zoffset */ ;
-        z2 -= get_z_correction(LOGICAL_X_POSITION(UBL_PROBE_PT_2_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_2_Y)) /* + zprobe_zoffset */ ;
-        z3 -= get_z_correction(LOGICAL_X_POSITION(UBL_PROBE_PT_3_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_3_Y)) /* + zprobe_zoffset */ ;
+          // Adjust z1, z2, z3 by the Mesh Height at these points. Just because they're non-zero
+          // doesn't mean the Mesh is tilted! (Compensate each probe point by what the Mesh says
+          // its height is.)
 
-        do_blocking_move_to_xy(0.5 * (UBL_MESH_MAX_X - (UBL_MESH_MIN_X)), 0.5 * (UBL_MESH_MAX_Y - (UBL_MESH_MIN_Y)));
-        tilt_mesh_based_on_3pts(z1, z2, z3);
-        restore_ubl_active_state_and_leave();
+          save_ubl_active_state_and_disable();
+          z1 -= get_z_correction(LOGICAL_X_POSITION(UBL_PROBE_PT_1_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_1_Y)) /* + zprobe_zoffset */ ;
+          z2 -= get_z_correction(LOGICAL_X_POSITION(UBL_PROBE_PT_2_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_2_Y)) /* + zprobe_zoffset */ ;
+          z3 -= get_z_correction(LOGICAL_X_POSITION(UBL_PROBE_PT_3_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_3_Y)) /* + zprobe_zoffset */ ;
+
+          do_blocking_move_to_xy(0.5 * (UBL_MESH_MAX_X - (UBL_MESH_MIN_X)), 0.5 * (UBL_MESH_MAX_Y - (UBL_MESH_MIN_Y)));
+          tilt_mesh_based_on_3pts(z1, z2, z3);
+          restore_ubl_active_state_and_leave();
+        }
       }
-    }
+
+    #endif // HAS_BED_PROBE
 
     if (parser.seen('P')) {
       if (WITHIN(g29_phase_value, 0, 1) && state.storage_slot == -1) {
         state.storage_slot = 0;
         SERIAL_PROTOCOLLNPGM("Default storage slot 0 selected.");
       }
 
       switch (g29_phase_value) {
         case 0:
           //
           // Zero Mesh Data
           //
           reset();
           SERIAL_PROTOCOLLNPGM("Mesh zeroed.");
           break;
 
-        case 1:
-          //
-          // Invalidate Entire Mesh and Automatically Probe Mesh in areas that can be reached by the probe
-          //
-          if (!parser.seen('C')) {
-            invalidate();
-            SERIAL_PROTOCOLLNPGM("Mesh invalidated. Probing mesh.");
-          }
-          if (g29_verbose_level > 1) {
-            SERIAL_PROTOCOLPAIR("Probing Mesh Points Closest to (", g29_x_pos);
-            SERIAL_PROTOCOLCHAR(',');
-            SERIAL_PROTOCOL(g29_y_pos);
-            SERIAL_PROTOCOLLNPGM(").\n");
-          }
-          probe_entire_mesh(g29_x_pos + X_PROBE_OFFSET_FROM_EXTRUDER, g29_y_pos + Y_PROBE_OFFSET_FROM_EXTRUDER,
-                            parser.seen('T'), parser.seen('E'), parser.seen('U'));
-          break;
+        #if HAS_BED_PROBE
+
+          case 1:
+            //
+            // Invalidate Entire Mesh and Automatically Probe Mesh in areas that can be reached by the probe
+            //
+            if (!parser.seen('C')) {
+              invalidate();
+              SERIAL_PROTOCOLLNPGM("Mesh invalidated. Probing mesh.");
+            }
+            if (g29_verbose_level > 1) {
+              SERIAL_PROTOCOLPAIR("Probing Mesh Points Closest to (", g29_x_pos);
+              SERIAL_PROTOCOLCHAR(',');
+              SERIAL_PROTOCOL(g29_y_pos);
+              SERIAL_PROTOCOLLNPGM(").\n");
+            }
+            probe_entire_mesh(g29_x_pos + X_PROBE_OFFSET_FROM_EXTRUDER, g29_y_pos + Y_PROBE_OFFSET_FROM_EXTRUDER,
+                              parser.seen('T'), parser.seen('E'), parser.seen('U'));
+            break;
+
+        #endif
 
         case 2: {
           #if ENABLED(NEWPANEL)
             //
             // Manually Probe Mesh in areas that can't be reached by the probe
             //
             SERIAL_PROTOCOLLNPGM("Manually probing unreachable mesh locations.");
             do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
             if (!g29_x_flag && !g29_y_flag) {
               /**
@@ -769,175 +780,180 @@
             z_values[x][y] -= mean + g29_constant;
   }
 
   void unified_bed_leveling::shift_mesh_height() {
     for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
         if (!isnan(z_values[x][y]))
           z_values[x][y] += g29_constant;
   }
 
-  /**
-   * Probe all invalidated locations of the mesh that can be reached by the probe.
-   * This attempts to fill in locations closest to the nozzle's start location first.
-   */
-  void unified_bed_leveling::probe_entire_mesh(const float &lx, const float &ly, const bool do_ubl_mesh_map, const bool stow_probe, bool close_or_far) {
-    mesh_index_pair location;
-
-    has_control_of_lcd_panel = true;
-    save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
-    DEPLOY_PROBE();
-
-    uint16_t max_iterations = GRID_MAX_POINTS;
+  #if HAS_BED_PROBE
 
-    do {
-      #if ENABLED(NEWPANEL)
-        if (ubl_lcd_clicked()) {
-          SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.\n");
-          lcd_quick_feedback();
-          STOW_PROBE();
-          while (ubl_lcd_clicked()) idle();
-          has_control_of_lcd_panel = false;
-          restore_ubl_active_state_and_leave();
-          safe_delay(50);  // Debounce the Encoder wheel
-          return;
-        }
-      #endif
-
-      location = find_closest_mesh_point_of_type(INVALID, lx, ly, USE_PROBE_AS_REFERENCE, NULL, close_or_far);
-
-      if (location.x_index >= 0) {    // mesh point found and is reachable by probe
-        const float rawx = mesh_index_to_xpos(location.x_index),
-                    rawy = mesh_index_to_ypos(location.y_index);
+    /**
+     * Probe all invalidated locations of the mesh that can be reached by the probe.
+     * This attempts to fill in locations closest to the nozzle's start location first.
+     */
+    void unified_bed_leveling::probe_entire_mesh(const float &lx, const float &ly, const bool do_ubl_mesh_map, const bool stow_probe, bool close_or_far) {
+      mesh_index_pair location;
 
-        const float measured_z = probe_pt(LOGICAL_X_POSITION(rawx), LOGICAL_Y_POSITION(rawy), stow_probe, g29_verbose_level); // TODO: Needs error handling
-        z_values[location.x_index][location.y_index] = measured_z;
-      }
+      has_control_of_lcd_panel = true;
+      save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
+      DEPLOY_PROBE();
 
-      if (do_ubl_mesh_map) display_map(g29_map_type);
+      uint16_t max_iterations = GRID_MAX_POINTS;
 
-    } while (location.x_index >= 0 && --max_iterations);
+      do {
+        #if ENABLED(NEWPANEL)
+          if (ubl_lcd_clicked()) {
+            SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.\n");
+            lcd_quick_feedback();
+            STOW_PROBE();
+            while (ubl_lcd_clicked()) idle();
+            has_control_of_lcd_panel = false;
+            restore_ubl_active_state_and_leave();
+            safe_delay(50);  // Debounce the Encoder wheel
+            return;
+          }
+        #endif
 
-    STOW_PROBE();
-    restore_ubl_active_state_and_leave();
+        location = find_closest_mesh_point_of_type(INVALID, lx, ly, USE_PROBE_AS_REFERENCE, NULL, close_or_far);
 
-    do_blocking_move_to_xy(
-      constrain(lx - (X_PROBE_OFFSET_FROM_EXTRUDER), UBL_MESH_MIN_X, UBL_MESH_MAX_X),
-      constrain(ly - (Y_PROBE_OFFSET_FROM_EXTRUDER), UBL_MESH_MIN_Y, UBL_MESH_MAX_Y)
-    );
-  }
+        if (location.x_index >= 0) {    // mesh point found and is reachable by probe
+          const float rawx = mesh_index_to_xpos(location.x_index),
+                      rawy = mesh_index_to_ypos(location.y_index);
 
-  void unified_bed_leveling::tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3) {
-    matrix_3x3 rotation;
-    vector_3 v1 = vector_3( (UBL_PROBE_PT_1_X - UBL_PROBE_PT_2_X),
-                            (UBL_PROBE_PT_1_Y - UBL_PROBE_PT_2_Y),
-                            (z1 - z2) ),
+          const float measured_z = probe_pt(LOGICAL_X_POSITION(rawx), LOGICAL_Y_POSITION(rawy), stow_probe, g29_verbose_level); // TODO: Needs error handling
+          z_values[location.x_index][location.y_index] = measured_z;
+        }
 
-             v2 = vector_3( (UBL_PROBE_PT_3_X - UBL_PROBE_PT_2_X),
-                            (UBL_PROBE_PT_3_Y - UBL_PROBE_PT_2_Y),
-                            (z3 - z2) ),
+        if (do_ubl_mesh_map) display_map(g29_map_type);
 
-             normal = vector_3::cross(v1, v2);
+      } while (location.x_index >= 0 && --max_iterations);
 
-    normal = normal.get_normal();
+      STOW_PROBE();
+      restore_ubl_active_state_and_leave();
 
-    /**
-     * This vector is normal to the tilted plane.
-     * However, we don't know its direction. We need it to point up. So if
-     * Z is negative, we need to invert the sign of all components of the vector
-     */
-    if (normal.z < 0.0) {
-      normal.x = -normal.x;
-      normal.y = -normal.y;
-      normal.z = -normal.z;
+      do_blocking_move_to_xy(
+        constrain(lx - (X_PROBE_OFFSET_FROM_EXTRUDER), UBL_MESH_MIN_X, UBL_MESH_MAX_X),
+        constrain(ly - (Y_PROBE_OFFSET_FROM_EXTRUDER), UBL_MESH_MIN_Y, UBL_MESH_MAX_Y)
+      );
     }
 
-    rotation = matrix_3x3::create_look_at(vector_3(normal.x, normal.y, 1));
-
-    if (g29_verbose_level > 2) {
-      SERIAL_ECHOPGM("bed plane normal = [");
-      SERIAL_PROTOCOL_F(normal.x, 7);
-      SERIAL_PROTOCOLCHAR(',');
-      SERIAL_PROTOCOL_F(normal.y, 7);
-      SERIAL_PROTOCOLCHAR(',');
-      SERIAL_PROTOCOL_F(normal.z, 7);
-      SERIAL_ECHOLNPGM("]");
-      rotation.debug(PSTR("rotation matrix:"));
-    }
+    void unified_bed_leveling::tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3) {
+      matrix_3x3 rotation;
+      vector_3 v1 = vector_3( (UBL_PROBE_PT_1_X - UBL_PROBE_PT_2_X),
+                              (UBL_PROBE_PT_1_Y - UBL_PROBE_PT_2_Y),
+                              (z1 - z2) ),
+
+               v2 = vector_3( (UBL_PROBE_PT_3_X - UBL_PROBE_PT_2_X),
+                              (UBL_PROBE_PT_3_Y - UBL_PROBE_PT_2_Y),
+                              (z3 - z2) ),
+
+               normal = vector_3::cross(v1, v2);
+
+      normal = normal.get_normal();
+
+      /**
+       * This vector is normal to the tilted plane.
+       * However, we don't know its direction. We need it to point up. So if
+       * Z is negative, we need to invert the sign of all components of the vector
+       */
+      if (normal.z < 0.0) {
+        normal.x = -normal.x;
+        normal.y = -normal.y;
+        normal.z = -normal.z;
+      }
 
-    //
-    // All of 3 of these points should give us the same d constant
-    //
+      rotation = matrix_3x3::create_look_at(vector_3(normal.x, normal.y, 1));
 
-    float t = normal.x * (UBL_PROBE_PT_1_X) + normal.y * (UBL_PROBE_PT_1_Y),
-          d = t + normal.z * z1;
+      if (g29_verbose_level > 2) {
+        SERIAL_ECHOPGM("bed plane normal = [");
+        SERIAL_PROTOCOL_F(normal.x, 7);
+        SERIAL_PROTOCOLCHAR(',');
+        SERIAL_PROTOCOL_F(normal.y, 7);
+        SERIAL_PROTOCOLCHAR(',');
+        SERIAL_PROTOCOL_F(normal.z, 7);
+        SERIAL_ECHOLNPGM("]");
+        rotation.debug(PSTR("rotation matrix:"));
+      }
 
-    if (g29_verbose_level>2) {
-      SERIAL_ECHOPGM("D constant: ");
-      SERIAL_PROTOCOL_F(d, 7);
-      SERIAL_ECHOLNPGM(" ");
-    }
+      //
+      // All of 3 of these points should give us the same d constant
+      //
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPGM("d from 1st point: ");
-        SERIAL_ECHO_F(d, 6);
-        SERIAL_EOL();
-        t = normal.x * (UBL_PROBE_PT_2_X) + normal.y * (UBL_PROBE_PT_2_Y);
-        d = t + normal.z * z2;
-        SERIAL_ECHOPGM("d from 2nd point: ");
-        SERIAL_ECHO_F(d, 6);
-        SERIAL_EOL();
-        t = normal.x * (UBL_PROBE_PT_3_X) + normal.y * (UBL_PROBE_PT_3_Y);
-        d = t + normal.z * z3;
-        SERIAL_ECHOPGM("d from 3rd point: ");
-        SERIAL_ECHO_F(d, 6);
-        SERIAL_EOL();
+      float t = normal.x * (UBL_PROBE_PT_1_X) + normal.y * (UBL_PROBE_PT_1_Y),
+            d = t + normal.z * z1;
+
+      if (g29_verbose_level>2) {
+        SERIAL_ECHOPGM("D constant: ");
+        SERIAL_PROTOCOL_F(d, 7);
+        SERIAL_ECHOLNPGM(" ");
       }
-    #endif
 
-    for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
-      for (uint8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
-        float x_tmp = mesh_index_to_xpos(i),
-              y_tmp = mesh_index_to_ypos(j),
-              z_tmp = z_values[i][j];
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOPGM("before rotation = [");
-            SERIAL_PROTOCOL_F(x_tmp, 7);
-            SERIAL_PROTOCOLCHAR(',');
-            SERIAL_PROTOCOL_F(y_tmp, 7);
-            SERIAL_PROTOCOLCHAR(',');
-            SERIAL_PROTOCOL_F(z_tmp, 7);
-            SERIAL_ECHOPGM("]   ---> ");
-            safe_delay(20);
-          }
-        #endif
-        apply_rotation_xyz(rotation, x_tmp, y_tmp, z_tmp);
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOPGM("after rotation = [");
-            SERIAL_PROTOCOL_F(x_tmp, 7);
-            SERIAL_PROTOCOLCHAR(',');
-            SERIAL_PROTOCOL_F(y_tmp, 7);
-            SERIAL_PROTOCOLCHAR(',');
-            SERIAL_PROTOCOL_F(z_tmp, 7);
-            SERIAL_ECHOLNPGM("]");
-            safe_delay(55);
-          }
-        #endif
-        z_values[i][j] += z_tmp - d;
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) {
+          SERIAL_ECHOPGM("d from 1st point: ");
+          SERIAL_ECHO_F(d, 6);
+          SERIAL_EOL();
+          t = normal.x * (UBL_PROBE_PT_2_X) + normal.y * (UBL_PROBE_PT_2_Y);
+          d = t + normal.z * z2;
+          SERIAL_ECHOPGM("d from 2nd point: ");
+          SERIAL_ECHO_F(d, 6);
+          SERIAL_EOL();
+          t = normal.x * (UBL_PROBE_PT_3_X) + normal.y * (UBL_PROBE_PT_3_Y);
+          d = t + normal.z * z3;
+          SERIAL_ECHOPGM("d from 3rd point: ");
+          SERIAL_ECHO_F(d, 6);
+          SERIAL_EOL();
+        }
+      #endif
+
+      for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
+        for (uint8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
+          float x_tmp = mesh_index_to_xpos(i),
+                y_tmp = mesh_index_to_ypos(j),
+                z_tmp = z_values[i][j];
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) {
+              SERIAL_ECHOPGM("before rotation = [");
+              SERIAL_PROTOCOL_F(x_tmp, 7);
+              SERIAL_PROTOCOLCHAR(',');
+              SERIAL_PROTOCOL_F(y_tmp, 7);
+              SERIAL_PROTOCOLCHAR(',');
+              SERIAL_PROTOCOL_F(z_tmp, 7);
+              SERIAL_ECHOPGM("]   ---> ");
+              safe_delay(20);
+            }
+          #endif
+          apply_rotation_xyz(rotation, x_tmp, y_tmp, z_tmp);
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) {
+              SERIAL_ECHOPGM("after rotation = [");
+              SERIAL_PROTOCOL_F(x_tmp, 7);
+              SERIAL_PROTOCOLCHAR(',');
+              SERIAL_PROTOCOL_F(y_tmp, 7);
+              SERIAL_PROTOCOLCHAR(',');
+              SERIAL_PROTOCOL_F(z_tmp, 7);
+              SERIAL_ECHOLNPGM("]");
+              safe_delay(55);
+            }
+          #endif
+          z_values[i][j] += z_tmp - d;
+        }
       }
     }
-  }
+
+  #endif // HAS_BED_PROBE
 
   #if ENABLED(NEWPANEL)
+
     float unified_bed_leveling::measure_point_with_encoder() {
 
       while (ubl_lcd_clicked()) delay(50);  // wait for user to release encoder wheel
       delay(50);  // debounce
 
       KEEPALIVE_STATE(PAUSED_FOR_USER);
       while (!ubl_lcd_clicked()) {     // we need the loop to move the nozzle based on the encoder wheel here!
         idle();
         if (encoder_diff) {
           do_blocking_move_to_z(current_position[Z_AXIS] + 0.01 * float(encoder_diff));
@@ -1073,21 +1089,22 @@
         }
       } while (location.x_index >= 0 && location.y_index >= 0);
 
       if (do_ubl_mesh_map) display_map(g29_map_type);
 
       restore_ubl_active_state_and_leave();
       KEEPALIVE_STATE(IN_HANDLER);
       do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
       do_blocking_move_to_xy(lx, ly);
     }
-  #endif
+
+  #endif // NEWPANEL
 
   bool unified_bed_leveling::g29_parameter_parsing() {
     bool err_flag = false;
 
     #if ENABLED(NEWPANEL)
       LCD_MESSAGEPGM(MSG_UBL_DOING_G29);
       lcd_quick_feedback();
     #endif
 
     g29_constant = 0.0;
@@ -1107,33 +1124,48 @@
       }
     }
 
     g29_verbose_level = parser.seen('V') ? parser.value_int() : 0;
     if (!WITHIN(g29_verbose_level, 0, 4)) {
       SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).\n");
       err_flag = true;
     }
 
     if (parser.seen('P')) {
-      g29_phase_value = parser.value_int();
-      if (!WITHIN(g29_phase_value, 0, 6)) {
-        SERIAL_PROTOCOLLNPGM("?(P)hase value invalid (0-6).\n");
-        err_flag = true;
-      }
+      const int pv = parser.value_int();
+      #if !HAS_BED_PROBE
+        if (pv == 1) {
+          SERIAL_PROTOCOLLNPGM("G29 P1 requires a probe.\n");
+          err_flag = true;
+        }
+        else
+      #endif
+        {
+          g29_phase_value = pv;
+           if (!WITHIN(g29_phase_value, 0, 6)) {
+             SERIAL_PROTOCOLLNPGM("?(P)hase value invalid (0-6).\n");
+             err_flag = true;
+           }
+         }
     }
 
     if (parser.seen('J')) {
-      g29_grid_size = parser.has_value() ? parser.value_int() : 0;
-      if (g29_grid_size && !WITHIN(g29_grid_size, 2, 9)) {
-        SERIAL_PROTOCOLLNPGM("?Invalid grid size (J) specified (2-9).\n");
+      #if HAS_BED_PROBE
+        g29_grid_size = parser.has_value() ? parser.value_int() : 0;
+        if (g29_grid_size && !WITHIN(g29_grid_size, 2, 9)) {
+          SERIAL_PROTOCOLLNPGM("?Invalid grid size (J) specified (2-9).\n");
+          err_flag = true;
+        }
+      #else
+        SERIAL_PROTOCOLLNPGM("G29 J action requires a probe.\n");
         err_flag = true;
-      }
+      #endif
     }
 
     if (g29_x_flag != g29_y_flag) {
       SERIAL_PROTOCOLLNPGM("Both X & Y locations must be specified.\n");
       err_flag = true;
     }
 
     // If X or Y are not valid, use center of the bed values
     if (!WITHIN(RAW_X_POSITION(g29_x_pos), X_MIN_BED, X_MAX_BED)) g29_x_pos = LOGICAL_X_POSITION(X_CENTER);
     if (!WITHIN(RAW_Y_POSITION(g29_y_pos), Y_MIN_BED, Y_MAX_BED)) g29_y_pos = LOGICAL_Y_POSITION(Y_CENTER);
@@ -1617,164 +1649,168 @@
       }
       else {
         const int8_t dir = ey > sy ? 1 : -1;
          for (uint8_t x = sx; x != ex; ++x)
           for (uint8_t y = sy; y != ey; y += dir)
             if (smart_fill_one(x, y, 0, dir)) break;
       }
     }
   }
 
-  void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map) {
-    constexpr int16_t x_min = max(MIN_PROBE_X, UBL_MESH_MIN_X),
-                      x_max = min(MAX_PROBE_X, UBL_MESH_MAX_X),
-                      y_min = max(MIN_PROBE_Y, UBL_MESH_MIN_Y),
-                      y_max = min(MAX_PROBE_Y, UBL_MESH_MAX_Y);
-
-    const float dx = float(x_max - x_min) / (g29_grid_size - 1.0),
-                dy = float(y_max - y_min) / (g29_grid_size - 1.0);
-
-    struct linear_fit_data lsf_results;
-    incremental_LSF_reset(&lsf_results);
-
-    bool zig_zag = false;
-    for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
-      const float x = float(x_min) + ix * dx;
-      for (int8_t iy = 0; iy < g29_grid_size; iy++) {
-        const float y = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
-        float measured_z = probe_pt(LOGICAL_X_POSITION(x), LOGICAL_Y_POSITION(y), parser.seen('E'), g29_verbose_level); // TODO: Needs error handling
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_CHAR('(');
-            SERIAL_PROTOCOL_F(x, 7);
-            SERIAL_CHAR(',');
-            SERIAL_PROTOCOL_F(y, 7);
-            SERIAL_ECHOPGM(")   logical: ");
-            SERIAL_CHAR('(');
-            SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(x), 7);
-            SERIAL_CHAR(',');
-            SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(y), 7);
-            SERIAL_ECHOPGM(")   measured: ");
-            SERIAL_PROTOCOL_F(measured_z, 7);
-            SERIAL_ECHOPGM("   correction: ");
-            SERIAL_PROTOCOL_F(get_z_correction(LOGICAL_X_POSITION(x), LOGICAL_Y_POSITION(y)), 7);
-          }
-        #endif
+  #if HAS_BED_PROBE
 
-        measured_z -= get_z_correction(LOGICAL_X_POSITION(x), LOGICAL_Y_POSITION(y)) /* + zprobe_zoffset */ ;
-
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOPGM("   final >>>---> ");
-            SERIAL_PROTOCOL_F(measured_z, 7);
-            SERIAL_EOL();
-          }
-        #endif
-
-        incremental_LSF(&lsf_results, x, y, measured_z);
-      }
-
-      zig_zag ^= true;
-    }
-
-    if (finish_incremental_LSF(&lsf_results)) {
-      SERIAL_ECHOPGM("Could not complete LSF!");
-      return;
-    }
+    void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map) {
+      constexpr int16_t x_min = max(MIN_PROBE_X, UBL_MESH_MIN_X),
+                        x_max = min(MAX_PROBE_X, UBL_MESH_MAX_X),
+                        y_min = max(MIN_PROBE_Y, UBL_MESH_MIN_Y),
+                        y_max = min(MAX_PROBE_Y, UBL_MESH_MAX_Y);
 
-    if (g29_verbose_level > 3) {
-      SERIAL_ECHOPGM("LSF Results A=");
-      SERIAL_PROTOCOL_F(lsf_results.A, 7);
-      SERIAL_ECHOPGM("  B=");
-      SERIAL_PROTOCOL_F(lsf_results.B, 7);
-      SERIAL_ECHOPGM("  D=");
-      SERIAL_PROTOCOL_F(lsf_results.D, 7);
-      SERIAL_EOL();
-    }
+      const float dx = float(x_max - x_min) / (g29_grid_size - 1.0),
+                  dy = float(y_max - y_min) / (g29_grid_size - 1.0);
 
-    vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1.0000).get_normal();
+      struct linear_fit_data lsf_results;
+      incremental_LSF_reset(&lsf_results);
+
+      bool zig_zag = false;
+      for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
+        const float x = float(x_min) + ix * dx;
+        for (int8_t iy = 0; iy < g29_grid_size; iy++) {
+          const float y = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
+          float measured_z = probe_pt(LOGICAL_X_POSITION(x), LOGICAL_Y_POSITION(y), parser.seen('E'), g29_verbose_level); // TODO: Needs error handling
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) {
+              SERIAL_CHAR('(');
+              SERIAL_PROTOCOL_F(x, 7);
+              SERIAL_CHAR(',');
+              SERIAL_PROTOCOL_F(y, 7);
+              SERIAL_ECHOPGM(")   logical: ");
+              SERIAL_CHAR('(');
+              SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(x), 7);
+              SERIAL_CHAR(',');
+              SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(y), 7);
+              SERIAL_ECHOPGM(")   measured: ");
+              SERIAL_PROTOCOL_F(measured_z, 7);
+              SERIAL_ECHOPGM("   correction: ");
+              SERIAL_PROTOCOL_F(get_z_correction(LOGICAL_X_POSITION(x), LOGICAL_Y_POSITION(y)), 7);
+            }
+          #endif
 
-    if (g29_verbose_level > 2) {
-      SERIAL_ECHOPGM("bed plane normal = [");
-      SERIAL_PROTOCOL_F(normal.x, 7);
-      SERIAL_PROTOCOLCHAR(',');
-      SERIAL_PROTOCOL_F(normal.y, 7);
-      SERIAL_PROTOCOLCHAR(',');
-      SERIAL_PROTOCOL_F(normal.z, 7);
-      SERIAL_ECHOLNPGM("]");
-    }
+          measured_z -= get_z_correction(LOGICAL_X_POSITION(x), LOGICAL_Y_POSITION(y)) /* + zprobe_zoffset */ ;
 
-    matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) {
+              SERIAL_ECHOPGM("   final >>>---> ");
+              SERIAL_PROTOCOL_F(measured_z, 7);
+              SERIAL_EOL();
+            }
+          #endif
 
-    for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
-      for (uint8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
-        float x_tmp = mesh_index_to_xpos(i),
-              y_tmp = mesh_index_to_ypos(j),
-              z_tmp = z_values[i][j];
-
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOPGM("before rotation = [");
-            SERIAL_PROTOCOL_F(x_tmp, 7);
-            SERIAL_PROTOCOLCHAR(',');
-            SERIAL_PROTOCOL_F(y_tmp, 7);
-            SERIAL_PROTOCOLCHAR(',');
-            SERIAL_PROTOCOL_F(z_tmp, 7);
-            SERIAL_ECHOPGM("]   ---> ");
-            safe_delay(20);
-          }
-        #endif
+          incremental_LSF(&lsf_results, x, y, measured_z);
+        }
 
-        apply_rotation_xyz(rotation, x_tmp, y_tmp, z_tmp);
-
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOPGM("after rotation = [");
-            SERIAL_PROTOCOL_F(x_tmp, 7);
-            SERIAL_PROTOCOLCHAR(',');
-            SERIAL_PROTOCOL_F(y_tmp, 7);
-            SERIAL_PROTOCOLCHAR(',');
-            SERIAL_PROTOCOL_F(z_tmp, 7);
-            SERIAL_ECHOLNPGM("]");
-            safe_delay(55);
-          }
-        #endif
+        zig_zag ^= true;
+      }
 
-        z_values[i][j] += z_tmp - lsf_results.D;
+      if (finish_incremental_LSF(&lsf_results)) {
+        SERIAL_ECHOPGM("Could not complete LSF!");
+        return;
       }
-    }
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        rotation.debug(PSTR("rotation matrix:"));
+      if (g29_verbose_level > 3) {
         SERIAL_ECHOPGM("LSF Results A=");
         SERIAL_PROTOCOL_F(lsf_results.A, 7);
         SERIAL_ECHOPGM("  B=");
         SERIAL_PROTOCOL_F(lsf_results.B, 7);
         SERIAL_ECHOPGM("  D=");
         SERIAL_PROTOCOL_F(lsf_results.D, 7);
         SERIAL_EOL();
-        safe_delay(55);
+      }
 
+      vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1.0000).get_normal();
+
+      if (g29_verbose_level > 2) {
         SERIAL_ECHOPGM("bed plane normal = [");
         SERIAL_PROTOCOL_F(normal.x, 7);
         SERIAL_PROTOCOLCHAR(',');
         SERIAL_PROTOCOL_F(normal.y, 7);
         SERIAL_PROTOCOLCHAR(',');
         SERIAL_PROTOCOL_F(normal.z, 7);
-        SERIAL_ECHOPGM("]\n");
-        SERIAL_EOL();
+        SERIAL_ECHOLNPGM("]");
       }
-    #endif
 
-    if (do_ubl_mesh_map) display_map(g29_map_type);
-  }
+      matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
+
+      for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
+        for (uint8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
+          float x_tmp = mesh_index_to_xpos(i),
+                y_tmp = mesh_index_to_ypos(j),
+                z_tmp = z_values[i][j];
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) {
+              SERIAL_ECHOPGM("before rotation = [");
+              SERIAL_PROTOCOL_F(x_tmp, 7);
+              SERIAL_PROTOCOLCHAR(',');
+              SERIAL_PROTOCOL_F(y_tmp, 7);
+              SERIAL_PROTOCOLCHAR(',');
+              SERIAL_PROTOCOL_F(z_tmp, 7);
+              SERIAL_ECHOPGM("]   ---> ");
+              safe_delay(20);
+            }
+          #endif
+
+          apply_rotation_xyz(rotation, x_tmp, y_tmp, z_tmp);
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) {
+              SERIAL_ECHOPGM("after rotation = [");
+              SERIAL_PROTOCOL_F(x_tmp, 7);
+              SERIAL_PROTOCOLCHAR(',');
+              SERIAL_PROTOCOL_F(y_tmp, 7);
+              SERIAL_PROTOCOLCHAR(',');
+              SERIAL_PROTOCOL_F(z_tmp, 7);
+              SERIAL_ECHOLNPGM("]");
+              safe_delay(55);
+            }
+          #endif
+
+          z_values[i][j] += z_tmp - lsf_results.D;
+        }
+      }
+
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) {
+          rotation.debug(PSTR("rotation matrix:"));
+          SERIAL_ECHOPGM("LSF Results A=");
+          SERIAL_PROTOCOL_F(lsf_results.A, 7);
+          SERIAL_ECHOPGM("  B=");
+          SERIAL_PROTOCOL_F(lsf_results.B, 7);
+          SERIAL_ECHOPGM("  D=");
+          SERIAL_PROTOCOL_F(lsf_results.D, 7);
+          SERIAL_EOL();
+          safe_delay(55);
+
+          SERIAL_ECHOPGM("bed plane normal = [");
+          SERIAL_PROTOCOL_F(normal.x, 7);
+          SERIAL_PROTOCOLCHAR(',');
+          SERIAL_PROTOCOL_F(normal.y, 7);
+          SERIAL_PROTOCOLCHAR(',');
+          SERIAL_PROTOCOL_F(normal.z, 7);
+          SERIAL_ECHOPGM("]\n");
+          SERIAL_EOL();
+        }
+      #endif
+
+      if (do_ubl_mesh_map) display_map(g29_map_type);
+    }
+
+  #endif // HAS_BED_PROBE
 
   #if ENABLED(UBL_G29_P31)
     void unified_bed_leveling::smart_fill_wlsf(const float &weight_factor) {
 
       // For each undefined mesh point, compute a distance-weighted least squares fit
       // from all the originally populated mesh points, weighted toward the point
       // being extrapolated so that nearby points will have greater influence on
       // the point being extrapolated.  Then extrapolate the mesh point from WLSF.
 
       static_assert(GRID_MAX_POINTS_Y <= 16, "GRID_MAX_POINTS_Y too big");

commit 551752eac73a6f60de45b6465e2f224b2b2dca24
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 15:35:25 2017 -0500

    Consolidate "bedlevel" code

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
new file mode 100644
index 0000000000..8449050285
--- /dev/null
+++ b/Marlin/src/feature/bedlevel/ubl/ubl_G29.cpp
@@ -0,0 +1,1826 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../../inc/MarlinConfig.h"
+
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+
+  #include "ubl.h"
+
+  #include "../../../Marlin.h"
+  #include "../../../libs/hex_print_routines.h"
+  #include "../../../module/configuration_store.h"
+  #include "../../../lcd/ultralcd.h"
+  #include "../../../module/stepper.h"
+  #include "../../../module/planner.h"
+  #include "../../../module/probe.h"
+  #include "../../../gcode/gcode.h"
+  #include "../../../gcode/parser.h"
+  #include "../../../feature/bedlevel/bedlevel.h"
+  #include "../../../libs/least_squares_fit.h"
+
+  #include <math.h>
+
+  #define UBL_G29_P31
+
+  extern float destination[XYZE], current_position[XYZE];
+
+  #if ENABLED(NEWPANEL)
+    void lcd_return_to_status();
+    void lcd_mesh_edit_setup(float initial);
+    float lcd_mesh_edit();
+    void lcd_z_offset_edit_setup(float);
+    extern void _lcd_ubl_output_map_lcd();
+    float lcd_z_offset_edit();
+  #endif
+
+  extern float meshedit_done;
+  extern long babysteps_done;
+  //extern bool set_probe_deployed(bool);
+  //extern void set_bed_leveling_enabled(bool);
+
+  #define SIZE_OF_LITTLE_RAISE 1
+  #define BIG_RAISE_NOT_NEEDED 0
+
+  int    unified_bed_leveling::g29_verbose_level,
+         unified_bed_leveling::g29_phase_value,
+         unified_bed_leveling::g29_repetition_cnt,
+         unified_bed_leveling::g29_storage_slot = 0,
+         unified_bed_leveling::g29_map_type,
+         unified_bed_leveling::g29_grid_size;
+  bool   unified_bed_leveling::g29_c_flag,
+         unified_bed_leveling::g29_x_flag,
+         unified_bed_leveling::g29_y_flag;
+  float  unified_bed_leveling::g29_x_pos,
+         unified_bed_leveling::g29_y_pos,
+         unified_bed_leveling::g29_card_thickness = 0.0,
+         unified_bed_leveling::g29_constant = 0.0;
+
+  /**
+   *   G29: Unified Bed Leveling by Roxy
+   *
+   *   Parameters understood by this leveling system:
+   *
+   *   A     Activate   Activate the Unified Bed Leveling system.
+   *
+   *   B #   Business   Use the 'Business Card' mode of the Manual Probe subsystem with P2.
+   *                    Note: A non-compressible Spark Gap feeler gauge is recommended over a business card.
+   *                    In this mode of G29 P2, a business or index card is used as a shim that the nozzle can
+   *                    grab onto as it is lowered. In principle, the nozzle-bed distance is the same when the
+   *                    same resistance is felt in the shim. You can omit the numerical value on first invocation
+   *                    of G29 P2 B to measure shim thickness. Subsequent use of 'B' will apply the previously-
+   *                    measured thickness by default.
+   *
+   *   C     Continue   G29 P1 C continues the generation of a partially-constructed Mesh without invalidating
+   *                    previous measurements.
+   *
+   *   C     Constant   G29 P2 C specifies a Constant and tells the Manual Probe subsystem to use the current
+   *                    location in its search for the closest unmeasured Mesh Point.
+   *
+   *                    G29 P3 C specifies the Constant for the fill. Otherwise, uses a "reasonable" value.
+   *
+   *   C     Current    G29 Z C uses the Current location (instead of bed center or nearest edge).
+   *
+   *   D     Disable    Disable the Unified Bed Leveling system.
+   *
+   *   E     Stow_probe Stow the probe after each sampled point.
+   *
+   *   F #   Fade       Fade the amount of Mesh Based Compensation over a specified height. At the
+   *                    specified height, no correction is applied and natural printer kenimatics take over. If no
+   *                    number is specified for the command, 10mm is assumed to be reasonable.
+   *
+   *   H #   Height     With P2, 'H' specifies the Height to raise the nozzle after each manual probe of the bed.
+   *                    If omitted, the nozzle will raise by Z_CLEARANCE_BETWEEN_PROBES.
+   *
+   *   H #   Offset     With P4, 'H' specifies the Offset above the mesh height to place the nozzle.
+   *                    If omitted, Z_CLEARANCE_BETWEEN_PROBES will be used.
+   *
+   *   I #   Invalidate Invalidate the specified number of Mesh Points near the given 'X' 'Y'. If X or Y are omitted,
+   *                    the nozzle location is used. If no 'I' value is given, only the point nearest to the location
+   *                    is invalidated. Use 'T' to produce a map afterward. This command is useful to invalidate a
+   *                    portion of the Mesh so it can be adjusted using other UBL tools. When attempting to invalidate
+   *                    an isolated bad mesh point, the 'T' option shows the nozzle position in the Mesh with (#). You
+   *                    can move the nozzle around and use this feature to select the center of the area (or cell) to
+   *                    invalidate.
+   *
+   *   J #   Grid       Perform a Grid Based Leveling of the current Mesh using a grid with n points on a side.
+   *                    Not specifying a grid size will invoke the 3-Point leveling function.
+   *
+   *   K #   Kompare    Kompare current Mesh with stored Mesh # replacing current Mesh with the result. This
+   *                    command literally performs a diff between two Meshes.
+   *
+   *   L     Load       Load Mesh from the previously activated location in the EEPROM.
+   *
+   *   L #   Load       Load Mesh from the specified location in the EEPROM. Set this location as activated
+   *                    for subsequent Load and Store operations.
+   *
+   *   The P or Phase commands are used for the bulk of the work to setup a Mesh. In general, your Mesh will
+   *   start off being initialized with a G29 P0 or a G29 P1. Further refinement of the Mesh happens with
+   *   each additional Phase that processes it.
+   *
+   *   P0    Phase 0    Zero Mesh Data and turn off the Mesh Compensation System. This reverts the
+   *                    3D Printer to the same state it was in before the Unified Bed Leveling Compensation
+   *                    was turned on. Setting the entire Mesh to Zero is a special case that allows
+   *                    a subsequent G or T leveling operation for backward compatibility.
+   *
+   *   P1    Phase 1    Invalidate entire Mesh and continue with automatic generation of the Mesh data using
+   *                    the Z-Probe. Usually the probe can't reach all areas that the nozzle can reach. On
+   *                    Cartesian printers, points within the X_PROBE_OFFSET_FROM_EXTRUDER and Y_PROBE_OFFSET_FROM_EXTRUDER
+   *                    area cannot be automatically probed. For Delta printers the area in which DELTA_PROBEABLE_RADIUS
+   *                    and DELTA_PRINTABLE_RADIUS do not overlap will not be automatically probed.
+   *
+   *                    Unreachable points will be handled in Phase 2 and Phase 3.
+   *
+   *                    Use 'C' to leave the previous mesh intact and automatically probe needed points. This allows you
+   *                    to invalidate parts of the Mesh but still use Automatic Probing.
+   *
+   *                    The 'X' and 'Y' parameters prioritize where to try and measure points. If omitted, the current
+   *                    probe position is used.
+   *
+   *                    Use 'T' (Topology) to generate a report of mesh generation.
+   *
+   *                    P1 will suspend Mesh generation if the controller button is held down. Note that you may need
+   *                    to press and hold the switch for several seconds if moves are underway.
+   *
+   *   P2    Phase 2    Probe unreachable points.
+   *
+   *                    Use 'H' to set the height between Mesh points. If omitted, Z_CLEARANCE_BETWEEN_PROBES is used.
+   *                    Smaller values will be quicker. Move the nozzle down till it barely touches the bed. Make sure the
+   *                    nozzle is clean and unobstructed. Use caution and move slowly. This can damage your printer!
+   *                    (Uses SIZE_OF_LITTLE_RAISE mm if the nozzle is moving less than BIG_RAISE_NOT_NEEDED mm.)
+   *
+   *                    The 'H' value can be negative if the Mesh dips in a large area. Press and hold the
+   *                    controller button to terminate the current Phase 2 command. You can then re-issue "G29 P 2"
+   *                    with an 'H' parameter more suitable for the area you're manually probing. Note that the command
+   *                    tries to start in a corner of the bed where movement will be predictable. Override the distance
+   *                    calculation location with the X and Y parameters. You can print a Mesh Map (G29 T) to see where
+   *                    the mesh is invalidated and where the nozzle needs to move to complete the command. Use 'C' to
+   *                    indicate that the search should be based on the current position.
+   *
+   *                    The 'B' parameter for this command is described above. It places the manual probe subsystem into
+   *                    Business Card mode where the thickness of a business card is measured and then used to accurately
+   *                    set the nozzle height in all manual probing for the duration of the command. A Business card can
+   *                    be used, but you'll get better results with a flexible Shim that doesn't compress. This makes it
+   *                    easier to produce similar amounts of force and get more accurate measurements. Google if you're
+   *                    not sure how to use a shim.
+   *
+   *                    The 'T' (Map) parameter helps track Mesh building progress.
+   *
+   *                    NOTE: P2 requires an LCD controller!
+   *
+   *   P3    Phase 3    Fill the unpopulated regions of the Mesh with a fixed value. There are two different paths to
+   *                    go down:
+   *
+   *                    - If a 'C' constant is specified, the closest invalid mesh points to the nozzle will be filled,
+   *                      and a repeat count can then also be specified with 'R'.
+   *
+   *                    - Leaving out 'C' invokes Smart Fill, which scans the mesh from the edges inward looking for
+   *                      invalid mesh points. Adjacent points are used to determine the bed slope. If the bed is sloped
+   *                      upward from the invalid point, it takes the value of the nearest point. If sloped downward, it's
+   *                      replaced by a value that puts all three points in a line. This version of G29 P3 is a quick, easy
+   *                      and (usually) safe way to populate unprobed mesh regions before continuing to G26 Mesh Validation
+   *                      Pattern. Note that this populates the mesh with unverified values. Pay attention and use caution.
+   *
+   *   P4    Phase 4    Fine tune the Mesh. The Delta Mesh Compensation System assumes the existence of
+   *                    an LCD Panel. It is possible to fine tune the mesh without an LCD Panel using
+   *                    G42 and M421. See the UBL documentation for further details.
+   *
+   *                    Phase 4 is meant to be used with G26 Mesh Validation to fine tune the mesh by direct editing
+   *                    of Mesh Points. Raise and lower points to fine tune the mesh until it gives consistently reliable
+   *                    adhesion.
+   *
+   *                    P4 moves to the closest Mesh Point (and/or the given X Y), raises the nozzle above the mesh height
+   *                    by the given 'H' offset (or default Z_CLEARANCE_BETWEEN_PROBES), and waits while the controller is
+   *                    used to adjust the nozzle height. On click the displayed height is saved in the mesh.
+   *
+   *                    Start Phase 4 at a specific location with X and Y. Adjust a specific number of Mesh Points with
+   *                    the 'R' (Repeat) parameter. (If 'R' is left out, the whole matrix is assumed.) This command can be
+   *                    terminated early (e.g., after editing the area of interest) by pressing and holding the encoder button.
+   *
+   *                    The general form is G29 P4 [R points] [X position] [Y position]
+   *
+   *                    The H [offset] parameter is useful if a shim is used to fine-tune the mesh. For a 0.4mm shim the
+   *                    command would be G29 P4 H0.4. The nozzle is moved to the shim height, you adjust height to the shim,
+   *                    and on click the height minus the shim thickness will be saved in the mesh.
+   *
+   *                    !!Use with caution, as a very poor mesh could cause the nozzle to crash into the bed!!
+   *
+   *                    NOTE:  P4 is not available unless you have LCD support enabled!
+   *
+   *   P5    Phase 5    Find Mean Mesh Height and Standard Deviation. Typically, it is easier to use and
+   *                    work with the Mesh if it is Mean Adjusted. You can specify a C parameter to
+   *                    Correct the Mesh to a 0.00 Mean Height. Adding a C parameter will automatically
+   *                    execute a G29 P6 C <mean height>.
+   *
+   *   P6    Phase 6    Shift Mesh height. The entire Mesh's height is adjusted by the height specified
+   *                    with the C parameter. Being able to adjust the height of a Mesh is useful tool. It
+   *                    can be used to compensate for poorly calibrated Z-Probes and other errors. Ideally,
+   *                    you should have the Mesh adjusted for a Mean Height of 0.00 and the Z-Probe measuring
+   *                    0.000 at the Z Home location.
+   *
+   *   Q     Test       Load specified Test Pattern to assist in checking correct operation of system. This
+   *                    command is not anticipated to be of much value to the typical user. It is intended
+   *                    for developers to help them verify correct operation of the Unified Bed Leveling System.
+   *
+   *   R #   Repeat     Repeat this command the specified number of times. If no number is specified the
+   *                    command will be repeated GRID_MAX_POINTS_X * GRID_MAX_POINTS_Y times.
+   *
+   *   S     Store      Store the current Mesh in the Activated area of the EEPROM. It will also store the
+   *                    current state of the Unified Bed Leveling system in the EEPROM.
+   *
+   *   S #   Store      Store the current Mesh at the specified location in EEPROM. Activate this location
+   *                    for subsequent Load and Store operations. Valid storage slot numbers begin at 0 and
+   *                    extend to a limit related to the available EEPROM storage.
+   *
+   *   S -1  Store      Store the current Mesh as a print out that is suitable to be feed back into the system
+   *                    at a later date. The GCode output can be saved and later replayed by the host software
+   *                    to reconstruct the current mesh on another machine.
+   *
+   *   T     Topology   Display the Mesh Map Topology.
+   *                    'T' can be used alone (e.g., G29 T) or in combination with most of the other commands.
+   *                    This option works with all Phase commands (e.g., G29 P4 R 5 T X 50 Y100 C -.1 O)
+   *                    This parameter can also specify a Map Type. T0 (the default) is user-readable. T1 can
+   *                    is suitable to paste into a spreadsheet for a 3D graph of the mesh.
+   *
+   *   U     Unlevel    Perform a probe of the outer perimeter to assist in physically leveling unlevel beds.
+   *                    Only used for G29 P1 T U. This speeds up the probing of the edge of the bed. Useful
+   *                    when the entire bed doesn't need to be probed because it will be adjusted.
+   *
+   *   V #   Verbosity  Set the verbosity level (0-4) for extra details. (Default 0)
+   *
+   *   W     What?      Display valuable Unified Bed Leveling System data.
+   *
+   *   X #              X Location for this command
+   *
+   *   Y #              Y Location for this command
+   *
+   *
+   *   Release Notes:
+   *   You MUST do M502, M500 to initialize the storage. Failure to do this will cause all
+   *   kinds of problems. Enabling EEPROM Storage is highly recommended. With EEPROM Storage
+   *   of the mesh, you are limited to 3-Point and Grid Leveling. (G29 P0 T and G29 P0 G
+   *   respectively.)
+   *
+   *   When you do a G28 and then a G29 P1 to automatically build your first mesh, you are going to notice
+   *   the Unified Bed Leveling probes points further and further away from the starting location. (The
+   *   starting location defaults to the center of the bed.)   The original Grid and Mesh leveling used
+   *   a Zig Zag pattern. The new pattern is better, especially for people with Delta printers. This
+   *   allows you to get the center area of the Mesh populated (and edited) quicker. This allows you to
+   *   perform a small print and check out your settings quicker. You do not need to populate the
+   *   entire mesh to use it. (You don't want to spend a lot of time generating a mesh only to realize
+   *   you don't have the resolution or zprobe_zoffset set correctly. The Mesh generation
+   *   gathers points closest to where the nozzle is located unless you specify an (X,Y) coordinate pair.
+   *
+   *   The Unified Bed Leveling uses a lot of EEPROM storage to hold its data. And it takes some effort
+   *   to get this Mesh data correct for a user's printer. We do not want this data destroyed as
+   *   new versions of Marlin add or subtract to the items stored in EEPROM. So, for the benefit of
+   *   the users, we store the Mesh data at the end of the EEPROM and do not keep it contiguous with the
+   *   other data stored in the EEPROM. (For sure the developers are going to complain about this, but
+   *   this is going to be helpful to the users!)
+   *
+   *   The foundation of this Bed Leveling System is built on Epatel's Mesh Bed Leveling code. A big
+   *   'Thanks!' to him and the creators of 3-Point and Grid Based leveling. Combining their contributions
+   *   we now have the functionality and features of all three systems combined.
+   */
+
+  void unified_bed_leveling::G29() {
+
+    if (!settings.calc_num_meshes()) {
+      SERIAL_PROTOCOLLNPGM("?You need to enable your EEPROM and initialize it");
+      SERIAL_PROTOCOLLNPGM("with M502, M500, M501 in that order.\n");
+      return;
+    }
+
+    // Check for commands that require the printer to be homed
+    if (axis_unhomed_error()) {
+      const int8_t p_val = parser.intval('P', -1);
+      if (p_val == 1 || p_val == 2 || p_val == 4 || parser.seen('J'))
+        gcode.home_all_axes();
+    }
+
+    if (g29_parameter_parsing()) return; // abort if parsing the simple parameters causes a problem,
+
+    // Invalidate Mesh Points. This command is a little bit asymmetrical because
+    // it directly specifies the repetition count and does not use the 'R' parameter.
+    if (parser.seen('I')) {
+      uint8_t cnt = 0;
+      g29_repetition_cnt = parser.has_value() ? parser.value_int() : 1;
+      if (g29_repetition_cnt >= GRID_MAX_POINTS) {
+        set_all_mesh_points_to_value(NAN);
+      }
+      else {
+        while (g29_repetition_cnt--) {
+          if (cnt > 20) { cnt = 0; idle(); }
+          const mesh_index_pair location = find_closest_mesh_point_of_type(REAL, g29_x_pos, g29_y_pos, USE_NOZZLE_AS_REFERENCE, NULL, false);
+          if (location.x_index < 0) {
+            // No more REACHABLE mesh points to invalidate, so we ASSUME the user
+            // meant to invalidate the ENTIRE mesh, which cannot be done with
+            // find_closest_mesh_point loop which only returns REACHABLE points.
+            set_all_mesh_points_to_value(NAN);
+            SERIAL_PROTOCOLLNPGM("Entire Mesh invalidated.\n");
+            break;            // No more invalid Mesh Points to populate
+          }
+          z_values[location.x_index][location.y_index] = NAN;
+          cnt++;
+        }
+      }
+      SERIAL_PROTOCOLLNPGM("Locations invalidated.\n");
+    }
+
+    if (parser.seen('Q')) {
+      const int test_pattern = parser.has_value() ? parser.value_int() : -99;
+      if (!WITHIN(test_pattern, -1, 2)) {
+        SERIAL_PROTOCOLLNPGM("Invalid test_pattern value. (-1 to 2)\n");
+        return;
+      }
+      SERIAL_PROTOCOLLNPGM("Loading test_pattern values.\n");
+      switch (test_pattern) {
+        case -1:
+          g29_eeprom_dump();
+          break;
+        case 0:
+          for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++) {   // Create a bowl shape - similar to
+            for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++) { // a poorly calibrated Delta.
+              const float p1 = 0.5 * (GRID_MAX_POINTS_X) - x,
+                          p2 = 0.5 * (GRID_MAX_POINTS_Y) - y;
+              z_values[x][y] += 2.0 * HYPOT(p1, p2);
+            }
+          }
+          break;
+        case 1:
+          for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++) {  // Create a diagonal line several Mesh cells thick that is raised
+            z_values[x][x] += 9.999;
+            z_values[x][x + (x < GRID_MAX_POINTS_Y - 1) ? 1 : -1] += 9.999; // We want the altered line several mesh points thick
+          }
+          break;
+        case 2:
+          // Allow the user to specify the height because 10mm is a little extreme in some cases.
+          for (uint8_t x = (GRID_MAX_POINTS_X) / 3; x < 2 * (GRID_MAX_POINTS_X) / 3; x++)   // Create a rectangular raised area in
+            for (uint8_t y = (GRID_MAX_POINTS_Y) / 3; y < 2 * (GRID_MAX_POINTS_Y) / 3; y++) // the center of the bed
+              z_values[x][y] += parser.seen('C') ? g29_constant : 9.99;
+          break;
+      }
+    }
+
+    if (parser.seen('J')) {
+      if (g29_grid_size) {  // if not 0 it is a normal n x n grid being probed
+        save_ubl_active_state_and_disable();
+        tilt_mesh_based_on_probed_grid(parser.seen('T'));
+        restore_ubl_active_state_and_leave();
+      }
+      else { // grid_size == 0 : A 3-Point leveling has been requested
+        float z3, z2, z1 = probe_pt(LOGICAL_X_POSITION(UBL_PROBE_PT_1_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_1_Y), false, g29_verbose_level);
+        if (!isnan(z1)) {
+          z2 = probe_pt(LOGICAL_X_POSITION(UBL_PROBE_PT_2_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_2_Y), false, g29_verbose_level);
+          if (!isnan(z2))
+            z3 = probe_pt(LOGICAL_X_POSITION(UBL_PROBE_PT_3_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_3_Y), true, g29_verbose_level);
+        }
+
+        if (isnan(z1) || isnan(z2) || isnan(z3)) { // probe_pt will return NAN if unreachable
+          SERIAL_ERROR_START();
+          SERIAL_ERRORLNPGM("Attempt to probe off the bed.");
+          goto LEAVE;
+        }
+
+        // Adjust z1, z2, z3 by the Mesh Height at these points. Just because they're non-zero
+        // doesn't mean the Mesh is tilted! (Compensate each probe point by what the Mesh says
+        // its height is.)
+
+        save_ubl_active_state_and_disable();
+        z1 -= get_z_correction(LOGICAL_X_POSITION(UBL_PROBE_PT_1_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_1_Y)) /* + zprobe_zoffset */ ;
+        z2 -= get_z_correction(LOGICAL_X_POSITION(UBL_PROBE_PT_2_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_2_Y)) /* + zprobe_zoffset */ ;
+        z3 -= get_z_correction(LOGICAL_X_POSITION(UBL_PROBE_PT_3_X), LOGICAL_Y_POSITION(UBL_PROBE_PT_3_Y)) /* + zprobe_zoffset */ ;
+
+        do_blocking_move_to_xy(0.5 * (UBL_MESH_MAX_X - (UBL_MESH_MIN_X)), 0.5 * (UBL_MESH_MAX_Y - (UBL_MESH_MIN_Y)));
+        tilt_mesh_based_on_3pts(z1, z2, z3);
+        restore_ubl_active_state_and_leave();
+      }
+    }
+
+    if (parser.seen('P')) {
+      if (WITHIN(g29_phase_value, 0, 1) && state.storage_slot == -1) {
+        state.storage_slot = 0;
+        SERIAL_PROTOCOLLNPGM("Default storage slot 0 selected.");
+      }
+
+      switch (g29_phase_value) {
+        case 0:
+          //
+          // Zero Mesh Data
+          //
+          reset();
+          SERIAL_PROTOCOLLNPGM("Mesh zeroed.");
+          break;
+
+        case 1:
+          //
+          // Invalidate Entire Mesh and Automatically Probe Mesh in areas that can be reached by the probe
+          //
+          if (!parser.seen('C')) {
+            invalidate();
+            SERIAL_PROTOCOLLNPGM("Mesh invalidated. Probing mesh.");
+          }
+          if (g29_verbose_level > 1) {
+            SERIAL_PROTOCOLPAIR("Probing Mesh Points Closest to (", g29_x_pos);
+            SERIAL_PROTOCOLCHAR(',');
+            SERIAL_PROTOCOL(g29_y_pos);
+            SERIAL_PROTOCOLLNPGM(").\n");
+          }
+          probe_entire_mesh(g29_x_pos + X_PROBE_OFFSET_FROM_EXTRUDER, g29_y_pos + Y_PROBE_OFFSET_FROM_EXTRUDER,
+                            parser.seen('T'), parser.seen('E'), parser.seen('U'));
+          break;
+
+        case 2: {
+          #if ENABLED(NEWPANEL)
+            //
+            // Manually Probe Mesh in areas that can't be reached by the probe
+            //
+            SERIAL_PROTOCOLLNPGM("Manually probing unreachable mesh locations.");
+            do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
+            if (!g29_x_flag && !g29_y_flag) {
+              /**
+               * Use a good default location for the path.
+               * The flipped > and < operators in these comparisons is intentional.
+               * It should cause the probed points to follow a nice path on Cartesian printers.
+               * It may make sense to have Delta printers default to the center of the bed.
+               * Until that is decided, this can be forced with the X and Y parameters.
+               */
+              #if IS_KINEMATIC
+                g29_x_pos = X_HOME_POS;
+                g29_y_pos = Y_HOME_POS;
+              #else // cartesian
+                g29_x_pos = X_PROBE_OFFSET_FROM_EXTRUDER > 0 ? X_BED_SIZE : 0;
+                g29_y_pos = Y_PROBE_OFFSET_FROM_EXTRUDER < 0 ? Y_BED_SIZE : 0;
+              #endif
+            }
+
+            if (parser.seen('C')) {
+              g29_x_pos = current_position[X_AXIS];
+              g29_y_pos = current_position[Y_AXIS];
+            }
+
+            if (parser.seen('B')) {
+              g29_card_thickness = parser.has_value() ? parser.value_float() : measure_business_card_thickness(Z_CLEARANCE_BETWEEN_PROBES);
+              if (FABS(g29_card_thickness) > 1.5) {
+                SERIAL_PROTOCOLLNPGM("?Error in Business Card measurement.");
+                return;
+              }
+            }
+
+            if (!position_is_reachable_xy(g29_x_pos, g29_y_pos)) {
+              SERIAL_PROTOCOLLNPGM("XY outside printable radius.");
+              return;
+            }
+
+            const float height = parser.floatval('H', Z_CLEARANCE_BETWEEN_PROBES);
+            manually_probe_remaining_mesh(g29_x_pos, g29_y_pos, height, g29_card_thickness, parser.seen('T'));
+
+            SERIAL_PROTOCOLLNPGM("G29 P2 finished.");
+
+          #else
+
+            SERIAL_PROTOCOLLNPGM("?P2 is only available when an LCD is present.");
+            return;
+
+          #endif
+        } break;
+
+        case 3: {
+          /**
+           * Populate invalid mesh areas. Proceed with caution.
+           * Two choices are available:
+           *   - Specify a constant with the 'C' parameter.
+           *   - Allow 'G29 P3' to choose a 'reasonable' constant.
+           */
+
+          if (g29_c_flag) {
+            if (g29_repetition_cnt >= GRID_MAX_POINTS) {
+              set_all_mesh_points_to_value(g29_constant);
+            }
+            else {
+              while (g29_repetition_cnt--) {  // this only populates reachable mesh points near
+                const mesh_index_pair location = find_closest_mesh_point_of_type(INVALID, g29_x_pos, g29_y_pos, USE_NOZZLE_AS_REFERENCE, NULL, false);
+                if (location.x_index < 0) {
+                  // No more REACHABLE INVALID mesh points to populate, so we ASSUME
+                  // user meant to populate ALL INVALID mesh points to value
+                  for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
+                    for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
+                      if (isnan(z_values[x][y]))
+                        z_values[x][y] = g29_constant;
+                  break; // No more invalid Mesh Points to populate
+                }
+                z_values[location.x_index][location.y_index] = g29_constant;
+              }
+            }
+          }
+          else {
+            const float cvf = parser.value_float();
+            switch((int)truncf(cvf * 10.0) - 30) {   // 3.1 -> 1
+              #if ENABLED(UBL_G29_P31)
+                case 1: {
+
+                  // P3.1  use least squares fit to fill missing mesh values
+                  // P3.10 zero weighting for distance, all grid points equal, best fit tilted plane
+                  // P3.11 10X weighting for nearest grid points versus farthest grid points
+                  // P3.12 100X distance weighting
+                  // P3.13 1000X distance weighting, approaches simple average of nearest points
+
+                  const float weight_power  = (cvf - 3.10) * 100.0,  // 3.12345 -> 2.345
+                              weight_factor = weight_power ? POW(10.0, weight_power) : 0;
+                  smart_fill_wlsf(weight_factor);
+                }
+                break;
+              #endif
+              case 0:   // P3 or P3.0
+              default:  // and anything P3.x that's not P3.1
+                smart_fill_mesh();  // Do a 'Smart' fill using nearby known values
+                break;
+            }
+          }
+          break;
+        }
+
+        case 4: // Fine Tune (i.e., Edit) the Mesh
+          #if ENABLED(NEWPANEL)
+            fine_tune_mesh(g29_x_pos, g29_y_pos, parser.seen('T'));
+          #else
+            SERIAL_PROTOCOLLNPGM("?P4 is only available when an LCD is present.");
+            return;
+          #endif
+          break;
+
+        case 5: find_mean_mesh_height(); break;
+
+        case 6: shift_mesh_height(); break;
+      }
+    }
+
+    //
+    // Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
+    // good to have the extra information. Soon... we prune this to just a few items
+    //
+    if (parser.seen('W')) g29_what_command();
+
+    //
+    // When we are fully debugged, this may go away. But there are some valid
+    // use cases for the users. So we can wait and see what to do with it.
+    //
+
+    if (parser.seen('K')) // Kompare Current Mesh Data to Specified Stored Mesh
+      g29_compare_current_mesh_to_stored_mesh();
+
+    //
+    // Load a Mesh from the EEPROM
+    //
+
+    if (parser.seen('L')) {     // Load Current Mesh Data
+      g29_storage_slot = parser.has_value() ? parser.value_int() : state.storage_slot;
+
+      int16_t a = settings.calc_num_meshes();
+
+      if (!a) {
+        SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
+        return;
+      }
+
+      if (!WITHIN(g29_storage_slot, 0, a - 1)) {
+        SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
+        SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
+        return;
+      }
+
+      settings.load_mesh(g29_storage_slot);
+      state.storage_slot = g29_storage_slot;
+
+      SERIAL_PROTOCOLLNPGM("Done.");
+    }
+
+    //
+    // Store a Mesh in the EEPROM
+    //
+
+    if (parser.seen('S')) {     // Store (or Save) Current Mesh Data
+      g29_storage_slot = parser.has_value() ? parser.value_int() : state.storage_slot;
+
+      if (g29_storage_slot == -1) {                     // Special case, we are going to 'Export' the mesh to the
+        SERIAL_ECHOLNPGM("G29 I 999");              // host in a form it can be reconstructed on a different machine
+        for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
+          for (uint8_t y = 0;  y < GRID_MAX_POINTS_Y; y++)
+            if (!isnan(z_values[x][y])) {
+              SERIAL_ECHOPAIR("M421 I ", x);
+              SERIAL_ECHOPAIR(" J ", y);
+              SERIAL_ECHOPGM(" Z ");
+              SERIAL_ECHO_F(z_values[x][y], 6);
+              SERIAL_ECHOPAIR(" ; X ", LOGICAL_X_POSITION(mesh_index_to_xpos(x)));
+              SERIAL_ECHOPAIR(", Y ", LOGICAL_Y_POSITION(mesh_index_to_ypos(y)));
+              SERIAL_EOL();
+            }
+        return;
+      }
+
+      int16_t a = settings.calc_num_meshes();
+
+      if (!a) {
+        SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
+        goto LEAVE;
+      }
+
+      if (!WITHIN(g29_storage_slot, 0, a - 1)) {
+        SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
+        SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
+        goto LEAVE;
+      }
+
+      settings.store_mesh(g29_storage_slot);
+      state.storage_slot = g29_storage_slot;
+
+      SERIAL_PROTOCOLLNPGM("Done.");
+    }
+
+    if (parser.seen('T'))
+      display_map(parser.has_value() ? parser.value_int() : 0);
+
+    /**
+     * This code may not be needed...  Prepare for its removal...
+     *
+     */
+    #if 0
+    if (parser.seen('Z')) {
+      if (parser.has_value())
+        state.z_offset = parser.value_float();   // do the simple case. Just lock in the specified value
+      else {
+        save_ubl_active_state_and_disable();
+        //float measured_z = probe_pt(g29_x_pos + X_PROBE_OFFSET_FROM_EXTRUDER, g29_y_pos + Y_PROBE_OFFSET_FROM_EXTRUDER, ProbeDeployAndStow, g29_verbose_level);
+
+        has_control_of_lcd_panel = true;     // Grab the LCD Hardware
+        float measured_z = 1.5;
+        do_blocking_move_to_z(measured_z);  // Get close to the bed, but leave some space so we don't damage anything
+                                            // The user is not going to be locking in a new Z-Offset very often so
+                                            // it won't be that painful to spin the Encoder Wheel for 1.5mm
+        lcd_refresh();
+        lcd_z_offset_edit_setup(measured_z);
+
+        KEEPALIVE_STATE(PAUSED_FOR_USER);
+
+        do {
+          measured_z = lcd_z_offset_edit();
+          idle();
+          do_blocking_move_to_z(measured_z);
+        } while (!ubl_lcd_clicked());
+
+        has_control_of_lcd_panel = true;   // There is a race condition for the encoder click.
+                                               // It could get detected in lcd_mesh_edit (actually _lcd_mesh_fine_tune)
+                                               // or here. So, until we are done looking for a long encoder press,
+                                               // we need to take control of the panel
+
+        KEEPALIVE_STATE(IN_HANDLER);
+
+        lcd_return_to_status();
+
+        const millis_t nxt = millis() + 1500UL;
+        while (ubl_lcd_clicked()) { // debounce and watch for abort
+          idle();
+          if (ELAPSED(millis(), nxt)) {
+            SERIAL_PROTOCOLLNPGM("\nZ-Offset Adjustment Stopped.");
+            do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
+            LCD_MESSAGEPGM(MSG_UBL_Z_OFFSET_STOPPED);
+            restore_ubl_active_state_and_leave();
+            goto LEAVE;
+          }
+        }
+        has_control_of_lcd_panel = false;
+        safe_delay(20); // We don't want any switch noise.
+
+        state.z_offset = measured_z;
+
+        lcd_refresh();
+        restore_ubl_active_state_and_leave();
+      }
+    }
+    #endif
+
+    LEAVE:
+
+    #if ENABLED(NEWPANEL)
+      lcd_reset_alert_level();
+      LCD_MESSAGEPGM("");
+      lcd_quick_feedback();
+
+      has_control_of_lcd_panel = false;
+    #endif
+
+    return;
+  }
+
+  void unified_bed_leveling::find_mean_mesh_height() {
+    float sum = 0.0;
+    int n = 0;
+    for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
+      for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
+        if (!isnan(z_values[x][y])) {
+          sum += z_values[x][y];
+          n++;
+        }
+
+    const float mean = sum / n;
+
+    //
+    // Sum the squares of difference from mean
+    //
+    float sum_of_diff_squared = 0.0;
+    for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
+      for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
+        if (!isnan(z_values[x][y]))
+          sum_of_diff_squared += sq(z_values[x][y] - mean);
+
+    SERIAL_ECHOLNPAIR("# of samples: ", n);
+    SERIAL_ECHOPGM("Mean Mesh Height: ");
+    SERIAL_ECHO_F(mean, 6);
+    SERIAL_EOL();
+
+    const float sigma = SQRT(sum_of_diff_squared / (n + 1));
+    SERIAL_ECHOPGM("Standard Deviation: ");
+    SERIAL_ECHO_F(sigma, 6);
+    SERIAL_EOL();
+
+    if (g29_c_flag)
+      for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
+        for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
+          if (!isnan(z_values[x][y]))
+            z_values[x][y] -= mean + g29_constant;
+  }
+
+  void unified_bed_leveling::shift_mesh_height() {
+    for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
+      for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
+        if (!isnan(z_values[x][y]))
+          z_values[x][y] += g29_constant;
+  }
+
+  /**
+   * Probe all invalidated locations of the mesh that can be reached by the probe.
+   * This attempts to fill in locations closest to the nozzle's start location first.
+   */
+  void unified_bed_leveling::probe_entire_mesh(const float &lx, const float &ly, const bool do_ubl_mesh_map, const bool stow_probe, bool close_or_far) {
+    mesh_index_pair location;
+
+    has_control_of_lcd_panel = true;
+    save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
+    DEPLOY_PROBE();
+
+    uint16_t max_iterations = GRID_MAX_POINTS;
+
+    do {
+      #if ENABLED(NEWPANEL)
+        if (ubl_lcd_clicked()) {
+          SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.\n");
+          lcd_quick_feedback();
+          STOW_PROBE();
+          while (ubl_lcd_clicked()) idle();
+          has_control_of_lcd_panel = false;
+          restore_ubl_active_state_and_leave();
+          safe_delay(50);  // Debounce the Encoder wheel
+          return;
+        }
+      #endif
+
+      location = find_closest_mesh_point_of_type(INVALID, lx, ly, USE_PROBE_AS_REFERENCE, NULL, close_or_far);
+
+      if (location.x_index >= 0) {    // mesh point found and is reachable by probe
+        const float rawx = mesh_index_to_xpos(location.x_index),
+                    rawy = mesh_index_to_ypos(location.y_index);
+
+        const float measured_z = probe_pt(LOGICAL_X_POSITION(rawx), LOGICAL_Y_POSITION(rawy), stow_probe, g29_verbose_level); // TODO: Needs error handling
+        z_values[location.x_index][location.y_index] = measured_z;
+      }
+
+      if (do_ubl_mesh_map) display_map(g29_map_type);
+
+    } while (location.x_index >= 0 && --max_iterations);
+
+    STOW_PROBE();
+    restore_ubl_active_state_and_leave();
+
+    do_blocking_move_to_xy(
+      constrain(lx - (X_PROBE_OFFSET_FROM_EXTRUDER), UBL_MESH_MIN_X, UBL_MESH_MAX_X),
+      constrain(ly - (Y_PROBE_OFFSET_FROM_EXTRUDER), UBL_MESH_MIN_Y, UBL_MESH_MAX_Y)
+    );
+  }
+
+  void unified_bed_leveling::tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3) {
+    matrix_3x3 rotation;
+    vector_3 v1 = vector_3( (UBL_PROBE_PT_1_X - UBL_PROBE_PT_2_X),
+                            (UBL_PROBE_PT_1_Y - UBL_PROBE_PT_2_Y),
+                            (z1 - z2) ),
+
+             v2 = vector_3( (UBL_PROBE_PT_3_X - UBL_PROBE_PT_2_X),
+                            (UBL_PROBE_PT_3_Y - UBL_PROBE_PT_2_Y),
+                            (z3 - z2) ),
+
+             normal = vector_3::cross(v1, v2);
+
+    normal = normal.get_normal();
+
+    /**
+     * This vector is normal to the tilted plane.
+     * However, we don't know its direction. We need it to point up. So if
+     * Z is negative, we need to invert the sign of all components of the vector
+     */
+    if (normal.z < 0.0) {
+      normal.x = -normal.x;
+      normal.y = -normal.y;
+      normal.z = -normal.z;
+    }
+
+    rotation = matrix_3x3::create_look_at(vector_3(normal.x, normal.y, 1));
+
+    if (g29_verbose_level > 2) {
+      SERIAL_ECHOPGM("bed plane normal = [");
+      SERIAL_PROTOCOL_F(normal.x, 7);
+      SERIAL_PROTOCOLCHAR(',');
+      SERIAL_PROTOCOL_F(normal.y, 7);
+      SERIAL_PROTOCOLCHAR(',');
+      SERIAL_PROTOCOL_F(normal.z, 7);
+      SERIAL_ECHOLNPGM("]");
+      rotation.debug(PSTR("rotation matrix:"));
+    }
+
+    //
+    // All of 3 of these points should give us the same d constant
+    //
+
+    float t = normal.x * (UBL_PROBE_PT_1_X) + normal.y * (UBL_PROBE_PT_1_Y),
+          d = t + normal.z * z1;
+
+    if (g29_verbose_level>2) {
+      SERIAL_ECHOPGM("D constant: ");
+      SERIAL_PROTOCOL_F(d, 7);
+      SERIAL_ECHOLNPGM(" ");
+    }
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPGM("d from 1st point: ");
+        SERIAL_ECHO_F(d, 6);
+        SERIAL_EOL();
+        t = normal.x * (UBL_PROBE_PT_2_X) + normal.y * (UBL_PROBE_PT_2_Y);
+        d = t + normal.z * z2;
+        SERIAL_ECHOPGM("d from 2nd point: ");
+        SERIAL_ECHO_F(d, 6);
+        SERIAL_EOL();
+        t = normal.x * (UBL_PROBE_PT_3_X) + normal.y * (UBL_PROBE_PT_3_Y);
+        d = t + normal.z * z3;
+        SERIAL_ECHOPGM("d from 3rd point: ");
+        SERIAL_ECHO_F(d, 6);
+        SERIAL_EOL();
+      }
+    #endif
+
+    for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
+      for (uint8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
+        float x_tmp = mesh_index_to_xpos(i),
+              y_tmp = mesh_index_to_ypos(j),
+              z_tmp = z_values[i][j];
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_ECHOPGM("before rotation = [");
+            SERIAL_PROTOCOL_F(x_tmp, 7);
+            SERIAL_PROTOCOLCHAR(',');
+            SERIAL_PROTOCOL_F(y_tmp, 7);
+            SERIAL_PROTOCOLCHAR(',');
+            SERIAL_PROTOCOL_F(z_tmp, 7);
+            SERIAL_ECHOPGM("]   ---> ");
+            safe_delay(20);
+          }
+        #endif
+        apply_rotation_xyz(rotation, x_tmp, y_tmp, z_tmp);
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_ECHOPGM("after rotation = [");
+            SERIAL_PROTOCOL_F(x_tmp, 7);
+            SERIAL_PROTOCOLCHAR(',');
+            SERIAL_PROTOCOL_F(y_tmp, 7);
+            SERIAL_PROTOCOLCHAR(',');
+            SERIAL_PROTOCOL_F(z_tmp, 7);
+            SERIAL_ECHOLNPGM("]");
+            safe_delay(55);
+          }
+        #endif
+        z_values[i][j] += z_tmp - d;
+      }
+    }
+  }
+
+  #if ENABLED(NEWPANEL)
+    float unified_bed_leveling::measure_point_with_encoder() {
+
+      while (ubl_lcd_clicked()) delay(50);  // wait for user to release encoder wheel
+      delay(50);  // debounce
+
+      KEEPALIVE_STATE(PAUSED_FOR_USER);
+      while (!ubl_lcd_clicked()) {     // we need the loop to move the nozzle based on the encoder wheel here!
+        idle();
+        if (encoder_diff) {
+          do_blocking_move_to_z(current_position[Z_AXIS] + 0.01 * float(encoder_diff));
+          encoder_diff = 0;
+        }
+      }
+      KEEPALIVE_STATE(IN_HANDLER);
+      return current_position[Z_AXIS];
+    }
+
+    static void echo_and_take_a_measurement() { SERIAL_PROTOCOLLNPGM(" and take a measurement."); }
+
+    float unified_bed_leveling::measure_business_card_thickness(float in_height) {
+      has_control_of_lcd_panel = true;
+      save_ubl_active_state_and_disable();   // Disable bed level correction for probing
+
+      do_blocking_move_to_z(in_height);
+      do_blocking_move_to_xy(0.5 * (UBL_MESH_MAX_X - (UBL_MESH_MIN_X)), 0.5 * (UBL_MESH_MAX_Y - (UBL_MESH_MIN_Y)));
+        //, min(planner.max_feedrate_mm_s[X_AXIS], planner.max_feedrate_mm_s[Y_AXIS]) / 2.0);
+      stepper.synchronize();
+
+      SERIAL_PROTOCOLPGM("Place shim under nozzle");
+      LCD_MESSAGEPGM(MSG_UBL_BC_INSERT);
+      lcd_return_to_status();
+      echo_and_take_a_measurement();
+
+      const float z1 = measure_point_with_encoder();
+      do_blocking_move_to_z(current_position[Z_AXIS] + SIZE_OF_LITTLE_RAISE);
+      stepper.synchronize();
+
+      SERIAL_PROTOCOLPGM("Remove shim");
+      LCD_MESSAGEPGM(MSG_UBL_BC_REMOVE);
+      echo_and_take_a_measurement();
+
+      const float z2 = measure_point_with_encoder();
+
+      do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES);
+
+      const float thickness = abs(z1 - z2);
+
+      if (g29_verbose_level > 1) {
+        SERIAL_PROTOCOLPGM("Business Card is ");
+        SERIAL_PROTOCOL_F(thickness, 4);
+        SERIAL_PROTOCOLLNPGM("mm thick.");
+      }
+
+      in_height = current_position[Z_AXIS]; // do manual probing at lower height
+
+      has_control_of_lcd_panel = false;
+
+      restore_ubl_active_state_and_leave();
+
+      return thickness;
+    }
+
+    void unified_bed_leveling::manually_probe_remaining_mesh(const float &lx, const float &ly, const float &z_clearance, const float &thick, const bool do_ubl_mesh_map) {
+
+      has_control_of_lcd_panel = true;
+
+      save_ubl_active_state_and_disable();   // we don't do bed level correction because we want the raw data when we probe
+      do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
+      do_blocking_move_to_xy(lx, ly);
+
+      lcd_return_to_status();
+
+      mesh_index_pair location;
+      do {
+        location = find_closest_mesh_point_of_type(INVALID, lx, ly, USE_NOZZLE_AS_REFERENCE, NULL, false);
+        // It doesn't matter if the probe can't reach the NAN location. This is a manual probe.
+        if (location.x_index < 0 && location.y_index < 0) continue;
+
+        const float rawx = mesh_index_to_xpos(location.x_index),
+                    rawy = mesh_index_to_ypos(location.y_index),
+                    xProbe = LOGICAL_X_POSITION(rawx),
+                    yProbe = LOGICAL_Y_POSITION(rawy);
+
+        if (!position_is_reachable_raw_xy(rawx, rawy)) break; // SHOULD NOT OCCUR (find_closest_mesh_point only returns reachable points)
+
+        do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
+
+        LCD_MESSAGEPGM(MSG_UBL_MOVING_TO_NEXT);
+
+        do_blocking_move_to_xy(xProbe, yProbe);
+        do_blocking_move_to_z(z_clearance);
+
+        KEEPALIVE_STATE(PAUSED_FOR_USER);
+        has_control_of_lcd_panel = true;
+
+        if (do_ubl_mesh_map) display_map(g29_map_type);  // show user where we're probing
+
+        serialprintPGM(parser.seen('B') ? PSTR(MSG_UBL_BC_INSERT) : PSTR(MSG_UBL_BC_INSERT2));
+
+        const float z_step = 0.01;                                        // existing behavior: 0.01mm per click, occasionally step
+        //const float z_step = 1.0 / planner.axis_steps_per_mm[Z_AXIS];   // approx one step each click
+
+        while (ubl_lcd_clicked()) delay(50);             // wait for user to release encoder wheel
+        delay(50);                                       // debounce
+        while (!ubl_lcd_clicked()) {                     // we need the loop to move the nozzle based on the encoder wheel here!
+          idle();
+          if (encoder_diff) {
+            do_blocking_move_to_z(current_position[Z_AXIS] + float(encoder_diff) * z_step);
+            encoder_diff = 0;
+          }
+        }
+
+        // this sequence to detect an ubl_lcd_clicked() debounce it and leave if it is
+        // a Press and Hold is repeated in a lot of places (including G26_Mesh_Validation.cpp).   This
+        // should be redone and compressed.
+        const millis_t nxt = millis() + 1500L;
+        while (ubl_lcd_clicked()) {     // debounce and watch for abort
+          idle();
+          if (ELAPSED(millis(), nxt)) {
+            SERIAL_PROTOCOLLNPGM("\nMesh only partially populated.");
+            do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
+
+            #if ENABLED(NEWPANEL)
+              lcd_quick_feedback();
+              while (ubl_lcd_clicked()) idle();
+              has_control_of_lcd_panel = false;
+            #endif
+
+            KEEPALIVE_STATE(IN_HANDLER);
+            restore_ubl_active_state_and_leave();
+            return;
+          }
+        }
+
+        z_values[location.x_index][location.y_index] = current_position[Z_AXIS] - thick;
+        if (g29_verbose_level > 2) {
+          SERIAL_PROTOCOLPGM("Mesh Point Measured at: ");
+          SERIAL_PROTOCOL_F(z_values[location.x_index][location.y_index], 6);
+          SERIAL_EOL();
+        }
+      } while (location.x_index >= 0 && location.y_index >= 0);
+
+      if (do_ubl_mesh_map) display_map(g29_map_type);
+
+      restore_ubl_active_state_and_leave();
+      KEEPALIVE_STATE(IN_HANDLER);
+      do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);
+      do_blocking_move_to_xy(lx, ly);
+    }
+  #endif
+
+  bool unified_bed_leveling::g29_parameter_parsing() {
+    bool err_flag = false;
+
+    #if ENABLED(NEWPANEL)
+      LCD_MESSAGEPGM(MSG_UBL_DOING_G29);
+      lcd_quick_feedback();
+    #endif
+
+    g29_constant = 0.0;
+    g29_repetition_cnt = 0;
+
+    g29_x_flag = parser.seenval('X');
+    g29_x_pos = g29_x_flag ? parser.value_float() : current_position[X_AXIS];
+    g29_y_flag = parser.seenval('Y');
+    g29_y_pos = g29_y_flag ? parser.value_float() : current_position[Y_AXIS];
+
+    if (parser.seen('R')) {
+      g29_repetition_cnt = parser.has_value() ? parser.value_int() : GRID_MAX_POINTS;
+      NOMORE(g29_repetition_cnt, GRID_MAX_POINTS);
+      if (g29_repetition_cnt < 1) {
+        SERIAL_PROTOCOLLNPGM("?(R)epetition count invalid (1+).\n");
+        return UBL_ERR;
+      }
+    }
+
+    g29_verbose_level = parser.seen('V') ? parser.value_int() : 0;
+    if (!WITHIN(g29_verbose_level, 0, 4)) {
+      SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).\n");
+      err_flag = true;
+    }
+
+    if (parser.seen('P')) {
+      g29_phase_value = parser.value_int();
+      if (!WITHIN(g29_phase_value, 0, 6)) {
+        SERIAL_PROTOCOLLNPGM("?(P)hase value invalid (0-6).\n");
+        err_flag = true;
+      }
+    }
+
+    if (parser.seen('J')) {
+      g29_grid_size = parser.has_value() ? parser.value_int() : 0;
+      if (g29_grid_size && !WITHIN(g29_grid_size, 2, 9)) {
+        SERIAL_PROTOCOLLNPGM("?Invalid grid size (J) specified (2-9).\n");
+        err_flag = true;
+      }
+    }
+
+    if (g29_x_flag != g29_y_flag) {
+      SERIAL_PROTOCOLLNPGM("Both X & Y locations must be specified.\n");
+      err_flag = true;
+    }
+
+    // If X or Y are not valid, use center of the bed values
+    if (!WITHIN(RAW_X_POSITION(g29_x_pos), X_MIN_BED, X_MAX_BED)) g29_x_pos = LOGICAL_X_POSITION(X_CENTER);
+    if (!WITHIN(RAW_Y_POSITION(g29_y_pos), Y_MIN_BED, Y_MAX_BED)) g29_y_pos = LOGICAL_Y_POSITION(Y_CENTER);
+
+    if (err_flag) return UBL_ERR;
+
+    /**
+     * Activate or deactivate UBL
+     * Note: UBL's G29 restores the state set here when done.
+     *       Leveling is being enabled here with old data, possibly
+     *       none. Error handling should disable for safety...
+     */
+    if (parser.seen('A')) {
+      if (parser.seen('D')) {
+        SERIAL_PROTOCOLLNPGM("?Can't activate and deactivate at the same time.\n");
+        return UBL_ERR;
+      }
+      set_bed_leveling_enabled(true);
+      report_state();
+    }
+    else if (parser.seen('D')) {
+      set_bed_leveling_enabled(false);
+      report_state();
+    }
+
+    // Set global 'C' flag and its value
+    if ((g29_c_flag = parser.seen('C')))
+      g29_constant = parser.value_float();
+
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      if (parser.seenval('F')) {
+        const float fh = parser.value_float();
+        if (!WITHIN(fh, 0.0, 100.0)) {
+          SERIAL_PROTOCOLLNPGM("?(F)ade height for Bed Level Correction not plausible.\n");
+          return UBL_ERR;
+        }
+        set_z_fade_height(fh);
+      }
+    #endif
+
+    g29_map_type = parser.intval('T');
+    if (!WITHIN(g29_map_type, 0, 2)) {
+      SERIAL_PROTOCOLLNPGM("Invalid map type.\n");
+      return UBL_ERR;
+    }
+    return UBL_OK;
+  }
+
+  static int ubl_state_at_invocation = 0,
+             ubl_state_recursion_chk = 0;
+
+  void unified_bed_leveling::save_ubl_active_state_and_disable() {
+    ubl_state_recursion_chk++;
+    if (ubl_state_recursion_chk != 1) {
+      SERIAL_ECHOLNPGM("save_ubl_active_state_and_disabled() called multiple times in a row.");
+
+      #if ENABLED(NEWPANEL)
+        LCD_MESSAGEPGM(MSG_UBL_SAVE_ERROR);
+        lcd_quick_feedback();
+      #endif
+
+      return;
+    }
+    ubl_state_at_invocation = state.active;
+    set_bed_leveling_enabled(false);
+  }
+
+  void unified_bed_leveling::restore_ubl_active_state_and_leave() {
+    if (--ubl_state_recursion_chk) {
+      SERIAL_ECHOLNPGM("restore_ubl_active_state_and_leave() called too many times.");
+
+      #if ENABLED(NEWPANEL)
+        LCD_MESSAGEPGM(MSG_UBL_RESTORE_ERROR);
+        lcd_quick_feedback();
+      #endif
+
+      return;
+    }
+    set_bed_leveling_enabled(ubl_state_at_invocation);
+  }
+
+  /**
+   * Much of the 'What?' command can be eliminated. But until we are fully debugged, it is
+   * good to have the extra information. Soon... we prune this to just a few items
+   */
+  void unified_bed_leveling::g29_what_command() {
+    report_state();
+
+    if (state.storage_slot == -1)
+      SERIAL_PROTOCOLPGM("No Mesh Loaded.");
+    else {
+      SERIAL_PROTOCOLPAIR("Mesh ", state.storage_slot);
+      SERIAL_PROTOCOLPGM(" Loaded.");
+    }
+    SERIAL_EOL();
+    safe_delay(50);
+
+    SERIAL_PROTOCOLLNPAIR("UBL object count: ", (int)ubl_cnt);
+
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      SERIAL_PROTOCOL("planner.z_fade_height : ");
+      SERIAL_PROTOCOL_F(planner.z_fade_height, 4);
+      SERIAL_EOL();
+    #endif
+
+    #if HAS_BED_PROBE
+      SERIAL_PROTOCOLPGM("zprobe_zoffset: ");
+      SERIAL_PROTOCOL_F(zprobe_zoffset, 7);
+      SERIAL_EOL();
+    #endif
+
+    SERIAL_ECHOLNPAIR("UBL_MESH_MIN_X  " STRINGIFY(UBL_MESH_MIN_X) "=", UBL_MESH_MIN_X);
+    SERIAL_ECHOLNPAIR("UBL_MESH_MIN_Y  " STRINGIFY(UBL_MESH_MIN_Y) "=", UBL_MESH_MIN_Y);
+    safe_delay(25);
+    SERIAL_ECHOLNPAIR("UBL_MESH_MAX_X  " STRINGIFY(UBL_MESH_MAX_X) "=", UBL_MESH_MAX_X);
+    SERIAL_ECHOLNPAIR("UBL_MESH_MAX_Y  " STRINGIFY(UBL_MESH_MAX_Y) "=", UBL_MESH_MAX_Y);
+    safe_delay(25);
+    SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_X  ", GRID_MAX_POINTS_X);
+    SERIAL_ECHOLNPAIR("GRID_MAX_POINTS_Y  ", GRID_MAX_POINTS_Y);
+    safe_delay(25);
+    SERIAL_ECHOLNPAIR("MESH_X_DIST  ", MESH_X_DIST);
+    SERIAL_ECHOLNPAIR("MESH_Y_DIST  ", MESH_Y_DIST);
+    safe_delay(25);
+
+    SERIAL_PROTOCOLPGM("X-Axis Mesh Points at: ");
+    for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
+      SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(mesh_index_to_xpos(i)), 3);
+      SERIAL_PROTOCOLPGM("  ");
+      safe_delay(25);
+    }
+    SERIAL_EOL();
+
+    SERIAL_PROTOCOLPGM("Y-Axis Mesh Points at: ");
+    for (uint8_t i = 0; i < GRID_MAX_POINTS_Y; i++) {
+      SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(mesh_index_to_ypos(i)), 3);
+      SERIAL_PROTOCOLPGM("  ");
+      safe_delay(25);
+    }
+    SERIAL_EOL();
+
+    #if HAS_KILL
+      SERIAL_PROTOCOLPAIR("Kill pin on :", KILL_PIN);
+      SERIAL_PROTOCOLLNPAIR("  state:", READ(KILL_PIN));
+    #endif
+    SERIAL_EOL();
+    safe_delay(50);
+
+    SERIAL_PROTOCOLLNPAIR("ubl_state_at_invocation :", ubl_state_at_invocation);
+    SERIAL_EOL();
+    SERIAL_PROTOCOLLNPAIR("ubl_state_recursion_chk :", ubl_state_recursion_chk);
+    SERIAL_EOL();
+    safe_delay(50);
+
+    SERIAL_PROTOCOLPAIR("Meshes go from ", hex_address((void*)settings.get_start_of_meshes()));
+    SERIAL_PROTOCOLLNPAIR(" to ", hex_address((void*)settings.get_end_of_meshes()));
+    safe_delay(50);
+
+    SERIAL_PROTOCOLLNPAIR("sizeof(ubl) :  ", (int)sizeof(ubl));
+    SERIAL_EOL();
+    SERIAL_PROTOCOLLNPAIR("z_value[][] size: ", (int)sizeof(z_values));
+    SERIAL_EOL();
+    safe_delay(25);
+
+    SERIAL_PROTOCOLLNPAIR("EEPROM free for UBL: ", hex_address((void*)(settings.get_end_of_meshes() - settings.get_start_of_meshes())));
+    safe_delay(50);
+
+    SERIAL_PROTOCOLPAIR("EEPROM can hold ", settings.calc_num_meshes());
+    SERIAL_PROTOCOLLNPGM(" meshes.\n");
+    safe_delay(25);
+
+    if (!sanity_check()) {
+      echo_name();
+      SERIAL_PROTOCOLLNPGM(" sanity checks passed.");
+    }
+  }
+
+  /**
+   * When we are fully debugged, the EEPROM dump command will get deleted also. But
+   * right now, it is good to have the extra information. Soon... we prune this.
+   */
+  void unified_bed_leveling::g29_eeprom_dump() {
+    unsigned char cccc;
+    uint16_t kkkk;
+
+    SERIAL_ECHO_START();
+    SERIAL_ECHOLNPGM("EEPROM Dump:");
+    for (uint16_t i = 0; i < E2END + 1; i += 16) {
+      if (!(i & 0x3)) idle();
+      print_hex_word(i);
+      SERIAL_ECHOPGM(": ");
+      for (uint16_t j = 0; j < 16; j++) {
+        kkkk = i + j;
+        eeprom_read_block(&cccc, (void *)kkkk, 1);
+        print_hex_byte(cccc);
+        SERIAL_ECHO(' ');
+      }
+      SERIAL_EOL();
+    }
+    SERIAL_EOL();
+  }
+
+  /**
+   * When we are fully debugged, this may go away. But there are some valid
+   * use cases for the users. So we can wait and see what to do with it.
+   */
+  void unified_bed_leveling::g29_compare_current_mesh_to_stored_mesh() {
+    int16_t a = settings.calc_num_meshes();
+
+    if (!a) {
+      SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
+      return;
+    }
+
+    if (!parser.has_value()) {
+      SERIAL_PROTOCOLLNPGM("?Storage slot # required.");
+      SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
+      return;
+    }
+
+    g29_storage_slot = parser.value_int();
+
+    if (!WITHIN(g29_storage_slot, 0, a - 1)) {
+      SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
+      SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
+      return;
+    }
+
+    float tmp_z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
+    settings.load_mesh(g29_storage_slot, &tmp_z_values);
+
+    SERIAL_PROTOCOLPAIR("Subtracting mesh in slot ", g29_storage_slot);
+    SERIAL_PROTOCOLLNPGM(" from current mesh.");
+
+    for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
+      for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
+        z_values[x][y] -= tmp_z_values[x][y];
+  }
+
+  mesh_index_pair unified_bed_leveling::find_closest_mesh_point_of_type(const MeshPointType type, const float &lx, const float &ly, const bool probe_as_reference, uint16_t bits[16], const bool far_flag) {
+    mesh_index_pair out_mesh;
+    out_mesh.x_index = out_mesh.y_index = -1;
+
+    // Get our reference position. Either the nozzle or probe location.
+    const float px = RAW_X_POSITION(lx) - (probe_as_reference == USE_PROBE_AS_REFERENCE ? X_PROBE_OFFSET_FROM_EXTRUDER : 0),
+                py = RAW_Y_POSITION(ly) - (probe_as_reference == USE_PROBE_AS_REFERENCE ? Y_PROBE_OFFSET_FROM_EXTRUDER : 0);
+
+    float best_so_far = far_flag ? -99999.99 : 99999.99;
+
+    for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
+      for (uint8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
+
+        if ( (type == INVALID && isnan(z_values[i][j]))  // Check to see if this location holds the right thing
+          || (type == REAL && !isnan(z_values[i][j]))
+          || (type == SET_IN_BITMAP && is_bit_set(bits, i, j))
+        ) {
+          // We only get here if we found a Mesh Point of the specified type
+
+          float raw_x = RAW_CURRENT_POSITION(X), raw_y = RAW_CURRENT_POSITION(Y);
+          const float mx = mesh_index_to_xpos(i),
+                      my = mesh_index_to_ypos(j);
+
+          // If using the probe as the reference there are some unreachable locations.
+          // Also for round beds, there are grid points outside the bed the nozzle can't reach.
+          // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
+
+          if (probe_as_reference ? !position_is_reachable_by_probe_raw_xy(mx, my) : !position_is_reachable_raw_xy(mx, my))
+            continue;
+
+          // Reachable. Check if it's the best_so_far location to the nozzle.
+          // Add in a weighting factor that considers the current location of the nozzle.
+
+          float distance = HYPOT(px - mx, py - my);
+
+          /**
+           * If doing the far_flag action, we want to be as far as possible
+           * from the starting point and from any other probed points. We
+           * want the next point spread out and filling in any blank spaces
+           * in the mesh. So we add in some of the distance to every probed
+           * point we can find.
+           */
+          if (far_flag) {
+            for (uint8_t k = 0; k < GRID_MAX_POINTS_X; k++) {
+              for (uint8_t l = 0; l < GRID_MAX_POINTS_Y; l++) {
+                if (i != k && j != l && !isnan(z_values[k][l])) {
+                  //distance += pow((float) abs(i - k) * (MESH_X_DIST), 2) + pow((float) abs(j - l) * (MESH_Y_DIST), 2);  // working here
+                  distance += HYPOT(MESH_X_DIST, MESH_Y_DIST) / log(HYPOT((i - k) * (MESH_X_DIST) + .001, (j - l) * (MESH_Y_DIST)) + .001);
+                }
+              }
+            }
+          }
+          else
+          // factor in the distance from the current location for the normal case
+          // so the nozzle isn't running all over the bed.
+            distance += HYPOT(raw_x - mx, raw_y - my) * 0.1;
+
+          // if far_flag, look for farthest point
+          if (far_flag == (distance > best_so_far) && distance != best_so_far) {
+            best_so_far = distance;   // We found a closer/farther location with
+            out_mesh.x_index = i;     // the specified type of mesh value.
+            out_mesh.y_index = j;
+            out_mesh.distance = best_so_far;
+          }
+        }
+      } // for j
+    } // for i
+
+    return out_mesh;
+  }
+
+  #if ENABLED(NEWPANEL)
+
+    void unified_bed_leveling::fine_tune_mesh(const float &lx, const float &ly, const bool do_ubl_mesh_map) {
+      if (!parser.seen('R'))    // fine_tune_mesh() is special. If no repetition count flag is specified
+        g29_repetition_cnt = 1;   // do exactly one mesh location. Otherwise use what the parser decided.
+
+      #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
+        const bool is_offset = parser.seen('H');
+        const float h_offset = is_offset ? parser.value_linear_units() : Z_CLEARANCE_BETWEEN_PROBES;
+        if (is_offset && !WITHIN(h_offset, 0, 10)) {
+          SERIAL_PROTOCOLLNPGM("Offset out of bounds. (0 to 10mm)\n");
+          return;
+        }
+      #endif
+
+      mesh_index_pair location;
+
+      if (!position_is_reachable_xy(lx, ly)) {
+        SERIAL_PROTOCOLLNPGM("(X,Y) outside printable radius.");
+        return;
+      }
+
+      save_ubl_active_state_and_disable();
+
+      LCD_MESSAGEPGM(MSG_UBL_FINE_TUNE_MESH);
+
+      do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
+      do_blocking_move_to_xy(lx, ly);
+
+      uint16_t not_done[16];
+      memset(not_done, 0xFF, sizeof(not_done));
+      do {
+        location = find_closest_mesh_point_of_type(SET_IN_BITMAP, lx, ly, USE_NOZZLE_AS_REFERENCE, not_done, false);
+
+        if (location.x_index < 0) break; // stop when we can't find any more reachable points.
+
+        bit_clear(not_done, location.x_index, location.y_index);  // Mark this location as 'adjusted' so we will find a
+                                                                  // different location the next time through the loop
+
+        const float rawx = mesh_index_to_xpos(location.x_index),
+                    rawy = mesh_index_to_ypos(location.y_index);
+
+        if (!position_is_reachable_raw_xy(rawx, rawy)) // SHOULD NOT OCCUR because find_closest_mesh_point_of_type will only return reachable
+          break;
+
+        float new_z = z_values[location.x_index][location.y_index];
+
+        if (isnan(new_z)) // if the mesh point is invalid, set it to 0.0 so it can be edited
+          new_z = 0.0;
+
+        do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);    // Move the nozzle to where we are going to edit
+        do_blocking_move_to_xy(LOGICAL_X_POSITION(rawx), LOGICAL_Y_POSITION(rawy));
+
+        new_z = FLOOR(new_z * 1000.0) * 0.001; // Chop off digits after the 1000ths place
+
+        KEEPALIVE_STATE(PAUSED_FOR_USER);
+        has_control_of_lcd_panel = true;
+
+        if (do_ubl_mesh_map) display_map(g29_map_type);  // show the user which point is being adjusted
+
+        lcd_refresh();
+
+        lcd_mesh_edit_setup(new_z);
+
+        do {
+          new_z = lcd_mesh_edit();
+          #if ENABLED(UBL_MESH_EDIT_MOVES_Z)
+            do_blocking_move_to_z(h_offset + new_z); // Move the nozzle as the point is edited
+          #endif
+          idle();
+        } while (!ubl_lcd_clicked());
+
+        if (!lcd_map_control) lcd_return_to_status();
+
+        // The technique used here generates a race condition for the encoder click.
+        // It could get detected in lcd_mesh_edit (actually _lcd_mesh_fine_tune) or here.
+        // Let's work on specifying a proper API for the LCD ASAP, OK?
+        has_control_of_lcd_panel = true;
+
+        // this sequence to detect an ubl_lcd_clicked() debounce it and leave if it is
+        // a Press and Hold is repeated in a lot of places (including G26_Mesh_Validation.cpp).   This
+        // should be redone and compressed.
+        const millis_t nxt = millis() + 1500UL;
+        while (ubl_lcd_clicked()) { // debounce and watch for abort
+          idle();
+          if (ELAPSED(millis(), nxt)) {
+            lcd_return_to_status();
+            do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
+            LCD_MESSAGEPGM(MSG_EDITING_STOPPED);
+
+            while (ubl_lcd_clicked()) idle();
+
+            goto FINE_TUNE_EXIT;
+          }
+        }
+
+        safe_delay(20);                       // We don't want any switch noise.
+
+        z_values[location.x_index][location.y_index] = new_z;
+
+        lcd_refresh();
+
+      } while (location.x_index >= 0 && --g29_repetition_cnt > 0);
+
+      FINE_TUNE_EXIT:
+
+      has_control_of_lcd_panel = false;
+      KEEPALIVE_STATE(IN_HANDLER);
+
+      if (do_ubl_mesh_map) display_map(g29_map_type);
+      restore_ubl_active_state_and_leave();
+      do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
+
+      do_blocking_move_to_xy(lx, ly);
+
+      LCD_MESSAGEPGM(MSG_UBL_DONE_EDITING_MESH);
+      SERIAL_ECHOLNPGM("Done Editing Mesh");
+
+      if (lcd_map_control)
+        lcd_goto_screen(_lcd_ubl_output_map_lcd);
+      else
+        lcd_return_to_status();
+    }
+
+  #endif // NEWPANEL
+
+  /**
+   * 'Smart Fill': Scan from the outward edges of the mesh towards the center.
+   * If an invalid location is found, use the next two points (if valid) to
+   * calculate a 'reasonable' value for the unprobed mesh point.
+   */
+
+  bool unified_bed_leveling::smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
+    const int8_t x1 = x + xdir, x2 = x1 + xdir,
+                 y1 = y + ydir, y2 = y1 + ydir;
+    // A NAN next to a pair of real values?
+    if (isnan(z_values[x][y]) && !isnan(z_values[x1][y1]) && !isnan(z_values[x2][y2])) {
+      if (z_values[x1][y1] < z_values[x2][y2])                  // Angled downward?
+        z_values[x][y] = z_values[x1][y1];                      // Use nearest (maybe a little too high.)
+      else
+        z_values[x][y] = 2.0 * z_values[x1][y1] - z_values[x2][y2];   // Angled upward...
+      return true;
+    }
+    return false;
+  }
+
+  typedef struct { uint8_t sx, ex, sy, ey; bool yfirst; } smart_fill_info;
+
+  void unified_bed_leveling::smart_fill_mesh() {
+    static const smart_fill_info
+      info0 PROGMEM = { 0, GRID_MAX_POINTS_X,      0, GRID_MAX_POINTS_Y - 2,  false },  // Bottom of the mesh looking up
+      info1 PROGMEM = { 0, GRID_MAX_POINTS_X,      GRID_MAX_POINTS_Y - 1, 0,  false },  // Top of the mesh looking down
+      info2 PROGMEM = { 0, GRID_MAX_POINTS_X - 2,  0, GRID_MAX_POINTS_Y,      true  },  // Left side of the mesh looking right
+      info3 PROGMEM = { GRID_MAX_POINTS_X - 1, 0,  0, GRID_MAX_POINTS_Y,      true  };  // Right side of the mesh looking left
+    static const smart_fill_info * const info[] PROGMEM = { &info0, &info1, &info2, &info3 };
+
+    // static const smart_fill_info info[] PROGMEM = {
+    //   { 0, GRID_MAX_POINTS_X,      0, GRID_MAX_POINTS_Y - 2,  false } PROGMEM,  // Bottom of the mesh looking up
+    //   { 0, GRID_MAX_POINTS_X,      GRID_MAX_POINTS_Y - 1, 0,  false } PROGMEM,  // Top of the mesh looking down
+    //   { 0, GRID_MAX_POINTS_X - 2,  0, GRID_MAX_POINTS_Y,      true  } PROGMEM,  // Left side of the mesh looking right
+    //   { GRID_MAX_POINTS_X - 1, 0,  0, GRID_MAX_POINTS_Y,      true  } PROGMEM   // Right side of the mesh looking left
+    // };
+    for (uint8_t i = 0; i < COUNT(info); ++i) {
+      const smart_fill_info *f = (smart_fill_info*)pgm_read_ptr(&info[i]);
+      const int8_t sx = pgm_read_word(&f->sx), sy = pgm_read_word(&f->sy),
+                   ex = pgm_read_word(&f->ex), ey = pgm_read_word(&f->ey);
+      if (pgm_read_byte(&f->yfirst)) {
+        const int8_t dir = ex > sx ? 1 : -1;
+        for (uint8_t y = sy; y != ey; ++y)
+          for (uint8_t x = sx; x != ex; x += dir)
+            if (smart_fill_one(x, y, dir, 0)) break;
+      }
+      else {
+        const int8_t dir = ey > sy ? 1 : -1;
+         for (uint8_t x = sx; x != ex; ++x)
+          for (uint8_t y = sy; y != ey; y += dir)
+            if (smart_fill_one(x, y, 0, dir)) break;
+      }
+    }
+  }
+
+  void unified_bed_leveling::tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map) {
+    constexpr int16_t x_min = max(MIN_PROBE_X, UBL_MESH_MIN_X),
+                      x_max = min(MAX_PROBE_X, UBL_MESH_MAX_X),
+                      y_min = max(MIN_PROBE_Y, UBL_MESH_MIN_Y),
+                      y_max = min(MAX_PROBE_Y, UBL_MESH_MAX_Y);
+
+    const float dx = float(x_max - x_min) / (g29_grid_size - 1.0),
+                dy = float(y_max - y_min) / (g29_grid_size - 1.0);
+
+    struct linear_fit_data lsf_results;
+    incremental_LSF_reset(&lsf_results);
+
+    bool zig_zag = false;
+    for (uint8_t ix = 0; ix < g29_grid_size; ix++) {
+      const float x = float(x_min) + ix * dx;
+      for (int8_t iy = 0; iy < g29_grid_size; iy++) {
+        const float y = float(y_min) + dy * (zig_zag ? g29_grid_size - 1 - iy : iy);
+        float measured_z = probe_pt(LOGICAL_X_POSITION(x), LOGICAL_Y_POSITION(y), parser.seen('E'), g29_verbose_level); // TODO: Needs error handling
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_CHAR('(');
+            SERIAL_PROTOCOL_F(x, 7);
+            SERIAL_CHAR(',');
+            SERIAL_PROTOCOL_F(y, 7);
+            SERIAL_ECHOPGM(")   logical: ");
+            SERIAL_CHAR('(');
+            SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(x), 7);
+            SERIAL_CHAR(',');
+            SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(y), 7);
+            SERIAL_ECHOPGM(")   measured: ");
+            SERIAL_PROTOCOL_F(measured_z, 7);
+            SERIAL_ECHOPGM("   correction: ");
+            SERIAL_PROTOCOL_F(get_z_correction(LOGICAL_X_POSITION(x), LOGICAL_Y_POSITION(y)), 7);
+          }
+        #endif
+
+        measured_z -= get_z_correction(LOGICAL_X_POSITION(x), LOGICAL_Y_POSITION(y)) /* + zprobe_zoffset */ ;
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_ECHOPGM("   final >>>---> ");
+            SERIAL_PROTOCOL_F(measured_z, 7);
+            SERIAL_EOL();
+          }
+        #endif
+
+        incremental_LSF(&lsf_results, x, y, measured_z);
+      }
+
+      zig_zag ^= true;
+    }
+
+    if (finish_incremental_LSF(&lsf_results)) {
+      SERIAL_ECHOPGM("Could not complete LSF!");
+      return;
+    }
+
+    if (g29_verbose_level > 3) {
+      SERIAL_ECHOPGM("LSF Results A=");
+      SERIAL_PROTOCOL_F(lsf_results.A, 7);
+      SERIAL_ECHOPGM("  B=");
+      SERIAL_PROTOCOL_F(lsf_results.B, 7);
+      SERIAL_ECHOPGM("  D=");
+      SERIAL_PROTOCOL_F(lsf_results.D, 7);
+      SERIAL_EOL();
+    }
+
+    vector_3 normal = vector_3(lsf_results.A, lsf_results.B, 1.0000).get_normal();
+
+    if (g29_verbose_level > 2) {
+      SERIAL_ECHOPGM("bed plane normal = [");
+      SERIAL_PROTOCOL_F(normal.x, 7);
+      SERIAL_PROTOCOLCHAR(',');
+      SERIAL_PROTOCOL_F(normal.y, 7);
+      SERIAL_PROTOCOLCHAR(',');
+      SERIAL_PROTOCOL_F(normal.z, 7);
+      SERIAL_ECHOLNPGM("]");
+    }
+
+    matrix_3x3 rotation = matrix_3x3::create_look_at(vector_3(lsf_results.A, lsf_results.B, 1));
+
+    for (uint8_t i = 0; i < GRID_MAX_POINTS_X; i++) {
+      for (uint8_t j = 0; j < GRID_MAX_POINTS_Y; j++) {
+        float x_tmp = mesh_index_to_xpos(i),
+              y_tmp = mesh_index_to_ypos(j),
+              z_tmp = z_values[i][j];
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_ECHOPGM("before rotation = [");
+            SERIAL_PROTOCOL_F(x_tmp, 7);
+            SERIAL_PROTOCOLCHAR(',');
+            SERIAL_PROTOCOL_F(y_tmp, 7);
+            SERIAL_PROTOCOLCHAR(',');
+            SERIAL_PROTOCOL_F(z_tmp, 7);
+            SERIAL_ECHOPGM("]   ---> ");
+            safe_delay(20);
+          }
+        #endif
+
+        apply_rotation_xyz(rotation, x_tmp, y_tmp, z_tmp);
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_ECHOPGM("after rotation = [");
+            SERIAL_PROTOCOL_F(x_tmp, 7);
+            SERIAL_PROTOCOLCHAR(',');
+            SERIAL_PROTOCOL_F(y_tmp, 7);
+            SERIAL_PROTOCOLCHAR(',');
+            SERIAL_PROTOCOL_F(z_tmp, 7);
+            SERIAL_ECHOLNPGM("]");
+            safe_delay(55);
+          }
+        #endif
+
+        z_values[i][j] += z_tmp - lsf_results.D;
+      }
+    }
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        rotation.debug(PSTR("rotation matrix:"));
+        SERIAL_ECHOPGM("LSF Results A=");
+        SERIAL_PROTOCOL_F(lsf_results.A, 7);
+        SERIAL_ECHOPGM("  B=");
+        SERIAL_PROTOCOL_F(lsf_results.B, 7);
+        SERIAL_ECHOPGM("  D=");
+        SERIAL_PROTOCOL_F(lsf_results.D, 7);
+        SERIAL_EOL();
+        safe_delay(55);
+
+        SERIAL_ECHOPGM("bed plane normal = [");
+        SERIAL_PROTOCOL_F(normal.x, 7);
+        SERIAL_PROTOCOLCHAR(',');
+        SERIAL_PROTOCOL_F(normal.y, 7);
+        SERIAL_PROTOCOLCHAR(',');
+        SERIAL_PROTOCOL_F(normal.z, 7);
+        SERIAL_ECHOPGM("]\n");
+        SERIAL_EOL();
+      }
+    #endif
+
+    if (do_ubl_mesh_map) display_map(g29_map_type);
+  }
+
+  #if ENABLED(UBL_G29_P31)
+    void unified_bed_leveling::smart_fill_wlsf(const float &weight_factor) {
+
+      // For each undefined mesh point, compute a distance-weighted least squares fit
+      // from all the originally populated mesh points, weighted toward the point
+      // being extrapolated so that nearby points will have greater influence on
+      // the point being extrapolated.  Then extrapolate the mesh point from WLSF.
+
+      static_assert(GRID_MAX_POINTS_Y <= 16, "GRID_MAX_POINTS_Y too big");
+      uint16_t bitmap[GRID_MAX_POINTS_X] = { 0 };
+      struct linear_fit_data lsf_results;
+
+      SERIAL_ECHOPGM("Extrapolating mesh...");
+
+      const float weight_scaled = weight_factor * max(MESH_X_DIST, MESH_Y_DIST);
+
+      for (uint8_t jx = 0; jx < GRID_MAX_POINTS_X; jx++)
+        for (uint8_t jy = 0; jy < GRID_MAX_POINTS_Y; jy++)
+          if (!isnan(z_values[jx][jy]))
+            SBI(bitmap[jx], jy);
+
+      for (uint8_t ix = 0; ix < GRID_MAX_POINTS_X; ix++) {
+        const float px = mesh_index_to_xpos(ix);
+        for (uint8_t iy = 0; iy < GRID_MAX_POINTS_Y; iy++) {
+          const float py = mesh_index_to_ypos(iy);
+          if (isnan(z_values[ix][iy])) {
+            // undefined mesh point at (px,py), compute weighted LSF from original valid mesh points.
+            incremental_LSF_reset(&lsf_results);
+            for (uint8_t jx = 0; jx < GRID_MAX_POINTS_X; jx++) {
+              const float rx = mesh_index_to_xpos(jx);
+              for (uint8_t jy = 0; jy < GRID_MAX_POINTS_Y; jy++) {
+                if (TEST(bitmap[jx], jy)) {
+                  const float ry = mesh_index_to_ypos(jy),
+                              rz = z_values[jx][jy],
+                              w  = 1.0 + weight_scaled / HYPOT((rx - px), (ry - py));
+                  incremental_WLSF(&lsf_results, rx, ry, rz, w);
+                }
+              }
+            }
+            if (finish_incremental_LSF(&lsf_results)) {
+              SERIAL_ECHOLNPGM("Insufficient data");
+              return;
+            }
+            const float ez = -lsf_results.D - lsf_results.A * px - lsf_results.B * py;
+            z_values[ix][iy] = ez;
+            idle();   // housekeeping
+          }
+        }
+      }
+
+      SERIAL_ECHOLNPGM("done");
+    }
+  #endif // UBL_G29_P31
+
+#endif // AUTO_BED_LEVELING_UBL
