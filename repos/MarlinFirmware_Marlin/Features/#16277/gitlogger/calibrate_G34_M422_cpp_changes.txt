commit 9343247e075fbc11e0ea83670f92543e2b1245f2
Author: sargonphin <85966195+sargonphin@users.noreply.github.com>
Date:   Sun Apr 7 17:48:13 2024 +0200

    ü©πIncrease range of G34 accuracy target  (#26771)
    
    * Allow G34 accuracy down to 0.001mm, previous minimum was 0.01mm.

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 8b94dd5392..7a27a61b9d 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -115,8 +115,8 @@ void GcodeSuite::G34() {
       }
 
       const float z_auto_align_accuracy = parser.floatval('T', Z_STEPPER_ALIGN_ACC);
-      if (!WITHIN(z_auto_align_accuracy, 0.01f, 1.0f)) {
-        SERIAL_ECHOLNPGM(GCODE_ERR_MSG("(T)arget accuracy out of bounds (0.01-1.0)."));
+      if (!WITHIN(z_auto_align_accuracy, 0.001f, 1.0f)) {
+        SERIAL_ECHOLNPGM(GCODE_ERR_MSG("(T)arget accuracy out of bounds (0.001-1.0)."));
         break;
       }
 

commit 669814d0d408a622f020a55971ba04030e4fa4bf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 7 23:40:54 2024 -0600

    ‚ú® MARLIN_SMALL_BUILD option (#26775)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index bbc403904f..8b94dd5392 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -110,19 +110,19 @@ void GcodeSuite::G34() {
 
       const int8_t z_auto_align_iterations = parser.intval('I', Z_STEPPER_ALIGN_ITERATIONS);
       if (!WITHIN(z_auto_align_iterations, 1, 30)) {
-        SERIAL_ECHOLNPGM("?(I)teration out of bounds (1-30).");
+        SERIAL_ECHOLNPGM(GCODE_ERR_MSG("(I)teration out of bounds (1-30)."));
         break;
       }
 
       const float z_auto_align_accuracy = parser.floatval('T', Z_STEPPER_ALIGN_ACC);
       if (!WITHIN(z_auto_align_accuracy, 0.01f, 1.0f)) {
-        SERIAL_ECHOLNPGM("?(T)arget accuracy out of bounds (0.01-1.0).");
+        SERIAL_ECHOLNPGM(GCODE_ERR_MSG("(T)arget accuracy out of bounds (0.01-1.0)."));
         break;
       }
 
       const float z_auto_align_amplification = TERN(HAS_Z_STEPPER_ALIGN_STEPPER_XY, Z_STEPPER_ALIGN_AMP, parser.floatval('A', Z_STEPPER_ALIGN_AMP));
       if (!WITHIN(ABS(z_auto_align_amplification), 0.5f, 2.0f)) {
-        SERIAL_ECHOLNPGM("?(A)mplification out of bounds (0.5-2.0).");
+        SERIAL_ECHOLNPGM(GCODE_ERR_MSG("(A)mplification out of bounds (0.5-2.0)."));
         break;
       }
 
@@ -450,7 +450,7 @@ void GcodeSuite::M422() {
   const bool is_probe_point = parser.seen_test('S');
 
   if (TERN0(HAS_Z_STEPPER_ALIGN_STEPPER_XY, is_probe_point && parser.seen_test('W'))) {
-    SERIAL_ECHOLNPGM("?(S) and (W) may not be combined.");
+    SERIAL_ECHOLNPGM(GCODE_ERR_MSG("(S) and (W) may not be combined."));
     return;
   }
 
@@ -460,7 +460,7 @@ void GcodeSuite::M422() {
   );
 
   if (!is_probe_point && TERN1(HAS_Z_STEPPER_ALIGN_STEPPER_XY, !parser.seen_test('W'))) {
-    SERIAL_ECHOLNPGM("?(S)" TERN_(HAS_Z_STEPPER_ALIGN_STEPPER_XY, " or (W)") " is required.");
+    SERIAL_ECHOLNPGM(GCODE_ERR_MSG("(S)" TERN_(HAS_Z_STEPPER_ALIGN_STEPPER_XY, " or (W)") " is required."));
     return;
   }
 
@@ -490,11 +490,11 @@ void GcodeSuite::M422() {
 
   if (is_probe_point) {
     if (!probe.can_reach(pos.x, Y_CENTER)) {
-      SERIAL_ECHOLNPGM("?(X) out of bounds.");
+      SERIAL_ECHOLNPGM(GCODE_ERR_MSG("(X) out of bounds."));
       return;
     }
     if (!probe.can_reach(pos)) {
-      SERIAL_ECHOLNPGM("?(Y) out of bounds.");
+      SERIAL_ECHOLNPGM(GCODE_ERR_MSG("(Y) out of bounds."));
       return;
     }
   }
@@ -503,6 +503,8 @@ void GcodeSuite::M422() {
 }
 
 void GcodeSuite::M422_report(const bool forReplay/*=true*/) {
+  TERN_(MARLIN_SMALL_BUILD, return);
+
   report_heading(forReplay, F(STR_Z_AUTO_ALIGN));
   for (uint8_t i = 0; i < NUM_Z_STEPPERS; ++i) {
     report_echo_start(forReplay);

commit 52693f72afca243ace00a7a57365301f5f8c42c0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 4 13:01:45 2024 -0600

    üé® Clean up some checks & includes

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index af2c6a5f65..bbc403904f 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -37,10 +37,6 @@
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
-#if HAS_MULTI_HOTEND
-  #include "../../module/tool_change.h"
-#endif
-
 #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
   #include "../../libs/least_squares_fit.h"
 #endif

commit 67d7562609986fae14d80036ad1e7a7f3aaa49d0
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Wed Dec 20 02:56:47 2023 +0100

    üêõ‚ö°Ô∏è FT_MOTION improvements (#26074)
    
    Co-Authored-By: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index f76df4316c..af2c6a5f65 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -79,6 +79,7 @@
  *   R                 Flag to recalculate points based on current probe offsets
  */
 void GcodeSuite::G34() {
+
   DEBUG_SECTION(log_G34, "G34", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) log_machine_info();
 

commit 574dd34c49fde76e1e736b8a7e1ea579d724ff22
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 13:19:36 2023 -0500

    ‚ôªÔ∏è String helper class (#24390)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 39f3d2d5df..f76df4316c 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -277,42 +277,21 @@ void GcodeSuite::G34() {
           );
         #endif
 
-        SERIAL_ECHOLNPGM("\n"
-          "Z2-Z1=", ABS(z_measured[1] - z_measured[0])
-          #if TRIPLE_Z
-            , " Z3-Z2=", ABS(z_measured[2] - z_measured[1])
-            , " Z3-Z1=", ABS(z_measured[2] - z_measured[0])
-            #if QUAD_Z
-              , " Z4-Z3=", ABS(z_measured[3] - z_measured[2])
-              , " Z4-Z2=", ABS(z_measured[3] - z_measured[1])
-              , " Z4-Z1=", ABS(z_measured[3] - z_measured[0])
-            #endif
-          #endif
-        );
+        SERIAL_EOL();
 
-        #if HAS_STATUS_MESSAGE
-          char fstr1[10];
-          char msg[6 + (6 + 5) * NUM_Z_STEPPERS + 1]
-            #if TRIPLE_Z
-              , fstr2[10], fstr3[10]
-              #if QUAD_Z
-                , fstr4[10], fstr5[10], fstr6[10]
-              #endif
-            #endif
-          ;
-          sprintf_P(msg,
-            PSTR("1:2=%s" TERN_(TRIPLE_Z, " 3-2=%s 3-1=%s") TERN_(QUAD_Z, " 4-3=%s 4-2=%s 4-1=%s")),
-            dtostrf(ABS(z_measured[1] - z_measured[0]), 1, 3, fstr1)
-            OPTARG(TRIPLE_Z,
-              dtostrf(ABS(z_measured[2] - z_measured[1]), 1, 3, fstr2),
-              dtostrf(ABS(z_measured[2] - z_measured[0]), 1, 3, fstr3))
-            OPTARG(QUAD_Z,
-              dtostrf(ABS(z_measured[3] - z_measured[2]), 1, 3, fstr4),
-              dtostrf(ABS(z_measured[3] - z_measured[1]), 1, 3, fstr5),
-              dtostrf(ABS(z_measured[3] - z_measured[0]), 1, 3, fstr6))
-          );
-          ui.set_status(msg);
+        SString<15 + TERN0(TRIPLE_Z, 30) + TERN0(QUAD_Z, 45)> msg(F("1:2="), p_float_t(ABS(z_measured[1] - z_measured[0]), 3));
+        #if TRIPLE_Z
+          msg.append(F(" 3-2="), p_float_t(ABS(z_measured[2] - z_measured[1]), 3))
+             .append(F(" 3-1="), p_float_t(ABS(z_measured[2] - z_measured[0]), 3));
         #endif
+        #if QUAD_Z
+          msg.append(F(" 4-3="), p_float_t(ABS(z_measured[3] - z_measured[2]), 3))
+             .append(F(" 4-2="), p_float_t(ABS(z_measured[3] - z_measured[1]), 3))
+             .append(F(" 4-1="), p_float_t(ABS(z_measured[3] - z_measured[0]), 3));
+        #endif
+
+        msg.echoln();
+        ui.set_status(msg);
 
         auto decreasing_accuracy = [](const_float_t v1, const_float_t v2) {
           if (v1 < v2 * 0.7f) {

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ‚ôªÔ∏è Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 7650443de8..39f3d2d5df 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -411,7 +411,7 @@ void GcodeSuite::G34() {
         SERIAL_ECHOLNPGM("G34 aborted.");
       else {
         SERIAL_ECHOLNPGM("Did ", iteration + (iteration != z_auto_align_iterations), " of ", z_auto_align_iterations);
-        SERIAL_ECHOLNPAIR_F("Accuracy: ", z_maxdiff);
+        SERIAL_ECHOLNPGM("Accuracy: ", p_float_t(z_maxdiff, 2));
       }
 
       // Stow the probe because the last call to probe.probe_at_point(...)
@@ -501,8 +501,7 @@ void GcodeSuite::M422() {
   }
 
   if (!WITHIN(position_index, 1, NUM_Z_STEPPERS)) {
-    SERIAL_ECHOF(err_string);
-    SERIAL_ECHOLNPGM(" index invalid (1.." STRINGIFY(NUM_Z_STEPPERS) ").");
+    SERIAL_ECHOLN(err_string, F(" index invalid (1.." STRINGIFY(NUM_Z_STEPPERS) ")."));
     return;
   }
 

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index a878db2edf..7650443de8 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -204,7 +204,7 @@ void GcodeSuite::G34() {
         float z_measured_max = -100000.0f;
 
         // Probe all positions (one per Z-Stepper)
-        LOOP_L_N(i, NUM_Z_STEPPERS) {
+        for (uint8_t i = 0; i < NUM_Z_STEPPERS; ++i) {
           // iteration odd/even --> downward / upward stepper sequence
           const uint8_t iprobe = (iteration & 1) ? NUM_Z_STEPPERS - 1 - i : i;
 
@@ -255,14 +255,14 @@ void GcodeSuite::G34() {
           // This allows the actual adjustment logic to be shared by both algorithms.
           linear_fit_data lfd;
           incremental_LSF_reset(&lfd);
-          LOOP_L_N(i, NUM_Z_STEPPERS) {
+          for (uint8_t i = 0; i < NUM_Z_STEPPERS; ++i) {
             SERIAL_ECHOLNPGM("PROBEPT_", i, ": ", z_measured[i]);
             incremental_LSF(&lfd, z_stepper_align.xy[i], z_measured[i]);
           }
           finish_incremental_LSF(&lfd);
 
           z_measured_min = 100000.0f;
-          LOOP_L_N(i, NUM_Z_STEPPERS) {
+          for (uint8_t i = 0; i < NUM_Z_STEPPERS; ++i) {
             z_measured[i] = -(lfd.A * z_stepper_align.stepper_xy[i].x + lfd.B * z_stepper_align.stepper_xy[i].y + lfd.D);
             z_measured_min = _MIN(z_measured_min, z_measured[i]);
           }
@@ -330,12 +330,12 @@ void GcodeSuite::G34() {
 
           // Calculate mean value as a reference
           float z_measured_mean = 0.0f;
-          LOOP_L_N(zstepper, NUM_Z_STEPPERS) z_measured_mean += z_measured[zstepper];
+          for (uint8_t zstepper = 0; zstepper < NUM_Z_STEPPERS; ++zstepper) z_measured_mean += z_measured[zstepper];
           z_measured_mean /= NUM_Z_STEPPERS;
 
           // Calculate the sum of the absolute deviations from the mean value
           float z_align_level_indicator = 0.0f;
-          LOOP_L_N(zstepper, NUM_Z_STEPPERS)
+          for (uint8_t zstepper = 0; zstepper < NUM_Z_STEPPERS; ++zstepper)
             z_align_level_indicator += ABS(z_measured[zstepper] - z_measured_mean);
 
           // If it's getting worse, stop and throw an error
@@ -350,7 +350,7 @@ void GcodeSuite::G34() {
 
         bool success_break = true;
         // Correct the individual stepper offsets
-        LOOP_L_N(zstepper, NUM_Z_STEPPERS) {
+        for (uint8_t zstepper = 0; zstepper < NUM_Z_STEPPERS; ++zstepper) {
           // Calculate current stepper move
           float z_align_move = z_measured[zstepper] - z_measured_min;
           const float z_align_abs = ABS(z_align_move);
@@ -529,7 +529,7 @@ void GcodeSuite::M422() {
 
 void GcodeSuite::M422_report(const bool forReplay/*=true*/) {
   report_heading(forReplay, F(STR_Z_AUTO_ALIGN));
-  LOOP_L_N(i, NUM_Z_STEPPERS) {
+  for (uint8_t i = 0; i < NUM_Z_STEPPERS; ++i) {
     report_echo_start(forReplay);
     SERIAL_ECHOLNPGM_P(
       PSTR("  M422 S"), i + 1,
@@ -538,7 +538,7 @@ void GcodeSuite::M422_report(const bool forReplay/*=true*/) {
     );
   }
   #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
-    LOOP_L_N(i, NUM_Z_STEPPERS) {
+    for (uint8_t i = 0; i < NUM_Z_STEPPERS; ++i) {
       report_echo_start(forReplay);
       SERIAL_ECHOLNPGM_P(
         PSTR("  M422 W"), i + 1,

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 3e7ed08b6c..a878db2edf 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -22,7 +22,7 @@
 
 #include "../../inc/MarlinConfigPre.h"
 
-#if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
+#if ANY(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
 
 #include "../../feature/z_stepper_align.h"
 
@@ -431,7 +431,7 @@ void GcodeSuite::G34() {
 
       probe.use_probing_tool(false);
 
-      #if BOTH(HAS_LEVELING, RESTORE_LEVELING_AFTER_G34)
+      #if ALL(HAS_LEVELING, RESTORE_LEVELING_AFTER_G34)
         set_bed_leveling_enabled(leveling_was_active);
       #endif
 

commit c5a2e41647a12ef16b280975ab713e080e831e46
Author: James Pearson <jamespearson04@hotmail.co.uk>
Date:   Fri Apr 28 23:30:15 2023 +0100

    üêõ Probe behavior corrections (#25631)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: David Fries <2767875+dfries@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index db6ef874d9..3e7ed08b6c 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -153,7 +153,8 @@ void GcodeSuite::G34() {
         const xy_pos_t diff = z_stepper_align.xy[i] - z_stepper_align.xy[j];
         return HYPOT2(diff.x, diff.y);
       };
-      float z_probe = (Z_PROBE_SAFE_CLEARANCE) + (G34_MAX_GRADE) * 0.01f * SQRT(_MAX(0, magnitude2(0, 1)
+      const float zoffs = (probe.offset.z < 0) ? -probe.offset.z : 0.0f;
+      float z_probe = (Z_TWEEN_SAFE_CLEARANCE + zoffs) + (G34_MAX_GRADE) * 0.01f * SQRT(_MAX(0, magnitude2(0, 1)
         #if TRIPLE_Z
           , magnitude2(2, 1), magnitude2(2, 0)
           #if QUAD_Z
@@ -165,12 +166,6 @@ void GcodeSuite::G34() {
       // Home before the alignment procedure
       home_if_needed();
 
-      // Move the Z coordinate realm towards the positive - dirty trick
-      current_position.z += z_probe * 0.5f;
-      sync_plan_position();
-      // Now, the Z origin lies below the build plate. That allows to probe deeper, before run_z_probe throws an error.
-      // This hack is un-done at the end of G34 - either by re-homing, or by using the probed heights of the last iteration.
-
       #if !HAS_Z_STEPPER_ALIGN_STEPPER_XY
         float last_z_align_move[NUM_Z_STEPPERS] = ARRAY_N_1(NUM_Z_STEPPERS, 10000.0f);
       #else
@@ -213,20 +208,16 @@ void GcodeSuite::G34() {
           // iteration odd/even --> downward / upward stepper sequence
           const uint8_t iprobe = (iteration & 1) ? NUM_Z_STEPPERS - 1 - i : i;
 
-          // Safe clearance even on an incline
-          if ((iteration == 0 || i > 0) && z_probe > current_position.z) do_blocking_move_to_z(z_probe);
-
           xy_pos_t &ppos = z_stepper_align.xy[iprobe];
 
-          if (DEBUGGING(LEVELING))
-            DEBUG_ECHOLNPGM_P(PSTR("Probing X"), ppos.x, SP_Y_STR, ppos.y);
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM_P(PSTR("Probing X"), ppos.x, SP_Y_STR, ppos.y);
 
           // Probe a Z height for each stepper.
           // Probing sanity check is disabled, as it would trigger even in normal cases because
           // current_position.z has been manually altered in the "dirty trick" above.
-          const float z_probed_height = probe.probe_at_point(DIFF_TERN(HAS_HOME_OFFSET, ppos, xy_pos_t(home_offset)), raise_after, 0, true, false);
+          const float z_probed_height = probe.probe_at_point(DIFF_TERN(HAS_HOME_OFFSET, ppos, xy_pos_t(home_offset)), raise_after, 0, true, false, (Z_PROBE_LOW_POINT) - z_probe * 0.5f, z_probe * 0.5f);
           if (isnan(z_probed_height)) {
-            SERIAL_ECHOLNPGM("Probing failed");
+            SERIAL_ECHOLNPGM(STR_ERR_PROBING_FAILED);
             LCD_MESSAGE(MSG_LCD_PROBING_FAILED);
             err_break = true;
             break;
@@ -234,7 +225,7 @@ void GcodeSuite::G34() {
 
           // Add height to each value, to provide a more useful target height for
           // the next iteration of probing. This allows adjustments to be made away from the bed.
-          z_measured[iprobe] = z_probed_height + (Z_CLEARANCE_BETWEEN_PROBES);
+          z_measured[iprobe] = z_probed_height + (Z_TWEEN_SAFE_CLEARANCE + zoffs); //do we need to add the clearance to this?
 
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Z", iprobe + 1, " measured position is ", z_measured[iprobe]);
 
@@ -248,7 +239,7 @@ void GcodeSuite::G34() {
         // Adapt the next probe clearance height based on the new measurements.
         // Safe_height = lowest distance to bed (= highest measurement) plus highest measured misalignment.
         z_maxdiff = z_measured_max - z_measured_min;
-        z_probe = (Z_PROBE_SAFE_CLEARANCE) + z_measured_max + z_maxdiff;
+        z_probe = (Z_TWEEN_SAFE_CLEARANCE + zoffs) + z_measured_max + z_maxdiff; //Not sure we need z_maxdiff, but leaving it in for safety.
 
         #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
           // Replace the initial values in z_measured with calculated heights at
@@ -428,15 +419,13 @@ void GcodeSuite::G34() {
       IF_DISABLED(TOUCH_MI_PROBE, probe.stow());
 
       #if ENABLED(HOME_AFTER_G34)
-        // After this operation the z position needs correction
-        set_axis_never_homed(Z_AXIS);
         // Home Z after the alignment procedure
         process_subcommands_now(F("G28Z"));
       #else
         // Use the probed height from the last iteration to determine the Z height.
         // z_measured_min is used, because all steppers are aligned to z_measured_min.
         // Ideally, this would be equal to the 'z_probe * 0.5f' which was added earlier.
-        current_position.z -= z_measured_min - float(Z_CLEARANCE_BETWEEN_PROBES);
+        current_position.z -= z_measured_min - (Z_TWEEN_SAFE_CLEARANCE + zoffs); //we shouldn't want to subtract the clearance from here right? (Depends if we added it further up)
         sync_plan_position();
       #endif
 

commit 266786406c3e90654e94b91cd74e646d145cc4ef
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 30 15:12:56 2023 -0500

    üé® Misc. probe-related cleanup

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 816e455b84..db6ef874d9 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -153,7 +153,7 @@ void GcodeSuite::G34() {
         const xy_pos_t diff = z_stepper_align.xy[i] - z_stepper_align.xy[j];
         return HYPOT2(diff.x, diff.y);
       };
-      float z_probe = Z_PROBE_SAFE_CLEARANCE + (G34_MAX_GRADE) * 0.01f * SQRT(_MAX(0, magnitude2(0, 1)
+      float z_probe = (Z_PROBE_SAFE_CLEARANCE) + (G34_MAX_GRADE) * 0.01f * SQRT(_MAX(0, magnitude2(0, 1)
         #if TRIPLE_Z
           , magnitude2(2, 1), magnitude2(2, 0)
           #if QUAD_Z
@@ -234,7 +234,7 @@ void GcodeSuite::G34() {
 
           // Add height to each value, to provide a more useful target height for
           // the next iteration of probing. This allows adjustments to be made away from the bed.
-          z_measured[iprobe] = z_probed_height + Z_CLEARANCE_BETWEEN_PROBES;
+          z_measured[iprobe] = z_probed_height + (Z_CLEARANCE_BETWEEN_PROBES);
 
           if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Z", iprobe + 1, " measured position is ", z_measured[iprobe]);
 
@@ -248,7 +248,7 @@ void GcodeSuite::G34() {
         // Adapt the next probe clearance height based on the new measurements.
         // Safe_height = lowest distance to bed (= highest measurement) plus highest measured misalignment.
         z_maxdiff = z_measured_max - z_measured_min;
-        z_probe = Z_PROBE_SAFE_CLEARANCE + z_measured_max + z_maxdiff;
+        z_probe = (Z_PROBE_SAFE_CLEARANCE) + z_measured_max + z_maxdiff;
 
         #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
           // Replace the initial values in z_measured with calculated heights at
@@ -436,7 +436,7 @@ void GcodeSuite::G34() {
         // Use the probed height from the last iteration to determine the Z height.
         // z_measured_min is used, because all steppers are aligned to z_measured_min.
         // Ideally, this would be equal to the 'z_probe * 0.5f' which was added earlier.
-        current_position.z -= z_measured_min - (float)Z_CLEARANCE_BETWEEN_PROBES;
+        current_position.z -= z_measured_min - float(Z_CLEARANCE_BETWEEN_PROBES);
         sync_plan_position();
       #endif
 

commit 49f1cc8efe0fcb8df79581c0b71eedef250e83f7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 29 22:55:36 2023 -0500

    üé® Refine probe, more debug

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 6d5ca8bf19..816e455b84 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -147,18 +147,13 @@ void GcodeSuite::G34() {
 
       TERN_(HAS_DUPLICATION_MODE, set_duplication_enabled(false));
 
-      // In BLTOUCH HS mode, the probe travels in a deployed state.
-      // Users of G34 might have a badly misaligned bed, so raise Z by the
-      // length of the deployed pin (BLTOUCH stroke < 7mm)
-      #define Z_BASIC_CLEARANCE (Z_CLEARANCE_BETWEEN_PROBES + TERN0(BLTOUCH, bltouch.z_extra_clearance()))
-
       // Compute a worst-case clearance height to probe from. After the first
       // iteration this will be re-calculated based on the actual bed position
       auto magnitude2 = [&](const uint8_t i, const uint8_t j) {
         const xy_pos_t diff = z_stepper_align.xy[i] - z_stepper_align.xy[j];
         return HYPOT2(diff.x, diff.y);
       };
-      float z_probe = Z_BASIC_CLEARANCE + (G34_MAX_GRADE) * 0.01f * SQRT(_MAX(0, magnitude2(0, 1)
+      float z_probe = Z_PROBE_SAFE_CLEARANCE + (G34_MAX_GRADE) * 0.01f * SQRT(_MAX(0, magnitude2(0, 1)
         #if TRIPLE_Z
           , magnitude2(2, 1), magnitude2(2, 0)
           #if QUAD_Z
@@ -253,7 +248,7 @@ void GcodeSuite::G34() {
         // Adapt the next probe clearance height based on the new measurements.
         // Safe_height = lowest distance to bed (= highest measurement) plus highest measured misalignment.
         z_maxdiff = z_measured_max - z_measured_min;
-        z_probe = Z_BASIC_CLEARANCE + z_measured_max + z_maxdiff;
+        z_probe = Z_PROBE_SAFE_CLEARANCE + z_measured_max + z_maxdiff;
 
         #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
           // Replace the initial values in z_measured with calculated heights at

commit 06cfd9c54af1537adf458a719b840cd501395278
Author: John Lagonikas <39417467+zeleps@users.noreply.github.com>
Date:   Wed Mar 22 02:15:51 2023 +0200

    ‚ú® PROBING_TOOL (#24411)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 8cf652cd84..6d5ca8bf19 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -108,6 +108,7 @@ void GcodeSuite::G34() {
   }
 
   #if ENABLED(Z_STEPPER_AUTO_ALIGN)
+
     do { // break out on error
 
       const int8_t z_auto_align_iterations = parser.intval('I', Z_STEPPER_ALIGN_ITERATIONS);
@@ -142,11 +143,7 @@ void GcodeSuite::G34() {
 
       TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
-      // Always home with tool 0 active
-      #if HAS_MULTI_HOTEND
-        const uint8_t old_tool_index = active_extruder;
-        tool_change(0, true);
-      #endif
+      probe.use_probing_tool();
 
       TERN_(HAS_DUPLICATION_MODE, set_duplication_enabled(false));
 
@@ -448,14 +445,16 @@ void GcodeSuite::G34() {
         sync_plan_position();
       #endif
 
-      // Restore the active tool after homing
-      TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index, DISABLED(PARKING_EXTRUDER))); // Fetch previous tool for parking extruder
+      probe.use_probing_tool(false);
 
       #if BOTH(HAS_LEVELING, RESTORE_LEVELING_AFTER_G34)
         set_bed_leveling_enabled(leveling_was_active);
       #endif
 
     }while(0);
+
+    probe.use_probing_tool(false);
+
   #endif // Z_STEPPER_AUTO_ALIGN
 }
 

commit bb3c5aa18674748ed02bf53dc2b4344a0560868f
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jul 18 21:12:27 2022 -0400

    üö∏ Machine-relative Z_STEPPER_ALIGN_XY (#24261)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index d68207885d..8cf652cd84 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -224,13 +224,15 @@ void GcodeSuite::G34() {
           // Safe clearance even on an incline
           if ((iteration == 0 || i > 0) && z_probe > current_position.z) do_blocking_move_to_z(z_probe);
 
+          xy_pos_t &ppos = z_stepper_align.xy[iprobe];
+
           if (DEBUGGING(LEVELING))
-            DEBUG_ECHOLNPGM_P(PSTR("Probing X"), z_stepper_align.xy[iprobe].x, SP_Y_STR, z_stepper_align.xy[iprobe].y);
+            DEBUG_ECHOLNPGM_P(PSTR("Probing X"), ppos.x, SP_Y_STR, ppos.y);
 
           // Probe a Z height for each stepper.
           // Probing sanity check is disabled, as it would trigger even in normal cases because
           // current_position.z has been manually altered in the "dirty trick" above.
-          const float z_probed_height = probe.probe_at_point(z_stepper_align.xy[iprobe], raise_after, 0, true, false);
+          const float z_probed_height = probe.probe_at_point(DIFF_TERN(HAS_HOME_OFFSET, ppos, xy_pos_t(home_offset)), raise_after, 0, true, false);
           if (isnan(z_probed_height)) {
             SERIAL_ECHOLNPGM("Probing failed");
             LCD_MESSAGE(MSG_LCD_PROBING_FAILED);

commit df40181357b08761766067ef5012b2b3d0e34d3e
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed May 4 17:25:02 2022 -0700

    üí• Num Axes and Multi-Stepper based on Driver Types (#24120)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index d1f82e7e98..d68207885d 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -52,9 +52,9 @@
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
 
-#if NUM_Z_STEPPER_DRIVERS >= 3
+#if NUM_Z_STEPPERS >= 3
   #define TRIPLE_Z 1
-  #if NUM_Z_STEPPER_DRIVERS >= 4
+  #if NUM_Z_STEPPERS >= 4
     #define QUAD_Z 1
   #endif
 #endif
@@ -180,11 +180,11 @@ void GcodeSuite::G34() {
       // This hack is un-done at the end of G34 - either by re-homing, or by using the probed heights of the last iteration.
 
       #if !HAS_Z_STEPPER_ALIGN_STEPPER_XY
-        float last_z_align_move[NUM_Z_STEPPER_DRIVERS] = ARRAY_N_1(NUM_Z_STEPPER_DRIVERS, 10000.0f);
+        float last_z_align_move[NUM_Z_STEPPERS] = ARRAY_N_1(NUM_Z_STEPPERS, 10000.0f);
       #else
         float last_z_align_level_indicator = 10000.0f;
       #endif
-      float z_measured[NUM_Z_STEPPER_DRIVERS] = { 0 },
+      float z_measured[NUM_Z_STEPPERS] = { 0 },
             z_maxdiff = 0.0f,
             amplification = z_auto_align_amplification;
 
@@ -217,9 +217,9 @@ void GcodeSuite::G34() {
         float z_measured_max = -100000.0f;
 
         // Probe all positions (one per Z-Stepper)
-        LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
+        LOOP_L_N(i, NUM_Z_STEPPERS) {
           // iteration odd/even --> downward / upward stepper sequence
-          const uint8_t iprobe = (iteration & 1) ? NUM_Z_STEPPER_DRIVERS - 1 - i : i;
+          const uint8_t iprobe = (iteration & 1) ? NUM_Z_STEPPERS - 1 - i : i;
 
           // Safe clearance even on an incline
           if ((iteration == 0 || i > 0) && z_probe > current_position.z) do_blocking_move_to_z(z_probe);
@@ -270,20 +270,20 @@ void GcodeSuite::G34() {
           // This allows the actual adjustment logic to be shared by both algorithms.
           linear_fit_data lfd;
           incremental_LSF_reset(&lfd);
-          LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
+          LOOP_L_N(i, NUM_Z_STEPPERS) {
             SERIAL_ECHOLNPGM("PROBEPT_", i, ": ", z_measured[i]);
             incremental_LSF(&lfd, z_stepper_align.xy[i], z_measured[i]);
           }
           finish_incremental_LSF(&lfd);
 
           z_measured_min = 100000.0f;
-          LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
+          LOOP_L_N(i, NUM_Z_STEPPERS) {
             z_measured[i] = -(lfd.A * z_stepper_align.stepper_xy[i].x + lfd.B * z_stepper_align.stepper_xy[i].y + lfd.D);
             z_measured_min = _MIN(z_measured_min, z_measured[i]);
           }
 
           SERIAL_ECHOLNPGM(
-            LIST_N(DOUBLE(NUM_Z_STEPPER_DRIVERS),
+            LIST_N(DOUBLE(NUM_Z_STEPPERS),
               "Calculated Z1=", z_measured[0],
                         " Z2=", z_measured[1],
                         " Z3=", z_measured[2],
@@ -307,7 +307,7 @@ void GcodeSuite::G34() {
 
         #if HAS_STATUS_MESSAGE
           char fstr1[10];
-          char msg[6 + (6 + 5) * NUM_Z_STEPPER_DRIVERS + 1]
+          char msg[6 + (6 + 5) * NUM_Z_STEPPERS + 1]
             #if TRIPLE_Z
               , fstr2[10], fstr3[10]
               #if QUAD_Z
@@ -345,12 +345,12 @@ void GcodeSuite::G34() {
 
           // Calculate mean value as a reference
           float z_measured_mean = 0.0f;
-          LOOP_L_N(zstepper, NUM_Z_STEPPER_DRIVERS) z_measured_mean += z_measured[zstepper];
-          z_measured_mean /= NUM_Z_STEPPER_DRIVERS;
+          LOOP_L_N(zstepper, NUM_Z_STEPPERS) z_measured_mean += z_measured[zstepper];
+          z_measured_mean /= NUM_Z_STEPPERS;
 
           // Calculate the sum of the absolute deviations from the mean value
           float z_align_level_indicator = 0.0f;
-          LOOP_L_N(zstepper, NUM_Z_STEPPER_DRIVERS)
+          LOOP_L_N(zstepper, NUM_Z_STEPPERS)
             z_align_level_indicator += ABS(z_measured[zstepper] - z_measured_mean);
 
           // If it's getting worse, stop and throw an error
@@ -365,7 +365,7 @@ void GcodeSuite::G34() {
 
         bool success_break = true;
         // Correct the individual stepper offsets
-        LOOP_L_N(zstepper, NUM_Z_STEPPER_DRIVERS) {
+        LOOP_L_N(zstepper, NUM_Z_STEPPERS) {
           // Calculate current stepper move
           float z_align_move = z_measured[zstepper] - z_measured_min;
           const float z_align_abs = ABS(z_align_move);
@@ -515,9 +515,9 @@ void GcodeSuite::M422() {
     #endif
   }
 
-  if (!WITHIN(position_index, 1, NUM_Z_STEPPER_DRIVERS)) {
+  if (!WITHIN(position_index, 1, NUM_Z_STEPPERS)) {
     SERIAL_ECHOF(err_string);
-    SERIAL_ECHOLNPGM(" index invalid (1.." STRINGIFY(NUM_Z_STEPPER_DRIVERS) ").");
+    SERIAL_ECHOLNPGM(" index invalid (1.." STRINGIFY(NUM_Z_STEPPERS) ").");
     return;
   }
 
@@ -544,7 +544,7 @@ void GcodeSuite::M422() {
 
 void GcodeSuite::M422_report(const bool forReplay/*=true*/) {
   report_heading(forReplay, F(STR_Z_AUTO_ALIGN));
-  LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
+  LOOP_L_N(i, NUM_Z_STEPPERS) {
     report_echo_start(forReplay);
     SERIAL_ECHOLNPGM_P(
       PSTR("  M422 S"), i + 1,
@@ -553,7 +553,7 @@ void GcodeSuite::M422_report(const bool forReplay/*=true*/) {
     );
   }
   #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
-    LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
+    LOOP_L_N(i, NUM_Z_STEPPERS) {
       report_echo_start(forReplay);
       SERIAL_ECHOLNPGM_P(
         PSTR("  M422 W"), i + 1,

commit 4b84b28c1435ff4520e0f8078f0a061aa27f6884
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 10 17:25:09 2022 -0600

    üö∏ Improve M422 error messages

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 61e817fe94..d1f82e7e98 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -493,7 +493,7 @@ void GcodeSuite::M422() {
     return;
   }
 
-  xy_pos_t *pos_dest = (
+  xy_pos_t * const pos_dest = (
     TERN_(HAS_Z_STEPPER_ALIGN_STEPPER_XY, !is_probe_point ? z_stepper_align.stepper_xy :)
     z_stepper_align.xy
   );
@@ -504,24 +504,25 @@ void GcodeSuite::M422() {
   }
 
   // Get the Probe Position Index or Z Stepper Index
-  int8_t position_index;
-  if (is_probe_point) {
-    position_index = parser.intval('S') - 1;
-    if (!WITHIN(position_index, 0, int8_t(NUM_Z_STEPPER_DRIVERS) - 1)) {
-      SERIAL_ECHOLNPGM("?(S) Probe-position index invalid.");
-      return;
-    }
-  }
+  int8_t position_index = 1;
+  FSTR_P err_string = F("?(S) Probe-position");
+  if (is_probe_point)
+    position_index = parser.intval('S');
   else {
     #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
-      position_index = parser.intval('W') - 1;
-      if (!WITHIN(position_index, 0, NUM_Z_STEPPER_DRIVERS - 1)) {
-        SERIAL_ECHOLNPGM("?(W) Z-stepper index invalid.");
-        return;
-      }
+      err_string = F("?(W) Z-stepper");
+      position_index = parser.intval('W');
     #endif
   }
 
+  if (!WITHIN(position_index, 1, NUM_Z_STEPPER_DRIVERS)) {
+    SERIAL_ECHOF(err_string);
+    SERIAL_ECHOLNPGM(" index invalid (1.." STRINGIFY(NUM_Z_STEPPER_DRIVERS) ").");
+    return;
+  }
+
+  --position_index;
+
   const xy_pos_t pos = {
     parser.floatval('X', pos_dest[position_index].x),
     parser.floatval('Y', pos_dest[position_index].y)

commit 6aee2c755bb0468df1672d566897f2c6becab597
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 2 17:58:23 2022 -0600

    ‚ö°Ô∏è Use seen_test in `M422`

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index fc4430885e..61e817fe94 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -486,9 +486,9 @@ void GcodeSuite::M422() {
     return;
   }
 
-  const bool is_probe_point = parser.seen('S');
+  const bool is_probe_point = parser.seen_test('S');
 
-  if (TERN0(HAS_Z_STEPPER_ALIGN_STEPPER_XY, is_probe_point && parser.seen('W'))) {
+  if (TERN0(HAS_Z_STEPPER_ALIGN_STEPPER_XY, is_probe_point && parser.seen_test('W'))) {
     SERIAL_ECHOLNPGM("?(S) and (W) may not be combined.");
     return;
   }
@@ -498,7 +498,7 @@ void GcodeSuite::M422() {
     z_stepper_align.xy
   );
 
-  if (!is_probe_point && TERN1(HAS_Z_STEPPER_ALIGN_STEPPER_XY, !parser.seen('W'))) {
+  if (!is_probe_point && TERN1(HAS_Z_STEPPER_ALIGN_STEPPER_XY, !parser.seen_test('W'))) {
     SERIAL_ECHOLNPGM("?(S)" TERN_(HAS_Z_STEPPER_ALIGN_STEPPER_XY, " or (W)") " is required.");
     return;
   }

commit bb2f100fcdaef30958601ec90ebcaad0fcae8815
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 2 17:50:55 2022 -0600

    üö∏ Use Z_STEPPER_ALIGN_STEPPER_XY to enable

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 328a40dbb4..fc4430885e 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -41,7 +41,7 @@
   #include "../../module/tool_change.h"
 #endif
 
-#if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+#if HAS_Z_STEPPER_ALIGN_STEPPER_XY
   #include "../../libs/least_squares_fit.h"
 #endif
 
@@ -122,7 +122,7 @@ void GcodeSuite::G34() {
         break;
       }
 
-      const float z_auto_align_amplification = TERN(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS, Z_STEPPER_ALIGN_AMP, parser.floatval('A', Z_STEPPER_ALIGN_AMP));
+      const float z_auto_align_amplification = TERN(HAS_Z_STEPPER_ALIGN_STEPPER_XY, Z_STEPPER_ALIGN_AMP, parser.floatval('A', Z_STEPPER_ALIGN_AMP));
       if (!WITHIN(ABS(z_auto_align_amplification), 0.5f, 2.0f)) {
         SERIAL_ECHOLNPGM("?(A)mplification out of bounds (0.5-2.0).");
         break;
@@ -179,7 +179,7 @@ void GcodeSuite::G34() {
       // Now, the Z origin lies below the build plate. That allows to probe deeper, before run_z_probe throws an error.
       // This hack is un-done at the end of G34 - either by re-homing, or by using the probed heights of the last iteration.
 
-      #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+      #if !HAS_Z_STEPPER_ALIGN_STEPPER_XY
         float last_z_align_move[NUM_Z_STEPPER_DRIVERS] = ARRAY_N_1(NUM_Z_STEPPER_DRIVERS, 10000.0f);
       #else
         float last_z_align_level_indicator = 10000.0f;
@@ -188,7 +188,7 @@ void GcodeSuite::G34() {
             z_maxdiff = 0.0f,
             amplification = z_auto_align_amplification;
 
-      #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+      #if !HAS_Z_STEPPER_ALIGN_STEPPER_XY
         bool adjustment_reverse = false;
       #endif
 
@@ -256,7 +256,7 @@ void GcodeSuite::G34() {
         z_maxdiff = z_measured_max - z_measured_min;
         z_probe = Z_BASIC_CLEARANCE + z_measured_max + z_maxdiff;
 
-        #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+        #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
           // Replace the initial values in z_measured with calculated heights at
           // each stepper position. This allows the adjustment algorithm to be
           // shared between both possible probing mechanisms.
@@ -338,7 +338,7 @@ void GcodeSuite::G34() {
           return false;
         };
 
-        #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+        #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
           // Check if the applied corrections go in the correct direction.
           // Calculate the sum of the absolute deviations from the mean of the probe measurements.
           // Compare to the last iteration to ensure it's getting better.
@@ -370,7 +370,7 @@ void GcodeSuite::G34() {
           float z_align_move = z_measured[zstepper] - z_measured_min;
           const float z_align_abs = ABS(z_align_move);
 
-          #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+          #if !HAS_Z_STEPPER_ALIGN_STEPPER_XY
             // Optimize one iteration's correction based on the first measurements
             if (z_align_abs) amplification = (iteration == 1) ? _MIN(last_z_align_move[zstepper] / z_align_abs, 2.0f) : z_auto_align_amplification;
 
@@ -394,7 +394,7 @@ void GcodeSuite::G34() {
           // Lock all steppers except one
           stepper.set_all_z_lock(true, zstepper);
 
-          #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+          #if !HAS_Z_STEPPER_ALIGN_STEPPER_XY
             // Decreasing accuracy was detected so move was inverted.
             // Will match reversed Z steppers on dual steppers. Triple will need more work to map.
             if (adjustment_reverse) {
@@ -467,7 +467,7 @@ void GcodeSuite::G34() {
  *
  *   S<index> : Index of the probe point to set
  *
- * With Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS:
+ * With Z_STEPPER_ALIGN_STEPPER_XY:
  *   W<index> : Index of the Z stepper position to set
  *              The W and S parameters may not be combined.
  *
@@ -488,18 +488,18 @@ void GcodeSuite::M422() {
 
   const bool is_probe_point = parser.seen('S');
 
-  if (TERN0(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS, is_probe_point && parser.seen('W'))) {
+  if (TERN0(HAS_Z_STEPPER_ALIGN_STEPPER_XY, is_probe_point && parser.seen('W'))) {
     SERIAL_ECHOLNPGM("?(S) and (W) may not be combined.");
     return;
   }
 
   xy_pos_t *pos_dest = (
-    TERN_(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS, !is_probe_point ? z_stepper_align.stepper_xy :)
+    TERN_(HAS_Z_STEPPER_ALIGN_STEPPER_XY, !is_probe_point ? z_stepper_align.stepper_xy :)
     z_stepper_align.xy
   );
 
-  if (!is_probe_point && TERN1(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS, !parser.seen('W'))) {
-    SERIAL_ECHOLNPGM("?(S)" TERN_(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS, " or (W)") " is required.");
+  if (!is_probe_point && TERN1(HAS_Z_STEPPER_ALIGN_STEPPER_XY, !parser.seen('W'))) {
+    SERIAL_ECHOLNPGM("?(S)" TERN_(HAS_Z_STEPPER_ALIGN_STEPPER_XY, " or (W)") " is required.");
     return;
   }
 
@@ -513,7 +513,7 @@ void GcodeSuite::M422() {
     }
   }
   else {
-    #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+    #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
       position_index = parser.intval('W') - 1;
       if (!WITHIN(position_index, 0, NUM_Z_STEPPER_DRIVERS - 1)) {
         SERIAL_ECHOLNPGM("?(W) Z-stepper index invalid.");
@@ -551,7 +551,7 @@ void GcodeSuite::M422_report(const bool forReplay/*=true*/) {
       SP_Y_STR, z_stepper_align.xy[i].y
     );
   }
-  #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+  #if HAS_Z_STEPPER_ALIGN_STEPPER_XY
     LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
       report_echo_start(forReplay);
       SERIAL_ECHOLNPGM_P(

commit 2893048e2955963bb307a4ca67ec26bb336de2f5
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Dec 21 23:09:55 2021 -0500

    ‚ú® BLTouch High Speed mode runtime configuration (#22916)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 8f4eab2c97..328a40dbb4 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -45,6 +45,10 @@
   #include "../../libs/least_squares_fit.h"
 #endif
 
+#if ENABLED(BLTOUCH)
+  #include "../../feature/bltouch.h"
+#endif
+
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
 
@@ -149,7 +153,7 @@ void GcodeSuite::G34() {
       // In BLTOUCH HS mode, the probe travels in a deployed state.
       // Users of G34 might have a badly misaligned bed, so raise Z by the
       // length of the deployed pin (BLTOUCH stroke < 7mm)
-      #define Z_BASIC_CLEARANCE (Z_CLEARANCE_BETWEEN_PROBES + 7.0f * BOTH(BLTOUCH, BLTOUCH_HS_MODE))
+      #define Z_BASIC_CLEARANCE (Z_CLEARANCE_BETWEEN_PROBES + TERN0(BLTOUCH, bltouch.z_extra_clearance()))
 
       // Compute a worst-case clearance height to probe from. After the first
       // iteration this will be re-calculated based on the actual bed position

commit d7fede3a6324cd6b1ec91a9c8e248fce8f0d7cf2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 13:40:01 2021 -0500

    üé® Apply F() to G-code report header

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 25855e6a4e..8f4eab2c97 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -538,7 +538,7 @@ void GcodeSuite::M422() {
 }
 
 void GcodeSuite::M422_report(const bool forReplay/*=true*/) {
-  report_heading(forReplay, PSTR(STR_Z_AUTO_ALIGN));
+  report_heading(forReplay, F(STR_Z_AUTO_ALIGN));
   LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
     report_echo_start(forReplay);
     SERIAL_ECHOLNPGM_P(

commit 7f1286a11f87065c4e666985e679cf9c77d668bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 17:05:11 2021 -0500

    üé® Apply F() to status message

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 63d839c847..25855e6a4e 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -31,7 +31,7 @@
 #include "../../module/stepper.h"
 #include "../../module/planner.h"
 #include "../../module/probe.h"
-#include "../../lcd/marlinui.h" // for LCD_MESSAGEPGM
+#include "../../lcd/marlinui.h" // for LCD_MESSAGE
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
@@ -229,7 +229,7 @@ void GcodeSuite::G34() {
           const float z_probed_height = probe.probe_at_point(z_stepper_align.xy[iprobe], raise_after, 0, true, false);
           if (isnan(z_probed_height)) {
             SERIAL_ECHOLNPGM("Probing failed");
-            LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
+            LCD_MESSAGE(MSG_LCD_PROBING_FAILED);
             err_break = true;
             break;
           }
@@ -328,7 +328,7 @@ void GcodeSuite::G34() {
         auto decreasing_accuracy = [](const_float_t v1, const_float_t v2) {
           if (v1 < v2 * 0.7f) {
             SERIAL_ECHOLNPGM("Decreasing Accuracy Detected.");
-            LCD_MESSAGEPGM(MSG_DECREASING_ACCURACY);
+            LCD_MESSAGE(MSG_DECREASING_ACCURACY);
             return true;
           }
           return false;
@@ -411,7 +411,7 @@ void GcodeSuite::G34() {
 
         if (success_break) {
           SERIAL_ECHOLNPGM("Target accuracy achieved.");
-          LCD_MESSAGEPGM(MSG_ACCURACY_ACHIEVED);
+          LCD_MESSAGE(MSG_ACCURACY_ACHIEVED);
           break;
         }
 

commit 59dac3a7e41ae7964686d9dff56baba821a278f7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 18:43:52 2021 -0500

    üé® Apply F() to G-code subcommands

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index dd1dd5622a..63d839c847 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -433,7 +433,7 @@ void GcodeSuite::G34() {
         // After this operation the z position needs correction
         set_axis_never_homed(Z_AXIS);
         // Home Z after the alignment procedure
-        process_subcommands_now_P(PSTR("G28Z"));
+        process_subcommands_now(F("G28Z"));
       #else
         // Use the probed height from the last iteration to determine the Z height.
         // z_measured_min is used, because all steppers are aligned to z_measured_min.

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index c5f5e582a9..dd1dd5622a 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -201,7 +201,7 @@ void GcodeSuite::G34() {
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> probing all positions.");
 
         const int iter = iteration + 1;
-        SERIAL_ECHOLNPAIR("\nG34 Iteration: ", iter);
+        SERIAL_ECHOLNPGM("\nG34 Iteration: ", iter);
         #if HAS_STATUS_MESSAGE
           char str[iter_str_len + 2 + 1];
           sprintf_P(str, msg_iteration, iter);
@@ -221,7 +221,7 @@ void GcodeSuite::G34() {
           if ((iteration == 0 || i > 0) && z_probe > current_position.z) do_blocking_move_to_z(z_probe);
 
           if (DEBUGGING(LEVELING))
-            DEBUG_ECHOLNPAIR_P(PSTR("Probing X"), z_stepper_align.xy[iprobe].x, SP_Y_STR, z_stepper_align.xy[iprobe].y);
+            DEBUG_ECHOLNPGM_P(PSTR("Probing X"), z_stepper_align.xy[iprobe].x, SP_Y_STR, z_stepper_align.xy[iprobe].y);
 
           // Probe a Z height for each stepper.
           // Probing sanity check is disabled, as it would trigger even in normal cases because
@@ -238,7 +238,7 @@ void GcodeSuite::G34() {
           // the next iteration of probing. This allows adjustments to be made away from the bed.
           z_measured[iprobe] = z_probed_height + Z_CLEARANCE_BETWEEN_PROBES;
 
-          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", iprobe + 1, " measured position is ", z_measured[iprobe]);
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Z", iprobe + 1, " measured position is ", z_measured[iprobe]);
 
           // Remember the minimum measurement to calculate the correction later on
           z_measured_min = _MIN(z_measured_min, z_measured[iprobe]);
@@ -267,7 +267,7 @@ void GcodeSuite::G34() {
           linear_fit_data lfd;
           incremental_LSF_reset(&lfd);
           LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
-            SERIAL_ECHOLNPAIR("PROBEPT_", i, ": ", z_measured[i]);
+            SERIAL_ECHOLNPGM("PROBEPT_", i, ": ", z_measured[i]);
             incremental_LSF(&lfd, z_stepper_align.xy[i], z_measured[i]);
           }
           finish_incremental_LSF(&lfd);
@@ -278,7 +278,7 @@ void GcodeSuite::G34() {
             z_measured_min = _MIN(z_measured_min, z_measured[i]);
           }
 
-          SERIAL_ECHOLNPAIR(
+          SERIAL_ECHOLNPGM(
             LIST_N(DOUBLE(NUM_Z_STEPPER_DRIVERS),
               "Calculated Z1=", z_measured[0],
                         " Z2=", z_measured[1],
@@ -288,7 +288,7 @@ void GcodeSuite::G34() {
           );
         #endif
 
-        SERIAL_ECHOLNPAIR("\n"
+        SERIAL_ECHOLNPGM("\n"
           "Z2-Z1=", ABS(z_measured[1] - z_measured[0])
           #if TRIPLE_Z
             , " Z3-Z2=", ABS(z_measured[2] - z_measured[1])
@@ -372,8 +372,8 @@ void GcodeSuite::G34() {
 
             // Check for less accuracy compared to last move
             if (decreasing_accuracy(last_z_align_move[zstepper], z_align_abs)) {
-              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", zstepper + 1, " last_z_align_move = ", last_z_align_move[zstepper]);
-              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", zstepper + 1, " z_align_abs = ", z_align_abs);
+              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Z", zstepper + 1, " last_z_align_move = ", last_z_align_move[zstepper]);
+              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Z", zstepper + 1, " z_align_abs = ", z_align_abs);
               adjustment_reverse = !adjustment_reverse;
             }
 
@@ -385,7 +385,7 @@ void GcodeSuite::G34() {
           // Stop early if all measured points achieve accuracy target
           if (z_align_abs > z_auto_align_accuracy) success_break = false;
 
-          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", zstepper + 1, " corrected by ", z_align_move);
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Z", zstepper + 1, " corrected by ", z_align_move);
 
           // Lock all steppers except one
           stepper.set_all_z_lock(true, zstepper);
@@ -395,7 +395,7 @@ void GcodeSuite::G34() {
             // Will match reversed Z steppers on dual steppers. Triple will need more work to map.
             if (adjustment_reverse) {
               z_align_move = -z_align_move;
-              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", zstepper + 1, " correction reversed to ", z_align_move);
+              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> Z", zstepper + 1, " correction reversed to ", z_align_move);
             }
           #endif
 
@@ -421,7 +421,7 @@ void GcodeSuite::G34() {
       if (err_break)
         SERIAL_ECHOLNPGM("G34 aborted.");
       else {
-        SERIAL_ECHOLNPAIR("Did ", iteration + (iteration != z_auto_align_iterations), " of ", z_auto_align_iterations);
+        SERIAL_ECHOLNPGM("Did ", iteration + (iteration != z_auto_align_iterations), " of ", z_auto_align_iterations);
         SERIAL_ECHOLNPAIR_F("Accuracy: ", z_maxdiff);
       }
 
@@ -541,7 +541,7 @@ void GcodeSuite::M422_report(const bool forReplay/*=true*/) {
   report_heading(forReplay, PSTR(STR_Z_AUTO_ALIGN));
   LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
     report_echo_start(forReplay);
-    SERIAL_ECHOLNPAIR_P(
+    SERIAL_ECHOLNPGM_P(
       PSTR("  M422 S"), i + 1,
       SP_X_STR, z_stepper_align.xy[i].x,
       SP_Y_STR, z_stepper_align.xy[i].y
@@ -550,7 +550,7 @@ void GcodeSuite::M422_report(const bool forReplay/*=true*/) {
   #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
     LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
       report_echo_start(forReplay);
-      SERIAL_ECHOLNPAIR_P(
+      SERIAL_ECHOLNPGM_P(
         PSTR("  M422 W"), i + 1,
         SP_X_STR, z_stepper_align.stepper_xy[i].x,
         SP_Y_STR, z_stepper_align.stepper_xy[i].y

commit 79c72ed821564507b0ef46cbb26f9577585e2ccc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 7 18:06:10 2021 -0500

    üé® Standardize G-code reporting

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 50f3419c89..c5f5e582a9 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -475,21 +475,13 @@ void GcodeSuite::G34() {
  */
 void GcodeSuite::M422() {
 
+  if (!parser.seen_any()) return M422_report();
+
   if (parser.seen('R')) {
     z_stepper_align.reset_to_default();
     return;
   }
 
-  if (!parser.seen_any()) {
-    LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS)
-      SERIAL_ECHOLNPAIR_P(PSTR("M422 S"), i + 1, SP_X_STR, z_stepper_align.xy[i].x, SP_Y_STR, z_stepper_align.xy[i].y);
-    #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-      LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS)
-        SERIAL_ECHOLNPAIR_P(PSTR("M422 W"), i + 1, SP_X_STR, z_stepper_align.stepper_xy[i].x, SP_Y_STR, z_stepper_align.stepper_xy[i].y);
-    #endif
-    return;
-  }
-
   const bool is_probe_point = parser.seen('S');
 
   if (TERN0(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS, is_probe_point && parser.seen('W'))) {
@@ -545,4 +537,26 @@ void GcodeSuite::M422() {
   pos_dest[position_index] = pos;
 }
 
+void GcodeSuite::M422_report(const bool forReplay/*=true*/) {
+  report_heading(forReplay, PSTR(STR_Z_AUTO_ALIGN));
+  LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
+    report_echo_start(forReplay);
+    SERIAL_ECHOLNPAIR_P(
+      PSTR("  M422 S"), i + 1,
+      SP_X_STR, z_stepper_align.xy[i].x,
+      SP_Y_STR, z_stepper_align.xy[i].y
+    );
+  }
+  #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+    LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
+      report_echo_start(forReplay);
+      SERIAL_ECHOLNPAIR_P(
+        PSTR("  M422 W"), i + 1,
+        SP_X_STR, z_stepper_align.stepper_xy[i].x,
+        SP_Y_STR, z_stepper_align.stepper_xy[i].y
+      );
+    }
+  #endif
+}
+
 #endif // Z_STEPPER_AUTO_ALIGN

commit b2f0913083d83bd3fd9af1c603d1f4cc1afb64eb
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Tue Jul 6 17:36:41 2021 -0700

    üêõ Redundant Temp Sensor followup (#22196)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 6869962028..50f3419c89 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -314,11 +314,13 @@ void GcodeSuite::G34() {
           sprintf_P(msg,
             PSTR("1:2=%s" TERN_(TRIPLE_Z, " 3-2=%s 3-1=%s") TERN_(QUAD_Z, " 4-3=%s 4-2=%s 4-1=%s")),
             dtostrf(ABS(z_measured[1] - z_measured[0]), 1, 3, fstr1)
-            OPTARG(TRIPLE_Z, dtostrf(ABS(z_measured[2] - z_measured[1]), 1, 3, fstr2))
-            OPTARG(TRIPLE_Z, dtostrf(ABS(z_measured[2] - z_measured[0]), 1, 3, fstr3))
-            OPTARG(QUAD_Z,   dtostrf(ABS(z_measured[3] - z_measured[2]), 1, 3, fstr4))
-            OPTARG(QUAD_Z,   dtostrf(ABS(z_measured[3] - z_measured[1]), 1, 3, fstr5))
-            OPTARG(QUAD_Z,   dtostrf(ABS(z_measured[3] - z_measured[0]), 1, 3, fstr6))
+            OPTARG(TRIPLE_Z,
+              dtostrf(ABS(z_measured[2] - z_measured[1]), 1, 3, fstr2),
+              dtostrf(ABS(z_measured[2] - z_measured[0]), 1, 3, fstr3))
+            OPTARG(QUAD_Z,
+              dtostrf(ABS(z_measured[3] - z_measured[2]), 1, 3, fstr4),
+              dtostrf(ABS(z_measured[3] - z_measured[1]), 1, 3, fstr5),
+              dtostrf(ABS(z_measured[3] - z_measured[0]), 1, 3, fstr6))
           );
           ui.set_status(msg);
         #endif

commit 6bdd0fcda183068dcd8fe797a9a835765c3efe9e
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Mon Jun 14 23:52:42 2021 +0200

    ‚ö°Ô∏è Home Z (and maybe XY) at the start of G35 (#22060)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 1803933d16..6869962028 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -167,7 +167,7 @@ void GcodeSuite::G34() {
       ));
 
       // Home before the alignment procedure
-      if (!all_axes_trusted()) home_all_axes();
+      home_if_needed();
 
       // Move the Z coordinate realm towards the positive - dirty trick
       current_position.z += z_probe * 0.5f;

commit 53a82511ff04df00c6ad47e198da7e8ab9169b07
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 4 23:44:16 2021 -0500

    ‚ú® Update G34 for 4x Z steppers (#22039)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 1614dd6fbd..1803933d16 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -48,6 +48,13 @@
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
 
+#if NUM_Z_STEPPER_DRIVERS >= 3
+  #define TRIPLE_Z 1
+  #if NUM_Z_STEPPER_DRIVERS >= 4
+    #define QUAD_Z 1
+  #endif
+#endif
+
 /**
  * G34: Z-Stepper automatic alignment
  *
@@ -82,9 +89,9 @@ void GcodeSuite::G34() {
     switch (parser.intval('Z')) {
       case 1: stepper.set_z1_lock(state); break;
       case 2: stepper.set_z2_lock(state); break;
-      #if NUM_Z_STEPPER_DRIVERS >= 3
+      #if TRIPLE_Z
         case 3: stepper.set_z3_lock(state); break;
-        #if NUM_Z_STEPPER_DRIVERS >= 4
+        #if QUAD_Z
           case 4: stepper.set_z4_lock(state); break;
         #endif
       #endif
@@ -99,13 +106,6 @@ void GcodeSuite::G34() {
   #if ENABLED(Z_STEPPER_AUTO_ALIGN)
     do { // break out on error
 
-      #if NUM_Z_STEPPER_DRIVERS == 4
-        SERIAL_ECHOLNPGM("Alignment for 4 steppers is Experimental!");
-      #elif NUM_Z_STEPPER_DRIVERS > 4
-        SERIAL_ECHOLNPGM("Alignment not supported for over 4 steppers");
-        break;
-      #endif
-
       const int8_t z_auto_align_iterations = parser.intval('I', Z_STEPPER_ALIGN_ITERATIONS);
       if (!WITHIN(z_auto_align_iterations, 1, 30)) {
         SERIAL_ECHOLNPGM("?(I)teration out of bounds (1-30).");
@@ -157,16 +157,14 @@ void GcodeSuite::G34() {
         const xy_pos_t diff = z_stepper_align.xy[i] - z_stepper_align.xy[j];
         return HYPOT2(diff.x, diff.y);
       };
-      float z_probe = Z_BASIC_CLEARANCE + (G34_MAX_GRADE) * 0.01f * SQRT(
-        #if NUM_Z_STEPPER_DRIVERS == 3
-          _MAX(magnitude2(0, 1), magnitude2(1, 2), magnitude2(2, 0))
-        #elif NUM_Z_STEPPER_DRIVERS == 4
-          _MAX(magnitude2(0, 1), magnitude2(1, 2), magnitude2(2, 3),
-                magnitude2(3, 0), magnitude2(0, 2), magnitude2(1, 3))
-        #else
-          magnitude2(0, 1)
+      float z_probe = Z_BASIC_CLEARANCE + (G34_MAX_GRADE) * 0.01f * SQRT(_MAX(0, magnitude2(0, 1)
+        #if TRIPLE_Z
+          , magnitude2(2, 1), magnitude2(2, 0)
+          #if QUAD_Z
+            , magnitude2(3, 2), magnitude2(3, 1), magnitude2(3, 0)
+          #endif
         #endif
-      );
+      ));
 
       // Home before the alignment procedure
       if (!all_axes_trusted()) home_all_axes();
@@ -178,7 +176,7 @@ void GcodeSuite::G34() {
       // This hack is un-done at the end of G34 - either by re-homing, or by using the probed heights of the last iteration.
 
       #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-        float last_z_align_move[NUM_Z_STEPPER_DRIVERS] = ARRAY_N(NUM_Z_STEPPER_DRIVERS, 10000.0f, 10000.0f, 10000.0f, 10000.0f);
+        float last_z_align_move[NUM_Z_STEPPER_DRIVERS] = ARRAY_N_1(NUM_Z_STEPPER_DRIVERS, 10000.0f);
       #else
         float last_z_align_level_indicator = 10000.0f;
       #endif
@@ -280,39 +278,52 @@ void GcodeSuite::G34() {
             z_measured_min = _MIN(z_measured_min, z_measured[i]);
           }
 
-          SERIAL_ECHOLNPAIR("CALCULATED STEPPER POSITIONS: Z1=", z_measured[0], " Z2=", z_measured[1], " Z3=", z_measured[2]);
+          SERIAL_ECHOLNPAIR(
+            LIST_N(DOUBLE(NUM_Z_STEPPER_DRIVERS),
+              "Calculated Z1=", z_measured[0],
+                        " Z2=", z_measured[1],
+                        " Z3=", z_measured[2],
+                        " Z4=", z_measured[3]
+            )
+          );
         #endif
 
         SERIAL_ECHOLNPAIR("\n"
-          "DIFFERENCE Z1-Z2=", ABS(z_measured[0] - z_measured[1])
-          #if NUM_Z_STEPPER_DRIVERS == 3
-            , " Z2-Z3=", ABS(z_measured[1] - z_measured[2])
+          "Z2-Z1=", ABS(z_measured[1] - z_measured[0])
+          #if TRIPLE_Z
+            , " Z3-Z2=", ABS(z_measured[2] - z_measured[1])
             , " Z3-Z1=", ABS(z_measured[2] - z_measured[0])
+            #if QUAD_Z
+              , " Z4-Z3=", ABS(z_measured[3] - z_measured[2])
+              , " Z4-Z2=", ABS(z_measured[3] - z_measured[1])
+              , " Z4-Z1=", ABS(z_measured[3] - z_measured[0])
+            #endif
           #endif
         );
+
         #if HAS_STATUS_MESSAGE
           char fstr1[10];
-          #if NUM_Z_STEPPER_DRIVERS == 2
-            char msg[6 + (6 + 5) * 1 + 1];
-          #else
-            char msg[6 + (6 + 5) * 3 + 1], fstr2[10], fstr3[10];
-          #endif
-          sprintf_P(msg,
-            PSTR("Diffs Z1-Z2=%s"
-              #if NUM_Z_STEPPER_DRIVERS == 3
-                " Z2-Z3=%s"
-                " Z3-Z1=%s"
+          char msg[6 + (6 + 5) * NUM_Z_STEPPER_DRIVERS + 1]
+            #if TRIPLE_Z
+              , fstr2[10], fstr3[10]
+              #if QUAD_Z
+                , fstr4[10], fstr5[10], fstr6[10]
               #endif
-            ), dtostrf(ABS(z_measured[0] - z_measured[1]), 1, 3, fstr1)
-            #if NUM_Z_STEPPER_DRIVERS == 3
-              , dtostrf(ABS(z_measured[1] - z_measured[2]), 1, 3, fstr2)
-              , dtostrf(ABS(z_measured[2] - z_measured[0]), 1, 3, fstr3)
             #endif
+          ;
+          sprintf_P(msg,
+            PSTR("1:2=%s" TERN_(TRIPLE_Z, " 3-2=%s 3-1=%s") TERN_(QUAD_Z, " 4-3=%s 4-2=%s 4-1=%s")),
+            dtostrf(ABS(z_measured[1] - z_measured[0]), 1, 3, fstr1)
+            OPTARG(TRIPLE_Z, dtostrf(ABS(z_measured[2] - z_measured[1]), 1, 3, fstr2))
+            OPTARG(TRIPLE_Z, dtostrf(ABS(z_measured[2] - z_measured[0]), 1, 3, fstr3))
+            OPTARG(QUAD_Z,   dtostrf(ABS(z_measured[3] - z_measured[2]), 1, 3, fstr4))
+            OPTARG(QUAD_Z,   dtostrf(ABS(z_measured[3] - z_measured[1]), 1, 3, fstr5))
+            OPTARG(QUAD_Z,   dtostrf(ABS(z_measured[3] - z_measured[0]), 1, 3, fstr6))
           );
           ui.set_status(msg);
         #endif
 
-        auto decreasing_accuracy = [](const_float_t v1, const_float_t v2){
+        auto decreasing_accuracy = [](const_float_t v1, const_float_t v2) {
           if (v1 < v2 * 0.7f) {
             SERIAL_ECHOLNPGM("Decreasing Accuracy Detected.");
             LCD_MESSAGEPGM(MSG_DECREASING_ACCURACY);
@@ -437,7 +448,7 @@ void GcodeSuite::G34() {
       #endif
 
     }while(0);
-  #endif
+  #endif // Z_STEPPER_AUTO_ALIGN
 }
 
 #endif // Z_MULTI_ENDSTOPS || Z_STEPPER_AUTO_ALIGN

commit 528b9bd8729656d7ebcd3dc7898ceddc2f377354
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 16 02:43:59 2021 -0500

    Revert experimental NAN patch
    
    Hold changes from #21575 (24a095c) for more testing.

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 959d0f9c09..1614dd6fbd 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -229,7 +229,7 @@ void GcodeSuite::G34() {
           // Probing sanity check is disabled, as it would trigger even in normal cases because
           // current_position.z has been manually altered in the "dirty trick" above.
           const float z_probed_height = probe.probe_at_point(z_stepper_align.xy[iprobe], raise_after, 0, true, false);
-          if (ISNAN(z_probed_height)) {
+          if (isnan(z_probed_height)) {
             SERIAL_ECHOLNPGM("Probing failed");
             LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
             err_break = true;

commit 24a095c5c14b60bcbffc2807d2c8cc8e9af46e90
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 12 16:49:53 2021 -0500

    Reduce math library code size by 3.4KB (#21575)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 1614dd6fbd..959d0f9c09 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -229,7 +229,7 @@ void GcodeSuite::G34() {
           // Probing sanity check is disabled, as it would trigger even in normal cases because
           // current_position.z has been manually altered in the "dirty trick" above.
           const float z_probed_height = probe.probe_at_point(z_stepper_align.xy[iprobe], raise_after, 0, true, false);
-          if (isnan(z_probed_height)) {
+          if (ISNAN(z_probed_height)) {
             SERIAL_ECHOLNPGM("Probing failed");
             LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
             err_break = true;

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index a97283b3e7..1614dd6fbd 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -312,7 +312,7 @@ void GcodeSuite::G34() {
           ui.set_status(msg);
         #endif
 
-        auto decreasing_accuracy = [](const float &v1, const float &v2){
+        auto decreasing_accuracy = [](const_float_t v1, const_float_t v2){
           if (v1 < v2 * 0.7f) {
             SERIAL_ECHOLNPGM("Decreasing Accuracy Detected.");
             LCD_MESSAGEPGM(MSG_DECREASING_ACCURACY);

commit 930752d46e6aacb484ea89dacae6baf823d78d62
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Wed Mar 24 10:12:57 2021 -0500

    Ender 3 V2 Status Line (#21369)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index d2075fedce..a97283b3e7 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -190,7 +190,7 @@ void GcodeSuite::G34() {
         bool adjustment_reverse = false;
       #endif
 
-      #if HAS_DISPLAY
+      #if HAS_STATUS_MESSAGE
         PGM_P const msg_iteration = GET_TEXT(MSG_ITERATION);
         const uint8_t iter_str_len = strlen_P(msg_iteration);
       #endif
@@ -204,7 +204,7 @@ void GcodeSuite::G34() {
 
         const int iter = iteration + 1;
         SERIAL_ECHOLNPAIR("\nG34 Iteration: ", iter);
-        #if HAS_DISPLAY
+        #if HAS_STATUS_MESSAGE
           char str[iter_str_len + 2 + 1];
           sprintf_P(str, msg_iteration, iter);
           ui.set_status(str);
@@ -290,7 +290,7 @@ void GcodeSuite::G34() {
             , " Z3-Z1=", ABS(z_measured[2] - z_measured[0])
           #endif
         );
-        #if HAS_DISPLAY
+        #if HAS_STATUS_MESSAGE
           char fstr1[10];
           #if NUM_Z_STEPPER_DRIVERS == 2
             char msg[6 + (6 + 5) * 1 + 1];

commit 2d2291d00eab6159de24eb7ff74001b1d6dd29e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 24 05:40:28 2021 -0500

    More IntelliSense-friendly declarations

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index bee6aaedeb..d2075fedce 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -130,7 +130,9 @@ void GcodeSuite::G34() {
 
       // Disable the leveling matrix before auto-aligning
       #if HAS_LEVELING
-        TERN_(RESTORE_LEVELING_AFTER_G34, const bool leveling_was_active = planner.leveling_active);
+        #if ENABLED(RESTORE_LEVELING_AFTER_G34)
+          const bool leveling_was_active = planner.leveling_active;
+        #endif
         set_bed_leveling_enabled(false);
       #endif
 

commit 8c512191b2f3c3c937ce12da25b8203b464dfc6d
Author: Cal1sto <47449942+Cal1sto@users.noreply.github.com>
Date:   Wed Mar 10 21:37:22 2021 +0100

    Fix TouchMI stow in G34 (#21291)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 50476e8e7c..bee6aaedeb 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -410,9 +410,9 @@ void GcodeSuite::G34() {
         SERIAL_ECHOLNPAIR_F("Accuracy: ", z_maxdiff);
       }
 
-      // Stow the probe, as the last call to probe.probe_at_point(...) left
-      // the probe deployed if it was successful.
-      probe.stow();
+      // Stow the probe because the last call to probe.probe_at_point(...)
+      // leaves the probe deployed when it's successful.
+      IF_DISABLED(TOUCH_MI_PROBE, probe.stow());
 
       #if ENABLED(HOME_AFTER_G34)
         // After this operation the z position needs correction

commit e7c711996bd3080f5e343eff5556736cbf2e2416
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 8 07:37:24 2021 +0100

    Serial refactor. Default 8-bit ECHO to int, not char (#20985)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 0bcf954faf..50476e8e7c 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -238,7 +238,7 @@ void GcodeSuite::G34() {
           // the next iteration of probing. This allows adjustments to be made away from the bed.
           z_measured[iprobe] = z_probed_height + Z_CLEARANCE_BETWEEN_PROBES;
 
-          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(iprobe + 1), " measured position is ", z_measured[iprobe]);
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", iprobe + 1, " measured position is ", z_measured[iprobe]);
 
           // Remember the minimum measurement to calculate the correction later on
           z_measured_min = _MIN(z_measured_min, z_measured[iprobe]);
@@ -267,7 +267,7 @@ void GcodeSuite::G34() {
           linear_fit_data lfd;
           incremental_LSF_reset(&lfd);
           LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
-            SERIAL_ECHOLNPAIR("PROBEPT_", int(i), ": ", z_measured[i]);
+            SERIAL_ECHOLNPAIR("PROBEPT_", i, ": ", z_measured[i]);
             incremental_LSF(&lfd, z_stepper_align.xy[i], z_measured[i]);
           }
           finish_incremental_LSF(&lfd);
@@ -357,8 +357,8 @@ void GcodeSuite::G34() {
 
             // Check for less accuracy compared to last move
             if (decreasing_accuracy(last_z_align_move[zstepper], z_align_abs)) {
-              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " last_z_align_move = ", last_z_align_move[zstepper]);
-              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " z_align_abs = ", z_align_abs);
+              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", zstepper + 1, " last_z_align_move = ", last_z_align_move[zstepper]);
+              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", zstepper + 1, " z_align_abs = ", z_align_abs);
               adjustment_reverse = !adjustment_reverse;
             }
 
@@ -370,7 +370,7 @@ void GcodeSuite::G34() {
           // Stop early if all measured points achieve accuracy target
           if (z_align_abs > z_auto_align_accuracy) success_break = false;
 
-          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " corrected by ", z_align_move);
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", zstepper + 1, " corrected by ", z_align_move);
 
           // Lock all steppers except one
           stepper.set_all_z_lock(true, zstepper);
@@ -380,7 +380,7 @@ void GcodeSuite::G34() {
             // Will match reversed Z steppers on dual steppers. Triple will need more work to map.
             if (adjustment_reverse) {
               z_align_move = -z_align_move;
-              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " correction reversed to ", z_align_move);
+              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", zstepper + 1, " correction reversed to ", z_align_move);
             }
           #endif
 
@@ -406,7 +406,7 @@ void GcodeSuite::G34() {
       if (err_break)
         SERIAL_ECHOLNPGM("G34 aborted.");
       else {
-        SERIAL_ECHOLNPAIR("Did ", int(iteration + (iteration != z_auto_align_iterations)), " of ", int(z_auto_align_iterations));
+        SERIAL_ECHOLNPAIR("Did ", iteration + (iteration != z_auto_align_iterations), " of ", z_auto_align_iterations);
         SERIAL_ECHOLNPAIR_F("Accuracy: ", z_maxdiff);
       }
 
@@ -467,10 +467,10 @@ void GcodeSuite::M422() {
 
   if (!parser.seen_any()) {
     LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS)
-      SERIAL_ECHOLNPAIR_P(PSTR("M422 S"), int(i + 1), SP_X_STR, z_stepper_align.xy[i].x, SP_Y_STR, z_stepper_align.xy[i].y);
+      SERIAL_ECHOLNPAIR_P(PSTR("M422 S"), i + 1, SP_X_STR, z_stepper_align.xy[i].x, SP_Y_STR, z_stepper_align.xy[i].y);
     #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
       LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS)
-        SERIAL_ECHOLNPAIR_P(PSTR("M422 W"), int(i + 1), SP_X_STR, z_stepper_align.stepper_xy[i].x, SP_Y_STR, z_stepper_align.stepper_xy[i].y);
+        SERIAL_ECHOLNPAIR_P(PSTR("M422 W"), i + 1, SP_X_STR, z_stepper_align.stepper_xy[i].x, SP_Y_STR, z_stepper_align.stepper_xy[i].y);
     #endif
     return;
   }

commit 208200a3ccd4e4d4b22569459a4785de7af5406b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 4 17:51:46 2021 -0600

    G34/M422 cleanup

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 840d04f29e..0bcf954faf 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -320,7 +320,6 @@ void GcodeSuite::G34() {
         };
 
         #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-
           // Check if the applied corrections go in the correct direction.
           // Calculate the sum of the absolute deviations from the mean of the probe measurements.
           // Compare to the last iteration to ensure it's getting better.
@@ -478,32 +477,18 @@ void GcodeSuite::M422() {
 
   const bool is_probe_point = parser.seen('S');
 
-  #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-    if (is_probe_point && parser.seen('W')) {
-      SERIAL_ECHOLNPGM("?(S) and (W) may not be combined.");
-      return;
-    }
-  #endif
+  if (TERN0(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS, is_probe_point && parser.seen('W'))) {
+    SERIAL_ECHOLNPGM("?(S) and (W) may not be combined.");
+    return;
+  }
 
   xy_pos_t *pos_dest = (
-    #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-      !is_probe_point ? z_stepper_align.stepper_xy :
-    #endif
+    TERN_(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS, !is_probe_point ? z_stepper_align.stepper_xy :)
     z_stepper_align.xy
   );
 
-  if (!is_probe_point
-    #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-      && !parser.seen('W')
-    #endif
-  ) {
-    SERIAL_ECHOLNPGM(
-      #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-        "?(S) or (W) is required."
-      #else
-        "?(S) is required."
-      #endif
-    );
+  if (!is_probe_point && TERN1(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS, !parser.seen('W'))) {
+    SERIAL_ECHOLNPGM("?(S)" TERN_(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS, " or (W)") " is required.");
     return;
   }
 
@@ -512,7 +497,7 @@ void GcodeSuite::M422() {
   if (is_probe_point) {
     position_index = parser.intval('S') - 1;
     if (!WITHIN(position_index, 0, int8_t(NUM_Z_STEPPER_DRIVERS) - 1)) {
-      SERIAL_ECHOLNPGM("?(S) Z-ProbePosition index invalid.");
+      SERIAL_ECHOLNPGM("?(S) Probe-position index invalid.");
       return;
     }
   }
@@ -520,7 +505,7 @@ void GcodeSuite::M422() {
     #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
       position_index = parser.intval('W') - 1;
       if (!WITHIN(position_index, 0, NUM_Z_STEPPER_DRIVERS - 1)) {
-        SERIAL_ECHOLNPGM("?(W) Z-Stepper index invalid.");
+        SERIAL_ECHOLNPGM("?(W) Z-stepper index invalid.");
         return;
       }
     #endif

commit 8fd8772a6fffe63d99d0b88aec7a77d283df8584
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 29 19:06:40 2020 -0600

    Adjust axis homed / trusted methods (#20323)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 8d3dd0d06b..840d04f29e 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -167,7 +167,7 @@ void GcodeSuite::G34() {
       );
 
       // Home before the alignment procedure
-      if (!all_axes_known()) home_all_axes();
+      if (!all_axes_trusted()) home_all_axes();
 
       // Move the Z coordinate realm towards the positive - dirty trick
       current_position.z += z_probe * 0.5f;

commit 1b0a5abd73d162b68b2881486630f60a1e9e7825
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Nov 12 23:54:18 2020 -0500

    G34 Z stepper locking (#20091)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 5e1ec5b961..8d3dd0d06b 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -22,7 +22,7 @@
 
 #include "../../inc/MarlinConfigPre.h"
 
-#if ENABLED(Z_STEPPER_AUTO_ALIGN)
+#if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
 
 #include "../../feature/z_stepper_align.h"
 
@@ -51,364 +51,398 @@
 /**
  * G34: Z-Stepper automatic alignment
  *
- *   I<iterations>
- *   T<accuracy>
- *   A<amplification>
- *   R<recalculate> points based on current probe offsets
+ * Manual stepper lock controls (reset by G28):
+ *   L                 Unlock all steppers
+ *   Z<1-4>            Z stepper to lock / unlock
+ *   S<state>          0=UNLOCKED 1=LOCKED. If omitted, assume LOCKED.
+ *
+ *   Examples:
+ *     G34 Z1     ; Lock Z1
+ *     G34 L Z2   ; Unlock all, then lock Z2
+ *     G34 Z2 S0  ; Unlock Z2
+ *
+ * With Z_STEPPER_AUTO_ALIGN:
+ *   I<iterations>     Number of tests. If omitted, Z_STEPPER_ALIGN_ITERATIONS.
+ *   T<accuracy>       Target Accuracy factor. If omitted, Z_STEPPER_ALIGN_ACC.
+ *   A<amplification>  Provide an Amplification value. If omitted, Z_STEPPER_ALIGN_AMP.
+ *   R                 Flag to recalculate points based on current probe offsets
  */
 void GcodeSuite::G34() {
   DEBUG_SECTION(log_G34, "G34", DEBUGGING(LEVELING));
   if (DEBUGGING(LEVELING)) log_machine_info();
 
-  do { // break out on error
-
-    #if NUM_Z_STEPPER_DRIVERS == 4
-      SERIAL_ECHOLNPGM("Alignment for 4 steppers is Experimental!");
-    #elif NUM_Z_STEPPER_DRIVERS > 4
-      SERIAL_ECHOLNPGM("Alignment not supported for over 4 steppers");
-      break;
-    #endif
-
-    const int8_t z_auto_align_iterations = parser.intval('I', Z_STEPPER_ALIGN_ITERATIONS);
-    if (!WITHIN(z_auto_align_iterations, 1, 30)) {
-      SERIAL_ECHOLNPGM("?(I)teration out of bounds (1-30).");
-      break;
+  planner.synchronize();  // Prevent damage
+
+  const bool seenL = parser.seen('L');
+  if (seenL) stepper.set_all_z_lock(false);
+
+  const bool seenZ = parser.seenval('Z');
+  if (seenZ) {
+    const bool state = parser.boolval('S', true);
+    switch (parser.intval('Z')) {
+      case 1: stepper.set_z1_lock(state); break;
+      case 2: stepper.set_z2_lock(state); break;
+      #if NUM_Z_STEPPER_DRIVERS >= 3
+        case 3: stepper.set_z3_lock(state); break;
+        #if NUM_Z_STEPPER_DRIVERS >= 4
+          case 4: stepper.set_z4_lock(state); break;
+        #endif
+      #endif
     }
+  }
 
-    const float z_auto_align_accuracy = parser.floatval('T', Z_STEPPER_ALIGN_ACC);
-    if (!WITHIN(z_auto_align_accuracy, 0.01f, 1.0f)) {
-      SERIAL_ECHOLNPGM("?(T)arget accuracy out of bounds (0.01-1.0).");
-      break;
-    }
+  if (seenL || seenZ) {
+    stepper.set_separate_multi_axis(seenZ);
+    return;
+  }
 
-    const float z_auto_align_amplification =
-      #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-        Z_STEPPER_ALIGN_AMP;
-      #else
-        parser.floatval('A', Z_STEPPER_ALIGN_AMP);
-        if (!WITHIN(ABS(z_auto_align_amplification), 0.5f, 2.0f)) {
-          SERIAL_ECHOLNPGM("?(A)mplification out of bounds (0.5-2.0).");
-          break;
-        }
+  #if ENABLED(Z_STEPPER_AUTO_ALIGN)
+    do { // break out on error
+
+      #if NUM_Z_STEPPER_DRIVERS == 4
+        SERIAL_ECHOLNPGM("Alignment for 4 steppers is Experimental!");
+      #elif NUM_Z_STEPPER_DRIVERS > 4
+        SERIAL_ECHOLNPGM("Alignment not supported for over 4 steppers");
+        break;
       #endif
 
-    if (parser.seen('R')) z_stepper_align.reset_to_default();
+      const int8_t z_auto_align_iterations = parser.intval('I', Z_STEPPER_ALIGN_ITERATIONS);
+      if (!WITHIN(z_auto_align_iterations, 1, 30)) {
+        SERIAL_ECHOLNPGM("?(I)teration out of bounds (1-30).");
+        break;
+      }
 
-    const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
+      const float z_auto_align_accuracy = parser.floatval('T', Z_STEPPER_ALIGN_ACC);
+      if (!WITHIN(z_auto_align_accuracy, 0.01f, 1.0f)) {
+        SERIAL_ECHOLNPGM("?(T)arget accuracy out of bounds (0.01-1.0).");
+        break;
+      }
 
-    // Wait for planner moves to finish!
-    planner.synchronize();
+      const float z_auto_align_amplification = TERN(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS, Z_STEPPER_ALIGN_AMP, parser.floatval('A', Z_STEPPER_ALIGN_AMP));
+      if (!WITHIN(ABS(z_auto_align_amplification), 0.5f, 2.0f)) {
+        SERIAL_ECHOLNPGM("?(A)mplification out of bounds (0.5-2.0).");
+        break;
+      }
 
-    // Disable the leveling matrix before auto-aligning
-    #if HAS_LEVELING
-      TERN_(RESTORE_LEVELING_AFTER_G34, const bool leveling_was_active = planner.leveling_active);
-      set_bed_leveling_enabled(false);
-    #endif
+      if (parser.seen('R')) z_stepper_align.reset_to_default();
 
-    TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
+      const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
 
-    // Always home with tool 0 active
-    #if HAS_MULTI_HOTEND
-      const uint8_t old_tool_index = active_extruder;
-      tool_change(0, true);
-    #endif
+      // Disable the leveling matrix before auto-aligning
+      #if HAS_LEVELING
+        TERN_(RESTORE_LEVELING_AFTER_G34, const bool leveling_was_active = planner.leveling_active);
+        set_bed_leveling_enabled(false);
+      #endif
 
-    TERN_(HAS_DUPLICATION_MODE, set_duplication_enabled(false));
-
-    // In BLTOUCH HS mode, the probe travels in a deployed state.
-    // Users of G34 might have a badly misaligned bed, so raise Z by the
-    // length of the deployed pin (BLTOUCH stroke < 7mm)
-    #define Z_BASIC_CLEARANCE (Z_CLEARANCE_BETWEEN_PROBES + 7.0f * BOTH(BLTOUCH, BLTOUCH_HS_MODE))
-
-    // Compute a worst-case clearance height to probe from. After the first
-    // iteration this will be re-calculated based on the actual bed position
-    auto magnitude2 = [&](const uint8_t i, const uint8_t j) {
-      const xy_pos_t diff = z_stepper_align.xy[i] - z_stepper_align.xy[j];
-      return HYPOT2(diff.x, diff.y);
-    };
-    float z_probe = Z_BASIC_CLEARANCE + (G34_MAX_GRADE) * 0.01f * SQRT(
-      #if NUM_Z_STEPPER_DRIVERS == 3
-         _MAX(magnitude2(0, 1), magnitude2(1, 2), magnitude2(2, 0))
-      #elif NUM_Z_STEPPER_DRIVERS == 4
-         _MAX(magnitude2(0, 1), magnitude2(1, 2), magnitude2(2, 3),
-              magnitude2(3, 0), magnitude2(0, 2), magnitude2(1, 3))
-      #else
-         magnitude2(0, 1)
+      TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
+
+      // Always home with tool 0 active
+      #if HAS_MULTI_HOTEND
+        const uint8_t old_tool_index = active_extruder;
+        tool_change(0, true);
       #endif
-    );
 
-    // Home before the alignment procedure
-    if (!all_axes_known()) home_all_axes();
+      TERN_(HAS_DUPLICATION_MODE, set_duplication_enabled(false));
 
-    // Move the Z coordinate realm towards the positive - dirty trick
-    current_position.z += z_probe * 0.5f;
-    sync_plan_position();
-    // Now, the Z origin lies below the build plate. That allows to probe deeper, before run_z_probe throws an error.
-    // This hack is un-done at the end of G34 - either by re-homing, or by using the probed heights of the last iteration.
+      // In BLTOUCH HS mode, the probe travels in a deployed state.
+      // Users of G34 might have a badly misaligned bed, so raise Z by the
+      // length of the deployed pin (BLTOUCH stroke < 7mm)
+      #define Z_BASIC_CLEARANCE (Z_CLEARANCE_BETWEEN_PROBES + 7.0f * BOTH(BLTOUCH, BLTOUCH_HS_MODE))
 
-    #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-      float last_z_align_move[NUM_Z_STEPPER_DRIVERS] = ARRAY_N(NUM_Z_STEPPER_DRIVERS, 10000.0f, 10000.0f, 10000.0f, 10000.0f);
-    #else
-      float last_z_align_level_indicator = 10000.0f;
-    #endif
-    float z_measured[NUM_Z_STEPPER_DRIVERS] = { 0 },
-          z_maxdiff = 0.0f,
-          amplification = z_auto_align_amplification;
+      // Compute a worst-case clearance height to probe from. After the first
+      // iteration this will be re-calculated based on the actual bed position
+      auto magnitude2 = [&](const uint8_t i, const uint8_t j) {
+        const xy_pos_t diff = z_stepper_align.xy[i] - z_stepper_align.xy[j];
+        return HYPOT2(diff.x, diff.y);
+      };
+      float z_probe = Z_BASIC_CLEARANCE + (G34_MAX_GRADE) * 0.01f * SQRT(
+        #if NUM_Z_STEPPER_DRIVERS == 3
+          _MAX(magnitude2(0, 1), magnitude2(1, 2), magnitude2(2, 0))
+        #elif NUM_Z_STEPPER_DRIVERS == 4
+          _MAX(magnitude2(0, 1), magnitude2(1, 2), magnitude2(2, 3),
+                magnitude2(3, 0), magnitude2(0, 2), magnitude2(1, 3))
+        #else
+          magnitude2(0, 1)
+        #endif
+      );
 
-    #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-      bool adjustment_reverse = false;
-    #endif
+      // Home before the alignment procedure
+      if (!all_axes_known()) home_all_axes();
 
-    #if HAS_DISPLAY
-      PGM_P const msg_iteration = GET_TEXT(MSG_ITERATION);
-      const uint8_t iter_str_len = strlen_P(msg_iteration);
-    #endif
+      // Move the Z coordinate realm towards the positive - dirty trick
+      current_position.z += z_probe * 0.5f;
+      sync_plan_position();
+      // Now, the Z origin lies below the build plate. That allows to probe deeper, before run_z_probe throws an error.
+      // This hack is un-done at the end of G34 - either by re-homing, or by using the probed heights of the last iteration.
+
+      #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+        float last_z_align_move[NUM_Z_STEPPER_DRIVERS] = ARRAY_N(NUM_Z_STEPPER_DRIVERS, 10000.0f, 10000.0f, 10000.0f, 10000.0f);
+      #else
+        float last_z_align_level_indicator = 10000.0f;
+      #endif
+      float z_measured[NUM_Z_STEPPER_DRIVERS] = { 0 },
+            z_maxdiff = 0.0f,
+            amplification = z_auto_align_amplification;
 
-    // Final z and iteration values will be used after breaking the loop
-    float z_measured_min;
-    uint8_t iteration = 0;
-    bool err_break = false; // To break out of nested loops
-    while (iteration < z_auto_align_iterations) {
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> probing all positions.");
+      #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+        bool adjustment_reverse = false;
+      #endif
 
-      const int iter = iteration + 1;
-      SERIAL_ECHOLNPAIR("\nG34 Iteration: ", iter);
       #if HAS_DISPLAY
-        char str[iter_str_len + 2 + 1];
-        sprintf_P(str, msg_iteration, iter);
-        ui.set_status(str);
+        PGM_P const msg_iteration = GET_TEXT(MSG_ITERATION);
+        const uint8_t iter_str_len = strlen_P(msg_iteration);
       #endif
 
-      // Initialize minimum value
-      z_measured_min =  100000.0f;
-      float z_measured_max = -100000.0f;
-
-      // Probe all positions (one per Z-Stepper)
-      LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
-        // iteration odd/even --> downward / upward stepper sequence
-        const uint8_t iprobe = (iteration & 1) ? NUM_Z_STEPPER_DRIVERS - 1 - i : i;
-
-        // Safe clearance even on an incline
-        if ((iteration == 0 || i > 0) && z_probe > current_position.z) do_blocking_move_to_z(z_probe);
-
-        if (DEBUGGING(LEVELING))
-          DEBUG_ECHOLNPAIR_P(PSTR("Probing X"), z_stepper_align.xy[iprobe].x, SP_Y_STR, z_stepper_align.xy[iprobe].y);
-
-        // Probe a Z height for each stepper.
-        // Probing sanity check is disabled, as it would trigger even in normal cases because
-        // current_position.z has been manually altered in the "dirty trick" above.
-        const float z_probed_height = probe.probe_at_point(z_stepper_align.xy[iprobe], raise_after, 0, true, false);
-        if (isnan(z_probed_height)) {
-          SERIAL_ECHOLNPGM("Probing failed");
-          LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
-          err_break = true;
-          break;
-        }
+      // Final z and iteration values will be used after breaking the loop
+      float z_measured_min;
+      uint8_t iteration = 0;
+      bool err_break = false; // To break out of nested loops
+      while (iteration < z_auto_align_iterations) {
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> probing all positions.");
+
+        const int iter = iteration + 1;
+        SERIAL_ECHOLNPAIR("\nG34 Iteration: ", iter);
+        #if HAS_DISPLAY
+          char str[iter_str_len + 2 + 1];
+          sprintf_P(str, msg_iteration, iter);
+          ui.set_status(str);
+        #endif
 
-        // Add height to each value, to provide a more useful target height for
-        // the next iteration of probing. This allows adjustments to be made away from the bed.
-        z_measured[iprobe] = z_probed_height + Z_CLEARANCE_BETWEEN_PROBES;
+        // Initialize minimum value
+        z_measured_min =  100000.0f;
+        float z_measured_max = -100000.0f;
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(iprobe + 1), " measured position is ", z_measured[iprobe]);
+        // Probe all positions (one per Z-Stepper)
+        LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
+          // iteration odd/even --> downward / upward stepper sequence
+          const uint8_t iprobe = (iteration & 1) ? NUM_Z_STEPPER_DRIVERS - 1 - i : i;
+
+          // Safe clearance even on an incline
+          if ((iteration == 0 || i > 0) && z_probe > current_position.z) do_blocking_move_to_z(z_probe);
+
+          if (DEBUGGING(LEVELING))
+            DEBUG_ECHOLNPAIR_P(PSTR("Probing X"), z_stepper_align.xy[iprobe].x, SP_Y_STR, z_stepper_align.xy[iprobe].y);
+
+          // Probe a Z height for each stepper.
+          // Probing sanity check is disabled, as it would trigger even in normal cases because
+          // current_position.z has been manually altered in the "dirty trick" above.
+          const float z_probed_height = probe.probe_at_point(z_stepper_align.xy[iprobe], raise_after, 0, true, false);
+          if (isnan(z_probed_height)) {
+            SERIAL_ECHOLNPGM("Probing failed");
+            LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
+            err_break = true;
+            break;
+          }
 
-        // Remember the minimum measurement to calculate the correction later on
-        z_measured_min = _MIN(z_measured_min, z_measured[iprobe]);
-        z_measured_max = _MAX(z_measured_max, z_measured[iprobe]);
-      } // for (i)
+          // Add height to each value, to provide a more useful target height for
+          // the next iteration of probing. This allows adjustments to be made away from the bed.
+          z_measured[iprobe] = z_probed_height + Z_CLEARANCE_BETWEEN_PROBES;
 
-      if (err_break) break;
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(iprobe + 1), " measured position is ", z_measured[iprobe]);
 
-      // Adapt the next probe clearance height based on the new measurements.
-      // Safe_height = lowest distance to bed (= highest measurement) plus highest measured misalignment.
-      z_maxdiff = z_measured_max - z_measured_min;
-      z_probe = Z_BASIC_CLEARANCE + z_measured_max + z_maxdiff;
+          // Remember the minimum measurement to calculate the correction later on
+          z_measured_min = _MIN(z_measured_min, z_measured[iprobe]);
+          z_measured_max = _MAX(z_measured_max, z_measured[iprobe]);
+        } // for (i)
 
-      #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-        // Replace the initial values in z_measured with calculated heights at
-        // each stepper position. This allows the adjustment algorithm to be
-        // shared between both possible probing mechanisms.
-
-        // This must be done after the next z_probe height is calculated, so that
-        // the height is calculated from actual print area positions, and not
-        // extrapolated motor movements.
-
-        // Compute the least-squares fit for all probed points.
-        // Calculate the Z position of each stepper and store it in z_measured.
-        // This allows the actual adjustment logic to be shared by both algorithms.
-        linear_fit_data lfd;
-        incremental_LSF_reset(&lfd);
-        LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
-          SERIAL_ECHOLNPAIR("PROBEPT_", int(i), ": ", z_measured[i]);
-          incremental_LSF(&lfd, z_stepper_align.xy[i], z_measured[i]);
-        }
-        finish_incremental_LSF(&lfd);
+        if (err_break) break;
 
-        z_measured_min = 100000.0f;
-        LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
-          z_measured[i] = -(lfd.A * z_stepper_align.stepper_xy[i].x + lfd.B * z_stepper_align.stepper_xy[i].y + lfd.D);
-          z_measured_min = _MIN(z_measured_min, z_measured[i]);
-        }
+        // Adapt the next probe clearance height based on the new measurements.
+        // Safe_height = lowest distance to bed (= highest measurement) plus highest measured misalignment.
+        z_maxdiff = z_measured_max - z_measured_min;
+        z_probe = Z_BASIC_CLEARANCE + z_measured_max + z_maxdiff;
+
+        #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+          // Replace the initial values in z_measured with calculated heights at
+          // each stepper position. This allows the adjustment algorithm to be
+          // shared between both possible probing mechanisms.
+
+          // This must be done after the next z_probe height is calculated, so that
+          // the height is calculated from actual print area positions, and not
+          // extrapolated motor movements.
+
+          // Compute the least-squares fit for all probed points.
+          // Calculate the Z position of each stepper and store it in z_measured.
+          // This allows the actual adjustment logic to be shared by both algorithms.
+          linear_fit_data lfd;
+          incremental_LSF_reset(&lfd);
+          LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
+            SERIAL_ECHOLNPAIR("PROBEPT_", int(i), ": ", z_measured[i]);
+            incremental_LSF(&lfd, z_stepper_align.xy[i], z_measured[i]);
+          }
+          finish_incremental_LSF(&lfd);
 
-        SERIAL_ECHOLNPAIR("CALCULATED STEPPER POSITIONS: Z1=", z_measured[0], " Z2=", z_measured[1], " Z3=", z_measured[2]);
-      #endif
+          z_measured_min = 100000.0f;
+          LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
+            z_measured[i] = -(lfd.A * z_stepper_align.stepper_xy[i].x + lfd.B * z_stepper_align.stepper_xy[i].y + lfd.D);
+            z_measured_min = _MIN(z_measured_min, z_measured[i]);
+          }
 
-      SERIAL_ECHOLNPAIR("\n"
-        "DIFFERENCE Z1-Z2=", ABS(z_measured[0] - z_measured[1])
-        #if NUM_Z_STEPPER_DRIVERS == 3
-          , " Z2-Z3=", ABS(z_measured[1] - z_measured[2])
-          , " Z3-Z1=", ABS(z_measured[2] - z_measured[0])
-        #endif
-      );
-      #if HAS_DISPLAY
-        char fstr1[10];
-        #if NUM_Z_STEPPER_DRIVERS == 2
-          char msg[6 + (6 + 5) * 1 + 1];
-        #else
-          char msg[6 + (6 + 5) * 3 + 1], fstr2[10], fstr3[10];
+          SERIAL_ECHOLNPAIR("CALCULATED STEPPER POSITIONS: Z1=", z_measured[0], " Z2=", z_measured[1], " Z3=", z_measured[2]);
         #endif
-        sprintf_P(msg,
-          PSTR("Diffs Z1-Z2=%s"
-            #if NUM_Z_STEPPER_DRIVERS == 3
-              " Z2-Z3=%s"
-              " Z3-Z1=%s"
-            #endif
-          ), dtostrf(ABS(z_measured[0] - z_measured[1]), 1, 3, fstr1)
+
+        SERIAL_ECHOLNPAIR("\n"
+          "DIFFERENCE Z1-Z2=", ABS(z_measured[0] - z_measured[1])
           #if NUM_Z_STEPPER_DRIVERS == 3
-            , dtostrf(ABS(z_measured[1] - z_measured[2]), 1, 3, fstr2)
-            , dtostrf(ABS(z_measured[2] - z_measured[0]), 1, 3, fstr3)
+            , " Z2-Z3=", ABS(z_measured[1] - z_measured[2])
+            , " Z3-Z1=", ABS(z_measured[2] - z_measured[0])
           #endif
         );
-        ui.set_status(msg);
-      #endif
+        #if HAS_DISPLAY
+          char fstr1[10];
+          #if NUM_Z_STEPPER_DRIVERS == 2
+            char msg[6 + (6 + 5) * 1 + 1];
+          #else
+            char msg[6 + (6 + 5) * 3 + 1], fstr2[10], fstr3[10];
+          #endif
+          sprintf_P(msg,
+            PSTR("Diffs Z1-Z2=%s"
+              #if NUM_Z_STEPPER_DRIVERS == 3
+                " Z2-Z3=%s"
+                " Z3-Z1=%s"
+              #endif
+            ), dtostrf(ABS(z_measured[0] - z_measured[1]), 1, 3, fstr1)
+            #if NUM_Z_STEPPER_DRIVERS == 3
+              , dtostrf(ABS(z_measured[1] - z_measured[2]), 1, 3, fstr2)
+              , dtostrf(ABS(z_measured[2] - z_measured[0]), 1, 3, fstr3)
+            #endif
+          );
+          ui.set_status(msg);
+        #endif
 
-      auto decreasing_accuracy = [](const float &v1, const float &v2){
-        if (v1 < v2 * 0.7f) {
-          SERIAL_ECHOLNPGM("Decreasing Accuracy Detected.");
-          LCD_MESSAGEPGM(MSG_DECREASING_ACCURACY);
-          return true;
-        }
-        return false;
-      };
+        auto decreasing_accuracy = [](const float &v1, const float &v2){
+          if (v1 < v2 * 0.7f) {
+            SERIAL_ECHOLNPGM("Decreasing Accuracy Detected.");
+            LCD_MESSAGEPGM(MSG_DECREASING_ACCURACY);
+            return true;
+          }
+          return false;
+        };
 
-      #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+        #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
 
-        // Check if the applied corrections go in the correct direction.
-        // Calculate the sum of the absolute deviations from the mean of the probe measurements.
-        // Compare to the last iteration to ensure it's getting better.
+          // Check if the applied corrections go in the correct direction.
+          // Calculate the sum of the absolute deviations from the mean of the probe measurements.
+          // Compare to the last iteration to ensure it's getting better.
 
-        // Calculate mean value as a reference
-        float z_measured_mean = 0.0f;
-        LOOP_L_N(zstepper, NUM_Z_STEPPER_DRIVERS) z_measured_mean += z_measured[zstepper];
-        z_measured_mean /= NUM_Z_STEPPER_DRIVERS;
+          // Calculate mean value as a reference
+          float z_measured_mean = 0.0f;
+          LOOP_L_N(zstepper, NUM_Z_STEPPER_DRIVERS) z_measured_mean += z_measured[zstepper];
+          z_measured_mean /= NUM_Z_STEPPER_DRIVERS;
 
-        // Calculate the sum of the absolute deviations from the mean value
-        float z_align_level_indicator = 0.0f;
-        LOOP_L_N(zstepper, NUM_Z_STEPPER_DRIVERS)
-          z_align_level_indicator += ABS(z_measured[zstepper] - z_measured_mean);
+          // Calculate the sum of the absolute deviations from the mean value
+          float z_align_level_indicator = 0.0f;
+          LOOP_L_N(zstepper, NUM_Z_STEPPER_DRIVERS)
+            z_align_level_indicator += ABS(z_measured[zstepper] - z_measured_mean);
 
-        // If it's getting worse, stop and throw an error
-        err_break = decreasing_accuracy(last_z_align_level_indicator, z_align_level_indicator);
-        if (err_break) break;
+          // If it's getting worse, stop and throw an error
+          err_break = decreasing_accuracy(last_z_align_level_indicator, z_align_level_indicator);
+          if (err_break) break;
 
-        last_z_align_level_indicator = z_align_level_indicator;
-      #endif
+          last_z_align_level_indicator = z_align_level_indicator;
+        #endif
 
-      // The following correction actions are to be enabled for select Z-steppers only
-      stepper.set_separate_multi_axis(true);
-
-      bool success_break = true;
-      // Correct the individual stepper offsets
-      LOOP_L_N(zstepper, NUM_Z_STEPPER_DRIVERS) {
-        // Calculate current stepper move
-        float z_align_move = z_measured[zstepper] - z_measured_min;
-        const float z_align_abs = ABS(z_align_move);
-
-        #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-          // Optimize one iteration's correction based on the first measurements
-          if (z_align_abs) amplification = (iteration == 1) ? _MIN(last_z_align_move[zstepper] / z_align_abs, 2.0f) : z_auto_align_amplification;
-
-          // Check for less accuracy compared to last move
-          if (decreasing_accuracy(last_z_align_move[zstepper], z_align_abs)) {
-            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " last_z_align_move = ", last_z_align_move[zstepper]);
-            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " z_align_abs = ", z_align_abs);
-            adjustment_reverse = !adjustment_reverse;
-          }
+        // The following correction actions are to be enabled for select Z-steppers only
+        stepper.set_separate_multi_axis(true);
+
+        bool success_break = true;
+        // Correct the individual stepper offsets
+        LOOP_L_N(zstepper, NUM_Z_STEPPER_DRIVERS) {
+          // Calculate current stepper move
+          float z_align_move = z_measured[zstepper] - z_measured_min;
+          const float z_align_abs = ABS(z_align_move);
+
+          #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+            // Optimize one iteration's correction based on the first measurements
+            if (z_align_abs) amplification = (iteration == 1) ? _MIN(last_z_align_move[zstepper] / z_align_abs, 2.0f) : z_auto_align_amplification;
+
+            // Check for less accuracy compared to last move
+            if (decreasing_accuracy(last_z_align_move[zstepper], z_align_abs)) {
+              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " last_z_align_move = ", last_z_align_move[zstepper]);
+              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " z_align_abs = ", z_align_abs);
+              adjustment_reverse = !adjustment_reverse;
+            }
+
+            // Remember the alignment for the next iteration, but only if steppers move,
+            // otherwise it would be just zero (in case this stepper was at z_measured_min already)
+            if (z_align_abs > 0) last_z_align_move[zstepper] = z_align_abs;
+          #endif
 
-          // Remember the alignment for the next iteration, but only if steppers move,
-          // otherwise it would be just zero (in case this stepper was at z_measured_min already)
-          if (z_align_abs > 0) last_z_align_move[zstepper] = z_align_abs;
-        #endif
+          // Stop early if all measured points achieve accuracy target
+          if (z_align_abs > z_auto_align_accuracy) success_break = false;
 
-        // Stop early if all measured points achieve accuracy target
-        if (z_align_abs > z_auto_align_accuracy) success_break = false;
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " corrected by ", z_align_move);
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " corrected by ", z_align_move);
+          // Lock all steppers except one
+          stepper.set_all_z_lock(true, zstepper);
 
-        // Lock all steppers except one
-        stepper.set_all_z_lock(true, zstepper);
+          #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+            // Decreasing accuracy was detected so move was inverted.
+            // Will match reversed Z steppers on dual steppers. Triple will need more work to map.
+            if (adjustment_reverse) {
+              z_align_move = -z_align_move;
+              if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " correction reversed to ", z_align_move);
+            }
+          #endif
 
-        #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-          // Decreasing accuracy was detected so move was inverted.
-          // Will match reversed Z steppers on dual steppers. Triple will need more work to map.
-          if (adjustment_reverse) {
-            z_align_move = -z_align_move;
-            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " correction reversed to ", z_align_move);
-          }
-        #endif
+          // Do a move to correct part of the misalignment for the current stepper
+          do_blocking_move_to_z(amplification * z_align_move + current_position.z);
+        } // for (zstepper)
 
-        // Do a move to correct part of the misalignment for the current stepper
-        do_blocking_move_to_z(amplification * z_align_move + current_position.z);
-      } // for (zstepper)
+        // Back to normal stepper operations
+        stepper.set_all_z_lock(false);
+        stepper.set_separate_multi_axis(false);
 
-      // Back to normal stepper operations
-      stepper.set_all_z_lock(false);
-      stepper.set_separate_multi_axis(false);
+        if (err_break) break;
 
-      if (err_break) break;
+        if (success_break) {
+          SERIAL_ECHOLNPGM("Target accuracy achieved.");
+          LCD_MESSAGEPGM(MSG_ACCURACY_ACHIEVED);
+          break;
+        }
 
-      if (success_break) {
-        SERIAL_ECHOLNPGM("Target accuracy achieved.");
-        LCD_MESSAGEPGM(MSG_ACCURACY_ACHIEVED);
-        break;
-      }
+        iteration++;
+      } // while (iteration < z_auto_align_iterations)
 
-      iteration++;
-    } // while (iteration < z_auto_align_iterations)
+      if (err_break)
+        SERIAL_ECHOLNPGM("G34 aborted.");
+      else {
+        SERIAL_ECHOLNPAIR("Did ", int(iteration + (iteration != z_auto_align_iterations)), " of ", int(z_auto_align_iterations));
+        SERIAL_ECHOLNPAIR_F("Accuracy: ", z_maxdiff);
+      }
 
-    if (err_break)
-      SERIAL_ECHOLNPGM("G34 aborted.");
-    else {
-      SERIAL_ECHOLNPAIR("Did ", int(iteration + (iteration != z_auto_align_iterations)), " of ", int(z_auto_align_iterations));
-      SERIAL_ECHOLNPAIR_F("Accuracy: ", z_maxdiff);
-    }
+      // Stow the probe, as the last call to probe.probe_at_point(...) left
+      // the probe deployed if it was successful.
+      probe.stow();
 
-    // Stow the probe, as the last call to probe.probe_at_point(...) left
-    // the probe deployed if it was successful.
-    probe.stow();
-
-    #if ENABLED(HOME_AFTER_G34)
-      // After this operation the z position needs correction
-      set_axis_never_homed(Z_AXIS);
-      // Home Z after the alignment procedure
-      process_subcommands_now_P(PSTR("G28Z"));
-    #else
-      // Use the probed height from the last iteration to determine the Z height.
-      // z_measured_min is used, because all steppers are aligned to z_measured_min.
-      // Ideally, this would be equal to the 'z_probe * 0.5f' which was added earlier.
-      current_position.z -= z_measured_min - (float)Z_CLEARANCE_BETWEEN_PROBES;
-      sync_plan_position();
-    #endif
+      #if ENABLED(HOME_AFTER_G34)
+        // After this operation the z position needs correction
+        set_axis_never_homed(Z_AXIS);
+        // Home Z after the alignment procedure
+        process_subcommands_now_P(PSTR("G28Z"));
+      #else
+        // Use the probed height from the last iteration to determine the Z height.
+        // z_measured_min is used, because all steppers are aligned to z_measured_min.
+        // Ideally, this would be equal to the 'z_probe * 0.5f' which was added earlier.
+        current_position.z -= z_measured_min - (float)Z_CLEARANCE_BETWEEN_PROBES;
+        sync_plan_position();
+      #endif
 
-    // Restore the active tool after homing
-    TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index, DISABLED(PARKING_EXTRUDER))); // Fetch previous tool for parking extruder
+      // Restore the active tool after homing
+      TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index, DISABLED(PARKING_EXTRUDER))); // Fetch previous tool for parking extruder
 
-    #if BOTH(HAS_LEVELING, RESTORE_LEVELING_AFTER_G34)
-      set_bed_leveling_enabled(leveling_was_active);
-    #endif
+      #if BOTH(HAS_LEVELING, RESTORE_LEVELING_AFTER_G34)
+        set_bed_leveling_enabled(leveling_was_active);
+      #endif
 
-  }while(0);
+    }while(0);
+  #endif
 }
 
+#endif // Z_MULTI_ENDSTOPS || Z_STEPPER_AUTO_ALIGN
+
+#if ENABLED(Z_STEPPER_AUTO_ALIGN)
+
 /**
  * M422: Set a Z-Stepper automatic alignment XY point.
  *       Use repeatedly to set multiple points.

commit 263f29a96a6ce5e76aa94782f5dc9c26e3f4a4fc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 20:48:52 2020 -0500

    MarlinUI followup

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 3dc63b0655..5e1ec5b961 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -31,7 +31,7 @@
 #include "../../module/stepper.h"
 #include "../../module/planner.h"
 #include "../../module/probe.h"
-#include "../../lcd/ultralcd.h" // for LCD_MESSAGEPGM
+#include "../../lcd/marlinui.h" // for LCD_MESSAGEPGM
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"

commit 418b3e5ee26c0284561f07cf462af27971715d12
Author: nb-rapidia <43864438+nb-rapidia@users.noreply.github.com>
Date:   Fri Oct 16 14:59:55 2020 -0700

    Fix IDEX layer shift and DIR states (#19756)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 24292477f9..3dc63b0655 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -113,7 +113,7 @@ void GcodeSuite::G34() {
       tool_change(0, true);
     #endif
 
-    TERN_(HAS_DUPLICATION_MODE, extruder_duplication_enabled = false);
+    TERN_(HAS_DUPLICATION_MODE, set_duplication_enabled(false));
 
     // In BLTOUCH HS mode, the probe travels in a deployed state.
     // Users of G34 might have a badly misaligned bed, so raise Z by the

commit e7838c5f7904924eed7e996d2ff95fff0f64e30e
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Oct 11 22:34:27 2020 -0400

    G34 Mechanical Gantry Calibration (like Prusa M915) (#18972)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 1fd0754ec7..24292477f9 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -20,28 +20,29 @@
  *
  */
 
-#include "../../inc/MarlinConfig.h"
+#include "../../inc/MarlinConfigPre.h"
 
 #if ENABLED(Z_STEPPER_AUTO_ALIGN)
 
 #include "../../feature/z_stepper_align.h"
 
 #include "../gcode.h"
-#include "../../module/planner.h"
-#include "../../module/stepper.h"
 #include "../../module/motion.h"
+#include "../../module/stepper.h"
+#include "../../module/planner.h"
 #include "../../module/probe.h"
-
-#if HAS_MULTI_HOTEND
-  #include "../../module/tool_change.h"
-#endif
+#include "../../lcd/ultralcd.h" // for LCD_MESSAGEPGM
 
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
+#if HAS_MULTI_HOTEND
+  #include "../../module/tool_change.h"
+#endif
+
 #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-   #include "../../libs/least_squares_fit.h"
+  #include "../../libs/least_squares_fit.h"
 #endif
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
@@ -117,7 +118,7 @@ void GcodeSuite::G34() {
     // In BLTOUCH HS mode, the probe travels in a deployed state.
     // Users of G34 might have a badly misaligned bed, so raise Z by the
     // length of the deployed pin (BLTOUCH stroke < 7mm)
-    #define Z_BASIC_CLEARANCE Z_CLEARANCE_BETWEEN_PROBES + 7.0f * BOTH(BLTOUCH, BLTOUCH_HS_MODE)
+    #define Z_BASIC_CLEARANCE (Z_CLEARANCE_BETWEEN_PROBES + 7.0f * BOTH(BLTOUCH, BLTOUCH_HS_MODE))
 
     // Compute a worst-case clearance height to probe from. After the first
     // iteration this will be re-calculated based on the actual bed position
@@ -154,21 +155,29 @@ void GcodeSuite::G34() {
           z_maxdiff = 0.0f,
           amplification = z_auto_align_amplification;
 
-    // These are needed after the for-loop
-    uint8_t iteration;
-    bool err_break = false;
-    float z_measured_min;
-
     #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
       bool adjustment_reverse = false;
     #endif
 
-    // 'iteration' is declared above and is also used after the for-loop.
-    // *not* the same as LOOP_L_N(iteration, z_auto_align_iterations)
-    for (iteration = 0; iteration < z_auto_align_iterations; ++iteration) {
+    #if HAS_DISPLAY
+      PGM_P const msg_iteration = GET_TEXT(MSG_ITERATION);
+      const uint8_t iter_str_len = strlen_P(msg_iteration);
+    #endif
+
+    // Final z and iteration values will be used after breaking the loop
+    float z_measured_min;
+    uint8_t iteration = 0;
+    bool err_break = false; // To break out of nested loops
+    while (iteration < z_auto_align_iterations) {
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> probing all positions.");
 
-      SERIAL_ECHOLNPAIR("\nITERATION: ", int(iteration + 1));
+      const int iter = iteration + 1;
+      SERIAL_ECHOLNPAIR("\nG34 Iteration: ", iter);
+      #if HAS_DISPLAY
+        char str[iter_str_len + 2 + 1];
+        sprintf_P(str, msg_iteration, iter);
+        ui.set_status(str);
+      #endif
 
       // Initialize minimum value
       z_measured_min =  100000.0f;
@@ -190,7 +199,8 @@ void GcodeSuite::G34() {
         // current_position.z has been manually altered in the "dirty trick" above.
         const float z_probed_height = probe.probe_at_point(z_stepper_align.xy[iprobe], raise_after, 0, true, false);
         if (isnan(z_probed_height)) {
-          SERIAL_ECHOLNPGM("Probing failed.");
+          SERIAL_ECHOLNPGM("Probing failed");
+          LCD_MESSAGEPGM(MSG_LCD_PROBING_FAILED);
           err_break = true;
           break;
         }
@@ -249,8 +259,39 @@ void GcodeSuite::G34() {
           , " Z3-Z1=", ABS(z_measured[2] - z_measured[0])
         #endif
       );
+      #if HAS_DISPLAY
+        char fstr1[10];
+        #if NUM_Z_STEPPER_DRIVERS == 2
+          char msg[6 + (6 + 5) * 1 + 1];
+        #else
+          char msg[6 + (6 + 5) * 3 + 1], fstr2[10], fstr3[10];
+        #endif
+        sprintf_P(msg,
+          PSTR("Diffs Z1-Z2=%s"
+            #if NUM_Z_STEPPER_DRIVERS == 3
+              " Z2-Z3=%s"
+              " Z3-Z1=%s"
+            #endif
+          ), dtostrf(ABS(z_measured[0] - z_measured[1]), 1, 3, fstr1)
+          #if NUM_Z_STEPPER_DRIVERS == 3
+            , dtostrf(ABS(z_measured[1] - z_measured[2]), 1, 3, fstr2)
+            , dtostrf(ABS(z_measured[2] - z_measured[0]), 1, 3, fstr3)
+          #endif
+        );
+        ui.set_status(msg);
+      #endif
+
+      auto decreasing_accuracy = [](const float &v1, const float &v2){
+        if (v1 < v2 * 0.7f) {
+          SERIAL_ECHOLNPGM("Decreasing Accuracy Detected.");
+          LCD_MESSAGEPGM(MSG_DECREASING_ACCURACY);
+          return true;
+        }
+        return false;
+      };
 
       #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+
         // Check if the applied corrections go in the correct direction.
         // Calculate the sum of the absolute deviations from the mean of the probe measurements.
         // Compare to the last iteration to ensure it's getting better.
@@ -266,11 +307,8 @@ void GcodeSuite::G34() {
           z_align_level_indicator += ABS(z_measured[zstepper] - z_measured_mean);
 
         // If it's getting worse, stop and throw an error
-        if (last_z_align_level_indicator < z_align_level_indicator * 0.7f) {
-          SERIAL_ECHOLNPGM("Decreasing accuracy detected.");
-          err_break = true;
-          break;
-        }
+        err_break = decreasing_accuracy(last_z_align_level_indicator, z_align_level_indicator);
+        if (err_break) break;
 
         last_z_align_level_indicator = z_align_level_indicator;
       #endif
@@ -290,8 +328,7 @@ void GcodeSuite::G34() {
           if (z_align_abs) amplification = (iteration == 1) ? _MIN(last_z_align_move[zstepper] / z_align_abs, 2.0f) : z_auto_align_amplification;
 
           // Check for less accuracy compared to last move
-          if (last_z_align_move[zstepper] < z_align_abs * 0.7f) {
-            SERIAL_ECHOLNPGM("Decreasing accuracy detected.");
+          if (decreasing_accuracy(last_z_align_move[zstepper], z_align_abs)) {
             if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " last_z_align_move = ", last_z_align_move[zstepper]);
             if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " z_align_abs = ", z_align_abs);
             adjustment_reverse = !adjustment_reverse;
@@ -329,9 +366,14 @@ void GcodeSuite::G34() {
 
       if (err_break) break;
 
-      if (success_break) { SERIAL_ECHOLNPGM("Target accuracy achieved."); break; }
+      if (success_break) {
+        SERIAL_ECHOLNPGM("Target accuracy achieved.");
+        LCD_MESSAGEPGM(MSG_ACCURACY_ACHIEVED);
+        break;
+      }
 
-    } // for (iteration)
+      iteration++;
+    } // while (iteration < z_auto_align_iterations)
 
     if (err_break)
       SERIAL_ECHOLNPGM("G34 aborted.");

commit 462d3eeab15d173ade700faf961931050aed9d70
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 27 14:48:42 2020 -0500

    set_axis_not_trusted => set_axis_never_homed

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 3360dc050f..1fd0754ec7 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -346,7 +346,7 @@ void GcodeSuite::G34() {
 
     #if ENABLED(HOME_AFTER_G34)
       // After this operation the z position needs correction
-      set_axis_not_trusted(Z_AXIS);
+      set_axis_never_homed(Z_AXIS);
       // Home Z after the alignment procedure
       process_subcommands_now_P(PSTR("G28Z"));
     #else

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 6c85a7e021..3360dc050f 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit 73fc0778b864ab1f5e5c3f065f5d8db75a0bbb7c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 8 21:44:21 2020 -0500

    Consolidate probe clearance, add section debug (#18576)
    
    * Better section / function log
    * Add do_z_clearance motion function

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index d0fa84b9ad..6c85a7e021 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -56,10 +56,8 @@
  *   R<recalculate> points based on current probe offsets
  */
 void GcodeSuite::G34() {
-  if (DEBUGGING(LEVELING)) {
-    DEBUG_ECHOLNPGM(">>> G34");
-    log_machine_info();
-  }
+  DEBUG_SECTION(log_G34, "G34", DEBUGGING(LEVELING));
+  if (DEBUGGING(LEVELING)) log_machine_info();
 
   do { // break out on error
 
@@ -367,8 +365,6 @@ void GcodeSuite::G34() {
     #endif
 
   }while(0);
-
-  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G34");
 }
 
 /**

commit fcb8c5a1c1220c0f9c48fcecdd848a060c998703
Author: MoellerDi <MoellerDi@users.noreply.github.com>
Date:   Fri Jun 5 02:09:01 2020 +0200

    Fix G34 move in wrong direction (#18188)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 0961cce59c..d0fa84b9ad 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -294,11 +294,14 @@ void GcodeSuite::G34() {
           // Check for less accuracy compared to last move
           if (last_z_align_move[zstepper] < z_align_abs * 0.7f) {
             SERIAL_ECHOLNPGM("Decreasing accuracy detected.");
+            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " last_z_align_move = ", last_z_align_move[zstepper]);
+            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " z_align_abs = ", z_align_abs);
             adjustment_reverse = !adjustment_reverse;
           }
 
-          // Remember the alignment for the next iteration
-          last_z_align_move[zstepper] = z_align_abs;
+          // Remember the alignment for the next iteration, but only if steppers move,
+          // otherwise it would be just zero (in case this stepper was at z_measured_min already)
+          if (z_align_abs > 0) last_z_align_move[zstepper] = z_align_abs;
         #endif
 
         // Stop early if all measured points achieve accuracy target
@@ -312,8 +315,10 @@ void GcodeSuite::G34() {
         #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
           // Decreasing accuracy was detected so move was inverted.
           // Will match reversed Z steppers on dual steppers. Triple will need more work to map.
-          if (adjustment_reverse)
+          if (adjustment_reverse) {
             z_align_move = -z_align_move;
+            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " correction reversed to ", z_align_move);
+          }
         #endif
 
         // Do a move to correct part of the misalignment for the current stepper

commit a1f3d2f3cd9bf8bb4da16da0e55cdb5ff264a15d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 31 01:03:28 2020 -0500

    Move set_all_z_lock to Stepper

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index f5addd9cd6..0961cce59c 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -47,17 +47,6 @@
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
 
-inline void set_all_z_lock(const bool lock) {
-  stepper.set_z_lock(lock);
-  stepper.set_z2_lock(lock);
-  #if NUM_Z_STEPPER_DRIVERS >= 3
-    stepper.set_z3_lock(lock);
-    #if NUM_Z_STEPPER_DRIVERS >= 4
-      stepper.set_z4_lock(lock);
-    #endif
-  #endif
-}
-
 /**
  * G34: Z-Stepper automatic alignment
  *
@@ -318,17 +307,7 @@ void GcodeSuite::G34() {
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " corrected by ", z_align_move);
 
         // Lock all steppers except one
-        set_all_z_lock(true);
-        switch (zstepper) {
-          case 0: stepper.set_z_lock(false); break;
-          case 1: stepper.set_z2_lock(false); break;
-          #if NUM_Z_STEPPER_DRIVERS >= 3
-            case 2: stepper.set_z3_lock(false); break;
-          #endif
-          #if NUM_Z_STEPPER_DRIVERS == 4
-            case 3: stepper.set_z4_lock(false); break;
-          #endif
-        }
+        stepper.set_all_z_lock(true, zstepper);
 
         #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
           // Decreasing accuracy was detected so move was inverted.
@@ -342,7 +321,7 @@ void GcodeSuite::G34() {
       } // for (zstepper)
 
       // Back to normal stepper operations
-      set_all_z_lock(false);
+      stepper.set_all_z_lock(false);
       stepper.set_separate_multi_axis(false);
 
       if (err_break) break;

commit ab2b98e4255b0b9579af9627e884ac3dfc1d30bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 21:42:38 2020 -0500

    Apply composite tests

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 8c321df58c..f5addd9cd6 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -378,7 +378,7 @@ void GcodeSuite::G34() {
     // Restore the active tool after homing
     TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index, DISABLED(PARKING_EXTRUDER))); // Fetch previous tool for parking extruder
 
-    #if HAS_LEVELING && ENABLED(RESTORE_LEVELING_AFTER_G34)
+    #if BOTH(HAS_LEVELING, RESTORE_LEVELING_AFTER_G34)
       set_bed_leveling_enabled(leveling_was_active);
     #endif
 

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 091619c6ff..8c321df58c 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -113,15 +113,11 @@ void GcodeSuite::G34() {
 
     // Disable the leveling matrix before auto-aligning
     #if HAS_LEVELING
-      #if ENABLED(RESTORE_LEVELING_AFTER_G34)
-        const bool leveling_was_active = planner.leveling_active;
-      #endif
+      TERN_(RESTORE_LEVELING_AFTER_G34, const bool leveling_was_active = planner.leveling_active);
       set_bed_leveling_enabled(false);
     #endif
 
-    #if ENABLED(CNC_WORKSPACE_PLANES)
-      workspace_plane = PLANE_XY;
-    #endif
+    TERN_(CNC_WORKSPACE_PLANES, workspace_plane = PLANE_XY);
 
     // Always home with tool 0 active
     #if HAS_MULTI_HOTEND
@@ -129,18 +125,12 @@ void GcodeSuite::G34() {
       tool_change(0, true);
     #endif
 
-    #if HAS_DUPLICATION_MODE
-      extruder_duplication_enabled = false;
-    #endif
+    TERN_(HAS_DUPLICATION_MODE, extruder_duplication_enabled = false);
 
-    #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
-        // In BLTOUCH HS mode, the probe travels in a deployed state.
-        // Users of G34 might have a badly misaligned bed, so raise Z by the
-        // length of the deployed pin (BLTOUCH stroke < 7mm)
-      #define Z_BASIC_CLEARANCE Z_CLEARANCE_BETWEEN_PROBES + 7.0f
-    #else
-      #define Z_BASIC_CLEARANCE Z_CLEARANCE_BETWEEN_PROBES
-    #endif
+    // In BLTOUCH HS mode, the probe travels in a deployed state.
+    // Users of G34 might have a badly misaligned bed, so raise Z by the
+    // length of the deployed pin (BLTOUCH stroke < 7mm)
+    #define Z_BASIC_CLEARANCE Z_CLEARANCE_BETWEEN_PROBES + 7.0f * BOTH(BLTOUCH, BLTOUCH_HS_MODE)
 
     // Compute a worst-case clearance height to probe from. After the first
     // iteration this will be re-calculated based on the actual bed position
@@ -386,9 +376,7 @@ void GcodeSuite::G34() {
     #endif
 
     // Restore the active tool after homing
-    #if HAS_MULTI_HOTEND
-      tool_change(old_tool_index, DISABLED(PARKING_EXTRUDER)); // Fetch previous tool for parking extruder
-    #endif
+    TERN_(HAS_MULTI_HOTEND, tool_change(old_tool_index, DISABLED(PARKING_EXTRUDER))); // Fetch previous tool for parking extruder
 
     #if HAS_LEVELING && ENABLED(RESTORE_LEVELING_AFTER_G34)
       set_bed_leveling_enabled(leveling_was_active);

commit 15f6f53638a6778d22a17e1900fb3a9fdc92dade
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 19 23:56:55 2020 -0500

    Add HAS_HOTEND, etc.

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index d1b828d079..091619c6ff 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -32,7 +32,7 @@
 #include "../../module/motion.h"
 #include "../../module/probe.h"
 
-#if HOTENDS > 1
+#if HAS_MULTI_HOTEND
   #include "../../module/tool_change.h"
 #endif
 
@@ -124,7 +124,7 @@ void GcodeSuite::G34() {
     #endif
 
     // Always home with tool 0 active
-    #if HOTENDS > 1
+    #if HAS_MULTI_HOTEND
       const uint8_t old_tool_index = active_extruder;
       tool_change(0, true);
     #endif
@@ -386,7 +386,7 @@ void GcodeSuite::G34() {
     #endif
 
     // Restore the active tool after homing
-    #if HOTENDS > 1
+    #if HAS_MULTI_HOTEND
       tool_change(old_tool_index, DISABLED(PARKING_EXTRUDER)); // Fetch previous tool for parking extruder
     #endif
 

commit 3b987dfcec653bfa8c79412d44cc70fd07941bd2
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Mon Mar 16 00:23:24 2020 +0100

    Fix G34 Z lower, extra "BLTOUCH" debug line (#17175)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 672f40737a..d1b828d079 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -203,7 +203,7 @@ void GcodeSuite::G34() {
         const uint8_t iprobe = (iteration & 1) ? NUM_Z_STEPPER_DRIVERS - 1 - i : i;
 
         // Safe clearance even on an incline
-        if (iteration == 0 || i > 0) do_blocking_move_to_z(z_probe);
+        if ((iteration == 0 || i > 0) && z_probe > current_position.z) do_blocking_move_to_z(z_probe);
 
         if (DEBUGGING(LEVELING))
           DEBUG_ECHOLNPAIR_P(PSTR("Probing X"), z_stepper_align.xy[iprobe].x, SP_Y_STR, z_stepper_align.xy[iprobe].y);

commit cee07f3f6b3fad54919283529daa65a964266000
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Mar 14 00:22:04 2020 -0400

    Quad Z leveling, G34 (R)ecalculate (#17122)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index fecbb4be68..672f40737a 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -64,6 +64,7 @@ inline void set_all_z_lock(const bool lock) {
  *   I<iterations>
  *   T<accuracy>
  *   A<amplification>
+ *   R<recalculate> points based on current probe offsets
  */
 void GcodeSuite::G34() {
   if (DEBUGGING(LEVELING)) {
@@ -73,8 +74,10 @@ void GcodeSuite::G34() {
 
   do { // break out on error
 
-    #if NUM_Z_STEPPER_DRIVERS >= 4
-      SERIAL_ECHOLNPGM("Alignment not supported for over 3 steppers");
+    #if NUM_Z_STEPPER_DRIVERS == 4
+      SERIAL_ECHOLNPGM("Alignment for 4 steppers is Experimental!");
+    #elif NUM_Z_STEPPER_DRIVERS > 4
+      SERIAL_ECHOLNPGM("Alignment not supported for over 4 steppers");
       break;
     #endif
 
@@ -101,6 +104,8 @@ void GcodeSuite::G34() {
         }
       #endif
 
+    if (parser.seen('R')) z_stepper_align.reset_to_default();
+
     const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
 
     // Wait for planner moves to finish!
@@ -139,13 +144,18 @@ void GcodeSuite::G34() {
 
     // Compute a worst-case clearance height to probe from. After the first
     // iteration this will be re-calculated based on the actual bed position
-    float z_probe = Z_BASIC_CLEARANCE + (G34_MAX_GRADE) * 0.01f * (
+    auto magnitude2 = [&](const uint8_t i, const uint8_t j) {
+      const xy_pos_t diff = z_stepper_align.xy[i] - z_stepper_align.xy[j];
+      return HYPOT2(diff.x, diff.y);
+    };
+    float z_probe = Z_BASIC_CLEARANCE + (G34_MAX_GRADE) * 0.01f * SQRT(
       #if NUM_Z_STEPPER_DRIVERS == 3
-         SQRT(_MAX(HYPOT2(z_stepper_align.xy[0].x - z_stepper_align.xy[1].x, z_stepper_align.xy[0].y - z_stepper_align.xy[1].y),
-                   HYPOT2(z_stepper_align.xy[1].x - z_stepper_align.xy[2].x, z_stepper_align.xy[1].y - z_stepper_align.xy[2].y),
-                   HYPOT2(z_stepper_align.xy[2].x - z_stepper_align.xy[0].x, z_stepper_align.xy[2].y - z_stepper_align.xy[0].y)))
+         _MAX(magnitude2(0, 1), magnitude2(1, 2), magnitude2(2, 0))
+      #elif NUM_Z_STEPPER_DRIVERS == 4
+         _MAX(magnitude2(0, 1), magnitude2(1, 2), magnitude2(2, 3),
+              magnitude2(3, 0), magnitude2(0, 2), magnitude2(1, 3))
       #else
-         HYPOT(z_stepper_align.xy[0].x - z_stepper_align.xy[1].x, z_stepper_align.xy[0].y - z_stepper_align.xy[1].y)
+         magnitude2(0, 1)
       #endif
     );
 
@@ -159,7 +169,7 @@ void GcodeSuite::G34() {
     // This hack is un-done at the end of G34 - either by re-homing, or by using the probed heights of the last iteration.
 
     #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-      float last_z_align_move[NUM_Z_STEPPER_DRIVERS] = ARRAY_N(NUM_Z_STEPPER_DRIVERS, 10000.0f, 10000.0f, 10000.0f);
+      float last_z_align_move[NUM_Z_STEPPER_DRIVERS] = ARRAY_N(NUM_Z_STEPPER_DRIVERS, 10000.0f, 10000.0f, 10000.0f, 10000.0f);
     #else
       float last_z_align_level_indicator = 10000.0f;
     #endif
@@ -241,7 +251,7 @@ void GcodeSuite::G34() {
         linear_fit_data lfd;
         incremental_LSF_reset(&lfd);
         LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
-          SERIAL_ECHOLNPAIR("PROBEPT_", ('0' + i), ": ", z_measured[i]);
+          SERIAL_ECHOLNPAIR("PROBEPT_", int(i), ": ", z_measured[i]);
           incremental_LSF(&lfd, z_stepper_align.xy[i], z_measured[i]);
         }
         finish_incremental_LSF(&lfd);
@@ -322,9 +332,12 @@ void GcodeSuite::G34() {
         switch (zstepper) {
           case 0: stepper.set_z_lock(false); break;
           case 1: stepper.set_z2_lock(false); break;
-          #if NUM_Z_STEPPER_DRIVERS == 3
+          #if NUM_Z_STEPPER_DRIVERS >= 3
             case 2: stepper.set_z3_lock(false); break;
           #endif
+          #if NUM_Z_STEPPER_DRIVERS == 4
+            case 3: stepper.set_z4_lock(false); break;
+          #endif
         }
 
         #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
@@ -348,28 +361,13 @@ void GcodeSuite::G34() {
 
     } // for (iteration)
 
-    if (err_break) {
+    if (err_break)
       SERIAL_ECHOLNPGM("G34 aborted.");
-      set_axis_not_trusted(Z_AXIS);  // The Z coordinate is messed up now
-      break;
+    else {
+      SERIAL_ECHOLNPAIR("Did ", int(iteration + (iteration != z_auto_align_iterations)), " of ", int(z_auto_align_iterations));
+      SERIAL_ECHOLNPAIR_F("Accuracy: ", z_maxdiff);
     }
 
-    SERIAL_ECHOLNPAIR("Did ", int(iteration + (iteration != z_auto_align_iterations)), " iterations of ", int(z_auto_align_iterations));
-    SERIAL_ECHOLNPAIR_F("Accuracy: ", z_maxdiff);
-
-    // Restore the active tool after homing
-    #if HOTENDS > 1
-      tool_change(old_tool_index, (true
-        #if ENABLED(PARKING_EXTRUDER)
-          && false // Fetch the previous toolhead
-        #endif
-      ));
-    #endif
-
-    #if HAS_LEVELING && ENABLED(RESTORE_LEVELING_AFTER_G34)
-      set_bed_leveling_enabled(leveling_was_active);
-    #endif
-
     // Stow the probe, as the last call to probe.probe_at_point(...) left
     // the probe deployed if it was successful.
     probe.stow();
@@ -377,7 +375,6 @@ void GcodeSuite::G34() {
     #if ENABLED(HOME_AFTER_G34)
       // After this operation the z position needs correction
       set_axis_not_trusted(Z_AXIS);
-
       // Home Z after the alignment procedure
       process_subcommands_now_P(PSTR("G28Z"));
     #else
@@ -388,6 +385,15 @@ void GcodeSuite::G34() {
       sync_plan_position();
     #endif
 
+    // Restore the active tool after homing
+    #if HOTENDS > 1
+      tool_change(old_tool_index, DISABLED(PARKING_EXTRUDER)); // Fetch previous tool for parking extruder
+    #endif
+
+    #if HAS_LEVELING && ENABLED(RESTORE_LEVELING_AFTER_G34)
+      set_bed_leveling_enabled(leveling_was_active);
+    #endif
+
   }while(0);
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G34");
@@ -406,9 +412,16 @@ void GcodeSuite::G34() {
  * S and W require an X and/or Y parameter
  *   X<pos>   : X position to set (Unchanged if omitted)
  *   Y<pos>   : Y position to set (Unchanged if omitted)
+ *
+ * R : Recalculate points based on current probe offsets
  */
 void GcodeSuite::M422() {
 
+  if (parser.seen('R')) {
+    z_stepper_align.reset_to_default();
+    return;
+  }
+
   if (!parser.seen_any()) {
     LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS)
       SERIAL_ECHOLNPAIR_P(PSTR("M422 S"), int(i + 1), SP_X_STR, z_stepper_align.xy[i].x, SP_Y_STR, z_stepper_align.xy[i].y);

commit 9c759e5f74ca69a7cb5169ea217dd179d65b1f44
Author: Jason Smith <jason.inet@gmail.com>
Date:   Thu Mar 12 17:26:09 2020 -0700

    Fix BAUD_RATE_GCODE, etc. (#17135)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 087172518f..fecbb4be68 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -411,10 +411,10 @@ void GcodeSuite::M422() {
 
   if (!parser.seen_any()) {
     LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS)
-      SERIAL_ECHOLNPAIR_P(PSTR("M422 S"), i + '1', SP_X_STR, z_stepper_align.xy[i].x, SP_Y_STR, z_stepper_align.xy[i].y);
+      SERIAL_ECHOLNPAIR_P(PSTR("M422 S"), int(i + 1), SP_X_STR, z_stepper_align.xy[i].x, SP_Y_STR, z_stepper_align.xy[i].y);
     #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
       LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS)
-        SERIAL_ECHOLNPAIR_P(PSTR("M422 W"), i + '1', SP_X_STR, z_stepper_align.stepper_xy[i].x, SP_Y_STR, z_stepper_align.stepper_xy[i].y);
+        SERIAL_ECHOLNPAIR_P(PSTR("M422 W"), int(i + 1), SP_X_STR, z_stepper_align.stepper_xy[i].x, SP_Y_STR, z_stepper_align.stepper_xy[i].y);
     #endif
     return;
   }

commit 627aa8db2dcb59584a815095e4a382a556323a9c
Author: jufimu12 <jufimu12@gmail.com>
Date:   Wed Mar 11 02:00:26 2020 +0100

    Fix G34, add HOME_AFTER_G34 option (#17108)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 5dcad991f1..087172518f 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -141,11 +141,11 @@ void GcodeSuite::G34() {
     // iteration this will be re-calculated based on the actual bed position
     float z_probe = Z_BASIC_CLEARANCE + (G34_MAX_GRADE) * 0.01f * (
       #if NUM_Z_STEPPER_DRIVERS == 3
-         SQRT(_MAX(HYPOT2(z_stepper_align.xy[0].x - z_stepper_align.xy[0].y, z_stepper_align.xy[1].x - z_stepper_align.xy[1].y),
-                   HYPOT2(z_stepper_align.xy[1].x - z_stepper_align.xy[1].y, z_stepper_align.xy[2].x - z_stepper_align.xy[2].y),
-                   HYPOT2(z_stepper_align.xy[2].x - z_stepper_align.xy[2].y, z_stepper_align.xy[0].x - z_stepper_align.xy[0].y)))
+         SQRT(_MAX(HYPOT2(z_stepper_align.xy[0].x - z_stepper_align.xy[1].x, z_stepper_align.xy[0].y - z_stepper_align.xy[1].y),
+                   HYPOT2(z_stepper_align.xy[1].x - z_stepper_align.xy[2].x, z_stepper_align.xy[1].y - z_stepper_align.xy[2].y),
+                   HYPOT2(z_stepper_align.xy[2].x - z_stepper_align.xy[0].x, z_stepper_align.xy[2].y - z_stepper_align.xy[0].y)))
       #else
-         HYPOT(z_stepper_align.xy[0].x - z_stepper_align.xy[0].y, z_stepper_align.xy[1].x - z_stepper_align.xy[1].y)
+         HYPOT(z_stepper_align.xy[0].x - z_stepper_align.xy[1].x, z_stepper_align.xy[0].y - z_stepper_align.xy[1].y)
       #endif
     );
 
@@ -156,6 +156,7 @@ void GcodeSuite::G34() {
     current_position.z += z_probe * 0.5f;
     sync_plan_position();
     // Now, the Z origin lies below the build plate. That allows to probe deeper, before run_z_probe throws an error.
+    // This hack is un-done at the end of G34 - either by re-homing, or by using the probed heights of the last iteration.
 
     #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
       float last_z_align_move[NUM_Z_STEPPER_DRIVERS] = ARRAY_N(NUM_Z_STEPPER_DRIVERS, 10000.0f, 10000.0f, 10000.0f);
@@ -166,8 +167,10 @@ void GcodeSuite::G34() {
           z_maxdiff = 0.0f,
           amplification = z_auto_align_amplification;
 
+    // These are needed after the for-loop
     uint8_t iteration;
     bool err_break = false;
+    float z_measured_min;
 
     #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
       bool adjustment_reverse = false;
@@ -181,8 +184,8 @@ void GcodeSuite::G34() {
       SERIAL_ECHOLNPAIR("\nITERATION: ", int(iteration + 1));
 
       // Initialize minimum value
-      float z_measured_min =  100000.0f,
-            z_measured_max = -100000.0f;
+      z_measured_min =  100000.0f;
+      float z_measured_max = -100000.0f;
 
       // Probe all positions (one per Z-Stepper)
       LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
@@ -238,14 +241,14 @@ void GcodeSuite::G34() {
         linear_fit_data lfd;
         incremental_LSF_reset(&lfd);
         LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
-          SERIAL_ECHOLNPAIR("PROBEPT_", i + '1', ": ", z_measured[i]);
+          SERIAL_ECHOLNPAIR("PROBEPT_", ('0' + i), ": ", z_measured[i]);
           incremental_LSF(&lfd, z_stepper_align.xy[i], z_measured[i]);
         }
         finish_incremental_LSF(&lfd);
 
         z_measured_min = 100000.0f;
         LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
-          z_measured[i] = -(lfd.A * z_stepper_align.stepper_xy[i].x + lfd.B * z_stepper_align.stepper_xy[i].y);
+          z_measured[i] = -(lfd.A * z_stepper_align.stepper_xy[i].x + lfd.B * z_stepper_align.stepper_xy[i].y + lfd.D);
           z_measured_min = _MIN(z_measured_min, z_measured[i]);
         }
 
@@ -345,7 +348,11 @@ void GcodeSuite::G34() {
 
     } // for (iteration)
 
-    if (err_break) { SERIAL_ECHOLNPGM("G34 aborted."); break; }
+    if (err_break) {
+      SERIAL_ECHOLNPGM("G34 aborted.");
+      set_axis_not_trusted(Z_AXIS);  // The Z coordinate is messed up now
+      break;
+    }
 
     SERIAL_ECHOLNPAIR("Did ", int(iteration + (iteration != z_auto_align_iterations)), " iterations of ", int(z_auto_align_iterations));
     SERIAL_ECHOLNPAIR_F("Accuracy: ", z_maxdiff);
@@ -363,15 +370,23 @@ void GcodeSuite::G34() {
       set_bed_leveling_enabled(leveling_was_active);
     #endif
 
-    // After this operation the z position needs correction
-    set_axis_is_not_at_home(Z_AXIS);
-
     // Stow the probe, as the last call to probe.probe_at_point(...) left
     // the probe deployed if it was successful.
     probe.stow();
 
-    // Home Z after the alignment procedure
-    process_subcommands_now_P(PSTR("G28 Z"));
+    #if ENABLED(HOME_AFTER_G34)
+      // After this operation the z position needs correction
+      set_axis_not_trusted(Z_AXIS);
+
+      // Home Z after the alignment procedure
+      process_subcommands_now_P(PSTR("G28Z"));
+    #else
+      // Use the probed height from the last iteration to determine the Z height.
+      // z_measured_min is used, because all steppers are aligned to z_measured_min.
+      // Ideally, this would be equal to the 'z_probe * 0.5f' which was added earlier.
+      current_position.z -= z_measured_min - (float)Z_CLEARANCE_BETWEEN_PROBES;
+      sync_plan_position();
+    #endif
 
   }while(0);
 

commit ad4a9eb73a099aed88daffd929019324a8471e5e
Author: jufimu12 <jufimu12@gmail.com>
Date:   Mon Mar 2 20:35:02 2020 +0100

    Fix G34 probing range/error bug (#17052)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 7923ef9231..5dcad991f1 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -153,7 +153,9 @@ void GcodeSuite::G34() {
     if (!all_axes_known()) home_all_axes();
 
     // Move the Z coordinate realm towards the positive - dirty trick
-    current_position.z -= z_probe * 0.5f;
+    current_position.z += z_probe * 0.5f;
+    sync_plan_position();
+    // Now, the Z origin lies below the build plate. That allows to probe deeper, before run_z_probe throws an error.
 
     #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
       float last_z_align_move[NUM_Z_STEPPER_DRIVERS] = ARRAY_N(NUM_Z_STEPPER_DRIVERS, 10000.0f, 10000.0f, 10000.0f);
@@ -171,7 +173,9 @@ void GcodeSuite::G34() {
       bool adjustment_reverse = false;
     #endif
 
-    LOOP_L_N(iteration, z_auto_align_iterations) {
+    // 'iteration' is declared above and is also used after the for-loop.
+    // *not* the same as LOOP_L_N(iteration, z_auto_align_iterations)
+    for (iteration = 0; iteration < z_auto_align_iterations; ++iteration) {
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> probing all positions.");
 
       SERIAL_ECHOLNPAIR("\nITERATION: ", int(iteration + 1));
@@ -192,7 +196,9 @@ void GcodeSuite::G34() {
           DEBUG_ECHOLNPAIR_P(PSTR("Probing X"), z_stepper_align.xy[iprobe].x, SP_Y_STR, z_stepper_align.xy[iprobe].y);
 
         // Probe a Z height for each stepper.
-        const float z_probed_height = probe.probe_at_point(z_stepper_align.xy[iprobe], raise_after, 0, true);
+        // Probing sanity check is disabled, as it would trigger even in normal cases because
+        // current_position.z has been manually altered in the "dirty trick" above.
+        const float z_probed_height = probe.probe_at_point(z_stepper_align.xy[iprobe], raise_after, 0, true, false);
         if (isnan(z_probed_height)) {
           SERIAL_ECHOLNPGM("Probing failed.");
           err_break = true;

commit ac755fce82a1749ad96c4fe3a61a9ec2dae24814
Author: jufimu12 <jufimu12@gmail.com>
Date:   Fri Feb 28 18:42:51 2020 +0100

    Fix G34 "Decreasing accuracy" bug (#17013)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 7144038ebd..7923ef9231 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -155,8 +155,12 @@ void GcodeSuite::G34() {
     // Move the Z coordinate realm towards the positive - dirty trick
     current_position.z -= z_probe * 0.5f;
 
-    float last_z_align_move[NUM_Z_STEPPER_DRIVERS] = ARRAY_N(NUM_Z_STEPPER_DRIVERS, 10000.0f, 10000.0f, 10000.0f),
-          z_measured[NUM_Z_STEPPER_DRIVERS] = { 0 },
+    #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+      float last_z_align_move[NUM_Z_STEPPER_DRIVERS] = ARRAY_N(NUM_Z_STEPPER_DRIVERS, 10000.0f, 10000.0f, 10000.0f);
+    #else
+      float last_z_align_level_indicator = 10000.0f;
+    #endif
+    float z_measured[NUM_Z_STEPPER_DRIVERS] = { 0 },
           z_maxdiff = 0.0f,
           amplification = z_auto_align_amplification;
 
@@ -167,7 +171,7 @@ void GcodeSuite::G34() {
       bool adjustment_reverse = false;
     #endif
 
-    for (iteration = 0; iteration < z_auto_align_iterations; ++iteration) {
+    LOOP_L_N(iteration, z_auto_align_iterations) {
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> probing all positions.");
 
       SERIAL_ECHOLNPAIR("\nITERATION: ", int(iteration + 1));
@@ -177,7 +181,7 @@ void GcodeSuite::G34() {
             z_measured_max = -100000.0f;
 
       // Probe all positions (one per Z-Stepper)
-      for (uint8_t i = 0; i < NUM_Z_STEPPER_DRIVERS; ++i) {
+      LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
         // iteration odd/even --> downward / upward stepper sequence
         const uint8_t iprobe = (iteration & 1) ? NUM_Z_STEPPER_DRIVERS - 1 - i : i;
 
@@ -227,14 +231,14 @@ void GcodeSuite::G34() {
         // This allows the actual adjustment logic to be shared by both algorithms.
         linear_fit_data lfd;
         incremental_LSF_reset(&lfd);
-        for (uint8_t i = 0; i < NUM_Z_STEPPER_DRIVERS; ++i) {
+        LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
           SERIAL_ECHOLNPAIR("PROBEPT_", i + '1', ": ", z_measured[i]);
           incremental_LSF(&lfd, z_stepper_align.xy[i], z_measured[i]);
         }
         finish_incremental_LSF(&lfd);
 
         z_measured_min = 100000.0f;
-        for (uint8_t i = 0; i < NUM_Z_STEPPER_DRIVERS; ++i) {
+        LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS) {
           z_measured[i] = -(lfd.A * z_stepper_align.stepper_xy[i].x + lfd.B * z_stepper_align.stepper_xy[i].y);
           z_measured_min = _MIN(z_measured_min, z_measured[i]);
         }
@@ -250,12 +254,37 @@ void GcodeSuite::G34() {
         #endif
       );
 
+      #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+        // Check if the applied corrections go in the correct direction.
+        // Calculate the sum of the absolute deviations from the mean of the probe measurements.
+        // Compare to the last iteration to ensure it's getting better.
+
+        // Calculate mean value as a reference
+        float z_measured_mean = 0.0f;
+        LOOP_L_N(zstepper, NUM_Z_STEPPER_DRIVERS) z_measured_mean += z_measured[zstepper];
+        z_measured_mean /= NUM_Z_STEPPER_DRIVERS;
+
+        // Calculate the sum of the absolute deviations from the mean value
+        float z_align_level_indicator = 0.0f;
+        LOOP_L_N(zstepper, NUM_Z_STEPPER_DRIVERS)
+          z_align_level_indicator += ABS(z_measured[zstepper] - z_measured_mean);
+
+        // If it's getting worse, stop and throw an error
+        if (last_z_align_level_indicator < z_align_level_indicator * 0.7f) {
+          SERIAL_ECHOLNPGM("Decreasing accuracy detected.");
+          err_break = true;
+          break;
+        }
+
+        last_z_align_level_indicator = z_align_level_indicator;
+      #endif
+
       // The following correction actions are to be enabled for select Z-steppers only
       stepper.set_separate_multi_axis(true);
 
       bool success_break = true;
       // Correct the individual stepper offsets
-      for (uint8_t zstepper = 0; zstepper < NUM_Z_STEPPER_DRIVERS; ++zstepper) {
+      LOOP_L_N(zstepper, NUM_Z_STEPPER_DRIVERS) {
         // Calculate current stepper move
         float z_align_move = z_measured[zstepper] - z_measured_min;
         const float z_align_abs = ABS(z_align_move);
@@ -263,21 +292,16 @@ void GcodeSuite::G34() {
         #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
           // Optimize one iteration's correction based on the first measurements
           if (z_align_abs) amplification = (iteration == 1) ? _MIN(last_z_align_move[zstepper] / z_align_abs, 2.0f) : z_auto_align_amplification;
-        #endif
 
-        // Check for less accuracy compared to last move
-        if (last_z_align_move[zstepper] < z_align_abs * 0.7f) {
-          SERIAL_ECHOLNPGM("Decreasing accuracy detected.");
-          #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+          // Check for less accuracy compared to last move
+          if (last_z_align_move[zstepper] < z_align_abs * 0.7f) {
+            SERIAL_ECHOLNPGM("Decreasing accuracy detected.");
             adjustment_reverse = !adjustment_reverse;
-          #else
-            err_break = true;
-            break;
-          #endif
-        }
+          }
 
-        // Remember the alignment for the next iteration
-        last_z_align_move[zstepper] = z_align_abs;
+          // Remember the alignment for the next iteration
+          last_z_align_move[zstepper] = z_align_abs;
+        #endif
 
         // Stop early if all measured points achieve accuracy target
         if (z_align_abs > z_auto_align_accuracy) success_break = false;
@@ -322,11 +346,9 @@ void GcodeSuite::G34() {
 
     // Restore the active tool after homing
     #if HOTENDS > 1
-      tool_change(old_tool_index, (
+      tool_change(old_tool_index, (true
         #if ENABLED(PARKING_EXTRUDER)
-          false // Fetch the previous toolhead
-        #else
-          true
+          && false // Fetch the previous toolhead
         #endif
       ));
     #endif
@@ -367,10 +389,10 @@ void GcodeSuite::G34() {
 void GcodeSuite::M422() {
 
   if (!parser.seen_any()) {
-    for (uint8_t i = 0; i < NUM_Z_STEPPER_DRIVERS; ++i)
+    LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS)
       SERIAL_ECHOLNPAIR_P(PSTR("M422 S"), i + '1', SP_X_STR, z_stepper_align.xy[i].x, SP_Y_STR, z_stepper_align.xy[i].y);
     #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-      for (uint8_t i = 0; i < NUM_Z_STEPPER_DRIVERS; ++i)
+      LOOP_L_N(i, NUM_Z_STEPPER_DRIVERS)
         SERIAL_ECHOLNPAIR_P(PSTR("M422 W"), i + '1', SP_X_STR, z_stepper_align.stepper_xy[i].x, SP_Y_STR, z_stepper_align.stepper_xy[i].y);
     #endif
     return;

commit be62ab2d02f58634013a78a2e243a50c1cd4a1c4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 27 06:16:33 2020 -0600

    Move reachable test to Probe class

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index e7bc63828f..7144038ebd 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -432,11 +432,11 @@ void GcodeSuite::M422() {
   };
 
   if (is_probe_point) {
-    if (!position_is_reachable_by_probe(pos.x, Y_CENTER)) {
+    if (!probe.can_reach(pos.x, Y_CENTER)) {
       SERIAL_ECHOLNPGM("?(X) out of bounds.");
       return;
     }
-    if (!position_is_reachable_by_probe(pos)) {
+    if (!probe.can_reach(pos)) {
       SERIAL_ECHOLNPGM("?(Y) out of bounds.");
       return;
     }

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 4532da8f8c..e7bc63828f 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit e58d1bf97405f89d0a720c90a63ad677ca0624b5
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Feb 1 05:50:44 2020 -0500

    G34 automatic point assignment (#16473)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index a35b3faef7..4532da8f8c 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -24,6 +24,8 @@
 
 #if ENABLED(Z_STEPPER_AUTO_ALIGN)
 
+#include "../../feature/z_stepper_align.h"
+
 #include "../gcode.h"
 #include "../../module/planner.h"
 #include "../../module/stepper.h"
@@ -45,68 +47,6 @@
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
 
-//
-// Sanity check G34 / M422 settings
-//
-constexpr xy_pos_t test_z_stepper_align_xy[] = Z_STEPPER_ALIGN_XY;
-
-#if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-
-  static_assert(COUNT(test_z_stepper_align_xy) >= NUM_Z_STEPPER_DRIVERS,
-    "Z_STEPPER_ALIGN_XY requires at least three {X,Y} entries (Z, Z2, Z3, ...)."
-  );
-
-  constexpr float test_z_stepper_align_stepper_xy[][XY] = Z_STEPPER_ALIGN_STEPPER_XY;
-  static_assert(
-    COUNT(test_z_stepper_align_stepper_xy) == NUM_Z_STEPPER_DRIVERS,
-    "Z_STEPPER_ALIGN_STEPPER_XY requires three {X,Y} entries (one per Z stepper)."
-  );
-
-#else
-
-  static_assert(COUNT(test_z_stepper_align_xy) == NUM_Z_STEPPER_DRIVERS,
-    #if NUM_Z_STEPPER_DRIVERS == 4
-      "Z_STEPPER_ALIGN_XY requires four {X,Y} entries (Z, Z2, Z3, and Z4)."
-    #elif NUM_Z_STEPPER_DRIVERS == 3
-      "Z_STEPPER_ALIGN_XY requires three {X,Y} entries (Z, Z2, and Z3)."
-    #else
-      "Z_STEPPER_ALIGN_XY requires two {X,Y} entries (Z and Z2)."
-    #endif
-  );
-
-#endif
-
-constexpr xyz_pos_t dpo = NOZZLE_TO_PROBE_OFFSET;
-
-#define LTEST(N) (test_z_stepper_align_xy[N].x >= _MAX(X_MIN_BED + MIN_PROBE_EDGE_LEFT,  X_MIN_POS + dpo.x) - 0.00001f)
-#define RTEST(N) (test_z_stepper_align_xy[N].x <= _MIN(X_MAX_BED - MIN_PROBE_EDGE_RIGHT, X_MAX_POS + dpo.x) + 0.00001f)
-#define FTEST(N) (test_z_stepper_align_xy[N].y >= _MAX(Y_MIN_BED + MIN_PROBE_EDGE_FRONT, Y_MIN_POS + dpo.y) - 0.00001f)
-#define BTEST(N) (test_z_stepper_align_xy[N].y <= _MIN(Y_MAX_BED - MIN_PROBE_EDGE_BACK,  Y_MAX_POS + dpo.y) + 0.00001f)
-
-static_assert(LTEST(0) && RTEST(0), "The 1st Z_STEPPER_ALIGN_XY X is unreachable with the default probe X offset.");
-static_assert(FTEST(0) && BTEST(0), "The 1st Z_STEPPER_ALIGN_XY Y is unreachable with the default probe Y offset.");
-static_assert(LTEST(1) && RTEST(1), "The 2nd Z_STEPPER_ALIGN_XY X is unreachable with the default probe X offset.");
-static_assert(FTEST(1) && BTEST(1), "The 2nd Z_STEPPER_ALIGN_XY Y is unreachable with the default probe Y offset.");
-#if NUM_Z_STEPPER_DRIVERS >= 3
-  static_assert(LTEST(2) && RTEST(2), "The 3rd Z_STEPPER_ALIGN_XY X is unreachable with the default probe X offset.");
-  static_assert(FTEST(2) && BTEST(2), "The 3rd Z_STEPPER_ALIGN_XY Y is unreachable with the default probe Y offset.");
-  #if NUM_Z_STEPPER_DRIVERS >= 4
-    static_assert(LTEST(3) && RTEST(3), "The 4th Z_STEPPER_ALIGN_XY X is unreachable with the default probe X offset.");
-    static_assert(FTEST(3) && BTEST(3), "The 4th Z_STEPPER_ALIGN_XY Y is unreachable with the default probe Y offset.");
-  #endif
-#endif
-
-//
-// G34 / M422 shared data
-//
-static xy_pos_t z_stepper_align_pos[] = Z_STEPPER_ALIGN_XY;
-
-#if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-  static xy_pos_t z_stepper_align_stepper_pos[] = Z_STEPPER_ALIGN_STEPPER_XY;
-#endif
-
-#define G34_PROBE_COUNT COUNT(z_stepper_align_pos)
-
 inline void set_all_z_lock(const bool lock) {
   stepper.set_z_lock(lock);
   stepper.set_z2_lock(lock);
@@ -201,11 +141,11 @@ void GcodeSuite::G34() {
     // iteration this will be re-calculated based on the actual bed position
     float z_probe = Z_BASIC_CLEARANCE + (G34_MAX_GRADE) * 0.01f * (
       #if NUM_Z_STEPPER_DRIVERS == 3
-         SQRT(_MAX(HYPOT2(z_stepper_align_pos[0].x - z_stepper_align_pos[0].y, z_stepper_align_pos[1].x - z_stepper_align_pos[1].y),
-                   HYPOT2(z_stepper_align_pos[1].x - z_stepper_align_pos[1].y, z_stepper_align_pos[2].x - z_stepper_align_pos[2].y),
-                   HYPOT2(z_stepper_align_pos[2].x - z_stepper_align_pos[2].y, z_stepper_align_pos[0].x - z_stepper_align_pos[0].y)))
+         SQRT(_MAX(HYPOT2(z_stepper_align.xy[0].x - z_stepper_align.xy[0].y, z_stepper_align.xy[1].x - z_stepper_align.xy[1].y),
+                   HYPOT2(z_stepper_align.xy[1].x - z_stepper_align.xy[1].y, z_stepper_align.xy[2].x - z_stepper_align.xy[2].y),
+                   HYPOT2(z_stepper_align.xy[2].x - z_stepper_align.xy[2].y, z_stepper_align.xy[0].x - z_stepper_align.xy[0].y)))
       #else
-         HYPOT(z_stepper_align_pos[0].x - z_stepper_align_pos[0].y, z_stepper_align_pos[1].x - z_stepper_align_pos[1].y)
+         HYPOT(z_stepper_align.xy[0].x - z_stepper_align.xy[0].y, z_stepper_align.xy[1].x - z_stepper_align.xy[1].y)
       #endif
     );
 
@@ -216,31 +156,39 @@ void GcodeSuite::G34() {
     current_position.z -= z_probe * 0.5f;
 
     float last_z_align_move[NUM_Z_STEPPER_DRIVERS] = ARRAY_N(NUM_Z_STEPPER_DRIVERS, 10000.0f, 10000.0f, 10000.0f),
-          z_measured[G34_PROBE_COUNT] = { 0 },
+          z_measured[NUM_Z_STEPPER_DRIVERS] = { 0 },
           z_maxdiff = 0.0f,
           amplification = z_auto_align_amplification;
 
     uint8_t iteration;
     bool err_break = false;
+
+    #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+      bool adjustment_reverse = false;
+    #endif
+
     for (iteration = 0; iteration < z_auto_align_iterations; ++iteration) {
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> probing all positions.");
 
       SERIAL_ECHOLNPAIR("\nITERATION: ", int(iteration + 1));
 
       // Initialize minimum value
-      float z_measured_min = 100000.0f,
+      float z_measured_min =  100000.0f,
             z_measured_max = -100000.0f;
 
       // Probe all positions (one per Z-Stepper)
-      for (uint8_t i = 0; i < G34_PROBE_COUNT; ++i) {
+      for (uint8_t i = 0; i < NUM_Z_STEPPER_DRIVERS; ++i) {
         // iteration odd/even --> downward / upward stepper sequence
-        const uint8_t iprobe = (iteration & 1) ? G34_PROBE_COUNT - 1 - i : i;
+        const uint8_t iprobe = (iteration & 1) ? NUM_Z_STEPPER_DRIVERS - 1 - i : i;
 
         // Safe clearance even on an incline
         if (iteration == 0 || i > 0) do_blocking_move_to_z(z_probe);
 
+        if (DEBUGGING(LEVELING))
+          DEBUG_ECHOLNPAIR_P(PSTR("Probing X"), z_stepper_align.xy[iprobe].x, SP_Y_STR, z_stepper_align.xy[iprobe].y);
+
         // Probe a Z height for each stepper.
-        const float z_probed_height = probe.probe_at_point(z_stepper_align_pos[iprobe], raise_after, 0, true);
+        const float z_probed_height = probe.probe_at_point(z_stepper_align.xy[iprobe], raise_after, 0, true);
         if (isnan(z_probed_height)) {
           SERIAL_ECHOLNPGM("Probing failed.");
           err_break = true;
@@ -279,15 +227,15 @@ void GcodeSuite::G34() {
         // This allows the actual adjustment logic to be shared by both algorithms.
         linear_fit_data lfd;
         incremental_LSF_reset(&lfd);
-        for (uint8_t i = 0; i < G34_PROBE_COUNT; ++i) {
-          SERIAL_ECHOLNPAIR("PROBEPT_", int(i + 1), ": ", z_measured[i]);
-          incremental_LSF(&lfd, z_stepper_align_pos[i], z_measured[i]);
+        for (uint8_t i = 0; i < NUM_Z_STEPPER_DRIVERS; ++i) {
+          SERIAL_ECHOLNPAIR("PROBEPT_", i + '1', ": ", z_measured[i]);
+          incremental_LSF(&lfd, z_stepper_align.xy[i], z_measured[i]);
         }
         finish_incremental_LSF(&lfd);
 
         z_measured_min = 100000.0f;
         for (uint8_t i = 0; i < NUM_Z_STEPPER_DRIVERS; ++i) {
-          z_measured[i] = -(lfd.A * z_stepper_align_stepper_pos[i].x + lfd.B * z_stepper_align_stepper_pos[i].y);
+          z_measured[i] = -(lfd.A * z_stepper_align.stepper_xy[i].x + lfd.B * z_stepper_align.stepper_xy[i].y);
           z_measured_min = _MIN(z_measured_min, z_measured[i]);
         }
 
@@ -309,8 +257,8 @@ void GcodeSuite::G34() {
       // Correct the individual stepper offsets
       for (uint8_t zstepper = 0; zstepper < NUM_Z_STEPPER_DRIVERS; ++zstepper) {
         // Calculate current stepper move
-        const float z_align_move = z_measured[zstepper] - z_measured_min,
-                    z_align_abs = ABS(z_align_move);
+        float z_align_move = z_measured[zstepper] - z_measured_min;
+        const float z_align_abs = ABS(z_align_move);
 
         #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
           // Optimize one iteration's correction based on the first measurements
@@ -318,10 +266,14 @@ void GcodeSuite::G34() {
         #endif
 
         // Check for less accuracy compared to last move
-        if (last_z_align_move[zstepper] < z_align_abs - 1.0) {
+        if (last_z_align_move[zstepper] < z_align_abs * 0.7f) {
           SERIAL_ECHOLNPGM("Decreasing accuracy detected.");
-          err_break = true;
-          break;
+          #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+            adjustment_reverse = !adjustment_reverse;
+          #else
+            err_break = true;
+            break;
+          #endif
         }
 
         // Remember the alignment for the next iteration
@@ -342,6 +294,13 @@ void GcodeSuite::G34() {
           #endif
         }
 
+        #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+          // Decreasing accuracy was detected so move was inverted.
+          // Will match reversed Z steppers on dual steppers. Triple will need more work to map.
+          if (adjustment_reverse)
+            z_align_move = -z_align_move;
+        #endif
+
         // Do a move to correct part of the misalignment for the current stepper
         do_blocking_move_to_z(amplification * z_align_move + current_position.z);
       } // for (zstepper)
@@ -406,12 +365,13 @@ void GcodeSuite::G34() {
  *   Y<pos>   : Y position to set (Unchanged if omitted)
  */
 void GcodeSuite::M422() {
+
   if (!parser.seen_any()) {
-    for (uint8_t i = 0; i < G34_PROBE_COUNT; ++i)
-      SERIAL_ECHOLNPAIR_P(PSTR("M422 S"), i + 1, SP_X_STR, z_stepper_align_pos[i].x, SP_Y_STR, z_stepper_align_pos[i].y);
+    for (uint8_t i = 0; i < NUM_Z_STEPPER_DRIVERS; ++i)
+      SERIAL_ECHOLNPAIR_P(PSTR("M422 S"), i + '1', SP_X_STR, z_stepper_align.xy[i].x, SP_Y_STR, z_stepper_align.xy[i].y);
     #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
       for (uint8_t i = 0; i < NUM_Z_STEPPER_DRIVERS; ++i)
-        SERIAL_ECHOLNPAIR_P(PSTR("M422 W"), i + 1, SP_X_STR, z_stepper_align_stepper_pos[i].x, SP_Y_STR, z_stepper_align_stepper_pos[i].y);
+        SERIAL_ECHOLNPAIR_P(PSTR("M422 W"), i + '1', SP_X_STR, z_stepper_align.stepper_xy[i].x, SP_Y_STR, z_stepper_align.stepper_xy[i].y);
     #endif
     return;
   }
@@ -427,9 +387,9 @@ void GcodeSuite::M422() {
 
   xy_pos_t *pos_dest = (
     #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-      !is_probe_point ? z_stepper_align_stepper_pos :
+      !is_probe_point ? z_stepper_align.stepper_xy :
     #endif
-    z_stepper_align_pos
+    z_stepper_align.xy
   );
 
   if (!is_probe_point
@@ -451,7 +411,7 @@ void GcodeSuite::M422() {
   int8_t position_index;
   if (is_probe_point) {
     position_index = parser.intval('S') - 1;
-    if (!WITHIN(position_index, 0, int8_t(G34_PROBE_COUNT) - 1)) {
+    if (!WITHIN(position_index, 0, int8_t(NUM_Z_STEPPER_DRIVERS) - 1)) {
       SERIAL_ECHOLNPGM("?(S) Z-ProbePosition index invalid.");
       return;
     }

commit 90b6324563b806ea7dc24ddf299f055dc4854341
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 04:21:36 2020 -0600

    Encapsulate probe as singleton class (#16751)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 2c284de681..a35b3faef7 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -133,8 +133,8 @@ void GcodeSuite::G34() {
 
   do { // break out on error
 
-    #if NUM_Z_STEPPER_DRIVERS == 4
-      SERIAL_ECHOLNPGM("Quad Z Stepper Leveling not Yet Supported");
+    #if NUM_Z_STEPPER_DRIVERS >= 4
+      SERIAL_ECHOLNPGM("Alignment not supported for over 3 steppers");
       break;
     #endif
 
@@ -240,7 +240,7 @@ void GcodeSuite::G34() {
         if (iteration == 0 || i > 0) do_blocking_move_to_z(z_probe);
 
         // Probe a Z height for each stepper.
-        const float z_probed_height = probe_at_point(z_stepper_align_pos[iprobe], raise_after, 0, true);
+        const float z_probed_height = probe.probe_at_point(z_stepper_align_pos[iprobe], raise_after, 0, true);
         if (isnan(z_probed_height)) {
           SERIAL_ECHOLNPGM("Probing failed.");
           err_break = true;
@@ -314,7 +314,7 @@ void GcodeSuite::G34() {
 
         #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
           // Optimize one iteration's correction based on the first measurements
-          if (z_align_abs > 0.0f) amplification = iteration == 1 ? _MIN(last_z_align_move[zstepper] / z_align_abs, 2.0f) : z_auto_align_amplification;
+          if (z_align_abs) amplification = (iteration == 1) ? _MIN(last_z_align_move[zstepper] / z_align_abs, 2.0f) : z_auto_align_amplification;
         #endif
 
         // Check for less accuracy compared to last move
@@ -379,9 +379,9 @@ void GcodeSuite::G34() {
     // After this operation the z position needs correction
     set_axis_is_not_at_home(Z_AXIS);
 
-    // Stow the probe, as the last call to probe_at_point(...) left
+    // Stow the probe, as the last call to probe.probe_at_point(...) left
     // the probe deployed if it was successful.
-    STOW_PROBE();
+    probe.stow();
 
     // Home Z after the alignment procedure
     process_subcommands_now_P(PSTR("G28 Z"));

commit 0fcf2b1110d9f0d362e5aab9cc73d963710e9865
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jan 20 00:35:07 2020 -0500

    Quad Z stepper support (#16277)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 418633f03f..2c284de681 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -52,20 +52,22 @@ constexpr xy_pos_t test_z_stepper_align_xy[] = Z_STEPPER_ALIGN_XY;
 
 #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
 
-  static_assert(COUNT(test_z_stepper_align_xy) >= Z_STEPPER_COUNT,
+  static_assert(COUNT(test_z_stepper_align_xy) >= NUM_Z_STEPPER_DRIVERS,
     "Z_STEPPER_ALIGN_XY requires at least three {X,Y} entries (Z, Z2, Z3, ...)."
   );
 
   constexpr float test_z_stepper_align_stepper_xy[][XY] = Z_STEPPER_ALIGN_STEPPER_XY;
   static_assert(
-    COUNT(test_z_stepper_align_stepper_xy) == Z_STEPPER_COUNT,
+    COUNT(test_z_stepper_align_stepper_xy) == NUM_Z_STEPPER_DRIVERS,
     "Z_STEPPER_ALIGN_STEPPER_XY requires three {X,Y} entries (one per Z stepper)."
   );
 
 #else
 
-  static_assert(COUNT(test_z_stepper_align_xy) == Z_STEPPER_COUNT,
-    #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+  static_assert(COUNT(test_z_stepper_align_xy) == NUM_Z_STEPPER_DRIVERS,
+    #if NUM_Z_STEPPER_DRIVERS == 4
+      "Z_STEPPER_ALIGN_XY requires four {X,Y} entries (Z, Z2, Z3, and Z4)."
+    #elif NUM_Z_STEPPER_DRIVERS == 3
       "Z_STEPPER_ALIGN_XY requires three {X,Y} entries (Z, Z2, and Z3)."
     #else
       "Z_STEPPER_ALIGN_XY requires two {X,Y} entries (Z and Z2)."
@@ -85,10 +87,13 @@ static_assert(LTEST(0) && RTEST(0), "The 1st Z_STEPPER_ALIGN_XY X is unreachable
 static_assert(FTEST(0) && BTEST(0), "The 1st Z_STEPPER_ALIGN_XY Y is unreachable with the default probe Y offset.");
 static_assert(LTEST(1) && RTEST(1), "The 2nd Z_STEPPER_ALIGN_XY X is unreachable with the default probe X offset.");
 static_assert(FTEST(1) && BTEST(1), "The 2nd Z_STEPPER_ALIGN_XY Y is unreachable with the default probe Y offset.");
-
-#if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+#if NUM_Z_STEPPER_DRIVERS >= 3
   static_assert(LTEST(2) && RTEST(2), "The 3rd Z_STEPPER_ALIGN_XY X is unreachable with the default probe X offset.");
   static_assert(FTEST(2) && BTEST(2), "The 3rd Z_STEPPER_ALIGN_XY Y is unreachable with the default probe Y offset.");
+  #if NUM_Z_STEPPER_DRIVERS >= 4
+    static_assert(LTEST(3) && RTEST(3), "The 4th Z_STEPPER_ALIGN_XY X is unreachable with the default probe X offset.");
+    static_assert(FTEST(3) && BTEST(3), "The 4th Z_STEPPER_ALIGN_XY Y is unreachable with the default probe Y offset.");
+  #endif
 #endif
 
 //
@@ -105,8 +110,11 @@ static xy_pos_t z_stepper_align_pos[] = Z_STEPPER_ALIGN_XY;
 inline void set_all_z_lock(const bool lock) {
   stepper.set_z_lock(lock);
   stepper.set_z2_lock(lock);
-  #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+  #if NUM_Z_STEPPER_DRIVERS >= 3
     stepper.set_z3_lock(lock);
+    #if NUM_Z_STEPPER_DRIVERS >= 4
+      stepper.set_z4_lock(lock);
+    #endif
   #endif
 }
 
@@ -125,6 +133,11 @@ void GcodeSuite::G34() {
 
   do { // break out on error
 
+    #if NUM_Z_STEPPER_DRIVERS == 4
+      SERIAL_ECHOLNPGM("Quad Z Stepper Leveling not Yet Supported");
+      break;
+    #endif
+
     const int8_t z_auto_align_iterations = parser.intval('I', Z_STEPPER_ALIGN_ITERATIONS);
     if (!WITHIN(z_auto_align_iterations, 1, 30)) {
       SERIAL_ECHOLNPGM("?(I)teration out of bounds (1-30).");
@@ -187,7 +200,7 @@ void GcodeSuite::G34() {
     // Compute a worst-case clearance height to probe from. After the first
     // iteration this will be re-calculated based on the actual bed position
     float z_probe = Z_BASIC_CLEARANCE + (G34_MAX_GRADE) * 0.01f * (
-      #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+      #if NUM_Z_STEPPER_DRIVERS == 3
          SQRT(_MAX(HYPOT2(z_stepper_align_pos[0].x - z_stepper_align_pos[0].y, z_stepper_align_pos[1].x - z_stepper_align_pos[1].y),
                    HYPOT2(z_stepper_align_pos[1].x - z_stepper_align_pos[1].y, z_stepper_align_pos[2].x - z_stepper_align_pos[2].y),
                    HYPOT2(z_stepper_align_pos[2].x - z_stepper_align_pos[2].y, z_stepper_align_pos[0].x - z_stepper_align_pos[0].y)))
@@ -202,7 +215,7 @@ void GcodeSuite::G34() {
     // Move the Z coordinate realm towards the positive - dirty trick
     current_position.z -= z_probe * 0.5f;
 
-    float last_z_align_move[Z_STEPPER_COUNT] = ARRAY_N(Z_STEPPER_COUNT, 10000.0f, 10000.0f, 10000.0f),
+    float last_z_align_move[NUM_Z_STEPPER_DRIVERS] = ARRAY_N(NUM_Z_STEPPER_DRIVERS, 10000.0f, 10000.0f, 10000.0f),
           z_measured[G34_PROBE_COUNT] = { 0 },
           z_maxdiff = 0.0f,
           amplification = z_auto_align_amplification;
@@ -273,7 +286,7 @@ void GcodeSuite::G34() {
         finish_incremental_LSF(&lfd);
 
         z_measured_min = 100000.0f;
-        for (uint8_t i = 0; i < Z_STEPPER_COUNT; ++i) {
+        for (uint8_t i = 0; i < NUM_Z_STEPPER_DRIVERS; ++i) {
           z_measured[i] = -(lfd.A * z_stepper_align_stepper_pos[i].x + lfd.B * z_stepper_align_stepper_pos[i].y);
           z_measured_min = _MIN(z_measured_min, z_measured[i]);
         }
@@ -283,7 +296,7 @@ void GcodeSuite::G34() {
 
       SERIAL_ECHOLNPAIR("\n"
         "DIFFERENCE Z1-Z2=", ABS(z_measured[0] - z_measured[1])
-        #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+        #if NUM_Z_STEPPER_DRIVERS == 3
           , " Z2-Z3=", ABS(z_measured[1] - z_measured[2])
           , " Z3-Z1=", ABS(z_measured[2] - z_measured[0])
         #endif
@@ -294,7 +307,7 @@ void GcodeSuite::G34() {
 
       bool success_break = true;
       // Correct the individual stepper offsets
-      for (uint8_t zstepper = 0; zstepper < Z_STEPPER_COUNT; ++zstepper) {
+      for (uint8_t zstepper = 0; zstepper < NUM_Z_STEPPER_DRIVERS; ++zstepper) {
         // Calculate current stepper move
         const float z_align_move = z_measured[zstepper] - z_measured_min,
                     z_align_abs = ABS(z_align_move);
@@ -324,7 +337,7 @@ void GcodeSuite::G34() {
         switch (zstepper) {
           case 0: stepper.set_z_lock(false); break;
           case 1: stepper.set_z2_lock(false); break;
-          #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+          #if NUM_Z_STEPPER_DRIVERS == 3
             case 2: stepper.set_z3_lock(false); break;
           #endif
         }
@@ -397,7 +410,7 @@ void GcodeSuite::M422() {
     for (uint8_t i = 0; i < G34_PROBE_COUNT; ++i)
       SERIAL_ECHOLNPAIR_P(PSTR("M422 S"), i + 1, SP_X_STR, z_stepper_align_pos[i].x, SP_Y_STR, z_stepper_align_pos[i].y);
     #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-      for (uint8_t i = 0; i < Z_STEPPER_COUNT; ++i)
+      for (uint8_t i = 0; i < NUM_Z_STEPPER_DRIVERS; ++i)
         SERIAL_ECHOLNPAIR_P(PSTR("M422 W"), i + 1, SP_X_STR, z_stepper_align_stepper_pos[i].x, SP_Y_STR, z_stepper_align_stepper_pos[i].y);
     #endif
     return;
@@ -446,7 +459,7 @@ void GcodeSuite::M422() {
   else {
     #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
       position_index = parser.intval('W') - 1;
-      if (!WITHIN(position_index, 0, Z_STEPPER_COUNT - 1)) {
+      if (!WITHIN(position_index, 0, NUM_Z_STEPPER_DRIVERS - 1)) {
         SERIAL_ECHOLNPGM("?(W) Z-Stepper index invalid.");
         return;
       }

commit 0b6c2d893e0f735aa54421f89994b32f8b05a095
Author: randellhodges <rhodges@taxfodder.com>
Date:   Fri Dec 20 22:03:37 2019 -0600

    Fix G34 with Z_DUAL_STEPPER_DRIVERS compile (#16274)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index af0b096795..418633f03f 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -85,8 +85,11 @@ static_assert(LTEST(0) && RTEST(0), "The 1st Z_STEPPER_ALIGN_XY X is unreachable
 static_assert(FTEST(0) && BTEST(0), "The 1st Z_STEPPER_ALIGN_XY Y is unreachable with the default probe Y offset.");
 static_assert(LTEST(1) && RTEST(1), "The 2nd Z_STEPPER_ALIGN_XY X is unreachable with the default probe X offset.");
 static_assert(FTEST(1) && BTEST(1), "The 2nd Z_STEPPER_ALIGN_XY Y is unreachable with the default probe Y offset.");
-static_assert(LTEST(2) && RTEST(2), "The 3rd Z_STEPPER_ALIGN_XY X is unreachable with the default probe X offset.");
-static_assert(FTEST(2) && BTEST(2), "The 3rd Z_STEPPER_ALIGN_XY Y is unreachable with the default probe Y offset.");
+
+#if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+  static_assert(LTEST(2) && RTEST(2), "The 3rd Z_STEPPER_ALIGN_XY X is unreachable with the default probe X offset.");
+  static_assert(FTEST(2) && BTEST(2), "The 3rd Z_STEPPER_ALIGN_XY Y is unreachable with the default probe Y offset.");
+#endif
 
 //
 // G34 / M422 shared data

commit dcdaa2025fe0281d8b274cd5ef0db84d330f40de
Author: Moshi Binyamini <MoshiBin@users.noreply.github.com>
Date:   Thu Dec 19 08:59:01 2019 +0200

    Sanity-check Z_STEPPER_AUTO_ALIGN coordinates (#16231)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 1f7339679a..af0b096795 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -45,22 +45,49 @@
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
 
-// Sanity-check the count of Z_STEPPER_ALIGN_XY points
-constexpr xy_pos_t sanity_arr_z_align[] = Z_STEPPER_ALIGN_XY;
+//
+// Sanity check G34 / M422 settings
+//
+constexpr xy_pos_t test_z_stepper_align_xy[] = Z_STEPPER_ALIGN_XY;
+
 #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-  static_assert(COUNT(sanity_arr_z_align) >= Z_STEPPER_COUNT,
+
+  static_assert(COUNT(test_z_stepper_align_xy) >= Z_STEPPER_COUNT,
     "Z_STEPPER_ALIGN_XY requires at least three {X,Y} entries (Z, Z2, Z3, ...)."
   );
+
+  constexpr float test_z_stepper_align_stepper_xy[][XY] = Z_STEPPER_ALIGN_STEPPER_XY;
+  static_assert(
+    COUNT(test_z_stepper_align_stepper_xy) == Z_STEPPER_COUNT,
+    "Z_STEPPER_ALIGN_STEPPER_XY requires three {X,Y} entries (one per Z stepper)."
+  );
+
 #else
-  static_assert(COUNT(sanity_arr_z_align) == Z_STEPPER_COUNT,
+
+  static_assert(COUNT(test_z_stepper_align_xy) == Z_STEPPER_COUNT,
     #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
       "Z_STEPPER_ALIGN_XY requires three {X,Y} entries (Z, Z2, and Z3)."
     #else
       "Z_STEPPER_ALIGN_XY requires two {X,Y} entries (Z and Z2)."
     #endif
   );
+
 #endif
 
+constexpr xyz_pos_t dpo = NOZZLE_TO_PROBE_OFFSET;
+
+#define LTEST(N) (test_z_stepper_align_xy[N].x >= _MAX(X_MIN_BED + MIN_PROBE_EDGE_LEFT,  X_MIN_POS + dpo.x) - 0.00001f)
+#define RTEST(N) (test_z_stepper_align_xy[N].x <= _MIN(X_MAX_BED - MIN_PROBE_EDGE_RIGHT, X_MAX_POS + dpo.x) + 0.00001f)
+#define FTEST(N) (test_z_stepper_align_xy[N].y >= _MAX(Y_MIN_BED + MIN_PROBE_EDGE_FRONT, Y_MIN_POS + dpo.y) - 0.00001f)
+#define BTEST(N) (test_z_stepper_align_xy[N].y <= _MIN(Y_MAX_BED - MIN_PROBE_EDGE_BACK,  Y_MAX_POS + dpo.y) + 0.00001f)
+
+static_assert(LTEST(0) && RTEST(0), "The 1st Z_STEPPER_ALIGN_XY X is unreachable with the default probe X offset.");
+static_assert(FTEST(0) && BTEST(0), "The 1st Z_STEPPER_ALIGN_XY Y is unreachable with the default probe Y offset.");
+static_assert(LTEST(1) && RTEST(1), "The 2nd Z_STEPPER_ALIGN_XY X is unreachable with the default probe X offset.");
+static_assert(FTEST(1) && BTEST(1), "The 2nd Z_STEPPER_ALIGN_XY Y is unreachable with the default probe Y offset.");
+static_assert(LTEST(2) && RTEST(2), "The 3rd Z_STEPPER_ALIGN_XY X is unreachable with the default probe X offset.");
+static_assert(FTEST(2) && BTEST(2), "The 3rd Z_STEPPER_ALIGN_XY Y is unreachable with the default probe Y offset.");
+
 //
 // G34 / M422 shared data
 //

commit 04007834444d88f50455964ca08b4b18a29bc7c6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Dec 19 00:39:09 2019 -0600

    Tweak G34, fix a declaration

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 704d370c4f..1f7339679a 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -61,13 +61,16 @@ constexpr xy_pos_t sanity_arr_z_align[] = Z_STEPPER_ALIGN_XY;
   );
 #endif
 
-static xy_pos_t z_auto_align_pos[Z_STEPPER_COUNT] = Z_STEPPER_ALIGN_XY;
+//
+// G34 / M422 shared data
+//
+static xy_pos_t z_stepper_align_pos[] = Z_STEPPER_ALIGN_XY;
 
 #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-  static xy_pos_t z_stepper_pos[] = Z_STEPPER_ALIGN_STEPPER_XY;
+  static xy_pos_t z_stepper_align_stepper_pos[] = Z_STEPPER_ALIGN_STEPPER_XY;
 #endif
 
-#define G34_PROBE_COUNT COUNT(z_auto_align_pos)
+#define G34_PROBE_COUNT COUNT(z_stepper_align_pos)
 
 inline void set_all_z_lock(const bool lock) {
   stepper.set_z_lock(lock);
@@ -155,11 +158,11 @@ void GcodeSuite::G34() {
     // iteration this will be re-calculated based on the actual bed position
     float z_probe = Z_BASIC_CLEARANCE + (G34_MAX_GRADE) * 0.01f * (
       #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
-         SQRT(_MAX(HYPOT2(z_auto_align_pos[0].x - z_auto_align_pos[0].y, z_auto_align_pos[1].x - z_auto_align_pos[1].y),
-                   HYPOT2(z_auto_align_pos[1].x - z_auto_align_pos[1].y, z_auto_align_pos[2].x - z_auto_align_pos[2].y),
-                   HYPOT2(z_auto_align_pos[2].x - z_auto_align_pos[2].y, z_auto_align_pos[0].x - z_auto_align_pos[0].y)))
+         SQRT(_MAX(HYPOT2(z_stepper_align_pos[0].x - z_stepper_align_pos[0].y, z_stepper_align_pos[1].x - z_stepper_align_pos[1].y),
+                   HYPOT2(z_stepper_align_pos[1].x - z_stepper_align_pos[1].y, z_stepper_align_pos[2].x - z_stepper_align_pos[2].y),
+                   HYPOT2(z_stepper_align_pos[2].x - z_stepper_align_pos[2].y, z_stepper_align_pos[0].x - z_stepper_align_pos[0].y)))
       #else
-         HYPOT(z_auto_align_pos[0].x - z_auto_align_pos[0].y, z_auto_align_pos[1].x - z_auto_align_pos[1].y)
+         HYPOT(z_stepper_align_pos[0].x - z_stepper_align_pos[0].y, z_stepper_align_pos[1].x - z_stepper_align_pos[1].y)
       #endif
     );
 
@@ -194,7 +197,7 @@ void GcodeSuite::G34() {
         if (iteration == 0 || i > 0) do_blocking_move_to_z(z_probe);
 
         // Probe a Z height for each stepper.
-        const float z_probed_height = probe_at_point(z_auto_align_pos[iprobe], raise_after, 0, true);
+        const float z_probed_height = probe_at_point(z_stepper_align_pos[iprobe], raise_after, 0, true);
         if (isnan(z_probed_height)) {
           SERIAL_ECHOLNPGM("Probing failed.");
           err_break = true;
@@ -235,13 +238,13 @@ void GcodeSuite::G34() {
         incremental_LSF_reset(&lfd);
         for (uint8_t i = 0; i < G34_PROBE_COUNT; ++i) {
           SERIAL_ECHOLNPAIR("PROBEPT_", int(i + 1), ": ", z_measured[i]);
-          incremental_LSF(&lfd, z_auto_align_pos[i], z_measured[i]);
+          incremental_LSF(&lfd, z_stepper_align_pos[i], z_measured[i]);
         }
         finish_incremental_LSF(&lfd);
 
         z_measured_min = 100000.0f;
         for (uint8_t i = 0; i < Z_STEPPER_COUNT; ++i) {
-          z_measured[i] = -(lfd.A * z_stepper_pos[i].x + lfd.B * z_stepper_pos[i].y);
+          z_measured[i] = -(lfd.A * z_stepper_align_stepper_pos[i].x + lfd.B * z_stepper_align_stepper_pos[i].y);
           z_measured_min = _MIN(z_measured_min, z_measured[i]);
         }
 
@@ -362,10 +365,10 @@ void GcodeSuite::G34() {
 void GcodeSuite::M422() {
   if (!parser.seen_any()) {
     for (uint8_t i = 0; i < G34_PROBE_COUNT; ++i)
-      SERIAL_ECHOLNPAIR_P(PSTR("M422 S"), i + 1, SP_X_STR, z_auto_align_pos[i].x, SP_Y_STR, z_auto_align_pos[i].y);
+      SERIAL_ECHOLNPAIR_P(PSTR("M422 S"), i + 1, SP_X_STR, z_stepper_align_pos[i].x, SP_Y_STR, z_stepper_align_pos[i].y);
     #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
       for (uint8_t i = 0; i < Z_STEPPER_COUNT; ++i)
-        SERIAL_ECHOLNPAIR_P(PSTR("M422 W"), i + 1, SP_X_STR, z_stepper_pos[i].x, SP_Y_STR, z_stepper_pos[i].y);
+        SERIAL_ECHOLNPAIR_P(PSTR("M422 W"), i + 1, SP_X_STR, z_stepper_align_stepper_pos[i].x, SP_Y_STR, z_stepper_align_stepper_pos[i].y);
     #endif
     return;
   }
@@ -381,9 +384,9 @@ void GcodeSuite::M422() {
 
   xy_pos_t *pos_dest = (
     #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
-      !is_probe_point ? z_stepper_pos :
+      !is_probe_point ? z_stepper_align_stepper_pos :
     #endif
-    z_auto_align_pos
+    z_stepper_align_pos
   );
 
   if (!is_probe_point

commit f83bc0aa13e8cf2d92ec138576cc3a620e74a982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 29 04:45:07 2019 -0600

    Optimize common strings
    
    Saves 128 bytes in testing with `mftest mega 1 -y`

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index d74a9ce5da..704d370c4f 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -362,10 +362,10 @@ void GcodeSuite::G34() {
 void GcodeSuite::M422() {
   if (!parser.seen_any()) {
     for (uint8_t i = 0; i < G34_PROBE_COUNT; ++i)
-      SERIAL_ECHOLNPAIR("M422 S", i + 1, " X", z_auto_align_pos[i].x, " Y", z_auto_align_pos[i].y);
+      SERIAL_ECHOLNPAIR_P(PSTR("M422 S"), i + 1, SP_X_STR, z_auto_align_pos[i].x, SP_Y_STR, z_auto_align_pos[i].y);
     #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
       for (uint8_t i = 0; i < Z_STEPPER_COUNT; ++i)
-        SERIAL_ECHOLNPAIR("M422 W", i + 1, " X", z_stepper_pos[i].x, " Y", z_stepper_pos[i].y);
+        SERIAL_ECHOLNPAIR_P(PSTR("M422 W"), i + 1, SP_X_STR, z_stepper_pos[i].x, SP_Y_STR, z_stepper_pos[i].y);
     #endif
     return;
   }

commit 7116a8645ce6a01ec3bb1f19635e02e24d9611d6
Author: Evgeny-SPB <en.kudryavtsev@gmail.com>
Date:   Wed Nov 20 08:25:07 2019 +0300

    G34 logic / typo fix (#15938)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 7f1d086d45..d74a9ce5da 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -194,7 +194,7 @@ void GcodeSuite::G34() {
         if (iteration == 0 || i > 0) do_blocking_move_to_z(z_probe);
 
         // Probe a Z height for each stepper.
-        const float z_probed_height = probe_at_point(z_auto_align_pos[i], raise_after, 0, true);
+        const float z_probed_height = probe_at_point(z_auto_align_pos[iprobe], raise_after, 0, true);
         if (isnan(z_probed_height)) {
           SERIAL_ECHOLNPGM("Probing failed.");
           err_break = true;

commit cd3ec5a77b6488546fb70fb7ddd3229f0dd1513f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 24 12:52:20 2019 -0500

    Add error-check to M422

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 4bb37d2f85..7f1d086d45 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -386,6 +386,21 @@ void GcodeSuite::M422() {
     z_auto_align_pos
   );
 
+  if (!is_probe_point
+    #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+      && !parser.seen('W')
+    #endif
+  ) {
+    SERIAL_ECHOLNPGM(
+      #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+        "?(S) or (W) is required."
+      #else
+        "?(S) is required."
+      #endif
+    );
+    return;
+  }
+
   // Get the Probe Position Index or Z Stepper Index
   int8_t position_index;
   if (is_probe_point) {

commit 832cb7e1ac33663834a69f2d377fbf47451d73d4
Author: Jason Smith <jason.inet@gmail.com>
Date:   Wed Oct 16 11:39:58 2019 -0700

    Z_STEPPER_AUTO_ALIGN ‚Äî To align with Z stepper points (#15195)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 48ed8fe986..4bb37d2f85 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -25,37 +25,49 @@
 #if ENABLED(Z_STEPPER_AUTO_ALIGN)
 
 #include "../gcode.h"
-#include "../../module/delta.h"
-#include "../../module/motion.h"
+#include "../../module/planner.h"
 #include "../../module/stepper.h"
-#include "../../module/endstops.h"
+#include "../../module/motion.h"
+#include "../../module/probe.h"
 
 #if HOTENDS > 1
   #include "../../module/tool_change.h"
 #endif
 
-#if HAS_BED_PROBE
-  #include "../../module/probe.h"
-#endif
-
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
+#if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+   #include "../../libs/least_squares_fit.h"
+#endif
+
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
 
-// Sanity-check
+// Sanity-check the count of Z_STEPPER_ALIGN_XY points
 constexpr xy_pos_t sanity_arr_z_align[] = Z_STEPPER_ALIGN_XY;
-static_assert(COUNT(sanity_arr_z_align) == Z_STEPPER_COUNT,
-  #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
-    "Z_STEPPER_ALIGN_XY requires three {X,Y} entries (Z, Z2, and Z3)."
-  #else
-    "Z_STEPPER_ALIGN_XY requires two {X,Y} entries (Z and Z2)."
-  #endif
-);
+#if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+  static_assert(COUNT(sanity_arr_z_align) >= Z_STEPPER_COUNT,
+    "Z_STEPPER_ALIGN_XY requires at least three {X,Y} entries (Z, Z2, Z3, ...)."
+  );
+#else
+  static_assert(COUNT(sanity_arr_z_align) == Z_STEPPER_COUNT,
+    #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+      "Z_STEPPER_ALIGN_XY requires three {X,Y} entries (Z, Z2, and Z3)."
+    #else
+      "Z_STEPPER_ALIGN_XY requires two {X,Y} entries (Z and Z2)."
+    #endif
+  );
+#endif
+
+static xy_pos_t z_auto_align_pos[Z_STEPPER_COUNT] = Z_STEPPER_ALIGN_XY;
+
+#if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+  static xy_pos_t z_stepper_pos[] = Z_STEPPER_ALIGN_STEPPER_XY;
+#endif
 
-xy_pos_t z_auto_align_pos[Z_STEPPER_COUNT] = Z_STEPPER_ALIGN_XY;
+#define G34_PROBE_COUNT COUNT(z_auto_align_pos)
 
 inline void set_all_z_lock(const bool lock) {
   stepper.set_z_lock(lock);
@@ -68,7 +80,9 @@ inline void set_all_z_lock(const bool lock) {
 /**
  * G34: Z-Stepper automatic alignment
  *
- * Parameters: I<iterations> T<accuracy> A<amplification>
+ *   I<iterations>
+ *   T<accuracy>
+ *   A<amplification>
  */
 void GcodeSuite::G34() {
   if (DEBUGGING(LEVELING)) {
@@ -90,11 +104,18 @@ void GcodeSuite::G34() {
       break;
     }
 
-    const float z_auto_align_amplification = parser.floatval('A', Z_STEPPER_ALIGN_AMP);
-    if (!WITHIN(ABS(z_auto_align_amplification), 0.5f, 2.0f)) {
-      SERIAL_ECHOLNPGM("?(A)mplification out of bounds (0.5-2.0).");
-      break;
-    }
+    const float z_auto_align_amplification =
+      #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+        Z_STEPPER_ALIGN_AMP;
+      #else
+        parser.floatval('A', Z_STEPPER_ALIGN_AMP);
+        if (!WITHIN(ABS(z_auto_align_amplification), 0.5f, 2.0f)) {
+          SERIAL_ECHOLNPGM("?(A)mplification out of bounds (0.5-2.0).");
+          break;
+        }
+      #endif
+
+    const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
 
     // Wait for planner moves to finish!
     planner.synchronize();
@@ -130,11 +151,13 @@ void GcodeSuite::G34() {
       #define Z_BASIC_CLEARANCE Z_CLEARANCE_BETWEEN_PROBES
     #endif
 
+    // Compute a worst-case clearance height to probe from. After the first
+    // iteration this will be re-calculated based on the actual bed position
     float z_probe = Z_BASIC_CLEARANCE + (G34_MAX_GRADE) * 0.01f * (
       #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
          SQRT(_MAX(HYPOT2(z_auto_align_pos[0].x - z_auto_align_pos[0].y, z_auto_align_pos[1].x - z_auto_align_pos[1].y),
-                  HYPOT2(z_auto_align_pos[1].x - z_auto_align_pos[1].y, z_auto_align_pos[2].x - z_auto_align_pos[2].y),
-                  HYPOT2(z_auto_align_pos[2].x - z_auto_align_pos[2].y, z_auto_align_pos[0].x - z_auto_align_pos[0].y)))
+                   HYPOT2(z_auto_align_pos[1].x - z_auto_align_pos[1].y, z_auto_align_pos[2].x - z_auto_align_pos[2].y),
+                   HYPOT2(z_auto_align_pos[2].x - z_auto_align_pos[2].y, z_auto_align_pos[0].x - z_auto_align_pos[0].y)))
       #else
          HYPOT(z_auto_align_pos[0].x - z_auto_align_pos[0].y, z_auto_align_pos[1].x - z_auto_align_pos[1].y)
       #endif
@@ -147,12 +170,10 @@ void GcodeSuite::G34() {
     current_position.z -= z_probe * 0.5f;
 
     float last_z_align_move[Z_STEPPER_COUNT] = ARRAY_N(Z_STEPPER_COUNT, 10000.0f, 10000.0f, 10000.0f),
-          z_measured[Z_STEPPER_COUNT] = { 0 },
+          z_measured[G34_PROBE_COUNT] = { 0 },
           z_maxdiff = 0.0f,
           amplification = z_auto_align_amplification;
 
-    const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
-
     uint8_t iteration;
     bool err_break = false;
     for (iteration = 0; iteration < z_auto_align_iterations; ++iteration) {
@@ -161,17 +182,19 @@ void GcodeSuite::G34() {
       SERIAL_ECHOLNPAIR("\nITERATION: ", int(iteration + 1));
 
       // Initialize minimum value
-      float z_measured_min = 100000.0f;
+      float z_measured_min = 100000.0f,
+            z_measured_max = -100000.0f;
+
       // Probe all positions (one per Z-Stepper)
-      for (uint8_t izstepper = 0; izstepper < Z_STEPPER_COUNT; ++izstepper) {
+      for (uint8_t i = 0; i < G34_PROBE_COUNT; ++i) {
         // iteration odd/even --> downward / upward stepper sequence
-        const uint8_t zstepper = (iteration & 1) ? Z_STEPPER_COUNT - 1 - izstepper : izstepper;
+        const uint8_t iprobe = (iteration & 1) ? G34_PROBE_COUNT - 1 - i : i;
 
         // Safe clearance even on an incline
-        if (iteration == 0 || izstepper > 0) do_blocking_move_to_z(z_probe);
+        if (iteration == 0 || i > 0) do_blocking_move_to_z(z_probe);
 
         // Probe a Z height for each stepper.
-        const float z_probed_height = probe_at_point(z_auto_align_pos[zstepper], raise_after, 0, true);
+        const float z_probed_height = probe_at_point(z_auto_align_pos[i], raise_after, 0, true);
         if (isnan(z_probed_height)) {
           SERIAL_ECHOLNPGM("Probing failed.");
           err_break = true;
@@ -180,35 +203,58 @@ void GcodeSuite::G34() {
 
         // Add height to each value, to provide a more useful target height for
         // the next iteration of probing. This allows adjustments to be made away from the bed.
-        z_measured[zstepper] = z_probed_height + Z_CLEARANCE_BETWEEN_PROBES;
+        z_measured[iprobe] = z_probed_height + Z_CLEARANCE_BETWEEN_PROBES;
 
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " measured position is ", z_measured[zstepper]);
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(iprobe + 1), " measured position is ", z_measured[iprobe]);
 
         // Remember the minimum measurement to calculate the correction later on
-        z_measured_min = _MIN(z_measured_min, z_measured[zstepper]);
-      } // for (zstepper)
+        z_measured_min = _MIN(z_measured_min, z_measured[iprobe]);
+        z_measured_max = _MAX(z_measured_max, z_measured[iprobe]);
+      } // for (i)
 
       if (err_break) break;
 
       // Adapt the next probe clearance height based on the new measurements.
       // Safe_height = lowest distance to bed (= highest measurement) plus highest measured misalignment.
-      #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
-        z_maxdiff = _MAX(ABS(z_measured[0] - z_measured[1]), ABS(z_measured[1] - z_measured[2]), ABS(z_measured[2] - z_measured[0]));
-        z_probe = Z_BASIC_CLEARANCE + _MAX(z_measured[0], z_measured[1], z_measured[2]) + z_maxdiff;
-      #else
-        z_maxdiff = ABS(z_measured[0] - z_measured[1]);
-        z_probe = Z_BASIC_CLEARANCE + _MAX(z_measured[0], z_measured[1]) + z_maxdiff;
+      z_maxdiff = z_measured_max - z_measured_min;
+      z_probe = Z_BASIC_CLEARANCE + z_measured_max + z_maxdiff;
+
+      #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+        // Replace the initial values in z_measured with calculated heights at
+        // each stepper position. This allows the adjustment algorithm to be
+        // shared between both possible probing mechanisms.
+
+        // This must be done after the next z_probe height is calculated, so that
+        // the height is calculated from actual print area positions, and not
+        // extrapolated motor movements.
+
+        // Compute the least-squares fit for all probed points.
+        // Calculate the Z position of each stepper and store it in z_measured.
+        // This allows the actual adjustment logic to be shared by both algorithms.
+        linear_fit_data lfd;
+        incremental_LSF_reset(&lfd);
+        for (uint8_t i = 0; i < G34_PROBE_COUNT; ++i) {
+          SERIAL_ECHOLNPAIR("PROBEPT_", int(i + 1), ": ", z_measured[i]);
+          incremental_LSF(&lfd, z_auto_align_pos[i], z_measured[i]);
+        }
+        finish_incremental_LSF(&lfd);
+
+        z_measured_min = 100000.0f;
+        for (uint8_t i = 0; i < Z_STEPPER_COUNT; ++i) {
+          z_measured[i] = -(lfd.A * z_stepper_pos[i].x + lfd.B * z_stepper_pos[i].y);
+          z_measured_min = _MIN(z_measured_min, z_measured[i]);
+        }
+
+        SERIAL_ECHOLNPAIR("CALCULATED STEPPER POSITIONS: Z1=", z_measured[0], " Z2=", z_measured[1], " Z3=", z_measured[2]);
       #endif
 
-      SERIAL_ECHOPAIR("\n"
+      SERIAL_ECHOLNPAIR("\n"
         "DIFFERENCE Z1-Z2=", ABS(z_measured[0] - z_measured[1])
         #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
           , " Z2-Z3=", ABS(z_measured[1] - z_measured[2])
           , " Z3-Z1=", ABS(z_measured[2] - z_measured[0])
         #endif
       );
-      SERIAL_EOL();
-      SERIAL_EOL();
 
       // The following correction actions are to be enabled for select Z-steppers only
       stepper.set_separate_multi_axis(true);
@@ -220,8 +266,10 @@ void GcodeSuite::G34() {
         const float z_align_move = z_measured[zstepper] - z_measured_min,
                     z_align_abs = ABS(z_align_move);
 
-        // Optimize one iterations correction based on the first measurements
-        if (z_align_abs > 0.0f) amplification = iteration == 1 ? _MIN(last_z_align_move[zstepper] / z_align_abs, 2.0f) : z_auto_align_amplification;
+        #if DISABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+          // Optimize one iteration's correction based on the first measurements
+          if (z_align_abs > 0.0f) amplification = iteration == 1 ? _MIN(last_z_align_move[zstepper] / z_align_abs, 2.0f) : z_auto_align_amplification;
+        #endif
 
         // Check for less accuracy compared to last move
         if (last_z_align_move[zstepper] < z_align_abs - 1.0) {
@@ -266,7 +314,6 @@ void GcodeSuite::G34() {
 
     SERIAL_ECHOLNPAIR("Did ", int(iteration + (iteration != z_auto_align_iterations)), " iterations of ", int(z_auto_align_iterations));
     SERIAL_ECHOLNPAIR_F("Accuracy: ", z_maxdiff);
-    SERIAL_EOL();
 
     // Restore the active tool after homing
     #if HOTENDS > 1
@@ -299,31 +346,82 @@ void GcodeSuite::G34() {
 }
 
 /**
- * M422: Z-Stepper automatic alignment parameter selection
+ * M422: Set a Z-Stepper automatic alignment XY point.
+ *       Use repeatedly to set multiple points.
+ *
+ *   S<index> : Index of the probe point to set
+ *
+ * With Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS:
+ *   W<index> : Index of the Z stepper position to set
+ *              The W and S parameters may not be combined.
+ *
+ * S and W require an X and/or Y parameter
+ *   X<pos>   : X position to set (Unchanged if omitted)
+ *   Y<pos>   : Y position to set (Unchanged if omitted)
  */
 void GcodeSuite::M422() {
-  const int8_t zstepper = parser.intval('S') - 1;
-  if (!WITHIN(zstepper, 0, Z_STEPPER_COUNT - 1)) {
-    SERIAL_ECHOLNPGM("?(S) Z-Stepper index invalid.");
+  if (!parser.seen_any()) {
+    for (uint8_t i = 0; i < G34_PROBE_COUNT; ++i)
+      SERIAL_ECHOLNPAIR("M422 S", i + 1, " X", z_auto_align_pos[i].x, " Y", z_auto_align_pos[i].y);
+    #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+      for (uint8_t i = 0; i < Z_STEPPER_COUNT; ++i)
+        SERIAL_ECHOLNPAIR("M422 W", i + 1, " X", z_stepper_pos[i].x, " Y", z_stepper_pos[i].y);
+    #endif
     return;
   }
 
-  const xy_pos_t pos = {
-    parser.floatval('X', z_auto_align_pos[zstepper].x),
-    parser.floatval('Y', z_auto_align_pos[zstepper].y)
-  };
+  const bool is_probe_point = parser.seen('S');
 
-  if (!WITHIN(pos.x, X_MIN_POS, X_MAX_POS)) {
-    SERIAL_ECHOLNPGM("?(X) out of bounds.");
-    return;
+  #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+    if (is_probe_point && parser.seen('W')) {
+      SERIAL_ECHOLNPGM("?(S) and (W) may not be combined.");
+      return;
+    }
+  #endif
+
+  xy_pos_t *pos_dest = (
+    #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+      !is_probe_point ? z_stepper_pos :
+    #endif
+    z_auto_align_pos
+  );
+
+  // Get the Probe Position Index or Z Stepper Index
+  int8_t position_index;
+  if (is_probe_point) {
+    position_index = parser.intval('S') - 1;
+    if (!WITHIN(position_index, 0, int8_t(G34_PROBE_COUNT) - 1)) {
+      SERIAL_ECHOLNPGM("?(S) Z-ProbePosition index invalid.");
+      return;
+    }
+  }
+  else {
+    #if ENABLED(Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
+      position_index = parser.intval('W') - 1;
+      if (!WITHIN(position_index, 0, Z_STEPPER_COUNT - 1)) {
+        SERIAL_ECHOLNPGM("?(W) Z-Stepper index invalid.");
+        return;
+      }
+    #endif
   }
 
-  if (!WITHIN(pos.y, Y_MIN_POS, Y_MAX_POS)) {
-    SERIAL_ECHOLNPGM("?(Y) out of bounds.");
-    return;
+  const xy_pos_t pos = {
+    parser.floatval('X', pos_dest[position_index].x),
+    parser.floatval('Y', pos_dest[position_index].y)
+  };
+
+  if (is_probe_point) {
+    if (!position_is_reachable_by_probe(pos.x, Y_CENTER)) {
+      SERIAL_ECHOLNPGM("?(X) out of bounds.");
+      return;
+    }
+    if (!position_is_reachable_by_probe(pos)) {
+      SERIAL_ECHOLNPGM("?(Y) out of bounds.");
+      return;
+    }
   }
 
-  z_auto_align_pos[zstepper] = pos;
+  pos_dest[position_index] = pos;
 }
 
 #endif // Z_STEPPER_AUTO_ALIGN

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index b7b366a1cf..48ed8fe986 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -45,8 +45,17 @@
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../core/debug_out.h"
 
-float z_auto_align_xpos[Z_STEPPER_COUNT] = Z_STEPPER_ALIGN_X,
-      z_auto_align_ypos[Z_STEPPER_COUNT] = Z_STEPPER_ALIGN_Y;
+// Sanity-check
+constexpr xy_pos_t sanity_arr_z_align[] = Z_STEPPER_ALIGN_XY;
+static_assert(COUNT(sanity_arr_z_align) == Z_STEPPER_COUNT,
+  #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+    "Z_STEPPER_ALIGN_XY requires three {X,Y} entries (Z, Z2, and Z3)."
+  #else
+    "Z_STEPPER_ALIGN_XY requires two {X,Y} entries (Z and Z2)."
+  #endif
+);
+
+xy_pos_t z_auto_align_pos[Z_STEPPER_COUNT] = Z_STEPPER_ALIGN_XY;
 
 inline void set_all_z_lock(const bool lock) {
   stepper.set_z_lock(lock);
@@ -123,11 +132,11 @@ void GcodeSuite::G34() {
 
     float z_probe = Z_BASIC_CLEARANCE + (G34_MAX_GRADE) * 0.01f * (
       #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
-         SQRT(_MAX(HYPOT2(z_auto_align_xpos[0] - z_auto_align_ypos[0], z_auto_align_xpos[1] - z_auto_align_ypos[1]),
-                  HYPOT2(z_auto_align_xpos[1] - z_auto_align_ypos[1], z_auto_align_xpos[2] - z_auto_align_ypos[2]),
-                  HYPOT2(z_auto_align_xpos[2] - z_auto_align_ypos[2], z_auto_align_xpos[0] - z_auto_align_ypos[0])))
+         SQRT(_MAX(HYPOT2(z_auto_align_pos[0].x - z_auto_align_pos[0].y, z_auto_align_pos[1].x - z_auto_align_pos[1].y),
+                  HYPOT2(z_auto_align_pos[1].x - z_auto_align_pos[1].y, z_auto_align_pos[2].x - z_auto_align_pos[2].y),
+                  HYPOT2(z_auto_align_pos[2].x - z_auto_align_pos[2].y, z_auto_align_pos[0].x - z_auto_align_pos[0].y)))
       #else
-         HYPOT(z_auto_align_xpos[0] - z_auto_align_ypos[0], z_auto_align_xpos[1] - z_auto_align_ypos[1])
+         HYPOT(z_auto_align_pos[0].x - z_auto_align_pos[0].y, z_auto_align_pos[1].x - z_auto_align_pos[1].y)
       #endif
     );
 
@@ -135,7 +144,7 @@ void GcodeSuite::G34() {
     if (!all_axes_known()) home_all_axes();
 
     // Move the Z coordinate realm towards the positive - dirty trick
-    current_position[Z_AXIS] -= z_probe * 0.5;
+    current_position.z -= z_probe * 0.5f;
 
     float last_z_align_move[Z_STEPPER_COUNT] = ARRAY_N(Z_STEPPER_COUNT, 10000.0f, 10000.0f, 10000.0f),
           z_measured[Z_STEPPER_COUNT] = { 0 },
@@ -162,7 +171,7 @@ void GcodeSuite::G34() {
         if (iteration == 0 || izstepper > 0) do_blocking_move_to_z(z_probe);
 
         // Probe a Z height for each stepper.
-        const float z_probed_height = probe_at_point(z_auto_align_xpos[zstepper], z_auto_align_ypos[zstepper], raise_after, 0, true);
+        const float z_probed_height = probe_at_point(z_auto_align_pos[zstepper], raise_after, 0, true);
         if (isnan(z_probed_height)) {
           SERIAL_ECHOLNPGM("Probing failed.");
           err_break = true;
@@ -240,7 +249,7 @@ void GcodeSuite::G34() {
         }
 
         // Do a move to correct part of the misalignment for the current stepper
-        do_blocking_move_to_z(amplification * z_align_move + current_position[Z_AXIS]);
+        do_blocking_move_to_z(amplification * z_align_move + current_position.z);
       } // for (zstepper)
 
       // Back to normal stepper operations
@@ -299,20 +308,22 @@ void GcodeSuite::M422() {
     return;
   }
 
-  const float x_pos = parser.floatval('X', z_auto_align_xpos[zstepper]);
-  if (!WITHIN(x_pos, X_MIN_POS, X_MAX_POS)) {
+  const xy_pos_t pos = {
+    parser.floatval('X', z_auto_align_pos[zstepper].x),
+    parser.floatval('Y', z_auto_align_pos[zstepper].y)
+  };
+
+  if (!WITHIN(pos.x, X_MIN_POS, X_MAX_POS)) {
     SERIAL_ECHOLNPGM("?(X) out of bounds.");
     return;
   }
 
-  const float y_pos = parser.floatval('Y', z_auto_align_ypos[zstepper]);
-  if (!WITHIN(y_pos, Y_MIN_POS, Y_MAX_POS)) {
+  if (!WITHIN(pos.y, Y_MIN_POS, Y_MAX_POS)) {
     SERIAL_ECHOLNPGM("?(Y) out of bounds.");
     return;
   }
 
-  z_auto_align_xpos[zstepper] = x_pos;
-  z_auto_align_ypos[zstepper] = y_pos;
+  z_auto_align_pos[zstepper] = pos;
 }
 
 #endif // Z_STEPPER_AUTO_ALIGN

commit 9c288a682dcdd3063d5cf3ccefbf6502ed0f65ff
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Wed Sep 25 14:29:10 2019 +0700

    Followup to probe_at_point change (#15342)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index e55eacdc88..b7b366a1cf 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -277,7 +277,7 @@ void GcodeSuite::G34() {
     // After this operation the z position needs correction
     set_axis_is_not_at_home(Z_AXIS);
 
-    // Stow the probe, as the last call to probe_pt(...) left
+    // Stow the probe, as the last call to probe_at_point(...) left
     // the probe deployed if it was successful.
     STOW_PROBE();
 

commit c353eaa14630eb9d74f185e2b6aae1630ca21525
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 17 18:16:28 2019 -0500

    Misc changes from struct refactor (#15289)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 2ec6652141..e55eacdc88 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -162,7 +162,7 @@ void GcodeSuite::G34() {
         if (iteration == 0 || izstepper > 0) do_blocking_move_to_z(z_probe);
 
         // Probe a Z height for each stepper.
-        const float z_probed_height = probe_pt(z_auto_align_xpos[zstepper], z_auto_align_ypos[zstepper], raise_after, 0, true);
+        const float z_probed_height = probe_at_point(z_auto_align_xpos[zstepper], z_auto_align_ypos[zstepper], raise_after, 0, true);
         if (isnan(z_probed_height)) {
           SERIAL_ECHOLNPGM("Probing failed.");
           err_break = true;

commit 9958f5e3229e7823344ef07005fbc079aa8a68ca
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Mon Sep 2 09:44:48 2019 +0200

    Home on G34 if steppers slept (#15127)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 4b38eff325..2ec6652141 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -132,7 +132,7 @@ void GcodeSuite::G34() {
     );
 
     // Home before the alignment procedure
-    if (homing_needed()) home_all_axes();
+    if (!all_axes_known()) home_all_axes();
 
     // Move the Z coordinate realm towards the positive - dirty trick
     current_position[Z_AXIS] -= z_probe * 0.5;

commit 274934ad81ee6cd9b4f686e55107966cc4e23bd7
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Aug 16 17:34:13 2019 -0600

    Add LULZBOT_TOUCH_UI (#14967)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 101b3cc008..4b38eff325 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -284,7 +284,7 @@ void GcodeSuite::G34() {
     // Home Z after the alignment procedure
     process_subcommands_now_P(PSTR("G28 Z"));
 
-  } while(0);
+  }while(0);
 
   if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G34");
 }

commit f2c5740d06a427a2272f0871a8926697e46cb2d8
Author: Jason Smith <jason.inet@gmail.com>
Date:   Wed Jul 17 02:18:16 2019 -0700

     Add 'E' argument to G34 to allow stowing between probes (#14533)
    
    - Use the return value from probe_pt during `G34`
      Eliminate the assumption that probe_pt leaves current_position set to values relative to the probed points. This is not always true, depending on the raise_after argument.
    - Add '`E`' argument to `G34` command allowing stowing between each probe.

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index fee9ea2189..101b3cc008 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -142,6 +142,8 @@ void GcodeSuite::G34() {
           z_maxdiff = 0.0f,
           amplification = z_auto_align_amplification;
 
+    const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;
+
     uint8_t iteration;
     bool err_break = false;
     for (iteration = 0; iteration < z_auto_align_iterations; ++iteration) {
@@ -159,18 +161,18 @@ void GcodeSuite::G34() {
         // Safe clearance even on an incline
         if (iteration == 0 || izstepper > 0) do_blocking_move_to_z(z_probe);
 
-        // Probe a Z height for each stepper
-        if (isnan(probe_pt(z_auto_align_xpos[zstepper], z_auto_align_ypos[zstepper], PROBE_PT_RAISE, 0, true))) {
+        // Probe a Z height for each stepper.
+        const float z_probed_height = probe_pt(z_auto_align_xpos[zstepper], z_auto_align_ypos[zstepper], raise_after, 0, true);
+        if (isnan(z_probed_height)) {
           SERIAL_ECHOLNPGM("Probing failed.");
           err_break = true;
           break;
         }
 
-        // This is not the trigger Z value. It is the position of the probe after raising it.
-        // It is higher than the trigger value by a constant value (not known here). This value
-        // is more useful for determining the desired next iteration Z position for probing. It is
-        // equally well suited for determining the misalignment, just like the trigger position would be.
-        z_measured[zstepper] = current_position[Z_AXIS];
+        // Add height to each value, to provide a more useful target height for
+        // the next iteration of probing. This allows adjustments to be made away from the bed.
+        z_measured[zstepper] = z_probed_height + Z_CLEARANCE_BETWEEN_PROBES;
+
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " measured position is ", z_measured[zstepper]);
 
         // Remember the minimum measurement to calculate the correction later on

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 44f7845bf6..fee9ea2189 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -123,7 +123,7 @@ void GcodeSuite::G34() {
 
     float z_probe = Z_BASIC_CLEARANCE + (G34_MAX_GRADE) * 0.01f * (
       #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
-         SQRT(MAX(HYPOT2(z_auto_align_xpos[0] - z_auto_align_ypos[0], z_auto_align_xpos[1] - z_auto_align_ypos[1]),
+         SQRT(_MAX(HYPOT2(z_auto_align_xpos[0] - z_auto_align_ypos[0], z_auto_align_xpos[1] - z_auto_align_ypos[1]),
                   HYPOT2(z_auto_align_xpos[1] - z_auto_align_ypos[1], z_auto_align_xpos[2] - z_auto_align_ypos[2]),
                   HYPOT2(z_auto_align_xpos[2] - z_auto_align_ypos[2], z_auto_align_xpos[0] - z_auto_align_ypos[0])))
       #else
@@ -174,7 +174,7 @@ void GcodeSuite::G34() {
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " measured position is ", z_measured[zstepper]);
 
         // Remember the minimum measurement to calculate the correction later on
-        z_measured_min = MIN(z_measured_min, z_measured[zstepper]);
+        z_measured_min = _MIN(z_measured_min, z_measured[zstepper]);
       } // for (zstepper)
 
       if (err_break) break;
@@ -182,11 +182,11 @@ void GcodeSuite::G34() {
       // Adapt the next probe clearance height based on the new measurements.
       // Safe_height = lowest distance to bed (= highest measurement) plus highest measured misalignment.
       #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
-        z_maxdiff = MAX(ABS(z_measured[0] - z_measured[1]), ABS(z_measured[1] - z_measured[2]), ABS(z_measured[2] - z_measured[0]));
-        z_probe = Z_BASIC_CLEARANCE + MAX(z_measured[0], z_measured[1], z_measured[2]) + z_maxdiff;
+        z_maxdiff = _MAX(ABS(z_measured[0] - z_measured[1]), ABS(z_measured[1] - z_measured[2]), ABS(z_measured[2] - z_measured[0]));
+        z_probe = Z_BASIC_CLEARANCE + _MAX(z_measured[0], z_measured[1], z_measured[2]) + z_maxdiff;
       #else
         z_maxdiff = ABS(z_measured[0] - z_measured[1]);
-        z_probe = Z_BASIC_CLEARANCE + MAX(z_measured[0], z_measured[1]) + z_maxdiff;
+        z_probe = Z_BASIC_CLEARANCE + _MAX(z_measured[0], z_measured[1]) + z_maxdiff;
       #endif
 
       SERIAL_ECHOPAIR("\n"
@@ -210,7 +210,7 @@ void GcodeSuite::G34() {
                     z_align_abs = ABS(z_align_move);
 
         // Optimize one iterations correction based on the first measurements
-        if (z_align_abs > 0.0f) amplification = iteration == 1 ? MIN(last_z_align_move[zstepper] / z_align_abs, 2.0f) : z_auto_align_amplification;
+        if (z_align_abs > 0.0f) amplification = iteration == 1 ? _MIN(last_z_align_move[zstepper] / z_align_abs, 2.0f) : z_auto_align_amplification;
 
         // Check for less accuracy compared to last move
         if (last_z_align_move[zstepper] < z_align_abs - 1.0) {

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 75cc09d293..44f7845bf6 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit 9f136a7c6765b99c34d8aace3f6f2b5cfed54972
Author: BigIronGuru <51454533+BigIronGuru@users.noreply.github.com>
Date:   Wed Jun 26 10:52:01 2019 +0200

    Low-priority homing in G34 (#14391)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index c4b6193c5c..75cc09d293 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -132,7 +132,7 @@ void GcodeSuite::G34() {
     );
 
     // Home before the alignment procedure
-    home_all_axes();
+    if (homing_needed()) home_all_axes();
 
     // Move the Z coordinate realm towards the positive - dirty trick
     current_position[Z_AXIS] -= z_probe * 0.5;

commit 12d21e642febb0d0e070e57ba4af17187c41f317
Author: BigIronGuru <51454533+BigIronGuru@users.noreply.github.com>
Date:   Mon Jun 24 03:55:43 2019 +0200

    Update G34 for non-BLTouch probes (#14380)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index e7f9dbdadd..c4b6193c5c 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -38,10 +38,6 @@
   #include "../../module/probe.h"
 #endif
 
-#if ENABLED(BLTOUCH)
-  #include "../../feature/bltouch.h"
-#endif
-
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
@@ -279,11 +275,9 @@ void GcodeSuite::G34() {
     // After this operation the z position needs correction
     set_axis_is_not_at_home(Z_AXIS);
 
-    #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
-      // In BLTOUCH HS mode, the pin is still deployed at this point.
-      // The upcoming G28 means travel, so it is better to stow the pin.
-      bltouch._stow();
-    #endif
+    // Stow the probe, as the last call to probe_pt(...) left
+    // the probe deployed if it was successful.
+    STOW_PROBE();
 
     // Home Z after the alignment procedure
     process_subcommands_now_P(PSTR("G28 Z"));

commit aa0383a83b7bc45b86753ef9f5adb41da09c76df
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jun 23 21:00:48 2019 -0400

    Enhance IDEX toolchange auto-return w/ no park, full control (#14117)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index e0f3b2958b..e7f9dbdadd 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -109,7 +109,7 @@ void GcodeSuite::G34() {
     // Always home with tool 0 active
     #if HOTENDS > 1
       const uint8_t old_tool_index = active_extruder;
-      tool_change(0, 0, true);
+      tool_change(0, true);
     #endif
 
     #if HAS_DUPLICATION_MODE
@@ -263,7 +263,7 @@ void GcodeSuite::G34() {
 
     // Restore the active tool after homing
     #if HOTENDS > 1
-      tool_change(old_tool_index, 0, (
+      tool_change(old_tool_index, (
         #if ENABLED(PARKING_EXTRUDER)
           false // Fetch the previous toolhead
         #else

commit 9c83135d4096b6602f7975c71dddf909aac0d6f4
Author: BigIronGuru <51454533+BigIronGuru@users.noreply.github.com>
Date:   Sat Jun 22 07:43:33 2019 +0200

    Only home Z at the end of G34 (#14353)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 7fb1476b5c..e0f3b2958b 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -285,8 +285,8 @@ void GcodeSuite::G34() {
       bltouch._stow();
     #endif
 
-    // Home after the alignment procedure
-    home_all_axes();
+    // Home Z after the alignment procedure
+    process_subcommands_now_P(PSTR("G28 Z"));
 
   } while(0);
 

commit a9acd2f4973cbbff1b936229ff97a3b56e4157ff
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Jun 20 22:18:36 2019 -0400

    G34 configurable angle limit (#14321)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 1067a06bf8..7fb1476b5c 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -125,10 +125,7 @@ void GcodeSuite::G34() {
       #define Z_BASIC_CLEARANCE Z_CLEARANCE_BETWEEN_PROBES
     #endif
 
-    // 0.05 is a 5% incline. On a 300mm bed that would be a misalignment of about 1.5cm.
-    // This angle is the maximum misalignment catered for
-    #define MAX_ANGLE 0.05f
-    float z_probe = Z_BASIC_CLEARANCE + MAX_ANGLE * (
+    float z_probe = Z_BASIC_CLEARANCE + (G34_MAX_GRADE) * 0.01f * (
       #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
          SQRT(MAX(HYPOT2(z_auto_align_xpos[0] - z_auto_align_ypos[0], z_auto_align_xpos[1] - z_auto_align_ypos[1]),
                   HYPOT2(z_auto_align_xpos[1] - z_auto_align_ypos[1], z_auto_align_xpos[2] - z_auto_align_ypos[2]),
@@ -160,7 +157,7 @@ void GcodeSuite::G34() {
       float z_measured_min = 100000.0f;
       // Probe all positions (one per Z-Stepper)
       for (uint8_t izstepper = 0; izstepper < Z_STEPPER_COUNT; ++izstepper) {
-        // iteration odd/even --> downward / upward stepper sequence 
+        // iteration odd/even --> downward / upward stepper sequence
         const uint8_t zstepper = (iteration & 1) ? Z_STEPPER_COUNT - 1 - izstepper : izstepper;
 
         // Safe clearance even on an incline

commit bf64dd4db6e28f3ab9cddabbcdec3a56abda03de
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Jun 18 08:02:18 2019 -0400

    Improve G34, M422 (Z alignment) (#14142)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 62944ffc3e..1067a06bf8 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -73,11 +73,6 @@ void GcodeSuite::G34() {
 
   do { // break out on error
 
-    if (!TEST(axis_known_position, X_AXIS) || !TEST(axis_known_position, Y_AXIS)) {
-      SERIAL_ECHOLNPGM("Home XY first");
-      break;
-    }
-
     const int8_t z_auto_align_iterations = parser.intval('I', Z_STEPPER_ALIGN_ITERATIONS);
     if (!WITHIN(z_auto_align_iterations, 1, 30)) {
       SERIAL_ECHOLNPGM("?(I)teration out of bounds (1-30).");
@@ -111,10 +106,6 @@ void GcodeSuite::G34() {
       workspace_plane = PLANE_XY;
     #endif
 
-    #if ENABLED(BLTOUCH)
-      bltouch.init();
-    #endif
-
     // Always home with tool 0 active
     #if HOTENDS > 1
       const uint8_t old_tool_index = active_extruder;
@@ -125,78 +116,126 @@ void GcodeSuite::G34() {
       extruder_duplication_enabled = false;
     #endif
 
-    // Before moving other axes raise Z, if needed. Never lower Z.
-    if (current_position[Z_AXIS] < Z_CLEARANCE_BETWEEN_PROBES) {
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before moving to probe pos) to ", Z_CLEARANCE_BETWEEN_PROBES);
-      do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
-    }
+    #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
+        // In BLTOUCH HS mode, the probe travels in a deployed state.
+        // Users of G34 might have a badly misaligned bed, so raise Z by the
+        // length of the deployed pin (BLTOUCH stroke < 7mm)
+      #define Z_BASIC_CLEARANCE Z_CLEARANCE_BETWEEN_PROBES + 7.0f
+    #else
+      #define Z_BASIC_CLEARANCE Z_CLEARANCE_BETWEEN_PROBES
+    #endif
+
+    // 0.05 is a 5% incline. On a 300mm bed that would be a misalignment of about 1.5cm.
+    // This angle is the maximum misalignment catered for
+    #define MAX_ANGLE 0.05f
+    float z_probe = Z_BASIC_CLEARANCE + MAX_ANGLE * (
+      #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+         SQRT(MAX(HYPOT2(z_auto_align_xpos[0] - z_auto_align_ypos[0], z_auto_align_xpos[1] - z_auto_align_ypos[1]),
+                  HYPOT2(z_auto_align_xpos[1] - z_auto_align_ypos[1], z_auto_align_xpos[2] - z_auto_align_ypos[2]),
+                  HYPOT2(z_auto_align_xpos[2] - z_auto_align_ypos[2], z_auto_align_xpos[0] - z_auto_align_ypos[0])))
+      #else
+         HYPOT(z_auto_align_xpos[0] - z_auto_align_ypos[0], z_auto_align_xpos[1] - z_auto_align_ypos[1])
+      #endif
+    );
+
+    // Home before the alignment procedure
+    home_all_axes();
+
+    // Move the Z coordinate realm towards the positive - dirty trick
+    current_position[Z_AXIS] -= z_probe * 0.5;
 
-    // Remember corrections to determine errors on each iteration
     float last_z_align_move[Z_STEPPER_COUNT] = ARRAY_N(Z_STEPPER_COUNT, 10000.0f, 10000.0f, 10000.0f),
-          z_measured[Z_STEPPER_COUNT] = { 0 };
+          z_measured[Z_STEPPER_COUNT] = { 0 },
+          z_maxdiff = 0.0f,
+          amplification = z_auto_align_amplification;
+
+    uint8_t iteration;
     bool err_break = false;
-    for (uint8_t iteration = 0; iteration < z_auto_align_iterations; ++iteration) {
+    for (iteration = 0; iteration < z_auto_align_iterations; ++iteration) {
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> probing all positions.");
 
-      // Reset minimum value
+      SERIAL_ECHOLNPAIR("\nITERATION: ", int(iteration + 1));
+
+      // Initialize minimum value
       float z_measured_min = 100000.0f;
-      // For each iteration go through all probe positions (one per Z-Stepper)
-      for (uint8_t zstepper = 0; zstepper < Z_STEPPER_COUNT; ++zstepper) {
+      // Probe all positions (one per Z-Stepper)
+      for (uint8_t izstepper = 0; izstepper < Z_STEPPER_COUNT; ++izstepper) {
+        // iteration odd/even --> downward / upward stepper sequence 
+        const uint8_t zstepper = (iteration & 1) ? Z_STEPPER_COUNT - 1 - izstepper : izstepper;
 
-        #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
-          // In BLTOUCH HS mode, the probe travels in a deployed state.
-          // Users of G34 might have a badly misaligned bed, so raise Z by the
-          // length of the deployed pin (BLTOUCH stroke < 7mm)
-          do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES + 7);
-        #endif
+        // Safe clearance even on an incline
+        if (iteration == 0 || izstepper > 0) do_blocking_move_to_z(z_probe);
 
         // Probe a Z height for each stepper
-        z_measured[zstepper] = probe_pt(z_auto_align_xpos[zstepper], z_auto_align_ypos[zstepper], PROBE_PT_RAISE, false);
-
-        // Stop on error
-        if (isnan(z_measured[zstepper])) {
-          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> PROBING FAILED!");
+        if (isnan(probe_pt(z_auto_align_xpos[zstepper], z_auto_align_ypos[zstepper], PROBE_PT_RAISE, 0, true))) {
+          SERIAL_ECHOLNPGM("Probing failed.");
           err_break = true;
           break;
         }
 
+        // This is not the trigger Z value. It is the position of the probe after raising it.
+        // It is higher than the trigger value by a constant value (not known here). This value
+        // is more useful for determining the desired next iteration Z position for probing. It is
+        // equally well suited for determining the misalignment, just like the trigger position would be.
+        z_measured[zstepper] = current_position[Z_AXIS];
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " measured position is ", z_measured[zstepper]);
 
-        // Remember the maximum position to calculate the correction
+        // Remember the minimum measurement to calculate the correction later on
         z_measured_min = MIN(z_measured_min, z_measured[zstepper]);
-      }
+      } // for (zstepper)
 
       if (err_break) break;
 
-      // Remember the current z position to return to
-      float z_original_position = current_position[Z_AXIS];
+      // Adapt the next probe clearance height based on the new measurements.
+      // Safe_height = lowest distance to bed (= highest measurement) plus highest measured misalignment.
+      #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+        z_maxdiff = MAX(ABS(z_measured[0] - z_measured[1]), ABS(z_measured[1] - z_measured[2]), ABS(z_measured[2] - z_measured[0]));
+        z_probe = Z_BASIC_CLEARANCE + MAX(z_measured[0], z_measured[1], z_measured[2]) + z_maxdiff;
+      #else
+        z_maxdiff = ABS(z_measured[0] - z_measured[1]);
+        z_probe = Z_BASIC_CLEARANCE + MAX(z_measured[0], z_measured[1]) + z_maxdiff;
+      #endif
+
+      SERIAL_ECHOPAIR("\n"
+        "DIFFERENCE Z1-Z2=", ABS(z_measured[0] - z_measured[1])
+        #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+          , " Z2-Z3=", ABS(z_measured[1] - z_measured[2])
+          , " Z3-Z1=", ABS(z_measured[2] - z_measured[0])
+        #endif
+      );
+      SERIAL_EOL();
+      SERIAL_EOL();
+
+      // The following correction actions are to be enabled for select Z-steppers only
+      stepper.set_separate_multi_axis(true);
 
-      // Iterations can stop early if all corrections are below required accuracy
       bool success_break = true;
-      // Correct stepper offsets and re-iterate
+      // Correct the individual stepper offsets
       for (uint8_t zstepper = 0; zstepper < Z_STEPPER_COUNT; ++zstepper) {
-        stepper.set_separate_multi_axis(true);
-        set_all_z_lock(true); // Steppers will be enabled separately
-
         // Calculate current stepper move
         const float z_align_move = z_measured[zstepper] - z_measured_min,
                     z_align_abs = ABS(z_align_move);
 
-        // Check for lost accuracy compared to last move
+        // Optimize one iterations correction based on the first measurements
+        if (z_align_abs > 0.0f) amplification = iteration == 1 ? MIN(last_z_align_move[zstepper] / z_align_abs, 2.0f) : z_auto_align_amplification;
+
+        // Check for less accuracy compared to last move
         if (last_z_align_move[zstepper] < z_align_abs - 1.0) {
-          // Stop here
-          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> detected decreasing accuracy.");
+          SERIAL_ECHOLNPGM("Decreasing accuracy detected.");
           err_break = true;
           break;
         }
-        else
-          last_z_align_move[zstepper] = z_align_abs;
 
-        // Only stop early if all measured points achieve accuracy target
+        // Remember the alignment for the next iteration
+        last_z_align_move[zstepper] = z_align_abs;
+
+        // Stop early if all measured points achieve accuracy target
         if (z_align_abs > z_auto_align_accuracy) success_break = false;
 
         if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " corrected by ", z_align_move);
 
+        // Lock all steppers except one
+        set_all_z_lock(true);
         switch (zstepper) {
           case 0: stepper.set_z_lock(false); break;
           case 1: stepper.set_z2_lock(false); break;
@@ -205,26 +244,25 @@ void GcodeSuite::G34() {
           #endif
         }
 
-        // This will lose home position and require re-homing
-        do_blocking_move_to_z(z_auto_align_amplification * z_align_move + current_position[Z_AXIS]);
-      }
+        // Do a move to correct part of the misalignment for the current stepper
+        do_blocking_move_to_z(amplification * z_align_move + current_position[Z_AXIS]);
+      } // for (zstepper)
+
+      // Back to normal stepper operations
+      set_all_z_lock(false);
+      stepper.set_separate_multi_axis(false);
 
       if (err_break) break;
 
-      // Move Z back to previous position
-      set_all_z_lock(true);
-      do_blocking_move_to_z(z_original_position);
-      set_all_z_lock(false);
+      if (success_break) { SERIAL_ECHOLNPGM("Target accuracy achieved."); break; }
 
-      stepper.set_separate_multi_axis(false);
+    } // for (iteration)
 
-      if (success_break) {
-        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> achieved target accuracy.");
-        break;
-      }
-    }
+    if (err_break) { SERIAL_ECHOLNPGM("G34 aborted."); break; }
 
-    if (err_break) break;
+    SERIAL_ECHOLNPAIR("Did ", int(iteration + (iteration != z_auto_align_iterations)), " iterations of ", int(z_auto_align_iterations));
+    SERIAL_ECHOLNPAIR_F("Accuracy: ", z_maxdiff);
+    SERIAL_EOL();
 
     // Restore the active tool after homing
     #if HOTENDS > 1
@@ -250,7 +288,8 @@ void GcodeSuite::G34() {
       bltouch._stow();
     #endif
 
-    gcode.G28(false);
+    // Home after the alignment procedure
+    home_all_axes();
 
   } while(0);
 

commit 85fb33a060354a70348f220085405ae7bfb939c5
Author: FanDjango <FanDjango@users.noreply.github.com>
Date:   Sat May 18 02:10:18 2019 +0200

    BLTOUCH tweaks, new v3.1 command (#14015)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 66fa800169..62944ffc3e 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -74,7 +74,7 @@ void GcodeSuite::G34() {
   do { // break out on error
 
     if (!TEST(axis_known_position, X_AXIS) || !TEST(axis_known_position, Y_AXIS)) {
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> XY homing required.");
+      SERIAL_ECHOLNPGM("Home XY first");
       break;
     }
 
@@ -142,6 +142,14 @@ void GcodeSuite::G34() {
       float z_measured_min = 100000.0f;
       // For each iteration go through all probe positions (one per Z-Stepper)
       for (uint8_t zstepper = 0; zstepper < Z_STEPPER_COUNT; ++zstepper) {
+
+        #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
+          // In BLTOUCH HS mode, the probe travels in a deployed state.
+          // Users of G34 might have a badly misaligned bed, so raise Z by the
+          // length of the deployed pin (BLTOUCH stroke < 7mm)
+          do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES + 7);
+        #endif
+
         // Probe a Z height for each stepper
         z_measured[zstepper] = probe_pt(z_auto_align_xpos[zstepper], z_auto_align_ypos[zstepper], PROBE_PT_RAISE, false);
 
@@ -229,15 +237,19 @@ void GcodeSuite::G34() {
       ));
     #endif
 
-    #if HAS_LEVELING
-      #if ENABLED(RESTORE_LEVELING_AFTER_G34)
-        set_bed_leveling_enabled(leveling_was_active);
-      #endif
+    #if HAS_LEVELING && ENABLED(RESTORE_LEVELING_AFTER_G34)
+      set_bed_leveling_enabled(leveling_was_active);
     #endif
 
     // After this operation the z position needs correction
     set_axis_is_not_at_home(Z_AXIS);
 
+    #if BOTH(BLTOUCH, BLTOUCH_HS_MODE)
+      // In BLTOUCH HS mode, the pin is still deployed at this point.
+      // The upcoming G28 means travel, so it is better to stow the pin.
+      bltouch._stow();
+    #endif
+
     gcode.G28(false);
 
   } while(0);

commit 6811e2921bcd272e7487e4f379b42a5a403a07c2
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue May 7 22:25:54 2019 -0400

    BLTouch v3 / 3DTouch Interoperability & performance (#13814)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 36550a7bd7..66fa800169 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -112,8 +112,7 @@ void GcodeSuite::G34() {
     #endif
 
     #if ENABLED(BLTOUCH)
-      bltouch.reset();
-      bltouch.stow();
+      bltouch.init();
     #endif
 
     // Always home with tool 0 active

commit e2dd2268e81d8e593f9c9217a5798911167db1f3
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Apr 23 20:40:55 2019 +0200

    Add a Z raise-between-probes to G34 (#13791)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 9a26400a97..36550a7bd7 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -126,6 +126,12 @@ void GcodeSuite::G34() {
       extruder_duplication_enabled = false;
     #endif
 
+    // Before moving other axes raise Z, if needed. Never lower Z.
+    if (current_position[Z_AXIS] < Z_CLEARANCE_BETWEEN_PROBES) {
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Raise Z (before moving to probe pos) to ", Z_CLEARANCE_BETWEEN_PROBES);
+      do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
+    }
+
     // Remember corrections to determine errors on each iteration
     float last_z_align_move[Z_STEPPER_COUNT] = ARRAY_N(Z_STEPPER_COUNT, 10000.0f, 10000.0f, 10000.0f),
           z_measured[Z_STEPPER_COUNT] = { 0 };

commit 5b2c37d6c1318079687eed6e14aecd3a4ef2ce47
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Mar 18 17:31:11 2019 -0400

    Followup to BLTouch (#13422)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 0f7c237f17..9a26400a97 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -38,6 +38,10 @@
   #include "../../module/probe.h"
 #endif
 
+#if ENABLED(BLTOUCH)
+  #include "../../feature/bltouch.h"
+#endif
+
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif

commit 691e5c3bb8d04b0b6690424034d73ade19e91586
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Mar 17 06:57:25 2019 -0400

    BLTouch V3.0 support (#13406)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index ea2c5a20eb..0f7c237f17 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -108,8 +108,8 @@ void GcodeSuite::G34() {
     #endif
 
     #if ENABLED(BLTOUCH)
-      bltouch_command(BLTOUCH_RESET);
-      set_bltouch_deployed(false);
+      bltouch.reset();
+      bltouch.stow();
     #endif
 
     // Always home with tool 0 active

commit f5bcc00570bd5ae2ba0deaa7af0ba4d3ce7c3b02
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 14 02:25:42 2019 -0500

    Unify debugging output with debug_out.h (#13388)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 9c47d18d42..ea2c5a20eb 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -42,6 +42,9 @@
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
+#define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
+#include "../../core/debug_out.h"
+
 float z_auto_align_xpos[Z_STEPPER_COUNT] = Z_STEPPER_ALIGN_X,
       z_auto_align_ypos[Z_STEPPER_COUNT] = Z_STEPPER_ALIGN_Y;
 
@@ -59,19 +62,15 @@ inline void set_all_z_lock(const bool lock) {
  * Parameters: I<iterations> T<accuracy> A<amplification>
  */
 void GcodeSuite::G34() {
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOLNPGM(">>> G34");
-      log_machine_info();
-    }
-  #endif
+  if (DEBUGGING(LEVELING)) {
+    DEBUG_ECHOLNPGM(">>> G34");
+    log_machine_info();
+  }
 
   do { // break out on error
 
     if (!TEST(axis_known_position, X_AXIS) || !TEST(axis_known_position, Y_AXIS)) {
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> XY homing required.");
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> XY homing required.");
       break;
     }
 
@@ -128,9 +127,7 @@ void GcodeSuite::G34() {
           z_measured[Z_STEPPER_COUNT] = { 0 };
     bool err_break = false;
     for (uint8_t iteration = 0; iteration < z_auto_align_iterations; ++iteration) {
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> probing all positions.");
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> probing all positions.");
 
       // Reset minimum value
       float z_measured_min = 100000.0f;
@@ -141,19 +138,12 @@ void GcodeSuite::G34() {
 
         // Stop on error
         if (isnan(z_measured[zstepper])) {
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> PROBING FAILED!");
-          #endif
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> PROBING FAILED!");
           err_break = true;
           break;
         }
 
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOPAIR("> Z", int(zstepper + 1));
-            SERIAL_ECHOLNPAIR(" measured position is ", z_measured[zstepper]);
-          }
-        #endif
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " measured position is ", z_measured[zstepper]);
 
         // Remember the maximum position to calculate the correction
         z_measured_min = MIN(z_measured_min, z_measured[zstepper]);
@@ -178,9 +168,7 @@ void GcodeSuite::G34() {
         // Check for lost accuracy compared to last move
         if (last_z_align_move[zstepper] < z_align_abs - 1.0) {
           // Stop here
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> detected decreasing accuracy.");
-          #endif
+          if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> detected decreasing accuracy.");
           err_break = true;
           break;
         }
@@ -190,12 +178,7 @@ void GcodeSuite::G34() {
         // Only stop early if all measured points achieve accuracy target
         if (z_align_abs > z_auto_align_accuracy) success_break = false;
 
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOPAIR("> Z", int(zstepper + 1));
-            SERIAL_ECHOLNPAIR(" corrected by ", z_align_move);
-          }
-        #endif
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("> Z", int(zstepper + 1), " corrected by ", z_align_move);
 
         switch (zstepper) {
           case 0: stepper.set_z_lock(false); break;
@@ -219,9 +202,7 @@ void GcodeSuite::G34() {
       stepper.set_separate_multi_axis(false);
 
       if (success_break) {
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> achieved target accuracy.");
-        #endif
+        if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("> achieved target accuracy.");
         break;
       }
     }
@@ -252,9 +233,7 @@ void GcodeSuite::G34() {
 
   } while(0);
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G34");
-  #endif
+  if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("<<< G34");
 }
 
 /**

commit 050eac03afb67743131b5537bf7464e3dafbce23
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Mar 13 01:42:50 2019 -0400

    Single X Duplication Extension (#13373)
    
    * Multi-nozzle selective duplication
    * Use a bit-mask, reduce stepper_indirection.h size
    * Tweak the multi-nozzle duplication description
    * Use 'S' as a bool in M605
    * Add HAS_DUPLICATION_MODE conditional
    * Remove '_MODE' from the option name
    * M605 in the style of Stacker M280
    * Also include direct mask style (P)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 808353d3c4..9c47d18d42 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -119,7 +119,7 @@ void GcodeSuite::G34() {
       tool_change(0, 0, true);
     #endif
 
-    #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+    #if HAS_DUPLICATION_MODE
       extruder_duplication_enabled = false;
     #endif
 

commit d94e077901e15557e94f64640adf37e10defb7f2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 11 20:48:49 2019 -0500

    Apply HAS_HOTEND_OFFSET where needed

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 67baca6df6..808353d3c4 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -230,13 +230,13 @@ void GcodeSuite::G34() {
 
     // Restore the active tool after homing
     #if HOTENDS > 1
-      tool_change(old_tool_index, 0,
+      tool_change(old_tool_index, 0, (
         #if ENABLED(PARKING_EXTRUDER)
           false // Fetch the previous toolhead
         #else
           true
         #endif
-      );
+      ));
     #endif
 
     #if HAS_LEVELING

commit 92a4984066bcb0e157d7e1c7c5421de4c1fd684f
Author: Minims <github@minims.fr>
Date:   Sun Feb 24 20:57:30 2019 +0100

    Fix G34 probe position (#13251)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 3c54f5207b..67baca6df6 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -137,7 +137,7 @@ void GcodeSuite::G34() {
       // For each iteration go through all probe positions (one per Z-Stepper)
       for (uint8_t zstepper = 0; zstepper < Z_STEPPER_COUNT; ++zstepper) {
         // Probe a Z height for each stepper
-        z_measured[zstepper] = probe_pt(z_auto_align_xpos[zstepper], z_auto_align_ypos[zstepper], PROBE_PT_RAISE, 0, false);
+        z_measured[zstepper] = probe_pt(z_auto_align_xpos[zstepper], z_auto_align_ypos[zstepper], PROBE_PT_RAISE, false);
 
         // Stop on error
         if (isnan(z_measured[zstepper])) {

commit 562f2321d282eb16d538e6098b0155e0d91e7e4a
Author: Bruce j Beare <bruce.j.beare@intel.com>
Date:   Sat Feb 23 00:41:52 2019 -0800

    Fix a G34 bug, allow negative Z corrections (#13240)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 9b1ba1c5ab..3c54f5207b 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -88,7 +88,7 @@ void GcodeSuite::G34() {
     }
 
     const float z_auto_align_amplification = parser.floatval('A', Z_STEPPER_ALIGN_AMP);
-    if (!WITHIN(z_auto_align_amplification, 0.5f, 2.0f)) {
+    if (!WITHIN(ABS(z_auto_align_amplification), 0.5f, 2.0f)) {
       SERIAL_ECHOLNPGM("?(A)mplification out of bounds (0.5-2.0).");
       break;
     }
@@ -137,7 +137,7 @@ void GcodeSuite::G34() {
       // For each iteration go through all probe positions (one per Z-Stepper)
       for (uint8_t zstepper = 0; zstepper < Z_STEPPER_COUNT; ++zstepper) {
         // Probe a Z height for each stepper
-        z_measured[zstepper] = probe_pt(z_auto_align_xpos[zstepper], z_auto_align_ypos[zstepper], PROBE_PT_RAISE, false);
+        z_measured[zstepper] = probe_pt(z_auto_align_xpos[zstepper], z_auto_align_ypos[zstepper], PROBE_PT_RAISE, 0, false);
 
         // Stop on error
         if (isnan(z_measured[zstepper])) {

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index 33d0aa2f2e..9b1ba1c5ab 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
index fbeb7b8669..33d0aa2f2e 100644
--- a/Marlin/src/gcode/calibrate/G34_M422.cpp
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -263,19 +263,19 @@ void GcodeSuite::G34() {
 void GcodeSuite::M422() {
   const int8_t zstepper = parser.intval('S') - 1;
   if (!WITHIN(zstepper, 0, Z_STEPPER_COUNT - 1)) {
-    SERIAL_PROTOCOLLNPGM("?(S) Z-Stepper index invalid.");
+    SERIAL_ECHOLNPGM("?(S) Z-Stepper index invalid.");
     return;
   }
 
   const float x_pos = parser.floatval('X', z_auto_align_xpos[zstepper]);
   if (!WITHIN(x_pos, X_MIN_POS, X_MAX_POS)) {
-    SERIAL_PROTOCOLLNPGM("?(X) out of bounds.");
+    SERIAL_ECHOLNPGM("?(X) out of bounds.");
     return;
   }
 
   const float y_pos = parser.floatval('Y', z_auto_align_ypos[zstepper]);
   if (!WITHIN(y_pos, Y_MIN_POS, Y_MAX_POS)) {
-    SERIAL_PROTOCOLLNPGM("?(Y) out of bounds.");
+    SERIAL_ECHOLNPGM("?(Y) out of bounds.");
     return;
   }
 

commit 553622835911b520c6ba43bc03e71868f3972cb3
Author: TheLongAndOnly <github@mueller-gelff.de>
Date:   Mon Oct 29 20:01:36 2018 +0100

    G34 Auto-align multi-stepper Z axis (#11302)

diff --git a/Marlin/src/gcode/calibrate/G34_M422.cpp b/Marlin/src/gcode/calibrate/G34_M422.cpp
new file mode 100644
index 0000000000..fbeb7b8669
--- /dev/null
+++ b/Marlin/src/gcode/calibrate/G34_M422.cpp
@@ -0,0 +1,286 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(Z_STEPPER_AUTO_ALIGN)
+
+#include "../gcode.h"
+#include "../../module/delta.h"
+#include "../../module/motion.h"
+#include "../../module/stepper.h"
+#include "../../module/endstops.h"
+
+#if HOTENDS > 1
+  #include "../../module/tool_change.h"
+#endif
+
+#if HAS_BED_PROBE
+  #include "../../module/probe.h"
+#endif
+
+#if HAS_LEVELING
+  #include "../../feature/bedlevel/bedlevel.h"
+#endif
+
+float z_auto_align_xpos[Z_STEPPER_COUNT] = Z_STEPPER_ALIGN_X,
+      z_auto_align_ypos[Z_STEPPER_COUNT] = Z_STEPPER_ALIGN_Y;
+
+inline void set_all_z_lock(const bool lock) {
+  stepper.set_z_lock(lock);
+  stepper.set_z2_lock(lock);
+  #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+    stepper.set_z3_lock(lock);
+  #endif
+}
+
+/**
+ * G34: Z-Stepper automatic alignment
+ *
+ * Parameters: I<iterations> T<accuracy> A<amplification>
+ */
+void GcodeSuite::G34() {
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOLNPGM(">>> G34");
+      log_machine_info();
+    }
+  #endif
+
+  do { // break out on error
+
+    if (!TEST(axis_known_position, X_AXIS) || !TEST(axis_known_position, Y_AXIS)) {
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> XY homing required.");
+      #endif
+      break;
+    }
+
+    const int8_t z_auto_align_iterations = parser.intval('I', Z_STEPPER_ALIGN_ITERATIONS);
+    if (!WITHIN(z_auto_align_iterations, 1, 30)) {
+      SERIAL_ECHOLNPGM("?(I)teration out of bounds (1-30).");
+      break;
+    }
+
+    const float z_auto_align_accuracy = parser.floatval('T', Z_STEPPER_ALIGN_ACC);
+    if (!WITHIN(z_auto_align_accuracy, 0.01f, 1.0f)) {
+      SERIAL_ECHOLNPGM("?(T)arget accuracy out of bounds (0.01-1.0).");
+      break;
+    }
+
+    const float z_auto_align_amplification = parser.floatval('A', Z_STEPPER_ALIGN_AMP);
+    if (!WITHIN(z_auto_align_amplification, 0.5f, 2.0f)) {
+      SERIAL_ECHOLNPGM("?(A)mplification out of bounds (0.5-2.0).");
+      break;
+    }
+
+    // Wait for planner moves to finish!
+    planner.synchronize();
+
+    // Disable the leveling matrix before auto-aligning
+    #if HAS_LEVELING
+      #if ENABLED(RESTORE_LEVELING_AFTER_G34)
+        const bool leveling_was_active = planner.leveling_active;
+      #endif
+      set_bed_leveling_enabled(false);
+    #endif
+
+    #if ENABLED(CNC_WORKSPACE_PLANES)
+      workspace_plane = PLANE_XY;
+    #endif
+
+    #if ENABLED(BLTOUCH)
+      bltouch_command(BLTOUCH_RESET);
+      set_bltouch_deployed(false);
+    #endif
+
+    // Always home with tool 0 active
+    #if HOTENDS > 1
+      const uint8_t old_tool_index = active_extruder;
+      tool_change(0, 0, true);
+    #endif
+
+    #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+      extruder_duplication_enabled = false;
+    #endif
+
+    // Remember corrections to determine errors on each iteration
+    float last_z_align_move[Z_STEPPER_COUNT] = ARRAY_N(Z_STEPPER_COUNT, 10000.0f, 10000.0f, 10000.0f),
+          z_measured[Z_STEPPER_COUNT] = { 0 };
+    bool err_break = false;
+    for (uint8_t iteration = 0; iteration < z_auto_align_iterations; ++iteration) {
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> probing all positions.");
+      #endif
+
+      // Reset minimum value
+      float z_measured_min = 100000.0f;
+      // For each iteration go through all probe positions (one per Z-Stepper)
+      for (uint8_t zstepper = 0; zstepper < Z_STEPPER_COUNT; ++zstepper) {
+        // Probe a Z height for each stepper
+        z_measured[zstepper] = probe_pt(z_auto_align_xpos[zstepper], z_auto_align_ypos[zstepper], PROBE_PT_RAISE, false);
+
+        // Stop on error
+        if (isnan(z_measured[zstepper])) {
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> PROBING FAILED!");
+          #endif
+          err_break = true;
+          break;
+        }
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_ECHOPAIR("> Z", int(zstepper + 1));
+            SERIAL_ECHOLNPAIR(" measured position is ", z_measured[zstepper]);
+          }
+        #endif
+
+        // Remember the maximum position to calculate the correction
+        z_measured_min = MIN(z_measured_min, z_measured[zstepper]);
+      }
+
+      if (err_break) break;
+
+      // Remember the current z position to return to
+      float z_original_position = current_position[Z_AXIS];
+
+      // Iterations can stop early if all corrections are below required accuracy
+      bool success_break = true;
+      // Correct stepper offsets and re-iterate
+      for (uint8_t zstepper = 0; zstepper < Z_STEPPER_COUNT; ++zstepper) {
+        stepper.set_separate_multi_axis(true);
+        set_all_z_lock(true); // Steppers will be enabled separately
+
+        // Calculate current stepper move
+        const float z_align_move = z_measured[zstepper] - z_measured_min,
+                    z_align_abs = ABS(z_align_move);
+
+        // Check for lost accuracy compared to last move
+        if (last_z_align_move[zstepper] < z_align_abs - 1.0) {
+          // Stop here
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> detected decreasing accuracy.");
+          #endif
+          err_break = true;
+          break;
+        }
+        else
+          last_z_align_move[zstepper] = z_align_abs;
+
+        // Only stop early if all measured points achieve accuracy target
+        if (z_align_abs > z_auto_align_accuracy) success_break = false;
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_ECHOPAIR("> Z", int(zstepper + 1));
+            SERIAL_ECHOLNPAIR(" corrected by ", z_align_move);
+          }
+        #endif
+
+        switch (zstepper) {
+          case 0: stepper.set_z_lock(false); break;
+          case 1: stepper.set_z2_lock(false); break;
+          #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+            case 2: stepper.set_z3_lock(false); break;
+          #endif
+        }
+
+        // This will lose home position and require re-homing
+        do_blocking_move_to_z(z_auto_align_amplification * z_align_move + current_position[Z_AXIS]);
+      }
+
+      if (err_break) break;
+
+      // Move Z back to previous position
+      set_all_z_lock(true);
+      do_blocking_move_to_z(z_original_position);
+      set_all_z_lock(false);
+
+      stepper.set_separate_multi_axis(false);
+
+      if (success_break) {
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> achieved target accuracy.");
+        #endif
+        break;
+      }
+    }
+
+    if (err_break) break;
+
+    // Restore the active tool after homing
+    #if HOTENDS > 1
+      tool_change(old_tool_index, 0,
+        #if ENABLED(PARKING_EXTRUDER)
+          false // Fetch the previous toolhead
+        #else
+          true
+        #endif
+      );
+    #endif
+
+    #if HAS_LEVELING
+      #if ENABLED(RESTORE_LEVELING_AFTER_G34)
+        set_bed_leveling_enabled(leveling_was_active);
+      #endif
+    #endif
+
+    // After this operation the z position needs correction
+    set_axis_is_not_at_home(Z_AXIS);
+
+    gcode.G28(false);
+
+  } while(0);
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G34");
+  #endif
+}
+
+/**
+ * M422: Z-Stepper automatic alignment parameter selection
+ */
+void GcodeSuite::M422() {
+  const int8_t zstepper = parser.intval('S') - 1;
+  if (!WITHIN(zstepper, 0, Z_STEPPER_COUNT - 1)) {
+    SERIAL_PROTOCOLLNPGM("?(S) Z-Stepper index invalid.");
+    return;
+  }
+
+  const float x_pos = parser.floatval('X', z_auto_align_xpos[zstepper]);
+  if (!WITHIN(x_pos, X_MIN_POS, X_MAX_POS)) {
+    SERIAL_PROTOCOLLNPGM("?(X) out of bounds.");
+    return;
+  }
+
+  const float y_pos = parser.floatval('Y', z_auto_align_ypos[zstepper]);
+  if (!WITHIN(y_pos, Y_MIN_POS, Y_MAX_POS)) {
+    SERIAL_PROTOCOLLNPGM("?(Y) out of bounds.");
+    return;
+  }
+
+  z_auto_align_xpos[zstepper] = x_pos;
+  z_auto_align_ypos[zstepper] = y_pos;
+}
+
+#endif // Z_STEPPER_AUTO_ALIGN
