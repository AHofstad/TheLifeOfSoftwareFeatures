commit 3b681f7b7450582e0fca2425aabf47b37624cbda
Author: Roi Rodr√≠guez Huertas <roiamorin69@gmail.com>
Date:   Mon Jun 5 07:13:57 2023 +0200

    üîß TMC Driver axis baud for Soft Serial (#25664)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 1e8782753a..ce99d87f09 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -514,154 +514,154 @@ enum StealthIndex : uint8_t {
       #ifdef X_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(X);
       #else
-        stepperX.beginSerial(TMC_BAUD_RATE);
+        stepperX.beginSerial(TMC_X_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(X2)
       #ifdef X2_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(X2);
       #else
-        stepperX2.beginSerial(TMC_BAUD_RATE);
+        stepperX2.beginSerial(TMC_X2_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Y)
       #ifdef Y_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(Y);
       #else
-        stepperY.beginSerial(TMC_BAUD_RATE);
+        stepperY.beginSerial(TMC_Y_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Y2)
       #ifdef Y2_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(Y2);
       #else
-        stepperY2.beginSerial(TMC_BAUD_RATE);
+        stepperY2.beginSerial(TMC_Y2_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Z)
       #ifdef Z_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(Z);
       #else
-        stepperZ.beginSerial(TMC_BAUD_RATE);
+        stepperZ.beginSerial(TMC_Z_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Z2)
       #ifdef Z2_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(Z2);
       #else
-        stepperZ2.beginSerial(TMC_BAUD_RATE);
+        stepperZ2.beginSerial(TMC_Z2_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Z3)
       #ifdef Z3_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(Z3);
       #else
-        stepperZ3.beginSerial(TMC_BAUD_RATE);
+        stepperZ3.beginSerial(TMC_Z3_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Z4)
       #ifdef Z4_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(Z4);
       #else
-        stepperZ4.beginSerial(TMC_BAUD_RATE);
+        stepperZ4.beginSerial(TMC_Z4_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(I)
       #ifdef I_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(I);
       #else
-        stepperI.beginSerial(TMC_BAUD_RATE);
+        stepperI.beginSerial(TMC_I_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(J)
       #ifdef J_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(J);
       #else
-        stepperJ.beginSerial(TMC_BAUD_RATE);
+        stepperJ.beginSerial(TMC_J_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(K)
       #ifdef K_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(K);
       #else
-        stepperK.beginSerial(TMC_BAUD_RATE);
+        stepperK.beginSerial(TMC_K_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(U)
       #ifdef U_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(U);
       #else
-        stepperU.beginSerial(TMC_BAUD_RATE);
+        stepperU.beginSerial(TMC_U_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(V)
       #ifdef V_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(V);
       #else
-        stepperV.beginSerial(TMC_BAUD_RATE);
+        stepperV.beginSerial(TMC_V_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(W)
       #ifdef W_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(W);
       #else
-        stepperW.beginSerial(TMC_BAUD_RATE);
+        stepperW.beginSerial(TMC_W_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E0)
       #ifdef E0_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(E0);
       #else
-        stepperE0.beginSerial(TMC_BAUD_RATE);
+        stepperE0.beginSerial(TMC_E0_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E1)
       #ifdef E1_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(E1);
       #else
-        stepperE1.beginSerial(TMC_BAUD_RATE);
+        stepperE1.beginSerial(TMC_E1_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E2)
       #ifdef E2_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(E2);
       #else
-        stepperE2.beginSerial(TMC_BAUD_RATE);
+        stepperE2.beginSerial(TMC_E2_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E3)
       #ifdef E3_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(E3);
       #else
-        stepperE3.beginSerial(TMC_BAUD_RATE);
+        stepperE3.beginSerial(TMC_E3_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E4)
       #ifdef E4_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(E4);
       #else
-        stepperE4.beginSerial(TMC_BAUD_RATE);
+        stepperE4.beginSerial(TMC_E4_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E5)
       #ifdef E5_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(E5);
       #else
-        stepperE5.beginSerial(TMC_BAUD_RATE);
+        stepperE5.beginSerial(TMC_E5_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E6)
       #ifdef E6_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(E6);
       #else
-        stepperE6.beginSerial(TMC_BAUD_RATE);
+        stepperE6.beginSerial(TMC_E6_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E7)
       #ifdef E7_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(E7);
       #else
-        stepperE7.beginSerial(TMC_BAUD_RATE);
+        stepperE7.beginSerial(TMC_E7_BAUD_RATE);
       #endif
     #endif
   }

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 7649c52f5c..1e8782753a 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -501,7 +501,7 @@ enum StealthIndex : uint8_t {
       struct {
         const void *ptr[TMCAxis::TOTAL];
         bool began(const TMCAxis a, const void * const p) {
-          LOOP_L_N(i, a) if (p == ptr[i]) return true;
+          for (uint8_t i = 0; i < a; ++i) if (p == ptr[i]) return true;
           ptr[a] = p; return false;
         };
       } sp_helper;

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    üö∏ Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 3db2c0827e..7649c52f5c 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -493,7 +493,7 @@ enum StealthIndex : uint8_t {
   #endif
 
   #define _EN_ITEM(N) , E##N
-  enum TMCAxis : uint8_t { MAIN_AXIS_NAMES, X2, Y2, Z2, Z3, Z4 REPEAT(EXTRUDERS, _EN_ITEM), TOTAL };
+  enum TMCAxis : uint8_t { MAIN_AXIS_NAMES_ X2, Y2, Z2, Z3, Z4 REPEAT(EXTRUDERS, _EN_ITEM), TOTAL };
   #undef _EN_ITEM
 
   void tmc_serial_begin() {

commit 85325f585ac4a9bb667423561540b5d58bdc3b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 19:37:13 2023 -0500

    üßë‚Äçüíª Endstops preliminary work (#25780)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 893ce3f8db..3db2c0827e 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -991,13 +991,13 @@ void reset_trinamic_drivers() {
 
   #if USE_SENSORLESS
     TERN_(X_SENSORLESS, stepperX.homing_threshold(X_STALL_SENSITIVITY));
-    TERN_(X2_SENSORLESS, stepperX2.homing_threshold(CAT(TERN(X2_SENSORLESS, X2, X), _STALL_SENSITIVITY)));
+    TERN_(X2_SENSORLESS, stepperX2.homing_threshold(X2_STALL_SENSITIVITY));
     TERN_(Y_SENSORLESS, stepperY.homing_threshold(Y_STALL_SENSITIVITY));
-    TERN_(Y2_SENSORLESS, stepperY2.homing_threshold(CAT(TERN(Y2_SENSORLESS, Y2, Y), _STALL_SENSITIVITY)));
+    TERN_(Y2_SENSORLESS, stepperY2.homing_threshold(Y2_STALL_SENSITIVITY));
     TERN_(Z_SENSORLESS, stepperZ.homing_threshold(Z_STALL_SENSITIVITY));
-    TERN_(Z2_SENSORLESS, stepperZ2.homing_threshold(CAT(TERN(Z2_SENSORLESS, Z2, Z), _STALL_SENSITIVITY)));
-    TERN_(Z3_SENSORLESS, stepperZ3.homing_threshold(CAT(TERN(Z3_SENSORLESS, Z3, Z), _STALL_SENSITIVITY)));
-    TERN_(Z4_SENSORLESS, stepperZ4.homing_threshold(CAT(TERN(Z4_SENSORLESS, Z4, Z), _STALL_SENSITIVITY)));
+    TERN_(Z2_SENSORLESS, stepperZ2.homing_threshold(Z2_STALL_SENSITIVITY));
+    TERN_(Z3_SENSORLESS, stepperZ3.homing_threshold(Z3_STALL_SENSITIVITY));
+    TERN_(Z4_SENSORLESS, stepperZ4.homing_threshold(Z4_STALL_SENSITIVITY));
     TERN_(I_SENSORLESS, stepperI.homing_threshold(I_STALL_SENSITIVITY));
     TERN_(J_SENSORLESS, stepperJ.homing_threshold(J_STALL_SENSITIVITY));
     TERN_(K_SENSORLESS, stepperK.homing_threshold(K_STALL_SENSITIVITY));

commit f0f7ec88823318c7d778e42b4dc7604120943032
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 23 00:47:44 2023 -0500

    üßë‚Äçüíª Stepper::set_directions() => apply_directions()

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 02ae9cb1e4..893ce3f8db 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -1010,7 +1010,7 @@ void reset_trinamic_drivers() {
     TMC_ADV()
   #endif
 
-  stepper.set_directions();
+  stepper.apply_directions();
 }
 
 // TMC Slave Address Conflict Detection

commit 769ad2764512b38e987ebbed1fe026d68a424bb1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 24 00:33:39 2023 -0500

    üé® TMC SPI Pins
    
    Co-Authored-By: Martin Turski <turningtides@outlook.de>

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 7d87e5953f..02ae9cb1e4 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -46,7 +46,7 @@ enum StealthIndex : uint8_t {
 //   AI = Axis Enum Index
 // SWHW = SW/SH UART selection
 #if ENABLED(TMC_USE_SW_SPI)
-  #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, float(ST##_RSENSE), TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK, ST##_CHAIN_POS)
+  #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, float(ST##_RSENSE), TMC_SPI_MOSI, TMC_SPI_MISO, TMC_SPI_SCK, ST##_CHAIN_POS)
 #else
   #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, float(ST##_RSENSE), ST##_CHAIN_POS)
 #endif

commit 98c0cc044d1be2c098335d9656f2d0eadf524129
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sat Mar 18 00:22:17 2023 -0700

    üîß SQUARE_WAVE_STEPPING => EDGE_STEPPING (#25526)
    
    Co-Authored-By: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 48ce020d3d..7d87e5953f 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -227,7 +227,7 @@ enum StealthIndex : uint8_t {
     chopconf.intpol = interpolate;
     chopconf.hend = chop_init.hend + 3;
     chopconf.hstrt = chop_init.hstrt - 1;
-    TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
+    TERN_(EDGE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, hold_multiplier);
@@ -262,7 +262,7 @@ enum StealthIndex : uint8_t {
     chopconf.intpol = interpolate;
     chopconf.hend = chop_init.hend + 3;
     chopconf.hstrt = chop_init.hstrt - 1;
-    TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
+    TERN_(EDGE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, hold_multiplier);
@@ -684,7 +684,7 @@ enum StealthIndex : uint8_t {
     chopconf.intpol = interpolate;
     chopconf.hend = chop_init.hend + 3;
     chopconf.hstrt = chop_init.hstrt - 1;
-    TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
+    TERN_(EDGE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, hold_multiplier);
@@ -726,7 +726,7 @@ enum StealthIndex : uint8_t {
     chopconf.intpol = interpolate;
     chopconf.hend = chop_init.hend + 3;
     chopconf.hstrt = chop_init.hstrt - 1;
-    TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
+    TERN_(EDGE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, hold_multiplier);
@@ -766,7 +766,7 @@ enum StealthIndex : uint8_t {
     st.sdoff(0);
     st.rms_current(mA);
     st.microsteps(microsteps);
-    TERN_(SQUARE_WAVE_STEPPING, st.dedge(true));
+    TERN_(EDGE_STEPPING, st.dedge(true));
     st.intpol(interpolate);
     st.diss2g(true); // Disable short to ground protection. Too many false readings?
     TERN_(TMC_DEBUG, st.rdsel(0b01));
@@ -784,7 +784,7 @@ enum StealthIndex : uint8_t {
     chopconf.intpol = interpolate;
     chopconf.hend = chop_init.hend + 3;
     chopconf.hstrt = chop_init.hstrt - 1;
-    TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
+    TERN_(EDGE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, hold_multiplier);
@@ -819,7 +819,7 @@ enum StealthIndex : uint8_t {
     chopconf.intpol = interpolate;
     chopconf.hend = chop_init.hend + 3;
     chopconf.hstrt = chop_init.hstrt - 1;
-    TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
+    TERN_(EDGE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, hold_multiplier);

commit cc1069a3f00fb4422bf372e409e95849c1c8322e
Author: Manuel McLure <manuel@mclure.org>
Date:   Sat Nov 26 18:30:59 2022 -0800

    üîß Merge TMC26X with TMC config (#24373)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index bf36f83cd8..48ce020d3d 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -1023,8 +1023,6 @@ void reset_trinamic_drivers() {
 // 2. For each axis in use, static_assert using a constexpr function, which counts the
 //      number of matching/conflicting axis. If the value is not exactly 1, fail.
 
-#define ALL_AXIS_NAMES X, X2, Y, Y2, Z, Z2, Z3, Z4, I, J, K, U, V, W, E0, E1, E2, E3, E4, E5, E6, E7
-
 #if ANY_AXIS_HAS(HW_SERIAL)
   // Hardware serial names are compared as strings, since actually resolving them cannot occur in a constexpr.
   // Using a fixed-length character array for the port name allows this to be constexpr compatible.

commit 6cbd7a48d16789fd73ab6ebe4be00bc2beff5591
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 20 21:15:57 2022 -0500

    üé® Fix comments, formatting

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 7637351556..bf36f83cd8 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -1030,10 +1030,8 @@ void reset_trinamic_drivers() {
   // Using a fixed-length character array for the port name allows this to be constexpr compatible.
   struct SanityHwSerialDetails { const char port[20]; uint32_t address; };
   #define TMC_HW_DETAIL_ARGS(A) TERN(A##_HAS_HW_SERIAL, STRINGIFY(A##_HARDWARE_SERIAL), ""), TERN0(A##_HAS_HW_SERIAL, A##_SLAVE_ADDRESS)
-  #define TMC_HW_DETAIL(A) { TMC_HW_DETAIL_ARGS(A) },
-  constexpr SanityHwSerialDetails sanity_tmc_hw_details[] = {
-    MAP(TMC_HW_DETAIL, ALL_AXIS_NAMES)
-  };
+  #define TMC_HW_DETAIL(A) { TMC_HW_DETAIL_ARGS(A) }
+  constexpr SanityHwSerialDetails sanity_tmc_hw_details[] = { MAPLIST(TMC_HW_DETAIL, ALL_AXIS_NAMES) };
 
   // constexpr compatible string comparison
   constexpr bool str_eq_ce(const char * a, const char * b) {
@@ -1057,10 +1055,8 @@ void reset_trinamic_drivers() {
 #if ANY_AXIS_HAS(SW_SERIAL)
   struct SanitySwSerialDetails { int32_t txpin; int32_t rxpin; uint32_t address; };
   #define TMC_SW_DETAIL_ARGS(A) TERN(A##_HAS_SW_SERIAL, A##_SERIAL_TX_PIN, -1), TERN(A##_HAS_SW_SERIAL, A##_SERIAL_RX_PIN, -1), TERN0(A##_HAS_SW_SERIAL, A##_SLAVE_ADDRESS)
-  #define TMC_SW_DETAIL(A) TMC_SW_DETAIL_ARGS(A),
-  constexpr SanitySwSerialDetails sanity_tmc_sw_details[] = {
-    MAP(TMC_SW_DETAIL, ALL_AXIS_NAMES)
-  };
+  #define TMC_SW_DETAIL(A) { TMC_SW_DETAIL_ARGS(A) }
+  constexpr SanitySwSerialDetails sanity_tmc_sw_details[] = { MAPLIST(TMC_SW_DETAIL, ALL_AXIS_NAMES) };
 
   constexpr bool sc_sw_done(size_t start, size_t end) { return start == end; }
   constexpr bool sc_sw_skip(int32_t txpin) { return txpin < 0; }

commit c5126de559719ebdaf4475b0db4ab21c26b90a1a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 22 16:08:29 2022 -0500

    üßë‚Äçüíª MAP macro for axis lists, etc. (#24191)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index ee156a1986..7637351556 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -493,7 +493,7 @@ enum StealthIndex : uint8_t {
   #endif
 
   #define _EN_ITEM(N) , E##N
-  enum TMCAxis : uint8_t { NUM_AXIS_LIST(X, Y, Z, I, J, K, U, V, W), X2, Y2, Z2, Z3, Z4 REPEAT(EXTRUDERS, _EN_ITEM), TOTAL };
+  enum TMCAxis : uint8_t { MAIN_AXIS_NAMES, X2, Y2, Z2, Z3, Z4 REPEAT(EXTRUDERS, _EN_ITEM), TOTAL };
   #undef _EN_ITEM
 
   void tmc_serial_begin() {
@@ -1023,18 +1023,16 @@ void reset_trinamic_drivers() {
 // 2. For each axis in use, static_assert using a constexpr function, which counts the
 //      number of matching/conflicting axis. If the value is not exactly 1, fail.
 
+#define ALL_AXIS_NAMES X, X2, Y, Y2, Z, Z2, Z3, Z4, I, J, K, U, V, W, E0, E1, E2, E3, E4, E5, E6, E7
+
 #if ANY_AXIS_HAS(HW_SERIAL)
   // Hardware serial names are compared as strings, since actually resolving them cannot occur in a constexpr.
   // Using a fixed-length character array for the port name allows this to be constexpr compatible.
   struct SanityHwSerialDetails { const char port[20]; uint32_t address; };
   #define TMC_HW_DETAIL_ARGS(A) TERN(A##_HAS_HW_SERIAL, STRINGIFY(A##_HARDWARE_SERIAL), ""), TERN0(A##_HAS_HW_SERIAL, A##_SLAVE_ADDRESS)
-  #define TMC_HW_DETAIL(A) { TMC_HW_DETAIL_ARGS(A) }
+  #define TMC_HW_DETAIL(A) { TMC_HW_DETAIL_ARGS(A) },
   constexpr SanityHwSerialDetails sanity_tmc_hw_details[] = {
-    TMC_HW_DETAIL(X), TMC_HW_DETAIL(X2),
-    TMC_HW_DETAIL(Y), TMC_HW_DETAIL(Y2),
-    TMC_HW_DETAIL(Z), TMC_HW_DETAIL(Z2), TMC_HW_DETAIL(Z3), TMC_HW_DETAIL(Z4),
-    TMC_HW_DETAIL(I), TMC_HW_DETAIL(J), TMC_HW_DETAIL(K), TMC_HW_DETAIL(U), TMC_HW_DETAIL(V), TMC_HW_DETAIL(W),
-    TMC_HW_DETAIL(E0), TMC_HW_DETAIL(E1), TMC_HW_DETAIL(E2), TMC_HW_DETAIL(E3), TMC_HW_DETAIL(E4), TMC_HW_DETAIL(E5), TMC_HW_DETAIL(E6), TMC_HW_DETAIL(E7)
+    MAP(TMC_HW_DETAIL, ALL_AXIS_NAMES)
   };
 
   // constexpr compatible string comparison
@@ -1053,23 +1051,15 @@ void reset_trinamic_drivers() {
 
   #define TMC_HWSERIAL_CONFLICT_MSG(A) STRINGIFY(A) "_SLAVE_ADDRESS conflicts with another driver using the same " STRINGIFY(A) "_HARDWARE_SERIAL"
   #define SA_NO_TMC_HW_C(A) static_assert(1 >= count_tmc_hw_serial_matches(TMC_HW_DETAIL_ARGS(A), 0, COUNT(sanity_tmc_hw_details)), TMC_HWSERIAL_CONFLICT_MSG(A));
-  SA_NO_TMC_HW_C(X); SA_NO_TMC_HW_C(X2);
-  SA_NO_TMC_HW_C(Y); SA_NO_TMC_HW_C(Y2);
-  SA_NO_TMC_HW_C(Z); SA_NO_TMC_HW_C(Z2); SA_NO_TMC_HW_C(Z3); SA_NO_TMC_HW_C(Z4);
-  SA_NO_TMC_HW_C(I); SA_NO_TMC_HW_C(J); SA_NO_TMC_HW_C(K); SA_NO_TMC_HW_C(U); SA_NO_TMC_HW_C(V); SA_NO_TMC_HW_C(W);
-  SA_NO_TMC_HW_C(E0); SA_NO_TMC_HW_C(E1); SA_NO_TMC_HW_C(E2); SA_NO_TMC_HW_C(E3); SA_NO_TMC_HW_C(E4); SA_NO_TMC_HW_C(E5); SA_NO_TMC_HW_C(E6); SA_NO_TMC_HW_C(E7);
+  MAP(SA_NO_TMC_HW_C, ALL_AXIS_NAMES)
 #endif
 
 #if ANY_AXIS_HAS(SW_SERIAL)
   struct SanitySwSerialDetails { int32_t txpin; int32_t rxpin; uint32_t address; };
   #define TMC_SW_DETAIL_ARGS(A) TERN(A##_HAS_SW_SERIAL, A##_SERIAL_TX_PIN, -1), TERN(A##_HAS_SW_SERIAL, A##_SERIAL_RX_PIN, -1), TERN0(A##_HAS_SW_SERIAL, A##_SLAVE_ADDRESS)
-  #define TMC_SW_DETAIL(A) TMC_SW_DETAIL_ARGS(A)
+  #define TMC_SW_DETAIL(A) TMC_SW_DETAIL_ARGS(A),
   constexpr SanitySwSerialDetails sanity_tmc_sw_details[] = {
-    TMC_SW_DETAIL(X), TMC_SW_DETAIL(X2),
-    TMC_SW_DETAIL(Y), TMC_SW_DETAIL(Y2),
-    TMC_SW_DETAIL(Z), TMC_SW_DETAIL(Z2), TMC_SW_DETAIL(Z3), TMC_SW_DETAIL(Z4),
-    TMC_SW_DETAIL(I), TMC_SW_DETAIL(J), TMC_SW_DETAIL(K), TMC_SW_DETAIL(U), TMC_SW_DETAIL(V), TMC_SW_DETAIL(W),
-    TMC_SW_DETAIL(E0), TMC_SW_DETAIL(E1), TMC_SW_DETAIL(E2), TMC_SW_DETAIL(E3), TMC_SW_DETAIL(E4), TMC_SW_DETAIL(E5), TMC_SW_DETAIL(E6), TMC_SW_DETAIL(E7)
+    MAP(TMC_SW_DETAIL, ALL_AXIS_NAMES)
   };
 
   constexpr bool sc_sw_done(size_t start, size_t end) { return start == end; }
@@ -1083,11 +1073,7 @@ void reset_trinamic_drivers() {
 
   #define TMC_SWSERIAL_CONFLICT_MSG(A) STRINGIFY(A) "_SLAVE_ADDRESS conflicts with another driver using the same " STRINGIFY(A) "_SERIAL_RX_PIN or " STRINGIFY(A) "_SERIAL_TX_PIN"
   #define SA_NO_TMC_SW_C(A) static_assert(1 >= count_tmc_sw_serial_matches(TMC_SW_DETAIL_ARGS(A), 0, COUNT(sanity_tmc_sw_details)), TMC_SWSERIAL_CONFLICT_MSG(A));
-  SA_NO_TMC_SW_C(X); SA_NO_TMC_SW_C(X2);
-  SA_NO_TMC_SW_C(Y); SA_NO_TMC_SW_C(Y2);
-  SA_NO_TMC_SW_C(Z); SA_NO_TMC_SW_C(Z2); SA_NO_TMC_SW_C(Z3); SA_NO_TMC_SW_C(Z4);
-  SA_NO_TMC_SW_C(I); SA_NO_TMC_SW_C(J); SA_NO_TMC_SW_C(K); SA_NO_TMC_SW_C(U); SA_NO_TMC_SW_C(V); SA_NO_TMC_SW_C(W);
-  SA_NO_TMC_SW_C(E0); SA_NO_TMC_SW_C(E1); SA_NO_TMC_SW_C(E2); SA_NO_TMC_SW_C(E3); SA_NO_TMC_SW_C(E4); SA_NO_TMC_SW_C(E5); SA_NO_TMC_SW_C(E6); SA_NO_TMC_SW_C(E7);
+  MAP(SA_NO_TMC_SW_C, ALL_AXIS_NAMES)
 #endif
 
 #endif // HAS_TRINAMIC_CONFIG

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index af09623dc1..ee156a1986 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -36,7 +36,7 @@
 #include <SPI.h>
 
 enum StealthIndex : uint8_t {
-  LOGICAL_AXIS_LIST(STEALTH_AXIS_E, STEALTH_AXIS_X, STEALTH_AXIS_Y, STEALTH_AXIS_Z, STEALTH_AXIS_I, STEALTH_AXIS_J, STEALTH_AXIS_K)
+  LOGICAL_AXIS_LIST(STEALTH_AXIS_E, STEALTH_AXIS_X, STEALTH_AXIS_Y, STEALTH_AXIS_Z, STEALTH_AXIS_I, STEALTH_AXIS_J, STEALTH_AXIS_K, STEALTH_AXIS_U, STEALTH_AXIS_V, STEALTH_AXIS_W)
 };
 #define TMC_INIT(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, stealthchop_by_axis[STEALTH_INDEX], chopper_timing_##ST, ST##_INTERPOLATE, ST##_HOLD_MULTIPLIER)
 
@@ -106,6 +106,15 @@ enum StealthIndex : uint8_t {
 #if AXIS_HAS_SPI(K)
   TMC_SPI_DEFINE(K, K);
 #endif
+#if AXIS_HAS_SPI(U)
+  TMC_SPI_DEFINE(U, U);
+#endif
+#if AXIS_HAS_SPI(V)
+  TMC_SPI_DEFINE(V, V);
+#endif
+#if AXIS_HAS_SPI(W)
+  TMC_SPI_DEFINE(W, W);
+#endif
 #if AXIS_HAS_SPI(E0)
   TMC_SPI_DEFINE_E(0);
 #endif
@@ -173,6 +182,15 @@ enum StealthIndex : uint8_t {
 #ifndef TMC_K_BAUD_RATE
   #define TMC_K_BAUD_RATE TMC_BAUD_RATE
 #endif
+#ifndef TMC_U_BAUD_RATE
+  #define TMC_U_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_V_BAUD_RATE
+  #define TMC_V_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_W_BAUD_RATE
+  #define TMC_W_BAUD_RATE TMC_BAUD_RATE
+#endif
 #ifndef TMC_E0_BAUD_RATE
   #define TMC_E0_BAUD_RATE TMC_BAUD_RATE
 #endif
@@ -374,6 +392,32 @@ enum StealthIndex : uint8_t {
       #define K_HAS_SW_SERIAL 1
     #endif
   #endif
+  #if AXIS_HAS_UART(U)
+    #ifdef U_HARDWARE_SERIAL
+      TMC_UART_DEFINE(HW, U, U);
+      #define U_HAS_HW_SERIAL 1
+    #else
+      TMC_UART_DEFINE(SW, U, U);
+      #define U_HAS_SW_SERIAL 1
+    #endif
+  #endif
+  #if AXIS_HAS_UART(V)
+    #ifdef V_HARDWARE_SERIAL
+      TMC_UART_DEFINE(HW, V, V);
+    #else
+      TMC_UART_DEFINE(SW, V, V);
+      #define V_HAS_SW_SERIAL 1
+    #endif
+  #endif
+  #if AXIS_HAS_UART(W)
+    #ifdef W_HARDWARE_SERIAL
+      TMC_UART_DEFINE(HW, W, W);
+      #define W_HAS_HW_SERIAL 1
+    #else
+      TMC_UART_DEFINE(SW, W, W);
+      #define W_HAS_SW_SERIAL 1
+    #endif
+  #endif
 
   #if AXIS_HAS_UART(E0)
     #ifdef E0_HARDWARE_SERIAL
@@ -449,7 +493,7 @@ enum StealthIndex : uint8_t {
   #endif
 
   #define _EN_ITEM(N) , E##N
-  enum TMCAxis : uint8_t { LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4 REPEAT(EXTRUDERS, _EN_ITEM), TOTAL };
+  enum TMCAxis : uint8_t { NUM_AXIS_LIST(X, Y, Z, I, J, K, U, V, W), X2, Y2, Z2, Z3, Z4 REPEAT(EXTRUDERS, _EN_ITEM), TOTAL };
   #undef _EN_ITEM
 
   void tmc_serial_begin() {
@@ -543,6 +587,27 @@ enum StealthIndex : uint8_t {
         stepperK.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
+    #if AXIS_HAS_UART(U)
+      #ifdef U_HARDWARE_SERIAL
+        HW_SERIAL_BEGIN(U);
+      #else
+        stepperU.beginSerial(TMC_BAUD_RATE);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(V)
+      #ifdef V_HARDWARE_SERIAL
+        HW_SERIAL_BEGIN(V);
+      #else
+        stepperV.beginSerial(TMC_BAUD_RATE);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(W)
+      #ifdef W_HARDWARE_SERIAL
+        HW_SERIAL_BEGIN(W);
+      #else
+        stepperW.beginSerial(TMC_BAUD_RATE);
+      #endif
+    #endif
     #if AXIS_HAS_UART(E0)
       #ifdef E0_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(E0);
@@ -814,6 +879,15 @@ void restore_trinamic_drivers() {
   #if AXIS_IS_TMC(K)
     stepperK.push();
   #endif
+  #if AXIS_IS_TMC(U)
+    stepperU.push();
+  #endif
+  #if AXIS_IS_TMC(V)
+    stepperV.push();
+  #endif
+  #if AXIS_IS_TMC(W)
+    stepperW.push();
+  #endif
   #if AXIS_IS_TMC(E0)
     stepperE0.push();
   #endif
@@ -844,7 +918,8 @@ void reset_trinamic_drivers() {
   static constexpr bool stealthchop_by_axis[] = LOGICAL_AXIS_ARRAY(
     ENABLED(STEALTHCHOP_E),
     ENABLED(STEALTHCHOP_XY), ENABLED(STEALTHCHOP_XY), ENABLED(STEALTHCHOP_Z),
-    ENABLED(STEALTHCHOP_I), ENABLED(STEALTHCHOP_J), ENABLED(STEALTHCHOP_K)
+    ENABLED(STEALTHCHOP_I), ENABLED(STEALTHCHOP_J), ENABLED(STEALTHCHOP_K),
+    ENABLED(STEALTHCHOP_U), ENABLED(STEALTHCHOP_V), ENABLED(STEALTHCHOP_W)
   );
 
   #if AXIS_IS_TMC(X)
@@ -880,6 +955,15 @@ void reset_trinamic_drivers() {
   #if AXIS_IS_TMC(K)
     TMC_INIT(K, STEALTH_AXIS_K);
   #endif
+  #if AXIS_IS_TMC(U)
+    TMC_INIT(U, STEALTH_AXIS_U);
+  #endif
+  #if AXIS_IS_TMC(V)
+    TMC_INIT(V, STEALTH_AXIS_V);
+  #endif
+  #if AXIS_IS_TMC(W)
+    TMC_INIT(W, STEALTH_AXIS_W);
+  #endif
   #if AXIS_IS_TMC(E0)
     TMC_INIT(E0, STEALTH_AXIS_E);
   #endif
@@ -917,6 +1001,9 @@ void reset_trinamic_drivers() {
     TERN_(I_SENSORLESS, stepperI.homing_threshold(I_STALL_SENSITIVITY));
     TERN_(J_SENSORLESS, stepperJ.homing_threshold(J_STALL_SENSITIVITY));
     TERN_(K_SENSORLESS, stepperK.homing_threshold(K_STALL_SENSITIVITY));
+    TERN_(U_SENSORLESS, stepperU.homing_threshold(U_STALL_SENSITIVITY));
+    TERN_(V_SENSORLESS, stepperV.homing_threshold(V_STALL_SENSITIVITY));
+    TERN_(W_SENSORLESS, stepperW.homing_threshold(W_STALL_SENSITIVITY));
   #endif
 
   #ifdef TMC_ADV
@@ -946,7 +1033,7 @@ void reset_trinamic_drivers() {
     TMC_HW_DETAIL(X), TMC_HW_DETAIL(X2),
     TMC_HW_DETAIL(Y), TMC_HW_DETAIL(Y2),
     TMC_HW_DETAIL(Z), TMC_HW_DETAIL(Z2), TMC_HW_DETAIL(Z3), TMC_HW_DETAIL(Z4),
-    TMC_HW_DETAIL(I), TMC_HW_DETAIL(J), TMC_HW_DETAIL(K),
+    TMC_HW_DETAIL(I), TMC_HW_DETAIL(J), TMC_HW_DETAIL(K), TMC_HW_DETAIL(U), TMC_HW_DETAIL(V), TMC_HW_DETAIL(W),
     TMC_HW_DETAIL(E0), TMC_HW_DETAIL(E1), TMC_HW_DETAIL(E2), TMC_HW_DETAIL(E3), TMC_HW_DETAIL(E4), TMC_HW_DETAIL(E5), TMC_HW_DETAIL(E6), TMC_HW_DETAIL(E7)
   };
 
@@ -969,7 +1056,7 @@ void reset_trinamic_drivers() {
   SA_NO_TMC_HW_C(X); SA_NO_TMC_HW_C(X2);
   SA_NO_TMC_HW_C(Y); SA_NO_TMC_HW_C(Y2);
   SA_NO_TMC_HW_C(Z); SA_NO_TMC_HW_C(Z2); SA_NO_TMC_HW_C(Z3); SA_NO_TMC_HW_C(Z4);
-  SA_NO_TMC_HW_C(I); SA_NO_TMC_HW_C(J); SA_NO_TMC_HW_C(K);
+  SA_NO_TMC_HW_C(I); SA_NO_TMC_HW_C(J); SA_NO_TMC_HW_C(K); SA_NO_TMC_HW_C(U); SA_NO_TMC_HW_C(V); SA_NO_TMC_HW_C(W);
   SA_NO_TMC_HW_C(E0); SA_NO_TMC_HW_C(E1); SA_NO_TMC_HW_C(E2); SA_NO_TMC_HW_C(E3); SA_NO_TMC_HW_C(E4); SA_NO_TMC_HW_C(E5); SA_NO_TMC_HW_C(E6); SA_NO_TMC_HW_C(E7);
 #endif
 
@@ -981,7 +1068,7 @@ void reset_trinamic_drivers() {
     TMC_SW_DETAIL(X), TMC_SW_DETAIL(X2),
     TMC_SW_DETAIL(Y), TMC_SW_DETAIL(Y2),
     TMC_SW_DETAIL(Z), TMC_SW_DETAIL(Z2), TMC_SW_DETAIL(Z3), TMC_SW_DETAIL(Z4),
-    TMC_SW_DETAIL(I), TMC_SW_DETAIL(J), TMC_SW_DETAIL(K),
+    TMC_SW_DETAIL(I), TMC_SW_DETAIL(J), TMC_SW_DETAIL(K), TMC_SW_DETAIL(U), TMC_SW_DETAIL(V), TMC_SW_DETAIL(W),
     TMC_SW_DETAIL(E0), TMC_SW_DETAIL(E1), TMC_SW_DETAIL(E2), TMC_SW_DETAIL(E3), TMC_SW_DETAIL(E4), TMC_SW_DETAIL(E5), TMC_SW_DETAIL(E6), TMC_SW_DETAIL(E7)
   };
 
@@ -999,7 +1086,7 @@ void reset_trinamic_drivers() {
   SA_NO_TMC_SW_C(X); SA_NO_TMC_SW_C(X2);
   SA_NO_TMC_SW_C(Y); SA_NO_TMC_SW_C(Y2);
   SA_NO_TMC_SW_C(Z); SA_NO_TMC_SW_C(Z2); SA_NO_TMC_SW_C(Z3); SA_NO_TMC_SW_C(Z4);
-  SA_NO_TMC_SW_C(I); SA_NO_TMC_SW_C(J); SA_NO_TMC_SW_C(K);
+  SA_NO_TMC_SW_C(I); SA_NO_TMC_SW_C(J); SA_NO_TMC_SW_C(K); SA_NO_TMC_SW_C(U); SA_NO_TMC_SW_C(V); SA_NO_TMC_SW_C(W);
   SA_NO_TMC_SW_C(E0); SA_NO_TMC_SW_C(E1); SA_NO_TMC_SW_C(E2); SA_NO_TMC_SW_C(E3); SA_NO_TMC_SW_C(E4); SA_NO_TMC_SW_C(E5); SA_NO_TMC_SW_C(E6); SA_NO_TMC_SW_C(E7);
 #endif
 

commit 258a2ed112da097969d36187b53805df7f98a3ec
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 22 19:17:12 2022 -0500

    üé® Apply _TERN where possible

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 7baa2108f0..af09623dc1 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -906,49 +906,18 @@ void reset_trinamic_drivers() {
   #endif
 
   #if USE_SENSORLESS
-    #if X_SENSORLESS
-      stepperX.homing_threshold(X_STALL_SENSITIVITY);
-      #if AXIS_HAS_STALLGUARD(X2)
-        stepperX2.homing_threshold(CAT(TERN(X2_SENSORLESS, X2, X), _STALL_SENSITIVITY));
-      #endif
-    #endif
-    #if Y_SENSORLESS
-      stepperY.homing_threshold(Y_STALL_SENSITIVITY);
-      #if AXIS_HAS_STALLGUARD(Y2)
-        stepperY2.homing_threshold(CAT(TERN(Y2_SENSORLESS, Y2, Y), _STALL_SENSITIVITY));
-      #endif
-    #endif
-    #if Z_SENSORLESS
-      stepperZ.homing_threshold(Z_STALL_SENSITIVITY);
-      #if AXIS_HAS_STALLGUARD(Z2)
-        stepperZ2.homing_threshold(CAT(TERN(Z2_SENSORLESS, Z2, Z), _STALL_SENSITIVITY));
-      #endif
-      #if AXIS_HAS_STALLGUARD(Z3)
-        stepperZ3.homing_threshold(CAT(TERN(Z3_SENSORLESS, Z3, Z), _STALL_SENSITIVITY));
-      #endif
-      #if AXIS_HAS_STALLGUARD(Z4)
-        stepperZ4.homing_threshold(CAT(TERN(Z4_SENSORLESS, Z4, Z), _STALL_SENSITIVITY));
-      #endif
-    #endif
-    #if I_SENSORLESS
-      stepperI.homing_threshold(I_STALL_SENSITIVITY);
-      #if AXIS_HAS_STALLGUARD(I)
-        stepperI.homing_threshold(CAT(TERN(I_SENSORLESS, I, I), _STALL_SENSITIVITY));
-      #endif
-    #endif
-    #if J_SENSORLESS
-      stepperJ.homing_threshold(J_STALL_SENSITIVITY);
-      #if AXIS_HAS_STALLGUARD(J)
-        stepperJ.homing_threshold(CAT(TERN(J_SENSORLESS, J, J), _STALL_SENSITIVITY));
-      #endif
-    #endif
-    #if K_SENSORLESS
-      stepperK.homing_threshold(K_STALL_SENSITIVITY);
-      #if AXIS_HAS_STALLGUARD(K)
-        stepperK.homing_threshold(CAT(TERN(K_SENSORLESS, K, K), _STALL_SENSITIVITY));
-      #endif
-    #endif
-  #endif // USE SENSORLESS
+    TERN_(X_SENSORLESS, stepperX.homing_threshold(X_STALL_SENSITIVITY));
+    TERN_(X2_SENSORLESS, stepperX2.homing_threshold(CAT(TERN(X2_SENSORLESS, X2, X), _STALL_SENSITIVITY)));
+    TERN_(Y_SENSORLESS, stepperY.homing_threshold(Y_STALL_SENSITIVITY));
+    TERN_(Y2_SENSORLESS, stepperY2.homing_threshold(CAT(TERN(Y2_SENSORLESS, Y2, Y), _STALL_SENSITIVITY)));
+    TERN_(Z_SENSORLESS, stepperZ.homing_threshold(Z_STALL_SENSITIVITY));
+    TERN_(Z2_SENSORLESS, stepperZ2.homing_threshold(CAT(TERN(Z2_SENSORLESS, Z2, Z), _STALL_SENSITIVITY)));
+    TERN_(Z3_SENSORLESS, stepperZ3.homing_threshold(CAT(TERN(Z3_SENSORLESS, Z3, Z), _STALL_SENSITIVITY)));
+    TERN_(Z4_SENSORLESS, stepperZ4.homing_threshold(CAT(TERN(Z4_SENSORLESS, Z4, Z), _STALL_SENSITIVITY)));
+    TERN_(I_SENSORLESS, stepperI.homing_threshold(I_STALL_SENSITIVITY));
+    TERN_(J_SENSORLESS, stepperJ.homing_threshold(J_STALL_SENSITIVITY));
+    TERN_(K_SENSORLESS, stepperK.homing_threshold(K_STALL_SENSITIVITY));
+  #endif
 
   #ifdef TMC_ADV
     TMC_ADV()

commit c74161c011abfeb7004631f63642566f37a845db
Author: fflosi <34758322+fflosi@users.noreply.github.com>
Date:   Sat Dec 25 05:57:07 2021 -0300

    ‚ú® Per-axis TMC hold multiplier (#23345)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index e8ecbf1c76..7baa2108f0 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -38,7 +38,7 @@
 enum StealthIndex : uint8_t {
   LOGICAL_AXIS_LIST(STEALTH_AXIS_E, STEALTH_AXIS_X, STEALTH_AXIS_Y, STEALTH_AXIS_Z, STEALTH_AXIS_I, STEALTH_AXIS_J, STEALTH_AXIS_K)
 };
-#define TMC_INIT(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, stealthchop_by_axis[STEALTH_INDEX], chopper_timing_##ST, ST##_INTERPOLATE)
+#define TMC_INIT(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, stealthchop_by_axis[STEALTH_INDEX], chopper_timing_##ST, ST##_INTERPOLATE, ST##_HOLD_MULTIPLIER)
 
 //   IC = TMC model number
 //   ST = Stepper object letter
@@ -200,7 +200,7 @@ enum StealthIndex : uint8_t {
 
 #if HAS_DRIVER(TMC2130)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate) {
+  void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate, float hold_multiplier) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
@@ -212,7 +212,7 @@ enum StealthIndex : uint8_t {
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
-    st.rms_current(mA, HOLD_MULTIPLIER);
+    st.rms_current(mA, hold_multiplier);
     st.microsteps(microsteps);
     st.iholddelay(10);
     st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
@@ -235,7 +235,7 @@ enum StealthIndex : uint8_t {
 
 #if HAS_DRIVER(TMC2160)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate) {
+  void tmc_init(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate, float hold_multiplier) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
@@ -247,7 +247,7 @@ enum StealthIndex : uint8_t {
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
-    st.rms_current(mA, HOLD_MULTIPLIER);
+    st.rms_current(mA, hold_multiplier);
     st.microsteps(microsteps);
     st.iholddelay(10);
     st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
@@ -604,7 +604,7 @@ enum StealthIndex : uint8_t {
 
 #if HAS_DRIVER(TMC2208)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate) {
+  void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate, float hold_multiplier) {
     TMC2208_n::GCONF_t gconf{0};
     gconf.pdn_disable = true; // Use UART
     gconf.mstep_reg_select = true; // Select microsteps with UART
@@ -622,7 +622,7 @@ enum StealthIndex : uint8_t {
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
-    st.rms_current(mA, HOLD_MULTIPLIER);
+    st.rms_current(mA, hold_multiplier);
     st.microsteps(microsteps);
     st.iholddelay(10);
     st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
@@ -646,7 +646,7 @@ enum StealthIndex : uint8_t {
 
 #if HAS_DRIVER(TMC2209)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate) {
+  void tmc_init(TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate, float hold_multiplier) {
     TMC2208_n::GCONF_t gconf{0};
     gconf.pdn_disable = true; // Use UART
     gconf.mstep_reg_select = true; // Select microsteps with UART
@@ -664,7 +664,7 @@ enum StealthIndex : uint8_t {
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
-    st.rms_current(mA, HOLD_MULTIPLIER);
+    st.rms_current(mA, hold_multiplier);
     st.microsteps(microsteps);
     st.iholddelay(10);
     st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
@@ -688,7 +688,7 @@ enum StealthIndex : uint8_t {
 
 #if HAS_DRIVER(TMC2660)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const bool, const chopper_timing_t &chop_init, const bool interpolate) {
+  void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const bool, const chopper_timing_t &chop_init, const bool interpolate, float hold_multiplier) {
     st.begin();
 
     TMC2660_n::CHOPCONF_t chopconf{0};
@@ -710,7 +710,7 @@ enum StealthIndex : uint8_t {
 
 #if HAS_DRIVER(TMC5130)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC5130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate) {
+  void tmc_init(TMCMarlin<TMC5130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate, float hold_multiplier) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
@@ -722,7 +722,7 @@ enum StealthIndex : uint8_t {
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
-    st.rms_current(mA, HOLD_MULTIPLIER);
+    st.rms_current(mA, hold_multiplier);
     st.microsteps(microsteps);
     st.iholddelay(10);
     st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
@@ -745,7 +745,7 @@ enum StealthIndex : uint8_t {
 
 #if HAS_DRIVER(TMC5160)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate) {
+  void tmc_init(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate, float hold_multiplier) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
@@ -757,7 +757,7 @@ enum StealthIndex : uint8_t {
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
-    st.rms_current(mA, HOLD_MULTIPLIER);
+    st.rms_current(mA, hold_multiplier);
     st.microsteps(microsteps);
     st.iholddelay(10);
     st.TPOWERDOWN(128); // ~2s until driver lowers to hold current

commit dc5bef62ba185461ba969db6af996ebc93a33ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 23 10:01:37 2021 -0500

    üé® Various multi-axis patches (#22823)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index fd63027974..e8ecbf1c76 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -164,6 +164,15 @@ enum StealthIndex : uint8_t {
 #ifndef TMC_Z4_BAUD_RATE
   #define TMC_Z4_BAUD_RATE TMC_BAUD_RATE
 #endif
+#ifndef TMC_I_BAUD_RATE
+  #define TMC_I_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_J_BAUD_RATE
+  #define TMC_J_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_K_BAUD_RATE
+  #define TMC_K_BAUD_RATE TMC_BAUD_RATE
+#endif
 #ifndef TMC_E0_BAUD_RATE
   #define TMC_E0_BAUD_RATE TMC_BAUD_RATE
 #endif
@@ -834,12 +843,8 @@ void restore_trinamic_drivers() {
 void reset_trinamic_drivers() {
   static constexpr bool stealthchop_by_axis[] = LOGICAL_AXIS_ARRAY(
     ENABLED(STEALTHCHOP_E),
-    ENABLED(STEALTHCHOP_XY),
-    ENABLED(STEALTHCHOP_XY),
-    ENABLED(STEALTHCHOP_Z),
-    ENABLED(STEALTHCHOP_I),
-    ENABLED(STEALTHCHOP_J),
-    ENABLED(STEALTHCHOP_K)
+    ENABLED(STEALTHCHOP_XY), ENABLED(STEALTHCHOP_XY), ENABLED(STEALTHCHOP_Z),
+    ENABLED(STEALTHCHOP_I), ENABLED(STEALTHCHOP_J), ENABLED(STEALTHCHOP_K)
   );
 
   #if AXIS_IS_TMC(X)

commit afca6e745932d295b88d37fa9bd4274e22705b0b
Author: luzpaz <luzpaz@users.noreply.github.com>
Date:   Tue Aug 3 20:02:34 2021 -0400

    üêõ Spellcheck comments (#22496)
    
    codespell -q 3 --builtin=clear,rare,informal,code -S ./Marlin/src/lcd/language -L alo,amin,endcode,stdio,uint

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index f9ed43acbf..fd63027974 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -955,7 +955,7 @@ void reset_trinamic_drivers() {
 // TMC Slave Address Conflict Detection
 //
 // Conflict detection is performed in the following way. Similar methods are used for
-// hardware and software serial, but the implementations are indepenent.
+// hardware and software serial, but the implementations are independent.
 //
 // 1. Populate a data structure with UART parameters and addresses for all possible axis.
 //      If an axis is not in use, populate it with recognizable placeholder data.

commit 1e33c1a2a78392e9182442db043384b0f96cca20
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Aug 1 14:28:53 2021 -0500

    M256 LCD brightness (#22478)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index a5d7e5ad6b..f9ed43acbf 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -1008,7 +1008,7 @@ void reset_trinamic_drivers() {
     TMC_SW_DETAIL(Y), TMC_SW_DETAIL(Y2),
     TMC_SW_DETAIL(Z), TMC_SW_DETAIL(Z2), TMC_SW_DETAIL(Z3), TMC_SW_DETAIL(Z4),
     TMC_SW_DETAIL(I), TMC_SW_DETAIL(J), TMC_SW_DETAIL(K),
-  	TMC_SW_DETAIL(E0), TMC_SW_DETAIL(E1), TMC_SW_DETAIL(E2), TMC_SW_DETAIL(E3), TMC_SW_DETAIL(E4), TMC_SW_DETAIL(E5), TMC_SW_DETAIL(E6), TMC_SW_DETAIL(E7)
+    TMC_SW_DETAIL(E0), TMC_SW_DETAIL(E1), TMC_SW_DETAIL(E2), TMC_SW_DETAIL(E3), TMC_SW_DETAIL(E4), TMC_SW_DETAIL(E5), TMC_SW_DETAIL(E6), TMC_SW_DETAIL(E7)
   };
 
   constexpr bool sc_sw_done(size_t start, size_t end) { return start == end; }

commit ba4fa4983411d03eae791b70d8ec3e26f0781785
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sun Jun 6 08:30:39 2021 +0200

    ‚úèÔ∏è Followup to Six Linear Axes (#22056)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index dbde6a5a04..a5d7e5ad6b 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -766,11 +766,7 @@ enum StealthIndex : uint8_t {
     pwmconf.pwm_ofs = 36;
     st.PWMCONF(pwmconf.sr);
 
-    #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(hyb_thrs);
-    #else
-      UNUSED(hyb_thrs);
-    #endif
+    TERN(HYBRID_THRESHOLD, st.set_pwm_thrs(hyb_thrs), UNUSED(hyb_thrs));
     st.GSTAT(); // Clear GSTAT
   }
 #endif // TMC5160
@@ -971,11 +967,12 @@ void reset_trinamic_drivers() {
   // Using a fixed-length character array for the port name allows this to be constexpr compatible.
   struct SanityHwSerialDetails { const char port[20]; uint32_t address; };
   #define TMC_HW_DETAIL_ARGS(A) TERN(A##_HAS_HW_SERIAL, STRINGIFY(A##_HARDWARE_SERIAL), ""), TERN0(A##_HAS_HW_SERIAL, A##_SLAVE_ADDRESS)
-  #define TMC_HW_DETAIL(A) {TMC_HW_DETAIL_ARGS(A)}
+  #define TMC_HW_DETAIL(A) { TMC_HW_DETAIL_ARGS(A) }
   constexpr SanityHwSerialDetails sanity_tmc_hw_details[] = {
     TMC_HW_DETAIL(X), TMC_HW_DETAIL(X2),
     TMC_HW_DETAIL(Y), TMC_HW_DETAIL(Y2),
     TMC_HW_DETAIL(Z), TMC_HW_DETAIL(Z2), TMC_HW_DETAIL(Z3), TMC_HW_DETAIL(Z4),
+    TMC_HW_DETAIL(I), TMC_HW_DETAIL(J), TMC_HW_DETAIL(K),
     TMC_HW_DETAIL(E0), TMC_HW_DETAIL(E1), TMC_HW_DETAIL(E2), TMC_HW_DETAIL(E3), TMC_HW_DETAIL(E4), TMC_HW_DETAIL(E5), TMC_HW_DETAIL(E6), TMC_HW_DETAIL(E7)
   };
 
@@ -995,10 +992,11 @@ void reset_trinamic_drivers() {
 
   #define TMC_HWSERIAL_CONFLICT_MSG(A) STRINGIFY(A) "_SLAVE_ADDRESS conflicts with another driver using the same " STRINGIFY(A) "_HARDWARE_SERIAL"
   #define SA_NO_TMC_HW_C(A) static_assert(1 >= count_tmc_hw_serial_matches(TMC_HW_DETAIL_ARGS(A), 0, COUNT(sanity_tmc_hw_details)), TMC_HWSERIAL_CONFLICT_MSG(A));
-  SA_NO_TMC_HW_C(X);SA_NO_TMC_HW_C(X2);
-  SA_NO_TMC_HW_C(Y);SA_NO_TMC_HW_C(Y2);
-  SA_NO_TMC_HW_C(Z);SA_NO_TMC_HW_C(Z2);SA_NO_TMC_HW_C(Z3);SA_NO_TMC_HW_C(Z4);
-  SA_NO_TMC_HW_C(E0);SA_NO_TMC_HW_C(E1);SA_NO_TMC_HW_C(E2);SA_NO_TMC_HW_C(E3);SA_NO_TMC_HW_C(E4);SA_NO_TMC_HW_C(E5);SA_NO_TMC_HW_C(E6);SA_NO_TMC_HW_C(E7);
+  SA_NO_TMC_HW_C(X); SA_NO_TMC_HW_C(X2);
+  SA_NO_TMC_HW_C(Y); SA_NO_TMC_HW_C(Y2);
+  SA_NO_TMC_HW_C(Z); SA_NO_TMC_HW_C(Z2); SA_NO_TMC_HW_C(Z3); SA_NO_TMC_HW_C(Z4);
+  SA_NO_TMC_HW_C(I); SA_NO_TMC_HW_C(J); SA_NO_TMC_HW_C(K);
+  SA_NO_TMC_HW_C(E0); SA_NO_TMC_HW_C(E1); SA_NO_TMC_HW_C(E2); SA_NO_TMC_HW_C(E3); SA_NO_TMC_HW_C(E4); SA_NO_TMC_HW_C(E5); SA_NO_TMC_HW_C(E6); SA_NO_TMC_HW_C(E7);
 #endif
 
 #if ANY_AXIS_HAS(SW_SERIAL)
@@ -1009,7 +1007,8 @@ void reset_trinamic_drivers() {
     TMC_SW_DETAIL(X), TMC_SW_DETAIL(X2),
     TMC_SW_DETAIL(Y), TMC_SW_DETAIL(Y2),
     TMC_SW_DETAIL(Z), TMC_SW_DETAIL(Z2), TMC_SW_DETAIL(Z3), TMC_SW_DETAIL(Z4),
-    TMC_SW_DETAIL(E0), TMC_SW_DETAIL(E1), TMC_SW_DETAIL(E2), TMC_SW_DETAIL(E3), TMC_SW_DETAIL(E4), TMC_SW_DETAIL(E5), TMC_SW_DETAIL(E6), TMC_SW_DETAIL(E7)
+    TMC_SW_DETAIL(I), TMC_SW_DETAIL(J), TMC_SW_DETAIL(K),
+  	TMC_SW_DETAIL(E0), TMC_SW_DETAIL(E1), TMC_SW_DETAIL(E2), TMC_SW_DETAIL(E3), TMC_SW_DETAIL(E4), TMC_SW_DETAIL(E5), TMC_SW_DETAIL(E6), TMC_SW_DETAIL(E7)
   };
 
   constexpr bool sc_sw_done(size_t start, size_t end) { return start == end; }
@@ -1023,10 +1022,11 @@ void reset_trinamic_drivers() {
 
   #define TMC_SWSERIAL_CONFLICT_MSG(A) STRINGIFY(A) "_SLAVE_ADDRESS conflicts with another driver using the same " STRINGIFY(A) "_SERIAL_RX_PIN or " STRINGIFY(A) "_SERIAL_TX_PIN"
   #define SA_NO_TMC_SW_C(A) static_assert(1 >= count_tmc_sw_serial_matches(TMC_SW_DETAIL_ARGS(A), 0, COUNT(sanity_tmc_sw_details)), TMC_SWSERIAL_CONFLICT_MSG(A));
-  SA_NO_TMC_SW_C(X);SA_NO_TMC_SW_C(X2);
-  SA_NO_TMC_SW_C(Y);SA_NO_TMC_SW_C(Y2);
-  SA_NO_TMC_SW_C(Z);SA_NO_TMC_SW_C(Z2);SA_NO_TMC_SW_C(Z3);SA_NO_TMC_SW_C(Z4);
-  SA_NO_TMC_SW_C(E0);SA_NO_TMC_SW_C(E1);SA_NO_TMC_SW_C(E2);SA_NO_TMC_SW_C(E3);SA_NO_TMC_SW_C(E4);SA_NO_TMC_SW_C(E5);SA_NO_TMC_SW_C(E6);SA_NO_TMC_SW_C(E7);
+  SA_NO_TMC_SW_C(X); SA_NO_TMC_SW_C(X2);
+  SA_NO_TMC_SW_C(Y); SA_NO_TMC_SW_C(Y2);
+  SA_NO_TMC_SW_C(Z); SA_NO_TMC_SW_C(Z2); SA_NO_TMC_SW_C(Z3); SA_NO_TMC_SW_C(Z4);
+  SA_NO_TMC_SW_C(I); SA_NO_TMC_SW_C(J); SA_NO_TMC_SW_C(K);
+  SA_NO_TMC_SW_C(E0); SA_NO_TMC_SW_C(E1); SA_NO_TMC_SW_C(E2); SA_NO_TMC_SW_C(E3); SA_NO_TMC_SW_C(E4); SA_NO_TMC_SW_C(E5); SA_NO_TMC_SW_C(E6); SA_NO_TMC_SW_C(E7);
 #endif
 
 #endif // HAS_TRINAMIC_CONFIG

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index dab60e42a2..dbde6a5a04 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -36,7 +36,7 @@
 #include <SPI.h>
 
 enum StealthIndex : uint8_t {
-  LOGICAL_AXIS_LIST(STEALTH_AXIS_E, STEALTH_AXIS_X, STEALTH_AXIS_Y, STEALTH_AXIS_Z)
+  LOGICAL_AXIS_LIST(STEALTH_AXIS_E, STEALTH_AXIS_X, STEALTH_AXIS_Y, STEALTH_AXIS_Z, STEALTH_AXIS_I, STEALTH_AXIS_J, STEALTH_AXIS_K)
 };
 #define TMC_INIT(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, stealthchop_by_axis[STEALTH_INDEX], chopper_timing_##ST, ST##_INTERPOLATE)
 
@@ -97,6 +97,15 @@ enum StealthIndex : uint8_t {
 #if AXIS_HAS_SPI(Z4)
   TMC_SPI_DEFINE(Z4, Z);
 #endif
+#if AXIS_HAS_SPI(I)
+  TMC_SPI_DEFINE(I, I);
+#endif
+#if AXIS_HAS_SPI(J)
+  TMC_SPI_DEFINE(J, J);
+#endif
+#if AXIS_HAS_SPI(K)
+  TMC_SPI_DEFINE(K, K);
+#endif
 #if AXIS_HAS_SPI(E0)
   TMC_SPI_DEFINE_E(0);
 #endif
@@ -329,6 +338,34 @@ enum StealthIndex : uint8_t {
       #define Z4_HAS_SW_SERIAL 1
     #endif
   #endif
+  #if AXIS_HAS_UART(I)
+    #ifdef I_HARDWARE_SERIAL
+      TMC_UART_DEFINE(HW, I, I);
+      #define I_HAS_HW_SERIAL 1
+    #else
+      TMC_UART_DEFINE(SW, I, I);
+      #define I_HAS_SW_SERIAL 1
+    #endif
+  #endif
+  #if AXIS_HAS_UART(J)
+    #ifdef J_HARDWARE_SERIAL
+      TMC_UART_DEFINE(HW, J, J);
+      #define J_HAS_HW_SERIAL 1
+    #else
+      TMC_UART_DEFINE(SW, J, J);
+      #define J_HAS_SW_SERIAL 1
+    #endif
+  #endif
+  #if AXIS_HAS_UART(K)
+    #ifdef K_HARDWARE_SERIAL
+      TMC_UART_DEFINE(HW, K, K);
+      #define K_HAS_HW_SERIAL 1
+    #else
+      TMC_UART_DEFINE(SW, K, K);
+      #define K_HAS_SW_SERIAL 1
+    #endif
+  #endif
+
   #if AXIS_HAS_UART(E0)
     #ifdef E0_HARDWARE_SERIAL
       TMC_UART_DEFINE_E(HW, 0);
@@ -402,7 +439,9 @@ enum StealthIndex : uint8_t {
     #endif
   #endif
 
-  enum TMCAxis : uint8_t { LINEAR_AXIS_LIST(X, Y, Z), X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7, TOTAL };
+  #define _EN_ITEM(N) , E##N
+  enum TMCAxis : uint8_t { LINEAR_AXIS_LIST(X, Y, Z, I, J, K), X2, Y2, Z2, Z3, Z4 REPEAT(EXTRUDERS, _EN_ITEM), TOTAL };
+  #undef _EN_ITEM
 
   void tmc_serial_begin() {
     #if HAS_TMC_HW_SERIAL
@@ -474,6 +513,27 @@ enum StealthIndex : uint8_t {
         stepperZ4.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
+    #if AXIS_HAS_UART(I)
+      #ifdef I_HARDWARE_SERIAL
+        HW_SERIAL_BEGIN(I);
+      #else
+        stepperI.beginSerial(TMC_BAUD_RATE);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(J)
+      #ifdef J_HARDWARE_SERIAL
+        HW_SERIAL_BEGIN(J);
+      #else
+        stepperJ.beginSerial(TMC_BAUD_RATE);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(K)
+      #ifdef K_HARDWARE_SERIAL
+        HW_SERIAL_BEGIN(K);
+      #else
+        stepperK.beginSerial(TMC_BAUD_RATE);
+      #endif
+    #endif
     #if AXIS_HAS_UART(E0)
       #ifdef E0_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(E0);
@@ -740,6 +800,15 @@ void restore_trinamic_drivers() {
   #if AXIS_IS_TMC(Z4)
     stepperZ4.push();
   #endif
+  #if AXIS_IS_TMC(I)
+    stepperI.push();
+  #endif
+  #if AXIS_IS_TMC(J)
+    stepperJ.push();
+  #endif
+  #if AXIS_IS_TMC(K)
+    stepperK.push();
+  #endif
   #if AXIS_IS_TMC(E0)
     stepperE0.push();
   #endif
@@ -771,7 +840,10 @@ void reset_trinamic_drivers() {
     ENABLED(STEALTHCHOP_E),
     ENABLED(STEALTHCHOP_XY),
     ENABLED(STEALTHCHOP_XY),
-    ENABLED(STEALTHCHOP_Z)
+    ENABLED(STEALTHCHOP_Z),
+    ENABLED(STEALTHCHOP_I),
+    ENABLED(STEALTHCHOP_J),
+    ENABLED(STEALTHCHOP_K)
   );
 
   #if AXIS_IS_TMC(X)
@@ -798,6 +870,15 @@ void reset_trinamic_drivers() {
   #if AXIS_IS_TMC(Z4)
     TMC_INIT(Z4, STEALTH_AXIS_Z);
   #endif
+  #if AXIS_IS_TMC(I)
+    TMC_INIT(I, STEALTH_AXIS_I);
+  #endif
+  #if AXIS_IS_TMC(J)
+    TMC_INIT(J, STEALTH_AXIS_J);
+  #endif
+  #if AXIS_IS_TMC(K)
+    TMC_INIT(K, STEALTH_AXIS_K);
+  #endif
   #if AXIS_IS_TMC(E0)
     TMC_INIT(E0, STEALTH_AXIS_E);
   #endif
@@ -848,6 +929,24 @@ void reset_trinamic_drivers() {
         stepperZ4.homing_threshold(CAT(TERN(Z4_SENSORLESS, Z4, Z), _STALL_SENSITIVITY));
       #endif
     #endif
+    #if I_SENSORLESS
+      stepperI.homing_threshold(I_STALL_SENSITIVITY);
+      #if AXIS_HAS_STALLGUARD(I)
+        stepperI.homing_threshold(CAT(TERN(I_SENSORLESS, I, I), _STALL_SENSITIVITY));
+      #endif
+    #endif
+    #if J_SENSORLESS
+      stepperJ.homing_threshold(J_STALL_SENSITIVITY);
+      #if AXIS_HAS_STALLGUARD(J)
+        stepperJ.homing_threshold(CAT(TERN(J_SENSORLESS, J, J), _STALL_SENSITIVITY));
+      #endif
+    #endif
+    #if K_SENSORLESS
+      stepperK.homing_threshold(K_STALL_SENSITIVITY);
+      #if AXIS_HAS_STALLGUARD(K)
+        stepperK.homing_threshold(CAT(TERN(K_SENSORLESS, K, K), _STALL_SENSITIVITY));
+      #endif
+    #endif
   #endif // USE SENSORLESS
 
   #ifdef TMC_ADV

commit 5ceccc95a88b1aa206a6677062d78cbb19a38c93
Author: hannesweisbach <hannesweisbach@users.noreply.github.com>
Date:   Wed Jun 2 06:20:47 2021 +0200

    ‚ú® TMC Driver distinct baudrates (#22008)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 5acc860787..dab60e42a2 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -131,6 +131,55 @@ enum StealthIndex : uint8_t {
   #define TMC_BAUD_RATE TERN(HAS_TMC_SW_SERIAL, 57600, 115200)
 #endif
 
+#ifndef TMC_X_BAUD_RATE
+  #define TMC_X_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_X2_BAUD_RATE
+  #define TMC_X2_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_Y_BAUD_RATE
+  #define TMC_Y_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_Y2_BAUD_RATE
+  #define TMC_Y2_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_Z_BAUD_RATE
+  #define TMC_Z_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_Z2_BAUD_RATE
+  #define TMC_Z2_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_Z3_BAUD_RATE
+  #define TMC_Z3_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_Z4_BAUD_RATE
+  #define TMC_Z4_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_E0_BAUD_RATE
+  #define TMC_E0_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_E1_BAUD_RATE
+  #define TMC_E1_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_E2_BAUD_RATE
+  #define TMC_E2_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_E3_BAUD_RATE
+  #define TMC_E3_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_E4_BAUD_RATE
+  #define TMC_E4_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_E5_BAUD_RATE
+  #define TMC_E5_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_E6_BAUD_RATE
+  #define TMC_E6_BAUD_RATE TMC_BAUD_RATE
+#endif
+#ifndef TMC_E7_BAUD_RATE
+  #define TMC_E7_BAUD_RATE TMC_BAUD_RATE
+#endif
+
 #if HAS_DRIVER(TMC2130)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
   void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate) {
@@ -366,7 +415,7 @@ enum StealthIndex : uint8_t {
       } sp_helper;
 
       #define HW_SERIAL_BEGIN(A) do{ if (!sp_helper.began(TMCAxis::A, &A##_HARDWARE_SERIAL)) \
-                                          A##_HARDWARE_SERIAL.begin(TMC_BAUD_RATE); }while(0)
+                                          A##_HARDWARE_SERIAL.begin(TMC_##A##_BAUD_RATE); }while(0)
     #endif
 
     #if AXIS_HAS_UART(X)

commit dd4990252e891cdfe56cb7d6e3bbe1e6289be649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 24 16:38:57 2021 -0500

    ‚ôªÔ∏è Refactor Linear / Logical / Distinct Axes (#21953)
    
    * More patches supporting EXTRUDERS 0
    * Extend types in prep for more axes

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 8c943048ba..5acc860787 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -35,7 +35,9 @@
 #include <HardwareSerial.h>
 #include <SPI.h>
 
-enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
+enum StealthIndex : uint8_t {
+  LOGICAL_AXIS_LIST(STEALTH_AXIS_E, STEALTH_AXIS_X, STEALTH_AXIS_Y, STEALTH_AXIS_Z)
+};
 #define TMC_INIT(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, stealthchop_by_axis[STEALTH_INDEX], chopper_timing_##ST, ST##_INTERPOLATE)
 
 //   IC = TMC model number
@@ -351,7 +353,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     #endif
   #endif
 
-  enum TMCAxis : uint8_t { X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7, TOTAL };
+  enum TMCAxis : uint8_t { LINEAR_AXIS_LIST(X, Y, Z), X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7, TOTAL };
 
   void tmc_serial_begin() {
     #if HAS_TMC_HW_SERIAL
@@ -716,19 +718,24 @@ void restore_trinamic_drivers() {
 }
 
 void reset_trinamic_drivers() {
-  static constexpr bool stealthchop_by_axis[] = { ENABLED(STEALTHCHOP_XY), ENABLED(STEALTHCHOP_Z), ENABLED(STEALTHCHOP_E) };
+  static constexpr bool stealthchop_by_axis[] = LOGICAL_AXIS_ARRAY(
+    ENABLED(STEALTHCHOP_E),
+    ENABLED(STEALTHCHOP_XY),
+    ENABLED(STEALTHCHOP_XY),
+    ENABLED(STEALTHCHOP_Z)
+  );
 
   #if AXIS_IS_TMC(X)
-    TMC_INIT(X, STEALTH_AXIS_XY);
+    TMC_INIT(X, STEALTH_AXIS_X);
   #endif
   #if AXIS_IS_TMC(X2)
-    TMC_INIT(X2, STEALTH_AXIS_XY);
+    TMC_INIT(X2, STEALTH_AXIS_X);
   #endif
   #if AXIS_IS_TMC(Y)
-    TMC_INIT(Y, STEALTH_AXIS_XY);
+    TMC_INIT(Y, STEALTH_AXIS_Y);
   #endif
   #if AXIS_IS_TMC(Y2)
-    TMC_INIT(Y2, STEALTH_AXIS_XY);
+    TMC_INIT(Y2, STEALTH_AXIS_Y);
   #endif
   #if AXIS_IS_TMC(Z)
     TMC_INIT(Z, STEALTH_AXIS_Z);
@@ -792,7 +799,7 @@ void reset_trinamic_drivers() {
         stepperZ4.homing_threshold(CAT(TERN(Z4_SENSORLESS, Z4, Z), _STALL_SENSITIVITY));
       #endif
     #endif
-  #endif
+  #endif // USE SENSORLESS
 
   #ifdef TMC_ADV
     TMC_ADV()

commit abbe3f0dc7aa23bae4aa26f6d6b09a4a0665a1a0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:46:59 2021 -0500

    üé® Misc cleanup and fixes

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index de3d45e4b6..8c943048ba 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -62,7 +62,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 #define _TMC_UART_DEFINE(SWHW, IC, ST, AI) TMC_UART_##SWHW##_DEFINE(IC, ST, TMC_##ST##_LABEL, AI)
 #define TMC_UART_DEFINE(SWHW, ST, AI) _TMC_UART_DEFINE(SWHW, ST##_DRIVER_TYPE, ST, AI##_AXIS)
 
-#if DISTINCT_E > 1
+#if ENABLED(DISTINCT_E_FACTORS)
   #define TMC_SPI_DEFINE_E(AI) TMC_SPI_DEFINE(E##AI, E##AI)
   #define TMC_UART_DEFINE_E(SWHW, AI) TMC_UART_DEFINE(SWHW, E##AI, E##AI)
 #else

commit bca4652c5e48415cf478da229a253a2106da3e59
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 17 02:03:16 2021 -0500

    Leave Hybrid Threshold as-is for now
    
    Reverting 253ee0c407

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 561e947190..de3d45e4b6 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -158,7 +158,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ampl = 180;
     st.PWMCONF(pwmconf.sr);
 
-    st.set_pwm_thrs(TERN0(HYBRID_THRESHOLD, hyb_thrs)); UNUSED(hyb_thrs);
+    TERN(HYBRID_THRESHOLD, st.set_pwm_thrs(hyb_thrs), UNUSED(hyb_thrs));
 
     st.GSTAT(); // Clear GSTAT
   }
@@ -196,7 +196,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ofs = 36;
     st.PWMCONF(pwmconf.sr);
 
-    st.set_pwm_thrs(TERN0(HYBRID_THRESHOLD, hyb_thrs)); UNUSED(hyb_thrs);
+    TERN(HYBRID_THRESHOLD, st.set_pwm_thrs(hyb_thrs), UNUSED(hyb_thrs));
 
     st.GSTAT(); // Clear GSTAT
   }
@@ -517,7 +517,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ofs = 36;
     st.PWMCONF(pwmconf.sr);
 
-    st.set_pwm_thrs(TERN0(HYBRID_THRESHOLD, hyb_thrs)); UNUSED(hyb_thrs);
+    TERN(HYBRID_THRESHOLD, st.set_pwm_thrs(hyb_thrs), UNUSED(hyb_thrs));
 
     st.GSTAT(0b111); // Clear
     delay(200);
@@ -559,7 +559,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ofs = 36;
     st.PWMCONF(pwmconf.sr);
 
-    st.set_pwm_thrs(TERN0(HYBRID_THRESHOLD, hyb_thrs)); UNUSED(hyb_thrs);
+    TERN(HYBRID_THRESHOLD, st.set_pwm_thrs(hyb_thrs), UNUSED(hyb_thrs));
 
     st.GSTAT(0b111); // Clear
     delay(200);
@@ -617,7 +617,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ampl = 180;
     st.PWMCONF(pwmconf.sr);
 
-    st.set_pwm_thrs(TERN0(HYBRID_THRESHOLD, hyb_thrs)); UNUSED(hyb_thrs);
+    TERN(HYBRID_THRESHOLD, st.set_pwm_thrs(hyb_thrs), UNUSED(hyb_thrs));
 
     st.GSTAT(); // Clear GSTAT
   }
@@ -655,8 +655,11 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ofs = 36;
     st.PWMCONF(pwmconf.sr);
 
-    st.set_pwm_thrs(TERN0(HYBRID_THRESHOLD, hyb_thrs)); UNUSED(hyb_thrs);
-
+    #if ENABLED(HYBRID_THRESHOLD)
+      st.set_pwm_thrs(hyb_thrs);
+    #else
+      UNUSED(hyb_thrs);
+    #endif
     st.GSTAT(); // Clear GSTAT
   }
 #endif // TMC5160

commit 253ee0c407120526b821c0f3251bda0afb69d934
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 16 04:04:07 2021 -0500

    Init pwm_thrs to 0 when HYBRID_THRESHOLD is off (#21623)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index de3d45e4b6..561e947190 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -158,7 +158,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ampl = 180;
     st.PWMCONF(pwmconf.sr);
 
-    TERN(HYBRID_THRESHOLD, st.set_pwm_thrs(hyb_thrs), UNUSED(hyb_thrs));
+    st.set_pwm_thrs(TERN0(HYBRID_THRESHOLD, hyb_thrs)); UNUSED(hyb_thrs);
 
     st.GSTAT(); // Clear GSTAT
   }
@@ -196,7 +196,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ofs = 36;
     st.PWMCONF(pwmconf.sr);
 
-    TERN(HYBRID_THRESHOLD, st.set_pwm_thrs(hyb_thrs), UNUSED(hyb_thrs));
+    st.set_pwm_thrs(TERN0(HYBRID_THRESHOLD, hyb_thrs)); UNUSED(hyb_thrs);
 
     st.GSTAT(); // Clear GSTAT
   }
@@ -517,7 +517,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ofs = 36;
     st.PWMCONF(pwmconf.sr);
 
-    TERN(HYBRID_THRESHOLD, st.set_pwm_thrs(hyb_thrs), UNUSED(hyb_thrs));
+    st.set_pwm_thrs(TERN0(HYBRID_THRESHOLD, hyb_thrs)); UNUSED(hyb_thrs);
 
     st.GSTAT(0b111); // Clear
     delay(200);
@@ -559,7 +559,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ofs = 36;
     st.PWMCONF(pwmconf.sr);
 
-    TERN(HYBRID_THRESHOLD, st.set_pwm_thrs(hyb_thrs), UNUSED(hyb_thrs));
+    st.set_pwm_thrs(TERN0(HYBRID_THRESHOLD, hyb_thrs)); UNUSED(hyb_thrs);
 
     st.GSTAT(0b111); // Clear
     delay(200);
@@ -617,7 +617,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ampl = 180;
     st.PWMCONF(pwmconf.sr);
 
-    TERN(HYBRID_THRESHOLD, st.set_pwm_thrs(hyb_thrs), UNUSED(hyb_thrs));
+    st.set_pwm_thrs(TERN0(HYBRID_THRESHOLD, hyb_thrs)); UNUSED(hyb_thrs);
 
     st.GSTAT(); // Clear GSTAT
   }
@@ -655,11 +655,8 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ofs = 36;
     st.PWMCONF(pwmconf.sr);
 
-    #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(hyb_thrs);
-    #else
-      UNUSED(hyb_thrs);
-    #endif
+    st.set_pwm_thrs(TERN0(HYBRID_THRESHOLD, hyb_thrs)); UNUSED(hyb_thrs);
+
     st.GSTAT(); // Clear GSTAT
   }
 #endif // TMC5160

commit 3b73b115ca9366f0155986b717d4c85c31ed2f80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 29 20:36:37 2021 -0500

    Apply pointer formatting

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index c33581d132..de3d45e4b6 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -830,11 +830,11 @@ void reset_trinamic_drivers() {
   }
 
   constexpr bool sc_hw_done(size_t start, size_t end) { return start == end; }
-  constexpr bool sc_hw_skip(const char* port_name) { return !(*port_name); }
-  constexpr bool sc_hw_match(const char* port_name, uint32_t address, size_t start, size_t end) {
+  constexpr bool sc_hw_skip(const char *port_name) { return !(*port_name); }
+  constexpr bool sc_hw_match(const char *port_name, uint32_t address, size_t start, size_t end) {
     return !sc_hw_done(start, end) && !sc_hw_skip(port_name) && (address == sanity_tmc_hw_details[start].address && str_eq_ce(port_name, sanity_tmc_hw_details[start].port));
   }
-  constexpr int count_tmc_hw_serial_matches(const char* port_name, uint32_t address, size_t start, size_t end) {
+  constexpr int count_tmc_hw_serial_matches(const char *port_name, uint32_t address, size_t start, size_t end) {
     return sc_hw_done(start, end) ? 0 : ((sc_hw_skip(port_name) ? 0 : (sc_hw_match(port_name, address, start, end) ? 1 : 0)) + count_tmc_hw_serial_matches(port_name, address, start + 1, end));
   }
 

commit 4fccb92e072463bd6147b2ce22352b79337cb53c
Author: ManuelMcLure <manuel@mclure.org>
Date:   Thu Oct 22 04:27:33 2020 -0700

    Configure TMC interpolation per driver (#19828)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index ad11046f62..c33581d132 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -36,7 +36,7 @@
 #include <SPI.h>
 
 enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
-#define TMC_INIT(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, stealthchop_by_axis[STEALTH_INDEX], chopper_timing_##ST)
+#define TMC_INIT(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, stealthchop_by_axis[STEALTH_INDEX], chopper_timing_##ST, ST##_INTERPOLATE)
 
 //   IC = TMC model number
 //   ST = Stepper object letter
@@ -131,13 +131,13 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2130)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init) {
+  void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
     chopconf.tbl = 0b01;
     chopconf.toff = chop_init.toff;
-    chopconf.intpol = INTERPOLATE;
+    chopconf.intpol = interpolate;
     chopconf.hend = chop_init.hend + 3;
     chopconf.hstrt = chop_init.hstrt - 1;
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
@@ -166,13 +166,13 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2160)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init) {
+  void tmc_init(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
     chopconf.tbl = 0b01;
     chopconf.toff = chop_init.toff;
-    chopconf.intpol = INTERPOLATE;
+    chopconf.intpol = interpolate;
     chopconf.hend = chop_init.hend + 3;
     chopconf.hstrt = chop_init.hstrt - 1;
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
@@ -484,7 +484,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2208)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init) {
+  void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate) {
     TMC2208_n::GCONF_t gconf{0};
     gconf.pdn_disable = true; // Use UART
     gconf.mstep_reg_select = true; // Select microsteps with UART
@@ -496,7 +496,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     TMC2208_n::CHOPCONF_t chopconf{0};
     chopconf.tbl = 0b01; // blank_time = 24
     chopconf.toff = chop_init.toff;
-    chopconf.intpol = INTERPOLATE;
+    chopconf.intpol = interpolate;
     chopconf.hend = chop_init.hend + 3;
     chopconf.hstrt = chop_init.hstrt - 1;
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
@@ -526,7 +526,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2209)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init) {
+  void tmc_init(TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate) {
     TMC2208_n::GCONF_t gconf{0};
     gconf.pdn_disable = true; // Use UART
     gconf.mstep_reg_select = true; // Select microsteps with UART
@@ -538,7 +538,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     TMC2208_n::CHOPCONF_t chopconf{0};
     chopconf.tbl = 0b01; // blank_time = 24
     chopconf.toff = chop_init.toff;
-    chopconf.intpol = INTERPOLATE;
+    chopconf.intpol = interpolate;
     chopconf.hend = chop_init.hend + 3;
     chopconf.hstrt = chop_init.hstrt - 1;
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
@@ -568,7 +568,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2660)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const bool, const chopper_timing_t &chop_init) {
+  void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const bool, const chopper_timing_t &chop_init, const bool interpolate) {
     st.begin();
 
     TMC2660_n::CHOPCONF_t chopconf{0};
@@ -582,7 +582,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     st.rms_current(mA);
     st.microsteps(microsteps);
     TERN_(SQUARE_WAVE_STEPPING, st.dedge(true));
-    st.intpol(INTERPOLATE);
+    st.intpol(interpolate);
     st.diss2g(true); // Disable short to ground protection. Too many false readings?
     TERN_(TMC_DEBUG, st.rdsel(0b01));
   }
@@ -590,13 +590,13 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC5130)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC5130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init) {
+  void tmc_init(TMCMarlin<TMC5130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
     chopconf.tbl = 0b01;
     chopconf.toff = chop_init.toff;
-    chopconf.intpol = INTERPOLATE;
+    chopconf.intpol = interpolate;
     chopconf.hend = chop_init.hend + 3;
     chopconf.hstrt = chop_init.hstrt - 1;
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
@@ -625,13 +625,13 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC5160)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init) {
+  void tmc_init(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init, const bool interpolate) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
     chopconf.tbl = 0b01;
     chopconf.toff = chop_init.toff;
-    chopconf.intpol = INTERPOLATE;
+    chopconf.intpol = interpolate;
     chopconf.hend = chop_init.hend + 3;
     chopconf.hstrt = chop_init.hstrt - 1;
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);

commit c2802d35bb1bcfc20785b0ccf255697b9c08c775
Author: Jago Strong-Wright <jagoosw@protonmail.com>
Date:   Sun Oct 18 04:35:19 2020 +0100

    Distinct Chopper Timing settings (#19781)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index d5a861d71b..ad11046f62 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -36,7 +36,7 @@
 #include <SPI.h>
 
 enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
-#define TMC_INIT(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, stealthchop_by_axis[STEALTH_INDEX])
+#define TMC_INIT(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, stealthchop_by_axis[STEALTH_INDEX], chopper_timing_##ST)
 
 //   IC = TMC model number
 //   ST = Stepper object letter
@@ -131,15 +131,15 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2130)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth) {
+  void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
-    chopconf.tbl = 1;
-    chopconf.toff = chopper_timing.toff;
+    chopconf.tbl = 0b01;
+    chopconf.toff = chop_init.toff;
     chopconf.intpol = INTERPOLATE;
-    chopconf.hend = chopper_timing.hend + 3;
-    chopconf.hstrt = chopper_timing.hstrt - 1;
+    chopconf.hend = chop_init.hend + 3;
+    chopconf.hstrt = chop_init.hstrt - 1;
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
@@ -166,15 +166,15 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2160)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth) {
+  void tmc_init(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
-    chopconf.tbl = 1;
-    chopconf.toff = chopper_timing.toff;
+    chopconf.tbl = 0b01;
+    chopconf.toff = chop_init.toff;
     chopconf.intpol = INTERPOLATE;
-    chopconf.hend = chopper_timing.hend + 3;
-    chopconf.hstrt = chopper_timing.hstrt - 1;
+    chopconf.hend = chop_init.hend + 3;
+    chopconf.hstrt = chop_init.hstrt - 1;
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
@@ -484,7 +484,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2208)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth) {
+  void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init) {
     TMC2208_n::GCONF_t gconf{0};
     gconf.pdn_disable = true; // Use UART
     gconf.mstep_reg_select = true; // Select microsteps with UART
@@ -495,10 +495,10 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
     TMC2208_n::CHOPCONF_t chopconf{0};
     chopconf.tbl = 0b01; // blank_time = 24
-    chopconf.toff = chopper_timing.toff;
+    chopconf.toff = chop_init.toff;
     chopconf.intpol = INTERPOLATE;
-    chopconf.hend = chopper_timing.hend + 3;
-    chopconf.hstrt = chopper_timing.hstrt - 1;
+    chopconf.hend = chop_init.hend + 3;
+    chopconf.hstrt = chop_init.hstrt - 1;
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
@@ -526,7 +526,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2209)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth) {
+  void tmc_init(TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init) {
     TMC2208_n::GCONF_t gconf{0};
     gconf.pdn_disable = true; // Use UART
     gconf.mstep_reg_select = true; // Select microsteps with UART
@@ -537,10 +537,10 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
     TMC2208_n::CHOPCONF_t chopconf{0};
     chopconf.tbl = 0b01; // blank_time = 24
-    chopconf.toff = chopper_timing.toff;
+    chopconf.toff = chop_init.toff;
     chopconf.intpol = INTERPOLATE;
-    chopconf.hend = chopper_timing.hend + 3;
-    chopconf.hstrt = chopper_timing.hstrt - 1;
+    chopconf.hend = chop_init.hend + 3;
+    chopconf.hstrt = chop_init.hstrt - 1;
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
@@ -568,14 +568,14 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2660)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const bool) {
+  void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const bool, const chopper_timing_t &chop_init) {
     st.begin();
 
     TMC2660_n::CHOPCONF_t chopconf{0};
-    chopconf.tbl = 1;
-    chopconf.toff = chopper_timing.toff;
-    chopconf.hend = chopper_timing.hend + 3;
-    chopconf.hstrt = chopper_timing.hstrt - 1;
+    chopconf.tbl = 0b01;
+    chopconf.toff = chop_init.toff;
+    chopconf.hend = chop_init.hend + 3;
+    chopconf.hstrt = chop_init.hstrt - 1;
     st.CHOPCONF(chopconf.sr);
 
     st.sdoff(0);
@@ -590,15 +590,15 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC5130)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC5130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth) {
+  void tmc_init(TMCMarlin<TMC5130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
-    chopconf.tbl = 1;
-    chopconf.toff = chopper_timing.toff;
+    chopconf.tbl = 0b01;
+    chopconf.toff = chop_init.toff;
     chopconf.intpol = INTERPOLATE;
-    chopconf.hend = chopper_timing.hend + 3;
-    chopconf.hstrt = chopper_timing.hstrt - 1;
+    chopconf.hend = chop_init.hend + 3;
+    chopconf.hstrt = chop_init.hstrt - 1;
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
@@ -625,15 +625,15 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC5160)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth) {
+  void tmc_init(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth, const chopper_timing_t &chop_init) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
-    chopconf.tbl = 1;
-    chopconf.toff = chopper_timing.toff;
+    chopconf.tbl = 0b01;
+    chopconf.toff = chop_init.toff;
     chopconf.intpol = INTERPOLATE;
-    chopconf.hend = chopper_timing.hend + 3;
-    chopconf.hstrt = chopper_timing.hstrt - 1;
+    chopconf.hend = chop_init.hend + 3;
+    chopconf.hstrt = chop_init.hstrt - 1;
     TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 

commit ecc80138123751945b6470d4cd95b13f00456a90
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Sep 23 17:40:00 2020 -0500

    Whitespace cleanup

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index a4b1b240f7..d5a861d71b 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -802,10 +802,10 @@ void reset_trinamic_drivers() {
 }
 
 // TMC Slave Address Conflict Detection
-// 
+//
 // Conflict detection is performed in the following way. Similar methods are used for
 // hardware and software serial, but the implementations are indepenent.
-// 
+//
 // 1. Populate a data structure with UART parameters and addresses for all possible axis.
 //      If an axis is not in use, populate it with recognizable placeholder data.
 // 2. For each axis in use, static_assert using a constexpr function, which counts the
@@ -815,7 +815,7 @@ void reset_trinamic_drivers() {
   // Hardware serial names are compared as strings, since actually resolving them cannot occur in a constexpr.
   // Using a fixed-length character array for the port name allows this to be constexpr compatible.
   struct SanityHwSerialDetails { const char port[20]; uint32_t address; };
-  #define TMC_HW_DETAIL_ARGS(A) TERN(A##_HAS_HW_SERIAL, STRINGIFY(A##_HARDWARE_SERIAL), ""), TERN0(A##_HAS_HW_SERIAL, A##_SLAVE_ADDRESS)  
+  #define TMC_HW_DETAIL_ARGS(A) TERN(A##_HAS_HW_SERIAL, STRINGIFY(A##_HARDWARE_SERIAL), ""), TERN0(A##_HAS_HW_SERIAL, A##_SLAVE_ADDRESS)
   #define TMC_HW_DETAIL(A) {TMC_HW_DETAIL_ARGS(A)}
   constexpr SanityHwSerialDetails sanity_tmc_hw_details[] = {
     TMC_HW_DETAIL(X), TMC_HW_DETAIL(X2),

commit 5d0429ee2a5b802d1000a406f9c02850403472af
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Sep 22 18:36:31 2020 -0700

    Catch a TMC address conflict early (#19458)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 3dda98698b..a4b1b240f7 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -209,113 +209,145 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
   #if AXIS_HAS_UART(X)
     #ifdef X_HARDWARE_SERIAL
       TMC_UART_DEFINE(HW, X, X);
+      #define X_HAS_HW_SERIAL 1
     #else
       TMC_UART_DEFINE(SW, X, X);
+      #define X_HAS_SW_SERIAL 1
     #endif
   #endif
   #if AXIS_HAS_UART(X2)
     #ifdef X2_HARDWARE_SERIAL
       TMC_UART_DEFINE(HW, X2, X);
+      #define X2_HAS_HW_SERIAL 1
     #else
       TMC_UART_DEFINE(SW, X2, X);
+      #define X2_HAS_SW_SERIAL 1
     #endif
   #endif
   #if AXIS_HAS_UART(Y)
     #ifdef Y_HARDWARE_SERIAL
       TMC_UART_DEFINE(HW, Y, Y);
+      #define Y_HAS_HW_SERIAL 1
     #else
       TMC_UART_DEFINE(SW, Y, Y);
+      #define Y_HAS_SW_SERIAL 1
     #endif
   #endif
   #if AXIS_HAS_UART(Y2)
     #ifdef Y2_HARDWARE_SERIAL
       TMC_UART_DEFINE(HW, Y2, Y);
+      #define Y2_HAS_HW_SERIAL 1
     #else
       TMC_UART_DEFINE(SW, Y2, Y);
+      #define Y2_HAS_SW_SERIAL 1
     #endif
   #endif
   #if AXIS_HAS_UART(Z)
     #ifdef Z_HARDWARE_SERIAL
       TMC_UART_DEFINE(HW, Z, Z);
+      #define Z_HAS_HW_SERIAL 1
     #else
       TMC_UART_DEFINE(SW, Z, Z);
+      #define Z_HAS_SW_SERIAL 1
     #endif
   #endif
   #if AXIS_HAS_UART(Z2)
     #ifdef Z2_HARDWARE_SERIAL
       TMC_UART_DEFINE(HW, Z2, Z);
+      #define Z2_HAS_HW_SERIAL 1
     #else
       TMC_UART_DEFINE(SW, Z2, Z);
+      #define Z2_HAS_SW_SERIAL 1
     #endif
   #endif
   #if AXIS_HAS_UART(Z3)
     #ifdef Z3_HARDWARE_SERIAL
       TMC_UART_DEFINE(HW, Z3, Z);
+      #define Z3_HAS_HW_SERIAL 1
     #else
       TMC_UART_DEFINE(SW, Z3, Z);
+      #define Z3_HAS_SW_SERIAL 1
     #endif
   #endif
   #if AXIS_HAS_UART(Z4)
     #ifdef Z4_HARDWARE_SERIAL
       TMC_UART_DEFINE(HW, Z4, Z);
+      #define Z4_HAS_HW_SERIAL 1
     #else
       TMC_UART_DEFINE(SW, Z4, Z);
+      #define Z4_HAS_SW_SERIAL 1
     #endif
   #endif
   #if AXIS_HAS_UART(E0)
     #ifdef E0_HARDWARE_SERIAL
       TMC_UART_DEFINE_E(HW, 0);
+      #define E0_HAS_HW_SERIAL 1
     #else
       TMC_UART_DEFINE_E(SW, 0);
+      #define E0_HAS_SW_SERIAL 1
     #endif
   #endif
   #if AXIS_HAS_UART(E1)
     #ifdef E1_HARDWARE_SERIAL
       TMC_UART_DEFINE_E(HW, 1);
+      #define E1_HAS_HW_SERIAL 1
     #else
       TMC_UART_DEFINE_E(SW, 1);
+      #define E1_HAS_SW_SERIAL 1
     #endif
   #endif
   #if AXIS_HAS_UART(E2)
     #ifdef E2_HARDWARE_SERIAL
       TMC_UART_DEFINE_E(HW, 2);
+      #define E2_HAS_HW_SERIAL 1
     #else
       TMC_UART_DEFINE_E(SW, 2);
+      #define E2_HAS_SW_SERIAL 1
     #endif
   #endif
   #if AXIS_HAS_UART(E3)
     #ifdef E3_HARDWARE_SERIAL
       TMC_UART_DEFINE_E(HW, 3);
+      #define E3_HAS_HW_SERIAL 1
     #else
       TMC_UART_DEFINE_E(SW, 3);
+      #define E3_HAS_SW_SERIAL 1
     #endif
   #endif
   #if AXIS_HAS_UART(E4)
     #ifdef E4_HARDWARE_SERIAL
       TMC_UART_DEFINE_E(HW, 4);
+      #define E4_HAS_HW_SERIAL 1
     #else
       TMC_UART_DEFINE_E(SW, 4);
+      #define E4_HAS_SW_SERIAL 1
     #endif
   #endif
   #if AXIS_HAS_UART(E5)
     #ifdef E5_HARDWARE_SERIAL
       TMC_UART_DEFINE_E(HW, 5);
+      #define E5_HAS_HW_SERIAL 1
     #else
       TMC_UART_DEFINE_E(SW, 5);
+      #define E5_HAS_SW_SERIAL 1
     #endif
   #endif
   #if AXIS_HAS_UART(E6)
     #ifdef E6_HARDWARE_SERIAL
       TMC_UART_DEFINE_E(HW, 6);
+      #define E6_HAS_HW_SERIAL 1
     #else
       TMC_UART_DEFINE_E(SW, 6);
+      #define E6_HAS_SW_SERIAL 1
     #endif
   #endif
   #if AXIS_HAS_UART(E7)
     #ifdef E7_HARDWARE_SERIAL
       TMC_UART_DEFINE_E(HW, 7);
+      #define E7_HAS_HW_SERIAL 1
     #else
       TMC_UART_DEFINE_E(SW, 7);
+      #define E7_HAS_SW_SERIAL 1
     #endif
   #endif
 
@@ -769,4 +801,77 @@ void reset_trinamic_drivers() {
   stepper.set_directions();
 }
 
+// TMC Slave Address Conflict Detection
+// 
+// Conflict detection is performed in the following way. Similar methods are used for
+// hardware and software serial, but the implementations are indepenent.
+// 
+// 1. Populate a data structure with UART parameters and addresses for all possible axis.
+//      If an axis is not in use, populate it with recognizable placeholder data.
+// 2. For each axis in use, static_assert using a constexpr function, which counts the
+//      number of matching/conflicting axis. If the value is not exactly 1, fail.
+
+#if ANY_AXIS_HAS(HW_SERIAL)
+  // Hardware serial names are compared as strings, since actually resolving them cannot occur in a constexpr.
+  // Using a fixed-length character array for the port name allows this to be constexpr compatible.
+  struct SanityHwSerialDetails { const char port[20]; uint32_t address; };
+  #define TMC_HW_DETAIL_ARGS(A) TERN(A##_HAS_HW_SERIAL, STRINGIFY(A##_HARDWARE_SERIAL), ""), TERN0(A##_HAS_HW_SERIAL, A##_SLAVE_ADDRESS)  
+  #define TMC_HW_DETAIL(A) {TMC_HW_DETAIL_ARGS(A)}
+  constexpr SanityHwSerialDetails sanity_tmc_hw_details[] = {
+    TMC_HW_DETAIL(X), TMC_HW_DETAIL(X2),
+    TMC_HW_DETAIL(Y), TMC_HW_DETAIL(Y2),
+    TMC_HW_DETAIL(Z), TMC_HW_DETAIL(Z2), TMC_HW_DETAIL(Z3), TMC_HW_DETAIL(Z4),
+    TMC_HW_DETAIL(E0), TMC_HW_DETAIL(E1), TMC_HW_DETAIL(E2), TMC_HW_DETAIL(E3), TMC_HW_DETAIL(E4), TMC_HW_DETAIL(E5), TMC_HW_DETAIL(E6), TMC_HW_DETAIL(E7)
+  };
+
+  // constexpr compatible string comparison
+  constexpr bool str_eq_ce(const char * a, const char * b) {
+    return *a == *b && (*a == '\0' || str_eq_ce(a+1,b+1));
+  }
+
+  constexpr bool sc_hw_done(size_t start, size_t end) { return start == end; }
+  constexpr bool sc_hw_skip(const char* port_name) { return !(*port_name); }
+  constexpr bool sc_hw_match(const char* port_name, uint32_t address, size_t start, size_t end) {
+    return !sc_hw_done(start, end) && !sc_hw_skip(port_name) && (address == sanity_tmc_hw_details[start].address && str_eq_ce(port_name, sanity_tmc_hw_details[start].port));
+  }
+  constexpr int count_tmc_hw_serial_matches(const char* port_name, uint32_t address, size_t start, size_t end) {
+    return sc_hw_done(start, end) ? 0 : ((sc_hw_skip(port_name) ? 0 : (sc_hw_match(port_name, address, start, end) ? 1 : 0)) + count_tmc_hw_serial_matches(port_name, address, start + 1, end));
+  }
+
+  #define TMC_HWSERIAL_CONFLICT_MSG(A) STRINGIFY(A) "_SLAVE_ADDRESS conflicts with another driver using the same " STRINGIFY(A) "_HARDWARE_SERIAL"
+  #define SA_NO_TMC_HW_C(A) static_assert(1 >= count_tmc_hw_serial_matches(TMC_HW_DETAIL_ARGS(A), 0, COUNT(sanity_tmc_hw_details)), TMC_HWSERIAL_CONFLICT_MSG(A));
+  SA_NO_TMC_HW_C(X);SA_NO_TMC_HW_C(X2);
+  SA_NO_TMC_HW_C(Y);SA_NO_TMC_HW_C(Y2);
+  SA_NO_TMC_HW_C(Z);SA_NO_TMC_HW_C(Z2);SA_NO_TMC_HW_C(Z3);SA_NO_TMC_HW_C(Z4);
+  SA_NO_TMC_HW_C(E0);SA_NO_TMC_HW_C(E1);SA_NO_TMC_HW_C(E2);SA_NO_TMC_HW_C(E3);SA_NO_TMC_HW_C(E4);SA_NO_TMC_HW_C(E5);SA_NO_TMC_HW_C(E6);SA_NO_TMC_HW_C(E7);
+#endif
+
+#if ANY_AXIS_HAS(SW_SERIAL)
+  struct SanitySwSerialDetails { int32_t txpin; int32_t rxpin; uint32_t address; };
+  #define TMC_SW_DETAIL_ARGS(A) TERN(A##_HAS_SW_SERIAL, A##_SERIAL_TX_PIN, -1), TERN(A##_HAS_SW_SERIAL, A##_SERIAL_RX_PIN, -1), TERN0(A##_HAS_SW_SERIAL, A##_SLAVE_ADDRESS)
+  #define TMC_SW_DETAIL(A) TMC_SW_DETAIL_ARGS(A)
+  constexpr SanitySwSerialDetails sanity_tmc_sw_details[] = {
+    TMC_SW_DETAIL(X), TMC_SW_DETAIL(X2),
+    TMC_SW_DETAIL(Y), TMC_SW_DETAIL(Y2),
+    TMC_SW_DETAIL(Z), TMC_SW_DETAIL(Z2), TMC_SW_DETAIL(Z3), TMC_SW_DETAIL(Z4),
+    TMC_SW_DETAIL(E0), TMC_SW_DETAIL(E1), TMC_SW_DETAIL(E2), TMC_SW_DETAIL(E3), TMC_SW_DETAIL(E4), TMC_SW_DETAIL(E5), TMC_SW_DETAIL(E6), TMC_SW_DETAIL(E7)
+  };
+
+  constexpr bool sc_sw_done(size_t start, size_t end) { return start == end; }
+  constexpr bool sc_sw_skip(int32_t txpin) { return txpin < 0; }
+  constexpr bool sc_sw_match(int32_t txpin, int32_t rxpin, uint32_t address, size_t start, size_t end) {
+    return !sc_sw_done(start, end) && !sc_sw_skip(txpin) && (txpin == sanity_tmc_sw_details[start].txpin || rxpin == sanity_tmc_sw_details[start].rxpin) && (address == sanity_tmc_sw_details[start].address);
+  }
+  constexpr int count_tmc_sw_serial_matches(int32_t txpin, int32_t rxpin, uint32_t address, size_t start, size_t end) {
+    return sc_sw_done(start, end) ? 0 : ((sc_sw_skip(txpin) ? 0 : (sc_sw_match(txpin, rxpin, address, start, end) ? 1 : 0)) + count_tmc_sw_serial_matches(txpin, rxpin, address, start + 1, end));
+  }
+
+  #define TMC_SWSERIAL_CONFLICT_MSG(A) STRINGIFY(A) "_SLAVE_ADDRESS conflicts with another driver using the same " STRINGIFY(A) "_SERIAL_RX_PIN or " STRINGIFY(A) "_SERIAL_TX_PIN"
+  #define SA_NO_TMC_SW_C(A) static_assert(1 >= count_tmc_sw_serial_matches(TMC_SW_DETAIL_ARGS(A), 0, COUNT(sanity_tmc_sw_details)), TMC_SWSERIAL_CONFLICT_MSG(A));
+  SA_NO_TMC_SW_C(X);SA_NO_TMC_SW_C(X2);
+  SA_NO_TMC_SW_C(Y);SA_NO_TMC_SW_C(Y2);
+  SA_NO_TMC_SW_C(Z);SA_NO_TMC_SW_C(Z2);SA_NO_TMC_SW_C(Z3);SA_NO_TMC_SW_C(Z4);
+  SA_NO_TMC_SW_C(E0);SA_NO_TMC_SW_C(E1);SA_NO_TMC_SW_C(E2);SA_NO_TMC_SW_C(E3);SA_NO_TMC_SW_C(E4);SA_NO_TMC_SW_C(E5);SA_NO_TMC_SW_C(E6);SA_NO_TMC_SW_C(E7);
+#endif
+
 #endif // HAS_TRINAMIC_CONFIG

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 7d87853d81..3dda98698b 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit 31167c158b6ed7fc7a5105c7f7848ae85058c11a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jun 21 22:10:29 2020 -0500

    TMCStepper 0.7.0

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 26a0f58959..7d87853d81 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -54,7 +54,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 #else
   #define TMC_UART_HW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(&ST##_HARDWARE_SERIAL, float(ST##_RSENSE), ST##_SLAVE_ADDRESS)
 #endif
-#define TMC_UART_SW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN, float(ST##_RSENSE), ST##_SLAVE_ADDRESS, ST##_SERIAL_RX_PIN > -1)
+#define TMC_UART_SW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN, float(ST##_RSENSE), ST##_SLAVE_ADDRESS)
 
 #define _TMC_SPI_DEFINE(IC, ST, AI) __TMC_SPI_DEFINE(IC, ST, TMC_##ST##_LABEL, AI)
 #define TMC_SPI_DEFINE(ST, AI) _TMC_SPI_DEFINE(ST##_DRIVER_TYPE, ST, AI##_AXIS)

commit fe7452c5cbc9086abfdaeac316351cfa17de61c4
Author: George Fu <nailao_5918@163.com>
Date:   Tue May 26 04:48:33 2020 +0800

    TMC serial multiplexer, FYSETC AIO-II (#18080)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index ed238ede7d..26a0f58959 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -49,7 +49,11 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
   #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, float(ST##_RSENSE), ST##_CHAIN_POS)
 #endif
 
-#define TMC_UART_HW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(&ST##_HARDWARE_SERIAL, float(ST##_RSENSE), ST##_SLAVE_ADDRESS)
+#if ENABLED(TMC_SERIAL_MULTIPLEXER)
+  #define TMC_UART_HW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(&ST##_HARDWARE_SERIAL, float(ST##_RSENSE), ST##_SLAVE_ADDRESS, SERIAL_MUL_PIN1, SERIAL_MUL_PIN2)
+#else
+  #define TMC_UART_HW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(&ST##_HARDWARE_SERIAL, float(ST##_RSENSE), ST##_SLAVE_ADDRESS)
+#endif
 #define TMC_UART_SW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN, float(ST##_RSENSE), ST##_SLAVE_ADDRESS, ST##_SERIAL_RX_PIN > -1)
 
 #define _TMC_SPI_DEFINE(IC, ST, AI) __TMC_SPI_DEFINE(IC, ST, TMC_##ST##_LABEL, AI)

commit a2153c15eef903181afe522dfd719dc6aed90316
Author: Jason Smith <jason.inet@gmail.com>
Date:   Thu May 7 23:15:12 2020 -0700

    Add TMC driver HW serial defines (#17909)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index e2bf706bf1..ed238ede7d 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -318,15 +318,19 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
   enum TMCAxis : uint8_t { X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7, TOTAL };
 
   void tmc_serial_begin() {
-    struct {
-      const void *ptr[TMCAxis::TOTAL];
-      bool began(const TMCAxis a, const void * const p) {
-        LOOP_L_N(i, a) if (p == ptr[i]) return true;
-        ptr[a] = p; return false;
-      };
-    } sp_helper;
-    #define HW_SERIAL_BEGIN(A) do{ if (!sp_helper.began(TMCAxis::A, &A##_HARDWARE_SERIAL)) \
-                                         A##_HARDWARE_SERIAL.begin(TMC_BAUD_RATE); }while(0)
+    #if HAS_TMC_HW_SERIAL
+      struct {
+        const void *ptr[TMCAxis::TOTAL];
+        bool began(const TMCAxis a, const void * const p) {
+          LOOP_L_N(i, a) if (p == ptr[i]) return true;
+          ptr[a] = p; return false;
+        };
+      } sp_helper;
+
+      #define HW_SERIAL_BEGIN(A) do{ if (!sp_helper.began(TMCAxis::A, &A##_HARDWARE_SERIAL)) \
+                                          A##_HARDWARE_SERIAL.begin(TMC_BAUD_RATE); }while(0)
+    #endif
+
     #if AXIS_HAS_UART(X)
       #ifdef X_HARDWARE_SERIAL
         HW_SERIAL_BEGIN(X);

commit eeabe66fc49501222fc458f5c298893e4d88ee17
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 5 00:28:39 2020 -0500

    Some distinct E helpers

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 48a4ff85e9..e2bf706bf1 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -58,7 +58,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 #define _TMC_UART_DEFINE(SWHW, IC, ST, AI) TMC_UART_##SWHW##_DEFINE(IC, ST, TMC_##ST##_LABEL, AI)
 #define TMC_UART_DEFINE(SWHW, ST, AI) _TMC_UART_DEFINE(SWHW, ST##_DRIVER_TYPE, ST, AI##_AXIS)
 
-#if ENABLED(DISTINCT_E_FACTORS) && E_STEPPERS > 1
+#if DISTINCT_E > 1
   #define TMC_SPI_DEFINE_E(AI) TMC_SPI_DEFINE(E##AI, E##AI)
   #define TMC_UART_DEFINE_E(SWHW, AI) TMC_UART_DEFINE(SWHW, E##AI, E##AI)
 #else

commit a226b281aff5d569bc18afb9879149e0e89d29df
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 30 22:52:33 2020 -0500

    UI and stall reset for extra TMC axes (#17818)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 4f0751ec2e..48a4ff85e9 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -117,16 +117,12 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 #endif
 
 #ifndef TMC_BAUD_RATE
-  #if HAS_TMC_SW_SERIAL
-    // Reduce baud rate for boards not already overriding TMC_BAUD_RATE for software serial.
-    // Testing has shown that 115200 is not 100% reliable on AVR platforms, occasionally
-    // failing to read status properly. 32-bit platforms typically define an even lower
-    // TMC_BAUD_RATE, due to differences in how SoftwareSerial libraries work on different
-    // platforms.
-    #define TMC_BAUD_RATE 57600
-  #else
-    #define TMC_BAUD_RATE 115200
-  #endif
+  // Reduce baud rate for boards not already overriding TMC_BAUD_RATE for software serial.
+  // Testing has shown that 115200 is not 100% reliable on AVR platforms, occasionally
+  // failing to read status properly. 32-bit platforms typically define an even lower
+  // TMC_BAUD_RATE, due to differences in how SoftwareSerial libraries work on different
+  // platforms.
+  #define TMC_BAUD_RATE TERN(HAS_TMC_SW_SERIAL, 57600, 115200)
 #endif
 
 #if HAS_DRIVER(TMC2130)
@@ -158,11 +154,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ampl = 180;
     st.PWMCONF(pwmconf.sr);
 
-    #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(hyb_thrs);
-    #else
-      UNUSED(hyb_thrs);
-    #endif
+    TERN(HYBRID_THRESHOLD, st.set_pwm_thrs(hyb_thrs), UNUSED(hyb_thrs));
 
     st.GSTAT(); // Clear GSTAT
   }
@@ -200,11 +192,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ofs = 36;
     st.PWMCONF(pwmconf.sr);
 
-    #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(hyb_thrs);
-    #else
-      UNUSED(hyb_thrs);
-    #endif
+    TERN(HYBRID_THRESHOLD, st.set_pwm_thrs(hyb_thrs), UNUSED(hyb_thrs));
 
     st.GSTAT(); // Clear GSTAT
   }
@@ -489,11 +477,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ofs = 36;
     st.PWMCONF(pwmconf.sr);
 
-    #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(hyb_thrs);
-    #else
-      UNUSED(hyb_thrs);
-    #endif
+    TERN(HYBRID_THRESHOLD, st.set_pwm_thrs(hyb_thrs), UNUSED(hyb_thrs));
 
     st.GSTAT(0b111); // Clear
     delay(200);
@@ -535,11 +519,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ofs = 36;
     st.PWMCONF(pwmconf.sr);
 
-    #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(hyb_thrs);
-    #else
-      UNUSED(hyb_thrs);
-    #endif
+    TERN(HYBRID_THRESHOLD, st.set_pwm_thrs(hyb_thrs), UNUSED(hyb_thrs));
 
     st.GSTAT(0b111); // Clear
     delay(200);
@@ -597,11 +577,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     pwmconf.pwm_ampl = 180;
     st.PWMCONF(pwmconf.sr);
 
-    #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(hyb_thrs);
-    #else
-      UNUSED(hyb_thrs);
-    #endif
+    TERN(HYBRID_THRESHOLD, st.set_pwm_thrs(hyb_thrs), UNUSED(hyb_thrs));
 
     st.GSTAT(); // Clear GSTAT
   }
@@ -700,25 +676,7 @@ void restore_trinamic_drivers() {
 }
 
 void reset_trinamic_drivers() {
-  static constexpr bool stealthchop_by_axis[] = {
-    #if ENABLED(STEALTHCHOP_XY)
-      true
-    #else
-      false
-    #endif
-    ,
-    #if ENABLED(STEALTHCHOP_Z)
-      true
-    #else
-      false
-    #endif
-    ,
-    #if ENABLED(STEALTHCHOP_E)
-      true
-    #else
-      false
-    #endif
-  };
+  static constexpr bool stealthchop_by_axis[] = { ENABLED(STEALTHCHOP_XY), ENABLED(STEALTHCHOP_Z), ENABLED(STEALTHCHOP_E) };
 
   #if AXIS_IS_TMC(X)
     TMC_INIT(X, STEALTH_AXIS_XY);
@@ -770,14 +728,30 @@ void reset_trinamic_drivers() {
   #endif
 
   #if USE_SENSORLESS
-    TERN_(X_SENSORLESS,  stepperX.homing_threshold(X_STALL_SENSITIVITY));
-    TERN_(X2_SENSORLESS, stepperX2.homing_threshold(X2_STALL_SENSITIVITY));
-    TERN_(Y_SENSORLESS,  stepperY.homing_threshold(Y_STALL_SENSITIVITY));
-    TERN_(Y2_SENSORLESS, stepperY2.homing_threshold(Y2_STALL_SENSITIVITY));
-    TERN_(Z_SENSORLESS,  stepperZ.homing_threshold(Z_STALL_SENSITIVITY));
-    TERN_(Z2_SENSORLESS, stepperZ2.homing_threshold(Z2_STALL_SENSITIVITY));
-    TERN_(Z3_SENSORLESS, stepperZ3.homing_threshold(Z3_STALL_SENSITIVITY));
-    TERN_(Z4_SENSORLESS, stepperZ4.homing_threshold(Z4_STALL_SENSITIVITY));
+    #if X_SENSORLESS
+      stepperX.homing_threshold(X_STALL_SENSITIVITY);
+      #if AXIS_HAS_STALLGUARD(X2)
+        stepperX2.homing_threshold(CAT(TERN(X2_SENSORLESS, X2, X), _STALL_SENSITIVITY));
+      #endif
+    #endif
+    #if Y_SENSORLESS
+      stepperY.homing_threshold(Y_STALL_SENSITIVITY);
+      #if AXIS_HAS_STALLGUARD(Y2)
+        stepperY2.homing_threshold(CAT(TERN(Y2_SENSORLESS, Y2, Y), _STALL_SENSITIVITY));
+      #endif
+    #endif
+    #if Z_SENSORLESS
+      stepperZ.homing_threshold(Z_STALL_SENSITIVITY);
+      #if AXIS_HAS_STALLGUARD(Z2)
+        stepperZ2.homing_threshold(CAT(TERN(Z2_SENSORLESS, Z2, Z), _STALL_SENSITIVITY));
+      #endif
+      #if AXIS_HAS_STALLGUARD(Z3)
+        stepperZ3.homing_threshold(CAT(TERN(Z3_SENSORLESS, Z3, Z), _STALL_SENSITIVITY));
+      #endif
+      #if AXIS_HAS_STALLGUARD(Z4)
+        stepperZ4.homing_threshold(CAT(TERN(Z4_SENSORLESS, Z4, Z), _STALL_SENSITIVITY));
+      #endif
+    #endif
   #endif
 
   #ifdef TMC_ADV

commit 7c3909bc3f5ea84a59f7dce4e3a378f7e2c4e5ba
Author: Neil van Geffen <neilvangeffen@gmail.com>
Date:   Tue Apr 28 18:22:03 2020 +1200

    Save/Load distinct TMC SG thresholds (#17741)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 100d660f2c..4f0751ec2e 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -770,39 +770,14 @@ void reset_trinamic_drivers() {
   #endif
 
   #if USE_SENSORLESS
-    #if X_SENSORLESS
-      #if AXIS_HAS_STALLGUARD(X)
-        stepperX.homing_threshold(X_STALL_SENSITIVITY);
-      #endif
-      #if AXIS_HAS_STALLGUARD(X2) && !X2_SENSORLESS
-        stepperX2.homing_threshold(X_STALL_SENSITIVITY);
-      #endif
-    #endif
-    #if X2_SENSORLESS
-      stepperX2.homing_threshold(X2_STALL_SENSITIVITY);
-    #endif
-    #if Y_SENSORLESS
-      #if AXIS_HAS_STALLGUARD(Y)
-        stepperY.homing_threshold(Y_STALL_SENSITIVITY);
-      #endif
-      #if AXIS_HAS_STALLGUARD(Y2)
-        stepperY2.homing_threshold(Y_STALL_SENSITIVITY);
-      #endif
-    #endif
-    #if Z_SENSORLESS
-      #if AXIS_HAS_STALLGUARD(Z)
-        stepperZ.homing_threshold(Z_STALL_SENSITIVITY);
-      #endif
-      #if AXIS_HAS_STALLGUARD(Z2)
-        stepperZ2.homing_threshold(Z_STALL_SENSITIVITY);
-      #endif
-      #if AXIS_HAS_STALLGUARD(Z3)
-        stepperZ3.homing_threshold(Z_STALL_SENSITIVITY);
-      #endif
-      #if AXIS_HAS_STALLGUARD(Z4)
-        stepperZ4.homing_threshold(Z_STALL_SENSITIVITY);
-      #endif
-    #endif
+    TERN_(X_SENSORLESS,  stepperX.homing_threshold(X_STALL_SENSITIVITY));
+    TERN_(X2_SENSORLESS, stepperX2.homing_threshold(X2_STALL_SENSITIVITY));
+    TERN_(Y_SENSORLESS,  stepperY.homing_threshold(Y_STALL_SENSITIVITY));
+    TERN_(Y2_SENSORLESS, stepperY2.homing_threshold(Y2_STALL_SENSITIVITY));
+    TERN_(Z_SENSORLESS,  stepperZ.homing_threshold(Z_STALL_SENSITIVITY));
+    TERN_(Z2_SENSORLESS, stepperZ2.homing_threshold(Z2_STALL_SENSITIVITY));
+    TERN_(Z3_SENSORLESS, stepperZ3.homing_threshold(Z3_STALL_SENSITIVITY));
+    TERN_(Z4_SENSORLESS, stepperZ4.homing_threshold(Z4_STALL_SENSITIVITY));
   #endif
 
   #ifdef TMC_ADV

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 1440c24cf8..100d660f2c 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -140,9 +140,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     chopconf.intpol = INTERPOLATE;
     chopconf.hend = chopper_timing.hend + 3;
     chopconf.hstrt = chopper_timing.hstrt - 1;
-    #if ENABLED(SQUARE_WAVE_STEPPING)
-      chopconf.dedge = true;
-    #endif
+    TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);
@@ -181,9 +179,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     chopconf.intpol = INTERPOLATE;
     chopconf.hend = chopper_timing.hend + 3;
     chopconf.hstrt = chopper_timing.hstrt - 1;
-    #if ENABLED(SQUARE_WAVE_STEPPING)
-      chopconf.dedge = true;
-    #endif
+    TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);
@@ -475,9 +471,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     chopconf.intpol = INTERPOLATE;
     chopconf.hend = chopper_timing.hend + 3;
     chopconf.hstrt = chopper_timing.hstrt - 1;
-    #if ENABLED(SQUARE_WAVE_STEPPING)
-      chopconf.dedge = true;
-    #endif
+    TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);
@@ -523,9 +517,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     chopconf.intpol = INTERPOLATE;
     chopconf.hend = chopper_timing.hend + 3;
     chopconf.hstrt = chopper_timing.hstrt - 1;
-    #if ENABLED(SQUARE_WAVE_STEPPING)
-      chopconf.dedge = true;
-    #endif
+    TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);
@@ -569,15 +561,10 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     st.sdoff(0);
     st.rms_current(mA);
     st.microsteps(microsteps);
-    #if ENABLED(SQUARE_WAVE_STEPPING)
-      st.dedge(true);
-    #endif
+    TERN_(SQUARE_WAVE_STEPPING, st.dedge(true));
     st.intpol(INTERPOLATE);
     st.diss2g(true); // Disable short to ground protection. Too many false readings?
-
-    #if ENABLED(TMC_DEBUG)
-      st.rdsel(0b01);
-    #endif
+    TERN_(TMC_DEBUG, st.rdsel(0b01));
   }
 #endif // TMC2660
 
@@ -592,9 +579,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     chopconf.intpol = INTERPOLATE;
     chopconf.hend = chopper_timing.hend + 3;
     chopconf.hstrt = chopper_timing.hstrt - 1;
-    #if ENABLED(SQUARE_WAVE_STEPPING)
-      chopconf.dedge = true;
-    #endif
+    TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);
@@ -633,9 +618,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     chopconf.intpol = INTERPOLATE;
     chopconf.hend = chopper_timing.hend + 3;
     chopconf.hstrt = chopper_timing.hstrt - 1;
-    #if ENABLED(SQUARE_WAVE_STEPPING)
-      chopconf.dedge = true;
-    #endif
+    TERN_(SQUARE_WAVE_STEPPING, chopconf.dedge = true);
     st.CHOPCONF(chopconf.sr);
 
     st.rms_current(mA, HOLD_MULTIPLIER);

commit 11ce281694c08565e14023f379f72e4765738442
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 2 13:32:49 2020 -0500

    Followup to #17351

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index f0ac48f514..1440c24cf8 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -341,7 +341,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
         ptr[a] = p; return false;
       };
     } sp_helper;
-    #define HW_SERIAL_BEGIN(A) do{ if (sp_helper.began(TMCAxis::A, &A##_HARDWARE_SERIAL)) \
+    #define HW_SERIAL_BEGIN(A) do{ if (!sp_helper.began(TMCAxis::A, &A##_HARDWARE_SERIAL)) \
                                          A##_HARDWARE_SERIAL.begin(TMC_BAUD_RATE); }while(0)
     #if AXIS_HAS_UART(X)
       #ifdef X_HARDWARE_SERIAL

commit 192c7c27b9130d5e13f6a1a96ccf490c48d2e26c
Author: Simon Jouet <simon-jouet@users.noreply.github.com>
Date:   Wed Apr 1 22:20:38 2020 +0100

    Fix extra TMC serial begin calls (#17351)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 14598f9c73..f0ac48f514 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -331,115 +331,126 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     #endif
   #endif
 
+  enum TMCAxis : uint8_t { X, Y, Z, X2, Y2, Z2, Z3, Z4, E0, E1, E2, E3, E4, E5, E6, E7, TOTAL };
+
   void tmc_serial_begin() {
+    struct {
+      const void *ptr[TMCAxis::TOTAL];
+      bool began(const TMCAxis a, const void * const p) {
+        LOOP_L_N(i, a) if (p == ptr[i]) return true;
+        ptr[a] = p; return false;
+      };
+    } sp_helper;
+    #define HW_SERIAL_BEGIN(A) do{ if (sp_helper.began(TMCAxis::A, &A##_HARDWARE_SERIAL)) \
+                                         A##_HARDWARE_SERIAL.begin(TMC_BAUD_RATE); }while(0)
     #if AXIS_HAS_UART(X)
       #ifdef X_HARDWARE_SERIAL
-        X_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+        HW_SERIAL_BEGIN(X);
       #else
         stepperX.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(X2)
       #ifdef X2_HARDWARE_SERIAL
-        X2_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+        HW_SERIAL_BEGIN(X2);
       #else
         stepperX2.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Y)
       #ifdef Y_HARDWARE_SERIAL
-        Y_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+        HW_SERIAL_BEGIN(Y);
       #else
         stepperY.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Y2)
       #ifdef Y2_HARDWARE_SERIAL
-        Y2_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+        HW_SERIAL_BEGIN(Y2);
       #else
         stepperY2.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Z)
       #ifdef Z_HARDWARE_SERIAL
-        Z_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+        HW_SERIAL_BEGIN(Z);
       #else
         stepperZ.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Z2)
       #ifdef Z2_HARDWARE_SERIAL
-        Z2_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+        HW_SERIAL_BEGIN(Z2);
       #else
         stepperZ2.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Z3)
       #ifdef Z3_HARDWARE_SERIAL
-        Z3_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+        HW_SERIAL_BEGIN(Z3);
       #else
         stepperZ3.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Z4)
       #ifdef Z4_HARDWARE_SERIAL
-        Z4_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+        HW_SERIAL_BEGIN(Z4);
       #else
         stepperZ4.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E0)
       #ifdef E0_HARDWARE_SERIAL
-        E0_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+        HW_SERIAL_BEGIN(E0);
       #else
         stepperE0.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E1)
       #ifdef E1_HARDWARE_SERIAL
-        E1_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+        HW_SERIAL_BEGIN(E1);
       #else
         stepperE1.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E2)
       #ifdef E2_HARDWARE_SERIAL
-        E2_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+        HW_SERIAL_BEGIN(E2);
       #else
         stepperE2.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E3)
       #ifdef E3_HARDWARE_SERIAL
-        E3_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+        HW_SERIAL_BEGIN(E3);
       #else
         stepperE3.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E4)
       #ifdef E4_HARDWARE_SERIAL
-        E4_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+        HW_SERIAL_BEGIN(E4);
       #else
         stepperE4.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E5)
       #ifdef E5_HARDWARE_SERIAL
-        E5_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+        HW_SERIAL_BEGIN(E5);
       #else
         stepperE5.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E6)
       #ifdef E6_HARDWARE_SERIAL
-        E6_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+        HW_SERIAL_BEGIN(E6);
       #else
         stepperE6.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E7)
       #ifdef E7_HARDWARE_SERIAL
-        E7_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+        HW_SERIAL_BEGIN(E7);
       #else
         stepperE7.beginSerial(TMC_BAUD_RATE);
       #endif

commit b1a50d54e2a6f8e415a72e0e2d275304029d8ada
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 2 12:03:43 2020 -0600

    HAS_TRINAMIC => HAS_TRINAMIC_CONFIG

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 0b14aaf647..14598f9c73 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -27,7 +27,7 @@
 
 #include "../../inc/MarlinConfig.h"
 
-#if HAS_TRINAMIC
+#if HAS_TRINAMIC_CONFIG
 
 #include "trinamic.h"
 #include "../stepper.h"
@@ -818,4 +818,4 @@ void reset_trinamic_drivers() {
   stepper.set_directions();
 }
 
-#endif // HAS_TRINAMIC
+#endif // HAS_TRINAMIC_CONFIG

commit 2bcc2ec7d1125428beb6898a527d1cc49c26ac78
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Feb 23 05:48:56 2020 -0800

    Reduce default TMC baudrate to 57600 with Software Serial (#16930)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 506383aa35..0b14aaf647 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -117,7 +117,16 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 #endif
 
 #ifndef TMC_BAUD_RATE
-  #define TMC_BAUD_RATE 115200
+  #if HAS_TMC_SW_SERIAL
+    // Reduce baud rate for boards not already overriding TMC_BAUD_RATE for software serial.
+    // Testing has shown that 115200 is not 100% reliable on AVR platforms, occasionally
+    // failing to read status properly. 32-bit platforms typically define an even lower
+    // TMC_BAUD_RATE, due to differences in how SoftwareSerial libraries work on different
+    // platforms.
+    #define TMC_BAUD_RATE 57600
+  #else
+    #define TMC_BAUD_RATE 115200
+  #endif
 #endif
 
 #if HAS_DRIVER(TMC2130)

commit 72fae2faa5c95f63f50daf49be67657ddc3ad069
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 15 18:51:23 2020 -0600

    Require TMCStepper 0.6.2

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 1103e12f63..506383aa35 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -44,13 +44,13 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 //   AI = Axis Enum Index
 // SWHW = SW/SH UART selection
 #if ENABLED(TMC_USE_SW_SPI)
-  #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, ST##_RSENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK, ST##_CHAIN_POS)
+  #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, float(ST##_RSENSE), TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK, ST##_CHAIN_POS)
 #else
-  #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, ST##_RSENSE, ST##_CHAIN_POS)
+  #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, float(ST##_RSENSE), ST##_CHAIN_POS)
 #endif
 
-#define TMC_UART_HW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(&ST##_HARDWARE_SERIAL, ST##_RSENSE, ST##_SLAVE_ADDRESS)
-#define TMC_UART_SW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN, ST##_RSENSE, ST##_SLAVE_ADDRESS, ST##_SERIAL_RX_PIN > -1)
+#define TMC_UART_HW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(&ST##_HARDWARE_SERIAL, float(ST##_RSENSE), ST##_SLAVE_ADDRESS)
+#define TMC_UART_SW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN, float(ST##_RSENSE), ST##_SLAVE_ADDRESS, ST##_SERIAL_RX_PIN > -1)
 
 #define _TMC_SPI_DEFINE(IC, ST, AI) __TMC_SPI_DEFINE(IC, ST, TMC_##ST##_LABEL, AI)
 #define TMC_SPI_DEFINE(ST, AI) _TMC_SPI_DEFINE(ST##_DRIVER_TYPE, ST, AI##_AXIS)

commit 18a7276909a3e2aa1761ba0c46577a8f6e7baedb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 9 21:22:26 2020 -0600

    Revert "Coolstep for TMC2130, 2209, 5130, 5160"
    
    Reverting #16790 as not ready for primetime.

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index a9f6f08f48..1103e12f63 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -36,19 +36,7 @@
 #include <SPI.h>
 
 enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
-#define _TMC_INIT_1(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS)
-#define _TMC_INIT_2(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, stealthchop_by_axis[STEALTH_INDEX], ST##_HYBRID_THRESHOLD)
-#define _TMC_INIT_3(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, stealthchop_by_axis[STEALTH_INDEX], ST##_HYBRID_THRESHOLD, ST##_COOLSTEP_SPEED_THRESHOLD, ST##_COOLSTEP_LOWER_LOAD_THRESHOLD, ST##_COOLSTEP_UPPER_LOAD_THRESHOLD, ST##_COOLSTEP_SEUP, ST##_COOLSTEP_SEDN, ST##_COOLSTEP_SEIMIN)
-#define _TMC_INIT_TMC2660(ST, STEALTH_INDEX) _TMC_INIT_1(ST, STEALTH_INDEX)
-#define _TMC_INIT_TMC2160(ST, STEALTH_INDEX) _TMC_INIT_2(ST, STEALTH_INDEX)
-#define _TMC_INIT_TMC2208(ST, STEALTH_INDEX) _TMC_INIT_2(ST, STEALTH_INDEX)
-#define _TMC_INIT_TMC5130(ST, STEALTH_INDEX) _TMC_INIT_3(ST, STEALTH_INDEX)
-#define _TMC_INIT_TMC5160(ST, STEALTH_INDEX) _TMC_INIT_3(ST, STEALTH_INDEX)
-#define _TMC_INIT_TMC2130(ST, STEALTH_INDEX) _TMC_INIT_3(ST, STEALTH_INDEX)
-#define _TMC_INIT_TMC2209(ST, STEALTH_INDEX) _TMC_INIT_3(ST, STEALTH_INDEX)
-#define __TMC_INIT(DRV, ST, STEALTH_INDEX) _TMC_INIT_##DRV(ST, STEALTH_INDEX)
-#define _TMC_INIT(DRV, ST, STEALTH_INDEX) __TMC_INIT(DRV, ST, STEALTH_INDEX)
-#define TMC_INIT(ST, STEALTH_INDEX) _TMC_INIT(ST##_DRIVER_TYPE, ST, STEALTH_INDEX)
+#define TMC_INIT(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, stealthchop_by_axis[STEALTH_INDEX])
 
 //   IC = TMC model number
 //   ST = Stepper object letter
@@ -134,19 +122,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2130)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(
-    TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st,
-    const uint16_t mA,
-    const uint16_t microsteps,
-    const bool stealth,
-    const uint32_t hyb_thrs,
-    const uint32_t cool_thrs,
-    const uint8_t cool_semin,
-    const uint8_t cool_semax,
-    const uint8_t cool_seup,
-    const uint8_t cool_sedn,
-    const bool cool_seimin
-  ) {
+  void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
@@ -181,28 +157,13 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
       UNUSED(hyb_thrs);
     #endif
 
-    st.set_cool_thrs(cool_thrs);  // (mm/s)
-    COOLCONF_t coolconf{0};
-    coolconf.semin = cool_semin;
-    coolconf.semax = cool_semax;
-    coolconf.seup = cool_seup;
-    coolconf.sedn = cool_sedn;
-    coolconf.seimin = cool_seimin;
-    st.COOLCONF(coolconf.sr);
-
     st.GSTAT(); // Clear GSTAT
   }
 #endif // TMC2130
 
 #if HAS_DRIVER(TMC2160)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(
-    TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st,
-    const uint16_t mA,
-    const uint16_t microsteps,
-    const bool stealth,
-    const uint32_t hyb_thrs
-  ) {
+  void tmc_init(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
@@ -479,13 +440,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2208)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(
-    TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st,
-    const uint16_t mA,
-    const uint16_t microsteps,
-    const bool stealth,
-    const uint32_t hyb_thrs
-  ) {
+  void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth) {
     TMC2208_n::GCONF_t gconf{0};
     gconf.pdn_disable = true; // Use UART
     gconf.mstep_reg_select = true; // Select microsteps with UART
@@ -533,19 +488,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2209)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(
-    TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st,
-    const uint16_t mA,
-    const uint16_t microsteps,
-    const bool stealth,
-    const uint32_t hyb_thrs,
-    const uint32_t cool_thrs,
-    const uint8_t cool_semin,
-    const uint8_t cool_semax,
-    const uint8_t cool_seup,
-    const uint8_t cool_sedn,
-    const bool cool_seimin
-  ) {
+  void tmc_init(TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth) {
     TMC2208_n::GCONF_t gconf{0};
     gconf.pdn_disable = true; // Use UART
     gconf.mstep_reg_select = true; // Select microsteps with UART
@@ -586,15 +529,6 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
       UNUSED(hyb_thrs);
     #endif
 
-    st.set_cool_thrs(cool_thrs);  // (mm/s)
-    COOLCONF_t coolconf{0};
-    coolconf.semin = cool_semin;
-    coolconf.semax = cool_semax;
-    coolconf.seup = cool_seup;
-    coolconf.sedn = cool_sedn;
-    coolconf.seimin = cool_seimin;
-    st.COOLCONF(coolconf.sr);
-
     st.GSTAT(0b111); // Clear
     delay(200);
   }
@@ -602,11 +536,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2660)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(
-    TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st,
-    const uint16_t mA,
-    const uint16_t microsteps
-  ) {
+  void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const bool) {
     st.begin();
 
     TMC2660_n::CHOPCONF_t chopconf{0};
@@ -633,19 +563,7 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC5130)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(
-    TMCMarlin<TMC5130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st,
-    const uint16_t mA,
-    const uint16_t microsteps,
-    const bool stealth,
-    const uint32_t hyb_thrs,
-    const uint32_t cool_thrs,
-    const uint8_t cool_semin,
-    const uint8_t cool_semax,
-    const uint8_t cool_seup,
-    const uint8_t cool_sedn,
-    const bool cool_seimin
-  ) {
+  void tmc_init(TMCMarlin<TMC5130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
@@ -680,34 +598,13 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
       UNUSED(hyb_thrs);
     #endif
 
-    st.set_cool_thrs(cool_thrs);  // (mm/s)
-    COOLCONF_t coolconf{0};
-    coolconf.semin = cool_semin;
-    coolconf.semax = cool_semax;
-    coolconf.seup = cool_seup;
-    coolconf.sedn = cool_sedn;
-    coolconf.seimin = cool_seimin;
-    st.COOLCONF(coolconf.sr);
-
     st.GSTAT(); // Clear GSTAT
   }
 #endif // TMC5130
 
 #if HAS_DRIVER(TMC5160)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(
-    TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st,
-    const uint16_t mA,
-    const uint16_t microsteps,
-    const bool stealth,
-    const uint32_t hyb_thrs,
-    const uint32_t cool_thrs,
-    const uint8_t cool_semin,
-    const uint8_t cool_semax,
-    const uint8_t cool_seup,
-    const uint8_t cool_sedn,
-    const bool cool_seimin
-  ) {
+  void tmc_init(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t hyb_thrs, const bool stealth) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
@@ -744,16 +641,6 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     #else
       UNUSED(hyb_thrs);
     #endif
-
-    st.set_cool_thrs(cool_thrs);  // (mm/s)
-    COOLCONF_t coolconf{0};
-    coolconf.semin = cool_semin;
-    coolconf.semax = cool_semax;
-    coolconf.seup = cool_seup;
-    coolconf.sedn = cool_sedn;
-    coolconf.seimin = cool_seimin;
-    st.COOLCONF(coolconf.sr);
-
     st.GSTAT(); // Clear GSTAT
   }
 #endif // TMC5160

commit 894762259b072407504ee584103680b103310026
Author: Fabio Santos <fabiosan@live.com>
Date:   Sat Feb 8 19:01:57 2020 -0800

    Coolstep for TMC2130, 2209, 5130, 5160 (#16790)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 69eaaa5c5c..a9f6f08f48 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -36,7 +36,19 @@
 #include <SPI.h>
 
 enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
-#define _TMC_INIT(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, stealthchop_by_axis[STEALTH_INDEX])
+#define _TMC_INIT_1(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS)
+#define _TMC_INIT_2(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, stealthchop_by_axis[STEALTH_INDEX], ST##_HYBRID_THRESHOLD)
+#define _TMC_INIT_3(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, stealthchop_by_axis[STEALTH_INDEX], ST##_HYBRID_THRESHOLD, ST##_COOLSTEP_SPEED_THRESHOLD, ST##_COOLSTEP_LOWER_LOAD_THRESHOLD, ST##_COOLSTEP_UPPER_LOAD_THRESHOLD, ST##_COOLSTEP_SEUP, ST##_COOLSTEP_SEDN, ST##_COOLSTEP_SEIMIN)
+#define _TMC_INIT_TMC2660(ST, STEALTH_INDEX) _TMC_INIT_1(ST, STEALTH_INDEX)
+#define _TMC_INIT_TMC2160(ST, STEALTH_INDEX) _TMC_INIT_2(ST, STEALTH_INDEX)
+#define _TMC_INIT_TMC2208(ST, STEALTH_INDEX) _TMC_INIT_2(ST, STEALTH_INDEX)
+#define _TMC_INIT_TMC5130(ST, STEALTH_INDEX) _TMC_INIT_3(ST, STEALTH_INDEX)
+#define _TMC_INIT_TMC5160(ST, STEALTH_INDEX) _TMC_INIT_3(ST, STEALTH_INDEX)
+#define _TMC_INIT_TMC2130(ST, STEALTH_INDEX) _TMC_INIT_3(ST, STEALTH_INDEX)
+#define _TMC_INIT_TMC2209(ST, STEALTH_INDEX) _TMC_INIT_3(ST, STEALTH_INDEX)
+#define __TMC_INIT(DRV, ST, STEALTH_INDEX) _TMC_INIT_##DRV(ST, STEALTH_INDEX)
+#define _TMC_INIT(DRV, ST, STEALTH_INDEX) __TMC_INIT(DRV, ST, STEALTH_INDEX)
+#define TMC_INIT(ST, STEALTH_INDEX) _TMC_INIT(ST##_DRIVER_TYPE, ST, STEALTH_INDEX)
 
 //   IC = TMC model number
 //   ST = Stepper object letter
@@ -122,7 +134,19 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2130)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
+  void tmc_init(
+    TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st,
+    const uint16_t mA,
+    const uint16_t microsteps,
+    const bool stealth,
+    const uint32_t hyb_thrs,
+    const uint32_t cool_thrs,
+    const uint8_t cool_semin,
+    const uint8_t cool_semax,
+    const uint8_t cool_seup,
+    const uint8_t cool_sedn,
+    const bool cool_seimin
+  ) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
@@ -152,18 +176,33 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     st.PWMCONF(pwmconf.sr);
 
     #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(thrs);
+      st.set_pwm_thrs(hyb_thrs);
     #else
-      UNUSED(thrs);
+      UNUSED(hyb_thrs);
     #endif
 
+    st.set_cool_thrs(cool_thrs);  // (mm/s)
+    COOLCONF_t coolconf{0};
+    coolconf.semin = cool_semin;
+    coolconf.semax = cool_semax;
+    coolconf.seup = cool_seup;
+    coolconf.sedn = cool_sedn;
+    coolconf.seimin = cool_seimin;
+    st.COOLCONF(coolconf.sr);
+
     st.GSTAT(); // Clear GSTAT
   }
 #endif // TMC2130
 
 #if HAS_DRIVER(TMC2160)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
+  void tmc_init(
+    TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st,
+    const uint16_t mA,
+    const uint16_t microsteps,
+    const bool stealth,
+    const uint32_t hyb_thrs
+  ) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
@@ -196,9 +235,9 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     st.PWMCONF(pwmconf.sr);
 
     #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(thrs);
+      st.set_pwm_thrs(hyb_thrs);
     #else
-      UNUSED(thrs);
+      UNUSED(hyb_thrs);
     #endif
 
     st.GSTAT(); // Clear GSTAT
@@ -440,7 +479,13 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2208)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
+  void tmc_init(
+    TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st,
+    const uint16_t mA,
+    const uint16_t microsteps,
+    const bool stealth,
+    const uint32_t hyb_thrs
+  ) {
     TMC2208_n::GCONF_t gconf{0};
     gconf.pdn_disable = true; // Use UART
     gconf.mstep_reg_select = true; // Select microsteps with UART
@@ -476,9 +521,9 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     st.PWMCONF(pwmconf.sr);
 
     #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(thrs);
+      st.set_pwm_thrs(hyb_thrs);
     #else
-      UNUSED(thrs);
+      UNUSED(hyb_thrs);
     #endif
 
     st.GSTAT(0b111); // Clear
@@ -488,7 +533,19 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2209)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
+  void tmc_init(
+    TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st,
+    const uint16_t mA,
+    const uint16_t microsteps,
+    const bool stealth,
+    const uint32_t hyb_thrs,
+    const uint32_t cool_thrs,
+    const uint8_t cool_semin,
+    const uint8_t cool_semax,
+    const uint8_t cool_seup,
+    const uint8_t cool_sedn,
+    const bool cool_seimin
+  ) {
     TMC2208_n::GCONF_t gconf{0};
     gconf.pdn_disable = true; // Use UART
     gconf.mstep_reg_select = true; // Select microsteps with UART
@@ -524,11 +581,20 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     st.PWMCONF(pwmconf.sr);
 
     #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(thrs);
+      st.set_pwm_thrs(hyb_thrs);
     #else
-      UNUSED(thrs);
+      UNUSED(hyb_thrs);
     #endif
 
+    st.set_cool_thrs(cool_thrs);  // (mm/s)
+    COOLCONF_t coolconf{0};
+    coolconf.semin = cool_semin;
+    coolconf.semax = cool_semax;
+    coolconf.seup = cool_seup;
+    coolconf.sedn = cool_sedn;
+    coolconf.seimin = cool_seimin;
+    st.COOLCONF(coolconf.sr);
+
     st.GSTAT(0b111); // Clear
     delay(200);
   }
@@ -536,7 +602,11 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC2660)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const bool) {
+  void tmc_init(
+    TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st,
+    const uint16_t mA,
+    const uint16_t microsteps
+  ) {
     st.begin();
 
     TMC2660_n::CHOPCONF_t chopconf{0};
@@ -563,7 +633,19 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 
 #if HAS_DRIVER(TMC5130)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC5130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
+  void tmc_init(
+    TMCMarlin<TMC5130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st,
+    const uint16_t mA,
+    const uint16_t microsteps,
+    const bool stealth,
+    const uint32_t hyb_thrs,
+    const uint32_t cool_thrs,
+    const uint8_t cool_semin,
+    const uint8_t cool_semax,
+    const uint8_t cool_seup,
+    const uint8_t cool_sedn,
+    const bool cool_seimin
+  ) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
@@ -593,18 +675,39 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     st.PWMCONF(pwmconf.sr);
 
     #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(thrs);
+      st.set_pwm_thrs(hyb_thrs);
     #else
-      UNUSED(thrs);
+      UNUSED(hyb_thrs);
     #endif
 
+    st.set_cool_thrs(cool_thrs);  // (mm/s)
+    COOLCONF_t coolconf{0};
+    coolconf.semin = cool_semin;
+    coolconf.semax = cool_semax;
+    coolconf.seup = cool_seup;
+    coolconf.sedn = cool_sedn;
+    coolconf.seimin = cool_seimin;
+    st.COOLCONF(coolconf.sr);
+
     st.GSTAT(); // Clear GSTAT
   }
 #endif // TMC5130
 
 #if HAS_DRIVER(TMC5160)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
-  void tmc_init(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
+  void tmc_init(
+    TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st,
+    const uint16_t mA,
+    const uint16_t microsteps,
+    const bool stealth,
+    const uint32_t hyb_thrs,
+    const uint32_t cool_thrs,
+    const uint8_t cool_semin,
+    const uint8_t cool_semax,
+    const uint8_t cool_seup,
+    const uint8_t cool_sedn,
+    const bool cool_seimin
+  ) {
     st.begin();
 
     CHOPCONF_t chopconf{0};
@@ -637,10 +740,20 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
     st.PWMCONF(pwmconf.sr);
 
     #if ENABLED(HYBRID_THRESHOLD)
-      st.set_pwm_thrs(thrs);
+      st.set_pwm_thrs(hyb_thrs);
     #else
-      UNUSED(thrs);
+      UNUSED(hyb_thrs);
     #endif
+
+    st.set_cool_thrs(cool_thrs);  // (mm/s)
+    COOLCONF_t coolconf{0};
+    coolconf.semin = cool_semin;
+    coolconf.semax = cool_semax;
+    coolconf.seup = cool_seup;
+    coolconf.sedn = cool_sedn;
+    coolconf.seimin = cool_seimin;
+    st.COOLCONF(coolconf.sr);
+
     st.GSTAT(); // Clear GSTAT
   }
 #endif // TMC5160
@@ -718,52 +831,52 @@ void reset_trinamic_drivers() {
   };
 
   #if AXIS_IS_TMC(X)
-    _TMC_INIT(X, STEALTH_AXIS_XY);
+    TMC_INIT(X, STEALTH_AXIS_XY);
   #endif
   #if AXIS_IS_TMC(X2)
-    _TMC_INIT(X2, STEALTH_AXIS_XY);
+    TMC_INIT(X2, STEALTH_AXIS_XY);
   #endif
   #if AXIS_IS_TMC(Y)
-    _TMC_INIT(Y, STEALTH_AXIS_XY);
+    TMC_INIT(Y, STEALTH_AXIS_XY);
   #endif
   #if AXIS_IS_TMC(Y2)
-    _TMC_INIT(Y2, STEALTH_AXIS_XY);
+    TMC_INIT(Y2, STEALTH_AXIS_XY);
   #endif
   #if AXIS_IS_TMC(Z)
-    _TMC_INIT(Z, STEALTH_AXIS_Z);
+    TMC_INIT(Z, STEALTH_AXIS_Z);
   #endif
   #if AXIS_IS_TMC(Z2)
-    _TMC_INIT(Z2, STEALTH_AXIS_Z);
+    TMC_INIT(Z2, STEALTH_AXIS_Z);
   #endif
   #if AXIS_IS_TMC(Z3)
-    _TMC_INIT(Z3, STEALTH_AXIS_Z);
+    TMC_INIT(Z3, STEALTH_AXIS_Z);
   #endif
   #if AXIS_IS_TMC(Z4)
-    _TMC_INIT(Z4, STEALTH_AXIS_Z);
+    TMC_INIT(Z4, STEALTH_AXIS_Z);
   #endif
   #if AXIS_IS_TMC(E0)
-    _TMC_INIT(E0, STEALTH_AXIS_E);
+    TMC_INIT(E0, STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E1)
-    _TMC_INIT(E1, STEALTH_AXIS_E);
+    TMC_INIT(E1, STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E2)
-    _TMC_INIT(E2, STEALTH_AXIS_E);
+    TMC_INIT(E2, STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E3)
-    _TMC_INIT(E3, STEALTH_AXIS_E);
+    TMC_INIT(E3, STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E4)
-    _TMC_INIT(E4, STEALTH_AXIS_E);
+    TMC_INIT(E4, STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E5)
-    _TMC_INIT(E5, STEALTH_AXIS_E);
+    TMC_INIT(E5, STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E6)
-    _TMC_INIT(E6, STEALTH_AXIS_E);
+    TMC_INIT(E6, STEALTH_AXIS_E);
   #endif
   #if AXIS_IS_TMC(E7)
-    _TMC_INIT(E7, STEALTH_AXIS_E);
+    TMC_INIT(E7, STEALTH_AXIS_E);
   #endif
 
   #if USE_SENSORLESS

commit f312ddfa4fd5772d825908f8e376dedf29442893
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 4 12:37:20 2020 -0600

    More updates for 8 extruders, REPEAT

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index aa31499c42..69eaaa5c5c 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -109,6 +109,12 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 #if AXIS_HAS_SPI(E5)
   TMC_SPI_DEFINE_E(5);
 #endif
+#if AXIS_HAS_SPI(E6)
+  TMC_SPI_DEFINE_E(6);
+#endif
+#if AXIS_HAS_SPI(E7)
+  TMC_SPI_DEFINE_E(7);
+#endif
 
 #ifndef TMC_BAUD_RATE
   #define TMC_BAUD_RATE 115200

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index ba65c32eb6..aa31499c42 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit 248b7dfa591a34a8aa1c6960944e1a3a468ad1de
Author: yangwenxiong <46896566+yangwenxiong@users.noreply.github.com>
Date:   Sat Jan 25 16:13:39 2020 +0800

    BigTreeTech GTR V1.0 / Support 8 extruders, heaters, temp sensors, fans (#16595)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index bdb6f20377..ba65c32eb6 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -301,6 +301,20 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
       TMC_UART_DEFINE_E(SW, 5);
     #endif
   #endif
+  #if AXIS_HAS_UART(E6)
+    #ifdef E6_HARDWARE_SERIAL
+      TMC_UART_DEFINE_E(HW, 6);
+    #else
+      TMC_UART_DEFINE_E(SW, 6);
+    #endif
+  #endif
+  #if AXIS_HAS_UART(E7)
+    #ifdef E7_HARDWARE_SERIAL
+      TMC_UART_DEFINE_E(HW, 7);
+    #else
+      TMC_UART_DEFINE_E(SW, 7);
+    #endif
+  #endif
 
   void tmc_serial_begin() {
     #if AXIS_HAS_UART(X)
@@ -401,6 +415,20 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
         stepperE5.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
+    #if AXIS_HAS_UART(E6)
+      #ifdef E6_HARDWARE_SERIAL
+        E6_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+      #else
+        stepperE6.beginSerial(TMC_BAUD_RATE);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(E7)
+      #ifdef E7_HARDWARE_SERIAL
+        E7_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+      #else
+        stepperE7.beginSerial(TMC_BAUD_RATE);
+      #endif
+    #endif
   }
 #endif
 
@@ -654,6 +682,12 @@ void restore_trinamic_drivers() {
   #if AXIS_IS_TMC(E5)
     stepperE5.push();
   #endif
+  #if AXIS_IS_TMC(E6)
+    stepperE6.push();
+  #endif
+  #if AXIS_IS_TMC(E7)
+    stepperE7.push();
+  #endif
 }
 
 void reset_trinamic_drivers() {
@@ -719,6 +753,12 @@ void reset_trinamic_drivers() {
   #if AXIS_IS_TMC(E5)
     _TMC_INIT(E5, STEALTH_AXIS_E);
   #endif
+  #if AXIS_IS_TMC(E6)
+    _TMC_INIT(E6, STEALTH_AXIS_E);
+  #endif
+  #if AXIS_IS_TMC(E7)
+    _TMC_INIT(E7, STEALTH_AXIS_E);
+  #endif
 
   #if USE_SENSORLESS
     #if X_SENSORLESS

commit 0fcf2b1110d9f0d362e5aab9cc73d963710e9865
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jan 20 00:35:07 2020 -0500

    Quad Z stepper support (#16277)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 24e3d8cce3..bdb6f20377 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -88,6 +88,9 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 #if AXIS_HAS_SPI(Z3)
   TMC_SPI_DEFINE(Z3, Z);
 #endif
+#if AXIS_HAS_SPI(Z4)
+  TMC_SPI_DEFINE(Z4, Z);
+#endif
 #if AXIS_HAS_SPI(E0)
   TMC_SPI_DEFINE_E(0);
 #endif
@@ -249,6 +252,13 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
       TMC_UART_DEFINE(SW, Z3, Z);
     #endif
   #endif
+  #if AXIS_HAS_UART(Z4)
+    #ifdef Z4_HARDWARE_SERIAL
+      TMC_UART_DEFINE(HW, Z4, Z);
+    #else
+      TMC_UART_DEFINE(SW, Z4, Z);
+    #endif
+  #endif
   #if AXIS_HAS_UART(E0)
     #ifdef E0_HARDWARE_SERIAL
       TMC_UART_DEFINE_E(HW, 0);
@@ -342,6 +352,13 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
         stepperZ3.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
+    #if AXIS_HAS_UART(Z4)
+      #ifdef Z4_HARDWARE_SERIAL
+        Z4_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
+      #else
+        stepperZ4.beginSerial(TMC_BAUD_RATE);
+      #endif
+    #endif
     #if AXIS_HAS_UART(E0)
       #ifdef E0_HARDWARE_SERIAL
         E0_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
@@ -616,6 +633,9 @@ void restore_trinamic_drivers() {
   #if AXIS_IS_TMC(Z3)
     stepperZ3.push();
   #endif
+  #if AXIS_IS_TMC(Z4)
+    stepperZ4.push();
+  #endif
   #if AXIS_IS_TMC(E0)
     stepperE0.push();
   #endif
@@ -678,6 +698,9 @@ void reset_trinamic_drivers() {
   #if AXIS_IS_TMC(Z3)
     _TMC_INIT(Z3, STEALTH_AXIS_Z);
   #endif
+  #if AXIS_IS_TMC(Z4)
+    _TMC_INIT(Z4, STEALTH_AXIS_Z);
+  #endif
   #if AXIS_IS_TMC(E0)
     _TMC_INIT(E0, STEALTH_AXIS_E);
   #endif
@@ -727,6 +750,9 @@ void reset_trinamic_drivers() {
       #if AXIS_HAS_STALLGUARD(Z3)
         stepperZ3.homing_threshold(Z_STALL_SENSITIVITY);
       #endif
+      #if AXIS_HAS_STALLGUARD(Z4)
+        stepperZ4.homing_threshold(Z_STALL_SENSITIVITY);
+      #endif
     #endif
   #endif
 

commit 814a2eaf8f5d1ab950654b26e762c9a2c7b246f6
Author: Jason Smith <jason.inet@gmail.com>
Date:   Wed Nov 6 15:08:12 2019 -0800

    Allow TMC baud rate override (#15773)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index 08a13c17aa..24e3d8cce3 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -107,6 +107,10 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
   TMC_SPI_DEFINE_E(5);
 #endif
 
+#ifndef TMC_BAUD_RATE
+  #define TMC_BAUD_RATE 115200
+#endif
+
 #if HAS_DRIVER(TMC2130)
   template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
   void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
@@ -291,93 +295,93 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
   void tmc_serial_begin() {
     #if AXIS_HAS_UART(X)
       #ifdef X_HARDWARE_SERIAL
-        X_HARDWARE_SERIAL.begin(115200);
+        X_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
       #else
-        stepperX.beginSerial(115200);
+        stepperX.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(X2)
       #ifdef X2_HARDWARE_SERIAL
-        X2_HARDWARE_SERIAL.begin(115200);
+        X2_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
       #else
-        stepperX2.beginSerial(115200);
+        stepperX2.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Y)
       #ifdef Y_HARDWARE_SERIAL
-        Y_HARDWARE_SERIAL.begin(115200);
+        Y_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
       #else
-        stepperY.beginSerial(115200);
+        stepperY.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Y2)
       #ifdef Y2_HARDWARE_SERIAL
-        Y2_HARDWARE_SERIAL.begin(115200);
+        Y2_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
       #else
-        stepperY2.beginSerial(115200);
+        stepperY2.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Z)
       #ifdef Z_HARDWARE_SERIAL
-        Z_HARDWARE_SERIAL.begin(115200);
+        Z_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
       #else
-        stepperZ.beginSerial(115200);
+        stepperZ.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Z2)
       #ifdef Z2_HARDWARE_SERIAL
-        Z2_HARDWARE_SERIAL.begin(115200);
+        Z2_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
       #else
-        stepperZ2.beginSerial(115200);
+        stepperZ2.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(Z3)
       #ifdef Z3_HARDWARE_SERIAL
-        Z3_HARDWARE_SERIAL.begin(115200);
+        Z3_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
       #else
-        stepperZ3.beginSerial(115200);
+        stepperZ3.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E0)
       #ifdef E0_HARDWARE_SERIAL
-        E0_HARDWARE_SERIAL.begin(115200);
+        E0_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
       #else
-        stepperE0.beginSerial(115200);
+        stepperE0.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E1)
       #ifdef E1_HARDWARE_SERIAL
-        E1_HARDWARE_SERIAL.begin(115200);
+        E1_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
       #else
-        stepperE1.beginSerial(115200);
+        stepperE1.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E2)
       #ifdef E2_HARDWARE_SERIAL
-        E2_HARDWARE_SERIAL.begin(115200);
+        E2_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
       #else
-        stepperE2.beginSerial(115200);
+        stepperE2.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E3)
       #ifdef E3_HARDWARE_SERIAL
-        E3_HARDWARE_SERIAL.begin(115200);
+        E3_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
       #else
-        stepperE3.beginSerial(115200);
+        stepperE3.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E4)
       #ifdef E4_HARDWARE_SERIAL
-        E4_HARDWARE_SERIAL.begin(115200);
+        E4_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
       #else
-        stepperE4.beginSerial(115200);
+        stepperE4.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
     #if AXIS_HAS_UART(E5)
       #ifdef E5_HARDWARE_SERIAL
-        E5_HARDWARE_SERIAL.begin(115200);
+        E5_HARDWARE_SERIAL.begin(TMC_BAUD_RATE);
       #else
-        stepperE5.beginSerial(115200);
+        stepperE5.beginSerial(TMC_BAUD_RATE);
       #endif
     #endif
   }

commit 178dcd6fd8ce1d2eea0cbb79b7f384e48b5ed6e5
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Sun Sep 29 05:47:20 2019 -0500

    SPI chaining with TMCStepper simplified interface (#15179)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
index a0910204e6..08a13c17aa 100644
--- a/Marlin/src/module/stepper/trinamic.cpp
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -44,9 +44,9 @@ enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
 //   AI = Axis Enum Index
 // SWHW = SW/SH UART selection
 #if ENABLED(TMC_USE_SW_SPI)
-  #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, ST##_RSENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
+  #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, ST##_RSENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK, ST##_CHAIN_POS)
 #else
-  #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, ST##_RSENSE)
+  #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, ST##_RSENSE, ST##_CHAIN_POS)
 #endif
 
 #define TMC_UART_HW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(&ST##_HARDWARE_SERIAL, ST##_RSENSE, ST##_SLAVE_ADDRESS)
@@ -653,93 +653,6 @@ void reset_trinamic_drivers() {
     #endif
   };
 
-  #if TMC_USE_CHAIN
-
-    enum TMC_axis_enum : unsigned char { _, X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5 };
-    #define __TMC_CHAIN(Q,V) do{ stepper##Q.set_chain_info(Q,V); }while(0)
-    #define _TMC_CHAIN(Q) __TMC_CHAIN(Q, Q##_CHAIN_POS)
-
-    #if AXIS_HAS_SPI(X)                  // First set chain array to uninitialized
-      __TMC_CHAIN(X, 0);
-    #endif
-    #if AXIS_HAS_SPI(X2)
-      __TMC_CHAIN(X2, 0);
-    #endif
-    #if AXIS_HAS_SPI(Y)
-      __TMC_CHAIN(Y, 0);
-    #endif
-    #if AXIS_HAS_SPI(Y2)
-      __TMC_CHAIN(Y2, 0);
-    #endif
-    #if AXIS_HAS_SPI(Z)
-      __TMC_CHAIN(Z, 0);
-    #endif
-    #if AXIS_HAS_SPI(Z2)
-      __TMC_CHAIN(Z2, 0);
-    #endif
-    #if AXIS_HAS_SPI(Z3)
-      __TMC_CHAIN(Z3, 0);
-    #endif
-    #if AXIS_HAS_SPI(E0)
-      __TMC_CHAIN(E0, 0);
-    #endif
-    #if AXIS_HAS_SPI(E1)
-      __TMC_CHAIN(E1, 0);
-    #endif
-    #if AXIS_HAS_SPI(E2)
-      __TMC_CHAIN(E2, 0);
-    #endif
-    #if AXIS_HAS_SPI(E3)
-      __TMC_CHAIN(E3, 0);
-    #endif
-    #if AXIS_HAS_SPI(E4)
-      __TMC_CHAIN(E4, 0);
-    #endif
-    #if AXIS_HAS_SPI(E5)
-      __TMC_CHAIN(E5, 0);
-    #endif
-
-    #if AXIS_HAS_SPI(X) && X_CHAIN_POS             // Now set up the SPI chain
-      _TMC_CHAIN(X);
-    #endif
-    #if AXIS_HAS_SPI(X2) && X2_CHAIN_POS
-      _TMC_CHAIN(X2);
-    #endif
-    #if AXIS_HAS_SPI(Y) && Y_CHAIN_POS
-      _TMC_CHAIN(Y);
-    #endif
-    #if AXIS_HAS_SPI(Y2) && Y2_CHAIN_POS
-      _TMC_CHAIN(Y2);
-    #endif
-    #if AXIS_HAS_SPI(Z) && Z_CHAIN_POS
-      _TMC_CHAIN(Z);
-    #endif
-    #if AXIS_HAS_SPI(Z2) && Z2_CHAIN_POS
-      _TMC_CHAIN(Z2);
-    #endif
-    #if AXIS_HAS_SPI(Z3) && Z3_CHAIN_POS
-      _TMC_CHAIN(Z3);
-    #endif
-    #if AXIS_HAS_SPI(E0) && E0_CHAIN_POS
-      _TMC_CHAIN(E0);
-    #endif
-    #if AXIS_HAS_SPI(E1) && E1_CHAIN_POS
-      _TMC_CHAIN(E1);
-    #endif
-    #if AXIS_HAS_SPI(E2) && E2_CHAIN_POS
-      _TMC_CHAIN(E2);
-    #endif
-    #if AXIS_HAS_SPI(E3) && E3_CHAIN_POS
-      _TMC_CHAIN(E3);
-    #endif
-    #if AXIS_HAS_SPI(E4) && E4_CHAIN_POS
-      _TMC_CHAIN(E4);
-    #endif
-    #if AXIS_HAS_SPI(E5) && E5_CHAIN_POS
-      _TMC_CHAIN(E5);
-    #endif
-  #endif // TMC_USE_CHAIN
-
   #if AXIS_IS_TMC(X)
     _TMC_INIT(X, STEALTH_AXIS_XY);
   #endif

commit 586b334c2ab61240607e878390ed1d53af86da69
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 31 19:44:45 2019 -0500

    Split up stepper indirection (#15111)

diff --git a/Marlin/src/module/stepper/trinamic.cpp b/Marlin/src/module/stepper/trinamic.cpp
new file mode 100644
index 0000000000..a0910204e6
--- /dev/null
+++ b/Marlin/src/module/stepper/trinamic.cpp
@@ -0,0 +1,823 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * stepper/trinamic.cpp
+ * Stepper driver indirection for Trinamic
+ */
+
+#include "../../inc/MarlinConfig.h"
+
+#if HAS_TRINAMIC
+
+#include "trinamic.h"
+#include "../stepper.h"
+
+#include <HardwareSerial.h>
+#include <SPI.h>
+
+enum StealthIndex : uint8_t { STEALTH_AXIS_XY, STEALTH_AXIS_Z, STEALTH_AXIS_E };
+#define _TMC_INIT(ST, STEALTH_INDEX) tmc_init(stepper##ST, ST##_CURRENT, ST##_MICROSTEPS, ST##_HYBRID_THRESHOLD, stealthchop_by_axis[STEALTH_INDEX])
+
+//   IC = TMC model number
+//   ST = Stepper object letter
+//   L  = Label characters
+//   AI = Axis Enum Index
+// SWHW = SW/SH UART selection
+#if ENABLED(TMC_USE_SW_SPI)
+  #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, ST##_RSENSE, TMC_SW_MOSI, TMC_SW_MISO, TMC_SW_SCK)
+#else
+  #define __TMC_SPI_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_CS_PIN, ST##_RSENSE)
+#endif
+
+#define TMC_UART_HW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(&ST##_HARDWARE_SERIAL, ST##_RSENSE, ST##_SLAVE_ADDRESS)
+#define TMC_UART_SW_DEFINE(IC, ST, L, AI) TMCMarlin<IC##Stepper, L, AI> stepper##ST(ST##_SERIAL_RX_PIN, ST##_SERIAL_TX_PIN, ST##_RSENSE, ST##_SLAVE_ADDRESS, ST##_SERIAL_RX_PIN > -1)
+
+#define _TMC_SPI_DEFINE(IC, ST, AI) __TMC_SPI_DEFINE(IC, ST, TMC_##ST##_LABEL, AI)
+#define TMC_SPI_DEFINE(ST, AI) _TMC_SPI_DEFINE(ST##_DRIVER_TYPE, ST, AI##_AXIS)
+
+#define _TMC_UART_DEFINE(SWHW, IC, ST, AI) TMC_UART_##SWHW##_DEFINE(IC, ST, TMC_##ST##_LABEL, AI)
+#define TMC_UART_DEFINE(SWHW, ST, AI) _TMC_UART_DEFINE(SWHW, ST##_DRIVER_TYPE, ST, AI##_AXIS)
+
+#if ENABLED(DISTINCT_E_FACTORS) && E_STEPPERS > 1
+  #define TMC_SPI_DEFINE_E(AI) TMC_SPI_DEFINE(E##AI, E##AI)
+  #define TMC_UART_DEFINE_E(SWHW, AI) TMC_UART_DEFINE(SWHW, E##AI, E##AI)
+#else
+  #define TMC_SPI_DEFINE_E(AI) TMC_SPI_DEFINE(E##AI, E)
+  #define TMC_UART_DEFINE_E(SWHW, AI) TMC_UART_DEFINE(SWHW, E##AI, E)
+#endif
+
+// Stepper objects of TMC2130/TMC2160/TMC2660/TMC5130/TMC5160 steppers used
+#if AXIS_HAS_SPI(X)
+  TMC_SPI_DEFINE(X, X);
+#endif
+#if AXIS_HAS_SPI(X2)
+  TMC_SPI_DEFINE(X2, X);
+#endif
+#if AXIS_HAS_SPI(Y)
+  TMC_SPI_DEFINE(Y, Y);
+#endif
+#if AXIS_HAS_SPI(Y2)
+  TMC_SPI_DEFINE(Y2, Y);
+#endif
+#if AXIS_HAS_SPI(Z)
+  TMC_SPI_DEFINE(Z, Z);
+#endif
+#if AXIS_HAS_SPI(Z2)
+  TMC_SPI_DEFINE(Z2, Z);
+#endif
+#if AXIS_HAS_SPI(Z3)
+  TMC_SPI_DEFINE(Z3, Z);
+#endif
+#if AXIS_HAS_SPI(E0)
+  TMC_SPI_DEFINE_E(0);
+#endif
+#if AXIS_HAS_SPI(E1)
+  TMC_SPI_DEFINE_E(1);
+#endif
+#if AXIS_HAS_SPI(E2)
+  TMC_SPI_DEFINE_E(2);
+#endif
+#if AXIS_HAS_SPI(E3)
+  TMC_SPI_DEFINE_E(3);
+#endif
+#if AXIS_HAS_SPI(E4)
+  TMC_SPI_DEFINE_E(4);
+#endif
+#if AXIS_HAS_SPI(E5)
+  TMC_SPI_DEFINE_E(5);
+#endif
+
+#if HAS_DRIVER(TMC2130)
+  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+  void tmc_init(TMCMarlin<TMC2130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
+    st.begin();
+
+    CHOPCONF_t chopconf{0};
+    chopconf.tbl = 1;
+    chopconf.toff = chopper_timing.toff;
+    chopconf.intpol = INTERPOLATE;
+    chopconf.hend = chopper_timing.hend + 3;
+    chopconf.hstrt = chopper_timing.hstrt - 1;
+    #if ENABLED(SQUARE_WAVE_STEPPING)
+      chopconf.dedge = true;
+    #endif
+    st.CHOPCONF(chopconf.sr);
+
+    st.rms_current(mA, HOLD_MULTIPLIER);
+    st.microsteps(microsteps);
+    st.iholddelay(10);
+    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
+
+    st.en_pwm_mode(stealth);
+    st.stored.stealthChop_enabled = stealth;
+
+    PWMCONF_t pwmconf{0};
+    pwmconf.pwm_freq = 0b01; // f_pwm = 2/683 f_clk
+    pwmconf.pwm_autoscale = true;
+    pwmconf.pwm_grad = 5;
+    pwmconf.pwm_ampl = 180;
+    st.PWMCONF(pwmconf.sr);
+
+    #if ENABLED(HYBRID_THRESHOLD)
+      st.set_pwm_thrs(thrs);
+    #else
+      UNUSED(thrs);
+    #endif
+
+    st.GSTAT(); // Clear GSTAT
+  }
+#endif // TMC2130
+
+#if HAS_DRIVER(TMC2160)
+  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+  void tmc_init(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
+    st.begin();
+
+    CHOPCONF_t chopconf{0};
+    chopconf.tbl = 1;
+    chopconf.toff = chopper_timing.toff;
+    chopconf.intpol = INTERPOLATE;
+    chopconf.hend = chopper_timing.hend + 3;
+    chopconf.hstrt = chopper_timing.hstrt - 1;
+    #if ENABLED(SQUARE_WAVE_STEPPING)
+      chopconf.dedge = true;
+    #endif
+    st.CHOPCONF(chopconf.sr);
+
+    st.rms_current(mA, HOLD_MULTIPLIER);
+    st.microsteps(microsteps);
+    st.iholddelay(10);
+    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
+
+    st.en_pwm_mode(stealth);
+    st.stored.stealthChop_enabled = stealth;
+
+    TMC2160_n::PWMCONF_t pwmconf{0};
+    pwmconf.pwm_lim = 12;
+    pwmconf.pwm_reg = 8;
+    pwmconf.pwm_autograd = true;
+    pwmconf.pwm_autoscale = true;
+    pwmconf.pwm_freq = 0b01;
+    pwmconf.pwm_grad = 14;
+    pwmconf.pwm_ofs = 36;
+    st.PWMCONF(pwmconf.sr);
+
+    #if ENABLED(HYBRID_THRESHOLD)
+      st.set_pwm_thrs(thrs);
+    #else
+      UNUSED(thrs);
+    #endif
+
+    st.GSTAT(); // Clear GSTAT
+  }
+#endif // TMC2160
+
+//
+// TMC2208/2209 Driver objects and inits
+//
+#if HAS_TMC220x
+  #if AXIS_HAS_UART(X)
+    #ifdef X_HARDWARE_SERIAL
+      TMC_UART_DEFINE(HW, X, X);
+    #else
+      TMC_UART_DEFINE(SW, X, X);
+    #endif
+  #endif
+  #if AXIS_HAS_UART(X2)
+    #ifdef X2_HARDWARE_SERIAL
+      TMC_UART_DEFINE(HW, X2, X);
+    #else
+      TMC_UART_DEFINE(SW, X2, X);
+    #endif
+  #endif
+  #if AXIS_HAS_UART(Y)
+    #ifdef Y_HARDWARE_SERIAL
+      TMC_UART_DEFINE(HW, Y, Y);
+    #else
+      TMC_UART_DEFINE(SW, Y, Y);
+    #endif
+  #endif
+  #if AXIS_HAS_UART(Y2)
+    #ifdef Y2_HARDWARE_SERIAL
+      TMC_UART_DEFINE(HW, Y2, Y);
+    #else
+      TMC_UART_DEFINE(SW, Y2, Y);
+    #endif
+  #endif
+  #if AXIS_HAS_UART(Z)
+    #ifdef Z_HARDWARE_SERIAL
+      TMC_UART_DEFINE(HW, Z, Z);
+    #else
+      TMC_UART_DEFINE(SW, Z, Z);
+    #endif
+  #endif
+  #if AXIS_HAS_UART(Z2)
+    #ifdef Z2_HARDWARE_SERIAL
+      TMC_UART_DEFINE(HW, Z2, Z);
+    #else
+      TMC_UART_DEFINE(SW, Z2, Z);
+    #endif
+  #endif
+  #if AXIS_HAS_UART(Z3)
+    #ifdef Z3_HARDWARE_SERIAL
+      TMC_UART_DEFINE(HW, Z3, Z);
+    #else
+      TMC_UART_DEFINE(SW, Z3, Z);
+    #endif
+  #endif
+  #if AXIS_HAS_UART(E0)
+    #ifdef E0_HARDWARE_SERIAL
+      TMC_UART_DEFINE_E(HW, 0);
+    #else
+      TMC_UART_DEFINE_E(SW, 0);
+    #endif
+  #endif
+  #if AXIS_HAS_UART(E1)
+    #ifdef E1_HARDWARE_SERIAL
+      TMC_UART_DEFINE_E(HW, 1);
+    #else
+      TMC_UART_DEFINE_E(SW, 1);
+    #endif
+  #endif
+  #if AXIS_HAS_UART(E2)
+    #ifdef E2_HARDWARE_SERIAL
+      TMC_UART_DEFINE_E(HW, 2);
+    #else
+      TMC_UART_DEFINE_E(SW, 2);
+    #endif
+  #endif
+  #if AXIS_HAS_UART(E3)
+    #ifdef E3_HARDWARE_SERIAL
+      TMC_UART_DEFINE_E(HW, 3);
+    #else
+      TMC_UART_DEFINE_E(SW, 3);
+    #endif
+  #endif
+  #if AXIS_HAS_UART(E4)
+    #ifdef E4_HARDWARE_SERIAL
+      TMC_UART_DEFINE_E(HW, 4);
+    #else
+      TMC_UART_DEFINE_E(SW, 4);
+    #endif
+  #endif
+  #if AXIS_HAS_UART(E5)
+    #ifdef E5_HARDWARE_SERIAL
+      TMC_UART_DEFINE_E(HW, 5);
+    #else
+      TMC_UART_DEFINE_E(SW, 5);
+    #endif
+  #endif
+
+  void tmc_serial_begin() {
+    #if AXIS_HAS_UART(X)
+      #ifdef X_HARDWARE_SERIAL
+        X_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperX.beginSerial(115200);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(X2)
+      #ifdef X2_HARDWARE_SERIAL
+        X2_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperX2.beginSerial(115200);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(Y)
+      #ifdef Y_HARDWARE_SERIAL
+        Y_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperY.beginSerial(115200);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(Y2)
+      #ifdef Y2_HARDWARE_SERIAL
+        Y2_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperY2.beginSerial(115200);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(Z)
+      #ifdef Z_HARDWARE_SERIAL
+        Z_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperZ.beginSerial(115200);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(Z2)
+      #ifdef Z2_HARDWARE_SERIAL
+        Z2_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperZ2.beginSerial(115200);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(Z3)
+      #ifdef Z3_HARDWARE_SERIAL
+        Z3_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperZ3.beginSerial(115200);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(E0)
+      #ifdef E0_HARDWARE_SERIAL
+        E0_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperE0.beginSerial(115200);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(E1)
+      #ifdef E1_HARDWARE_SERIAL
+        E1_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperE1.beginSerial(115200);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(E2)
+      #ifdef E2_HARDWARE_SERIAL
+        E2_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperE2.beginSerial(115200);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(E3)
+      #ifdef E3_HARDWARE_SERIAL
+        E3_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperE3.beginSerial(115200);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(E4)
+      #ifdef E4_HARDWARE_SERIAL
+        E4_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperE4.beginSerial(115200);
+      #endif
+    #endif
+    #if AXIS_HAS_UART(E5)
+      #ifdef E5_HARDWARE_SERIAL
+        E5_HARDWARE_SERIAL.begin(115200);
+      #else
+        stepperE5.beginSerial(115200);
+      #endif
+    #endif
+  }
+#endif
+
+#if HAS_DRIVER(TMC2208)
+  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+  void tmc_init(TMCMarlin<TMC2208Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
+    TMC2208_n::GCONF_t gconf{0};
+    gconf.pdn_disable = true; // Use UART
+    gconf.mstep_reg_select = true; // Select microsteps with UART
+    gconf.i_scale_analog = false;
+    gconf.en_spreadcycle = !stealth;
+    st.GCONF(gconf.sr);
+    st.stored.stealthChop_enabled = stealth;
+
+    TMC2208_n::CHOPCONF_t chopconf{0};
+    chopconf.tbl = 0b01; // blank_time = 24
+    chopconf.toff = chopper_timing.toff;
+    chopconf.intpol = INTERPOLATE;
+    chopconf.hend = chopper_timing.hend + 3;
+    chopconf.hstrt = chopper_timing.hstrt - 1;
+    #if ENABLED(SQUARE_WAVE_STEPPING)
+      chopconf.dedge = true;
+    #endif
+    st.CHOPCONF(chopconf.sr);
+
+    st.rms_current(mA, HOLD_MULTIPLIER);
+    st.microsteps(microsteps);
+    st.iholddelay(10);
+    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
+
+    TMC2208_n::PWMCONF_t pwmconf{0};
+    pwmconf.pwm_lim = 12;
+    pwmconf.pwm_reg = 8;
+    pwmconf.pwm_autograd = true;
+    pwmconf.pwm_autoscale = true;
+    pwmconf.pwm_freq = 0b01;
+    pwmconf.pwm_grad = 14;
+    pwmconf.pwm_ofs = 36;
+    st.PWMCONF(pwmconf.sr);
+
+    #if ENABLED(HYBRID_THRESHOLD)
+      st.set_pwm_thrs(thrs);
+    #else
+      UNUSED(thrs);
+    #endif
+
+    st.GSTAT(0b111); // Clear
+    delay(200);
+  }
+#endif // TMC2208
+
+#if HAS_DRIVER(TMC2209)
+  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+  void tmc_init(TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
+    TMC2208_n::GCONF_t gconf{0};
+    gconf.pdn_disable = true; // Use UART
+    gconf.mstep_reg_select = true; // Select microsteps with UART
+    gconf.i_scale_analog = false;
+    gconf.en_spreadcycle = !stealth;
+    st.GCONF(gconf.sr);
+    st.stored.stealthChop_enabled = stealth;
+
+    TMC2208_n::CHOPCONF_t chopconf{0};
+    chopconf.tbl = 0b01; // blank_time = 24
+    chopconf.toff = chopper_timing.toff;
+    chopconf.intpol = INTERPOLATE;
+    chopconf.hend = chopper_timing.hend + 3;
+    chopconf.hstrt = chopper_timing.hstrt - 1;
+    #if ENABLED(SQUARE_WAVE_STEPPING)
+      chopconf.dedge = true;
+    #endif
+    st.CHOPCONF(chopconf.sr);
+
+    st.rms_current(mA, HOLD_MULTIPLIER);
+    st.microsteps(microsteps);
+    st.iholddelay(10);
+    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
+
+    TMC2208_n::PWMCONF_t pwmconf{0};
+    pwmconf.pwm_lim = 12;
+    pwmconf.pwm_reg = 8;
+    pwmconf.pwm_autograd = true;
+    pwmconf.pwm_autoscale = true;
+    pwmconf.pwm_freq = 0b01;
+    pwmconf.pwm_grad = 14;
+    pwmconf.pwm_ofs = 36;
+    st.PWMCONF(pwmconf.sr);
+
+    #if ENABLED(HYBRID_THRESHOLD)
+      st.set_pwm_thrs(thrs);
+    #else
+      UNUSED(thrs);
+    #endif
+
+    st.GSTAT(0b111); // Clear
+    delay(200);
+  }
+#endif // TMC2209
+
+#if HAS_DRIVER(TMC2660)
+  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+  void tmc_init(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t, const bool) {
+    st.begin();
+
+    TMC2660_n::CHOPCONF_t chopconf{0};
+    chopconf.tbl = 1;
+    chopconf.toff = chopper_timing.toff;
+    chopconf.hend = chopper_timing.hend + 3;
+    chopconf.hstrt = chopper_timing.hstrt - 1;
+    st.CHOPCONF(chopconf.sr);
+
+    st.sdoff(0);
+    st.rms_current(mA);
+    st.microsteps(microsteps);
+    #if ENABLED(SQUARE_WAVE_STEPPING)
+      st.dedge(true);
+    #endif
+    st.intpol(INTERPOLATE);
+    st.diss2g(true); // Disable short to ground protection. Too many false readings?
+
+    #if ENABLED(TMC_DEBUG)
+      st.rdsel(0b01);
+    #endif
+  }
+#endif // TMC2660
+
+#if HAS_DRIVER(TMC5130)
+  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+  void tmc_init(TMCMarlin<TMC5130Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
+    st.begin();
+
+    CHOPCONF_t chopconf{0};
+    chopconf.tbl = 1;
+    chopconf.toff = chopper_timing.toff;
+    chopconf.intpol = INTERPOLATE;
+    chopconf.hend = chopper_timing.hend + 3;
+    chopconf.hstrt = chopper_timing.hstrt - 1;
+    #if ENABLED(SQUARE_WAVE_STEPPING)
+      chopconf.dedge = true;
+    #endif
+    st.CHOPCONF(chopconf.sr);
+
+    st.rms_current(mA, HOLD_MULTIPLIER);
+    st.microsteps(microsteps);
+    st.iholddelay(10);
+    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
+
+    st.en_pwm_mode(stealth);
+    st.stored.stealthChop_enabled = stealth;
+
+    PWMCONF_t pwmconf{0};
+    pwmconf.pwm_freq = 0b01; // f_pwm = 2/683 f_clk
+    pwmconf.pwm_autoscale = true;
+    pwmconf.pwm_grad = 5;
+    pwmconf.pwm_ampl = 180;
+    st.PWMCONF(pwmconf.sr);
+
+    #if ENABLED(HYBRID_THRESHOLD)
+      st.set_pwm_thrs(thrs);
+    #else
+      UNUSED(thrs);
+    #endif
+
+    st.GSTAT(); // Clear GSTAT
+  }
+#endif // TMC5130
+
+#if HAS_DRIVER(TMC5160)
+  template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+  void tmc_init(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const uint16_t mA, const uint16_t microsteps, const uint32_t thrs, const bool stealth) {
+    st.begin();
+
+    CHOPCONF_t chopconf{0};
+    chopconf.tbl = 1;
+    chopconf.toff = chopper_timing.toff;
+    chopconf.intpol = INTERPOLATE;
+    chopconf.hend = chopper_timing.hend + 3;
+    chopconf.hstrt = chopper_timing.hstrt - 1;
+    #if ENABLED(SQUARE_WAVE_STEPPING)
+      chopconf.dedge = true;
+    #endif
+    st.CHOPCONF(chopconf.sr);
+
+    st.rms_current(mA, HOLD_MULTIPLIER);
+    st.microsteps(microsteps);
+    st.iholddelay(10);
+    st.TPOWERDOWN(128); // ~2s until driver lowers to hold current
+
+    st.en_pwm_mode(stealth);
+    st.stored.stealthChop_enabled = stealth;
+
+    TMC2160_n::PWMCONF_t pwmconf{0};
+    pwmconf.pwm_lim = 12;
+    pwmconf.pwm_reg = 8;
+    pwmconf.pwm_autograd = true;
+    pwmconf.pwm_autoscale = true;
+    pwmconf.pwm_freq = 0b01;
+    pwmconf.pwm_grad = 14;
+    pwmconf.pwm_ofs = 36;
+    st.PWMCONF(pwmconf.sr);
+
+    #if ENABLED(HYBRID_THRESHOLD)
+      st.set_pwm_thrs(thrs);
+    #else
+      UNUSED(thrs);
+    #endif
+    st.GSTAT(); // Clear GSTAT
+  }
+#endif // TMC5160
+
+void restore_trinamic_drivers() {
+  #if AXIS_IS_TMC(X)
+    stepperX.push();
+  #endif
+  #if AXIS_IS_TMC(X2)
+    stepperX2.push();
+  #endif
+  #if AXIS_IS_TMC(Y)
+    stepperY.push();
+  #endif
+  #if AXIS_IS_TMC(Y2)
+    stepperY2.push();
+  #endif
+  #if AXIS_IS_TMC(Z)
+    stepperZ.push();
+  #endif
+  #if AXIS_IS_TMC(Z2)
+    stepperZ2.push();
+  #endif
+  #if AXIS_IS_TMC(Z3)
+    stepperZ3.push();
+  #endif
+  #if AXIS_IS_TMC(E0)
+    stepperE0.push();
+  #endif
+  #if AXIS_IS_TMC(E1)
+    stepperE1.push();
+  #endif
+  #if AXIS_IS_TMC(E2)
+    stepperE2.push();
+  #endif
+  #if AXIS_IS_TMC(E3)
+    stepperE3.push();
+  #endif
+  #if AXIS_IS_TMC(E4)
+    stepperE4.push();
+  #endif
+  #if AXIS_IS_TMC(E5)
+    stepperE5.push();
+  #endif
+}
+
+void reset_trinamic_drivers() {
+  static constexpr bool stealthchop_by_axis[] = {
+    #if ENABLED(STEALTHCHOP_XY)
+      true
+    #else
+      false
+    #endif
+    ,
+    #if ENABLED(STEALTHCHOP_Z)
+      true
+    #else
+      false
+    #endif
+    ,
+    #if ENABLED(STEALTHCHOP_E)
+      true
+    #else
+      false
+    #endif
+  };
+
+  #if TMC_USE_CHAIN
+
+    enum TMC_axis_enum : unsigned char { _, X, Y, Z, X2, Y2, Z2, Z3, E0, E1, E2, E3, E4, E5 };
+    #define __TMC_CHAIN(Q,V) do{ stepper##Q.set_chain_info(Q,V); }while(0)
+    #define _TMC_CHAIN(Q) __TMC_CHAIN(Q, Q##_CHAIN_POS)
+
+    #if AXIS_HAS_SPI(X)                  // First set chain array to uninitialized
+      __TMC_CHAIN(X, 0);
+    #endif
+    #if AXIS_HAS_SPI(X2)
+      __TMC_CHAIN(X2, 0);
+    #endif
+    #if AXIS_HAS_SPI(Y)
+      __TMC_CHAIN(Y, 0);
+    #endif
+    #if AXIS_HAS_SPI(Y2)
+      __TMC_CHAIN(Y2, 0);
+    #endif
+    #if AXIS_HAS_SPI(Z)
+      __TMC_CHAIN(Z, 0);
+    #endif
+    #if AXIS_HAS_SPI(Z2)
+      __TMC_CHAIN(Z2, 0);
+    #endif
+    #if AXIS_HAS_SPI(Z3)
+      __TMC_CHAIN(Z3, 0);
+    #endif
+    #if AXIS_HAS_SPI(E0)
+      __TMC_CHAIN(E0, 0);
+    #endif
+    #if AXIS_HAS_SPI(E1)
+      __TMC_CHAIN(E1, 0);
+    #endif
+    #if AXIS_HAS_SPI(E2)
+      __TMC_CHAIN(E2, 0);
+    #endif
+    #if AXIS_HAS_SPI(E3)
+      __TMC_CHAIN(E3, 0);
+    #endif
+    #if AXIS_HAS_SPI(E4)
+      __TMC_CHAIN(E4, 0);
+    #endif
+    #if AXIS_HAS_SPI(E5)
+      __TMC_CHAIN(E5, 0);
+    #endif
+
+    #if AXIS_HAS_SPI(X) && X_CHAIN_POS             // Now set up the SPI chain
+      _TMC_CHAIN(X);
+    #endif
+    #if AXIS_HAS_SPI(X2) && X2_CHAIN_POS
+      _TMC_CHAIN(X2);
+    #endif
+    #if AXIS_HAS_SPI(Y) && Y_CHAIN_POS
+      _TMC_CHAIN(Y);
+    #endif
+    #if AXIS_HAS_SPI(Y2) && Y2_CHAIN_POS
+      _TMC_CHAIN(Y2);
+    #endif
+    #if AXIS_HAS_SPI(Z) && Z_CHAIN_POS
+      _TMC_CHAIN(Z);
+    #endif
+    #if AXIS_HAS_SPI(Z2) && Z2_CHAIN_POS
+      _TMC_CHAIN(Z2);
+    #endif
+    #if AXIS_HAS_SPI(Z3) && Z3_CHAIN_POS
+      _TMC_CHAIN(Z3);
+    #endif
+    #if AXIS_HAS_SPI(E0) && E0_CHAIN_POS
+      _TMC_CHAIN(E0);
+    #endif
+    #if AXIS_HAS_SPI(E1) && E1_CHAIN_POS
+      _TMC_CHAIN(E1);
+    #endif
+    #if AXIS_HAS_SPI(E2) && E2_CHAIN_POS
+      _TMC_CHAIN(E2);
+    #endif
+    #if AXIS_HAS_SPI(E3) && E3_CHAIN_POS
+      _TMC_CHAIN(E3);
+    #endif
+    #if AXIS_HAS_SPI(E4) && E4_CHAIN_POS
+      _TMC_CHAIN(E4);
+    #endif
+    #if AXIS_HAS_SPI(E5) && E5_CHAIN_POS
+      _TMC_CHAIN(E5);
+    #endif
+  #endif // TMC_USE_CHAIN
+
+  #if AXIS_IS_TMC(X)
+    _TMC_INIT(X, STEALTH_AXIS_XY);
+  #endif
+  #if AXIS_IS_TMC(X2)
+    _TMC_INIT(X2, STEALTH_AXIS_XY);
+  #endif
+  #if AXIS_IS_TMC(Y)
+    _TMC_INIT(Y, STEALTH_AXIS_XY);
+  #endif
+  #if AXIS_IS_TMC(Y2)
+    _TMC_INIT(Y2, STEALTH_AXIS_XY);
+  #endif
+  #if AXIS_IS_TMC(Z)
+    _TMC_INIT(Z, STEALTH_AXIS_Z);
+  #endif
+  #if AXIS_IS_TMC(Z2)
+    _TMC_INIT(Z2, STEALTH_AXIS_Z);
+  #endif
+  #if AXIS_IS_TMC(Z3)
+    _TMC_INIT(Z3, STEALTH_AXIS_Z);
+  #endif
+  #if AXIS_IS_TMC(E0)
+    _TMC_INIT(E0, STEALTH_AXIS_E);
+  #endif
+  #if AXIS_IS_TMC(E1)
+    _TMC_INIT(E1, STEALTH_AXIS_E);
+  #endif
+  #if AXIS_IS_TMC(E2)
+    _TMC_INIT(E2, STEALTH_AXIS_E);
+  #endif
+  #if AXIS_IS_TMC(E3)
+    _TMC_INIT(E3, STEALTH_AXIS_E);
+  #endif
+  #if AXIS_IS_TMC(E4)
+    _TMC_INIT(E4, STEALTH_AXIS_E);
+  #endif
+  #if AXIS_IS_TMC(E5)
+    _TMC_INIT(E5, STEALTH_AXIS_E);
+  #endif
+
+  #if USE_SENSORLESS
+    #if X_SENSORLESS
+      #if AXIS_HAS_STALLGUARD(X)
+        stepperX.homing_threshold(X_STALL_SENSITIVITY);
+      #endif
+      #if AXIS_HAS_STALLGUARD(X2) && !X2_SENSORLESS
+        stepperX2.homing_threshold(X_STALL_SENSITIVITY);
+      #endif
+    #endif
+    #if X2_SENSORLESS
+      stepperX2.homing_threshold(X2_STALL_SENSITIVITY);
+    #endif
+    #if Y_SENSORLESS
+      #if AXIS_HAS_STALLGUARD(Y)
+        stepperY.homing_threshold(Y_STALL_SENSITIVITY);
+      #endif
+      #if AXIS_HAS_STALLGUARD(Y2)
+        stepperY2.homing_threshold(Y_STALL_SENSITIVITY);
+      #endif
+    #endif
+    #if Z_SENSORLESS
+      #if AXIS_HAS_STALLGUARD(Z)
+        stepperZ.homing_threshold(Z_STALL_SENSITIVITY);
+      #endif
+      #if AXIS_HAS_STALLGUARD(Z2)
+        stepperZ2.homing_threshold(Z_STALL_SENSITIVITY);
+      #endif
+      #if AXIS_HAS_STALLGUARD(Z3)
+        stepperZ3.homing_threshold(Z_STALL_SENSITIVITY);
+      #endif
+    #endif
+  #endif
+
+  #ifdef TMC_ADV
+    TMC_ADV()
+  #endif
+
+  stepper.set_directions();
+}
+
+#endif // HAS_TRINAMIC
