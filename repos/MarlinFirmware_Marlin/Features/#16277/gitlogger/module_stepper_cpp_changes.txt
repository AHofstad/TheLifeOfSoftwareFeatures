commit d9fc4f3a9937cdd366793a67444dbf5d15ecfd2d
Author: Vovodroid <vovodroid@users.noreply.github.com>
Date:   Mon Jun 10 21:42:28 2024 +0300

    🚸 Nonlinear Extrusion polynomial Av^2+Bv+C (#27162)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index ba4030f0d6..eed3973afa 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2234,7 +2234,7 @@ hal_timer_t Stepper::calc_timer_interval(uint32_t step_rate) {
 #if ENABLED(NONLINEAR_EXTRUSION)
   void Stepper::calc_nonlinear_e(uint32_t step_rate) {
     const uint32_t velocity = ne_scale * step_rate; // Scale step_rate first so all intermediate values stay in range of 8.24 fixed point math
-    int32_t vd = (((int64_t)ne_fix.A * velocity) >> 24) + (((((int64_t)ne_fix.B * velocity) >> 24) * velocity) >> 24);
+    int32_t vd =  (((((int64_t)ne_fix.A * velocity) >> 24) * velocity) >> 24) + (((int64_t)ne_fix.B * velocity) >> 24);
     NOLESS(vd, 0);
 
     advance_dividend.e = (uint64_t(ne_fix.C + vd) * ne_edividend) >> 24;

commit 65c19f82b9827604d1286823a655d9ecf106b6b3
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Thu Jun 6 05:26:09 2024 +0300

    🔧 Minimum Stepper Pulse in Nanoseconds (#27113)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 083d2019dc..ba4030f0d6 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -519,16 +519,15 @@ xyze_int8_t Stepper::count_direction{0};
   #define E_APPLY_DIR(FWD,Q) do{ if (FWD) { FWD_E_DIR(stepper_extruder); } else { REV_E_DIR(stepper_extruder); } }while(0)
 #endif
 
-#define CYCLES_TO_NS(CYC) (1000UL * (CYC) / ((F_CPU) / 1000000))
-#define NS_PER_PULSE_TIMER_TICK (1000000000UL / (STEPPER_TIMER_RATE))
+constexpr uint32_t cycles_to_ns(const uint32_t CYC) { return 1000UL * (CYC) / ((F_CPU) / 1000000); }
+constexpr uint32_t ns_per_pulse_timer_tick = 1000000000UL / (STEPPER_TIMER_RATE);
 
 // Round up when converting from ns to timer ticks
-#define NS_TO_PULSE_TIMER_TICKS(NS) (((NS) + (NS_PER_PULSE_TIMER_TICK) / 2) / (NS_PER_PULSE_TIMER_TICK))
+constexpr hal_timer_t ns_to_pulse_timer_ticks(const uint32_t ns) { return (ns + ns_per_pulse_timer_tick / 2) / ns_per_pulse_timer_tick; }
 
-#define TIMER_SETUP_NS (CYCLES_TO_NS(TIMER_READ_ADD_AND_STORE_CYCLES))
-
-#define PULSE_HIGH_TICK_COUNT hal_timer_t(NS_TO_PULSE_TIMER_TICKS(_MIN_PULSE_HIGH_NS - _MIN(_MIN_PULSE_HIGH_NS, TIMER_SETUP_NS)))
-#define PULSE_LOW_TICK_COUNT hal_timer_t(NS_TO_PULSE_TIMER_TICKS(_MIN_PULSE_LOW_NS - _MIN(_MIN_PULSE_LOW_NS, TIMER_SETUP_NS)))
+constexpr uint32_t timer_setup_ns = cycles_to_ns(timer_read_add_and_store_cycles);
+constexpr hal_timer_t PULSE_HIGH_TICK_COUNT = ns_to_pulse_timer_ticks(_min_pulse_high_ns - _MIN(_min_pulse_high_ns, timer_setup_ns));
+constexpr hal_timer_t PULSE_LOW_TICK_COUNT = ns_to_pulse_timer_ticks(_min_pulse_low_ns - _MIN(_min_pulse_low_ns, timer_setup_ns));
 
 #define USING_TIMED_PULSE() hal_timer_t start_pulse_count = 0
 #define START_TIMED_PULSE() (start_pulse_count = HAL_timer_get_count(MF_TIMER_PULSE))
@@ -1720,7 +1719,7 @@ void Stepper::isr() {
   #endif
 }
 
-#if MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE
+#if MINIMUM_STEPPER_PULSE_NS || MAXIMUM_STEPPER_RATE
   #define ISR_PULSE_CONTROL 1
 #endif
 #if ISR_PULSE_CONTROL && DISABLED(I2S_STEPPER_STREAM)
@@ -2080,7 +2079,7 @@ void Stepper::pulse_phase_isr() {
 
     TERN_(I2S_STEPPER_STREAM, i2s_push_sample());
 
-    // TODO: need to deal with MINIMUM_STEPPER_PULSE over i2s
+    // TODO: need to deal with MINIMUM_STEPPER_PULSE_NS over i2s
     #if ISR_MULTI_STEPS
       START_TIMED_PULSE();
       AWAIT_HIGH_PULSE();
@@ -2256,25 +2255,25 @@ hal_timer_t Stepper::calc_multistep_timer_interval(uint32_t step_rate) {
 
       // The stepping frequency limits for each multistepping rate
       static const uint32_t limit[] PROGMEM = {
-            (  MAX_STEP_ISR_FREQUENCY_1X     )
-          , (((F_CPU) / ISR_EXECUTION_CYCLES(1)) >> 1)
+            max_step_isr_frequency_sh(0)
+          , max_step_isr_frequency_sh(1)
         #if MULTISTEPPING_LIMIT >= 4
-          , (((F_CPU) / ISR_EXECUTION_CYCLES(2)) >> 2)
+          , max_step_isr_frequency_sh(2)
         #endif
         #if MULTISTEPPING_LIMIT >= 8
-          , (((F_CPU) / ISR_EXECUTION_CYCLES(3)) >> 3)
+          , max_step_isr_frequency_sh(3)
         #endif
         #if MULTISTEPPING_LIMIT >= 16
-          , (((F_CPU) / ISR_EXECUTION_CYCLES(4)) >> 4)
+          , max_step_isr_frequency_sh(4)
         #endif
         #if MULTISTEPPING_LIMIT >= 32
-          , (((F_CPU) / ISR_EXECUTION_CYCLES(5)) >> 5)
+          , max_step_isr_frequency_sh(5)
         #endif
         #if MULTISTEPPING_LIMIT >= 64
-          , (((F_CPU) / ISR_EXECUTION_CYCLES(6)) >> 6)
+          , max_step_isr_frequency_sh(6)
         #endif
         #if MULTISTEPPING_LIMIT >= 128
-          , (((F_CPU) / ISR_EXECUTION_CYCLES(7)) >> 7)
+          , max_step_isr_frequency_sh(7)
         #endif
       };
 
@@ -2702,9 +2701,9 @@ hal_timer_t Stepper::block_phase_isr() {
         // Decide if axis smoothing is possible
         if (stepper.adaptive_step_smoothing_enabled) {
           uint32_t max_rate = current_block->nominal_rate;  // Get the step event rate
-          while (max_rate < MIN_STEP_ISR_FREQUENCY) {       // As long as more ISRs are possible...
+          while (max_rate < min_step_isr_frequency) {       // As long as more ISRs are possible...
             max_rate <<= 1;                                 // Try to double the rate
-            if (max_rate < MIN_STEP_ISR_FREQUENCY)          // Don't exceed the estimated ISR limit
+            if (max_rate < min_step_isr_frequency)          // Don't exceed the estimated ISR limit
               ++oversampling_factor;                        // Increase the oversampling (used for left-shift)
           }
         }
@@ -3737,8 +3736,8 @@ void Stepper::report_positions() {
   #define _READ_DIR(AXIS) AXIS ##_DIR_READ()
   #define _APPLY_DIR(AXIS, FWD) AXIS ##_APPLY_DIR(FWD, true)
 
-  #if MINIMUM_STEPPER_PULSE
-    #define STEP_PULSE_CYCLES ((MINIMUM_STEPPER_PULSE) * CYCLES_PER_MICROSECOND)
+  #if MINIMUM_STEPPER_PULSE_NS
+    #define STEP_PULSE_CYCLES ((MINIMUM_STEPPER_PULSE_NS) * CYCLES_PER_MICROSECOND / 1000)
   #else
     #define STEP_PULSE_CYCLES 0
   #endif
@@ -3761,7 +3760,7 @@ void Stepper::report_positions() {
   #else
     #define _SAVE_START() NOOP
     #if EXTRA_CYCLES_BABYSTEP > 0
-      #define _PULSE_WAIT() DELAY_NS(EXTRA_CYCLES_BABYSTEP * NANOSECONDS_PER_CYCLE)
+      #define _PULSE_WAIT() DELAY_CYCLES(EXTRA_CYCLES_BABYSTEP)
     #elif ENABLED(DELTA)
       #define _PULSE_WAIT() DELAY_US(2);
     #elif STEP_PULSE_CYCLES > 0

commit 6b6865d068c2ebbcb6b56c965807571257d50828
Author: Jonathan Brazier <66009857+JonBr306@users.noreply.github.com>
Date:   Mon May 20 06:03:03 2024 +0100

    ✨ INPUT_SHAPING_Z (#27073)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c2674480d5..083d2019dc 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -281,20 +281,16 @@ uint32_t Stepper::advance_divisor = 0,
   shaping_echo_axis_t ShapingQueue::echo_axes[shaping_echoes];
   uint16_t            ShapingQueue::tail = 0;
 
-  #if ENABLED(INPUT_SHAPING_X)
-    shaping_time_t  ShapingQueue::delay_x;
-    shaping_time_t  ShapingQueue::peek_x_val = shaping_time_t(-1);
-    uint16_t        ShapingQueue::head_x = 0;
-    uint16_t        ShapingQueue::_free_count_x = shaping_echoes - 1;
-    ShapeParams     Stepper::shaping_x;
-  #endif
-  #if ENABLED(INPUT_SHAPING_Y)
-    shaping_time_t  ShapingQueue::delay_y;
-    shaping_time_t  ShapingQueue::peek_y_val = shaping_time_t(-1);
-    uint16_t        ShapingQueue::head_y = 0;
-    uint16_t        ShapingQueue::_free_count_y = shaping_echoes - 1;
-    ShapeParams     Stepper::shaping_y;
-  #endif
+  #define SHAPING_VAR_DEFS(AXIS)                                           \
+    shaping_time_t  ShapingQueue::delay_##AXIS;                            \
+    shaping_time_t  ShapingQueue::_peek_##AXIS = shaping_time_t(-1);       \
+    uint16_t        ShapingQueue::head_##AXIS = 0;                         \
+    uint16_t        ShapingQueue::_free_count_##AXIS = shaping_echoes - 1; \
+    ShapeParams     Stepper::shaping_##AXIS;
+
+  TERN_(INPUT_SHAPING_X, SHAPING_VAR_DEFS(x))
+  TERN_(INPUT_SHAPING_Y, SHAPING_VAR_DEFS(y))
+  TERN_(INPUT_SHAPING_Z, SHAPING_VAR_DEFS(z))
 #endif
 
 #if ENABLED(BABYSTEPPING)
@@ -1610,6 +1606,7 @@ void Stepper::isr() {
       interval = _MIN(nextMainISR, uint32_t(HAL_TIMER_TYPE_MAX));         // Time until the next Pulse / Block phase
       TERN_(INPUT_SHAPING_X, NOMORE(interval, ShapingQueue::peek_x()));   // Time until next input shaping echo for X
       TERN_(INPUT_SHAPING_Y, NOMORE(interval, ShapingQueue::peek_y()));   // Time until next input shaping echo for Y
+      TERN_(INPUT_SHAPING_Z, NOMORE(interval, ShapingQueue::peek_z()));   // Time until next input shaping echo for Z
       TERN_(LIN_ADVANCE, NOMORE(interval, nextAdvanceISR));               // Come back early for Linear Advance?
       TERN_(BABYSTEPPING, NOMORE(interval, nextBabystepISR));             // Come back early for Babystepping?
 
@@ -1754,6 +1751,10 @@ void Stepper::pulse_phase_isr() {
           shaping_y.delta_error = 0;
           shaping_y.last_block_end_pos = count_position.y;
         #endif
+        #if ENABLED(INPUT_SHAPING_Z)
+          shaping_z.delta_error = 0;
+          shaping_z.last_block_end_pos = count_position.z;
+        #endif
       #endif
     }
   }
@@ -1813,6 +1814,12 @@ void Stepper::pulse_phase_isr() {
     #else
       #define HYSTERESIS_Y 0
     #endif
+    #if AXIS_DRIVER_TYPE_Z(TMC2208) || AXIS_DRIVER_TYPE_Z(TMC2208_STANDALONE) || \
+        AXIS_DRIVER_TYPE_Z(TMC5160) || AXIS_DRIVER_TYPE_Z(TMC5160_STANDALONE)
+      #define HYSTERESIS_Z 64
+    #else
+      #define HYSTERESIS_Z 0
+    #endif
     #define _HYSTERESIS(AXIS) HYSTERESIS_##AXIS
     #define HYSTERESIS(AXIS) _HYSTERESIS(AXIS)
 
@@ -2005,9 +2012,10 @@ void Stepper::pulse_phase_isr() {
       #if HAS_ZV_SHAPING
         // record an echo if a step is needed in the primary bresenham
         const bool x_step = TERN0(INPUT_SHAPING_X, step_needed.x && shaping_x.enabled),
-                   y_step = TERN0(INPUT_SHAPING_Y, step_needed.y && shaping_y.enabled);
-        if (x_step || y_step)
-          ShapingQueue::enqueue(x_step, TERN0(INPUT_SHAPING_X, shaping_x.forward), y_step, TERN0(INPUT_SHAPING_Y, shaping_y.forward));
+                   y_step = TERN0(INPUT_SHAPING_Y, step_needed.y && shaping_y.enabled),
+                   z_step = TERN0(INPUT_SHAPING_Z, step_needed.z && shaping_z.enabled);
+        if (x_step || y_step || z_step)
+          ShapingQueue::enqueue(x_step, TERN0(INPUT_SHAPING_X, shaping_x.forward), y_step, TERN0(INPUT_SHAPING_Y, shaping_y.forward), z_step, TERN0(INPUT_SHAPING_Z, shaping_z.forward));
 
         // do the first part of the secondary bresenham
         #if ENABLED(INPUT_SHAPING_X)
@@ -2018,6 +2026,10 @@ void Stepper::pulse_phase_isr() {
           if (y_step)
             PULSE_PREP_SHAPING(Y, shaping_y.delta_error, shaping_y.forward ? shaping_y.factor1 : -shaping_y.factor1);
         #endif
+        #if ENABLED(INPUT_SHAPING_Z)
+          if (z_step)
+            PULSE_PREP_SHAPING(Z, shaping_z.delta_error, shaping_z.forward ? shaping_z.factor1 : -shaping_z.factor1);
+        #endif
       #endif
     }
 
@@ -2124,6 +2136,7 @@ void Stepper::pulse_phase_isr() {
     // Clear the echoes that are ready to process. If the buffers are too full and risk overflow, also apply echoes early.
     TERN_(INPUT_SHAPING_X, step_needed.x = !ShapingQueue::peek_x() || ShapingQueue::free_count_x() < steps_per_isr);
     TERN_(INPUT_SHAPING_Y, step_needed.y = !ShapingQueue::peek_y() || ShapingQueue::free_count_y() < steps_per_isr);
+    TERN_(INPUT_SHAPING_Z, step_needed.z = !ShapingQueue::peek_z() || ShapingQueue::free_count_z() < steps_per_isr);
 
     if (bool(step_needed)) while (true) {
       #if ENABLED(INPUT_SHAPING_X)
@@ -2142,6 +2155,14 @@ void Stepper::pulse_phase_isr() {
         }
       #endif
 
+      #if ENABLED(INPUT_SHAPING_Z)
+        if (step_needed.z) {
+          const bool forward = ShapingQueue::dequeue_z();
+          PULSE_PREP_SHAPING(Z, shaping_z.delta_error, (forward ? shaping_z.factor2 : -shaping_z.factor2));
+          PULSE_START(Z);
+        }
+      #endif
+
       TERN_(I2S_STEPPER_STREAM, i2s_push_sample());
 
       USING_TIMED_PULSE();
@@ -2156,10 +2177,14 @@ void Stepper::pulse_phase_isr() {
         #if ENABLED(INPUT_SHAPING_Y)
           PULSE_STOP(Y);
         #endif
+        #if ENABLED(INPUT_SHAPING_Z)
+          PULSE_STOP(Z);
+        #endif
       }
 
       TERN_(INPUT_SHAPING_X, step_needed.x = !ShapingQueue::peek_x() || ShapingQueue::free_count_x() < steps_per_isr);
       TERN_(INPUT_SHAPING_Y, step_needed.y = !ShapingQueue::peek_y() || ShapingQueue::free_count_y() < steps_per_isr);
+      TERN_(INPUT_SHAPING_Z, step_needed.z = !ShapingQueue::peek_z() || ShapingQueue::free_count_z() < steps_per_isr);
 
       if (!bool(step_needed)) break;
 
@@ -2708,7 +2733,7 @@ hal_timer_t Stepper::block_phase_isr() {
         }
       #endif
 
-      // Y follows the same logic as X (but the comments aren't repeated)
+      // Y and Z follow the same logic as X (but the comments aren't repeated)
       #if ENABLED(INPUT_SHAPING_Y)
         if (shaping_y.enabled) {
           const int64_t steps = current_block->direction_bits.y ? int64_t(current_block->steps.y) : -int64_t(current_block->steps.y);
@@ -2718,6 +2743,15 @@ hal_timer_t Stepper::block_phase_isr() {
         }
       #endif
 
+      #if ENABLED(INPUT_SHAPING_Z)
+        if (shaping_z.enabled) {
+          const int64_t steps = current_block->direction_bits.z ? int64_t(current_block->steps.z) : -int64_t(current_block->steps.z);
+          shaping_z.last_block_end_pos += steps;
+          shaping_z.forward = current_block->direction_bits.z;
+          if (!ShapingQueue::empty_z()) current_block->direction_bits.z = last_direction_bits.z;
+        }
+      #endif
+
       // No step events completed so far
       step_events_completed = 0;
 
@@ -3220,12 +3254,14 @@ void Stepper::init() {
     hal.isr_off();
     TERN_(INPUT_SHAPING_X, if (axis == X_AXIS) { shaping_x.factor2 = factor2; shaping_x.factor1 = 128 - factor2; shaping_x.zeta = zeta; })
     TERN_(INPUT_SHAPING_Y, if (axis == Y_AXIS) { shaping_y.factor2 = factor2; shaping_y.factor1 = 128 - factor2; shaping_y.zeta = zeta; })
+    TERN_(INPUT_SHAPING_Z, if (axis == Z_AXIS) { shaping_z.factor2 = factor2; shaping_z.factor1 = 128 - factor2; shaping_z.zeta = zeta; })
     if (was_on) hal.isr_on();
   }
 
   float Stepper::get_shaping_damping_ratio(const AxisEnum axis) {
     TERN_(INPUT_SHAPING_X, if (axis == X_AXIS) return shaping_x.zeta);
     TERN_(INPUT_SHAPING_Y, if (axis == Y_AXIS) return shaping_y.zeta);
+    TERN_(INPUT_SHAPING_Z, if (axis == Z_AXIS) return shaping_z.zeta);
     return -1;
   }
 
@@ -3237,24 +3273,18 @@ void Stepper::init() {
     hal.isr_off();
 
     const shaping_time_t delay = freq ? float(uint32_t(STEPPER_TIMER_RATE) / 2) / freq : shaping_time_t(-1);
-    #if ENABLED(INPUT_SHAPING_X)
-      if (axis == X_AXIS) {
-        ShapingQueue::set_delay(X_AXIS, delay);
-        shaping_x.frequency = freq;
-        shaping_x.enabled = !!freq;
-        shaping_x.delta_error = 0;
-        shaping_x.last_block_end_pos = count_position.x;
-      }
-    #endif
-    #if ENABLED(INPUT_SHAPING_Y)
-      if (axis == Y_AXIS) {
-        ShapingQueue::set_delay(Y_AXIS, delay);
-        shaping_y.frequency = freq;
-        shaping_y.enabled = !!freq;
-        shaping_y.delta_error = 0;
-        shaping_y.last_block_end_pos = count_position.y;
+    #define SHAPING_SET_FREQ_FOR_AXIS(AXISN, AXISL)                                 \
+      if (axis == AXISN) {                                                          \
+        ShapingQueue::set_delay(AXISN, delay);                                      \
+        shaping_##AXISL.frequency = freq;                                           \
+        shaping_##AXISL.enabled = !!freq;                                           \
+        shaping_##AXISL.delta_error = 0;                                            \
+        shaping_##AXISL.last_block_end_pos = count_position.AXISL;                  \
       }
-    #endif
+
+    TERN_(INPUT_SHAPING_X, SHAPING_SET_FREQ_FOR_AXIS(X_AXIS, x))
+    TERN_(INPUT_SHAPING_Y, SHAPING_SET_FREQ_FOR_AXIS(Y_AXIS, y))
+    TERN_(INPUT_SHAPING_Z, SHAPING_SET_FREQ_FOR_AXIS(Z_AXIS, z))
 
     if (was_on) hal.isr_on();
   }
@@ -3262,6 +3292,7 @@ void Stepper::init() {
   float Stepper::get_shaping_frequency(const AxisEnum axis) {
     TERN_(INPUT_SHAPING_X, if (axis == X_AXIS) return shaping_x.frequency);
     TERN_(INPUT_SHAPING_Y, if (axis == Y_AXIS) return shaping_y.frequency);
+    TERN_(INPUT_SHAPING_Z, if (axis == Z_AXIS) return shaping_z.frequency);
     return -1;
   }
 
@@ -3283,6 +3314,9 @@ void Stepper::_set_position(const abce_long_t &spos) {
   #if ENABLED(INPUT_SHAPING_Y)
     const int32_t y_shaping_delta = count_position.y - shaping_y.last_block_end_pos;
   #endif
+  #if ENABLED(INPUT_SHAPING_Z)
+    const int32_t z_shaping_delta = count_position.z - shaping_z.last_block_end_pos;
+  #endif
 
   #if ANY(IS_CORE, MARKFORGED_XY, MARKFORGED_YX)
     // Core equations follow the form of the dA and dB equations at https://www.corexy.com/theory.html
@@ -3323,6 +3357,12 @@ void Stepper::_set_position(const abce_long_t &spos) {
       shaping_y.last_block_end_pos = spos.y;
     }
   #endif
+  #if ENABLED(INPUT_SHAPING_Z)
+    if (shaping_z.enabled) {
+      count_position.z += z_shaping_delta;
+      shaping_z.last_block_end_pos = spos.z;
+    }
+  #endif
 }
 
 /**
@@ -3364,6 +3404,7 @@ void Stepper::set_axis_position(const AxisEnum a, const int32_t &v) {
   count_position[a] = v;
   TERN_(INPUT_SHAPING_X, if (a == X_AXIS) shaping_x.last_block_end_pos = v);
   TERN_(INPUT_SHAPING_Y, if (a == Y_AXIS) shaping_y.last_block_end_pos = v);
+  TERN_(INPUT_SHAPING_Z, if (a == Z_AXIS) shaping_z.last_block_end_pos = v);
 
   #ifdef __AVR__
     // Reenable Stepper ISR

commit 2fd7c2b8652a3250e1eb1dbfd96991b4b11f6257
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Fri May 17 04:48:21 2024 +0300

    ⚡️ Fix motion smoothness (#27013)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 90254ff947..c2674480d5 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -58,10 +58,16 @@
  *
  *                           time ----->
  *
- *  The trapezoid is the shape the speed curve over time. It starts at block->initial_rate, accelerates
- *  first block->accelerate_until step_events_completed, then keeps going at constant speed until
- *  step_events_completed reaches block->decelerate_after after which it decelerates until the trapezoid generator is reset.
- *  The slope of acceleration is calculated using v = u + at where t is the accumulated timer values of the steps so far.
+ *  The speed over time graph forms a TRAPEZOID. The slope of acceleration is calculated by
+ *    v = u + t
+ *  where 't' is the accumulated timer values of the steps so far.
+ *
+ *  The Stepper ISR dynamically executes acceleration, deceleration, and cruising according to the block parameters.
+ *    - Start at block->initial_rate.
+ *    - Accelerate while step_events_completed < block->accelerate_before.
+ *    - Cruise while step_events_completed < block->decelerate_start.
+ *    - Decelerate after that, until all steps are completed.
+ *    - Reset the trapezoid generator.
  */
 
 /**
@@ -193,6 +199,7 @@ bool Stepper::abort_current_block;
   ;
 #endif
 
+// In timer_ticks
 uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
 
 #if MULTISTEPPING_LIMIT > 1
@@ -224,8 +231,8 @@ xyze_long_t Stepper::delta_error{0};
 xyze_long_t Stepper::advance_dividend{0};
 uint32_t Stepper::advance_divisor = 0,
          Stepper::step_events_completed = 0, // The number of step events executed in the current block
-         Stepper::accelerate_until,          // The count at which to stop accelerating
-         Stepper::decelerate_after,          // The count at which to start decelerating
+         Stepper::accelerate_before,         // The count at which to start cruising
+         Stepper::decelerate_start,          // The count at which to start decelerating
          Stepper::step_event_count;          // The total event count for the current block
 
 #if ANY(HAS_MULTI_EXTRUDER, MIXING_EXTRUDER)
@@ -2403,7 +2410,7 @@ hal_timer_t Stepper::block_phase_isr() {
       // Step events not completed yet...
 
       // Are we in acceleration phase ?
-      if (step_events_completed <= accelerate_until) { // Calculate new timer value
+      if (step_events_completed < accelerate_before) { // Calculate new timer value
 
         #if ENABLED(S_CURVE_ACCELERATION)
           // Get the next speed to use (Jerk limited!)
@@ -2420,6 +2427,7 @@ hal_timer_t Stepper::block_phase_isr() {
         // step_rate to timer interval and steps per stepper isr
         interval = calc_multistep_timer_interval(acc_step_rate << oversampling_factor);
         acceleration_time += interval;
+        deceleration_time = 0; // Reset since we're doing acceleration first.
 
         #if ENABLED(NONLINEAR_EXTRUSION)
           calc_nonlinear_e(acc_step_rate << oversampling_factor);
@@ -2456,30 +2464,24 @@ hal_timer_t Stepper::block_phase_isr() {
         #endif
       }
       // Are we in Deceleration phase ?
-      else if (step_events_completed > decelerate_after) {
+      else if (step_events_completed >= decelerate_start) {
         uint32_t step_rate;
 
         #if ENABLED(S_CURVE_ACCELERATION)
-
           // If this is the 1st time we process the 2nd half of the trapezoid...
           if (!bezier_2nd_half) {
             // Initialize the Bézier speed curve
             _calc_bezier_curve_coeffs(current_block->cruise_rate, current_block->final_rate, current_block->deceleration_time_inverse);
             bezier_2nd_half = true;
-            // The first point starts at cruise rate. Just save evaluation of the Bézier curve
-            step_rate = current_block->cruise_rate;
-          }
-          else {
-            // Calculate the next speed to use
-            step_rate = deceleration_time < current_block->deceleration_time
-              ? _eval_bezier_curve(deceleration_time)
-              : current_block->final_rate;
           }
-
+          // Calculate the next speed to use
+          step_rate = deceleration_time < current_block->deceleration_time
+            ? _eval_bezier_curve(deceleration_time)
+            : current_block->final_rate;
         #else
           // Using the old trapezoidal control
           step_rate = STEP_MULTIPLY(deceleration_time, current_block->acceleration_rate);
-          if (step_rate < acc_step_rate) { // Still decelerating?
+          if (step_rate < acc_step_rate) {
             step_rate = acc_step_rate - step_rate;
             NOLESS(step_rate, current_block->final_rate);
           }
@@ -2542,6 +2544,9 @@ hal_timer_t Stepper::block_phase_isr() {
         if (ticks_nominal == 0) {
           // step_rate to timer interval and loops for the nominal speed
           ticks_nominal = calc_multistep_timer_interval(current_block->nominal_rate << oversampling_factor);
+          // Prepare for deceleration
+          IF_DISABLED(S_CURVE_ACCELERATION, acc_step_rate = current_block->nominal_rate);
+          deceleration_time = ticks_nominal / 2;
 
           #if ENABLED(NONLINEAR_EXTRUSION)
             calc_nonlinear_e(current_block->nominal_rate << oversampling_factor);
@@ -2664,9 +2669,6 @@ hal_timer_t Stepper::block_phase_isr() {
       // Set flags for all moving axes, accounting for kinematics
       set_axis_moved_for_current_block();
 
-      // No acceleration / deceleration time elapsed so far
-      acceleration_time = deceleration_time = 0;
-
       #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
         // Nonlinear Extrusion needs at least 2x oversampling to permit increase of E step rate
         // Otherwise assume no axis smoothing (via oversampling)
@@ -2720,8 +2722,8 @@ hal_timer_t Stepper::block_phase_isr() {
       step_events_completed = 0;
 
       // Compute the acceleration and deceleration points
-      accelerate_until = current_block->accelerate_until << oversampling_factor;
-      decelerate_after = current_block->decelerate_after << oversampling_factor;
+      accelerate_before = current_block->accelerate_before << oversampling_factor;
+      decelerate_start = current_block->decelerate_start << oversampling_factor;
 
       TERN_(MIXING_EXTRUDER, mixer.stepper_setup(current_block->b_color));
 
@@ -2807,7 +2809,8 @@ hal_timer_t Stepper::block_phase_isr() {
 
       // Calculate the initial timer interval
       interval = calc_multistep_timer_interval(current_block->initial_rate << oversampling_factor);
-      acceleration_time += interval;
+      // Initialize ac/deceleration time as if half the time passed.
+      acceleration_time = deceleration_time = interval / 2;
 
       #if ENABLED(NONLINEAR_EXTRUSION)
         calc_nonlinear_e(current_block->initial_rate << oversampling_factor);

commit 383e6f464650f91b2423874e90a0411687cf8fe6
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Fri May 17 04:05:27 2024 +0300

    🐛 Move LASER_POWER_TRAP cruise to cruise block (#27031)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b08f8ccb7e..90254ff947 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2441,16 +2441,13 @@ hal_timer_t Stepper::block_phase_isr() {
          * Laser power variables are calulated and stored in this block by the planner code.
          *  trap_ramp_active_pwr - the active power in this block across accel or decel trap steps.
          *  trap_ramp_entry_incr - holds the precalculated value to increase the current power per accel step.
-         *
-         * Apply the starting active power and then increase power per step by the trap_ramp_entry_incr value if positive.
          */
-
         #if ENABLED(LASER_POWER_TRAP)
           if (cutter.cutter_mode == CUTTER_MODE_CONTINUOUS) {
             if (planner.laser_inline.status.isPowered && planner.laser_inline.status.isEnabled) {
               if (current_block->laser.trap_ramp_entry_incr > 0) {
                 cutter.apply_power(current_block->laser.trap_ramp_active_pwr);
-                current_block->laser.trap_ramp_active_pwr += current_block->laser.trap_ramp_entry_incr;
+                current_block->laser.trap_ramp_active_pwr += current_block->laser.trap_ramp_entry_incr * steps_per_isr;
               }
             }
             // Not a powered move.
@@ -2524,15 +2521,12 @@ hal_timer_t Stepper::block_phase_isr() {
           }
         #endif // LIN_ADVANCE
 
-        /**
-         * Adjust Laser Power - Decelerating
-         * trap_ramp_entry_decr - holds the precalculated value to decrease the current power per decel step.
-         */
+        // Adjust Laser Power - Decelerating
         #if ENABLED(LASER_POWER_TRAP)
           if (cutter.cutter_mode == CUTTER_MODE_CONTINUOUS) {
             if (planner.laser_inline.status.isPowered && planner.laser_inline.status.isEnabled) {
               if (current_block->laser.trap_ramp_exit_decr > 0) {
-                current_block->laser.trap_ramp_active_pwr -= current_block->laser.trap_ramp_exit_decr;
+                current_block->laser.trap_ramp_active_pwr -= current_block->laser.trap_ramp_exit_decr * steps_per_isr;
                 cutter.apply_power(current_block->laser.trap_ramp_active_pwr);
               }
               // Not a powered move.
@@ -2557,30 +2551,25 @@ hal_timer_t Stepper::block_phase_isr() {
             if (la_active)
               la_interval = calc_timer_interval(current_block->nominal_rate >> current_block->la_scaling);
           #endif
+
+          // Adjust Laser Power - Cruise
+          #if ENABLED(LASER_POWER_TRAP)
+            if (cutter.cutter_mode == CUTTER_MODE_CONTINUOUS) {
+              if (planner.laser_inline.status.isPowered && planner.laser_inline.status.isEnabled) {
+                if (current_block->laser.trap_ramp_entry_incr > 0) {
+                  current_block->laser.trap_ramp_active_pwr = current_block->laser.power;
+                  cutter.apply_power(current_block->laser.power);
+                }
+              }
+              // Not a powered move.
+              else cutter.apply_power(0);
+            }
+          #endif
         }
 
         // The timer interval is just the nominal value for the nominal speed
         interval = ticks_nominal;
       }
-
-      /**
-       * Adjust Laser Power - Cruise
-       * power - direct or floor adjusted active laser power.
-       */
-      #if ENABLED(LASER_POWER_TRAP)
-        if (cutter.cutter_mode == CUTTER_MODE_CONTINUOUS) {
-          if (step_events_completed + 1 == accelerate_until) {
-            if (planner.laser_inline.status.isPowered && planner.laser_inline.status.isEnabled) {
-              if (current_block->laser.trap_ramp_entry_incr > 0) {
-                current_block->laser.trap_ramp_active_pwr = current_block->laser.power;
-                cutter.apply_power(current_block->laser.power);
-              }
-            }
-            // Not a powered move.
-            else cutter.apply_power(0);
-          }
-        }
-      #endif
     }
 
     #if ENABLED(LASER_FEATURE)

commit 3dc437add4d142b71ea0684848fc1b73e4245a4c
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Thu May 16 08:42:19 2024 +1200

    🎨 Apply TERN0/1 for some contexts (#27036)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index f6a7705c3b..b08f8ccb7e 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2681,7 +2681,7 @@ hal_timer_t Stepper::block_phase_isr() {
       #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
         // Nonlinear Extrusion needs at least 2x oversampling to permit increase of E step rate
         // Otherwise assume no axis smoothing (via oversampling)
-        oversampling_factor = TERN(NONLINEAR_EXTRUSION, 1, 0);
+        oversampling_factor = TERN0(NONLINEAR_EXTRUSION, 1);
 
         // Decide if axis smoothing is possible
         if (stepper.adaptive_step_smoothing_enabled) {

commit 909e3ad11666c35dd24e78bb55235526f8fda1a9
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Mon May 13 10:31:02 2024 +1200

    🩹 Motor PWM followup (#27087)
    
    Followup to 08fe8a3076

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 3416cda3c0..f6a7705c3b 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3973,7 +3973,7 @@ void Stepper::report_positions() {
             #endif
             break;
           case 2:
-            #if HAS_MOTOR_CURRENT_PWM_E
+            #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
               _WRITE_CURRENT_PWM(E);
             #endif
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_E0)
@@ -4036,7 +4036,7 @@ void Stepper::report_positions() {
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
           INIT_CURRENT_PWM(Z);
         #endif
-        #if HAS_MOTOR_CURRENT_PWM_E
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
           INIT_CURRENT_PWM(E);
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_E0)

commit 08fe8a3076c21f881f151bc596e54ff24831bdea
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 12 13:08:17 2024 -0500

    🔧 Undef motor current PWM for unused axes

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 252bf5526b..3416cda3c0 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3906,7 +3906,7 @@ void Stepper::report_positions() {
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
           case 1:
         #endif
-        #if ANY_PIN(MOTOR_CURRENT_PWM_E, MOTOR_CURRENT_PWM_E0, MOTOR_CURRENT_PWM_E1)
+        #if HAS_MOTOR_CURRENT_PWM_E
           case 2:
         #endif
             set_digipot_current(i, motor_current_setting[i]);
@@ -3973,7 +3973,7 @@ void Stepper::report_positions() {
             #endif
             break;
           case 2:
-            #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
+            #if HAS_MOTOR_CURRENT_PWM_E
               _WRITE_CURRENT_PWM(E);
             #endif
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_E0)
@@ -4036,7 +4036,7 @@ void Stepper::report_positions() {
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
           INIT_CURRENT_PWM(Z);
         #endif
-        #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
+        #if HAS_MOTOR_CURRENT_PWM_E
           INIT_CURRENT_PWM(E);
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_E0)

commit 1da947f54806437fdff84adfdc06f48d2e3d60a3
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Thu May 9 23:57:23 2024 +0200

    ⚡️ FT_MOTION : Core and other refinements (#26720)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: Ulendo Alex <alex@ulendo.io>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 6426c7f4a2..252bf5526b 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -647,6 +647,11 @@ void Stepper::disable_all_steppers() {
   TERN_(EXTENSIBLE_UI, ExtUI::onSteppersDisabled());
 }
 
+#if ENABLED(FTM_OPTIMIZE_DIR_STATES)
+  // We'll compare the updated DIR bits to the last set state
+  static AxisBits last_set_direction;
+#endif
+
 // Set a single axis direction based on the last set flags.
 // A direction bit of "1" indicates forward or positive motion.
 #define SET_STEP_DIR(A) do{                     \
@@ -672,6 +677,8 @@ void Stepper::apply_directions() {
     SET_STEP_DIR(U), SET_STEP_DIR(V), SET_STEP_DIR(W)
   );
 
+  TERN_(FTM_OPTIMIZE_DIR_STATES, last_set_direction = last_direction_bits);
+
   DIR_WAIT_AFTER();
 }
 
@@ -1542,8 +1549,20 @@ void Stepper::isr() {
           nextMainISR = FTM_MIN_TICKS;    // Set to minimum interval (a limit on the top speed)
           ftMotion_stepper();             // Run FTM Stepping
         }
-        interval = nextMainISR;           // Interval is either some old nextMainISR or FTM_MIN_TICKS
-        nextMainISR = 0;                  // For FT Motion fire again ASAP
+
+        #if ENABLED(BABYSTEPPING)
+          if (nextBabystepISR == 0) {                   // Avoid ANY stepping too soon after baby-stepping
+            nextBabystepISR = babystepping_isr();
+            NOLESS(nextMainISR, (BABYSTEP_TICKS) / 8);  // FULL STOP for 125µs after a baby-step
+          }
+          if (nextBabystepISR != BABYSTEP_NEVER)        // Avoid baby-stepping too close to axis Stepping
+            NOLESS(nextBabystepISR, nextMainISR / 2);   // TODO: Only look at axes enabled for baby-stepping
+        #endif
+
+        interval = nextMainISR;                         // Interval is either some old nextMainISR or FTM_MIN_TICKS
+        TERN_(BABYSTEPPING, NOMORE(interval, nextBabystepISR)); // Come back early for Babystepping?
+
+        nextMainISR = 0;                                // For FT Motion fire again ASAP
       }
 
     #endif
@@ -1801,6 +1820,7 @@ void Stepper::pulse_phase_isr() {
           last_direction_bits.toggle(_AXIS(AXIS)); \
           DIR_WAIT_BEFORE(); \
           SET_STEP_DIR(AXIS); \
+          TERN_(FTM_OPTIMIZE_DIR_STATES, last_set_direction = last_direction_bits); \
           DIR_WAIT_AFTER(); \
         } \
       } \
@@ -2248,6 +2268,90 @@ hal_timer_t Stepper::calc_multistep_timer_interval(uint32_t step_rate) {
   return calc_timer_interval(step_rate);
 }
 
+// Method to get all moving axes (for proper endstop handling)
+void Stepper::set_axis_moved_for_current_block() {
+
+  #if IS_CORE
+    // Define conditions for checking endstops
+    #define S_(N) current_block->steps[CORE_AXIS_##N]
+    #define D_(N) current_block->direction_bits[CORE_AXIS_##N]
+  #endif
+
+  #if CORE_IS_XY || CORE_IS_XZ
+    /**
+     * Head direction in -X axis for CoreXY and CoreXZ bots.
+     *
+     * If steps differ, both axes are moving.
+     * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z, handled below)
+     * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X)
+     */
+    #if ANY(COREXY, COREXZ)
+      #define X_CMP(A,B) ((A)==(B))
+    #else
+      #define X_CMP(A,B) ((A)!=(B))
+    #endif
+    #define X_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && X_CMP(D_(1),D_(2))) )
+  #elif ENABLED(MARKFORGED_XY)
+    #define X_MOVE_TEST (current_block->steps.a != current_block->steps.b)
+  #else
+    #define X_MOVE_TEST !!current_block->steps.a
+  #endif
+
+  #if CORE_IS_XY || CORE_IS_YZ
+    /**
+     * Head direction in -Y axis for CoreXY / CoreYZ bots.
+     *
+     * If steps differ, both axes are moving
+     * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y)
+     * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z)
+     */
+    #if ANY(COREYX, COREYZ)
+      #define Y_CMP(A,B) ((A)==(B))
+    #else
+      #define Y_CMP(A,B) ((A)!=(B))
+    #endif
+    #define Y_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && Y_CMP(D_(1),D_(2))) )
+  #elif ENABLED(MARKFORGED_YX)
+    #define Y_MOVE_TEST (current_block->steps.a != current_block->steps.b)
+  #else
+    #define Y_MOVE_TEST !!current_block->steps.b
+  #endif
+
+  #if CORE_IS_XZ || CORE_IS_YZ
+    /**
+     * Head direction in -Z axis for CoreXZ or CoreYZ bots.
+     *
+     * If steps differ, both axes are moving
+     * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y, already handled above)
+     * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Z)
+     */
+    #if ANY(COREZX, COREZY)
+      #define Z_CMP(A,B) ((A)==(B))
+    #else
+      #define Z_CMP(A,B) ((A)!=(B))
+    #endif
+    #define Z_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && Z_CMP(D_(1),D_(2))) )
+  #else
+    #define Z_MOVE_TEST !!current_block->steps.c
+  #endif
+
+  // Set flags for all axes that move in this block
+  // These are set per-axis, not per-stepper
+  AxisBits didmove;
+  NUM_AXIS_CODE(
+    if (X_MOVE_TEST)              didmove.a = true, // Cartesian X or Kinematic A
+    if (Y_MOVE_TEST)              didmove.b = true, // Cartesian Y or Kinematic B
+    if (Z_MOVE_TEST)              didmove.c = true, // Cartesian Z or Kinematic C
+    if (!!current_block->steps.i) didmove.i = true,
+    if (!!current_block->steps.j) didmove.j = true,
+    if (!!current_block->steps.k) didmove.k = true,
+    if (!!current_block->steps.u) didmove.u = true,
+    if (!!current_block->steps.v) didmove.v = true,
+    if (!!current_block->steps.w) didmove.w = true
+  );
+  axis_did_move = didmove;
+}
+
 /**
  * This last phase of the stepper interrupt processes and properly
  * schedules planner blocks. This is executed after the step pulses
@@ -2410,6 +2514,8 @@ hal_timer_t Stepper::block_phase_isr() {
 
                 E_APPLY_DIR(forward_e, false);
 
+                TERN_(FTM_OPTIMIZE_DIR_STATES, last_set_direction = last_direction_bits);
+
                 DIR_WAIT_AFTER();
               }
             }
@@ -2508,25 +2614,31 @@ hal_timer_t Stepper::block_phase_isr() {
     // Anything in the buffer?
     if ((current_block = planner.get_current_block())) {
 
-      // Sync block? Sync the stepper counts or fan speeds and return
+      // Run through all sync blocks
       while (current_block->is_sync()) {
 
+        // Set laser power
         #if ENABLED(LASER_POWER_SYNC)
           if (cutter.cutter_mode == CUTTER_MODE_CONTINUOUS) {
-            if (current_block->is_pwr_sync()) {
+            if (current_block->is_sync_pwr()) {
               planner.laser_inline.status.isSyncPower = true;
               cutter.apply_power(current_block->laser.power);
             }
           }
         #endif
 
-        TERN_(LASER_SYNCHRONOUS_M106_M107, if (current_block->is_fan_sync()) planner.sync_fan_speeds(current_block->fan_speed));
+        // Set "fan speeds" for a laser module
+        #if ENABLED(LASER_SYNCHRONOUS_M106_M107)
+          if (current_block->is_sync_fan()) planner.sync_fan_speeds(current_block->fan_speed);
+        #endif
 
-        if (!(current_block->is_fan_sync() || current_block->is_pwr_sync())) _set_position(current_block->position);
+        // Set position
+        if (current_block->is_sync_pos()) _set_position(current_block->position);
 
+        // Done with this block
         discard_current_block();
 
-        // Try to get a new block
+        // Try to get a new block. Exit if there are no more.
         if (!(current_block = planner.get_current_block()))
           return interval; // No more queued movements!
       }
@@ -2560,85 +2672,8 @@ hal_timer_t Stepper::block_phase_isr() {
         }
       #endif
 
-      // Flag all moving axes for proper endstop handling
-
-      #if IS_CORE
-        // Define conditions for checking endstops
-        #define S_(N) current_block->steps[CORE_AXIS_##N]
-        #define D_(N) current_block->direction_bits[CORE_AXIS_##N]
-      #endif
-
-      #if CORE_IS_XY || CORE_IS_XZ
-        /**
-         * Head direction in -X axis for CoreXY and CoreXZ bots.
-         *
-         * If steps differ, both axes are moving.
-         * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z, handled below)
-         * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X)
-         */
-        #if ANY(COREXY, COREXZ)
-          #define X_CMP(A,B) ((A)==(B))
-        #else
-          #define X_CMP(A,B) ((A)!=(B))
-        #endif
-        #define X_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && X_CMP(D_(1),D_(2))) )
-      #elif ENABLED(MARKFORGED_XY)
-        #define X_MOVE_TEST (current_block->steps.a != current_block->steps.b)
-      #else
-        #define X_MOVE_TEST !!current_block->steps.a
-      #endif
-
-      #if CORE_IS_XY || CORE_IS_YZ
-        /**
-         * Head direction in -Y axis for CoreXY / CoreYZ bots.
-         *
-         * If steps differ, both axes are moving
-         * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y)
-         * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z)
-         */
-        #if ANY(COREYX, COREYZ)
-          #define Y_CMP(A,B) ((A)==(B))
-        #else
-          #define Y_CMP(A,B) ((A)!=(B))
-        #endif
-        #define Y_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && Y_CMP(D_(1),D_(2))) )
-      #elif ENABLED(MARKFORGED_YX)
-        #define Y_MOVE_TEST (current_block->steps.a != current_block->steps.b)
-      #else
-        #define Y_MOVE_TEST !!current_block->steps.b
-      #endif
-
-      #if CORE_IS_XZ || CORE_IS_YZ
-        /**
-         * Head direction in -Z axis for CoreXZ or CoreYZ bots.
-         *
-         * If steps differ, both axes are moving
-         * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y, already handled above)
-         * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Z)
-         */
-        #if ANY(COREZX, COREZY)
-          #define Z_CMP(A,B) ((A)==(B))
-        #else
-          #define Z_CMP(A,B) ((A)!=(B))
-        #endif
-        #define Z_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && Z_CMP(D_(1),D_(2))) )
-      #else
-        #define Z_MOVE_TEST !!current_block->steps.c
-      #endif
-
-      AxisBits didmove;
-      NUM_AXIS_CODE(
-        if (X_MOVE_TEST)              didmove.a = true,
-        if (Y_MOVE_TEST)              didmove.b = true,
-        if (Z_MOVE_TEST)              didmove.c = true,
-        if (!!current_block->steps.i) didmove.i = true,
-        if (!!current_block->steps.j) didmove.j = true,
-        if (!!current_block->steps.k) didmove.k = true,
-        if (!!current_block->steps.u) didmove.u = true,
-        if (!!current_block->steps.v) didmove.v = true,
-        if (!!current_block->steps.w) didmove.w = true
-      );
-      axis_did_move = didmove;
+      // Set flags for all moving axes, accounting for kinematics
+      set_axis_moved_for_current_block();
 
       // No acceleration / deceleration time elapsed so far
       acceleration_time = deceleration_time = 0;
@@ -3258,15 +3293,12 @@ void Stepper::_set_position(const abce_long_t &spos) {
   #endif
 
   #if ANY(IS_CORE, MARKFORGED_XY, MARKFORGED_YX)
+    // Core equations follow the form of the dA and dB equations at https://www.corexy.com/theory.html
     #if CORE_IS_XY
-      // corexy positioning
-      // these equations follow the form of the dA and dB equations on https://www.corexy.com/theory.html
       count_position.set(spos.a + spos.b, CORESIGN(spos.a - spos.b) OPTARG(HAS_Z_AXIS, spos.c));
     #elif CORE_IS_XZ
-      // corexz planning
       count_position.set(spos.a + spos.c, spos.b, CORESIGN(spos.a - spos.c));
     #elif CORE_IS_YZ
-      // coreyz planning
       count_position.set(spos.a, spos.b + spos.c, CORESIGN(spos.b - spos.c));
     #elif ENABLED(MARKFORGED_XY)
       count_position.set(spos.a TERN(MARKFORGED_INVERSE, +, -) spos.b, spos.b, spos.c);
@@ -3462,16 +3494,24 @@ void Stepper::report_positions() {
 
 #if ENABLED(FT_MOTION)
 
-  // Set stepper I/O for fixed time controller.
+  /**
+   * Run stepping from the Stepper ISR at regular short intervals.
+   *
+   * - Set ftMotion.sts_stepperBusy state to reflect whether there are any commands in the circular buffer.
+   * - If there are no commands in the buffer, return.
+   * - Get the next command from the circular buffer ftMotion.stepperCmdBuff[].
+   * - If the block is being aborted, return without processing the command.
+   * - Apply STEP/DIR along with any delays required. A command may be empty, with no STEP/DIR.
+   */
   void Stepper::ftMotion_stepper() {
 
+    static AxisBits direction_bits{0};
+
     // Check if the buffer is empty.
     ftMotion.sts_stepperBusy = (ftMotion.stepperCmdBuff_produceIdx != ftMotion.stepperCmdBuff_consumeIdx);
     if (!ftMotion.sts_stepperBusy) return;
 
     // "Pop" one command from current motion buffer
-    // Use one byte to restore one stepper command in the format:
-    // |X_step|X_direction|Y_step|Y_direction|Z_step|Z_direction|E_step|E_direction|
     const ft_command_t command = ftMotion.stepperCmdBuff[ftMotion.stepperCmdBuff_consumeIdx];
     if (++ftMotion.stepperCmdBuff_consumeIdx == (FTM_STEPPERCMD_BUFF_SIZE))
       ftMotion.stepperCmdBuff_consumeIdx = 0;
@@ -3480,58 +3520,80 @@ void Stepper::report_positions() {
 
     USING_TIMED_PULSE();
 
-    axis_did_move = LOGICAL_AXIS_ARRAY(
+    // Get FT Motion command flags for axis STEP / DIR
+    #define _FTM_STEP(AXIS) TEST(command, FT_BIT_STEP_##AXIS)
+    #define _FTM_DIR(AXIS) TEST(command, FT_BIT_DIR_##AXIS)
+
+    AxisBits axis_step;
+    axis_step = LOGICAL_AXIS_ARRAY(
       TEST(command, FT_BIT_STEP_E),
       TEST(command, FT_BIT_STEP_X), TEST(command, FT_BIT_STEP_Y), TEST(command, FT_BIT_STEP_Z),
       TEST(command, FT_BIT_STEP_I), TEST(command, FT_BIT_STEP_J), TEST(command, FT_BIT_STEP_K),
       TEST(command, FT_BIT_STEP_U), TEST(command, FT_BIT_STEP_V), TEST(command, FT_BIT_STEP_W)
     );
 
-    last_direction_bits = LOGICAL_AXIS_ARRAY(
-      axis_did_move.e ? TEST(command, FT_BIT_DIR_E) : last_direction_bits.e,
-      axis_did_move.x ? TEST(command, FT_BIT_DIR_X) : last_direction_bits.x,
-      axis_did_move.y ? TEST(command, FT_BIT_DIR_Y) : last_direction_bits.y,
-      axis_did_move.z ? TEST(command, FT_BIT_DIR_Z) : last_direction_bits.z,
-      axis_did_move.i ? TEST(command, FT_BIT_DIR_I) : last_direction_bits.i,
-      axis_did_move.j ? TEST(command, FT_BIT_DIR_J) : last_direction_bits.j,
-      axis_did_move.k ? TEST(command, FT_BIT_DIR_K) : last_direction_bits.k,
-      axis_did_move.u ? TEST(command, FT_BIT_DIR_U) : last_direction_bits.u,
-      axis_did_move.v ? TEST(command, FT_BIT_DIR_V) : last_direction_bits.v,
-      axis_did_move.w ? TEST(command, FT_BIT_DIR_W) : last_direction_bits.w
+    direction_bits = LOGICAL_AXIS_ARRAY(
+      axis_step.e ? TEST(command, FT_BIT_DIR_E) : direction_bits.e,
+      axis_step.x ? TEST(command, FT_BIT_DIR_X) : direction_bits.x,
+      axis_step.y ? TEST(command, FT_BIT_DIR_Y) : direction_bits.y,
+      axis_step.z ? TEST(command, FT_BIT_DIR_Z) : direction_bits.z,
+      axis_step.i ? TEST(command, FT_BIT_DIR_I) : direction_bits.i,
+      axis_step.j ? TEST(command, FT_BIT_DIR_J) : direction_bits.j,
+      axis_step.k ? TEST(command, FT_BIT_DIR_K) : direction_bits.k,
+      axis_step.u ? TEST(command, FT_BIT_DIR_U) : direction_bits.u,
+      axis_step.v ? TEST(command, FT_BIT_DIR_V) : direction_bits.v,
+      axis_step.w ? TEST(command, FT_BIT_DIR_W) : direction_bits.w
     );
 
     // Apply directions (which will apply to the entire linear move)
     LOGICAL_AXIS_CODE(
-      E_APPLY_DIR(last_direction_bits.e, false),
-      X_APPLY_DIR(last_direction_bits.x, false), Y_APPLY_DIR(last_direction_bits.y, false), Z_APPLY_DIR(last_direction_bits.z, false),
-      I_APPLY_DIR(last_direction_bits.i, false), J_APPLY_DIR(last_direction_bits.j, false), K_APPLY_DIR(last_direction_bits.k, false),
-      U_APPLY_DIR(last_direction_bits.u, false), V_APPLY_DIR(last_direction_bits.v, false), W_APPLY_DIR(last_direction_bits.w, false)
+      E_APPLY_DIR(direction_bits.e, false),
+      X_APPLY_DIR(direction_bits.x, false), Y_APPLY_DIR(direction_bits.y, false), Z_APPLY_DIR(direction_bits.z, false),
+      I_APPLY_DIR(direction_bits.i, false), J_APPLY_DIR(direction_bits.j, false), K_APPLY_DIR(direction_bits.k, false),
+      U_APPLY_DIR(direction_bits.u, false), V_APPLY_DIR(direction_bits.v, false), W_APPLY_DIR(direction_bits.w, false)
     );
 
-    DIR_WAIT_AFTER();
+    /**
+     * Update direction bits for steppers that were stepped by this command.
+     * HX, HY, HZ direction bits were set for Core kinematics
+     * when the block was fetched and are not overwritten here.
+     */
 
     // Start a step pulse
     LOGICAL_AXIS_CODE(
-      E_APPLY_STEP(axis_did_move.e, false),
-      X_APPLY_STEP(axis_did_move.x, false), Y_APPLY_STEP(axis_did_move.y, false), Z_APPLY_STEP(axis_did_move.z, false),
-      I_APPLY_STEP(axis_did_move.i, false), J_APPLY_STEP(axis_did_move.j, false), K_APPLY_STEP(axis_did_move.k, false),
-      U_APPLY_STEP(axis_did_move.u, false), V_APPLY_STEP(axis_did_move.v, false), W_APPLY_STEP(axis_did_move.w, false)
+      E_APPLY_STEP(axis_step.e, false),
+      X_APPLY_STEP(axis_step.x, false), Y_APPLY_STEP(axis_step.y, false), Z_APPLY_STEP(axis_step.z, false),
+      I_APPLY_STEP(axis_step.i, false), J_APPLY_STEP(axis_step.j, false), K_APPLY_STEP(axis_step.k, false),
+      U_APPLY_STEP(axis_step.u, false), V_APPLY_STEP(axis_step.v, false), W_APPLY_STEP(axis_step.w, false)
     );
 
+    if (TERN1(FTM_OPTIMIZE_DIR_STATES, last_set_direction != last_direction_bits)) {
+      // Apply directions (generally applying to the entire linear move)
+      #define _FTM_APPLY_DIR(AXIS) if (TERN1(FTM_OPTIMIZE_DIR_STATES, last_direction_bits[_AXIS(A)] != last_set_direction[_AXIS(AXIS)])) \
+                                     SET_STEP_DIR(AXIS);
+      LOGICAL_AXIS_MAP(_FTM_APPLY_DIR);
+
+      TERN_(FTM_OPTIMIZE_DIR_STATES, last_set_direction = last_direction_bits);
+
+      // Any DIR change requires a wait period
+      DIR_WAIT_AFTER();
+    }
+
+    // Start step pulses. Edge stepping will toggle the STEP pin.
+    #define _FTM_STEP_START(AXIS) AXIS##_APPLY_STEP(_FTM_STEP(AXIS), false);
+    LOGICAL_AXIS_MAP(_FTM_STEP_START);
+
+    // Apply steps via I2S
     TERN_(I2S_STEPPER_STREAM, i2s_push_sample());
 
     // Begin waiting for the minimum pulse duration
     START_TIMED_PULSE();
 
     // Update step counts
-    LOGICAL_AXIS_CODE(
-      if (axis_did_move.e) count_position.e += last_direction_bits.e ? 1 : -1, if (axis_did_move.x) count_position.x += last_direction_bits.x ? 1 : -1,
-      if (axis_did_move.y) count_position.y += last_direction_bits.y ? 1 : -1, if (axis_did_move.z) count_position.z += last_direction_bits.z ? 1 : -1,
-      if (axis_did_move.i) count_position.i += last_direction_bits.i ? 1 : -1, if (axis_did_move.j) count_position.j += last_direction_bits.j ? 1 : -1,
-      if (axis_did_move.k) count_position.k += last_direction_bits.k ? 1 : -1, if (axis_did_move.u) count_position.u += last_direction_bits.u ? 1 : -1,
-      if (axis_did_move.v) count_position.v += last_direction_bits.v ? 1 : -1, if (axis_did_move.w) count_position.w += last_direction_bits.w ? 1 : -1
-    );
+    #define _FTM_STEP_COUNT(AXIS) if (axis_step[_AXIS(AXIS)]) count_position[_AXIS(AXIS)] += direction_bits[_AXIS(AXIS)] ? 1 : -1;
+    LOGICAL_AXIS_MAP(_FTM_STEP_COUNT);
 
+    // Provide EDGE flags for E stepper(s)
     #if HAS_EXTRUDERS
       #if ENABLED(E_DUAL_STEPPER_DRIVERS)
         constexpr bool e_axis_has_dedge = AXIS_HAS_DEDGE(E0) && AXIS_HAS_DEDGE(E1);
@@ -3544,38 +3606,32 @@ void Stepper::report_positions() {
 
     // Only wait for axes without edge stepping
     const bool any_wait = false LOGICAL_AXIS_GANG(
-      || (!e_axis_has_dedge && axis_did_move.e),
-      || (!AXIS_HAS_DEDGE(X) && axis_did_move.x), || (!AXIS_HAS_DEDGE(Y) && axis_did_move.y), || (!AXIS_HAS_DEDGE(Z) && axis_did_move.z),
-      || (!AXIS_HAS_DEDGE(I) && axis_did_move.i), || (!AXIS_HAS_DEDGE(J) && axis_did_move.j), || (!AXIS_HAS_DEDGE(K) && axis_did_move.k),
-      || (!AXIS_HAS_DEDGE(U) && axis_did_move.u), || (!AXIS_HAS_DEDGE(V) && axis_did_move.v), || (!AXIS_HAS_DEDGE(W) && axis_did_move.w)
+      || (!e_axis_has_dedge && axis_step.e),
+      || (!AXIS_HAS_DEDGE(X) && axis_step.x), || (!AXIS_HAS_DEDGE(Y) && axis_step.y), || (!AXIS_HAS_DEDGE(Z) && axis_step.z),
+      || (!AXIS_HAS_DEDGE(I) && axis_step.i), || (!AXIS_HAS_DEDGE(J) && axis_step.j), || (!AXIS_HAS_DEDGE(K) && axis_step.k),
+      || (!AXIS_HAS_DEDGE(U) && axis_step.u), || (!AXIS_HAS_DEDGE(V) && axis_step.v), || (!AXIS_HAS_DEDGE(W) && axis_step.w)
     );
 
     // Allow pulses to be registered by stepper drivers
     if (any_wait) AWAIT_HIGH_PULSE();
 
     // Stop pulses. Axes with DEDGE will do nothing, assuming STEP_STATE_* is HIGH
-    LOGICAL_AXIS_CODE(
-      E_APPLY_STEP(!STEP_STATE_E, false),
-      X_APPLY_STEP(!STEP_STATE_X, false), Y_APPLY_STEP(!STEP_STATE_Y, false), Z_APPLY_STEP(!STEP_STATE_Z, false),
-      I_APPLY_STEP(!STEP_STATE_I, false), J_APPLY_STEP(!STEP_STATE_J, false), K_APPLY_STEP(!STEP_STATE_K, false),
-      U_APPLY_STEP(!STEP_STATE_U, false), V_APPLY_STEP(!STEP_STATE_V, false), W_APPLY_STEP(!STEP_STATE_W, false)
-    );
-
-    // Check endstops on every step
-    IF_DISABLED(ENDSTOP_INTERRUPTS_FEATURE, endstops.update());
+    #define _FTM_STEP_STOP(AXIS) AXIS##_APPLY_STEP(!STEP_STATE_##AXIS, false);
+    LOGICAL_AXIS_MAP(_FTM_STEP_STOP);
 
     // Also handle babystepping here
     TERN_(BABYSTEPPING, if (babystep.has_steps()) babystepping_isr());
 
   } // Stepper::ftMotion_stepper
 
+  // Called from FTMotion::loop (when !blockProcRdy) which is called from Marlin idle()
   void Stepper::ftMotion_blockQueueUpdate() {
 
     if (current_block) {
-      // If the current block is not done processing, return right away
+      // If the current block is not done processing, return right away.
+      // A block is done processing when the command buffer has been
+      // filled, not necessarily when it's done running.
       if (!ftMotion.getBlockProcDn()) return;
-
-      axis_did_move.reset();
       planner.release_current_block();
     }
 
@@ -3583,10 +3639,37 @@ void Stepper::report_positions() {
     current_block = planner.get_current_block();
 
     if (current_block) {
-      // Sync block? Sync the stepper counts and return
+
+      // Sync position, fan power, laser power?
       while (current_block->is_sync()) {
-        TERN_(LASER_FEATURE, if (!(current_block->is_fan_sync() || current_block->is_pwr_sync()))) _set_position(current_block->position);
 
+        #if 0
+
+        // TODO: Implement compatible sync blocks with FT Motion commands,
+        //       perhaps by setting a FT_BIT_SYNC flag that holds the current block
+        //       until it is processed by ftMotion_stepper
+
+        // Set laser power
+        #if ENABLED(LASER_POWER_SYNC)
+          if (cutter.cutter_mode == CUTTER_MODE_CONTINUOUS) {
+            if (current_block->is_sync_pwr()) {
+              planner.laser_inline.status.isSyncPower = true;
+              cutter.apply_power(current_block->laser.power);
+            }
+          }
+        #endif
+
+        // Set "fan speeds" for a laser module
+        #if ENABLED(LASER_SYNCHRONOUS_M106_M107)
+          if (current_block->is_sync_fan()) planner.sync_fan_speeds(current_block->fan_speed);
+        #endif
+
+        // Set position
+        if (current_block->is_sync_pos()) _set_position(current_block->position);
+
+        #endif
+
+        // Done with this block
         planner.release_current_block();
 
         // Try to get a new block
@@ -3594,6 +3677,17 @@ void Stepper::report_positions() {
           return; // No queued blocks.
       }
 
+      // Some kinematics track axis motion in HX, HY, HZ
+      #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
+        last_direction_bits.hx = current_block->direction_bits.hx;
+      #endif
+      #if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY, MARKFORGED_YX)
+        last_direction_bits.hy = current_block->direction_bits.hy;
+      #endif
+      #if ANY(CORE_IS_XZ, CORE_IS_YZ)
+        last_direction_bits.hz = current_block->direction_bits.hz;
+      #endif
+
       ftMotion.startBlockProc();
       return;
     }

commit c91771a51e32dd490b1298fa2eef3af67f033553
Author: Vovodroid <vovodroid@users.noreply.github.com>
Date:   Sun Apr 7 08:41:01 2024 +0300

    🩹Disable nonlinear extrusion on unretract (#26824)
    
    * Fixes disable NLE on unretract #26808, which reported blobs at the start of lines during unretract.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 803c14d73c..6426c7f4a2 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2770,7 +2770,7 @@ hal_timer_t Stepper::block_phase_isr() {
         ne_edividend = advance_dividend.e;
         const float scale = (float(ne_edividend) / advance_divisor) * planner.mm_per_step[E_AXIS_N(current_block->extruder)];
         ne_scale = (1L << 24) * scale;
-        if (current_block->direction_bits.e) {
+        if (current_block->direction_bits.e && ANY_AXIS_MOVES(current_block)) {
           ne_fix.A = (1L << 24) * ne.A;
           ne_fix.B = (1L << 24) * ne.B;
           ne_fix.C = (1L << 24) * ne.C;

commit 87e94f456348e944ba4487aed436c762dd718966
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon Apr 1 16:05:11 2024 -0400

    🚸 Update ProUI Plot graph - part 2 (#26563)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 851fa452e7..803c14d73c 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -204,6 +204,11 @@ uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
 #endif
 
 #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
+  #if ENABLED(ADAPTIVE_STEP_SMOOTHING_TOGGLE)
+    bool Stepper::adaptive_step_smoothing_enabled; // Initialized by settings.load()
+  #else
+    constexpr bool Stepper::adaptive_step_smoothing_enabled; // = true
+  #endif
   // Oversampling factor (log2(multiplier)) to increase temporal resolution of axis
   uint8_t Stepper::oversampling_factor;
 #else
@@ -547,6 +552,8 @@ void Stepper::enable_axis(const AxisEnum axis) {
     default: break;
   }
   mark_axis_enabled(axis);
+
+  TERN_(EXTENSIBLE_UI, ExtUI::onAxisEnabled(ExtUI::axis_to_axis_t(axis)));
 }
 
 /**
@@ -567,7 +574,8 @@ void Stepper::enable_axis(const AxisEnum axis) {
 bool Stepper::disable_axis(const AxisEnum axis) {
   mark_axis_disabled(axis);
 
-  TERN_(DWIN_LCD_PROUI, set_axis_untrusted(axis)); // MRISCOC workaround: https://github.com/MarlinFirmware/Marlin/issues/23095
+  // This scheme prevents shared steppers being disabled. It should consider several axes at once
+  // and keep a count of how many times each ENA pin has been set.
 
   // If all the axes that share the enabled bit are disabled
   const bool can_disable = can_axis_disable(axis);
@@ -577,6 +585,7 @@ bool Stepper::disable_axis(const AxisEnum axis) {
       MAIN_AXIS_MAP(_CASE_DISABLE)
       default: break;
     }
+    TERN_(EXTENSIBLE_UI, ExtUI::onAxisDisabled(ExtUI::axis_to_axis_t(axis)));
   }
 
   return can_disable;
@@ -2640,7 +2649,7 @@ hal_timer_t Stepper::block_phase_isr() {
         oversampling_factor = TERN(NONLINEAR_EXTRUSION, 1, 0);
 
         // Decide if axis smoothing is possible
-        if (TERN1(DWIN_LCD_PROUI, hmiData.adaptiveStepSmoothing)) {
+        if (stepper.adaptive_step_smoothing_enabled) {
           uint32_t max_rate = current_block->nominal_rate;  // Get the step event rate
           while (max_rate < MIN_STEP_ISR_FREQUENCY) {       // As long as more ISRs are possible...
             max_rate <<= 1;                                 // Try to double the rate

commit 466282f322ae4f42a8f3db5e3c9765c38445fdc8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 31 18:20:37 2024 -0500

    🩹 Misc. changes from ProUI / ExtUI updates (#26928)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 9380ff79f4..851fa452e7 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -203,12 +203,17 @@ uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
   hal_timer_t Stepper::time_spent_in_isr = 0, Stepper::time_spent_out_isr = 0;
 #endif
 
+#if ENABLED(ADAPTIVE_STEP_SMOOTHING)
+  // Oversampling factor (log2(multiplier)) to increase temporal resolution of axis
+  uint8_t Stepper::oversampling_factor;
+#else
+  constexpr uint8_t Stepper::oversampling_factor; // = 0
+#endif
+
 #if ENABLED(FREEZE_FEATURE)
   bool Stepper::frozen; // = false
 #endif
 
-IF_DISABLED(ADAPTIVE_STEP_SMOOTHING, constexpr) uint8_t Stepper::oversampling_factor;
-
 xyze_long_t Stepper::delta_error{0};
 
 xyze_long_t Stepper::advance_dividend{0};
@@ -544,6 +549,21 @@ void Stepper::enable_axis(const AxisEnum axis) {
   mark_axis_enabled(axis);
 }
 
+/**
+ * Mark an axis as disabled and power off its stepper(s).
+ * If one of the axis steppers is still in use by a non-disabled axis the axis will remain powered.
+ * DISCUSSION: It's basically just stepper ENA pins that are shared across axes, not whole steppers.
+ *             Used on MCUs with a shortage of pins. We already track the overlap of ENA pins, so now
+ *             we just need stronger logic to track which ENA pins are being set more than once.
+ *
+ *             It would be better to use a bit mask (i.e., Flags<NUM_DISTINCT_AXIS_ENUMS>).
+ *             While the method try_to_disable in gcode/control/M17_M18_M84.cpp does use the
+ *             bit mask, it is still only at the axis level.
+ * TODO: Power off steppers that don't share another axis. Currently axis-based steppers turn off as a unit.
+ *       So we'd need to power off the off axis, then power on the on axis (for a microsecond).
+ *       A global solution would keep a usage count when enabling or disabling a stepper, but this partially
+ *       defeats the purpose of an on/off mask.
+ */
 bool Stepper::disable_axis(const AxisEnum axis) {
   mark_axis_disabled(axis);
 
@@ -558,6 +578,7 @@ bool Stepper::disable_axis(const AxisEnum axis) {
       default: break;
     }
   }
+
   return can_disable;
 }
 

commit 3ee3964becc6861375b8a0470bfb6401d52b83b8
Author: John Robertson <john@cirtech.co.uk>
Date:   Sat Mar 23 00:57:23 2024 +0000

    🐛 Fix ESP32 laser M4 exception (#26884)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 16855ebb66..9380ff79f4 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2456,7 +2456,8 @@ hal_timer_t Stepper::block_phase_isr() {
        */
       if (cutter.cutter_mode == CUTTER_MODE_DYNAMIC
         && planner.laser_inline.status.isPowered                  // isPowered flag set on any parsed G1, G2, G3, or G5 move; cleared on any others.
-        && cutter.last_block_power != current_block->laser.power  // Prevent constant update without change
+        && current_block                                          // Block may not be available if steps completed (see discard_current_block() above)
+        && cutter.last_block_power != current_block->laser.power  // Only update if the power changed
       ) {
         cutter.apply_power(current_block->laser.power);
         cutter.last_block_power = current_block->laser.power;

commit 075f96d2bf44c20d480599ccf7b90909dfa6f217
Author: Holger Mößinger <hm2dev@users.noreply.github.com>
Date:   Fri Mar 22 22:36:42 2024 +0100

    ✏️ Fix stepper MS pin typos (#26891)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 0ae6ccb9a7..16855ebb66 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -4118,22 +4118,22 @@ void Stepper::report_positions() {
           break;
       #endif
       #if HAS_I_MS_PINS
-        case  I_AXIS: WRITE(I_MS1_PIN, ms1); break
+        case  I_AXIS: WRITE(I_MS1_PIN, ms1); break;
       #endif
       #if HAS_J_MS_PINS
-        case  J_AXIS: WRITE(J_MS1_PIN, ms1); break
+        case  J_AXIS: WRITE(J_MS1_PIN, ms1); break;
       #endif
       #if HAS_K_MS_PINS
-        case  K_AXIS: WRITE(K_MS1_PIN, ms1); break
+        case  K_AXIS: WRITE(K_MS1_PIN, ms1); break;
       #endif
       #if HAS_U_MS_PINS
-        case  U_AXIS: WRITE(U_MS1_PIN, ms1); break
+        case  U_AXIS: WRITE(U_MS1_PIN, ms1); break;
       #endif
       #if HAS_V_MS_PINS
-        case  V_AXIS: WRITE(V_MS1_PIN, ms1); break
+        case  V_AXIS: WRITE(V_MS1_PIN, ms1); break;
       #endif
       #if HAS_W_MS_PINS
-        case  W_AXIS: WRITE(W_MS1_PIN, ms1); break
+        case  W_AXIS: WRITE(W_MS1_PIN, ms1); break;
       #endif
       #if HAS_E0_MS_PINS
         case  E_AXIS: WRITE(E0_MS1_PIN, ms1); break;
@@ -4198,22 +4198,22 @@ void Stepper::report_positions() {
           break;
       #endif
       #if HAS_I_MS_PINS
-        case  I_AXIS: WRITE(I_MS2_PIN, ms2); break
+        case  I_AXIS: WRITE(I_MS2_PIN, ms2); break;
       #endif
       #if HAS_J_MS_PINS
-        case  J_AXIS: WRITE(J_MS2_PIN, ms2); break
+        case  J_AXIS: WRITE(J_MS2_PIN, ms2); break;
       #endif
       #if HAS_K_MS_PINS
-        case  K_AXIS: WRITE(K_MS2_PIN, ms2); break
+        case  K_AXIS: WRITE(K_MS2_PIN, ms2); break;
       #endif
       #if HAS_U_MS_PINS
-        case  U_AXIS: WRITE(U_MS2_PIN, ms2); break
+        case  U_AXIS: WRITE(U_MS2_PIN, ms2); break;
       #endif
       #if HAS_V_MS_PINS
-        case  V_AXIS: WRITE(V_MS2_PIN, ms2); break
+        case  V_AXIS: WRITE(V_MS2_PIN, ms2); break;
       #endif
       #if HAS_W_MS_PINS
-        case  W_AXIS: WRITE(W_MS2_PIN, ms2); break
+        case  W_AXIS: WRITE(W_MS2_PIN, ms2); break;
       #endif
       #if HAS_E0_MS_PINS
         case  E_AXIS: WRITE(E0_MS2_PIN, ms2); break;
@@ -4277,23 +4277,23 @@ void Stepper::report_positions() {
           #endif
           break;
       #endif
-      #if HAS_I_MS_PINS
-        case  I_AXIS: WRITE(I_MS3_PIN, ms3); break
+      #if HAS_I_MS_PINS && PIN_EXISTS(I_MS3)
+        case  I_AXIS: WRITE(I_MS3_PIN, ms3); break;
       #endif
-      #if HAS_J_MS_PINS
-        case  J_AXIS: WRITE(J_MS3_PIN, ms3); break
+      #if HAS_J_MS_PINS && PIN_EXISTS(J_MS3)
+        case  J_AXIS: WRITE(J_MS3_PIN, ms3); break;
       #endif
-      #if HAS_K_MS_PINS
-        case  K_AXIS: WRITE(K_MS3_PIN, ms3); break
+      #if HAS_K_MS_PINS && PIN_EXISTS(K_MS3)
+        case  K_AXIS: WRITE(K_MS3_PIN, ms3); break;
       #endif
-      #if HAS_U_MS_PINS
-        case  U_AXIS: WRITE(U_MS3_PIN, ms3); break
+      #if HAS_U_MS_PINS && PIN_EXISTS(U_MS3)
+        case  U_AXIS: WRITE(U_MS3_PIN, ms3); break;
       #endif
-      #if HAS_V_MS_PINS
-        case  V_AXIS: WRITE(V_MS3_PIN, ms3); break
+      #if HAS_V_MS_PINS && PIN_EXISTS(V_MS3)
+        case  V_AXIS: WRITE(V_MS3_PIN, ms3); break;
       #endif
-      #if HAS_W_MS_PINS
-        case  W_AXIS: WRITE(W_MS3_PIN, ms3); break
+      #if HAS_W_MS_PINS && PIN_EXISTS(W_MS3)
+        case  W_AXIS: WRITE(W_MS3_PIN, ms3); break;
       #endif
       #if HAS_E0_MS_PINS && PIN_EXISTS(E0_MS3)
         case  E_AXIS: WRITE(E0_MS3_PIN, ms3); break;

commit 3ef192e7c7b18804ec7e3964a1366bd08355dc93
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 23 16:05:41 2024 -0600

    🎨 Cosmetic cleanup 23-01

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 8d55d37b96..0ae6ccb9a7 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2597,20 +2597,16 @@ hal_timer_t Stepper::block_phase_isr() {
 
       AxisBits didmove;
       NUM_AXIS_CODE(
-        if (X_MOVE_TEST)            didmove.a = true,
-        if (Y_MOVE_TEST)            didmove.b = true,
-        if (Z_MOVE_TEST)            didmove.c = true,
-        if (current_block->steps.i) didmove.i = true,
-        if (current_block->steps.j) didmove.j = true,
-        if (current_block->steps.k) didmove.k = true,
-        if (current_block->steps.u) didmove.u = true,
-        if (current_block->steps.v) didmove.v = true,
-        if (current_block->steps.w) didmove.w = true
+        if (X_MOVE_TEST)              didmove.a = true,
+        if (Y_MOVE_TEST)              didmove.b = true,
+        if (Z_MOVE_TEST)              didmove.c = true,
+        if (!!current_block->steps.i) didmove.i = true,
+        if (!!current_block->steps.j) didmove.j = true,
+        if (!!current_block->steps.k) didmove.k = true,
+        if (!!current_block->steps.u) didmove.u = true,
+        if (!!current_block->steps.v) didmove.v = true,
+        if (!!current_block->steps.w) didmove.w = true
       );
-      //if (current_block->steps.e) didmove.e = true;
-      //if (current_block->steps.a) didmove.x = true;
-      //if (current_block->steps.b) didmove.y = true;
-      //if (current_block->steps.c) didmove.z = true;
       axis_did_move = didmove;
 
       // No acceleration / deceleration time elapsed so far

commit b106f59eb495718d7158e27347eca5deb11fbe86
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Mon Jan 8 05:17:43 2024 +0100

    🐛 Refine FT Motion, I2S Stepping (#26628)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 552b7cb34a..8d55d37b96 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1508,14 +1508,12 @@ void Stepper::isr() {
     #if ENABLED(FT_MOTION)
 
       if (using_ftMotion) {
-        if (!nextMainISR) {
-          nextMainISR = FTM_MIN_TICKS;
-          ftMotion_stepper();
-          endstops.update();
-          TERN_(BABYSTEPPING, if (babystep.has_steps()) babystepping_isr());
+        if (!nextMainISR) {               // Main ISR is ready to fire during this iteration?
+          nextMainISR = FTM_MIN_TICKS;    // Set to minimum interval (a limit on the top speed)
+          ftMotion_stepper();             // Run FTM Stepping
         }
-        interval = nextMainISR;
-        nextMainISR -= interval;
+        interval = nextMainISR;           // Interval is either some old nextMainISR or FTM_MIN_TICKS
+        nextMainISR = 0;                  // For FT Motion fire again ASAP
       }
 
     #endif
@@ -3448,7 +3446,8 @@ void Stepper::report_positions() {
     // Use one byte to restore one stepper command in the format:
     // |X_step|X_direction|Y_step|Y_direction|Z_step|Z_direction|E_step|E_direction|
     const ft_command_t command = ftMotion.stepperCmdBuff[ftMotion.stepperCmdBuff_consumeIdx];
-    if (++ftMotion.stepperCmdBuff_consumeIdx == (FTM_STEPPERCMD_BUFF_SIZE)) ftMotion.stepperCmdBuff_consumeIdx = 0U;
+    if (++ftMotion.stepperCmdBuff_consumeIdx == (FTM_STEPPERCMD_BUFF_SIZE))
+      ftMotion.stepperCmdBuff_consumeIdx = 0;
 
     if (abort_current_block) return;
 
@@ -3492,6 +3491,8 @@ void Stepper::report_positions() {
       U_APPLY_STEP(axis_did_move.u, false), V_APPLY_STEP(axis_did_move.v, false), W_APPLY_STEP(axis_did_move.w, false)
     );
 
+    TERN_(I2S_STEPPER_STREAM, i2s_push_sample());
+
     // Begin waiting for the minimum pulse duration
     START_TIMED_PULSE();
 
@@ -3533,6 +3534,12 @@ void Stepper::report_positions() {
       U_APPLY_STEP(!STEP_STATE_U, false), V_APPLY_STEP(!STEP_STATE_V, false), W_APPLY_STEP(!STEP_STATE_W, false)
     );
 
+    // Check endstops on every step
+    IF_DISABLED(ENDSTOP_INTERRUPTS_FEATURE, endstops.update());
+
+    // Also handle babystepping here
+    TERN_(BABYSTEPPING, if (babystep.has_steps()) babystepping_isr());
+
   } // Stepper::ftMotion_stepper
 
   void Stepper::ftMotion_blockQueueUpdate() {

commit 5987a5464bc8622d77ab52990b88d5ae035074e1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 7 19:34:34 2024 -0600

    🎨 Use float CEIL/FLOOR

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 9c1668619b..552b7cb34a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3161,7 +3161,7 @@ void Stepper::init() {
       factor2 += -7.58095488 * zeta2;
       const float zeta3 = zeta2 * zeta;
       factor2 += 43.073216 * zeta3;
-      factor2 = floor(factor2);
+      factor2 = FLOOR(factor2);
     }
 
     const bool was_on = hal.isr_state();

commit 89fdfcfaf9df44b0782d3ef900aa28531d777058
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sun Dec 24 19:37:20 2023 -0800

    🩹 Fix MARKFORGED_INVERSE typos (#26558)
    
    Followup to #26516

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 8dda2eec40..9c1668619b 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3361,12 +3361,12 @@ void Stepper::endstop_triggered(const AxisEnum axis) {
       ) * double(0.5)
     #elif ENABLED(MARKFORGED_XY)
       axis == CORE_AXIS_1
-        ? count_position[CORE_AXIS_1] ENABLED(MARKFORGED_INVERSE, +, -) count_position[CORE_AXIS_2]
+        ? count_position[CORE_AXIS_1] TERN(MARKFORGED_INVERSE, +, -) count_position[CORE_AXIS_2]
         : count_position[CORE_AXIS_2]
     #elif ENABLED(MARKFORGED_YX)
       axis == CORE_AXIS_1
         ? count_position[CORE_AXIS_1]
-        : count_position[CORE_AXIS_2] ENABLED(MARKFORGED_INVERSE, +, -) count_position[CORE_AXIS_1]
+        : count_position[CORE_AXIS_2] TERN(MARKFORGED_INVERSE, +, -) count_position[CORE_AXIS_1]
     #else // !IS_CORE
       count_position[axis]
     #endif

commit 205b0a679e3ca7cbf7ca590279d1cd4ed0c284c1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Dec 23 04:19:23 2023 -0600

    🎨 Whitespace in the rightplace

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 862b272804..8dda2eec40 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3552,7 +3552,7 @@ void Stepper::report_positions() {
       // Sync block? Sync the stepper counts and return
       while (current_block->is_sync()) {
         TERN_(LASER_FEATURE, if (!(current_block->is_fan_sync() || current_block->is_pwr_sync()))) _set_position(current_block->position);
-        
+
         planner.release_current_block();
 
         // Try to get a new block

commit 67d7562609986fae14d80036ad1e7a7f3aaa49d0
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Wed Dec 20 02:56:47 2023 +0100

    🐛⚡️ FT_MOTION improvements (#26074)
    
    Co-Authored-By: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c68db6bb89..862b272804 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1492,11 +1492,6 @@ void Stepper::isr() {
   uint8_t max_loops = 10;
 
   #if ENABLED(FT_MOTION)
-    static bool ftMotion_stepCmdRdy = false;    // Indicates a step command was loaded from the
-                                                //  buffers and is ready to be output.
-    static bool ftMotion_applyDir = false;      // Indicates the DIR output should be set.
-    static ft_command_t ftMotion_stepCmd = 0U;  // Storage for the step command to be output.
-    static uint32_t ftMotion_nextAuxISR = 0U;   // Storage for the next ISR of the auxilliary tasks.
     const bool using_ftMotion = ftMotion.cfg.mode;
   #else
     constexpr bool using_ftMotion = false;
@@ -1508,57 +1503,19 @@ void Stepper::isr() {
     // Enable ISRs to reduce USART processing latency
     hal.isr_on();
 
-    hal_timer_t interval;
+    hal_timer_t interval = 0;
 
     #if ENABLED(FT_MOTION)
 
       if (using_ftMotion) {
         if (!nextMainISR) {
-          if (abort_current_block) {
-            ftMotion_stepCmdRdy = false; // If a command was ready, cancel it.
-            ftMotion.sts_stepperBusy = false; // Set busy false to allow a reset.
-            nextMainISR = 0.01f * (STEPPER_TIMER_RATE); // Come back in 10 msec.
-          }
-          else { // !(abort_current_block)
-            if (ftMotion_stepCmdRdy) {
-              ftMotion_stepper(ftMotion_applyDir, ftMotion_stepCmd);
-              ftMotion_stepCmdRdy = false;
-            }
-            // Check if there is data in the buffers.
-            if (ftMotion.stepperCmdBuff_produceIdx != ftMotion.stepperCmdBuff_consumeIdx) {
-
-              ftMotion.sts_stepperBusy = true;
-
-              // "Pop" one command from the command buffer.
-              ftMotion_stepCmd = ftMotion.stepperCmdBuff[ftMotion.stepperCmdBuff_consumeIdx];
-              const uint8_t dir_index = ftMotion.stepperCmdBuff_consumeIdx >> 3,
-                            dir_bit = ftMotion.stepperCmdBuff_consumeIdx & 0x7;
-              ftMotion_applyDir = TEST(ftMotion.stepperCmdBuff_ApplyDir[dir_index], dir_bit);
-              nextMainISR = ftMotion.stepperCmdBuff_StepRelativeTi[ftMotion.stepperCmdBuff_consumeIdx];
-              ftMotion_stepCmdRdy = true;
-
-              if (++ftMotion.stepperCmdBuff_consumeIdx == (FTM_STEPPERCMD_BUFF_SIZE))
-                ftMotion.stepperCmdBuff_consumeIdx = 0;
-
-            }
-            else { // Buffer empty.
-              ftMotion.sts_stepperBusy = false;
-              nextMainISR = 0.01f * (STEPPER_TIMER_RATE); // Come back in 10 msec.
-            }
-          } // !(abort_current_block)
-        } // if (!nextMainISR)
-
-        // Define 2.5 msec task for auxiliary functions.
-        if (!ftMotion_nextAuxISR) {
+          nextMainISR = FTM_MIN_TICKS;
+          ftMotion_stepper();
           endstops.update();
           TERN_(BABYSTEPPING, if (babystep.has_steps()) babystepping_isr());
-          ftMotion_refreshAxisDidMove();
-          ftMotion_nextAuxISR = 0.0025f * (STEPPER_TIMER_RATE);
         }
-
-        interval = _MIN(nextMainISR, ftMotion_nextAuxISR);
+        interval = nextMainISR;
         nextMainISR -= interval;
-        ftMotion_nextAuxISR -= interval;
       }
 
     #endif
@@ -3365,6 +3322,28 @@ void Stepper::set_axis_position(const AxisEnum a, const int32_t &v) {
   #endif
 }
 
+#if ENABLED(FT_MOTION)
+
+  void Stepper::ftMotion_syncPosition() {
+    //planner.synchronize(); planner already synchronized in M493
+
+    #ifdef __AVR__
+      // Protect the access to the position. Only required for AVR, as
+      //  any 32bit CPU offers atomic access to 32bit variables
+      const bool was_enabled = suspend();
+    #endif
+
+    // Update stepper positions from the planner
+    count_position = planner.position;
+
+    #ifdef __AVR__
+      // Reenable Stepper ISR
+      if (was_enabled) wake_up();
+    #endif
+  }
+
+#endif // FT_MOTION
+
 // Signal endstops were triggered - This function can be called from
 // an ISR context  (Temperature, Stepper or limits ISR), so we must
 // be very careful here. If the interrupt being preempted was the
@@ -3459,65 +3438,70 @@ void Stepper::report_positions() {
 #if ENABLED(FT_MOTION)
 
   // Set stepper I/O for fixed time controller.
-  void Stepper::ftMotion_stepper(const bool applyDir, const ft_command_t command) {
+  void Stepper::ftMotion_stepper() {
+
+    // Check if the buffer is empty.
+    ftMotion.sts_stepperBusy = (ftMotion.stepperCmdBuff_produceIdx != ftMotion.stepperCmdBuff_consumeIdx);
+    if (!ftMotion.sts_stepperBusy) return;
+
+    // "Pop" one command from current motion buffer
+    // Use one byte to restore one stepper command in the format:
+    // |X_step|X_direction|Y_step|Y_direction|Z_step|Z_direction|E_step|E_direction|
+    const ft_command_t command = ftMotion.stepperCmdBuff[ftMotion.stepperCmdBuff_consumeIdx];
+    if (++ftMotion.stepperCmdBuff_consumeIdx == (FTM_STEPPERCMD_BUFF_SIZE)) ftMotion.stepperCmdBuff_consumeIdx = 0U;
+
+    if (abort_current_block) return;
 
     USING_TIMED_PULSE();
 
-    const xyze_bool_t axis_step = LOGICAL_AXIS_ARRAY(
+    axis_did_move = LOGICAL_AXIS_ARRAY(
       TEST(command, FT_BIT_STEP_E),
       TEST(command, FT_BIT_STEP_X), TEST(command, FT_BIT_STEP_Y), TEST(command, FT_BIT_STEP_Z),
       TEST(command, FT_BIT_STEP_I), TEST(command, FT_BIT_STEP_J), TEST(command, FT_BIT_STEP_K),
       TEST(command, FT_BIT_STEP_U), TEST(command, FT_BIT_STEP_V), TEST(command, FT_BIT_STEP_W)
     );
 
+    last_direction_bits = LOGICAL_AXIS_ARRAY(
+      axis_did_move.e ? TEST(command, FT_BIT_DIR_E) : last_direction_bits.e,
+      axis_did_move.x ? TEST(command, FT_BIT_DIR_X) : last_direction_bits.x,
+      axis_did_move.y ? TEST(command, FT_BIT_DIR_Y) : last_direction_bits.y,
+      axis_did_move.z ? TEST(command, FT_BIT_DIR_Z) : last_direction_bits.z,
+      axis_did_move.i ? TEST(command, FT_BIT_DIR_I) : last_direction_bits.i,
+      axis_did_move.j ? TEST(command, FT_BIT_DIR_J) : last_direction_bits.j,
+      axis_did_move.k ? TEST(command, FT_BIT_DIR_K) : last_direction_bits.k,
+      axis_did_move.u ? TEST(command, FT_BIT_DIR_U) : last_direction_bits.u,
+      axis_did_move.v ? TEST(command, FT_BIT_DIR_V) : last_direction_bits.v,
+      axis_did_move.w ? TEST(command, FT_BIT_DIR_W) : last_direction_bits.w
+    );
+
     // Apply directions (which will apply to the entire linear move)
-    AxisBits axis_dir = last_direction_bits;
-    if (applyDir) {
-      axis_dir = LOGICAL_AXIS_ARRAY(
-        TEST(command, FT_BIT_DIR_E),
-        TEST(command, FT_BIT_DIR_X), TEST(command, FT_BIT_DIR_Y), TEST(command, FT_BIT_DIR_Z),
-        TEST(command, FT_BIT_DIR_I), TEST(command, FT_BIT_DIR_J), TEST(command, FT_BIT_DIR_K),
-        TEST(command, FT_BIT_DIR_U), TEST(command, FT_BIT_DIR_V), TEST(command, FT_BIT_DIR_W)
-      );
-      LOGICAL_AXIS_CODE(
-        E_APPLY_DIR(axis_dir.e, false),
-        X_APPLY_DIR(axis_dir.x, false), Y_APPLY_DIR(axis_dir.y, false), Z_APPLY_DIR(axis_dir.z, false),
-        I_APPLY_DIR(axis_dir.i, false), J_APPLY_DIR(axis_dir.j, false), K_APPLY_DIR(axis_dir.k, false),
-        U_APPLY_DIR(axis_dir.u, false), V_APPLY_DIR(axis_dir.v, false), W_APPLY_DIR(axis_dir.w, false)
-      );
-      last_direction_bits = axis_dir;
-      DIR_WAIT_AFTER();
-    }
+    LOGICAL_AXIS_CODE(
+      E_APPLY_DIR(last_direction_bits.e, false),
+      X_APPLY_DIR(last_direction_bits.x, false), Y_APPLY_DIR(last_direction_bits.y, false), Z_APPLY_DIR(last_direction_bits.z, false),
+      I_APPLY_DIR(last_direction_bits.i, false), J_APPLY_DIR(last_direction_bits.j, false), K_APPLY_DIR(last_direction_bits.k, false),
+      U_APPLY_DIR(last_direction_bits.u, false), V_APPLY_DIR(last_direction_bits.v, false), W_APPLY_DIR(last_direction_bits.w, false)
+    );
+
+    DIR_WAIT_AFTER();
 
     // Start a step pulse
     LOGICAL_AXIS_CODE(
-      if (axis_step.e) E_APPLY_STEP(STEP_STATE_E, false),
-      if (axis_step.x) X_APPLY_STEP(STEP_STATE_X, false), if (axis_step.y) Y_APPLY_STEP(STEP_STATE_Y, false),
-      if (axis_step.z) Z_APPLY_STEP(STEP_STATE_Z, false), if (axis_step.i) I_APPLY_STEP(STEP_STATE_I, false),
-      if (axis_step.j) J_APPLY_STEP(STEP_STATE_J, false), if (axis_step.k) K_APPLY_STEP(STEP_STATE_K, false),
-      if (axis_step.u) U_APPLY_STEP(STEP_STATE_U, false), if (axis_step.v) V_APPLY_STEP(STEP_STATE_V, false),
-      if (axis_step.w) W_APPLY_STEP(STEP_STATE_W, false)
+      E_APPLY_STEP(axis_did_move.e, false),
+      X_APPLY_STEP(axis_did_move.x, false), Y_APPLY_STEP(axis_did_move.y, false), Z_APPLY_STEP(axis_did_move.z, false),
+      I_APPLY_STEP(axis_did_move.i, false), J_APPLY_STEP(axis_did_move.j, false), K_APPLY_STEP(axis_did_move.k, false),
+      U_APPLY_STEP(axis_did_move.u, false), V_APPLY_STEP(axis_did_move.v, false), W_APPLY_STEP(axis_did_move.w, false)
     );
 
     // Begin waiting for the minimum pulse duration
     START_TIMED_PULSE();
 
-    // Update axis direction adders
-    count_direction = LOGICAL_AXIS_ARRAY(
-      int8_t(axis_dir.e ? 1 : -1),
-      int8_t(axis_dir.x ? 1 : -1), int8_t(axis_dir.y ? 1 : -1), int8_t(axis_dir.z ? 1 : -1),
-      int8_t(axis_dir.i ? 1 : -1), int8_t(axis_dir.j ? 1 : -1), int8_t(axis_dir.k ? 1 : -1),
-      int8_t(axis_dir.u ? 1 : -1), int8_t(axis_dir.v ? 1 : -1), int8_t(axis_dir.w ? 1 : -1)
-    );
-
-    // Update stepper counts - required for various operations
+    // Update step counts
     LOGICAL_AXIS_CODE(
-      if (axis_step.e) count_position.e += count_direction.e,
-      if (axis_step.x) count_position.x += count_direction.x, if (axis_step.y) count_position.y += count_direction.y,
-      if (axis_step.z) count_position.z += count_direction.z, if (axis_step.i) count_position.i += count_direction.i,
-      if (axis_step.j) count_position.j += count_direction.j, if (axis_step.k) count_position.k += count_direction.k,
-      if (axis_step.u) count_position.u += count_direction.u, if (axis_step.v) count_position.v += count_direction.v,
-      if (axis_step.w) count_position.w += count_direction.w
+      if (axis_did_move.e) count_position.e += last_direction_bits.e ? 1 : -1, if (axis_did_move.x) count_position.x += last_direction_bits.x ? 1 : -1,
+      if (axis_did_move.y) count_position.y += last_direction_bits.y ? 1 : -1, if (axis_did_move.z) count_position.z += last_direction_bits.z ? 1 : -1,
+      if (axis_did_move.i) count_position.i += last_direction_bits.i ? 1 : -1, if (axis_did_move.j) count_position.j += last_direction_bits.j ? 1 : -1,
+      if (axis_did_move.k) count_position.k += last_direction_bits.k ? 1 : -1, if (axis_did_move.u) count_position.u += last_direction_bits.u ? 1 : -1,
+      if (axis_did_move.v) count_position.v += last_direction_bits.v ? 1 : -1, if (axis_did_move.w) count_position.w += last_direction_bits.w ? 1 : -1
     );
 
     #if HAS_EXTRUDERS
@@ -3532,10 +3516,10 @@ void Stepper::report_positions() {
 
     // Only wait for axes without edge stepping
     const bool any_wait = false LOGICAL_AXIS_GANG(
-      || (!e_axis_has_dedge && axis_step.e),
-      || (!AXIS_HAS_DEDGE(X) && axis_step.x), || (!AXIS_HAS_DEDGE(Y) && axis_step.y), || (!AXIS_HAS_DEDGE(Z) && axis_step.z),
-      || (!AXIS_HAS_DEDGE(I) && axis_step.i), || (!AXIS_HAS_DEDGE(J) && axis_step.j), || (!AXIS_HAS_DEDGE(K) && axis_step.k),
-      || (!AXIS_HAS_DEDGE(U) && axis_step.u), || (!AXIS_HAS_DEDGE(V) && axis_step.v), || (!AXIS_HAS_DEDGE(W) && axis_step.w)
+      || (!e_axis_has_dedge && axis_did_move.e),
+      || (!AXIS_HAS_DEDGE(X) && axis_did_move.x), || (!AXIS_HAS_DEDGE(Y) && axis_did_move.y), || (!AXIS_HAS_DEDGE(Z) && axis_did_move.z),
+      || (!AXIS_HAS_DEDGE(I) && axis_did_move.i), || (!AXIS_HAS_DEDGE(J) && axis_did_move.j), || (!AXIS_HAS_DEDGE(K) && axis_did_move.k),
+      || (!AXIS_HAS_DEDGE(U) && axis_did_move.u), || (!AXIS_HAS_DEDGE(V) && axis_did_move.v), || (!AXIS_HAS_DEDGE(W) && axis_did_move.w)
     );
 
     // Allow pulses to be registered by stepper drivers
@@ -3543,80 +3527,46 @@ void Stepper::report_positions() {
 
     // Stop pulses. Axes with DEDGE will do nothing, assuming STEP_STATE_* is HIGH
     LOGICAL_AXIS_CODE(
-      if (axis_step.e) E_APPLY_STEP(!STEP_STATE_E, false),
-      if (axis_step.x) X_APPLY_STEP(!STEP_STATE_X, false), if (axis_step.y) Y_APPLY_STEP(!STEP_STATE_Y, false),
-      if (axis_step.z) Z_APPLY_STEP(!STEP_STATE_Z, false), if (axis_step.i) I_APPLY_STEP(!STEP_STATE_I, false),
-      if (axis_step.j) J_APPLY_STEP(!STEP_STATE_J, false), if (axis_step.k) K_APPLY_STEP(!STEP_STATE_K, false),
-      if (axis_step.u) U_APPLY_STEP(!STEP_STATE_U, false), if (axis_step.v) V_APPLY_STEP(!STEP_STATE_V, false),
-      if (axis_step.w) W_APPLY_STEP(!STEP_STATE_W, false)
+      E_APPLY_STEP(!STEP_STATE_E, false),
+      X_APPLY_STEP(!STEP_STATE_X, false), Y_APPLY_STEP(!STEP_STATE_Y, false), Z_APPLY_STEP(!STEP_STATE_Z, false),
+      I_APPLY_STEP(!STEP_STATE_I, false), J_APPLY_STEP(!STEP_STATE_J, false), K_APPLY_STEP(!STEP_STATE_K, false),
+      U_APPLY_STEP(!STEP_STATE_U, false), V_APPLY_STEP(!STEP_STATE_V, false), W_APPLY_STEP(!STEP_STATE_W, false)
     );
 
   } // Stepper::ftMotion_stepper
 
-  void Stepper::ftMotion_BlockQueueUpdate() {
+  void Stepper::ftMotion_blockQueueUpdate() {
 
     if (current_block) {
       // If the current block is not done processing, return right away
       if (!ftMotion.getBlockProcDn()) return;
 
       axis_did_move.reset();
-      current_block = nullptr;
-      discard_current_block();
+      planner.release_current_block();
     }
 
-    if (!current_block) { // No current block
-
-      // Check the buffer for a new block
-      current_block = planner.get_current_block();
-
-      if (current_block) {
-        // Sync block? Sync the stepper counts and return
-        while (current_block->is_sync()) {
-          if (!(current_block->is_fan_sync() || current_block->is_pwr_sync())) _set_position(current_block->position);
-          discard_current_block();
-
-          // Try to get a new block
-          if (!(current_block = planner.get_current_block()))
-            return; // No more queued movements!image.png
-        }
+    // Check the buffer for a new block
+    current_block = planner.get_current_block();
 
-        // this is needed by motor_direction() and subsequently bed leveling (somehow)
-        // update it here, even though it will may be out of sync with step commands
-        last_direction_bits = current_block->direction_bits;
-
-        ftMotion.startBlockProc(current_block);
+    if (current_block) {
+      // Sync block? Sync the stepper counts and return
+      while (current_block->is_sync()) {
+        TERN_(LASER_FEATURE, if (!(current_block->is_fan_sync() || current_block->is_pwr_sync()))) _set_position(current_block->position);
+        
+        planner.release_current_block();
 
-      }
-      else {
-        ftMotion.runoutBlock();
-        return; // No queued blocks
+        // Try to get a new block
+        if (!(current_block = planner.get_current_block()))
+          return; // No queued blocks.
       }
 
-    } // if (!current_block)
-
-  } // Stepper::ftMotion_BlockQueueUpdate()
-
-  // Debounces the axis move indication to account for potential
-  // delay between the block information and the stepper commands
-  void Stepper::ftMotion_refreshAxisDidMove() {
-
-    // Set the debounce time in seconds.
-    #define AXIS_DID_MOVE_DEB 5 // TODO: The debounce time should be calculated if possible,
-                                // or the set conditions should be changed from the block to
-                                // the motion trajectory or motor commands.
-
-    AxisBits didmove;
-    static abce_ulong_t debounce{0};
-    auto debounce_axis = [&](const AxisEnum axis) {
-      if (current_block->steps[axis]) debounce[axis] = (AXIS_DID_MOVE_DEB) * 400; // divide by 0.0025f */
-      if (debounce[axis]) { didmove.bset(axis); debounce[axis]--; }
-    };
-    #define _DEBOUNCE(N) debounce_axis(AxisEnum(N));
+      ftMotion.startBlockProc();
+      return;
+    }
 
-    if (current_block) { REPEAT(LOGICAL_AXES, _DEBOUNCE); }
+    ftMotion.runoutBlock();
 
-    axis_did_move = didmove;
-  }
+  } // Stepper::ftMotion_blockQueueUpdate()
 
 #endif // FT_MOTION
 

commit fef74398e41a1b492792837941af55057eb694f5
Author: jesterhead82 <mclauss82@gmail.com>
Date:   Wed Dec 13 08:44:11 2023 +0100

    ✨ MARKFORGED_INVERSE (#26516)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index a6c628e081..c68db6bb89 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3287,9 +3287,9 @@ void Stepper::_set_position(const abce_long_t &spos) {
       // coreyz planning
       count_position.set(spos.a, spos.b + spos.c, CORESIGN(spos.b - spos.c));
     #elif ENABLED(MARKFORGED_XY)
-      count_position.set(spos.a - spos.b, spos.b, spos.c);
+      count_position.set(spos.a TERN(MARKFORGED_INVERSE, +, -) spos.b, spos.b, spos.c);
     #elif ENABLED(MARKFORGED_YX)
-      count_position.set(spos.a, spos.b - spos.a, spos.c);
+      count_position.set(spos.a, spos.b TERN(MARKFORGED_INVERSE, +, -) spos.a, spos.c);
     #endif
     SECONDARY_AXIS_CODE(
       count_position.i = spos.i,
@@ -3382,12 +3382,12 @@ void Stepper::endstop_triggered(const AxisEnum axis) {
       ) * double(0.5)
     #elif ENABLED(MARKFORGED_XY)
       axis == CORE_AXIS_1
-        ? count_position[CORE_AXIS_1] - count_position[CORE_AXIS_2]
+        ? count_position[CORE_AXIS_1] ENABLED(MARKFORGED_INVERSE, +, -) count_position[CORE_AXIS_2]
         : count_position[CORE_AXIS_2]
     #elif ENABLED(MARKFORGED_YX)
       axis == CORE_AXIS_1
         ? count_position[CORE_AXIS_1]
-        : count_position[CORE_AXIS_2] - count_position[CORE_AXIS_1]
+        : count_position[CORE_AXIS_2] ENABLED(MARKFORGED_INVERSE, +, -) count_position[CORE_AXIS_1]
     #else // !IS_CORE
       count_position[axis]
     #endif

commit e7e77d9612253cf7106cfc9e69f69e52f4083294
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 12 09:44:46 2023 -0500

    🧑‍💻 FxdTiCtrl => FTMotion

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 6077154cd2..a6c628e081 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1492,11 +1492,14 @@ void Stepper::isr() {
   uint8_t max_loops = 10;
 
   #if ENABLED(FT_MOTION)
-    static bool fxdTiCtrl_stepCmdRdy = false;   // Indicates a step command was loaded from the
-                                                // buffers and is ready to be output.
-    static bool fxdTiCtrl_applyDir = false;     // Indicates the DIR output should be set.
-    static ft_command_t fxdTiCtrl_stepCmd = 0U; // Storage for the step command to be output.
-    static uint32_t fxdTiCtrl_nextAuxISR = 0U;  // Storage for the next ISR of the auxilliary tasks.
+    static bool ftMotion_stepCmdRdy = false;    // Indicates a step command was loaded from the
+                                                //  buffers and is ready to be output.
+    static bool ftMotion_applyDir = false;      // Indicates the DIR output should be set.
+    static ft_command_t ftMotion_stepCmd = 0U;  // Storage for the step command to be output.
+    static uint32_t ftMotion_nextAuxISR = 0U;   // Storage for the next ISR of the auxilliary tasks.
+    const bool using_ftMotion = ftMotion.cfg.mode;
+  #else
+    constexpr bool using_ftMotion = false;
   #endif
 
   // We need this variable here to be able to use it in the following loop
@@ -1509,64 +1512,58 @@ void Stepper::isr() {
 
     #if ENABLED(FT_MOTION)
 
-      // NOTE STEPPER_TIMER_RATE is equal to 2000000, not what VSCode shows
-      const bool using_fxtictrl = fxdTiCtrl.cfg.mode;
-      if (using_fxtictrl) {
+      if (using_ftMotion) {
         if (!nextMainISR) {
           if (abort_current_block) {
-            fxdTiCtrl_stepCmdRdy = false; // If a command was ready, cancel it.
-            fxdTiCtrl.sts_stepperBusy = false; // Set busy false to allow a reset.
+            ftMotion_stepCmdRdy = false; // If a command was ready, cancel it.
+            ftMotion.sts_stepperBusy = false; // Set busy false to allow a reset.
             nextMainISR = 0.01f * (STEPPER_TIMER_RATE); // Come back in 10 msec.
           }
           else { // !(abort_current_block)
-            if (fxdTiCtrl_stepCmdRdy) {
-              fxdTiCtrl_stepper(fxdTiCtrl_applyDir, fxdTiCtrl_stepCmd);
-              fxdTiCtrl_stepCmdRdy = false;
+            if (ftMotion_stepCmdRdy) {
+              ftMotion_stepper(ftMotion_applyDir, ftMotion_stepCmd);
+              ftMotion_stepCmdRdy = false;
             }
             // Check if there is data in the buffers.
-            if (fxdTiCtrl.stepperCmdBuff_produceIdx != fxdTiCtrl.stepperCmdBuff_consumeIdx) {
+            if (ftMotion.stepperCmdBuff_produceIdx != ftMotion.stepperCmdBuff_consumeIdx) {
 
-              fxdTiCtrl.sts_stepperBusy = true;
+              ftMotion.sts_stepperBusy = true;
 
               // "Pop" one command from the command buffer.
-              fxdTiCtrl_stepCmd = fxdTiCtrl.stepperCmdBuff[fxdTiCtrl.stepperCmdBuff_consumeIdx];
-              const uint8_t dir_index = fxdTiCtrl.stepperCmdBuff_consumeIdx >> 3,
-                            dir_bit = fxdTiCtrl.stepperCmdBuff_consumeIdx & 0x7;
-              fxdTiCtrl_applyDir = TEST(fxdTiCtrl.stepperCmdBuff_ApplyDir[dir_index], dir_bit);
-              nextMainISR = fxdTiCtrl.stepperCmdBuff_StepRelativeTi[fxdTiCtrl.stepperCmdBuff_consumeIdx];
-              fxdTiCtrl_stepCmdRdy = true;
+              ftMotion_stepCmd = ftMotion.stepperCmdBuff[ftMotion.stepperCmdBuff_consumeIdx];
+              const uint8_t dir_index = ftMotion.stepperCmdBuff_consumeIdx >> 3,
+                            dir_bit = ftMotion.stepperCmdBuff_consumeIdx & 0x7;
+              ftMotion_applyDir = TEST(ftMotion.stepperCmdBuff_ApplyDir[dir_index], dir_bit);
+              nextMainISR = ftMotion.stepperCmdBuff_StepRelativeTi[ftMotion.stepperCmdBuff_consumeIdx];
+              ftMotion_stepCmdRdy = true;
 
-              if (++fxdTiCtrl.stepperCmdBuff_consumeIdx == (FTM_STEPPERCMD_BUFF_SIZE))
-                fxdTiCtrl.stepperCmdBuff_consumeIdx = 0;
+              if (++ftMotion.stepperCmdBuff_consumeIdx == (FTM_STEPPERCMD_BUFF_SIZE))
+                ftMotion.stepperCmdBuff_consumeIdx = 0;
 
             }
             else { // Buffer empty.
-              fxdTiCtrl.sts_stepperBusy = false;
+              ftMotion.sts_stepperBusy = false;
               nextMainISR = 0.01f * (STEPPER_TIMER_RATE); // Come back in 10 msec.
             }
           } // !(abort_current_block)
         } // if (!nextMainISR)
 
-        // Define 2.5 msec task for auxilliary functions.
-        if (!fxdTiCtrl_nextAuxISR) {
+        // Define 2.5 msec task for auxiliary functions.
+        if (!ftMotion_nextAuxISR) {
           endstops.update();
           TERN_(BABYSTEPPING, if (babystep.has_steps()) babystepping_isr());
-          fxdTiCtrl_refreshAxisDidMove();
-          fxdTiCtrl_nextAuxISR = 0.0025f * (STEPPER_TIMER_RATE);
+          ftMotion_refreshAxisDidMove();
+          ftMotion_nextAuxISR = 0.0025f * (STEPPER_TIMER_RATE);
         }
 
-        interval = _MIN(nextMainISR, fxdTiCtrl_nextAuxISR);
+        interval = _MIN(nextMainISR, ftMotion_nextAuxISR);
         nextMainISR -= interval;
-        fxdTiCtrl_nextAuxISR -= interval;
+        ftMotion_nextAuxISR -= interval;
       }
 
-    #else
-
-      constexpr bool using_fxtictrl = false;
-
     #endif
 
-    if (!using_fxtictrl) {
+    if (!using_ftMotion) {
 
       TERN_(HAS_ZV_SHAPING, shaping_isr());               // Do Shaper stepping, if needed
 
@@ -3436,12 +3433,8 @@ void Stepper::report_a_position(const xyz_long_t &pos) {
         TERN(SAYS_A, PSTR(STR_COUNT_A), PSTR(STR_COUNT_X)), pos.x,
         TERN(SAYS_B, PSTR("B:"), SP_Y_LBL), pos.y,
         TERN(SAYS_C, PSTR("C:"), SP_Z_LBL), pos.z,
-        SP_I_LBL, pos.i,
-        SP_J_LBL, pos.j,
-        SP_K_LBL, pos.k,
-        SP_U_LBL, pos.u,
-        SP_V_LBL, pos.v,
-        SP_W_LBL, pos.w
+        SP_I_LBL, pos.i, SP_J_LBL, pos.j, SP_K_LBL, pos.k,
+        SP_U_LBL, pos.u, SP_V_LBL, pos.v, SP_W_LBL, pos.w
       )
     );
   #endif
@@ -3466,7 +3459,7 @@ void Stepper::report_positions() {
 #if ENABLED(FT_MOTION)
 
   // Set stepper I/O for fixed time controller.
-  void Stepper::fxdTiCtrl_stepper(const bool applyDir, const ft_command_t command) {
+  void Stepper::ftMotion_stepper(const bool applyDir, const ft_command_t command) {
 
     USING_TIMED_PULSE();
 
@@ -3558,13 +3551,13 @@ void Stepper::report_positions() {
       if (axis_step.w) W_APPLY_STEP(!STEP_STATE_W, false)
     );
 
-  } // Stepper::fxdTiCtrl_stepper
+  } // Stepper::ftMotion_stepper
 
-  void Stepper::fxdTiCtrl_BlockQueueUpdate() {
+  void Stepper::ftMotion_BlockQueueUpdate() {
 
     if (current_block) {
       // If the current block is not done processing, return right away
-      if (!fxdTiCtrl.getBlockProcDn()) return;
+      if (!ftMotion.getBlockProcDn()) return;
 
       axis_did_move.reset();
       current_block = nullptr;
@@ -3591,21 +3584,21 @@ void Stepper::report_positions() {
         // update it here, even though it will may be out of sync with step commands
         last_direction_bits = current_block->direction_bits;
 
-        fxdTiCtrl.startBlockProc(current_block);
+        ftMotion.startBlockProc(current_block);
 
       }
       else {
-        fxdTiCtrl.runoutBlock();
+        ftMotion.runoutBlock();
         return; // No queued blocks
       }
 
     } // if (!current_block)
 
-  } // Stepper::fxdTiCtrl_BlockQueueUpdate()
+  } // Stepper::ftMotion_BlockQueueUpdate()
 
   // Debounces the axis move indication to account for potential
   // delay between the block information and the stepper commands
-  void Stepper::fxdTiCtrl_refreshAxisDidMove() {
+  void Stepper::ftMotion_refreshAxisDidMove() {
 
     // Set the debounce time in seconds.
     #define AXIS_DID_MOVE_DEB 5 // TODO: The debounce time should be calculated if possible,

commit e9b9d634c4ef5d48791de84545ef86d46909fec0
Author: Andrew Bortz <andrew@abortz.net>
Date:   Tue Oct 10 20:24:48 2023 -0700

    ✨ Nonlinear Extrusion Control (M592) (#26127)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 9bafe7443d..6077154cd2 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -245,6 +245,13 @@ uint32_t Stepper::advance_divisor = 0,
   bool        Stepper::la_active = false;
 #endif
 
+#if ENABLED(NONLINEAR_EXTRUSION)
+  ne_coeff_t Stepper::ne;
+  ne_fix_t Stepper::ne_fix;
+  int32_t Stepper::ne_edividend;
+  uint32_t Stepper::ne_scale;
+#endif
+
 #if HAS_ZV_SHAPING
   shaping_time_t      ShapingQueue::now = 0;
   #if ANY(MCU_LPC1768, MCU_LPC1769) && DISABLED(NO_LPC_ETHERNET_BUFFER)
@@ -2191,6 +2198,16 @@ hal_timer_t Stepper::calc_timer_interval(uint32_t step_rate) {
   #endif // !CPU_32_BIT
 }
 
+#if ENABLED(NONLINEAR_EXTRUSION)
+  void Stepper::calc_nonlinear_e(uint32_t step_rate) {
+    const uint32_t velocity = ne_scale * step_rate; // Scale step_rate first so all intermediate values stay in range of 8.24 fixed point math
+    int32_t vd = (((int64_t)ne_fix.A * velocity) >> 24) + (((((int64_t)ne_fix.B * velocity) >> 24) * velocity) >> 24);
+    NOLESS(vd, 0);
+
+    advance_dividend.e = (uint64_t(ne_fix.C + vd) * ne_edividend) >> 24;
+  }
+#endif
+
 // Get the timer interval and the number of loops to perform per tick
 hal_timer_t Stepper::calc_multistep_timer_interval(uint32_t step_rate) {
 
@@ -2318,6 +2335,10 @@ hal_timer_t Stepper::block_phase_isr() {
         interval = calc_multistep_timer_interval(acc_step_rate << oversampling_factor);
         acceleration_time += interval;
 
+        #if ENABLED(NONLINEAR_EXTRUSION)
+          calc_nonlinear_e(acc_step_rate << oversampling_factor);
+        #endif
+
         #if ENABLED(LIN_ADVANCE)
           if (la_active) {
             const uint32_t la_step_rate = la_advance_steps < current_block->max_adv_steps ? current_block->la_advance_rate : 0;
@@ -2388,6 +2409,10 @@ hal_timer_t Stepper::block_phase_isr() {
         interval = calc_multistep_timer_interval(step_rate << oversampling_factor);
         deceleration_time += interval;
 
+        #if ENABLED(NONLINEAR_EXTRUSION)
+          calc_nonlinear_e(step_rate << oversampling_factor);
+        #endif
+
         #if ENABLED(LIN_ADVANCE)
           if (la_active) {
             const uint32_t la_step_rate = la_advance_steps > current_block->final_adv_steps ? current_block->la_advance_rate : 0;
@@ -2436,6 +2461,10 @@ hal_timer_t Stepper::block_phase_isr() {
           // step_rate to timer interval and loops for the nominal speed
           ticks_nominal = calc_multistep_timer_interval(current_block->nominal_rate << oversampling_factor);
 
+          #if ENABLED(NONLINEAR_EXTRUSION)
+            calc_nonlinear_e(current_block->nominal_rate << oversampling_factor);
+          #endif
+
           #if ENABLED(LIN_ADVANCE)
             if (la_active)
               la_interval = calc_timer_interval(current_block->nominal_rate >> current_block->la_scaling);
@@ -2636,10 +2665,13 @@ hal_timer_t Stepper::block_phase_isr() {
       acceleration_time = deceleration_time = 0;
 
       #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
-        oversampling_factor = 0;                            // Assume no axis smoothing (via oversampling)
+        // Nonlinear Extrusion needs at least 2x oversampling to permit increase of E step rate
+        // Otherwise assume no axis smoothing (via oversampling)
+        oversampling_factor = TERN(NONLINEAR_EXTRUSION, 1, 0);
+
         // Decide if axis smoothing is possible
-        uint32_t max_rate = current_block->nominal_rate;    // Get the step event rate
         if (TERN1(DWIN_LCD_PROUI, hmiData.adaptiveStepSmoothing)) {
+          uint32_t max_rate = current_block->nominal_rate;  // Get the step event rate
           while (max_rate < MIN_STEP_ISR_FREQUENCY) {       // As long as more ISRs are possible...
             max_rate <<= 1;                                 // Try to double the rate
             if (max_rate < MIN_STEP_ISR_FREQUENCY)          // Don't exceed the estimated ISR limit
@@ -2755,10 +2787,29 @@ hal_timer_t Stepper::block_phase_isr() {
         acc_step_rate = current_block->initial_rate;
       #endif
 
+      #if ENABLED(NONLINEAR_EXTRUSION)
+        ne_edividend = advance_dividend.e;
+        const float scale = (float(ne_edividend) / advance_divisor) * planner.mm_per_step[E_AXIS_N(current_block->extruder)];
+        ne_scale = (1L << 24) * scale;
+        if (current_block->direction_bits.e) {
+          ne_fix.A = (1L << 24) * ne.A;
+          ne_fix.B = (1L << 24) * ne.B;
+          ne_fix.C = (1L << 24) * ne.C;
+        }
+        else {
+          ne_fix.A = ne_fix.B = 0;
+          ne_fix.C = (1L << 24);
+        }
+      #endif
+
       // Calculate the initial timer interval
       interval = calc_multistep_timer_interval(current_block->initial_rate << oversampling_factor);
       acceleration_time += interval;
 
+      #if ENABLED(NONLINEAR_EXTRUSION)
+        calc_nonlinear_e(current_block->initial_rate << oversampling_factor);
+      #endif
+
       #if ENABLED(LIN_ADVANCE)
         if (la_active) {
           const uint32_t la_step_rate = la_advance_steps < current_block->max_adv_steps ? current_block->la_advance_rate : 0;

commit 45193b4a1d82023f1b763c0340e40ec5b6fcc51c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 19 21:12:32 2023 -0500

    🔥 Always use ISR for BABYSTEPPING (#26035)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index d1c8eef69c..9bafe7443d 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -106,7 +106,7 @@ Stepper stepper; // Singleton
   #include "../feature/bedlevel/bdl/bdl.h"
 #endif
 
-#if ENABLED(INTEGRATED_BABYSTEPPING)
+#if ENABLED(BABYSTEPPING)
   #include "../feature/babystep.h"
 #endif
 
@@ -273,7 +273,7 @@ uint32_t Stepper::advance_divisor = 0,
   #endif
 #endif
 
-#if ENABLED(INTEGRATED_BABYSTEPPING)
+#if ENABLED(BABYSTEPPING)
   hal_timer_t Stepper::nextBabystepISR = BABYSTEP_NEVER;
 #endif
 
@@ -1543,7 +1543,7 @@ void Stepper::isr() {
         // Define 2.5 msec task for auxilliary functions.
         if (!fxdTiCtrl_nextAuxISR) {
           endstops.update();
-          TERN_(INTEGRATED_BABYSTEPPING, if (babystep.has_steps()) babystepping_isr());
+          TERN_(BABYSTEPPING, if (babystep.has_steps()) babystepping_isr());
           fxdTiCtrl_refreshAxisDidMove();
           fxdTiCtrl_nextAuxISR = 0.0025f * (STEPPER_TIMER_RATE);
         }
@@ -1574,7 +1574,7 @@ void Stepper::isr() {
           nextAdvanceISR = la_interval;
       #endif
 
-      #if ENABLED(INTEGRATED_BABYSTEPPING)
+      #if ENABLED(BABYSTEPPING)
         const bool is_babystep = (nextBabystepISR == 0);  // 0 = Do Babystepping (XY)Z pulses
         if (is_babystep) nextBabystepISR = babystepping_isr();
       #endif
@@ -1583,7 +1583,7 @@ void Stepper::isr() {
 
       if (!nextMainISR) nextMainISR = block_phase_isr();  // Manage acc/deceleration, get next block
 
-      #if ENABLED(INTEGRATED_BABYSTEPPING)
+      #if ENABLED(BABYSTEPPING)
         if (is_babystep)                                  // Avoid ANY stepping too soon after baby-stepping
           NOLESS(nextMainISR, (BABYSTEP_TICKS) / 8);      // FULL STOP for 125µs after a baby-step
 
@@ -1596,7 +1596,7 @@ void Stepper::isr() {
       TERN_(INPUT_SHAPING_X, NOMORE(interval, ShapingQueue::peek_x()));   // Time until next input shaping echo for X
       TERN_(INPUT_SHAPING_Y, NOMORE(interval, ShapingQueue::peek_y()));   // Time until next input shaping echo for Y
       TERN_(LIN_ADVANCE, NOMORE(interval, nextAdvanceISR));               // Come back early for Linear Advance?
-      TERN_(INTEGRATED_BABYSTEPPING, NOMORE(interval, nextBabystepISR));  // Come back early for Babystepping?
+      TERN_(BABYSTEPPING, NOMORE(interval, nextBabystepISR));             // Come back early for Babystepping?
 
       //
       // Compute remaining time for each ISR phase
@@ -1608,7 +1608,7 @@ void Stepper::isr() {
       nextMainISR -= interval;
       TERN_(HAS_ZV_SHAPING, ShapingQueue::decrement_delays(interval));
       TERN_(LIN_ADVANCE, if (nextAdvanceISR != LA_ADV_NEVER) nextAdvanceISR -= interval);
-      TERN_(INTEGRATED_BABYSTEPPING, if (nextBabystepISR != BABYSTEP_NEVER) nextBabystepISR -= interval);
+      TERN_(BABYSTEPPING, if (nextBabystepISR != BABYSTEP_NEVER) nextBabystepISR -= interval);
 
     } // standard motion control
 
@@ -2807,7 +2807,7 @@ hal_timer_t Stepper::block_phase_isr() {
 
 #endif // LIN_ADVANCE
 
-#if ENABLED(INTEGRATED_BABYSTEPPING)
+#if ENABLED(BABYSTEPPING)
 
   // Timer interrupt for baby-stepping
   hal_timer_t Stepper::babystepping_isr() {
@@ -3669,7 +3669,7 @@ void Stepper::report_positions() {
   // No other ISR should ever interrupt this!
   void Stepper::do_babystep(const AxisEnum axis, const bool direction) {
 
-    IF_DISABLED(INTEGRATED_BABYSTEPPING, cli());
+    IF_DISABLED(BABYSTEPPING, cli());
 
     switch (axis) {
 
@@ -3750,7 +3750,7 @@ void Stepper::report_positions() {
       default: break;
     }
 
-    IF_DISABLED(INTEGRATED_BABYSTEPPING, sei());
+    IF_DISABLED(BABYSTEPPING, sei());
   }
 
 #endif // BABYSTEPPING

commit 821d77fe4c2ea0260d63e02ae65ab575da840801
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 16 23:43:50 2023 -0500

    🎨 Misc. comment open

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 6133b6e39b..d1c8eef69c 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2411,7 +2411,7 @@ hal_timer_t Stepper::block_phase_isr() {
           }
         #endif // LIN_ADVANCE
 
-        /*
+        /**
          * Adjust Laser Power - Decelerating
          * trap_ramp_entry_decr - holds the precalculated value to decrease the current power per decel step.
          */

commit f14f1be168ebf252dd458c935271aed1a57cfa0b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 30 19:16:00 2023 -0500

    🎨 Standardize naming (ProUI) (#25982)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 5d48b20ee8..6133b6e39b 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2639,7 +2639,7 @@ hal_timer_t Stepper::block_phase_isr() {
         oversampling_factor = 0;                            // Assume no axis smoothing (via oversampling)
         // Decide if axis smoothing is possible
         uint32_t max_rate = current_block->nominal_rate;    // Get the step event rate
-        if (TERN1(DWIN_LCD_PROUI, HMI_data.AdaptiveStepSmoothing)) {
+        if (TERN1(DWIN_LCD_PROUI, hmiData.adaptiveStepSmoothing)) {
           while (max_rate < MIN_STEP_ISR_FREQUENCY) {       // As long as more ISRs are possible...
             max_rate <<= 1;                                 // Try to double the rate
             if (max_rate < MIN_STEP_ISR_FREQUENCY)          // Don't exceed the estimated ISR limit

commit d9349caeee7307d660ec729052210dfba7036432
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Thu Jun 29 13:27:25 2023 -0700

    ⚡️ Ethernet Buffer for Input Shaping on LPC (#26027)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 50b8323838..5d48b20ee8 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -247,7 +247,13 @@ uint32_t Stepper::advance_divisor = 0,
 
 #if HAS_ZV_SHAPING
   shaping_time_t      ShapingQueue::now = 0;
-  shaping_time_t      ShapingQueue::times[shaping_echoes];
+  #if ANY(MCU_LPC1768, MCU_LPC1769) && DISABLED(NO_LPC_ETHERNET_BUFFER)
+    // Use the 16K LPC Ethernet buffer: https://github.com/MarlinFirmware/Marlin/issues/25432#issuecomment-1450420638
+    #define _ATTR_BUFFER __attribute__((section("AHBSRAM1"),aligned))
+  #else
+    #define _ATTR_BUFFER
+  #endif
+  shaping_time_t      ShapingQueue::times[shaping_echoes] _ATTR_BUFFER;
   shaping_echo_axis_t ShapingQueue::echo_axes[shaping_echoes];
   uint16_t            ShapingQueue::tail = 0;
 

commit 858916d628526b5d56c34c5c9663e3535bfc7788
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Fri Jun 23 04:57:22 2023 -0500

    🚸 Update DWIN ProUI (#26003)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c2915eb418..50b8323838 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2633,10 +2633,12 @@ hal_timer_t Stepper::block_phase_isr() {
         oversampling_factor = 0;                            // Assume no axis smoothing (via oversampling)
         // Decide if axis smoothing is possible
         uint32_t max_rate = current_block->nominal_rate;    // Get the step event rate
-        while (max_rate < MIN_STEP_ISR_FREQUENCY) {         // As long as more ISRs are possible...
-          max_rate <<= 1;                                   // Try to double the rate
-          if (max_rate < MIN_STEP_ISR_FREQUENCY)            // Don't exceed the estimated ISR limit
-            ++oversampling_factor;                          // Increase the oversampling (used for left-shift)
+        if (TERN1(DWIN_LCD_PROUI, HMI_data.AdaptiveStepSmoothing)) {
+          while (max_rate < MIN_STEP_ISR_FREQUENCY) {       // As long as more ISRs are possible...
+            max_rate <<= 1;                                 // Try to double the rate
+            if (max_rate < MIN_STEP_ISR_FREQUENCY)          // Don't exceed the estimated ISR limit
+              ++oversampling_factor;                        // Increase the oversampling (used for left-shift)
+          }
         }
       #endif
 

commit 8c9172cf5d21fd57aed16edbe825a872ae064ad0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 22 02:54:21 2023 -0500

    🍻 Fixed-Time Motion integration (#25719)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 66dd114616..c2915eb418 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2608,23 +2608,23 @@ hal_timer_t Stepper::block_phase_isr() {
         #define Z_MOVE_TEST !!current_block->steps.c
       #endif
 
-      AxisBits axis_bits;
+      AxisBits didmove;
       NUM_AXIS_CODE(
-        if (X_MOVE_TEST)            axis_bits.a = true,
-        if (Y_MOVE_TEST)            axis_bits.b = true,
-        if (Z_MOVE_TEST)            axis_bits.c = true,
-        if (current_block->steps.i) axis_bits.i = true,
-        if (current_block->steps.j) axis_bits.j = true,
-        if (current_block->steps.k) axis_bits.k = true,
-        if (current_block->steps.u) axis_bits.u = true,
-        if (current_block->steps.v) axis_bits.v = true,
-        if (current_block->steps.w) axis_bits.w = true
+        if (X_MOVE_TEST)            didmove.a = true,
+        if (Y_MOVE_TEST)            didmove.b = true,
+        if (Z_MOVE_TEST)            didmove.c = true,
+        if (current_block->steps.i) didmove.i = true,
+        if (current_block->steps.j) didmove.j = true,
+        if (current_block->steps.k) didmove.k = true,
+        if (current_block->steps.u) didmove.u = true,
+        if (current_block->steps.v) didmove.v = true,
+        if (current_block->steps.w) didmove.w = true
       );
-      //if (current_block->steps.e) axis_bits.e = true;
-      //if (current_block->steps.a) axis_bits.x = true;
-      //if (current_block->steps.b) axis_bits.y = true;
-      //if (current_block->steps.c) axis_bits.z = true;
-      axis_did_move = axis_bits;
+      //if (current_block->steps.e) didmove.e = true;
+      //if (current_block->steps.a) didmove.x = true;
+      //if (current_block->steps.b) didmove.y = true;
+      //if (current_block->steps.c) didmove.z = true;
+      axis_did_move = didmove;
 
       // No acceleration / deceleration time elapsed so far
       acceleration_time = deceleration_time = 0;
@@ -2758,7 +2758,7 @@ hal_timer_t Stepper::block_phase_isr() {
         }
       #endif
     }
-  }
+  } // !current_block
 
   // Return the interval to wait
   return interval;
@@ -3136,9 +3136,9 @@ void Stepper::init() {
    * when shaping an axis.
    */
   void Stepper::set_shaping_damping_ratio(const AxisEnum axis, const_float_t zeta) {
-    // from the damping ratio, get a factor that can be applied to advance_dividend for fixed point maths
-    // for ZV, we use amplitudes 1/(1+K) and K/(1+K) where K = exp(-zeta * M_PI / sqrt(1.0f - zeta * zeta))
-    // which can be converted to 1:7 fixed point with an excellent fit with a 3rd order polynomial
+    // From the damping ratio, get a factor that can be applied to advance_dividend for fixed-point maths.
+    // For ZV, we use amplitudes 1/(1+K) and K/(1+K) where K = exp(-zeta * π / sqrt(1.0f - zeta * zeta))
+    // which can be converted to 1:7 fixed point with an excellent fit with a 3rd-order polynomial.
     float factor2;
     if (zeta <= 0.0f) factor2 = 64.0f;
     else if (zeta >= 1.0f) factor2 = 0.0f;
@@ -3411,39 +3411,93 @@ void Stepper::report_positions() {
 
     USING_TIMED_PULSE();
 
-    #if HAS_Z_AXIS
-      // Z is handled differently to update the stepper
-      // counts (needed by Marlin for bed level probing).
-      const bool z_fwd = TEST(command, FT_BIT_DIR_Z),
-                z_step = TEST(command, FT_BIT_STEP_Z);
-    #endif
+    const xyze_bool_t axis_step = LOGICAL_AXIS_ARRAY(
+      TEST(command, FT_BIT_STEP_E),
+      TEST(command, FT_BIT_STEP_X), TEST(command, FT_BIT_STEP_Y), TEST(command, FT_BIT_STEP_Z),
+      TEST(command, FT_BIT_STEP_I), TEST(command, FT_BIT_STEP_J), TEST(command, FT_BIT_STEP_K),
+      TEST(command, FT_BIT_STEP_U), TEST(command, FT_BIT_STEP_V), TEST(command, FT_BIT_STEP_W)
+    );
 
+    // Apply directions (which will apply to the entire linear move)
+    AxisBits axis_dir = last_direction_bits;
     if (applyDir) {
-      TERN_(HAS_X_AXIS, X_APPLY_DIR(TEST(command, FT_BIT_DIR_X), false));
-      TERN_(HAS_Y_AXIS, Y_APPLY_DIR(TEST(command, FT_BIT_DIR_Y), false));
-      TERN_(HAS_Z_AXIS, Z_APPLY_DIR(z_fwd, false));
-      TERN_(HAS_EXTRUDERS, E_APPLY_DIR(TEST(command, FT_BIT_DIR_E), false));
+      axis_dir = LOGICAL_AXIS_ARRAY(
+        TEST(command, FT_BIT_DIR_E),
+        TEST(command, FT_BIT_DIR_X), TEST(command, FT_BIT_DIR_Y), TEST(command, FT_BIT_DIR_Z),
+        TEST(command, FT_BIT_DIR_I), TEST(command, FT_BIT_DIR_J), TEST(command, FT_BIT_DIR_K),
+        TEST(command, FT_BIT_DIR_U), TEST(command, FT_BIT_DIR_V), TEST(command, FT_BIT_DIR_W)
+      );
+      LOGICAL_AXIS_CODE(
+        E_APPLY_DIR(axis_dir.e, false),
+        X_APPLY_DIR(axis_dir.x, false), Y_APPLY_DIR(axis_dir.y, false), Z_APPLY_DIR(axis_dir.z, false),
+        I_APPLY_DIR(axis_dir.i, false), J_APPLY_DIR(axis_dir.j, false), K_APPLY_DIR(axis_dir.k, false),
+        U_APPLY_DIR(axis_dir.u, false), V_APPLY_DIR(axis_dir.v, false), W_APPLY_DIR(axis_dir.w, false)
+      );
+      last_direction_bits = axis_dir;
       DIR_WAIT_AFTER();
     }
 
-    TERN_(HAS_X_AXIS, X_APPLY_STEP(TEST(command, FT_BIT_STEP_X), false));
-    TERN_(HAS_Y_AXIS, Y_APPLY_STEP(TEST(command, FT_BIT_STEP_Y), false));
-    TERN_(HAS_Z_AXIS, Z_APPLY_STEP(z_step, false));
-    TERN_(HAS_EXTRUDERS, E_APPLY_STEP(TEST(command, FT_BIT_STEP_E), false));
+    // Start a step pulse
+    LOGICAL_AXIS_CODE(
+      if (axis_step.e) E_APPLY_STEP(STEP_STATE_E, false),
+      if (axis_step.x) X_APPLY_STEP(STEP_STATE_X, false), if (axis_step.y) Y_APPLY_STEP(STEP_STATE_Y, false),
+      if (axis_step.z) Z_APPLY_STEP(STEP_STATE_Z, false), if (axis_step.i) I_APPLY_STEP(STEP_STATE_I, false),
+      if (axis_step.j) J_APPLY_STEP(STEP_STATE_J, false), if (axis_step.k) K_APPLY_STEP(STEP_STATE_K, false),
+      if (axis_step.u) U_APPLY_STEP(STEP_STATE_U, false), if (axis_step.v) V_APPLY_STEP(STEP_STATE_V, false),
+      if (axis_step.w) W_APPLY_STEP(STEP_STATE_W, false)
+    );
 
+    // Begin waiting for the minimum pulse duration
     START_TIMED_PULSE();
 
-    #if HAS_Z_AXIS
-      // Update step counts
-      if (z_step) count_position.z += z_fwd ? 1 : -1;
+    // Update axis direction adders
+    count_direction = LOGICAL_AXIS_ARRAY(
+      int8_t(axis_dir.e ? 1 : -1),
+      int8_t(axis_dir.x ? 1 : -1), int8_t(axis_dir.y ? 1 : -1), int8_t(axis_dir.z ? 1 : -1),
+      int8_t(axis_dir.i ? 1 : -1), int8_t(axis_dir.j ? 1 : -1), int8_t(axis_dir.k ? 1 : -1),
+      int8_t(axis_dir.u ? 1 : -1), int8_t(axis_dir.v ? 1 : -1), int8_t(axis_dir.w ? 1 : -1)
+    );
+
+    // Update stepper counts - required for various operations
+    LOGICAL_AXIS_CODE(
+      if (axis_step.e) count_position.e += count_direction.e,
+      if (axis_step.x) count_position.x += count_direction.x, if (axis_step.y) count_position.y += count_direction.y,
+      if (axis_step.z) count_position.z += count_direction.z, if (axis_step.i) count_position.i += count_direction.i,
+      if (axis_step.j) count_position.j += count_direction.j, if (axis_step.k) count_position.k += count_direction.k,
+      if (axis_step.u) count_position.u += count_direction.u, if (axis_step.v) count_position.v += count_direction.v,
+      if (axis_step.w) count_position.w += count_direction.w
+    );
+
+    #if HAS_EXTRUDERS
+      #if ENABLED(E_DUAL_STEPPER_DRIVERS)
+        constexpr bool e_axis_has_dedge = AXIS_HAS_DEDGE(E0) && AXIS_HAS_DEDGE(E1);
+      #else
+        #define _EDGE_BIT(N) | (AXIS_HAS_DEDGE(E##N) << TOOL_ESTEPPER(N))
+        constexpr Flags<E_STEPPERS> e_stepper_dedge { 0 REPEAT(EXTRUDERS, _EDGE_BIT) };
+        const bool e_axis_has_dedge = e_stepper_dedge[stepper_extruder];
+      #endif
     #endif
 
-    AWAIT_HIGH_PULSE();
+    // Only wait for axes without edge stepping
+    const bool any_wait = false LOGICAL_AXIS_GANG(
+      || (!e_axis_has_dedge && axis_step.e),
+      || (!AXIS_HAS_DEDGE(X) && axis_step.x), || (!AXIS_HAS_DEDGE(Y) && axis_step.y), || (!AXIS_HAS_DEDGE(Z) && axis_step.z),
+      || (!AXIS_HAS_DEDGE(I) && axis_step.i), || (!AXIS_HAS_DEDGE(J) && axis_step.j), || (!AXIS_HAS_DEDGE(K) && axis_step.k),
+      || (!AXIS_HAS_DEDGE(U) && axis_step.u), || (!AXIS_HAS_DEDGE(V) && axis_step.v), || (!AXIS_HAS_DEDGE(W) && axis_step.w)
+    );
 
-    TERN_(HAS_X_AXIS, X_APPLY_STEP(0, false));
-    TERN_(HAS_Y_AXIS, Y_APPLY_STEP(0, false));
-    TERN_(HAS_Z_AXIS, Z_APPLY_STEP(0, false));
-    TERN_(HAS_EXTRUDERS, E_APPLY_STEP(0, false));
+    // Allow pulses to be registered by stepper drivers
+    if (any_wait) AWAIT_HIGH_PULSE();
+
+    // Stop pulses. Axes with DEDGE will do nothing, assuming STEP_STATE_* is HIGH
+    LOGICAL_AXIS_CODE(
+      if (axis_step.e) E_APPLY_STEP(!STEP_STATE_E, false),
+      if (axis_step.x) X_APPLY_STEP(!STEP_STATE_X, false), if (axis_step.y) Y_APPLY_STEP(!STEP_STATE_Y, false),
+      if (axis_step.z) Z_APPLY_STEP(!STEP_STATE_Z, false), if (axis_step.i) I_APPLY_STEP(!STEP_STATE_I, false),
+      if (axis_step.j) J_APPLY_STEP(!STEP_STATE_J, false), if (axis_step.k) K_APPLY_STEP(!STEP_STATE_K, false),
+      if (axis_step.u) U_APPLY_STEP(!STEP_STATE_U, false), if (axis_step.v) V_APPLY_STEP(!STEP_STATE_V, false),
+      if (axis_step.w) W_APPLY_STEP(!STEP_STATE_W, false)
+    );
 
   } // Stepper::fxdTiCtrl_stepper
 
@@ -3499,28 +3553,17 @@ void Stepper::report_positions() {
                                 // or the set conditions should be changed from the block to
                                 // the motion trajectory or motor commands.
 
-    AxisBits axis_bits;
+    AxisBits didmove;
+    static abce_ulong_t debounce{0};
+    auto debounce_axis = [&](const AxisEnum axis) {
+      if (current_block->steps[axis]) debounce[axis] = (AXIS_DID_MOVE_DEB) * 400; // divide by 0.0025f */
+      if (debounce[axis]) { didmove.bset(axis); debounce[axis]--; }
+    };
+    #define _DEBOUNCE(N) debounce_axis(AxisEnum(N));
 
-    static uint32_t a_debounce = 0U;
-    if (!!current_block->steps.a) a_debounce = (AXIS_DID_MOVE_DEB) * 400; // divide by 0.0025f
-    if (a_debounce) { axis_bits.a = true; a_debounce--; }
-    #if HAS_Y_AXIS
-      static uint32_t b_debounce = 0U;
-      if (!!current_block->steps.b) b_debounce = (AXIS_DID_MOVE_DEB) * 400;
-      if (b_debounce) { axis_bits.b = true; b_debounce--; }
-    #endif
-    #if HAS_Z_AXIS
-      static uint32_t c_debounce = 0U;
-      if (!!current_block->steps.c) c_debounce = (AXIS_DID_MOVE_DEB) * 400;
-      if (c_debounce) { axis_bits.c = true; c_debounce--; }
-    #endif
-    #if HAS_EXTRUDERS
-      static uint32_t e_debounce = 0U;
-      if (!!current_block->steps.e) e_debounce = (AXIS_DID_MOVE_DEB) * 400;
-      if (e_debounce) { axis_bits.e = true; e_debounce--; }
-    #endif
+    if (current_block) { REPEAT(LOGICAL_AXES, _DEBOUNCE); }
 
-    axis_did_move = axis_bits;
+    axis_did_move = didmove;
   }
 
 #endif // FT_MOTION

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    🧑‍💻 Remove LOOP macros (#25917)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index eb977793ef..66dd114616 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2842,7 +2842,7 @@ void Stepper::init() {
   #if MB(ALLIGATOR)
     const float motor_current[] = MOTOR_CURRENT;
     unsigned int digipot_motor = 0;
-    LOOP_L_N(i, 3 + EXTRUDERS) {
+    for (uint8_t i = 0; i < 3 + EXTRUDERS; ++i) {
       digipot_motor = 255 * (motor_current[i] / 2.5);
       dac084s085::setValue(i, digipot_motor);
     }
@@ -3725,7 +3725,7 @@ void Stepper::report_positions() {
 
   void Stepper::refresh_motor_power() {
     if (!initialized) return;
-    LOOP_L_N(i, COUNT(motor_current_setting)) {
+    for (uint8_t i = 0; i < COUNT(motor_current_setting); ++i) {
       switch (i) {
         #if ANY_PIN(MOTOR_CURRENT_PWM_XY, MOTOR_CURRENT_PWM_X, MOTOR_CURRENT_PWM_Y, MOTOR_CURRENT_PWM_I, MOTOR_CURRENT_PWM_J, MOTOR_CURRENT_PWM_K, MOTOR_CURRENT_PWM_U, MOTOR_CURRENT_PWM_V, MOTOR_CURRENT_PWM_W)
           case 0:
@@ -3821,7 +3821,7 @@ void Stepper::report_positions() {
         SPI.begin();
         SET_OUTPUT(DIGIPOTSS_PIN);
 
-        LOOP_L_N(i, COUNT(motor_current_setting))
+        for (uint8_t i = 0; i < COUNT(motor_current_setting); ++i)
           set_digipot_current(i, motor_current_setting[i]);
 
       #elif HAS_MOTOR_CURRENT_PWM

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    🧑‍💻 Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 3188f77da8..eb977793ef 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -148,7 +148,7 @@ Stepper stepper; // Singleton
 
 // public:
 
-#if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
+#if ANY(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
   bool Stepper::separate_multi_axis = false;
 #endif
 
@@ -182,7 +182,7 @@ bool Stepper::abort_current_block;
   bool Stepper::locked_Y_motor = false, Stepper::locked_Y2_motor = false;
 #endif
 
-#if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
+#if ANY(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
   bool Stepper::locked_Z_motor = false, Stepper::locked_Z2_motor = false
     #if NUM_Z_STEPPERS >= 3
       , Stepper::locked_Z3_motor = false
@@ -218,7 +218,7 @@ uint32_t Stepper::advance_divisor = 0,
          Stepper::decelerate_after,          // The count at which to start decelerating
          Stepper::step_event_count;          // The total event count for the current block
 
-#if EITHER(HAS_MULTI_EXTRUDER, MIXING_EXTRUDER)
+#if ANY(HAS_MULTI_EXTRUDER, MIXING_EXTRUDER)
   uint8_t Stepper::stepper_extruder;
 #else
   constexpr uint8_t Stepper::stepper_extruder;
@@ -1967,7 +1967,7 @@ void Stepper::pulse_phase_isr() {
         PULSE_PREP(W);
       #endif
 
-      #if EITHER(HAS_E0_STEP, MIXING_EXTRUDER)
+      #if ANY(HAS_E0_STEP, MIXING_EXTRUDER)
         PULSE_PREP(E);
 
         #if ENABLED(LIN_ADVANCE)
@@ -2558,7 +2558,7 @@ hal_timer_t Stepper::block_phase_isr() {
          * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z, handled below)
          * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X)
          */
-        #if EITHER(COREXY, COREXZ)
+        #if ANY(COREXY, COREXZ)
           #define X_CMP(A,B) ((A)==(B))
         #else
           #define X_CMP(A,B) ((A)!=(B))
@@ -2578,7 +2578,7 @@ hal_timer_t Stepper::block_phase_isr() {
          * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y)
          * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z)
          */
-        #if EITHER(COREYX, COREYZ)
+        #if ANY(COREYX, COREYZ)
           #define Y_CMP(A,B) ((A)==(B))
         #else
           #define Y_CMP(A,B) ((A)!=(B))
@@ -2598,7 +2598,7 @@ hal_timer_t Stepper::block_phase_isr() {
          * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y, already handled above)
          * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Z)
          */
-        #if EITHER(COREZX, COREZY)
+        #if ANY(COREZX, COREZY)
           #define Z_CMP(A,B) ((A)==(B))
         #else
           #define Z_CMP(A,B) ((A)!=(B))
@@ -2856,7 +2856,7 @@ void Stepper::init() {
   TERN_(HAS_X2_DIR, X2_DIR_INIT());
   #if HAS_Y_DIR
     Y_DIR_INIT();
-    #if BOTH(HAS_Y2_STEPPER, HAS_Y2_DIR)
+    #if ALL(HAS_Y2_STEPPER, HAS_Y2_DIR)
       Y2_DIR_INIT();
     #endif
   #endif
@@ -2908,7 +2908,7 @@ void Stepper::init() {
     #endif
     X_ENABLE_INIT();
     if (X_ENABLE_INIT_STATE) X_ENABLE_WRITE(X_ENABLE_INIT_STATE);
-    #if BOTH(HAS_X2_STEPPER, HAS_X2_ENABLE)
+    #if ALL(HAS_X2_STEPPER, HAS_X2_ENABLE)
       X2_ENABLE_INIT();
       if (X_ENABLE_INIT_STATE) X2_ENABLE_WRITE(X_ENABLE_INIT_STATE);
     #endif
@@ -2919,7 +2919,7 @@ void Stepper::init() {
     #endif
     Y_ENABLE_INIT();
     if (Y_ENABLE_INIT_STATE) Y_ENABLE_WRITE(Y_ENABLE_INIT_STATE);
-    #if BOTH(HAS_Y2_STEPPER, HAS_Y2_ENABLE)
+    #if ALL(HAS_Y2_STEPPER, HAS_Y2_ENABLE)
       Y2_ENABLE_INIT();
       if (Y_ENABLE_INIT_STATE) Y2_ENABLE_WRITE(Y_ENABLE_INIT_STATE);
     #endif

commit ed66f498eb713f59f14d000f8bfa550b34ce8528
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 16 02:38:24 2023 -0500

    🚸 Fixed-Time Motion EEPROM and Menu (#25835)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b23667b820..3188f77da8 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1497,7 +1497,7 @@ void Stepper::isr() {
     #if ENABLED(FT_MOTION)
 
       // NOTE STEPPER_TIMER_RATE is equal to 2000000, not what VSCode shows
-      const bool using_fxtictrl = fxdTiCtrl.cfg_mode;
+      const bool using_fxtictrl = fxdTiCtrl.cfg.mode;
       if (using_fxtictrl) {
         if (!nextMainISR) {
           if (abort_current_block) {

commit 25ddde0394361c23194c0f4a8f9777d389040af3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 15 22:00:15 2023 -0500

    🧑‍💻 Change Marlin DIR bits: 1=Forward, 0=Reverse (#25791)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c811bf5e38..b23667b820 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -383,111 +383,114 @@ xyze_int8_t Stepper::count_direction{0};
   }
 
 #if HAS_SYNCED_X_STEPPERS
-  #define X_APPLY_DIR(v,Q) do{ X_DIR_WRITE(v); X2_DIR_WRITE(INVERT_DIR(X2_VS_X, v)); }while(0)
+  #define X_APPLY_DIR(FWD,Q) do{ X_DIR_WRITE(FWD); X2_DIR_WRITE(INVERT_DIR(X2_VS_X, FWD)); }while(0)
   #if ENABLED(X_DUAL_ENDSTOPS)
-    #define X_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(X,v)
+    #define X_APPLY_STEP(FWD,Q) DUAL_ENDSTOP_APPLY_STEP(X,FWD)
   #else
-    #define X_APPLY_STEP(v,Q) do{ X_STEP_WRITE(v); X2_STEP_WRITE(v); }while(0)
+    #define X_APPLY_STEP(FWD,Q) do{ X_STEP_WRITE(FWD); X2_STEP_WRITE(FWD); }while(0)
   #endif
 #elif ENABLED(DUAL_X_CARRIAGE)
-  #define X_APPLY_DIR(v,ALWAYS) do{ \
-    if (extruder_duplication_enabled || ALWAYS) { X_DIR_WRITE(v); X2_DIR_WRITE((v) ^ idex_mirrored_mode); } \
-    else if (last_moved_extruder) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \
+  #define X_APPLY_DIR(FWD,ALWAYS) do{ \
+    if (extruder_duplication_enabled || ALWAYS) { X_DIR_WRITE(FWD); X2_DIR_WRITE((FWD) ^ idex_mirrored_mode); } \
+    else if (last_moved_extruder) X2_DIR_WRITE(FWD); else X_DIR_WRITE(FWD); \
   }while(0)
-  #define X_APPLY_STEP(v,ALWAYS) do{ \
-    if (extruder_duplication_enabled || ALWAYS) { X_STEP_WRITE(v); X2_STEP_WRITE(v); } \
-    else if (last_moved_extruder) X2_STEP_WRITE(v); else X_STEP_WRITE(v); \
+  #define X_APPLY_STEP(FWD,ALWAYS) do{ \
+    if (extruder_duplication_enabled || ALWAYS) { X_STEP_WRITE(FWD); X2_STEP_WRITE(FWD); } \
+    else if (last_moved_extruder) X2_STEP_WRITE(FWD); else X_STEP_WRITE(FWD); \
   }while(0)
 #elif HAS_X_AXIS
-  #define X_APPLY_DIR(v,Q) X_DIR_WRITE(v)
-  #define X_APPLY_STEP(v,Q) X_STEP_WRITE(v)
+  #define X_APPLY_DIR(FWD,Q) X_DIR_WRITE(FWD)
+  #define X_APPLY_STEP(FWD,Q) X_STEP_WRITE(FWD)
 #endif
 
 #if HAS_SYNCED_Y_STEPPERS
-  #define Y_APPLY_DIR(v,Q) do{ Y_DIR_WRITE(v); Y2_DIR_WRITE(INVERT_DIR(Y2_VS_Y, v)); }while(0)
+  #define Y_APPLY_DIR(FWD,Q) do{ Y_DIR_WRITE(FWD); Y2_DIR_WRITE(INVERT_DIR(Y2_VS_Y, FWD)); }while(0)
   #if ENABLED(Y_DUAL_ENDSTOPS)
-    #define Y_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Y,v)
+    #define Y_APPLY_STEP(FWD,Q) DUAL_ENDSTOP_APPLY_STEP(Y,FWD)
   #else
-    #define Y_APPLY_STEP(v,Q) do{ Y_STEP_WRITE(v); Y2_STEP_WRITE(v); }while(0)
+    #define Y_APPLY_STEP(FWD,Q) do{ Y_STEP_WRITE(FWD); Y2_STEP_WRITE(FWD); }while(0)
   #endif
 #elif HAS_Y_AXIS
-  #define Y_APPLY_DIR(v,Q) Y_DIR_WRITE(v)
-  #define Y_APPLY_STEP(v,Q) Y_STEP_WRITE(v)
+  #define Y_APPLY_DIR(FWD,Q) Y_DIR_WRITE(FWD)
+  #define Y_APPLY_STEP(FWD,Q) Y_STEP_WRITE(FWD)
 #endif
 
 #if NUM_Z_STEPPERS == 4
-  #define Z_APPLY_DIR(v,Q) do{ \
-    Z_DIR_WRITE(v); Z2_DIR_WRITE(INVERT_DIR(Z2_VS_Z, v)); \
-    Z3_DIR_WRITE(INVERT_DIR(Z3_VS_Z, v)); Z4_DIR_WRITE(INVERT_DIR(Z4_VS_Z, v)); \
+  #define Z_APPLY_DIR(FWD,Q) do{ \
+    Z_DIR_WRITE(FWD); Z2_DIR_WRITE(INVERT_DIR(Z2_VS_Z, FWD)); \
+    Z3_DIR_WRITE(INVERT_DIR(Z3_VS_Z, FWD)); Z4_DIR_WRITE(INVERT_DIR(Z4_VS_Z, FWD)); \
   }while(0)
   #if ENABLED(Z_MULTI_ENDSTOPS)
-    #define Z_APPLY_STEP(v,Q) QUAD_ENDSTOP_APPLY_STEP(Z,v)
+    #define Z_APPLY_STEP(FWD,Q) QUAD_ENDSTOP_APPLY_STEP(Z,FWD)
   #elif ENABLED(Z_STEPPER_AUTO_ALIGN)
-    #define Z_APPLY_STEP(v,Q) QUAD_SEPARATE_APPLY_STEP(Z,v)
+    #define Z_APPLY_STEP(FWD,Q) QUAD_SEPARATE_APPLY_STEP(Z,FWD)
   #else
-    #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); Z3_STEP_WRITE(v); Z4_STEP_WRITE(v); }while(0)
+    #define Z_APPLY_STEP(FWD,Q) do{ Z_STEP_WRITE(FWD); Z2_STEP_WRITE(FWD); Z3_STEP_WRITE(FWD); Z4_STEP_WRITE(FWD); }while(0)
   #endif
 #elif NUM_Z_STEPPERS == 3
-  #define Z_APPLY_DIR(v,Q) do{ \
-    Z_DIR_WRITE(v); Z2_DIR_WRITE(INVERT_DIR(Z2_VS_Z, v)); Z3_DIR_WRITE(INVERT_DIR(Z3_VS_Z, v)); \
+  #define Z_APPLY_DIR(FWD,Q) do{ \
+    Z_DIR_WRITE(FWD); Z2_DIR_WRITE(INVERT_DIR(Z2_VS_Z, FWD)); Z3_DIR_WRITE(INVERT_DIR(Z3_VS_Z, FWD)); \
   }while(0)
   #if ENABLED(Z_MULTI_ENDSTOPS)
-    #define Z_APPLY_STEP(v,Q) TRIPLE_ENDSTOP_APPLY_STEP(Z,v)
+    #define Z_APPLY_STEP(FWD,Q) TRIPLE_ENDSTOP_APPLY_STEP(Z,FWD)
   #elif ENABLED(Z_STEPPER_AUTO_ALIGN)
-    #define Z_APPLY_STEP(v,Q) TRIPLE_SEPARATE_APPLY_STEP(Z,v)
+    #define Z_APPLY_STEP(FWD,Q) TRIPLE_SEPARATE_APPLY_STEP(Z,FWD)
   #else
-    #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); Z3_STEP_WRITE(v); }while(0)
+    #define Z_APPLY_STEP(FWD,Q) do{ Z_STEP_WRITE(FWD); Z2_STEP_WRITE(FWD); Z3_STEP_WRITE(FWD); }while(0)
   #endif
 #elif NUM_Z_STEPPERS == 2
-  #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(INVERT_DIR(Z2_VS_Z, v)); }while(0)
+  #define Z_APPLY_DIR(FWD,Q) do{ Z_DIR_WRITE(FWD); Z2_DIR_WRITE(INVERT_DIR(Z2_VS_Z, FWD)); }while(0)
   #if ENABLED(Z_MULTI_ENDSTOPS)
-    #define Z_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Z,v)
+    #define Z_APPLY_STEP(FWD,Q) DUAL_ENDSTOP_APPLY_STEP(Z,FWD)
   #elif ENABLED(Z_STEPPER_AUTO_ALIGN)
-    #define Z_APPLY_STEP(v,Q) DUAL_SEPARATE_APPLY_STEP(Z,v)
+    #define Z_APPLY_STEP(FWD,Q) DUAL_SEPARATE_APPLY_STEP(Z,FWD)
   #else
-    #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); }while(0)
+    #define Z_APPLY_STEP(FWD,Q) do{ Z_STEP_WRITE(FWD); Z2_STEP_WRITE(FWD); }while(0)
   #endif
 #elif HAS_Z_AXIS
-  #define Z_APPLY_DIR(v,Q) Z_DIR_WRITE(v)
-  #define Z_APPLY_STEP(v,Q) Z_STEP_WRITE(v)
+  #define Z_APPLY_DIR(FWD,Q) Z_DIR_WRITE(FWD)
+  #define Z_APPLY_STEP(FWD,Q) Z_STEP_WRITE(FWD)
 #endif
 
 #if HAS_I_AXIS
-  #define I_APPLY_DIR(v,Q) I_DIR_WRITE(v)
-  #define I_APPLY_STEP(v,Q) I_STEP_WRITE(v)
+  #define I_APPLY_DIR(FWD,Q) I_DIR_WRITE(FWD)
+  #define I_APPLY_STEP(FWD,Q) I_STEP_WRITE(FWD)
 #endif
 #if HAS_J_AXIS
-  #define J_APPLY_DIR(v,Q) J_DIR_WRITE(v)
-  #define J_APPLY_STEP(v,Q) J_STEP_WRITE(v)
+  #define J_APPLY_DIR(FWD,Q) J_DIR_WRITE(FWD)
+  #define J_APPLY_STEP(FWD,Q) J_STEP_WRITE(FWD)
 #endif
 #if HAS_K_AXIS
-  #define K_APPLY_DIR(v,Q) K_DIR_WRITE(v)
-  #define K_APPLY_STEP(v,Q) K_STEP_WRITE(v)
+  #define K_APPLY_DIR(FWD,Q) K_DIR_WRITE(FWD)
+  #define K_APPLY_STEP(FWD,Q) K_STEP_WRITE(FWD)
 #endif
 #if HAS_U_AXIS
-  #define U_APPLY_DIR(v,Q) U_DIR_WRITE(v)
-  #define U_APPLY_STEP(v,Q) U_STEP_WRITE(v)
+  #define U_APPLY_DIR(FWD,Q) U_DIR_WRITE(FWD)
+  #define U_APPLY_STEP(FWD,Q) U_STEP_WRITE(FWD)
 #endif
 #if HAS_V_AXIS
-  #define V_APPLY_DIR(v,Q) V_DIR_WRITE(v)
-  #define V_APPLY_STEP(v,Q) V_STEP_WRITE(v)
+  #define V_APPLY_DIR(FWD,Q) V_DIR_WRITE(FWD)
+  #define V_APPLY_STEP(FWD,Q) V_STEP_WRITE(FWD)
 #endif
 #if HAS_W_AXIS
-  #define W_APPLY_DIR(v,Q) W_DIR_WRITE(v)
-  #define W_APPLY_STEP(v,Q) W_STEP_WRITE(v)
+  #define W_APPLY_DIR(FWD,Q) W_DIR_WRITE(FWD)
+  #define W_APPLY_STEP(FWD,Q) W_STEP_WRITE(FWD)
 #endif
 
-#define E0_APPLY_DIR(REV) do{ (REV) ? FWD_E_DIR(0) : REV_E_DIR(0); }while(0)
-#define E1_APPLY_DIR(REV) do{ (REV) ? FWD_E_DIR(1) : REV_E_DIR(1); }while(0)
-#define E2_APPLY_DIR(REV) do{ (REV) ? FWD_E_DIR(2) : REV_E_DIR(2); }while(0)
-#define E3_APPLY_DIR(REV) do{ (REV) ? FWD_E_DIR(3) : REV_E_DIR(3); }while(0)
-#define E4_APPLY_DIR(REV) do{ (REV) ? FWD_E_DIR(4) : REV_E_DIR(4); }while(0)
-#define E5_APPLY_DIR(REV) do{ (REV) ? FWD_E_DIR(5) : REV_E_DIR(5); }while(0)
-#define E6_APPLY_DIR(REV) do{ (REV) ? FWD_E_DIR(6) : REV_E_DIR(6); }while(0)
-#define E7_APPLY_DIR(REV) do{ (REV) ? FWD_E_DIR(7) : REV_E_DIR(7); }while(0)
-
-#if DISABLED(MIXING_EXTRUDER)
-  #define E_APPLY_STEP(v,Q) E_STEP_WRITE(stepper_extruder, v)
+//#define E0_APPLY_DIR(FWD) do{ (FWD) ? FWD_E_DIR(0) : REV_E_DIR(0); }while(0)
+//#define E1_APPLY_DIR(FWD) do{ (FWD) ? FWD_E_DIR(1) : REV_E_DIR(1); }while(0)
+//#define E2_APPLY_DIR(FWD) do{ (FWD) ? FWD_E_DIR(2) : REV_E_DIR(2); }while(0)
+//#define E3_APPLY_DIR(FWD) do{ (FWD) ? FWD_E_DIR(3) : REV_E_DIR(3); }while(0)
+//#define E4_APPLY_DIR(FWD) do{ (FWD) ? FWD_E_DIR(4) : REV_E_DIR(4); }while(0)
+//#define E5_APPLY_DIR(FWD) do{ (FWD) ? FWD_E_DIR(5) : REV_E_DIR(5); }while(0)
+//#define E6_APPLY_DIR(FWD) do{ (FWD) ? FWD_E_DIR(6) : REV_E_DIR(6); }while(0)
+//#define E7_APPLY_DIR(FWD) do{ (FWD) ? FWD_E_DIR(7) : REV_E_DIR(7); }while(0)
+
+#if ENABLED(MIXING_EXTRUDER)
+  #define E_APPLY_DIR(FWD,Q) do{ if (FWD) { MIXER_STEPPER_LOOP(j) FWD_E_DIR(j); } else { MIXER_STEPPER_LOOP(j) REV_E_DIR(j); } }while(0)
+#else
+  #define E_APPLY_STEP(FWD,Q) E_STEP_WRITE(stepper_extruder, FWD)
+  #define E_APPLY_DIR(FWD,Q) do{ if (FWD) { FWD_E_DIR(stepper_extruder); } else { REV_E_DIR(stepper_extruder); } }while(0)
 #endif
 
 #define CYCLES_TO_NS(CYC) (1000UL * (CYC) / ((F_CPU) / 1000000))
@@ -602,16 +605,12 @@ void Stepper::disable_all_steppers() {
 }
 
 // Set a single axis direction based on the last set flags.
-// A direction bit of "1" indicates reverse or negative motion.
-#define SET_STEP_DIR(A)             \
-  if (motor_direction(_AXIS(A))) {  \
-    A##_APPLY_DIR(LOW, false);      \
-    count_direction[_AXIS(A)] = -1; \
-  }                                 \
-  else {                            \
-    A##_APPLY_DIR(HIGH, false);     \
-    count_direction[_AXIS(A)] = 1;  \
-  }
+// A direction bit of "1" indicates forward or positive motion.
+#define SET_STEP_DIR(A) do{                     \
+    const bool fwd = motor_direction(_AXIS(A)); \
+    A##_APPLY_DIR(fwd, false);                  \
+    count_direction[_AXIS(A)] = fwd ? 1 : -1;   \
+  }while(0)
 
 /**
  * Set the stepper direction of each axis
@@ -621,36 +620,15 @@ void Stepper::disable_all_steppers() {
  *   COREYZ: Y_AXIS=B_AXIS and Z_AXIS=C_AXIS
  */
 void Stepper::apply_directions() {
-
   DIR_WAIT_BEFORE();
 
-  NUM_AXIS_CODE(
+  LOGICAL_AXIS_CODE(
+    SET_STEP_DIR(E),
     SET_STEP_DIR(X), SET_STEP_DIR(Y), SET_STEP_DIR(Z), // ABC
     SET_STEP_DIR(I), SET_STEP_DIR(J), SET_STEP_DIR(K),
     SET_STEP_DIR(U), SET_STEP_DIR(V), SET_STEP_DIR(W)
   );
 
-  #if HAS_EXTRUDERS
-     // Because this is valid for the whole block we don't know
-     // what E steppers will step. Likely all. Set all.
-    if (motor_direction(E_AXIS)) {
-      #if ENABLED(MIXING_EXTRUDER)
-        MIXER_STEPPER_LOOP(j) REV_E_DIR(j);
-      #else
-        REV_E_DIR(stepper_extruder);
-      #endif
-      count_direction.e = -1;
-    }
-    else {
-      #if ENABLED(MIXING_EXTRUDER)
-        MIXER_STEPPER_LOOP(j) FWD_E_DIR(j);
-      #else
-        FWD_E_DIR(stepper_extruder);
-      #endif
-      count_direction.e = 1;
-    }
-  #endif // HAS_EXTRUDERS
-
   DIR_WAIT_AFTER();
 }
 
@@ -1858,8 +1836,8 @@ void Stepper::pulse_phase_isr() {
         #if STEPPER_PAGE_FORMAT == SP_4x4D_128
 
           #define PAGE_SEGMENT_UPDATE(AXIS, VALUE) do{      \
-                 if ((VALUE) <  7) dm[_AXIS(AXIS)] = true;  \
-            else if ((VALUE) >  7) dm[_AXIS(AXIS)] = false; \
+                 if ((VALUE) <  7) dm[_AXIS(AXIS)] = false; \
+            else if ((VALUE) >  7) dm[_AXIS(AXIS)] = true;  \
             page_step_state.sd[_AXIS(AXIS)] = VALUE;        \
             page_step_state.bd[_AXIS(AXIS)] += VALUE;       \
           }while(0)
@@ -1884,8 +1862,7 @@ void Stepper::pulse_phase_isr() {
               PAGE_SEGMENT_UPDATE(Z, high >> 4);
               PAGE_SEGMENT_UPDATE(E, high & 0xF);
 
-              if (dm != last_direction_bits)
-                set_directions(dm);
+              if (dm != last_direction_bits) set_directions(dm);
 
             } break;
 
@@ -2409,29 +2386,16 @@ hal_timer_t Stepper::block_phase_isr() {
           if (la_active) {
             const uint32_t la_step_rate = la_advance_steps > current_block->final_adv_steps ? current_block->la_advance_rate : 0;
             if (la_step_rate != step_rate) {
-              const bool reverse_e = la_step_rate > step_rate;
-              la_interval = calc_timer_interval((reverse_e ? la_step_rate - step_rate : step_rate - la_step_rate) >> current_block->la_scaling);
+              const bool forward_e = la_step_rate < step_rate;
+              la_interval = calc_timer_interval((forward_e ? step_rate - la_step_rate : la_step_rate - step_rate) >> current_block->la_scaling);
 
-              if (reverse_e != motor_direction(E_AXIS)) {
+              if (forward_e != motor_direction(E_AXIS)) {
                 last_direction_bits.toggle(E_AXIS);
                 count_direction.e = -count_direction.e;
 
                 DIR_WAIT_BEFORE();
 
-                if (reverse_e) {
-                  #if ENABLED(MIXING_EXTRUDER)
-                    MIXER_STEPPER_LOOP(j) REV_E_DIR(j);
-                  #else
-                    REV_E_DIR(stepper_extruder);
-                  #endif
-                }
-                else {
-                  #if ENABLED(MIXING_EXTRUDER)
-                    MIXER_STEPPER_LOOP(j) FWD_E_DIR(j);
-                  #else
-                    FWD_E_DIR(stepper_extruder);
-                  #endif
-                }
+                E_APPLY_DIR(forward_e, false);
 
                 DIR_WAIT_AFTER();
               }
@@ -2688,13 +2652,13 @@ hal_timer_t Stepper::block_phase_isr() {
 
       #if ENABLED(INPUT_SHAPING_X)
         if (shaping_x.enabled) {
-          const int64_t steps = current_block->direction_bits.x ? -int64_t(current_block->steps.x) : int64_t(current_block->steps.x);
+          const int64_t steps = current_block->direction_bits.x ? int64_t(current_block->steps.x) : -int64_t(current_block->steps.x);
           shaping_x.last_block_end_pos += steps;
 
           // If there are any remaining echos unprocessed, then direction change must
           // be delayed and processed in PULSE_PREP_SHAPING. This will cause half a step
           // to be missed, which will need recovering and this can be done through shaping_x.remainder.
-          shaping_x.forward = !current_block->direction_bits.x;
+          shaping_x.forward = current_block->direction_bits.x;
           if (!ShapingQueue::empty_x()) current_block->direction_bits.x = last_direction_bits.x;
         }
       #endif
@@ -2702,9 +2666,9 @@ hal_timer_t Stepper::block_phase_isr() {
       // Y follows the same logic as X (but the comments aren't repeated)
       #if ENABLED(INPUT_SHAPING_Y)
         if (shaping_y.enabled) {
-          const int64_t steps = current_block->direction_bits.y ? -int64_t(current_block->steps.y) : int64_t(current_block->steps.y);
+          const int64_t steps = current_block->direction_bits.y ? int64_t(current_block->steps.y) : -int64_t(current_block->steps.y);
           shaping_y.last_block_end_pos += steps;
-          shaping_y.forward = !current_block->direction_bits.y;
+          shaping_y.forward = current_block->direction_bits.y;
           if (!ShapingQueue::empty_y()) current_block->direction_bits.y = last_direction_bits.y;
         }
       #endif
@@ -3450,36 +3414,36 @@ void Stepper::report_positions() {
     #if HAS_Z_AXIS
       // Z is handled differently to update the stepper
       // counts (needed by Marlin for bed level probing).
-      const bool z_dir = TEST(command, FT_BIT_DIR_Z),
+      const bool z_fwd = TEST(command, FT_BIT_DIR_Z),
                 z_step = TEST(command, FT_BIT_STEP_Z);
     #endif
 
     if (applyDir) {
-      TERN_(HAS_X_AXIS, X_DIR_WRITE(TEST(command, FT_BIT_DIR_X)));
-      TERN_(HAS_Y_AXIS, Y_DIR_WRITE(TEST(command, FT_BIT_DIR_Y)));
-      TERN_(HAS_Z_AXIS, Z_DIR_WRITE(z_dir));
-      TERN_(HAS_EXTRUDERS, E0_DIR_WRITE(TEST(command, FT_BIT_DIR_E)));
+      TERN_(HAS_X_AXIS, X_APPLY_DIR(TEST(command, FT_BIT_DIR_X), false));
+      TERN_(HAS_Y_AXIS, Y_APPLY_DIR(TEST(command, FT_BIT_DIR_Y), false));
+      TERN_(HAS_Z_AXIS, Z_APPLY_DIR(z_fwd, false));
+      TERN_(HAS_EXTRUDERS, E_APPLY_DIR(TEST(command, FT_BIT_DIR_E), false));
       DIR_WAIT_AFTER();
     }
 
-    TERN_(HAS_X_AXIS, X_STEP_WRITE(TEST(command, FT_BIT_STEP_X)));
-    TERN_(HAS_Y_AXIS, Y_STEP_WRITE(TEST(command, FT_BIT_STEP_Y)));
-    TERN_(HAS_Z_AXIS, Z_STEP_WRITE(z_step));
-    TERN_(HAS_EXTRUDERS, E0_STEP_WRITE(TEST(command, FT_BIT_STEP_E)));
+    TERN_(HAS_X_AXIS, X_APPLY_STEP(TEST(command, FT_BIT_STEP_X), false));
+    TERN_(HAS_Y_AXIS, Y_APPLY_STEP(TEST(command, FT_BIT_STEP_Y), false));
+    TERN_(HAS_Z_AXIS, Z_APPLY_STEP(z_step, false));
+    TERN_(HAS_EXTRUDERS, E_APPLY_STEP(TEST(command, FT_BIT_STEP_E), false));
 
     START_TIMED_PULSE();
 
     #if HAS_Z_AXIS
       // Update step counts
-      if (z_step) count_position.z += z_dir ? 1 : -1;
+      if (z_step) count_position.z += z_fwd ? 1 : -1;
     #endif
 
     AWAIT_HIGH_PULSE();
 
-    X_STEP_WRITE(0);
-    TERN_(HAS_Y_AXIS, Y_STEP_WRITE(0));
-    TERN_(HAS_Z_AXIS, Z_STEP_WRITE(0));
-    TERN_(HAS_EXTRUDERS, E0_STEP_WRITE(0));
+    TERN_(HAS_X_AXIS, X_APPLY_STEP(0, false));
+    TERN_(HAS_Y_AXIS, Y_APPLY_STEP(0, false));
+    TERN_(HAS_Z_AXIS, Z_APPLY_STEP(0, false));
+    TERN_(HAS_EXTRUDERS, E_APPLY_STEP(0, false));
 
   } // Stepper::fxdTiCtrl_stepper
 
@@ -3565,7 +3529,7 @@ void Stepper::report_positions() {
 
   #define _ENABLE_AXIS(A) enable_axis(_AXIS(A))
   #define _READ_DIR(AXIS) AXIS ##_DIR_READ()
-  #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)
+  #define _APPLY_DIR(AXIS, FWD) AXIS ##_APPLY_DIR(FWD, true)
 
   #if MINIMUM_STEPPER_PULSE
     #define STEP_PULSE_CYCLES ((MINIMUM_STEPPER_PULSE) * CYCLES_PER_MICROSECOND)

commit d52d26b4ef55ebb7ebc56ce5c712e4914f3aeb2a
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 08:37:34 2023 +1200

    🔧 Update multi-stepper axis conditionals (#25798)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 3e4f65fd69..c811bf5e38 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -382,7 +382,7 @@ xyze_int8_t Stepper::count_direction{0};
     A##4_STEP_WRITE(V);                           \
   }
 
-#if HAS_DUAL_X_STEPPERS
+#if HAS_SYNCED_X_STEPPERS
   #define X_APPLY_DIR(v,Q) do{ X_DIR_WRITE(v); X2_DIR_WRITE(INVERT_DIR(X2_VS_X, v)); }while(0)
   #if ENABLED(X_DUAL_ENDSTOPS)
     #define X_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(X,v)
@@ -403,7 +403,7 @@ xyze_int8_t Stepper::count_direction{0};
   #define X_APPLY_STEP(v,Q) X_STEP_WRITE(v)
 #endif
 
-#if HAS_DUAL_Y_STEPPERS
+#if HAS_SYNCED_Y_STEPPERS
   #define Y_APPLY_DIR(v,Q) do{ Y_DIR_WRITE(v); Y2_DIR_WRITE(INVERT_DIR(Y2_VS_Y, v)); }while(0)
   #if ENABLED(Y_DUAL_ENDSTOPS)
     #define Y_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Y,v)
@@ -2892,7 +2892,7 @@ void Stepper::init() {
   TERN_(HAS_X2_DIR, X2_DIR_INIT());
   #if HAS_Y_DIR
     Y_DIR_INIT();
-    #if BOTH(HAS_DUAL_Y_STEPPERS, HAS_Y2_DIR)
+    #if BOTH(HAS_Y2_STEPPER, HAS_Y2_DIR)
       Y2_DIR_INIT();
     #endif
   #endif
@@ -2955,7 +2955,7 @@ void Stepper::init() {
     #endif
     Y_ENABLE_INIT();
     if (Y_ENABLE_INIT_STATE) Y_ENABLE_WRITE(Y_ENABLE_INIT_STATE);
-    #if BOTH(HAS_DUAL_Y_STEPPERS, HAS_Y2_ENABLE)
+    #if BOTH(HAS_Y2_STEPPER, HAS_Y2_ENABLE)
       Y2_ENABLE_INIT();
       if (Y_ENABLE_INIT_STATE) Y2_ENABLE_WRITE(Y_ENABLE_INIT_STATE);
     #endif
@@ -3084,7 +3084,7 @@ void Stepper::init() {
   #endif
 
   #if HAS_Y_STEP
-    #if HAS_DUAL_Y_STEPPERS
+    #if HAS_Y2_STEPPER
       Y2_STEP_INIT();
       Y2_STEP_WRITE(!STEP_STATE_Y);
     #endif

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    🚸 Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index d7ef76d18a..3e4f65fd69 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -398,7 +398,7 @@ xyze_int8_t Stepper::count_direction{0};
     if (extruder_duplication_enabled || ALWAYS) { X_STEP_WRITE(v); X2_STEP_WRITE(v); } \
     else if (last_moved_extruder) X2_STEP_WRITE(v); else X_STEP_WRITE(v); \
   }while(0)
-#else
+#elif HAS_X_AXIS
   #define X_APPLY_DIR(v,Q) X_DIR_WRITE(v)
   #define X_APPLY_STEP(v,Q) X_STEP_WRITE(v)
 #endif
@@ -3407,19 +3407,21 @@ int32_t Stepper::triggered_position(const AxisEnum axis) {
 #endif
 
 void Stepper::report_a_position(const xyz_long_t &pos) {
-  SERIAL_ECHOLNPGM_P(
-    LIST_N(DOUBLE(NUM_AXES),
-      TERN(SAYS_A, PSTR(STR_COUNT_A), PSTR(STR_COUNT_X)), pos.x,
-      TERN(SAYS_B, PSTR("B:"), SP_Y_LBL), pos.y,
-      TERN(SAYS_C, PSTR("C:"), SP_Z_LBL), pos.z,
-      SP_I_LBL, pos.i,
-      SP_J_LBL, pos.j,
-      SP_K_LBL, pos.k,
-      SP_U_LBL, pos.u,
-      SP_V_LBL, pos.v,
-      SP_W_LBL, pos.w
-    )
-  );
+  #if NUM_AXES
+    SERIAL_ECHOLNPGM_P(
+      LIST_N(DOUBLE(NUM_AXES),
+        TERN(SAYS_A, PSTR(STR_COUNT_A), PSTR(STR_COUNT_X)), pos.x,
+        TERN(SAYS_B, PSTR("B:"), SP_Y_LBL), pos.y,
+        TERN(SAYS_C, PSTR("C:"), SP_Z_LBL), pos.z,
+        SP_I_LBL, pos.i,
+        SP_J_LBL, pos.j,
+        SP_K_LBL, pos.k,
+        SP_U_LBL, pos.u,
+        SP_V_LBL, pos.v,
+        SP_W_LBL, pos.w
+      )
+    );
+  #endif
 }
 
 void Stepper::report_positions() {

commit c6ea99f4be9c52d28c535e823da4171a7a89fa31
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 8 06:50:21 2023 -0500

    🐛 Fix babystep corrupting DIR
    
    Followup to 2538a7c4

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 7517bcd0a6..d7ef76d18a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3609,31 +3609,31 @@ void Stepper::report_positions() {
 
   #if DISABLED(DELTA)
 
-    #define BABYSTEP_AXIS(AXIS, DIR, INV) do{           \
-      const uint8_t old_dir = _READ_DIR(AXIS);          \
-      _ENABLE_AXIS(AXIS);                               \
-      DIR_WAIT_BEFORE();                                \
-      _APPLY_DIR(AXIS, (DIR)^(INV));                    \
-      DIR_WAIT_AFTER();                                 \
-      _SAVE_START();                                    \
-      _APPLY_STEP(AXIS, _STEP_STATE(AXIS), true);       \
-      _PULSE_WAIT();                                    \
-      _APPLY_STEP(AXIS, !_STEP_STATE(AXIS), true);      \
-      EXTRA_DIR_WAIT_BEFORE();                          \
-      _APPLY_DIR(AXIS, old_dir);                        \
-      EXTRA_DIR_WAIT_AFTER();                           \
+    #define BABYSTEP_AXIS(AXIS, FWD, INV) do{      \
+      const bool old_fwd = _READ_DIR(AXIS);        \
+      _ENABLE_AXIS(AXIS);                          \
+      DIR_WAIT_BEFORE();                           \
+      _APPLY_DIR(AXIS, (FWD)^(INV));               \
+      DIR_WAIT_AFTER();                            \
+      _SAVE_START();                               \
+      _APPLY_STEP(AXIS, _STEP_STATE(AXIS), true);  \
+      _PULSE_WAIT();                               \
+      _APPLY_STEP(AXIS, !_STEP_STATE(AXIS), true); \
+      EXTRA_DIR_WAIT_BEFORE();                     \
+      _APPLY_DIR(AXIS, old_fwd);                   \
+      EXTRA_DIR_WAIT_AFTER();                      \
     }while(0)
 
   #endif
 
   #if IS_CORE
 
-    #define BABYSTEP_CORE(A, B, DIR, INV, ALT) do{              \
-      const xy_byte_t old_dir = { _READ_DIR(A), _READ_DIR(B) }; \
+    #define BABYSTEP_CORE(A, B, FWD, INV, ALT) do{              \
+      const xy_byte_t old_fwd = { _READ_DIR(A), _READ_DIR(B) }; \
       _ENABLE_AXIS(A); _ENABLE_AXIS(B);                         \
       DIR_WAIT_BEFORE();                                        \
-      _APPLY_DIR(A, (DIR)^(INV));                               \
-      _APPLY_DIR(B, (DIR)^(INV)^(ALT));                         \
+      _APPLY_DIR(A, (FWD)^(INV));                               \
+      _APPLY_DIR(B, (FWD)^(INV)^(ALT));                         \
       DIR_WAIT_AFTER();                                         \
       _SAVE_START();                                            \
       _APPLY_STEP(A, _STEP_STATE(A), true);                     \
@@ -3642,7 +3642,7 @@ void Stepper::report_positions() {
       _APPLY_STEP(A, !_STEP_STATE(A), true);                    \
       _APPLY_STEP(B, !_STEP_STATE(B), true);                    \
       EXTRA_DIR_WAIT_BEFORE();                                  \
-      _APPLY_DIR(A, old_dir.a); _APPLY_DIR(B, old_dir.b);       \
+      _APPLY_DIR(A, old_fwd.a); _APPLY_DIR(B, old_fwd.b);       \
       EXTRA_DIR_WAIT_AFTER();                                   \
     }while(0)
 
@@ -3683,78 +3683,46 @@ void Stepper::report_positions() {
       case Z_AXIS: {
 
         #if CORE_IS_XZ
-          BABYSTEP_CORE(X, Z, direction, BABYSTEP_INVERT_Z, (CORESIGN(1)>0));
+          BABYSTEP_CORE(X, Z, direction, ENABLED(BABYSTEP_INVERT_Z), (CORESIGN(1)>0));
         #elif CORE_IS_YZ
-          BABYSTEP_CORE(Y, Z, direction, BABYSTEP_INVERT_Z, (CORESIGN(1)<0));
+          BABYSTEP_CORE(Y, Z, direction, ENABLED(BABYSTEP_INVERT_Z), (CORESIGN(1)<0));
         #elif DISABLED(DELTA)
-          BABYSTEP_AXIS(Z, direction, BABYSTEP_INVERT_Z);
+          BABYSTEP_AXIS(Z, direction, ENABLED(BABYSTEP_INVERT_Z));
 
         #else // DELTA
 
           const bool z_direction = TERN_(BABYSTEP_INVERT_Z, !) direction;
 
-          NUM_AXIS_CODE(
-            enable_axis(X_AXIS), enable_axis(Y_AXIS), enable_axis(Z_AXIS),
-            enable_axis(I_AXIS), enable_axis(J_AXIS), enable_axis(K_AXIS),
-            enable_axis(U_AXIS), enable_axis(V_AXIS), enable_axis(W_AXIS)
-          );
+          enable_axis(A_AXIS); enable_axis(B_AXIS); enable_axis(C_AXIS);
 
           DIR_WAIT_BEFORE();
 
-          const xyz_byte_t old_dir = NUM_AXIS_ARRAY(
-            X_DIR_READ(), Y_DIR_READ(), Z_DIR_READ(),
-            I_DIR_READ(), J_DIR_READ(), K_DIR_READ(),
-            U_DIR_READ(), V_DIR_READ(), W_DIR_READ()
-          );
+          const bool old_fwd[3] = { X_DIR_READ(), Y_DIR_READ(), Z_DIR_READ() };
 
-          #ifdef X_DIR_WRITE
-            X_DIR_WRITE(z_direction);
-          #endif
-          #ifdef Y_DIR_WRITE
-            Y_DIR_WRITE(z_direction);
-          #endif
-          #ifdef Z_DIR_WRITE
-            Z_DIR_WRITE(z_direction);
-          #endif
+          X_DIR_WRITE(z_direction);
+          Y_DIR_WRITE(z_direction);
+          Z_DIR_WRITE(z_direction);
 
           DIR_WAIT_AFTER();
 
           _SAVE_START();
 
-          #ifdef X_STEP_WRITE
-            X_STEP_WRITE(STEP_STATE_X);
-          #endif
-          #ifdef Y_STEP_WRITE
-            Y_STEP_WRITE(STEP_STATE_Y);
-          #endif
-          #ifdef Z_STEP_WRITE
-            Z_STEP_WRITE(STEP_STATE_Z);
-          #endif
+          X_STEP_WRITE(STEP_STATE_X);
+          Y_STEP_WRITE(STEP_STATE_Y);
+          Z_STEP_WRITE(STEP_STATE_Z);
 
           _PULSE_WAIT();
 
-          #ifdef X_STEP_WRITE
-            X_STEP_WRITE(!STEP_STATE_X);
-          #endif
-          #ifdef Y_STEP_WRITE
-            Y_STEP_WRITE(!STEP_STATE_Y);
-          #endif
-          #ifdef Z_STEP_WRITE
-            Z_STEP_WRITE(!STEP_STATE_Z);
-          #endif
+          X_STEP_WRITE(!STEP_STATE_X);
+          Y_STEP_WRITE(!STEP_STATE_Y);
+          Z_STEP_WRITE(!STEP_STATE_Z);
 
           // Restore direction bits
           EXTRA_DIR_WAIT_BEFORE();
 
-          #ifdef X_DIR_WRITE
-            X_DIR_WRITE(old_dir.x);
-          #endif
-          #ifdef Y_DIR_WRITE
-            Y_DIR_WRITE(old_dir.y);
-          #endif
-          #ifdef Z_DIR_WRITE
-            Z_DIR_WRITE(old_dir.z);
-          #endif
+          X_DIR_WRITE(old_fwd[A_AXIS]);
+          Y_DIR_WRITE(old_fwd[B_AXIS]);
+          Z_DIR_WRITE(old_fwd[C_AXIS]);
 
           EXTRA_DIR_WAIT_AFTER();
 
@@ -3762,25 +3730,6 @@ void Stepper::report_positions() {
 
       } break;
 
-      #if HAS_I_AXIS
-        case I_AXIS: BABYSTEP_AXIS(I, direction, 0); break;
-      #endif
-      #if HAS_J_AXIS
-        case J_AXIS: BABYSTEP_AXIS(J, direction, 0); break;
-      #endif
-      #if HAS_K_AXIS
-        case K_AXIS: BABYSTEP_AXIS(K, direction, 0); break;
-      #endif
-      #if HAS_U_AXIS
-        case U_AXIS: BABYSTEP_AXIS(U, direction, 0); break;
-      #endif
-      #if HAS_V_AXIS
-        case V_AXIS: BABYSTEP_AXIS(V, direction, 0); break;
-      #endif
-      #if HAS_W_AXIS
-        case W_AXIS: BABYSTEP_AXIS(W, direction, 0); break;
-      #endif
-
       default: break;
     }
 

commit f2071770984e393ed524d924ff501fc2cd42849d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 7 21:25:53 2023 -0500

    🐛 Fix Babystepping for CoreXZ
    
    Fixes #19988

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 750bf11c46..7517bcd0a6 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3670,7 +3670,7 @@ void Stepper::report_positions() {
 
         case Y_AXIS:
           #if CORE_IS_XY
-            BABYSTEP_CORE(X, Y, !direction, 1, (CORESIGN(1)>0));
+            BABYSTEP_CORE(X, Y, direction, 0, (CORESIGN(1)>0));
           #elif CORE_IS_YZ
             BABYSTEP_CORE(Y, Z, direction, 0, (CORESIGN(1)<0));
           #else
@@ -3683,7 +3683,7 @@ void Stepper::report_positions() {
       case Z_AXIS: {
 
         #if CORE_IS_XZ
-          BABYSTEP_CORE(X, Z, direction, BABYSTEP_INVERT_Z, (CORESIGN(1)<0));
+          BABYSTEP_CORE(X, Z, direction, BABYSTEP_INVERT_Z, (CORESIGN(1)>0));
         #elif CORE_IS_YZ
           BABYSTEP_CORE(Y, Z, direction, BABYSTEP_INVERT_Z, (CORESIGN(1)<0));
         #elif DISABLED(DELTA)

commit d3ee4eecdf11810ab3da2ff448bfd298e03a740e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 7 19:31:20 2023 -0500

    🩹 Use AxisBits methods

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index a311592540..750bf11c46 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2583,7 +2583,7 @@ hal_timer_t Stepper::block_phase_isr() {
       #if IS_CORE
         // Define conditions for checking endstops
         #define S_(N) current_block->steps[CORE_AXIS_##N]
-        #define D_(N) TEST(current_block->direction_bits, CORE_AXIS_##N)
+        #define D_(N) current_block->direction_bits[CORE_AXIS_##N]
       #endif
 
       #if CORE_IS_XY || CORE_IS_XZ
@@ -2646,20 +2646,20 @@ hal_timer_t Stepper::block_phase_isr() {
 
       AxisBits axis_bits;
       NUM_AXIS_CODE(
-        if (X_MOVE_TEST)            SBI(axis_bits, A_AXIS),
-        if (Y_MOVE_TEST)            SBI(axis_bits, B_AXIS),
-        if (Z_MOVE_TEST)            SBI(axis_bits, C_AXIS),
-        if (current_block->steps.i) SBI(axis_bits, I_AXIS),
-        if (current_block->steps.j) SBI(axis_bits, J_AXIS),
-        if (current_block->steps.k) SBI(axis_bits, K_AXIS),
-        if (current_block->steps.u) SBI(axis_bits, U_AXIS),
-        if (current_block->steps.v) SBI(axis_bits, V_AXIS),
-        if (current_block->steps.w) SBI(axis_bits, W_AXIS)
+        if (X_MOVE_TEST)            axis_bits.a = true,
+        if (Y_MOVE_TEST)            axis_bits.b = true,
+        if (Z_MOVE_TEST)            axis_bits.c = true,
+        if (current_block->steps.i) axis_bits.i = true,
+        if (current_block->steps.j) axis_bits.j = true,
+        if (current_block->steps.k) axis_bits.k = true,
+        if (current_block->steps.u) axis_bits.u = true,
+        if (current_block->steps.v) axis_bits.v = true,
+        if (current_block->steps.w) axis_bits.w = true
       );
-      //if (current_block->steps.e) SBI(axis_bits, E_AXIS);
-      //if (current_block->steps.a) SBI(axis_bits, X_HEAD);
-      //if (current_block->steps.b) SBI(axis_bits, Y_HEAD);
-      //if (current_block->steps.c) SBI(axis_bits, Z_HEAD);
+      //if (current_block->steps.e) axis_bits.e = true;
+      //if (current_block->steps.a) axis_bits.x = true;
+      //if (current_block->steps.b) axis_bits.y = true;
+      //if (current_block->steps.c) axis_bits.z = true;
       axis_did_move = axis_bits;
 
       // No acceleration / deceleration time elapsed so far
@@ -3487,7 +3487,7 @@ void Stepper::report_positions() {
       // If the current block is not done processing, return right away
       if (!fxdTiCtrl.getBlockProcDn()) return;
 
-      axis_did_move = 0;
+      axis_did_move.reset();
       current_block = nullptr;
       discard_current_block();
     }
@@ -3533,25 +3533,25 @@ void Stepper::report_positions() {
                                 // or the set conditions should be changed from the block to
                                 // the motion trajectory or motor commands.
 
-    uint8_t axis_bits = 0U;
+    AxisBits axis_bits;
 
     static uint32_t a_debounce = 0U;
     if (!!current_block->steps.a) a_debounce = (AXIS_DID_MOVE_DEB) * 400; // divide by 0.0025f
-    if (a_debounce) { SBI(axis_bits, A_AXIS); a_debounce--; }
+    if (a_debounce) { axis_bits.a = true; a_debounce--; }
     #if HAS_Y_AXIS
       static uint32_t b_debounce = 0U;
       if (!!current_block->steps.b) b_debounce = (AXIS_DID_MOVE_DEB) * 400;
-      if (b_debounce) { SBI(axis_bits, B_AXIS); b_debounce--; }
+      if (b_debounce) { axis_bits.b = true; b_debounce--; }
     #endif
     #if HAS_Z_AXIS
       static uint32_t c_debounce = 0U;
       if (!!current_block->steps.c) c_debounce = (AXIS_DID_MOVE_DEB) * 400;
-      if (c_debounce) { SBI(axis_bits, C_AXIS); c_debounce--; }
+      if (c_debounce) { axis_bits.c = true; c_debounce--; }
     #endif
     #if HAS_EXTRUDERS
       static uint32_t e_debounce = 0U;
       if (!!current_block->steps.e) e_debounce = (AXIS_DID_MOVE_DEB) * 400;
-      if (e_debounce) { SBI(axis_bits, E_AXIS); e_debounce--; }
+      if (e_debounce) { axis_bits.e = true; e_debounce--; }
     #endif
 
     axis_did_move = axis_bits;

commit 99a9e265b0b7356b4d3bc5fdef88e2afe1ab0623
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 6 19:07:07 2023 -0500

    🩹 Endstops prelim. followup

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index ec85db35d6..a311592540 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -287,7 +287,7 @@ xyze_int8_t Stepper::count_direction{0};
 #define MINDIR(A) (count_direction[_AXIS(A)] < 0)
 #define MAXDIR(A) (count_direction[_AXIS(A)] > 0)
 
-#define STEPTEST(A,M,I) TERN0(HAS_ ##A## ##I## _ ##M, !(TEST(endstops.state(), A## ##I## _ ##M) && M## DIR(A)) && !locked_ ##A## ##I## _motor)
+#define STEPTEST(A,M,I) TERN0(USE_##A##I##_##M, !(TEST(endstops.state(), A##I##_##M) && M## DIR(A)) && !locked_ ##A##I##_motor)
 
 #define DUAL_ENDSTOP_APPLY_STEP(A,V)             \
   if (separate_multi_axis) {                     \

commit d93aa0c38449bcbc38aeca7eac506297270546c8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 6 16:42:21 2023 -0500

    🐛 Apply direction bits at startup

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c7c053679a..ec85db35d6 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3156,6 +3156,9 @@ void Stepper::init() {
     sei();
   #endif
 
+  // Init direction states
+  apply_directions();
+
   #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
     initialized = true;
     digipot_init();

commit af4ba2b1ced98066b89dde7636b052b075f96621
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 17:42:56 2023 -0500

    🐛 Minor Fixed-Time Motion patches

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 140a539ef3..c7c053679a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3466,7 +3466,7 @@ void Stepper::report_positions() {
 
     #if HAS_Z_AXIS
       // Update step counts
-      if (z_step) count_position.z += z_dir ? -1 : 1;
+      if (z_step) count_position.z += z_dir ? 1 : -1;
     #endif
 
     AWAIT_HIGH_PULSE();

commit 664b35b77c0ddf9562de6e74dd253f5bb33ce6b0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 03:03:33 2023 -0500

    🧑‍💻 Replace axis_bits_t with AxisBits class (#25761)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 8a4d801e76..140a539ef3 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -166,8 +166,8 @@ stepper_flags_t Stepper::axis_enabled; // {0}
 
 block_t* Stepper::current_block; // (= nullptr) A pointer to the block currently being traced
 
-axis_bits_t Stepper::last_direction_bits, // = 0
-            Stepper::axis_did_move; // = 0
+AxisBits Stepper::last_direction_bits, // = 0
+         Stepper::axis_did_move; // = 0
 
 bool Stepper::abort_current_block;
 
@@ -624,15 +624,11 @@ void Stepper::apply_directions() {
 
   DIR_WAIT_BEFORE();
 
-  TERN_(HAS_X_DIR, SET_STEP_DIR(X)); // A
-  TERN_(HAS_Y_DIR, SET_STEP_DIR(Y)); // B
-  TERN_(HAS_Z_DIR, SET_STEP_DIR(Z)); // C
-  TERN_(HAS_I_DIR, SET_STEP_DIR(I));
-  TERN_(HAS_J_DIR, SET_STEP_DIR(J));
-  TERN_(HAS_K_DIR, SET_STEP_DIR(K));
-  TERN_(HAS_U_DIR, SET_STEP_DIR(U));
-  TERN_(HAS_V_DIR, SET_STEP_DIR(V));
-  TERN_(HAS_W_DIR, SET_STEP_DIR(W));
+  NUM_AXIS_CODE(
+    SET_STEP_DIR(X), SET_STEP_DIR(Y), SET_STEP_DIR(Z), // ABC
+    SET_STEP_DIR(I), SET_STEP_DIR(J), SET_STEP_DIR(K),
+    SET_STEP_DIR(U), SET_STEP_DIR(V), SET_STEP_DIR(W)
+  );
 
   #if HAS_EXTRUDERS
      // Because this is valid for the whole block we don't know
@@ -1829,7 +1825,7 @@ void Stepper::pulse_phase_isr() {
         de += step_fwd ? -128 : 128; \
         if ((MAXDIR(AXIS) && step_bak) || (MINDIR(AXIS) && step_fwd)) { \
           { USING_TIMED_PULSE(); START_TIMED_PULSE(); AWAIT_LOW_PULSE(); } \
-          TBI(last_direction_bits, _AXIS(AXIS)); \
+          last_direction_bits.toggle(_AXIS(AXIS)); \
           DIR_WAIT_BEFORE(); \
           SET_STEP_DIR(AXIS); \
           DIR_WAIT_AFTER(); \
@@ -1861,11 +1857,11 @@ void Stepper::pulse_phase_isr() {
 
         #if STEPPER_PAGE_FORMAT == SP_4x4D_128
 
-          #define PAGE_SEGMENT_UPDATE(AXIS, VALUE) do{   \
-                 if ((VALUE) <  7) SBI(dm, _AXIS(AXIS)); \
-            else if ((VALUE) >  7) CBI(dm, _AXIS(AXIS)); \
-            page_step_state.sd[_AXIS(AXIS)] = VALUE;     \
-            page_step_state.bd[_AXIS(AXIS)] += VALUE;    \
+          #define PAGE_SEGMENT_UPDATE(AXIS, VALUE) do{      \
+                 if ((VALUE) <  7) dm[_AXIS(AXIS)] = true;  \
+            else if ((VALUE) >  7) dm[_AXIS(AXIS)] = false; \
+            page_step_state.sd[_AXIS(AXIS)] = VALUE;        \
+            page_step_state.bd[_AXIS(AXIS)] += VALUE;       \
           }while(0)
 
           #define PAGE_PULSE_PREP(AXIS) do{ \
@@ -1881,7 +1877,7 @@ void Stepper::pulse_phase_isr() {
             case 0: {
               const uint8_t low = page_step_state.page[page_step_state.segment_idx],
                            high = page_step_state.page[page_step_state.segment_idx + 1];
-              axis_bits_t dm = last_direction_bits;
+              const AxisBits dm = last_direction_bits;
 
               PAGE_SEGMENT_UPDATE(X, low >> 4);
               PAGE_SEGMENT_UPDATE(Y, low & 0xF);
@@ -2417,7 +2413,7 @@ hal_timer_t Stepper::block_phase_isr() {
               la_interval = calc_timer_interval((reverse_e ? la_step_rate - step_rate : step_rate - la_step_rate) >> current_block->la_scaling);
 
               if (reverse_e != motor_direction(E_AXIS)) {
-                TBI(last_direction_bits, E_AXIS);
+                last_direction_bits.toggle(E_AXIS);
                 count_direction.e = -count_direction.e;
 
                 DIR_WAIT_BEFORE();
@@ -2648,7 +2644,7 @@ hal_timer_t Stepper::block_phase_isr() {
         #define Z_MOVE_TEST !!current_block->steps.c
       #endif
 
-      axis_bits_t axis_bits = 0;
+      AxisBits axis_bits;
       NUM_AXIS_CODE(
         if (X_MOVE_TEST)            SBI(axis_bits, A_AXIS),
         if (Y_MOVE_TEST)            SBI(axis_bits, B_AXIS),
@@ -2692,24 +2688,24 @@ hal_timer_t Stepper::block_phase_isr() {
 
       #if ENABLED(INPUT_SHAPING_X)
         if (shaping_x.enabled) {
-          const int64_t steps = TEST(current_block->direction_bits, X_AXIS) ? -int64_t(current_block->steps.x) : int64_t(current_block->steps.x);
+          const int64_t steps = current_block->direction_bits.x ? -int64_t(current_block->steps.x) : int64_t(current_block->steps.x);
           shaping_x.last_block_end_pos += steps;
 
           // If there are any remaining echos unprocessed, then direction change must
           // be delayed and processed in PULSE_PREP_SHAPING. This will cause half a step
           // to be missed, which will need recovering and this can be done through shaping_x.remainder.
-          shaping_x.forward = !TEST(current_block->direction_bits, X_AXIS);
-          if (!ShapingQueue::empty_x()) SET_BIT_TO(current_block->direction_bits, X_AXIS, TEST(last_direction_bits, X_AXIS));
+          shaping_x.forward = !current_block->direction_bits.x;
+          if (!ShapingQueue::empty_x()) current_block->direction_bits.x = last_direction_bits.x;
         }
       #endif
 
       // Y follows the same logic as X (but the comments aren't repeated)
       #if ENABLED(INPUT_SHAPING_Y)
         if (shaping_y.enabled) {
-          const int64_t steps = TEST(current_block->direction_bits, Y_AXIS) ? -int64_t(current_block->steps.y) : int64_t(current_block->steps.y);
+          const int64_t steps = current_block->direction_bits.y ? -int64_t(current_block->steps.y) : int64_t(current_block->steps.y);
           shaping_y.last_block_end_pos += steps;
-          shaping_y.forward = !TEST(current_block->direction_bits, Y_AXIS);
-          if (!ShapingQueue::empty_y()) SET_BIT_TO(current_block->direction_bits, Y_AXIS, TEST(last_direction_bits, Y_AXIS));
+          shaping_y.forward = !current_block->direction_bits.y;
+          if (!ShapingQueue::empty_y()) current_block->direction_bits.y = last_direction_bits.y;
         }
       #endif
 
@@ -2912,24 +2908,10 @@ void Stepper::init() {
       Z4_DIR_INIT();
     #endif
   #endif
-  #if HAS_I_DIR
-    I_DIR_INIT();
-  #endif
-  #if HAS_J_DIR
-    J_DIR_INIT();
-  #endif
-  #if HAS_K_DIR
-    K_DIR_INIT();
-  #endif
-  #if HAS_U_DIR
-    U_DIR_INIT();
-  #endif
-  #if HAS_V_DIR
-    V_DIR_INIT();
-  #endif
-  #if HAS_W_DIR
-    W_DIR_INIT();
-  #endif
+  SECONDARY_AXIS_CODE(
+    I_DIR_INIT(), J_DIR_INIT(), K_DIR_INIT(),
+    U_DIR_INIT(), V_DIR_INIT(), W_DIR_INIT()
+  );
   #if HAS_E0_DIR
     E0_DIR_INIT();
   #endif

commit 2538a7c4d6148d8249f5418a76c58ec483343d2b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 29 21:28:12 2023 -0500

    🧑‍💻 Move DIR inverting to *_DIR_WRITE

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 9bb93597e2..8a4d801e76 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -477,6 +477,15 @@ xyze_int8_t Stepper::count_direction{0};
   #define W_APPLY_STEP(v,Q) W_STEP_WRITE(v)
 #endif
 
+#define E0_APPLY_DIR(REV) do{ (REV) ? FWD_E_DIR(0) : REV_E_DIR(0); }while(0)
+#define E1_APPLY_DIR(REV) do{ (REV) ? FWD_E_DIR(1) : REV_E_DIR(1); }while(0)
+#define E2_APPLY_DIR(REV) do{ (REV) ? FWD_E_DIR(2) : REV_E_DIR(2); }while(0)
+#define E3_APPLY_DIR(REV) do{ (REV) ? FWD_E_DIR(3) : REV_E_DIR(3); }while(0)
+#define E4_APPLY_DIR(REV) do{ (REV) ? FWD_E_DIR(4) : REV_E_DIR(4); }while(0)
+#define E5_APPLY_DIR(REV) do{ (REV) ? FWD_E_DIR(5) : REV_E_DIR(5); }while(0)
+#define E6_APPLY_DIR(REV) do{ (REV) ? FWD_E_DIR(6) : REV_E_DIR(6); }while(0)
+#define E7_APPLY_DIR(REV) do{ (REV) ? FWD_E_DIR(7) : REV_E_DIR(7); }while(0)
+
 #if DISABLED(MIXING_EXTRUDER)
   #define E_APPLY_STEP(v,Q) E_STEP_WRITE(stepper_extruder, v)
 #endif
@@ -592,14 +601,16 @@ void Stepper::disable_all_steppers() {
   TERN_(EXTENSIBLE_UI, ExtUI::onSteppersDisabled());
 }
 
-#define SET_STEP_DIR(A)                         \
-  if (motor_direction(_AXIS(A))) {              \
-    A##_APPLY_DIR(INVERT_DIR(A, LOW), false);   \
-    count_direction[_AXIS(A)] = -1;             \
-  }                                             \
-  else {                                        \
-    A##_APPLY_DIR(INVERT_DIR(A, HIGH), false);  \
-    count_direction[_AXIS(A)] = 1;              \
+// Set a single axis direction based on the last set flags.
+// A direction bit of "1" indicates reverse or negative motion.
+#define SET_STEP_DIR(A)             \
+  if (motor_direction(_AXIS(A))) {  \
+    A##_APPLY_DIR(LOW, false);      \
+    count_direction[_AXIS(A)] = -1; \
+  }                                 \
+  else {                            \
+    A##_APPLY_DIR(HIGH, false);     \
+    count_direction[_AXIS(A)] = 1;  \
   }
 
 /**
@@ -2402,7 +2413,7 @@ hal_timer_t Stepper::block_phase_isr() {
           if (la_active) {
             const uint32_t la_step_rate = la_advance_steps > current_block->final_adv_steps ? current_block->la_advance_rate : 0;
             if (la_step_rate != step_rate) {
-              bool reverse_e = la_step_rate > step_rate;
+              const bool reverse_e = la_step_rate > step_rate;
               la_interval = calc_timer_interval((reverse_e ? la_step_rate - step_rate : step_rate - la_step_rate) >> current_block->la_scaling);
 
               if (reverse_e != motor_direction(E_AXIS)) {
@@ -3163,21 +3174,6 @@ void Stepper::init() {
     sei();
   #endif
 
-  // Init direction bits for first moves
-  set_directions(0
-    NUM_AXIS_GANG(
-      | TERN0(INVERT_X_DIR, _BV(X_AXIS)),
-      | TERN0(INVERT_Y_DIR, _BV(Y_AXIS)),
-      | TERN0(INVERT_Z_DIR, _BV(Z_AXIS)),
-      | TERN0(INVERT_I_DIR, _BV(I_AXIS)),
-      | TERN0(INVERT_J_DIR, _BV(J_AXIS)),
-      | TERN0(INVERT_K_DIR, _BV(K_AXIS)),
-      | TERN0(INVERT_U_DIR, _BV(U_AXIS)),
-      | TERN0(INVERT_V_DIR, _BV(V_AXIS)),
-      | TERN0(INVERT_W_DIR, _BV(W_AXIS))
-    )
-  );
-
   #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
     initialized = true;
     digipot_init();
@@ -3472,10 +3468,10 @@ void Stepper::report_positions() {
     #endif
 
     if (applyDir) {
-      TERN_(HAS_X_AXIS, X_DIR_WRITE(INVERT_DIR(X, TEST(command, FT_BIT_DIR_X))));
-      TERN_(HAS_Y_AXIS, Y_DIR_WRITE(INVERT_DIR(Y, TEST(command, FT_BIT_DIR_Y))));
-      TERN_(HAS_Z_AXIS, Z_DIR_WRITE(INVERT_DIR(Z, z_dir)));
-      TERN_(HAS_EXTRUDERS, E0_DIR_WRITE(INVERT_DIR(E0, TEST(command, FT_BIT_DIR_E))));
+      TERN_(HAS_X_AXIS, X_DIR_WRITE(TEST(command, FT_BIT_DIR_X)));
+      TERN_(HAS_Y_AXIS, Y_DIR_WRITE(TEST(command, FT_BIT_DIR_Y)));
+      TERN_(HAS_Z_AXIS, Z_DIR_WRITE(z_dir));
+      TERN_(HAS_EXTRUDERS, E0_DIR_WRITE(TEST(command, FT_BIT_DIR_E)));
       DIR_WAIT_AFTER();
     }
 
@@ -3632,7 +3628,7 @@ void Stepper::report_positions() {
       const uint8_t old_dir = _READ_DIR(AXIS);          \
       _ENABLE_AXIS(AXIS);                               \
       DIR_WAIT_BEFORE();                                \
-      _APPLY_DIR(AXIS, INVERT_DIR(AXIS, (DIR)^(INV)));  \
+      _APPLY_DIR(AXIS, (DIR)^(INV));                    \
       DIR_WAIT_AFTER();                                 \
       _SAVE_START();                                    \
       _APPLY_STEP(AXIS, _STEP_STATE(AXIS), true);       \
@@ -3651,8 +3647,8 @@ void Stepper::report_positions() {
       const xy_byte_t old_dir = { _READ_DIR(A), _READ_DIR(B) }; \
       _ENABLE_AXIS(A); _ENABLE_AXIS(B);                         \
       DIR_WAIT_BEFORE();                                        \
-      _APPLY_DIR(A, INVERT_DIR(A, (DIR)^(INV)));                \
-      _APPLY_DIR(B, INVERT_DIR(B, (DIR)^(INV)^(ALT)));          \
+      _APPLY_DIR(A, (DIR)^(INV));                               \
+      _APPLY_DIR(B, (DIR)^(INV)^(ALT));                         \
       DIR_WAIT_AFTER();                                         \
       _SAVE_START();                                            \
       _APPLY_STEP(A, _STEP_STATE(A), true);                     \
@@ -3710,7 +3706,7 @@ void Stepper::report_positions() {
 
         #else // DELTA
 
-          const bool z_direction = direction ^ BABYSTEP_INVERT_Z;
+          const bool z_direction = TERN_(BABYSTEP_INVERT_Z, !) direction;
 
           NUM_AXIS_CODE(
             enable_axis(X_AXIS), enable_axis(Y_AXIS), enable_axis(Z_AXIS),
@@ -3727,13 +3723,13 @@ void Stepper::report_positions() {
           );
 
           #ifdef X_DIR_WRITE
-            X_DIR_WRITE(INVERT_DIR(X, z_direction));
+            X_DIR_WRITE(z_direction);
           #endif
           #ifdef Y_DIR_WRITE
-            Y_DIR_WRITE(INVERT_DIR(Y, z_direction));
+            Y_DIR_WRITE(z_direction);
           #endif
           #ifdef Z_DIR_WRITE
-            Z_DIR_WRITE(INVERT_DIR(Z, z_direction));
+            Z_DIR_WRITE(z_direction);
           #endif
 
           DIR_WAIT_AFTER();

commit 573bc7344bcd66c08bf8cccbc90a29faa4d55030
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 29 20:20:49 2023 -0500

    🎨 NORM_E_DIR => FWD_E_DIR

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index bda5319dfc..9bb93597e2 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -636,9 +636,9 @@ void Stepper::apply_directions() {
     }
     else {
       #if ENABLED(MIXING_EXTRUDER)
-        MIXER_STEPPER_LOOP(j) NORM_E_DIR(j);
+        MIXER_STEPPER_LOOP(j) FWD_E_DIR(j);
       #else
-        NORM_E_DIR(stepper_extruder);
+        FWD_E_DIR(stepper_extruder);
       #endif
       count_direction.e = 1;
     }
@@ -2420,9 +2420,9 @@ hal_timer_t Stepper::block_phase_isr() {
                 }
                 else {
                   #if ENABLED(MIXING_EXTRUDER)
-                    MIXER_STEPPER_LOOP(j) NORM_E_DIR(j);
+                    MIXER_STEPPER_LOOP(j) FWD_E_DIR(j);
                   #else
-                    NORM_E_DIR(stepper_extruder);
+                    FWD_E_DIR(stepper_extruder);
                   #endif
                 }
 

commit 673e6d5380017f6cb30e75a3cc0c9d7385bf2654
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 4 21:32:46 2023 -0500

    🧑‍💻 Split up stepper.h header

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 790b118c6d..bda5319dfc 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -83,6 +83,7 @@ Stepper stepper; // Singleton
 
 #define BABYSTEPPING_EXTRA_DIR_WAIT
 
+#include "stepper/cycles.h"
 #ifdef __AVR__
   #include "stepper/speed_lookuptable.h"
 #endif

commit ec6bc15d1b52f480e88ad4a21c87f175d1388226
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 29 20:10:33 2023 -0500

    🐛 Fix FT Motion reversed Z

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 32e97c2a06..790b118c6d 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3466,7 +3466,7 @@ void Stepper::report_positions() {
     #if HAS_Z_AXIS
       // Z is handled differently to update the stepper
       // counts (needed by Marlin for bed level probing).
-      const bool z_dir = !TEST(command, FT_BIT_DIR_Z),
+      const bool z_dir = TEST(command, FT_BIT_DIR_Z),
                 z_step = TEST(command, FT_BIT_STEP_Z);
     #endif
 

commit d364babbc0cdb73337d86e2c4fd9170b46b7361a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 26 14:29:21 2023 -0500

    🧑‍💻 Change HAL_PATH macro for easier HAL relocation (#25743)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index f26e10a4bd..32e97c2a06 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3985,7 +3985,7 @@ void Stepper::report_positions() {
 
 #else // PRINTRBOARD_G2
 
-  #include HAL_PATH(../HAL, fastio/G2_PWM.h)
+  #include HAL_PATH(.., fastio/G2_PWM.h)
 
 #endif
 

commit f0f7ec88823318c7d778e42b4dc7604120943032
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 23 00:47:44 2023 -0500

    🧑‍💻 Stepper::set_directions() => apply_directions()

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 045df05981..f26e10a4bd 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -608,7 +608,7 @@ void Stepper::disable_all_steppers() {
  *   COREXZ: X_AXIS=A_AXIS and Z_AXIS=C_AXIS
  *   COREYZ: Y_AXIS=B_AXIS and Z_AXIS=C_AXIS
  */
-void Stepper::set_directions() {
+void Stepper::apply_directions() {
 
   DIR_WAIT_BEFORE();
 

commit ded9ffa1e7cc154518fe94b5c7da4f4332eb8a27
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 20 17:35:20 2023 -0500

    🧑‍💻 Apply INVERT_DIR to SET_STEP_DIR

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 373d86970a..045df05981 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -591,14 +591,14 @@ void Stepper::disable_all_steppers() {
   TERN_(EXTENSIBLE_UI, ExtUI::onSteppersDisabled());
 }
 
-#define SET_STEP_DIR(A)                       \
-  if (motor_direction(_AXIS(A))) {            \
-    A##_APPLY_DIR(INVERT_##A##_DIR, false);   \
-    count_direction[_AXIS(A)] = -1;           \
-  }                                           \
-  else {                                      \
-    A##_APPLY_DIR(!INVERT_##A##_DIR, false);  \
-    count_direction[_AXIS(A)] = 1;            \
+#define SET_STEP_DIR(A)                         \
+  if (motor_direction(_AXIS(A))) {              \
+    A##_APPLY_DIR(INVERT_DIR(A, LOW), false);   \
+    count_direction[_AXIS(A)] = -1;             \
+  }                                             \
+  else {                                        \
+    A##_APPLY_DIR(INVERT_DIR(A, HIGH), false);  \
+    count_direction[_AXIS(A)] = 1;              \
   }
 
 /**

commit 335ba32a0e71991402d3686162afc429130db4ec
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 20 17:21:59 2023 -0500

    🩹 Fix Core Kinematics BABYSTEP_XY

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 9728a90896..373d86970a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3627,7 +3627,7 @@ void Stepper::report_positions() {
 
   #if DISABLED(DELTA)
 
-    #define BABYSTEP_AXIS(AXIS, INV, DIR) do{           \
+    #define BABYSTEP_AXIS(AXIS, DIR, INV) do{           \
       const uint8_t old_dir = _READ_DIR(AXIS);          \
       _ENABLE_AXIS(AXIS);                               \
       DIR_WAIT_BEFORE();                                \
@@ -3646,12 +3646,12 @@ void Stepper::report_positions() {
 
   #if IS_CORE
 
-    #define BABYSTEP_CORE(A, B, INV, DIR, ALT) do{              \
+    #define BABYSTEP_CORE(A, B, DIR, INV, ALT) do{              \
       const xy_byte_t old_dir = { _READ_DIR(A), _READ_DIR(B) }; \
       _ENABLE_AXIS(A); _ENABLE_AXIS(B);                         \
       DIR_WAIT_BEFORE();                                        \
-      _APPLY_DIR(A, INVERT_DIR(A, (DIR)^(INV));                 \
-      _APPLY_DIR(B, INVERT_DIR(B, (DIR)^(INV)^(ALT));           \
+      _APPLY_DIR(A, INVERT_DIR(A, (DIR)^(INV)));                \
+      _APPLY_DIR(B, INVERT_DIR(B, (DIR)^(INV)^(ALT)));          \
       DIR_WAIT_AFTER();                                         \
       _SAVE_START();                                            \
       _APPLY_STEP(A, _STEP_STATE(A), true);                     \
@@ -3678,21 +3678,21 @@ void Stepper::report_positions() {
 
         case X_AXIS:
           #if CORE_IS_XY
-            BABYSTEP_CORE(X, Y, 0, direction, 0);
+            BABYSTEP_CORE(X, Y, direction, 0, 0);
           #elif CORE_IS_XZ
-            BABYSTEP_CORE(X, Z, 0, direction, 0);
+            BABYSTEP_CORE(X, Z, direction, 0, 0);
           #else
-            BABYSTEP_AXIS(X, 0, direction);
+            BABYSTEP_AXIS(X, direction, 0);
           #endif
           break;
 
         case Y_AXIS:
           #if CORE_IS_XY
-            BABYSTEP_CORE(X, Y, 1, !direction, (CORESIGN(1)>0));
+            BABYSTEP_CORE(X, Y, !direction, 1, (CORESIGN(1)>0));
           #elif CORE_IS_YZ
-            BABYSTEP_CORE(Y, Z, 0, direction, (CORESIGN(1)<0));
+            BABYSTEP_CORE(Y, Z, direction, 0, (CORESIGN(1)<0));
           #else
-            BABYSTEP_AXIS(Y, 0, direction);
+            BABYSTEP_AXIS(Y, direction, 0);
           #endif
           break;
 
@@ -3701,11 +3701,11 @@ void Stepper::report_positions() {
       case Z_AXIS: {
 
         #if CORE_IS_XZ
-          BABYSTEP_CORE(X, Z, BABYSTEP_INVERT_Z, direction, (CORESIGN(1)<0));
+          BABYSTEP_CORE(X, Z, direction, BABYSTEP_INVERT_Z, (CORESIGN(1)<0));
         #elif CORE_IS_YZ
-          BABYSTEP_CORE(Y, Z, BABYSTEP_INVERT_Z, direction, (CORESIGN(1)<0));
+          BABYSTEP_CORE(Y, Z, direction, BABYSTEP_INVERT_Z, (CORESIGN(1)<0));
         #elif DISABLED(DELTA)
-          BABYSTEP_AXIS(Z, BABYSTEP_INVERT_Z, direction);
+          BABYSTEP_AXIS(Z, direction, BABYSTEP_INVERT_Z);
 
         #else // DELTA
 
@@ -3781,22 +3781,22 @@ void Stepper::report_positions() {
       } break;
 
       #if HAS_I_AXIS
-        case I_AXIS: BABYSTEP_AXIS(I, 0, direction); break;
+        case I_AXIS: BABYSTEP_AXIS(I, direction, 0); break;
       #endif
       #if HAS_J_AXIS
-        case J_AXIS: BABYSTEP_AXIS(J, 0, direction); break;
+        case J_AXIS: BABYSTEP_AXIS(J, direction, 0); break;
       #endif
       #if HAS_K_AXIS
-        case K_AXIS: BABYSTEP_AXIS(K, 0, direction); break;
+        case K_AXIS: BABYSTEP_AXIS(K, direction, 0); break;
       #endif
       #if HAS_U_AXIS
-        case U_AXIS: BABYSTEP_AXIS(U, 0, direction); break;
+        case U_AXIS: BABYSTEP_AXIS(U, direction, 0); break;
       #endif
       #if HAS_V_AXIS
-        case V_AXIS: BABYSTEP_AXIS(V, 0, direction); break;
+        case V_AXIS: BABYSTEP_AXIS(V, direction, 0); break;
       #endif
       #if HAS_W_AXIS
-        case W_AXIS: BABYSTEP_AXIS(W, 0, direction); break;
+        case W_AXIS: BABYSTEP_AXIS(W, direction, 0); break;
       #endif
 
       default: break;

commit e6308f5d027d2e8ff633aaf035787a1be9da0d58
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 17 18:10:07 2023 -0500

    🩹 const_float_t => float

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 3cca0516ff..9728a90896 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3198,9 +3198,9 @@ void Stepper::init() {
     else if (zeta >= 1.0f) factor2 = 0.0f;
     else {
       factor2 = 64.44056192 + -99.02008832 * zeta;
-      const_float_t zeta2 = zeta * zeta;
+      const float zeta2 = sq(zeta);
       factor2 += -7.58095488 * zeta2;
-      const_float_t zeta3 = zeta2 * zeta;
+      const float zeta3 = zeta2 * zeta;
       factor2 += 43.073216 * zeta3;
       factor2 = floor(factor2);
     }

commit 4d8ab1c401170e345b11e971773a87d87272a82a
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Mon Apr 17 23:48:56 2023 +0100

    🐛 Prevent Linear Advance stall (#25696)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 7bf50e557f..3cca0516ff 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1578,7 +1578,7 @@ void Stepper::isr() {
           advance_isr();
           nextAdvanceISR = la_interval;
         }
-        else if (nextAdvanceISR == LA_ADV_NEVER)          // Start LA steps if necessary
+        else if (nextAdvanceISR > la_interval)            // Start/accelerate LA steps if necessary
           nextAdvanceISR = la_interval;
       #endif
 
@@ -2169,7 +2169,8 @@ hal_timer_t Stepper::calc_timer_interval(uint32_t step_rate) {
   #ifdef CPU_32_BIT
 
     // A fast processor can just do integer division
-    return step_rate ? uint32_t(STEPPER_TIMER_RATE) / step_rate : HAL_TIMER_TYPE_MAX;
+    constexpr uint32_t min_step_rate = uint32_t(STEPPER_TIMER_RATE) / HAL_TIMER_TYPE_MAX;
+    return step_rate > min_step_rate ? uint32_t(STEPPER_TIMER_RATE) / step_rate : HAL_TIMER_TYPE_MAX;
 
   #else
 

commit 74b205c7abfa5cf9bc487edcd6a26a75a6c9a0cb
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Fri Apr 7 18:32:25 2023 +1200

    🚸 Support CoreXY without Z (#25630)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index cc353b42e2..7bf50e557f 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3276,7 +3276,7 @@ void Stepper::_set_position(const abce_long_t &spos) {
     #if CORE_IS_XY
       // corexy positioning
       // these equations follow the form of the dA and dB equations on https://www.corexy.com/theory.html
-      count_position.set(spos.a + spos.b, CORESIGN(spos.a - spos.b), spos.c);
+      count_position.set(spos.a + spos.b, CORESIGN(spos.a - spos.b) OPTARG(HAS_Z_AXIS, spos.c));
     #elif CORE_IS_XZ
       // corexz planning
       count_position.set(spos.a + spos.c, spos.b, CORESIGN(spos.a - spos.c));

commit 4aec74f2465a14b2660a2c28e1da39f1013cb521
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 5 11:58:24 2023 -0500

    🐛 INVERT_*_DIR for FT_MOTION (#25637)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index f40afc6191..cc353b42e2 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -382,7 +382,7 @@ xyze_int8_t Stepper::count_direction{0};
   }
 
 #if HAS_DUAL_X_STEPPERS
-  #define X_APPLY_DIR(v,Q) do{ X_DIR_WRITE(v); X2_DIR_WRITE((v) ^ ENABLED(INVERT_X2_VS_X_DIR)); }while(0)
+  #define X_APPLY_DIR(v,Q) do{ X_DIR_WRITE(v); X2_DIR_WRITE(INVERT_DIR(X2_VS_X, v)); }while(0)
   #if ENABLED(X_DUAL_ENDSTOPS)
     #define X_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(X,v)
   #else
@@ -403,7 +403,7 @@ xyze_int8_t Stepper::count_direction{0};
 #endif
 
 #if HAS_DUAL_Y_STEPPERS
-  #define Y_APPLY_DIR(v,Q) do{ Y_DIR_WRITE(v); Y2_DIR_WRITE((v) ^ ENABLED(INVERT_Y2_VS_Y_DIR)); }while(0)
+  #define Y_APPLY_DIR(v,Q) do{ Y_DIR_WRITE(v); Y2_DIR_WRITE(INVERT_DIR(Y2_VS_Y, v)); }while(0)
   #if ENABLED(Y_DUAL_ENDSTOPS)
     #define Y_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Y,v)
   #else
@@ -416,8 +416,8 @@ xyze_int8_t Stepper::count_direction{0};
 
 #if NUM_Z_STEPPERS == 4
   #define Z_APPLY_DIR(v,Q) do{ \
-    Z_DIR_WRITE(v); Z2_DIR_WRITE((v) ^ ENABLED(INVERT_Z2_VS_Z_DIR)); \
-    Z3_DIR_WRITE((v) ^ ENABLED(INVERT_Z3_VS_Z_DIR)); Z4_DIR_WRITE((v) ^ ENABLED(INVERT_Z4_VS_Z_DIR)); \
+    Z_DIR_WRITE(v); Z2_DIR_WRITE(INVERT_DIR(Z2_VS_Z, v)); \
+    Z3_DIR_WRITE(INVERT_DIR(Z3_VS_Z, v)); Z4_DIR_WRITE(INVERT_DIR(Z4_VS_Z, v)); \
   }while(0)
   #if ENABLED(Z_MULTI_ENDSTOPS)
     #define Z_APPLY_STEP(v,Q) QUAD_ENDSTOP_APPLY_STEP(Z,v)
@@ -428,7 +428,7 @@ xyze_int8_t Stepper::count_direction{0};
   #endif
 #elif NUM_Z_STEPPERS == 3
   #define Z_APPLY_DIR(v,Q) do{ \
-    Z_DIR_WRITE(v); Z2_DIR_WRITE((v) ^ ENABLED(INVERT_Z2_VS_Z_DIR)); Z3_DIR_WRITE((v) ^ ENABLED(INVERT_Z3_VS_Z_DIR)); \
+    Z_DIR_WRITE(v); Z2_DIR_WRITE(INVERT_DIR(Z2_VS_Z, v)); Z3_DIR_WRITE(INVERT_DIR(Z3_VS_Z, v)); \
   }while(0)
   #if ENABLED(Z_MULTI_ENDSTOPS)
     #define Z_APPLY_STEP(v,Q) TRIPLE_ENDSTOP_APPLY_STEP(Z,v)
@@ -438,7 +438,7 @@ xyze_int8_t Stepper::count_direction{0};
     #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); Z3_STEP_WRITE(v); }while(0)
   #endif
 #elif NUM_Z_STEPPERS == 2
-  #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE((v) ^ ENABLED(INVERT_Z2_VS_Z_DIR)); }while(0)
+  #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(INVERT_DIR(Z2_VS_Z, v)); }while(0)
   #if ENABLED(Z_MULTI_ENDSTOPS)
     #define Z_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Z,v)
   #elif ENABLED(Z_STEPPER_AUTO_ALIGN)
@@ -3470,14 +3470,14 @@ void Stepper::report_positions() {
     #endif
 
     if (applyDir) {
-      X_DIR_WRITE(TEST(command, FT_BIT_DIR_X));
-      TERN_(HAS_Y_AXIS, Y_DIR_WRITE(TEST(command, FT_BIT_DIR_Y)));
-      TERN_(HAS_Z_AXIS, Z_DIR_WRITE(z_dir));
-      TERN_(HAS_EXTRUDERS, E0_DIR_WRITE(TEST(command, FT_BIT_DIR_E)));
+      TERN_(HAS_X_AXIS, X_DIR_WRITE(INVERT_DIR(X, TEST(command, FT_BIT_DIR_X))));
+      TERN_(HAS_Y_AXIS, Y_DIR_WRITE(INVERT_DIR(Y, TEST(command, FT_BIT_DIR_Y))));
+      TERN_(HAS_Z_AXIS, Z_DIR_WRITE(INVERT_DIR(Z, z_dir)));
+      TERN_(HAS_EXTRUDERS, E0_DIR_WRITE(INVERT_DIR(E0, TEST(command, FT_BIT_DIR_E))));
       DIR_WAIT_AFTER();
     }
 
-    X_STEP_WRITE(TEST(command, FT_BIT_STEP_X));
+    TERN_(HAS_X_AXIS, X_STEP_WRITE(TEST(command, FT_BIT_STEP_X)));
     TERN_(HAS_Y_AXIS, Y_STEP_WRITE(TEST(command, FT_BIT_STEP_Y)));
     TERN_(HAS_Z_AXIS, Z_STEP_WRITE(z_step));
     TERN_(HAS_EXTRUDERS, E0_STEP_WRITE(TEST(command, FT_BIT_STEP_E)));
@@ -3580,7 +3580,6 @@ void Stepper::report_positions() {
 
   #define _ENABLE_AXIS(A) enable_axis(_AXIS(A))
   #define _READ_DIR(AXIS) AXIS ##_DIR_READ()
-  #define _INVERT_DIR(AXIS) ENABLED(INVERT_## AXIS ##_DIR)
   #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)
 
   #if MINIMUM_STEPPER_PULSE
@@ -3627,19 +3626,19 @@ void Stepper::report_positions() {
 
   #if DISABLED(DELTA)
 
-    #define BABYSTEP_AXIS(AXIS, INV, DIR) do{      \
-      const uint8_t old_dir = _READ_DIR(AXIS);     \
-      _ENABLE_AXIS(AXIS);                          \
-      DIR_WAIT_BEFORE();                           \
-      _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^DIR^INV); \
-      DIR_WAIT_AFTER();                            \
-      _SAVE_START();                               \
-      _APPLY_STEP(AXIS, _STEP_STATE(AXIS), true);  \
-      _PULSE_WAIT();                               \
-      _APPLY_STEP(AXIS, !_STEP_STATE(AXIS), true); \
-      EXTRA_DIR_WAIT_BEFORE();                     \
-      _APPLY_DIR(AXIS, old_dir);                   \
-      EXTRA_DIR_WAIT_AFTER();                      \
+    #define BABYSTEP_AXIS(AXIS, INV, DIR) do{           \
+      const uint8_t old_dir = _READ_DIR(AXIS);          \
+      _ENABLE_AXIS(AXIS);                               \
+      DIR_WAIT_BEFORE();                                \
+      _APPLY_DIR(AXIS, INVERT_DIR(AXIS, (DIR)^(INV)));  \
+      DIR_WAIT_AFTER();                                 \
+      _SAVE_START();                                    \
+      _APPLY_STEP(AXIS, _STEP_STATE(AXIS), true);       \
+      _PULSE_WAIT();                                    \
+      _APPLY_STEP(AXIS, !_STEP_STATE(AXIS), true);      \
+      EXTRA_DIR_WAIT_BEFORE();                          \
+      _APPLY_DIR(AXIS, old_dir);                        \
+      EXTRA_DIR_WAIT_AFTER();                           \
     }while(0)
 
   #endif
@@ -3650,8 +3649,8 @@ void Stepper::report_positions() {
       const xy_byte_t old_dir = { _READ_DIR(A), _READ_DIR(B) }; \
       _ENABLE_AXIS(A); _ENABLE_AXIS(B);                         \
       DIR_WAIT_BEFORE();                                        \
-      _APPLY_DIR(A, _INVERT_DIR(A)^DIR^INV);                    \
-      _APPLY_DIR(B, _INVERT_DIR(B)^DIR^INV^ALT);                \
+      _APPLY_DIR(A, INVERT_DIR(A, (DIR)^(INV));                 \
+      _APPLY_DIR(B, INVERT_DIR(B, (DIR)^(INV)^(ALT));           \
       DIR_WAIT_AFTER();                                         \
       _SAVE_START();                                            \
       _APPLY_STEP(A, _STEP_STATE(A), true);                     \
@@ -3725,19 +3724,23 @@ void Stepper::report_positions() {
             U_DIR_READ(), V_DIR_READ(), W_DIR_READ()
           );
 
-          X_DIR_WRITE(ENABLED(INVERT_X_DIR) ^ z_direction);
+          #ifdef X_DIR_WRITE
+            X_DIR_WRITE(INVERT_DIR(X, z_direction));
+          #endif
           #ifdef Y_DIR_WRITE
-            Y_DIR_WRITE(ENABLED(INVERT_Y_DIR) ^ z_direction);
+            Y_DIR_WRITE(INVERT_DIR(Y, z_direction));
           #endif
           #ifdef Z_DIR_WRITE
-            Z_DIR_WRITE(ENABLED(INVERT_Z_DIR) ^ z_direction);
+            Z_DIR_WRITE(INVERT_DIR(Z, z_direction));
           #endif
 
           DIR_WAIT_AFTER();
 
           _SAVE_START();
 
-          X_STEP_WRITE(STEP_STATE_X);
+          #ifdef X_STEP_WRITE
+            X_STEP_WRITE(STEP_STATE_X);
+          #endif
           #ifdef Y_STEP_WRITE
             Y_STEP_WRITE(STEP_STATE_Y);
           #endif
@@ -3747,7 +3750,9 @@ void Stepper::report_positions() {
 
           _PULSE_WAIT();
 
-          X_STEP_WRITE(!STEP_STATE_X);
+          #ifdef X_STEP_WRITE
+            X_STEP_WRITE(!STEP_STATE_X);
+          #endif
           #ifdef Y_STEP_WRITE
             Y_STEP_WRITE(!STEP_STATE_Y);
           #endif
@@ -3758,7 +3763,9 @@ void Stepper::report_positions() {
           // Restore direction bits
           EXTRA_DIR_WAIT_BEFORE();
 
-          X_DIR_WRITE(old_dir.x);
+          #ifdef X_DIR_WRITE
+            X_DIR_WRITE(old_dir.x);
+          #endif
           #ifdef Y_DIR_WRITE
             Y_DIR_WRITE(old_dir.y);
           #endif

commit e687490f41036e85d604618bf4c6246526759b54
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 4 21:52:26 2023 -0500

    🐛 Clean up DELTA babystep Z

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 1062a778d8..f40afc6191 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3732,24 +3732,6 @@ void Stepper::report_positions() {
           #ifdef Z_DIR_WRITE
             Z_DIR_WRITE(ENABLED(INVERT_Z_DIR) ^ z_direction);
           #endif
-          #ifdef I_DIR_WRITE
-            I_DIR_WRITE(ENABLED(INVERT_I_DIR) ^ z_direction);
-          #endif
-          #ifdef J_DIR_WRITE
-            J_DIR_WRITE(ENABLED(INVERT_J_DIR) ^ z_direction);
-          #endif
-          #ifdef K_DIR_WRITE
-            K_DIR_WRITE(ENABLED(INVERT_K_DIR) ^ z_direction);
-          #endif
-          #ifdef U_DIR_WRITE
-            U_DIR_WRITE(ENABLED(INVERT_U_DIR) ^ z_direction);
-          #endif
-          #ifdef V_DIR_WRITE
-            V_DIR_WRITE(ENABLED(INVERT_V_DIR) ^ z_direction);
-          #endif
-          #ifdef W_DIR_WRITE
-            W_DIR_WRITE(ENABLED(INVERT_W_DIR) ^ z_direction);
-          #endif
 
           DIR_WAIT_AFTER();
 
@@ -3762,24 +3744,6 @@ void Stepper::report_positions() {
           #ifdef Z_STEP_WRITE
             Z_STEP_WRITE(STEP_STATE_Z);
           #endif
-          #ifdef I_STEP_WRITE
-            I_STEP_WRITE(STEP_STATE_I);
-          #endif
-          #ifdef J_STEP_WRITE
-            J_STEP_WRITE(STEP_STATE_J);
-          #endif
-          #ifdef K_STEP_WRITE
-            K_STEP_WRITE(STEP_STATE_K);
-          #endif
-          #ifdef U_STEP_WRITE
-            U_STEP_WRITE(STEP_STATE_U);
-          #endif
-          #ifdef V_STEP_WRITE
-            V_STEP_WRITE(STEP_STATE_V);
-          #endif
-          #ifdef W_STEP_WRITE
-            W_STEP_WRITE(STEP_STATE_W);
-          #endif
 
           _PULSE_WAIT();
 
@@ -3790,24 +3754,6 @@ void Stepper::report_positions() {
           #ifdef Z_STEP_WRITE
             Z_STEP_WRITE(!STEP_STATE_Z);
           #endif
-          #ifdef I_STEP_WRITE
-            I_STEP_WRITE(!STEP_STATE_I);
-          #endif
-          #ifdef J_STEP_WRITE
-            J_STEP_WRITE(!STEP_STATE_J);
-          #endif
-          #ifdef K_STEP_WRITE
-            K_STEP_WRITE(!STEP_STATE_K);
-          #endif
-          #ifdef U_STEP_WRITE
-            U_STEP_WRITE(!STEP_STATE_U);
-          #endif
-           #ifdef V_STEP_WRITE
-            V_STEP_WRITE(!STEP_STATE_V);
-          #endif
-          #ifdef W_STEP_WRITE
-            W_STEP_WRITE(!STEP_STATE_W);
-          #endif
 
           // Restore direction bits
           EXTRA_DIR_WAIT_BEFORE();
@@ -3819,24 +3765,6 @@ void Stepper::report_positions() {
           #ifdef Z_DIR_WRITE
             Z_DIR_WRITE(old_dir.z);
           #endif
-          #ifdef I_DIR_WRITE
-            I_DIR_WRITE(old_dir.i);
-          #endif
-          #ifdef J_DIR_WRITE
-            J_DIR_WRITE(old_dir.j);
-          #endif
-          #ifdef K_DIR_WRITE
-            K_DIR_WRITE(old_dir.k);
-          #endif
-          #ifdef U_DIR_WRITE
-            U_DIR_WRITE(old_dir.u);
-          #endif
-          #ifdef V_DIR_WRITE
-            V_DIR_WRITE(old_dir.v);
-          #endif
-          #ifdef W_DIR_WRITE
-            W_DIR_WRITE(old_dir.w);
-          #endif
 
           EXTRA_DIR_WAIT_AFTER();
 

commit c37fa3cc9097a9aa7fad5f168e335caabf23278e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 31 21:18:37 2023 -0500

    ✨ Fixed-Time Motion with Input Shaping by Ulendo (#25394)
    
    Co-authored-by: Ulendo Alex <alex@ulendo.io>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 34a5ca28a3..1062a778d8 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -91,6 +91,10 @@ Stepper stepper; // Singleton
 #include "planner.h"
 #include "motion.h"
 
+#if ENABLED(FT_MOTION)
+  #include "ft_motion.h"
+#endif
+
 #include "../lcd/marlinui.h"
 #include "../gcode/queue.h"
 #include "../sd/cardreader.h"
@@ -1488,63 +1492,133 @@ void Stepper::isr() {
   // Limit the amount of iterations
   uint8_t max_loops = 10;
 
+  #if ENABLED(FT_MOTION)
+    static bool fxdTiCtrl_stepCmdRdy = false;   // Indicates a step command was loaded from the
+                                                // buffers and is ready to be output.
+    static bool fxdTiCtrl_applyDir = false;     // Indicates the DIR output should be set.
+    static ft_command_t fxdTiCtrl_stepCmd = 0U; // Storage for the step command to be output.
+    static uint32_t fxdTiCtrl_nextAuxISR = 0U;  // Storage for the next ISR of the auxilliary tasks.
+  #endif
+
   // We need this variable here to be able to use it in the following loop
   hal_timer_t min_ticks;
   do {
     // Enable ISRs to reduce USART processing latency
     hal.isr_on();
 
-    TERN_(HAS_ZV_SHAPING, shaping_isr());                  // Do Shaper stepping, if needed
+    hal_timer_t interval;
+
+    #if ENABLED(FT_MOTION)
+
+      // NOTE STEPPER_TIMER_RATE is equal to 2000000, not what VSCode shows
+      const bool using_fxtictrl = fxdTiCtrl.cfg_mode;
+      if (using_fxtictrl) {
+        if (!nextMainISR) {
+          if (abort_current_block) {
+            fxdTiCtrl_stepCmdRdy = false; // If a command was ready, cancel it.
+            fxdTiCtrl.sts_stepperBusy = false; // Set busy false to allow a reset.
+            nextMainISR = 0.01f * (STEPPER_TIMER_RATE); // Come back in 10 msec.
+          }
+          else { // !(abort_current_block)
+            if (fxdTiCtrl_stepCmdRdy) {
+              fxdTiCtrl_stepper(fxdTiCtrl_applyDir, fxdTiCtrl_stepCmd);
+              fxdTiCtrl_stepCmdRdy = false;
+            }
+            // Check if there is data in the buffers.
+            if (fxdTiCtrl.stepperCmdBuff_produceIdx != fxdTiCtrl.stepperCmdBuff_consumeIdx) {
+
+              fxdTiCtrl.sts_stepperBusy = true;
+
+              // "Pop" one command from the command buffer.
+              fxdTiCtrl_stepCmd = fxdTiCtrl.stepperCmdBuff[fxdTiCtrl.stepperCmdBuff_consumeIdx];
+              const uint8_t dir_index = fxdTiCtrl.stepperCmdBuff_consumeIdx >> 3,
+                            dir_bit = fxdTiCtrl.stepperCmdBuff_consumeIdx & 0x7;
+              fxdTiCtrl_applyDir = TEST(fxdTiCtrl.stepperCmdBuff_ApplyDir[dir_index], dir_bit);
+              nextMainISR = fxdTiCtrl.stepperCmdBuff_StepRelativeTi[fxdTiCtrl.stepperCmdBuff_consumeIdx];
+              fxdTiCtrl_stepCmdRdy = true;
 
-    if (!nextMainISR) pulse_phase_isr();                // 0 = Do coordinated axes Stepper pulses
+              if (++fxdTiCtrl.stepperCmdBuff_consumeIdx == (FTM_STEPPERCMD_BUFF_SIZE))
+                fxdTiCtrl.stepperCmdBuff_consumeIdx = 0;
 
-    #if ENABLED(LIN_ADVANCE)
-      if (!nextAdvanceISR) {                            // 0 = Do Linear Advance E Stepper pulses
-        advance_isr();
-        nextAdvanceISR = la_interval;
+            }
+            else { // Buffer empty.
+              fxdTiCtrl.sts_stepperBusy = false;
+              nextMainISR = 0.01f * (STEPPER_TIMER_RATE); // Come back in 10 msec.
+            }
+          } // !(abort_current_block)
+        } // if (!nextMainISR)
+
+        // Define 2.5 msec task for auxilliary functions.
+        if (!fxdTiCtrl_nextAuxISR) {
+          endstops.update();
+          TERN_(INTEGRATED_BABYSTEPPING, if (babystep.has_steps()) babystepping_isr());
+          fxdTiCtrl_refreshAxisDidMove();
+          fxdTiCtrl_nextAuxISR = 0.0025f * (STEPPER_TIMER_RATE);
+        }
+
+        interval = _MIN(nextMainISR, fxdTiCtrl_nextAuxISR);
+        nextMainISR -= interval;
+        fxdTiCtrl_nextAuxISR -= interval;
       }
-      else if (nextAdvanceISR == LA_ADV_NEVER)          // Start LA steps if necessary
-        nextAdvanceISR = la_interval;
-    #endif
 
-    #if ENABLED(INTEGRATED_BABYSTEPPING)
-      const bool is_babystep = (nextBabystepISR == 0);  // 0 = Do Babystepping (XY)Z pulses
-      if (is_babystep) nextBabystepISR = babystepping_isr();
+    #else
+
+      constexpr bool using_fxtictrl = false;
+
     #endif
 
-    // ^== Time critical. NOTHING besides pulse generation should be above here!!!
+    if (!using_fxtictrl) {
 
-    if (!nextMainISR) nextMainISR = block_phase_isr();  // Manage acc/deceleration, get next block
+      TERN_(HAS_ZV_SHAPING, shaping_isr());               // Do Shaper stepping, if needed
 
-    #if ENABLED(INTEGRATED_BABYSTEPPING)
-      if (is_babystep)                                  // Avoid ANY stepping too soon after baby-stepping
-        NOLESS(nextMainISR, (BABYSTEP_TICKS) / 8);      // FULL STOP for 125µs after a baby-step
+      if (!nextMainISR) pulse_phase_isr();                // 0 = Do coordinated axes Stepper pulses
 
-      if (nextBabystepISR != BABYSTEP_NEVER)            // Avoid baby-stepping too close to axis Stepping
-        NOLESS(nextBabystepISR, nextMainISR / 2);       // TODO: Only look at axes enabled for baby-stepping
-    #endif
+      #if ENABLED(LIN_ADVANCE)
+        if (!nextAdvanceISR) {                            // 0 = Do Linear Advance E Stepper pulses
+          advance_isr();
+          nextAdvanceISR = la_interval;
+        }
+        else if (nextAdvanceISR == LA_ADV_NEVER)          // Start LA steps if necessary
+          nextAdvanceISR = la_interval;
+      #endif
 
-    // Get the interval to the next ISR call
-    const hal_timer_t interval = _MIN(
-      hal_timer_t(HAL_TIMER_TYPE_MAX),                        // Come back in a very long time
-      nextMainISR                                             // Time until the next Pulse / Block phase
-      OPTARG(INPUT_SHAPING_X, ShapingQueue::peek_x())         // Time until next input shaping echo for X
-      OPTARG(INPUT_SHAPING_Y, ShapingQueue::peek_y())         // Time until next input shaping echo for Y
-      OPTARG(LIN_ADVANCE, nextAdvanceISR)                     // Come back early for Linear Advance?
-      OPTARG(INTEGRATED_BABYSTEPPING, nextBabystepISR)        // Come back early for Babystepping?
-    );
+      #if ENABLED(INTEGRATED_BABYSTEPPING)
+        const bool is_babystep = (nextBabystepISR == 0);  // 0 = Do Babystepping (XY)Z pulses
+        if (is_babystep) nextBabystepISR = babystepping_isr();
+      #endif
+
+      // ^== Time critical. NOTHING besides pulse generation should be above here!!!
+
+      if (!nextMainISR) nextMainISR = block_phase_isr();  // Manage acc/deceleration, get next block
+
+      #if ENABLED(INTEGRATED_BABYSTEPPING)
+        if (is_babystep)                                  // Avoid ANY stepping too soon after baby-stepping
+          NOLESS(nextMainISR, (BABYSTEP_TICKS) / 8);      // FULL STOP for 125µs after a baby-step
+
+        if (nextBabystepISR != BABYSTEP_NEVER)            // Avoid baby-stepping too close to axis Stepping
+          NOLESS(nextBabystepISR, nextMainISR / 2);       // TODO: Only look at axes enabled for baby-stepping
+      #endif
+
+      // Get the interval to the next ISR call
+      interval = _MIN(nextMainISR, uint32_t(HAL_TIMER_TYPE_MAX));         // Time until the next Pulse / Block phase
+      TERN_(INPUT_SHAPING_X, NOMORE(interval, ShapingQueue::peek_x()));   // Time until next input shaping echo for X
+      TERN_(INPUT_SHAPING_Y, NOMORE(interval, ShapingQueue::peek_y()));   // Time until next input shaping echo for Y
+      TERN_(LIN_ADVANCE, NOMORE(interval, nextAdvanceISR));               // Come back early for Linear Advance?
+      TERN_(INTEGRATED_BABYSTEPPING, NOMORE(interval, nextBabystepISR));  // Come back early for Babystepping?
+
+      //
+      // Compute remaining time for each ISR phase
+      //     NEVER : The phase is idle
+      //      Zero : The phase will occur on the next ISR call
+      //  Non-zero : The phase will occur on a future ISR call
+      //
 
-    //
-    // Compute remaining time for each ISR phase
-    //     NEVER : The phase is idle
-    //      Zero : The phase will occur on the next ISR call
-    //  Non-zero : The phase will occur on a future ISR call
-    //
+      nextMainISR -= interval;
+      TERN_(HAS_ZV_SHAPING, ShapingQueue::decrement_delays(interval));
+      TERN_(LIN_ADVANCE, if (nextAdvanceISR != LA_ADV_NEVER) nextAdvanceISR -= interval);
+      TERN_(INTEGRATED_BABYSTEPPING, if (nextBabystepISR != BABYSTEP_NEVER) nextBabystepISR -= interval);
 
-    nextMainISR -= interval;
-    TERN_(HAS_ZV_SHAPING, ShapingQueue::decrement_delays(interval));
-    TERN_(LIN_ADVANCE, if (nextAdvanceISR != LA_ADV_NEVER) nextAdvanceISR -= interval);
-    TERN_(INTEGRATED_BABYSTEPPING, if (nextBabystepISR != BABYSTEP_NEVER) nextBabystepISR -= interval);
+    } // standard motion control
 
     /**
      * This needs to avoid a race-condition caused by interleaving
@@ -1978,7 +2052,7 @@ void Stepper::pulse_phase_isr() {
 
     #if ENABLED(MIXING_EXTRUDER)
       if (step_needed.e) {
-        count_position[E_AXIS] += count_direction[E_AXIS];
+        count_position.e += count_direction.e;
         E_STEP_WRITE(mixer.get_next_stepper(), STEP_STATE_E);
       }
     #elif HAS_E0_STEP
@@ -3381,6 +3455,127 @@ void Stepper::report_positions() {
   report_a_position(pos);
 }
 
+#if ENABLED(FT_MOTION)
+
+  // Set stepper I/O for fixed time controller.
+  void Stepper::fxdTiCtrl_stepper(const bool applyDir, const ft_command_t command) {
+
+    USING_TIMED_PULSE();
+
+    #if HAS_Z_AXIS
+      // Z is handled differently to update the stepper
+      // counts (needed by Marlin for bed level probing).
+      const bool z_dir = !TEST(command, FT_BIT_DIR_Z),
+                z_step = TEST(command, FT_BIT_STEP_Z);
+    #endif
+
+    if (applyDir) {
+      X_DIR_WRITE(TEST(command, FT_BIT_DIR_X));
+      TERN_(HAS_Y_AXIS, Y_DIR_WRITE(TEST(command, FT_BIT_DIR_Y)));
+      TERN_(HAS_Z_AXIS, Z_DIR_WRITE(z_dir));
+      TERN_(HAS_EXTRUDERS, E0_DIR_WRITE(TEST(command, FT_BIT_DIR_E)));
+      DIR_WAIT_AFTER();
+    }
+
+    X_STEP_WRITE(TEST(command, FT_BIT_STEP_X));
+    TERN_(HAS_Y_AXIS, Y_STEP_WRITE(TEST(command, FT_BIT_STEP_Y)));
+    TERN_(HAS_Z_AXIS, Z_STEP_WRITE(z_step));
+    TERN_(HAS_EXTRUDERS, E0_STEP_WRITE(TEST(command, FT_BIT_STEP_E)));
+
+    START_TIMED_PULSE();
+
+    #if HAS_Z_AXIS
+      // Update step counts
+      if (z_step) count_position.z += z_dir ? -1 : 1;
+    #endif
+
+    AWAIT_HIGH_PULSE();
+
+    X_STEP_WRITE(0);
+    TERN_(HAS_Y_AXIS, Y_STEP_WRITE(0));
+    TERN_(HAS_Z_AXIS, Z_STEP_WRITE(0));
+    TERN_(HAS_EXTRUDERS, E0_STEP_WRITE(0));
+
+  } // Stepper::fxdTiCtrl_stepper
+
+  void Stepper::fxdTiCtrl_BlockQueueUpdate() {
+
+    if (current_block) {
+      // If the current block is not done processing, return right away
+      if (!fxdTiCtrl.getBlockProcDn()) return;
+
+      axis_did_move = 0;
+      current_block = nullptr;
+      discard_current_block();
+    }
+
+    if (!current_block) { // No current block
+
+      // Check the buffer for a new block
+      current_block = planner.get_current_block();
+
+      if (current_block) {
+        // Sync block? Sync the stepper counts and return
+        while (current_block->is_sync()) {
+          if (!(current_block->is_fan_sync() || current_block->is_pwr_sync())) _set_position(current_block->position);
+          discard_current_block();
+
+          // Try to get a new block
+          if (!(current_block = planner.get_current_block()))
+            return; // No more queued movements!image.png
+        }
+
+        // this is needed by motor_direction() and subsequently bed leveling (somehow)
+        // update it here, even though it will may be out of sync with step commands
+        last_direction_bits = current_block->direction_bits;
+
+        fxdTiCtrl.startBlockProc(current_block);
+
+      }
+      else {
+        fxdTiCtrl.runoutBlock();
+        return; // No queued blocks
+      }
+
+    } // if (!current_block)
+
+  } // Stepper::fxdTiCtrl_BlockQueueUpdate()
+
+  // Debounces the axis move indication to account for potential
+  // delay between the block information and the stepper commands
+  void Stepper::fxdTiCtrl_refreshAxisDidMove() {
+
+    // Set the debounce time in seconds.
+    #define AXIS_DID_MOVE_DEB 5 // TODO: The debounce time should be calculated if possible,
+                                // or the set conditions should be changed from the block to
+                                // the motion trajectory or motor commands.
+
+    uint8_t axis_bits = 0U;
+
+    static uint32_t a_debounce = 0U;
+    if (!!current_block->steps.a) a_debounce = (AXIS_DID_MOVE_DEB) * 400; // divide by 0.0025f
+    if (a_debounce) { SBI(axis_bits, A_AXIS); a_debounce--; }
+    #if HAS_Y_AXIS
+      static uint32_t b_debounce = 0U;
+      if (!!current_block->steps.b) b_debounce = (AXIS_DID_MOVE_DEB) * 400;
+      if (b_debounce) { SBI(axis_bits, B_AXIS); b_debounce--; }
+    #endif
+    #if HAS_Z_AXIS
+      static uint32_t c_debounce = 0U;
+      if (!!current_block->steps.c) c_debounce = (AXIS_DID_MOVE_DEB) * 400;
+      if (c_debounce) { SBI(axis_bits, C_AXIS); c_debounce--; }
+    #endif
+    #if HAS_EXTRUDERS
+      static uint32_t e_debounce = 0U;
+      if (!!current_block->steps.e) e_debounce = (AXIS_DID_MOVE_DEB) * 400;
+      if (e_debounce) { SBI(axis_bits, E_AXIS); e_debounce--; }
+    #endif
+
+    axis_did_move = axis_bits;
+  }
+
+#endif // FT_MOTION
+
 #if ENABLED(BABYSTEPPING)
 
   #define _ENABLE_AXIS(A) enable_axis(_AXIS(A))

commit 8cdf43f8fdf8900ad903d094d1aeb5dc651b324b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 31 20:26:49 2023 -0500

    🎨  HAS_SHAPING => HAS_ZV_SHAPING

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index f7436e51d5..34a5ca28a3 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -240,7 +240,7 @@ uint32_t Stepper::advance_divisor = 0,
   bool        Stepper::la_active = false;
 #endif
 
-#if HAS_SHAPING
+#if HAS_ZV_SHAPING
   shaping_time_t      ShapingQueue::now = 0;
   shaping_time_t      ShapingQueue::times[shaping_echoes];
   shaping_echo_axis_t ShapingQueue::echo_axes[shaping_echoes];
@@ -1494,7 +1494,7 @@ void Stepper::isr() {
     // Enable ISRs to reduce USART processing latency
     hal.isr_on();
 
-    TERN_(HAS_SHAPING, shaping_isr());                  // Do Shaper stepping, if needed
+    TERN_(HAS_ZV_SHAPING, shaping_isr());                  // Do Shaper stepping, if needed
 
     if (!nextMainISR) pulse_phase_isr();                // 0 = Do coordinated axes Stepper pulses
 
@@ -1542,7 +1542,7 @@ void Stepper::isr() {
     //
 
     nextMainISR -= interval;
-    TERN_(HAS_SHAPING, ShapingQueue::decrement_delays(interval));
+    TERN_(HAS_ZV_SHAPING, ShapingQueue::decrement_delays(interval));
     TERN_(LIN_ADVANCE, if (nextAdvanceISR != LA_ADV_NEVER) nextAdvanceISR -= interval);
     TERN_(INTEGRATED_BABYSTEPPING, if (nextBabystepISR != BABYSTEP_NEVER) nextBabystepISR -= interval);
 
@@ -1663,7 +1663,7 @@ void Stepper::pulse_phase_isr() {
     abort_current_block = false;
     if (current_block) {
       discard_current_block();
-      #if HAS_SHAPING
+      #if HAS_ZV_SHAPING
         ShapingQueue::purge();
         #if ENABLED(INPUT_SHAPING_X)
           shaping_x.delta_error = 0;
@@ -1921,7 +1921,7 @@ void Stepper::pulse_phase_isr() {
         #endif
       #endif
 
-      #if HAS_SHAPING
+      #if HAS_ZV_SHAPING
         // record an echo if a step is needed in the primary bresenham
         const bool x_step = TERN0(INPUT_SHAPING_X, step_needed.x && shaping_x.enabled),
                    y_step = TERN0(INPUT_SHAPING_Y, step_needed.y && shaping_y.enabled);
@@ -2035,7 +2035,7 @@ void Stepper::pulse_phase_isr() {
   } while (--events_to_do);
 }
 
-#if HAS_SHAPING
+#if HAS_ZV_SHAPING
 
   void Stepper::shaping_isr() {
     AxisFlags step_needed{0};
@@ -2087,7 +2087,7 @@ void Stepper::pulse_phase_isr() {
     }
   }
 
-#endif // HAS_SHAPING
+#endif // HAS_ZV_SHAPING
 
 // Calculate timer interval, with all limits applied.
 hal_timer_t Stepper::calc_timer_interval(uint32_t step_rate) {
@@ -3108,7 +3108,7 @@ void Stepper::init() {
   #endif
 }
 
-#if HAS_SHAPING
+#if HAS_ZV_SHAPING
 
   /**
    * Calculate a fixed point factor to apply to the signal and its echo
@@ -3179,7 +3179,7 @@ void Stepper::init() {
     return -1;
   }
 
-#endif // HAS_SHAPING
+#endif // HAS_ZV_SHAPING
 
 /**
  * Set the stepper positions directly in steps

commit 241c06218822d63e47710acfa6885351fe495bc5
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sun Mar 26 10:46:55 2023 +0100

    🐛 Prevent divide-by-zero in calc_timer_interval (#25557)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 5c0034a5f9..f7436e51d5 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2094,7 +2094,8 @@ hal_timer_t Stepper::calc_timer_interval(uint32_t step_rate) {
 
   #ifdef CPU_32_BIT
 
-    return uint32_t(STEPPER_TIMER_RATE) / step_rate; // A fast processor can just do integer division
+    // A fast processor can just do integer division
+    return step_rate ? uint32_t(STEPPER_TIMER_RATE) / step_rate : HAL_TIMER_TYPE_MAX;
 
   #else
 

commit ca77850cbb8ed57d4cdcf29a12a278d6bfa5c0d5
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sun Mar 19 21:25:14 2023 +0000

    🐛 Avoid step rate overflow (#25541)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4872e98aa9..5c0034a5f9 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2098,9 +2098,15 @@ hal_timer_t Stepper::calc_timer_interval(uint32_t step_rate) {
 
   #else
 
-    // AVR is able to keep up at 30khz Stepping ISR rate.
     constexpr uint32_t min_step_rate = (F_CPU) / 500000U; // i.e., 32 or 40
     if (step_rate >= 0x0800) {  // higher step rate
+      // AVR is able to keep up at around 65kHz Stepping ISR rate at most.
+      // So values for step_rate > 65535 might as well be truncated.
+      // Handle it as quickly as possible. i.e., assume highest byte is zero
+      // because non-zero would represent a step rate far beyond AVR capabilities.
+      if (uint8_t(step_rate >> 16))
+        return uint32_t(STEPPER_TIMER_RATE) / 0x10000;
+
       const uintptr_t table_address = uintptr_t(&speed_lookuptable_fast[uint8_t(step_rate >> 8)]);
       const uint16_t base = uint16_t(pgm_read_word(table_address));
       const uint8_t gain = uint8_t(pgm_read_byte(table_address + 2));
@@ -2112,10 +2118,8 @@ hal_timer_t Stepper::calc_timer_interval(uint32_t step_rate) {
       return uint16_t(pgm_read_word(table_address))
              - ((uint16_t(pgm_read_word(table_address + 2)) * uint8_t(step_rate & 0x0007)) >> 3);
     }
-    else {
-      step_rate = 0;
-      return uint16_t(pgm_read_word(uintptr_t(speed_lookuptable_slow)));
-    }
+
+    return uint16_t(pgm_read_word(uintptr_t(speed_lookuptable_slow)));
 
   #endif // !CPU_32_BIT
 }
@@ -2250,7 +2254,7 @@ hal_timer_t Stepper::block_phase_isr() {
         #if ENABLED(LIN_ADVANCE)
           if (la_active) {
             const uint32_t la_step_rate = la_advance_steps < current_block->max_adv_steps ? current_block->la_advance_rate : 0;
-            la_interval = calc_timer_interval(acc_step_rate + la_step_rate) << current_block->la_scaling;
+            la_interval = calc_timer_interval((acc_step_rate + la_step_rate) >> current_block->la_scaling);
           }
         #endif
 
@@ -2322,7 +2326,7 @@ hal_timer_t Stepper::block_phase_isr() {
             const uint32_t la_step_rate = la_advance_steps > current_block->final_adv_steps ? current_block->la_advance_rate : 0;
             if (la_step_rate != step_rate) {
               bool reverse_e = la_step_rate > step_rate;
-              la_interval = calc_timer_interval(reverse_e ? la_step_rate - step_rate : step_rate - la_step_rate) << current_block->la_scaling;
+              la_interval = calc_timer_interval((reverse_e ? la_step_rate - step_rate : step_rate - la_step_rate) >> current_block->la_scaling);
 
               if (reverse_e != motor_direction(E_AXIS)) {
                 TBI(last_direction_bits, E_AXIS);
@@ -2380,7 +2384,7 @@ hal_timer_t Stepper::block_phase_isr() {
 
           #if ENABLED(LIN_ADVANCE)
             if (la_active)
-              la_interval = calc_timer_interval(current_block->nominal_rate) << current_block->la_scaling;
+              la_interval = calc_timer_interval(current_block->nominal_rate >> current_block->la_scaling);
           #endif
         }
 
@@ -2702,7 +2706,7 @@ hal_timer_t Stepper::block_phase_isr() {
       #if ENABLED(LIN_ADVANCE)
         if (la_active) {
           const uint32_t la_step_rate = la_advance_steps < current_block->max_adv_steps ? current_block->la_advance_rate : 0;
-          la_interval = calc_timer_interval(current_block->initial_rate + la_step_rate) << current_block->la_scaling;
+          la_interval = calc_timer_interval((current_block->initial_rate + la_step_rate) >> current_block->la_scaling);
         }
       #endif
     }

commit 3c882703619bde0d7cf292bb7dd7918f12edd23c
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sat Mar 18 10:34:53 2023 +0000

    ⚡️ Smart Adaptive Multi-Stepping (#25474)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index ae12f0b7f4..4872e98aa9 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -194,6 +194,10 @@ uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
   uint8_t Stepper::steps_per_isr = 1; // Count of steps to perform per Stepper ISR call
 #endif
 
+#if DISABLED(OLD_ADAPTIVE_MULTISTEPPING)
+  hal_timer_t Stepper::time_spent_in_isr = 0, Stepper::time_spent_out_isr = 0;
+#endif
+
 #if ENABLED(FREEZE_FEATURE)
   bool Stepper::frozen; // = false
 #endif
@@ -614,27 +618,26 @@ void Stepper::set_directions() {
   TERN_(HAS_V_DIR, SET_STEP_DIR(V));
   TERN_(HAS_W_DIR, SET_STEP_DIR(W));
 
-  #if ENABLED(MIXING_EXTRUDER)
+  #if HAS_EXTRUDERS
      // Because this is valid for the whole block we don't know
      // what E steppers will step. Likely all. Set all.
     if (motor_direction(E_AXIS)) {
-      MIXER_STEPPER_LOOP(j) REV_E_DIR(j);
-      count_direction.e = -1;
-    }
-    else {
-      MIXER_STEPPER_LOOP(j) NORM_E_DIR(j);
-      count_direction.e = 1;
-    }
-  #elif HAS_EXTRUDERS
-    if (motor_direction(E_AXIS)) {
-      REV_E_DIR(stepper_extruder);
+      #if ENABLED(MIXING_EXTRUDER)
+        MIXER_STEPPER_LOOP(j) REV_E_DIR(j);
+      #else
+        REV_E_DIR(stepper_extruder);
+      #endif
       count_direction.e = -1;
     }
     else {
-      NORM_E_DIR(stepper_extruder);
+      #if ENABLED(MIXING_EXTRUDER)
+        MIXER_STEPPER_LOOP(j) NORM_E_DIR(j);
+      #else
+        NORM_E_DIR(stepper_extruder);
+      #endif
       count_direction.e = 1;
     }
-  #endif
+  #endif // HAS_EXTRUDERS
 
   DIR_WAIT_AFTER();
 }
@@ -1587,16 +1590,44 @@ void Stepper::isr() {
      */
     min_ticks = HAL_timer_get_count(MF_TIMER_STEP) + hal_timer_t(TERN(__AVR__, 8, 1) * (STEPPER_TIMER_TICKS_PER_US));
 
-    /**
-     * NB: If for some reason the stepper monopolizes the MPU, eventually the
-     * timer will wrap around (and so will 'next_isr_ticks'). So, limit the
-     * loop to 10 iterations. Beyond that, there's no way to ensure correct pulse
-     * timing, since the MCU isn't fast enough.
-     */
-    if (!--max_loops) next_isr_ticks = min_ticks;
+    #if ENABLED(OLD_ADAPTIVE_MULTISTEPPING)
+      /**
+       * NB: If for some reason the stepper monopolizes the MPU, eventually the
+       * timer will wrap around (and so will 'next_isr_ticks'). So, limit the
+       * loop to 10 iterations. Beyond that, there's no way to ensure correct pulse
+       * timing, since the MCU isn't fast enough.
+       */
+      if (!--max_loops) next_isr_ticks = min_ticks;
+    #endif
 
     // Advance pulses if not enough time to wait for the next ISR
-  } while (next_isr_ticks < min_ticks);
+  } while (TERN(OLD_ADAPTIVE_MULTISTEPPING, true, --max_loops) && next_isr_ticks < min_ticks);
+
+  #if DISABLED(OLD_ADAPTIVE_MULTISTEPPING)
+
+    // Track the time spent in the ISR
+    const hal_timer_t time_spent = HAL_timer_get_count(MF_TIMER_STEP);
+    time_spent_in_isr += time_spent;
+
+    if (next_isr_ticks < min_ticks) {
+      next_isr_ticks = min_ticks;
+
+      // When forced out of the ISR, increase multi-stepping
+      #if MULTISTEPPING_LIMIT > 1
+        if (steps_per_isr < MULTISTEPPING_LIMIT) {
+          steps_per_isr <<= 1;
+          // ticks_nominal will need to be recalculated if we are in cruise phase
+          ticks_nominal = 0;
+        }
+      #endif
+    }
+    else {
+      // Track the time spent voluntarily outside the ISR
+      time_spent_out_isr += next_isr_ticks;
+      time_spent_out_isr -= time_spent;
+    }
+
+  #endif // !OLD_ADAPTIVE_MULTISTEPPING
 
   // Now 'next_isr_ticks' contains the period to the next Stepper ISR - And we are
   // sure that the time has not arrived yet - Warrantied by the scheduler
@@ -2091,44 +2122,56 @@ hal_timer_t Stepper::calc_timer_interval(uint32_t step_rate) {
 
 // Get the timer interval and the number of loops to perform per tick
 hal_timer_t Stepper::calc_multistep_timer_interval(uint32_t step_rate) {
-  #if MULTISTEPPING_LIMIT == 1
 
-    // Just make sure the step rate is doable
-    NOMORE(step_rate, uint32_t(MAX_STEP_ISR_FREQUENCY_1X));
+  #if ENABLED(OLD_ADAPTIVE_MULTISTEPPING)
 
-  #else
+    #if MULTISTEPPING_LIMIT == 1
 
-    // The stepping frequency limits for each multistepping rate
-    static const uint32_t limit[] PROGMEM = {
-          (  MAX_STEP_ISR_FREQUENCY_1X     )
-        , (  MAX_STEP_ISR_FREQUENCY_2X >> 1)
-      #if MULTISTEPPING_LIMIT >= 4
-        , (  MAX_STEP_ISR_FREQUENCY_4X >> 2)
-      #endif
-      #if MULTISTEPPING_LIMIT >= 8
-        , (  MAX_STEP_ISR_FREQUENCY_8X >> 3)
-      #endif
-      #if MULTISTEPPING_LIMIT >= 16
-        , ( MAX_STEP_ISR_FREQUENCY_16X >> 4)
-      #endif
-      #if MULTISTEPPING_LIMIT >= 32
-        , ( MAX_STEP_ISR_FREQUENCY_32X >> 5)
-      #endif
-      #if MULTISTEPPING_LIMIT >= 64
-        , ( MAX_STEP_ISR_FREQUENCY_64X >> 6)
-      #endif
-      #if MULTISTEPPING_LIMIT >= 128
-        , (MAX_STEP_ISR_FREQUENCY_128X >> 7)
-      #endif
-    };
+      // Just make sure the step rate is doable
+      NOMORE(step_rate, uint32_t(MAX_STEP_ISR_FREQUENCY_1X));
 
-    // Find a doable step rate using multistepping
-    uint8_t multistep = 1;
-    for (uint8_t i = 0; i < COUNT(limit) && step_rate > uint32_t(pgm_read_dword(&limit[i])); ++i) {
-      step_rate >>= 1;
-      multistep <<= 1;
-    }
-    steps_per_isr = multistep;
+    #else
+
+      // The stepping frequency limits for each multistepping rate
+      static const uint32_t limit[] PROGMEM = {
+            (  MAX_STEP_ISR_FREQUENCY_1X     )
+          , (((F_CPU) / ISR_EXECUTION_CYCLES(1)) >> 1)
+        #if MULTISTEPPING_LIMIT >= 4
+          , (((F_CPU) / ISR_EXECUTION_CYCLES(2)) >> 2)
+        #endif
+        #if MULTISTEPPING_LIMIT >= 8
+          , (((F_CPU) / ISR_EXECUTION_CYCLES(3)) >> 3)
+        #endif
+        #if MULTISTEPPING_LIMIT >= 16
+          , (((F_CPU) / ISR_EXECUTION_CYCLES(4)) >> 4)
+        #endif
+        #if MULTISTEPPING_LIMIT >= 32
+          , (((F_CPU) / ISR_EXECUTION_CYCLES(5)) >> 5)
+        #endif
+        #if MULTISTEPPING_LIMIT >= 64
+          , (((F_CPU) / ISR_EXECUTION_CYCLES(6)) >> 6)
+        #endif
+        #if MULTISTEPPING_LIMIT >= 128
+          , (((F_CPU) / ISR_EXECUTION_CYCLES(7)) >> 7)
+        #endif
+      };
+
+      // Find a doable step rate using multistepping
+      uint8_t multistep = 1;
+      for (uint8_t i = 0; i < COUNT(limit) && step_rate > uint32_t(pgm_read_dword(&limit[i])); ++i) {
+        step_rate >>= 1;
+        multistep <<= 1;
+      }
+      steps_per_isr = multistep;
+
+    #endif
+
+  #elif MULTISTEPPING_LIMIT > 1
+
+    uint8_t loops = steps_per_isr;
+    if (MULTISTEPPING_LIMIT >= 16 && loops >= 16) { step_rate >>= 4; loops >>= 4; }
+    if (MULTISTEPPING_LIMIT >=  4 && loops >=  4) { step_rate >>= 2; loops >>= 2; }
+    if (MULTISTEPPING_LIMIT >=  2 && loops >=  2) { step_rate >>= 1; }
 
   #endif
 
@@ -2141,6 +2184,19 @@ hal_timer_t Stepper::calc_multistep_timer_interval(uint32_t step_rate) {
  * have been done, so it is less time critical.
  */
 hal_timer_t Stepper::block_phase_isr() {
+  #if DISABLED(OLD_ADAPTIVE_MULTISTEPPING)
+    // If the ISR uses < 50% of MPU time, halve multi-stepping
+    const hal_timer_t time_spent = HAL_timer_get_count(MF_TIMER_STEP);
+    #if MULTISTEPPING_LIMIT > 1
+      if (steps_per_isr > 1 && time_spent_out_isr >= time_spent_in_isr + time_spent) {
+        steps_per_isr >>= 1;
+        // ticks_nominal will need to be recalculated if we are in cruise phase
+        ticks_nominal = 0;
+      }
+    #endif
+    time_spent_in_isr = -time_spent;    // unsigned but guaranteed to be +ve when needed
+    time_spent_out_isr = 0;
+  #endif
 
   // If no queued movements, just wait 1ms for the next block
   hal_timer_t interval = (STEPPER_TIMER_RATE) / 1000UL;

commit 143a8701d5b11925440d643b47e5c5812a69352f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 12 16:29:21 2023 -0500

    ⚡️ Optimize speed lookup for AVR
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b4c66d1fba..ae12f0b7f4 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2069,22 +2069,21 @@ hal_timer_t Stepper::calc_timer_interval(uint32_t step_rate) {
 
     // AVR is able to keep up at 30khz Stepping ISR rate.
     constexpr uint32_t min_step_rate = (F_CPU) / 500000U; // i.e., 32 or 40
-    if (step_rate <= min_step_rate) { // lower step rates
-      step_rate = 0;
-      return uint16_t(pgm_read_word(uintptr_t(speed_lookuptable_slow)));
+    if (step_rate >= 0x0800) {  // higher step rate
+      const uintptr_t table_address = uintptr_t(&speed_lookuptable_fast[uint8_t(step_rate >> 8)]);
+      const uint16_t base = uint16_t(pgm_read_word(table_address));
+      const uint8_t gain = uint8_t(pgm_read_byte(table_address + 2));
+      return base - MultiU8X8toH8(uint8_t(step_rate & 0x00FF), gain);
     }
-    else {
+    else if (step_rate > min_step_rate) { // lower step rates
       step_rate -= min_step_rate; // Correct for minimal speed
-      if (step_rate >= 0x0800) {  // higher step rate
-        const uintptr_t table_address = uintptr_t(&speed_lookuptable_fast[uint8_t(step_rate >> 8)]);
-        const uint16_t gain = uint16_t(pgm_read_word(table_address + 2));
-        return uint16_t(pgm_read_word(table_address)) - MultiU8X16toH16(uint8_t(step_rate & 0x00FF), gain);
-      }
-      else { // lower step rates
-        const uintptr_t table_address = uintptr_t(&speed_lookuptable_slow[uint8_t(step_rate >> 3)]);
-        return uint16_t(pgm_read_word(table_address))
-               - ((uint16_t(pgm_read_word(table_address + 2)) * uint8_t(step_rate & 0x0007)) >> 3);
-      }
+      const uintptr_t table_address = uintptr_t(&speed_lookuptable_slow[uint8_t(step_rate >> 3)]);
+      return uint16_t(pgm_read_word(table_address))
+             - ((uint16_t(pgm_read_word(table_address + 2)) * uint8_t(step_rate & 0x0007)) >> 3);
+    }
+    else {
+      step_rate = 0;
+      return uint16_t(pgm_read_word(uintptr_t(speed_lookuptable_slow)));
     }
 
   #endif // !CPU_32_BIT

commit 3365172e7c7b577d12912a7d942d3a2fa5c75f74
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 11 19:54:48 2023 -0600

    🔧 Expose MULTISTEPPING_LIMIT option
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 738862666f..b4c66d1fba 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -189,7 +189,10 @@ bool Stepper::abort_current_block;
 #endif
 
 uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
-uint8_t Stepper::steps_per_isr = 1;   // Count of steps to perform per Stepper ISR call
+
+#if MULTISTEPPING_LIMIT > 1
+  uint8_t Stepper::steps_per_isr = 1; // Count of steps to perform per Stepper ISR call
+#endif
 
 #if ENABLED(FREEZE_FEATURE)
   bool Stepper::frozen; // = false
@@ -2089,7 +2092,7 @@ hal_timer_t Stepper::calc_timer_interval(uint32_t step_rate) {
 
 // Get the timer interval and the number of loops to perform per tick
 hal_timer_t Stepper::calc_multistep_timer_interval(uint32_t step_rate) {
-  #if ENABLED(DISABLE_MULTI_STEPPING)
+  #if MULTISTEPPING_LIMIT == 1
 
     // Just make sure the step rate is doable
     NOMORE(step_rate, uint32_t(MAX_STEP_ISR_FREQUENCY_1X));
@@ -2098,19 +2101,31 @@ hal_timer_t Stepper::calc_multistep_timer_interval(uint32_t step_rate) {
 
     // The stepping frequency limits for each multistepping rate
     static const uint32_t limit[] PROGMEM = {
-      (  MAX_STEP_ISR_FREQUENCY_1X     ),
-      (  MAX_STEP_ISR_FREQUENCY_2X >> 1),
-      (  MAX_STEP_ISR_FREQUENCY_4X >> 2),
-      (  MAX_STEP_ISR_FREQUENCY_8X >> 3),
-      ( MAX_STEP_ISR_FREQUENCY_16X >> 4),
-      ( MAX_STEP_ISR_FREQUENCY_32X >> 5),
-      ( MAX_STEP_ISR_FREQUENCY_64X >> 6),
-      (MAX_STEP_ISR_FREQUENCY_128X >> 7)
+          (  MAX_STEP_ISR_FREQUENCY_1X     )
+        , (  MAX_STEP_ISR_FREQUENCY_2X >> 1)
+      #if MULTISTEPPING_LIMIT >= 4
+        , (  MAX_STEP_ISR_FREQUENCY_4X >> 2)
+      #endif
+      #if MULTISTEPPING_LIMIT >= 8
+        , (  MAX_STEP_ISR_FREQUENCY_8X >> 3)
+      #endif
+      #if MULTISTEPPING_LIMIT >= 16
+        , ( MAX_STEP_ISR_FREQUENCY_16X >> 4)
+      #endif
+      #if MULTISTEPPING_LIMIT >= 32
+        , ( MAX_STEP_ISR_FREQUENCY_32X >> 5)
+      #endif
+      #if MULTISTEPPING_LIMIT >= 64
+        , ( MAX_STEP_ISR_FREQUENCY_64X >> 6)
+      #endif
+      #if MULTISTEPPING_LIMIT >= 128
+        , (MAX_STEP_ISR_FREQUENCY_128X >> 7)
+      #endif
     };
 
     // Find a doable step rate using multistepping
     uint8_t multistep = 1;
-    for (uint8_t i = 0; i < 7 && step_rate > uint32_t(pgm_read_dword(&limit[i])); ++i) {
+    for (uint8_t i = 0; i < COUNT(limit) && step_rate > uint32_t(pgm_read_dword(&limit[i])); ++i) {
       step_rate >>= 1;
       multistep <<= 1;
     }

commit 549419e08482873422675173cd9d241362b88f00
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 11 19:25:42 2023 -0600

    ⚡️ Set steps_per_isr in calc_multistep_timer_interval
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 0ae2a52f9d..738862666f 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -189,7 +189,7 @@ bool Stepper::abort_current_block;
 #endif
 
 uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
-uint8_t Stepper::steps_per_isr;       // Count of steps to perform per Stepper ISR call
+uint8_t Stepper::steps_per_isr = 1;   // Count of steps to perform per Stepper ISR call
 
 #if ENABLED(FREEZE_FEATURE)
   bool Stepper::frozen; // = false
@@ -2088,8 +2088,7 @@ hal_timer_t Stepper::calc_timer_interval(uint32_t step_rate) {
 }
 
 // Get the timer interval and the number of loops to perform per tick
-hal_timer_t Stepper::calc_timer_interval(uint32_t step_rate, uint8_t &loops) {
-  uint8_t multistep = 1;
+hal_timer_t Stepper::calc_multistep_timer_interval(uint32_t step_rate) {
   #if ENABLED(DISABLE_MULTI_STEPPING)
 
     // Just make sure the step rate is doable
@@ -2109,16 +2108,15 @@ hal_timer_t Stepper::calc_timer_interval(uint32_t step_rate, uint8_t &loops) {
       (MAX_STEP_ISR_FREQUENCY_128X >> 7)
     };
 
-    // Select the proper multistepping
-    uint8_t idx = 0;
-    while (idx < 7 && step_rate > (uint32_t)pgm_read_dword(&limit[idx])) {
+    // Find a doable step rate using multistepping
+    uint8_t multistep = 1;
+    for (uint8_t i = 0; i < 7 && step_rate > uint32_t(pgm_read_dword(&limit[i])); ++i) {
       step_rate >>= 1;
       multistep <<= 1;
-      ++idx;
-    };
+    }
+    steps_per_isr = multistep;
 
   #endif
-  loops = multistep;
 
   return calc_timer_interval(step_rate);
 }
@@ -2176,7 +2174,7 @@ hal_timer_t Stepper::block_phase_isr() {
         // acc_step_rate is in steps/second
 
         // step_rate to timer interval and steps per stepper isr
-        interval = calc_timer_interval(acc_step_rate << oversampling_factor, steps_per_isr);
+        interval = calc_multistep_timer_interval(acc_step_rate << oversampling_factor);
         acceleration_time += interval;
 
         #if ENABLED(LIN_ADVANCE)
@@ -2246,7 +2244,7 @@ hal_timer_t Stepper::block_phase_isr() {
         #endif
 
         // step_rate to timer interval and steps per stepper isr
-        interval = calc_timer_interval(step_rate << oversampling_factor, steps_per_isr);
+        interval = calc_multistep_timer_interval(step_rate << oversampling_factor);
         deceleration_time += interval;
 
         #if ENABLED(LIN_ADVANCE)
@@ -2308,7 +2306,7 @@ hal_timer_t Stepper::block_phase_isr() {
         // Calculate the ticks_nominal for this nominal speed, if not done yet
         if (ticks_nominal == 0) {
           // step_rate to timer interval and loops for the nominal speed
-          ticks_nominal = calc_timer_interval(current_block->nominal_rate << oversampling_factor, steps_per_isr);
+          ticks_nominal = calc_multistep_timer_interval(current_block->nominal_rate << oversampling_factor);
 
           #if ENABLED(LIN_ADVANCE)
             if (la_active)
@@ -2628,7 +2626,7 @@ hal_timer_t Stepper::block_phase_isr() {
       #endif
 
       // Calculate the initial timer interval
-      interval = calc_timer_interval(current_block->initial_rate << oversampling_factor, steps_per_isr);
+      interval = calc_multistep_timer_interval(current_block->initial_rate << oversampling_factor);
       acceleration_time += interval;
 
       #if ENABLED(LIN_ADVANCE)

commit e4b83ad5f58772f73d9b2dcc9dcccbbc2a3e893d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 11 19:22:18 2023 -0600

    ⚡️ Major shaper optimization
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 400dab5893..0ae2a52f9d 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1676,7 +1676,7 @@ void Stepper::pulse_phase_isr() {
       int32_t de = delta_error[_AXIS(AXIS)] + advance_dividend[_AXIS(AXIS)]; \
       if (de >= 0) { \
         step_needed.set(_AXIS(AXIS)); \
-        de -= advance_divisor; \
+        de -= advance_divisor_cached; \
       } \
       delta_error[_AXIS(AXIS)] = de; \
     }while(0)
@@ -1702,19 +1702,22 @@ void Stepper::pulse_phase_isr() {
     #define HYSTERESIS(AXIS) _HYSTERESIS(AXIS)
 
     #define PULSE_PREP_SHAPING(AXIS, DELTA_ERROR, DIVIDEND) do{ \
-      if (step_needed.test(_AXIS(AXIS))) { \
-        DELTA_ERROR += (DIVIDEND); \
-        if ((MAXDIR(AXIS) && DELTA_ERROR <= -(64 + HYSTERESIS(AXIS))) || (MINDIR(AXIS) && DELTA_ERROR >= (64 + HYSTERESIS(AXIS)))) { \
+      int16_t de = DELTA_ERROR + (DIVIDEND); \
+      const bool step_fwd = de >=  (64 + HYSTERESIS(AXIS)), \
+                 step_bak = de <= -(64 + HYSTERESIS(AXIS)); \
+      if (step_fwd || step_bak) { \
+        de += step_fwd ? -128 : 128; \
+        if ((MAXDIR(AXIS) && step_bak) || (MINDIR(AXIS) && step_fwd)) { \
           { USING_TIMED_PULSE(); START_TIMED_PULSE(); AWAIT_LOW_PULSE(); } \
           TBI(last_direction_bits, _AXIS(AXIS)); \
           DIR_WAIT_BEFORE(); \
           SET_STEP_DIR(AXIS); \
           DIR_WAIT_AFTER(); \
         } \
-        step_needed.set(_AXIS(AXIS), DELTA_ERROR <= -(64 + HYSTERESIS(AXIS)) || DELTA_ERROR >= (64 + HYSTERESIS(AXIS))); \
-        if (step_needed.test(_AXIS(AXIS))) \
-          DELTA_ERROR += MAXDIR(AXIS) ? -128 : 128; \
       } \
+      else \
+        step_needed.clear(_AXIS(AXIS)); \
+      DELTA_ERROR = de; \
     }while(0)
 
     // Start an active pulse if needed
@@ -1839,6 +1842,9 @@ void Stepper::pulse_phase_isr() {
     #endif // DIRECT_STEPPING
 
     if (!is_page) {
+      // Give the compiler a clue to store advance_divisor in registers for what follows
+      const uint32_t advance_divisor_cached = advance_divisor;
+
       // Determine if pulses are needed
       #if HAS_X_STEP
         PULSE_PREP(X);
@@ -1883,19 +1889,19 @@ void Stepper::pulse_phase_isr() {
 
       #if HAS_SHAPING
         // record an echo if a step is needed in the primary bresenham
-        const bool x_step = TERN0(INPUT_SHAPING_X, shaping_x.enabled && step_needed.x),
-                   y_step = TERN0(INPUT_SHAPING_Y, shaping_y.enabled && step_needed.y);
+        const bool x_step = TERN0(INPUT_SHAPING_X, step_needed.x && shaping_x.enabled),
+                   y_step = TERN0(INPUT_SHAPING_Y, step_needed.y && shaping_y.enabled);
         if (x_step || y_step)
           ShapingQueue::enqueue(x_step, TERN0(INPUT_SHAPING_X, shaping_x.forward), y_step, TERN0(INPUT_SHAPING_Y, shaping_y.forward));
 
         // do the first part of the secondary bresenham
         #if ENABLED(INPUT_SHAPING_X)
-          if (shaping_x.enabled)
-            PULSE_PREP_SHAPING(X, shaping_x.delta_error, shaping_x.factor1 * (shaping_x.forward ? 1 : -1));
+          if (x_step)
+            PULSE_PREP_SHAPING(X, shaping_x.delta_error, shaping_x.forward ? shaping_x.factor1 : -shaping_x.factor1);
         #endif
         #if ENABLED(INPUT_SHAPING_Y)
-          if (shaping_y.enabled)
-            PULSE_PREP_SHAPING(Y, shaping_y.delta_error, shaping_y.factor1 * (shaping_y.forward ? 1 : -1));
+          if (y_step)
+            PULSE_PREP_SHAPING(Y, shaping_y.delta_error, shaping_y.forward ? shaping_y.factor1 : -shaping_y.factor1);
         #endif
       #endif
     }
@@ -2008,7 +2014,7 @@ void Stepper::pulse_phase_isr() {
       #if ENABLED(INPUT_SHAPING_X)
         if (step_needed.x) {
           const bool forward = ShapingQueue::dequeue_x();
-          PULSE_PREP_SHAPING(X, shaping_x.delta_error, shaping_x.factor2 * (forward ? 1 : -1));
+          PULSE_PREP_SHAPING(X, shaping_x.delta_error, (forward ? shaping_x.factor2 : -shaping_x.factor2));
           PULSE_START(X);
         }
       #endif
@@ -2016,7 +2022,7 @@ void Stepper::pulse_phase_isr() {
       #if ENABLED(INPUT_SHAPING_Y)
         if (step_needed.y) {
           const bool forward = ShapingQueue::dequeue_y();
-          PULSE_PREP_SHAPING(Y, shaping_y.delta_error, shaping_y.factor2 * (forward ? 1 : -1));
+          PULSE_PREP_SHAPING(Y, shaping_y.delta_error, (forward ? shaping_y.factor2 : -shaping_y.factor2));
           PULSE_START(Y);
         }
       #endif

commit 4a0cb4fb4ac27ab20b1f97a016b85bac6ad15470
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 11 19:21:31 2023 -0600

    ⚡️ Use AxisFlags for step_needed
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index acb394f281..400dab5893 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1661,21 +1661,24 @@ void Stepper::pulse_phase_isr() {
     bool firstStep = true;
     USING_TIMED_PULSE();
   #endif
-  xyze_bool_t step_needed{0};
 
   // Direct Stepping page?
   const bool is_page = current_block->is_page();
 
   do {
+    AxisFlags step_needed{0};
+
     #define _APPLY_STEP(AXIS, INV, ALWAYS) AXIS ##_APPLY_STEP(INV, ALWAYS)
     #define _STEP_STATE(AXIS) STEP_STATE_## AXIS
 
     // Determine if a pulse is needed using Bresenham
     #define PULSE_PREP(AXIS) do{ \
-      delta_error[_AXIS(AXIS)] += advance_dividend[_AXIS(AXIS)]; \
-      step_needed[_AXIS(AXIS)] = (delta_error[_AXIS(AXIS)] >= 0); \
-      if (step_needed[_AXIS(AXIS)]) \
-        delta_error[_AXIS(AXIS)] -= advance_divisor; \
+      int32_t de = delta_error[_AXIS(AXIS)] + advance_dividend[_AXIS(AXIS)]; \
+      if (de >= 0) { \
+        step_needed.set(_AXIS(AXIS)); \
+        de -= advance_divisor; \
+      } \
+      delta_error[_AXIS(AXIS)] = de; \
     }while(0)
 
     // With input shaping, direction changes can happen with almost only
@@ -1699,7 +1702,7 @@ void Stepper::pulse_phase_isr() {
     #define HYSTERESIS(AXIS) _HYSTERESIS(AXIS)
 
     #define PULSE_PREP_SHAPING(AXIS, DELTA_ERROR, DIVIDEND) do{ \
-      if (step_needed[_AXIS(AXIS)]) { \
+      if (step_needed.test(_AXIS(AXIS))) { \
         DELTA_ERROR += (DIVIDEND); \
         if ((MAXDIR(AXIS) && DELTA_ERROR <= -(64 + HYSTERESIS(AXIS))) || (MINDIR(AXIS) && DELTA_ERROR >= (64 + HYSTERESIS(AXIS)))) { \
           { USING_TIMED_PULSE(); START_TIMED_PULSE(); AWAIT_LOW_PULSE(); } \
@@ -1708,15 +1711,15 @@ void Stepper::pulse_phase_isr() {
           SET_STEP_DIR(AXIS); \
           DIR_WAIT_AFTER(); \
         } \
-        step_needed[_AXIS(AXIS)] = DELTA_ERROR <= -(64 + HYSTERESIS(AXIS)) || DELTA_ERROR >= (64 + HYSTERESIS(AXIS)); \
-        if (step_needed[_AXIS(AXIS)]) \
+        step_needed.set(_AXIS(AXIS), DELTA_ERROR <= -(64 + HYSTERESIS(AXIS)) || DELTA_ERROR >= (64 + HYSTERESIS(AXIS))); \
+        if (step_needed.test(_AXIS(AXIS))) \
           DELTA_ERROR += MAXDIR(AXIS) ? -128 : 128; \
       } \
     }while(0)
 
     // Start an active pulse if needed
     #define PULSE_START(AXIS) do{ \
-      if (step_needed[_AXIS(AXIS)]) { \
+      if (step_needed.test(_AXIS(AXIS))) { \
         count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \
         _APPLY_STEP(AXIS, _STEP_STATE(AXIS), 0); \
       } \
@@ -1724,7 +1727,7 @@ void Stepper::pulse_phase_isr() {
 
     // Stop an active pulse if needed
     #define PULSE_STOP(AXIS) do { \
-      if (step_needed[_AXIS(AXIS)]) { \
+      if (step_needed.test(_AXIS(AXIS))) { \
         _APPLY_STEP(AXIS, !_STEP_STATE(AXIS), 0); \
       } \
     }while(0)
@@ -1743,8 +1746,8 @@ void Stepper::pulse_phase_isr() {
           }while(0)
 
           #define PAGE_PULSE_PREP(AXIS) do{ \
-            step_needed[_AXIS(AXIS)] =      \
-              pgm_read_byte(&segment_table[page_step_state.sd[_AXIS(AXIS)]][page_step_state.segment_steps & 0x7]); \
+            step_needed.set(_AXIS(AXIS), \
+              pgm_read_byte(&segment_table[page_step_state.sd[_AXIS(AXIS)]][page_step_state.segment_steps & 0x7])); \
           }while(0)
 
           switch (page_step_state.segment_steps) {
@@ -1784,8 +1787,8 @@ void Stepper::pulse_phase_isr() {
             page_step_state.bd[_AXIS(AXIS)] += VALUE;
 
           #define PAGE_PULSE_PREP(AXIS) do{ \
-            step_needed[_AXIS(AXIS)] =      \
-              pgm_read_byte(&segment_table[page_step_state.sd[_AXIS(AXIS)]][page_step_state.segment_steps & 0x3]); \
+            step_needed.set(_AXIS(AXIS), \
+              pgm_read_byte(&segment_table[page_step_state.sd[_AXIS(AXIS)]][page_step_state.segment_steps & 0x3])); \
           }while(0)
 
           switch (page_step_state.segment_steps) {
@@ -1812,10 +1815,10 @@ void Stepper::pulse_phase_isr() {
 
         #elif STEPPER_PAGE_FORMAT == SP_4x1_512
 
-          #define PAGE_PULSE_PREP(AXIS, BITS) do{             \
-            step_needed[_AXIS(AXIS)] = (steps >> BITS) & 0x1; \
-            if (step_needed[_AXIS(AXIS)])                     \
-              page_step_state.bd[_AXIS(AXIS)]++;              \
+          #define PAGE_PULSE_PREP(AXIS, NBIT) do{            \
+            step_needed.set(_AXIS(AXIS), TEST(steps, NBIT)); \
+            if (step_needed.test(_AXIS(AXIS)))               \
+              page_step_state.bd[_AXIS(AXIS)]++;             \
           }while(0)
 
           uint8_t steps = page_step_state.page[page_step_state.segment_idx >> 1];
@@ -1880,8 +1883,8 @@ void Stepper::pulse_phase_isr() {
 
       #if HAS_SHAPING
         // record an echo if a step is needed in the primary bresenham
-        const bool x_step = TERN0(INPUT_SHAPING_X, shaping_x.enabled && step_needed[X_AXIS]),
-                   y_step = TERN0(INPUT_SHAPING_Y, shaping_y.enabled && step_needed[Y_AXIS]);
+        const bool x_step = TERN0(INPUT_SHAPING_X, shaping_x.enabled && step_needed.x),
+                   y_step = TERN0(INPUT_SHAPING_Y, shaping_y.enabled && step_needed.y);
         if (x_step || y_step)
           ShapingQueue::enqueue(x_step, TERN0(INPUT_SHAPING_X, shaping_x.forward), y_step, TERN0(INPUT_SHAPING_Y, shaping_y.forward));
 
@@ -1995,15 +1998,15 @@ void Stepper::pulse_phase_isr() {
 #if HAS_SHAPING
 
   void Stepper::shaping_isr() {
-    xy_bool_t step_needed{0};
+    AxisFlags step_needed{0};
 
     // Clear the echoes that are ready to process. If the buffers are too full and risk overflow, also apply echoes early.
-    TERN_(INPUT_SHAPING_X, step_needed[X_AXIS] = !ShapingQueue::peek_x() || ShapingQueue::free_count_x() < steps_per_isr);
-    TERN_(INPUT_SHAPING_Y, step_needed[Y_AXIS] = !ShapingQueue::peek_y() || ShapingQueue::free_count_y() < steps_per_isr);
+    TERN_(INPUT_SHAPING_X, step_needed.x = !ShapingQueue::peek_x() || ShapingQueue::free_count_x() < steps_per_isr);
+    TERN_(INPUT_SHAPING_Y, step_needed.y = !ShapingQueue::peek_y() || ShapingQueue::free_count_y() < steps_per_isr);
 
     if (bool(step_needed)) while (true) {
       #if ENABLED(INPUT_SHAPING_X)
-        if (step_needed[X_AXIS]) {
+        if (step_needed.x) {
           const bool forward = ShapingQueue::dequeue_x();
           PULSE_PREP_SHAPING(X, shaping_x.delta_error, shaping_x.factor2 * (forward ? 1 : -1));
           PULSE_START(X);
@@ -2011,7 +2014,7 @@ void Stepper::pulse_phase_isr() {
       #endif
 
       #if ENABLED(INPUT_SHAPING_Y)
-        if (step_needed[Y_AXIS]) {
+        if (step_needed.y) {
           const bool forward = ShapingQueue::dequeue_y();
           PULSE_PREP_SHAPING(Y, shaping_y.delta_error, shaping_y.factor2 * (forward ? 1 : -1));
           PULSE_START(Y);
@@ -2034,8 +2037,8 @@ void Stepper::pulse_phase_isr() {
         #endif
       }
 
-      TERN_(INPUT_SHAPING_X, step_needed[X_AXIS] = !ShapingQueue::peek_x() || ShapingQueue::free_count_x() < steps_per_isr);
-      TERN_(INPUT_SHAPING_Y, step_needed[Y_AXIS] = !ShapingQueue::peek_y() || ShapingQueue::free_count_y() < steps_per_isr);
+      TERN_(INPUT_SHAPING_X, step_needed.x = !ShapingQueue::peek_x() || ShapingQueue::free_count_x() < steps_per_isr);
+      TERN_(INPUT_SHAPING_Y, step_needed.y = !ShapingQueue::peek_y() || ShapingQueue::free_count_y() < steps_per_isr);
 
       if (!bool(step_needed)) break;
 

commit d554844a51691c4e88d0fab8e7893b62e090f235
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 11 19:19:36 2023 -0600

    ⚡️ Use cached la_active state
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index a3183c1b12..acb394f281 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -230,6 +230,7 @@ uint32_t Stepper::advance_divisor = 0,
   int32_t     Stepper::la_delta_error = 0,
               Stepper::la_dividend = 0,
               Stepper::la_advance_steps = 0;
+  bool        Stepper::la_active = false;
 #endif
 
 #if HAS_SHAPING
@@ -1868,7 +1869,7 @@ void Stepper::pulse_phase_isr() {
         PULSE_PREP(E);
 
         #if ENABLED(LIN_ADVANCE)
-          if (step_needed.e && current_block->la_advance_rate) {
+          if (la_active && step_needed.e) {
             // don't actually step here, but do subtract movements steps
             // from the linear advance step count
             step_needed.e = false;
@@ -2170,7 +2171,7 @@ hal_timer_t Stepper::block_phase_isr() {
         acceleration_time += interval;
 
         #if ENABLED(LIN_ADVANCE)
-          if (current_block->la_advance_rate) {
+          if (la_active) {
             const uint32_t la_step_rate = la_advance_steps < current_block->max_adv_steps ? current_block->la_advance_rate : 0;
             la_interval = calc_timer_interval(acc_step_rate + la_step_rate) << current_block->la_scaling;
           }
@@ -2240,7 +2241,7 @@ hal_timer_t Stepper::block_phase_isr() {
         deceleration_time += interval;
 
         #if ENABLED(LIN_ADVANCE)
-          if (current_block->la_advance_rate) {
+          if (la_active) {
             const uint32_t la_step_rate = la_advance_steps > current_block->final_adv_steps ? current_block->la_advance_rate : 0;
             if (la_step_rate != step_rate) {
               bool reverse_e = la_step_rate > step_rate;
@@ -2301,7 +2302,7 @@ hal_timer_t Stepper::block_phase_isr() {
           ticks_nominal = calc_timer_interval(current_block->nominal_rate << oversampling_factor, steps_per_isr);
 
           #if ENABLED(LIN_ADVANCE)
-            if (current_block->la_advance_rate)
+            if (la_active)
               la_interval = calc_timer_interval(current_block->nominal_rate) << current_block->la_scaling;
           #endif
         }
@@ -2556,11 +2557,12 @@ hal_timer_t Stepper::block_phase_isr() {
 
       // Initialize the trapezoid generator from the current block.
       #if ENABLED(LIN_ADVANCE)
+        la_active = (current_block->la_advance_rate != 0);
         #if DISABLED(MIXING_EXTRUDER) && E_STEPPERS > 1
           // If the now active extruder wasn't in use during the last move, its pressure is most likely gone.
           if (stepper_extruder != last_moved_extruder) la_advance_steps = 0;
         #endif
-        if (current_block->la_advance_rate) {
+        if (la_active) {
           // Apply LA scaling and discount the effect of frequency scaling
           la_dividend = (advance_dividend.e << current_block->la_scaling) << oversampling_factor;
         }
@@ -2621,7 +2623,7 @@ hal_timer_t Stepper::block_phase_isr() {
       acceleration_time += interval;
 
       #if ENABLED(LIN_ADVANCE)
-        if (current_block->la_advance_rate) {
+        if (la_active) {
           const uint32_t la_step_rate = la_advance_steps < current_block->max_adv_steps ? current_block->la_advance_rate : 0;
           la_interval = calc_timer_interval(current_block->initial_rate + la_step_rate) << current_block->la_scaling;
         }

commit 194f58740a34c8aa8daebf21baf614c6f1eec518
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 11 19:08:13 2023 -0600

    ⚡️ Use hal_timer_t for timing vars
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 700cdd377b..a3183c1b12 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -225,11 +225,11 @@ uint32_t Stepper::advance_divisor = 0,
 #endif
 
 #if ENABLED(LIN_ADVANCE)
-  uint32_t Stepper::nextAdvanceISR = LA_ADV_NEVER,
-           Stepper::la_interval = LA_ADV_NEVER;
-  int32_t  Stepper::la_delta_error = 0,
-           Stepper::la_dividend = 0,
-           Stepper::la_advance_steps = 0;
+  hal_timer_t Stepper::nextAdvanceISR = LA_ADV_NEVER,
+              Stepper::la_interval = LA_ADV_NEVER;
+  int32_t     Stepper::la_delta_error = 0,
+              Stepper::la_dividend = 0,
+              Stepper::la_advance_steps = 0;
 #endif
 
 #if HAS_SHAPING
@@ -255,14 +255,14 @@ uint32_t Stepper::advance_divisor = 0,
 #endif
 
 #if ENABLED(INTEGRATED_BABYSTEPPING)
-  uint32_t Stepper::nextBabystepISR = BABYSTEP_NEVER;
+  hal_timer_t Stepper::nextBabystepISR = BABYSTEP_NEVER;
 #endif
 
 #if ENABLED(DIRECT_STEPPING)
   page_step_state_t Stepper::page_step_state;
 #endif
 
-int32_t Stepper::ticks_nominal = -1;
+hal_timer_t Stepper::ticks_nominal = 0;
 #if DISABLED(S_CURVE_ACCELERATION)
   uint32_t Stepper::acc_step_rate; // needed for deceleration start point
 #endif
@@ -1462,7 +1462,7 @@ HAL_STEP_TIMER_ISR() {
 
 void Stepper::isr() {
 
-  static uint32_t nextMainISR = 0;  // Interval until the next main Stepper Pulse phase (0 = Now)
+  static hal_timer_t nextMainISR = 0;  // Interval until the next main Stepper Pulse phase (0 = Now)
 
   #ifndef __AVR__
     // Disable interrupts, to avoid ISR preemption while we reprogram the period
@@ -1518,8 +1518,8 @@ void Stepper::isr() {
     #endif
 
     // Get the interval to the next ISR call
-    const uint32_t interval = _MIN(
-      uint32_t(HAL_TIMER_TYPE_MAX),                           // Come back in a very long time
+    const hal_timer_t interval = _MIN(
+      hal_timer_t(HAL_TIMER_TYPE_MAX),                        // Come back in a very long time
       nextMainISR                                             // Time until the next Pulse / Block phase
       OPTARG(INPUT_SHAPING_X, ShapingQueue::peek_x())         // Time until next input shaping echo for X
       OPTARG(INPUT_SHAPING_Y, ShapingQueue::peek_y())         // Time until next input shaping echo for Y
@@ -1598,7 +1598,7 @@ void Stepper::isr() {
   // sure that the time has not arrived yet - Warrantied by the scheduler
 
   // Set the next ISR to fire at the proper time
-  HAL_timer_set_compare(MF_TIMER_STEP, hal_timer_t(next_isr_ticks));
+  HAL_timer_set_compare(MF_TIMER_STEP, next_isr_ticks);
 
   // Don't forget to finally reenable interrupts on non-AVR.
   // AVR automatically calls sei() for us on Return-from-Interrupt.
@@ -2046,7 +2046,7 @@ void Stepper::pulse_phase_isr() {
 #endif // HAS_SHAPING
 
 // Calculate timer interval, with all limits applied.
-uint32_t Stepper::calc_timer_interval(uint32_t step_rate) {
+hal_timer_t Stepper::calc_timer_interval(uint32_t step_rate) {
 
   #ifdef CPU_32_BIT
 
@@ -2078,7 +2078,7 @@ uint32_t Stepper::calc_timer_interval(uint32_t step_rate) {
 }
 
 // Get the timer interval and the number of loops to perform per tick
-uint32_t Stepper::calc_timer_interval(uint32_t step_rate, uint8_t &loops) {
+hal_timer_t Stepper::calc_timer_interval(uint32_t step_rate, uint8_t &loops) {
   uint8_t multistep = 1;
   #if ENABLED(DISABLE_MULTI_STEPPING)
 
@@ -2118,10 +2118,10 @@ uint32_t Stepper::calc_timer_interval(uint32_t step_rate, uint8_t &loops) {
  * schedules planner blocks. This is executed after the step pulses
  * have been done, so it is less time critical.
  */
-uint32_t Stepper::block_phase_isr() {
+hal_timer_t Stepper::block_phase_isr() {
 
   // If no queued movements, just wait 1ms for the next block
-  uint32_t interval = (STEPPER_TIMER_RATE) / 1000UL;
+  hal_timer_t interval = (STEPPER_TIMER_RATE) / 1000UL;
 
   // If there is a current block
   if (current_block) {
@@ -2296,7 +2296,7 @@ uint32_t Stepper::block_phase_isr() {
       else {  // Must be in cruise phase otherwise
 
         // Calculate the ticks_nominal for this nominal speed, if not done yet
-        if (ticks_nominal < 0) {
+        if (ticks_nominal == 0) {
           // step_rate to timer interval and loops for the nominal speed
           ticks_nominal = calc_timer_interval(current_block->nominal_rate << oversampling_factor, steps_per_isr);
 
@@ -2604,7 +2604,7 @@ uint32_t Stepper::block_phase_isr() {
       #endif
 
       // Mark ticks_nominal as not-yet-calculated
-      ticks_nominal = -1;
+      ticks_nominal = 0;
 
       #if ENABLED(S_CURVE_ACCELERATION)
         // Initialize the Bézier speed curve
@@ -2671,7 +2671,7 @@ uint32_t Stepper::block_phase_isr() {
 #if ENABLED(INTEGRATED_BABYSTEPPING)
 
   // Timer interrupt for baby-stepping
-  uint32_t Stepper::babystepping_isr() {
+  hal_timer_t Stepper::babystepping_isr() {
     babystep.task();
     return babystep.has_steps() ? BABYSTEP_TICKS : BABYSTEP_NEVER;
   }

commit f9d3939d2331b785c59924538f1d248d5ad23a58
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 11 18:51:37 2023 -0600

    🎨 Cosmetic stepper updates
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b54b9668ea..700cdd377b 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -189,7 +189,7 @@ bool Stepper::abort_current_block;
 #endif
 
 uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
-uint8_t Stepper::steps_per_isr;
+uint8_t Stepper::steps_per_isr;       // Count of steps to perform per Stepper ISR call
 
 #if ENABLED(FREEZE_FEATURE)
   bool Stepper::frozen; // = false
@@ -1996,7 +1996,7 @@ void Stepper::pulse_phase_isr() {
   void Stepper::shaping_isr() {
     xy_bool_t step_needed{0};
 
-    // Clear the echoes that are ready to process. If the buffers are too full and risk overflo, also apply echoes early.
+    // Clear the echoes that are ready to process. If the buffers are too full and risk overflow, also apply echoes early.
     TERN_(INPUT_SHAPING_X, step_needed[X_AXIS] = !ShapingQueue::peek_x() || ShapingQueue::free_count_x() < steps_per_isr);
     TERN_(INPUT_SHAPING_Y, step_needed[Y_AXIS] = !ShapingQueue::peek_y() || ShapingQueue::free_count_y() < steps_per_isr);
 
@@ -2047,39 +2047,45 @@ void Stepper::pulse_phase_isr() {
 
 // Calculate timer interval, with all limits applied.
 uint32_t Stepper::calc_timer_interval(uint32_t step_rate) {
+
   #ifdef CPU_32_BIT
-    // In case of high-performance processor, it is able to calculate in real-time
-    return uint32_t(STEPPER_TIMER_RATE) / step_rate;
+
+    return uint32_t(STEPPER_TIMER_RATE) / step_rate; // A fast processor can just do integer division
+
   #else
+
     // AVR is able to keep up at 30khz Stepping ISR rate.
-    constexpr uint32_t min_step_rate = (F_CPU) / 500000U;
-    if (step_rate <= min_step_rate) {
+    constexpr uint32_t min_step_rate = (F_CPU) / 500000U; // i.e., 32 or 40
+    if (step_rate <= min_step_rate) { // lower step rates
       step_rate = 0;
-      uintptr_t table_address = (uintptr_t)&speed_lookuptable_slow[0][0];
-      return uint16_t(pgm_read_word(table_address));
+      return uint16_t(pgm_read_word(uintptr_t(speed_lookuptable_slow)));
     }
     else {
       step_rate -= min_step_rate; // Correct for minimal speed
       if (step_rate >= 0x0800) {  // higher step rate
-        const uint8_t rate_mod_256 = (step_rate & 0x00FF);
-        const uintptr_t table_address = uintptr_t(&speed_lookuptable_fast[uint8_t(step_rate >> 8)][0]),
-                        gain = uint16_t(pgm_read_word(table_address + 2));
-        return uint16_t(pgm_read_word(table_address)) - MultiU8X16toH16(rate_mod_256, gain);
+        const uintptr_t table_address = uintptr_t(&speed_lookuptable_fast[uint8_t(step_rate >> 8)]);
+        const uint16_t gain = uint16_t(pgm_read_word(table_address + 2));
+        return uint16_t(pgm_read_word(table_address)) - MultiU8X16toH16(uint8_t(step_rate & 0x00FF), gain);
       }
       else { // lower step rates
-        uintptr_t table_address = uintptr_t(&speed_lookuptable_slow[0][0]);
-        table_address += (step_rate >> 1) & 0xFFFC;
+        const uintptr_t table_address = uintptr_t(&speed_lookuptable_slow[uint8_t(step_rate >> 3)]);
         return uint16_t(pgm_read_word(table_address))
                - ((uint16_t(pgm_read_word(table_address + 2)) * uint8_t(step_rate & 0x0007)) >> 3);
       }
     }
-  #endif
+
+  #endif // !CPU_32_BIT
 }
 
 // Get the timer interval and the number of loops to perform per tick
 uint32_t Stepper::calc_timer_interval(uint32_t step_rate, uint8_t &loops) {
   uint8_t multistep = 1;
-  #if DISABLED(DISABLE_MULTI_STEPPING)
+  #if ENABLED(DISABLE_MULTI_STEPPING)
+
+    // Just make sure the step rate is doable
+    NOMORE(step_rate, uint32_t(MAX_STEP_ISR_FREQUENCY_1X));
+
+  #else
 
     // The stepping frequency limits for each multistepping rate
     static const uint32_t limit[] PROGMEM = {
@@ -2100,18 +2106,18 @@ uint32_t Stepper::calc_timer_interval(uint32_t step_rate, uint8_t &loops) {
       multistep <<= 1;
       ++idx;
     };
-  #else
-    NOMORE(step_rate, uint32_t(MAX_STEP_ISR_FREQUENCY_1X));
+
   #endif
   loops = multistep;
 
   return calc_timer_interval(step_rate);
 }
 
-// This is the last half of the stepper interrupt: This one processes and
-// properly schedules blocks from the planner. This is executed after creating
-// the step pulses, so it is not time critical, as pulses are already done.
-
+/**
+ * This last phase of the stepper interrupt processes and properly
+ * schedules planner blocks. This is executed after the step pulses
+ * have been done, so it is less time critical.
+ */
 uint32_t Stepper::block_phase_isr() {
 
   // If no queued movements, just wait 1ms for the next block
@@ -2555,7 +2561,7 @@ uint32_t Stepper::block_phase_isr() {
           if (stepper_extruder != last_moved_extruder) la_advance_steps = 0;
         #endif
         if (current_block->la_advance_rate) {
-          // apply LA scaling and discount the effect of frequency scaling
+          // Apply LA scaling and discount the effect of frequency scaling
           la_dividend = (advance_dividend.e << current_block->la_scaling) << oversampling_factor;
         }
       #endif
@@ -2597,7 +2603,7 @@ uint32_t Stepper::block_phase_isr() {
         if (current_block->steps.z) enable_axis(Z_AXIS);
       #endif
 
-      // Mark the time_nominal as not calculated yet
+      // Mark ticks_nominal as not-yet-calculated
       ticks_nominal = -1;
 
       #if ENABLED(S_CURVE_ACCELERATION)
@@ -2635,8 +2641,8 @@ uint32_t Stepper::block_phase_isr() {
     // the acceleration and speed values calculated in block_phase_isr().
     // This helps keep LA in sync with, for example, S_CURVE_ACCELERATION.
     la_delta_error += la_dividend;
-    const bool step_needed = la_delta_error >= 0;
-    if (step_needed) {
+    const bool e_step_needed = la_delta_error >= 0;
+    if (e_step_needed) {
       count_position.e += count_direction.e;
       la_advance_steps += count_direction.e;
       la_delta_error -= advance_divisor;
@@ -2647,7 +2653,7 @@ uint32_t Stepper::block_phase_isr() {
 
     TERN_(I2S_STEPPER_STREAM, i2s_push_sample());
 
-    if (step_needed) {
+    if (e_step_needed) {
       // Enforce a minimum duration for STEP pulse ON
       #if ISR_PULSE_CONTROL
         USING_TIMED_PULSE();

commit cb66bff9246534c11acea192deae4ab6281b64c6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 11 19:17:25 2023 -0600

    ⚡️ Exit from ISR on AVR already does sei
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index d0398b404c..b54b9668ea 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1600,8 +1600,11 @@ void Stepper::isr() {
   // Set the next ISR to fire at the proper time
   HAL_timer_set_compare(MF_TIMER_STEP, hal_timer_t(next_isr_ticks));
 
-  // Don't forget to finally reenable interrupts
-  hal.isr_on();
+  // Don't forget to finally reenable interrupts on non-AVR.
+  // AVR automatically calls sei() for us on Return-from-Interrupt.
+  #ifndef __AVR__
+    hal.isr_on();
+  #endif
 }
 
 #if MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE

commit 42cd314d96b764831f6406102530d570aff8a06c
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Wed Mar 1 00:16:27 2023 +0000

    🐛 Fix LA retract/feedrate edge case (#25445)
    
    Followup to #25442

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index d47565f409..d0398b404c 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2261,6 +2261,8 @@ uint32_t Stepper::block_phase_isr() {
                 DIR_WAIT_AFTER();
               }
             }
+            else
+              la_interval = LA_ADV_NEVER;
           }
         #endif // LIN_ADVANCE
 

commit 6084502f8067c001ba3c4ab42e246931a6c6c8d8
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Mon Feb 27 23:00:13 2023 +0000

    🐛 Fix Linear Advance E position tracking (#25442)
    
    Fix regression from #24951

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 0750fd82aa..d47565f409 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1869,7 +1869,6 @@ void Stepper::pulse_phase_isr() {
             // don't actually step here, but do subtract movements steps
             // from the linear advance step count
             step_needed.e = false;
-            count_position.e -= count_direction.e;
             la_advance_steps--;
           }
         #endif

commit f9f6662a8c4692cc67006fb302068c96a0e86ac1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Feb 23 21:08:31 2023 -0600

    ♻️ Stepper options refactor (#25422)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index f9de7498d7..0750fd82aa 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1664,7 +1664,7 @@ void Stepper::pulse_phase_isr() {
 
   do {
     #define _APPLY_STEP(AXIS, INV, ALWAYS) AXIS ##_APPLY_STEP(INV, ALWAYS)
-    #define _INVERT_STEP_PIN(AXIS) INVERT_## AXIS ##_STEP_PIN
+    #define _STEP_STATE(AXIS) STEP_STATE_## AXIS
 
     // Determine if a pulse is needed using Bresenham
     #define PULSE_PREP(AXIS) do{ \
@@ -1714,14 +1714,14 @@ void Stepper::pulse_phase_isr() {
     #define PULSE_START(AXIS) do{ \
       if (step_needed[_AXIS(AXIS)]) { \
         count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \
-        _APPLY_STEP(AXIS, !_INVERT_STEP_PIN(AXIS), 0); \
+        _APPLY_STEP(AXIS, _STEP_STATE(AXIS), 0); \
       } \
     }while(0)
 
     // Stop an active pulse if needed
     #define PULSE_STOP(AXIS) do { \
       if (step_needed[_AXIS(AXIS)]) { \
-        _APPLY_STEP(AXIS, _INVERT_STEP_PIN(AXIS), 0); \
+        _APPLY_STEP(AXIS, !_STEP_STATE(AXIS), 0); \
       } \
     }while(0)
 
@@ -1933,7 +1933,7 @@ void Stepper::pulse_phase_isr() {
     #if ENABLED(MIXING_EXTRUDER)
       if (step_needed.e) {
         count_position[E_AXIS] += count_direction[E_AXIS];
-        E_STEP_WRITE(mixer.get_next_stepper(), !INVERT_E_STEP_PIN);
+        E_STEP_WRITE(mixer.get_next_stepper(), STEP_STATE_E);
       }
     #elif HAS_E0_STEP
       PULSE_START(E);
@@ -1977,7 +1977,7 @@ void Stepper::pulse_phase_isr() {
     #endif
 
     #if ENABLED(MIXING_EXTRUDER)
-      if (step_needed.e) E_STEP_WRITE(mixer.get_stepper(), INVERT_E_STEP_PIN);
+      if (step_needed.e) E_STEP_WRITE(mixer.get_stepper(), !STEP_STATE_E);
     #elif HAS_E0_STEP
       PULSE_STOP(E);
     #endif
@@ -2638,7 +2638,7 @@ uint32_t Stepper::block_phase_isr() {
       la_delta_error -= advance_divisor;
 
       // Set the STEP pulse ON
-      E_STEP_WRITE(TERN(MIXING_EXTRUDER, mixer.get_next_stepper(), stepper_extruder), !INVERT_E_STEP_PIN);
+      E_STEP_WRITE(TERN(MIXING_EXTRUDER, mixer.get_next_stepper(), stepper_extruder), STEP_STATE_E);
     }
 
     TERN_(I2S_STEPPER_STREAM, i2s_push_sample());
@@ -2652,7 +2652,7 @@ uint32_t Stepper::block_phase_isr() {
       #endif
 
       // Set the STEP pulse OFF
-      E_STEP_WRITE(TERN(MIXING_EXTRUDER, mixer.get_stepper(), stepper_extruder), INVERT_E_STEP_PIN);
+      E_STEP_WRITE(TERN(MIXING_EXTRUDER, mixer.get_stepper(), stepper_extruder), !STEP_STATE_E);
     }
   }
 
@@ -2906,7 +2906,7 @@ void Stepper::init() {
 
   #define AXIS_INIT(AXIS, PIN) \
     _STEP_INIT(AXIS); \
-    _WRITE_STEP(AXIS, _INVERT_STEP_PIN(PIN)); \
+    _WRITE_STEP(AXIS, !_STEP_STATE(PIN)); \
     _DISABLE_AXIS(AXIS)
 
   #define E_AXIS_INIT(NUM) AXIS_INIT(E## NUM, E)
@@ -2915,7 +2915,7 @@ void Stepper::init() {
   #if HAS_X_STEP
     #if HAS_X2_STEPPER
       X2_STEP_INIT();
-      X2_STEP_WRITE(INVERT_X_STEP_PIN);
+      X2_STEP_WRITE(!STEP_STATE_X);
     #endif
     AXIS_INIT(X, X);
   #endif
@@ -2923,7 +2923,7 @@ void Stepper::init() {
   #if HAS_Y_STEP
     #if HAS_DUAL_Y_STEPPERS
       Y2_STEP_INIT();
-      Y2_STEP_WRITE(INVERT_Y_STEP_PIN);
+      Y2_STEP_WRITE(!STEP_STATE_Y);
     #endif
     AXIS_INIT(Y, Y);
   #endif
@@ -2931,15 +2931,15 @@ void Stepper::init() {
   #if HAS_Z_STEP
     #if NUM_Z_STEPPERS >= 2
       Z2_STEP_INIT();
-      Z2_STEP_WRITE(INVERT_Z_STEP_PIN);
+      Z2_STEP_WRITE(!STEP_STATE_Z);
     #endif
     #if NUM_Z_STEPPERS >= 3
       Z3_STEP_INIT();
-      Z3_STEP_WRITE(INVERT_Z_STEP_PIN);
+      Z3_STEP_WRITE(!STEP_STATE_Z);
     #endif
     #if NUM_Z_STEPPERS >= 4
       Z4_STEP_INIT();
-      Z4_STEP_WRITE(INVERT_Z_STEP_PIN);
+      Z4_STEP_WRITE(!STEP_STATE_Z);
     #endif
     AXIS_INIT(Z, Z);
   #endif
@@ -3338,19 +3338,19 @@ void Stepper::report_positions() {
 
   #if DISABLED(DELTA)
 
-    #define BABYSTEP_AXIS(AXIS, INV, DIR) do{           \
-      const uint8_t old_dir = _READ_DIR(AXIS);          \
-      _ENABLE_AXIS(AXIS);                               \
-      DIR_WAIT_BEFORE();                                \
-      _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^DIR^INV);      \
-      DIR_WAIT_AFTER();                                 \
-      _SAVE_START();                                    \
-      _APPLY_STEP(AXIS, !_INVERT_STEP_PIN(AXIS), true); \
-      _PULSE_WAIT();                                    \
-      _APPLY_STEP(AXIS, _INVERT_STEP_PIN(AXIS), true);  \
-      EXTRA_DIR_WAIT_BEFORE();                          \
-      _APPLY_DIR(AXIS, old_dir);                        \
-      EXTRA_DIR_WAIT_AFTER();                           \
+    #define BABYSTEP_AXIS(AXIS, INV, DIR) do{      \
+      const uint8_t old_dir = _READ_DIR(AXIS);     \
+      _ENABLE_AXIS(AXIS);                          \
+      DIR_WAIT_BEFORE();                           \
+      _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^DIR^INV); \
+      DIR_WAIT_AFTER();                            \
+      _SAVE_START();                               \
+      _APPLY_STEP(AXIS, _STEP_STATE(AXIS), true);  \
+      _PULSE_WAIT();                               \
+      _APPLY_STEP(AXIS, !_STEP_STATE(AXIS), true); \
+      EXTRA_DIR_WAIT_BEFORE();                     \
+      _APPLY_DIR(AXIS, old_dir);                   \
+      EXTRA_DIR_WAIT_AFTER();                      \
     }while(0)
 
   #endif
@@ -3365,11 +3365,11 @@ void Stepper::report_positions() {
       _APPLY_DIR(B, _INVERT_DIR(B)^DIR^INV^ALT);                \
       DIR_WAIT_AFTER();                                         \
       _SAVE_START();                                            \
-      _APPLY_STEP(A, !_INVERT_STEP_PIN(A), true);               \
-      _APPLY_STEP(B, !_INVERT_STEP_PIN(B), true);               \
+      _APPLY_STEP(A, _STEP_STATE(A), true);                     \
+      _APPLY_STEP(B, _STEP_STATE(B), true);                     \
       _PULSE_WAIT();                                            \
-      _APPLY_STEP(A, _INVERT_STEP_PIN(A), true);                \
-      _APPLY_STEP(B, _INVERT_STEP_PIN(B), true);                \
+      _APPLY_STEP(A, !_STEP_STATE(A), true);                    \
+      _APPLY_STEP(B, !_STEP_STATE(B), true);                    \
       EXTRA_DIR_WAIT_BEFORE();                                  \
       _APPLY_DIR(A, old_dir.a); _APPLY_DIR(B, old_dir.b);       \
       EXTRA_DIR_WAIT_AFTER();                                   \
@@ -3466,58 +3466,58 @@ void Stepper::report_positions() {
 
           _SAVE_START();
 
-          X_STEP_WRITE(!INVERT_X_STEP_PIN);
+          X_STEP_WRITE(STEP_STATE_X);
           #ifdef Y_STEP_WRITE
-            Y_STEP_WRITE(!INVERT_Y_STEP_PIN);
+            Y_STEP_WRITE(STEP_STATE_Y);
           #endif
           #ifdef Z_STEP_WRITE
-            Z_STEP_WRITE(!INVERT_Z_STEP_PIN);
+            Z_STEP_WRITE(STEP_STATE_Z);
           #endif
           #ifdef I_STEP_WRITE
-            I_STEP_WRITE(!INVERT_I_STEP_PIN);
+            I_STEP_WRITE(STEP_STATE_I);
           #endif
           #ifdef J_STEP_WRITE
-            J_STEP_WRITE(!INVERT_J_STEP_PIN);
+            J_STEP_WRITE(STEP_STATE_J);
           #endif
           #ifdef K_STEP_WRITE
-            K_STEP_WRITE(!INVERT_K_STEP_PIN);
+            K_STEP_WRITE(STEP_STATE_K);
           #endif
           #ifdef U_STEP_WRITE
-            U_STEP_WRITE(!INVERT_U_STEP_PIN);
+            U_STEP_WRITE(STEP_STATE_U);
           #endif
           #ifdef V_STEP_WRITE
-            V_STEP_WRITE(!INVERT_V_STEP_PIN);
+            V_STEP_WRITE(STEP_STATE_V);
           #endif
           #ifdef W_STEP_WRITE
-            W_STEP_WRITE(!INVERT_W_STEP_PIN);
+            W_STEP_WRITE(STEP_STATE_W);
           #endif
 
           _PULSE_WAIT();
 
-          X_STEP_WRITE(INVERT_X_STEP_PIN);
+          X_STEP_WRITE(!STEP_STATE_X);
           #ifdef Y_STEP_WRITE
-            Y_STEP_WRITE(INVERT_Y_STEP_PIN);
+            Y_STEP_WRITE(!STEP_STATE_Y);
           #endif
           #ifdef Z_STEP_WRITE
-            Z_STEP_WRITE(INVERT_Z_STEP_PIN);
+            Z_STEP_WRITE(!STEP_STATE_Z);
           #endif
           #ifdef I_STEP_WRITE
-            I_STEP_WRITE(INVERT_I_STEP_PIN);
+            I_STEP_WRITE(!STEP_STATE_I);
           #endif
           #ifdef J_STEP_WRITE
-            J_STEP_WRITE(INVERT_J_STEP_PIN);
+            J_STEP_WRITE(!STEP_STATE_J);
           #endif
           #ifdef K_STEP_WRITE
-            K_STEP_WRITE(INVERT_K_STEP_PIN);
+            K_STEP_WRITE(!STEP_STATE_K);
           #endif
           #ifdef U_STEP_WRITE
-            U_STEP_WRITE(INVERT_U_STEP_PIN);
+            U_STEP_WRITE(!STEP_STATE_U);
           #endif
            #ifdef V_STEP_WRITE
-            V_STEP_WRITE(INVERT_V_STEP_PIN);
+            V_STEP_WRITE(!STEP_STATE_V);
           #endif
           #ifdef W_STEP_WRITE
-            W_STEP_WRITE(INVERT_W_STEP_PIN);
+            W_STEP_WRITE(!STEP_STATE_W);
           #endif
 
           // Restore direction bits

commit 5a8883b44f6a6fc7be43e0f50c5d7708d0e28c97
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Tue Feb 21 22:37:11 2023 +0000

    🐛 Fix AVR maths used by Stepper (#25338)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 54b52cd16e..f9de7498d7 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2062,7 +2062,7 @@ uint32_t Stepper::calc_timer_interval(uint32_t step_rate) {
         const uint8_t rate_mod_256 = (step_rate & 0x00FF);
         const uintptr_t table_address = uintptr_t(&speed_lookuptable_fast[uint8_t(step_rate >> 8)][0]),
                         gain = uint16_t(pgm_read_word(table_address + 2));
-        return uint16_t(pgm_read_word(table_address)) - MultiU16X8toH16(rate_mod_256, gain);
+        return uint16_t(pgm_read_word(table_address)) - MultiU8X16toH16(rate_mod_256, gain);
       }
       else { // lower step rates
         uintptr_t table_address = uintptr_t(&speed_lookuptable_slow[0][0]);

commit cf02107e6a8f9a122f15b38ed6b699215ee7cf16
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jan 25 21:37:10 2023 -0600

    🔧 Refine Input Shaping check (#25280)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 2a9487f096..54b52cd16e 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3020,7 +3020,7 @@ void Stepper::init() {
    * Calculate a fixed point factor to apply to the signal and its echo
    * when shaping an axis.
    */
-  void Stepper::set_shaping_damping_ratio(const AxisEnum axis, const float zeta) {
+  void Stepper::set_shaping_damping_ratio(const AxisEnum axis, const_float_t zeta) {
     // from the damping ratio, get a factor that can be applied to advance_dividend for fixed point maths
     // for ZV, we use amplitudes 1/(1+K) and K/(1+K) where K = exp(-zeta * M_PI / sqrt(1.0f - zeta * zeta))
     // which can be converted to 1:7 fixed point with an excellent fit with a 3rd order polynomial
@@ -3029,9 +3029,9 @@ void Stepper::init() {
     else if (zeta >= 1.0f) factor2 = 0.0f;
     else {
       factor2 = 64.44056192 + -99.02008832 * zeta;
-      const float zeta2 = zeta * zeta;
+      const_float_t zeta2 = zeta * zeta;
       factor2 += -7.58095488 * zeta2;
-      const float zeta3 = zeta2 * zeta;
+      const_float_t zeta3 = zeta2 * zeta;
       factor2 += 43.073216 * zeta3;
       factor2 = floor(factor2);
     }
@@ -3049,7 +3049,7 @@ void Stepper::init() {
     return -1;
   }
 
-  void Stepper::set_shaping_frequency(const AxisEnum axis, const float freq) {
+  void Stepper::set_shaping_frequency(const AxisEnum axis, const_float_t freq) {
     // enabling or disabling shaping whilst moving can result in lost steps
     planner.synchronize();
 

commit e0ae072f5a7094af02704fd7ccc4f3894f076d7a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 24 02:21:02 2023 -0600

    🔧 Overridable Stepper EN init

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 9c3d459634..2a9487f096 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2776,35 +2776,44 @@ void Stepper::init() {
 
   // Init Enable Pins - steppers default to disabled.
   #if HAS_X_ENABLE
+    #ifndef X_ENABLE_INIT_STATE
+      #define X_ENABLE_INIT_STATE !X_ENABLE_ON
+    #endif
     X_ENABLE_INIT();
-    if (!X_ENABLE_ON) X_ENABLE_WRITE(HIGH);
+    if (X_ENABLE_INIT_STATE) X_ENABLE_WRITE(X_ENABLE_INIT_STATE);
     #if BOTH(HAS_X2_STEPPER, HAS_X2_ENABLE)
       X2_ENABLE_INIT();
-      if (!X_ENABLE_ON) X2_ENABLE_WRITE(HIGH);
+      if (X_ENABLE_INIT_STATE) X2_ENABLE_WRITE(X_ENABLE_INIT_STATE);
     #endif
   #endif
   #if HAS_Y_ENABLE
+    #ifndef Y_ENABLE_INIT_STATE
+      #define Y_ENABLE_INIT_STATE !Y_ENABLE_ON
+    #endif
     Y_ENABLE_INIT();
-    if (!Y_ENABLE_ON) Y_ENABLE_WRITE(HIGH);
+    if (Y_ENABLE_INIT_STATE) Y_ENABLE_WRITE(Y_ENABLE_INIT_STATE);
     #if BOTH(HAS_DUAL_Y_STEPPERS, HAS_Y2_ENABLE)
       Y2_ENABLE_INIT();
-      if (!Y_ENABLE_ON) Y2_ENABLE_WRITE(HIGH);
+      if (Y_ENABLE_INIT_STATE) Y2_ENABLE_WRITE(Y_ENABLE_INIT_STATE);
     #endif
   #endif
   #if HAS_Z_ENABLE
+    #ifndef Z_ENABLE_INIT_STATE
+      #define Z_ENABLE_INIT_STATE !Z_ENABLE_ON
+    #endif
     Z_ENABLE_INIT();
-    if (!Z_ENABLE_ON) Z_ENABLE_WRITE(HIGH);
+    if (Z_ENABLE_INIT_STATE) Z_ENABLE_WRITE(Z_ENABLE_INIT_STATE);
     #if NUM_Z_STEPPERS >= 2 && HAS_Z2_ENABLE
       Z2_ENABLE_INIT();
-      if (!Z_ENABLE_ON) Z2_ENABLE_WRITE(HIGH);
+      if (Z_ENABLE_INIT_STATE) Z2_ENABLE_WRITE(Z_ENABLE_INIT_STATE);
     #endif
     #if NUM_Z_STEPPERS >= 3 && HAS_Z3_ENABLE
       Z3_ENABLE_INIT();
-      if (!Z_ENABLE_ON) Z3_ENABLE_WRITE(HIGH);
+      if (Z_ENABLE_INIT_STATE) Z3_ENABLE_WRITE(Z_ENABLE_INIT_STATE);
     #endif
     #if NUM_Z_STEPPERS >= 4 && HAS_Z4_ENABLE
       Z4_ENABLE_INIT();
-      if (!Z_ENABLE_ON) Z4_ENABLE_WRITE(HIGH);
+      if (Z_ENABLE_INIT_STATE) Z4_ENABLE_WRITE(Z_ENABLE_INIT_STATE);
     #endif
   #endif
   #if HAS_I_ENABLE
@@ -2832,36 +2841,63 @@ void Stepper::init() {
     if (!W_ENABLE_ON) W_ENABLE_WRITE(HIGH);
   #endif
   #if HAS_E0_ENABLE
+    #ifndef E_ENABLE_INIT_STATE
+      #define E_ENABLE_INIT_STATE !E_ENABLE_ON
+    #endif
+    #ifndef E0_ENABLE_INIT_STATE
+      #define E0_ENABLE_INIT_STATE E_ENABLE_INIT_STATE
+    #endif
     E0_ENABLE_INIT();
-    if (!E_ENABLE_ON) E0_ENABLE_WRITE(HIGH);
+    if (E0_ENABLE_INIT_STATE) E0_ENABLE_WRITE(E0_ENABLE_INIT_STATE);
   #endif
   #if HAS_E1_ENABLE
+    #ifndef E1_ENABLE_INIT_STATE
+      #define E1_ENABLE_INIT_STATE E_ENABLE_INIT_STATE
+    #endif
     E1_ENABLE_INIT();
-    if (!E_ENABLE_ON) E1_ENABLE_WRITE(HIGH);
+    if (E1_ENABLE_INIT_STATE) E1_ENABLE_WRITE(E1_ENABLE_INIT_STATE);
   #endif
   #if HAS_E2_ENABLE
+    #ifndef E2_ENABLE_INIT_STATE
+      #define E2_ENABLE_INIT_STATE E_ENABLE_INIT_STATE
+    #endif
     E2_ENABLE_INIT();
-    if (!E_ENABLE_ON) E2_ENABLE_WRITE(HIGH);
+    if (E2_ENABLE_INIT_STATE) E2_ENABLE_WRITE(E2_ENABLE_INIT_STATE);
   #endif
   #if HAS_E3_ENABLE
+    #ifndef E3_ENABLE_INIT_STATE
+      #define E3_ENABLE_INIT_STATE E_ENABLE_INIT_STATE
+    #endif
     E3_ENABLE_INIT();
-    if (!E_ENABLE_ON) E3_ENABLE_WRITE(HIGH);
+    if (E3_ENABLE_INIT_STATE) E3_ENABLE_WRITE(E3_ENABLE_INIT_STATE);
   #endif
   #if HAS_E4_ENABLE
+    #ifndef E4_ENABLE_INIT_STATE
+      #define E4_ENABLE_INIT_STATE E_ENABLE_INIT_STATE
+    #endif
     E4_ENABLE_INIT();
-    if (!E_ENABLE_ON) E4_ENABLE_WRITE(HIGH);
+    if (E4_ENABLE_INIT_STATE) E4_ENABLE_WRITE(E4_ENABLE_INIT_STATE);
   #endif
   #if HAS_E5_ENABLE
+    #ifndef E5_ENABLE_INIT_STATE
+      #define E5_ENABLE_INIT_STATE E_ENABLE_INIT_STATE
+    #endif
     E5_ENABLE_INIT();
-    if (!E_ENABLE_ON) E5_ENABLE_WRITE(HIGH);
+    if (E5_ENABLE_INIT_STATE) E5_ENABLE_WRITE(E5_ENABLE_INIT_STATE);
   #endif
   #if HAS_E6_ENABLE
+    #ifndef E6_ENABLE_INIT_STATE
+      #define E6_ENABLE_INIT_STATE E_ENABLE_INIT_STATE
+    #endif
     E6_ENABLE_INIT();
-    if (!E_ENABLE_ON) E6_ENABLE_WRITE(HIGH);
+    if (E6_ENABLE_INIT_STATE) E6_ENABLE_WRITE(E6_ENABLE_INIT_STATE);
   #endif
   #if HAS_E7_ENABLE
+    #ifndef E7_ENABLE_INIT_STATE
+      #define E7_ENABLE_INIT_STATE E_ENABLE_INIT_STATE
+    #endif
     E7_ENABLE_INIT();
-    if (!E_ENABLE_ON) E7_ENABLE_WRITE(HIGH);
+    if (E7_ENABLE_INIT_STATE) E7_ENABLE_WRITE(E7_ENABLE_INIT_STATE);
   #endif
 
   #define _STEP_INIT(AXIS) AXIS ##_STEP_INIT()

commit 7717beb79362522b8239d5af62b32ff3d0e2d748
Author: kadir ilkimen <kadirilkimen@gmail.com>
Date:   Wed Jan 11 06:29:38 2023 +0200

    ✨ Polar Kinematics (#25214)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 70a1e25cec..9c3d459634 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3212,7 +3212,7 @@ int32_t Stepper::triggered_position(const AxisEnum axis) {
 #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX, IS_SCARA, DELTA)
   #define SAYS_A 1
 #endif
-#if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY, MARKFORGED_YX, IS_SCARA, DELTA)
+#if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY, MARKFORGED_YX, IS_SCARA, DELTA, POLAR)
   #define SAYS_B 1
 #endif
 #if ANY(CORE_IS_XZ, CORE_IS_YZ, DELTA)

commit e744ca78a8095d0d70eb80a00d93fe0c19f93d10
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 3 04:09:40 2023 -0600

    🎨 Misc. IS cleanup

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 46b21a20b6..70a1e25cec 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3015,7 +3015,7 @@ void Stepper::init() {
 
   void Stepper::set_shaping_frequency(const AxisEnum axis, const float freq) {
     // enabling or disabling shaping whilst moving can result in lost steps
-    Planner::synchronize();
+    planner.synchronize();
 
     const bool was_on = hal.isr_state();
     hal.isr_off();

commit 5c3d87a951cee94ce3d5ac500079da705a274be4
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sun Dec 4 02:14:31 2022 +0000

    🐛 Fix TMC5160 + Input Shaping overcurrent (#25050)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 74e761dc64..46b21a20b6 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1679,12 +1679,14 @@ void Stepper::pulse_phase_isr() {
     // the TMC2208 / TMC2225 shutdown bug (#16076), add a half step hysteresis
     // in each direction. This results in the position being off by half an
     // average half step during travel but correct at the end of each segment.
-    #if AXIS_DRIVER_TYPE_X(TMC2208) || AXIS_DRIVER_TYPE_X(TMC2208_STANDALONE)
+    #if AXIS_DRIVER_TYPE_X(TMC2208) || AXIS_DRIVER_TYPE_X(TMC2208_STANDALONE) || \
+        AXIS_DRIVER_TYPE_X(TMC5160) || AXIS_DRIVER_TYPE_X(TMC5160_STANDALONE)
       #define HYSTERESIS_X 64
     #else
       #define HYSTERESIS_X 0
     #endif
-    #if AXIS_DRIVER_TYPE_Y(TMC2208) || AXIS_DRIVER_TYPE_Y(TMC2208_STANDALONE)
+    #if AXIS_DRIVER_TYPE_Y(TMC2208) || AXIS_DRIVER_TYPE_Y(TMC2208_STANDALONE) || \
+        AXIS_DRIVER_TYPE_Y(TMC5160) || AXIS_DRIVER_TYPE_Y(TMC5160_STANDALONE)
       #define HYSTERESIS_Y 64
     #else
       #define HYSTERESIS_Y 0

commit 89334caa526f2d300eee834d34d06d8f837a57d5
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Mon Nov 28 03:38:15 2022 +0000

    ⚡️ Input Shaping improvements (#24951)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 6cc40ccece..74e761dc64 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -232,17 +232,25 @@ uint32_t Stepper::advance_divisor = 0,
            Stepper::la_advance_steps = 0;
 #endif
 
-#if ENABLED(INPUT_SHAPING)
-  shaping_time_t                DelayTimeManager::now = 0;
-  ParamDelayQueue               Stepper::shaping_dividend_queue;
-  DelayQueue<shaping_dividends> Stepper::shaping_queue;
-  #if HAS_SHAPING_X
-    shaping_time_t DelayTimeManager::delay_x;
-    ShapeParams Stepper::shaping_x;
+#if HAS_SHAPING
+  shaping_time_t      ShapingQueue::now = 0;
+  shaping_time_t      ShapingQueue::times[shaping_echoes];
+  shaping_echo_axis_t ShapingQueue::echo_axes[shaping_echoes];
+  uint16_t            ShapingQueue::tail = 0;
+
+  #if ENABLED(INPUT_SHAPING_X)
+    shaping_time_t  ShapingQueue::delay_x;
+    shaping_time_t  ShapingQueue::peek_x_val = shaping_time_t(-1);
+    uint16_t        ShapingQueue::head_x = 0;
+    uint16_t        ShapingQueue::_free_count_x = shaping_echoes - 1;
+    ShapeParams     Stepper::shaping_x;
   #endif
-  #if HAS_SHAPING_Y
-    shaping_time_t DelayTimeManager::delay_y;
-    ShapeParams Stepper::shaping_y;
+  #if ENABLED(INPUT_SHAPING_Y)
+    shaping_time_t  ShapingQueue::delay_y;
+    shaping_time_t  ShapingQueue::peek_y_val = shaping_time_t(-1);
+    uint16_t        ShapingQueue::head_y = 0;
+    uint16_t        ShapingQueue::_free_count_y = shaping_echoes - 1;
+    ShapeParams     Stepper::shaping_y;
   #endif
 #endif
 
@@ -1479,20 +1487,10 @@ void Stepper::isr() {
     // Enable ISRs to reduce USART processing latency
     hal.isr_on();
 
-    #if ENABLED(INPUT_SHAPING)
-      // Speed limiting should ensure the buffers never get full. But if somehow they do, stutter rather than overflow.
-      if (!nextMainISR) {
-        TERN_(HAS_SHAPING_X, if (shaping_dividend_queue.free_count_x() == 0) nextMainISR = shaping_dividend_queue.peek_x() + 1);
-        TERN_(HAS_SHAPING_Y, if (shaping_dividend_queue.free_count_y() == 0) NOLESS(nextMainISR, shaping_dividend_queue.peek_y() + 1));
-        TERN_(HAS_SHAPING_X, if (shaping_queue.free_count_x() < steps_per_isr) NOLESS(nextMainISR, shaping_queue.peek_x() + 1));
-        TERN_(HAS_SHAPING_Y, if (shaping_queue.free_count_y() < steps_per_isr) NOLESS(nextMainISR, shaping_queue.peek_y() + 1));
-      }
-    #endif
+    TERN_(HAS_SHAPING, shaping_isr());                  // Do Shaper stepping, if needed
 
     if (!nextMainISR) pulse_phase_isr();                // 0 = Do coordinated axes Stepper pulses
 
-    TERN_(INPUT_SHAPING, shaping_isr());                // Do Shaper stepping, if needed
-
     #if ENABLED(LIN_ADVANCE)
       if (!nextAdvanceISR) {                            // 0 = Do Linear Advance E Stepper pulses
         advance_isr();
@@ -1523,10 +1521,8 @@ void Stepper::isr() {
     const uint32_t interval = _MIN(
       uint32_t(HAL_TIMER_TYPE_MAX),                           // Come back in a very long time
       nextMainISR                                             // Time until the next Pulse / Block phase
-      OPTARG(HAS_SHAPING_X, shaping_dividend_queue.peek_x())  // Time until next input shaping dividend change for X
-      OPTARG(HAS_SHAPING_Y, shaping_dividend_queue.peek_y())  // Time until next input shaping dividend change for Y
-      OPTARG(HAS_SHAPING_X, shaping_queue.peek_x())           // Time until next input shaping echo for X
-      OPTARG(HAS_SHAPING_Y, shaping_queue.peek_y())           // Time until next input shaping echo for Y
+      OPTARG(INPUT_SHAPING_X, ShapingQueue::peek_x())         // Time until next input shaping echo for X
+      OPTARG(INPUT_SHAPING_Y, ShapingQueue::peek_y())         // Time until next input shaping echo for Y
       OPTARG(LIN_ADVANCE, nextAdvanceISR)                     // Come back early for Linear Advance?
       OPTARG(INTEGRATED_BABYSTEPPING, nextBabystepISR)        // Come back early for Babystepping?
     );
@@ -1539,16 +1535,9 @@ void Stepper::isr() {
     //
 
     nextMainISR -= interval;
-
-    TERN_(INPUT_SHAPING, DelayTimeManager::decrement_delays(interval));
-
-    #if ENABLED(LIN_ADVANCE)
-      if (nextAdvanceISR != LA_ADV_NEVER) nextAdvanceISR -= interval;
-    #endif
-
-    #if ENABLED(INTEGRATED_BABYSTEPPING)
-      if (nextBabystepISR != BABYSTEP_NEVER) nextBabystepISR -= interval;
-    #endif
+    TERN_(HAS_SHAPING, ShapingQueue::decrement_delays(interval));
+    TERN_(LIN_ADVANCE, if (nextAdvanceISR != LA_ADV_NEVER) nextAdvanceISR -= interval);
+    TERN_(INTEGRATED_BABYSTEPPING, if (nextBabystepISR != BABYSTEP_NEVER) nextBabystepISR -= interval);
 
     /**
      * This needs to avoid a race-condition caused by interleaving
@@ -1636,11 +1625,16 @@ void Stepper::pulse_phase_isr() {
     abort_current_block = false;
     if (current_block) {
       discard_current_block();
-      #if ENABLED(INPUT_SHAPING)
-        shaping_dividend_queue.purge();
-        shaping_queue.purge();
-        TERN_(HAS_SHAPING_X, delta_error.x = 0);
-        TERN_(HAS_SHAPING_Y, delta_error.y = 0);
+      #if HAS_SHAPING
+        ShapingQueue::purge();
+        #if ENABLED(INPUT_SHAPING_X)
+          shaping_x.delta_error = 0;
+          shaping_x.last_block_end_pos = count_position.x;
+        #endif
+        #if ENABLED(INPUT_SHAPING_Y)
+          shaping_y.delta_error = 0;
+          shaping_y.last_block_end_pos = count_position.y;
+        #endif
       #endif
     }
   }
@@ -1676,31 +1670,48 @@ void Stepper::pulse_phase_isr() {
     #define PULSE_PREP(AXIS) do{ \
       delta_error[_AXIS(AXIS)] += advance_dividend[_AXIS(AXIS)]; \
       step_needed[_AXIS(AXIS)] = (delta_error[_AXIS(AXIS)] >= 0); \
-      if (step_needed[_AXIS(AXIS)]) { \
-        count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \
+      if (step_needed[_AXIS(AXIS)]) \
         delta_error[_AXIS(AXIS)] -= advance_divisor; \
-      } \
     }while(0)
 
-    #define PULSE_PREP_SHAPING(AXIS, DIVIDEND) do{ \
-      delta_error[_AXIS(AXIS)] += (DIVIDEND); \
-      if ((MAXDIR(AXIS) && delta_error[_AXIS(AXIS)] <= -0x30000000L) || (MINDIR(AXIS) && delta_error[_AXIS(AXIS)] >= 0x30000000L)) { \
-        TBI(last_direction_bits, _AXIS(AXIS)); \
-        DIR_WAIT_BEFORE(); \
-        SET_STEP_DIR(AXIS); \
-        DIR_WAIT_AFTER(); \
-      } \
-      step_needed[_AXIS(AXIS)] = (MAXDIR(AXIS) && delta_error[_AXIS(AXIS)] >= 0x10000000L) || \
-                                 (MINDIR(AXIS) && delta_error[_AXIS(AXIS)] <= -0x10000000L); \
+    // With input shaping, direction changes can happen with almost only
+    // AWAIT_LOW_PULSE() and  DIR_WAIT_BEFORE() between steps. To work around
+    // the TMC2208 / TMC2225 shutdown bug (#16076), add a half step hysteresis
+    // in each direction. This results in the position being off by half an
+    // average half step during travel but correct at the end of each segment.
+    #if AXIS_DRIVER_TYPE_X(TMC2208) || AXIS_DRIVER_TYPE_X(TMC2208_STANDALONE)
+      #define HYSTERESIS_X 64
+    #else
+      #define HYSTERESIS_X 0
+    #endif
+    #if AXIS_DRIVER_TYPE_Y(TMC2208) || AXIS_DRIVER_TYPE_Y(TMC2208_STANDALONE)
+      #define HYSTERESIS_Y 64
+    #else
+      #define HYSTERESIS_Y 0
+    #endif
+    #define _HYSTERESIS(AXIS) HYSTERESIS_##AXIS
+    #define HYSTERESIS(AXIS) _HYSTERESIS(AXIS)
+
+    #define PULSE_PREP_SHAPING(AXIS, DELTA_ERROR, DIVIDEND) do{ \
       if (step_needed[_AXIS(AXIS)]) { \
-        count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \
-        delta_error[_AXIS(AXIS)] += MAXDIR(AXIS) ? -0x20000000L : 0x20000000L; \
+        DELTA_ERROR += (DIVIDEND); \
+        if ((MAXDIR(AXIS) && DELTA_ERROR <= -(64 + HYSTERESIS(AXIS))) || (MINDIR(AXIS) && DELTA_ERROR >= (64 + HYSTERESIS(AXIS)))) { \
+          { USING_TIMED_PULSE(); START_TIMED_PULSE(); AWAIT_LOW_PULSE(); } \
+          TBI(last_direction_bits, _AXIS(AXIS)); \
+          DIR_WAIT_BEFORE(); \
+          SET_STEP_DIR(AXIS); \
+          DIR_WAIT_AFTER(); \
+        } \
+        step_needed[_AXIS(AXIS)] = DELTA_ERROR <= -(64 + HYSTERESIS(AXIS)) || DELTA_ERROR >= (64 + HYSTERESIS(AXIS)); \
+        if (step_needed[_AXIS(AXIS)]) \
+          DELTA_ERROR += MAXDIR(AXIS) ? -128 : 128; \
       } \
     }while(0)
 
     // Start an active pulse if needed
     #define PULSE_START(AXIS) do{ \
       if (step_needed[_AXIS(AXIS)]) { \
+        count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \
         _APPLY_STEP(AXIS, !_INVERT_STEP_PIN(AXIS), 0); \
       } \
     }while(0)
@@ -1819,22 +1830,12 @@ void Stepper::pulse_phase_isr() {
     #endif // DIRECT_STEPPING
 
     if (!is_page) {
-      TERN_(INPUT_SHAPING, shaping_queue.enqueue());
-
       // Determine if pulses are needed
       #if HAS_X_STEP
-        #if HAS_SHAPING_X
-          PULSE_PREP_SHAPING(X, advance_dividend.x);
-        #else
-          PULSE_PREP(X);
-        #endif
+        PULSE_PREP(X);
       #endif
       #if HAS_Y_STEP
-        #if HAS_SHAPING_Y
-          PULSE_PREP_SHAPING(Y, advance_dividend.y);
-        #else
-          PULSE_PREP(Y);
-        #endif
+        PULSE_PREP(Y);
       #endif
       #if HAS_Z_STEP
         PULSE_PREP(Z);
@@ -1871,6 +1872,24 @@ void Stepper::pulse_phase_isr() {
           }
         #endif
       #endif
+
+      #if HAS_SHAPING
+        // record an echo if a step is needed in the primary bresenham
+        const bool x_step = TERN0(INPUT_SHAPING_X, shaping_x.enabled && step_needed[X_AXIS]),
+                   y_step = TERN0(INPUT_SHAPING_Y, shaping_y.enabled && step_needed[Y_AXIS]);
+        if (x_step || y_step)
+          ShapingQueue::enqueue(x_step, TERN0(INPUT_SHAPING_X, shaping_x.forward), y_step, TERN0(INPUT_SHAPING_Y, shaping_y.forward));
+
+        // do the first part of the secondary bresenham
+        #if ENABLED(INPUT_SHAPING_X)
+          if (shaping_x.enabled)
+            PULSE_PREP_SHAPING(X, shaping_x.delta_error, shaping_x.factor1 * (shaping_x.forward ? 1 : -1));
+        #endif
+        #if ENABLED(INPUT_SHAPING_Y)
+          if (shaping_y.enabled)
+            PULSE_PREP_SHAPING(Y, shaping_y.delta_error, shaping_y.factor1 * (shaping_y.forward ? 1 : -1));
+        #endif
+      #endif
     }
 
     #if ISR_MULTI_STEPS
@@ -1910,7 +1929,10 @@ void Stepper::pulse_phase_isr() {
     #endif
 
     #if ENABLED(MIXING_EXTRUDER)
-      if (step_needed.e) E_STEP_WRITE(mixer.get_next_stepper(), !INVERT_E_STEP_PIN);
+      if (step_needed.e) {
+        count_position[E_AXIS] += count_direction[E_AXIS];
+        E_STEP_WRITE(mixer.get_next_stepper(), !INVERT_E_STEP_PIN);
+      }
     #elif HAS_E0_STEP
       PULSE_START(E);
     #endif
@@ -1965,55 +1987,59 @@ void Stepper::pulse_phase_isr() {
   } while (--events_to_do);
 }
 
-#if ENABLED(INPUT_SHAPING)
+#if HAS_SHAPING
 
   void Stepper::shaping_isr() {
-    xyze_bool_t step_needed{0};
+    xy_bool_t step_needed{0};
+
+    // Clear the echoes that are ready to process. If the buffers are too full and risk overflo, also apply echoes early.
+    TERN_(INPUT_SHAPING_X, step_needed[X_AXIS] = !ShapingQueue::peek_x() || ShapingQueue::free_count_x() < steps_per_isr);
+    TERN_(INPUT_SHAPING_Y, step_needed[Y_AXIS] = !ShapingQueue::peek_y() || ShapingQueue::free_count_y() < steps_per_isr);
+
+    if (bool(step_needed)) while (true) {
+      #if ENABLED(INPUT_SHAPING_X)
+        if (step_needed[X_AXIS]) {
+          const bool forward = ShapingQueue::dequeue_x();
+          PULSE_PREP_SHAPING(X, shaping_x.delta_error, shaping_x.factor2 * (forward ? 1 : -1));
+          PULSE_START(X);
+        }
+      #endif
 
-    const bool shapex = TERN0(HAS_SHAPING_X, !shaping_queue.peek_x()),
-               shapey = TERN0(HAS_SHAPING_Y, !shaping_queue.peek_y());
+      #if ENABLED(INPUT_SHAPING_Y)
+        if (step_needed[Y_AXIS]) {
+          const bool forward = ShapingQueue::dequeue_y();
+          PULSE_PREP_SHAPING(Y, shaping_y.delta_error, shaping_y.factor2 * (forward ? 1 : -1));
+          PULSE_START(Y);
+        }
+      #endif
 
-    #if HAS_SHAPING_X
-      if (!shaping_dividend_queue.peek_x()) shaping_x.dividend = shaping_dividend_queue.dequeue_x();
-    #endif
-    #if HAS_SHAPING_Y
-      if (!shaping_dividend_queue.peek_y()) shaping_y.dividend = shaping_dividend_queue.dequeue_y();
-    #endif
+      TERN_(I2S_STEPPER_STREAM, i2s_push_sample());
 
-    #if HAS_SHAPING_X
-      if (shapex) {
-        shaping_queue.dequeue_x();
-        PULSE_PREP_SHAPING(X, shaping_x.dividend);
-        PULSE_START(X);
+      USING_TIMED_PULSE();
+      if (bool(step_needed)) {
+        #if ISR_MULTI_STEPS
+          START_TIMED_PULSE();
+          AWAIT_HIGH_PULSE();
+        #endif
+        #if ENABLED(INPUT_SHAPING_X)
+          PULSE_STOP(X);
+        #endif
+        #if ENABLED(INPUT_SHAPING_Y)
+          PULSE_STOP(Y);
+        #endif
       }
-    #endif
 
-    #if HAS_SHAPING_Y
-      if (shapey) {
-        shaping_queue.dequeue_y();
-        PULSE_PREP_SHAPING(Y, shaping_y.dividend);
-        PULSE_START(Y);
-      }
-    #endif
+      TERN_(INPUT_SHAPING_X, step_needed[X_AXIS] = !ShapingQueue::peek_x() || ShapingQueue::free_count_x() < steps_per_isr);
+      TERN_(INPUT_SHAPING_Y, step_needed[Y_AXIS] = !ShapingQueue::peek_y() || ShapingQueue::free_count_y() < steps_per_isr);
 
-    TERN_(I2S_STEPPER_STREAM, i2s_push_sample());
+      if (!bool(step_needed)) break;
 
-    if (shapex || shapey) {
-      #if ISR_MULTI_STEPS
-        USING_TIMED_PULSE();
-        START_TIMED_PULSE();
-        AWAIT_HIGH_PULSE();
-      #endif
-      #if HAS_SHAPING_X
-        if (shapex) PULSE_STOP(X);
-      #endif
-      #if HAS_SHAPING_Y
-        if (shapey) PULSE_STOP(Y);
-      #endif
+      START_TIMED_PULSE();
+      AWAIT_LOW_PULSE();
     }
   }
 
-#endif // INPUT_SHAPING
+#endif // HAS_SHAPING
 
 // Calculate timer interval, with all limits applied.
 uint32_t Stepper::calc_timer_interval(uint32_t step_rate) {
@@ -2462,79 +2488,55 @@ uint32_t Stepper::block_phase_isr() {
       acceleration_time = deceleration_time = 0;
 
       #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
-        uint8_t oversampling = 0;                           // Assume no axis smoothing (via oversampling)
+        oversampling_factor = 0;                            // Assume no axis smoothing (via oversampling)
         // Decide if axis smoothing is possible
         uint32_t max_rate = current_block->nominal_rate;    // Get the step event rate
         while (max_rate < MIN_STEP_ISR_FREQUENCY) {         // As long as more ISRs are possible...
           max_rate <<= 1;                                   // Try to double the rate
           if (max_rate < MIN_STEP_ISR_FREQUENCY)            // Don't exceed the estimated ISR limit
-            ++oversampling;                                 // Increase the oversampling (used for left-shift)
+            ++oversampling_factor;                          // Increase the oversampling (used for left-shift)
         }
-        oversampling_factor = oversampling;                 // For all timer interval calculations
-      #else
-        constexpr uint8_t oversampling = 0;
       #endif
 
       // Based on the oversampling factor, do the calculations
-      step_event_count = current_block->step_event_count << oversampling;
+      step_event_count = current_block->step_event_count << oversampling_factor;
 
       // Initialize Bresenham delta errors to 1/2
-      #if HAS_SHAPING_X
-        const int32_t old_delta_error_x = delta_error.x;
-      #endif
-      #if HAS_SHAPING_Y
-        const int32_t old_delta_error_y = delta_error.y;
-      #endif
       delta_error = TERN_(LIN_ADVANCE, la_delta_error =) -int32_t(step_event_count);
 
       // Calculate Bresenham dividends and divisors
       advance_dividend = (current_block->steps << 1).asLong();
       advance_divisor = step_event_count << 1;
 
-      // for input shaped axes, advance_divisor is replaced with 0x40000000
-      // and steps are repeated twice so dividends have to be scaled and halved
-      // and the dividend is directional, i.e. signed
-      TERN_(HAS_SHAPING_X, advance_dividend.x = (uint64_t(current_block->steps.x) << 29) / step_event_count);
-      TERN_(HAS_SHAPING_X, if (TEST(current_block->direction_bits, X_AXIS)) advance_dividend.x *= -1);
-      TERN_(HAS_SHAPING_X, if (!shaping_queue.empty_x()) SET_BIT_TO(current_block->direction_bits, X_AXIS, TEST(last_direction_bits, X_AXIS)));
-      TERN_(HAS_SHAPING_Y, advance_dividend.y = (uint64_t(current_block->steps.y) << 29) / step_event_count);
-      TERN_(HAS_SHAPING_Y, if (TEST(current_block->direction_bits, Y_AXIS)) advance_dividend.y *= -1);
-      TERN_(HAS_SHAPING_Y, if (!shaping_queue.empty_y()) SET_BIT_TO(current_block->direction_bits, Y_AXIS, TEST(last_direction_bits, Y_AXIS)));
-
-      // The scaling operation above introduces rounding errors which must now be removed.
-      // For this segment, there will be step_event_count calls to the Bresenham logic and the same number of echoes.
-      // For each pair of calls to the Bresenham logic, delta_error will increase by advance_dividend modulo 0x20000000
-      // so (e.g. for x) delta_error.x will end up changing by (advance_dividend.x * step_event_count) % 0x20000000.
-      // For a divisor which is a power of 2, modulo is the same as as a bitmask, i.e.
-      // (advance_dividend.x * step_event_count) & 0x1FFFFFFF.
-      // This segment's final change in delta_error should actually be zero so we need to increase delta_error by
-      // 0 - ((advance_dividend.x * step_event_count) & 0x1FFFFFFF)
-      // And this needs to be adjusted to the range -0x10000000 to 0x10000000.
-      // Adding and subtracting 0x10000000 inside the outside the modulo achieves this.
-      TERN_(HAS_SHAPING_X, delta_error.x = old_delta_error_x + 0x10000000L - ((0x10000000L + advance_dividend.x * step_event_count) & 0x1FFFFFFFUL));
-      TERN_(HAS_SHAPING_Y, delta_error.y = old_delta_error_y + 0x10000000L - ((0x10000000L + advance_dividend.y * step_event_count) & 0x1FFFFFFFUL));
-
-      // when there is damping, the signal and its echo have different amplitudes
-      #if ENABLED(HAS_SHAPING_X)
-        const int32_t echo_x = shaping_x.factor * (advance_dividend.x >> 7);
-      #endif
-      #if ENABLED(HAS_SHAPING_Y)
-        const int32_t echo_y = shaping_y.factor * (advance_dividend.y >> 7);
-      #endif
-
-      // plan the change of values for advance_dividend for the input shaping echoes
-      TERN_(INPUT_SHAPING, shaping_dividend_queue.enqueue(TERN0(HAS_SHAPING_X, echo_x), TERN0(HAS_SHAPING_Y, echo_y)));
-
-      // apply the adjustment to the primary signal
-      TERN_(HAS_SHAPING_X, advance_dividend.x -= echo_x);
-      TERN_(HAS_SHAPING_Y, advance_dividend.y -= echo_y);
+      #if ENABLED(INPUT_SHAPING_X)
+        if (shaping_x.enabled) {
+          const int64_t steps = TEST(current_block->direction_bits, X_AXIS) ? -int64_t(current_block->steps.x) : int64_t(current_block->steps.x);
+          shaping_x.last_block_end_pos += steps;
+
+          // If there are any remaining echos unprocessed, then direction change must
+          // be delayed and processed in PULSE_PREP_SHAPING. This will cause half a step
+          // to be missed, which will need recovering and this can be done through shaping_x.remainder.
+          shaping_x.forward = !TEST(current_block->direction_bits, X_AXIS);
+          if (!ShapingQueue::empty_x()) SET_BIT_TO(current_block->direction_bits, X_AXIS, TEST(last_direction_bits, X_AXIS));
+        }
+      #endif
+
+      // Y follows the same logic as X (but the comments aren't repeated)
+      #if ENABLED(INPUT_SHAPING_Y)
+        if (shaping_y.enabled) {
+          const int64_t steps = TEST(current_block->direction_bits, Y_AXIS) ? -int64_t(current_block->steps.y) : int64_t(current_block->steps.y);
+          shaping_y.last_block_end_pos += steps;
+          shaping_y.forward = !TEST(current_block->direction_bits, Y_AXIS);
+          if (!ShapingQueue::empty_y()) SET_BIT_TO(current_block->direction_bits, Y_AXIS, TEST(last_direction_bits, Y_AXIS));
+        }
+      #endif
 
       // No step events completed so far
       step_events_completed = 0;
 
       // Compute the acceleration and deceleration points
-      accelerate_until = current_block->accelerate_until << oversampling;
-      decelerate_after = current_block->decelerate_after << oversampling;
+      accelerate_until = current_block->accelerate_until << oversampling_factor;
+      decelerate_after = current_block->decelerate_after << oversampling_factor;
 
       TERN_(MIXING_EXTRUDER, mixer.stepper_setup(current_block->b_color));
 
@@ -2548,7 +2550,7 @@ uint32_t Stepper::block_phase_isr() {
         #endif
         if (current_block->la_advance_rate) {
           // apply LA scaling and discount the effect of frequency scaling
-          la_dividend = (advance_dividend.e << current_block->la_scaling) << oversampling;
+          la_dividend = (advance_dividend.e << current_block->la_scaling) << oversampling_factor;
         }
       #endif
 
@@ -2974,7 +2976,8 @@ void Stepper::init() {
   #endif
 }
 
-#if ENABLED(INPUT_SHAPING)
+#if HAS_SHAPING
+
   /**
    * Calculate a fixed point factor to apply to the signal and its echo
    * when shaping an axis.
@@ -2983,41 +2986,68 @@ void Stepper::init() {
     // from the damping ratio, get a factor that can be applied to advance_dividend for fixed point maths
     // for ZV, we use amplitudes 1/(1+K) and K/(1+K) where K = exp(-zeta * M_PI / sqrt(1.0f - zeta * zeta))
     // which can be converted to 1:7 fixed point with an excellent fit with a 3rd order polynomial
-    float shaping_factor;
-    if (zeta <= 0.0f) shaping_factor = 64.0f;
-    else if (zeta >= 1.0f) shaping_factor = 0.0f;
+    float factor2;
+    if (zeta <= 0.0f) factor2 = 64.0f;
+    else if (zeta >= 1.0f) factor2 = 0.0f;
     else {
-      shaping_factor = 64.44056192 + -99.02008832 * zeta;
+      factor2 = 64.44056192 + -99.02008832 * zeta;
       const float zeta2 = zeta * zeta;
-      shaping_factor += -7.58095488 * zeta2;
+      factor2 += -7.58095488 * zeta2;
       const float zeta3 = zeta2 * zeta;
-      shaping_factor += 43.073216 * zeta3;
+      factor2 += 43.073216 * zeta3;
+      factor2 = floor(factor2);
     }
 
     const bool was_on = hal.isr_state();
     hal.isr_off();
-    TERN_(HAS_SHAPING_X, if (axis == X_AXIS) { shaping_x.factor = floor(shaping_factor); shaping_x.zeta = zeta; })
-    TERN_(HAS_SHAPING_Y, if (axis == Y_AXIS) { shaping_y.factor = floor(shaping_factor); shaping_y.zeta = zeta; })
+    TERN_(INPUT_SHAPING_X, if (axis == X_AXIS) { shaping_x.factor2 = factor2; shaping_x.factor1 = 128 - factor2; shaping_x.zeta = zeta; })
+    TERN_(INPUT_SHAPING_Y, if (axis == Y_AXIS) { shaping_y.factor2 = factor2; shaping_y.factor1 = 128 - factor2; shaping_y.zeta = zeta; })
     if (was_on) hal.isr_on();
   }
 
   float Stepper::get_shaping_damping_ratio(const AxisEnum axis) {
-    TERN_(HAS_SHAPING_X, if (axis == X_AXIS) return shaping_x.zeta);
-    TERN_(HAS_SHAPING_Y, if (axis == Y_AXIS) return shaping_y.zeta);
+    TERN_(INPUT_SHAPING_X, if (axis == X_AXIS) return shaping_x.zeta);
+    TERN_(INPUT_SHAPING_Y, if (axis == Y_AXIS) return shaping_y.zeta);
     return -1;
   }
 
   void Stepper::set_shaping_frequency(const AxisEnum axis, const float freq) {
-    TERN_(HAS_SHAPING_X, if (axis == X_AXIS) { DelayTimeManager::set_delay(axis, float(uint32_t(STEPPER_TIMER_RATE) / 2) / freq); shaping_x.frequency = freq; })
-    TERN_(HAS_SHAPING_Y, if (axis == Y_AXIS) { DelayTimeManager::set_delay(axis, float(uint32_t(STEPPER_TIMER_RATE) / 2) / freq); shaping_y.frequency = freq; })
+    // enabling or disabling shaping whilst moving can result in lost steps
+    Planner::synchronize();
+
+    const bool was_on = hal.isr_state();
+    hal.isr_off();
+
+    const shaping_time_t delay = freq ? float(uint32_t(STEPPER_TIMER_RATE) / 2) / freq : shaping_time_t(-1);
+    #if ENABLED(INPUT_SHAPING_X)
+      if (axis == X_AXIS) {
+        ShapingQueue::set_delay(X_AXIS, delay);
+        shaping_x.frequency = freq;
+        shaping_x.enabled = !!freq;
+        shaping_x.delta_error = 0;
+        shaping_x.last_block_end_pos = count_position.x;
+      }
+    #endif
+    #if ENABLED(INPUT_SHAPING_Y)
+      if (axis == Y_AXIS) {
+        ShapingQueue::set_delay(Y_AXIS, delay);
+        shaping_y.frequency = freq;
+        shaping_y.enabled = !!freq;
+        shaping_y.delta_error = 0;
+        shaping_y.last_block_end_pos = count_position.y;
+      }
+    #endif
+
+    if (was_on) hal.isr_on();
   }
 
   float Stepper::get_shaping_frequency(const AxisEnum axis) {
-    TERN_(HAS_SHAPING_X, if (axis == X_AXIS) return shaping_x.frequency);
-    TERN_(HAS_SHAPING_Y, if (axis == Y_AXIS) return shaping_y.frequency);
+    TERN_(INPUT_SHAPING_X, if (axis == X_AXIS) return shaping_x.frequency);
+    TERN_(INPUT_SHAPING_Y, if (axis == Y_AXIS) return shaping_y.frequency);
     return -1;
   }
-#endif
+
+#endif // HAS_SHAPING
 
 /**
  * Set the stepper positions directly in steps
@@ -3029,6 +3059,13 @@ void Stepper::init() {
  * derive the current XYZE position later on.
  */
 void Stepper::_set_position(const abce_long_t &spos) {
+  #if ENABLED(INPUT_SHAPING_X)
+    const int32_t x_shaping_delta = count_position.x - shaping_x.last_block_end_pos;
+  #endif
+  #if ENABLED(INPUT_SHAPING_Y)
+    const int32_t y_shaping_delta = count_position.y - shaping_y.last_block_end_pos;
+  #endif
+
   #if ANY(IS_CORE, MARKFORGED_XY, MARKFORGED_YX)
     #if CORE_IS_XY
       // corexy positioning
@@ -3058,6 +3095,19 @@ void Stepper::_set_position(const abce_long_t &spos) {
     // default non-h-bot planning
     count_position = spos;
   #endif
+
+  #if ENABLED(INPUT_SHAPING_X)
+    if (shaping_x.enabled) {
+      count_position.x += x_shaping_delta;
+      shaping_x.last_block_end_pos = spos.x;
+    }
+  #endif
+  #if ENABLED(INPUT_SHAPING_Y)
+    if (shaping_y.enabled) {
+      count_position.y += y_shaping_delta;
+      shaping_y.last_block_end_pos = spos.y;
+    }
+  #endif
 }
 
 /**
@@ -3097,6 +3147,8 @@ void Stepper::set_axis_position(const AxisEnum a, const int32_t &v) {
   #endif
 
   count_position[a] = v;
+  TERN_(INPUT_SHAPING_X, if (a == X_AXIS) shaping_x.last_block_end_pos = v);
+  TERN_(INPUT_SHAPING_Y, if (a == Y_AXIS) shaping_y.last_block_end_pos = v);
 
   #ifdef __AVR__
     // Reenable Stepper ISR

commit a460b01c876ff39901fe55a4b66b2c62737ef46c
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Oct 21 22:34:22 2022 +0100

    🚀 ZV Input Shaping (#24797)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4ee4c1d1a7..6cc40ccece 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -199,7 +199,7 @@ IF_DISABLED(ADAPTIVE_STEP_SMOOTHING, constexpr) uint8_t Stepper::oversampling_fa
 
 xyze_long_t Stepper::delta_error{0};
 
-xyze_ulong_t Stepper::advance_dividend{0};
+xyze_long_t Stepper::advance_dividend{0};
 uint32_t Stepper::advance_divisor = 0,
          Stepper::step_events_completed = 0, // The number of step events executed in the current block
          Stepper::accelerate_until,          // The count at which to stop accelerating
@@ -232,6 +232,20 @@ uint32_t Stepper::advance_divisor = 0,
            Stepper::la_advance_steps = 0;
 #endif
 
+#if ENABLED(INPUT_SHAPING)
+  shaping_time_t                DelayTimeManager::now = 0;
+  ParamDelayQueue               Stepper::shaping_dividend_queue;
+  DelayQueue<shaping_dividends> Stepper::shaping_queue;
+  #if HAS_SHAPING_X
+    shaping_time_t DelayTimeManager::delay_x;
+    ShapeParams Stepper::shaping_x;
+  #endif
+  #if HAS_SHAPING_Y
+    shaping_time_t DelayTimeManager::delay_y;
+    ShapeParams Stepper::shaping_y;
+  #endif
+#endif
+
 #if ENABLED(INTEGRATED_BABYSTEPPING)
   uint32_t Stepper::nextBabystepISR = BABYSTEP_NEVER;
 #endif
@@ -458,12 +472,10 @@ xyze_int8_t Stepper::count_direction{0};
 #define PULSE_LOW_TICK_COUNT hal_timer_t(NS_TO_PULSE_TIMER_TICKS(_MIN_PULSE_LOW_NS - _MIN(_MIN_PULSE_LOW_NS, TIMER_SETUP_NS)))
 
 #define USING_TIMED_PULSE() hal_timer_t start_pulse_count = 0
-#define START_TIMED_PULSE(DIR) (start_pulse_count = HAL_timer_get_count(MF_TIMER_PULSE))
-#define AWAIT_TIMED_PULSE(DIR) while (PULSE_##DIR##_TICK_COUNT > HAL_timer_get_count(MF_TIMER_PULSE) - start_pulse_count) { }
-#define START_HIGH_PULSE()  START_TIMED_PULSE(HIGH)
-#define AWAIT_HIGH_PULSE()  AWAIT_TIMED_PULSE(HIGH)
-#define START_LOW_PULSE()   START_TIMED_PULSE(LOW)
-#define AWAIT_LOW_PULSE()   AWAIT_TIMED_PULSE(LOW)
+#define START_TIMED_PULSE() (start_pulse_count = HAL_timer_get_count(MF_TIMER_PULSE))
+#define AWAIT_TIMED_PULSE(DIR) while (PULSE_##DIR##_TICK_COUNT > HAL_timer_get_count(MF_TIMER_PULSE) - start_pulse_count) { /* nada */ }
+#define AWAIT_HIGH_PULSE() AWAIT_TIMED_PULSE(HIGH)
+#define AWAIT_LOW_PULSE()  AWAIT_TIMED_PULSE(LOW)
 
 #if MINIMUM_STEPPER_PRE_DIR_DELAY > 0
   #define DIR_WAIT_BEFORE() DELAY_NS(MINIMUM_STEPPER_PRE_DIR_DELAY)
@@ -559,6 +571,16 @@ void Stepper::disable_all_steppers() {
   TERN_(EXTENSIBLE_UI, ExtUI::onSteppersDisabled());
 }
 
+#define SET_STEP_DIR(A)                       \
+  if (motor_direction(_AXIS(A))) {            \
+    A##_APPLY_DIR(INVERT_##A##_DIR, false);   \
+    count_direction[_AXIS(A)] = -1;           \
+  }                                           \
+  else {                                      \
+    A##_APPLY_DIR(!INVERT_##A##_DIR, false);  \
+    count_direction[_AXIS(A)] = 1;            \
+  }
+
 /**
  * Set the stepper direction of each axis
  *
@@ -570,16 +592,6 @@ void Stepper::set_directions() {
 
   DIR_WAIT_BEFORE();
 
-  #define SET_STEP_DIR(A)                       \
-    if (motor_direction(_AXIS(A))) {            \
-      A##_APPLY_DIR(INVERT_##A##_DIR, false);   \
-      count_direction[_AXIS(A)] = -1;           \
-    }                                           \
-    else {                                      \
-      A##_APPLY_DIR(!INVERT_##A##_DIR, false);  \
-      count_direction[_AXIS(A)] = 1;            \
-    }
-
   TERN_(HAS_X_DIR, SET_STEP_DIR(X)); // A
   TERN_(HAS_Y_DIR, SET_STEP_DIR(Y)); // B
   TERN_(HAS_Z_DIR, SET_STEP_DIR(Z)); // C
@@ -1467,8 +1479,20 @@ void Stepper::isr() {
     // Enable ISRs to reduce USART processing latency
     hal.isr_on();
 
+    #if ENABLED(INPUT_SHAPING)
+      // Speed limiting should ensure the buffers never get full. But if somehow they do, stutter rather than overflow.
+      if (!nextMainISR) {
+        TERN_(HAS_SHAPING_X, if (shaping_dividend_queue.free_count_x() == 0) nextMainISR = shaping_dividend_queue.peek_x() + 1);
+        TERN_(HAS_SHAPING_Y, if (shaping_dividend_queue.free_count_y() == 0) NOLESS(nextMainISR, shaping_dividend_queue.peek_y() + 1));
+        TERN_(HAS_SHAPING_X, if (shaping_queue.free_count_x() < steps_per_isr) NOLESS(nextMainISR, shaping_queue.peek_x() + 1));
+        TERN_(HAS_SHAPING_Y, if (shaping_queue.free_count_y() < steps_per_isr) NOLESS(nextMainISR, shaping_queue.peek_y() + 1));
+      }
+    #endif
+
     if (!nextMainISR) pulse_phase_isr();                // 0 = Do coordinated axes Stepper pulses
 
+    TERN_(INPUT_SHAPING, shaping_isr());                // Do Shaper stepping, if needed
+
     #if ENABLED(LIN_ADVANCE)
       if (!nextAdvanceISR) {                            // 0 = Do Linear Advance E Stepper pulses
         advance_isr();
@@ -1497,10 +1521,14 @@ void Stepper::isr() {
 
     // Get the interval to the next ISR call
     const uint32_t interval = _MIN(
-      uint32_t(HAL_TIMER_TYPE_MAX),                     // Come back in a very long time
-      nextMainISR                                       // Time until the next Pulse / Block phase
-      OPTARG(LIN_ADVANCE, nextAdvanceISR)               // Come back early for Linear Advance?
-      OPTARG(INTEGRATED_BABYSTEPPING, nextBabystepISR)  // Come back early for Babystepping?
+      uint32_t(HAL_TIMER_TYPE_MAX),                           // Come back in a very long time
+      nextMainISR                                             // Time until the next Pulse / Block phase
+      OPTARG(HAS_SHAPING_X, shaping_dividend_queue.peek_x())  // Time until next input shaping dividend change for X
+      OPTARG(HAS_SHAPING_Y, shaping_dividend_queue.peek_y())  // Time until next input shaping dividend change for Y
+      OPTARG(HAS_SHAPING_X, shaping_queue.peek_x())           // Time until next input shaping echo for X
+      OPTARG(HAS_SHAPING_Y, shaping_queue.peek_y())           // Time until next input shaping echo for Y
+      OPTARG(LIN_ADVANCE, nextAdvanceISR)                     // Come back early for Linear Advance?
+      OPTARG(INTEGRATED_BABYSTEPPING, nextBabystepISR)        // Come back early for Babystepping?
     );
 
     //
@@ -1512,6 +1540,8 @@ void Stepper::isr() {
 
     nextMainISR -= interval;
 
+    TERN_(INPUT_SHAPING, DelayTimeManager::decrement_delays(interval));
+
     #if ENABLED(LIN_ADVANCE)
       if (nextAdvanceISR != LA_ADV_NEVER) nextAdvanceISR -= interval;
     #endif
@@ -1604,11 +1634,19 @@ void Stepper::pulse_phase_isr() {
   // If we must abort the current block, do so!
   if (abort_current_block) {
     abort_current_block = false;
-    if (current_block) discard_current_block();
+    if (current_block) {
+      discard_current_block();
+      #if ENABLED(INPUT_SHAPING)
+        shaping_dividend_queue.purge();
+        shaping_queue.purge();
+        TERN_(HAS_SHAPING_X, delta_error.x = 0);
+        TERN_(HAS_SHAPING_Y, delta_error.y = 0);
+      #endif
+    }
   }
 
   // If there is no current block, do nothing
-  if (!current_block) return;
+  if (!current_block || step_events_completed >= step_event_count) return;
 
   // Skipping step processing causes motion to freeze
   if (TERN0(FREEZE_FEATURE, frozen)) return;
@@ -1627,6 +1665,9 @@ void Stepper::pulse_phase_isr() {
   #endif
   xyze_bool_t step_needed{0};
 
+  // Direct Stepping page?
+  const bool is_page = current_block->is_page();
+
   do {
     #define _APPLY_STEP(AXIS, INV, ALWAYS) AXIS ##_APPLY_STEP(INV, ALWAYS)
     #define _INVERT_STEP_PIN(AXIS) INVERT_## AXIS ##_STEP_PIN
@@ -1641,6 +1682,22 @@ void Stepper::pulse_phase_isr() {
       } \
     }while(0)
 
+    #define PULSE_PREP_SHAPING(AXIS, DIVIDEND) do{ \
+      delta_error[_AXIS(AXIS)] += (DIVIDEND); \
+      if ((MAXDIR(AXIS) && delta_error[_AXIS(AXIS)] <= -0x30000000L) || (MINDIR(AXIS) && delta_error[_AXIS(AXIS)] >= 0x30000000L)) { \
+        TBI(last_direction_bits, _AXIS(AXIS)); \
+        DIR_WAIT_BEFORE(); \
+        SET_STEP_DIR(AXIS); \
+        DIR_WAIT_AFTER(); \
+      } \
+      step_needed[_AXIS(AXIS)] = (MAXDIR(AXIS) && delta_error[_AXIS(AXIS)] >= 0x10000000L) || \
+                                 (MINDIR(AXIS) && delta_error[_AXIS(AXIS)] <= -0x10000000L); \
+      if (step_needed[_AXIS(AXIS)]) { \
+        count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \
+        delta_error[_AXIS(AXIS)] += MAXDIR(AXIS) ? -0x20000000L : 0x20000000L; \
+      } \
+    }while(0)
+
     // Start an active pulse if needed
     #define PULSE_START(AXIS) do{ \
       if (step_needed[_AXIS(AXIS)]) { \
@@ -1655,9 +1712,6 @@ void Stepper::pulse_phase_isr() {
       } \
     }while(0)
 
-    // Direct Stepping page?
-    const bool is_page = current_block->is_page();
-
     #if ENABLED(DIRECT_STEPPING)
       // Direct stepping is currently not ready for HAS_I_AXIS
       if (is_page) {
@@ -1765,12 +1819,22 @@ void Stepper::pulse_phase_isr() {
     #endif // DIRECT_STEPPING
 
     if (!is_page) {
+      TERN_(INPUT_SHAPING, shaping_queue.enqueue());
+
       // Determine if pulses are needed
       #if HAS_X_STEP
-        PULSE_PREP(X);
+        #if HAS_SHAPING_X
+          PULSE_PREP_SHAPING(X, advance_dividend.x);
+        #else
+          PULSE_PREP(X);
+        #endif
       #endif
       #if HAS_Y_STEP
-        PULSE_PREP(Y);
+        #if HAS_SHAPING_Y
+          PULSE_PREP_SHAPING(Y, advance_dividend.y);
+        #else
+          PULSE_PREP(Y);
+        #endif
       #endif
       #if HAS_Z_STEP
         PULSE_PREP(Z);
@@ -1855,7 +1919,7 @@ void Stepper::pulse_phase_isr() {
 
     // TODO: need to deal with MINIMUM_STEPPER_PULSE over i2s
     #if ISR_MULTI_STEPS
-      START_HIGH_PULSE();
+      START_TIMED_PULSE();
       AWAIT_HIGH_PULSE();
     #endif
 
@@ -1895,12 +1959,62 @@ void Stepper::pulse_phase_isr() {
     #endif
 
     #if ISR_MULTI_STEPS
-      if (events_to_do) START_LOW_PULSE();
+      if (events_to_do) START_TIMED_PULSE();
     #endif
 
   } while (--events_to_do);
 }
 
+#if ENABLED(INPUT_SHAPING)
+
+  void Stepper::shaping_isr() {
+    xyze_bool_t step_needed{0};
+
+    const bool shapex = TERN0(HAS_SHAPING_X, !shaping_queue.peek_x()),
+               shapey = TERN0(HAS_SHAPING_Y, !shaping_queue.peek_y());
+
+    #if HAS_SHAPING_X
+      if (!shaping_dividend_queue.peek_x()) shaping_x.dividend = shaping_dividend_queue.dequeue_x();
+    #endif
+    #if HAS_SHAPING_Y
+      if (!shaping_dividend_queue.peek_y()) shaping_y.dividend = shaping_dividend_queue.dequeue_y();
+    #endif
+
+    #if HAS_SHAPING_X
+      if (shapex) {
+        shaping_queue.dequeue_x();
+        PULSE_PREP_SHAPING(X, shaping_x.dividend);
+        PULSE_START(X);
+      }
+    #endif
+
+    #if HAS_SHAPING_Y
+      if (shapey) {
+        shaping_queue.dequeue_y();
+        PULSE_PREP_SHAPING(Y, shaping_y.dividend);
+        PULSE_START(Y);
+      }
+    #endif
+
+    TERN_(I2S_STEPPER_STREAM, i2s_push_sample());
+
+    if (shapex || shapey) {
+      #if ISR_MULTI_STEPS
+        USING_TIMED_PULSE();
+        START_TIMED_PULSE();
+        AWAIT_HIGH_PULSE();
+      #endif
+      #if HAS_SHAPING_X
+        if (shapex) PULSE_STOP(X);
+      #endif
+      #if HAS_SHAPING_Y
+        if (shapey) PULSE_STOP(Y);
+      #endif
+    }
+  }
+
+#endif // INPUT_SHAPING
+
 // Calculate timer interval, with all limits applied.
 uint32_t Stepper::calc_timer_interval(uint32_t step_rate) {
   #ifdef CPU_32_BIT
@@ -2365,12 +2479,56 @@ uint32_t Stepper::block_phase_isr() {
       step_event_count = current_block->step_event_count << oversampling;
 
       // Initialize Bresenham delta errors to 1/2
+      #if HAS_SHAPING_X
+        const int32_t old_delta_error_x = delta_error.x;
+      #endif
+      #if HAS_SHAPING_Y
+        const int32_t old_delta_error_y = delta_error.y;
+      #endif
       delta_error = TERN_(LIN_ADVANCE, la_delta_error =) -int32_t(step_event_count);
 
       // Calculate Bresenham dividends and divisors
-      advance_dividend = current_block->steps << 1;
+      advance_dividend = (current_block->steps << 1).asLong();
       advance_divisor = step_event_count << 1;
 
+      // for input shaped axes, advance_divisor is replaced with 0x40000000
+      // and steps are repeated twice so dividends have to be scaled and halved
+      // and the dividend is directional, i.e. signed
+      TERN_(HAS_SHAPING_X, advance_dividend.x = (uint64_t(current_block->steps.x) << 29) / step_event_count);
+      TERN_(HAS_SHAPING_X, if (TEST(current_block->direction_bits, X_AXIS)) advance_dividend.x *= -1);
+      TERN_(HAS_SHAPING_X, if (!shaping_queue.empty_x()) SET_BIT_TO(current_block->direction_bits, X_AXIS, TEST(last_direction_bits, X_AXIS)));
+      TERN_(HAS_SHAPING_Y, advance_dividend.y = (uint64_t(current_block->steps.y) << 29) / step_event_count);
+      TERN_(HAS_SHAPING_Y, if (TEST(current_block->direction_bits, Y_AXIS)) advance_dividend.y *= -1);
+      TERN_(HAS_SHAPING_Y, if (!shaping_queue.empty_y()) SET_BIT_TO(current_block->direction_bits, Y_AXIS, TEST(last_direction_bits, Y_AXIS)));
+
+      // The scaling operation above introduces rounding errors which must now be removed.
+      // For this segment, there will be step_event_count calls to the Bresenham logic and the same number of echoes.
+      // For each pair of calls to the Bresenham logic, delta_error will increase by advance_dividend modulo 0x20000000
+      // so (e.g. for x) delta_error.x will end up changing by (advance_dividend.x * step_event_count) % 0x20000000.
+      // For a divisor which is a power of 2, modulo is the same as as a bitmask, i.e.
+      // (advance_dividend.x * step_event_count) & 0x1FFFFFFF.
+      // This segment's final change in delta_error should actually be zero so we need to increase delta_error by
+      // 0 - ((advance_dividend.x * step_event_count) & 0x1FFFFFFF)
+      // And this needs to be adjusted to the range -0x10000000 to 0x10000000.
+      // Adding and subtracting 0x10000000 inside the outside the modulo achieves this.
+      TERN_(HAS_SHAPING_X, delta_error.x = old_delta_error_x + 0x10000000L - ((0x10000000L + advance_dividend.x * step_event_count) & 0x1FFFFFFFUL));
+      TERN_(HAS_SHAPING_Y, delta_error.y = old_delta_error_y + 0x10000000L - ((0x10000000L + advance_dividend.y * step_event_count) & 0x1FFFFFFFUL));
+
+      // when there is damping, the signal and its echo have different amplitudes
+      #if ENABLED(HAS_SHAPING_X)
+        const int32_t echo_x = shaping_x.factor * (advance_dividend.x >> 7);
+      #endif
+      #if ENABLED(HAS_SHAPING_Y)
+        const int32_t echo_y = shaping_y.factor * (advance_dividend.y >> 7);
+      #endif
+
+      // plan the change of values for advance_dividend for the input shaping echoes
+      TERN_(INPUT_SHAPING, shaping_dividend_queue.enqueue(TERN0(HAS_SHAPING_X, echo_x), TERN0(HAS_SHAPING_Y, echo_y)));
+
+      // apply the adjustment to the primary signal
+      TERN_(HAS_SHAPING_X, advance_dividend.x -= echo_x);
+      TERN_(HAS_SHAPING_Y, advance_dividend.y -= echo_y);
+
       // No step events completed so far
       step_events_completed = 0;
 
@@ -2485,7 +2643,7 @@ uint32_t Stepper::block_phase_isr() {
       // Enforce a minimum duration for STEP pulse ON
       #if ISR_PULSE_CONTROL
         USING_TIMED_PULSE();
-        START_HIGH_PULSE();
+        START_TIMED_PULSE();
         AWAIT_HIGH_PULSE();
       #endif
 
@@ -2816,6 +2974,51 @@ void Stepper::init() {
   #endif
 }
 
+#if ENABLED(INPUT_SHAPING)
+  /**
+   * Calculate a fixed point factor to apply to the signal and its echo
+   * when shaping an axis.
+   */
+  void Stepper::set_shaping_damping_ratio(const AxisEnum axis, const float zeta) {
+    // from the damping ratio, get a factor that can be applied to advance_dividend for fixed point maths
+    // for ZV, we use amplitudes 1/(1+K) and K/(1+K) where K = exp(-zeta * M_PI / sqrt(1.0f - zeta * zeta))
+    // which can be converted to 1:7 fixed point with an excellent fit with a 3rd order polynomial
+    float shaping_factor;
+    if (zeta <= 0.0f) shaping_factor = 64.0f;
+    else if (zeta >= 1.0f) shaping_factor = 0.0f;
+    else {
+      shaping_factor = 64.44056192 + -99.02008832 * zeta;
+      const float zeta2 = zeta * zeta;
+      shaping_factor += -7.58095488 * zeta2;
+      const float zeta3 = zeta2 * zeta;
+      shaping_factor += 43.073216 * zeta3;
+    }
+
+    const bool was_on = hal.isr_state();
+    hal.isr_off();
+    TERN_(HAS_SHAPING_X, if (axis == X_AXIS) { shaping_x.factor = floor(shaping_factor); shaping_x.zeta = zeta; })
+    TERN_(HAS_SHAPING_Y, if (axis == Y_AXIS) { shaping_y.factor = floor(shaping_factor); shaping_y.zeta = zeta; })
+    if (was_on) hal.isr_on();
+  }
+
+  float Stepper::get_shaping_damping_ratio(const AxisEnum axis) {
+    TERN_(HAS_SHAPING_X, if (axis == X_AXIS) return shaping_x.zeta);
+    TERN_(HAS_SHAPING_Y, if (axis == Y_AXIS) return shaping_y.zeta);
+    return -1;
+  }
+
+  void Stepper::set_shaping_frequency(const AxisEnum axis, const float freq) {
+    TERN_(HAS_SHAPING_X, if (axis == X_AXIS) { DelayTimeManager::set_delay(axis, float(uint32_t(STEPPER_TIMER_RATE) / 2) / freq); shaping_x.frequency = freq; })
+    TERN_(HAS_SHAPING_Y, if (axis == Y_AXIS) { DelayTimeManager::set_delay(axis, float(uint32_t(STEPPER_TIMER_RATE) / 2) / freq); shaping_y.frequency = freq; })
+  }
+
+  float Stepper::get_shaping_frequency(const AxisEnum axis) {
+    TERN_(HAS_SHAPING_X, if (axis == X_AXIS) return shaping_x.frequency);
+    TERN_(HAS_SHAPING_Y, if (axis == Y_AXIS) return shaping_y.frequency);
+    return -1;
+  }
+#endif
+
 /**
  * Set the stepper positions directly in steps
  *
@@ -3021,7 +3224,7 @@ void Stepper::report_positions() {
 
   #if EXTRA_CYCLES_BABYSTEP > 20
     #define _SAVE_START() const hal_timer_t pulse_start = HAL_timer_get_count(MF_TIMER_PULSE)
-    #define _PULSE_WAIT() while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(HAL_timer_get_count(MF_TIMER_PULSE) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
+    #define _PULSE_WAIT() while (EXTRA_CYCLES_BABYSTEP > uint32_t(HAL_timer_get_count(MF_TIMER_PULSE) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
   #else
     #define _SAVE_START() NOOP
     #if EXTRA_CYCLES_BABYSTEP > 0

commit 4f9ba7e9915b0f288998fccc36798ecdc2525309
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 6 23:03:15 2022 -0500

    🧑‍💻 Microsteps to stepper.cpp

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index ef1e1f82cb..4ee4c1d1a7 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3859,30 +3859,53 @@ void Stepper::report_positions() {
     }
   }
 
+  // MS1 MS2 MS3 Stepper Driver Microstepping mode table
+  #ifndef MICROSTEP1
+    #define MICROSTEP1 LOW,LOW,LOW
+  #endif
+  #if ENABLED(HEROIC_STEPPER_DRIVERS)
+    #ifndef MICROSTEP128
+      #define MICROSTEP128 LOW,HIGH,LOW
+    #endif
+  #else
+    #ifndef MICROSTEP2
+      #define MICROSTEP2 HIGH,LOW,LOW
+    #endif
+    #ifndef MICROSTEP4
+      #define MICROSTEP4 LOW,HIGH,LOW
+    #endif
+  #endif
+  #ifndef MICROSTEP8
+    #define MICROSTEP8 HIGH,HIGH,LOW
+  #endif
+  #ifndef MICROSTEP16
+    #define MICROSTEP16 HIGH,HIGH,LOW
+  #endif
+
   void Stepper::microstep_mode(const uint8_t driver, const uint8_t stepping_mode) {
     switch (stepping_mode) {
-      #if HAS_MICROSTEP1
+      #ifdef MICROSTEP1
         case 1: microstep_ms(driver, MICROSTEP1); break;
       #endif
-      #if HAS_MICROSTEP2
+      #ifdef MICROSTEP2
         case 2: microstep_ms(driver, MICROSTEP2); break;
       #endif
-      #if HAS_MICROSTEP4
+      #ifdef MICROSTEP4
         case 4: microstep_ms(driver, MICROSTEP4); break;
       #endif
-      #if HAS_MICROSTEP8
+      #ifdef MICROSTEP8
         case 8: microstep_ms(driver, MICROSTEP8); break;
       #endif
-      #if HAS_MICROSTEP16
+      #ifdef MICROSTEP16
         case 16: microstep_ms(driver, MICROSTEP16); break;
       #endif
-      #if HAS_MICROSTEP32
+      #ifdef MICROSTEP32
         case 32: microstep_ms(driver, MICROSTEP32); break;
       #endif
-      #if HAS_MICROSTEP64
+      #ifdef MICROSTEP64
         case 64: microstep_ms(driver, MICROSTEP64); break;
       #endif
-      #if HAS_MICROSTEP128
+      #ifdef MICROSTEP128
         case 128: microstep_ms(driver, MICROSTEP128); break;
       #endif
 

commit 8e71f7add45782f17ce485c6a2bd9004edac156c
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Sep 2 03:04:46 2022 +0100

    ✨ Permit Linear Advance with I2S Streaming (#24684)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index beea674ced..ef1e1f82cb 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -137,6 +137,10 @@ Stepper stepper; // Singleton
   #include "../lcd/extui/ui_api.h"
 #endif
 
+#if ENABLED(I2S_STEPPER_STREAM)
+  #include "../HAL/ESP32/i2s.h"
+#endif
+
 // public:
 
 #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
@@ -1558,14 +1562,7 @@ void Stepper::isr() {
      * On AVR the ISR epilogue+prologue is estimated at 100 instructions - Give 8µs as margin
      * On ARM the ISR epilogue+prologue is estimated at 20 instructions - Give 1µs as margin
      */
-    min_ticks = HAL_timer_get_count(MF_TIMER_STEP) + hal_timer_t(
-      #ifdef __AVR__
-        8
-      #else
-        1
-      #endif
-      * (STEPPER_TIMER_TICKS_PER_US)
-    );
+    min_ticks = HAL_timer_get_count(MF_TIMER_STEP) + hal_timer_t(TERN(__AVR__, 8, 1) * (STEPPER_TIMER_TICKS_PER_US));
 
     /**
      * NB: If for some reason the stepper monopolizes the MPU, eventually the
@@ -2472,18 +2469,19 @@ uint32_t Stepper::block_phase_isr() {
     // the acceleration and speed values calculated in block_phase_isr().
     // This helps keep LA in sync with, for example, S_CURVE_ACCELERATION.
     la_delta_error += la_dividend;
-    if (la_delta_error >= 0) {
+    const bool step_needed = la_delta_error >= 0;
+    if (step_needed) {
       count_position.e += count_direction.e;
       la_advance_steps += count_direction.e;
       la_delta_error -= advance_divisor;
 
       // Set the STEP pulse ON
-      #if ENABLED(MIXING_EXTRUDER)
-        E_STEP_WRITE(mixer.get_next_stepper(), !INVERT_E_STEP_PIN);
-      #else
-        E_STEP_WRITE(stepper_extruder, !INVERT_E_STEP_PIN);
-      #endif
+      E_STEP_WRITE(TERN(MIXING_EXTRUDER, mixer.get_next_stepper(), stepper_extruder), !INVERT_E_STEP_PIN);
+    }
+
+    TERN_(I2S_STEPPER_STREAM, i2s_push_sample());
 
+    if (step_needed) {
       // Enforce a minimum duration for STEP pulse ON
       #if ISR_PULSE_CONTROL
         USING_TIMED_PULSE();
@@ -2492,11 +2490,7 @@ uint32_t Stepper::block_phase_isr() {
       #endif
 
       // Set the STEP pulse OFF
-      #if ENABLED(MIXING_EXTRUDER)
-        E_STEP_WRITE(mixer.get_stepper(), INVERT_E_STEP_PIN);
-      #else
-        E_STEP_WRITE(stepper_extruder, INVERT_E_STEP_PIN);
-      #endif
+      E_STEP_WRITE(TERN(MIXING_EXTRUDER, mixer.get_stepper(), stepper_extruder), INVERT_E_STEP_PIN);
     }
   }
 

commit 83320f1052dd09bff7aae789372e7bffccbced97
Author: Mark <niujl123@sina.com>
Date:   Sat Aug 6 14:14:58 2022 +0800

    ✨ Bed Distance Sensor (#24554)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b759d97098..beea674ced 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -97,6 +97,10 @@ Stepper stepper; // Singleton
 #include "../MarlinCore.h"
 #include "../HAL/shared/Delay.h"
 
+#if ENABLED(BD_SENSOR)
+  #include "../feature/bedlevel/bdl/bdl.h"
+#endif
+
 #if ENABLED(INTEGRATED_BABYSTEPPING)
   #include "../feature/babystep.h"
 #endif

commit 1c4fc4603a924b80361864044ab5f4ca13daff19
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 4 01:17:10 2022 -0500

    🩹 Fix Malyan M300 with S-Curve compile
    
    Fixes #24548

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index cac2161a47..b759d97098 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1345,7 +1345,7 @@ void Stepper::set_directions() {
     }
 
     FORCE_INLINE int32_t Stepper::_eval_bezier_curve(const uint32_t curr_step) {
-      #if (defined(__arm__) || defined(__thumb__)) && !defined(STM32G0B1xx) // TODO: Test define STM32G0xx versus STM32G0B1xx
+      #if (defined(__arm__) || defined(__thumb__)) && __ARM_ARCH >= 6 && !defined(STM32G0B1xx) // TODO: Test define STM32G0xx versus STM32G0B1xx
 
         // For ARM Cortex M3/M4 CPUs, we have the optimized assembler version, that takes 43 cycles to execute
         uint32_t flo = 0;

commit 232a104a927988c63f8c0c53a8c2e26005166e2d
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sun Jul 31 03:39:48 2022 +0100

    Fix, improve Linear Advance (#24533)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b7fd918561..cac2161a47 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -217,18 +217,12 @@ uint32_t Stepper::advance_divisor = 0,
 #endif
 
 #if ENABLED(LIN_ADVANCE)
-
   uint32_t Stepper::nextAdvanceISR = LA_ADV_NEVER,
-           Stepper::LA_isr_rate = LA_ADV_NEVER;
-  uint16_t Stepper::LA_current_adv_steps = 0,
-           Stepper::LA_final_adv_steps,
-           Stepper::LA_max_adv_steps;
-
-  int8_t   Stepper::LA_steps = 0;
-
-  bool Stepper::LA_use_advance_lead;
-
-#endif // LIN_ADVANCE
+           Stepper::la_interval = LA_ADV_NEVER;
+  int32_t  Stepper::la_delta_error = 0,
+           Stepper::la_dividend = 0,
+           Stepper::la_advance_steps = 0;
+#endif
 
 #if ENABLED(INTEGRATED_BABYSTEPPING)
   uint32_t Stepper::nextBabystepISR = BABYSTEP_NEVER;
@@ -588,29 +582,27 @@ void Stepper::set_directions() {
   TERN_(HAS_V_DIR, SET_STEP_DIR(V));
   TERN_(HAS_W_DIR, SET_STEP_DIR(W));
 
-  #if DISABLED(LIN_ADVANCE)
-    #if ENABLED(MIXING_EXTRUDER)
-       // Because this is valid for the whole block we don't know
-       // what E steppers will step. Likely all. Set all.
-      if (motor_direction(E_AXIS)) {
-        MIXER_STEPPER_LOOP(j) REV_E_DIR(j);
-        count_direction.e = -1;
-      }
-      else {
-        MIXER_STEPPER_LOOP(j) NORM_E_DIR(j);
-        count_direction.e = 1;
-      }
-    #elif HAS_EXTRUDERS
-      if (motor_direction(E_AXIS)) {
-        REV_E_DIR(stepper_extruder);
-        count_direction.e = -1;
-      }
-      else {
-        NORM_E_DIR(stepper_extruder);
-        count_direction.e = 1;
-      }
-    #endif
-  #endif // !LIN_ADVANCE
+  #if ENABLED(MIXING_EXTRUDER)
+     // Because this is valid for the whole block we don't know
+     // what E steppers will step. Likely all. Set all.
+    if (motor_direction(E_AXIS)) {
+      MIXER_STEPPER_LOOP(j) REV_E_DIR(j);
+      count_direction.e = -1;
+    }
+    else {
+      MIXER_STEPPER_LOOP(j) NORM_E_DIR(j);
+      count_direction.e = 1;
+    }
+  #elif HAS_EXTRUDERS
+    if (motor_direction(E_AXIS)) {
+      REV_E_DIR(stepper_extruder);
+      count_direction.e = -1;
+    }
+    else {
+      NORM_E_DIR(stepper_extruder);
+      count_direction.e = 1;
+    }
+  #endif
 
   DIR_WAIT_AFTER();
 }
@@ -1467,14 +1459,19 @@ void Stepper::isr() {
     // Enable ISRs to reduce USART processing latency
     hal.isr_on();
 
-    if (!nextMainISR) pulse_phase_isr();                    // 0 = Do coordinated axes Stepper pulses
+    if (!nextMainISR) pulse_phase_isr();                // 0 = Do coordinated axes Stepper pulses
 
     #if ENABLED(LIN_ADVANCE)
-      if (!nextAdvanceISR) nextAdvanceISR = advance_isr();  // 0 = Do Linear Advance E Stepper pulses
+      if (!nextAdvanceISR) {                            // 0 = Do Linear Advance E Stepper pulses
+        advance_isr();
+        nextAdvanceISR = la_interval;
+      }
+      else if (nextAdvanceISR == LA_ADV_NEVER)          // Start LA steps if necessary
+        nextAdvanceISR = la_interval;
     #endif
 
     #if ENABLED(INTEGRATED_BABYSTEPPING)
-      const bool is_babystep = (nextBabystepISR == 0);      // 0 = Do Babystepping (XY)Z pulses
+      const bool is_babystep = (nextBabystepISR == 0);  // 0 = Do Babystepping (XY)Z pulses
       if (is_babystep) nextBabystepISR = babystepping_isr();
     #endif
 
@@ -1796,20 +1793,18 @@ void Stepper::pulse_phase_isr() {
         PULSE_PREP(W);
       #endif
 
-      #if EITHER(LIN_ADVANCE, MIXING_EXTRUDER)
-        delta_error.e += advance_dividend.e;
-        if (delta_error.e >= 0) {
-          #if ENABLED(LIN_ADVANCE)
-            delta_error.e -= advance_divisor;
-            // Don't step E here - But remember the number of steps to perform
-            motor_direction(E_AXIS) ? --LA_steps : ++LA_steps;
-          #else
-            count_position.e += count_direction.e;
-            step_needed.e = true;
-          #endif
-        }
-      #elif HAS_E0_STEP
+      #if EITHER(HAS_E0_STEP, MIXING_EXTRUDER)
         PULSE_PREP(E);
+
+        #if ENABLED(LIN_ADVANCE)
+          if (step_needed.e && current_block->la_advance_rate) {
+            // don't actually step here, but do subtract movements steps
+            // from the linear advance step count
+            step_needed.e = false;
+            count_position.e -= count_direction.e;
+            la_advance_steps--;
+          }
+        #endif
       #endif
     }
 
@@ -1849,12 +1844,10 @@ void Stepper::pulse_phase_isr() {
       PULSE_START(W);
     #endif
 
-    #if DISABLED(LIN_ADVANCE)
-      #if ENABLED(MIXING_EXTRUDER)
-        if (step_needed.e) E_STEP_WRITE(mixer.get_next_stepper(), !INVERT_E_STEP_PIN);
-      #elif HAS_E0_STEP
-        PULSE_START(E);
-      #endif
+    #if ENABLED(MIXING_EXTRUDER)
+      if (step_needed.e) E_STEP_WRITE(mixer.get_next_stepper(), !INVERT_E_STEP_PIN);
+    #elif HAS_E0_STEP
+      PULSE_START(E);
     #endif
 
     TERN_(I2S_STEPPER_STREAM, i2s_push_sample());
@@ -1894,15 +1887,10 @@ void Stepper::pulse_phase_isr() {
       PULSE_STOP(W);
     #endif
 
-    #if DISABLED(LIN_ADVANCE)
-      #if ENABLED(MIXING_EXTRUDER)
-        if (delta_error.e >= 0) {
-          delta_error.e -= advance_divisor;
-          E_STEP_WRITE(mixer.get_stepper(), INVERT_E_STEP_PIN);
-        }
-      #elif HAS_E0_STEP
-        PULSE_STOP(E);
-      #endif
+    #if ENABLED(MIXING_EXTRUDER)
+      if (step_needed.e) E_STEP_WRITE(mixer.get_stepper(), INVERT_E_STEP_PIN);
+    #elif HAS_E0_STEP
+      PULSE_STOP(E);
     #endif
 
     #if ISR_MULTI_STEPS
@@ -1912,6 +1900,69 @@ void Stepper::pulse_phase_isr() {
   } while (--events_to_do);
 }
 
+// Calculate timer interval, with all limits applied.
+uint32_t Stepper::calc_timer_interval(uint32_t step_rate) {
+  #ifdef CPU_32_BIT
+    // In case of high-performance processor, it is able to calculate in real-time
+    return uint32_t(STEPPER_TIMER_RATE) / step_rate;
+  #else
+    // AVR is able to keep up at 30khz Stepping ISR rate.
+    constexpr uint32_t min_step_rate = (F_CPU) / 500000U;
+    if (step_rate <= min_step_rate) {
+      step_rate = 0;
+      uintptr_t table_address = (uintptr_t)&speed_lookuptable_slow[0][0];
+      return uint16_t(pgm_read_word(table_address));
+    }
+    else {
+      step_rate -= min_step_rate; // Correct for minimal speed
+      if (step_rate >= 0x0800) {  // higher step rate
+        const uint8_t rate_mod_256 = (step_rate & 0x00FF);
+        const uintptr_t table_address = uintptr_t(&speed_lookuptable_fast[uint8_t(step_rate >> 8)][0]),
+                        gain = uint16_t(pgm_read_word(table_address + 2));
+        return uint16_t(pgm_read_word(table_address)) - MultiU16X8toH16(rate_mod_256, gain);
+      }
+      else { // lower step rates
+        uintptr_t table_address = uintptr_t(&speed_lookuptable_slow[0][0]);
+        table_address += (step_rate >> 1) & 0xFFFC;
+        return uint16_t(pgm_read_word(table_address))
+               - ((uint16_t(pgm_read_word(table_address + 2)) * uint8_t(step_rate & 0x0007)) >> 3);
+      }
+    }
+  #endif
+}
+
+// Get the timer interval and the number of loops to perform per tick
+uint32_t Stepper::calc_timer_interval(uint32_t step_rate, uint8_t &loops) {
+  uint8_t multistep = 1;
+  #if DISABLED(DISABLE_MULTI_STEPPING)
+
+    // The stepping frequency limits for each multistepping rate
+    static const uint32_t limit[] PROGMEM = {
+      (  MAX_STEP_ISR_FREQUENCY_1X     ),
+      (  MAX_STEP_ISR_FREQUENCY_2X >> 1),
+      (  MAX_STEP_ISR_FREQUENCY_4X >> 2),
+      (  MAX_STEP_ISR_FREQUENCY_8X >> 3),
+      ( MAX_STEP_ISR_FREQUENCY_16X >> 4),
+      ( MAX_STEP_ISR_FREQUENCY_32X >> 5),
+      ( MAX_STEP_ISR_FREQUENCY_64X >> 6),
+      (MAX_STEP_ISR_FREQUENCY_128X >> 7)
+    };
+
+    // Select the proper multistepping
+    uint8_t idx = 0;
+    while (idx < 7 && step_rate > (uint32_t)pgm_read_dword(&limit[idx])) {
+      step_rate >>= 1;
+      multistep <<= 1;
+      ++idx;
+    };
+  #else
+    NOMORE(step_rate, uint32_t(MAX_STEP_ISR_FREQUENCY_1X));
+  #endif
+  loops = multistep;
+
+  return calc_timer_interval(step_rate);
+}
+
 // This is the last half of the stepper interrupt: This one processes and
 // properly schedules blocks from the planner. This is executed after creating
 // the step pulses, so it is not time critical, as pulses are already done.
@@ -1964,15 +2015,14 @@ uint32_t Stepper::block_phase_isr() {
         // acc_step_rate is in steps/second
 
         // step_rate to timer interval and steps per stepper isr
-        interval = calc_timer_interval(acc_step_rate, &steps_per_isr);
+        interval = calc_timer_interval(acc_step_rate << oversampling_factor, steps_per_isr);
         acceleration_time += interval;
 
         #if ENABLED(LIN_ADVANCE)
-          if (LA_use_advance_lead) {
-            // Fire ISR if final adv_rate is reached
-            if (LA_steps && LA_isr_rate != current_block->advance_speed) nextAdvanceISR = 0;
+          if (current_block->la_advance_rate) {
+            const uint32_t la_step_rate = la_advance_steps < current_block->max_adv_steps ? current_block->la_advance_rate : 0;
+            la_interval = calc_timer_interval(acc_step_rate + la_step_rate) << current_block->la_scaling;
           }
-          else if (LA_steps) nextAdvanceISR = 0;
         #endif
 
         /**
@@ -2035,18 +2085,41 @@ uint32_t Stepper::block_phase_isr() {
         #endif
 
         // step_rate to timer interval and steps per stepper isr
-        interval = calc_timer_interval(step_rate, &steps_per_isr);
+        interval = calc_timer_interval(step_rate << oversampling_factor, steps_per_isr);
         deceleration_time += interval;
 
         #if ENABLED(LIN_ADVANCE)
-          if (LA_use_advance_lead) {
-            // Wake up eISR on first deceleration loop and fire ISR if final adv_rate is reached
-            if (step_events_completed <= decelerate_after + steps_per_isr || (LA_steps && LA_isr_rate != current_block->advance_speed)) {
-              initiateLA();
-              LA_isr_rate = current_block->advance_speed;
+          if (current_block->la_advance_rate) {
+            const uint32_t la_step_rate = la_advance_steps > current_block->final_adv_steps ? current_block->la_advance_rate : 0;
+            if (la_step_rate != step_rate) {
+              bool reverse_e = la_step_rate > step_rate;
+              la_interval = calc_timer_interval(reverse_e ? la_step_rate - step_rate : step_rate - la_step_rate) << current_block->la_scaling;
+
+              if (reverse_e != motor_direction(E_AXIS)) {
+                TBI(last_direction_bits, E_AXIS);
+                count_direction.e = -count_direction.e;
+
+                DIR_WAIT_BEFORE();
+
+                if (reverse_e) {
+                  #if ENABLED(MIXING_EXTRUDER)
+                    MIXER_STEPPER_LOOP(j) REV_E_DIR(j);
+                  #else
+                    REV_E_DIR(stepper_extruder);
+                  #endif
+                }
+                else {
+                  #if ENABLED(MIXING_EXTRUDER)
+                    MIXER_STEPPER_LOOP(j) NORM_E_DIR(j);
+                  #else
+                    NORM_E_DIR(stepper_extruder);
+                  #endif
+                }
+
+                DIR_WAIT_AFTER();
+              }
             }
           }
-          else if (LA_steps) nextAdvanceISR = 0;
         #endif // LIN_ADVANCE
 
         /*
@@ -2069,15 +2142,15 @@ uint32_t Stepper::block_phase_isr() {
       }
       else {  // Must be in cruise phase otherwise
 
-        #if ENABLED(LIN_ADVANCE)
-          // If there are any esteps, fire the next advance_isr "now"
-          if (LA_steps && LA_isr_rate != current_block->advance_speed) initiateLA();
-        #endif
-
         // Calculate the ticks_nominal for this nominal speed, if not done yet
         if (ticks_nominal < 0) {
           // step_rate to timer interval and loops for the nominal speed
-          ticks_nominal = calc_timer_interval(current_block->nominal_rate, &steps_per_isr);
+          ticks_nominal = calc_timer_interval(current_block->nominal_rate << oversampling_factor, steps_per_isr);
+
+          #if ENABLED(LIN_ADVANCE)
+            if (current_block->la_advance_rate)
+              la_interval = calc_timer_interval(current_block->nominal_rate) << current_block->la_scaling;
+          #endif
         }
 
         // The timer interval is just the nominal value for the nominal speed
@@ -2291,7 +2364,7 @@ uint32_t Stepper::block_phase_isr() {
       step_event_count = current_block->step_event_count << oversampling;
 
       // Initialize Bresenham delta errors to 1/2
-      delta_error = -int32_t(step_event_count);
+      delta_error = TERN_(LIN_ADVANCE, la_delta_error =) -int32_t(step_event_count);
 
       // Calculate Bresenham dividends and divisors
       advance_dividend = current_block->steps << 1;
@@ -2312,16 +2385,12 @@ uint32_t Stepper::block_phase_isr() {
       #if ENABLED(LIN_ADVANCE)
         #if DISABLED(MIXING_EXTRUDER) && E_STEPPERS > 1
           // If the now active extruder wasn't in use during the last move, its pressure is most likely gone.
-          if (stepper_extruder != last_moved_extruder) LA_current_adv_steps = 0;
+          if (stepper_extruder != last_moved_extruder) la_advance_steps = 0;
         #endif
-
-        if ((LA_use_advance_lead = current_block->use_advance_lead)) {
-          LA_final_adv_steps = current_block->final_adv_steps;
-          LA_max_adv_steps = current_block->max_adv_steps;
-          initiateLA(); // Start the ISR
-          LA_isr_rate = current_block->advance_speed;
+        if (current_block->la_advance_rate) {
+          // apply LA scaling and discount the effect of frequency scaling
+          la_dividend = (advance_dividend.e << current_block->la_scaling) << oversampling;
         }
-        else LA_isr_rate = LA_ADV_NEVER;
       #endif
 
       if ( ENABLED(DUAL_X_CARRIAGE) // TODO: Find out why this fixes "jittery" small circles
@@ -2375,7 +2444,15 @@ uint32_t Stepper::block_phase_isr() {
       #endif
 
       // Calculate the initial timer interval
-      interval = calc_timer_interval(current_block->initial_rate, &steps_per_isr);
+      interval = calc_timer_interval(current_block->initial_rate << oversampling_factor, steps_per_isr);
+      acceleration_time += interval;
+
+      #if ENABLED(LIN_ADVANCE)
+        if (current_block->la_advance_rate) {
+          const uint32_t la_step_rate = la_advance_steps < current_block->max_adv_steps ? current_block->la_advance_rate : 0;
+          la_interval = calc_timer_interval(current_block->initial_rate + la_step_rate) << current_block->la_scaling;
+        }
+      #endif
     }
   }
 
@@ -2386,71 +2463,15 @@ uint32_t Stepper::block_phase_isr() {
 #if ENABLED(LIN_ADVANCE)
 
   // Timer interrupt for E. LA_steps is set in the main routine
-  uint32_t Stepper::advance_isr() {
-    uint32_t interval;
-
-    if (LA_use_advance_lead) {
-      if (step_events_completed > decelerate_after && LA_current_adv_steps > LA_final_adv_steps) {
-        LA_steps--;
-        LA_current_adv_steps--;
-        interval = LA_isr_rate;
-      }
-      else if (step_events_completed < decelerate_after && LA_current_adv_steps < LA_max_adv_steps) {
-        LA_steps++;
-        LA_current_adv_steps++;
-        interval = LA_isr_rate;
-      }
-      else
-        interval = LA_isr_rate = LA_ADV_NEVER;
-    }
-    else
-      interval = LA_ADV_NEVER;
-
-    if (!LA_steps) return interval; // Leave pins alone if there are no steps!
-
-    DIR_WAIT_BEFORE();
-
-    #if ENABLED(MIXING_EXTRUDER)
-      // We don't know which steppers will be stepped because LA loop follows,
-      // with potentially multiple steps. Set all.
-      if (LA_steps > 0) {
-        MIXER_STEPPER_LOOP(j) NORM_E_DIR(j);
-        count_direction.e = 1;
-      }
-      else if (LA_steps < 0) {
-        MIXER_STEPPER_LOOP(j) REV_E_DIR(j);
-        count_direction.e = -1;
-      }
-    #else
-      if (LA_steps > 0) {
-        NORM_E_DIR(stepper_extruder);
-        count_direction.e = 1;
-      }
-      else if (LA_steps < 0) {
-        REV_E_DIR(stepper_extruder);
-        count_direction.e = -1;
-      }
-    #endif
-
-    DIR_WAIT_AFTER();
-
-    //const hal_timer_t added_step_ticks = hal_timer_t(ADDED_STEP_TICKS);
-
-    // Step E stepper if we have steps
-    #if ISR_MULTI_STEPS
-      bool firstStep = true;
-      USING_TIMED_PULSE();
-    #endif
-
-    while (LA_steps) {
-      #if ISR_MULTI_STEPS
-        if (firstStep)
-          firstStep = false;
-        else
-          AWAIT_LOW_PULSE();
-      #endif
-
+  void Stepper::advance_isr() {
+    // Apply Bresenham algorithm so that linear advance can piggy back on
+    // the acceleration and speed values calculated in block_phase_isr().
+    // This helps keep LA in sync with, for example, S_CURVE_ACCELERATION.
+    la_delta_error += la_dividend;
+    if (la_delta_error >= 0) {
       count_position.e += count_direction.e;
+      la_advance_steps += count_direction.e;
+      la_delta_error -= advance_divisor;
 
       // Set the STEP pulse ON
       #if ENABLED(MIXING_EXTRUDER)
@@ -2461,12 +2482,8 @@ uint32_t Stepper::block_phase_isr() {
 
       // Enforce a minimum duration for STEP pulse ON
       #if ISR_PULSE_CONTROL
+        USING_TIMED_PULSE();
         START_HIGH_PULSE();
-      #endif
-
-      LA_steps < 0 ? ++LA_steps : --LA_steps;
-
-      #if ISR_PULSE_CONTROL
         AWAIT_HIGH_PULSE();
       #endif
 
@@ -2476,15 +2493,7 @@ uint32_t Stepper::block_phase_isr() {
       #else
         E_STEP_WRITE(stepper_extruder, INVERT_E_STEP_PIN);
       #endif
-
-      // For minimum pulse time wait before looping
-      // Just wait for the requested pulse duration
-      #if ISR_PULSE_CONTROL
-        if (LA_steps) START_LOW_PULSE();
-      #endif
-    } // LA_steps
-
-    return interval;
+    }
   }
 
 #endif // LIN_ADVANCE

commit 21c48d9f927c81d7b7cf6fc3641ce01a831a16ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 27 04:24:50 2022 -0500

    🧑‍💻  Update planner/stepper includes

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 593c8f7c6f..b7fd918561 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1467,14 +1467,14 @@ void Stepper::isr() {
     // Enable ISRs to reduce USART processing latency
     hal.isr_on();
 
-    if (!nextMainISR) pulse_phase_isr();                            // 0 = Do coordinated axes Stepper pulses
+    if (!nextMainISR) pulse_phase_isr();                    // 0 = Do coordinated axes Stepper pulses
 
     #if ENABLED(LIN_ADVANCE)
-      if (!nextAdvanceISR) nextAdvanceISR = advance_isr();          // 0 = Do Linear Advance E Stepper pulses
+      if (!nextAdvanceISR) nextAdvanceISR = advance_isr();  // 0 = Do Linear Advance E Stepper pulses
     #endif
 
     #if ENABLED(INTEGRATED_BABYSTEPPING)
-      const bool is_babystep = (nextBabystepISR == 0);              // 0 = Do Babystepping (XY)Z pulses
+      const bool is_babystep = (nextBabystepISR == 0);      // 0 = Do Babystepping (XY)Z pulses
       if (is_babystep) nextBabystepISR = babystepping_isr();
     #endif
 

commit 3f4e4a4d891e3c4b73ab80aedec46e69c1b59f0d
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Wed Jul 13 22:16:22 2022 -0500

    🔥 Drop STM L64** drivers, STEVAL_3DP001V1 (#24427)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 2bacc55606..593c8f7c6f 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -117,12 +117,6 @@ Stepper stepper; // Singleton
   #include "../feature/runout.h"
 #endif
 
-#if HAS_L64XX
-  #include "../libs/L64XX/L64XX_Marlin.h"
-  uint8_t L6470_buf[MAX_L64XX + 1];   // chip command sequence - element 0 not used
-  bool L64XX_OK_to_power_up = false;  // flag to keep L64xx steppers powered down after a reset or power up
-#endif
-
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
@@ -618,27 +612,6 @@ void Stepper::set_directions() {
     #endif
   #endif // !LIN_ADVANCE
 
-  #if HAS_L64XX
-    if (L64XX_OK_to_power_up) { // OK to send the direction commands (which powers up the L64XX steppers)
-      if (L64xxManager.spi_active) {
-        L64xxManager.spi_abort = true;                    // Interrupted SPI transfer needs to shut down gracefully
-        for (uint8_t j = 1; j <= L64XX::chain[0]; j++)
-          L6470_buf[j] = dSPIN_NOP;                         // Fill buffer with NOOPs
-        L64xxManager.transfer(L6470_buf, L64XX::chain[0]);  // Send enough NOOPs to complete any command
-        L64xxManager.transfer(L6470_buf, L64XX::chain[0]);
-        L64xxManager.transfer(L6470_buf, L64XX::chain[0]);
-      }
-
-      // L64xxManager.dir_commands[] is an array that holds direction command for each stepper
-
-      // Scan command array, copy matches into L64xxManager.transfer
-      for (uint8_t j = 1; j <= L64XX::chain[0]; j++)
-        L6470_buf[j] = L64xxManager.dir_commands[L64XX::chain[j]];
-
-      L64xxManager.transfer(L6470_buf, L64XX::chain[0]);  // send the command stream to the drivers
-    }
-  #endif
-
   DIR_WAIT_AFTER();
 }
 
@@ -2351,13 +2324,11 @@ uint32_t Stepper::block_phase_isr() {
         else LA_isr_rate = LA_ADV_NEVER;
       #endif
 
-      if ( ENABLED(HAS_L64XX)       // Always set direction for L64xx (Also enables the chips)
-        || ENABLED(DUAL_X_CARRIAGE) // TODO: Find out why this fixes "jittery" small circles
+      if ( ENABLED(DUAL_X_CARRIAGE) // TODO: Find out why this fixes "jittery" small circles
         || current_block->direction_bits != last_direction_bits
         || TERN(MIXING_EXTRUDER, false, stepper_extruder != last_moved_extruder)
       ) {
         E_TERN_(last_moved_extruder = stepper_extruder);
-        TERN_(HAS_L64XX, L64XX_OK_to_power_up = true);
         set_directions(current_block->direction_bits);
       }
 

commit 920799e38d192f056b76b25a35886f19543308e6
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Jul 8 20:41:39 2022 +0100

    ⚡️ Optimize G2-G3 Arcs (#24366)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4832220abd..2bacc55606 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2002,14 +2002,15 @@ uint32_t Stepper::block_phase_isr() {
           else if (LA_steps) nextAdvanceISR = 0;
         #endif
 
-        /*
+        /**
          * Adjust Laser Power - Accelerating
-         * isPowered - True when a move is powered.
-         * isEnabled - laser power is active.
-         * Laser power variables are calulated and stored in this block by the planner code.
          *
-         * trap_ramp_active_pwr - the active power in this block across accel or decel trap steps.
-         * trap_ramp_entry_incr - holds the precalculated value to increase the current power per accel step.
+         *  isPowered - True when a move is powered.
+         *  isEnabled - laser power is active.
+         *
+         * Laser power variables are calulated and stored in this block by the planner code.
+         *  trap_ramp_active_pwr - the active power in this block across accel or decel trap steps.
+         *  trap_ramp_entry_incr - holds the precalculated value to increase the current power per accel step.
          *
          * Apply the starting active power and then increase power per step by the trap_ramp_entry_incr value if positive.
          */
@@ -2032,6 +2033,7 @@ uint32_t Stepper::block_phase_isr() {
         uint32_t step_rate;
 
         #if ENABLED(S_CURVE_ACCELERATION)
+
           // If this is the 1st time we process the 2nd half of the trapezoid...
           if (!bezier_2nd_half) {
             // Initialize the Bézier speed curve
@@ -2046,6 +2048,7 @@ uint32_t Stepper::block_phase_isr() {
               ? _eval_bezier_curve(deceleration_time)
               : current_block->final_rate;
           }
+
         #else
           // Using the old trapezoidal control
           step_rate = STEP_MULTIPLY(deceleration_time, current_block->acceleration_rate);
@@ -2055,9 +2058,8 @@ uint32_t Stepper::block_phase_isr() {
           }
           else
             step_rate = current_block->final_rate;
-        #endif
 
-        // step_rate is in steps/second
+        #endif
 
         // step_rate to timer interval and steps per stepper isr
         interval = calc_timer_interval(step_rate, &steps_per_isr);
@@ -2109,10 +2111,10 @@ uint32_t Stepper::block_phase_isr() {
         interval = ticks_nominal;
       }
 
-      /* Adjust Laser Power - Cruise
+      /**
+       * Adjust Laser Power - Cruise
        * power - direct or floor adjusted active laser power.
        */
-
       #if ENABLED(LASER_POWER_TRAP)
         if (cutter.cutter_mode == CUTTER_MODE_CONTINUOUS) {
           if (step_events_completed + 1 == accelerate_until) {
@@ -2130,7 +2132,7 @@ uint32_t Stepper::block_phase_isr() {
     }
 
     #if ENABLED(LASER_FEATURE)
-      /*
+      /**
        * CUTTER_MODE_DYNAMIC is experimental and developing.
        * Super-fast method to dynamically adjust the laser power OCR value based on the input feedrate in mm-per-minute.
        * TODO: Set up Min/Max OCR offsets to allow tuning and scaling of various lasers.
@@ -2147,9 +2149,8 @@ uint32_t Stepper::block_phase_isr() {
   }
   else { // !current_block
     #if ENABLED(LASER_FEATURE)
-      if (cutter.cutter_mode == CUTTER_MODE_DYNAMIC) {
+      if (cutter.cutter_mode == CUTTER_MODE_DYNAMIC)
         cutter.apply_power(0);  // No movement in dynamic mode so turn Laser off
-      }
     #endif
   }
 

commit 6a67ad4e4aacf7e7314f9e15fd8fe8489b73742b
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Wed Jul 6 07:46:39 2022 -0500

    ⚡️ Fix and improve Inline Laser Power (#22690)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 5dd1bd24b3..4832220abd 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -253,20 +253,6 @@ xyz_long_t Stepper::endstops_trigsteps;
 xyze_long_t Stepper::count_position{0};
 xyze_int8_t Stepper::count_direction{0};
 
-#if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
-  Stepper::stepper_laser_t Stepper::laser_trap = {
-    .enabled = false,
-    .cur_power = 0,
-    .cruise_set = false,
-    #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
-      .last_step_count = 0,
-      .acc_step_count = 0
-    #else
-      .till_update = 0
-    #endif
-  };
-#endif
-
 #define MINDIR(A) (count_direction[_AXIS(A)] < 0)
 #define MAXDIR(A) (count_direction[_AXIS(A)] > 0)
 
@@ -1964,7 +1950,6 @@ uint32_t Stepper::block_phase_isr() {
 
   // If there is a current block
   if (current_block) {
-
     // If current block is finished, reset pointer and finalize state
     if (step_events_completed >= step_event_count) {
       #if ENABLED(DIRECT_STEPPING)
@@ -2017,32 +2002,28 @@ uint32_t Stepper::block_phase_isr() {
           else if (LA_steps) nextAdvanceISR = 0;
         #endif
 
-        // Update laser - Accelerating
-        #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
-          if (laser_trap.enabled) {
-            #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
-              if (current_block->laser.entry_per) {
-                laser_trap.acc_step_count -= step_events_completed - laser_trap.last_step_count;
-                laser_trap.last_step_count = step_events_completed;
-
-                // Should be faster than a divide, since this should trip just once
-                if (laser_trap.acc_step_count < 0) {
-                  while (laser_trap.acc_step_count < 0) {
-                    laser_trap.acc_step_count += current_block->laser.entry_per;
-                    if (laser_trap.cur_power < current_block->laser.power) laser_trap.cur_power++;
-                  }
-                  cutter.ocr_set_power(laser_trap.cur_power);
-                }
-              }
-            #else
-              if (laser_trap.till_update)
-                laser_trap.till_update--;
-              else {
-                laser_trap.till_update = LASER_POWER_INLINE_TRAPEZOID_CONT_PER;
-                laser_trap.cur_power = (current_block->laser.power * acc_step_rate) / current_block->nominal_rate;
-                cutter.ocr_set_power(laser_trap.cur_power); // Cycle efficiency is irrelevant it the last line was many cycles
+        /*
+         * Adjust Laser Power - Accelerating
+         * isPowered - True when a move is powered.
+         * isEnabled - laser power is active.
+         * Laser power variables are calulated and stored in this block by the planner code.
+         *
+         * trap_ramp_active_pwr - the active power in this block across accel or decel trap steps.
+         * trap_ramp_entry_incr - holds the precalculated value to increase the current power per accel step.
+         *
+         * Apply the starting active power and then increase power per step by the trap_ramp_entry_incr value if positive.
+         */
+
+        #if ENABLED(LASER_POWER_TRAP)
+          if (cutter.cutter_mode == CUTTER_MODE_CONTINUOUS) {
+            if (planner.laser_inline.status.isPowered && planner.laser_inline.status.isEnabled) {
+              if (current_block->laser.trap_ramp_entry_incr > 0) {
+                cutter.apply_power(current_block->laser.trap_ramp_active_pwr);
+                current_block->laser.trap_ramp_active_pwr += current_block->laser.trap_ramp_entry_incr;
               }
-            #endif
+            }
+            // Not a powered move.
+            else cutter.apply_power(0);
           }
         #endif
       }
@@ -2066,7 +2047,6 @@ uint32_t Stepper::block_phase_isr() {
               : current_block->final_rate;
           }
         #else
-
           // Using the old trapezoidal control
           step_rate = STEP_MULTIPLY(deceleration_time, current_block->acceleration_rate);
           if (step_rate < acc_step_rate) { // Still decelerating?
@@ -2094,37 +2074,25 @@ uint32_t Stepper::block_phase_isr() {
           else if (LA_steps) nextAdvanceISR = 0;
         #endif // LIN_ADVANCE
 
-        // Update laser - Decelerating
-        #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
-          if (laser_trap.enabled) {
-            #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
-              if (current_block->laser.exit_per) {
-                laser_trap.acc_step_count -= step_events_completed - laser_trap.last_step_count;
-                laser_trap.last_step_count = step_events_completed;
-
-                // Should be faster than a divide, since this should trip just once
-                if (laser_trap.acc_step_count < 0) {
-                  while (laser_trap.acc_step_count < 0) {
-                    laser_trap.acc_step_count += current_block->laser.exit_per;
-                    if (laser_trap.cur_power > current_block->laser.power_exit) laser_trap.cur_power--;
-                  }
-                  cutter.ocr_set_power(laser_trap.cur_power);
-                }
-              }
-            #else
-              if (laser_trap.till_update)
-                laser_trap.till_update--;
-              else {
-                laser_trap.till_update = LASER_POWER_INLINE_TRAPEZOID_CONT_PER;
-                laser_trap.cur_power = (current_block->laser.power * step_rate) / current_block->nominal_rate;
-                cutter.ocr_set_power(laser_trap.cur_power); // Cycle efficiency isn't relevant when the last line was many cycles
+        /*
+         * Adjust Laser Power - Decelerating
+         * trap_ramp_entry_decr - holds the precalculated value to decrease the current power per decel step.
+         */
+        #if ENABLED(LASER_POWER_TRAP)
+          if (cutter.cutter_mode == CUTTER_MODE_CONTINUOUS) {
+            if (planner.laser_inline.status.isPowered && planner.laser_inline.status.isEnabled) {
+              if (current_block->laser.trap_ramp_exit_decr > 0) {
+                current_block->laser.trap_ramp_active_pwr -= current_block->laser.trap_ramp_exit_decr;
+                cutter.apply_power(current_block->laser.trap_ramp_active_pwr);
               }
-            #endif
+              // Not a powered move.
+              else cutter.apply_power(0);
+            }
           }
         #endif
+
       }
-      // Must be in cruise phase otherwise
-      else {
+      else {  // Must be in cruise phase otherwise
 
         #if ENABLED(LIN_ADVANCE)
           // If there are any esteps, fire the next advance_isr "now"
@@ -2139,24 +2107,50 @@ uint32_t Stepper::block_phase_isr() {
 
         // The timer interval is just the nominal value for the nominal speed
         interval = ticks_nominal;
+      }
 
-        // Update laser - Cruising
-        #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
-          if (laser_trap.enabled) {
-            if (!laser_trap.cruise_set) {
-              laser_trap.cur_power = current_block->laser.power;
-              cutter.ocr_set_power(laser_trap.cur_power);
-              laser_trap.cruise_set = true;
+      /* Adjust Laser Power - Cruise
+       * power - direct or floor adjusted active laser power.
+       */
+
+      #if ENABLED(LASER_POWER_TRAP)
+        if (cutter.cutter_mode == CUTTER_MODE_CONTINUOUS) {
+          if (step_events_completed + 1 == accelerate_until) {
+            if (planner.laser_inline.status.isPowered && planner.laser_inline.status.isEnabled) {
+              if (current_block->laser.trap_ramp_entry_incr > 0) {
+                current_block->laser.trap_ramp_active_pwr = current_block->laser.power;
+                cutter.apply_power(current_block->laser.power);
+              }
             }
-            #if ENABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
-              laser_trap.till_update = LASER_POWER_INLINE_TRAPEZOID_CONT_PER;
-            #else
-              laser_trap.last_step_count = step_events_completed;
-            #endif
+            // Not a powered move.
+            else cutter.apply_power(0);
           }
-        #endif
-      }
+        }
+      #endif
     }
+
+    #if ENABLED(LASER_FEATURE)
+      /*
+       * CUTTER_MODE_DYNAMIC is experimental and developing.
+       * Super-fast method to dynamically adjust the laser power OCR value based on the input feedrate in mm-per-minute.
+       * TODO: Set up Min/Max OCR offsets to allow tuning and scaling of various lasers.
+       * TODO: Integrate accel/decel +-rate into the dynamic laser power calc.
+       */
+      if (cutter.cutter_mode == CUTTER_MODE_DYNAMIC
+        && planner.laser_inline.status.isPowered                  // isPowered flag set on any parsed G1, G2, G3, or G5 move; cleared on any others.
+        && cutter.last_block_power != current_block->laser.power  // Prevent constant update without change
+      ) {
+        cutter.apply_power(current_block->laser.power);
+        cutter.last_block_power = current_block->laser.power;
+      }
+    #endif
+  }
+  else { // !current_block
+    #if ENABLED(LASER_FEATURE)
+      if (cutter.cutter_mode == CUTTER_MODE_DYNAMIC) {
+        cutter.apply_power(0);  // No movement in dynamic mode so turn Laser off
+      }
+    #endif
   }
 
   // If there is no current block at this point, attempt to pop one from the buffer
@@ -2169,11 +2163,18 @@ uint32_t Stepper::block_phase_isr() {
       // Sync block? Sync the stepper counts or fan speeds and return
       while (current_block->is_sync()) {
 
-        if (current_block->is_fan_sync()) {
-          TERN_(LASER_SYNCHRONOUS_M106_M107, planner.sync_fan_speeds(current_block->fan_speed));
-        }
-        else
-          _set_position(current_block->position);
+        #if ENABLED(LASER_POWER_SYNC)
+          if (cutter.cutter_mode == CUTTER_MODE_CONTINUOUS) {
+            if (current_block->is_pwr_sync()) {
+              planner.laser_inline.status.isSyncPower = true;
+              cutter.apply_power(current_block->laser.power);
+            }
+          }
+        #endif
+
+        TERN_(LASER_SYNCHRONOUS_M106_M107, if (current_block->is_fan_sync()) planner.sync_fan_speeds(current_block->fan_speed));
+
+        if (!(current_block->is_fan_sync() || current_block->is_pwr_sync())) _set_position(current_block->position);
 
         discard_current_block();
 
@@ -2183,8 +2184,10 @@ uint32_t Stepper::block_phase_isr() {
       }
 
       // For non-inline cutter, grossly apply power
-      #if ENABLED(LASER_FEATURE) && DISABLED(LASER_POWER_INLINE)
-        cutter.apply_power(current_block->cutter_power);
+      #if HAS_CUTTER
+        if (cutter.cutter_mode == CUTTER_MODE_STANDARD) {
+          cutter.apply_power(current_block->cutter_power);
+        }
       #endif
 
       #if ENABLED(POWER_LOSS_RECOVERY)
@@ -2357,36 +2360,22 @@ uint32_t Stepper::block_phase_isr() {
         set_directions(current_block->direction_bits);
       }
 
-      #if ENABLED(LASER_POWER_INLINE)
-        const power_status_t stat = current_block->laser.status;
-        #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
-          laser_trap.enabled = stat.isPlanned && stat.isEnabled;
-          laser_trap.cur_power = current_block->laser.power_entry; // RESET STATE
-          laser_trap.cruise_set = false;
-          #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
-            laser_trap.last_step_count = 0;
-            laser_trap.acc_step_count = current_block->laser.entry_per / 2;
-          #else
-            laser_trap.till_update = 0;
-          #endif
-          // Always have PWM in this case
-          if (stat.isPlanned) {                        // Planner controls the laser
-            cutter.ocr_set_power(
-              stat.isEnabled ? laser_trap.cur_power : 0 // ON with power or OFF
-            );
-          }
-        #else
-          if (stat.isPlanned) {                        // Planner controls the laser
-            #if ENABLED(SPINDLE_LASER_USE_PWM)
-              cutter.ocr_set_power(
-                stat.isEnabled ? current_block->laser.power : 0 // ON with power or OFF
-              );
+      #if ENABLED(LASER_FEATURE)
+        if (cutter.cutter_mode == CUTTER_MODE_CONTINUOUS) {           // Planner controls the laser
+          if (planner.laser_inline.status.isSyncPower)
+            // If the previous block was a M3 sync power then skip the trap power init otherwise it will 0 the sync power.
+            planner.laser_inline.status.isSyncPower = false;          // Clear the flag to process subsequent trap calc's.
+          else if (current_block->laser.status.isEnabled) {
+            #if ENABLED(LASER_POWER_TRAP)
+              TERN_(DEBUG_LASER_TRAP, SERIAL_ECHO_MSG("InitTrapPwr:",current_block->laser.trap_ramp_active_pwr));
+              cutter.apply_power(current_block->laser.status.isPowered ? current_block->laser.trap_ramp_active_pwr : 0);
             #else
-              cutter.set_enabled(stat.isEnabled);
+              TERN_(DEBUG_CUTTER_POWER, SERIAL_ECHO_MSG("InlinePwr:",current_block->laser.power));
+              cutter.apply_power(current_block->laser.status.isPowered ? current_block->laser.power : 0);
             #endif
           }
-        #endif
-      #endif // LASER_POWER_INLINE
+        }
+      #endif // LASER_FEATURE
 
       // If the endstop is already pressed, endstop interrupts won't invoke
       // endstop_triggered and the move will grind. So check here for a
@@ -2416,21 +2405,6 @@ uint32_t Stepper::block_phase_isr() {
       // Calculate the initial timer interval
       interval = calc_timer_interval(current_block->initial_rate, &steps_per_isr);
     }
-    #if ENABLED(LASER_POWER_INLINE_CONTINUOUS)
-      else { // No new block found; so apply inline laser parameters
-        // This should mean ending file with 'M5 I' will stop the laser; thus the inline flag isn't needed
-        const power_status_t stat = planner.laser_inline.status;
-        if (stat.isPlanned) {             // Planner controls the laser
-          #if ENABLED(SPINDLE_LASER_USE_PWM)
-            cutter.ocr_set_power(
-              stat.isEnabled ? planner.laser_inline.power : 0 // ON with power or OFF
-            );
-          #else
-            cutter.set_enabled(stat.isEnabled);
-          #endif
-        }
-      }
-    #endif
   }
 
   // Return the interval to wait

commit 307dfb15ca88f424dcb4cf579e4542e77dfb0eaf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 26 22:24:59 2022 -0500

    ♻️ Planner flags refactor

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 40cf7d02ea..5dd1bd24b3 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1699,7 +1699,7 @@ void Stepper::pulse_phase_isr() {
     }while(0)
 
     // Direct Stepping page?
-    const bool is_page = IS_PAGE(current_block);
+    const bool is_page = current_block->is_page();
 
     #if ENABLED(DIRECT_STEPPING)
       // Direct stepping is currently not ready for HAS_I_AXIS
@@ -1977,7 +1977,7 @@ uint32_t Stepper::block_phase_isr() {
             count_position[_AXIS(AXIS)] += page_step_state.bd[_AXIS(AXIS)] * count_direction[_AXIS(AXIS)];
         #endif
 
-        if (IS_PAGE(current_block)) {
+        if (current_block->is_page()) {
           PAGE_SEGMENT_UPDATE_POS(X);
           PAGE_SEGMENT_UPDATE_POS(Y);
           PAGE_SEGMENT_UPDATE_POS(Z);
@@ -2167,16 +2167,13 @@ uint32_t Stepper::block_phase_isr() {
     if ((current_block = planner.get_current_block())) {
 
       // Sync block? Sync the stepper counts or fan speeds and return
-      while (current_block->flag & BLOCK_MASK_SYNC) {
+      while (current_block->is_sync()) {
 
-        #if ENABLED(LASER_SYNCHRONOUS_M106_M107)
-          const bool is_sync_fans = TEST(current_block->flag, BLOCK_BIT_SYNC_FANS);
-          if (is_sync_fans) planner.sync_fan_speeds(current_block->fan_speed);
-        #else
-          constexpr bool is_sync_fans = false;
-        #endif
-
-        if (!is_sync_fans) _set_position(current_block->position);
+        if (current_block->is_fan_sync()) {
+          TERN_(LASER_SYNCHRONOUS_M106_M107, planner.sync_fan_speeds(current_block->fan_speed));
+        }
+        else
+          _set_position(current_block->position);
 
         discard_current_block();
 
@@ -2196,7 +2193,7 @@ uint32_t Stepper::block_phase_isr() {
       #endif
 
       #if ENABLED(DIRECT_STEPPING)
-        if (IS_PAGE(current_block)) {
+        if (current_block->is_page()) {
           page_step_state.segment_steps = 0;
           page_step_state.segment_idx = 0;
           page_step_state.page = page_manager.get_page(current_block->page_idx);

commit ca06c6eab97407b3ef897f1512cc51e1b4aa083c
Author: John Robertson <john@cirtech.co.uk>
Date:   Sat Jun 4 07:26:08 2022 +0100

    ⚡️ PWM for ESP32 I2S expander (#24193)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index d098179fc1..40cf7d02ea 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1898,9 +1898,7 @@ void Stepper::pulse_phase_isr() {
       #endif
     #endif
 
-    #if ENABLED(I2S_STEPPER_STREAM)
-      i2s_push_sample();
-    #endif
+    TERN_(I2S_STEPPER_STREAM, i2s_push_sample());
 
     // TODO: need to deal with MINIMUM_STEPPER_PULSE over i2s
     #if ISR_MULTI_STEPS

commit d99185be24e035d6370c8f36851e09917d7fe342
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sun May 22 14:32:16 2022 -0700

    🎨 Fix/adjust warnings (#24225)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4e44199f22..d098179fc1 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -611,7 +611,7 @@ void Stepper::set_directions() {
   #if DISABLED(LIN_ADVANCE)
     #if ENABLED(MIXING_EXTRUDER)
        // Because this is valid for the whole block we don't know
-       // what e-steppers will step. Likely all. Set all.
+       // what E steppers will step. Likely all. Set all.
       if (motor_direction(E_AXIS)) {
         MIXER_STEPPER_LOOP(j) REV_E_DIR(j);
         count_direction.e = -1;

commit c5126de559719ebdaf4475b0db4ab21c26b90a1a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 22 16:08:29 2022 -0500

    🧑‍💻 MAP macro for axis lists, etc. (#24191)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 60eb635965..4e44199f22 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -498,11 +498,7 @@ xyze_int8_t Stepper::count_direction{0};
 void Stepper::enable_axis(const AxisEnum axis) {
   #define _CASE_ENABLE(N) case N##_AXIS: ENABLE_AXIS_##N(); break;
   switch (axis) {
-    NUM_AXIS_CODE(
-      _CASE_ENABLE(X), _CASE_ENABLE(Y), _CASE_ENABLE(Z),
-      _CASE_ENABLE(I), _CASE_ENABLE(J), _CASE_ENABLE(K),
-      _CASE_ENABLE(U), _CASE_ENABLE(V), _CASE_ENABLE(W)
-    );
+    MAIN_AXIS_MAP(_CASE_ENABLE)
     default: break;
   }
   mark_axis_enabled(axis);
@@ -518,11 +514,7 @@ bool Stepper::disable_axis(const AxisEnum axis) {
   if (can_disable) {
     #define _CASE_DISABLE(N) case N##_AXIS: DISABLE_AXIS_##N(); break;
     switch (axis) {
-      NUM_AXIS_CODE(
-        _CASE_DISABLE(X), _CASE_DISABLE(Y), _CASE_DISABLE(Z),
-        _CASE_DISABLE(I), _CASE_DISABLE(J), _CASE_DISABLE(K),
-        _CASE_DISABLE(U), _CASE_DISABLE(V), _CASE_DISABLE(W)
-      );
+      MAIN_AXIS_MAP(_CASE_DISABLE)
       default: break;
     }
   }

commit e438c77c6a5bb59966d39a6ea6aa7703ec4131a3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 4 19:10:14 2022 -0500

    🚚 Move speed_lookuptable.h

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index aadea0f1c6..60eb635965 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -84,7 +84,7 @@ Stepper stepper; // Singleton
 #define BABYSTEPPING_EXTRA_DIR_WAIT
 
 #ifdef __AVR__
-  #include "speed_lookuptable.h"
+  #include "stepper/speed_lookuptable.h"
 #endif
 
 #include "endstops.h"

commit df40181357b08761766067ef5012b2b3d0e34d3e
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed May 4 17:25:02 2022 -0700

    💥 Num Axes and Multi-Stepper based on Driver Types (#24120)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 85b42f61bb..aadea0f1c6 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -177,9 +177,9 @@ bool Stepper::abort_current_block;
 
 #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
   bool Stepper::locked_Z_motor = false, Stepper::locked_Z2_motor = false
-    #if NUM_Z_STEPPER_DRIVERS >= 3
+    #if NUM_Z_STEPPERS >= 3
       , Stepper::locked_Z3_motor = false
-      #if NUM_Z_STEPPER_DRIVERS >= 4
+      #if NUM_Z_STEPPERS >= 4
         , Stepper::locked_Z4_motor = false
       #endif
     #endif
@@ -365,7 +365,7 @@ xyze_int8_t Stepper::count_direction{0};
     A##4_STEP_WRITE(V);                           \
   }
 
-#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+#if HAS_DUAL_X_STEPPERS
   #define X_APPLY_DIR(v,Q) do{ X_DIR_WRITE(v); X2_DIR_WRITE((v) ^ ENABLED(INVERT_X2_VS_X_DIR)); }while(0)
   #if ENABLED(X_DUAL_ENDSTOPS)
     #define X_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(X,v)
@@ -386,7 +386,7 @@ xyze_int8_t Stepper::count_direction{0};
   #define X_APPLY_STEP(v,Q) X_STEP_WRITE(v)
 #endif
 
-#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+#if HAS_DUAL_Y_STEPPERS
   #define Y_APPLY_DIR(v,Q) do{ Y_DIR_WRITE(v); Y2_DIR_WRITE((v) ^ ENABLED(INVERT_Y2_VS_Y_DIR)); }while(0)
   #if ENABLED(Y_DUAL_ENDSTOPS)
     #define Y_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Y,v)
@@ -398,7 +398,7 @@ xyze_int8_t Stepper::count_direction{0};
   #define Y_APPLY_STEP(v,Q) Y_STEP_WRITE(v)
 #endif
 
-#if NUM_Z_STEPPER_DRIVERS == 4
+#if NUM_Z_STEPPERS == 4
   #define Z_APPLY_DIR(v,Q) do{ \
     Z_DIR_WRITE(v); Z2_DIR_WRITE((v) ^ ENABLED(INVERT_Z2_VS_Z_DIR)); \
     Z3_DIR_WRITE((v) ^ ENABLED(INVERT_Z3_VS_Z_DIR)); Z4_DIR_WRITE((v) ^ ENABLED(INVERT_Z4_VS_Z_DIR)); \
@@ -410,7 +410,7 @@ xyze_int8_t Stepper::count_direction{0};
   #else
     #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); Z3_STEP_WRITE(v); Z4_STEP_WRITE(v); }while(0)
   #endif
-#elif NUM_Z_STEPPER_DRIVERS == 3
+#elif NUM_Z_STEPPERS == 3
   #define Z_APPLY_DIR(v,Q) do{ \
     Z_DIR_WRITE(v); Z2_DIR_WRITE((v) ^ ENABLED(INVERT_Z2_VS_Z_DIR)); Z3_DIR_WRITE((v) ^ ENABLED(INVERT_Z3_VS_Z_DIR)); \
   }while(0)
@@ -421,7 +421,7 @@ xyze_int8_t Stepper::count_direction{0};
   #else
     #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); Z3_STEP_WRITE(v); }while(0)
   #endif
-#elif NUM_Z_STEPPER_DRIVERS == 2
+#elif NUM_Z_STEPPERS == 2
   #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE((v) ^ ENABLED(INVERT_Z2_VS_Z_DIR)); }while(0)
   #if ENABLED(Z_MULTI_ENDSTOPS)
     #define Z_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Z,v)
@@ -2613,19 +2613,19 @@ void Stepper::init() {
   TERN_(HAS_X2_DIR, X2_DIR_INIT());
   #if HAS_Y_DIR
     Y_DIR_INIT();
-    #if BOTH(Y_DUAL_STEPPER_DRIVERS, HAS_Y2_DIR)
+    #if BOTH(HAS_DUAL_Y_STEPPERS, HAS_Y2_DIR)
       Y2_DIR_INIT();
     #endif
   #endif
   #if HAS_Z_DIR
     Z_DIR_INIT();
-    #if NUM_Z_STEPPER_DRIVERS >= 2 && HAS_Z2_DIR
+    #if NUM_Z_STEPPERS >= 2 && HAS_Z2_DIR
       Z2_DIR_INIT();
     #endif
-    #if NUM_Z_STEPPER_DRIVERS >= 3 && HAS_Z3_DIR
+    #if NUM_Z_STEPPERS >= 3 && HAS_Z3_DIR
       Z3_DIR_INIT();
     #endif
-    #if NUM_Z_STEPPER_DRIVERS >= 4 && HAS_Z4_DIR
+    #if NUM_Z_STEPPERS >= 4 && HAS_Z4_DIR
       Z4_DIR_INIT();
     #endif
   #endif
@@ -2684,7 +2684,7 @@ void Stepper::init() {
   #if HAS_Y_ENABLE
     Y_ENABLE_INIT();
     if (!Y_ENABLE_ON) Y_ENABLE_WRITE(HIGH);
-    #if BOTH(Y_DUAL_STEPPER_DRIVERS, HAS_Y2_ENABLE)
+    #if BOTH(HAS_DUAL_Y_STEPPERS, HAS_Y2_ENABLE)
       Y2_ENABLE_INIT();
       if (!Y_ENABLE_ON) Y2_ENABLE_WRITE(HIGH);
     #endif
@@ -2692,15 +2692,15 @@ void Stepper::init() {
   #if HAS_Z_ENABLE
     Z_ENABLE_INIT();
     if (!Z_ENABLE_ON) Z_ENABLE_WRITE(HIGH);
-    #if NUM_Z_STEPPER_DRIVERS >= 2 && HAS_Z2_ENABLE
+    #if NUM_Z_STEPPERS >= 2 && HAS_Z2_ENABLE
       Z2_ENABLE_INIT();
       if (!Z_ENABLE_ON) Z2_ENABLE_WRITE(HIGH);
     #endif
-    #if NUM_Z_STEPPER_DRIVERS >= 3 && HAS_Z3_ENABLE
+    #if NUM_Z_STEPPERS >= 3 && HAS_Z3_ENABLE
       Z3_ENABLE_INIT();
       if (!Z_ENABLE_ON) Z3_ENABLE_WRITE(HIGH);
     #endif
-    #if NUM_Z_STEPPER_DRIVERS >= 4 && HAS_Z4_ENABLE
+    #if NUM_Z_STEPPERS >= 4 && HAS_Z4_ENABLE
       Z4_ENABLE_INIT();
       if (!Z_ENABLE_ON) Z4_ENABLE_WRITE(HIGH);
     #endif
@@ -2775,7 +2775,7 @@ void Stepper::init() {
 
   // Init Step Pins
   #if HAS_X_STEP
-    #if EITHER(X_DUAL_STEPPER_DRIVERS, DUAL_X_CARRIAGE)
+    #if HAS_X2_STEPPER
       X2_STEP_INIT();
       X2_STEP_WRITE(INVERT_X_STEP_PIN);
     #endif
@@ -2783,7 +2783,7 @@ void Stepper::init() {
   #endif
 
   #if HAS_Y_STEP
-    #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+    #if HAS_DUAL_Y_STEPPERS
       Y2_STEP_INIT();
       Y2_STEP_WRITE(INVERT_Y_STEP_PIN);
     #endif
@@ -2791,15 +2791,15 @@ void Stepper::init() {
   #endif
 
   #if HAS_Z_STEP
-    #if NUM_Z_STEPPER_DRIVERS >= 2
+    #if NUM_Z_STEPPERS >= 2
       Z2_STEP_INIT();
       Z2_STEP_WRITE(INVERT_Z_STEP_PIN);
     #endif
-    #if NUM_Z_STEPPER_DRIVERS >= 3
+    #if NUM_Z_STEPPERS >= 3
       Z3_STEP_INIT();
       Z3_STEP_WRITE(INVERT_Z_STEP_PIN);
     #endif
-    #if NUM_Z_STEPPER_DRIVERS >= 4
+    #if NUM_Z_STEPPERS >= 4
       Z4_STEP_INIT();
       Z4_STEP_WRITE(INVERT_Z_STEP_PIN);
     #endif

commit b37d13af7278c241064b61279e7e8538a03206a3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 29 15:21:15 2022 -0500

    🔧 Base NUM_AXES on defined DRIVER_TYPEs (#24106)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 1140a6eb1e..85b42f61bb 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3058,7 +3058,7 @@ void Stepper::report_positions() {
 
   #define _ENABLE_AXIS(A) enable_axis(_AXIS(A))
   #define _READ_DIR(AXIS) AXIS ##_DIR_READ()
-  #define _INVERT_DIR(AXIS) INVERT_## AXIS ##_DIR
+  #define _INVERT_DIR(AXIS) ENABLED(INVERT_## AXIS ##_DIR)
   #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)
 
   #if MINIMUM_STEPPER_PULSE
@@ -3203,30 +3203,30 @@ void Stepper::report_positions() {
             U_DIR_READ(), V_DIR_READ(), W_DIR_READ()
           );
 
-          X_DIR_WRITE(INVERT_X_DIR ^ z_direction);
+          X_DIR_WRITE(ENABLED(INVERT_X_DIR) ^ z_direction);
           #ifdef Y_DIR_WRITE
-            Y_DIR_WRITE(INVERT_Y_DIR ^ z_direction);
+            Y_DIR_WRITE(ENABLED(INVERT_Y_DIR) ^ z_direction);
           #endif
           #ifdef Z_DIR_WRITE
-            Z_DIR_WRITE(INVERT_Z_DIR ^ z_direction);
+            Z_DIR_WRITE(ENABLED(INVERT_Z_DIR) ^ z_direction);
           #endif
           #ifdef I_DIR_WRITE
-            I_DIR_WRITE(INVERT_I_DIR ^ z_direction);
+            I_DIR_WRITE(ENABLED(INVERT_I_DIR) ^ z_direction);
           #endif
           #ifdef J_DIR_WRITE
-            J_DIR_WRITE(INVERT_J_DIR ^ z_direction);
+            J_DIR_WRITE(ENABLED(INVERT_J_DIR) ^ z_direction);
           #endif
           #ifdef K_DIR_WRITE
-            K_DIR_WRITE(INVERT_K_DIR ^ z_direction);
+            K_DIR_WRITE(ENABLED(INVERT_K_DIR) ^ z_direction);
           #endif
           #ifdef U_DIR_WRITE
-            U_DIR_WRITE(INVERT_U_DIR ^ z_direction);
+            U_DIR_WRITE(ENABLED(INVERT_U_DIR) ^ z_direction);
           #endif
           #ifdef V_DIR_WRITE
-            V_DIR_WRITE(INVERT_V_DIR ^ z_direction);
+            V_DIR_WRITE(ENABLED(INVERT_V_DIR) ^ z_direction);
           #endif
           #ifdef W_DIR_WRITE
-            W_DIR_WRITE(INVERT_W_DIR ^ z_direction);
+            W_DIR_WRITE(ENABLED(INVERT_W_DIR) ^ z_direction);
           #endif
 
           DIR_WAIT_AFTER();

commit bf38ef23e50677a5fe949e74131e9377bc3f743a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 21 08:58:45 2022 -0500

    🐛  Prevent BABYSTEP freeze
    
    See #22830, #13300

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 6c18169067..1140a6eb1e 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3072,7 +3072,12 @@ void Stepper::report_positions() {
   #else
     #define CYCLES_EATEN_BABYSTEP 0
   #endif
-  #define EXTRA_CYCLES_BABYSTEP (STEP_PULSE_CYCLES - (CYCLES_EATEN_BABYSTEP))
+
+  #if CYCLES_EATEN_BABYSTEP < STEP_PULSE_CYCLES
+    #define EXTRA_CYCLES_BABYSTEP (STEP_PULSE_CYCLES - (CYCLES_EATEN_BABYSTEP))
+  #else
+    #define EXTRA_CYCLES_BABYSTEP 0
+  #endif
 
   #if EXTRA_CYCLES_BABYSTEP > 20
     #define _SAVE_START() const hal_timer_t pulse_start = HAL_timer_get_count(MF_TIMER_PULSE)

commit 8aaf64d9172bacff2231823ccedbe27a1a968d45
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Tue Apr 19 05:15:15 2022 +0200

    💥 Update Motor Current G-codes for extra axes (#23975)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 7301e29814..6c18169067 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3367,7 +3367,7 @@ void Stepper::report_positions() {
     if (!initialized) return;
     LOOP_L_N(i, COUNT(motor_current_setting)) {
       switch (i) {
-        #if ANY_PIN(MOTOR_CURRENT_PWM_XY, MOTOR_CURRENT_PWM_X, MOTOR_CURRENT_PWM_Y)
+        #if ANY_PIN(MOTOR_CURRENT_PWM_XY, MOTOR_CURRENT_PWM_X, MOTOR_CURRENT_PWM_Y, MOTOR_CURRENT_PWM_I, MOTOR_CURRENT_PWM_J, MOTOR_CURRENT_PWM_K, MOTOR_CURRENT_PWM_U, MOTOR_CURRENT_PWM_V, MOTOR_CURRENT_PWM_W)
           case 0:
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
@@ -3415,6 +3415,24 @@ void Stepper::report_positions() {
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
               _WRITE_CURRENT_PWM(XY);
             #endif
+            #if PIN_EXISTS(MOTOR_CURRENT_PWM_I)
+              _WRITE_CURRENT_PWM(I);
+            #endif
+            #if PIN_EXISTS(MOTOR_CURRENT_PWM_J)
+              _WRITE_CURRENT_PWM(J);
+            #endif
+            #if PIN_EXISTS(MOTOR_CURRENT_PWM_K)
+              _WRITE_CURRENT_PWM(K);
+            #endif
+            #if PIN_EXISTS(MOTOR_CURRENT_PWM_U)
+              _WRITE_CURRENT_PWM(U);
+            #endif
+            #if PIN_EXISTS(MOTOR_CURRENT_PWM_V)
+              _WRITE_CURRENT_PWM(V);
+            #endif
+            #if PIN_EXISTS(MOTOR_CURRENT_PWM_W)
+              _WRITE_CURRENT_PWM(W);
+            #endif
             break;
           case 1:
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
@@ -3464,6 +3482,24 @@ void Stepper::report_positions() {
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
           INIT_CURRENT_PWM(XY);
         #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_I)
+          INIT_CURRENT_PWM(I);
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_J)
+          INIT_CURRENT_PWM(J);
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_K)
+          INIT_CURRENT_PWM(K);
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_U)
+          INIT_CURRENT_PWM(U);
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_V)
+          INIT_CURRENT_PWM(V);
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_W)
+          INIT_CURRENT_PWM(W);
+        #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
           INIT_CURRENT_PWM(Z);
         #endif

commit f22307a0af5bcb6b144e39a8fbf18a27d9a074a6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Mon Apr 4 04:43:42 2022 +0200

    🚸 Better M350, M114 with more axes (#23986)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 82024efdef..7301e29814 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3638,7 +3638,7 @@ void Stepper::report_positions() {
   void Stepper::microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2, const int8_t ms3) {
     if (ms1 >= 0) switch (driver) {
       #if HAS_X_MS_PINS || HAS_X2_MS_PINS
-        case 0:
+        case X_AXIS:
           #if HAS_X_MS_PINS
             WRITE(X_MS1_PIN, ms1);
           #endif
@@ -3648,7 +3648,7 @@ void Stepper::report_positions() {
           break;
       #endif
       #if HAS_Y_MS_PINS || HAS_Y2_MS_PINS
-        case 1:
+        case Y_AXIS:
           #if HAS_Y_MS_PINS
             WRITE(Y_MS1_PIN, ms1);
           #endif
@@ -3658,7 +3658,7 @@ void Stepper::report_positions() {
           break;
       #endif
       #if HAS_SOME_Z_MS_PINS
-        case 2:
+        case Z_AXIS:
           #if HAS_Z_MS_PINS
             WRITE(Z_MS1_PIN, ms1);
           #endif
@@ -3673,52 +3673,52 @@ void Stepper::report_positions() {
           #endif
           break;
       #endif
+      #if HAS_I_MS_PINS
+        case  I_AXIS: WRITE(I_MS1_PIN, ms1); break
+      #endif
+      #if HAS_J_MS_PINS
+        case  J_AXIS: WRITE(J_MS1_PIN, ms1); break
+      #endif
+      #if HAS_K_MS_PINS
+        case  K_AXIS: WRITE(K_MS1_PIN, ms1); break
+      #endif
+      #if HAS_U_MS_PINS
+        case  U_AXIS: WRITE(U_MS1_PIN, ms1); break
+      #endif
+      #if HAS_V_MS_PINS
+        case  V_AXIS: WRITE(V_MS1_PIN, ms1); break
+      #endif
+      #if HAS_W_MS_PINS
+        case  W_AXIS: WRITE(W_MS1_PIN, ms1); break
+      #endif
       #if HAS_E0_MS_PINS
-        case  3: WRITE(E0_MS1_PIN, ms1); break;
+        case  E_AXIS: WRITE(E0_MS1_PIN, ms1); break;
       #endif
       #if HAS_E1_MS_PINS
-        case  4: WRITE(E1_MS1_PIN, ms1); break;
+        case (E_AXIS + 1): WRITE(E1_MS1_PIN, ms1); break;
       #endif
       #if HAS_E2_MS_PINS
-        case  5: WRITE(E2_MS1_PIN, ms1); break;
+        case (E_AXIS + 2): WRITE(E2_MS1_PIN, ms1); break;
       #endif
       #if HAS_E3_MS_PINS
-        case  6: WRITE(E3_MS1_PIN, ms1); break;
+        case (E_AXIS + 3): WRITE(E3_MS1_PIN, ms1); break;
       #endif
       #if HAS_E4_MS_PINS
-        case  7: WRITE(E4_MS1_PIN, ms1); break;
+        case (E_AXIS + 4): WRITE(E4_MS1_PIN, ms1); break;
       #endif
       #if HAS_E5_MS_PINS
-        case  8: WRITE(E5_MS1_PIN, ms1); break;
+        case (E_AXIS + 5): WRITE(E5_MS1_PIN, ms1); break;
       #endif
       #if HAS_E6_MS_PINS
-        case  9: WRITE(E6_MS1_PIN, ms1); break;
+        case (E_AXIS + 6): WRITE(E6_MS1_PIN, ms1); break;
       #endif
       #if HAS_E7_MS_PINS
-        case 10: WRITE(E7_MS1_PIN, ms1); break;
-      #endif
-      #if HAS_I_MS_PINS
-        case 11: WRITE(I_MS1_PIN, ms1); break
-      #endif
-      #if HAS_J_MS_PINS
-        case 12: WRITE(J_MS1_PIN, ms1); break
-      #endif
-      #if HAS_K_MS_PINS
-        case 13: WRITE(K_MS1_PIN, ms1); break
-      #endif
-      #if HAS_U_MS_PINS
-        case 14: WRITE(U_MS1_PIN, ms1); break
-      #endif
-      #if HAS_V_MS_PINS
-        case 15: WRITE(V_MS1_PIN, ms1); break
-      #endif
-      #if HAS_W_MS_PINS
-        case 16: WRITE(W_MS1_PIN, ms1); break
+        case (E_AXIS + 7): WRITE(E7_MS1_PIN, ms1); break;
       #endif
     }
     if (ms2 >= 0) switch (driver) {
       #if HAS_X_MS_PINS || HAS_X2_MS_PINS
-        case 0:
+        case X_AXIS:
           #if HAS_X_MS_PINS
             WRITE(X_MS2_PIN, ms2);
           #endif
@@ -3728,7 +3728,7 @@ void Stepper::report_positions() {
           break;
       #endif
       #if HAS_Y_MS_PINS || HAS_Y2_MS_PINS
-        case 1:
+        case Y_AXIS:
           #if HAS_Y_MS_PINS
             WRITE(Y_MS2_PIN, ms2);
           #endif
@@ -3738,7 +3738,7 @@ void Stepper::report_positions() {
           break;
       #endif
       #if HAS_SOME_Z_MS_PINS
-        case 2:
+        case Z_AXIS:
           #if HAS_Z_MS_PINS
             WRITE(Z_MS2_PIN, ms2);
           #endif
@@ -3753,52 +3753,52 @@ void Stepper::report_positions() {
           #endif
           break;
       #endif
+      #if HAS_I_MS_PINS
+        case  I_AXIS: WRITE(I_MS2_PIN, ms2); break
+      #endif
+      #if HAS_J_MS_PINS
+        case  J_AXIS: WRITE(J_MS2_PIN, ms2); break
+      #endif
+      #if HAS_K_MS_PINS
+        case  K_AXIS: WRITE(K_MS2_PIN, ms2); break
+      #endif
+      #if HAS_U_MS_PINS
+        case  U_AXIS: WRITE(U_MS2_PIN, ms2); break
+      #endif
+      #if HAS_V_MS_PINS
+        case  V_AXIS: WRITE(V_MS2_PIN, ms2); break
+      #endif
+      #if HAS_W_MS_PINS
+        case  W_AXIS: WRITE(W_MS2_PIN, ms2); break
+      #endif
       #if HAS_E0_MS_PINS
-        case  3: WRITE(E0_MS2_PIN, ms2); break;
+        case  E_AXIS: WRITE(E0_MS2_PIN, ms2); break;
       #endif
       #if HAS_E1_MS_PINS
-        case  4: WRITE(E1_MS2_PIN, ms2); break;
+        case (E_AXIS + 1): WRITE(E1_MS2_PIN, ms2); break;
       #endif
       #if HAS_E2_MS_PINS
-        case  5: WRITE(E2_MS2_PIN, ms2); break;
+        case (E_AXIS + 2): WRITE(E2_MS2_PIN, ms2); break;
       #endif
       #if HAS_E3_MS_PINS
-        case  6: WRITE(E3_MS2_PIN, ms2); break;
+        case (E_AXIS + 3): WRITE(E3_MS2_PIN, ms2); break;
       #endif
       #if HAS_E4_MS_PINS
-        case  7: WRITE(E4_MS2_PIN, ms2); break;
+        case (E_AXIS + 4): WRITE(E4_MS2_PIN, ms2); break;
       #endif
       #if HAS_E5_MS_PINS
-        case  8: WRITE(E5_MS2_PIN, ms2); break;
+        case (E_AXIS + 5): WRITE(E5_MS2_PIN, ms2); break;
       #endif
       #if HAS_E6_MS_PINS
-        case  9: WRITE(E6_MS2_PIN, ms2); break;
+        case (E_AXIS + 6): WRITE(E6_MS2_PIN, ms2); break;
       #endif
       #if HAS_E7_MS_PINS
-        case 10: WRITE(E7_MS2_PIN, ms2); break;
-      #endif
-      #if HAS_I_MS_PINS
-        case 11: WRITE(I_MS2_PIN, ms2); break
-      #endif
-      #if HAS_J_MS_PINS
-        case 12: WRITE(J_MS2_PIN, ms2); break
-      #endif
-      #if HAS_K_MS_PINS
-        case 13: WRITE(K_MS2_PIN, ms2); break
-      #endif
-      #if HAS_U_MS_PINS
-        case 14: WRITE(U_MS2_PIN, ms2); break
-      #endif
-      #if HAS_V_MS_PINS
-        case 15: WRITE(V_MS2_PIN, ms2); break
-      #endif
-      #if HAS_W_MS_PINS
-        case 16: WRITE(W_MS2_PIN, ms2); break
+        case (E_AXIS + 7): WRITE(E7_MS2_PIN, ms2); break;
       #endif
     }
     if (ms3 >= 0) switch (driver) {
       #if HAS_X_MS_PINS || HAS_X2_MS_PINS
-        case 0:
+        case X_AXIS:
           #if HAS_X_MS_PINS && PIN_EXISTS(X_MS3)
             WRITE(X_MS3_PIN, ms3);
           #endif
@@ -3808,7 +3808,7 @@ void Stepper::report_positions() {
           break;
       #endif
       #if HAS_Y_MS_PINS || HAS_Y2_MS_PINS
-        case 1:
+        case Y_AXIS:
           #if HAS_Y_MS_PINS && PIN_EXISTS(Y_MS3)
             WRITE(Y_MS3_PIN, ms3);
           #endif
@@ -3818,7 +3818,7 @@ void Stepper::report_positions() {
           break;
       #endif
       #if HAS_SOME_Z_MS_PINS
-        case 2:
+        case Z_AXIS:
           #if HAS_Z_MS_PINS && PIN_EXISTS(Z_MS3)
             WRITE(Z_MS3_PIN, ms3);
           #endif
@@ -3833,29 +3833,47 @@ void Stepper::report_positions() {
           #endif
           break;
       #endif
+      #if HAS_I_MS_PINS
+        case  I_AXIS: WRITE(I_MS3_PIN, ms3); break
+      #endif
+      #if HAS_J_MS_PINS
+        case  J_AXIS: WRITE(J_MS3_PIN, ms3); break
+      #endif
+      #if HAS_K_MS_PINS
+        case  K_AXIS: WRITE(K_MS3_PIN, ms3); break
+      #endif
+      #if HAS_U_MS_PINS
+        case  U_AXIS: WRITE(U_MS3_PIN, ms3); break
+      #endif
+      #if HAS_V_MS_PINS
+        case  V_AXIS: WRITE(V_MS3_PIN, ms3); break
+      #endif
+      #if HAS_W_MS_PINS
+        case  W_AXIS: WRITE(W_MS3_PIN, ms3); break
+      #endif
       #if HAS_E0_MS_PINS && PIN_EXISTS(E0_MS3)
-        case  3: WRITE(E0_MS3_PIN, ms3); break;
+        case  E_AXIS: WRITE(E0_MS3_PIN, ms3); break;
       #endif
       #if HAS_E1_MS_PINS && PIN_EXISTS(E1_MS3)
-        case  4: WRITE(E1_MS3_PIN, ms3); break;
+        case (E_AXIS + 1): WRITE(E1_MS3_PIN, ms3); break;
       #endif
       #if HAS_E2_MS_PINS && PIN_EXISTS(E2_MS3)
-        case  5: WRITE(E2_MS3_PIN, ms3); break;
+        case (E_AXIS + 2): WRITE(E2_MS3_PIN, ms3); break;
       #endif
       #if HAS_E3_MS_PINS && PIN_EXISTS(E3_MS3)
-        case  6: WRITE(E3_MS3_PIN, ms3); break;
+        case (E_AXIS + 3): WRITE(E3_MS3_PIN, ms3); break;
       #endif
       #if HAS_E4_MS_PINS && PIN_EXISTS(E4_MS3)
-        case  7: WRITE(E4_MS3_PIN, ms3); break;
+        case (E_AXIS + 4): WRITE(E4_MS3_PIN, ms3); break;
       #endif
       #if HAS_E5_MS_PINS && PIN_EXISTS(E5_MS3)
-        case  8: WRITE(E5_MS3_PIN, ms3); break;
+        case (E_AXIS + 5): WRITE(E5_MS3_PIN, ms3); break;
       #endif
       #if HAS_E6_MS_PINS && PIN_EXISTS(E6_MS3)
-        case  9: WRITE(E6_MS3_PIN, ms3); break;
+        case (E_AXIS + 6): WRITE(E6_MS3_PIN, ms3); break;
       #endif
       #if HAS_E7_MS_PINS && PIN_EXISTS(E7_MS3)
-        case 10: WRITE(E7_MS3_PIN, ms3); break;
+        case (E_AXIS + 7): WRITE(E7_MS3_PIN, ms3); break;
       #endif
     }
   }

commit c4873a64ecd54dc0bbccb1eaeecd1b5ae2f6aef5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 3 16:14:02 2022 -0500

    🧑‍💻 General and Axis-based bitfield flags (#23989)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 5aa7822e20..82024efdef 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -153,7 +153,7 @@ Stepper stepper; // Singleton
   #endif
 #endif
 
-axis_flags_t Stepper::axis_enabled; // {0}
+stepper_flags_t Stepper::axis_enabled; // {0}
 
 // private:
 

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ✨ Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index af64d9f8bf..5aa7822e20 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -447,6 +447,18 @@ xyze_int8_t Stepper::count_direction{0};
   #define K_APPLY_DIR(v,Q) K_DIR_WRITE(v)
   #define K_APPLY_STEP(v,Q) K_STEP_WRITE(v)
 #endif
+#if HAS_U_AXIS
+  #define U_APPLY_DIR(v,Q) U_DIR_WRITE(v)
+  #define U_APPLY_STEP(v,Q) U_STEP_WRITE(v)
+#endif
+#if HAS_V_AXIS
+  #define V_APPLY_DIR(v,Q) V_DIR_WRITE(v)
+  #define V_APPLY_STEP(v,Q) V_STEP_WRITE(v)
+#endif
+#if HAS_W_AXIS
+  #define W_APPLY_DIR(v,Q) W_DIR_WRITE(v)
+  #define W_APPLY_STEP(v,Q) W_STEP_WRITE(v)
+#endif
 
 #if DISABLED(MIXING_EXTRUDER)
   #define E_APPLY_STEP(v,Q) E_STEP_WRITE(stepper_extruder, v)
@@ -486,9 +498,10 @@ xyze_int8_t Stepper::count_direction{0};
 void Stepper::enable_axis(const AxisEnum axis) {
   #define _CASE_ENABLE(N) case N##_AXIS: ENABLE_AXIS_##N(); break;
   switch (axis) {
-    LINEAR_AXIS_CODE(
+    NUM_AXIS_CODE(
       _CASE_ENABLE(X), _CASE_ENABLE(Y), _CASE_ENABLE(Z),
-      _CASE_ENABLE(I), _CASE_ENABLE(J), _CASE_ENABLE(K)
+      _CASE_ENABLE(I), _CASE_ENABLE(J), _CASE_ENABLE(K),
+      _CASE_ENABLE(U), _CASE_ENABLE(V), _CASE_ENABLE(W)
     );
     default: break;
   }
@@ -505,9 +518,10 @@ bool Stepper::disable_axis(const AxisEnum axis) {
   if (can_disable) {
     #define _CASE_DISABLE(N) case N##_AXIS: DISABLE_AXIS_##N(); break;
     switch (axis) {
-      LINEAR_AXIS_CODE(
+      NUM_AXIS_CODE(
         _CASE_DISABLE(X), _CASE_DISABLE(Y), _CASE_DISABLE(Z),
-        _CASE_DISABLE(I), _CASE_DISABLE(J), _CASE_DISABLE(K)
+        _CASE_DISABLE(I), _CASE_DISABLE(J), _CASE_DISABLE(K),
+        _CASE_DISABLE(U), _CASE_DISABLE(V), _CASE_DISABLE(W)
       );
       default: break;
     }
@@ -550,9 +564,10 @@ bool Stepper::disable_axis(const AxisEnum axis) {
 
 void Stepper::enable_all_steppers() {
   TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
-  LINEAR_AXIS_CODE(
+  NUM_AXIS_CODE(
     enable_axis(X_AXIS), enable_axis(Y_AXIS), enable_axis(Z_AXIS),
-    enable_axis(I_AXIS), enable_axis(J_AXIS), enable_axis(K_AXIS)
+    enable_axis(I_AXIS), enable_axis(J_AXIS), enable_axis(K_AXIS),
+    enable_axis(U_AXIS), enable_axis(V_AXIS), enable_axis(W_AXIS)
   );
   enable_e_steppers();
 
@@ -560,9 +575,10 @@ void Stepper::enable_all_steppers() {
 }
 
 void Stepper::disable_all_steppers() {
-  LINEAR_AXIS_CODE(
+  NUM_AXIS_CODE(
     disable_axis(X_AXIS), disable_axis(Y_AXIS), disable_axis(Z_AXIS),
-    disable_axis(I_AXIS), disable_axis(J_AXIS), disable_axis(K_AXIS)
+    disable_axis(I_AXIS), disable_axis(J_AXIS), disable_axis(K_AXIS),
+    disable_axis(U_AXIS), disable_axis(V_AXIS), disable_axis(W_AXIS)
   );
   disable_e_steppers();
 
@@ -596,6 +612,9 @@ void Stepper::set_directions() {
   TERN_(HAS_I_DIR, SET_STEP_DIR(I));
   TERN_(HAS_J_DIR, SET_STEP_DIR(J));
   TERN_(HAS_K_DIR, SET_STEP_DIR(K));
+  TERN_(HAS_U_DIR, SET_STEP_DIR(U));
+  TERN_(HAS_V_DIR, SET_STEP_DIR(V));
+  TERN_(HAS_W_DIR, SET_STEP_DIR(W));
 
   #if DISABLED(LIN_ADVANCE)
     #if ENABLED(MIXING_EXTRUDER)
@@ -1816,6 +1835,15 @@ void Stepper::pulse_phase_isr() {
       #if HAS_K_STEP
         PULSE_PREP(K);
       #endif
+      #if HAS_U_STEP
+        PULSE_PREP(U);
+      #endif
+      #if HAS_V_STEP
+        PULSE_PREP(V);
+      #endif
+      #if HAS_W_STEP
+        PULSE_PREP(W);
+      #endif
 
       #if EITHER(LIN_ADVANCE, MIXING_EXTRUDER)
         delta_error.e += advance_dividend.e;
@@ -1860,6 +1888,15 @@ void Stepper::pulse_phase_isr() {
     #if HAS_K_STEP
       PULSE_START(K);
     #endif
+    #if HAS_U_STEP
+      PULSE_START(U);
+    #endif
+    #if HAS_V_STEP
+      PULSE_START(V);
+    #endif
+    #if HAS_W_STEP
+      PULSE_START(W);
+    #endif
 
     #if DISABLED(LIN_ADVANCE)
       #if ENABLED(MIXING_EXTRUDER)
@@ -1898,6 +1935,15 @@ void Stepper::pulse_phase_isr() {
     #if HAS_K_STEP
       PULSE_STOP(K);
     #endif
+    #if HAS_U_STEP
+      PULSE_STOP(U);
+    #endif
+    #if HAS_V_STEP
+      PULSE_STOP(V);
+    #endif
+    #if HAS_W_STEP
+      PULSE_STOP(W);
+    #endif
 
     #if DISABLED(LIN_ADVANCE)
       #if ENABLED(MIXING_EXTRUDER)
@@ -2243,13 +2289,16 @@ uint32_t Stepper::block_phase_isr() {
       #endif
 
       axis_bits_t axis_bits = 0;
-      LINEAR_AXIS_CODE(
+      NUM_AXIS_CODE(
         if (X_MOVE_TEST)            SBI(axis_bits, A_AXIS),
         if (Y_MOVE_TEST)            SBI(axis_bits, B_AXIS),
         if (Z_MOVE_TEST)            SBI(axis_bits, C_AXIS),
         if (current_block->steps.i) SBI(axis_bits, I_AXIS),
         if (current_block->steps.j) SBI(axis_bits, J_AXIS),
-        if (current_block->steps.k) SBI(axis_bits, K_AXIS)
+        if (current_block->steps.k) SBI(axis_bits, K_AXIS),
+        if (current_block->steps.u) SBI(axis_bits, U_AXIS),
+        if (current_block->steps.v) SBI(axis_bits, V_AXIS),
+        if (current_block->steps.w) SBI(axis_bits, W_AXIS)
       );
       //if (current_block->steps.e) SBI(axis_bits, E_AXIS);
       //if (current_block->steps.a) SBI(axis_bits, X_HEAD);
@@ -2589,6 +2638,15 @@ void Stepper::init() {
   #if HAS_K_DIR
     K_DIR_INIT();
   #endif
+  #if HAS_U_DIR
+    U_DIR_INIT();
+  #endif
+  #if HAS_V_DIR
+    V_DIR_INIT();
+  #endif
+  #if HAS_W_DIR
+    W_DIR_INIT();
+  #endif
   #if HAS_E0_DIR
     E0_DIR_INIT();
   #endif
@@ -2659,6 +2717,18 @@ void Stepper::init() {
     K_ENABLE_INIT();
     if (!K_ENABLE_ON) K_ENABLE_WRITE(HIGH);
   #endif
+  #if HAS_U_ENABLE
+    U_ENABLE_INIT();
+    if (!U_ENABLE_ON) U_ENABLE_WRITE(HIGH);
+  #endif
+  #if HAS_V_ENABLE
+    V_ENABLE_INIT();
+    if (!V_ENABLE_ON) V_ENABLE_WRITE(HIGH);
+  #endif
+  #if HAS_W_ENABLE
+    W_ENABLE_INIT();
+    if (!W_ENABLE_ON) W_ENABLE_WRITE(HIGH);
+  #endif
   #if HAS_E0_ENABLE
     E0_ENABLE_INIT();
     if (!E_ENABLE_ON) E0_ENABLE_WRITE(HIGH);
@@ -2744,6 +2814,15 @@ void Stepper::init() {
   #if HAS_K_STEP
     AXIS_INIT(K, K);
   #endif
+  #if HAS_U_STEP
+    AXIS_INIT(U, U);
+  #endif
+  #if HAS_V_STEP
+    AXIS_INIT(V, V);
+  #endif
+  #if HAS_W_STEP
+    AXIS_INIT(W, W);
+  #endif
 
   #if E_STEPPERS && HAS_E0_STEP
     E_AXIS_INIT(0);
@@ -2778,13 +2857,16 @@ void Stepper::init() {
 
   // Init direction bits for first moves
   set_directions(0
-    LINEAR_AXIS_GANG(
+    NUM_AXIS_GANG(
       | TERN0(INVERT_X_DIR, _BV(X_AXIS)),
       | TERN0(INVERT_Y_DIR, _BV(Y_AXIS)),
       | TERN0(INVERT_Z_DIR, _BV(Z_AXIS)),
       | TERN0(INVERT_I_DIR, _BV(I_AXIS)),
       | TERN0(INVERT_J_DIR, _BV(J_AXIS)),
-      | TERN0(INVERT_K_DIR, _BV(K_AXIS))
+      | TERN0(INVERT_K_DIR, _BV(K_AXIS)),
+      | TERN0(INVERT_U_DIR, _BV(U_AXIS)),
+      | TERN0(INVERT_V_DIR, _BV(V_AXIS)),
+      | TERN0(INVERT_W_DIR, _BV(W_AXIS))
     )
   );
 
@@ -2820,6 +2902,14 @@ void Stepper::_set_position(const abce_long_t &spos) {
     #elif ENABLED(MARKFORGED_YX)
       count_position.set(spos.a, spos.b - spos.a, spos.c);
     #endif
+    SECONDARY_AXIS_CODE(
+      count_position.i = spos.i,
+      count_position.j = spos.j,
+      count_position.k = spos.k,
+      count_position.u = spos.u,
+      count_position.v = spos.v,
+      count_position.w = spos.w
+    );
     TERN_(HAS_EXTRUDERS, count_position.e = spos.e);
   #else
     // default non-h-bot planning
@@ -2934,13 +3024,16 @@ int32_t Stepper::triggered_position(const AxisEnum axis) {
 
 void Stepper::report_a_position(const xyz_long_t &pos) {
   SERIAL_ECHOLNPGM_P(
-    LIST_N(DOUBLE(LINEAR_AXES),
+    LIST_N(DOUBLE(NUM_AXES),
       TERN(SAYS_A, PSTR(STR_COUNT_A), PSTR(STR_COUNT_X)), pos.x,
       TERN(SAYS_B, PSTR("B:"), SP_Y_LBL), pos.y,
       TERN(SAYS_C, PSTR("C:"), SP_Z_LBL), pos.z,
       SP_I_LBL, pos.i,
       SP_J_LBL, pos.j,
-      SP_K_LBL, pos.k
+      SP_K_LBL, pos.k,
+      SP_U_LBL, pos.u,
+      SP_V_LBL, pos.v,
+      SP_W_LBL, pos.w
     )
   );
 }
@@ -3091,16 +3184,18 @@ void Stepper::report_positions() {
 
           const bool z_direction = direction ^ BABYSTEP_INVERT_Z;
 
-          LINEAR_AXIS_CODE(
+          NUM_AXIS_CODE(
             enable_axis(X_AXIS), enable_axis(Y_AXIS), enable_axis(Z_AXIS),
-            enable_axis(I_AXIS), enable_axis(J_AXIS), enable_axis(K_AXIS)
+            enable_axis(I_AXIS), enable_axis(J_AXIS), enable_axis(K_AXIS),
+            enable_axis(U_AXIS), enable_axis(V_AXIS), enable_axis(W_AXIS)
           );
 
           DIR_WAIT_BEFORE();
 
-          const xyz_byte_t old_dir = LINEAR_AXIS_ARRAY(
+          const xyz_byte_t old_dir = NUM_AXIS_ARRAY(
             X_DIR_READ(), Y_DIR_READ(), Z_DIR_READ(),
-            I_DIR_READ(), J_DIR_READ(), K_DIR_READ()
+            I_DIR_READ(), J_DIR_READ(), K_DIR_READ(),
+            U_DIR_READ(), V_DIR_READ(), W_DIR_READ()
           );
 
           X_DIR_WRITE(INVERT_X_DIR ^ z_direction);
@@ -3119,6 +3214,15 @@ void Stepper::report_positions() {
           #ifdef K_DIR_WRITE
             K_DIR_WRITE(INVERT_K_DIR ^ z_direction);
           #endif
+          #ifdef U_DIR_WRITE
+            U_DIR_WRITE(INVERT_U_DIR ^ z_direction);
+          #endif
+          #ifdef V_DIR_WRITE
+            V_DIR_WRITE(INVERT_V_DIR ^ z_direction);
+          #endif
+          #ifdef W_DIR_WRITE
+            W_DIR_WRITE(INVERT_W_DIR ^ z_direction);
+          #endif
 
           DIR_WAIT_AFTER();
 
@@ -3140,6 +3244,15 @@ void Stepper::report_positions() {
           #ifdef K_STEP_WRITE
             K_STEP_WRITE(!INVERT_K_STEP_PIN);
           #endif
+          #ifdef U_STEP_WRITE
+            U_STEP_WRITE(!INVERT_U_STEP_PIN);
+          #endif
+          #ifdef V_STEP_WRITE
+            V_STEP_WRITE(!INVERT_V_STEP_PIN);
+          #endif
+          #ifdef W_STEP_WRITE
+            W_STEP_WRITE(!INVERT_W_STEP_PIN);
+          #endif
 
           _PULSE_WAIT();
 
@@ -3159,6 +3272,15 @@ void Stepper::report_positions() {
           #ifdef K_STEP_WRITE
             K_STEP_WRITE(INVERT_K_STEP_PIN);
           #endif
+          #ifdef U_STEP_WRITE
+            U_STEP_WRITE(INVERT_U_STEP_PIN);
+          #endif
+           #ifdef V_STEP_WRITE
+            V_STEP_WRITE(INVERT_V_STEP_PIN);
+          #endif
+          #ifdef W_STEP_WRITE
+            W_STEP_WRITE(INVERT_W_STEP_PIN);
+          #endif
 
           // Restore direction bits
           EXTRA_DIR_WAIT_BEFORE();
@@ -3179,6 +3301,15 @@ void Stepper::report_positions() {
           #ifdef K_DIR_WRITE
             K_DIR_WRITE(old_dir.k);
           #endif
+          #ifdef U_DIR_WRITE
+            U_DIR_WRITE(old_dir.u);
+          #endif
+          #ifdef V_DIR_WRITE
+            V_DIR_WRITE(old_dir.v);
+          #endif
+          #ifdef W_DIR_WRITE
+            W_DIR_WRITE(old_dir.w);
+          #endif
 
           EXTRA_DIR_WAIT_AFTER();
 
@@ -3195,6 +3326,15 @@ void Stepper::report_positions() {
       #if HAS_K_AXIS
         case K_AXIS: BABYSTEP_AXIS(K, 0, direction); break;
       #endif
+      #if HAS_U_AXIS
+        case U_AXIS: BABYSTEP_AXIS(U, 0, direction); break;
+      #endif
+      #if HAS_V_AXIS
+        case V_AXIS: BABYSTEP_AXIS(V, 0, direction); break;
+      #endif
+      #if HAS_W_AXIS
+        case W_AXIS: BABYSTEP_AXIS(W, 0, direction); break;
+      #endif
 
       default: break;
     }
@@ -3423,6 +3563,24 @@ void Stepper::report_positions() {
         SET_OUTPUT(K_MS3_PIN);
       #endif
     #endif
+    #if HAS_U_MS_PINS
+      SET_OUTPUT(U_MS1_PIN); SET_OUTPUT(U_MS2_PIN);
+      #if PIN_EXISTS(U_MS3)
+        SET_OUTPUT(U_MS3_PIN);
+      #endif
+    #endif
+    #if HAS_V_MS_PINS
+      SET_OUTPUT(V_MS1_PIN); SET_OUTPUT(V_MS2_PIN);
+      #if PIN_EXISTS(V_MS3)
+        SET_OUTPUT(V_MS3_PIN);
+      #endif
+    #endif
+    #if HAS_W_MS_PINS
+      SET_OUTPUT(W_MS1_PIN); SET_OUTPUT(W_MS2_PIN);
+      #if PIN_EXISTS(W_MS3)
+        SET_OUTPUT(W_MS3_PIN);
+      #endif
+    #endif
     #if HAS_E0_MS_PINS
       SET_OUTPUT(E0_MS1_PIN); SET_OUTPUT(E0_MS2_PIN);
       #if PIN_EXISTS(E0_MS3)
@@ -3548,6 +3706,15 @@ void Stepper::report_positions() {
       #if HAS_K_MS_PINS
         case 13: WRITE(K_MS1_PIN, ms1); break
       #endif
+      #if HAS_U_MS_PINS
+        case 14: WRITE(U_MS1_PIN, ms1); break
+      #endif
+      #if HAS_V_MS_PINS
+        case 15: WRITE(V_MS1_PIN, ms1); break
+      #endif
+      #if HAS_W_MS_PINS
+        case 16: WRITE(W_MS1_PIN, ms1); break
+      #endif
     }
     if (ms2 >= 0) switch (driver) {
       #if HAS_X_MS_PINS || HAS_X2_MS_PINS
@@ -3619,6 +3786,15 @@ void Stepper::report_positions() {
       #if HAS_K_MS_PINS
         case 13: WRITE(K_MS2_PIN, ms2); break
       #endif
+      #if HAS_U_MS_PINS
+        case 14: WRITE(U_MS2_PIN, ms2); break
+      #endif
+      #if HAS_V_MS_PINS
+        case 15: WRITE(V_MS2_PIN, ms2); break
+      #endif
+      #if HAS_W_MS_PINS
+        case 16: WRITE(W_MS2_PIN, ms2); break
+      #endif
     }
     if (ms3 >= 0) switch (driver) {
       #if HAS_X_MS_PINS || HAS_X2_MS_PINS
@@ -3755,6 +3931,24 @@ void Stepper::report_positions() {
         PIN_CHAR(K_MS3);
       #endif
     #endif
+    #if HAS_U_MS_PINS
+      MS_LINE(U);
+      #if PIN_EXISTS(U_MS3)
+        PIN_CHAR(U_MS3);
+      #endif
+    #endif
+    #if HAS_V_MS_PINS
+      MS_LINE(V);
+      #if PIN_EXISTS(V_MS3)
+        PIN_CHAR(V_MS3);
+      #endif
+    #endif
+    #if HAS_W_MS_PINS
+      MS_LINE(W);
+      #if PIN_EXISTS(W_MS3)
+        PIN_CHAR(W_MS3);
+      #endif
+    #endif
     #if HAS_E0_MS_PINS
       MS_LINE(E0);
       #if PIN_EXISTS(E0_MS3)

commit 20b5615305639c9e33907a755cee1c22cc5aa664
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Mar 26 16:44:22 2022 +1300

    ✨ Configurable FREEZE pin state (#23944)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index f83104fe9c..af64d9f8bf 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -189,7 +189,7 @@ bool Stepper::abort_current_block;
 uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
 uint8_t Stepper::steps_per_isr;
 
-#if HAS_FREEZE_PIN
+#if ENABLED(FREEZE_FEATURE)
   bool Stepper::frozen; // = false
 #endif
 
@@ -1643,7 +1643,7 @@ void Stepper::pulse_phase_isr() {
   if (!current_block) return;
 
   // Skipping step processing causes motion to freeze
-  if (TERN0(HAS_FREEZE_PIN, frozen)) return;
+  if (TERN0(FREEZE_FEATURE, frozen)) return;
 
   // Count of pending loops and events for this iteration
   const uint32_t pending_events = step_event_count - step_events_completed;

commit 79b38e0e14074b52e0aeb98b08a686a99a9b1aad
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Fri Mar 11 15:06:49 2022 -0500

    🚸 Update Ender3 V2/S1 Pro UI (#23878)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index a96ed3a651..f83104fe9c 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -497,6 +497,9 @@ void Stepper::enable_axis(const AxisEnum axis) {
 
 bool Stepper::disable_axis(const AxisEnum axis) {
   mark_axis_disabled(axis);
+
+  TERN_(DWIN_LCD_PROUI, set_axis_untrusted(axis)); // MRISCOC workaround: https://github.com/MarlinFirmware/Marlin/issues/23095
+
   // If all the axes that share the enabled bit are disabled
   const bool can_disable = can_axis_disable(axis);
   if (can_disable) {

commit 44eff9a23348dcc117fd1ea9b4b1ef0b54061808
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Feb 17 18:50:31 2022 -0600

    ♻️ Refactor HAL as singleton (#23357)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 5da06a5e50..a96ed3a651 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1474,7 +1474,7 @@ void Stepper::isr() {
   #ifndef __AVR__
     // Disable interrupts, to avoid ISR preemption while we reprogram the period
     // (AVR enters the ISR with global interrupts disabled, so no need to do it here)
-    DISABLE_ISRS();
+    hal.isr_off();
   #endif
 
   // Program timer compare for the maximum period, so it does NOT
@@ -1492,7 +1492,7 @@ void Stepper::isr() {
   hal_timer_t min_ticks;
   do {
     // Enable ISRs to reduce USART processing latency
-    ENABLE_ISRS();
+    hal.isr_on();
 
     if (!nextMainISR) pulse_phase_isr();                            // 0 = Do coordinated axes Stepper pulses
 
@@ -1576,7 +1576,7 @@ void Stepper::isr() {
      * is less than the current count due to something preempting between the
      * read and the write of the new period value).
      */
-    DISABLE_ISRS();
+    hal.isr_off();
 
     /**
      * Get the current tick value + margin
@@ -1611,7 +1611,7 @@ void Stepper::isr() {
   HAL_timer_set_compare(MF_TIMER_STEP, hal_timer_t(next_isr_ticks));
 
   // Don't forget to finally reenable interrupts
-  ENABLE_ISRS();
+  hal.isr_on();
 }
 
 #if MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE
@@ -3260,33 +3260,33 @@ void Stepper::report_positions() {
 
       #elif HAS_MOTOR_CURRENT_PWM
 
-        #define _WRITE_CURRENT_PWM_DUTY(P) set_pwm_duty(pin_t(MOTOR_CURRENT_PWM_## P ##_PIN), 255L * current / (MOTOR_CURRENT_PWM_RANGE))
+        #define _WRITE_CURRENT_PWM(P) hal.set_pwm_duty(pin_t(MOTOR_CURRENT_PWM_## P ##_PIN), 255L * current / (MOTOR_CURRENT_PWM_RANGE))
         switch (driver) {
           case 0:
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)
-              _WRITE_CURRENT_PWM_DUTY(X);
+              _WRITE_CURRENT_PWM(X);
             #endif
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_Y)
-              _WRITE_CURRENT_PWM_DUTY(Y);
+              _WRITE_CURRENT_PWM(Y);
             #endif
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
-              _WRITE_CURRENT_PWM_DUTY(XY);
+              _WRITE_CURRENT_PWM(XY);
             #endif
             break;
           case 1:
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
-              _WRITE_CURRENT_PWM_DUTY(Z);
+              _WRITE_CURRENT_PWM(Z);
             #endif
             break;
           case 2:
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
-              _WRITE_CURRENT_PWM_DUTY(E);
+              _WRITE_CURRENT_PWM(E);
             #endif
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_E0)
-              _WRITE_CURRENT_PWM_DUTY(E0);
+              _WRITE_CURRENT_PWM(E0);
             #endif
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_E1)
-              _WRITE_CURRENT_PWM_DUTY(E1);
+              _WRITE_CURRENT_PWM(E1);
             #endif
             break;
         }
@@ -3308,7 +3308,7 @@ void Stepper::report_positions() {
         #ifdef __SAM3X8E__
           #define _RESET_CURRENT_PWM_FREQ(P) NOOP
         #else
-          #define _RESET_CURRENT_PWM_FREQ(P) set_pwm_frequency(pin_t(P), MOTOR_CURRENT_PWM_FREQUENCY)
+          #define _RESET_CURRENT_PWM_FREQ(P) hal.set_pwm_frequency(pin_t(P), MOTOR_CURRENT_PWM_FREQUENCY)
         #endif
         #define INIT_CURRENT_PWM(P) do{ SET_PWM(MOTOR_CURRENT_PWM_## P ##_PIN); _RESET_CURRENT_PWM_FREQ(MOTOR_CURRENT_PWM_## P ##_PIN); }while(0)
 

commit a323d6732bf691d29ce996b6bfd11cbcc3c9f0a7
Author: MOHAMMAD RASIM <mohammad.rasim96@gmail.com>
Date:   Wed Feb 9 21:29:34 2022 +0300

    🚸 Fix, Improve Power-Loss Recovery (#22828)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index ae8a1ef078..5da06a5e50 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2151,7 +2151,10 @@ uint32_t Stepper::block_phase_isr() {
         cutter.apply_power(current_block->cutter_power);
       #endif
 
-      TERN_(POWER_LOSS_RECOVERY, recovery.info.sdpos = current_block->sdpos);
+      #if ENABLED(POWER_LOSS_RECOVERY)
+        recovery.info.sdpos = current_block->sdpos;
+        recovery.info.current_position = current_block->start_position;
+      #endif
 
       #if ENABLED(DIRECT_STEPPING)
         if (IS_PAGE(current_block)) {

commit 40481947fc1f11a01235c5c55333a4437fc45c5f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 14 03:14:13 2022 -0600

    🧑‍💻 Misc. updates for extra axes (#23521)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 0221f4c8be..ae8a1ef078 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -522,7 +522,7 @@ bool Stepper::disable_axis(const AxisEnum axis) {
     }
   }
 
-  bool Stepper::disable_extruder(E_TERN_(const uint8_t eindex)) {
+  bool Stepper::disable_extruder(E_TERN_(const uint8_t eindex/*=0*/)) {
     IF_DISABLED(HAS_MULTI_EXTRUDER, constexpr uint8_t eindex = 0);
     mark_axis_disabled(E_AXIS E_OPTARG(eindex));
     const bool can_disable = can_axis_disable(E_AXIS E_OPTARG(eindex));
@@ -1688,7 +1688,7 @@ void Stepper::pulse_phase_isr() {
     const bool is_page = IS_PAGE(current_block);
 
     #if ENABLED(DIRECT_STEPPING)
-      // TODO (DerAndere): Add support for HAS_I_AXIS
+      // Direct stepping is currently not ready for HAS_I_AXIS
       if (is_page) {
 
         #if STEPPER_PAGE_FORMAT == SP_4x4D_128
@@ -1929,7 +1929,7 @@ uint32_t Stepper::block_phase_isr() {
     // If current block is finished, reset pointer and finalize state
     if (step_events_completed >= step_event_count) {
       #if ENABLED(DIRECT_STEPPING)
-        // TODO (DerAndere): Add support for HAS_I_AXIS
+        // Direct stepping is currently not ready for HAS_I_AXIS
         #if STEPPER_PAGE_FORMAT == SP_4x4D_128
           #define PAGE_SEGMENT_UPDATE_POS(AXIS) \
             count_position[_AXIS(AXIS)] += page_step_state.bd[_AXIS(AXIS)] - 128 * 7;
@@ -3352,113 +3352,115 @@ void Stepper::report_positions() {
 
   void Stepper::microstep_init() {
     #if HAS_X_MS_PINS
-      SET_OUTPUT(X_MS1_PIN);
-      SET_OUTPUT(X_MS2_PIN);
+      SET_OUTPUT(X_MS1_PIN); SET_OUTPUT(X_MS2_PIN);
       #if PIN_EXISTS(X_MS3)
         SET_OUTPUT(X_MS3_PIN);
       #endif
     #endif
     #if HAS_X2_MS_PINS
-      SET_OUTPUT(X2_MS1_PIN);
-      SET_OUTPUT(X2_MS2_PIN);
+      SET_OUTPUT(X2_MS1_PIN); SET_OUTPUT(X2_MS2_PIN);
       #if PIN_EXISTS(X2_MS3)
         SET_OUTPUT(X2_MS3_PIN);
       #endif
     #endif
     #if HAS_Y_MS_PINS
-      SET_OUTPUT(Y_MS1_PIN);
-      SET_OUTPUT(Y_MS2_PIN);
+      SET_OUTPUT(Y_MS1_PIN); SET_OUTPUT(Y_MS2_PIN);
       #if PIN_EXISTS(Y_MS3)
         SET_OUTPUT(Y_MS3_PIN);
       #endif
     #endif
     #if HAS_Y2_MS_PINS
-      SET_OUTPUT(Y2_MS1_PIN);
-      SET_OUTPUT(Y2_MS2_PIN);
+      SET_OUTPUT(Y2_MS1_PIN); SET_OUTPUT(Y2_MS2_PIN);
       #if PIN_EXISTS(Y2_MS3)
         SET_OUTPUT(Y2_MS3_PIN);
       #endif
     #endif
     #if HAS_Z_MS_PINS
-      SET_OUTPUT(Z_MS1_PIN);
-      SET_OUTPUT(Z_MS2_PIN);
+      SET_OUTPUT(Z_MS1_PIN); SET_OUTPUT(Z_MS2_PIN);
       #if PIN_EXISTS(Z_MS3)
         SET_OUTPUT(Z_MS3_PIN);
       #endif
     #endif
     #if HAS_Z2_MS_PINS
-      SET_OUTPUT(Z2_MS1_PIN);
-      SET_OUTPUT(Z2_MS2_PIN);
+      SET_OUTPUT(Z2_MS1_PIN); SET_OUTPUT(Z2_MS2_PIN);
       #if PIN_EXISTS(Z2_MS3)
         SET_OUTPUT(Z2_MS3_PIN);
       #endif
     #endif
     #if HAS_Z3_MS_PINS
-      SET_OUTPUT(Z3_MS1_PIN);
-      SET_OUTPUT(Z3_MS2_PIN);
+      SET_OUTPUT(Z3_MS1_PIN); SET_OUTPUT(Z3_MS2_PIN);
       #if PIN_EXISTS(Z3_MS3)
         SET_OUTPUT(Z3_MS3_PIN);
       #endif
     #endif
     #if HAS_Z4_MS_PINS
-      SET_OUTPUT(Z4_MS1_PIN);
-      SET_OUTPUT(Z4_MS2_PIN);
+      SET_OUTPUT(Z4_MS1_PIN); SET_OUTPUT(Z4_MS2_PIN);
       #if PIN_EXISTS(Z4_MS3)
         SET_OUTPUT(Z4_MS3_PIN);
       #endif
     #endif
+    #if HAS_I_MS_PINS
+      SET_OUTPUT(I_MS1_PIN); SET_OUTPUT(I_MS2_PIN);
+      #if PIN_EXISTS(I_MS3)
+        SET_OUTPUT(I_MS3_PIN);
+      #endif
+    #endif
+    #if HAS_J_MS_PINS
+      SET_OUTPUT(J_MS1_PIN); SET_OUTPUT(J_MS2_PIN);
+      #if PIN_EXISTS(J_MS3)
+        SET_OUTPUT(J_MS3_PIN);
+      #endif
+    #endif
+    #if HAS_K_MS_PINS
+      SET_OUTPUT(K_MS1_PIN); SET_OUTPUT(K_MS2_PIN);
+      #if PIN_EXISTS(K_MS3)
+        SET_OUTPUT(K_MS3_PIN);
+      #endif
+    #endif
     #if HAS_E0_MS_PINS
-      SET_OUTPUT(E0_MS1_PIN);
-      SET_OUTPUT(E0_MS2_PIN);
+      SET_OUTPUT(E0_MS1_PIN); SET_OUTPUT(E0_MS2_PIN);
       #if PIN_EXISTS(E0_MS3)
         SET_OUTPUT(E0_MS3_PIN);
       #endif
     #endif
     #if HAS_E1_MS_PINS
-      SET_OUTPUT(E1_MS1_PIN);
-      SET_OUTPUT(E1_MS2_PIN);
+      SET_OUTPUT(E1_MS1_PIN); SET_OUTPUT(E1_MS2_PIN);
       #if PIN_EXISTS(E1_MS3)
         SET_OUTPUT(E1_MS3_PIN);
       #endif
     #endif
     #if HAS_E2_MS_PINS
-      SET_OUTPUT(E2_MS1_PIN);
-      SET_OUTPUT(E2_MS2_PIN);
+      SET_OUTPUT(E2_MS1_PIN); SET_OUTPUT(E2_MS2_PIN);
       #if PIN_EXISTS(E2_MS3)
         SET_OUTPUT(E2_MS3_PIN);
       #endif
     #endif
     #if HAS_E3_MS_PINS
-      SET_OUTPUT(E3_MS1_PIN);
-      SET_OUTPUT(E3_MS2_PIN);
+      SET_OUTPUT(E3_MS1_PIN); SET_OUTPUT(E3_MS2_PIN);
       #if PIN_EXISTS(E3_MS3)
         SET_OUTPUT(E3_MS3_PIN);
       #endif
     #endif
     #if HAS_E4_MS_PINS
-      SET_OUTPUT(E4_MS1_PIN);
-      SET_OUTPUT(E4_MS2_PIN);
+      SET_OUTPUT(E4_MS1_PIN); SET_OUTPUT(E4_MS2_PIN);
       #if PIN_EXISTS(E4_MS3)
         SET_OUTPUT(E4_MS3_PIN);
       #endif
     #endif
     #if HAS_E5_MS_PINS
-      SET_OUTPUT(E5_MS1_PIN);
-      SET_OUTPUT(E5_MS2_PIN);
+      SET_OUTPUT(E5_MS1_PIN); SET_OUTPUT(E5_MS2_PIN);
       #if PIN_EXISTS(E5_MS3)
         SET_OUTPUT(E5_MS3_PIN);
       #endif
     #endif
     #if HAS_E6_MS_PINS
-      SET_OUTPUT(E6_MS1_PIN);
-      SET_OUTPUT(E6_MS2_PIN);
+      SET_OUTPUT(E6_MS1_PIN); SET_OUTPUT(E6_MS2_PIN);
       #if PIN_EXISTS(E6_MS3)
         SET_OUTPUT(E6_MS3_PIN);
       #endif
     #endif
     #if HAS_E7_MS_PINS
-      SET_OUTPUT(E7_MS1_PIN);
-      SET_OUTPUT(E7_MS2_PIN);
+      SET_OUTPUT(E7_MS1_PIN); SET_OUTPUT(E7_MS2_PIN);
       #if PIN_EXISTS(E7_MS3)
         SET_OUTPUT(E7_MS3_PIN);
       #endif
@@ -3531,13 +3533,13 @@ void Stepper::report_positions() {
       #if HAS_E7_MS_PINS
         case 10: WRITE(E7_MS1_PIN, ms1); break;
       #endif
-      #if HAS_I_MICROSTEPS
+      #if HAS_I_MS_PINS
         case 11: WRITE(I_MS1_PIN, ms1); break
       #endif
-      #if HAS_J_MICROSTEPS
+      #if HAS_J_MS_PINS
         case 12: WRITE(J_MS1_PIN, ms1); break
       #endif
-      #if HAS_K_MICROSTEPS
+      #if HAS_K_MS_PINS
         case 13: WRITE(K_MS1_PIN, ms1); break
       #endif
     }
@@ -3602,13 +3604,13 @@ void Stepper::report_positions() {
       #if HAS_E7_MS_PINS
         case 10: WRITE(E7_MS2_PIN, ms2); break;
       #endif
-      #if HAS_I_M_PINS
+      #if HAS_I_MS_PINS
         case 11: WRITE(I_MS2_PIN, ms2); break
       #endif
-      #if HAS_J_M_PINS
+      #if HAS_J_MS_PINS
         case 12: WRITE(J_MS2_PIN, ms2); break
       #endif
-      #if HAS_K_M_PINS
+      #if HAS_K_MS_PINS
         case 13: WRITE(K_MS2_PIN, ms2); break
       #endif
     }

commit 2cfde39ecac13eb75f8ce933d2116d1b75db3e4b
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Wed Jan 12 17:28:53 2022 -0600

    🐛 Fix, improve PWM on AVR (#23463)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 9a1c8278ba..0221f4c8be 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3257,33 +3257,33 @@ void Stepper::report_positions() {
 
       #elif HAS_MOTOR_CURRENT_PWM
 
-        #define _WRITE_CURRENT_PWM(P) set_pwm_duty(pin_t(MOTOR_CURRENT_PWM_## P ##_PIN), 255L * current / (MOTOR_CURRENT_PWM_RANGE))
+        #define _WRITE_CURRENT_PWM_DUTY(P) set_pwm_duty(pin_t(MOTOR_CURRENT_PWM_## P ##_PIN), 255L * current / (MOTOR_CURRENT_PWM_RANGE))
         switch (driver) {
           case 0:
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)
-              _WRITE_CURRENT_PWM(X);
+              _WRITE_CURRENT_PWM_DUTY(X);
             #endif
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_Y)
-              _WRITE_CURRENT_PWM(Y);
+              _WRITE_CURRENT_PWM_DUTY(Y);
             #endif
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
-              _WRITE_CURRENT_PWM(XY);
+              _WRITE_CURRENT_PWM_DUTY(XY);
             #endif
             break;
           case 1:
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
-              _WRITE_CURRENT_PWM(Z);
+              _WRITE_CURRENT_PWM_DUTY(Z);
             #endif
             break;
           case 2:
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
-              _WRITE_CURRENT_PWM(E);
+              _WRITE_CURRENT_PWM_DUTY(E);
             #endif
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_E0)
-              _WRITE_CURRENT_PWM(E0);
+              _WRITE_CURRENT_PWM_DUTY(E0);
             #endif
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_E1)
-              _WRITE_CURRENT_PWM(E1);
+              _WRITE_CURRENT_PWM_DUTY(E1);
             #endif
             break;
         }
@@ -3302,34 +3302,37 @@ void Stepper::report_positions() {
 
       #elif HAS_MOTOR_CURRENT_PWM
 
+        #ifdef __SAM3X8E__
+          #define _RESET_CURRENT_PWM_FREQ(P) NOOP
+        #else
+          #define _RESET_CURRENT_PWM_FREQ(P) set_pwm_frequency(pin_t(P), MOTOR_CURRENT_PWM_FREQUENCY)
+        #endif
+        #define INIT_CURRENT_PWM(P) do{ SET_PWM(MOTOR_CURRENT_PWM_## P ##_PIN); _RESET_CURRENT_PWM_FREQ(MOTOR_CURRENT_PWM_## P ##_PIN); }while(0)
+
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)
-          SET_PWM(MOTOR_CURRENT_PWM_X_PIN);
+          INIT_CURRENT_PWM(X);
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_Y)
-          SET_PWM(MOTOR_CURRENT_PWM_Y_PIN);
+          INIT_CURRENT_PWM(Y);
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
-          SET_PWM(MOTOR_CURRENT_PWM_XY_PIN);
+          INIT_CURRENT_PWM(XY);
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
-          SET_PWM(MOTOR_CURRENT_PWM_Z_PIN);
+          INIT_CURRENT_PWM(Z);
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
-          SET_PWM(MOTOR_CURRENT_PWM_E_PIN);
+          INIT_CURRENT_PWM(E);
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_E0)
-          SET_PWM(MOTOR_CURRENT_PWM_E0_PIN);
+          INIT_CURRENT_PWM(E0);
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_E1)
-          SET_PWM(MOTOR_CURRENT_PWM_E1_PIN);
+          INIT_CURRENT_PWM(E1);
         #endif
 
         refresh_motor_power();
 
-        // Set Timer5 to 31khz so the PWM of the motor power is as constant as possible. (removes a buzzing noise)
-        #ifdef __AVR__
-          SET_CS5(PRESCALER_1);
-        #endif
       #endif
     }
 

commit 1bd921d6a69412686fa4b31c4c1e5710de9840cf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 6 05:07:47 2022 -0600

    🎨 Misc. cleanup, comments

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b61f36bbb4..9a1c8278ba 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2346,13 +2346,9 @@ uint32_t Stepper::block_phase_isr() {
         #endif
       #endif // LASER_POWER_INLINE
 
-      // At this point, we must ensure the movement about to execute isn't
-      // trying to force the head against a limit switch. If using interrupt-
-      // driven change detection, and already against a limit then no call to
-      // the endstop_triggered method will be done and the movement will be
-      // done against the endstop. So, check the limits here: If the movement
-      // is against the limits, the block will be marked as to be killed, and
-      // on the next call to this ISR, will be discarded.
+      // If the endstop is already pressed, endstop interrupts won't invoke
+      // endstop_triggered and the move will grind. So check here for a
+      // triggered endstop, which marks the block for discard on the next ISR.
       endstops.update();
 
       #if ENABLED(Z_LATE_ENABLE)

commit e65c12cf96a226019a7456099078ee5cb03f9a49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 2 09:22:36 2022 -0600

    🧑‍💻 Apply axis conditionals

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c100051f98..b61f36bbb4 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -435,15 +435,15 @@ xyze_int8_t Stepper::count_direction{0};
   #define Z_APPLY_STEP(v,Q) Z_STEP_WRITE(v)
 #endif
 
-#if LINEAR_AXES >= 4
+#if HAS_I_AXIS
   #define I_APPLY_DIR(v,Q) I_DIR_WRITE(v)
   #define I_APPLY_STEP(v,Q) I_STEP_WRITE(v)
 #endif
-#if LINEAR_AXES >= 5
+#if HAS_J_AXIS
   #define J_APPLY_DIR(v,Q) J_DIR_WRITE(v)
   #define J_APPLY_STEP(v,Q) J_STEP_WRITE(v)
 #endif
-#if LINEAR_AXES >= 6
+#if HAS_K_AXIS
   #define K_APPLY_DIR(v,Q) K_DIR_WRITE(v)
   #define K_APPLY_STEP(v,Q) K_STEP_WRITE(v)
 #endif
@@ -1688,7 +1688,7 @@ void Stepper::pulse_phase_isr() {
     const bool is_page = IS_PAGE(current_block);
 
     #if ENABLED(DIRECT_STEPPING)
-      // TODO (DerAndere): Add support for LINEAR_AXES >= 4
+      // TODO (DerAndere): Add support for HAS_I_AXIS
       if (is_page) {
 
         #if STEPPER_PAGE_FORMAT == SP_4x4D_128
@@ -1929,7 +1929,7 @@ uint32_t Stepper::block_phase_isr() {
     // If current block is finished, reset pointer and finalize state
     if (step_events_completed >= step_event_count) {
       #if ENABLED(DIRECT_STEPPING)
-        // TODO (DerAndere): Add support for LINEAR_AXES >= 4
+        // TODO (DerAndere): Add support for HAS_I_AXIS
         #if STEPPER_PAGE_FORMAT == SP_4x4D_128
           #define PAGE_SEGMENT_UPDATE_POS(AXIS) \
             count_position[_AXIS(AXIS)] += page_step_state.bd[_AXIS(AXIS)] - 128 * 7;
@@ -3184,13 +3184,13 @@ void Stepper::report_positions() {
 
       } break;
 
-      #if LINEAR_AXES >= 4
+      #if HAS_I_AXIS
         case I_AXIS: BABYSTEP_AXIS(I, 0, direction); break;
       #endif
-      #if LINEAR_AXES >= 5
+      #if HAS_J_AXIS
         case J_AXIS: BABYSTEP_AXIS(J, 0, direction); break;
       #endif
-      #if LINEAR_AXES >= 6
+      #if HAS_K_AXIS
         case K_AXIS: BABYSTEP_AXIS(K, 0, direction); break;
       #endif
 

commit 6a8b9274a31d11c396ce1bc44b3a0b872a4606dc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Dec 25 23:15:17 2021 -0600

    ⏪️ Refactor still needs work
    
    Reverting #23295

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 0f47d66791..c100051f98 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1474,7 +1474,7 @@ void Stepper::isr() {
   #ifndef __AVR__
     // Disable interrupts, to avoid ISR preemption while we reprogram the period
     // (AVR enters the ISR with global interrupts disabled, so no need to do it here)
-    hal.isr_off();
+    DISABLE_ISRS();
   #endif
 
   // Program timer compare for the maximum period, so it does NOT
@@ -1492,7 +1492,7 @@ void Stepper::isr() {
   hal_timer_t min_ticks;
   do {
     // Enable ISRs to reduce USART processing latency
-    hal.isr_on();
+    ENABLE_ISRS();
 
     if (!nextMainISR) pulse_phase_isr();                            // 0 = Do coordinated axes Stepper pulses
 
@@ -1576,7 +1576,7 @@ void Stepper::isr() {
      * is less than the current count due to something preempting between the
      * read and the write of the new period value).
      */
-    hal.isr_off();
+    DISABLE_ISRS();
 
     /**
      * Get the current tick value + margin
@@ -1611,7 +1611,7 @@ void Stepper::isr() {
   HAL_timer_set_compare(MF_TIMER_STEP, hal_timer_t(next_isr_ticks));
 
   // Don't forget to finally reenable interrupts
-  hal.isr_on();
+  ENABLE_ISRS();
 }
 
 #if MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE
@@ -3261,7 +3261,7 @@ void Stepper::report_positions() {
 
       #elif HAS_MOTOR_CURRENT_PWM
 
-        #define _WRITE_CURRENT_PWM(P) hal.set_pwm_duty(pin_t(MOTOR_CURRENT_PWM_## P ##_PIN), 255L * current / (MOTOR_CURRENT_PWM_RANGE))
+        #define _WRITE_CURRENT_PWM(P) set_pwm_duty(pin_t(MOTOR_CURRENT_PWM_## P ##_PIN), 255L * current / (MOTOR_CURRENT_PWM_RANGE))
         switch (driver) {
           case 0:
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)

commit e211ff148c39bf5dace72de7cffbb83f19d3f1bf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 24 21:33:59 2021 -0600

    ♻️ Refactor HAL as singleton (#23295)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c100051f98..0f47d66791 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1474,7 +1474,7 @@ void Stepper::isr() {
   #ifndef __AVR__
     // Disable interrupts, to avoid ISR preemption while we reprogram the period
     // (AVR enters the ISR with global interrupts disabled, so no need to do it here)
-    DISABLE_ISRS();
+    hal.isr_off();
   #endif
 
   // Program timer compare for the maximum period, so it does NOT
@@ -1492,7 +1492,7 @@ void Stepper::isr() {
   hal_timer_t min_ticks;
   do {
     // Enable ISRs to reduce USART processing latency
-    ENABLE_ISRS();
+    hal.isr_on();
 
     if (!nextMainISR) pulse_phase_isr();                            // 0 = Do coordinated axes Stepper pulses
 
@@ -1576,7 +1576,7 @@ void Stepper::isr() {
      * is less than the current count due to something preempting between the
      * read and the write of the new period value).
      */
-    DISABLE_ISRS();
+    hal.isr_off();
 
     /**
      * Get the current tick value + margin
@@ -1611,7 +1611,7 @@ void Stepper::isr() {
   HAL_timer_set_compare(MF_TIMER_STEP, hal_timer_t(next_isr_ticks));
 
   // Don't forget to finally reenable interrupts
-  ENABLE_ISRS();
+  hal.isr_on();
 }
 
 #if MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE
@@ -3261,7 +3261,7 @@ void Stepper::report_positions() {
 
       #elif HAS_MOTOR_CURRENT_PWM
 
-        #define _WRITE_CURRENT_PWM(P) set_pwm_duty(pin_t(MOTOR_CURRENT_PWM_## P ##_PIN), 255L * current / (MOTOR_CURRENT_PWM_RANGE))
+        #define _WRITE_CURRENT_PWM(P) hal.set_pwm_duty(pin_t(MOTOR_CURRENT_PWM_## P ##_PIN), 255L * current / (MOTOR_CURRENT_PWM_RANGE))
         switch (driver) {
           case 0:
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)

commit 0077d982cdbc414c60b2be8c7800317883ce6413
Author: BigTreeTech <38851044+bigtreetech@users.noreply.github.com>
Date:   Sat Dec 11 03:38:03 2021 +0800

    ✨ BigTreeTech SKR mini E3 V3.0 (STM32G0B1RET6) (#23283)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b93dd21198..c100051f98 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1380,7 +1380,7 @@ void Stepper::set_directions() {
     }
 
     FORCE_INLINE int32_t Stepper::_eval_bezier_curve(const uint32_t curr_step) {
-      #if defined(__arm__) || defined(__thumb__)
+      #if (defined(__arm__) || defined(__thumb__)) && !defined(STM32G0B1xx) // TODO: Test define STM32G0xx versus STM32G0B1xx
 
         // For ARM Cortex M3/M4 CPUs, we have the optimized assembler version, that takes 43 cycles to execute
         uint32_t flo = 0;

commit 0539e870de30877a38c78d29a304a97a6068cc80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 27 18:33:32 2021 -0600

    🎨 Rename HAL timer elements

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 69818aff7a..b93dd21198 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -464,8 +464,8 @@ xyze_int8_t Stepper::count_direction{0};
 #define PULSE_LOW_TICK_COUNT hal_timer_t(NS_TO_PULSE_TIMER_TICKS(_MIN_PULSE_LOW_NS - _MIN(_MIN_PULSE_LOW_NS, TIMER_SETUP_NS)))
 
 #define USING_TIMED_PULSE() hal_timer_t start_pulse_count = 0
-#define START_TIMED_PULSE(DIR) (start_pulse_count = HAL_timer_get_count(PULSE_TIMER_NUM))
-#define AWAIT_TIMED_PULSE(DIR) while (PULSE_##DIR##_TICK_COUNT > HAL_timer_get_count(PULSE_TIMER_NUM) - start_pulse_count) { }
+#define START_TIMED_PULSE(DIR) (start_pulse_count = HAL_timer_get_count(MF_TIMER_PULSE))
+#define AWAIT_TIMED_PULSE(DIR) while (PULSE_##DIR##_TICK_COUNT > HAL_timer_get_count(MF_TIMER_PULSE) - start_pulse_count) { }
 #define START_HIGH_PULSE()  START_TIMED_PULSE(HIGH)
 #define AWAIT_HIGH_PULSE()  AWAIT_TIMED_PULSE(HIGH)
 #define START_LOW_PULSE()   START_TIMED_PULSE(LOW)
@@ -1454,11 +1454,11 @@ void Stepper::set_directions() {
  */
 
 HAL_STEP_TIMER_ISR() {
-  HAL_timer_isr_prologue(STEP_TIMER_NUM);
+  HAL_timer_isr_prologue(MF_TIMER_STEP);
 
   Stepper::isr();
 
-  HAL_timer_isr_epilogue(STEP_TIMER_NUM);
+  HAL_timer_isr_epilogue(MF_TIMER_STEP);
 }
 
 #ifdef CPU_32_BIT
@@ -1480,7 +1480,7 @@ void Stepper::isr() {
   // Program timer compare for the maximum period, so it does NOT
   // flag an interrupt while this ISR is running - So changes from small
   // periods to big periods are respected and the timer does not reset to 0
-  HAL_timer_set_compare(STEP_TIMER_NUM, hal_timer_t(HAL_TIMER_TYPE_MAX));
+  HAL_timer_set_compare(MF_TIMER_STEP, hal_timer_t(HAL_TIMER_TYPE_MAX));
 
   // Count of ticks for the next ISR
   hal_timer_t next_isr_ticks = 0;
@@ -1584,7 +1584,7 @@ void Stepper::isr() {
      * On AVR the ISR epilogue+prologue is estimated at 100 instructions - Give 8µs as margin
      * On ARM the ISR epilogue+prologue is estimated at 20 instructions - Give 1µs as margin
      */
-    min_ticks = HAL_timer_get_count(STEP_TIMER_NUM) + hal_timer_t(
+    min_ticks = HAL_timer_get_count(MF_TIMER_STEP) + hal_timer_t(
       #ifdef __AVR__
         8
       #else
@@ -1608,7 +1608,7 @@ void Stepper::isr() {
   // sure that the time has not arrived yet - Warrantied by the scheduler
 
   // Set the next ISR to fire at the proper time
-  HAL_timer_set_compare(STEP_TIMER_NUM, hal_timer_t(next_isr_ticks));
+  HAL_timer_set_compare(MF_TIMER_STEP, hal_timer_t(next_isr_ticks));
 
   // Don't forget to finally reenable interrupts
   ENABLE_ISRS();
@@ -2769,7 +2769,7 @@ void Stepper::init() {
   #endif
 
   #if DISABLED(I2S_STEPPER_STREAM)
-    HAL_timer_start(STEP_TIMER_NUM, 122); // Init Stepper ISR to 122 Hz for quick starting
+    HAL_timer_start(MF_TIMER_STEP, 122); // Init Stepper ISR to 122 Hz for quick starting
     wake_up();
     sei();
   #endif
@@ -2980,8 +2980,8 @@ void Stepper::report_positions() {
   #define EXTRA_CYCLES_BABYSTEP (STEP_PULSE_CYCLES - (CYCLES_EATEN_BABYSTEP))
 
   #if EXTRA_CYCLES_BABYSTEP > 20
-    #define _SAVE_START() const hal_timer_t pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM)
-    #define _PULSE_WAIT() while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
+    #define _SAVE_START() const hal_timer_t pulse_start = HAL_timer_get_count(MF_TIMER_PULSE)
+    #define _PULSE_WAIT() while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(HAL_timer_get_count(MF_TIMER_PULSE) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
   #else
     #define _SAVE_START() NOOP
     #if EXTRA_CYCLES_BABYSTEP > 0

commit e5154ec28179c7dc7b58a830412e7cb09c2f878c
Author: John Robertson <john@cirtech.co.uk>
Date:   Tue Nov 23 21:24:24 2021 +0000

    ✨ MarkForged YX kinematics (#23163)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 2c8933266f..69818aff7a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2212,6 +2212,8 @@ uint32_t Stepper::block_phase_isr() {
           #define Y_CMP(A,B) ((A)!=(B))
         #endif
         #define Y_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && Y_CMP(D_(1),D_(2))) )
+      #elif ENABLED(MARKFORGED_YX)
+        #define Y_MOVE_TEST (current_block->steps.a != current_block->steps.b)
       #else
         #define Y_MOVE_TEST !!current_block->steps.b
       #endif
@@ -2800,7 +2802,7 @@ void Stepper::init() {
  * derive the current XYZE position later on.
  */
 void Stepper::_set_position(const abce_long_t &spos) {
-  #if EITHER(IS_CORE, MARKFORGED_XY)
+  #if ANY(IS_CORE, MARKFORGED_XY, MARKFORGED_YX)
     #if CORE_IS_XY
       // corexy positioning
       // these equations follow the form of the dA and dB equations on https://www.corexy.com/theory.html
@@ -2813,6 +2815,8 @@ void Stepper::_set_position(const abce_long_t &spos) {
       count_position.set(spos.a, spos.b + spos.c, CORESIGN(spos.b - spos.c));
     #elif ENABLED(MARKFORGED_XY)
       count_position.set(spos.a - spos.b, spos.b, spos.c);
+    #elif ENABLED(MARKFORGED_YX)
+      count_position.set(spos.a, spos.b - spos.a, spos.c);
     #endif
     TERN_(HAS_EXTRUDERS, count_position.e = spos.e);
   #else
@@ -2884,6 +2888,10 @@ void Stepper::endstop_triggered(const AxisEnum axis) {
       axis == CORE_AXIS_1
         ? count_position[CORE_AXIS_1] - count_position[CORE_AXIS_2]
         : count_position[CORE_AXIS_2]
+    #elif ENABLED(MARKFORGED_YX)
+      axis == CORE_AXIS_1
+        ? count_position[CORE_AXIS_1]
+        : count_position[CORE_AXIS_2] - count_position[CORE_AXIS_1]
     #else // !IS_CORE
       count_position[axis]
     #endif
@@ -2912,10 +2920,10 @@ int32_t Stepper::triggered_position(const AxisEnum axis) {
   return v;
 }
 
-#if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, IS_SCARA, DELTA)
+#if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX, IS_SCARA, DELTA)
   #define SAYS_A 1
 #endif
-#if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY, IS_SCARA, DELTA)
+#if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY, MARKFORGED_YX, IS_SCARA, DELTA)
   #define SAYS_B 1
 #endif
 #if ANY(CORE_IS_XZ, CORE_IS_YZ, DELTA)

commit da830e6ced7f7c7e509e748104245064d1c1b265
Author: Andrei M <22990561+andrei-moraru@users.noreply.github.com>
Date:   Tue Nov 2 01:47:16 2021 -0400

    ⚗️ Use pwm_set_duty over analogWrite to set PWM (#23048)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index a54bf53c49..2c8933266f 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3253,7 +3253,7 @@ void Stepper::report_positions() {
 
       #elif HAS_MOTOR_CURRENT_PWM
 
-        #define _WRITE_CURRENT_PWM(P) analogWrite(pin_t(MOTOR_CURRENT_PWM_## P ##_PIN), 255L * current / (MOTOR_CURRENT_PWM_RANGE))
+        #define _WRITE_CURRENT_PWM(P) set_pwm_duty(pin_t(MOTOR_CURRENT_PWM_## P ##_PIN), 255L * current / (MOTOR_CURRENT_PWM_RANGE))
         switch (driver) {
           case 0:
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)

commit b619a7184406a3fff2d67d33f1f82159721bb1bc
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Mon Oct 25 19:12:07 2021 +1300

    🐛 Fix børken E_DUAL_STEPPER_DRIVERS (#23017)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index e374b85d7a..a54bf53c49 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2744,7 +2744,7 @@ void Stepper::init() {
   #if E_STEPPERS && HAS_E0_STEP
     E_AXIS_INIT(0);
   #endif
-  #if E_STEPPERS > 1 && HAS_E1_STEP
+  #if (E_STEPPERS > 1 || ENABLED(E_DUAL_STEPPER_DRIVERS)) && HAS_E1_STEP
     E_AXIS_INIT(1);
   #endif
   #if E_STEPPERS > 2 && HAS_E2_STEP

commit 8e4953514c893410c402ba6486f86580385effd9
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Oct 12 23:19:05 2021 -0400

    ⚡️ Formbot ST7920 delays, intentional X2 pins (#22915)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 3a1ee39c52..e374b85d7a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2614,7 +2614,7 @@ void Stepper::init() {
   #if HAS_X_ENABLE
     X_ENABLE_INIT();
     if (!X_ENABLE_ON) X_ENABLE_WRITE(HIGH);
-    #if EITHER(DUAL_X_CARRIAGE, X_DUAL_STEPPER_DRIVERS) && HAS_X2_ENABLE
+    #if BOTH(HAS_X2_STEPPER, HAS_X2_ENABLE)
       X2_ENABLE_INIT();
       if (!X_ENABLE_ON) X2_ENABLE_WRITE(HIGH);
     #endif

commit 33e0855e2c173680865aaa6c6aa93047d63fc469
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 01:07:51 2021 -0500

    ⚡️ Handle shared enable pins (#22824)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index aa68ccd4ec..3a1ee39c52 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -123,6 +123,10 @@ Stepper stepper; // Singleton
   bool L64XX_OK_to_power_up = false;  // flag to keep L64xx steppers powered down after a reset or power up
 #endif
 
+#if ENABLED(AUTO_POWER_CONTROL)
+  #include "../feature/power.h"
+#endif
+
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/powerloss.h"
 #endif
@@ -131,6 +135,10 @@ Stepper stepper; // Singleton
   #include "../feature/spindle_laser.h"
 #endif
 
+#if ENABLED(EXTENSIBLE_UI)
+  #include "../lcd/extui/ui_api.h"
+#endif
+
 // public:
 
 #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
@@ -145,6 +153,8 @@ Stepper stepper; // Singleton
   #endif
 #endif
 
+axis_flags_t Stepper::axis_enabled; // {0}
+
 // private:
 
 block_t* Stepper::current_block; // (= nullptr) A pointer to the block currently being traced
@@ -473,6 +483,89 @@ xyze_int8_t Stepper::count_direction{0};
   #define DIR_WAIT_AFTER()
 #endif
 
+void Stepper::enable_axis(const AxisEnum axis) {
+  #define _CASE_ENABLE(N) case N##_AXIS: ENABLE_AXIS_##N(); break;
+  switch (axis) {
+    LINEAR_AXIS_CODE(
+      _CASE_ENABLE(X), _CASE_ENABLE(Y), _CASE_ENABLE(Z),
+      _CASE_ENABLE(I), _CASE_ENABLE(J), _CASE_ENABLE(K)
+    );
+    default: break;
+  }
+  mark_axis_enabled(axis);
+}
+
+bool Stepper::disable_axis(const AxisEnum axis) {
+  mark_axis_disabled(axis);
+  // If all the axes that share the enabled bit are disabled
+  const bool can_disable = can_axis_disable(axis);
+  if (can_disable) {
+    #define _CASE_DISABLE(N) case N##_AXIS: DISABLE_AXIS_##N(); break;
+    switch (axis) {
+      LINEAR_AXIS_CODE(
+        _CASE_DISABLE(X), _CASE_DISABLE(Y), _CASE_DISABLE(Z),
+        _CASE_DISABLE(I), _CASE_DISABLE(J), _CASE_DISABLE(K)
+      );
+      default: break;
+    }
+  }
+  return can_disable;
+}
+
+#if HAS_EXTRUDERS
+
+  void Stepper::enable_extruder(E_TERN_(const uint8_t eindex)) {
+    IF_DISABLED(HAS_MULTI_EXTRUDER, constexpr uint8_t eindex = 0);
+    #define _CASE_ENA_E(N) case N: ENABLE_AXIS_E##N(); mark_axis_enabled(E_AXIS E_OPTARG(eindex)); break;
+    switch (eindex) {
+      REPEAT(E_STEPPERS, _CASE_ENA_E)
+    }
+  }
+
+  bool Stepper::disable_extruder(E_TERN_(const uint8_t eindex)) {
+    IF_DISABLED(HAS_MULTI_EXTRUDER, constexpr uint8_t eindex = 0);
+    mark_axis_disabled(E_AXIS E_OPTARG(eindex));
+    const bool can_disable = can_axis_disable(E_AXIS E_OPTARG(eindex));
+    if (can_disable) {
+      #define _CASE_DIS_E(N) case N: DISABLE_AXIS_E##N(); break;
+      switch (eindex) { REPEAT(E_STEPPERS, _CASE_DIS_E) }
+    }
+    return can_disable;
+  }
+
+  void Stepper::enable_e_steppers() {
+    #define _ENA_E(N) ENABLE_EXTRUDER(N);
+    REPEAT(EXTRUDERS, _ENA_E)
+  }
+
+  void Stepper::disable_e_steppers() {
+    #define _DIS_E(N) DISABLE_EXTRUDER(N);
+    REPEAT(EXTRUDERS, _DIS_E)
+  }
+
+#endif
+
+void Stepper::enable_all_steppers() {
+  TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
+  LINEAR_AXIS_CODE(
+    enable_axis(X_AXIS), enable_axis(Y_AXIS), enable_axis(Z_AXIS),
+    enable_axis(I_AXIS), enable_axis(J_AXIS), enable_axis(K_AXIS)
+  );
+  enable_e_steppers();
+
+  TERN_(EXTENSIBLE_UI, ExtUI::onSteppersEnabled());
+}
+
+void Stepper::disable_all_steppers() {
+  LINEAR_AXIS_CODE(
+    disable_axis(X_AXIS), disable_axis(Y_AXIS), disable_axis(Z_AXIS),
+    disable_axis(I_AXIS), disable_axis(J_AXIS), disable_axis(K_AXIS)
+  );
+  disable_e_steppers();
+
+  TERN_(EXTENSIBLE_UI, ExtUI::onSteppersDisabled());
+}
+
 /**
  * Set the stepper direction of each axis
  *
@@ -494,24 +587,12 @@ void Stepper::set_directions() {
       count_direction[_AXIS(A)] = 1;            \
     }
 
-  #if HAS_X_DIR
-    SET_STEP_DIR(X); // A
-  #endif
-  #if HAS_Y_DIR
-    SET_STEP_DIR(Y); // B
-  #endif
-  #if HAS_Z_DIR
-    SET_STEP_DIR(Z); // C
-  #endif
-  #if HAS_I_DIR
-    SET_STEP_DIR(I);
-  #endif
-  #if HAS_J_DIR
-    SET_STEP_DIR(J);
-  #endif
-  #if HAS_K_DIR
-    SET_STEP_DIR(K);
-  #endif
+  TERN_(HAS_X_DIR, SET_STEP_DIR(X)); // A
+  TERN_(HAS_Y_DIR, SET_STEP_DIR(Y)); // B
+  TERN_(HAS_Z_DIR, SET_STEP_DIR(Z)); // C
+  TERN_(HAS_I_DIR, SET_STEP_DIR(I));
+  TERN_(HAS_J_DIR, SET_STEP_DIR(J));
+  TERN_(HAS_K_DIR, SET_STEP_DIR(K));
 
   #if DISABLED(LIN_ADVANCE)
     #if ENABLED(MIXING_EXTRUDER)
@@ -2204,7 +2285,7 @@ uint32_t Stepper::block_phase_isr() {
 
       TERN_(MIXING_EXTRUDER, mixer.stepper_setup(current_block->b_color));
 
-      TERN_(HAS_MULTI_EXTRUDER, stepper_extruder = current_block->extruder);
+      E_TERN_(stepper_extruder = current_block->extruder);
 
       // Initialize the trapezoid generator from the current block.
       #if ENABLED(LIN_ADVANCE)
@@ -2227,7 +2308,7 @@ uint32_t Stepper::block_phase_isr() {
         || current_block->direction_bits != last_direction_bits
         || TERN(MIXING_EXTRUDER, false, stepper_extruder != last_moved_extruder)
       ) {
-        TERN_(HAS_MULTI_EXTRUDER, last_moved_extruder = stepper_extruder);
+        E_TERN_(last_moved_extruder = stepper_extruder);
         TERN_(HAS_L64XX, L64XX_OK_to_power_up = true);
         set_directions(current_block->direction_bits);
       }
@@ -2276,7 +2357,7 @@ uint32_t Stepper::block_phase_isr() {
         // If delayed Z enable, enable it now. This option will severely interfere with
         // timing between pulses when chaining motion between blocks, and it could lead
         // to lost steps in both X and Y axis, so avoid using it unless strictly necessary!!
-        if (current_block->steps.z) ENABLE_AXIS_Z();
+        if (current_block->steps.z) enable_axis(Z_AXIS);
       #endif
 
       // Mark the time_nominal as not calculated yet
@@ -2872,7 +2953,7 @@ void Stepper::report_positions() {
 
 #if ENABLED(BABYSTEPPING)
 
-  #define _ENABLE_AXIS(AXIS) ENABLE_AXIS_## AXIS()
+  #define _ENABLE_AXIS(A) enable_axis(_AXIS(A))
   #define _READ_DIR(AXIS) AXIS ##_DIR_READ()
   #define _INVERT_DIR(AXIS) INVERT_## AXIS ##_DIR
   #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)
@@ -3000,8 +3081,10 @@ void Stepper::report_positions() {
 
           const bool z_direction = direction ^ BABYSTEP_INVERT_Z;
 
-          ENABLE_AXIS_X(); ENABLE_AXIS_Y(); ENABLE_AXIS_Z();
-          ENABLE_AXIS_I(); ENABLE_AXIS_J(); ENABLE_AXIS_K();
+          LINEAR_AXIS_CODE(
+            enable_axis(X_AXIS), enable_axis(Y_AXIS), enable_axis(Z_AXIS),
+            enable_axis(I_AXIS), enable_axis(J_AXIS), enable_axis(K_AXIS)
+          );
 
           DIR_WAIT_BEFORE();
 

commit dc5bef62ba185461ba969db6af996ebc93a33ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 23 10:01:37 2021 -0500

    🎨 Various multi-axis patches (#22823)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 83aa15063b..aa68ccd4ec 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -149,8 +149,8 @@ Stepper stepper; // Singleton
 
 block_t* Stepper::current_block; // (= nullptr) A pointer to the block currently being traced
 
-uint8_t Stepper::last_direction_bits, // = 0
-        Stepper::axis_did_move; // = 0
+axis_bits_t Stepper::last_direction_bits, // = 0
+            Stepper::axis_did_move; // = 0
 
 bool Stepper::abort_current_block;
 
@@ -503,17 +503,14 @@ void Stepper::set_directions() {
   #if HAS_Z_DIR
     SET_STEP_DIR(Z); // C
   #endif
-
   #if HAS_I_DIR
-    SET_STEP_DIR(I); // I
+    SET_STEP_DIR(I);
   #endif
-
   #if HAS_J_DIR
-    SET_STEP_DIR(J); // J
+    SET_STEP_DIR(J);
   #endif
-
   #if HAS_K_DIR
-    SET_STEP_DIR(K); // K
+    SET_STEP_DIR(K);
   #endif
 
   #if DISABLED(LIN_ADVANCE)
@@ -1635,7 +1632,7 @@ void Stepper::pulse_phase_isr() {
             case 0: {
               const uint8_t low = page_step_state.page[page_step_state.segment_idx],
                            high = page_step_state.page[page_step_state.segment_idx + 1];
-              uint8_t dm = last_direction_bits;
+              axis_bits_t dm = last_direction_bits;
 
               PAGE_SEGMENT_UPDATE(X, low >> 4);
               PAGE_SEGMENT_UPDATE(Y, low & 0xF);
@@ -2156,7 +2153,7 @@ uint32_t Stepper::block_phase_isr() {
         #define Z_MOVE_TEST !!current_block->steps.c
       #endif
 
-      uint8_t axis_bits = 0;
+      axis_bits_t axis_bits = 0;
       LINEAR_AXIS_CODE(
         if (X_MOVE_TEST)            SBI(axis_bits, A_AXIS),
         if (Y_MOVE_TEST)            SBI(axis_bits, B_AXIS),
@@ -3003,16 +3000,15 @@ void Stepper::report_positions() {
 
           const bool z_direction = direction ^ BABYSTEP_INVERT_Z;
 
-          ENABLE_AXIS_X();
-          ENABLE_AXIS_Y();
-          ENABLE_AXIS_Z();
-          ENABLE_AXIS_I();
-          ENABLE_AXIS_J();
-          ENABLE_AXIS_K();
+          ENABLE_AXIS_X(); ENABLE_AXIS_Y(); ENABLE_AXIS_Z();
+          ENABLE_AXIS_I(); ENABLE_AXIS_J(); ENABLE_AXIS_K();
 
           DIR_WAIT_BEFORE();
 
-          const xyz_byte_t old_dir = LINEAR_AXIS_ARRAY(X_DIR_READ(), Y_DIR_READ(), Z_DIR_READ(), I_DIR_READ(), J_DIR_READ(), K_DIR_READ());
+          const xyz_byte_t old_dir = LINEAR_AXIS_ARRAY(
+            X_DIR_READ(), Y_DIR_READ(), Z_DIR_READ(),
+            I_DIR_READ(), J_DIR_READ(), K_DIR_READ()
+          );
 
           X_DIR_WRITE(INVERT_X_DIR ^ z_direction);
           #ifdef Y_DIR_WRITE

commit 798a8a7a0852c12fb8640c4a531fac70fbc57eda
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 13 16:28:12 2021 -0500

    🔧 SPINDLE_LASER_PWM => SPINDLE_LASER_USE_PWM

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index aea5f88c06..83aa15063b 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2255,7 +2255,7 @@ uint32_t Stepper::block_phase_isr() {
           }
         #else
           if (stat.isPlanned) {                        // Planner controls the laser
-            #if ENABLED(SPINDLE_LASER_PWM)
+            #if ENABLED(SPINDLE_LASER_USE_PWM)
               cutter.ocr_set_power(
                 stat.isEnabled ? current_block->laser.power : 0 // ON with power or OFF
               );
@@ -2303,7 +2303,7 @@ uint32_t Stepper::block_phase_isr() {
         // This should mean ending file with 'M5 I' will stop the laser; thus the inline flag isn't needed
         const power_status_t stat = planner.laser_inline.status;
         if (stat.isPlanned) {             // Planner controls the laser
-          #if ENABLED(SPINDLE_LASER_PWM)
+          #if ENABLED(SPINDLE_LASER_USE_PWM)
             cutter.ocr_set_power(
               stat.isEnabled ? planner.laser_inline.power : 0 // ON with power or OFF
             );

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    🎨 Fewer serial macros

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index f9245336f3..aea5f88c06 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2845,7 +2845,7 @@ int32_t Stepper::triggered_position(const AxisEnum axis) {
 #endif
 
 void Stepper::report_a_position(const xyz_long_t &pos) {
-  SERIAL_ECHOLNPAIR_P(
+  SERIAL_ECHOLNPGM_P(
     LIST_N(DOUBLE(LINEAR_AXES),
       TERN(SAYS_A, PSTR(STR_COUNT_A), PSTR(STR_COUNT_X)), pos.x,
       TERN(SAYS_B, PSTR("B:"), SP_Y_LBL), pos.y,
@@ -3167,7 +3167,7 @@ void Stepper::report_positions() {
 
       #if HAS_MOTOR_CURRENT_SPI
 
-        //SERIAL_ECHOLNPAIR("Digipotss current ", current);
+        //SERIAL_ECHOLNPGM("Digipotss current ", current);
 
         const uint8_t digipot_ch[] = DIGIPOT_CHANNELS;
         set_digipot_value_spi(digipot_ch[driver], current);

commit 845d42ef40e1adc04315779d31eb55dac2218689
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 6 15:34:12 2021 -0500

    🎨 Misc. Spindle/Laser (etc.) cleanup

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 50d8ad4260..f9245336f3 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1914,7 +1914,7 @@ uint32_t Stepper::block_phase_isr() {
                     laser_trap.acc_step_count += current_block->laser.entry_per;
                     if (laser_trap.cur_power < current_block->laser.power) laser_trap.cur_power++;
                   }
-                  cutter.set_ocr_power(laser_trap.cur_power);
+                  cutter.ocr_set_power(laser_trap.cur_power);
                 }
               }
             #else
@@ -1923,7 +1923,7 @@ uint32_t Stepper::block_phase_isr() {
               else {
                 laser_trap.till_update = LASER_POWER_INLINE_TRAPEZOID_CONT_PER;
                 laser_trap.cur_power = (current_block->laser.power * acc_step_rate) / current_block->nominal_rate;
-                cutter.set_ocr_power(laser_trap.cur_power); // Cycle efficiency is irrelevant it the last line was many cycles
+                cutter.ocr_set_power(laser_trap.cur_power); // Cycle efficiency is irrelevant it the last line was many cycles
               }
             #endif
           }
@@ -1991,7 +1991,7 @@ uint32_t Stepper::block_phase_isr() {
                     laser_trap.acc_step_count += current_block->laser.exit_per;
                     if (laser_trap.cur_power > current_block->laser.power_exit) laser_trap.cur_power--;
                   }
-                  cutter.set_ocr_power(laser_trap.cur_power);
+                  cutter.ocr_set_power(laser_trap.cur_power);
                 }
               }
             #else
@@ -2000,7 +2000,7 @@ uint32_t Stepper::block_phase_isr() {
               else {
                 laser_trap.till_update = LASER_POWER_INLINE_TRAPEZOID_CONT_PER;
                 laser_trap.cur_power = (current_block->laser.power * step_rate) / current_block->nominal_rate;
-                cutter.set_ocr_power(laser_trap.cur_power); // Cycle efficiency isn't relevant when the last line was many cycles
+                cutter.ocr_set_power(laser_trap.cur_power); // Cycle efficiency isn't relevant when the last line was many cycles
               }
             #endif
           }
@@ -2028,7 +2028,7 @@ uint32_t Stepper::block_phase_isr() {
           if (laser_trap.enabled) {
             if (!laser_trap.cruise_set) {
               laser_trap.cur_power = current_block->laser.power;
-              cutter.set_ocr_power(laser_trap.cur_power);
+              cutter.ocr_set_power(laser_trap.cur_power);
               laser_trap.cruise_set = true;
             }
             #if ENABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
@@ -2249,14 +2249,14 @@ uint32_t Stepper::block_phase_isr() {
           #endif
           // Always have PWM in this case
           if (stat.isPlanned) {                        // Planner controls the laser
-            cutter.set_ocr_power(
+            cutter.ocr_set_power(
               stat.isEnabled ? laser_trap.cur_power : 0 // ON with power or OFF
             );
           }
         #else
           if (stat.isPlanned) {                        // Planner controls the laser
             #if ENABLED(SPINDLE_LASER_PWM)
-              cutter.set_ocr_power(
+              cutter.ocr_set_power(
                 stat.isEnabled ? current_block->laser.power : 0 // ON with power or OFF
               );
             #else
@@ -2304,7 +2304,7 @@ uint32_t Stepper::block_phase_isr() {
         const power_status_t stat = planner.laser_inline.status;
         if (stat.isPlanned) {             // Planner controls the laser
           #if ENABLED(SPINDLE_LASER_PWM)
-            cutter.set_ocr_power(
+            cutter.ocr_set_power(
               stat.isEnabled ? planner.laser_inline.power : 0 // ON with power or OFF
             );
           #else

commit ff95a93ecc299dc8c811012e7e77e32427649cf8
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Fri Sep 3 05:08:40 2021 +0200

    🐛 Fix Mixing code typos (#22697)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 86e469827d..50d8ad4260 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2205,7 +2205,7 @@ uint32_t Stepper::block_phase_isr() {
       accelerate_until = current_block->accelerate_until << oversampling;
       decelerate_after = current_block->decelerate_after << oversampling;
 
-      TERN_(MIXING_EXTRUDER, mixer.stepper_setup(current_block->b_color))
+      TERN_(MIXING_EXTRUDER, mixer.stepper_setup(current_block->b_color));
 
       TERN_(HAS_MULTI_EXTRUDER, stepper_extruder = current_block->extruder);
 

commit 71c96db932134ce845855fd51d910a86d044261e
Author: Ryan V1 <55478432+V1EngineeringInc@users.noreply.github.com>
Date:   Tue Aug 24 20:34:10 2021 -0700

    🐛 Fix Multi-Endstop stepping (#22625)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 882f5efc35..86e469827d 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -257,25 +257,30 @@ xyze_int8_t Stepper::count_direction{0};
   };
 #endif
 
-#define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                        \
-  if (separate_multi_axis) {                                                                                                \
-    if (ENABLED(A##_HOME_TO_MIN)) {                                                                                         \
-      if (TERN0(HAS_##A##_MIN, !(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor)) A##_STEP_WRITE(V);     \
-      if (TERN0(HAS_##A##2_MIN, !(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor)) A##2_STEP_WRITE(V); \
-    }                                                                                                                       \
-    else {                                                                                                                  \
-      if (TERN0(HAS_##A##_MAX, !(TEST(endstops.state(), A##_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##_motor)) A##_STEP_WRITE(V);     \
-      if (TERN0(HAS_##A##2_MAX, !(TEST(endstops.state(), A##2_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##2_motor)) A##2_STEP_WRITE(V); \
-    }                                                                                                                       \
-  }                                                                                                                         \
-  else {                                                                                                                    \
-    A##_STEP_WRITE(V);                                                                                                      \
-    A##2_STEP_WRITE(V);                                                                                                     \
+#define MINDIR(A) (count_direction[_AXIS(A)] < 0)
+#define MAXDIR(A) (count_direction[_AXIS(A)] > 0)
+
+#define STEPTEST(A,M,I) TERN0(HAS_ ##A## ##I## _ ##M, !(TEST(endstops.state(), A## ##I## _ ##M) && M## DIR(A)) && !locked_ ##A## ##I## _motor)
+
+#define DUAL_ENDSTOP_APPLY_STEP(A,V)             \
+  if (separate_multi_axis) {                     \
+    if (ENABLED(A##_HOME_TO_MIN)) {              \
+      if (STEPTEST(A,MIN, )) A## _STEP_WRITE(V); \
+      if (STEPTEST(A,MIN,2)) A##2_STEP_WRITE(V); \
+    }                                            \
+    else if (ENABLED(A##_HOME_TO_MAX)) {         \
+      if (STEPTEST(A,MAX, )) A## _STEP_WRITE(V); \
+      if (STEPTEST(A,MAX,2)) A##2_STEP_WRITE(V); \
+    }                                            \
+  }                                              \
+  else {                                         \
+    A##_STEP_WRITE(V);                           \
+    A##2_STEP_WRITE(V);                          \
   }
 
 #define DUAL_SEPARATE_APPLY_STEP(A,V)             \
   if (separate_multi_axis) {                      \
-    if (!locked_##A##_motor) A##_STEP_WRITE(V);   \
+    if (!locked_##A## _motor) A## _STEP_WRITE(V); \
     if (!locked_##A##2_motor) A##2_STEP_WRITE(V); \
   }                                               \
   else {                                          \
@@ -283,60 +288,68 @@ xyze_int8_t Stepper::count_direction{0};
     A##2_STEP_WRITE(V);                           \
   }
 
-#define TRIPLE_ENDSTOP_APPLY_STEP(A,V)                                                                                      \
-  if (separate_multi_axis) {                                                                                                \
-    if (ENABLED(A##_HOME_TO_MIN)) {                                                                                         \
-      if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
-      if (!(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
-      if (!(TEST(endstops.state(), A##3_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##3_motor) A##3_STEP_WRITE(V); \
-    }                                                                                                                       \
-    else {                                                                                                                  \
-      if (!(TEST(endstops.state(), A##_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
-      if (!(TEST(endstops.state(), A##2_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
-      if (!(TEST(endstops.state(), A##3_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##3_motor) A##3_STEP_WRITE(V); \
-    }                                                                                                                       \
-  }                                                                                                                         \
-  else {                                                                                                                    \
-    A##_STEP_WRITE(V);                                                                                                      \
-    A##2_STEP_WRITE(V);                                                                                                     \
-    A##3_STEP_WRITE(V);                                                                                                     \
+#define TRIPLE_ENDSTOP_APPLY_STEP(A,V)           \
+  if (separate_multi_axis) {                     \
+    if (ENABLED(A##_HOME_TO_MIN)) {              \
+      if (STEPTEST(A,MIN, )) A## _STEP_WRITE(V); \
+      if (STEPTEST(A,MIN,2)) A##2_STEP_WRITE(V); \
+      if (STEPTEST(A,MIN,3)) A##3_STEP_WRITE(V); \
+    }                                            \
+    else if (ENABLED(A##_HOME_TO_MAX)) {         \
+      if (STEPTEST(A,MAX, )) A## _STEP_WRITE(V); \
+      if (STEPTEST(A,MAX,2)) A##2_STEP_WRITE(V); \
+      if (STEPTEST(A,MAX,3)) A##3_STEP_WRITE(V); \
+    }                                            \
+  }                                              \
+  else {                                         \
+    A##_STEP_WRITE(V);                           \
+    A##2_STEP_WRITE(V);                          \
+    A##3_STEP_WRITE(V);                          \
   }
 
 #define TRIPLE_SEPARATE_APPLY_STEP(A,V)           \
   if (separate_multi_axis) {                      \
-    if (!locked_##A##_motor) A##_STEP_WRITE(V);   \
+    if (!locked_##A## _motor) A## _STEP_WRITE(V); \
     if (!locked_##A##2_motor) A##2_STEP_WRITE(V); \
     if (!locked_##A##3_motor) A##3_STEP_WRITE(V); \
   }                                               \
   else {                                          \
-    A##_STEP_WRITE(V);                            \
+    A## _STEP_WRITE(V);                           \
     A##2_STEP_WRITE(V);                           \
     A##3_STEP_WRITE(V);                           \
   }
 
-#define QUAD_ENDSTOP_APPLY_STEP(A,V) \
-  if (separate_multi_axis) {         \
-    if (!(TEST(endstops.state(), (TERN(A##_HOME_TO_MIN, A##_MIN,  A##_MAX)))  && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor)  A##_STEP_WRITE(V);  \
-    if (!(TEST(endstops.state(), (TERN(A##_HOME_TO_MIN, A##2_MIN, A##2_MAX))) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
-    if (!(TEST(endstops.state(), (TERN(A##_HOME_TO_MIN, A##3_MIN, A##3_MAX))) && count_direction[_AXIS(A)] < 0) && !locked_##A##3_motor) A##3_STEP_WRITE(V); \
-    if (!(TEST(endstops.state(), (TERN(A##_HOME_TO_MIN, A##4_MIN, A##4_MAX))) && count_direction[_AXIS(A)] < 0) && !locked_##A##4_motor) A##4_STEP_WRITE(V); \
-  }       \
-  else {  \
-    A##_STEP_WRITE(V);  \
-    A##2_STEP_WRITE(V); \
-    A##3_STEP_WRITE(V); \
-    A##4_STEP_WRITE(V); \
+#define QUAD_ENDSTOP_APPLY_STEP(A,V)             \
+  if (separate_multi_axis) {                     \
+    if (ENABLED(A##_HOME_TO_MIN)) {              \
+      if (STEPTEST(A,MIN, )) A## _STEP_WRITE(V); \
+      if (STEPTEST(A,MIN,2)) A##2_STEP_WRITE(V); \
+      if (STEPTEST(A,MIN,3)) A##3_STEP_WRITE(V); \
+      if (STEPTEST(A,MIN,4)) A##4_STEP_WRITE(V); \
+    }                                            \
+    else if (ENABLED(A##_HOME_TO_MAX)) {         \
+      if (STEPTEST(A,MAX, )) A## _STEP_WRITE(V); \
+      if (STEPTEST(A,MAX,2)) A##2_STEP_WRITE(V); \
+      if (STEPTEST(A,MAX,3)) A##3_STEP_WRITE(V); \
+      if (STEPTEST(A,MAX,4)) A##4_STEP_WRITE(V); \
+    }                                            \
+  }                                              \
+  else {                                         \
+    A## _STEP_WRITE(V);                          \
+    A##2_STEP_WRITE(V);                          \
+    A##3_STEP_WRITE(V);                          \
+    A##4_STEP_WRITE(V);                          \
   }
 
 #define QUAD_SEPARATE_APPLY_STEP(A,V)             \
   if (separate_multi_axis) {                      \
-    if (!locked_##A##_motor) A##_STEP_WRITE(V);   \
+    if (!locked_##A## _motor) A## _STEP_WRITE(V); \
     if (!locked_##A##2_motor) A##2_STEP_WRITE(V); \
     if (!locked_##A##3_motor) A##3_STEP_WRITE(V); \
     if (!locked_##A##4_motor) A##4_STEP_WRITE(V); \
   }                                               \
   else {                                          \
-    A##_STEP_WRITE(V);                            \
+    A## _STEP_WRITE(V);                           \
     A##2_STEP_WRITE(V);                           \
     A##3_STEP_WRITE(V);                           \
     A##4_STEP_WRITE(V);                           \

commit 536cf287a6f642aa3eccd290b421b0e3869f018a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Aug 21 18:00:55 2021 -0500

    🎨 Misc code and spacing cleanup

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b8fdaa5f76..882f5efc35 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1428,14 +1428,10 @@ void Stepper::isr() {
 
     // Get the interval to the next ISR call
     const uint32_t interval = _MIN(
+      uint32_t(HAL_TIMER_TYPE_MAX),                     // Come back in a very long time
       nextMainISR                                       // Time until the next Pulse / Block phase
-      #if ENABLED(LIN_ADVANCE)
-        , nextAdvanceISR                                // Come back early for Linear Advance?
-      #endif
-      #if ENABLED(INTEGRATED_BABYSTEPPING)
-        , nextBabystepISR                               // Come back early for Babystepping?
-      #endif
-      , uint32_t(HAL_TIMER_TYPE_MAX)                    // Come back in a very long time
+      OPTARG(LIN_ADVANCE, nextAdvanceISR)               // Come back early for Linear Advance?
+      OPTARG(INTEGRATED_BABYSTEPPING, nextBabystepISR)  // Come back early for Babystepping?
     );
 
     //

commit c2c7a03706e54d1ce4441a39ca8343755bceac06
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Aug 4 17:01:42 2021 -0500

    🐛 Fix report_a_position ABC criteria

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 0ff909d7cc..b8fdaa5f76 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2825,19 +2825,22 @@ int32_t Stepper::triggered_position(const AxisEnum axis) {
   return v;
 }
 
-#if ANY(CORE_IS_XZ, CORE_IS_YZ, DELTA)
-  #define USES_ABC 1
+#if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, IS_SCARA, DELTA)
+  #define SAYS_A 1
+#endif
+#if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY, IS_SCARA, DELTA)
+  #define SAYS_B 1
 #endif
-#if ANY(USES_ABC, MARKFORGED_XY, IS_SCARA)
-  #define USES_AB 1
+#if ANY(CORE_IS_XZ, CORE_IS_YZ, DELTA)
+  #define SAYS_C 1
 #endif
 
 void Stepper::report_a_position(const xyz_long_t &pos) {
   SERIAL_ECHOLNPAIR_P(
     LIST_N(DOUBLE(LINEAR_AXES),
-      TERN(USES_AB,  PSTR(STR_COUNT_A), PSTR(STR_COUNT_X)), pos.x,
-      TERN(USES_AB,  PSTR("B:"), SP_Y_LBL), pos.y,
-      TERN(USES_ABC, PSTR("C:"), SP_Z_LBL), pos.z,
+      TERN(SAYS_A, PSTR(STR_COUNT_A), PSTR(STR_COUNT_X)), pos.x,
+      TERN(SAYS_B, PSTR("B:"), SP_Y_LBL), pos.y,
+      TERN(SAYS_C, PSTR("C:"), SP_Z_LBL), pos.z,
       SP_I_LBL, pos.i,
       SP_J_LBL, pos.j,
       SP_K_LBL, pos.k

commit d882a16b801078f2741ad1021d8be418fef71764
Author: ellensp <ellensp@hotmail.com>
Date:   Sun Jun 27 06:28:56 2021 +1200

    🐛 Fix Z_MULTI_ENDSTOPS + NUM_Z_STEPPER_DRIVERS 4 compile (#22203)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 062049ec77..0ff909d7cc 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -314,26 +314,18 @@ xyze_int8_t Stepper::count_direction{0};
     A##3_STEP_WRITE(V);                           \
   }
 
-#define QUAD_ENDSTOP_APPLY_STEP(A,V)                                                                                        \
-  if (separate_multi_axis) {                                                                                                \
-    if (ENABLED(A##_HOME_TO_MIN)) {                                                                                         \
-      if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
-      if (!(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
-      if (!(TEST(endstops.state(), A##3_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##3_motor) A##3_STEP_WRITE(V); \
-      if (!(TEST(endstops.state(), A##4_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##4_motor) A##4_STEP_WRITE(V); \
-    }                                                                                                                       \
-    else {                                                                                                                  \
-      if (!(TEST(endstops.state(), A##_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
-      if (!(TEST(endstops.state(), A##2_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
-      if (!(TEST(endstops.state(), A##3_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##3_motor) A##3_STEP_WRITE(V); \
-      if (!(TEST(endstops.state(), A##4_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##4_motor) A##4_STEP_WRITE(V); \
-    }                                                                                                                       \
-  }                                                                                                                         \
-  else {                                                                                                                    \
-    A##_STEP_WRITE(V);                                                                                                      \
-    A##2_STEP_WRITE(V);                                                                                                     \
-    A##3_STEP_WRITE(V);                                                                                                     \
-    A##4_STEP_WRITE(V);                                                                                                     \
+#define QUAD_ENDSTOP_APPLY_STEP(A,V) \
+  if (separate_multi_axis) {         \
+    if (!(TEST(endstops.state(), (TERN(A##_HOME_TO_MIN, A##_MIN,  A##_MAX)))  && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor)  A##_STEP_WRITE(V);  \
+    if (!(TEST(endstops.state(), (TERN(A##_HOME_TO_MIN, A##2_MIN, A##2_MAX))) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
+    if (!(TEST(endstops.state(), (TERN(A##_HOME_TO_MIN, A##3_MIN, A##3_MAX))) && count_direction[_AXIS(A)] < 0) && !locked_##A##3_motor) A##3_STEP_WRITE(V); \
+    if (!(TEST(endstops.state(), (TERN(A##_HOME_TO_MIN, A##4_MIN, A##4_MAX))) && count_direction[_AXIS(A)] < 0) && !locked_##A##4_motor) A##4_STEP_WRITE(V); \
+  }       \
+  else {  \
+    A##_STEP_WRITE(V);  \
+    A##2_STEP_WRITE(V); \
+    A##3_STEP_WRITE(V); \
+    A##4_STEP_WRITE(V); \
   }
 
 #define QUAD_SEPARATE_APPLY_STEP(A,V)             \

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    🏗️ Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 05286a6566..062049ec77 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -378,7 +378,7 @@ xyze_int8_t Stepper::count_direction{0};
   #else
     #define Y_APPLY_STEP(v,Q) do{ Y_STEP_WRITE(v); Y2_STEP_WRITE(v); }while(0)
   #endif
-#else
+#elif HAS_Y_AXIS
   #define Y_APPLY_DIR(v,Q) Y_DIR_WRITE(v)
   #define Y_APPLY_STEP(v,Q) Y_STEP_WRITE(v)
 #endif
@@ -415,11 +415,24 @@ xyze_int8_t Stepper::count_direction{0};
   #else
     #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); }while(0)
   #endif
-#else
+#elif HAS_Z_AXIS
   #define Z_APPLY_DIR(v,Q) Z_DIR_WRITE(v)
   #define Z_APPLY_STEP(v,Q) Z_STEP_WRITE(v)
 #endif
 
+#if LINEAR_AXES >= 4
+  #define I_APPLY_DIR(v,Q) I_DIR_WRITE(v)
+  #define I_APPLY_STEP(v,Q) I_STEP_WRITE(v)
+#endif
+#if LINEAR_AXES >= 5
+  #define J_APPLY_DIR(v,Q) J_DIR_WRITE(v)
+  #define J_APPLY_STEP(v,Q) J_STEP_WRITE(v)
+#endif
+#if LINEAR_AXES >= 6
+  #define K_APPLY_DIR(v,Q) K_DIR_WRITE(v)
+  #define K_APPLY_STEP(v,Q) K_STEP_WRITE(v)
+#endif
+
 #if DISABLED(MIXING_EXTRUDER)
   #define E_APPLY_STEP(v,Q) E_STEP_WRITE(stepper_extruder, v)
 #endif
@@ -486,6 +499,18 @@ void Stepper::set_directions() {
     SET_STEP_DIR(Z); // C
   #endif
 
+  #if HAS_I_DIR
+    SET_STEP_DIR(I); // I
+  #endif
+
+  #if HAS_J_DIR
+    SET_STEP_DIR(J); // J
+  #endif
+
+  #if HAS_K_DIR
+    SET_STEP_DIR(K); // K
+  #endif
+
   #if DISABLED(LIN_ADVANCE)
     #if ENABLED(MIXING_EXTRUDER)
        // Because this is valid for the whole block we don't know
@@ -1584,7 +1609,7 @@ void Stepper::pulse_phase_isr() {
     const bool is_page = IS_PAGE(current_block);
 
     #if ENABLED(DIRECT_STEPPING)
-
+      // TODO (DerAndere): Add support for LINEAR_AXES >= 4
       if (is_page) {
 
         #if STEPPER_PAGE_FORMAT == SP_4x4D_128
@@ -1700,6 +1725,15 @@ void Stepper::pulse_phase_isr() {
       #if HAS_Z_STEP
         PULSE_PREP(Z);
       #endif
+      #if HAS_I_STEP
+        PULSE_PREP(I);
+      #endif
+      #if HAS_J_STEP
+        PULSE_PREP(J);
+      #endif
+      #if HAS_K_STEP
+        PULSE_PREP(K);
+      #endif
 
       #if EITHER(LIN_ADVANCE, MIXING_EXTRUDER)
         delta_error.e += advance_dividend.e;
@@ -1735,6 +1769,15 @@ void Stepper::pulse_phase_isr() {
     #if HAS_Z_STEP
       PULSE_START(Z);
     #endif
+    #if HAS_I_STEP
+      PULSE_START(I);
+    #endif
+    #if HAS_J_STEP
+      PULSE_START(J);
+    #endif
+    #if HAS_K_STEP
+      PULSE_START(K);
+    #endif
 
     #if DISABLED(LIN_ADVANCE)
       #if ENABLED(MIXING_EXTRUDER)
@@ -1764,6 +1807,15 @@ void Stepper::pulse_phase_isr() {
     #if HAS_Z_STEP
       PULSE_STOP(Z);
     #endif
+    #if HAS_I_STEP
+      PULSE_STOP(I);
+    #endif
+    #if HAS_J_STEP
+      PULSE_STOP(J);
+    #endif
+    #if HAS_K_STEP
+      PULSE_STOP(K);
+    #endif
 
     #if DISABLED(LIN_ADVANCE)
       #if ENABLED(MIXING_EXTRUDER)
@@ -1798,6 +1850,7 @@ uint32_t Stepper::block_phase_isr() {
     // If current block is finished, reset pointer and finalize state
     if (step_events_completed >= step_event_count) {
       #if ENABLED(DIRECT_STEPPING)
+        // TODO (DerAndere): Add support for LINEAR_AXES >= 4
         #if STEPPER_PAGE_FORMAT == SP_4x4D_128
           #define PAGE_SEGMENT_UPDATE_POS(AXIS) \
             count_position[_AXIS(AXIS)] += page_step_state.bd[_AXIS(AXIS)] - 128 * 7;
@@ -2104,9 +2157,12 @@ uint32_t Stepper::block_phase_isr() {
 
       uint8_t axis_bits = 0;
       LINEAR_AXIS_CODE(
-        if (X_MOVE_TEST) SBI(axis_bits, A_AXIS),
-        if (Y_MOVE_TEST) SBI(axis_bits, B_AXIS),
-        if (Z_MOVE_TEST) SBI(axis_bits, C_AXIS)
+        if (X_MOVE_TEST)            SBI(axis_bits, A_AXIS),
+        if (Y_MOVE_TEST)            SBI(axis_bits, B_AXIS),
+        if (Z_MOVE_TEST)            SBI(axis_bits, C_AXIS),
+        if (current_block->steps.i) SBI(axis_bits, I_AXIS),
+        if (current_block->steps.j) SBI(axis_bits, J_AXIS),
+        if (current_block->steps.k) SBI(axis_bits, K_AXIS)
       );
       //if (current_block->steps.e) SBI(axis_bits, E_AXIS);
       //if (current_block->steps.a) SBI(axis_bits, X_HEAD);
@@ -2441,6 +2497,15 @@ void Stepper::init() {
       Z4_DIR_INIT();
     #endif
   #endif
+  #if HAS_I_DIR
+    I_DIR_INIT();
+  #endif
+  #if HAS_J_DIR
+    J_DIR_INIT();
+  #endif
+  #if HAS_K_DIR
+    K_DIR_INIT();
+  #endif
   #if HAS_E0_DIR
     E0_DIR_INIT();
   #endif
@@ -2499,6 +2564,18 @@ void Stepper::init() {
       if (!Z_ENABLE_ON) Z4_ENABLE_WRITE(HIGH);
     #endif
   #endif
+  #if HAS_I_ENABLE
+    I_ENABLE_INIT();
+    if (!I_ENABLE_ON) I_ENABLE_WRITE(HIGH);
+  #endif
+  #if HAS_J_ENABLE
+    J_ENABLE_INIT();
+    if (!J_ENABLE_ON) J_ENABLE_WRITE(HIGH);
+  #endif
+  #if HAS_K_ENABLE
+    K_ENABLE_INIT();
+    if (!K_ENABLE_ON) K_ENABLE_WRITE(HIGH);
+  #endif
   #if HAS_E0_ENABLE
     E0_ENABLE_INIT();
     if (!E_ENABLE_ON) E0_ENABLE_WRITE(HIGH);
@@ -2575,6 +2652,15 @@ void Stepper::init() {
     #endif
     AXIS_INIT(Z, Z);
   #endif
+  #if HAS_I_STEP
+    AXIS_INIT(I, I);
+  #endif
+  #if HAS_J_STEP
+    AXIS_INIT(J, J);
+  #endif
+  #if HAS_K_STEP
+    AXIS_INIT(K, K);
+  #endif
 
   #if E_STEPPERS && HAS_E0_STEP
     E_AXIS_INIT(0);
@@ -2612,7 +2698,10 @@ void Stepper::init() {
     LINEAR_AXIS_GANG(
       | TERN0(INVERT_X_DIR, _BV(X_AXIS)),
       | TERN0(INVERT_Y_DIR, _BV(Y_AXIS)),
-      | TERN0(INVERT_Z_DIR, _BV(Z_AXIS))
+      | TERN0(INVERT_Z_DIR, _BV(Z_AXIS)),
+      | TERN0(INVERT_I_DIR, _BV(I_AXIS)),
+      | TERN0(INVERT_J_DIR, _BV(J_AXIS)),
+      | TERN0(INVERT_K_DIR, _BV(K_AXIS))
     )
   );
 
@@ -2625,32 +2714,32 @@ void Stepper::init() {
 /**
  * Set the stepper positions directly in steps
  *
- * The input is based on the typical per-axis XYZ steps.
+ * The input is based on the typical per-axis XYZE steps.
  * For CORE machines XYZ needs to be translated to ABC.
  *
  * This allows get_axis_position_mm to correctly
- * derive the current XYZ position later on.
+ * derive the current XYZE position later on.
  */
-void Stepper::_set_position(
-  LOGICAL_AXIS_LIST(const int32_t &e, const int32_t &a, const int32_t &b, const int32_t &c)
-) {
-  #if CORE_IS_XY
-    // corexy positioning
-    // these equations follow the form of the dA and dB equations on https://www.corexy.com/theory.html
-    count_position.set(a + b, CORESIGN(a - b), c);
-  #elif CORE_IS_XZ
-    // corexz planning
-    count_position.set(a + c, b, CORESIGN(a - c));
-  #elif CORE_IS_YZ
-    // coreyz planning
-    count_position.set(a, b + c, CORESIGN(b - c));
-  #elif ENABLED(MARKFORGED_XY)
-    count_position.set(a - b, b, c);
+void Stepper::_set_position(const abce_long_t &spos) {
+  #if EITHER(IS_CORE, MARKFORGED_XY)
+    #if CORE_IS_XY
+      // corexy positioning
+      // these equations follow the form of the dA and dB equations on https://www.corexy.com/theory.html
+      count_position.set(spos.a + spos.b, CORESIGN(spos.a - spos.b), spos.c);
+    #elif CORE_IS_XZ
+      // corexz planning
+      count_position.set(spos.a + spos.c, spos.b, CORESIGN(spos.a - spos.c));
+    #elif CORE_IS_YZ
+      // coreyz planning
+      count_position.set(spos.a, spos.b + spos.c, CORESIGN(spos.b - spos.c));
+    #elif ENABLED(MARKFORGED_XY)
+      count_position.set(spos.a - spos.b, spos.b, spos.c);
+    #endif
+    TERN_(HAS_EXTRUDERS, count_position.e = spos.e);
   #else
     // default non-h-bot planning
-    count_position.set(LINEAR_AXIS_LIST(a, b, c));
+    count_position = spos;
   #endif
-  TERN_(HAS_EXTRUDERS, count_position.e = e);
 }
 
 /**
@@ -2673,13 +2762,10 @@ int32_t Stepper::position(const AxisEnum axis) {
 }
 
 // Set the current position in steps
-//TODO: Test for LINEAR_AXES >= 4
-void Stepper::set_position(
-  LOGICAL_AXIS_LIST(const int32_t &e, const int32_t &a, const int32_t &b, const int32_t &c)
-) {
+void Stepper::set_position(const xyze_long_t &spos) {
   planner.synchronize();
   const bool was_enabled = suspend();
-  _set_position(LOGICAL_AXIS_LIST(e, a, b, c));
+  _set_position(spos);
   if (was_enabled) wake_up();
 }
 
@@ -2747,18 +2833,24 @@ int32_t Stepper::triggered_position(const AxisEnum axis) {
   return v;
 }
 
+#if ANY(CORE_IS_XZ, CORE_IS_YZ, DELTA)
+  #define USES_ABC 1
+#endif
+#if ANY(USES_ABC, MARKFORGED_XY, IS_SCARA)
+  #define USES_AB 1
+#endif
+
 void Stepper::report_a_position(const xyz_long_t &pos) {
-  #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, DELTA, IS_SCARA)
-    SERIAL_ECHOPAIR(STR_COUNT_A, pos.x, " B:", pos.y);
-  #else
-    SERIAL_ECHOPAIR_P(PSTR(STR_COUNT_X), pos.x, SP_Y_LBL, pos.y);
-  #endif
-  #if ANY(CORE_IS_XZ, CORE_IS_YZ, DELTA)
-    SERIAL_ECHOPAIR(" C:", pos.z);
-  #elif LINEAR_AXES >= 3
-    SERIAL_ECHOPAIR_P(SP_Z_LBL, pos.z);
-  #endif
-  SERIAL_EOL();
+  SERIAL_ECHOLNPAIR_P(
+    LIST_N(DOUBLE(LINEAR_AXES),
+      TERN(USES_AB,  PSTR(STR_COUNT_A), PSTR(STR_COUNT_X)), pos.x,
+      TERN(USES_AB,  PSTR("B:"), SP_Y_LBL), pos.y,
+      TERN(USES_ABC, PSTR("C:"), SP_Z_LBL), pos.z,
+      SP_I_LBL, pos.i,
+      SP_J_LBL, pos.j,
+      SP_K_LBL, pos.k
+    )
+  );
 }
 
 void Stepper::report_positions() {
@@ -2866,9 +2958,7 @@ void Stepper::report_positions() {
   // No other ISR should ever interrupt this!
   void Stepper::do_babystep(const AxisEnum axis, const bool direction) {
 
-    #if DISABLED(INTEGRATED_BABYSTEPPING)
-      cli();
-    #endif
+    IF_DISABLED(INTEGRATED_BABYSTEPPING, cli());
 
     switch (axis) {
 
@@ -2912,35 +3002,90 @@ void Stepper::report_positions() {
           ENABLE_AXIS_X();
           ENABLE_AXIS_Y();
           ENABLE_AXIS_Z();
+          ENABLE_AXIS_I();
+          ENABLE_AXIS_J();
+          ENABLE_AXIS_K();
 
           DIR_WAIT_BEFORE();
 
-          const xyz_byte_t old_dir = LINEAR_AXIS_ARRAY(X_DIR_READ(), Y_DIR_READ(), Z_DIR_READ());
+          const xyz_byte_t old_dir = LINEAR_AXIS_ARRAY(X_DIR_READ(), Y_DIR_READ(), Z_DIR_READ(), I_DIR_READ(), J_DIR_READ(), K_DIR_READ());
 
           X_DIR_WRITE(INVERT_X_DIR ^ z_direction);
-          Y_DIR_WRITE(INVERT_Y_DIR ^ z_direction);
-          Z_DIR_WRITE(INVERT_Z_DIR ^ z_direction);
+          #ifdef Y_DIR_WRITE
+            Y_DIR_WRITE(INVERT_Y_DIR ^ z_direction);
+          #endif
+          #ifdef Z_DIR_WRITE
+            Z_DIR_WRITE(INVERT_Z_DIR ^ z_direction);
+          #endif
+          #ifdef I_DIR_WRITE
+            I_DIR_WRITE(INVERT_I_DIR ^ z_direction);
+          #endif
+          #ifdef J_DIR_WRITE
+            J_DIR_WRITE(INVERT_J_DIR ^ z_direction);
+          #endif
+          #ifdef K_DIR_WRITE
+            K_DIR_WRITE(INVERT_K_DIR ^ z_direction);
+          #endif
 
           DIR_WAIT_AFTER();
 
           _SAVE_START();
 
           X_STEP_WRITE(!INVERT_X_STEP_PIN);
-          Y_STEP_WRITE(!INVERT_Y_STEP_PIN);
-          Z_STEP_WRITE(!INVERT_Z_STEP_PIN);
+          #ifdef Y_STEP_WRITE
+            Y_STEP_WRITE(!INVERT_Y_STEP_PIN);
+          #endif
+          #ifdef Z_STEP_WRITE
+            Z_STEP_WRITE(!INVERT_Z_STEP_PIN);
+          #endif
+          #ifdef I_STEP_WRITE
+            I_STEP_WRITE(!INVERT_I_STEP_PIN);
+          #endif
+          #ifdef J_STEP_WRITE
+            J_STEP_WRITE(!INVERT_J_STEP_PIN);
+          #endif
+          #ifdef K_STEP_WRITE
+            K_STEP_WRITE(!INVERT_K_STEP_PIN);
+          #endif
 
           _PULSE_WAIT();
 
           X_STEP_WRITE(INVERT_X_STEP_PIN);
-          Y_STEP_WRITE(INVERT_Y_STEP_PIN);
-          Z_STEP_WRITE(INVERT_Z_STEP_PIN);
+          #ifdef Y_STEP_WRITE
+            Y_STEP_WRITE(INVERT_Y_STEP_PIN);
+          #endif
+          #ifdef Z_STEP_WRITE
+            Z_STEP_WRITE(INVERT_Z_STEP_PIN);
+          #endif
+          #ifdef I_STEP_WRITE
+            I_STEP_WRITE(INVERT_I_STEP_PIN);
+          #endif
+          #ifdef J_STEP_WRITE
+            J_STEP_WRITE(INVERT_J_STEP_PIN);
+          #endif
+          #ifdef K_STEP_WRITE
+            K_STEP_WRITE(INVERT_K_STEP_PIN);
+          #endif
 
           // Restore direction bits
           EXTRA_DIR_WAIT_BEFORE();
 
           X_DIR_WRITE(old_dir.x);
-          Y_DIR_WRITE(old_dir.y);
-          Z_DIR_WRITE(old_dir.z);
+          #ifdef Y_DIR_WRITE
+            Y_DIR_WRITE(old_dir.y);
+          #endif
+          #ifdef Z_DIR_WRITE
+            Z_DIR_WRITE(old_dir.z);
+          #endif
+          #ifdef I_DIR_WRITE
+            I_DIR_WRITE(old_dir.i);
+          #endif
+          #ifdef J_DIR_WRITE
+            J_DIR_WRITE(old_dir.j);
+          #endif
+          #ifdef K_DIR_WRITE
+            K_DIR_WRITE(old_dir.k);
+          #endif
 
           EXTRA_DIR_WAIT_AFTER();
 
@@ -2948,12 +3093,20 @@ void Stepper::report_positions() {
 
       } break;
 
+      #if LINEAR_AXES >= 4
+        case I_AXIS: BABYSTEP_AXIS(I, 0, direction); break;
+      #endif
+      #if LINEAR_AXES >= 5
+        case J_AXIS: BABYSTEP_AXIS(J, 0, direction); break;
+      #endif
+      #if LINEAR_AXES >= 6
+        case K_AXIS: BABYSTEP_AXIS(K, 0, direction); break;
+      #endif
+
       default: break;
     }
 
-    #if DISABLED(INTEGRATED_BABYSTEPPING)
-      sei();
-    #endif
+    IF_DISABLED(INTEGRATED_BABYSTEPPING, sei());
   }
 
 #endif // BABYSTEPPING
@@ -3288,6 +3441,15 @@ void Stepper::report_positions() {
       #if HAS_E7_MS_PINS
         case 10: WRITE(E7_MS1_PIN, ms1); break;
       #endif
+      #if HAS_I_MICROSTEPS
+        case 11: WRITE(I_MS1_PIN, ms1); break
+      #endif
+      #if HAS_J_MICROSTEPS
+        case 12: WRITE(J_MS1_PIN, ms1); break
+      #endif
+      #if HAS_K_MICROSTEPS
+        case 13: WRITE(K_MS1_PIN, ms1); break
+      #endif
     }
     if (ms2 >= 0) switch (driver) {
       #if HAS_X_MS_PINS || HAS_X2_MS_PINS
@@ -3350,6 +3512,15 @@ void Stepper::report_positions() {
       #if HAS_E7_MS_PINS
         case 10: WRITE(E7_MS2_PIN, ms2); break;
       #endif
+      #if HAS_I_M_PINS
+        case 11: WRITE(I_MS2_PIN, ms2); break
+      #endif
+      #if HAS_J_M_PINS
+        case 12: WRITE(J_MS2_PIN, ms2); break
+      #endif
+      #if HAS_K_M_PINS
+        case 13: WRITE(K_MS2_PIN, ms2); break
+      #endif
     }
     if (ms3 >= 0) switch (driver) {
       #if HAS_X_MS_PINS || HAS_X2_MS_PINS
@@ -3468,6 +3639,24 @@ void Stepper::report_positions() {
         PIN_CHAR(Z_MS3);
       #endif
     #endif
+    #if HAS_I_MS_PINS
+      MS_LINE(I);
+      #if PIN_EXISTS(I_MS3)
+        PIN_CHAR(I_MS3);
+      #endif
+    #endif
+    #if HAS_J_MS_PINS
+      MS_LINE(J);
+      #if PIN_EXISTS(J_MS3)
+        PIN_CHAR(J_MS3);
+      #endif
+    #endif
+    #if HAS_K_MS_PINS
+      MS_LINE(K);
+      #if PIN_EXISTS(K_MS3)
+        PIN_CHAR(K_MS3);
+      #endif
+    #endif
     #if HAS_E0_MS_PINS
       MS_LINE(E0);
       #if PIN_EXISTS(E0_MS3)

commit 82ea06e6a4ffdb0816ab92a5dd721ec5d770015d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 1 20:23:37 2021 -0500

    ♻️ Patches for Zero Extruders (with TMC)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index bc6dbeaf25..05286a6566 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -259,7 +259,7 @@ xyze_int8_t Stepper::count_direction{0};
 
 #define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                        \
   if (separate_multi_axis) {                                                                                                \
-    if (A##_HOME_TO_MIN) {                                                                                                  \
+    if (ENABLED(A##_HOME_TO_MIN)) {                                                                                         \
       if (TERN0(HAS_##A##_MIN, !(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor)) A##_STEP_WRITE(V);     \
       if (TERN0(HAS_##A##2_MIN, !(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor)) A##2_STEP_WRITE(V); \
     }                                                                                                                       \
@@ -285,7 +285,7 @@ xyze_int8_t Stepper::count_direction{0};
 
 #define TRIPLE_ENDSTOP_APPLY_STEP(A,V)                                                                                      \
   if (separate_multi_axis) {                                                                                                \
-    if (A##_HOME_TO_MIN) {                                                                                                  \
+    if (ENABLED(A##_HOME_TO_MIN)) {                                                                                         \
       if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
       if (!(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
       if (!(TEST(endstops.state(), A##3_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##3_motor) A##3_STEP_WRITE(V); \
@@ -316,7 +316,7 @@ xyze_int8_t Stepper::count_direction{0};
 
 #define QUAD_ENDSTOP_APPLY_STEP(A,V)                                                                                        \
   if (separate_multi_axis) {                                                                                                \
-    if (A##_HOME_TO_MIN) {                                                                                                  \
+    if (ENABLED(A##_HOME_TO_MIN)) {                                                                                         \
       if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
       if (!(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
       if (!(TEST(endstops.state(), A##3_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##3_motor) A##3_STEP_WRITE(V); \

commit dd4990252e891cdfe56cb7d6e3bbe1e6289be649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 24 16:38:57 2021 -0500

    ♻️ Refactor Linear / Logical / Distinct Axes (#21953)
    
    * More patches supporting EXTRUDERS 0
    * Extend types in prep for more axes

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 2e2afaeb90..bc6dbeaf25 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -498,7 +498,7 @@ void Stepper::set_directions() {
         MIXER_STEPPER_LOOP(j) NORM_E_DIR(j);
         count_direction.e = 1;
       }
-    #else
+    #elif HAS_EXTRUDERS
       if (motor_direction(E_AXIS)) {
         REV_E_DIR(stepper_extruder);
         count_direction.e = -1;
@@ -1627,7 +1627,7 @@ void Stepper::pulse_phase_isr() {
           PAGE_PULSE_PREP(X);
           PAGE_PULSE_PREP(Y);
           PAGE_PULSE_PREP(Z);
-          PAGE_PULSE_PREP(E);
+          TERN_(HAS_EXTRUDERS, PAGE_PULSE_PREP(E));
 
           page_step_state.segment_steps++;
 
@@ -1660,7 +1660,7 @@ void Stepper::pulse_phase_isr() {
           PAGE_PULSE_PREP(X);
           PAGE_PULSE_PREP(Y);
           PAGE_PULSE_PREP(Z);
-          PAGE_PULSE_PREP(E);
+          TERN_(HAS_EXTRUDERS, PAGE_PULSE_PREP(E));
 
           page_step_state.segment_steps++;
 
@@ -2103,13 +2103,15 @@ uint32_t Stepper::block_phase_isr() {
       #endif
 
       uint8_t axis_bits = 0;
-      if (X_MOVE_TEST) SBI(axis_bits, A_AXIS);
-      if (Y_MOVE_TEST) SBI(axis_bits, B_AXIS);
-      if (Z_MOVE_TEST) SBI(axis_bits, C_AXIS);
-      //if (!!current_block->steps.e) SBI(axis_bits, E_AXIS);
-      //if (!!current_block->steps.a) SBI(axis_bits, X_HEAD);
-      //if (!!current_block->steps.b) SBI(axis_bits, Y_HEAD);
-      //if (!!current_block->steps.c) SBI(axis_bits, Z_HEAD);
+      LINEAR_AXIS_CODE(
+        if (X_MOVE_TEST) SBI(axis_bits, A_AXIS),
+        if (Y_MOVE_TEST) SBI(axis_bits, B_AXIS),
+        if (Z_MOVE_TEST) SBI(axis_bits, C_AXIS)
+      );
+      //if (current_block->steps.e) SBI(axis_bits, E_AXIS);
+      //if (current_block->steps.a) SBI(axis_bits, X_HEAD);
+      //if (current_block->steps.b) SBI(axis_bits, Y_HEAD);
+      //if (current_block->steps.c) SBI(axis_bits, Z_HEAD);
       axis_did_move = axis_bits;
 
       // No acceleration / deceleration time elapsed so far
@@ -2606,9 +2608,13 @@ void Stepper::init() {
   #endif
 
   // Init direction bits for first moves
-  set_directions((INVERT_X_DIR ? _BV(X_AXIS) : 0)
-               | (INVERT_Y_DIR ? _BV(Y_AXIS) : 0)
-               | (INVERT_Z_DIR ? _BV(Z_AXIS) : 0));
+  set_directions(0
+    LINEAR_AXIS_GANG(
+      | TERN0(INVERT_X_DIR, _BV(X_AXIS)),
+      | TERN0(INVERT_Y_DIR, _BV(Y_AXIS)),
+      | TERN0(INVERT_Z_DIR, _BV(Z_AXIS))
+    )
+  );
 
   #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
     initialized = true;
@@ -2625,7 +2631,9 @@ void Stepper::init() {
  * This allows get_axis_position_mm to correctly
  * derive the current XYZ position later on.
  */
-void Stepper::_set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
+void Stepper::_set_position(
+  LOGICAL_AXIS_LIST(const int32_t &e, const int32_t &a, const int32_t &b, const int32_t &c)
+) {
   #if CORE_IS_XY
     // corexy positioning
     // these equations follow the form of the dA and dB equations on https://www.corexy.com/theory.html
@@ -2640,9 +2648,9 @@ void Stepper::_set_position(const int32_t &a, const int32_t &b, const int32_t &c
     count_position.set(a - b, b, c);
   #else
     // default non-h-bot planning
-    count_position.set(a, b, c);
+    count_position.set(LINEAR_AXIS_LIST(a, b, c));
   #endif
-  count_position.e = e;
+  TERN_(HAS_EXTRUDERS, count_position.e = e);
 }
 
 /**
@@ -2665,10 +2673,13 @@ int32_t Stepper::position(const AxisEnum axis) {
 }
 
 // Set the current position in steps
-void Stepper::set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
+//TODO: Test for LINEAR_AXES >= 4
+void Stepper::set_position(
+  LOGICAL_AXIS_LIST(const int32_t &e, const int32_t &a, const int32_t &b, const int32_t &c)
+) {
   planner.synchronize();
   const bool was_enabled = suspend();
-  _set_position(a, b, c, e);
+  _set_position(LOGICAL_AXIS_LIST(e, a, b, c));
   if (was_enabled) wake_up();
 }
 
@@ -2743,10 +2754,11 @@ void Stepper::report_a_position(const xyz_long_t &pos) {
     SERIAL_ECHOPAIR_P(PSTR(STR_COUNT_X), pos.x, SP_Y_LBL, pos.y);
   #endif
   #if ANY(CORE_IS_XZ, CORE_IS_YZ, DELTA)
-    SERIAL_ECHOLNPAIR(" C:", pos.z);
-  #else
-    SERIAL_ECHOLNPAIR_P(SP_Z_LBL, pos.z);
+    SERIAL_ECHOPAIR(" C:", pos.z);
+  #elif LINEAR_AXES >= 3
+    SERIAL_ECHOPAIR_P(SP_Z_LBL, pos.z);
   #endif
+  SERIAL_EOL();
 }
 
 void Stepper::report_positions() {
@@ -2903,7 +2915,7 @@ void Stepper::report_positions() {
 
           DIR_WAIT_BEFORE();
 
-          const xyz_byte_t old_dir = { X_DIR_READ(), Y_DIR_READ(), Z_DIR_READ() };
+          const xyz_byte_t old_dir = LINEAR_AXIS_ARRAY(X_DIR_READ(), Y_DIR_READ(), Z_DIR_READ());
 
           X_DIR_WRITE(INVERT_X_DIR ^ z_direction);
           Y_DIR_WRITE(INVERT_Y_DIR ^ z_direction);

commit 49771c4a9ed2afa1e572f82a24b5edb3de120f78
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 19 00:21:34 2021 -0500

    🎨 Flags for homing directions

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index e8f578ae91..2e2afaeb90 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -259,7 +259,7 @@ xyze_int8_t Stepper::count_direction{0};
 
 #define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                        \
   if (separate_multi_axis) {                                                                                                \
-    if (A##_HOME_DIR < 0) {                                                                                                 \
+    if (A##_HOME_TO_MIN) {                                                                                                  \
       if (TERN0(HAS_##A##_MIN, !(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor)) A##_STEP_WRITE(V);     \
       if (TERN0(HAS_##A##2_MIN, !(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor)) A##2_STEP_WRITE(V); \
     }                                                                                                                       \
@@ -285,7 +285,7 @@ xyze_int8_t Stepper::count_direction{0};
 
 #define TRIPLE_ENDSTOP_APPLY_STEP(A,V)                                                                                      \
   if (separate_multi_axis) {                                                                                                \
-    if (A##_HOME_DIR < 0) {                                                                                                 \
+    if (A##_HOME_TO_MIN) {                                                                                                  \
       if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
       if (!(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
       if (!(TEST(endstops.state(), A##3_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##3_motor) A##3_STEP_WRITE(V); \
@@ -316,7 +316,7 @@ xyze_int8_t Stepper::count_direction{0};
 
 #define QUAD_ENDSTOP_APPLY_STEP(A,V)                                                                                        \
   if (separate_multi_axis) {                                                                                                \
-    if (A##_HOME_DIR < 0) {                                                                                                 \
+    if (A##_HOME_TO_MIN) {                                                                                                  \
       if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
       if (!(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
       if (!(TEST(endstops.state(), A##3_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##3_motor) A##3_STEP_WRITE(V); \

commit 02f904dbf9df999264099a26c563b07b1d163df4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:53:52 2021 -0500

    ♻️ Minimize endstop bits

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index ff2be0c356..e8f578ae91 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -260,12 +260,12 @@ xyze_int8_t Stepper::count_direction{0};
 #define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                        \
   if (separate_multi_axis) {                                                                                                \
     if (A##_HOME_DIR < 0) {                                                                                                 \
-      if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
-      if (!(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
+      if (TERN0(HAS_##A##_MIN, !(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor)) A##_STEP_WRITE(V);     \
+      if (TERN0(HAS_##A##2_MIN, !(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor)) A##2_STEP_WRITE(V); \
     }                                                                                                                       \
     else {                                                                                                                  \
-      if (!(TEST(endstops.state(), A##_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
-      if (!(TEST(endstops.state(), A##2_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
+      if (TERN0(HAS_##A##_MAX, !(TEST(endstops.state(), A##_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##_motor)) A##_STEP_WRITE(V);     \
+      if (TERN0(HAS_##A##2_MAX, !(TEST(endstops.state(), A##2_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##2_motor)) A##2_STEP_WRITE(V); \
     }                                                                                                                       \
   }                                                                                                                         \
   else {                                                                                                                    \

commit d97c1f1c6245e2b1f3152e5a210ed840b4bdbefb
Author: Jamie <vector76@users.noreply.github.com>
Date:   Fri May 14 00:14:13 2021 -0500

    ✨ Instant Freeze/Resume Function (#17462)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 5a5fa3afe6..ff2be0c356 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -179,6 +179,10 @@ bool Stepper::abort_current_block;
 uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
 uint8_t Stepper::steps_per_isr;
 
+#if HAS_FREEZE_PIN
+  bool Stepper::frozen; // = false
+#endif
+
 IF_DISABLED(ADAPTIVE_STEP_SMOOTHING, constexpr) uint8_t Stepper::oversampling_factor;
 
 xyze_long_t Stepper::delta_error{0};
@@ -1531,6 +1535,9 @@ void Stepper::pulse_phase_isr() {
   // If there is no current block, do nothing
   if (!current_block) return;
 
+  // Skipping step processing causes motion to freeze
+  if (TERN0(HAS_FREEZE_PIN, frozen)) return;
+
   // Count of pending loops and events for this iteration
   const uint32_t pending_events = step_event_count - step_events_completed;
   uint8_t events_to_do = _MIN(pending_events, steps_per_isr);

commit 37e671612ee224b97e0500a33b887df675e580ec
Author: BigTreeTech <38851044+bigtreetech@users.noreply.github.com>
Date:   Sat Apr 10 16:44:36 2021 +0800

    Fix M114 E / R broken by `LIN_ADVANCE` (#21579)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 8c377bf7bf..5a5fa3afe6 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1697,12 +1697,12 @@ void Stepper::pulse_phase_isr() {
       #if EITHER(LIN_ADVANCE, MIXING_EXTRUDER)
         delta_error.e += advance_dividend.e;
         if (delta_error.e >= 0) {
-          count_position.e += count_direction.e;
           #if ENABLED(LIN_ADVANCE)
             delta_error.e -= advance_divisor;
             // Don't step E here - But remember the number of steps to perform
             motor_direction(E_AXIS) ? --LA_steps : ++LA_steps;
           #else
+            count_position.e += count_direction.e;
             step_needed.e = true;
           #endif
         }
@@ -2283,15 +2283,23 @@ uint32_t Stepper::block_phase_isr() {
     #if ENABLED(MIXING_EXTRUDER)
       // We don't know which steppers will be stepped because LA loop follows,
       // with potentially multiple steps. Set all.
-      if (LA_steps > 0)
+      if (LA_steps > 0) {
         MIXER_STEPPER_LOOP(j) NORM_E_DIR(j);
-      else if (LA_steps < 0)
+        count_direction.e = 1;
+      }
+      else if (LA_steps < 0) {
         MIXER_STEPPER_LOOP(j) REV_E_DIR(j);
+        count_direction.e = -1;
+      }
     #else
-      if (LA_steps > 0)
+      if (LA_steps > 0) {
         NORM_E_DIR(stepper_extruder);
-      else if (LA_steps < 0)
+        count_direction.e = 1;
+      }
+      else if (LA_steps < 0) {
         REV_E_DIR(stepper_extruder);
+        count_direction.e = -1;
+      }
     #endif
 
     DIR_WAIT_AFTER();
@@ -2312,6 +2320,8 @@ uint32_t Stepper::block_phase_isr() {
           AWAIT_LOW_PULSE();
       #endif
 
+      count_position.e += count_direction.e;
+
       // Set the STEP pulse ON
       #if ENABLED(MIXING_EXTRUDER)
         E_STEP_WRITE(mixer.get_next_stepper(), !INVERT_E_STEP_PIN);

commit 3b73b115ca9366f0155986b717d4c85c31ed2f80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 29 20:36:37 2021 -0500

    Apply pointer formatting

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 49eca7047c..8c377bf7bf 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2362,7 +2362,7 @@ uint32_t Stepper::block_phase_isr() {
 // Check if the given block is busy or not - Must not be called from ISR contexts
 // The current_block could change in the middle of the read by an Stepper ISR, so
 // we must explicitly prevent that!
-bool Stepper::is_block_busy(const block_t* const block) {
+bool Stepper::is_block_busy(const block_t * const block) {
   #ifdef __AVR__
     // A SW memory barrier, to ensure GCC does not overoptimize loops
     #define sw_barrier() asm volatile("": : :"memory");
@@ -2372,7 +2372,7 @@ bool Stepper::is_block_busy(const block_t* const block) {
     // This works because stepper ISRs happen at a slower rate than
     // successive reads of a variable, so 2 consecutive reads with
     // the same value means no interrupt updated it.
-    block_t* vold, *vnew = current_block;
+    block_t *vold, *vnew = current_block;
     sw_barrier();
     do {
       vold = vnew;

commit 30e7e2c2766d7dbbe0144344287994f1969dfadd
Author: Martijn Bosgraaf <drywfiltiarn+github@gmail.com>
Date:   Wed Mar 24 18:21:11 2021 +0100

    Extend M106/M107 for better laser module support (#16082)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 77fa6539bc..49eca7047c 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1988,9 +1988,18 @@ uint32_t Stepper::block_phase_isr() {
     // Anything in the buffer?
     if ((current_block = planner.get_current_block())) {
 
-      // Sync block? Sync the stepper counts and return
-      while (TEST(current_block->flag, BLOCK_BIT_SYNC_POSITION)) {
-        _set_position(current_block->position);
+      // Sync block? Sync the stepper counts or fan speeds and return
+      while (current_block->flag & BLOCK_MASK_SYNC) {
+
+        #if ENABLED(LASER_SYNCHRONOUS_M106_M107)
+          const bool is_sync_fans = TEST(current_block->flag, BLOCK_BIT_SYNC_FANS);
+          if (is_sync_fans) planner.sync_fan_speeds(current_block->fan_speed);
+        #else
+          constexpr bool is_sync_fans = false;
+        #endif
+
+        if (!is_sync_fans) _set_position(current_block->position);
+
         discard_current_block();
 
         // Try to get a new block

commit 2d2291d00eab6159de24eb7ff74001b1d6dd29e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 24 05:40:28 2021 -0500

    More IntelliSense-friendly declarations

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 466f4f333a..77fa6539bc 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2130,9 +2130,7 @@ uint32_t Stepper::block_phase_isr() {
       accelerate_until = current_block->accelerate_until << oversampling;
       decelerate_after = current_block->decelerate_after << oversampling;
 
-      #if ENABLED(MIXING_EXTRUDER)
-        MIXER_STEPPER_SETUP();
-      #endif
+      TERN_(MIXING_EXTRUDER, mixer.stepper_setup(current_block->b_color))
 
       TERN_(HAS_MULTI_EXTRUDER, stepper_extruder = current_block->extruder);
 

commit acda53aa1c386324b6fb2cf30c77f4e3d06914dc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jan 8 15:07:35 2021 -0600

    Clean up some includes

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c92dd4512d..466f4f333a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -91,7 +91,6 @@ Stepper stepper; // Singleton
 #include "planner.h"
 #include "motion.h"
 
-#include "temperature.h"
 #include "../lcd/marlinui.h"
 #include "../gcode/queue.h"
 #include "../sd/cardreader.h"

commit e3831c146d635530f0e7e3af1afc86186038cd1e
Author: wilbur4321 <wilbur4321@gmail.com>
Date:   Tue Jan 5 15:03:45 2021 -0800

    Multi-Z stepper inverting (#20678)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 8b4bc23cb9..c92dd4512d 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -381,7 +381,10 @@ xyze_int8_t Stepper::count_direction{0};
 #endif
 
 #if NUM_Z_STEPPER_DRIVERS == 4
-  #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(v); Z3_DIR_WRITE(v); Z4_DIR_WRITE(v); }while(0)
+  #define Z_APPLY_DIR(v,Q) do{ \
+    Z_DIR_WRITE(v); Z2_DIR_WRITE((v) ^ ENABLED(INVERT_Z2_VS_Z_DIR)); \
+    Z3_DIR_WRITE((v) ^ ENABLED(INVERT_Z3_VS_Z_DIR)); Z4_DIR_WRITE((v) ^ ENABLED(INVERT_Z4_VS_Z_DIR)); \
+  }while(0)
   #if ENABLED(Z_MULTI_ENDSTOPS)
     #define Z_APPLY_STEP(v,Q) QUAD_ENDSTOP_APPLY_STEP(Z,v)
   #elif ENABLED(Z_STEPPER_AUTO_ALIGN)
@@ -390,7 +393,9 @@ xyze_int8_t Stepper::count_direction{0};
     #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); Z3_STEP_WRITE(v); Z4_STEP_WRITE(v); }while(0)
   #endif
 #elif NUM_Z_STEPPER_DRIVERS == 3
-  #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(v); Z3_DIR_WRITE(v); }while(0)
+  #define Z_APPLY_DIR(v,Q) do{ \
+    Z_DIR_WRITE(v); Z2_DIR_WRITE((v) ^ ENABLED(INVERT_Z2_VS_Z_DIR)); Z3_DIR_WRITE((v) ^ ENABLED(INVERT_Z3_VS_Z_DIR)); \
+  }while(0)
   #if ENABLED(Z_MULTI_ENDSTOPS)
     #define Z_APPLY_STEP(v,Q) TRIPLE_ENDSTOP_APPLY_STEP(Z,v)
   #elif ENABLED(Z_STEPPER_AUTO_ALIGN)
@@ -399,7 +404,7 @@ xyze_int8_t Stepper::count_direction{0};
     #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); Z3_STEP_WRITE(v); }while(0)
   #endif
 #elif NUM_Z_STEPPER_DRIVERS == 2
-  #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(v); }while(0)
+  #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE((v) ^ ENABLED(INVERT_Z2_VS_Z_DIR)); }while(0)
   #if ENABLED(Z_MULTI_ENDSTOPS)
     #define Z_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Z,v)
   #elif ENABLED(Z_STEPPER_AUTO_ALIGN)

commit a97a1ae218d141a32ea7c3fadc64672d845b8bcd
Author: phcay <58492957+phcay@users.noreply.github.com>
Date:   Sat Nov 14 02:24:08 2020 +0100

    Fix extraneous Linear Advance DIR change (#20131)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 627ecf9ebb..8b4bc23cb9 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2255,7 +2255,6 @@ uint32_t Stepper::block_phase_isr() {
         interval = LA_isr_rate;
       }
       else if (step_events_completed < decelerate_after && LA_current_adv_steps < LA_max_adv_steps) {
-             //step_events_completed <= (uint32_t)accelerate_until) {
         LA_steps++;
         LA_current_adv_steps++;
         interval = LA_isr_rate;
@@ -2266,6 +2265,8 @@ uint32_t Stepper::block_phase_isr() {
     else
       interval = LA_ADV_NEVER;
 
+    if (!LA_steps) return interval; // Leave pins alone if there are no steps!
+
     DIR_WAIT_BEFORE();
 
     #if ENABLED(MIXING_EXTRUDER)

commit 06bf3ccfb7a19c972e5f40816d49e3860711f976
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 7 18:28:29 2020 -0600

    Add alternative TERN macros

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 0a83a90ba2..627ecf9ebb 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -180,7 +180,7 @@ bool Stepper::abort_current_block;
 uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
 uint8_t Stepper::steps_per_isr;
 
-TERN(ADAPTIVE_STEP_SMOOTHING,,constexpr) uint8_t Stepper::oversampling_factor;
+IF_DISABLED(ADAPTIVE_STEP_SMOOTHING, constexpr) uint8_t Stepper::oversampling_factor;
 
 xyze_long_t Stepper::delta_error{0};
 

commit 6fed11896ba7c51ba5f5ade4346c94ff048b1718
Author: Sten Uusvali <31988255+nuevocampo@users.noreply.github.com>
Date:   Sat Oct 17 14:11:22 2020 -0700

    Fix M503 output for M907 motor current (#19777)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 7b3e13eff4..0a83a90ba2 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2962,7 +2962,7 @@ void Stepper::report_positions() {
   #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
 
     void Stepper::set_digipot_current(const uint8_t driver, const int16_t current) {
-      if (WITHIN(driver, 0, COUNT(motor_current_setting) - 1))
+      if (WITHIN(driver, 0, MOTOR_CURRENT_COUNT - 1))
         motor_current_setting[driver] = current; // update motor_current_setting
 
       if (!initialized) return;

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 2201577717..7b3e13eff4 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -92,7 +92,7 @@ Stepper stepper; // Singleton
 #include "motion.h"
 
 #include "temperature.h"
-#include "../lcd/ultralcd.h"
+#include "../lcd/marlinui.h"
 #include "../gcode/queue.h"
 #include "../sd/cardreader.h"
 #include "../MarlinCore.h"

commit 418b3e5ee26c0284561f07cf462af27971715d12
Author: nb-rapidia <43864438+nb-rapidia@users.noreply.github.com>
Date:   Fri Oct 16 14:59:55 2020 -0700

    Fix IDEX layer shift and DIR states (#19756)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 8a5de4b608..2201577717 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -348,7 +348,7 @@ xyze_int8_t Stepper::count_direction{0};
   }
 
 #if ENABLED(X_DUAL_STEPPER_DRIVERS)
-  #define X_APPLY_DIR(v,Q) do{ X_DIR_WRITE(v); X2_DIR_WRITE((v) != INVERT_X2_VS_X_DIR); }while(0)
+  #define X_APPLY_DIR(v,Q) do{ X_DIR_WRITE(v); X2_DIR_WRITE((v) ^ ENABLED(INVERT_X2_VS_X_DIR)); }while(0)
   #if ENABLED(X_DUAL_ENDSTOPS)
     #define X_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(X,v)
   #else
@@ -356,7 +356,7 @@ xyze_int8_t Stepper::count_direction{0};
   #endif
 #elif ENABLED(DUAL_X_CARRIAGE)
   #define X_APPLY_DIR(v,ALWAYS) do{ \
-    if (extruder_duplication_enabled || ALWAYS) { X_DIR_WRITE(v); X2_DIR_WRITE(mirrored_duplication_mode ? !(v) : v); } \
+    if (extruder_duplication_enabled || ALWAYS) { X_DIR_WRITE(v); X2_DIR_WRITE((v) ^ idex_mirrored_mode); } \
     else if (last_moved_extruder) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \
   }while(0)
   #define X_APPLY_STEP(v,ALWAYS) do{ \
@@ -369,7 +369,7 @@ xyze_int8_t Stepper::count_direction{0};
 #endif
 
 #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-  #define Y_APPLY_DIR(v,Q) do{ Y_DIR_WRITE(v); Y2_DIR_WRITE((v) != INVERT_Y2_VS_Y_DIR); }while(0)
+  #define Y_APPLY_DIR(v,Q) do{ Y_DIR_WRITE(v); Y2_DIR_WRITE((v) ^ ENABLED(INVERT_Y2_VS_Y_DIR)); }while(0)
   #if ENABLED(Y_DUAL_ENDSTOPS)
     #define Y_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Y,v)
   #else
@@ -1605,10 +1605,9 @@ void Stepper::pulse_phase_isr() {
               PAGE_SEGMENT_UPDATE(Z, high >> 4);
               PAGE_SEGMENT_UPDATE(E, high & 0xF);
 
-              if (dm != last_direction_bits) {
-                last_direction_bits = dm;
-                set_directions();
-              }
+              if (dm != last_direction_bits)
+                set_directions(dm);
+
             } break;
 
             default: break;
@@ -2131,9 +2130,7 @@ uint32_t Stepper::block_phase_isr() {
         MIXER_STEPPER_SETUP();
       #endif
 
-      #if HAS_MULTI_EXTRUDER
-        stepper_extruder = current_block->extruder;
-      #endif
+      TERN_(HAS_MULTI_EXTRUDER, stepper_extruder = current_block->extruder);
 
       // Initialize the trapezoid generator from the current block.
       #if ENABLED(LIN_ADVANCE)
@@ -2151,17 +2148,14 @@ uint32_t Stepper::block_phase_isr() {
         else LA_isr_rate = LA_ADV_NEVER;
       #endif
 
-      if ( ENABLED(HAS_L64XX)  // Always set direction for L64xx (Also enables the chips)
+      if ( ENABLED(HAS_L64XX)       // Always set direction for L64xx (Also enables the chips)
+        || ENABLED(DUAL_X_CARRIAGE) // TODO: Find out why this fixes "jittery" small circles
         || current_block->direction_bits != last_direction_bits
         || TERN(MIXING_EXTRUDER, false, stepper_extruder != last_moved_extruder)
       ) {
-        last_direction_bits = current_block->direction_bits;
-        #if HAS_MULTI_EXTRUDER
-          last_moved_extruder = stepper_extruder;
-        #endif
-
+        TERN_(HAS_MULTI_EXTRUDER, last_moved_extruder = stepper_extruder);
         TERN_(HAS_L64XX, L64XX_OK_to_power_up = true);
-        set_directions();
+        set_directions(current_block->direction_bits);
       }
 
       #if ENABLED(LASER_POWER_INLINE)
@@ -2583,12 +2577,9 @@ void Stepper::init() {
   #endif
 
   // Init direction bits for first moves
-  last_direction_bits = 0
-    | (INVERT_X_DIR ? _BV(X_AXIS) : 0)
-    | (INVERT_Y_DIR ? _BV(Y_AXIS) : 0)
-    | (INVERT_Z_DIR ? _BV(Z_AXIS) : 0);
-
-  set_directions();
+  set_directions((INVERT_X_DIR ? _BV(X_AXIS) : 0)
+               | (INVERT_Y_DIR ? _BV(Y_AXIS) : 0)
+               | (INVERT_Z_DIR ? _BV(Z_AXIS) : 0));
 
   #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
     initialized = true;

commit 492ba2a111ce541513d4515c4af3f57ceaa897ea
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 11 14:58:35 2020 -0500

    Digipots refactor / cleanup (#19690)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 56a75d1b48..8a5de4b608 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -83,10 +83,6 @@ Stepper stepper; // Singleton
 
 #define BABYSTEPPING_EXTRA_DIR_WAIT
 
-#if HAS_MOTOR_CURRENT_PWM
-  bool Stepper::initialized; // = false
-#endif
-
 #ifdef __AVR__
   #include "speed_lookuptable.h"
 #endif
@@ -110,7 +106,7 @@ Stepper stepper; // Singleton
   #include "../feature/dac/dac_dac084s085.h"
 #endif
 
-#if HAS_DIGIPOTSS
+#if HAS_MOTOR_CURRENT_SPI
   #include <SPI.h>
 #endif
 
@@ -142,8 +138,12 @@ Stepper stepper; // Singleton
   bool Stepper::separate_multi_axis = false;
 #endif
 
-#if HAS_MOTOR_CURRENT_PWM
-  uint32_t Stepper::motor_current_setting[3]; // Initialized by settings.load()
+#if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
+  bool Stepper::initialized; // = false
+  uint32_t Stepper::motor_current_setting[MOTOR_CURRENT_COUNT]; // Initialized by settings.load()
+  #if HAS_MOTOR_CURRENT_SPI
+    constexpr uint32_t Stepper::digipot_count[];
+  #endif
 #endif
 
 // private:
@@ -2590,8 +2590,8 @@ void Stepper::init() {
 
   set_directions();
 
-  #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
-    TERN_(HAS_MOTOR_CURRENT_PWM, initialized = true);
+  #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
+    initialized = true;
     digipot_init();
   #endif
 }
@@ -2930,10 +2930,10 @@ void Stepper::report_positions() {
  * Software-controlled Stepper Motor Current
  */
 
-#if HAS_DIGIPOTSS
+#if HAS_MOTOR_CURRENT_SPI
 
   // From Arduino DigitalPotControl example
-  void Stepper::digitalPotWrite(const int16_t address, const int16_t value) {
+  void Stepper::set_digipot_value_spi(const int16_t address, const int16_t value) {
     WRITE(DIGIPOTSS_PIN, LOW);  // Take the SS pin low to select the chip
     SPI.transfer(address);      // Send the address and value via SPI
     SPI.transfer(value);
@@ -2941,7 +2941,7 @@ void Stepper::report_positions() {
     //delay(10);
   }
 
-#endif // HAS_DIGIPOTSS
+#endif // HAS_MOTOR_CURRENT_SPI
 
 #if HAS_MOTOR_CURRENT_PWM
 
@@ -2958,7 +2958,7 @@ void Stepper::report_positions() {
         #if ANY_PIN(MOTOR_CURRENT_PWM_E, MOTOR_CURRENT_PWM_E0, MOTOR_CURRENT_PWM_E1)
           case 2:
         #endif
-            digipot_current(i, motor_current_setting[i]);
+            set_digipot_current(i, motor_current_setting[i]);
         default: break;
       }
     }
@@ -2968,21 +2968,22 @@ void Stepper::report_positions() {
 
 #if !MB(PRINTRBOARD_G2)
 
-  #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
+  #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
 
-    void Stepper::digipot_current(const uint8_t driver, const int16_t current) {
+    void Stepper::set_digipot_current(const uint8_t driver, const int16_t current) {
+      if (WITHIN(driver, 0, COUNT(motor_current_setting) - 1))
+        motor_current_setting[driver] = current; // update motor_current_setting
 
-      #if HAS_DIGIPOTSS
+      if (!initialized) return;
 
-        const uint8_t digipot_ch[] = DIGIPOT_CHANNELS;
-        digitalPotWrite(digipot_ch[driver], current);
+      #if HAS_MOTOR_CURRENT_SPI
 
-      #elif HAS_MOTOR_CURRENT_PWM
+        //SERIAL_ECHOLNPAIR("Digipotss current ", current);
 
-        if (!initialized) return;
+        const uint8_t digipot_ch[] = DIGIPOT_CHANNELS;
+        set_digipot_value_spi(digipot_ch[driver], current);
 
-        if (WITHIN(driver, 0, COUNT(motor_current_setting) - 1))
-          motor_current_setting[driver] = current; // update motor_current_setting
+      #elif HAS_MOTOR_CURRENT_PWM
 
         #define _WRITE_CURRENT_PWM(P) analogWrite(pin_t(MOTOR_CURRENT_PWM_## P ##_PIN), 255L * current / (MOTOR_CURRENT_PWM_RANGE))
         switch (driver) {
@@ -3019,17 +3020,13 @@ void Stepper::report_positions() {
 
     void Stepper::digipot_init() {
 
-      #if HAS_DIGIPOTSS
-
-        static const uint8_t digipot_motor_current[] = DIGIPOT_MOTOR_CURRENT;
+      #if HAS_MOTOR_CURRENT_SPI
 
         SPI.begin();
         SET_OUTPUT(DIGIPOTSS_PIN);
 
-        LOOP_L_N(i, COUNT(digipot_motor_current)) {
-          //digitalPotWrite(digipot_ch[i], digipot_motor_current[i]);
-          digipot_current(i, digipot_motor_current[i]);
-        }
+        LOOP_L_N(i, COUNT(motor_current_setting))
+          set_digipot_current(i, motor_current_setting[i]);
 
       #elif HAS_MOTOR_CURRENT_PWM
 

commit 76d8d1742c1d4a1efe0fd6c0645d3fc656bfd0b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 20 18:29:08 2020 -0500

    Add multi-extruder condition

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index fab1a61548..56a75d1b48 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -155,7 +155,7 @@ uint8_t Stepper::last_direction_bits, // = 0
 
 bool Stepper::abort_current_block;
 
-#if DISABLED(MIXING_EXTRUDER) && EXTRUDERS > 1
+#if DISABLED(MIXING_EXTRUDER) && HAS_MULTI_EXTRUDER
   uint8_t Stepper::last_moved_extruder = 0xFF;
 #endif
 
@@ -191,7 +191,7 @@ uint32_t Stepper::advance_divisor = 0,
          Stepper::decelerate_after,          // The count at which to start decelerating
          Stepper::step_event_count;          // The total event count for the current block
 
-#if EXTRUDERS > 1 || ENABLED(MIXING_EXTRUDER)
+#if EITHER(HAS_MULTI_EXTRUDER, MIXING_EXTRUDER)
   uint8_t Stepper::stepper_extruder;
 #else
   constexpr uint8_t Stepper::stepper_extruder;
@@ -357,11 +357,11 @@ xyze_int8_t Stepper::count_direction{0};
 #elif ENABLED(DUAL_X_CARRIAGE)
   #define X_APPLY_DIR(v,ALWAYS) do{ \
     if (extruder_duplication_enabled || ALWAYS) { X_DIR_WRITE(v); X2_DIR_WRITE(mirrored_duplication_mode ? !(v) : v); } \
-    else if (movement_extruder()) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \
+    else if (last_moved_extruder) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \
   }while(0)
   #define X_APPLY_STEP(v,ALWAYS) do{ \
     if (extruder_duplication_enabled || ALWAYS) { X_STEP_WRITE(v); X2_STEP_WRITE(v); } \
-    else if (movement_extruder()) X2_STEP_WRITE(v); else X_STEP_WRITE(v); \
+    else if (last_moved_extruder) X2_STEP_WRITE(v); else X_STEP_WRITE(v); \
   }while(0)
 #else
   #define X_APPLY_DIR(v,Q) X_DIR_WRITE(v)
@@ -2131,7 +2131,7 @@ uint32_t Stepper::block_phase_isr() {
         MIXER_STEPPER_SETUP();
       #endif
 
-      #if EXTRUDERS > 1
+      #if HAS_MULTI_EXTRUDER
         stepper_extruder = current_block->extruder;
       #endif
 
@@ -2156,7 +2156,7 @@ uint32_t Stepper::block_phase_isr() {
         || TERN(MIXING_EXTRUDER, false, stepper_extruder != last_moved_extruder)
       ) {
         last_direction_bits = current_block->direction_bits;
-        #if EXTRUDERS > 1
+        #if HAS_MULTI_EXTRUDER
           last_moved_extruder = stepper_extruder;
         #endif
 

commit e97e6865c3e587a04ae2878e72a8dfb137534b7e
Author: Victor Sokolov <gzigzigzeo@gmail.com>
Date:   Fri Sep 4 05:12:53 2020 +0400

    MarkForged kinematics (#19235)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 0e70fd370c..fab1a61548 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2041,6 +2041,8 @@ uint32_t Stepper::block_phase_isr() {
           #define X_CMP(A,B) ((A)!=(B))
         #endif
         #define X_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && X_CMP(D_(1),D_(2))) )
+      #elif ENABLED(MARKFORGED_XY)
+        #define X_MOVE_TEST (current_block->steps.a != current_block->steps.b)
       #else
         #define X_MOVE_TEST !!current_block->steps.a
       #endif
@@ -2614,6 +2616,8 @@ void Stepper::_set_position(const int32_t &a, const int32_t &b, const int32_t &c
   #elif CORE_IS_YZ
     // coreyz planning
     count_position.set(a, b + c, CORESIGN(b - c));
+  #elif ENABLED(MARKFORGED_XY)
+    count_position.set(a - b, b, c);
   #else
     // default non-h-bot planning
     count_position.set(a, b, c);
@@ -2680,6 +2684,10 @@ void Stepper::endstop_triggered(const AxisEnum axis) {
         ? CORESIGN(count_position[CORE_AXIS_1] - count_position[CORE_AXIS_2])
         : count_position[CORE_AXIS_1] + count_position[CORE_AXIS_2]
       ) * double(0.5)
+    #elif ENABLED(MARKFORGED_XY)
+      axis == CORE_AXIS_1
+        ? count_position[CORE_AXIS_1] - count_position[CORE_AXIS_2]
+        : count_position[CORE_AXIS_2]
     #else // !IS_CORE
       count_position[axis]
     #endif
@@ -2709,12 +2717,12 @@ int32_t Stepper::triggered_position(const AxisEnum axis) {
 }
 
 void Stepper::report_a_position(const xyz_long_t &pos) {
-  #if CORE_IS_XY || CORE_IS_XZ || ENABLED(DELTA) || IS_SCARA
+  #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, DELTA, IS_SCARA)
     SERIAL_ECHOPAIR(STR_COUNT_A, pos.x, " B:", pos.y);
   #else
     SERIAL_ECHOPAIR_P(PSTR(STR_COUNT_X), pos.x, SP_Y_LBL, pos.y);
   #endif
-  #if CORE_IS_XZ || CORE_IS_YZ || ENABLED(DELTA)
+  #if ANY(CORE_IS_XZ, CORE_IS_YZ, DELTA)
     SERIAL_ECHOLNPAIR(" C:", pos.z);
   #else
     SERIAL_ECHOLNPAIR_P(SP_Z_LBL, pos.z);

commit 131ddeaeba96addcf573cbeff86b65225d3b8320
Author: Colin Godsey <crgodsey@gmail.com>
Date:   Wed Aug 26 00:32:56 2020 -0600

    Direct Stepping update (#19135)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index e5f65a3cdd..0e70fd370c 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1578,12 +1578,11 @@ void Stepper::pulse_phase_isr() {
 
         #if STEPPER_PAGE_FORMAT == SP_4x4D_128
 
-          #define PAGE_SEGMENT_UPDATE(AXIS, VALUE, MID) do{ \
-                 if ((VALUE) == MID) {}                     \
-            else if ((VALUE) <  MID) SBI(dm, _AXIS(AXIS));  \
-            else                     CBI(dm, _AXIS(AXIS));  \
-            page_step_state.sd[_AXIS(AXIS)] = VALUE;        \
-            page_step_state.bd[_AXIS(AXIS)] += VALUE;       \
+          #define PAGE_SEGMENT_UPDATE(AXIS, VALUE) do{   \
+                 if ((VALUE) <  7) SBI(dm, _AXIS(AXIS)); \
+            else if ((VALUE) >  7) CBI(dm, _AXIS(AXIS)); \
+            page_step_state.sd[_AXIS(AXIS)] = VALUE;     \
+            page_step_state.bd[_AXIS(AXIS)] += VALUE;    \
           }while(0)
 
           #define PAGE_PULSE_PREP(AXIS) do{ \
@@ -1592,7 +1591,7 @@ void Stepper::pulse_phase_isr() {
           }while(0)
 
           switch (page_step_state.segment_steps) {
-            case 8:
+            case DirectStepping::Config::SEGMENT_STEPS:
               page_step_state.segment_idx += 2;
               page_step_state.segment_steps = 0;
               // fallthru
@@ -1601,10 +1600,10 @@ void Stepper::pulse_phase_isr() {
                            high = page_step_state.page[page_step_state.segment_idx + 1];
               uint8_t dm = last_direction_bits;
 
-              PAGE_SEGMENT_UPDATE(X, low >> 4, 7);
-              PAGE_SEGMENT_UPDATE(Y, low & 0xF, 7);
-              PAGE_SEGMENT_UPDATE(Z, high >> 4, 7);
-              PAGE_SEGMENT_UPDATE(E, high & 0xF, 7);
+              PAGE_SEGMENT_UPDATE(X, low >> 4);
+              PAGE_SEGMENT_UPDATE(Y, low & 0xF);
+              PAGE_SEGMENT_UPDATE(Z, high >> 4);
+              PAGE_SEGMENT_UPDATE(E, high & 0xF);
 
               if (dm != last_direction_bits) {
                 last_direction_bits = dm;
@@ -1615,9 +1614,9 @@ void Stepper::pulse_phase_isr() {
             default: break;
           }
 
-          PAGE_PULSE_PREP(X),
-          PAGE_PULSE_PREP(Y),
-          PAGE_PULSE_PREP(Z),
+          PAGE_PULSE_PREP(X);
+          PAGE_PULSE_PREP(Y);
+          PAGE_PULSE_PREP(Z);
           PAGE_PULSE_PREP(E);
 
           page_step_state.segment_steps++;
@@ -1634,7 +1633,7 @@ void Stepper::pulse_phase_isr() {
           }while(0)
 
           switch (page_step_state.segment_steps) {
-            case 4:
+            case DirectStepping::Config::SEGMENT_STEPS:
               page_step_state.segment_idx++;
               page_step_state.segment_steps = 0;
               // fallthru
@@ -1664,7 +1663,6 @@ void Stepper::pulse_phase_isr() {
           }while(0)
 
           uint8_t steps = page_step_state.page[page_step_state.segment_idx >> 1];
-
           if (page_step_state.segment_idx & 0x1) steps >>= 4;
 
           PAGE_PULSE_PREP(X, 3);

commit d3c51614760b87d4844b77f2459195ffc2cd9a62
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Wed Aug 19 09:59:37 2020 +0200

    Fix __ARM__ / __arm__ typo (#19063)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c9d87486f8..e5f65a3cdd 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1264,7 +1264,7 @@ void Stepper::set_directions() {
     }
 
     FORCE_INLINE int32_t Stepper::_eval_bezier_curve(const uint32_t curr_step) {
-      #if defined(__ARM__) || defined(__thumb__)
+      #if defined(__arm__) || defined(__thumb__)
 
         // For ARM Cortex M3/M4 CPUs, we have the optimized assembler version, that takes 43 cycles to execute
         uint32_t flo = 0;

commit d20d4591321aa467c062f0050355d2aca84e03ad
Author: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
Date:   Sat Jul 25 13:52:07 2020 +0800

    Robin nano V2, TFT LVGL UI parameters, and more (#18500)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 20514853ea..c9d87486f8 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2551,7 +2551,7 @@ void Stepper::init() {
     AXIS_INIT(Z, Z);
   #endif
 
-  #if E_STEPPERS > 0 && HAS_E0_STEP
+  #if E_STEPPERS && HAS_E0_STEP
     E_AXIS_INIT(0);
   #endif
   #if E_STEPPERS > 1 && HAS_E1_STEP

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b240c5519d..20514853ea 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
@@ -38,7 +38,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
+ * along with Grbl.  If not, see <https://www.gnu.org/licenses/>.
  */
 
 /**
@@ -2608,7 +2608,7 @@ void Stepper::init() {
 void Stepper::_set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
   #if CORE_IS_XY
     // corexy positioning
-    // these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html
+    // these equations follow the form of the dA and dB equations on https://www.corexy.com/theory.html
     count_position.set(a + b, CORESIGN(a - b), c);
   #elif CORE_IS_XZ
     // corexz planning

commit f9b1da7beb6f66959b6c6171809132ab591bd817
Author: Jason Smith <jason.inet@gmail.com>
Date:   Wed Jul 22 20:17:33 2020 -0700

    Linear Advance: Only change E DIR when needed (#18744)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 2a9e4dae21..b240c5519d 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2277,14 +2277,14 @@ uint32_t Stepper::block_phase_isr() {
     #if ENABLED(MIXING_EXTRUDER)
       // We don't know which steppers will be stepped because LA loop follows,
       // with potentially multiple steps. Set all.
-      if (LA_steps >= 0)
+      if (LA_steps > 0)
         MIXER_STEPPER_LOOP(j) NORM_E_DIR(j);
-      else
+      else if (LA_steps < 0)
         MIXER_STEPPER_LOOP(j) REV_E_DIR(j);
     #else
-      if (LA_steps >= 0)
+      if (LA_steps > 0)
         NORM_E_DIR(stepper_extruder);
-      else
+      else if (LA_steps < 0)
         REV_E_DIR(stepper_extruder);
     #endif
 

commit a847f37d43e4571ddc848172caa71e49c087eebe
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Jul 19 19:53:29 2020 -0700

    Reduce Step Smoothing ceiling to 50% CPU usage (#18719)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 16ff134923..2a9e4dae21 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2099,11 +2099,11 @@ uint32_t Stepper::block_phase_isr() {
       #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
         uint8_t oversampling = 0;                           // Assume no axis smoothing (via oversampling)
         // Decide if axis smoothing is possible
-        uint32_t max_rate = current_block->nominal_rate;    // Get the maximum rate (maximum event speed)
+        uint32_t max_rate = current_block->nominal_rate;    // Get the step event rate
         while (max_rate < MIN_STEP_ISR_FREQUENCY) {         // As long as more ISRs are possible...
           max_rate <<= 1;                                   // Try to double the rate
-          if (max_rate >= MAX_STEP_ISR_FREQUENCY_1X) break; // Don't exceed the estimated ISR limit
-          ++oversampling;                                   // Increase the oversampling (used for left-shift)
+          if (max_rate < MIN_STEP_ISR_FREQUENCY)            // Don't exceed the estimated ISR limit
+            ++oversampling;                                 // Increase the oversampling (used for left-shift)
         }
         oversampling_factor = oversampling;                 // For all timer interval calculations
       #else

commit 55e519a06f47e8c29687ebf2b58cc8117be0afdf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 14 21:26:09 2020 -0500

    General cleanup

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 6b957bad89..16ff134923 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -168,22 +168,19 @@ bool Stepper::abort_current_block;
 
 #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
   bool Stepper::locked_Z_motor = false, Stepper::locked_Z2_motor = false
-       #if NUM_Z_STEPPER_DRIVERS >= 3
-         , Stepper::locked_Z3_motor = false
-         #if NUM_Z_STEPPER_DRIVERS >= 4
-           , Stepper::locked_Z4_motor = false
-         #endif
-       #endif
-       ;
+    #if NUM_Z_STEPPER_DRIVERS >= 3
+      , Stepper::locked_Z3_motor = false
+      #if NUM_Z_STEPPER_DRIVERS >= 4
+        , Stepper::locked_Z4_motor = false
+      #endif
+    #endif
+  ;
 #endif
 
 uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
 uint8_t Stepper::steps_per_isr;
 
-#if DISABLED(ADAPTIVE_STEP_SMOOTHING)
-  constexpr
-#endif
-    uint8_t Stepper::oversampling_factor;
+TERN(ADAPTIVE_STEP_SMOOTHING,,constexpr) uint8_t Stepper::oversampling_factor;
 
 xyze_long_t Stepper::delta_error{0};
 
@@ -2099,17 +2096,18 @@ uint32_t Stepper::block_phase_isr() {
       // No acceleration / deceleration time elapsed so far
       acceleration_time = deceleration_time = 0;
 
-      uint8_t oversampling = 0;                           // Assume no axis smoothing (via oversampling)
-
       #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
+        uint8_t oversampling = 0;                           // Assume no axis smoothing (via oversampling)
         // Decide if axis smoothing is possible
-        uint32_t max_rate = current_block->nominal_rate;  // Get the maximum rate (maximum event speed)
+        uint32_t max_rate = current_block->nominal_rate;    // Get the maximum rate (maximum event speed)
         while (max_rate < MIN_STEP_ISR_FREQUENCY) {         // As long as more ISRs are possible...
           max_rate <<= 1;                                   // Try to double the rate
           if (max_rate >= MAX_STEP_ISR_FREQUENCY_1X) break; // Don't exceed the estimated ISR limit
           ++oversampling;                                   // Increase the oversampling (used for left-shift)
         }
         oversampling_factor = oversampling;                 // For all timer interval calculations
+      #else
+        constexpr uint8_t oversampling = 0;
       #endif
 
       // Based on the oversampling factor, do the calculations

commit 8e20691f423cca37e5b0f4ee301f6b4002a269c5
Author: brian park <gouache95@gmail.com>
Date:   Fri Jun 19 05:28:52 2020 +0900

    Fix Core axis babystepping (#18342)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index aa2c5380cf..6b957bad89 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2850,7 +2850,7 @@ void Stepper::report_positions() {
 
         case Y_AXIS:
           #if CORE_IS_XY
-            BABYSTEP_CORE(X, Y, 0, direction, (CORESIGN(1)<0));
+            BABYSTEP_CORE(X, Y, 1, !direction, (CORESIGN(1)>0));
           #elif CORE_IS_YZ
             BABYSTEP_CORE(Y, Z, 0, direction, (CORESIGN(1)<0));
           #else

commit 51be5955735a31365a0f61712135b67149d80e03
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 16 13:48:14 2020 -0500

    Fix core babystep compile

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b278ae9b4f..aa2c5380cf 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2802,7 +2802,9 @@ void Stepper::report_positions() {
       EXTRA_DIR_WAIT_AFTER();                           \
     }while(0)
 
-  #elif IS_CORE
+  #endif
+
+  #if IS_CORE
 
     #define BABYSTEP_CORE(A, B, INV, DIR, ALT) do{              \
       const xy_byte_t old_dir = { _READ_DIR(A), _READ_DIR(B) }; \

commit eda2fd8dbea69cb8f571f2992cb11334b2cb7a2f
Author: Luu Lac <45380455+shitcreek@users.noreply.github.com>
Date:   Mon Jun 8 00:47:31 2020 -0500

    Improvements for Laser / Spindle (#17661)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 3b1b787af7..b278ae9b4f 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -244,8 +244,8 @@ xyze_long_t Stepper::count_position{0};
 xyze_int8_t Stepper::count_direction{0};
 
 #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
-  Stepper::stepper_laser_t Stepper::laser = {
-    .trap_en = false,
+  Stepper::stepper_laser_t Stepper::laser_trap = {
+    .enabled = false,
     .cur_power = 0,
     .cruise_set = false,
     #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
@@ -1843,28 +1843,28 @@ uint32_t Stepper::block_phase_isr() {
 
         // Update laser - Accelerating
         #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
-          if (laser.trap_en) {
+          if (laser_trap.enabled) {
             #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
               if (current_block->laser.entry_per) {
-                laser.acc_step_count -= step_events_completed - laser.last_step_count;
-                laser.last_step_count = step_events_completed;
+                laser_trap.acc_step_count -= step_events_completed - laser_trap.last_step_count;
+                laser_trap.last_step_count = step_events_completed;
 
                 // Should be faster than a divide, since this should trip just once
-                if (laser.acc_step_count < 0) {
-                  while (laser.acc_step_count < 0) {
-                    laser.acc_step_count += current_block->laser.entry_per;
-                    if (laser.cur_power < current_block->laser.power) laser.cur_power++;
+                if (laser_trap.acc_step_count < 0) {
+                  while (laser_trap.acc_step_count < 0) {
+                    laser_trap.acc_step_count += current_block->laser.entry_per;
+                    if (laser_trap.cur_power < current_block->laser.power) laser_trap.cur_power++;
                   }
-                  cutter.set_ocr_power(laser.cur_power);
+                  cutter.set_ocr_power(laser_trap.cur_power);
                 }
               }
             #else
-              if (laser.till_update)
-                laser.till_update--;
+              if (laser_trap.till_update)
+                laser_trap.till_update--;
               else {
-                laser.till_update = LASER_POWER_INLINE_TRAPEZOID_CONT_PER;
-                laser.cur_power = (current_block->laser.power * acc_step_rate) / current_block->nominal_rate;
-                cutter.set_ocr_power(laser.cur_power); // Cycle efficiency is irrelevant it the last line was many cycles
+                laser_trap.till_update = LASER_POWER_INLINE_TRAPEZOID_CONT_PER;
+                laser_trap.cur_power = (current_block->laser.power * acc_step_rate) / current_block->nominal_rate;
+                cutter.set_ocr_power(laser_trap.cur_power); // Cycle efficiency is irrelevant it the last line was many cycles
               }
             #endif
           }
@@ -1920,28 +1920,28 @@ uint32_t Stepper::block_phase_isr() {
 
         // Update laser - Decelerating
         #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
-          if (laser.trap_en) {
+          if (laser_trap.enabled) {
             #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
               if (current_block->laser.exit_per) {
-                laser.acc_step_count -= step_events_completed - laser.last_step_count;
-                laser.last_step_count = step_events_completed;
+                laser_trap.acc_step_count -= step_events_completed - laser_trap.last_step_count;
+                laser_trap.last_step_count = step_events_completed;
 
                 // Should be faster than a divide, since this should trip just once
-                if (laser.acc_step_count < 0) {
-                  while (laser.acc_step_count < 0) {
-                    laser.acc_step_count += current_block->laser.exit_per;
-                    if (laser.cur_power > current_block->laser.power_exit) laser.cur_power--;
+                if (laser_trap.acc_step_count < 0) {
+                  while (laser_trap.acc_step_count < 0) {
+                    laser_trap.acc_step_count += current_block->laser.exit_per;
+                    if (laser_trap.cur_power > current_block->laser.power_exit) laser_trap.cur_power--;
                   }
-                  cutter.set_ocr_power(laser.cur_power);
+                  cutter.set_ocr_power(laser_trap.cur_power);
                 }
               }
             #else
-              if (laser.till_update)
-                laser.till_update--;
+              if (laser_trap.till_update)
+                laser_trap.till_update--;
               else {
-                laser.till_update = LASER_POWER_INLINE_TRAPEZOID_CONT_PER;
-                laser.cur_power = (current_block->laser.power * step_rate) / current_block->nominal_rate;
-                cutter.set_ocr_power(laser.cur_power); // Cycle efficiency isn't relevant when the last line was many cycles
+                laser_trap.till_update = LASER_POWER_INLINE_TRAPEZOID_CONT_PER;
+                laser_trap.cur_power = (current_block->laser.power * step_rate) / current_block->nominal_rate;
+                cutter.set_ocr_power(laser_trap.cur_power); // Cycle efficiency isn't relevant when the last line was many cycles
               }
             #endif
           }
@@ -1966,16 +1966,16 @@ uint32_t Stepper::block_phase_isr() {
 
         // Update laser - Cruising
         #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
-          if (laser.trap_en) {
-            if (!laser.cruise_set) {
-              laser.cur_power = current_block->laser.power;
-              cutter.set_ocr_power(laser.cur_power);
-              laser.cruise_set = true;
+          if (laser_trap.enabled) {
+            if (!laser_trap.cruise_set) {
+              laser_trap.cur_power = current_block->laser.power;
+              cutter.set_ocr_power(laser_trap.cur_power);
+              laser_trap.cruise_set = true;
             }
             #if ENABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
-              laser.till_update = LASER_POWER_INLINE_TRAPEZOID_CONT_PER;
+              laser_trap.till_update = LASER_POWER_INLINE_TRAPEZOID_CONT_PER;
             #else
-              laser.last_step_count = step_events_completed;
+              laser_trap.last_step_count = step_events_completed;
             #endif
           }
         #endif
@@ -2000,7 +2000,10 @@ uint32_t Stepper::block_phase_isr() {
           return interval; // No more queued movements!
       }
 
-      TERN_(HAS_CUTTER, cutter.apply_power(current_block->cutter_power));
+      // For non-inline cutter, grossly apply power
+      #if ENABLED(LASER_FEATURE) && DISABLED(LASER_POWER_INLINE)
+        cutter.apply_power(current_block->cutter_power);
+      #endif
 
       TERN_(POWER_LOSS_RECOVERY, recovery.info.sdpos = current_block->sdpos);
 
@@ -2150,15 +2153,9 @@ uint32_t Stepper::block_phase_isr() {
         else LA_isr_rate = LA_ADV_NEVER;
       #endif
 
-      if (
-        #if HAS_L64XX
-          true  // Always set direction for L64xx (This also enables the chips)
-        #else
-          current_block->direction_bits != last_direction_bits
-          #if DISABLED(MIXING_EXTRUDER)
-            || stepper_extruder != last_moved_extruder
-          #endif
-        #endif
+      if ( ENABLED(HAS_L64XX)  // Always set direction for L64xx (Also enables the chips)
+        || current_block->direction_bits != last_direction_bits
+        || TERN(MIXING_EXTRUDER, false, stepper_extruder != last_moved_extruder)
       ) {
         last_direction_bits = current_block->direction_bits;
         #if EXTRUDERS > 1
@@ -2170,33 +2167,31 @@ uint32_t Stepper::block_phase_isr() {
       }
 
       #if ENABLED(LASER_POWER_INLINE)
-        const uint8_t stat = current_block->laser.status;
+        const power_status_t stat = current_block->laser.status;
         #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
-          laser.trap_en = (stat & 0x03) == 0x03;
-          laser.cur_power = current_block->laser.power_entry; // RESET STATE
-          laser.cruise_set = false;
+          laser_trap.enabled = stat.isPlanned && stat.isEnabled;
+          laser_trap.cur_power = current_block->laser.power_entry; // RESET STATE
+          laser_trap.cruise_set = false;
           #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
-            laser.last_step_count = 0;
-            laser.acc_step_count = current_block->laser.entry_per / 2;
+            laser_trap.last_step_count = 0;
+            laser_trap.acc_step_count = current_block->laser.entry_per / 2;
           #else
-            laser.till_update = 0;
+            laser_trap.till_update = 0;
           #endif
           // Always have PWM in this case
-          if (TEST(stat, 0)) {                        // Planner controls the laser
-            if (TEST(stat, 1))                        // Laser is on
-              cutter.set_ocr_power(laser.cur_power);
-            else
-              cutter.set_power(0);
+          if (stat.isPlanned) {                        // Planner controls the laser
+            cutter.set_ocr_power(
+              stat.isEnabled ? laser_trap.cur_power : 0 // ON with power or OFF
+            );
           }
         #else
-          if (TEST(stat, 0)) {                        // Planner controls the laser
+          if (stat.isPlanned) {                        // Planner controls the laser
             #if ENABLED(SPINDLE_LASER_PWM)
-              if (TEST(stat, 1))                      // Laser is on
-                cutter.set_ocr_power(current_block->laser.power);
-              else
-                cutter.set_power(0);
+              cutter.set_ocr_power(
+                stat.isEnabled ? current_block->laser.power : 0 // ON with power or OFF
+              );
             #else
-              cutter.set_enabled(TEST(stat, 1));
+              cutter.set_enabled(stat.isEnabled);
             #endif
           }
         #endif
@@ -2237,15 +2232,14 @@ uint32_t Stepper::block_phase_isr() {
     #if ENABLED(LASER_POWER_INLINE_CONTINUOUS)
       else { // No new block found; so apply inline laser parameters
         // This should mean ending file with 'M5 I' will stop the laser; thus the inline flag isn't needed
-        const uint8_t stat = planner.laser.status;
-        if (TEST(stat, 0)) {             // Planner controls the laser
+        const power_status_t stat = planner.laser_inline.status;
+        if (stat.isPlanned) {             // Planner controls the laser
           #if ENABLED(SPINDLE_LASER_PWM)
-            if (TEST(stat, 1))           // Laser is on
-              cutter.set_ocr_power(planner.laser.power);
-            else
-              cutter.set_power(0);
+            cutter.set_ocr_power(
+              stat.isEnabled ? planner.laser_inline.power : 0 // ON with power or OFF
+            );
           #else
-            cutter.set_enabled(TEST(stat, 1));
+            cutter.set_enabled(stat.isEnabled);
           #endif
         }
       }

commit cfd31ff70ee949eb5eea61bf30eac24aef9fcb9c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 5 23:18:23 2020 -0500

    Add HAS_FILAMENT_RUNOUT_DISTANCE

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 63fee87d00..3b1b787af7 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -118,7 +118,7 @@ Stepper stepper; // Singleton
   #include "../feature/mixing.h"
 #endif
 
-#ifdef FILAMENT_RUNOUT_DISTANCE_MM
+#if HAS_FILAMENT_RUNOUT_DISTANCE
   #include "../feature/runout.h"
 #endif
 
@@ -1808,9 +1808,7 @@ uint32_t Stepper::block_phase_isr() {
           PAGE_SEGMENT_UPDATE_POS(E);
         }
       #endif
-      #ifdef FILAMENT_RUNOUT_DISTANCE_MM
-        runout.block_completed(current_block);
-      #endif
+      TERN_(HAS_FILAMENT_RUNOUT_DISTANCE, runout.block_completed(current_block));
       discard_current_block();
     }
     else {

commit 219812e3bbd1dd90cff54faf64b822dc2b05bdd6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 12 02:11:16 2020 -0500

    Squish microstep_readings

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4a40e3f22d..63fee87d00 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -3420,95 +3420,76 @@ void Stepper::report_positions() {
   }
 
   void Stepper::microstep_readings() {
-    SERIAL_ECHOLNPGM("MS1|MS2|MS3 Pins");
+    #define PIN_CHAR(P) SERIAL_CHAR('0' + READ(P##_PIN))
+    #define MS_LINE(A)  do{ SERIAL_ECHOPGM(" " STRINGIFY(A) ":"); PIN_CHAR(A##_MS1); PIN_CHAR(A##_MS2); }while(0)
+    SERIAL_ECHOPGM("MS1|2|3 Pins");
     #if HAS_X_MS_PINS
-      SERIAL_ECHOPGM("X: ");
-      SERIAL_CHAR('0' + READ(X_MS1_PIN), '0' + READ(X_MS2_PIN)
-        #if PIN_EXISTS(X_MS3)
-          , '0' + READ(X_MS3_PIN)
-        #endif
-      );
+      MS_LINE(X);
+      #if PIN_EXISTS(X_MS3)
+        PIN_CHAR(X_MS3);
+      #endif
     #endif
     #if HAS_Y_MS_PINS
-      SERIAL_ECHOPGM("Y: ");
-      SERIAL_CHAR('0' + READ(Y_MS1_PIN), '0' + READ(Y_MS2_PIN)
-        #if PIN_EXISTS(Y_MS3)
-          , '0' + READ(Y_MS3_PIN)
-        #endif
-      );
+      MS_LINE(Y);
+      #if PIN_EXISTS(Y_MS3)
+        PIN_CHAR(Y_MS3);
+      #endif
     #endif
     #if HAS_Z_MS_PINS
-      SERIAL_ECHOPGM("Z: ");
-      SERIAL_CHAR('0' + READ(Z_MS1_PIN), '0' + READ(Z_MS2_PIN)
-        #if PIN_EXISTS(Z_MS3)
-          , '0' + READ(Z_MS3_PIN)
-        #endif
-      );
+      MS_LINE(Z);
+      #if PIN_EXISTS(Z_MS3)
+        PIN_CHAR(Z_MS3);
+      #endif
     #endif
     #if HAS_E0_MS_PINS
-      SERIAL_ECHOPGM("E0: ");
-      SERIAL_CHAR('0' + READ(E0_MS1_PIN), '0' + READ(E0_MS2_PIN)
-        #if PIN_EXISTS(E0_MS3)
-          , '0' + READ(E0_MS3_PIN)
-        #endif
-      );
+      MS_LINE(E0);
+      #if PIN_EXISTS(E0_MS3)
+        PIN_CHAR(E0_MS3);
+      #endif
     #endif
     #if HAS_E1_MS_PINS
-      SERIAL_ECHOPGM("E1: ");
-      SERIAL_CHAR('0' + READ(E1_MS1_PIN), '0' + READ(E1_MS2_PIN)
-        #if PIN_EXISTS(E1_MS3)
-          , '0' + READ(E1_MS3_PIN)
-        #endif
-      );
+      MS_LINE(E1);
+      #if PIN_EXISTS(E1_MS3)
+        PIN_CHAR(E1_MS3);
+      #endif
     #endif
     #if HAS_E2_MS_PINS
-      SERIAL_ECHOPGM("E2: ");
-      SERIAL_CHAR('0' + READ(E2_MS1_PIN), '0' + READ(E2_MS2_PIN)
-        #if PIN_EXISTS(E2_MS3)
-          , '0' + READ(E2_MS3_PIN)
-        #endif
-      );
+      MS_LINE(E2);
+      #if PIN_EXISTS(E2_MS3)
+        PIN_CHAR(E2_MS3);
+      #endif
     #endif
     #if HAS_E3_MS_PINS
-      SERIAL_ECHOPGM("E3: ");
-      SERIAL_CHAR('0' + READ(E3_MS1_PIN), '0' + READ(E3_MS2_PIN)
-        #if PIN_EXISTS(E3_MS3)
-          , '0' + READ(E3_MS3_PIN)
-        #endif
-      );
+      MS_LINE(E3);
+      #if PIN_EXISTS(E3_MS3)
+        PIN_CHAR(E3_MS3);
+      #endif
     #endif
     #if HAS_E4_MS_PINS
-      SERIAL_ECHOPGM("E4: ");
-      SERIAL_CHAR('0' + READ(E4_MS1_PIN), '0' + READ(E4_MS2_PIN)
-        #if PIN_EXISTS(E4_MS3)
-          , '0' + READ(E4_MS3_PIN)
-        #endif
-      );
+      MS_LINE(E4);
+      #if PIN_EXISTS(E4_MS3)
+        PIN_CHAR(E4_MS3);
+      #endif
     #endif
     #if HAS_E5_MS_PINS
-      SERIAL_ECHOPGM("E5: ");
-      SERIAL_CHAR('0' + READ(E5_MS1_PIN), '0' + READ(E5_MS2_PIN)
-        #if PIN_EXISTS(E5_MS3)
-          , '0' + READ(E5_MS3_PIN)
-        #endif
-      );
+      MS_LINE(E5);
+      #if PIN_EXISTS(E5_MS3)
+        PIN_CHAR(E5_MS3);
+      #endif
     #endif
     #if HAS_E6_MS_PINS
-      SERIAL_ECHOPGM("E6: ");
-      SERIAL_CHAR('0' + READ(E6_MS1_PIN), '0' + READ(E6_MS2_PIN)
-        #if PIN_EXISTS(E6_MS3)
-          , '0' + READ(E6_MS3_PIN)
-        #endif
-      );
+      MS_LINE(E6);
+      #if PIN_EXISTS(E6_MS3)
+        PIN_CHAR(E6_MS3);
+      #endif
     #endif
     #if HAS_E7_MS_PINS
-      SERIAL_ECHOPGM("E7: ");
-      SERIAL_CHAR('0' + READ(E7_MS1_PIN), '0' + READ(E7_MS2_PIN)
-        #if PIN_EXISTS(E7_MS3)
-          , '0' + READ(E7_MS3_PIN)
-        #endif
-      );
+      MS_LINE(E7);
+      #if PIN_EXISTS(E7_MS3)
+        PIN_CHAR(E7_MS3);
+      #endif
     #endif
+    SERIAL_EOL();
   }
 
 #endif // HAS_MICROSTEPS

commit 181739d0d1a54ab01c4f97678f04ae43ebb1facd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 12 00:09:18 2020 -0500

    Move inline laser state to fix EEPROM error

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 68e75e36e3..4a40e3f22d 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2239,11 +2239,11 @@ uint32_t Stepper::block_phase_isr() {
     #if ENABLED(LASER_POWER_INLINE_CONTINUOUS)
       else { // No new block found; so apply inline laser parameters
         // This should mean ending file with 'M5 I' will stop the laser; thus the inline flag isn't needed
-        const uint8_t stat = planner.settings.laser.status;
+        const uint8_t stat = planner.laser.status;
         if (TEST(stat, 0)) {             // Planner controls the laser
           #if ENABLED(SPINDLE_LASER_PWM)
             if (TEST(stat, 1))           // Laser is on
-              cutter.set_ocr_power(planner.settings.laser.power);
+              cutter.set_ocr_power(planner.laser.power);
             else
               cutter.set_power(0);
           #else

commit 8a22ef0c83a94f742be39005f259226e005ded2d
Author: Colin Godsey <crgodsey@gmail.com>
Date:   Mon May 11 18:22:41 2020 -0600

    G6 Direct Stepping (#17853)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 92ee753392..68e75e36e3 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -230,6 +230,10 @@ uint32_t Stepper::advance_divisor = 0,
   uint32_t Stepper::nextBabystepISR = BABYSTEP_NEVER;
 #endif
 
+#if ENABLED(DIRECT_STEPPING)
+  page_step_state_t Stepper::page_step_state;
+#endif
+
 int32_t Stepper::ticks_nominal = -1;
 #if DISABLED(S_CURVE_ACCELERATION)
   uint32_t Stepper::acc_step_rate; // needed for deceleration start point
@@ -1520,11 +1524,7 @@ void Stepper::pulse_phase_isr() {
   // If we must abort the current block, do so!
   if (abort_current_block) {
     abort_current_block = false;
-    if (current_block) {
-      axis_did_move = 0;
-      current_block = nullptr;
-      planner.discard_current_block();
-    }
+    if (current_block) discard_current_block();
   }
 
   // If there is no current block, do nothing
@@ -1558,46 +1558,160 @@ void Stepper::pulse_phase_isr() {
       } \
     }while(0)
 
-    // Start an active pulse, if Bresenham says so, and update position
+    // Start an active pulse if needed
     #define PULSE_START(AXIS) do{ \
       if (step_needed[_AXIS(AXIS)]) { \
         _APPLY_STEP(AXIS, !_INVERT_STEP_PIN(AXIS), 0); \
       } \
     }while(0)
 
-    // Stop an active pulse, if any, and adjust error term
+    // Stop an active pulse if needed
     #define PULSE_STOP(AXIS) do { \
       if (step_needed[_AXIS(AXIS)]) { \
         _APPLY_STEP(AXIS, _INVERT_STEP_PIN(AXIS), 0); \
       } \
     }while(0)
 
-    // Determine if pulses are needed
-    #if HAS_X_STEP
-      PULSE_PREP(X);
-    #endif
-    #if HAS_Y_STEP
-      PULSE_PREP(Y);
-    #endif
-    #if HAS_Z_STEP
-      PULSE_PREP(Z);
-    #endif
+    // Direct Stepping page?
+    const bool is_page = IS_PAGE(current_block);
+
+    #if ENABLED(DIRECT_STEPPING)
+
+      if (is_page) {
+
+        #if STEPPER_PAGE_FORMAT == SP_4x4D_128
+
+          #define PAGE_SEGMENT_UPDATE(AXIS, VALUE, MID) do{ \
+                 if ((VALUE) == MID) {}                     \
+            else if ((VALUE) <  MID) SBI(dm, _AXIS(AXIS));  \
+            else                     CBI(dm, _AXIS(AXIS));  \
+            page_step_state.sd[_AXIS(AXIS)] = VALUE;        \
+            page_step_state.bd[_AXIS(AXIS)] += VALUE;       \
+          }while(0)
+
+          #define PAGE_PULSE_PREP(AXIS) do{ \
+            step_needed[_AXIS(AXIS)] =      \
+              pgm_read_byte(&segment_table[page_step_state.sd[_AXIS(AXIS)]][page_step_state.segment_steps & 0x7]); \
+          }while(0)
+
+          switch (page_step_state.segment_steps) {
+            case 8:
+              page_step_state.segment_idx += 2;
+              page_step_state.segment_steps = 0;
+              // fallthru
+            case 0: {
+              const uint8_t low = page_step_state.page[page_step_state.segment_idx],
+                           high = page_step_state.page[page_step_state.segment_idx + 1];
+              uint8_t dm = last_direction_bits;
+
+              PAGE_SEGMENT_UPDATE(X, low >> 4, 7);
+              PAGE_SEGMENT_UPDATE(Y, low & 0xF, 7);
+              PAGE_SEGMENT_UPDATE(Z, high >> 4, 7);
+              PAGE_SEGMENT_UPDATE(E, high & 0xF, 7);
+
+              if (dm != last_direction_bits) {
+                last_direction_bits = dm;
+                set_directions();
+              }
+            } break;
+
+            default: break;
+          }
+
+          PAGE_PULSE_PREP(X),
+          PAGE_PULSE_PREP(Y),
+          PAGE_PULSE_PREP(Z),
+          PAGE_PULSE_PREP(E);
+
+          page_step_state.segment_steps++;
+
+        #elif STEPPER_PAGE_FORMAT == SP_4x2_256
+
+          #define PAGE_SEGMENT_UPDATE(AXIS, VALUE) \
+            page_step_state.sd[_AXIS(AXIS)] = VALUE; \
+            page_step_state.bd[_AXIS(AXIS)] += VALUE;
+
+          #define PAGE_PULSE_PREP(AXIS) do{ \
+            step_needed[_AXIS(AXIS)] =      \
+              pgm_read_byte(&segment_table[page_step_state.sd[_AXIS(AXIS)]][page_step_state.segment_steps & 0x3]); \
+          }while(0)
+
+          switch (page_step_state.segment_steps) {
+            case 4:
+              page_step_state.segment_idx++;
+              page_step_state.segment_steps = 0;
+              // fallthru
+            case 0: {
+              const uint8_t b = page_step_state.page[page_step_state.segment_idx];
+              PAGE_SEGMENT_UPDATE(X, (b >> 6) & 0x3);
+              PAGE_SEGMENT_UPDATE(Y, (b >> 4) & 0x3);
+              PAGE_SEGMENT_UPDATE(Z, (b >> 2) & 0x3);
+              PAGE_SEGMENT_UPDATE(E, (b >> 0) & 0x3);
+            } break;
+            default: break;
+          }
+
+          PAGE_PULSE_PREP(X);
+          PAGE_PULSE_PREP(Y);
+          PAGE_PULSE_PREP(Z);
+          PAGE_PULSE_PREP(E);
+
+          page_step_state.segment_steps++;
+
+        #elif STEPPER_PAGE_FORMAT == SP_4x1_512
+
+          #define PAGE_PULSE_PREP(AXIS, BITS) do{             \
+            step_needed[_AXIS(AXIS)] = (steps >> BITS) & 0x1; \
+            if (step_needed[_AXIS(AXIS)])                     \
+              page_step_state.bd[_AXIS(AXIS)]++;              \
+          }while(0)
+
+          uint8_t steps = page_step_state.page[page_step_state.segment_idx >> 1];
+
+          if (page_step_state.segment_idx & 0x1) steps >>= 4;
+
+          PAGE_PULSE_PREP(X, 3);
+          PAGE_PULSE_PREP(Y, 2);
+          PAGE_PULSE_PREP(Z, 1);
+          PAGE_PULSE_PREP(E, 0);
+
+          page_step_state.segment_idx++;
 
-    #if EITHER(LIN_ADVANCE, MIXING_EXTRUDER)
-      delta_error.e += advance_dividend.e;
-      if (delta_error.e >= 0) {
-        count_position.e += count_direction.e;
-        #if ENABLED(LIN_ADVANCE)
-          delta_error.e -= advance_divisor;
-          // Don't step E here - But remember the number of steps to perform
-          motor_direction(E_AXIS) ? --LA_steps : ++LA_steps;
         #else
-          step_needed.e = true;
+          #error "Unknown direct stepping page format!"
         #endif
       }
-    #elif HAS_E0_STEP
-      PULSE_PREP(E);
-    #endif
+
+    #endif // DIRECT_STEPPING
+
+    if (!is_page) {
+      // Determine if pulses are needed
+      #if HAS_X_STEP
+        PULSE_PREP(X);
+      #endif
+      #if HAS_Y_STEP
+        PULSE_PREP(Y);
+      #endif
+      #if HAS_Z_STEP
+        PULSE_PREP(Z);
+      #endif
+
+      #if EITHER(LIN_ADVANCE, MIXING_EXTRUDER)
+        delta_error.e += advance_dividend.e;
+        if (delta_error.e >= 0) {
+          count_position.e += count_direction.e;
+          #if ENABLED(LIN_ADVANCE)
+            delta_error.e -= advance_divisor;
+            // Don't step E here - But remember the number of steps to perform
+            motor_direction(E_AXIS) ? --LA_steps : ++LA_steps;
+          #else
+            step_needed.e = true;
+          #endif
+        }
+      #elif HAS_E0_STEP
+        PULSE_PREP(E);
+      #endif
+    }
 
     #if ISR_MULTI_STEPS
       if (firstStep)
@@ -1676,14 +1790,28 @@ uint32_t Stepper::block_phase_isr() {
   // If there is a current block
   if (current_block) {
 
-    // If current block is finished, reset pointer
+    // If current block is finished, reset pointer and finalize state
     if (step_events_completed >= step_event_count) {
+      #if ENABLED(DIRECT_STEPPING)
+        #if STEPPER_PAGE_FORMAT == SP_4x4D_128
+          #define PAGE_SEGMENT_UPDATE_POS(AXIS) \
+            count_position[_AXIS(AXIS)] += page_step_state.bd[_AXIS(AXIS)] - 128 * 7;
+        #elif STEPPER_PAGE_FORMAT == SP_4x1_512 || STEPPER_PAGE_FORMAT == SP_4x2_256
+          #define PAGE_SEGMENT_UPDATE_POS(AXIS) \
+            count_position[_AXIS(AXIS)] += page_step_state.bd[_AXIS(AXIS)] * count_direction[_AXIS(AXIS)];
+        #endif
+
+        if (IS_PAGE(current_block)) {
+          PAGE_SEGMENT_UPDATE_POS(X);
+          PAGE_SEGMENT_UPDATE_POS(Y);
+          PAGE_SEGMENT_UPDATE_POS(Z);
+          PAGE_SEGMENT_UPDATE_POS(E);
+        }
+      #endif
       #ifdef FILAMENT_RUNOUT_DISTANCE_MM
         runout.block_completed(current_block);
       #endif
-      axis_did_move = 0;
-      current_block = nullptr;
-      planner.discard_current_block();
+      discard_current_block();
     }
     else {
       // Step events not completed yet...
@@ -1867,7 +1995,7 @@ uint32_t Stepper::block_phase_isr() {
       // Sync block? Sync the stepper counts and return
       while (TEST(current_block->flag, BLOCK_BIT_SYNC_POSITION)) {
         _set_position(current_block->position);
-        planner.discard_current_block();
+        discard_current_block();
 
         // Try to get a new block
         if (!(current_block = planner.get_current_block()))
@@ -1878,6 +2006,23 @@ uint32_t Stepper::block_phase_isr() {
 
       TERN_(POWER_LOSS_RECOVERY, recovery.info.sdpos = current_block->sdpos);
 
+      #if ENABLED(DIRECT_STEPPING)
+        if (IS_PAGE(current_block)) {
+          page_step_state.segment_steps = 0;
+          page_step_state.segment_idx = 0;
+          page_step_state.page = page_manager.get_page(current_block->page_idx);
+          page_step_state.bd.reset();
+
+          if (DirectStepping::Config::DIRECTIONAL)
+            current_block->direction_bits = last_direction_bits;
+
+          if (!page_step_state.page) {
+            discard_current_block();
+            return interval;
+          }
+        }
+      #endif
+
       // Flag all moving axes for proper endstop handling
 
       #if IS_CORE

commit 4b35ff1f070619ff455830ffb9b08cb1741a20a2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 28 07:48:32 2020 -0500

    STEPPER_TIMER_RATE might call a function

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c105570067..92ee753392 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -416,10 +416,10 @@ xyze_int8_t Stepper::count_direction{0};
 #endif
 
 #define CYCLES_TO_NS(CYC) (1000UL * (CYC) / ((F_CPU) / 1000000))
-constexpr uint32_t NS_PER_PULSE_TIMER_TICK = 1000000000UL / (STEPPER_TIMER_RATE);
+#define NS_PER_PULSE_TIMER_TICK (1000000000UL / (STEPPER_TIMER_RATE))
 
 // Round up when converting from ns to timer ticks
-constexpr uint32_t NS_TO_PULSE_TIMER_TICKS(uint32_t NS) { return (NS + (NS_PER_PULSE_TIMER_TICK) / 2) / (NS_PER_PULSE_TIMER_TICK); }
+#define NS_TO_PULSE_TIMER_TICKS(NS) (((NS) + (NS_PER_PULSE_TIMER_TICK) / 2) / (NS_PER_PULSE_TIMER_TICK))
 
 #define TIMER_SETUP_NS (CYCLES_TO_NS(TIMER_READ_ADD_AND_STORE_CYCLES))
 

commit ab2b98e4255b0b9579af9627e884ac3dfc1d30bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 21:42:38 2020 -0500

    Apply composite tests

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 0119c07bea..c105570067 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -138,7 +138,7 @@ Stepper stepper; // Singleton
 
 // public:
 
-#if HAS_EXTRA_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
+#if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
   bool Stepper::separate_multi_axis = false;
 #endif
 
@@ -2265,7 +2265,7 @@ void Stepper::init() {
   TERN_(HAS_X2_DIR, X2_DIR_INIT());
   #if HAS_Y_DIR
     Y_DIR_INIT();
-    #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_DIR
+    #if BOTH(Y_DUAL_STEPPER_DRIVERS, HAS_Y2_DIR)
       Y2_DIR_INIT();
     #endif
   #endif
@@ -2318,7 +2318,7 @@ void Stepper::init() {
   #if HAS_Y_ENABLE
     Y_ENABLE_INIT();
     if (!Y_ENABLE_ON) Y_ENABLE_WRITE(HIGH);
-    #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_ENABLE
+    #if BOTH(Y_DUAL_STEPPER_DRIVERS, HAS_Y2_ENABLE)
       Y2_ENABLE_INIT();
       if (!Y_ENABLE_ON) Y2_ENABLE_WRITE(HIGH);
     #endif

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 94da5f0076..0119c07bea 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -470,11 +470,9 @@ void Stepper::set_directions() {
   #if HAS_X_DIR
     SET_STEP_DIR(X); // A
   #endif
-
   #if HAS_Y_DIR
     SET_STEP_DIR(Y); // B
   #endif
-
   #if HAS_Z_DIR
     SET_STEP_DIR(Z); // C
   #endif
@@ -1503,8 +1501,12 @@ void Stepper::isr() {
   ENABLE_ISRS();
 }
 
-#define ISR_PULSE_CONTROL (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE)
-#define ISR_MULTI_STEPS (ISR_PULSE_CONTROL && DISABLED(I2S_STEPPER_STREAM))
+#if MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE
+  #define ISR_PULSE_CONTROL 1
+#endif
+#if ISR_PULSE_CONTROL && DISABLED(I2S_STEPPER_STREAM)
+  #define ISR_MULTI_STEPS 1
+#endif
 
 /**
  * This phase of the ISR should ONLY create the pulses for the steppers.
@@ -1872,13 +1874,9 @@ uint32_t Stepper::block_phase_isr() {
           return interval; // No more queued movements!
       }
 
-      #if HAS_CUTTER
-        cutter.apply_power(current_block->cutter_power);
-      #endif
+      TERN_(HAS_CUTTER, cutter.apply_power(current_block->cutter_power));
 
-      #if ENABLED(POWER_LOSS_RECOVERY)
-        recovery.info.sdpos = current_block->sdpos;
-      #endif
+      TERN_(POWER_LOSS_RECOVERY, recovery.info.sdpos = current_block->sdpos);
 
       // Flag all moving axes for proper endstop handling
 
@@ -2024,9 +2022,7 @@ uint32_t Stepper::block_phase_isr() {
           last_moved_extruder = stepper_extruder;
         #endif
 
-        #if HAS_L64XX
-          L64XX_OK_to_power_up = true;
-        #endif
+        TERN_(HAS_L64XX, L64XX_OK_to_power_up = true);
         set_directions();
       }
 
@@ -2262,17 +2258,11 @@ void Stepper::init() {
   #endif
 
   // Init Microstepping Pins
-  #if HAS_MICROSTEPS
-    microstep_init();
-  #endif
+  TERN_(HAS_MICROSTEPS, microstep_init());
 
   // Init Dir Pins
-  #if HAS_X_DIR
-    X_DIR_INIT();
-  #endif
-  #if HAS_X2_DIR
-    X2_DIR_INIT();
-  #endif
+  TERN_(HAS_X_DIR, X_DIR_INIT());
+  TERN_(HAS_X2_DIR, X2_DIR_INIT());
   #if HAS_Y_DIR
     Y_DIR_INIT();
     #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_DIR
@@ -2466,9 +2456,7 @@ void Stepper::init() {
   set_directions();
 
   #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
-    #if HAS_MOTOR_CURRENT_PWM
-      initialized = true;
-    #endif
+    TERN_(HAS_MOTOR_CURRENT_PWM, initialized = true);
     digipot_init();
   #endif
 }
@@ -2948,112 +2936,112 @@ void Stepper::report_positions() {
    */
 
   void Stepper::microstep_init() {
-    #if HAS_X_MICROSTEPS
+    #if HAS_X_MS_PINS
       SET_OUTPUT(X_MS1_PIN);
       SET_OUTPUT(X_MS2_PIN);
       #if PIN_EXISTS(X_MS3)
         SET_OUTPUT(X_MS3_PIN);
       #endif
     #endif
-    #if HAS_X2_MICROSTEPS
+    #if HAS_X2_MS_PINS
       SET_OUTPUT(X2_MS1_PIN);
       SET_OUTPUT(X2_MS2_PIN);
       #if PIN_EXISTS(X2_MS3)
         SET_OUTPUT(X2_MS3_PIN);
       #endif
     #endif
-    #if HAS_Y_MICROSTEPS
+    #if HAS_Y_MS_PINS
       SET_OUTPUT(Y_MS1_PIN);
       SET_OUTPUT(Y_MS2_PIN);
       #if PIN_EXISTS(Y_MS3)
         SET_OUTPUT(Y_MS3_PIN);
       #endif
     #endif
-    #if HAS_Y2_MICROSTEPS
+    #if HAS_Y2_MS_PINS
       SET_OUTPUT(Y2_MS1_PIN);
       SET_OUTPUT(Y2_MS2_PIN);
       #if PIN_EXISTS(Y2_MS3)
         SET_OUTPUT(Y2_MS3_PIN);
       #endif
     #endif
-    #if HAS_Z_MICROSTEPS
+    #if HAS_Z_MS_PINS
       SET_OUTPUT(Z_MS1_PIN);
       SET_OUTPUT(Z_MS2_PIN);
       #if PIN_EXISTS(Z_MS3)
         SET_OUTPUT(Z_MS3_PIN);
       #endif
     #endif
-    #if HAS_Z2_MICROSTEPS
+    #if HAS_Z2_MS_PINS
       SET_OUTPUT(Z2_MS1_PIN);
       SET_OUTPUT(Z2_MS2_PIN);
       #if PIN_EXISTS(Z2_MS3)
         SET_OUTPUT(Z2_MS3_PIN);
       #endif
     #endif
-    #if HAS_Z3_MICROSTEPS
+    #if HAS_Z3_MS_PINS
       SET_OUTPUT(Z3_MS1_PIN);
       SET_OUTPUT(Z3_MS2_PIN);
       #if PIN_EXISTS(Z3_MS3)
         SET_OUTPUT(Z3_MS3_PIN);
       #endif
     #endif
-    #if HAS_Z4_MICROSTEPS
+    #if HAS_Z4_MS_PINS
       SET_OUTPUT(Z4_MS1_PIN);
       SET_OUTPUT(Z4_MS2_PIN);
       #if PIN_EXISTS(Z4_MS3)
         SET_OUTPUT(Z4_MS3_PIN);
       #endif
     #endif
-    #if HAS_E0_MICROSTEPS
+    #if HAS_E0_MS_PINS
       SET_OUTPUT(E0_MS1_PIN);
       SET_OUTPUT(E0_MS2_PIN);
       #if PIN_EXISTS(E0_MS3)
         SET_OUTPUT(E0_MS3_PIN);
       #endif
     #endif
-    #if HAS_E1_MICROSTEPS
+    #if HAS_E1_MS_PINS
       SET_OUTPUT(E1_MS1_PIN);
       SET_OUTPUT(E1_MS2_PIN);
       #if PIN_EXISTS(E1_MS3)
         SET_OUTPUT(E1_MS3_PIN);
       #endif
     #endif
-    #if HAS_E2_MICROSTEPS
+    #if HAS_E2_MS_PINS
       SET_OUTPUT(E2_MS1_PIN);
       SET_OUTPUT(E2_MS2_PIN);
       #if PIN_EXISTS(E2_MS3)
         SET_OUTPUT(E2_MS3_PIN);
       #endif
     #endif
-    #if HAS_E3_MICROSTEPS
+    #if HAS_E3_MS_PINS
       SET_OUTPUT(E3_MS1_PIN);
       SET_OUTPUT(E3_MS2_PIN);
       #if PIN_EXISTS(E3_MS3)
         SET_OUTPUT(E3_MS3_PIN);
       #endif
     #endif
-    #if HAS_E4_MICROSTEPS
+    #if HAS_E4_MS_PINS
       SET_OUTPUT(E4_MS1_PIN);
       SET_OUTPUT(E4_MS2_PIN);
       #if PIN_EXISTS(E4_MS3)
         SET_OUTPUT(E4_MS3_PIN);
       #endif
     #endif
-    #if HAS_E5_MICROSTEPS
+    #if HAS_E5_MS_PINS
       SET_OUTPUT(E5_MS1_PIN);
       SET_OUTPUT(E5_MS2_PIN);
       #if PIN_EXISTS(E5_MS3)
         SET_OUTPUT(E5_MS3_PIN);
       #endif
     #endif
-    #if HAS_E6_MICROSTEPS
+    #if HAS_E6_MS_PINS
       SET_OUTPUT(E6_MS1_PIN);
       SET_OUTPUT(E6_MS2_PIN);
       #if PIN_EXISTS(E6_MS3)
         SET_OUTPUT(E6_MS3_PIN);
       #endif
     #endif
-    #if HAS_E7_MICROSTEPS
+    #if HAS_E7_MS_PINS
       SET_OUTPUT(E7_MS1_PIN);
       SET_OUTPUT(E7_MS2_PIN);
       #if PIN_EXISTS(E7_MS3)
@@ -3068,188 +3056,188 @@ void Stepper::report_positions() {
 
   void Stepper::microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2, const int8_t ms3) {
     if (ms1 >= 0) switch (driver) {
-      #if HAS_X_MICROSTEPS || HAS_X2_MICROSTEPS
+      #if HAS_X_MS_PINS || HAS_X2_MS_PINS
         case 0:
-          #if HAS_X_MICROSTEPS
+          #if HAS_X_MS_PINS
             WRITE(X_MS1_PIN, ms1);
           #endif
-          #if HAS_X2_MICROSTEPS
+          #if HAS_X2_MS_PINS
             WRITE(X2_MS1_PIN, ms1);
           #endif
           break;
       #endif
-      #if HAS_Y_MICROSTEPS || HAS_Y2_MICROSTEPS
+      #if HAS_Y_MS_PINS || HAS_Y2_MS_PINS
         case 1:
-          #if HAS_Y_MICROSTEPS
+          #if HAS_Y_MS_PINS
             WRITE(Y_MS1_PIN, ms1);
           #endif
-          #if HAS_Y2_MICROSTEPS
+          #if HAS_Y2_MS_PINS
             WRITE(Y2_MS1_PIN, ms1);
           #endif
           break;
       #endif
-      #if HAS_SOME_Z_MICROSTEPS
+      #if HAS_SOME_Z_MS_PINS
         case 2:
-          #if HAS_Z_MICROSTEPS
+          #if HAS_Z_MS_PINS
             WRITE(Z_MS1_PIN, ms1);
           #endif
-          #if HAS_Z2_MICROSTEPS
+          #if HAS_Z2_MS_PINS
             WRITE(Z2_MS1_PIN, ms1);
           #endif
-          #if HAS_Z3_MICROSTEPS
+          #if HAS_Z3_MS_PINS
             WRITE(Z3_MS1_PIN, ms1);
           #endif
-          #if HAS_Z4_MICROSTEPS
+          #if HAS_Z4_MS_PINS
             WRITE(Z4_MS1_PIN, ms1);
           #endif
           break;
       #endif
-      #if HAS_E0_MICROSTEPS
+      #if HAS_E0_MS_PINS
         case  3: WRITE(E0_MS1_PIN, ms1); break;
       #endif
-      #if HAS_E1_MICROSTEPS
+      #if HAS_E1_MS_PINS
         case  4: WRITE(E1_MS1_PIN, ms1); break;
       #endif
-      #if HAS_E2_MICROSTEPS
+      #if HAS_E2_MS_PINS
         case  5: WRITE(E2_MS1_PIN, ms1); break;
       #endif
-      #if HAS_E3_MICROSTEPS
+      #if HAS_E3_MS_PINS
         case  6: WRITE(E3_MS1_PIN, ms1); break;
       #endif
-      #if HAS_E4_MICROSTEPS
+      #if HAS_E4_MS_PINS
         case  7: WRITE(E4_MS1_PIN, ms1); break;
       #endif
-      #if HAS_E5_MICROSTEPS
+      #if HAS_E5_MS_PINS
         case  8: WRITE(E5_MS1_PIN, ms1); break;
       #endif
-      #if HAS_E6_MICROSTEPS
+      #if HAS_E6_MS_PINS
         case  9: WRITE(E6_MS1_PIN, ms1); break;
       #endif
-      #if HAS_E7_MICROSTEPS
+      #if HAS_E7_MS_PINS
         case 10: WRITE(E7_MS1_PIN, ms1); break;
       #endif
     }
     if (ms2 >= 0) switch (driver) {
-      #if HAS_X_MICROSTEPS || HAS_X2_MICROSTEPS
+      #if HAS_X_MS_PINS || HAS_X2_MS_PINS
         case 0:
-          #if HAS_X_MICROSTEPS
+          #if HAS_X_MS_PINS
             WRITE(X_MS2_PIN, ms2);
           #endif
-          #if HAS_X2_MICROSTEPS
+          #if HAS_X2_MS_PINS
             WRITE(X2_MS2_PIN, ms2);
           #endif
           break;
       #endif
-      #if HAS_Y_MICROSTEPS || HAS_Y2_MICROSTEPS
+      #if HAS_Y_MS_PINS || HAS_Y2_MS_PINS
         case 1:
-          #if HAS_Y_MICROSTEPS
+          #if HAS_Y_MS_PINS
             WRITE(Y_MS2_PIN, ms2);
           #endif
-          #if HAS_Y2_MICROSTEPS
+          #if HAS_Y2_MS_PINS
             WRITE(Y2_MS2_PIN, ms2);
           #endif
           break;
       #endif
-      #if HAS_SOME_Z_MICROSTEPS
+      #if HAS_SOME_Z_MS_PINS
         case 2:
-          #if HAS_Z_MICROSTEPS
+          #if HAS_Z_MS_PINS
             WRITE(Z_MS2_PIN, ms2);
           #endif
-          #if HAS_Z2_MICROSTEPS
+          #if HAS_Z2_MS_PINS
             WRITE(Z2_MS2_PIN, ms2);
           #endif
-          #if HAS_Z3_MICROSTEPS
+          #if HAS_Z3_MS_PINS
             WRITE(Z3_MS2_PIN, ms2);
           #endif
-          #if HAS_Z4_MICROSTEPS
+          #if HAS_Z4_MS_PINS
             WRITE(Z4_MS2_PIN, ms2);
           #endif
           break;
       #endif
-      #if HAS_E0_MICROSTEPS
+      #if HAS_E0_MS_PINS
         case  3: WRITE(E0_MS2_PIN, ms2); break;
       #endif
-      #if HAS_E1_MICROSTEPS
+      #if HAS_E1_MS_PINS
         case  4: WRITE(E1_MS2_PIN, ms2); break;
       #endif
-      #if HAS_E2_MICROSTEPS
+      #if HAS_E2_MS_PINS
         case  5: WRITE(E2_MS2_PIN, ms2); break;
       #endif
-      #if HAS_E3_MICROSTEPS
+      #if HAS_E3_MS_PINS
         case  6: WRITE(E3_MS2_PIN, ms2); break;
       #endif
-      #if HAS_E4_MICROSTEPS
+      #if HAS_E4_MS_PINS
         case  7: WRITE(E4_MS2_PIN, ms2); break;
       #endif
-      #if HAS_E5_MICROSTEPS
+      #if HAS_E5_MS_PINS
         case  8: WRITE(E5_MS2_PIN, ms2); break;
       #endif
-      #if HAS_E6_MICROSTEPS
+      #if HAS_E6_MS_PINS
         case  9: WRITE(E6_MS2_PIN, ms2); break;
       #endif
-      #if HAS_E7_MICROSTEPS
+      #if HAS_E7_MS_PINS
         case 10: WRITE(E7_MS2_PIN, ms2); break;
       #endif
     }
     if (ms3 >= 0) switch (driver) {
-      #if HAS_X_MICROSTEPS || HAS_X2_MICROSTEPS
+      #if HAS_X_MS_PINS || HAS_X2_MS_PINS
         case 0:
-          #if HAS_X_MICROSTEPS && PIN_EXISTS(X_MS3)
+          #if HAS_X_MS_PINS && PIN_EXISTS(X_MS3)
             WRITE(X_MS3_PIN, ms3);
           #endif
-          #if HAS_X2_MICROSTEPS && PIN_EXISTS(X2_MS3)
+          #if HAS_X2_MS_PINS && PIN_EXISTS(X2_MS3)
             WRITE(X2_MS3_PIN, ms3);
           #endif
           break;
       #endif
-      #if HAS_Y_MICROSTEPS || HAS_Y2_MICROSTEPS
+      #if HAS_Y_MS_PINS || HAS_Y2_MS_PINS
         case 1:
-          #if HAS_Y_MICROSTEPS && PIN_EXISTS(Y_MS3)
+          #if HAS_Y_MS_PINS && PIN_EXISTS(Y_MS3)
             WRITE(Y_MS3_PIN, ms3);
           #endif
-          #if HAS_Y2_MICROSTEPS && PIN_EXISTS(Y2_MS3)
+          #if HAS_Y2_MS_PINS && PIN_EXISTS(Y2_MS3)
             WRITE(Y2_MS3_PIN, ms3);
           #endif
           break;
       #endif
-      #if HAS_SOME_Z_MICROSTEPS
+      #if HAS_SOME_Z_MS_PINS
         case 2:
-          #if HAS_Z_MICROSTEPS && PIN_EXISTS(Z_MS3)
+          #if HAS_Z_MS_PINS && PIN_EXISTS(Z_MS3)
             WRITE(Z_MS3_PIN, ms3);
           #endif
-          #if HAS_Z2_MICROSTEPS && PIN_EXISTS(Z2_MS3)
+          #if HAS_Z2_MS_PINS && PIN_EXISTS(Z2_MS3)
             WRITE(Z2_MS3_PIN, ms3);
           #endif
-          #if HAS_Z3_MICROSTEPS && PIN_EXISTS(Z3_MS3)
+          #if HAS_Z3_MS_PINS && PIN_EXISTS(Z3_MS3)
             WRITE(Z3_MS3_PIN, ms3);
           #endif
-          #if HAS_Z4_MICROSTEPS && PIN_EXISTS(Z4_MS3)
+          #if HAS_Z4_MS_PINS && PIN_EXISTS(Z4_MS3)
             WRITE(Z4_MS3_PIN, ms3);
           #endif
           break;
       #endif
-      #if HAS_E0_MICROSTEPS && PIN_EXISTS(E0_MS3)
+      #if HAS_E0_MS_PINS && PIN_EXISTS(E0_MS3)
         case  3: WRITE(E0_MS3_PIN, ms3); break;
       #endif
-      #if HAS_E1_MICROSTEPS && PIN_EXISTS(E1_MS3)
+      #if HAS_E1_MS_PINS && PIN_EXISTS(E1_MS3)
         case  4: WRITE(E1_MS3_PIN, ms3); break;
       #endif
-      #if HAS_E2_MICROSTEPS && PIN_EXISTS(E2_MS3)
+      #if HAS_E2_MS_PINS && PIN_EXISTS(E2_MS3)
         case  5: WRITE(E2_MS3_PIN, ms3); break;
       #endif
-      #if HAS_E3_MICROSTEPS && PIN_EXISTS(E3_MS3)
+      #if HAS_E3_MS_PINS && PIN_EXISTS(E3_MS3)
         case  6: WRITE(E3_MS3_PIN, ms3); break;
       #endif
-      #if HAS_E4_MICROSTEPS && PIN_EXISTS(E4_MS3)
+      #if HAS_E4_MS_PINS && PIN_EXISTS(E4_MS3)
         case  7: WRITE(E4_MS3_PIN, ms3); break;
       #endif
-      #if HAS_E5_MICROSTEPS && PIN_EXISTS(E5_MS3)
+      #if HAS_E5_MS_PINS && PIN_EXISTS(E5_MS3)
         case  8: WRITE(E5_MS3_PIN, ms3); break;
       #endif
-      #if HAS_E6_MICROSTEPS && PIN_EXISTS(E6_MS3)
+      #if HAS_E6_MS_PINS && PIN_EXISTS(E6_MS3)
         case  9: WRITE(E6_MS3_PIN, ms3); break;
       #endif
-      #if HAS_E7_MICROSTEPS && PIN_EXISTS(E7_MS3)
+      #if HAS_E7_MS_PINS && PIN_EXISTS(E7_MS3)
         case 10: WRITE(E7_MS3_PIN, ms3); break;
       #endif
     }
@@ -3288,7 +3276,7 @@ void Stepper::report_positions() {
 
   void Stepper::microstep_readings() {
     SERIAL_ECHOLNPGM("MS1|MS2|MS3 Pins");
-    #if HAS_X_MICROSTEPS
+    #if HAS_X_MS_PINS
       SERIAL_ECHOPGM("X: ");
       SERIAL_CHAR('0' + READ(X_MS1_PIN), '0' + READ(X_MS2_PIN)
         #if PIN_EXISTS(X_MS3)
@@ -3296,7 +3284,7 @@ void Stepper::report_positions() {
         #endif
       );
     #endif
-    #if HAS_Y_MICROSTEPS
+    #if HAS_Y_MS_PINS
       SERIAL_ECHOPGM("Y: ");
       SERIAL_CHAR('0' + READ(Y_MS1_PIN), '0' + READ(Y_MS2_PIN)
         #if PIN_EXISTS(Y_MS3)
@@ -3304,7 +3292,7 @@ void Stepper::report_positions() {
         #endif
       );
     #endif
-    #if HAS_Z_MICROSTEPS
+    #if HAS_Z_MS_PINS
       SERIAL_ECHOPGM("Z: ");
       SERIAL_CHAR('0' + READ(Z_MS1_PIN), '0' + READ(Z_MS2_PIN)
         #if PIN_EXISTS(Z_MS3)
@@ -3312,7 +3300,7 @@ void Stepper::report_positions() {
         #endif
       );
     #endif
-    #if HAS_E0_MICROSTEPS
+    #if HAS_E0_MS_PINS
       SERIAL_ECHOPGM("E0: ");
       SERIAL_CHAR('0' + READ(E0_MS1_PIN), '0' + READ(E0_MS2_PIN)
         #if PIN_EXISTS(E0_MS3)
@@ -3320,7 +3308,7 @@ void Stepper::report_positions() {
         #endif
       );
     #endif
-    #if HAS_E1_MICROSTEPS
+    #if HAS_E1_MS_PINS
       SERIAL_ECHOPGM("E1: ");
       SERIAL_CHAR('0' + READ(E1_MS1_PIN), '0' + READ(E1_MS2_PIN)
         #if PIN_EXISTS(E1_MS3)
@@ -3328,7 +3316,7 @@ void Stepper::report_positions() {
         #endif
       );
     #endif
-    #if HAS_E2_MICROSTEPS
+    #if HAS_E2_MS_PINS
       SERIAL_ECHOPGM("E2: ");
       SERIAL_CHAR('0' + READ(E2_MS1_PIN), '0' + READ(E2_MS2_PIN)
         #if PIN_EXISTS(E2_MS3)
@@ -3336,7 +3324,7 @@ void Stepper::report_positions() {
         #endif
       );
     #endif
-    #if HAS_E3_MICROSTEPS
+    #if HAS_E3_MS_PINS
       SERIAL_ECHOPGM("E3: ");
       SERIAL_CHAR('0' + READ(E3_MS1_PIN), '0' + READ(E3_MS2_PIN)
         #if PIN_EXISTS(E3_MS3)
@@ -3344,7 +3332,7 @@ void Stepper::report_positions() {
         #endif
       );
     #endif
-    #if HAS_E4_MICROSTEPS
+    #if HAS_E4_MS_PINS
       SERIAL_ECHOPGM("E4: ");
       SERIAL_CHAR('0' + READ(E4_MS1_PIN), '0' + READ(E4_MS2_PIN)
         #if PIN_EXISTS(E4_MS3)
@@ -3352,7 +3340,7 @@ void Stepper::report_positions() {
         #endif
       );
     #endif
-    #if HAS_E5_MICROSTEPS
+    #if HAS_E5_MS_PINS
       SERIAL_ECHOPGM("E5: ");
       SERIAL_CHAR('0' + READ(E5_MS1_PIN), '0' + READ(E5_MS2_PIN)
         #if PIN_EXISTS(E5_MS3)
@@ -3360,7 +3348,7 @@ void Stepper::report_positions() {
         #endif
       );
     #endif
-    #if HAS_E6_MICROSTEPS
+    #if HAS_E6_MS_PINS
       SERIAL_ECHOPGM("E6: ");
       SERIAL_CHAR('0' + READ(E6_MS1_PIN), '0' + READ(E6_MS2_PIN)
         #if PIN_EXISTS(E6_MS3)
@@ -3368,7 +3356,7 @@ void Stepper::report_positions() {
         #endif
       );
     #endif
-    #if HAS_E7_MICROSTEPS
+    #if HAS_E7_MS_PINS
       SERIAL_ECHOPGM("E7: ");
       SERIAL_CHAR('0' + READ(E7_MS1_PIN), '0' + READ(E7_MS2_PIN)
         #if PIN_EXISTS(E7_MS3)

commit 000ec9fc139413c7702e8e295a29a21f6a6226e8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 20 09:43:15 2020 -0500

    Ensure language.h include order
    
    See #17604

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index f77a596b08..94da5f0076 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -97,7 +97,6 @@ Stepper stepper; // Singleton
 
 #include "temperature.h"
 #include "../lcd/ultralcd.h"
-#include "../core/language.h"
 #include "../gcode/queue.h"
 #include "../sd/cardreader.h"
 #include "../MarlinCore.h"

commit df8b7dfc406be095a62b5445b69c40034d418823
Author: Ben <jediminer543@users.noreply.github.com>
Date:   Fri Apr 3 01:31:08 2020 +0100

    Various Laser / Spindle improvements (#15335)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index ed48b83d5a..f77a596b08 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -133,6 +133,10 @@ Stepper stepper; // Singleton
   #include "../feature/powerloss.h"
 #endif
 
+#if HAS_CUTTER
+  #include "../feature/spindle_laser.h"
+#endif
+
 // public:
 
 #if HAS_EXTRA_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
@@ -236,6 +240,20 @@ xyz_long_t Stepper::endstops_trigsteps;
 xyze_long_t Stepper::count_position{0};
 xyze_int8_t Stepper::count_direction{0};
 
+#if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
+  Stepper::stepper_laser_t Stepper::laser = {
+    .trap_en = false,
+    .cur_power = 0,
+    .cruise_set = false,
+    #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
+      .last_step_count = 0,
+      .acc_step_count = 0
+    #else
+      .till_update = 0
+    #endif
+  };
+#endif
+
 #define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                        \
   if (separate_multi_axis) {                                                                                                \
     if (A##_HOME_DIR < 0) {                                                                                                 \
@@ -1674,10 +1692,9 @@ uint32_t Stepper::block_phase_isr() {
 
         #if ENABLED(S_CURVE_ACCELERATION)
           // Get the next speed to use (Jerk limited!)
-          uint32_t acc_step_rate =
-            acceleration_time < current_block->acceleration_time
-              ? _eval_bezier_curve(acceleration_time)
-              : current_block->cruise_rate;
+          uint32_t acc_step_rate = acceleration_time < current_block->acceleration_time
+                                   ? _eval_bezier_curve(acceleration_time)
+                                   : current_block->cruise_rate;
         #else
           acc_step_rate = STEP_MULTIPLY(acceleration_time, current_block->acceleration_rate) + current_block->initial_rate;
           NOMORE(acc_step_rate, current_block->nominal_rate);
@@ -1690,9 +1707,40 @@ uint32_t Stepper::block_phase_isr() {
         acceleration_time += interval;
 
         #if ENABLED(LIN_ADVANCE)
-          // Fire ISR if final adv_rate is reached
-          if (LA_steps && (!LA_use_advance_lead || LA_isr_rate != current_block->advance_speed))
-            initiateLA();
+          if (LA_use_advance_lead) {
+            // Fire ISR if final adv_rate is reached
+            if (LA_steps && LA_isr_rate != current_block->advance_speed) nextAdvanceISR = 0;
+          }
+          else if (LA_steps) nextAdvanceISR = 0;
+        #endif
+
+        // Update laser - Accelerating
+        #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
+          if (laser.trap_en) {
+            #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
+              if (current_block->laser.entry_per) {
+                laser.acc_step_count -= step_events_completed - laser.last_step_count;
+                laser.last_step_count = step_events_completed;
+
+                // Should be faster than a divide, since this should trip just once
+                if (laser.acc_step_count < 0) {
+                  while (laser.acc_step_count < 0) {
+                    laser.acc_step_count += current_block->laser.entry_per;
+                    if (laser.cur_power < current_block->laser.power) laser.cur_power++;
+                  }
+                  cutter.set_ocr_power(laser.cur_power);
+                }
+              }
+            #else
+              if (laser.till_update)
+                laser.till_update--;
+              else {
+                laser.till_update = LASER_POWER_INLINE_TRAPEZOID_CONT_PER;
+                laser.cur_power = (current_block->laser.power * acc_step_rate) / current_block->nominal_rate;
+                cutter.set_ocr_power(laser.cur_power); // Cycle efficiency is irrelevant it the last line was many cycles
+              }
+            #endif
+          }
         #endif
       }
       // Are we in Deceleration phase ?
@@ -1740,10 +1788,39 @@ uint32_t Stepper::block_phase_isr() {
               LA_isr_rate = current_block->advance_speed;
             }
           }
-          else if (LA_steps) initiateLA();
+          else if (LA_steps) nextAdvanceISR = 0;
+        #endif // LIN_ADVANCE
+
+        // Update laser - Decelerating
+        #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
+          if (laser.trap_en) {
+            #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
+              if (current_block->laser.exit_per) {
+                laser.acc_step_count -= step_events_completed - laser.last_step_count;
+                laser.last_step_count = step_events_completed;
+
+                // Should be faster than a divide, since this should trip just once
+                if (laser.acc_step_count < 0) {
+                  while (laser.acc_step_count < 0) {
+                    laser.acc_step_count += current_block->laser.exit_per;
+                    if (laser.cur_power > current_block->laser.power_exit) laser.cur_power--;
+                  }
+                  cutter.set_ocr_power(laser.cur_power);
+                }
+              }
+            #else
+              if (laser.till_update)
+                laser.till_update--;
+              else {
+                laser.till_update = LASER_POWER_INLINE_TRAPEZOID_CONT_PER;
+                laser.cur_power = (current_block->laser.power * step_rate) / current_block->nominal_rate;
+                cutter.set_ocr_power(laser.cur_power); // Cycle efficiency isn't relevant when the last line was many cycles
+              }
+            #endif
+          }
         #endif
       }
-      // We must be in cruise phase otherwise
+      // Must be in cruise phase otherwise
       else {
 
         #if ENABLED(LIN_ADVANCE)
@@ -1759,6 +1836,22 @@ uint32_t Stepper::block_phase_isr() {
 
         // The timer interval is just the nominal value for the nominal speed
         interval = ticks_nominal;
+
+        // Update laser - Cruising
+        #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
+          if (laser.trap_en) {
+            if (!laser.cruise_set) {
+              laser.cur_power = current_block->laser.power;
+              cutter.set_ocr_power(laser.cur_power);
+              laser.cruise_set = true;
+            }
+            #if ENABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
+              laser.till_update = LASER_POWER_INLINE_TRAPEZOID_CONT_PER;
+            #else
+              laser.last_step_count = step_events_completed;
+            #endif
+          }
+        #endif
       }
     }
   }
@@ -1805,11 +1898,11 @@ uint32_t Stepper::block_phase_isr() {
          * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X)
          */
         #if EITHER(COREXY, COREXZ)
-          #define X_CMP ==
+          #define X_CMP(A,B) ((A)==(B))
         #else
-          #define X_CMP !=
+          #define X_CMP(A,B) ((A)!=(B))
         #endif
-        #define X_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) X_CMP D_(2)) )
+        #define X_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && X_CMP(D_(1),D_(2))) )
       #else
         #define X_MOVE_TEST !!current_block->steps.a
       #endif
@@ -1823,11 +1916,11 @@ uint32_t Stepper::block_phase_isr() {
          * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z)
          */
         #if EITHER(COREYX, COREYZ)
-          #define Y_CMP ==
+          #define Y_CMP(A,B) ((A)==(B))
         #else
-          #define Y_CMP !=
+          #define Y_CMP(A,B) ((A)!=(B))
         #endif
-        #define Y_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Y_CMP D_(2)) )
+        #define Y_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && Y_CMP(D_(1),D_(2))) )
       #else
         #define Y_MOVE_TEST !!current_block->steps.b
       #endif
@@ -1841,11 +1934,11 @@ uint32_t Stepper::block_phase_isr() {
          * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Z)
          */
         #if EITHER(COREZX, COREZY)
-          #define Z_CMP ==
+          #define Z_CMP(A,B) ((A)==(B))
         #else
-          #define Z_CMP !=
+          #define Z_CMP(A,B) ((A)!=(B))
         #endif
-        #define Z_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Z_CMP D_(2)) )
+        #define Z_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && Z_CMP(D_(1),D_(2))) )
       #else
         #define Z_MOVE_TEST !!current_block->steps.c
       #endif
@@ -1938,6 +2031,39 @@ uint32_t Stepper::block_phase_isr() {
         set_directions();
       }
 
+      #if ENABLED(LASER_POWER_INLINE)
+        const uint8_t stat = current_block->laser.status;
+        #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
+          laser.trap_en = (stat & 0x03) == 0x03;
+          laser.cur_power = current_block->laser.power_entry; // RESET STATE
+          laser.cruise_set = false;
+          #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
+            laser.last_step_count = 0;
+            laser.acc_step_count = current_block->laser.entry_per / 2;
+          #else
+            laser.till_update = 0;
+          #endif
+          // Always have PWM in this case
+          if (TEST(stat, 0)) {                        // Planner controls the laser
+            if (TEST(stat, 1))                        // Laser is on
+              cutter.set_ocr_power(laser.cur_power);
+            else
+              cutter.set_power(0);
+          }
+        #else
+          if (TEST(stat, 0)) {                        // Planner controls the laser
+            #if ENABLED(SPINDLE_LASER_PWM)
+              if (TEST(stat, 1))                      // Laser is on
+                cutter.set_ocr_power(current_block->laser.power);
+              else
+                cutter.set_power(0);
+            #else
+              cutter.set_enabled(TEST(stat, 1));
+            #endif
+          }
+        #endif
+      #endif // LASER_POWER_INLINE
+
       // At this point, we must ensure the movement about to execute isn't
       // trying to force the head against a limit switch. If using interrupt-
       // driven change detection, and already against a limit then no call to
@@ -1957,21 +2083,35 @@ uint32_t Stepper::block_phase_isr() {
       // Mark the time_nominal as not calculated yet
       ticks_nominal = -1;
 
-      #if DISABLED(S_CURVE_ACCELERATION)
-        // Set as deceleration point the initial rate of the block
-        acc_step_rate = current_block->initial_rate;
-      #endif
-
       #if ENABLED(S_CURVE_ACCELERATION)
         // Initialize the Bézier speed curve
         _calc_bezier_curve_coeffs(current_block->initial_rate, current_block->cruise_rate, current_block->acceleration_time_inverse);
         // We haven't started the 2nd half of the trapezoid
         bezier_2nd_half = false;
+      #else
+        // Set as deceleration point the initial rate of the block
+        acc_step_rate = current_block->initial_rate;
       #endif
 
       // Calculate the initial timer interval
       interval = calc_timer_interval(current_block->initial_rate, &steps_per_isr);
     }
+    #if ENABLED(LASER_POWER_INLINE_CONTINUOUS)
+      else { // No new block found; so apply inline laser parameters
+        // This should mean ending file with 'M5 I' will stop the laser; thus the inline flag isn't needed
+        const uint8_t stat = planner.settings.laser.status;
+        if (TEST(stat, 0)) {             // Planner controls the laser
+          #if ENABLED(SPINDLE_LASER_PWM)
+            if (TEST(stat, 1))           // Laser is on
+              cutter.set_ocr_power(planner.settings.laser.power);
+            else
+              cutter.set_power(0);
+          #else
+            cutter.set_enabled(TEST(stat, 1));
+          #endif
+        }
+      }
+    #endif
   }
 
   // Return the interval to wait

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b83f2c2ce2..ed48b83d5a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2116,7 +2116,7 @@ void Stepper::init() {
   #if MB(ALLIGATOR)
     const float motor_current[] = MOTOR_CURRENT;
     unsigned int digipot_motor = 0;
-    for (uint8_t i = 0; i < 3 + EXTRUDERS; i++) {
+    LOOP_L_N(i, 3 + EXTRUDERS) {
       digipot_motor = 255 * (motor_current[i] / 2.5);
       dac084s085::setValue(i, digipot_motor);
     }
@@ -2756,7 +2756,7 @@ void Stepper::report_positions() {
         SPI.begin();
         SET_OUTPUT(DIGIPOTSS_PIN);
 
-        for (uint8_t i = 0; i < COUNT(digipot_motor_current); i++) {
+        LOOP_L_N(i, COUNT(digipot_motor_current)) {
           //digitalPotWrite(digipot_ch[i], digipot_motor_current[i]);
           digipot_current(i, digipot_motor_current[i]);
         }

commit 6bead0c1b04152f6a291d851f6cd4029fe0fc616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 16:29:29 2020 -0500

    Shorter paths to HAL, ExtUI (#17156)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index dacef0f2cb..b83f2c2ce2 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -130,7 +130,7 @@ Stepper stepper; // Singleton
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
-  #include "../feature/power_loss_recovery.h"
+  #include "../feature/powerloss.h"
 #endif
 
 // public:

commit 3a07b4412d24a6afd430f6d7e1b8c7f3c442a3c2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Mar 2 21:52:53 2020 -0600

    Asynchronous M114 and (R)ealtime position option (#17032)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index d4bbe36f13..dacef0f2cb 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2448,6 +2448,19 @@ int32_t Stepper::triggered_position(const AxisEnum axis) {
   return v;
 }
 
+void Stepper::report_a_position(const xyz_long_t &pos) {
+  #if CORE_IS_XY || CORE_IS_XZ || ENABLED(DELTA) || IS_SCARA
+    SERIAL_ECHOPAIR(STR_COUNT_A, pos.x, " B:", pos.y);
+  #else
+    SERIAL_ECHOPAIR_P(PSTR(STR_COUNT_X), pos.x, SP_Y_LBL, pos.y);
+  #endif
+  #if CORE_IS_XZ || CORE_IS_YZ || ENABLED(DELTA)
+    SERIAL_ECHOLNPAIR(" C:", pos.z);
+  #else
+    SERIAL_ECHOLNPAIR_P(SP_Z_LBL, pos.z);
+  #endif
+}
+
 void Stepper::report_positions() {
 
   #ifdef __AVR__
@@ -2461,16 +2474,7 @@ void Stepper::report_positions() {
     if (was_enabled) wake_up();
   #endif
 
-  #if CORE_IS_XY || CORE_IS_XZ || ENABLED(DELTA) || IS_SCARA
-    SERIAL_ECHOPAIR(STR_COUNT_A, pos.x, " B:", pos.y);
-  #else
-    SERIAL_ECHOPAIR_P(PSTR(STR_COUNT_X), pos.x, SP_Y_LBL, pos.y);
-  #endif
-  #if CORE_IS_XZ || CORE_IS_YZ || ENABLED(DELTA)
-    SERIAL_ECHOLNPAIR(" C:", pos.z);
-  #else
-    SERIAL_ECHOLNPAIR_P(SP_Z_LBL, pos.z);
-  #endif
+  report_a_position(pos);
 }
 
 #if ENABLED(BABYSTEPPING)

commit 5e9a10dbaeaa885a670af0bd7ef3e7c068f5a7b8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 1 07:36:25 2020 -0600

    Use PSTR for common labels

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 68639d40f0..d4bbe36f13 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2464,12 +2464,12 @@ void Stepper::report_positions() {
   #if CORE_IS_XY || CORE_IS_XZ || ENABLED(DELTA) || IS_SCARA
     SERIAL_ECHOPAIR(STR_COUNT_A, pos.x, " B:", pos.y);
   #else
-    SERIAL_ECHOPAIR(STR_COUNT_X, pos.x, " Y:", pos.y);
+    SERIAL_ECHOPAIR_P(PSTR(STR_COUNT_X), pos.x, SP_Y_LBL, pos.y);
   #endif
   #if CORE_IS_XZ || CORE_IS_YZ || ENABLED(DELTA)
     SERIAL_ECHOLNPAIR(" C:", pos.z);
   #else
-    SERIAL_ECHOLNPAIR(" Z:", pos.z);
+    SERIAL_ECHOLNPAIR_P(SP_Z_LBL, pos.z);
   #endif
 }
 

commit e78f607ef33044eecde744e77beea87532817c47
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 03:02:03 2020 -0600

    Use a STR_ prefix for non-translated strings

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 66fc39228d..68639d40f0 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2462,9 +2462,9 @@ void Stepper::report_positions() {
   #endif
 
   #if CORE_IS_XY || CORE_IS_XZ || ENABLED(DELTA) || IS_SCARA
-    SERIAL_ECHOPAIR(MSG_COUNT_A, pos.x, " B:", pos.y);
+    SERIAL_ECHOPAIR(STR_COUNT_A, pos.x, " B:", pos.y);
   #else
-    SERIAL_ECHOPAIR(MSG_COUNT_X, pos.x, " Y:", pos.y);
+    SERIAL_ECHOPAIR(STR_COUNT_X, pos.x, " Y:", pos.y);
   #endif
   #if CORE_IS_XZ || CORE_IS_YZ || ENABLED(DELTA)
     SERIAL_ECHOLNPAIR(" C:", pos.z);

commit 5e197df89af624d556b75c4881aacd1ab57e861d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 24 05:29:13 2020 -0600

    Fix Babystepping loop (again)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index d21d1fe359..66fc39228d 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -81,6 +81,8 @@
 
 Stepper stepper; // Singleton
 
+#define BABYSTEPPING_EXTRA_DIR_WAIT
+
 #if HAS_MOTOR_CURRENT_PWM
   bool Stepper::initialized; // = false
 #endif
@@ -1367,8 +1369,8 @@ void Stepper::isr() {
     #endif
 
     #if ENABLED(INTEGRATED_BABYSTEPPING)
-      const bool do_babystep = (nextBabystepISR == 0);              // 0 = Do Babystepping (XY)Z pulses
-      if (do_babystep) nextBabystepISR = babystepping_isr();
+      const bool is_babystep = (nextBabystepISR == 0);              // 0 = Do Babystepping (XY)Z pulses
+      if (is_babystep) nextBabystepISR = babystepping_isr();
     #endif
 
     // ^== Time critical. NOTHING besides pulse generation should be above here!!!
@@ -1376,7 +1378,7 @@ void Stepper::isr() {
     if (!nextMainISR) nextMainISR = block_phase_isr();  // Manage acc/deceleration, get next block
 
     #if ENABLED(INTEGRATED_BABYSTEPPING)
-      if (do_babystep)                                  // Avoid ANY stepping too soon after baby-stepping
+      if (is_babystep)                                  // Avoid ANY stepping too soon after baby-stepping
         NOLESS(nextMainISR, (BABYSTEP_TICKS) / 8);      // FULL STOP for 125µs after a baby-step
 
       if (nextBabystepISR != BABYSTEP_NEVER)            // Avoid baby-stepping too close to axis Stepping
@@ -2507,6 +2509,14 @@ void Stepper::report_positions() {
     #endif
   #endif
 
+  #if ENABLED(BABYSTEPPING_EXTRA_DIR_WAIT)
+    #define EXTRA_DIR_WAIT_BEFORE DIR_WAIT_BEFORE
+    #define EXTRA_DIR_WAIT_AFTER  DIR_WAIT_AFTER
+  #else
+    #define EXTRA_DIR_WAIT_BEFORE()
+    #define EXTRA_DIR_WAIT_AFTER()
+  #endif
+
   #if DISABLED(DELTA)
 
     #define BABYSTEP_AXIS(AXIS, INV, DIR) do{           \
@@ -2519,9 +2529,9 @@ void Stepper::report_positions() {
       _APPLY_STEP(AXIS, !_INVERT_STEP_PIN(AXIS), true); \
       _PULSE_WAIT();                                    \
       _APPLY_STEP(AXIS, _INVERT_STEP_PIN(AXIS), true);  \
-      DIR_WAIT_BEFORE();                                \
+      EXTRA_DIR_WAIT_BEFORE();                          \
       _APPLY_DIR(AXIS, old_dir);                        \
-      DIR_WAIT_AFTER();                                 \
+      EXTRA_DIR_WAIT_AFTER();                           \
     }while(0)
 
   #elif IS_CORE
@@ -2539,9 +2549,9 @@ void Stepper::report_positions() {
       _PULSE_WAIT();                                            \
       _APPLY_STEP(A, _INVERT_STEP_PIN(A), true);                \
       _APPLY_STEP(B, _INVERT_STEP_PIN(B), true);                \
-      DIR_WAIT_BEFORE();                                        \
+      EXTRA_DIR_WAIT_BEFORE();                                  \
       _APPLY_DIR(A, old_dir.a); _APPLY_DIR(B, old_dir.b);       \
-      DIR_WAIT_AFTER();                                         \
+      EXTRA_DIR_WAIT_AFTER();                                   \
     }while(0)
 
   #endif
@@ -2620,13 +2630,13 @@ void Stepper::report_positions() {
           Z_STEP_WRITE(INVERT_Z_STEP_PIN);
 
           // Restore direction bits
-          DIR_WAIT_BEFORE();
+          EXTRA_DIR_WAIT_BEFORE();
 
           X_DIR_WRITE(old_dir.x);
           Y_DIR_WRITE(old_dir.y);
           Z_DIR_WRITE(old_dir.z);
 
-          DIR_WAIT_AFTER();
+          EXTRA_DIR_WAIT_AFTER();
 
         #endif
 

commit b9b29bf4c075996f50ed2f8680fbed3862239010
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 22 07:04:06 2020 -0600

    Followup to babystep hotfix

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 5ccfca2e00..d21d1fe359 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2564,7 +2564,7 @@ void Stepper::report_positions() {
           #elif CORE_IS_XZ
             BABYSTEP_CORE(X, Z, 0, direction, 0);
           #else
-            BABYSTEP_AXIS(X, 0, direction, 0);
+            BABYSTEP_AXIS(X, 0, direction);
           #endif
           break;
 
@@ -2574,7 +2574,7 @@ void Stepper::report_positions() {
           #elif CORE_IS_YZ
             BABYSTEP_CORE(Y, Z, 0, direction, (CORESIGN(1)<0));
           #else
-            BABYSTEP_AXIS(Y, 0, direction, (CORESIGN(1)<0));
+            BABYSTEP_AXIS(Y, 0, direction);
           #endif
           break;
 
@@ -2587,7 +2587,7 @@ void Stepper::report_positions() {
         #elif CORE_IS_YZ
           BABYSTEP_CORE(Y, Z, BABYSTEP_INVERT_Z, direction, (CORESIGN(1)<0));
         #elif DISABLED(DELTA)
-          BABYSTEP_AXIS(Z, BABYSTEP_INVERT_Z, direction, (CORESIGN(1)<0));
+          BABYSTEP_AXIS(Z, BABYSTEP_INVERT_Z, direction);
 
         #else // DELTA
 

commit 484e1a624c178f1bb0996892d2c606f6cfebefbe
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 22 02:52:59 2020 -0600

    CoreXY Babystepping hotfix

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 0a79855bcf..5ccfca2e00 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2526,12 +2526,12 @@ void Stepper::report_positions() {
 
   #elif IS_CORE
 
-    #define BABYSTEP_CORE(A, B, INV, DIR) do{                   \
+    #define BABYSTEP_CORE(A, B, INV, DIR, ALT) do{              \
       const xy_byte_t old_dir = { _READ_DIR(A), _READ_DIR(B) }; \
       _ENABLE_AXIS(A); _ENABLE_AXIS(B);                         \
       DIR_WAIT_BEFORE();                                        \
       _APPLY_DIR(A, _INVERT_DIR(A)^DIR^INV);                    \
-      _APPLY_DIR(B, _INVERT_DIR(B)^DIR^INV^(CORESIGN(1)<0));    \
+      _APPLY_DIR(B, _INVERT_DIR(B)^DIR^INV^ALT);                \
       DIR_WAIT_AFTER();                                         \
       _SAVE_START();                                            \
       _APPLY_STEP(A, !_INVERT_STEP_PIN(A), true);               \
@@ -2560,21 +2560,21 @@ void Stepper::report_positions() {
 
         case X_AXIS:
           #if CORE_IS_XY
-            BABYSTEP_CORE(X, Y, false, direction);
+            BABYSTEP_CORE(X, Y, 0, direction, 0);
           #elif CORE_IS_XZ
-            BABYSTEP_CORE(X, Z, false, direction);
+            BABYSTEP_CORE(X, Z, 0, direction, 0);
           #else
-            BABYSTEP_AXIS(X, false, direction);
+            BABYSTEP_AXIS(X, 0, direction, 0);
           #endif
           break;
 
         case Y_AXIS:
           #if CORE_IS_XY
-            BABYSTEP_CORE(X, Y, false, direction);
+            BABYSTEP_CORE(X, Y, 0, direction, (CORESIGN(1)<0));
           #elif CORE_IS_YZ
-            BABYSTEP_CORE(Y, Z, false, direction);
+            BABYSTEP_CORE(Y, Z, 0, direction, (CORESIGN(1)<0));
           #else
-            BABYSTEP_AXIS(Y, false, direction);
+            BABYSTEP_AXIS(Y, 0, direction, (CORESIGN(1)<0));
           #endif
           break;
 
@@ -2583,11 +2583,11 @@ void Stepper::report_positions() {
       case Z_AXIS: {
 
         #if CORE_IS_XZ
-          BABYSTEP_CORE(X, Z, BABYSTEP_INVERT_Z, direction);
+          BABYSTEP_CORE(X, Z, BABYSTEP_INVERT_Z, direction, (CORESIGN(1)<0));
         #elif CORE_IS_YZ
-          BABYSTEP_CORE(Y, Z, BABYSTEP_INVERT_Z, direction);
+          BABYSTEP_CORE(Y, Z, BABYSTEP_INVERT_Z, direction, (CORESIGN(1)<0));
         #elif DISABLED(DELTA)
-          BABYSTEP_AXIS(Z, BABYSTEP_INVERT_Z, direction);
+          BABYSTEP_AXIS(Z, BABYSTEP_INVERT_Z, direction, (CORESIGN(1)<0));
 
         #else // DELTA
 

commit 99a50743727e2076c19d8f9469090c3ddd6f9a93
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 16 17:46:41 2020 -0600

    Fix babystep include, typos in stepper.cpp
    
    Fix #16881

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index e898d974ed..0a79855bcf 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -101,6 +101,10 @@ Stepper stepper; // Singleton
 #include "../MarlinCore.h"
 #include "../HAL/shared/Delay.h"
 
+#if ENABLED(INTEGRATED_BABYSTEPPING)
+  #include "../feature/babystep.h"
+#endif
+
 #if MB(ALLIGATOR)
   #include "../feature/dac/dac_dac084s085.h"
 #endif
@@ -1373,10 +1377,10 @@ void Stepper::isr() {
 
     #if ENABLED(INTEGRATED_BABYSTEPPING)
       if (do_babystep)                                  // Avoid ANY stepping too soon after baby-stepping
-        NOLESS(nextMainISR, (BABYSTEP_TICKS) / 8)       // FULL STOP for 125µs after a baby-step
+        NOLESS(nextMainISR, (BABYSTEP_TICKS) / 8);      // FULL STOP for 125µs after a baby-step
 
       if (nextBabystepISR != BABYSTEP_NEVER)            // Avoid baby-stepping too close to axis Stepping
-        NOLESS(nextBabystepISR, nextMainISR / 2)        // TODO: Only look at axes enabled for baby-stepping
+        NOLESS(nextBabystepISR, nextMainISR / 2);       // TODO: Only look at axes enabled for baby-stepping
     #endif
 
     // Get the interval to the next ISR call
@@ -2544,7 +2548,7 @@ void Stepper::report_positions() {
 
   // MUST ONLY BE CALLED BY AN ISR,
   // No other ISR should ever interrupt this!
-  void Stepper::babystep(const AxisEnum axis, const bool direction) {
+  void Stepper::do_babystep(const AxisEnum axis, const bool direction) {
 
     #if DISABLED(INTEGRATED_BABYSTEPPING)
       cli();

commit 64a81f887a3b9fd471484dba784e11bdba88ffbb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 15 21:42:28 2020 -0600

    EXPERIMENTAL integrated BABYSTEPPING (#16829)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 6e0a318fcb..e898d974ed 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -217,6 +217,10 @@ uint32_t Stepper::advance_divisor = 0,
 
 #endif // LIN_ADVANCE
 
+#if ENABLED(INTEGRATED_BABYSTEPPING)
+  uint32_t Stepper::nextBabystepISR = BABYSTEP_NEVER;
+#endif
+
 int32_t Stepper::ticks_nominal = -1;
 #if DISABLED(S_CURVE_ACCELERATION)
   uint32_t Stepper::acc_step_rate; // needed for deceleration start point
@@ -1358,16 +1362,32 @@ void Stepper::isr() {
       if (!nextAdvanceISR) nextAdvanceISR = advance_isr();          // 0 = Do Linear Advance E Stepper pulses
     #endif
 
+    #if ENABLED(INTEGRATED_BABYSTEPPING)
+      const bool do_babystep = (nextBabystepISR == 0);              // 0 = Do Babystepping (XY)Z pulses
+      if (do_babystep) nextBabystepISR = babystepping_isr();
+    #endif
+
     // ^== Time critical. NOTHING besides pulse generation should be above here!!!
 
     if (!nextMainISR) nextMainISR = block_phase_isr();  // Manage acc/deceleration, get next block
 
+    #if ENABLED(INTEGRATED_BABYSTEPPING)
+      if (do_babystep)                                  // Avoid ANY stepping too soon after baby-stepping
+        NOLESS(nextMainISR, (BABYSTEP_TICKS) / 8)       // FULL STOP for 125µs after a baby-step
+
+      if (nextBabystepISR != BABYSTEP_NEVER)            // Avoid baby-stepping too close to axis Stepping
+        NOLESS(nextBabystepISR, nextMainISR / 2)        // TODO: Only look at axes enabled for baby-stepping
+    #endif
+
     // Get the interval to the next ISR call
     const uint32_t interval = _MIN(
-      nextMainISR                                       // Time until the next Stepper ISR
+      nextMainISR                                       // Time until the next Pulse / Block phase
       #if ENABLED(LIN_ADVANCE)
         , nextAdvanceISR                                // Come back early for Linear Advance?
       #endif
+      #if ENABLED(INTEGRATED_BABYSTEPPING)
+        , nextBabystepISR                               // Come back early for Babystepping?
+      #endif
       , uint32_t(HAL_TIMER_TYPE_MAX)                    // Come back in a very long time
     );
 
@@ -1384,6 +1404,10 @@ void Stepper::isr() {
       if (nextAdvanceISR != LA_ADV_NEVER) nextAdvanceISR -= interval;
     #endif
 
+    #if ENABLED(INTEGRATED_BABYSTEPPING)
+      if (nextBabystepISR != BABYSTEP_NEVER) nextBabystepISR -= interval;
+    #endif
+
     /**
      * This needs to avoid a race-condition caused by interleaving
      * of interrupts required by both the LA and Stepper algorithms.
@@ -2043,6 +2067,16 @@ uint32_t Stepper::block_phase_isr() {
 
 #endif // LIN_ADVANCE
 
+#if ENABLED(INTEGRATED_BABYSTEPPING)
+
+  // Timer interrupt for baby-stepping
+  uint32_t Stepper::babystepping_isr() {
+    babystep.task();
+    return babystep.has_steps() ? BABYSTEP_TICKS : BABYSTEP_NEVER;
+  }
+
+#endif
+
 // Check if the given block is busy or not - Must not be called from ISR contexts
 // The current_block could change in the middle of the read by an Stepper ISR, so
 // we must explicitly prevent that!
@@ -2511,7 +2545,10 @@ void Stepper::report_positions() {
   // MUST ONLY BE CALLED BY AN ISR,
   // No other ISR should ever interrupt this!
   void Stepper::babystep(const AxisEnum axis, const bool direction) {
-    cli();
+
+    #if DISABLED(INTEGRATED_BABYSTEPPING)
+      cli();
+    #endif
 
     switch (axis) {
 
@@ -2594,7 +2631,9 @@ void Stepper::report_positions() {
       default: break;
     }
 
-    sei();
+    #if DISABLED(INTEGRATED_BABYSTEPPING)
+      sei();
+    #endif
   }
 
 #endif // BABYSTEPPING

commit 0b984519c30f453fdb5b4efb8008a07c69688824
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Feb 14 05:14:37 2020 -0600

    Clean up stepper and babystep (#16857)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index bc08e35377..6e0a318fcb 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -203,11 +203,8 @@ uint32_t Stepper::advance_divisor = 0,
   bool Stepper::bezier_2nd_half;    // =false If Bézier curve has been initialized or not
 #endif
 
-uint32_t Stepper::nextMainISR = 0;
-
 #if ENABLED(LIN_ADVANCE)
 
-  constexpr uint32_t LA_ADV_NEVER = 0xFFFFFFFF;
   uint32_t Stepper::nextAdvanceISR = LA_ADV_NEVER,
            Stepper::LA_isr_rate = LA_ADV_NEVER;
   uint16_t Stepper::LA_current_adv_steps = 0,
@@ -402,13 +399,13 @@ constexpr uint32_t NS_TO_PULSE_TIMER_TICKS(uint32_t NS) { return (NS + (NS_PER_P
 #define PULSE_HIGH_TICK_COUNT hal_timer_t(NS_TO_PULSE_TIMER_TICKS(_MIN_PULSE_HIGH_NS - _MIN(_MIN_PULSE_HIGH_NS, TIMER_SETUP_NS)))
 #define PULSE_LOW_TICK_COUNT hal_timer_t(NS_TO_PULSE_TIMER_TICKS(_MIN_PULSE_LOW_NS - _MIN(_MIN_PULSE_LOW_NS, TIMER_SETUP_NS)))
 
-#define USING_TIMED_PULSE() hal_timer_t end_tick_count = 0
-#define START_TIMED_PULSE(DIR) (end_tick_count = HAL_timer_get_count(PULSE_TIMER_NUM) + PULSE_##DIR##_TICK_COUNT)
-#define AWAIT_TIMED_PULSE() while (HAL_timer_get_count(PULSE_TIMER_NUM) < end_tick_count) { }
+#define USING_TIMED_PULSE() hal_timer_t start_pulse_count = 0
+#define START_TIMED_PULSE(DIR) (start_pulse_count = HAL_timer_get_count(PULSE_TIMER_NUM))
+#define AWAIT_TIMED_PULSE(DIR) while (PULSE_##DIR##_TICK_COUNT > HAL_timer_get_count(PULSE_TIMER_NUM) - start_pulse_count) { }
 #define START_HIGH_PULSE()  START_TIMED_PULSE(HIGH)
+#define AWAIT_HIGH_PULSE()  AWAIT_TIMED_PULSE(HIGH)
 #define START_LOW_PULSE()   START_TIMED_PULSE(LOW)
-#define AWAIT_HIGH_PULSE()  AWAIT_TIMED_PULSE()
-#define AWAIT_LOW_PULSE()   AWAIT_TIMED_PULSE()
+#define AWAIT_LOW_PULSE()   AWAIT_TIMED_PULSE(LOW)
 
 #if MINIMUM_STEPPER_PRE_DIR_DELAY > 0
   #define DIR_WAIT_BEFORE() DELAY_NS(MINIMUM_STEPPER_PRE_DIR_DELAY)
@@ -422,11 +419,6 @@ constexpr uint32_t NS_TO_PULSE_TIMER_TICKS(uint32_t NS) { return (NS + (NS_PER_P
   #define DIR_WAIT_AFTER()
 #endif
 
-void Stepper::wake_up() {
-  // TCNT1 = 0;
-  ENABLE_STEPPER_DRIVER_INTERRUPT();
-}
-
 /**
  * Set the stepper direction of each axis
  *
@@ -1334,6 +1326,9 @@ HAL_STEP_TIMER_ISR() {
 #endif
 
 void Stepper::isr() {
+
+  static uint32_t nextMainISR = 0;  // Interval until the next main Stepper Pulse phase (0 = Now)
+
   #ifndef __AVR__
     // Disable interrupts, to avoid ISR preemption while we reprogram the period
     // (AVR enters the ISR with global interrupts disabled, so no need to do it here)
@@ -1357,35 +1352,35 @@ void Stepper::isr() {
     // Enable ISRs to reduce USART processing latency
     ENABLE_ISRS();
 
-    // Run main stepping pulse phase ISR if we have to
-    if (!nextMainISR) Stepper::stepper_pulse_phase_isr();
+    if (!nextMainISR) pulse_phase_isr();                            // 0 = Do coordinated axes Stepper pulses
 
     #if ENABLED(LIN_ADVANCE)
-      // Run linear advance stepper ISR if we have to
-      if (!nextAdvanceISR) nextAdvanceISR = Stepper::advance_isr();
+      if (!nextAdvanceISR) nextAdvanceISR = advance_isr();          // 0 = Do Linear Advance E Stepper pulses
     #endif
 
     // ^== Time critical. NOTHING besides pulse generation should be above here!!!
 
-    // Run main stepping block processing ISR if we have to
-    if (!nextMainISR) nextMainISR = Stepper::stepper_block_phase_isr();
+    if (!nextMainISR) nextMainISR = block_phase_isr();  // Manage acc/deceleration, get next block
 
-    uint32_t interval =
+    // Get the interval to the next ISR call
+    const uint32_t interval = _MIN(
+      nextMainISR                                       // Time until the next Stepper ISR
       #if ENABLED(LIN_ADVANCE)
-        _MIN(nextAdvanceISR, nextMainISR)  // Nearest time interval
-      #else
-        nextMainISR                       // Remaining stepper ISR time
+        , nextAdvanceISR                                // Come back early for Linear Advance?
       #endif
-    ;
+      , uint32_t(HAL_TIMER_TYPE_MAX)                    // Come back in a very long time
+    );
 
-    // Limit the value to the maximum possible value of the timer
-    NOMORE(interval, uint32_t(HAL_TIMER_TYPE_MAX));
+    //
+    // Compute remaining time for each ISR phase
+    //     NEVER : The phase is idle
+    //      Zero : The phase will occur on the next ISR call
+    //  Non-zero : The phase will occur on a future ISR call
+    //
 
-    // Compute the time remaining for the main isr
     nextMainISR -= interval;
 
     #if ENABLED(LIN_ADVANCE)
-      // Compute the time remaining for the advance isr
       if (nextAdvanceISR != LA_ADV_NEVER) nextAdvanceISR -= interval;
     #endif
 
@@ -1471,7 +1466,7 @@ void Stepper::isr() {
  * call to this method that might cause variation in the timing. The aim
  * is to keep pulse timing as regular as possible.
  */
-void Stepper::stepper_pulse_phase_isr() {
+void Stepper::pulse_phase_isr() {
 
   // If we must abort the current block, do so!
   if (abort_current_block) {
@@ -1548,7 +1543,7 @@ void Stepper::stepper_pulse_phase_isr() {
           // Don't step E here - But remember the number of steps to perform
           motor_direction(E_AXIS) ? --LA_steps : ++LA_steps;
         #else
-          step_needed.e = delta_error.e >= 0;
+          step_needed.e = true;
         #endif
       }
     #elif HAS_E0_STEP
@@ -1604,20 +1599,14 @@ void Stepper::stepper_pulse_phase_isr() {
 
     #if DISABLED(LIN_ADVANCE)
       #if ENABLED(MIXING_EXTRUDER)
-
         if (delta_error.e >= 0) {
           delta_error.e -= advance_divisor;
           E_STEP_WRITE(mixer.get_stepper(), INVERT_E_STEP_PIN);
         }
-
-      #else // !MIXING_EXTRUDER
-
-        #if HAS_E0_STEP
-          PULSE_STOP(E);
-        #endif
-
-      #endif  // !MIXING_EXTRUDER
-    #endif // !LIN_ADVANCE
+      #elif HAS_E0_STEP
+        PULSE_STOP(E);
+      #endif
+    #endif
 
     #if ISR_MULTI_STEPS
       if (events_to_do) START_LOW_PULSE();
@@ -1630,10 +1619,10 @@ void Stepper::stepper_pulse_phase_isr() {
 // properly schedules blocks from the planner. This is executed after creating
 // the step pulses, so it is not time critical, as pulses are already done.
 
-uint32_t Stepper::stepper_block_phase_isr() {
+uint32_t Stepper::block_phase_isr() {
 
-  // If no queued movements, just wait 1ms for the next move
-  uint32_t interval = (STEPPER_TIMER_RATE) / 1000;
+  // If no queued movements, just wait 1ms for the next block
+  uint32_t interval = (STEPPER_TIMER_RATE) / 1000UL;
 
   // If there is a current block
   if (current_block) {
@@ -1667,16 +1656,14 @@ uint32_t Stepper::stepper_block_phase_isr() {
         // acc_step_rate is in steps/second
 
         // step_rate to timer interval and steps per stepper isr
-        interval = calc_timer_interval(acc_step_rate, oversampling_factor, &steps_per_isr);
+        interval = calc_timer_interval(acc_step_rate, &steps_per_isr);
         acceleration_time += interval;
 
         #if ENABLED(LIN_ADVANCE)
-          if (LA_use_advance_lead) {
-            // Fire ISR if final adv_rate is reached
-            if (LA_steps && LA_isr_rate != current_block->advance_speed) nextAdvanceISR = 0;
-          }
-          else if (LA_steps) nextAdvanceISR = 0;
-        #endif // LIN_ADVANCE
+          // Fire ISR if final adv_rate is reached
+          if (LA_steps && (!LA_use_advance_lead || LA_isr_rate != current_block->advance_speed))
+            initiateLA();
+        #endif
       }
       // Are we in Deceleration phase ?
       else if (step_events_completed > decelerate_after) {
@@ -1712,32 +1699,32 @@ uint32_t Stepper::stepper_block_phase_isr() {
         // step_rate is in steps/second
 
         // step_rate to timer interval and steps per stepper isr
-        interval = calc_timer_interval(step_rate, oversampling_factor, &steps_per_isr);
+        interval = calc_timer_interval(step_rate, &steps_per_isr);
         deceleration_time += interval;
 
         #if ENABLED(LIN_ADVANCE)
           if (LA_use_advance_lead) {
             // Wake up eISR on first deceleration loop and fire ISR if final adv_rate is reached
             if (step_events_completed <= decelerate_after + steps_per_isr || (LA_steps && LA_isr_rate != current_block->advance_speed)) {
-              nextAdvanceISR = 0;
+              initiateLA();
               LA_isr_rate = current_block->advance_speed;
             }
           }
-          else if (LA_steps) nextAdvanceISR = 0;
-        #endif // LIN_ADVANCE
+          else if (LA_steps) initiateLA();
+        #endif
       }
       // We must be in cruise phase otherwise
       else {
 
         #if ENABLED(LIN_ADVANCE)
           // If there are any esteps, fire the next advance_isr "now"
-          if (LA_steps && LA_isr_rate != current_block->advance_speed) nextAdvanceISR = 0;
+          if (LA_steps && LA_isr_rate != current_block->advance_speed) initiateLA();
         #endif
 
         // Calculate the ticks_nominal for this nominal speed, if not done yet
         if (ticks_nominal < 0) {
           // step_rate to timer interval and loops for the nominal speed
-          ticks_nominal = calc_timer_interval(current_block->nominal_rate, oversampling_factor, &steps_per_isr);
+          ticks_nominal = calc_timer_interval(current_block->nominal_rate, &steps_per_isr);
         }
 
         // The timer interval is just the nominal value for the nominal speed
@@ -1846,17 +1833,17 @@ uint32_t Stepper::stepper_block_phase_isr() {
       // No acceleration / deceleration time elapsed so far
       acceleration_time = deceleration_time = 0;
 
-      uint8_t oversampling = 0;                         // Assume we won't use it
+      uint8_t oversampling = 0;                           // Assume no axis smoothing (via oversampling)
 
       #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
-        // At this point, we must decide if we can use Stepper movement axis smoothing.
+        // Decide if axis smoothing is possible
         uint32_t max_rate = current_block->nominal_rate;  // Get the maximum rate (maximum event speed)
-        while (max_rate < MIN_STEP_ISR_FREQUENCY) {
-          max_rate <<= 1;
-          if (max_rate >= MAX_STEP_ISR_FREQUENCY_1X) break;
-          ++oversampling;
+        while (max_rate < MIN_STEP_ISR_FREQUENCY) {         // As long as more ISRs are possible...
+          max_rate <<= 1;                                   // Try to double the rate
+          if (max_rate >= MAX_STEP_ISR_FREQUENCY_1X) break; // Don't exceed the estimated ISR limit
+          ++oversampling;                                   // Increase the oversampling (used for left-shift)
         }
-        oversampling_factor = oversampling;
+        oversampling_factor = oversampling;                 // For all timer interval calculations
       #endif
 
       // Based on the oversampling factor, do the calculations
@@ -1894,8 +1881,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
         if ((LA_use_advance_lead = current_block->use_advance_lead)) {
           LA_final_adv_steps = current_block->final_adv_steps;
           LA_max_adv_steps = current_block->max_adv_steps;
-          //Start the ISR
-          nextAdvanceISR = 0;
+          initiateLA(); // Start the ISR
           LA_isr_rate = current_block->advance_speed;
         }
         else LA_isr_rate = LA_ADV_NEVER;
@@ -1954,7 +1940,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
       #endif
 
       // Calculate the initial timer interval
-      interval = calc_timer_interval(current_block->initial_rate, oversampling_factor, &steps_per_isr);
+      interval = calc_timer_interval(current_block->initial_rate, &steps_per_isr);
     }
   }
 
@@ -2054,6 +2040,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
 
     return interval;
   }
+
 #endif // LIN_ADVANCE
 
 // Check if the given block is busy or not - Must not be called from ISR contexts
@@ -2093,7 +2080,7 @@ void Stepper::init() {
       digipot_motor = 255 * (motor_current[i] / 2.5);
       dac084s085::setValue(i, digipot_motor);
     }
-  #endif//MB(ALLIGATOR)
+  #endif
 
   // Init Microstepping Pins
   #if HAS_MICROSTEPS
@@ -2287,7 +2274,7 @@ void Stepper::init() {
 
   #if DISABLED(I2S_STEPPER_STREAM)
     HAL_timer_start(STEP_TIMER_NUM, 122); // Init Stepper ISR to 122 Hz for quick starting
-    ENABLE_STEPPER_DRIVER_INTERRUPT();
+    wake_up();
     sei();
   #endif
 
@@ -2341,19 +2328,43 @@ int32_t Stepper::position(const AxisEnum axis) {
   #ifdef __AVR__
     // Protect the access to the position. Only required for AVR, as
     //  any 32bit CPU offers atomic access to 32bit variables
-    const bool was_enabled = STEPPER_ISR_ENABLED();
-    if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+    const bool was_enabled = suspend();
   #endif
 
   const int32_t v = count_position[axis];
 
   #ifdef __AVR__
     // Reenable Stepper ISR
-    if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+    if (was_enabled) wake_up();
   #endif
   return v;
 }
 
+// Set the current position in steps
+void Stepper::set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
+  planner.synchronize();
+  const bool was_enabled = suspend();
+  _set_position(a, b, c, e);
+  if (was_enabled) wake_up();
+}
+
+void Stepper::set_axis_position(const AxisEnum a, const int32_t &v) {
+  planner.synchronize();
+
+  #ifdef __AVR__
+    // Protect the access to the position. Only required for AVR, as
+    //  any 32bit CPU offers atomic access to 32bit variables
+    const bool was_enabled = suspend();
+  #endif
+
+  count_position[a] = v;
+
+  #ifdef __AVR__
+    // Reenable Stepper ISR
+    if (was_enabled) wake_up();
+  #endif
+}
+
 // Signal endstops were triggered - This function can be called from
 // an ISR context  (Temperature, Stepper or limits ISR), so we must
 // be very careful here. If the interrupt being preempted was the
@@ -2362,8 +2373,7 @@ int32_t Stepper::position(const AxisEnum axis) {
 // is properly canceled
 void Stepper::endstop_triggered(const AxisEnum axis) {
 
-  const bool was_enabled = STEPPER_ISR_ENABLED();
-  if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+  const bool was_enabled = suspend();
   endstops_trigsteps[axis] = (
     #if IS_CORE
       (axis == CORE_AXIS_2
@@ -2378,22 +2388,21 @@ void Stepper::endstop_triggered(const AxisEnum axis) {
   // Discard the rest of the move if there is a current block
   quick_stop();
 
-  if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+  if (was_enabled) wake_up();
 }
 
 int32_t Stepper::triggered_position(const AxisEnum axis) {
   #ifdef __AVR__
     // Protect the access to the position. Only required for AVR, as
     //  any 32bit CPU offers atomic access to 32bit variables
-    const bool was_enabled = STEPPER_ISR_ENABLED();
-    if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+    const bool was_enabled = suspend();
   #endif
 
   const int32_t v = endstops_trigsteps[axis];
 
   #ifdef __AVR__
     // Reenable Stepper ISR
-    if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+    if (was_enabled) wake_up();
   #endif
 
   return v;
@@ -2403,14 +2412,13 @@ void Stepper::report_positions() {
 
   #ifdef __AVR__
     // Protect the access to the position.
-    const bool was_enabled = STEPPER_ISR_ENABLED();
-    if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+    const bool was_enabled = suspend();
   #endif
 
   const xyz_long_t pos = count_position;
 
   #ifdef __AVR__
-    if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+    if (was_enabled) wake_up();
   #endif
 
   #if CORE_IS_XY || CORE_IS_XZ || ENABLED(DELTA) || IS_SCARA
@@ -2571,16 +2579,21 @@ void Stepper::report_positions() {
           Z_STEP_WRITE(INVERT_Z_STEP_PIN);
 
           // Restore direction bits
+          DIR_WAIT_BEFORE();
+
           X_DIR_WRITE(old_dir.x);
           Y_DIR_WRITE(old_dir.y);
           Z_DIR_WRITE(old_dir.z);
 
+          DIR_WAIT_AFTER();
+
         #endif
 
       } break;
 
       default: break;
     }
+
     sei();
   }
 

commit 189c101793c72780fdff2b8cd693d4a53040a0e8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Feb 11 08:52:11 2020 -0600

    Use prior babystep delay method (#16833)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index a4a457c0a7..bc08e35377 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2432,47 +2432,78 @@ void Stepper::report_positions() {
   #define _INVERT_DIR(AXIS) INVERT_## AXIS ##_DIR
   #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)
 
+  #if MINIMUM_STEPPER_PULSE
+    #define STEP_PULSE_CYCLES ((MINIMUM_STEPPER_PULSE) * CYCLES_PER_MICROSECOND)
+  #else
+    #define STEP_PULSE_CYCLES 0
+  #endif
+
+  #if ENABLED(DELTA)
+    #define CYCLES_EATEN_BABYSTEP (2 * 15)
+  #else
+    #define CYCLES_EATEN_BABYSTEP 0
+  #endif
+  #define EXTRA_CYCLES_BABYSTEP (STEP_PULSE_CYCLES - (CYCLES_EATEN_BABYSTEP))
+
+  #if EXTRA_CYCLES_BABYSTEP > 20
+    #define _SAVE_START() const hal_timer_t pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM)
+    #define _PULSE_WAIT() while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
+  #else
+    #define _SAVE_START() NOOP
+    #if EXTRA_CYCLES_BABYSTEP > 0
+      #define _PULSE_WAIT() DELAY_NS(EXTRA_CYCLES_BABYSTEP * NANOSECONDS_PER_CYCLE)
+    #elif ENABLED(DELTA)
+      #define _PULSE_WAIT() DELAY_US(2);
+    #elif STEP_PULSE_CYCLES > 0
+      #define _PULSE_WAIT() NOOP
+    #else
+      #define _PULSE_WAIT() DELAY_US(4);
+    #endif
+  #endif
+
   #if DISABLED(DELTA)
+
     #define BABYSTEP_AXIS(AXIS, INV, DIR) do{           \
       const uint8_t old_dir = _READ_DIR(AXIS);          \
       _ENABLE_AXIS(AXIS);                               \
       DIR_WAIT_BEFORE();                                \
       _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^DIR^INV);      \
       DIR_WAIT_AFTER();                                 \
-      USING_TIMED_PULSE();                              \
-      START_HIGH_PULSE();                               \
+      _SAVE_START();                                    \
       _APPLY_STEP(AXIS, !_INVERT_STEP_PIN(AXIS), true); \
-      AWAIT_HIGH_PULSE();                               \
-      _APPLY_STEP(AXIS,  _INVERT_STEP_PIN(AXIS), true); \
+      _PULSE_WAIT();                                    \
+      _APPLY_STEP(AXIS, _INVERT_STEP_PIN(AXIS), true);  \
+      DIR_WAIT_BEFORE();                                \
       _APPLY_DIR(AXIS, old_dir);                        \
+      DIR_WAIT_AFTER();                                 \
     }while(0)
-  #endif
 
-  #if IS_CORE
-    #define BABYSTEP_CORE(A, B, INV, DIR) do{     \
+  #elif IS_CORE
+
+    #define BABYSTEP_CORE(A, B, INV, DIR) do{                   \
       const xy_byte_t old_dir = { _READ_DIR(A), _READ_DIR(B) }; \
-      _ENABLE_AXIS(A); _ENABLE_AXIS(B);           \
-      DIR_WAIT_BEFORE();                          \
-      _APPLY_DIR(A, _INVERT_DIR(A)^DIR^INV);      \
-      _APPLY_DIR(B, _INVERT_DIR(B)^DIR^INV^(CORESIGN(1)<0)); \
-      DIR_WAIT_AFTER();                           \
-      USING_TIMED_PULSE();                        \
-      START_HIGH_PULSE();                         \
-      _APPLY_STEP(A, !_INVERT_STEP_PIN(A), true); \
-      _APPLY_STEP(B, !_INVERT_STEP_PIN(B), true); \
-      AWAIT_HIGH_PULSE();                         \
-      _APPLY_STEP(A,  _INVERT_STEP_PIN(A), true); \
-      _APPLY_STEP(B,  _INVERT_STEP_PIN(B), true); \
-      _APPLY_DIR(A, old_dir.a); _APPLY_DIR(B, old_dir.b); \
+      _ENABLE_AXIS(A); _ENABLE_AXIS(B);                         \
+      DIR_WAIT_BEFORE();                                        \
+      _APPLY_DIR(A, _INVERT_DIR(A)^DIR^INV);                    \
+      _APPLY_DIR(B, _INVERT_DIR(B)^DIR^INV^(CORESIGN(1)<0));    \
+      DIR_WAIT_AFTER();                                         \
+      _SAVE_START();                                            \
+      _APPLY_STEP(A, !_INVERT_STEP_PIN(A), true);               \
+      _APPLY_STEP(B, !_INVERT_STEP_PIN(B), true);               \
+      _PULSE_WAIT();                                            \
+      _APPLY_STEP(A, _INVERT_STEP_PIN(A), true);                \
+      _APPLY_STEP(B, _INVERT_STEP_PIN(B), true);                \
+      DIR_WAIT_BEFORE();                                        \
+      _APPLY_DIR(A, old_dir.a); _APPLY_DIR(B, old_dir.b);       \
+      DIR_WAIT_AFTER();                                         \
     }while(0)
+
   #endif
 
   // MUST ONLY BE CALLED BY AN ISR,
   // No other ISR should ever interrupt this!
   void Stepper::babystep(const AxisEnum axis, const bool direction) {
-    DISABLE_ISRS();
-
-    USING_TIMED_PULSE();
+    cli();
 
     switch (axis) {
 
@@ -2527,13 +2558,13 @@ void Stepper::report_positions() {
 
           DIR_WAIT_AFTER();
 
-          START_HIGH_PULSE();
+          _SAVE_START();
 
           X_STEP_WRITE(!INVERT_X_STEP_PIN);
           Y_STEP_WRITE(!INVERT_Y_STEP_PIN);
           Z_STEP_WRITE(!INVERT_Z_STEP_PIN);
 
-          AWAIT_HIGH_PULSE();
+          _PULSE_WAIT();
 
           X_STEP_WRITE(INVERT_X_STEP_PIN);
           Y_STEP_WRITE(INVERT_Y_STEP_PIN);
@@ -2550,9 +2581,7 @@ void Stepper::report_positions() {
 
       default: break;
     }
-
-    START_LOW_PULSE(); AWAIT_LOW_PULSE();  // Prevent Stepper::ISR pulsing too soon
-    ENABLE_ISRS();                         // Now it's ok for the ISR to run
+    sei();
   }
 
 #endif // BABYSTEPPING

commit 2836834d7ef2043ccd80b8a76560c21f2eb8fe74
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Feb 10 16:58:21 2020 -0600

    Unify step pulse timing of ISR / babystep (#16813)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c739abe26a..a4a457c0a7 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -402,6 +402,7 @@ constexpr uint32_t NS_TO_PULSE_TIMER_TICKS(uint32_t NS) { return (NS + (NS_PER_P
 #define PULSE_HIGH_TICK_COUNT hal_timer_t(NS_TO_PULSE_TIMER_TICKS(_MIN_PULSE_HIGH_NS - _MIN(_MIN_PULSE_HIGH_NS, TIMER_SETUP_NS)))
 #define PULSE_LOW_TICK_COUNT hal_timer_t(NS_TO_PULSE_TIMER_TICKS(_MIN_PULSE_LOW_NS - _MIN(_MIN_PULSE_LOW_NS, TIMER_SETUP_NS)))
 
+#define USING_TIMED_PULSE() hal_timer_t end_tick_count = 0
 #define START_TIMED_PULSE(DIR) (end_tick_count = HAL_timer_get_count(PULSE_TIMER_NUM) + PULSE_##DIR##_TICK_COUNT)
 #define AWAIT_TIMED_PULSE() while (HAL_timer_get_count(PULSE_TIMER_NUM) < end_tick_count) { }
 #define START_HIGH_PULSE()  START_TIMED_PULSE(HIGH)
@@ -409,6 +410,18 @@ constexpr uint32_t NS_TO_PULSE_TIMER_TICKS(uint32_t NS) { return (NS + (NS_PER_P
 #define AWAIT_HIGH_PULSE()  AWAIT_TIMED_PULSE()
 #define AWAIT_LOW_PULSE()   AWAIT_TIMED_PULSE()
 
+#if MINIMUM_STEPPER_PRE_DIR_DELAY > 0
+  #define DIR_WAIT_BEFORE() DELAY_NS(MINIMUM_STEPPER_PRE_DIR_DELAY)
+#else
+  #define DIR_WAIT_BEFORE()
+#endif
+
+#if MINIMUM_STEPPER_POST_DIR_DELAY > 0
+  #define DIR_WAIT_AFTER() DELAY_NS(MINIMUM_STEPPER_POST_DIR_DELAY)
+#else
+  #define DIR_WAIT_AFTER()
+#endif
+
 void Stepper::wake_up() {
   // TCNT1 = 0;
   ENABLE_STEPPER_DRIVER_INTERRUPT();
@@ -423,9 +436,7 @@ void Stepper::wake_up() {
  */
 void Stepper::set_directions() {
 
-  #if MINIMUM_STEPPER_PRE_DIR_DELAY > 0
-    DELAY_NS(MINIMUM_STEPPER_PRE_DIR_DELAY);
-  #endif
+  DIR_WAIT_BEFORE();
 
   #define SET_STEP_DIR(A)                       \
     if (motor_direction(_AXIS(A))) {            \
@@ -494,10 +505,7 @@ void Stepper::set_directions() {
     }
   #endif
 
-  // A small delay may be needed after changing direction
-  #if MINIMUM_STEPPER_POST_DIR_DELAY > 0
-    DELAY_NS(MINIMUM_STEPPER_POST_DIR_DELAY);
-  #endif
+  DIR_WAIT_AFTER();
 }
 
 #if ENABLED(S_CURVE_ACCELERATION)
@@ -1488,12 +1496,12 @@ void Stepper::stepper_pulse_phase_isr() {
   // Take multiple steps per interrupt (For high speed moves)
   #if ISR_MULTI_STEPS
     bool firstStep = true;
-    hal_timer_t end_tick_count = 0;
+    USING_TIMED_PULSE();
   #endif
   xyze_bool_t step_needed{0};
 
   do {
-    #define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP
+    #define _APPLY_STEP(AXIS, INV, ALWAYS) AXIS ##_APPLY_STEP(INV, ALWAYS)
     #define _INVERT_STEP_PIN(AXIS) INVERT_## AXIS ##_STEP_PIN
 
     // Determine if a pulse is needed using Bresenham
@@ -1509,14 +1517,14 @@ void Stepper::stepper_pulse_phase_isr() {
     // Start an active pulse, if Bresenham says so, and update position
     #define PULSE_START(AXIS) do{ \
       if (step_needed[_AXIS(AXIS)]) { \
-        _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), 0); \
+        _APPLY_STEP(AXIS, !_INVERT_STEP_PIN(AXIS), 0); \
       } \
     }while(0)
 
     // Stop an active pulse, if any, and adjust error term
     #define PULSE_STOP(AXIS) do { \
       if (step_needed[_AXIS(AXIS)]) { \
-        _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), 0); \
+        _APPLY_STEP(AXIS, _INVERT_STEP_PIN(AXIS), 0); \
       } \
     }while(0)
 
@@ -1978,9 +1986,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
     else
       interval = LA_ADV_NEVER;
 
-    #if MINIMUM_STEPPER_PRE_DIR_DELAY > 0
-      DELAY_NS(MINIMUM_STEPPER_PRE_DIR_DELAY);
-    #endif
+    DIR_WAIT_BEFORE();
 
     #if ENABLED(MIXING_EXTRUDER)
       // We don't know which steppers will be stepped because LA loop follows,
@@ -1996,17 +2002,14 @@ uint32_t Stepper::stepper_block_phase_isr() {
         REV_E_DIR(stepper_extruder);
     #endif
 
-    // A small delay may be needed after changing direction
-    #if MINIMUM_STEPPER_POST_DIR_DELAY > 0
-      DELAY_NS(MINIMUM_STEPPER_POST_DIR_DELAY);
-    #endif
+    DIR_WAIT_AFTER();
 
     //const hal_timer_t added_step_ticks = hal_timer_t(ADDED_STEP_TICKS);
 
     // Step E stepper if we have steps
     #if ISR_MULTI_STEPS
       bool firstStep = true;
-      hal_timer_t end_tick_count = 0;
+      USING_TIMED_PULSE();
     #endif
 
     while (LA_steps) {
@@ -2424,57 +2427,52 @@ void Stepper::report_positions() {
 
 #if ENABLED(BABYSTEPPING)
 
-  #if MINIMUM_STEPPER_PULSE
-    #define STEP_PULSE_CYCLES ((MINIMUM_STEPPER_PULSE) * CYCLES_PER_MICROSECOND)
-  #else
-    #define STEP_PULSE_CYCLES 0
-  #endif
-
-  #if ENABLED(DELTA)
-    #define CYCLES_EATEN_BABYSTEP (2 * 15)
-  #else
-    #define CYCLES_EATEN_BABYSTEP 0
-  #endif
-  #define EXTRA_CYCLES_BABYSTEP (STEP_PULSE_CYCLES - (CYCLES_EATEN_BABYSTEP))
-
   #define _ENABLE_AXIS(AXIS) ENABLE_AXIS_## AXIS()
   #define _READ_DIR(AXIS) AXIS ##_DIR_READ()
   #define _INVERT_DIR(AXIS) INVERT_## AXIS ##_DIR
   #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)
 
-  #if EXTRA_CYCLES_BABYSTEP > 20
-    #define _SAVE_START const hal_timer_t pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM)
-    #define _PULSE_WAIT while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
-  #else
-    #define _SAVE_START NOOP
-    #if EXTRA_CYCLES_BABYSTEP > 0
-      #define _PULSE_WAIT DELAY_NS(EXTRA_CYCLES_BABYSTEP * NANOSECONDS_PER_CYCLE)
-    #elif ENABLED(DELTA)
-      #define _PULSE_WAIT DELAY_US(2);
-    #elif STEP_PULSE_CYCLES > 0
-      #define _PULSE_WAIT NOOP
-    #else
-      #define _PULSE_WAIT DELAY_US(4);
-    #endif
-  #endif
-
-  #define BABYSTEP_AXIS(AXIS, INVERT, DIR) {            \
+  #if DISABLED(DELTA)
+    #define BABYSTEP_AXIS(AXIS, INV, DIR) do{           \
       const uint8_t old_dir = _READ_DIR(AXIS);          \
       _ENABLE_AXIS(AXIS);                               \
-      DELAY_NS(MINIMUM_STEPPER_PRE_DIR_DELAY);          \
-      _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^DIR^INVERT);   \
-      DELAY_NS(MINIMUM_STEPPER_POST_DIR_DELAY);         \
-      _SAVE_START;                                      \
-      _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), true); \
-      _PULSE_WAIT;                                      \
-      _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), true);  \
+      DIR_WAIT_BEFORE();                                \
+      _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^DIR^INV);      \
+      DIR_WAIT_AFTER();                                 \
+      USING_TIMED_PULSE();                              \
+      START_HIGH_PULSE();                               \
+      _APPLY_STEP(AXIS, !_INVERT_STEP_PIN(AXIS), true); \
+      AWAIT_HIGH_PULSE();                               \
+      _APPLY_STEP(AXIS,  _INVERT_STEP_PIN(AXIS), true); \
       _APPLY_DIR(AXIS, old_dir);                        \
-    }
+    }while(0)
+  #endif
+
+  #if IS_CORE
+    #define BABYSTEP_CORE(A, B, INV, DIR) do{     \
+      const xy_byte_t old_dir = { _READ_DIR(A), _READ_DIR(B) }; \
+      _ENABLE_AXIS(A); _ENABLE_AXIS(B);           \
+      DIR_WAIT_BEFORE();                          \
+      _APPLY_DIR(A, _INVERT_DIR(A)^DIR^INV);      \
+      _APPLY_DIR(B, _INVERT_DIR(B)^DIR^INV^(CORESIGN(1)<0)); \
+      DIR_WAIT_AFTER();                           \
+      USING_TIMED_PULSE();                        \
+      START_HIGH_PULSE();                         \
+      _APPLY_STEP(A, !_INVERT_STEP_PIN(A), true); \
+      _APPLY_STEP(B, !_INVERT_STEP_PIN(B), true); \
+      AWAIT_HIGH_PULSE();                         \
+      _APPLY_STEP(A,  _INVERT_STEP_PIN(A), true); \
+      _APPLY_STEP(B,  _INVERT_STEP_PIN(B), true); \
+      _APPLY_DIR(A, old_dir.a); _APPLY_DIR(B, old_dir.b); \
+    }while(0)
+  #endif
 
   // MUST ONLY BE CALLED BY AN ISR,
   // No other ISR should ever interrupt this!
   void Stepper::babystep(const AxisEnum axis, const bool direction) {
-    cli();
+    DISABLE_ISRS();
+
+    USING_TIMED_PULSE();
 
     switch (axis) {
 
@@ -2482,11 +2480,9 @@ void Stepper::report_positions() {
 
         case X_AXIS:
           #if CORE_IS_XY
-            BABYSTEP_AXIS(X, false, direction);
-            BABYSTEP_AXIS(Y, false, direction);
+            BABYSTEP_CORE(X, Y, false, direction);
           #elif CORE_IS_XZ
-            BABYSTEP_AXIS(X, false, direction);
-            BABYSTEP_AXIS(Z, false, direction);
+            BABYSTEP_CORE(X, Z, false, direction);
           #else
             BABYSTEP_AXIS(X, false, direction);
           #endif
@@ -2494,11 +2490,9 @@ void Stepper::report_positions() {
 
         case Y_AXIS:
           #if CORE_IS_XY
-            BABYSTEP_AXIS(X, false, direction);
-            BABYSTEP_AXIS(Y, false, direction^(CORESIGN(1)<0));
+            BABYSTEP_CORE(X, Y, false, direction);
           #elif CORE_IS_YZ
-            BABYSTEP_AXIS(Y, false, direction);
-            BABYSTEP_AXIS(Z, false, direction^(CORESIGN(1)<0));
+            BABYSTEP_CORE(Y, Z, false, direction);
           #else
             BABYSTEP_AXIS(Y, false, direction);
           #endif
@@ -2509,13 +2503,9 @@ void Stepper::report_positions() {
       case Z_AXIS: {
 
         #if CORE_IS_XZ
-          BABYSTEP_AXIS(X, BABYSTEP_INVERT_Z, direction);
-          BABYSTEP_AXIS(Z, BABYSTEP_INVERT_Z, direction^(CORESIGN(1)<0));
-
+          BABYSTEP_CORE(X, Z, BABYSTEP_INVERT_Z, direction);
         #elif CORE_IS_YZ
-          BABYSTEP_AXIS(Y, BABYSTEP_INVERT_Z, direction);
-          BABYSTEP_AXIS(Z, BABYSTEP_INVERT_Z, direction^(CORESIGN(1)<0));
-
+          BABYSTEP_CORE(Y, Z, BABYSTEP_INVERT_Z, direction);
         #elif DISABLED(DELTA)
           BABYSTEP_AXIS(Z, BABYSTEP_INVERT_Z, direction);
 
@@ -2527,38 +2517,32 @@ void Stepper::report_positions() {
           ENABLE_AXIS_Y();
           ENABLE_AXIS_Z();
 
-          #if MINIMUM_STEPPER_PRE_DIR_DELAY > 0
-            DELAY_NS(MINIMUM_STEPPER_PRE_DIR_DELAY);
-          #endif
+          DIR_WAIT_BEFORE();
 
-          const uint8_t old_x_dir_pin = X_DIR_READ(),
-                        old_y_dir_pin = Y_DIR_READ(),
-                        old_z_dir_pin = Z_DIR_READ();
+          const xyz_byte_t old_dir = { X_DIR_READ(), Y_DIR_READ(), Z_DIR_READ() };
 
           X_DIR_WRITE(INVERT_X_DIR ^ z_direction);
           Y_DIR_WRITE(INVERT_Y_DIR ^ z_direction);
           Z_DIR_WRITE(INVERT_Z_DIR ^ z_direction);
 
-          #if MINIMUM_STEPPER_POST_DIR_DELAY > 0
-            DELAY_NS(MINIMUM_STEPPER_POST_DIR_DELAY);
-          #endif
+          DIR_WAIT_AFTER();
 
-          _SAVE_START;
+          START_HIGH_PULSE();
 
           X_STEP_WRITE(!INVERT_X_STEP_PIN);
           Y_STEP_WRITE(!INVERT_Y_STEP_PIN);
           Z_STEP_WRITE(!INVERT_Z_STEP_PIN);
 
-          _PULSE_WAIT;
+          AWAIT_HIGH_PULSE();
 
           X_STEP_WRITE(INVERT_X_STEP_PIN);
           Y_STEP_WRITE(INVERT_Y_STEP_PIN);
           Z_STEP_WRITE(INVERT_Z_STEP_PIN);
 
           // Restore direction bits
-          X_DIR_WRITE(old_x_dir_pin);
-          Y_DIR_WRITE(old_y_dir_pin);
-          Z_DIR_WRITE(old_z_dir_pin);
+          X_DIR_WRITE(old_dir.x);
+          Y_DIR_WRITE(old_dir.y);
+          Z_DIR_WRITE(old_dir.z);
 
         #endif
 
@@ -2566,7 +2550,9 @@ void Stepper::report_positions() {
 
       default: break;
     }
-    sei();
+
+    START_LOW_PULSE(); AWAIT_LOW_PULSE();  // Prevent Stepper::ISR pulsing too soon
+    ENABLE_ISRS();                         // Now it's ok for the ISR to run
   }
 
 #endif // BABYSTEPPING

commit 894762259b072407504ee584103680b103310026
Author: Fabio Santos <fabiosan@live.com>
Date:   Sat Feb 8 19:01:57 2020 -0800

    Coolstep for TMC2130, 2209, 5130, 5160 (#16790)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index dcc13eca58..c739abe26a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1496,7 +1496,7 @@ void Stepper::stepper_pulse_phase_isr() {
     #define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP
     #define _INVERT_STEP_PIN(AXIS) INVERT_## AXIS ##_STEP_PIN
 
-    // Determine if pulses are needed
+    // Determine if a pulse is needed using Bresenham
     #define PULSE_PREP(AXIS) do{ \
       delta_error[_AXIS(AXIS)] += advance_dividend[_AXIS(AXIS)]; \
       step_needed[_AXIS(AXIS)] = (delta_error[_AXIS(AXIS)] >= 0); \

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 90848c99d1..dcc13eca58 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit 43d3463d5d612a300789bdc7a845eb2e8a37786d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 1 03:50:26 2020 -0600

    Misc cleanup, whitespace

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4e46ea56cd..90848c99d1 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2460,10 +2460,10 @@ void Stepper::report_positions() {
 
   #define BABYSTEP_AXIS(AXIS, INVERT, DIR) {            \
       const uint8_t old_dir = _READ_DIR(AXIS);          \
-      _ENABLE_AXIS(AXIS);                                    \
-      DELAY_NS(MINIMUM_STEPPER_PRE_DIR_DELAY);              \
+      _ENABLE_AXIS(AXIS);                               \
+      DELAY_NS(MINIMUM_STEPPER_PRE_DIR_DELAY);          \
       _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^DIR^INVERT);   \
-      DELAY_NS(MINIMUM_STEPPER_POST_DIR_DELAY);              \
+      DELAY_NS(MINIMUM_STEPPER_POST_DIR_DELAY);         \
       _SAVE_START;                                      \
       _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), true); \
       _PULSE_WAIT;                                      \

commit 50889c0f94778c378357bcc4d4a966fa869bc5c1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 30 03:24:23 2020 -0600

    Move L64XX index_to_axis to progmem (#16697)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 6e4977984f..4e46ea56cd 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1927,7 +1927,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
         // If delayed Z enable, enable it now. This option will severely interfere with
         // timing between pulses when chaining motion between blocks, and it could lead
         // to lost steps in both X and Y axis, so avoid using it unless strictly necessary!!
-        if (current_block->steps.z) enable_Z();
+        if (current_block->steps.z) ENABLE_AXIS_Z();
       #endif
 
       // Mark the time_nominal as not calculated yet
@@ -2215,12 +2215,12 @@ void Stepper::init() {
 
   #define _STEP_INIT(AXIS) AXIS ##_STEP_INIT()
   #define _WRITE_STEP(AXIS, HIGHLOW) AXIS ##_STEP_WRITE(HIGHLOW)
-  #define _DISABLE(AXIS) disable_## AXIS()
+  #define _DISABLE_AXIS(AXIS) DISABLE_AXIS_## AXIS()
 
   #define AXIS_INIT(AXIS, PIN) \
     _STEP_INIT(AXIS); \
     _WRITE_STEP(AXIS, _INVERT_STEP_PIN(PIN)); \
-    _DISABLE(AXIS)
+    _DISABLE_AXIS(AXIS)
 
   #define E_AXIS_INIT(NUM) AXIS_INIT(E## NUM, E)
 
@@ -2437,7 +2437,7 @@ void Stepper::report_positions() {
   #endif
   #define EXTRA_CYCLES_BABYSTEP (STEP_PULSE_CYCLES - (CYCLES_EATEN_BABYSTEP))
 
-  #define _ENABLE(AXIS) enable_## AXIS()
+  #define _ENABLE_AXIS(AXIS) ENABLE_AXIS_## AXIS()
   #define _READ_DIR(AXIS) AXIS ##_DIR_READ()
   #define _INVERT_DIR(AXIS) INVERT_## AXIS ##_DIR
   #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)
@@ -2460,7 +2460,7 @@ void Stepper::report_positions() {
 
   #define BABYSTEP_AXIS(AXIS, INVERT, DIR) {            \
       const uint8_t old_dir = _READ_DIR(AXIS);          \
-      _ENABLE(AXIS);                                    \
+      _ENABLE_AXIS(AXIS);                                    \
       DELAY_NS(MINIMUM_STEPPER_PRE_DIR_DELAY);              \
       _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^DIR^INVERT);   \
       DELAY_NS(MINIMUM_STEPPER_POST_DIR_DELAY);              \
@@ -2523,9 +2523,9 @@ void Stepper::report_positions() {
 
           const bool z_direction = direction ^ BABYSTEP_INVERT_Z;
 
-          enable_X();
-          enable_Y();
-          enable_Z();
+          ENABLE_AXIS_X();
+          ENABLE_AXIS_Y();
+          ENABLE_AXIS_Z();
 
           #if MINIMUM_STEPPER_PRE_DIR_DELAY > 0
             DELAY_NS(MINIMUM_STEPPER_PRE_DIR_DELAY);

commit 248b7dfa591a34a8aa1c6960944e1a3a468ad1de
Author: yangwenxiong <46896566+yangwenxiong@users.noreply.github.com>
Date:   Sat Jan 25 16:13:39 2020 +0800

    BigTreeTech GTR V1.0 / Support 8 extruders, heaters, temp sensors, fans (#16595)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index dec11245f5..6e4977984f 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2140,6 +2140,12 @@ void Stepper::init() {
   #if HAS_E5_DIR
     E5_DIR_INIT();
   #endif
+  #if HAS_E6_DIR
+    E6_DIR_INIT();
+  #endif
+  #if HAS_E7_DIR
+    E7_DIR_INIT();
+  #endif
 
   // Init Enable Pins - steppers default to disabled.
   #if HAS_X_ENABLE
@@ -2198,6 +2204,14 @@ void Stepper::init() {
     E5_ENABLE_INIT();
     if (!E_ENABLE_ON) E5_ENABLE_WRITE(HIGH);
   #endif
+  #if HAS_E6_ENABLE
+    E6_ENABLE_INIT();
+    if (!E_ENABLE_ON) E6_ENABLE_WRITE(HIGH);
+  #endif
+  #if HAS_E7_ENABLE
+    E7_ENABLE_INIT();
+    if (!E_ENABLE_ON) E7_ENABLE_WRITE(HIGH);
+  #endif
 
   #define _STEP_INIT(AXIS) AXIS ##_STEP_INIT()
   #define _WRITE_STEP(AXIS, HIGHLOW) AXIS ##_STEP_WRITE(HIGHLOW)
@@ -2261,6 +2275,12 @@ void Stepper::init() {
   #if E_STEPPERS > 5 && HAS_E5_STEP
     E_AXIS_INIT(5);
   #endif
+  #if E_STEPPERS > 6 && HAS_E6_STEP
+    E_AXIS_INIT(6);
+  #endif
+  #if E_STEPPERS > 7 && HAS_E7_STEP
+    E_AXIS_INIT(7);
+  #endif
 
   #if DISABLED(I2S_STEPPER_STREAM)
     HAL_timer_start(STEP_TIMER_NUM, 122); // Init Stepper ISR to 122 Hz for quick starting
@@ -2802,6 +2822,20 @@ void Stepper::report_positions() {
         SET_OUTPUT(E5_MS3_PIN);
       #endif
     #endif
+    #if HAS_E6_MICROSTEPS
+      SET_OUTPUT(E6_MS1_PIN);
+      SET_OUTPUT(E6_MS2_PIN);
+      #if PIN_EXISTS(E6_MS3)
+        SET_OUTPUT(E6_MS3_PIN);
+      #endif
+    #endif
+    #if HAS_E7_MICROSTEPS
+      SET_OUTPUT(E7_MS1_PIN);
+      SET_OUTPUT(E7_MS2_PIN);
+      #if PIN_EXISTS(E7_MS3)
+        SET_OUTPUT(E7_MS3_PIN);
+      #endif
+    #endif
 
     static const uint8_t microstep_modes[] = MICROSTEP_MODES;
     for (uint16_t i = 0; i < COUNT(microstep_modes); i++)
@@ -2847,22 +2881,28 @@ void Stepper::report_positions() {
           break;
       #endif
       #if HAS_E0_MICROSTEPS
-        case 3: WRITE(E0_MS1_PIN, ms1); break;
+        case  3: WRITE(E0_MS1_PIN, ms1); break;
       #endif
       #if HAS_E1_MICROSTEPS
-        case 4: WRITE(E1_MS1_PIN, ms1); break;
+        case  4: WRITE(E1_MS1_PIN, ms1); break;
       #endif
       #if HAS_E2_MICROSTEPS
-        case 5: WRITE(E2_MS1_PIN, ms1); break;
+        case  5: WRITE(E2_MS1_PIN, ms1); break;
       #endif
       #if HAS_E3_MICROSTEPS
-        case 6: WRITE(E3_MS1_PIN, ms1); break;
+        case  6: WRITE(E3_MS1_PIN, ms1); break;
       #endif
       #if HAS_E4_MICROSTEPS
-        case 7: WRITE(E4_MS1_PIN, ms1); break;
+        case  7: WRITE(E4_MS1_PIN, ms1); break;
       #endif
       #if HAS_E5_MICROSTEPS
-        case 8: WRITE(E5_MS1_PIN, ms1); break;
+        case  8: WRITE(E5_MS1_PIN, ms1); break;
+      #endif
+      #if HAS_E6_MICROSTEPS
+        case  9: WRITE(E6_MS1_PIN, ms1); break;
+      #endif
+      #if HAS_E7_MICROSTEPS
+        case 10: WRITE(E7_MS1_PIN, ms1); break;
       #endif
     }
     if (ms2 >= 0) switch (driver) {
@@ -2903,22 +2943,28 @@ void Stepper::report_positions() {
           break;
       #endif
       #if HAS_E0_MICROSTEPS
-        case 3: WRITE(E0_MS2_PIN, ms2); break;
+        case  3: WRITE(E0_MS2_PIN, ms2); break;
       #endif
       #if HAS_E1_MICROSTEPS
-        case 4: WRITE(E1_MS2_PIN, ms2); break;
+        case  4: WRITE(E1_MS2_PIN, ms2); break;
       #endif
       #if HAS_E2_MICROSTEPS
-        case 5: WRITE(E2_MS2_PIN, ms2); break;
+        case  5: WRITE(E2_MS2_PIN, ms2); break;
       #endif
       #if HAS_E3_MICROSTEPS
-        case 6: WRITE(E3_MS2_PIN, ms2); break;
+        case  6: WRITE(E3_MS2_PIN, ms2); break;
       #endif
       #if HAS_E4_MICROSTEPS
-        case 7: WRITE(E4_MS2_PIN, ms2); break;
+        case  7: WRITE(E4_MS2_PIN, ms2); break;
       #endif
       #if HAS_E5_MICROSTEPS
-        case 8: WRITE(E5_MS2_PIN, ms2); break;
+        case  8: WRITE(E5_MS2_PIN, ms2); break;
+      #endif
+      #if HAS_E6_MICROSTEPS
+        case  9: WRITE(E6_MS2_PIN, ms2); break;
+      #endif
+      #if HAS_E7_MICROSTEPS
+        case 10: WRITE(E7_MS2_PIN, ms2); break;
       #endif
     }
     if (ms3 >= 0) switch (driver) {
@@ -2959,22 +3005,28 @@ void Stepper::report_positions() {
           break;
       #endif
       #if HAS_E0_MICROSTEPS && PIN_EXISTS(E0_MS3)
-        case 3: WRITE(E0_MS3_PIN, ms3); break;
+        case  3: WRITE(E0_MS3_PIN, ms3); break;
       #endif
       #if HAS_E1_MICROSTEPS && PIN_EXISTS(E1_MS3)
-        case 4: WRITE(E1_MS3_PIN, ms3); break;
+        case  4: WRITE(E1_MS3_PIN, ms3); break;
       #endif
       #if HAS_E2_MICROSTEPS && PIN_EXISTS(E2_MS3)
-        case 5: WRITE(E2_MS3_PIN, ms3); break;
+        case  5: WRITE(E2_MS3_PIN, ms3); break;
       #endif
       #if HAS_E3_MICROSTEPS && PIN_EXISTS(E3_MS3)
-        case 6: WRITE(E3_MS3_PIN, ms3); break;
+        case  6: WRITE(E3_MS3_PIN, ms3); break;
       #endif
       #if HAS_E4_MICROSTEPS && PIN_EXISTS(E4_MS3)
-        case 7: WRITE(E4_MS3_PIN, ms3); break;
+        case  7: WRITE(E4_MS3_PIN, ms3); break;
       #endif
       #if HAS_E5_MICROSTEPS && PIN_EXISTS(E5_MS3)
-        case 8: WRITE(E5_MS3_PIN, ms3); break;
+        case  8: WRITE(E5_MS3_PIN, ms3); break;
+      #endif
+      #if HAS_E6_MICROSTEPS && PIN_EXISTS(E6_MS3)
+        case  9: WRITE(E6_MS3_PIN, ms3); break;
+      #endif
+      #if HAS_E7_MICROSTEPS && PIN_EXISTS(E7_MS3)
+        case 10: WRITE(E7_MS3_PIN, ms3); break;
       #endif
     }
   }
@@ -3084,6 +3136,22 @@ void Stepper::report_positions() {
         #endif
       );
     #endif
+    #if HAS_E6_MICROSTEPS
+      SERIAL_ECHOPGM("E6: ");
+      SERIAL_CHAR('0' + READ(E6_MS1_PIN), '0' + READ(E6_MS2_PIN)
+        #if PIN_EXISTS(E6_MS3)
+          , '0' + READ(E6_MS3_PIN)
+        #endif
+      );
+    #endif
+    #if HAS_E7_MICROSTEPS
+      SERIAL_ECHOPGM("E7: ");
+      SERIAL_CHAR('0' + READ(E7_MS1_PIN), '0' + READ(E7_MS2_PIN)
+        #if PIN_EXISTS(E7_MS3)
+          , '0' + READ(E7_MS3_PIN)
+        #endif
+      );
+    #endif
   }
 
 #endif // HAS_MICROSTEPS

commit 0fcf2b1110d9f0d362e5aab9cc73d963710e9865
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jan 20 00:35:07 2020 -0500

    Quad Z stepper support (#16277)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 5a19205697..dec11245f5 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -156,11 +156,16 @@ bool Stepper::abort_current_block;
 #if ENABLED(Y_DUAL_ENDSTOPS)
   bool Stepper::locked_Y_motor = false, Stepper::locked_Y2_motor = false;
 #endif
-#if Z_MULTI_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
-  bool Stepper::locked_Z_motor = false, Stepper::locked_Z2_motor = false;
-#endif
-#if ENABLED(Z_TRIPLE_ENDSTOPS) || BOTH(Z_STEPPER_AUTO_ALIGN, Z_TRIPLE_STEPPER_DRIVERS)
-  bool Stepper::locked_Z3_motor = false;
+
+#if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
+  bool Stepper::locked_Z_motor = false, Stepper::locked_Z2_motor = false
+       #if NUM_Z_STEPPER_DRIVERS >= 3
+         , Stepper::locked_Z3_motor = false
+         #if NUM_Z_STEPPER_DRIVERS >= 4
+           , Stepper::locked_Z4_motor = false
+         #endif
+       #endif
+       ;
 #endif
 
 uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
@@ -281,6 +286,42 @@ xyze_int8_t Stepper::count_direction{0};
     A##3_STEP_WRITE(V);                           \
   }
 
+#define QUAD_ENDSTOP_APPLY_STEP(A,V)                                                                                        \
+  if (separate_multi_axis) {                                                                                                \
+    if (A##_HOME_DIR < 0) {                                                                                                 \
+      if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
+      if (!(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
+      if (!(TEST(endstops.state(), A##3_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##3_motor) A##3_STEP_WRITE(V); \
+      if (!(TEST(endstops.state(), A##4_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##4_motor) A##4_STEP_WRITE(V); \
+    }                                                                                                                       \
+    else {                                                                                                                  \
+      if (!(TEST(endstops.state(), A##_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
+      if (!(TEST(endstops.state(), A##2_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
+      if (!(TEST(endstops.state(), A##3_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##3_motor) A##3_STEP_WRITE(V); \
+      if (!(TEST(endstops.state(), A##4_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##4_motor) A##4_STEP_WRITE(V); \
+    }                                                                                                                       \
+  }                                                                                                                         \
+  else {                                                                                                                    \
+    A##_STEP_WRITE(V);                                                                                                      \
+    A##2_STEP_WRITE(V);                                                                                                     \
+    A##3_STEP_WRITE(V);                                                                                                     \
+    A##4_STEP_WRITE(V);                                                                                                     \
+  }
+
+#define QUAD_SEPARATE_APPLY_STEP(A,V)             \
+  if (separate_multi_axis) {                      \
+    if (!locked_##A##_motor) A##_STEP_WRITE(V);   \
+    if (!locked_##A##2_motor) A##2_STEP_WRITE(V); \
+    if (!locked_##A##3_motor) A##3_STEP_WRITE(V); \
+    if (!locked_##A##4_motor) A##4_STEP_WRITE(V); \
+  }                                               \
+  else {                                          \
+    A##_STEP_WRITE(V);                            \
+    A##2_STEP_WRITE(V);                           \
+    A##3_STEP_WRITE(V);                           \
+    A##4_STEP_WRITE(V);                           \
+  }
+
 #if ENABLED(X_DUAL_STEPPER_DRIVERS)
   #define X_APPLY_DIR(v,Q) do{ X_DIR_WRITE(v); X2_DIR_WRITE((v) != INVERT_X2_VS_X_DIR); }while(0)
   #if ENABLED(X_DUAL_ENDSTOPS)
@@ -314,18 +355,27 @@ xyze_int8_t Stepper::count_direction{0};
   #define Y_APPLY_STEP(v,Q) Y_STEP_WRITE(v)
 #endif
 
-#if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+#if NUM_Z_STEPPER_DRIVERS == 4
+  #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(v); Z3_DIR_WRITE(v); Z4_DIR_WRITE(v); }while(0)
+  #if ENABLED(Z_MULTI_ENDSTOPS)
+    #define Z_APPLY_STEP(v,Q) QUAD_ENDSTOP_APPLY_STEP(Z,v)
+  #elif ENABLED(Z_STEPPER_AUTO_ALIGN)
+    #define Z_APPLY_STEP(v,Q) QUAD_SEPARATE_APPLY_STEP(Z,v)
+  #else
+    #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); Z3_STEP_WRITE(v); Z4_STEP_WRITE(v); }while(0)
+  #endif
+#elif NUM_Z_STEPPER_DRIVERS == 3
   #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(v); Z3_DIR_WRITE(v); }while(0)
-  #if ENABLED(Z_TRIPLE_ENDSTOPS)
+  #if ENABLED(Z_MULTI_ENDSTOPS)
     #define Z_APPLY_STEP(v,Q) TRIPLE_ENDSTOP_APPLY_STEP(Z,v)
   #elif ENABLED(Z_STEPPER_AUTO_ALIGN)
     #define Z_APPLY_STEP(v,Q) TRIPLE_SEPARATE_APPLY_STEP(Z,v)
   #else
     #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); Z3_STEP_WRITE(v); }while(0)
   #endif
-#elif ENABLED(Z_DUAL_STEPPER_DRIVERS)
+#elif NUM_Z_STEPPER_DRIVERS == 2
   #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(v); }while(0)
-  #if ENABLED(Z_DUAL_ENDSTOPS)
+  #if ENABLED(Z_MULTI_ENDSTOPS)
     #define Z_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Z,v)
   #elif ENABLED(Z_STEPPER_AUTO_ALIGN)
     #define Z_APPLY_STEP(v,Q) DUAL_SEPARATE_APPLY_STEP(Z,v)
@@ -2062,12 +2112,15 @@ void Stepper::init() {
   #endif
   #if HAS_Z_DIR
     Z_DIR_INIT();
-    #if Z_MULTI_STEPPER_DRIVERS && HAS_Z2_DIR
+    #if NUM_Z_STEPPER_DRIVERS >= 2 && HAS_Z2_DIR
       Z2_DIR_INIT();
     #endif
-    #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS) && HAS_Z3_DIR
+    #if NUM_Z_STEPPER_DRIVERS >= 3 && HAS_Z3_DIR
       Z3_DIR_INIT();
     #endif
+    #if NUM_Z_STEPPER_DRIVERS >= 4 && HAS_Z4_DIR
+      Z4_DIR_INIT();
+    #endif
   #endif
   #if HAS_E0_DIR
     E0_DIR_INIT();
@@ -2108,14 +2161,18 @@ void Stepper::init() {
   #if HAS_Z_ENABLE
     Z_ENABLE_INIT();
     if (!Z_ENABLE_ON) Z_ENABLE_WRITE(HIGH);
-    #if Z_MULTI_STEPPER_DRIVERS && HAS_Z2_ENABLE
+    #if NUM_Z_STEPPER_DRIVERS >= 2 && HAS_Z2_ENABLE
       Z2_ENABLE_INIT();
       if (!Z_ENABLE_ON) Z2_ENABLE_WRITE(HIGH);
     #endif
-    #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS) && HAS_Z3_ENABLE
+    #if NUM_Z_STEPPER_DRIVERS >= 3 && HAS_Z3_ENABLE
       Z3_ENABLE_INIT();
       if (!Z_ENABLE_ON) Z3_ENABLE_WRITE(HIGH);
     #endif
+    #if NUM_Z_STEPPER_DRIVERS >= 4 && HAS_Z4_ENABLE
+      Z4_ENABLE_INIT();
+      if (!Z_ENABLE_ON) Z4_ENABLE_WRITE(HIGH);
+    #endif
   #endif
   #if HAS_E0_ENABLE
     E0_ENABLE_INIT();
@@ -2171,14 +2228,18 @@ void Stepper::init() {
   #endif
 
   #if HAS_Z_STEP
-    #if Z_MULTI_STEPPER_DRIVERS
+    #if NUM_Z_STEPPER_DRIVERS >= 2
       Z2_STEP_INIT();
       Z2_STEP_WRITE(INVERT_Z_STEP_PIN);
     #endif
-    #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+    #if NUM_Z_STEPPER_DRIVERS >= 3
       Z3_STEP_INIT();
       Z3_STEP_WRITE(INVERT_Z_STEP_PIN);
     #endif
+    #if NUM_Z_STEPPER_DRIVERS >= 4
+      Z4_STEP_INIT();
+      Z4_STEP_WRITE(INVERT_Z_STEP_PIN);
+    #endif
     AXIS_INIT(Z, Z);
   #endif
 
@@ -2692,6 +2753,13 @@ void Stepper::report_positions() {
         SET_OUTPUT(Z3_MS3_PIN);
       #endif
     #endif
+    #if HAS_Z4_MICROSTEPS
+      SET_OUTPUT(Z4_MS1_PIN);
+      SET_OUTPUT(Z4_MS2_PIN);
+      #if PIN_EXISTS(Z4_MS3)
+        SET_OUTPUT(Z4_MS3_PIN);
+      #endif
+    #endif
     #if HAS_E0_MICROSTEPS
       SET_OUTPUT(E0_MS1_PIN);
       SET_OUTPUT(E0_MS2_PIN);
@@ -2762,7 +2830,7 @@ void Stepper::report_positions() {
           #endif
           break;
       #endif
-      #if HAS_Z_MICROSTEPS || HAS_Z2_MICROSTEPS || HAS_Z3_MICROSTEPS
+      #if HAS_SOME_Z_MICROSTEPS
         case 2:
           #if HAS_Z_MICROSTEPS
             WRITE(Z_MS1_PIN, ms1);
@@ -2773,6 +2841,9 @@ void Stepper::report_positions() {
           #if HAS_Z3_MICROSTEPS
             WRITE(Z3_MS1_PIN, ms1);
           #endif
+          #if HAS_Z4_MICROSTEPS
+            WRITE(Z4_MS1_PIN, ms1);
+          #endif
           break;
       #endif
       #if HAS_E0_MICROSTEPS
@@ -2815,7 +2886,7 @@ void Stepper::report_positions() {
           #endif
           break;
       #endif
-      #if HAS_Z_MICROSTEPS || HAS_Z2_MICROSTEPS || HAS_Z3_MICROSTEPS
+      #if HAS_SOME_Z_MICROSTEPS
         case 2:
           #if HAS_Z_MICROSTEPS
             WRITE(Z_MS2_PIN, ms2);
@@ -2826,6 +2897,9 @@ void Stepper::report_positions() {
           #if HAS_Z3_MICROSTEPS
             WRITE(Z3_MS2_PIN, ms2);
           #endif
+          #if HAS_Z4_MICROSTEPS
+            WRITE(Z4_MS2_PIN, ms2);
+          #endif
           break;
       #endif
       #if HAS_E0_MICROSTEPS
@@ -2868,7 +2942,7 @@ void Stepper::report_positions() {
           #endif
           break;
       #endif
-      #if HAS_Z_MICROSTEPS || HAS_Z2_MICROSTEPS || HAS_Z3_MICROSTEPS
+      #if HAS_SOME_Z_MICROSTEPS
         case 2:
           #if HAS_Z_MICROSTEPS && PIN_EXISTS(Z_MS3)
             WRITE(Z_MS3_PIN, ms3);
@@ -2879,6 +2953,9 @@ void Stepper::report_positions() {
           #if HAS_Z3_MICROSTEPS && PIN_EXISTS(Z3_MS3)
             WRITE(Z3_MS3_PIN, ms3);
           #endif
+          #if HAS_Z4_MICROSTEPS && PIN_EXISTS(Z4_MS3)
+            WRITE(Z4_MS3_PIN, ms3);
+          #endif
           break;
       #endif
       #if HAS_E0_MICROSTEPS && PIN_EXISTS(E0_MS3)

commit e9ae585647900866fbad7bfdd412ee22660429d2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jan 19 20:50:33 2020 -0600

    Patch for _STEP_INIT

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4fec3206e0..5a19205697 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2142,7 +2142,7 @@ void Stepper::init() {
     if (!E_ENABLE_ON) E5_ENABLE_WRITE(HIGH);
   #endif
 
-  #define _STEP_INIT(AXIS) AXIS ##_STEP_INIT
+  #define _STEP_INIT(AXIS) AXIS ##_STEP_INIT()
   #define _WRITE_STEP(AXIS, HIGHLOW) AXIS ##_STEP_WRITE(HIGHLOW)
   #define _DISABLE(AXIS) disable_## AXIS()
 

commit 37849969ad231a947e904d3578d13c93a630e88e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jan 19 20:01:22 2020 -0600

    Function-like macros

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 5d05e0d759..4fec3206e0 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2049,96 +2049,96 @@ void Stepper::init() {
 
   // Init Dir Pins
   #if HAS_X_DIR
-    X_DIR_INIT;
+    X_DIR_INIT();
   #endif
   #if HAS_X2_DIR
-    X2_DIR_INIT;
+    X2_DIR_INIT();
   #endif
   #if HAS_Y_DIR
-    Y_DIR_INIT;
+    Y_DIR_INIT();
     #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_DIR
-      Y2_DIR_INIT;
+      Y2_DIR_INIT();
     #endif
   #endif
   #if HAS_Z_DIR
-    Z_DIR_INIT;
+    Z_DIR_INIT();
     #if Z_MULTI_STEPPER_DRIVERS && HAS_Z2_DIR
-      Z2_DIR_INIT;
+      Z2_DIR_INIT();
     #endif
     #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS) && HAS_Z3_DIR
-      Z3_DIR_INIT;
+      Z3_DIR_INIT();
     #endif
   #endif
   #if HAS_E0_DIR
-    E0_DIR_INIT;
+    E0_DIR_INIT();
   #endif
   #if HAS_E1_DIR
-    E1_DIR_INIT;
+    E1_DIR_INIT();
   #endif
   #if HAS_E2_DIR
-    E2_DIR_INIT;
+    E2_DIR_INIT();
   #endif
   #if HAS_E3_DIR
-    E3_DIR_INIT;
+    E3_DIR_INIT();
   #endif
   #if HAS_E4_DIR
-    E4_DIR_INIT;
+    E4_DIR_INIT();
   #endif
   #if HAS_E5_DIR
-    E5_DIR_INIT;
+    E5_DIR_INIT();
   #endif
 
   // Init Enable Pins - steppers default to disabled.
   #if HAS_X_ENABLE
-    X_ENABLE_INIT;
+    X_ENABLE_INIT();
     if (!X_ENABLE_ON) X_ENABLE_WRITE(HIGH);
     #if EITHER(DUAL_X_CARRIAGE, X_DUAL_STEPPER_DRIVERS) && HAS_X2_ENABLE
-      X2_ENABLE_INIT;
+      X2_ENABLE_INIT();
       if (!X_ENABLE_ON) X2_ENABLE_WRITE(HIGH);
     #endif
   #endif
   #if HAS_Y_ENABLE
-    Y_ENABLE_INIT;
+    Y_ENABLE_INIT();
     if (!Y_ENABLE_ON) Y_ENABLE_WRITE(HIGH);
     #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_ENABLE
-      Y2_ENABLE_INIT;
+      Y2_ENABLE_INIT();
       if (!Y_ENABLE_ON) Y2_ENABLE_WRITE(HIGH);
     #endif
   #endif
   #if HAS_Z_ENABLE
-    Z_ENABLE_INIT;
+    Z_ENABLE_INIT();
     if (!Z_ENABLE_ON) Z_ENABLE_WRITE(HIGH);
     #if Z_MULTI_STEPPER_DRIVERS && HAS_Z2_ENABLE
-      Z2_ENABLE_INIT;
+      Z2_ENABLE_INIT();
       if (!Z_ENABLE_ON) Z2_ENABLE_WRITE(HIGH);
     #endif
     #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS) && HAS_Z3_ENABLE
-      Z3_ENABLE_INIT;
+      Z3_ENABLE_INIT();
       if (!Z_ENABLE_ON) Z3_ENABLE_WRITE(HIGH);
     #endif
   #endif
   #if HAS_E0_ENABLE
-    E0_ENABLE_INIT;
+    E0_ENABLE_INIT();
     if (!E_ENABLE_ON) E0_ENABLE_WRITE(HIGH);
   #endif
   #if HAS_E1_ENABLE
-    E1_ENABLE_INIT;
+    E1_ENABLE_INIT();
     if (!E_ENABLE_ON) E1_ENABLE_WRITE(HIGH);
   #endif
   #if HAS_E2_ENABLE
-    E2_ENABLE_INIT;
+    E2_ENABLE_INIT();
     if (!E_ENABLE_ON) E2_ENABLE_WRITE(HIGH);
   #endif
   #if HAS_E3_ENABLE
-    E3_ENABLE_INIT;
+    E3_ENABLE_INIT();
     if (!E_ENABLE_ON) E3_ENABLE_WRITE(HIGH);
   #endif
   #if HAS_E4_ENABLE
-    E4_ENABLE_INIT;
+    E4_ENABLE_INIT();
     if (!E_ENABLE_ON) E4_ENABLE_WRITE(HIGH);
   #endif
   #if HAS_E5_ENABLE
-    E5_ENABLE_INIT;
+    E5_ENABLE_INIT();
     if (!E_ENABLE_ON) E5_ENABLE_WRITE(HIGH);
   #endif
 
@@ -2156,7 +2156,7 @@ void Stepper::init() {
   // Init Step Pins
   #if HAS_X_STEP
     #if EITHER(X_DUAL_STEPPER_DRIVERS, DUAL_X_CARRIAGE)
-      X2_STEP_INIT;
+      X2_STEP_INIT();
       X2_STEP_WRITE(INVERT_X_STEP_PIN);
     #endif
     AXIS_INIT(X, X);
@@ -2164,7 +2164,7 @@ void Stepper::init() {
 
   #if HAS_Y_STEP
     #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-      Y2_STEP_INIT;
+      Y2_STEP_INIT();
       Y2_STEP_WRITE(INVERT_Y_STEP_PIN);
     #endif
     AXIS_INIT(Y, Y);
@@ -2172,11 +2172,11 @@ void Stepper::init() {
 
   #if HAS_Z_STEP
     #if Z_MULTI_STEPPER_DRIVERS
-      Z2_STEP_INIT;
+      Z2_STEP_INIT();
       Z2_STEP_WRITE(INVERT_Z_STEP_PIN);
     #endif
     #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
-      Z3_STEP_INIT;
+      Z3_STEP_INIT();
       Z3_STEP_WRITE(INVERT_Z_STEP_PIN);
     #endif
     AXIS_INIT(Z, Z);

commit 707349d492c2544d32af7287aca4ddbaf1473542
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jan 19 19:52:01 2020 -0600

    Updates for L64XX

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4aa2208b68..5d05e0d759 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -119,7 +119,7 @@ Stepper stepper; // Singleton
 
 #if HAS_L64XX
   #include "../libs/L64XX/L64XX_Marlin.h"
-  uint8_t L6470_buf[MAX_L6470 + 1];   // chip command sequence - element 0 not used
+  uint8_t L6470_buf[MAX_L64XX + 1];   // chip command sequence - element 0 not used
   bool L64XX_OK_to_power_up = false;  // flag to keep L64xx steppers powered down after a reset or power up
 #endif
 

commit 1ad53cee1f4e2768310fca98de0381df9c39b617
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Mon Jan 13 18:47:30 2020 -0600

    Improved STMicro L64XX stepper driver support (#16452)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 1ba473946a..4aa2208b68 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -117,8 +117,10 @@ Stepper stepper; // Singleton
   #include "../feature/runout.h"
 #endif
 
-#if HAS_DRIVER(L6470)
-  #include "../libs/L6470/L6470_Marlin.h"
+#if HAS_L64XX
+  #include "../libs/L64XX/L64XX_Marlin.h"
+  uint8_t L6470_buf[MAX_L6470 + 1];   // chip command sequence - element 0 not used
+  bool L64XX_OK_to_power_up = false;  // flag to keep L64xx steppers powered down after a reset or power up
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
@@ -371,21 +373,17 @@ void Stepper::wake_up() {
  */
 void Stepper::set_directions() {
 
-  #if HAS_DRIVER(L6470)
-    uint8_t L6470_buf[MAX_L6470 + 1];   // chip command sequence - element 0 not used
-  #endif
-
   #if MINIMUM_STEPPER_PRE_DIR_DELAY > 0
     DELAY_NS(MINIMUM_STEPPER_PRE_DIR_DELAY);
   #endif
 
   #define SET_STEP_DIR(A)                       \
     if (motor_direction(_AXIS(A))) {            \
-      A##_APPLY_DIR(INVERT_## A##_DIR, false);  \
+      A##_APPLY_DIR(INVERT_##A##_DIR, false);   \
       count_direction[_AXIS(A)] = -1;           \
     }                                           \
     else {                                      \
-      A##_APPLY_DIR(!INVERT_## A##_DIR, false); \
+      A##_APPLY_DIR(!INVERT_##A##_DIR, false);  \
       count_direction[_AXIS(A)] = 1;            \
     }
 
@@ -425,25 +423,25 @@ void Stepper::set_directions() {
     #endif
   #endif // !LIN_ADVANCE
 
-  #if HAS_DRIVER(L6470)
-
-    if (L6470.spi_active) {
-      L6470.spi_abort = true;                     // interrupted a SPI transfer - need to shut it down gracefully
-      for (uint8_t j = 1; j <= L6470::chain[0]; j++)
-        L6470_buf[j] = dSPIN_NOP;                 // fill buffer with NOOP commands
-      L6470.transfer(L6470_buf, L6470::chain[0]);  // send enough NOOPs to complete any command
-      L6470.transfer(L6470_buf, L6470::chain[0]);
-      L6470.transfer(L6470_buf, L6470::chain[0]);
-    }
-
-    // The L6470.dir_commands[] array holds the direction command for each stepper
+  #if HAS_L64XX
+    if (L64XX_OK_to_power_up) { // OK to send the direction commands (which powers up the L64XX steppers)
+      if (L64xxManager.spi_active) {
+        L64xxManager.spi_abort = true;                    // Interrupted SPI transfer needs to shut down gracefully
+        for (uint8_t j = 1; j <= L64XX::chain[0]; j++)
+          L6470_buf[j] = dSPIN_NOP;                         // Fill buffer with NOOPs
+        L64xxManager.transfer(L6470_buf, L64XX::chain[0]);  // Send enough NOOPs to complete any command
+        L64xxManager.transfer(L6470_buf, L64XX::chain[0]);
+        L64xxManager.transfer(L6470_buf, L64XX::chain[0]);
+      }
 
-    //scan command array and copy matches into L6470.transfer
-    for (uint8_t j = 1; j <= L6470::chain[0]; j++)
-      L6470_buf[j] = L6470.dir_commands[L6470::chain[j]];
+      // L64xxManager.dir_commands[] is an array that holds direction command for each stepper
 
-    L6470.transfer(L6470_buf, L6470::chain[0]);  // send the command stream to the drivers
+      // Scan command array, copy matches into L64xxManager.transfer
+      for (uint8_t j = 1; j <= L64XX::chain[0]; j++)
+        L6470_buf[j] = L64xxManager.dir_commands[L64XX::chain[j]];
 
+      L64xxManager.transfer(L6470_buf, L64XX::chain[0]);  // send the command stream to the drivers
+    }
   #endif
 
   // A small delay may be needed after changing direction
@@ -1846,8 +1844,8 @@ uint32_t Stepper::stepper_block_phase_isr() {
       #endif
 
       if (
-        #if HAS_DRIVER(L6470)
-          true  // Always set direction for L6470 (This also enables the chips)
+        #if HAS_L64XX
+          true  // Always set direction for L64xx (This also enables the chips)
         #else
           current_block->direction_bits != last_direction_bits
           #if DISABLED(MIXING_EXTRUDER)
@@ -1859,6 +1857,10 @@ uint32_t Stepper::stepper_block_phase_isr() {
         #if EXTRUDERS > 1
           last_moved_extruder = stepper_extruder;
         #endif
+
+        #if HAS_L64XX
+          L64XX_OK_to_power_up = true;
+        #endif
         set_directions();
       }
 

commit 6e658a7c045acc80f92c99551d81c850d8c05723
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jan 8 20:00:06 2020 -0600

    Code style and comment tweaks

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 2bf091ab52..1ba473946a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1492,7 +1492,7 @@ void Stepper::stepper_pulse_phase_isr() {
           // Don't step E here - But remember the number of steps to perform
           motor_direction(E_AXIS) ? --LA_steps : ++LA_steps;
         #else
-          step_needed[E_AXIS] = delta_error.e >= 0;
+          step_needed.e = delta_error.e >= 0;
         #endif
       }
     #elif HAS_E0_STEP
@@ -1519,7 +1519,7 @@ void Stepper::stepper_pulse_phase_isr() {
 
     #if DISABLED(LIN_ADVANCE)
       #if ENABLED(MIXING_EXTRUDER)
-        if (step_needed[E_AXIS]) E_STEP_WRITE(mixer.get_next_stepper(), !INVERT_E_STEP_PIN);
+        if (step_needed.e) E_STEP_WRITE(mixer.get_next_stepper(), !INVERT_E_STEP_PIN);
       #elif HAS_E0_STEP
         PULSE_START(E);
       #endif

commit 95046c90478c14d2c43bd41d30c4170dcbcdf53a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jan 8 18:31:57 2020 -0600

    Extend SERIAL_CHAR to take multiple arguments

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index f1aa52b1ca..2bf091ab52 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2932,77 +2932,78 @@ void Stepper::report_positions() {
   }
 
   void Stepper::microstep_readings() {
-    SERIAL_ECHOPGM("MS1,MS2,MS3 Pins\nX: ");
+    SERIAL_ECHOLNPGM("MS1|MS2|MS3 Pins");
     #if HAS_X_MICROSTEPS
-      SERIAL_CHAR('0' + READ(X_MS1_PIN));
-      SERIAL_CHAR('0' + READ(X_MS2_PIN));
-      #if PIN_EXISTS(X_MS3)
-        SERIAL_ECHOLN((int)READ(X_MS3_PIN));
-      #endif
+      SERIAL_ECHOPGM("X: ");
+      SERIAL_CHAR('0' + READ(X_MS1_PIN), '0' + READ(X_MS2_PIN)
+        #if PIN_EXISTS(X_MS3)
+          , '0' + READ(X_MS3_PIN)
+        #endif
+      );
     #endif
     #if HAS_Y_MICROSTEPS
       SERIAL_ECHOPGM("Y: ");
-      SERIAL_CHAR('0' + READ(Y_MS1_PIN));
-      SERIAL_CHAR('0' + READ(Y_MS2_PIN));
-      #if PIN_EXISTS(Y_MS3)
-        SERIAL_ECHOLN((int)READ(Y_MS3_PIN));
-      #endif
+      SERIAL_CHAR('0' + READ(Y_MS1_PIN), '0' + READ(Y_MS2_PIN)
+        #if PIN_EXISTS(Y_MS3)
+          , '0' + READ(Y_MS3_PIN)
+        #endif
+      );
     #endif
     #if HAS_Z_MICROSTEPS
       SERIAL_ECHOPGM("Z: ");
-      SERIAL_CHAR('0' + READ(Z_MS1_PIN));
-      SERIAL_CHAR('0' + READ(Z_MS2_PIN));
-      #if PIN_EXISTS(Z_MS3)
-        SERIAL_ECHOLN((int)READ(Z_MS3_PIN));
-      #endif
+      SERIAL_CHAR('0' + READ(Z_MS1_PIN), '0' + READ(Z_MS2_PIN)
+        #if PIN_EXISTS(Z_MS3)
+          , '0' + READ(Z_MS3_PIN)
+        #endif
+      );
     #endif
     #if HAS_E0_MICROSTEPS
       SERIAL_ECHOPGM("E0: ");
-      SERIAL_CHAR('0' + READ(E0_MS1_PIN));
-      SERIAL_CHAR('0' + READ(E0_MS2_PIN));
-      #if PIN_EXISTS(E0_MS3)
-        SERIAL_ECHOLN((int)READ(E0_MS3_PIN));
-      #endif
+      SERIAL_CHAR('0' + READ(E0_MS1_PIN), '0' + READ(E0_MS2_PIN)
+        #if PIN_EXISTS(E0_MS3)
+          , '0' + READ(E0_MS3_PIN)
+        #endif
+      );
     #endif
     #if HAS_E1_MICROSTEPS
       SERIAL_ECHOPGM("E1: ");
-      SERIAL_CHAR('0' + READ(E1_MS1_PIN));
-      SERIAL_CHAR('0' + READ(E1_MS2_PIN));
-      #if PIN_EXISTS(E1_MS3)
-        SERIAL_ECHOLN((int)READ(E1_MS3_PIN));
-      #endif
+      SERIAL_CHAR('0' + READ(E1_MS1_PIN), '0' + READ(E1_MS2_PIN)
+        #if PIN_EXISTS(E1_MS3)
+          , '0' + READ(E1_MS3_PIN)
+        #endif
+      );
     #endif
     #if HAS_E2_MICROSTEPS
       SERIAL_ECHOPGM("E2: ");
-      SERIAL_CHAR('0' + READ(E2_MS1_PIN));
-      SERIAL_CHAR('0' + READ(E2_MS2_PIN));
-      #if PIN_EXISTS(E2_MS3)
-        SERIAL_ECHOLN((int)READ(E2_MS3_PIN));
-      #endif
+      SERIAL_CHAR('0' + READ(E2_MS1_PIN), '0' + READ(E2_MS2_PIN)
+        #if PIN_EXISTS(E2_MS3)
+          , '0' + READ(E2_MS3_PIN)
+        #endif
+      );
     #endif
     #if HAS_E3_MICROSTEPS
       SERIAL_ECHOPGM("E3: ");
-      SERIAL_CHAR('0' + READ(E3_MS1_PIN));
-      SERIAL_CHAR('0' + READ(E3_MS2_PIN));
-      #if PIN_EXISTS(E3_MS3)
-        SERIAL_ECHOLN((int)READ(E3_MS3_PIN));
-      #endif
+      SERIAL_CHAR('0' + READ(E3_MS1_PIN), '0' + READ(E3_MS2_PIN)
+        #if PIN_EXISTS(E3_MS3)
+          , '0' + READ(E3_MS3_PIN)
+        #endif
+      );
     #endif
     #if HAS_E4_MICROSTEPS
       SERIAL_ECHOPGM("E4: ");
-      SERIAL_CHAR('0' + READ(E4_MS1_PIN));
-      SERIAL_CHAR('0' + READ(E4_MS2_PIN));
-      #if PIN_EXISTS(E4_MS3)
-        SERIAL_ECHOLN((int)READ(E4_MS3_PIN));
-      #endif
+      SERIAL_CHAR('0' + READ(E4_MS1_PIN), '0' + READ(E4_MS2_PIN)
+        #if PIN_EXISTS(E4_MS3)
+          , '0' + READ(E4_MS3_PIN)
+        #endif
+      );
     #endif
     #if HAS_E5_MICROSTEPS
       SERIAL_ECHOPGM("E5: ");
-      SERIAL_CHAR('0' + READ(E5_MS1_PIN));
-      SERIAL_ECHOLN((int)READ(E5_MS2_PIN));
-      #if PIN_EXISTS(E5_MS3)
-        SERIAL_ECHOLN((int)READ(E5_MS3_PIN));
-      #endif
+      SERIAL_CHAR('0' + READ(E5_MS1_PIN), '0' + READ(E5_MS2_PIN)
+        #if PIN_EXISTS(E5_MS3)
+          , '0' + READ(E5_MS3_PIN)
+        #endif
+      );
     #endif
   }
 

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 31bda4c517..f1aa52b1ca 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -98,7 +98,7 @@ Stepper stepper; // Singleton
 #include "../core/language.h"
 #include "../gcode/queue.h"
 #include "../sd/cardreader.h"
-#include "../Marlin.h"
+#include "../MarlinCore.h"
 #include "../HAL/shared/Delay.h"
 
 #if MB(ALLIGATOR)

commit 9ff2d34bf8f858f1fbf48475e753aa0c72ee4690
Author: Jason Smith <jason.inet@gmail.com>
Date:   Wed Jan 1 20:06:50 2020 -0800

    Fix warnings in stepper.cpp (#16364)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c651a24d30..31bda4c517 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1405,6 +1405,9 @@ void Stepper::isr() {
   ENABLE_ISRS();
 }
 
+#define ISR_PULSE_CONTROL (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE)
+#define ISR_MULTI_STEPS (ISR_PULSE_CONTROL && DISABLED(I2S_STEPPER_STREAM))
+
 /**
  * This phase of the ISR should ONLY create the pulses for the steppers.
  * This prevents jitter caused by the interval between the start of the
@@ -1435,9 +1438,11 @@ void Stepper::stepper_pulse_phase_isr() {
   step_events_completed += events_to_do;
 
   // Take multiple steps per interrupt (For high speed moves)
-  bool firstStep = true;
+  #if ISR_MULTI_STEPS
+    bool firstStep = true;
+    hal_timer_t end_tick_count = 0;
+  #endif
   xyze_bool_t step_needed{0};
-  hal_timer_t end_tick_count = 0;
 
   do {
     #define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP
@@ -1494,7 +1499,7 @@ void Stepper::stepper_pulse_phase_isr() {
       PULSE_PREP(E);
     #endif
 
-    #if (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE) && DISABLED(I2S_STEPPER_STREAM)
+    #if ISR_MULTI_STEPS
       if (firstStep)
         firstStep = false;
       else
@@ -1525,7 +1530,7 @@ void Stepper::stepper_pulse_phase_isr() {
     #endif
 
     // TODO: need to deal with MINIMUM_STEPPER_PULSE over i2s
-    #if (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE) && DISABLED(I2S_STEPPER_STREAM)
+    #if ISR_MULTI_STEPS
       START_HIGH_PULSE();
       AWAIT_HIGH_PULSE();
     #endif
@@ -1558,7 +1563,7 @@ void Stepper::stepper_pulse_phase_isr() {
       #endif  // !MIXING_EXTRUDER
     #endif // !LIN_ADVANCE
 
-    #if (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE) && DISABLED(I2S_STEPPER_STREAM)
+    #if ISR_MULTI_STEPS
       if (events_to_do) START_LOW_PULSE();
     #endif
 
@@ -1947,11 +1952,13 @@ uint32_t Stepper::stepper_block_phase_isr() {
     //const hal_timer_t added_step_ticks = hal_timer_t(ADDED_STEP_TICKS);
 
     // Step E stepper if we have steps
-    bool firstStep = true;
-    hal_timer_t end_tick_count = 0;
+    #if ISR_MULTI_STEPS
+      bool firstStep = true;
+      hal_timer_t end_tick_count = 0;
+    #endif
 
     while (LA_steps) {
-      #if (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE) && DISABLED(I2S_STEPPER_STREAM)
+      #if ISR_MULTI_STEPS
         if (firstStep)
           firstStep = false;
         else
@@ -1966,13 +1973,13 @@ uint32_t Stepper::stepper_block_phase_isr() {
       #endif
 
       // Enforce a minimum duration for STEP pulse ON
-      #if (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE)
+      #if ISR_PULSE_CONTROL
         START_HIGH_PULSE();
       #endif
 
       LA_steps < 0 ? ++LA_steps : --LA_steps;
 
-      #if (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE)
+      #if ISR_PULSE_CONTROL
         AWAIT_HIGH_PULSE();
       #endif
 
@@ -1985,7 +1992,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
 
       // For minimum pulse time wait before looping
       // Just wait for the requested pulse duration
-      #if (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE)
+      #if ISR_PULSE_CONTROL
         if (LA_steps) START_LOW_PULSE();
       #endif
     } // LA_steps

commit 24eaf2d7e0bad4ad3a11f1835ed60c031b0d521c
Author: Luc <8822552+luc-github@users.noreply.github.com>
Date:   Sun Dec 22 23:11:17 2019 +0100

    Some ESP32 patches (#16297)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 51c4e98244..c651a24d30 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2276,7 +2276,7 @@ void Stepper::endstop_triggered(const AxisEnum axis) {
       (axis == CORE_AXIS_2
         ? CORESIGN(count_position[CORE_AXIS_1] - count_position[CORE_AXIS_2])
         : count_position[CORE_AXIS_1] + count_position[CORE_AXIS_2]
-      ) * 0.5f
+      ) * double(0.5)
     #else // !IS_CORE
       count_position[axis]
     #endif

commit d5bc5547eeaff6dd179b4695526897174119ecc9
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sat Dec 21 16:36:25 2019 -0800

    Step timing cleanup and rounding fix (#16258)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 9babb13707..51c4e98244 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -338,6 +338,13 @@ xyze_int8_t Stepper::count_direction{0};
 #if DISABLED(MIXING_EXTRUDER)
   #define E_APPLY_STEP(v,Q) E_STEP_WRITE(stepper_extruder, v)
 #endif
+
+#define CYCLES_TO_NS(CYC) (1000UL * (CYC) / ((F_CPU) / 1000000))
+constexpr uint32_t NS_PER_PULSE_TIMER_TICK = 1000000000UL / (STEPPER_TIMER_RATE);
+
+// Round up when converting from ns to timer ticks
+constexpr uint32_t NS_TO_PULSE_TIMER_TICKS(uint32_t NS) { return (NS + (NS_PER_PULSE_TIMER_TICK) / 2) / (NS_PER_PULSE_TIMER_TICK); }
+
 #define TIMER_SETUP_NS (CYCLES_TO_NS(TIMER_READ_ADD_AND_STORE_CYCLES))
 
 #define PULSE_HIGH_TICK_COUNT hal_timer_t(NS_TO_PULSE_TIMER_TICKS(_MIN_PULSE_HIGH_NS - _MIN(_MIN_PULSE_HIGH_NS, TIMER_SETUP_NS)))
@@ -1430,7 +1437,7 @@ void Stepper::stepper_pulse_phase_isr() {
   // Take multiple steps per interrupt (For high speed moves)
   bool firstStep = true;
   xyze_bool_t step_needed{0};
-  hal_timer_t end_tick_count;
+  hal_timer_t end_tick_count = 0;
 
   do {
     #define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP
@@ -1941,7 +1948,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
 
     // Step E stepper if we have steps
     bool firstStep = true;
-    hal_timer_t end_tick_count;
+    hal_timer_t end_tick_count = 0;
 
     while (LA_steps) {
       #if (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE) && DISABLED(I2S_STEPPER_STREAM)

commit 1bad8f1b172d8074272e5bae78a356e3671f7b50
Author: Jason Smith <jason.inet@gmail.com>
Date:   Thu Dec 19 00:38:48 2019 -0800

    Improve pulse timing and step reliability (#16128)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index f59b7a42a3..9babb13707 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -338,6 +338,17 @@ xyze_int8_t Stepper::count_direction{0};
 #if DISABLED(MIXING_EXTRUDER)
   #define E_APPLY_STEP(v,Q) E_STEP_WRITE(stepper_extruder, v)
 #endif
+#define TIMER_SETUP_NS (CYCLES_TO_NS(TIMER_READ_ADD_AND_STORE_CYCLES))
+
+#define PULSE_HIGH_TICK_COUNT hal_timer_t(NS_TO_PULSE_TIMER_TICKS(_MIN_PULSE_HIGH_NS - _MIN(_MIN_PULSE_HIGH_NS, TIMER_SETUP_NS)))
+#define PULSE_LOW_TICK_COUNT hal_timer_t(NS_TO_PULSE_TIMER_TICKS(_MIN_PULSE_LOW_NS - _MIN(_MIN_PULSE_LOW_NS, TIMER_SETUP_NS)))
+
+#define START_TIMED_PULSE(DIR) (end_tick_count = HAL_timer_get_count(PULSE_TIMER_NUM) + PULSE_##DIR##_TICK_COUNT)
+#define AWAIT_TIMED_PULSE() while (HAL_timer_get_count(PULSE_TIMER_NUM) < end_tick_count) { }
+#define START_HIGH_PULSE()  START_TIMED_PULSE(HIGH)
+#define START_LOW_PULSE()   START_TIMED_PULSE(LOW)
+#define AWAIT_HIGH_PULSE()  AWAIT_TIMED_PULSE()
+#define AWAIT_LOW_PULSE()   AWAIT_TIMED_PULSE()
 
 void Stepper::wake_up() {
   // TCNT1 = 0;
@@ -1416,47 +1427,50 @@ void Stepper::stepper_pulse_phase_isr() {
   // Just update the value we will get at the end of the loop
   step_events_completed += events_to_do;
 
-  // Get the timer count and estimate the end of the pulse
-  hal_timer_t pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t(MIN_PULSE_TICKS);
-
-  const hal_timer_t added_step_ticks = hal_timer_t(ADDED_STEP_TICKS);
-
   // Take multiple steps per interrupt (For high speed moves)
-  do {
+  bool firstStep = true;
+  xyze_bool_t step_needed{0};
+  hal_timer_t end_tick_count;
 
+  do {
     #define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP
     #define _INVERT_STEP_PIN(AXIS) INVERT_## AXIS ##_STEP_PIN
 
+    // Determine if pulses are needed
+    #define PULSE_PREP(AXIS) do{ \
+      delta_error[_AXIS(AXIS)] += advance_dividend[_AXIS(AXIS)]; \
+      step_needed[_AXIS(AXIS)] = (delta_error[_AXIS(AXIS)] >= 0); \
+      if (step_needed[_AXIS(AXIS)]) { \
+        count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \
+        delta_error[_AXIS(AXIS)] -= advance_divisor; \
+      } \
+    }while(0)
+
     // Start an active pulse, if Bresenham says so, and update position
     #define PULSE_START(AXIS) do{ \
-      delta_error[_AXIS(AXIS)] += advance_dividend[_AXIS(AXIS)]; \
-      if (delta_error[_AXIS(AXIS)] >= 0) { \
+      if (step_needed[_AXIS(AXIS)]) { \
         _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), 0); \
-        count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \
       } \
     }while(0)
 
     // Stop an active pulse, if any, and adjust error term
     #define PULSE_STOP(AXIS) do { \
-      if (delta_error[_AXIS(AXIS)] >= 0) { \
-        delta_error[_AXIS(AXIS)] -= advance_divisor; \
+      if (step_needed[_AXIS(AXIS)]) { \
         _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), 0); \
       } \
     }while(0)
 
-    // Pulse start
+    // Determine if pulses are needed
     #if HAS_X_STEP
-      PULSE_START(X);
+      PULSE_PREP(X);
     #endif
     #if HAS_Y_STEP
-      PULSE_START(Y);
+      PULSE_PREP(Y);
     #endif
     #if HAS_Z_STEP
-      PULSE_START(Z);
+      PULSE_PREP(Z);
     #endif
 
-    // Pulse Extruders
-    // Tick the E axis, correct error term and update position
     #if EITHER(LIN_ADVANCE, MIXING_EXTRUDER)
       delta_error.e += advance_dividend.e;
       if (delta_error.e >= 0) {
@@ -1465,14 +1479,36 @@ void Stepper::stepper_pulse_phase_isr() {
           delta_error.e -= advance_divisor;
           // Don't step E here - But remember the number of steps to perform
           motor_direction(E_AXIS) ? --LA_steps : ++LA_steps;
-        #else // !LIN_ADVANCE && MIXING_EXTRUDER
-          // Don't adjust delta_error.e here!
-          // Being positive is the criteria for ending the pulse.
-          E_STEP_WRITE(mixer.get_next_stepper(), !INVERT_E_STEP_PIN);
+        #else
+          step_needed[E_AXIS] = delta_error.e >= 0;
         #endif
       }
-    #else // !LIN_ADVANCE && !MIXING_EXTRUDER
-      #if HAS_E0_STEP
+    #elif HAS_E0_STEP
+      PULSE_PREP(E);
+    #endif
+
+    #if (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE) && DISABLED(I2S_STEPPER_STREAM)
+      if (firstStep)
+        firstStep = false;
+      else
+        AWAIT_LOW_PULSE();
+    #endif
+
+    // Pulse start
+    #if HAS_X_STEP
+      PULSE_START(X);
+    #endif
+    #if HAS_Y_STEP
+      PULSE_START(Y);
+    #endif
+    #if HAS_Z_STEP
+      PULSE_START(Z);
+    #endif
+
+    #if DISABLED(LIN_ADVANCE)
+      #if ENABLED(MIXING_EXTRUDER)
+        if (step_needed[E_AXIS]) E_STEP_WRITE(mixer.get_next_stepper(), !INVERT_E_STEP_PIN);
+      #elif HAS_E0_STEP
         PULSE_START(E);
       #endif
     #endif
@@ -1482,14 +1518,11 @@ void Stepper::stepper_pulse_phase_isr() {
     #endif
 
     // TODO: need to deal with MINIMUM_STEPPER_PULSE over i2s
-    #if MINIMUM_STEPPER_PULSE && DISABLED(I2S_STEPPER_STREAM)
-      // Just wait for the requested pulse duration
-      while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
+    #if (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE) && DISABLED(I2S_STEPPER_STREAM)
+      START_HIGH_PULSE();
+      AWAIT_HIGH_PULSE();
     #endif
 
-    // Add the delay needed to ensure the maximum driver rate is enforced
-    if (signed(added_step_ticks) > 0) pulse_end += hal_timer_t(added_step_ticks);
-
     // Pulse stop
     #if HAS_X_STEP
       PULSE_STOP(X);
@@ -1503,31 +1536,26 @@ void Stepper::stepper_pulse_phase_isr() {
 
     #if DISABLED(LIN_ADVANCE)
       #if ENABLED(MIXING_EXTRUDER)
+
         if (delta_error.e >= 0) {
           delta_error.e -= advance_divisor;
           E_STEP_WRITE(mixer.get_stepper(), INVERT_E_STEP_PIN);
         }
+
       #else // !MIXING_EXTRUDER
+
         #if HAS_E0_STEP
           PULSE_STOP(E);
         #endif
-      #endif
-    #endif // !LIN_ADVANCE
 
-    // Decrement the count of pending pulses to do
-    --events_to_do;
+      #endif  // !MIXING_EXTRUDER
+    #endif // !LIN_ADVANCE
 
-    // For minimum pulse time wait after stopping pulses also
-    if (events_to_do) {
-      // Just wait for the requested pulse duration
-      while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
-      #if MINIMUM_STEPPER_PULSE
-        // Add to the value, the time that the pulse must be active (to be used on the next loop)
-        pulse_end += hal_timer_t(MIN_PULSE_TICKS);
-      #endif
-    }
+    #if (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE) && DISABLED(I2S_STEPPER_STREAM)
+      if (events_to_do) START_LOW_PULSE();
+    #endif
 
-  } while (events_to_do);
+  } while (--events_to_do);
 }
 
 // This is the last half of the stepper interrupt: This one processes and
@@ -1909,13 +1937,19 @@ uint32_t Stepper::stepper_block_phase_isr() {
       DELAY_NS(MINIMUM_STEPPER_POST_DIR_DELAY);
     #endif
 
-    // Get the timer count and estimate the end of the pulse
-    hal_timer_t pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t(MIN_PULSE_TICKS);
-
-    const hal_timer_t added_step_ticks = hal_timer_t(ADDED_STEP_TICKS);
+    //const hal_timer_t added_step_ticks = hal_timer_t(ADDED_STEP_TICKS);
 
     // Step E stepper if we have steps
+    bool firstStep = true;
+    hal_timer_t end_tick_count;
+
     while (LA_steps) {
+      #if (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE) && DISABLED(I2S_STEPPER_STREAM)
+        if (firstStep)
+          firstStep = false;
+        else
+          AWAIT_LOW_PULSE();
+      #endif
 
       // Set the STEP pulse ON
       #if ENABLED(MIXING_EXTRUDER)
@@ -1925,16 +1959,16 @@ uint32_t Stepper::stepper_block_phase_isr() {
       #endif
 
       // Enforce a minimum duration for STEP pulse ON
-      #if MINIMUM_STEPPER_PULSE
-        // Just wait for the requested pulse duration
-        while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
+      #if (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE)
+        START_HIGH_PULSE();
       #endif
 
-      // Add the delay needed to ensure the maximum driver rate is enforced
-      if (signed(added_step_ticks) > 0) pulse_end += hal_timer_t(added_step_ticks);
-
       LA_steps < 0 ? ++LA_steps : --LA_steps;
 
+      #if (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE)
+        AWAIT_HIGH_PULSE();
+      #endif
+
       // Set the STEP pulse OFF
       #if ENABLED(MIXING_EXTRUDER)
         E_STEP_WRITE(mixer.get_stepper(), INVERT_E_STEP_PIN);
@@ -1944,13 +1978,9 @@ uint32_t Stepper::stepper_block_phase_isr() {
 
       // For minimum pulse time wait before looping
       // Just wait for the requested pulse duration
-      if (LA_steps) {
-        while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
-        #if MINIMUM_STEPPER_PULSE
-          // Add to the value, the time that the pulse must be active (to be used on the next loop)
-          pulse_end += hal_timer_t(MIN_PULSE_TICKS);
-        #endif
-      }
+      #if (MINIMUM_STEPPER_PULSE || MAXIMUM_STEPPER_RATE)
+        if (LA_steps) START_LOW_PULSE();
+      #endif
     } // LA_steps
 
     return interval;

commit ac71cdc265374717c067102b2bc22af002c86ee3
Author: Lino Barreca <linobarreca@hotmail.com>
Date:   Wed Nov 13 02:23:02 2019 +0100

    New HardwareTimer for STM32 5.7.0 (#15655)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 19060b9b23..f59b7a42a3 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1537,7 +1537,7 @@ void Stepper::stepper_pulse_phase_isr() {
 uint32_t Stepper::stepper_block_phase_isr() {
 
   // If no queued movements, just wait 1ms for the next move
-  uint32_t interval = (STEPPER_TIMER_RATE / 1000);
+  uint32_t interval = (STEPPER_TIMER_RATE) / 1000;
 
   // If there is a current block
   if (current_block) {

commit 93f001295988a335552d8fea5463a112e3aa64e4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 24 15:35:40 2019 -0500

    Cancel Objects - As seen at ERRF2019 (#15590)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c8e51525fe..19060b9b23 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2229,7 +2229,7 @@ int32_t Stepper::position(const AxisEnum axis) {
 // be very careful here. If the interrupt being preempted was the
 // Stepper ISR (this CAN happen with the endstop limits ISR) then
 // when the stepper ISR resumes, we must be very sure that the movement
-// is properly cancelled
+// is properly canceled
 void Stepper::endstop_triggered(const AxisEnum axis) {
 
   const bool was_enabled = STEPPER_ISR_ENABLED();

commit b7b303f4bfbced9f7a242a87af0f50d4cb24d8ae
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 15 16:10:20 2019 -0500

    Spindle/Laser power in planner blocks (#14437)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 12d5820d09..c8e51525fe 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1667,6 +1667,10 @@ uint32_t Stepper::stepper_block_phase_isr() {
           return interval; // No more queued movements!
       }
 
+      #if HAS_CUTTER
+        cutter.apply_power(current_block->cutter_power);
+      #endif
+
       #if ENABLED(POWER_LOSS_RECOVERY)
         recovery.info.sdpos = current_block->sdpos;
       #endif

commit a9c259c77a539c620ff5e92cd9f050bdfea0c33c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 30 02:47:19 2019 -0500

    Patch PrintrboardG2 build (on spec)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 6bee709b4e..12d5820d09 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2580,9 +2580,9 @@ void Stepper::report_positions() {
 
   #endif
 
-#else
+#else // PRINTRBOARD_G2
 
-  #include "../HAL/HAL_DUE/G2_PWM.h"
+  #include HAL_PATH(../HAL, fastio/G2_PWM.h)
 
 #endif
 

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b806cb1142..6bee709b4e 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -169,10 +169,10 @@ uint8_t Stepper::steps_per_isr;
 #endif
     uint8_t Stepper::oversampling_factor;
 
-int32_t Stepper::delta_error[XYZE] = { 0 };
+xyze_long_t Stepper::delta_error{0};
 
-uint32_t Stepper::advance_dividend[XYZE] = { 0 },
-         Stepper::advance_divisor = 0,
+xyze_ulong_t Stepper::advance_dividend{0};
+uint32_t Stepper::advance_divisor = 0,
          Stepper::step_events_completed = 0, // The number of step events executed in the current block
          Stepper::accelerate_until,          // The count at which to stop accelerating
          Stepper::decelerate_after,          // The count at which to start decelerating
@@ -218,10 +218,9 @@ int32_t Stepper::ticks_nominal = -1;
   uint32_t Stepper::acc_step_rate; // needed for deceleration start point
 #endif
 
-volatile int32_t Stepper::endstops_trigsteps[XYZ];
-
-volatile int32_t Stepper::count_position[NUM_AXIS] = { 0 };
-int8_t Stepper::count_direction[NUM_AXIS] = { 0, 0, 0, 0 };
+xyz_long_t Stepper::endstops_trigsteps;
+xyze_long_t Stepper::count_position{0};
+xyze_int8_t Stepper::count_direction{0};
 
 #define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                        \
   if (separate_multi_axis) {                                                                                                \
@@ -390,20 +389,20 @@ void Stepper::set_directions() {
        // what e-steppers will step. Likely all. Set all.
       if (motor_direction(E_AXIS)) {
         MIXER_STEPPER_LOOP(j) REV_E_DIR(j);
-        count_direction[E_AXIS] = -1;
+        count_direction.e = -1;
       }
       else {
         MIXER_STEPPER_LOOP(j) NORM_E_DIR(j);
-        count_direction[E_AXIS] = 1;
+        count_direction.e = 1;
       }
     #else
       if (motor_direction(E_AXIS)) {
         REV_E_DIR(stepper_extruder);
-        count_direction[E_AXIS] = -1;
+        count_direction.e = -1;
       }
       else {
         NORM_E_DIR(stepper_extruder);
-        count_direction[E_AXIS] = 1;
+        count_direction.e = 1;
       }
     #endif
   #endif // !LIN_ADVANCE
@@ -1459,15 +1458,15 @@ void Stepper::stepper_pulse_phase_isr() {
     // Pulse Extruders
     // Tick the E axis, correct error term and update position
     #if EITHER(LIN_ADVANCE, MIXING_EXTRUDER)
-      delta_error[E_AXIS] += advance_dividend[E_AXIS];
-      if (delta_error[E_AXIS] >= 0) {
-        count_position[E_AXIS] += count_direction[E_AXIS];
+      delta_error.e += advance_dividend.e;
+      if (delta_error.e >= 0) {
+        count_position.e += count_direction.e;
         #if ENABLED(LIN_ADVANCE)
-          delta_error[E_AXIS] -= advance_divisor;
+          delta_error.e -= advance_divisor;
           // Don't step E here - But remember the number of steps to perform
           motor_direction(E_AXIS) ? --LA_steps : ++LA_steps;
         #else // !LIN_ADVANCE && MIXING_EXTRUDER
-          // Don't adjust delta_error[E_AXIS] here!
+          // Don't adjust delta_error.e here!
           // Being positive is the criteria for ending the pulse.
           E_STEP_WRITE(mixer.get_next_stepper(), !INVERT_E_STEP_PIN);
         #endif
@@ -1504,8 +1503,8 @@ void Stepper::stepper_pulse_phase_isr() {
 
     #if DISABLED(LIN_ADVANCE)
       #if ENABLED(MIXING_EXTRUDER)
-        if (delta_error[E_AXIS] >= 0) {
-          delta_error[E_AXIS] -= advance_divisor;
+        if (delta_error.e >= 0) {
+          delta_error.e -= advance_divisor;
           E_STEP_WRITE(mixer.get_stepper(), INVERT_E_STEP_PIN);
         }
       #else // !MIXING_EXTRUDER
@@ -1660,10 +1659,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
 
       // Sync block? Sync the stepper counts and return
       while (TEST(current_block->flag, BLOCK_BIT_SYNC_POSITION)) {
-        _set_position(
-          current_block->position[A_AXIS], current_block->position[B_AXIS],
-          current_block->position[C_AXIS], current_block->position[E_AXIS]
-        );
+        _set_position(current_block->position);
         planner.discard_current_block();
 
         // Try to get a new block
@@ -1698,7 +1694,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
         #endif
         #define X_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) X_CMP D_(2)) )
       #else
-        #define X_MOVE_TEST !!current_block->steps[A_AXIS]
+        #define X_MOVE_TEST !!current_block->steps.a
       #endif
 
       #if CORE_IS_XY || CORE_IS_YZ
@@ -1716,7 +1712,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
         #endif
         #define Y_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Y_CMP D_(2)) )
       #else
-        #define Y_MOVE_TEST !!current_block->steps[B_AXIS]
+        #define Y_MOVE_TEST !!current_block->steps.b
       #endif
 
       #if CORE_IS_XZ || CORE_IS_YZ
@@ -1734,17 +1730,17 @@ uint32_t Stepper::stepper_block_phase_isr() {
         #endif
         #define Z_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Z_CMP D_(2)) )
       #else
-        #define Z_MOVE_TEST !!current_block->steps[C_AXIS]
+        #define Z_MOVE_TEST !!current_block->steps.c
       #endif
 
       uint8_t axis_bits = 0;
       if (X_MOVE_TEST) SBI(axis_bits, A_AXIS);
       if (Y_MOVE_TEST) SBI(axis_bits, B_AXIS);
       if (Z_MOVE_TEST) SBI(axis_bits, C_AXIS);
-      //if (!!current_block->steps[E_AXIS]) SBI(axis_bits, E_AXIS);
-      //if (!!current_block->steps[A_AXIS]) SBI(axis_bits, X_HEAD);
-      //if (!!current_block->steps[B_AXIS]) SBI(axis_bits, Y_HEAD);
-      //if (!!current_block->steps[C_AXIS]) SBI(axis_bits, Z_HEAD);
+      //if (!!current_block->steps.e) SBI(axis_bits, E_AXIS);
+      //if (!!current_block->steps.a) SBI(axis_bits, X_HEAD);
+      //if (!!current_block->steps.b) SBI(axis_bits, Y_HEAD);
+      //if (!!current_block->steps.c) SBI(axis_bits, Z_HEAD);
       axis_did_move = axis_bits;
 
       // No acceleration / deceleration time elapsed so far
@@ -1767,15 +1763,10 @@ uint32_t Stepper::stepper_block_phase_isr() {
       step_event_count = current_block->step_event_count << oversampling;
 
       // Initialize Bresenham delta errors to 1/2
-      delta_error[X_AXIS] = delta_error[Y_AXIS] = delta_error[Z_AXIS] = delta_error[E_AXIS] = -int32_t(step_event_count);
+      delta_error = -int32_t(step_event_count);
 
-      // Calculate Bresenham dividends
-      advance_dividend[X_AXIS] = current_block->steps[X_AXIS] << 1;
-      advance_dividend[Y_AXIS] = current_block->steps[Y_AXIS] << 1;
-      advance_dividend[Z_AXIS] = current_block->steps[Z_AXIS] << 1;
-      advance_dividend[E_AXIS] = current_block->steps[E_AXIS] << 1;
-
-      // Calculate Bresenham divisor
+      // Calculate Bresenham dividends and divisors
+      advance_dividend = current_block->steps << 1;
       advance_divisor = step_event_count << 1;
 
       // No step events completed so far
@@ -1840,7 +1831,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
         // If delayed Z enable, enable it now. This option will severely interfere with
         // timing between pulses when chaining motion between blocks, and it could lead
         // to lost steps in both X and Y axis, so avoid using it unless strictly necessary!!
-        if (current_block->steps[Z_AXIS]) enable_Z();
+        if (current_block->steps.z) enable_Z();
       #endif
 
       // Mark the time_nominal as not calculated yet
@@ -2195,26 +2186,18 @@ void Stepper::_set_position(const int32_t &a, const int32_t &b, const int32_t &c
   #if CORE_IS_XY
     // corexy positioning
     // these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html
-    count_position[A_AXIS] = a + b;
-    count_position[B_AXIS] = CORESIGN(a - b);
-    count_position[Z_AXIS] = c;
+    count_position.set(a + b, CORESIGN(a - b), c);
   #elif CORE_IS_XZ
     // corexz planning
-    count_position[A_AXIS] = a + c;
-    count_position[Y_AXIS] = b;
-    count_position[C_AXIS] = CORESIGN(a - c);
+    count_position.set(a + c, b, CORESIGN(a - c));
   #elif CORE_IS_YZ
     // coreyz planning
-    count_position[X_AXIS] = a;
-    count_position[B_AXIS] = b + c;
-    count_position[C_AXIS] = CORESIGN(b - c);
+    count_position.set(a, b + c, CORESIGN(b - c));
   #else
     // default non-h-bot planning
-    count_position[X_AXIS] = a;
-    count_position[Y_AXIS] = b;
-    count_position[Z_AXIS] = c;
+    count_position.set(a, b, c);
   #endif
-  count_position[E_AXIS] = e;
+  count_position.e = e;
 }
 
 /**
@@ -2290,36 +2273,22 @@ void Stepper::report_positions() {
     if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
   #endif
 
-  const int32_t xpos = count_position[X_AXIS],
-                ypos = count_position[Y_AXIS],
-                zpos = count_position[Z_AXIS];
+  const xyz_long_t pos = count_position;
 
   #ifdef __AVR__
     if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
   #endif
 
   #if CORE_IS_XY || CORE_IS_XZ || ENABLED(DELTA) || IS_SCARA
-    SERIAL_ECHOPGM(MSG_COUNT_A);
-  #else
-    SERIAL_ECHOPGM(MSG_COUNT_X);
-  #endif
-  SERIAL_ECHO(xpos);
-
-  #if CORE_IS_XY || CORE_IS_YZ || ENABLED(DELTA) || IS_SCARA
-    SERIAL_ECHOPGM(" B:");
+    SERIAL_ECHOPAIR(MSG_COUNT_A, pos.x, " B:", pos.y);
   #else
-    SERIAL_ECHOPGM(" Y:");
+    SERIAL_ECHOPAIR(MSG_COUNT_X, pos.x, " Y:", pos.y);
   #endif
-  SERIAL_ECHO(ypos);
-
   #if CORE_IS_XZ || CORE_IS_YZ || ENABLED(DELTA)
-    SERIAL_ECHOPGM(" C:");
+    SERIAL_ECHOLNPAIR(" C:", pos.z);
   #else
-    SERIAL_ECHOPGM(" Z:");
+    SERIAL_ECHOLNPAIR(" Z:", pos.z);
   #endif
-  SERIAL_ECHO(zpos);
-
-  SERIAL_EOL();
 }
 
 #if ENABLED(BABYSTEPPING)

commit 6a312fae8066788466cf129f048be53b59ab17f6
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Sep 19 19:44:07 2019 -0400

    Add before/after dir change delays (#15314)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 8163416cb0..b806cb1142 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -358,6 +358,10 @@ void Stepper::set_directions() {
     uint8_t L6470_buf[MAX_L6470 + 1];   // chip command sequence - element 0 not used
   #endif
 
+  #if MINIMUM_STEPPER_PRE_DIR_DELAY > 0
+    DELAY_NS(MINIMUM_STEPPER_PRE_DIR_DELAY);
+  #endif
+
   #define SET_STEP_DIR(A)                       \
     if (motor_direction(_AXIS(A))) {            \
       A##_APPLY_DIR(INVERT_## A##_DIR, false);  \
@@ -426,8 +430,8 @@ void Stepper::set_directions() {
   #endif
 
   // A small delay may be needed after changing direction
-  #if MINIMUM_STEPPER_DIR_DELAY > 0
-    DELAY_NS(MINIMUM_STEPPER_DIR_DELAY);
+  #if MINIMUM_STEPPER_POST_DIR_DELAY > 0
+    DELAY_NS(MINIMUM_STEPPER_POST_DIR_DELAY);
   #endif
 }
 
@@ -1887,6 +1891,10 @@ uint32_t Stepper::stepper_block_phase_isr() {
     else
       interval = LA_ADV_NEVER;
 
+    #if MINIMUM_STEPPER_PRE_DIR_DELAY > 0
+      DELAY_NS(MINIMUM_STEPPER_PRE_DIR_DELAY);
+    #endif
+
     #if ENABLED(MIXING_EXTRUDER)
       // We don't know which steppers will be stepped because LA loop follows,
       // with potentially multiple steps. Set all.
@@ -1902,8 +1910,8 @@ uint32_t Stepper::stepper_block_phase_isr() {
     #endif
 
     // A small delay may be needed after changing direction
-    #if MINIMUM_STEPPER_DIR_DELAY > 0
-      DELAY_NS(MINIMUM_STEPPER_DIR_DELAY);
+    #if MINIMUM_STEPPER_POST_DIR_DELAY > 0
+      DELAY_NS(MINIMUM_STEPPER_POST_DIR_DELAY);
     #endif
 
     // Get the timer count and estimate the end of the pulse
@@ -2353,8 +2361,9 @@ void Stepper::report_positions() {
   #define BABYSTEP_AXIS(AXIS, INVERT, DIR) {            \
       const uint8_t old_dir = _READ_DIR(AXIS);          \
       _ENABLE(AXIS);                                    \
+      DELAY_NS(MINIMUM_STEPPER_PRE_DIR_DELAY);              \
       _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^DIR^INVERT);   \
-      DELAY_NS(MINIMUM_STEPPER_DIR_DELAY);              \
+      DELAY_NS(MINIMUM_STEPPER_POST_DIR_DELAY);              \
       _SAVE_START;                                      \
       _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), true); \
       _PULSE_WAIT;                                      \
@@ -2418,6 +2427,10 @@ void Stepper::report_positions() {
           enable_Y();
           enable_Z();
 
+          #if MINIMUM_STEPPER_PRE_DIR_DELAY > 0
+            DELAY_NS(MINIMUM_STEPPER_PRE_DIR_DELAY);
+          #endif
+
           const uint8_t old_x_dir_pin = X_DIR_READ(),
                         old_y_dir_pin = Y_DIR_READ(),
                         old_z_dir_pin = Z_DIR_READ();
@@ -2426,8 +2439,8 @@ void Stepper::report_positions() {
           Y_DIR_WRITE(INVERT_Y_DIR ^ z_direction);
           Z_DIR_WRITE(INVERT_Z_DIR ^ z_direction);
 
-          #if MINIMUM_STEPPER_DIR_DELAY > 0
-            DELAY_NS(MINIMUM_STEPPER_DIR_DELAY);
+          #if MINIMUM_STEPPER_POST_DIR_DELAY > 0
+            DELAY_NS(MINIMUM_STEPPER_POST_DIR_DELAY);
           #endif
 
           _SAVE_START;

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 7595ac1f84..8163416cb0 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -174,8 +174,8 @@ int32_t Stepper::delta_error[XYZE] = { 0 };
 uint32_t Stepper::advance_dividend[XYZE] = { 0 },
          Stepper::advance_divisor = 0,
          Stepper::step_events_completed = 0, // The number of step events executed in the current block
-         Stepper::accelerate_until,          // The point from where we need to stop acceleration
-         Stepper::decelerate_after,          // The point from where we need to start decelerating
+         Stepper::accelerate_until,          // The count at which to stop accelerating
+         Stepper::decelerate_after,          // The count at which to start decelerating
          Stepper::step_event_count;          // The total event count for the current block
 
 #if EXTRUDERS > 1 || ENABLED(MIXING_EXTRUDER)
@@ -2239,19 +2239,16 @@ void Stepper::endstop_triggered(const AxisEnum axis) {
 
   const bool was_enabled = STEPPER_ISR_ENABLED();
   if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
-
-  #if IS_CORE
-
-    endstops_trigsteps[axis] = 0.5f * (
-      axis == CORE_AXIS_2 ? CORESIGN(count_position[CORE_AXIS_1] - count_position[CORE_AXIS_2])
-                          : count_position[CORE_AXIS_1] + count_position[CORE_AXIS_2]
-    );
-
-  #else // !COREXY && !COREXZ && !COREYZ
-
-    endstops_trigsteps[axis] = count_position[axis];
-
-  #endif // !COREXY && !COREXZ && !COREYZ
+  endstops_trigsteps[axis] = (
+    #if IS_CORE
+      (axis == CORE_AXIS_2
+        ? CORESIGN(count_position[CORE_AXIS_1] - count_position[CORE_AXIS_2])
+        : count_position[CORE_AXIS_1] + count_position[CORE_AXIS_2]
+      ) * 0.5f
+    #else // !IS_CORE
+      count_position[axis]
+    #endif
+  );
 
   // Discard the rest of the move if there is a current block
   quick_stop();
@@ -2279,15 +2276,19 @@ int32_t Stepper::triggered_position(const AxisEnum axis) {
 
 void Stepper::report_positions() {
 
-  // Protect the access to the position.
-  const bool was_enabled = STEPPER_ISR_ENABLED();
-  if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+  #ifdef __AVR__
+    // Protect the access to the position.
+    const bool was_enabled = STEPPER_ISR_ENABLED();
+    if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+  #endif
 
   const int32_t xpos = count_position[X_AXIS],
                 ypos = count_position[Y_AXIS],
                 zpos = count_position[Z_AXIS];
 
-  if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+  #ifdef __AVR__
+    if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+  #endif
 
   #if CORE_IS_XY || CORE_IS_XZ || ENABLED(DELTA) || IS_SCARA
     SERIAL_ECHOPGM(MSG_COUNT_A);

commit c590e8ac05c3b417aa42ecd1f4967c4f70cfdd71
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 18:52:41 2019 -0500

    Improve Power-loss Recovery (#15135)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index cd868e7db6..7595ac1f84 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -121,6 +121,10 @@ Stepper stepper; // Singleton
   #include "../libs/L6470/L6470_Marlin.h"
 #endif
 
+#if ENABLED(POWER_LOSS_RECOVERY)
+  #include "../feature/power_loss_recovery.h"
+#endif
+
 // public:
 
 #if HAS_EXTRA_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
@@ -1663,6 +1667,10 @@ uint32_t Stepper::stepper_block_phase_isr() {
           return interval; // No more queued movements!
       }
 
+      #if ENABLED(POWER_LOSS_RECOVERY)
+        recovery.info.sdpos = current_block->sdpos;
+      #endif
+
       // Flag all moving axes for proper endstop handling
 
       #if IS_CORE

commit 89a2161cac4c6c0ad4d177dcee6dbd0b7cc21b08
Author: AnHardt <github@kitelab.de>
Date:   Wed Sep 4 03:01:51 2019 +0200

    MINIMUM_STEPPER_DIR_DELAY in LA (#15154)
    
    Add missed MINIMUM_STEPPER_DIR_DELAY after dir change in LinearAdvance interrupt.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 862c608776..cd868e7db6 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1879,19 +1879,24 @@ uint32_t Stepper::stepper_block_phase_isr() {
     else
       interval = LA_ADV_NEVER;
 
-      #if ENABLED(MIXING_EXTRUDER)
-        // We don't know which steppers will be stepped because LA loop follows,
-        // with potentially multiple steps. Set all.
-        if (LA_steps >= 0)
-          MIXER_STEPPER_LOOP(j) NORM_E_DIR(j);
-        else
-          MIXER_STEPPER_LOOP(j) REV_E_DIR(j);
-      #else
-        if (LA_steps >= 0)
-          NORM_E_DIR(stepper_extruder);
-        else
-          REV_E_DIR(stepper_extruder);
-      #endif
+    #if ENABLED(MIXING_EXTRUDER)
+      // We don't know which steppers will be stepped because LA loop follows,
+      // with potentially multiple steps. Set all.
+      if (LA_steps >= 0)
+        MIXER_STEPPER_LOOP(j) NORM_E_DIR(j);
+      else
+        MIXER_STEPPER_LOOP(j) REV_E_DIR(j);
+    #else
+      if (LA_steps >= 0)
+        NORM_E_DIR(stepper_extruder);
+      else
+        REV_E_DIR(stepper_extruder);
+    #endif
+
+    // A small delay may be needed after changing direction
+    #if MINIMUM_STEPPER_DIR_DELAY > 0
+      DELAY_NS(MINIMUM_STEPPER_DIR_DELAY);
+    #endif
 
     // Get the timer count and estimate the end of the pulse
     hal_timer_t pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t(MIN_PULSE_TICKS);

commit 8bdb3d997048fac4dae3ee47b0d7131aa581c644
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Aug 16 20:57:19 2019 -0600

    Add CONTROLLERFAN_SPEED_Z_ONLY (#14956)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 3d2c34e6d3..862c608776 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2316,7 +2316,7 @@ void Stepper::report_positions() {
   #define EXTRA_CYCLES_BABYSTEP (STEP_PULSE_CYCLES - (CYCLES_EATEN_BABYSTEP))
 
   #define _ENABLE(AXIS) enable_## AXIS()
-  #define _READ_DIR(AXIS) AXIS ##_DIR_READ
+  #define _READ_DIR(AXIS) AXIS ##_DIR_READ()
   #define _INVERT_DIR(AXIS) INVERT_## AXIS ##_DIR
   #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)
 
@@ -2404,9 +2404,9 @@ void Stepper::report_positions() {
           enable_Y();
           enable_Z();
 
-          const uint8_t old_x_dir_pin = X_DIR_READ,
-                        old_y_dir_pin = Y_DIR_READ,
-                        old_z_dir_pin = Z_DIR_READ;
+          const uint8_t old_x_dir_pin = X_DIR_READ(),
+                        old_y_dir_pin = Y_DIR_READ(),
+                        old_z_dir_pin = Z_DIR_READ();
 
           X_DIR_WRITE(INVERT_X_DIR ^ z_direction);
           Y_DIR_WRITE(INVERT_Y_DIR ^ z_direction);

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index a5c73bb3ff..3d2c34e6d3 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1291,7 +1291,7 @@ void Stepper::isr() {
 
     uint32_t interval =
       #if ENABLED(LIN_ADVANCE)
-        MIN(nextAdvanceISR, nextMainISR)  // Nearest time interval
+        _MIN(nextAdvanceISR, nextMainISR)  // Nearest time interval
       #else
         nextMainISR                       // Remaining stepper ISR time
       #endif
@@ -1404,7 +1404,7 @@ void Stepper::stepper_pulse_phase_isr() {
 
   // Count of pending loops and events for this iteration
   const uint32_t pending_events = step_event_count - step_events_completed;
-  uint8_t events_to_do = MIN(pending_events, steps_per_isr);
+  uint8_t events_to_do = _MIN(pending_events, steps_per_isr);
 
   // Just update the value we will get at the end of the loop
   step_events_completed += events_to_do;

commit d4415dcf592bbb1db869316a3020d92fa5a23edb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 2 04:04:49 2019 -0500

    Fix analogWrite ambiguity

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 6a862a2492..a5c73bb3ff 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2502,7 +2502,7 @@ void Stepper::report_positions() {
         if (WITHIN(driver, 0, COUNT(motor_current_setting) - 1))
           motor_current_setting[driver] = current; // update motor_current_setting
 
-        #define _WRITE_CURRENT_PWM(P) analogWrite(MOTOR_CURRENT_PWM_## P ##_PIN, 255L * current / (MOTOR_CURRENT_PWM_RANGE))
+        #define _WRITE_CURRENT_PWM(P) analogWrite(pin_t(MOTOR_CURRENT_PWM_## P ##_PIN), 255L * current / (MOTOR_CURRENT_PWM_RANGE))
         switch (driver) {
           case 0:
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)

commit 19aafb90508af2edd7c684ad5d63f1fca16f1b36
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sat Jun 29 11:39:38 2019 +0200

    Fix STM32F1 motor shocks (stepper timer issue) (#14030)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4160546e8e..6a862a2492 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1262,7 +1262,7 @@ void Stepper::isr() {
   // Program timer compare for the maximum period, so it does NOT
   // flag an interrupt while this ISR is running - So changes from small
   // periods to big periods are respected and the timer does not reset to 0
-  HAL_timer_set_compare(STEP_TIMER_NUM, HAL_TIMER_TYPE_MAX);
+  HAL_timer_set_compare(STEP_TIMER_NUM, hal_timer_t(HAL_TIMER_TYPE_MAX));
 
   // Count of ticks for the next ISR
   hal_timer_t next_isr_ticks = 0;

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 6b655b44e9..4160546e8e 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit 06f327353120f000a358aecb79f5344be6a52ec7
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri May 17 17:16:56 2019 -0400

    Fix DELTA pulse wait bug (#14028)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 5666f58bb3..6b655b44e9 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2327,10 +2327,10 @@ void Stepper::report_positions() {
     #define _SAVE_START NOOP
     #if EXTRA_CYCLES_BABYSTEP > 0
       #define _PULSE_WAIT DELAY_NS(EXTRA_CYCLES_BABYSTEP * NANOSECONDS_PER_CYCLE)
-    #elif STEP_PULSE_CYCLES > 0
-      #define _PULSE_WAIT NOOP
     #elif ENABLED(DELTA)
       #define _PULSE_WAIT DELAY_US(2);
+    #elif STEP_PULSE_CYCLES > 0
+      #define _PULSE_WAIT NOOP
     #else
       #define _PULSE_WAIT DELAY_US(4);
     #endif

commit ad4ffa1d2fbd17ac09c816ba2052cdf714261042
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 9 11:45:55 2019 -0500

    Use C++ language supported 'nullptr' (#13944)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index eaac7f5504..5666f58bb3 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -133,7 +133,7 @@ Stepper stepper; // Singleton
 
 // private:
 
-block_t* Stepper::current_block; // (= NULL) A pointer to the block currently being traced
+block_t* Stepper::current_block; // (= nullptr) A pointer to the block currently being traced
 
 uint8_t Stepper::last_direction_bits, // = 0
         Stepper::axis_did_move; // = 0
@@ -1394,7 +1394,7 @@ void Stepper::stepper_pulse_phase_isr() {
     abort_current_block = false;
     if (current_block) {
       axis_did_move = 0;
-      current_block = NULL;
+      current_block = nullptr;
       planner.discard_current_block();
     }
   }
@@ -1541,7 +1541,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
         runout.block_completed(current_block);
       #endif
       axis_did_move = 0;
-      current_block = NULL;
+      current_block = nullptr;
       planner.discard_current_block();
     }
     else {

commit 7da63fa03fbcf680375da48403dac3a16a7eac87
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sat May 4 22:59:38 2019 +0200

    Fix NOMORE() sign warning in stepper (#13894)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index eb4957ec2e..eaac7f5504 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1298,7 +1298,7 @@ void Stepper::isr() {
     ;
 
     // Limit the value to the maximum possible value of the timer
-    NOMORE(interval, HAL_TIMER_TYPE_MAX);
+    NOMORE(interval, uint32_t(HAL_TIMER_TYPE_MAX));
 
     // Compute the time remaining for the main isr
     nextMainISR -= interval;

commit 15357af67ceb74b14606eba9fbb75d20914f8909
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri May 3 22:53:15 2019 -0600

    Backlash cleanup (#13659)
    
    …And save backlash, fil. sensor, ExtUI userdata to EEPROM.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index ce3141c12f..eb4957ec2e 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -113,7 +113,7 @@ Stepper stepper; // Singleton
   #include "../feature/mixing.h"
 #endif
 
-#if FILAMENT_RUNOUT_DISTANCE_MM > 0
+#ifdef FILAMENT_RUNOUT_DISTANCE_MM
   #include "../feature/runout.h"
 #endif
 
@@ -1537,7 +1537,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
 
     // If current block is finished, reset pointer
     if (step_events_completed >= step_event_count) {
-      #if FILAMENT_RUNOUT_DISTANCE_MM > 0
+      #ifdef FILAMENT_RUNOUT_DISTANCE_MM
         runout.block_completed(current_block);
       #endif
       axis_did_move = 0;

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index eb78cd4c13..ce3141c12f 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -153,7 +153,7 @@ bool Stepper::abort_current_block;
 #if Z_MULTI_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
   bool Stepper::locked_Z_motor = false, Stepper::locked_Z2_motor = false;
 #endif
-#if ENABLED(Z_TRIPLE_ENDSTOPS) || (ENABLED(Z_STEPPER_AUTO_ALIGN) && ENABLED(Z_TRIPLE_STEPPER_DRIVERS))
+#if ENABLED(Z_TRIPLE_ENDSTOPS) || BOTH(Z_STEPPER_AUTO_ALIGN, Z_TRIPLE_STEPPER_DRIVERS)
   bool Stepper::locked_Z3_motor = false;
 #endif
 
@@ -1450,7 +1450,7 @@ void Stepper::stepper_pulse_phase_isr() {
 
     // Pulse Extruders
     // Tick the E axis, correct error term and update position
-    #if ENABLED(LIN_ADVANCE) || ENABLED(MIXING_EXTRUDER)
+    #if EITHER(LIN_ADVANCE, MIXING_EXTRUDER)
       delta_error[E_AXIS] += advance_dividend[E_AXIS];
       if (delta_error[E_AXIS] >= 0) {
         count_position[E_AXIS] += count_direction[E_AXIS];
@@ -1679,7 +1679,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
          * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z, handled below)
          * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X)
          */
-        #if ENABLED(COREXY) || ENABLED(COREXZ)
+        #if EITHER(COREXY, COREXZ)
           #define X_CMP ==
         #else
           #define X_CMP !=
@@ -1697,7 +1697,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
          * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y)
          * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z)
          */
-        #if ENABLED(COREYX) || ENABLED(COREYZ)
+        #if EITHER(COREYX, COREYZ)
           #define Y_CMP ==
         #else
           #define Y_CMP !=
@@ -1715,7 +1715,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
          * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y, already handled above)
          * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Z)
          */
-        #if ENABLED(COREZX) || ENABLED(COREZY)
+        #if EITHER(COREZX, COREZY)
           #define Z_CMP ==
         #else
           #define Z_CMP !=
@@ -2030,7 +2030,7 @@ void Stepper::init() {
   #if HAS_X_ENABLE
     X_ENABLE_INIT;
     if (!X_ENABLE_ON) X_ENABLE_WRITE(HIGH);
-    #if (ENABLED(DUAL_X_CARRIAGE) || ENABLED(X_DUAL_STEPPER_DRIVERS)) && HAS_X2_ENABLE
+    #if EITHER(DUAL_X_CARRIAGE, X_DUAL_STEPPER_DRIVERS) && HAS_X2_ENABLE
       X2_ENABLE_INIT;
       if (!X_ENABLE_ON) X2_ENABLE_WRITE(HIGH);
     #endif
@@ -2093,7 +2093,7 @@ void Stepper::init() {
 
   // Init Step Pins
   #if HAS_X_STEP
-    #if ENABLED(X_DUAL_STEPPER_DRIVERS) || ENABLED(DUAL_X_CARRIAGE)
+    #if EITHER(X_DUAL_STEPPER_DRIVERS, DUAL_X_CARRIAGE)
       X2_STEP_INIT;
       X2_STEP_WRITE(INVERT_X_STEP_PIN);
     #endif
@@ -2467,13 +2467,13 @@ void Stepper::report_positions() {
     if (!initialized) return;
     LOOP_L_N(i, COUNT(motor_current_setting)) {
       switch (i) {
-        #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY) || PIN_EXISTS(MOTOR_CURRENT_PWM_X) || PIN_EXISTS(MOTOR_CURRENT_PWM_Y)
+        #if ANY_PIN(MOTOR_CURRENT_PWM_XY, MOTOR_CURRENT_PWM_X, MOTOR_CURRENT_PWM_Y)
           case 0:
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
           case 1:
         #endif
-        #if PIN_EXISTS(MOTOR_CURRENT_PWM_E) || PIN_EXISTS(MOTOR_CURRENT_PWM_E0) || PIN_EXISTS(MOTOR_CURRENT_PWM_E1)
+        #if ANY_PIN(MOTOR_CURRENT_PWM_E, MOTOR_CURRENT_PWM_E0, MOTOR_CURRENT_PWM_E1)
           case 2:
         #endif
             digipot_current(i, motor_current_setting[i]);

commit 09eb30dc05a727e3816ab5a407f02ada18700e23
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Mar 15 23:46:27 2019 -0400

    IDEX Mirror mode based on Formbot / Vivedino Symmetric mode (#13404)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4c1cff6753..eb78cd4c13 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -284,22 +284,14 @@ int8_t Stepper::count_direction[NUM_AXIS] = { 0, 0, 0, 0 };
     #define X_APPLY_STEP(v,Q) do{ X_STEP_WRITE(v); X2_STEP_WRITE(v); }while(0)
   #endif
 #elif ENABLED(DUAL_X_CARRIAGE)
-  #define X_APPLY_DIR(v,ALWAYS) \
-    if (extruder_duplication_enabled || ALWAYS) { \
-      X_DIR_WRITE(v); \
-      X2_DIR_WRITE(v); \
-    } \
-    else { \
-      if (movement_extruder()) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \
-    }
-  #define X_APPLY_STEP(v,ALWAYS) \
-    if (extruder_duplication_enabled || ALWAYS) { \
-      X_STEP_WRITE(v); \
-      X2_STEP_WRITE(v); \
-    } \
-    else { \
-      if (movement_extruder()) X2_STEP_WRITE(v); else X_STEP_WRITE(v); \
-    }
+  #define X_APPLY_DIR(v,ALWAYS) do{ \
+    if (extruder_duplication_enabled || ALWAYS) { X_DIR_WRITE(v); X2_DIR_WRITE(mirrored_duplication_mode ? !(v) : v); } \
+    else if (movement_extruder()) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \
+  }while(0)
+  #define X_APPLY_STEP(v,ALWAYS) do{ \
+    if (extruder_duplication_enabled || ALWAYS) { X_STEP_WRITE(v); X2_STEP_WRITE(v); } \
+    else if (movement_extruder()) X2_STEP_WRITE(v); else X_STEP_WRITE(v); \
+  }while(0)
 #else
   #define X_APPLY_DIR(v,Q) X_DIR_WRITE(v)
   #define X_APPLY_STEP(v,Q) X_STEP_WRITE(v)

commit 67bee06e4371fca6511aae99125337b6e63560d8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 13 07:21:10 2019 -0500

    No patch needed for non-libmaple analogWrite
    
    See https://github.com/pinchies/Marlin/pull/1#issuecomment-471388743

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index be91e7d808..4c1cff6753 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2510,7 +2510,7 @@ void Stepper::report_positions() {
         if (WITHIN(driver, 0, COUNT(motor_current_setting) - 1))
           motor_current_setting[driver] = current; // update motor_current_setting
 
-        #define _WRITE_CURRENT_PWM(P) ANALOG_WRITE(MOTOR_CURRENT_PWM_## P ##_PIN, 255L * current / (MOTOR_CURRENT_PWM_RANGE))
+        #define _WRITE_CURRENT_PWM(P) analogWrite(MOTOR_CURRENT_PWM_## P ##_PIN, 255L * current / (MOTOR_CURRENT_PWM_RANGE))
         switch (driver) {
           case 0:
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)

commit f89b375fb9ca9730a4165ac3bf9f0f9dc100a338
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 13 06:51:15 2019 -0500

    Fixes and improvements for PWM pins (#13383)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index a5b86631f9..be91e7d808 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2510,7 +2510,7 @@ void Stepper::report_positions() {
         if (WITHIN(driver, 0, COUNT(motor_current_setting) - 1))
           motor_current_setting[driver] = current; // update motor_current_setting
 
-        #define _WRITE_CURRENT_PWM(P) analogWrite(MOTOR_CURRENT_PWM_## P ##_PIN, 255L * current / (MOTOR_CURRENT_PWM_RANGE))
+        #define _WRITE_CURRENT_PWM(P) ANALOG_WRITE(MOTOR_CURRENT_PWM_## P ##_PIN, 255L * current / (MOTOR_CURRENT_PWM_RANGE))
         switch (driver) {
           case 0:
             #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)
@@ -2560,25 +2560,25 @@ void Stepper::report_positions() {
       #elif HAS_MOTOR_CURRENT_PWM
 
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)
-          SET_OUTPUT(MOTOR_CURRENT_PWM_X_PIN);
+          SET_PWM(MOTOR_CURRENT_PWM_X_PIN);
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_Y)
-          SET_OUTPUT(MOTOR_CURRENT_PWM_Y_PIN);
+          SET_PWM(MOTOR_CURRENT_PWM_Y_PIN);
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
-          SET_OUTPUT(MOTOR_CURRENT_PWM_XY_PIN);
+          SET_PWM(MOTOR_CURRENT_PWM_XY_PIN);
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
-          SET_OUTPUT(MOTOR_CURRENT_PWM_Z_PIN);
+          SET_PWM(MOTOR_CURRENT_PWM_Z_PIN);
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
-          SET_OUTPUT(MOTOR_CURRENT_PWM_E_PIN);
+          SET_PWM(MOTOR_CURRENT_PWM_E_PIN);
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_E0)
-          SET_OUTPUT(MOTOR_CURRENT_PWM_E0_PIN);
+          SET_PWM(MOTOR_CURRENT_PWM_E0_PIN);
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_E1)
-          SET_OUTPUT(MOTOR_CURRENT_PWM_E1_PIN);
+          SET_PWM(MOTOR_CURRENT_PWM_E1_PIN);
         #endif
 
         refresh_motor_power();

commit 1f7e220387e01d8be9b370396c2c5cc7e0b34f56
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 10 20:43:59 2019 -0500

    Make HAL ISR macros function-like

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 56e30bdcbe..a5b86631f9 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1246,7 +1246,7 @@ void Stepper::set_directions() {
  * Directly pulses the stepper motors at high frequency.
  */
 
-HAL_STEP_TIMER_ISR {
+HAL_STEP_TIMER_ISR() {
   HAL_timer_isr_prologue(STEP_TIMER_NUM);
 
   Stepper::isr();

commit 367d392880a13d337ebd518dcce29d4717588bbf
Author: Robert Mendon <gibben@gmail.com>
Date:   Sun Mar 3 19:58:02 2019 -0700

    Init stepper current after stepper pins are set up (#13302)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 666c9a9c6d..56e30bdcbe 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1979,11 +1979,6 @@ bool Stepper::is_block_busy(const block_t* const block) {
 
 void Stepper::init() {
 
-  // Init Digipot Motor Current
-  #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
-    digipot_init();
-  #endif
-
   #if MB(ALLIGATOR)
     const float motor_current[] = MOTOR_CURRENT;
     unsigned int digipot_motor = 0;
@@ -2165,8 +2160,12 @@ void Stepper::init() {
     | (INVERT_Z_DIR ? _BV(Z_AXIS) : 0);
 
   set_directions();
-  #if HAS_MOTOR_CURRENT_PWM
-    initialized = true;
+
+  #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
+    #if HAS_MOTOR_CURRENT_PWM
+      initialized = true;
+    #endif
+    digipot_init();
   #endif
 }
 

commit 71773b128db764afeccb3c782c5a8bdaef175042
Author: Vasily Evseenko <svpcom@gmail.com>
Date:   Sun Mar 3 02:29:02 2019 +0300

    Fix stepper use before init. Add Ultimaker2+ Extended clone config (#13284)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index afc1c3f3f8..666c9a9c6d 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -81,6 +81,10 @@
 
 Stepper stepper; // Singleton
 
+#if HAS_MOTOR_CURRENT_PWM
+  bool Stepper::initialized; // = false
+#endif
+
 #ifdef __AVR__
   #include "speed_lookuptable.h"
 #endif
@@ -2161,6 +2165,9 @@ void Stepper::init() {
     | (INVERT_Z_DIR ? _BV(Z_AXIS) : 0);
 
   set_directions();
+  #if HAS_MOTOR_CURRENT_PWM
+    initialized = true;
+  #endif
 }
 
 /**
@@ -2466,6 +2473,7 @@ void Stepper::report_positions() {
 #if HAS_MOTOR_CURRENT_PWM
 
   void Stepper::refresh_motor_power() {
+    if (!initialized) return;
     LOOP_L_N(i, COUNT(motor_current_setting)) {
       switch (i) {
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY) || PIN_EXISTS(MOTOR_CURRENT_PWM_X) || PIN_EXISTS(MOTOR_CURRENT_PWM_Y)
@@ -2498,6 +2506,8 @@ void Stepper::report_positions() {
 
       #elif HAS_MOTOR_CURRENT_PWM
 
+        if (!initialized) return;
+
         if (WITHIN(driver, 0, COUNT(motor_current_setting) - 1))
           motor_current_setting[driver] = current; // update motor_current_setting
 

commit ddbe4cfa20165b5efcd8fb28078083261136cf72
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Tue Feb 26 21:03:13 2019 -0600

    Printrboard G2 support (#13116)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 57e8e4195c..afc1c3f3f8 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2485,99 +2485,107 @@ void Stepper::report_positions() {
 
 #endif // HAS_MOTOR_CURRENT_PWM
 
-#if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
+#if !MB(PRINTRBOARD_G2)
 
-  void Stepper::digipot_current(const uint8_t driver, const int16_t current) {
+  #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
 
-    #if HAS_DIGIPOTSS
+    void Stepper::digipot_current(const uint8_t driver, const int16_t current) {
 
-      const uint8_t digipot_ch[] = DIGIPOT_CHANNELS;
-      digitalPotWrite(digipot_ch[driver], current);
+      #if HAS_DIGIPOTSS
 
-    #elif HAS_MOTOR_CURRENT_PWM
+        const uint8_t digipot_ch[] = DIGIPOT_CHANNELS;
+        digitalPotWrite(digipot_ch[driver], current);
 
-      if (WITHIN(driver, 0, COUNT(motor_current_setting) - 1))
-        motor_current_setting[driver] = current; // update motor_current_setting
+      #elif HAS_MOTOR_CURRENT_PWM
 
-      #define _WRITE_CURRENT_PWM(P) analogWrite(MOTOR_CURRENT_PWM_## P ##_PIN, 255L * current / (MOTOR_CURRENT_PWM_RANGE))
-      switch (driver) {
-        case 0:
-          #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)
-            _WRITE_CURRENT_PWM(X);
-          #endif
-          #if PIN_EXISTS(MOTOR_CURRENT_PWM_Y)
-            _WRITE_CURRENT_PWM(Y);
-          #endif
-          #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
-            _WRITE_CURRENT_PWM(XY);
-          #endif
-          break;
-        case 1:
-          #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
-            _WRITE_CURRENT_PWM(Z);
-          #endif
-          break;
-        case 2:
-          #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
-            _WRITE_CURRENT_PWM(E);
-          #endif
-          #if PIN_EXISTS(MOTOR_CURRENT_PWM_E0)
-            _WRITE_CURRENT_PWM(E0);
-          #endif
-          #if PIN_EXISTS(MOTOR_CURRENT_PWM_E1)
-            _WRITE_CURRENT_PWM(E1);
-          #endif
-          break;
-      }
-    #endif
-  }
+        if (WITHIN(driver, 0, COUNT(motor_current_setting) - 1))
+          motor_current_setting[driver] = current; // update motor_current_setting
 
-  void Stepper::digipot_init() {
+        #define _WRITE_CURRENT_PWM(P) analogWrite(MOTOR_CURRENT_PWM_## P ##_PIN, 255L * current / (MOTOR_CURRENT_PWM_RANGE))
+        switch (driver) {
+          case 0:
+            #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)
+              _WRITE_CURRENT_PWM(X);
+            #endif
+            #if PIN_EXISTS(MOTOR_CURRENT_PWM_Y)
+              _WRITE_CURRENT_PWM(Y);
+            #endif
+            #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
+              _WRITE_CURRENT_PWM(XY);
+            #endif
+            break;
+          case 1:
+            #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
+              _WRITE_CURRENT_PWM(Z);
+            #endif
+            break;
+          case 2:
+            #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
+              _WRITE_CURRENT_PWM(E);
+            #endif
+            #if PIN_EXISTS(MOTOR_CURRENT_PWM_E0)
+              _WRITE_CURRENT_PWM(E0);
+            #endif
+            #if PIN_EXISTS(MOTOR_CURRENT_PWM_E1)
+              _WRITE_CURRENT_PWM(E1);
+            #endif
+            break;
+        }
+      #endif
+    }
 
-    #if HAS_DIGIPOTSS
+    void Stepper::digipot_init() {
 
-      static const uint8_t digipot_motor_current[] = DIGIPOT_MOTOR_CURRENT;
+      #if HAS_DIGIPOTSS
 
-      SPI.begin();
-      SET_OUTPUT(DIGIPOTSS_PIN);
+        static const uint8_t digipot_motor_current[] = DIGIPOT_MOTOR_CURRENT;
 
-      for (uint8_t i = 0; i < COUNT(digipot_motor_current); i++) {
-        //digitalPotWrite(digipot_ch[i], digipot_motor_current[i]);
-        digipot_current(i, digipot_motor_current[i]);
-      }
+        SPI.begin();
+        SET_OUTPUT(DIGIPOTSS_PIN);
 
-    #elif HAS_MOTOR_CURRENT_PWM
+        for (uint8_t i = 0; i < COUNT(digipot_motor_current); i++) {
+          //digitalPotWrite(digipot_ch[i], digipot_motor_current[i]);
+          digipot_current(i, digipot_motor_current[i]);
+        }
 
-      #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)
-        SET_OUTPUT(MOTOR_CURRENT_PWM_X_PIN);
-      #endif
-      #if PIN_EXISTS(MOTOR_CURRENT_PWM_Y)
-        SET_OUTPUT(MOTOR_CURRENT_PWM_Y_PIN);
-      #endif
-      #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
-        SET_OUTPUT(MOTOR_CURRENT_PWM_XY_PIN);
-      #endif
-      #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
-        SET_OUTPUT(MOTOR_CURRENT_PWM_Z_PIN);
-      #endif
-      #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
-        SET_OUTPUT(MOTOR_CURRENT_PWM_E_PIN);
-      #endif
-      #if PIN_EXISTS(MOTOR_CURRENT_PWM_E0)
-        SET_OUTPUT(MOTOR_CURRENT_PWM_E0_PIN);
-      #endif
-      #if PIN_EXISTS(MOTOR_CURRENT_PWM_E1)
-        SET_OUTPUT(MOTOR_CURRENT_PWM_E1_PIN);
-      #endif
+      #elif HAS_MOTOR_CURRENT_PWM
 
-      refresh_motor_power();
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)
+          SET_OUTPUT(MOTOR_CURRENT_PWM_X_PIN);
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_Y)
+          SET_OUTPUT(MOTOR_CURRENT_PWM_Y_PIN);
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
+          SET_OUTPUT(MOTOR_CURRENT_PWM_XY_PIN);
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
+          SET_OUTPUT(MOTOR_CURRENT_PWM_Z_PIN);
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
+          SET_OUTPUT(MOTOR_CURRENT_PWM_E_PIN);
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_E0)
+          SET_OUTPUT(MOTOR_CURRENT_PWM_E0_PIN);
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_E1)
+          SET_OUTPUT(MOTOR_CURRENT_PWM_E1_PIN);
+        #endif
 
-      // Set Timer5 to 31khz so the PWM of the motor power is as constant as possible. (removes a buzzing noise)
-      #ifdef __AVR__
-        SET_CS5(PRESCALER_1);
+        refresh_motor_power();
+
+        // Set Timer5 to 31khz so the PWM of the motor power is as constant as possible. (removes a buzzing noise)
+        #ifdef __AVR__
+          SET_CS5(PRESCALER_1);
+        #endif
       #endif
-    #endif
-  }
+    }
+
+  #endif
+
+#else
+
+  #include "../HAL/HAL_DUE/G2_PWM.h"
 
 #endif
 

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 11f44e8df5..57e8e4195c 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit 5cd0fa3ce1ea2e6839c2a19816b16c821fddc8a5
Author: Simon Jouet <simon-jouet@users.noreply.github.com>
Date:   Sun Feb 10 11:40:31 2019 +0000

    Basic GPIO expander using the ESP32 I2S peripheral (#12959)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 83de4b9719..11f44e8df5 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1474,7 +1474,12 @@ void Stepper::stepper_pulse_phase_isr() {
       #endif
     #endif
 
-    #if MINIMUM_STEPPER_PULSE
+    #if ENABLED(I2S_STEPPER_STREAM)
+      i2s_push_sample();
+    #endif
+
+    // TODO: need to deal with MINIMUM_STEPPER_PULSE over i2s
+    #if MINIMUM_STEPPER_PULSE && DISABLED(I2S_STEPPER_STREAM)
       // Just wait for the requested pulse duration
       while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
     #endif
@@ -2143,12 +2148,11 @@ void Stepper::init() {
     E_AXIS_INIT(5);
   #endif
 
-  // Init Stepper ISR to 122 Hz for quick starting
-  HAL_timer_start(STEP_TIMER_NUM, 122);
-
-  ENABLE_STEPPER_DRIVER_INTERRUPT();
-
-  sei();
+  #if DISABLED(I2S_STEPPER_STREAM)
+    HAL_timer_start(STEP_TIMER_NUM, 122); // Init Stepper ISR to 122 Hz for quick starting
+    ENABLE_STEPPER_DRIVER_INTERRUPT();
+    sei();
+  #endif
 
   // Init direction bits for first moves
   last_direction_bits = 0

commit 1bd9a630492e0b029c39e4c885c6a1f49dc0c6ee
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 6 04:59:22 2019 -0600

    Add HAS_EXTRA_ENDSTOPS macro

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 970433a732..83de4b9719 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -119,7 +119,7 @@ Stepper stepper; // Singleton
 
 // public:
 
-#if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
+#if HAS_EXTRA_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
   bool Stepper::separate_multi_axis = false;
 #endif
 

commit d4d1b28a06caa57d26e300c1b814b2b8b62120cd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 4 03:41:55 2019 -0600

    Fix some include paths

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 72032dcb60..970433a732 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -89,7 +89,7 @@ Stepper stepper; // Singleton
 #include "planner.h"
 #include "motion.h"
 
-#include "../module/temperature.h"
+#include "temperature.h"
 #include "../lcd/ultralcd.h"
 #include "../core/language.h"
 #include "../gcode/queue.h"

commit 4d1093b3868a37ee0def13dbe2785f3ce98fcf6d
Author: Mark Zachmann <MZachmann@users.noreply.github.com>
Date:   Sun Feb 3 02:29:00 2019 -0500

    Fix init of last_direction_bits (#13067)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 10c524bdc8..72032dcb60 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -129,10 +129,10 @@ Stepper stepper; // Singleton
 
 // private:
 
-block_t* Stepper::current_block = NULL; // A pointer to the block currently being traced
+block_t* Stepper::current_block; // (= NULL) A pointer to the block currently being traced
 
-uint8_t Stepper::last_direction_bits = 0,
-        Stepper::axis_did_move;
+uint8_t Stepper::last_direction_bits, // = 0
+        Stepper::axis_did_move; // = 0
 
 bool Stepper::abort_current_block;
 
@@ -2143,14 +2143,20 @@ void Stepper::init() {
     E_AXIS_INIT(5);
   #endif
 
-  set_directions();
-
   // Init Stepper ISR to 122 Hz for quick starting
   HAL_timer_start(STEP_TIMER_NUM, 122);
 
   ENABLE_STEPPER_DRIVER_INTERRUPT();
 
   sei();
+
+  // Init direction bits for first moves
+  last_direction_bits = 0
+    | (INVERT_X_DIR ? _BV(X_AXIS) : 0)
+    | (INVERT_Y_DIR ? _BV(Y_AXIS) : 0)
+    | (INVERT_Z_DIR ? _BV(Z_AXIS) : 0);
+
+  set_directions();
 }
 
 /**

commit 0da636e1a31ea1b93744425c40efbb8bdd6643a2
Author: jeffstaley <jeffstaley@gmail.com>
Date:   Sun Jan 27 21:02:38 2019 -0800

    Set correct stepper direction on reset (#13032)
    
    On a reset steppers were being initialized to incorrect direction. Original code wasn't respecting `INVERT_Z_DIR` define.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index d067e0a10e..10c524bdc8 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2143,16 +2143,14 @@ void Stepper::init() {
     E_AXIS_INIT(5);
   #endif
 
+  set_directions();
+
   // Init Stepper ISR to 122 Hz for quick starting
   HAL_timer_start(STEP_TIMER_NUM, 122);
 
   ENABLE_STEPPER_DRIVER_INTERRUPT();
 
   sei();
-
-  Z_DIR_WRITE(0);    // Init directions to last_direction_bits = 0  Keeps Z from being reversed
-  Z2_DIR_WRITE(0);
-  Z3_DIR_WRITE(0);
 }
 
 /**

commit 2f35747f294c4b3dc3e6920b34e208f89bd4841d
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Wed Jan 23 19:06:54 2019 -0600

    L6470 SPI daisy chain support (#12895)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index ef2098feee..d067e0a10e 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -79,6 +79,8 @@
 
 #include "stepper.h"
 
+Stepper stepper; // Singleton
+
 #ifdef __AVR__
   #include "speed_lookuptable.h"
 #endif
@@ -107,12 +109,14 @@
   #include "../feature/mixing.h"
 #endif
 
-Stepper stepper; // Singleton
-
 #if FILAMENT_RUNOUT_DISTANCE_MM > 0
   #include "../feature/runout.h"
 #endif
 
+#if HAS_DRIVER(L6470)
+  #include "../libs/L6470/L6470_Marlin.h"
+#endif
+
 // public:
 
 #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
@@ -350,22 +354,28 @@ void Stepper::wake_up() {
  */
 void Stepper::set_directions() {
 
-  #define SET_STEP_DIR(A) \
-    if (motor_direction(_AXIS(A))) { \
-      A##_APPLY_DIR(INVERT_## A##_DIR, false); \
-      count_direction[_AXIS(A)] = -1; \
-    } \
-    else { \
+  #if HAS_DRIVER(L6470)
+    uint8_t L6470_buf[MAX_L6470 + 1];   // chip command sequence - element 0 not used
+  #endif
+
+  #define SET_STEP_DIR(A)                       \
+    if (motor_direction(_AXIS(A))) {            \
+      A##_APPLY_DIR(INVERT_## A##_DIR, false);  \
+      count_direction[_AXIS(A)] = -1;           \
+    }                                           \
+    else {                                      \
       A##_APPLY_DIR(!INVERT_## A##_DIR, false); \
-      count_direction[_AXIS(A)] = 1; \
+      count_direction[_AXIS(A)] = 1;            \
     }
 
   #if HAS_X_DIR
     SET_STEP_DIR(X); // A
   #endif
+
   #if HAS_Y_DIR
     SET_STEP_DIR(Y); // B
   #endif
+
   #if HAS_Z_DIR
     SET_STEP_DIR(Z); // C
   #endif
@@ -394,6 +404,27 @@ void Stepper::set_directions() {
     #endif
   #endif // !LIN_ADVANCE
 
+  #if HAS_DRIVER(L6470)
+
+    if (L6470.spi_active) {
+      L6470.spi_abort = true;                     // interrupted a SPI transfer - need to shut it down gracefully
+      for (uint8_t j = 1; j <= L6470::chain[0]; j++)
+        L6470_buf[j] = dSPIN_NOP;                 // fill buffer with NOOP commands
+      L6470.transfer(L6470_buf, L6470::chain[0]);  // send enough NOOPs to complete any command
+      L6470.transfer(L6470_buf, L6470::chain[0]);
+      L6470.transfer(L6470_buf, L6470::chain[0]);
+    }
+
+    // The L6470.dir_commands[] array holds the direction command for each stepper
+
+    //scan command array and copy matches into L6470.transfer
+    for (uint8_t j = 1; j <= L6470::chain[0]; j++)
+      L6470_buf[j] = L6470.dir_commands[L6470::chain[j]];
+
+    L6470.transfer(L6470_buf, L6470::chain[0]);  // send the command stream to the drivers
+
+  #endif
+
   // A small delay may be needed after changing direction
   #if MINIMUM_STEPPER_DIR_DELAY > 0
     DELAY_NS(MINIMUM_STEPPER_DIR_DELAY);
@@ -1766,10 +1797,15 @@ uint32_t Stepper::stepper_block_phase_isr() {
         else LA_isr_rate = LA_ADV_NEVER;
       #endif
 
-      if (current_block->direction_bits != last_direction_bits
+      if (
+        #if HAS_DRIVER(L6470)
+          true  // Always set direction for L6470 (This also enables the chips)
+        #else
+          current_block->direction_bits != last_direction_bits
           #if DISABLED(MIXING_EXTRUDER)
             || stepper_extruder != last_moved_extruder
           #endif
+        #endif
       ) {
         last_direction_bits = current_block->direction_bits;
         #if EXTRUDERS > 1
@@ -2113,7 +2149,10 @@ void Stepper::init() {
   ENABLE_STEPPER_DRIVER_INTERRUPT();
 
   sei();
-  set_directions(); // Init directions to last_direction_bits = 0  Keeps Z from being reversed
+
+  Z_DIR_WRITE(0);    // Init directions to last_direction_bits = 0  Keeps Z from being reversed
+  Z2_DIR_WRITE(0);
+  Z3_DIR_WRITE(0);
 }
 
 /**

commit cb643d87df16dd54d6e7779fe8565c9be04ec951
Author: TheLongAndOnly <github@mueller-gelff.de>
Date:   Wed Jan 2 01:22:04 2019 +0100

    Adding missing code for triple Z-stepper auto-align (#12786)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 69069562cc..ef2098feee 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -256,6 +256,18 @@ int8_t Stepper::count_direction[NUM_AXIS] = { 0, 0, 0, 0 };
     A##3_STEP_WRITE(V);                                                                                                     \
   }
 
+#define TRIPLE_SEPARATE_APPLY_STEP(A,V)           \
+  if (separate_multi_axis) {                      \
+    if (!locked_##A##_motor) A##_STEP_WRITE(V);   \
+    if (!locked_##A##2_motor) A##2_STEP_WRITE(V); \
+    if (!locked_##A##3_motor) A##3_STEP_WRITE(V); \
+  }                                               \
+  else {                                          \
+    A##_STEP_WRITE(V);                            \
+    A##2_STEP_WRITE(V);                           \
+    A##3_STEP_WRITE(V);                           \
+  }
+
 #if ENABLED(X_DUAL_STEPPER_DRIVERS)
   #define X_APPLY_DIR(v,Q) do{ X_DIR_WRITE(v); X2_DIR_WRITE((v) != INVERT_X2_VS_X_DIR); }while(0)
   #if ENABLED(X_DUAL_ENDSTOPS)
@@ -301,6 +313,8 @@ int8_t Stepper::count_direction[NUM_AXIS] = { 0, 0, 0, 0 };
   #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(v); Z3_DIR_WRITE(v); }while(0)
   #if ENABLED(Z_TRIPLE_ENDSTOPS)
     #define Z_APPLY_STEP(v,Q) TRIPLE_ENDSTOP_APPLY_STEP(Z,v)
+  #elif ENABLED(Z_STEPPER_AUTO_ALIGN)
+    #define Z_APPLY_STEP(v,Q) TRIPLE_SEPARATE_APPLY_STEP(Z,v)
   #else
     #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); Z3_STEP_WRITE(v); }while(0)
   #endif

commit 6cf8d40f418833ac91774d84c806778ef4d6287d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 9 02:32:25 2018 -0600

    Fix some serial echos of pin states

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index e25b4e614d..69069562cc 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2820,74 +2820,74 @@ void Stepper::report_positions() {
   void Stepper::microstep_readings() {
     SERIAL_ECHOPGM("MS1,MS2,MS3 Pins\nX: ");
     #if HAS_X_MICROSTEPS
-      SERIAL_ECHO(READ(X_MS1_PIN));
-      SERIAL_ECHO(READ(X_MS2_PIN));
+      SERIAL_CHAR('0' + READ(X_MS1_PIN));
+      SERIAL_CHAR('0' + READ(X_MS2_PIN));
       #if PIN_EXISTS(X_MS3)
-        SERIAL_ECHOLN(READ(X_MS3_PIN));
+        SERIAL_ECHOLN((int)READ(X_MS3_PIN));
       #endif
     #endif
     #if HAS_Y_MICROSTEPS
       SERIAL_ECHOPGM("Y: ");
-      SERIAL_ECHO(READ(Y_MS1_PIN));
-      SERIAL_ECHO(READ(Y_MS2_PIN));
+      SERIAL_CHAR('0' + READ(Y_MS1_PIN));
+      SERIAL_CHAR('0' + READ(Y_MS2_PIN));
       #if PIN_EXISTS(Y_MS3)
-        SERIAL_ECHOLN(READ(Y_MS3_PIN));
+        SERIAL_ECHOLN((int)READ(Y_MS3_PIN));
       #endif
     #endif
     #if HAS_Z_MICROSTEPS
       SERIAL_ECHOPGM("Z: ");
-      SERIAL_ECHO(READ(Z_MS1_PIN));
-      SERIAL_ECHO(READ(Z_MS2_PIN));
+      SERIAL_CHAR('0' + READ(Z_MS1_PIN));
+      SERIAL_CHAR('0' + READ(Z_MS2_PIN));
       #if PIN_EXISTS(Z_MS3)
-        SERIAL_ECHOLN(READ(Z_MS3_PIN));
+        SERIAL_ECHOLN((int)READ(Z_MS3_PIN));
       #endif
     #endif
     #if HAS_E0_MICROSTEPS
       SERIAL_ECHOPGM("E0: ");
-      SERIAL_ECHO(READ(E0_MS1_PIN));
-      SERIAL_ECHO(READ(E0_MS2_PIN));
+      SERIAL_CHAR('0' + READ(E0_MS1_PIN));
+      SERIAL_CHAR('0' + READ(E0_MS2_PIN));
       #if PIN_EXISTS(E0_MS3)
-        SERIAL_ECHOLN(READ(E0_MS3_PIN));
+        SERIAL_ECHOLN((int)READ(E0_MS3_PIN));
       #endif
     #endif
     #if HAS_E1_MICROSTEPS
       SERIAL_ECHOPGM("E1: ");
-      SERIAL_ECHO(READ(E1_MS1_PIN));
-      SERIAL_ECHO(READ(E1_MS2_PIN));
+      SERIAL_CHAR('0' + READ(E1_MS1_PIN));
+      SERIAL_CHAR('0' + READ(E1_MS2_PIN));
       #if PIN_EXISTS(E1_MS3)
-        SERIAL_ECHOLN(READ(E1_MS3_PIN));
+        SERIAL_ECHOLN((int)READ(E1_MS3_PIN));
       #endif
     #endif
     #if HAS_E2_MICROSTEPS
       SERIAL_ECHOPGM("E2: ");
-      SERIAL_ECHO(READ(E2_MS1_PIN));
-      SERIAL_ECHO(READ(E2_MS2_PIN));
+      SERIAL_CHAR('0' + READ(E2_MS1_PIN));
+      SERIAL_CHAR('0' + READ(E2_MS2_PIN));
       #if PIN_EXISTS(E2_MS3)
-        SERIAL_ECHOLN(READ(E2_MS3_PIN));
+        SERIAL_ECHOLN((int)READ(E2_MS3_PIN));
       #endif
     #endif
     #if HAS_E3_MICROSTEPS
       SERIAL_ECHOPGM("E3: ");
-      SERIAL_ECHO(READ(E3_MS1_PIN));
-      SERIAL_ECHO(READ(E3_MS2_PIN));
+      SERIAL_CHAR('0' + READ(E3_MS1_PIN));
+      SERIAL_CHAR('0' + READ(E3_MS2_PIN));
       #if PIN_EXISTS(E3_MS3)
-        SERIAL_ECHOLN(READ(E3_MS3_PIN));
+        SERIAL_ECHOLN((int)READ(E3_MS3_PIN));
       #endif
     #endif
     #if HAS_E4_MICROSTEPS
       SERIAL_ECHOPGM("E4: ");
-      SERIAL_ECHO(READ(E4_MS1_PIN));
-      SERIAL_ECHO(READ(E4_MS2_PIN));
+      SERIAL_CHAR('0' + READ(E4_MS1_PIN));
+      SERIAL_CHAR('0' + READ(E4_MS2_PIN));
       #if PIN_EXISTS(E4_MS3)
-        SERIAL_ECHOLN(READ(E4_MS3_PIN));
+        SERIAL_ECHOLN((int)READ(E4_MS3_PIN));
       #endif
     #endif
     #if HAS_E5_MICROSTEPS
       SERIAL_ECHOPGM("E5: ");
-      SERIAL_ECHO(READ(E5_MS1_PIN));
-      SERIAL_ECHOLN(READ(E5_MS2_PIN));
+      SERIAL_CHAR('0' + READ(E5_MS1_PIN));
+      SERIAL_ECHOLN((int)READ(E5_MS2_PIN));
       #if PIN_EXISTS(E5_MS3)
-        SERIAL_ECHOLN(READ(E5_MS3_PIN));
+        SERIAL_ECHOLN((int)READ(E5_MS3_PIN));
       #endif
     #endif
   }

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index e9593730c3..e25b4e614d 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2218,25 +2218,25 @@ void Stepper::report_positions() {
   if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
 
   #if CORE_IS_XY || CORE_IS_XZ || ENABLED(DELTA) || IS_SCARA
-    SERIAL_PROTOCOLPGM(MSG_COUNT_A);
+    SERIAL_ECHOPGM(MSG_COUNT_A);
   #else
-    SERIAL_PROTOCOLPGM(MSG_COUNT_X);
+    SERIAL_ECHOPGM(MSG_COUNT_X);
   #endif
-  SERIAL_PROTOCOL(xpos);
+  SERIAL_ECHO(xpos);
 
   #if CORE_IS_XY || CORE_IS_YZ || ENABLED(DELTA) || IS_SCARA
-    SERIAL_PROTOCOLPGM(" B:");
+    SERIAL_ECHOPGM(" B:");
   #else
-    SERIAL_PROTOCOLPGM(" Y:");
+    SERIAL_ECHOPGM(" Y:");
   #endif
-  SERIAL_PROTOCOL(ypos);
+  SERIAL_ECHO(ypos);
 
   #if CORE_IS_XZ || CORE_IS_YZ || ENABLED(DELTA)
-    SERIAL_PROTOCOLPGM(" C:");
+    SERIAL_ECHOPGM(" C:");
   #else
-    SERIAL_PROTOCOLPGM(" Z:");
+    SERIAL_ECHOPGM(" Z:");
   #endif
-  SERIAL_PROTOCOL(zpos);
+  SERIAL_ECHO(zpos);
 
   SERIAL_EOL();
 }
@@ -2813,82 +2813,81 @@ void Stepper::report_positions() {
         case 128: microstep_ms(driver, MICROSTEP128); break;
       #endif
 
-      default: SERIAL_ERROR_START(); SERIAL_ERRORLNPGM("Microsteps unavailable"); break;
+      default: SERIAL_ERROR_MSG("Microsteps unavailable"); break;
     }
   }
 
   void Stepper::microstep_readings() {
-    SERIAL_PROTOCOLLNPGM("MS1,MS2,MS3 Pins");
-    SERIAL_PROTOCOLPGM("X: ");
+    SERIAL_ECHOPGM("MS1,MS2,MS3 Pins\nX: ");
     #if HAS_X_MICROSTEPS
-      SERIAL_PROTOCOL(READ(X_MS1_PIN));
-      SERIAL_PROTOCOL(READ(X_MS2_PIN));
+      SERIAL_ECHO(READ(X_MS1_PIN));
+      SERIAL_ECHO(READ(X_MS2_PIN));
       #if PIN_EXISTS(X_MS3)
-        SERIAL_PROTOCOLLN(READ(X_MS3_PIN));
+        SERIAL_ECHOLN(READ(X_MS3_PIN));
       #endif
     #endif
     #if HAS_Y_MICROSTEPS
-      SERIAL_PROTOCOLPGM("Y: ");
-      SERIAL_PROTOCOL(READ(Y_MS1_PIN));
-      SERIAL_PROTOCOL(READ(Y_MS2_PIN));
+      SERIAL_ECHOPGM("Y: ");
+      SERIAL_ECHO(READ(Y_MS1_PIN));
+      SERIAL_ECHO(READ(Y_MS2_PIN));
       #if PIN_EXISTS(Y_MS3)
-        SERIAL_PROTOCOLLN(READ(Y_MS3_PIN));
+        SERIAL_ECHOLN(READ(Y_MS3_PIN));
       #endif
     #endif
     #if HAS_Z_MICROSTEPS
-      SERIAL_PROTOCOLPGM("Z: ");
-      SERIAL_PROTOCOL(READ(Z_MS1_PIN));
-      SERIAL_PROTOCOL(READ(Z_MS2_PIN));
+      SERIAL_ECHOPGM("Z: ");
+      SERIAL_ECHO(READ(Z_MS1_PIN));
+      SERIAL_ECHO(READ(Z_MS2_PIN));
       #if PIN_EXISTS(Z_MS3)
-        SERIAL_PROTOCOLLN(READ(Z_MS3_PIN));
+        SERIAL_ECHOLN(READ(Z_MS3_PIN));
       #endif
     #endif
     #if HAS_E0_MICROSTEPS
-      SERIAL_PROTOCOLPGM("E0: ");
-      SERIAL_PROTOCOL(READ(E0_MS1_PIN));
-      SERIAL_PROTOCOL(READ(E0_MS2_PIN));
+      SERIAL_ECHOPGM("E0: ");
+      SERIAL_ECHO(READ(E0_MS1_PIN));
+      SERIAL_ECHO(READ(E0_MS2_PIN));
       #if PIN_EXISTS(E0_MS3)
-        SERIAL_PROTOCOLLN(READ(E0_MS3_PIN));
+        SERIAL_ECHOLN(READ(E0_MS3_PIN));
       #endif
     #endif
     #if HAS_E1_MICROSTEPS
-      SERIAL_PROTOCOLPGM("E1: ");
-      SERIAL_PROTOCOL(READ(E1_MS1_PIN));
-      SERIAL_PROTOCOL(READ(E1_MS2_PIN));
+      SERIAL_ECHOPGM("E1: ");
+      SERIAL_ECHO(READ(E1_MS1_PIN));
+      SERIAL_ECHO(READ(E1_MS2_PIN));
       #if PIN_EXISTS(E1_MS3)
-        SERIAL_PROTOCOLLN(READ(E1_MS3_PIN));
+        SERIAL_ECHOLN(READ(E1_MS3_PIN));
       #endif
     #endif
     #if HAS_E2_MICROSTEPS
-      SERIAL_PROTOCOLPGM("E2: ");
-      SERIAL_PROTOCOL(READ(E2_MS1_PIN));
-      SERIAL_PROTOCOL(READ(E2_MS2_PIN));
+      SERIAL_ECHOPGM("E2: ");
+      SERIAL_ECHO(READ(E2_MS1_PIN));
+      SERIAL_ECHO(READ(E2_MS2_PIN));
       #if PIN_EXISTS(E2_MS3)
-        SERIAL_PROTOCOLLN(READ(E2_MS3_PIN));
+        SERIAL_ECHOLN(READ(E2_MS3_PIN));
       #endif
     #endif
     #if HAS_E3_MICROSTEPS
-      SERIAL_PROTOCOLPGM("E3: ");
-      SERIAL_PROTOCOL(READ(E3_MS1_PIN));
-      SERIAL_PROTOCOL(READ(E3_MS2_PIN));
+      SERIAL_ECHOPGM("E3: ");
+      SERIAL_ECHO(READ(E3_MS1_PIN));
+      SERIAL_ECHO(READ(E3_MS2_PIN));
       #if PIN_EXISTS(E3_MS3)
-        SERIAL_PROTOCOLLN(READ(E3_MS3_PIN));
+        SERIAL_ECHOLN(READ(E3_MS3_PIN));
       #endif
     #endif
     #if HAS_E4_MICROSTEPS
-      SERIAL_PROTOCOLPGM("E4: ");
-      SERIAL_PROTOCOL(READ(E4_MS1_PIN));
-      SERIAL_PROTOCOL(READ(E4_MS2_PIN));
+      SERIAL_ECHOPGM("E4: ");
+      SERIAL_ECHO(READ(E4_MS1_PIN));
+      SERIAL_ECHO(READ(E4_MS2_PIN));
       #if PIN_EXISTS(E4_MS3)
-        SERIAL_PROTOCOLLN(READ(E4_MS3_PIN));
+        SERIAL_ECHOLN(READ(E4_MS3_PIN));
       #endif
     #endif
     #if HAS_E5_MICROSTEPS
-      SERIAL_PROTOCOLPGM("E5: ");
-      SERIAL_PROTOCOL(READ(E5_MS1_PIN));
-      SERIAL_PROTOCOLLN(READ(E5_MS2_PIN));
+      SERIAL_ECHOPGM("E5: ");
+      SERIAL_ECHO(READ(E5_MS1_PIN));
+      SERIAL_ECHOLN(READ(E5_MS2_PIN));
       #if PIN_EXISTS(E5_MS3)
-        SERIAL_PROTOCOLLN(READ(E5_MS3_PIN));
+        SERIAL_ECHOLN(READ(E5_MS3_PIN));
       #endif
     #endif
   }

commit edfd106bc5d7bc02ef5e55445ffb3dbaf48b0226
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 14 11:45:57 2018 -0600

    Rejigger Filament Runout class (#12428)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index e5bc14f36e..e9593730c3 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1492,7 +1492,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
     // If current block is finished, reset pointer
     if (step_events_completed >= step_event_count) {
       #if FILAMENT_RUNOUT_DISTANCE_MM > 0
-        runout.block_complete(current_block);
+        runout.block_completed(current_block);
       #endif
       axis_did_move = 0;
       current_block = NULL;

commit 052d102ded293e7ad96739c7ba1b0662fc64388f
Author: Ryan <allted@gmail.com>
Date:   Tue Nov 13 22:27:39 2018 -0800

    UltiMachine Archim 1 support (#12404)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 811a09bb7a..e5bc14f36e 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2407,13 +2407,13 @@ void Stepper::report_positions() {
   void Stepper::refresh_motor_power() {
     LOOP_L_N(i, COUNT(motor_current_setting)) {
       switch (i) {
-        #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY) || PIN_EXISTS(MOTOR_CURRENT_PWM_X) || PIN_EXISTS(MOTOR_CURRENT_PWM_Y)
           case 0:
         #endif
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
           case 1:
         #endif
-        #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_E) || PIN_EXISTS(MOTOR_CURRENT_PWM_E0) || PIN_EXISTS(MOTOR_CURRENT_PWM_E1)
           case 2:
         #endif
             digipot_current(i, motor_current_setting[i]);
@@ -2426,7 +2426,7 @@ void Stepper::report_positions() {
 
 #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
 
-  void Stepper::digipot_current(const uint8_t driver, const int current) {
+  void Stepper::digipot_current(const uint8_t driver, const int16_t current) {
 
     #if HAS_DIGIPOTSS
 
@@ -2440,15 +2440,33 @@ void Stepper::report_positions() {
 
       #define _WRITE_CURRENT_PWM(P) analogWrite(MOTOR_CURRENT_PWM_## P ##_PIN, 255L * current / (MOTOR_CURRENT_PWM_RANGE))
       switch (driver) {
-        #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
-          case 0: _WRITE_CURRENT_PWM(XY); break;
-        #endif
-        #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
-          case 1: _WRITE_CURRENT_PWM(Z); break;
-        #endif
-        #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
-          case 2: _WRITE_CURRENT_PWM(E); break;
-        #endif
+        case 0:
+          #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)
+            _WRITE_CURRENT_PWM(X);
+          #endif
+          #if PIN_EXISTS(MOTOR_CURRENT_PWM_Y)
+            _WRITE_CURRENT_PWM(Y);
+          #endif
+          #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
+            _WRITE_CURRENT_PWM(XY);
+          #endif
+          break;
+        case 1:
+          #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
+            _WRITE_CURRENT_PWM(Z);
+          #endif
+          break;
+        case 2:
+          #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
+            _WRITE_CURRENT_PWM(E);
+          #endif
+          #if PIN_EXISTS(MOTOR_CURRENT_PWM_E0)
+            _WRITE_CURRENT_PWM(E0);
+          #endif
+          #if PIN_EXISTS(MOTOR_CURRENT_PWM_E1)
+            _WRITE_CURRENT_PWM(E1);
+          #endif
+          break;
       }
     #endif
   }
@@ -2469,6 +2487,12 @@ void Stepper::report_positions() {
 
     #elif HAS_MOTOR_CURRENT_PWM
 
+      #if PIN_EXISTS(MOTOR_CURRENT_PWM_X)
+        SET_OUTPUT(MOTOR_CURRENT_PWM_X_PIN);
+      #endif
+      #if PIN_EXISTS(MOTOR_CURRENT_PWM_Y)
+        SET_OUTPUT(MOTOR_CURRENT_PWM_Y_PIN);
+      #endif
       #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
         SET_OUTPUT(MOTOR_CURRENT_PWM_XY_PIN);
       #endif
@@ -2478,12 +2502,19 @@ void Stepper::report_positions() {
       #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
         SET_OUTPUT(MOTOR_CURRENT_PWM_E_PIN);
       #endif
+      #if PIN_EXISTS(MOTOR_CURRENT_PWM_E0)
+        SET_OUTPUT(MOTOR_CURRENT_PWM_E0_PIN);
+      #endif
+      #if PIN_EXISTS(MOTOR_CURRENT_PWM_E1)
+        SET_OUTPUT(MOTOR_CURRENT_PWM_E1_PIN);
+      #endif
 
       refresh_motor_power();
 
       // Set Timer5 to 31khz so the PWM of the motor power is as constant as possible. (removes a buzzing noise)
-      SET_CS5(PRESCALER_1);
-
+      #ifdef __AVR__
+        SET_CS5(PRESCALER_1);
+      #endif
     #endif
   }
 
@@ -2587,6 +2618,7 @@ void Stepper::report_positions() {
         SET_OUTPUT(E5_MS3_PIN);
       #endif
     #endif
+
     static const uint8_t microstep_modes[] = MICROSTEP_MODES;
     for (uint16_t i = 0; i < COUNT(microstep_modes); i++)
       microstep_mode(i, microstep_modes[i]);

commit 9da6809ac30e1e3db0ccfa39164e02fa65b773c1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 11 11:28:29 2018 -0600

    Adjust some comment spacing

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4c560f52d3..811a09bb7a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -590,29 +590,29 @@ void Stepper::set_directions() {
    *        uint16_t t;
    *        umul24x24to16hi(t, bezier_AV, curr_step);   // t: Range 0 - 1^16 = 16 bits
    *        uint16_t f = t;
-   *        umul16x16to16hi(f, f, t);           // Range 16 bits (unsigned)
-   *        umul16x16to16hi(f, f, t);           // Range 16 bits : f = t^3  (unsigned)
-   *        uint24_t acc = bezier_F;          // Range 20 bits (unsigned)
+   *        umul16x16to16hi(f, f, t);                   // Range 16 bits (unsigned)
+   *        umul16x16to16hi(f, f, t);                   // Range 16 bits : f = t^3  (unsigned)
+   *        uint24_t acc = bezier_F;                    // Range 20 bits (unsigned)
    *        if (A_negative) {
    *          uint24_t v;
-   *          umul16x24to24hi(v, f, bezier_C);    // Range 21bits
+   *          umul16x24to24hi(v, f, bezier_C);          // Range 21bits
    *          acc -= v;
-   *          umul16x16to16hi(f, f, t);         // Range 16 bits : f = t^4  (unsigned)
-   *          umul16x24to24hi(v, f, bezier_B);    // Range 22bits
+   *          umul16x16to16hi(f, f, t);                 // Range 16 bits : f = t^4  (unsigned)
+   *          umul16x24to24hi(v, f, bezier_B);          // Range 22bits
    *          acc += v;
-   *          umul16x16to16hi(f, f, t);         // Range 16 bits : f = t^5  (unsigned)
-   *          umul16x24to24hi(v, f, bezier_A);    // Range 21bits + 15 = 36bits (plus sign)
+   *          umul16x16to16hi(f, f, t);                 // Range 16 bits : f = t^5  (unsigned)
+   *          umul16x24to24hi(v, f, bezier_A);          // Range 21bits + 15 = 36bits (plus sign)
    *          acc -= v;
    *        }
    *        else {
    *          uint24_t v;
-   *          umul16x24to24hi(v, f, bezier_C);    // Range 21bits
+   *          umul16x24to24hi(v, f, bezier_C);          // Range 21bits
    *          acc += v;
-   *          umul16x16to16hi(f, f, t);       // Range 16 bits : f = t^4  (unsigned)
-   *          umul16x24to24hi(v, f, bezier_B);    // Range 22bits
+   *          umul16x16to16hi(f, f, t);                 // Range 16 bits : f = t^4  (unsigned)
+   *          umul16x24to24hi(v, f, bezier_B);          // Range 22bits
    *          acc -= v;
-   *          umul16x16to16hi(f, f, t);               // Range 16 bits : f = t^5  (unsigned)
-   *          umul16x24to24hi(v, f, bezier_A);    // Range 21bits + 15 = 36bits (plus sign)
+   *          umul16x16to16hi(f, f, t);                 // Range 16 bits : f = t^5  (unsigned)
+   *          umul16x24to24hi(v, f, bezier_A);          // Range 21bits + 15 = 36bits (plus sign)
    *          acc += v;
    *        }
    *        return acc;

commit 5182eaf661d148b841e0034d4337241fdca2b36f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 4 20:51:54 2018 -0600

    Fix endstops enable behavior during probing
    
    Fix a bug introduced in #9582

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index f86b514798..4c560f52d3 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2098,7 +2098,6 @@ void Stepper::init() {
 
   ENABLE_STEPPER_DRIVER_INTERRUPT();
 
-  endstops.enable(true); // Start with endstops active. After homing they can be disabled
   sei();
   set_directions(); // Init directions to last_direction_bits = 0  Keeps Z from being reversed
 }

commit e0956bb5724a18485c98e79fe1c05a758a9251c2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 4 16:17:13 2018 -0600

    Drop 'register' storage specifier

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 6a1beec94c..f86b514798 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -498,14 +498,14 @@ void Stepper::set_directions() {
    *        rhi = int32_t((mul >> 32) & 0xFFFFFFFF);
    *      }
    *      int32_t _eval_bezier_curve_arm(uint32_t curr_step) {
-   *        register uint32_t flo = 0;
-   *        register uint32_t fhi = bezier_AV * curr_step;
-   *        register uint32_t t = fhi;
-   *        register int32_t alo = bezier_F;
-   *        register int32_t ahi = 0;
-   *        register int32_t A = bezier_A;
-   *        register int32_t B = bezier_B;
-   *        register int32_t C = bezier_C;
+   *        uint32_t flo = 0;
+   *        uint32_t fhi = bezier_AV * curr_step;
+   *        uint32_t t = fhi;
+   *        int32_t alo = bezier_F;
+   *        int32_t ahi = 0;
+   *        int32_t A = bezier_A;
+   *        int32_t B = bezier_B;
+   *        int32_t C = bezier_C;
    *
    *        lsrs(ahi, alo, 1);          // a  = F << 31
    *        lsls(alo, alo, 31);         //
@@ -630,13 +630,13 @@ void Stepper::set_directions() {
       bezier_AV = av;
 
       // Calculate the rest of the coefficients
-      register uint8_t r2 = v0 & 0xFF;
-      register uint8_t r3 = (v0 >> 8) & 0xFF;
-      register uint8_t r12 = (v0 >> 16) & 0xFF;
-      register uint8_t r5 = v1 & 0xFF;
-      register uint8_t r6 = (v1 >> 8) & 0xFF;
-      register uint8_t r7 = (v1 >> 16) & 0xFF;
-      register uint8_t r4,r8,r9,r10,r11;
+      uint8_t r2 = v0 & 0xFF;
+      uint8_t r3 = (v0 >> 8) & 0xFF;
+      uint8_t r12 = (v0 >> 16) & 0xFF;
+      uint8_t r5 = v1 & 0xFF;
+      uint8_t r6 = (v1 >> 8) & 0xFF;
+      uint8_t r7 = (v1 >> 16) & 0xFF;
+      uint8_t r4,r8,r9,r10,r11;
 
       __asm__ __volatile__(
         /* Calculate the Bézier coefficients */
@@ -732,11 +732,11 @@ void Stepper::set_directions() {
       if (!curr_step)
         return bezier_F;
 
-      register uint8_t r0 = 0; /* Zero register */
-      register uint8_t r2 = (curr_step) & 0xFF;
-      register uint8_t r3 = (curr_step >> 8) & 0xFF;
-      register uint8_t r4 = (curr_step >> 16) & 0xFF;
-      register uint8_t r1,r5,r6,r7,r8,r9,r10,r11; /* Temporary registers */
+      uint8_t r0 = 0; /* Zero register */
+      uint8_t r2 = (curr_step) & 0xFF;
+      uint8_t r3 = (curr_step >> 8) & 0xFF;
+      uint8_t r4 = (curr_step >> 16) & 0xFF;
+      uint8_t r1,r5,r6,r7,r8,r9,r10,r11; /* Temporary registers */
 
       __asm__ __volatile(
         /* umul24x24to16hi(t, bezier_AV, curr_step);  t: Range 0 - 1^16 = 16 bits*/
@@ -1127,14 +1127,14 @@ void Stepper::set_directions() {
       #if defined(__ARM__) || defined(__thumb__)
 
         // For ARM Cortex M3/M4 CPUs, we have the optimized assembler version, that takes 43 cycles to execute
-        register uint32_t flo = 0;
-        register uint32_t fhi = bezier_AV * curr_step;
-        register uint32_t t = fhi;
-        register int32_t alo = bezier_F;
-        register int32_t ahi = 0;
-        register int32_t A = bezier_A;
-        register int32_t B = bezier_B;
-        register int32_t C = bezier_C;
+        uint32_t flo = 0;
+        uint32_t fhi = bezier_AV * curr_step;
+        uint32_t t = fhi;
+        int32_t alo = bezier_F;
+        int32_t ahi = 0;
+        int32_t A = bezier_A;
+        int32_t B = bezier_B;
+        int32_t C = bezier_C;
 
          __asm__ __volatile__(
           ".syntax unified" "\n\t"              // is to prevent CM0,CM1 non-unified syntax

commit 6e3caf23b6773a16a11c83b03c8a9463733534e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 3 03:48:36 2018 -0500

    IS_DELTA => ENABLED(DELTA)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 065aba8270..6a1beec94c 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2218,21 +2218,21 @@ void Stepper::report_positions() {
 
   if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
 
-  #if CORE_IS_XY || CORE_IS_XZ || IS_DELTA || IS_SCARA
+  #if CORE_IS_XY || CORE_IS_XZ || ENABLED(DELTA) || IS_SCARA
     SERIAL_PROTOCOLPGM(MSG_COUNT_A);
   #else
     SERIAL_PROTOCOLPGM(MSG_COUNT_X);
   #endif
   SERIAL_PROTOCOL(xpos);
 
-  #if CORE_IS_XY || CORE_IS_YZ || IS_DELTA || IS_SCARA
+  #if CORE_IS_XY || CORE_IS_YZ || ENABLED(DELTA) || IS_SCARA
     SERIAL_PROTOCOLPGM(" B:");
   #else
     SERIAL_PROTOCOLPGM(" Y:");
   #endif
   SERIAL_PROTOCOL(ypos);
 
-  #if CORE_IS_XZ || CORE_IS_YZ || IS_DELTA
+  #if CORE_IS_XZ || CORE_IS_YZ || ENABLED(DELTA)
     SERIAL_PROTOCOLPGM(" C:");
   #else
     SERIAL_PROTOCOLPGM(" Z:");

commit 553622835911b520c6ba43bc03e71868f3972cb3
Author: TheLongAndOnly <github@mueller-gelff.de>
Date:   Mon Oct 29 20:01:36 2018 +0100

    G34 Auto-align multi-stepper Z axis (#11302)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index e8b9e42c3b..065aba8270 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -115,7 +115,7 @@ Stepper stepper; // Singleton
 
 // public:
 
-#if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+#if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
   bool Stepper::separate_multi_axis = false;
 #endif
 
@@ -142,10 +142,10 @@ bool Stepper::abort_current_block;
 #if ENABLED(Y_DUAL_ENDSTOPS)
   bool Stepper::locked_Y_motor = false, Stepper::locked_Y2_motor = false;
 #endif
-#if Z_MULTI_ENDSTOPS
+#if Z_MULTI_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
   bool Stepper::locked_Z_motor = false, Stepper::locked_Z2_motor = false;
 #endif
-#if ENABLED(Z_TRIPLE_ENDSTOPS)
+#if ENABLED(Z_TRIPLE_ENDSTOPS) || (ENABLED(Z_STEPPER_AUTO_ALIGN) && ENABLED(Z_TRIPLE_STEPPER_DRIVERS))
   bool Stepper::locked_Z3_motor = false;
 #endif
 
@@ -211,7 +211,7 @@ volatile int32_t Stepper::endstops_trigsteps[XYZ];
 volatile int32_t Stepper::count_position[NUM_AXIS] = { 0 };
 int8_t Stepper::count_direction[NUM_AXIS] = { 0, 0, 0, 0 };
 
-#define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                       \
+#define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                        \
   if (separate_multi_axis) {                                                                                                \
     if (A##_HOME_DIR < 0) {                                                                                                 \
       if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
@@ -227,7 +227,17 @@ int8_t Stepper::count_direction[NUM_AXIS] = { 0, 0, 0, 0 };
     A##2_STEP_WRITE(V);                                                                                                     \
   }
 
-#define TRIPLE_ENDSTOP_APPLY_STEP(A,V)                                                                                       \
+#define DUAL_SEPARATE_APPLY_STEP(A,V)             \
+  if (separate_multi_axis) {                      \
+    if (!locked_##A##_motor) A##_STEP_WRITE(V);   \
+    if (!locked_##A##2_motor) A##2_STEP_WRITE(V); \
+  }                                               \
+  else {                                          \
+    A##_STEP_WRITE(V);                            \
+    A##2_STEP_WRITE(V);                           \
+  }
+
+#define TRIPLE_ENDSTOP_APPLY_STEP(A,V)                                                                                      \
   if (separate_multi_axis) {                                                                                                \
     if (A##_HOME_DIR < 0) {                                                                                                 \
       if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
@@ -298,6 +308,8 @@ int8_t Stepper::count_direction[NUM_AXIS] = { 0, 0, 0, 0 };
   #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(v); }while(0)
   #if ENABLED(Z_DUAL_ENDSTOPS)
     #define Z_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Z,v)
+  #elif ENABLED(Z_STEPPER_AUTO_ALIGN)
+    #define Z_APPLY_STEP(v,Q) DUAL_SEPARATE_APPLY_STEP(Z,v)
   #else
     #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); }while(0)
   #endif

commit aebbb2359dfc771f818d8633452113c4e21ca2fa
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Oct 24 17:40:06 2018 -0400

    Fix IDEX homing X0 wrong direction (#12200)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 5f2dc0ca72..e8b9e42c3b 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1746,10 +1746,10 @@ uint32_t Stepper::stepper_block_phase_isr() {
           #endif
       ) {
         last_direction_bits = current_block->direction_bits;
-        set_directions();
         #if EXTRUDERS > 1
           last_moved_extruder = stepper_extruder;
         #endif
+        set_directions();
       }
 
       // At this point, we must ensure the movement about to execute isn't

commit 3a3ab3391ff56e165d2062d3b53a2f8b9cc3b486
Author: forkoz <lactduup@grr.la>
Date:   Mon Oct 22 19:30:51 2018 -0500

    Return set_directions() to stepper.cpp (#12182)
    
    Initial manual Z move can be negative if your stepper is inverted. Leads to bad situations for crashed or initially booted printers.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index d224114b9a..5f2dc0ca72 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2088,6 +2088,7 @@ void Stepper::init() {
 
   endstops.enable(true); // Start with endstops active. After homing they can be disabled
   sei();
+  set_directions(); // Init directions to last_direction_bits = 0  Keeps Z from being reversed
 }
 
 /**

commit d82bcdeea1971c759d71926c993c5a94a823b021
Author: AnHardt <github@kitelab.de>
Date:   Wed Oct 17 16:52:57 2018 +0200

    Make PULSE_STOP(E) conditional (#12121)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 2ff1e583c6..d224114b9a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1443,7 +1443,9 @@ void Stepper::stepper_pulse_phase_isr() {
           E_STEP_WRITE(mixer.get_stepper(), INVERT_E_STEP_PIN);
         }
       #else // !MIXING_EXTRUDER
-        PULSE_STOP(E);
+        #if HAS_E0_STEP
+          PULSE_STOP(E);
+        #endif
       #endif
     #endif // !LIN_ADVANCE
 

commit c90e26dfa6bf0a25e3094a94ea86931b844fb7f5
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Wed Oct 17 08:47:31 2018 +0100

    fix normal extruder stepping (#12118)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 9ec5d6804a..2ff1e583c6 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1412,7 +1412,7 @@ void Stepper::stepper_pulse_phase_isr() {
         #endif
       }
     #else // !LIN_ADVANCE && !MIXING_EXTRUDER
-      #if HAS_E_STEP
+      #if HAS_E0_STEP
         PULSE_START(E);
       #endif
     #endif

commit 056561df935f47ecfabc16e2ed777f3754be837c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Oct 16 06:28:52 2018 -0600

    [2.0.x] Enhancements to FILAMENT_RUNOUT_SENSOR (#12069)
    
    - Added FILAMENT_RUNOUT_DISTANCE_MM option
    - Added FILAMENT_MOTION_SENSOR option

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index a49b6173fc..9ec5d6804a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -109,6 +109,10 @@
 
 Stepper stepper; // Singleton
 
+#if FILAMENT_RUNOUT_DISTANCE_MM > 0
+  #include "../feature/runout.h"
+#endif
+
 // public:
 
 #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
@@ -1473,6 +1477,9 @@ uint32_t Stepper::stepper_block_phase_isr() {
 
     // If current block is finished, reset pointer
     if (step_events_completed >= step_event_count) {
+      #if FILAMENT_RUNOUT_DISTANCE_MM > 0
+        runout.block_complete(current_block);
+      #endif
       axis_did_move = 0;
       current_block = NULL;
       planner.discard_current_block();

commit f56968ba0b8d4eaccbc9b0c7834cf0cd2f5872d8
Author: AnHardt <github@kitelab.de>
Date:   Tue Oct 16 10:38:57 2018 +0200

    New Continuous Filament Mixer (#12098)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index e080bfb347..a49b6173fc 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -103,6 +103,10 @@
   #include <SPI.h>
 #endif
 
+#if ENABLED(MIXING_EXTRUDER)
+  #include "../feature/mixing.h"
+#endif
+
 Stepper stepper; // Singleton
 
 // public:
@@ -158,12 +162,10 @@ uint32_t Stepper::advance_dividend[XYZE] = { 0 },
          Stepper::decelerate_after,          // The point from where we need to start decelerating
          Stepper::step_event_count;          // The total event count for the current block
 
-#if ENABLED(MIXING_EXTRUDER)
-  int32_t Stepper::delta_error_m[MIXING_STEPPERS];
-  uint32_t Stepper::advance_dividend_m[MIXING_STEPPERS],
-           Stepper::advance_divisor_m;
-#elif EXTRUDERS > 1
-  uint8_t Stepper::active_extruder;          // Active extruder
+#if EXTRUDERS > 1 || ENABLED(MIXING_EXTRUDER)
+  uint8_t Stepper::stepper_extruder;
+#else
+  constexpr uint8_t Stepper::stepper_extruder;
 #endif
 
 #if ENABLED(S_CURVE_ACCELERATION)
@@ -301,7 +303,7 @@ int8_t Stepper::count_direction[NUM_AXIS] = { 0, 0, 0, 0 };
 #endif
 
 #if DISABLED(MIXING_EXTRUDER)
-  #define E_APPLY_STEP(v,Q) E_STEP_WRITE(active_extruder, v)
+  #define E_APPLY_STEP(v,Q) E_STEP_WRITE(stepper_extruder, v)
 #endif
 
 void Stepper::wake_up() {
@@ -340,21 +342,23 @@ void Stepper::set_directions() {
 
   #if DISABLED(LIN_ADVANCE)
     #if ENABLED(MIXING_EXTRUDER)
+       // Because this is valid for the whole block we don't know
+       // what e-steppers will step. Likely all. Set all.
       if (motor_direction(E_AXIS)) {
-        MIXING_STEPPERS_LOOP(j) REV_E_DIR(j);
+        MIXER_STEPPER_LOOP(j) REV_E_DIR(j);
         count_direction[E_AXIS] = -1;
       }
       else {
-        MIXING_STEPPERS_LOOP(j) NORM_E_DIR(j);
+        MIXER_STEPPER_LOOP(j) NORM_E_DIR(j);
         count_direction[E_AXIS] = 1;
       }
     #else
       if (motor_direction(E_AXIS)) {
-        REV_E_DIR(active_extruder);
+        REV_E_DIR(stepper_extruder);
         count_direction[E_AXIS] = -1;
       }
       else {
-        NORM_E_DIR(active_extruder);
+        NORM_E_DIR(stepper_extruder);
         count_direction[E_AXIS] = 1;
       }
     #endif
@@ -1387,39 +1391,27 @@ void Stepper::stepper_pulse_phase_isr() {
       PULSE_START(Z);
     #endif
 
-    // Pulse E/Mixing extruders
-    #if ENABLED(LIN_ADVANCE)
-      // Tick the E axis, correct error term and update position
+    // Pulse Extruders
+    // Tick the E axis, correct error term and update position
+    #if ENABLED(LIN_ADVANCE) || ENABLED(MIXING_EXTRUDER)
       delta_error[E_AXIS] += advance_dividend[E_AXIS];
       if (delta_error[E_AXIS] >= 0) {
         count_position[E_AXIS] += count_direction[E_AXIS];
-        delta_error[E_AXIS] -= advance_divisor;
-
-        // Don't step E here - But remember the number of steps to perform
-        motor_direction(E_AXIS) ? --LA_steps : ++LA_steps;
-      }
-    #else // !LIN_ADVANCE - use linear interpolation for E also
-      #if ENABLED(MIXING_EXTRUDER)
-
-        // Tick the E axis
-        delta_error[E_AXIS] += advance_dividend[E_AXIS];
-        if (delta_error[E_AXIS] >= 0) {
-          count_position[E_AXIS] += count_direction[E_AXIS];
+        #if ENABLED(LIN_ADVANCE)
           delta_error[E_AXIS] -= advance_divisor;
-        }
-
-        // Tick the counters used for this mix in proper proportion
-        MIXING_STEPPERS_LOOP(j) {
-          // Step mixing steppers (proportionally)
-          delta_error_m[j] += advance_dividend_m[j];
-          // Step when the counter goes over zero
-          if (delta_error_m[j] >= 0) E_STEP_WRITE(j, !INVERT_E_STEP_PIN);
-        }
-
-      #else // !MIXING_EXTRUDER
+          // Don't step E here - But remember the number of steps to perform
+          motor_direction(E_AXIS) ? --LA_steps : ++LA_steps;
+        #else // !LIN_ADVANCE && MIXING_EXTRUDER
+          // Don't adjust delta_error[E_AXIS] here!
+          // Being positive is the criteria for ending the pulse.
+          E_STEP_WRITE(mixer.get_next_stepper(), !INVERT_E_STEP_PIN);
+        #endif
+      }
+    #else // !LIN_ADVANCE && !MIXING_EXTRUDER
+      #if HAS_E_STEP
         PULSE_START(E);
       #endif
-    #endif // !LIN_ADVANCE
+    #endif
 
     #if MINIMUM_STEPPER_PULSE
       // Just wait for the requested pulse duration
@@ -1442,11 +1434,9 @@ void Stepper::stepper_pulse_phase_isr() {
 
     #if DISABLED(LIN_ADVANCE)
       #if ENABLED(MIXING_EXTRUDER)
-        MIXING_STEPPERS_LOOP(j) {
-          if (delta_error_m[j] >= 0) {
-            delta_error_m[j] -= advance_divisor_m;
-            E_STEP_WRITE(j, INVERT_E_STEP_PIN);
-          }
+        if (delta_error[E_AXIS] >= 0) {
+          delta_error[E_AXIS] -= advance_divisor;
+          E_STEP_WRITE(mixer.get_stepper(), INVERT_E_STEP_PIN);
         }
       #else // !MIXING_EXTRUDER
         PULSE_STOP(E);
@@ -1717,27 +1707,18 @@ uint32_t Stepper::stepper_block_phase_isr() {
       decelerate_after = current_block->decelerate_after << oversampling;
 
       #if ENABLED(MIXING_EXTRUDER)
-        const uint32_t e_steps = (
-          #if ENABLED(LIN_ADVANCE)
-            current_block->steps[E_AXIS]
-          #else
-            step_event_count
-          #endif
-        );
-        MIXING_STEPPERS_LOOP(i) {
-          delta_error_m[i] = -int32_t(e_steps);
-          advance_dividend_m[i] = current_block->mix_steps[i] << 1;
-        }
-        advance_divisor_m = e_steps << 1;
-      #elif EXTRUDERS > 1
-        active_extruder = current_block->active_extruder;
+        MIXER_STEPPER_SETUP();
+      #endif
+
+      #if EXTRUDERS > 1
+        stepper_extruder = current_block->extruder;
       #endif
 
       // Initialize the trapezoid generator from the current block.
       #if ENABLED(LIN_ADVANCE)
         #if DISABLED(MIXING_EXTRUDER) && E_STEPPERS > 1
           // If the now active extruder wasn't in use during the last move, its pressure is most likely gone.
-          if (active_extruder != last_moved_extruder) LA_current_adv_steps = 0;
+          if (stepper_extruder != last_moved_extruder) LA_current_adv_steps = 0;
         #endif
 
         if ((LA_use_advance_lead = current_block->use_advance_lead)) {
@@ -1751,15 +1732,15 @@ uint32_t Stepper::stepper_block_phase_isr() {
       #endif
 
       if (current_block->direction_bits != last_direction_bits
-        #if DISABLED(MIXING_EXTRUDER)
-          || active_extruder != last_moved_extruder
-        #endif
+          #if DISABLED(MIXING_EXTRUDER)
+            || stepper_extruder != last_moved_extruder
+          #endif
       ) {
         last_direction_bits = current_block->direction_bits;
-        #if DISABLED(MIXING_EXTRUDER) && EXTRUDERS > 1
-          last_moved_extruder = active_extruder;
-        #endif
         set_directions();
+        #if EXTRUDERS > 1
+          last_moved_extruder = stepper_extruder;
+        #endif
       }
 
       // At this point, we must ensure the movement about to execute isn't
@@ -1827,15 +1808,17 @@ uint32_t Stepper::stepper_block_phase_isr() {
       interval = LA_ADV_NEVER;
 
       #if ENABLED(MIXING_EXTRUDER)
+        // We don't know which steppers will be stepped because LA loop follows,
+        // with potentially multiple steps. Set all.
         if (LA_steps >= 0)
-          MIXING_STEPPERS_LOOP(j) NORM_E_DIR(j);
+          MIXER_STEPPER_LOOP(j) NORM_E_DIR(j);
         else
-          MIXING_STEPPERS_LOOP(j) REV_E_DIR(j);
+          MIXER_STEPPER_LOOP(j) REV_E_DIR(j);
       #else
         if (LA_steps >= 0)
-          NORM_E_DIR(active_extruder);
+          NORM_E_DIR(stepper_extruder);
         else
-          REV_E_DIR(active_extruder);
+          REV_E_DIR(stepper_extruder);
       #endif
 
     // Get the timer count and estimate the end of the pulse
@@ -1848,14 +1831,9 @@ uint32_t Stepper::stepper_block_phase_isr() {
 
       // Set the STEP pulse ON
       #if ENABLED(MIXING_EXTRUDER)
-        MIXING_STEPPERS_LOOP(j) {
-          // Step mixing steppers (proportionally)
-          delta_error_m[j] += advance_dividend_m[j];
-          // Step when the counter goes over zero
-          if (delta_error_m[j] >= 0) E_STEP_WRITE(j, !INVERT_E_STEP_PIN);
-        }
+        E_STEP_WRITE(mixer.get_next_stepper(), !INVERT_E_STEP_PIN);
       #else
-        E_STEP_WRITE(active_extruder, !INVERT_E_STEP_PIN);
+        E_STEP_WRITE(stepper_extruder, !INVERT_E_STEP_PIN);
       #endif
 
       // Enforce a minimum duration for STEP pulse ON
@@ -1871,14 +1849,9 @@ uint32_t Stepper::stepper_block_phase_isr() {
 
       // Set the STEP pulse OFF
       #if ENABLED(MIXING_EXTRUDER)
-        MIXING_STEPPERS_LOOP(j) {
-          if (delta_error_m[j] >= 0) {
-            delta_error_m[j] -= advance_divisor_m;
-            E_STEP_WRITE(j, INVERT_E_STEP_PIN);
-          }
-        }
+        E_STEP_WRITE(mixer.get_stepper(), INVERT_E_STEP_PIN);
       #else
-        E_STEP_WRITE(active_extruder, INVERT_E_STEP_PIN);
+        E_STEP_WRITE(stepper_extruder, INVERT_E_STEP_PIN);
       #endif
 
       // For minimum pulse time wait before looping
@@ -2106,8 +2079,6 @@ void Stepper::init() {
 
   endstops.enable(true); // Start with endstops active. After homing they can be disabled
   sei();
-
-  set_directions(); // Init directions to last_direction_bits = 0
 }
 
 /**

commit ddaef1a60c5e01576509d3c79a83b750fefd6969
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 11 21:40:55 2018 -0500

    Clean trailing whitespace

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index d3ce5b70a0..e080bfb347 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2552,7 +2552,7 @@ void Stepper::report_positions() {
       #if PIN_EXISTS(Z3_MS3)
         SET_OUTPUT(Z3_MS3_PIN);
       #endif
-    #endif    
+    #endif
     #if HAS_E0_MICROSTEPS
       SET_OUTPUT(E0_MS1_PIN);
       SET_OUTPUT(E0_MS2_PIN);
@@ -2758,7 +2758,7 @@ void Stepper::report_positions() {
       #endif
       #if HAS_E5_MICROSTEPS && PIN_EXISTS(E5_MS3)
         case 8: WRITE(E5_MS3_PIN, ms3); break;
-      #endif    
+      #endif
     }
   }
 
@@ -2865,7 +2865,7 @@ void Stepper::report_positions() {
       SERIAL_PROTOCOLLN(READ(E5_MS2_PIN));
       #if PIN_EXISTS(E5_MS3)
         SERIAL_PROTOCOLLN(READ(E5_MS3_PIN));
-      #endif      
+      #endif
     #endif
   }
 

commit 45e738876ac3b08af1b702d87435899005c043bc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 11 00:56:26 2018 -0500

    Add stepper MS3 support
    
    Co-Authored-By: TheLongAndOnly <thelongandonly@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index ed7ef07931..d3ce5b70a0 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2504,53 +2504,136 @@ void Stepper::report_positions() {
    */
 
   void Stepper::microstep_init() {
-    SET_OUTPUT(X_MS1_PIN);
-    SET_OUTPUT(X_MS2_PIN);
+    #if HAS_X_MICROSTEPS
+      SET_OUTPUT(X_MS1_PIN);
+      SET_OUTPUT(X_MS2_PIN);
+      #if PIN_EXISTS(X_MS3)
+        SET_OUTPUT(X_MS3_PIN);
+      #endif
+    #endif
+    #if HAS_X2_MICROSTEPS
+      SET_OUTPUT(X2_MS1_PIN);
+      SET_OUTPUT(X2_MS2_PIN);
+      #if PIN_EXISTS(X2_MS3)
+        SET_OUTPUT(X2_MS3_PIN);
+      #endif
+    #endif
     #if HAS_Y_MICROSTEPS
       SET_OUTPUT(Y_MS1_PIN);
       SET_OUTPUT(Y_MS2_PIN);
+      #if PIN_EXISTS(Y_MS3)
+        SET_OUTPUT(Y_MS3_PIN);
+      #endif
+    #endif
+    #if HAS_Y2_MICROSTEPS
+      SET_OUTPUT(Y2_MS1_PIN);
+      SET_OUTPUT(Y2_MS2_PIN);
+      #if PIN_EXISTS(Y2_MS3)
+        SET_OUTPUT(Y2_MS3_PIN);
+      #endif
     #endif
     #if HAS_Z_MICROSTEPS
       SET_OUTPUT(Z_MS1_PIN);
       SET_OUTPUT(Z_MS2_PIN);
+      #if PIN_EXISTS(Z_MS3)
+        SET_OUTPUT(Z_MS3_PIN);
+      #endif
+    #endif
+    #if HAS_Z2_MICROSTEPS
+      SET_OUTPUT(Z2_MS1_PIN);
+      SET_OUTPUT(Z2_MS2_PIN);
+      #if PIN_EXISTS(Z2_MS3)
+        SET_OUTPUT(Z2_MS3_PIN);
+      #endif
     #endif
+    #if HAS_Z3_MICROSTEPS
+      SET_OUTPUT(Z3_MS1_PIN);
+      SET_OUTPUT(Z3_MS2_PIN);
+      #if PIN_EXISTS(Z3_MS3)
+        SET_OUTPUT(Z3_MS3_PIN);
+      #endif
+    #endif    
     #if HAS_E0_MICROSTEPS
       SET_OUTPUT(E0_MS1_PIN);
       SET_OUTPUT(E0_MS2_PIN);
+      #if PIN_EXISTS(E0_MS3)
+        SET_OUTPUT(E0_MS3_PIN);
+      #endif
     #endif
     #if HAS_E1_MICROSTEPS
       SET_OUTPUT(E1_MS1_PIN);
       SET_OUTPUT(E1_MS2_PIN);
+      #if PIN_EXISTS(E1_MS3)
+        SET_OUTPUT(E1_MS3_PIN);
+      #endif
     #endif
     #if HAS_E2_MICROSTEPS
       SET_OUTPUT(E2_MS1_PIN);
       SET_OUTPUT(E2_MS2_PIN);
+      #if PIN_EXISTS(E2_MS3)
+        SET_OUTPUT(E2_MS3_PIN);
+      #endif
     #endif
     #if HAS_E3_MICROSTEPS
       SET_OUTPUT(E3_MS1_PIN);
       SET_OUTPUT(E3_MS2_PIN);
+      #if PIN_EXISTS(E3_MS3)
+        SET_OUTPUT(E3_MS3_PIN);
+      #endif
     #endif
     #if HAS_E4_MICROSTEPS
       SET_OUTPUT(E4_MS1_PIN);
       SET_OUTPUT(E4_MS2_PIN);
+      #if PIN_EXISTS(E4_MS3)
+        SET_OUTPUT(E4_MS3_PIN);
+      #endif
     #endif
     #if HAS_E5_MICROSTEPS
       SET_OUTPUT(E5_MS1_PIN);
       SET_OUTPUT(E5_MS2_PIN);
+      #if PIN_EXISTS(E5_MS3)
+        SET_OUTPUT(E5_MS3_PIN);
+      #endif
     #endif
     static const uint8_t microstep_modes[] = MICROSTEP_MODES;
     for (uint16_t i = 0; i < COUNT(microstep_modes); i++)
       microstep_mode(i, microstep_modes[i]);
   }
 
-  void Stepper::microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2) {
+  void Stepper::microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2, const int8_t ms3) {
     if (ms1 >= 0) switch (driver) {
-      case 0: WRITE(X_MS1_PIN, ms1); break;
-      #if HAS_Y_MICROSTEPS
-        case 1: WRITE(Y_MS1_PIN, ms1); break;
+      #if HAS_X_MICROSTEPS || HAS_X2_MICROSTEPS
+        case 0:
+          #if HAS_X_MICROSTEPS
+            WRITE(X_MS1_PIN, ms1);
+          #endif
+          #if HAS_X2_MICROSTEPS
+            WRITE(X2_MS1_PIN, ms1);
+          #endif
+          break;
       #endif
-      #if HAS_Z_MICROSTEPS
-        case 2: WRITE(Z_MS1_PIN, ms1); break;
+      #if HAS_Y_MICROSTEPS || HAS_Y2_MICROSTEPS
+        case 1:
+          #if HAS_Y_MICROSTEPS
+            WRITE(Y_MS1_PIN, ms1);
+          #endif
+          #if HAS_Y2_MICROSTEPS
+            WRITE(Y2_MS1_PIN, ms1);
+          #endif
+          break;
+      #endif
+      #if HAS_Z_MICROSTEPS || HAS_Z2_MICROSTEPS || HAS_Z3_MICROSTEPS
+        case 2:
+          #if HAS_Z_MICROSTEPS
+            WRITE(Z_MS1_PIN, ms1);
+          #endif
+          #if HAS_Z2_MICROSTEPS
+            WRITE(Z2_MS1_PIN, ms1);
+          #endif
+          #if HAS_Z3_MICROSTEPS
+            WRITE(Z3_MS1_PIN, ms1);
+          #endif
+          break;
       #endif
       #if HAS_E0_MICROSTEPS
         case 3: WRITE(E0_MS1_PIN, ms1); break;
@@ -2572,12 +2655,38 @@ void Stepper::report_positions() {
       #endif
     }
     if (ms2 >= 0) switch (driver) {
-      case 0: WRITE(X_MS2_PIN, ms2); break;
-      #if HAS_Y_MICROSTEPS
-        case 1: WRITE(Y_MS2_PIN, ms2); break;
+      #if HAS_X_MICROSTEPS || HAS_X2_MICROSTEPS
+        case 0:
+          #if HAS_X_MICROSTEPS
+            WRITE(X_MS2_PIN, ms2);
+          #endif
+          #if HAS_X2_MICROSTEPS
+            WRITE(X2_MS2_PIN, ms2);
+          #endif
+          break;
+      #endif
+      #if HAS_Y_MICROSTEPS || HAS_Y2_MICROSTEPS
+        case 1:
+          #if HAS_Y_MICROSTEPS
+            WRITE(Y_MS2_PIN, ms2);
+          #endif
+          #if HAS_Y2_MICROSTEPS
+            WRITE(Y2_MS2_PIN, ms2);
+          #endif
+          break;
       #endif
-      #if HAS_Z_MICROSTEPS
-        case 2: WRITE(Z_MS2_PIN, ms2); break;
+      #if HAS_Z_MICROSTEPS || HAS_Z2_MICROSTEPS || HAS_Z3_MICROSTEPS
+        case 2:
+          #if HAS_Z_MICROSTEPS
+            WRITE(Z_MS2_PIN, ms2);
+          #endif
+          #if HAS_Z2_MICROSTEPS
+            WRITE(Z2_MS2_PIN, ms2);
+          #endif
+          #if HAS_Z3_MICROSTEPS
+            WRITE(Z3_MS2_PIN, ms2);
+          #endif
+          break;
       #endif
       #if HAS_E0_MICROSTEPS
         case 3: WRITE(E0_MS2_PIN, ms2); break;
@@ -2598,70 +2707,165 @@ void Stepper::report_positions() {
         case 8: WRITE(E5_MS2_PIN, ms2); break;
       #endif
     }
+    if (ms3 >= 0) switch (driver) {
+      #if HAS_X_MICROSTEPS || HAS_X2_MICROSTEPS
+        case 0:
+          #if HAS_X_MICROSTEPS && PIN_EXISTS(X_MS3)
+            WRITE(X_MS3_PIN, ms3);
+          #endif
+          #if HAS_X2_MICROSTEPS && PIN_EXISTS(X2_MS3)
+            WRITE(X2_MS3_PIN, ms3);
+          #endif
+          break;
+      #endif
+      #if HAS_Y_MICROSTEPS || HAS_Y2_MICROSTEPS
+        case 1:
+          #if HAS_Y_MICROSTEPS && PIN_EXISTS(Y_MS3)
+            WRITE(Y_MS3_PIN, ms3);
+          #endif
+          #if HAS_Y2_MICROSTEPS && PIN_EXISTS(Y2_MS3)
+            WRITE(Y2_MS3_PIN, ms3);
+          #endif
+          break;
+      #endif
+      #if HAS_Z_MICROSTEPS || HAS_Z2_MICROSTEPS || HAS_Z3_MICROSTEPS
+        case 2:
+          #if HAS_Z_MICROSTEPS && PIN_EXISTS(Z_MS3)
+            WRITE(Z_MS3_PIN, ms3);
+          #endif
+          #if HAS_Z2_MICROSTEPS && PIN_EXISTS(Z2_MS3)
+            WRITE(Z2_MS3_PIN, ms3);
+          #endif
+          #if HAS_Z3_MICROSTEPS && PIN_EXISTS(Z3_MS3)
+            WRITE(Z3_MS3_PIN, ms3);
+          #endif
+          break;
+      #endif
+      #if HAS_E0_MICROSTEPS && PIN_EXISTS(E0_MS3)
+        case 3: WRITE(E0_MS3_PIN, ms3); break;
+      #endif
+      #if HAS_E1_MICROSTEPS && PIN_EXISTS(E1_MS3)
+        case 4: WRITE(E1_MS3_PIN, ms3); break;
+      #endif
+      #if HAS_E2_MICROSTEPS && PIN_EXISTS(E2_MS3)
+        case 5: WRITE(E2_MS3_PIN, ms3); break;
+      #endif
+      #if HAS_E3_MICROSTEPS && PIN_EXISTS(E3_MS3)
+        case 6: WRITE(E3_MS3_PIN, ms3); break;
+      #endif
+      #if HAS_E4_MICROSTEPS && PIN_EXISTS(E4_MS3)
+        case 7: WRITE(E4_MS3_PIN, ms3); break;
+      #endif
+      #if HAS_E5_MICROSTEPS && PIN_EXISTS(E5_MS3)
+        case 8: WRITE(E5_MS3_PIN, ms3); break;
+      #endif    
+    }
   }
 
   void Stepper::microstep_mode(const uint8_t driver, const uint8_t stepping_mode) {
     switch (stepping_mode) {
-      case 1: microstep_ms(driver, MICROSTEP1); break;
-      #if ENABLED(HEROIC_STEPPER_DRIVERS)
-        case 128: microstep_ms(driver, MICROSTEP128); break;
-      #else
+      #if HAS_MICROSTEP1
+        case 1: microstep_ms(driver, MICROSTEP1); break;
+      #endif
+      #if HAS_MICROSTEP2
         case 2: microstep_ms(driver, MICROSTEP2); break;
+      #endif
+      #if HAS_MICROSTEP4
         case 4: microstep_ms(driver, MICROSTEP4); break;
       #endif
-      case 8: microstep_ms(driver, MICROSTEP8); break;
-      case 16: microstep_ms(driver, MICROSTEP16); break;
-      #if MB(ALLIGATOR)
+      #if HAS_MICROSTEP8
+        case 8: microstep_ms(driver, MICROSTEP8); break;
+      #endif
+      #if HAS_MICROSTEP16
+        case 16: microstep_ms(driver, MICROSTEP16); break;
+      #endif
+      #if HAS_MICROSTEP32
         case 32: microstep_ms(driver, MICROSTEP32); break;
       #endif
+      #if HAS_MICROSTEP64
+        case 64: microstep_ms(driver, MICROSTEP64); break;
+      #endif
+      #if HAS_MICROSTEP128
+        case 128: microstep_ms(driver, MICROSTEP128); break;
+      #endif
+
       default: SERIAL_ERROR_START(); SERIAL_ERRORLNPGM("Microsteps unavailable"); break;
     }
   }
 
   void Stepper::microstep_readings() {
-    SERIAL_PROTOCOLLNPGM("MS1,MS2 Pins");
+    SERIAL_PROTOCOLLNPGM("MS1,MS2,MS3 Pins");
     SERIAL_PROTOCOLPGM("X: ");
-    SERIAL_PROTOCOL(READ(X_MS1_PIN));
-    SERIAL_PROTOCOLLN(READ(X_MS2_PIN));
+    #if HAS_X_MICROSTEPS
+      SERIAL_PROTOCOL(READ(X_MS1_PIN));
+      SERIAL_PROTOCOL(READ(X_MS2_PIN));
+      #if PIN_EXISTS(X_MS3)
+        SERIAL_PROTOCOLLN(READ(X_MS3_PIN));
+      #endif
+    #endif
     #if HAS_Y_MICROSTEPS
       SERIAL_PROTOCOLPGM("Y: ");
       SERIAL_PROTOCOL(READ(Y_MS1_PIN));
-      SERIAL_PROTOCOLLN(READ(Y_MS2_PIN));
+      SERIAL_PROTOCOL(READ(Y_MS2_PIN));
+      #if PIN_EXISTS(Y_MS3)
+        SERIAL_PROTOCOLLN(READ(Y_MS3_PIN));
+      #endif
     #endif
     #if HAS_Z_MICROSTEPS
       SERIAL_PROTOCOLPGM("Z: ");
       SERIAL_PROTOCOL(READ(Z_MS1_PIN));
-      SERIAL_PROTOCOLLN(READ(Z_MS2_PIN));
+      SERIAL_PROTOCOL(READ(Z_MS2_PIN));
+      #if PIN_EXISTS(Z_MS3)
+        SERIAL_PROTOCOLLN(READ(Z_MS3_PIN));
+      #endif
     #endif
     #if HAS_E0_MICROSTEPS
       SERIAL_PROTOCOLPGM("E0: ");
       SERIAL_PROTOCOL(READ(E0_MS1_PIN));
-      SERIAL_PROTOCOLLN(READ(E0_MS2_PIN));
+      SERIAL_PROTOCOL(READ(E0_MS2_PIN));
+      #if PIN_EXISTS(E0_MS3)
+        SERIAL_PROTOCOLLN(READ(E0_MS3_PIN));
+      #endif
     #endif
     #if HAS_E1_MICROSTEPS
       SERIAL_PROTOCOLPGM("E1: ");
       SERIAL_PROTOCOL(READ(E1_MS1_PIN));
-      SERIAL_PROTOCOLLN(READ(E1_MS2_PIN));
+      SERIAL_PROTOCOL(READ(E1_MS2_PIN));
+      #if PIN_EXISTS(E1_MS3)
+        SERIAL_PROTOCOLLN(READ(E1_MS3_PIN));
+      #endif
     #endif
     #if HAS_E2_MICROSTEPS
       SERIAL_PROTOCOLPGM("E2: ");
       SERIAL_PROTOCOL(READ(E2_MS1_PIN));
-      SERIAL_PROTOCOLLN(READ(E2_MS2_PIN));
+      SERIAL_PROTOCOL(READ(E2_MS2_PIN));
+      #if PIN_EXISTS(E2_MS3)
+        SERIAL_PROTOCOLLN(READ(E2_MS3_PIN));
+      #endif
     #endif
     #if HAS_E3_MICROSTEPS
       SERIAL_PROTOCOLPGM("E3: ");
       SERIAL_PROTOCOL(READ(E3_MS1_PIN));
-      SERIAL_PROTOCOLLN(READ(E3_MS2_PIN));
+      SERIAL_PROTOCOL(READ(E3_MS2_PIN));
+      #if PIN_EXISTS(E3_MS3)
+        SERIAL_PROTOCOLLN(READ(E3_MS3_PIN));
+      #endif
     #endif
     #if HAS_E4_MICROSTEPS
       SERIAL_PROTOCOLPGM("E4: ");
       SERIAL_PROTOCOL(READ(E4_MS1_PIN));
-      SERIAL_PROTOCOLLN(READ(E4_MS2_PIN));
+      SERIAL_PROTOCOL(READ(E4_MS2_PIN));
+      #if PIN_EXISTS(E4_MS3)
+        SERIAL_PROTOCOLLN(READ(E4_MS3_PIN));
+      #endif
     #endif
     #if HAS_E5_MICROSTEPS
       SERIAL_PROTOCOLPGM("E5: ");
       SERIAL_PROTOCOL(READ(E5_MS1_PIN));
       SERIAL_PROTOCOLLN(READ(E5_MS2_PIN));
+      #if PIN_EXISTS(E5_MS3)
+        SERIAL_PROTOCOLLN(READ(E5_MS3_PIN));
+      #endif      
     #endif
   }
 

commit d556dc18650e2185791834d7fe70b4acf45254bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 10 09:45:20 2018 -0500

    Fix and improve EEPROM storage (#12054)
    
    * Clean up Temperature PID
    * Improve EEPROM read/write/validate
    * Group `SINGLENOZZLE` saved settings
    * Group planner saved settings
    * Group filament change saved settings
    * Group skew saved settings
    * Group `FWRETRACT` saved settings

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 76c068977f..ed7ef07931 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2413,7 +2413,7 @@ void Stepper::report_positions() {
 #if HAS_MOTOR_CURRENT_PWM
 
   void Stepper::refresh_motor_power() {
-    for (uint8_t i = 0; i < COUNT(motor_current_setting); ++i) {
+    LOOP_L_N(i, COUNT(motor_current_setting)) {
       switch (i) {
         #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
           case 0:
@@ -2443,7 +2443,7 @@ void Stepper::report_positions() {
 
     #elif HAS_MOTOR_CURRENT_PWM
 
-      if (WITHIN(driver, 0, 2))
+      if (WITHIN(driver, 0, COUNT(motor_current_setting) - 1))
         motor_current_setting[driver] = current; // update motor_current_setting
 
       #define _WRITE_CURRENT_PWM(P) analogWrite(MOTOR_CURRENT_PWM_## P ##_PIN, 255L * current / (MOTOR_CURRENT_PWM_RANGE))

commit 0780913848eea5048947808dfcc9143131f094d3
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Mon Sep 17 01:06:22 2018 -0500

    IDEX Improvements (#11848)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index a83fbd85b0..76c068977f 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -251,7 +251,7 @@ int8_t Stepper::count_direction[NUM_AXIS] = { 0, 0, 0, 0 };
   #define X_APPLY_DIR(v,ALWAYS) \
     if (extruder_duplication_enabled || ALWAYS) { \
       X_DIR_WRITE(v); \
-      X2_DIR_WRITE(bool(v)); \
+      X2_DIR_WRITE(v); \
     } \
     else { \
       if (movement_extruder()) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \

commit 1718eff54adefc7cc95851f28df0c7e02eae3a36
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 13 01:35:55 2018 -0500

    Code changes supporting up to 6 extruders

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 9bcf62501c..a83fbd85b0 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1982,6 +1982,9 @@ void Stepper::init() {
   #if HAS_E4_DIR
     E4_DIR_INIT;
   #endif
+  #if HAS_E5_DIR
+    E5_DIR_INIT;
+  #endif
 
   // Init Enable Pins - steppers default to disabled.
   #if HAS_X_ENABLE
@@ -2032,6 +2035,10 @@ void Stepper::init() {
     E4_ENABLE_INIT;
     if (!E_ENABLE_ON) E4_ENABLE_WRITE(HIGH);
   #endif
+  #if HAS_E5_ENABLE
+    E5_ENABLE_INIT;
+    if (!E_ENABLE_ON) E5_ENABLE_WRITE(HIGH);
+  #endif
 
   #define _STEP_INIT(AXIS) AXIS ##_STEP_INIT
   #define _WRITE_STEP(AXIS, HIGHLOW) AXIS ##_STEP_WRITE(HIGHLOW)
@@ -2088,6 +2095,9 @@ void Stepper::init() {
   #if E_STEPPERS > 4 && HAS_E4_STEP
     E_AXIS_INIT(4);
   #endif
+  #if E_STEPPERS > 5 && HAS_E5_STEP
+    E_AXIS_INIT(5);
+  #endif
 
   // Init Stepper ISR to 122 Hz for quick starting
   HAL_timer_start(STEP_TIMER_NUM, 122);
@@ -2524,6 +2534,10 @@ void Stepper::report_positions() {
       SET_OUTPUT(E4_MS1_PIN);
       SET_OUTPUT(E4_MS2_PIN);
     #endif
+    #if HAS_E5_MICROSTEPS
+      SET_OUTPUT(E5_MS1_PIN);
+      SET_OUTPUT(E5_MS2_PIN);
+    #endif
     static const uint8_t microstep_modes[] = MICROSTEP_MODES;
     for (uint16_t i = 0; i < COUNT(microstep_modes); i++)
       microstep_mode(i, microstep_modes[i]);
@@ -2553,6 +2567,9 @@ void Stepper::report_positions() {
       #if HAS_E4_MICROSTEPS
         case 7: WRITE(E4_MS1_PIN, ms1); break;
       #endif
+      #if HAS_E5_MICROSTEPS
+        case 8: WRITE(E5_MS1_PIN, ms1); break;
+      #endif
     }
     if (ms2 >= 0) switch (driver) {
       case 0: WRITE(X_MS2_PIN, ms2); break;
@@ -2577,6 +2594,9 @@ void Stepper::report_positions() {
       #if HAS_E4_MICROSTEPS
         case 7: WRITE(E4_MS2_PIN, ms2); break;
       #endif
+      #if HAS_E5_MICROSTEPS
+        case 8: WRITE(E5_MS2_PIN, ms2); break;
+      #endif
     }
   }
 
@@ -2638,6 +2658,11 @@ void Stepper::report_positions() {
       SERIAL_PROTOCOL(READ(E4_MS1_PIN));
       SERIAL_PROTOCOLLN(READ(E4_MS2_PIN));
     #endif
+    #if HAS_E5_MICROSTEPS
+      SERIAL_PROTOCOLPGM("E5: ");
+      SERIAL_PROTOCOL(READ(E5_MS1_PIN));
+      SERIAL_PROTOCOLLN(READ(E5_MS2_PIN));
+    #endif
   }
 
 #endif // HAS_MICROSTEPS

commit 1a6f2b29b8dd3bc8e6ef56d4f376f49cacfc8785
Author: Holger Müller <holger@mueller-gelff.de>
Date:   Tue Jun 19 18:55:49 2018 +0200

    Add support for Triple-Z steppers/endstops

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b7ccbb33e2..9bcf62501c 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -107,8 +107,8 @@ Stepper stepper; // Singleton
 
 // public:
 
-#if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
-  bool Stepper::homing_dual_axis = false;
+#if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+  bool Stepper::separate_multi_axis = false;
 #endif
 
 #if HAS_MOTOR_CURRENT_PWM
@@ -134,9 +134,12 @@ bool Stepper::abort_current_block;
 #if ENABLED(Y_DUAL_ENDSTOPS)
   bool Stepper::locked_Y_motor = false, Stepper::locked_Y2_motor = false;
 #endif
-#if ENABLED(Z_DUAL_ENDSTOPS)
+#if Z_MULTI_ENDSTOPS
   bool Stepper::locked_Z_motor = false, Stepper::locked_Z2_motor = false;
 #endif
+#if ENABLED(Z_TRIPLE_ENDSTOPS)
+  bool Stepper::locked_Z3_motor = false;
+#endif
 
 uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
 uint8_t Stepper::steps_per_isr;
@@ -202,23 +205,40 @@ volatile int32_t Stepper::endstops_trigsteps[XYZ];
 volatile int32_t Stepper::count_position[NUM_AXIS] = { 0 };
 int8_t Stepper::count_direction[NUM_AXIS] = { 0, 0, 0, 0 };
 
-#if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
-  #define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                        \
-    if (homing_dual_axis) {                                                                                                   \
-      if (A##_HOME_DIR < 0) {                                                                                                 \
-        if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
-        if (!(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
-      }                                                                                                                       \
-      else {                                                                                                                  \
-        if (!(TEST(endstops.state(), A##_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
-        if (!(TEST(endstops.state(), A##2_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
-      }                                                                                                                       \
-    }                                                                                                                         \
-    else {                                                                                                                    \
-      A##_STEP_WRITE(V);                                                                                                      \
-      A##2_STEP_WRITE(V);                                                                                                     \
-    }
-#endif
+#define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                       \
+  if (separate_multi_axis) {                                                                                                \
+    if (A##_HOME_DIR < 0) {                                                                                                 \
+      if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
+      if (!(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
+    }                                                                                                                       \
+    else {                                                                                                                  \
+      if (!(TEST(endstops.state(), A##_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
+      if (!(TEST(endstops.state(), A##2_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
+    }                                                                                                                       \
+  }                                                                                                                         \
+  else {                                                                                                                    \
+    A##_STEP_WRITE(V);                                                                                                      \
+    A##2_STEP_WRITE(V);                                                                                                     \
+  }
+
+#define TRIPLE_ENDSTOP_APPLY_STEP(A,V)                                                                                       \
+  if (separate_multi_axis) {                                                                                                \
+    if (A##_HOME_DIR < 0) {                                                                                                 \
+      if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
+      if (!(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
+      if (!(TEST(endstops.state(), A##3_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##3_motor) A##3_STEP_WRITE(V); \
+    }                                                                                                                       \
+    else {                                                                                                                  \
+      if (!(TEST(endstops.state(), A##_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
+      if (!(TEST(endstops.state(), A##2_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
+      if (!(TEST(endstops.state(), A##3_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##3_motor) A##3_STEP_WRITE(V); \
+    }                                                                                                                       \
+  }                                                                                                                         \
+  else {                                                                                                                    \
+    A##_STEP_WRITE(V);                                                                                                      \
+    A##2_STEP_WRITE(V);                                                                                                     \
+    A##3_STEP_WRITE(V);                                                                                                     \
+  }
 
 #if ENABLED(X_DUAL_STEPPER_DRIVERS)
   #define X_APPLY_DIR(v,Q) do{ X_DIR_WRITE(v); X2_DIR_WRITE((v) != INVERT_X2_VS_X_DIR); }while(0)
@@ -261,7 +281,14 @@ int8_t Stepper::count_direction[NUM_AXIS] = { 0, 0, 0, 0 };
   #define Y_APPLY_STEP(v,Q) Y_STEP_WRITE(v)
 #endif
 
-#if ENABLED(Z_DUAL_STEPPER_DRIVERS)
+#if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+  #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(v); Z3_DIR_WRITE(v); }while(0)
+  #if ENABLED(Z_TRIPLE_ENDSTOPS)
+    #define Z_APPLY_STEP(v,Q) TRIPLE_ENDSTOP_APPLY_STEP(Z,v)
+  #else
+    #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); Z3_STEP_WRITE(v); }while(0)
+  #endif
+#elif ENABLED(Z_DUAL_STEPPER_DRIVERS)
   #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(v); }while(0)
   #if ENABLED(Z_DUAL_ENDSTOPS)
     #define Z_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Z,v)
@@ -1933,9 +1960,12 @@ void Stepper::init() {
   #endif
   #if HAS_Z_DIR
     Z_DIR_INIT;
-    #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_DIR
+    #if Z_MULTI_STEPPER_DRIVERS && HAS_Z2_DIR
       Z2_DIR_INIT;
     #endif
+    #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS) && HAS_Z3_DIR
+      Z3_DIR_INIT;
+    #endif
   #endif
   #if HAS_E0_DIR
     E0_DIR_INIT;
@@ -1973,10 +2003,14 @@ void Stepper::init() {
   #if HAS_Z_ENABLE
     Z_ENABLE_INIT;
     if (!Z_ENABLE_ON) Z_ENABLE_WRITE(HIGH);
-    #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_ENABLE
+    #if Z_MULTI_STEPPER_DRIVERS && HAS_Z2_ENABLE
       Z2_ENABLE_INIT;
       if (!Z_ENABLE_ON) Z2_ENABLE_WRITE(HIGH);
     #endif
+    #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS) && HAS_Z3_ENABLE
+      Z3_ENABLE_INIT;
+      if (!Z_ENABLE_ON) Z3_ENABLE_WRITE(HIGH);
+    #endif
   #endif
   #if HAS_E0_ENABLE
     E0_ENABLE_INIT;
@@ -2028,10 +2062,14 @@ void Stepper::init() {
   #endif
 
   #if HAS_Z_STEP
-    #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
+    #if Z_MULTI_STEPPER_DRIVERS
       Z2_STEP_INIT;
       Z2_STEP_WRITE(INVERT_Z_STEP_PIN);
     #endif
+    #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+      Z3_STEP_INIT;
+      Z3_STEP_WRITE(INVERT_Z_STEP_PIN);
+    #endif
     AXIS_INIT(Z, Z);
   #endif
 

commit d882717d98d08ba7a47234eacf291b2d82288f13
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 10 23:09:26 2018 -0500

    Save some PROGMEM with constexpr (#11798)
    
    When possible, make `active_extruder` a `constexpr` to save some PROGMEM.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index bff01abae0..b7ccbb33e2 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -124,7 +124,7 @@ uint8_t Stepper::last_direction_bits = 0,
 
 bool Stepper::abort_current_block;
 
-#if DISABLED(MIXING_EXTRUDER)
+#if DISABLED(MIXING_EXTRUDER) && EXTRUDERS > 1
   uint8_t Stepper::last_moved_extruder = 0xFF;
 #endif
 
@@ -159,8 +159,8 @@ uint32_t Stepper::advance_dividend[XYZE] = { 0 },
   int32_t Stepper::delta_error_m[MIXING_STEPPERS];
   uint32_t Stepper::advance_dividend_m[MIXING_STEPPERS],
            Stepper::advance_divisor_m;
-#else
-  int8_t Stepper::active_extruder;           // Active extruder
+#elif EXTRUDERS > 1
+  uint8_t Stepper::active_extruder;          // Active extruder
 #endif
 
 #if ENABLED(S_CURVE_ACCELERATION)
@@ -1702,7 +1702,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
           advance_dividend_m[i] = current_block->mix_steps[i] << 1;
         }
         advance_divisor_m = e_steps << 1;
-      #else
+      #elif EXTRUDERS > 1
         active_extruder = current_block->active_extruder;
       #endif
 
@@ -1729,7 +1729,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
         #endif
       ) {
         last_direction_bits = current_block->direction_bits;
-        #if DISABLED(MIXING_EXTRUDER)
+        #if DISABLED(MIXING_EXTRUDER) && EXTRUDERS > 1
           last_moved_extruder = active_extruder;
         #endif
         set_directions();

commit 7e8c073fba85c766d571bec47319e7ded1476618
Author: Sebastianv650 <sebastian.popp@vodafonemail.de>
Date:   Sun Sep 9 07:04:14 2018 +0200

    Fix extruder stops extruding with LA (#11758)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 6dcf52741c..bff01abae0 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1485,16 +1485,10 @@ uint32_t Stepper::stepper_block_phase_isr() {
 
         #if ENABLED(LIN_ADVANCE)
           if (LA_use_advance_lead) {
-            // Wake up eISR on first acceleration loop and fire ISR if final adv_rate is reached
-            if (step_events_completed == steps_per_isr || (LA_steps && LA_isr_rate != current_block->advance_speed)) {
-              nextAdvanceISR = 0;
-              LA_isr_rate = current_block->advance_speed;
-            }
-          }
-          else {
-            LA_isr_rate = LA_ADV_NEVER;
-            if (LA_steps) nextAdvanceISR = 0;
+            // Fire ISR if final adv_rate is reached
+            if (LA_steps && LA_isr_rate != current_block->advance_speed) nextAdvanceISR = 0;
           }
+          else if (LA_steps) nextAdvanceISR = 0;
         #endif // LIN_ADVANCE
       }
       // Are we in Deceleration phase ?
@@ -1536,17 +1530,13 @@ uint32_t Stepper::stepper_block_phase_isr() {
 
         #if ENABLED(LIN_ADVANCE)
           if (LA_use_advance_lead) {
-            if (step_events_completed <= decelerate_after + steps_per_isr ||
-               (LA_steps && LA_isr_rate != current_block->advance_speed)
-            ) {
-              nextAdvanceISR = 0; // Wake up eISR on first deceleration loop
+            // Wake up eISR on first deceleration loop and fire ISR if final adv_rate is reached
+            if (step_events_completed <= decelerate_after + steps_per_isr || (LA_steps && LA_isr_rate != current_block->advance_speed)) {
+              nextAdvanceISR = 0;
               LA_isr_rate = current_block->advance_speed;
             }
           }
-          else {
-            LA_isr_rate = LA_ADV_NEVER;
-            if (LA_steps) nextAdvanceISR = 0;
-          }
+          else if (LA_steps) nextAdvanceISR = 0;
         #endif // LIN_ADVANCE
       }
       // We must be in cruise phase otherwise
@@ -1726,7 +1716,11 @@ uint32_t Stepper::stepper_block_phase_isr() {
         if ((LA_use_advance_lead = current_block->use_advance_lead)) {
           LA_final_adv_steps = current_block->final_adv_steps;
           LA_max_adv_steps = current_block->max_adv_steps;
+          //Start the ISR
+          nextAdvanceISR = 0;
+          LA_isr_rate = current_block->advance_speed;
         }
+        else LA_isr_rate = LA_ADV_NEVER;
       #endif
 
       if (current_block->direction_bits != last_direction_bits

commit d1ceaf5550a98049fce5c78983f798d096e43c1f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 3 23:15:31 2018 -0500

    [2.0.x] Followup to IDEX changes (#11707)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 49790cb319..6dcf52741c 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -231,10 +231,7 @@ int8_t Stepper::count_direction[NUM_AXIS] = { 0, 0, 0, 0 };
   #define X_APPLY_DIR(v,ALWAYS) \
     if (extruder_duplication_enabled || ALWAYS) { \
       X_DIR_WRITE(v); \
-      if (symmetric_duplication_mode) \
-        X2_DIR_WRITE(!v); \
-      else \
-      X2_DIR_WRITE(v); \
+      X2_DIR_WRITE(bool(v)); \
     } \
     else { \
       if (movement_extruder()) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \

commit 7680b64aa66d3aecbc8d682af9912797e59c12aa
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sun Sep 2 10:18:59 2018 -0500

    IDEX clean up (#11690)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 67907ac017..49790cb319 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -231,6 +231,9 @@ int8_t Stepper::count_direction[NUM_AXIS] = { 0, 0, 0, 0 };
   #define X_APPLY_DIR(v,ALWAYS) \
     if (extruder_duplication_enabled || ALWAYS) { \
       X_DIR_WRITE(v); \
+      if (symmetric_duplication_mode) \
+        X2_DIR_WRITE(!v); \
+      else \
       X2_DIR_WRITE(v); \
     } \
     else { \

commit c64199941e058abb18a06be90002f5f03009347b
Author: Dave Johnson <davejohnson3000@gmail.com>
Date:   Tue Aug 14 01:28:52 2018 -0700

    Compile only selected PIO environment (#11519)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 1b85dcbb7b..67907ac017 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -93,7 +93,7 @@
 #include "../gcode/queue.h"
 #include "../sd/cardreader.h"
 #include "../Marlin.h"
-#include "../HAL/Delay.h"
+#include "../HAL/shared/Delay.h"
 
 #if MB(ALLIGATOR)
   #include "../feature/dac/dac_dac084s085.h"

commit e85feb254534f66e4093096ab42671f607bdc070
Author: Giuliano <3684609+GMagician@users.noreply.github.com>
Date:   Tue Aug 7 06:13:36 2018 +0200

    [2.0.x] Better timing handling (#11461)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index ba535cddf1..1b85dcbb7b 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2247,7 +2247,7 @@ void Stepper::report_positions() {
       const uint8_t old_dir = _READ_DIR(AXIS);          \
       _ENABLE(AXIS);                                    \
       _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^DIR^INVERT);   \
-      DELAY_NS(400); /* DRV8825 */                      \
+      DELAY_NS(MINIMUM_STEPPER_DIR_DELAY);              \
       _SAVE_START;                                      \
       _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), true); \
       _PULSE_WAIT;                                      \
@@ -2319,7 +2319,9 @@ void Stepper::report_positions() {
           Y_DIR_WRITE(INVERT_Y_DIR ^ z_direction);
           Z_DIR_WRITE(INVERT_Z_DIR ^ z_direction);
 
-          DELAY_NS(400); // DRV8825
+          #if MINIMUM_STEPPER_DIR_DELAY > 0
+            DELAY_NS(MINIMUM_STEPPER_DIR_DELAY);
+          #endif
 
           _SAVE_START;
 

commit aa4cd2e861f195836e51c42fbdaa962bc3e085c5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jun 27 21:27:36 2018 -0500

    Eliminate stepper.* signed/unsigned warnings

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 3c13a279d8..ba535cddf1 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1324,7 +1324,7 @@ void Stepper::stepper_pulse_phase_isr() {
   // Get the timer count and estimate the end of the pulse
   hal_timer_t pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t(MIN_PULSE_TICKS);
 
-  const hal_timer_t added_step_ticks = ADDED_STEP_TICKS;
+  const hal_timer_t added_step_ticks = hal_timer_t(ADDED_STEP_TICKS);
 
   // Take multiple steps per interrupt (For high speed moves)
   do {
@@ -1820,7 +1820,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
     // Get the timer count and estimate the end of the pulse
     hal_timer_t pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t(MIN_PULSE_TICKS);
 
-    const hal_timer_t added_step_ticks = ADDED_STEP_TICKS;
+    const hal_timer_t added_step_ticks = hal_timer_t(ADDED_STEP_TICKS);
 
     // Step E stepper if we have steps
     while (LA_steps) {

commit edb21f349ad18d2948ff6c313c6d43132bad5118
Author: Eduardo José Tagle <ejtagle@hotmail.com>
Date:   Wed Jun 27 20:11:16 2018 -0300

    Fix stepper/planner block handling, race conditions (#11098)
    
    - Allow planner to alter the deceleration phase of the currently executing block.
    - Remove BUSY flag, as it is NON ATOMIC to set bits in the Stepper ISR and Planner at the same time.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4208924af9..3c13a279d8 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -107,8 +107,6 @@ Stepper stepper; // Singleton
 
 // public:
 
-block_t* Stepper::current_block = NULL;  // A pointer to the block currently being traced
-
 #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
   bool Stepper::homing_dual_axis = false;
 #endif
@@ -119,6 +117,8 @@ block_t* Stepper::current_block = NULL;  // A pointer to the block currently bei
 
 // private:
 
+block_t* Stepper::current_block = NULL; // A pointer to the block currently being traced
+
 uint8_t Stepper::last_direction_bits = 0,
         Stepper::axis_did_move;
 
@@ -1665,6 +1665,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
       acceleration_time = deceleration_time = 0;
 
       uint8_t oversampling = 0;                         // Assume we won't use it
+
       #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
         // At this point, we must decide if we can use Stepper movement axis smoothing.
         uint32_t max_rate = current_block->nominal_rate;  // Get the maximum rate (maximum event speed)
@@ -1874,6 +1875,34 @@ uint32_t Stepper::stepper_block_phase_isr() {
   }
 #endif // LIN_ADVANCE
 
+// Check if the given block is busy or not - Must not be called from ISR contexts
+// The current_block could change in the middle of the read by an Stepper ISR, so
+// we must explicitly prevent that!
+bool Stepper::is_block_busy(const block_t* const block) {
+  #ifdef __AVR__
+    // A SW memory barrier, to ensure GCC does not overoptimize loops
+    #define sw_barrier() asm volatile("": : :"memory");
+
+    // Keep reading until 2 consecutive reads return the same value,
+    // meaning there was no update in-between caused by an interrupt.
+    // This works because stepper ISRs happen at a slower rate than
+    // successive reads of a variable, so 2 consecutive reads with
+    // the same value means no interrupt updated it.
+    block_t* vold, *vnew = current_block;
+    sw_barrier();
+    do {
+      vold = vnew;
+      vnew = current_block;
+      sw_barrier();
+    } while (vold != vnew);
+  #else
+    block_t *vnew = current_block;
+  #endif
+
+  // Return if the block is busy or not
+  return block == vnew;
+}
+
 void Stepper::init() {
 
   // Init Digipot Motor Current

commit 5b49fccf80e0f17aa107262c649ba2777f8d5cc2
Author: etagle <ejtagle@hotmail.com>
Date:   Sat Jun 23 14:31:18 2018 -0300

    Add stepper driver DIR delay configuration option
    
    ...and recommended pulse width configuration for A4988

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 45f23b7a18..4208924af9 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -332,6 +332,11 @@ void Stepper::set_directions() {
       }
     #endif
   #endif // !LIN_ADVANCE
+
+  // A small delay may be needed after changing direction
+  #if MINIMUM_STEPPER_DIR_DELAY > 0
+    DELAY_NS(MINIMUM_STEPPER_DIR_DELAY);
+  #endif
 }
 
 #if ENABLED(S_CURVE_ACCELERATION)

commit 99591dc20cbe6f998850e3b42b5f13e7789ff837
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 21 20:14:16 2018 -0500

    Filter endstops state at all times (#11066)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 369cadfb54..45f23b7a18 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1742,7 +1742,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
       // done against the endstop. So, check the limits here: If the movement
       // is against the limits, the block will be marked as to be killed, and
       // on the next call to this ISR, will be discarded.
-      endstops.check_possible_change();
+      endstops.update();
 
       #if ENABLED(Z_LATE_ENABLE)
         // If delayed Z enable, enable it now. This option will severely interfere with

commit a215725df6a00aa61c5d5a8c5e2d109810f082c9
Author: etagle <ejtagle@hotmail.com>
Date:   Tue Jun 12 01:04:26 2018 -0300

    Fix stepper pulse timing
    
    Always honor minimum period on stepper pulse generation, and fix timing calculations
    
    Signed-off-by: etagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 68eeadfd0f..369cadfb54 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1263,7 +1263,7 @@ void Stepper::isr() {
       #else
         1
       #endif
-      * (HAL_TICKS_PER_US)
+      * (STEPPER_TIMER_TICKS_PER_US)
     );
 
     /**
@@ -1316,10 +1316,10 @@ void Stepper::stepper_pulse_phase_isr() {
   // Just update the value we will get at the end of the loop
   step_events_completed += events_to_do;
 
-  #if MINIMUM_STEPPER_PULSE
-    // Get the timer count and estimate the end of the pulse
-    hal_timer_t pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t((HAL_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE));
-  #endif
+  // Get the timer count and estimate the end of the pulse
+  hal_timer_t pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t(MIN_PULSE_TICKS);
+
+  const hal_timer_t added_step_ticks = ADDED_STEP_TICKS;
 
   // Take multiple steps per interrupt (For high speed moves)
   do {
@@ -1392,10 +1392,11 @@ void Stepper::stepper_pulse_phase_isr() {
     #if MINIMUM_STEPPER_PULSE
       // Just wait for the requested pulse duration
       while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
-      // Add to the value, the value needed for the pulse end and ensuring the maximum driver rate is enforced
-      pulse_end += hal_timer_t(MIN_STEPPER_PULSE_CYCLES) - hal_timer_t((HAL_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE));
     #endif
 
+    // Add the delay needed to ensure the maximum driver rate is enforced
+    if (signed(added_step_ticks) > 0) pulse_end += hal_timer_t(added_step_ticks);
+
     // Pulse stop
     #if HAS_X_STEP
       PULSE_STOP(X);
@@ -1423,15 +1424,15 @@ void Stepper::stepper_pulse_phase_isr() {
     // Decrement the count of pending pulses to do
     --events_to_do;
 
-    #if MINIMUM_STEPPER_PULSE
-      // For minimum pulse time wait after stopping pulses also
-      if (events_to_do) {
-        // Just wait for the requested pulse duration
-        while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
+    // For minimum pulse time wait after stopping pulses also
+    if (events_to_do) {
+      // Just wait for the requested pulse duration
+      while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
+      #if MINIMUM_STEPPER_PULSE
         // Add to the value, the time that the pulse must be active (to be used on the next loop)
-        pulse_end += hal_timer_t((HAL_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE));
-      }
-    #endif
+        pulse_end += hal_timer_t(MIN_PULSE_TICKS);
+      #endif
+    }
 
   } while (events_to_do);
 }
@@ -1810,13 +1811,15 @@ uint32_t Stepper::stepper_block_phase_isr() {
           REV_E_DIR(active_extruder);
       #endif
 
+    // Get the timer count and estimate the end of the pulse
+    hal_timer_t pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t(MIN_PULSE_TICKS);
+
+    const hal_timer_t added_step_ticks = ADDED_STEP_TICKS;
+
     // Step E stepper if we have steps
     while (LA_steps) {
 
-      #if MINIMUM_STEPPER_PULSE
-        hal_timer_t pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t((HAL_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE));
-      #endif
-
+      // Set the STEP pulse ON
       #if ENABLED(MIXING_EXTRUDER)
         MIXING_STEPPERS_LOOP(j) {
           // Step mixing steppers (proportionally)
@@ -1828,15 +1831,18 @@ uint32_t Stepper::stepper_block_phase_isr() {
         E_STEP_WRITE(active_extruder, !INVERT_E_STEP_PIN);
       #endif
 
+      // Enforce a minimum duration for STEP pulse ON
       #if MINIMUM_STEPPER_PULSE
         // Just wait for the requested pulse duration
         while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
-        // Add to the value, the value needed for the pulse end and ensuring the maximum driver rate is enforced
-        pulse_end += hal_timer_t(MIN_STEPPER_PULSE_CYCLES) - hal_timer_t((HAL_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE));
       #endif
 
+      // Add the delay needed to ensure the maximum driver rate is enforced
+      if (signed(added_step_ticks) > 0) pulse_end += hal_timer_t(added_step_ticks);
+
       LA_steps < 0 ? ++LA_steps : --LA_steps;
 
+      // Set the STEP pulse OFF
       #if ENABLED(MIXING_EXTRUDER)
         MIXING_STEPPERS_LOOP(j) {
           if (delta_error_m[j] >= 0) {
@@ -1848,12 +1854,15 @@ uint32_t Stepper::stepper_block_phase_isr() {
         E_STEP_WRITE(active_extruder, INVERT_E_STEP_PIN);
       #endif
 
-      #if MINIMUM_STEPPER_PULSE
-        // For minimum pulse time wait before looping
-        // Just wait for the requested pulse duration
-        if (LA_steps) while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
-      #endif
-
+      // For minimum pulse time wait before looping
+      // Just wait for the requested pulse duration
+      if (LA_steps) {
+        while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
+        #if MINIMUM_STEPPER_PULSE
+          // Add to the value, the time that the pulse must be active (to be used on the next loop)
+          pulse_end += hal_timer_t(MIN_PULSE_TICKS);
+        #endif
+      }
     } // LA_steps
 
     return interval;

commit 0d79128c8d6830c967f8f6091a40dcd65d7c6a53
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 12 17:28:57 2018 -0500

    Localize stepper-specific defines

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index feb75fbd34..68eeadfd0f 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1664,7 +1664,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
         uint32_t max_rate = current_block->nominal_rate;  // Get the maximum rate (maximum event speed)
         while (max_rate < MIN_STEP_ISR_FREQUENCY) {
           max_rate <<= 1;
-          if (max_rate >= MAX_1X_STEP_ISR_FREQUENCY) break;
+          if (max_rate >= MAX_STEP_ISR_FREQUENCY_1X) break;
           ++oversampling;
         }
         oversampling_factor = oversampling;

commit 4dbec774b5839df5c0ec0b078f21bb2e07b86707
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 12 16:32:22 2018 -0500

    HAL_*_TIMER_RATE => *_TIMER_RATE

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index fdedbb5f91..feb75fbd34 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1443,7 +1443,7 @@ void Stepper::stepper_pulse_phase_isr() {
 uint32_t Stepper::stepper_block_phase_isr() {
 
   // If no queued movements, just wait 1ms for the next move
-  uint32_t interval = (HAL_STEPPER_TIMER_RATE / 1000);
+  uint32_t interval = (STEPPER_TIMER_RATE / 1000);
 
   // If there is a current block
   if (current_block) {

commit 6f14bcaa3e85abdf5f043bdeab2d93024d75ea9d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jun 3 14:24:23 2018 -0300

    Add MAXIMUM_STEPPER_RATE, enforce in multi-stepping
    
    The timing value should be properly set for ALL boards. The compiler will check and set maximum step rate calculations based on those values.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index bb218c22cc..fdedbb5f91 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1309,8 +1309,20 @@ void Stepper::stepper_pulse_phase_isr() {
   // If there is no current block, do nothing
   if (!current_block) return;
 
+  // Count of pending loops and events for this iteration
+  const uint32_t pending_events = step_event_count - step_events_completed;
+  uint8_t events_to_do = MIN(pending_events, steps_per_isr);
+
+  // Just update the value we will get at the end of the loop
+  step_events_completed += events_to_do;
+
+  #if MINIMUM_STEPPER_PULSE
+    // Get the timer count and estimate the end of the pulse
+    hal_timer_t pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t((HAL_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE));
+  #endif
+
   // Take multiple steps per interrupt (For high speed moves)
-  for (uint8_t i = steps_per_isr; i--;) {
+  do {
 
     #define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP
     #define _INVERT_STEP_PIN(AXIS) INVERT_## AXIS ##_STEP_PIN
@@ -1332,11 +1344,6 @@ void Stepper::stepper_pulse_phase_isr() {
       } \
     }while(0)
 
-    #if MINIMUM_STEPPER_PULSE > 0
-      // Get the timer count and estimate the end of the pulse
-      hal_timer_t pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t((HAL_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE));
-    #endif
-
     // Pulse start
     #if HAS_X_STEP
       PULSE_START(X);
@@ -1382,11 +1389,11 @@ void Stepper::stepper_pulse_phase_isr() {
       #endif
     #endif // !LIN_ADVANCE
 
-    #if MINIMUM_STEPPER_PULSE > 0
-      // Just wait for the requested pulse time.
+    #if MINIMUM_STEPPER_PULSE
+      // Just wait for the requested pulse duration
       while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
-      // Get the timer count and estimate the end of the pulse for the OFF phase
-      pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t((HAL_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE));
+      // Add to the value, the value needed for the pulse end and ensuring the maximum driver rate is enforced
+      pulse_end += hal_timer_t(MIN_STEPPER_PULSE_CYCLES) - hal_timer_t((HAL_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE));
     #endif
 
     // Pulse stop
@@ -1413,15 +1420,20 @@ void Stepper::stepper_pulse_phase_isr() {
       #endif
     #endif // !LIN_ADVANCE
 
-    // If all events done, break loop now
-    if (++step_events_completed >= step_event_count) break;
+    // Decrement the count of pending pulses to do
+    --events_to_do;
 
     #if MINIMUM_STEPPER_PULSE
       // For minimum pulse time wait after stopping pulses also
-      // Just wait for the requested pulse time.
-      if (i) while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
+      if (events_to_do) {
+        // Just wait for the requested pulse duration
+        while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
+        // Add to the value, the time that the pulse must be active (to be used on the next loop)
+        pulse_end += hal_timer_t((HAL_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE));
+      }
     #endif
-  } // steps_loop
+
+  } while (events_to_do);
 }
 
 // This is the last half of the stepper interrupt: This one processes and
@@ -1819,8 +1831,8 @@ uint32_t Stepper::stepper_block_phase_isr() {
       #if MINIMUM_STEPPER_PULSE
         // Just wait for the requested pulse duration
         while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
-        // Get the timer count and estimate the end of the pulse for the OFF phase
-        pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t((HAL_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE));
+        // Add to the value, the value needed for the pulse end and ensuring the maximum driver rate is enforced
+        pulse_end += hal_timer_t(MIN_STEPPER_PULSE_CYCLES) - hal_timer_t((HAL_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE));
       #endif
 
       LA_steps < 0 ? ++LA_steps : --LA_steps;

commit 39a7e7720d0b14e7c55b65d7da7973b528d184c7
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jun 3 00:59:21 2018 -0300

    Adaptive multiaxis step smoothing
    
    - Stepper bugs fixed
    - Support MIXING_EXTRUDER with Linear Advance
    - Miscellaneous cleanup

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 6f21d84aaa..bb218c22cc 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -46,6 +46,29 @@
  * and Philipp Tiefenbacher.
  */
 
+/**
+ *         __________________________
+ *        /|                        |\     _________________         ^
+ *       / |                        | \   /|               |\        |
+ *      /  |                        |  \ / |               | \       s
+ *     /   |                        |   |  |               |  \      p
+ *    /    |                        |   |  |               |   \     e
+ *   +-----+------------------------+---+--+---------------+----+    e
+ *   |               BLOCK 1            |      BLOCK 2          |    d
+ *
+ *                           time ----->
+ *
+ *  The trapezoid is the shape the speed curve over time. It starts at block->initial_rate, accelerates
+ *  first block->accelerate_until step_events_completed, then keeps going at constant speed until
+ *  step_events_completed reaches block->decelerate_after after which it decelerates until the trapezoid generator is reset.
+ *  The slope of acceleration is calculated using v = u + at where t is the accumulated timer values of the steps so far.
+ */
+
+/**
+ * Marlin uses the Bresenham algorithm. For a detailed explanation of theory and
+ * method see https://www.cs.helsinki.fi/group/goa/mallinnus/lines/bresenh.html
+ */
+
 /**
  * Jerk controlled movements planner added Apr 2018 by Eduardo José Tagle.
  * Equations based on Synthethos TinyG2 sources, but the fixed-point
@@ -97,10 +120,14 @@ block_t* Stepper::current_block = NULL;  // A pointer to the block currently bei
 // private:
 
 uint8_t Stepper::last_direction_bits = 0,
-        Stepper::last_movement_extruder = 0xFF,
         Stepper::axis_did_move;
+
 bool Stepper::abort_current_block;
 
+#if DISABLED(MIXING_EXTRUDER)
+  uint8_t Stepper::last_moved_extruder = 0xFF;
+#endif
+
 #if ENABLED(X_DUAL_ENDSTOPS)
   bool Stepper::locked_X_motor = false, Stepper::locked_X2_motor = false;
 #endif
@@ -111,19 +138,30 @@ bool Stepper::abort_current_block;
   bool Stepper::locked_Z_motor = false, Stepper::locked_Z2_motor = false;
 #endif
 
-/**
- * Marlin uses the Bresenham algorithm. For a detailed explanation of theory and
- * method see https://www.cs.helsinki.fi/group/goa/mallinnus/lines/bresenh.html
- *
- * The implementation used here additionally rounds up the starting seed.
- */
+uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
+uint8_t Stepper::steps_per_isr;
 
-int32_t Stepper::counter_X = 0,
-        Stepper::counter_Y = 0,
-        Stepper::counter_Z = 0,
-        Stepper::counter_E = 0;
+#if DISABLED(ADAPTIVE_STEP_SMOOTHING)
+  constexpr
+#endif
+    uint8_t Stepper::oversampling_factor;
+
+int32_t Stepper::delta_error[XYZE] = { 0 };
 
-uint32_t Stepper::step_events_completed = 0; // The number of step events executed in the current block
+uint32_t Stepper::advance_dividend[XYZE] = { 0 },
+         Stepper::advance_divisor = 0,
+         Stepper::step_events_completed = 0, // The number of step events executed in the current block
+         Stepper::accelerate_until,          // The point from where we need to stop acceleration
+         Stepper::decelerate_after,          // The point from where we need to start decelerating
+         Stepper::step_event_count;          // The total event count for the current block
+
+#if ENABLED(MIXING_EXTRUDER)
+  int32_t Stepper::delta_error_m[MIXING_STEPPERS];
+  uint32_t Stepper::advance_dividend_m[MIXING_STEPPERS],
+           Stepper::advance_divisor_m;
+#else
+  int8_t Stepper::active_extruder;           // Active extruder
+#endif
 
 #if ENABLED(S_CURVE_ACCELERATION)
   int32_t __attribute__((used)) Stepper::bezier_A __asm__("bezier_A");    // A coefficient in Bézier speed curve with alias for assembler
@@ -132,55 +170,38 @@ uint32_t Stepper::step_events_completed = 0; // The number of step events execut
   uint32_t __attribute__((used)) Stepper::bezier_F __asm__("bezier_F");   // F coefficient in Bézier speed curve with alias for assembler
   uint32_t __attribute__((used)) Stepper::bezier_AV __asm__("bezier_AV"); // AV coefficient in Bézier speed curve with alias for assembler
   #ifdef __AVR__
-    bool __attribute__((used)) Stepper::A_negative __asm__("A_negative");   // If A coefficient was negative
+    bool __attribute__((used)) Stepper::A_negative __asm__("A_negative"); // If A coefficient was negative
   #endif
   bool Stepper::bezier_2nd_half;    // =false If Bézier curve has been initialized or not
 #endif
 
 uint32_t Stepper::nextMainISR = 0;
-bool Stepper::all_steps_done = false;
 
 #if ENABLED(LIN_ADVANCE)
 
-  uint32_t Stepper::LA_decelerate_after;
-
-  constexpr uint32_t ADV_NEVER = 0xFFFFFFFF;
-  uint32_t Stepper::nextAdvanceISR = ADV_NEVER,
-           Stepper::eISR_Rate = ADV_NEVER;
-  uint16_t Stepper::current_adv_steps = 0,
-           Stepper::final_adv_steps,
-           Stepper::max_adv_steps;
+  constexpr uint32_t LA_ADV_NEVER = 0xFFFFFFFF;
+  uint32_t Stepper::nextAdvanceISR = LA_ADV_NEVER,
+           Stepper::LA_isr_rate = LA_ADV_NEVER;
+  uint16_t Stepper::LA_current_adv_steps = 0,
+           Stepper::LA_final_adv_steps,
+           Stepper::LA_max_adv_steps;
 
-  int8_t Stepper::e_steps = 0;
+  int8_t   Stepper::LA_steps = 0;
 
-  #if E_STEPPERS > 1
-    int8_t Stepper::LA_active_extruder; // Copy from current executed block. Needed because current_block is set to NULL "too early".
-  #else
-    constexpr int8_t Stepper::LA_active_extruder;
-  #endif
-
-  bool Stepper::use_advance_lead;
+  bool Stepper::LA_use_advance_lead;
 
 #endif // LIN_ADVANCE
 
-uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
-
-volatile int32_t Stepper::count_position[NUM_AXIS] = { 0 };
-int8_t Stepper::count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
-
-#if ENABLED(MIXING_EXTRUDER)
-  int32_t Stepper::counter_m[MIXING_STEPPERS];
-#endif
-
-uint32_t Stepper::ticks_nominal;
-uint8_t Stepper::step_loops, Stepper::step_loops_nominal;
-
+int32_t Stepper::ticks_nominal = -1;
 #if DISABLED(S_CURVE_ACCELERATION)
   uint32_t Stepper::acc_step_rate; // needed for deceleration start point
 #endif
 
 volatile int32_t Stepper::endstops_trigsteps[XYZ];
 
+volatile int32_t Stepper::count_position[NUM_AXIS] = { 0 };
+int8_t Stepper::count_direction[NUM_AXIS] = { 0, 0, 0, 0 };
+
 #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
   #define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                        \
     if (homing_dual_axis) {                                                                                                   \
@@ -213,7 +234,7 @@ volatile int32_t Stepper::endstops_trigsteps[XYZ];
       X2_DIR_WRITE(v); \
     } \
     else { \
-      if (current_block->active_extruder) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \
+      if (movement_extruder()) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \
     }
   #define X_APPLY_STEP(v,ALWAYS) \
     if (extruder_duplication_enabled || ALWAYS) { \
@@ -221,7 +242,7 @@ volatile int32_t Stepper::endstops_trigsteps[XYZ];
       X2_STEP_WRITE(v); \
     } \
     else { \
-      if (current_block->active_extruder) X2_STEP_WRITE(v); else X_STEP_WRITE(v); \
+      if (movement_extruder()) X2_STEP_WRITE(v); else X_STEP_WRITE(v); \
     }
 #else
   #define X_APPLY_DIR(v,Q) X_DIR_WRITE(v)
@@ -253,26 +274,9 @@ volatile int32_t Stepper::endstops_trigsteps[XYZ];
 #endif
 
 #if DISABLED(MIXING_EXTRUDER)
-  #define E_APPLY_STEP(v,Q) E_STEP_WRITE(current_block->active_extruder, v)
+  #define E_APPLY_STEP(v,Q) E_STEP_WRITE(active_extruder, v)
 #endif
 
-/**
- *         __________________________
- *        /|                        |\     _________________         ^
- *       / |                        | \   /|               |\        |
- *      /  |                        |  \ / |               | \       s
- *     /   |                        |   |  |               |  \      p
- *    /    |                        |   |  |               |   \     e
- *   +-----+------------------------+---+--+---------------+----+    e
- *   |               BLOCK 1            |      BLOCK 2          |    d
- *
- *                           time ----->
- *
- *  The trapezoid is the shape the speed curve over time. It starts at block->initial_rate, accelerates
- *  first block->accelerate_until step_events_completed, then keeps going at constant speed until
- *  step_events_completed reaches block->decelerate_after after which it decelerates until the trapezoid generator is reset.
- *  The slope of acceleration is calculated using v = u + at where t is the accumulated timer values of the steps so far.
- */
 void Stepper::wake_up() {
   // TCNT1 = 0;
   ENABLE_STEPPER_DRIVER_INTERRUPT();
@@ -308,14 +312,25 @@ void Stepper::set_directions() {
   #endif
 
   #if DISABLED(LIN_ADVANCE)
-    if (motor_direction(E_AXIS)) {
-      REV_E_DIR(current_block->active_extruder);
-      count_direction[E_AXIS] = -1;
-    }
-    else {
-      NORM_E_DIR(current_block->active_extruder);
-      count_direction[E_AXIS] = 1;
-    }
+    #if ENABLED(MIXING_EXTRUDER)
+      if (motor_direction(E_AXIS)) {
+        MIXING_STEPPERS_LOOP(j) REV_E_DIR(j);
+        count_direction[E_AXIS] = -1;
+      }
+      else {
+        MIXING_STEPPERS_LOOP(j) NORM_E_DIR(j);
+        count_direction[E_AXIS] = 1;
+      }
+    #else
+      if (motor_direction(E_AXIS)) {
+        REV_E_DIR(active_extruder);
+        count_direction[E_AXIS] = -1;
+      }
+      else {
+        NORM_E_DIR(active_extruder);
+        count_direction[E_AXIS] = 1;
+      }
+    #endif
   #endif // !LIN_ADVANCE
 }
 
@@ -1128,17 +1143,6 @@ void Stepper::set_directions() {
  * Stepper Driver Interrupt
  *
  * Directly pulses the stepper motors at high frequency.
- *
- * AVR :
- * Timer 1 runs at a base frequency of 2MHz, with this ISR using OCR1A compare mode.
- *
- * OCR1A   Frequency
- *     1     2 MHz
- *    50    40 KHz
- *   100    20 KHz - capped max rate
- *   200    10 KHz - nominal max rate
- *  2000     1 KHz - sleep rate
- *  4000   500  Hz - init rate
  */
 
 HAL_STEP_TIMER_ISR {
@@ -1156,9 +1160,11 @@ HAL_STEP_TIMER_ISR {
 #endif
 
 void Stepper::isr() {
-
-  // Disable interrupts, to avoid ISR preemption while we reprogram the period
-  DISABLE_ISRS();
+  #ifndef __AVR__
+    // Disable interrupts, to avoid ISR preemption while we reprogram the period
+    // (AVR enters the ISR with global interrupts disabled, so no need to do it here)
+    DISABLE_ISRS();
+  #endif
 
   // Program timer compare for the maximum period, so it does NOT
   // flag an interrupt while this ISR is running - So changes from small
@@ -1206,7 +1212,7 @@ void Stepper::isr() {
 
     #if ENABLED(LIN_ADVANCE)
       // Compute the time remaining for the advance isr
-      if (nextAdvanceISR != ADV_NEVER) nextAdvanceISR -= interval;
+      if (nextAdvanceISR != LA_ADV_NEVER) nextAdvanceISR -= interval;
     #endif
 
     /**
@@ -1248,12 +1254,17 @@ void Stepper::isr() {
     /**
      * Get the current tick value + margin
      * Assuming at least 6µs between calls to this ISR...
-     * On AVR the ISR epilogue is estimated at 40 instructions - close to 2.5µS.
-     * On ARM the ISR epilogue is estimated at 10 instructions - close to 200nS.
-     * In either case leave at least 8µS for other tasks to execute - That allows
-     * up to 100khz stepping rates
+     * On AVR the ISR epilogue+prologue is estimated at 100 instructions - Give 8µs as margin
+     * On ARM the ISR epilogue+prologue is estimated at 20 instructions - Give 1µs as margin
      */
-    min_ticks = HAL_timer_get_count(STEP_TIMER_NUM) + hal_timer_t((HAL_TICKS_PER_US) * 8); // ISR never takes more than 1ms, so this shouldn't cause trouble
+    min_ticks = HAL_timer_get_count(STEP_TIMER_NUM) + hal_timer_t(
+      #ifdef __AVR__
+        8
+      #else
+        1
+      #endif
+      * (HAL_TICKS_PER_US)
+    );
 
     /**
      * NB: If for some reason the stepper monopolizes the MPU, eventually the
@@ -1299,97 +1310,34 @@ void Stepper::stepper_pulse_phase_isr() {
   if (!current_block) return;
 
   // Take multiple steps per interrupt (For high speed moves)
-  all_steps_done = false;
-  for (uint8_t i = step_loops; i--;) {
+  for (uint8_t i = steps_per_isr; i--;) {
 
-    #define _COUNTER(AXIS) counter_## AXIS
     #define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP
     #define _INVERT_STEP_PIN(AXIS) INVERT_## AXIS ##_STEP_PIN
 
-    // Advance the Bresenham counter; start a pulse if the axis needs a step
+    // Start an active pulse, if Bresenham says so, and update position
     #define PULSE_START(AXIS) do{ \
-      _COUNTER(AXIS) += current_block->steps[_AXIS(AXIS)]; \
-      if (_COUNTER(AXIS) >= 0) { _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), 0); } \
-    }while(0)
-
-    // Advance the Bresenham counter; start a pulse if the axis needs a step
-    #define STEP_TICK(AXIS) do { \
-      if (_COUNTER(AXIS) >= 0) { \
-        _COUNTER(AXIS) -= current_block->step_event_count; \
+      delta_error[_AXIS(AXIS)] += advance_dividend[_AXIS(AXIS)]; \
+      if (delta_error[_AXIS(AXIS)] >= 0) { \
+        _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), 0); \
         count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \
       } \
     }while(0)
 
-    // Stop an active pulse, if any
-    #define PULSE_STOP(AXIS) _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), 0)
-
-    /**
-     * Estimate the number of cycles that the stepper logic already takes
-     * up between the start and stop of the X stepper pulse.
-     *
-     * Currently this uses very modest estimates of around 5 cycles.
-     * True values may be derived by careful testing.
-     *
-     * Once any delay is added, the cost of the delay code itself
-     * may be subtracted from this value to get a more accurate delay.
-     * Delays under 20 cycles (1.25µs) will be very accurate, using NOPs.
-     * Longer delays use a loop. The resolution is 8 cycles.
-     */
-    #if HAS_X_STEP
-      #define _CYCLE_APPROX_1 5
-    #else
-      #define _CYCLE_APPROX_1 0
-    #endif
-    #if ENABLED(X_DUAL_STEPPER_DRIVERS)
-      #define _CYCLE_APPROX_2 _CYCLE_APPROX_1 + 4
-    #else
-      #define _CYCLE_APPROX_2 _CYCLE_APPROX_1
-    #endif
-    #if HAS_Y_STEP
-      #define _CYCLE_APPROX_3 _CYCLE_APPROX_2 + 5
-    #else
-      #define _CYCLE_APPROX_3 _CYCLE_APPROX_2
-    #endif
-    #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-      #define _CYCLE_APPROX_4 _CYCLE_APPROX_3 + 4
-    #else
-      #define _CYCLE_APPROX_4 _CYCLE_APPROX_3
-    #endif
-    #if HAS_Z_STEP
-      #define _CYCLE_APPROX_5 _CYCLE_APPROX_4 + 5
-    #else
-      #define _CYCLE_APPROX_5 _CYCLE_APPROX_4
-    #endif
-    #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
-      #define _CYCLE_APPROX_6 _CYCLE_APPROX_5 + 4
-    #else
-      #define _CYCLE_APPROX_6 _CYCLE_APPROX_5
-    #endif
-    #if DISABLED(LIN_ADVANCE)
-      #if ENABLED(MIXING_EXTRUDER)
-        #define _CYCLE_APPROX_7 _CYCLE_APPROX_6 + (MIXING_STEPPERS) * 6
-      #else
-        #define _CYCLE_APPROX_7 _CYCLE_APPROX_6 + 5
-      #endif
-    #else
-      #define _CYCLE_APPROX_7 _CYCLE_APPROX_6
-    #endif
-
-    #define CYCLES_EATEN_XYZE _CYCLE_APPROX_7
-    #define EXTRA_CYCLES_XYZE (STEP_PULSE_CYCLES - (CYCLES_EATEN_XYZE))
+    // Stop an active pulse, if any, and adjust error term
+    #define PULSE_STOP(AXIS) do { \
+      if (delta_error[_AXIS(AXIS)] >= 0) { \
+        delta_error[_AXIS(AXIS)] -= advance_divisor; \
+        _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), 0); \
+      } \
+    }while(0)
 
-    /**
-     * If a minimum pulse time was specified get the timer 0 value.
-     *
-     * On AVR the TCNT0 timer has an 8x prescaler, so it increments every 8 cycles.
-     * That's every 0.5µs on 16MHz and every 0.4µs on 20MHz.
-     * 20 counts of TCNT0 -by itself- is a good pulse delay.
-     * 10µs = 160 or 200 cycles.
-     */
-    #if EXTRA_CYCLES_XYZE > 20
-      hal_timer_t pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM);
+    #if MINIMUM_STEPPER_PULSE > 0
+      // Get the timer count and estimate the end of the pulse
+      hal_timer_t pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t((HAL_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE));
     #endif
 
+    // Pulse start
     #if HAS_X_STEP
       PULSE_START(X);
     #endif
@@ -1400,64 +1348,48 @@ void Stepper::stepper_pulse_phase_isr() {
       PULSE_START(Z);
     #endif
 
+    // Pulse E/Mixing extruders
     #if ENABLED(LIN_ADVANCE)
-      counter_E += current_block->steps[E_AXIS];
-      if (counter_E >= 0) {
-        #if DISABLED(MIXING_EXTRUDER)
-          // Don't step E here for mixing extruder
-          motor_direction(E_AXIS) ? --e_steps : ++e_steps;
-        #endif
+      // Tick the E axis, correct error term and update position
+      delta_error[E_AXIS] += advance_dividend[E_AXIS];
+      if (delta_error[E_AXIS] >= 0) {
+        count_position[E_AXIS] += count_direction[E_AXIS];
+        delta_error[E_AXIS] -= advance_divisor;
+
+        // Don't step E here - But remember the number of steps to perform
+        motor_direction(E_AXIS) ? --LA_steps : ++LA_steps;
       }
-
+    #else // !LIN_ADVANCE - use linear interpolation for E also
       #if ENABLED(MIXING_EXTRUDER)
-        // Step mixing steppers proportionally
-        const bool dir = motor_direction(E_AXIS);
-        MIXING_STEPPERS_LOOP(j) {
-          counter_m[j] += current_block->steps[E_AXIS];
-          if (counter_m[j] >= 0) {
-            counter_m[j] -= current_block->mix_event_count[j];
-            dir ? --e_steps[j] : ++e_steps[j];
-          }
-        }
-      #endif
 
-    #else // !LIN_ADVANCE - use linear interpolation for E also
+        // Tick the E axis
+        delta_error[E_AXIS] += advance_dividend[E_AXIS];
+        if (delta_error[E_AXIS] >= 0) {
+          count_position[E_AXIS] += count_direction[E_AXIS];
+          delta_error[E_AXIS] -= advance_divisor;
+        }
 
-      #if ENABLED(MIXING_EXTRUDER)
-        // Keep updating the single E axis
-        counter_E += current_block->steps[E_AXIS];
-        // Tick the counters used for this mix
+        // Tick the counters used for this mix in proper proportion
         MIXING_STEPPERS_LOOP(j) {
           // Step mixing steppers (proportionally)
-          counter_m[j] += current_block->steps[E_AXIS];
+          delta_error_m[j] += advance_dividend_m[j];
           // Step when the counter goes over zero
-          if (counter_m[j] >= 0) E_STEP_WRITE(j, !INVERT_E_STEP_PIN);
+          if (delta_error_m[j] >= 0) E_STEP_WRITE(j, !INVERT_E_STEP_PIN);
         }
+
       #else // !MIXING_EXTRUDER
         PULSE_START(E);
       #endif
     #endif // !LIN_ADVANCE
 
-    #if HAS_X_STEP
-      STEP_TICK(X);
-    #endif
-    #if HAS_Y_STEP
-      STEP_TICK(Y);
-    #endif
-    #if HAS_Z_STEP
-      STEP_TICK(Z);
-    #endif
-
-    STEP_TICK(E); // Always tick the single E axis
-
-    // For minimum pulse time wait before stopping pulses
-    #if EXTRA_CYCLES_XYZE > 20
-      while (EXTRA_CYCLES_XYZE > (uint32_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
-      pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM);
-    #elif EXTRA_CYCLES_XYZE > 0
-      DELAY_NS(EXTRA_CYCLES_XYZE * NANOSECONDS_PER_CYCLE);
+    #if MINIMUM_STEPPER_PULSE > 0
+      // Just wait for the requested pulse time.
+      while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
+      // Get the timer count and estimate the end of the pulse for the OFF phase
+      pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t((HAL_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE));
     #endif
 
+    // Pulse stop
     #if HAS_X_STEP
       PULSE_STOP(X);
     #endif
@@ -1471,8 +1403,8 @@ void Stepper::stepper_pulse_phase_isr() {
     #if DISABLED(LIN_ADVANCE)
       #if ENABLED(MIXING_EXTRUDER)
         MIXING_STEPPERS_LOOP(j) {
-          if (counter_m[j] >= 0) {
-            counter_m[j] -= current_block->mix_event_count[j];
+          if (delta_error_m[j] >= 0) {
+            delta_error_m[j] -= advance_divisor_m;
             E_STEP_WRITE(j, INVERT_E_STEP_PIN);
           }
         }
@@ -1481,18 +1413,14 @@ void Stepper::stepper_pulse_phase_isr() {
       #endif
     #endif // !LIN_ADVANCE
 
-    if (++step_events_completed >= current_block->step_event_count) {
-      all_steps_done = true;
-      break;
-    }
+    // If all events done, break loop now
+    if (++step_events_completed >= step_event_count) break;
 
-    // For minimum pulse time wait after stopping pulses also
-    #if EXTRA_CYCLES_XYZE > 20
-      if (i) while (EXTRA_CYCLES_XYZE > (uint32_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
-    #elif EXTRA_CYCLES_XYZE > 0
-      if (i) DELAY_NS(EXTRA_CYCLES_XYZE * NANOSECONDS_PER_CYCLE);
+    #if MINIMUM_STEPPER_PULSE
+      // For minimum pulse time wait after stopping pulses also
+      // Just wait for the requested pulse time.
+      if (i) while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
     #endif
-
   } // steps_loop
 }
 
@@ -1508,100 +1436,118 @@ uint32_t Stepper::stepper_block_phase_isr() {
   // If there is a current block
   if (current_block) {
 
-    // Calculate new timer value
-    if (step_events_completed <= current_block->accelerate_until) {
+    // If current block is finished, reset pointer
+    if (step_events_completed >= step_event_count) {
+      axis_did_move = 0;
+      current_block = NULL;
+      planner.discard_current_block();
+    }
+    else {
+      // Step events not completed yet...
 
-      #if ENABLED(S_CURVE_ACCELERATION)
-        // Get the next speed to use (Jerk limited!)
-        uint32_t acc_step_rate =
-          acceleration_time < current_block->acceleration_time
-            ? _eval_bezier_curve(acceleration_time)
-            : current_block->cruise_rate;
-      #else
-        acc_step_rate = STEP_MULTIPLY(acceleration_time, current_block->acceleration_rate) + current_block->initial_rate;
-        NOMORE(acc_step_rate, current_block->nominal_rate);
-      #endif
+      // Are we in acceleration phase ?
+      if (step_events_completed <= accelerate_until) { // Calculate new timer value
 
-      // step_rate to timer interval
-      interval = calc_timer_interval(acc_step_rate);
-      acceleration_time += interval;
+        #if ENABLED(S_CURVE_ACCELERATION)
+          // Get the next speed to use (Jerk limited!)
+          uint32_t acc_step_rate =
+            acceleration_time < current_block->acceleration_time
+              ? _eval_bezier_curve(acceleration_time)
+              : current_block->cruise_rate;
+        #else
+          acc_step_rate = STEP_MULTIPLY(acceleration_time, current_block->acceleration_rate) + current_block->initial_rate;
+          NOMORE(acc_step_rate, current_block->nominal_rate);
+        #endif
 
-      #if ENABLED(LIN_ADVANCE)
-        if (current_block->use_advance_lead) {
-          if (step_events_completed == step_loops || (e_steps && eISR_Rate != current_block->advance_speed)) {
-            nextAdvanceISR = 0; // Wake up eISR on first acceleration loop and fire ISR if final adv_rate is reached
-            eISR_Rate = current_block->advance_speed;
-          }
-        }
-        else {
-          eISR_Rate = ADV_NEVER;
-          if (e_steps) nextAdvanceISR = 0;
-        }
-      #endif // LIN_ADVANCE
-    }
-    else if (step_events_completed > current_block->decelerate_after) {
-      uint32_t step_rate;
+        // acc_step_rate is in steps/second
 
-      #if ENABLED(S_CURVE_ACCELERATION)
-        // If this is the 1st time we process the 2nd half of the trapezoid...
-        if (!bezier_2nd_half) {
-          // Initialize the Bézier speed curve
-          _calc_bezier_curve_coeffs(current_block->cruise_rate, current_block->final_rate, current_block->deceleration_time_inverse);
-          bezier_2nd_half = true;
-        }
+        // step_rate to timer interval and steps per stepper isr
+        interval = calc_timer_interval(acc_step_rate, oversampling_factor, &steps_per_isr);
+        acceleration_time += interval;
 
-        // Calculate the next speed to use
-        step_rate = deceleration_time < current_block->deceleration_time
-          ? _eval_bezier_curve(deceleration_time)
-          : current_block->final_rate;
-      #else
+        #if ENABLED(LIN_ADVANCE)
+          if (LA_use_advance_lead) {
+            // Wake up eISR on first acceleration loop and fire ISR if final adv_rate is reached
+            if (step_events_completed == steps_per_isr || (LA_steps && LA_isr_rate != current_block->advance_speed)) {
+              nextAdvanceISR = 0;
+              LA_isr_rate = current_block->advance_speed;
+            }
+          }
+          else {
+            LA_isr_rate = LA_ADV_NEVER;
+            if (LA_steps) nextAdvanceISR = 0;
+          }
+        #endif // LIN_ADVANCE
+      }
+      // Are we in Deceleration phase ?
+      else if (step_events_completed > decelerate_after) {
+        uint32_t step_rate;
+
+        #if ENABLED(S_CURVE_ACCELERATION)
+          // If this is the 1st time we process the 2nd half of the trapezoid...
+          if (!bezier_2nd_half) {
+            // Initialize the Bézier speed curve
+            _calc_bezier_curve_coeffs(current_block->cruise_rate, current_block->final_rate, current_block->deceleration_time_inverse);
+            bezier_2nd_half = true;
+            // The first point starts at cruise rate. Just save evaluation of the Bézier curve
+            step_rate = current_block->cruise_rate;
+          }
+          else {
+            // Calculate the next speed to use
+            step_rate = deceleration_time < current_block->deceleration_time
+              ? _eval_bezier_curve(deceleration_time)
+              : current_block->final_rate;
+          }
+        #else
 
-        // Using the old trapezoidal control
-        step_rate = STEP_MULTIPLY(deceleration_time, current_block->acceleration_rate);
-        if (step_rate < acc_step_rate) { // Still decelerating?
-          step_rate = acc_step_rate - step_rate;
-          NOLESS(step_rate, current_block->final_rate);
-        }
-        else
-          step_rate = current_block->final_rate;
-      #endif
+          // Using the old trapezoidal control
+          step_rate = STEP_MULTIPLY(deceleration_time, current_block->acceleration_rate);
+          if (step_rate < acc_step_rate) { // Still decelerating?
+            step_rate = acc_step_rate - step_rate;
+            NOLESS(step_rate, current_block->final_rate);
+          }
+          else
+            step_rate = current_block->final_rate;
+        #endif
 
-      // step_rate to timer interval
-      interval = calc_timer_interval(step_rate);
-      deceleration_time += interval;
+        // step_rate is in steps/second
 
-      #if ENABLED(LIN_ADVANCE)
-        if (current_block->use_advance_lead) {
-          if (step_events_completed <= current_block->decelerate_after + step_loops || (e_steps && eISR_Rate != current_block->advance_speed)) {
-            nextAdvanceISR = 0; // Wake up eISR on first deceleration loop
-            eISR_Rate = current_block->advance_speed;
-          }
-        }
-        else {
-          eISR_Rate = ADV_NEVER;
-          if (e_steps) nextAdvanceISR = 0;
-        }
-      #endif // LIN_ADVANCE
-    }
-    else {
+        // step_rate to timer interval and steps per stepper isr
+        interval = calc_timer_interval(step_rate, oversampling_factor, &steps_per_isr);
+        deceleration_time += interval;
 
-      #if ENABLED(LIN_ADVANCE)
-        // If there are any esteps, fire the next advance_isr "now"
-        if (e_steps && eISR_Rate != current_block->advance_speed) nextAdvanceISR = 0;
-      #endif
+        #if ENABLED(LIN_ADVANCE)
+          if (LA_use_advance_lead) {
+            if (step_events_completed <= decelerate_after + steps_per_isr ||
+               (LA_steps && LA_isr_rate != current_block->advance_speed)
+            ) {
+              nextAdvanceISR = 0; // Wake up eISR on first deceleration loop
+              LA_isr_rate = current_block->advance_speed;
+            }
+          }
+          else {
+            LA_isr_rate = LA_ADV_NEVER;
+            if (LA_steps) nextAdvanceISR = 0;
+          }
+        #endif // LIN_ADVANCE
+      }
+      // We must be in cruise phase otherwise
+      else {
 
-      // The timer interval is just the nominal value for the nominal speed
-      interval = ticks_nominal;
+        #if ENABLED(LIN_ADVANCE)
+          // If there are any esteps, fire the next advance_isr "now"
+          if (LA_steps && LA_isr_rate != current_block->advance_speed) nextAdvanceISR = 0;
+        #endif
 
-      // Ensure this runs at the correct step rate, even if it just came off an acceleration
-      step_loops = step_loops_nominal;
-    }
+        // Calculate the ticks_nominal for this nominal speed, if not done yet
+        if (ticks_nominal < 0) {
+          // step_rate to timer interval and loops for the nominal speed
+          ticks_nominal = calc_timer_interval(current_block->nominal_rate, oversampling_factor, &steps_per_isr);
+        }
 
-    // If current block is finished, reset pointer
-    if (all_steps_done) {
-      axis_did_move = 0;
-      current_block = NULL;
-      planner.discard_current_block();
+        // The timer interval is just the nominal value for the nominal speed
+        interval = ticks_nominal;
+      }
     }
   }
 
@@ -1697,25 +1643,82 @@ uint32_t Stepper::stepper_block_phase_isr() {
       //if (!!current_block->steps[C_AXIS]) SBI(axis_bits, Z_HEAD);
       axis_did_move = axis_bits;
 
+      // No acceleration / deceleration time elapsed so far
+      acceleration_time = deceleration_time = 0;
+
+      uint8_t oversampling = 0;                         // Assume we won't use it
+      #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
+        // At this point, we must decide if we can use Stepper movement axis smoothing.
+        uint32_t max_rate = current_block->nominal_rate;  // Get the maximum rate (maximum event speed)
+        while (max_rate < MIN_STEP_ISR_FREQUENCY) {
+          max_rate <<= 1;
+          if (max_rate >= MAX_1X_STEP_ISR_FREQUENCY) break;
+          ++oversampling;
+        }
+        oversampling_factor = oversampling;
+      #endif
+
+      // Based on the oversampling factor, do the calculations
+      step_event_count = current_block->step_event_count << oversampling;
+
+      // Initialize Bresenham delta errors to 1/2
+      delta_error[X_AXIS] = delta_error[Y_AXIS] = delta_error[Z_AXIS] = delta_error[E_AXIS] = -int32_t(step_event_count);
+
+      // Calculate Bresenham dividends
+      advance_dividend[X_AXIS] = current_block->steps[X_AXIS] << 1;
+      advance_dividend[Y_AXIS] = current_block->steps[Y_AXIS] << 1;
+      advance_dividend[Z_AXIS] = current_block->steps[Z_AXIS] << 1;
+      advance_dividend[E_AXIS] = current_block->steps[E_AXIS] << 1;
+
+      // Calculate Bresenham divisor
+      advance_divisor = step_event_count << 1;
+
+      // No step events completed so far
+      step_events_completed = 0;
+
+      // Compute the acceleration and deceleration points
+      accelerate_until = current_block->accelerate_until << oversampling;
+      decelerate_after = current_block->decelerate_after << oversampling;
+
+      #if ENABLED(MIXING_EXTRUDER)
+        const uint32_t e_steps = (
+          #if ENABLED(LIN_ADVANCE)
+            current_block->steps[E_AXIS]
+          #else
+            step_event_count
+          #endif
+        );
+        MIXING_STEPPERS_LOOP(i) {
+          delta_error_m[i] = -int32_t(e_steps);
+          advance_dividend_m[i] = current_block->mix_steps[i] << 1;
+        }
+        advance_divisor_m = e_steps << 1;
+      #else
+        active_extruder = current_block->active_extruder;
+      #endif
+
       // Initialize the trapezoid generator from the current block.
       #if ENABLED(LIN_ADVANCE)
-        #if E_STEPPERS > 1
-          if (current_block->active_extruder != last_movement_extruder) {
-            current_adv_steps = 0; // If the now active extruder wasn't in use during the last move, its pressure is most likely gone.
-            LA_active_extruder = current_block->active_extruder;
-          }
+        #if DISABLED(MIXING_EXTRUDER) && E_STEPPERS > 1
+          // If the now active extruder wasn't in use during the last move, its pressure is most likely gone.
+          if (active_extruder != last_moved_extruder) LA_current_adv_steps = 0;
         #endif
 
-        if ((use_advance_lead = current_block->use_advance_lead)) {
-          LA_decelerate_after = current_block->decelerate_after;
-          final_adv_steps = current_block->final_adv_steps;
-          max_adv_steps = current_block->max_adv_steps;
+        if ((LA_use_advance_lead = current_block->use_advance_lead)) {
+          LA_final_adv_steps = current_block->final_adv_steps;
+          LA_max_adv_steps = current_block->max_adv_steps;
         }
       #endif
 
-      if (current_block->direction_bits != last_direction_bits || current_block->active_extruder != last_movement_extruder) {
+      if (current_block->direction_bits != last_direction_bits
+        #if DISABLED(MIXING_EXTRUDER)
+          || active_extruder != last_moved_extruder
+        #endif
+      ) {
         last_direction_bits = current_block->direction_bits;
-        last_movement_extruder = current_block->active_extruder;
+        #if DISABLED(MIXING_EXTRUDER)
+          last_moved_extruder = active_extruder;
+        #endif
         set_directions();
       }
 
@@ -1728,17 +1731,15 @@ uint32_t Stepper::stepper_block_phase_isr() {
       // on the next call to this ISR, will be discarded.
       endstops.check_possible_change();
 
-      // No acceleration / deceleration time elapsed so far
-      acceleration_time = deceleration_time = 0;
-
-      // No step events completed so far
-      step_events_completed = 0;
-
-      // step_rate to timer interval for the nominal speed
-      ticks_nominal = calc_timer_interval(current_block->nominal_rate);
+      #if ENABLED(Z_LATE_ENABLE)
+        // If delayed Z enable, enable it now. This option will severely interfere with
+        // timing between pulses when chaining motion between blocks, and it could lead
+        // to lost steps in both X and Y axis, so avoid using it unless strictly necessary!!
+        if (current_block->steps[Z_AXIS]) enable_Z();
+      #endif
 
-      // make a note of the number of step loops required at nominal speed
-      step_loops_nominal = step_loops;
+      // Mark the time_nominal as not calculated yet
+      ticks_nominal = -1;
 
       #if DISABLED(S_CURVE_ACCELERATION)
         // Set as deceleration point the initial rate of the block
@@ -1748,24 +1749,12 @@ uint32_t Stepper::stepper_block_phase_isr() {
       #if ENABLED(S_CURVE_ACCELERATION)
         // Initialize the Bézier speed curve
         _calc_bezier_curve_coeffs(current_block->initial_rate, current_block->cruise_rate, current_block->acceleration_time_inverse);
-
-        // We have not started the 2nd half of the trapezoid
+        // We haven't started the 2nd half of the trapezoid
         bezier_2nd_half = false;
       #endif
 
-      // Initialize Bresenham counters to 1/2 the ceiling, with proper roundup (as explained in the article linked above)
-      counter_X = counter_Y = counter_Z = counter_E = -int32_t((current_block->step_event_count + 1) >> 1);
-      #if ENABLED(MIXING_EXTRUDER)
-        MIXING_STEPPERS_LOOP(i)
-          counter_m[i] = -int32_t((current_block->mix_event_count[i] + 1) >> 1);
-      #endif
-
-      #if ENABLED(Z_LATE_ENABLE)
-        // If delayed Z enable, enable it now. This option will severely interfere with
-        //  timing between pulses when chaining motion between blocks, and it could lead
-        //  to lost steps in both X and Y axis, so avoid using it unless strictly necessary!!
-        if (current_block->steps[Z_AXIS]) enable_Z();
-      #endif
+      // Calculate the initial timer interval
+      interval = calc_timer_interval(current_block->initial_rate, oversampling_factor, &steps_per_isr);
     }
   }
 
@@ -1775,65 +1764,85 @@ uint32_t Stepper::stepper_block_phase_isr() {
 
 #if ENABLED(LIN_ADVANCE)
 
-  #define CYCLES_EATEN_E (E_STEPPERS * 5)
-  #define EXTRA_CYCLES_E (STEP_PULSE_CYCLES - (CYCLES_EATEN_E))
-
-  // Timer interrupt for E. e_steps is set in the main routine;
+  // Timer interrupt for E. LA_steps is set in the main routine
   uint32_t Stepper::advance_isr() {
     uint32_t interval;
 
-    if (use_advance_lead) {
-      if (step_events_completed > LA_decelerate_after && current_adv_steps > final_adv_steps) {
-        e_steps--;
-        current_adv_steps--;
-        interval = eISR_Rate;
+    if (LA_use_advance_lead) {
+      if (step_events_completed > decelerate_after && LA_current_adv_steps > LA_final_adv_steps) {
+        LA_steps--;
+        LA_current_adv_steps--;
+        interval = LA_isr_rate;
       }
-      else if (step_events_completed < LA_decelerate_after && current_adv_steps < max_adv_steps) {
-             //step_events_completed <= (uint32_t)current_block->accelerate_until) {
-        e_steps++;
-        current_adv_steps++;
-        interval = eISR_Rate;
+      else if (step_events_completed < decelerate_after && LA_current_adv_steps < LA_max_adv_steps) {
+             //step_events_completed <= (uint32_t)accelerate_until) {
+        LA_steps++;
+        LA_current_adv_steps++;
+        interval = LA_isr_rate;
       }
       else
-        interval = eISR_Rate = ADV_NEVER;
+        interval = LA_isr_rate = LA_ADV_NEVER;
     }
     else
-      interval = ADV_NEVER;
+      interval = LA_ADV_NEVER;
 
-    if (e_steps >= 0)
-      NORM_E_DIR(LA_active_extruder);
-    else
-      REV_E_DIR(LA_active_extruder);
+      #if ENABLED(MIXING_EXTRUDER)
+        if (LA_steps >= 0)
+          MIXING_STEPPERS_LOOP(j) NORM_E_DIR(j);
+        else
+          MIXING_STEPPERS_LOOP(j) REV_E_DIR(j);
+      #else
+        if (LA_steps >= 0)
+          NORM_E_DIR(active_extruder);
+        else
+          REV_E_DIR(active_extruder);
+      #endif
 
     // Step E stepper if we have steps
-    while (e_steps) {
+    while (LA_steps) {
 
-      #if EXTRA_CYCLES_E > 20
-        hal_timer_t pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM);
+      #if MINIMUM_STEPPER_PULSE
+        hal_timer_t pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t((HAL_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE));
       #endif
 
-      E_STEP_WRITE(LA_active_extruder, !INVERT_E_STEP_PIN);
+      #if ENABLED(MIXING_EXTRUDER)
+        MIXING_STEPPERS_LOOP(j) {
+          // Step mixing steppers (proportionally)
+          delta_error_m[j] += advance_dividend_m[j];
+          // Step when the counter goes over zero
+          if (delta_error_m[j] >= 0) E_STEP_WRITE(j, !INVERT_E_STEP_PIN);
+        }
+      #else
+        E_STEP_WRITE(active_extruder, !INVERT_E_STEP_PIN);
+      #endif
 
-      // For minimum pulse time wait before stopping pulses
-      #if EXTRA_CYCLES_E > 20
-        while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
-        pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM);
-      #elif EXTRA_CYCLES_E > 0
-        DELAY_NS(EXTRA_CYCLES_E * NANOSECONDS_PER_CYCLE);
+      #if MINIMUM_STEPPER_PULSE
+        // Just wait for the requested pulse duration
+        while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
+        // Get the timer count and estimate the end of the pulse for the OFF phase
+        pulse_end = HAL_timer_get_count(PULSE_TIMER_NUM) + hal_timer_t((HAL_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE));
       #endif
 
-      e_steps < 0 ? ++e_steps : --e_steps;
+      LA_steps < 0 ? ++LA_steps : --LA_steps;
 
-      E_STEP_WRITE(LA_active_extruder, INVERT_E_STEP_PIN);
+      #if ENABLED(MIXING_EXTRUDER)
+        MIXING_STEPPERS_LOOP(j) {
+          if (delta_error_m[j] >= 0) {
+            delta_error_m[j] -= advance_divisor_m;
+            E_STEP_WRITE(j, INVERT_E_STEP_PIN);
+          }
+        }
+      #else
+        E_STEP_WRITE(active_extruder, INVERT_E_STEP_PIN);
+      #endif
 
-      // For minimum pulse time wait before looping
-      #if EXTRA_CYCLES_E > 20
-        if (e_steps) while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
-      #elif EXTRA_CYCLES_E > 0
-        if (e_steps) DELAY_NS(EXTRA_CYCLES_E * NANOSECONDS_PER_CYCLE);
+      #if MINIMUM_STEPPER_PULSE
+        // For minimum pulse time wait before looping
+        // Just wait for the requested pulse duration
+        if (LA_steps) while (HAL_timer_get_count(PULSE_TIMER_NUM) < pulse_end) { /* nada */ }
       #endif
 
-    } // e_steps
+    } // LA_steps
 
     return interval;
   }
@@ -2145,6 +2154,12 @@ void Stepper::report_positions() {
 
 #if ENABLED(BABYSTEPPING)
 
+  #if MINIMUM_STEPPER_PULSE
+    #define STEP_PULSE_CYCLES ((MINIMUM_STEPPER_PULSE) * CYCLES_PER_MICROSECOND)
+  #else
+    #define STEP_PULSE_CYCLES 0
+  #endif
+
   #if ENABLED(DELTA)
     #define CYCLES_EATEN_BABYSTEP (2 * 15)
   #else
@@ -2158,8 +2173,8 @@ void Stepper::report_positions() {
   #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)
 
   #if EXTRA_CYCLES_BABYSTEP > 20
-    #define _SAVE_START const hal_timer_t pulse_start = HAL_timer_get_count(STEP_TIMER_NUM)
-    #define _PULSE_WAIT while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(HAL_timer_get_count(STEP_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
+    #define _SAVE_START const hal_timer_t pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM)
+    #define _PULSE_WAIT while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
   #else
     #define _SAVE_START NOOP
     #if EXTRA_CYCLES_BABYSTEP > 0

commit 3701869e6cdf3fe24b44da8a606575cf4764f872
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jun 3 01:43:00 2018 -0500

    Add HAL_timer_start for AVR, use stepper timer to time pulses

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index e4e42eda25..6f21d84aaa 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1993,27 +1993,8 @@ void Stepper::init() {
     E_AXIS_INIT(4);
   #endif
 
-  #ifdef __AVR__
-    // waveform generation = 0100 = CTC
-    SET_WGM(1, CTC_OCRnA);
-
-    // output mode = 00 (disconnected)
-    SET_COMA(1, NORMAL);
-
-    // Set the timer pre-scaler
-    // Generally we use a divider of 8, resulting in a 2MHz timer
-    // frequency on a 16MHz MCU. If you are going to change this, be
-    // sure to regenerate speed_lookuptable.h with
-    // create_speed_lookuptable.py
-    SET_CS(1, PRESCALER_8);  //  CS 2 = 1/8 prescaler
-
-    // Init Stepper ISR to 122 Hz for quick starting
-    OCR1A = 0x4000;
-    TCNT1 = 0;
-  #else
-    // Init Stepper ISR to 122 Hz for quick starting
-    HAL_timer_start(STEP_TIMER_NUM, 122);
-  #endif
+  // Init Stepper ISR to 122 Hz for quick starting
+  HAL_timer_start(STEP_TIMER_NUM, 122);
 
   ENABLE_STEPPER_DRIVER_INTERRUPT();
 

commit ad8d3150aa4d6b792b5e06a63d2645991136fc50
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 2 20:39:00 2018 -0500

    Cleanup for dual endstops homing

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index a69d65d419..e4e42eda25 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -87,7 +87,7 @@ Stepper stepper; // Singleton
 block_t* Stepper::current_block = NULL;  // A pointer to the block currently being traced
 
 #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
-  bool Stepper::performing_homing = false;
+  bool Stepper::homing_dual_axis = false;
 #endif
 
 #if HAS_MOTOR_CURRENT_PWM
@@ -166,7 +166,7 @@ bool Stepper::all_steps_done = false;
 uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
 
 volatile int32_t Stepper::count_position[NUM_AXIS] = { 0 };
-volatile signed char Stepper::count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
+int8_t Stepper::count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
 
 #if ENABLED(MIXING_EXTRUDER)
   int32_t Stepper::counter_m[MIXING_STEPPERS];
@@ -183,7 +183,7 @@ volatile int32_t Stepper::endstops_trigsteps[XYZ];
 
 #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
   #define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                        \
-    if (performing_homing) {                                                                                                  \
+    if (homing_dual_axis) {                                                                                                   \
       if (A##_HOME_DIR < 0) {                                                                                                 \
         if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
         if (!(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
@@ -1144,7 +1144,6 @@ void Stepper::set_directions() {
 HAL_STEP_TIMER_ISR {
   HAL_timer_isr_prologue(STEP_TIMER_NUM);
 
-  // Call the ISR
   Stepper::isr();
 
   HAL_timer_isr_epilogue(STEP_TIMER_NUM);
@@ -1175,7 +1174,7 @@ void Stepper::isr() {
   // We need this variable here to be able to use it in the following loop
   hal_timer_t min_ticks;
   do {
-    // Enable ISRs so the USART processing latency is reduced
+    // Enable ISRs to reduce USART processing latency
     ENABLE_ISRS();
 
     // Run main stepping pulse phase ISR if we have to
@@ -1193,11 +1192,9 @@ void Stepper::isr() {
 
     uint32_t interval =
       #if ENABLED(LIN_ADVANCE)
-        // Select the closest interval in time
-        MIN(nextAdvanceISR, nextMainISR)
+        MIN(nextAdvanceISR, nextMainISR)  // Nearest time interval
       #else
-        // The interval is just the remaining time to the stepper ISR
-        nextMainISR
+        nextMainISR                       // Remaining stepper ISR time
       #endif
     ;
 
@@ -1239,7 +1236,7 @@ void Stepper::isr() {
     next_isr_ticks += interval;
 
     /**
-     *  The following section must be done with global interrupts disabled.
+     * The following section must be done with global interrupts disabled.
      * We want nothing to interrupt it, as that could mess the calculations
      * we do for the next value to program in the period register of the
      * stepper timer and lead to skipped ISRs (if the value we happen to program

commit d3c02410a84b369443654ef77f925562e9b87830
Author: Eduardo José Tagle <ejtagle@hotmail.com>
Date:   Fri Jun 1 21:02:22 2018 -0300

    [2.0.x] Small assorted collection of fixes and improvements (#10911)
    
    * Misc fixes and improvements
    
    - Get rid of most critical sections on the Serial port drivers for AVR and DUE. Proper usage of FIFOs should allow interrupts to stay enabled without harm to queuing and dequeuing.
      Also, with 8-bit indices (for AVR) and up to 32-bit indices (for ARM), there is no need to protect reads and writes to those indices.
    - Simplify the XON/XOFF logic quite a bit. Much cleaner now (both for AVR and ARM)
    - Prevent a race condition (edge case) that could happen when estimating the proper value for the stepper timer (by reading it) and writing the calculated value for the time to the next ISR by disabling interrupts in those critical and small sections of the code - The problem could lead to lost steps.
    - Fix dual endstops not properly homing bug (maybe).
    
    * Set position immediately when possible

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index fc0378950a..a69d65d419 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -102,13 +102,13 @@ uint8_t Stepper::last_direction_bits = 0,
 bool Stepper::abort_current_block;
 
 #if ENABLED(X_DUAL_ENDSTOPS)
-  bool Stepper::locked_x_motor = false, Stepper::locked_x2_motor = false;
+  bool Stepper::locked_X_motor = false, Stepper::locked_X2_motor = false;
 #endif
 #if ENABLED(Y_DUAL_ENDSTOPS)
-  bool Stepper::locked_y_motor = false, Stepper::locked_y2_motor = false;
+  bool Stepper::locked_Y_motor = false, Stepper::locked_Y2_motor = false;
 #endif
 #if ENABLED(Z_DUAL_ENDSTOPS)
-  bool Stepper::locked_z_motor = false, Stepper::locked_z2_motor = false;
+  bool Stepper::locked_Z_motor = false, Stepper::locked_Z2_motor = false;
 #endif
 
 /**
@@ -182,26 +182,20 @@ uint8_t Stepper::step_loops, Stepper::step_loops_nominal;
 volatile int32_t Stepper::endstops_trigsteps[XYZ];
 
 #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
-  #define LOCKED_X_MOTOR  locked_x_motor
-  #define LOCKED_Y_MOTOR  locked_y_motor
-  #define LOCKED_Z_MOTOR  locked_z_motor
-  #define LOCKED_X2_MOTOR locked_x2_motor
-  #define LOCKED_Y2_MOTOR locked_y2_motor
-  #define LOCKED_Z2_MOTOR locked_z2_motor
-  #define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                                      \
-    if (performing_homing) {                                                                                                                \
-      if (A##_HOME_DIR < 0) {                                                                                                               \
-        if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !LOCKED_##A##_MOTOR) A##_STEP_WRITE(V);     \
-        if (!(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !LOCKED_##A##2_MOTOR) A##2_STEP_WRITE(V);  \
-      }                                                                                                                                     \
-      else {                                                                                                                                \
-        if (!(TEST(endstops.state(), A##_MAX) && count_direction[_AXIS(A)] > 0) && !LOCKED_##A##_MOTOR) A##_STEP_WRITE(V);     \
-        if (!(TEST(endstops.state(), A##2_MAX) && count_direction[_AXIS(A)] > 0) && !LOCKED_##A##2_MOTOR) A##2_STEP_WRITE(V);  \
-      }                                                                                                                                     \
-    }                                                                                                                                       \
-    else {                                                                                                                                  \
-      A##_STEP_WRITE(V);                                                                                                                    \
-      A##2_STEP_WRITE(V);                                                                                                                   \
+  #define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                        \
+    if (performing_homing) {                                                                                                  \
+      if (A##_HOME_DIR < 0) {                                                                                                 \
+        if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
+        if (!(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
+      }                                                                                                                       \
+      else {                                                                                                                  \
+        if (!(TEST(endstops.state(), A##_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##_motor) A##_STEP_WRITE(V);    \
+        if (!(TEST(endstops.state(), A##2_MAX) && count_direction[_AXIS(A)] > 0) && !locked_##A##2_motor) A##2_STEP_WRITE(V); \
+      }                                                                                                                       \
+    }                                                                                                                         \
+    else {                                                                                                                    \
+      A##_STEP_WRITE(V);                                                                                                      \
+      A##2_STEP_WRITE(V);                                                                                                     \
     }
 #endif
 
@@ -1150,19 +1144,8 @@ void Stepper::set_directions() {
 HAL_STEP_TIMER_ISR {
   HAL_timer_isr_prologue(STEP_TIMER_NUM);
 
-  // Program timer compare for the maximum period, so it does NOT
-  // flag an interrupt while this ISR is running - So changes from small
-  // periods to big periods are respected and the timer does not reset to 0
-  HAL_timer_set_compare(STEP_TIMER_NUM, HAL_TIMER_TYPE_MAX);
-
-  // Call the ISR scheduler
-  hal_timer_t ticks = Stepper::isr_scheduler();
-
-  // Now 'ticks' contains the period to the next Stepper ISR - And we are
-  // sure that the time has not arrived yet - Warrantied by the scheduler
-
-  // Set the next ISR to fire at the proper time
-  HAL_timer_set_compare(STEP_TIMER_NUM, ticks);
+  // Call the ISR
+  Stepper::isr();
 
   HAL_timer_isr_epilogue(STEP_TIMER_NUM);
 }
@@ -1173,8 +1156,15 @@ HAL_STEP_TIMER_ISR {
   #define STEP_MULTIPLY(A,B) MultiU24X32toH16(A, B)
 #endif
 
-hal_timer_t Stepper::isr_scheduler() {
-  uint32_t interval;
+void Stepper::isr() {
+
+  // Disable interrupts, to avoid ISR preemption while we reprogram the period
+  DISABLE_ISRS();
+
+  // Program timer compare for the maximum period, so it does NOT
+  // flag an interrupt while this ISR is running - So changes from small
+  // periods to big periods are respected and the timer does not reset to 0
+  HAL_timer_set_compare(STEP_TIMER_NUM, HAL_TIMER_TYPE_MAX);
 
   // Count of ticks for the next ISR
   hal_timer_t next_isr_ticks = 0;
@@ -1185,6 +1175,9 @@ hal_timer_t Stepper::isr_scheduler() {
   // We need this variable here to be able to use it in the following loop
   hal_timer_t min_ticks;
   do {
+    // Enable ISRs so the USART processing latency is reduced
+    ENABLE_ISRS();
+
     // Run main stepping pulse phase ISR if we have to
     if (!nextMainISR) Stepper::stepper_pulse_phase_isr();
 
@@ -1198,13 +1191,15 @@ hal_timer_t Stepper::isr_scheduler() {
     // Run main stepping block processing ISR if we have to
     if (!nextMainISR) nextMainISR = Stepper::stepper_block_phase_isr();
 
-    #if ENABLED(LIN_ADVANCE)
-      // Select the closest interval in time
-      interval = (nextAdvanceISR <= nextMainISR) ? nextAdvanceISR : nextMainISR;
-    #else
-      // The interval is just the remaining time to the stepper ISR
-      interval = nextMainISR;
-    #endif
+    uint32_t interval =
+      #if ENABLED(LIN_ADVANCE)
+        // Select the closest interval in time
+        MIN(nextAdvanceISR, nextMainISR)
+      #else
+        // The interval is just the remaining time to the stepper ISR
+        nextMainISR
+      #endif
+    ;
 
     // Limit the value to the maximum possible value of the timer
     NOMORE(interval, HAL_TIMER_TYPE_MAX);
@@ -1243,6 +1238,16 @@ hal_timer_t Stepper::isr_scheduler() {
     // Compute the tick count for the next ISR
     next_isr_ticks += interval;
 
+    /**
+     *  The following section must be done with global interrupts disabled.
+     * We want nothing to interrupt it, as that could mess the calculations
+     * we do for the next value to program in the period register of the
+     * stepper timer and lead to skipped ISRs (if the value we happen to program
+     * is less than the current count due to something preempting between the
+     * read and the write of the new period value).
+     */
+    DISABLE_ISRS();
+
     /**
      * Get the current tick value + margin
      * Assuming at least 6µs between calls to this ISR...
@@ -1264,8 +1269,14 @@ hal_timer_t Stepper::isr_scheduler() {
     // Advance pulses if not enough time to wait for the next ISR
   } while (next_isr_ticks < min_ticks);
 
-  // Return the count of ticks for the next ISR
-  return (hal_timer_t)next_isr_ticks;
+  // Now 'next_isr_ticks' contains the period to the next Stepper ISR - And we are
+  // sure that the time has not arrived yet - Warrantied by the scheduler
+
+  // Set the next ISR to fire at the proper time
+  HAL_timer_set_compare(STEP_TIMER_NUM, hal_timer_t(next_isr_ticks));
+
+  // Don't forget to finally reenable interrupts
+  ENABLE_ISRS();
 }
 
 /**

commit 4299e5dc8b80e4f6daef3309728d58e09f514d43
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 28 19:34:08 2018 -0500

    Modify E-stepping macros for use in LINEAR_ADVANCE (#10885)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index ff534707cd..fc0378950a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -259,7 +259,7 @@ volatile int32_t Stepper::endstops_trigsteps[XYZ];
 #endif
 
 #if DISABLED(MIXING_EXTRUDER)
-  #define E_APPLY_STEP(v,Q) E_STEP_WRITE(v)
+  #define E_APPLY_STEP(v,Q) E_STEP_WRITE(current_block->active_extruder, v)
 #endif
 
 /**
@@ -315,11 +315,11 @@ void Stepper::set_directions() {
 
   #if DISABLED(LIN_ADVANCE)
     if (motor_direction(E_AXIS)) {
-      REV_E_DIR();
+      REV_E_DIR(current_block->active_extruder);
       count_direction[E_AXIS] = -1;
     }
     else {
-      NORM_E_DIR();
+      NORM_E_DIR(current_block->active_extruder);
       count_direction[E_AXIS] = 1;
     }
   #endif // !LIN_ADVANCE
@@ -1423,7 +1423,7 @@ void Stepper::stepper_pulse_phase_isr() {
           // Step mixing steppers (proportionally)
           counter_m[j] += current_block->steps[E_AXIS];
           // Step when the counter goes over zero
-          if (counter_m[j] >= 0) En_STEP_WRITE(j, !INVERT_E_STEP_PIN);
+          if (counter_m[j] >= 0) E_STEP_WRITE(j, !INVERT_E_STEP_PIN);
         }
       #else // !MIXING_EXTRUDER
         PULSE_START(E);
@@ -1465,7 +1465,7 @@ void Stepper::stepper_pulse_phase_isr() {
         MIXING_STEPPERS_LOOP(j) {
           if (counter_m[j] >= 0) {
             counter_m[j] -= current_block->mix_event_count[j];
-            En_STEP_WRITE(j, INVERT_E_STEP_PIN);
+            E_STEP_WRITE(j, INVERT_E_STEP_PIN);
           }
         }
       #else // !MIXING_EXTRUDER
@@ -1774,61 +1774,6 @@ uint32_t Stepper::stepper_block_phase_isr() {
   uint32_t Stepper::advance_isr() {
     uint32_t interval;
 
-    #if ENABLED(MK2_MULTIPLEXER) // For SNMM even-numbered steppers are reversed
-      #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) E0_DIR_WRITE(e_steps < 0 ? !INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0) : INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0)); }while(0)
-    #elif ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
-      #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) { if (e_steps < 0) REV_E_DIR(); else NORM_E_DIR(); } }while(0)
-    #elif ENABLED(SWITCHING_EXTRUDER)
-      #if EXTRUDERS > 4
-        #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) { switch (INDEX) { \
-            case 0: case 1: E0_DIR_WRITE(!INVERT_E0_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); break; \
-            case 2: case 3: E1_DIR_WRITE(!INVERT_E1_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); break; \
-                    case 4: E2_DIR_WRITE(!INVERT_E2_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); \
-        } } }while(0)
-      #elif EXTRUDERS > 2
-        #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) { switch (INDEX) { \
-            case 0: case 1: E0_DIR_WRITE(!INVERT_E0_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); break; \
-            case 2: case 3: E1_DIR_WRITE(!INVERT_E1_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); break; \
-        } } }while(0)
-      #else
-        #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) E0_DIR_WRITE(!INVERT_E0_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); }while(0)
-      #endif
-    #else
-      #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) E## INDEX ##_DIR_WRITE(!INVERT_E## INDEX ##_DIR ^ (e_steps < 0)); }while(0)
-    #endif
-
-    #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
-      #define START_E_PULSE(INDEX) do{ if (e_steps) E_STEP_WRITE(!INVERT_E_STEP_PIN); }while(0)
-      #define STOP_E_PULSE(INDEX) do{ if (e_steps) { e_steps < 0 ? ++e_steps : --e_steps; E_STEP_WRITE(INVERT_E_STEP_PIN); } }while(0)
-    #elif ENABLED(SWITCHING_EXTRUDER)
-      #if EXTRUDERS > 4
-        #define START_E_PULSE(INDEX) do{ if (e_steps) { switch (INDEX) { \
-            case 0: case 1: E0_STEP_WRITE(!INVERT_E_STEP_PIN); break; \
-            case 2: case 3: E1_STEP_WRITE(!INVERT_E_STEP_PIN); break; \
-                    case 4: E2_STEP_WRITE(!INVERT_E_STEP_PIN); } \
-        } }while(0)
-        #define STOP_E_PULSE(INDEX) do{ if (e_steps) { \
-          e_steps < 0 ? ++e_steps : --e_steps; \
-          switch (INDEX) { \
-            case 0: case 1: E0_STEP_WRITE( INVERT_E_STEP_PIN); break; \
-            case 2: case 3: E1_STEP_WRITE( INVERT_E_STEP_PIN); break; \
-                    case 4: E2_STEP_WRITE( INVERT_E_STEP_PIN); } \
-        } }while(0)
-      #elif EXTRUDERS > 2
-        #define START_E_PULSE(INDEX) do{ if (e_steps) { if (INDEX < 2) E0_STEP_WRITE(!INVERT_E_STEP_PIN); else E1_STEP_WRITE(!INVERT_E_STEP_PIN); } }while(0)
-        #define STOP_E_PULSE(INDEX) do{ if (e_steps) { \
-          e_steps < 0 ? ++e_steps : --e_steps; \
-          if (INDEX < 2) E0_STEP_WRITE(INVERT_E_STEP_PIN); else E1_STEP_WRITE(INVERT_E_STEP_PIN); \
-        } }while(0)
-      #else
-        #define START_E_PULSE(INDEX) do{ if (e_steps) E0_STEP_WRITE(!INVERT_E_STEP_PIN); }while(0)
-        #define STOP_E_PULSE(INDEX) do{ if (e_steps) { e_steps < 0 ? ++e_steps : --e_steps; E0_STEP_WRITE(INVERT_E_STEP_PIN); }while(0)
-      #endif
-    #else
-      #define START_E_PULSE(INDEX) do{ if (e_steps) E## INDEX ##_STEP_WRITE(!INVERT_E_STEP_PIN); }while(0)
-      #define STOP_E_PULSE(INDEX) do { if (e_steps) { e_steps < 0 ? ++e_steps : --e_steps; E## INDEX ##_STEP_WRITE(INVERT_E_STEP_PIN); } }while(0)
-    #endif
-
     if (use_advance_lead) {
       if (step_events_completed > LA_decelerate_after && current_adv_steps > final_adv_steps) {
         e_steps--;
@@ -1847,21 +1792,10 @@ uint32_t Stepper::stepper_block_phase_isr() {
     else
       interval = ADV_NEVER;
 
-    switch (LA_active_extruder) {
-      case 0: SET_E_STEP_DIR(0); break;
-      #if EXTRUDERS > 1
-        case 1: SET_E_STEP_DIR(1); break;
-        #if EXTRUDERS > 2
-          case 2: SET_E_STEP_DIR(2); break;
-          #if EXTRUDERS > 3
-            case 3: SET_E_STEP_DIR(3); break;
-            #if EXTRUDERS > 4
-              case 4: SET_E_STEP_DIR(4); break;
-            #endif // EXTRUDERS > 4
-          #endif // EXTRUDERS > 3
-        #endif // EXTRUDERS > 2
-      #endif // EXTRUDERS > 1
-    }
+    if (e_steps >= 0)
+      NORM_E_DIR(LA_active_extruder);
+    else
+      REV_E_DIR(LA_active_extruder);
 
     // Step E stepper if we have steps
     while (e_steps) {
@@ -1870,21 +1804,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
         hal_timer_t pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM);
       #endif
 
-      switch (LA_active_extruder) {
-        case 0: START_E_PULSE(0); break;
-        #if EXTRUDERS > 1
-          case 1: START_E_PULSE(1); break;
-          #if EXTRUDERS > 2
-            case 2: START_E_PULSE(2); break;
-            #if EXTRUDERS > 3
-              case 3: START_E_PULSE(3); break;
-              #if EXTRUDERS > 4
-                case 4: START_E_PULSE(4); break;
-              #endif // EXTRUDERS > 4
-            #endif // EXTRUDERS > 3
-          #endif // EXTRUDERS > 2
-        #endif // EXTRUDERS > 1
-      }
+      E_STEP_WRITE(LA_active_extruder, !INVERT_E_STEP_PIN);
 
       // For minimum pulse time wait before stopping pulses
       #if EXTRA_CYCLES_E > 20
@@ -1894,21 +1814,9 @@ uint32_t Stepper::stepper_block_phase_isr() {
         DELAY_NS(EXTRA_CYCLES_E * NANOSECONDS_PER_CYCLE);
       #endif
 
-      switch (LA_active_extruder) {
-        case 0: STOP_E_PULSE(0); break;
-        #if EXTRUDERS > 1
-          case 1: STOP_E_PULSE(1); break;
-          #if EXTRUDERS > 2
-            case 2: STOP_E_PULSE(2); break;
-            #if EXTRUDERS > 3
-              case 3: STOP_E_PULSE(3); break;
-              #if EXTRUDERS > 4
-                case 4: STOP_E_PULSE(4); break;
-              #endif // EXTRUDERS > 4
-            #endif // EXTRUDERS > 3
-          #endif // EXTRUDERS > 2
-        #endif // EXTRUDERS > 1
-      }
+      e_steps < 0 ? ++e_steps : --e_steps;
+
+      E_STEP_WRITE(LA_active_extruder, INVERT_E_STEP_PIN);
 
       // For minimum pulse time wait before looping
       #if EXTRA_CYCLES_E > 20
@@ -2061,19 +1969,19 @@ void Stepper::init() {
     AXIS_INIT(Z, Z);
   #endif
 
-  #if HAS_E0_STEP
+  #if E_STEPPERS > 0 && HAS_E0_STEP
     E_AXIS_INIT(0);
   #endif
-  #if HAS_E1_STEP
+  #if E_STEPPERS > 1 && HAS_E1_STEP
     E_AXIS_INIT(1);
   #endif
-  #if HAS_E2_STEP
+  #if E_STEPPERS > 2 && HAS_E2_STEP
     E_AXIS_INIT(2);
   #endif
-  #if HAS_E3_STEP
+  #if E_STEPPERS > 3 && HAS_E3_STEP
     E_AXIS_INIT(3);
   #endif
-  #if HAS_E4_STEP
+  #if E_STEPPERS > 4 && HAS_E4_STEP
     E_AXIS_INIT(4);
   #endif
 

commit 0ca9db705191d0b36dea513437ec518b0c0211a6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 27 17:56:21 2018 -0500

    Correct HOTENDS for SWITCHING_EXTRUDER

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4c0e70c3f7..ff534707cd 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1841,10 +1841,8 @@ uint32_t Stepper::stepper_block_phase_isr() {
         current_adv_steps++;
         interval = eISR_Rate;
       }
-      else {
-        interval = ADV_NEVER;
-        eISR_Rate = ADV_NEVER;
-      }
+      else
+        interval = eISR_Rate = ADV_NEVER;
     }
     else
       interval = ADV_NEVER;

commit 7b9f0302d4113941beeeadef3f1f75ae6983cf18
Author: Eduardo José Tagle <ejtagle@hotmail.com>
Date:   Sun May 27 03:49:59 2018 -0300

    Fix Bresenham rounding errors, add link to article (#10871)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b76b1b7b44..4c0e70c3f7 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -111,6 +111,13 @@ bool Stepper::abort_current_block;
   bool Stepper::locked_z_motor = false, Stepper::locked_z2_motor = false;
 #endif
 
+/**
+ * Marlin uses the Bresenham algorithm. For a detailed explanation of theory and
+ * method see https://www.cs.helsinki.fi/group/goa/mallinnus/lines/bresenh.html
+ *
+ * The implementation used here additionally rounds up the starting seed.
+ */
+
 int32_t Stepper::counter_X = 0,
         Stepper::counter_Y = 0,
         Stepper::counter_Z = 0,
@@ -1174,7 +1181,7 @@ hal_timer_t Stepper::isr_scheduler() {
 
   // Limit the amount of iterations
   uint8_t max_loops = 10;
-  
+
   // We need this variable here to be able to use it in the following loop
   hal_timer_t min_ticks;
   do {
@@ -1294,12 +1301,12 @@ void Stepper::stepper_pulse_phase_isr() {
     // Advance the Bresenham counter; start a pulse if the axis needs a step
     #define PULSE_START(AXIS) do{ \
       _COUNTER(AXIS) += current_block->steps[_AXIS(AXIS)]; \
-      if (_COUNTER(AXIS) > 0) { _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), 0); } \
+      if (_COUNTER(AXIS) >= 0) { _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), 0); } \
     }while(0)
 
     // Advance the Bresenham counter; start a pulse if the axis needs a step
     #define STEP_TICK(AXIS) do { \
-      if (_COUNTER(AXIS) > 0) { \
+      if (_COUNTER(AXIS) >= 0) { \
         _COUNTER(AXIS) -= current_block->step_event_count; \
         count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \
       } \
@@ -1387,7 +1394,7 @@ void Stepper::stepper_pulse_phase_isr() {
 
     #if ENABLED(LIN_ADVANCE)
       counter_E += current_block->steps[E_AXIS];
-      if (counter_E > 0) {
+      if (counter_E >= 0) {
         #if DISABLED(MIXING_EXTRUDER)
           // Don't step E here for mixing extruder
           motor_direction(E_AXIS) ? --e_steps : ++e_steps;
@@ -1399,7 +1406,7 @@ void Stepper::stepper_pulse_phase_isr() {
         const bool dir = motor_direction(E_AXIS);
         MIXING_STEPPERS_LOOP(j) {
           counter_m[j] += current_block->steps[E_AXIS];
-          if (counter_m[j] > 0) {
+          if (counter_m[j] >= 0) {
             counter_m[j] -= current_block->mix_event_count[j];
             dir ? --e_steps[j] : ++e_steps[j];
           }
@@ -1416,7 +1423,7 @@ void Stepper::stepper_pulse_phase_isr() {
           // Step mixing steppers (proportionally)
           counter_m[j] += current_block->steps[E_AXIS];
           // Step when the counter goes over zero
-          if (counter_m[j] > 0) En_STEP_WRITE(j, !INVERT_E_STEP_PIN);
+          if (counter_m[j] >= 0) En_STEP_WRITE(j, !INVERT_E_STEP_PIN);
         }
       #else // !MIXING_EXTRUDER
         PULSE_START(E);
@@ -1456,7 +1463,7 @@ void Stepper::stepper_pulse_phase_isr() {
     #if DISABLED(LIN_ADVANCE)
       #if ENABLED(MIXING_EXTRUDER)
         MIXING_STEPPERS_LOOP(j) {
-          if (counter_m[j] > 0) {
+          if (counter_m[j] >= 0) {
             counter_m[j] -= current_block->mix_event_count[j];
             En_STEP_WRITE(j, INVERT_E_STEP_PIN);
           }
@@ -1738,11 +1745,11 @@ uint32_t Stepper::stepper_block_phase_isr() {
         bezier_2nd_half = false;
       #endif
 
-      // Initialize Bresenham counters to 1/2 the ceiling
-      counter_X = counter_Y = counter_Z = counter_E = -((int32_t)(current_block->step_event_count >> 1));
+      // Initialize Bresenham counters to 1/2 the ceiling, with proper roundup (as explained in the article linked above)
+      counter_X = counter_Y = counter_Z = counter_E = -int32_t((current_block->step_event_count + 1) >> 1);
       #if ENABLED(MIXING_EXTRUDER)
         MIXING_STEPPERS_LOOP(i)
-          counter_m[i] = -(current_block->mix_event_count[i] >> 1);
+          counter_m[i] = -int32_t((current_block->mix_event_count[i] + 1) >> 1);
       #endif
 
       #if ENABLED(Z_LATE_ENABLE)

commit 2566342979481a81cd48c3eab1afa0ea926e19e8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 27 00:10:05 2018 -0500

    Adjust some commentary

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 8e2eb6fec1..b76b1b7b44 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -320,15 +320,15 @@ void Stepper::set_directions() {
 
 #if ENABLED(S_CURVE_ACCELERATION)
   /**
-   *   We are using a quintic (fifth-degree) Bézier polynomial for the velocity curve.
-   *  This gives us a "linear pop" velocity curve; with pop being the sixth derivative of position:
+   *  This uses a quintic (fifth-degree) Bézier polynomial for the velocity curve, giving
+   *  a "linear pop" velocity curve; with pop being the sixth derivative of position:
    *  velocity - 1st, acceleration - 2nd, jerk - 3rd, snap - 4th, crackle - 5th, pop - 6th
    *
    *  The Bézier curve takes the form:
    *
    *  V(t) = P_0 * B_0(t) + P_1 * B_1(t) + P_2 * B_2(t) + P_3 * B_3(t) + P_4 * B_4(t) + P_5 * B_5(t)
    *
-   *   Where 0 <= t <= 1, and V(t) is the velocity. P_0 through P_5 are the control points, and B_0(t)
+   *  Where 0 <= t <= 1, and V(t) is the velocity. P_0 through P_5 are the control points, and B_0(t)
    *  through B_5(t) are the Bernstein basis as follows:
    *
    *        B_0(t) =   (1-t)^5        =   -t^5 +  5t^4 - 10t^3 + 10t^2 -  5t   +   1
@@ -341,12 +341,12 @@ void Stepper::set_directions() {
    *                                      |       |       |       |       |       |
    *                                      A       B       C       D       E       F
    *
-   *   Unfortunately, we cannot use forward-differencing to calculate each position through
+   *  Unfortunately, we cannot use forward-differencing to calculate each position through
    *  the curve, as Marlin uses variable timer periods. So, we require a formula of the form:
    *
    *        V_f(t) = A*t^5 + B*t^4 + C*t^3 + D*t^2 + E*t + F
    *
-   *   Looking at the above B_0(t) through B_5(t) expanded forms, if we take the coefficients of t^5
+   *  Looking at the above B_0(t) through B_5(t) expanded forms, if we take the coefficients of t^5
    *  through t of the Bézier form of V(t), we can determine that:
    *
    *        A =    -P_0 +  5*P_1 - 10*P_2 + 10*P_3 -  5*P_4 +  P_5
@@ -356,7 +356,7 @@ void Stepper::set_directions() {
    *        E = - 5*P_0 +  5*P_1
    *        F =     P_0
    *
-   *   Now, since we will (currently) *always* want the initial acceleration and jerk values to be 0,
+   *  Now, since we will (currently) *always* want the initial acceleration and jerk values to be 0,
    *  We set P_i = P_0 = P_1 = P_2 (initial velocity), and P_t = P_3 = P_4 = P_5 (target velocity),
    *  which, after simplification, resolves to:
    *
@@ -367,12 +367,12 @@ void Stepper::set_directions() {
    *        E = 0
    *        F = P_i
    *
-   *   As the t is evaluated in non uniform steps here, there is no other way rather than evaluating
+   *  As the t is evaluated in non uniform steps here, there is no other way rather than evaluating
    *  the Bézier curve at each point:
    *
    *        V_f(t) = A*t^5 + B*t^4 + C*t^3 + F          [0 <= t <= 1]
    *
-   *   Floating point arithmetic execution time cost is prohibitive, so we will transform the math to
+   * Floating point arithmetic execution time cost is prohibitive, so we will transform the math to
    * use fixed point values to be able to evaluate it in realtime. Assuming a maximum of 250000 steps
    * per second (driver pulses should at least be 2µS hi/2µS lo), and allocating 2 bits to avoid
    * overflows on the evaluation of the Bézier curve, means we can use
@@ -383,7 +383,7 @@ void Stepper::set_directions() {
    *   C:   signed Q24.7 ,            |range = +/- 250000 *10 * 128 = +/- 320000000 = 0x1312D000 | 29 bits + sign
    *   F:   signed Q24.7 ,            |range = +/- 250000     * 128 =      32000000 = 0x01E84800 | 25 bits + sign
    *
-   *  The trapezoid generator state contains the following information, that we will use to create and evaluate
+   * The trapezoid generator state contains the following information, that we will use to create and evaluate
    * the Bézier curve:
    *
    *  blk->step_event_count [TS] = The total count of steps for this movement. (=distance)
@@ -395,7 +395,7 @@ void Stepper::set_directions() {
    *
    *  For Any 32bit CPU:
    *
-   *    At the start of each trapezoid, we calculate the coefficients A,B,C,F and Advance [AV], as follows:
+   *    At the start of each trapezoid, calculate the coefficients A,B,C,F and Advance [AV], as follows:
    *
    *      A =  6*128*(VF - VI) =  768*(VF - VI)
    *      B = 15*128*(VI - VF) = 1920*(VI - VF)
@@ -403,7 +403,7 @@ void Stepper::set_directions() {
    *      F =    128*VI        =  128*VI
    *     AV = (1<<32)/TS      ~= 0xFFFFFFFF / TS (To use ARM UDIV, that is 32 bits) (this is computed at the planner, to offload expensive calculations from the ISR)
    *
-   *   And for each point, we will evaluate the curve with the following sequence:
+   *    And for each point, evaluate the curve with the following sequence:
    *
    *      void lsrs(uint32_t& d, uint32_t s, int cnt) {
    *        d = s >> cnt;
@@ -456,10 +456,10 @@ void Stepper::set_directions() {
    *        return alo;
    *      }
    *
-   *    This will be rewritten in ARM assembly to get peak performance and will take 43 cycles to execute
+   *  This is rewritten in ARM assembly for optimal performance (43 cycles to execute).
    *
-   *  For AVR, we scale precision of coefficients to make it possible to evaluate the Bézier curve in
-   *    realtime: Let's reduce precision as much as possible. After some experimentation we found that:
+   *  For AVR, the precision of coefficients is scaled so the Bézier curve can be evaluated in real-time:
+   *  Let's reduce precision as much as possible. After some experimentation we found that:
    *
    *    Assume t and AV with 24 bits is enough
    *       A =  6*(VF - VI)
@@ -468,9 +468,9 @@ void Stepper::set_directions() {
    *       F =     VI
    *      AV = (1<<24)/TS   (this is computed at the planner, to offload expensive calculations from the ISR)
    *
-   *     Instead of storing sign for each coefficient, we will store its absolute value,
+   *    Instead of storing sign for each coefficient, we will store its absolute value,
    *    and flag the sign of the A coefficient, so we can save to store the sign bit.
-   *     It always holds that sign(A) = - sign(B) = sign(C)
+   *    It always holds that sign(A) = - sign(B) = sign(C)
    *
    *     So, the resulting range of the coefficients are:
    *
@@ -480,7 +480,7 @@ void Stepper::set_directions() {
    *       C:   signed Q24 , range = 250000 *10 = 2500000 = 0x1312D0 | 21 bits
    *       F:   signed Q24 , range = 250000     =  250000 = 0x0ED090 | 20 bits
    *
-   *    And for each curve, we estimate its coefficients with:
+   *    And for each curve, estimate its coefficients with:
    *
    *      void _calc_bezier_curve_coeffs(int32_t v0, int32_t v1, uint32_t av) {
    *       // Calculate the Bézier coefficients
@@ -499,7 +499,7 @@ void Stepper::set_directions() {
    *       bezier_F = v0;
    *      }
    *
-   *    And for each point, we will evaluate the curve with the following sequence:
+   *    And for each point, evaluate the curve with the following sequence:
    *
    *      // unsigned multiplication of 24 bits x 24bits, return upper 16 bits
    *      void umul24x24to16hi(uint16_t& r, uint24_t op1, uint24_t op2) {
@@ -549,9 +549,8 @@ void Stepper::set_directions() {
    *        }
    *        return acc;
    *      }
-   *    Those functions will be translated into assembler to get peak performance. coefficient calculations takes 70 cycles,
-   *    Bezier point evaluation takes 150 cycles
-   *
+   *    These functions are translated to assembler for optimal performance.
+   *    Coefficient calculation takes 70 cycles. Bezier point evaluation takes 150 cycles.
    */
 
   #ifdef __AVR__

commit 6775a16c9785bc3d94bbe9a0f20c787e40fc2916
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 26 19:06:49 2018 -0500

    Fix switching extruder stepping with LA

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 9c9a087f48..8e2eb6fec1 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1797,26 +1797,26 @@ uint32_t Stepper::stepper_block_phase_isr() {
     #elif ENABLED(SWITCHING_EXTRUDER)
       #if EXTRUDERS > 4
         #define START_E_PULSE(INDEX) do{ if (e_steps) { switch (INDEX) { \
-            case 0: case 1: E0_DIR_WRITE(!INVERT_E_STEP_PIN); break; \
-            case 2: case 3: E1_DIR_WRITE(!INVERT_E_STEP_PIN); break; \
-                    case 4: E2_DIR_WRITE(!INVERT_E_STEP_PIN); } \
+            case 0: case 1: E0_STEP_WRITE(!INVERT_E_STEP_PIN); break; \
+            case 2: case 3: E1_STEP_WRITE(!INVERT_E_STEP_PIN); break; \
+                    case 4: E2_STEP_WRITE(!INVERT_E_STEP_PIN); } \
         } }while(0)
         #define STOP_E_PULSE(INDEX) do{ if (e_steps) { \
           e_steps < 0 ? ++e_steps : --e_steps; \
           switch (INDEX) { \
-            case 0: case 1: E0_DIR_WRITE(INVERT_E_STEP_PIN); break; \
-            case 2: case 3: E1_DIR_WRITE(INVERT_E_STEP_PIN); break; \
-                    case 4: E2_DIR_WRITE(INVERT_E_STEP_PIN); } \
+            case 0: case 1: E0_STEP_WRITE( INVERT_E_STEP_PIN); break; \
+            case 2: case 3: E1_STEP_WRITE( INVERT_E_STEP_PIN); break; \
+                    case 4: E2_STEP_WRITE( INVERT_E_STEP_PIN); } \
         } }while(0)
       #elif EXTRUDERS > 2
-        #define START_E_PULSE(INDEX) do{ if (e_steps) { if (INDEX < 2) E0_DIR_WRITE(!INVERT_E_STEP_PIN); else E1_DIR_WRITE(!INVERT_E_STEP_PIN); } }while(0)
+        #define START_E_PULSE(INDEX) do{ if (e_steps) { if (INDEX < 2) E0_STEP_WRITE(!INVERT_E_STEP_PIN); else E1_STEP_WRITE(!INVERT_E_STEP_PIN); } }while(0)
         #define STOP_E_PULSE(INDEX) do{ if (e_steps) { \
           e_steps < 0 ? ++e_steps : --e_steps; \
-          if (INDEX < 2) E0_DIR_WRITE(INVERT_E_STEP_PIN); else E1_DIR_WRITE(INVERT_E_STEP_PIN); \
+          if (INDEX < 2) E0_STEP_WRITE(INVERT_E_STEP_PIN); else E1_STEP_WRITE(INVERT_E_STEP_PIN); \
         } }while(0)
       #else
-        #define START_E_PULSE(INDEX) do{ if (e_steps) E0_DIR_WRITE(!INVERT_E_STEP_PIN); }while(0)
-        #define STOP_E_PULSE(INDEX) do{ if (e_steps) { e_steps < 0 ? ++e_steps : --e_steps; E0_DIR_WRITE(INVERT_E_STEP_PIN); }while(0)
+        #define START_E_PULSE(INDEX) do{ if (e_steps) E0_STEP_WRITE(!INVERT_E_STEP_PIN); }while(0)
+        #define STOP_E_PULSE(INDEX) do{ if (e_steps) { e_steps < 0 ? ++e_steps : --e_steps; E0_STEP_WRITE(INVERT_E_STEP_PIN); }while(0)
       #endif
     #else
       #define START_E_PULSE(INDEX) do{ if (e_steps) E## INDEX ##_STEP_WRITE(!INVERT_E_STEP_PIN); }while(0)

commit aaaf09bda27eff38d773b4b73925442f61d34866
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 26 02:02:39 2018 -0500

    BEZIER_JERK_CONTROL => S_CURVE_ACCELERATION

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b4411579ce..9c9a087f48 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -118,7 +118,7 @@ int32_t Stepper::counter_X = 0,
 
 uint32_t Stepper::step_events_completed = 0; // The number of step events executed in the current block
 
-#if ENABLED(BEZIER_JERK_CONTROL)
+#if ENABLED(S_CURVE_ACCELERATION)
   int32_t __attribute__((used)) Stepper::bezier_A __asm__("bezier_A");    // A coefficient in Bézier speed curve with alias for assembler
   int32_t __attribute__((used)) Stepper::bezier_B __asm__("bezier_B");    // B coefficient in Bézier speed curve with alias for assembler
   int32_t __attribute__((used)) Stepper::bezier_C __asm__("bezier_C");    // C coefficient in Bézier speed curve with alias for assembler
@@ -168,7 +168,7 @@ volatile signed char Stepper::count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
 uint32_t Stepper::ticks_nominal;
 uint8_t Stepper::step_loops, Stepper::step_loops_nominal;
 
-#if DISABLED(BEZIER_JERK_CONTROL)
+#if DISABLED(S_CURVE_ACCELERATION)
   uint32_t Stepper::acc_step_rate; // needed for deceleration start point
 #endif
 
@@ -318,7 +318,7 @@ void Stepper::set_directions() {
   #endif // !LIN_ADVANCE
 }
 
-#if ENABLED(BEZIER_JERK_CONTROL)
+#if ENABLED(S_CURVE_ACCELERATION)
   /**
    *   We are using a quintic (fifth-degree) Bézier polynomial for the velocity curve.
    *  This gives us a "linear pop" velocity curve; with pop being the sixth derivative of position:
@@ -1122,7 +1122,7 @@ void Stepper::set_directions() {
       #endif
     }
   #endif
-#endif // BEZIER_JERK_CONTROL
+#endif // S_CURVE_ACCELERATION
 
 /**
  * Stepper Driver Interrupt
@@ -1497,7 +1497,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
     // Calculate new timer value
     if (step_events_completed <= current_block->accelerate_until) {
 
-      #if ENABLED(BEZIER_JERK_CONTROL)
+      #if ENABLED(S_CURVE_ACCELERATION)
         // Get the next speed to use (Jerk limited!)
         uint32_t acc_step_rate =
           acceleration_time < current_block->acceleration_time
@@ -1528,7 +1528,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
     else if (step_events_completed > current_block->decelerate_after) {
       uint32_t step_rate;
 
-      #if ENABLED(BEZIER_JERK_CONTROL)
+      #if ENABLED(S_CURVE_ACCELERATION)
         // If this is the 1st time we process the 2nd half of the trapezoid...
         if (!bezier_2nd_half) {
           // Initialize the Bézier speed curve
@@ -1726,12 +1726,12 @@ uint32_t Stepper::stepper_block_phase_isr() {
       // make a note of the number of step loops required at nominal speed
       step_loops_nominal = step_loops;
 
-      #if DISABLED(BEZIER_JERK_CONTROL)
+      #if DISABLED(S_CURVE_ACCELERATION)
         // Set as deceleration point the initial rate of the block
         acc_step_rate = current_block->initial_rate;
       #endif
 
-      #if ENABLED(BEZIER_JERK_CONTROL)
+      #if ENABLED(S_CURVE_ACCELERATION)
         // Initialize the Bézier speed curve
         _calc_bezier_curve_coeffs(current_block->initial_rate, current_block->cruise_rate, current_block->acceleration_time_inverse);
 

commit 01d37e00af73bab50c084d01ae1f837653781f52
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 26 01:00:13 2018 -0500

    Fix up stepper ISR with linear advance timing (#10853)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b705688a40..b4411579ce 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -642,7 +642,7 @@ void Stepper::set_directions() {
         A("mul %10,%9")             /* r1:r0 = 10*HI(v0-v1) */
         A("add %7,r0")              /* %7:%6:?? += 10*HI(v0-v1) << 16 */
         A("sts bezier_C+1, %6")
-        " sts bezier_C+2, %7"            /* bezier_C = %7:%6:?? = 10*(v0-v1) [65 cycles worst] */
+        " sts bezier_C+2, %7"       /* bezier_C = %7:%6:?? = 10*(v0-v1) [65 cycles worst] */
         : "+r" (r2),
           "+d" (r3),
           "=r" (r4),
@@ -1025,7 +1025,7 @@ void Stepper::set_directions() {
         A("add %3,r0")
         A("adc %4,r1")              /* %4:%3:%2:%9 += HI(bezier_A) * LO(f) << 16*/
         L("2")
-        " clr __zero_reg__"              /* C runtime expects r1 = __zero_reg__ = 0 */
+        " clr __zero_reg__"         /* C runtime expects r1 = __zero_reg__ = 0 */
         : "+r"(r0),
           "+r"(r1),
           "+r"(r2),
@@ -1152,16 +1152,8 @@ HAL_STEP_TIMER_ISR {
   // Call the ISR scheduler
   hal_timer_t ticks = Stepper::isr_scheduler();
 
-  // Now 'ticks' contains the period to the next Stepper ISR.
-  // Potential problem: Since the timer continues to run, the requested
-  // compare value may already have passed.
-  //
-  // Assuming at least 6µs between calls to this ISR...
-  // On AVR the ISR epilogue is estimated at 40 instructions - close to 2.5µS.
-  // On ARM the ISR epilogue is estimated at 10 instructions - close to 200nS.
-  // In either case leave at least 4µS for other tasks to execute.
-  const hal_timer_t minticks = HAL_timer_get_count(STEP_TIMER_NUM) + hal_timer_t((HAL_TICKS_PER_US) * 4); // ISR never takes more than 1ms, so this shouldn't cause trouble
-  NOLESS(ticks, MAX(minticks, hal_timer_t((STEP_TIMER_MIN_INTERVAL) * (HAL_TICKS_PER_US))));
+  // Now 'ticks' contains the period to the next Stepper ISR - And we are
+  // sure that the time has not arrived yet - Warrantied by the scheduler
 
   // Set the next ISR to fire at the proper time
   HAL_timer_set_compare(STEP_TIMER_NUM, ticks);
@@ -1178,54 +1170,105 @@ HAL_STEP_TIMER_ISR {
 hal_timer_t Stepper::isr_scheduler() {
   uint32_t interval;
 
-  // Run main stepping pulse phase ISR if we have to
-  if (!nextMainISR) Stepper::stepper_pulse_phase_isr();
+  // Count of ticks for the next ISR
+  hal_timer_t next_isr_ticks = 0;
 
-  #if ENABLED(LIN_ADVANCE)
-    // Run linear advance stepper ISR if we have to
-    if (!nextAdvanceISR) nextAdvanceISR = Stepper::advance_isr();
-  #endif
+  // Limit the amount of iterations
+  uint8_t max_loops = 10;
+  
+  // We need this variable here to be able to use it in the following loop
+  hal_timer_t min_ticks;
+  do {
+    // Run main stepping pulse phase ISR if we have to
+    if (!nextMainISR) Stepper::stepper_pulse_phase_isr();
 
-  // ^== Time critical. NOTHING besides pulse generation should be above here!!!
+    #if ENABLED(LIN_ADVANCE)
+      // Run linear advance stepper ISR if we have to
+      if (!nextAdvanceISR) nextAdvanceISR = Stepper::advance_isr();
+    #endif
 
-  // Run main stepping block processing ISR if we have to
-  if (!nextMainISR) nextMainISR = Stepper::stepper_block_phase_isr();
+    // ^== Time critical. NOTHING besides pulse generation should be above here!!!
 
-  #if ENABLED(LIN_ADVANCE)
-    // Select the closest interval in time
-    interval = (nextAdvanceISR <= nextMainISR)
-      ? nextAdvanceISR
-      : nextMainISR;
+    // Run main stepping block processing ISR if we have to
+    if (!nextMainISR) nextMainISR = Stepper::stepper_block_phase_isr();
 
-  #else // !ENABLED(LIN_ADVANCE)
+    #if ENABLED(LIN_ADVANCE)
+      // Select the closest interval in time
+      interval = (nextAdvanceISR <= nextMainISR) ? nextAdvanceISR : nextMainISR;
+    #else
+      // The interval is just the remaining time to the stepper ISR
+      interval = nextMainISR;
+    #endif
 
-    // The interval is just the remaining time to the stepper ISR
-    interval = nextMainISR;
-  #endif
+    // Limit the value to the maximum possible value of the timer
+    NOMORE(interval, HAL_TIMER_TYPE_MAX);
 
-  // Limit the value to the maximum possible value of the timer
-  if (interval > HAL_TIMER_TYPE_MAX)
-    interval = HAL_TIMER_TYPE_MAX;
+    // Compute the time remaining for the main isr
+    nextMainISR -= interval;
 
-  // Compute the time remaining for the main isr
-  nextMainISR -= interval;
+    #if ENABLED(LIN_ADVANCE)
+      // Compute the time remaining for the advance isr
+      if (nextAdvanceISR != ADV_NEVER) nextAdvanceISR -= interval;
+    #endif
 
-  #if ENABLED(LIN_ADVANCE)
-    // Compute the time remaining for the advance isr
-    if (nextAdvanceISR != ADV_NEVER)
-      nextAdvanceISR -= interval;
-  #endif
+    /**
+     * This needs to avoid a race-condition caused by interleaving
+     * of interrupts required by both the LA and Stepper algorithms.
+     *
+     * Assume the following tick times for stepper pulses:
+     *   Stepper ISR (S):  1 1000 2000 3000 4000
+     *   Linear Adv. (E): 10 1010 2010 3010 4010
+     *
+     * The current algorithm tries to interleave them, giving:
+     *  1:S 10:E 1000:S 1010:E 2000:S 2010:E 3000:S 3010:E 4000:S 4010:E
+     *
+     * Ideal timing would yield these delta periods:
+     *  1:S  9:E  990:S   10:E  990:S   10:E  990:S   10:E  990:S   10:E
+     *
+     * But, since each event must fire an ISR with a minimum duration, the
+     * minimum delta might be 900, so deltas under 900 get rounded up:
+     *  900:S d900:E d990:S d900:E d990:S d900:E d990:S d900:E d990:S d900:E
+     *
+     * It works, but divides the speed of all motors by half, leading to a sudden
+     * reduction to 1/2 speed! Such jumps in speed lead to lost steps (not even
+     * accounting for double/quad stepping, which makes it even worse).
+     */
+
+    // Compute the tick count for the next ISR
+    next_isr_ticks += interval;
+
+    /**
+     * Get the current tick value + margin
+     * Assuming at least 6µs between calls to this ISR...
+     * On AVR the ISR epilogue is estimated at 40 instructions - close to 2.5µS.
+     * On ARM the ISR epilogue is estimated at 10 instructions - close to 200nS.
+     * In either case leave at least 8µS for other tasks to execute - That allows
+     * up to 100khz stepping rates
+     */
+    min_ticks = HAL_timer_get_count(STEP_TIMER_NUM) + hal_timer_t((HAL_TICKS_PER_US) * 8); // ISR never takes more than 1ms, so this shouldn't cause trouble
 
-  return (hal_timer_t)interval;
+    /**
+     * NB: If for some reason the stepper monopolizes the MPU, eventually the
+     * timer will wrap around (and so will 'next_isr_ticks'). So, limit the
+     * loop to 10 iterations. Beyond that, there's no way to ensure correct pulse
+     * timing, since the MCU isn't fast enough.
+     */
+    if (!--max_loops) next_isr_ticks = min_ticks;
+
+    // Advance pulses if not enough time to wait for the next ISR
+  } while (next_isr_ticks < min_ticks);
+
+  // Return the count of ticks for the next ISR
+  return (hal_timer_t)next_isr_ticks;
 }
 
-// This part of the ISR should ONLY create the pulses for the steppers
-// -- Nothing more, nothing less -- We want to avoid jitter from where
-// the pulses should be generated (when the interrupt triggers) to the
-// time pulses are actually created. So, PLEASE DO NOT PLACE ANY CODE
-// above this line that can conditionally change that time (we are trying
-// to keep the delay between the interrupt triggering and pulse generation
-// as constant as possible!!!!
+/**
+ * This phase of the ISR should ONLY create the pulses for the steppers.
+ * This prevents jitter caused by the interval between the start of the
+ * interrupt and the start of the pulses. DON'T add any logic ahead of the
+ * call to this method that might cause variation in the timing. The aim
+ * is to keep pulse timing as regular as possible.
+ */
 void Stepper::stepper_pulse_phase_isr() {
 
   // If we must abort the current block, do so!

commit 7261f48872fd9adba6ac890f886a00daeb852b0c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 24 19:28:15 2018 -0500

    Fix reset of endstops and move state

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 1c11823da6..b705688a40 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1232,6 +1232,7 @@ void Stepper::stepper_pulse_phase_isr() {
   if (abort_current_block) {
     abort_current_block = false;
     if (current_block) {
+      axis_did_move = 0;
       current_block = NULL;
       planner.discard_current_block();
     }
@@ -1541,6 +1542,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
 
     // If current block is finished, reset pointer
     if (all_steps_done) {
+      axis_did_move = 0;
       current_block = NULL;
       planner.discard_current_block();
     }

commit 50fa8e01c1f2e23face239d7c7bc48cc7aa1e58a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 24 19:08:07 2018 -0500

    Minor optimization of axis_did_move bits

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 914cc86c86..1c11823da6 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1628,13 +1628,15 @@ uint32_t Stepper::stepper_block_phase_isr() {
         #define Z_MOVE_TEST !!current_block->steps[C_AXIS]
       #endif
 
-      SET_BIT_TO(axis_did_move, X_AXIS, X_MOVE_TEST);
-      SET_BIT_TO(axis_did_move, Y_AXIS, Y_MOVE_TEST);
-      SET_BIT_TO(axis_did_move, Z_AXIS, Z_MOVE_TEST);
-      //SET_BIT_TO(axis_did_move, E_AXIS, !!current_block->steps[E_AXIS]);
-      //SET_BIT_TO(axis_did_move, X_HEAD, !!current_block->steps[A_AXIS]);
-      //SET_BIT_TO(axis_did_move, Y_HEAD, !!current_block->steps[B_AXIS]);
-      //SET_BIT_TO(axis_did_move, Z_HEAD, !!current_block->steps[C_AXIS]);
+      uint8_t axis_bits = 0;
+      if (X_MOVE_TEST) SBI(axis_bits, A_AXIS);
+      if (Y_MOVE_TEST) SBI(axis_bits, B_AXIS);
+      if (Z_MOVE_TEST) SBI(axis_bits, C_AXIS);
+      //if (!!current_block->steps[E_AXIS]) SBI(axis_bits, E_AXIS);
+      //if (!!current_block->steps[A_AXIS]) SBI(axis_bits, X_HEAD);
+      //if (!!current_block->steps[B_AXIS]) SBI(axis_bits, Y_HEAD);
+      //if (!!current_block->steps[C_AXIS]) SBI(axis_bits, Z_HEAD);
+      axis_did_move = axis_bits;
 
       // Initialize the trapezoid generator from the current block.
       #if ENABLED(LIN_ADVANCE)

commit f28e366b775919a2c604b0ecad60c73b0b9ca9ce
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 24 03:02:44 2018 -0500

    Followup for core endstops

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 62f91d5ecf..914cc86c86 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1571,7 +1571,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
       #if IS_CORE
         // Define conditions for checking endstops
         #define S_(N) current_block->steps[CORE_AXIS_##N]
-        #define D_(N) motor_direction(CORE_AXIS_##N)
+        #define D_(N) TEST(current_block->direction_bits, CORE_AXIS_##N)
       #endif
 
       #if CORE_IS_XY || CORE_IS_XZ

commit 9644d56b42de1d45b292f67cda950387fd76aa06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 24 00:04:47 2018 -0500

    Patches for core motion tests

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 64f38bd69a..62f91d5ecf 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1589,7 +1589,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
         #endif
         #define X_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) X_CMP D_(2)) )
       #else
-        #define X_MOVE_TEST !!current_block->steps[X_AXIS]
+        #define X_MOVE_TEST !!current_block->steps[A_AXIS]
       #endif
 
       #if CORE_IS_XY || CORE_IS_YZ
@@ -1607,7 +1607,7 @@ uint32_t Stepper::stepper_block_phase_isr() {
         #endif
         #define Y_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Y_CMP D_(2)) )
       #else
-        #define Y_MOVE_TEST !!current_block->steps[Y_AXIS]
+        #define Y_MOVE_TEST !!current_block->steps[B_AXIS]
       #endif
 
       #if CORE_IS_XZ || CORE_IS_YZ
@@ -1625,16 +1625,16 @@ uint32_t Stepper::stepper_block_phase_isr() {
         #endif
         #define Z_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Z_CMP D_(2)) )
       #else
-        #define Z_MOVE_TEST !!current_block->steps[Z_AXIS]
+        #define Z_MOVE_TEST !!current_block->steps[C_AXIS]
       #endif
 
-      SET_BIT(axis_did_move, X_AXIS, X_MOVE_TEST);
-      SET_BIT(axis_did_move, Y_AXIS, Y_MOVE_TEST);
-      SET_BIT(axis_did_move, Z_AXIS, Z_MOVE_TEST);
-      SET_BIT(axis_did_move, E_AXIS, !!current_block->steps[E_AXIS]);
-      SET_BIT(axis_did_move, X_HEAD, !!current_block->steps[X_HEAD]);
-      SET_BIT(axis_did_move, Y_HEAD, !!current_block->steps[Y_HEAD]);
-      SET_BIT(axis_did_move, Z_HEAD, !!current_block->steps[Z_HEAD]);
+      SET_BIT_TO(axis_did_move, X_AXIS, X_MOVE_TEST);
+      SET_BIT_TO(axis_did_move, Y_AXIS, Y_MOVE_TEST);
+      SET_BIT_TO(axis_did_move, Z_AXIS, Z_MOVE_TEST);
+      //SET_BIT_TO(axis_did_move, E_AXIS, !!current_block->steps[E_AXIS]);
+      //SET_BIT_TO(axis_did_move, X_HEAD, !!current_block->steps[A_AXIS]);
+      //SET_BIT_TO(axis_did_move, Y_HEAD, !!current_block->steps[B_AXIS]);
+      //SET_BIT_TO(axis_did_move, Z_HEAD, !!current_block->steps[C_AXIS]);
 
       // Initialize the trapezoid generator from the current block.
       #if ENABLED(LIN_ADVANCE)

commit 3e3789da85e4d25693506df9dfd094aabf98d50e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 23 03:45:25 2018 -0500

    Regression: Endstops Core compatibility (#10823)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index bc61658ed7..64f38bd69a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -96,10 +96,10 @@ block_t* Stepper::current_block = NULL;  // A pointer to the block currently bei
 
 // private:
 
-uint8_t Stepper::last_direction_bits = 0,       // The next stepping-bits to be output
-        Stepper::last_movement_extruder = 0xFF; // Last movement extruder, as computed when the last movement was fetched from planner
-bool Stepper::abort_current_block,              // Signals to the stepper that current block should be aborted
-     Stepper::last_movement_non_null[NUM_AXIS]; // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
+uint8_t Stepper::last_direction_bits = 0,
+        Stepper::last_movement_extruder = 0xFF,
+        Stepper::axis_did_move;
+bool Stepper::abort_current_block;
 
 #if ENABLED(X_DUAL_ENDSTOPS)
   bool Stepper::locked_x_motor = false, Stepper::locked_x2_motor = false;
@@ -1566,8 +1566,75 @@ uint32_t Stepper::stepper_block_phase_isr() {
           return interval; // No more queued movements!
       }
 
-      // Compute movement direction for proper endstop handling
-      LOOP_NA(i) last_movement_non_null[i] = !!current_block->steps[i];
+      // Flag all moving axes for proper endstop handling
+
+      #if IS_CORE
+        // Define conditions for checking endstops
+        #define S_(N) current_block->steps[CORE_AXIS_##N]
+        #define D_(N) motor_direction(CORE_AXIS_##N)
+      #endif
+
+      #if CORE_IS_XY || CORE_IS_XZ
+        /**
+         * Head direction in -X axis for CoreXY and CoreXZ bots.
+         *
+         * If steps differ, both axes are moving.
+         * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z, handled below)
+         * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X)
+         */
+        #if ENABLED(COREXY) || ENABLED(COREXZ)
+          #define X_CMP ==
+        #else
+          #define X_CMP !=
+        #endif
+        #define X_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) X_CMP D_(2)) )
+      #else
+        #define X_MOVE_TEST !!current_block->steps[X_AXIS]
+      #endif
+
+      #if CORE_IS_XY || CORE_IS_YZ
+        /**
+         * Head direction in -Y axis for CoreXY / CoreYZ bots.
+         *
+         * If steps differ, both axes are moving
+         * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y)
+         * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z)
+         */
+        #if ENABLED(COREYX) || ENABLED(COREYZ)
+          #define Y_CMP ==
+        #else
+          #define Y_CMP !=
+        #endif
+        #define Y_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Y_CMP D_(2)) )
+      #else
+        #define Y_MOVE_TEST !!current_block->steps[Y_AXIS]
+      #endif
+
+      #if CORE_IS_XZ || CORE_IS_YZ
+        /**
+         * Head direction in -Z axis for CoreXZ or CoreYZ bots.
+         *
+         * If steps differ, both axes are moving
+         * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y, already handled above)
+         * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Z)
+         */
+        #if ENABLED(COREZX) || ENABLED(COREZY)
+          #define Z_CMP ==
+        #else
+          #define Z_CMP !=
+        #endif
+        #define Z_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Z_CMP D_(2)) )
+      #else
+        #define Z_MOVE_TEST !!current_block->steps[Z_AXIS]
+      #endif
+
+      SET_BIT(axis_did_move, X_AXIS, X_MOVE_TEST);
+      SET_BIT(axis_did_move, Y_AXIS, Y_MOVE_TEST);
+      SET_BIT(axis_did_move, Z_AXIS, Z_MOVE_TEST);
+      SET_BIT(axis_did_move, E_AXIS, !!current_block->steps[E_AXIS]);
+      SET_BIT(axis_did_move, X_HEAD, !!current_block->steps[X_HEAD]);
+      SET_BIT(axis_did_move, Y_HEAD, !!current_block->steps[Y_HEAD]);
+      SET_BIT(axis_did_move, Z_HEAD, !!current_block->steps[Z_HEAD]);
 
       // Initialize the trapezoid generator from the current block.
       #if ENABLED(LIN_ADVANCE)

commit 4b2f6e3b2b0d6773cb15e55433bb243625ba71ea
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 21 15:51:38 2018 -0500

    [2.0.x] Add endstop noise filter (#10796)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 56a4b0d6d5..bc61658ed7 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -184,12 +184,12 @@ volatile int32_t Stepper::endstops_trigsteps[XYZ];
   #define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                                      \
     if (performing_homing) {                                                                                                                \
       if (A##_HOME_DIR < 0) {                                                                                                               \
-        if (!(TEST(endstops.current_endstop_bits, A##_MIN) && count_direction[_AXIS(A)] < 0) && !LOCKED_##A##_MOTOR) A##_STEP_WRITE(V);     \
-        if (!(TEST(endstops.current_endstop_bits, A##2_MIN) && count_direction[_AXIS(A)] < 0) && !LOCKED_##A##2_MOTOR) A##2_STEP_WRITE(V);  \
+        if (!(TEST(endstops.state(), A##_MIN) && count_direction[_AXIS(A)] < 0) && !LOCKED_##A##_MOTOR) A##_STEP_WRITE(V);     \
+        if (!(TEST(endstops.state(), A##2_MIN) && count_direction[_AXIS(A)] < 0) && !LOCKED_##A##2_MOTOR) A##2_STEP_WRITE(V);  \
       }                                                                                                                                     \
       else {                                                                                                                                \
-        if (!(TEST(endstops.current_endstop_bits, A##_MAX) && count_direction[_AXIS(A)] > 0) && !LOCKED_##A##_MOTOR) A##_STEP_WRITE(V);     \
-        if (!(TEST(endstops.current_endstop_bits, A##2_MAX) && count_direction[_AXIS(A)] > 0) && !LOCKED_##A##2_MOTOR) A##2_STEP_WRITE(V);  \
+        if (!(TEST(endstops.state(), A##_MAX) && count_direction[_AXIS(A)] > 0) && !LOCKED_##A##_MOTOR) A##_STEP_WRITE(V);     \
+        if (!(TEST(endstops.state(), A##2_MAX) && count_direction[_AXIS(A)] > 0) && !LOCKED_##A##2_MOTOR) A##2_STEP_WRITE(V);  \
       }                                                                                                                                     \
     }                                                                                                                                       \
     else {                                                                                                                                  \

commit 435ecb6b67e285becad4e6ca8375ffc8b5cb6025
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 20 22:20:11 2018 -0500

    Followup to stepper/planner refactor

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 23a4acd3d4..56a4b0d6d5 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -181,20 +181,20 @@ volatile int32_t Stepper::endstops_trigsteps[XYZ];
   #define LOCKED_X2_MOTOR locked_x2_motor
   #define LOCKED_Y2_MOTOR locked_y2_motor
   #define LOCKED_Z2_MOTOR locked_z2_motor
-  #define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                                           \
-    if (performing_homing) {                                                                                                                        \
-      if (A##_HOME_DIR < 0) {                                                                                                                    \
+  #define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                                      \
+    if (performing_homing) {                                                                                                                \
+      if (A##_HOME_DIR < 0) {                                                                                                               \
         if (!(TEST(endstops.current_endstop_bits, A##_MIN) && count_direction[_AXIS(A)] < 0) && !LOCKED_##A##_MOTOR) A##_STEP_WRITE(V);     \
         if (!(TEST(endstops.current_endstop_bits, A##2_MIN) && count_direction[_AXIS(A)] < 0) && !LOCKED_##A##2_MOTOR) A##2_STEP_WRITE(V);  \
-      }                                                                                                                                             \
-      else {                                                                                                                                        \
+      }                                                                                                                                     \
+      else {                                                                                                                                \
         if (!(TEST(endstops.current_endstop_bits, A##_MAX) && count_direction[_AXIS(A)] > 0) && !LOCKED_##A##_MOTOR) A##_STEP_WRITE(V);     \
         if (!(TEST(endstops.current_endstop_bits, A##2_MAX) && count_direction[_AXIS(A)] > 0) && !LOCKED_##A##2_MOTOR) A##2_STEP_WRITE(V);  \
-      }                                                                                                                                             \
-    }                                                                                                                                               \
-    else {                                                                                                                                          \
-      A##_STEP_WRITE(V);                                                                                                                         \
-      A##2_STEP_WRITE(V);                                                                                                                        \
+      }                                                                                                                                     \
+    }                                                                                                                                       \
+    else {                                                                                                                                  \
+      A##_STEP_WRITE(V);                                                                                                                    \
+      A##2_STEP_WRITE(V);                                                                                                                   \
     }
 #endif
 
@@ -2035,7 +2035,7 @@ int32_t Stepper::position(const AxisEnum axis) {
     if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
   #endif
 
-  int32_t v = count_position[axis];
+  const int32_t v = count_position[axis];
 
   #ifdef __AVR__
     // Reenable Stepper ISR

commit 569df3fc0ccb8b000cc56dd55e6369008ed3f7a2
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 16 04:08:43 2018 -0300

    Fix interrupt-based endstop detection
    
    - Also implemented real endstop reading on interrupt.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 3a7336f734..23a4acd3d4 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -96,7 +96,10 @@ block_t* Stepper::current_block = NULL;  // A pointer to the block currently bei
 
 // private:
 
-uint8_t Stepper::last_direction_bits = 0;        // The next stepping-bits to be output
+uint8_t Stepper::last_direction_bits = 0,       // The next stepping-bits to be output
+        Stepper::last_movement_extruder = 0xFF; // Last movement extruder, as computed when the last movement was fetched from planner
+bool Stepper::abort_current_block,              // Signals to the stepper that current block should be aborted
+     Stepper::last_movement_non_null[NUM_AXIS]; // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
 
 #if ENABLED(X_DUAL_ENDSTOPS)
   bool Stepper::locked_x_motor = false, Stepper::locked_x2_motor = false;
@@ -181,12 +184,12 @@ volatile int32_t Stepper::endstops_trigsteps[XYZ];
   #define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                                           \
     if (performing_homing) {                                                                                                                        \
       if (A##_HOME_DIR < 0) {                                                                                                                    \
-        if (!(TEST(endstops.old_endstop_bits, A##_MIN) && count_direction[_AXIS(A)] < 0) && !LOCKED_##A##_MOTOR) A##_STEP_WRITE(V);     \
-        if (!(TEST(endstops.old_endstop_bits, A##2_MIN) && count_direction[_AXIS(A)] < 0) && !LOCKED_##A##2_MOTOR) A##2_STEP_WRITE(V);  \
+        if (!(TEST(endstops.current_endstop_bits, A##_MIN) && count_direction[_AXIS(A)] < 0) && !LOCKED_##A##_MOTOR) A##_STEP_WRITE(V);     \
+        if (!(TEST(endstops.current_endstop_bits, A##2_MIN) && count_direction[_AXIS(A)] < 0) && !LOCKED_##A##2_MOTOR) A##2_STEP_WRITE(V);  \
       }                                                                                                                                             \
       else {                                                                                                                                        \
-        if (!(TEST(endstops.old_endstop_bits, A##_MAX) && count_direction[_AXIS(A)] > 0) && !LOCKED_##A##_MOTOR) A##_STEP_WRITE(V);     \
-        if (!(TEST(endstops.old_endstop_bits, A##2_MAX) && count_direction[_AXIS(A)] > 0) && !LOCKED_##A##2_MOTOR) A##2_STEP_WRITE(V);  \
+        if (!(TEST(endstops.current_endstop_bits, A##_MAX) && count_direction[_AXIS(A)] > 0) && !LOCKED_##A##_MOTOR) A##_STEP_WRITE(V);     \
+        if (!(TEST(endstops.current_endstop_bits, A##2_MAX) && count_direction[_AXIS(A)] > 0) && !LOCKED_##A##2_MOTOR) A##2_STEP_WRITE(V);  \
       }                                                                                                                                             \
     }                                                                                                                                               \
     else {                                                                                                                                          \
@@ -315,10 +318,6 @@ void Stepper::set_directions() {
   #endif // !LIN_ADVANCE
 }
 
-#if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-  extern volatile uint8_t e_hit;
-#endif
-
 #if ENABLED(BEZIER_JERK_CONTROL)
   /**
    *   We are using a quintic (fifth-degree) Bézier polynomial for the velocity curve.
@@ -1229,6 +1228,15 @@ hal_timer_t Stepper::isr_scheduler() {
 // as constant as possible!!!!
 void Stepper::stepper_pulse_phase_isr() {
 
+  // If we must abort the current block, do so!
+  if (abort_current_block) {
+    abort_current_block = false;
+    if (current_block) {
+      current_block = NULL;
+      planner.discard_current_block();
+    }
+  }
+
   // If there is no current block, do nothing
   if (!current_block) return;
 
@@ -1558,12 +1566,13 @@ uint32_t Stepper::stepper_block_phase_isr() {
           return interval; // No more queued movements!
       }
 
-      // Initialize the trapezoid generator from the current block.
-      static int8_t last_extruder = -1;
+      // Compute movement direction for proper endstop handling
+      LOOP_NA(i) last_movement_non_null[i] = !!current_block->steps[i];
 
+      // Initialize the trapezoid generator from the current block.
       #if ENABLED(LIN_ADVANCE)
         #if E_STEPPERS > 1
-          if (current_block->active_extruder != last_extruder) {
+          if (current_block->active_extruder != last_movement_extruder) {
             current_adv_steps = 0; // If the now active extruder wasn't in use during the last move, its pressure is most likely gone.
             LA_active_extruder = current_block->active_extruder;
           }
@@ -1576,12 +1585,21 @@ uint32_t Stepper::stepper_block_phase_isr() {
         }
       #endif
 
-      if (current_block->direction_bits != last_direction_bits || current_block->active_extruder != last_extruder) {
+      if (current_block->direction_bits != last_direction_bits || current_block->active_extruder != last_movement_extruder) {
         last_direction_bits = current_block->direction_bits;
-        last_extruder = current_block->active_extruder;
+        last_movement_extruder = current_block->active_extruder;
         set_directions();
       }
 
+      // At this point, we must ensure the movement about to execute isn't
+      // trying to force the head against a limit switch. If using interrupt-
+      // driven change detection, and already against a limit then no call to
+      // the endstop_triggered method will be done and the movement will be
+      // done against the endstop. So, check the limits here: If the movement
+      // is against the limits, the block will be marked as to be killed, and
+      // on the next call to this ISR, will be discarded.
+      endstops.check_possible_change();
+
       // No acceleration / deceleration time elapsed so far
       acceleration_time = deceleration_time = 0;
 
@@ -1614,11 +1632,6 @@ uint32_t Stepper::stepper_block_phase_isr() {
           counter_m[i] = -(current_block->mix_event_count[i] >> 1);
       #endif
 
-      #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-        e_hit = 2; // Needed for the case an endstop is already triggered before the new move begins.
-                   // No 'change' can be detected.
-      #endif
-
       #if ENABLED(Z_LATE_ENABLE)
         // If delayed Z enable, enable it now. This option will severely interfere with
         //  timing between pulses when chaining motion between blocks, and it could lead
@@ -1894,9 +1907,6 @@ void Stepper::init() {
     if (!E_ENABLE_ON) E4_ENABLE_WRITE(HIGH);
   #endif
 
-  // Init endstops and pullups
-  endstops.init();
-
   #define _STEP_INIT(AXIS) AXIS ##_STEP_INIT
   #define _WRITE_STEP(AXIS, HIGHLOW) AXIS ##_STEP_WRITE(HIGHLOW)
   #define _DISABLE(AXIS) disable_## AXIS()
@@ -2034,29 +2044,14 @@ int32_t Stepper::position(const AxisEnum axis) {
   return v;
 }
 
-void Stepper::quick_stop() {
-  const bool was_enabled = STEPPER_ISR_ENABLED();
-  DISABLE_STEPPER_DRIVER_INTERRUPT();
-
-  if (current_block) {
-    step_events_completed = current_block->step_event_count;
-    current_block = NULL;
-  }
-
-  if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
-}
-
-void Stepper::kill_current_block() {
-  const bool was_enabled = STEPPER_ISR_ENABLED();
-  DISABLE_STEPPER_DRIVER_INTERRUPT();
-
-  if (current_block)
-    step_events_completed = current_block->step_event_count;
-
-  if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
-}
-
+// Signal endstops were triggered - This function can be called from
+// an ISR context  (Temperature, Stepper or limits ISR), so we must
+// be very careful here. If the interrupt being preempted was the
+// Stepper ISR (this CAN happen with the endstop limits ISR) then
+// when the stepper ISR resumes, we must be very sure that the movement
+// is properly cancelled
 void Stepper::endstop_triggered(const AxisEnum axis) {
+
   const bool was_enabled = STEPPER_ISR_ENABLED();
   if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
 
@@ -2074,14 +2069,7 @@ void Stepper::endstop_triggered(const AxisEnum axis) {
   #endif // !COREXY && !COREXZ && !COREYZ
 
   // Discard the rest of the move if there is a current block
-  if (current_block) {
-
-    // Kill the current block being executed
-    step_events_completed = current_block->step_event_count;
-
-    // Prep to get a new block after cleaning
-    current_block = NULL;
-  }
+  quick_stop();
 
   if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
 }

commit a11eb50a3eab6d58d595a67e526fb51190018db3
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 9 02:17:53 2018 -0300

    Refactor and optimize Stepper/Planner
    
    Better encapsulation and considerably reduce stepper jitter

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index baa50c2992..3a7336f734 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -86,10 +86,6 @@ Stepper stepper; // Singleton
 
 block_t* Stepper::current_block = NULL;  // A pointer to the block currently being traced
 
-#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
-  bool Stepper::abort_on_endstop_hit = false;
-#endif
-
 #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
   bool Stepper::performing_homing = false;
 #endif
@@ -101,7 +97,6 @@ block_t* Stepper::current_block = NULL;  // A pointer to the block currently bei
 // private:
 
 uint8_t Stepper::last_direction_bits = 0;        // The next stepping-bits to be output
-int16_t Stepper::cleaning_buffer_counter = 0;
 
 #if ENABLED(X_DUAL_ENDSTOPS)
   bool Stepper::locked_x_motor = false, Stepper::locked_x2_motor = false;
@@ -118,7 +113,7 @@ int32_t Stepper::counter_X = 0,
         Stepper::counter_Z = 0,
         Stepper::counter_E = 0;
 
-volatile uint32_t Stepper::step_events_completed = 0; // The number of step events executed in the current block
+uint32_t Stepper::step_events_completed = 0; // The number of step events executed in the current block
 
 #if ENABLED(BEZIER_JERK_CONTROL)
   int32_t __attribute__((used)) Stepper::bezier_A __asm__("bezier_A");    // A coefficient in Bézier speed curve with alias for assembler
@@ -132,15 +127,16 @@ volatile uint32_t Stepper::step_events_completed = 0; // The number of step even
   bool Stepper::bezier_2nd_half;    // =false If Bézier curve has been initialized or not
 #endif
 
+uint32_t Stepper::nextMainISR = 0;
+bool Stepper::all_steps_done = false;
+
 #if ENABLED(LIN_ADVANCE)
 
   uint32_t Stepper::LA_decelerate_after;
 
-  constexpr hal_timer_t ADV_NEVER = HAL_TIMER_TYPE_MAX;
-
-  hal_timer_t Stepper::nextMainISR = 0,
-              Stepper::nextAdvanceISR = ADV_NEVER,
-              Stepper::eISR_Rate = ADV_NEVER;
+  constexpr uint32_t ADV_NEVER = 0xFFFFFFFF;
+  uint32_t Stepper::nextAdvanceISR = ADV_NEVER,
+           Stepper::eISR_Rate = ADV_NEVER;
   uint16_t Stepper::current_adv_steps = 0,
            Stepper::final_adv_steps,
            Stepper::max_adv_steps;
@@ -157,7 +153,7 @@ volatile uint32_t Stepper::step_events_completed = 0; // The number of step even
 
 #endif // LIN_ADVANCE
 
-int32_t Stepper::acceleration_time, Stepper::deceleration_time;
+uint32_t Stepper::acceleration_time, Stepper::deceleration_time;
 
 volatile int32_t Stepper::count_position[NUM_AXIS] = { 0 };
 volatile signed char Stepper::count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
@@ -166,11 +162,11 @@ volatile signed char Stepper::count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
   int32_t Stepper::counter_m[MIXING_STEPPERS];
 #endif
 
+uint32_t Stepper::ticks_nominal;
 uint8_t Stepper::step_loops, Stepper::step_loops_nominal;
 
-hal_timer_t Stepper::OCR1A_nominal;
 #if DISABLED(BEZIER_JERK_CONTROL)
-  hal_timer_t Stepper::acc_step_rate; // needed for deceleration start point
+  uint32_t Stepper::acc_step_rate; // needed for deceleration start point
 #endif
 
 volatile int32_t Stepper::endstops_trigsteps[XYZ];
@@ -379,7 +375,7 @@ void Stepper::set_directions() {
    *
    *   Floating point arithmetic execution time cost is prohibitive, so we will transform the math to
    * use fixed point values to be able to evaluate it in realtime. Assuming a maximum of 250000 steps
-   * per second (driver pulses should at least be 2uS hi/2uS lo), and allocating 2 bits to avoid
+   * per second (driver pulses should at least be 2µS hi/2µS lo), and allocating 2 bits to avoid
    * overflows on the evaluation of the Bézier curve, means we can use
    *
    *   t: unsigned Q0.32 (0 <= t < 1) |range 0 to 0xFFFFFFFF unsigned
@@ -1149,11 +1145,27 @@ void Stepper::set_directions() {
 HAL_STEP_TIMER_ISR {
   HAL_timer_isr_prologue(STEP_TIMER_NUM);
 
-  #if ENABLED(LIN_ADVANCE)
-    Stepper::advance_isr_scheduler();
-  #else
-    Stepper::isr();
-  #endif
+  // Program timer compare for the maximum period, so it does NOT
+  // flag an interrupt while this ISR is running - So changes from small
+  // periods to big periods are respected and the timer does not reset to 0
+  HAL_timer_set_compare(STEP_TIMER_NUM, HAL_TIMER_TYPE_MAX);
+
+  // Call the ISR scheduler
+  hal_timer_t ticks = Stepper::isr_scheduler();
+
+  // Now 'ticks' contains the period to the next Stepper ISR.
+  // Potential problem: Since the timer continues to run, the requested
+  // compare value may already have passed.
+  //
+  // Assuming at least 6µs between calls to this ISR...
+  // On AVR the ISR epilogue is estimated at 40 instructions - close to 2.5µS.
+  // On ARM the ISR epilogue is estimated at 10 instructions - close to 200nS.
+  // In either case leave at least 4µS for other tasks to execute.
+  const hal_timer_t minticks = HAL_timer_get_count(STEP_TIMER_NUM) + hal_timer_t((HAL_TICKS_PER_US) * 4); // ISR never takes more than 1ms, so this shouldn't cause trouble
+  NOLESS(ticks, MAX(minticks, hal_timer_t((STEP_TIMER_MIN_INTERVAL) * (HAL_TICKS_PER_US))));
+
+  // Set the next ISR to fire at the proper time
+  HAL_timer_set_compare(STEP_TIMER_NUM, ticks);
 
   HAL_timer_isr_epilogue(STEP_TIMER_NUM);
 }
@@ -1164,168 +1176,64 @@ HAL_STEP_TIMER_ISR {
   #define STEP_MULTIPLY(A,B) MultiU24X32toH16(A, B)
 #endif
 
-void Stepper::isr() {
-
-  #define ENDSTOP_NOMINAL_OCR_VAL 1500 * HAL_TICKS_PER_US // Check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
-  #define OCR_VAL_TOLERANCE        500 * HAL_TICKS_PER_US // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
-
-  hal_timer_t ocr_val;
-  static uint32_t step_remaining = 0;  // SPLIT function always runs.  This allows 16 bit timers to be
-                                       // used to generate the stepper ISR.
-  #define SPLIT(L) do { \
-    if (L > ENDSTOP_NOMINAL_OCR_VAL) { \
-      const uint32_t remainder = (uint32_t)L % (ENDSTOP_NOMINAL_OCR_VAL); \
-      ocr_val = (remainder < OCR_VAL_TOLERANCE) ? ENDSTOP_NOMINAL_OCR_VAL + remainder : ENDSTOP_NOMINAL_OCR_VAL; \
-      step_remaining = (uint32_t)L - ocr_val; \
-    } \
-    else \
-      ocr_val = L;\
-  }while(0)
+hal_timer_t Stepper::isr_scheduler() {
+  uint32_t interval;
 
-  // Time remaining before the next step?
-  if (step_remaining) {
-
-    // Make sure endstops are updated
-    if (ENDSTOPS_ENABLED) endstops.update();
-
-    // Next ISR either for endstops or stepping
-    ocr_val = step_remaining <= ENDSTOP_NOMINAL_OCR_VAL ? step_remaining : ENDSTOP_NOMINAL_OCR_VAL;
-    step_remaining -= ocr_val;
-    _NEXT_ISR(ocr_val);
-
-    #if DISABLED(LIN_ADVANCE)
-      HAL_timer_restrain(STEP_TIMER_NUM, STEP_TIMER_MIN_INTERVAL * HAL_TICKS_PER_US);
-    #endif
-
-    return;
-  }
-
-  //
-  // When cleaning, discard the current block and run fast
-  //
-  if (cleaning_buffer_counter) {
-    if (cleaning_buffer_counter < 0) {          // Count up for endstop hit
-      if (current_block) planner.discard_current_block(); // Discard the active block that led to the trigger
-      if (!planner.discard_continued_block())   // Discard next CONTINUED block
-        cleaning_buffer_counter = 0;            // Keep discarding until non-CONTINUED
-    }
-    else {
-      planner.discard_current_block();
-      --cleaning_buffer_counter;                // Count down for abort print
-      #if ENABLED(SD_FINISHED_STEPPERRELEASE) && defined(SD_FINISHED_RELEASECOMMAND)
-        if (!cleaning_buffer_counter) enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
-      #endif
-    }
-    current_block = NULL;                       // Prep to get a new block after cleaning
-    _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 10000);  // Run at max speed - 10 KHz
-    return;
-  }
-
-  // If there is no current block, attempt to pop one from the buffer
-  if (!current_block) {
-
-    // Anything in the buffer?
-    if ((current_block = planner.get_current_block())) {
+  // Run main stepping pulse phase ISR if we have to
+  if (!nextMainISR) Stepper::stepper_pulse_phase_isr();
 
-      // Sync block? Sync the stepper counts and return
-      while (TEST(current_block->flag, BLOCK_BIT_SYNC_POSITION)) {
-        _set_position(
-          current_block->steps[A_AXIS], current_block->steps[B_AXIS],
-          current_block->steps[C_AXIS], current_block->steps[E_AXIS]
-        );
-        planner.discard_current_block();
-        if (!(current_block = planner.get_current_block())) return;
-      }
-
-      // Initialize the trapezoid generator from the current block.
-      static int8_t last_extruder = -1;
-
-      #if ENABLED(LIN_ADVANCE)
-        #if E_STEPPERS > 1
-          if (current_block->active_extruder != last_extruder) {
-            current_adv_steps = 0; // If the now active extruder wasn't in use during the last move, its pressure is most likely gone.
-            LA_active_extruder = current_block->active_extruder;
-          }
-        #endif
+  #if ENABLED(LIN_ADVANCE)
+    // Run linear advance stepper ISR if we have to
+    if (!nextAdvanceISR) nextAdvanceISR = Stepper::advance_isr();
+  #endif
 
-        if ((use_advance_lead = current_block->use_advance_lead)) {
-          LA_decelerate_after = current_block->decelerate_after;
-          final_adv_steps = current_block->final_adv_steps;
-          max_adv_steps = current_block->max_adv_steps;
-        }
-      #endif
+  // ^== Time critical. NOTHING besides pulse generation should be above here!!!
 
-      if (current_block->direction_bits != last_direction_bits || current_block->active_extruder != last_extruder) {
-        last_direction_bits = current_block->direction_bits;
-        last_extruder = current_block->active_extruder;
-        set_directions();
-      }
+  // Run main stepping block processing ISR if we have to
+  if (!nextMainISR) nextMainISR = Stepper::stepper_block_phase_isr();
 
-      // No acceleration / deceleration time elapsed so far
-      acceleration_time = deceleration_time = 0;
-
-      // No step events completed so far
-      step_events_completed = 0;
+  #if ENABLED(LIN_ADVANCE)
+    // Select the closest interval in time
+    interval = (nextAdvanceISR <= nextMainISR)
+      ? nextAdvanceISR
+      : nextMainISR;
 
-      // step_rate to timer interval
-      OCR1A_nominal = calc_timer_interval(current_block->nominal_rate);
+  #else // !ENABLED(LIN_ADVANCE)
 
-      // make a note of the number of step loops required at nominal speed
-      step_loops_nominal = step_loops;
-
-      #if DISABLED(BEZIER_JERK_CONTROL)
-        // Set as deceleration point the initial rate of the block
-        acc_step_rate = current_block->initial_rate;
-      #endif
+    // The interval is just the remaining time to the stepper ISR
+    interval = nextMainISR;
+  #endif
 
-      #if ENABLED(BEZIER_JERK_CONTROL)
-        // Initialize the Bézier speed curve
-        _calc_bezier_curve_coeffs(current_block->initial_rate, current_block->cruise_rate, current_block->acceleration_time_inverse);
+  // Limit the value to the maximum possible value of the timer
+  if (interval > HAL_TIMER_TYPE_MAX)
+    interval = HAL_TIMER_TYPE_MAX;
 
-        // We have not started the 2nd half of the trapezoid
-        bezier_2nd_half = false;
-      #endif
+  // Compute the time remaining for the main isr
+  nextMainISR -= interval;
 
-      // Initialize Bresenham counters to 1/2 the ceiling
-      counter_X = counter_Y = counter_Z = counter_E = -(current_block->step_event_count >> 1);
-      #if ENABLED(MIXING_EXTRUDER)
-        MIXING_STEPPERS_LOOP(i)
-          counter_m[i] = -(current_block->mix_event_count[i] >> 1);
-      #endif
+  #if ENABLED(LIN_ADVANCE)
+    // Compute the time remaining for the advance isr
+    if (nextAdvanceISR != ADV_NEVER)
+      nextAdvanceISR -= interval;
+  #endif
 
-      #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-        e_hit = 2; // Needed for the case an endstop is already triggered before the new move begins.
-                   // No 'change' can be detected.
-      #endif
+  return (hal_timer_t)interval;
+}
 
-      #if ENABLED(Z_LATE_ENABLE)
-        // If delayed Z enable, postpone move for 1mS
-        if (current_block->steps[Z_AXIS] > 0) {
-          enable_Z();
-          _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 1000); // Run at slow speed - 1 KHz
-          return;
-        }
-      #endif
-    }
-    else {
-      // If no more queued moves, postpone next check for 1mS
-      _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 1000); // Run at slow speed - 1 KHz
-      return;
-    }
-  }
+// This part of the ISR should ONLY create the pulses for the steppers
+// -- Nothing more, nothing less -- We want to avoid jitter from where
+// the pulses should be generated (when the interrupt triggers) to the
+// time pulses are actually created. So, PLEASE DO NOT PLACE ANY CODE
+// above this line that can conditionally change that time (we are trying
+// to keep the delay between the interrupt triggering and pulse generation
+// as constant as possible!!!!
+void Stepper::stepper_pulse_phase_isr() {
 
-  // Update endstops state, if enabled
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (e_hit && ENDSTOPS_ENABLED) {
-      endstops.update();
-      e_hit--;
-    }
-  #else
-    if (ENDSTOPS_ENABLED) endstops.update();
-  #endif
+  // If there is no current block, do nothing
+  if (!current_block) return;
 
   // Take multiple steps per interrupt (For high speed moves)
-  bool all_steps_done = false;
+  all_steps_done = false;
   for (uint8_t i = step_loops; i--;) {
 
     #define _COUNTER(AXIS) counter_## AXIS
@@ -1520,116 +1428,208 @@ void Stepper::isr() {
     #endif
 
   } // steps_loop
+}
 
-  // Calculate new timer value
-  if (step_events_completed <= (uint32_t)current_block->accelerate_until) {
+// This is the last half of the stepper interrupt: This one processes and
+// properly schedules blocks from the planner. This is executed after creating
+// the step pulses, so it is not time critical, as pulses are already done.
 
-    #if ENABLED(BEZIER_JERK_CONTROL)
-      // Get the next speed to use (Jerk limited!)
-      hal_timer_t acc_step_rate =
-        acceleration_time < current_block->acceleration_time
-          ? _eval_bezier_curve(acceleration_time)
-          : current_block->cruise_rate;
-    #else
-      acc_step_rate = STEP_MULTIPLY(acceleration_time, current_block->acceleration_rate) + current_block->initial_rate;
-      NOMORE(acc_step_rate, current_block->nominal_rate);
-    #endif
+uint32_t Stepper::stepper_block_phase_isr() {
 
-    // step_rate to timer interval
-    const hal_timer_t interval = calc_timer_interval(acc_step_rate);
+  // If no queued movements, just wait 1ms for the next move
+  uint32_t interval = (HAL_STEPPER_TIMER_RATE / 1000);
 
-    SPLIT(interval);  // split step into multiple ISRs if larger than ENDSTOP_NOMINAL_OCR_VAL
-    _NEXT_ISR(ocr_val);
+  // If there is a current block
+  if (current_block) {
 
-    acceleration_time += interval;
+    // Calculate new timer value
+    if (step_events_completed <= current_block->accelerate_until) {
 
-    #if ENABLED(LIN_ADVANCE)
-      if (current_block->use_advance_lead) {
-        if (step_events_completed == step_loops || (e_steps && eISR_Rate != current_block->advance_speed)) {
-          nextAdvanceISR = 0; // Wake up eISR on first acceleration loop and fire ISR if final adv_rate is reached
-          eISR_Rate = current_block->advance_speed;
+      #if ENABLED(BEZIER_JERK_CONTROL)
+        // Get the next speed to use (Jerk limited!)
+        uint32_t acc_step_rate =
+          acceleration_time < current_block->acceleration_time
+            ? _eval_bezier_curve(acceleration_time)
+            : current_block->cruise_rate;
+      #else
+        acc_step_rate = STEP_MULTIPLY(acceleration_time, current_block->acceleration_rate) + current_block->initial_rate;
+        NOMORE(acc_step_rate, current_block->nominal_rate);
+      #endif
+
+      // step_rate to timer interval
+      interval = calc_timer_interval(acc_step_rate);
+      acceleration_time += interval;
+
+      #if ENABLED(LIN_ADVANCE)
+        if (current_block->use_advance_lead) {
+          if (step_events_completed == step_loops || (e_steps && eISR_Rate != current_block->advance_speed)) {
+            nextAdvanceISR = 0; // Wake up eISR on first acceleration loop and fire ISR if final adv_rate is reached
+            eISR_Rate = current_block->advance_speed;
+          }
         }
-      }
-      else {
-        eISR_Rate = ADV_NEVER;
-        if (e_steps) nextAdvanceISR = 0;
-      }
-    #endif // LIN_ADVANCE
+        else {
+          eISR_Rate = ADV_NEVER;
+          if (e_steps) nextAdvanceISR = 0;
+        }
+      #endif // LIN_ADVANCE
+    }
+    else if (step_events_completed > current_block->decelerate_after) {
+      uint32_t step_rate;
+
+      #if ENABLED(BEZIER_JERK_CONTROL)
+        // If this is the 1st time we process the 2nd half of the trapezoid...
+        if (!bezier_2nd_half) {
+          // Initialize the Bézier speed curve
+          _calc_bezier_curve_coeffs(current_block->cruise_rate, current_block->final_rate, current_block->deceleration_time_inverse);
+          bezier_2nd_half = true;
+        }
+
+        // Calculate the next speed to use
+        step_rate = deceleration_time < current_block->deceleration_time
+          ? _eval_bezier_curve(deceleration_time)
+          : current_block->final_rate;
+      #else
+
+        // Using the old trapezoidal control
+        step_rate = STEP_MULTIPLY(deceleration_time, current_block->acceleration_rate);
+        if (step_rate < acc_step_rate) { // Still decelerating?
+          step_rate = acc_step_rate - step_rate;
+          NOLESS(step_rate, current_block->final_rate);
+        }
+        else
+          step_rate = current_block->final_rate;
+      #endif
+
+      // step_rate to timer interval
+      interval = calc_timer_interval(step_rate);
+      deceleration_time += interval;
+
+      #if ENABLED(LIN_ADVANCE)
+        if (current_block->use_advance_lead) {
+          if (step_events_completed <= current_block->decelerate_after + step_loops || (e_steps && eISR_Rate != current_block->advance_speed)) {
+            nextAdvanceISR = 0; // Wake up eISR on first deceleration loop
+            eISR_Rate = current_block->advance_speed;
+          }
+        }
+        else {
+          eISR_Rate = ADV_NEVER;
+          if (e_steps) nextAdvanceISR = 0;
+        }
+      #endif // LIN_ADVANCE
+    }
+    else {
+
+      #if ENABLED(LIN_ADVANCE)
+        // If there are any esteps, fire the next advance_isr "now"
+        if (e_steps && eISR_Rate != current_block->advance_speed) nextAdvanceISR = 0;
+      #endif
+
+      // The timer interval is just the nominal value for the nominal speed
+      interval = ticks_nominal;
+
+      // Ensure this runs at the correct step rate, even if it just came off an acceleration
+      step_loops = step_loops_nominal;
+    }
+
+    // If current block is finished, reset pointer
+    if (all_steps_done) {
+      current_block = NULL;
+      planner.discard_current_block();
+    }
   }
-  else if (step_events_completed > (uint32_t)current_block->decelerate_after) {
-    hal_timer_t step_rate;
 
-    #if ENABLED(BEZIER_JERK_CONTROL)
-      // If this is the 1st time we process the 2nd half of the trapezoid...
-      if (!bezier_2nd_half) {
+  // If there is no current block at this point, attempt to pop one from the buffer
+  // and prepare its movement
+  if (!current_block) {
+
+    // Anything in the buffer?
+    if ((current_block = planner.get_current_block())) {
 
-        // Initialize the Bézier speed curve
-        _calc_bezier_curve_coeffs(current_block->cruise_rate, current_block->final_rate, current_block->deceleration_time_inverse);
-        bezier_2nd_half = true;
+      // Sync block? Sync the stepper counts and return
+      while (TEST(current_block->flag, BLOCK_BIT_SYNC_POSITION)) {
+        _set_position(
+          current_block->position[A_AXIS], current_block->position[B_AXIS],
+          current_block->position[C_AXIS], current_block->position[E_AXIS]
+        );
+        planner.discard_current_block();
+
+        // Try to get a new block
+        if (!(current_block = planner.get_current_block()))
+          return interval; // No more queued movements!
       }
 
-      // Calculate the next speed to use
-      step_rate = deceleration_time < current_block->deceleration_time
-        ? _eval_bezier_curve(deceleration_time)
-        : current_block->final_rate;
-    #else
+      // Initialize the trapezoid generator from the current block.
+      static int8_t last_extruder = -1;
+
+      #if ENABLED(LIN_ADVANCE)
+        #if E_STEPPERS > 1
+          if (current_block->active_extruder != last_extruder) {
+            current_adv_steps = 0; // If the now active extruder wasn't in use during the last move, its pressure is most likely gone.
+            LA_active_extruder = current_block->active_extruder;
+          }
+        #endif
 
-      // Using the old trapezoidal control
-      step_rate = STEP_MULTIPLY(deceleration_time, current_block->acceleration_rate);
-      if (step_rate < acc_step_rate) { // Still decelerating?
-        step_rate = acc_step_rate - step_rate;
-        NOLESS(step_rate, current_block->final_rate);
+        if ((use_advance_lead = current_block->use_advance_lead)) {
+          LA_decelerate_after = current_block->decelerate_after;
+          final_adv_steps = current_block->final_adv_steps;
+          max_adv_steps = current_block->max_adv_steps;
+        }
+      #endif
+
+      if (current_block->direction_bits != last_direction_bits || current_block->active_extruder != last_extruder) {
+        last_direction_bits = current_block->direction_bits;
+        last_extruder = current_block->active_extruder;
+        set_directions();
       }
-      else
-        step_rate = current_block->final_rate;
 
-    #endif
+      // No acceleration / deceleration time elapsed so far
+      acceleration_time = deceleration_time = 0;
 
-    // step_rate to timer interval
-    const hal_timer_t interval = calc_timer_interval(step_rate);
+      // No step events completed so far
+      step_events_completed = 0;
 
-    SPLIT(interval);  // split step into multiple ISRs if larger than ENDSTOP_NOMINAL_OCR_VAL
-    _NEXT_ISR(ocr_val);
+      // step_rate to timer interval for the nominal speed
+      ticks_nominal = calc_timer_interval(current_block->nominal_rate);
 
-    deceleration_time += interval;
+      // make a note of the number of step loops required at nominal speed
+      step_loops_nominal = step_loops;
 
-    #if ENABLED(LIN_ADVANCE)
-      if (current_block->use_advance_lead) {
-        if (step_events_completed <= (uint32_t)current_block->decelerate_after + step_loops || (e_steps && eISR_Rate != current_block->advance_speed)) {
-          nextAdvanceISR = 0; // Wake up eISR on first deceleration loop
-          eISR_Rate = current_block->advance_speed;
-        }
-      }
-      else {
-        eISR_Rate = ADV_NEVER;
-        if (e_steps) nextAdvanceISR = 0;
-      }
-    #endif // LIN_ADVANCE
-  }
-  else {
+      #if DISABLED(BEZIER_JERK_CONTROL)
+        // Set as deceleration point the initial rate of the block
+        acc_step_rate = current_block->initial_rate;
+      #endif
 
-    #if ENABLED(LIN_ADVANCE)
-      // If we have esteps to execute, fire the next advance_isr "now"
-      if (e_steps && eISR_Rate != current_block->advance_speed) nextAdvanceISR = 0;
-    #endif
+      #if ENABLED(BEZIER_JERK_CONTROL)
+        // Initialize the Bézier speed curve
+        _calc_bezier_curve_coeffs(current_block->initial_rate, current_block->cruise_rate, current_block->acceleration_time_inverse);
 
-    SPLIT(OCR1A_nominal);  // split step into multiple ISRs if larger than ENDSTOP_NOMINAL_OCR_VAL
-    _NEXT_ISR(ocr_val);
+        // We have not started the 2nd half of the trapezoid
+        bezier_2nd_half = false;
+      #endif
 
-    // ensure we're running at the correct step rate, even if we just came off an acceleration
-    step_loops = step_loops_nominal;
-  }
+      // Initialize Bresenham counters to 1/2 the ceiling
+      counter_X = counter_Y = counter_Z = counter_E = -((int32_t)(current_block->step_event_count >> 1));
+      #if ENABLED(MIXING_EXTRUDER)
+        MIXING_STEPPERS_LOOP(i)
+          counter_m[i] = -(current_block->mix_event_count[i] >> 1);
+      #endif
 
-  #if DISABLED(LIN_ADVANCE)
-    // Make sure stepper ISR doesn't monopolize the CPU
-    HAL_timer_restrain(STEP_TIMER_NUM, STEP_TIMER_MIN_INTERVAL * HAL_TICKS_PER_US);
-  #endif
+      #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+        e_hit = 2; // Needed for the case an endstop is already triggered before the new move begins.
+                   // No 'change' can be detected.
+      #endif
 
-  // If current block is finished, reset pointer
-  if (all_steps_done) {
-    current_block = NULL;
-    planner.discard_current_block();
+      #if ENABLED(Z_LATE_ENABLE)
+        // If delayed Z enable, enable it now. This option will severely interfere with
+        //  timing between pulses when chaining motion between blocks, and it could lead
+        //  to lost steps in both X and Y axis, so avoid using it unless strictly necessary!!
+        if (current_block->steps[Z_AXIS]) enable_Z();
+      #endif
+    }
   }
+
+  // Return the interval to wait
+  return interval;
 }
 
 #if ENABLED(LIN_ADVANCE)
@@ -1638,8 +1638,8 @@ void Stepper::isr() {
   #define EXTRA_CYCLES_E (STEP_PULSE_CYCLES - (CYCLES_EATEN_E))
 
   // Timer interrupt for E. e_steps is set in the main routine;
-
-  void Stepper::advance_isr() {
+  uint32_t Stepper::advance_isr() {
+    uint32_t interval;
 
     #if ENABLED(MK2_MULTIPLEXER) // For SNMM even-numbered steppers are reversed
       #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) E0_DIR_WRITE(e_steps < 0 ? !INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0) : INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0)); }while(0)
@@ -1700,21 +1700,21 @@ void Stepper::isr() {
       if (step_events_completed > LA_decelerate_after && current_adv_steps > final_adv_steps) {
         e_steps--;
         current_adv_steps--;
-        nextAdvanceISR = eISR_Rate;
+        interval = eISR_Rate;
       }
       else if (step_events_completed < LA_decelerate_after && current_adv_steps < max_adv_steps) {
              //step_events_completed <= (uint32_t)current_block->accelerate_until) {
         e_steps++;
         current_adv_steps++;
-        nextAdvanceISR = eISR_Rate;
+        interval = eISR_Rate;
       }
       else {
-        nextAdvanceISR = ADV_NEVER;
+        interval = ADV_NEVER;
         eISR_Rate = ADV_NEVER;
       }
     }
     else
-      nextAdvanceISR = ADV_NEVER;
+      interval = ADV_NEVER;
 
     switch (LA_active_extruder) {
       case 0: SET_E_STEP_DIR(0); break;
@@ -1787,39 +1787,9 @@ void Stepper::isr() {
       #endif
 
     } // e_steps
-  }
 
-  void Stepper::advance_isr_scheduler() {
-
-    // Run main stepping ISR if flagged
-    if (!nextMainISR) isr();
-
-    // Run Advance stepping ISR if flagged
-    if (!nextAdvanceISR) advance_isr();
-
-    // Is the next advance ISR scheduled before the next main ISR?
-    if (nextAdvanceISR <= nextMainISR) {
-      // Set up the next interrupt
-      HAL_timer_set_compare(STEP_TIMER_NUM, nextAdvanceISR);
-      // New interval for the next main ISR
-      if (nextMainISR) nextMainISR -= nextAdvanceISR;
-      // Will call Stepper::advance_isr on the next interrupt
-      nextAdvanceISR = 0;
-    }
-    else {
-      // The next main ISR comes first
-      HAL_timer_set_compare(STEP_TIMER_NUM, nextMainISR);
-      // New interval for the next advance ISR, if any
-      if (nextAdvanceISR && nextAdvanceISR != ADV_NEVER)
-        nextAdvanceISR -= nextMainISR;
-      // Will call Stepper::isr on the next interrupt
-      nextMainISR = 0;
-    }
-
-    // Make sure stepper ISR doesn't monopolize the CPU
-    HAL_timer_restrain(STEP_TIMER_NUM, STEP_TIMER_MIN_INTERVAL * HAL_TICKS_PER_US);
+    return interval;
   }
-
 #endif // LIN_ADVANCE
 
 void Stepper::init() {
@@ -2048,30 +2018,47 @@ void Stepper::_set_position(const int32_t &a, const int32_t &b, const int32_t &c
  * Get a stepper's position in steps.
  */
 int32_t Stepper::position(const AxisEnum axis) {
-  CRITICAL_SECTION_START;
-  const int32_t count_pos = count_position[axis];
-  CRITICAL_SECTION_END;
-  return count_pos;
-}
+  #ifdef __AVR__
+    // Protect the access to the position. Only required for AVR, as
+    //  any 32bit CPU offers atomic access to 32bit variables
+    const bool was_enabled = STEPPER_ISR_ENABLED();
+    if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+  #endif
 
-void Stepper::finish_and_disable() {
-  planner.synchronize();
-  disable_all_steppers();
+  int32_t v = count_position[axis];
+
+  #ifdef __AVR__
+    // Reenable Stepper ISR
+    if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+  #endif
+  return v;
 }
 
 void Stepper::quick_stop() {
+  const bool was_enabled = STEPPER_ISR_ENABLED();
   DISABLE_STEPPER_DRIVER_INTERRUPT();
-  kill_current_block();
-  current_block = NULL;
-  cleaning_buffer_counter = 5000;
-  planner.clear_block_buffer();
-  ENABLE_STEPPER_DRIVER_INTERRUPT();
-  #if ENABLED(ULTRA_LCD)
-    planner.clear_block_buffer_runtime();
-  #endif
+
+  if (current_block) {
+    step_events_completed = current_block->step_event_count;
+    current_block = NULL;
+  }
+
+  if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+}
+
+void Stepper::kill_current_block() {
+  const bool was_enabled = STEPPER_ISR_ENABLED();
+  DISABLE_STEPPER_DRIVER_INTERRUPT();
+
+  if (current_block)
+    step_events_completed = current_block->step_event_count;
+
+  if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
 }
 
 void Stepper::endstop_triggered(const AxisEnum axis) {
+  const bool was_enabled = STEPPER_ISR_ENABLED();
+  if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
 
   #if IS_CORE
 
@@ -2086,16 +2073,48 @@ void Stepper::endstop_triggered(const AxisEnum axis) {
 
   #endif // !COREXY && !COREXZ && !COREYZ
 
-  kill_current_block();
-  cleaning_buffer_counter = -1; // Discard the rest of the move
+  // Discard the rest of the move if there is a current block
+  if (current_block) {
+
+    // Kill the current block being executed
+    step_events_completed = current_block->step_event_count;
+
+    // Prep to get a new block after cleaning
+    current_block = NULL;
+  }
+
+  if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+}
+
+int32_t Stepper::triggered_position(const AxisEnum axis) {
+  #ifdef __AVR__
+    // Protect the access to the position. Only required for AVR, as
+    //  any 32bit CPU offers atomic access to 32bit variables
+    const bool was_enabled = STEPPER_ISR_ENABLED();
+    if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+  #endif
+
+  const int32_t v = endstops_trigsteps[axis];
+
+  #ifdef __AVR__
+    // Reenable Stepper ISR
+    if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+  #endif
+
+  return v;
 }
 
 void Stepper::report_positions() {
-  CRITICAL_SECTION_START;
+
+  // Protect the access to the position.
+  const bool was_enabled = STEPPER_ISR_ENABLED();
+  if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+
   const int32_t xpos = count_position[X_AXIS],
                 ypos = count_position[Y_AXIS],
                 zpos = count_position[Z_AXIS];
-  CRITICAL_SECTION_END;
+
+  if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
 
   #if CORE_IS_XY || CORE_IS_XZ || IS_DELTA || IS_SCARA
     SERIAL_PROTOCOLPGM(MSG_COUNT_A);

commit 7dc03ce721bdf7577b78d29205d030c45d50b7f5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 19 17:26:11 2018 -0500

    Simplified fix for babystep pulse width
    
    Alternative to the apparently superfluous double delay

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index ed41390866..baa50c2992 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2136,8 +2136,7 @@ void Stepper::report_positions() {
   #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)
 
   #if EXTRA_CYCLES_BABYSTEP > 20
-    hal_timer_t pulse_start;
-    #define _SAVE_START pulse_start = HAL_timer_get_count(STEP_TIMER_NUM)
+    #define _SAVE_START const hal_timer_t pulse_start = HAL_timer_get_count(STEP_TIMER_NUM)
     #define _PULSE_WAIT while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(HAL_timer_get_count(STEP_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
   #else
     #define _SAVE_START NOOP
@@ -2155,11 +2154,10 @@ void Stepper::report_positions() {
   #define BABYSTEP_AXIS(AXIS, INVERT, DIR) {            \
       const uint8_t old_dir = _READ_DIR(AXIS);          \
       _ENABLE(AXIS);                                    \
-      _SAVE_START;                                      \
       _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^DIR^INVERT);   \
-      _PULSE_WAIT;                                      \
-      _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), true); \
+      DELAY_NS(400); /* DRV8825 */                      \
       _SAVE_START;                                      \
+      _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), true); \
       _PULSE_WAIT;                                      \
       _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), true);  \
       _APPLY_DIR(AXIS, old_dir);                        \
@@ -2229,6 +2227,8 @@ void Stepper::report_positions() {
           Y_DIR_WRITE(INVERT_Y_DIR ^ z_direction);
           Z_DIR_WRITE(INVERT_Z_DIR ^ z_direction);
 
+          DELAY_NS(400); // DRV8825
+
           _SAVE_START;
 
           X_STEP_WRITE(!INVERT_X_STEP_PIN);

commit 65270d6a96900a56aa02609bb0fd0b8605f576fa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 19 18:19:03 2018 -0500

    Fix LIN_ADVANCE + SWITCHING_EXTRUDER
    
    Followup to #10656

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 60bba7a6eb..ed41390866 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1646,29 +1646,51 @@ void Stepper::isr() {
     #elif ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
       #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) { if (e_steps < 0) REV_E_DIR(); else NORM_E_DIR(); } }while(0)
     #elif ENABLED(SWITCHING_EXTRUDER)
-      #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) { switch (INDEX) { \
-          case 0: case 1: E0_DIR_WRITE(!INVERT_E0_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); break; \
-          case 2: case 3: E1_DIR_WRITE(!INVERT_E1_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); break; \
-                  case 4: E2_DIR_WRITE(!INVERT_E2_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); \
-      } } }while(0)
+      #if EXTRUDERS > 4
+        #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) { switch (INDEX) { \
+            case 0: case 1: E0_DIR_WRITE(!INVERT_E0_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); break; \
+            case 2: case 3: E1_DIR_WRITE(!INVERT_E1_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); break; \
+                    case 4: E2_DIR_WRITE(!INVERT_E2_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); \
+        } } }while(0)
+      #elif EXTRUDERS > 2
+        #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) { switch (INDEX) { \
+            case 0: case 1: E0_DIR_WRITE(!INVERT_E0_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); break; \
+            case 2: case 3: E1_DIR_WRITE(!INVERT_E1_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); break; \
+        } } }while(0)
+      #else
+        #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) E0_DIR_WRITE(!INVERT_E0_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); }while(0)
+      #endif
     #else
-      #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) E## INDEX ##_DIR_WRITE(e_steps < 0 ? INVERT_E## INDEX ##_DIR : !INVERT_E## INDEX ##_DIR); }while(0)
+      #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) E## INDEX ##_DIR_WRITE(!INVERT_E## INDEX ##_DIR ^ (e_steps < 0)); }while(0)
     #endif
 
     #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
       #define START_E_PULSE(INDEX) do{ if (e_steps) E_STEP_WRITE(!INVERT_E_STEP_PIN); }while(0)
-      #define STOP_E_PULSE(INDEX) do{ if (e_steps) { E_STEP_WRITE(INVERT_E_STEP_PIN); e_steps < 0 ? ++e_steps : --e_steps; } }while(0)
+      #define STOP_E_PULSE(INDEX) do{ if (e_steps) { e_steps < 0 ? ++e_steps : --e_steps; E_STEP_WRITE(INVERT_E_STEP_PIN); } }while(0)
     #elif ENABLED(SWITCHING_EXTRUDER)
-      #define START_E_PULSE(INDEX) do{ if (e_steps) { switch (INDEX) { \
-          case 0: case 1: E0_DIR_WRITE(!INVERT_E_STEP_PIN); break; \
-          case 2: case 3: E1_DIR_WRITE(!INVERT_E_STEP_PIN); break; \
-                  case 4: E2_DIR_WRITE(!INVERT_E_STEP_PIN); \
-      } } }while(0)
-      #define STOP_E_PULSE(INDEX) do{ if (e_steps) { switch (INDEX) { \
-          case 0: case 1: E0_DIR_WRITE(!INVERT_E_STEP_PIN); break; \
-          case 2: case 3: E1_DIR_WRITE(!INVERT_E_STEP_PIN); break; \
-                  case 4: E2_DIR_WRITE(!INVERT_E_STEP_PIN); \
-      } } }while(0)
+      #if EXTRUDERS > 4
+        #define START_E_PULSE(INDEX) do{ if (e_steps) { switch (INDEX) { \
+            case 0: case 1: E0_DIR_WRITE(!INVERT_E_STEP_PIN); break; \
+            case 2: case 3: E1_DIR_WRITE(!INVERT_E_STEP_PIN); break; \
+                    case 4: E2_DIR_WRITE(!INVERT_E_STEP_PIN); } \
+        } }while(0)
+        #define STOP_E_PULSE(INDEX) do{ if (e_steps) { \
+          e_steps < 0 ? ++e_steps : --e_steps; \
+          switch (INDEX) { \
+            case 0: case 1: E0_DIR_WRITE(INVERT_E_STEP_PIN); break; \
+            case 2: case 3: E1_DIR_WRITE(INVERT_E_STEP_PIN); break; \
+                    case 4: E2_DIR_WRITE(INVERT_E_STEP_PIN); } \
+        } }while(0)
+      #elif EXTRUDERS > 2
+        #define START_E_PULSE(INDEX) do{ if (e_steps) { if (INDEX < 2) E0_DIR_WRITE(!INVERT_E_STEP_PIN); else E1_DIR_WRITE(!INVERT_E_STEP_PIN); } }while(0)
+        #define STOP_E_PULSE(INDEX) do{ if (e_steps) { \
+          e_steps < 0 ? ++e_steps : --e_steps; \
+          if (INDEX < 2) E0_DIR_WRITE(INVERT_E_STEP_PIN); else E1_DIR_WRITE(INVERT_E_STEP_PIN); \
+        } }while(0)
+      #else
+        #define START_E_PULSE(INDEX) do{ if (e_steps) E0_DIR_WRITE(!INVERT_E_STEP_PIN); }while(0)
+        #define STOP_E_PULSE(INDEX) do{ if (e_steps) { e_steps < 0 ? ++e_steps : --e_steps; E0_DIR_WRITE(INVERT_E_STEP_PIN); }while(0)
+      #endif
     #else
       #define START_E_PULSE(INDEX) do{ if (e_steps) E## INDEX ##_STEP_WRITE(!INVERT_E_STEP_PIN); }while(0)
       #define STOP_E_PULSE(INDEX) do { if (e_steps) { e_steps < 0 ? ++e_steps : --e_steps; E## INDEX ##_STEP_WRITE(INVERT_E_STEP_PIN); } }while(0)

commit 9ad42d661750f95d594b305ceaf106d37e5bc766
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Sat May 19 17:12:16 2018 -0500

    add delay between pulse edges (#10778)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 7a4a10843f..60bba7a6eb 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2114,7 +2114,8 @@ void Stepper::report_positions() {
   #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)
 
   #if EXTRA_CYCLES_BABYSTEP > 20
-    #define _SAVE_START const hal_timer_t pulse_start = HAL_timer_get_count(STEP_TIMER_NUM)
+    hal_timer_t pulse_start;
+    #define _SAVE_START pulse_start = HAL_timer_get_count(STEP_TIMER_NUM)
     #define _PULSE_WAIT while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(HAL_timer_get_count(STEP_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
   #else
     #define _SAVE_START NOOP
@@ -2136,6 +2137,7 @@ void Stepper::report_positions() {
       _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^DIR^INVERT);   \
       _PULSE_WAIT;                                      \
       _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), true); \
+      _SAVE_START;                                      \
       _PULSE_WAIT;                                      \
       _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), true);  \
       _APPLY_DIR(AXIS, old_dir);                        \

commit ba4c32eec52353159d5a5dd9c5a7402b8113a036
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 10:40:45 2018 -0500

    Followup to _AXIS patch

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 3bff52fe0a..7a4a10843f 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -287,14 +287,14 @@ void Stepper::wake_up() {
  */
 void Stepper::set_directions() {
 
-  #define SET_STEP_DIR(AXIS) \
-    if (motor_direction(AXIS ##_AXIS)) { \
-      AXIS ##_APPLY_DIR(INVERT_## AXIS ##_DIR, false); \
-      count_direction[AXIS ##_AXIS] = -1; \
+  #define SET_STEP_DIR(A) \
+    if (motor_direction(_AXIS(A))) { \
+      A##_APPLY_DIR(INVERT_## A##_DIR, false); \
+      count_direction[_AXIS(A)] = -1; \
     } \
     else { \
-      AXIS ##_APPLY_DIR(!INVERT_## AXIS ##_DIR, false); \
-      count_direction[AXIS ##_AXIS] = 1; \
+      A##_APPLY_DIR(!INVERT_## A##_DIR, false); \
+      count_direction[_AXIS(A)] = 1; \
     }
 
   #if HAS_X_DIR

commit d9154ebdf6b23b52b39198f64be7c0e95b12c334
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 09:29:08 2018 -0500

    Followup to math patch

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 2e644d3803..3bff52fe0a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1159,9 +1159,9 @@ HAL_STEP_TIMER_ISR {
 }
 
 #ifdef CPU_32_BIT
-  #define STEP_MULTIPLY(A,B) MultiU32X24toH32(A, B);
+  #define STEP_MULTIPLY(A,B) MultiU32X24toH32(A, B)
 #else
-  #define STEP_MULTIPLY(A,B) MultiU24X32toH16(A, B);
+  #define STEP_MULTIPLY(A,B) MultiU24X32toH16(A, B)
 #endif
 
 void Stepper::isr() {

commit 883b0c98808e09b2375eeb1f107ec931bb72c9ff
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 13 08:10:08 2018 -0500

    Convert custom maths to inlines (#10728)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c4b6ed8329..2e644d3803 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1158,6 +1158,12 @@ HAL_STEP_TIMER_ISR {
   HAL_timer_isr_epilogue(STEP_TIMER_NUM);
 }
 
+#ifdef CPU_32_BIT
+  #define STEP_MULTIPLY(A,B) MultiU32X24toH32(A, B);
+#else
+  #define STEP_MULTIPLY(A,B) MultiU24X32toH16(A, B);
+#endif
+
 void Stepper::isr() {
 
   #define ENDSTOP_NOMINAL_OCR_VAL 1500 * HAL_TICKS_PER_US // Check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
@@ -1525,14 +1531,7 @@ void Stepper::isr() {
           ? _eval_bezier_curve(acceleration_time)
           : current_block->cruise_rate;
     #else
-      #ifdef CPU_32_BIT
-        MultiU32X24toH32(acc_step_rate, acceleration_time, current_block->acceleration_rate);
-      #else
-        MultiU24X32toH16(acc_step_rate, acceleration_time, current_block->acceleration_rate);
-      #endif
-      acc_step_rate += current_block->initial_rate;
-
-      // upper limit
+      acc_step_rate = STEP_MULTIPLY(acceleration_time, current_block->acceleration_rate) + current_block->initial_rate;
       NOMORE(acc_step_rate, current_block->nominal_rate);
     #endif
 
@@ -1576,18 +1575,14 @@ void Stepper::isr() {
     #else
 
       // Using the old trapezoidal control
-      #ifdef CPU_32_BIT
-        MultiU32X24toH32(step_rate, deceleration_time, current_block->acceleration_rate);
-      #else
-        MultiU24X32toH16(step_rate, deceleration_time, current_block->acceleration_rate);
-      #endif
-
+      step_rate = STEP_MULTIPLY(deceleration_time, current_block->acceleration_rate);
       if (step_rate < acc_step_rate) { // Still decelerating?
         step_rate = acc_step_rate - step_rate;
         NOLESS(step_rate, current_block->final_rate);
       }
       else
         step_rate = current_block->final_rate;
+
     #endif
 
     // step_rate to timer interval

commit 08e36e264e72f56bada1f25c1a784d6e3f9d2135
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 03:44:24 2018 -0500

    Apply _AXIS macro

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 7af6b2c94d..c4b6ed8329 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -182,20 +182,20 @@ volatile int32_t Stepper::endstops_trigsteps[XYZ];
   #define LOCKED_X2_MOTOR locked_x2_motor
   #define LOCKED_Y2_MOTOR locked_y2_motor
   #define LOCKED_Z2_MOTOR locked_z2_motor
-  #define DUAL_ENDSTOP_APPLY_STEP(AXIS,v)                                                                                                           \
+  #define DUAL_ENDSTOP_APPLY_STEP(A,V)                                                                                                           \
     if (performing_homing) {                                                                                                                        \
-      if (AXIS##_HOME_DIR < 0) {                                                                                                                    \
-        if (!(TEST(endstops.old_endstop_bits, AXIS##_MIN) && count_direction[AXIS##_AXIS] < 0) && !LOCKED_##AXIS##_MOTOR) AXIS##_STEP_WRITE(v);     \
-        if (!(TEST(endstops.old_endstop_bits, AXIS##2_MIN) && count_direction[AXIS##_AXIS] < 0) && !LOCKED_##AXIS##2_MOTOR) AXIS##2_STEP_WRITE(v);  \
+      if (A##_HOME_DIR < 0) {                                                                                                                    \
+        if (!(TEST(endstops.old_endstop_bits, A##_MIN) && count_direction[_AXIS(A)] < 0) && !LOCKED_##A##_MOTOR) A##_STEP_WRITE(V);     \
+        if (!(TEST(endstops.old_endstop_bits, A##2_MIN) && count_direction[_AXIS(A)] < 0) && !LOCKED_##A##2_MOTOR) A##2_STEP_WRITE(V);  \
       }                                                                                                                                             \
       else {                                                                                                                                        \
-        if (!(TEST(endstops.old_endstop_bits, AXIS##_MAX) && count_direction[AXIS##_AXIS] > 0) && !LOCKED_##AXIS##_MOTOR) AXIS##_STEP_WRITE(v);     \
-        if (!(TEST(endstops.old_endstop_bits, AXIS##2_MAX) && count_direction[AXIS##_AXIS] > 0) && !LOCKED_##AXIS##2_MOTOR) AXIS##2_STEP_WRITE(v);  \
+        if (!(TEST(endstops.old_endstop_bits, A##_MAX) && count_direction[_AXIS(A)] > 0) && !LOCKED_##A##_MOTOR) A##_STEP_WRITE(V);     \
+        if (!(TEST(endstops.old_endstop_bits, A##2_MAX) && count_direction[_AXIS(A)] > 0) && !LOCKED_##A##2_MOTOR) A##2_STEP_WRITE(V);  \
       }                                                                                                                                             \
     }                                                                                                                                               \
     else {                                                                                                                                          \
-      AXIS##_STEP_WRITE(v);                                                                                                                         \
-      AXIS##2_STEP_WRITE(v);                                                                                                                        \
+      A##_STEP_WRITE(V);                                                                                                                         \
+      A##2_STEP_WRITE(V);                                                                                                                        \
     }
 #endif
 

commit 8f8c6a9bc4f1c8b2d927e74339a48217d9b48ec7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 09:59:11 2018 -0500

    Move get_axis_position_mm to Planner (#10718)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index d62081d854..7af6b2c94d 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2037,32 +2037,6 @@ int32_t Stepper::position(const AxisEnum axis) {
   return count_pos;
 }
 
-/**
- * Get an axis position according to stepper position(s)
- * For CORE machines apply translation from ABC to XYZ.
- */
-float Stepper::get_axis_position_mm(const AxisEnum axis) {
-  float axis_steps;
-  #if IS_CORE
-    // Requesting one of the "core" axes?
-    if (axis == CORE_AXIS_1 || axis == CORE_AXIS_2) {
-      CRITICAL_SECTION_START;
-      // ((a1+a2)+(a1-a2))/2 -> (a1+a2+a1-a2)/2 -> (a1+a1)/2 -> a1
-      // ((a1+a2)-(a1-a2))/2 -> (a1+a2-a1+a2)/2 -> (a2+a2)/2 -> a2
-      axis_steps = 0.5f * (
-        axis == CORE_AXIS_2 ? CORESIGN(count_position[CORE_AXIS_1] - count_position[CORE_AXIS_2])
-                            : count_position[CORE_AXIS_1] + count_position[CORE_AXIS_2]
-      );
-      CRITICAL_SECTION_END;
-    }
-    else
-      axis_steps = position(axis);
-  #else
-    axis_steps = position(axis);
-  #endif
-  return axis_steps * planner.steps_to_mm[axis];
-}
-
 void Stepper::finish_and_disable() {
   planner.synchronize();
   disable_all_steppers();

commit a1062eec5b6afe38d6769beea89bb14017c3f260
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 08:34:04 2018 -0500

    Better handling of DELAY_NS and DELAY_US (#10716)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 1c1234c642..d62081d854 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -41,15 +41,18 @@
  * along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-/* The timer calculations of this module informed by the 'RepRap cartesian firmware' by Zack Smith
-   and Philipp Tiefenbacher. */
+/**
+ * Timer calculations informed by the 'RepRap cartesian firmware' by Zack Smith
+ * and Philipp Tiefenbacher.
+ */
 
-/* Jerk controlled movements planner added by Eduardo José Tagle in April
-   2018, Equations based on Synthethos TinyG2 sources, but the fixed-point
-   implementation is a complete new one, as we are running the ISR with a
-   variable period.
-   Also implemented the Bézier velocity curve evaluation in ARM assembler,
-   to avoid impacting ISR speed. */
+/**
+ * Jerk controlled movements planner added Apr 2018 by Eduardo José Tagle.
+ * Equations based on Synthethos TinyG2 sources, but the fixed-point
+ * implementation is new, as we are running the ISR with a variable period.
+ * Also implemented the Bézier velocity curve evaluation in ARM assembler,
+ * to avoid impacting ISR speed.
+ */
 
 #include "stepper.h"
 
@@ -67,6 +70,7 @@
 #include "../gcode/queue.h"
 #include "../sd/cardreader.h"
 #include "../Marlin.h"
+#include "../HAL/Delay.h"
 
 #if MB(ALLIGATOR)
   #include "../feature/dac/dac_dac084s085.h"
@@ -1471,7 +1475,7 @@ void Stepper::isr() {
       while (EXTRA_CYCLES_XYZE > (uint32_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
       pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM);
     #elif EXTRA_CYCLES_XYZE > 0
-      DELAY_NOPS(EXTRA_CYCLES_XYZE);
+      DELAY_NS(EXTRA_CYCLES_XYZE * NANOSECONDS_PER_CYCLE);
     #endif
 
     #if HAS_X_STEP
@@ -1506,7 +1510,7 @@ void Stepper::isr() {
     #if EXTRA_CYCLES_XYZE > 20
       if (i) while (EXTRA_CYCLES_XYZE > (uint32_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
     #elif EXTRA_CYCLES_XYZE > 0
-      if (i) DELAY_NOPS(EXTRA_CYCLES_XYZE);
+      if (i) DELAY_NS(EXTRA_CYCLES_XYZE * NANOSECONDS_PER_CYCLE);
     #endif
 
   } // steps_loop
@@ -1739,7 +1743,7 @@ void Stepper::isr() {
         while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
         pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM);
       #elif EXTRA_CYCLES_E > 0
-        DELAY_NOPS(EXTRA_CYCLES_E);
+        DELAY_NS(EXTRA_CYCLES_E * NANOSECONDS_PER_CYCLE);
       #endif
 
       switch (LA_active_extruder) {
@@ -1762,7 +1766,7 @@ void Stepper::isr() {
       #if EXTRA_CYCLES_E > 20
         if (e_steps) while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
       #elif EXTRA_CYCLES_E > 0
-        if (e_steps) DELAY_NOPS(EXTRA_CYCLES_E);
+        if (e_steps) DELAY_NS(EXTRA_CYCLES_E * NANOSECONDS_PER_CYCLE);
       #endif
 
     } // e_steps
@@ -2146,13 +2150,13 @@ void Stepper::report_positions() {
   #else
     #define _SAVE_START NOOP
     #if EXTRA_CYCLES_BABYSTEP > 0
-      #define _PULSE_WAIT DELAY_NOPS(EXTRA_CYCLES_BABYSTEP)
+      #define _PULSE_WAIT DELAY_NS(EXTRA_CYCLES_BABYSTEP * NANOSECONDS_PER_CYCLE)
     #elif STEP_PULSE_CYCLES > 0
       #define _PULSE_WAIT NOOP
     #elif ENABLED(DELTA)
-      #define _PULSE_WAIT delayMicroseconds(2);
+      #define _PULSE_WAIT DELAY_US(2);
     #else
-      #define _PULSE_WAIT delayMicroseconds(4);
+      #define _PULSE_WAIT DELAY_US(4);
     #endif
   #endif
 

commit 3614e6ce0f5ca5ddf5c4dd76b2b6fa12220cede1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 12 02:26:14 2018 -0500

    Fix Switching Extruder with Linear Advance

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 64f2517942..1c1234c642 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1659,6 +1659,17 @@ void Stepper::isr() {
     #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
       #define START_E_PULSE(INDEX) do{ if (e_steps) E_STEP_WRITE(!INVERT_E_STEP_PIN); }while(0)
       #define STOP_E_PULSE(INDEX) do{ if (e_steps) { E_STEP_WRITE(INVERT_E_STEP_PIN); e_steps < 0 ? ++e_steps : --e_steps; } }while(0)
+    #elif ENABLED(SWITCHING_EXTRUDER)
+      #define START_E_PULSE(INDEX) do{ if (e_steps) { switch (INDEX) { \
+          case 0: case 1: E0_DIR_WRITE(!INVERT_E_STEP_PIN); break; \
+          case 2: case 3: E1_DIR_WRITE(!INVERT_E_STEP_PIN); break; \
+                  case 4: E2_DIR_WRITE(!INVERT_E_STEP_PIN); \
+      } } }while(0)
+      #define STOP_E_PULSE(INDEX) do{ if (e_steps) { switch (INDEX) { \
+          case 0: case 1: E0_DIR_WRITE(!INVERT_E_STEP_PIN); break; \
+          case 2: case 3: E1_DIR_WRITE(!INVERT_E_STEP_PIN); break; \
+                  case 4: E2_DIR_WRITE(!INVERT_E_STEP_PIN); \
+      } } }while(0)
     #else
       #define START_E_PULSE(INDEX) do{ if (e_steps) E## INDEX ##_STEP_WRITE(!INVERT_E_STEP_PIN); }while(0)
       #define STOP_E_PULSE(INDEX) do { if (e_steps) { e_steps < 0 ? ++e_steps : --e_steps; E## INDEX ##_STEP_WRITE(INVERT_E_STEP_PIN); } }while(0)

commit 306f0f2135e4b2aed749a0d1b870abf17d883e38
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 01:38:02 2018 -0500

    Move Stepper::synchronize to Planner (#10713)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index f26001074e..64f2517942 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1977,12 +1977,6 @@ void Stepper::init() {
   set_directions(); // Init directions to last_direction_bits = 0
 }
 
-
-/**
- * Block until all buffered steps are executed / cleaned
- */
-void Stepper::synchronize() { while (planner.has_blocks_queued() || cleaning_buffer_counter) idle(); }
-
 /**
  * Set the stepper positions directly in steps
  *
@@ -2055,7 +2049,7 @@ float Stepper::get_axis_position_mm(const AxisEnum axis) {
 }
 
 void Stepper::finish_and_disable() {
-  synchronize();
+  planner.synchronize();
   disable_all_steppers();
 }
 

commit 722aba77f35fc1d274ca88043e2de2c117b91422
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 9 14:36:09 2018 -0500

    Fix LIN_ADVANCE + SWITCHING_EXTRUDER stepper directions (#10656)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 5214bade44..f26001074e 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1646,6 +1646,12 @@ void Stepper::isr() {
       #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) E0_DIR_WRITE(e_steps < 0 ? !INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0) : INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0)); }while(0)
     #elif ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
       #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) { if (e_steps < 0) REV_E_DIR(); else NORM_E_DIR(); } }while(0)
+    #elif ENABLED(SWITCHING_EXTRUDER)
+      #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) { switch (INDEX) { \
+          case 0: case 1: E0_DIR_WRITE(!INVERT_E0_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); break; \
+          case 2: case 3: E1_DIR_WRITE(!INVERT_E1_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); break; \
+                  case 4: E2_DIR_WRITE(!INVERT_E2_DIR ^ TEST(INDEX, 0) ^ (e_steps < 0)); \
+      } } }while(0)
     #else
       #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) E## INDEX ##_DIR_WRITE(e_steps < 0 ? INVERT_E## INDEX ##_DIR : !INVERT_E## INDEX ##_DIR); }while(0)
     #endif

commit 0436e16fb22ce411311bce5994a315a991ec3219
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 8 05:10:27 2018 -0500

    Apply shorthand Assembler macros

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4e6747a124..5214bade44 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -581,68 +581,68 @@ void Stepper::set_directions() {
         /*  %10 (must be high register!)*/
 
         /* Store initial velocity*/
-        " sts bezier_F, %0" "\n\t"
-        " sts bezier_F+1, %1" "\n\t"
-        " sts bezier_F+2, %10" "\n\t"    /* bezier_F = %10:%1:%0 = v0 */
+        A("sts bezier_F, %0")
+        A("sts bezier_F+1, %1")
+        A("sts bezier_F+2, %10")    /* bezier_F = %10:%1:%0 = v0 */
 
         /* Get delta speed */
-        " ldi %2,-1" "\n\t"              /* %2 = 0xff, means A_negative = true */
-        " clr %8" "\n\t"                 /* %8 = 0 */
-        " sub %0,%3" "\n\t"
-        " sbc %1,%4" "\n\t"
-        " sbc %10,%5" "\n\t"             /*  v0 -= v1, C=1 if result is negative */
-        " brcc 1f" "\n\t"                /* branch if result is positive (C=0), that means v0 >= v1 */
+        A("ldi %2,-1")              /* %2 = 0xFF, means A_negative = true */
+        A("clr %8")                 /* %8 = 0 */
+        A("sub %0,%3")
+        A("sbc %1,%4")
+        A("sbc %10,%5")             /*  v0 -= v1, C=1 if result is negative */
+        A("brcc 1f")                /* branch if result is positive (C=0), that means v0 >= v1 */
 
         /*  Result was negative, get the absolute value*/
-        " com %10" "\n\t"
-        " com %1" "\n\t"
-        " neg %0" "\n\t"
-        " sbc %1,%2" "\n\t"
-        " sbc %10,%2" "\n\t"             /* %10:%1:%0 +1  -> %10:%1:%0 = -(v0 - v1) = (v1 - v0) */
-        " clr %2" "\n\t"                 /* %2 = 0, means A_negative = false */
+        A("com %10")
+        A("com %1")
+        A("neg %0")
+        A("sbc %1,%2")
+        A("sbc %10,%2")             /* %10:%1:%0 +1  -> %10:%1:%0 = -(v0 - v1) = (v1 - v0) */
+        A("clr %2")                 /* %2 = 0, means A_negative = false */
 
         /*  Store negative flag*/
-        "1:" "\n\t"
-        " sts A_negative, %2" "\n\t"     /* Store negative flag */
+        L("1")
+        A("sts A_negative, %2")     /* Store negative flag */
 
         /*  Compute coefficients A,B and C   [20 cycles worst case]*/
-        " ldi %9,6" "\n\t"               /* %9 = 6 */
-        " mul %0,%9" "\n\t"              /* r1:r0 = 6*LO(v0-v1) */
-        " sts bezier_A, r0" "\n\t"
-        " mov %6,r1" "\n\t"
-        " clr %7" "\n\t"                 /* %7:%6:r0 = 6*LO(v0-v1) */
-        " mul %1,%9" "\n\t"              /* r1:r0 = 6*MI(v0-v1) */
-        " add %6,r0" "\n\t"
-        " adc %7,r1" "\n\t"              /* %7:%6:?? += 6*MI(v0-v1) << 8 */
-        " mul %10,%9" "\n\t"             /* r1:r0 = 6*HI(v0-v1) */
-        " add %7,r0" "\n\t"              /* %7:%6:?? += 6*HI(v0-v1) << 16 */
-        " sts bezier_A+1, %6" "\n\t"
-        " sts bezier_A+2, %7" "\n\t"     /* bezier_A = %7:%6:?? = 6*(v0-v1) [35 cycles worst] */
-
-        " ldi %9,15" "\n\t"              /* %9 = 15 */
-        " mul %0,%9" "\n\t"              /* r1:r0 = 5*LO(v0-v1) */
-        " sts bezier_B, r0" "\n\t"
-        " mov %6,r1" "\n\t"
-        " clr %7" "\n\t"                 /* %7:%6:?? = 5*LO(v0-v1) */
-        " mul %1,%9" "\n\t"              /* r1:r0 = 5*MI(v0-v1) */
-        " add %6,r0" "\n\t"
-        " adc %7,r1" "\n\t"              /* %7:%6:?? += 5*MI(v0-v1) << 8 */
-        " mul %10,%9" "\n\t"             /* r1:r0 = 5*HI(v0-v1) */
-        " add %7,r0" "\n\t"              /* %7:%6:?? += 5*HI(v0-v1) << 16 */
-        " sts bezier_B+1, %6" "\n\t"
-        " sts bezier_B+2, %7" "\n\t"     /* bezier_B = %7:%6:?? = 5*(v0-v1) [50 cycles worst] */
-
-        " ldi %9,10" "\n\t"              /* %9 = 10 */
-        " mul %0,%9" "\n\t"              /* r1:r0 = 10*LO(v0-v1) */
-        " sts bezier_C, r0" "\n\t"
-        " mov %6,r1" "\n\t"
-        " clr %7" "\n\t"                 /* %7:%6:?? = 10*LO(v0-v1) */
-        " mul %1,%9" "\n\t"              /* r1:r0 = 10*MI(v0-v1) */
-        " add %6,r0" "\n\t"
-        " adc %7,r1" "\n\t"              /* %7:%6:?? += 10*MI(v0-v1) << 8 */
-        " mul %10,%9" "\n\t"             /* r1:r0 = 10*HI(v0-v1) */
-        " add %7,r0" "\n\t"              /* %7:%6:?? += 10*HI(v0-v1) << 16 */
-        " sts bezier_C+1, %6" "\n\t"
+        A("ldi %9,6")               /* %9 = 6 */
+        A("mul %0,%9")              /* r1:r0 = 6*LO(v0-v1) */
+        A("sts bezier_A, r0")
+        A("mov %6,r1")
+        A("clr %7")                 /* %7:%6:r0 = 6*LO(v0-v1) */
+        A("mul %1,%9")              /* r1:r0 = 6*MI(v0-v1) */
+        A("add %6,r0")
+        A("adc %7,r1")              /* %7:%6:?? += 6*MI(v0-v1) << 8 */
+        A("mul %10,%9")             /* r1:r0 = 6*HI(v0-v1) */
+        A("add %7,r0")              /* %7:%6:?? += 6*HI(v0-v1) << 16 */
+        A("sts bezier_A+1, %6")
+        A("sts bezier_A+2, %7")     /* bezier_A = %7:%6:?? = 6*(v0-v1) [35 cycles worst] */
+
+        A("ldi %9,15")              /* %9 = 15 */
+        A("mul %0,%9")              /* r1:r0 = 5*LO(v0-v1) */
+        A("sts bezier_B, r0")
+        A("mov %6,r1")
+        A("clr %7")                 /* %7:%6:?? = 5*LO(v0-v1) */
+        A("mul %1,%9")              /* r1:r0 = 5*MI(v0-v1) */
+        A("add %6,r0")
+        A("adc %7,r1")              /* %7:%6:?? += 5*MI(v0-v1) << 8 */
+        A("mul %10,%9")             /* r1:r0 = 5*HI(v0-v1) */
+        A("add %7,r0")              /* %7:%6:?? += 5*HI(v0-v1) << 16 */
+        A("sts bezier_B+1, %6")
+        A("sts bezier_B+2, %7")     /* bezier_B = %7:%6:?? = 5*(v0-v1) [50 cycles worst] */
+
+        A("ldi %9,10")              /* %9 = 10 */
+        A("mul %0,%9")              /* r1:r0 = 10*LO(v0-v1) */
+        A("sts bezier_C, r0")
+        A("mov %6,r1")
+        A("clr %7")                 /* %7:%6:?? = 10*LO(v0-v1) */
+        A("mul %1,%9")              /* r1:r0 = 10*MI(v0-v1) */
+        A("add %6,r0")
+        A("adc %7,r1")              /* %7:%6:?? += 10*MI(v0-v1) << 8 */
+        A("mul %10,%9")             /* r1:r0 = 10*HI(v0-v1) */
+        A("add %7,r0")              /* %7:%6:?? += 10*HI(v0-v1) << 16 */
+        A("sts bezier_C+1, %6")
         " sts bezier_C+2, %7"            /* bezier_C = %7:%6:?? = 10*(v0-v1) [65 cycles worst] */
         : "+r" (r2),
           "+d" (r3),
@@ -674,358 +674,358 @@ void Stepper::set_directions() {
 
       __asm__ __volatile(
         /* umul24x24to16hi(t, bezier_AV, curr_step);  t: Range 0 - 1^16 = 16 bits*/
-        " lds %9,bezier_AV" "\n\t"       /* %9 = LO(AV)*/
-        " mul %9,%2" "\n\t"              /* r1:r0 = LO(bezier_AV)*LO(curr_step)*/
-        " mov %7,r1" "\n\t"              /* %7 = LO(bezier_AV)*LO(curr_step) >> 8*/
-        " clr %8" "\n\t"                 /* %8:%7  = LO(bezier_AV)*LO(curr_step) >> 8*/
-        " lds %10,bezier_AV+1" "\n\t"    /* %10 = MI(AV)*/
-        " mul %10,%2" "\n\t"             /* r1:r0  = MI(bezier_AV)*LO(curr_step)*/
-        " add %7,r0" "\n\t"
-        " adc %8,r1" "\n\t"              /* %8:%7 += MI(bezier_AV)*LO(curr_step)*/
-        " lds r1,bezier_AV+2" "\n\t"     /* r11 = HI(AV)*/
-        " mul r1,%2" "\n\t"              /* r1:r0  = HI(bezier_AV)*LO(curr_step)*/
-        " add %8,r0" "\n\t"              /* %8:%7 += HI(bezier_AV)*LO(curr_step) << 8*/
-        " mul %9,%3" "\n\t"              /* r1:r0 =  LO(bezier_AV)*MI(curr_step)*/
-        " add %7,r0" "\n\t"
-        " adc %8,r1" "\n\t"              /* %8:%7 += LO(bezier_AV)*MI(curr_step)*/
-        " mul %10,%3" "\n\t"             /* r1:r0 =  MI(bezier_AV)*MI(curr_step)*/
-        " add %8,r0" "\n\t"              /* %8:%7 += LO(bezier_AV)*MI(curr_step) << 8*/
-        " mul %9,%4" "\n\t"              /* r1:r0 =  LO(bezier_AV)*HI(curr_step)*/
-        " add %8,r0" "\n\t"              /* %8:%7 += LO(bezier_AV)*HI(curr_step) << 8*/
+        A("lds %9,bezier_AV")       /* %9 = LO(AV)*/
+        A("mul %9,%2")              /* r1:r0 = LO(bezier_AV)*LO(curr_step)*/
+        A("mov %7,r1")              /* %7 = LO(bezier_AV)*LO(curr_step) >> 8*/
+        A("clr %8")                 /* %8:%7  = LO(bezier_AV)*LO(curr_step) >> 8*/
+        A("lds %10,bezier_AV+1")    /* %10 = MI(AV)*/
+        A("mul %10,%2")             /* r1:r0  = MI(bezier_AV)*LO(curr_step)*/
+        A("add %7,r0")
+        A("adc %8,r1")              /* %8:%7 += MI(bezier_AV)*LO(curr_step)*/
+        A("lds r1,bezier_AV+2")     /* r11 = HI(AV)*/
+        A("mul r1,%2")              /* r1:r0  = HI(bezier_AV)*LO(curr_step)*/
+        A("add %8,r0")              /* %8:%7 += HI(bezier_AV)*LO(curr_step) << 8*/
+        A("mul %9,%3")              /* r1:r0 =  LO(bezier_AV)*MI(curr_step)*/
+        A("add %7,r0")
+        A("adc %8,r1")              /* %8:%7 += LO(bezier_AV)*MI(curr_step)*/
+        A("mul %10,%3")             /* r1:r0 =  MI(bezier_AV)*MI(curr_step)*/
+        A("add %8,r0")              /* %8:%7 += LO(bezier_AV)*MI(curr_step) << 8*/
+        A("mul %9,%4")              /* r1:r0 =  LO(bezier_AV)*HI(curr_step)*/
+        A("add %8,r0")              /* %8:%7 += LO(bezier_AV)*HI(curr_step) << 8*/
         /* %8:%7 = t*/
 
         /* uint16_t f = t;*/
-        " mov %5,%7" "\n\t"              /* %6:%5 = f*/
-        " mov %6,%8" "\n\t"
+        A("mov %5,%7")              /* %6:%5 = f*/
+        A("mov %6,%8")
         /* %6:%5 = f*/
 
         /* umul16x16to16hi(f, f, t); / Range 16 bits (unsigned) [17] */
-        " mul %5,%7" "\n\t"              /* r1:r0 = LO(f) * LO(t)*/
-        " mov %9,r1" "\n\t"              /* store MIL(LO(f) * LO(t)) in %9, we need it for rounding*/
-        " clr %10" "\n\t"                /* %10 = 0*/
-        " clr %11" "\n\t"                /* %11 = 0*/
-        " mul %5,%8" "\n\t"              /* r1:r0 = LO(f) * HI(t)*/
-        " add %9,r0" "\n\t"              /* %9 += LO(LO(f) * HI(t))*/
-        " adc %10,r1" "\n\t"             /* %10 = HI(LO(f) * HI(t))*/
-        " adc %11,%0" "\n\t"             /* %11 += carry*/
-        " mul %6,%7" "\n\t"              /* r1:r0 = HI(f) * LO(t)*/
-        " add %9,r0" "\n\t"              /* %9 += LO(HI(f) * LO(t))*/
-        " adc %10,r1" "\n\t"             /* %10 += HI(HI(f) * LO(t)) */
-        " adc %11,%0" "\n\t"             /* %11 += carry*/
-        " mul %6,%8" "\n\t"              /* r1:r0 = HI(f) * HI(t)*/
-        " add %10,r0" "\n\t"             /* %10 += LO(HI(f) * HI(t))*/
-        " adc %11,r1" "\n\t"             /* %11 += HI(HI(f) * HI(t))*/
-        " mov %5,%10" "\n\t"             /* %6:%5 = */
-        " mov %6,%11" "\n\t"             /* f = %10:%11*/
+        A("mul %5,%7")              /* r1:r0 = LO(f) * LO(t)*/
+        A("mov %9,r1")              /* store MIL(LO(f) * LO(t)) in %9, we need it for rounding*/
+        A("clr %10")                /* %10 = 0*/
+        A("clr %11")                /* %11 = 0*/
+        A("mul %5,%8")              /* r1:r0 = LO(f) * HI(t)*/
+        A("add %9,r0")              /* %9 += LO(LO(f) * HI(t))*/
+        A("adc %10,r1")             /* %10 = HI(LO(f) * HI(t))*/
+        A("adc %11,%0")             /* %11 += carry*/
+        A("mul %6,%7")              /* r1:r0 = HI(f) * LO(t)*/
+        A("add %9,r0")              /* %9 += LO(HI(f) * LO(t))*/
+        A("adc %10,r1")             /* %10 += HI(HI(f) * LO(t)) */
+        A("adc %11,%0")             /* %11 += carry*/
+        A("mul %6,%8")              /* r1:r0 = HI(f) * HI(t)*/
+        A("add %10,r0")             /* %10 += LO(HI(f) * HI(t))*/
+        A("adc %11,r1")             /* %11 += HI(HI(f) * HI(t))*/
+        A("mov %5,%10")             /* %6:%5 = */
+        A("mov %6,%11")             /* f = %10:%11*/
 
         /* umul16x16to16hi(f, f, t); / Range 16 bits : f = t^3  (unsigned) [17]*/
-        " mul %5,%7" "\n\t"              /* r1:r0 = LO(f) * LO(t)*/
-        " mov %1,r1" "\n\t"              /* store MIL(LO(f) * LO(t)) in %1, we need it for rounding*/
-        " clr %10" "\n\t"                /* %10 = 0*/
-        " clr %11" "\n\t"                /* %11 = 0*/
-        " mul %5,%8" "\n\t"              /* r1:r0 = LO(f) * HI(t)*/
-        " add %1,r0" "\n\t"              /* %1 += LO(LO(f) * HI(t))*/
-        " adc %10,r1" "\n\t"             /* %10 = HI(LO(f) * HI(t))*/
-        " adc %11,%0" "\n\t"             /* %11 += carry*/
-        " mul %6,%7" "\n\t"              /* r1:r0 = HI(f) * LO(t)*/
-        " add %1,r0" "\n\t"              /* %1 += LO(HI(f) * LO(t))*/
-        " adc %10,r1" "\n\t"             /* %10 += HI(HI(f) * LO(t))*/
-        " adc %11,%0" "\n\t"             /* %11 += carry*/
-        " mul %6,%8" "\n\t"              /* r1:r0 = HI(f) * HI(t)*/
-        " add %10,r0" "\n\t"             /* %10 += LO(HI(f) * HI(t))*/
-        " adc %11,r1" "\n\t"             /* %11 += HI(HI(f) * HI(t))*/
-        " mov %5,%10" "\n\t"             /* %6:%5 =*/
-        " mov %6,%11" "\n\t"             /* f = %10:%11*/
+        A("mul %5,%7")              /* r1:r0 = LO(f) * LO(t)*/
+        A("mov %1,r1")              /* store MIL(LO(f) * LO(t)) in %1, we need it for rounding*/
+        A("clr %10")                /* %10 = 0*/
+        A("clr %11")                /* %11 = 0*/
+        A("mul %5,%8")              /* r1:r0 = LO(f) * HI(t)*/
+        A("add %1,r0")              /* %1 += LO(LO(f) * HI(t))*/
+        A("adc %10,r1")             /* %10 = HI(LO(f) * HI(t))*/
+        A("adc %11,%0")             /* %11 += carry*/
+        A("mul %6,%7")              /* r1:r0 = HI(f) * LO(t)*/
+        A("add %1,r0")              /* %1 += LO(HI(f) * LO(t))*/
+        A("adc %10,r1")             /* %10 += HI(HI(f) * LO(t))*/
+        A("adc %11,%0")             /* %11 += carry*/
+        A("mul %6,%8")              /* r1:r0 = HI(f) * HI(t)*/
+        A("add %10,r0")             /* %10 += LO(HI(f) * HI(t))*/
+        A("adc %11,r1")             /* %11 += HI(HI(f) * HI(t))*/
+        A("mov %5,%10")             /* %6:%5 =*/
+        A("mov %6,%11")             /* f = %10:%11*/
         /* [15 +17*2] = [49]*/
 
         /* %4:%3:%2 will be acc from now on*/
 
         /* uint24_t acc = bezier_F; / Range 20 bits (unsigned)*/
-        " clr %9" "\n\t"                 /* "decimal place we get for free"*/
-        " lds %2,bezier_F" "\n\t"
-        " lds %3,bezier_F+1" "\n\t"
-        " lds %4,bezier_F+2" "\n\t"      /* %4:%3:%2 = acc*/
+        A("clr %9")                 /* "decimal place we get for free"*/
+        A("lds %2,bezier_F")
+        A("lds %3,bezier_F+1")
+        A("lds %4,bezier_F+2")      /* %4:%3:%2 = acc*/
 
         /* if (A_negative) {*/
-        " lds r0,A_negative" "\n\t"
-        " or r0,%0" "\n\t"               /* Is flag signalling negative? */
-        " brne 3f" "\n\t"                /* If yes, Skip next instruction if A was negative*/
-        " rjmp 1f" "\n\t"                /* Otherwise, jump */
+        A("lds r0,A_negative")
+        A("or r0,%0")               /* Is flag signalling negative? */
+        A("brne 3f")                /* If yes, Skip next instruction if A was negative*/
+        A("rjmp 1f")                /* Otherwise, jump */
 
         /* uint24_t v; */
         /* umul16x24to24hi(v, f, bezier_C); / Range 21bits [29] */
         /* acc -= v; */
-        "3:" "\n\t"
-        " lds %10, bezier_C" "\n\t"      /* %10 = LO(bezier_C)*/
-        " mul %10,%5" "\n\t"             /* r1:r0 = LO(bezier_C) * LO(f)*/
-        " sub %9,r1" "\n\t"
-        " sbc %2,%0" "\n\t"
-        " sbc %3,%0" "\n\t"
-        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= HI(LO(bezier_C) * LO(f))*/
-        " lds %11, bezier_C+1" "\n\t"    /* %11 = MI(bezier_C)*/
-        " mul %11,%5" "\n\t"             /* r1:r0 = MI(bezier_C) * LO(f)*/
-        " sub %9,r0" "\n\t"
-        " sbc %2,r1" "\n\t"
-        " sbc %3,%0" "\n\t"
-        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= MI(bezier_C) * LO(f)*/
-        " lds %1, bezier_C+2" "\n\t"     /* %1 = HI(bezier_C)*/
-        " mul %1,%5" "\n\t"              /* r1:r0 = MI(bezier_C) * LO(f)*/
-        " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"
-        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= HI(bezier_C) * LO(f) << 8*/
-        " mul %10,%6" "\n\t"             /* r1:r0 = LO(bezier_C) * MI(f)*/
-        " sub %9,r0" "\n\t"
-        " sbc %2,r1" "\n\t"
-        " sbc %3,%0" "\n\t"
-        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= LO(bezier_C) * MI(f)*/
-        " mul %11,%6" "\n\t"             /* r1:r0 = MI(bezier_C) * MI(f)*/
-        " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"
-        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= MI(bezier_C) * MI(f) << 8*/
-        " mul %1,%6" "\n\t"              /* r1:r0 = HI(bezier_C) * LO(f)*/
-        " sub %3,r0" "\n\t"
-        " sbc %4,r1" "\n\t"              /* %4:%3:%2:%9 -= HI(bezier_C) * LO(f) << 16*/
+        L("3")
+        A("lds %10, bezier_C")      /* %10 = LO(bezier_C)*/
+        A("mul %10,%5")             /* r1:r0 = LO(bezier_C) * LO(f)*/
+        A("sub %9,r1")
+        A("sbc %2,%0")
+        A("sbc %3,%0")
+        A("sbc %4,%0")              /* %4:%3:%2:%9 -= HI(LO(bezier_C) * LO(f))*/
+        A("lds %11, bezier_C+1")    /* %11 = MI(bezier_C)*/
+        A("mul %11,%5")             /* r1:r0 = MI(bezier_C) * LO(f)*/
+        A("sub %9,r0")
+        A("sbc %2,r1")
+        A("sbc %3,%0")
+        A("sbc %4,%0")              /* %4:%3:%2:%9 -= MI(bezier_C) * LO(f)*/
+        A("lds %1, bezier_C+2")     /* %1 = HI(bezier_C)*/
+        A("mul %1,%5")              /* r1:r0 = MI(bezier_C) * LO(f)*/
+        A("sub %2,r0")
+        A("sbc %3,r1")
+        A("sbc %4,%0")              /* %4:%3:%2:%9 -= HI(bezier_C) * LO(f) << 8*/
+        A("mul %10,%6")             /* r1:r0 = LO(bezier_C) * MI(f)*/
+        A("sub %9,r0")
+        A("sbc %2,r1")
+        A("sbc %3,%0")
+        A("sbc %4,%0")              /* %4:%3:%2:%9 -= LO(bezier_C) * MI(f)*/
+        A("mul %11,%6")             /* r1:r0 = MI(bezier_C) * MI(f)*/
+        A("sub %2,r0")
+        A("sbc %3,r1")
+        A("sbc %4,%0")              /* %4:%3:%2:%9 -= MI(bezier_C) * MI(f) << 8*/
+        A("mul %1,%6")              /* r1:r0 = HI(bezier_C) * LO(f)*/
+        A("sub %3,r0")
+        A("sbc %4,r1")              /* %4:%3:%2:%9 -= HI(bezier_C) * LO(f) << 16*/
 
         /* umul16x16to16hi(f, f, t); / Range 16 bits : f = t^3  (unsigned) [17]*/
-        " mul %5,%7" "\n\t"              /* r1:r0 = LO(f) * LO(t)*/
-        " mov %1,r1" "\n\t"              /* store MIL(LO(f) * LO(t)) in %1, we need it for rounding*/
-        " clr %10" "\n\t"                /* %10 = 0*/
-        " clr %11" "\n\t"                /* %11 = 0*/
-        " mul %5,%8" "\n\t"              /* r1:r0 = LO(f) * HI(t)*/
-        " add %1,r0" "\n\t"              /* %1 += LO(LO(f) * HI(t))*/
-        " adc %10,r1" "\n\t"             /* %10 = HI(LO(f) * HI(t))*/
-        " adc %11,%0" "\n\t"             /* %11 += carry*/
-        " mul %6,%7" "\n\t"              /* r1:r0 = HI(f) * LO(t)*/
-        " add %1,r0" "\n\t"              /* %1 += LO(HI(f) * LO(t))*/
-        " adc %10,r1" "\n\t"             /* %10 += HI(HI(f) * LO(t))*/
-        " adc %11,%0" "\n\t"             /* %11 += carry*/
-        " mul %6,%8" "\n\t"              /* r1:r0 = HI(f) * HI(t)*/
-        " add %10,r0" "\n\t"             /* %10 += LO(HI(f) * HI(t))*/
-        " adc %11,r1" "\n\t"             /* %11 += HI(HI(f) * HI(t))*/
-        " mov %5,%10" "\n\t"             /* %6:%5 =*/
-        " mov %6,%11" "\n\t"             /* f = %10:%11*/
+        A("mul %5,%7")              /* r1:r0 = LO(f) * LO(t)*/
+        A("mov %1,r1")              /* store MIL(LO(f) * LO(t)) in %1, we need it for rounding*/
+        A("clr %10")                /* %10 = 0*/
+        A("clr %11")                /* %11 = 0*/
+        A("mul %5,%8")              /* r1:r0 = LO(f) * HI(t)*/
+        A("add %1,r0")              /* %1 += LO(LO(f) * HI(t))*/
+        A("adc %10,r1")             /* %10 = HI(LO(f) * HI(t))*/
+        A("adc %11,%0")             /* %11 += carry*/
+        A("mul %6,%7")              /* r1:r0 = HI(f) * LO(t)*/
+        A("add %1,r0")              /* %1 += LO(HI(f) * LO(t))*/
+        A("adc %10,r1")             /* %10 += HI(HI(f) * LO(t))*/
+        A("adc %11,%0")             /* %11 += carry*/
+        A("mul %6,%8")              /* r1:r0 = HI(f) * HI(t)*/
+        A("add %10,r0")             /* %10 += LO(HI(f) * HI(t))*/
+        A("adc %11,r1")             /* %11 += HI(HI(f) * HI(t))*/
+        A("mov %5,%10")             /* %6:%5 =*/
+        A("mov %6,%11")             /* f = %10:%11*/
 
         /* umul16x24to24hi(v, f, bezier_B); / Range 22bits [29]*/
         /* acc += v; */
-        " lds %10, bezier_B" "\n\t"      /* %10 = LO(bezier_B)*/
-        " mul %10,%5" "\n\t"             /* r1:r0 = LO(bezier_B) * LO(f)*/
-        " add %9,r1" "\n\t"
-        " adc %2,%0" "\n\t"
-        " adc %3,%0" "\n\t"
-        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += HI(LO(bezier_B) * LO(f))*/
-        " lds %11, bezier_B+1" "\n\t"    /* %11 = MI(bezier_B)*/
-        " mul %11,%5" "\n\t"             /* r1:r0 = MI(bezier_B) * LO(f)*/
-        " add %9,r0" "\n\t"
-        " adc %2,r1" "\n\t"
-        " adc %3,%0" "\n\t"
-        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += MI(bezier_B) * LO(f)*/
-        " lds %1, bezier_B+2" "\n\t"     /* %1 = HI(bezier_B)*/
-        " mul %1,%5" "\n\t"              /* r1:r0 = MI(bezier_B) * LO(f)*/
-        " add %2,r0" "\n\t"
-        " adc %3,r1" "\n\t"
-        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += HI(bezier_B) * LO(f) << 8*/
-        " mul %10,%6" "\n\t"             /* r1:r0 = LO(bezier_B) * MI(f)*/
-        " add %9,r0" "\n\t"
-        " adc %2,r1" "\n\t"
-        " adc %3,%0" "\n\t"
-        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += LO(bezier_B) * MI(f)*/
-        " mul %11,%6" "\n\t"             /* r1:r0 = MI(bezier_B) * MI(f)*/
-        " add %2,r0" "\n\t"
-        " adc %3,r1" "\n\t"
-        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += MI(bezier_B) * MI(f) << 8*/
-        " mul %1,%6" "\n\t"              /* r1:r0 = HI(bezier_B) * LO(f)*/
-        " add %3,r0" "\n\t"
-        " adc %4,r1" "\n\t"              /* %4:%3:%2:%9 += HI(bezier_B) * LO(f) << 16*/
+        A("lds %10, bezier_B")      /* %10 = LO(bezier_B)*/
+        A("mul %10,%5")             /* r1:r0 = LO(bezier_B) * LO(f)*/
+        A("add %9,r1")
+        A("adc %2,%0")
+        A("adc %3,%0")
+        A("adc %4,%0")              /* %4:%3:%2:%9 += HI(LO(bezier_B) * LO(f))*/
+        A("lds %11, bezier_B+1")    /* %11 = MI(bezier_B)*/
+        A("mul %11,%5")             /* r1:r0 = MI(bezier_B) * LO(f)*/
+        A("add %9,r0")
+        A("adc %2,r1")
+        A("adc %3,%0")
+        A("adc %4,%0")              /* %4:%3:%2:%9 += MI(bezier_B) * LO(f)*/
+        A("lds %1, bezier_B+2")     /* %1 = HI(bezier_B)*/
+        A("mul %1,%5")              /* r1:r0 = MI(bezier_B) * LO(f)*/
+        A("add %2,r0")
+        A("adc %3,r1")
+        A("adc %4,%0")              /* %4:%3:%2:%9 += HI(bezier_B) * LO(f) << 8*/
+        A("mul %10,%6")             /* r1:r0 = LO(bezier_B) * MI(f)*/
+        A("add %9,r0")
+        A("adc %2,r1")
+        A("adc %3,%0")
+        A("adc %4,%0")              /* %4:%3:%2:%9 += LO(bezier_B) * MI(f)*/
+        A("mul %11,%6")             /* r1:r0 = MI(bezier_B) * MI(f)*/
+        A("add %2,r0")
+        A("adc %3,r1")
+        A("adc %4,%0")              /* %4:%3:%2:%9 += MI(bezier_B) * MI(f) << 8*/
+        A("mul %1,%6")              /* r1:r0 = HI(bezier_B) * LO(f)*/
+        A("add %3,r0")
+        A("adc %4,r1")              /* %4:%3:%2:%9 += HI(bezier_B) * LO(f) << 16*/
 
         /* umul16x16to16hi(f, f, t); / Range 16 bits : f = t^5  (unsigned) [17]*/
-        " mul %5,%7" "\n\t"              /* r1:r0 = LO(f) * LO(t)*/
-        " mov %1,r1" "\n\t"              /* store MIL(LO(f) * LO(t)) in %1, we need it for rounding*/
-        " clr %10" "\n\t"                /* %10 = 0*/
-        " clr %11" "\n\t"                /* %11 = 0*/
-        " mul %5,%8" "\n\t"              /* r1:r0 = LO(f) * HI(t)*/
-        " add %1,r0" "\n\t"              /* %1 += LO(LO(f) * HI(t))*/
-        " adc %10,r1" "\n\t"             /* %10 = HI(LO(f) * HI(t))*/
-        " adc %11,%0" "\n\t"             /* %11 += carry*/
-        " mul %6,%7" "\n\t"              /* r1:r0 = HI(f) * LO(t)*/
-        " add %1,r0" "\n\t"              /* %1 += LO(HI(f) * LO(t))*/
-        " adc %10,r1" "\n\t"             /* %10 += HI(HI(f) * LO(t))*/
-        " adc %11,%0" "\n\t"             /* %11 += carry*/
-        " mul %6,%8" "\n\t"              /* r1:r0 = HI(f) * HI(t)*/
-        " add %10,r0" "\n\t"             /* %10 += LO(HI(f) * HI(t))*/
-        " adc %11,r1" "\n\t"             /* %11 += HI(HI(f) * HI(t))*/
-        " mov %5,%10" "\n\t"             /* %6:%5 =*/
-        " mov %6,%11" "\n\t"             /* f = %10:%11*/
+        A("mul %5,%7")              /* r1:r0 = LO(f) * LO(t)*/
+        A("mov %1,r1")              /* store MIL(LO(f) * LO(t)) in %1, we need it for rounding*/
+        A("clr %10")                /* %10 = 0*/
+        A("clr %11")                /* %11 = 0*/
+        A("mul %5,%8")              /* r1:r0 = LO(f) * HI(t)*/
+        A("add %1,r0")              /* %1 += LO(LO(f) * HI(t))*/
+        A("adc %10,r1")             /* %10 = HI(LO(f) * HI(t))*/
+        A("adc %11,%0")             /* %11 += carry*/
+        A("mul %6,%7")              /* r1:r0 = HI(f) * LO(t)*/
+        A("add %1,r0")              /* %1 += LO(HI(f) * LO(t))*/
+        A("adc %10,r1")             /* %10 += HI(HI(f) * LO(t))*/
+        A("adc %11,%0")             /* %11 += carry*/
+        A("mul %6,%8")              /* r1:r0 = HI(f) * HI(t)*/
+        A("add %10,r0")             /* %10 += LO(HI(f) * HI(t))*/
+        A("adc %11,r1")             /* %11 += HI(HI(f) * HI(t))*/
+        A("mov %5,%10")             /* %6:%5 =*/
+        A("mov %6,%11")             /* f = %10:%11*/
 
         /* umul16x24to24hi(v, f, bezier_A); / Range 21bits [29]*/
         /* acc -= v; */
-        " lds %10, bezier_A" "\n\t"      /* %10 = LO(bezier_A)*/
-        " mul %10,%5" "\n\t"             /* r1:r0 = LO(bezier_A) * LO(f)*/
-        " sub %9,r1" "\n\t"
-        " sbc %2,%0" "\n\t"
-        " sbc %3,%0" "\n\t"
-        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= HI(LO(bezier_A) * LO(f))*/
-        " lds %11, bezier_A+1" "\n\t"    /* %11 = MI(bezier_A)*/
-        " mul %11,%5" "\n\t"             /* r1:r0 = MI(bezier_A) * LO(f)*/
-        " sub %9,r0" "\n\t"
-        " sbc %2,r1" "\n\t"
-        " sbc %3,%0" "\n\t"
-        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= MI(bezier_A) * LO(f)*/
-        " lds %1, bezier_A+2" "\n\t"     /* %1 = HI(bezier_A)*/
-        " mul %1,%5" "\n\t"              /* r1:r0 = MI(bezier_A) * LO(f)*/
-        " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"
-        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= HI(bezier_A) * LO(f) << 8*/
-        " mul %10,%6" "\n\t"             /* r1:r0 = LO(bezier_A) * MI(f)*/
-        " sub %9,r0" "\n\t"
-        " sbc %2,r1" "\n\t"
-        " sbc %3,%0" "\n\t"
-        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= LO(bezier_A) * MI(f)*/
-        " mul %11,%6" "\n\t"             /* r1:r0 = MI(bezier_A) * MI(f)*/
-        " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"
-        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= MI(bezier_A) * MI(f) << 8*/
-        " mul %1,%6" "\n\t"              /* r1:r0 = HI(bezier_A) * LO(f)*/
-        " sub %3,r0" "\n\t"
-        " sbc %4,r1" "\n\t"              /* %4:%3:%2:%9 -= HI(bezier_A) * LO(f) << 16*/
-        " jmp 2f" "\n\t"                 /* Done!*/
-
-        "1:" "\n\t"
+        A("lds %10, bezier_A")      /* %10 = LO(bezier_A)*/
+        A("mul %10,%5")             /* r1:r0 = LO(bezier_A) * LO(f)*/
+        A("sub %9,r1")
+        A("sbc %2,%0")
+        A("sbc %3,%0")
+        A("sbc %4,%0")              /* %4:%3:%2:%9 -= HI(LO(bezier_A) * LO(f))*/
+        A("lds %11, bezier_A+1")    /* %11 = MI(bezier_A)*/
+        A("mul %11,%5")             /* r1:r0 = MI(bezier_A) * LO(f)*/
+        A("sub %9,r0")
+        A("sbc %2,r1")
+        A("sbc %3,%0")
+        A("sbc %4,%0")              /* %4:%3:%2:%9 -= MI(bezier_A) * LO(f)*/
+        A("lds %1, bezier_A+2")     /* %1 = HI(bezier_A)*/
+        A("mul %1,%5")              /* r1:r0 = MI(bezier_A) * LO(f)*/
+        A("sub %2,r0")
+        A("sbc %3,r1")
+        A("sbc %4,%0")              /* %4:%3:%2:%9 -= HI(bezier_A) * LO(f) << 8*/
+        A("mul %10,%6")             /* r1:r0 = LO(bezier_A) * MI(f)*/
+        A("sub %9,r0")
+        A("sbc %2,r1")
+        A("sbc %3,%0")
+        A("sbc %4,%0")              /* %4:%3:%2:%9 -= LO(bezier_A) * MI(f)*/
+        A("mul %11,%6")             /* r1:r0 = MI(bezier_A) * MI(f)*/
+        A("sub %2,r0")
+        A("sbc %3,r1")
+        A("sbc %4,%0")              /* %4:%3:%2:%9 -= MI(bezier_A) * MI(f) << 8*/
+        A("mul %1,%6")              /* r1:r0 = HI(bezier_A) * LO(f)*/
+        A("sub %3,r0")
+        A("sbc %4,r1")              /* %4:%3:%2:%9 -= HI(bezier_A) * LO(f) << 16*/
+        A("jmp 2f")                 /* Done!*/
+
+        L("1")
 
         /* uint24_t v; */
         /* umul16x24to24hi(v, f, bezier_C); / Range 21bits [29]*/
         /* acc += v; */
-        " lds %10, bezier_C" "\n\t"      /* %10 = LO(bezier_C)*/
-        " mul %10,%5" "\n\t"             /* r1:r0 = LO(bezier_C) * LO(f)*/
-        " add %9,r1" "\n\t"
-        " adc %2,%0" "\n\t"
-        " adc %3,%0" "\n\t"
-        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += HI(LO(bezier_C) * LO(f))*/
-        " lds %11, bezier_C+1" "\n\t"    /* %11 = MI(bezier_C)*/
-        " mul %11,%5" "\n\t"             /* r1:r0 = MI(bezier_C) * LO(f)*/
-        " add %9,r0" "\n\t"
-        " adc %2,r1" "\n\t"
-        " adc %3,%0" "\n\t"
-        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += MI(bezier_C) * LO(f)*/
-        " lds %1, bezier_C+2" "\n\t"     /* %1 = HI(bezier_C)*/
-        " mul %1,%5" "\n\t"              /* r1:r0 = MI(bezier_C) * LO(f)*/
-        " add %2,r0" "\n\t"
-        " adc %3,r1" "\n\t"
-        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += HI(bezier_C) * LO(f) << 8*/
-        " mul %10,%6" "\n\t"             /* r1:r0 = LO(bezier_C) * MI(f)*/
-        " add %9,r0" "\n\t"
-        " adc %2,r1" "\n\t"
-        " adc %3,%0" "\n\t"
-        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += LO(bezier_C) * MI(f)*/
-        " mul %11,%6" "\n\t"             /* r1:r0 = MI(bezier_C) * MI(f)*/
-        " add %2,r0" "\n\t"
-        " adc %3,r1" "\n\t"
-        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += MI(bezier_C) * MI(f) << 8*/
-        " mul %1,%6" "\n\t"              /* r1:r0 = HI(bezier_C) * LO(f)*/
-        " add %3,r0" "\n\t"
-        " adc %4,r1" "\n\t"              /* %4:%3:%2:%9 += HI(bezier_C) * LO(f) << 16*/
+        A("lds %10, bezier_C")      /* %10 = LO(bezier_C)*/
+        A("mul %10,%5")             /* r1:r0 = LO(bezier_C) * LO(f)*/
+        A("add %9,r1")
+        A("adc %2,%0")
+        A("adc %3,%0")
+        A("adc %4,%0")              /* %4:%3:%2:%9 += HI(LO(bezier_C) * LO(f))*/
+        A("lds %11, bezier_C+1")    /* %11 = MI(bezier_C)*/
+        A("mul %11,%5")             /* r1:r0 = MI(bezier_C) * LO(f)*/
+        A("add %9,r0")
+        A("adc %2,r1")
+        A("adc %3,%0")
+        A("adc %4,%0")              /* %4:%3:%2:%9 += MI(bezier_C) * LO(f)*/
+        A("lds %1, bezier_C+2")     /* %1 = HI(bezier_C)*/
+        A("mul %1,%5")              /* r1:r0 = MI(bezier_C) * LO(f)*/
+        A("add %2,r0")
+        A("adc %3,r1")
+        A("adc %4,%0")              /* %4:%3:%2:%9 += HI(bezier_C) * LO(f) << 8*/
+        A("mul %10,%6")             /* r1:r0 = LO(bezier_C) * MI(f)*/
+        A("add %9,r0")
+        A("adc %2,r1")
+        A("adc %3,%0")
+        A("adc %4,%0")              /* %4:%3:%2:%9 += LO(bezier_C) * MI(f)*/
+        A("mul %11,%6")             /* r1:r0 = MI(bezier_C) * MI(f)*/
+        A("add %2,r0")
+        A("adc %3,r1")
+        A("adc %4,%0")              /* %4:%3:%2:%9 += MI(bezier_C) * MI(f) << 8*/
+        A("mul %1,%6")              /* r1:r0 = HI(bezier_C) * LO(f)*/
+        A("add %3,r0")
+        A("adc %4,r1")              /* %4:%3:%2:%9 += HI(bezier_C) * LO(f) << 16*/
 
         /* umul16x16to16hi(f, f, t); / Range 16 bits : f = t^3  (unsigned) [17]*/
-        " mul %5,%7" "\n\t"              /* r1:r0 = LO(f) * LO(t)*/
-        " mov %1,r1" "\n\t"              /* store MIL(LO(f) * LO(t)) in %1, we need it for rounding*/
-        " clr %10" "\n\t"                /* %10 = 0*/
-        " clr %11" "\n\t"                /* %11 = 0*/
-        " mul %5,%8" "\n\t"              /* r1:r0 = LO(f) * HI(t)*/
-        " add %1,r0" "\n\t"              /* %1 += LO(LO(f) * HI(t))*/
-        " adc %10,r1" "\n\t"             /* %10 = HI(LO(f) * HI(t))*/
-        " adc %11,%0" "\n\t"             /* %11 += carry*/
-        " mul %6,%7" "\n\t"              /* r1:r0 = HI(f) * LO(t)*/
-        " add %1,r0" "\n\t"              /* %1 += LO(HI(f) * LO(t))*/
-        " adc %10,r1" "\n\t"             /* %10 += HI(HI(f) * LO(t))*/
-        " adc %11,%0" "\n\t"             /* %11 += carry*/
-        " mul %6,%8" "\n\t"              /* r1:r0 = HI(f) * HI(t)*/
-        " add %10,r0" "\n\t"             /* %10 += LO(HI(f) * HI(t))*/
-        " adc %11,r1" "\n\t"             /* %11 += HI(HI(f) * HI(t))*/
-        " mov %5,%10" "\n\t"             /* %6:%5 =*/
-        " mov %6,%11" "\n\t"             /* f = %10:%11*/
+        A("mul %5,%7")              /* r1:r0 = LO(f) * LO(t)*/
+        A("mov %1,r1")              /* store MIL(LO(f) * LO(t)) in %1, we need it for rounding*/
+        A("clr %10")                /* %10 = 0*/
+        A("clr %11")                /* %11 = 0*/
+        A("mul %5,%8")              /* r1:r0 = LO(f) * HI(t)*/
+        A("add %1,r0")              /* %1 += LO(LO(f) * HI(t))*/
+        A("adc %10,r1")             /* %10 = HI(LO(f) * HI(t))*/
+        A("adc %11,%0")             /* %11 += carry*/
+        A("mul %6,%7")              /* r1:r0 = HI(f) * LO(t)*/
+        A("add %1,r0")              /* %1 += LO(HI(f) * LO(t))*/
+        A("adc %10,r1")             /* %10 += HI(HI(f) * LO(t))*/
+        A("adc %11,%0")             /* %11 += carry*/
+        A("mul %6,%8")              /* r1:r0 = HI(f) * HI(t)*/
+        A("add %10,r0")             /* %10 += LO(HI(f) * HI(t))*/
+        A("adc %11,r1")             /* %11 += HI(HI(f) * HI(t))*/
+        A("mov %5,%10")             /* %6:%5 =*/
+        A("mov %6,%11")             /* f = %10:%11*/
 
         /* umul16x24to24hi(v, f, bezier_B); / Range 22bits [29]*/
         /* acc -= v;*/
-        " lds %10, bezier_B" "\n\t"      /* %10 = LO(bezier_B)*/
-        " mul %10,%5" "\n\t"             /* r1:r0 = LO(bezier_B) * LO(f)*/
-        " sub %9,r1" "\n\t"
-        " sbc %2,%0" "\n\t"
-        " sbc %3,%0" "\n\t"
-        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= HI(LO(bezier_B) * LO(f))*/
-        " lds %11, bezier_B+1" "\n\t"    /* %11 = MI(bezier_B)*/
-        " mul %11,%5" "\n\t"             /* r1:r0 = MI(bezier_B) * LO(f)*/
-        " sub %9,r0" "\n\t"
-        " sbc %2,r1" "\n\t"
-        " sbc %3,%0" "\n\t"
-        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= MI(bezier_B) * LO(f)*/
-        " lds %1, bezier_B+2" "\n\t"     /* %1 = HI(bezier_B)*/
-        " mul %1,%5" "\n\t"              /* r1:r0 = MI(bezier_B) * LO(f)*/
-        " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"
-        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= HI(bezier_B) * LO(f) << 8*/
-        " mul %10,%6" "\n\t"             /* r1:r0 = LO(bezier_B) * MI(f)*/
-        " sub %9,r0" "\n\t"
-        " sbc %2,r1" "\n\t"
-        " sbc %3,%0" "\n\t"
-        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= LO(bezier_B) * MI(f)*/
-        " mul %11,%6" "\n\t"             /* r1:r0 = MI(bezier_B) * MI(f)*/
-        " sub %2,r0" "\n\t"
-        " sbc %3,r1" "\n\t"
-        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= MI(bezier_B) * MI(f) << 8*/
-        " mul %1,%6" "\n\t"              /* r1:r0 = HI(bezier_B) * LO(f)*/
-        " sub %3,r0" "\n\t"
-        " sbc %4,r1" "\n\t"              /* %4:%3:%2:%9 -= HI(bezier_B) * LO(f) << 16*/
+        A("lds %10, bezier_B")      /* %10 = LO(bezier_B)*/
+        A("mul %10,%5")             /* r1:r0 = LO(bezier_B) * LO(f)*/
+        A("sub %9,r1")
+        A("sbc %2,%0")
+        A("sbc %3,%0")
+        A("sbc %4,%0")              /* %4:%3:%2:%9 -= HI(LO(bezier_B) * LO(f))*/
+        A("lds %11, bezier_B+1")    /* %11 = MI(bezier_B)*/
+        A("mul %11,%5")             /* r1:r0 = MI(bezier_B) * LO(f)*/
+        A("sub %9,r0")
+        A("sbc %2,r1")
+        A("sbc %3,%0")
+        A("sbc %4,%0")              /* %4:%3:%2:%9 -= MI(bezier_B) * LO(f)*/
+        A("lds %1, bezier_B+2")     /* %1 = HI(bezier_B)*/
+        A("mul %1,%5")              /* r1:r0 = MI(bezier_B) * LO(f)*/
+        A("sub %2,r0")
+        A("sbc %3,r1")
+        A("sbc %4,%0")              /* %4:%3:%2:%9 -= HI(bezier_B) * LO(f) << 8*/
+        A("mul %10,%6")             /* r1:r0 = LO(bezier_B) * MI(f)*/
+        A("sub %9,r0")
+        A("sbc %2,r1")
+        A("sbc %3,%0")
+        A("sbc %4,%0")              /* %4:%3:%2:%9 -= LO(bezier_B) * MI(f)*/
+        A("mul %11,%6")             /* r1:r0 = MI(bezier_B) * MI(f)*/
+        A("sub %2,r0")
+        A("sbc %3,r1")
+        A("sbc %4,%0")              /* %4:%3:%2:%9 -= MI(bezier_B) * MI(f) << 8*/
+        A("mul %1,%6")              /* r1:r0 = HI(bezier_B) * LO(f)*/
+        A("sub %3,r0")
+        A("sbc %4,r1")              /* %4:%3:%2:%9 -= HI(bezier_B) * LO(f) << 16*/
 
         /* umul16x16to16hi(f, f, t); / Range 16 bits : f = t^5  (unsigned) [17]*/
-        " mul %5,%7" "\n\t"              /* r1:r0 = LO(f) * LO(t)*/
-        " mov %1,r1" "\n\t"              /* store MIL(LO(f) * LO(t)) in %1, we need it for rounding*/
-        " clr %10" "\n\t"                /* %10 = 0*/
-        " clr %11" "\n\t"                /* %11 = 0*/
-        " mul %5,%8" "\n\t"              /* r1:r0 = LO(f) * HI(t)*/
-        " add %1,r0" "\n\t"              /* %1 += LO(LO(f) * HI(t))*/
-        " adc %10,r1" "\n\t"             /* %10 = HI(LO(f) * HI(t))*/
-        " adc %11,%0" "\n\t"             /* %11 += carry*/
-        " mul %6,%7" "\n\t"              /* r1:r0 = HI(f) * LO(t)*/
-        " add %1,r0" "\n\t"              /* %1 += LO(HI(f) * LO(t))*/
-        " adc %10,r1" "\n\t"             /* %10 += HI(HI(f) * LO(t))*/
-        " adc %11,%0" "\n\t"             /* %11 += carry*/
-        " mul %6,%8" "\n\t"              /* r1:r0 = HI(f) * HI(t)*/
-        " add %10,r0" "\n\t"             /* %10 += LO(HI(f) * HI(t))*/
-        " adc %11,r1" "\n\t"             /* %11 += HI(HI(f) * HI(t))*/
-        " mov %5,%10" "\n\t"             /* %6:%5 =*/
-        " mov %6,%11" "\n\t"             /* f = %10:%11*/
+        A("mul %5,%7")              /* r1:r0 = LO(f) * LO(t)*/
+        A("mov %1,r1")              /* store MIL(LO(f) * LO(t)) in %1, we need it for rounding*/
+        A("clr %10")                /* %10 = 0*/
+        A("clr %11")                /* %11 = 0*/
+        A("mul %5,%8")              /* r1:r0 = LO(f) * HI(t)*/
+        A("add %1,r0")              /* %1 += LO(LO(f) * HI(t))*/
+        A("adc %10,r1")             /* %10 = HI(LO(f) * HI(t))*/
+        A("adc %11,%0")             /* %11 += carry*/
+        A("mul %6,%7")              /* r1:r0 = HI(f) * LO(t)*/
+        A("add %1,r0")              /* %1 += LO(HI(f) * LO(t))*/
+        A("adc %10,r1")             /* %10 += HI(HI(f) * LO(t))*/
+        A("adc %11,%0")             /* %11 += carry*/
+        A("mul %6,%8")              /* r1:r0 = HI(f) * HI(t)*/
+        A("add %10,r0")             /* %10 += LO(HI(f) * HI(t))*/
+        A("adc %11,r1")             /* %11 += HI(HI(f) * HI(t))*/
+        A("mov %5,%10")             /* %6:%5 =*/
+        A("mov %6,%11")             /* f = %10:%11*/
 
         /* umul16x24to24hi(v, f, bezier_A); / Range 21bits [29]*/
         /* acc += v; */
-        " lds %10, bezier_A" "\n\t"      /* %10 = LO(bezier_A)*/
-        " mul %10,%5" "\n\t"             /* r1:r0 = LO(bezier_A) * LO(f)*/
-        " add %9,r1" "\n\t"
-        " adc %2,%0" "\n\t"
-        " adc %3,%0" "\n\t"
-        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += HI(LO(bezier_A) * LO(f))*/
-        " lds %11, bezier_A+1" "\n\t"    /* %11 = MI(bezier_A)*/
-        " mul %11,%5" "\n\t"             /* r1:r0 = MI(bezier_A) * LO(f)*/
-        " add %9,r0" "\n\t"
-        " adc %2,r1" "\n\t"
-        " adc %3,%0" "\n\t"
-        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += MI(bezier_A) * LO(f)*/
-        " lds %1, bezier_A+2" "\n\t"     /* %1 = HI(bezier_A)*/
-        " mul %1,%5" "\n\t"              /* r1:r0 = MI(bezier_A) * LO(f)*/
-        " add %2,r0" "\n\t"
-        " adc %3,r1" "\n\t"
-        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += HI(bezier_A) * LO(f) << 8*/
-        " mul %10,%6" "\n\t"             /* r1:r0 = LO(bezier_A) * MI(f)*/
-        " add %9,r0" "\n\t"
-        " adc %2,r1" "\n\t"
-        " adc %3,%0" "\n\t"
-        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += LO(bezier_A) * MI(f)*/
-        " mul %11,%6" "\n\t"             /* r1:r0 = MI(bezier_A) * MI(f)*/
-        " add %2,r0" "\n\t"
-        " adc %3,r1" "\n\t"
-        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += MI(bezier_A) * MI(f) << 8*/
-        " mul %1,%6" "\n\t"              /* r1:r0 = HI(bezier_A) * LO(f)*/
-        " add %3,r0" "\n\t"
-        " adc %4,r1" "\n\t"              /* %4:%3:%2:%9 += HI(bezier_A) * LO(f) << 16*/
-        "2:" "\n\t"
+        A("lds %10, bezier_A")      /* %10 = LO(bezier_A)*/
+        A("mul %10,%5")             /* r1:r0 = LO(bezier_A) * LO(f)*/
+        A("add %9,r1")
+        A("adc %2,%0")
+        A("adc %3,%0")
+        A("adc %4,%0")              /* %4:%3:%2:%9 += HI(LO(bezier_A) * LO(f))*/
+        A("lds %11, bezier_A+1")    /* %11 = MI(bezier_A)*/
+        A("mul %11,%5")             /* r1:r0 = MI(bezier_A) * LO(f)*/
+        A("add %9,r0")
+        A("adc %2,r1")
+        A("adc %3,%0")
+        A("adc %4,%0")              /* %4:%3:%2:%9 += MI(bezier_A) * LO(f)*/
+        A("lds %1, bezier_A+2")     /* %1 = HI(bezier_A)*/
+        A("mul %1,%5")              /* r1:r0 = MI(bezier_A) * LO(f)*/
+        A("add %2,r0")
+        A("adc %3,r1")
+        A("adc %4,%0")              /* %4:%3:%2:%9 += HI(bezier_A) * LO(f) << 8*/
+        A("mul %10,%6")             /* r1:r0 = LO(bezier_A) * MI(f)*/
+        A("add %9,r0")
+        A("adc %2,r1")
+        A("adc %3,%0")
+        A("adc %4,%0")              /* %4:%3:%2:%9 += LO(bezier_A) * MI(f)*/
+        A("mul %11,%6")             /* r1:r0 = MI(bezier_A) * MI(f)*/
+        A("add %2,r0")
+        A("adc %3,r1")
+        A("adc %4,%0")              /* %4:%3:%2:%9 += MI(bezier_A) * MI(f) << 8*/
+        A("mul %1,%6")              /* r1:r0 = HI(bezier_A) * LO(f)*/
+        A("add %3,r0")
+        A("adc %4,r1")              /* %4:%3:%2:%9 += HI(bezier_A) * LO(f) << 16*/
+        L("2")
         " clr __zero_reg__"              /* C runtime expects r1 = __zero_reg__ = 0 */
         : "+r"(r0),
           "+r"(r1),
@@ -1071,20 +1071,20 @@ void Stepper::set_directions() {
         register int32_t C = bezier_C;
 
          __asm__ __volatile__(
-          ".syntax unified"                   "\n\t"  // is to prevent CM0,CM1 non-unified syntax
-          " lsrs  %[ahi],%[alo],#1"           "\n\t"  // a  = F << 31      1 cycles
-          " lsls  %[alo],%[alo],#31"          "\n\t"  //                   1 cycles
-          " umull %[flo],%[fhi],%[fhi],%[t]"  "\n\t"  // f *= t            5 cycles [fhi:flo=64bits]
-          " umull %[flo],%[fhi],%[fhi],%[t]"  "\n\t"  // f>>=32; f*=t      5 cycles [fhi:flo=64bits]
-          " lsrs  %[flo],%[fhi],#1"           "\n\t"  //                   1 cycles [31bits]
-          " smlal %[alo],%[ahi],%[flo],%[C]"  "\n\t"  // a+=(f>>33)*C;     5 cycles
-          " umull %[flo],%[fhi],%[fhi],%[t]"  "\n\t"  // f>>=32; f*=t      5 cycles [fhi:flo=64bits]
-          " lsrs  %[flo],%[fhi],#1"           "\n\t"  //                   1 cycles [31bits]
-          " smlal %[alo],%[ahi],%[flo],%[B]"  "\n\t"  // a+=(f>>33)*B;     5 cycles
-          " umull %[flo],%[fhi],%[fhi],%[t]"  "\n\t"  // f>>=32; f*=t      5 cycles [fhi:flo=64bits]
-          " lsrs  %[flo],%[fhi],#1"           "\n\t"  // f>>=33;           1 cycles [31bits]
-          " smlal %[alo],%[ahi],%[flo],%[A]"  "\n\t"  // a+=(f>>33)*A;     5 cycles
-          " lsrs  %[alo],%[ahi],#6"           "\n\t"  // a>>=38            1 cycles
+          ".syntax unified" "\n\t"              // is to prevent CM0,CM1 non-unified syntax
+          A("lsrs  %[ahi],%[alo],#1")           // a  = F << 31      1 cycles
+          A("lsls  %[alo],%[alo],#31")          //                   1 cycles
+          A("umull %[flo],%[fhi],%[fhi],%[t]")  // f *= t            5 cycles [fhi:flo=64bits]
+          A("umull %[flo],%[fhi],%[fhi],%[t]")  // f>>=32; f*=t      5 cycles [fhi:flo=64bits]
+          A("lsrs  %[flo],%[fhi],#1")           //                   1 cycles [31bits]
+          A("smlal %[alo],%[ahi],%[flo],%[C]")  // a+=(f>>33)*C;     5 cycles
+          A("umull %[flo],%[fhi],%[fhi],%[t]")  // f>>=32; f*=t      5 cycles [fhi:flo=64bits]
+          A("lsrs  %[flo],%[fhi],#1")           //                   1 cycles [31bits]
+          A("smlal %[alo],%[ahi],%[flo],%[B]")  // a+=(f>>33)*B;     5 cycles
+          A("umull %[flo],%[fhi],%[fhi],%[t]")  // f>>=32; f*=t      5 cycles [fhi:flo=64bits]
+          A("lsrs  %[flo],%[fhi],#1")           // f>>=33;           1 cycles [31bits]
+          A("smlal %[alo],%[ahi],%[flo],%[A]")  // a+=(f>>33)*A;     5 cycles
+          A("lsrs  %[alo],%[ahi],#6")           // a>>=38            1 cycles
           : [alo]"+r"( alo ) ,
             [flo]"+r"( flo ) ,
             [fhi]"+r"( fhi ) ,

commit af1950a63e4049c6f870fffcc12bf6e0f15dddac
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 3 17:45:13 2018 -0500

    Improve sync of stepper positions

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index ec547c5980..4e6747a124 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1217,6 +1217,16 @@ void Stepper::isr() {
     // Anything in the buffer?
     if ((current_block = planner.get_current_block())) {
 
+      // Sync block? Sync the stepper counts and return
+      while (TEST(current_block->flag, BLOCK_BIT_SYNC_POSITION)) {
+        _set_position(
+          current_block->steps[A_AXIS], current_block->steps[B_AXIS],
+          current_block->steps[C_AXIS], current_block->steps[E_AXIS]
+        );
+        planner.discard_current_block();
+        if (!(current_block = planner.get_current_block())) return;
+      }
+
       // Initialize the trapezoid generator from the current block.
       static int8_t last_extruder = -1;
 
@@ -1976,12 +1986,7 @@ void Stepper::synchronize() { while (planner.has_blocks_queued() || cleaning_buf
  * This allows get_axis_position_mm to correctly
  * derive the current XYZ position later on.
  */
-void Stepper::set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
-
-  synchronize(); // Bad to set stepper counts in the middle of a move
-
-  CRITICAL_SECTION_START;
-
+void Stepper::_set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
   #if CORE_IS_XY
     // corexy positioning
     // these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html
@@ -2004,21 +2009,7 @@ void Stepper::set_position(const int32_t &a, const int32_t &b, const int32_t &c,
     count_position[Y_AXIS] = b;
     count_position[Z_AXIS] = c;
   #endif
-
-  count_position[E_AXIS] = e;
-  CRITICAL_SECTION_END;
-}
-
-void Stepper::set_position(const AxisEnum &axis, const int32_t &v) {
-  CRITICAL_SECTION_START;
-  count_position[axis] = v;
-  CRITICAL_SECTION_END;
-}
-
-void Stepper::set_e_position(const int32_t &e) {
-  CRITICAL_SECTION_START;
   count_position[E_AXIS] = e;
-  CRITICAL_SECTION_END;
 }
 
 /**

commit 0c23792344a5134dc00446c192456bf62094c346
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 3 20:13:01 2018 -0500

    Apply int32_t to stepper

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 04c6c270f5..ec547c5980 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -109,10 +109,10 @@ int16_t Stepper::cleaning_buffer_counter = 0;
   bool Stepper::locked_z_motor = false, Stepper::locked_z2_motor = false;
 #endif
 
-long Stepper::counter_X = 0,
-     Stepper::counter_Y = 0,
-     Stepper::counter_Z = 0,
-     Stepper::counter_E = 0;
+int32_t Stepper::counter_X = 0,
+        Stepper::counter_Y = 0,
+        Stepper::counter_Z = 0,
+        Stepper::counter_E = 0;
 
 volatile uint32_t Stepper::step_events_completed = 0; // The number of step events executed in the current block
 
@@ -159,7 +159,7 @@ volatile int32_t Stepper::count_position[NUM_AXIS] = { 0 };
 volatile signed char Stepper::count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
 
 #if ENABLED(MIXING_EXTRUDER)
-  long Stepper::counter_m[MIXING_STEPPERS];
+  int32_t Stepper::counter_m[MIXING_STEPPERS];
 #endif
 
 uint8_t Stepper::step_loops, Stepper::step_loops_nominal;
@@ -169,7 +169,7 @@ hal_timer_t Stepper::OCR1A_nominal;
   hal_timer_t Stepper::acc_step_rate; // needed for deceleration start point
 #endif
 
-volatile long Stepper::endstops_trigsteps[XYZ];
+volatile int32_t Stepper::endstops_trigsteps[XYZ];
 
 #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
   #define LOCKED_X_MOTOR  locked_x_motor
@@ -1976,7 +1976,7 @@ void Stepper::synchronize() { while (planner.has_blocks_queued() || cleaning_buf
  * This allows get_axis_position_mm to correctly
  * derive the current XYZ position later on.
  */
-void Stepper::set_position(const long &a, const long &b, const long &c, const long &e) {
+void Stepper::set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
 
   synchronize(); // Bad to set stepper counts in the middle of a move
 
@@ -2009,13 +2009,13 @@ void Stepper::set_position(const long &a, const long &b, const long &c, const lo
   CRITICAL_SECTION_END;
 }
 
-void Stepper::set_position(const AxisEnum &axis, const long &v) {
+void Stepper::set_position(const AxisEnum &axis, const int32_t &v) {
   CRITICAL_SECTION_START;
   count_position[axis] = v;
   CRITICAL_SECTION_END;
 }
 
-void Stepper::set_e_position(const long &e) {
+void Stepper::set_e_position(const int32_t &e) {
   CRITICAL_SECTION_START;
   count_position[E_AXIS] = e;
   CRITICAL_SECTION_END;
@@ -2024,9 +2024,9 @@ void Stepper::set_e_position(const long &e) {
 /**
  * Get a stepper's position in steps.
  */
-long Stepper::position(const AxisEnum axis) {
+int32_t Stepper::position(const AxisEnum axis) {
   CRITICAL_SECTION_START;
-  const long count_pos = count_position[axis];
+  const int32_t count_pos = count_position[axis];
   CRITICAL_SECTION_END;
   return count_pos;
 }
@@ -2095,9 +2095,9 @@ void Stepper::endstop_triggered(const AxisEnum axis) {
 
 void Stepper::report_positions() {
   CRITICAL_SECTION_START;
-  const long xpos = count_position[X_AXIS],
-             ypos = count_position[Y_AXIS],
-             zpos = count_position[Z_AXIS];
+  const int32_t xpos = count_position[X_AXIS],
+                ypos = count_position[Y_AXIS],
+                zpos = count_position[Z_AXIS];
   CRITICAL_SECTION_END;
 
   #if CORE_IS_XY || CORE_IS_XZ || IS_DELTA || IS_SCARA

commit 0c428a66d92ab3db49c76cfedde5b239db16195d
Author: Eduardo José Tagle <ejtagle@hotmail.com>
Date:   Tue Apr 24 00:05:07 2018 -0300

    Proper AVR preemptive interrupt handling (#10496)
    
    Also simplify logic on all ARM-based interrupts. Now, it is REQUIRED to properly configure interrupt priority. USART should have highest priority, followed by Stepper, and then all others.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index f6f28fe4bd..04c6c270f5 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1144,11 +1144,14 @@ void Stepper::set_directions() {
 
 HAL_STEP_TIMER_ISR {
   HAL_timer_isr_prologue(STEP_TIMER_NUM);
+
   #if ENABLED(LIN_ADVANCE)
     Stepper::advance_isr_scheduler();
   #else
     Stepper::isr();
   #endif
+
+  HAL_timer_isr_epilogue(STEP_TIMER_NUM);
 }
 
 void Stepper::isr() {
@@ -1156,15 +1159,6 @@ void Stepper::isr() {
   #define ENDSTOP_NOMINAL_OCR_VAL 1500 * HAL_TICKS_PER_US // Check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
   #define OCR_VAL_TOLERANCE        500 * HAL_TICKS_PER_US // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
 
-  #if DISABLED(LIN_ADVANCE)
-    // Disable Timer0 ISRs and enable global ISR again to capture UART events (incoming chars)
-    DISABLE_TEMPERATURE_INTERRUPT(); // Temperature ISR
-    DISABLE_STEPPER_DRIVER_INTERRUPT();
-    #ifndef CPU_32_BIT
-      sei();
-    #endif
-  #endif
-
   hal_timer_t ocr_val;
   static uint32_t step_remaining = 0;  // SPLIT function always runs.  This allows 16 bit timers to be
                                        // used to generate the stepper ISR.
@@ -1191,7 +1185,6 @@ void Stepper::isr() {
 
     #if DISABLED(LIN_ADVANCE)
       HAL_timer_restrain(STEP_TIMER_NUM, STEP_TIMER_MIN_INTERVAL * HAL_TICKS_PER_US);
-      HAL_ENABLE_ISRs();
     #endif
 
     return;
@@ -1215,7 +1208,6 @@ void Stepper::isr() {
     }
     current_block = NULL;                       // Prep to get a new block after cleaning
     _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 10000);  // Run at max speed - 10 KHz
-    HAL_ENABLE_ISRs();
     return;
   }
 
@@ -1291,7 +1283,6 @@ void Stepper::isr() {
         if (current_block->steps[Z_AXIS] > 0) {
           enable_Z();
           _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 1000); // Run at slow speed - 1 KHz
-          HAL_ENABLE_ISRs();
           return;
         }
       #endif
@@ -1299,7 +1290,6 @@ void Stepper::isr() {
     else {
       // If no more queued moves, postpone next check for 1mS
       _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 1000); // Run at slow speed - 1 KHz
-      HAL_ENABLE_ISRs();
       return;
     }
   }
@@ -1631,9 +1621,6 @@ void Stepper::isr() {
     current_block = NULL;
     planner.discard_current_block();
   }
-  #if DISABLED(LIN_ADVANCE)
-    HAL_ENABLE_ISRs();
-  #endif
 }
 
 #if ENABLED(LIN_ADVANCE)
@@ -1755,10 +1742,6 @@ void Stepper::isr() {
   }
 
   void Stepper::advance_isr_scheduler() {
-    // Disable Timer0 ISRs and enable global ISR again to capture UART events (incoming chars)
-    DISABLE_TEMPERATURE_INTERRUPT(); // Temperature ISR
-    DISABLE_STEPPER_DRIVER_INTERRUPT();
-    sei();
 
     // Run main stepping ISR if flagged
     if (!nextMainISR) isr();
@@ -1787,9 +1770,6 @@ void Stepper::isr() {
 
     // Make sure stepper ISR doesn't monopolize the CPU
     HAL_timer_restrain(STEP_TIMER_NUM, STEP_TIMER_MIN_INTERVAL * HAL_TICKS_PER_US);
-
-    // Restore original ISR settings
-    HAL_ENABLE_ISRs();
   }
 
 #endif // LIN_ADVANCE

commit 36b97bde9f92b6ebf899f5240cec62ca8abdcd94
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 13 22:04:53 2018 -0500

    clear_block_buffer, kill_current_block in quick_stop

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 7be9c9ead2..f6f28fe4bd 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -2083,10 +2083,11 @@ void Stepper::finish_and_disable() {
 }
 
 void Stepper::quick_stop() {
-  cleaning_buffer_counter = 5000;
   DISABLE_STEPPER_DRIVER_INTERRUPT();
-  while (planner.has_blocks_queued()) planner.discard_current_block();
+  kill_current_block();
   current_block = NULL;
+  cleaning_buffer_counter = 5000;
+  planner.clear_block_buffer();
   ENABLE_STEPPER_DRIVER_INTERRUPT();
   #if ENABLED(ULTRA_LCD)
     planner.clear_block_buffer_runtime();

commit 57a899a412b0d45c159423925c1f63164dcd9308
Author: Eduardo José Tagle <ejtagle@hotmail.com>
Date:   Wed Apr 11 20:13:42 2018 -0300

    [2.0.x] 6th-order jerk-controlled motion planning in real-time for AVR (#10373)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 2b0974efa5..7be9c9ead2 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -117,11 +117,14 @@ long Stepper::counter_X = 0,
 volatile uint32_t Stepper::step_events_completed = 0; // The number of step events executed in the current block
 
 #if ENABLED(BEZIER_JERK_CONTROL)
-  int32_t Stepper::bezier_A,        // A coefficient in Bézier speed curve
-          Stepper::bezier_B,        // B coefficient in Bézier speed curve
-          Stepper::bezier_C,        // C coefficient in Bézier speed curve
-          Stepper::bezier_F;        // F coefficient in Bézier speed curve
-  uint32_t Stepper::bezier_AV;      // AV coefficient in Bézier speed curve
+  int32_t __attribute__((used)) Stepper::bezier_A __asm__("bezier_A");    // A coefficient in Bézier speed curve with alias for assembler
+  int32_t __attribute__((used)) Stepper::bezier_B __asm__("bezier_B");    // B coefficient in Bézier speed curve with alias for assembler
+  int32_t __attribute__((used)) Stepper::bezier_C __asm__("bezier_C");    // C coefficient in Bézier speed curve with alias for assembler
+  uint32_t __attribute__((used)) Stepper::bezier_F __asm__("bezier_F");   // F coefficient in Bézier speed curve with alias for assembler
+  uint32_t __attribute__((used)) Stepper::bezier_AV __asm__("bezier_AV"); // AV coefficient in Bézier speed curve with alias for assembler
+  #ifdef __AVR__
+    bool __attribute__((used)) Stepper::A_negative __asm__("A_negative");   // If A coefficient was negative
+  #endif
   bool Stepper::bezier_2nd_half;    // =false If Bézier curve has been initialized or not
 #endif
 
@@ -391,130 +394,735 @@ void Stepper::set_directions() {
    *
    *  Note the abbreviations we use in the following formulae are between []s
    *
-   *  At the start of each trapezoid, we calculate the coefficients A,B,C,F and Advance [AV], as follows:
+   *  For Any 32bit CPU:
+   *
+   *    At the start of each trapezoid, we calculate the coefficients A,B,C,F and Advance [AV], as follows:
+   *
+   *      A =  6*128*(VF - VI) =  768*(VF - VI)
+   *      B = 15*128*(VI - VF) = 1920*(VI - VF)
+   *      C = 10*128*(VF - VI) = 1280*(VF - VI)
+   *      F =    128*VI        =  128*VI
+   *     AV = (1<<32)/TS      ~= 0xFFFFFFFF / TS (To use ARM UDIV, that is 32 bits) (this is computed at the planner, to offload expensive calculations from the ISR)
+   *
+   *   And for each point, we will evaluate the curve with the following sequence:
+   *
+   *      void lsrs(uint32_t& d, uint32_t s, int cnt) {
+   *        d = s >> cnt;
+   *      }
+   *      void lsls(uint32_t& d, uint32_t s, int cnt) {
+   *        d = s << cnt;
+   *      }
+   *      void lsrs(int32_t& d, uint32_t s, int cnt) {
+   *        d = uint32_t(s) >> cnt;
+   *      }
+   *      void lsls(int32_t& d, uint32_t s, int cnt) {
+   *        d = uint32_t(s) << cnt;
+   *      }
+   *      void umull(uint32_t& rlo, uint32_t& rhi, uint32_t op1, uint32_t op2) {
+   *        uint64_t res = uint64_t(op1) * op2;
+   *        rlo = uint32_t(res & 0xFFFFFFFF);
+   *        rhi = uint32_t((res >> 32) & 0xFFFFFFFF);
+   *      }
+   *      void smlal(int32_t& rlo, int32_t& rhi, int32_t op1, int32_t op2) {
+   *        int64_t mul = int64_t(op1) * op2;
+   *        int64_t s = int64_t(uint32_t(rlo) | ((uint64_t(uint32_t(rhi)) << 32U)));
+   *        mul += s;
+   *        rlo = int32_t(mul & 0xFFFFFFFF);
+   *        rhi = int32_t((mul >> 32) & 0xFFFFFFFF);
+   *      }
+   *      int32_t _eval_bezier_curve_arm(uint32_t curr_step) {
+   *        register uint32_t flo = 0;
+   *        register uint32_t fhi = bezier_AV * curr_step;
+   *        register uint32_t t = fhi;
+   *        register int32_t alo = bezier_F;
+   *        register int32_t ahi = 0;
+   *        register int32_t A = bezier_A;
+   *        register int32_t B = bezier_B;
+   *        register int32_t C = bezier_C;
+   *
+   *        lsrs(ahi, alo, 1);          // a  = F << 31
+   *        lsls(alo, alo, 31);         //
+   *        umull(flo, fhi, fhi, t);    // f *= t
+   *        umull(flo, fhi, fhi, t);    // f>>=32; f*=t
+   *        lsrs(flo, fhi, 1);          //
+   *        smlal(alo, ahi, flo, C);    // a+=(f>>33)*C
+   *        umull(flo, fhi, fhi, t);    // f>>=32; f*=t
+   *        lsrs(flo, fhi, 1);          //
+   *        smlal(alo, ahi, flo, B);    // a+=(f>>33)*B
+   *        umull(flo, fhi, fhi, t);    // f>>=32; f*=t
+   *        lsrs(flo, fhi, 1);          // f>>=33;
+   *        smlal(alo, ahi, flo, A);    // a+=(f>>33)*A;
+   *        lsrs(alo, ahi, 6);          // a>>=38
+   *
+   *        return alo;
+   *      }
+   *
+   *    This will be rewritten in ARM assembly to get peak performance and will take 43 cycles to execute
    *
-   *   A =  6*128*(VF - VI) =  768*(VF - VI)
-   *   B = 15*128*(VI - VF) = 1920*(VI - VF)
-   *   C = 10*128*(VF - VI) = 1280*(VF - VI)
-   *   F =    128*VI        =  128*VI
-   *  AV = (1<<32)/TS      ~= 0xFFFFFFFF / TS (To use ARM UDIV, that is 32 bits)
+   *  For AVR, we scale precision of coefficients to make it possible to evaluate the Bézier curve in
+   *    realtime: Let's reduce precision as much as possible. After some experimentation we found that:
    *
-   *  And for each point, we will evaluate the curve with the following sequence:
+   *    Assume t and AV with 24 bits is enough
+   *       A =  6*(VF - VI)
+   *       B = 15*(VI - VF)
+   *       C = 10*(VF - VI)
+   *       F =     VI
+   *      AV = (1<<24)/TS   (this is computed at the planner, to offload expensive calculations from the ISR)
    *
-   *    uint32_t t = bezier_AV * curr_step;               // t: Range 0 - 1^32 = 32 bits
-   *    uint64_t f = t;
-   *    f *= t;                                           // Range 32*2 = 64 bits (unsigned)
-   *    f >>= 32;                                         // Range 32 bits  (unsigned)
-   *    f *= t;                                           // Range 32*2 = 64 bits  (unsigned)
-   *    f >>= 32;                                         // Range 32 bits : f = t^3  (unsigned)
-   *    int64_t acc = (int64_t) bezier_F << 31;           // Range 63 bits (signed)
-   *    acc += ((uint32_t) f >> 1) * (int64_t) bezier_C;  // Range 29bits + 31 = 60bits (plus sign)
-   *    f *= t;                                           // Range 32*2 = 64 bits
-   *    f >>= 32;                                         // Range 32 bits : f = t^3  (unsigned)
-   *    acc += ((uint32_t) f >> 1) * (int64_t) bezier_B;  // Range 29bits + 31 = 60bits (plus sign)
-   *    f *= t;                                           // Range 32*2 = 64 bits
-   *    f >>= 32;                                         // Range 32 bits : f = t^3  (unsigned)
-   *    acc += ((uint32_t) f >> 1) * (int64_t) bezier_A;  // Range 28bits + 31 = 59bits (plus sign)
-   *    acc >>= (31 + 7);                                 // Range 24bits (plus sign)
+   *     Instead of storing sign for each coefficient, we will store its absolute value,
+   *    and flag the sign of the A coefficient, so we can save to store the sign bit.
+   *     It always holds that sign(A) = - sign(B) = sign(C)
    *
-   * This can be translated to the following ARM assembly sequence:
+   *     So, the resulting range of the coefficients are:
    *
-   * At start:
-   *  fhi = AV, flo = CS, alo = F
+   *       t: unsigned (0 <= t < 1) |range 0 to 0xFFFFFF unsigned
+   *       A:   signed Q24 , range = 250000 * 6 = 1500000 = 0x16E360 | 21 bits
+   *       B:   signed Q24 , range = 250000 *15 = 3750000 = 0x393870 | 22 bits
+   *       C:   signed Q24 , range = 250000 *10 = 2500000 = 0x1312D0 | 21 bits
+   *       F:   signed Q24 , range = 250000     =  250000 = 0x0ED090 | 20 bits
+   *
+   *    And for each curve, we estimate its coefficients with:
+   *
+   *      void _calc_bezier_curve_coeffs(int32_t v0, int32_t v1, uint32_t av) {
+   *       // Calculate the Bézier coefficients
+   *       if (v1 < v0) {
+   *         A_negative = true;
+   *         bezier_A = 6 * (v0 - v1);
+   *         bezier_B = 15 * (v0 - v1);
+   *         bezier_C = 10 * (v0 - v1);
+   *       }
+   *       else {
+   *         A_negative = false;
+   *         bezier_A = 6 * (v1 - v0);
+   *         bezier_B = 15 * (v1 - v0);
+   *         bezier_C = 10 * (v1 - v0);
+   *       }
+   *       bezier_F = v0;
+   *      }
+   *
+   *    And for each point, we will evaluate the curve with the following sequence:
+   *
+   *      // unsigned multiplication of 24 bits x 24bits, return upper 16 bits
+   *      void umul24x24to16hi(uint16_t& r, uint24_t op1, uint24_t op2) {
+   *        r = (uint64_t(op1) * op2) >> 8;
+   *      }
+   *      // unsigned multiplication of 16 bits x 16bits, return upper 16 bits
+   *      void umul16x16to16hi(uint16_t& r, uint16_t op1, uint16_t op2) {
+   *        r = (uint32_t(op1) * op2) >> 16;
+   *      }
+   *      // unsigned multiplication of 16 bits x 24bits, return upper 24 bits
+   *      void umul16x24to24hi(uint24_t& r, uint16_t op1, uint24_t op2) {
+   *        r = uint24_t((uint64_t(op1) * op2) >> 16);
+   *      }
+   *
+   *      int32_t _eval_bezier_curve(uint32_t curr_step) {
+   *        // To save computing, the first step is always the initial speed
+   *        if (!curr_step)
+   *          return bezier_F;
+   *
+   *        uint16_t t;
+   *        umul24x24to16hi(t, bezier_AV, curr_step);   // t: Range 0 - 1^16 = 16 bits
+   *        uint16_t f = t;
+   *        umul16x16to16hi(f, f, t);           // Range 16 bits (unsigned)
+   *        umul16x16to16hi(f, f, t);           // Range 16 bits : f = t^3  (unsigned)
+   *        uint24_t acc = bezier_F;          // Range 20 bits (unsigned)
+   *        if (A_negative) {
+   *          uint24_t v;
+   *          umul16x24to24hi(v, f, bezier_C);    // Range 21bits
+   *          acc -= v;
+   *          umul16x16to16hi(f, f, t);         // Range 16 bits : f = t^4  (unsigned)
+   *          umul16x24to24hi(v, f, bezier_B);    // Range 22bits
+   *          acc += v;
+   *          umul16x16to16hi(f, f, t);         // Range 16 bits : f = t^5  (unsigned)
+   *          umul16x24to24hi(v, f, bezier_A);    // Range 21bits + 15 = 36bits (plus sign)
+   *          acc -= v;
+   *        }
+   *        else {
+   *          uint24_t v;
+   *          umul16x24to24hi(v, f, bezier_C);    // Range 21bits
+   *          acc += v;
+   *          umul16x16to16hi(f, f, t);       // Range 16 bits : f = t^4  (unsigned)
+   *          umul16x24to24hi(v, f, bezier_B);    // Range 22bits
+   *          acc -= v;
+   *          umul16x16to16hi(f, f, t);               // Range 16 bits : f = t^5  (unsigned)
+   *          umul16x24to24hi(v, f, bezier_A);    // Range 21bits + 15 = 36bits (plus sign)
+   *          acc += v;
+   *        }
+   *        return acc;
+   *      }
+   *    Those functions will be translated into assembler to get peak performance. coefficient calculations takes 70 cycles,
+   *    Bezier point evaluation takes 150 cycles
    *
-   *  muls  fhi,flo               | f = AV * CS       1 cycles
-   *  mov   t,fhi                 | t = AV * CS       1 cycles
-   *  lsrs  ahi,alo,#1            | a  = F << 31      1 cycles
-   *  lsls  alo,alo,#31           |                   1 cycles
-   *  umull flo,fhi,fhi,t         | f *= t            5 cycles [fhi:flo=64bits
-   *  umull flo,fhi,fhi,t         | f>>=32; f*=t      5 cycles [fhi:flo=64bits
-   *  lsrs  flo,fhi,#1            |                   1 cycles [31bits
-   *  smlal alo,ahi,flo,C         | a+=(f>>33)*C;     5 cycles
-   *  umull flo,fhi,fhi,t         | f>>=32; f*=t      5 cycles [fhi:flo=64bits
-   *  lsrs  flo,fhi,#1            |                   1 cycles [31bits
-   *  smlal alo,ahi,flo,B         | a+=(f>>33)*B;     5 cycles
-   *  umull flo,fhi,fhi,t         | f>>=32; f*=t      5 cycles [fhi:flo=64bits
-   *  lsrs  flo,fhi,#1            | f>>=33;           1 cycles [31bits
-   *  smlal alo,ahi,flo,A         | a+=(f>>33)*A;     5 cycles
-   *  lsrs  alo,ahi,#6            | a>>=38            1 cycles
-   *  43 cycles total
    */
 
-  FORCE_INLINE void Stepper::_calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t interval) {
-    // Calculate the Bézier coefficients
-    bezier_A =  768 * (v1 - v0);
-    bezier_B = 1920 * (v0 - v1);
-    bezier_C = 1280 * (v1 - v0);
-    bezier_F =  128 * v0;
-    bezier_AV = 0xFFFFFFFF / interval;
-  }
+  #ifdef __AVR__
 
-  FORCE_INLINE int32_t Stepper::_eval_bezier_curve(const uint32_t curr_step) {
-    #if defined(__ARM__) || defined(__thumb__)
-
-      // For ARM CORTEX M3/M4 CPUs, we have the optimized assembler version, that takes 43 cycles to execute
-      register uint32_t flo = 0;
-      register uint32_t fhi = bezier_AV * curr_step;
-      register uint32_t t = fhi;
-      register int32_t alo = bezier_F;
-      register int32_t ahi = 0;
-      register int32_t A = bezier_A;
-      register int32_t B = bezier_B;
-      register int32_t C = bezier_C;
-
-       __asm__ __volatile__(
-        ".syntax unified"                   "\n\t"  // is to prevent CM0,CM1 non-unified syntax
-        " lsrs  %[ahi],%[alo],#1"           "\n\t"  // a  = F << 31      1 cycles
-        " lsls  %[alo],%[alo],#31"          "\n\t"  //                   1 cycles
-        " umull %[flo],%[fhi],%[fhi],%[t]"  "\n\t"  // f *= t            5 cycles [fhi:flo=64bits]
-        " umull %[flo],%[fhi],%[fhi],%[t]"  "\n\t"  // f>>=32; f*=t      5 cycles [fhi:flo=64bits]
-        " lsrs  %[flo],%[fhi],#1"           "\n\t"  //                   1 cycles [31bits]
-        " smlal %[alo],%[ahi],%[flo],%[C]"  "\n\t"  // a+=(f>>33)*C;     5 cycles
-        " umull %[flo],%[fhi],%[fhi],%[t]"  "\n\t"  // f>>=32; f*=t      5 cycles [fhi:flo=64bits]
-        " lsrs  %[flo],%[fhi],#1"           "\n\t"  //                   1 cycles [31bits]
-        " smlal %[alo],%[ahi],%[flo],%[B]"  "\n\t"  // a+=(f>>33)*B;     5 cycles
-        " umull %[flo],%[fhi],%[fhi],%[t]"  "\n\t"  // f>>=32; f*=t      5 cycles [fhi:flo=64bits]
-        " lsrs  %[flo],%[fhi],#1"           "\n\t"  // f>>=33;           1 cycles [31bits]
-        " smlal %[alo],%[ahi],%[flo],%[A]"  "\n\t"  // a+=(f>>33)*A;     5 cycles
-        " lsrs  %[alo],%[ahi],#6"           "\n\t"  // a>>=38            1 cycles
-        : [alo]"+r"( alo ) ,
-          [flo]"+r"( flo ) ,
-          [fhi]"+r"( fhi ) ,
-          [ahi]"+r"( ahi ) ,
-          [A]"+r"( A ) ,  // <== Note: Even if A, B, C, and t registers are INPUT ONLY
-          [B]"+r"( B ) ,  //  GCC does bad optimizations on the code if we list them as
-          [C]"+r"( C ) ,  //  such, breaking this function. So, to avoid that problem,
-          [t]"+r"( t )    //  we list all registers as input-outputs.
+    // For AVR we use assembly to maximize speed
+    void Stepper::_calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t av) {
+
+      // Store advance
+      bezier_AV = av;
+
+      // Calculate the rest of the coefficients
+      register uint8_t r2 = v0 & 0xFF;
+      register uint8_t r3 = (v0 >> 8) & 0xFF;
+      register uint8_t r12 = (v0 >> 16) & 0xFF;
+      register uint8_t r5 = v1 & 0xFF;
+      register uint8_t r6 = (v1 >> 8) & 0xFF;
+      register uint8_t r7 = (v1 >> 16) & 0xFF;
+      register uint8_t r4,r8,r9,r10,r11;
+
+      __asm__ __volatile__(
+        /* Calculate the Bézier coefficients */
+        /*  %10:%1:%0 = v0*/
+        /*  %5:%4:%3 = v1*/
+        /*  %7:%6:%10 = temporary*/
+        /*  %9 = val (must be high register!)*/
+        /*  %10 (must be high register!)*/
+
+        /* Store initial velocity*/
+        " sts bezier_F, %0" "\n\t"
+        " sts bezier_F+1, %1" "\n\t"
+        " sts bezier_F+2, %10" "\n\t"    /* bezier_F = %10:%1:%0 = v0 */
+
+        /* Get delta speed */
+        " ldi %2,-1" "\n\t"              /* %2 = 0xff, means A_negative = true */
+        " clr %8" "\n\t"                 /* %8 = 0 */
+        " sub %0,%3" "\n\t"
+        " sbc %1,%4" "\n\t"
+        " sbc %10,%5" "\n\t"             /*  v0 -= v1, C=1 if result is negative */
+        " brcc 1f" "\n\t"                /* branch if result is positive (C=0), that means v0 >= v1 */
+
+        /*  Result was negative, get the absolute value*/
+        " com %10" "\n\t"
+        " com %1" "\n\t"
+        " neg %0" "\n\t"
+        " sbc %1,%2" "\n\t"
+        " sbc %10,%2" "\n\t"             /* %10:%1:%0 +1  -> %10:%1:%0 = -(v0 - v1) = (v1 - v0) */
+        " clr %2" "\n\t"                 /* %2 = 0, means A_negative = false */
+
+        /*  Store negative flag*/
+        "1:" "\n\t"
+        " sts A_negative, %2" "\n\t"     /* Store negative flag */
+
+        /*  Compute coefficients A,B and C   [20 cycles worst case]*/
+        " ldi %9,6" "\n\t"               /* %9 = 6 */
+        " mul %0,%9" "\n\t"              /* r1:r0 = 6*LO(v0-v1) */
+        " sts bezier_A, r0" "\n\t"
+        " mov %6,r1" "\n\t"
+        " clr %7" "\n\t"                 /* %7:%6:r0 = 6*LO(v0-v1) */
+        " mul %1,%9" "\n\t"              /* r1:r0 = 6*MI(v0-v1) */
+        " add %6,r0" "\n\t"
+        " adc %7,r1" "\n\t"              /* %7:%6:?? += 6*MI(v0-v1) << 8 */
+        " mul %10,%9" "\n\t"             /* r1:r0 = 6*HI(v0-v1) */
+        " add %7,r0" "\n\t"              /* %7:%6:?? += 6*HI(v0-v1) << 16 */
+        " sts bezier_A+1, %6" "\n\t"
+        " sts bezier_A+2, %7" "\n\t"     /* bezier_A = %7:%6:?? = 6*(v0-v1) [35 cycles worst] */
+
+        " ldi %9,15" "\n\t"              /* %9 = 15 */
+        " mul %0,%9" "\n\t"              /* r1:r0 = 5*LO(v0-v1) */
+        " sts bezier_B, r0" "\n\t"
+        " mov %6,r1" "\n\t"
+        " clr %7" "\n\t"                 /* %7:%6:?? = 5*LO(v0-v1) */
+        " mul %1,%9" "\n\t"              /* r1:r0 = 5*MI(v0-v1) */
+        " add %6,r0" "\n\t"
+        " adc %7,r1" "\n\t"              /* %7:%6:?? += 5*MI(v0-v1) << 8 */
+        " mul %10,%9" "\n\t"             /* r1:r0 = 5*HI(v0-v1) */
+        " add %7,r0" "\n\t"              /* %7:%6:?? += 5*HI(v0-v1) << 16 */
+        " sts bezier_B+1, %6" "\n\t"
+        " sts bezier_B+2, %7" "\n\t"     /* bezier_B = %7:%6:?? = 5*(v0-v1) [50 cycles worst] */
+
+        " ldi %9,10" "\n\t"              /* %9 = 10 */
+        " mul %0,%9" "\n\t"              /* r1:r0 = 10*LO(v0-v1) */
+        " sts bezier_C, r0" "\n\t"
+        " mov %6,r1" "\n\t"
+        " clr %7" "\n\t"                 /* %7:%6:?? = 10*LO(v0-v1) */
+        " mul %1,%9" "\n\t"              /* r1:r0 = 10*MI(v0-v1) */
+        " add %6,r0" "\n\t"
+        " adc %7,r1" "\n\t"              /* %7:%6:?? += 10*MI(v0-v1) << 8 */
+        " mul %10,%9" "\n\t"             /* r1:r0 = 10*HI(v0-v1) */
+        " add %7,r0" "\n\t"              /* %7:%6:?? += 10*HI(v0-v1) << 16 */
+        " sts bezier_C+1, %6" "\n\t"
+        " sts bezier_C+2, %7"            /* bezier_C = %7:%6:?? = 10*(v0-v1) [65 cycles worst] */
+        : "+r" (r2),
+          "+d" (r3),
+          "=r" (r4),
+          "+r" (r5),
+          "+r" (r6),
+          "+r" (r7),
+          "=r" (r8),
+          "=r" (r9),
+          "=r" (r10),
+          "=d" (r11),
+          "+r" (r12)
         :
-        : "cc"
+        : "r0", "r1", "cc", "memory"
       );
-      return alo;
+    }
 
-    #else
+    FORCE_INLINE int32_t Stepper::_eval_bezier_curve(const uint32_t curr_step) {
+
+      // If dealing with the first step, save expensive computing and return the initial speed
+      if (!curr_step)
+        return bezier_F;
+
+      register uint8_t r0 = 0; /* Zero register */
+      register uint8_t r2 = (curr_step) & 0xFF;
+      register uint8_t r3 = (curr_step >> 8) & 0xFF;
+      register uint8_t r4 = (curr_step >> 16) & 0xFF;
+      register uint8_t r1,r5,r6,r7,r8,r9,r10,r11; /* Temporary registers */
+
+      __asm__ __volatile(
+        /* umul24x24to16hi(t, bezier_AV, curr_step);  t: Range 0 - 1^16 = 16 bits*/
+        " lds %9,bezier_AV" "\n\t"       /* %9 = LO(AV)*/
+        " mul %9,%2" "\n\t"              /* r1:r0 = LO(bezier_AV)*LO(curr_step)*/
+        " mov %7,r1" "\n\t"              /* %7 = LO(bezier_AV)*LO(curr_step) >> 8*/
+        " clr %8" "\n\t"                 /* %8:%7  = LO(bezier_AV)*LO(curr_step) >> 8*/
+        " lds %10,bezier_AV+1" "\n\t"    /* %10 = MI(AV)*/
+        " mul %10,%2" "\n\t"             /* r1:r0  = MI(bezier_AV)*LO(curr_step)*/
+        " add %7,r0" "\n\t"
+        " adc %8,r1" "\n\t"              /* %8:%7 += MI(bezier_AV)*LO(curr_step)*/
+        " lds r1,bezier_AV+2" "\n\t"     /* r11 = HI(AV)*/
+        " mul r1,%2" "\n\t"              /* r1:r0  = HI(bezier_AV)*LO(curr_step)*/
+        " add %8,r0" "\n\t"              /* %8:%7 += HI(bezier_AV)*LO(curr_step) << 8*/
+        " mul %9,%3" "\n\t"              /* r1:r0 =  LO(bezier_AV)*MI(curr_step)*/
+        " add %7,r0" "\n\t"
+        " adc %8,r1" "\n\t"              /* %8:%7 += LO(bezier_AV)*MI(curr_step)*/
+        " mul %10,%3" "\n\t"             /* r1:r0 =  MI(bezier_AV)*MI(curr_step)*/
+        " add %8,r0" "\n\t"              /* %8:%7 += LO(bezier_AV)*MI(curr_step) << 8*/
+        " mul %9,%4" "\n\t"              /* r1:r0 =  LO(bezier_AV)*HI(curr_step)*/
+        " add %8,r0" "\n\t"              /* %8:%7 += LO(bezier_AV)*HI(curr_step) << 8*/
+        /* %8:%7 = t*/
+
+        /* uint16_t f = t;*/
+        " mov %5,%7" "\n\t"              /* %6:%5 = f*/
+        " mov %6,%8" "\n\t"
+        /* %6:%5 = f*/
+
+        /* umul16x16to16hi(f, f, t); / Range 16 bits (unsigned) [17] */
+        " mul %5,%7" "\n\t"              /* r1:r0 = LO(f) * LO(t)*/
+        " mov %9,r1" "\n\t"              /* store MIL(LO(f) * LO(t)) in %9, we need it for rounding*/
+        " clr %10" "\n\t"                /* %10 = 0*/
+        " clr %11" "\n\t"                /* %11 = 0*/
+        " mul %5,%8" "\n\t"              /* r1:r0 = LO(f) * HI(t)*/
+        " add %9,r0" "\n\t"              /* %9 += LO(LO(f) * HI(t))*/
+        " adc %10,r1" "\n\t"             /* %10 = HI(LO(f) * HI(t))*/
+        " adc %11,%0" "\n\t"             /* %11 += carry*/
+        " mul %6,%7" "\n\t"              /* r1:r0 = HI(f) * LO(t)*/
+        " add %9,r0" "\n\t"              /* %9 += LO(HI(f) * LO(t))*/
+        " adc %10,r1" "\n\t"             /* %10 += HI(HI(f) * LO(t)) */
+        " adc %11,%0" "\n\t"             /* %11 += carry*/
+        " mul %6,%8" "\n\t"              /* r1:r0 = HI(f) * HI(t)*/
+        " add %10,r0" "\n\t"             /* %10 += LO(HI(f) * HI(t))*/
+        " adc %11,r1" "\n\t"             /* %11 += HI(HI(f) * HI(t))*/
+        " mov %5,%10" "\n\t"             /* %6:%5 = */
+        " mov %6,%11" "\n\t"             /* f = %10:%11*/
+
+        /* umul16x16to16hi(f, f, t); / Range 16 bits : f = t^3  (unsigned) [17]*/
+        " mul %5,%7" "\n\t"              /* r1:r0 = LO(f) * LO(t)*/
+        " mov %1,r1" "\n\t"              /* store MIL(LO(f) * LO(t)) in %1, we need it for rounding*/
+        " clr %10" "\n\t"                /* %10 = 0*/
+        " clr %11" "\n\t"                /* %11 = 0*/
+        " mul %5,%8" "\n\t"              /* r1:r0 = LO(f) * HI(t)*/
+        " add %1,r0" "\n\t"              /* %1 += LO(LO(f) * HI(t))*/
+        " adc %10,r1" "\n\t"             /* %10 = HI(LO(f) * HI(t))*/
+        " adc %11,%0" "\n\t"             /* %11 += carry*/
+        " mul %6,%7" "\n\t"              /* r1:r0 = HI(f) * LO(t)*/
+        " add %1,r0" "\n\t"              /* %1 += LO(HI(f) * LO(t))*/
+        " adc %10,r1" "\n\t"             /* %10 += HI(HI(f) * LO(t))*/
+        " adc %11,%0" "\n\t"             /* %11 += carry*/
+        " mul %6,%8" "\n\t"              /* r1:r0 = HI(f) * HI(t)*/
+        " add %10,r0" "\n\t"             /* %10 += LO(HI(f) * HI(t))*/
+        " adc %11,r1" "\n\t"             /* %11 += HI(HI(f) * HI(t))*/
+        " mov %5,%10" "\n\t"             /* %6:%5 =*/
+        " mov %6,%11" "\n\t"             /* f = %10:%11*/
+        /* [15 +17*2] = [49]*/
+
+        /* %4:%3:%2 will be acc from now on*/
+
+        /* uint24_t acc = bezier_F; / Range 20 bits (unsigned)*/
+        " clr %9" "\n\t"                 /* "decimal place we get for free"*/
+        " lds %2,bezier_F" "\n\t"
+        " lds %3,bezier_F+1" "\n\t"
+        " lds %4,bezier_F+2" "\n\t"      /* %4:%3:%2 = acc*/
+
+        /* if (A_negative) {*/
+        " lds r0,A_negative" "\n\t"
+        " or r0,%0" "\n\t"               /* Is flag signalling negative? */
+        " brne 3f" "\n\t"                /* If yes, Skip next instruction if A was negative*/
+        " rjmp 1f" "\n\t"                /* Otherwise, jump */
+
+        /* uint24_t v; */
+        /* umul16x24to24hi(v, f, bezier_C); / Range 21bits [29] */
+        /* acc -= v; */
+        "3:" "\n\t"
+        " lds %10, bezier_C" "\n\t"      /* %10 = LO(bezier_C)*/
+        " mul %10,%5" "\n\t"             /* r1:r0 = LO(bezier_C) * LO(f)*/
+        " sub %9,r1" "\n\t"
+        " sbc %2,%0" "\n\t"
+        " sbc %3,%0" "\n\t"
+        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= HI(LO(bezier_C) * LO(f))*/
+        " lds %11, bezier_C+1" "\n\t"    /* %11 = MI(bezier_C)*/
+        " mul %11,%5" "\n\t"             /* r1:r0 = MI(bezier_C) * LO(f)*/
+        " sub %9,r0" "\n\t"
+        " sbc %2,r1" "\n\t"
+        " sbc %3,%0" "\n\t"
+        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= MI(bezier_C) * LO(f)*/
+        " lds %1, bezier_C+2" "\n\t"     /* %1 = HI(bezier_C)*/
+        " mul %1,%5" "\n\t"              /* r1:r0 = MI(bezier_C) * LO(f)*/
+        " sub %2,r0" "\n\t"
+        " sbc %3,r1" "\n\t"
+        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= HI(bezier_C) * LO(f) << 8*/
+        " mul %10,%6" "\n\t"             /* r1:r0 = LO(bezier_C) * MI(f)*/
+        " sub %9,r0" "\n\t"
+        " sbc %2,r1" "\n\t"
+        " sbc %3,%0" "\n\t"
+        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= LO(bezier_C) * MI(f)*/
+        " mul %11,%6" "\n\t"             /* r1:r0 = MI(bezier_C) * MI(f)*/
+        " sub %2,r0" "\n\t"
+        " sbc %3,r1" "\n\t"
+        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= MI(bezier_C) * MI(f) << 8*/
+        " mul %1,%6" "\n\t"              /* r1:r0 = HI(bezier_C) * LO(f)*/
+        " sub %3,r0" "\n\t"
+        " sbc %4,r1" "\n\t"              /* %4:%3:%2:%9 -= HI(bezier_C) * LO(f) << 16*/
+
+        /* umul16x16to16hi(f, f, t); / Range 16 bits : f = t^3  (unsigned) [17]*/
+        " mul %5,%7" "\n\t"              /* r1:r0 = LO(f) * LO(t)*/
+        " mov %1,r1" "\n\t"              /* store MIL(LO(f) * LO(t)) in %1, we need it for rounding*/
+        " clr %10" "\n\t"                /* %10 = 0*/
+        " clr %11" "\n\t"                /* %11 = 0*/
+        " mul %5,%8" "\n\t"              /* r1:r0 = LO(f) * HI(t)*/
+        " add %1,r0" "\n\t"              /* %1 += LO(LO(f) * HI(t))*/
+        " adc %10,r1" "\n\t"             /* %10 = HI(LO(f) * HI(t))*/
+        " adc %11,%0" "\n\t"             /* %11 += carry*/
+        " mul %6,%7" "\n\t"              /* r1:r0 = HI(f) * LO(t)*/
+        " add %1,r0" "\n\t"              /* %1 += LO(HI(f) * LO(t))*/
+        " adc %10,r1" "\n\t"             /* %10 += HI(HI(f) * LO(t))*/
+        " adc %11,%0" "\n\t"             /* %11 += carry*/
+        " mul %6,%8" "\n\t"              /* r1:r0 = HI(f) * HI(t)*/
+        " add %10,r0" "\n\t"             /* %10 += LO(HI(f) * HI(t))*/
+        " adc %11,r1" "\n\t"             /* %11 += HI(HI(f) * HI(t))*/
+        " mov %5,%10" "\n\t"             /* %6:%5 =*/
+        " mov %6,%11" "\n\t"             /* f = %10:%11*/
+
+        /* umul16x24to24hi(v, f, bezier_B); / Range 22bits [29]*/
+        /* acc += v; */
+        " lds %10, bezier_B" "\n\t"      /* %10 = LO(bezier_B)*/
+        " mul %10,%5" "\n\t"             /* r1:r0 = LO(bezier_B) * LO(f)*/
+        " add %9,r1" "\n\t"
+        " adc %2,%0" "\n\t"
+        " adc %3,%0" "\n\t"
+        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += HI(LO(bezier_B) * LO(f))*/
+        " lds %11, bezier_B+1" "\n\t"    /* %11 = MI(bezier_B)*/
+        " mul %11,%5" "\n\t"             /* r1:r0 = MI(bezier_B) * LO(f)*/
+        " add %9,r0" "\n\t"
+        " adc %2,r1" "\n\t"
+        " adc %3,%0" "\n\t"
+        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += MI(bezier_B) * LO(f)*/
+        " lds %1, bezier_B+2" "\n\t"     /* %1 = HI(bezier_B)*/
+        " mul %1,%5" "\n\t"              /* r1:r0 = MI(bezier_B) * LO(f)*/
+        " add %2,r0" "\n\t"
+        " adc %3,r1" "\n\t"
+        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += HI(bezier_B) * LO(f) << 8*/
+        " mul %10,%6" "\n\t"             /* r1:r0 = LO(bezier_B) * MI(f)*/
+        " add %9,r0" "\n\t"
+        " adc %2,r1" "\n\t"
+        " adc %3,%0" "\n\t"
+        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += LO(bezier_B) * MI(f)*/
+        " mul %11,%6" "\n\t"             /* r1:r0 = MI(bezier_B) * MI(f)*/
+        " add %2,r0" "\n\t"
+        " adc %3,r1" "\n\t"
+        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += MI(bezier_B) * MI(f) << 8*/
+        " mul %1,%6" "\n\t"              /* r1:r0 = HI(bezier_B) * LO(f)*/
+        " add %3,r0" "\n\t"
+        " adc %4,r1" "\n\t"              /* %4:%3:%2:%9 += HI(bezier_B) * LO(f) << 16*/
+
+        /* umul16x16to16hi(f, f, t); / Range 16 bits : f = t^5  (unsigned) [17]*/
+        " mul %5,%7" "\n\t"              /* r1:r0 = LO(f) * LO(t)*/
+        " mov %1,r1" "\n\t"              /* store MIL(LO(f) * LO(t)) in %1, we need it for rounding*/
+        " clr %10" "\n\t"                /* %10 = 0*/
+        " clr %11" "\n\t"                /* %11 = 0*/
+        " mul %5,%8" "\n\t"              /* r1:r0 = LO(f) * HI(t)*/
+        " add %1,r0" "\n\t"              /* %1 += LO(LO(f) * HI(t))*/
+        " adc %10,r1" "\n\t"             /* %10 = HI(LO(f) * HI(t))*/
+        " adc %11,%0" "\n\t"             /* %11 += carry*/
+        " mul %6,%7" "\n\t"              /* r1:r0 = HI(f) * LO(t)*/
+        " add %1,r0" "\n\t"              /* %1 += LO(HI(f) * LO(t))*/
+        " adc %10,r1" "\n\t"             /* %10 += HI(HI(f) * LO(t))*/
+        " adc %11,%0" "\n\t"             /* %11 += carry*/
+        " mul %6,%8" "\n\t"              /* r1:r0 = HI(f) * HI(t)*/
+        " add %10,r0" "\n\t"             /* %10 += LO(HI(f) * HI(t))*/
+        " adc %11,r1" "\n\t"             /* %11 += HI(HI(f) * HI(t))*/
+        " mov %5,%10" "\n\t"             /* %6:%5 =*/
+        " mov %6,%11" "\n\t"             /* f = %10:%11*/
+
+        /* umul16x24to24hi(v, f, bezier_A); / Range 21bits [29]*/
+        /* acc -= v; */
+        " lds %10, bezier_A" "\n\t"      /* %10 = LO(bezier_A)*/
+        " mul %10,%5" "\n\t"             /* r1:r0 = LO(bezier_A) * LO(f)*/
+        " sub %9,r1" "\n\t"
+        " sbc %2,%0" "\n\t"
+        " sbc %3,%0" "\n\t"
+        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= HI(LO(bezier_A) * LO(f))*/
+        " lds %11, bezier_A+1" "\n\t"    /* %11 = MI(bezier_A)*/
+        " mul %11,%5" "\n\t"             /* r1:r0 = MI(bezier_A) * LO(f)*/
+        " sub %9,r0" "\n\t"
+        " sbc %2,r1" "\n\t"
+        " sbc %3,%0" "\n\t"
+        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= MI(bezier_A) * LO(f)*/
+        " lds %1, bezier_A+2" "\n\t"     /* %1 = HI(bezier_A)*/
+        " mul %1,%5" "\n\t"              /* r1:r0 = MI(bezier_A) * LO(f)*/
+        " sub %2,r0" "\n\t"
+        " sbc %3,r1" "\n\t"
+        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= HI(bezier_A) * LO(f) << 8*/
+        " mul %10,%6" "\n\t"             /* r1:r0 = LO(bezier_A) * MI(f)*/
+        " sub %9,r0" "\n\t"
+        " sbc %2,r1" "\n\t"
+        " sbc %3,%0" "\n\t"
+        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= LO(bezier_A) * MI(f)*/
+        " mul %11,%6" "\n\t"             /* r1:r0 = MI(bezier_A) * MI(f)*/
+        " sub %2,r0" "\n\t"
+        " sbc %3,r1" "\n\t"
+        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= MI(bezier_A) * MI(f) << 8*/
+        " mul %1,%6" "\n\t"              /* r1:r0 = HI(bezier_A) * LO(f)*/
+        " sub %3,r0" "\n\t"
+        " sbc %4,r1" "\n\t"              /* %4:%3:%2:%9 -= HI(bezier_A) * LO(f) << 16*/
+        " jmp 2f" "\n\t"                 /* Done!*/
+
+        "1:" "\n\t"
+
+        /* uint24_t v; */
+        /* umul16x24to24hi(v, f, bezier_C); / Range 21bits [29]*/
+        /* acc += v; */
+        " lds %10, bezier_C" "\n\t"      /* %10 = LO(bezier_C)*/
+        " mul %10,%5" "\n\t"             /* r1:r0 = LO(bezier_C) * LO(f)*/
+        " add %9,r1" "\n\t"
+        " adc %2,%0" "\n\t"
+        " adc %3,%0" "\n\t"
+        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += HI(LO(bezier_C) * LO(f))*/
+        " lds %11, bezier_C+1" "\n\t"    /* %11 = MI(bezier_C)*/
+        " mul %11,%5" "\n\t"             /* r1:r0 = MI(bezier_C) * LO(f)*/
+        " add %9,r0" "\n\t"
+        " adc %2,r1" "\n\t"
+        " adc %3,%0" "\n\t"
+        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += MI(bezier_C) * LO(f)*/
+        " lds %1, bezier_C+2" "\n\t"     /* %1 = HI(bezier_C)*/
+        " mul %1,%5" "\n\t"              /* r1:r0 = MI(bezier_C) * LO(f)*/
+        " add %2,r0" "\n\t"
+        " adc %3,r1" "\n\t"
+        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += HI(bezier_C) * LO(f) << 8*/
+        " mul %10,%6" "\n\t"             /* r1:r0 = LO(bezier_C) * MI(f)*/
+        " add %9,r0" "\n\t"
+        " adc %2,r1" "\n\t"
+        " adc %3,%0" "\n\t"
+        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += LO(bezier_C) * MI(f)*/
+        " mul %11,%6" "\n\t"             /* r1:r0 = MI(bezier_C) * MI(f)*/
+        " add %2,r0" "\n\t"
+        " adc %3,r1" "\n\t"
+        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += MI(bezier_C) * MI(f) << 8*/
+        " mul %1,%6" "\n\t"              /* r1:r0 = HI(bezier_C) * LO(f)*/
+        " add %3,r0" "\n\t"
+        " adc %4,r1" "\n\t"              /* %4:%3:%2:%9 += HI(bezier_C) * LO(f) << 16*/
+
+        /* umul16x16to16hi(f, f, t); / Range 16 bits : f = t^3  (unsigned) [17]*/
+        " mul %5,%7" "\n\t"              /* r1:r0 = LO(f) * LO(t)*/
+        " mov %1,r1" "\n\t"              /* store MIL(LO(f) * LO(t)) in %1, we need it for rounding*/
+        " clr %10" "\n\t"                /* %10 = 0*/
+        " clr %11" "\n\t"                /* %11 = 0*/
+        " mul %5,%8" "\n\t"              /* r1:r0 = LO(f) * HI(t)*/
+        " add %1,r0" "\n\t"              /* %1 += LO(LO(f) * HI(t))*/
+        " adc %10,r1" "\n\t"             /* %10 = HI(LO(f) * HI(t))*/
+        " adc %11,%0" "\n\t"             /* %11 += carry*/
+        " mul %6,%7" "\n\t"              /* r1:r0 = HI(f) * LO(t)*/
+        " add %1,r0" "\n\t"              /* %1 += LO(HI(f) * LO(t))*/
+        " adc %10,r1" "\n\t"             /* %10 += HI(HI(f) * LO(t))*/
+        " adc %11,%0" "\n\t"             /* %11 += carry*/
+        " mul %6,%8" "\n\t"              /* r1:r0 = HI(f) * HI(t)*/
+        " add %10,r0" "\n\t"             /* %10 += LO(HI(f) * HI(t))*/
+        " adc %11,r1" "\n\t"             /* %11 += HI(HI(f) * HI(t))*/
+        " mov %5,%10" "\n\t"             /* %6:%5 =*/
+        " mov %6,%11" "\n\t"             /* f = %10:%11*/
+
+        /* umul16x24to24hi(v, f, bezier_B); / Range 22bits [29]*/
+        /* acc -= v;*/
+        " lds %10, bezier_B" "\n\t"      /* %10 = LO(bezier_B)*/
+        " mul %10,%5" "\n\t"             /* r1:r0 = LO(bezier_B) * LO(f)*/
+        " sub %9,r1" "\n\t"
+        " sbc %2,%0" "\n\t"
+        " sbc %3,%0" "\n\t"
+        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= HI(LO(bezier_B) * LO(f))*/
+        " lds %11, bezier_B+1" "\n\t"    /* %11 = MI(bezier_B)*/
+        " mul %11,%5" "\n\t"             /* r1:r0 = MI(bezier_B) * LO(f)*/
+        " sub %9,r0" "\n\t"
+        " sbc %2,r1" "\n\t"
+        " sbc %3,%0" "\n\t"
+        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= MI(bezier_B) * LO(f)*/
+        " lds %1, bezier_B+2" "\n\t"     /* %1 = HI(bezier_B)*/
+        " mul %1,%5" "\n\t"              /* r1:r0 = MI(bezier_B) * LO(f)*/
+        " sub %2,r0" "\n\t"
+        " sbc %3,r1" "\n\t"
+        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= HI(bezier_B) * LO(f) << 8*/
+        " mul %10,%6" "\n\t"             /* r1:r0 = LO(bezier_B) * MI(f)*/
+        " sub %9,r0" "\n\t"
+        " sbc %2,r1" "\n\t"
+        " sbc %3,%0" "\n\t"
+        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= LO(bezier_B) * MI(f)*/
+        " mul %11,%6" "\n\t"             /* r1:r0 = MI(bezier_B) * MI(f)*/
+        " sub %2,r0" "\n\t"
+        " sbc %3,r1" "\n\t"
+        " sbc %4,%0" "\n\t"              /* %4:%3:%2:%9 -= MI(bezier_B) * MI(f) << 8*/
+        " mul %1,%6" "\n\t"              /* r1:r0 = HI(bezier_B) * LO(f)*/
+        " sub %3,r0" "\n\t"
+        " sbc %4,r1" "\n\t"              /* %4:%3:%2:%9 -= HI(bezier_B) * LO(f) << 16*/
+
+        /* umul16x16to16hi(f, f, t); / Range 16 bits : f = t^5  (unsigned) [17]*/
+        " mul %5,%7" "\n\t"              /* r1:r0 = LO(f) * LO(t)*/
+        " mov %1,r1" "\n\t"              /* store MIL(LO(f) * LO(t)) in %1, we need it for rounding*/
+        " clr %10" "\n\t"                /* %10 = 0*/
+        " clr %11" "\n\t"                /* %11 = 0*/
+        " mul %5,%8" "\n\t"              /* r1:r0 = LO(f) * HI(t)*/
+        " add %1,r0" "\n\t"              /* %1 += LO(LO(f) * HI(t))*/
+        " adc %10,r1" "\n\t"             /* %10 = HI(LO(f) * HI(t))*/
+        " adc %11,%0" "\n\t"             /* %11 += carry*/
+        " mul %6,%7" "\n\t"              /* r1:r0 = HI(f) * LO(t)*/
+        " add %1,r0" "\n\t"              /* %1 += LO(HI(f) * LO(t))*/
+        " adc %10,r1" "\n\t"             /* %10 += HI(HI(f) * LO(t))*/
+        " adc %11,%0" "\n\t"             /* %11 += carry*/
+        " mul %6,%8" "\n\t"              /* r1:r0 = HI(f) * HI(t)*/
+        " add %10,r0" "\n\t"             /* %10 += LO(HI(f) * HI(t))*/
+        " adc %11,r1" "\n\t"             /* %11 += HI(HI(f) * HI(t))*/
+        " mov %5,%10" "\n\t"             /* %6:%5 =*/
+        " mov %6,%11" "\n\t"             /* f = %10:%11*/
+
+        /* umul16x24to24hi(v, f, bezier_A); / Range 21bits [29]*/
+        /* acc += v; */
+        " lds %10, bezier_A" "\n\t"      /* %10 = LO(bezier_A)*/
+        " mul %10,%5" "\n\t"             /* r1:r0 = LO(bezier_A) * LO(f)*/
+        " add %9,r1" "\n\t"
+        " adc %2,%0" "\n\t"
+        " adc %3,%0" "\n\t"
+        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += HI(LO(bezier_A) * LO(f))*/
+        " lds %11, bezier_A+1" "\n\t"    /* %11 = MI(bezier_A)*/
+        " mul %11,%5" "\n\t"             /* r1:r0 = MI(bezier_A) * LO(f)*/
+        " add %9,r0" "\n\t"
+        " adc %2,r1" "\n\t"
+        " adc %3,%0" "\n\t"
+        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += MI(bezier_A) * LO(f)*/
+        " lds %1, bezier_A+2" "\n\t"     /* %1 = HI(bezier_A)*/
+        " mul %1,%5" "\n\t"              /* r1:r0 = MI(bezier_A) * LO(f)*/
+        " add %2,r0" "\n\t"
+        " adc %3,r1" "\n\t"
+        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += HI(bezier_A) * LO(f) << 8*/
+        " mul %10,%6" "\n\t"             /* r1:r0 = LO(bezier_A) * MI(f)*/
+        " add %9,r0" "\n\t"
+        " adc %2,r1" "\n\t"
+        " adc %3,%0" "\n\t"
+        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += LO(bezier_A) * MI(f)*/
+        " mul %11,%6" "\n\t"             /* r1:r0 = MI(bezier_A) * MI(f)*/
+        " add %2,r0" "\n\t"
+        " adc %3,r1" "\n\t"
+        " adc %4,%0" "\n\t"              /* %4:%3:%2:%9 += MI(bezier_A) * MI(f) << 8*/
+        " mul %1,%6" "\n\t"              /* r1:r0 = HI(bezier_A) * LO(f)*/
+        " add %3,r0" "\n\t"
+        " adc %4,r1" "\n\t"              /* %4:%3:%2:%9 += HI(bezier_A) * LO(f) << 16*/
+        "2:" "\n\t"
+        " clr __zero_reg__"              /* C runtime expects r1 = __zero_reg__ = 0 */
+        : "+r"(r0),
+          "+r"(r1),
+          "+r"(r2),
+          "+r"(r3),
+          "+r"(r4),
+          "+r"(r5),
+          "+r"(r6),
+          "+r"(r7),
+          "+r"(r8),
+          "+r"(r9),
+          "+r"(r10),
+          "+r"(r11)
+        :
+        :"cc","r0","r1"
+      );
+      return (r2 | (uint16_t(r3) << 8)) | (uint32_t(r4) << 16);
+    }
 
-      // For non ARM targets, we provide a fallback implementation. Really doubt it
-      // will be useful, unless the processor is extremely fast.
-
-      uint32_t t = bezier_AV * curr_step;               // t: Range 0 - 1^32 = 32 bits
-      uint64_t f = t;
-      f *= t;                                           // Range 32*2 = 64 bits (unsigned)
-      f >>= 32;                                         // Range 32 bits  (unsigned)
-      f *= t;                                           // Range 32*2 = 64 bits  (unsigned)
-      f >>= 32;                                         // Range 32 bits : f = t^3  (unsigned)
-      int64_t acc = (int64_t) bezier_F << 31;           // Range 63 bits (signed)
-      acc += ((uint32_t) f >> 1) * (int64_t) bezier_C;  // Range 29bits + 31 = 60bits (plus sign)
-      f *= t;                                           // Range 32*2 = 64 bits
-      f >>= 32;                                         // Range 32 bits : f = t^3  (unsigned)
-      acc += ((uint32_t) f >> 1) * (int64_t) bezier_B;  // Range 29bits + 31 = 60bits (plus sign)
-      f *= t;                                           // Range 32*2 = 64 bits
-      f >>= 32;                                         // Range 32 bits : f = t^3  (unsigned)
-      acc += ((uint32_t) f >> 1) * (int64_t) bezier_A;  // Range 28bits + 31 = 59bits (plus sign)
-      acc >>= (31 + 7);                                 // Range 24bits (plus sign)
-      return (int32_t) acc;
+  #else
 
-    #endif
-  }
+    // For all the other 32bit CPUs
+    FORCE_INLINE void Stepper::_calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t av) {
+      // Calculate the Bézier coefficients
+      bezier_A =  768 * (v1 - v0);
+      bezier_B = 1920 * (v0 - v1);
+      bezier_C = 1280 * (v1 - v0);
+      bezier_F =  128 * v0;
+      bezier_AV = av;
+    }
+
+    FORCE_INLINE int32_t Stepper::_eval_bezier_curve(const uint32_t curr_step) {
+      #if defined(__ARM__) || defined(__thumb__)
+
+        // For ARM Cortex M3/M4 CPUs, we have the optimized assembler version, that takes 43 cycles to execute
+        register uint32_t flo = 0;
+        register uint32_t fhi = bezier_AV * curr_step;
+        register uint32_t t = fhi;
+        register int32_t alo = bezier_F;
+        register int32_t ahi = 0;
+        register int32_t A = bezier_A;
+        register int32_t B = bezier_B;
+        register int32_t C = bezier_C;
+
+         __asm__ __volatile__(
+          ".syntax unified"                   "\n\t"  // is to prevent CM0,CM1 non-unified syntax
+          " lsrs  %[ahi],%[alo],#1"           "\n\t"  // a  = F << 31      1 cycles
+          " lsls  %[alo],%[alo],#31"          "\n\t"  //                   1 cycles
+          " umull %[flo],%[fhi],%[fhi],%[t]"  "\n\t"  // f *= t            5 cycles [fhi:flo=64bits]
+          " umull %[flo],%[fhi],%[fhi],%[t]"  "\n\t"  // f>>=32; f*=t      5 cycles [fhi:flo=64bits]
+          " lsrs  %[flo],%[fhi],#1"           "\n\t"  //                   1 cycles [31bits]
+          " smlal %[alo],%[ahi],%[flo],%[C]"  "\n\t"  // a+=(f>>33)*C;     5 cycles
+          " umull %[flo],%[fhi],%[fhi],%[t]"  "\n\t"  // f>>=32; f*=t      5 cycles [fhi:flo=64bits]
+          " lsrs  %[flo],%[fhi],#1"           "\n\t"  //                   1 cycles [31bits]
+          " smlal %[alo],%[ahi],%[flo],%[B]"  "\n\t"  // a+=(f>>33)*B;     5 cycles
+          " umull %[flo],%[fhi],%[fhi],%[t]"  "\n\t"  // f>>=32; f*=t      5 cycles [fhi:flo=64bits]
+          " lsrs  %[flo],%[fhi],#1"           "\n\t"  // f>>=33;           1 cycles [31bits]
+          " smlal %[alo],%[ahi],%[flo],%[A]"  "\n\t"  // a+=(f>>33)*A;     5 cycles
+          " lsrs  %[alo],%[ahi],#6"           "\n\t"  // a>>=38            1 cycles
+          : [alo]"+r"( alo ) ,
+            [flo]"+r"( flo ) ,
+            [fhi]"+r"( fhi ) ,
+            [ahi]"+r"( ahi ) ,
+            [A]"+r"( A ) ,  // <== Note: Even if A, B, C, and t registers are INPUT ONLY
+            [B]"+r"( B ) ,  //  GCC does bad optimizations on the code if we list them as
+            [C]"+r"( C ) ,  //  such, breaking this function. So, to avoid that problem,
+            [t]"+r"( t )    //  we list all registers as input-outputs.
+          :
+          : "cc"
+        );
+        return alo;
+
+      #else
 
+        // For non ARM targets, we provide a fallback implementation. Really doubt it
+        // will be useful, unless the processor is fast and 32bit
+
+        uint32_t t = bezier_AV * curr_step;               // t: Range 0 - 1^32 = 32 bits
+        uint64_t f = t;
+        f *= t;                                           // Range 32*2 = 64 bits (unsigned)
+        f >>= 32;                                         // Range 32 bits  (unsigned)
+        f *= t;                                           // Range 32*2 = 64 bits  (unsigned)
+        f >>= 32;                                         // Range 32 bits : f = t^3  (unsigned)
+        int64_t acc = (int64_t) bezier_F << 31;           // Range 63 bits (signed)
+        acc += ((uint32_t) f >> 1) * (int64_t) bezier_C;  // Range 29bits + 31 = 60bits (plus sign)
+        f *= t;                                           // Range 32*2 = 64 bits
+        f >>= 32;                                         // Range 32 bits : f = t^3  (unsigned)
+        acc += ((uint32_t) f >> 1) * (int64_t) bezier_B;  // Range 29bits + 31 = 60bits (plus sign)
+        f *= t;                                           // Range 32*2 = 64 bits
+        f >>= 32;                                         // Range 32 bits : f = t^3  (unsigned)
+        acc += ((uint32_t) f >> 1) * (int64_t) bezier_A;  // Range 28bits + 31 = 59bits (plus sign)
+        acc >>= (31 + 7);                                 // Range 24bits (plus sign)
+        return (int32_t) acc;
+
+      #endif
+    }
+  #endif
 #endif // BEZIER_JERK_CONTROL
 
 /**
@@ -660,7 +1268,7 @@ void Stepper::isr() {
 
       #if ENABLED(BEZIER_JERK_CONTROL)
         // Initialize the Bézier speed curve
-        _calc_bezier_curve_coeffs(current_block->initial_rate, current_block->cruise_rate, current_block->acceleration_time);
+        _calc_bezier_curve_coeffs(current_block->initial_rate, current_block->cruise_rate, current_block->acceleration_time_inverse);
 
         // We have not started the 2nd half of the trapezoid
         bezier_2nd_half = false;
@@ -953,7 +1561,7 @@ void Stepper::isr() {
       if (!bezier_2nd_half) {
 
         // Initialize the Bézier speed curve
-        _calc_bezier_curve_coeffs(current_block->cruise_rate, current_block->final_rate, current_block->deceleration_time);
+        _calc_bezier_curve_coeffs(current_block->cruise_rate, current_block->final_rate, current_block->deceleration_time_inverse);
         bezier_2nd_half = true;
       }
 

commit a29adde5c0706a572261c40a02c61e1c966928a4
Author: etagle <ejtagle@hotmail.com>
Date:   Fri Apr 6 22:48:06 2018 -0300

    Implement BEZIER_JERK_CONTROL
    
    Enable 6th-order jerk-controlled motion planning in real-time.
    Only for 32bit MCUs. (AVR simply does not have enough processing power for this!)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 70ddd1f828..2b0974efa5 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -44,6 +44,13 @@
 /* The timer calculations of this module informed by the 'RepRap cartesian firmware' by Zack Smith
    and Philipp Tiefenbacher. */
 
+/* Jerk controlled movements planner added by Eduardo José Tagle in April
+   2018, Equations based on Synthethos TinyG2 sources, but the fixed-point
+   implementation is a complete new one, as we are running the ISR with a
+   variable period.
+   Also implemented the Bézier velocity curve evaluation in ARM assembler,
+   to avoid impacting ISR speed. */
+
 #include "stepper.h"
 
 #ifdef __AVR__
@@ -109,6 +116,15 @@ long Stepper::counter_X = 0,
 
 volatile uint32_t Stepper::step_events_completed = 0; // The number of step events executed in the current block
 
+#if ENABLED(BEZIER_JERK_CONTROL)
+  int32_t Stepper::bezier_A,        // A coefficient in Bézier speed curve
+          Stepper::bezier_B,        // B coefficient in Bézier speed curve
+          Stepper::bezier_C,        // C coefficient in Bézier speed curve
+          Stepper::bezier_F;        // F coefficient in Bézier speed curve
+  uint32_t Stepper::bezier_AV;      // AV coefficient in Bézier speed curve
+  bool Stepper::bezier_2nd_half;    // =false If Bézier curve has been initialized or not
+#endif
+
 #if ENABLED(LIN_ADVANCE)
 
   uint32_t Stepper::LA_decelerate_after;
@@ -134,9 +150,9 @@ volatile uint32_t Stepper::step_events_completed = 0; // The number of step even
 
 #endif // LIN_ADVANCE
 
-long Stepper::acceleration_time, Stepper::deceleration_time;
+int32_t Stepper::acceleration_time, Stepper::deceleration_time;
 
-volatile long Stepper::count_position[NUM_AXIS] = { 0 };
+volatile int32_t Stepper::count_position[NUM_AXIS] = { 0 };
 volatile signed char Stepper::count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
 
 #if ENABLED(MIXING_EXTRUDER)
@@ -145,8 +161,10 @@ volatile signed char Stepper::count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
 
 uint8_t Stepper::step_loops, Stepper::step_loops_nominal;
 
-hal_timer_t Stepper::OCR1A_nominal,
-            Stepper::acc_step_rate; // needed for deceleration start point
+hal_timer_t Stepper::OCR1A_nominal;
+#if DISABLED(BEZIER_JERK_CONTROL)
+  hal_timer_t Stepper::acc_step_rate; // needed for deceleration start point
+#endif
 
 volatile long Stepper::endstops_trigsteps[XYZ];
 
@@ -298,6 +316,207 @@ void Stepper::set_directions() {
   extern volatile uint8_t e_hit;
 #endif
 
+#if ENABLED(BEZIER_JERK_CONTROL)
+  /**
+   *   We are using a quintic (fifth-degree) Bézier polynomial for the velocity curve.
+   *  This gives us a "linear pop" velocity curve; with pop being the sixth derivative of position:
+   *  velocity - 1st, acceleration - 2nd, jerk - 3rd, snap - 4th, crackle - 5th, pop - 6th
+   *
+   *  The Bézier curve takes the form:
+   *
+   *  V(t) = P_0 * B_0(t) + P_1 * B_1(t) + P_2 * B_2(t) + P_3 * B_3(t) + P_4 * B_4(t) + P_5 * B_5(t)
+   *
+   *   Where 0 <= t <= 1, and V(t) is the velocity. P_0 through P_5 are the control points, and B_0(t)
+   *  through B_5(t) are the Bernstein basis as follows:
+   *
+   *        B_0(t) =   (1-t)^5        =   -t^5 +  5t^4 - 10t^3 + 10t^2 -  5t   +   1
+   *        B_1(t) =  5(1-t)^4 * t    =   5t^5 - 20t^4 + 30t^3 - 20t^2 +  5t
+   *        B_2(t) = 10(1-t)^3 * t^2  = -10t^5 + 30t^4 - 30t^3 + 10t^2
+   *        B_3(t) = 10(1-t)^2 * t^3  =  10t^5 - 20t^4 + 10t^3
+   *        B_4(t) =  5(1-t)   * t^4  =  -5t^5 +  5t^4
+   *        B_5(t) =             t^5  =    t^5
+   *                                      ^       ^       ^       ^       ^       ^
+   *                                      |       |       |       |       |       |
+   *                                      A       B       C       D       E       F
+   *
+   *   Unfortunately, we cannot use forward-differencing to calculate each position through
+   *  the curve, as Marlin uses variable timer periods. So, we require a formula of the form:
+   *
+   *        V_f(t) = A*t^5 + B*t^4 + C*t^3 + D*t^2 + E*t + F
+   *
+   *   Looking at the above B_0(t) through B_5(t) expanded forms, if we take the coefficients of t^5
+   *  through t of the Bézier form of V(t), we can determine that:
+   *
+   *        A =    -P_0 +  5*P_1 - 10*P_2 + 10*P_3 -  5*P_4 +  P_5
+   *        B =   5*P_0 - 20*P_1 + 30*P_2 - 20*P_3 +  5*P_4
+   *        C = -10*P_0 + 30*P_1 - 30*P_2 + 10*P_3
+   *        D =  10*P_0 - 20*P_1 + 10*P_2
+   *        E = - 5*P_0 +  5*P_1
+   *        F =     P_0
+   *
+   *   Now, since we will (currently) *always* want the initial acceleration and jerk values to be 0,
+   *  We set P_i = P_0 = P_1 = P_2 (initial velocity), and P_t = P_3 = P_4 = P_5 (target velocity),
+   *  which, after simplification, resolves to:
+   *
+   *        A = - 6*P_i +  6*P_t =  6*(P_t - P_i)
+   *        B =  15*P_i - 15*P_t = 15*(P_i - P_t)
+   *        C = -10*P_i + 10*P_t = 10*(P_t - P_i)
+   *        D = 0
+   *        E = 0
+   *        F = P_i
+   *
+   *   As the t is evaluated in non uniform steps here, there is no other way rather than evaluating
+   *  the Bézier curve at each point:
+   *
+   *        V_f(t) = A*t^5 + B*t^4 + C*t^3 + F          [0 <= t <= 1]
+   *
+   *   Floating point arithmetic execution time cost is prohibitive, so we will transform the math to
+   * use fixed point values to be able to evaluate it in realtime. Assuming a maximum of 250000 steps
+   * per second (driver pulses should at least be 2uS hi/2uS lo), and allocating 2 bits to avoid
+   * overflows on the evaluation of the Bézier curve, means we can use
+   *
+   *   t: unsigned Q0.32 (0 <= t < 1) |range 0 to 0xFFFFFFFF unsigned
+   *   A:   signed Q24.7 ,            |range = +/- 250000 * 6 * 128 = +/- 192000000 = 0x0B71B000 | 28 bits + sign
+   *   B:   signed Q24.7 ,            |range = +/- 250000 *15 * 128 = +/- 480000000 = 0x1C9C3800 | 29 bits + sign
+   *   C:   signed Q24.7 ,            |range = +/- 250000 *10 * 128 = +/- 320000000 = 0x1312D000 | 29 bits + sign
+   *   F:   signed Q24.7 ,            |range = +/- 250000     * 128 =      32000000 = 0x01E84800 | 25 bits + sign
+   *
+   *  The trapezoid generator state contains the following information, that we will use to create and evaluate
+   * the Bézier curve:
+   *
+   *  blk->step_event_count [TS] = The total count of steps for this movement. (=distance)
+   *  blk->initial_rate     [VI] = The initial steps per second (=velocity)
+   *  blk->final_rate       [VF] = The ending steps per second  (=velocity)
+   *  and the count of events completed (step_events_completed) [CS] (=distance until now)
+   *
+   *  Note the abbreviations we use in the following formulae are between []s
+   *
+   *  At the start of each trapezoid, we calculate the coefficients A,B,C,F and Advance [AV], as follows:
+   *
+   *   A =  6*128*(VF - VI) =  768*(VF - VI)
+   *   B = 15*128*(VI - VF) = 1920*(VI - VF)
+   *   C = 10*128*(VF - VI) = 1280*(VF - VI)
+   *   F =    128*VI        =  128*VI
+   *  AV = (1<<32)/TS      ~= 0xFFFFFFFF / TS (To use ARM UDIV, that is 32 bits)
+   *
+   *  And for each point, we will evaluate the curve with the following sequence:
+   *
+   *    uint32_t t = bezier_AV * curr_step;               // t: Range 0 - 1^32 = 32 bits
+   *    uint64_t f = t;
+   *    f *= t;                                           // Range 32*2 = 64 bits (unsigned)
+   *    f >>= 32;                                         // Range 32 bits  (unsigned)
+   *    f *= t;                                           // Range 32*2 = 64 bits  (unsigned)
+   *    f >>= 32;                                         // Range 32 bits : f = t^3  (unsigned)
+   *    int64_t acc = (int64_t) bezier_F << 31;           // Range 63 bits (signed)
+   *    acc += ((uint32_t) f >> 1) * (int64_t) bezier_C;  // Range 29bits + 31 = 60bits (plus sign)
+   *    f *= t;                                           // Range 32*2 = 64 bits
+   *    f >>= 32;                                         // Range 32 bits : f = t^3  (unsigned)
+   *    acc += ((uint32_t) f >> 1) * (int64_t) bezier_B;  // Range 29bits + 31 = 60bits (plus sign)
+   *    f *= t;                                           // Range 32*2 = 64 bits
+   *    f >>= 32;                                         // Range 32 bits : f = t^3  (unsigned)
+   *    acc += ((uint32_t) f >> 1) * (int64_t) bezier_A;  // Range 28bits + 31 = 59bits (plus sign)
+   *    acc >>= (31 + 7);                                 // Range 24bits (plus sign)
+   *
+   * This can be translated to the following ARM assembly sequence:
+   *
+   * At start:
+   *  fhi = AV, flo = CS, alo = F
+   *
+   *  muls  fhi,flo               | f = AV * CS       1 cycles
+   *  mov   t,fhi                 | t = AV * CS       1 cycles
+   *  lsrs  ahi,alo,#1            | a  = F << 31      1 cycles
+   *  lsls  alo,alo,#31           |                   1 cycles
+   *  umull flo,fhi,fhi,t         | f *= t            5 cycles [fhi:flo=64bits
+   *  umull flo,fhi,fhi,t         | f>>=32; f*=t      5 cycles [fhi:flo=64bits
+   *  lsrs  flo,fhi,#1            |                   1 cycles [31bits
+   *  smlal alo,ahi,flo,C         | a+=(f>>33)*C;     5 cycles
+   *  umull flo,fhi,fhi,t         | f>>=32; f*=t      5 cycles [fhi:flo=64bits
+   *  lsrs  flo,fhi,#1            |                   1 cycles [31bits
+   *  smlal alo,ahi,flo,B         | a+=(f>>33)*B;     5 cycles
+   *  umull flo,fhi,fhi,t         | f>>=32; f*=t      5 cycles [fhi:flo=64bits
+   *  lsrs  flo,fhi,#1            | f>>=33;           1 cycles [31bits
+   *  smlal alo,ahi,flo,A         | a+=(f>>33)*A;     5 cycles
+   *  lsrs  alo,ahi,#6            | a>>=38            1 cycles
+   *  43 cycles total
+   */
+
+  FORCE_INLINE void Stepper::_calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t interval) {
+    // Calculate the Bézier coefficients
+    bezier_A =  768 * (v1 - v0);
+    bezier_B = 1920 * (v0 - v1);
+    bezier_C = 1280 * (v1 - v0);
+    bezier_F =  128 * v0;
+    bezier_AV = 0xFFFFFFFF / interval;
+  }
+
+  FORCE_INLINE int32_t Stepper::_eval_bezier_curve(const uint32_t curr_step) {
+    #if defined(__ARM__) || defined(__thumb__)
+
+      // For ARM CORTEX M3/M4 CPUs, we have the optimized assembler version, that takes 43 cycles to execute
+      register uint32_t flo = 0;
+      register uint32_t fhi = bezier_AV * curr_step;
+      register uint32_t t = fhi;
+      register int32_t alo = bezier_F;
+      register int32_t ahi = 0;
+      register int32_t A = bezier_A;
+      register int32_t B = bezier_B;
+      register int32_t C = bezier_C;
+
+       __asm__ __volatile__(
+        ".syntax unified"                   "\n\t"  // is to prevent CM0,CM1 non-unified syntax
+        " lsrs  %[ahi],%[alo],#1"           "\n\t"  // a  = F << 31      1 cycles
+        " lsls  %[alo],%[alo],#31"          "\n\t"  //                   1 cycles
+        " umull %[flo],%[fhi],%[fhi],%[t]"  "\n\t"  // f *= t            5 cycles [fhi:flo=64bits]
+        " umull %[flo],%[fhi],%[fhi],%[t]"  "\n\t"  // f>>=32; f*=t      5 cycles [fhi:flo=64bits]
+        " lsrs  %[flo],%[fhi],#1"           "\n\t"  //                   1 cycles [31bits]
+        " smlal %[alo],%[ahi],%[flo],%[C]"  "\n\t"  // a+=(f>>33)*C;     5 cycles
+        " umull %[flo],%[fhi],%[fhi],%[t]"  "\n\t"  // f>>=32; f*=t      5 cycles [fhi:flo=64bits]
+        " lsrs  %[flo],%[fhi],#1"           "\n\t"  //                   1 cycles [31bits]
+        " smlal %[alo],%[ahi],%[flo],%[B]"  "\n\t"  // a+=(f>>33)*B;     5 cycles
+        " umull %[flo],%[fhi],%[fhi],%[t]"  "\n\t"  // f>>=32; f*=t      5 cycles [fhi:flo=64bits]
+        " lsrs  %[flo],%[fhi],#1"           "\n\t"  // f>>=33;           1 cycles [31bits]
+        " smlal %[alo],%[ahi],%[flo],%[A]"  "\n\t"  // a+=(f>>33)*A;     5 cycles
+        " lsrs  %[alo],%[ahi],#6"           "\n\t"  // a>>=38            1 cycles
+        : [alo]"+r"( alo ) ,
+          [flo]"+r"( flo ) ,
+          [fhi]"+r"( fhi ) ,
+          [ahi]"+r"( ahi ) ,
+          [A]"+r"( A ) ,  // <== Note: Even if A, B, C, and t registers are INPUT ONLY
+          [B]"+r"( B ) ,  //  GCC does bad optimizations on the code if we list them as
+          [C]"+r"( C ) ,  //  such, breaking this function. So, to avoid that problem,
+          [t]"+r"( t )    //  we list all registers as input-outputs.
+        :
+        : "cc"
+      );
+      return alo;
+
+    #else
+
+      // For non ARM targets, we provide a fallback implementation. Really doubt it
+      // will be useful, unless the processor is extremely fast.
+
+      uint32_t t = bezier_AV * curr_step;               // t: Range 0 - 1^32 = 32 bits
+      uint64_t f = t;
+      f *= t;                                           // Range 32*2 = 64 bits (unsigned)
+      f >>= 32;                                         // Range 32 bits  (unsigned)
+      f *= t;                                           // Range 32*2 = 64 bits  (unsigned)
+      f >>= 32;                                         // Range 32 bits : f = t^3  (unsigned)
+      int64_t acc = (int64_t) bezier_F << 31;           // Range 63 bits (signed)
+      acc += ((uint32_t) f >> 1) * (int64_t) bezier_C;  // Range 29bits + 31 = 60bits (plus sign)
+      f *= t;                                           // Range 32*2 = 64 bits
+      f >>= 32;                                         // Range 32 bits : f = t^3  (unsigned)
+      acc += ((uint32_t) f >> 1) * (int64_t) bezier_B;  // Range 29bits + 31 = 60bits (plus sign)
+      f *= t;                                           // Range 32*2 = 64 bits
+      f >>= 32;                                         // Range 32 bits : f = t^3  (unsigned)
+      acc += ((uint32_t) f >> 1) * (int64_t) bezier_A;  // Range 28bits + 31 = 59bits (plus sign)
+      acc >>= (31 + 7);                                 // Range 24bits (plus sign)
+      return (int32_t) acc;
+
+    #endif
+  }
+
+#endif // BEZIER_JERK_CONTROL
+
 /**
  * Stepper Driver Interrupt
  *
@@ -394,26 +613,73 @@ void Stepper::isr() {
 
   // If there is no current block, attempt to pop one from the buffer
   if (!current_block) {
+
     // Anything in the buffer?
     if ((current_block = planner.get_current_block())) {
-      trapezoid_generator_reset();
+
+      // Initialize the trapezoid generator from the current block.
+      static int8_t last_extruder = -1;
+
+      #if ENABLED(LIN_ADVANCE)
+        #if E_STEPPERS > 1
+          if (current_block->active_extruder != last_extruder) {
+            current_adv_steps = 0; // If the now active extruder wasn't in use during the last move, its pressure is most likely gone.
+            LA_active_extruder = current_block->active_extruder;
+          }
+        #endif
+
+        if ((use_advance_lead = current_block->use_advance_lead)) {
+          LA_decelerate_after = current_block->decelerate_after;
+          final_adv_steps = current_block->final_adv_steps;
+          max_adv_steps = current_block->max_adv_steps;
+        }
+      #endif
+
+      if (current_block->direction_bits != last_direction_bits || current_block->active_extruder != last_extruder) {
+        last_direction_bits = current_block->direction_bits;
+        last_extruder = current_block->active_extruder;
+        set_directions();
+      }
+
+      // No acceleration / deceleration time elapsed so far
+      acceleration_time = deceleration_time = 0;
+
+      // No step events completed so far
+      step_events_completed = 0;
+
+      // step_rate to timer interval
+      OCR1A_nominal = calc_timer_interval(current_block->nominal_rate);
+
+      // make a note of the number of step loops required at nominal speed
+      step_loops_nominal = step_loops;
+
+      #if DISABLED(BEZIER_JERK_CONTROL)
+        // Set as deceleration point the initial rate of the block
+        acc_step_rate = current_block->initial_rate;
+      #endif
+
+      #if ENABLED(BEZIER_JERK_CONTROL)
+        // Initialize the Bézier speed curve
+        _calc_bezier_curve_coeffs(current_block->initial_rate, current_block->cruise_rate, current_block->acceleration_time);
+
+        // We have not started the 2nd half of the trapezoid
+        bezier_2nd_half = false;
+      #endif
 
       // Initialize Bresenham counters to 1/2 the ceiling
       counter_X = counter_Y = counter_Z = counter_E = -(current_block->step_event_count >> 1);
-
       #if ENABLED(MIXING_EXTRUDER)
         MIXING_STEPPERS_LOOP(i)
           counter_m[i] = -(current_block->mix_event_count[i] >> 1);
       #endif
 
-      step_events_completed = 0;
-
       #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
         e_hit = 2; // Needed for the case an endstop is already triggered before the new move begins.
                    // No 'change' can be detected.
       #endif
 
       #if ENABLED(Z_LATE_ENABLE)
+        // If delayed Z enable, postpone move for 1mS
         if (current_block->steps[Z_AXIS] > 0) {
           enable_Z();
           _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 1000); // Run at slow speed - 1 KHz
@@ -423,6 +689,7 @@ void Stepper::isr() {
       #endif
     }
     else {
+      // If no more queued moves, postpone next check for 1mS
       _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 1000); // Run at slow speed - 1 KHz
       HAL_ENABLE_ISRs();
       return;
@@ -542,7 +809,6 @@ void Stepper::isr() {
     #endif
 
     #if ENABLED(LIN_ADVANCE)
-
       counter_E += current_block->steps[E_AXIS];
       if (counter_E > 0) {
         #if DISABLED(MIXING_EXTRUDER)
@@ -640,15 +906,23 @@ void Stepper::isr() {
   // Calculate new timer value
   if (step_events_completed <= (uint32_t)current_block->accelerate_until) {
 
-    #ifdef CPU_32_BIT
-      MultiU32X24toH32(acc_step_rate, acceleration_time, current_block->acceleration_rate);
+    #if ENABLED(BEZIER_JERK_CONTROL)
+      // Get the next speed to use (Jerk limited!)
+      hal_timer_t acc_step_rate =
+        acceleration_time < current_block->acceleration_time
+          ? _eval_bezier_curve(acceleration_time)
+          : current_block->cruise_rate;
     #else
-      MultiU24X32toH16(acc_step_rate, acceleration_time, current_block->acceleration_rate);
-    #endif
-    acc_step_rate += current_block->initial_rate;
+      #ifdef CPU_32_BIT
+        MultiU32X24toH32(acc_step_rate, acceleration_time, current_block->acceleration_rate);
+      #else
+        MultiU24X32toH16(acc_step_rate, acceleration_time, current_block->acceleration_rate);
+      #endif
+      acc_step_rate += current_block->initial_rate;
 
-    // upper limit
-    NOMORE(acc_step_rate, current_block->nominal_rate);
+      // upper limit
+      NOMORE(acc_step_rate, current_block->nominal_rate);
+    #endif
 
     // step_rate to timer interval
     const hal_timer_t interval = calc_timer_interval(acc_step_rate);
@@ -659,7 +933,6 @@ void Stepper::isr() {
     acceleration_time += interval;
 
     #if ENABLED(LIN_ADVANCE)
-
       if (current_block->use_advance_lead) {
         if (step_events_completed == step_loops || (e_steps && eISR_Rate != current_block->advance_speed)) {
           nextAdvanceISR = 0; // Wake up eISR on first acceleration loop and fire ISR if final adv_rate is reached
@@ -670,23 +943,40 @@ void Stepper::isr() {
         eISR_Rate = ADV_NEVER;
         if (e_steps) nextAdvanceISR = 0;
       }
-
     #endif // LIN_ADVANCE
   }
   else if (step_events_completed > (uint32_t)current_block->decelerate_after) {
     hal_timer_t step_rate;
-    #ifdef CPU_32_BIT
-      MultiU32X24toH32(step_rate, deceleration_time, current_block->acceleration_rate);
+
+    #if ENABLED(BEZIER_JERK_CONTROL)
+      // If this is the 1st time we process the 2nd half of the trapezoid...
+      if (!bezier_2nd_half) {
+
+        // Initialize the Bézier speed curve
+        _calc_bezier_curve_coeffs(current_block->cruise_rate, current_block->final_rate, current_block->deceleration_time);
+        bezier_2nd_half = true;
+      }
+
+      // Calculate the next speed to use
+      step_rate = deceleration_time < current_block->deceleration_time
+        ? _eval_bezier_curve(deceleration_time)
+        : current_block->final_rate;
     #else
-      MultiU24X32toH16(step_rate, deceleration_time, current_block->acceleration_rate);
-    #endif
 
-    if (step_rate < acc_step_rate) { // Still decelerating?
-      step_rate = acc_step_rate - step_rate;
-      NOLESS(step_rate, current_block->final_rate);
-    }
-    else
-      step_rate = current_block->final_rate;
+      // Using the old trapezoidal control
+      #ifdef CPU_32_BIT
+        MultiU32X24toH32(step_rate, deceleration_time, current_block->acceleration_rate);
+      #else
+        MultiU24X32toH16(step_rate, deceleration_time, current_block->acceleration_rate);
+      #endif
+
+      if (step_rate < acc_step_rate) { // Still decelerating?
+        step_rate = acc_step_rate - step_rate;
+        NOLESS(step_rate, current_block->final_rate);
+      }
+      else
+        step_rate = current_block->final_rate;
+    #endif
 
     // step_rate to timer interval
     const hal_timer_t interval = calc_timer_interval(step_rate);
@@ -697,7 +987,6 @@ void Stepper::isr() {
     deceleration_time += interval;
 
     #if ENABLED(LIN_ADVANCE)
-
       if (current_block->use_advance_lead) {
         if (step_events_completed <= (uint32_t)current_block->decelerate_after + step_loops || (e_steps && eISR_Rate != current_block->advance_speed)) {
           nextAdvanceISR = 0; // Wake up eISR on first deceleration loop
@@ -708,16 +997,13 @@ void Stepper::isr() {
         eISR_Rate = ADV_NEVER;
         if (e_steps) nextAdvanceISR = 0;
       }
-
     #endif // LIN_ADVANCE
   }
   else {
 
     #if ENABLED(LIN_ADVANCE)
-
       // If we have esteps to execute, fire the next advance_isr "now"
       if (e_steps && eISR_Rate != current_block->advance_speed) nextAdvanceISR = 0;
-
     #endif
 
     SPLIT(OCR1A_nominal);  // split step into multiple ISRs if larger than ENDSTOP_NOMINAL_OCR_VAL

commit 7d8a46519fc9ecb07be2a6cbdfa4087d5863d4f3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 31 20:13:32 2018 -0500

    Output ABC for delta stepper counts

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index d566f295ea..70ddd1f828 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1225,21 +1225,21 @@ void Stepper::report_positions() {
              zpos = count_position[Z_AXIS];
   CRITICAL_SECTION_END;
 
-  #if CORE_IS_XY || CORE_IS_XZ || IS_SCARA
+  #if CORE_IS_XY || CORE_IS_XZ || IS_DELTA || IS_SCARA
     SERIAL_PROTOCOLPGM(MSG_COUNT_A);
   #else
     SERIAL_PROTOCOLPGM(MSG_COUNT_X);
   #endif
   SERIAL_PROTOCOL(xpos);
 
-  #if CORE_IS_XY || CORE_IS_YZ || IS_SCARA
+  #if CORE_IS_XY || CORE_IS_YZ || IS_DELTA || IS_SCARA
     SERIAL_PROTOCOLPGM(" B:");
   #else
     SERIAL_PROTOCOLPGM(" Y:");
   #endif
   SERIAL_PROTOCOL(ypos);
 
-  #if CORE_IS_XZ || CORE_IS_YZ
+  #if CORE_IS_XZ || CORE_IS_YZ || IS_DELTA
     SERIAL_PROTOCOLPGM(" C:");
   #else
     SERIAL_PROTOCOLPGM(" Z:");

commit 1cb810ff1c04065daa29182a6c22ecf6b0c0098b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 21 19:30:06 2018 -0500

    [2.0.x] Automatically reset stepper timeout (#10179)
    
    * Automatically reset stepper timeout in manage_inactivity
    
    Any code that adds moves to the planner can skip resetting the stepper timeout. We can let `idle` / `manage_inactivity` reset the timer whenever it detects any moves in the planner.
    
    * blocks_queued => has_blocks_queued

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index bdb25bbf6a..d566f295ea 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1091,7 +1091,7 @@ void Stepper::init() {
 /**
  * Block until all buffered steps are executed / cleaned
  */
-void Stepper::synchronize() { while (planner.blocks_queued() || cleaning_buffer_counter) idle(); }
+void Stepper::synchronize() { while (planner.has_blocks_queued() || cleaning_buffer_counter) idle(); }
 
 /**
  * Set the stepper positions directly in steps
@@ -1191,7 +1191,7 @@ void Stepper::finish_and_disable() {
 void Stepper::quick_stop() {
   cleaning_buffer_counter = 5000;
   DISABLE_STEPPER_DRIVER_INTERRUPT();
-  while (planner.blocks_queued()) planner.discard_current_block();
+  while (planner.has_blocks_queued()) planner.discard_current_block();
   current_block = NULL;
   ENABLE_STEPPER_DRIVER_INTERRUPT();
   #if ENABLED(ULTRA_LCD)

commit 48d7036874e55131847360e5693d9807ee0e5184
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 18 19:01:42 2018 -0500

    Consolidate smart stepper driver initialization

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 60305919b8..bdb25bbf6a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -921,31 +921,6 @@ void Stepper::init() {
     microstep_init();
   #endif
 
-  // Init TMC Steppers
-  #if ENABLED(HAVE_TMC26X)
-    tmc26x_init();
-  #endif
-
-  // Init TMC2130 Steppers
-  #if ENABLED(HAVE_TMC2130)
-    tmc2130_init();
-  #endif
-
-  // Init TMC2208 Steppers
-  #if ENABLED(HAVE_TMC2208)
-    tmc2208_init();
-  #endif
-
-  // TRAMS, TMC2130 and TMC2208 advanced settings
-  #if HAS_TRINAMIC
-    TMC_ADV()
-  #endif
-
-  // Init L6470 Steppers
-  #if ENABLED(HAVE_L6470DRIVER)
-    L6470_init();
-  #endif
-
   // Init Dir Pins
   #if HAS_X_DIR
     X_DIR_INIT;

commit eaefc1e41069ab9dc51a52e87e7418c6669dce42
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Mar 19 02:51:40 2018 -0500

    Add CorePQ support for BABYSTEPPING (#10155)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c4c604b015..60305919b8 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1304,16 +1304,16 @@ void Stepper::report_positions() {
     #endif
   #endif
 
-  #define BABYSTEP_AXIS(AXIS, INVERT) {                     \
-      const uint8_t old_dir = _READ_DIR(AXIS);              \
-      _ENABLE(AXIS);                                        \
-      _SAVE_START;                                          \
-      _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^direction^INVERT); \
-      _PULSE_WAIT;                                          \
-      _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), true);     \
-      _PULSE_WAIT;                                          \
-      _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), true);      \
-      _APPLY_DIR(AXIS, old_dir);                            \
+  #define BABYSTEP_AXIS(AXIS, INVERT, DIR) {            \
+      const uint8_t old_dir = _READ_DIR(AXIS);          \
+      _ENABLE(AXIS);                                    \
+      _SAVE_START;                                      \
+      _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^DIR^INVERT);   \
+      _PULSE_WAIT;                                      \
+      _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), true); \
+      _PULSE_WAIT;                                      \
+      _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), true);  \
+      _APPLY_DIR(AXIS, old_dir);                        \
     }
 
   // MUST ONLY BE CALLED BY AN ISR,
@@ -1326,20 +1326,43 @@ void Stepper::report_positions() {
       #if ENABLED(BABYSTEP_XY)
 
         case X_AXIS:
-          BABYSTEP_AXIS(X, false);
+          #if CORE_IS_XY
+            BABYSTEP_AXIS(X, false, direction);
+            BABYSTEP_AXIS(Y, false, direction);
+          #elif CORE_IS_XZ
+            BABYSTEP_AXIS(X, false, direction);
+            BABYSTEP_AXIS(Z, false, direction);
+          #else
+            BABYSTEP_AXIS(X, false, direction);
+          #endif
           break;
 
         case Y_AXIS:
-          BABYSTEP_AXIS(Y, false);
+          #if CORE_IS_XY
+            BABYSTEP_AXIS(X, false, direction);
+            BABYSTEP_AXIS(Y, false, direction^(CORESIGN(1)<0));
+          #elif CORE_IS_YZ
+            BABYSTEP_AXIS(Y, false, direction);
+            BABYSTEP_AXIS(Z, false, direction^(CORESIGN(1)<0));
+          #else
+            BABYSTEP_AXIS(Y, false, direction);
+          #endif
           break;
 
       #endif
 
       case Z_AXIS: {
 
-        #if DISABLED(DELTA)
+        #if CORE_IS_XZ
+          BABYSTEP_AXIS(X, BABYSTEP_INVERT_Z, direction);
+          BABYSTEP_AXIS(Z, BABYSTEP_INVERT_Z, direction^(CORESIGN(1)<0));
 
-          BABYSTEP_AXIS(Z, BABYSTEP_INVERT_Z);
+        #elif CORE_IS_YZ
+          BABYSTEP_AXIS(Y, BABYSTEP_INVERT_Z, direction);
+          BABYSTEP_AXIS(Z, BABYSTEP_INVERT_Z, direction^(CORESIGN(1)<0));
+
+        #elif DISABLED(DELTA)
+          BABYSTEP_AXIS(Z, BABYSTEP_INVERT_Z, direction);
 
         #else // DELTA
 

commit 51bf3c9503eedd0c73550e67627cd7fd847708b3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 14 07:53:14 2018 -0500

    Fix E direction for MK2_MULTIPLEXER with LIN_ADVANCE

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 5cfabb5b11..c4c604b015 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -752,7 +752,7 @@ void Stepper::isr() {
   void Stepper::advance_isr() {
 
     #if ENABLED(MK2_MULTIPLEXER) // For SNMM even-numbered steppers are reversed
-      #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) E## INDEX ##_DIR_WRITE(e_steps < 0 ? !INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0) : INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0)); }while(0)
+      #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) E0_DIR_WRITE(e_steps < 0 ? !INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0) : INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0)); }while(0)
     #elif ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
       #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) { if (e_steps < 0) REV_E_DIR(); else NORM_E_DIR(); } }while(0)
     #else

commit e7570f3195189f3b6df31faff629da33c8f9f625
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 13 02:06:40 2018 -0500

    Improve TMC config organization, naming

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 30ae0f4f39..5cfabb5b11 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -922,8 +922,8 @@ void Stepper::init() {
   #endif
 
   // Init TMC Steppers
-  #if ENABLED(HAVE_TMCDRIVER)
-    tmc_init();
+  #if ENABLED(HAVE_TMC26X)
+    tmc26x_init();
   #endif
 
   // Init TMC2130 Steppers

commit 751785fc97475ca35f54e776bc8e6e4348d1aaa3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 10 21:40:45 2018 -0600

    Followup to recent patches
    
    - `M666` is static, not inline
    - Disambiguate some stepper macros

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b5f69e5b3f..30ae0f4f39 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -157,20 +157,20 @@ volatile long Stepper::endstops_trigsteps[XYZ];
   #define LOCKED_X2_MOTOR locked_x2_motor
   #define LOCKED_Y2_MOTOR locked_y2_motor
   #define LOCKED_Z2_MOTOR locked_z2_motor
-  #define DUAL_ENDSTOP_APPLY_STEP(AXIS,v)                                                                                                             \
-    if (performing_homing) {                                                                                                                          \
-      if (AXIS##_HOME_DIR < 0) {                                                                                                                      \
-        if (!(TEST(endstops.old_endstop_bits, AXIS##_MIN) && (count_direction[AXIS##_AXIS] < 0)) && !LOCKED_##AXIS##_MOTOR) AXIS##_STEP_WRITE(v);     \
-        if (!(TEST(endstops.old_endstop_bits, AXIS##2_MIN) && (count_direction[AXIS##_AXIS] < 0)) && !LOCKED_##AXIS##2_MOTOR) AXIS##2_STEP_WRITE(v);  \
-      }                                                                                                                                               \
-      else {                                                                                                                                          \
-        if (!(TEST(endstops.old_endstop_bits, AXIS##_MAX) && (count_direction[AXIS##_AXIS] > 0)) && !LOCKED_##AXIS##_MOTOR) AXIS##_STEP_WRITE(v);     \
-        if (!(TEST(endstops.old_endstop_bits, AXIS##2_MAX) && (count_direction[AXIS##_AXIS] > 0)) && !LOCKED_##AXIS##2_MOTOR) AXIS##2_STEP_WRITE(v);  \
-      }                                                                                                                                               \
-    }                                                                                                                                                 \
-    else {                                                                                                                                            \
-      AXIS##_STEP_WRITE(v);                                                                                                                           \
-      AXIS##2_STEP_WRITE(v);                                                                                                                          \
+  #define DUAL_ENDSTOP_APPLY_STEP(AXIS,v)                                                                                                           \
+    if (performing_homing) {                                                                                                                        \
+      if (AXIS##_HOME_DIR < 0) {                                                                                                                    \
+        if (!(TEST(endstops.old_endstop_bits, AXIS##_MIN) && count_direction[AXIS##_AXIS] < 0) && !LOCKED_##AXIS##_MOTOR) AXIS##_STEP_WRITE(v);     \
+        if (!(TEST(endstops.old_endstop_bits, AXIS##2_MIN) && count_direction[AXIS##_AXIS] < 0) && !LOCKED_##AXIS##2_MOTOR) AXIS##2_STEP_WRITE(v);  \
+      }                                                                                                                                             \
+      else {                                                                                                                                        \
+        if (!(TEST(endstops.old_endstop_bits, AXIS##_MAX) && count_direction[AXIS##_AXIS] > 0) && !LOCKED_##AXIS##_MOTOR) AXIS##_STEP_WRITE(v);     \
+        if (!(TEST(endstops.old_endstop_bits, AXIS##2_MAX) && count_direction[AXIS##_AXIS] > 0) && !LOCKED_##AXIS##2_MOTOR) AXIS##2_STEP_WRITE(v);  \
+      }                                                                                                                                             \
+    }                                                                                                                                               \
+    else {                                                                                                                                          \
+      AXIS##_STEP_WRITE(v);                                                                                                                         \
+      AXIS##2_STEP_WRITE(v);                                                                                                                        \
     }
 #endif
 
@@ -231,8 +231,6 @@ volatile long Stepper::endstops_trigsteps[XYZ];
   #define E_APPLY_STEP(v,Q) E_STEP_WRITE(v)
 #endif
 
-
-
 /**
  *         __________________________
  *        /|                        |\     _________________         ^
@@ -452,13 +450,16 @@ void Stepper::isr() {
     // Advance the Bresenham counter; start a pulse if the axis needs a step
     #define PULSE_START(AXIS) do{ \
       _COUNTER(AXIS) += current_block->steps[_AXIS(AXIS)]; \
-      if (_COUNTER(AXIS) > 0) _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), 0); }while(0)
+      if (_COUNTER(AXIS) > 0) { _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), 0); } \
+    }while(0)
 
     // Advance the Bresenham counter; start a pulse if the axis needs a step
-    #define STEP_TICK(AXIS) \
+    #define STEP_TICK(AXIS) do { \
       if (_COUNTER(AXIS) > 0) { \
         _COUNTER(AXIS) -= current_block->step_event_count; \
-        count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; }
+        count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \
+      } \
+    }while(0)
 
     // Stop an active pulse, if any
     #define PULSE_STOP(AXIS) _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), 0)

commit 16a8edc5f041148595f93064aa2d8a15a5437407
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 9 05:26:29 2018 -0600

    Add more delay before pulse off in Linear Advance ISR
    
    A capital idea from https://github.com/MarlinFirmware/Marlin/pull/9914#issuecomment-371614153

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index fe3e39638d..b5f69e5b3f 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -763,7 +763,7 @@ void Stepper::isr() {
       #define STOP_E_PULSE(INDEX) do{ if (e_steps) { E_STEP_WRITE(INVERT_E_STEP_PIN); e_steps < 0 ? ++e_steps : --e_steps; } }while(0)
     #else
       #define START_E_PULSE(INDEX) do{ if (e_steps) E## INDEX ##_STEP_WRITE(!INVERT_E_STEP_PIN); }while(0)
-      #define STOP_E_PULSE(INDEX) do { if (e_steps) { E## INDEX ##_STEP_WRITE(INVERT_E_STEP_PIN); e_steps < 0 ? ++e_steps : --e_steps; } }while(0)
+      #define STOP_E_PULSE(INDEX) do { if (e_steps) { e_steps < 0 ? ++e_steps : --e_steps; E## INDEX ##_STEP_WRITE(INVERT_E_STEP_PIN); } }while(0)
     #endif
 
     if (use_advance_lead) {

commit 98d48fc7310adeb305ecaae7d025b33533dc9402
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 7 22:18:13 2018 -0600

    Followup to HAL_timer_restrain
    
    Followup to #9985

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 9da2c036cf..fe3e39638d 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -365,8 +365,8 @@ void Stepper::isr() {
     _NEXT_ISR(ocr_val);
 
     #if DISABLED(LIN_ADVANCE)
-      HAL_timer_restrain(STEP_TIMER_NUM, STEP_TIMER_MIN_INTERVAL);
-      HAL_ENABLE_ISRs(); // re-enable ISRs
+      HAL_timer_restrain(STEP_TIMER_NUM, STEP_TIMER_MIN_INTERVAL * HAL_TICKS_PER_US);
+      HAL_ENABLE_ISRs();
     #endif
 
     return;
@@ -419,14 +419,14 @@ void Stepper::isr() {
         if (current_block->steps[Z_AXIS] > 0) {
           enable_Z();
           _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 1000); // Run at slow speed - 1 KHz
-          HAL_ENABLE_ISRs(); // re-enable ISRs
+          HAL_ENABLE_ISRs();
           return;
         }
       #endif
     }
     else {
       _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 1000); // Run at slow speed - 1 KHz
-      HAL_ENABLE_ISRs(); // re-enable ISRs
+      HAL_ENABLE_ISRs();
       return;
     }
   }
@@ -727,7 +727,8 @@ void Stepper::isr() {
   }
 
   #if DISABLED(LIN_ADVANCE)
-    HAL_timer_restrain(STEP_TIMER_NUM, STEP_TIMER_MIN_INTERVAL);
+    // Make sure stepper ISR doesn't monopolize the CPU
+    HAL_timer_restrain(STEP_TIMER_NUM, STEP_TIMER_MIN_INTERVAL * HAL_TICKS_PER_US);
   #endif
 
   // If current block is finished, reset pointer
@@ -736,7 +737,7 @@ void Stepper::isr() {
     planner.discard_current_block();
   }
   #if DISABLED(LIN_ADVANCE)
-    HAL_ENABLE_ISRs(); // re-enable ISRs
+    HAL_ENABLE_ISRs();
   #endif
 }
 
@@ -889,9 +890,8 @@ void Stepper::isr() {
       nextMainISR = 0;
     }
 
-    // Don't run the ISR faster than possible
-    // Make sure stepper interrupt does not monopolise CPU by adjusting compare to give about 8µs room
-    HAL_timer_restrain(STEP_TIMER_NUM, STEP_TIMER_MIN_INTERVAL);
+    // Make sure stepper ISR doesn't monopolize the CPU
+    HAL_timer_restrain(STEP_TIMER_NUM, STEP_TIMER_MIN_INTERVAL * HAL_TICKS_PER_US);
 
     // Restore original ISR settings
     HAL_ENABLE_ISRs();

commit a1a88ebabc57f40fdbfe6f4b77f62fe7a2dc8a5d
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Wed Mar 7 23:53:25 2018 +0000

    HAL function to ensure min stepper interrupt interval (#9985)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 1efa5ef899..9da2c036cf 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -365,11 +365,7 @@ void Stepper::isr() {
     _NEXT_ISR(ocr_val);
 
     #if DISABLED(LIN_ADVANCE)
-      #ifdef CPU_32_BIT
-        HAL_timer_set_compare(STEP_TIMER_NUM, ocr_val);
-      #else
-        NOLESS(OCR1A, TCNT1 + 16);
-      #endif
+      HAL_timer_restrain(STEP_TIMER_NUM, STEP_TIMER_MIN_INTERVAL);
       HAL_ENABLE_ISRs(); // re-enable ISRs
     #endif
 
@@ -731,14 +727,7 @@ void Stepper::isr() {
   }
 
   #if DISABLED(LIN_ADVANCE)
-    #ifdef CPU_32_BIT
-      // Make sure stepper interrupt does not monopolise CPU by adjusting count to give about 8 us room
-      hal_timer_t stepper_timer_count = HAL_timer_get_compare(STEP_TIMER_NUM),
-                  stepper_timer_current_count = HAL_timer_get_count(STEP_TIMER_NUM) + 8 * HAL_TICKS_PER_US;
-      HAL_timer_set_compare(STEP_TIMER_NUM, max(stepper_timer_count, stepper_timer_current_count));
-    #else
-      NOLESS(OCR1A, TCNT1 + 16);
-    #endif
+    HAL_timer_restrain(STEP_TIMER_NUM, STEP_TIMER_MIN_INTERVAL);
   #endif
 
   // If current block is finished, reset pointer
@@ -901,14 +890,8 @@ void Stepper::isr() {
     }
 
     // Don't run the ISR faster than possible
-    #ifdef CPU_32_BIT
-      // Make sure stepper interrupt does not monopolise CPU by adjusting count to give about 8 us room
-      uint32_t stepper_timer_count = HAL_timer_get_compare(STEP_TIMER_NUM),
-               stepper_timer_current_count = HAL_timer_get_count(STEP_TIMER_NUM) + 8 * HAL_TICKS_PER_US;
-      HAL_timer_set_compare(STEP_TIMER_NUM, max(stepper_timer_count, stepper_timer_current_count));
-    #else
-      NOLESS(OCR1A, TCNT1 + 16);
-    #endif
+    // Make sure stepper interrupt does not monopolise CPU by adjusting compare to give about 8µs room
+    HAL_timer_restrain(STEP_TIMER_NUM, STEP_TIMER_MIN_INTERVAL);
 
     // Restore original ISR settings
     HAL_ENABLE_ISRs();

commit e5ec793f7e4aa81d7d194c155576345845092d83
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 7 05:42:20 2018 -0600

    Wrap stepper indirection macros

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 9f4be4c40e..1efa5ef899 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -763,7 +763,7 @@ void Stepper::isr() {
     #if ENABLED(MK2_MULTIPLEXER) // For SNMM even-numbered steppers are reversed
       #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) E## INDEX ##_DIR_WRITE(e_steps < 0 ? !INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0) : INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0)); }while(0)
     #elif ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
-      #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) { e_steps < 0 ? REV_E_DIR() : NORM_E_DIR(); } }while(0)
+      #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) { if (e_steps < 0) REV_E_DIR(); else NORM_E_DIR(); } }while(0)
     #else
       #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) E## INDEX ##_DIR_WRITE(e_steps < 0 ? INVERT_E## INDEX ##_DIR : !INVERT_E## INDEX ##_DIR); }while(0)
     #endif

commit 5b854647913ae694ded4c6b21fa00cc7d5aa331f
Author: Sebastianv650 <sebastian.popp@vodafonemail.de>
Date:   Wed Mar 7 12:33:13 2018 +0100

    Fix for LA (#9964)
    
    Missed in the original LA 1.5 PR: eISR has to use a local copy of
    current_block->use_advance_lead because it might still run wenn the last
    block has been set to NULL.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index fd4a3c3b59..9f4be4c40e 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -776,7 +776,7 @@ void Stepper::isr() {
       #define STOP_E_PULSE(INDEX) do { if (e_steps) { E## INDEX ##_STEP_WRITE(INVERT_E_STEP_PIN); e_steps < 0 ? ++e_steps : --e_steps; } }while(0)
     #endif
 
-    if (current_block->use_advance_lead) {
+    if (use_advance_lead) {
       if (step_events_completed > LA_decelerate_after && current_adv_steps > final_adv_steps) {
         e_steps--;
         current_adv_steps--;

commit ca0def766e3b5bfc3710835cd9cfe7c1cdfb9c89
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 6 19:21:41 2018 -0600

    LIN_ADVANCE single stepper optimization

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 1df10ea759..fd4a3c3b59 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -122,8 +122,13 @@ volatile uint32_t Stepper::step_events_completed = 0; // The number of step even
            Stepper::final_adv_steps,
            Stepper::max_adv_steps;
 
-  int8_t Stepper::e_steps = 0,
-         Stepper::LA_active_extruder; // Copy from current executed block. Needed because current_block is set to NULL "too early".
+  int8_t Stepper::e_steps = 0;
+
+  #if E_STEPPERS > 1
+    int8_t Stepper::LA_active_extruder; // Copy from current executed block. Needed because current_block is set to NULL "too early".
+  #else
+    constexpr int8_t Stepper::LA_active_extruder;
+  #endif
 
   bool Stepper::use_advance_lead;
 

commit 8291ae34f2175c0234ff2d2b25b94dd21a514e69
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 6 19:00:38 2018 -0600

    Support duplication mode in LIN_ADVANCE

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index bf4aa41186..1df10ea759 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -755,23 +755,21 @@ void Stepper::isr() {
 
   void Stepper::advance_isr() {
 
-    #if ENABLED(MK2_MULTIPLEXER)
-      // Even-numbered steppers are reversed
-      #define SET_E_STEP_DIR(INDEX) \
-        if (e_steps) E## INDEX ##_DIR_WRITE(e_steps < 0 ? !INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0) : INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0))
+    #if ENABLED(MK2_MULTIPLEXER) // For SNMM even-numbered steppers are reversed
+      #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) E## INDEX ##_DIR_WRITE(e_steps < 0 ? !INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0) : INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0)); }while(0)
+    #elif ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+      #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) { e_steps < 0 ? REV_E_DIR() : NORM_E_DIR(); } }while(0)
     #else
-      #define SET_E_STEP_DIR(INDEX) \
-        if (e_steps) E## INDEX ##_DIR_WRITE(e_steps < 0 ? INVERT_E## INDEX ##_DIR : !INVERT_E## INDEX ##_DIR)
+      #define SET_E_STEP_DIR(INDEX) do{ if (e_steps) E## INDEX ##_DIR_WRITE(e_steps < 0 ? INVERT_E## INDEX ##_DIR : !INVERT_E## INDEX ##_DIR); }while(0)
     #endif
 
-    #define START_E_PULSE(INDEX) \
-      if (e_steps) E## INDEX ##_STEP_WRITE(!INVERT_E_STEP_PIN)
-
-    #define STOP_E_PULSE(INDEX) \
-      if (e_steps) { \
-        e_steps < 0 ? ++e_steps : --e_steps; \
-        E## INDEX ##_STEP_WRITE(INVERT_E_STEP_PIN); \
-      }
+    #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+      #define START_E_PULSE(INDEX) do{ if (e_steps) E_STEP_WRITE(!INVERT_E_STEP_PIN); }while(0)
+      #define STOP_E_PULSE(INDEX) do{ if (e_steps) { E_STEP_WRITE(INVERT_E_STEP_PIN); e_steps < 0 ? ++e_steps : --e_steps; } }while(0)
+    #else
+      #define START_E_PULSE(INDEX) do{ if (e_steps) E## INDEX ##_STEP_WRITE(!INVERT_E_STEP_PIN); }while(0)
+      #define STOP_E_PULSE(INDEX) do { if (e_steps) { E## INDEX ##_STEP_WRITE(INVERT_E_STEP_PIN); e_steps < 0 ? ++e_steps : --e_steps; } }while(0)
+    #endif
 
     if (current_block->use_advance_lead) {
       if (step_events_completed > LA_decelerate_after && current_adv_steps > final_adv_steps) {
@@ -793,7 +791,7 @@ void Stepper::isr() {
     else
       nextAdvanceISR = ADV_NEVER;
 
-    switch(LA_active_extruder) {
+    switch (LA_active_extruder) {
       case 0: SET_E_STEP_DIR(0); break;
       #if EXTRUDERS > 1
         case 1: SET_E_STEP_DIR(1); break;
@@ -816,7 +814,7 @@ void Stepper::isr() {
         hal_timer_t pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM);
       #endif
 
-      switch(LA_active_extruder) {
+      switch (LA_active_extruder) {
         case 0: START_E_PULSE(0); break;
         #if EXTRUDERS > 1
           case 1: START_E_PULSE(1); break;
@@ -840,7 +838,7 @@ void Stepper::isr() {
         DELAY_NOPS(EXTRA_CYCLES_E);
       #endif
 
-      switch(LA_active_extruder) {
+      switch (LA_active_extruder) {
         case 0: STOP_E_PULSE(0); break;
         #if EXTRUDERS > 1
           case 1: STOP_E_PULSE(1); break;

commit 0dd1c4458d505ca811efb697ae069dafcd028d7e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Mar 5 23:06:57 2018 -0600

    Put more code between pulse start and stop (#9959)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 6834cc642a..bf4aa41186 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -443,48 +443,24 @@ void Stepper::isr() {
   // Take multiple steps per interrupt (For high speed moves)
   bool all_steps_done = false;
   for (uint8_t i = step_loops; i--;) {
-    #if ENABLED(LIN_ADVANCE)
-
-      counter_E += current_block->steps[E_AXIS];
-      if (counter_E > 0) {
-        counter_E -= current_block->step_event_count;
-        #if DISABLED(MIXING_EXTRUDER)
-          // Don't step E here for mixing extruder
-          count_position[E_AXIS] += count_direction[E_AXIS];
-          motor_direction(E_AXIS) ? --e_steps : ++e_steps;
-        #endif
-      }
-
-      #if ENABLED(MIXING_EXTRUDER)
-        // Step mixing steppers proportionally
-        const bool dir = motor_direction(E_AXIS);
-        MIXING_STEPPERS_LOOP(j) {
-          counter_m[j] += current_block->steps[E_AXIS];
-          if (counter_m[j] > 0) {
-            counter_m[j] -= current_block->mix_event_count[j];
-            dir ? --e_steps[j] : ++e_steps[j];
-          }
-        }
-      #endif
-
-    #endif // LIN_ADVANCE
 
     #define _COUNTER(AXIS) counter_## AXIS
     #define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP
     #define _INVERT_STEP_PIN(AXIS) INVERT_## AXIS ##_STEP_PIN
 
     // Advance the Bresenham counter; start a pulse if the axis needs a step
-    #define PULSE_START(AXIS) \
+    #define PULSE_START(AXIS) do{ \
       _COUNTER(AXIS) += current_block->steps[_AXIS(AXIS)]; \
-      if (_COUNTER(AXIS) > 0) { _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS),0); }
+      if (_COUNTER(AXIS) > 0) _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), 0); }while(0)
 
-    // Stop an active pulse, reset the Bresenham counter, update the position
-    #define PULSE_STOP(AXIS) \
+    // Advance the Bresenham counter; start a pulse if the axis needs a step
+    #define STEP_TICK(AXIS) \
       if (_COUNTER(AXIS) > 0) { \
         _COUNTER(AXIS) -= current_block->step_event_count; \
-        count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \
-        _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS),0); \
-      }
+        count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; }
+
+    // Stop an active pulse, if any
+    #define PULSE_STOP(AXIS) _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), 0)
 
     /**
      * Estimate the number of cycles that the stepper logic already takes
@@ -563,8 +539,30 @@ void Stepper::isr() {
       PULSE_START(Z);
     #endif
 
-    // For non-advance use linear interpolation for E also
-    #if DISABLED(LIN_ADVANCE)
+    #if ENABLED(LIN_ADVANCE)
+
+      counter_E += current_block->steps[E_AXIS];
+      if (counter_E > 0) {
+        #if DISABLED(MIXING_EXTRUDER)
+          // Don't step E here for mixing extruder
+          motor_direction(E_AXIS) ? --e_steps : ++e_steps;
+        #endif
+      }
+
+      #if ENABLED(MIXING_EXTRUDER)
+        // Step mixing steppers proportionally
+        const bool dir = motor_direction(E_AXIS);
+        MIXING_STEPPERS_LOOP(j) {
+          counter_m[j] += current_block->steps[E_AXIS];
+          if (counter_m[j] > 0) {
+            counter_m[j] -= current_block->mix_event_count[j];
+            dir ? --e_steps[j] : ++e_steps[j];
+          }
+        }
+      #endif
+
+    #else // !LIN_ADVANCE - use linear interpolation for E also
+
       #if ENABLED(MIXING_EXTRUDER)
         // Keep updating the single E axis
         counter_E += current_block->steps[E_AXIS];
@@ -580,6 +578,18 @@ void Stepper::isr() {
       #endif
     #endif // !LIN_ADVANCE
 
+    #if HAS_X_STEP
+      STEP_TICK(X);
+    #endif
+    #if HAS_Y_STEP
+      STEP_TICK(Y);
+    #endif
+    #if HAS_Z_STEP
+      STEP_TICK(Z);
+    #endif
+
+    STEP_TICK(E); // Always tick the single E axis
+
     // For minimum pulse time wait before stopping pulses
     #if EXTRA_CYCLES_XYZE > 20
       while (EXTRA_CYCLES_XYZE > (uint32_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
@@ -600,11 +610,6 @@ void Stepper::isr() {
 
     #if DISABLED(LIN_ADVANCE)
       #if ENABLED(MIXING_EXTRUDER)
-        // Always step the single E axis
-        if (counter_E > 0) {
-          counter_E -= current_block->step_event_count;
-          count_position[E_AXIS] += count_direction[E_AXIS];
-        }
         MIXING_STEPPERS_LOOP(j) {
           if (counter_m[j] > 0) {
             counter_m[j] -= current_block->mix_event_count[j];
@@ -686,6 +691,7 @@ void Stepper::isr() {
 
     SPLIT(interval);  // split step into multiple ISRs if larger than ENDSTOP_NOMINAL_OCR_VAL
     _NEXT_ISR(ocr_val);
+
     deceleration_time += interval;
 
     #if ENABLED(LIN_ADVANCE)
@@ -714,6 +720,7 @@ void Stepper::isr() {
 
     SPLIT(OCR1A_nominal);  // split step into multiple ISRs if larger than ENDSTOP_NOMINAL_OCR_VAL
     _NEXT_ISR(ocr_val);
+
     // ensure we're running at the correct step rate, even if we just came off an acceleration
     step_loops = step_loops_nominal;
   }

commit 07ae23fe14851473c06d8a31b08c9d165e10bc09
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 4 15:06:22 2018 -0600

    No pulse delay on last e_steps in advance isr

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index bf06c3139b..6834cc642a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -851,9 +851,9 @@ void Stepper::isr() {
 
       // For minimum pulse time wait before looping
       #if EXTRA_CYCLES_E > 20
-        while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
+        if (e_steps) while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
       #elif EXTRA_CYCLES_E > 0
-        DELAY_NOPS(EXTRA_CYCLES_E);
+        if (e_steps) DELAY_NOPS(EXTRA_CYCLES_E);
       #endif
 
     } // e_steps

commit ed758de80d51912983a34c3448c4b25e31d58079
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 4 04:03:23 2018 -0600

    tweak comment in stepper.cpp

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 2f78f17c2b..bf06c3139b 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -856,7 +856,7 @@ void Stepper::isr() {
         DELAY_NOPS(EXTRA_CYCLES_E);
       #endif
 
-    } // steps_loop
+    } // e_steps
   }
 
   void Stepper::advance_isr_scheduler() {

commit 6d7f4f84e25f90aa8afe694d6ccf90788674db56
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 3 23:14:52 2018 -0600

    Add board MKS_BASE_HEROIC (#9926)
    
    Followup to #9008
    
    - Don't define micro-stepping pins for boards that lack them.
    - Allow setting of 128 microsteps with `M350`.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4a2707215d..2f78f17c2b 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1591,13 +1591,18 @@ void Stepper::report_positions() {
   void Stepper::microstep_mode(const uint8_t driver, const uint8_t stepping_mode) {
     switch (stepping_mode) {
       case 1: microstep_ms(driver, MICROSTEP1); break;
-      case 2: microstep_ms(driver, MICROSTEP2); break;
-      case 4: microstep_ms(driver, MICROSTEP4); break;
+      #if ENABLED(HEROIC_STEPPER_DRIVERS)
+        case 128: microstep_ms(driver, MICROSTEP128); break;
+      #else
+        case 2: microstep_ms(driver, MICROSTEP2); break;
+        case 4: microstep_ms(driver, MICROSTEP4); break;
+      #endif
       case 8: microstep_ms(driver, MICROSTEP8); break;
       case 16: microstep_ms(driver, MICROSTEP16); break;
       #if MB(ALLIGATOR)
         case 32: microstep_ms(driver, MICROSTEP32); break;
       #endif
+      default: SERIAL_ERROR_START(); SERIAL_ERRORLNPGM("Microsteps unavailable"); break;
     }
   }
 

commit cb4cb86d8075b97bd72b3e820649c95e2b47b754
Author: Sebastianv650 <sebastian.popp@vodafonemail.de>
Date:   Mon Feb 26 04:20:37 2018 +0100

    Useless line removed (#9814)
    
    nextAdvanceISR is set in the next if structure in every possible
    situation, so it's useless to set it once more before.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 2eb5b57758..4a2707215d 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -747,7 +747,6 @@ void Stepper::isr() {
   // Timer interrupt for E. e_steps is set in the main routine;
 
   void Stepper::advance_isr() {
-    nextAdvanceISR = eISR_Rate;
 
     #if ENABLED(MK2_MULTIPLEXER)
       // Even-numbered steppers are reversed

commit 813f9f308294cdddb28a958b56bf2b94889f58cc
Author: UtterlyD <35540980+UtterlyD@users.noreply.github.com>
Date:   Sat Feb 24 22:37:23 2018 +0000

    [bugfix_2.0.x] - LIN_ADVANCE V1.5 stepper.cpp (#9797)
    
    Removal of obsolete (i) from port of LIN_ADVANCE from V1.1.x to V2..0.x.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 9e7afe2c47..2eb5b57758 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -852,9 +852,9 @@ void Stepper::isr() {
 
       // For minimum pulse time wait before looping
       #if EXTRA_CYCLES_E > 20
-        if (i) while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
+        while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
       #elif EXTRA_CYCLES_E > 0
-        if (i) DELAY_NOPS(EXTRA_CYCLES_E);
+        DELAY_NOPS(EXTRA_CYCLES_E);
       #endif
 
     } // steps_loop

commit 2bd252b50149c860cf37d488762abcf70a83f78d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Feb 23 00:53:29 2018 -0600

    [2.0.x] LIN_ADVANCE v1.5 (#9712)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index d829858774..9e7afe2c47 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -111,31 +111,21 @@ volatile uint32_t Stepper::step_events_completed = 0; // The number of step even
 
 #if ENABLED(LIN_ADVANCE)
 
+  uint32_t Stepper::LA_decelerate_after;
+
   constexpr hal_timer_t ADV_NEVER = HAL_TIMER_TYPE_MAX;
 
   hal_timer_t Stepper::nextMainISR = 0,
               Stepper::nextAdvanceISR = ADV_NEVER,
               Stepper::eISR_Rate = ADV_NEVER;
+  uint16_t Stepper::current_adv_steps = 0,
+           Stepper::final_adv_steps,
+           Stepper::max_adv_steps;
 
-  volatile int Stepper::e_steps[E_STEPPERS];
-  int Stepper::final_estep_rate,
-      Stepper::current_estep_rate[E_STEPPERS],
-      Stepper::current_adv_steps[E_STEPPERS];
+  int8_t Stepper::e_steps = 0,
+         Stepper::LA_active_extruder; // Copy from current executed block. Needed because current_block is set to NULL "too early".
 
-  /**
-   * See https://github.com/MarlinFirmware/Marlin/issues/5699#issuecomment-309264382
-   *
-   * This fix isn't perfect and may lose steps - but better than locking up completely
-   * in future the planner should slow down if advance stepping rate would be too high
-   */
-  FORCE_INLINE hal_timer_t adv_rate(const int steps, const hal_timer_t timer, const uint8_t loops) {
-    if (steps) {
-      const hal_timer_t rate = (timer * loops) / abs(steps);
-      //return constrain(rate, 1, ADV_NEVER - 1)
-      return rate ? rate : 1;
-    }
-    return ADV_NEVER;
-  }
+  bool Stepper::use_advance_lead;
 
 #endif // LIN_ADVANCE
 
@@ -461,7 +451,7 @@ void Stepper::isr() {
         #if DISABLED(MIXING_EXTRUDER)
           // Don't step E here for mixing extruder
           count_position[E_AXIS] += count_direction[E_AXIS];
-          motor_direction(E_AXIS) ? --e_steps[TOOL_E_INDEX] : ++e_steps[TOOL_E_INDEX];
+          motor_direction(E_AXIS) ? --e_steps : ++e_steps;
         #endif
       }
 
@@ -640,25 +630,6 @@ void Stepper::isr() {
 
   } // steps_loop
 
-  #if ENABLED(LIN_ADVANCE)
-
-    if (current_block->use_advance_lead) {
-      const int delta_adv_steps = current_estep_rate[TOOL_E_INDEX] - current_adv_steps[TOOL_E_INDEX];
-      current_adv_steps[TOOL_E_INDEX] += delta_adv_steps;
-      #if ENABLED(MIXING_EXTRUDER)
-        // Mixing extruders apply advance lead proportionally
-        MIXING_STEPPERS_LOOP(j)
-          e_steps[j] += delta_adv_steps * current_block->step_event_count / current_block->mix_event_count[j];
-      #else
-        // For most extruders, advance the single E stepper
-        e_steps[TOOL_E_INDEX] += delta_adv_steps;
-      #endif
-    }
-    // If we have esteps to execute, fire the next advance_isr "now"
-    if (e_steps[TOOL_E_INDEX]) nextAdvanceISR = 0;
-
-  #endif // LIN_ADVANCE
-
   // Calculate new timer value
   if (step_events_completed <= (uint32_t)current_block->accelerate_until) {
 
@@ -683,14 +654,15 @@ void Stepper::isr() {
     #if ENABLED(LIN_ADVANCE)
 
       if (current_block->use_advance_lead) {
-        #if ENABLED(MIXING_EXTRUDER)
-          MIXING_STEPPERS_LOOP(j)
-            current_estep_rate[j] = ((uint32_t)acc_step_rate * current_block->abs_adv_steps_multiplier8 * current_block->step_event_count / current_block->mix_event_count[j]) >> 17;
-        #else
-          current_estep_rate[TOOL_E_INDEX] = ((uint32_t)acc_step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
-        #endif
+        if (step_events_completed == step_loops || (e_steps && eISR_Rate != current_block->advance_speed)) {
+          nextAdvanceISR = 0; // Wake up eISR on first acceleration loop and fire ISR if final adv_rate is reached
+          eISR_Rate = current_block->advance_speed;
+        }
+      }
+      else {
+        eISR_Rate = ADV_NEVER;
+        if (e_steps) nextAdvanceISR = 0;
       }
-      eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], interval, step_loops);
 
     #endif // LIN_ADVANCE
   }
@@ -719,14 +691,15 @@ void Stepper::isr() {
     #if ENABLED(LIN_ADVANCE)
 
       if (current_block->use_advance_lead) {
-        #if ENABLED(MIXING_EXTRUDER)
-          MIXING_STEPPERS_LOOP(j)
-            current_estep_rate[j] = ((uint32_t)step_rate * current_block->abs_adv_steps_multiplier8 * current_block->step_event_count / current_block->mix_event_count[j]) >> 17;
-        #else
-          current_estep_rate[TOOL_E_INDEX] = ((uint32_t)step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
-        #endif
+        if (step_events_completed <= (uint32_t)current_block->decelerate_after + step_loops || (e_steps && eISR_Rate != current_block->advance_speed)) {
+          nextAdvanceISR = 0; // Wake up eISR on first deceleration loop
+          eISR_Rate = current_block->advance_speed;
+        }
+      }
+      else {
+        eISR_Rate = ADV_NEVER;
+        if (e_steps) nextAdvanceISR = 0;
       }
-      eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], interval, step_loops);
 
     #endif // LIN_ADVANCE
   }
@@ -734,10 +707,8 @@ void Stepper::isr() {
 
     #if ENABLED(LIN_ADVANCE)
 
-      if (current_block->use_advance_lead)
-        current_estep_rate[TOOL_E_INDEX] = final_estep_rate;
-
-      eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], OCR1A_nominal, step_loops_nominal);
+      // If we have esteps to execute, fire the next advance_isr "now"
+      if (e_steps && eISR_Rate != current_block->advance_speed) nextAdvanceISR = 0;
 
     #endif
 
@@ -781,55 +752,79 @@ void Stepper::isr() {
     #if ENABLED(MK2_MULTIPLEXER)
       // Even-numbered steppers are reversed
       #define SET_E_STEP_DIR(INDEX) \
-        if (e_steps[INDEX]) E## INDEX ##_DIR_WRITE(e_steps[INDEX] < 0 ? !INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0) : INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0))
+        if (e_steps) E## INDEX ##_DIR_WRITE(e_steps < 0 ? !INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0) : INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0))
     #else
       #define SET_E_STEP_DIR(INDEX) \
-        if (e_steps[INDEX]) E## INDEX ##_DIR_WRITE(e_steps[INDEX] < 0 ? INVERT_E## INDEX ##_DIR : !INVERT_E## INDEX ##_DIR)
+        if (e_steps) E## INDEX ##_DIR_WRITE(e_steps < 0 ? INVERT_E## INDEX ##_DIR : !INVERT_E## INDEX ##_DIR)
     #endif
 
     #define START_E_PULSE(INDEX) \
-      if (e_steps[INDEX]) E## INDEX ##_STEP_WRITE(!INVERT_E_STEP_PIN)
+      if (e_steps) E## INDEX ##_STEP_WRITE(!INVERT_E_STEP_PIN)
 
     #define STOP_E_PULSE(INDEX) \
-      if (e_steps[INDEX]) { \
-        e_steps[INDEX] < 0 ? ++e_steps[INDEX] : --e_steps[INDEX]; \
+      if (e_steps) { \
+        e_steps < 0 ? ++e_steps : --e_steps; \
         E## INDEX ##_STEP_WRITE(INVERT_E_STEP_PIN); \
       }
 
-    SET_E_STEP_DIR(0);
-    #if E_STEPPERS > 1
-      SET_E_STEP_DIR(1);
-      #if E_STEPPERS > 2
-        SET_E_STEP_DIR(2);
-        #if E_STEPPERS > 3
-          SET_E_STEP_DIR(3);
-          #if E_STEPPERS > 4
-            SET_E_STEP_DIR(4);
-          #endif
-        #endif
-      #endif
-    #endif
+    if (current_block->use_advance_lead) {
+      if (step_events_completed > LA_decelerate_after && current_adv_steps > final_adv_steps) {
+        e_steps--;
+        current_adv_steps--;
+        nextAdvanceISR = eISR_Rate;
+      }
+      else if (step_events_completed < LA_decelerate_after && current_adv_steps < max_adv_steps) {
+             //step_events_completed <= (uint32_t)current_block->accelerate_until) {
+        e_steps++;
+        current_adv_steps++;
+        nextAdvanceISR = eISR_Rate;
+      }
+      else {
+        nextAdvanceISR = ADV_NEVER;
+        eISR_Rate = ADV_NEVER;
+      }
+    }
+    else
+      nextAdvanceISR = ADV_NEVER;
+
+    switch(LA_active_extruder) {
+      case 0: SET_E_STEP_DIR(0); break;
+      #if EXTRUDERS > 1
+        case 1: SET_E_STEP_DIR(1); break;
+        #if EXTRUDERS > 2
+          case 2: SET_E_STEP_DIR(2); break;
+          #if EXTRUDERS > 3
+            case 3: SET_E_STEP_DIR(3); break;
+            #if EXTRUDERS > 4
+              case 4: SET_E_STEP_DIR(4); break;
+            #endif // EXTRUDERS > 4
+          #endif // EXTRUDERS > 3
+        #endif // EXTRUDERS > 2
+      #endif // EXTRUDERS > 1
+    }
 
-    // Step all E steppers that have steps
-    for (uint8_t i = step_loops; i--;) {
+    // Step E stepper if we have steps
+    while (e_steps) {
 
       #if EXTRA_CYCLES_E > 20
         hal_timer_t pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM);
       #endif
 
-      START_E_PULSE(0);
-      #if E_STEPPERS > 1
-        START_E_PULSE(1);
-        #if E_STEPPERS > 2
-          START_E_PULSE(2);
-          #if E_STEPPERS > 3
-            START_E_PULSE(3);
-            #if E_STEPPERS > 4
-              START_E_PULSE(4);
-            #endif
-          #endif
-        #endif
-      #endif
+      switch(LA_active_extruder) {
+        case 0: START_E_PULSE(0); break;
+        #if EXTRUDERS > 1
+          case 1: START_E_PULSE(1); break;
+          #if EXTRUDERS > 2
+            case 2: START_E_PULSE(2); break;
+            #if EXTRUDERS > 3
+              case 3: START_E_PULSE(3); break;
+              #if EXTRUDERS > 4
+                case 4: START_E_PULSE(4); break;
+              #endif // EXTRUDERS > 4
+            #endif // EXTRUDERS > 3
+          #endif // EXTRUDERS > 2
+        #endif // EXTRUDERS > 1
+      }
 
       // For minimum pulse time wait before stopping pulses
       #if EXTRA_CYCLES_E > 20
@@ -839,19 +834,21 @@ void Stepper::isr() {
         DELAY_NOPS(EXTRA_CYCLES_E);
       #endif
 
-      STOP_E_PULSE(0);
-      #if E_STEPPERS > 1
-        STOP_E_PULSE(1);
-        #if E_STEPPERS > 2
-          STOP_E_PULSE(2);
-          #if E_STEPPERS > 3
-            STOP_E_PULSE(3);
-            #if E_STEPPERS > 4
-              STOP_E_PULSE(4);
-            #endif
-          #endif
-        #endif
-      #endif
+      switch(LA_active_extruder) {
+        case 0: STOP_E_PULSE(0); break;
+        #if EXTRUDERS > 1
+          case 1: STOP_E_PULSE(1); break;
+          #if EXTRUDERS > 2
+            case 2: STOP_E_PULSE(2); break;
+            #if EXTRUDERS > 3
+              case 3: STOP_E_PULSE(3); break;
+              #if EXTRUDERS > 4
+                case 4: STOP_E_PULSE(4); break;
+              #endif // EXTRUDERS > 4
+            #endif // EXTRUDERS > 3
+          #endif // EXTRUDERS > 2
+        #endif // EXTRUDERS > 1
+      }
 
       // For minimum pulse time wait before looping
       #if EXTRA_CYCLES_E > 20
@@ -1116,11 +1113,6 @@ void Stepper::init() {
 
   ENABLE_STEPPER_DRIVER_INTERRUPT();
 
-  #if ENABLED(LIN_ADVANCE)
-    for (uint8_t i = 0; i < COUNT(e_steps); i++) e_steps[i] = 0;
-    ZERO(current_adv_steps);
-  #endif
-
   endstops.enable(true); // Start with endstops active. After homing they can be disabled
   sei();
 

commit 3d1692d1fdbb0a11eaeb3ae04e285a9a407d744e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 18 22:08:18 2018 -0600

    Fix X2 enable with X_DUAL_STEPPER_DRIVERS
    
    From #9286

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 7e59702b24..d829858774 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -995,7 +995,7 @@ void Stepper::init() {
   #if HAS_X_ENABLE
     X_ENABLE_INIT;
     if (!X_ENABLE_ON) X_ENABLE_WRITE(HIGH);
-    #if ENABLED(DUAL_X_CARRIAGE) && HAS_X2_ENABLE
+    #if (ENABLED(DUAL_X_CARRIAGE) || ENABLED(X_DUAL_STEPPER_DRIVERS)) && HAS_X2_ENABLE
       X2_ENABLE_INIT;
       if (!X_ENABLE_ON) X2_ENABLE_WRITE(HIGH);
     #endif

commit 03d790451f7bd523dff6c2d4689b1a0360e67689
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 10 20:42:00 2018 -0600

    [2.0.x] HAL timer set/get count => set/get compare (#9581)
    
    To reduce confusion over the current timer count vs. the compare (aka "top") value. Caution: this re-uses the function name, changing its meaning.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 5fe7eff561..7e59702b24 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -371,7 +371,7 @@ void Stepper::isr() {
 
     #if DISABLED(LIN_ADVANCE)
       #ifdef CPU_32_BIT
-        HAL_timer_set_count(STEP_TIMER_NUM, ocr_val);
+        HAL_timer_set_compare(STEP_TIMER_NUM, ocr_val);
       #else
         NOLESS(OCR1A, TCNT1 + 16);
       #endif
@@ -560,7 +560,7 @@ void Stepper::isr() {
      * 10µs = 160 or 200 cycles.
      */
     #if EXTRA_CYCLES_XYZE > 20
-      hal_timer_t pulse_start = HAL_timer_get_current_count(PULSE_TIMER_NUM);
+      hal_timer_t pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM);
     #endif
 
     #if HAS_X_STEP
@@ -592,8 +592,8 @@ void Stepper::isr() {
 
     // For minimum pulse time wait before stopping pulses
     #if EXTRA_CYCLES_XYZE > 20
-      while (EXTRA_CYCLES_XYZE > (uint32_t)(HAL_timer_get_current_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
-      pulse_start = HAL_timer_get_current_count(PULSE_TIMER_NUM);
+      while (EXTRA_CYCLES_XYZE > (uint32_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
+      pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM);
     #elif EXTRA_CYCLES_XYZE > 0
       DELAY_NOPS(EXTRA_CYCLES_XYZE);
     #endif
@@ -633,7 +633,7 @@ void Stepper::isr() {
 
     // For minimum pulse time wait after stopping pulses also
     #if EXTRA_CYCLES_XYZE > 20
-      if (i) while (EXTRA_CYCLES_XYZE > (uint32_t)(HAL_timer_get_current_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
+      if (i) while (EXTRA_CYCLES_XYZE > (uint32_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
     #elif EXTRA_CYCLES_XYZE > 0
       if (i) DELAY_NOPS(EXTRA_CYCLES_XYZE);
     #endif
@@ -750,9 +750,9 @@ void Stepper::isr() {
   #if DISABLED(LIN_ADVANCE)
     #ifdef CPU_32_BIT
       // Make sure stepper interrupt does not monopolise CPU by adjusting count to give about 8 us room
-      hal_timer_t stepper_timer_count = HAL_timer_get_count(STEP_TIMER_NUM),
-                  stepper_timer_current_count = HAL_timer_get_current_count(STEP_TIMER_NUM) + 8 * HAL_TICKS_PER_US;
-      HAL_timer_set_count(STEP_TIMER_NUM, max(stepper_timer_count, stepper_timer_current_count));
+      hal_timer_t stepper_timer_count = HAL_timer_get_compare(STEP_TIMER_NUM),
+                  stepper_timer_current_count = HAL_timer_get_count(STEP_TIMER_NUM) + 8 * HAL_TICKS_PER_US;
+      HAL_timer_set_compare(STEP_TIMER_NUM, max(stepper_timer_count, stepper_timer_current_count));
     #else
       NOLESS(OCR1A, TCNT1 + 16);
     #endif
@@ -814,7 +814,7 @@ void Stepper::isr() {
     for (uint8_t i = step_loops; i--;) {
 
       #if EXTRA_CYCLES_E > 20
-        hal_timer_t pulse_start = HAL_timer_get_current_count(PULSE_TIMER_NUM);
+        hal_timer_t pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM);
       #endif
 
       START_E_PULSE(0);
@@ -833,8 +833,8 @@ void Stepper::isr() {
 
       // For minimum pulse time wait before stopping pulses
       #if EXTRA_CYCLES_E > 20
-        while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_current_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
-        pulse_start = HAL_timer_get_current_count(PULSE_TIMER_NUM);
+        while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
+        pulse_start = HAL_timer_get_count(PULSE_TIMER_NUM);
       #elif EXTRA_CYCLES_E > 0
         DELAY_NOPS(EXTRA_CYCLES_E);
       #endif
@@ -855,7 +855,7 @@ void Stepper::isr() {
 
       // For minimum pulse time wait before looping
       #if EXTRA_CYCLES_E > 20
-        if (i) while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_current_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
+        if (i) while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
       #elif EXTRA_CYCLES_E > 0
         if (i) DELAY_NOPS(EXTRA_CYCLES_E);
       #endif
@@ -878,7 +878,7 @@ void Stepper::isr() {
     // Is the next advance ISR scheduled before the next main ISR?
     if (nextAdvanceISR <= nextMainISR) {
       // Set up the next interrupt
-      HAL_timer_set_count(STEP_TIMER_NUM, nextAdvanceISR);
+      HAL_timer_set_compare(STEP_TIMER_NUM, nextAdvanceISR);
       // New interval for the next main ISR
       if (nextMainISR) nextMainISR -= nextAdvanceISR;
       // Will call Stepper::advance_isr on the next interrupt
@@ -886,7 +886,7 @@ void Stepper::isr() {
     }
     else {
       // The next main ISR comes first
-      HAL_timer_set_count(STEP_TIMER_NUM, nextMainISR);
+      HAL_timer_set_compare(STEP_TIMER_NUM, nextMainISR);
       // New interval for the next advance ISR, if any
       if (nextAdvanceISR && nextAdvanceISR != ADV_NEVER)
         nextAdvanceISR -= nextMainISR;
@@ -897,9 +897,9 @@ void Stepper::isr() {
     // Don't run the ISR faster than possible
     #ifdef CPU_32_BIT
       // Make sure stepper interrupt does not monopolise CPU by adjusting count to give about 8 us room
-      uint32_t stepper_timer_count = HAL_timer_get_count(STEP_TIMER_NUM),
-               stepper_timer_current_count = HAL_timer_get_current_count(STEP_TIMER_NUM) + 8 * HAL_TICKS_PER_US;
-      HAL_timer_set_count(STEP_TIMER_NUM, max(stepper_timer_count, stepper_timer_current_count));
+      uint32_t stepper_timer_count = HAL_timer_get_compare(STEP_TIMER_NUM),
+               stepper_timer_current_count = HAL_timer_get_count(STEP_TIMER_NUM) + 8 * HAL_TICKS_PER_US;
+      HAL_timer_set_compare(STEP_TIMER_NUM, max(stepper_timer_count, stepper_timer_current_count));
     #else
       NOLESS(OCR1A, TCNT1 + 16);
     #endif
@@ -1304,8 +1304,8 @@ void Stepper::report_positions() {
   #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)
 
   #if EXTRA_CYCLES_BABYSTEP > 20
-    #define _SAVE_START const hal_timer_t pulse_start = HAL_timer_get_current_count(STEP_TIMER_NUM)
-    #define _PULSE_WAIT while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(HAL_timer_get_current_count(STEP_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
+    #define _SAVE_START const hal_timer_t pulse_start = HAL_timer_get_count(STEP_TIMER_NUM)
+    #define _PULSE_WAIT while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(HAL_timer_get_count(STEP_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
   #else
     #define _SAVE_START NOOP
     #if EXTRA_CYCLES_BABYSTEP > 0

commit d168ee9bed1b025942d436fcaf94c149bf27cad1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 8 01:32:19 2018 -0600

    Drop leveling include from steppers.cpp

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 471be7aa88..5fe7eff561 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -65,10 +65,6 @@
   #include "../feature/dac/dac_dac084s085.h"
 #endif
 
-#if HAS_LEVELING
-  #include "../feature/bedlevel/bedlevel.h"
-#endif
-
 #if HAS_DIGIPOTSS
   #include <SPI.h>
 #endif

commit 887664aa61bb92c25ed2b5ba29fae3e275e4c145
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jan 20 15:08:50 2018 -0600

    Restore broken Dual X Carriage

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 143e512fd2..471be7aa88 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -185,28 +185,28 @@ volatile long Stepper::endstops_trigsteps[XYZ];
 
 #if ENABLED(X_DUAL_STEPPER_DRIVERS)
   #define X_APPLY_DIR(v,Q) do{ X_DIR_WRITE(v); X2_DIR_WRITE((v) != INVERT_X2_VS_X_DIR); }while(0)
-  #if ENABLED(DUAL_X_CARRIAGE)
-    #define X_APPLY_DIR(v,ALWAYS) \
-      if (extruder_duplication_enabled || ALWAYS) { \
-        X_DIR_WRITE(v); \
-        X2_DIR_WRITE(v); \
-      } \
-      else { \
-        if (current_block->active_extruder) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \
-      }
-    #define X_APPLY_STEP(v,ALWAYS) \
-      if (extruder_duplication_enabled || ALWAYS) { \
-        X_STEP_WRITE(v); \
-        X2_STEP_WRITE(v); \
-      } \
-      else { \
-        if (current_block->active_extruder) X2_STEP_WRITE(v); else X_STEP_WRITE(v); \
-      }
-  #elif ENABLED(X_DUAL_ENDSTOPS)
+  #if ENABLED(X_DUAL_ENDSTOPS)
     #define X_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(X,v)
   #else
     #define X_APPLY_STEP(v,Q) do{ X_STEP_WRITE(v); X2_STEP_WRITE(v); }while(0)
   #endif
+#elif ENABLED(DUAL_X_CARRIAGE)
+  #define X_APPLY_DIR(v,ALWAYS) \
+    if (extruder_duplication_enabled || ALWAYS) { \
+      X_DIR_WRITE(v); \
+      X2_DIR_WRITE(v); \
+    } \
+    else { \
+      if (current_block->active_extruder) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \
+    }
+  #define X_APPLY_STEP(v,ALWAYS) \
+    if (extruder_duplication_enabled || ALWAYS) { \
+      X_STEP_WRITE(v); \
+      X2_STEP_WRITE(v); \
+    } \
+    else { \
+      if (current_block->active_extruder) X2_STEP_WRITE(v); else X_STEP_WRITE(v); \
+    }
 #else
   #define X_APPLY_DIR(v,Q) X_DIR_WRITE(v)
   #define X_APPLY_STEP(v,Q) X_STEP_WRITE(v)

commit 50366b00d570c682316dff2d37642248dd41b18f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 24 20:34:50 2017 -0600

    Tweak cleaning buffer / SD finished command

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4372db6b2a..143e512fd2 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -397,8 +397,8 @@ void Stepper::isr() {
     else {
       planner.discard_current_block();
       --cleaning_buffer_counter;                // Count down for abort print
-      #ifdef SD_FINISHED_RELEASECOMMAND
-        if (!cleaning_buffer_counter && (SD_FINISHED_STEPPERRELEASE)) enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
+      #if ENABLED(SD_FINISHED_STEPPERRELEASE) && defined(SD_FINISHED_RELEASECOMMAND)
+        if (!cleaning_buffer_counter) enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
       #endif
     }
     current_block = NULL;                       // Prep to get a new block after cleaning

commit 8df5955da46d94539eab890a599aaa75b502ee9b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 17 02:37:35 2017 -0600

    Revert "Reset timer count before first block step"
    
    This reverts commit 5cf6a062e315e7c0936f60ba6bf11d7f8fb1f20c.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 2d78fa6b0f..4372db6b2a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -408,13 +408,10 @@ void Stepper::isr() {
   }
 
   // If there is no current block, attempt to pop one from the buffer
-  bool first_step = false;
   if (!current_block) {
     // Anything in the buffer?
     if ((current_block = planner.get_current_block())) {
       trapezoid_generator_reset();
-      HAL_timer_set_current_count(STEP_TIMER_NUM, 0);
-      first_step = true;
 
       // Initialize Bresenham counters to 1/2 the ceiling
       counter_X = counter_Y = counter_Z = counter_E = -(current_block->step_event_count >> 1);
@@ -669,18 +666,12 @@ void Stepper::isr() {
   // Calculate new timer value
   if (step_events_completed <= (uint32_t)current_block->accelerate_until) {
 
-    if (first_step) {
-      acc_step_rate = current_block->initial_rate;
-      acceleration_time = 0;
-    }
-    else {
-      #ifdef CPU_32_BIT
-        MultiU32X24toH32(acc_step_rate, acceleration_time, current_block->acceleration_rate);
-      #else
-        MultiU24X32toH16(acc_step_rate, acceleration_time, current_block->acceleration_rate);
-      #endif
-      acc_step_rate += current_block->initial_rate;
-    }
+    #ifdef CPU_32_BIT
+      MultiU32X24toH32(acc_step_rate, acceleration_time, current_block->acceleration_rate);
+    #else
+      MultiU24X32toH16(acc_step_rate, acceleration_time, current_block->acceleration_rate);
+    #endif
+    acc_step_rate += current_block->initial_rate;
 
     // upper limit
     NOMORE(acc_step_rate, current_block->nominal_rate);

commit 0cd1e91056213d6a0bd422848ccff7cd1191d001
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 15 23:03:14 2017 +0200

    [2.0.x] TMC driver update (#8769)

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 6e630c6d1a..2d78fa6b0f 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -954,6 +954,16 @@ void Stepper::init() {
     tmc2130_init();
   #endif
 
+  // Init TMC2208 Steppers
+  #if ENABLED(HAVE_TMC2208)
+    tmc2208_init();
+  #endif
+
+  // TRAMS, TMC2130 and TMC2208 advanced settings
+  #if HAS_TRINAMIC
+    TMC_ADV()
+  #endif
+
   // Init L6470 Steppers
   #if ENABLED(HAVE_L6470DRIVER)
     L6470_init();

commit cf2193c07ffc07597ece619da2db8cc587f68479
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 13 02:32:34 2017 -0600

    Comment, fix filament width sensor

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c8e4203e85..6e630c6d1a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -688,7 +688,7 @@ void Stepper::isr() {
     // step_rate to timer interval
     const hal_timer_t interval = calc_timer_interval(acc_step_rate);
 
-    SPLIT(interval);  // split step into multiple ISRs if larger than  ENDSTOP_NOMINAL_OCR_VAL
+    SPLIT(interval);  // split step into multiple ISRs if larger than ENDSTOP_NOMINAL_OCR_VAL
     _NEXT_ISR(ocr_val);
 
     acceleration_time += interval;
@@ -725,7 +725,7 @@ void Stepper::isr() {
     // step_rate to timer interval
     const hal_timer_t interval = calc_timer_interval(step_rate);
 
-    SPLIT(interval);  // split step into multiple ISRs if larger than  ENDSTOP_NOMINAL_OCR_VAL
+    SPLIT(interval);  // split step into multiple ISRs if larger than ENDSTOP_NOMINAL_OCR_VAL
     _NEXT_ISR(ocr_val);
     deceleration_time += interval;
 
@@ -754,7 +754,7 @@ void Stepper::isr() {
 
     #endif
 
-    SPLIT(OCR1A_nominal);  // split step into multiple ISRs if larger than  ENDSTOP_NOMINAL_OCR_VAL
+    SPLIT(OCR1A_nominal);  // split step into multiple ISRs if larger than ENDSTOP_NOMINAL_OCR_VAL
     _NEXT_ISR(ocr_val);
     // ensure we're running at the correct step rate, even if we just came off an acceleration
     step_loops = step_loops_nominal;

commit 73e32925e4b140fe23f62eeb658f807e4477d872
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 02:10:54 2017 -0600

    References are better for array args

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index cbb227d936..c8e4203e85 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1193,7 +1193,7 @@ void Stepper::set_e_position(const long &e) {
 /**
  * Get a stepper's position in steps.
  */
-long Stepper::position(AxisEnum axis) {
+long Stepper::position(const AxisEnum axis) {
   CRITICAL_SECTION_START;
   const long count_pos = count_position[axis];
   CRITICAL_SECTION_END;
@@ -1204,7 +1204,7 @@ long Stepper::position(AxisEnum axis) {
  * Get an axis position according to stepper position(s)
  * For CORE machines apply translation from ABC to XYZ.
  */
-float Stepper::get_axis_position_mm(AxisEnum axis) {
+float Stepper::get_axis_position_mm(const AxisEnum axis) {
   float axis_steps;
   #if IS_CORE
     // Requesting one of the "core" axes?
@@ -1242,7 +1242,7 @@ void Stepper::quick_stop() {
   #endif
 }
 
-void Stepper::endstop_triggered(AxisEnum axis) {
+void Stepper::endstop_triggered(const AxisEnum axis) {
 
   #if IS_CORE
 

commit 5cf6a062e315e7c0936f60ba6bf11d7f8fb1f20c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 18:41:15 2017 -0600

    Reset timer count before first block step

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c3f03cdbe3..cbb227d936 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -408,10 +408,13 @@ void Stepper::isr() {
   }
 
   // If there is no current block, attempt to pop one from the buffer
+  bool first_step = false;
   if (!current_block) {
     // Anything in the buffer?
     if ((current_block = planner.get_current_block())) {
       trapezoid_generator_reset();
+      HAL_timer_set_current_count(STEP_TIMER_NUM, 0);
+      first_step = true;
 
       // Initialize Bresenham counters to 1/2 the ceiling
       counter_X = counter_Y = counter_Z = counter_E = -(current_block->step_event_count >> 1);
@@ -666,12 +669,18 @@ void Stepper::isr() {
   // Calculate new timer value
   if (step_events_completed <= (uint32_t)current_block->accelerate_until) {
 
-    #ifdef CPU_32_BIT
-      MultiU32X24toH32(acc_step_rate, acceleration_time, current_block->acceleration_rate);
-    #else
-      MultiU24X32toH16(acc_step_rate, acceleration_time, current_block->acceleration_rate);
-    #endif
-    acc_step_rate += current_block->initial_rate;
+    if (first_step) {
+      acc_step_rate = current_block->initial_rate;
+      acceleration_time = 0;
+    }
+    else {
+      #ifdef CPU_32_BIT
+        MultiU32X24toH32(acc_step_rate, acceleration_time, current_block->acceleration_rate);
+      #else
+        MultiU24X32toH16(acc_step_rate, acceleration_time, current_block->acceleration_rate);
+      #endif
+      acc_step_rate += current_block->initial_rate;
+    }
 
     // upper limit
     NOMORE(acc_step_rate, current_block->nominal_rate);

commit 82ef6b52420b47004fea9c34c6bf445157a7f9bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 19:59:12 2017 -0600

    Add an option to specify "pulse" timer

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 77da0b26fd..c3f03cdbe3 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -564,7 +564,7 @@ void Stepper::isr() {
      * 10µs = 160 or 200 cycles.
      */
     #if EXTRA_CYCLES_XYZE > 20
-      hal_timer_t pulse_start = HAL_timer_get_current_count(STEP_TIMER_NUM);
+      hal_timer_t pulse_start = HAL_timer_get_current_count(PULSE_TIMER_NUM);
     #endif
 
     #if HAS_X_STEP
@@ -596,8 +596,8 @@ void Stepper::isr() {
 
     // For minimum pulse time wait before stopping pulses
     #if EXTRA_CYCLES_XYZE > 20
-      while (EXTRA_CYCLES_XYZE > (uint32_t)(HAL_timer_get_current_count(STEP_TIMER_NUM) - pulse_start) * (STEPPER_TIMER_PRESCALE)) { /* nada */ }
-      pulse_start = HAL_timer_get_current_count(STEP_TIMER_NUM);
+      while (EXTRA_CYCLES_XYZE > (uint32_t)(HAL_timer_get_current_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
+      pulse_start = HAL_timer_get_current_count(PULSE_TIMER_NUM);
     #elif EXTRA_CYCLES_XYZE > 0
       DELAY_NOPS(EXTRA_CYCLES_XYZE);
     #endif
@@ -637,7 +637,7 @@ void Stepper::isr() {
 
     // For minimum pulse time wait after stopping pulses also
     #if EXTRA_CYCLES_XYZE > 20
-      if (i) while (EXTRA_CYCLES_XYZE > (uint32_t)(HAL_timer_get_current_count(STEP_TIMER_NUM) - pulse_start) * (STEPPER_TIMER_PRESCALE)) { /* nada */ }
+      if (i) while (EXTRA_CYCLES_XYZE > (uint32_t)(HAL_timer_get_current_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
     #elif EXTRA_CYCLES_XYZE > 0
       if (i) DELAY_NOPS(EXTRA_CYCLES_XYZE);
     #endif
@@ -818,7 +818,7 @@ void Stepper::isr() {
     for (uint8_t i = step_loops; i--;) {
 
       #if EXTRA_CYCLES_E > 20
-        hal_timer_t pulse_start = HAL_timer_get_current_count(STEP_TIMER_NUM);
+        hal_timer_t pulse_start = HAL_timer_get_current_count(PULSE_TIMER_NUM);
       #endif
 
       START_E_PULSE(0);
@@ -837,8 +837,8 @@ void Stepper::isr() {
 
       // For minimum pulse time wait before stopping pulses
       #if EXTRA_CYCLES_E > 20
-        while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_current_count(STEP_TIMER_NUM) - pulse_start) * (STEPPER_TIMER_PRESCALE)) { /* nada */ }
-        pulse_start = HAL_timer_get_current_count(STEP_TIMER_NUM);
+        while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_current_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
+        pulse_start = HAL_timer_get_current_count(PULSE_TIMER_NUM);
       #elif EXTRA_CYCLES_E > 0
         DELAY_NOPS(EXTRA_CYCLES_E);
       #endif
@@ -859,7 +859,7 @@ void Stepper::isr() {
 
       // For minimum pulse time wait before looping
       #if EXTRA_CYCLES_E > 20
-        if (i) while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_current_count(STEP_TIMER_NUM) - pulse_start) * (STEPPER_TIMER_PRESCALE)) { /* nada */ }
+        if (i) while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_current_count(PULSE_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
       #elif EXTRA_CYCLES_E > 0
         if (i) DELAY_NOPS(EXTRA_CYCLES_E);
       #endif
@@ -1299,7 +1299,7 @@ void Stepper::report_positions() {
 
   #if EXTRA_CYCLES_BABYSTEP > 20
     #define _SAVE_START const hal_timer_t pulse_start = HAL_timer_get_current_count(STEP_TIMER_NUM)
-    #define _PULSE_WAIT while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(HAL_timer_get_current_count(STEP_TIMER_NUM) - pulse_start) * (STEPPER_TIMER_PRESCALE)) { /* nada */ }
+    #define _PULSE_WAIT while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(HAL_timer_get_current_count(STEP_TIMER_NUM) - pulse_start) * (PULSE_TIMER_PRESCALE)) { /* nada */ }
   #else
     #define _SAVE_START NOOP
     #if EXTRA_CYCLES_BABYSTEP > 0

commit 4fa65a5c25d8e4771359b0d562b631769183f5f1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 8 22:13:03 2017 -0600

    TCNT0 => HAL_timer_get_current_count
    
    Fix #8710

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index d311fe6a2a..77da0b26fd 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -118,8 +118,8 @@ volatile uint32_t Stepper::step_events_completed = 0; // The number of step even
   constexpr hal_timer_t ADV_NEVER = HAL_TIMER_TYPE_MAX;
 
   hal_timer_t Stepper::nextMainISR = 0,
-         Stepper::nextAdvanceISR = ADV_NEVER,
-         Stepper::eISR_Rate = ADV_NEVER;
+              Stepper::nextAdvanceISR = ADV_NEVER,
+              Stepper::eISR_Rate = ADV_NEVER;
 
   volatile int Stepper::e_steps[E_STEPPERS];
   int Stepper::final_estep_rate,
@@ -152,9 +152,10 @@ volatile signed char Stepper::count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
   long Stepper::counter_m[MIXING_STEPPERS];
 #endif
 
-hal_timer_t Stepper::acc_step_rate; // needed for deceleration start point
 uint8_t Stepper::step_loops, Stepper::step_loops_nominal;
-hal_timer_t Stepper::OCR1A_nominal;
+
+hal_timer_t Stepper::OCR1A_nominal,
+            Stepper::acc_step_rate; // needed for deceleration start point
 
 volatile long Stepper::endstops_trigsteps[XYZ];
 
@@ -557,13 +558,13 @@ void Stepper::isr() {
     /**
      * If a minimum pulse time was specified get the timer 0 value.
      *
-     * TCNT0 has an 8x prescaler, so it increments every 8 cycles.
+     * On AVR the TCNT0 timer has an 8x prescaler, so it increments every 8 cycles.
      * That's every 0.5µs on 16MHz and every 0.4µs on 20MHz.
      * 20 counts of TCNT0 -by itself- is a good pulse delay.
      * 10µs = 160 or 200 cycles.
      */
     #if EXTRA_CYCLES_XYZE > 20
-      uint32_t pulse_start = HAL_timer_get_current_count(STEP_TIMER_NUM);
+      hal_timer_t pulse_start = HAL_timer_get_current_count(STEP_TIMER_NUM);
     #endif
 
     #if HAS_X_STEP
@@ -676,12 +677,12 @@ void Stepper::isr() {
     NOMORE(acc_step_rate, current_block->nominal_rate);
 
     // step_rate to timer interval
-    const hal_timer_t timer = calc_timer(acc_step_rate);
+    const hal_timer_t interval = calc_timer_interval(acc_step_rate);
 
-    SPLIT(timer);  // split step into multiple ISRs if larger than  ENDSTOP_NOMINAL_OCR_VAL
+    SPLIT(interval);  // split step into multiple ISRs if larger than  ENDSTOP_NOMINAL_OCR_VAL
     _NEXT_ISR(ocr_val);
 
-    acceleration_time += timer;
+    acceleration_time += interval;
 
     #if ENABLED(LIN_ADVANCE)
 
@@ -693,7 +694,7 @@ void Stepper::isr() {
           current_estep_rate[TOOL_E_INDEX] = ((uint32_t)acc_step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
         #endif
       }
-      eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], timer, step_loops);
+      eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], interval, step_loops);
 
     #endif // LIN_ADVANCE
   }
@@ -713,11 +714,11 @@ void Stepper::isr() {
       step_rate = current_block->final_rate;
 
     // step_rate to timer interval
-    const hal_timer_t timer = calc_timer(step_rate);
+    const hal_timer_t interval = calc_timer_interval(step_rate);
 
-    SPLIT(timer);  // split step into multiple ISRs if larger than  ENDSTOP_NOMINAL_OCR_VAL
+    SPLIT(interval);  // split step into multiple ISRs if larger than  ENDSTOP_NOMINAL_OCR_VAL
     _NEXT_ISR(ocr_val);
-    deceleration_time += timer;
+    deceleration_time += interval;
 
     #if ENABLED(LIN_ADVANCE)
 
@@ -729,7 +730,7 @@ void Stepper::isr() {
           current_estep_rate[TOOL_E_INDEX] = ((uint32_t)step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
         #endif
       }
-      eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], timer, step_loops);
+      eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], interval, step_loops);
 
     #endif // LIN_ADVANCE
   }
@@ -754,7 +755,7 @@ void Stepper::isr() {
     #ifdef CPU_32_BIT
       // Make sure stepper interrupt does not monopolise CPU by adjusting count to give about 8 us room
       hal_timer_t stepper_timer_count = HAL_timer_get_count(STEP_TIMER_NUM),
-                     stepper_timer_current_count = HAL_timer_get_current_count(STEP_TIMER_NUM) + 8 * HAL_TICKS_PER_US;
+                  stepper_timer_current_count = HAL_timer_get_current_count(STEP_TIMER_NUM) + 8 * HAL_TICKS_PER_US;
       HAL_timer_set_count(STEP_TIMER_NUM, max(stepper_timer_count, stepper_timer_current_count));
     #else
       NOLESS(OCR1A, TCNT1 + 16);
@@ -817,7 +818,7 @@ void Stepper::isr() {
     for (uint8_t i = step_loops; i--;) {
 
       #if EXTRA_CYCLES_E > 20
-        uint32_t pulse_start = TCNT0;
+        hal_timer_t pulse_start = HAL_timer_get_current_count(STEP_TIMER_NUM);
       #endif
 
       START_E_PULSE(0);
@@ -836,8 +837,8 @@ void Stepper::isr() {
 
       // For minimum pulse time wait before stopping pulses
       #if EXTRA_CYCLES_E > 20
-        while (EXTRA_CYCLES_E > (uint32_t)(TCNT0 - pulse_start) * (INT0_PRESCALER)) { /* nada */ }
-        pulse_start = TCNT0;
+        while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_current_count(STEP_TIMER_NUM) - pulse_start) * (STEPPER_TIMER_PRESCALE)) { /* nada */ }
+        pulse_start = HAL_timer_get_current_count(STEP_TIMER_NUM);
       #elif EXTRA_CYCLES_E > 0
         DELAY_NOPS(EXTRA_CYCLES_E);
       #endif
@@ -858,7 +859,7 @@ void Stepper::isr() {
 
       // For minimum pulse time wait before looping
       #if EXTRA_CYCLES_E > 20
-        if (i) while (EXTRA_CYCLES_E > (uint32_t)(TCNT0 - pulse_start) * (INT0_PRESCALER)) { /* nada */ }
+        if (i) while (EXTRA_CYCLES_E > (hal_timer_t)(HAL_timer_get_current_count(STEP_TIMER_NUM) - pulse_start) * (STEPPER_TIMER_PRESCALE)) { /* nada */ }
       #elif EXTRA_CYCLES_E > 0
         if (i) DELAY_NOPS(EXTRA_CYCLES_E);
       #endif
@@ -1297,8 +1298,8 @@ void Stepper::report_positions() {
   #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)
 
   #if EXTRA_CYCLES_BABYSTEP > 20
-    #define _SAVE_START const uint32_t pulse_start = TCNT0
-    #define _PULSE_WAIT while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(TCNT0 - pulse_start) * (INT0_PRESCALER)) { /* nada */ }
+    #define _SAVE_START const hal_timer_t pulse_start = HAL_timer_get_current_count(STEP_TIMER_NUM)
+    #define _PULSE_WAIT while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(HAL_timer_get_current_count(STEP_TIMER_NUM) - pulse_start) * (STEPPER_TIMER_PRESCALE)) { /* nada */ }
   #else
     #define _SAVE_START NOOP
     #if EXTRA_CYCLES_BABYSTEP > 0

commit 85c6ffbe0d411cd223f345705e2b1235239bd91e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Dec 7 23:03:36 2017 -0600

    Discard all "continued" blocks on interrupted move

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 721c9c57c8..d311fe6a2a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -388,18 +388,21 @@ void Stepper::isr() {
   // When cleaning, discard the current block and run fast
   //
   if (cleaning_buffer_counter) {
-    if (cleaning_buffer_counter < 0)
-      ++cleaning_buffer_counter;                // Count up for endstop hit
+    if (cleaning_buffer_counter < 0) {          // Count up for endstop hit
+      if (current_block) planner.discard_current_block(); // Discard the active block that led to the trigger
+      if (!planner.discard_continued_block())   // Discard next CONTINUED block
+        cleaning_buffer_counter = 0;            // Keep discarding until non-CONTINUED
+    }
     else {
+      planner.discard_current_block();
       --cleaning_buffer_counter;                // Count down for abort print
       #ifdef SD_FINISHED_RELEASECOMMAND
         if (!cleaning_buffer_counter && (SD_FINISHED_STEPPERRELEASE)) enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
       #endif
     }
-    current_block = NULL;
-    planner.discard_current_block();
+    current_block = NULL;                       // Prep to get a new block after cleaning
     _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 10000);  // Run at max speed - 10 KHz
-    HAL_ENABLE_ISRs();                          // Re-enable ISRs
+    HAL_ENABLE_ISRs();
     return;
   }
 
@@ -1119,9 +1122,9 @@ void Stepper::init() {
 
 
 /**
- * Block until all buffered steps are executed
+ * Block until all buffered steps are executed / cleaned
  */
-void Stepper::synchronize() { while (planner.blocks_queued()) idle(); }
+void Stepper::synchronize() { while (planner.blocks_queued() || cleaning_buffer_counter) idle(); }
 
 /**
  * Set the stepper positions directly in steps
@@ -1245,7 +1248,7 @@ void Stepper::endstop_triggered(AxisEnum axis) {
   #endif // !COREXY && !COREXZ && !COREYZ
 
   kill_current_block();
-  cleaning_buffer_counter = -(BLOCK_BUFFER_SIZE - 1); // Ignore remaining blocks
+  cleaning_buffer_counter = -1; // Discard the rest of the move
 }
 
 void Stepper::report_positions() {

commit 9898b969926dca060eee40dc7a92a3a31da757c0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 21:28:50 2017 -0600

    No lcd_map_control flag in quick_stop

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b39fdf6a5f..721c9c57c8 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1219,12 +1219,7 @@ void Stepper::finish_and_disable() {
 }
 
 void Stepper::quick_stop() {
-
-  #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)
-    if (!ubl.lcd_map_control)
-  #endif
-      cleaning_buffer_counter = 5000;
-
+  cleaning_buffer_counter = 5000;
   DISABLE_STEPPER_DRIVER_INTERRUPT();
   while (planner.blocks_queued()) planner.discard_current_block();
   current_block = NULL;

commit 840289e7ccaa79846acfdceee63ffc1baa77168c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 12:44:44 2017 -0600

    Use block cleaning instead of split flag

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 9a464f1cfd..b39fdf6a5f 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1250,6 +1250,7 @@ void Stepper::endstop_triggered(AxisEnum axis) {
   #endif // !COREXY && !COREXZ && !COREYZ
 
   kill_current_block();
+  cleaning_buffer_counter = -(BLOCK_BUFFER_SIZE - 1); // Ignore remaining blocks
 }
 
 void Stepper::report_positions() {

commit 2fde60da124fddb6cf2a8f15479680f3410b53af
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 16:56:30 2017 -0600

    Changes for parity with 1.1.x

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 8942994175..9a464f1cfd 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -97,18 +97,13 @@ uint8_t Stepper::last_direction_bits = 0;        // The next stepping-bits to be
 int16_t Stepper::cleaning_buffer_counter = 0;
 
 #if ENABLED(X_DUAL_ENDSTOPS)
-  bool Stepper::locked_x_motor = false;
-  bool Stepper::locked_x2_motor = false;
+  bool Stepper::locked_x_motor = false, Stepper::locked_x2_motor = false;
 #endif
-
 #if ENABLED(Y_DUAL_ENDSTOPS)
-  bool Stepper::locked_y_motor = false;
-  bool Stepper::locked_y2_motor = false;
+  bool Stepper::locked_y_motor = false, Stepper::locked_y2_motor = false;
 #endif
-
 #if ENABLED(Z_DUAL_ENDSTOPS)
-  bool Stepper::locked_z_motor = false;
-  bool Stepper::locked_z2_motor = false;
+  bool Stepper::locked_z_motor = false, Stepper::locked_z2_motor = false;
 #endif
 
 long Stepper::counter_X = 0,

commit 6040d4080ee347b5276f93cf09a6cfc75286dc74
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 12:43:41 2017 -0600

    Cleanup stepper ISR. Allow cleaning for endstops.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 47fac7285a..8942994175 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -94,7 +94,7 @@ block_t* Stepper::current_block = NULL;  // A pointer to the block currently bei
 // private:
 
 uint8_t Stepper::last_direction_bits = 0;        // The next stepping-bits to be output
-uint16_t Stepper::cleaning_buffer_counter = 0;
+int16_t Stepper::cleaning_buffer_counter = 0;
 
 #if ENABLED(X_DUAL_ENDSTOPS)
   bool Stepper::locked_x_motor = false;
@@ -341,10 +341,8 @@ HAL_STEP_TIMER_ISR {
 
 void Stepper::isr() {
 
-  hal_timer_t ocr_val;
-
-  #define ENDSTOP_NOMINAL_OCR_VAL 1500 * HAL_TICKS_PER_US    // check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
-  #define OCR_VAL_TOLERANCE 500 * HAL_TICKS_PER_US           // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
+  #define ENDSTOP_NOMINAL_OCR_VAL 1500 * HAL_TICKS_PER_US // Check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
+  #define OCR_VAL_TOLERANCE        500 * HAL_TICKS_PER_US // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
 
   #if DISABLED(LIN_ADVANCE)
     // Disable Timer0 ISRs and enable global ISR again to capture UART events (incoming chars)
@@ -355,6 +353,7 @@ void Stepper::isr() {
     #endif
   #endif
 
+  hal_timer_t ocr_val;
   static uint32_t step_remaining = 0;  // SPLIT function always runs.  This allows 16 bit timers to be
                                        // used to generate the stepper ISR.
   #define SPLIT(L) do { \
@@ -367,42 +366,45 @@ void Stepper::isr() {
       ocr_val = L;\
   }while(0)
 
+  // Time remaining before the next step?
   if (step_remaining) {
-    if (ENDSTOPS_ENABLED)
-      endstops.update();
-    if (step_remaining > ENDSTOP_NOMINAL_OCR_VAL) {
-      step_remaining -= ENDSTOP_NOMINAL_OCR_VAL;
-      ocr_val = ENDSTOP_NOMINAL_OCR_VAL;
-    }
-    else {
-      ocr_val = step_remaining;
-      step_remaining = 0;  //  last one before the ISR that does the step
-    }
 
+    // Make sure endstops are updated
+    if (ENDSTOPS_ENABLED) endstops.update();
+
+    // Next ISR either for endstops or stepping
+    ocr_val = step_remaining <= ENDSTOP_NOMINAL_OCR_VAL ? step_remaining : ENDSTOP_NOMINAL_OCR_VAL;
+    step_remaining -= ocr_val;
     _NEXT_ISR(ocr_val);
 
-  #if DISABLED(LIN_ADVANCE)
-    #ifdef CPU_32_BIT
-      HAL_timer_set_count(STEP_TIMER_NUM, ocr_val);
-    #else
-      NOLESS(OCR1A, TCNT1 + 16);
+    #if DISABLED(LIN_ADVANCE)
+      #ifdef CPU_32_BIT
+        HAL_timer_set_count(STEP_TIMER_NUM, ocr_val);
+      #else
+        NOLESS(OCR1A, TCNT1 + 16);
+      #endif
+      HAL_ENABLE_ISRs(); // re-enable ISRs
     #endif
-    HAL_ENABLE_ISRs(); // re-enable ISRs
-  #endif
 
     return;
   }
 
-
+  //
+  // When cleaning, discard the current block and run fast
+  //
   if (cleaning_buffer_counter) {
-    --cleaning_buffer_counter;
+    if (cleaning_buffer_counter < 0)
+      ++cleaning_buffer_counter;                // Count up for endstop hit
+    else {
+      --cleaning_buffer_counter;                // Count down for abort print
+      #ifdef SD_FINISHED_RELEASECOMMAND
+        if (!cleaning_buffer_counter && (SD_FINISHED_STEPPERRELEASE)) enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
+      #endif
+    }
     current_block = NULL;
     planner.discard_current_block();
-    #ifdef SD_FINISHED_RELEASECOMMAND
-      if (!cleaning_buffer_counter && (SD_FINISHED_STEPPERRELEASE)) enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
-    #endif
-    _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 10000); // Run at max speed - 10 KHz
-    HAL_ENABLE_ISRs(); // re-enable ISRs
+    _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 10000);  // Run at max speed - 10 KHz
+    HAL_ENABLE_ISRs();                          // Re-enable ISRs
     return;
   }
 

commit 000b3b3117c500f51be05cdb136ce56617edd69a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 1 21:43:44 2017 -0600

    Comment/cleanup of motion code

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 4793f7687d..47fac7285a 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -409,8 +409,7 @@ void Stepper::isr() {
   // If there is no current block, attempt to pop one from the buffer
   if (!current_block) {
     // Anything in the buffer?
-    current_block = planner.get_current_block();
-    if (current_block) {
+    if ((current_block = planner.get_current_block())) {
       trapezoid_generator_reset();
 
       // Initialize Bresenham counters to 1/2 the ceiling

commit 1d4571b88dd0a5c5f182c86611e88742d44fd53d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 19 13:59:40 2017 -0600

    Dependency adjustments

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 98f2b326a3..4793f7687d 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -54,12 +54,12 @@
 #include "planner.h"
 #include "motion.h"
 
-#include "../Marlin.h"
 #include "../module/temperature.h"
 #include "../lcd/ultralcd.h"
 #include "../core/language.h"
 #include "../gcode/queue.h"
 #include "../sd/cardreader.h"
+#include "../Marlin.h"
 
 #if MB(ALLIGATOR)
   #include "../feature/dac/dac_dac084s085.h"

commit 22463166055c11be400a534deafb50f7b8d9db02
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 5 19:31:07 2017 -0600

    Fix name collision. timer_t => hal_timer_t

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index c86575edee..98f2b326a3 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -120,9 +120,9 @@ volatile uint32_t Stepper::step_events_completed = 0; // The number of step even
 
 #if ENABLED(LIN_ADVANCE)
 
-  constexpr timer_t ADV_NEVER = HAL_TIMER_TYPE_MAX;
+  constexpr hal_timer_t ADV_NEVER = HAL_TIMER_TYPE_MAX;
 
-  timer_t Stepper::nextMainISR = 0,
+  hal_timer_t Stepper::nextMainISR = 0,
          Stepper::nextAdvanceISR = ADV_NEVER,
          Stepper::eISR_Rate = ADV_NEVER;
 
@@ -137,9 +137,9 @@ volatile uint32_t Stepper::step_events_completed = 0; // The number of step even
    * This fix isn't perfect and may lose steps - but better than locking up completely
    * in future the planner should slow down if advance stepping rate would be too high
    */
-  FORCE_INLINE timer_t adv_rate(const int steps, const timer_t timer, const uint8_t loops) {
+  FORCE_INLINE hal_timer_t adv_rate(const int steps, const hal_timer_t timer, const uint8_t loops) {
     if (steps) {
-      const timer_t rate = (timer * loops) / abs(steps);
+      const hal_timer_t rate = (timer * loops) / abs(steps);
       //return constrain(rate, 1, ADV_NEVER - 1)
       return rate ? rate : 1;
     }
@@ -157,9 +157,9 @@ volatile signed char Stepper::count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
   long Stepper::counter_m[MIXING_STEPPERS];
 #endif
 
-timer_t Stepper::acc_step_rate; // needed for deceleration start point
+hal_timer_t Stepper::acc_step_rate; // needed for deceleration start point
 uint8_t Stepper::step_loops, Stepper::step_loops_nominal;
-timer_t Stepper::OCR1A_nominal;
+hal_timer_t Stepper::OCR1A_nominal;
 
 volatile long Stepper::endstops_trigsteps[XYZ];
 
@@ -341,7 +341,7 @@ HAL_STEP_TIMER_ISR {
 
 void Stepper::isr() {
 
-  timer_t ocr_val;
+  hal_timer_t ocr_val;
 
   #define ENDSTOP_NOMINAL_OCR_VAL 1500 * HAL_TICKS_PER_US    // check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
   #define OCR_VAL_TOLERANCE 500 * HAL_TICKS_PER_US           // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
@@ -677,7 +677,7 @@ void Stepper::isr() {
     NOMORE(acc_step_rate, current_block->nominal_rate);
 
     // step_rate to timer interval
-    const timer_t timer = calc_timer(acc_step_rate);
+    const hal_timer_t timer = calc_timer(acc_step_rate);
 
     SPLIT(timer);  // split step into multiple ISRs if larger than  ENDSTOP_NOMINAL_OCR_VAL
     _NEXT_ISR(ocr_val);
@@ -699,7 +699,7 @@ void Stepper::isr() {
     #endif // LIN_ADVANCE
   }
   else if (step_events_completed > (uint32_t)current_block->decelerate_after) {
-    timer_t step_rate;
+    hal_timer_t step_rate;
     #ifdef CPU_32_BIT
       MultiU32X24toH32(step_rate, deceleration_time, current_block->acceleration_rate);
     #else
@@ -714,7 +714,7 @@ void Stepper::isr() {
       step_rate = current_block->final_rate;
 
     // step_rate to timer interval
-    const timer_t timer = calc_timer(step_rate);
+    const hal_timer_t timer = calc_timer(step_rate);
 
     SPLIT(timer);  // split step into multiple ISRs if larger than  ENDSTOP_NOMINAL_OCR_VAL
     _NEXT_ISR(ocr_val);
@@ -754,7 +754,7 @@ void Stepper::isr() {
   #if DISABLED(LIN_ADVANCE)
     #ifdef CPU_32_BIT
       // Make sure stepper interrupt does not monopolise CPU by adjusting count to give about 8 us room
-      timer_t stepper_timer_count = HAL_timer_get_count(STEP_TIMER_NUM),
+      hal_timer_t stepper_timer_count = HAL_timer_get_count(STEP_TIMER_NUM),
                      stepper_timer_current_count = HAL_timer_get_current_count(STEP_TIMER_NUM) + 8 * HAL_TICKS_PER_US;
       HAL_timer_set_count(STEP_TIMER_NUM, max(stepper_timer_count, stepper_timer_current_count));
     #else

commit 723f2a77f6de40024508ea07fd7324e0987a2aa9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 29 03:43:44 2017 -0500

    Implement support for Dual X and Y endstops

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 22c9ad3d92..c86575edee 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -83,7 +83,7 @@ block_t* Stepper::current_block = NULL;  // A pointer to the block currently bei
   bool Stepper::abort_on_endstop_hit = false;
 #endif
 
-#if ENABLED(Z_DUAL_ENDSTOPS)
+#if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
   bool Stepper::performing_homing = false;
 #endif
 
@@ -96,6 +96,16 @@ block_t* Stepper::current_block = NULL;  // A pointer to the block currently bei
 uint8_t Stepper::last_direction_bits = 0;        // The next stepping-bits to be output
 uint16_t Stepper::cleaning_buffer_counter = 0;
 
+#if ENABLED(X_DUAL_ENDSTOPS)
+  bool Stepper::locked_x_motor = false;
+  bool Stepper::locked_x2_motor = false;
+#endif
+
+#if ENABLED(Y_DUAL_ENDSTOPS)
+  bool Stepper::locked_y_motor = false;
+  bool Stepper::locked_y2_motor = false;
+#endif
+
 #if ENABLED(Z_DUAL_ENDSTOPS)
   bool Stepper::locked_z_motor = false;
   bool Stepper::locked_z2_motor = false;
@@ -153,26 +163,54 @@ timer_t Stepper::OCR1A_nominal;
 
 volatile long Stepper::endstops_trigsteps[XYZ];
 
+#if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
+  #define LOCKED_X_MOTOR  locked_x_motor
+  #define LOCKED_Y_MOTOR  locked_y_motor
+  #define LOCKED_Z_MOTOR  locked_z_motor
+  #define LOCKED_X2_MOTOR locked_x2_motor
+  #define LOCKED_Y2_MOTOR locked_y2_motor
+  #define LOCKED_Z2_MOTOR locked_z2_motor
+  #define DUAL_ENDSTOP_APPLY_STEP(AXIS,v)                                                                                                             \
+    if (performing_homing) {                                                                                                                          \
+      if (AXIS##_HOME_DIR < 0) {                                                                                                                      \
+        if (!(TEST(endstops.old_endstop_bits, AXIS##_MIN) && (count_direction[AXIS##_AXIS] < 0)) && !LOCKED_##AXIS##_MOTOR) AXIS##_STEP_WRITE(v);     \
+        if (!(TEST(endstops.old_endstop_bits, AXIS##2_MIN) && (count_direction[AXIS##_AXIS] < 0)) && !LOCKED_##AXIS##2_MOTOR) AXIS##2_STEP_WRITE(v);  \
+      }                                                                                                                                               \
+      else {                                                                                                                                          \
+        if (!(TEST(endstops.old_endstop_bits, AXIS##_MAX) && (count_direction[AXIS##_AXIS] > 0)) && !LOCKED_##AXIS##_MOTOR) AXIS##_STEP_WRITE(v);     \
+        if (!(TEST(endstops.old_endstop_bits, AXIS##2_MAX) && (count_direction[AXIS##_AXIS] > 0)) && !LOCKED_##AXIS##2_MOTOR) AXIS##2_STEP_WRITE(v);  \
+      }                                                                                                                                               \
+    }                                                                                                                                                 \
+    else {                                                                                                                                            \
+      AXIS##_STEP_WRITE(v);                                                                                                                           \
+      AXIS##2_STEP_WRITE(v);                                                                                                                          \
+    }
+#endif
+
 #if ENABLED(X_DUAL_STEPPER_DRIVERS)
   #define X_APPLY_DIR(v,Q) do{ X_DIR_WRITE(v); X2_DIR_WRITE((v) != INVERT_X2_VS_X_DIR); }while(0)
-  #define X_APPLY_STEP(v,Q) do{ X_STEP_WRITE(v); X2_STEP_WRITE(v); }while(0)
-#elif ENABLED(DUAL_X_CARRIAGE)
-  #define X_APPLY_DIR(v,ALWAYS) \
-    if (extruder_duplication_enabled || ALWAYS) { \
-      X_DIR_WRITE(v); \
-      X2_DIR_WRITE(v); \
-    } \
-    else { \
-      if (current_block->active_extruder) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \
-    }
-  #define X_APPLY_STEP(v,ALWAYS) \
-    if (extruder_duplication_enabled || ALWAYS) { \
-      X_STEP_WRITE(v); \
-      X2_STEP_WRITE(v); \
-    } \
-    else { \
-      if (current_block->active_extruder) X2_STEP_WRITE(v); else X_STEP_WRITE(v); \
-    }
+  #if ENABLED(DUAL_X_CARRIAGE)
+    #define X_APPLY_DIR(v,ALWAYS) \
+      if (extruder_duplication_enabled || ALWAYS) { \
+        X_DIR_WRITE(v); \
+        X2_DIR_WRITE(v); \
+      } \
+      else { \
+        if (current_block->active_extruder) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \
+      }
+    #define X_APPLY_STEP(v,ALWAYS) \
+      if (extruder_duplication_enabled || ALWAYS) { \
+        X_STEP_WRITE(v); \
+        X2_STEP_WRITE(v); \
+      } \
+      else { \
+        if (current_block->active_extruder) X2_STEP_WRITE(v); else X_STEP_WRITE(v); \
+      }
+  #elif ENABLED(X_DUAL_ENDSTOPS)
+    #define X_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(X,v)
+  #else
+    #define X_APPLY_STEP(v,Q) do{ X_STEP_WRITE(v); X2_STEP_WRITE(v); }while(0)
+  #endif
 #else
   #define X_APPLY_DIR(v,Q) X_DIR_WRITE(v)
   #define X_APPLY_STEP(v,Q) X_STEP_WRITE(v)
@@ -180,7 +218,11 @@ volatile long Stepper::endstops_trigsteps[XYZ];
 
 #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
   #define Y_APPLY_DIR(v,Q) do{ Y_DIR_WRITE(v); Y2_DIR_WRITE((v) != INVERT_Y2_VS_Y_DIR); }while(0)
-  #define Y_APPLY_STEP(v,Q) do{ Y_STEP_WRITE(v); Y2_STEP_WRITE(v); }while(0)
+  #if ENABLED(Y_DUAL_ENDSTOPS)
+    #define Y_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Y,v)
+  #else
+    #define Y_APPLY_STEP(v,Q) do{ Y_STEP_WRITE(v); Y2_STEP_WRITE(v); }while(0)
+  #endif
 #else
   #define Y_APPLY_DIR(v,Q) Y_DIR_WRITE(v)
   #define Y_APPLY_STEP(v,Q) Y_STEP_WRITE(v)
@@ -189,21 +231,7 @@ volatile long Stepper::endstops_trigsteps[XYZ];
 #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
   #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(v); }while(0)
   #if ENABLED(Z_DUAL_ENDSTOPS)
-    #define Z_APPLY_STEP(v,Q) \
-    if (performing_homing) { \
-      if (Z_HOME_DIR < 0) { \
-        if (!(TEST(endstops.old_endstop_bits, Z_MIN) && (count_direction[Z_AXIS] < 0)) && !locked_z_motor) Z_STEP_WRITE(v); \
-        if (!(TEST(endstops.old_endstop_bits, Z2_MIN) && (count_direction[Z_AXIS] < 0)) && !locked_z2_motor) Z2_STEP_WRITE(v); \
-      } \
-      else { \
-        if (!(TEST(endstops.old_endstop_bits, Z_MAX) && (count_direction[Z_AXIS] > 0)) && !locked_z_motor) Z_STEP_WRITE(v); \
-        if (!(TEST(endstops.old_endstop_bits, Z2_MAX) && (count_direction[Z_AXIS] > 0)) && !locked_z2_motor) Z2_STEP_WRITE(v); \
-      } \
-    } \
-    else { \
-      Z_STEP_WRITE(v); \
-      Z2_STEP_WRITE(v); \
-    }
+    #define Z_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Z,v)
   #else
     #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); }while(0)
   #endif

commit 9e699811d25918fe64793824b2a2fdbccdf3b7bd
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Thu Oct 26 13:37:26 2017 -0500

    Make LPC1768 pinmapping not specific to Re-ARM (#8063)
    
    * Merging early because of build failures.  See #8105
    
    * Make LPC1768 pinmapping not specific to Re-ARM
    
    * Add HAL_PIN_TYPE and LPC1768 pin features
    
    * M43 Updates
    
    * Move pin map into pinsDebug_LPC1768.h
    
    * Incorporate comments and M226
    
    * Fix persistent store compilation issues
    
    * Update pin features
    
    * Update MKS SBASE pins
    
    * Use native LPC1768 pin numbers in M42, M43, and M226

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index eb856af2a7..22c9ad3d92 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -110,9 +110,9 @@ volatile uint32_t Stepper::step_events_completed = 0; // The number of step even
 
 #if ENABLED(LIN_ADVANCE)
 
-  constexpr HAL_TIMER_TYPE ADV_NEVER = HAL_TIMER_TYPE_MAX;
+  constexpr timer_t ADV_NEVER = HAL_TIMER_TYPE_MAX;
 
-  HAL_TIMER_TYPE Stepper::nextMainISR = 0,
+  timer_t Stepper::nextMainISR = 0,
          Stepper::nextAdvanceISR = ADV_NEVER,
          Stepper::eISR_Rate = ADV_NEVER;
 
@@ -127,9 +127,9 @@ volatile uint32_t Stepper::step_events_completed = 0; // The number of step even
    * This fix isn't perfect and may lose steps - but better than locking up completely
    * in future the planner should slow down if advance stepping rate would be too high
    */
-  FORCE_INLINE HAL_TIMER_TYPE adv_rate(const int steps, const HAL_TIMER_TYPE timer, const uint8_t loops) {
+  FORCE_INLINE timer_t adv_rate(const int steps, const timer_t timer, const uint8_t loops) {
     if (steps) {
-      const HAL_TIMER_TYPE rate = (timer * loops) / abs(steps);
+      const timer_t rate = (timer * loops) / abs(steps);
       //return constrain(rate, 1, ADV_NEVER - 1)
       return rate ? rate : 1;
     }
@@ -147,9 +147,9 @@ volatile signed char Stepper::count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
   long Stepper::counter_m[MIXING_STEPPERS];
 #endif
 
-HAL_TIMER_TYPE Stepper::acc_step_rate; // needed for deceleration start point
+timer_t Stepper::acc_step_rate; // needed for deceleration start point
 uint8_t Stepper::step_loops, Stepper::step_loops_nominal;
-HAL_TIMER_TYPE Stepper::OCR1A_nominal;
+timer_t Stepper::OCR1A_nominal;
 
 volatile long Stepper::endstops_trigsteps[XYZ];
 
@@ -313,7 +313,7 @@ HAL_STEP_TIMER_ISR {
 
 void Stepper::isr() {
 
-  HAL_TIMER_TYPE ocr_val;
+  timer_t ocr_val;
 
   #define ENDSTOP_NOMINAL_OCR_VAL 1500 * HAL_TICKS_PER_US    // check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
   #define OCR_VAL_TOLERANCE 500 * HAL_TICKS_PER_US           // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
@@ -649,7 +649,7 @@ void Stepper::isr() {
     NOMORE(acc_step_rate, current_block->nominal_rate);
 
     // step_rate to timer interval
-    const HAL_TIMER_TYPE timer = calc_timer(acc_step_rate);
+    const timer_t timer = calc_timer(acc_step_rate);
 
     SPLIT(timer);  // split step into multiple ISRs if larger than  ENDSTOP_NOMINAL_OCR_VAL
     _NEXT_ISR(ocr_val);
@@ -671,7 +671,7 @@ void Stepper::isr() {
     #endif // LIN_ADVANCE
   }
   else if (step_events_completed > (uint32_t)current_block->decelerate_after) {
-    HAL_TIMER_TYPE step_rate;
+    timer_t step_rate;
     #ifdef CPU_32_BIT
       MultiU32X24toH32(step_rate, deceleration_time, current_block->acceleration_rate);
     #else
@@ -686,7 +686,7 @@ void Stepper::isr() {
       step_rate = current_block->final_rate;
 
     // step_rate to timer interval
-    const HAL_TIMER_TYPE timer = calc_timer(step_rate);
+    const timer_t timer = calc_timer(step_rate);
 
     SPLIT(timer);  // split step into multiple ISRs if larger than  ENDSTOP_NOMINAL_OCR_VAL
     _NEXT_ISR(ocr_val);
@@ -726,7 +726,7 @@ void Stepper::isr() {
   #if DISABLED(LIN_ADVANCE)
     #ifdef CPU_32_BIT
       // Make sure stepper interrupt does not monopolise CPU by adjusting count to give about 8 us room
-      HAL_TIMER_TYPE stepper_timer_count = HAL_timer_get_count(STEP_TIMER_NUM),
+      timer_t stepper_timer_count = HAL_timer_get_count(STEP_TIMER_NUM),
                      stepper_timer_current_count = HAL_timer_get_current_count(STEP_TIMER_NUM) + 8 * HAL_TICKS_PER_US;
       HAL_timer_set_count(STEP_TIMER_NUM, max(stepper_timer_count, stepper_timer_current_count));
     #else

commit 6cb26c98c8714e199c2d8859d0a383dd59171692
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Mon Oct 16 16:29:37 2017 -0500

    Fix Baby Stepping on 32-Bit platforms (#8001)
    
    Also, Max7219 debug code was used for this effort.   It has been
    improved and hardened.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index a04e74fa84..eb856af2a7 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -1294,6 +1294,7 @@ void Stepper::report_positions() {
       _ENABLE(AXIS);                                        \
       _SAVE_START;                                          \
       _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^direction^INVERT); \
+      _PULSE_WAIT;                                          \
       _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), true);     \
       _PULSE_WAIT;                                          \
       _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), true);      \

commit 03f4891fb98c032509643b6fbc8b6d24df6630b6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 9 04:25:18 2017 -0500

    Remove legacy ADVANCE feature

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 1419b96109..a04e74fa84 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -108,7 +108,7 @@ long Stepper::counter_X = 0,
 
 volatile uint32_t Stepper::step_events_completed = 0; // The number of step events executed in the current block
 
-#if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+#if ENABLED(LIN_ADVANCE)
 
   constexpr HAL_TIMER_TYPE ADV_NEVER = HAL_TIMER_TYPE_MAX;
 
@@ -116,18 +116,10 @@ volatile uint32_t Stepper::step_events_completed = 0; // The number of step even
          Stepper::nextAdvanceISR = ADV_NEVER,
          Stepper::eISR_Rate = ADV_NEVER;
 
-  #if ENABLED(LIN_ADVANCE)
-    volatile int Stepper::e_steps[E_STEPPERS];
-    int Stepper::final_estep_rate,
-        Stepper::current_estep_rate[E_STEPPERS],
-        Stepper::current_adv_steps[E_STEPPERS];
-  #else
-    long Stepper::e_steps[E_STEPPERS],
-         Stepper::final_advance = 0,
-         Stepper::old_advance = 0,
-         Stepper::advance_rate,
-         Stepper::advance;
-  #endif
+  volatile int Stepper::e_steps[E_STEPPERS];
+  int Stepper::final_estep_rate,
+      Stepper::current_estep_rate[E_STEPPERS],
+      Stepper::current_adv_steps[E_STEPPERS];
 
   /**
    * See https://github.com/MarlinFirmware/Marlin/issues/5699#issuecomment-309264382
@@ -144,7 +136,7 @@ volatile uint32_t Stepper::step_events_completed = 0; // The number of step even
     return ADV_NEVER;
   }
 
-#endif // ADVANCE || LIN_ADVANCE
+#endif // LIN_ADVANCE
 
 long Stepper::acceleration_time, Stepper::deceleration_time;
 
@@ -277,7 +269,7 @@ void Stepper::set_directions() {
     SET_STEP_DIR(Z); // C
   #endif
 
-  #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+  #if DISABLED(LIN_ADVANCE)
     if (motor_direction(E_AXIS)) {
       REV_E_DIR();
       count_direction[E_AXIS] = -1;
@@ -286,7 +278,7 @@ void Stepper::set_directions() {
       NORM_E_DIR();
       count_direction[E_AXIS] = 1;
     }
-  #endif // !ADVANCE && !LIN_ADVANCE
+  #endif // !LIN_ADVANCE
 }
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
@@ -312,7 +304,7 @@ void Stepper::set_directions() {
 
 HAL_STEP_TIMER_ISR {
   HAL_timer_isr_prologue(STEP_TIMER_NUM);
-  #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+  #if ENABLED(LIN_ADVANCE)
     Stepper::advance_isr_scheduler();
   #else
     Stepper::isr();
@@ -326,7 +318,7 @@ void Stepper::isr() {
   #define ENDSTOP_NOMINAL_OCR_VAL 1500 * HAL_TICKS_PER_US    // check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
   #define OCR_VAL_TOLERANCE 500 * HAL_TICKS_PER_US           // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
 
-  #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+  #if DISABLED(LIN_ADVANCE)
     // Disable Timer0 ISRs and enable global ISR again to capture UART events (incoming chars)
     DISABLE_TEMPERATURE_INTERRUPT(); // Temperature ISR
     DISABLE_STEPPER_DRIVER_INTERRUPT();
@@ -361,7 +353,7 @@ void Stepper::isr() {
 
     _NEXT_ISR(ocr_val);
 
-  #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+  #if DISABLED(LIN_ADVANCE)
     #ifdef CPU_32_BIT
       HAL_timer_set_count(STEP_TIMER_NUM, ocr_val);
     #else
@@ -416,10 +408,6 @@ void Stepper::isr() {
           return;
         }
       #endif
-
-      // #if ENABLED(ADVANCE)
-      //   e_steps[TOOL_E_INDEX] = 0;
-      // #endif
     }
     else {
       _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 1000); // Run at slow speed - 1 KHz
@@ -465,33 +453,7 @@ void Stepper::isr() {
         }
       #endif
 
-    #elif ENABLED(ADVANCE)
-
-      // Always count the unified E axis
-      counter_E += current_block->steps[E_AXIS];
-      if (counter_E > 0) {
-        counter_E -= current_block->step_event_count;
-        #if DISABLED(MIXING_EXTRUDER)
-          // Don't step E here for mixing extruder
-          motor_direction(E_AXIS) ? --e_steps[TOOL_E_INDEX] : ++e_steps[TOOL_E_INDEX];
-        #endif
-      }
-
-      #if ENABLED(MIXING_EXTRUDER)
-
-        // Step mixing steppers proportionally
-        const bool dir = motor_direction(E_AXIS);
-        MIXING_STEPPERS_LOOP(j) {
-          counter_m[j] += current_block->steps[E_AXIS];
-          if (counter_m[j] > 0) {
-            counter_m[j] -= current_block->mix_event_count[j];
-            dir ? --e_steps[j] : ++e_steps[j];
-          }
-        }
-
-      #endif // MIXING_EXTRUDER
-
-    #endif // ADVANCE or LIN_ADVANCE
+    #endif // LIN_ADVANCE
 
     #define _COUNTER(AXIS) counter_## AXIS
     #define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP
@@ -552,7 +514,7 @@ void Stepper::isr() {
     #else
       #define _CYCLE_APPROX_6 _CYCLE_APPROX_5
     #endif
-    #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+    #if DISABLED(LIN_ADVANCE)
       #if ENABLED(MIXING_EXTRUDER)
         #define _CYCLE_APPROX_7 _CYCLE_APPROX_6 + (MIXING_STEPPERS) * 6
       #else
@@ -588,7 +550,7 @@ void Stepper::isr() {
     #endif
 
     // For non-advance use linear interpolation for E also
-    #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+    #if DISABLED(LIN_ADVANCE)
       #if ENABLED(MIXING_EXTRUDER)
         // Keep updating the single E axis
         counter_E += current_block->steps[E_AXIS];
@@ -602,7 +564,7 @@ void Stepper::isr() {
       #else // !MIXING_EXTRUDER
         PULSE_START(E);
       #endif
-    #endif // !ADVANCE && !LIN_ADVANCE
+    #endif // !LIN_ADVANCE
 
     // For minimum pulse time wait before stopping pulses
     #if EXTRA_CYCLES_XYZE > 20
@@ -622,7 +584,7 @@ void Stepper::isr() {
       PULSE_STOP(Z);
     #endif
 
-    #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+    #if DISABLED(LIN_ADVANCE)
       #if ENABLED(MIXING_EXTRUDER)
         // Always step the single E axis
         if (counter_E > 0) {
@@ -638,7 +600,7 @@ void Stepper::isr() {
       #else // !MIXING_EXTRUDER
         PULSE_STOP(E);
       #endif
-    #endif // !ADVANCE && !LIN_ADVANCE
+    #endif // !LIN_ADVANCE
 
     if (++step_events_completed >= current_block->step_event_count) {
       all_steps_done = true;
@@ -655,6 +617,7 @@ void Stepper::isr() {
   } // steps_loop
 
   #if ENABLED(LIN_ADVANCE)
+
     if (current_block->use_advance_lead) {
       const int delta_adv_steps = current_estep_rate[TOOL_E_INDEX] - current_adv_steps[TOOL_E_INDEX];
       current_adv_steps[TOOL_E_INDEX] += delta_adv_steps;
@@ -666,13 +629,11 @@ void Stepper::isr() {
         // For most extruders, advance the single E stepper
         e_steps[TOOL_E_INDEX] += delta_adv_steps;
       #endif
-   }
-  #endif
-
-  #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+    }
     // If we have esteps to execute, fire the next advance_isr "now"
     if (e_steps[TOOL_E_INDEX]) nextAdvanceISR = 0;
-  #endif
+
+  #endif // LIN_ADVANCE
 
   // Calculate new timer value
   if (step_events_completed <= (uint32_t)current_block->accelerate_until) {
@@ -705,33 +666,9 @@ void Stepper::isr() {
           current_estep_rate[TOOL_E_INDEX] = ((uint32_t)acc_step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
         #endif
       }
-
-    #elif ENABLED(ADVANCE)
-
-      advance += advance_rate * step_loops;
-      //NOLESS(advance, current_block->advance);
-
-      const long advance_whole = advance >> 8,
-                 advance_factor = advance_whole - old_advance;
-
-      // Do E steps + advance steps
-      #if ENABLED(MIXING_EXTRUDER)
-        // ...for mixing steppers proportionally
-        MIXING_STEPPERS_LOOP(j)
-          e_steps[j] += advance_factor * current_block->step_event_count / current_block->mix_event_count[j];
-      #else
-        // ...for the active extruder
-        e_steps[TOOL_E_INDEX] += advance_factor;
-      #endif
-
-      old_advance = advance_whole;
-
-    #endif // ADVANCE or LIN_ADVANCE
-
-    #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
-      // TODO: HAL
       eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], timer, step_loops);
-    #endif
+
+    #endif // LIN_ADVANCE
   }
   else if (step_events_completed > (uint32_t)current_block->decelerate_after) {
     HAL_TIMER_TYPE step_rate;
@@ -765,30 +702,9 @@ void Stepper::isr() {
           current_estep_rate[TOOL_E_INDEX] = ((uint32_t)step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
         #endif
       }
-
-    #elif ENABLED(ADVANCE)
-
-      advance -= advance_rate * step_loops;
-      NOLESS(advance, final_advance);
-
-      // Do E steps + advance steps
-      const long advance_whole = advance >> 8,
-                 advance_factor = advance_whole - old_advance;
-
-      #if ENABLED(MIXING_EXTRUDER)
-        MIXING_STEPPERS_LOOP(j)
-          e_steps[j] += advance_factor * current_block->step_event_count / current_block->mix_event_count[j];
-      #else
-        e_steps[TOOL_E_INDEX] += advance_factor;
-      #endif
-
-      old_advance = advance_whole;
-
-    #endif // ADVANCE or LIN_ADVANCE
-
-    #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
       eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], timer, step_loops);
-    #endif
+
+    #endif // LIN_ADVANCE
   }
   else {
 
@@ -807,7 +723,7 @@ void Stepper::isr() {
     step_loops = step_loops_nominal;
   }
 
-  #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+  #if DISABLED(LIN_ADVANCE)
     #ifdef CPU_32_BIT
       // Make sure stepper interrupt does not monopolise CPU by adjusting count to give about 8 us room
       HAL_TIMER_TYPE stepper_timer_count = HAL_timer_get_count(STEP_TIMER_NUM),
@@ -823,12 +739,12 @@ void Stepper::isr() {
     current_block = NULL;
     planner.discard_current_block();
   }
-  #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+  #if DISABLED(LIN_ADVANCE)
     HAL_ENABLE_ISRs(); // re-enable ISRs
   #endif
 }
 
-#if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+#if ENABLED(LIN_ADVANCE)
 
   #define CYCLES_EATEN_E (E_STEPPERS * 5)
   #define EXTRA_CYCLES_E (STEP_PULSE_CYCLES - (CYCLES_EATEN_E))
@@ -968,7 +884,7 @@ void Stepper::isr() {
     HAL_ENABLE_ISRs();
   }
 
-#endif // ADVANCE or LIN_ADVANCE
+#endif // LIN_ADVANCE
 
 void Stepper::init() {
 
@@ -1166,12 +1082,10 @@ void Stepper::init() {
 
   ENABLE_STEPPER_DRIVER_INTERRUPT();
 
-  #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+  #if ENABLED(LIN_ADVANCE)
     for (uint8_t i = 0; i < COUNT(e_steps); i++) e_steps[i] = 0;
-    #if ENABLED(LIN_ADVANCE)
-      ZERO(current_adv_steps);
-    #endif
-  #endif // ADVANCE || LIN_ADVANCE
+    ZERO(current_adv_steps);
+  #endif
 
   endstops.enable(true); // Start with endstops active. After homing they can be disabled
   sei();

commit 46b2773e13ef6a5474f2be57bf57f1d782339df0
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Wed Oct 4 21:40:54 2017 +0100

    General fixes for LPC1768 (#7834)
    
    * fixed some include paths
    
    * LPC1768: Fix Serial API
    
    Add missing serial methods used if TX_BUFFER_SIZE is set
    Change return value of HalSerial:read to match Arduino API
    
    * LPC1768: add filters to ADC
    
    This is to try and compensate for hardware issue and oversensitivity to noise
    
    * LPC1768: remove the polling section of delayMicroseconds
    
    * LPC1768: lock usb mass storage device while device accesses it.
    
    Currently only applicable to persistent store,
    The device always has priority and will unmount the sd card from the host, Windows then tries to automount again so it can look like the explorer window freezes. Linux Mint, by default, just closes the Nemo window.
    
    * Add timeout to make sure if Serial never connects that Marlin still boots
    
    * Remove unneeded ifdef CPU_32_BIT
    
    In general the need for ifdef CPU_32_BIT blocks means that something is missing from the HAL API or a Platform, in this case HAL_TICKS_PER_US was missing from the AVR Platform
    
    * LPC1768: relocate RE-ARM debug_extra_script.py

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index b95d223561..1419b96109 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -323,13 +323,8 @@ void Stepper::isr() {
 
   HAL_TIMER_TYPE ocr_val;
 
-  #ifdef CPU_32_BIT
-    #define ENDSTOP_NOMINAL_OCR_VAL 1500 * HAL_TICKS_PER_US    // check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
-    #define OCR_VAL_TOLERANCE 500 * HAL_TICKS_PER_US           // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
-  #else
-    #define ENDSTOP_NOMINAL_OCR_VAL 3000    // check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
-    #define OCR_VAL_TOLERANCE 1000          // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
-  #endif
+  #define ENDSTOP_NOMINAL_OCR_VAL 1500 * HAL_TICKS_PER_US    // check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
+  #define OCR_VAL_TOLERANCE 500 * HAL_TICKS_PER_US           // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
 
   #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
     // Disable Timer0 ISRs and enable global ISR again to capture UART events (incoming chars)

commit 965b0ab53e834e7e272d2d698560f70b17c86a90
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 1 21:33:52 2017 -0500

    Spacing adjustments

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index bd553c8a97..b95d223561 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -323,7 +323,7 @@ void Stepper::isr() {
 
   HAL_TIMER_TYPE ocr_val;
 
-  #if defined(CPU_32_BIT)
+  #ifdef CPU_32_BIT
     #define ENDSTOP_NOMINAL_OCR_VAL 1500 * HAL_TICKS_PER_US    // check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
     #define OCR_VAL_TOLERANCE 500 * HAL_TICKS_PER_US           // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
   #else
@@ -335,7 +335,7 @@ void Stepper::isr() {
     // Disable Timer0 ISRs and enable global ISR again to capture UART events (incoming chars)
     DISABLE_TEMPERATURE_INTERRUPT(); // Temperature ISR
     DISABLE_STEPPER_DRIVER_INTERRUPT();
-    #if !defined(CPU_32_BIT)
+    #ifndef CPU_32_BIT
       sei();
     #endif
   #endif

commit ac41eb5871b5f36686412b2ae83789e4d6bd9f31
Merge: c0b365fdb4 0cb00f52d9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 1 21:56:54 2017 -0500

    Merge pull request #7722 from tcm0116/2.0.x-warnings
    
    Cleanup 2.0.x compiler warnings

diff --combined Marlin/src/module/stepper.cpp
index 06af28f295,e71859f34e..bd553c8a97
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@@ -135,9 -135,9 +135,9 @@@ volatile uint32_t Stepper::step_events_
     * This fix isn't perfect and may lose steps - but better than locking up completely
     * in future the planner should slow down if advance stepping rate would be too high
     */
-   FORCE_INLINE uint16_t adv_rate(const int steps, const uint16_t timer, const uint8_t loops) {
+   FORCE_INLINE HAL_TIMER_TYPE adv_rate(const int steps, const HAL_TIMER_TYPE timer, const uint8_t loops) {
      if (steps) {
-       const uint16_t rate = (timer * loops) / abs(steps);
+       const HAL_TIMER_TYPE rate = (timer * loops) / abs(steps);
        //return constrain(rate, 1, ADV_NEVER - 1)
        return rate ? rate : 1;
      }
@@@ -323,13 -323,8 +323,13 @@@ void Stepper::isr() 
  
    HAL_TIMER_TYPE ocr_val;
  
 -  #define ENDSTOP_NOMINAL_OCR_VAL 3000    // check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
 -  #define OCR_VAL_TOLERANCE 1000          // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
 +  #if defined(CPU_32_BIT)
 +    #define ENDSTOP_NOMINAL_OCR_VAL 1500 * HAL_TICKS_PER_US    // check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
 +    #define OCR_VAL_TOLERANCE 500 * HAL_TICKS_PER_US           // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
 +  #else
 +    #define ENDSTOP_NOMINAL_OCR_VAL 3000    // check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
 +    #define OCR_VAL_TOLERANCE 1000          // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
 +  #endif
  
    #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
      // Disable Timer0 ISRs and enable global ISR again to capture UART events (incoming chars)
@@@ -340,45 -335,40 +340,45 @@@
      #endif
    #endif
  
 -  #define _SPLIT(L) (ocr_val = (HAL_TIMER_TYPE)L)
 -  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) || defined(CPU_32_BIT)
 -    #define SPLIT(L) _SPLIT(L)
 -  #else                 // sample endstops in between step pulses
 -    static uint32_t step_remaining = 0;
 -    #define SPLIT(L) do { \
 -      _SPLIT(L); \
 -      if (ENDSTOPS_ENABLED && L > ENDSTOP_NOMINAL_OCR_VAL) { \
 -        const uint16_t remainder = (uint16_t)L % (ENDSTOP_NOMINAL_OCR_VAL); \
 -        ocr_val = (remainder < OCR_VAL_TOLERANCE) ? ENDSTOP_NOMINAL_OCR_VAL + remainder : ENDSTOP_NOMINAL_OCR_VAL; \
 -        step_remaining = (uint16_t)L - ocr_val; \
 -      } \
 -    }while(0)
 +  static uint32_t step_remaining = 0;  // SPLIT function always runs.  This allows 16 bit timers to be
 +                                       // used to generate the stepper ISR.
 +  #define SPLIT(L) do { \
 +    if (L > ENDSTOP_NOMINAL_OCR_VAL) { \
 +      const uint32_t remainder = (uint32_t)L % (ENDSTOP_NOMINAL_OCR_VAL); \
 +      ocr_val = (remainder < OCR_VAL_TOLERANCE) ? ENDSTOP_NOMINAL_OCR_VAL + remainder : ENDSTOP_NOMINAL_OCR_VAL; \
 +      step_remaining = (uint32_t)L - ocr_val; \
 +    } \
 +    else \
 +      ocr_val = L;\
 +  }while(0)
  
 -    if (step_remaining && ENDSTOPS_ENABLED) {   // Just check endstops - not yet time for a step
 +  if (step_remaining) {
 +    if (ENDSTOPS_ENABLED)
        endstops.update();
 -      if (step_remaining > ENDSTOP_NOMINAL_OCR_VAL) {
 -        step_remaining -= ENDSTOP_NOMINAL_OCR_VAL;
 -        ocr_val = ENDSTOP_NOMINAL_OCR_VAL;
 -      }
 -      else {
 -        ocr_val = step_remaining;
 -        step_remaining = 0;  //  last one before the ISR that does the step
 -      }
 +    if (step_remaining > ENDSTOP_NOMINAL_OCR_VAL) {
 +      step_remaining -= ENDSTOP_NOMINAL_OCR_VAL;
 +      ocr_val = ENDSTOP_NOMINAL_OCR_VAL;
 +    }
 +    else {
 +      ocr_val = step_remaining;
 +      step_remaining = 0;  //  last one before the ISR that does the step
 +    }
  
 -      _NEXT_ISR(ocr_val);
 +    _NEXT_ISR(ocr_val);
  
 +  #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
 +    #ifdef CPU_32_BIT
 +      HAL_timer_set_count(STEP_TIMER_NUM, ocr_val);
 +    #else
        NOLESS(OCR1A, TCNT1 + 16);
 -
 -      HAL_ENABLE_ISRs(); // re-enable ISRs
 -      return;
 -    }
 +    #endif
 +    HAL_ENABLE_ISRs(); // re-enable ISRs
    #endif
  
 +    return;
 +  }
 +
 +
    if (cleaning_buffer_counter) {
      --cleaning_buffer_counter;
      current_block = NULL;
@@@ -758,6 -748,7 +758,6 @@@
  
      SPLIT(timer);  // split step into multiple ISRs if larger than  ENDSTOP_NOMINAL_OCR_VAL
      _NEXT_ISR(ocr_val);
 -
      deceleration_time += timer;
  
      #if ENABLED(LIN_ADVANCE)
@@@ -815,8 -806,8 +815,8 @@@
    #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
      #ifdef CPU_32_BIT
        // Make sure stepper interrupt does not monopolise CPU by adjusting count to give about 8 us room
-       uint32_t stepper_timer_count = HAL_timer_get_count(STEP_TIMER_NUM),
-                stepper_timer_current_count = HAL_timer_get_current_count(STEP_TIMER_NUM) + 8 * HAL_TICKS_PER_US;
+       HAL_TIMER_TYPE stepper_timer_count = HAL_timer_get_count(STEP_TIMER_NUM),
+                      stepper_timer_current_count = HAL_timer_get_current_count(STEP_TIMER_NUM) + 8 * HAL_TICKS_PER_US;
        HAL_timer_set_count(STEP_TIMER_NUM, max(stepper_timer_count, stepper_timer_current_count));
      #else
        NOLESS(OCR1A, TCNT1 + 16);
@@@ -841,6 -832,7 +841,6 @@@
    // Timer interrupt for E. e_steps is set in the main routine;
  
    void Stepper::advance_isr() {
 -
      nextAdvanceISR = eISR_Rate;
  
      #if ENABLED(MK2_MULTIPLEXER)

commit 0cb00f52d94773411e405ae10a463a4687b70658
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sat Sep 30 16:06:43 2017 -0500

    Cleanup warnings

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 7cfc0f630d..e71859f34e 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -135,9 +135,9 @@ volatile uint32_t Stepper::step_events_completed = 0; // The number of step even
    * This fix isn't perfect and may lose steps - but better than locking up completely
    * in future the planner should slow down if advance stepping rate would be too high
    */
-  FORCE_INLINE uint16_t adv_rate(const int steps, const uint16_t timer, const uint8_t loops) {
+  FORCE_INLINE HAL_TIMER_TYPE adv_rate(const int steps, const HAL_TIMER_TYPE timer, const uint8_t loops) {
     if (steps) {
-      const uint16_t rate = (timer * loops) / abs(steps);
+      const HAL_TIMER_TYPE rate = (timer * loops) / abs(steps);
       //return constrain(rate, 1, ADV_NEVER - 1)
       return rate ? rate : 1;
     }
@@ -806,8 +806,8 @@ void Stepper::isr() {
   #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
     #ifdef CPU_32_BIT
       // Make sure stepper interrupt does not monopolise CPU by adjusting count to give about 8 us room
-      uint32_t stepper_timer_count = HAL_timer_get_count(STEP_TIMER_NUM),
-               stepper_timer_current_count = HAL_timer_get_current_count(STEP_TIMER_NUM) + 8 * HAL_TICKS_PER_US;
+      HAL_TIMER_TYPE stepper_timer_count = HAL_timer_get_count(STEP_TIMER_NUM),
+                     stepper_timer_current_count = HAL_timer_get_current_count(STEP_TIMER_NUM) + 8 * HAL_TICKS_PER_US;
       HAL_timer_set_count(STEP_TIMER_NUM, max(stepper_timer_count, stepper_timer_current_count));
     #else
       NOLESS(OCR1A, TCNT1 + 16);

commit 1beaef04521e60533cf39df67bf34c333c67839a
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Fri Sep 29 23:52:17 2017 -0500

    fix 3S hang & enable SPLIT

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 7cfc0f630d..06af28f295 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -323,8 +323,13 @@ void Stepper::isr() {
 
   HAL_TIMER_TYPE ocr_val;
 
-  #define ENDSTOP_NOMINAL_OCR_VAL 3000    // check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
-  #define OCR_VAL_TOLERANCE 1000          // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
+  #if defined(CPU_32_BIT)
+    #define ENDSTOP_NOMINAL_OCR_VAL 1500 * HAL_TICKS_PER_US    // check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
+    #define OCR_VAL_TOLERANCE 500 * HAL_TICKS_PER_US           // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
+  #else
+    #define ENDSTOP_NOMINAL_OCR_VAL 3000    // check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
+    #define OCR_VAL_TOLERANCE 1000          // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
+  #endif
 
   #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
     // Disable Timer0 ISRs and enable global ISR again to capture UART events (incoming chars)
@@ -335,40 +340,45 @@ void Stepper::isr() {
     #endif
   #endif
 
-  #define _SPLIT(L) (ocr_val = (HAL_TIMER_TYPE)L)
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) || defined(CPU_32_BIT)
-    #define SPLIT(L) _SPLIT(L)
-  #else                 // sample endstops in between step pulses
-    static uint32_t step_remaining = 0;
-    #define SPLIT(L) do { \
-      _SPLIT(L); \
-      if (ENDSTOPS_ENABLED && L > ENDSTOP_NOMINAL_OCR_VAL) { \
-        const uint16_t remainder = (uint16_t)L % (ENDSTOP_NOMINAL_OCR_VAL); \
-        ocr_val = (remainder < OCR_VAL_TOLERANCE) ? ENDSTOP_NOMINAL_OCR_VAL + remainder : ENDSTOP_NOMINAL_OCR_VAL; \
-        step_remaining = (uint16_t)L - ocr_val; \
-      } \
-    }while(0)
+  static uint32_t step_remaining = 0;  // SPLIT function always runs.  This allows 16 bit timers to be
+                                       // used to generate the stepper ISR.
+  #define SPLIT(L) do { \
+    if (L > ENDSTOP_NOMINAL_OCR_VAL) { \
+      const uint32_t remainder = (uint32_t)L % (ENDSTOP_NOMINAL_OCR_VAL); \
+      ocr_val = (remainder < OCR_VAL_TOLERANCE) ? ENDSTOP_NOMINAL_OCR_VAL + remainder : ENDSTOP_NOMINAL_OCR_VAL; \
+      step_remaining = (uint32_t)L - ocr_val; \
+    } \
+    else \
+      ocr_val = L;\
+  }while(0)
 
-    if (step_remaining && ENDSTOPS_ENABLED) {   // Just check endstops - not yet time for a step
+  if (step_remaining) {
+    if (ENDSTOPS_ENABLED)
       endstops.update();
-      if (step_remaining > ENDSTOP_NOMINAL_OCR_VAL) {
-        step_remaining -= ENDSTOP_NOMINAL_OCR_VAL;
-        ocr_val = ENDSTOP_NOMINAL_OCR_VAL;
-      }
-      else {
-        ocr_val = step_remaining;
-        step_remaining = 0;  //  last one before the ISR that does the step
-      }
+    if (step_remaining > ENDSTOP_NOMINAL_OCR_VAL) {
+      step_remaining -= ENDSTOP_NOMINAL_OCR_VAL;
+      ocr_val = ENDSTOP_NOMINAL_OCR_VAL;
+    }
+    else {
+      ocr_val = step_remaining;
+      step_remaining = 0;  //  last one before the ISR that does the step
+    }
 
-      _NEXT_ISR(ocr_val);
+    _NEXT_ISR(ocr_val);
 
+  #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+    #ifdef CPU_32_BIT
+      HAL_timer_set_count(STEP_TIMER_NUM, ocr_val);
+    #else
       NOLESS(OCR1A, TCNT1 + 16);
-
-      HAL_ENABLE_ISRs(); // re-enable ISRs
-      return;
-    }
+    #endif
+    HAL_ENABLE_ISRs(); // re-enable ISRs
   #endif
 
+    return;
+  }
+
+
   if (cleaning_buffer_counter) {
     --cleaning_buffer_counter;
     current_block = NULL;
@@ -748,7 +758,6 @@ void Stepper::isr() {
 
     SPLIT(timer);  // split step into multiple ISRs if larger than  ENDSTOP_NOMINAL_OCR_VAL
     _NEXT_ISR(ocr_val);
-
     deceleration_time += timer;
 
     #if ENABLED(LIN_ADVANCE)
@@ -832,7 +841,6 @@ void Stepper::isr() {
   // Timer interrupt for E. e_steps is set in the main routine;
 
   void Stepper::advance_isr() {
-
     nextAdvanceISR = eISR_Rate;
 
     #if ENABLED(MK2_MULTIPLEXER)

commit f58ba3a64e94d5f6fa414f3e1bb4d7c1e2ddb46e
Author: Dave Johnson <davejohnson3000@gmail.com>
Date:   Sat Sep 23 21:25:28 2017 -0700

    Improve AVR arch detection
    
    Replace ARDUINO_ARCH_AVR with __AVR__ to better detect architecture for non-Arduino dev environments.  Resolves compile failure in PIO for 8-bit Teensduino targets
    
    More info:
    https://forum.pjrc.com/threads/33234-Using-Teensyduino-Selecting-Teensy-3-2-3-1-board-has-incorrect-platform-define
    http://www.atmel.com/webdoc/avrlibcreferencemanual/using_tools_1using_avr_gcc_mach_opt.html

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 74dffe732c..7cfc0f630d 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -46,7 +46,7 @@
 
 #include "stepper.h"
 
-#ifdef ARDUINO_ARCH_AVR
+#ifdef __AVR__
   #include "speed_lookuptable.h"
 #endif
 
@@ -1139,7 +1139,7 @@ void Stepper::init() {
     E_AXIS_INIT(4);
   #endif
 
-  #ifdef ARDUINO_ARCH_AVR
+  #ifdef __AVR__
     // waveform generation = 0100 = CTC
     SET_WGM(1, CTC_OCRnA);
 

commit 551752eac73a6f60de45b6465e2f224b2b2dca24
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 15:35:25 2017 -0500

    Consolidate "bedlevel" code

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index fecb5c7a99..74dffe732c 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -52,6 +52,7 @@
 
 #include "endstops.h"
 #include "planner.h"
+#include "motion.h"
 
 #include "../Marlin.h"
 #include "../module/temperature.h"

commit 722786966ad284a708502d18ac5daad02012bfc8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 7 22:33:16 2017 -0500

    Add gcode.cpp, motion.*, queue.* - Apply to some G-codes.

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index 5835238d5f..fecb5c7a99 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -57,6 +57,7 @@
 #include "../module/temperature.h"
 #include "../lcd/ultralcd.h"
 #include "../core/language.h"
+#include "../gcode/queue.h"
 #include "../sd/cardreader.h"
 
 #if MB(ALLIGATOR)

commit 3d8a0ab4b215a3869a0388e5c0ef35a6372ed7d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:32 2017 -0500

    Module updates

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
index f982db4a32..5835238d5f 100644
--- a/Marlin/src/module/stepper.cpp
+++ b/Marlin/src/module/stepper.cpp
@@ -44,19 +44,27 @@
 /* The timer calculations of this module informed by the 'RepRap cartesian firmware' by Zack Smith
    and Philipp Tiefenbacher. */
 
-#include "Marlin.h"
 #include "stepper.h"
+
+#ifdef ARDUINO_ARCH_AVR
+  #include "speed_lookuptable.h"
+#endif
+
 #include "endstops.h"
 #include "planner.h"
+
+#include "../Marlin.h"
+#include "../module/temperature.h"
+#include "../lcd/ultralcd.h"
+#include "../core/language.h"
+#include "../sd/cardreader.h"
+
 #if MB(ALLIGATOR)
-  #include "dac_dac084s085.h"
+  #include "../feature/dac/dac_dac084s085.h"
 #endif
-#include "temperature.h"
-#include "ultralcd.h"
-#include "language.h"
-#include "cardreader.h"
-#ifdef ARDUINO_ARCH_AVR
-  #include "speed_lookuptable.h"
+
+#if HAS_LEVELING
+  #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_DIGIPOTSS
@@ -67,10 +75,6 @@ Stepper stepper; // Singleton
 
 // public:
 
-#if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)
-  extern bool ubl_lcd_map_control;
-#endif
-
 block_t* Stepper::current_block = NULL;  // A pointer to the block currently being traced
 
 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
@@ -1272,12 +1276,12 @@ void Stepper::finish_and_disable() {
 }
 
 void Stepper::quick_stop() {
+
   #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)
-    if (!ubl_lcd_map_control)
-      cleaning_buffer_counter = 5000;
-  #else
-    cleaning_buffer_counter = 5000;
+    if (!ubl.lcd_map_control)
   #endif
+      cleaning_buffer_counter = 5000;
+
   DISABLE_STEPPER_DRIVER_INTERRUPT();
   while (planner.blocks_queued()) planner.discard_current_block();
   current_block = NULL;

commit 0c9231fd04798c30830513a0cad8b204a6b9633f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:30 2017 -0500

    Move 'module' files

diff --git a/Marlin/src/module/stepper.cpp b/Marlin/src/module/stepper.cpp
new file mode 100644
index 0000000000..f982db4a32
--- /dev/null
+++ b/Marlin/src/module/stepper.cpp
@@ -0,0 +1,1701 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * stepper.cpp - A singleton object to execute motion plans using stepper motors
+ * Marlin Firmware
+ *
+ * Derived from Grbl
+ * Copyright (c) 2009-2011 Simen Svale Skogsrud
+ *
+ * Grbl is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Grbl is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* The timer calculations of this module informed by the 'RepRap cartesian firmware' by Zack Smith
+   and Philipp Tiefenbacher. */
+
+#include "Marlin.h"
+#include "stepper.h"
+#include "endstops.h"
+#include "planner.h"
+#if MB(ALLIGATOR)
+  #include "dac_dac084s085.h"
+#endif
+#include "temperature.h"
+#include "ultralcd.h"
+#include "language.h"
+#include "cardreader.h"
+#ifdef ARDUINO_ARCH_AVR
+  #include "speed_lookuptable.h"
+#endif
+
+#if HAS_DIGIPOTSS
+  #include <SPI.h>
+#endif
+
+Stepper stepper; // Singleton
+
+// public:
+
+#if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)
+  extern bool ubl_lcd_map_control;
+#endif
+
+block_t* Stepper::current_block = NULL;  // A pointer to the block currently being traced
+
+#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+  bool Stepper::abort_on_endstop_hit = false;
+#endif
+
+#if ENABLED(Z_DUAL_ENDSTOPS)
+  bool Stepper::performing_homing = false;
+#endif
+
+#if HAS_MOTOR_CURRENT_PWM
+  uint32_t Stepper::motor_current_setting[3]; // Initialized by settings.load()
+#endif
+
+// private:
+
+uint8_t Stepper::last_direction_bits = 0;        // The next stepping-bits to be output
+uint16_t Stepper::cleaning_buffer_counter = 0;
+
+#if ENABLED(Z_DUAL_ENDSTOPS)
+  bool Stepper::locked_z_motor = false;
+  bool Stepper::locked_z2_motor = false;
+#endif
+
+long Stepper::counter_X = 0,
+     Stepper::counter_Y = 0,
+     Stepper::counter_Z = 0,
+     Stepper::counter_E = 0;
+
+volatile uint32_t Stepper::step_events_completed = 0; // The number of step events executed in the current block
+
+#if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+
+  constexpr HAL_TIMER_TYPE ADV_NEVER = HAL_TIMER_TYPE_MAX;
+
+  HAL_TIMER_TYPE Stepper::nextMainISR = 0,
+         Stepper::nextAdvanceISR = ADV_NEVER,
+         Stepper::eISR_Rate = ADV_NEVER;
+
+  #if ENABLED(LIN_ADVANCE)
+    volatile int Stepper::e_steps[E_STEPPERS];
+    int Stepper::final_estep_rate,
+        Stepper::current_estep_rate[E_STEPPERS],
+        Stepper::current_adv_steps[E_STEPPERS];
+  #else
+    long Stepper::e_steps[E_STEPPERS],
+         Stepper::final_advance = 0,
+         Stepper::old_advance = 0,
+         Stepper::advance_rate,
+         Stepper::advance;
+  #endif
+
+  /**
+   * See https://github.com/MarlinFirmware/Marlin/issues/5699#issuecomment-309264382
+   *
+   * This fix isn't perfect and may lose steps - but better than locking up completely
+   * in future the planner should slow down if advance stepping rate would be too high
+   */
+  FORCE_INLINE uint16_t adv_rate(const int steps, const uint16_t timer, const uint8_t loops) {
+    if (steps) {
+      const uint16_t rate = (timer * loops) / abs(steps);
+      //return constrain(rate, 1, ADV_NEVER - 1)
+      return rate ? rate : 1;
+    }
+    return ADV_NEVER;
+  }
+
+#endif // ADVANCE || LIN_ADVANCE
+
+long Stepper::acceleration_time, Stepper::deceleration_time;
+
+volatile long Stepper::count_position[NUM_AXIS] = { 0 };
+volatile signed char Stepper::count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
+
+#if ENABLED(MIXING_EXTRUDER)
+  long Stepper::counter_m[MIXING_STEPPERS];
+#endif
+
+HAL_TIMER_TYPE Stepper::acc_step_rate; // needed for deceleration start point
+uint8_t Stepper::step_loops, Stepper::step_loops_nominal;
+HAL_TIMER_TYPE Stepper::OCR1A_nominal;
+
+volatile long Stepper::endstops_trigsteps[XYZ];
+
+#if ENABLED(X_DUAL_STEPPER_DRIVERS)
+  #define X_APPLY_DIR(v,Q) do{ X_DIR_WRITE(v); X2_DIR_WRITE((v) != INVERT_X2_VS_X_DIR); }while(0)
+  #define X_APPLY_STEP(v,Q) do{ X_STEP_WRITE(v); X2_STEP_WRITE(v); }while(0)
+#elif ENABLED(DUAL_X_CARRIAGE)
+  #define X_APPLY_DIR(v,ALWAYS) \
+    if (extruder_duplication_enabled || ALWAYS) { \
+      X_DIR_WRITE(v); \
+      X2_DIR_WRITE(v); \
+    } \
+    else { \
+      if (current_block->active_extruder) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \
+    }
+  #define X_APPLY_STEP(v,ALWAYS) \
+    if (extruder_duplication_enabled || ALWAYS) { \
+      X_STEP_WRITE(v); \
+      X2_STEP_WRITE(v); \
+    } \
+    else { \
+      if (current_block->active_extruder) X2_STEP_WRITE(v); else X_STEP_WRITE(v); \
+    }
+#else
+  #define X_APPLY_DIR(v,Q) X_DIR_WRITE(v)
+  #define X_APPLY_STEP(v,Q) X_STEP_WRITE(v)
+#endif
+
+#if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+  #define Y_APPLY_DIR(v,Q) do{ Y_DIR_WRITE(v); Y2_DIR_WRITE((v) != INVERT_Y2_VS_Y_DIR); }while(0)
+  #define Y_APPLY_STEP(v,Q) do{ Y_STEP_WRITE(v); Y2_STEP_WRITE(v); }while(0)
+#else
+  #define Y_APPLY_DIR(v,Q) Y_DIR_WRITE(v)
+  #define Y_APPLY_STEP(v,Q) Y_STEP_WRITE(v)
+#endif
+
+#if ENABLED(Z_DUAL_STEPPER_DRIVERS)
+  #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(v); }while(0)
+  #if ENABLED(Z_DUAL_ENDSTOPS)
+    #define Z_APPLY_STEP(v,Q) \
+    if (performing_homing) { \
+      if (Z_HOME_DIR < 0) { \
+        if (!(TEST(endstops.old_endstop_bits, Z_MIN) && (count_direction[Z_AXIS] < 0)) && !locked_z_motor) Z_STEP_WRITE(v); \
+        if (!(TEST(endstops.old_endstop_bits, Z2_MIN) && (count_direction[Z_AXIS] < 0)) && !locked_z2_motor) Z2_STEP_WRITE(v); \
+      } \
+      else { \
+        if (!(TEST(endstops.old_endstop_bits, Z_MAX) && (count_direction[Z_AXIS] > 0)) && !locked_z_motor) Z_STEP_WRITE(v); \
+        if (!(TEST(endstops.old_endstop_bits, Z2_MAX) && (count_direction[Z_AXIS] > 0)) && !locked_z2_motor) Z2_STEP_WRITE(v); \
+      } \
+    } \
+    else { \
+      Z_STEP_WRITE(v); \
+      Z2_STEP_WRITE(v); \
+    }
+  #else
+    #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); }while(0)
+  #endif
+#else
+  #define Z_APPLY_DIR(v,Q) Z_DIR_WRITE(v)
+  #define Z_APPLY_STEP(v,Q) Z_STEP_WRITE(v)
+#endif
+
+#if DISABLED(MIXING_EXTRUDER)
+  #define E_APPLY_STEP(v,Q) E_STEP_WRITE(v)
+#endif
+
+
+
+/**
+ *         __________________________
+ *        /|                        |\     _________________         ^
+ *       / |                        | \   /|               |\        |
+ *      /  |                        |  \ / |               | \       s
+ *     /   |                        |   |  |               |  \      p
+ *    /    |                        |   |  |               |   \     e
+ *   +-----+------------------------+---+--+---------------+----+    e
+ *   |               BLOCK 1            |      BLOCK 2          |    d
+ *
+ *                           time ----->
+ *
+ *  The trapezoid is the shape the speed curve over time. It starts at block->initial_rate, accelerates
+ *  first block->accelerate_until step_events_completed, then keeps going at constant speed until
+ *  step_events_completed reaches block->decelerate_after after which it decelerates until the trapezoid generator is reset.
+ *  The slope of acceleration is calculated using v = u + at where t is the accumulated timer values of the steps so far.
+ */
+void Stepper::wake_up() {
+  // TCNT1 = 0;
+  ENABLE_STEPPER_DRIVER_INTERRUPT();
+}
+
+/**
+ * Set the stepper direction of each axis
+ *
+ *   COREXY: X_AXIS=A_AXIS and Y_AXIS=B_AXIS
+ *   COREXZ: X_AXIS=A_AXIS and Z_AXIS=C_AXIS
+ *   COREYZ: Y_AXIS=B_AXIS and Z_AXIS=C_AXIS
+ */
+void Stepper::set_directions() {
+
+  #define SET_STEP_DIR(AXIS) \
+    if (motor_direction(AXIS ##_AXIS)) { \
+      AXIS ##_APPLY_DIR(INVERT_## AXIS ##_DIR, false); \
+      count_direction[AXIS ##_AXIS] = -1; \
+    } \
+    else { \
+      AXIS ##_APPLY_DIR(!INVERT_## AXIS ##_DIR, false); \
+      count_direction[AXIS ##_AXIS] = 1; \
+    }
+
+  #if HAS_X_DIR
+    SET_STEP_DIR(X); // A
+  #endif
+  #if HAS_Y_DIR
+    SET_STEP_DIR(Y); // B
+  #endif
+  #if HAS_Z_DIR
+    SET_STEP_DIR(Z); // C
+  #endif
+
+  #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+    if (motor_direction(E_AXIS)) {
+      REV_E_DIR();
+      count_direction[E_AXIS] = -1;
+    }
+    else {
+      NORM_E_DIR();
+      count_direction[E_AXIS] = 1;
+    }
+  #endif // !ADVANCE && !LIN_ADVANCE
+}
+
+#if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+  extern volatile uint8_t e_hit;
+#endif
+
+/**
+ * Stepper Driver Interrupt
+ *
+ * Directly pulses the stepper motors at high frequency.
+ *
+ * AVR :
+ * Timer 1 runs at a base frequency of 2MHz, with this ISR using OCR1A compare mode.
+ *
+ * OCR1A   Frequency
+ *     1     2 MHz
+ *    50    40 KHz
+ *   100    20 KHz - capped max rate
+ *   200    10 KHz - nominal max rate
+ *  2000     1 KHz - sleep rate
+ *  4000   500  Hz - init rate
+ */
+
+HAL_STEP_TIMER_ISR {
+  HAL_timer_isr_prologue(STEP_TIMER_NUM);
+  #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+    Stepper::advance_isr_scheduler();
+  #else
+    Stepper::isr();
+  #endif
+}
+
+void Stepper::isr() {
+
+  HAL_TIMER_TYPE ocr_val;
+
+  #define ENDSTOP_NOMINAL_OCR_VAL 3000    // check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
+  #define OCR_VAL_TOLERANCE 1000          // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
+
+  #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+    // Disable Timer0 ISRs and enable global ISR again to capture UART events (incoming chars)
+    DISABLE_TEMPERATURE_INTERRUPT(); // Temperature ISR
+    DISABLE_STEPPER_DRIVER_INTERRUPT();
+    #if !defined(CPU_32_BIT)
+      sei();
+    #endif
+  #endif
+
+  #define _SPLIT(L) (ocr_val = (HAL_TIMER_TYPE)L)
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) || defined(CPU_32_BIT)
+    #define SPLIT(L) _SPLIT(L)
+  #else                 // sample endstops in between step pulses
+    static uint32_t step_remaining = 0;
+    #define SPLIT(L) do { \
+      _SPLIT(L); \
+      if (ENDSTOPS_ENABLED && L > ENDSTOP_NOMINAL_OCR_VAL) { \
+        const uint16_t remainder = (uint16_t)L % (ENDSTOP_NOMINAL_OCR_VAL); \
+        ocr_val = (remainder < OCR_VAL_TOLERANCE) ? ENDSTOP_NOMINAL_OCR_VAL + remainder : ENDSTOP_NOMINAL_OCR_VAL; \
+        step_remaining = (uint16_t)L - ocr_val; \
+      } \
+    }while(0)
+
+    if (step_remaining && ENDSTOPS_ENABLED) {   // Just check endstops - not yet time for a step
+      endstops.update();
+      if (step_remaining > ENDSTOP_NOMINAL_OCR_VAL) {
+        step_remaining -= ENDSTOP_NOMINAL_OCR_VAL;
+        ocr_val = ENDSTOP_NOMINAL_OCR_VAL;
+      }
+      else {
+        ocr_val = step_remaining;
+        step_remaining = 0;  //  last one before the ISR that does the step
+      }
+
+      _NEXT_ISR(ocr_val);
+
+      NOLESS(OCR1A, TCNT1 + 16);
+
+      HAL_ENABLE_ISRs(); // re-enable ISRs
+      return;
+    }
+  #endif
+
+  if (cleaning_buffer_counter) {
+    --cleaning_buffer_counter;
+    current_block = NULL;
+    planner.discard_current_block();
+    #ifdef SD_FINISHED_RELEASECOMMAND
+      if (!cleaning_buffer_counter && (SD_FINISHED_STEPPERRELEASE)) enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
+    #endif
+    _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 10000); // Run at max speed - 10 KHz
+    HAL_ENABLE_ISRs(); // re-enable ISRs
+    return;
+  }
+
+  // If there is no current block, attempt to pop one from the buffer
+  if (!current_block) {
+    // Anything in the buffer?
+    current_block = planner.get_current_block();
+    if (current_block) {
+      trapezoid_generator_reset();
+
+      // Initialize Bresenham counters to 1/2 the ceiling
+      counter_X = counter_Y = counter_Z = counter_E = -(current_block->step_event_count >> 1);
+
+      #if ENABLED(MIXING_EXTRUDER)
+        MIXING_STEPPERS_LOOP(i)
+          counter_m[i] = -(current_block->mix_event_count[i] >> 1);
+      #endif
+
+      step_events_completed = 0;
+
+      #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+        e_hit = 2; // Needed for the case an endstop is already triggered before the new move begins.
+                   // No 'change' can be detected.
+      #endif
+
+      #if ENABLED(Z_LATE_ENABLE)
+        if (current_block->steps[Z_AXIS] > 0) {
+          enable_Z();
+          _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 1000); // Run at slow speed - 1 KHz
+          HAL_ENABLE_ISRs(); // re-enable ISRs
+          return;
+        }
+      #endif
+
+      // #if ENABLED(ADVANCE)
+      //   e_steps[TOOL_E_INDEX] = 0;
+      // #endif
+    }
+    else {
+      _NEXT_ISR(HAL_STEPPER_TIMER_RATE / 1000); // Run at slow speed - 1 KHz
+      HAL_ENABLE_ISRs(); // re-enable ISRs
+      return;
+    }
+  }
+
+  // Update endstops state, if enabled
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+    if (e_hit && ENDSTOPS_ENABLED) {
+      endstops.update();
+      e_hit--;
+    }
+  #else
+    if (ENDSTOPS_ENABLED) endstops.update();
+  #endif
+
+  // Take multiple steps per interrupt (For high speed moves)
+  bool all_steps_done = false;
+  for (uint8_t i = step_loops; i--;) {
+    #if ENABLED(LIN_ADVANCE)
+
+      counter_E += current_block->steps[E_AXIS];
+      if (counter_E > 0) {
+        counter_E -= current_block->step_event_count;
+        #if DISABLED(MIXING_EXTRUDER)
+          // Don't step E here for mixing extruder
+          count_position[E_AXIS] += count_direction[E_AXIS];
+          motor_direction(E_AXIS) ? --e_steps[TOOL_E_INDEX] : ++e_steps[TOOL_E_INDEX];
+        #endif
+      }
+
+      #if ENABLED(MIXING_EXTRUDER)
+        // Step mixing steppers proportionally
+        const bool dir = motor_direction(E_AXIS);
+        MIXING_STEPPERS_LOOP(j) {
+          counter_m[j] += current_block->steps[E_AXIS];
+          if (counter_m[j] > 0) {
+            counter_m[j] -= current_block->mix_event_count[j];
+            dir ? --e_steps[j] : ++e_steps[j];
+          }
+        }
+      #endif
+
+    #elif ENABLED(ADVANCE)
+
+      // Always count the unified E axis
+      counter_E += current_block->steps[E_AXIS];
+      if (counter_E > 0) {
+        counter_E -= current_block->step_event_count;
+        #if DISABLED(MIXING_EXTRUDER)
+          // Don't step E here for mixing extruder
+          motor_direction(E_AXIS) ? --e_steps[TOOL_E_INDEX] : ++e_steps[TOOL_E_INDEX];
+        #endif
+      }
+
+      #if ENABLED(MIXING_EXTRUDER)
+
+        // Step mixing steppers proportionally
+        const bool dir = motor_direction(E_AXIS);
+        MIXING_STEPPERS_LOOP(j) {
+          counter_m[j] += current_block->steps[E_AXIS];
+          if (counter_m[j] > 0) {
+            counter_m[j] -= current_block->mix_event_count[j];
+            dir ? --e_steps[j] : ++e_steps[j];
+          }
+        }
+
+      #endif // MIXING_EXTRUDER
+
+    #endif // ADVANCE or LIN_ADVANCE
+
+    #define _COUNTER(AXIS) counter_## AXIS
+    #define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP
+    #define _INVERT_STEP_PIN(AXIS) INVERT_## AXIS ##_STEP_PIN
+
+    // Advance the Bresenham counter; start a pulse if the axis needs a step
+    #define PULSE_START(AXIS) \
+      _COUNTER(AXIS) += current_block->steps[_AXIS(AXIS)]; \
+      if (_COUNTER(AXIS) > 0) { _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS),0); }
+
+    // Stop an active pulse, reset the Bresenham counter, update the position
+    #define PULSE_STOP(AXIS) \
+      if (_COUNTER(AXIS) > 0) { \
+        _COUNTER(AXIS) -= current_block->step_event_count; \
+        count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \
+        _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS),0); \
+      }
+
+    /**
+     * Estimate the number of cycles that the stepper logic already takes
+     * up between the start and stop of the X stepper pulse.
+     *
+     * Currently this uses very modest estimates of around 5 cycles.
+     * True values may be derived by careful testing.
+     *
+     * Once any delay is added, the cost of the delay code itself
+     * may be subtracted from this value to get a more accurate delay.
+     * Delays under 20 cycles (1.25µs) will be very accurate, using NOPs.
+     * Longer delays use a loop. The resolution is 8 cycles.
+     */
+    #if HAS_X_STEP
+      #define _CYCLE_APPROX_1 5
+    #else
+      #define _CYCLE_APPROX_1 0
+    #endif
+    #if ENABLED(X_DUAL_STEPPER_DRIVERS)
+      #define _CYCLE_APPROX_2 _CYCLE_APPROX_1 + 4
+    #else
+      #define _CYCLE_APPROX_2 _CYCLE_APPROX_1
+    #endif
+    #if HAS_Y_STEP
+      #define _CYCLE_APPROX_3 _CYCLE_APPROX_2 + 5
+    #else
+      #define _CYCLE_APPROX_3 _CYCLE_APPROX_2
+    #endif
+    #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+      #define _CYCLE_APPROX_4 _CYCLE_APPROX_3 + 4
+    #else
+      #define _CYCLE_APPROX_4 _CYCLE_APPROX_3
+    #endif
+    #if HAS_Z_STEP
+      #define _CYCLE_APPROX_5 _CYCLE_APPROX_4 + 5
+    #else
+      #define _CYCLE_APPROX_5 _CYCLE_APPROX_4
+    #endif
+    #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
+      #define _CYCLE_APPROX_6 _CYCLE_APPROX_5 + 4
+    #else
+      #define _CYCLE_APPROX_6 _CYCLE_APPROX_5
+    #endif
+    #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+      #if ENABLED(MIXING_EXTRUDER)
+        #define _CYCLE_APPROX_7 _CYCLE_APPROX_6 + (MIXING_STEPPERS) * 6
+      #else
+        #define _CYCLE_APPROX_7 _CYCLE_APPROX_6 + 5
+      #endif
+    #else
+      #define _CYCLE_APPROX_7 _CYCLE_APPROX_6
+    #endif
+
+    #define CYCLES_EATEN_XYZE _CYCLE_APPROX_7
+    #define EXTRA_CYCLES_XYZE (STEP_PULSE_CYCLES - (CYCLES_EATEN_XYZE))
+
+    /**
+     * If a minimum pulse time was specified get the timer 0 value.
+     *
+     * TCNT0 has an 8x prescaler, so it increments every 8 cycles.
+     * That's every 0.5µs on 16MHz and every 0.4µs on 20MHz.
+     * 20 counts of TCNT0 -by itself- is a good pulse delay.
+     * 10µs = 160 or 200 cycles.
+     */
+    #if EXTRA_CYCLES_XYZE > 20
+      uint32_t pulse_start = HAL_timer_get_current_count(STEP_TIMER_NUM);
+    #endif
+
+    #if HAS_X_STEP
+      PULSE_START(X);
+    #endif
+    #if HAS_Y_STEP
+      PULSE_START(Y);
+    #endif
+    #if HAS_Z_STEP
+      PULSE_START(Z);
+    #endif
+
+    // For non-advance use linear interpolation for E also
+    #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+      #if ENABLED(MIXING_EXTRUDER)
+        // Keep updating the single E axis
+        counter_E += current_block->steps[E_AXIS];
+        // Tick the counters used for this mix
+        MIXING_STEPPERS_LOOP(j) {
+          // Step mixing steppers (proportionally)
+          counter_m[j] += current_block->steps[E_AXIS];
+          // Step when the counter goes over zero
+          if (counter_m[j] > 0) En_STEP_WRITE(j, !INVERT_E_STEP_PIN);
+        }
+      #else // !MIXING_EXTRUDER
+        PULSE_START(E);
+      #endif
+    #endif // !ADVANCE && !LIN_ADVANCE
+
+    // For minimum pulse time wait before stopping pulses
+    #if EXTRA_CYCLES_XYZE > 20
+      while (EXTRA_CYCLES_XYZE > (uint32_t)(HAL_timer_get_current_count(STEP_TIMER_NUM) - pulse_start) * (STEPPER_TIMER_PRESCALE)) { /* nada */ }
+      pulse_start = HAL_timer_get_current_count(STEP_TIMER_NUM);
+    #elif EXTRA_CYCLES_XYZE > 0
+      DELAY_NOPS(EXTRA_CYCLES_XYZE);
+    #endif
+
+    #if HAS_X_STEP
+      PULSE_STOP(X);
+    #endif
+    #if HAS_Y_STEP
+      PULSE_STOP(Y);
+    #endif
+    #if HAS_Z_STEP
+      PULSE_STOP(Z);
+    #endif
+
+    #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+      #if ENABLED(MIXING_EXTRUDER)
+        // Always step the single E axis
+        if (counter_E > 0) {
+          counter_E -= current_block->step_event_count;
+          count_position[E_AXIS] += count_direction[E_AXIS];
+        }
+        MIXING_STEPPERS_LOOP(j) {
+          if (counter_m[j] > 0) {
+            counter_m[j] -= current_block->mix_event_count[j];
+            En_STEP_WRITE(j, INVERT_E_STEP_PIN);
+          }
+        }
+      #else // !MIXING_EXTRUDER
+        PULSE_STOP(E);
+      #endif
+    #endif // !ADVANCE && !LIN_ADVANCE
+
+    if (++step_events_completed >= current_block->step_event_count) {
+      all_steps_done = true;
+      break;
+    }
+
+    // For minimum pulse time wait after stopping pulses also
+    #if EXTRA_CYCLES_XYZE > 20
+      if (i) while (EXTRA_CYCLES_XYZE > (uint32_t)(HAL_timer_get_current_count(STEP_TIMER_NUM) - pulse_start) * (STEPPER_TIMER_PRESCALE)) { /* nada */ }
+    #elif EXTRA_CYCLES_XYZE > 0
+      if (i) DELAY_NOPS(EXTRA_CYCLES_XYZE);
+    #endif
+
+  } // steps_loop
+
+  #if ENABLED(LIN_ADVANCE)
+    if (current_block->use_advance_lead) {
+      const int delta_adv_steps = current_estep_rate[TOOL_E_INDEX] - current_adv_steps[TOOL_E_INDEX];
+      current_adv_steps[TOOL_E_INDEX] += delta_adv_steps;
+      #if ENABLED(MIXING_EXTRUDER)
+        // Mixing extruders apply advance lead proportionally
+        MIXING_STEPPERS_LOOP(j)
+          e_steps[j] += delta_adv_steps * current_block->step_event_count / current_block->mix_event_count[j];
+      #else
+        // For most extruders, advance the single E stepper
+        e_steps[TOOL_E_INDEX] += delta_adv_steps;
+      #endif
+   }
+  #endif
+
+  #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+    // If we have esteps to execute, fire the next advance_isr "now"
+    if (e_steps[TOOL_E_INDEX]) nextAdvanceISR = 0;
+  #endif
+
+  // Calculate new timer value
+  if (step_events_completed <= (uint32_t)current_block->accelerate_until) {
+
+    #ifdef CPU_32_BIT
+      MultiU32X24toH32(acc_step_rate, acceleration_time, current_block->acceleration_rate);
+    #else
+      MultiU24X32toH16(acc_step_rate, acceleration_time, current_block->acceleration_rate);
+    #endif
+    acc_step_rate += current_block->initial_rate;
+
+    // upper limit
+    NOMORE(acc_step_rate, current_block->nominal_rate);
+
+    // step_rate to timer interval
+    const HAL_TIMER_TYPE timer = calc_timer(acc_step_rate);
+
+    SPLIT(timer);  // split step into multiple ISRs if larger than  ENDSTOP_NOMINAL_OCR_VAL
+    _NEXT_ISR(ocr_val);
+
+    acceleration_time += timer;
+
+    #if ENABLED(LIN_ADVANCE)
+
+      if (current_block->use_advance_lead) {
+        #if ENABLED(MIXING_EXTRUDER)
+          MIXING_STEPPERS_LOOP(j)
+            current_estep_rate[j] = ((uint32_t)acc_step_rate * current_block->abs_adv_steps_multiplier8 * current_block->step_event_count / current_block->mix_event_count[j]) >> 17;
+        #else
+          current_estep_rate[TOOL_E_INDEX] = ((uint32_t)acc_step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
+        #endif
+      }
+
+    #elif ENABLED(ADVANCE)
+
+      advance += advance_rate * step_loops;
+      //NOLESS(advance, current_block->advance);
+
+      const long advance_whole = advance >> 8,
+                 advance_factor = advance_whole - old_advance;
+
+      // Do E steps + advance steps
+      #if ENABLED(MIXING_EXTRUDER)
+        // ...for mixing steppers proportionally
+        MIXING_STEPPERS_LOOP(j)
+          e_steps[j] += advance_factor * current_block->step_event_count / current_block->mix_event_count[j];
+      #else
+        // ...for the active extruder
+        e_steps[TOOL_E_INDEX] += advance_factor;
+      #endif
+
+      old_advance = advance_whole;
+
+    #endif // ADVANCE or LIN_ADVANCE
+
+    #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+      // TODO: HAL
+      eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], timer, step_loops);
+    #endif
+  }
+  else if (step_events_completed > (uint32_t)current_block->decelerate_after) {
+    HAL_TIMER_TYPE step_rate;
+    #ifdef CPU_32_BIT
+      MultiU32X24toH32(step_rate, deceleration_time, current_block->acceleration_rate);
+    #else
+      MultiU24X32toH16(step_rate, deceleration_time, current_block->acceleration_rate);
+    #endif
+
+    if (step_rate < acc_step_rate) { // Still decelerating?
+      step_rate = acc_step_rate - step_rate;
+      NOLESS(step_rate, current_block->final_rate);
+    }
+    else
+      step_rate = current_block->final_rate;
+
+    // step_rate to timer interval
+    const HAL_TIMER_TYPE timer = calc_timer(step_rate);
+
+    SPLIT(timer);  // split step into multiple ISRs if larger than  ENDSTOP_NOMINAL_OCR_VAL
+    _NEXT_ISR(ocr_val);
+
+    deceleration_time += timer;
+
+    #if ENABLED(LIN_ADVANCE)
+
+      if (current_block->use_advance_lead) {
+        #if ENABLED(MIXING_EXTRUDER)
+          MIXING_STEPPERS_LOOP(j)
+            current_estep_rate[j] = ((uint32_t)step_rate * current_block->abs_adv_steps_multiplier8 * current_block->step_event_count / current_block->mix_event_count[j]) >> 17;
+        #else
+          current_estep_rate[TOOL_E_INDEX] = ((uint32_t)step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
+        #endif
+      }
+
+    #elif ENABLED(ADVANCE)
+
+      advance -= advance_rate * step_loops;
+      NOLESS(advance, final_advance);
+
+      // Do E steps + advance steps
+      const long advance_whole = advance >> 8,
+                 advance_factor = advance_whole - old_advance;
+
+      #if ENABLED(MIXING_EXTRUDER)
+        MIXING_STEPPERS_LOOP(j)
+          e_steps[j] += advance_factor * current_block->step_event_count / current_block->mix_event_count[j];
+      #else
+        e_steps[TOOL_E_INDEX] += advance_factor;
+      #endif
+
+      old_advance = advance_whole;
+
+    #endif // ADVANCE or LIN_ADVANCE
+
+    #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+      eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], timer, step_loops);
+    #endif
+  }
+  else {
+
+    #if ENABLED(LIN_ADVANCE)
+
+      if (current_block->use_advance_lead)
+        current_estep_rate[TOOL_E_INDEX] = final_estep_rate;
+
+      eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], OCR1A_nominal, step_loops_nominal);
+
+    #endif
+
+    SPLIT(OCR1A_nominal);  // split step into multiple ISRs if larger than  ENDSTOP_NOMINAL_OCR_VAL
+    _NEXT_ISR(ocr_val);
+    // ensure we're running at the correct step rate, even if we just came off an acceleration
+    step_loops = step_loops_nominal;
+  }
+
+  #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+    #ifdef CPU_32_BIT
+      // Make sure stepper interrupt does not monopolise CPU by adjusting count to give about 8 us room
+      uint32_t stepper_timer_count = HAL_timer_get_count(STEP_TIMER_NUM),
+               stepper_timer_current_count = HAL_timer_get_current_count(STEP_TIMER_NUM) + 8 * HAL_TICKS_PER_US;
+      HAL_timer_set_count(STEP_TIMER_NUM, max(stepper_timer_count, stepper_timer_current_count));
+    #else
+      NOLESS(OCR1A, TCNT1 + 16);
+    #endif
+  #endif
+
+  // If current block is finished, reset pointer
+  if (all_steps_done) {
+    current_block = NULL;
+    planner.discard_current_block();
+  }
+  #if DISABLED(ADVANCE) && DISABLED(LIN_ADVANCE)
+    HAL_ENABLE_ISRs(); // re-enable ISRs
+  #endif
+}
+
+#if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+
+  #define CYCLES_EATEN_E (E_STEPPERS * 5)
+  #define EXTRA_CYCLES_E (STEP_PULSE_CYCLES - (CYCLES_EATEN_E))
+
+  // Timer interrupt for E. e_steps is set in the main routine;
+
+  void Stepper::advance_isr() {
+
+    nextAdvanceISR = eISR_Rate;
+
+    #if ENABLED(MK2_MULTIPLEXER)
+      // Even-numbered steppers are reversed
+      #define SET_E_STEP_DIR(INDEX) \
+        if (e_steps[INDEX]) E## INDEX ##_DIR_WRITE(e_steps[INDEX] < 0 ? !INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0) : INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0))
+    #else
+      #define SET_E_STEP_DIR(INDEX) \
+        if (e_steps[INDEX]) E## INDEX ##_DIR_WRITE(e_steps[INDEX] < 0 ? INVERT_E## INDEX ##_DIR : !INVERT_E## INDEX ##_DIR)
+    #endif
+
+    #define START_E_PULSE(INDEX) \
+      if (e_steps[INDEX]) E## INDEX ##_STEP_WRITE(!INVERT_E_STEP_PIN)
+
+    #define STOP_E_PULSE(INDEX) \
+      if (e_steps[INDEX]) { \
+        e_steps[INDEX] < 0 ? ++e_steps[INDEX] : --e_steps[INDEX]; \
+        E## INDEX ##_STEP_WRITE(INVERT_E_STEP_PIN); \
+      }
+
+    SET_E_STEP_DIR(0);
+    #if E_STEPPERS > 1
+      SET_E_STEP_DIR(1);
+      #if E_STEPPERS > 2
+        SET_E_STEP_DIR(2);
+        #if E_STEPPERS > 3
+          SET_E_STEP_DIR(3);
+          #if E_STEPPERS > 4
+            SET_E_STEP_DIR(4);
+          #endif
+        #endif
+      #endif
+    #endif
+
+    // Step all E steppers that have steps
+    for (uint8_t i = step_loops; i--;) {
+
+      #if EXTRA_CYCLES_E > 20
+        uint32_t pulse_start = TCNT0;
+      #endif
+
+      START_E_PULSE(0);
+      #if E_STEPPERS > 1
+        START_E_PULSE(1);
+        #if E_STEPPERS > 2
+          START_E_PULSE(2);
+          #if E_STEPPERS > 3
+            START_E_PULSE(3);
+            #if E_STEPPERS > 4
+              START_E_PULSE(4);
+            #endif
+          #endif
+        #endif
+      #endif
+
+      // For minimum pulse time wait before stopping pulses
+      #if EXTRA_CYCLES_E > 20
+        while (EXTRA_CYCLES_E > (uint32_t)(TCNT0 - pulse_start) * (INT0_PRESCALER)) { /* nada */ }
+        pulse_start = TCNT0;
+      #elif EXTRA_CYCLES_E > 0
+        DELAY_NOPS(EXTRA_CYCLES_E);
+      #endif
+
+      STOP_E_PULSE(0);
+      #if E_STEPPERS > 1
+        STOP_E_PULSE(1);
+        #if E_STEPPERS > 2
+          STOP_E_PULSE(2);
+          #if E_STEPPERS > 3
+            STOP_E_PULSE(3);
+            #if E_STEPPERS > 4
+              STOP_E_PULSE(4);
+            #endif
+          #endif
+        #endif
+      #endif
+
+      // For minimum pulse time wait before looping
+      #if EXTRA_CYCLES_E > 20
+        if (i) while (EXTRA_CYCLES_E > (uint32_t)(TCNT0 - pulse_start) * (INT0_PRESCALER)) { /* nada */ }
+      #elif EXTRA_CYCLES_E > 0
+        if (i) DELAY_NOPS(EXTRA_CYCLES_E);
+      #endif
+
+    } // steps_loop
+  }
+
+  void Stepper::advance_isr_scheduler() {
+    // Disable Timer0 ISRs and enable global ISR again to capture UART events (incoming chars)
+    DISABLE_TEMPERATURE_INTERRUPT(); // Temperature ISR
+    DISABLE_STEPPER_DRIVER_INTERRUPT();
+    sei();
+
+    // Run main stepping ISR if flagged
+    if (!nextMainISR) isr();
+
+    // Run Advance stepping ISR if flagged
+    if (!nextAdvanceISR) advance_isr();
+
+    // Is the next advance ISR scheduled before the next main ISR?
+    if (nextAdvanceISR <= nextMainISR) {
+      // Set up the next interrupt
+      HAL_timer_set_count(STEP_TIMER_NUM, nextAdvanceISR);
+      // New interval for the next main ISR
+      if (nextMainISR) nextMainISR -= nextAdvanceISR;
+      // Will call Stepper::advance_isr on the next interrupt
+      nextAdvanceISR = 0;
+    }
+    else {
+      // The next main ISR comes first
+      HAL_timer_set_count(STEP_TIMER_NUM, nextMainISR);
+      // New interval for the next advance ISR, if any
+      if (nextAdvanceISR && nextAdvanceISR != ADV_NEVER)
+        nextAdvanceISR -= nextMainISR;
+      // Will call Stepper::isr on the next interrupt
+      nextMainISR = 0;
+    }
+
+    // Don't run the ISR faster than possible
+    #ifdef CPU_32_BIT
+      // Make sure stepper interrupt does not monopolise CPU by adjusting count to give about 8 us room
+      uint32_t stepper_timer_count = HAL_timer_get_count(STEP_TIMER_NUM),
+               stepper_timer_current_count = HAL_timer_get_current_count(STEP_TIMER_NUM) + 8 * HAL_TICKS_PER_US;
+      HAL_timer_set_count(STEP_TIMER_NUM, max(stepper_timer_count, stepper_timer_current_count));
+    #else
+      NOLESS(OCR1A, TCNT1 + 16);
+    #endif
+
+    // Restore original ISR settings
+    HAL_ENABLE_ISRs();
+  }
+
+#endif // ADVANCE or LIN_ADVANCE
+
+void Stepper::init() {
+
+  // Init Digipot Motor Current
+  #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
+    digipot_init();
+  #endif
+
+  #if MB(ALLIGATOR)
+    const float motor_current[] = MOTOR_CURRENT;
+    unsigned int digipot_motor = 0;
+    for (uint8_t i = 0; i < 3 + EXTRUDERS; i++) {
+      digipot_motor = 255 * (motor_current[i] / 2.5);
+      dac084s085::setValue(i, digipot_motor);
+    }
+  #endif//MB(ALLIGATOR)
+
+  // Init Microstepping Pins
+  #if HAS_MICROSTEPS
+    microstep_init();
+  #endif
+
+  // Init TMC Steppers
+  #if ENABLED(HAVE_TMCDRIVER)
+    tmc_init();
+  #endif
+
+  // Init TMC2130 Steppers
+  #if ENABLED(HAVE_TMC2130)
+    tmc2130_init();
+  #endif
+
+  // Init L6470 Steppers
+  #if ENABLED(HAVE_L6470DRIVER)
+    L6470_init();
+  #endif
+
+  // Init Dir Pins
+  #if HAS_X_DIR
+    X_DIR_INIT;
+  #endif
+  #if HAS_X2_DIR
+    X2_DIR_INIT;
+  #endif
+  #if HAS_Y_DIR
+    Y_DIR_INIT;
+    #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_DIR
+      Y2_DIR_INIT;
+    #endif
+  #endif
+  #if HAS_Z_DIR
+    Z_DIR_INIT;
+    #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_DIR
+      Z2_DIR_INIT;
+    #endif
+  #endif
+  #if HAS_E0_DIR
+    E0_DIR_INIT;
+  #endif
+  #if HAS_E1_DIR
+    E1_DIR_INIT;
+  #endif
+  #if HAS_E2_DIR
+    E2_DIR_INIT;
+  #endif
+  #if HAS_E3_DIR
+    E3_DIR_INIT;
+  #endif
+  #if HAS_E4_DIR
+    E4_DIR_INIT;
+  #endif
+
+  // Init Enable Pins - steppers default to disabled.
+  #if HAS_X_ENABLE
+    X_ENABLE_INIT;
+    if (!X_ENABLE_ON) X_ENABLE_WRITE(HIGH);
+    #if ENABLED(DUAL_X_CARRIAGE) && HAS_X2_ENABLE
+      X2_ENABLE_INIT;
+      if (!X_ENABLE_ON) X2_ENABLE_WRITE(HIGH);
+    #endif
+  #endif
+  #if HAS_Y_ENABLE
+    Y_ENABLE_INIT;
+    if (!Y_ENABLE_ON) Y_ENABLE_WRITE(HIGH);
+    #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_ENABLE
+      Y2_ENABLE_INIT;
+      if (!Y_ENABLE_ON) Y2_ENABLE_WRITE(HIGH);
+    #endif
+  #endif
+  #if HAS_Z_ENABLE
+    Z_ENABLE_INIT;
+    if (!Z_ENABLE_ON) Z_ENABLE_WRITE(HIGH);
+    #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_ENABLE
+      Z2_ENABLE_INIT;
+      if (!Z_ENABLE_ON) Z2_ENABLE_WRITE(HIGH);
+    #endif
+  #endif
+  #if HAS_E0_ENABLE
+    E0_ENABLE_INIT;
+    if (!E_ENABLE_ON) E0_ENABLE_WRITE(HIGH);
+  #endif
+  #if HAS_E1_ENABLE
+    E1_ENABLE_INIT;
+    if (!E_ENABLE_ON) E1_ENABLE_WRITE(HIGH);
+  #endif
+  #if HAS_E2_ENABLE
+    E2_ENABLE_INIT;
+    if (!E_ENABLE_ON) E2_ENABLE_WRITE(HIGH);
+  #endif
+  #if HAS_E3_ENABLE
+    E3_ENABLE_INIT;
+    if (!E_ENABLE_ON) E3_ENABLE_WRITE(HIGH);
+  #endif
+  #if HAS_E4_ENABLE
+    E4_ENABLE_INIT;
+    if (!E_ENABLE_ON) E4_ENABLE_WRITE(HIGH);
+  #endif
+
+  // Init endstops and pullups
+  endstops.init();
+
+  #define _STEP_INIT(AXIS) AXIS ##_STEP_INIT
+  #define _WRITE_STEP(AXIS, HIGHLOW) AXIS ##_STEP_WRITE(HIGHLOW)
+  #define _DISABLE(AXIS) disable_## AXIS()
+
+  #define AXIS_INIT(AXIS, PIN) \
+    _STEP_INIT(AXIS); \
+    _WRITE_STEP(AXIS, _INVERT_STEP_PIN(PIN)); \
+    _DISABLE(AXIS)
+
+  #define E_AXIS_INIT(NUM) AXIS_INIT(E## NUM, E)
+
+  // Init Step Pins
+  #if HAS_X_STEP
+    #if ENABLED(X_DUAL_STEPPER_DRIVERS) || ENABLED(DUAL_X_CARRIAGE)
+      X2_STEP_INIT;
+      X2_STEP_WRITE(INVERT_X_STEP_PIN);
+    #endif
+    AXIS_INIT(X, X);
+  #endif
+
+  #if HAS_Y_STEP
+    #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+      Y2_STEP_INIT;
+      Y2_STEP_WRITE(INVERT_Y_STEP_PIN);
+    #endif
+    AXIS_INIT(Y, Y);
+  #endif
+
+  #if HAS_Z_STEP
+    #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
+      Z2_STEP_INIT;
+      Z2_STEP_WRITE(INVERT_Z_STEP_PIN);
+    #endif
+    AXIS_INIT(Z, Z);
+  #endif
+
+  #if HAS_E0_STEP
+    E_AXIS_INIT(0);
+  #endif
+  #if HAS_E1_STEP
+    E_AXIS_INIT(1);
+  #endif
+  #if HAS_E2_STEP
+    E_AXIS_INIT(2);
+  #endif
+  #if HAS_E3_STEP
+    E_AXIS_INIT(3);
+  #endif
+  #if HAS_E4_STEP
+    E_AXIS_INIT(4);
+  #endif
+
+  #ifdef ARDUINO_ARCH_AVR
+    // waveform generation = 0100 = CTC
+    SET_WGM(1, CTC_OCRnA);
+
+    // output mode = 00 (disconnected)
+    SET_COMA(1, NORMAL);
+
+    // Set the timer pre-scaler
+    // Generally we use a divider of 8, resulting in a 2MHz timer
+    // frequency on a 16MHz MCU. If you are going to change this, be
+    // sure to regenerate speed_lookuptable.h with
+    // create_speed_lookuptable.py
+    SET_CS(1, PRESCALER_8);  //  CS 2 = 1/8 prescaler
+
+    // Init Stepper ISR to 122 Hz for quick starting
+    OCR1A = 0x4000;
+    TCNT1 = 0;
+  #else
+    // Init Stepper ISR to 122 Hz for quick starting
+    HAL_timer_start(STEP_TIMER_NUM, 122);
+  #endif
+
+  ENABLE_STEPPER_DRIVER_INTERRUPT();
+
+  #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+    for (uint8_t i = 0; i < COUNT(e_steps); i++) e_steps[i] = 0;
+    #if ENABLED(LIN_ADVANCE)
+      ZERO(current_adv_steps);
+    #endif
+  #endif // ADVANCE || LIN_ADVANCE
+
+  endstops.enable(true); // Start with endstops active. After homing they can be disabled
+  sei();
+
+  set_directions(); // Init directions to last_direction_bits = 0
+}
+
+
+/**
+ * Block until all buffered steps are executed
+ */
+void Stepper::synchronize() { while (planner.blocks_queued()) idle(); }
+
+/**
+ * Set the stepper positions directly in steps
+ *
+ * The input is based on the typical per-axis XYZ steps.
+ * For CORE machines XYZ needs to be translated to ABC.
+ *
+ * This allows get_axis_position_mm to correctly
+ * derive the current XYZ position later on.
+ */
+void Stepper::set_position(const long &a, const long &b, const long &c, const long &e) {
+
+  synchronize(); // Bad to set stepper counts in the middle of a move
+
+  CRITICAL_SECTION_START;
+
+  #if CORE_IS_XY
+    // corexy positioning
+    // these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html
+    count_position[A_AXIS] = a + b;
+    count_position[B_AXIS] = CORESIGN(a - b);
+    count_position[Z_AXIS] = c;
+  #elif CORE_IS_XZ
+    // corexz planning
+    count_position[A_AXIS] = a + c;
+    count_position[Y_AXIS] = b;
+    count_position[C_AXIS] = CORESIGN(a - c);
+  #elif CORE_IS_YZ
+    // coreyz planning
+    count_position[X_AXIS] = a;
+    count_position[B_AXIS] = b + c;
+    count_position[C_AXIS] = CORESIGN(b - c);
+  #else
+    // default non-h-bot planning
+    count_position[X_AXIS] = a;
+    count_position[Y_AXIS] = b;
+    count_position[Z_AXIS] = c;
+  #endif
+
+  count_position[E_AXIS] = e;
+  CRITICAL_SECTION_END;
+}
+
+void Stepper::set_position(const AxisEnum &axis, const long &v) {
+  CRITICAL_SECTION_START;
+  count_position[axis] = v;
+  CRITICAL_SECTION_END;
+}
+
+void Stepper::set_e_position(const long &e) {
+  CRITICAL_SECTION_START;
+  count_position[E_AXIS] = e;
+  CRITICAL_SECTION_END;
+}
+
+/**
+ * Get a stepper's position in steps.
+ */
+long Stepper::position(AxisEnum axis) {
+  CRITICAL_SECTION_START;
+  const long count_pos = count_position[axis];
+  CRITICAL_SECTION_END;
+  return count_pos;
+}
+
+/**
+ * Get an axis position according to stepper position(s)
+ * For CORE machines apply translation from ABC to XYZ.
+ */
+float Stepper::get_axis_position_mm(AxisEnum axis) {
+  float axis_steps;
+  #if IS_CORE
+    // Requesting one of the "core" axes?
+    if (axis == CORE_AXIS_1 || axis == CORE_AXIS_2) {
+      CRITICAL_SECTION_START;
+      // ((a1+a2)+(a1-a2))/2 -> (a1+a2+a1-a2)/2 -> (a1+a1)/2 -> a1
+      // ((a1+a2)-(a1-a2))/2 -> (a1+a2-a1+a2)/2 -> (a2+a2)/2 -> a2
+      axis_steps = 0.5f * (
+        axis == CORE_AXIS_2 ? CORESIGN(count_position[CORE_AXIS_1] - count_position[CORE_AXIS_2])
+                            : count_position[CORE_AXIS_1] + count_position[CORE_AXIS_2]
+      );
+      CRITICAL_SECTION_END;
+    }
+    else
+      axis_steps = position(axis);
+  #else
+    axis_steps = position(axis);
+  #endif
+  return axis_steps * planner.steps_to_mm[axis];
+}
+
+void Stepper::finish_and_disable() {
+  synchronize();
+  disable_all_steppers();
+}
+
+void Stepper::quick_stop() {
+  #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)
+    if (!ubl_lcd_map_control)
+      cleaning_buffer_counter = 5000;
+  #else
+    cleaning_buffer_counter = 5000;
+  #endif
+  DISABLE_STEPPER_DRIVER_INTERRUPT();
+  while (planner.blocks_queued()) planner.discard_current_block();
+  current_block = NULL;
+  ENABLE_STEPPER_DRIVER_INTERRUPT();
+  #if ENABLED(ULTRA_LCD)
+    planner.clear_block_buffer_runtime();
+  #endif
+}
+
+void Stepper::endstop_triggered(AxisEnum axis) {
+
+  #if IS_CORE
+
+    endstops_trigsteps[axis] = 0.5f * (
+      axis == CORE_AXIS_2 ? CORESIGN(count_position[CORE_AXIS_1] - count_position[CORE_AXIS_2])
+                          : count_position[CORE_AXIS_1] + count_position[CORE_AXIS_2]
+    );
+
+  #else // !COREXY && !COREXZ && !COREYZ
+
+    endstops_trigsteps[axis] = count_position[axis];
+
+  #endif // !COREXY && !COREXZ && !COREYZ
+
+  kill_current_block();
+}
+
+void Stepper::report_positions() {
+  CRITICAL_SECTION_START;
+  const long xpos = count_position[X_AXIS],
+             ypos = count_position[Y_AXIS],
+             zpos = count_position[Z_AXIS];
+  CRITICAL_SECTION_END;
+
+  #if CORE_IS_XY || CORE_IS_XZ || IS_SCARA
+    SERIAL_PROTOCOLPGM(MSG_COUNT_A);
+  #else
+    SERIAL_PROTOCOLPGM(MSG_COUNT_X);
+  #endif
+  SERIAL_PROTOCOL(xpos);
+
+  #if CORE_IS_XY || CORE_IS_YZ || IS_SCARA
+    SERIAL_PROTOCOLPGM(" B:");
+  #else
+    SERIAL_PROTOCOLPGM(" Y:");
+  #endif
+  SERIAL_PROTOCOL(ypos);
+
+  #if CORE_IS_XZ || CORE_IS_YZ
+    SERIAL_PROTOCOLPGM(" C:");
+  #else
+    SERIAL_PROTOCOLPGM(" Z:");
+  #endif
+  SERIAL_PROTOCOL(zpos);
+
+  SERIAL_EOL();
+}
+
+#if ENABLED(BABYSTEPPING)
+
+  #if ENABLED(DELTA)
+    #define CYCLES_EATEN_BABYSTEP (2 * 15)
+  #else
+    #define CYCLES_EATEN_BABYSTEP 0
+  #endif
+  #define EXTRA_CYCLES_BABYSTEP (STEP_PULSE_CYCLES - (CYCLES_EATEN_BABYSTEP))
+
+  #define _ENABLE(AXIS) enable_## AXIS()
+  #define _READ_DIR(AXIS) AXIS ##_DIR_READ
+  #define _INVERT_DIR(AXIS) INVERT_## AXIS ##_DIR
+  #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)
+
+  #if EXTRA_CYCLES_BABYSTEP > 20
+    #define _SAVE_START const uint32_t pulse_start = TCNT0
+    #define _PULSE_WAIT while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(TCNT0 - pulse_start) * (INT0_PRESCALER)) { /* nada */ }
+  #else
+    #define _SAVE_START NOOP
+    #if EXTRA_CYCLES_BABYSTEP > 0
+      #define _PULSE_WAIT DELAY_NOPS(EXTRA_CYCLES_BABYSTEP)
+    #elif STEP_PULSE_CYCLES > 0
+      #define _PULSE_WAIT NOOP
+    #elif ENABLED(DELTA)
+      #define _PULSE_WAIT delayMicroseconds(2);
+    #else
+      #define _PULSE_WAIT delayMicroseconds(4);
+    #endif
+  #endif
+
+  #define BABYSTEP_AXIS(AXIS, INVERT) {                     \
+      const uint8_t old_dir = _READ_DIR(AXIS);              \
+      _ENABLE(AXIS);                                        \
+      _SAVE_START;                                          \
+      _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^direction^INVERT); \
+      _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), true);     \
+      _PULSE_WAIT;                                          \
+      _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), true);      \
+      _APPLY_DIR(AXIS, old_dir);                            \
+    }
+
+  // MUST ONLY BE CALLED BY AN ISR,
+  // No other ISR should ever interrupt this!
+  void Stepper::babystep(const AxisEnum axis, const bool direction) {
+    cli();
+
+    switch (axis) {
+
+      #if ENABLED(BABYSTEP_XY)
+
+        case X_AXIS:
+          BABYSTEP_AXIS(X, false);
+          break;
+
+        case Y_AXIS:
+          BABYSTEP_AXIS(Y, false);
+          break;
+
+      #endif
+
+      case Z_AXIS: {
+
+        #if DISABLED(DELTA)
+
+          BABYSTEP_AXIS(Z, BABYSTEP_INVERT_Z);
+
+        #else // DELTA
+
+          const bool z_direction = direction ^ BABYSTEP_INVERT_Z;
+
+          enable_X();
+          enable_Y();
+          enable_Z();
+
+          const uint8_t old_x_dir_pin = X_DIR_READ,
+                        old_y_dir_pin = Y_DIR_READ,
+                        old_z_dir_pin = Z_DIR_READ;
+
+          X_DIR_WRITE(INVERT_X_DIR ^ z_direction);
+          Y_DIR_WRITE(INVERT_Y_DIR ^ z_direction);
+          Z_DIR_WRITE(INVERT_Z_DIR ^ z_direction);
+
+          _SAVE_START;
+
+          X_STEP_WRITE(!INVERT_X_STEP_PIN);
+          Y_STEP_WRITE(!INVERT_Y_STEP_PIN);
+          Z_STEP_WRITE(!INVERT_Z_STEP_PIN);
+
+          _PULSE_WAIT;
+
+          X_STEP_WRITE(INVERT_X_STEP_PIN);
+          Y_STEP_WRITE(INVERT_Y_STEP_PIN);
+          Z_STEP_WRITE(INVERT_Z_STEP_PIN);
+
+          // Restore direction bits
+          X_DIR_WRITE(old_x_dir_pin);
+          Y_DIR_WRITE(old_y_dir_pin);
+          Z_DIR_WRITE(old_z_dir_pin);
+
+        #endif
+
+      } break;
+
+      default: break;
+    }
+    sei();
+  }
+
+#endif // BABYSTEPPING
+
+/**
+ * Software-controlled Stepper Motor Current
+ */
+
+#if HAS_DIGIPOTSS
+
+  // From Arduino DigitalPotControl example
+  void Stepper::digitalPotWrite(const int16_t address, const int16_t value) {
+    WRITE(DIGIPOTSS_PIN, LOW);  // Take the SS pin low to select the chip
+    SPI.transfer(address);      // Send the address and value via SPI
+    SPI.transfer(value);
+    WRITE(DIGIPOTSS_PIN, HIGH); // Take the SS pin high to de-select the chip
+    //delay(10);
+  }
+
+#endif // HAS_DIGIPOTSS
+
+#if HAS_MOTOR_CURRENT_PWM
+
+  void Stepper::refresh_motor_power() {
+    for (uint8_t i = 0; i < COUNT(motor_current_setting); ++i) {
+      switch (i) {
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
+          case 0:
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
+          case 1:
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
+          case 2:
+        #endif
+            digipot_current(i, motor_current_setting[i]);
+        default: break;
+      }
+    }
+  }
+
+#endif // HAS_MOTOR_CURRENT_PWM
+
+#if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
+
+  void Stepper::digipot_current(const uint8_t driver, const int current) {
+
+    #if HAS_DIGIPOTSS
+
+      const uint8_t digipot_ch[] = DIGIPOT_CHANNELS;
+      digitalPotWrite(digipot_ch[driver], current);
+
+    #elif HAS_MOTOR_CURRENT_PWM
+
+      if (WITHIN(driver, 0, 2))
+        motor_current_setting[driver] = current; // update motor_current_setting
+
+      #define _WRITE_CURRENT_PWM(P) analogWrite(MOTOR_CURRENT_PWM_## P ##_PIN, 255L * current / (MOTOR_CURRENT_PWM_RANGE))
+      switch (driver) {
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
+          case 0: _WRITE_CURRENT_PWM(XY); break;
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
+          case 1: _WRITE_CURRENT_PWM(Z); break;
+        #endif
+        #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
+          case 2: _WRITE_CURRENT_PWM(E); break;
+        #endif
+      }
+    #endif
+  }
+
+  void Stepper::digipot_init() {
+
+    #if HAS_DIGIPOTSS
+
+      static const uint8_t digipot_motor_current[] = DIGIPOT_MOTOR_CURRENT;
+
+      SPI.begin();
+      SET_OUTPUT(DIGIPOTSS_PIN);
+
+      for (uint8_t i = 0; i < COUNT(digipot_motor_current); i++) {
+        //digitalPotWrite(digipot_ch[i], digipot_motor_current[i]);
+        digipot_current(i, digipot_motor_current[i]);
+      }
+
+    #elif HAS_MOTOR_CURRENT_PWM
+
+      #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
+        SET_OUTPUT(MOTOR_CURRENT_PWM_XY_PIN);
+      #endif
+      #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
+        SET_OUTPUT(MOTOR_CURRENT_PWM_Z_PIN);
+      #endif
+      #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
+        SET_OUTPUT(MOTOR_CURRENT_PWM_E_PIN);
+      #endif
+
+      refresh_motor_power();
+
+      // Set Timer5 to 31khz so the PWM of the motor power is as constant as possible. (removes a buzzing noise)
+      SET_CS5(PRESCALER_1);
+
+    #endif
+  }
+
+#endif
+
+#if HAS_MICROSTEPS
+
+  /**
+   * Software-controlled Microstepping
+   */
+
+  void Stepper::microstep_init() {
+    SET_OUTPUT(X_MS1_PIN);
+    SET_OUTPUT(X_MS2_PIN);
+    #if HAS_Y_MICROSTEPS
+      SET_OUTPUT(Y_MS1_PIN);
+      SET_OUTPUT(Y_MS2_PIN);
+    #endif
+    #if HAS_Z_MICROSTEPS
+      SET_OUTPUT(Z_MS1_PIN);
+      SET_OUTPUT(Z_MS2_PIN);
+    #endif
+    #if HAS_E0_MICROSTEPS
+      SET_OUTPUT(E0_MS1_PIN);
+      SET_OUTPUT(E0_MS2_PIN);
+    #endif
+    #if HAS_E1_MICROSTEPS
+      SET_OUTPUT(E1_MS1_PIN);
+      SET_OUTPUT(E1_MS2_PIN);
+    #endif
+    #if HAS_E2_MICROSTEPS
+      SET_OUTPUT(E2_MS1_PIN);
+      SET_OUTPUT(E2_MS2_PIN);
+    #endif
+    #if HAS_E3_MICROSTEPS
+      SET_OUTPUT(E3_MS1_PIN);
+      SET_OUTPUT(E3_MS2_PIN);
+    #endif
+    #if HAS_E4_MICROSTEPS
+      SET_OUTPUT(E4_MS1_PIN);
+      SET_OUTPUT(E4_MS2_PIN);
+    #endif
+    static const uint8_t microstep_modes[] = MICROSTEP_MODES;
+    for (uint16_t i = 0; i < COUNT(microstep_modes); i++)
+      microstep_mode(i, microstep_modes[i]);
+  }
+
+  void Stepper::microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2) {
+    if (ms1 >= 0) switch (driver) {
+      case 0: WRITE(X_MS1_PIN, ms1); break;
+      #if HAS_Y_MICROSTEPS
+        case 1: WRITE(Y_MS1_PIN, ms1); break;
+      #endif
+      #if HAS_Z_MICROSTEPS
+        case 2: WRITE(Z_MS1_PIN, ms1); break;
+      #endif
+      #if HAS_E0_MICROSTEPS
+        case 3: WRITE(E0_MS1_PIN, ms1); break;
+      #endif
+      #if HAS_E1_MICROSTEPS
+        case 4: WRITE(E1_MS1_PIN, ms1); break;
+      #endif
+      #if HAS_E2_MICROSTEPS
+        case 5: WRITE(E2_MS1_PIN, ms1); break;
+      #endif
+      #if HAS_E3_MICROSTEPS
+        case 6: WRITE(E3_MS1_PIN, ms1); break;
+      #endif
+      #if HAS_E4_MICROSTEPS
+        case 7: WRITE(E4_MS1_PIN, ms1); break;
+      #endif
+    }
+    if (ms2 >= 0) switch (driver) {
+      case 0: WRITE(X_MS2_PIN, ms2); break;
+      #if HAS_Y_MICROSTEPS
+        case 1: WRITE(Y_MS2_PIN, ms2); break;
+      #endif
+      #if HAS_Z_MICROSTEPS
+        case 2: WRITE(Z_MS2_PIN, ms2); break;
+      #endif
+      #if HAS_E0_MICROSTEPS
+        case 3: WRITE(E0_MS2_PIN, ms2); break;
+      #endif
+      #if HAS_E1_MICROSTEPS
+        case 4: WRITE(E1_MS2_PIN, ms2); break;
+      #endif
+      #if HAS_E2_MICROSTEPS
+        case 5: WRITE(E2_MS2_PIN, ms2); break;
+      #endif
+      #if HAS_E3_MICROSTEPS
+        case 6: WRITE(E3_MS2_PIN, ms2); break;
+      #endif
+      #if HAS_E4_MICROSTEPS
+        case 7: WRITE(E4_MS2_PIN, ms2); break;
+      #endif
+    }
+  }
+
+  void Stepper::microstep_mode(const uint8_t driver, const uint8_t stepping_mode) {
+    switch (stepping_mode) {
+      case 1: microstep_ms(driver, MICROSTEP1); break;
+      case 2: microstep_ms(driver, MICROSTEP2); break;
+      case 4: microstep_ms(driver, MICROSTEP4); break;
+      case 8: microstep_ms(driver, MICROSTEP8); break;
+      case 16: microstep_ms(driver, MICROSTEP16); break;
+      #if MB(ALLIGATOR)
+        case 32: microstep_ms(driver, MICROSTEP32); break;
+      #endif
+    }
+  }
+
+  void Stepper::microstep_readings() {
+    SERIAL_PROTOCOLLNPGM("MS1,MS2 Pins");
+    SERIAL_PROTOCOLPGM("X: ");
+    SERIAL_PROTOCOL(READ(X_MS1_PIN));
+    SERIAL_PROTOCOLLN(READ(X_MS2_PIN));
+    #if HAS_Y_MICROSTEPS
+      SERIAL_PROTOCOLPGM("Y: ");
+      SERIAL_PROTOCOL(READ(Y_MS1_PIN));
+      SERIAL_PROTOCOLLN(READ(Y_MS2_PIN));
+    #endif
+    #if HAS_Z_MICROSTEPS
+      SERIAL_PROTOCOLPGM("Z: ");
+      SERIAL_PROTOCOL(READ(Z_MS1_PIN));
+      SERIAL_PROTOCOLLN(READ(Z_MS2_PIN));
+    #endif
+    #if HAS_E0_MICROSTEPS
+      SERIAL_PROTOCOLPGM("E0: ");
+      SERIAL_PROTOCOL(READ(E0_MS1_PIN));
+      SERIAL_PROTOCOLLN(READ(E0_MS2_PIN));
+    #endif
+    #if HAS_E1_MICROSTEPS
+      SERIAL_PROTOCOLPGM("E1: ");
+      SERIAL_PROTOCOL(READ(E1_MS1_PIN));
+      SERIAL_PROTOCOLLN(READ(E1_MS2_PIN));
+    #endif
+    #if HAS_E2_MICROSTEPS
+      SERIAL_PROTOCOLPGM("E2: ");
+      SERIAL_PROTOCOL(READ(E2_MS1_PIN));
+      SERIAL_PROTOCOLLN(READ(E2_MS2_PIN));
+    #endif
+    #if HAS_E3_MICROSTEPS
+      SERIAL_PROTOCOLPGM("E3: ");
+      SERIAL_PROTOCOL(READ(E3_MS1_PIN));
+      SERIAL_PROTOCOLLN(READ(E3_MS2_PIN));
+    #endif
+    #if HAS_E4_MICROSTEPS
+      SERIAL_PROTOCOLPGM("E4: ");
+      SERIAL_PROTOCOL(READ(E4_MS1_PIN));
+      SERIAL_PROTOCOLLN(READ(E4_MS2_PIN));
+    #endif
+  }
+
+#endif // HAS_MICROSTEPS
