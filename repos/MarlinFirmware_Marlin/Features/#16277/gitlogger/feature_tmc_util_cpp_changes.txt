commit f9d5ee04b4930fa7b876c278e80072060463f55c
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Thu Feb 1 07:33:42 2024 +1300

    ü©π Patch STM32 serial UUID (#26737)
    
    Followup to #26715
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index bff6872e4d..421f9b0c22 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -763,7 +763,7 @@
         SERIAL_CHAR('\t');
         st.printLabel();
         SERIAL_CHAR('\t');
-        print_hex_long(drv_status, ':');
+        print_hex_long(drv_status, ':', true);
         if (drv_status == 0xFFFFFFFF || drv_status == 0) SERIAL_ECHOPGM("\t Bad response!");
         SERIAL_EOL();
         break;

commit 574dd34c49fde76e1e736b8a7e1ea579d724ff22
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 13:19:36 2023 -0500

    ‚ôªÔ∏è String helper class (#24390)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 556a608914..bff6872e4d 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -213,47 +213,46 @@
 
   template<typename TMC>
   void report_driver_otpw(TMC &st) {
-    char timestamp[14];
+    MString<13> timestamp;
     duration_t elapsed = print_job_timer.duration();
     const bool has_days = (elapsed.value > 60*60*24L);
-    (void)elapsed.toDigital(timestamp, has_days);
-    SERIAL_EOL();
-    SERIAL_ECHO(timestamp);
-    SERIAL_ECHOPGM(": ");
+    (void)elapsed.toDigital(&timestamp, has_days);
+    TSS('\n', timestamp, F(": ")).echo();
     st.printLabel();
-    SERIAL_ECHOLNPGM(" driver overtemperature warning! (", st.getMilliamps(), "mA)");
+    SString<50>(F(" driver overtemperature warning! ("), st.getMilliamps(), F("mA)")).echoln();
   }
 
   template<typename TMC>
   void report_polled_driver_data(TMC &st, const TMC_driver_data &data) {
     const uint32_t pwm_scale = get_pwm_scale(st);
     st.printLabel();
-    SERIAL_CHAR(':'); SERIAL_ECHO(pwm_scale);
+    SString<60> report(':', pwm_scale);
     #if ENABLED(TMC_DEBUG)
       #if HAS_TMCX1X0 || HAS_TMC220x
-        SERIAL_CHAR('/'); SERIAL_ECHO(data.cs_actual);
+        report.append('/', data.cs_actual);
       #endif
       #if HAS_STALLGUARD
-        SERIAL_CHAR('/');
+        report += '/';
         if (data.sg_result_reasonable)
-          SERIAL_ECHO(data.sg_result);
+          report += data.sg_result;
         else
-          SERIAL_CHAR('-');
+          report += '-';
       #endif
     #endif
-    SERIAL_CHAR('|');
-    if (st.error_count)       SERIAL_CHAR('E'); // Error
-    if (data.is_ot)           SERIAL_CHAR('O'); // Over-temperature
-    if (data.is_otpw)         SERIAL_CHAR('W'); // over-temperature pre-Warning
+    report += '|';
+    if (st.error_count)       report += 'E'; // Error
+    if (data.is_ot)           report += 'O'; // Over-temperature
+    if (data.is_otpw)         report += 'W'; // over-temperature pre-Warning
     #if ENABLED(TMC_DEBUG)
-      if (data.is_stall)      SERIAL_CHAR('G'); // stallGuard
-      if (data.is_stealth)    SERIAL_CHAR('T'); // stealthChop
-      if (data.is_standstill) SERIAL_CHAR('I'); // standstIll
-    #endif
-    if (st.flag_otpw)         SERIAL_CHAR('F'); // otpw Flag
-    SERIAL_CHAR('|');
-    if (st.otpw_count > 0) SERIAL_ECHO(st.otpw_count);
-    SERIAL_CHAR('\t');
+      if (data.is_stall)      report += 'G'; // stallGuard
+      if (data.is_stealth)    report += 'T'; // stealthChop
+      if (data.is_standstill) report += 'I'; // standstIll
+    #endif
+    if (st.flag_otpw)         report += 'F'; // otpw Flag
+    report += '|';
+    if (st.otpw_count > 0)    report += st.otpw_count;
+    report += '\t';
+    report.echo();
   }
 
   #if CURRENT_STEP_DOWN > 0

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ‚ôªÔ∏è Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 095e14fe15..556a608914 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -562,7 +562,7 @@
   };
 
   template<class TMC>
-  static void print_vsense(TMC &st) { SERIAL_ECHOF(st.vsense() ? F("1=.18") : F("0=.325")); }
+  static void print_vsense(TMC &st) { SERIAL_ECHO(st.vsense() ? F("1=.18") : F("0=.325")); }
 
   #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC5130)
     static void _tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
@@ -680,7 +680,7 @@
       case TMC_ENABLED: serialprint_truefalse(st.isEnabled()); break;
       case TMC_CURRENT: SERIAL_ECHO(st.getMilliamps()); break;
       case TMC_RMS_CURRENT: SERIAL_ECHO(st.rms_current()); break;
-      case TMC_MAX_CURRENT: SERIAL_PRINT((float)st.rms_current() * 1.41, 0); break;
+      case TMC_MAX_CURRENT: SERIAL_ECHO(p_float_t(st.rms_current() * 1.41, 0)); break;
       case TMC_IRUN:
         SERIAL_ECHO(st.irun());
         SERIAL_ECHOPGM("/31");
@@ -728,12 +728,12 @@
         case TMC_ENABLED: serialprint_truefalse(st.isEnabled()); break;
         case TMC_CURRENT: SERIAL_ECHO(st.getMilliamps()); break;
         case TMC_RMS_CURRENT: SERIAL_ECHO(st.rms_current()); break;
-        case TMC_MAX_CURRENT: SERIAL_PRINT((float)st.rms_current() * 1.41, 0); break;
+        case TMC_MAX_CURRENT: SERIAL_ECHO(p_float_t(st.rms_current() * 1.41, 0)); break;
         case TMC_IRUN:
           SERIAL_ECHO(st.cs());
           SERIAL_ECHOPGM("/31");
           break;
-        case TMC_VSENSE: SERIAL_ECHOF(st.vsense() ? F("1=.165") : F("0=.310")); break;
+        case TMC_VSENSE: SERIAL_ECHO(st.vsense() ? F("1=.165") : F("0=.310")); break;
         case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
         //case TMC_OTPW: serialprint_truefalse(st.otpw()); break;
         //case TMC_OTPW_TRIGGERED: serialprint_truefalse(st.getOTPW()); break;
@@ -1228,7 +1228,7 @@ static bool test_connection(TMC &st) {
     case 1: stat = F("HIGH"); break;
     case 2: stat = F("LOW"); break;
   }
-  SERIAL_ECHOLNF(stat);
+  SERIAL_ECHOLN(stat);
 
   return test_result;
 }

commit 7d5bd4dfbc029c1be10a3de42c0eb6508965a22d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 19 04:48:11 2023 -0500

    üé® Cutter pins cleanup

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index cc99f34c5b..095e14fe15 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -1236,7 +1236,7 @@ static bool test_connection(TMC &st) {
 void test_tmc_connection(LOGICAL_AXIS_ARGS(const bool)) {
   uint8_t axis_connection = 0;
 
-    if (TERN0(HAS_X_AXIS, x)) {
+  if (TERN0(HAS_X_AXIS, x)) {
     #if AXIS_IS_TMC(X)
       axis_connection += test_connection(stepperX);
     #endif

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    üö∏ Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 2e5a5c5585..cc99f34c5b 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -773,8 +773,8 @@
     }
   }
 
-  static void tmc_debug_loop(const TMC_debug_enum n, LOGICAL_AXIS_ARGS(const bool)) {
-    if (x) {
+  static void tmc_debug_loop(const TMC_debug_enum n OPTARGS_LOGICAL(const bool)) {
+    if (TERN0(HAS_X_AXIS, x)) {
       #if AXIS_IS_TMC(X)
         tmc_status(stepperX, n);
       #endif
@@ -856,8 +856,8 @@
     SERIAL_EOL();
   }
 
-  static void drv_status_loop(const TMC_drv_status_enum n, LOGICAL_AXIS_ARGS(const bool)) {
-    if (x) {
+  static void drv_status_loop(const TMC_drv_status_enum n OPTARGS_LOGICAL(const bool)) {
+    if (TERN0(HAS_X_AXIS, x)) {
       #if AXIS_IS_TMC(X)
         tmc_parse_drv_status(stepperX, n);
       #endif
@@ -944,8 +944,8 @@
    */
 
   void tmc_report_all(LOGICAL_AXIS_ARGS(const bool)) {
-    #define TMC_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); tmc_debug_loop(ITEM, LOGICAL_AXIS_ARGS()); }while(0)
-    #define DRV_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); drv_status_loop(ITEM, LOGICAL_AXIS_ARGS()); }while(0)
+    #define TMC_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); tmc_debug_loop(ITEM OPTARGS_LOGICAL()); }while(0)
+    #define DRV_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); drv_status_loop(ITEM OPTARGS_LOGICAL()); }while(0)
 
     TMC_REPORT("\t",                 TMC_CODES);
     #if HAS_DRIVER(TMC2209)
@@ -1070,8 +1070,8 @@
     }
   #endif
 
-  static void tmc_get_registers(TMC_get_registers_enum n, LOGICAL_AXIS_ARGS(const bool)) {
-    if (x) {
+  static void tmc_get_registers(TMC_get_registers_enum n OPTARGS_LOGICAL(const bool)) {
+    if (TERN0(HAS_X_AXIS, x)) {
       #if AXIS_IS_TMC(X)
         tmc_get_registers(stepperX, n);
       #endif
@@ -1154,7 +1154,7 @@
   }
 
   void tmc_get_registers(LOGICAL_AXIS_ARGS(bool)) {
-    #define _TMC_GET_REG(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); tmc_get_registers(ITEM, LOGICAL_AXIS_ARGS()); }while(0)
+    #define _TMC_GET_REG(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); tmc_get_registers(ITEM OPTARGS_LOGICAL()); }while(0)
     #define TMC_GET_REG(NAME, TABS) _TMC_GET_REG(STRINGIFY(NAME) TABS, TMC_GET_##NAME)
     _TMC_GET_REG("\t", TMC_AXIS_CODES);
     TMC_GET_REG(GCONF, "\t\t");
@@ -1236,7 +1236,7 @@ static bool test_connection(TMC &st) {
 void test_tmc_connection(LOGICAL_AXIS_ARGS(const bool)) {
   uint8_t axis_connection = 0;
 
-  if (x) {
+    if (TERN0(HAS_X_AXIS, x)) {
     #if AXIS_IS_TMC(X)
       axis_connection += test_connection(stepperX);
     #endif

commit 6d819eb8d419bad0bea5c9ce33a673eef5ef03eb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 14 18:09:16 2023 -0500

    üßë‚Äçüíª Apply simplified ?:

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 0867686363..2e5a5c5585 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -601,8 +601,8 @@
         case TMC_STEALTHCHOP: serialprint_truefalse(st.en_pwm_mode()); break;
         case TMC_GLOBAL_SCALER:
           {
-            uint16_t value = st.GLOBAL_SCALER();
-            SERIAL_ECHO(value ? value : 256);
+            const uint16_t value = st.GLOBAL_SCALER();
+            SERIAL_ECHO(value ?: 256);
             SERIAL_ECHOPGM("/256");
           }
           break;

commit 21c48d9f927c81d7b7cf6fc3641ce01a831a16ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 27 04:24:50 2022 -0500

    üßë‚Äçüíª  Update planner/stepper includes

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index cb970c7ebc..0867686363 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -33,17 +33,12 @@
 #include "../gcode/gcode.h"
 
 #if ENABLED(TMC_DEBUG)
-  #include "../module/planner.h"
   #include "../libs/hex_print.h"
   #if ENABLED(MONITOR_DRIVER_STATUS)
     static uint16_t report_tmc_status_interval; // = 0
   #endif
 #endif
 
-#if HAS_MARLINUI_MENU
-  #include "../module/stepper.h"
-#endif
-
 /**
  * Check for over temperature or short to ground error flags.
  * Report and log warning of overtemperature condition.

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index c69772bebc..cb970c7ebc 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -429,6 +429,18 @@
         if (monitor_tmc_driver(stepperK, need_update_error_counters, need_debug_reporting))
           step_current_down(stepperK);
       #endif
+      #if AXIS_IS_TMC(U)
+        if (monitor_tmc_driver(stepperU, need_update_error_counters, need_debug_reporting))
+          step_current_down(stepperU);
+      #endif
+      #if AXIS_IS_TMC(V)
+        if (monitor_tmc_driver(stepperV, need_update_error_counters, need_debug_reporting))
+          step_current_down(stepperV);
+      #endif
+      #if AXIS_IS_TMC(W)
+        if (monitor_tmc_driver(stepperW, need_update_error_counters, need_debug_reporting))
+          step_current_down(stepperW);
+      #endif
 
       #if AXIS_IS_TMC(E0)
         (void)monitor_tmc_driver(stepperE0, need_update_error_counters, need_debug_reporting);
@@ -809,6 +821,15 @@
     #if AXIS_IS_TMC(K)
       if (k) tmc_status(stepperK, n);
     #endif
+    #if AXIS_IS_TMC(U)
+      if (u) tmc_status(stepperU, n);
+    #endif
+    #if AXIS_IS_TMC(V)
+      if (v) tmc_status(stepperV, n);
+    #endif
+    #if AXIS_IS_TMC(W)
+      if (w) tmc_status(stepperW, n);
+    #endif
 
     if (TERN0(HAS_EXTRUDERS, e)) {
       #if AXIS_IS_TMC(E0)
@@ -883,6 +904,15 @@
     #if AXIS_IS_TMC(K)
       if (k) tmc_parse_drv_status(stepperK, n);
     #endif
+    #if AXIS_IS_TMC(U)
+      if (u) tmc_parse_drv_status(stepperU, n);
+    #endif
+    #if AXIS_IS_TMC(V)
+      if (v) tmc_parse_drv_status(stepperV, n);
+    #endif
+    #if AXIS_IS_TMC(W)
+      if (w) tmc_parse_drv_status(stepperW, n);
+    #endif
 
     if (TERN0(HAS_EXTRUDERS, e)) {
       #if AXIS_IS_TMC(E0)
@@ -1088,6 +1118,15 @@
     #if AXIS_IS_TMC(K)
       if (k) tmc_get_registers(stepperK, n);
     #endif
+    #if AXIS_IS_TMC(U)
+      if (u) tmc_get_registers(stepperU, n);
+    #endif
+    #if AXIS_IS_TMC(V)
+      if (v) tmc_get_registers(stepperV, n);
+    #endif
+    #if AXIS_IS_TMC(W)
+      if (w) tmc_get_registers(stepperW, n);
+    #endif
 
     if (TERN0(HAS_EXTRUDERS, e)) {
       #if AXIS_IS_TMC(E0)
@@ -1244,6 +1283,15 @@ void test_tmc_connection(LOGICAL_AXIS_ARGS(const bool)) {
   #if AXIS_IS_TMC(K)
     if (k) axis_connection += test_connection(stepperK);
   #endif
+  #if AXIS_IS_TMC(U)
+    if (u) axis_connection += test_connection(stepperU);
+  #endif
+  #if AXIS_IS_TMC(V)
+    if (v) axis_connection += test_connection(stepperV);
+  #endif
+  #if AXIS_IS_TMC(W)
+    if (w) axis_connection += test_connection(stepperW);
+  #endif
 
   if (TERN0(HAS_EXTRUDERS, e)) {
     #if AXIS_IS_TMC(E0)
@@ -1313,6 +1361,15 @@ void test_tmc_connection(LOGICAL_AXIS_ARGS(const bool)) {
     #if AXIS_HAS_SPI(K)
       SET_CS_PIN(K);
     #endif
+    #if AXIS_HAS_SPI(U)
+      SET_CS_PIN(U);
+    #endif
+    #if AXIS_HAS_SPI(V)
+      SET_CS_PIN(V);
+    #endif
+    #if AXIS_HAS_SPI(W)
+      SET_CS_PIN(W);
+    #endif
     #if AXIS_HAS_SPI(E0)
       SET_CS_PIN(E0);
     #endif

commit f03c3677394126e72fb7c2679891a67f1efe0332
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Tue Feb 22 16:16:57 2022 +1300

    üêõ Fix TMC26X CS pins init (#23778)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index cf3fa3b7b0..c69772bebc 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -1178,69 +1178,6 @@
 
 #endif // USE_SENSORLESS
 
-#if HAS_TMC_SPI
-  #define SET_CS_PIN(st) OUT_WRITE(st##_CS_PIN, HIGH)
-  void tmc_init_cs_pins() {
-    #if AXIS_HAS_SPI(X)
-      SET_CS_PIN(X);
-    #endif
-    #if AXIS_HAS_SPI(Y)
-      SET_CS_PIN(Y);
-    #endif
-    #if AXIS_HAS_SPI(Z)
-      SET_CS_PIN(Z);
-    #endif
-    #if AXIS_HAS_SPI(X2)
-      SET_CS_PIN(X2);
-    #endif
-    #if AXIS_HAS_SPI(Y2)
-      SET_CS_PIN(Y2);
-    #endif
-    #if AXIS_HAS_SPI(Z2)
-      SET_CS_PIN(Z2);
-    #endif
-    #if AXIS_HAS_SPI(Z3)
-      SET_CS_PIN(Z3);
-    #endif
-    #if AXIS_HAS_SPI(Z4)
-      SET_CS_PIN(Z4);
-    #endif
-    #if AXIS_HAS_SPI(I)
-      SET_CS_PIN(I);
-    #endif
-    #if AXIS_HAS_SPI(J)
-      SET_CS_PIN(J);
-    #endif
-    #if AXIS_HAS_SPI(K)
-      SET_CS_PIN(K);
-    #endif
-    #if AXIS_HAS_SPI(E0)
-      SET_CS_PIN(E0);
-    #endif
-    #if AXIS_HAS_SPI(E1)
-      SET_CS_PIN(E1);
-    #endif
-    #if AXIS_HAS_SPI(E2)
-      SET_CS_PIN(E2);
-    #endif
-    #if AXIS_HAS_SPI(E3)
-      SET_CS_PIN(E3);
-    #endif
-    #if AXIS_HAS_SPI(E4)
-      SET_CS_PIN(E4);
-    #endif
-    #if AXIS_HAS_SPI(E5)
-      SET_CS_PIN(E5);
-    #endif
-    #if AXIS_HAS_SPI(E6)
-      SET_CS_PIN(E6);
-    #endif
-    #if AXIS_HAS_SPI(E7)
-      SET_CS_PIN(E7);
-    #endif
-  }
-#endif // HAS_TMC_SPI
-
 template<typename TMC>
 static bool test_connection(TMC &st) {
   SERIAL_ECHOPGM("Testing ");
@@ -1339,3 +1276,66 @@ void test_tmc_connection(LOGICAL_AXIS_ARGS(const bool)) {
 }
 
 #endif // HAS_TRINAMIC_CONFIG
+
+#if HAS_TMC_SPI
+  #define SET_CS_PIN(st) OUT_WRITE(st##_CS_PIN, HIGH)
+  void tmc_init_cs_pins() {
+    #if AXIS_HAS_SPI(X)
+      SET_CS_PIN(X);
+    #endif
+    #if AXIS_HAS_SPI(Y)
+      SET_CS_PIN(Y);
+    #endif
+    #if AXIS_HAS_SPI(Z)
+      SET_CS_PIN(Z);
+    #endif
+    #if AXIS_HAS_SPI(X2)
+      SET_CS_PIN(X2);
+    #endif
+    #if AXIS_HAS_SPI(Y2)
+      SET_CS_PIN(Y2);
+    #endif
+    #if AXIS_HAS_SPI(Z2)
+      SET_CS_PIN(Z2);
+    #endif
+    #if AXIS_HAS_SPI(Z3)
+      SET_CS_PIN(Z3);
+    #endif
+    #if AXIS_HAS_SPI(Z4)
+      SET_CS_PIN(Z4);
+    #endif
+    #if AXIS_HAS_SPI(I)
+      SET_CS_PIN(I);
+    #endif
+    #if AXIS_HAS_SPI(J)
+      SET_CS_PIN(J);
+    #endif
+    #if AXIS_HAS_SPI(K)
+      SET_CS_PIN(K);
+    #endif
+    #if AXIS_HAS_SPI(E0)
+      SET_CS_PIN(E0);
+    #endif
+    #if AXIS_HAS_SPI(E1)
+      SET_CS_PIN(E1);
+    #endif
+    #if AXIS_HAS_SPI(E2)
+      SET_CS_PIN(E2);
+    #endif
+    #if AXIS_HAS_SPI(E3)
+      SET_CS_PIN(E3);
+    #endif
+    #if AXIS_HAS_SPI(E4)
+      SET_CS_PIN(E4);
+    #endif
+    #if AXIS_HAS_SPI(E5)
+      SET_CS_PIN(E5);
+    #endif
+    #if AXIS_HAS_SPI(E6)
+      SET_CS_PIN(E6);
+    #endif
+    #if AXIS_HAS_SPI(E7)
+      SET_CS_PIN(E7);
+    #endif
+  }
+#endif // HAS_TMC_SPI

commit ab46b7e2f298826a5512569d6e79bb59a7a6b8ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 25 15:33:03 2022 -0600

    üßë‚Äçüíª HAS_MARLINUI_MENU, HAS_MANUAL_MOVE_MENU

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 934c0b7264..cf3fa3b7b0 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -40,7 +40,7 @@
   #endif
 #endif
 
-#if HAS_LCD_MENU
+#if HAS_MARLINUI_MENU
   #include "../module/stepper.h"
 #endif
 

commit 40481947fc1f11a01235c5c55333a4437fc45c5f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 14 03:14:13 2022 -0600

    üßë‚Äçüíª Misc. updates for extra axes (#23521)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index e793b4cf22..934c0b7264 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -421,12 +421,10 @@
         if (monitor_tmc_driver(stepperI, need_update_error_counters, need_debug_reporting))
           step_current_down(stepperI);
       #endif
-
       #if AXIS_IS_TMC(J)
         if (monitor_tmc_driver(stepperJ, need_update_error_counters, need_debug_reporting))
           step_current_down(stepperJ);
       #endif
-
       #if AXIS_IS_TMC(K)
         if (monitor_tmc_driver(stepperK, need_update_error_counters, need_debug_reporting))
           step_current_down(stepperK);

commit 13ce5aa1ed4ab4f8fc01f7ff6f7ad7884fc28ea9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Dec 21 22:15:48 2021 -0600

    üé® Misc. cleanup

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 82c10e6e8e..e793b4cf22 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -472,12 +472,8 @@
     void tmc_set_report_interval(const uint16_t update_interval) {
       if ((report_tmc_status_interval = update_interval))
         SERIAL_ECHOLNPGM("axis:pwm_scale"
-          #if HAS_STEALTHCHOP
-            "/curr_scale"
-          #endif
-          #if HAS_STALLGUARD
-            "/mech_load"
-          #endif
+          TERN_(HAS_STEALTHCHOP, "/curr_scale")
+          TERN_(HAS_STALLGUARD, "/mech_load")
           "|flags|warncount"
         );
     }

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    üé® Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index c11d2e5f6d..82c10e6e8e 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -212,7 +212,7 @@
       if (data.is_ot) SERIAL_ECHOLNPGM("overtemperature");
       if (data.is_s2g) SERIAL_ECHOLNPGM("coil short circuit");
       TERN_(TMC_DEBUG, tmc_report_all());
-      kill(PSTR("Driver error"));
+      kill(F("Driver error"));
     }
   #endif
 

commit 7f1286a11f87065c4e666985e679cf9c77d668bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 17:05:11 2021 -0500

    üé® Apply F() to status message

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 6848d81003..c11d2e5f6d 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -1341,7 +1341,7 @@ void test_tmc_connection(LOGICAL_AXIS_ARGS(const bool)) {
     #endif
   }
 
-  if (axis_connection) LCD_MESSAGEPGM(MSG_ERROR_TMC);
+  if (axis_connection) LCD_MESSAGE(MSG_ERROR_TMC);
 }
 
 #endif // HAS_TRINAMIC_CONFIG

commit 520b97083e52efdd47ab434b97823e48d85ade62
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 11:03:07 2021 -0500

    üé® Apply F() to serial macros

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 97fedf13c5..6848d81003 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -561,7 +561,7 @@
   };
 
   template<class TMC>
-  static void print_vsense(TMC &st) { SERIAL_ECHOPGM_P(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); }
+  static void print_vsense(TMC &st) { SERIAL_ECHOF(st.vsense() ? F("1=.18") : F("0=.325")); }
 
   #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC5130)
     static void _tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
@@ -732,7 +732,7 @@
           SERIAL_ECHO(st.cs());
           SERIAL_ECHOPGM("/31");
           break;
-        case TMC_VSENSE: SERIAL_ECHOPGM_P(st.vsense() ? PSTR("1=.165") : PSTR("0=.310")); break;
+        case TMC_VSENSE: SERIAL_ECHOF(st.vsense() ? F("1=.165") : F("0=.310")); break;
         case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
         //case TMC_OTPW: serialprint_truefalse(st.otpw()); break;
         //case TMC_OTPW_TRIGGERED: serialprint_truefalse(st.getOTPW()); break;
@@ -1256,15 +1256,14 @@ static bool test_connection(TMC &st) {
 
   if (test_result > 0) SERIAL_ECHOPGM("Error: All ");
 
-  const char *stat;
+  FSTR_P stat;
   switch (test_result) {
     default:
-    case 0: stat = PSTR("OK"); break;
-    case 1: stat = PSTR("HIGH"); break;
-    case 2: stat = PSTR("LOW"); break;
+    case 0: stat = F("OK"); break;
+    case 1: stat = F("HIGH"); break;
+    case 2: stat = F("LOW"); break;
   }
-  SERIAL_ECHOPGM_P(stat);
-  SERIAL_EOL();
+  SERIAL_ECHOLNF(stat);
 
   return test_result;
 }

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 99cfd996c8..97fedf13c5 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -226,7 +226,7 @@
     SERIAL_ECHO(timestamp);
     SERIAL_ECHOPGM(": ");
     st.printLabel();
-    SERIAL_ECHOLNPAIR(" driver overtemperature warning! (", st.getMilliamps(), "mA)");
+    SERIAL_ECHOLNPGM(" driver overtemperature warning! (", st.getMilliamps(), "mA)");
   }
 
   template<typename TMC>
@@ -271,7 +271,7 @@
           st.rms_current(I_rms);
           #if ENABLED(REPORT_CURRENT_CHANGE)
             st.printLabel();
-            SERIAL_ECHOLNPAIR(" current decreased to ", I_rms);
+            SERIAL_ECHOLNPGM(" current decreased to ", I_rms);
           #endif
         }
       }

commit 331cc5fd6a044e568dbe789ecd0b732b6eba454f
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Aug 8 19:25:17 2021 -0700

    üêõ Fix some Simulator on Windows issues (#22516)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 48b26cc101..99cfd996c8 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -208,7 +208,7 @@
   #if ENABLED(STOP_ON_ERROR)
     void report_driver_error(const TMC_driver_data &data) {
       SERIAL_ECHOPGM(" driver error detected: 0x");
-      SERIAL_PRINTLN(data.drv_status, HEX);
+      SERIAL_PRINTLN(data.drv_status, PrintBase::Hex);
       if (data.is_ot) SERIAL_ECHOLNPGM("overtemperature");
       if (data.is_s2g) SERIAL_ECHOLNPGM("coil short circuit");
       TERN_(TMC_DEBUG, tmc_report_all());

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 021317ea89..48b26cc101 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -417,6 +417,21 @@
       }
       #endif
 
+      #if AXIS_IS_TMC(I)
+        if (monitor_tmc_driver(stepperI, need_update_error_counters, need_debug_reporting))
+          step_current_down(stepperI);
+      #endif
+
+      #if AXIS_IS_TMC(J)
+        if (monitor_tmc_driver(stepperJ, need_update_error_counters, need_debug_reporting))
+          step_current_down(stepperJ);
+      #endif
+
+      #if AXIS_IS_TMC(K)
+        if (monitor_tmc_driver(stepperK, need_update_error_counters, need_debug_reporting))
+          step_current_down(stepperK);
+      #endif
+
       #if AXIS_IS_TMC(E0)
         (void)monitor_tmc_driver(stepperE0, need_update_error_counters, need_debug_reporting);
       #endif
@@ -757,138 +772,148 @@
     }
   }
 
-  static void tmc_debug_loop(
-    const TMC_debug_enum i,
-    LOGICAL_AXIS_LIST(const bool print_e, const bool print_x, const bool print_y, const bool print_z)
-  ) {
-    if (print_x) {
+  static void tmc_debug_loop(const TMC_debug_enum n, LOGICAL_AXIS_ARGS(const bool)) {
+    if (x) {
       #if AXIS_IS_TMC(X)
-        tmc_status(stepperX, i);
+        tmc_status(stepperX, n);
       #endif
       #if AXIS_IS_TMC(X2)
-        tmc_status(stepperX2, i);
+        tmc_status(stepperX2, n);
       #endif
     }
 
-    #if LINEAR_AXES >= XY
-      if (print_y) {
-        #if AXIS_IS_TMC(Y)
-          tmc_status(stepperY, i);
-        #endif
-        #if AXIS_IS_TMC(Y2)
-          tmc_status(stepperY2, i);
-        #endif
-      }
-    #endif
+    if (TERN0(HAS_Y_AXIS, y)) {
+      #if AXIS_IS_TMC(Y)
+        tmc_status(stepperY, n);
+      #endif
+      #if AXIS_IS_TMC(Y2)
+        tmc_status(stepperY2, n);
+      #endif
+    }
 
-    if (TERN0(HAS_Z_AXIS, print_z)) {
+    if (TERN0(HAS_Z_AXIS, z)) {
       #if AXIS_IS_TMC(Z)
-        tmc_status(stepperZ, i);
+        tmc_status(stepperZ, n);
       #endif
       #if AXIS_IS_TMC(Z2)
-        tmc_status(stepperZ2, i);
+        tmc_status(stepperZ2, n);
       #endif
       #if AXIS_IS_TMC(Z3)
-        tmc_status(stepperZ3, i);
+        tmc_status(stepperZ3, n);
       #endif
       #if AXIS_IS_TMC(Z4)
-        tmc_status(stepperZ4, i);
+        tmc_status(stepperZ4, n);
       #endif
     }
 
-    if (TERN0(HAS_EXTRUDERS, print_e)) {
+    #if AXIS_IS_TMC(I)
+      if (i) tmc_status(stepperI, n);
+    #endif
+    #if AXIS_IS_TMC(J)
+      if (j) tmc_status(stepperJ, n);
+    #endif
+    #if AXIS_IS_TMC(K)
+      if (k) tmc_status(stepperK, n);
+    #endif
+
+    if (TERN0(HAS_EXTRUDERS, e)) {
       #if AXIS_IS_TMC(E0)
-        tmc_status(stepperE0, i);
+        tmc_status(stepperE0, n);
       #endif
       #if AXIS_IS_TMC(E1)
-        tmc_status(stepperE1, i);
+        tmc_status(stepperE1, n);
       #endif
       #if AXIS_IS_TMC(E2)
-        tmc_status(stepperE2, i);
+        tmc_status(stepperE2, n);
       #endif
       #if AXIS_IS_TMC(E3)
-        tmc_status(stepperE3, i);
+        tmc_status(stepperE3, n);
       #endif
       #if AXIS_IS_TMC(E4)
-        tmc_status(stepperE4, i);
+        tmc_status(stepperE4, n);
       #endif
       #if AXIS_IS_TMC(E5)
-        tmc_status(stepperE5, i);
+        tmc_status(stepperE5, n);
       #endif
       #if AXIS_IS_TMC(E6)
-        tmc_status(stepperE6, i);
+        tmc_status(stepperE6, n);
       #endif
       #if AXIS_IS_TMC(E7)
-        tmc_status(stepperE7, i);
+        tmc_status(stepperE7, n);
       #endif
     }
 
     SERIAL_EOL();
   }
 
-  static void drv_status_loop(
-    const TMC_drv_status_enum i,
-    LOGICAL_AXIS_LIST(const bool print_e, const bool print_x, const bool print_y, const bool print_z)
-  ) {
-    if (print_x) {
+  static void drv_status_loop(const TMC_drv_status_enum n, LOGICAL_AXIS_ARGS(const bool)) {
+    if (x) {
       #if AXIS_IS_TMC(X)
-        tmc_parse_drv_status(stepperX, i);
+        tmc_parse_drv_status(stepperX, n);
       #endif
       #if AXIS_IS_TMC(X2)
-        tmc_parse_drv_status(stepperX2, i);
+        tmc_parse_drv_status(stepperX2, n);
       #endif
     }
 
-    #if LINEAR_AXES >= XY
-      if (print_y) {
-        #if AXIS_IS_TMC(Y)
-          tmc_parse_drv_status(stepperY, i);
-        #endif
-        #if AXIS_IS_TMC(Y2)
-          tmc_parse_drv_status(stepperY2, i);
-        #endif
-      }
-    #endif
+    if (TERN0(HAS_Y_AXIS, y)) {
+      #if AXIS_IS_TMC(Y)
+        tmc_parse_drv_status(stepperY, n);
+      #endif
+      #if AXIS_IS_TMC(Y2)
+        tmc_parse_drv_status(stepperY2, n);
+      #endif
+    }
 
-    if (TERN0(HAS_Z_AXIS, print_z)) {
+    if (TERN0(HAS_Z_AXIS, z)) {
       #if AXIS_IS_TMC(Z)
-        tmc_parse_drv_status(stepperZ, i);
+        tmc_parse_drv_status(stepperZ, n);
       #endif
       #if AXIS_IS_TMC(Z2)
-        tmc_parse_drv_status(stepperZ2, i);
+        tmc_parse_drv_status(stepperZ2, n);
       #endif
       #if AXIS_IS_TMC(Z3)
-        tmc_parse_drv_status(stepperZ3, i);
+        tmc_parse_drv_status(stepperZ3, n);
       #endif
       #if AXIS_IS_TMC(Z4)
-        tmc_parse_drv_status(stepperZ4, i);
+        tmc_parse_drv_status(stepperZ4, n);
       #endif
     }
 
-    if (TERN0(HAS_EXTRUDERS, print_e)) {
+    #if AXIS_IS_TMC(I)
+      if (i) tmc_parse_drv_status(stepperI, n);
+    #endif
+    #if AXIS_IS_TMC(J)
+      if (j) tmc_parse_drv_status(stepperJ, n);
+    #endif
+    #if AXIS_IS_TMC(K)
+      if (k) tmc_parse_drv_status(stepperK, n);
+    #endif
+
+    if (TERN0(HAS_EXTRUDERS, e)) {
       #if AXIS_IS_TMC(E0)
-        tmc_parse_drv_status(stepperE0, i);
+        tmc_parse_drv_status(stepperE0, n);
       #endif
       #if AXIS_IS_TMC(E1)
-        tmc_parse_drv_status(stepperE1, i);
+        tmc_parse_drv_status(stepperE1, n);
       #endif
       #if AXIS_IS_TMC(E2)
-        tmc_parse_drv_status(stepperE2, i);
+        tmc_parse_drv_status(stepperE2, n);
       #endif
       #if AXIS_IS_TMC(E3)
-        tmc_parse_drv_status(stepperE3, i);
+        tmc_parse_drv_status(stepperE3, n);
       #endif
       #if AXIS_IS_TMC(E4)
-        tmc_parse_drv_status(stepperE4, i);
+        tmc_parse_drv_status(stepperE4, n);
       #endif
       #if AXIS_IS_TMC(E5)
-        tmc_parse_drv_status(stepperE5, i);
+        tmc_parse_drv_status(stepperE5, n);
       #endif
       #if AXIS_IS_TMC(E6)
-        tmc_parse_drv_status(stepperE6, i);
+        tmc_parse_drv_status(stepperE6, n);
       #endif
       #if AXIS_IS_TMC(E7)
-        tmc_parse_drv_status(stepperE7, i);
+        tmc_parse_drv_status(stepperE7, n);
       #endif
     }
 
@@ -899,11 +924,9 @@
    * M122 report functions
    */
 
-  void tmc_report_all(
-    LOGICAL_AXIS_LIST(const bool print_e/*=true*/, const bool print_x/*=true*/, const bool print_y/*=true*/, const bool print_z/*=true*/)
-  ) {
-    #define TMC_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL);  tmc_debug_loop(ITEM, LOGICAL_AXIS_LIST(print_e, print_x, print_y, print_z)); }while(0)
-    #define DRV_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); drv_status_loop(ITEM, LOGICAL_AXIS_LIST(print_e, print_x, print_y, print_z)); }while(0)
+  void tmc_report_all(LOGICAL_AXIS_ARGS(const bool)) {
+    #define TMC_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); tmc_debug_loop(ITEM, LOGICAL_AXIS_ARGS()); }while(0)
+    #define DRV_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); drv_status_loop(ITEM, LOGICAL_AXIS_ARGS()); }while(0)
 
     TMC_REPORT("\t",                 TMC_CODES);
     #if HAS_DRIVER(TMC2209)
@@ -1028,79 +1051,82 @@
     }
   #endif
 
-  static void tmc_get_registers(
-    TMC_get_registers_enum i,
-    LOGICAL_AXIS_LIST(const bool print_e, const bool print_x, const bool print_y, const bool print_z)
-  ) {
-    if (print_x) {
+  static void tmc_get_registers(TMC_get_registers_enum n, LOGICAL_AXIS_ARGS(const bool)) {
+    if (x) {
       #if AXIS_IS_TMC(X)
-        tmc_get_registers(stepperX, i);
+        tmc_get_registers(stepperX, n);
       #endif
       #if AXIS_IS_TMC(X2)
-        tmc_get_registers(stepperX2, i);
+        tmc_get_registers(stepperX2, n);
       #endif
     }
 
-    #if LINEAR_AXES >= XY
-      if (print_y) {
-        #if AXIS_IS_TMC(Y)
-          tmc_get_registers(stepperY, i);
-        #endif
-        #if AXIS_IS_TMC(Y2)
-          tmc_get_registers(stepperY2, i);
-        #endif
-      }
-    #endif
+    if (TERN0(HAS_Y_AXIS, y)) {
+      #if AXIS_IS_TMC(Y)
+        tmc_get_registers(stepperY, n);
+      #endif
+      #if AXIS_IS_TMC(Y2)
+        tmc_get_registers(stepperY2, n);
+      #endif
+    }
 
-    if (TERN0(HAS_Z_AXIS, print_z)) {
+    if (TERN0(HAS_Z_AXIS, z)) {
       #if AXIS_IS_TMC(Z)
-        tmc_get_registers(stepperZ, i);
+        tmc_get_registers(stepperZ, n);
       #endif
       #if AXIS_IS_TMC(Z2)
-        tmc_get_registers(stepperZ2, i);
+        tmc_get_registers(stepperZ2, n);
       #endif
       #if AXIS_IS_TMC(Z3)
-        tmc_get_registers(stepperZ3, i);
+        tmc_get_registers(stepperZ3, n);
       #endif
       #if AXIS_IS_TMC(Z4)
-        tmc_get_registers(stepperZ4, i);
+        tmc_get_registers(stepperZ4, n);
       #endif
     }
 
-    if (TERN0(HAS_EXTRUDERS, print_e)) {
+    #if AXIS_IS_TMC(I)
+      if (i) tmc_get_registers(stepperI, n);
+    #endif
+    #if AXIS_IS_TMC(J)
+      if (j) tmc_get_registers(stepperJ, n);
+    #endif
+    #if AXIS_IS_TMC(K)
+      if (k) tmc_get_registers(stepperK, n);
+    #endif
+
+    if (TERN0(HAS_EXTRUDERS, e)) {
       #if AXIS_IS_TMC(E0)
-        tmc_get_registers(stepperE0, i);
+        tmc_get_registers(stepperE0, n);
       #endif
       #if AXIS_IS_TMC(E1)
-        tmc_get_registers(stepperE1, i);
+        tmc_get_registers(stepperE1, n);
       #endif
       #if AXIS_IS_TMC(E2)
-        tmc_get_registers(stepperE2, i);
+        tmc_get_registers(stepperE2, n);
       #endif
       #if AXIS_IS_TMC(E3)
-        tmc_get_registers(stepperE3, i);
+        tmc_get_registers(stepperE3, n);
       #endif
       #if AXIS_IS_TMC(E4)
-        tmc_get_registers(stepperE4, i);
+        tmc_get_registers(stepperE4, n);
       #endif
       #if AXIS_IS_TMC(E5)
-        tmc_get_registers(stepperE5, i);
+        tmc_get_registers(stepperE5, n);
       #endif
       #if AXIS_IS_TMC(E6)
-        tmc_get_registers(stepperE6, i);
+        tmc_get_registers(stepperE6, n);
       #endif
       #if AXIS_IS_TMC(E7)
-        tmc_get_registers(stepperE7, i);
+        tmc_get_registers(stepperE7, n);
       #endif
     }
 
     SERIAL_EOL();
   }
 
-  void tmc_get_registers(
-    LOGICAL_AXIS_LIST(bool print_e, bool print_x, bool print_y, bool print_z)
-  ) {
-    #define _TMC_GET_REG(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); tmc_get_registers(ITEM, LOGICAL_AXIS_LIST(print_e, print_x, print_y, print_z)); }while(0)
+  void tmc_get_registers(LOGICAL_AXIS_ARGS(bool)) {
+    #define _TMC_GET_REG(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); tmc_get_registers(ITEM, LOGICAL_AXIS_ARGS()); }while(0)
     #define TMC_GET_REG(NAME, TABS) _TMC_GET_REG(STRINGIFY(NAME) TABS, TMC_GET_##NAME)
     _TMC_GET_REG("\t", TMC_AXIS_CODES);
     TMC_GET_REG(GCONF, "\t\t");
@@ -1185,6 +1211,15 @@
     #if AXIS_HAS_SPI(Z4)
       SET_CS_PIN(Z4);
     #endif
+    #if AXIS_HAS_SPI(I)
+      SET_CS_PIN(I);
+    #endif
+    #if AXIS_HAS_SPI(J)
+      SET_CS_PIN(J);
+    #endif
+    #if AXIS_HAS_SPI(K)
+      SET_CS_PIN(K);
+    #endif
     #if AXIS_HAS_SPI(E0)
       SET_CS_PIN(E0);
     #endif
@@ -1234,12 +1269,10 @@ static bool test_connection(TMC &st) {
   return test_result;
 }
 
-void test_tmc_connection(
-  LOGICAL_AXIS_LIST(const bool test_e/*=true*/, const bool test_x/*=true*/, const bool test_y/*=true*/, const bool test_z/*=true*/)
-) {
+void test_tmc_connection(LOGICAL_AXIS_ARGS(const bool)) {
   uint8_t axis_connection = 0;
 
-  if (test_x) {
+  if (x) {
     #if AXIS_IS_TMC(X)
       axis_connection += test_connection(stepperX);
     #endif
@@ -1248,18 +1281,16 @@ void test_tmc_connection(
     #endif
   }
 
-  #if LINEAR_AXES >= XY
-    if (test_y) {
-      #if AXIS_IS_TMC(Y)
-        axis_connection += test_connection(stepperY);
-      #endif
-      #if AXIS_IS_TMC(Y2)
-        axis_connection += test_connection(stepperY2);
-      #endif
-    }
-  #endif
+  if (TERN0(HAS_Y_AXIS, y)) {
+    #if AXIS_IS_TMC(Y)
+      axis_connection += test_connection(stepperY);
+    #endif
+    #if AXIS_IS_TMC(Y2)
+      axis_connection += test_connection(stepperY2);
+    #endif
+  }
 
-  if (TERN0(HAS_Z_AXIS, test_z)) {
+  if (TERN0(HAS_Z_AXIS, z)) {
     #if AXIS_IS_TMC(Z)
       axis_connection += test_connection(stepperZ);
     #endif
@@ -1274,7 +1305,17 @@ void test_tmc_connection(
     #endif
   }
 
-  if (TERN0(HAS_EXTRUDERS, test_e)) {
+  #if AXIS_IS_TMC(I)
+    if (i) axis_connection += test_connection(stepperI);
+  #endif
+  #if AXIS_IS_TMC(J)
+    if (j) axis_connection += test_connection(stepperJ);
+  #endif
+  #if AXIS_IS_TMC(K)
+    if (k) axis_connection += test_connection(stepperK);
+  #endif
+
+  if (TERN0(HAS_EXTRUDERS, e)) {
     #if AXIS_IS_TMC(E0)
       axis_connection += test_connection(stepperE0);
     #endif

commit 82ea06e6a4ffdb0816ab92a5dd721ec5d770015d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 1 20:23:37 2021 -0500

    ‚ôªÔ∏è Patches for Zero Extruders (with TMC)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index e244a33eee..021317ea89 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -770,16 +770,18 @@
       #endif
     }
 
-    if (print_y) {
-      #if AXIS_IS_TMC(Y)
-        tmc_status(stepperY, i);
-      #endif
-      #if AXIS_IS_TMC(Y2)
-        tmc_status(stepperY2, i);
-      #endif
-    }
+    #if LINEAR_AXES >= XY
+      if (print_y) {
+        #if AXIS_IS_TMC(Y)
+          tmc_status(stepperY, i);
+        #endif
+        #if AXIS_IS_TMC(Y2)
+          tmc_status(stepperY2, i);
+        #endif
+      }
+    #endif
 
-    if (print_z) {
+    if (TERN0(HAS_Z_AXIS, print_z)) {
       #if AXIS_IS_TMC(Z)
         tmc_status(stepperZ, i);
       #endif
@@ -794,7 +796,7 @@
       #endif
     }
 
-    if (print_e) {
+    if (TERN0(HAS_EXTRUDERS, print_e)) {
       #if AXIS_IS_TMC(E0)
         tmc_status(stepperE0, i);
       #endif
@@ -837,16 +839,18 @@
       #endif
     }
 
-    if (print_y) {
-      #if AXIS_IS_TMC(Y)
-        tmc_parse_drv_status(stepperY, i);
-      #endif
-      #if AXIS_IS_TMC(Y2)
-        tmc_parse_drv_status(stepperY2, i);
-      #endif
-    }
+    #if LINEAR_AXES >= XY
+      if (print_y) {
+        #if AXIS_IS_TMC(Y)
+          tmc_parse_drv_status(stepperY, i);
+        #endif
+        #if AXIS_IS_TMC(Y2)
+          tmc_parse_drv_status(stepperY2, i);
+        #endif
+      }
+    #endif
 
-    if (print_z) {
+    if (TERN0(HAS_Z_AXIS, print_z)) {
       #if AXIS_IS_TMC(Z)
         tmc_parse_drv_status(stepperZ, i);
       #endif
@@ -861,7 +865,7 @@
       #endif
     }
 
-    if (print_e) {
+    if (TERN0(HAS_EXTRUDERS, print_e)) {
       #if AXIS_IS_TMC(E0)
         tmc_parse_drv_status(stepperE0, i);
       #endif
@@ -1037,16 +1041,18 @@
       #endif
     }
 
-    if (print_y) {
-      #if AXIS_IS_TMC(Y)
-        tmc_get_registers(stepperY, i);
-      #endif
-      #if AXIS_IS_TMC(Y2)
-        tmc_get_registers(stepperY2, i);
-      #endif
-    }
+    #if LINEAR_AXES >= XY
+      if (print_y) {
+        #if AXIS_IS_TMC(Y)
+          tmc_get_registers(stepperY, i);
+        #endif
+        #if AXIS_IS_TMC(Y2)
+          tmc_get_registers(stepperY2, i);
+        #endif
+      }
+    #endif
 
-    if (print_z) {
+    if (TERN0(HAS_Z_AXIS, print_z)) {
       #if AXIS_IS_TMC(Z)
         tmc_get_registers(stepperZ, i);
       #endif
@@ -1061,7 +1067,7 @@
       #endif
     }
 
-    if (print_e) {
+    if (TERN0(HAS_EXTRUDERS, print_e)) {
       #if AXIS_IS_TMC(E0)
         tmc_get_registers(stepperE0, i);
       #endif
@@ -1242,16 +1248,18 @@ void test_tmc_connection(
     #endif
   }
 
-  if (test_y) {
-    #if AXIS_IS_TMC(Y)
-      axis_connection += test_connection(stepperY);
-    #endif
-    #if AXIS_IS_TMC(Y2)
-      axis_connection += test_connection(stepperY2);
-    #endif
-  }
+  #if LINEAR_AXES >= XY
+    if (test_y) {
+      #if AXIS_IS_TMC(Y)
+        axis_connection += test_connection(stepperY);
+      #endif
+      #if AXIS_IS_TMC(Y2)
+        axis_connection += test_connection(stepperY2);
+      #endif
+    }
+  #endif
 
-  if (test_z) {
+  if (TERN0(HAS_Z_AXIS, test_z)) {
     #if AXIS_IS_TMC(Z)
       axis_connection += test_connection(stepperZ);
     #endif
@@ -1266,7 +1274,7 @@ void test_tmc_connection(
     #endif
   }
 
-  if (test_e) {
+  if (TERN0(HAS_EXTRUDERS, test_e)) {
     #if AXIS_IS_TMC(E0)
       axis_connection += test_connection(stepperE0);
     #endif

commit dd4990252e891cdfe56cb7d6e3bbe1e6289be649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 24 16:38:57 2021 -0500

    ‚ôªÔ∏è Refactor Linear / Logical / Distinct Axes (#21953)
    
    * More patches supporting EXTRUDERS 0
    * Extend types in prep for more axes

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 9c4fbf08df..e244a33eee 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -757,7 +757,10 @@
     }
   }
 
-  static void tmc_debug_loop(const TMC_debug_enum i, const bool print_x, const bool print_y, const bool print_z, const bool print_e) {
+  static void tmc_debug_loop(
+    const TMC_debug_enum i,
+    LOGICAL_AXIS_LIST(const bool print_e, const bool print_x, const bool print_y, const bool print_z)
+  ) {
     if (print_x) {
       #if AXIS_IS_TMC(X)
         tmc_status(stepperX, i);
@@ -821,7 +824,10 @@
     SERIAL_EOL();
   }
 
-  static void drv_status_loop(const TMC_drv_status_enum i, const bool print_x, const bool print_y, const bool print_z, const bool print_e) {
+  static void drv_status_loop(
+    const TMC_drv_status_enum i,
+    LOGICAL_AXIS_LIST(const bool print_e, const bool print_x, const bool print_y, const bool print_z)
+  ) {
     if (print_x) {
       #if AXIS_IS_TMC(X)
         tmc_parse_drv_status(stepperX, i);
@@ -889,9 +895,12 @@
    * M122 report functions
    */
 
-  void tmc_report_all(const bool print_x/*=true*/, const bool print_y/*=true*/, const bool print_z/*=true*/, const bool print_e/*=true*/) {
-    #define TMC_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL);  tmc_debug_loop(ITEM, print_x, print_y, print_z, print_e); }while(0)
-    #define DRV_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); drv_status_loop(ITEM, print_x, print_y, print_z, print_e); }while(0)
+  void tmc_report_all(
+    LOGICAL_AXIS_LIST(const bool print_e/*=true*/, const bool print_x/*=true*/, const bool print_y/*=true*/, const bool print_z/*=true*/)
+  ) {
+    #define TMC_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL);  tmc_debug_loop(ITEM, LOGICAL_AXIS_LIST(print_e, print_x, print_y, print_z)); }while(0)
+    #define DRV_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); drv_status_loop(ITEM, LOGICAL_AXIS_LIST(print_e, print_x, print_y, print_z)); }while(0)
+
     TMC_REPORT("\t",                 TMC_CODES);
     #if HAS_DRIVER(TMC2209)
       TMC_REPORT("Address\t",        TMC_UART_ADDR);
@@ -1015,7 +1024,10 @@
     }
   #endif
 
-  static void tmc_get_registers(TMC_get_registers_enum i, const bool print_x, const bool print_y, const bool print_z, const bool print_e) {
+  static void tmc_get_registers(
+    TMC_get_registers_enum i,
+    LOGICAL_AXIS_LIST(const bool print_e, const bool print_x, const bool print_y, const bool print_z)
+  ) {
     if (print_x) {
       #if AXIS_IS_TMC(X)
         tmc_get_registers(stepperX, i);
@@ -1079,8 +1091,10 @@
     SERIAL_EOL();
   }
 
-  void tmc_get_registers(bool print_x, bool print_y, bool print_z, bool print_e) {
-    #define _TMC_GET_REG(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); tmc_get_registers(ITEM, print_x, print_y, print_z, print_e); }while(0)
+  void tmc_get_registers(
+    LOGICAL_AXIS_LIST(bool print_e, bool print_x, bool print_y, bool print_z)
+  ) {
+    #define _TMC_GET_REG(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); tmc_get_registers(ITEM, LOGICAL_AXIS_LIST(print_e, print_x, print_y, print_z)); }while(0)
     #define TMC_GET_REG(NAME, TABS) _TMC_GET_REG(STRINGIFY(NAME) TABS, TMC_GET_##NAME)
     _TMC_GET_REG("\t", TMC_AXIS_CODES);
     TMC_GET_REG(GCONF, "\t\t");
@@ -1214,7 +1228,9 @@ static bool test_connection(TMC &st) {
   return test_result;
 }
 
-void test_tmc_connection(const bool test_x/*=true*/, const bool test_y/*=true*/, const bool test_z/*=true*/, const bool test_e/*=true*/) {
+void test_tmc_connection(
+  LOGICAL_AXIS_LIST(const bool test_e/*=true*/, const bool test_x/*=true*/, const bool test_y/*=true*/, const bool test_z/*=true*/)
+) {
   uint8_t axis_connection = 0;
 
   if (test_x) {

commit 926a7f27c66e777b5a838a87ee8931d35095fd03
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:52:10 2021 -0500

    ‚ôªÔ∏è Simplify TMC utilities for more axes

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index a4f71414a6..9c4fbf08df 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -211,7 +211,7 @@
       SERIAL_PRINTLN(data.drv_status, HEX);
       if (data.is_ot) SERIAL_ECHOLNPGM("overtemperature");
       if (data.is_s2g) SERIAL_ECHOLNPGM("coil short circuit");
-      TERN_(TMC_DEBUG, tmc_report_all(true, true, true, true));
+      TERN_(TMC_DEBUG, tmc_report_all());
       kill(PSTR("Driver error"));
     }
   #endif
@@ -889,7 +889,7 @@
    * M122 report functions
    */
 
-  void tmc_report_all(bool print_x, const bool print_y, const bool print_z, const bool print_e) {
+  void tmc_report_all(const bool print_x/*=true*/, const bool print_y/*=true*/, const bool print_z/*=true*/, const bool print_e/*=true*/) {
     #define TMC_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL);  tmc_debug_loop(ITEM, print_x, print_y, print_z, print_e); }while(0)
     #define DRV_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); drv_status_loop(ITEM, print_x, print_y, print_z, print_e); }while(0)
     TMC_REPORT("\t",                 TMC_CODES);
@@ -1214,7 +1214,7 @@ static bool test_connection(TMC &st) {
   return test_result;
 }
 
-void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z, const bool test_e) {
+void test_tmc_connection(const bool test_x/*=true*/, const bool test_y/*=true*/, const bool test_z/*=true*/, const bool test_e/*=true*/) {
   uint8_t axis_connection = 0;
 
   if (test_x) {

commit dd42831cba7334c5d106ba435bdb41b6135971bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 28 19:43:46 2021 -0600

    Serial macros cleanup

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index a16af31e55..a4f71414a6 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -546,7 +546,7 @@
   };
 
   template<class TMC>
-  static void print_vsense(TMC &st) { serialprintPGM(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); }
+  static void print_vsense(TMC &st) { SERIAL_ECHOPGM_P(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); }
 
   #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC5130)
     static void _tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
@@ -717,7 +717,7 @@
           SERIAL_ECHO(st.cs());
           SERIAL_ECHOPGM("/31");
           break;
-        case TMC_VSENSE: serialprintPGM(st.vsense() ? PSTR("1=.165") : PSTR("0=.310")); break;
+        case TMC_VSENSE: SERIAL_ECHOPGM_P(st.vsense() ? PSTR("1=.165") : PSTR("0=.310")); break;
         case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
         //case TMC_OTPW: serialprint_truefalse(st.otpw()); break;
         //case TMC_OTPW_TRIGGERED: serialprint_truefalse(st.getOTPW()); break;
@@ -1208,7 +1208,7 @@ static bool test_connection(TMC &st) {
     case 1: stat = PSTR("HIGH"); break;
     case 2: stat = PSTR("LOW"); break;
   }
-  serialprintPGM(stat);
+  SERIAL_ECHOPGM_P(stat);
   SERIAL_EOL();
 
   return test_result;

commit 604afd52d11f45c21194ff5679c829b57e5387e6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 4 19:18:31 2021 -0600

    Fix some serial char, echo
    
    Co-Authored-By: X-Ryl669 <3277165+X-Ryl669@users.noreply.github.com>

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 8d0156883b..a16af31e55 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -233,10 +233,10 @@
   void report_polled_driver_data(TMC &st, const TMC_driver_data &data) {
     const uint32_t pwm_scale = get_pwm_scale(st);
     st.printLabel();
-    SERIAL_CHAR(':'); SERIAL_PRINT(pwm_scale, DEC);
+    SERIAL_CHAR(':'); SERIAL_ECHO(pwm_scale);
     #if ENABLED(TMC_DEBUG)
       #if HAS_TMCX1X0 || HAS_TMC220x
-        SERIAL_CHAR('/'); SERIAL_PRINT(data.cs_actual, DEC);
+        SERIAL_CHAR('/'); SERIAL_ECHO(data.cs_actual);
       #endif
       #if HAS_STALLGUARD
         SERIAL_CHAR('/');
@@ -257,7 +257,7 @@
     #endif
     if (st.flag_otpw)         SERIAL_CHAR('F'); // otpw Flag
     SERIAL_CHAR('|');
-    if (st.otpw_count > 0) SERIAL_PRINT(st.otpw_count, DEC);
+    if (st.otpw_count > 0) SERIAL_ECHO(st.otpw_count);
     SERIAL_CHAR('\t');
   }
 
@@ -551,8 +551,8 @@
   #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC5130)
     static void _tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
       switch (i) {
-        case TMC_PWM_SCALE: SERIAL_PRINT(st.PWM_SCALE(), DEC); break;
-        case TMC_SGT: SERIAL_PRINT(st.sgt(), DEC); break;
+        case TMC_PWM_SCALE: SERIAL_ECHO(st.PWM_SCALE()); break;
+        case TMC_SGT: SERIAL_ECHO(st.sgt()); break;
         case TMC_STEALTHCHOP: serialprint_truefalse(st.en_pwm_mode()); break;
         case TMC_INTERPOLATE: serialprint_truefalse(st.intpol()); break;
         default: break;
@@ -563,9 +563,9 @@
     static void _tmc_parse_drv_status(TMC2130Stepper &st, const TMC_drv_status_enum i) {
       switch (i) {
         case TMC_STALLGUARD: if (st.stallguard()) SERIAL_CHAR('*'); break;
-        case TMC_SG_RESULT:  SERIAL_PRINT(st.sg_result(), DEC); break;
+        case TMC_SG_RESULT:  SERIAL_ECHO(st.sg_result()); break;
         case TMC_FSACTIVE:   if (st.fsactive())   SERIAL_CHAR('*'); break;
-        case TMC_DRV_CS_ACTUAL: SERIAL_PRINT(st.cs_actual(), DEC); break;
+        case TMC_DRV_CS_ACTUAL: SERIAL_ECHO(st.cs_actual()); break;
         default: break;
       }
     }
@@ -580,13 +580,13 @@
 
     static void _tmc_status(TMC2160Stepper &st, const TMC_debug_enum i) {
       switch (i) {
-        case TMC_PWM_SCALE: SERIAL_PRINT(st.PWM_SCALE(), DEC); break;
-        case TMC_SGT: SERIAL_PRINT(st.sgt(), DEC); break;
+        case TMC_PWM_SCALE: SERIAL_ECHO(st.PWM_SCALE()); break;
+        case TMC_SGT: SERIAL_ECHO(st.sgt()); break;
         case TMC_STEALTHCHOP: serialprint_truefalse(st.en_pwm_mode()); break;
         case TMC_GLOBAL_SCALER:
           {
             uint16_t value = st.GLOBAL_SCALER();
-            SERIAL_PRINT(value ?: 256, DEC);
+            SERIAL_ECHO(value ? value : 256);
             SERIAL_ECHOPGM("/256");
           }
           break;
@@ -599,10 +599,10 @@
   #if HAS_TMC220x
     static void _tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
       switch (i) {
-        case TMC_PWM_SCALE_SUM: SERIAL_PRINT(st.pwm_scale_sum(), DEC); break;
-        case TMC_PWM_SCALE_AUTO: SERIAL_PRINT(st.pwm_scale_auto(), DEC); break;
-        case TMC_PWM_OFS_AUTO: SERIAL_PRINT(st.pwm_ofs_auto(), DEC); break;
-        case TMC_PWM_GRAD_AUTO: SERIAL_PRINT(st.pwm_grad_auto(), DEC); break;
+        case TMC_PWM_SCALE_SUM: SERIAL_ECHO(st.pwm_scale_sum()); break;
+        case TMC_PWM_SCALE_AUTO: SERIAL_ECHO(st.pwm_scale_auto()); break;
+        case TMC_PWM_OFS_AUTO: SERIAL_ECHO(st.pwm_ofs_auto()); break;
+        case TMC_PWM_GRAD_AUTO: SERIAL_ECHO(st.pwm_grad_auto()); break;
         case TMC_STEALTHCHOP: serialprint_truefalse(st.stealth()); break;
         case TMC_INTERPOLATE: serialprint_truefalse(st.intpol()); break;
         default: break;
@@ -613,8 +613,8 @@
       template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
       static void _tmc_status(TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const TMC_debug_enum i) {
         switch (i) {
-          case TMC_SGT:       SERIAL_PRINT(st.SGTHRS(), DEC); break;
-          case TMC_UART_ADDR: SERIAL_PRINT(st.get_address(), DEC); break;
+          case TMC_SGT:       SERIAL_ECHO(st.SGTHRS()); break;
+          case TMC_UART_ADDR: SERIAL_ECHO(st.get_address()); break;
           default:
             TMC2208Stepper *parent = &st;
             _tmc_status(*parent, i);
@@ -631,7 +631,7 @@
         case TMC_T120: if (st.t120()) SERIAL_CHAR('*'); break;
         case TMC_S2VSA: if (st.s2vsa()) SERIAL_CHAR('*'); break;
         case TMC_S2VSB: if (st.s2vsb()) SERIAL_CHAR('*'); break;
-        case TMC_DRV_CS_ACTUAL: SERIAL_PRINT(st.cs_actual(), DEC); break;
+        case TMC_DRV_CS_ACTUAL: SERIAL_ECHO(st.cs_actual()); break;
         default: break;
       }
     }
@@ -639,7 +639,7 @@
     #if HAS_DRIVER(TMC2209)
       static void _tmc_parse_drv_status(TMC2209Stepper &st, const TMC_drv_status_enum i) {
         switch (i) {
-          case TMC_SG_RESULT: SERIAL_PRINT(st.SG_RESULT(), DEC); break;
+          case TMC_SG_RESULT: SERIAL_ECHO(st.SG_RESULT()); break;
           default:            _tmc_parse_drv_status(static_cast<TMC2208Stepper &>(st), i); break;
         }
       }
@@ -666,15 +666,15 @@
       case TMC_RMS_CURRENT: SERIAL_ECHO(st.rms_current()); break;
       case TMC_MAX_CURRENT: SERIAL_PRINT((float)st.rms_current() * 1.41, 0); break;
       case TMC_IRUN:
-        SERIAL_PRINT(st.irun(), DEC);
+        SERIAL_ECHO(st.irun());
         SERIAL_ECHOPGM("/31");
         break;
       case TMC_IHOLD:
-        SERIAL_PRINT(st.ihold(), DEC);
+        SERIAL_ECHO(st.ihold());
         SERIAL_ECHOPGM("/31");
         break;
       case TMC_CS_ACTUAL:
-        SERIAL_PRINT(st.cs_actual(), DEC);
+        SERIAL_ECHO(st.cs_actual());
         SERIAL_ECHOPGM("/31");
         break;
       case TMC_VSENSE: print_vsense(st); break;
@@ -694,11 +694,11 @@
       #if ENABLED(MONITOR_DRIVER_STATUS)
         case TMC_OTPW_TRIGGERED: serialprint_truefalse(st.getOTPW()); break;
       #endif
-      case TMC_TOFF: SERIAL_PRINT(st.toff(), DEC); break;
-      case TMC_TBL: SERIAL_PRINT(st.blank_time(), DEC); break;
-      case TMC_HEND: SERIAL_PRINT(st.hysteresis_end(), DEC); break;
-      case TMC_HSTRT: SERIAL_PRINT(st.hysteresis_start(), DEC); break;
-      case TMC_MSCNT: SERIAL_PRINT(st.get_microstep_counter(), DEC); break;
+      case TMC_TOFF: SERIAL_ECHO(st.toff()); break;
+      case TMC_TBL: SERIAL_ECHO(st.blank_time()); break;
+      case TMC_HEND: SERIAL_ECHO(st.hysteresis_end()); break;
+      case TMC_HSTRT: SERIAL_ECHO(st.hysteresis_start()); break;
+      case TMC_MSCNT: SERIAL_ECHO(st.get_microstep_counter()); break;
       default: _tmc_status(st, i); break;
     }
   }
@@ -714,18 +714,18 @@
         case TMC_RMS_CURRENT: SERIAL_ECHO(st.rms_current()); break;
         case TMC_MAX_CURRENT: SERIAL_PRINT((float)st.rms_current() * 1.41, 0); break;
         case TMC_IRUN:
-          SERIAL_PRINT(st.cs(), DEC);
+          SERIAL_ECHO(st.cs());
           SERIAL_ECHOPGM("/31");
           break;
         case TMC_VSENSE: serialprintPGM(st.vsense() ? PSTR("1=.165") : PSTR("0=.310")); break;
         case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
         //case TMC_OTPW: serialprint_truefalse(st.otpw()); break;
         //case TMC_OTPW_TRIGGERED: serialprint_truefalse(st.getOTPW()); break;
-        case TMC_SGT: SERIAL_PRINT(st.sgt(), DEC); break;
-        case TMC_TOFF: SERIAL_PRINT(st.toff(), DEC); break;
-        case TMC_TBL: SERIAL_PRINT(st.blank_time(), DEC); break;
-        case TMC_HEND: SERIAL_PRINT(st.hysteresis_end(), DEC); break;
-        case TMC_HSTRT: SERIAL_PRINT(st.hysteresis_start(), DEC); break;
+        case TMC_SGT: SERIAL_ECHO(st.sgt()); break;
+        case TMC_TOFF: SERIAL_ECHO(st.toff()); break;
+        case TMC_TBL: SERIAL_ECHO(st.blank_time()); break;
+        case TMC_HEND: SERIAL_ECHO(st.hysteresis_end()); break;
+        case TMC_HSTRT: SERIAL_ECHO(st.hysteresis_start()); break;
         default: break;
       }
     }

commit a275e4e5b8a5a36d15b3c6a5edc588a34da6a1f4
Author: devin122 <devin122@gmail.com>
Date:   Tue Jan 19 21:57:12 2021 -0500

    Fix reporting of TMC_S2VSA/B (#20730)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 29bb249cea..8d0156883b 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -604,8 +604,6 @@
         case TMC_PWM_OFS_AUTO: SERIAL_PRINT(st.pwm_ofs_auto(), DEC); break;
         case TMC_PWM_GRAD_AUTO: SERIAL_PRINT(st.pwm_grad_auto(), DEC); break;
         case TMC_STEALTHCHOP: serialprint_truefalse(st.stealth()); break;
-        case TMC_S2VSA: if (st.s2vsa()) SERIAL_CHAR('*'); break;
-        case TMC_S2VSB: if (st.s2vsb()) SERIAL_CHAR('*'); break;
         case TMC_INTERPOLATE: serialprint_truefalse(st.intpol()); break;
         default: break;
       }
@@ -631,6 +629,8 @@
         case TMC_T150: if (st.t150()) SERIAL_CHAR('*'); break;
         case TMC_T143: if (st.t143()) SERIAL_CHAR('*'); break;
         case TMC_T120: if (st.t120()) SERIAL_CHAR('*'); break;
+        case TMC_S2VSA: if (st.s2vsa()) SERIAL_CHAR('*'); break;
+        case TMC_S2VSB: if (st.s2vsb()) SERIAL_CHAR('*'); break;
         case TMC_DRV_CS_ACTUAL: SERIAL_PRINT(st.cs_actual(), DEC); break;
         default: break;
       }

commit 8ff87c120ad20892b9037276a2fff3f790654761
Author: devin122 <devin122@gmail.com>
Date:   Mon Jan 11 02:46:17 2021 -0500

    Fix TMC220x short circuit (#20731)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index d27177326b..29bb249cea 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -147,7 +147,7 @@
 
     static TMC_driver_data get_driver_data(TMC2208Stepper &st) {
       constexpr uint8_t OTPW_bp = 0, OT_bp = 1;
-      constexpr uint8_t S2G_bm = 0b11110; // 2..5
+      constexpr uint8_t S2G_bm = 0b111100; // 2..5
       TMC_driver_data data;
       const auto ds = data.drv_status = st.DRV_STATUS();
       data.is_otpw = TEST(ds, OTPW_bp);
@@ -291,7 +291,7 @@
     bool should_step_down = false;
 
     if (need_update_error_counters) {
-      if (data.is_ot /* | data.s2ga | data.s2gb*/) st.error_count++;
+      if (data.is_ot | data.is_s2g) st.error_count++;
       else if (st.error_count > 0) st.error_count--;
 
       #if ENABLED(STOP_ON_ERROR)

commit 4fccb92e072463bd6147b2ce22352b79337cb53c
Author: ManuelMcLure <manuel@mclure.org>
Date:   Thu Oct 22 04:27:33 2020 -0700

    Configure TMC interpolation per driver (#19828)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 781253079e..d27177326b 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -497,7 +497,8 @@
     TMC_HEND,
     TMC_HSTRT,
     TMC_SGT,
-    TMC_MSCNT
+    TMC_MSCNT,
+    TMC_INTERPOLATE
   };
   enum TMC_drv_status_enum : char {
     TMC_DRV_CODES,
@@ -553,6 +554,7 @@
         case TMC_PWM_SCALE: SERIAL_PRINT(st.PWM_SCALE(), DEC); break;
         case TMC_SGT: SERIAL_PRINT(st.sgt(), DEC); break;
         case TMC_STEALTHCHOP: serialprint_truefalse(st.en_pwm_mode()); break;
+        case TMC_INTERPOLATE: serialprint_truefalse(st.intpol()); break;
         default: break;
       }
     }
@@ -588,6 +590,7 @@
             SERIAL_ECHOPGM("/256");
           }
           break;
+        case TMC_INTERPOLATE: serialprint_truefalse(st.intpol()); break;
         default: break;
       }
     }
@@ -603,6 +606,7 @@
         case TMC_STEALTHCHOP: serialprint_truefalse(st.stealth()); break;
         case TMC_S2VSA: if (st.s2vsa()) SERIAL_CHAR('*'); break;
         case TMC_S2VSB: if (st.s2vsb()) SERIAL_CHAR('*'); break;
+        case TMC_INTERPOLATE: serialprint_truefalse(st.intpol()); break;
         default: break;
       }
     }
@@ -644,6 +648,12 @@
 
   #if HAS_DRIVER(TMC2660)
     static void _tmc_parse_drv_status(TMC2660Stepper, const TMC_drv_status_enum) { }
+    static void _tmc_status(TMC2660Stepper &st, const TMC_debug_enum i) {
+      switch (i) {
+        case TMC_INTERPOLATE: serialprint_truefalse(st.intpol()); break;
+        default: break;
+      }
+    }
   #endif
 
   template <typename TMC>
@@ -902,6 +912,7 @@
     #endif
     TMC_REPORT("stealthChop",        TMC_STEALTHCHOP);
     TMC_REPORT("msteps\t",           TMC_MICROSTEPS);
+    TMC_REPORT("interp\t",           TMC_INTERPOLATE);
     TMC_REPORT("tstep\t",            TMC_TSTEP);
     TMC_REPORT("PWM thresh.",        TMC_TPWMTHRS);
     TMC_REPORT("[mm/s]\t",           TMC_TPWMTHRS_MMS);

commit d69c2a90b7721c2b779d31572faff5fd848d8ea0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Aug 5 23:21:41 2020 -0500

    Simple rename of hex_print

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 495d6a9f5b..781253079e 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -34,7 +34,7 @@
 
 #if ENABLED(TMC_DEBUG)
   #include "../module/planner.h"
-  #include "../libs/hex_print_routines.h"
+  #include "../libs/hex_print.h"
   #if ENABLED(MONITOR_DRIVER_STATUS)
     static uint16_t report_tmc_status_interval; // = 0
   #endif

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index a8a1f5075b..495d6a9f5b 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit 9ee891c4a602b8cbdf1f477e28b4e1bc9003fd99
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Jul 7 00:32:33 2020 +0200

    Fix TMC homing phase coils alignment (#18528)
    
    Co-authored-by: Fabio Santos <fabiosan@live.com>

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index fe8fe06d6f..a8a1f5075b 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -480,6 +480,10 @@
     TMC_GLOBAL_SCALER,
     TMC_CS_ACTUAL,
     TMC_PWM_SCALE,
+    TMC_PWM_SCALE_SUM,
+    TMC_PWM_SCALE_AUTO,
+    TMC_PWM_OFS_AUTO,
+    TMC_PWM_GRAD_AUTO,
     TMC_VSENSE,
     TMC_STEALTHCHOP,
     TMC_MICROSTEPS,
@@ -492,7 +496,8 @@
     TMC_TBL,
     TMC_HEND,
     TMC_HSTRT,
-    TMC_SGT
+    TMC_SGT,
+    TMC_MSCNT
   };
   enum TMC_drv_status_enum : char {
     TMC_DRV_CODES,
@@ -591,7 +596,10 @@
   #if HAS_TMC220x
     static void _tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
       switch (i) {
-        case TMC_PWM_SCALE: SERIAL_PRINT(st.pwm_scale_sum(), DEC); break;
+        case TMC_PWM_SCALE_SUM: SERIAL_PRINT(st.pwm_scale_sum(), DEC); break;
+        case TMC_PWM_SCALE_AUTO: SERIAL_PRINT(st.pwm_scale_auto(), DEC); break;
+        case TMC_PWM_OFS_AUTO: SERIAL_PRINT(st.pwm_ofs_auto(), DEC); break;
+        case TMC_PWM_GRAD_AUTO: SERIAL_PRINT(st.pwm_grad_auto(), DEC); break;
         case TMC_STEALTHCHOP: serialprint_truefalse(st.stealth()); break;
         case TMC_S2VSA: if (st.s2vsa()) SERIAL_CHAR('*'); break;
         case TMC_S2VSB: if (st.s2vsb()) SERIAL_CHAR('*'); break;
@@ -680,6 +688,7 @@
       case TMC_TBL: SERIAL_PRINT(st.blank_time(), DEC); break;
       case TMC_HEND: SERIAL_PRINT(st.hysteresis_end(), DEC); break;
       case TMC_HSTRT: SERIAL_PRINT(st.hysteresis_start(), DEC); break;
+      case TMC_MSCNT: SERIAL_PRINT(st.get_microstep_counter(), DEC); break;
       default: _tmc_status(st, i); break;
     }
   }
@@ -900,11 +909,20 @@
     #if ENABLED(MONITOR_DRIVER_STATUS)
       TMC_REPORT("triggered\n OTP\t", TMC_OTPW_TRIGGERED);
     #endif
+
+    #if HAS_TMC220x
+      TMC_REPORT("pwm scale sum",     TMC_PWM_SCALE_SUM);
+      TMC_REPORT("pwm scale auto",    TMC_PWM_SCALE_AUTO);
+      TMC_REPORT("pwm offset auto",   TMC_PWM_OFS_AUTO);
+      TMC_REPORT("pwm grad auto",     TMC_PWM_GRAD_AUTO);
+    #endif
+
     TMC_REPORT("off time",           TMC_TOFF);
     TMC_REPORT("blank time",         TMC_TBL);
     TMC_REPORT("hysteresis\n -end\t", TMC_HEND);
     TMC_REPORT(" -start\t",          TMC_HSTRT);
     TMC_REPORT("Stallguard thrs",    TMC_SGT);
+    TMC_REPORT("uStep count",        TMC_MSCNT);
     DRV_REPORT("DRVSTATUS",          TMC_DRV_CODES);
     #if HAS_TMCX1X0 || HAS_TMC220x
       DRV_REPORT("sg_result",        TMC_SG_RESULT);

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index bfc2e1a555..fe8fe06d6f 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -63,9 +63,9 @@
            , is_stall:1
            , is_stealth:1
            , is_standstill:1
-          #if HAS_STALLGUARD
-           , sg_result_reasonable:1
-          #endif
+           #if HAS_STALLGUARD
+             , sg_result_reasonable:1
+           #endif
          #endif
       ;
     #if ENABLED(TMC_DEBUG)
@@ -169,9 +169,7 @@
           data.is_stealth = TEST(ds, STEALTH_bp);
           data.is_standstill = TEST(ds, STST_bp);
         #endif
-        #if HAS_STALLGUARD
-          data.sg_result_reasonable = false;
-        #endif
+        TERN_(HAS_STALLGUARD, data.sg_result_reasonable = false);
       #endif
       return data;
     }
@@ -213,9 +211,7 @@
       SERIAL_PRINTLN(data.drv_status, HEX);
       if (data.is_ot) SERIAL_ECHOLNPGM("overtemperature");
       if (data.is_s2g) SERIAL_ECHOLNPGM("coil short circuit");
-      #if ENABLED(TMC_DEBUG)
-        tmc_report_all(true, true, true, true);
-      #endif
+      TERN_(TMC_DEBUG, tmc_report_all(true, true, true, true));
       kill(PSTR("Driver error"));
     }
   #endif
@@ -446,9 +442,7 @@
         (void)monitor_tmc_driver(stepperE7, need_update_error_counters, need_debug_reporting);
       #endif
 
-      #if ENABLED(TMC_DEBUG)
-        if (need_debug_reporting) SERIAL_EOL();
-      #endif
+      if (TERN0(TMC_DEBUG, need_debug_reporting)) SERIAL_EOL();
     }
   }
 

commit 514afddeb4b3a7ede9ff481504aae69219a95f68
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Apr 1 18:53:58 2020 -0500

    Minor code cleanup

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index e5e69eed50..bfc2e1a555 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -1254,7 +1254,7 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
     #endif
   }
 
-  if (axis_connection) ui.set_status_P(GET_TEXT(MSG_ERROR_TMC));
+  if (axis_connection) LCD_MESSAGEPGM(MSG_ERROR_TMC);
 }
 
 #endif // HAS_TRINAMIC_CONFIG

commit b1a50d54e2a6f8e415a72e0e2d275304029d8ada
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 2 12:03:43 2020 -0600

    HAS_TRINAMIC => HAS_TRINAMIC_CONFIG

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index a2723fd393..e5e69eed50 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -22,7 +22,7 @@
 
 #include "../inc/MarlinConfig.h"
 
-#if HAS_TRINAMIC
+#if HAS_TRINAMIC_CONFIG
 
 #include "tmc_util.h"
 #include "../MarlinCore.h"
@@ -954,7 +954,7 @@
     static void tmc_get_ic_registers(TMC2208Stepper, const TMC_get_registers_enum) { SERIAL_CHAR('\t'); }
   #endif
 
-  #if HAS_TRINAMIC
+  #if HAS_TRINAMIC_CONFIG
     template<class TMC>
     static void tmc_get_registers(TMC &st, const TMC_get_registers_enum i) {
       switch (i) {
@@ -1257,4 +1257,4 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
   if (axis_connection) ui.set_status_P(GET_TEXT(MSG_ERROR_TMC));
 }
 
-#endif // HAS_TRINAMIC
+#endif // HAS_TRINAMIC_CONFIG

commit 5e197df89af624d556b75c4881aacd1ab57e861d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 24 05:29:13 2020 -0600

    Fix Babystepping loop (again)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 9f905021ea..a2723fd393 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -1097,7 +1097,7 @@
 
   bool tmc_enable_stallguard(TMC2209Stepper &st) {
     const bool stealthchop_was_enabled = !st.en_spreadCycle();
-    
+
     st.TCOOLTHRS(0xFFFFF);
     st.en_spreadCycle(false);
     return stealthchop_was_enabled;

commit f30897500d37b59fbf975cfc772c4359fe8b2566
Author: Karl Andersson <karl@iaccess.se>
Date:   Fri Feb 21 14:40:55 2020 +0100

    Disable spreadcycle in tmc_enable_stallguard<2209> (#16890)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index be26b804b5..9f905021ea 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -1096,8 +1096,11 @@
   }
 
   bool tmc_enable_stallguard(TMC2209Stepper &st) {
+    const bool stealthchop_was_enabled = !st.en_spreadCycle();
+    
     st.TCOOLTHRS(0xFFFFF);
-    return !st.en_spreadCycle();
+    st.en_spreadCycle(false);
+    return stealthchop_was_enabled;
   }
   void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth) {
     st.en_spreadCycle(!restore_stealth);

commit ddce1c6ef23f86bde9389a309838ead6e0d0f36b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 10 18:28:04 2020 -0600

    Show '*' for zero 'stst' flag

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 11a81559df..be26b804b5 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -723,13 +723,13 @@
     SERIAL_CHAR('\t');
     switch (i) {
       case TMC_DRV_CODES:     st.printLabel();  break;
-      case TMC_STST:          if (st.stst())         SERIAL_CHAR('*'); break;
-      case TMC_OLB:           if (st.olb())          SERIAL_CHAR('*'); break;
-      case TMC_OLA:           if (st.ola())          SERIAL_CHAR('*'); break;
-      case TMC_S2GB:          if (st.s2gb())         SERIAL_CHAR('*'); break;
-      case TMC_S2GA:          if (st.s2ga())         SERIAL_CHAR('*'); break;
-      case TMC_DRV_OTPW:      if (st.otpw())         SERIAL_CHAR('*'); break;
-      case TMC_OT:            if (st.ot())           SERIAL_CHAR('*'); break;
+      case TMC_STST:          if (!st.stst())   SERIAL_CHAR('*'); break;
+      case TMC_OLB:           if (st.olb())     SERIAL_CHAR('*'); break;
+      case TMC_OLA:           if (st.ola())     SERIAL_CHAR('*'); break;
+      case TMC_S2GB:          if (st.s2gb())    SERIAL_CHAR('*'); break;
+      case TMC_S2GA:          if (st.s2ga())    SERIAL_CHAR('*'); break;
+      case TMC_DRV_OTPW:      if (st.otpw())    SERIAL_CHAR('*'); break;
+      case TMC_OT:            if (st.ot())      SERIAL_CHAR('*'); break;
       case TMC_DRV_STATUS_HEX: {
         const uint32_t drv_status = st.DRV_STATUS();
         SERIAL_CHAR('\t');

commit 894762259b072407504ee584103680b103310026
Author: Fabio Santos <fabiosan@live.com>
Date:   Sat Feb 8 19:01:57 2020 -0800

    Coolstep for TMC2130, 2209, 5130, 5160 (#16790)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index c09939173a..11a81559df 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -629,6 +629,15 @@
         default: break;
       }
     }
+
+    #if HAS_DRIVER(TMC2209)
+      static void _tmc_parse_drv_status(TMC2209Stepper &st, const TMC_drv_status_enum i) {
+        switch (i) {
+          case TMC_SG_RESULT: SERIAL_PRINT(st.SG_RESULT(), DEC); break;
+          default:            _tmc_parse_drv_status(static_cast<TMC2208Stepper &>(st), i); break;
+        }
+      }
+    #endif
   #endif
 
   #if HAS_DRIVER(TMC2660)
@@ -891,24 +900,24 @@
     TMC_REPORT("stealthChop",        TMC_STEALTHCHOP);
     TMC_REPORT("msteps\t",           TMC_MICROSTEPS);
     TMC_REPORT("tstep\t",            TMC_TSTEP);
-    TMC_REPORT("pwm\nthreshold",     TMC_TPWMTHRS);
+    TMC_REPORT("PWM thresh.",        TMC_TPWMTHRS);
     TMC_REPORT("[mm/s]\t",           TMC_TPWMTHRS_MMS);
     TMC_REPORT("OT prewarn",         TMC_OTPW);
     #if ENABLED(MONITOR_DRIVER_STATUS)
-      TMC_REPORT("OT prewarn has\n"
-                 "been triggered",   TMC_OTPW_TRIGGERED);
+      TMC_REPORT("triggered\n OTP\t", TMC_OTPW_TRIGGERED);
     #endif
     TMC_REPORT("off time",           TMC_TOFF);
     TMC_REPORT("blank time",         TMC_TBL);
-    TMC_REPORT("hysteresis\n-end\t", TMC_HEND);
-    TMC_REPORT("-start\t",           TMC_HSTRT);
+    TMC_REPORT("hysteresis\n -end\t", TMC_HEND);
+    TMC_REPORT(" -start\t",          TMC_HSTRT);
     TMC_REPORT("Stallguard thrs",    TMC_SGT);
-
     DRV_REPORT("DRVSTATUS",          TMC_DRV_CODES);
-    #if HAS_TMCX1X0
-      DRV_REPORT("stallguard\t",     TMC_STALLGUARD);
+    #if HAS_TMCX1X0 || HAS_TMC220x
       DRV_REPORT("sg_result",        TMC_SG_RESULT);
-      DRV_REPORT("fsactive\t",       TMC_FSACTIVE);
+    #endif
+    #if HAS_TMCX1X0
+      DRV_REPORT("stallguard",       TMC_STALLGUARD);
+      DRV_REPORT("fsactive",         TMC_FSACTIVE);
     #endif
     DRV_REPORT("stst\t",             TMC_STST);
     DRV_REPORT("olb\t",              TMC_OLB);
@@ -1103,7 +1112,7 @@
 
 #endif // USE_SENSORLESS
 
-#if TMC_HAS_SPI
+#if HAS_TMC_SPI
   #define SET_CS_PIN(st) OUT_WRITE(st##_CS_PIN, HIGH)
   void tmc_init_cs_pins() {
     #if AXIS_HAS_SPI(X)
@@ -1155,7 +1164,7 @@
       SET_CS_PIN(E7);
     #endif
   }
-#endif // TMC_HAS_SPI
+#endif // HAS_TMC_SPI
 
 template<typename TMC>
 static bool test_connection(TMC &st) {

commit f312ddfa4fd5772d825908f8e376dedf29442893
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 4 12:37:20 2020 -0600

    More updates for 8 extruders, REPEAT

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 63fa849b12..c09939173a 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -439,6 +439,12 @@
       #if AXIS_IS_TMC(E5)
         (void)monitor_tmc_driver(stepperE5, need_update_error_counters, need_debug_reporting);
       #endif
+      #if AXIS_IS_TMC(E6)
+        (void)monitor_tmc_driver(stepperE6, need_update_error_counters, need_debug_reporting);
+      #endif
+      #if AXIS_IS_TMC(E7)
+        (void)monitor_tmc_driver(stepperE7, need_update_error_counters, need_debug_reporting);
+      #endif
 
       #if ENABLED(TMC_DEBUG)
         if (need_debug_reporting) SERIAL_EOL();
@@ -782,6 +788,12 @@
       #if AXIS_IS_TMC(E5)
         tmc_status(stepperE5, i);
       #endif
+      #if AXIS_IS_TMC(E6)
+        tmc_status(stepperE6, i);
+      #endif
+      #if AXIS_IS_TMC(E7)
+        tmc_status(stepperE7, i);
+      #endif
     }
 
     SERIAL_EOL();
@@ -840,6 +852,12 @@
       #if AXIS_IS_TMC(E5)
         tmc_parse_drv_status(stepperE5, i);
       #endif
+      #if AXIS_IS_TMC(E6)
+        tmc_parse_drv_status(stepperE6, i);
+      #endif
+      #if AXIS_IS_TMC(E7)
+        tmc_parse_drv_status(stepperE7, i);
+      #endif
     }
 
     SERIAL_EOL();
@@ -1018,6 +1036,12 @@
       #if AXIS_IS_TMC(E5)
         tmc_get_registers(stepperE5, i);
       #endif
+      #if AXIS_IS_TMC(E6)
+        tmc_get_registers(stepperE6, i);
+      #endif
+      #if AXIS_IS_TMC(E7)
+        tmc_get_registers(stepperE7, i);
+      #endif
     }
 
     SERIAL_EOL();
@@ -1124,6 +1148,12 @@
     #if AXIS_HAS_SPI(E5)
       SET_CS_PIN(E5);
     #endif
+    #if AXIS_HAS_SPI(E6)
+      SET_CS_PIN(E6);
+    #endif
+    #if AXIS_HAS_SPI(E7)
+      SET_CS_PIN(E7);
+    #endif
   }
 #endif // TMC_HAS_SPI
 
@@ -1204,6 +1234,12 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
     #if AXIS_IS_TMC(E5)
       axis_connection += test_connection(stepperE5);
     #endif
+    #if AXIS_IS_TMC(E6)
+      axis_connection += test_connection(stepperE6);
+    #endif
+    #if AXIS_IS_TMC(E7)
+      axis_connection += test_connection(stepperE7);
+    #endif
   }
 
   if (axis_connection) ui.set_status_P(GET_TEXT(MSG_ERROR_TMC));

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 84b5c2db7b..63fa849b12 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit 0d342bac51a5f32d143f0dba9c65af820dfab621
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 1 06:27:17 2020 -0600

    Fix CURRENT_STEP_DOWN compile error

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 340855a6da..84b5c2db7b 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -281,6 +281,10 @@
       }
     }
 
+  #else
+
+    #define step_current_down(...)
+
   #endif
 
   template<typename TMC>
@@ -288,7 +292,7 @@
     TMC_driver_data data = get_driver_data(st);
     if (data.drv_status == 0xFFFFFFFF || data.drv_status == 0x0) return false;
 
-    bool did_step_down = false;
+    bool should_step_down = false;
 
     if (need_update_error_counters) {
       if (data.is_ot /* | data.s2ga | data.s2gb*/) st.error_count++;
@@ -308,10 +312,8 @@
 
       #if CURRENT_STEP_DOWN > 0
         // Decrease current if is_otpw is true and driver is enabled and there's been more than 4 warnings
-        if (data.is_otpw && st.otpw_count > 4 && st.isEnabled()) {
-          step_current_down(st);
-          did_step_down = true;
-        }
+        if (data.is_otpw && st.otpw_count > 4 && st.isEnabled())
+          should_step_down = true;
       #endif
 
       if (data.is_otpw) {
@@ -325,7 +327,7 @@
       if (need_debug_reporting) report_polled_driver_data(st, data);
     #endif
 
-    return did_step_down;
+    return should_step_down;
   }
 
   void monitor_tmc_drivers() {

commit 0fcf2b1110d9f0d362e5aab9cc73d963710e9865
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jan 20 00:35:07 2020 -0500

    Quad Z stepper support (#16277)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index e044044a02..340855a6da 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -387,7 +387,7 @@
       }
       #endif
 
-      #if AXIS_IS_TMC(Z) || AXIS_IS_TMC(Z2) || AXIS_IS_TMC(Z3)
+      #if AXIS_IS_TMC(Z) || AXIS_IS_TMC(Z2) || AXIS_IS_TMC(Z3) || AXIS_IS_TMC(Z4)
       {
         bool result = false;
         #if AXIS_IS_TMC(Z)
@@ -399,6 +399,9 @@
         #if AXIS_IS_TMC(Z3)
           if (monitor_tmc_driver(stepperZ3, need_update_error_counters, need_debug_reporting)) result = true;
         #endif
+        #if AXIS_IS_TMC(Z4)
+          if (monitor_tmc_driver(stepperZ4, need_update_error_counters, need_debug_reporting)) result = true;
+        #endif
         if (result) {
           #if AXIS_IS_TMC(Z)
             step_current_down(stepperZ);
@@ -409,6 +412,9 @@
           #if AXIS_IS_TMC(Z3)
             step_current_down(stepperZ3);
           #endif
+          #if AXIS_IS_TMC(Z4)
+            step_current_down(stepperZ4);
+          #endif
         }
       }
       #endif
@@ -750,6 +756,9 @@
       #if AXIS_IS_TMC(Z3)
         tmc_status(stepperZ3, i);
       #endif
+      #if AXIS_IS_TMC(Z4)
+        tmc_status(stepperZ4, i);
+      #endif
     }
 
     if (print_e) {
@@ -805,6 +814,9 @@
       #if AXIS_IS_TMC(Z3)
         tmc_parse_drv_status(stepperZ3, i);
       #endif
+      #if AXIS_IS_TMC(Z4)
+        tmc_parse_drv_status(stepperZ4, i);
+      #endif
     }
 
     if (print_e) {
@@ -980,6 +992,9 @@
       #if AXIS_IS_TMC(Z3)
         tmc_get_registers(stepperZ3, i);
       #endif
+      #if AXIS_IS_TMC(Z4)
+        tmc_get_registers(stepperZ4, i);
+      #endif
     }
 
     if (print_e) {
@@ -1086,6 +1101,9 @@
     #if AXIS_HAS_SPI(Z3)
       SET_CS_PIN(Z3);
     #endif
+    #if AXIS_HAS_SPI(Z4)
+      SET_CS_PIN(Z4);
+    #endif
     #if AXIS_HAS_SPI(E0)
       SET_CS_PIN(E0);
     #endif
@@ -1160,6 +1178,9 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
     #if AXIS_IS_TMC(Z3)
       axis_connection += test_connection(stepperZ3);
     #endif
+    #if AXIS_IS_TMC(Z4)
+      axis_connection += test_connection(stepperZ4);
+    #endif
   }
 
   if (test_e) {

commit f6a6839a82312f05efbd39acc3bbbd92b990e8a5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jan 19 19:29:30 2020 -0600

    Simplify TMC monitor code

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index f50371d73b..e044044a02 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -346,64 +346,73 @@
     #endif
 
     if (need_update_error_counters || need_debug_reporting) {
-      #if AXIS_IS_TMC(X)
-        if (monitor_tmc_driver(stepperX, need_update_error_counters, need_debug_reporting)) {
-          #if AXIS_IS_TMC(X2)
-            step_current_down(stepperX2);
-          #endif
-        }
-      #endif
-      #if AXIS_IS_TMC(X2)
-        if (monitor_tmc_driver(stepperX2, need_update_error_counters, need_debug_reporting)) {
+
+      #if AXIS_IS_TMC(X) || AXIS_IS_TMC(X2)
+      {
+        bool result = false;
+        #if AXIS_IS_TMC(X)
+          if (monitor_tmc_driver(stepperX, need_update_error_counters, need_debug_reporting)) result = true;
+        #endif
+        #if AXIS_IS_TMC(X2)
+          if (monitor_tmc_driver(stepperX2, need_update_error_counters, need_debug_reporting)) result = true;
+        #endif
+        if (result) {
           #if AXIS_IS_TMC(X)
             step_current_down(stepperX);
           #endif
-        }
-      #endif
-      #if AXIS_IS_TMC(Y)
-        if (monitor_tmc_driver(stepperY, need_update_error_counters, need_debug_reporting)) {
-          #if AXIS_IS_TMC(Y2)
-            step_current_down(stepperY2);
+          #if AXIS_IS_TMC(X2)
+            step_current_down(stepperX2);
           #endif
         }
+      }
       #endif
-      #if AXIS_IS_TMC(Y2)
-        if (monitor_tmc_driver(stepperY2, need_update_error_counters, need_debug_reporting)) {
+
+      #if AXIS_IS_TMC(Y) || AXIS_IS_TMC(Y2)
+      {
+        bool result = false;
+        #if AXIS_IS_TMC(Y)
+          if (monitor_tmc_driver(stepperY, need_update_error_counters, need_debug_reporting)) result = true;
+        #endif
+        #if AXIS_IS_TMC(Y2)
+          if (monitor_tmc_driver(stepperY2, need_update_error_counters, need_debug_reporting)) result = true;
+        #endif
+        if (result) {
           #if AXIS_IS_TMC(Y)
             step_current_down(stepperY);
           #endif
-        }
-      #endif
-      #if AXIS_IS_TMC(Z)
-        if (monitor_tmc_driver(stepperZ, need_update_error_counters, need_debug_reporting)) {
-          #if AXIS_IS_TMC(Z2)
-            step_current_down(stepperZ2);
-          #endif
-          #if AXIS_IS_TMC(Z3)
-            step_current_down(stepperZ3);
-          #endif
-        }
-      #endif
-      #if AXIS_IS_TMC(Z2)
-        if (monitor_tmc_driver(stepperZ2, need_update_error_counters, need_debug_reporting)) {
-          #if AXIS_IS_TMC(Z)
-            step_current_down(stepperZ);
-          #endif
-          #if AXIS_IS_TMC(Z3)
-            step_current_down(stepperZ3);
+          #if AXIS_IS_TMC(Y2)
+            step_current_down(stepperY2);
           #endif
         }
+      }
       #endif
-      #if AXIS_IS_TMC(Z3)
-        if (monitor_tmc_driver(stepperZ3, need_update_error_counters, need_debug_reporting)) {
+
+      #if AXIS_IS_TMC(Z) || AXIS_IS_TMC(Z2) || AXIS_IS_TMC(Z3)
+      {
+        bool result = false;
+        #if AXIS_IS_TMC(Z)
+          if (monitor_tmc_driver(stepperZ, need_update_error_counters, need_debug_reporting)) result = true;
+        #endif
+        #if AXIS_IS_TMC(Z2)
+          if (monitor_tmc_driver(stepperZ2, need_update_error_counters, need_debug_reporting)) result = true;
+        #endif
+        #if AXIS_IS_TMC(Z3)
+          if (monitor_tmc_driver(stepperZ3, need_update_error_counters, need_debug_reporting)) result = true;
+        #endif
+        if (result) {
           #if AXIS_IS_TMC(Z)
             step_current_down(stepperZ);
           #endif
           #if AXIS_IS_TMC(Z2)
             step_current_down(stepperZ2);
           #endif
+          #if AXIS_IS_TMC(Z3)
+            step_current_down(stepperZ3);
+          #endif
         }
+      }
       #endif
+
       #if AXIS_IS_TMC(E0)
         (void)monitor_tmc_driver(stepperE0, need_update_error_counters, need_debug_reporting);
       #endif

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index edcfe511ae..f50371d73b 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -25,7 +25,7 @@
 #if HAS_TRINAMIC
 
 #include "tmc_util.h"
-#include "../Marlin.h"
+#include "../MarlinCore.h"
 
 #include "../module/stepper/indirection.h"
 #include "../module/printcounter.h"

commit 937dca4432cf1aecf743de913a316b5b5d9413c9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Dec 19 15:54:29 2019 -0600

    Followup to TMC2209 spreadcycle patch

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 3eb29c0f99..edcfe511ae 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -1022,7 +1022,7 @@
 #if USE_SENSORLESS
 
   bool tmc_enable_stallguard(TMC2130Stepper &st) {
-    bool stealthchop_was_enabled = st.en_pwm_mode();
+    const bool stealthchop_was_enabled = st.en_pwm_mode();
 
     st.TCOOLTHRS(0xFFFFF);
     st.en_pwm_mode(false);
@@ -1038,7 +1038,7 @@
 
   bool tmc_enable_stallguard(TMC2209Stepper &st) {
     st.TCOOLTHRS(0xFFFFF);
-    return stealthchop_was_enabled;
+    return !st.en_spreadCycle();
   }
   void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth) {
     st.en_spreadCycle(!restore_stealth);

commit e5edbf9d3526953f7683f03abdb88355fd8a79c9
Author: elementfoundry <57408038+elementfoundry@users.noreply.github.com>
Date:   Thu Dec 19 01:23:54 2019 -0700

    Allow TMC2209 to save/restore spreadCycle (#16153)
    
    Co-Authored-By: teemuatlut <teemu.mantykallio@live.fi>

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index f5c9509831..3eb29c0f99 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -1038,9 +1038,10 @@
 
   bool tmc_enable_stallguard(TMC2209Stepper &st) {
     st.TCOOLTHRS(0xFFFFF);
-    return true;
+    return stealthchop_was_enabled;
   }
-  void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth _UNUSED) {
+  void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth) {
+    st.en_spreadCycle(!restore_stealth);
     st.TCOOLTHRS(0);
   }
 

commit 25a7ceabdbac8e60fccc61e31283e7be8b8d5e1a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 1 17:30:22 2019 -0600

    Fix missing step_current_down semicolons

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index a6f66deb9a..f5c9509831 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -349,58 +349,58 @@
       #if AXIS_IS_TMC(X)
         if (monitor_tmc_driver(stepperX, need_update_error_counters, need_debug_reporting)) {
           #if AXIS_IS_TMC(X2)
-            step_current_down(stepperX2)
+            step_current_down(stepperX2);
           #endif
         }
       #endif
       #if AXIS_IS_TMC(X2)
         if (monitor_tmc_driver(stepperX2, need_update_error_counters, need_debug_reporting)) {
           #if AXIS_IS_TMC(X)
-            step_current_down(stepperX)
+            step_current_down(stepperX);
           #endif
         }
       #endif
       #if AXIS_IS_TMC(Y)
         if (monitor_tmc_driver(stepperY, need_update_error_counters, need_debug_reporting)) {
           #if AXIS_IS_TMC(Y2)
-            step_current_down(stepperY2)
+            step_current_down(stepperY2);
           #endif
         }
       #endif
       #if AXIS_IS_TMC(Y2)
         if (monitor_tmc_driver(stepperY2, need_update_error_counters, need_debug_reporting)) {
           #if AXIS_IS_TMC(Y)
-            step_current_down(stepperY)
+            step_current_down(stepperY);
           #endif
         }
       #endif
       #if AXIS_IS_TMC(Z)
         if (monitor_tmc_driver(stepperZ, need_update_error_counters, need_debug_reporting)) {
           #if AXIS_IS_TMC(Z2)
-            step_current_down(stepperZ2)
+            step_current_down(stepperZ2);
           #endif
           #if AXIS_IS_TMC(Z3)
-            step_current_down(stepperZ3)
+            step_current_down(stepperZ3);
           #endif
         }
       #endif
       #if AXIS_IS_TMC(Z2)
         if (monitor_tmc_driver(stepperZ2, need_update_error_counters, need_debug_reporting)) {
           #if AXIS_IS_TMC(Z)
-            step_current_down(stepperZ)
+            step_current_down(stepperZ);
           #endif
           #if AXIS_IS_TMC(Z3)
-            step_current_down(stepperZ3)
+            step_current_down(stepperZ3);
           #endif
         }
       #endif
       #if AXIS_IS_TMC(Z3)
         if (monitor_tmc_driver(stepperZ3, need_update_error_counters, need_debug_reporting)) {
           #if AXIS_IS_TMC(Z)
-            step_current_down(stepperZ)
+            step_current_down(stepperZ);
           #endif
           #if AXIS_IS_TMC(Z2)
-            step_current_down(stepperZ2)
+            step_current_down(stepperZ2);
           #endif
         }
       #endif

commit 27943f9e31a4c16d981e437447f143972c92f835
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 30 06:59:44 2019 -0600

    Multiple axis TMC OTPW step down (#16044)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 618fdd81f5..a6f66deb9a 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -265,10 +265,30 @@
     SERIAL_CHAR('\t');
   }
 
+  #if CURRENT_STEP_DOWN > 0
+
+    template<typename TMC>
+    void step_current_down(TMC &st) {
+      if (st.isEnabled()) {
+        const uint16_t I_rms = st.getMilliamps() - (CURRENT_STEP_DOWN);
+        if (I_rms > 50) {
+          st.rms_current(I_rms);
+          #if ENABLED(REPORT_CURRENT_CHANGE)
+            st.printLabel();
+            SERIAL_ECHOLNPAIR(" current decreased to ", I_rms);
+          #endif
+        }
+      }
+    }
+
+  #endif
+
   template<typename TMC>
-  void monitor_tmc_driver(TMC &st, const bool need_update_error_counters, const bool need_debug_reporting) {
+  bool monitor_tmc_driver(TMC &st, const bool need_update_error_counters, const bool need_debug_reporting) {
     TMC_driver_data data = get_driver_data(st);
-    if (data.drv_status == 0xFFFFFFFF || data.drv_status == 0x0) return;
+    if (data.drv_status == 0xFFFFFFFF || data.drv_status == 0x0) return false;
+
+    bool did_step_down = false;
 
     if (need_update_error_counters) {
       if (data.is_ot /* | data.s2ga | data.s2gb*/) st.error_count++;
@@ -288,15 +308,9 @@
 
       #if CURRENT_STEP_DOWN > 0
         // Decrease current if is_otpw is true and driver is enabled and there's been more than 4 warnings
-        if (data.is_otpw && st.otpw_count > 4) {
-          uint16_t I_rms = st.getMilliamps();
-          if (st.isEnabled() && I_rms > 100) {
-            st.rms_current(I_rms - (CURRENT_STEP_DOWN));
-            #if ENABLED(REPORT_CURRENT_CHANGE)
-              st.printLabel();
-              SERIAL_ECHOLNPAIR(" current decreased to ", st.getMilliamps());
-            #endif
-          }
+        if (data.is_otpw && st.otpw_count > 4 && st.isEnabled()) {
+          step_current_down(st);
+          did_step_down = true;
         }
       #endif
 
@@ -308,64 +322,105 @@
     }
 
     #if ENABLED(TMC_DEBUG)
-      if (need_debug_reporting)
-        report_polled_driver_data(st, data);
+      if (need_debug_reporting) report_polled_driver_data(st, data);
     #endif
+
+    return did_step_down;
   }
 
-  void monitor_tmc_driver() {
-    static millis_t next_poll = 0;
+  void monitor_tmc_drivers() {
     const millis_t ms = millis();
-    bool need_update_error_counters = ELAPSED(ms, next_poll);
-    bool need_debug_reporting = false;
-    if (need_update_error_counters)
-      next_poll = ms + MONITOR_DRIVER_STATUS_INTERVAL_MS;
+
+    // Poll TMC drivers at the configured interval
+    static millis_t next_poll = 0;
+    const bool need_update_error_counters = ELAPSED(ms, next_poll);
+    if (need_update_error_counters) next_poll = ms + MONITOR_DRIVER_STATUS_INTERVAL_MS;
+
+    // Also poll at intervals for debugging
     #if ENABLED(TMC_DEBUG)
       static millis_t next_debug_reporting = 0;
-      if (report_tmc_status_interval && ELAPSED(ms, next_debug_reporting)) {
-        need_debug_reporting = true;
-        next_debug_reporting = ms + report_tmc_status_interval;
-      }
+      const bool need_debug_reporting = report_tmc_status_interval && ELAPSED(ms, next_debug_reporting);
+      if (need_debug_reporting) next_debug_reporting = ms + report_tmc_status_interval;
+    #else
+      constexpr bool need_debug_reporting = false;
     #endif
+
     if (need_update_error_counters || need_debug_reporting) {
       #if AXIS_IS_TMC(X)
-        monitor_tmc_driver(stepperX, need_update_error_counters, need_debug_reporting);
-      #endif
-      #if AXIS_IS_TMC(Y)
-        monitor_tmc_driver(stepperY, need_update_error_counters, need_debug_reporting);
-      #endif
-      #if AXIS_IS_TMC(Z)
-        monitor_tmc_driver(stepperZ, need_update_error_counters, need_debug_reporting);
+        if (monitor_tmc_driver(stepperX, need_update_error_counters, need_debug_reporting)) {
+          #if AXIS_IS_TMC(X2)
+            step_current_down(stepperX2)
+          #endif
+        }
       #endif
       #if AXIS_IS_TMC(X2)
-        monitor_tmc_driver(stepperX2, need_update_error_counters, need_debug_reporting);
+        if (monitor_tmc_driver(stepperX2, need_update_error_counters, need_debug_reporting)) {
+          #if AXIS_IS_TMC(X)
+            step_current_down(stepperX)
+          #endif
+        }
+      #endif
+      #if AXIS_IS_TMC(Y)
+        if (monitor_tmc_driver(stepperY, need_update_error_counters, need_debug_reporting)) {
+          #if AXIS_IS_TMC(Y2)
+            step_current_down(stepperY2)
+          #endif
+        }
       #endif
       #if AXIS_IS_TMC(Y2)
-        monitor_tmc_driver(stepperY2, need_update_error_counters, need_debug_reporting);
+        if (monitor_tmc_driver(stepperY2, need_update_error_counters, need_debug_reporting)) {
+          #if AXIS_IS_TMC(Y)
+            step_current_down(stepperY)
+          #endif
+        }
+      #endif
+      #if AXIS_IS_TMC(Z)
+        if (monitor_tmc_driver(stepperZ, need_update_error_counters, need_debug_reporting)) {
+          #if AXIS_IS_TMC(Z2)
+            step_current_down(stepperZ2)
+          #endif
+          #if AXIS_IS_TMC(Z3)
+            step_current_down(stepperZ3)
+          #endif
+        }
       #endif
       #if AXIS_IS_TMC(Z2)
-        monitor_tmc_driver(stepperZ2, need_update_error_counters, need_debug_reporting);
+        if (monitor_tmc_driver(stepperZ2, need_update_error_counters, need_debug_reporting)) {
+          #if AXIS_IS_TMC(Z)
+            step_current_down(stepperZ)
+          #endif
+          #if AXIS_IS_TMC(Z3)
+            step_current_down(stepperZ3)
+          #endif
+        }
       #endif
       #if AXIS_IS_TMC(Z3)
-        monitor_tmc_driver(stepperZ3, need_update_error_counters, need_debug_reporting);
+        if (monitor_tmc_driver(stepperZ3, need_update_error_counters, need_debug_reporting)) {
+          #if AXIS_IS_TMC(Z)
+            step_current_down(stepperZ)
+          #endif
+          #if AXIS_IS_TMC(Z2)
+            step_current_down(stepperZ2)
+          #endif
+        }
       #endif
       #if AXIS_IS_TMC(E0)
-        monitor_tmc_driver(stepperE0, need_update_error_counters, need_debug_reporting);
+        (void)monitor_tmc_driver(stepperE0, need_update_error_counters, need_debug_reporting);
       #endif
       #if AXIS_IS_TMC(E1)
-        monitor_tmc_driver(stepperE1, need_update_error_counters, need_debug_reporting);
+        (void)monitor_tmc_driver(stepperE1, need_update_error_counters, need_debug_reporting);
       #endif
       #if AXIS_IS_TMC(E2)
-        monitor_tmc_driver(stepperE2, need_update_error_counters, need_debug_reporting);
+        (void)monitor_tmc_driver(stepperE2, need_update_error_counters, need_debug_reporting);
       #endif
       #if AXIS_IS_TMC(E3)
-        monitor_tmc_driver(stepperE3, need_update_error_counters, need_debug_reporting);
+        (void)monitor_tmc_driver(stepperE3, need_update_error_counters, need_debug_reporting);
       #endif
       #if AXIS_IS_TMC(E4)
-        monitor_tmc_driver(stepperE4, need_update_error_counters, need_debug_reporting);
+        (void)monitor_tmc_driver(stepperE4, need_update_error_counters, need_debug_reporting);
       #endif
       #if AXIS_IS_TMC(E5)
-        monitor_tmc_driver(stepperE5, need_update_error_counters, need_debug_reporting);
+        (void)monitor_tmc_driver(stepperE5, need_update_error_counters, need_debug_reporting);
       #endif
 
       #if ENABLED(TMC_DEBUG)

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 6b97168f98..618fdd81f5 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -1118,7 +1118,7 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
     #endif
   }
 
-  if (axis_connection) ui.set_status_P(PSTR(MSG_ERROR_TMC));
+  if (axis_connection) ui.set_status_P(GET_TEXT(MSG_ERROR_TMC));
 }
 
 #endif // HAS_TRINAMIC

commit 438835f6a52ab23c9b0114a27d35941a34648592
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Oct 1 20:59:48 2019 -0400

    Configurable Max Accel, Max Feedrate, Max Jerk edit limits (#13929)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 329c511ecd..6b97168f98 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -507,7 +507,7 @@
         case TMC_GLOBAL_SCALER:
           {
             uint16_t value = st.GLOBAL_SCALER();
-            SERIAL_PRINT(value ? value : 256, DEC);
+            SERIAL_PRINT(value ?: 256, DEC);
             SERIAL_ECHOPGM("/256");
           }
           break;

commit 068c303742dc9df785bce68eda858dc72bd6e55c
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sun Sep 8 07:15:25 2019 +0200

    More translatable LCD strings (#15190)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 428a5986fa..329c511ecd 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -1118,7 +1118,7 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
     #endif
   }
 
-  if (axis_connection) ui.set_status_P(PSTR("TMC CONNECTION ERROR"));
+  if (axis_connection) ui.set_status_P(PSTR(MSG_ERROR_TMC));
 }
 
 #endif // HAS_TRINAMIC

commit 586b334c2ab61240607e878390ed1d53af86da69
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 31 19:44:45 2019 -0500

    Split up stepper indirection (#15111)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index b3ea6e7cb7..428a5986fa 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -27,7 +27,7 @@
 #include "tmc_util.h"
 #include "../Marlin.h"
 
-#include "../module/stepper_indirection.h"
+#include "../module/stepper/indirection.h"
 #include "../module/printcounter.h"
 #include "../libs/duration_t.h"
 #include "../gcode/gcode.h"

commit 27952648cf7c91d8d3f4e906aad113a13d2965e8
Author: Gustavo Alvarez <462213+sl1pkn07@users.noreply.github.com>
Date:   Wed Jul 31 00:11:17 2019 +0200

    Fix M122 column alignment (#14779)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index a9c55e8c10..b3ea6e7cb7 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -787,7 +787,7 @@
     #if HAS_DRIVER(TMC2160) || HAS_DRIVER(TMC5160)
       TMC_REPORT("Global scaler",    TMC_GLOBAL_SCALER);
     #endif
-    TMC_REPORT("CS actual\t",        TMC_CS_ACTUAL);
+    TMC_REPORT("CS actual",          TMC_CS_ACTUAL);
     TMC_REPORT("PWM scale",          TMC_PWM_SCALE);
     #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC2224) || HAS_DRIVER(TMC2660) || HAS_TMC220x
       TMC_REPORT("vsense\t",         TMC_VSENSE);
@@ -795,14 +795,14 @@
     TMC_REPORT("stealthChop",        TMC_STEALTHCHOP);
     TMC_REPORT("msteps\t",           TMC_MICROSTEPS);
     TMC_REPORT("tstep\t",            TMC_TSTEP);
-    TMC_REPORT("pwm\nthreshold\t",   TMC_TPWMTHRS);
+    TMC_REPORT("pwm\nthreshold",     TMC_TPWMTHRS);
     TMC_REPORT("[mm/s]\t",           TMC_TPWMTHRS_MMS);
     TMC_REPORT("OT prewarn",         TMC_OTPW);
     #if ENABLED(MONITOR_DRIVER_STATUS)
       TMC_REPORT("OT prewarn has\n"
                  "been triggered",   TMC_OTPW_TRIGGERED);
     #endif
-    TMC_REPORT("off time\t",         TMC_TOFF);
+    TMC_REPORT("off time",           TMC_TOFF);
     TMC_REPORT("blank time",         TMC_TBL);
     TMC_REPORT("hysteresis\n-end\t", TMC_HEND);
     TMC_REPORT("-start\t",           TMC_HSTRT);
@@ -811,7 +811,7 @@
     DRV_REPORT("DRVSTATUS",          TMC_DRV_CODES);
     #if HAS_TMCX1X0
       DRV_REPORT("stallguard\t",     TMC_STALLGUARD);
-      DRV_REPORT("sg_result\t",      TMC_SG_RESULT);
+      DRV_REPORT("sg_result",        TMC_SG_RESULT);
       DRV_REPORT("fsactive\t",       TMC_FSACTIVE);
     #endif
     DRV_REPORT("stst\t",             TMC_STST);

commit 1a349c75229604c113c83d29c2ff06f61153b44a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jul 8 22:59:51 2019 -0500

    Add HAS_TMC220x

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index c432a3cf9a..a9c55e8c10 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -69,7 +69,7 @@
          #endif
       ;
     #if ENABLED(TMC_DEBUG)
-      #if HAS_TMCX1X0 || HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
+      #if HAS_TMCX1X0 || HAS_TMC220x
         uint8_t cs_actual;
       #endif
       #if HAS_STALLGUARD
@@ -139,7 +139,7 @@
 
   #endif // HAS_TMCX1X0
 
-  #if HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
+  #if HAS_TMC220x
 
     #if ENABLED(TMC_DEBUG)
       static uint32_t get_pwm_scale(TMC2208Stepper &st) { return st.pwm_scale_sum(); }
@@ -239,7 +239,7 @@
     st.printLabel();
     SERIAL_CHAR(':'); SERIAL_PRINT(pwm_scale, DEC);
     #if ENABLED(TMC_DEBUG)
-      #if HAS_TMCX1X0 || HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
+      #if HAS_TMCX1X0 || HAS_TMC220x
         SERIAL_CHAR('/'); SERIAL_PRINT(data.cs_actual, DEC);
       #endif
       #if HAS_STALLGUARD
@@ -516,7 +516,7 @@
     }
   #endif
 
-  #if HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
+  #if HAS_TMC220x
     static void _tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
       switch (i) {
         case TMC_PWM_SCALE: SERIAL_PRINT(st.pwm_scale_sum(), DEC); break;
@@ -789,7 +789,7 @@
     #endif
     TMC_REPORT("CS actual\t",        TMC_CS_ACTUAL);
     TMC_REPORT("PWM scale",          TMC_PWM_SCALE);
-    #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC2224) || HAS_DRIVER(TMC2660) || HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
+    #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC2224) || HAS_DRIVER(TMC2660) || HAS_TMC220x
       TMC_REPORT("vsense\t",         TMC_VSENSE);
     #endif
     TMC_REPORT("stealthChop",        TMC_STEALTHCHOP);
@@ -821,7 +821,7 @@
     DRV_REPORT("s2ga\t",             TMC_S2GA);
     DRV_REPORT("otpw\t",             TMC_DRV_OTPW);
     DRV_REPORT("ot\t",               TMC_OT);
-    #if HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
+    #if HAS_TMC220x
       DRV_REPORT("157C\t",           TMC_T157);
       DRV_REPORT("150C\t",           TMC_T150);
       DRV_REPORT("143C\t",           TMC_T143);
@@ -845,7 +845,7 @@
       }
     }
   #endif
-  #if HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
+  #if HAS_TMC220x
     static void tmc_get_ic_registers(TMC2208Stepper, const TMC_get_registers_enum) { SERIAL_CHAR('\t'); }
   #endif
 

commit e6cf7860e8fafb5c2bdb95ff36ad7d598fa5636a
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Jun 28 23:23:57 2019 -0600

    Improve ExtUI, fix compiler errors, warnings (#14441)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index e79d4045ea..c432a3cf9a 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -985,7 +985,7 @@
     st.TCOOLTHRS(0xFFFFF);
     return true;
   }
-  void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth) {
+  void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth _UNUSED) {
     st.TCOOLTHRS(0);
   }
 

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index b91be7e9a1..e79d4045ea 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit 4df4c47994f248428ae30218800803e467327b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 20 15:47:50 2019 -0500

    Add TMC2209 support (#14249)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 847310c210..b91be7e9a1 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -69,7 +69,7 @@
          #endif
       ;
     #if ENABLED(TMC_DEBUG)
-      #if HAS_TMCX1X0 || HAS_DRIVER(TMC2208)
+      #if HAS_TMCX1X0 || HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
         uint8_t cs_actual;
       #endif
       #if HAS_STALLGUARD
@@ -97,6 +97,7 @@
       TMC_driver_data data;
       const auto ds = data.drv_status = st.DRV_STATUS();
       #ifdef __AVR__
+
         // 8-bit optimization saves up to 70 bytes of PROGMEM per axis
         uint8_t spart;
         #if ENABLED(TMC_DEBUG)
@@ -115,6 +116,7 @@
           data.is_standstill = TEST(spart, STST_bp - 24);
           data.sg_result_reasonable = !data.is_standstill; // sg_result has no reasonable meaning while standstill
         #endif
+
       #else // !__AVR__
 
         data.is_ot = TEST(ds, OT_bp);
@@ -137,7 +139,7 @@
 
   #endif // HAS_TMCX1X0
 
-  #if HAS_DRIVER(TMC2208)
+  #if HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
 
     #if ENABLED(TMC_DEBUG)
       static uint32_t get_pwm_scale(TMC2208Stepper &st) { return st.pwm_scale_sum(); }
@@ -174,7 +176,7 @@
       return data;
     }
 
-  #endif // TMC2208
+  #endif // TMC2208 || TMC2209
 
   #if HAS_DRIVER(TMC2660)
 
@@ -228,9 +230,7 @@
     SERIAL_ECHO(timestamp);
     SERIAL_ECHOPGM(": ");
     st.printLabel();
-    SERIAL_ECHOPGM(" driver overtemperature warning! (");
-    SERIAL_ECHO(st.getMilliamps());
-    SERIAL_ECHOLNPGM("mA)");
+    SERIAL_ECHOLNPAIR(" driver overtemperature warning! (", st.getMilliamps(), "mA)");
   }
 
   template<typename TMC>
@@ -239,7 +239,7 @@
     st.printLabel();
     SERIAL_CHAR(':'); SERIAL_PRINT(pwm_scale, DEC);
     #if ENABLED(TMC_DEBUG)
-      #if HAS_TMCX1X0 || HAS_DRIVER(TMC2208)
+      #if HAS_TMCX1X0 || HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
         SERIAL_CHAR('/'); SERIAL_PRINT(data.cs_actual, DEC);
       #endif
       #if HAS_STALLGUARD
@@ -386,7 +386,7 @@
       if ((report_tmc_status_interval = update_interval))
         SERIAL_ECHOLNPGM("axis:pwm_scale"
           #if HAS_STEALTHCHOP
-            "/current_scale"
+            "/curr_scale"
           #endif
           #if HAS_STALLGUARD
             "/mech_load"
@@ -398,6 +398,7 @@
 
   enum TMC_debug_enum : char {
     TMC_CODES,
+    TMC_UART_ADDR,
     TMC_ENABLED,
     TMC_CURRENT,
     TMC_RMS_CURRENT,
@@ -482,9 +483,9 @@
   #if HAS_TMCX1X0
     static void _tmc_parse_drv_status(TMC2130Stepper &st, const TMC_drv_status_enum i) {
       switch (i) {
-        case TMC_STALLGUARD: if (st.stallguard()) SERIAL_CHAR('X'); break;
-        case TMC_SG_RESULT:  SERIAL_PRINT(st.sg_result(), DEC);   break;
-        case TMC_FSACTIVE:   if (st.fsactive())   SERIAL_CHAR('X'); break;
+        case TMC_STALLGUARD: if (st.stallguard()) SERIAL_CHAR('*'); break;
+        case TMC_SG_RESULT:  SERIAL_PRINT(st.sg_result(), DEC); break;
+        case TMC_FSACTIVE:   if (st.fsactive())   SERIAL_CHAR('*'); break;
         case TMC_DRV_CS_ACTUAL: SERIAL_PRINT(st.cs_actual(), DEC); break;
         default: break;
       }
@@ -515,22 +516,37 @@
     }
   #endif
 
-  #if HAS_DRIVER(TMC2208)
+  #if HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
     static void _tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
       switch (i) {
         case TMC_PWM_SCALE: SERIAL_PRINT(st.pwm_scale_sum(), DEC); break;
         case TMC_STEALTHCHOP: serialprint_truefalse(st.stealth()); break;
-        case TMC_S2VSA: if (st.s2vsa()) SERIAL_CHAR('X'); break;
-        case TMC_S2VSB: if (st.s2vsb()) SERIAL_CHAR('X'); break;
+        case TMC_S2VSA: if (st.s2vsa()) SERIAL_CHAR('*'); break;
+        case TMC_S2VSB: if (st.s2vsb()) SERIAL_CHAR('*'); break;
         default: break;
       }
     }
+
+    #if HAS_DRIVER(TMC2209)
+      template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+      static void _tmc_status(TMCMarlin<TMC2209Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const TMC_debug_enum i) {
+        switch (i) {
+          case TMC_SGT:       SERIAL_PRINT(st.SGTHRS(), DEC); break;
+          case TMC_UART_ADDR: SERIAL_PRINT(st.get_address(), DEC); break;
+          default:
+            TMC2208Stepper *parent = &st;
+            _tmc_status(*parent, i);
+            break;
+        }
+      }
+    #endif
+
     static void _tmc_parse_drv_status(TMC2208Stepper &st, const TMC_drv_status_enum i) {
       switch (i) {
-        case TMC_T157: if (st.t157()) SERIAL_CHAR('X'); break;
-        case TMC_T150: if (st.t150()) SERIAL_CHAR('X'); break;
-        case TMC_T143: if (st.t143()) SERIAL_CHAR('X'); break;
-        case TMC_T120: if (st.t120()) SERIAL_CHAR('X'); break;
+        case TMC_T157: if (st.t157()) SERIAL_CHAR('*'); break;
+        case TMC_T150: if (st.t150()) SERIAL_CHAR('*'); break;
+        case TMC_T143: if (st.t143()) SERIAL_CHAR('*'); break;
+        case TMC_T120: if (st.t120()) SERIAL_CHAR('*'); break;
         case TMC_DRV_CS_ACTUAL: SERIAL_PRINT(st.cs_actual(), DEC); break;
         default: break;
       }
@@ -620,13 +636,13 @@
     SERIAL_CHAR('\t');
     switch (i) {
       case TMC_DRV_CODES:     st.printLabel();  break;
-      case TMC_STST:          if (st.stst())         SERIAL_CHAR('X'); break;
-      case TMC_OLB:           if (st.olb())          SERIAL_CHAR('X'); break;
-      case TMC_OLA:           if (st.ola())          SERIAL_CHAR('X'); break;
-      case TMC_S2GB:          if (st.s2gb())         SERIAL_CHAR('X'); break;
-      case TMC_S2GA:          if (st.s2ga())         SERIAL_CHAR('X'); break;
-      case TMC_DRV_OTPW:      if (st.otpw())         SERIAL_CHAR('X'); break;
-      case TMC_OT:            if (st.ot())           SERIAL_CHAR('X'); break;
+      case TMC_STST:          if (st.stst())         SERIAL_CHAR('*'); break;
+      case TMC_OLB:           if (st.olb())          SERIAL_CHAR('*'); break;
+      case TMC_OLA:           if (st.ola())          SERIAL_CHAR('*'); break;
+      case TMC_S2GB:          if (st.s2gb())         SERIAL_CHAR('*'); break;
+      case TMC_S2GA:          if (st.s2ga())         SERIAL_CHAR('*'); break;
+      case TMC_DRV_OTPW:      if (st.otpw())         SERIAL_CHAR('*'); break;
+      case TMC_OT:            if (st.ot())           SERIAL_CHAR('*'); break;
       case TMC_DRV_STATUS_HEX: {
         const uint32_t drv_status = st.DRV_STATUS();
         SERIAL_CHAR('\t');
@@ -759,6 +775,9 @@
     #define TMC_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL);  tmc_debug_loop(ITEM, print_x, print_y, print_z, print_e); }while(0)
     #define DRV_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); drv_status_loop(ITEM, print_x, print_y, print_z, print_e); }while(0)
     TMC_REPORT("\t",                 TMC_CODES);
+    #if HAS_DRIVER(TMC2209)
+      TMC_REPORT("Address\t",        TMC_UART_ADDR);
+    #endif
     TMC_REPORT("Enabled\t",          TMC_ENABLED);
     TMC_REPORT("Set current",        TMC_CURRENT);
     TMC_REPORT("RMS current",        TMC_RMS_CURRENT);
@@ -770,7 +789,7 @@
     #endif
     TMC_REPORT("CS actual\t",        TMC_CS_ACTUAL);
     TMC_REPORT("PWM scale",          TMC_PWM_SCALE);
-    #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC2224) || HAS_DRIVER(TMC2660) || HAS_DRIVER(TMC2208)
+    #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC2224) || HAS_DRIVER(TMC2660) || HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
       TMC_REPORT("vsense\t",         TMC_VSENSE);
     #endif
     TMC_REPORT("stealthChop",        TMC_STEALTHCHOP);
@@ -802,7 +821,7 @@
     DRV_REPORT("s2ga\t",             TMC_S2GA);
     DRV_REPORT("otpw\t",             TMC_DRV_OTPW);
     DRV_REPORT("ot\t",               TMC_OT);
-    #if HAS_DRIVER(TMC2208)
+    #if HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
       DRV_REPORT("157C\t",           TMC_T157);
       DRV_REPORT("150C\t",           TMC_T150);
       DRV_REPORT("143C\t",           TMC_T143);
@@ -826,7 +845,7 @@
       }
     }
   #endif
-  #if HAS_DRIVER(TMC2208)
+  #if HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
     static void tmc_get_ic_registers(TMC2208Stepper, const TMC_get_registers_enum) { SERIAL_CHAR('\t'); }
   #endif
 
@@ -961,6 +980,15 @@
     st.en_pwm_mode(restore_stealth);
     st.diag1_stall(false);
   }
+
+  bool tmc_enable_stallguard(TMC2209Stepper &st) {
+    st.TCOOLTHRS(0xFFFFF);
+    return true;
+  }
+  void tmc_disable_stallguard(TMC2209Stepper &st, const bool restore_stealth) {
+    st.TCOOLTHRS(0);
+  }
+
   bool tmc_enable_stallguard(TMC2660Stepper) {
     // TODO
     return false;

commit dfdbd1e75f252ec6194c5ee9fa1703b71533d632
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jun 12 20:17:01 2019 -0500

    Use TEST macro where possible

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 886f963069..847310c210 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -95,38 +95,38 @@
         constexpr uint8_t STST_bp = 31;
       #endif
       TMC_driver_data data;
-      data.drv_status = st.DRV_STATUS();
+      const auto ds = data.drv_status = st.DRV_STATUS();
       #ifdef __AVR__
         // 8-bit optimization saves up to 70 bytes of PROGMEM per axis
         uint8_t spart;
         #if ENABLED(TMC_DEBUG)
-          data.sg_result = data.drv_status & SG_RESULT_bm;
-          spart = data.drv_status >> 8;
-          data.is_stealth = !!(spart & _BV(STEALTH_bp - 8));
-          spart = data.drv_status >> 16;
+          data.sg_result = ds & SG_RESULT_bm;
+          spart = ds >> 8;
+          data.is_stealth = TEST(spart, STEALTH_bp - 8);
+          spart = ds >> 16;
           data.cs_actual = spart & (CS_ACTUAL_bm >> 16);
         #endif
-        spart = data.drv_status >> 24;
-        data.is_ot = !!(spart & _BV(OT_bp - 24));
-        data.is_otpw = !!(spart & _BV(OTPW_bp - 24));
+        spart = ds >> 24;
+        data.is_ot = TEST(spart, OT_bp - 24);
+        data.is_otpw = TEST(spart, OTPW_bp - 24);
         data.is_s2g = !!(spart & (S2G_bm >> 24));
         #if ENABLED(TMC_DEBUG)
-          data.is_stall = !!(spart & _BV(STALL_GUARD_bp - 24));
-          data.is_standstill = !!(spart & _BV(STST_bp - 24));
+          data.is_stall = TEST(spart, STALL_GUARD_bp - 24);
+          data.is_standstill = TEST(spart, STST_bp - 24);
           data.sg_result_reasonable = !data.is_standstill; // sg_result has no reasonable meaning while standstill
         #endif
       #else // !__AVR__
 
-        data.is_ot = !!(data.drv_status & _BV(OT_bp));
-        data.is_otpw = !!(data.drv_status & _BV(OTPW_bp));
-        data.is_s2g = !!(data.drv_status & S2G_bm);
+        data.is_ot = TEST(ds, OT_bp);
+        data.is_otpw = TEST(ds, OTPW_bp);
+        data.is_s2g = !!(ds & S2G_bm);
         #if ENABLED(TMC_DEBUG)
           constexpr uint8_t CS_ACTUAL_sb = 16;
-          data.sg_result = data.drv_status & SG_RESULT_bm;
-          data.is_stealth = !!(data.drv_status & _BV(STEALTH_bp));
-          data.cs_actual = (data.drv_status & CS_ACTUAL_bm) >> CS_ACTUAL_sb;
-          data.is_stall = !!(data.drv_status & _BV(STALL_GUARD_bp));
-          data.is_standstill = !!(data.drv_status & _BV(STST_bp));
+          data.sg_result = ds & SG_RESULT_bm;
+          data.is_stealth = TEST(ds, STEALTH_bp);
+          data.cs_actual = (ds & CS_ACTUAL_bm) >> CS_ACTUAL_sb;
+          data.is_stall = TEST(ds, STALL_GUARD_bp);
+          data.is_standstill = TEST(ds, STST_bp);
           data.sg_result_reasonable = !data.is_standstill; // sg_result has no reasonable meaning while standstill
         #endif
 
@@ -147,25 +147,25 @@
       constexpr uint8_t OTPW_bp = 0, OT_bp = 1;
       constexpr uint8_t S2G_bm = 0b11110; // 2..5
       TMC_driver_data data;
-      data.drv_status = st.DRV_STATUS();
-      data.is_otpw = !!(data.drv_status & _BV(OTPW_bp));
-      data.is_ot = !!(data.drv_status & _BV(OT_bp));
-      data.is_s2g = !!(data.drv_status & S2G_bm);
+      const auto ds = data.drv_status = st.DRV_STATUS();
+      data.is_otpw = TEST(ds, OTPW_bp);
+      data.is_ot = TEST(ds, OT_bp);
+      data.is_s2g = !!(ds & S2G_bm);
       #if ENABLED(TMC_DEBUG)
         constexpr uint32_t CS_ACTUAL_bm = 0x1F0000; // 16:20
         constexpr uint8_t STEALTH_bp = 30, STST_bp = 31;
         #ifdef __AVR__
           // 8-bit optimization saves up to 12 bytes of PROGMEM per axis
-          uint8_t spart = data.drv_status >> 16;
+          uint8_t spart = ds >> 16;
           data.cs_actual = spart & (CS_ACTUAL_bm >> 16);
-          spart = data.drv_status >> 24;
-          data.is_stealth = !!(spart & _BV(STEALTH_bp - 24));
-          data.is_standstill = !!(spart & _BV(STST_bp - 24));
+          spart = ds >> 24;
+          data.is_stealth = TEST(spart, STEALTH_bp - 24);
+          data.is_standstill = TEST(spart, STST_bp - 24);
         #else
           constexpr uint8_t CS_ACTUAL_sb = 16;
-          data.cs_actual = (data.drv_status & CS_ACTUAL_bm) >> CS_ACTUAL_sb;
-          data.is_stealth = !!(data.drv_status & _BV(STEALTH_bp));
-          data.is_standstill = !!(data.drv_status & _BV(STST_bp));
+          data.cs_actual = (ds & CS_ACTUAL_bm) >> CS_ACTUAL_sb;
+          data.is_stealth = TEST(ds, STEALTH_bp);
+          data.is_standstill = TEST(ds, STST_bp);
         #endif
         #if HAS_STALLGUARD
           data.sg_result_reasonable = false;
@@ -186,18 +186,18 @@
       constexpr uint8_t OT_bp = 1, OTPW_bp = 2;
       constexpr uint8_t S2G_bm = 0b11000;
       TMC_driver_data data;
-      data.drv_status = st.DRVSTATUS();
-      uint8_t spart = data.drv_status & 0xFF;
-      data.is_otpw = !!(spart & _BV(OTPW_bp));
-      data.is_ot = !!(spart & _BV(OT_bp));
-      data.is_s2g = !!(data.drv_status & S2G_bm);
+      const auto ds = data.drv_status = st.DRVSTATUS();
+      uint8_t spart = ds & 0xFF;
+      data.is_otpw = TEST(spart, OTPW_bp);
+      data.is_ot = TEST(spart, OT_bp);
+      data.is_s2g = !!(ds & S2G_bm);
       #if ENABLED(TMC_DEBUG)
         constexpr uint8_t STALL_GUARD_bp = 0;
         constexpr uint8_t STST_bp = 7, SG_RESULT_sp = 10;
         constexpr uint32_t SG_RESULT_bm = 0xFFC00; // 10:19
-        data.is_stall = !!(spart & _BV(STALL_GUARD_bp));
-        data.is_standstill = !!(spart & _BV(STST_bp));
-        data.sg_result = (data.drv_status & SG_RESULT_bm) >> SG_RESULT_sp;
+        data.is_stall = TEST(spart, STALL_GUARD_bp);
+        data.is_standstill = TEST(spart, STST_bp);
+        data.sg_result = (ds & SG_RESULT_bm) >> SG_RESULT_sp;
         data.sg_result_reasonable = true;
       #endif
       return data;

commit bf4a0db97f6dc00b20afdb508a00b06c9ba46fa6
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Tue May 28 05:24:20 2019 +0300

    TMC LCD followup (#14134)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 50ed030a19..886f963069 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -565,24 +565,16 @@
       case TMC_VSENSE: print_vsense(st); break;
       case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
       case TMC_TSTEP: {
-          uint32_t tstep_value = st.TSTEP();
-          if (tstep_value == 0xFFFFF) SERIAL_ECHOPGM("max");
-          else SERIAL_ECHO(tstep_value);
-        }
-        break;
-      case TMC_TPWMTHRS: {
-          uint32_t tpwmthrs_val = st.TPWMTHRS();
-          SERIAL_ECHO(tpwmthrs_val);
-        }
-        break;
-      case TMC_TPWMTHRS_MMS: {
-          uint32_t tpwmthrs_val = st.get_pwm_thrs();
-          if (tpwmthrs_val)
-            SERIAL_ECHO(tpwmthrs_val);
-          else
-            SERIAL_CHAR('-');
-        }
-        break;
+        const uint32_t tstep_value = st.TSTEP();
+        if (tstep_value != 0xFFFFF) SERIAL_ECHO(tstep_value); else SERIAL_ECHOPGM("max");
+      } break;
+      #if ENABLED(HYBRID_THRESHOLD)
+        case TMC_TPWMTHRS: SERIAL_ECHO(uint32_t(st.TPWMTHRS())); break;
+        case TMC_TPWMTHRS_MMS: {
+          const uint32_t tpwmthrs_val = st.get_pwm_thrs();
+          if (tpwmthrs_val) SERIAL_ECHO(tpwmthrs_val); else SERIAL_CHAR('-');
+        } break;
+      #endif
       case TMC_OTPW: serialprint_truefalse(st.otpw()); break;
       #if ENABLED(MONITOR_DRIVER_STATUS)
         case TMC_OTPW_TRIGGERED: serialprint_truefalse(st.getOTPW()); break;

commit 1c86fbc60bad74957c872cbd6bc87900a3f127d8
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sun May 26 02:22:12 2019 +0300

    TMC updates, capture LCD changes (#14074)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 86f9222c58..50ed030a19 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -313,8 +313,6 @@
     #endif
   }
 
-  #define HAS_HW_COMMS(ST) AXIS_DRIVER_TYPE(ST, TMC2130) || AXIS_DRIVER_TYPE(ST, TMC2160) || AXIS_DRIVER_TYPE(ST, TMC2660) || AXIS_DRIVER_TYPE(ST, TMC5130) || AXIS_DRIVER_TYPE(ST, TMC5160) || (AXIS_DRIVER_TYPE(ST, TMC2208) && defined(ST##_HARDWARE_SERIAL))
-
   void monitor_tmc_driver() {
     static millis_t next_poll = 0;
     const millis_t ms = millis();
@@ -330,43 +328,43 @@
       }
     #endif
     if (need_update_error_counters || need_debug_reporting) {
-      #if HAS_HW_COMMS(X)
+      #if AXIS_IS_TMC(X)
         monitor_tmc_driver(stepperX, need_update_error_counters, need_debug_reporting);
       #endif
-      #if HAS_HW_COMMS(Y)
+      #if AXIS_IS_TMC(Y)
         monitor_tmc_driver(stepperY, need_update_error_counters, need_debug_reporting);
       #endif
-      #if HAS_HW_COMMS(Z)
+      #if AXIS_IS_TMC(Z)
         monitor_tmc_driver(stepperZ, need_update_error_counters, need_debug_reporting);
       #endif
-      #if HAS_HW_COMMS(X2)
+      #if AXIS_IS_TMC(X2)
         monitor_tmc_driver(stepperX2, need_update_error_counters, need_debug_reporting);
       #endif
-      #if HAS_HW_COMMS(Y2)
+      #if AXIS_IS_TMC(Y2)
         monitor_tmc_driver(stepperY2, need_update_error_counters, need_debug_reporting);
       #endif
-      #if HAS_HW_COMMS(Z2)
+      #if AXIS_IS_TMC(Z2)
         monitor_tmc_driver(stepperZ2, need_update_error_counters, need_debug_reporting);
       #endif
-      #if HAS_HW_COMMS(Z3)
+      #if AXIS_IS_TMC(Z3)
         monitor_tmc_driver(stepperZ3, need_update_error_counters, need_debug_reporting);
       #endif
-      #if HAS_HW_COMMS(E0)
+      #if AXIS_IS_TMC(E0)
         monitor_tmc_driver(stepperE0, need_update_error_counters, need_debug_reporting);
       #endif
-      #if HAS_HW_COMMS(E1)
+      #if AXIS_IS_TMC(E1)
         monitor_tmc_driver(stepperE1, need_update_error_counters, need_debug_reporting);
       #endif
-      #if HAS_HW_COMMS(E2)
+      #if AXIS_IS_TMC(E2)
         monitor_tmc_driver(stepperE2, need_update_error_counters, need_debug_reporting);
       #endif
-      #if HAS_HW_COMMS(E3)
+      #if AXIS_IS_TMC(E3)
         monitor_tmc_driver(stepperE3, need_update_error_counters, need_debug_reporting);
       #endif
-      #if HAS_HW_COMMS(E4)
+      #if AXIS_IS_TMC(E4)
         monitor_tmc_driver(stepperE4, need_update_error_counters, need_debug_reporting);
       #endif
-      #if HAS_HW_COMMS(E5)
+      #if AXIS_IS_TMC(E5)
         monitor_tmc_driver(stepperE5, need_update_error_counters, need_debug_reporting);
       #endif
 
@@ -471,8 +469,8 @@
   template<class TMC>
   static void print_vsense(TMC &st) { serialprintPGM(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); }
 
-  #if HAS_TMCX1X0
-    static void tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
+  #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC5130)
+    static void _tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
       switch (i) {
         case TMC_PWM_SCALE: SERIAL_PRINT(st.PWM_SCALE(), DEC); break;
         case TMC_SGT: SERIAL_PRINT(st.sgt(), DEC); break;
@@ -480,6 +478,8 @@
         default: break;
       }
     }
+  #endif
+  #if HAS_TMCX1X0
     static void _tmc_parse_drv_status(TMC2130Stepper &st, const TMC_drv_status_enum i) {
       switch (i) {
         case TMC_STALLGUARD: if (st.stallguard()) SERIAL_CHAR('X'); break;
@@ -492,10 +492,13 @@
   #endif
 
   #if HAS_DRIVER(TMC2160) || HAS_DRIVER(TMC5160)
-    template<char AXIS_LETTER, char DRIVER_ID> void print_vsense(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID> &st) { UNUSED(st); }
-    template<char AXIS_LETTER, char DRIVER_ID> void print_vsense(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID> &st) { UNUSED(st); }
+    template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+    void print_vsense(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &) { }
+
+    template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+    void print_vsense(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &) { }
 
-    static void tmc_status(TMC2160Stepper &st, const TMC_debug_enum i) {
+    static void _tmc_status(TMC2160Stepper &st, const TMC_debug_enum i) {
       switch (i) {
         case TMC_PWM_SCALE: SERIAL_PRINT(st.PWM_SCALE(), DEC); break;
         case TMC_SGT: SERIAL_PRINT(st.sgt(), DEC); break;
@@ -513,7 +516,7 @@
   #endif
 
   #if HAS_DRIVER(TMC2208)
-    static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
+    static void _tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
       switch (i) {
         case TMC_PWM_SCALE: SERIAL_PRINT(st.pwm_scale_sum(), DEC); break;
         case TMC_STEALTHCHOP: serialprint_truefalse(st.stealth()); break;
@@ -539,7 +542,7 @@
   #endif
 
   template <typename TMC>
-  static void tmc_status(TMC &st, const TMC_debug_enum i, const float spmm) {
+  static void tmc_status(TMC &st, const TMC_debug_enum i) {
     SERIAL_CHAR('\t');
     switch (i) {
       case TMC_CODES: st.printLabel(); break;
@@ -573,9 +576,9 @@
         }
         break;
       case TMC_TPWMTHRS_MMS: {
-          uint32_t tpwmthrs_val = st.TPWMTHRS();
+          uint32_t tpwmthrs_val = st.get_pwm_thrs();
           if (tpwmthrs_val)
-            SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm));
+            SERIAL_ECHO(tpwmthrs_val);
           else
             SERIAL_CHAR('-');
         }
@@ -588,13 +591,13 @@
       case TMC_TBL: SERIAL_PRINT(st.blank_time(), DEC); break;
       case TMC_HEND: SERIAL_PRINT(st.hysteresis_end(), DEC); break;
       case TMC_HSTRT: SERIAL_PRINT(st.hysteresis_start(), DEC); break;
-      default: tmc_status(st, i); break;
+      default: _tmc_status(st, i); break;
     }
   }
 
   #if HAS_DRIVER(TMC2660)
-    template<char AXIS_LETTER, char DRIVER_ID>
-    void tmc_status(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID> &st, const TMC_debug_enum i, const float) {
+    template<char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+    void tmc_status(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const TMC_debug_enum i) {
       SERIAL_CHAR('\t');
       switch (i) {
         case TMC_CODES: st.printLabel(); break;
@@ -649,72 +652,52 @@
   static void tmc_debug_loop(const TMC_debug_enum i, const bool print_x, const bool print_y, const bool print_z, const bool print_e) {
     if (print_x) {
       #if AXIS_IS_TMC(X)
-        tmc_status(stepperX, i, planner.settings.axis_steps_per_mm[X_AXIS]);
+        tmc_status(stepperX, i);
       #endif
       #if AXIS_IS_TMC(X2)
-        tmc_status(stepperX2, i, planner.settings.axis_steps_per_mm[X_AXIS]);
+        tmc_status(stepperX2, i);
       #endif
     }
 
     if (print_y) {
       #if AXIS_IS_TMC(Y)
-        tmc_status(stepperY, i, planner.settings.axis_steps_per_mm[Y_AXIS]);
+        tmc_status(stepperY, i);
       #endif
       #if AXIS_IS_TMC(Y2)
-        tmc_status(stepperY2, i, planner.settings.axis_steps_per_mm[Y_AXIS]);
+        tmc_status(stepperY2, i);
       #endif
     }
 
     if (print_z) {
       #if AXIS_IS_TMC(Z)
-        tmc_status(stepperZ, i, planner.settings.axis_steps_per_mm[Z_AXIS]);
+        tmc_status(stepperZ, i);
       #endif
       #if AXIS_IS_TMC(Z2)
-        tmc_status(stepperZ2, i, planner.settings.axis_steps_per_mm[Z_AXIS]);
+        tmc_status(stepperZ2, i);
       #endif
       #if AXIS_IS_TMC(Z3)
-        tmc_status(stepperZ3, i, planner.settings.axis_steps_per_mm[Z_AXIS]);
+        tmc_status(stepperZ3, i);
       #endif
     }
 
     if (print_e) {
       #if AXIS_IS_TMC(E0)
-        tmc_status(stepperE0, i, planner.settings.axis_steps_per_mm[E_AXIS]);
+        tmc_status(stepperE0, i);
       #endif
       #if AXIS_IS_TMC(E1)
-        tmc_status(stepperE1, i, planner.settings.axis_steps_per_mm[E_AXIS
-          #if ENABLED(DISTINCT_E_FACTORS)
-            + 1
-          #endif
-        ]);
+        tmc_status(stepperE1, i);
       #endif
       #if AXIS_IS_TMC(E2)
-        tmc_status(stepperE2, i, planner.settings.axis_steps_per_mm[E_AXIS
-          #if ENABLED(DISTINCT_E_FACTORS)
-            + 2
-          #endif
-        ]);
+        tmc_status(stepperE2, i);
       #endif
       #if AXIS_IS_TMC(E3)
-        tmc_status(stepperE3, i, planner.settings.axis_steps_per_mm[E_AXIS
-          #if ENABLED(DISTINCT_E_FACTORS)
-            + 3
-          #endif
-        ]);
+        tmc_status(stepperE3, i);
       #endif
       #if AXIS_IS_TMC(E4)
-        tmc_status(stepperE4, i, planner.settings.axis_steps_per_mm[E_AXIS
-          #if ENABLED(DISTINCT_E_FACTORS)
-            + 4
-          #endif
-        ]);
+        tmc_status(stepperE4, i);
       #endif
       #if AXIS_IS_TMC(E5)
-        tmc_status(stepperE5, i, planner.settings.axis_steps_per_mm[E_AXIS
-          #if ENABLED(DISTINCT_E_FACTORS)
-            + 5
-          #endif
-        ]);
+        tmc_status(stepperE5, i);
       #endif
     }
 
@@ -877,8 +860,8 @@
     }
   #endif
   #if HAS_DRIVER(TMC2660)
-    template <char AXIS_LETTER, char DRIVER_ID>
-    static void tmc_get_registers(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID> &st, const TMC_get_registers_enum i) {
+    template <char AXIS_LETTER, char DRIVER_ID, AxisEnum AXIS_ID>
+    static void tmc_get_registers(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID, AXIS_ID> &st, const TMC_get_registers_enum i) {
       switch (i) {
         case TMC_AXIS_CODES: SERIAL_CHAR('\t'); st.printLabel(); break;
         PRINT_TMC_REGISTER(DRVCONF);
@@ -1118,49 +1101,4 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
   if (axis_connection) ui.set_status_P(PSTR("TMC CONNECTION ERROR"));
 }
 
-#if HAS_LCD_MENU
-
-  void init_tmc_section() {
-    #if AXIS_IS_TMC(X)
-      stepperX.init_lcd_variables(X_AXIS);
-    #endif
-    #if AXIS_IS_TMC(Y)
-      stepperY.init_lcd_variables(Y_AXIS);
-    #endif
-    #if AXIS_IS_TMC(Z)
-      stepperZ.init_lcd_variables(Z_AXIS);
-    #endif
-    #if AXIS_IS_TMC(X2)
-      stepperX2.init_lcd_variables(X_AXIS);
-    #endif
-    #if AXIS_IS_TMC(Y2)
-      stepperY2.init_lcd_variables(Y_AXIS);
-    #endif
-    #if AXIS_IS_TMC(Z2)
-      stepperZ2.init_lcd_variables(Z_AXIS);
-    #endif
-    #if AXIS_IS_TMC(Z3)
-      stepperZ3.init_lcd_variables(Z_AXIS);
-    #endif
-    #if AXIS_IS_TMC(E0)
-      stepperE0.init_lcd_variables(E_AXIS);
-    #endif
-    #if AXIS_IS_TMC(E1)
-      stepperE1.init_lcd_variables(E_AXIS_N(1));
-    #endif
-    #if AXIS_IS_TMC(E2)
-      stepperE2.init_lcd_variables(E_AXIS_N(2));
-    #endif
-    #if AXIS_IS_TMC(E3)
-      stepperE3.init_lcd_variables(E_AXIS_N(3));
-    #endif
-    #if AXIS_IS_TMC(E4)
-      stepperE4.init_lcd_variables(E_AXIS_N(4));
-    #endif
-    #if AXIS_IS_TMC(E5)
-      stepperE5.init_lcd_variables(E_AXIS_N(5));
-    #endif
-  }
-#endif
-
 #endif // HAS_TRINAMIC

commit c837e9250c6ff91c54243ef7a72c1f02d6b26280
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Mon May 6 05:04:47 2019 +0200

    Define tmc variables where needed (#13918)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index d6abf9413e..86f9222c58 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -85,12 +85,15 @@
     #endif
 
     static TMC_driver_data get_driver_data(TMC2130Stepper &st) {
-      constexpr uint16_t SG_RESULT_bm = 0x3FF; // 0:9
-      constexpr uint8_t STEALTH_bp = 14, CS_ACTUAL_sb = 16;
-      constexpr uint32_t CS_ACTUAL_bm = 0x1F0000; // 16:20
-      constexpr uint8_t STALL_GUARD_bp = 24, OT_bp = 25, OTPW_bp = 26;
+      constexpr uint8_t OT_bp = 25, OTPW_bp = 26;
       constexpr uint32_t S2G_bm = 0x18000000;
-      constexpr uint8_t STST_bp = 31;
+      #if ENABLED(TMC_DEBUG)
+        constexpr uint16_t SG_RESULT_bm = 0x3FF; // 0:9
+        constexpr uint8_t STEALTH_bp = 14;
+        constexpr uint32_t CS_ACTUAL_bm = 0x1F0000; // 16:20
+        constexpr uint8_t STALL_GUARD_bp = 24;
+        constexpr uint8_t STST_bp = 31;
+      #endif
       TMC_driver_data data;
       data.drv_status = st.DRV_STATUS();
       #ifdef __AVR__
@@ -112,13 +115,13 @@
           data.is_standstill = !!(spart & _BV(STST_bp - 24));
           data.sg_result_reasonable = !data.is_standstill; // sg_result has no reasonable meaning while standstill
         #endif
-        UNUSED(CS_ACTUAL_sb);
       #else // !__AVR__
 
         data.is_ot = !!(data.drv_status & _BV(OT_bp));
         data.is_otpw = !!(data.drv_status & _BV(OTPW_bp));
         data.is_s2g = !!(data.drv_status & S2G_bm);
         #if ENABLED(TMC_DEBUG)
+          constexpr uint8_t CS_ACTUAL_sb = 16;
           data.sg_result = data.drv_status & SG_RESULT_bm;
           data.is_stealth = !!(data.drv_status & _BV(STEALTH_bp));
           data.cs_actual = (data.drv_status & CS_ACTUAL_bm) >> CS_ACTUAL_sb;
@@ -143,15 +146,14 @@
     static TMC_driver_data get_driver_data(TMC2208Stepper &st) {
       constexpr uint8_t OTPW_bp = 0, OT_bp = 1;
       constexpr uint8_t S2G_bm = 0b11110; // 2..5
-      constexpr uint8_t CS_ACTUAL_sb = 16;
-      constexpr uint32_t CS_ACTUAL_bm = 0x1F0000; // 16:20
-      constexpr uint8_t STEALTH_bp = 30, STST_bp = 31;
       TMC_driver_data data;
       data.drv_status = st.DRV_STATUS();
       data.is_otpw = !!(data.drv_status & _BV(OTPW_bp));
       data.is_ot = !!(data.drv_status & _BV(OT_bp));
       data.is_s2g = !!(data.drv_status & S2G_bm);
       #if ENABLED(TMC_DEBUG)
+        constexpr uint32_t CS_ACTUAL_bm = 0x1F0000; // 16:20
+        constexpr uint8_t STEALTH_bp = 30, STST_bp = 31;
         #ifdef __AVR__
           // 8-bit optimization saves up to 12 bytes of PROGMEM per axis
           uint8_t spart = data.drv_status >> 16;
@@ -159,8 +161,8 @@
           spart = data.drv_status >> 24;
           data.is_stealth = !!(spart & _BV(STEALTH_bp - 24));
           data.is_standstill = !!(spart & _BV(STST_bp - 24));
-          UNUSED(CS_ACTUAL_sb);
         #else
+          constexpr uint8_t CS_ACTUAL_sb = 16;
           data.cs_actual = (data.drv_status & CS_ACTUAL_bm) >> CS_ACTUAL_sb;
           data.is_stealth = !!(data.drv_status & _BV(STEALTH_bp));
           data.is_standstill = !!(data.drv_status & _BV(STST_bp));
@@ -181,11 +183,8 @@
     #endif
 
     static TMC_driver_data get_driver_data(TMC2660Stepper &st) {
-      constexpr uint8_t STALL_GUARD_bp = 0;
       constexpr uint8_t OT_bp = 1, OTPW_bp = 2;
       constexpr uint8_t S2G_bm = 0b11000;
-      constexpr uint8_t STST_bp = 7, SG_RESULT_sp = 10;
-      constexpr uint32_t SG_RESULT_bm = 0xFFC00; // 10:19
       TMC_driver_data data;
       data.drv_status = st.DRVSTATUS();
       uint8_t spart = data.drv_status & 0xFF;
@@ -193,6 +192,9 @@
       data.is_ot = !!(spart & _BV(OT_bp));
       data.is_s2g = !!(data.drv_status & S2G_bm);
       #if ENABLED(TMC_DEBUG)
+        constexpr uint8_t STALL_GUARD_bp = 0;
+        constexpr uint8_t STST_bp = 7, SG_RESULT_sp = 10;
+        constexpr uint32_t SG_RESULT_bm = 0xFFC00; // 10:19
         data.is_stall = !!(spart & _BV(STALL_GUARD_bp));
         data.is_standstill = !!(spart & _BV(STST_bp));
         data.sg_result = (data.drv_status & SG_RESULT_bm) >> SG_RESULT_sp;

commit ee73e17c9b3b2b4d24cc02d9f0b7e29ca69bfd67
Author: kAdonis <35379348+kAdonis@users.noreply.github.com>
Date:   Sun May 5 05:00:24 2019 +0200

    Hide 'vsense' report row if not used (#13884)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index ff477818fe..d6abf9413e 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -793,7 +793,9 @@
     #endif
     TMC_REPORT("CS actual\t",        TMC_CS_ACTUAL);
     TMC_REPORT("PWM scale",          TMC_PWM_SCALE);
-    TMC_REPORT("vsense\t",           TMC_VSENSE);
+    #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC2224) || HAS_DRIVER(TMC2660) || HAS_DRIVER(TMC2208)
+      TMC_REPORT("vsense\t",         TMC_VSENSE);
+    #endif
     TMC_REPORT("stealthChop",        TMC_STEALTHCHOP);
     TMC_REPORT("msteps\t",           TMC_MICROSTEPS);
     TMC_REPORT("tstep\t",            TMC_TSTEP);

commit cf12fc8366f2ffbc3811173769d5428236af0dd9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 5 20:02:46 2019 -0500

    Expand on serial debugging (#13577)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index ee28f70633..ff477818fe 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -474,7 +474,7 @@
       switch (i) {
         case TMC_PWM_SCALE: SERIAL_PRINT(st.PWM_SCALE(), DEC); break;
         case TMC_SGT: SERIAL_PRINT(st.sgt(), DEC); break;
-        case TMC_STEALTHCHOP: serialprintPGM(st.en_pwm_mode() ? PSTR("true") : PSTR("false")); break;
+        case TMC_STEALTHCHOP: serialprint_truefalse(st.en_pwm_mode()); break;
         default: break;
       }
     }
@@ -497,7 +497,7 @@
       switch (i) {
         case TMC_PWM_SCALE: SERIAL_PRINT(st.PWM_SCALE(), DEC); break;
         case TMC_SGT: SERIAL_PRINT(st.sgt(), DEC); break;
-        case TMC_STEALTHCHOP: serialprintPGM(st.en_pwm_mode() ? PSTR("true") : PSTR("false")); break;
+        case TMC_STEALTHCHOP: serialprint_truefalse(st.en_pwm_mode()); break;
         case TMC_GLOBAL_SCALER:
           {
             uint16_t value = st.GLOBAL_SCALER();
@@ -514,7 +514,7 @@
     static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
       switch (i) {
         case TMC_PWM_SCALE: SERIAL_PRINT(st.pwm_scale_sum(), DEC); break;
-        case TMC_STEALTHCHOP: serialprintPGM(st.stealth() ? PSTR("true") : PSTR("false")); break;
+        case TMC_STEALTHCHOP: serialprint_truefalse(st.stealth()); break;
         case TMC_S2VSA: if (st.s2vsa()) SERIAL_CHAR('X'); break;
         case TMC_S2VSB: if (st.s2vsb()) SERIAL_CHAR('X'); break;
         default: break;
@@ -541,7 +541,7 @@
     SERIAL_CHAR('\t');
     switch (i) {
       case TMC_CODES: st.printLabel(); break;
-      case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
+      case TMC_ENABLED: serialprint_truefalse(st.isEnabled()); break;
       case TMC_CURRENT: SERIAL_ECHO(st.getMilliamps()); break;
       case TMC_RMS_CURRENT: SERIAL_ECHO(st.rms_current()); break;
       case TMC_MAX_CURRENT: SERIAL_PRINT((float)st.rms_current() * 1.41, 0); break;
@@ -578,9 +578,9 @@
             SERIAL_CHAR('-');
         }
         break;
-      case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;
+      case TMC_OTPW: serialprint_truefalse(st.otpw()); break;
       #if ENABLED(MONITOR_DRIVER_STATUS)
-        case TMC_OTPW_TRIGGERED: serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false")); break;
+        case TMC_OTPW_TRIGGERED: serialprint_truefalse(st.getOTPW()); break;
       #endif
       case TMC_TOFF: SERIAL_PRINT(st.toff(), DEC); break;
       case TMC_TBL: SERIAL_PRINT(st.blank_time(), DEC); break;
@@ -596,7 +596,7 @@
       SERIAL_CHAR('\t');
       switch (i) {
         case TMC_CODES: st.printLabel(); break;
-        case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
+        case TMC_ENABLED: serialprint_truefalse(st.isEnabled()); break;
         case TMC_CURRENT: SERIAL_ECHO(st.getMilliamps()); break;
         case TMC_RMS_CURRENT: SERIAL_ECHO(st.rms_current()); break;
         case TMC_MAX_CURRENT: SERIAL_PRINT((float)st.rms_current() * 1.41, 0); break;
@@ -606,8 +606,8 @@
           break;
         case TMC_VSENSE: serialprintPGM(st.vsense() ? PSTR("1=.165") : PSTR("0=.310")); break;
         case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
-        //case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;
-        //case TMC_OTPW_TRIGGERED: serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false")); break;
+        //case TMC_OTPW: serialprint_truefalse(st.otpw()); break;
+        //case TMC_OTPW_TRIGGERED: serialprint_truefalse(st.getOTPW()); break;
         case TMC_SGT: SERIAL_PRINT(st.sgt(), DEC); break;
         case TMC_TOFF: SERIAL_PRINT(st.toff(), DEC); break;
         case TMC_TBL: SERIAL_PRINT(st.blank_time(), DEC); break;

commit bd4160dbafbd2be4d7e77f701793611710b9a8e1
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sun Mar 3 00:30:30 2019 +0100

    Unused CS_ACTUAL_sb (#13282)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index ac956ad177..ee28f70633 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -112,7 +112,7 @@
           data.is_standstill = !!(spart & _BV(STST_bp - 24));
           data.sg_result_reasonable = !data.is_standstill; // sg_result has no reasonable meaning while standstill
         #endif
-
+        UNUSED(CS_ACTUAL_sb);
       #else // !__AVR__
 
         data.is_ot = !!(data.drv_status & _BV(OT_bp));
@@ -159,6 +159,7 @@
           spart = data.drv_status >> 24;
           data.is_stealth = !!(spart & _BV(STEALTH_bp - 24));
           data.is_standstill = !!(spart & _BV(STST_bp - 24));
+          UNUSED(CS_ACTUAL_sb);
         #else
           data.cs_actual = (data.drv_status & CS_ACTUAL_bm) >> CS_ACTUAL_sb;
           data.is_stealth = !!(data.drv_status & _BV(STEALTH_bp));

commit ba39186364b69f7399f33b7ddb1115db42c6eabc
Author: LinFor <linfor@gmail.com>
Date:   Wed Feb 20 11:22:42 2019 +0300

    TMC_DEBUG optimization and improvements (#13135)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index f344e95cfe..ac956ad177 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -36,7 +36,7 @@
   #include "../module/planner.h"
   #include "../libs/hex_print_routines.h"
   #if ENABLED(MONITOR_DRIVER_STATUS)
-    static bool report_tmc_status; // = false;
+    static uint16_t report_tmc_status_interval; // = 0
   #endif
 #endif
 
@@ -55,87 +55,159 @@
 
   struct TMC_driver_data {
     uint32_t drv_status;
-    bool is_otpw,
-         is_ot,
-         is_s2ga,
-         is_s2gb,
-         is_error;
+    bool is_otpw:1,
+         is_ot:1,
+         is_s2g:1,
+         is_error:1
+         #if ENABLED(TMC_DEBUG)
+           , is_stall:1
+           , is_stealth:1
+           , is_standstill:1
+          #if HAS_STALLGUARD
+           , sg_result_reasonable:1
+          #endif
+         #endif
+      ;
+    #if ENABLED(TMC_DEBUG)
+      #if HAS_TMCX1X0 || HAS_DRIVER(TMC2208)
+        uint8_t cs_actual;
+      #endif
+      #if HAS_STALLGUARD
+        uint16_t sg_result;
+      #endif
+    #endif
   };
-  #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC2160) || HAS_DRIVER(TMC5130) || HAS_DRIVER(TMC5160)
+
+  #if HAS_TMCX1X0
+
     #if ENABLED(TMC_DEBUG)
       static uint32_t get_pwm_scale(TMC2130Stepper &st) { return st.PWM_SCALE(); }
-      static uint8_t get_status_response(TMC2130Stepper &st, uint32_t) { return st.status_response & 0xF; }
     #endif
+
     static TMC_driver_data get_driver_data(TMC2130Stepper &st) {
-      constexpr uint32_t OTPW_bm = 0x4000000UL;
-      constexpr uint8_t OTPW_bp = 26;
-      constexpr uint32_t OT_bm = 0x2000000UL;
-      constexpr uint8_t OT_bp = 25;
-      constexpr uint8_t S2GA_bp = 27;
-      constexpr uint8_t S2GB_bp = 28;
+      constexpr uint16_t SG_RESULT_bm = 0x3FF; // 0:9
+      constexpr uint8_t STEALTH_bp = 14, CS_ACTUAL_sb = 16;
+      constexpr uint32_t CS_ACTUAL_bm = 0x1F0000; // 16:20
+      constexpr uint8_t STALL_GUARD_bp = 24, OT_bp = 25, OTPW_bp = 26;
+      constexpr uint32_t S2G_bm = 0x18000000;
+      constexpr uint8_t STST_bp = 31;
       TMC_driver_data data;
       data.drv_status = st.DRV_STATUS();
-      data.is_otpw = (data.drv_status & OTPW_bm) >> OTPW_bp;
-      data.is_ot = (data.drv_status & OT_bm) >> OT_bp;
-      data.is_s2ga = (data.drv_status >> S2GA_bp) & 0b1;
-      data.is_s2gb = (data.drv_status >> S2GB_bp) & 0b1;
+      #ifdef __AVR__
+        // 8-bit optimization saves up to 70 bytes of PROGMEM per axis
+        uint8_t spart;
+        #if ENABLED(TMC_DEBUG)
+          data.sg_result = data.drv_status & SG_RESULT_bm;
+          spart = data.drv_status >> 8;
+          data.is_stealth = !!(spart & _BV(STEALTH_bp - 8));
+          spart = data.drv_status >> 16;
+          data.cs_actual = spart & (CS_ACTUAL_bm >> 16);
+        #endif
+        spart = data.drv_status >> 24;
+        data.is_ot = !!(spart & _BV(OT_bp - 24));
+        data.is_otpw = !!(spart & _BV(OTPW_bp - 24));
+        data.is_s2g = !!(spart & (S2G_bm >> 24));
+        #if ENABLED(TMC_DEBUG)
+          data.is_stall = !!(spart & _BV(STALL_GUARD_bp - 24));
+          data.is_standstill = !!(spart & _BV(STST_bp - 24));
+          data.sg_result_reasonable = !data.is_standstill; // sg_result has no reasonable meaning while standstill
+        #endif
+
+      #else // !__AVR__
+
+        data.is_ot = !!(data.drv_status & _BV(OT_bp));
+        data.is_otpw = !!(data.drv_status & _BV(OTPW_bp));
+        data.is_s2g = !!(data.drv_status & S2G_bm);
+        #if ENABLED(TMC_DEBUG)
+          data.sg_result = data.drv_status & SG_RESULT_bm;
+          data.is_stealth = !!(data.drv_status & _BV(STEALTH_bp));
+          data.cs_actual = (data.drv_status & CS_ACTUAL_bm) >> CS_ACTUAL_sb;
+          data.is_stall = !!(data.drv_status & _BV(STALL_GUARD_bp));
+          data.is_standstill = !!(data.drv_status & _BV(STST_bp));
+          data.sg_result_reasonable = !data.is_standstill; // sg_result has no reasonable meaning while standstill
+        #endif
+
+      #endif // !__AVR__
+
       return data;
     }
-  #endif
+
+  #endif // HAS_TMCX1X0
+
   #if HAS_DRIVER(TMC2208)
+
     #if ENABLED(TMC_DEBUG)
       static uint32_t get_pwm_scale(TMC2208Stepper &st) { return st.pwm_scale_sum(); }
-      static uint8_t get_status_response(TMC2208Stepper &st, uint32_t drv_status) {
-        uint8_t gstat = st.GSTAT();
-        uint8_t response = 0;
-        response |= (drv_status >> (31 - 3)) & 0b1000;
-        response |= gstat & 0b11;
-        return response;
-      }
     #endif
+
     static TMC_driver_data get_driver_data(TMC2208Stepper &st) {
-      constexpr uint32_t OTPW_bm = 0b1ul;
-      constexpr uint8_t OTPW_bp = 0;
-      constexpr uint32_t OT_bm = 0b10ul;
-      constexpr uint8_t OT_bp = 1;
-      constexpr uint8_t S2GA_bp = 2;
-      constexpr uint8_t S2GB_bp = 3;
+      constexpr uint8_t OTPW_bp = 0, OT_bp = 1;
+      constexpr uint8_t S2G_bm = 0b11110; // 2..5
+      constexpr uint8_t CS_ACTUAL_sb = 16;
+      constexpr uint32_t CS_ACTUAL_bm = 0x1F0000; // 16:20
+      constexpr uint8_t STEALTH_bp = 30, STST_bp = 31;
       TMC_driver_data data;
       data.drv_status = st.DRV_STATUS();
-      data.is_otpw = (data.drv_status & OTPW_bm) >> OTPW_bp;
-      data.is_ot = (data.drv_status & OT_bm) >> OT_bp;
-      data.is_s2ga = (data.drv_status >> S2GA_bp) & 0b1;
-      data.is_s2gb = (data.drv_status >> S2GB_bp) & 0b1;
+      data.is_otpw = !!(data.drv_status & _BV(OTPW_bp));
+      data.is_ot = !!(data.drv_status & _BV(OT_bp));
+      data.is_s2g = !!(data.drv_status & S2G_bm);
+      #if ENABLED(TMC_DEBUG)
+        #ifdef __AVR__
+          // 8-bit optimization saves up to 12 bytes of PROGMEM per axis
+          uint8_t spart = data.drv_status >> 16;
+          data.cs_actual = spart & (CS_ACTUAL_bm >> 16);
+          spart = data.drv_status >> 24;
+          data.is_stealth = !!(spart & _BV(STEALTH_bp - 24));
+          data.is_standstill = !!(spart & _BV(STST_bp - 24));
+        #else
+          data.cs_actual = (data.drv_status & CS_ACTUAL_bm) >> CS_ACTUAL_sb;
+          data.is_stealth = !!(data.drv_status & _BV(STEALTH_bp));
+          data.is_standstill = !!(data.drv_status & _BV(STST_bp));
+        #endif
+        #if HAS_STALLGUARD
+          data.sg_result_reasonable = false;
+        #endif
+      #endif
       return data;
     }
-  #endif
+
+  #endif // TMC2208
+
   #if HAS_DRIVER(TMC2660)
+
     #if ENABLED(TMC_DEBUG)
       static uint32_t get_pwm_scale(TMC2660Stepper) { return 0; }
-      static uint8_t get_status_response(TMC2660Stepper, uint32_t drv_status) {
-        return drv_status & 0xFF;
-      }
     #endif
+
     static TMC_driver_data get_driver_data(TMC2660Stepper &st) {
-      constexpr uint32_t OTPW_bm = 0x4UL;
-      constexpr uint8_t OTPW_bp = 2;
-      constexpr uint32_t OT_bm = 0x2UL;
-      constexpr uint8_t OT_bp = 1;
+      constexpr uint8_t STALL_GUARD_bp = 0;
+      constexpr uint8_t OT_bp = 1, OTPW_bp = 2;
+      constexpr uint8_t S2G_bm = 0b11000;
+      constexpr uint8_t STST_bp = 7, SG_RESULT_sp = 10;
+      constexpr uint32_t SG_RESULT_bm = 0xFFC00; // 10:19
       TMC_driver_data data;
       data.drv_status = st.DRVSTATUS();
-      data.is_otpw = (data.drv_status & OTPW_bm) >> OTPW_bp;
-      data.is_ot = (data.drv_status & OT_bm) >> OT_bp;
+      uint8_t spart = data.drv_status & 0xFF;
+      data.is_otpw = !!(spart & _BV(OTPW_bp));
+      data.is_ot = !!(spart & _BV(OT_bp));
+      data.is_s2g = !!(data.drv_status & S2G_bm);
+      #if ENABLED(TMC_DEBUG)
+        data.is_stall = !!(spart & _BV(STALL_GUARD_bp));
+        data.is_standstill = !!(spart & _BV(STST_bp));
+        data.sg_result = (data.drv_status & SG_RESULT_bm) >> SG_RESULT_sp;
+        data.sg_result_reasonable = true;
+      #endif
       return data;
     }
-  #endif
+
+  #endif // TMC2660
 
   #if ENABLED(STOP_ON_ERROR)
     void report_driver_error(const TMC_driver_data &data) {
       SERIAL_ECHOPGM(" driver error detected: 0x");
       SERIAL_PRINTLN(data.drv_status, HEX);
       if (data.is_ot) SERIAL_ECHOLNPGM("overtemperature");
-      if (data.is_s2ga) SERIAL_ECHOLNPGM("short to ground (coil A)");
-      if (data.is_s2gb) SERIAL_ECHOLNPGM("short to ground (coil B)");
+      if (data.is_s2g) SERIAL_ECHOLNPGM("coil short circuit");
       #if ENABLED(TMC_DEBUG)
         tmc_report_all(true, true, true, true);
       #endif
@@ -162,61 +234,79 @@
   void report_polled_driver_data(TMC &st, const TMC_driver_data &data) {
     const uint32_t pwm_scale = get_pwm_scale(st);
     st.printLabel();
-    SERIAL_ECHOPAIR(":", pwm_scale);
-    SERIAL_ECHOPGM(" |0b"); SERIAL_PRINT(get_status_response(st, data.drv_status), BIN);
-    SERIAL_ECHOPGM("| ");
-    if (st.error_count) SERIAL_CHAR('E');
-    else if (data.is_ot) SERIAL_CHAR('O');
-    else if (data.is_otpw) SERIAL_CHAR('W');
-    else if (st.otpw_count > 0) SERIAL_PRINT(st.otpw_count, DEC);
-    else if (st.flag_otpw) SERIAL_CHAR('F');
+    SERIAL_CHAR(':'); SERIAL_PRINT(pwm_scale, DEC);
+    #if ENABLED(TMC_DEBUG)
+      #if HAS_TMCX1X0 || HAS_DRIVER(TMC2208)
+        SERIAL_CHAR('/'); SERIAL_PRINT(data.cs_actual, DEC);
+      #endif
+      #if HAS_STALLGUARD
+        SERIAL_CHAR('/');
+        if (data.sg_result_reasonable)
+          SERIAL_ECHO(data.sg_result);
+        else
+          SERIAL_CHAR('-');
+      #endif
+    #endif
+    SERIAL_CHAR('|');
+    if (st.error_count)       SERIAL_CHAR('E'); // Error
+    if (data.is_ot)           SERIAL_CHAR('O'); // Over-temperature
+    if (data.is_otpw)         SERIAL_CHAR('W'); // over-temperature pre-Warning
+    #if ENABLED(TMC_DEBUG)
+      if (data.is_stall)      SERIAL_CHAR('G'); // stallGuard
+      if (data.is_stealth)    SERIAL_CHAR('T'); // stealthChop
+      if (data.is_standstill) SERIAL_CHAR('I'); // standstIll
+    #endif
+    if (st.flag_otpw)         SERIAL_CHAR('F'); // otpw Flag
+    SERIAL_CHAR('|');
+    if (st.otpw_count > 0) SERIAL_PRINT(st.otpw_count, DEC);
     SERIAL_CHAR('\t');
   }
 
   template<typename TMC>
-  void monitor_tmc_driver(TMC &st) {
+  void monitor_tmc_driver(TMC &st, const bool need_update_error_counters, const bool need_debug_reporting) {
     TMC_driver_data data = get_driver_data(st);
-    if ((data.drv_status == 0xFFFFFFFF) || (data.drv_status == 0x0)) return;
+    if (data.drv_status == 0xFFFFFFFF || data.drv_status == 0x0) return;
 
-    if (data.is_ot /* | data.s2ga | data.s2gb*/) st.error_count++;
-    else if (st.error_count > 0) st.error_count--;
+    if (need_update_error_counters) {
+      if (data.is_ot /* | data.s2ga | data.s2gb*/) st.error_count++;
+      else if (st.error_count > 0) st.error_count--;
 
-    #if ENABLED(STOP_ON_ERROR)
-      if (st.error_count >= 10) {
-        SERIAL_EOL();
-        st.printLabel();
-        report_driver_error(data);
-      }
-    #endif
+      #if ENABLED(STOP_ON_ERROR)
+        if (st.error_count >= 10) {
+          SERIAL_EOL();
+          st.printLabel();
+          report_driver_error(data);
+        }
+      #endif
 
-    // Report if a warning was triggered
-    if (data.is_otpw && st.otpw_count == 0) {
-      report_driver_otpw(st);
-    }
-    #if CURRENT_STEP_DOWN > 0
-      // Decrease current if is_otpw is true and driver is enabled and there's been more than 4 warnings
-      if (data.is_otpw && st.otpw_count > 4) {
-        uint16_t I_rms = st.getMilliamps();
-        if (st.isEnabled() && I_rms > 100) {
-          st.rms_current(I_rms - (CURRENT_STEP_DOWN));
-          #if ENABLED(REPORT_CURRENT_CHANGE)
-            st.printLabel();
-            SERIAL_ECHOLNPAIR(" current decreased to ", st.getMilliamps());
-          #endif
+      // Report if a warning was triggered
+      if (data.is_otpw && st.otpw_count == 0)
+        report_driver_otpw(st);
+
+      #if CURRENT_STEP_DOWN > 0
+        // Decrease current if is_otpw is true and driver is enabled and there's been more than 4 warnings
+        if (data.is_otpw && st.otpw_count > 4) {
+          uint16_t I_rms = st.getMilliamps();
+          if (st.isEnabled() && I_rms > 100) {
+            st.rms_current(I_rms - (CURRENT_STEP_DOWN));
+            #if ENABLED(REPORT_CURRENT_CHANGE)
+              st.printLabel();
+              SERIAL_ECHOLNPAIR(" current decreased to ", st.getMilliamps());
+            #endif
+          }
         }
-      }
-    #endif
+      #endif
 
-    if (data.is_otpw) {
-      st.otpw_count++;
-      st.flag_otpw = true;
+      if (data.is_otpw) {
+        st.otpw_count++;
+        st.flag_otpw = true;
+      }
+      else if (st.otpw_count > 0) st.otpw_count = 0;
     }
-    else if (st.otpw_count > 0) st.otpw_count = 0;
 
     #if ENABLED(TMC_DEBUG)
-      if (report_tmc_status) {
+      if (need_debug_reporting)
         report_polled_driver_data(st, data);
-      }
     #endif
   }
 
@@ -225,50 +315,60 @@
   void monitor_tmc_driver() {
     static millis_t next_poll = 0;
     const millis_t ms = millis();
-    if (ELAPSED(ms, next_poll)) {
-      next_poll = ms + 500;
+    bool need_update_error_counters = ELAPSED(ms, next_poll);
+    bool need_debug_reporting = false;
+    if (need_update_error_counters)
+      next_poll = ms + MONITOR_DRIVER_STATUS_INTERVAL_MS;
+    #if ENABLED(TMC_DEBUG)
+      static millis_t next_debug_reporting = 0;
+      if (report_tmc_status_interval && ELAPSED(ms, next_debug_reporting)) {
+        need_debug_reporting = true;
+        next_debug_reporting = ms + report_tmc_status_interval;
+      }
+    #endif
+    if (need_update_error_counters || need_debug_reporting) {
       #if HAS_HW_COMMS(X)
-        monitor_tmc_driver(stepperX);
+        monitor_tmc_driver(stepperX, need_update_error_counters, need_debug_reporting);
       #endif
       #if HAS_HW_COMMS(Y)
-        monitor_tmc_driver(stepperY);
+        monitor_tmc_driver(stepperY, need_update_error_counters, need_debug_reporting);
       #endif
       #if HAS_HW_COMMS(Z)
-        monitor_tmc_driver(stepperZ);
+        monitor_tmc_driver(stepperZ, need_update_error_counters, need_debug_reporting);
       #endif
       #if HAS_HW_COMMS(X2)
-        monitor_tmc_driver(stepperX2);
+        monitor_tmc_driver(stepperX2, need_update_error_counters, need_debug_reporting);
       #endif
       #if HAS_HW_COMMS(Y2)
-        monitor_tmc_driver(stepperY2);
+        monitor_tmc_driver(stepperY2, need_update_error_counters, need_debug_reporting);
       #endif
       #if HAS_HW_COMMS(Z2)
-        monitor_tmc_driver(stepperZ2);
+        monitor_tmc_driver(stepperZ2, need_update_error_counters, need_debug_reporting);
       #endif
       #if HAS_HW_COMMS(Z3)
-        monitor_tmc_driver(stepperZ3);
+        monitor_tmc_driver(stepperZ3, need_update_error_counters, need_debug_reporting);
       #endif
       #if HAS_HW_COMMS(E0)
-        monitor_tmc_driver(stepperE0);
+        monitor_tmc_driver(stepperE0, need_update_error_counters, need_debug_reporting);
       #endif
       #if HAS_HW_COMMS(E1)
-        monitor_tmc_driver(stepperE1);
+        monitor_tmc_driver(stepperE1, need_update_error_counters, need_debug_reporting);
       #endif
       #if HAS_HW_COMMS(E2)
-        monitor_tmc_driver(stepperE2);
+        monitor_tmc_driver(stepperE2, need_update_error_counters, need_debug_reporting);
       #endif
       #if HAS_HW_COMMS(E3)
-        monitor_tmc_driver(stepperE3);
+        monitor_tmc_driver(stepperE3, need_update_error_counters, need_debug_reporting);
       #endif
       #if HAS_HW_COMMS(E4)
-        monitor_tmc_driver(stepperE4);
+        monitor_tmc_driver(stepperE4, need_update_error_counters, need_debug_reporting);
       #endif
       #if HAS_HW_COMMS(E5)
-        monitor_tmc_driver(stepperE5);
+        monitor_tmc_driver(stepperE5, need_update_error_counters, need_debug_reporting);
       #endif
 
       #if ENABLED(TMC_DEBUG)
-        if (report_tmc_status) SERIAL_EOL();
+        if (need_debug_reporting) SERIAL_EOL();
       #endif
     }
   }
@@ -278,12 +378,20 @@
 #if ENABLED(TMC_DEBUG)
 
   /**
-   * M122 S[1,0] Enable periodic status reports
+   * M122 [S<0|1>] [Pnnn] Enable periodic status reports
    */
   #if ENABLED(MONITOR_DRIVER_STATUS)
-    void tmc_set_report_status(const bool status) {
-      if ((report_tmc_status = status))
-        SERIAL_ECHOLNPGM("axis:pwm_scale |status_response|");
+    void tmc_set_report_interval(const uint16_t update_interval) {
+      if ((report_tmc_status_interval = update_interval))
+        SERIAL_ECHOLNPGM("axis:pwm_scale"
+          #if HAS_STEALTHCHOP
+            "/current_scale"
+          #endif
+          #if HAS_STALLGUARD
+            "/mech_load"
+          #endif
+          "|flags|warncount"
+        );
     }
   #endif
 
@@ -360,7 +468,7 @@
   template<class TMC>
   static void print_vsense(TMC &st) { serialprintPGM(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); }
 
-  #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC2160) || HAS_DRIVER(TMC5130) || HAS_DRIVER(TMC5160)
+  #if HAS_TMCX1X0
     static void tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
       switch (i) {
         case TMC_PWM_SCALE: SERIAL_PRINT(st.PWM_SCALE(), DEC); break;
@@ -702,7 +810,7 @@
     TMC_REPORT("Stallguard thrs",    TMC_SGT);
 
     DRV_REPORT("DRVSTATUS",          TMC_DRV_CODES);
-    #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC2160) || HAS_DRIVER(TMC5130) || HAS_DRIVER(TMC5160)
+    #if HAS_TMCX1X0
       DRV_REPORT("stallguard\t",     TMC_STALLGUARD);
       DRV_REPORT("sg_result\t",      TMC_SG_RESULT);
       DRV_REPORT("fsactive\t",       TMC_FSACTIVE);
@@ -728,7 +836,7 @@
 
   #define PRINT_TMC_REGISTER(REG_CASE) case TMC_GET_##REG_CASE: print_hex_long(st.REG_CASE(), ':'); break
 
-  #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC2160) || HAS_DRIVER(TMC5130) || HAS_DRIVER(TMC5160)
+  #if HAS_TMCX1X0
     static void tmc_get_ic_registers(TMC2130Stepper &st, const TMC_get_registers_enum i) {
       switch (i) {
         PRINT_TMC_REGISTER(TCOOLTHRS);

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 46b7c19dd0..f344e95cfe 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit d81342254a1fb8b12ce7d86cde574d7d96cc9871
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Wed Feb 6 14:33:14 2019 +0200

    Support new TMC drivers (#13026)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index cba1d7e329..46b7c19dd0 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -61,7 +61,7 @@
          is_s2gb,
          is_error;
   };
-  #if HAS_DRIVER(TMC2130)
+  #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC2160) || HAS_DRIVER(TMC5130) || HAS_DRIVER(TMC5160)
     #if ENABLED(TMC_DEBUG)
       static uint32_t get_pwm_scale(TMC2130Stepper &st) { return st.PWM_SCALE(); }
       static uint8_t get_status_response(TMC2130Stepper &st, uint32_t) { return st.status_response & 0xF; }
@@ -220,7 +220,7 @@
     #endif
   }
 
-  #define HAS_HW_COMMS(ST) AXIS_DRIVER_TYPE(ST, TMC2130) || AXIS_DRIVER_TYPE(ST, TMC2660) || (AXIS_DRIVER_TYPE(ST, TMC2208) && defined(ST##_HARDWARE_SERIAL))
+  #define HAS_HW_COMMS(ST) AXIS_DRIVER_TYPE(ST, TMC2130) || AXIS_DRIVER_TYPE(ST, TMC2160) || AXIS_DRIVER_TYPE(ST, TMC2660) || AXIS_DRIVER_TYPE(ST, TMC5130) || AXIS_DRIVER_TYPE(ST, TMC5160) || (AXIS_DRIVER_TYPE(ST, TMC2208) && defined(ST##_HARDWARE_SERIAL))
 
   void monitor_tmc_driver() {
     static millis_t next_poll = 0;
@@ -295,6 +295,7 @@
     TMC_MAX_CURRENT,
     TMC_IRUN,
     TMC_IHOLD,
+    TMC_GLOBAL_SCALER,
     TMC_CS_ACTUAL,
     TMC_PWM_SCALE,
     TMC_VSENSE,
@@ -359,7 +360,7 @@
   template<class TMC>
   static void print_vsense(TMC &st) { serialprintPGM(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); }
 
-  #if HAS_DRIVER(TMC2130)
+  #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC2160) || HAS_DRIVER(TMC5130) || HAS_DRIVER(TMC5160)
     static void tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
       switch (i) {
         case TMC_PWM_SCALE: SERIAL_PRINT(st.PWM_SCALE(), DEC); break;
@@ -379,6 +380,27 @@
     }
   #endif
 
+  #if HAS_DRIVER(TMC2160) || HAS_DRIVER(TMC5160)
+    template<char AXIS_LETTER, char DRIVER_ID> void print_vsense(TMCMarlin<TMC2160Stepper, AXIS_LETTER, DRIVER_ID> &st) { UNUSED(st); }
+    template<char AXIS_LETTER, char DRIVER_ID> void print_vsense(TMCMarlin<TMC5160Stepper, AXIS_LETTER, DRIVER_ID> &st) { UNUSED(st); }
+
+    static void tmc_status(TMC2160Stepper &st, const TMC_debug_enum i) {
+      switch (i) {
+        case TMC_PWM_SCALE: SERIAL_PRINT(st.PWM_SCALE(), DEC); break;
+        case TMC_SGT: SERIAL_PRINT(st.sgt(), DEC); break;
+        case TMC_STEALTHCHOP: serialprintPGM(st.en_pwm_mode() ? PSTR("true") : PSTR("false")); break;
+        case TMC_GLOBAL_SCALER:
+          {
+            uint16_t value = st.GLOBAL_SCALER();
+            SERIAL_PRINT(value ? value : 256, DEC);
+            SERIAL_ECHOPGM("/256");
+          }
+          break;
+        default: break;
+      }
+    }
+  #endif
+
   #if HAS_DRIVER(TMC2208)
     static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
       switch (i) {
@@ -657,6 +679,9 @@
     TMC_REPORT("MAX current",        TMC_MAX_CURRENT);
     TMC_REPORT("Run current",        TMC_IRUN);
     TMC_REPORT("Hold current",       TMC_IHOLD);
+    #if HAS_DRIVER(TMC2160) || HAS_DRIVER(TMC5160)
+      TMC_REPORT("Global scaler",    TMC_GLOBAL_SCALER);
+    #endif
     TMC_REPORT("CS actual\t",        TMC_CS_ACTUAL);
     TMC_REPORT("PWM scale",          TMC_PWM_SCALE);
     TMC_REPORT("vsense\t",           TMC_VSENSE);
@@ -677,7 +702,7 @@
     TMC_REPORT("Stallguard thrs",    TMC_SGT);
 
     DRV_REPORT("DRVSTATUS",          TMC_DRV_CODES);
-    #if HAS_DRIVER(TMC2130)
+    #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC2160) || HAS_DRIVER(TMC5130) || HAS_DRIVER(TMC5160)
       DRV_REPORT("stallguard\t",     TMC_STALLGUARD);
       DRV_REPORT("sg_result\t",      TMC_SG_RESULT);
       DRV_REPORT("fsactive\t",       TMC_FSACTIVE);
@@ -703,7 +728,7 @@
 
   #define PRINT_TMC_REGISTER(REG_CASE) case TMC_GET_##REG_CASE: print_hex_long(st.REG_CASE(), ':'); break
 
-  #if HAS_DRIVER(TMC2130)
+  #if HAS_DRIVER(TMC2130) || HAS_DRIVER(TMC2160) || HAS_DRIVER(TMC5130) || HAS_DRIVER(TMC5160)
     static void tmc_get_ic_registers(TMC2130Stepper &st, const TMC_get_registers_enum i) {
       switch (i) {
         PRINT_TMC_REGISTER(TCOOLTHRS);
@@ -1023,7 +1048,6 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
       stepperE5.init_lcd_variables(E_AXIS_N(5));
     #endif
   }
-
 #endif
 
 #endif // HAS_TRINAMIC

commit e5801b75f89254d088b423499719b5ccbc48cb0d
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Mon Jan 21 07:54:57 2019 +0200

    Fix TMC-related compile issues. (#12971)
    
    - `STEALTHOP_[XYZE]` configuration options now set the default state.

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 8c21575a73..cba1d7e329 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -838,18 +838,14 @@
     bool stealthchop_was_enabled = st.en_pwm_mode();
 
     st.TCOOLTHRS(0xFFFFF);
-    #if STEALTHCHOP_ENABLED
-      st.en_pwm_mode(false);
-    #endif
+    st.en_pwm_mode(false);
     st.diag1_stall(true);
 
     return stealthchop_was_enabled;
   }
   void tmc_disable_stallguard(TMC2130Stepper &st, const bool restore_stealth) {
     st.TCOOLTHRS(0);
-    #if STEALTHCHOP_ENABLED
-      st.en_pwm_mode(restore_stealth);
-    #endif
+    st.en_pwm_mode(restore_stealth);
     st.diag1_stall(false);
   }
   bool tmc_enable_stallguard(TMC2660Stepper) {

commit e6805582a67b106691423a35ab580bd6b0895949
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Thu Jan 17 21:17:16 2019 +0200

    M569 to change stepping mode. Add new TMC section to LCD. (#12884)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 681b93b6af..8c21575a73 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -40,6 +40,10 @@
   #endif
 #endif
 
+#if HAS_LCD_MENU
+  #include "../module/stepper.h"
+#endif
+
 /**
  * Check for over temperature or short to ground error flags.
  * Report and log warning of overtemperature condition.
@@ -980,4 +984,50 @@ void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z
   if (axis_connection) ui.set_status_P(PSTR("TMC CONNECTION ERROR"));
 }
 
+#if HAS_LCD_MENU
+
+  void init_tmc_section() {
+    #if AXIS_IS_TMC(X)
+      stepperX.init_lcd_variables(X_AXIS);
+    #endif
+    #if AXIS_IS_TMC(Y)
+      stepperY.init_lcd_variables(Y_AXIS);
+    #endif
+    #if AXIS_IS_TMC(Z)
+      stepperZ.init_lcd_variables(Z_AXIS);
+    #endif
+    #if AXIS_IS_TMC(X2)
+      stepperX2.init_lcd_variables(X_AXIS);
+    #endif
+    #if AXIS_IS_TMC(Y2)
+      stepperY2.init_lcd_variables(Y_AXIS);
+    #endif
+    #if AXIS_IS_TMC(Z2)
+      stepperZ2.init_lcd_variables(Z_AXIS);
+    #endif
+    #if AXIS_IS_TMC(Z3)
+      stepperZ3.init_lcd_variables(Z_AXIS);
+    #endif
+    #if AXIS_IS_TMC(E0)
+      stepperE0.init_lcd_variables(E_AXIS);
+    #endif
+    #if AXIS_IS_TMC(E1)
+      stepperE1.init_lcd_variables(E_AXIS_N(1));
+    #endif
+    #if AXIS_IS_TMC(E2)
+      stepperE2.init_lcd_variables(E_AXIS_N(2));
+    #endif
+    #if AXIS_IS_TMC(E3)
+      stepperE3.init_lcd_variables(E_AXIS_N(3));
+    #endif
+    #if AXIS_IS_TMC(E4)
+      stepperE4.init_lcd_variables(E_AXIS_N(4));
+    #endif
+    #if AXIS_IS_TMC(E5)
+      stepperE5.init_lcd_variables(E_AXIS_N(5));
+    #endif
+  }
+
+#endif
+
 #endif // HAS_TRINAMIC

commit 55144284c2578dccca7a6a5fa472a3d927ff09f2
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Mon Dec 10 04:54:48 2018 +0200

    TMC connection test, spreadCycle parameters, improved debugging (#12616)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index a0fd58d301..681b93b6af 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -34,7 +34,10 @@
 
 #if ENABLED(TMC_DEBUG)
   #include "../module/planner.h"
-  static bool report_tmc_status; // = false;
+  #include "../libs/hex_print_routines.h"
+  #if ENABLED(MONITOR_DRIVER_STATUS)
+    static bool report_tmc_status; // = false;
+  #endif
 #endif
 
 /**
@@ -130,7 +133,7 @@
       if (data.is_s2ga) SERIAL_ECHOLNPGM("short to ground (coil A)");
       if (data.is_s2gb) SERIAL_ECHOLNPGM("short to ground (coil B)");
       #if ENABLED(TMC_DEBUG)
-        tmc_report_all();
+        tmc_report_all(true, true, true, true);
       #endif
       kill(PSTR("Driver error"));
     }
@@ -326,16 +329,28 @@
     TMC_S2VSB,
     TMC_S2VSA
   };
-  static void drv_status_print_hex(const uint32_t drv_status) {
-    for (int B = 24; B >= 8; B -= 8){
-      SERIAL_PRINT((drv_status >> (B + 4)) & 0xF, HEX);
-      SERIAL_PRINT((drv_status >> B) & 0xF, HEX);
-      SERIAL_CHAR(':');
-    }
-    SERIAL_PRINT((drv_status >> 4) & 0xF, HEX);
-    SERIAL_PRINT((drv_status) & 0xF, HEX);
-    SERIAL_EOL();
-  }
+  enum TMC_get_registers_enum : char {
+    TMC_AXIS_CODES,
+    TMC_GET_GCONF,
+    TMC_GET_IHOLD_IRUN,
+    TMC_GET_GSTAT,
+    TMC_GET_IOIN,
+    TMC_GET_TPOWERDOWN,
+    TMC_GET_TSTEP,
+    TMC_GET_TPWMTHRS,
+    TMC_GET_TCOOLTHRS,
+    TMC_GET_THIGH,
+    TMC_GET_CHOPCONF,
+    TMC_GET_COOLCONF,
+    TMC_GET_PWMCONF,
+    TMC_GET_PWM_SCALE,
+    TMC_GET_DRV_STATUS,
+    TMC_GET_DRVCONF,
+    TMC_GET_DRVCTRL,
+    TMC_GET_DRVSTATUS,
+    TMC_GET_SGCSCONF,
+    TMC_GET_SMARTEN
+  };
 
   template<class TMC>
   static void print_vsense(TMC &st) { serialprintPGM(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); }
@@ -480,125 +495,146 @@
       case TMC_S2GA:          if (st.s2ga())         SERIAL_CHAR('X'); break;
       case TMC_DRV_OTPW:      if (st.otpw())         SERIAL_CHAR('X'); break;
       case TMC_OT:            if (st.ot())           SERIAL_CHAR('X'); break;
-      case TMC_DRV_STATUS_HEX:
+      case TMC_DRV_STATUS_HEX: {
+        const uint32_t drv_status = st.DRV_STATUS();
+        SERIAL_CHAR('\t');
         st.printLabel();
-        SERIAL_ECHOPGM("\t0x");
-        drv_status_print_hex(st.DRV_STATUS());
+        SERIAL_CHAR('\t');
+        print_hex_long(drv_status, ':');
+        if (drv_status == 0xFFFFFFFF || drv_status == 0) SERIAL_ECHOPGM("\t Bad response!");
+        SERIAL_EOL();
         break;
+      }
       default: _tmc_parse_drv_status(st, i); break;
     }
   }
 
-  static void tmc_debug_loop(const TMC_debug_enum i) {
-    #if AXIS_IS_TMC(X)
-      tmc_status(stepperX, i, planner.settings.axis_steps_per_mm[X_AXIS]);
-    #endif
-    #if AXIS_IS_TMC(X2)
-      tmc_status(stepperX2, i, planner.settings.axis_steps_per_mm[X_AXIS]);
-    #endif
+  static void tmc_debug_loop(const TMC_debug_enum i, const bool print_x, const bool print_y, const bool print_z, const bool print_e) {
+    if (print_x) {
+      #if AXIS_IS_TMC(X)
+        tmc_status(stepperX, i, planner.settings.axis_steps_per_mm[X_AXIS]);
+      #endif
+      #if AXIS_IS_TMC(X2)
+        tmc_status(stepperX2, i, planner.settings.axis_steps_per_mm[X_AXIS]);
+      #endif
+    }
 
-    #if AXIS_IS_TMC(Y)
-      tmc_status(stepperY, i, planner.settings.axis_steps_per_mm[Y_AXIS]);
-    #endif
-    #if AXIS_IS_TMC(Y2)
-      tmc_status(stepperY2, i, planner.settings.axis_steps_per_mm[Y_AXIS]);
-    #endif
+    if (print_y) {
+      #if AXIS_IS_TMC(Y)
+        tmc_status(stepperY, i, planner.settings.axis_steps_per_mm[Y_AXIS]);
+      #endif
+      #if AXIS_IS_TMC(Y2)
+        tmc_status(stepperY2, i, planner.settings.axis_steps_per_mm[Y_AXIS]);
+      #endif
+    }
 
-    #if AXIS_IS_TMC(Z)
-      tmc_status(stepperZ, i, planner.settings.axis_steps_per_mm[Z_AXIS]);
-    #endif
-    #if AXIS_IS_TMC(Z2)
-      tmc_status(stepperZ2, i, planner.settings.axis_steps_per_mm[Z_AXIS]);
-    #endif
-    #if AXIS_IS_TMC(Z3)
-      tmc_status(stepperZ3, i, planner.settings.axis_steps_per_mm[Z_AXIS]);
-    #endif
+    if (print_z) {
+      #if AXIS_IS_TMC(Z)
+        tmc_status(stepperZ, i, planner.settings.axis_steps_per_mm[Z_AXIS]);
+      #endif
+      #if AXIS_IS_TMC(Z2)
+        tmc_status(stepperZ2, i, planner.settings.axis_steps_per_mm[Z_AXIS]);
+      #endif
+      #if AXIS_IS_TMC(Z3)
+        tmc_status(stepperZ3, i, planner.settings.axis_steps_per_mm[Z_AXIS]);
+      #endif
+    }
 
-    #if AXIS_IS_TMC(E0)
-      tmc_status(stepperE0, i, planner.settings.axis_steps_per_mm[E_AXIS]);
-    #endif
-    #if AXIS_IS_TMC(E1)
-      tmc_status(stepperE1, i, planner.settings.axis_steps_per_mm[E_AXIS
-        #if ENABLED(DISTINCT_E_FACTORS)
-          + 1
-        #endif
-      ]);
-    #endif
-    #if AXIS_IS_TMC(E2)
-      tmc_status(stepperE2, i, planner.settings.axis_steps_per_mm[E_AXIS
-        #if ENABLED(DISTINCT_E_FACTORS)
-          + 2
-        #endif
-      ]);
-    #endif
-    #if AXIS_IS_TMC(E3)
-      tmc_status(stepperE3, i, planner.settings.axis_steps_per_mm[E_AXIS
-        #if ENABLED(DISTINCT_E_FACTORS)
-          + 3
-        #endif
-      ]);
-    #endif
-    #if AXIS_IS_TMC(E4)
-      tmc_status(stepperE4, i, planner.settings.axis_steps_per_mm[E_AXIS
-        #if ENABLED(DISTINCT_E_FACTORS)
-          + 4
-        #endif
-      ]);
-    #endif
-    #if AXIS_IS_TMC(E5)
-      tmc_status(stepperE5, i, planner.settings.axis_steps_per_mm[E_AXIS
-        #if ENABLED(DISTINCT_E_FACTORS)
-          + 5
-        #endif
-      ]);
-    #endif
+    if (print_e) {
+      #if AXIS_IS_TMC(E0)
+        tmc_status(stepperE0, i, planner.settings.axis_steps_per_mm[E_AXIS]);
+      #endif
+      #if AXIS_IS_TMC(E1)
+        tmc_status(stepperE1, i, planner.settings.axis_steps_per_mm[E_AXIS
+          #if ENABLED(DISTINCT_E_FACTORS)
+            + 1
+          #endif
+        ]);
+      #endif
+      #if AXIS_IS_TMC(E2)
+        tmc_status(stepperE2, i, planner.settings.axis_steps_per_mm[E_AXIS
+          #if ENABLED(DISTINCT_E_FACTORS)
+            + 2
+          #endif
+        ]);
+      #endif
+      #if AXIS_IS_TMC(E3)
+        tmc_status(stepperE3, i, planner.settings.axis_steps_per_mm[E_AXIS
+          #if ENABLED(DISTINCT_E_FACTORS)
+            + 3
+          #endif
+        ]);
+      #endif
+      #if AXIS_IS_TMC(E4)
+        tmc_status(stepperE4, i, planner.settings.axis_steps_per_mm[E_AXIS
+          #if ENABLED(DISTINCT_E_FACTORS)
+            + 4
+          #endif
+        ]);
+      #endif
+      #if AXIS_IS_TMC(E5)
+        tmc_status(stepperE5, i, planner.settings.axis_steps_per_mm[E_AXIS
+          #if ENABLED(DISTINCT_E_FACTORS)
+            + 5
+          #endif
+        ]);
+      #endif
+    }
 
     SERIAL_EOL();
   }
 
-  static void drv_status_loop(const TMC_drv_status_enum i) {
-    #if AXIS_IS_TMC(X)
-      tmc_parse_drv_status(stepperX, i);
-    #endif
-    #if AXIS_IS_TMC(X2)
-      tmc_parse_drv_status(stepperX2, i);
-    #endif
+  static void drv_status_loop(const TMC_drv_status_enum i, const bool print_x, const bool print_y, const bool print_z, const bool print_e) {
+    if (print_x) {
+      #if AXIS_IS_TMC(X)
+        tmc_parse_drv_status(stepperX, i);
+      #endif
+      #if AXIS_IS_TMC(X2)
+        tmc_parse_drv_status(stepperX2, i);
+      #endif
+    }
 
-    #if AXIS_IS_TMC(Y)
-      tmc_parse_drv_status(stepperY, i);
-    #endif
-    #if AXIS_IS_TMC(Y2)
-      tmc_parse_drv_status(stepperY2, i);
-    #endif
+    if (print_y) {
+      #if AXIS_IS_TMC(Y)
+        tmc_parse_drv_status(stepperY, i);
+      #endif
+      #if AXIS_IS_TMC(Y2)
+        tmc_parse_drv_status(stepperY2, i);
+      #endif
+    }
 
-    #if AXIS_IS_TMC(Z)
-      tmc_parse_drv_status(stepperZ, i);
-    #endif
-    #if AXIS_IS_TMC(Z2)
-      tmc_parse_drv_status(stepperZ2, i);
-    #endif
-    #if AXIS_IS_TMC(Z3)
-      tmc_parse_drv_status(stepperZ3, i);
-    #endif
+    if (print_z) {
+      #if AXIS_IS_TMC(Z)
+        tmc_parse_drv_status(stepperZ, i);
+      #endif
+      #if AXIS_IS_TMC(Z2)
+        tmc_parse_drv_status(stepperZ2, i);
+      #endif
+      #if AXIS_IS_TMC(Z3)
+        tmc_parse_drv_status(stepperZ3, i);
+      #endif
+    }
 
-    #if AXIS_IS_TMC(E0)
-      tmc_parse_drv_status(stepperE0, i);
-    #endif
-    #if AXIS_IS_TMC(E1)
-      tmc_parse_drv_status(stepperE1, i);
-    #endif
-    #if AXIS_IS_TMC(E2)
-      tmc_parse_drv_status(stepperE2, i);
-    #endif
-    #if AXIS_IS_TMC(E3)
-      tmc_parse_drv_status(stepperE3, i);
-    #endif
-    #if AXIS_IS_TMC(E4)
-      tmc_parse_drv_status(stepperE4, i);
-    #endif
-    #if AXIS_IS_TMC(E5)
-      tmc_parse_drv_status(stepperE5, i);
-    #endif
+    if (print_e) {
+      #if AXIS_IS_TMC(E0)
+        tmc_parse_drv_status(stepperE0, i);
+      #endif
+      #if AXIS_IS_TMC(E1)
+        tmc_parse_drv_status(stepperE1, i);
+      #endif
+      #if AXIS_IS_TMC(E2)
+        tmc_parse_drv_status(stepperE2, i);
+      #endif
+      #if AXIS_IS_TMC(E3)
+        tmc_parse_drv_status(stepperE3, i);
+      #endif
+      #if AXIS_IS_TMC(E4)
+        tmc_parse_drv_status(stepperE4, i);
+      #endif
+      #if AXIS_IS_TMC(E5)
+        tmc_parse_drv_status(stepperE5, i);
+      #endif
+    }
 
     SERIAL_EOL();
   }
@@ -607,9 +643,9 @@
    * M122 report functions
    */
 
-  void tmc_report_all() {
-    #define TMC_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL);  tmc_debug_loop(ITEM); }while(0)
-    #define DRV_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); drv_status_loop(ITEM); }while(0)
+  void tmc_report_all(bool print_x, const bool print_y, const bool print_z, const bool print_e) {
+    #define TMC_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL);  tmc_debug_loop(ITEM, print_x, print_y, print_z, print_e); }while(0)
+    #define DRV_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); drv_status_loop(ITEM, print_x, print_y, print_z, print_e); }while(0)
     TMC_REPORT("\t",                 TMC_CODES);
     TMC_REPORT("Enabled\t",          TMC_ENABLED);
     TMC_REPORT("Set current",        TMC_CURRENT);
@@ -661,6 +697,135 @@
     SERIAL_EOL();
   }
 
+  #define PRINT_TMC_REGISTER(REG_CASE) case TMC_GET_##REG_CASE: print_hex_long(st.REG_CASE(), ':'); break
+
+  #if HAS_DRIVER(TMC2130)
+    static void tmc_get_ic_registers(TMC2130Stepper &st, const TMC_get_registers_enum i) {
+      switch (i) {
+        PRINT_TMC_REGISTER(TCOOLTHRS);
+        PRINT_TMC_REGISTER(THIGH);
+        PRINT_TMC_REGISTER(COOLCONF);
+        default: SERIAL_CHAR('\t'); break;
+      }
+    }
+  #endif
+  #if HAS_DRIVER(TMC2208)
+    static void tmc_get_ic_registers(TMC2208Stepper, const TMC_get_registers_enum) { SERIAL_CHAR('\t'); }
+  #endif
+
+  #if HAS_TRINAMIC
+    template<class TMC>
+    static void tmc_get_registers(TMC &st, const TMC_get_registers_enum i) {
+      switch (i) {
+        case TMC_AXIS_CODES: SERIAL_CHAR('\t'); st.printLabel(); break;
+        PRINT_TMC_REGISTER(GCONF);
+        PRINT_TMC_REGISTER(IHOLD_IRUN);
+        PRINT_TMC_REGISTER(GSTAT);
+        PRINT_TMC_REGISTER(IOIN);
+        PRINT_TMC_REGISTER(TPOWERDOWN);
+        PRINT_TMC_REGISTER(TSTEP);
+        PRINT_TMC_REGISTER(TPWMTHRS);
+        PRINT_TMC_REGISTER(CHOPCONF);
+        PRINT_TMC_REGISTER(PWMCONF);
+        PRINT_TMC_REGISTER(PWM_SCALE);
+        PRINT_TMC_REGISTER(DRV_STATUS);
+        default: tmc_get_ic_registers(st, i); break;
+      }
+      SERIAL_CHAR('\t');
+    }
+  #endif
+  #if HAS_DRIVER(TMC2660)
+    template <char AXIS_LETTER, char DRIVER_ID>
+    static void tmc_get_registers(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID> &st, const TMC_get_registers_enum i) {
+      switch (i) {
+        case TMC_AXIS_CODES: SERIAL_CHAR('\t'); st.printLabel(); break;
+        PRINT_TMC_REGISTER(DRVCONF);
+        PRINT_TMC_REGISTER(DRVCTRL);
+        PRINT_TMC_REGISTER(CHOPCONF);
+        PRINT_TMC_REGISTER(DRVSTATUS);
+        PRINT_TMC_REGISTER(SGCSCONF);
+        PRINT_TMC_REGISTER(SMARTEN);
+        default: SERIAL_CHAR('\t'); break;
+      }
+      SERIAL_CHAR('\t');
+    }
+  #endif
+
+  static void tmc_get_registers(TMC_get_registers_enum i, const bool print_x, const bool print_y, const bool print_z, const bool print_e) {
+    if (print_x) {
+      #if AXIS_IS_TMC(X)
+        tmc_get_registers(stepperX, i);
+      #endif
+      #if AXIS_IS_TMC(X2)
+        tmc_get_registers(stepperX2, i);
+      #endif
+    }
+
+    if (print_y) {
+      #if AXIS_IS_TMC(Y)
+        tmc_get_registers(stepperY, i);
+      #endif
+      #if AXIS_IS_TMC(Y2)
+        tmc_get_registers(stepperY2, i);
+      #endif
+    }
+
+    if (print_z) {
+      #if AXIS_IS_TMC(Z)
+        tmc_get_registers(stepperZ, i);
+      #endif
+      #if AXIS_IS_TMC(Z2)
+        tmc_get_registers(stepperZ2, i);
+      #endif
+      #if AXIS_IS_TMC(Z3)
+        tmc_get_registers(stepperZ3, i);
+      #endif
+    }
+
+    if (print_e) {
+      #if AXIS_IS_TMC(E0)
+        tmc_get_registers(stepperE0, i);
+      #endif
+      #if AXIS_IS_TMC(E1)
+        tmc_get_registers(stepperE1, i);
+      #endif
+      #if AXIS_IS_TMC(E2)
+        tmc_get_registers(stepperE2, i);
+      #endif
+      #if AXIS_IS_TMC(E3)
+        tmc_get_registers(stepperE3, i);
+      #endif
+      #if AXIS_IS_TMC(E4)
+        tmc_get_registers(stepperE4, i);
+      #endif
+      #if AXIS_IS_TMC(E5)
+        tmc_get_registers(stepperE5, i);
+      #endif
+    }
+
+    SERIAL_EOL();
+  }
+
+  void tmc_get_registers(bool print_x, bool print_y, bool print_z, bool print_e) {
+    #define _TMC_GET_REG(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); tmc_get_registers(ITEM, print_x, print_y, print_z, print_e); }while(0)
+    #define TMC_GET_REG(NAME, TABS) _TMC_GET_REG(STRINGIFY(NAME) TABS, TMC_GET_##NAME)
+    _TMC_GET_REG("\t", TMC_AXIS_CODES);
+    TMC_GET_REG(GCONF, "\t\t");
+    TMC_GET_REG(IHOLD_IRUN, "\t");
+    TMC_GET_REG(GSTAT, "\t\t");
+    TMC_GET_REG(IOIN, "\t\t");
+    TMC_GET_REG(TPOWERDOWN, "\t");
+    TMC_GET_REG(TSTEP, "\t\t");
+    TMC_GET_REG(TPWMTHRS, "\t");
+    TMC_GET_REG(TCOOLTHRS, "\t");
+    TMC_GET_REG(THIGH, "\t\t");
+    TMC_GET_REG(CHOPCONF, "\t");
+    TMC_GET_REG(COOLCONF, "\t");
+    TMC_GET_REG(PWMCONF, "\t");
+    TMC_GET_REG(PWM_SCALE, "\t");
+    TMC_GET_REG(DRV_STATUS, "\t");
+  }
+
 #endif // TMC_DEBUG
 
 #if USE_SENSORLESS
@@ -736,4 +901,83 @@
   }
 #endif // TMC_HAS_SPI
 
+template<typename TMC>
+static bool test_connection(TMC &st) {
+  SERIAL_ECHOPGM("Testing ");
+  st.printLabel();
+  SERIAL_ECHOPGM(" connection... ");
+  const uint8_t test_result = st.test_connection();
+
+  if (test_result > 0) SERIAL_ECHOPGM("Error: All ");
+
+  const char *stat;
+  switch (test_result) {
+    default:
+    case 0: stat = PSTR("OK"); break;
+    case 1: stat = PSTR("HIGH"); break;
+    case 2: stat = PSTR("LOW"); break;
+  }
+  serialprintPGM(stat);
+  SERIAL_EOL();
+
+  return test_result;
+}
+
+void test_tmc_connection(const bool test_x, const bool test_y, const bool test_z, const bool test_e) {
+  uint8_t axis_connection = 0;
+
+  if (test_x) {
+    #if AXIS_IS_TMC(X)
+      axis_connection += test_connection(stepperX);
+    #endif
+    #if AXIS_IS_TMC(X2)
+      axis_connection += test_connection(stepperX2);
+    #endif
+  }
+
+  if (test_y) {
+    #if AXIS_IS_TMC(Y)
+      axis_connection += test_connection(stepperY);
+    #endif
+    #if AXIS_IS_TMC(Y2)
+      axis_connection += test_connection(stepperY2);
+    #endif
+  }
+
+  if (test_z) {
+    #if AXIS_IS_TMC(Z)
+      axis_connection += test_connection(stepperZ);
+    #endif
+    #if AXIS_IS_TMC(Z2)
+      axis_connection += test_connection(stepperZ2);
+    #endif
+    #if AXIS_IS_TMC(Z3)
+      axis_connection += test_connection(stepperZ3);
+    #endif
+  }
+
+  if (test_e) {
+    #if AXIS_IS_TMC(E0)
+      axis_connection += test_connection(stepperE0);
+    #endif
+    #if AXIS_IS_TMC(E1)
+      axis_connection += test_connection(stepperE1);
+    #endif
+    #if AXIS_IS_TMC(E2)
+      axis_connection += test_connection(stepperE2);
+    #endif
+    #if AXIS_IS_TMC(E3)
+      axis_connection += test_connection(stepperE3);
+    #endif
+    #if AXIS_IS_TMC(E4)
+      axis_connection += test_connection(stepperE4);
+    #endif
+    #if AXIS_IS_TMC(E5)
+      axis_connection += test_connection(stepperE5);
+    #endif
+  }
+
+  if (axis_connection) ui.set_status_P(PSTR("TMC CONNECTION ERROR"));
+}
+
 #endif // HAS_TRINAMIC

commit b22716e938397d8beb64f5855b64f6fdb375b5d2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sat Dec 8 13:36:46 2018 -0700

    M425 Backlash Correction (#11061)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 942819b78b..a0fd58d301 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -81,7 +81,7 @@
       static uint8_t get_status_response(TMC2208Stepper &st, uint32_t drv_status) {
         uint8_t gstat = st.GSTAT();
         uint8_t response = 0;
-        response |= (drv_status >> (31-3)) & 0b1000;
+        response |= (drv_status >> (31 - 3)) & 0b1000;
         response |= gstat & 0b11;
         return response;
       }

commit 50b2fbd03140d21076b8dd3015219ffed0f761c9
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 7 23:34:21 2018 +0200

    Trinamic: Split stealthChop, improve driver monitoring, etc. (#12582)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index c9c612e820..942819b78b 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -48,35 +48,37 @@
 
   struct TMC_driver_data {
     uint32_t drv_status;
-    bool is_otpw;
-    bool is_ot;
-    bool is_error;
+    bool is_otpw,
+         is_ot,
+         is_s2ga,
+         is_s2gb,
+         is_error;
   };
   #if HAS_DRIVER(TMC2130)
     #if ENABLED(TMC_DEBUG)
       static uint32_t get_pwm_scale(TMC2130Stepper &st) { return st.PWM_SCALE(); }
-      static uint8_t get_status_response(TMC2130Stepper &st) { return st.status_response & 0xF; }
+      static uint8_t get_status_response(TMC2130Stepper &st, uint32_t) { return st.status_response & 0xF; }
     #endif
     static TMC_driver_data get_driver_data(TMC2130Stepper &st) {
       constexpr uint32_t OTPW_bm = 0x4000000UL;
       constexpr uint8_t OTPW_bp = 26;
       constexpr uint32_t OT_bm = 0x2000000UL;
       constexpr uint8_t OT_bp = 25;
-      constexpr uint8_t DRIVER_ERROR_bm = 0x2UL;
-      constexpr uint8_t DRIVER_ERROR_bp = 1;
+      constexpr uint8_t S2GA_bp = 27;
+      constexpr uint8_t S2GB_bp = 28;
       TMC_driver_data data;
       data.drv_status = st.DRV_STATUS();
       data.is_otpw = (data.drv_status & OTPW_bm) >> OTPW_bp;
       data.is_ot = (data.drv_status & OT_bm) >> OT_bp;
-      data.is_error = (st.status_response & DRIVER_ERROR_bm) >> DRIVER_ERROR_bp;
+      data.is_s2ga = (data.drv_status >> S2GA_bp) & 0b1;
+      data.is_s2gb = (data.drv_status >> S2GB_bp) & 0b1;
       return data;
     }
   #endif
   #if HAS_DRIVER(TMC2208)
     #if ENABLED(TMC_DEBUG)
       static uint32_t get_pwm_scale(TMC2208Stepper &st) { return st.pwm_scale_sum(); }
-      static uint8_t get_status_response(TMC2208Stepper &st) {
-        uint32_t drv_status = st.DRV_STATUS();
+      static uint8_t get_status_response(TMC2208Stepper &st, uint32_t drv_status) {
         uint8_t gstat = st.GSTAT();
         uint8_t response = 0;
         response |= (drv_status >> (31-3)) & 0b1000;
@@ -89,75 +91,112 @@
       constexpr uint8_t OTPW_bp = 0;
       constexpr uint32_t OT_bm = 0b10ul;
       constexpr uint8_t OT_bp = 1;
+      constexpr uint8_t S2GA_bp = 2;
+      constexpr uint8_t S2GB_bp = 3;
       TMC_driver_data data;
       data.drv_status = st.DRV_STATUS();
       data.is_otpw = (data.drv_status & OTPW_bm) >> OTPW_bp;
       data.is_ot = (data.drv_status & OT_bm) >> OT_bp;
-      data.is_error = st.drv_err();
+      data.is_s2ga = (data.drv_status >> S2GA_bp) & 0b1;
+      data.is_s2gb = (data.drv_status >> S2GB_bp) & 0b1;
       return data;
     }
   #endif
   #if HAS_DRIVER(TMC2660)
     #if ENABLED(TMC_DEBUG)
       static uint32_t get_pwm_scale(TMC2660Stepper) { return 0; }
-      static uint8_t get_status_response(TMC2660Stepper) { return 0; }
+      static uint8_t get_status_response(TMC2660Stepper, uint32_t drv_status) {
+        return drv_status & 0xFF;
+      }
     #endif
     static TMC_driver_data get_driver_data(TMC2660Stepper &st) {
       constexpr uint32_t OTPW_bm = 0x4UL;
       constexpr uint8_t OTPW_bp = 2;
       constexpr uint32_t OT_bm = 0x2UL;
       constexpr uint8_t OT_bp = 1;
-      constexpr uint8_t DRIVER_ERROR_bm = 0x6;
       TMC_driver_data data;
       data.drv_status = st.DRVSTATUS();
       data.is_otpw = (data.drv_status & OTPW_bm) >> OTPW_bp;
       data.is_ot = (data.drv_status & OT_bm) >> OT_bp;
-      data.is_error = data.drv_status & DRIVER_ERROR_bm;
       return data;
     }
   #endif
 
+  #if ENABLED(STOP_ON_ERROR)
+    void report_driver_error(const TMC_driver_data &data) {
+      SERIAL_ECHOPGM(" driver error detected: 0x");
+      SERIAL_PRINTLN(data.drv_status, HEX);
+      if (data.is_ot) SERIAL_ECHOLNPGM("overtemperature");
+      if (data.is_s2ga) SERIAL_ECHOLNPGM("short to ground (coil A)");
+      if (data.is_s2gb) SERIAL_ECHOLNPGM("short to ground (coil B)");
+      #if ENABLED(TMC_DEBUG)
+        tmc_report_all();
+      #endif
+      kill(PSTR("Driver error"));
+    }
+  #endif
+
+  template<typename TMC>
+  void report_driver_otpw(TMC &st) {
+    char timestamp[14];
+    duration_t elapsed = print_job_timer.duration();
+    const bool has_days = (elapsed.value > 60*60*24L);
+    (void)elapsed.toDigital(timestamp, has_days);
+    SERIAL_EOL();
+    SERIAL_ECHO(timestamp);
+    SERIAL_ECHOPGM(": ");
+    st.printLabel();
+    SERIAL_ECHOPGM(" driver overtemperature warning! (");
+    SERIAL_ECHO(st.getMilliamps());
+    SERIAL_ECHOLNPGM("mA)");
+  }
+
+  template<typename TMC>
+  void report_polled_driver_data(TMC &st, const TMC_driver_data &data) {
+    const uint32_t pwm_scale = get_pwm_scale(st);
+    st.printLabel();
+    SERIAL_ECHOPAIR(":", pwm_scale);
+    SERIAL_ECHOPGM(" |0b"); SERIAL_PRINT(get_status_response(st, data.drv_status), BIN);
+    SERIAL_ECHOPGM("| ");
+    if (st.error_count) SERIAL_CHAR('E');
+    else if (data.is_ot) SERIAL_CHAR('O');
+    else if (data.is_otpw) SERIAL_CHAR('W');
+    else if (st.otpw_count > 0) SERIAL_PRINT(st.otpw_count, DEC);
+    else if (st.flag_otpw) SERIAL_CHAR('F');
+    SERIAL_CHAR('\t');
+  }
+
   template<typename TMC>
   void monitor_tmc_driver(TMC &st) {
     TMC_driver_data data = get_driver_data(st);
+    if ((data.drv_status == 0xFFFFFFFF) || (data.drv_status == 0x0)) return;
+
+    if (data.is_ot /* | data.s2ga | data.s2gb*/) st.error_count++;
+    else if (st.error_count > 0) st.error_count--;
 
     #if ENABLED(STOP_ON_ERROR)
-      if (data.is_error) {
+      if (st.error_count >= 10) {
         SERIAL_EOL();
         st.printLabel();
-        SERIAL_ECHOLNPGM(" driver error detected:");
-        if (data.is_ot) SERIAL_ECHOLNPGM("overtemperature");
-        if (st.s2ga()) SERIAL_ECHOLNPGM("short to ground (coil A)");
-        if (st.s2gb()) SERIAL_ECHOLNPGM("short to ground (coil B)");
-        #if ENABLED(TMC_DEBUG)
-          tmc_report_all();
-        #endif
-        kill(PSTR("Driver error"));
+        report_driver_error(data);
       }
     #endif
 
     // Report if a warning was triggered
     if (data.is_otpw && st.otpw_count == 0) {
-      char timestamp[14];
-      duration_t elapsed = print_job_timer.duration();
-      const bool has_days = (elapsed.value > 60*60*24L);
-      (void)elapsed.toDigital(timestamp, has_days);
-      SERIAL_EOL();
-      SERIAL_ECHO(timestamp);
-      SERIAL_ECHOPGM(": ");
-      st.printLabel();
-      SERIAL_ECHOPGM(" driver overtemperature warning! (");
-      SERIAL_ECHO(st.getMilliamps());
-      SERIAL_ECHOLNPGM("mA)");
+      report_driver_otpw(st);
     }
     #if CURRENT_STEP_DOWN > 0
       // Decrease current if is_otpw is true and driver is enabled and there's been more than 4 warnings
-      if (data.is_otpw && st.isEnabled() && st.otpw_count > 4) {
-        st.rms_current(MAX(int16_t(st.getMilliamps() - (CURRENT_STEP_DOWN)), 0));
-        #if ENABLED(REPORT_CURRENT_CHANGE)
-          st.printLabel();
-          SERIAL_ECHOLNPAIR(" current decreased to ", st.getMilliamps());
-        #endif
+      if (data.is_otpw && st.otpw_count > 4) {
+        uint16_t I_rms = st.getMilliamps();
+        if (st.isEnabled() && I_rms > 100) {
+          st.rms_current(I_rms - (CURRENT_STEP_DOWN));
+          #if ENABLED(REPORT_CURRENT_CHANGE)
+            st.printLabel();
+            SERIAL_ECHOLNPAIR(" current decreased to ", st.getMilliamps());
+          #endif
+        }
       }
     #endif
 
@@ -169,17 +208,7 @@
 
     #if ENABLED(TMC_DEBUG)
       if (report_tmc_status) {
-        const uint32_t pwm_scale = get_pwm_scale(st);
-        st.printLabel();
-        SERIAL_ECHOPAIR(":", pwm_scale);
-        SERIAL_ECHOPGM(" |0b"); SERIAL_PRINT(get_status_response(st), BIN);
-        SERIAL_ECHOPGM("| ");
-        if (data.is_error) SERIAL_CHAR('E');
-        else if (data.is_ot) SERIAL_CHAR('O');
-        else if (data.is_otpw) SERIAL_CHAR('W');
-        else if (st.otpw_count > 0) SERIAL_PRINT(st.otpw_count, DEC);
-        else if (st.flag_otpw) SERIAL_CHAR('F');
-        SERIAL_CHAR('\t');
+        report_polled_driver_data(st, data);
       }
     #endif
   }
@@ -187,9 +216,10 @@
   #define HAS_HW_COMMS(ST) AXIS_DRIVER_TYPE(ST, TMC2130) || AXIS_DRIVER_TYPE(ST, TMC2660) || (AXIS_DRIVER_TYPE(ST, TMC2208) && defined(ST##_HARDWARE_SERIAL))
 
   void monitor_tmc_driver() {
-    static millis_t next_cOT = 0;
-    if (ELAPSED(millis(), next_cOT)) {
-      next_cOT = millis() + 500;
+    static millis_t next_poll = 0;
+    const millis_t ms = millis();
+    if (ELAPSED(ms, next_poll)) {
+      next_poll = ms + 500;
       #if HAS_HW_COMMS(X)
         monitor_tmc_driver(stepperX);
       #endif
@@ -379,7 +409,12 @@
         break;
       case TMC_VSENSE: print_vsense(st); break;
       case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
-      case TMC_TSTEP: SERIAL_ECHO(st.TSTEP()); break;
+      case TMC_TSTEP: {
+          uint32_t tstep_value = st.TSTEP();
+          if (tstep_value == 0xFFFFF) SERIAL_ECHOPGM("max");
+          else SERIAL_ECHO(tstep_value);
+        }
+        break;
       case TMC_TPWMTHRS: {
           uint32_t tpwmthrs_val = st.TPWMTHRS();
           SERIAL_ECHO(tpwmthrs_val);
@@ -630,16 +665,29 @@
 
 #if USE_SENSORLESS
 
-  void tmc_stallguard(TMC2130Stepper &st, const bool enable/*=true*/) {
-    st.TCOOLTHRS(enable ? 0xFFFFF : 0);
-    #if ENABLED(STEALTHCHOP)
-      st.en_pwm_mode(!enable);
+  bool tmc_enable_stallguard(TMC2130Stepper &st) {
+    bool stealthchop_was_enabled = st.en_pwm_mode();
+
+    st.TCOOLTHRS(0xFFFFF);
+    #if STEALTHCHOP_ENABLED
+      st.en_pwm_mode(false);
+    #endif
+    st.diag1_stall(true);
+
+    return stealthchop_was_enabled;
+  }
+  void tmc_disable_stallguard(TMC2130Stepper &st, const bool restore_stealth) {
+    st.TCOOLTHRS(0);
+    #if STEALTHCHOP_ENABLED
+      st.en_pwm_mode(restore_stealth);
     #endif
-    st.diag1_stall(enable ? 1 : 0);
+    st.diag1_stall(false);
   }
-  void tmc_sensorless_homing(TMC2660Stepper &st, const bool enable) {
+  bool tmc_enable_stallguard(TMC2660Stepper) {
     // TODO
+    return false;
   }
+  void tmc_disable_stallguard(TMC2660Stepper, const bool) {};
 
 #endif // USE_SENSORLESS
 

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 07128df4fc..c9c612e820 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -358,12 +358,12 @@
 
   template <typename TMC>
   static void tmc_status(TMC &st, const TMC_debug_enum i, const float spmm) {
-    SERIAL_ECHO('\t');
+    SERIAL_CHAR('\t');
     switch (i) {
       case TMC_CODES: st.printLabel(); break;
       case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
       case TMC_CURRENT: SERIAL_ECHO(st.getMilliamps()); break;
-      case TMC_RMS_CURRENT: SERIAL_PROTOCOL(st.rms_current()); break;
+      case TMC_RMS_CURRENT: SERIAL_ECHO(st.rms_current()); break;
       case TMC_MAX_CURRENT: SERIAL_PRINT((float)st.rms_current() * 1.41, 0); break;
       case TMC_IRUN:
         SERIAL_PRINT(st.irun(), DEC);
@@ -408,12 +408,12 @@
   #if HAS_DRIVER(TMC2660)
     template<char AXIS_LETTER, char DRIVER_ID>
     void tmc_status(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID> &st, const TMC_debug_enum i, const float) {
-      SERIAL_ECHO('\t');
+      SERIAL_CHAR('\t');
       switch (i) {
         case TMC_CODES: st.printLabel(); break;
         case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
         case TMC_CURRENT: SERIAL_ECHO(st.getMilliamps()); break;
-        case TMC_RMS_CURRENT: SERIAL_PROTOCOL(st.rms_current()); break;
+        case TMC_RMS_CURRENT: SERIAL_ECHO(st.rms_current()); break;
         case TMC_MAX_CURRENT: SERIAL_PRINT((float)st.rms_current() * 1.41, 0); break;
         case TMC_IRUN:
           SERIAL_PRINT(st.cs(), DEC);

commit b779b42ffd00ca608fb46f522cb5b3e35554f361
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Nov 5 02:48:43 2018 -0600

    Prevent current step-down going negative
    
    Addressing #11348

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 1b14172ca7..07128df4fc 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -153,7 +153,7 @@
     #if CURRENT_STEP_DOWN > 0
       // Decrease current if is_otpw is true and driver is enabled and there's been more than 4 warnings
       if (data.is_otpw && st.isEnabled() && st.otpw_count > 4) {
-        st.rms_current(st.getMilliamps() - (CURRENT_STEP_DOWN));
+        st.rms_current(MAX(int16_t(st.getMilliamps() - (CURRENT_STEP_DOWN)), 0));
         #if ENABLED(REPORT_CURRENT_CHANGE)
           st.printLabel();
           SERIAL_ECHOLNPAIR(" current decreased to ", st.getMilliamps());

commit 9bf5d4331c0b414f39e4ec8acaa7558fd99fea93
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 16 05:47:02 2018 -0500

    Clear up some compiler warnings

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 41bbd049bc..1b14172ca7 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -138,7 +138,7 @@
 
     // Report if a warning was triggered
     if (data.is_otpw && st.otpw_count == 0) {
-      char timestamp[10];
+      char timestamp[14];
       duration_t elapsed = print_job_timer.duration();
       const bool has_days = (elapsed.value > 60*60*24L);
       (void)elapsed.toDigital(timestamp, has_days);

commit d556dc18650e2185791834d7fe70b4acf45254bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 10 09:45:20 2018 -0500

    Fix and improve EEPROM storage (#12054)
    
    * Clean up Temperature PID
    * Improve EEPROM read/write/validate
    * Group `SINGLENOZZLE` saved settings
    * Group planner saved settings
    * Group filament change saved settings
    * Group skew saved settings
    * Group `FWRETRACT` saved settings

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 2db0dd2d57..41bbd049bc 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -456,62 +456,62 @@
 
   static void tmc_debug_loop(const TMC_debug_enum i) {
     #if AXIS_IS_TMC(X)
-      tmc_status(stepperX, i, planner.axis_steps_per_mm[X_AXIS]);
+      tmc_status(stepperX, i, planner.settings.axis_steps_per_mm[X_AXIS]);
     #endif
     #if AXIS_IS_TMC(X2)
-      tmc_status(stepperX2, i, planner.axis_steps_per_mm[X_AXIS]);
+      tmc_status(stepperX2, i, planner.settings.axis_steps_per_mm[X_AXIS]);
     #endif
 
     #if AXIS_IS_TMC(Y)
-      tmc_status(stepperY, i, planner.axis_steps_per_mm[Y_AXIS]);
+      tmc_status(stepperY, i, planner.settings.axis_steps_per_mm[Y_AXIS]);
     #endif
     #if AXIS_IS_TMC(Y2)
-      tmc_status(stepperY2, i, planner.axis_steps_per_mm[Y_AXIS]);
+      tmc_status(stepperY2, i, planner.settings.axis_steps_per_mm[Y_AXIS]);
     #endif
 
     #if AXIS_IS_TMC(Z)
-      tmc_status(stepperZ, i, planner.axis_steps_per_mm[Z_AXIS]);
+      tmc_status(stepperZ, i, planner.settings.axis_steps_per_mm[Z_AXIS]);
     #endif
     #if AXIS_IS_TMC(Z2)
-      tmc_status(stepperZ2, i, planner.axis_steps_per_mm[Z_AXIS]);
+      tmc_status(stepperZ2, i, planner.settings.axis_steps_per_mm[Z_AXIS]);
     #endif
     #if AXIS_IS_TMC(Z3)
-      tmc_status(stepperZ3, i, planner.axis_steps_per_mm[Z_AXIS]);
+      tmc_status(stepperZ3, i, planner.settings.axis_steps_per_mm[Z_AXIS]);
     #endif
 
     #if AXIS_IS_TMC(E0)
-      tmc_status(stepperE0, i, planner.axis_steps_per_mm[E_AXIS]);
+      tmc_status(stepperE0, i, planner.settings.axis_steps_per_mm[E_AXIS]);
     #endif
     #if AXIS_IS_TMC(E1)
-      tmc_status(stepperE1, i, planner.axis_steps_per_mm[E_AXIS
+      tmc_status(stepperE1, i, planner.settings.axis_steps_per_mm[E_AXIS
         #if ENABLED(DISTINCT_E_FACTORS)
           + 1
         #endif
       ]);
     #endif
     #if AXIS_IS_TMC(E2)
-      tmc_status(stepperE2, i, planner.axis_steps_per_mm[E_AXIS
+      tmc_status(stepperE2, i, planner.settings.axis_steps_per_mm[E_AXIS
         #if ENABLED(DISTINCT_E_FACTORS)
           + 2
         #endif
       ]);
     #endif
     #if AXIS_IS_TMC(E3)
-      tmc_status(stepperE3, i, planner.axis_steps_per_mm[E_AXIS
+      tmc_status(stepperE3, i, planner.settings.axis_steps_per_mm[E_AXIS
         #if ENABLED(DISTINCT_E_FACTORS)
           + 3
         #endif
       ]);
     #endif
     #if AXIS_IS_TMC(E4)
-      tmc_status(stepperE4, i, planner.axis_steps_per_mm[E_AXIS
+      tmc_status(stepperE4, i, planner.settings.axis_steps_per_mm[E_AXIS
         #if ENABLED(DISTINCT_E_FACTORS)
           + 4
         #endif
       ]);
     #endif
     #if AXIS_IS_TMC(E5)
-      tmc_status(stepperE5, i, planner.axis_steps_per_mm[E_AXIS
+      tmc_status(stepperE5, i, planner.settings.axis_steps_per_mm[E_AXIS
         #if ENABLED(DISTINCT_E_FACTORS)
           + 5
         #endif

commit dffb4c63dca4da7f2c248cdace62c475479ca117
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sun Oct 7 23:37:44 2018 +0300

    [2.0.x] TMC2660 followup (#12029)
    
    * Don't react to s2g on TMC2660. False positives
    * Init with sensorless probing as well

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 9628c0d988..2db0dd2d57 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -107,7 +107,7 @@
       constexpr uint8_t OTPW_bp = 2;
       constexpr uint32_t OT_bm = 0x2UL;
       constexpr uint8_t OT_bp = 1;
-      constexpr uint8_t DRIVER_ERROR_bm = 0x1EUL;
+      constexpr uint8_t DRIVER_ERROR_bm = 0x6;
       TMC_driver_data data;
       data.drv_status = st.DRVSTATUS();
       data.is_otpw = (data.drv_status & OTPW_bm) >> OTPW_bp;

commit c447d759167bb118c2f26febdae71dd60c64977a
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sun Oct 7 01:18:10 2018 +0300

    Add support for TMC2660 (#11998)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 97b91bbf74..9628c0d988 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -53,8 +53,10 @@
     bool is_error;
   };
   #if HAS_DRIVER(TMC2130)
-    static uint32_t get_pwm_scale(TMC2130Stepper &st) { return st.PWM_SCALE(); }
-    static uint8_t get_status_response(TMC2130Stepper &st) { return st.status_response & 0xF; }
+    #if ENABLED(TMC_DEBUG)
+      static uint32_t get_pwm_scale(TMC2130Stepper &st) { return st.PWM_SCALE(); }
+      static uint8_t get_status_response(TMC2130Stepper &st) { return st.status_response & 0xF; }
+    #endif
     static TMC_driver_data get_driver_data(TMC2130Stepper &st) {
       constexpr uint32_t OTPW_bm = 0x4000000UL;
       constexpr uint8_t OTPW_bp = 26;
@@ -71,15 +73,17 @@
     }
   #endif
   #if HAS_DRIVER(TMC2208)
-    static uint32_t get_pwm_scale(TMC2208Stepper &st) { return st.pwm_scale_sum(); }
-    static uint8_t get_status_response(TMC2208Stepper &st) {
-      uint32_t drv_status = st.DRV_STATUS();
-      uint8_t gstat = st.GSTAT();
-      uint8_t response = 0;
-      response |= (drv_status >> (31-3)) & 0b1000;
-      response |= gstat & 0b11;
-      return response;
-    }
+    #if ENABLED(TMC_DEBUG)
+      static uint32_t get_pwm_scale(TMC2208Stepper &st) { return st.pwm_scale_sum(); }
+      static uint8_t get_status_response(TMC2208Stepper &st) {
+        uint32_t drv_status = st.DRV_STATUS();
+        uint8_t gstat = st.GSTAT();
+        uint8_t response = 0;
+        response |= (drv_status >> (31-3)) & 0b1000;
+        response |= gstat & 0b11;
+        return response;
+      }
+    #endif
     static TMC_driver_data get_driver_data(TMC2208Stepper &st) {
       constexpr uint32_t OTPW_bm = 0b1ul;
       constexpr uint8_t OTPW_bp = 0;
@@ -93,6 +97,25 @@
       return data;
     }
   #endif
+  #if HAS_DRIVER(TMC2660)
+    #if ENABLED(TMC_DEBUG)
+      static uint32_t get_pwm_scale(TMC2660Stepper) { return 0; }
+      static uint8_t get_status_response(TMC2660Stepper) { return 0; }
+    #endif
+    static TMC_driver_data get_driver_data(TMC2660Stepper &st) {
+      constexpr uint32_t OTPW_bm = 0x4UL;
+      constexpr uint8_t OTPW_bp = 2;
+      constexpr uint32_t OT_bm = 0x2UL;
+      constexpr uint8_t OT_bp = 1;
+      constexpr uint8_t DRIVER_ERROR_bm = 0x1EUL;
+      TMC_driver_data data;
+      data.drv_status = st.DRVSTATUS();
+      data.is_otpw = (data.drv_status & OTPW_bm) >> OTPW_bp;
+      data.is_ot = (data.drv_status & OT_bm) >> OT_bp;
+      data.is_error = data.drv_status & DRIVER_ERROR_bm;
+      return data;
+    }
+  #endif
 
   template<typename TMC>
   void monitor_tmc_driver(TMC &st) {
@@ -161,7 +184,7 @@
     #endif
   }
 
-  #define HAS_HW_COMMS(ST) AXIS_DRIVER_TYPE(ST, TMC2130) || (AXIS_DRIVER_TYPE(ST, TMC2208) && defined(ST##_HARDWARE_SERIAL))
+  #define HAS_HW_COMMS(ST) AXIS_DRIVER_TYPE(ST, TMC2130) || AXIS_DRIVER_TYPE(ST, TMC2660) || (AXIS_DRIVER_TYPE(ST, TMC2208) && defined(ST##_HARDWARE_SERIAL))
 
   void monitor_tmc_driver() {
     static millis_t next_cOT = 0;
@@ -217,6 +240,16 @@
 
 #if ENABLED(TMC_DEBUG)
 
+  /**
+   * M122 S[1,0] Enable periodic status reports
+   */
+  #if ENABLED(MONITOR_DRIVER_STATUS)
+    void tmc_set_report_status(const bool status) {
+      if ((report_tmc_status = status))
+        SERIAL_ECHOLNPGM("axis:pwm_scale |status_response|");
+    }
+  #endif
+
   enum TMC_debug_enum : char {
     TMC_CODES,
     TMC_ENABLED,
@@ -291,6 +324,7 @@
         case TMC_STALLGUARD: if (st.stallguard()) SERIAL_CHAR('X'); break;
         case TMC_SG_RESULT:  SERIAL_PRINT(st.sg_result(), DEC);   break;
         case TMC_FSACTIVE:   if (st.fsactive())   SERIAL_CHAR('X'); break;
+        case TMC_DRV_CS_ACTUAL: SERIAL_PRINT(st.cs_actual(), DEC); break;
         default: break;
       }
     }
@@ -312,11 +346,16 @@
         case TMC_T150: if (st.t150()) SERIAL_CHAR('X'); break;
         case TMC_T143: if (st.t143()) SERIAL_CHAR('X'); break;
         case TMC_T120: if (st.t120()) SERIAL_CHAR('X'); break;
+        case TMC_DRV_CS_ACTUAL: SERIAL_PRINT(st.cs_actual(), DEC); break;
         default: break;
       }
     }
   #endif
 
+  #if HAS_DRIVER(TMC2660)
+    static void _tmc_parse_drv_status(TMC2660Stepper, const TMC_drv_status_enum) { }
+  #endif
+
   template <typename TMC>
   static void tmc_status(TMC &st, const TMC_debug_enum i, const float spmm) {
     SERIAL_ECHO('\t');
@@ -355,7 +394,9 @@
         }
         break;
       case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;
-      case TMC_OTPW_TRIGGERED: serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false")); break;
+      #if ENABLED(MONITOR_DRIVER_STATUS)
+        case TMC_OTPW_TRIGGERED: serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false")); break;
+      #endif
       case TMC_TOFF: SERIAL_PRINT(st.toff(), DEC); break;
       case TMC_TBL: SERIAL_PRINT(st.blank_time(), DEC); break;
       case TMC_HEND: SERIAL_PRINT(st.hysteresis_end(), DEC); break;
@@ -364,6 +405,34 @@
     }
   }
 
+  #if HAS_DRIVER(TMC2660)
+    template<char AXIS_LETTER, char DRIVER_ID>
+    void tmc_status(TMCMarlin<TMC2660Stepper, AXIS_LETTER, DRIVER_ID> &st, const TMC_debug_enum i, const float) {
+      SERIAL_ECHO('\t');
+      switch (i) {
+        case TMC_CODES: st.printLabel(); break;
+        case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
+        case TMC_CURRENT: SERIAL_ECHO(st.getMilliamps()); break;
+        case TMC_RMS_CURRENT: SERIAL_PROTOCOL(st.rms_current()); break;
+        case TMC_MAX_CURRENT: SERIAL_PRINT((float)st.rms_current() * 1.41, 0); break;
+        case TMC_IRUN:
+          SERIAL_PRINT(st.cs(), DEC);
+          SERIAL_ECHOPGM("/31");
+          break;
+        case TMC_VSENSE: serialprintPGM(st.vsense() ? PSTR("1=.165") : PSTR("0=.310")); break;
+        case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
+        //case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;
+        //case TMC_OTPW_TRIGGERED: serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false")); break;
+        case TMC_SGT: SERIAL_PRINT(st.sgt(), DEC); break;
+        case TMC_TOFF: SERIAL_PRINT(st.toff(), DEC); break;
+        case TMC_TBL: SERIAL_PRINT(st.blank_time(), DEC); break;
+        case TMC_HEND: SERIAL_PRINT(st.hysteresis_end(), DEC); break;
+        case TMC_HSTRT: SERIAL_PRINT(st.hysteresis_start(), DEC); break;
+        default: break;
+      }
+    }
+  #endif
+
   template <typename TMC>
   static void tmc_parse_drv_status(TMC &st, const TMC_drv_status_enum i) {
     SERIAL_CHAR('\t');
@@ -376,7 +445,6 @@
       case TMC_S2GA:          if (st.s2ga())         SERIAL_CHAR('X'); break;
       case TMC_DRV_OTPW:      if (st.otpw())         SERIAL_CHAR('X'); break;
       case TMC_OT:            if (st.ot())           SERIAL_CHAR('X'); break;
-      case TMC_DRV_CS_ACTUAL: SERIAL_PRINT(st.cs_actual(), DEC);       break;
       case TMC_DRV_STATUS_HEX:
         st.printLabel();
         SERIAL_ECHOPGM("\t0x");
@@ -503,10 +571,6 @@
   /**
    * M122 report functions
    */
-  void tmc_set_report_status(const bool status) {
-    if ((report_tmc_status = status))
-      SERIAL_ECHOLNPGM("axis:pwm_scale |status_response|");
-  }
 
   void tmc_report_all() {
     #define TMC_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL);  tmc_debug_loop(ITEM); }while(0)
@@ -527,8 +591,10 @@
     TMC_REPORT("pwm\nthreshold\t",   TMC_TPWMTHRS);
     TMC_REPORT("[mm/s]\t",           TMC_TPWMTHRS_MMS);
     TMC_REPORT("OT prewarn",         TMC_OTPW);
-    TMC_REPORT("OT prewarn has\n"
-               "been triggered",     TMC_OTPW_TRIGGERED);
+    #if ENABLED(MONITOR_DRIVER_STATUS)
+      TMC_REPORT("OT prewarn has\n"
+                 "been triggered",   TMC_OTPW_TRIGGERED);
+    #endif
     TMC_REPORT("off time\t",         TMC_TOFF);
     TMC_REPORT("blank time",         TMC_TBL);
     TMC_REPORT("hysteresis\n-end\t", TMC_HEND);
@@ -571,53 +637,55 @@
     #endif
     st.diag1_stall(enable ? 1 : 0);
   }
+  void tmc_sensorless_homing(TMC2660Stepper &st, const bool enable) {
+    // TODO
+  }
 
 #endif // USE_SENSORLESS
 
-#if HAS_DRIVER(TMC2130)
-  #define IS_TMC_SPI(ST) AXIS_DRIVER_TYPE(ST, TMC2130)
+#if TMC_HAS_SPI
   #define SET_CS_PIN(st) OUT_WRITE(st##_CS_PIN, HIGH)
   void tmc_init_cs_pins() {
-    #if IS_TMC_SPI(X)
+    #if AXIS_HAS_SPI(X)
       SET_CS_PIN(X);
     #endif
-    #if IS_TMC_SPI(Y)
+    #if AXIS_HAS_SPI(Y)
       SET_CS_PIN(Y);
     #endif
-    #if IS_TMC_SPI(Z)
+    #if AXIS_HAS_SPI(Z)
       SET_CS_PIN(Z);
     #endif
-    #if IS_TMC_SPI(X2)
+    #if AXIS_HAS_SPI(X2)
       SET_CS_PIN(X2);
     #endif
-    #if IS_TMC_SPI(Y2)
+    #if AXIS_HAS_SPI(Y2)
       SET_CS_PIN(Y2);
     #endif
-    #if IS_TMC_SPI(Z2)
+    #if AXIS_HAS_SPI(Z2)
       SET_CS_PIN(Z2);
     #endif
-    #if IS_TMC_SPI(Z3)
+    #if AXIS_HAS_SPI(Z3)
       SET_CS_PIN(Z3);
     #endif
-    #if IS_TMC_SPI(E0)
+    #if AXIS_HAS_SPI(E0)
       SET_CS_PIN(E0);
     #endif
-    #if IS_TMC_SPI(E1)
+    #if AXIS_HAS_SPI(E1)
       SET_CS_PIN(E1);
     #endif
-    #if IS_TMC_SPI(E2)
+    #if AXIS_HAS_SPI(E2)
       SET_CS_PIN(E2);
     #endif
-    #if IS_TMC_SPI(E3)
+    #if AXIS_HAS_SPI(E3)
       SET_CS_PIN(E3);
     #endif
-    #if IS_TMC_SPI(E4)
+    #if AXIS_HAS_SPI(E4)
       SET_CS_PIN(E4);
     #endif
-    #if IS_TMC_SPI(E5)
+    #if AXIS_HAS_SPI(E5)
       SET_CS_PIN(E5);
     #endif
   }
-#endif // TMC2130
+#endif // TMC_HAS_SPI
 
 #endif // HAS_TRINAMIC

commit 8daadd2c8ce9ab8fe2b1c346fae589b13f332d27
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 3 11:56:49 2018 -0500

    Fix TMC_DEBUG undefined report_tmc_status (#11993)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 27b170a83c..97b91bbf74 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -34,6 +34,7 @@
 
 #if ENABLED(TMC_DEBUG)
   #include "../module/planner.h"
+  static bool report_tmc_status; // = false;
 #endif
 
 /**
@@ -44,7 +45,6 @@
  * and so we don't repeatedly report warning before the condition is cleared.
  */
 #if ENABLED(MONITOR_DRIVER_STATUS)
-  static bool report_tmc_status = false;
 
   struct TMC_driver_data {
     uint32_t drv_status;
@@ -144,19 +144,21 @@
     }
     else if (st.otpw_count > 0) st.otpw_count = 0;
 
-    if (report_tmc_status) {
-      const uint32_t pwm_scale = get_pwm_scale(st);
-      st.printLabel();
-      SERIAL_ECHOPAIR(":", pwm_scale);
-      SERIAL_ECHOPGM(" |0b"); SERIAL_PRINT(get_status_response(st), BIN);
-      SERIAL_ECHOPGM("| ");
-      if (data.is_error) SERIAL_CHAR('E');
-      else if (data.is_ot) SERIAL_CHAR('O');
-      else if (data.is_otpw) SERIAL_CHAR('W');
-      else if (st.otpw_count > 0) SERIAL_PRINT(st.otpw_count, DEC);
-      else if (st.flag_otpw) SERIAL_CHAR('F');
-      SERIAL_CHAR('\t');
-    }
+    #if ENABLED(TMC_DEBUG)
+      if (report_tmc_status) {
+        const uint32_t pwm_scale = get_pwm_scale(st);
+        st.printLabel();
+        SERIAL_ECHOPAIR(":", pwm_scale);
+        SERIAL_ECHOPGM(" |0b"); SERIAL_PRINT(get_status_response(st), BIN);
+        SERIAL_ECHOPGM("| ");
+        if (data.is_error) SERIAL_CHAR('E');
+        else if (data.is_ot) SERIAL_CHAR('O');
+        else if (data.is_otpw) SERIAL_CHAR('W');
+        else if (st.otpw_count > 0) SERIAL_PRINT(st.otpw_count, DEC);
+        else if (st.flag_otpw) SERIAL_CHAR('F');
+        SERIAL_CHAR('\t');
+      }
+    #endif
   }
 
   #define HAS_HW_COMMS(ST) AXIS_DRIVER_TYPE(ST, TMC2130) || (AXIS_DRIVER_TYPE(ST, TMC2208) && defined(ST##_HARDWARE_SERIAL))
@@ -205,7 +207,9 @@
         monitor_tmc_driver(stepperE5);
       #endif
 
-      if (report_tmc_status) SERIAL_EOL();
+      #if ENABLED(TMC_DEBUG)
+        if (report_tmc_status) SERIAL_EOL();
+      #endif
     }
   }
 

commit c3229e1b3461b6da8373e7a24a7eeb131912a15b
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Wed Oct 3 10:48:49 2018 +0300

    Migrate to a new TMC library (#11943)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 9cc81f9dfe..27b170a83c 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -36,8 +36,6 @@
   #include "../module/planner.h"
 #endif
 
-bool report_tmc_status = false;
-
 /**
  * Check for over temperature or short to ground error flags.
  * Report and log warning of overtemperature condition.
@@ -46,6 +44,8 @@ bool report_tmc_status = false;
  * and so we don't repeatedly report warning before the condition is cleared.
  */
 #if ENABLED(MONITOR_DRIVER_STATUS)
+  static bool report_tmc_status = false;
+
   struct TMC_driver_data {
     uint32_t drv_status;
     bool is_otpw;
@@ -95,13 +95,13 @@ bool report_tmc_status = false;
   #endif
 
   template<typename TMC>
-  void monitor_tmc_driver(TMC &st, const TMC_AxisEnum axis, uint8_t &otpw_cnt) {
+  void monitor_tmc_driver(TMC &st) {
     TMC_driver_data data = get_driver_data(st);
 
     #if ENABLED(STOP_ON_ERROR)
       if (data.is_error) {
         SERIAL_EOL();
-        _tmc_say_axis(axis);
+        st.printLabel();
         SERIAL_ECHOLNPGM(" driver error detected:");
         if (data.is_ot) SERIAL_ECHOLNPGM("overtemperature");
         if (st.s2ga()) SERIAL_ECHOLNPGM("short to ground (coil A)");
@@ -114,7 +114,7 @@ bool report_tmc_status = false;
     #endif
 
     // Report if a warning was triggered
-    if (data.is_otpw && otpw_cnt == 0) {
+    if (data.is_otpw && st.otpw_count == 0) {
       char timestamp[10];
       duration_t elapsed = print_job_timer.duration();
       const bool has_days = (elapsed.value > 60*60*24L);
@@ -122,38 +122,38 @@ bool report_tmc_status = false;
       SERIAL_EOL();
       SERIAL_ECHO(timestamp);
       SERIAL_ECHOPGM(": ");
-      _tmc_say_axis(axis);
+      st.printLabel();
       SERIAL_ECHOPGM(" driver overtemperature warning! (");
-      SERIAL_ECHO(st.getCurrent());
+      SERIAL_ECHO(st.getMilliamps());
       SERIAL_ECHOLNPGM("mA)");
     }
     #if CURRENT_STEP_DOWN > 0
       // Decrease current if is_otpw is true and driver is enabled and there's been more than 4 warnings
-      if (data.is_otpw && st.isEnabled() && otpw_cnt > 4) {
-        st.setCurrent(st.getCurrent() - (CURRENT_STEP_DOWN), R_SENSE, HOLD_MULTIPLIER);
+      if (data.is_otpw && st.isEnabled() && st.otpw_count > 4) {
+        st.rms_current(st.getMilliamps() - (CURRENT_STEP_DOWN));
         #if ENABLED(REPORT_CURRENT_CHANGE)
-          _tmc_say_axis(axis);
-          SERIAL_ECHOLNPAIR(" current decreased to ", st.getCurrent());
+          st.printLabel();
+          SERIAL_ECHOLNPAIR(" current decreased to ", st.getMilliamps());
         #endif
       }
     #endif
 
     if (data.is_otpw) {
-      otpw_cnt++;
+      st.otpw_count++;
       st.flag_otpw = true;
     }
-    else if (otpw_cnt > 0) otpw_cnt = 0;
+    else if (st.otpw_count > 0) st.otpw_count = 0;
 
     if (report_tmc_status) {
       const uint32_t pwm_scale = get_pwm_scale(st);
-      _tmc_say_axis(axis);
+      st.printLabel();
       SERIAL_ECHOPAIR(":", pwm_scale);
       SERIAL_ECHOPGM(" |0b"); SERIAL_PRINT(get_status_response(st), BIN);
       SERIAL_ECHOPGM("| ");
       if (data.is_error) SERIAL_CHAR('E');
       else if (data.is_ot) SERIAL_CHAR('O');
       else if (data.is_otpw) SERIAL_CHAR('W');
-      else if (otpw_cnt > 0) SERIAL_PRINT(otpw_cnt, DEC);
+      else if (st.otpw_count > 0) SERIAL_PRINT(st.otpw_count, DEC);
       else if (st.flag_otpw) SERIAL_CHAR('F');
       SERIAL_CHAR('\t');
     }
@@ -166,56 +166,43 @@ bool report_tmc_status = false;
     if (ELAPSED(millis(), next_cOT)) {
       next_cOT = millis() + 500;
       #if HAS_HW_COMMS(X)
-        static uint8_t x_otpw_cnt = 0;
-        monitor_tmc_driver(stepperX, TMC_X, x_otpw_cnt);
+        monitor_tmc_driver(stepperX);
       #endif
       #if HAS_HW_COMMS(Y)
-        static uint8_t y_otpw_cnt = 0;
-        monitor_tmc_driver(stepperY, TMC_Y, y_otpw_cnt);
+        monitor_tmc_driver(stepperY);
       #endif
       #if HAS_HW_COMMS(Z)
-        static uint8_t z_otpw_cnt = 0;
-        monitor_tmc_driver(stepperZ, TMC_Z, z_otpw_cnt);
+        monitor_tmc_driver(stepperZ);
       #endif
       #if HAS_HW_COMMS(X2)
-        static uint8_t x2_otpw_cnt = 0;
-        monitor_tmc_driver(stepperX2, TMC_X, x2_otpw_cnt);
+        monitor_tmc_driver(stepperX2);
       #endif
       #if HAS_HW_COMMS(Y2)
-        static uint8_t y2_otpw_cnt = 0;
-        monitor_tmc_driver(stepperY2, TMC_Y, y2_otpw_cnt);
+        monitor_tmc_driver(stepperY2);
       #endif
       #if HAS_HW_COMMS(Z2)
-        static uint8_t z2_otpw_cnt = 0;
-        monitor_tmc_driver(stepperZ2, TMC_Z, z2_otpw_cnt);
+        monitor_tmc_driver(stepperZ2);
       #endif
       #if HAS_HW_COMMS(Z3)
-        static uint8_t z3_otpw_cnt = 0;
-        monitor_tmc_driver(stepperZ3, TMC_Z, z3_otpw_cnt);
+        monitor_tmc_driver(stepperZ3);
       #endif
       #if HAS_HW_COMMS(E0)
-        static uint8_t e0_otpw_cnt = 0;
-        monitor_tmc_driver(stepperE0, TMC_E0, e0_otpw_cnt);
+        monitor_tmc_driver(stepperE0);
       #endif
       #if HAS_HW_COMMS(E1)
-        static uint8_t e1_otpw_cnt = 0;
-        monitor_tmc_driver(stepperE1, TMC_E1, e1_otpw_cnt);
+        monitor_tmc_driver(stepperE1);
       #endif
       #if HAS_HW_COMMS(E2)
-        static uint8_t e2_otpw_cnt = 0;
-        monitor_tmc_driver(stepperE2, TMC_E2, e2_otpw_cnt);
+        monitor_tmc_driver(stepperE2);
       #endif
       #if HAS_HW_COMMS(E3)
-        static uint8_t e3_otpw_cnt = 0;
-        monitor_tmc_driver(stepperE3, TMC_E3, e3_otpw_cnt);
+        monitor_tmc_driver(stepperE3);
       #endif
       #if HAS_HW_COMMS(E4)
-        static uint8_t e4_otpw_cnt = 0;
-        monitor_tmc_driver(stepperE4, TMC_E4, e4_otpw_cnt);
+        monitor_tmc_driver(stepperE4);
       #endif
       #if HAS_HW_COMMS(E5)
-        static uint8_t e5_otpw_cnt = 0;
-        monitor_tmc_driver(stepperE5, TMC_E5, e5_otpw_cnt);
+        monitor_tmc_driver(stepperE5);
       #endif
 
       if (report_tmc_status) SERIAL_EOL();
@@ -224,100 +211,6 @@ bool report_tmc_status = false;
 
 #endif // MONITOR_DRIVER_STATUS
 
-void _tmc_say_axis(const TMC_AxisEnum axis) {
-  static const char ext_X[] PROGMEM = "X", ext_Y[] PROGMEM = "Y", ext_Z[] PROGMEM = "Z"
-    #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(X_DUAL_STEPPER_DRIVERS)
-      , ext_X2[] PROGMEM = "X2"
-    #endif
-    #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-      , ext_Y2[] PROGMEM = "Y2"
-    #endif
-    #if Z_MULTI_STEPPER_DRIVERS
-      , ext_Z2[] PROGMEM = "Z2"
-      #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
-        , ext_Z3[] PROGMEM = "Z3"
-      #endif
-    #endif
-    #if E_STEPPERS
-      , ext_E0[] PROGMEM = "E0"
-      #if E_STEPPERS > 1
-        , ext_E1[] PROGMEM = "E1"
-        #if E_STEPPERS > 2
-          , ext_E2[] PROGMEM = "E2"
-          #if E_STEPPERS > 3
-            , ext_E3[] PROGMEM = "E3"
-            #if E_STEPPERS > 4
-              , ext_E4[] PROGMEM = "E4"
-              #if E_STEPPERS > 5
-                , ext_E5[] PROGMEM = "E5"
-              #endif
-            #endif
-          #endif
-        #endif
-      #endif
-    #endif
-  ;
-
-  static PGM_P const tmc_axes[] PROGMEM = {
-    ext_X, ext_Y, ext_Z
-    #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(X_DUAL_STEPPER_DRIVERS)
-      , ext_X2
-    #endif
-    #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
-      , ext_Y2
-    #endif
-    #if Z_MULTI_STEPPER_DRIVERS
-      , ext_Z2
-      #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
-        , ext_Z3
-      #endif
-    #endif
-    #if E_STEPPERS
-      , ext_E0
-      #if E_STEPPERS > 1
-        , ext_E1
-        #if E_STEPPERS > 2
-          , ext_E2
-          #if E_STEPPERS > 3
-            , ext_E3
-            #if E_STEPPERS > 4
-              , ext_E4
-              #if E_STEPPERS > 5
-                , ext_E5
-              #endif
-            #endif
-          #endif
-        #endif
-      #endif
-    #endif
-  };
-  serialprintPGM((char*)pgm_read_ptr(&tmc_axes[axis]));
-}
-
-void _tmc_say_current(const TMC_AxisEnum axis, const uint16_t curr) {
-  _tmc_say_axis(axis);
-  SERIAL_ECHOLNPAIR(" driver current: ", curr);
-}
-void _tmc_say_otpw(const TMC_AxisEnum axis, const bool otpw) {
-  _tmc_say_axis(axis);
-  SERIAL_ECHOPGM(" temperature prewarn triggered: ");
-  serialprintPGM(otpw ? PSTR("true") : PSTR("false"));
-  SERIAL_EOL();
-}
-void _tmc_say_otpw_cleared(const TMC_AxisEnum axis) {
-  _tmc_say_axis(axis);
-  SERIAL_ECHOLNPGM(" prewarn flag cleared");
-}
-void _tmc_say_pwmthrs(const TMC_AxisEnum axis, const uint32_t thrs) {
-  _tmc_say_axis(axis);
-  SERIAL_ECHOLNPAIR(" stealthChop max speed: ", thrs);
-}
-void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
-  _tmc_say_axis(axis);
-  SERIAL_ECHOPGM(" homing sensitivity: ");
-  SERIAL_PRINTLN(sgt, DEC);
-}
-
 #if ENABLED(TMC_DEBUG)
 
   enum TMC_debug_enum : char {
@@ -366,9 +259,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
     TMC_S2VSB,
     TMC_S2VSA
   };
-  static void drv_status_print_hex(const TMC_AxisEnum axis, const uint32_t drv_status) {
-    _tmc_say_axis(axis);
-    SERIAL_ECHOPGM(" = 0x");
+  static void drv_status_print_hex(const uint32_t drv_status) {
     for (int B = 24; B >= 8; B -= 8){
       SERIAL_PRINT((drv_status >> (B + 4)) & 0xF, HEX);
       SERIAL_PRINT((drv_status >> B) & 0xF, HEX);
@@ -379,17 +270,19 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
     SERIAL_EOL();
   }
 
+  template<class TMC>
+  static void print_vsense(TMC &st) { serialprintPGM(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); }
+
   #if HAS_DRIVER(TMC2130)
     static void tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
       switch (i) {
         case TMC_PWM_SCALE: SERIAL_PRINT(st.PWM_SCALE(), DEC); break;
-        case TMC_TSTEP: SERIAL_ECHO(st.TSTEP()); break;
         case TMC_SGT: SERIAL_PRINT(st.sgt(), DEC); break;
-        case TMC_STEALTHCHOP: serialprintPGM(st.stealthChop() ? PSTR("true") : PSTR("false")); break;
+        case TMC_STEALTHCHOP: serialprintPGM(st.en_pwm_mode() ? PSTR("true") : PSTR("false")); break;
         default: break;
       }
     }
-    static void tmc_parse_drv_status(TMC2130Stepper &st, const TMC_drv_status_enum i) {
+    static void _tmc_parse_drv_status(TMC2130Stepper &st, const TMC_drv_status_enum i) {
       switch (i) {
         case TMC_STALLGUARD: if (st.stallguard()) SERIAL_CHAR('X'); break;
         case TMC_SG_RESULT:  SERIAL_PRINT(st.sg_result(), DEC);   break;
@@ -402,7 +295,6 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
   #if HAS_DRIVER(TMC2208)
     static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
       switch (i) {
-        case TMC_TSTEP: { uint32_t data = 0; st.TSTEP(&data); SERIAL_PROTOCOL(data); break; }
         case TMC_PWM_SCALE: SERIAL_PRINT(st.pwm_scale_sum(), DEC); break;
         case TMC_STEALTHCHOP: serialprintPGM(st.stealth() ? PSTR("true") : PSTR("false")); break;
         case TMC_S2VSA: if (st.s2vsa()) SERIAL_CHAR('X'); break;
@@ -410,7 +302,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
         default: break;
       }
     }
-    static void tmc_parse_drv_status(TMC2208Stepper &st, const TMC_drv_status_enum i) {
+    static void _tmc_parse_drv_status(TMC2208Stepper &st, const TMC_drv_status_enum i) {
       switch (i) {
         case TMC_T157: if (st.t157()) SERIAL_CHAR('X'); break;
         case TMC_T150: if (st.t150()) SERIAL_CHAR('X'); break;
@@ -422,12 +314,12 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
   #endif
 
   template <typename TMC>
-  static void tmc_status(TMC &st, const TMC_AxisEnum axis, const TMC_debug_enum i, const float spmm) {
+  static void tmc_status(TMC &st, const TMC_debug_enum i, const float spmm) {
     SERIAL_ECHO('\t');
     switch (i) {
-      case TMC_CODES: _tmc_say_axis(axis); break;
+      case TMC_CODES: st.printLabel(); break;
       case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
-      case TMC_CURRENT: SERIAL_ECHO(st.getCurrent()); break;
+      case TMC_CURRENT: SERIAL_ECHO(st.getMilliamps()); break;
       case TMC_RMS_CURRENT: SERIAL_PROTOCOL(st.rms_current()); break;
       case TMC_MAX_CURRENT: SERIAL_PRINT((float)st.rms_current() * 1.41, 0); break;
       case TMC_IRUN:
@@ -442,10 +334,9 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
         SERIAL_PRINT(st.cs_actual(), DEC);
         SERIAL_ECHOPGM("/31");
         break;
-
-      case TMC_VSENSE: serialprintPGM(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); break;
-
+      case TMC_VSENSE: print_vsense(st); break;
       case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
+      case TMC_TSTEP: SERIAL_ECHO(st.TSTEP()); break;
       case TMC_TPWMTHRS: {
           uint32_t tpwmthrs_val = st.TPWMTHRS();
           SERIAL_ECHO(tpwmthrs_val);
@@ -470,10 +361,10 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
   }
 
   template <typename TMC>
-  static void tmc_parse_drv_status(TMC &st, const TMC_AxisEnum axis, const TMC_drv_status_enum i) {
+  static void tmc_parse_drv_status(TMC &st, const TMC_drv_status_enum i) {
     SERIAL_CHAR('\t');
     switch (i) {
-      case TMC_DRV_CODES:     _tmc_say_axis(axis);  break;
+      case TMC_DRV_CODES:     st.printLabel();  break;
       case TMC_STST:          if (st.stst())         SERIAL_CHAR('X'); break;
       case TMC_OLB:           if (st.olb())          SERIAL_CHAR('X'); break;
       case TMC_OLA:           if (st.ola())          SERIAL_CHAR('X'); break;
@@ -482,69 +373,73 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
       case TMC_DRV_OTPW:      if (st.otpw())         SERIAL_CHAR('X'); break;
       case TMC_OT:            if (st.ot())           SERIAL_CHAR('X'); break;
       case TMC_DRV_CS_ACTUAL: SERIAL_PRINT(st.cs_actual(), DEC);       break;
-      case TMC_DRV_STATUS_HEX:drv_status_print_hex(axis, st.DRV_STATUS()); break;
-      default: tmc_parse_drv_status(st, i); break;
+      case TMC_DRV_STATUS_HEX:
+        st.printLabel();
+        SERIAL_ECHOPGM("\t0x");
+        drv_status_print_hex(st.DRV_STATUS());
+        break;
+      default: _tmc_parse_drv_status(st, i); break;
     }
   }
 
   static void tmc_debug_loop(const TMC_debug_enum i) {
     #if AXIS_IS_TMC(X)
-      tmc_status(stepperX, TMC_X, i, planner.axis_steps_per_mm[X_AXIS]);
+      tmc_status(stepperX, i, planner.axis_steps_per_mm[X_AXIS]);
     #endif
     #if AXIS_IS_TMC(X2)
-      tmc_status(stepperX2, TMC_X2, i, planner.axis_steps_per_mm[X_AXIS]);
+      tmc_status(stepperX2, i, planner.axis_steps_per_mm[X_AXIS]);
     #endif
 
     #if AXIS_IS_TMC(Y)
-      tmc_status(stepperY, TMC_Y, i, planner.axis_steps_per_mm[Y_AXIS]);
+      tmc_status(stepperY, i, planner.axis_steps_per_mm[Y_AXIS]);
     #endif
     #if AXIS_IS_TMC(Y2)
-      tmc_status(stepperY2, TMC_Y2, i, planner.axis_steps_per_mm[Y_AXIS]);
+      tmc_status(stepperY2, i, planner.axis_steps_per_mm[Y_AXIS]);
     #endif
 
     #if AXIS_IS_TMC(Z)
-      tmc_status(stepperZ, TMC_Z, i, planner.axis_steps_per_mm[Z_AXIS]);
+      tmc_status(stepperZ, i, planner.axis_steps_per_mm[Z_AXIS]);
     #endif
     #if AXIS_IS_TMC(Z2)
-      tmc_status(stepperZ2, TMC_Z2, i, planner.axis_steps_per_mm[Z_AXIS]);
+      tmc_status(stepperZ2, i, planner.axis_steps_per_mm[Z_AXIS]);
     #endif
     #if AXIS_IS_TMC(Z3)
-      tmc_status(stepperZ3, TMC_Z3, i, planner.axis_steps_per_mm[Z_AXIS]);
+      tmc_status(stepperZ3, i, planner.axis_steps_per_mm[Z_AXIS]);
     #endif
 
     #if AXIS_IS_TMC(E0)
-      tmc_status(stepperE0, TMC_E0, i, planner.axis_steps_per_mm[E_AXIS]);
+      tmc_status(stepperE0, i, planner.axis_steps_per_mm[E_AXIS]);
     #endif
     #if AXIS_IS_TMC(E1)
-      tmc_status(stepperE1, TMC_E1, i, planner.axis_steps_per_mm[E_AXIS
+      tmc_status(stepperE1, i, planner.axis_steps_per_mm[E_AXIS
         #if ENABLED(DISTINCT_E_FACTORS)
           + 1
         #endif
       ]);
     #endif
     #if AXIS_IS_TMC(E2)
-      tmc_status(stepperE2, TMC_E2, i, planner.axis_steps_per_mm[E_AXIS
+      tmc_status(stepperE2, i, planner.axis_steps_per_mm[E_AXIS
         #if ENABLED(DISTINCT_E_FACTORS)
           + 2
         #endif
       ]);
     #endif
     #if AXIS_IS_TMC(E3)
-      tmc_status(stepperE3, TMC_E3, i, planner.axis_steps_per_mm[E_AXIS
+      tmc_status(stepperE3, i, planner.axis_steps_per_mm[E_AXIS
         #if ENABLED(DISTINCT_E_FACTORS)
           + 3
         #endif
       ]);
     #endif
     #if AXIS_IS_TMC(E4)
-      tmc_status(stepperE4, TMC_E4, i, planner.axis_steps_per_mm[E_AXIS
+      tmc_status(stepperE4, i, planner.axis_steps_per_mm[E_AXIS
         #if ENABLED(DISTINCT_E_FACTORS)
           + 4
         #endif
       ]);
     #endif
     #if AXIS_IS_TMC(E5)
-      tmc_status(stepperE5, TMC_E5, i, planner.axis_steps_per_mm[E_AXIS
+      tmc_status(stepperE5, i, planner.axis_steps_per_mm[E_AXIS
         #if ENABLED(DISTINCT_E_FACTORS)
           + 5
         #endif
@@ -556,46 +451,46 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
 
   static void drv_status_loop(const TMC_drv_status_enum i) {
     #if AXIS_IS_TMC(X)
-      tmc_parse_drv_status(stepperX, TMC_X, i);
+      tmc_parse_drv_status(stepperX, i);
     #endif
     #if AXIS_IS_TMC(X2)
-      tmc_parse_drv_status(stepperX2, TMC_X2, i);
+      tmc_parse_drv_status(stepperX2, i);
     #endif
 
     #if AXIS_IS_TMC(Y)
-      tmc_parse_drv_status(stepperY, TMC_Y, i);
+      tmc_parse_drv_status(stepperY, i);
     #endif
     #if AXIS_IS_TMC(Y2)
-      tmc_parse_drv_status(stepperY2, TMC_Y2, i);
+      tmc_parse_drv_status(stepperY2, i);
     #endif
 
     #if AXIS_IS_TMC(Z)
-      tmc_parse_drv_status(stepperZ, TMC_Z, i);
+      tmc_parse_drv_status(stepperZ, i);
     #endif
     #if AXIS_IS_TMC(Z2)
-      tmc_parse_drv_status(stepperZ2, TMC_Z2, i);
+      tmc_parse_drv_status(stepperZ2, i);
     #endif
     #if AXIS_IS_TMC(Z3)
-      tmc_parse_drv_status(stepperZ3, TMC_Z3, i);
+      tmc_parse_drv_status(stepperZ3, i);
     #endif
 
     #if AXIS_IS_TMC(E0)
-      tmc_parse_drv_status(stepperE0, TMC_E0, i);
+      tmc_parse_drv_status(stepperE0, i);
     #endif
     #if AXIS_IS_TMC(E1)
-      tmc_parse_drv_status(stepperE1, TMC_E1, i);
+      tmc_parse_drv_status(stepperE1, i);
     #endif
     #if AXIS_IS_TMC(E2)
-      tmc_parse_drv_status(stepperE2, TMC_E2, i);
+      tmc_parse_drv_status(stepperE2, i);
     #endif
     #if AXIS_IS_TMC(E3)
-      tmc_parse_drv_status(stepperE3, TMC_E3, i);
+      tmc_parse_drv_status(stepperE3, i);
     #endif
     #if AXIS_IS_TMC(E4)
-      tmc_parse_drv_status(stepperE4, TMC_E4, i);
+      tmc_parse_drv_status(stepperE4, i);
     #endif
     #if AXIS_IS_TMC(E5)
-      tmc_parse_drv_status(stepperE5, TMC_E5, i);
+      tmc_parse_drv_status(stepperE5, i);
     #endif
 
     SERIAL_EOL();
@@ -620,7 +515,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
     TMC_REPORT("Run current",        TMC_IRUN);
     TMC_REPORT("Hold current",       TMC_IHOLD);
     TMC_REPORT("CS actual\t",        TMC_CS_ACTUAL);
-    TMC_REPORT("PWM scale\t",        TMC_PWM_SCALE);
+    TMC_REPORT("PWM scale",          TMC_PWM_SCALE);
     TMC_REPORT("vsense\t",           TMC_VSENSE);
     TMC_REPORT("stealthChop",        TMC_STEALTHCHOP);
     TMC_REPORT("msteps\t",           TMC_MICROSTEPS);
@@ -657,7 +552,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
       DRV_REPORT("s2vsa\t",          TMC_S2VSA);
       DRV_REPORT("s2vsb\t",          TMC_S2VSB);
     #endif
-    DRV_REPORT("Driver registers:",  TMC_DRV_STATUS_HEX);
+    DRV_REPORT("Driver registers:\n",TMC_DRV_STATUS_HEX);
     SERIAL_EOL();
   }
 
@@ -666,9 +561,9 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
 #if USE_SENSORLESS
 
   void tmc_stallguard(TMC2130Stepper &st, const bool enable/*=true*/) {
-    st.coolstep_min_speed(enable ? 1024UL * 1024UL - 1UL : 0);
+    st.TCOOLTHRS(enable ? 0xFFFFF : 0);
     #if ENABLED(STEALTHCHOP)
-      st.stealthChop(!enable);
+      st.en_pwm_mode(!enable);
     #endif
     st.diag1_stall(enable ? 1 : 0);
   }
@@ -676,45 +571,46 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
 #endif // USE_SENSORLESS
 
 #if HAS_DRIVER(TMC2130)
+  #define IS_TMC_SPI(ST) AXIS_DRIVER_TYPE(ST, TMC2130)
   #define SET_CS_PIN(st) OUT_WRITE(st##_CS_PIN, HIGH)
   void tmc_init_cs_pins() {
-    #if AXIS_DRIVER_TYPE(X, TMC2130)
+    #if IS_TMC_SPI(X)
       SET_CS_PIN(X);
     #endif
-    #if AXIS_DRIVER_TYPE(Y, TMC2130)
+    #if IS_TMC_SPI(Y)
       SET_CS_PIN(Y);
     #endif
-    #if AXIS_DRIVER_TYPE(Z, TMC2130)
+    #if IS_TMC_SPI(Z)
       SET_CS_PIN(Z);
     #endif
-    #if AXIS_DRIVER_TYPE(X2, TMC2130)
+    #if IS_TMC_SPI(X2)
       SET_CS_PIN(X2);
     #endif
-    #if AXIS_DRIVER_TYPE(Y2, TMC2130)
+    #if IS_TMC_SPI(Y2)
       SET_CS_PIN(Y2);
     #endif
-    #if AXIS_DRIVER_TYPE(Z2, TMC2130)
+    #if IS_TMC_SPI(Z2)
       SET_CS_PIN(Z2);
     #endif
-    #if AXIS_DRIVER_TYPE(Z3, TMC2130)
+    #if IS_TMC_SPI(Z3)
       SET_CS_PIN(Z3);
     #endif
-    #if AXIS_DRIVER_TYPE(E0, TMC2130)
+    #if IS_TMC_SPI(E0)
       SET_CS_PIN(E0);
     #endif
-    #if AXIS_DRIVER_TYPE(E1, TMC2130)
+    #if IS_TMC_SPI(E1)
       SET_CS_PIN(E1);
     #endif
-    #if AXIS_DRIVER_TYPE(E2, TMC2130)
+    #if IS_TMC_SPI(E2)
       SET_CS_PIN(E2);
     #endif
-    #if AXIS_DRIVER_TYPE(E3, TMC2130)
+    #if IS_TMC_SPI(E3)
       SET_CS_PIN(E3);
     #endif
-    #if AXIS_DRIVER_TYPE(E4, TMC2130)
+    #if IS_TMC_SPI(E4)
       SET_CS_PIN(E4);
     #endif
-    #if AXIS_DRIVER_TYPE(E5, TMC2130)
+    #if IS_TMC_SPI(E5)
       SET_CS_PIN(E5);
     #endif
   }

commit 11ac75edcb34a2f90b50ca134ff40839f8c29199
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 30 23:44:33 2018 -0500

    Use PGM_P for PSTR pointers (#11977)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index e4c4872e2e..9cc81f9dfe 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -258,7 +258,7 @@ void _tmc_say_axis(const TMC_AxisEnum axis) {
     #endif
   ;
 
-  static const char* const tmc_axes[] PROGMEM = {
+  static PGM_P const tmc_axes[] PROGMEM = {
     ext_X, ext_Y, ext_Z
     #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(X_DUAL_STEPPER_DRIVERS)
       , ext_X2

commit 3286325044a7788f12ceb3f3d6cef00dc8b32433
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sun Sep 9 15:59:12 2018 -0400

    Add TMC2130 sensorless probing

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index abfe4ba035..e4c4872e2e 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -663,9 +663,9 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
 
 #endif // TMC_DEBUG
 
-#if ENABLED(SENSORLESS_HOMING)
+#if USE_SENSORLESS
 
-  void tmc_sensorless_homing(TMC2130Stepper &st, const bool enable/*=true*/) {
+  void tmc_stallguard(TMC2130Stepper &st, const bool enable/*=true*/) {
     st.coolstep_min_speed(enable ? 1024UL * 1024UL - 1UL : 0);
     #if ENABLED(STEALTHCHOP)
       st.stealthChop(!enable);
@@ -673,7 +673,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
     st.diag1_stall(enable ? 1 : 0);
   }
 
-#endif // SENSORLESS_HOMING
+#endif // USE_SENSORLESS
 
 #if HAS_DRIVER(TMC2130)
   #define SET_CS_PIN(st) OUT_WRITE(st##_CS_PIN, HIGH)

commit 65045ba54b7d0b23b07ddb8b1064ead25643b0a4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 17 05:36:17 2018 -0500

    tmc_util fix part 2
    
    Followup to 115abf9

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 05e18fd8d4..abfe4ba035 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -225,7 +225,7 @@ bool report_tmc_status = false;
 #endif // MONITOR_DRIVER_STATUS
 
 void _tmc_say_axis(const TMC_AxisEnum axis) {
-  static const char ext_X[] PROGMEM = "X", ext_Y[] PROGMEM = "Y", ext_Z[] PROGMEM = "Z",
+  static const char ext_X[] PROGMEM = "X", ext_Y[] PROGMEM = "Y", ext_Z[] PROGMEM = "Z"
     #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(X_DUAL_STEPPER_DRIVERS)
       , ext_X2[] PROGMEM = "X2"
     #endif

commit 115abf9c534004a962a100c48bd1c0da8be78f48
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 17 01:10:14 2018 -0500

    Fix syntax error in front of `tmc_axes`

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index c005650b6d..05e18fd8d4 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -256,6 +256,7 @@ void _tmc_say_axis(const TMC_AxisEnum axis) {
         #endif
       #endif
     #endif
+  ;
 
   static const char* const tmc_axes[] PROGMEM = {
     ext_X, ext_Y, ext_Z

commit 1718eff54adefc7cc95851f28df0c7e02eae3a36
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 13 01:35:55 2018 -0500

    Code changes supporting up to 6 extruders

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 01418bfd98..c005650b6d 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -213,6 +213,10 @@ bool report_tmc_status = false;
         static uint8_t e4_otpw_cnt = 0;
         monitor_tmc_driver(stepperE4, TMC_E4, e4_otpw_cnt);
       #endif
+      #if HAS_HW_COMMS(E5)
+        static uint8_t e5_otpw_cnt = 0;
+        monitor_tmc_driver(stepperE5, TMC_E5, e5_otpw_cnt);
+      #endif
 
       if (report_tmc_status) SERIAL_EOL();
     }
@@ -244,6 +248,9 @@ void _tmc_say_axis(const TMC_AxisEnum axis) {
             , ext_E3[] PROGMEM = "E3"
             #if E_STEPPERS > 4
               , ext_E4[] PROGMEM = "E4"
+              #if E_STEPPERS > 5
+                , ext_E5[] PROGMEM = "E5"
+              #endif
             #endif
           #endif
         #endif
@@ -274,6 +281,9 @@ void _tmc_say_axis(const TMC_AxisEnum axis) {
             , ext_E3
             #if E_STEPPERS > 4
               , ext_E4
+              #if E_STEPPERS > 5
+                , ext_E5
+              #endif
             #endif
           #endif
         #endif
@@ -532,6 +542,13 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
         #endif
       ]);
     #endif
+    #if AXIS_IS_TMC(E5)
+      tmc_status(stepperE5, TMC_E5, i, planner.axis_steps_per_mm[E_AXIS
+        #if ENABLED(DISTINCT_E_FACTORS)
+          + 5
+        #endif
+      ]);
+    #endif
 
     SERIAL_EOL();
   }
@@ -576,6 +593,9 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
     #if AXIS_IS_TMC(E4)
       tmc_parse_drv_status(stepperE4, TMC_E4, i);
     #endif
+    #if AXIS_IS_TMC(E5)
+      tmc_parse_drv_status(stepperE5, TMC_E5, i);
+    #endif
 
     SERIAL_EOL();
   }
@@ -693,6 +713,9 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
     #if AXIS_DRIVER_TYPE(E4, TMC2130)
       SET_CS_PIN(E4);
     #endif
+    #if AXIS_DRIVER_TYPE(E5, TMC2130)
+      SET_CS_PIN(E5);
+    #endif
   }
 #endif // TMC2130
 

commit 1a6f2b29b8dd3bc8e6ef56d4f376f49cacfc8785
Author: Holger MuÃàller <holger@mueller-gelff.de>
Date:   Tue Jun 19 18:55:49 2018 +0200

    Add support for Triple-Z steppers/endstops

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 1995201922..01418bfd98 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -189,6 +189,10 @@ bool report_tmc_status = false;
         static uint8_t z2_otpw_cnt = 0;
         monitor_tmc_driver(stepperZ2, TMC_Z, z2_otpw_cnt);
       #endif
+      #if HAS_HW_COMMS(Z3)
+        static uint8_t z3_otpw_cnt = 0;
+        monitor_tmc_driver(stepperZ3, TMC_Z, z3_otpw_cnt);
+      #endif
       #if HAS_HW_COMMS(E0)
         static uint8_t e0_otpw_cnt = 0;
         monitor_tmc_driver(stepperE0, TMC_E0, e0_otpw_cnt);
@@ -217,12 +221,65 @@ bool report_tmc_status = false;
 #endif // MONITOR_DRIVER_STATUS
 
 void _tmc_say_axis(const TMC_AxisEnum axis) {
-  static const char ext_X[]  PROGMEM = "X",  ext_Y[]  PROGMEM = "Y",  ext_Z[]  PROGMEM = "Z",
-                    ext_X2[] PROGMEM = "X2", ext_Y2[] PROGMEM = "Y2", ext_Z2[] PROGMEM = "Z2",
-                    ext_E0[] PROGMEM = "E0", ext_E1[] PROGMEM = "E1",
-                    ext_E2[] PROGMEM = "E2", ext_E3[] PROGMEM = "E3",
-                    ext_E4[] PROGMEM = "E4";
-  static const char* const tmc_axes[] PROGMEM = { ext_X, ext_Y, ext_Z, ext_X2, ext_Y2, ext_Z2, ext_E0, ext_E1, ext_E2, ext_E3, ext_E4 };
+  static const char ext_X[] PROGMEM = "X", ext_Y[] PROGMEM = "Y", ext_Z[] PROGMEM = "Z",
+    #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(X_DUAL_STEPPER_DRIVERS)
+      , ext_X2[] PROGMEM = "X2"
+    #endif
+    #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+      , ext_Y2[] PROGMEM = "Y2"
+    #endif
+    #if Z_MULTI_STEPPER_DRIVERS
+      , ext_Z2[] PROGMEM = "Z2"
+      #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+        , ext_Z3[] PROGMEM = "Z3"
+      #endif
+    #endif
+    #if E_STEPPERS
+      , ext_E0[] PROGMEM = "E0"
+      #if E_STEPPERS > 1
+        , ext_E1[] PROGMEM = "E1"
+        #if E_STEPPERS > 2
+          , ext_E2[] PROGMEM = "E2"
+          #if E_STEPPERS > 3
+            , ext_E3[] PROGMEM = "E3"
+            #if E_STEPPERS > 4
+              , ext_E4[] PROGMEM = "E4"
+            #endif
+          #endif
+        #endif
+      #endif
+    #endif
+
+  static const char* const tmc_axes[] PROGMEM = {
+    ext_X, ext_Y, ext_Z
+    #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(X_DUAL_STEPPER_DRIVERS)
+      , ext_X2
+    #endif
+    #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
+      , ext_Y2
+    #endif
+    #if Z_MULTI_STEPPER_DRIVERS
+      , ext_Z2
+      #if ENABLED(Z_TRIPLE_STEPPER_DRIVERS)
+        , ext_Z3
+      #endif
+    #endif
+    #if E_STEPPERS
+      , ext_E0
+      #if E_STEPPERS > 1
+        , ext_E1
+        #if E_STEPPERS > 2
+          , ext_E2
+          #if E_STEPPERS > 3
+            , ext_E3
+            #if E_STEPPERS > 4
+              , ext_E4
+            #endif
+          #endif
+        #endif
+      #endif
+    #endif
+  };
   serialprintPGM((char*)pgm_read_ptr(&tmc_axes[axis]));
 }
 
@@ -440,6 +497,9 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
     #if AXIS_IS_TMC(Z2)
       tmc_status(stepperZ2, TMC_Z2, i, planner.axis_steps_per_mm[Z_AXIS]);
     #endif
+    #if AXIS_IS_TMC(Z3)
+      tmc_status(stepperZ3, TMC_Z3, i, planner.axis_steps_per_mm[Z_AXIS]);
+    #endif
 
     #if AXIS_IS_TMC(E0)
       tmc_status(stepperE0, TMC_E0, i, planner.axis_steps_per_mm[E_AXIS]);
@@ -497,6 +557,9 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
     #if AXIS_IS_TMC(Z2)
       tmc_parse_drv_status(stepperZ2, TMC_Z2, i);
     #endif
+    #if AXIS_IS_TMC(Z3)
+      tmc_parse_drv_status(stepperZ3, TMC_Z3, i);
+    #endif
 
     #if AXIS_IS_TMC(E0)
       tmc_parse_drv_status(stepperE0, TMC_E0, i);
@@ -612,6 +675,9 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
     #if AXIS_DRIVER_TYPE(Z2, TMC2130)
       SET_CS_PIN(Z2);
     #endif
+    #if AXIS_DRIVER_TYPE(Z3, TMC2130)
+      SET_CS_PIN(Z3);
+    #endif
     #if AXIS_DRIVER_TYPE(E0, TMC2130)
       SET_CS_PIN(E0);
     #endif

commit 2a61c9a9394c68b6eb26433f15f1bca9fe128da4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 6 05:33:16 2018 -0500

    Various fixups to configs, spacing, etc.

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index c7d6cacb10..1995201922 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -130,7 +130,7 @@ bool report_tmc_status = false;
     #if CURRENT_STEP_DOWN > 0
       // Decrease current if is_otpw is true and driver is enabled and there's been more than 4 warnings
       if (data.is_otpw && st.isEnabled() && otpw_cnt > 4) {
-        st.setCurrent(st.getCurrent() - CURRENT_STEP_DOWN, R_SENSE, HOLD_MULTIPLIER);
+        st.setCurrent(st.getCurrent() - (CURRENT_STEP_DOWN), R_SENSE, HOLD_MULTIPLIER);
         #if ENABLED(REPORT_CURRENT_CHANGE)
           _tmc_say_axis(axis);
           SERIAL_ECHOLNPAIR(" current decreased to ", st.getCurrent());

commit fbcdf5eaeb4f2265fd43097ab6c652a89842d8e7
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sat Jul 14 14:13:06 2018 +0300

    Simplify stepper driver per-axis selection

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index a5dc428592..c7d6cacb10 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -52,7 +52,7 @@ bool report_tmc_status = false;
     bool is_ot;
     bool is_error;
   };
-  #if ENABLED(HAVE_TMC2130)
+  #if HAS_DRIVER(TMC2130)
     static uint32_t get_pwm_scale(TMC2130Stepper &st) { return st.PWM_SCALE(); }
     static uint8_t get_status_response(TMC2130Stepper &st) { return st.status_response & 0xF; }
     static TMC_driver_data get_driver_data(TMC2130Stepper &st) {
@@ -70,7 +70,7 @@ bool report_tmc_status = false;
       return data;
     }
   #endif
-  #if ENABLED(HAVE_TMC2208)
+  #if HAS_DRIVER(TMC2208)
     static uint32_t get_pwm_scale(TMC2208Stepper &st) { return st.pwm_scale_sum(); }
     static uint8_t get_status_response(TMC2208Stepper &st) {
       uint32_t drv_status = st.DRV_STATUS();
@@ -159,21 +159,21 @@ bool report_tmc_status = false;
     }
   }
 
-  #define HAS_HW_COMMS(ST) ENABLED(ST##_IS_TMC2130)|| (ENABLED(ST##_IS_TMC2208) && defined(ST##_HARDWARE_SERIAL))
+  #define HAS_HW_COMMS(ST) AXIS_DRIVER_TYPE(ST, TMC2130) || (AXIS_DRIVER_TYPE(ST, TMC2208) && defined(ST##_HARDWARE_SERIAL))
 
   void monitor_tmc_driver() {
     static millis_t next_cOT = 0;
     if (ELAPSED(millis(), next_cOT)) {
       next_cOT = millis() + 500;
-      #if HAS_HW_COMMS(X) || ENABLED(IS_TRAMS)
+      #if HAS_HW_COMMS(X)
         static uint8_t x_otpw_cnt = 0;
         monitor_tmc_driver(stepperX, TMC_X, x_otpw_cnt);
       #endif
-      #if HAS_HW_COMMS(Y) || ENABLED(IS_TRAMS)
+      #if HAS_HW_COMMS(Y)
         static uint8_t y_otpw_cnt = 0;
         monitor_tmc_driver(stepperY, TMC_Y, y_otpw_cnt);
       #endif
-      #if HAS_HW_COMMS(Z) || ENABLED(IS_TRAMS)
+      #if HAS_HW_COMMS(Z)
         static uint8_t z_otpw_cnt = 0;
         monitor_tmc_driver(stepperZ, TMC_Z, z_otpw_cnt);
       #endif
@@ -189,7 +189,7 @@ bool report_tmc_status = false;
         static uint8_t z2_otpw_cnt = 0;
         monitor_tmc_driver(stepperZ2, TMC_Z, z2_otpw_cnt);
       #endif
-      #if HAS_HW_COMMS(E0) || ENABLED(IS_TRAMS)
+      #if HAS_HW_COMMS(E0)
         static uint8_t e0_otpw_cnt = 0;
         monitor_tmc_driver(stepperE0, TMC_E0, e0_otpw_cnt);
       #endif
@@ -311,7 +311,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
     SERIAL_EOL();
   }
 
-  #if ENABLED(HAVE_TMC2130)
+  #if HAS_DRIVER(TMC2130)
     static void tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
       switch (i) {
         case TMC_PWM_SCALE: SERIAL_PRINT(st.PWM_SCALE(), DEC); break;
@@ -331,7 +331,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
     }
   #endif
 
-  #if ENABLED(HAVE_TMC2208)
+  #if HAS_DRIVER(TMC2208)
     static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
       switch (i) {
         case TMC_TSTEP: { uint32_t data = 0; st.TSTEP(&data); SERIAL_PROTOCOL(data); break; }
@@ -420,52 +420,52 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
   }
 
   static void tmc_debug_loop(const TMC_debug_enum i) {
-    #if X_IS_TRINAMIC
+    #if AXIS_IS_TMC(X)
       tmc_status(stepperX, TMC_X, i, planner.axis_steps_per_mm[X_AXIS]);
     #endif
-    #if X2_IS_TRINAMIC
+    #if AXIS_IS_TMC(X2)
       tmc_status(stepperX2, TMC_X2, i, planner.axis_steps_per_mm[X_AXIS]);
     #endif
 
-    #if Y_IS_TRINAMIC
+    #if AXIS_IS_TMC(Y)
       tmc_status(stepperY, TMC_Y, i, planner.axis_steps_per_mm[Y_AXIS]);
     #endif
-    #if Y2_IS_TRINAMIC
+    #if AXIS_IS_TMC(Y2)
       tmc_status(stepperY2, TMC_Y2, i, planner.axis_steps_per_mm[Y_AXIS]);
     #endif
 
-    #if Z_IS_TRINAMIC
+    #if AXIS_IS_TMC(Z)
       tmc_status(stepperZ, TMC_Z, i, planner.axis_steps_per_mm[Z_AXIS]);
     #endif
-    #if Z2_IS_TRINAMIC
+    #if AXIS_IS_TMC(Z2)
       tmc_status(stepperZ2, TMC_Z2, i, planner.axis_steps_per_mm[Z_AXIS]);
     #endif
 
-    #if E0_IS_TRINAMIC
+    #if AXIS_IS_TMC(E0)
       tmc_status(stepperE0, TMC_E0, i, planner.axis_steps_per_mm[E_AXIS]);
     #endif
-    #if E1_IS_TRINAMIC
+    #if AXIS_IS_TMC(E1)
       tmc_status(stepperE1, TMC_E1, i, planner.axis_steps_per_mm[E_AXIS
         #if ENABLED(DISTINCT_E_FACTORS)
           + 1
         #endif
       ]);
     #endif
-    #if E2_IS_TRINAMIC
+    #if AXIS_IS_TMC(E2)
       tmc_status(stepperE2, TMC_E2, i, planner.axis_steps_per_mm[E_AXIS
         #if ENABLED(DISTINCT_E_FACTORS)
           + 2
         #endif
       ]);
     #endif
-    #if E3_IS_TRINAMIC
+    #if AXIS_IS_TMC(E3)
       tmc_status(stepperE3, TMC_E3, i, planner.axis_steps_per_mm[E_AXIS
         #if ENABLED(DISTINCT_E_FACTORS)
           + 3
         #endif
       ]);
     #endif
-    #if E4_IS_TRINAMIC
+    #if AXIS_IS_TMC(E4)
       tmc_status(stepperE4, TMC_E4, i, planner.axis_steps_per_mm[E_AXIS
         #if ENABLED(DISTINCT_E_FACTORS)
           + 4
@@ -477,40 +477,40 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
   }
 
   static void drv_status_loop(const TMC_drv_status_enum i) {
-    #if X_IS_TRINAMIC
+    #if AXIS_IS_TMC(X)
       tmc_parse_drv_status(stepperX, TMC_X, i);
     #endif
-    #if X2_IS_TRINAMIC
+    #if AXIS_IS_TMC(X2)
       tmc_parse_drv_status(stepperX2, TMC_X2, i);
     #endif
 
-    #if Y_IS_TRINAMIC
+    #if AXIS_IS_TMC(Y)
       tmc_parse_drv_status(stepperY, TMC_Y, i);
     #endif
-    #if Y2_IS_TRINAMIC
+    #if AXIS_IS_TMC(Y2)
       tmc_parse_drv_status(stepperY2, TMC_Y2, i);
     #endif
 
-    #if Z_IS_TRINAMIC
+    #if AXIS_IS_TMC(Z)
       tmc_parse_drv_status(stepperZ, TMC_Z, i);
     #endif
-    #if Z2_IS_TRINAMIC
+    #if AXIS_IS_TMC(Z2)
       tmc_parse_drv_status(stepperZ2, TMC_Z2, i);
     #endif
 
-    #if E0_IS_TRINAMIC
+    #if AXIS_IS_TMC(E0)
       tmc_parse_drv_status(stepperE0, TMC_E0, i);
     #endif
-    #if E1_IS_TRINAMIC
+    #if AXIS_IS_TMC(E1)
       tmc_parse_drv_status(stepperE1, TMC_E1, i);
     #endif
-    #if E2_IS_TRINAMIC
+    #if AXIS_IS_TMC(E2)
       tmc_parse_drv_status(stepperE2, TMC_E2, i);
     #endif
-    #if E3_IS_TRINAMIC
+    #if AXIS_IS_TMC(E3)
       tmc_parse_drv_status(stepperE3, TMC_E3, i);
     #endif
-    #if E4_IS_TRINAMIC
+    #if AXIS_IS_TMC(E4)
       tmc_parse_drv_status(stepperE4, TMC_E4, i);
     #endif
 
@@ -553,7 +553,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
     TMC_REPORT("Stallguard thrs",    TMC_SGT);
 
     DRV_REPORT("DRVSTATUS",          TMC_DRV_CODES);
-    #if ENABLED(HAVE_TMC2130)
+    #if HAS_DRIVER(TMC2130)
       DRV_REPORT("stallguard\t",     TMC_STALLGUARD);
       DRV_REPORT("sg_result\t",      TMC_SG_RESULT);
       DRV_REPORT("fsactive\t",       TMC_FSACTIVE);
@@ -565,7 +565,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
     DRV_REPORT("s2ga\t",             TMC_S2GA);
     DRV_REPORT("otpw\t",             TMC_DRV_OTPW);
     DRV_REPORT("ot\t",               TMC_OT);
-    #if ENABLED(HAVE_TMC2208)
+    #if HAS_DRIVER(TMC2208)
       DRV_REPORT("157C\t",           TMC_T157);
       DRV_REPORT("150C\t",           TMC_T150);
       DRV_REPORT("143C\t",           TMC_T143);
@@ -591,43 +591,43 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
 
 #endif // SENSORLESS_HOMING
 
-#if ENABLED(HAVE_TMC2130)
+#if HAS_DRIVER(TMC2130)
   #define SET_CS_PIN(st) OUT_WRITE(st##_CS_PIN, HIGH)
   void tmc_init_cs_pins() {
-    #if ENABLED(X_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(X, TMC2130)
       SET_CS_PIN(X);
     #endif
-    #if ENABLED(Y_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(Y, TMC2130)
       SET_CS_PIN(Y);
     #endif
-    #if ENABLED(Z_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(Z, TMC2130)
       SET_CS_PIN(Z);
     #endif
-    #if ENABLED(X2_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(X2, TMC2130)
       SET_CS_PIN(X2);
     #endif
-    #if ENABLED(Y2_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(Y2, TMC2130)
       SET_CS_PIN(Y2);
     #endif
-    #if ENABLED(Z2_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(Z2, TMC2130)
       SET_CS_PIN(Z2);
     #endif
-    #if ENABLED(E0_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(E0, TMC2130)
       SET_CS_PIN(E0);
     #endif
-    #if ENABLED(E1_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(E1, TMC2130)
       SET_CS_PIN(E1);
     #endif
-    #if ENABLED(E2_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(E2, TMC2130)
       SET_CS_PIN(E2);
     #endif
-    #if ENABLED(E3_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(E3, TMC2130)
       SET_CS_PIN(E3);
     #endif
-    #if ENABLED(E4_IS_TMC2130)
+    #if AXIS_DRIVER_TYPE(E4, TMC2130)
       SET_CS_PIN(E4);
     #endif
   }
-#endif // HAVE_TMC2130
+#endif // TMC2130
 
 #endif // HAS_TRINAMIC

commit f3fed52348005c313d5565959545fe1b3a756662
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 12 22:12:46 2018 -0500

    Fix coolstep_min_speed / sensorless homing
    
    Fix #8890

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index adfaccabbe..a5dc428592 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -582,8 +582,8 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
 #if ENABLED(SENSORLESS_HOMING)
 
   void tmc_sensorless_homing(TMC2130Stepper &st, const bool enable/*=true*/) {
+    st.coolstep_min_speed(enable ? 1024UL * 1024UL - 1UL : 0);
     #if ENABLED(STEALTHCHOP)
-      st.coolstep_min_speed(enable ? 1024UL * 1024UL - 1UL : 0);
       st.stealthChop(!enable);
     #endif
     st.diag1_stall(enable ? 1 : 0);

commit 2ba198a624d0bf0b00b044ef0d26514ab54d2a3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jun 10 20:33:11 2018 -0500

    Tweak M122 report spacing

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index d6f1d8d6b5..adfaccabbe 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -536,7 +536,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
     TMC_REPORT("Run current",        TMC_IRUN);
     TMC_REPORT("Hold current",       TMC_IHOLD);
     TMC_REPORT("CS actual\t",        TMC_CS_ACTUAL);
-    TMC_REPORT("PWM scale",          TMC_PWM_SCALE);
+    TMC_REPORT("PWM scale\t",        TMC_PWM_SCALE);
     TMC_REPORT("vsense\t",           TMC_VSENSE);
     TMC_REPORT("stealthChop",        TMC_STEALTHCHOP);
     TMC_REPORT("msteps\t",           TMC_MICROSTEPS);

commit f83361a814df875b3a5bdaadcbcba6732419c4dc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 27 00:51:28 2018 -0500

    Apply const to tmc_sensorless_homing

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 88d468af6d..d6f1d8d6b5 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -581,7 +581,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
 
 #if ENABLED(SENSORLESS_HOMING)
 
-  void tmc_sensorless_homing(TMC2130Stepper &st, bool enable/*=true*/) {
+  void tmc_sensorless_homing(TMC2130Stepper &st, const bool enable/*=true*/) {
     #if ENABLED(STEALTHCHOP)
       st.coolstep_min_speed(enable ? 1024UL * 1024UL - 1UL : 0);
       st.stealthChop(!enable);

commit 33966710119b64f83a19075875a8d27452cca9a4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 22 00:16:30 2018 -0500

    [2.0.x] Reset LCD status to fallbacks (#10470)
    
    * Remove obsolete strings
    * Tweak some static consts
    * Reset LCD status to fallbacks

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 37bd9fcc14..88d468af6d 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -217,12 +217,12 @@ bool report_tmc_status = false;
 #endif // MONITOR_DRIVER_STATUS
 
 void _tmc_say_axis(const TMC_AxisEnum axis) {
-  const static char ext_X[]  PROGMEM = "X",  ext_Y[]  PROGMEM = "Y",  ext_Z[]  PROGMEM = "Z",
+  static const char ext_X[]  PROGMEM = "X",  ext_Y[]  PROGMEM = "Y",  ext_Z[]  PROGMEM = "Z",
                     ext_X2[] PROGMEM = "X2", ext_Y2[] PROGMEM = "Y2", ext_Z2[] PROGMEM = "Z2",
                     ext_E0[] PROGMEM = "E0", ext_E1[] PROGMEM = "E1",
                     ext_E2[] PROGMEM = "E2", ext_E3[] PROGMEM = "E3",
                     ext_E4[] PROGMEM = "E4";
-  const static char* const tmc_axes[] PROGMEM = { ext_X, ext_Y, ext_Z, ext_X2, ext_Y2, ext_Z2, ext_E0, ext_E1, ext_E2, ext_E3, ext_E4 };
+  static const char* const tmc_axes[] PROGMEM = { ext_X, ext_Y, ext_Z, ext_X2, ext_Y2, ext_Z2, ext_E0, ext_E1, ext_E2, ext_E3, ext_E4 };
   serialprintPGM((char*)pgm_read_ptr(&tmc_axes[axis]));
 }
 

commit 89b158058731a8ea7a2cf4660a5347e807f033e9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 17 16:13:10 2018 -0500

    Fix compile error in tmc_status

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index d0a53c1c55..37bd9fcc14 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -385,7 +385,10 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
         break;
       case TMC_TPWMTHRS_MMS: {
           uint32_t tpwmthrs_val = st.TPWMTHRS();
-          tpwmthrs_val ? SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm)) : (void)SERIAL_CHAR('-');
+          if (tpwmthrs_val)
+            SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm));
+          else
+            SERIAL_CHAR('-');
         }
         break;
       case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;

commit ea1a83ce411c6022666513c24e222b1f2f5e360b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 23 02:16:35 2018 -0400

    Use pgm_read_ptr for tables of pointers

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 3c47c4225b..d0a53c1c55 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -223,7 +223,7 @@ void _tmc_say_axis(const TMC_AxisEnum axis) {
                     ext_E2[] PROGMEM = "E2", ext_E3[] PROGMEM = "E3",
                     ext_E4[] PROGMEM = "E4";
   const static char* const tmc_axes[] PROGMEM = { ext_X, ext_Y, ext_Z, ext_X2, ext_Y2, ext_Z2, ext_E0, ext_E1, ext_E2, ext_E3, ext_E4 };
-  serialprintPGM((char*)pgm_read_word(&tmc_axes[axis]));
+  serialprintPGM((char*)pgm_read_ptr(&tmc_axes[axis]));
 }
 
 void _tmc_say_current(const TMC_AxisEnum axis, const uint16_t curr) {

commit daf643e1ce75cce7f8507723632ddfb2d50d4126
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Mar 23 08:04:12 2018 +0200

    [2.0.x] TMC: Match axis label order (#10188)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 786526ed0a..3c47c4225b 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -217,13 +217,12 @@ bool report_tmc_status = false;
 #endif // MONITOR_DRIVER_STATUS
 
 void _tmc_say_axis(const TMC_AxisEnum axis) {
-  const static char ext_X[]  PROGMEM = "X",  ext_X2[] PROGMEM = "X2",
-                    ext_Y[]  PROGMEM = "Y",  ext_Y2[] PROGMEM = "Y2",
-                    ext_Z[]  PROGMEM = "Z",  ext_Z2[] PROGMEM = "Z2",
+  const static char ext_X[]  PROGMEM = "X",  ext_Y[]  PROGMEM = "Y",  ext_Z[]  PROGMEM = "Z",
+                    ext_X2[] PROGMEM = "X2", ext_Y2[] PROGMEM = "Y2", ext_Z2[] PROGMEM = "Z2",
                     ext_E0[] PROGMEM = "E0", ext_E1[] PROGMEM = "E1",
                     ext_E2[] PROGMEM = "E2", ext_E3[] PROGMEM = "E3",
                     ext_E4[] PROGMEM = "E4";
-  const static char* const tmc_axes[] PROGMEM = { ext_X, ext_X2, ext_Y, ext_Y2, ext_Z, ext_Z2, ext_E0, ext_E1, ext_E2, ext_E3, ext_E4 };
+  const static char* const tmc_axes[] PROGMEM = { ext_X, ext_Y, ext_Z, ext_X2, ext_Y2, ext_Z2, ext_E0, ext_E1, ext_E2, ext_E3, ext_E4 };
   serialprintPGM((char*)pgm_read_word(&tmc_axes[axis]));
 }
 

commit 8dfaf1539e2a304f22bea1b9c371bd26ddf1b9d8
Merge: 837ac2fdbd a46bac3100
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 20 23:14:19 2018 -0500

    Merge pull request #10102 from thinkyhead/bf2_eeprom_M913
    
    [2.0.x] More complete Trinamic driver options

diff --combined Marlin/src/feature/tmc_util.cpp
index 1d7a3d121c,d2a4ca55d0..786526ed0a
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@@ -128,8 -128,8 +128,8 @@@ bool report_tmc_status = false
        SERIAL_ECHOLNPGM("mA)");
      }
      #if CURRENT_STEP_DOWN > 0
 -      // Decrease current if is_otpw is true and driver is enabled and there's been more then 4 warnings
 -      if (data.is_otpw && !st.isEnabled() && otpw_cnt > 4) {
 +      // Decrease current if is_otpw is true and driver is enabled and there's been more than 4 warnings
 +      if (data.is_otpw && st.isEnabled() && otpw_cnt > 4) {
          st.setCurrent(st.getCurrent() - CURRENT_STEP_DOWN, R_SENSE, HOLD_MULTIPLIER);
          #if ENABLED(REPORT_CURRENT_CHANGE)
            _tmc_say_axis(axis);
@@@ -142,7 -142,7 +142,7 @@@
        otpw_cnt++;
        st.flag_otpw = true;
      }
 -    else if (otpw_cnt > 0) otpw_cnt--;
 +    else if (otpw_cnt > 0) otpw_cnt = 0;
  
      if (report_tmc_status) {
        const uint32_t pwm_scale = get_pwm_scale(st);
@@@ -331,6 -331,7 +331,7 @@@ void _tmc_say_sgt(const TMC_AxisEnum ax
        }
      }
    #endif
+ 
    #if ENABLED(HAVE_TMC2208)
      static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
        switch (i) {

commit b5b39af5316c92a53bfc2e25390ea179385020c6
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Tue Mar 20 22:16:05 2018 +0200

    [2.0.x] TMC: Fix CURRENT_STEP_DOWN (#10170)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 8364fa8690..1d7a3d121c 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -128,8 +128,8 @@ bool report_tmc_status = false;
       SERIAL_ECHOLNPGM("mA)");
     }
     #if CURRENT_STEP_DOWN > 0
-      // Decrease current if is_otpw is true and driver is enabled and there's been more then 4 warnings
-      if (data.is_otpw && !st.isEnabled() && otpw_cnt > 4) {
+      // Decrease current if is_otpw is true and driver is enabled and there's been more than 4 warnings
+      if (data.is_otpw && st.isEnabled() && otpw_cnt > 4) {
         st.setCurrent(st.getCurrent() - CURRENT_STEP_DOWN, R_SENSE, HOLD_MULTIPLIER);
         #if ENABLED(REPORT_CURRENT_CHANGE)
           _tmc_say_axis(axis);
@@ -142,7 +142,7 @@ bool report_tmc_status = false;
       otpw_cnt++;
       st.flag_otpw = true;
     }
-    else if (otpw_cnt > 0) otpw_cnt--;
+    else if (otpw_cnt > 0) otpw_cnt = 0;
 
     if (report_tmc_status) {
       const uint32_t pwm_scale = get_pwm_scale(st);

commit cfc13ed7f3fd20d2d07d64602e39e732a1cb982a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 14 05:43:18 2018 -0500

    Quiet M906/M913/M914 with axes. Patch for DISTINCT_E_FACTORS.

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 8364fa8690..d2a4ca55d0 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -331,6 +331,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
       }
     }
   #endif
+
   #if ENABLED(HAVE_TMC2208)
     static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
       switch (i) {

commit 978f342392964ee0e737cf0dffe9ba4e6fde33fc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 14 04:37:04 2018 -0500

    Reduce some tmc_util strings

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 40994d8c7f..8364fa8690 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -229,11 +229,11 @@ void _tmc_say_axis(const TMC_AxisEnum axis) {
 
 void _tmc_say_current(const TMC_AxisEnum axis, const uint16_t curr) {
   _tmc_say_axis(axis);
-  SERIAL_ECHOLNPAIR(" axis driver current: ", curr);
+  SERIAL_ECHOLNPAIR(" driver current: ", curr);
 }
 void _tmc_say_otpw(const TMC_AxisEnum axis, const bool otpw) {
   _tmc_say_axis(axis);
-  SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
+  SERIAL_ECHOPGM(" temperature prewarn triggered: ");
   serialprintPGM(otpw ? PSTR("true") : PSTR("false"));
   SERIAL_EOL();
 }
@@ -243,11 +243,11 @@ void _tmc_say_otpw_cleared(const TMC_AxisEnum axis) {
 }
 void _tmc_say_pwmthrs(const TMC_AxisEnum axis, const uint32_t thrs) {
   _tmc_say_axis(axis);
-  SERIAL_ECHOLNPAIR(" stealthChop max speed set to ", thrs);
+  SERIAL_ECHOLNPAIR(" stealthChop max speed: ", thrs);
 }
 void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
   _tmc_say_axis(axis);
-  SERIAL_ECHOPGM(" driver homing sensitivity set to ");
+  SERIAL_ECHOPGM(" homing sensitivity: ");
   SERIAL_PRINTLN(sgt, DEC);
 }
 

commit 1e946d681da353a70cc1e74055dbbfe78f5e64c1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Mar 15 21:03:12 2018 -0500

    Update Marlin for newest TMC libraries
    
    - TMC2130Stepper v2.2.0
    - TMC2208Stepper v0.0.4

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index e8ad7aee7b..40994d8c7f 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -392,8 +392,8 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
       case TMC_OTPW_TRIGGERED: serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false")); break;
       case TMC_TOFF: SERIAL_PRINT(st.toff(), DEC); break;
       case TMC_TBL: SERIAL_PRINT(st.blank_time(), DEC); break;
-      case TMC_HEND: SERIAL_PRINT(st.hysterisis_end(), DEC); break;
-      case TMC_HSTRT: SERIAL_PRINT(st.hysterisis_start(), DEC); break;
+      case TMC_HEND: SERIAL_PRINT(st.hysteresis_end(), DEC); break;
+      case TMC_HSTRT: SERIAL_PRINT(st.hysteresis_start(), DEC); break;
       default: tmc_status(st, i); break;
     }
   }
@@ -545,7 +545,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
                "been triggered",     TMC_OTPW_TRIGGERED);
     TMC_REPORT("off time\t",         TMC_TOFF);
     TMC_REPORT("blank time",         TMC_TBL);
-    TMC_REPORT("hysterisis\n-end\t", TMC_HEND);
+    TMC_REPORT("hysteresis\n-end\t", TMC_HEND);
     TMC_REPORT("-start\t",           TMC_HSTRT);
     TMC_REPORT("Stallguard thrs",    TMC_SGT);
 

commit e6dcfa64b00b1acadfb163b8bd5fd9dec7b76e72
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Wed Mar 14 14:09:06 2018 +0200

    Cast SERIAL_CHAR to void in M122 (#10086)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 61ebd811c5..e8ad7aee7b 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -385,7 +385,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
         break;
       case TMC_TPWMTHRS_MMS: {
           uint32_t tpwmthrs_val = st.TPWMTHRS();
-          tpwmthrs_val ? SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm)) : SERIAL_CHAR('-');
+          tpwmthrs_val ? SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm)) : (void)SERIAL_CHAR('-');
         }
         break;
       case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;

commit cc59ac4603d5d3fcf3260fb995d130722173fa34
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 9 06:10:11 2018 -0600

    Fix _tmc_say_axis string address
    
    Fixes #10003

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index d426ee42fa..61ebd811c5 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -224,7 +224,7 @@ void _tmc_say_axis(const TMC_AxisEnum axis) {
                     ext_E2[] PROGMEM = "E2", ext_E3[] PROGMEM = "E3",
                     ext_E4[] PROGMEM = "E4";
   const static char* const tmc_axes[] PROGMEM = { ext_X, ext_X2, ext_Y, ext_Y2, ext_Z, ext_Z2, ext_E0, ext_E1, ext_E2, ext_E3, ext_E4 };
-  serialprintPGM(tmc_axes[axis]);
+  serialprintPGM((char*)pgm_read_word(&tmc_axes[axis]));
 }
 
 void _tmc_say_current(const TMC_AxisEnum axis, const uint16_t curr) {

commit ca577c16380009abd0e64770ee6c7c1e44b937c8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 7 20:30:19 2018 -0600

    Fix up various spacing, comments, and typos

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 090d848518..d426ee42fa 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -314,7 +314,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
 
   #if ENABLED(HAVE_TMC2130)
     static void tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
-      switch(i) {
+      switch (i) {
         case TMC_PWM_SCALE: SERIAL_PRINT(st.PWM_SCALE(), DEC); break;
         case TMC_TSTEP: SERIAL_ECHO(st.TSTEP()); break;
         case TMC_SGT: SERIAL_PRINT(st.sgt(), DEC); break;
@@ -323,7 +323,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
       }
     }
     static void tmc_parse_drv_status(TMC2130Stepper &st, const TMC_drv_status_enum i) {
-      switch(i) {
+      switch (i) {
         case TMC_STALLGUARD: if (st.stallguard()) SERIAL_CHAR('X'); break;
         case TMC_SG_RESULT:  SERIAL_PRINT(st.sg_result(), DEC);   break;
         case TMC_FSACTIVE:   if (st.fsactive())   SERIAL_CHAR('X'); break;
@@ -333,7 +333,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
   #endif
   #if ENABLED(HAVE_TMC2208)
     static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
-      switch(i) {
+      switch (i) {
         case TMC_TSTEP: { uint32_t data = 0; st.TSTEP(&data); SERIAL_PROTOCOL(data); break; }
         case TMC_PWM_SCALE: SERIAL_PRINT(st.pwm_scale_sum(), DEC); break;
         case TMC_STEALTHCHOP: serialprintPGM(st.stealth() ? PSTR("true") : PSTR("false")); break;
@@ -343,7 +343,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
       }
     }
     static void tmc_parse_drv_status(TMC2208Stepper &st, const TMC_drv_status_enum i) {
-      switch(i) {
+      switch (i) {
         case TMC_T157: if (st.t157()) SERIAL_CHAR('X'); break;
         case TMC_T150: if (st.t150()) SERIAL_CHAR('X'); break;
         case TMC_T143: if (st.t143()) SERIAL_CHAR('X'); break;
@@ -356,7 +356,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
   template <typename TMC>
   static void tmc_status(TMC &st, const TMC_AxisEnum axis, const TMC_debug_enum i, const float spmm) {
     SERIAL_ECHO('\t');
-    switch(i) {
+    switch (i) {
       case TMC_CODES: _tmc_say_axis(axis); break;
       case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
       case TMC_CURRENT: SERIAL_ECHO(st.getCurrent()); break;
@@ -401,7 +401,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
   template <typename TMC>
   static void tmc_parse_drv_status(TMC &st, const TMC_AxisEnum axis, const TMC_drv_status_enum i) {
     SERIAL_CHAR('\t');
-    switch(i) {
+    switch (i) {
       case TMC_DRV_CODES:     _tmc_say_axis(axis);  break;
       case TMC_STST:          if (st.stst())         SERIAL_CHAR('X'); break;
       case TMC_OLB:           if (st.olb())          SERIAL_CHAR('X'); break;

commit 20571771848e2d8d3bb4f216c25c3d610c7e47cb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 6 22:35:22 2018 -0600

    Make enums into implicit char

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 2156bef022..090d848518 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -253,7 +253,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
 
 #if ENABLED(TMC_DEBUG)
 
-  enum TMC_debug_enum {
+  enum TMC_debug_enum : char {
     TMC_CODES,
     TMC_ENABLED,
     TMC_CURRENT,
@@ -277,7 +277,7 @@ void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
     TMC_HSTRT,
     TMC_SGT
   };
-  enum TMC_drv_status_enum {
+  enum TMC_drv_status_enum : char {
     TMC_DRV_CODES,
     TMC_STST,
     TMC_OLB,

commit e28e3bb5327ccd6dcf5f87258e3c0a7cfc2175f9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 6 22:16:19 2018 -0600

    Move extended_axis_codes to PROGMEM

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index d94b4e121b..2156bef022 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -37,7 +37,6 @@
 #endif
 
 bool report_tmc_status = false;
-char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1", "E2", "E3", "E4" };
 
 /**
  * Check for over temperature or short to ground error flags.
@@ -96,18 +95,17 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
   #endif
 
   template<typename TMC>
-  void monitor_tmc_driver(TMC &st, const char * const axisName, uint8_t &otpw_cnt) {
+  void monitor_tmc_driver(TMC &st, const TMC_AxisEnum axis, uint8_t &otpw_cnt) {
     TMC_driver_data data = get_driver_data(st);
 
     #if ENABLED(STOP_ON_ERROR)
       if (data.is_error) {
         SERIAL_EOL();
-        SERIAL_ECHO(axisName);
-        SERIAL_ECHOPGM(" driver error detected:");
-        if (data.is_ot) SERIAL_ECHOPGM("\novertemperature");
-        if (st.s2ga()) SERIAL_ECHOPGM("\nshort to ground (coil A)");
-        if (st.s2gb()) SERIAL_ECHOPGM("\nshort to ground (coil B)");
-        SERIAL_EOL();
+        _tmc_say_axis(axis);
+        SERIAL_ECHOLNPGM(" driver error detected:");
+        if (data.is_ot) SERIAL_ECHOLNPGM("overtemperature");
+        if (st.s2ga()) SERIAL_ECHOLNPGM("short to ground (coil A)");
+        if (st.s2gb()) SERIAL_ECHOLNPGM("short to ground (coil B)");
         #if ENABLED(TMC_DEBUG)
           tmc_report_all();
         #endif
@@ -124,7 +122,7 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
       SERIAL_EOL();
       SERIAL_ECHO(timestamp);
       SERIAL_ECHOPGM(": ");
-      SERIAL_ECHO(axisName);
+      _tmc_say_axis(axis);
       SERIAL_ECHOPGM(" driver overtemperature warning! (");
       SERIAL_ECHO(st.getCurrent());
       SERIAL_ECHOLNPGM("mA)");
@@ -134,7 +132,7 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
       if (data.is_otpw && !st.isEnabled() && otpw_cnt > 4) {
         st.setCurrent(st.getCurrent() - CURRENT_STEP_DOWN, R_SENSE, HOLD_MULTIPLIER);
         #if ENABLED(REPORT_CURRENT_CHANGE)
-          SERIAL_ECHO(axisName);
+          _tmc_say_axis(axis);
           SERIAL_ECHOLNPAIR(" current decreased to ", st.getCurrent());
         #endif
       }
@@ -148,7 +146,7 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
 
     if (report_tmc_status) {
       const uint32_t pwm_scale = get_pwm_scale(st);
-      SERIAL_ECHO(axisName);
+      _tmc_say_axis(axis);
       SERIAL_ECHOPAIR(":", pwm_scale);
       SERIAL_ECHOPGM(" |0b"); SERIAL_PRINT(get_status_response(st), BIN);
       SERIAL_ECHOPGM("| ");
@@ -169,47 +167,47 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
       next_cOT = millis() + 500;
       #if HAS_HW_COMMS(X) || ENABLED(IS_TRAMS)
         static uint8_t x_otpw_cnt = 0;
-        monitor_tmc_driver(stepperX, extended_axis_codes[TMC_X], x_otpw_cnt);
+        monitor_tmc_driver(stepperX, TMC_X, x_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(Y) || ENABLED(IS_TRAMS)
         static uint8_t y_otpw_cnt = 0;
-        monitor_tmc_driver(stepperY, extended_axis_codes[TMC_Y], y_otpw_cnt);
+        monitor_tmc_driver(stepperY, TMC_Y, y_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(Z) || ENABLED(IS_TRAMS)
         static uint8_t z_otpw_cnt = 0;
-        monitor_tmc_driver(stepperZ, extended_axis_codes[TMC_Z], z_otpw_cnt);
+        monitor_tmc_driver(stepperZ, TMC_Z, z_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(X2)
         static uint8_t x2_otpw_cnt = 0;
-        monitor_tmc_driver(stepperX2, extended_axis_codes[TMC_X], x2_otpw_cnt);
+        monitor_tmc_driver(stepperX2, TMC_X, x2_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(Y2)
         static uint8_t y2_otpw_cnt = 0;
-        monitor_tmc_driver(stepperY2, extended_axis_codes[TMC_Y], y2_otpw_cnt);
+        monitor_tmc_driver(stepperY2, TMC_Y, y2_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(Z2)
         static uint8_t z2_otpw_cnt = 0;
-        monitor_tmc_driver(stepperZ2, extended_axis_codes[TMC_Z], z2_otpw_cnt);
+        monitor_tmc_driver(stepperZ2, TMC_Z, z2_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(E0) || ENABLED(IS_TRAMS)
         static uint8_t e0_otpw_cnt = 0;
-        monitor_tmc_driver(stepperE0, extended_axis_codes[TMC_E0], e0_otpw_cnt);
+        monitor_tmc_driver(stepperE0, TMC_E0, e0_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(E1)
         static uint8_t e1_otpw_cnt = 0;
-        monitor_tmc_driver(stepperE1, extended_axis_codes[TMC_E1], e1_otpw_cnt);
+        monitor_tmc_driver(stepperE1, TMC_E1, e1_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(E2)
         static uint8_t e2_otpw_cnt = 0;
-        monitor_tmc_driver(stepperE2, extended_axis_codes[TMC_E2], e2_otpw_cnt);
+        monitor_tmc_driver(stepperE2, TMC_E2, e2_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(E3)
         static uint8_t e3_otpw_cnt = 0;
-        monitor_tmc_driver(stepperE3, extended_axis_codes[TMC_E3], e3_otpw_cnt);
+        monitor_tmc_driver(stepperE3, TMC_E3, e3_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(E4)
         static uint8_t e4_otpw_cnt = 0;
-        monitor_tmc_driver(stepperE4, extended_axis_codes[TMC_E4], e4_otpw_cnt);
+        monitor_tmc_driver(stepperE4, TMC_E4, e4_otpw_cnt);
       #endif
 
       if (report_tmc_status) SERIAL_EOL();
@@ -218,26 +216,37 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
 
 #endif // MONITOR_DRIVER_STATUS
 
-void _tmc_say_current(const char name[], const uint16_t curr) {
-  SERIAL_ECHO(name);
+void _tmc_say_axis(const TMC_AxisEnum axis) {
+  const static char ext_X[]  PROGMEM = "X",  ext_X2[] PROGMEM = "X2",
+                    ext_Y[]  PROGMEM = "Y",  ext_Y2[] PROGMEM = "Y2",
+                    ext_Z[]  PROGMEM = "Z",  ext_Z2[] PROGMEM = "Z2",
+                    ext_E0[] PROGMEM = "E0", ext_E1[] PROGMEM = "E1",
+                    ext_E2[] PROGMEM = "E2", ext_E3[] PROGMEM = "E3",
+                    ext_E4[] PROGMEM = "E4";
+  const static char* const tmc_axes[] PROGMEM = { ext_X, ext_X2, ext_Y, ext_Y2, ext_Z, ext_Z2, ext_E0, ext_E1, ext_E2, ext_E3, ext_E4 };
+  serialprintPGM(tmc_axes[axis]);
+}
+
+void _tmc_say_current(const TMC_AxisEnum axis, const uint16_t curr) {
+  _tmc_say_axis(axis);
   SERIAL_ECHOLNPAIR(" axis driver current: ", curr);
 }
-void _tmc_say_otpw(const char name[], const bool otpw) {
-  SERIAL_ECHO(name);
+void _tmc_say_otpw(const TMC_AxisEnum axis, const bool otpw) {
+  _tmc_say_axis(axis);
   SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
   serialprintPGM(otpw ? PSTR("true") : PSTR("false"));
   SERIAL_EOL();
 }
-void _tmc_say_otpw_cleared(const char name[]) {
-  SERIAL_ECHO(name);
+void _tmc_say_otpw_cleared(const TMC_AxisEnum axis) {
+  _tmc_say_axis(axis);
   SERIAL_ECHOLNPGM(" prewarn flag cleared");
 }
-void _tmc_say_pwmthrs(const char name[], const uint32_t thrs) {
-  SERIAL_ECHO(name);
+void _tmc_say_pwmthrs(const TMC_AxisEnum axis, const uint32_t thrs) {
+  _tmc_say_axis(axis);
   SERIAL_ECHOLNPAIR(" stealthChop max speed set to ", thrs);
 }
-void _tmc_say_sgt(const char name[], const int8_t sgt) {
-  SERIAL_ECHO(name);
+void _tmc_say_sgt(const TMC_AxisEnum axis, const int8_t sgt) {
+  _tmc_say_axis(axis);
   SERIAL_ECHOPGM(" driver homing sensitivity set to ");
   SERIAL_PRINTLN(sgt, DEC);
 }
@@ -290,8 +299,8 @@ void _tmc_say_sgt(const char name[], const int8_t sgt) {
     TMC_S2VSB,
     TMC_S2VSA
   };
-  static void drv_status_print_hex(const char name[], const uint32_t drv_status) {
-    SERIAL_ECHO(name);
+  static void drv_status_print_hex(const TMC_AxisEnum axis, const uint32_t drv_status) {
+    _tmc_say_axis(axis);
     SERIAL_ECHOPGM(" = 0x");
     for (int B = 24; B >= 8; B -= 8){
       SERIAL_PRINT((drv_status >> (B + 4)) & 0xF, HEX);
@@ -345,10 +354,10 @@ void _tmc_say_sgt(const char name[], const int8_t sgt) {
   #endif
 
   template <typename TMC>
-  static void tmc_status(TMC &st, TMC_AxisEnum axis, const TMC_debug_enum i, const float spmm) {
+  static void tmc_status(TMC &st, const TMC_AxisEnum axis, const TMC_debug_enum i, const float spmm) {
     SERIAL_ECHO('\t');
     switch(i) {
-      case TMC_CODES: SERIAL_ECHO(extended_axis_codes[axis]); break;
+      case TMC_CODES: _tmc_say_axis(axis); break;
       case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
       case TMC_CURRENT: SERIAL_ECHO(st.getCurrent()); break;
       case TMC_RMS_CURRENT: SERIAL_PROTOCOL(st.rms_current()); break;
@@ -390,10 +399,10 @@ void _tmc_say_sgt(const char name[], const int8_t sgt) {
   }
 
   template <typename TMC>
-  static void tmc_parse_drv_status(TMC &st, TMC_AxisEnum axis, const TMC_drv_status_enum i) {
+  static void tmc_parse_drv_status(TMC &st, const TMC_AxisEnum axis, const TMC_drv_status_enum i) {
     SERIAL_CHAR('\t');
     switch(i) {
-      case TMC_DRV_CODES:     SERIAL_ECHO(extended_axis_codes[axis]);  break;
+      case TMC_DRV_CODES:     _tmc_say_axis(axis);  break;
       case TMC_STST:          if (st.stst())         SERIAL_CHAR('X'); break;
       case TMC_OLB:           if (st.olb())          SERIAL_CHAR('X'); break;
       case TMC_OLA:           if (st.ola())          SERIAL_CHAR('X'); break;
@@ -402,7 +411,7 @@ void _tmc_say_sgt(const char name[], const int8_t sgt) {
       case TMC_DRV_OTPW:      if (st.otpw())         SERIAL_CHAR('X'); break;
       case TMC_OT:            if (st.ot())           SERIAL_CHAR('X'); break;
       case TMC_DRV_CS_ACTUAL: SERIAL_PRINT(st.cs_actual(), DEC);       break;
-      case TMC_DRV_STATUS_HEX:drv_status_print_hex(extended_axis_codes[axis], st.DRV_STATUS()); break;
+      case TMC_DRV_STATUS_HEX:drv_status_print_hex(axis, st.DRV_STATUS()); break;
       default: tmc_parse_drv_status(st, i); break;
     }
   }

commit b08ec22fe15a39e6f1e2f042f790e5f7a043867b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 6 19:01:07 2018 -0600

    Show E0-E4 in monitor_tmc_driver output (#9969)
    
    Fix #9966

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 21115c45f3..d94b4e121b 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -39,7 +39,7 @@
 bool report_tmc_status = false;
 char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1", "E2", "E3", "E4" };
 
-/*
+/**
  * Check for over temperature or short to ground error flags.
  * Report and log warning of overtemperature condition.
  * Reduce driver current in a persistent otpw condition.
@@ -96,13 +96,13 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
   #endif
 
   template<typename TMC>
-  void monitor_tmc_driver(TMC &st, const char axisID, uint8_t &otpw_cnt) {
+  void monitor_tmc_driver(TMC &st, const char * const axisName, uint8_t &otpw_cnt) {
     TMC_driver_data data = get_driver_data(st);
 
     #if ENABLED(STOP_ON_ERROR)
       if (data.is_error) {
         SERIAL_EOL();
-        SERIAL_ECHO(axisID);
+        SERIAL_ECHO(axisName);
         SERIAL_ECHOPGM(" driver error detected:");
         if (data.is_ot) SERIAL_ECHOPGM("\novertemperature");
         if (st.s2ga()) SERIAL_ECHOPGM("\nshort to ground (coil A)");
@@ -124,7 +124,7 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
       SERIAL_EOL();
       SERIAL_ECHO(timestamp);
       SERIAL_ECHOPGM(": ");
-      SERIAL_ECHO(axisID);
+      SERIAL_ECHO(axisName);
       SERIAL_ECHOPGM(" driver overtemperature warning! (");
       SERIAL_ECHO(st.getCurrent());
       SERIAL_ECHOLNPGM("mA)");
@@ -134,7 +134,7 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
       if (data.is_otpw && !st.isEnabled() && otpw_cnt > 4) {
         st.setCurrent(st.getCurrent() - CURRENT_STEP_DOWN, R_SENSE, HOLD_MULTIPLIER);
         #if ENABLED(REPORT_CURRENT_CHANGE)
-          SERIAL_ECHO(axisID);
+          SERIAL_ECHO(axisName);
           SERIAL_ECHOLNPAIR(" current decreased to ", st.getCurrent());
         #endif
       }
@@ -148,7 +148,7 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
 
     if (report_tmc_status) {
       const uint32_t pwm_scale = get_pwm_scale(st);
-      SERIAL_ECHO(axisID);
+      SERIAL_ECHO(axisName);
       SERIAL_ECHOPAIR(":", pwm_scale);
       SERIAL_ECHOPGM(" |0b"); SERIAL_PRINT(get_status_response(st), BIN);
       SERIAL_ECHOPGM("| ");
@@ -169,47 +169,47 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
       next_cOT = millis() + 500;
       #if HAS_HW_COMMS(X) || ENABLED(IS_TRAMS)
         static uint8_t x_otpw_cnt = 0;
-        monitor_tmc_driver(stepperX, axis_codes[X_AXIS], x_otpw_cnt);
+        monitor_tmc_driver(stepperX, extended_axis_codes[TMC_X], x_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(Y) || ENABLED(IS_TRAMS)
         static uint8_t y_otpw_cnt = 0;
-        monitor_tmc_driver(stepperY, axis_codes[Y_AXIS], y_otpw_cnt);
+        monitor_tmc_driver(stepperY, extended_axis_codes[TMC_Y], y_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(Z) || ENABLED(IS_TRAMS)
         static uint8_t z_otpw_cnt = 0;
-        monitor_tmc_driver(stepperZ, axis_codes[Z_AXIS], z_otpw_cnt);
+        monitor_tmc_driver(stepperZ, extended_axis_codes[TMC_Z], z_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(X2)
         static uint8_t x2_otpw_cnt = 0;
-        monitor_tmc_driver(stepperX2, axis_codes[X_AXIS], x2_otpw_cnt);
+        monitor_tmc_driver(stepperX2, extended_axis_codes[TMC_X], x2_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(Y2)
         static uint8_t y2_otpw_cnt = 0;
-        monitor_tmc_driver(stepperY2, axis_codes[Y_AXIS], y2_otpw_cnt);
+        monitor_tmc_driver(stepperY2, extended_axis_codes[TMC_Y], y2_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(Z2)
         static uint8_t z2_otpw_cnt = 0;
-        monitor_tmc_driver(stepperZ2, axis_codes[Z_AXIS], z2_otpw_cnt);
+        monitor_tmc_driver(stepperZ2, extended_axis_codes[TMC_Z], z2_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(E0) || ENABLED(IS_TRAMS)
         static uint8_t e0_otpw_cnt = 0;
-        monitor_tmc_driver(stepperE0, axis_codes[E_AXIS], e0_otpw_cnt);
+        monitor_tmc_driver(stepperE0, extended_axis_codes[TMC_E0], e0_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(E1)
         static uint8_t e1_otpw_cnt = 0;
-        monitor_tmc_driver(stepperE1, axis_codes[E_AXIS], e1_otpw_cnt);
+        monitor_tmc_driver(stepperE1, extended_axis_codes[TMC_E1], e1_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(E2)
         static uint8_t e2_otpw_cnt = 0;
-        monitor_tmc_driver(stepperE2, axis_codes[E_AXIS], e2_otpw_cnt);
+        monitor_tmc_driver(stepperE2, extended_axis_codes[TMC_E2], e2_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(E3)
         static uint8_t e3_otpw_cnt = 0;
-        monitor_tmc_driver(stepperE3, axis_codes[E_AXIS], e3_otpw_cnt);
+        monitor_tmc_driver(stepperE3, extended_axis_codes[TMC_E3], e3_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(E4)
         static uint8_t e4_otpw_cnt = 0;
-        monitor_tmc_driver(stepperE4, axis_codes[E_AXIS], e4_otpw_cnt);
+        monitor_tmc_driver(stepperE4, extended_axis_codes[TMC_E4], e4_otpw_cnt);
       #endif
 
       if (report_tmc_status) SERIAL_EOL();
@@ -299,7 +299,7 @@ void _tmc_say_sgt(const char name[], const int8_t sgt) {
       SERIAL_CHAR(':');
     }
     SERIAL_PRINT((drv_status >> 4) & 0xF, HEX);
-    SERIAL_PRINT(drv_status & 0xF, HEX);
+    SERIAL_PRINT((drv_status) & 0xF, HEX);
     SERIAL_EOL();
   }
 
@@ -376,10 +376,7 @@ void _tmc_say_sgt(const char name[], const int8_t sgt) {
         break;
       case TMC_TPWMTHRS_MMS: {
           uint32_t tpwmthrs_val = st.TPWMTHRS();
-          if (tpwmthrs_val)
-            SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm));
-          else
-            SERIAL_CHAR('-');
+          tpwmthrs_val ? SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm)) : SERIAL_CHAR('-');
         }
         break;
       case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;

commit 749bc42aa944fe59f012c30571429dab13468c8f
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Feb 16 10:19:33 2018 +0200

    TMC SGT is int8 (#9651)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 11bec933a5..21115c45f3 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -236,7 +236,7 @@ void _tmc_say_pwmthrs(const char name[], const uint32_t thrs) {
   SERIAL_ECHO(name);
   SERIAL_ECHOLNPAIR(" stealthChop max speed set to ", thrs);
 }
-void _tmc_say_sgt(const char name[], const uint32_t sgt) {
+void _tmc_say_sgt(const char name[], const int8_t sgt) {
   SERIAL_ECHO(name);
   SERIAL_ECHOPGM(" driver homing sensitivity set to ");
   SERIAL_PRINTLN(sgt, DEC);

commit 5990266724eb79536cb6d0d72b6130aebba2cbba
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sat Feb 10 22:08:53 2018 +0200

    Init CS pins before loading settings (#9566)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index a45136381b..11bec933a5 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -582,4 +582,43 @@ void _tmc_say_sgt(const char name[], const uint32_t sgt) {
 
 #endif // SENSORLESS_HOMING
 
+#if ENABLED(HAVE_TMC2130)
+  #define SET_CS_PIN(st) OUT_WRITE(st##_CS_PIN, HIGH)
+  void tmc_init_cs_pins() {
+    #if ENABLED(X_IS_TMC2130)
+      SET_CS_PIN(X);
+    #endif
+    #if ENABLED(Y_IS_TMC2130)
+      SET_CS_PIN(Y);
+    #endif
+    #if ENABLED(Z_IS_TMC2130)
+      SET_CS_PIN(Z);
+    #endif
+    #if ENABLED(X2_IS_TMC2130)
+      SET_CS_PIN(X2);
+    #endif
+    #if ENABLED(Y2_IS_TMC2130)
+      SET_CS_PIN(Y2);
+    #endif
+    #if ENABLED(Z2_IS_TMC2130)
+      SET_CS_PIN(Z2);
+    #endif
+    #if ENABLED(E0_IS_TMC2130)
+      SET_CS_PIN(E0);
+    #endif
+    #if ENABLED(E1_IS_TMC2130)
+      SET_CS_PIN(E1);
+    #endif
+    #if ENABLED(E2_IS_TMC2130)
+      SET_CS_PIN(E2);
+    #endif
+    #if ENABLED(E3_IS_TMC2130)
+      SET_CS_PIN(E3);
+    #endif
+    #if ENABLED(E4_IS_TMC2130)
+      SET_CS_PIN(E4);
+    #endif
+  }
+#endif // HAVE_TMC2130
+
 #endif // HAS_TRINAMIC

commit 1541224a81a80b91a1ac2009c917f1f33e816cfb
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Thu Feb 8 04:20:44 2018 -0600

    Enable Z axis and delta sensorless homing (#9516)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 1cf0112401..a45136381b 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -150,7 +150,7 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
       const uint32_t pwm_scale = get_pwm_scale(st);
       SERIAL_ECHO(axisID);
       SERIAL_ECHOPAIR(":", pwm_scale);
-      SERIAL_ECHOPGM(" |0b"); MYSERIAL0.print(get_status_response(st), BIN);
+      SERIAL_ECHOPGM(" |0b"); SERIAL_PRINT(get_status_response(st), BIN);
       SERIAL_ECHOPGM("| ");
       if (data.is_error) SERIAL_CHAR('E');
       else if (data.is_ot) SERIAL_CHAR('O');
@@ -239,7 +239,7 @@ void _tmc_say_pwmthrs(const char name[], const uint32_t thrs) {
 void _tmc_say_sgt(const char name[], const uint32_t sgt) {
   SERIAL_ECHO(name);
   SERIAL_ECHOPGM(" driver homing sensitivity set to ");
-  MYSERIAL0.println(sgt, DEC);
+  SERIAL_PRINTLN(sgt, DEC);
 }
 
 #if ENABLED(TMC_DEBUG)
@@ -325,7 +325,7 @@ void _tmc_say_sgt(const char name[], const uint32_t sgt) {
   #if ENABLED(HAVE_TMC2208)
     static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
       switch(i) {
-        case TMC_TSTEP: { uint32_t data = 0; st.TSTEP(&data); MYSERIAL0.print(data); break; }
+        case TMC_TSTEP: { uint32_t data = 0; st.TSTEP(&data); SERIAL_PROTOCOL(data); break; }
         case TMC_PWM_SCALE: SERIAL_PRINT(st.pwm_scale_sum(), DEC); break;
         case TMC_STEALTHCHOP: serialprintPGM(st.stealth() ? PSTR("true") : PSTR("false")); break;
         case TMC_S2VSA: if (st.s2vsa()) SERIAL_CHAR('X'); break;
@@ -351,7 +351,7 @@ void _tmc_say_sgt(const char name[], const uint32_t sgt) {
       case TMC_CODES: SERIAL_ECHO(extended_axis_codes[axis]); break;
       case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
       case TMC_CURRENT: SERIAL_ECHO(st.getCurrent()); break;
-      case TMC_RMS_CURRENT: MYSERIAL0.print(st.rms_current()); break;
+      case TMC_RMS_CURRENT: SERIAL_PROTOCOL(st.rms_current()); break;
       case TMC_MAX_CURRENT: SERIAL_PRINT((float)st.rms_current() * 1.41, 0); break;
       case TMC_IRUN:
         SERIAL_PRINT(st.irun(), DEC);

commit e1fd9c08b33be7073dbcfe57b88cd6f724aa34df
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sat Feb 3 19:33:26 2018 -0600

    [2.0.x] Add support for LPC1769 at 120 MHz (#9423)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 44e8bb6491..1cf0112401 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -436,16 +436,32 @@ void _tmc_say_sgt(const char name[], const uint32_t sgt) {
       tmc_status(stepperE0, TMC_E0, i, planner.axis_steps_per_mm[E_AXIS]);
     #endif
     #if E1_IS_TRINAMIC
-      tmc_status(stepperE1, TMC_E1, i, planner.axis_steps_per_mm[E_AXIS+1]);
+      tmc_status(stepperE1, TMC_E1, i, planner.axis_steps_per_mm[E_AXIS
+        #if ENABLED(DISTINCT_E_FACTORS)
+          + 1
+        #endif
+      ]);
     #endif
     #if E2_IS_TRINAMIC
-      tmc_status(stepperE2, TMC_E2, i, planner.axis_steps_per_mm[E_AXIS+2]);
+      tmc_status(stepperE2, TMC_E2, i, planner.axis_steps_per_mm[E_AXIS
+        #if ENABLED(DISTINCT_E_FACTORS)
+          + 2
+        #endif
+      ]);
     #endif
     #if E3_IS_TRINAMIC
-      tmc_status(stepperE3, TMC_E3, i, planner.axis_steps_per_mm[E_AXIS+3]);
+      tmc_status(stepperE3, TMC_E3, i, planner.axis_steps_per_mm[E_AXIS
+        #if ENABLED(DISTINCT_E_FACTORS)
+          + 3
+        #endif
+      ]);
     #endif
     #if E4_IS_TRINAMIC
-      tmc_status(stepperE4, TMC_E4, i, planner.axis_steps_per_mm[E_AXIS+4]);
+      tmc_status(stepperE4, TMC_E4, i, planner.axis_steps_per_mm[E_AXIS
+        #if ENABLED(DISTINCT_E_FACTORS)
+          + 4
+        #endif
+      ]);
     #endif
 
     SERIAL_EOL();

commit 43d3d024ac68322f8636bc25e7c64b960c90e056
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 15 04:51:59 2018 -0600

    Update tmc_util.cpp

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index da1bf6b174..44e8bb6491 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -379,7 +379,7 @@ void _tmc_say_sgt(const char name[], const uint32_t sgt) {
           if (tpwmthrs_val)
             SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm));
           else
-           SERIAL_CHAR('-');
+            SERIAL_CHAR('-');
         }
         break;
       case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;

commit ad500b01e0224719e9c29bc559484d44847a5e13
Author: Panayiotis Savva <psavva@gmail.com>
Date:   Mon Jan 15 12:24:02 2018 +0200

    Fixes TMC compilation error

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index f083258559..da1bf6b174 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -376,7 +376,10 @@ void _tmc_say_sgt(const char name[], const uint32_t sgt) {
         break;
       case TMC_TPWMTHRS_MMS: {
           uint32_t tpwmthrs_val = st.TPWMTHRS();
-          tpwmthrs_val ? SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm)) : SERIAL_CHAR('-');
+          if (tpwmthrs_val)
+            SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm));
+          else
+           SERIAL_CHAR('-');
         }
         break;
       case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;

commit 6a043eee558695e91f64b6f4a48fcd1816a5f130
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 9 19:14:07 2018 -0600

    Various updates for TMC support

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index b799462d35..f083258559 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -32,6 +32,10 @@
 #include "../libs/duration_t.h"
 #include "../gcode/gcode.h"
 
+#if ENABLED(TMC_DEBUG)
+  #include "../module/planner.h"
+#endif
+
 bool report_tmc_status = false;
 char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1", "E2", "E3", "E4" };
 
@@ -51,7 +55,7 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
   };
   #if ENABLED(HAVE_TMC2130)
     static uint32_t get_pwm_scale(TMC2130Stepper &st) { return st.PWM_SCALE(); }
-    static uint8_t get_status_response(TMC2130Stepper &st) { return st.status_response&0xF; }
+    static uint8_t get_status_response(TMC2130Stepper &st) { return st.status_response & 0xF; }
     static TMC_driver_data get_driver_data(TMC2130Stepper &st) {
       constexpr uint32_t OTPW_bm = 0x4000000UL;
       constexpr uint8_t OTPW_bp = 26;
@@ -61,9 +65,9 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
       constexpr uint8_t DRIVER_ERROR_bp = 1;
       TMC_driver_data data;
       data.drv_status = st.DRV_STATUS();
-      data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
-      data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
-      data.is_error = (st.status_response & DRIVER_ERROR_bm)>>DRIVER_ERROR_bp;
+      data.is_otpw = (data.drv_status & OTPW_bm) >> OTPW_bp;
+      data.is_ot = (data.drv_status & OT_bm) >> OT_bp;
+      data.is_error = (st.status_response & DRIVER_ERROR_bm) >> DRIVER_ERROR_bp;
       return data;
     }
   #endif
@@ -84,35 +88,35 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
       constexpr uint8_t OT_bp = 1;
       TMC_driver_data data;
       data.drv_status = st.DRV_STATUS();
-      data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
-      data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
+      data.is_otpw = (data.drv_status & OTPW_bm) >> OTPW_bp;
+      data.is_ot = (data.drv_status & OT_bm) >> OT_bp;
       data.is_error = st.drv_err();
       return data;
     }
   #endif
 
   template<typename TMC>
-  uint8_t monitor_tmc_driver(TMC &st, const char axisID, uint8_t otpw_cnt) {
+  void monitor_tmc_driver(TMC &st, const char axisID, uint8_t &otpw_cnt) {
     TMC_driver_data data = get_driver_data(st);
 
     #if ENABLED(STOP_ON_ERROR)
       if (data.is_error) {
         SERIAL_EOL();
         SERIAL_ECHO(axisID);
-        SERIAL_ECHO(" driver error detected:");
-        if (data.is_ot) SERIAL_ECHO("\novertemperature");
-        if (st.s2ga()) SERIAL_ECHO("\nshort to ground (coil A)");
-        if (st.s2gb()) SERIAL_ECHO("\nshort to ground (coil B)");
+        SERIAL_ECHOPGM(" driver error detected:");
+        if (data.is_ot) SERIAL_ECHOPGM("\novertemperature");
+        if (st.s2ga()) SERIAL_ECHOPGM("\nshort to ground (coil A)");
+        if (st.s2gb()) SERIAL_ECHOPGM("\nshort to ground (coil B)");
         SERIAL_EOL();
         #if ENABLED(TMC_DEBUG)
-          _M122();
+          tmc_report_all();
         #endif
         kill(PSTR("Driver error"));
       }
     #endif
 
     // Report if a warning was triggered
-    if (data.is_otpw && otpw_cnt==0) {
+    if (data.is_otpw && otpw_cnt == 0) {
       char timestamp[10];
       duration_t elapsed = print_job_timer.duration();
       const bool has_days = (elapsed.value > 60*60*24L);
@@ -123,7 +127,7 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
       SERIAL_ECHO(axisID);
       SERIAL_ECHOPGM(" driver overtemperature warning! (");
       SERIAL_ECHO(st.getCurrent());
-      SERIAL_ECHOLN("mA)");
+      SERIAL_ECHOLNPGM("mA)");
     }
     #if CURRENT_STEP_DOWN > 0
       // Decrease current if is_otpw is true and driver is enabled and there's been more then 4 warnings
@@ -140,23 +144,21 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
       otpw_cnt++;
       st.flag_otpw = true;
     }
-    else if (otpw_cnt>0) otpw_cnt--;
+    else if (otpw_cnt > 0) otpw_cnt--;
 
     if (report_tmc_status) {
       const uint32_t pwm_scale = get_pwm_scale(st);
       SERIAL_ECHO(axisID);
       SERIAL_ECHOPAIR(":", pwm_scale);
-      SERIAL_ECHO(" |0b"); SERIAL_PRINT(get_status_response(st), BIN);
-      SERIAL_ECHO("| ");
-      if (data.is_error) SERIAL_ECHO('E');
-      else if (data.is_ot) SERIAL_ECHO('O');
-      else if (data.is_otpw) SERIAL_ECHO('W');
-      else if (otpw_cnt>0) SERIAL_PRINT(otpw_cnt, DEC);
-      else if (st.flag_otpw) SERIAL_ECHO('F');
-      SERIAL_ECHO("\t");
+      SERIAL_ECHOPGM(" |0b"); MYSERIAL0.print(get_status_response(st), BIN);
+      SERIAL_ECHOPGM("| ");
+      if (data.is_error) SERIAL_CHAR('E');
+      else if (data.is_ot) SERIAL_CHAR('O');
+      else if (data.is_otpw) SERIAL_CHAR('W');
+      else if (otpw_cnt > 0) SERIAL_PRINT(otpw_cnt, DEC);
+      else if (st.flag_otpw) SERIAL_CHAR('F');
+      SERIAL_CHAR('\t');
     }
-
-    return otpw_cnt;
   }
 
   #define HAS_HW_COMMS(ST) ENABLED(ST##_IS_TMC2130)|| (ENABLED(ST##_IS_TMC2208) && defined(ST##_HARDWARE_SERIAL))
@@ -167,47 +169,47 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
       next_cOT = millis() + 500;
       #if HAS_HW_COMMS(X) || ENABLED(IS_TRAMS)
         static uint8_t x_otpw_cnt = 0;
-        x_otpw_cnt = monitor_tmc_driver(stepperX, axis_codes[X_AXIS], x_otpw_cnt);
+        monitor_tmc_driver(stepperX, axis_codes[X_AXIS], x_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(Y) || ENABLED(IS_TRAMS)
         static uint8_t y_otpw_cnt = 0;
-        y_otpw_cnt = monitor_tmc_driver(stepperY, axis_codes[Y_AXIS], y_otpw_cnt);
+        monitor_tmc_driver(stepperY, axis_codes[Y_AXIS], y_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(Z) || ENABLED(IS_TRAMS)
         static uint8_t z_otpw_cnt = 0;
-        z_otpw_cnt = monitor_tmc_driver(stepperZ, axis_codes[Z_AXIS], z_otpw_cnt);
+        monitor_tmc_driver(stepperZ, axis_codes[Z_AXIS], z_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(X2)
         static uint8_t x2_otpw_cnt = 0;
-        x2_otpw_cnt = monitor_tmc_driver(stepperX2, axis_codes[X_AXIS], x2_otpw_cnt);
+        monitor_tmc_driver(stepperX2, axis_codes[X_AXIS], x2_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(Y2)
         static uint8_t y2_otpw_cnt = 0;
-        y2_otpw_cnt = monitor_tmc_driver(stepperY2, axis_codes[Y_AXIS], y2_otpw_cnt);
+        monitor_tmc_driver(stepperY2, axis_codes[Y_AXIS], y2_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(Z2)
         static uint8_t z2_otpw_cnt = 0;
-        z2_otpw_cnt = monitor_tmc_driver(stepperZ2, axis_codes[Z_AXIS], z2_otpw_cnt);
+        monitor_tmc_driver(stepperZ2, axis_codes[Z_AXIS], z2_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(E0) || ENABLED(IS_TRAMS)
         static uint8_t e0_otpw_cnt = 0;
-        e0_otpw_cnt = monitor_tmc_driver(stepperE0, axis_codes[E_AXIS], e0_otpw_cnt);
+        monitor_tmc_driver(stepperE0, axis_codes[E_AXIS], e0_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(E1)
         static uint8_t e1_otpw_cnt = 0;
-        e1_otpw_cnt = monitor_tmc_driver(stepperE1, axis_codes[E_AXIS], e1_otpw_cnt);
+        monitor_tmc_driver(stepperE1, axis_codes[E_AXIS], e1_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(E2)
         static uint8_t e2_otpw_cnt = 0;
-        e2_otpw_cnt = monitor_tmc_driver(stepperE2, axis_codes[E_AXIS], e2_otpw_cnt);
+        monitor_tmc_driver(stepperE2, axis_codes[E_AXIS], e2_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(E3)
         static uint8_t e3_otpw_cnt = 0;
-        e3_otpw_cnt = monitor_tmc_driver(stepperE3, axis_codes[E_AXIS], e3_otpw_cnt);
+        monitor_tmc_driver(stepperE3, axis_codes[E_AXIS], e3_otpw_cnt);
       #endif
       #if HAS_HW_COMMS(E4)
         static uint8_t e4_otpw_cnt = 0;
-        e4_otpw_cnt = monitor_tmc_driver(stepperE4, axis_codes[E_AXIS], e4_otpw_cnt);
+        monitor_tmc_driver(stepperE4, axis_codes[E_AXIS], e4_otpw_cnt);
       #endif
 
       if (report_tmc_status) SERIAL_EOL();
@@ -216,4 +218,349 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
 
 #endif // MONITOR_DRIVER_STATUS
 
+void _tmc_say_current(const char name[], const uint16_t curr) {
+  SERIAL_ECHO(name);
+  SERIAL_ECHOLNPAIR(" axis driver current: ", curr);
+}
+void _tmc_say_otpw(const char name[], const bool otpw) {
+  SERIAL_ECHO(name);
+  SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
+  serialprintPGM(otpw ? PSTR("true") : PSTR("false"));
+  SERIAL_EOL();
+}
+void _tmc_say_otpw_cleared(const char name[]) {
+  SERIAL_ECHO(name);
+  SERIAL_ECHOLNPGM(" prewarn flag cleared");
+}
+void _tmc_say_pwmthrs(const char name[], const uint32_t thrs) {
+  SERIAL_ECHO(name);
+  SERIAL_ECHOLNPAIR(" stealthChop max speed set to ", thrs);
+}
+void _tmc_say_sgt(const char name[], const uint32_t sgt) {
+  SERIAL_ECHO(name);
+  SERIAL_ECHOPGM(" driver homing sensitivity set to ");
+  MYSERIAL0.println(sgt, DEC);
+}
+
+#if ENABLED(TMC_DEBUG)
+
+  enum TMC_debug_enum {
+    TMC_CODES,
+    TMC_ENABLED,
+    TMC_CURRENT,
+    TMC_RMS_CURRENT,
+    TMC_MAX_CURRENT,
+    TMC_IRUN,
+    TMC_IHOLD,
+    TMC_CS_ACTUAL,
+    TMC_PWM_SCALE,
+    TMC_VSENSE,
+    TMC_STEALTHCHOP,
+    TMC_MICROSTEPS,
+    TMC_TSTEP,
+    TMC_TPWMTHRS,
+    TMC_TPWMTHRS_MMS,
+    TMC_OTPW,
+    TMC_OTPW_TRIGGERED,
+    TMC_TOFF,
+    TMC_TBL,
+    TMC_HEND,
+    TMC_HSTRT,
+    TMC_SGT
+  };
+  enum TMC_drv_status_enum {
+    TMC_DRV_CODES,
+    TMC_STST,
+    TMC_OLB,
+    TMC_OLA,
+    TMC_S2GB,
+    TMC_S2GA,
+    TMC_DRV_OTPW,
+    TMC_OT,
+    TMC_STALLGUARD,
+    TMC_DRV_CS_ACTUAL,
+    TMC_FSACTIVE,
+    TMC_SG_RESULT,
+    TMC_DRV_STATUS_HEX,
+    TMC_T157,
+    TMC_T150,
+    TMC_T143,
+    TMC_T120,
+    TMC_STEALTH,
+    TMC_S2VSB,
+    TMC_S2VSA
+  };
+  static void drv_status_print_hex(const char name[], const uint32_t drv_status) {
+    SERIAL_ECHO(name);
+    SERIAL_ECHOPGM(" = 0x");
+    for (int B = 24; B >= 8; B -= 8){
+      SERIAL_PRINT((drv_status >> (B + 4)) & 0xF, HEX);
+      SERIAL_PRINT((drv_status >> B) & 0xF, HEX);
+      SERIAL_CHAR(':');
+    }
+    SERIAL_PRINT((drv_status >> 4) & 0xF, HEX);
+    SERIAL_PRINT(drv_status & 0xF, HEX);
+    SERIAL_EOL();
+  }
+
+  #if ENABLED(HAVE_TMC2130)
+    static void tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
+      switch(i) {
+        case TMC_PWM_SCALE: SERIAL_PRINT(st.PWM_SCALE(), DEC); break;
+        case TMC_TSTEP: SERIAL_ECHO(st.TSTEP()); break;
+        case TMC_SGT: SERIAL_PRINT(st.sgt(), DEC); break;
+        case TMC_STEALTHCHOP: serialprintPGM(st.stealthChop() ? PSTR("true") : PSTR("false")); break;
+        default: break;
+      }
+    }
+    static void tmc_parse_drv_status(TMC2130Stepper &st, const TMC_drv_status_enum i) {
+      switch(i) {
+        case TMC_STALLGUARD: if (st.stallguard()) SERIAL_CHAR('X'); break;
+        case TMC_SG_RESULT:  SERIAL_PRINT(st.sg_result(), DEC);   break;
+        case TMC_FSACTIVE:   if (st.fsactive())   SERIAL_CHAR('X'); break;
+        default: break;
+      }
+    }
+  #endif
+  #if ENABLED(HAVE_TMC2208)
+    static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
+      switch(i) {
+        case TMC_TSTEP: { uint32_t data = 0; st.TSTEP(&data); MYSERIAL0.print(data); break; }
+        case TMC_PWM_SCALE: SERIAL_PRINT(st.pwm_scale_sum(), DEC); break;
+        case TMC_STEALTHCHOP: serialprintPGM(st.stealth() ? PSTR("true") : PSTR("false")); break;
+        case TMC_S2VSA: if (st.s2vsa()) SERIAL_CHAR('X'); break;
+        case TMC_S2VSB: if (st.s2vsb()) SERIAL_CHAR('X'); break;
+        default: break;
+      }
+    }
+    static void tmc_parse_drv_status(TMC2208Stepper &st, const TMC_drv_status_enum i) {
+      switch(i) {
+        case TMC_T157: if (st.t157()) SERIAL_CHAR('X'); break;
+        case TMC_T150: if (st.t150()) SERIAL_CHAR('X'); break;
+        case TMC_T143: if (st.t143()) SERIAL_CHAR('X'); break;
+        case TMC_T120: if (st.t120()) SERIAL_CHAR('X'); break;
+        default: break;
+      }
+    }
+  #endif
+
+  template <typename TMC>
+  static void tmc_status(TMC &st, TMC_AxisEnum axis, const TMC_debug_enum i, const float spmm) {
+    SERIAL_ECHO('\t');
+    switch(i) {
+      case TMC_CODES: SERIAL_ECHO(extended_axis_codes[axis]); break;
+      case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
+      case TMC_CURRENT: SERIAL_ECHO(st.getCurrent()); break;
+      case TMC_RMS_CURRENT: MYSERIAL0.print(st.rms_current()); break;
+      case TMC_MAX_CURRENT: SERIAL_PRINT((float)st.rms_current() * 1.41, 0); break;
+      case TMC_IRUN:
+        SERIAL_PRINT(st.irun(), DEC);
+        SERIAL_ECHOPGM("/31");
+        break;
+      case TMC_IHOLD:
+        SERIAL_PRINT(st.ihold(), DEC);
+        SERIAL_ECHOPGM("/31");
+        break;
+      case TMC_CS_ACTUAL:
+        SERIAL_PRINT(st.cs_actual(), DEC);
+        SERIAL_ECHOPGM("/31");
+        break;
+
+      case TMC_VSENSE: serialprintPGM(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); break;
+
+      case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
+      case TMC_TPWMTHRS: {
+          uint32_t tpwmthrs_val = st.TPWMTHRS();
+          SERIAL_ECHO(tpwmthrs_val);
+        }
+        break;
+      case TMC_TPWMTHRS_MMS: {
+          uint32_t tpwmthrs_val = st.TPWMTHRS();
+          tpwmthrs_val ? SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm)) : SERIAL_CHAR('-');
+        }
+        break;
+      case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;
+      case TMC_OTPW_TRIGGERED: serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false")); break;
+      case TMC_TOFF: SERIAL_PRINT(st.toff(), DEC); break;
+      case TMC_TBL: SERIAL_PRINT(st.blank_time(), DEC); break;
+      case TMC_HEND: SERIAL_PRINT(st.hysterisis_end(), DEC); break;
+      case TMC_HSTRT: SERIAL_PRINT(st.hysterisis_start(), DEC); break;
+      default: tmc_status(st, i); break;
+    }
+  }
+
+  template <typename TMC>
+  static void tmc_parse_drv_status(TMC &st, TMC_AxisEnum axis, const TMC_drv_status_enum i) {
+    SERIAL_CHAR('\t');
+    switch(i) {
+      case TMC_DRV_CODES:     SERIAL_ECHO(extended_axis_codes[axis]);  break;
+      case TMC_STST:          if (st.stst())         SERIAL_CHAR('X'); break;
+      case TMC_OLB:           if (st.olb())          SERIAL_CHAR('X'); break;
+      case TMC_OLA:           if (st.ola())          SERIAL_CHAR('X'); break;
+      case TMC_S2GB:          if (st.s2gb())         SERIAL_CHAR('X'); break;
+      case TMC_S2GA:          if (st.s2ga())         SERIAL_CHAR('X'); break;
+      case TMC_DRV_OTPW:      if (st.otpw())         SERIAL_CHAR('X'); break;
+      case TMC_OT:            if (st.ot())           SERIAL_CHAR('X'); break;
+      case TMC_DRV_CS_ACTUAL: SERIAL_PRINT(st.cs_actual(), DEC);       break;
+      case TMC_DRV_STATUS_HEX:drv_status_print_hex(extended_axis_codes[axis], st.DRV_STATUS()); break;
+      default: tmc_parse_drv_status(st, i); break;
+    }
+  }
+
+  static void tmc_debug_loop(const TMC_debug_enum i) {
+    #if X_IS_TRINAMIC
+      tmc_status(stepperX, TMC_X, i, planner.axis_steps_per_mm[X_AXIS]);
+    #endif
+    #if X2_IS_TRINAMIC
+      tmc_status(stepperX2, TMC_X2, i, planner.axis_steps_per_mm[X_AXIS]);
+    #endif
+
+    #if Y_IS_TRINAMIC
+      tmc_status(stepperY, TMC_Y, i, planner.axis_steps_per_mm[Y_AXIS]);
+    #endif
+    #if Y2_IS_TRINAMIC
+      tmc_status(stepperY2, TMC_Y2, i, planner.axis_steps_per_mm[Y_AXIS]);
+    #endif
+
+    #if Z_IS_TRINAMIC
+      tmc_status(stepperZ, TMC_Z, i, planner.axis_steps_per_mm[Z_AXIS]);
+    #endif
+    #if Z2_IS_TRINAMIC
+      tmc_status(stepperZ2, TMC_Z2, i, planner.axis_steps_per_mm[Z_AXIS]);
+    #endif
+
+    #if E0_IS_TRINAMIC
+      tmc_status(stepperE0, TMC_E0, i, planner.axis_steps_per_mm[E_AXIS]);
+    #endif
+    #if E1_IS_TRINAMIC
+      tmc_status(stepperE1, TMC_E1, i, planner.axis_steps_per_mm[E_AXIS+1]);
+    #endif
+    #if E2_IS_TRINAMIC
+      tmc_status(stepperE2, TMC_E2, i, planner.axis_steps_per_mm[E_AXIS+2]);
+    #endif
+    #if E3_IS_TRINAMIC
+      tmc_status(stepperE3, TMC_E3, i, planner.axis_steps_per_mm[E_AXIS+3]);
+    #endif
+    #if E4_IS_TRINAMIC
+      tmc_status(stepperE4, TMC_E4, i, planner.axis_steps_per_mm[E_AXIS+4]);
+    #endif
+
+    SERIAL_EOL();
+  }
+
+  static void drv_status_loop(const TMC_drv_status_enum i) {
+    #if X_IS_TRINAMIC
+      tmc_parse_drv_status(stepperX, TMC_X, i);
+    #endif
+    #if X2_IS_TRINAMIC
+      tmc_parse_drv_status(stepperX2, TMC_X2, i);
+    #endif
+
+    #if Y_IS_TRINAMIC
+      tmc_parse_drv_status(stepperY, TMC_Y, i);
+    #endif
+    #if Y2_IS_TRINAMIC
+      tmc_parse_drv_status(stepperY2, TMC_Y2, i);
+    #endif
+
+    #if Z_IS_TRINAMIC
+      tmc_parse_drv_status(stepperZ, TMC_Z, i);
+    #endif
+    #if Z2_IS_TRINAMIC
+      tmc_parse_drv_status(stepperZ2, TMC_Z2, i);
+    #endif
+
+    #if E0_IS_TRINAMIC
+      tmc_parse_drv_status(stepperE0, TMC_E0, i);
+    #endif
+    #if E1_IS_TRINAMIC
+      tmc_parse_drv_status(stepperE1, TMC_E1, i);
+    #endif
+    #if E2_IS_TRINAMIC
+      tmc_parse_drv_status(stepperE2, TMC_E2, i);
+    #endif
+    #if E3_IS_TRINAMIC
+      tmc_parse_drv_status(stepperE3, TMC_E3, i);
+    #endif
+    #if E4_IS_TRINAMIC
+      tmc_parse_drv_status(stepperE4, TMC_E4, i);
+    #endif
+
+    SERIAL_EOL();
+  }
+
+  /**
+   * M122 report functions
+   */
+  void tmc_set_report_status(const bool status) {
+    if ((report_tmc_status = status))
+      SERIAL_ECHOLNPGM("axis:pwm_scale |status_response|");
+  }
+
+  void tmc_report_all() {
+    #define TMC_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL);  tmc_debug_loop(ITEM); }while(0)
+    #define DRV_REPORT(LABEL, ITEM) do{ SERIAL_ECHOPGM(LABEL); drv_status_loop(ITEM); }while(0)
+    TMC_REPORT("\t",                 TMC_CODES);
+    TMC_REPORT("Enabled\t",          TMC_ENABLED);
+    TMC_REPORT("Set current",        TMC_CURRENT);
+    TMC_REPORT("RMS current",        TMC_RMS_CURRENT);
+    TMC_REPORT("MAX current",        TMC_MAX_CURRENT);
+    TMC_REPORT("Run current",        TMC_IRUN);
+    TMC_REPORT("Hold current",       TMC_IHOLD);
+    TMC_REPORT("CS actual\t",        TMC_CS_ACTUAL);
+    TMC_REPORT("PWM scale",          TMC_PWM_SCALE);
+    TMC_REPORT("vsense\t",           TMC_VSENSE);
+    TMC_REPORT("stealthChop",        TMC_STEALTHCHOP);
+    TMC_REPORT("msteps\t",           TMC_MICROSTEPS);
+    TMC_REPORT("tstep\t",            TMC_TSTEP);
+    TMC_REPORT("pwm\nthreshold\t",   TMC_TPWMTHRS);
+    TMC_REPORT("[mm/s]\t",           TMC_TPWMTHRS_MMS);
+    TMC_REPORT("OT prewarn",         TMC_OTPW);
+    TMC_REPORT("OT prewarn has\n"
+               "been triggered",     TMC_OTPW_TRIGGERED);
+    TMC_REPORT("off time\t",         TMC_TOFF);
+    TMC_REPORT("blank time",         TMC_TBL);
+    TMC_REPORT("hysterisis\n-end\t", TMC_HEND);
+    TMC_REPORT("-start\t",           TMC_HSTRT);
+    TMC_REPORT("Stallguard thrs",    TMC_SGT);
+
+    DRV_REPORT("DRVSTATUS",          TMC_DRV_CODES);
+    #if ENABLED(HAVE_TMC2130)
+      DRV_REPORT("stallguard\t",     TMC_STALLGUARD);
+      DRV_REPORT("sg_result\t",      TMC_SG_RESULT);
+      DRV_REPORT("fsactive\t",       TMC_FSACTIVE);
+    #endif
+    DRV_REPORT("stst\t",             TMC_STST);
+    DRV_REPORT("olb\t",              TMC_OLB);
+    DRV_REPORT("ola\t",              TMC_OLA);
+    DRV_REPORT("s2gb\t",             TMC_S2GB);
+    DRV_REPORT("s2ga\t",             TMC_S2GA);
+    DRV_REPORT("otpw\t",             TMC_DRV_OTPW);
+    DRV_REPORT("ot\t",               TMC_OT);
+    #if ENABLED(HAVE_TMC2208)
+      DRV_REPORT("157C\t",           TMC_T157);
+      DRV_REPORT("150C\t",           TMC_T150);
+      DRV_REPORT("143C\t",           TMC_T143);
+      DRV_REPORT("120C\t",           TMC_T120);
+      DRV_REPORT("s2vsa\t",          TMC_S2VSA);
+      DRV_REPORT("s2vsb\t",          TMC_S2VSB);
+    #endif
+    DRV_REPORT("Driver registers:",  TMC_DRV_STATUS_HEX);
+    SERIAL_EOL();
+  }
+
+#endif // TMC_DEBUG
+
+#if ENABLED(SENSORLESS_HOMING)
+
+  void tmc_sensorless_homing(TMC2130Stepper &st, bool enable/*=true*/) {
+    #if ENABLED(STEALTHCHOP)
+      st.coolstep_min_speed(enable ? 1024UL * 1024UL - 1UL : 0);
+      st.stealthChop(!enable);
+    #endif
+    st.diag1_stall(enable ? 1 : 0);
+  }
+
+#endif // SENSORLESS_HOMING
+
 #endif // HAS_TRINAMIC

commit f7efac57b7ac607405529a71b4e36a6545525c89
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sun Nov 5 08:49:38 2017 -0600

    Multi-host support

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index ef80495f6d..b799462d35 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -146,12 +146,12 @@ char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1",
       const uint32_t pwm_scale = get_pwm_scale(st);
       SERIAL_ECHO(axisID);
       SERIAL_ECHOPAIR(":", pwm_scale);
-      SERIAL_ECHO(" |0b"); MYSERIAL.print(get_status_response(st), BIN);
+      SERIAL_ECHO(" |0b"); SERIAL_PRINT(get_status_response(st), BIN);
       SERIAL_ECHO("| ");
       if (data.is_error) SERIAL_ECHO('E');
       else if (data.is_ot) SERIAL_ECHO('O');
       else if (data.is_otpw) SERIAL_ECHO('W');
-      else if (otpw_cnt>0) MYSERIAL.print(otpw_cnt, DEC);
+      else if (otpw_cnt>0) SERIAL_PRINT(otpw_cnt, DEC);
       else if (st.flag_otpw) SERIAL_ECHO('F');
       SERIAL_ECHO("\t");
     }

commit 9d923c6c03e87cc8b66882ed9325ac47ddf9c3a0
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 29 21:38:08 2017 +0200

    Fix TMC gcode commands

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 3a70528cfb..ef80495f6d 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -35,56 +35,6 @@
 bool report_tmc_status = false;
 char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1", "E2", "E3", "E4" };
 
-template<typename TMC>
-void tmc_get_current(TMC &st, const char name[]) {
-  SERIAL_ECHO(name);
-  SERIAL_ECHOPGM(" axis driver current: ");
-  SERIAL_ECHOLN(st.getCurrent());
-}
-template<typename TMC>
-void tmc_set_current(TMC &st, const char name[], const int mA) {
-  st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
-  tmc_get_current(st, name);
-}
-
-template<typename TMC>
-void tmc_report_otpw(TMC &st, const char name[]) {
-  SERIAL_ECHO(name);
-  SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
-  serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
-  SERIAL_EOL();
-}
-template<typename TMC>
-void tmc_clear_otpw(TMC &st, const char name[]) {
-  st.clear_otpw();
-  SERIAL_ECHO(name);
-  SERIAL_ECHOLNPGM(" prewarn flag cleared");
-}
-
-template<typename TMC>
-void tmc_get_pwmthrs(TMC &st, const char name[], const uint16_t spmm) {
-  SERIAL_ECHO(name);
-  SERIAL_ECHOPGM(" stealthChop max speed set to ");
-  SERIAL_ECHOLN(12650000UL * st.microsteps() / (256 * st.TPWMTHRS() * spmm));
-}
-template<typename TMC>
-void tmc_set_pwmthrs(TMC &st, const char name[], const int32_t thrs, const uint32_t spmm) {
-  st.TPWMTHRS(12650000UL * st.microsteps() / (256 * thrs * spmm));
-  tmc_get_pwmthrs(st, name, spmm);
-}
-
-template<typename TMC>
-void tmc_get_sgt(TMC &st, const char name[]) {
-  SERIAL_ECHO(name);
-  SERIAL_ECHOPGM(" driver homing sensitivity set to ");
-  MYSERIAL.println(st.sgt(), DEC);
-}
-template<typename TMC>
-void tmc_set_sgt(TMC &st, const char name[], const int8_t sgt_val) {
-  st.sgt(sgt_val);
-  tmc_get_sgt(st, name);
-}
-
 /*
  * Check for over temperature or short to ground error flags.
  * Report and log warning of overtemperature condition.

commit b259bb46706fbd5034ddf1881d46159cd79232ef
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Dec 25 09:05:31 2017 -0600

    Fix tmc_util global vars

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
index 64a83e0e32..3a70528cfb 100644
--- a/Marlin/src/feature/tmc_util.cpp
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -32,6 +32,9 @@
 #include "../libs/duration_t.h"
 #include "../gcode/gcode.h"
 
+bool report_tmc_status = false;
+char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1", "E2", "E3", "E4" };
+
 template<typename TMC>
 void tmc_get_current(TMC &st, const char name[]) {
   SERIAL_ECHO(name);

commit 0cd1e91056213d6a0bd422848ccff7cd1191d001
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 15 23:03:14 2017 +0200

    [2.0.x] TMC driver update (#8769)

diff --git a/Marlin/src/feature/tmc_util.cpp b/Marlin/src/feature/tmc_util.cpp
new file mode 100644
index 0000000000..64a83e0e32
--- /dev/null
+++ b/Marlin/src/feature/tmc_util.cpp
@@ -0,0 +1,266 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../inc/MarlinConfig.h"
+
+#if HAS_TRINAMIC
+
+#include "tmc_util.h"
+#include "../Marlin.h"
+
+#include "../module/stepper_indirection.h"
+#include "../module/printcounter.h"
+#include "../libs/duration_t.h"
+#include "../gcode/gcode.h"
+
+template<typename TMC>
+void tmc_get_current(TMC &st, const char name[]) {
+  SERIAL_ECHO(name);
+  SERIAL_ECHOPGM(" axis driver current: ");
+  SERIAL_ECHOLN(st.getCurrent());
+}
+template<typename TMC>
+void tmc_set_current(TMC &st, const char name[], const int mA) {
+  st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
+  tmc_get_current(st, name);
+}
+
+template<typename TMC>
+void tmc_report_otpw(TMC &st, const char name[]) {
+  SERIAL_ECHO(name);
+  SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
+  serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
+  SERIAL_EOL();
+}
+template<typename TMC>
+void tmc_clear_otpw(TMC &st, const char name[]) {
+  st.clear_otpw();
+  SERIAL_ECHO(name);
+  SERIAL_ECHOLNPGM(" prewarn flag cleared");
+}
+
+template<typename TMC>
+void tmc_get_pwmthrs(TMC &st, const char name[], const uint16_t spmm) {
+  SERIAL_ECHO(name);
+  SERIAL_ECHOPGM(" stealthChop max speed set to ");
+  SERIAL_ECHOLN(12650000UL * st.microsteps() / (256 * st.TPWMTHRS() * spmm));
+}
+template<typename TMC>
+void tmc_set_pwmthrs(TMC &st, const char name[], const int32_t thrs, const uint32_t spmm) {
+  st.TPWMTHRS(12650000UL * st.microsteps() / (256 * thrs * spmm));
+  tmc_get_pwmthrs(st, name, spmm);
+}
+
+template<typename TMC>
+void tmc_get_sgt(TMC &st, const char name[]) {
+  SERIAL_ECHO(name);
+  SERIAL_ECHOPGM(" driver homing sensitivity set to ");
+  MYSERIAL.println(st.sgt(), DEC);
+}
+template<typename TMC>
+void tmc_set_sgt(TMC &st, const char name[], const int8_t sgt_val) {
+  st.sgt(sgt_val);
+  tmc_get_sgt(st, name);
+}
+
+/*
+ * Check for over temperature or short to ground error flags.
+ * Report and log warning of overtemperature condition.
+ * Reduce driver current in a persistent otpw condition.
+ * Keep track of otpw counter so we don't reduce current on a single instance,
+ * and so we don't repeatedly report warning before the condition is cleared.
+ */
+#if ENABLED(MONITOR_DRIVER_STATUS)
+  struct TMC_driver_data {
+    uint32_t drv_status;
+    bool is_otpw;
+    bool is_ot;
+    bool is_error;
+  };
+  #if ENABLED(HAVE_TMC2130)
+    static uint32_t get_pwm_scale(TMC2130Stepper &st) { return st.PWM_SCALE(); }
+    static uint8_t get_status_response(TMC2130Stepper &st) { return st.status_response&0xF; }
+    static TMC_driver_data get_driver_data(TMC2130Stepper &st) {
+      constexpr uint32_t OTPW_bm = 0x4000000UL;
+      constexpr uint8_t OTPW_bp = 26;
+      constexpr uint32_t OT_bm = 0x2000000UL;
+      constexpr uint8_t OT_bp = 25;
+      constexpr uint8_t DRIVER_ERROR_bm = 0x2UL;
+      constexpr uint8_t DRIVER_ERROR_bp = 1;
+      TMC_driver_data data;
+      data.drv_status = st.DRV_STATUS();
+      data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
+      data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
+      data.is_error = (st.status_response & DRIVER_ERROR_bm)>>DRIVER_ERROR_bp;
+      return data;
+    }
+  #endif
+  #if ENABLED(HAVE_TMC2208)
+    static uint32_t get_pwm_scale(TMC2208Stepper &st) { return st.pwm_scale_sum(); }
+    static uint8_t get_status_response(TMC2208Stepper &st) {
+      uint32_t drv_status = st.DRV_STATUS();
+      uint8_t gstat = st.GSTAT();
+      uint8_t response = 0;
+      response |= (drv_status >> (31-3)) & 0b1000;
+      response |= gstat & 0b11;
+      return response;
+    }
+    static TMC_driver_data get_driver_data(TMC2208Stepper &st) {
+      constexpr uint32_t OTPW_bm = 0b1ul;
+      constexpr uint8_t OTPW_bp = 0;
+      constexpr uint32_t OT_bm = 0b10ul;
+      constexpr uint8_t OT_bp = 1;
+      TMC_driver_data data;
+      data.drv_status = st.DRV_STATUS();
+      data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
+      data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
+      data.is_error = st.drv_err();
+      return data;
+    }
+  #endif
+
+  template<typename TMC>
+  uint8_t monitor_tmc_driver(TMC &st, const char axisID, uint8_t otpw_cnt) {
+    TMC_driver_data data = get_driver_data(st);
+
+    #if ENABLED(STOP_ON_ERROR)
+      if (data.is_error) {
+        SERIAL_EOL();
+        SERIAL_ECHO(axisID);
+        SERIAL_ECHO(" driver error detected:");
+        if (data.is_ot) SERIAL_ECHO("\novertemperature");
+        if (st.s2ga()) SERIAL_ECHO("\nshort to ground (coil A)");
+        if (st.s2gb()) SERIAL_ECHO("\nshort to ground (coil B)");
+        SERIAL_EOL();
+        #if ENABLED(TMC_DEBUG)
+          _M122();
+        #endif
+        kill(PSTR("Driver error"));
+      }
+    #endif
+
+    // Report if a warning was triggered
+    if (data.is_otpw && otpw_cnt==0) {
+      char timestamp[10];
+      duration_t elapsed = print_job_timer.duration();
+      const bool has_days = (elapsed.value > 60*60*24L);
+      (void)elapsed.toDigital(timestamp, has_days);
+      SERIAL_EOL();
+      SERIAL_ECHO(timestamp);
+      SERIAL_ECHOPGM(": ");
+      SERIAL_ECHO(axisID);
+      SERIAL_ECHOPGM(" driver overtemperature warning! (");
+      SERIAL_ECHO(st.getCurrent());
+      SERIAL_ECHOLN("mA)");
+    }
+    #if CURRENT_STEP_DOWN > 0
+      // Decrease current if is_otpw is true and driver is enabled and there's been more then 4 warnings
+      if (data.is_otpw && !st.isEnabled() && otpw_cnt > 4) {
+        st.setCurrent(st.getCurrent() - CURRENT_STEP_DOWN, R_SENSE, HOLD_MULTIPLIER);
+        #if ENABLED(REPORT_CURRENT_CHANGE)
+          SERIAL_ECHO(axisID);
+          SERIAL_ECHOLNPAIR(" current decreased to ", st.getCurrent());
+        #endif
+      }
+    #endif
+
+    if (data.is_otpw) {
+      otpw_cnt++;
+      st.flag_otpw = true;
+    }
+    else if (otpw_cnt>0) otpw_cnt--;
+
+    if (report_tmc_status) {
+      const uint32_t pwm_scale = get_pwm_scale(st);
+      SERIAL_ECHO(axisID);
+      SERIAL_ECHOPAIR(":", pwm_scale);
+      SERIAL_ECHO(" |0b"); MYSERIAL.print(get_status_response(st), BIN);
+      SERIAL_ECHO("| ");
+      if (data.is_error) SERIAL_ECHO('E');
+      else if (data.is_ot) SERIAL_ECHO('O');
+      else if (data.is_otpw) SERIAL_ECHO('W');
+      else if (otpw_cnt>0) MYSERIAL.print(otpw_cnt, DEC);
+      else if (st.flag_otpw) SERIAL_ECHO('F');
+      SERIAL_ECHO("\t");
+    }
+
+    return otpw_cnt;
+  }
+
+  #define HAS_HW_COMMS(ST) ENABLED(ST##_IS_TMC2130)|| (ENABLED(ST##_IS_TMC2208) && defined(ST##_HARDWARE_SERIAL))
+
+  void monitor_tmc_driver() {
+    static millis_t next_cOT = 0;
+    if (ELAPSED(millis(), next_cOT)) {
+      next_cOT = millis() + 500;
+      #if HAS_HW_COMMS(X) || ENABLED(IS_TRAMS)
+        static uint8_t x_otpw_cnt = 0;
+        x_otpw_cnt = monitor_tmc_driver(stepperX, axis_codes[X_AXIS], x_otpw_cnt);
+      #endif
+      #if HAS_HW_COMMS(Y) || ENABLED(IS_TRAMS)
+        static uint8_t y_otpw_cnt = 0;
+        y_otpw_cnt = monitor_tmc_driver(stepperY, axis_codes[Y_AXIS], y_otpw_cnt);
+      #endif
+      #if HAS_HW_COMMS(Z) || ENABLED(IS_TRAMS)
+        static uint8_t z_otpw_cnt = 0;
+        z_otpw_cnt = monitor_tmc_driver(stepperZ, axis_codes[Z_AXIS], z_otpw_cnt);
+      #endif
+      #if HAS_HW_COMMS(X2)
+        static uint8_t x2_otpw_cnt = 0;
+        x2_otpw_cnt = monitor_tmc_driver(stepperX2, axis_codes[X_AXIS], x2_otpw_cnt);
+      #endif
+      #if HAS_HW_COMMS(Y2)
+        static uint8_t y2_otpw_cnt = 0;
+        y2_otpw_cnt = monitor_tmc_driver(stepperY2, axis_codes[Y_AXIS], y2_otpw_cnt);
+      #endif
+      #if HAS_HW_COMMS(Z2)
+        static uint8_t z2_otpw_cnt = 0;
+        z2_otpw_cnt = monitor_tmc_driver(stepperZ2, axis_codes[Z_AXIS], z2_otpw_cnt);
+      #endif
+      #if HAS_HW_COMMS(E0) || ENABLED(IS_TRAMS)
+        static uint8_t e0_otpw_cnt = 0;
+        e0_otpw_cnt = monitor_tmc_driver(stepperE0, axis_codes[E_AXIS], e0_otpw_cnt);
+      #endif
+      #if HAS_HW_COMMS(E1)
+        static uint8_t e1_otpw_cnt = 0;
+        e1_otpw_cnt = monitor_tmc_driver(stepperE1, axis_codes[E_AXIS], e1_otpw_cnt);
+      #endif
+      #if HAS_HW_COMMS(E2)
+        static uint8_t e2_otpw_cnt = 0;
+        e2_otpw_cnt = monitor_tmc_driver(stepperE2, axis_codes[E_AXIS], e2_otpw_cnt);
+      #endif
+      #if HAS_HW_COMMS(E3)
+        static uint8_t e3_otpw_cnt = 0;
+        e3_otpw_cnt = monitor_tmc_driver(stepperE3, axis_codes[E_AXIS], e3_otpw_cnt);
+      #endif
+      #if HAS_HW_COMMS(E4)
+        static uint8_t e4_otpw_cnt = 0;
+        e4_otpw_cnt = monitor_tmc_driver(stepperE4, axis_codes[E_AXIS], e4_otpw_cnt);
+      #endif
+
+      if (report_tmc_status) SERIAL_EOL();
+    }
+  }
+
+#endif // MONITOR_DRIVER_STATUS
+
+#endif // HAS_TRINAMIC
