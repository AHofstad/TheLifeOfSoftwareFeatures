commit ee99eed3bf9f5d811b596058932b88d8ed5298a1
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Mon Jul 15 21:57:25 2024 +0300

    🚸 Improved menu responsiveness with MarlinUI + U8Glib. (#26555)
    
    Co-authored-by: Jason Smith <jason.inet@gmail.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 8b24cd26eb..fc21704022 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -358,25 +358,21 @@ void MarlinUI::init() {
   #if HAS_MEDIA
 
     #if MARLINUI_SCROLL_NAME
-      uint8_t MarlinUI::filename_scroll_pos, MarlinUI::filename_scroll_max;
+      static uint8_t filename_scroll_pos, filename_scroll_max;
     #endif
 
-    const char * MarlinUI::scrolled_filename(CardReader &theCard, const uint8_t maxlen, uint8_t hash, const bool doScroll) {
+    const char * MarlinUI::scrolled_filename(CardReader &theCard, const uint8_t maxlen, const bool doScroll) {
       const char *outstr = theCard.longest_filename();
       if (theCard.longFilename[0]) {
         #if MARLINUI_SCROLL_NAME
           if (doScroll) {
-            for (uint8_t l = FILENAME_LENGTH; l--;)
-              hash = ((hash << 1) | (hash >> 7)) ^ theCard.filename[l];      // rotate, xor
-            static uint8_t filename_scroll_hash;
-            if (filename_scroll_hash != hash) {                              // If the hash changed...
-              filename_scroll_hash = hash;                                   // Save the new hash
-              filename_scroll_max = _MAX(0, utf8_strlen(theCard.longFilename) - maxlen); // Update the scroll limit
-              filename_scroll_pos = 0;                                       // Reset scroll to the start
-              lcd_status_update_delay = 8;                                   // Don't scroll right away
+            filename_scroll_max = _MAX(0, utf8_strlen(theCard.longFilename) - maxlen);
+            if (filename_scroll_max) {
+              // Ensure filename_scroll_pos isn't out of bounds even though it should never happen.
+              if (filename_scroll_pos > filename_scroll_max) filename_scroll_pos = 0;
+              // Advance byte position corresponding to filename_scroll_pos char position
+              outstr += TERN(UTF_FILENAME_SUPPORT, utf8_byte_pos_by_char_num(outstr, filename_scroll_pos), filename_scroll_pos);
             }
-            // Advance byte position corresponding to filename_scroll_pos char position
-            outstr += TERN(UTF_FILENAME_SUPPORT, utf8_byte_pos_by_char_num(outstr, filename_scroll_pos), filename_scroll_pos);
           }
         #else
           theCard.longFilename[
@@ -1002,22 +998,19 @@ void MarlinUI::init() {
 
     #endif // HAS_MARLINUI_MENU
 
-    if (ELAPSED(ms, next_lcd_update_ms) || TERN0(HAS_MARLINUI_U8GLIB, drawing_screen)) {
-
+    const bool lcd_update_ms_elapsed = ELAPSED(ms, next_lcd_update_ms);
+    if (lcd_update_ms_elapsed) {
       next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
       #if HAS_TOUCH_BUTTONS
-
         if (on_status_screen()) next_lcd_update_ms += (LCD_UPDATE_INTERVAL) * 2;
 
         TERN_(HAS_ENCODER_ACTION, touch_buttons = touchBt.read_buttons());
-
       #endif
 
       TERN_(LCD_HAS_STATUS_INDICATORS, update_indicators());
 
       #if HAS_ENCODER_ACTION
-
         TERN_(HAS_SLOW_BUTTONS, slow_buttons = read_slow_buttons()); // Buttons that take too long to read in interrupt context
 
         if (TERN0(IS_RRW_KEYPAD, handle_keypad()))
@@ -1082,9 +1075,16 @@ void MarlinUI::init() {
           #endif
 
           refresh(LCDVIEW_REDRAW_NOW);
+          TERN_(HAS_MARLINUI_U8GLIB, drawing_screen = false);
+          #if MARLINUI_SCROLL_NAME
+            filename_scroll_max = 0;
+            filename_scroll_pos = 0;
+            lcd_status_update_delay = 9;
+          #endif
 
           TERN_(HAS_LED_POWEROFF_TIMEOUT, if (!powerManager.psu_on) leds.reset_timeout(ms));
-        } // encoder or click
+
+        } // encoder activity
 
       #endif // HAS_ENCODER_ACTION
 
@@ -1094,19 +1094,23 @@ void MarlinUI::init() {
         lcd_status_update_delay = TERN(HAS_MARLINUI_U8GLIB, 12, 9);
         if (max_display_update_time) max_display_update_time--;  // Be sure never go to a very big number
         refresh(LCDVIEW_REDRAW_NOW);
+        TERN_(HAS_MARLINUI_U8GLIB, drawing_screen = false);
       }
 
-      #if ALL(HAS_MARLINUI_MENU, SCROLL_LONG_FILENAMES)
+      #if MARLINUI_SCROLL_NAME
         // If scrolling of long file names is enabled and we are in the sd card menu,
         // cause a refresh to occur until all the text has scrolled into view.
-        if (currentScreen == menu_media && !lcd_status_update_delay--) {
+        if (currentScreen == menu_media && filename_scroll_max && !lcd_status_update_delay--) {
           lcd_status_update_delay = ++filename_scroll_pos >= filename_scroll_max ? 12 : 4; // Long delay at end and start
           if (filename_scroll_pos > filename_scroll_max) filename_scroll_pos = 0;
           refresh(LCDVIEW_REDRAW_NOW);
+          TERN_(HAS_MARLINUI_U8GLIB, drawing_screen = false);
           reset_status_timeout(ms);
         }
       #endif
+    }
 
+    if (lcd_update_ms_elapsed || drawing_screen) {
       // Then we want to use only 50% of the time
       const uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
 
@@ -1128,7 +1132,6 @@ void MarlinUI::init() {
         TERN_(HAS_ADC_BUTTONS, keypad_buttons = 0);
 
         #if HAS_MARLINUI_U8GLIB
-
           #if ENABLED(LIGHTWEIGHT_UI)
             const bool in_status = on_status_screen(),
                        do_u8g_loop = !in_status;
@@ -1157,14 +1160,11 @@ void MarlinUI::init() {
               return;
             }
           }
-
         #else
-
           run_current_screen();
 
           // Apply all DWIN drawing after processing
           TERN_(IS_DWIN_MARLINUI, dwinUpdateLCD());
-
         #endif
 
         TERN_(HAS_MARLINUI_MENU, lcd_clicked = false);
@@ -1209,8 +1209,7 @@ void MarlinUI::init() {
         case LCDVIEW_CALL_NO_REDRAW:
         default: break;
       } // switch
-
-    } // ELAPSED(ms, next_lcd_update_ms)
+    }
 
     TERN_(HAS_GRAPHICAL_TFT, tft_idle());
   }

commit 571783fc04314b0cac57948d343690fc1ea10a06
Author: David Buezas <dbuezas@users.noreply.github.com>
Date:   Sat Jul 6 23:41:02 2024 +0100

    🚸 SD card wake on insert, status screen on remove (#27197)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index bf5c43d98f..8b24cd26eb 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1824,13 +1824,14 @@ void MarlinUI::host_notify(const char * const cstr) {
   #endif
 
   void MarlinUI::media_changed(const uint8_t old_status, const uint8_t status) {
+    TERN_(HAS_DISPLAY_SLEEP, refresh_screen_timeout());
     if (old_status == status) {
       TERN_(EXTENSIBLE_UI, ExtUI::onMediaError()); // Failed to mount/unmount
       return;
     }
 
-    if (status) {
-      if (old_status < 2) {
+    if (old_status < 2) {   // Skip this section on first boot check
+      if (status) {         // Media Mounted
         #if ENABLED(EXTENSIBLE_UI)
           ExtUI::onMediaMounted();
         #elif ENABLED(BROWSE_MEDIA_ON_INSERT)
@@ -1841,16 +1842,16 @@ void MarlinUI::host_notify(const char * const cstr) {
           LCD_MESSAGE(MSG_MEDIA_INSERTED);
         #endif
       }
-    }
-    else {
-      if (old_status < 2) {
+      else {                // Media Removed
         #if ENABLED(EXTENSIBLE_UI)
           ExtUI::onMediaRemoved();
-        #elif HAS_SD_DETECT
+        #elif HAS_SD_DETECT // Q: Does "Media Removed" need to be shown for manual release too?
           LCD_MESSAGE(MSG_MEDIA_REMOVED);
           #if HAS_MARLINUI_MENU
-            if (!defer_return_to_status) return_to_status();
+            if (ENABLED(HAS_WIRED_LCD) || !defer_return_to_status) return_to_status();
           #endif
+        #elif HAS_WIRED_LCD
+          return_to_status();
         #endif
       }
     }

commit 4af5229cee2a2bb49ae53d76fbc145fc69d802c6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 5 20:08:07 2024 -0500

    🧑‍💻 Conditional HAS_LED_POWEROFF_TIMEOUT

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index a967d92135..bf5c43d98f 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -25,7 +25,7 @@
 #include "../MarlinCore.h" // for printingIsPaused
 #include "../gcode/parser.h" // for axis_is_rotational, using_inch_units
 
-#if LED_POWEROFF_TIMEOUT > 0 || ALL(HAS_WIRED_LCD, PRINTER_EVENT_LEDS) || (HAS_BACKLIGHT_TIMEOUT && defined(NEOPIXEL_BKGD_INDEX_FIRST))
+#if HAS_LED_POWEROFF_TIMEOUT || ALL(HAS_WIRED_LCD, PRINTER_EVENT_LEDS) || (HAS_BACKLIGHT_TIMEOUT && defined(NEOPIXEL_BKGD_INDEX_FIRST))
   #include "../feature/leds/leds.h"
 #endif
 
@@ -319,7 +319,7 @@ void MarlinUI::init() {
     #include "../feature/power_monitor.h"
   #endif
 
-  #if LED_POWEROFF_TIMEOUT > 0
+  #if HAS_LED_POWEROFF_TIMEOUT
     #include "../feature/power.h"
   #endif
 
@@ -943,9 +943,7 @@ void MarlinUI::init() {
     static uint16_t max_display_update_time = 0;
     const millis_t ms = millis();
 
-    #if LED_POWEROFF_TIMEOUT > 0
-      leds.update_timeout(powerManager.psu_on);
-    #endif
+    TERN_(HAS_LED_POWEROFF_TIMEOUT, leds.update_timeout(powerManager.psu_on));
 
     #if HAS_MARLINUI_MENU
 
@@ -1085,10 +1083,8 @@ void MarlinUI::init() {
 
           refresh(LCDVIEW_REDRAW_NOW);
 
-          #if LED_POWEROFF_TIMEOUT > 0
-            if (!powerManager.psu_on) leds.reset_timeout(ms);
-          #endif
-        } // encoder activity
+          TERN_(HAS_LED_POWEROFF_TIMEOUT, if (!powerManager.psu_on) leds.reset_timeout(ms));
+        } // encoder or click
 
       #endif // HAS_ENCODER_ACTION
 
@@ -1863,14 +1859,10 @@ void MarlinUI::host_notify(const char * const cstr) {
 
     refresh();
 
-    #if HAS_WIRED_LCD || LED_POWEROFF_TIMEOUT > 0
+    #if HAS_WIRED_LCD || HAS_LED_POWEROFF_TIMEOUT
       const millis_t ms = millis();
-    #endif
-
-    TERN_(HAS_WIRED_LCD, next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL); // Delay LCD update for SD activity
-
-    #if LED_POWEROFF_TIMEOUT > 0
-      leds.reset_timeout(ms);
+      TERN_(HAS_WIRED_LCD, next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL); // Delay LCD update for SD activity
+      TERN_(HAS_LED_POWEROFF_TIMEOUT, leds.reset_timeout(ms));
     #endif
   }
 

commit 1f9fc665ec21f95666801aa4fccc4f4f71932018
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 26 18:27:05 2024 -0500

    🚸 MarlinUI:: clear_for_drawing

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 5b83f0c6bf..a967d92135 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -226,6 +226,7 @@ void MarlinUI::init() {
   #endif
 
   init_lcd();
+  clear_lcd();
 
   #if BUTTON_EXISTS(EN1)
     SET_INPUT_PULLUP(BTN_EN1);
@@ -1204,7 +1205,7 @@ void MarlinUI::init() {
       // Change state of drawing flag between screen updates
       if (!drawing_screen) switch (lcdDrawUpdate) {
         case LCDVIEW_CLEAR_CALL_REDRAW:
-          clear_lcd(); break;
+          clear_for_drawing(); break;
         case LCDVIEW_REDRAW_NOW:
           refresh(LCDVIEW_NONE);
         case LCDVIEW_NONE:

commit 521e7eafce4921a36532e0a89f2cc7417c2c4e21
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 21 15:42:56 2024 -0500

    🧑‍💻 Clarify media "mounted"

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 7f10363eac..5b83f0c6bf 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1835,7 +1835,7 @@ void MarlinUI::host_notify(const char * const cstr) {
     if (status) {
       if (old_status < 2) {
         #if ENABLED(EXTENSIBLE_UI)
-          ExtUI::onMediaInserted();
+          ExtUI::onMediaMounted();
         #elif ENABLED(BROWSE_MEDIA_ON_INSERT)
           clear_menu_history();
           quick_feedback();

commit fde330af5a4143affc8bbc74af246e8bb5ac9c46
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Sun May 19 22:50:24 2024 -0400

    🎨 Fix MarlinUI "untyped" string args (#27046)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 930a87a520..7f10363eac 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1647,11 +1647,11 @@ void MarlinUI::host_notify(const char * const cstr) {
   //
   // Send the status line as a host notification
   //
-  void MarlinUI::_set_status(const char * const cstr, const bool, const bool pgm) {
-    host_notify(cstr);
+  void MarlinUI::_set_status(const char * const ustr, const bool, const bool pgm) {
+    host_notify(ustr);
   }
-  void MarlinUI::_set_alert(const char * const cstr, const int8_t, const bool pgm) {
-    host_notify(cstr);
+  void MarlinUI::_set_alert(const char * const ustr, const int8_t, const bool pgm) {
+    host_notify(ustr);
   }
   void MarlinUI::_set_status_and_level(const char * const ustr, const int8_t=0, const bool pgm) {
     pgm ? host_notify_P(ustr) : host_notify(ustr);

commit a3960dfa53394f9d105cbd23dc260ed81ff884f4
Author: David Buezas <dbuezas@users.noreply.github.com>
Date:   Thu May 9 23:20:57 2024 +0200

    🚸 New encoder logic & debounce (#26723)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index dad17814c6..930a87a520 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -227,34 +227,32 @@ void MarlinUI::init() {
 
   init_lcd();
 
-  #if HAS_DIGITAL_BUTTONS
-    #if BUTTON_EXISTS(EN1)
-      SET_INPUT_PULLUP(BTN_EN1);
-    #endif
-    #if BUTTON_EXISTS(EN2)
-      SET_INPUT_PULLUP(BTN_EN2);
-    #endif
-    #if BUTTON_EXISTS(ENC)
-      SET_INPUT_PULLUP(BTN_ENC);
-    #endif
-    #if BUTTON_EXISTS(ENC_EN)
-      SET_INPUT_PULLUP(BTN_ENC_EN);
-    #endif
-    #if BUTTON_EXISTS(BACK)
-      SET_INPUT_PULLUP(BTN_BACK);
-    #endif
-    #if BUTTON_EXISTS(UP)
-      SET_INPUT(BTN_UP);
-    #endif
-    #if BUTTON_EXISTS(DOWN)
-      SET_INPUT(BTN_DOWN);
-    #endif
-    #if BUTTON_EXISTS(LFT)
-      SET_INPUT(BTN_LEFT);
-    #endif
-    #if BUTTON_EXISTS(RT)
-      SET_INPUT(BTN_RIGHT);
-    #endif
+  #if BUTTON_EXISTS(EN1)
+    SET_INPUT_PULLUP(BTN_EN1);
+  #endif
+  #if BUTTON_EXISTS(EN2)
+    SET_INPUT_PULLUP(BTN_EN2);
+  #endif
+  #if BUTTON_EXISTS(ENC)
+    SET_INPUT_PULLUP(BTN_ENC);
+  #endif
+  #if BUTTON_EXISTS(ENC_EN)
+    SET_INPUT_PULLUP(BTN_ENC_EN);
+  #endif
+  #if BUTTON_EXISTS(BACK)
+    SET_INPUT_PULLUP(BTN_BACK);
+  #endif
+  #if BUTTON_EXISTS(UP)
+    SET_INPUT(BTN_UP);
+  #endif
+  #if BUTTON_EXISTS(DOWN)
+    SET_INPUT(BTN_DOWN);
+  #endif
+  #if BUTTON_EXISTS(LFT)
+    SET_INPUT(BTN_LEFT);
+  #endif
+  #if BUTTON_EXISTS(RT)
+    SET_INPUT(BTN_RIGHT);
   #endif
 
   #if HAS_SHIFT_ENCODER
@@ -1026,72 +1024,56 @@ void MarlinUI::init() {
         if (TERN0(IS_RRW_KEYPAD, handle_keypad()))
           reset_status_timeout(ms);
 
-        uint8_t abs_diff = ABS(encoderDiff);
-
-        #if ENCODER_PULSES_PER_STEP > 1
-          // When reversing the encoder direction, a movement step can be missed because
-          // encoderDiff has a non-zero residual value, making the controller unresponsive.
-          // The fix clears the residual value when the encoder is idle.
-          // Also check if past half the threshold to compensate for missed single steps.
-          static int8_t lastEncoderDiff;
-
-          // Timeout? No decoder change since last check. 10 or 20 times per second.
-          if (encoderDiff == lastEncoderDiff && abs_diff <= epps / 2)   // Same direction & size but not over a half-step?
-            encoderDiff = 0;                                            // Clear residual pulses.
-          else if (WITHIN(abs_diff, epps / 2 + 1, epps - 1)) {          // Past half of threshold?
-            abs_diff = epps;                                            // Treat as a full step size
-            encoderDiff = (encoderDiff < 0 ? -1 : 1) * abs_diff;        // ...in the spin direction.
-          }
-          if (lastEncoderDiff != encoderDiff) wake_display();
-          lastEncoderDiff = encoderDiff;
-        #endif
+        static int8_t lastEncoderDiff;
+        if (lastEncoderDiff != encoderDiff) wake_display();
+        lastEncoderDiff = encoderDiff;
 
+        const uint8_t abs_diff = ABS(encoderDiff);
         const bool encoderPastThreshold = (abs_diff >= epps);
-        if (encoderPastThreshold || lcd_clicked) {
-          if (encoderPastThreshold && TERN1(IS_TFTGLCD_PANEL, !external_control)) {
-
-            #if ALL(HAS_MARLINUI_MENU, ENCODER_RATE_MULTIPLIER)
-
-              int32_t encoder_multiplier = 1;
-
-              if (encoder_multiplier_enabled) {
-                // Note that the rate is always calculated between two passes through the
-                // loop and that the abs of the encoderDiff value is tracked.
-                static millis_t encoder_mult_prev_ms = 0;
-                const float encoderStepRate = ((float(abs_diff) / float(epps)) * 1000.0f) / float(ms - encoder_mult_prev_ms);
-                encoder_mult_prev_ms = ms;
-
-                if (ENCODER_100X_STEPS_PER_SEC > 0 && encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)
-                  encoder_multiplier = 100;
-                else if (ENCODER_10X_STEPS_PER_SEC > 0 && encoderStepRate >= ENCODER_10X_STEPS_PER_SEC)
-                  encoder_multiplier = 10;
-                else if (ENCODER_5X_STEPS_PER_SEC > 0 && encoderStepRate >= ENCODER_5X_STEPS_PER_SEC)
-                  encoder_multiplier = 5;
-
-                // Enable to output the encoder steps per second value
-                //#define ENCODER_RATE_MULTIPLIER_DEBUG
-                #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
-                  SERIAL_ECHO_MSG(
-                    "Enc Step Rate: ", encoderStepRate,
-                    "  Mult: ", encoder_multiplier,
-                    "  5X Steps: ", ENCODER_5X_STEPS_PER_SEC,
-                    "  10X Steps: ", ENCODER_10X_STEPS_PER_SEC,
-                    "  100X Steps: ", ENCODER_100X_STEPS_PER_SEC
-                  );
-                #endif
-              }
-
-            #else
-
-              constexpr int32_t encoder_multiplier = 1;
-
-            #endif // ENCODER_RATE_MULTIPLIER
+        if (encoderPastThreshold && TERN1(IS_TFTGLCD_PANEL, !external_control)) {
+
+          int32_t encoder_multiplier = 1;
+
+          #if ALL(HAS_MARLINUI_MENU, ENCODER_RATE_MULTIPLIER)
+
+            if (encoder_multiplier_enabled) {
+              // Note that the rate is always calculated between two passes through the
+              // loop and that the abs of the encoderDiff value is tracked.
+              static millis_t encoder_mult_prev_ms = 0;
+              const float encoderStepRate = ((float(abs_diff) / float(epps)) * 1000.0f) / float(ms - encoder_mult_prev_ms);
+              encoder_mult_prev_ms = ms;
+
+              if (ENCODER_100X_STEPS_PER_SEC > 0 && encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)
+                encoder_multiplier = 100;
+              else if (ENCODER_10X_STEPS_PER_SEC > 0 && encoderStepRate >= ENCODER_10X_STEPS_PER_SEC)
+                encoder_multiplier = 10;
+              else if (ENCODER_5X_STEPS_PER_SEC > 0 && encoderStepRate >= ENCODER_5X_STEPS_PER_SEC)
+                encoder_multiplier = 5;
+
+              // Enable to output the encoder steps per second value
+              //#define ENCODER_RATE_MULTIPLIER_DEBUG
+              #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
+                SERIAL_ECHO_MSG(
+                  "Enc Step Rate: ", encoderStepRate,
+                  "  Mult: ", encoder_multiplier,
+                  "  5X Steps: ", ENCODER_5X_STEPS_PER_SEC,
+                  "  10X Steps: ", ENCODER_10X_STEPS_PER_SEC,
+                  "  100X Steps: ", ENCODER_100X_STEPS_PER_SEC
+                );
+              #endif
+            }
 
-            if (can_encode()) encoderPosition += (encoderDiff * encoder_multiplier) / epps;
+          #endif // ENCODER_RATE_MULTIPLIER
 
-            encoderDiff = 0;
+          const int8_t fullSteps = encoderDiff / epps;
+          if (fullSteps != 0) {
+            encoderDiff -= fullSteps * epps;
+            if (can_encode() && !lcd_clicked)
+              encoderPosition += (fullSteps * encoder_multiplier);
           }
+        }
 
+        if (encoderPastThreshold || lcd_clicked) {
           reset_status_timeout(ms);
 
           #if HAS_BACKLIGHT_TIMEOUT
@@ -1312,123 +1294,155 @@ void MarlinUI::init() {
      */
     void MarlinUI::update_buttons() {
       const millis_t now = millis();
-      if (ELAPSED(now, next_button_update_ms)) {
 
-        #if HAS_DIGITAL_BUTTONS
+      #if HAS_MARLINUI_ENCODER
 
-          #if ANY_BUTTON(EN1, EN2, ENC, BACK)
+        const int8_t delta = get_encoder_delta(now);
+        if (delta) {
+          encoderDiff += delta * encoderDirection;
+          #if ALL(HAS_MARLINUI_MENU, AUTO_BED_LEVELING_UBL)
+            external_encoder();
+          #endif
+        }
 
-            uint8_t newbutton = 0;
-            if (BUTTON_PRESSED(EN1))                 newbutton |= EN_A;
-            if (BUTTON_PRESSED(EN2))                 newbutton |= EN_B;
-            if (can_encode() && BUTTON_PRESSED(ENC)) newbutton |= EN_C;
-            if (BUTTON_PRESSED(BACK))                newbutton |= EN_D;
+      #endif
 
-          #else
+      if (PENDING(now, next_button_update_ms)) return;
+
+      #if HAS_DIGITAL_BUTTONS
+
+        uint8_t newbuttons = 0;
+        #if ANY_BUTTON(ENC, BACK)
+          if (can_encode() && BUTTON_PRESSED(ENC)) newbuttons |= EN_C;
+          if (BUTTON_PRESSED(BACK))                newbuttons |= EN_D;
+        #endif
+
+        //
+        // Directional buttons
+        //
+        #if ANY_BUTTON(UP, DOWN, LEFT, RIGHT)
+
+          const int8_t pulses = epps * encoderDirection;
+
+          if (BUTTON_PRESSED(UP)) {
+            encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * pulses;
+            next_button_update_ms = now + 300;
+          }
+          else if (BUTTON_PRESSED(DOWN)) {
+            encoderDiff = -(ENCODER_STEPS_PER_MENU_ITEM) * pulses;
+            next_button_update_ms = now + 300;
+          }
+          else if (BUTTON_PRESSED(LEFT)) {
+            encoderDiff = -pulses;
+            next_button_update_ms = now + 300;
+          }
+          else if (BUTTON_PRESSED(RIGHT)) {
+            encoderDiff = pulses;
+            next_button_update_ms = now + 300;
+          }
 
-            constexpr uint8_t newbutton = 0;
+        #endif // UP || DOWN || LEFT || RIGHT
 
+        buttons = (newbuttons | TERN0(HAS_SLOW_BUTTONS, slow_buttons)
+          #if ALL(HAS_TOUCH_BUTTONS, HAS_ENCODER_ACTION)
+            | (touch_buttons & TERN(HAS_MARLINUI_ENCODER, ~(EN_A | EN_B), 0xFF))
           #endif
+        );
 
-          //
-          // Directional buttons
-          //
-          #if ANY_BUTTON(UP, DOWN, LEFT, RIGHT)
+      #elif HAS_ADC_BUTTONS
 
-            const int8_t pulses = epps * encoderDirection;
+        buttons = 0;
 
-            if (BUTTON_PRESSED(UP)) {
-              encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * pulses;
-              next_button_update_ms = now + 300;
-            }
-            else if (BUTTON_PRESSED(DOWN)) {
-              encoderDiff = -(ENCODER_STEPS_PER_MENU_ITEM) * pulses;
-              next_button_update_ms = now + 300;
-            }
-            else if (BUTTON_PRESSED(LEFT)) {
-              encoderDiff = -pulses;
-              next_button_update_ms = now + 300;
-            }
-            else if (BUTTON_PRESSED(RIGHT)) {
-              encoderDiff = pulses;
-              next_button_update_ms = now + 300;
-            }
+      #endif
 
-          #endif // UP || DOWN || LEFT || RIGHT
+      #if HAS_ADC_BUTTONS
+        if (keypad_buttons == 0) {
+          const uint8_t b = get_ADC_keyValue();
+          if (WITHIN(b, 1, 8)) keypad_buttons = _BV(b - 1);
+        }
+      #endif
 
-          buttons = (newbutton | TERN0(HAS_SLOW_BUTTONS, slow_buttons)
-            #if ALL(HAS_TOUCH_BUTTONS, HAS_ENCODER_ACTION)
-              | (touch_buttons & TERN(HAS_ENCODER_WHEEL, ~(EN_A | EN_B), 0xFF))
-            #endif
-          );
+      #if HAS_SHIFT_ENCODER
+        /**
+         * Set up Rotary Encoder bit values (for two pin encoders to indicate movement).
+         * These values are independent of which pins are used for EN_A / EN_B indications.
+         * The rotary encoder part is also independent of the LCD chipset.
+         */
+        uint8_t val = 0;
+        WRITE(SHIFT_LD_PIN, LOW);
+        WRITE(SHIFT_LD_PIN, HIGH);
+        for (uint8_t i = 0; i < 8; ++i) {
+          val >>= 1;
+          if (READ(SHIFT_OUT_PIN)) SBI(val, 7);
+          WRITE(SHIFT_CLK_PIN, HIGH);
+          WRITE(SHIFT_CLK_PIN, LOW);
+        }
+        TERN(REPRAPWORLD_KEYPAD, keypad_buttons, buttons) = ~val;
+      #endif
 
-        #elif HAS_ADC_BUTTONS
+      #if IS_TFTGLCD_PANEL
+        next_button_update_ms = now + (LCD_UPDATE_INTERVAL / 2);
+        buttons = slow_buttons;
+        TERN_(AUTO_BED_LEVELING_UBL, external_encoder());
+      #endif
 
-          buttons = 0;
+    } // update_buttons
 
-        #endif
+  #endif // HAS_ENCODER_ACTION
 
-        #if HAS_ADC_BUTTONS
-          if (keypad_buttons == 0) {
-            const uint8_t b = get_ADC_keyValue();
-            if (WITHIN(b, 1, 8)) keypad_buttons = _BV(b - 1);
-          }
-        #endif
+#endif // HAS_WIRED_LCD
 
-        #if HAS_SHIFT_ENCODER
-          /**
-           * Set up Rotary Encoder bit values (for two pin encoders to indicate movement).
-           * These values are independent of which pins are used for EN_A / EN_B indications.
-           * The rotary encoder part is also independent of the LCD chipset.
-           */
-          uint8_t val = 0;
-          WRITE(SHIFT_LD_PIN, LOW);
-          WRITE(SHIFT_LD_PIN, HIGH);
-          for (uint8_t i = 0; i < 8; ++i) {
-            val >>= 1;
-            if (READ(SHIFT_OUT_PIN)) SBI(val, 7);
-            WRITE(SHIFT_CLK_PIN, HIGH);
-            WRITE(SHIFT_CLK_PIN, LOW);
-          }
-          TERN(REPRAPWORLD_KEYPAD, keypad_buttons, buttons) = ~val;
-        #endif
+#if MARLINUI_ENCODER_DELTA
 
-        #if IS_TFTGLCD_PANEL
-          next_button_update_ms = now + (LCD_UPDATE_INTERVAL / 2);
-          buttons = slow_buttons;
-          TERN_(AUTO_BED_LEVELING_UBL, external_encoder());
-        #endif
+  #define ENCODER_DEBOUNCE_MS 2
 
-      } // next_button_update_ms
+  /**
+   * Get the encoder delta (-2 -1 0 +1 +2) since the last call, reading the live encoder state.
+   * Pins may be debounced to filter noise.
+   */
+  int8_t MarlinUI::get_encoder_delta(const millis_t &now/*=millis()*/) {
 
-      #if HAS_ENCODER_WHEEL
-        static uint8_t lastEncoderBits;
+    typedef struct { bool a:1, b:1; } enc_t;
 
-        // Manage encoder rotation
-        #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: encoderDiff += encoderDirection; break; case _E2: encoderDiff -= encoderDirection; }
+    const enc_t live_enc = { BUTTON_PRESSED(EN1), BUTTON_PRESSED(EN2) };
 
-        uint8_t enc = 0;
-        if (buttons & EN_A) enc |= B01;
-        if (buttons & EN_B) enc |= B10;
-        if (enc != lastEncoderBits) {
-          switch (enc) {
-            case 0: ENCODER_SPIN(1, 2); break;
-            case 2: ENCODER_SPIN(0, 3); break;
-            case 3: ENCODER_SPIN(2, 1); break;
-            case 1: ENCODER_SPIN(3, 0); break;
-          }
-          #if ALL(HAS_MARLINUI_MENU, AUTO_BED_LEVELING_UBL)
-            external_encoder();
-          #endif
-          lastEncoderBits = enc;
-        }
+    #if ENCODER_DEBOUNCE_MS
+
+      static enc_t enc;
+      static enc_t old_live;
+
+      static millis_t en_A_bounce_ms;
+      if (old_live.a != live_enc.a) en_A_bounce_ms = now + (ENCODER_DEBOUNCE_MS);
+      else if (ELAPSED(now, en_A_bounce_ms)) enc.a = live_enc.a;
 
-      #endif // HAS_ENCODER_WHEEL
+      static millis_t en_B_bounce_ms;
+      if (old_live.b != live_enc.b) en_B_bounce_ms = now + (ENCODER_DEBOUNCE_MS);
+      else if (ELAPSED(now, en_B_bounce_ms)) enc.b = live_enc.b;
+
+      old_live = live_enc;
+
+    #else
+
+      const enc_t &enc = live_enc;
+
+    #endif
+
+    static uint8_t old_pos;
+    const uint8_t pos = (enc.a ^ enc.b) | (enc.a << 1); // 0:00  1:10  2:11  3:01
+    int8_t delta = 0;
+    if (pos != old_pos) {
+      delta = (pos - old_pos + 4 + 1) % 4 - 1;
+      old_pos = pos;
+
+      static int8_t last_dir;
+      if (delta == 2) delta = last_dir * 2;
+      else last_dir = delta;
     }
+    return delta;
 
-  #endif // HAS_ENCODER_ACTION
+  } // get_encoder_delta
 
-#endif // HAS_WIRED_LCD
+#endif // MARLINUI_ENCODER_DELTA
 
 void MarlinUI::completion_feedback(const bool good/*=true*/) {
   wake_display(); // Wake the screen for all audio feedback

commit 49348716f538a16f7232efb0eed5d4e01d5a1494
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon May 6 19:58:00 2024 -0400

    🩹 Fix printf et.al. expecting F-strings (#27032)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index ef78dc2f1d..dad17814c6 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -739,7 +739,7 @@ void MarlinUI::init() {
 
   void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const lcd_component) {
     init();
-    status_printf(1, F(S_FMT ": " S_FMT), FTOP(lcd_error), FTOP(lcd_component));
+    status_printf(1, F(S_FMT ": " S_FMT), lcd_error, lcd_component);
     TERN_(HAS_MARLINUI_MENU, return_to_status());
 
     // RED ALERT. RED ALERT.

commit f5cf667c95e2e34130611e09e74052859f249214
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Wed May 1 16:08:15 2024 -0400

    🎨 Clarify some string parameters (#26949)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index dca18f2125..ef78dc2f1d 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1563,12 +1563,12 @@ void MarlinUI::host_notify(const char * const cstr) {
    *
    * @param pfmt    A constant format P-string
    */
-  void MarlinUI::status_printf_P(int8_t level, PGM_P const fmt, ...) {
+  void MarlinUI::status_printf_P(int8_t level, PGM_P const pfmt, ...) {
     if (set_alert_level(level)) return;
 
     va_list args;
-    va_start(args, fmt);
-    vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
+    va_start(args, pfmt);
+    vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, pfmt, args);
     va_end(args);
 
     host_notify(status_message);
@@ -1642,12 +1642,12 @@ void MarlinUI::host_notify(const char * const cstr) {
   void MarlinUI::_set_status_and_level(const char * const ustr, const int8_t=0, const bool pgm) {
     pgm ? host_notify_P(ustr) : host_notify(ustr);
   }
-  void MarlinUI::status_printf_P(int8_t level, PGM_P const fmt, ...) {
+  void MarlinUI::status_printf_P(int8_t level, PGM_P const pfmt, ...) {
     MString<30> msg;
 
     va_list args;
-    va_start(args, fmt);
-    vsnprintf_P(&msg, 30, fmt, args);
+    va_start(args, pfmt);
+    vsnprintf_P(&msg, 30, pfmt, args);
     va_end(args);
 
     host_notify(msg);

commit 1b091ecb874bb873c12c686746084e6ee71b056f
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Thu Apr 11 02:13:54 2024 -0400

    ✏️Minor style and typo fixups (#26947)
    
    * tweaks from PR, whitespace, wording in pause.h
    
    * Update Marlin/src/feature/pause.h

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index aaa8fb65e8..dca18f2125 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1668,7 +1668,7 @@ void MarlinUI::host_notify(const char * const cstr) {
         card.abortFilePrintSoon();
       else if (card.isMounted())
         card.closefile();
-      #endif
+    #endif
     #ifdef ACTION_ON_CANCEL
       hostui.cancel();
     #endif

commit 87e94f456348e944ba4487aed436c762dd718966
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon Apr 1 16:05:11 2024 -0400

    🚸 Update ProUI Plot graph - part 2 (#26563)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 4eed5f3c65..aaa8fb65e8 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -48,8 +48,6 @@ MarlinUI ui;
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "e3v2/creality/dwin.h"
-#elif ENABLED(DWIN_LCD_PROUI)
-  #include "e3v2/proui/dwin.h"
 #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
   #include "e3v2/jyersui/dwin.h"
 #endif
@@ -69,7 +67,7 @@ MarlinUI ui;
 constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
 #if HAS_STATUS_MESSAGE
-  #if ENABLED(STATUS_MESSAGE_SCROLLING) && ANY(HAS_WIRED_LCD, DWIN_LCD_PROUI)
+  #if ENABLED(STATUS_MESSAGE_SCROLLING)
     uint8_t MarlinUI::status_scroll_offset; // = 0
   #endif
   MString<MAX_MESSAGE_LENGTH> MarlinUI::status_message;
@@ -1490,7 +1488,7 @@ void MarlinUI::host_notify(const char * const cstr) {
 
     else if (!no_welcome) msg = GET_TEXT_F(WELCOME_MSG);
 
-    else if (ENABLED(DWIN_LCD_PROUI))
+    else if (ENABLED(STATUS_DO_CLEAR_EMPTY))
       msg = F("");
     else
       return;
@@ -1609,7 +1607,6 @@ void MarlinUI::host_notify(const char * const cstr) {
 
     TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
     TERN_(DWIN_CREALITY_LCD, dwinStatusChanged(status_message));
-    TERN_(DWIN_LCD_PROUI, dwinCheckStatusMessage());
     TERN_(DWIN_CREALITY_LCD_JYERSUI, jyersDWIN.updateStatus(status_message));
   }
 
@@ -1888,36 +1885,6 @@ void MarlinUI::host_notify(const char * const cstr) {
 
 #endif
 
-#if ALL(EXTENSIBLE_UI, ADVANCED_PAUSE_FEATURE)
-
-  void MarlinUI::pause_show_message(
-    const PauseMessage message,
-    const PauseMode mode/*=PAUSE_MODE_SAME*/,
-    const uint8_t extruder/*=active_extruder*/
-  ) {
-    if (mode != PAUSE_MODE_SAME) pause_mode = mode;
-    ExtUI::pauseModeStatus = message;
-    switch (message) {
-      case PAUSE_MESSAGE_PARKING:  ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING)); break;
-      case PAUSE_MESSAGE_CHANGING: ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT)); break;
-      case PAUSE_MESSAGE_UNLOAD:   ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD)); break;
-      case PAUSE_MESSAGE_WAITING:  ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING)); break;
-      case PAUSE_MESSAGE_INSERT:   ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_INSERT)); break;
-      case PAUSE_MESSAGE_LOAD:     ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_LOAD)); break;
-      case PAUSE_MESSAGE_PURGE:
-        ExtUI::onUserConfirmRequired(GET_TEXT_F(TERN(ADVANCED_PAUSE_CONTINUOUS_PURGE, MSG_FILAMENT_CHANGE_CONT_PURGE, MSG_FILAMENT_CHANGE_PURGE)));
-        break;
-      case PAUSE_MESSAGE_RESUME:   ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_RESUME)); break;
-      case PAUSE_MESSAGE_HEAT:     ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT)); break;
-      case PAUSE_MESSAGE_HEATING:  ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEATING)); break;
-      case PAUSE_MESSAGE_OPTION:   ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_OPTION_HEADER)); break;
-      case PAUSE_MESSAGE_STATUS:   break;
-      default: break;
-    }
-  }
-
-#endif
-
 #if ENABLED(EEPROM_SETTINGS)
 
   #if HAS_MARLINUI_MENU

commit 466282f322ae4f42a8f3db5e3c9765c38445fdc8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 31 18:20:37 2024 -0500

    🩹 Misc. changes from ProUI / ExtUI updates (#26928)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 99a5996a2d..4eed5f3c65 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1491,7 +1491,7 @@ void MarlinUI::host_notify(const char * const cstr) {
     else if (!no_welcome) msg = GET_TEXT_F(WELCOME_MSG);
 
     else if (ENABLED(DWIN_LCD_PROUI))
-        msg = F("");
+      msg = F("");
     else
       return;
 
@@ -1605,9 +1605,7 @@ void MarlinUI::host_notify(const char * const cstr) {
 
     #endif
 
-    #if ENABLED(STATUS_MESSAGE_SCROLLING) && ANY(HAS_WIRED_LCD, DWIN_LCD_PROUI)
-      status_scroll_offset = 0;
-    #endif
+    TERN_(STATUS_MESSAGE_SCROLLING, reset_status_scroll());
 
     TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
     TERN_(DWIN_CREALITY_LCD, dwinStatusChanged(status_message));
@@ -1622,7 +1620,7 @@ void MarlinUI::host_notify(const char * const cstr) {
       if (status_scroll_offset < status_message.glyphs())
         while (!START_OF_UTF8_CHAR(status_message[++status_scroll_offset]));
       else
-        status_scroll_offset = 0;
+        reset_status_scroll();
     }
 
     char* MarlinUI::status_and_len(uint8_t &len) {
@@ -1669,8 +1667,11 @@ void MarlinUI::host_notify(const char * const cstr) {
   void MarlinUI::abort_print() {
     #if HAS_MEDIA
       wait_for_heatup = wait_for_user = false;
-      card.abortFilePrintSoon();
-    #endif
+      if (IS_SD_PRINTING())
+        card.abortFilePrintSoon();
+      else if (card.isMounted())
+        card.closefile();
+      #endif
     #ifdef ACTION_ON_CANCEL
       hostui.cancel();
     #endif
@@ -1698,6 +1699,16 @@ void MarlinUI::host_notify(const char * const cstr) {
     }
   #endif
 
+  /**
+   * - Synchronize and put up a wait screen
+   * - Wake the display
+   * - Tell the host to present a "Resume" option
+   * - Print "Paused" on the display
+   * - One of three possibilities follow:
+   *   - If Parking, Print a message, send M125 P (which parks and waits), then M24 which will resume SD printing.
+   *   - If media exists call M25 to pause the SD print.
+   *   - For a host-only printer tell the host to pause the print in progress.
+   */
   void MarlinUI::pause_print() {
     #if HAS_MARLINUI_MENU
       synchronize(GET_TEXT_F(MSG_PAUSING));
@@ -1884,7 +1895,7 @@ void MarlinUI::host_notify(const char * const cstr) {
     const PauseMode mode/*=PAUSE_MODE_SAME*/,
     const uint8_t extruder/*=active_extruder*/
   ) {
-    pause_mode = mode;
+    if (mode != PAUSE_MODE_SAME) pause_mode = mode;
     ExtUI::pauseModeStatus = message;
     switch (message) {
       case PAUSE_MESSAGE_PARKING:  ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING)); break;

commit c8d51c27234bcb2b1419d238e8751593d855dadb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Mar 2 04:16:39 2024 +0100

    🚸 Enable G92.9 with rotational axes (#26174)
    
    - Supporting axes that can rotate forever.

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index f66b680bc1..99a5996a2d 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -23,6 +23,7 @@
 #include "../inc/MarlinConfig.h"
 
 #include "../MarlinCore.h" // for printingIsPaused
+#include "../gcode/parser.h" // for axis_is_rotational, using_inch_units
 
 #if LED_POWEROFF_TIMEOUT > 0 || ALL(HAS_WIRED_LCD, PRINTER_EVENT_LEDS) || (HAS_BACKLIGHT_TIMEOUT && defined(NEOPIXEL_BKGD_INDEX_FIRST))
   #include "../feature/leds/leds.h"
@@ -824,6 +825,13 @@ void MarlinUI::init() {
 
       const feedRate_t fr_mm_s = (axis < LOGICAL_AXES) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
 
+      /**
+       * For a rotational axis apply the "inch" to "mm" conversion factor. This mimics behaviour of the G-code G1
+       * (see get_destination_from_command). For moves involving only rotational axes, the planner will convert
+       * back to the feedrate in degrees-per-time unit.
+       */
+      const feedRate_t fr = parser.axis_is_rotational(axis) && parser.using_inch_units() ? IN_TO_MM(fr_mm_s) : fr_mm_s;
+
       #if IS_KINEMATIC
 
         #if HAS_MULTI_EXTRUDER
@@ -850,13 +858,13 @@ void MarlinUI::init() {
         // previous invocation is being blocked. Modifications to offset shouldn't be made while
         // processing is true or the planner will get out of sync.
         processing = true;
-        prepare_internal_move_to_destination(fr_mm_s);  // will set current_position from destination
+        prepare_internal_move_to_destination(fr);  // will set current_position from destination
         processing = false;
 
       #else
 
         // For Cartesian / Core motion simply move to the current_position
-        planner.buffer_line(current_position, fr_mm_s,
+        planner.buffer_line(current_position, fr,
           TERN_(MULTI_E_MANUAL, axis == E_AXIS ? e_index :) active_extruder
         );
 

commit 76b568830475d218a5229ff9736a155c5a0cb620
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Feb 9 19:11:37 2024 -0600

    🚸 Optional encoder multipliers

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 9a8152ba99..f66b680bc1 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1055,18 +1055,23 @@ void MarlinUI::init() {
                 const float encoderStepRate = ((float(abs_diff) / float(epps)) * 1000.0f) / float(ms - encoder_mult_prev_ms);
                 encoder_mult_prev_ms = ms;
 
-                if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoder_multiplier = 100;
-                else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoder_multiplier = 10;
+                if (ENCODER_100X_STEPS_PER_SEC > 0 && encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)
+                  encoder_multiplier = 100;
+                else if (ENCODER_10X_STEPS_PER_SEC > 0 && encoderStepRate >= ENCODER_10X_STEPS_PER_SEC)
+                  encoder_multiplier = 10;
+                else if (ENCODER_5X_STEPS_PER_SEC > 0 && encoderStepRate >= ENCODER_5X_STEPS_PER_SEC)
+                  encoder_multiplier = 5;
 
                 // Enable to output the encoder steps per second value
                 //#define ENCODER_RATE_MULTIPLIER_DEBUG
                 #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
-                  SERIAL_ECHO_START();
-                  SERIAL_ECHOPGM("Enc Step Rate: ", encoderStepRate);
-                  SERIAL_ECHOPGM("  Multiplier: ", encoder_multiplier);
-                  SERIAL_ECHOPGM("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
-                  SERIAL_ECHOPGM("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
-                  SERIAL_EOL();
+                  SERIAL_ECHO_MSG(
+                    "Enc Step Rate: ", encoderStepRate,
+                    "  Mult: ", encoder_multiplier,
+                    "  5X Steps: ", ENCODER_5X_STEPS_PER_SEC,
+                    "  10X Steps: ", ENCODER_10X_STEPS_PER_SEC,
+                    "  100X Steps: ", ENCODER_100X_STEPS_PER_SEC
+                  );
                 #endif
               }
 

commit 4aa48beb378fec6a6e7de0c8c3c7fe47f6551c24
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 7 18:25:13 2024 -0600

    🚸 Adjust encoder multiplier

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 313131d87a..9a8152ba99 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -398,12 +398,7 @@ void MarlinUI::init() {
     bool MarlinUI::screen_changed;
 
     #if ENABLED(ENCODER_RATE_MULTIPLIER)
-      bool MarlinUI::encoderRateMultiplierEnabled;
-      millis_t MarlinUI::lastEncoderMovementMillis = 0;
-      void MarlinUI::enable_encoder_multiplier(const bool onoff) {
-        encoderRateMultiplierEnabled = onoff;
-        lastEncoderMovementMillis = 0;
-      }
+      bool MarlinUI::encoder_multiplier_enabled;
     #endif
 
     #if ANY(REVERSE_MENU_DIRECTION, REVERSE_SELECT_DIRECTION)
@@ -614,8 +609,6 @@ void MarlinUI::init() {
 
   void MarlinUI::status_screen() {
 
-    TERN_(HAS_MARLINUI_MENU, ENCODER_RATE_MULTIPLY(false));
-
     #if BASIC_PROGRESS_BAR
 
       //
@@ -1053,41 +1046,37 @@ void MarlinUI::init() {
 
             #if ALL(HAS_MARLINUI_MENU, ENCODER_RATE_MULTIPLIER)
 
-              int32_t encoderMultiplier = 1;
-
-              if (encoderRateMultiplierEnabled) {
-                const float encoderMovementSteps = float(abs_diff) / epps;
-
-                if (lastEncoderMovementMillis) {
-                  // Note that the rate is always calculated between two passes through the
-                  // loop and that the abs of the encoderDiff value is tracked.
-                  const float encoderStepRate = encoderMovementSteps / float(ms - lastEncoderMovementMillis) * 1000;
-
-                  if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
-                  else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
-
-                  // Enable to output the encoder steps per second value
-                  //#define ENCODER_RATE_MULTIPLIER_DEBUG
-                  #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
-                    SERIAL_ECHO_START();
-                    SERIAL_ECHOPGM("Enc Step Rate: ", encoderStepRate);
-                    SERIAL_ECHOPGM("  Multiplier: ", encoderMultiplier);
-                    SERIAL_ECHOPGM("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
-                    SERIAL_ECHOPGM("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
-                    SERIAL_EOL();
-                  #endif
-                }
-
-                lastEncoderMovementMillis = ms;
-              } // encoderRateMultiplierEnabled
+              int32_t encoder_multiplier = 1;
+
+              if (encoder_multiplier_enabled) {
+                // Note that the rate is always calculated between two passes through the
+                // loop and that the abs of the encoderDiff value is tracked.
+                static millis_t encoder_mult_prev_ms = 0;
+                const float encoderStepRate = ((float(abs_diff) / float(epps)) * 1000.0f) / float(ms - encoder_mult_prev_ms);
+                encoder_mult_prev_ms = ms;
+
+                if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoder_multiplier = 100;
+                else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoder_multiplier = 10;
+
+                // Enable to output the encoder steps per second value
+                //#define ENCODER_RATE_MULTIPLIER_DEBUG
+                #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
+                  SERIAL_ECHO_START();
+                  SERIAL_ECHOPGM("Enc Step Rate: ", encoderStepRate);
+                  SERIAL_ECHOPGM("  Multiplier: ", encoder_multiplier);
+                  SERIAL_ECHOPGM("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
+                  SERIAL_ECHOPGM("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
+                  SERIAL_EOL();
+                #endif
+              }
 
             #else
 
-              constexpr int32_t encoderMultiplier = 1;
+              constexpr int32_t encoder_multiplier = 1;
 
             #endif // ENCODER_RATE_MULTIPLIER
 
-            if (can_encode()) encoderPosition += (encoderDiff * encoderMultiplier) / epps;
+            if (can_encode()) encoderPosition += (encoderDiff * encoder_multiplier) / epps;
 
             encoderDiff = 0;
           }

commit 1dee4d92c61b14458cd394d1f609f0dc80282092
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 4 12:09:08 2024 -0600

    🔧 TOUCH_IDLE_SLEEP_MINS => DISPLAY_SLEEP_MINUTES
    
    Follow up to #26517

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 23cb0a7058..313131d87a 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -214,14 +214,10 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
   millis_t MarlinUI::screen_timeout_ms = 0;
   void MarlinUI::refresh_screen_timeout() {
-    screen_timeout_ms = sleep_timeout_minutes ? millis() + sleep_timeout_minutes * 60UL * 1000UL : 0;
-    sleep_display(false);
+    screen_timeout_ms = sleep_timeout_minutes ? millis() + MIN_TO_MS(sleep_timeout_minutes) : 0;
+    wake_display();
   }
 
-  #if !HAS_TOUCH_SLEEP && !HAS_MARLINUI_U8GLIB // without DOGM (COLOR_UI)
-    void MarlinUI::sleep_display(const bool sleep) {} // if unimplemented
-  #endif
-
 #endif
 
 void MarlinUI::init() {
@@ -766,25 +762,9 @@ void MarlinUI::init() {
     draw_kill_screen();
   }
 
-  #if HAS_TOUCH_SLEEP
-    #if HAS_TOUCH_BUTTONS
-      #include "touch/touch_buttons.h"
-    #else
-      #include "tft/touch.h"
-    #endif
-    // Wake up a sleeping TFT
-    void MarlinUI::wakeup_screen() {
-      TERN(HAS_TOUCH_BUTTONS, touchBt.wakeUp(), touch.wakeUp());
-    }
-    #if HAS_DISPLAY_SLEEP && !HAS_MARLINUI_U8GLIB // without DOGM (COLOR_UI)
-      void MarlinUI::sleep_display(const bool sleep) {
-        if (!sleep) wakeup_screen(); // relay extra wake up events
-      }
-    #endif
-  #endif
-
   void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
-    TERN_(HAS_TOUCH_SLEEP, wakeup_screen()); // Wake up the TFT with most buttons
+    wake_display(); // Wake the screen for any click sound
+
     TERN_(HAS_MARLINUI_MENU, refresh());
 
     #if HAS_ENCODER_ACTION
@@ -1063,7 +1043,7 @@ void MarlinUI::init() {
             abs_diff = epps;                                            // Treat as a full step size
             encoderDiff = (encoderDiff < 0 ? -1 : 1) * abs_diff;        // ...in the spin direction.
           }
-          TERN_(HAS_TOUCH_SLEEP, if (lastEncoderDiff != encoderDiff) wakeup_screen());
+          if (lastEncoderDiff != encoderDiff) wake_display();
           lastEncoderDiff = encoderDiff;
         #endif
 
@@ -1448,14 +1428,14 @@ void MarlinUI::init() {
 
   #endif // HAS_ENCODER_ACTION
 
+#endif // HAS_WIRED_LCD
+
+void MarlinUI::completion_feedback(const bool good/*=true*/) {
+  wake_display(); // Wake the screen for all audio feedback
   #if HAS_SOUND
-    void MarlinUI::completion_feedback(const bool good/*=true*/) {
-      TERN_(HAS_TOUCH_SLEEP, wakeup_screen()); // Wake up on rotary encoder click...
-      if (good) OKAY_BUZZ(); else ERR_BUZZ();
-    }
+    if (good) OKAY_BUZZ(); else ERR_BUZZ();
   #endif
-
-#endif // HAS_WIRED_LCD
+}
 
 void MarlinUI::host_notify_P(PGM_P const pstr) {
   TERN_(HOST_STATUS_NOTIFICATIONS, hostui.notify_P(pstr));
@@ -1574,7 +1554,7 @@ void MarlinUI::host_notify(const char * const cstr) {
    */
   void MarlinUI::_set_alert(const char * const ustr, const int8_t level, const bool pgm) {
     pgm ? set_status_and_level_P(ustr, level) : set_status_and_level(ustr, level);
-    TERN_(HAS_TOUCH_SLEEP, wakeup_screen());
+    wake_display();
     TERN_(HAS_MARLINUI_MENU, return_to_status());
   }
 
@@ -1722,7 +1702,8 @@ void MarlinUI::host_notify(const char * const cstr) {
       defer_status_screen();
     #endif
 
-    TERN_(HAS_TOUCH_SLEEP, wakeup_screen());
+    wake_display();
+
     TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_open(PROMPT_PAUSE_RESUME, F("UI Pause"), F("Resume")));
 
     LCD_MESSAGE(MSG_PRINT_PAUSED);

commit 3ef192e7c7b18804ec7e3964a1366bd08355dc93
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 23 16:05:41 2024 -0600

    🎨 Cosmetic cleanup 23-01

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 97f15076fd..23cb0a7058 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -847,52 +847,51 @@ void MarlinUI::init() {
       if (processing) return;   // Prevent re-entry from idle() calls
 
       // Add a manual move to the queue?
-      if (axis != NO_AXIS_ENUM && ELAPSED(millis(), start_time) && !planner.is_full()) {
+      if (axis == NO_AXIS_ENUM || PENDING(millis(), start_time) || planner.is_full()) return;
 
-        const feedRate_t fr_mm_s = (axis < LOGICAL_AXES) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
+      const feedRate_t fr_mm_s = (axis < LOGICAL_AXES) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
 
-        #if IS_KINEMATIC
+      #if IS_KINEMATIC
 
-          #if HAS_MULTI_EXTRUDER
-            REMEMBER(ae, active_extruder);
-            #if MULTI_E_MANUAL
-              if (axis == E_AXIS) active_extruder = e_index;
-            #endif
+        #if HAS_MULTI_EXTRUDER
+          REMEMBER(ae, active_extruder);
+          #if MULTI_E_MANUAL
+            if (axis == E_AXIS) active_extruder = e_index;
           #endif
+        #endif
 
-          // Apply a linear offset to a single axis
-          if (axis == ALL_AXES_ENUM)
-            destination = all_axes_destination;
-          else if (axis <= LOGICAL_AXES) {
-            destination = current_position;
-            destination[axis] += offset;
-          }
+        // Apply a linear offset to a single axis
+        if (axis == ALL_AXES_ENUM)
+          destination = all_axes_destination;
+        else if (axis <= LOGICAL_AXES) {
+          destination = current_position;
+          destination[axis] += offset;
+        }
 
-          // Reset for the next move
-          offset = 0;
-          axis = NO_AXIS_ENUM;
+        // Reset for the next move
+        offset = 0;
+        axis = NO_AXIS_ENUM;
 
-          // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
-          // move_to_destination. This will cause idle() to be called, which can then call this function while the
-          // previous invocation is being blocked. Modifications to offset shouldn't be made while
-          // processing is true or the planner will get out of sync.
-          processing = true;
-          prepare_internal_move_to_destination(fr_mm_s);  // will set current_position from destination
-          processing = false;
+        // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
+        // move_to_destination. This will cause idle() to be called, which can then call this function while the
+        // previous invocation is being blocked. Modifications to offset shouldn't be made while
+        // processing is true or the planner will get out of sync.
+        processing = true;
+        prepare_internal_move_to_destination(fr_mm_s);  // will set current_position from destination
+        processing = false;
 
-        #else
+      #else
 
-          // For Cartesian / Core motion simply move to the current_position
-          planner.buffer_line(current_position, fr_mm_s,
-            TERN_(MULTI_E_MANUAL, axis == E_AXIS ? e_index :) active_extruder
-          );
+        // For Cartesian / Core motion simply move to the current_position
+        planner.buffer_line(current_position, fr_mm_s,
+          TERN_(MULTI_E_MANUAL, axis == E_AXIS ? e_index :) active_extruder
+        );
 
-          //SERIAL_ECHOLNPGM("Add planner.move with Axis ", C(AXIS_CHAR(axis)), " at FR ", fr_mm_s);
+        //SERIAL_ECHOLNPGM("Add planner.move with Axis ", C(AXIS_CHAR(axis)), " at FR ", fr_mm_s);
 
-          axis = NO_AXIS_ENUM;
+        axis = NO_AXIS_ENUM;
 
-        #endif
-      }
+      #endif
     }
 
     //

commit 7d751a20b1fc6ef920cbc56a68450302ac1eb973
Author: German Borisov <Borisov.German@gmail.com>
Date:   Fri Jan 19 22:17:36 2024 +0300

    ✨ Status Screen flow adjustment (#26627)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index dfb2a8d47c..97f15076fd 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -700,7 +700,7 @@ void MarlinUI::init() {
         else
           new_frm = old_frm;
       }
-      else if ((old_frm < 100 && new_frm > 100) || (old_frm > 100 && new_frm < 100))
+      else if ((old_frm < 100) == (new_frm > 100)) // Crossing 100? Stick at 100.
         new_frm = 100;
 
       LIMIT(new_frm, SPEED_EDIT_MIN, SPEED_EDIT_MAX);
@@ -720,7 +720,31 @@ void MarlinUI::init() {
         #endif
       }
 
-    #endif // ULTIPANEL_FEEDMULTIPLY
+    #elif ENABLED(ULTIPANEL_FLOWPERCENT)
+
+      const int16_t old_fp = planner.flow_percentage[active_extruder];
+            int16_t new_fp = old_fp + int16_t(encoderPosition);
+
+      // Dead zone at 100% flow percentage
+      if (old_fp == 100) {
+        if (int16_t(encoderPosition) > ENCODER_FEEDRATE_DEADZONE)
+          new_fp -= ENCODER_FEEDRATE_DEADZONE;
+        else if (int16_t(encoderPosition) < -(ENCODER_FEEDRATE_DEADZONE))
+          new_fp += ENCODER_FEEDRATE_DEADZONE;
+        else
+          new_fp = old_fp;
+      }
+      else if ((old_fp < 100) == (new_fp > 100)) // Crossing 100? Stick at 100.
+        new_fp = 100;
+
+      LIMIT(new_fp, FLOW_EDIT_MIN, FLOW_EDIT_MAX);
+
+      if (old_fp != new_fp) {
+        planner.set_flow(active_extruder, new_fp);
+        encoderPosition = 0;
+      }
+
+    #endif // ULTIPANEL_FLOWPERCENT
 
     draw_status_screen();
   }

commit 0f43ac79f610df25d865667e41baef707aaf40da
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jan 10 18:25:17 2024 -0600

    ⏪️ Revert encoder changes
    
    Reverts #26501

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 7309476182..dfb2a8d47c 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -67,8 +67,6 @@ MarlinUI ui;
 
 constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
-#define BLOCK_CLICK_AFTER_MOVEMENT_MS 100
-
 #if HAS_STATUS_MESSAGE
   #if ENABLED(STATUS_MESSAGE_SCROLLING) && ANY(HAS_WIRED_LCD, DWIN_LCD_PROUI)
     uint8_t MarlinUI::status_scroll_offset; // = 0
@@ -942,7 +940,6 @@ void MarlinUI::init() {
   void MarlinUI::update() {
 
     static uint16_t max_display_update_time = 0;
-    static millis_t next_encoder_enable_ms = 0;
     const millis_t ms = millis();
 
     #if LED_POWEROFF_TIMEOUT > 0
@@ -993,12 +990,7 @@ void MarlinUI::init() {
       if (!touch_buttons) {
         // Integrated LCD click handling via button_pressed
         if (!external_control && button_pressed()) {
-          if (!wait_for_unclick) {
-            if (ELAPSED(ms, next_encoder_enable_ms))
-              do_click();              // Handle the click
-            else
-              wait_for_unclick = true;
-          }
+          if (!wait_for_unclick) do_click();              // Handle the click
         }
         else
           wait_for_unclick = false;
@@ -1035,73 +1027,68 @@ void MarlinUI::init() {
         uint8_t abs_diff = ABS(encoderDiff);
 
         #if ENCODER_PULSES_PER_STEP > 1
-          #if HAS_TOUCH_SLEEP
-            static int8_t lastEncoderDiff;
-            if (lastEncoderDiff != encoderDiff) {
-              wakeup_screen();
-              lastEncoderDiff = encoderDiff;
-            }
-          #endif
+          // When reversing the encoder direction, a movement step can be missed because
+          // encoderDiff has a non-zero residual value, making the controller unresponsive.
+          // The fix clears the residual value when the encoder is idle.
+          // Also check if past half the threshold to compensate for missed single steps.
+          static int8_t lastEncoderDiff;
+
+          // Timeout? No decoder change since last check. 10 or 20 times per second.
+          if (encoderDiff == lastEncoderDiff && abs_diff <= epps / 2)   // Same direction & size but not over a half-step?
+            encoderDiff = 0;                                            // Clear residual pulses.
+          else if (WITHIN(abs_diff, epps / 2 + 1, epps - 1)) {          // Past half of threshold?
+            abs_diff = epps;                                            // Treat as a full step size
+            encoderDiff = (encoderDiff < 0 ? -1 : 1) * abs_diff;        // ...in the spin direction.
+          }
+          TERN_(HAS_TOUCH_SLEEP, if (lastEncoderDiff != encoderDiff) wakeup_screen());
+          lastEncoderDiff = encoderDiff;
         #endif
 
         const bool encoderPastThreshold = (abs_diff >= epps);
-        if (encoderPastThreshold && TERN1(IS_TFTGLCD_PANEL, !external_control)) {
+        if (encoderPastThreshold || lcd_clicked) {
+          if (encoderPastThreshold && TERN1(IS_TFTGLCD_PANEL, !external_control)) {
 
-          #if ALL(HAS_MARLINUI_MENU, ENCODER_RATE_MULTIPLIER)
+            #if ALL(HAS_MARLINUI_MENU, ENCODER_RATE_MULTIPLIER)
 
-            int32_t encoderMultiplier = 1;
+              int32_t encoderMultiplier = 1;
 
-            if (encoderRateMultiplierEnabled) {
-              if (lastEncoderMovementMillis) {
+              if (encoderRateMultiplierEnabled) {
                 const float encoderMovementSteps = float(abs_diff) / epps;
-                // Note that the rate is always calculated between two passes through the
-                // loop and that the abs of the encoderDiff value is tracked.
-                const float encoderStepRate = encoderMovementSteps / float(ms - lastEncoderMovementMillis) * 1000;
-
-                if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
-                else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
-
-                // Enable to output the encoder steps per second value
-                //#define ENCODER_RATE_MULTIPLIER_DEBUG
-                #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
-                  SERIAL_ECHO_START();
-                  SERIAL_ECHOPGM("Enc Step Rate: ", encoderStepRate);
-                  SERIAL_ECHOPGM("  Multiplier: ", encoderMultiplier);
-                  SERIAL_ECHOPGM("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
-                  SERIAL_ECHOPGM("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
-                  SERIAL_EOL();
-                #endif
-              }
 
-              lastEncoderMovementMillis = ms;
-            } // encoderRateMultiplierEnabled
+                if (lastEncoderMovementMillis) {
+                  // Note that the rate is always calculated between two passes through the
+                  // loop and that the abs of the encoderDiff value is tracked.
+                  const float encoderStepRate = encoderMovementSteps / float(ms - lastEncoderMovementMillis) * 1000;
 
-          #else
+                  if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
+                  else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
 
-            constexpr int32_t encoderMultiplier = 1;
+                  // Enable to output the encoder steps per second value
+                  //#define ENCODER_RATE_MULTIPLIER_DEBUG
+                  #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
+                    SERIAL_ECHO_START();
+                    SERIAL_ECHOPGM("Enc Step Rate: ", encoderStepRate);
+                    SERIAL_ECHOPGM("  Multiplier: ", encoderMultiplier);
+                    SERIAL_ECHOPGM("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
+                    SERIAL_ECHOPGM("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
+                    SERIAL_EOL();
+                  #endif
+                }
 
-          #endif // ENCODER_RATE_MULTIPLIER
+                lastEncoderMovementMillis = ms;
+              } // encoderRateMultiplierEnabled
 
-          int8_t fullSteps = encoderDiff / epps;
-          if (fullSteps != 0) {
+            #else
 
-            #if ENABLED(ENCODER_RATE_MULTIPLIER)
-              static bool lastFwd;
-              const bool fwd = fullSteps > 0;
-              if (encoderMultiplier != 1 && fwd != lastFwd)
-                fullSteps *= -1;  // Fast move and direction changed? Assume glitch.
-              else
-                lastFwd = fwd;    // Slow move or lastFwd==fwd already. Remember dir.
-            #endif
+              constexpr int32_t encoderMultiplier = 1;
+
+            #endif // ENCODER_RATE_MULTIPLIER
+
+            if (can_encode()) encoderPosition += (encoderDiff * encoderMultiplier) / epps;
 
-            next_encoder_enable_ms = ms + BLOCK_CLICK_AFTER_MOVEMENT_MS;
-            encoderDiff -= fullSteps * epps;
-            if (can_encode() && !lcd_clicked)
-              encoderPosition += (fullSteps * encoderMultiplier);
+            encoderDiff = 0;
           }
-        }
 
-        if (encoderPastThreshold || lcd_clicked) {
           reset_status_timeout(ms);
 
           #if HAS_BACKLIGHT_TIMEOUT
@@ -1115,7 +1102,7 @@ void MarlinUI::init() {
           #if LED_POWEROFF_TIMEOUT > 0
             if (!powerManager.psu_on) leds.reset_timeout(ms);
           #endif
-        }
+        } // encoder activity
 
       #endif // HAS_ENCODER_ACTION
 
@@ -1413,10 +1400,9 @@ void MarlinUI::init() {
 
       #if HAS_ENCODER_WHEEL
         static uint8_t lastEncoderBits;
-        bool ignore = false;
 
         // Manage encoder rotation
-        #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: encoderDiff += encoderDirection; break; case _E2: encoderDiff -= encoderDirection; break; default: ignore = true; }
+        #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: encoderDiff += encoderDirection; break; case _E2: encoderDiff -= encoderDirection; }
 
         uint8_t enc = 0;
         if (buttons & EN_A) enc |= B01;
@@ -1431,7 +1417,7 @@ void MarlinUI::init() {
           #if ALL(HAS_MARLINUI_MENU, AUTO_BED_LEVELING_UBL)
             external_encoder();
           #endif
-          if (!ignore) lastEncoderBits = enc;
+          lastEncoderBits = enc;
         }
 
       #endif // HAS_ENCODER_WHEEL

commit 15f26b402123d087f62728e1f1763a2b96f8d21d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Dec 27 01:25:51 2023 -0600

    🧑‍💻 AS_CHAR => C (#26569)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 4c5dec4761..7309476182 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -865,7 +865,7 @@ void MarlinUI::init() {
             TERN_(MULTI_E_MANUAL, axis == E_AXIS ? e_index :) active_extruder
           );
 
-          //SERIAL_ECHOLNPGM("Add planner.move with Axis ", AS_CHAR(AXIS_CHAR(axis)), " at FR ", fr_mm_s);
+          //SERIAL_ECHOLNPGM("Add planner.move with Axis ", C(AXIS_CHAR(axis)), " at FR ", fr_mm_s);
 
           axis = NO_AXIS_ENUM;
 
@@ -882,7 +882,7 @@ void MarlinUI::init() {
       TERN_(MULTI_E_MANUAL, if (move_axis == E_AXIS) e_index = eindex);
       start_time = millis() + (menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
       axis = move_axis;
-      //SERIAL_ECHOLNPGM("Post Move with Axis ", AS_CHAR(AXIS_CHAR(axis)), " soon.");
+      //SERIAL_ECHOLNPGM("Post Move with Axis ", C(AXIS_CHAR(axis)), " soon.");
     }
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)

commit bb557e5195a6177bc7386fce0176274aede60b64
Author: Dennis <16547088+soligen2010@users.noreply.github.com>
Date:   Sun Dec 24 22:40:20 2023 -0500

    🩹 Fix string buffer warning (#26550)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 60fb298dfc..4c5dec4761 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1035,9 +1035,13 @@ void MarlinUI::init() {
         uint8_t abs_diff = ABS(encoderDiff);
 
         #if ENCODER_PULSES_PER_STEP > 1
-          static int8_t lastEncoderDiff;
-          TERN_(HAS_TOUCH_SLEEP, if (lastEncoderDiff != encoderDiff) wakeup_screen());
-          lastEncoderDiff = encoderDiff;
+          #if HAS_TOUCH_SLEEP
+            static int8_t lastEncoderDiff;
+            if (lastEncoderDiff != encoderDiff) {
+              wakeup_screen();
+              lastEncoderDiff = encoderDiff;
+            }
+          #endif
         #endif
 
         const bool encoderPastThreshold = (abs_diff >= epps);

commit 06710e54de8c83af77a4f57d458f6463fbfcad93
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Wed Dec 13 00:33:03 2023 -0500

    ✨ EDITABLE_DISPLAY_TIMEOUT (#26517)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 4eb58f52ae..60fb298dfc 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -24,7 +24,7 @@
 
 #include "../MarlinCore.h" // for printingIsPaused
 
-#if LED_POWEROFF_TIMEOUT > 0 || ALL(HAS_WIRED_LCD, PRINTER_EVENT_LEDS) || (defined(LCD_BACKLIGHT_TIMEOUT_MINS) && defined(NEOPIXEL_BKGD_INDEX_FIRST))
+#if LED_POWEROFF_TIMEOUT > 0 || ALL(HAS_WIRED_LCD, PRINTER_EVENT_LEDS) || (HAS_BACKLIGHT_TIMEOUT && defined(NEOPIXEL_BKGD_INDEX_FIRST))
   #include "../feature/leds/leds.h"
 #endif
 
@@ -185,10 +185,14 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
 #endif
 
-#if LCD_BACKLIGHT_TIMEOUT_MINS
+#if HAS_BACKLIGHT_TIMEOUT
 
+  #if ENABLED(EDITABLE_DISPLAY_TIMEOUT)
+    uint8_t MarlinUI::backlight_timeout_minutes; // Initialized by settings.load()
+  #else
+    constexpr uint8_t MarlinUI::backlight_timeout_minutes;
+  #endif
   constexpr uint8_t MarlinUI::backlight_timeout_min, MarlinUI::backlight_timeout_max;
-  uint8_t MarlinUI::backlight_timeout_minutes; // Initialized by settings.load()
   millis_t MarlinUI::backlight_off_ms = 0;
 
   void MarlinUI::refresh_backlight_timeout() {
@@ -203,12 +207,16 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
 #elif HAS_DISPLAY_SLEEP
 
+  #if ENABLED(EDITABLE_DISPLAY_TIMEOUT)
+    uint8_t MarlinUI::sleep_timeout_minutes; // Initialized by settings.load()
+  #else
+    constexpr uint8_t MarlinUI::sleep_timeout_minutes;
+  #endif
   constexpr uint8_t MarlinUI::sleep_timeout_min, MarlinUI::sleep_timeout_max;
 
-  uint8_t MarlinUI::sleep_timeout_minutes; // Initialized by settings.load()
-  millis_t MarlinUI::screen_timeout_millis = 0;
+  millis_t MarlinUI::screen_timeout_ms = 0;
   void MarlinUI::refresh_screen_timeout() {
-    screen_timeout_millis = sleep_timeout_minutes ? millis() + sleep_timeout_minutes * 60UL * 1000UL : 0;
+    screen_timeout_ms = sleep_timeout_minutes ? millis() + sleep_timeout_minutes * 60UL * 1000UL : 0;
     sleep_display(false);
   }
 
@@ -1092,7 +1100,7 @@ void MarlinUI::init() {
         if (encoderPastThreshold || lcd_clicked) {
           reset_status_timeout(ms);
 
-          #if LCD_BACKLIGHT_TIMEOUT_MINS
+          #if HAS_BACKLIGHT_TIMEOUT
             refresh_backlight_timeout();
           #elif HAS_DISPLAY_SLEEP
             refresh_screen_timeout();
@@ -1202,8 +1210,7 @@ void MarlinUI::init() {
           return_to_status();
       #endif
 
-      #if LCD_BACKLIGHT_TIMEOUT_MINS
-
+      #if HAS_BACKLIGHT_TIMEOUT
         if (backlight_off_ms && ELAPSED(ms, backlight_off_ms)) {
           #ifdef NEOPIXEL_BKGD_INDEX_FIRST
             neo.set_background_off();
@@ -1214,7 +1221,7 @@ void MarlinUI::init() {
           backlight_off_ms = 0;
         }
       #elif HAS_DISPLAY_SLEEP
-        if (screen_timeout_millis && ELAPSED(ms, screen_timeout_millis))
+        if (screen_timeout_ms && ELAPSED(ms, screen_timeout_ms))
           sleep_display();
       #endif
 

commit a1c3a2b03a531606b3f6d850b324707efb89c1a0
Author: David Buezas <dbuezas@users.noreply.github.com>
Date:   Sat Dec 9 07:48:57 2023 +0100

    🚸 Encoder improvements (#26501)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 178f0b74ec..4eb58f52ae 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -67,6 +67,8 @@ MarlinUI ui;
 
 constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
+#define BLOCK_CLICK_AFTER_MOVEMENT_MS 100
+
 #if HAS_STATUS_MESSAGE
   #if ENABLED(STATUS_MESSAGE_SCROLLING) && ANY(HAS_WIRED_LCD, DWIN_LCD_PROUI)
     uint8_t MarlinUI::status_scroll_offset; // = 0
@@ -880,8 +882,8 @@ void MarlinUI::init() {
       void MarlinUI::external_encoder() {
         if (external_control && encoderDiff) {
           bedlevel.encoder_diff += encoderDiff; // Encoder for UBL G29 mesh editing
-          encoderDiff = 0;                  // Hide encoder events from the screen handler
-          refresh(LCDVIEW_REDRAW_NOW);      // ...but keep the refresh.
+          encoderDiff = 0;                      // Hide encoder events from the screen handler
+          refresh(LCDVIEW_REDRAW_NOW);          // ...but keep the refresh.
         }
       }
 
@@ -932,7 +934,8 @@ void MarlinUI::init() {
   void MarlinUI::update() {
 
     static uint16_t max_display_update_time = 0;
-    millis_t ms = millis();
+    static millis_t next_encoder_enable_ms = 0;
+    const millis_t ms = millis();
 
     #if LED_POWEROFF_TIMEOUT > 0
       leds.update_timeout(powerManager.psu_on);
@@ -982,7 +985,12 @@ void MarlinUI::init() {
       if (!touch_buttons) {
         // Integrated LCD click handling via button_pressed
         if (!external_control && button_pressed()) {
-          if (!wait_for_unclick) do_click();              // Handle the click
+          if (!wait_for_unclick) {
+            if (ELAPSED(ms, next_encoder_enable_ms))
+              do_click();              // Handle the click
+            else
+              wait_for_unclick = true;
+          }
         }
         else
           wait_for_unclick = false;
@@ -1019,68 +1027,69 @@ void MarlinUI::init() {
         uint8_t abs_diff = ABS(encoderDiff);
 
         #if ENCODER_PULSES_PER_STEP > 1
-          // When reversing the encoder direction, a movement step can be missed because
-          // encoderDiff has a non-zero residual value, making the controller unresponsive.
-          // The fix clears the residual value when the encoder is idle.
-          // Also check if past half the threshold to compensate for missed single steps.
           static int8_t lastEncoderDiff;
-
-          // Timeout? No decoder change since last check. 10 or 20 times per second.
-          if (encoderDiff == lastEncoderDiff && abs_diff <= epps / 2)   // Same direction & size but not over a half-step?
-            encoderDiff = 0;                                            // Clear residual pulses.
-          else if (WITHIN(abs_diff, epps / 2 + 1, epps - 1)) {          // Past half of threshold?
-            abs_diff = epps;                                            // Treat as a full step size
-            encoderDiff = (encoderDiff < 0 ? -1 : 1) * abs_diff;        // ...in the spin direction.
-          }
           TERN_(HAS_TOUCH_SLEEP, if (lastEncoderDiff != encoderDiff) wakeup_screen());
           lastEncoderDiff = encoderDiff;
         #endif
 
         const bool encoderPastThreshold = (abs_diff >= epps);
-        if (encoderPastThreshold || lcd_clicked) {
-          if (encoderPastThreshold && TERN1(IS_TFTGLCD_PANEL, !external_control)) {
+        if (encoderPastThreshold && TERN1(IS_TFTGLCD_PANEL, !external_control)) {
 
-            #if ALL(HAS_MARLINUI_MENU, ENCODER_RATE_MULTIPLIER)
+          #if ALL(HAS_MARLINUI_MENU, ENCODER_RATE_MULTIPLIER)
 
-              int32_t encoderMultiplier = 1;
+            int32_t encoderMultiplier = 1;
 
-              if (encoderRateMultiplierEnabled) {
+            if (encoderRateMultiplierEnabled) {
+              if (lastEncoderMovementMillis) {
                 const float encoderMovementSteps = float(abs_diff) / epps;
+                // Note that the rate is always calculated between two passes through the
+                // loop and that the abs of the encoderDiff value is tracked.
+                const float encoderStepRate = encoderMovementSteps / float(ms - lastEncoderMovementMillis) * 1000;
+
+                if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
+                else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
+
+                // Enable to output the encoder steps per second value
+                //#define ENCODER_RATE_MULTIPLIER_DEBUG
+                #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
+                  SERIAL_ECHO_START();
+                  SERIAL_ECHOPGM("Enc Step Rate: ", encoderStepRate);
+                  SERIAL_ECHOPGM("  Multiplier: ", encoderMultiplier);
+                  SERIAL_ECHOPGM("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
+                  SERIAL_ECHOPGM("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
+                  SERIAL_EOL();
+                #endif
+              }
 
-                if (lastEncoderMovementMillis) {
-                  // Note that the rate is always calculated between two passes through the
-                  // loop and that the abs of the encoderDiff value is tracked.
-                  const float encoderStepRate = encoderMovementSteps / float(ms - lastEncoderMovementMillis) * 1000;
-
-                  if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
-                  else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
-
-                  // Enable to output the encoder steps per second value
-                  //#define ENCODER_RATE_MULTIPLIER_DEBUG
-                  #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
-                    SERIAL_ECHO_START();
-                    SERIAL_ECHOPGM("Enc Step Rate: ", encoderStepRate);
-                    SERIAL_ECHOPGM("  Multiplier: ", encoderMultiplier);
-                    SERIAL_ECHOPGM("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
-                    SERIAL_ECHOPGM("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
-                    SERIAL_EOL();
-                  #endif
-                }
+              lastEncoderMovementMillis = ms;
+            } // encoderRateMultiplierEnabled
 
-                lastEncoderMovementMillis = ms;
-              } // encoderRateMultiplierEnabled
+          #else
 
-            #else
+            constexpr int32_t encoderMultiplier = 1;
 
-              constexpr int32_t encoderMultiplier = 1;
+          #endif // ENCODER_RATE_MULTIPLIER
 
-            #endif // ENCODER_RATE_MULTIPLIER
+          int8_t fullSteps = encoderDiff / epps;
+          if (fullSteps != 0) {
 
-            if (can_encode()) encoderPosition += (encoderDiff * encoderMultiplier) / epps;
+            #if ENABLED(ENCODER_RATE_MULTIPLIER)
+              static bool lastFwd;
+              const bool fwd = fullSteps > 0;
+              if (encoderMultiplier != 1 && fwd != lastFwd)
+                fullSteps *= -1;  // Fast move and direction changed? Assume glitch.
+              else
+                lastFwd = fwd;    // Slow move or lastFwd==fwd already. Remember dir.
+            #endif
 
-            encoderDiff = 0;
+            next_encoder_enable_ms = ms + BLOCK_CLICK_AFTER_MOVEMENT_MS;
+            encoderDiff -= fullSteps * epps;
+            if (can_encode() && !lcd_clicked)
+              encoderPosition += (fullSteps * encoderMultiplier);
           }
+        }
 
+        if (encoderPastThreshold || lcd_clicked) {
           reset_status_timeout(ms);
 
           #if LCD_BACKLIGHT_TIMEOUT_MINS
@@ -1094,7 +1103,7 @@ void MarlinUI::init() {
           #if LED_POWEROFF_TIMEOUT > 0
             if (!powerManager.psu_on) leds.reset_timeout(ms);
           #endif
-        } // encoder activity
+        }
 
       #endif // HAS_ENCODER_ACTION
 
@@ -1393,9 +1402,10 @@ void MarlinUI::init() {
 
       #if HAS_ENCODER_WHEEL
         static uint8_t lastEncoderBits;
+        bool ignore = false;
 
         // Manage encoder rotation
-        #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: encoderDiff += encoderDirection; break; case _E2: encoderDiff -= encoderDirection; }
+        #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: encoderDiff += encoderDirection; break; case _E2: encoderDiff -= encoderDirection; break; default: ignore = true; }
 
         uint8_t enc = 0;
         if (buttons & EN_A) enc |= B01;
@@ -1410,7 +1420,7 @@ void MarlinUI::init() {
           #if ALL(HAS_MARLINUI_MENU, AUTO_BED_LEVELING_UBL)
             external_encoder();
           #endif
-          lastEncoderBits = enc;
+          if (!ignore) lastEncoderBits = enc;
         }
 
       #endif // HAS_ENCODER_WHEEL

commit bd872a7a98528da6e1fab95382488ce703fe24c1
Author: Vovodroid <vovodroid@users.noreply.github.com>
Date:   Fri Nov 24 21:03:06 2023 +0200

    🔧 Configurable FR/Flow edit ranges (#26446)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 49b9fecad8..178f0b74ec 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -695,7 +695,7 @@ void MarlinUI::init() {
       else if ((old_frm < 100 && new_frm > 100) || (old_frm > 100 && new_frm < 100))
         new_frm = 100;
 
-      LIMIT(new_frm, 10, 999);
+      LIMIT(new_frm, SPEED_EDIT_MIN, SPEED_EDIT_MAX);
 
       if (old_frm != new_frm) {
         feedrate_percentage = new_frm;

commit 376673df284333ed499dd6a1e8ab52c317d2af73
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Nov 20 00:53:35 2023 -0600

    🚸 Minor touch calibration improvement (#26445)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index fa511b4882..49b9fecad8 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -408,7 +408,7 @@ void MarlinUI::init() {
 
     #if HAS_TOUCH_BUTTONS
       uint8_t MarlinUI::touch_buttons;
-      uint8_t MarlinUI::repeat_delay;
+      uint16_t MarlinUI::repeat_delay;
     #endif
 
     #if ANY(AUTO_BED_LEVELING_UBL, G26_MESH_VALIDATION)

commit 28bc19720a1118681d39e91fd11c4905de5497ff
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Tue Nov 14 21:33:15 2023 +1300

    🐛 Put I2C init ahead of LCD init (#26409)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 463d406110..fa511b4882 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -218,6 +218,10 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
 void MarlinUI::init() {
 
+  #if HAS_U8GLIB_I2C_OLED && PINS_EXIST(I2C_SCL, I2C_SDA) && DISABLED(SOFT_I2C_EEPROM)
+    Wire.begin(uint8_t(I2C_SDA_PIN), uint8_t(I2C_SCL_PIN));
+  #endif
+
   init_lcd();
 
   #if HAS_DIGITAL_BUTTONS
@@ -274,10 +278,6 @@ void MarlinUI::init() {
     slow_buttons = 0;
   #endif
 
-  #if HAS_U8GLIB_I2C_OLED && PINS_EXIST(I2C_SCL, I2C_SDA) && DISABLED(SOFT_I2C_EEPROM)
-    Wire.begin(int(I2C_SDA_PIN), int(I2C_SCL_PIN));
-  #endif
-
   update_buttons();
 
   TERN_(HAS_ENCODER_ACTION, encoderDiff = 0);

commit 2a88e7600298fef27e8cbbe01b708959515677fb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 25 19:41:32 2023 -0500

    🧑‍💻 Misc. LCD / string updates

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 1076d40de0..463d406110 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -444,8 +444,9 @@ void MarlinUI::init() {
             p = get_utf8_value_cb(p, cb_read_byte, wc);
             const bool eol = !wc;         // zero ends the string
             // End or a break between phrases?
-            if (eol || wc == ' ' || wc == '-' || wc == '+' || wc == '.') {
-              if (!c && wc == ' ') { if (wrd) wrd++; continue; } // collapse extra spaces
+            if (eol || wc == ' ' || wc == '-' || wc == '+' || wc == '.' || wc == '\n') {
+              const bool newline_after = wc == '\n';
+              if (!c && (wc == ' ' || newline_after)) { if (wrd) wrd++; continue; } // collapse extra spaces
               // Past the right and the word is not too long?
               if (col + c > LCD_WIDTH && col >= (LCD_WIDTH) / 4) _newline(); // should it wrap?
               c += !eol;                  // +1 so the space will be printed
@@ -456,6 +457,7 @@ void MarlinUI::init() {
                 lcd_put_lchar(wc);        // character to the LCD
               }
               if (eol) break;             // all done!
+              if (newline_after) _newline();
               wrd = nullptr;              // set up for next word
             }
             else c++;                     // count word characters
@@ -472,20 +474,20 @@ void MarlinUI::init() {
         }
       }
 
-      void MarlinUI::draw_select_screen_prompt(FSTR_P const pref, const char * const string/*=nullptr*/, FSTR_P const suff/*=nullptr*/) {
-        const uint8_t plen = utf8_strlen(pref), slen = suff ? utf8_strlen(suff) : 0;
+      void MarlinUI::draw_select_screen_prompt(FSTR_P const fpre, const char * const string/*=nullptr*/, FSTR_P const fsuf/*=nullptr*/) {
+        const uint8_t plen = utf8_strlen_P(FTOP(fpre)), slen = fsuf ? utf8_strlen_P(FTOP(fsuf)) : 0;
         uint8_t col = 0, row = 0;
         if (!string && plen + slen <= LCD_WIDTH) {
           col = (LCD_WIDTH - plen - slen) / 2;
           row = LCD_HEIGHT > 3 ? 1 : 0;
         }
         if (LCD_HEIGHT >= 8) row = LCD_HEIGHT / 2 - 2;
-        wrap_string_P(col, row, FTOP(pref), true);
+        wrap_string_P(col, row, FTOP(fpre), true);
         if (string) {
           if (col) { col = 0; row++; } // Move to the start of the next line
           wrap_string(col, row, string);
         }
-        if (suff) wrap_string_P(col, row, FTOP(suff));
+        if (fsuf) wrap_string_P(col, row, FTOP(fsuf));
       }
 
     #endif // !HAS_GRAPHICAL_TFT

commit 8fa6a4da2eebc1dbe120dcac87b159e389e17dc3
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Fri Aug 25 19:33:49 2023 -0400

    🚸 Fixes for ProUI, JyersUI, backlight, etc. (#26086)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 69a8e23363..1076d40de0 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -190,7 +190,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   millis_t MarlinUI::backlight_off_ms = 0;
 
   void MarlinUI::refresh_backlight_timeout() {
-    backlight_off_ms = backlight_timeout_minutes ? millis() + backlight_timeout_minutes * 60UL * 1000UL : 0;
+    backlight_off_ms = backlight_timeout_minutes ? millis() + MIN_TO_MS(backlight_timeout_minutes) : 0;
     #ifdef NEOPIXEL_BKGD_INDEX_FIRST
       neo.reset_background_color();
       neo.show();

commit 57d26f7e4f614ee4e05e7e97fdc7109d8cfdc702
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Wed Jul 5 08:21:54 2023 +0200

    🩹 Fix HOST_STATUS_NOTIFICATIONS compile (#26040)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index cbab4676c2..69a8e23363 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1431,9 +1431,6 @@ void MarlinUI::host_notify_P(PGM_P const pstr) {
 void MarlinUI::host_notify(const char * const cstr) {
   TERN_(HOST_STATUS_NOTIFICATIONS, hostui.notify(cstr));
 }
-void MarlinUI::host_status() {
-  TERN_(HOST_STATUS_NOTIFICATIONS, hostui.notify(status_message));
-}
 
 #include <stdarg.h>
 
@@ -1562,7 +1559,7 @@ void MarlinUI::host_status() {
     vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
     va_end(args);
 
-    host_status();
+    host_notify(status_message);
 
     finish_status(level > 0);
   }
@@ -1644,7 +1641,7 @@ void MarlinUI::host_status() {
     vsnprintf_P(&msg, 30, fmt, args);
     va_end(args);
 
-    host_status();
+    host_notify(msg);
   }
 
 #endif // !HAS_STATUS_MESSAGE

commit 3ea87ad54c1e445a1c8cfef1489809edae5decb3
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Sun Jul 2 04:16:12 2023 +0300

    ✨ SPI TFT / Touchscreen for STM32H7 (#25784)
    
    Co-authored-by: thisiskeithb <13375512+thisiskeithb@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index f8fde21777..cbab4676c2 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1679,11 +1679,13 @@ void MarlinUI::host_status() {
 
   #endif
 
-  void MarlinUI::flow_fault() {
-    LCD_ALERTMESSAGE(MSG_FLOWMETER_FAULT);
-    BUZZ(1000, 440);
-    TERN_(HAS_MARLINUI_MENU, return_to_status());
-  }
+  #if ENABLED(FLOWMETER_SAFETY)
+    void MarlinUI::flow_fault() {
+      LCD_ALERTMESSAGE(MSG_FLOWMETER_FAULT);
+      BUZZ(1000, 440);
+      TERN_(HAS_MARLINUI_MENU, return_to_status());
+    }
+  #endif
 
   void MarlinUI::pause_print() {
     #if HAS_MARLINUI_MENU
@@ -1718,13 +1720,13 @@ void MarlinUI::host_status() {
 
   #if HAS_TOUCH_BUTTONS
 
-    //
-    // Screen Click
-    //  - On menu screens move directly to the touched item
-    //  - On menu screens, right side (last 3 cols) acts like a scroll - half up => prev page, half down = next page
-    //  - On select screens (and others) touch the Right Half for +, Left Half for -
-    //  - On edit screens, touch Up Half for -,  Bottom Half to +
-    //
+    /**
+     * Screen Click
+     *  - On menu screens move directly to the touched item
+     *  - On menu screens, right side (last 3 cols) acts like a scroll - half up => prev page, half down = next page
+     *  - On select screens (and others) touch the Left Half for ←, Right Half for →
+     *  - On edit screens, touch Top Half for ↑, Bottom Half for ↓
+     */
     void MarlinUI::screen_click(const uint8_t row, const uint8_t col, const uint8_t, const uint8_t) {
       const millis_t now = millis();
       if (PENDING(now, next_button_update_ms)) return;

commit f14f1be168ebf252dd458c935271aed1a57cfa0b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 30 19:16:00 2023 -0500

    🎨 Standardize naming (ProUI) (#25982)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 8517e2ec23..f8fde21777 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1600,7 +1600,7 @@ void MarlinUI::host_status() {
 
     TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
     TERN_(DWIN_CREALITY_LCD, dwinStatusChanged(status_message));
-    TERN_(DWIN_LCD_PROUI, DWIN_CheckStatusMessage());
+    TERN_(DWIN_LCD_PROUI, dwinCheckStatusMessage());
     TERN_(DWIN_CREALITY_LCD_JYERSUI, jyersDWIN.updateStatus(status_message));
   }
 

commit bbfaf7474c50f81d606c2dde91035bc40835e830
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 21:44:42 2023 -0500

    🎨 CrealityDWIN => JyersDWIN (#26026)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 2d40baa9d1..8517e2ec23 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1601,7 +1601,7 @@ void MarlinUI::host_status() {
     TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
     TERN_(DWIN_CREALITY_LCD, dwinStatusChanged(status_message));
     TERN_(DWIN_LCD_PROUI, DWIN_CheckStatusMessage());
-    TERN_(DWIN_CREALITY_LCD_JYERSUI, crealityDWIN.updateStatus(status_message));
+    TERN_(DWIN_CREALITY_LCD_JYERSUI, jyersDWIN.updateStatus(status_message));
   }
 
   #if ENABLED(STATUS_MESSAGE_SCROLLING)

commit 574dd34c49fde76e1e736b8a7e1ea579d724ff22
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 13:19:36 2023 -0500

    ♻️ String helper class (#24390)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index db5d0a635f..2d40baa9d1 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -71,7 +71,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   #if ENABLED(STATUS_MESSAGE_SCROLLING) && ANY(HAS_WIRED_LCD, DWIN_LCD_PROUI)
     uint8_t MarlinUI::status_scroll_offset; // = 0
   #endif
-  char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
+  MString<MAX_MESSAGE_LENGTH> MarlinUI::status_message;
   uint8_t MarlinUI::alert_level; // = 0
   #if HAS_STATUS_MESSAGE_TIMEOUT
     millis_t MarlinUI::status_message_expire_ms; // = 0
@@ -492,10 +492,6 @@ void MarlinUI::init() {
 
   #endif // HAS_MARLINUI_MENU
 
-  ////////////////////////////////////////////
-  ///////////// Keypad Handling //////////////
-  ////////////////////////////////////////////
-
   #if IS_RRW_KEYPAD && HAS_ENCODER_ACTION
 
     volatile uint8_t MarlinUI::keypad_buttons;
@@ -641,7 +637,7 @@ void MarlinUI::init() {
           // Expire the message if a job is active and the bar has ticks
           if (get_progress_percent() > 2 && !print_job_timer.isPaused()) {
             if (ELAPSED(ms, expire_status_ms)) {
-              status_message[0] = '\0';
+              status_message.clear();
               expire_status_ms = 0;
             }
           }
@@ -776,10 +772,6 @@ void MarlinUI::init() {
     #endif
   }
 
-  ////////////////////////////////////////////
-  /////////////// Manual Move ////////////////
-  ////////////////////////////////////////////
-
   #if HAS_MARLINUI_MENU
 
     ManualMove MarlinUI::manual_move{};
@@ -1433,49 +1425,27 @@ void MarlinUI::init() {
 
 #endif // HAS_WIRED_LCD
 
-#if HAS_STATUS_MESSAGE
+void MarlinUI::host_notify_P(PGM_P const pstr) {
+  TERN_(HOST_STATUS_NOTIFICATIONS, hostui.notify_P(pstr));
+}
+void MarlinUI::host_notify(const char * const cstr) {
+  TERN_(HOST_STATUS_NOTIFICATIONS, hostui.notify(cstr));
+}
+void MarlinUI::host_status() {
+  TERN_(HOST_STATUS_NOTIFICATIONS, hostui.notify(status_message));
+}
 
-  ////////////////////////////////////////////
-  ////////////// Status Message //////////////
-  ////////////////////////////////////////////
+#include <stdarg.h>
+
+#if HAS_STATUS_MESSAGE
 
   #if ENABLED(EXTENSIBLE_UI)
     #include "extui/ui_api.h"
   #endif
 
-  bool MarlinUI::has_status() { return (status_message[0] != '\0'); }
-
-  void MarlinUI::set_status(const char * const cstr, const bool persist) {
-    if (alert_level) return;
-
-    TERN_(HOST_STATUS_NOTIFICATIONS, hostui.notify(cstr));
-
-    // Here we have a problem. The message is encoded in UTF8, so
-    // arbitrarily cutting it will be a problem. We MUST be sure
-    // that there is no cutting in the middle of a multibyte character!
-
-    // Get a pointer to the null terminator
-    const char* pend = cstr + strlen(cstr);
-
-    //  If length of supplied UTF8 string is greater than
-    // our buffer size, start cutting whole UTF8 chars
-    while ((pend - cstr) > MAX_MESSAGE_LENGTH) {
-      --pend;
-      while (!START_OF_UTF8_CHAR(*pend)) --pend;
-    };
-
-    // At this point, we have the proper cut point. Use it
-    uint8_t maxLen = pend - cstr;
-    strncpy(status_message, cstr, maxLen);
-    status_message[maxLen] = '\0';
-
-    finish_status(persist);
-  }
-
   /**
    * Reset the status message
    */
-
   void MarlinUI::reset_status(const bool no_welcome) {
     #if SERVICE_INTERVAL_1 > 0
       static PGMSTR(service1, "> " SERVICE_NAME_1 "!");
@@ -1492,7 +1462,7 @@ void MarlinUI::init() {
       msg = GET_TEXT_F(MSG_PRINT_PAUSED);
     #if HAS_MEDIA
       else if (IS_SD_PRINTING())
-        return set_status(card.longest_filename(), true);
+        return set_status_no_expire(card.longest_filename());
     #endif
     else if (print_job_timer.isRunning())
       msg = GET_TEXT_F(MSG_PRINTING);
@@ -1514,65 +1484,85 @@ void MarlinUI::init() {
     else
       return;
 
-    set_status(msg, -1);
+    set_min_status(msg);
   }
 
   /**
-   * Set Status with a fixed string and alert level.
-   * @param fstr  A constant F-string to set as the status.
+   * Try to set the alert level.
    * @param level Alert level. Negative to ignore and reset the level. Non-zero never expires.
+   * @return      TRUE if the level could NOT be set.
    */
-  void MarlinUI::set_status(FSTR_P const fstr, int8_t level) {
-    // Alerts block lower priority messages
+  bool MarlinUI::set_alert_level(int8_t &level) {
     if (level < 0) level = alert_level = 0;
-    if (level < alert_level) return;
+    if (level < alert_level) return true;
     alert_level = level;
+    return false;
+  }
+
+  /**
+   * @brief Set Status with a C- or P-string and alert level.
+   *
+   * @param ustr  A C- or P-string, according to pgm.
+   * @param level Alert level. Negative to ignore and reset the level. Non-zero never expires.
+   * @param pgm   Program string flag. Only relevant on AVR.
+   */
+  void MarlinUI::_set_status_and_level(const char * const ustr, int8_t level, const bool pgm) {
+    if (set_alert_level(level)) return;
 
-    PGM_P const pstr = FTOP(fstr);
+    pgm ? host_notify_P(ustr) : host_notify(ustr);
 
-    // Since the message is encoded in UTF8 it must
-    // only be cut on a character boundary.
+    MString<30> msg;
+    pgm ? msg.set_P(ustr) : msg.set(ustr);
+    status_message.set(&msg).utrunc(MAX_MESSAGE_LENGTH);
 
-    // Get a pointer to the null terminator
-    PGM_P pend = pstr + strlen_P(pstr);
+    finish_status(level > 0); // Persist if the status has a level
+  }
 
-    // If length of supplied UTF8 string is greater than
-    // the buffer size, start cutting whole UTF8 chars
-    while ((pend - pstr) > MAX_MESSAGE_LENGTH) {
-      --pend;
-      while (!START_OF_UTF8_CHAR(pgm_read_byte(pend))) --pend;
-    };
+  /**
+   * @brief Set Status with a C- or P-string and persistence flag.
+   *
+   * @param ustr    A C- or P-string, according to pgm.
+   * @param persist Don't expire (Requires STATUS_EXPIRE_SECONDS) - and set alert level to 1.
+   * @param pgm     Program string flag. Only relevant on AVR.
+   */
+  void MarlinUI::_set_status(const char * const ustr, const bool persist, const bool pgm) {
+    if (alert_level) return;
 
-    // At this point, we have the proper cut point. Use it
-    uint8_t maxLen = pend - pstr;
-    strncpy_P(status_message, pstr, maxLen);
-    status_message[maxLen] = '\0';
+    pgm ? host_notify_P(ustr) : host_notify(ustr);
 
-    TERN_(HOST_STATUS_NOTIFICATIONS, hostui.notify(fstr));
+    // Remove the last partial Unicode glyph, if any
+    (pgm ? status_message.set_P(ustr) : status_message.set(ustr)).utrunc(MAX_MESSAGE_LENGTH);
 
-    finish_status(level > 0);
+    finish_status(persist);
   }
 
-  void MarlinUI::set_alert_status(FSTR_P const fstr) {
-    set_status(fstr, 1);
+  /**
+   * @brief Set Alert with a C- or P-string and alert level.
+   *
+   * @param ustr  A C- or P-string, according to pgm.
+   * @param level Alert level. Negative to ignore and reset the level. Non-zero never expires.
+   * @param pgm   Program string flag. Only relevant on AVR.
+   */
+  void MarlinUI::_set_alert(const char * const ustr, const int8_t level, const bool pgm) {
+    pgm ? set_status_and_level_P(ustr, level) : set_status_and_level(ustr, level);
     TERN_(HAS_TOUCH_SLEEP, wakeup_screen());
     TERN_(HAS_MARLINUI_MENU, return_to_status());
   }
 
-  #include <stdarg.h>
-
-  void MarlinUI::status_printf(int8_t level, FSTR_P const fmt, ...) {
-    // Alerts block lower priority messages
-    if (level < 0) level = alert_level = 0;
-    if (level < alert_level) return;
-    alert_level = level;
+  /**
+   * @brief Set a status with a format string and parameters.
+   *
+   * @param pfmt    A constant format P-string
+   */
+  void MarlinUI::status_printf_P(int8_t level, PGM_P const fmt, ...) {
+    if (set_alert_level(level)) return;
 
     va_list args;
-    va_start(args, FTOP(fmt));
-    vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, FTOP(fmt), args);
+    va_start(args, fmt);
+    vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
     va_end(args);
 
-    TERN_(HOST_STATUS_NOTIFICATIONS, hostui.notify(status_message));
+    host_status();
 
     finish_status(level > 0);
   }
@@ -1618,14 +1608,14 @@ void MarlinUI::init() {
 
     void MarlinUI::advance_status_scroll() {
       // Advance by one UTF8 code-word
-      if (status_scroll_offset < utf8_strlen(status_message))
+      if (status_scroll_offset < status_message.glyphs())
         while (!START_OF_UTF8_CHAR(status_message[++status_scroll_offset]));
       else
         status_scroll_offset = 0;
     }
 
     char* MarlinUI::status_and_len(uint8_t &len) {
-      char *out = status_message + status_scroll_offset;
+      char *out = &status_message + status_scroll_offset;
       len = utf8_strlen(out);
       return out;
     }
@@ -1637,14 +1627,24 @@ void MarlinUI::init() {
   //
   // Send the status line as a host notification
   //
-  void MarlinUI::set_status(const char * const cstr, const bool) {
-    TERN(HOST_PROMPT_SUPPORT, hostui.notify(cstr), UNUSED(cstr));
+  void MarlinUI::_set_status(const char * const cstr, const bool, const bool pgm) {
+    host_notify(cstr);
+  }
+  void MarlinUI::_set_alert(const char * const cstr, const int8_t, const bool pgm) {
+    host_notify(cstr);
   }
-  void MarlinUI::set_status(FSTR_P const fstr, const int8_t) {
-    TERN(HOST_PROMPT_SUPPORT, hostui.notify(fstr), UNUSED(fstr));
+  void MarlinUI::_set_status_and_level(const char * const ustr, const int8_t=0, const bool pgm) {
+    pgm ? host_notify_P(ustr) : host_notify(ustr);
   }
-  void MarlinUI::status_printf(int8_t, FSTR_P const fstr, ...) {
-    TERN(HOST_PROMPT_SUPPORT, hostui.notify(fstr), UNUSED(fstr));
+  void MarlinUI::status_printf_P(int8_t level, PGM_P const fmt, ...) {
+    MString<30> msg;
+
+    va_list args;
+    va_start(args, fmt);
+    vsnprintf_P(&msg, 30, fmt, args);
+    va_end(args);
+
+    host_status();
   }
 
 #endif // !HAS_STATUS_MESSAGE

commit 238951a966204ce9bc109e06fdb4027125b28feb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 16 18:08:59 2023 -0500

    🎨 More more lowercase (partial ProUI)
    
    Followup to #25939

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index b56d21ae40..db5d0a635f 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1667,7 +1667,7 @@ void MarlinUI::init() {
     TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_open(PROMPT_INFO, F("UI Aborted"), FPSTR(DISMISS_STR)));
     LCD_MESSAGE(MSG_PRINT_ABORTED);
     TERN_(HAS_MARLINUI_MENU, return_to_status());
-    TERN_(DWIN_LCD_PROUI, HMI_flag.abort_flag = true);
+    TERN_(DWIN_LCD_PROUI, hmiFlag.abort_flag = true);
   }
 
   #if ALL(HAS_MARLINUI_MENU, PSU_CONTROL)

commit c3694f1c038fa20ad749118b0a1c7aa88e3dd5f2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 14 17:24:50 2023 -0500

    🎨 Lowercase methods, functions, data members (#25939)
    
    For: TFT, DGUS, MarlinUI, Anycubic, JyersUI, CrealityUI

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 8d27ee8f7e..b56d21ae40 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1179,7 +1179,7 @@ void MarlinUI::init() {
           run_current_screen();
 
           // Apply all DWIN drawing after processing
-          TERN_(IS_DWIN_MARLINUI, DWIN_UpdateLCD());
+          TERN_(IS_DWIN_MARLINUI, dwinUpdateLCD());
 
         #endif
 
@@ -1609,9 +1609,9 @@ void MarlinUI::init() {
     #endif
 
     TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
-    TERN_(DWIN_CREALITY_LCD, DWIN_StatusChanged(status_message));
+    TERN_(DWIN_CREALITY_LCD, dwinStatusChanged(status_message));
     TERN_(DWIN_LCD_PROUI, DWIN_CheckStatusMessage());
-    TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Update_Status(status_message));
+    TERN_(DWIN_CREALITY_LCD_JYERSUI, crealityDWIN.updateStatus(status_message));
   }
 
   #if ENABLED(STATUS_MESSAGE_SCROLLING)

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    🧑‍💻 Remove LOOP macros (#25917)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index a812dff556..8d27ee8f7e 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1289,7 +1289,7 @@ void MarlinUI::init() {
         thermalManager.current_ADCKey_raw = HAL_ADC_RANGE;
         thermalManager.ADCKey_count = 0;
         if (currentkpADCValue < adc_other_button)
-          LOOP_L_N(i, ADC_KEY_NUM) {
+          for (uint8_t i = 0; i < ADC_KEY_NUM; ++i) {
             const raw_adc_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
                             hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
             if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
@@ -1380,7 +1380,7 @@ void MarlinUI::init() {
           uint8_t val = 0;
           WRITE(SHIFT_LD_PIN, LOW);
           WRITE(SHIFT_LD_PIN, HIGH);
-          LOOP_L_N(i, 8) {
+          for (uint8_t i = 0; i < 8; ++i) {
             val >>= 1;
             if (READ(SHIFT_OUT_PIN)) SBI(val, 7);
             WRITE(SHIFT_CLK_PIN, HIGH);

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    🧑‍💻 Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 1c4bbe5fa9..a812dff556 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -24,7 +24,7 @@
 
 #include "../MarlinCore.h" // for printingIsPaused
 
-#if LED_POWEROFF_TIMEOUT > 0 || BOTH(HAS_WIRED_LCD, PRINTER_EVENT_LEDS) || (defined(LCD_BACKLIGHT_TIMEOUT_MINS) && defined(NEOPIXEL_BKGD_INDEX_FIRST))
+#if LED_POWEROFF_TIMEOUT > 0 || ALL(HAS_WIRED_LCD, PRINTER_EVENT_LEDS) || (defined(LCD_BACKLIGHT_TIMEOUT_MINS) && defined(NEOPIXEL_BKGD_INDEX_FIRST))
   #include "../feature/leds/leds.h"
 #endif
 
@@ -32,7 +32,7 @@
   #include "../feature/host_actions.h"
 #endif
 
-#if BOTH(BROWSE_MEDIA_ON_INSERT, PASSWORD_ON_SD_PRINT_MENU)
+#if ALL(BROWSE_MEDIA_ON_INSERT, PASSWORD_ON_SD_PRINT_MENU)
   #include "../feature/password/password.h"
 #endif
 
@@ -68,7 +68,7 @@ MarlinUI ui;
 constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
 #if HAS_STATUS_MESSAGE
-  #if ENABLED(STATUS_MESSAGE_SCROLLING) && EITHER(HAS_WIRED_LCD, DWIN_LCD_PROUI)
+  #if ENABLED(STATUS_MESSAGE_SCROLLING) && ANY(HAS_WIRED_LCD, DWIN_LCD_PROUI)
     uint8_t MarlinUI::status_scroll_offset; // = 0
   #endif
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
@@ -154,7 +154,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   }
 #endif
 
-#if EITHER(HAS_MARLINUI_MENU, EXTENSIBLE_UI)
+#if ANY(HAS_MARLINUI_MENU, EXTENSIBLE_UI)
   bool MarlinUI::lcd_clicked;
 #endif
 
@@ -270,7 +270,7 @@ void MarlinUI::init() {
 
   #endif // HAS_SHIFT_ENCODER
 
-  #if BOTH(HAS_ENCODER_ACTION, HAS_SLOW_BUTTONS)
+  #if ALL(HAS_ENCODER_ACTION, HAS_SLOW_BUTTONS)
     slow_buttons = 0;
   #endif
 
@@ -339,7 +339,7 @@ void MarlinUI::init() {
 
   uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 
-  #if BOTH(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
+  #if ALL(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
     millis_t MarlinUI::next_filament_display; // = 0
   #endif
 
@@ -402,7 +402,7 @@ void MarlinUI::init() {
       }
     #endif
 
-    #if EITHER(REVERSE_MENU_DIRECTION, REVERSE_SELECT_DIRECTION)
+    #if ANY(REVERSE_MENU_DIRECTION, REVERSE_SELECT_DIRECTION)
       int8_t MarlinUI::encoderDirection = ENCODERBASE;
     #endif
 
@@ -411,7 +411,7 @@ void MarlinUI::init() {
       uint8_t MarlinUI::repeat_delay;
     #endif
 
-    #if EITHER(AUTO_BED_LEVELING_UBL, G26_MESH_VALIDATION)
+    #if ANY(AUTO_BED_LEVELING_UBL, G26_MESH_VALIDATION)
 
       bool MarlinUI::external_control; // = false
 
@@ -574,7 +574,7 @@ void MarlinUI::init() {
             #endif
 
             if (homed) {
-              #if EITHER(DELTA, Z_HOME_TO_MAX)
+              #if ANY(DELTA, Z_HOME_TO_MAX)
                 if (RRK(EN_KEYPAD_F2))  _reprapworld_keypad_move(Z_AXIS,  1);
               #endif
               if (RRK(EN_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);
@@ -670,7 +670,7 @@ void MarlinUI::init() {
 
     #if HAS_MARLINUI_MENU
       if (use_click()) {
-        #if BOTH(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
+        #if ALL(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
           pause_filament_display();
         #endif
         goto_screen(menu_main);
@@ -702,7 +702,7 @@ void MarlinUI::init() {
       if (old_frm != new_frm) {
         feedrate_percentage = new_frm;
         encoderPosition = 0;
-        #if BOTH(HAS_SOUND, BEEP_ON_FEEDRATE_CHANGE)
+        #if ALL(HAS_SOUND, BEEP_ON_FEEDRATE_CHANGE)
           static millis_t next_beep;
           #ifndef GOT_MS
             const millis_t ms = millis();
@@ -1046,7 +1046,7 @@ void MarlinUI::init() {
         if (encoderPastThreshold || lcd_clicked) {
           if (encoderPastThreshold && TERN1(IS_TFTGLCD_PANEL, !external_control)) {
 
-            #if BOTH(HAS_MARLINUI_MENU, ENCODER_RATE_MULTIPLIER)
+            #if ALL(HAS_MARLINUI_MENU, ENCODER_RATE_MULTIPLIER)
 
               int32_t encoderMultiplier = 1;
 
@@ -1112,7 +1112,7 @@ void MarlinUI::init() {
         refresh(LCDVIEW_REDRAW_NOW);
       }
 
-      #if BOTH(HAS_MARLINUI_MENU, SCROLL_LONG_FILENAMES)
+      #if ALL(HAS_MARLINUI_MENU, SCROLL_LONG_FILENAMES)
         // If scrolling of long file names is enabled and we are in the sd card menu,
         // cause a refresh to occur until all the text has scrolled into view.
         if (currentScreen == menu_media && !lcd_status_update_delay--) {
@@ -1353,7 +1353,7 @@ void MarlinUI::init() {
           #endif // UP || DOWN || LEFT || RIGHT
 
           buttons = (newbutton | TERN0(HAS_SLOW_BUTTONS, slow_buttons)
-            #if BOTH(HAS_TOUCH_BUTTONS, HAS_ENCODER_ACTION)
+            #if ALL(HAS_TOUCH_BUTTONS, HAS_ENCODER_ACTION)
               | (touch_buttons & TERN(HAS_ENCODER_WHEEL, ~(EN_A | EN_B), 0xFF))
             #endif
           );
@@ -1413,7 +1413,7 @@ void MarlinUI::init() {
             case 3: ENCODER_SPIN(2, 1); break;
             case 1: ENCODER_SPIN(3, 0); break;
           }
-          #if BOTH(HAS_MARLINUI_MENU, AUTO_BED_LEVELING_UBL)
+          #if ALL(HAS_MARLINUI_MENU, AUTO_BED_LEVELING_UBL)
             external_encoder();
           #endif
           lastEncoderBits = enc;
@@ -1587,7 +1587,7 @@ void MarlinUI::init() {
 
     #if HAS_WIRED_LCD
 
-      #if BASIC_PROGRESS_BAR || BOTH(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
+      #if BASIC_PROGRESS_BAR || ALL(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
         const millis_t ms = millis();
       #endif
 
@@ -1598,13 +1598,13 @@ void MarlinUI::init() {
         #endif
       #endif
 
-      #if BOTH(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
+      #if ALL(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
         pause_filament_display(ms); // Show status message for 5s
       #endif
 
     #endif
 
-    #if ENABLED(STATUS_MESSAGE_SCROLLING) && EITHER(HAS_WIRED_LCD, DWIN_LCD_PROUI)
+    #if ENABLED(STATUS_MESSAGE_SCROLLING) && ANY(HAS_WIRED_LCD, DWIN_LCD_PROUI)
       status_scroll_offset = 0;
     #endif
 
@@ -1670,7 +1670,7 @@ void MarlinUI::init() {
     TERN_(DWIN_LCD_PROUI, HMI_flag.abort_flag = true);
   }
 
-  #if BOTH(HAS_MARLINUI_MENU, PSU_CONTROL)
+  #if ALL(HAS_MARLINUI_MENU, PSU_CONTROL)
 
     void MarlinUI::poweroff() {
       queue.inject(F("M81" TERN_(POWER_OFF_WAIT_FOR_COOLDOWN, "S")));
@@ -1848,7 +1848,7 @@ void MarlinUI::init() {
     #endif
   }
 
-  #if EITHER(BABYSTEP_GFX_OVERLAY, MESH_EDIT_GFX_OVERLAY)
+  #if ANY(BABYSTEP_GFX_OVERLAY, MESH_EDIT_GFX_OVERLAY)
     void MarlinUI::zoffset_overlay(const_float_t zvalue) {
       // Determine whether the user is raising or lowering the nozzle.
       static int8_t dir;
@@ -1863,7 +1863,7 @@ void MarlinUI::init() {
 
 #endif
 
-#if BOTH(EXTENSIBLE_UI, ADVANCED_PAUSE_FEATURE)
+#if ALL(EXTENSIBLE_UI, ADVANCED_PAUSE_FEATURE)
 
   void MarlinUI::pause_show_message(
     const PauseMessage message,

commit 5bc84bf08cb47741537fe705dbfe19eee5396d4e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 19 23:30:48 2023 -0500

    🚸 Improve EEPROM validation (#25860)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index e8956ab9e1..1c4bbe5fa9 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1913,18 +1913,22 @@ void MarlinUI::init() {
 
   #if DISABLED(EEPROM_AUTO_INIT)
 
-    static inline FSTR_P eeprom_err(const uint8_t msgid) {
-      switch (msgid) {
-        default:
-        case 0: return GET_TEXT_F(MSG_ERR_EEPROM_CRC);
-        case 1: return GET_TEXT_F(MSG_ERR_EEPROM_INDEX);
-        case 2: return GET_TEXT_F(MSG_ERR_EEPROM_VERSION);
+    static inline FSTR_P eeprom_err(const EEPROM_Error err) {
+      switch (err) {
+        case ERR_EEPROM_VERSION:  return GET_TEXT_F(MSG_ERR_EEPROM_VERSION);
+        case ERR_EEPROM_SIZE:     return GET_TEXT_F(MSG_ERR_EEPROM_SIZE);
+        case ERR_EEPROM_CRC:      return GET_TEXT_F(MSG_ERR_EEPROM_CRC);
+        case ERR_EEPROM_CORRUPT:  return GET_TEXT_F(MSG_ERR_EEPROM_CORRUPT);
+        default: return nullptr;
       }
     }
 
-    void MarlinUI::eeprom_alert(const uint8_t msgid) {
+    void MarlinUI::eeprom_alert(const EEPROM_Error err) {
+      FSTR_P const err_msg = eeprom_err(err);
+      set_status(err_msg);
+      TERN_(HOST_PROMPT_SUPPORT, hostui.notify(err_msg));
       #if HAS_MARLINUI_MENU
-        editable.uint8 = msgid;
+        editable.uint8 = err;
         goto_screen([]{
           FSTR_P const restore_msg = GET_TEXT_F(MSG_INIT_EEPROM);
           char msg[utf8_strlen(restore_msg) + 1];
@@ -1932,11 +1936,9 @@ void MarlinUI::init() {
           MenuItem_confirm::select_screen(
             GET_TEXT_F(MSG_BUTTON_RESET), GET_TEXT_F(MSG_BUTTON_IGNORE),
             init_eeprom, return_to_status,
-            eeprom_err(editable.uint8), msg, F("?")
+            eeprom_err((EEPROM_Error)editable.uint8), msg, F("?")
           );
         });
-      #else
-        set_status(eeprom_err(msgid));
       #endif
     }
 

commit 2e24637bd66d725dc07a560cda81b40f67fd1d4a
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Mon May 15 13:48:55 2023 +1200

    "One Click" Print newest file (#25781)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 638a133184..e8956ab9e1 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -424,7 +424,7 @@ void MarlinUI::init() {
 
     #if !HAS_GRAPHICAL_TFT
 
-      void _wrap_string(uint8_t &col, uint8_t &row, const char * const string, read_byte_cb_t cb_read_byte, bool wordwrap/*=false*/) {
+      void _wrap_string(uint8_t &col, uint8_t &row, const char * const string, read_byte_cb_t cb_read_byte, const bool wordwrap/*=false*/) {
         SETCURSOR(col, row);
         if (!string) return;
 

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    🚸 Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index ec929753ae..638a133184 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -506,7 +506,7 @@ void MarlinUI::init() {
         ui.manual_move.menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
         ui.encoderPosition = dir;
         switch (axis) {
-          case X_AXIS:
+          TERN_(HAS_X_AXIS, case X_AXIS:)
           TERN_(HAS_Y_AXIS, case Y_AXIS:)
           TERN_(HAS_Z_AXIS, case Z_AXIS:)
             lcd_move_axis(axis);

commit 9a7d9e6995f4f66c4b48147ec7876d49d4b3ae77
Author: Martin Turski <turningtides@outlook.de>
Date:   Thu Apr 27 14:05:24 2023 +0200

    🧑‍💻 Optimize PlatformIO source filtering (#25332)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 75e24e2313..ec929753ae 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -42,7 +42,7 @@ MarlinUI ui;
 
 #if HAS_DISPLAY
   #include "../gcode/queue.h"
-  #include "fontutils.h"
+  #include "utf8.h"
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)

commit 650e6fc42691a634c0a2f303734a6023e80eeecc
Author: Anson Liu <ansonl@users.noreply.github.com>
Date:   Mon Apr 24 22:07:12 2023 -0400

    🔨 Prevent SlowSoftWire + Wire name conflict (#25707)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index b3db930fe4..75e24e2313 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -174,7 +174,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 #endif
 
 #if HAS_U8GLIB_I2C_OLED && PINS_EXIST(I2C_SCL, I2C_SDA) && DISABLED(SOFT_I2C_EEPROM)
-  #include "Wire.h"
+  #include <Wire.h>
 #endif
 
 // Encoder Handling

commit 10ed5ab01c43a09429e1eb885196308fca71f492
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 23 03:17:55 2023 -0500

    🚸 Improve PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED (#25681)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 0153a11a15..b3db930fe4 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -127,7 +127,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 #endif
 
 #if ENABLED(PCA9632_BUZZER)
-  void MarlinUI::buzz(const long duration, const uint16_t freq) {
+  void MarlinUI::buzz(const long duration, const uint16_t freq/*=0*/) {
     if (sound_on) PCA9632_buzz(duration, freq);
   }
 #endif

commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    🧑‍💻 Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index c1ec15dc19..0153a11a15 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -339,7 +339,7 @@ void MarlinUI::init() {
 
   uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 
-  #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+  #if BOTH(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
     millis_t MarlinUI::next_filament_display; // = 0
   #endif
 
@@ -353,7 +353,7 @@ void MarlinUI::init() {
     bool MarlinUI::did_first_redraw;
   #endif
 
-  #if ENABLED(SDSUPPORT)
+  #if HAS_MEDIA
 
     #if MARLINUI_SCROLL_NAME
       uint8_t MarlinUI::filename_scroll_pos, MarlinUI::filename_scroll_max;
@@ -670,7 +670,7 @@ void MarlinUI::init() {
 
     #if HAS_MARLINUI_MENU
       if (use_click()) {
-        #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+        #if BOTH(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
           pause_filament_display();
         #endif
         goto_screen(menu_main);
@@ -1490,7 +1490,7 @@ void MarlinUI::init() {
     FSTR_P msg;
     if (printingIsPaused())
       msg = GET_TEXT_F(MSG_PRINT_PAUSED);
-    #if ENABLED(SDSUPPORT)
+    #if HAS_MEDIA
       else if (IS_SD_PRINTING())
         return set_status(card.longest_filename(), true);
     #endif
@@ -1587,7 +1587,7 @@ void MarlinUI::init() {
 
     #if HAS_WIRED_LCD
 
-      #if BASIC_PROGRESS_BAR || BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+      #if BASIC_PROGRESS_BAR || BOTH(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
         const millis_t ms = millis();
       #endif
 
@@ -1598,7 +1598,7 @@ void MarlinUI::init() {
         #endif
       #endif
 
-      #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+      #if BOTH(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
         pause_filament_display(ms); // Show status message for 5s
       #endif
 
@@ -1651,12 +1651,12 @@ void MarlinUI::init() {
 
 #if HAS_DISPLAY
 
-  #if ENABLED(SDSUPPORT)
+  #if HAS_MEDIA
     extern bool wait_for_user, wait_for_heatup;
   #endif
 
   void MarlinUI::abort_print() {
-    #if ENABLED(SDSUPPORT)
+    #if HAS_MEDIA
       wait_for_heatup = wait_for_user = false;
       card.abortFilePrintSoon();
     #endif
@@ -1699,7 +1699,7 @@ void MarlinUI::init() {
     #if ENABLED(PARK_HEAD_ON_PAUSE)
       pause_show_message(PAUSE_MESSAGE_PARKING, PAUSE_MODE_PAUSE_PRINT); // Show message immediately to let user know about pause in progress
       queue.inject(F("M25 P\nM24"));
-    #elif ENABLED(SDSUPPORT)
+    #elif HAS_MEDIA
       queue.inject(F("M25"));
     #elif defined(ACTION_ON_PAUSE)
       hostui.pause();
@@ -1709,7 +1709,7 @@ void MarlinUI::init() {
   void MarlinUI::resume_print() {
     reset_status();
     TERN_(PARK_HEAD_ON_PAUSE, wait_for_heatup = wait_for_user = false);
-    TERN_(SDSUPPORT, if (IS_SD_PAUSED()) queue.inject_P(M24_STR));
+    TERN_(HAS_MEDIA, if (IS_SD_PAUSED()) queue.inject_P(M24_STR));
     #ifdef ACTION_ON_RESUME
       hostui.resume();
     #endif
@@ -1754,7 +1754,7 @@ void MarlinUI::init() {
   MarlinUI::progress_t MarlinUI::_get_progress() {
     return (
       TERN0(SET_PROGRESS_PERCENT, (progress_override & PROGRESS_MASK))
-      #if ENABLED(SDSUPPORT)
+      #if HAS_MEDIA
         ?: TERN(HAS_PRINT_PROGRESS_PERMYRIAD, card.permyriadDone(), card.percentDone())
       #endif
     );
@@ -1784,7 +1784,7 @@ void MarlinUI::init() {
 
 #endif // HAS_PRINT_PROGRESS
 
-#if ENABLED(SDSUPPORT)
+#if HAS_MEDIA
 
   #if ENABLED(EXTENSIBLE_UI)
     #include "extui/ui_api.h"
@@ -1837,7 +1837,7 @@ void MarlinUI::init() {
     #endif
   }
 
-#endif // SDSUPPORT
+#endif // HAS_MEDIA
 
 #if HAS_MARLINUI_MENU
   void MarlinUI::reset_settings() {

commit 5d8d38a911f96dadd56471f6dacaa6bda64b66fb
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sun Apr 23 08:59:51 2023 +1200

    🩹 Status / Host Prompt followup (#25720)
    
    Followup to #25679
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 22b3fa27d7..c1ec15dc19 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1424,6 +1424,13 @@ void MarlinUI::init() {
 
   #endif // HAS_ENCODER_ACTION
 
+  #if HAS_SOUND
+    void MarlinUI::completion_feedback(const bool good/*=true*/) {
+      TERN_(HAS_TOUCH_SLEEP, wakeup_screen()); // Wake up on rotary encoder click...
+      if (good) OKAY_BUZZ(); else ERR_BUZZ();
+    }
+  #endif
+
 #endif // HAS_WIRED_LCD
 
 #if HAS_STATUS_MESSAGE

commit 9a1c02591ba4c3d5b41f4c64edd819ea1860b75b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 14 17:51:45 2023 -0500

    🧑‍💻 Status Message cleanup

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 88cdb99076..22b3fa27d7 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -671,7 +671,7 @@ void MarlinUI::init() {
     #if HAS_MARLINUI_MENU
       if (use_click()) {
         #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
-          next_filament_display = millis() + 5000UL;  // Show status message for 5s
+          pause_filament_display();
         #endif
         goto_screen(menu_main);
         reinit_lcd(); // Revive a noisy shared SPI LCD
@@ -1592,7 +1592,7 @@ void MarlinUI::init() {
       #endif
 
       #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
-        next_filament_display = ms + 5000UL; // Show status message for 5s
+        pause_filament_display(ms); // Show status message for 5s
       #endif
 
     #endif

commit 65b97438fa92743ac5b2659ae55013a4c413da39
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 15 19:13:09 2023 -0500

    🩹 Fan Menu / Status fixes
    
    Followup to #21888

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index d3f01e6d23..88cdb99076 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -351,7 +351,6 @@ void MarlinUI::init() {
 
   #if IS_DWIN_MARLINUI
     bool MarlinUI::did_first_redraw;
-    bool MarlinUI::old_is_printing;
   #endif
 
   #if ENABLED(SDSUPPORT)

commit 866e7d3128a7c526a76b8826df70b3769177385d
Author: Daranbalt4 <119883952+Daranbalt4@users.noreply.github.com>
Date:   Mon Feb 27 04:23:52 2023 +0100

    ✨ LCD_BACKLIGHT_TIMEOUT for Neopixel LCD (#25438)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index aa1ccb17c2..d3f01e6d23 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -24,7 +24,7 @@
 
 #include "../MarlinCore.h" // for printingIsPaused
 
-#if LED_POWEROFF_TIMEOUT > 0 || BOTH(HAS_WIRED_LCD, PRINTER_EVENT_LEDS)
+#if LED_POWEROFF_TIMEOUT > 0 || BOTH(HAS_WIRED_LCD, PRINTER_EVENT_LEDS) || (defined(LCD_BACKLIGHT_TIMEOUT_MINS) && defined(NEOPIXEL_BKGD_INDEX_FIRST))
   #include "../feature/leds/leds.h"
 #endif
 
@@ -186,12 +186,17 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 #if LCD_BACKLIGHT_TIMEOUT_MINS
 
   constexpr uint8_t MarlinUI::backlight_timeout_min, MarlinUI::backlight_timeout_max;
-
   uint8_t MarlinUI::backlight_timeout_minutes; // Initialized by settings.load()
   millis_t MarlinUI::backlight_off_ms = 0;
+
   void MarlinUI::refresh_backlight_timeout() {
     backlight_off_ms = backlight_timeout_minutes ? millis() + backlight_timeout_minutes * 60UL * 1000UL : 0;
-    WRITE(LCD_BACKLIGHT_PIN, HIGH);
+    #ifdef NEOPIXEL_BKGD_INDEX_FIRST
+      neo.reset_background_color();
+      neo.show();
+    #elif PIN_EXISTS(LCD_BACKLIGHT)
+      WRITE(LCD_BACKLIGHT_PIN, HIGH);
+    #endif
   }
 
 #elif HAS_DISPLAY_SLEEP
@@ -1196,8 +1201,14 @@ void MarlinUI::init() {
       #endif
 
       #if LCD_BACKLIGHT_TIMEOUT_MINS
+
         if (backlight_off_ms && ELAPSED(ms, backlight_off_ms)) {
-          WRITE(LCD_BACKLIGHT_PIN, LOW); // Backlight off
+          #ifdef NEOPIXEL_BKGD_INDEX_FIRST
+            neo.set_background_off();
+            neo.show();
+          #elif PIN_EXIST(LCD_BACKLIGHT)
+            WRITE(LCD_BACKLIGHT_PIN, LOW); // Backlight off
+          #endif
           backlight_off_ms = 0;
         }
       #elif HAS_DISPLAY_SLEEP

commit 03a43786703d84f1b8c6374755b2764aeb9e04eb
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Tue Feb 21 15:25:22 2023 +1300

    🔧 Sanity-check hotend max / preheat temps (#25407)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index d10ae7c5cc..aa1ccb17c2 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -149,7 +149,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     const preheat_t &pre = material_preset[m];
     TERN_(HAS_HOTEND,           if (TEST(pmask, PT_HOTEND))  thermalManager.setTargetHotend(pre.hotend_temp, e));
     TERN_(HAS_HEATED_BED,       if (TEST(pmask, PT_BED))     thermalManager.setTargetBed(pre.bed_temp));
-    //TERN_(HAS_HEATED_CHAMBER, if (TEST(pmask, PT_CHAMBER)) thermalManager.setTargetBed(pre.chamber_temp));
+    //TERN_(HAS_HEATED_CHAMBER, if (TEST(pmask, PT_CHAMBER)) thermalManager.setTargetChamber(pre.chamber_temp));
     TERN_(HAS_FAN,              if (TEST(pmask, PT_FAN))     thermalManager.set_fan_speed(0, pre.fan_speed));
   }
 #endif

commit 96bc084f3d791bc93265f217181986863e8e5fc7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 18 02:15:16 2023 -0600

    🎨 Misc. LCD cleanup (#25400)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 5d264198a3..d10ae7c5cc 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1831,7 +1831,7 @@ void MarlinUI::init() {
     #endif
   }
 
-  #if EITHER(BABYSTEP_ZPROBE_GFX_OVERLAY, MESH_EDIT_GFX_OVERLAY)
+  #if EITHER(BABYSTEP_GFX_OVERLAY, MESH_EDIT_GFX_OVERLAY)
     void MarlinUI::zoffset_overlay(const_float_t zvalue) {
       // Determine whether the user is raising or lowering the nozzle.
       static int8_t dir;

commit f595878b5b12ba87c88e43160b3434e76c782998
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 8 20:28:56 2023 -0600

    🩹 Various simple fixes

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 91982b5480..5d264198a3 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -833,7 +833,7 @@ void MarlinUI::init() {
           // Apply a linear offset to a single axis
           if (axis == ALL_AXES_ENUM)
             destination = all_axes_destination;
-          else if (axis <= XYZE) {
+          else if (axis <= LOGICAL_AXES) {
             destination = current_position;
             destination[axis] += offset;
           }

commit b7c23631c5840e2338cae531b171459e9e9c5301
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sun Jan 22 15:08:37 2023 +1300

    🐛 Fix misc. UI issues (#25252)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index ff12703ca9..91982b5480 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1743,9 +1743,11 @@ void MarlinUI::init() {
     );
   }
 
-  #if LCD_WITH_BLINK && DISABLED(HAS_GRAPHICAL_TFT)
-    typedef void (*PrintProgress_t)();
-    void MarlinUI::rotate_progress() { // Renew and redraw all enabled progress strings
+  #if LCD_WITH_BLINK && HAS_EXTRA_PROGRESS
+
+    // Renew and redraw all enabled progress strings
+    void MarlinUI::rotate_progress() {
+      typedef void (*PrintProgress_t)();
       const PrintProgress_t progFunc[] = {
         OPTITEM(SHOW_PROGRESS_PERCENT, drawPercent)
         OPTITEM(SHOW_ELAPSED_TIME, drawElapsed)
@@ -1760,7 +1762,8 @@ void MarlinUI::init() {
         (*progFunc[i])();
       }
     }
-  #endif
+
+  #endif // LCD_WITH_BLINK && HAS_EXTRA_PROGRESS
 
 #endif // HAS_PRINT_PROGRESS
 

commit c66b3cf8a429c427c014f33171407c634da735f1
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Sun Jan 8 04:22:21 2023 -0500

    🚸 ProUI updates (#25176)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index c5df604517..ff12703ca9 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1650,6 +1650,7 @@ void MarlinUI::init() {
     TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_open(PROMPT_INFO, F("UI Aborted"), FPSTR(DISMISS_STR)));
     LCD_MESSAGE(MSG_PRINT_ABORTED);
     TERN_(HAS_MARLINUI_MENU, return_to_status());
+    TERN_(DWIN_LCD_PROUI, HMI_flag.abort_flag = true);
   }
 
   #if BOTH(HAS_MARLINUI_MENU, PSU_CONTROL)

commit 7884ce070778ae8a6c25b81e4be84b8ffa193be3
Author: alextrical <35117191+alextrical@users.noreply.github.com>
Date:   Mon Dec 12 22:11:09 2022 +0000

    🩹 Use custom I2C pins for OLED (#24970)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index cdda7ca85a..c5df604517 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -173,6 +173,10 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
 #endif
 
+#if HAS_U8GLIB_I2C_OLED && PINS_EXIST(I2C_SCL, I2C_SDA) && DISABLED(SOFT_I2C_EEPROM)
+  #include "Wire.h"
+#endif
+
 // Encoder Handling
 #if HAS_ENCODER_ACTION
   uint32_t MarlinUI::encoderPosition;
@@ -265,6 +269,10 @@ void MarlinUI::init() {
     slow_buttons = 0;
   #endif
 
+  #if HAS_U8GLIB_I2C_OLED && PINS_EXIST(I2C_SCL, I2C_SDA) && DISABLED(SOFT_I2C_EEPROM)
+    Wire.begin(int(I2C_SDA_PIN), int(I2C_SCL_PIN));
+  #endif
+
   update_buttons();
 
   TERN_(HAS_ENCODER_ACTION, encoderDiff = 0);

commit 86276a6dd2c5e7f8f7a3c6e02c6d08af11f64998
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sat Nov 26 08:23:24 2022 +0100

    🚸 COLOR_UI sleep timeout / setting (#24994)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 5991806b7b..cdda7ca85a 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -196,12 +196,15 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
   uint8_t MarlinUI::sleep_timeout_minutes; // Initialized by settings.load()
   millis_t MarlinUI::screen_timeout_millis = 0;
-  #if DISABLED(TFT_COLOR_UI)
-    void MarlinUI::refresh_screen_timeout() {
-      screen_timeout_millis = sleep_timeout_minutes ? millis() + sleep_timeout_minutes * 60UL * 1000UL : 0;
-      sleep_display(false);
-    }
+  void MarlinUI::refresh_screen_timeout() {
+    screen_timeout_millis = sleep_timeout_minutes ? millis() + sleep_timeout_minutes * 60UL * 1000UL : 0;
+    sleep_display(false);
+  }
+
+  #if !HAS_TOUCH_SLEEP && !HAS_MARLINUI_U8GLIB // without DOGM (COLOR_UI)
+    void MarlinUI::sleep_display(const bool sleep) {} // if unimplemented
   #endif
+
 #endif
 
 void MarlinUI::init() {
@@ -731,6 +734,11 @@ void MarlinUI::init() {
     void MarlinUI::wakeup_screen() {
       TERN(HAS_TOUCH_BUTTONS, touchBt.wakeUp(), touch.wakeUp());
     }
+    #if HAS_DISPLAY_SLEEP && !HAS_MARLINUI_U8GLIB // without DOGM (COLOR_UI)
+      void MarlinUI::sleep_display(const bool sleep) {
+        if (!sleep) wakeup_screen(); // relay extra wake up events
+      }
+    #endif
   #endif
 
   void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
@@ -1071,7 +1079,7 @@ void MarlinUI::init() {
 
           #if LCD_BACKLIGHT_TIMEOUT_MINS
             refresh_backlight_timeout();
-          #elif HAS_DISPLAY_SLEEP && DISABLED(TFT_COLOR_UI)
+          #elif HAS_DISPLAY_SLEEP
             refresh_screen_timeout();
           #endif
 
@@ -1184,9 +1192,9 @@ void MarlinUI::init() {
           WRITE(LCD_BACKLIGHT_PIN, LOW); // Backlight off
           backlight_off_ms = 0;
         }
-      #elif HAS_DISPLAY_SLEEP && DISABLED(TFT_COLOR_UI)
+      #elif HAS_DISPLAY_SLEEP
         if (screen_timeout_millis && ELAPSED(ms, screen_timeout_millis))
-          sleep_display(true);
+          sleep_display();
       #endif
 
       // Change state of drawing flag between screen updates

commit c57925029471a4ce9acf2d96a5fda4d088b3e172
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 3 21:29:22 2022 -0500

    🧑‍💻 More direct encoder spin

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 0dfe60d8e4..5991806b7b 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1382,10 +1382,10 @@ void MarlinUI::init() {
         if (buttons & EN_B) enc |= B10;
         if (enc != lastEncoderBits) {
           switch (enc) {
-            case ENCODER_PHASE_0: ENCODER_SPIN(ENCODER_PHASE_3, ENCODER_PHASE_1); break;
-            case ENCODER_PHASE_1: ENCODER_SPIN(ENCODER_PHASE_0, ENCODER_PHASE_2); break;
-            case ENCODER_PHASE_2: ENCODER_SPIN(ENCODER_PHASE_1, ENCODER_PHASE_3); break;
-            case ENCODER_PHASE_3: ENCODER_SPIN(ENCODER_PHASE_2, ENCODER_PHASE_0); break;
+            case 0: ENCODER_SPIN(1, 2); break;
+            case 2: ENCODER_SPIN(0, 3); break;
+            case 3: ENCODER_SPIN(2, 1); break;
+            case 1: ENCODER_SPIN(3, 0); break;
           }
           #if BOTH(HAS_MARLINUI_MENU, AUTO_BED_LEVELING_UBL)
             external_encoder();

commit 81f88fefdc1d32fade897ddd0daff604c92b5da0
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Oct 24 17:44:52 2022 -0400

    🐛 Fix FTDUI Status Screen Timeout (#24899)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index c885e83845..0dfe60d8e4 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -316,7 +316,7 @@ void MarlinUI::init() {
     #endif
   #endif
 
-  #if SCREENS_CAN_TIME_OUT
+  #if HAS_SCREEN_TIMEOUT
     bool MarlinUI::defer_return_to_status;
     millis_t MarlinUI::return_to_status_ms = 0;
   #endif
@@ -1171,7 +1171,7 @@ void MarlinUI::init() {
           NOLESS(max_display_update_time, millis() - ms);
       }
 
-      #if SCREENS_CAN_TIME_OUT
+      #if HAS_SCREEN_TIMEOUT
         // Return to Status Screen after a timeout
         if (on_status_screen() || defer_return_to_status)
           reset_status_timeout(ms);

commit b244785141f518202060467bf39717192728c65d
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Oct 19 21:36:39 2022 -0400

    🐛 Fix Print Timer stop with MarlinUI abort (#24902)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index b1827534b5..c885e83845 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1630,7 +1630,7 @@ void MarlinUI::init() {
     #ifdef ACTION_ON_CANCEL
       hostui.cancel();
     #endif
-    IF_DISABLED(SDSUPPORT, print_job_timer.stop());
+    print_job_timer.stop();
     TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_open(PROMPT_INFO, F("UI Aborted"), FPSTR(DISMISS_STR)));
     LCD_MESSAGE(MSG_PRINT_ABORTED);
     TERN_(HAS_MARLINUI_MENU, return_to_status());

commit 81976c43609863d73b28d8af656802214e677557
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 17 23:00:26 2022 -0500

    🧑‍💻 Pins and debug list cleanup (#24878)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 2e116d5479..b1827534b5 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -227,14 +227,14 @@ void MarlinUI::init() {
     #if BUTTON_EXISTS(UP)
       SET_INPUT(BTN_UP);
     #endif
-    #if BUTTON_EXISTS(DWN)
-      SET_INPUT(BTN_DWN);
+    #if BUTTON_EXISTS(DOWN)
+      SET_INPUT(BTN_DOWN);
     #endif
     #if BUTTON_EXISTS(LFT)
-      SET_INPUT(BTN_LFT);
+      SET_INPUT(BTN_LEFT);
     #endif
     #if BUTTON_EXISTS(RT)
-      SET_INPUT(BTN_RT);
+      SET_INPUT(BTN_RIGHT);
     #endif
   #endif
 
@@ -1303,7 +1303,7 @@ void MarlinUI::init() {
           //
           // Directional buttons
           //
-          #if ANY_BUTTON(UP, DWN, LFT, RT)
+          #if ANY_BUTTON(UP, DOWN, LEFT, RIGHT)
 
             const int8_t pulses = epps * encoderDirection;
 
@@ -1311,20 +1311,20 @@ void MarlinUI::init() {
               encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * pulses;
               next_button_update_ms = now + 300;
             }
-            else if (BUTTON_PRESSED(DWN)) {
+            else if (BUTTON_PRESSED(DOWN)) {
               encoderDiff = -(ENCODER_STEPS_PER_MENU_ITEM) * pulses;
               next_button_update_ms = now + 300;
             }
-            else if (BUTTON_PRESSED(LFT)) {
+            else if (BUTTON_PRESSED(LEFT)) {
               encoderDiff = -pulses;
               next_button_update_ms = now + 300;
             }
-            else if (BUTTON_PRESSED(RT)) {
+            else if (BUTTON_PRESSED(RIGHT)) {
               encoderDiff = pulses;
               next_button_update_ms = now + 300;
             }
 
-          #endif // UP || DWN || LFT || RT
+          #endif // UP || DOWN || LEFT || RIGHT
 
           buttons = (newbutton | TERN0(HAS_SLOW_BUTTONS, slow_buttons)
             #if BOTH(HAS_TOUCH_BUTTONS, HAS_ENCODER_ACTION)

commit e37a23231aa6ebe5520b42f54720b76f7414c56a
Author: mjbogusz <mjbogusz@users.noreply.github.com>
Date:   Sat Oct 15 01:59:31 2022 +0200

    🩹 Fix TFT LCD in Simulation (#24871)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 00b0d62e1a..2e116d5479 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1726,7 +1726,7 @@ void MarlinUI::init() {
     );
   }
 
-  #if LCD_WITH_BLINK
+  #if LCD_WITH_BLINK && DISABLED(HAS_GRAPHICAL_TFT)
     typedef void (*PrintProgress_t)();
     void MarlinUI::rotate_progress() { // Renew and redraw all enabled progress strings
       const PrintProgress_t progFunc[] = {

commit f595e40ceb0c79d7f0d6438636658dfcfa2a75b8
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Sun Oct 9 18:30:47 2022 +0300

    ♻️ Set Progress without LCD (#24767)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 2f30da001f..00b0d62e1a 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -79,11 +79,16 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   statusResetFunc_t MarlinUI::status_reset_callback; // = nullptr
 #endif
 
-#if ENABLED(LCD_SET_PROGRESS_MANUALLY)
-  MarlinUI::progress_t MarlinUI::progress_override; // = 0
-  #if ENABLED(USE_M73_REMAINING_TIME)
+#if ENABLED(SET_PROGRESS_MANUALLY)
+  #if ENABLED(SET_PROGRESS_PERCENT)
+    MarlinUI::progress_t MarlinUI::progress_override; // = 0
+  #endif
+  #if ENABLED(SET_REMAINING_TIME)
     uint32_t MarlinUI::remaining_time;
   #endif
+  #if ENABLED(SET_INTERACTION_TIME)
+    uint32_t MarlinUI::interaction_time;
+  #endif
 #endif
 
 #if HAS_MULTI_LANGUAGE
@@ -153,7 +158,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   bool MarlinUI::lcd_clicked;
 #endif
 
-#if EITHER(HAS_WIRED_LCD, DWIN_CREALITY_LCD_JYERSUI)
+#if LCD_WITH_BLINK
 
   bool MarlinUI::get_blink() {
     static uint8_t blink = 0;
@@ -1677,19 +1682,6 @@ void MarlinUI::init() {
     print_job_timer.start(); // Also called by M24
   }
 
-  #if HAS_PRINT_PROGRESS
-
-    MarlinUI::progress_t MarlinUI::_get_progress() {
-      return (
-        TERN0(LCD_SET_PROGRESS_MANUALLY, (progress_override & PROGRESS_MASK))
-        #if ENABLED(SDSUPPORT)
-          ?: TERN(HAS_PRINT_PROGRESS_PERMYRIAD, card.permyriadDone(), card.percentDone())
-        #endif
-      );
-    }
-
-  #endif
-
   #if HAS_TOUCH_BUTTONS
 
     //
@@ -1723,6 +1715,38 @@ void MarlinUI::init() {
 
 #endif // HAS_DISPLAY
 
+#if HAS_PRINT_PROGRESS
+
+  MarlinUI::progress_t MarlinUI::_get_progress() {
+    return (
+      TERN0(SET_PROGRESS_PERCENT, (progress_override & PROGRESS_MASK))
+      #if ENABLED(SDSUPPORT)
+        ?: TERN(HAS_PRINT_PROGRESS_PERMYRIAD, card.permyriadDone(), card.percentDone())
+      #endif
+    );
+  }
+
+  #if LCD_WITH_BLINK
+    typedef void (*PrintProgress_t)();
+    void MarlinUI::rotate_progress() { // Renew and redraw all enabled progress strings
+      const PrintProgress_t progFunc[] = {
+        OPTITEM(SHOW_PROGRESS_PERCENT, drawPercent)
+        OPTITEM(SHOW_ELAPSED_TIME, drawElapsed)
+        OPTITEM(SHOW_REMAINING_TIME, drawRemain)
+        OPTITEM(SHOW_INTERACTION_TIME, drawInter)
+      };
+      static bool prev_blink;
+      static uint8_t i;
+      if (prev_blink != get_blink()) {
+        prev_blink = get_blink();
+        if (++i >= COUNT(progFunc)) i = 0;
+        (*progFunc[i])();
+      }
+    }
+  #endif
+
+#endif // HAS_PRINT_PROGRESS
+
 #if ENABLED(SDSUPPORT)
 
   #if ENABLED(EXTENSIBLE_UI)

commit fcf9f22390ca47f68b85d02c93e9ceeabd599f79
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Sat Oct 1 23:04:50 2022 +0300

    🩹 Fix Color UI touchscreen sleep (#24826)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 8b9c0e048e..2f30da001f 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -191,11 +191,12 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
   uint8_t MarlinUI::sleep_timeout_minutes; // Initialized by settings.load()
   millis_t MarlinUI::screen_timeout_millis = 0;
-  void MarlinUI::refresh_screen_timeout() {
-    screen_timeout_millis = sleep_timeout_minutes ? millis() + sleep_timeout_minutes * 60UL * 1000UL : 0;
-    sleep_display(false);
-  }
-
+  #if DISABLED(TFT_COLOR_UI)
+    void MarlinUI::refresh_screen_timeout() {
+      screen_timeout_millis = sleep_timeout_minutes ? millis() + sleep_timeout_minutes * 60UL * 1000UL : 0;
+      sleep_display(false);
+    }
+  #endif
 #endif
 
 void MarlinUI::init() {
@@ -1065,7 +1066,7 @@ void MarlinUI::init() {
 
           #if LCD_BACKLIGHT_TIMEOUT_MINS
             refresh_backlight_timeout();
-          #elif HAS_DISPLAY_SLEEP
+          #elif HAS_DISPLAY_SLEEP && DISABLED(TFT_COLOR_UI)
             refresh_screen_timeout();
           #endif
 
@@ -1178,9 +1179,9 @@ void MarlinUI::init() {
           WRITE(LCD_BACKLIGHT_PIN, LOW); // Backlight off
           backlight_off_ms = 0;
         }
-      #elif HAS_DISPLAY_SLEEP
+      #elif HAS_DISPLAY_SLEEP && DISABLED(TFT_COLOR_UI)
         if (screen_timeout_millis && ELAPSED(ms, screen_timeout_millis))
-          sleep_display();
+          sleep_display(true);
       #endif
 
       // Change state of drawing flag between screen updates

commit 2f91154cbdcec3b81da9913bdd16556e8c775d06
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Thu Aug 25 20:16:55 2022 +0300

    ♻️ Display sleep minutes, encoder disable option (#24618)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index e03e80ed3c..8b9c0e048e 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -174,22 +174,26 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
 #endif
 
-#if LCD_BACKLIGHT_TIMEOUT
+#if LCD_BACKLIGHT_TIMEOUT_MINS
 
-  uint16_t MarlinUI::lcd_backlight_timeout; // Initialized by settings.load()
+  constexpr uint8_t MarlinUI::backlight_timeout_min, MarlinUI::backlight_timeout_max;
+
+  uint8_t MarlinUI::backlight_timeout_minutes; // Initialized by settings.load()
   millis_t MarlinUI::backlight_off_ms = 0;
   void MarlinUI::refresh_backlight_timeout() {
-    backlight_off_ms = lcd_backlight_timeout ? millis() + lcd_backlight_timeout * 1000UL : 0;
+    backlight_off_ms = backlight_timeout_minutes ? millis() + backlight_timeout_minutes * 60UL * 1000UL : 0;
     WRITE(LCD_BACKLIGHT_PIN, HIGH);
   }
 
 #elif HAS_DISPLAY_SLEEP
 
+  constexpr uint8_t MarlinUI::sleep_timeout_min, MarlinUI::sleep_timeout_max;
+
   uint8_t MarlinUI::sleep_timeout_minutes; // Initialized by settings.load()
   millis_t MarlinUI::screen_timeout_millis = 0;
   void MarlinUI::refresh_screen_timeout() {
     screen_timeout_millis = sleep_timeout_minutes ? millis() + sleep_timeout_minutes * 60UL * 1000UL : 0;
-    sleep_off();
+    sleep_display(false);
   }
 
 #endif
@@ -1059,7 +1063,7 @@ void MarlinUI::init() {
 
           reset_status_timeout(ms);
 
-          #if LCD_BACKLIGHT_TIMEOUT
+          #if LCD_BACKLIGHT_TIMEOUT_MINS
             refresh_backlight_timeout();
           #elif HAS_DISPLAY_SLEEP
             refresh_screen_timeout();
@@ -1169,14 +1173,14 @@ void MarlinUI::init() {
           return_to_status();
       #endif
 
-      #if LCD_BACKLIGHT_TIMEOUT
+      #if LCD_BACKLIGHT_TIMEOUT_MINS
         if (backlight_off_ms && ELAPSED(ms, backlight_off_ms)) {
           WRITE(LCD_BACKLIGHT_PIN, LOW); // Backlight off
           backlight_off_ms = 0;
         }
       #elif HAS_DISPLAY_SLEEP
         if (screen_timeout_millis && ELAPSED(ms, screen_timeout_millis))
-          sleep_on();
+          sleep_display();
       #endif
 
       // Change state of drawing flag between screen updates

commit 007af4776880fda761e925bce383ac41a7769833
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 22 21:59:00 2022 -0500

    ✨ Reinstate JyersUI

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 5b17b0b975..e03e80ed3c 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -49,6 +49,8 @@ MarlinUI ui;
   #include "e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_LCD_PROUI)
   #include "e3v2/proui/dwin.h"
+#elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+  #include "e3v2/jyersui/dwin.h"
 #endif
 
 #if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
@@ -151,7 +153,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   bool MarlinUI::lcd_clicked;
 #endif
 
-#if HAS_WIRED_LCD
+#if EITHER(HAS_WIRED_LCD, DWIN_CREALITY_LCD_JYERSUI)
 
   bool MarlinUI::get_blink() {
     static uint8_t blink = 0;
@@ -1566,6 +1568,7 @@ void MarlinUI::init() {
     TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
     TERN_(DWIN_CREALITY_LCD, DWIN_StatusChanged(status_message));
     TERN_(DWIN_LCD_PROUI, DWIN_CheckStatusMessage());
+    TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Update_Status(status_message));
   }
 
   #if ENABLED(STATUS_MESSAGE_SCROLLING)

commit 5f2908a117ab45cf9e5a03a39e499979a40bf0f3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jul 18 19:53:36 2022 -0500

    ♻️ Small sound / buzz refactor (#24520)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 7707cbb052..5b17b0b975 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -119,17 +119,9 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   bool MarlinUI::sound_on = ENABLED(SOUND_ON_DEFAULT);
 #endif
 
-#if EITHER(PCA9632_BUZZER, HAS_BEEPER)
-  #if ENABLED(PCA9632_BUZZER)
-    #include "../feature/leds/pca9632.h"
-  #endif
+#if ENABLED(PCA9632_BUZZER)
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
-    if (!sound_on) return;
-    #if ENABLED(PCA9632_BUZZER)
-      PCA9632_buzz(duration, freq);
-    #elif HAS_BEEPER
-      buzzer.tone(duration, freq);
-    #endif
+    if (sound_on) PCA9632_buzz(duration, freq);
   }
 #endif
 
@@ -683,7 +675,7 @@ void MarlinUI::init() {
       if (old_frm != new_frm) {
         feedrate_percentage = new_frm;
         encoderPosition = 0;
-        #if BOTH(HAS_BUZZER, BEEP_ON_FEEDRATE_CHANGE)
+        #if BOTH(HAS_SOUND, BEEP_ON_FEEDRATE_CHANGE)
           static millis_t next_beep;
           #ifndef GOT_MS
             const millis_t ms = millis();
@@ -741,11 +733,12 @@ void MarlinUI::init() {
       UNUSED(clear_buttons);
     #endif
 
-    #if HAS_CHIRP
-      chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
-      #if BOTH(HAS_MARLINUI_MENU, HAS_BEEPER)
+    chirp();  // Buzz and wait. Is the delay needed for buttons to settle?
+
+    #if HAS_CHIRP && HAS_MARLINUI_MENU
+      #if HAS_BEEPER
         for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
-      #elif HAS_MARLINUI_MENU
+      #else
         delay(10);
       #endif
     #endif

commit f73fad1b2fa6e70b3d632969ecf2773bee826643
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 6 19:34:45 2022 -0500

    🔥 Remove JyersUI (#24459)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 7d9cb1b679..7707cbb052 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -49,8 +49,6 @@ MarlinUI ui;
   #include "e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_LCD_PROUI)
   #include "e3v2/proui/dwin.h"
-#elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
-  #include "e3v2/jyersui/dwin.h"
 #endif
 
 #if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
@@ -161,7 +159,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   bool MarlinUI::lcd_clicked;
 #endif
 
-#if EITHER(HAS_WIRED_LCD, DWIN_CREALITY_LCD_JYERSUI)
+#if HAS_WIRED_LCD
 
   bool MarlinUI::get_blink() {
     static uint8_t blink = 0;
@@ -1575,7 +1573,6 @@ void MarlinUI::init() {
     TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
     TERN_(DWIN_CREALITY_LCD, DWIN_StatusChanged(status_message));
     TERN_(DWIN_LCD_PROUI, DWIN_CheckStatusMessage());
-    TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Update_Status(status_message));
   }
 
   #if ENABLED(STATUS_MESSAGE_SCROLLING)

commit f39e2bc1e428e540e5b031577dce683fb6811cea
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 3 23:44:06 2022 -0500

    🩹 Followup for lchar_t

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 4d80ca1405..7d9cb1b679 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -417,26 +417,26 @@ void MarlinUI::init() {
         };
 
         const uint8_t *p = (uint8_t*)string;
-        lchar_t ch;
+        lchar_t wc;
         if (wordwrap) {
           const uint8_t *wrd = nullptr;
           uint8_t c = 0;
           // find the end of the part
           for (;;) {
             if (!wrd) wrd = p;            // Get word start /before/ advancing
-            p = get_utf8_value_cb(p, cb_read_byte, ch);
-            const bool eol = !ch;         // zero ends the string
+            p = get_utf8_value_cb(p, cb_read_byte, wc);
+            const bool eol = !wc;         // zero ends the string
             // End or a break between phrases?
-            if (eol || ch == ' ' || ch == '-' || ch == '+' || ch == '.') {
-              if (!c && ch == ' ') { if (wrd) wrd++; continue; } // collapse extra spaces
+            if (eol || wc == ' ' || wc == '-' || wc == '+' || wc == '.') {
+              if (!c && wc == ' ') { if (wrd) wrd++; continue; } // collapse extra spaces
               // Past the right and the word is not too long?
               if (col + c > LCD_WIDTH && col >= (LCD_WIDTH) / 4) _newline(); // should it wrap?
               c += !eol;                  // +1 so the space will be printed
               col += c;                   // advance col to new position
               while (c) {                 // character countdown
                 --c;                      // count down to zero
-                wrd = get_utf8_value_cb(wrd, cb_read_byte, ch); // get characters again
-                lcd_put_lchar(ch);        // character to the LCD
+                wrd = get_utf8_value_cb(wrd, cb_read_byte, wc); // get characters again
+                lcd_put_lchar(wc);        // character to the LCD
               }
               if (eol) break;             // all done!
               wrd = nullptr;              // set up for next word
@@ -446,9 +446,9 @@ void MarlinUI::init() {
         }
         else {
           for (;;) {
-            p = get_utf8_value_cb(p, cb_read_byte, ch);
-            if (!ch) break;
-            lcd_put_lchar(ch);
+            p = get_utf8_value_cb(p, cb_read_byte, wc);
+            if (!wc) break;
+            lcd_put_lchar(wc);
             col++;
             if (col >= LCD_WIDTH) _newline();
           }

commit cb4a79173be3e8ed1ff45e7c346df1c28e744d5a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 1 04:49:37 2022 -0500

    🩹 Remove poison wchar_t macro

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index c1b6005934..4d80ca1405 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -417,14 +417,14 @@ void MarlinUI::init() {
         };
 
         const uint8_t *p = (uint8_t*)string;
-        wchar_t ch;
+        lchar_t ch;
         if (wordwrap) {
           const uint8_t *wrd = nullptr;
           uint8_t c = 0;
           // find the end of the part
           for (;;) {
             if (!wrd) wrd = p;            // Get word start /before/ advancing
-            p = get_utf8_value_cb(p, cb_read_byte, &ch);
+            p = get_utf8_value_cb(p, cb_read_byte, ch);
             const bool eol = !ch;         // zero ends the string
             // End or a break between phrases?
             if (eol || ch == ' ' || ch == '-' || ch == '+' || ch == '.') {
@@ -435,8 +435,8 @@ void MarlinUI::init() {
               col += c;                   // advance col to new position
               while (c) {                 // character countdown
                 --c;                      // count down to zero
-                wrd = get_utf8_value_cb(wrd, cb_read_byte, &ch); // get characters again
-                lcd_put_wchar(ch);        // character to the LCD
+                wrd = get_utf8_value_cb(wrd, cb_read_byte, ch); // get characters again
+                lcd_put_lchar(ch);        // character to the LCD
               }
               if (eol) break;             // all done!
               wrd = nullptr;              // set up for next word
@@ -446,9 +446,9 @@ void MarlinUI::init() {
         }
         else {
           for (;;) {
-            p = get_utf8_value_cb(p, cb_read_byte, &ch);
+            p = get_utf8_value_cb(p, cb_read_byte, ch);
             if (!ch) break;
-            lcd_put_wchar(ch);
+            lcd_put_lchar(ch);
             col++;
             if (col >= LCD_WIDTH) _newline();
           }

commit d8545551fed8498f1c420ec3b301d4d77d0de8b5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 26 05:47:18 2022 -0500

    🐛 Fix Manual Move axis selection (#24404)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 2e59183b04..c1b6005934 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -763,6 +763,7 @@ void MarlinUI::init() {
 
     millis_t ManualMove::start_time = 0;
     float ManualMove::menu_scale = 1;
+    screenFunc_t ManualMove::screen_ptr;
     #if IS_KINEMATIC
       float ManualMove::offset = 0;
       xyze_pos_t ManualMove::all_axes_destination = { 0 };
@@ -772,6 +773,9 @@ void MarlinUI::init() {
       int8_t ManualMove::e_index = 0;
     #endif
     AxisEnum ManualMove::axis = NO_AXIS_ENUM;
+    #if ENABLED(MANUAL_E_MOVES_RELATIVE)
+      float ManualMove::e_origin = 0;
+    #endif
 
     /**
      * If a manual move has been posted and its time has arrived, and if the planner
@@ -788,9 +792,6 @@ void MarlinUI::init() {
      * For kinematic machines:
      *   - Set manual_move.offset to modify one axis and post the move.
      *     This is used to achieve more rapid stepping on kinematic machines.
-     *
-     * Currently used by the _lcd_move_xyz function in menu_motion.cpp
-     * and the ubl_map_move_to_xy function in menu_ubl.cpp.
      */
     void ManualMove::task() {
 
@@ -861,7 +862,7 @@ void MarlinUI::init() {
 
       void MarlinUI::external_encoder() {
         if (external_control && encoderDiff) {
-          bedlevel.encoder_diff += encoderDiff;  // Encoder for UBL G29 mesh editing
+          bedlevel.encoder_diff += encoderDiff; // Encoder for UBL G29 mesh editing
           encoderDiff = 0;                  // Hide encoder events from the screen handler
           refresh(LCDVIEW_REDRAW_NOW);      // ...but keep the refresh.
         }

commit 6cbd7a48d16789fd73ab6ebe4be00bc2beff5591
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 20 21:15:57 2022 -0500

    🎨 Fix comments, formatting

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 3976c48dc7..2e59183b04 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -489,13 +489,10 @@ void MarlinUI::init() {
         ui.manual_move.menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
         ui.encoderPosition = dir;
         switch (axis) {
-          case X_AXIS: { void lcd_move_x(); lcd_move_x(); } break;
-          #if HAS_Y_AXIS
-            case Y_AXIS: { void lcd_move_y(); lcd_move_y(); } break;
-          #endif
-          #if HAS_Z_AXIS
-            case Z_AXIS: { void lcd_move_z(); lcd_move_z(); } break;
-          #endif
+          case X_AXIS:
+          TERN_(HAS_Y_AXIS, case Y_AXIS:)
+          TERN_(HAS_Z_AXIS, case Z_AXIS:)
+            lcd_move_axis(axis);
           default: break;
         }
       }

commit 3e9fb34892e85bc4069acf5baddbf12d6cd47789
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Tue Jun 7 18:59:21 2022 +1200

    🩹 Media Change followup (#24302)
    
    Followup to #24015

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 8958de657c..3976c48dc7 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1756,7 +1756,7 @@ void MarlinUI::init() {
       if (old_status < 2) {
         #if ENABLED(EXTENSIBLE_UI)
           ExtUI::onMediaRemoved();
-        #elif PIN_EXISTS(SD_DETECT)
+        #elif HAS_SD_DETECT
           LCD_MESSAGE(MSG_MEDIA_REMOVED);
           #if HAS_MARLINUI_MENU
             if (!defer_return_to_status) return_to_status();

commit 8aca38351cd6d33a1202bf9a13890dc8e5eadd49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 3 22:56:38 2022 -0500

    🧑‍💻 Extend LCD string substitution (#24278)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 51620c9913..8958de657c 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -416,10 +416,11 @@ void MarlinUI::init() {
           SETCURSOR(0, row);              // Simulate carriage return
         };
 
-        uint8_t *p = (uint8_t*)string;
+        const uint8_t *p = (uint8_t*)string;
         wchar_t ch;
         if (wordwrap) {
-          uint8_t *wrd = nullptr, c = 0;
+          const uint8_t *wrd = nullptr;
+          uint8_t c = 0;
           // find the end of the part
           for (;;) {
             if (!wrd) wrd = p;            // Get word start /before/ advancing

commit a5e1d4c50ae40c8203d8490be83ef86e16ebf1c2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 22 19:56:46 2022 -0500

    ♻️ Apply F() to more LCD code (#24228)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 675e22b110..51620c9913 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -140,12 +140,12 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
   preheat_t MarlinUI::material_preset[PREHEAT_COUNT];  // Initialized by settings.load()
 
-  PGM_P MarlinUI::get_preheat_label(const uint8_t m) {
+  FSTR_P MarlinUI::get_preheat_label(const uint8_t m) {
     #define _PDEF(N) static PGMSTR(preheat_##N##_label, PREHEAT_##N##_LABEL);
     #define _PLBL(N) preheat_##N##_label,
     REPEAT_1(PREHEAT_COUNT, _PDEF);
     static PGM_P const preheat_labels[PREHEAT_COUNT] PROGMEM = { REPEAT_1(PREHEAT_COUNT, _PLBL) };
-    return (PGM_P)pgm_read_ptr(&preheat_labels[m]);
+    return FPSTR((PGM_P)pgm_read_ptr(&preheat_labels[m]));
   }
 
   void MarlinUI::apply_preheat(const uint8_t m, const uint8_t pmask, const uint8_t e/*=active_extruder*/) {
@@ -454,20 +454,20 @@ void MarlinUI::init() {
         }
       }
 
-      void MarlinUI::draw_select_screen_prompt(PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
-        const uint8_t plen = utf8_strlen_P(pref), slen = suff ? utf8_strlen_P(suff) : 0;
+      void MarlinUI::draw_select_screen_prompt(FSTR_P const pref, const char * const string/*=nullptr*/, FSTR_P const suff/*=nullptr*/) {
+        const uint8_t plen = utf8_strlen(pref), slen = suff ? utf8_strlen(suff) : 0;
         uint8_t col = 0, row = 0;
         if (!string && plen + slen <= LCD_WIDTH) {
           col = (LCD_WIDTH - plen - slen) / 2;
           row = LCD_HEIGHT > 3 ? 1 : 0;
         }
         if (LCD_HEIGHT >= 8) row = LCD_HEIGHT / 2 - 2;
-        wrap_string_P(col, row, pref, true);
+        wrap_string_P(col, row, FTOP(pref), true);
         if (string) {
           if (col) { col = 0; row++; } // Move to the start of the next line
           wrap_string(col, row, string);
         }
-        if (suff) wrap_string_P(col, row, suff);
+        if (suff) wrap_string_P(col, row, FTOP(suff));
       }
 
     #endif // !HAS_GRAPHICAL_TFT
@@ -484,17 +484,17 @@ void MarlinUI::init() {
 
     #if HAS_MARLINUI_MENU && !HAS_ADC_BUTTONS
 
-      void lcd_move_x();
-      void lcd_move_y();
-      void lcd_move_z();
-
       void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
         ui.manual_move.menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
         ui.encoderPosition = dir;
         switch (axis) {
-          case X_AXIS: lcd_move_x(); break;
-          case Y_AXIS: lcd_move_y(); break;
-          case Z_AXIS: lcd_move_z();
+          case X_AXIS: { void lcd_move_x(); lcd_move_x(); } break;
+          #if HAS_Y_AXIS
+            case Y_AXIS: { void lcd_move_y(); lcd_move_y(); } break;
+          #endif
+          #if HAS_Z_AXIS
+            case Z_AXIS: { void lcd_move_z(); lcd_move_z(); } break;
+          #endif
           default: break;
         }
       }
@@ -1651,7 +1651,7 @@ void MarlinUI::init() {
 
   void MarlinUI::pause_print() {
     #if HAS_MARLINUI_MENU
-      synchronize(GET_TEXT(MSG_PAUSING));
+      synchronize(GET_TEXT_F(MSG_PAUSING));
       defer_status_screen();
     #endif
 
@@ -1855,12 +1855,12 @@ void MarlinUI::init() {
 
   #if DISABLED(EEPROM_AUTO_INIT)
 
-    static inline PGM_P eeprom_err(const uint8_t msgid) {
+    static inline FSTR_P eeprom_err(const uint8_t msgid) {
       switch (msgid) {
         default:
-        case 0: return GET_TEXT(MSG_ERR_EEPROM_CRC);
-        case 1: return GET_TEXT(MSG_ERR_EEPROM_INDEX);
-        case 2: return GET_TEXT(MSG_ERR_EEPROM_VERSION);
+        case 0: return GET_TEXT_F(MSG_ERR_EEPROM_CRC);
+        case 1: return GET_TEXT_F(MSG_ERR_EEPROM_INDEX);
+        case 2: return GET_TEXT_F(MSG_ERR_EEPROM_VERSION);
       }
     }
 
@@ -1868,17 +1868,17 @@ void MarlinUI::init() {
       #if HAS_MARLINUI_MENU
         editable.uint8 = msgid;
         goto_screen([]{
-          PGM_P const restore_msg = GET_TEXT(MSG_INIT_EEPROM);
-          char msg[utf8_strlen_P(restore_msg) + 1];
-          strcpy_P(msg, restore_msg);
+          FSTR_P const restore_msg = GET_TEXT_F(MSG_INIT_EEPROM);
+          char msg[utf8_strlen(restore_msg) + 1];
+          strcpy_P(msg, FTOP(restore_msg));
           MenuItem_confirm::select_screen(
-            GET_TEXT(MSG_BUTTON_RESET), GET_TEXT(MSG_BUTTON_IGNORE),
+            GET_TEXT_F(MSG_BUTTON_RESET), GET_TEXT_F(MSG_BUTTON_IGNORE),
             init_eeprom, return_to_status,
-            eeprom_err(editable.uint8), msg, PSTR("?")
+            eeprom_err(editable.uint8), msg, F("?")
           );
         });
       #else
-        set_status(FPSTR(eeprom_err(msgid)));
+        set_status(eeprom_err(msgid));
       #endif
     }
 

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ♻️ Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 955813c2fb..675e22b110 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -863,7 +863,7 @@ void MarlinUI::init() {
 
       void MarlinUI::external_encoder() {
         if (external_control && encoderDiff) {
-          ubl.encoder_diff += encoderDiff;  // Encoder for UBL G29 mesh editing
+          bedlevel.encoder_diff += encoderDiff;  // Encoder for UBL G29 mesh editing
           encoderDiff = 0;                  // Hide encoder events from the screen handler
           refresh(LCDVIEW_REDRAW_NOW);      // ...but keep the refresh.
         }

commit 04fe50936e23a8aca7a400591e700c1220f68b3f
Author: Pauli Jokela <pauli.jokela@didstopia.com>
Date:   Thu May 12 05:23:16 2022 +0300

    ✨ SOUND_ON_DEFAULT option (#24102)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index d2af634896..955813c2fb 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -118,19 +118,18 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 #endif
 
 #if ENABLED(SOUND_MENU_ITEM)
-  bool MarlinUI::buzzer_enabled = true;
+  bool MarlinUI::sound_on = ENABLED(SOUND_ON_DEFAULT);
 #endif
 
-#if EITHER(PCA9632_BUZZER, USE_BEEPER)
-  #include "../libs/buzzer.h" // for BUZZ() macro
+#if EITHER(PCA9632_BUZZER, HAS_BEEPER)
   #if ENABLED(PCA9632_BUZZER)
     #include "../feature/leds/pca9632.h"
   #endif
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
-    if (!buzzer_enabled) return;
+    if (!sound_on) return;
     #if ENABLED(PCA9632_BUZZER)
       PCA9632_buzz(duration, freq);
-    #elif USE_BEEPER
+    #elif HAS_BEEPER
       buzzer.tone(duration, freq);
     #endif
   }
@@ -694,7 +693,7 @@ void MarlinUI::init() {
             const millis_t ms = millis();
           #endif
           if (ELAPSED(ms, next_beep)) {
-            buzz(FEEDRATE_CHANGE_BEEP_DURATION, FEEDRATE_CHANGE_BEEP_FREQUENCY);
+            BUZZ(FEEDRATE_CHANGE_BEEP_DURATION, FEEDRATE_CHANGE_BEEP_FREQUENCY);
             next_beep = ms + 500UL;
           }
         #endif
@@ -748,7 +747,7 @@ void MarlinUI::init() {
 
     #if HAS_CHIRP
       chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
-      #if BOTH(HAS_MARLINUI_MENU, USE_BEEPER)
+      #if BOTH(HAS_MARLINUI_MENU, HAS_BEEPER)
         for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
       #elif HAS_MARLINUI_MENU
         delay(10);
@@ -1646,7 +1645,7 @@ void MarlinUI::init() {
 
   void MarlinUI::flow_fault() {
     LCD_ALERTMESSAGE(MSG_FLOWMETER_FAULT);
-    TERN_(HAS_BUZZER, buzz(1000, 440));
+    BUZZ(1000, 440);
     TERN_(HAS_MARLINUI_MENU, return_to_status());
   }
 

commit 32e6767b5acfc57ced0a58c269ff5ae1d6f5cfd2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 4 15:57:03 2022 -0500

    ✨ DOGM Display Sleep (#23992)
    
    Co-authored-by: borland1 <barryorlando@hotmail.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 48e3f08fa9..d2af634896 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -192,6 +192,15 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     WRITE(LCD_BACKLIGHT_PIN, HIGH);
   }
 
+#elif HAS_DISPLAY_SLEEP
+
+  uint8_t MarlinUI::sleep_timeout_minutes; // Initialized by settings.load()
+  millis_t MarlinUI::screen_timeout_millis = 0;
+  void MarlinUI::refresh_screen_timeout() {
+    screen_timeout_millis = sleep_timeout_minutes ? millis() + sleep_timeout_minutes * 60UL * 1000UL : 0;
+    sleep_off();
+  }
+
 #endif
 
 void MarlinUI::init() {
@@ -1061,6 +1070,8 @@ void MarlinUI::init() {
 
           #if LCD_BACKLIGHT_TIMEOUT
             refresh_backlight_timeout();
+          #elif HAS_DISPLAY_SLEEP
+            refresh_screen_timeout();
           #endif
 
           refresh(LCDVIEW_REDRAW_NOW);
@@ -1172,6 +1183,9 @@ void MarlinUI::init() {
           WRITE(LCD_BACKLIGHT_PIN, LOW); // Backlight off
           backlight_off_ms = 0;
         }
+      #elif HAS_DISPLAY_SLEEP
+        if (screen_timeout_millis && ELAPSED(ms, screen_timeout_millis))
+          sleep_on();
       #endif
 
       // Change state of drawing flag between screen updates

commit 8b8defeacc5f7ba2bac63baf65c1d3b1ef60177c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 3 20:52:27 2022 -0500

    🏗️ Extend AXIS_CHAR to include E
    
    Co-Authored-By: DerAndere <26200979+DerAndere1@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index cf225eb2bd..48e3f08fa9 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -831,7 +831,7 @@ void MarlinUI::init() {
             TERN_(MULTI_E_MANUAL, axis == E_AXIS ? e_index :) active_extruder
           );
 
-          //SERIAL_ECHOLNPGM("Add planner.move with Axis ", AS_CHAR(axis_codes[axis]), " at FR ", fr_mm_s);
+          //SERIAL_ECHOLNPGM("Add planner.move with Axis ", AS_CHAR(AXIS_CHAR(axis)), " at FR ", fr_mm_s);
 
           axis = NO_AXIS_ENUM;
 
@@ -848,7 +848,7 @@ void MarlinUI::init() {
       TERN_(MULTI_E_MANUAL, if (move_axis == E_AXIS) e_index = eindex);
       start_time = millis() + (menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
       axis = move_axis;
-      //SERIAL_ECHOLNPGM("Post Move with Axis ", AS_CHAR(axis_codes[axis]), " soon.");
+      //SERIAL_ECHOLNPGM("Post Move with Axis ", AS_CHAR(AXIS_CHAR(axis)), " soon.");
     }
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)

commit 19838d97be0d9ae22efa9d51a412bb1ac0bf056b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 3 16:50:39 2022 -0500

    🎨  Misc. adjustments, spacing

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 7c97ef791d..cf225eb2bd 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -184,12 +184,14 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 #endif
 
 #if LCD_BACKLIGHT_TIMEOUT
+
   uint16_t MarlinUI::lcd_backlight_timeout; // Initialized by settings.load()
   millis_t MarlinUI::backlight_off_ms = 0;
   void MarlinUI::refresh_backlight_timeout() {
     backlight_off_ms = lcd_backlight_timeout ? millis() + lcd_backlight_timeout * 1000UL : 0;
     WRITE(LCD_BACKLIGHT_PIN, HIGH);
   }
+
 #endif
 
 void MarlinUI::init() {

commit b7ffcd6941e8d75fefc5c454ad0e334d554c4cea
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Sat Mar 26 06:34:20 2022 +0700

    ✨ STATUS_MESSAGE_TIMEOUT_SEC (#23135)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 8906b01e5e..7c97ef791d 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -73,6 +73,9 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   #endif
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
   uint8_t MarlinUI::alert_level; // = 0
+  #if HAS_STATUS_MESSAGE_TIMEOUT
+    millis_t MarlinUI::status_message_expire_ms; // = 0
+  #endif
   statusResetFunc_t MarlinUI::status_reset_callback; // = nullptr
 #endif
 
@@ -628,8 +631,17 @@ void MarlinUI::init() {
 
     #endif // BASIC_PROGRESS_BAR
 
-    if (status_reset_callback && (*status_reset_callback)())
-      reset_status();
+    bool did_expire = status_reset_callback && (*status_reset_callback)();
+
+    #if HAS_STATUS_MESSAGE_TIMEOUT
+      #ifndef GOT_MS
+        #define GOT_MS
+        const millis_t ms = millis();
+      #endif
+      did_expire |= status_message_expire_ms && ELAPSED(ms, status_message_expire_ms);
+    #endif
+
+    if (did_expire) reset_status();
 
     #if HAS_MARLINUI_MENU
       if (use_click()) {
@@ -1521,6 +1533,8 @@ void MarlinUI::init() {
 
     set_status_reset_fn();
 
+    TERN_(HAS_STATUS_MESSAGE_TIMEOUT, status_message_expire_ms = persist ? 0 : millis() + (STATUS_MESSAGE_TIMEOUT_SEC) * 1000UL);
+
     #if HAS_WIRED_LCD
 
       #if BASIC_PROGRESS_BAR || BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)

commit fd742616ba6fd2db1607df197dea142cbf1a9d3f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 25 17:35:00 2022 -0500

    🚸 Clear "heating/cooling" message on temp reached

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index dc7ecf2246..8906b01e5e 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -73,6 +73,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   #endif
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
   uint8_t MarlinUI::alert_level; // = 0
+  statusResetFunc_t MarlinUI::status_reset_callback; // = nullptr
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
@@ -627,6 +628,9 @@ void MarlinUI::init() {
 
     #endif // BASIC_PROGRESS_BAR
 
+    if (status_reset_callback && (*status_reset_callback)())
+      reset_status();
+
     #if HAS_MARLINUI_MENU
       if (use_click()) {
         #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
@@ -1515,6 +1519,8 @@ void MarlinUI::init() {
 
     UNUSED(persist);
 
+    set_status_reset_fn();
+
     #if HAS_WIRED_LCD
 
       #if BASIC_PROGRESS_BAR || BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)

commit 8dfdf51678a4a3975df8250bedf3489fd4835796
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 25 17:09:55 2022 -0500

    🎨 Format, use status macros

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 9e27dc6006..dc7ecf2246 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -593,7 +593,7 @@ void MarlinUI::init() {
       // share the same line on the display.
       //
 
-      #if DISABLED(PROGRESS_MSG_ONCE) || (PROGRESS_MSG_EXPIRE > 0)
+      #if DISABLED(PROGRESS_MSG_ONCE) || PROGRESS_MSG_EXPIRE > 0
         #define GOT_MS
         const millis_t ms = millis();
       #endif
@@ -1420,6 +1420,7 @@ void MarlinUI::init() {
     #if SERVICE_INTERVAL_3 > 0
       static PGMSTR(service3, "> " SERVICE_NAME_3 "!");
     #endif
+
     FSTR_P msg;
     if (printingIsPaused())
       msg = GET_TEXT_F(MSG_PRINT_PAUSED);
@@ -1450,13 +1451,18 @@ void MarlinUI::init() {
     set_status(msg, -1);
   }
 
+  /**
+   * Set Status with a fixed string and alert level.
+   * @param fstr  A constant F-string to set as the status.
+   * @param level Alert level. Negative to ignore and reset the level. Non-zero never expires.
+   */
   void MarlinUI::set_status(FSTR_P const fstr, int8_t level) {
-    PGM_P const pstr = FTOP(fstr);
+    // Alerts block lower priority messages
     if (level < 0) level = alert_level = 0;
     if (level < alert_level) return;
     alert_level = level;
 
-    TERN_(HOST_STATUS_NOTIFICATIONS, hostui.notify(fstr));
+    PGM_P const pstr = FTOP(fstr);
 
     // Since the message is encoded in UTF8 it must
     // only be cut on a character boundary.
@@ -1476,6 +1482,8 @@ void MarlinUI::init() {
     strncpy_P(status_message, pstr, maxLen);
     status_message[maxLen] = '\0';
 
+    TERN_(HOST_STATUS_NOTIFICATIONS, hostui.notify(fstr));
+
     finish_status(level > 0);
   }
 

commit 4ff063440d5bbf00b43c933caffe83940b58b4f0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 25 17:09:26 2022 -0500

    🐛 Fix status_printf alert level

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 11b523ff53..9e27dc6006 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1487,9 +1487,12 @@ void MarlinUI::init() {
 
   #include <stdarg.h>
 
-  void MarlinUI::status_printf(const uint8_t level, FSTR_P const fmt, ...) {
+  void MarlinUI::status_printf(int8_t level, FSTR_P const fmt, ...) {
+    // Alerts block lower priority messages
+    if (level < 0) level = alert_level = 0;
     if (level < alert_level) return;
     alert_level = level;
+
     va_list args;
     va_start(args, FTOP(fmt));
     vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, FTOP(fmt), args);
@@ -1551,7 +1554,22 @@ void MarlinUI::init() {
 
   #endif
 
-#endif
+#else // !HAS_STATUS_MESSAGE
+
+  //
+  // Send the status line as a host notification
+  //
+  void MarlinUI::set_status(const char * const cstr, const bool) {
+    TERN(HOST_PROMPT_SUPPORT, hostui.notify(cstr), UNUSED(cstr));
+  }
+  void MarlinUI::set_status(FSTR_P const fstr, const int8_t) {
+    TERN(HOST_PROMPT_SUPPORT, hostui.notify(fstr), UNUSED(fstr));
+  }
+  void MarlinUI::status_printf(int8_t, FSTR_P const fstr, ...) {
+    TERN(HOST_PROMPT_SUPPORT, hostui.notify(fstr), UNUSED(fstr));
+  }
+
+#endif // !HAS_STATUS_MESSAGE
 
 #if HAS_DISPLAY
 
@@ -1663,22 +1681,7 @@ void MarlinUI::init() {
 
   #endif
 
-#elif !HAS_STATUS_MESSAGE // && !HAS_DISPLAY
-
-  //
-  // Send the status line as a host notification
-  //
-  void MarlinUI::set_status(const char * const cstr, const bool) {
-    TERN(HOST_PROMPT_SUPPORT, hostui.notify(cstr), UNUSED(cstr));
-  }
-  void MarlinUI::set_status(FSTR_P const fstr, const int8_t) {
-    TERN(HOST_PROMPT_SUPPORT, hostui.notify(fstr), UNUSED(fstr));
-  }
-  void MarlinUI::status_printf(const uint8_t, FSTR_P const fstr, ...) {
-    TERN(HOST_PROMPT_SUPPORT, hostui.notify(fstr), UNUSED(fstr));
-  }
-
-#endif // !HAS_DISPLAY && !HAS_STATUS_MESSAGE
+#endif // HAS_DISPLAY
 
 #if ENABLED(SDSUPPORT)
 

commit a63205a034180fdc515818ce8bad789b82da9d01
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 22 20:11:10 2022 -0500

    🩹 Fix ADC math overflow

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 786a865049..11b523ff53 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1206,7 +1206,7 @@ void MarlinUI::init() {
     #define ADC_BUTTON_VALUE(r)  raw_adc_t(HAL_ADC_RANGE * (ADC_BUTTONS_VALUE_SCALE) * r / (r + ADC_BUTTONS_R_PULLUP))
 
     static constexpr raw_adc_t adc_button_tolerance = HAL_ADC_RANGE *   25 / 1024,
-                                   adc_other_button = HAL_ADC_RANGE * 1000 / 1024;
+                                   adc_other_button = raw_adc_t(uint32_t(HAL_ADC_RANGE * 1000UL) / 1024UL);
     static const _stADCKeypadTable_ stADCKeyTable[] PROGMEM = {
       // VALUE_MIN, VALUE_MAX, KEY
       { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F1     }, // F1

commit 631e35bfd6cec8d61eca31ac2945ff890ab8f2ed
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Mar 18 03:15:26 2022 +0000

    ⚡️ Fix noisy ADC - 16x oversampling with 12-bit ADC (#23867)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index f0677afd2d..786a865049 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1176,7 +1176,7 @@ void MarlinUI::init() {
   #if HAS_ADC_BUTTONS
 
     typedef struct {
-      uint16_t ADCKeyValueMin, ADCKeyValueMax;
+      raw_adc_t ADCKeyValueMin, ADCKeyValueMax;
       uint8_t  ADCKeyNo;
     } _stADCKeypadTable_;
 
@@ -1203,10 +1203,10 @@ void MarlinUI::init() {
     #endif
 
     // Calculate the ADC value for the voltage divider with specified pull-down resistor value
-    #define ADC_BUTTON_VALUE(r)  int(HAL_ADC_RANGE * (ADC_BUTTONS_VALUE_SCALE) * r / (r + ADC_BUTTONS_R_PULLUP))
+    #define ADC_BUTTON_VALUE(r)  raw_adc_t(HAL_ADC_RANGE * (ADC_BUTTONS_VALUE_SCALE) * r / (r + ADC_BUTTONS_R_PULLUP))
 
-    static constexpr uint16_t adc_button_tolerance = HAL_ADC_RANGE *   25 / 1024,
-                                  adc_other_button = HAL_ADC_RANGE * 1000 / 1024;
+    static constexpr raw_adc_t adc_button_tolerance = HAL_ADC_RANGE *   25 / 1024,
+                                   adc_other_button = HAL_ADC_RANGE * 1000 / 1024;
     static const _stADCKeypadTable_ stADCKeyTable[] PROGMEM = {
       // VALUE_MIN, VALUE_MAX, KEY
       { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F1     }, // F1
@@ -1226,13 +1226,13 @@ void MarlinUI::init() {
 
     uint8_t get_ADC_keyValue() {
       if (thermalManager.ADCKey_count >= 16) {
-        const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw;
+        const raw_adc_t currentkpADCValue = thermalManager.current_ADCKey_raw;
         thermalManager.current_ADCKey_raw = HAL_ADC_RANGE;
         thermalManager.ADCKey_count = 0;
         if (currentkpADCValue < adc_other_button)
           LOOP_L_N(i, ADC_KEY_NUM) {
-            const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
-                           hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
+            const raw_adc_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
+                            hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
             if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
           }
       }

commit 79b38e0e14074b52e0aeb98b08a686a99a9b1aad
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Fri Mar 11 15:06:49 2022 -0500

    🚸 Update Ender3 V2/S1 Pro UI (#23878)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 810d0db527..f0677afd2d 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -48,7 +48,6 @@ MarlinUI ui;
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_LCD_PROUI)
-  #include "fontutils.h"
   #include "e3v2/proui/dwin.h"
 #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
   #include "e3v2/jyersui/dwin.h"
@@ -1441,8 +1440,10 @@ void MarlinUI::init() {
       else if (print_job_timer.needsService(3)) msg = FPSTR(service3);
     #endif
 
-    else if (!no_welcome)
-      msg = GET_TEXT_F(WELCOME_MSG);
+    else if (!no_welcome) msg = GET_TEXT_F(WELCOME_MSG);
+
+    else if (ENABLED(DWIN_LCD_PROUI))
+        msg = F("");
     else
       return;
 

commit 48b5362cf02ff12c9e9fc4d5825ceebe457ea34b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 10 22:07:47 2022 -0600

    🔧 DWIN_CREALITY_LCD_ENHANCED => DWIN_LCD_PROUI
    
    Followup to #23624

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index d2884cc3f1..810d0db527 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -47,7 +47,7 @@ MarlinUI ui;
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "e3v2/creality/dwin.h"
-#elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+#elif ENABLED(DWIN_LCD_PROUI)
   #include "fontutils.h"
   #include "e3v2/proui/dwin.h"
 #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
@@ -69,7 +69,7 @@ MarlinUI ui;
 constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
 #if HAS_STATUS_MESSAGE
-  #if ENABLED(STATUS_MESSAGE_SCROLLING) && EITHER(HAS_WIRED_LCD, DWIN_CREALITY_LCD_ENHANCED)
+  #if ENABLED(STATUS_MESSAGE_SCROLLING) && EITHER(HAS_WIRED_LCD, DWIN_LCD_PROUI)
     uint8_t MarlinUI::status_scroll_offset; // = 0
   #endif
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
@@ -1522,13 +1522,13 @@ void MarlinUI::init() {
 
     #endif
 
-    #if ENABLED(STATUS_MESSAGE_SCROLLING) && EITHER(HAS_WIRED_LCD, DWIN_CREALITY_LCD_ENHANCED)
+    #if ENABLED(STATUS_MESSAGE_SCROLLING) && EITHER(HAS_WIRED_LCD, DWIN_LCD_PROUI)
       status_scroll_offset = 0;
     #endif
 
     TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
     TERN_(DWIN_CREALITY_LCD, DWIN_StatusChanged(status_message));
-    TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_CheckStatusMessage());
+    TERN_(DWIN_LCD_PROUI, DWIN_CheckStatusMessage());
     TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Update_Status(status_message));
   }
 

commit 0e7be8e8c4b1a7ca351ce19b462cac2d27fab82d
Author: M. FURIC Franck <francknos@gmail.com>
Date:   Sat Feb 26 23:54:04 2022 +0100

    ✨ LCD Backlight Timer (#23768)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index d0cc2a25b8..d2884cc3f1 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -180,6 +180,15 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
 #endif
 
+#if LCD_BACKLIGHT_TIMEOUT
+  uint16_t MarlinUI::lcd_backlight_timeout; // Initialized by settings.load()
+  millis_t MarlinUI::backlight_off_ms = 0;
+  void MarlinUI::refresh_backlight_timeout() {
+    backlight_off_ms = lcd_backlight_timeout ? millis() + lcd_backlight_timeout * 1000UL : 0;
+    WRITE(LCD_BACKLIGHT_PIN, HIGH);
+  }
+#endif
+
 void MarlinUI::init() {
 
   init_lcd();
@@ -1033,14 +1042,18 @@ void MarlinUI::init() {
 
           reset_status_timeout(ms);
 
+          #if LCD_BACKLIGHT_TIMEOUT
+            refresh_backlight_timeout();
+          #endif
+
           refresh(LCDVIEW_REDRAW_NOW);
 
           #if LED_POWEROFF_TIMEOUT > 0
             if (!powerManager.psu_on) leds.reset_timeout(ms);
           #endif
-        }
+        } // encoder activity
 
-      #endif
+      #endif // HAS_ENCODER_ACTION
 
       // This runs every ~100ms when idling often enough.
       // Instead of tracking changes just redraw the Status Screen once per second.
@@ -1137,6 +1150,13 @@ void MarlinUI::init() {
           return_to_status();
       #endif
 
+      #if LCD_BACKLIGHT_TIMEOUT
+        if (backlight_off_ms && ELAPSED(ms, backlight_off_ms)) {
+          WRITE(LCD_BACKLIGHT_PIN, LOW); // Backlight off
+          backlight_off_ms = 0;
+        }
+      #endif
+
       // Change state of drawing flag between screen updates
       if (!drawing_screen) switch (lcdDrawUpdate) {
         case LCDVIEW_CLEAR_CALL_REDRAW:

commit 03516f05191b888b5378f0426bc86f41b6cb2d03
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Feb 13 14:44:24 2022 -0500

    ♻️ No ui.reinit_lcd on any ExtUI (#23722)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 27965c1bd4..d0cc2a25b8 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -625,7 +625,7 @@ void MarlinUI::init() {
           next_filament_display = millis() + 5000UL;  // Show status message for 5s
         #endif
         goto_screen(menu_main);
-        IF_DISABLED(NO_LCD_REINIT, init_lcd()); // May revive the LCD if static electricity killed it
+        reinit_lcd(); // Revive a noisy shared SPI LCD
         return;
       }
 
@@ -1697,9 +1697,7 @@ void MarlinUI::init() {
       }
     }
 
-    #if PIN_EXISTS(SD_DETECT) && DISABLED(NO_LCD_REINIT)
-      init_lcd(); // Revive a noisy shared SPI LCD
-    #endif
+    reinit_lcd(); // Revive a noisy shared SPI LCD
 
     refresh();
 

commit 7763f9385d506ef79ef81ccb48a972ab56050fb1
Author: Taylor Talkington <taylor.talkington@gmail.com>
Date:   Tue Feb 8 18:36:06 2022 -0500

    ✨ Optional HOST_STATUS_NOTIFICATIONS (#22833)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 3d579fbc97..27965c1bd4 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1363,7 +1363,7 @@ void MarlinUI::init() {
   void MarlinUI::set_status(const char * const cstr, const bool persist) {
     if (alert_level) return;
 
-    TERN_(HOST_PROMPT_SUPPORT, hostui.notify(cstr));
+    TERN_(HOST_STATUS_NOTIFICATIONS, hostui.notify(cstr));
 
     // Here we have a problem. The message is encoded in UTF8, so
     // arbitrarily cutting it will be a problem. We MUST be sure
@@ -1435,7 +1435,7 @@ void MarlinUI::init() {
     if (level < alert_level) return;
     alert_level = level;
 
-    TERN_(HOST_PROMPT_SUPPORT, hostui.notify(fstr));
+    TERN_(HOST_STATUS_NOTIFICATIONS, hostui.notify(fstr));
 
     // Since the message is encoded in UTF8 it must
     // only be cut on a character boundary.
@@ -1473,6 +1473,9 @@ void MarlinUI::init() {
     va_start(args, FTOP(fmt));
     vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, FTOP(fmt), args);
     va_end(args);
+
+    TERN_(HOST_STATUS_NOTIFICATIONS, hostui.notify(status_message));
+
     finish_status(level > 0);
   }
 

commit 0564cb188f1a74dc9ecfb55b793f4225424a9ca4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 5 10:30:17 2022 -0600

    🚸 Enhanced UI => Professional UI - with updates (#23624)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index fdb6df1808..3d579fbc97 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -49,7 +49,7 @@ MarlinUI ui;
   #include "e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
   #include "fontutils.h"
-  #include "e3v2/enhanced/dwin.h"
+  #include "e3v2/proui/dwin.h"
 #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
   #include "e3v2/jyersui/dwin.h"
 #endif
@@ -104,7 +104,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 #endif
 
 #if HAS_LCD_BRIGHTNESS
-  uint8_t MarlinUI::brightness = DEFAULT_LCD_BRIGHTNESS;
+  uint8_t MarlinUI::brightness = LCD_BRIGHTNESS_DEFAULT;
   bool MarlinUI::backlight = true;
 
   void MarlinUI::set_brightness(const uint8_t value) {

commit 076d8e83ea4247b75a90e71bcb80dc3f8e01a458
Author: Bones <97494397+SidSkiba@users.noreply.github.com>
Date:   Fri Feb 4 14:52:57 2022 -0700

    ✨ Add ZRIB v53, patch G35 Z drop, related issues (#23636)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index dd90fba41b..fdb6df1808 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -704,7 +704,8 @@ void MarlinUI::init() {
     TERN_(HAS_MARLINUI_MENU, refresh());
 
     #if HAS_ENCODER_ACTION
-      if (clear_buttons) buttons = 0;
+      if (clear_buttons)
+        TERN_(HAS_ADC_BUTTONS, keypad_buttons =) buttons = 0;
       next_button_update_ms = millis() + 500;
     #else
       UNUSED(clear_buttons);

commit f07fc7e96f512f4900619049761f75d28f9e0403
Author: GHGiampy <83699429+GHGiampy@users.noreply.github.com>
Date:   Wed Feb 2 00:35:38 2022 +0100

    🚸 Case Light, LED menus for E3V2 DWIN Enhanced UI (#23590)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index f2fce1c8cd..dd90fba41b 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -24,7 +24,7 @@
 
 #include "../MarlinCore.h" // for printingIsPaused
 
-#ifdef LED_BACKLIGHT_TIMEOUT
+#if LED_POWEROFF_TIMEOUT > 0 || BOTH(HAS_WIRED_LCD, PRINTER_EVENT_LEDS)
   #include "../feature/leds/leds.h"
 #endif
 
@@ -277,7 +277,7 @@ void MarlinUI::init() {
     #include "../feature/power_monitor.h"
   #endif
 
-  #if ENABLED(PSU_CONTROL) && defined(LED_BACKLIGHT_TIMEOUT)
+  #if LED_POWEROFF_TIMEOUT > 0
     #include "../feature/power.h"
   #endif
 
@@ -676,7 +676,7 @@ void MarlinUI::init() {
     TERN_(HAS_MARLINUI_MENU, return_to_status());
 
     // RED ALERT. RED ALERT.
-    #ifdef LED_BACKLIGHT_TIMEOUT
+    #if ENABLED(PRINTER_EVENT_LEDS)
       leds.set_color(LEDColorRed());
       #ifdef NEOPIXEL_BKGD_INDEX_FIRST
         neo.set_background_color(255, 0, 0, 0);
@@ -883,7 +883,7 @@ void MarlinUI::init() {
     static uint16_t max_display_update_time = 0;
     millis_t ms = millis();
 
-    #if ENABLED(PSU_CONTROL) && defined(LED_BACKLIGHT_TIMEOUT)
+    #if LED_POWEROFF_TIMEOUT > 0
       leds.update_timeout(powerManager.psu_on);
     #endif
 
@@ -1034,7 +1034,7 @@ void MarlinUI::init() {
 
           refresh(LCDVIEW_REDRAW_NOW);
 
-          #if ENABLED(PSU_CONTROL) && defined(LED_BACKLIGHT_TIMEOUT)
+          #if LED_POWEROFF_TIMEOUT > 0
             if (!powerManager.psu_on) leds.reset_timeout(ms);
           #endif
         }
@@ -1699,13 +1699,13 @@ void MarlinUI::init() {
 
     refresh();
 
-    #if HAS_WIRED_LCD || defined(LED_BACKLIGHT_TIMEOUT)
+    #if HAS_WIRED_LCD || LED_POWEROFF_TIMEOUT > 0
       const millis_t ms = millis();
     #endif
 
     TERN_(HAS_WIRED_LCD, next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL); // Delay LCD update for SD activity
 
-    #ifdef LED_BACKLIGHT_TIMEOUT
+    #if LED_POWEROFF_TIMEOUT > 0
       leds.reset_timeout(ms);
     #endif
   }

commit ab46b7e2f298826a5512569d6e79bb59a7a6b8ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 25 15:33:03 2022 -0600

    🧑‍💻 HAS_MARLINUI_MENU, HAS_MANUAL_MOVE_MENU

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 7b9dc468e4..f2fce1c8cd 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -155,7 +155,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   }
 #endif
 
-#if EITHER(HAS_LCD_MENU, EXTENSIBLE_UI)
+#if EITHER(HAS_MARLINUI_MENU, EXTENSIBLE_UI)
   bool MarlinUI::lcd_clicked;
 #endif
 
@@ -257,7 +257,7 @@ void MarlinUI::init() {
   #include "../module/planner.h"
   #include "../module/motion.h"
 
-  #if HAS_LCD_MENU
+  #if HAS_MARLINUI_MENU
     #include "../module/settings.h"
   #endif
 
@@ -348,7 +348,7 @@ void MarlinUI::init() {
 
   #endif
 
-  #if HAS_LCD_MENU
+  #if HAS_MARLINUI_MENU
     #include "menu/menu.h"
 
     screenFunc_t MarlinUI::currentScreen; // Initialized in CTOR
@@ -450,7 +450,7 @@ void MarlinUI::init() {
 
     #endif // !HAS_GRAPHICAL_TFT
 
-  #endif // HAS_LCD_MENU
+  #endif // HAS_MARLINUI_MENU
 
   ////////////////////////////////////////////
   ///////////// Keypad Handling //////////////
@@ -460,7 +460,7 @@ void MarlinUI::init() {
 
     volatile uint8_t MarlinUI::keypad_buttons;
 
-    #if HAS_LCD_MENU && !HAS_ADC_BUTTONS
+    #if HAS_MARLINUI_MENU && !HAS_ADC_BUTTONS
 
       void lcd_move_x();
       void lcd_move_y();
@@ -487,7 +487,7 @@ void MarlinUI::init() {
         if (keypad_buttons) {
           #if HAS_ENCODER_ACTION
             refresh(LCDVIEW_REDRAW_NOW);
-            #if HAS_LCD_MENU
+            #if HAS_MARLINUI_MENU
               if (encoderDirection == -(ENCODERBASE)) { // HAS_ADC_BUTTONS forces REVERSE_MENU_DIRECTION, so this indicates menu navigation
                      if (RRK(EN_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
                 else if (RRK(EN_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
@@ -497,7 +497,7 @@ void MarlinUI::init() {
               else
             #endif
             {
-              #if HAS_LCD_MENU
+              #if HAS_MARLINUI_MENU
                      if (RRK(EN_KEYPAD_UP))     encoderPosition -= epps;
                 else if (RRK(EN_KEYPAD_DOWN))   encoderPosition += epps;
                 else if (RRK(EN_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
@@ -528,7 +528,7 @@ void MarlinUI::init() {
 
           const bool homed = all_axes_homed();
 
-          #if HAS_LCD_MENU
+          #if HAS_MARLINUI_MENU
 
             if (RRK(EN_KEYPAD_MIDDLE))  goto_screen(menu_move);
 
@@ -547,7 +547,7 @@ void MarlinUI::init() {
               if (RRK(EN_KEYPAD_UP))    _reprapworld_keypad_move(Y_AXIS, -1);
             }
 
-          #endif // HAS_LCD_MENU
+          #endif // HAS_MARLINUI_MENU
 
           if (!homed && RRK(EN_KEYPAD_F1)) queue.inject_P(G28_STR);
           return true;
@@ -575,7 +575,7 @@ void MarlinUI::init() {
 
   void MarlinUI::status_screen() {
 
-    TERN_(HAS_LCD_MENU, ENCODER_RATE_MULTIPLY(false));
+    TERN_(HAS_MARLINUI_MENU, ENCODER_RATE_MULTIPLY(false));
 
     #if BASIC_PROGRESS_BAR
 
@@ -619,7 +619,7 @@ void MarlinUI::init() {
 
     #endif // BASIC_PROGRESS_BAR
 
-    #if HAS_LCD_MENU
+    #if HAS_MARLINUI_MENU
       if (use_click()) {
         #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
           next_filament_display = millis() + 5000UL;  // Show status message for 5s
@@ -673,7 +673,7 @@ void MarlinUI::init() {
   void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const lcd_component) {
     init();
     status_printf(1, F(S_FMT ": " S_FMT), FTOP(lcd_error), FTOP(lcd_component));
-    TERN_(HAS_LCD_MENU, return_to_status());
+    TERN_(HAS_MARLINUI_MENU, return_to_status());
 
     // RED ALERT. RED ALERT.
     #ifdef LED_BACKLIGHT_TIMEOUT
@@ -701,7 +701,7 @@ void MarlinUI::init() {
 
   void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
     TERN_(HAS_TOUCH_SLEEP, wakeup_screen()); // Wake up the TFT with most buttons
-    TERN_(HAS_LCD_MENU, refresh());
+    TERN_(HAS_MARLINUI_MENU, refresh());
 
     #if HAS_ENCODER_ACTION
       if (clear_buttons) buttons = 0;
@@ -712,9 +712,9 @@ void MarlinUI::init() {
 
     #if HAS_CHIRP
       chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
-      #if BOTH(HAS_LCD_MENU, USE_BEEPER)
+      #if BOTH(HAS_MARLINUI_MENU, USE_BEEPER)
         for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
-      #elif HAS_LCD_MENU
+      #elif HAS_MARLINUI_MENU
         delay(10);
       #endif
     #endif
@@ -724,7 +724,7 @@ void MarlinUI::init() {
   /////////////// Manual Move ////////////////
   ////////////////////////////////////////////
 
-  #if HAS_LCD_MENU
+  #if HAS_MARLINUI_MENU
 
     ManualMove MarlinUI::manual_move{};
 
@@ -836,7 +836,7 @@ void MarlinUI::init() {
 
     #endif
 
-  #endif // HAS_LCD_MENU
+  #endif // HAS_MARLINUI_MENU
 
   /**
    * Update the LCD, read encoder buttons, etc.
@@ -887,7 +887,7 @@ void MarlinUI::init() {
       leds.update_timeout(powerManager.psu_on);
     #endif
 
-    #if HAS_LCD_MENU
+    #if HAS_MARLINUI_MENU
 
       // Handle any queued Move Axis motion
       manual_move.task();
@@ -942,7 +942,7 @@ void MarlinUI::init() {
         goto_previous_screen();
       }
 
-    #endif // HAS_LCD_MENU
+    #endif // HAS_MARLINUI_MENU
 
     if (ELAPSED(ms, next_lcd_update_ms) || TERN0(HAS_MARLINUI_U8GLIB, drawing_screen)) {
 
@@ -989,7 +989,7 @@ void MarlinUI::init() {
         if (encoderPastThreshold || lcd_clicked) {
           if (encoderPastThreshold && TERN1(IS_TFTGLCD_PANEL, !external_control)) {
 
-            #if BOTH(HAS_LCD_MENU, ENCODER_RATE_MULTIPLIER)
+            #if BOTH(HAS_MARLINUI_MENU, ENCODER_RATE_MULTIPLIER)
 
               int32_t encoderMultiplier = 1;
 
@@ -1049,7 +1049,7 @@ void MarlinUI::init() {
         refresh(LCDVIEW_REDRAW_NOW);
       }
 
-      #if BOTH(HAS_LCD_MENU, SCROLL_LONG_FILENAMES)
+      #if BOTH(HAS_MARLINUI_MENU, SCROLL_LONG_FILENAMES)
         // If scrolling of long file names is enabled and we are in the sd card menu,
         // cause a refresh to occur until all the text has scrolled into view.
         if (currentScreen == menu_media && !lcd_status_update_delay--) {
@@ -1120,7 +1120,7 @@ void MarlinUI::init() {
 
         #endif
 
-        TERN_(HAS_LCD_MENU, lcd_clicked = false);
+        TERN_(HAS_MARLINUI_MENU, lcd_clicked = false);
 
         // Keeping track of the longest time for an individual LCD update.
         // Used to do screen throttling when the planner starts to fill up.
@@ -1334,7 +1334,7 @@ void MarlinUI::init() {
             case ENCODER_PHASE_2: ENCODER_SPIN(ENCODER_PHASE_1, ENCODER_PHASE_3); break;
             case ENCODER_PHASE_3: ENCODER_SPIN(ENCODER_PHASE_2, ENCODER_PHASE_0); break;
           }
-          #if BOTH(HAS_LCD_MENU, AUTO_BED_LEVELING_UBL)
+          #if BOTH(HAS_MARLINUI_MENU, AUTO_BED_LEVELING_UBL)
             external_encoder();
           #endif
           lastEncoderBits = enc;
@@ -1460,7 +1460,7 @@ void MarlinUI::init() {
   void MarlinUI::set_alert_status(FSTR_P const fstr) {
     set_status(fstr, 1);
     TERN_(HAS_TOUCH_SLEEP, wakeup_screen());
-    TERN_(HAS_LCD_MENU, return_to_status());
+    TERN_(HAS_MARLINUI_MENU, return_to_status());
   }
 
   #include <stdarg.h>
@@ -1545,10 +1545,10 @@ void MarlinUI::init() {
     IF_DISABLED(SDSUPPORT, print_job_timer.stop());
     TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_open(PROMPT_INFO, F("UI Aborted"), FPSTR(DISMISS_STR)));
     LCD_MESSAGE(MSG_PRINT_ABORTED);
-    TERN_(HAS_LCD_MENU, return_to_status());
+    TERN_(HAS_MARLINUI_MENU, return_to_status());
   }
 
-  #if BOTH(HAS_LCD_MENU, PSU_CONTROL)
+  #if BOTH(HAS_MARLINUI_MENU, PSU_CONTROL)
 
     void MarlinUI::poweroff() {
       queue.inject(F("M81" TERN_(POWER_OFF_WAIT_FOR_COOLDOWN, "S")));
@@ -1560,11 +1560,11 @@ void MarlinUI::init() {
   void MarlinUI::flow_fault() {
     LCD_ALERTMESSAGE(MSG_FLOWMETER_FAULT);
     TERN_(HAS_BUZZER, buzz(1000, 440));
-    TERN_(HAS_LCD_MENU, return_to_status());
+    TERN_(HAS_MARLINUI_MENU, return_to_status());
   }
 
   void MarlinUI::pause_print() {
-    #if HAS_LCD_MENU
+    #if HAS_MARLINUI_MENU
       synchronize(GET_TEXT(MSG_PAUSING));
       defer_status_screen();
     #endif
@@ -1686,7 +1686,7 @@ void MarlinUI::init() {
           ExtUI::onMediaRemoved();
         #elif PIN_EXISTS(SD_DETECT)
           LCD_MESSAGE(MSG_MEDIA_REMOVED);
-          #if HAS_LCD_MENU
+          #if HAS_MARLINUI_MENU
             if (!defer_return_to_status) return_to_status();
           #endif
         #endif
@@ -1712,7 +1712,7 @@ void MarlinUI::init() {
 
 #endif // SDSUPPORT
 
-#if HAS_LCD_MENU
+#if HAS_MARLINUI_MENU
   void MarlinUI::reset_settings() {
     settings.reset();
     completion_feedback();
@@ -1768,7 +1768,7 @@ void MarlinUI::init() {
 
 #if ENABLED(EEPROM_SETTINGS)
 
-  #if HAS_LCD_MENU
+  #if HAS_MARLINUI_MENU
     void MarlinUI::init_eeprom() {
       const bool good = settings.init_eeprom();
       completion_feedback(good);
@@ -1796,7 +1796,7 @@ void MarlinUI::init() {
     }
 
     void MarlinUI::eeprom_alert(const uint8_t msgid) {
-      #if HAS_LCD_MENU
+      #if HAS_MARLINUI_MENU
         editable.uint8 = msgid;
         goto_screen([]{
           PGM_P const restore_msg = GET_TEXT(MSG_INIT_EEPROM);

commit f6e8622360609d95464d256be5717db090191583
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Sat Jan 22 10:16:41 2022 -0600

    🐛 Fix LCD contrast/brightness init (#23567)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index c068082c09..7b9dc468e4 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -96,8 +96,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 #endif
 
 #if HAS_LCD_CONTRAST
-  uint8_t MarlinUI::contrast; // Initialized by settings.load()
-
+  uint8_t MarlinUI::contrast = LCD_CONTRAST_DEFAULT; // Initialized by settings.load()
   void MarlinUI::set_contrast(const uint8_t value) {
     contrast = constrain(value, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX);
     _set_contrast();

commit d5f2334140e6f8ead29d3648b371547ebe72c7aa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jan 22 10:14:47 2022 -0600

    ♻️ Adjust LCD init, contrast default, settings load

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 2a576f647b..c068082c09 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -43,7 +43,6 @@ MarlinUI ui;
 #if HAS_DISPLAY
   #include "../gcode/queue.h"
   #include "fontutils.h"
-  #include "../sd/cardreader.h"
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
@@ -176,6 +175,77 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
 #endif
 
+// Encoder Handling
+#if HAS_ENCODER_ACTION
+  uint32_t MarlinUI::encoderPosition;
+  volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
+#endif
+
+void MarlinUI::init() {
+
+  init_lcd();
+
+  #if HAS_DIGITAL_BUTTONS
+    #if BUTTON_EXISTS(EN1)
+      SET_INPUT_PULLUP(BTN_EN1);
+    #endif
+    #if BUTTON_EXISTS(EN2)
+      SET_INPUT_PULLUP(BTN_EN2);
+    #endif
+    #if BUTTON_EXISTS(ENC)
+      SET_INPUT_PULLUP(BTN_ENC);
+    #endif
+    #if BUTTON_EXISTS(ENC_EN)
+      SET_INPUT_PULLUP(BTN_ENC_EN);
+    #endif
+    #if BUTTON_EXISTS(BACK)
+      SET_INPUT_PULLUP(BTN_BACK);
+    #endif
+    #if BUTTON_EXISTS(UP)
+      SET_INPUT(BTN_UP);
+    #endif
+    #if BUTTON_EXISTS(DWN)
+      SET_INPUT(BTN_DWN);
+    #endif
+    #if BUTTON_EXISTS(LFT)
+      SET_INPUT(BTN_LFT);
+    #endif
+    #if BUTTON_EXISTS(RT)
+      SET_INPUT(BTN_RT);
+    #endif
+  #endif
+
+  #if HAS_SHIFT_ENCODER
+
+    #if ENABLED(SR_LCD_2W_NL) // Non latching 2 wire shift register
+
+      SET_OUTPUT(SR_DATA_PIN);
+      SET_OUTPUT(SR_CLK_PIN);
+
+    #elif PIN_EXISTS(SHIFT_CLK)
+
+      SET_OUTPUT(SHIFT_CLK_PIN);
+      OUT_WRITE(SHIFT_LD_PIN, HIGH);
+      #if PIN_EXISTS(SHIFT_EN)
+        OUT_WRITE(SHIFT_EN_PIN, LOW);
+      #endif
+      SET_INPUT_PULLUP(SHIFT_OUT_PIN);
+
+    #endif
+
+  #endif // HAS_SHIFT_ENCODER
+
+  #if BOTH(HAS_ENCODER_ACTION, HAS_SLOW_BUTTONS)
+    slow_buttons = 0;
+  #endif
+
+  update_buttons();
+
+  TERN_(HAS_ENCODER_ACTION, encoderDiff = 0);
+
+  reset_status(); // Set welcome message
+}
+
 #if HAS_WIRED_LCD
 
   #if HAS_MARLINUI_U8GLIB
@@ -184,8 +254,6 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
   #include "lcdprint.h"
 
-  #include "../sd/cardreader.h"
-
   #include "../module/temperature.h"
   #include "../module/planner.h"
   #include "../module/motion.h"
@@ -247,16 +315,8 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     bool MarlinUI::old_is_printing;
   #endif
 
-  // Encoder Handling
-  #if HAS_ENCODER_ACTION
-    uint32_t MarlinUI::encoderPosition;
-    volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
-  #endif
-
   #if ENABLED(SDSUPPORT)
 
-    #include "../sd/cardreader.h"
-
     #if MARLINUI_SCROLL_NAME
       uint8_t MarlinUI::filename_scroll_pos, MarlinUI::filename_scroll_max;
     #endif
@@ -393,69 +453,6 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
   #endif // HAS_LCD_MENU
 
-  void MarlinUI::init() {
-
-    init_lcd();
-
-    #if HAS_DIGITAL_BUTTONS
-      #if BUTTON_EXISTS(EN1)
-        SET_INPUT_PULLUP(BTN_EN1);
-      #endif
-      #if BUTTON_EXISTS(EN2)
-        SET_INPUT_PULLUP(BTN_EN2);
-      #endif
-      #if BUTTON_EXISTS(ENC)
-        SET_INPUT_PULLUP(BTN_ENC);
-      #endif
-      #if BUTTON_EXISTS(ENC_EN)
-        SET_INPUT_PULLUP(BTN_ENC_EN);
-      #endif
-      #if BUTTON_EXISTS(BACK)
-        SET_INPUT_PULLUP(BTN_BACK);
-      #endif
-      #if BUTTON_EXISTS(UP)
-        SET_INPUT(BTN_UP);
-      #endif
-      #if BUTTON_EXISTS(DWN)
-        SET_INPUT(BTN_DWN);
-      #endif
-      #if BUTTON_EXISTS(LFT)
-        SET_INPUT(BTN_LFT);
-      #endif
-      #if BUTTON_EXISTS(RT)
-        SET_INPUT(BTN_RT);
-      #endif
-    #endif
-
-    #if HAS_SHIFT_ENCODER
-
-      #if ENABLED(SR_LCD_2W_NL) // Non latching 2 wire shift register
-
-        SET_OUTPUT(SR_DATA_PIN);
-        SET_OUTPUT(SR_CLK_PIN);
-
-      #elif PIN_EXISTS(SHIFT_CLK)
-
-        SET_OUTPUT(SHIFT_CLK_PIN);
-        OUT_WRITE(SHIFT_LD_PIN, HIGH);
-        #if PIN_EXISTS(SHIFT_EN)
-          OUT_WRITE(SHIFT_EN_PIN, LOW);
-        #endif
-        SET_INPUT_PULLUP(SHIFT_OUT_PIN);
-
-      #endif
-
-    #endif // HAS_SHIFT_ENCODER
-
-    #if BOTH(HAS_ENCODER_ACTION, HAS_SLOW_BUTTONS)
-      slow_buttons = 0;
-    #endif
-
-    update_buttons();
-
-    TERN_(HAS_ENCODER_ACTION, encoderDiff = 0);
-  }
-
   ////////////////////////////////////////////
   ///////////// Keypad Handling //////////////
   ////////////////////////////////////////////
@@ -629,9 +626,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
           next_filament_display = millis() + 5000UL;  // Show status message for 5s
         #endif
         goto_screen(menu_main);
-        #if DISABLED(NO_LCD_REINIT)
-          init_lcd(); // May revive the LCD if static electricity killed it
-        #endif
+        IF_DISABLED(NO_LCD_REINIT, init_lcd()); // May revive the LCD if static electricity killed it
         return;
       }
 

commit d8f73997b68da57454471b3b63056ce067cca10b
Author: Taylor Talkington <taylor.talkington@gmail.com>
Date:   Mon Jan 17 08:07:45 2022 -0500

    💄 Improve Ender3 v2 DWIN MarlinUI (#23369)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index d22b11f9bd..2a576f647b 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -244,6 +244,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
   #if IS_DWIN_MARLINUI
     bool MarlinUI::did_first_redraw;
+    bool MarlinUI::old_is_printing;
   #endif
 
   // Encoder Handling

commit 2ded50ba3fcbc6fec77a1697e9e846fcb6c68f66
Author: mistic100 <contact@git.strangeplanet.fr>
Date:   Sat Jan 8 10:51:21 2022 +0100

    🚸 Wait for cooldown in MarlinUI power-off (#23476)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index ab132216c8..d22b11f9bd 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1553,11 +1553,13 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     TERN_(HAS_LCD_MENU, return_to_status());
   }
 
-  #if BOTH(PSU_CONTROL, PS_OFF_CONFIRM)
+  #if BOTH(HAS_LCD_MENU, PSU_CONTROL)
+
     void MarlinUI::poweroff() {
-      queue.inject(F("M81"));
-      goto_previous_screen();
+      queue.inject(F("M81" TERN_(POWER_OFF_WAIT_FOR_COOLDOWN, "S")));
+      return_to_status();
     }
+
   #endif
 
   void MarlinUI::flow_fault() {

commit 224b6e5af9250e92671ad3ee35bb10cd79b819ef
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 10 05:34:16 2022 -0600

    🩹 Fix some logical axis usage

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 7b3e267310..ab132216c8 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -771,7 +771,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
       // Add a manual move to the queue?
       if (axis != NO_AXIS_ENUM && ELAPSED(millis(), start_time) && !planner.is_full()) {
 
-        const feedRate_t fr_mm_s = (axis <= LOGICAL_AXES) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
+        const feedRate_t fr_mm_s = (axis < LOGICAL_AXES) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
 
         #if IS_KINEMATIC
 

commit 13adcd5c08b7065a32f59d00c17c9bc3a351429c
Author: David Ross Smith <5095074+DragRedSim@users.noreply.github.com>
Date:   Fri Jan 7 22:44:44 2022 +1100

    🚑️ Fix preheat target bug
    
    Fixes Jyers/Marlin#1651

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 5cf3e66826..7b3e267310 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -150,10 +150,10 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
   void MarlinUI::apply_preheat(const uint8_t m, const uint8_t pmask, const uint8_t e/*=active_extruder*/) {
     const preheat_t &pre = material_preset[m];
-    TERN_(HAS_HOTEND,           if (TEST(pmask, PM_HOTEND))  thermalManager.setTargetHotend(pre.hotend_temp, e));
-    TERN_(HAS_HEATED_BED,       if (TEST(pmask, PM_BED))     thermalManager.setTargetBed(pre.bed_temp));
-    //TERN_(HAS_HEATED_CHAMBER, if (TEST(pmask, PM_CHAMBER)) thermalManager.setTargetBed(pre.chamber_temp));
-    TERN_(HAS_FAN,              if (TEST(pmask, PM_FAN))     thermalManager.set_fan_speed(0, pre.fan_speed));
+    TERN_(HAS_HOTEND,           if (TEST(pmask, PT_HOTEND))  thermalManager.setTargetHotend(pre.hotend_temp, e));
+    TERN_(HAS_HEATED_BED,       if (TEST(pmask, PT_BED))     thermalManager.setTargetBed(pre.bed_temp));
+    //TERN_(HAS_HEATED_CHAMBER, if (TEST(pmask, PT_CHAMBER)) thermalManager.setTargetBed(pre.chamber_temp));
+    TERN_(HAS_FAN,              if (TEST(pmask, PT_FAN))     thermalManager.set_fan_speed(0, pre.fan_speed));
   }
 #endif
 

commit 7110d11c9d8933c8c412c2fabd3b065a5ab97b6e
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Nov 23 21:01:53 2021 +0100

    ✨ Fan tachometer support (#23086)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 57157d2c00..5cf3e66826 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1566,10 +1566,6 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     TERN_(HAS_LCD_MENU, return_to_status());
   }
 
-  #if ANY(PARK_HEAD_ON_PAUSE, SDSUPPORT)
-    #include "../gcode/queue.h"
-  #endif
-
   void MarlinUI::pause_print() {
     #if HAS_LCD_MENU
       synchronize(GET_TEXT(MSG_PAUSING));

commit b4b16b63ff40aaba9e482294e8f34403eb51e632
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Wed Nov 10 11:31:35 2021 -0500

    🚸 Expose sub-options for E3V2 Enhanced (#23099)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 925e1c1618..57157d2c00 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -49,6 +49,7 @@ MarlinUI ui;
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "e3v2/creality/dwin.h"
 #elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+  #include "fontutils.h"
   #include "e3v2/enhanced/dwin.h"
 #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
   #include "e3v2/jyersui/dwin.h"
@@ -69,7 +70,7 @@ MarlinUI ui;
 constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
 #if HAS_STATUS_MESSAGE
-  #if BOTH(HAS_WIRED_LCD, STATUS_MESSAGE_SCROLLING)
+  #if ENABLED(STATUS_MESSAGE_SCROLLING) && EITHER(HAS_WIRED_LCD, DWIN_CREALITY_LCD_ENHANCED)
     uint8_t MarlinUI::status_scroll_offset; // = 0
   #endif
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
@@ -1481,11 +1482,9 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
   void MarlinUI::finish_status(const bool persist) {
 
-    #if HAS_WIRED_LCD
+    UNUSED(persist);
 
-      #if !(BASIC_PROGRESS_BAR && (PROGRESS_MSG_EXPIRE) > 0)
-        UNUSED(persist);
-      #endif
+    #if HAS_WIRED_LCD
 
       #if BASIC_PROGRESS_BAR || BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
         const millis_t ms = millis();
@@ -1502,13 +1501,15 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
         next_filament_display = ms + 5000UL; // Show status message for 5s
       #endif
 
-      TERN_(STATUS_MESSAGE_SCROLLING, status_scroll_offset = 0);
-    #else // HAS_WIRED_LCD
-      UNUSED(persist);
+    #endif
+
+    #if ENABLED(STATUS_MESSAGE_SCROLLING) && EITHER(HAS_WIRED_LCD, DWIN_CREALITY_LCD_ENHANCED)
+      status_scroll_offset = 0;
     #endif
 
     TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
-    TERN_(HAS_DWIN_E3V2_BASIC, DWIN_StatusChanged(status_message));
+    TERN_(DWIN_CREALITY_LCD, DWIN_StatusChanged(status_message));
+    TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_CheckStatusMessage());
     TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Update_Status(status_message));
   }
 

commit b09038fcc72bc8df4ec8a7014597586e0b0390ca
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 27 20:01:44 2021 -0500

    🎨 Standard material presets behavior

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 2757e6d47a..925e1c1618 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -135,7 +135,10 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 #endif
 
 #if HAS_PREHEAT
+  #include "../module/temperature.h"
+
   preheat_t MarlinUI::material_preset[PREHEAT_COUNT];  // Initialized by settings.load()
+
   PGM_P MarlinUI::get_preheat_label(const uint8_t m) {
     #define _PDEF(N) static PGMSTR(preheat_##N##_label, PREHEAT_##N##_LABEL);
     #define _PLBL(N) preheat_##N##_label,
@@ -143,6 +146,14 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     static PGM_P const preheat_labels[PREHEAT_COUNT] PROGMEM = { REPEAT_1(PREHEAT_COUNT, _PLBL) };
     return (PGM_P)pgm_read_ptr(&preheat_labels[m]);
   }
+
+  void MarlinUI::apply_preheat(const uint8_t m, const uint8_t pmask, const uint8_t e/*=active_extruder*/) {
+    const preheat_t &pre = material_preset[m];
+    TERN_(HAS_HOTEND,           if (TEST(pmask, PM_HOTEND))  thermalManager.setTargetHotend(pre.hotend_temp, e));
+    TERN_(HAS_HEATED_BED,       if (TEST(pmask, PM_BED))     thermalManager.setTargetBed(pre.bed_temp));
+    //TERN_(HAS_HEATED_CHAMBER, if (TEST(pmask, PM_CHAMBER)) thermalManager.setTargetBed(pre.chamber_temp));
+    TERN_(HAS_FAN,              if (TEST(pmask, PM_FAN))     thermalManager.set_fan_speed(0, pre.fan_speed));
+  }
 #endif
 
 #if EITHER(HAS_LCD_MENU, EXTENSIBLE_UI)

commit 1d80464ba77bc576426f15af28a633bf48d769ad
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 27 21:15:58 2021 -0500

    🎨 Define HAS_PREHEAT conditional

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index ae169cdab6..2757e6d47a 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -134,7 +134,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   }
 #endif
 
-#if PREHEAT_COUNT
+#if HAS_PREHEAT
   preheat_t MarlinUI::material_preset[PREHEAT_COUNT];  // Initialized by settings.load()
   PGM_P MarlinUI::get_preheat_label(const uint8_t m) {
     #define _PDEF(N) static PGMSTR(preheat_##N##_label, PREHEAT_##N##_LABEL);

commit ee28a14e8e7f6b33fe5813dbedcd85380207c345
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 15 00:24:08 2021 -0500

    🎨 Refactor Host Actions as singleton

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 83be7fd1a8..ae169cdab6 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1355,7 +1355,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   void MarlinUI::set_status(const char * const cstr, const bool persist) {
     if (alert_level) return;
 
-    TERN_(HOST_PROMPT_SUPPORT, host_action_notify(cstr));
+    TERN_(HOST_PROMPT_SUPPORT, hostui.notify(cstr));
 
     // Here we have a problem. The message is encoded in UTF8, so
     // arbitrarily cutting it will be a problem. We MUST be sure
@@ -1427,7 +1427,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     if (level < alert_level) return;
     alert_level = level;
 
-    TERN_(HOST_PROMPT_SUPPORT, host_action_notify(fstr));
+    TERN_(HOST_PROMPT_SUPPORT, hostui.notify(fstr));
 
     // Since the message is encoded in UTF8 it must
     // only be cut on a character boundary.
@@ -1533,10 +1533,10 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
       card.abortFilePrintSoon();
     #endif
     #ifdef ACTION_ON_CANCEL
-      host_action_cancel();
+      hostui.cancel();
     #endif
     IF_DISABLED(SDSUPPORT, print_job_timer.stop());
-    TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_INFO, F("UI Aborted"), FPSTR(DISMISS_STR)));
+    TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_open(PROMPT_INFO, F("UI Aborted"), FPSTR(DISMISS_STR)));
     LCD_MESSAGE(MSG_PRINT_ABORTED);
     TERN_(HAS_LCD_MENU, return_to_status());
   }
@@ -1565,7 +1565,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     #endif
 
     TERN_(HAS_TOUCH_SLEEP, wakeup_screen());
-    TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_PAUSE_RESUME, F("UI Pause"), F("Resume")));
+    TERN_(HOST_PROMPT_SUPPORT, hostui.prompt_open(PROMPT_PAUSE_RESUME, F("UI Pause"), F("Resume")));
 
     LCD_MESSAGE(MSG_PRINT_PAUSED);
 
@@ -1575,7 +1575,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     #elif ENABLED(SDSUPPORT)
       queue.inject(F("M25"));
     #elif defined(ACTION_ON_PAUSE)
-      host_action_pause();
+      hostui.pause();
     #endif
   }
 
@@ -1584,7 +1584,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     TERN_(PARK_HEAD_ON_PAUSE, wait_for_heatup = wait_for_user = false);
     TERN_(SDSUPPORT, if (IS_SD_PAUSED()) queue.inject_P(M24_STR));
     #ifdef ACTION_ON_RESUME
-      host_action_resume();
+      hostui.resume();
     #endif
     print_job_timer.start(); // Also called by M24
   }
@@ -1639,13 +1639,13 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   // Send the status line as a host notification
   //
   void MarlinUI::set_status(const char * const cstr, const bool) {
-    TERN(HOST_PROMPT_SUPPORT, host_action_notify(cstr), UNUSED(cstr));
+    TERN(HOST_PROMPT_SUPPORT, hostui.notify(cstr), UNUSED(cstr));
   }
   void MarlinUI::set_status(FSTR_P const fstr, const int8_t) {
-    TERN(HOST_PROMPT_SUPPORT, host_action_notify(fstr), UNUSED(fstr));
+    TERN(HOST_PROMPT_SUPPORT, hostui.notify(fstr), UNUSED(fstr));
   }
   void MarlinUI::status_printf(const uint8_t, FSTR_P const fstr, ...) {
-    TERN(HOST_PROMPT_SUPPORT, host_action_notify(fstr), UNUSED(fstr));
+    TERN(HOST_PROMPT_SUPPORT, hostui.notify(fstr), UNUSED(fstr));
   }
 
 #endif // !HAS_DISPLAY && !HAS_STATUS_MESSAGE

commit 2d08afe456255d47e6cd244c49c7cd243f74c53a
Author: Sebastien Andrivet <sebastien@andrivet.com>
Date:   Mon Oct 4 08:06:49 2021 +0200

    🐛 Fix ExtUI Pause messages (#22874)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index fd805d2df1..83be7fd1a8 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1741,19 +1741,20 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     pause_mode = mode;
     ExtUI::pauseModeStatus = message;
     switch (message) {
-      case PAUSE_MESSAGE_PARKING:  ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING));
-      case PAUSE_MESSAGE_CHANGING: ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT));
-      case PAUSE_MESSAGE_UNLOAD:   ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD));
-      case PAUSE_MESSAGE_WAITING:  ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING));
-      case PAUSE_MESSAGE_INSERT:   ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_INSERT));
-      case PAUSE_MESSAGE_LOAD:     ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_LOAD));
+      case PAUSE_MESSAGE_PARKING:  ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING)); break;
+      case PAUSE_MESSAGE_CHANGING: ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT)); break;
+      case PAUSE_MESSAGE_UNLOAD:   ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD)); break;
+      case PAUSE_MESSAGE_WAITING:  ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING)); break;
+      case PAUSE_MESSAGE_INSERT:   ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_INSERT)); break;
+      case PAUSE_MESSAGE_LOAD:     ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_LOAD)); break;
       case PAUSE_MESSAGE_PURGE:
         ExtUI::onUserConfirmRequired(GET_TEXT_F(TERN(ADVANCED_PAUSE_CONTINUOUS_PURGE, MSG_FILAMENT_CHANGE_CONT_PURGE, MSG_FILAMENT_CHANGE_PURGE)));
-      case PAUSE_MESSAGE_RESUME:   ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_RESUME));
-      case PAUSE_MESSAGE_HEAT:     ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT));
-      case PAUSE_MESSAGE_HEATING:  ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEATING));
-      case PAUSE_MESSAGE_OPTION:   ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_OPTION_HEADER));
-      case PAUSE_MESSAGE_STATUS:
+        break;
+      case PAUSE_MESSAGE_RESUME:   ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_RESUME)); break;
+      case PAUSE_MESSAGE_HEAT:     ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT)); break;
+      case PAUSE_MESSAGE_HEATING:  ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEATING)); break;
+      case PAUSE_MESSAGE_OPTION:   ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_OPTION_HEADER)); break;
+      case PAUSE_MESSAGE_STATUS:   break;
       default: break;
     }
   }

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    🎨 Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 1fec14228b..fd805d2df1 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -663,9 +663,9 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     draw_status_screen();
   }
 
-  void MarlinUI::kill_screen(PGM_P lcd_error, PGM_P lcd_component) {
+  void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const lcd_component) {
     init();
-    status_printf(1, F(S_FMT ": " S_FMT), lcd_error, lcd_component);
+    status_printf(1, F(S_FMT ": " S_FMT), FTOP(lcd_error), FTOP(lcd_component));
     TERN_(HAS_LCD_MENU, return_to_status());
 
     // RED ALERT. RED ALERT.

commit 12b5d997a2cee538e5026a68f8e0cfdd53248986
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 25 22:11:48 2021 -0500

    🎨 Apply F() to some ExtUI functions

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index c18a7d46f4..1fec14228b 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1741,18 +1741,18 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     pause_mode = mode;
     ExtUI::pauseModeStatus = message;
     switch (message) {
-      case PAUSE_MESSAGE_PARKING:  ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_PAUSE_PRINT_PARKING));
-      case PAUSE_MESSAGE_CHANGING: ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_INIT));
-      case PAUSE_MESSAGE_UNLOAD:   ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_UNLOAD));
-      case PAUSE_MESSAGE_WAITING:  ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_ADVANCED_PAUSE_WAITING));
-      case PAUSE_MESSAGE_INSERT:   ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_INSERT));
-      case PAUSE_MESSAGE_LOAD:     ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_LOAD));
+      case PAUSE_MESSAGE_PARKING:  ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING));
+      case PAUSE_MESSAGE_CHANGING: ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT));
+      case PAUSE_MESSAGE_UNLOAD:   ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD));
+      case PAUSE_MESSAGE_WAITING:  ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING));
+      case PAUSE_MESSAGE_INSERT:   ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_INSERT));
+      case PAUSE_MESSAGE_LOAD:     ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_LOAD));
       case PAUSE_MESSAGE_PURGE:
-        ExtUI::onUserConfirmRequired_P(GET_TEXT(TERN(ADVANCED_PAUSE_CONTINUOUS_PURGE, MSG_FILAMENT_CHANGE_CONT_PURGE, MSG_FILAMENT_CHANGE_PURGE)));
-      case PAUSE_MESSAGE_RESUME:   ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_RESUME));
-      case PAUSE_MESSAGE_HEAT:     ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_HEAT));
-      case PAUSE_MESSAGE_HEATING:  ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_HEATING));
-      case PAUSE_MESSAGE_OPTION:   ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_OPTION_HEADER));
+        ExtUI::onUserConfirmRequired(GET_TEXT_F(TERN(ADVANCED_PAUSE_CONTINUOUS_PURGE, MSG_FILAMENT_CHANGE_CONT_PURGE, MSG_FILAMENT_CHANGE_PURGE)));
+      case PAUSE_MESSAGE_RESUME:   ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_RESUME));
+      case PAUSE_MESSAGE_HEAT:     ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT));
+      case PAUSE_MESSAGE_HEATING:  ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEATING));
+      case PAUSE_MESSAGE_OPTION:   ExtUI::onUserConfirmRequired(GET_TEXT_F(MSG_FILAMENT_CHANGE_OPTION_HEADER));
       case PAUSE_MESSAGE_STATUS:
       default: break;
     }

commit 008bf1bcaef181cd1b74638692e2465bb9e07a4d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 11:55:08 2021 -0500

    🎨 Apply F() to Host Actions strings

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 66e2556b20..c18a7d46f4 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1352,28 +1352,28 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
   bool MarlinUI::has_status() { return (status_message[0] != '\0'); }
 
-  void MarlinUI::set_status(const char * const message, const bool persist) {
+  void MarlinUI::set_status(const char * const cstr, const bool persist) {
     if (alert_level) return;
 
-    TERN_(HOST_PROMPT_SUPPORT, host_action_notify(message));
+    TERN_(HOST_PROMPT_SUPPORT, host_action_notify(cstr));
 
     // Here we have a problem. The message is encoded in UTF8, so
     // arbitrarily cutting it will be a problem. We MUST be sure
     // that there is no cutting in the middle of a multibyte character!
 
     // Get a pointer to the null terminator
-    const char* pend = message + strlen(message);
+    const char* pend = cstr + strlen(cstr);
 
     //  If length of supplied UTF8 string is greater than
     // our buffer size, start cutting whole UTF8 chars
-    while ((pend - message) > MAX_MESSAGE_LENGTH) {
+    while ((pend - cstr) > MAX_MESSAGE_LENGTH) {
       --pend;
       while (!START_OF_UTF8_CHAR(*pend)) --pend;
     };
 
     // At this point, we have the proper cut point. Use it
-    uint8_t maxLen = pend - message;
-    strncpy(status_message, message, maxLen);
+    uint8_t maxLen = pend - cstr;
+    strncpy(status_message, cstr, maxLen);
     status_message[maxLen] = '\0';
 
     finish_status(persist);
@@ -1427,7 +1427,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     if (level < alert_level) return;
     alert_level = level;
 
-    TERN_(HOST_PROMPT_SUPPORT, host_action_notify_P(pstr));
+    TERN_(HOST_PROMPT_SUPPORT, host_action_notify(fstr));
 
     // Since the message is encoded in UTF8 it must
     // only be cut on a character boundary.
@@ -1536,7 +1536,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
       host_action_cancel();
     #endif
     IF_DISABLED(SDSUPPORT, print_job_timer.stop());
-    TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_INFO, PSTR("UI Aborted"), DISMISS_STR));
+    TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_INFO, F("UI Aborted"), FPSTR(DISMISS_STR)));
     LCD_MESSAGE(MSG_PRINT_ABORTED);
     TERN_(HAS_LCD_MENU, return_to_status());
   }
@@ -1565,7 +1565,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     #endif
 
     TERN_(HAS_TOUCH_SLEEP, wakeup_screen());
-    TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume")));
+    TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_PAUSE_RESUME, F("UI Pause"), F("Resume")));
 
     LCD_MESSAGE(MSG_PRINT_PAUSED);
 
@@ -1642,10 +1642,10 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     TERN(HOST_PROMPT_SUPPORT, host_action_notify(cstr), UNUSED(cstr));
   }
   void MarlinUI::set_status(FSTR_P const fstr, const int8_t) {
-    TERN(HOST_PROMPT_SUPPORT, host_action_notify_P(FTOP(fstr)), UNUSED(fstr));
+    TERN(HOST_PROMPT_SUPPORT, host_action_notify(fstr), UNUSED(fstr));
   }
   void MarlinUI::status_printf(const uint8_t, FSTR_P const fstr, ...) {
-    TERN(HOST_PROMPT_SUPPORT, host_action_notify_P(FPSTR(fstr)), UNUSED(fstr));
+    TERN(HOST_PROMPT_SUPPORT, host_action_notify(fstr), UNUSED(fstr));
   }
 
 #endif // !HAS_DISPLAY && !HAS_STATUS_MESSAGE

commit 7f1286a11f87065c4e666985e679cf9c77d668bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 17:05:11 2021 -0500

    🎨 Apply F() to status message

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index c8384fce31..66e2556b20 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -665,7 +665,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
   void MarlinUI::kill_screen(PGM_P lcd_error, PGM_P lcd_component) {
     init();
-    status_printf_P(1, PSTR(S_FMT ": " S_FMT), lcd_error, lcd_component);
+    status_printf(1, F(S_FMT ": " S_FMT), lcd_error, lcd_component);
     TERN_(HAS_LCD_MENU, return_to_status());
 
     // RED ALERT. RED ALERT.
@@ -1393,76 +1393,77 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     #if SERVICE_INTERVAL_3 > 0
       static PGMSTR(service3, "> " SERVICE_NAME_3 "!");
     #endif
-    PGM_P msg;
+    FSTR_P msg;
     if (printingIsPaused())
-      msg = GET_TEXT(MSG_PRINT_PAUSED);
+      msg = GET_TEXT_F(MSG_PRINT_PAUSED);
     #if ENABLED(SDSUPPORT)
       else if (IS_SD_PRINTING())
         return set_status(card.longest_filename(), true);
     #endif
     else if (print_job_timer.isRunning())
-      msg = GET_TEXT(MSG_PRINTING);
+      msg = GET_TEXT_F(MSG_PRINTING);
 
     #if SERVICE_INTERVAL_1 > 0
-      else if (print_job_timer.needsService(1)) msg = service1;
+      else if (print_job_timer.needsService(1)) msg = FPSTR(service1);
     #endif
     #if SERVICE_INTERVAL_2 > 0
-      else if (print_job_timer.needsService(2)) msg = service2;
+      else if (print_job_timer.needsService(2)) msg = FPSTR(service2);
     #endif
     #if SERVICE_INTERVAL_3 > 0
-      else if (print_job_timer.needsService(3)) msg = service3;
+      else if (print_job_timer.needsService(3)) msg = FPSTR(service3);
     #endif
 
     else if (!no_welcome)
-      msg = GET_TEXT(WELCOME_MSG);
+      msg = GET_TEXT_F(WELCOME_MSG);
     else
       return;
 
-    set_status_P(msg, -1);
+    set_status(msg, -1);
   }
 
-  void MarlinUI::set_status_P(PGM_P const message, int8_t level) {
+  void MarlinUI::set_status(FSTR_P const fstr, int8_t level) {
+    PGM_P const pstr = FTOP(fstr);
     if (level < 0) level = alert_level = 0;
     if (level < alert_level) return;
     alert_level = level;
 
-    TERN_(HOST_PROMPT_SUPPORT, host_action_notify_P(message));
+    TERN_(HOST_PROMPT_SUPPORT, host_action_notify_P(pstr));
 
     // Since the message is encoded in UTF8 it must
     // only be cut on a character boundary.
 
     // Get a pointer to the null terminator
-    PGM_P pend = message + strlen_P(message);
+    PGM_P pend = pstr + strlen_P(pstr);
 
     // If length of supplied UTF8 string is greater than
     // the buffer size, start cutting whole UTF8 chars
-    while ((pend - message) > MAX_MESSAGE_LENGTH) {
+    while ((pend - pstr) > MAX_MESSAGE_LENGTH) {
       --pend;
       while (!START_OF_UTF8_CHAR(pgm_read_byte(pend))) --pend;
     };
 
     // At this point, we have the proper cut point. Use it
-    uint8_t maxLen = pend - message;
-    strncpy_P(status_message, message, maxLen);
+    uint8_t maxLen = pend - pstr;
+    strncpy_P(status_message, pstr, maxLen);
     status_message[maxLen] = '\0';
 
     finish_status(level > 0);
   }
 
-  void MarlinUI::set_alert_status_P(PGM_P const message) {
-    set_status_P(message, 1);
+  void MarlinUI::set_alert_status(FSTR_P const fstr) {
+    set_status(fstr, 1);
     TERN_(HAS_TOUCH_SLEEP, wakeup_screen());
     TERN_(HAS_LCD_MENU, return_to_status());
   }
 
   #include <stdarg.h>
 
-  void MarlinUI::status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
+  void MarlinUI::status_printf(const uint8_t level, FSTR_P const fmt, ...) {
     if (level < alert_level) return;
     alert_level = level;
     va_list args;
-    va_start(args, fmt);
-    vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
+    va_start(args, FTOP(fmt));
+    vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, FTOP(fmt), args);
     va_end(args);
     finish_status(level > 0);
   }
@@ -1536,7 +1537,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     #endif
     IF_DISABLED(SDSUPPORT, print_job_timer.stop());
     TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_INFO, PSTR("UI Aborted"), DISMISS_STR));
-    LCD_MESSAGEPGM(MSG_PRINT_ABORTED);
+    LCD_MESSAGE(MSG_PRINT_ABORTED);
     TERN_(HAS_LCD_MENU, return_to_status());
   }
 
@@ -1548,7 +1549,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   #endif
 
   void MarlinUI::flow_fault() {
-    LCD_ALERTMESSAGEPGM(MSG_FLOWMETER_FAULT);
+    LCD_ALERTMESSAGE(MSG_FLOWMETER_FAULT);
     TERN_(HAS_BUZZER, buzz(1000, 440));
     TERN_(HAS_LCD_MENU, return_to_status());
   }
@@ -1566,7 +1567,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     TERN_(HAS_TOUCH_SLEEP, wakeup_screen());
     TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume")));
 
-    LCD_MESSAGEPGM(MSG_PRINT_PAUSED);
+    LCD_MESSAGE(MSG_PRINT_PAUSED);
 
     #if ENABLED(PARK_HEAD_ON_PAUSE)
       pause_show_message(PAUSE_MESSAGE_PARKING, PAUSE_MODE_PAUSE_PRINT); // Show message immediately to let user know about pause in progress
@@ -1637,14 +1638,14 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   //
   // Send the status line as a host notification
   //
-  void MarlinUI::set_status(const char * const message, const bool) {
-    TERN(HOST_PROMPT_SUPPORT, host_action_notify(message), UNUSED(message));
+  void MarlinUI::set_status(const char * const cstr, const bool) {
+    TERN(HOST_PROMPT_SUPPORT, host_action_notify(cstr), UNUSED(cstr));
   }
-  void MarlinUI::set_status_P(PGM_P message, const int8_t) {
-    TERN(HOST_PROMPT_SUPPORT, host_action_notify_P(message), UNUSED(message));
+  void MarlinUI::set_status(FSTR_P const fstr, const int8_t) {
+    TERN(HOST_PROMPT_SUPPORT, host_action_notify_P(FTOP(fstr)), UNUSED(fstr));
   }
-  void MarlinUI::status_printf_P(const uint8_t, PGM_P const message, ...) {
-    TERN(HOST_PROMPT_SUPPORT, host_action_notify_P(message), UNUSED(message));
+  void MarlinUI::status_printf(const uint8_t, FSTR_P const fstr, ...) {
+    TERN(HOST_PROMPT_SUPPORT, host_action_notify_P(FPSTR(fstr)), UNUSED(fstr));
   }
 
 #endif // !HAS_DISPLAY && !HAS_STATUS_MESSAGE
@@ -1670,7 +1671,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
           quick_feedback();
           goto_screen(MEDIA_MENU_GATEWAY);
         #else
-          LCD_MESSAGEPGM(MSG_MEDIA_INSERTED);
+          LCD_MESSAGE(MSG_MEDIA_INSERTED);
         #endif
       }
     }
@@ -1679,7 +1680,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
         #if ENABLED(EXTENSIBLE_UI)
           ExtUI::onMediaRemoved();
         #elif PIN_EXISTS(SD_DETECT)
-          LCD_MESSAGEPGM(MSG_MEDIA_REMOVED);
+          LCD_MESSAGE(MSG_MEDIA_REMOVED);
           #if HAS_LCD_MENU
             if (!defer_return_to_status) return_to_status();
           #endif
@@ -1802,7 +1803,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
           );
         });
       #else
-        set_status_P(eeprom_err(msgid));
+        set_status(FPSTR(eeprom_err(msgid)));
       #endif
     }
 

commit 417e2530ebc5b6c74ac34adaba8be552b407383a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 21:11:31 2021 -0500

    🎨 Apply F() to G-code suite and queue

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 14d0e182c0..c8384fce31 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1542,7 +1542,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
   #if BOTH(PSU_CONTROL, PS_OFF_CONFIRM)
     void MarlinUI::poweroff() {
-      queue.inject_P(PSTR("M81"));
+      queue.inject(F("M81"));
       goto_previous_screen();
     }
   #endif
@@ -1570,9 +1570,9 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
     #if ENABLED(PARK_HEAD_ON_PAUSE)
       pause_show_message(PAUSE_MESSAGE_PARKING, PAUSE_MODE_PAUSE_PRINT); // Show message immediately to let user know about pause in progress
-      queue.inject_P(PSTR("M25 P\nM24"));
+      queue.inject(F("M25 P\nM24"));
     #elif ENABLED(SDSUPPORT)
-      queue.inject_P(PSTR("M25"));
+      queue.inject(F("M25"));
     #elif defined(ACTION_ON_PAUSE)
       host_action_pause();
     #endif

commit eb784d6e55c84c05b2a5353899d8bc25276e0640
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 2 02:33:14 2021 -0500

    🎨 Rename MarlinUI::zoffset_overlay

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 5fcbff870e..14d0e182c0 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1714,6 +1714,20 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
       if (touch_calibration.need_calibration()) ui.goto_screen(touch_screen_calibration);
     #endif
   }
+
+  #if EITHER(BABYSTEP_ZPROBE_GFX_OVERLAY, MESH_EDIT_GFX_OVERLAY)
+    void MarlinUI::zoffset_overlay(const_float_t zvalue) {
+      // Determine whether the user is raising or lowering the nozzle.
+      static int8_t dir;
+      static float old_zvalue;
+      if (zvalue != old_zvalue) {
+        dir = zvalue ? zvalue < old_zvalue ? -1 : 1 : 0;
+        old_zvalue = zvalue;
+      }
+      zoffset_overlay(dir);
+    }
+  #endif
+
 #endif
 
 #if BOTH(EXTENSIBLE_UI, ADVANCED_PAUSE_FEATURE)

commit 1ac7a56a823b5012250dd7259a9a7a46d3bfcde5
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Sat Sep 25 05:59:43 2021 -0500

    🐛 E3V2 Brightness followup (#22821)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 2a6a320889..5fcbff870e 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -95,16 +95,23 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   }
 #endif
 
+#if HAS_LCD_CONTRAST
+  uint8_t MarlinUI::contrast; // Initialized by settings.load()
+
+  void MarlinUI::set_contrast(const uint8_t value) {
+    contrast = constrain(value, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX);
+    _set_contrast();
+  }
+#endif
+
 #if HAS_LCD_BRIGHTNESS
   uint8_t MarlinUI::brightness = DEFAULT_LCD_BRIGHTNESS;
   bool MarlinUI::backlight = true;
 
   void MarlinUI::set_brightness(const uint8_t value) {
     backlight = !!value;
-    if (backlight) brightness = constrain(value, MIN_LCD_BRIGHTNESS, MAX_LCD_BRIGHTNESS);
-    // Set brightness on enabled LCD here
-    TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_LCD_Brightness(brightness));
-    TERN_(DWIN_CREALITY_LCD_JYERSUI, DWIN_LCD_Brightness(backlight ? brightness : 0));
+    if (backlight) brightness = constrain(value, LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX);
+    _set_brightness();
   }
 #endif
 

commit 58301837e0a1ea0d682d23e0510619bd85841d5c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 20 18:44:35 2021 -0500

    🩹 Remove extra #include, misc. style

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index b1cb030025..2a6a320889 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1483,9 +1483,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
         next_filament_display = ms + 5000UL; // Show status message for 5s
       #endif
 
-      #if ENABLED(STATUS_MESSAGE_SCROLLING)
-        status_scroll_offset = 0;
-      #endif
+      TERN_(STATUS_MESSAGE_SCROLLING, status_scroll_offset = 0);
     #else // HAS_WIRED_LCD
       UNUSED(persist);
     #endif

commit 89125cd32ea913152dcdfe0edfa1571027f44e2d
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sun Sep 19 01:27:58 2021 +0200

    🚸 Wake up TFT for some events (#22788)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 369413d3a6..b1cb030025 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1444,6 +1444,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
   void MarlinUI::set_alert_status_P(PGM_P const message) {
     set_status_P(message, 1);
+    TERN_(HAS_TOUCH_SLEEP, wakeup_screen());
     TERN_(HAS_LCD_MENU, return_to_status());
   }
 
@@ -1557,6 +1558,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
       defer_status_screen();
     #endif
 
+    TERN_(HAS_TOUCH_SLEEP, wakeup_screen());
     TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume")));
 
     LCD_MESSAGEPGM(MSG_PRINT_PAUSED);

commit 08a40c43750eb49521849792520d8d819c0fcd29
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Sep 16 03:46:16 2021 -0400

    ✨ Improve pause/filament change for ExtUI (#22655)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 0fb6902e80..369413d3a6 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1716,9 +1716,8 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     const PauseMode mode/*=PAUSE_MODE_SAME*/,
     const uint8_t extruder/*=active_extruder*/
   ) {
-    if (mode == PAUSE_MODE_SAME)
-      return;
     pause_mode = mode;
+    ExtUI::pauseModeStatus = message;
     switch (message) {
       case PAUSE_MESSAGE_PARKING:  ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_PAUSE_PRINT_PARKING));
       case PAUSE_MESSAGE_CHANGING: ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_INIT));
@@ -1727,11 +1726,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
       case PAUSE_MESSAGE_INSERT:   ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_INSERT));
       case PAUSE_MESSAGE_LOAD:     ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_LOAD));
       case PAUSE_MESSAGE_PURGE:
-        #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
-          ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_CONT_PURGE));
-        #else
-          ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_PURGE));
-        #endif
+        ExtUI::onUserConfirmRequired_P(GET_TEXT(TERN(ADVANCED_PAUSE_CONTINUOUS_PURGE, MSG_FILAMENT_CHANGE_CONT_PURGE, MSG_FILAMENT_CHANGE_PURGE)));
       case PAUSE_MESSAGE_RESUME:   ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_RESUME));
       case PAUSE_MESSAGE_HEAT:     ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_HEAT));
       case PAUSE_MESSAGE_HEATING:  ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_HEATING));

commit 5b5a8798f8fe202e86c008088f847a3edb51cc71
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Sep 15 19:48:29 2021 -0500

    🎨 Consolidate Ender-3 V2 DWIN common code (#22778)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 40f815a3e7..0fb6902e80 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -104,7 +104,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     if (backlight) brightness = constrain(value, MIN_LCD_BRIGHTNESS, MAX_LCD_BRIGHTNESS);
     // Set brightness on enabled LCD here
     TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_LCD_Brightness(brightness));
-    TERN_(DWIN_CREALITY_LCD_JYERSUI, DWIN_Backlight_SetLuminance(backlight ? brightness : 0));
+    TERN_(DWIN_CREALITY_LCD_JYERSUI, DWIN_LCD_Brightness(backlight ? brightness : 0));
   }
 #endif
 

commit c2e4b1626f0cce82a55e8de9dc98ed9381e1d9ad
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Tue Sep 14 04:07:08 2021 +0200

    ✨ TFT Screen/Backlight Sleep (#22617)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 5e5b7a94bc..40f815a3e7 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -673,8 +673,20 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     draw_kill_screen();
   }
 
-  void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
+  #if HAS_TOUCH_SLEEP
+    #if HAS_TOUCH_BUTTONS
+      #include "touch/touch_buttons.h"
+    #else
+      #include "tft/touch.h"
+    #endif
+    // Wake up a sleeping TFT
+    void MarlinUI::wakeup_screen() {
+      TERN(HAS_TOUCH_BUTTONS, touchBt.wakeUp(), touch.wakeUp());
+    }
+  #endif
 
+  void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
+    TERN_(HAS_TOUCH_SLEEP, wakeup_screen()); // Wake up the TFT with most buttons
     TERN_(HAS_LCD_MENU, refresh());
 
     #if HAS_ENCODER_ACTION
@@ -926,7 +938,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
         if (on_status_screen()) next_lcd_update_ms += (LCD_UPDATE_INTERVAL) * 2;
 
-        TERN_(HAS_ENCODER_ACTION, touch_buttons = touch.read_buttons());
+        TERN_(HAS_ENCODER_ACTION, touch_buttons = touchBt.read_buttons());
 
       #endif
 
@@ -955,6 +967,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
             abs_diff = epps;                                            // Treat as a full step size
             encoderDiff = (encoderDiff < 0 ? -1 : 1) * abs_diff;        // ...in the spin direction.
           }
+          TERN_(HAS_TOUCH_SLEEP, if (lastEncoderDiff != encoderDiff) wakeup_screen());
           lastEncoderDiff = encoderDiff;
         #endif
 

commit d69c053225bab92bf53bec064a1830079a2092f9
Author: Vert <45634861+Vertabreak@users.noreply.github.com>
Date:   Sun Sep 12 22:39:52 2021 -0400

    🐛 Fix ENABLED => EITHER typo (#22756)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 67ad99ba2b..5e5b7a94bc 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -32,7 +32,7 @@
   #include "../feature/host_actions.h"
 #endif
 
-#if ENABLED(BROWSE_MEDIA_ON_INSERT, PASSWORD_ON_SD_PRINT_MENU)
+#if BOTH(BROWSE_MEDIA_ON_INSERT, PASSWORD_ON_SD_PRINT_MENU)
   #include "../feature/password/password.h"
 #endif
 

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    🎨 Fewer serial macros

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 8c59500574..67ad99ba2b 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -778,7 +778,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
             TERN_(MULTI_E_MANUAL, axis == E_AXIS ? e_index :) active_extruder
           );
 
-          //SERIAL_ECHOLNPAIR("Add planner.move with Axis ", AS_CHAR(axis_codes[axis]), " at FR ", fr_mm_s);
+          //SERIAL_ECHOLNPGM("Add planner.move with Axis ", AS_CHAR(axis_codes[axis]), " at FR ", fr_mm_s);
 
           axis = NO_AXIS_ENUM;
 
@@ -795,7 +795,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
       TERN_(MULTI_E_MANUAL, if (move_axis == E_AXIS) e_index = eindex);
       start_time = millis() + (menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
       axis = move_axis;
-      //SERIAL_ECHOLNPAIR("Post Move with Axis ", AS_CHAR(axis_codes[axis]), " soon.");
+      //SERIAL_ECHOLNPGM("Post Move with Axis ", AS_CHAR(axis_codes[axis]), " soon.");
     }
 
     #if ENABLED(AUTO_BED_LEVELING_UBL)
@@ -981,10 +981,10 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
                   //#define ENCODER_RATE_MULTIPLIER_DEBUG
                   #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
                     SERIAL_ECHO_START();
-                    SERIAL_ECHOPAIR("Enc Step Rate: ", encoderStepRate);
-                    SERIAL_ECHOPAIR("  Multiplier: ", encoderMultiplier);
-                    SERIAL_ECHOPAIR("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
-                    SERIAL_ECHOPAIR("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
+                    SERIAL_ECHOPGM("Enc Step Rate: ", encoderStepRate);
+                    SERIAL_ECHOPGM("  Multiplier: ", encoderMultiplier);
+                    SERIAL_ECHOPGM("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
+                    SERIAL_ECHOPGM("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
                     SERIAL_EOL();
                   #endif
                 }

commit 0f61d9e4dd4d4e4f27e5c688ab2c5dbd0f03af84
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Tue Sep 7 02:15:24 2021 -0500

    ✨ Ender-3 V2 CrealityUI Enhanced (#21942)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 51cbf4534f..8c59500574 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -48,6 +48,8 @@ MarlinUI ui;
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "e3v2/creality/dwin.h"
+#elif ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+  #include "e3v2/enhanced/dwin.h"
 #elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
   #include "e3v2/jyersui/dwin.h"
 #endif
@@ -101,6 +103,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     backlight = !!value;
     if (backlight) brightness = constrain(value, MIN_LCD_BRIGHTNESS, MAX_LCD_BRIGHTNESS);
     // Set brightness on enabled LCD here
+    TERN_(DWIN_CREALITY_LCD_ENHANCED, DWIN_LCD_Brightness(brightness));
     TERN_(DWIN_CREALITY_LCD_JYERSUI, DWIN_Backlight_SetLuminance(backlight ? brightness : 0));
   }
 #endif
@@ -1474,7 +1477,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     #endif
 
     TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
-    TERN_(DWIN_CREALITY_LCD, DWIN_StatusChanged(status_message));
+    TERN_(HAS_DWIN_E3V2_BASIC, DWIN_StatusChanged(status_message));
     TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Update_Status(status_message));
   }
 

commit 43a9c71ef7a1c9e9e294707017d372d344c774ce
Author: Jyers <76993396+Jyers@users.noreply.github.com>
Date:   Mon Sep 6 21:06:27 2021 -0700

    ✨ Ender-3 V2 with Jyers UI (#22422)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 8911941ee0..51cbf4534f 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -48,6 +48,8 @@ MarlinUI ui;
 
 #if ENABLED(DWIN_CREALITY_LCD)
   #include "e3v2/creality/dwin.h"
+#elif ENABLED(DWIN_CREALITY_LCD_JYERSUI)
+  #include "e3v2/jyersui/dwin.h"
 #endif
 
 #if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
@@ -99,6 +101,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     backlight = !!value;
     if (backlight) brightness = constrain(value, MIN_LCD_BRIGHTNESS, MAX_LCD_BRIGHTNESS);
     // Set brightness on enabled LCD here
+    TERN_(DWIN_CREALITY_LCD_JYERSUI, DWIN_Backlight_SetLuminance(backlight ? brightness : 0));
   }
 #endif
 
@@ -136,6 +139,21 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   bool MarlinUI::lcd_clicked;
 #endif
 
+#if EITHER(HAS_WIRED_LCD, DWIN_CREALITY_LCD_JYERSUI)
+
+  bool MarlinUI::get_blink() {
+    static uint8_t blink = 0;
+    static millis_t next_blink_ms = 0;
+    millis_t ms = millis();
+    if (ELAPSED(ms, next_blink_ms)) {
+      blink ^= 0xFF;
+      next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
+    }
+    return blink != 0;
+  }
+
+#endif
+
 #if HAS_WIRED_LCD
 
   #if HAS_MARLINUI_U8GLIB
@@ -415,17 +433,6 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     TERN_(HAS_ENCODER_ACTION, encoderDiff = 0);
   }
 
-  bool MarlinUI::get_blink() {
-    static uint8_t blink = 0;
-    static millis_t next_blink_ms = 0;
-    millis_t ms = millis();
-    if (ELAPSED(ms, next_blink_ms)) {
-      blink ^= 0xFF;
-      next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
-    }
-    return blink != 0;
-  }
-
   ////////////////////////////////////////////
   ///////////// Keypad Handling //////////////
   ////////////////////////////////////////////
@@ -1468,6 +1475,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
     TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
     TERN_(DWIN_CREALITY_LCD, DWIN_StatusChanged(status_message));
+    TERN_(DWIN_CREALITY_LCD_JYERSUI, CrealityDWIN.Update_Status(status_message));
   }
 
   #if ENABLED(STATUS_MESSAGE_SCROLLING)

commit 5dbb15539502da2bbc4ece99a3f5fc123801cdbe
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Sep 3 17:26:36 2021 -0500

    🩹 Fix 'ms' warning

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 1472f5c32a..8911941ee0 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1444,7 +1444,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
         UNUSED(persist);
       #endif
 
-      #if ENABLED(LCD_PROGRESS_BAR) || BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+      #if BASIC_PROGRESS_BAR || BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
         const millis_t ms = millis();
       #endif
 

commit 7d416bd055e3ccddf765208b2937dcc1fcd4ea8b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Aug 22 05:25:07 2021 -0500

    ✨ MarlinUI for Ender 3 v2 DWIN LCD (#22594)
    
    Co-Authored-By: Taylor Talkington <taylor.talkington@gmail.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index f4938722e3..1472f5c32a 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -202,6 +202,10 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     bool MarlinUI::drawing_screen, MarlinUI::first_page; // = false
   #endif
 
+  #if IS_DWIN_MARLINUI
+    bool MarlinUI::did_first_redraw;
+  #endif
+
   // Encoder Handling
   #if HAS_ENCODER_ACTION
     uint32_t MarlinUI::encoderPosition;
@@ -335,6 +339,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
           col = (LCD_WIDTH - plen - slen) / 2;
           row = LCD_HEIGHT > 3 ? 1 : 0;
         }
+        if (LCD_HEIGHT >= 8) row = LCD_HEIGHT / 2 - 2;
         wrap_string_P(col, row, pref, true);
         if (string) {
           if (col) { col = 0; row++; } // Move to the start of the next line
@@ -1073,6 +1078,9 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
           run_current_screen();
 
+          // Apply all DWIN drawing after processing
+          TERN_(IS_DWIN_MARLINUI, DWIN_UpdateLCD());
+
         #endif
 
         TERN_(HAS_LCD_MENU, lcd_clicked = false);

commit afca6e745932d295b88d37fa9bd4274e22705b0b
Author: luzpaz <luzpaz@users.noreply.github.com>
Date:   Tue Aug 3 20:02:34 2021 -0400

    🐛 Spellcheck comments (#22496)
    
    codespell -q 3 --builtin=clear,rare,informal,code -S ./Marlin/src/lcd/language -L alo,amin,endcode,stdio,uint

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index cf8d7343c6..f4938722e3 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -716,7 +716,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
      *     This is used to achieve more rapid stepping on kinematic machines.
      *
      * Currently used by the _lcd_move_xyz function in menu_motion.cpp
-     * and the ubl_map_move_to_xy funtion in menu_ubl.cpp.
+     * and the ubl_map_move_to_xy function in menu_ubl.cpp.
      */
     void ManualMove::task() {
 

commit 1e33c1a2a78392e9182442db043384b0f96cca20
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Aug 1 14:28:53 2021 -0500

    M256 LCD brightness (#22478)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 1e38a20250..cf8d7343c6 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -91,6 +91,17 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   }
 #endif
 
+#if HAS_LCD_BRIGHTNESS
+  uint8_t MarlinUI::brightness = DEFAULT_LCD_BRIGHTNESS;
+  bool MarlinUI::backlight = true;
+
+  void MarlinUI::set_brightness(const uint8_t value) {
+    backlight = !!value;
+    if (backlight) brightness = constrain(value, MIN_LCD_BRIGHTNESS, MAX_LCD_BRIGHTNESS);
+    // Set brightness on enabled LCD here
+  }
+#endif
+
 #if ENABLED(SOUND_MENU_ITEM)
   bool MarlinUI::buzzer_enabled = true;
 #endif

commit 9bb5b10c0c9cf5a61d2bfb9dfdb6cfe210b6002b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jul 31 05:32:13 2021 -0500

    🚚 Relocate and adjust DWIN E3V2 (#22471)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 346082986d..1e38a20250 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -47,7 +47,7 @@ MarlinUI ui;
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
-  #include "dwin/e3v2/dwin.h"
+  #include "e3v2/creality/dwin.h"
 #endif
 
 #if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
@@ -65,15 +65,8 @@ MarlinUI ui;
 constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
 #if HAS_STATUS_MESSAGE
-  #if HAS_WIRED_LCD
-    #if ENABLED(STATUS_MESSAGE_SCROLLING)
-      uint8_t MarlinUI::status_scroll_offset; // = 0
-      constexpr uint8_t MAX_MESSAGE_LENGTH = _MAX(LONG_FILENAME_LENGTH, MAX_LANG_CHARSIZE * 2 * (LCD_WIDTH));
-    #else
-      constexpr uint8_t MAX_MESSAGE_LENGTH = MAX_LANG_CHARSIZE * (LCD_WIDTH);
-    #endif
-  #else
-    constexpr uint8_t MAX_MESSAGE_LENGTH = 63;
+  #if BOTH(HAS_WIRED_LCD, STATUS_MESSAGE_SCROLLING)
+    uint8_t MarlinUI::status_scroll_offset; // = 0
   #endif
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
   uint8_t MarlinUI::alert_level; // = 0

commit b34a009bb1e114addf2d831171fab967d93a651f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 18 19:56:28 2021 -0500

    🐛 Change font for selected language (#22381)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 206bae925a..346082986d 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -88,6 +88,14 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
 #if HAS_MULTI_LANGUAGE
   uint8_t MarlinUI::language; // Initialized by settings.load()
+  void MarlinUI::set_language(const uint8_t lang) {
+    if (lang < NUM_LANGUAGES) {
+      language = lang;
+      TERN_(HAS_MARLINUI_U8GLIB, update_language_font());
+      return_to_status();
+      refresh();
+    }
+  }
 #endif
 
 #if ENABLED(SOUND_MENU_ITEM)

commit c8ee056cc63c5cb996b70c3336aae9be52f8cc85
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Sun Jul 11 22:13:58 2021 -0700

    ♻️ Consolidate PSU_CONTROL (#22304)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 0cb476c04b..206bae925a 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -158,6 +158,10 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     #include "../feature/power_monitor.h"
   #endif
 
+  #if ENABLED(PSU_CONTROL) && defined(LED_BACKLIGHT_TIMEOUT)
+    #include "../feature/power.h"
+  #endif
+
   #if HAS_ENCODER_ACTION
     volatile uint8_t MarlinUI::buttons;
     #if HAS_SLOW_BUTTONS
@@ -826,8 +830,8 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
     static uint16_t max_display_update_time = 0;
     millis_t ms = millis();
 
-    #ifdef LED_BACKLIGHT_TIMEOUT
-      leds.update_timeout(powersupply_on);
+    #if ENABLED(PSU_CONTROL) && defined(LED_BACKLIGHT_TIMEOUT)
+      leds.update_timeout(powerManager.psu_on);
     #endif
 
     #if HAS_LCD_MENU
@@ -976,8 +980,8 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
           refresh(LCDVIEW_REDRAW_NOW);
 
-          #ifdef LED_BACKLIGHT_TIMEOUT
-            if (!powersupply_on) leds.reset_timeout(ms);
+          #if ENABLED(PSU_CONTROL) && defined(LED_BACKLIGHT_TIMEOUT)
+            if (!powerManager.psu_on) leds.reset_timeout(ms);
           #endif
         }
 

commit 3ba5eda0b28498a3e557669496e0d6ffec875876
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Jul 9 19:24:14 2021 -0400

    📺 ExtUI pause state response (#22164)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 6741de3e40..0cb476c04b 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1661,6 +1661,40 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   }
 #endif
 
+#if BOTH(EXTENSIBLE_UI, ADVANCED_PAUSE_FEATURE)
+
+  void MarlinUI::pause_show_message(
+    const PauseMessage message,
+    const PauseMode mode/*=PAUSE_MODE_SAME*/,
+    const uint8_t extruder/*=active_extruder*/
+  ) {
+    if (mode == PAUSE_MODE_SAME)
+      return;
+    pause_mode = mode;
+    switch (message) {
+      case PAUSE_MESSAGE_PARKING:  ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_PAUSE_PRINT_PARKING));
+      case PAUSE_MESSAGE_CHANGING: ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_INIT));
+      case PAUSE_MESSAGE_UNLOAD:   ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_UNLOAD));
+      case PAUSE_MESSAGE_WAITING:  ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_ADVANCED_PAUSE_WAITING));
+      case PAUSE_MESSAGE_INSERT:   ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_INSERT));
+      case PAUSE_MESSAGE_LOAD:     ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_LOAD));
+      case PAUSE_MESSAGE_PURGE:
+        #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
+          ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_CONT_PURGE));
+        #else
+          ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_PURGE));
+        #endif
+      case PAUSE_MESSAGE_RESUME:   ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_RESUME));
+      case PAUSE_MESSAGE_HEAT:     ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_HEAT));
+      case PAUSE_MESSAGE_HEATING:  ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_HEATING));
+      case PAUSE_MESSAGE_OPTION:   ExtUI::onUserConfirmRequired_P(GET_TEXT(MSG_FILAMENT_CHANGE_OPTION_HEADER));
+      case PAUSE_MESSAGE_STATUS:
+      default: break;
+    }
+  }
+
+#endif
+
 #if ENABLED(EEPROM_SETTINGS)
 
   #if HAS_LCD_MENU

commit a5b2498de9590a19aeeea4cebc46bc204195012e
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Tue Jun 29 10:30:55 2021 -0700

    🐛 Fix ExtUI 'lcd_clicked' definition (#22257)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 67e5adc0f0..6741de3e40 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -120,1169 +120,1169 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   }
 #endif
 
-#if HAS_WIRED_LCD
-
-#if HAS_MARLINUI_U8GLIB
-  #include "dogm/marlinui_DOGM.h"
+#if EITHER(HAS_LCD_MENU, EXTENSIBLE_UI)
+  bool MarlinUI::lcd_clicked;
 #endif
 
-#include "lcdprint.h"
-
-#include "../sd/cardreader.h"
-
-#include "../module/temperature.h"
-#include "../module/planner.h"
-#include "../module/motion.h"
-
-#if HAS_LCD_MENU
-  #include "../module/settings.h"
-#endif
+#if HAS_WIRED_LCD
 
-#if ENABLED(AUTO_BED_LEVELING_UBL)
-  #include "../feature/bedlevel/bedlevel.h"
-#endif
+  #if HAS_MARLINUI_U8GLIB
+    #include "dogm/marlinui_DOGM.h"
+  #endif
 
-#if HAS_TRINAMIC_CONFIG
-  #include "../feature/tmc_util.h"
-#endif
+  #include "lcdprint.h"
 
-#if HAS_ADC_BUTTONS
-  #include "../module/thermistor/thermistors.h"
-#endif
+  #include "../sd/cardreader.h"
 
-#if HAS_POWER_MONITOR
-  #include "../feature/power_monitor.h"
-#endif
+  #include "../module/temperature.h"
+  #include "../module/planner.h"
+  #include "../module/motion.h"
 
-#if HAS_ENCODER_ACTION
-  volatile uint8_t MarlinUI::buttons;
-  #if HAS_SLOW_BUTTONS
-    volatile uint8_t MarlinUI::slow_buttons;
+  #if HAS_LCD_MENU
+    #include "../module/settings.h"
   #endif
-  #if HAS_TOUCH_BUTTONS
-    #include "touch/touch_buttons.h"
-    bool MarlinUI::on_edit_screen = false;
+
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+    #include "../feature/bedlevel/bedlevel.h"
   #endif
-#endif
 
-#if SCREENS_CAN_TIME_OUT
-  bool MarlinUI::defer_return_to_status;
-  millis_t MarlinUI::return_to_status_ms = 0;
-#endif
+  #if HAS_TRINAMIC_CONFIG
+    #include "../feature/tmc_util.h"
+  #endif
 
-uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
+  #if HAS_ADC_BUTTONS
+    #include "../module/thermistor/thermistors.h"
+  #endif
 
-#if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
-  millis_t MarlinUI::next_filament_display; // = 0
-#endif
+  #if HAS_POWER_MONITOR
+    #include "../feature/power_monitor.h"
+  #endif
 
-millis_t MarlinUI::next_button_update_ms; // = 0
+  #if HAS_ENCODER_ACTION
+    volatile uint8_t MarlinUI::buttons;
+    #if HAS_SLOW_BUTTONS
+      volatile uint8_t MarlinUI::slow_buttons;
+    #endif
+    #if HAS_TOUCH_BUTTONS
+      #include "touch/touch_buttons.h"
+      bool MarlinUI::on_edit_screen = false;
+    #endif
+  #endif
 
-#if HAS_MARLINUI_U8GLIB
-  bool MarlinUI::drawing_screen, MarlinUI::first_page; // = false
-#endif
+  #if SCREENS_CAN_TIME_OUT
+    bool MarlinUI::defer_return_to_status;
+    millis_t MarlinUI::return_to_status_ms = 0;
+  #endif
 
-// Encoder Handling
-#if HAS_ENCODER_ACTION
-  uint32_t MarlinUI::encoderPosition;
-  volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
-#endif
+  uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
 
-#if ENABLED(SDSUPPORT)
+  #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+    millis_t MarlinUI::next_filament_display; // = 0
+  #endif
 
-  #include "../sd/cardreader.h"
+  millis_t MarlinUI::next_button_update_ms; // = 0
 
-  #if MARLINUI_SCROLL_NAME
-    uint8_t MarlinUI::filename_scroll_pos, MarlinUI::filename_scroll_max;
+  #if HAS_MARLINUI_U8GLIB
+    bool MarlinUI::drawing_screen, MarlinUI::first_page; // = false
   #endif
 
-  const char * MarlinUI::scrolled_filename(CardReader &theCard, const uint8_t maxlen, uint8_t hash, const bool doScroll) {
-    const char *outstr = theCard.longest_filename();
-    if (theCard.longFilename[0]) {
-      #if MARLINUI_SCROLL_NAME
-        if (doScroll) {
-          for (uint8_t l = FILENAME_LENGTH; l--;)
-            hash = ((hash << 1) | (hash >> 7)) ^ theCard.filename[l];      // rotate, xor
-          static uint8_t filename_scroll_hash;
-          if (filename_scroll_hash != hash) {                              // If the hash changed...
-            filename_scroll_hash = hash;                                   // Save the new hash
-            filename_scroll_max = _MAX(0, utf8_strlen(theCard.longFilename) - maxlen); // Update the scroll limit
-            filename_scroll_pos = 0;                                       // Reset scroll to the start
-            lcd_status_update_delay = 8;                                   // Don't scroll right away
-          }
-          // Advance byte position corresponding to filename_scroll_pos char position
-          outstr += TERN(UTF_FILENAME_SUPPORT, utf8_byte_pos_by_char_num(outstr, filename_scroll_pos), filename_scroll_pos);
-        }
-      #else
-        theCard.longFilename[
-          TERN(UTF_FILENAME_SUPPORT, utf8_byte_pos_by_char_num(theCard.longFilename, maxlen), maxlen)
-        ] = '\0'; // cutoff at screen edge
-      #endif
-    }
-    return outstr;
-  }
-
-#endif
+  // Encoder Handling
+  #if HAS_ENCODER_ACTION
+    uint32_t MarlinUI::encoderPosition;
+    volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
+  #endif
 
-#if EITHER(HAS_LCD_MENU, EXTENSIBLE_UI)
-  bool MarlinUI::lcd_clicked;
-#endif
+  #if ENABLED(SDSUPPORT)
 
-#if HAS_LCD_MENU
-  #include "menu/menu.h"
+    #include "../sd/cardreader.h"
 
-  screenFunc_t MarlinUI::currentScreen; // Initialized in CTOR
-  bool MarlinUI::screen_changed;
+    #if MARLINUI_SCROLL_NAME
+      uint8_t MarlinUI::filename_scroll_pos, MarlinUI::filename_scroll_max;
+    #endif
 
-  #if ENABLED(ENCODER_RATE_MULTIPLIER)
-    bool MarlinUI::encoderRateMultiplierEnabled;
-    millis_t MarlinUI::lastEncoderMovementMillis = 0;
-    void MarlinUI::enable_encoder_multiplier(const bool onoff) {
-      encoderRateMultiplierEnabled = onoff;
-      lastEncoderMovementMillis = 0;
+    const char * MarlinUI::scrolled_filename(CardReader &theCard, const uint8_t maxlen, uint8_t hash, const bool doScroll) {
+      const char *outstr = theCard.longest_filename();
+      if (theCard.longFilename[0]) {
+        #if MARLINUI_SCROLL_NAME
+          if (doScroll) {
+            for (uint8_t l = FILENAME_LENGTH; l--;)
+              hash = ((hash << 1) | (hash >> 7)) ^ theCard.filename[l];      // rotate, xor
+            static uint8_t filename_scroll_hash;
+            if (filename_scroll_hash != hash) {                              // If the hash changed...
+              filename_scroll_hash = hash;                                   // Save the new hash
+              filename_scroll_max = _MAX(0, utf8_strlen(theCard.longFilename) - maxlen); // Update the scroll limit
+              filename_scroll_pos = 0;                                       // Reset scroll to the start
+              lcd_status_update_delay = 8;                                   // Don't scroll right away
+            }
+            // Advance byte position corresponding to filename_scroll_pos char position
+            outstr += TERN(UTF_FILENAME_SUPPORT, utf8_byte_pos_by_char_num(outstr, filename_scroll_pos), filename_scroll_pos);
+          }
+        #else
+          theCard.longFilename[
+            TERN(UTF_FILENAME_SUPPORT, utf8_byte_pos_by_char_num(theCard.longFilename, maxlen), maxlen)
+          ] = '\0'; // cutoff at screen edge
+        #endif
+      }
+      return outstr;
     }
-  #endif
 
-  #if EITHER(REVERSE_MENU_DIRECTION, REVERSE_SELECT_DIRECTION)
-    int8_t MarlinUI::encoderDirection = ENCODERBASE;
   #endif
 
-  #if HAS_TOUCH_BUTTONS
-    uint8_t MarlinUI::touch_buttons;
-    uint8_t MarlinUI::repeat_delay;
-  #endif
+  #if HAS_LCD_MENU
+    #include "menu/menu.h"
 
-  #if EITHER(AUTO_BED_LEVELING_UBL, G26_MESH_VALIDATION)
+    screenFunc_t MarlinUI::currentScreen; // Initialized in CTOR
+    bool MarlinUI::screen_changed;
 
-    bool MarlinUI::external_control; // = false
+    #if ENABLED(ENCODER_RATE_MULTIPLIER)
+      bool MarlinUI::encoderRateMultiplierEnabled;
+      millis_t MarlinUI::lastEncoderMovementMillis = 0;
+      void MarlinUI::enable_encoder_multiplier(const bool onoff) {
+        encoderRateMultiplierEnabled = onoff;
+        lastEncoderMovementMillis = 0;
+      }
+    #endif
 
-    void MarlinUI::wait_for_release() {
-      while (button_pressed()) safe_delay(50);
-      safe_delay(50);
-    }
+    #if EITHER(REVERSE_MENU_DIRECTION, REVERSE_SELECT_DIRECTION)
+      int8_t MarlinUI::encoderDirection = ENCODERBASE;
+    #endif
 
-  #endif
+    #if HAS_TOUCH_BUTTONS
+      uint8_t MarlinUI::touch_buttons;
+      uint8_t MarlinUI::repeat_delay;
+    #endif
 
-  #if !HAS_GRAPHICAL_TFT
+    #if EITHER(AUTO_BED_LEVELING_UBL, G26_MESH_VALIDATION)
 
-    void _wrap_string(uint8_t &col, uint8_t &row, const char * const string, read_byte_cb_t cb_read_byte, bool wordwrap/*=false*/) {
-      SETCURSOR(col, row);
-      if (!string) return;
+      bool MarlinUI::external_control; // = false
 
-      auto _newline = [&col, &row]{
-        col = 0; row++;                 // Move col to string len (plus space)
-        SETCURSOR(0, row);              // Simulate carriage return
-      };
+      void MarlinUI::wait_for_release() {
+        while (button_pressed()) safe_delay(50);
+        safe_delay(50);
+      }
+
+    #endif
 
-      uint8_t *p = (uint8_t*)string;
-      wchar_t ch;
-      if (wordwrap) {
-        uint8_t *wrd = nullptr, c = 0;
-        // find the end of the part
-        for (;;) {
-          if (!wrd) wrd = p;            // Get word start /before/ advancing
-          p = get_utf8_value_cb(p, cb_read_byte, &ch);
-          const bool eol = !ch;         // zero ends the string
-          // End or a break between phrases?
-          if (eol || ch == ' ' || ch == '-' || ch == '+' || ch == '.') {
-            if (!c && ch == ' ') { if (wrd) wrd++; continue; } // collapse extra spaces
-            // Past the right and the word is not too long?
-            if (col + c > LCD_WIDTH && col >= (LCD_WIDTH) / 4) _newline(); // should it wrap?
-            c += !eol;                  // +1 so the space will be printed
-            col += c;                   // advance col to new position
-            while (c) {                 // character countdown
-              --c;                      // count down to zero
-              wrd = get_utf8_value_cb(wrd, cb_read_byte, &ch); // get characters again
-              lcd_put_wchar(ch);        // character to the LCD
+    #if !HAS_GRAPHICAL_TFT
+
+      void _wrap_string(uint8_t &col, uint8_t &row, const char * const string, read_byte_cb_t cb_read_byte, bool wordwrap/*=false*/) {
+        SETCURSOR(col, row);
+        if (!string) return;
+
+        auto _newline = [&col, &row]{
+          col = 0; row++;                 // Move col to string len (plus space)
+          SETCURSOR(0, row);              // Simulate carriage return
+        };
+
+        uint8_t *p = (uint8_t*)string;
+        wchar_t ch;
+        if (wordwrap) {
+          uint8_t *wrd = nullptr, c = 0;
+          // find the end of the part
+          for (;;) {
+            if (!wrd) wrd = p;            // Get word start /before/ advancing
+            p = get_utf8_value_cb(p, cb_read_byte, &ch);
+            const bool eol = !ch;         // zero ends the string
+            // End or a break between phrases?
+            if (eol || ch == ' ' || ch == '-' || ch == '+' || ch == '.') {
+              if (!c && ch == ' ') { if (wrd) wrd++; continue; } // collapse extra spaces
+              // Past the right and the word is not too long?
+              if (col + c > LCD_WIDTH && col >= (LCD_WIDTH) / 4) _newline(); // should it wrap?
+              c += !eol;                  // +1 so the space will be printed
+              col += c;                   // advance col to new position
+              while (c) {                 // character countdown
+                --c;                      // count down to zero
+                wrd = get_utf8_value_cb(wrd, cb_read_byte, &ch); // get characters again
+                lcd_put_wchar(ch);        // character to the LCD
+              }
+              if (eol) break;             // all done!
+              wrd = nullptr;              // set up for next word
             }
-            if (eol) break;             // all done!
-            wrd = nullptr;              // set up for next word
+            else c++;                     // count word characters
           }
-          else c++;                     // count word characters
         }
-      }
-      else {
-        for (;;) {
-          p = get_utf8_value_cb(p, cb_read_byte, &ch);
-          if (!ch) break;
-          lcd_put_wchar(ch);
-          col++;
-          if (col >= LCD_WIDTH) _newline();
+        else {
+          for (;;) {
+            p = get_utf8_value_cb(p, cb_read_byte, &ch);
+            if (!ch) break;
+            lcd_put_wchar(ch);
+            col++;
+            if (col >= LCD_WIDTH) _newline();
+          }
         }
       }
-    }
 
-    void MarlinUI::draw_select_screen_prompt(PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
-      const uint8_t plen = utf8_strlen_P(pref), slen = suff ? utf8_strlen_P(suff) : 0;
-      uint8_t col = 0, row = 0;
-      if (!string && plen + slen <= LCD_WIDTH) {
-        col = (LCD_WIDTH - plen - slen) / 2;
-        row = LCD_HEIGHT > 3 ? 1 : 0;
-      }
-      wrap_string_P(col, row, pref, true);
-      if (string) {
-        if (col) { col = 0; row++; } // Move to the start of the next line
-        wrap_string(col, row, string);
+      void MarlinUI::draw_select_screen_prompt(PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
+        const uint8_t plen = utf8_strlen_P(pref), slen = suff ? utf8_strlen_P(suff) : 0;
+        uint8_t col = 0, row = 0;
+        if (!string && plen + slen <= LCD_WIDTH) {
+          col = (LCD_WIDTH - plen - slen) / 2;
+          row = LCD_HEIGHT > 3 ? 1 : 0;
+        }
+        wrap_string_P(col, row, pref, true);
+        if (string) {
+          if (col) { col = 0; row++; } // Move to the start of the next line
+          wrap_string(col, row, string);
+        }
+        if (suff) wrap_string_P(col, row, suff);
       }
-      if (suff) wrap_string_P(col, row, suff);
-    }
 
-  #endif // !HAS_GRAPHICAL_TFT
+    #endif // !HAS_GRAPHICAL_TFT
 
-#endif // HAS_LCD_MENU
+  #endif // HAS_LCD_MENU
 
-void MarlinUI::init() {
+  void MarlinUI::init() {
 
-  init_lcd();
+    init_lcd();
 
-  #if HAS_DIGITAL_BUTTONS
-    #if BUTTON_EXISTS(EN1)
-      SET_INPUT_PULLUP(BTN_EN1);
-    #endif
-    #if BUTTON_EXISTS(EN2)
-      SET_INPUT_PULLUP(BTN_EN2);
-    #endif
-    #if BUTTON_EXISTS(ENC)
-      SET_INPUT_PULLUP(BTN_ENC);
-    #endif
-    #if BUTTON_EXISTS(ENC_EN)
-      SET_INPUT_PULLUP(BTN_ENC_EN);
-    #endif
-    #if BUTTON_EXISTS(BACK)
-      SET_INPUT_PULLUP(BTN_BACK);
-    #endif
-    #if BUTTON_EXISTS(UP)
-      SET_INPUT(BTN_UP);
-    #endif
-    #if BUTTON_EXISTS(DWN)
-      SET_INPUT(BTN_DWN);
-    #endif
-    #if BUTTON_EXISTS(LFT)
-      SET_INPUT(BTN_LFT);
-    #endif
-    #if BUTTON_EXISTS(RT)
-      SET_INPUT(BTN_RT);
+    #if HAS_DIGITAL_BUTTONS
+      #if BUTTON_EXISTS(EN1)
+        SET_INPUT_PULLUP(BTN_EN1);
+      #endif
+      #if BUTTON_EXISTS(EN2)
+        SET_INPUT_PULLUP(BTN_EN2);
+      #endif
+      #if BUTTON_EXISTS(ENC)
+        SET_INPUT_PULLUP(BTN_ENC);
+      #endif
+      #if BUTTON_EXISTS(ENC_EN)
+        SET_INPUT_PULLUP(BTN_ENC_EN);
+      #endif
+      #if BUTTON_EXISTS(BACK)
+        SET_INPUT_PULLUP(BTN_BACK);
+      #endif
+      #if BUTTON_EXISTS(UP)
+        SET_INPUT(BTN_UP);
+      #endif
+      #if BUTTON_EXISTS(DWN)
+        SET_INPUT(BTN_DWN);
+      #endif
+      #if BUTTON_EXISTS(LFT)
+        SET_INPUT(BTN_LFT);
+      #endif
+      #if BUTTON_EXISTS(RT)
+        SET_INPUT(BTN_RT);
+      #endif
     #endif
-  #endif
 
-  #if HAS_SHIFT_ENCODER
+    #if HAS_SHIFT_ENCODER
 
-    #if ENABLED(SR_LCD_2W_NL) // Non latching 2 wire shift register
+      #if ENABLED(SR_LCD_2W_NL) // Non latching 2 wire shift register
 
-      SET_OUTPUT(SR_DATA_PIN);
-      SET_OUTPUT(SR_CLK_PIN);
+        SET_OUTPUT(SR_DATA_PIN);
+        SET_OUTPUT(SR_CLK_PIN);
 
-    #elif PIN_EXISTS(SHIFT_CLK)
+      #elif PIN_EXISTS(SHIFT_CLK)
 
-      SET_OUTPUT(SHIFT_CLK_PIN);
-      OUT_WRITE(SHIFT_LD_PIN, HIGH);
-      #if PIN_EXISTS(SHIFT_EN)
-        OUT_WRITE(SHIFT_EN_PIN, LOW);
-      #endif
-      SET_INPUT_PULLUP(SHIFT_OUT_PIN);
+        SET_OUTPUT(SHIFT_CLK_PIN);
+        OUT_WRITE(SHIFT_LD_PIN, HIGH);
+        #if PIN_EXISTS(SHIFT_EN)
+          OUT_WRITE(SHIFT_EN_PIN, LOW);
+        #endif
+        SET_INPUT_PULLUP(SHIFT_OUT_PIN);
 
-    #endif
+      #endif
 
-  #endif // HAS_SHIFT_ENCODER
+    #endif // HAS_SHIFT_ENCODER
 
-  #if BOTH(HAS_ENCODER_ACTION, HAS_SLOW_BUTTONS)
-    slow_buttons = 0;
-  #endif
+    #if BOTH(HAS_ENCODER_ACTION, HAS_SLOW_BUTTONS)
+      slow_buttons = 0;
+    #endif
 
-  update_buttons();
+    update_buttons();
 
-  TERN_(HAS_ENCODER_ACTION, encoderDiff = 0);
-}
+    TERN_(HAS_ENCODER_ACTION, encoderDiff = 0);
+  }
 
-bool MarlinUI::get_blink() {
-  static uint8_t blink = 0;
-  static millis_t next_blink_ms = 0;
-  millis_t ms = millis();
-  if (ELAPSED(ms, next_blink_ms)) {
-    blink ^= 0xFF;
-    next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
+  bool MarlinUI::get_blink() {
+    static uint8_t blink = 0;
+    static millis_t next_blink_ms = 0;
+    millis_t ms = millis();
+    if (ELAPSED(ms, next_blink_ms)) {
+      blink ^= 0xFF;
+      next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
+    }
+    return blink != 0;
   }
-  return blink != 0;
-}
 
-////////////////////////////////////////////
-///////////// Keypad Handling //////////////
-////////////////////////////////////////////
+  ////////////////////////////////////////////
+  ///////////// Keypad Handling //////////////
+  ////////////////////////////////////////////
 
-#if IS_RRW_KEYPAD && HAS_ENCODER_ACTION
+  #if IS_RRW_KEYPAD && HAS_ENCODER_ACTION
 
-  volatile uint8_t MarlinUI::keypad_buttons;
+    volatile uint8_t MarlinUI::keypad_buttons;
 
-  #if HAS_LCD_MENU && !HAS_ADC_BUTTONS
+    #if HAS_LCD_MENU && !HAS_ADC_BUTTONS
 
-    void lcd_move_x();
-    void lcd_move_y();
-    void lcd_move_z();
+      void lcd_move_x();
+      void lcd_move_y();
+      void lcd_move_z();
 
-    void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
-      ui.manual_move.menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
-      ui.encoderPosition = dir;
-      switch (axis) {
-        case X_AXIS: lcd_move_x(); break;
-        case Y_AXIS: lcd_move_y(); break;
-        case Z_AXIS: lcd_move_z();
-        default: break;
+      void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
+        ui.manual_move.menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+        ui.encoderPosition = dir;
+        switch (axis) {
+          case X_AXIS: lcd_move_x(); break;
+          case Y_AXIS: lcd_move_y(); break;
+          case Z_AXIS: lcd_move_z();
+          default: break;
+        }
       }
-    }
 
-  #endif
+    #endif
 
-  bool MarlinUI::handle_keypad() {
+    bool MarlinUI::handle_keypad() {
 
-    #if HAS_ADC_BUTTONS
+      #if HAS_ADC_BUTTONS
 
-      #define ADC_MIN_KEY_DELAY 100
-      if (keypad_buttons) {
-        #if HAS_ENCODER_ACTION
-          refresh(LCDVIEW_REDRAW_NOW);
-          #if HAS_LCD_MENU
-            if (encoderDirection == -(ENCODERBASE)) { // HAS_ADC_BUTTONS forces REVERSE_MENU_DIRECTION, so this indicates menu navigation
-                   if (RRK(EN_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
-              else if (RRK(EN_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
-              else if (RRK(EN_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
-              else if (RRK(EN_KEYPAD_RIGHT))  { return_to_status(); quick_feedback(); }
-            }
-            else
-          #endif
-          {
+        #define ADC_MIN_KEY_DELAY 100
+        if (keypad_buttons) {
+          #if HAS_ENCODER_ACTION
+            refresh(LCDVIEW_REDRAW_NOW);
             #if HAS_LCD_MENU
-                   if (RRK(EN_KEYPAD_UP))     encoderPosition -= epps;
-              else if (RRK(EN_KEYPAD_DOWN))   encoderPosition += epps;
-              else if (RRK(EN_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
-              else if (RRK(EN_KEYPAD_RIGHT))  encoderPosition = 0;
-            #else
-                   if (RRK(EN_KEYPAD_UP)   || RRK(EN_KEYPAD_LEFT))  encoderPosition -= epps;
-              else if (RRK(EN_KEYPAD_DOWN) || RRK(EN_KEYPAD_RIGHT)) encoderPosition += epps;
+              if (encoderDirection == -(ENCODERBASE)) { // HAS_ADC_BUTTONS forces REVERSE_MENU_DIRECTION, so this indicates menu navigation
+                     if (RRK(EN_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
+                else if (RRK(EN_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
+                else if (RRK(EN_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
+                else if (RRK(EN_KEYPAD_RIGHT))  { return_to_status(); quick_feedback(); }
+              }
+              else
             #endif
-          }
-        #endif
-        next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
-        return true;
-      }
-
-    #else // !HAS_ADC_BUTTONS
+            {
+              #if HAS_LCD_MENU
+                     if (RRK(EN_KEYPAD_UP))     encoderPosition -= epps;
+                else if (RRK(EN_KEYPAD_DOWN))   encoderPosition += epps;
+                else if (RRK(EN_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
+                else if (RRK(EN_KEYPAD_RIGHT))  encoderPosition = 0;
+              #else
+                     if (RRK(EN_KEYPAD_UP)   || RRK(EN_KEYPAD_LEFT))  encoderPosition -= epps;
+                else if (RRK(EN_KEYPAD_DOWN) || RRK(EN_KEYPAD_RIGHT)) encoderPosition += epps;
+              #endif
+            }
+          #endif
+          next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
+          return true;
+        }
 
-      static uint8_t keypad_debounce = 0;
+      #else // !HAS_ADC_BUTTONS
 
-      if (!RRK( EN_KEYPAD_F1    | EN_KEYPAD_F2
-              | EN_KEYPAD_F3    | EN_KEYPAD_DOWN
-              | EN_KEYPAD_RIGHT | EN_KEYPAD_MIDDLE
-              | EN_KEYPAD_UP    | EN_KEYPAD_LEFT )
-      ) {
-        if (keypad_debounce > 0) keypad_debounce--;
-      }
-      else if (!keypad_debounce) {
-        keypad_debounce = 2;
+        static uint8_t keypad_debounce = 0;
 
-        const bool homed = all_axes_homed();
+        if (!RRK( EN_KEYPAD_F1    | EN_KEYPAD_F2
+                | EN_KEYPAD_F3    | EN_KEYPAD_DOWN
+                | EN_KEYPAD_RIGHT | EN_KEYPAD_MIDDLE
+                | EN_KEYPAD_UP    | EN_KEYPAD_LEFT )
+        ) {
+          if (keypad_debounce > 0) keypad_debounce--;
+        }
+        else if (!keypad_debounce) {
+          keypad_debounce = 2;
 
-        #if HAS_LCD_MENU
+          const bool homed = all_axes_homed();
 
-          if (RRK(EN_KEYPAD_MIDDLE))  goto_screen(menu_move);
+          #if HAS_LCD_MENU
 
-          #if NONE(DELTA, Z_HOME_TO_MAX)
-            if (RRK(EN_KEYPAD_F2))    _reprapworld_keypad_move(Z_AXIS,  1);
-          #endif
+            if (RRK(EN_KEYPAD_MIDDLE))  goto_screen(menu_move);
 
-          if (homed) {
-            #if EITHER(DELTA, Z_HOME_TO_MAX)
-              if (RRK(EN_KEYPAD_F2))  _reprapworld_keypad_move(Z_AXIS,  1);
+            #if NONE(DELTA, Z_HOME_TO_MAX)
+              if (RRK(EN_KEYPAD_F2))    _reprapworld_keypad_move(Z_AXIS,  1);
             #endif
-            if (RRK(EN_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);
-            if (RRK(EN_KEYPAD_LEFT))  _reprapworld_keypad_move(X_AXIS, -1);
-            if (RRK(EN_KEYPAD_RIGHT)) _reprapworld_keypad_move(X_AXIS,  1);
-            if (RRK(EN_KEYPAD_DOWN))  _reprapworld_keypad_move(Y_AXIS,  1);
-            if (RRK(EN_KEYPAD_UP))    _reprapworld_keypad_move(Y_AXIS, -1);
-          }
 
-        #endif // HAS_LCD_MENU
+            if (homed) {
+              #if EITHER(DELTA, Z_HOME_TO_MAX)
+                if (RRK(EN_KEYPAD_F2))  _reprapworld_keypad_move(Z_AXIS,  1);
+              #endif
+              if (RRK(EN_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);
+              if (RRK(EN_KEYPAD_LEFT))  _reprapworld_keypad_move(X_AXIS, -1);
+              if (RRK(EN_KEYPAD_RIGHT)) _reprapworld_keypad_move(X_AXIS,  1);
+              if (RRK(EN_KEYPAD_DOWN))  _reprapworld_keypad_move(Y_AXIS,  1);
+              if (RRK(EN_KEYPAD_UP))    _reprapworld_keypad_move(Y_AXIS, -1);
+            }
 
-        if (!homed && RRK(EN_KEYPAD_F1)) queue.inject_P(G28_STR);
-        return true;
-      }
+          #endif // HAS_LCD_MENU
 
-    #endif // !HAS_ADC_BUTTONS
+          if (!homed && RRK(EN_KEYPAD_F1)) queue.inject_P(G28_STR);
+          return true;
+        }
 
-    return false;
-  }
+      #endif // !HAS_ADC_BUTTONS
 
-#endif // IS_RRW_KEYPAD && HAS_ENCODER_ACTION
+      return false;
+    }
 
-/**
- * Status Screen
- *
- * This is very display-dependent, so the lcd implementation draws this.
- */
+  #endif // IS_RRW_KEYPAD && HAS_ENCODER_ACTION
 
-#if BASIC_PROGRESS_BAR
-  millis_t MarlinUI::progress_bar_ms; // = 0
-  #if PROGRESS_MSG_EXPIRE > 0
-    millis_t MarlinUI::expire_status_ms; // = 0
+  /**
+   * Status Screen
+   *
+   * This is very display-dependent, so the lcd implementation draws this.
+   */
+
+  #if BASIC_PROGRESS_BAR
+    millis_t MarlinUI::progress_bar_ms; // = 0
+    #if PROGRESS_MSG_EXPIRE > 0
+      millis_t MarlinUI::expire_status_ms; // = 0
+    #endif
   #endif
-#endif
 
-void MarlinUI::status_screen() {
+  void MarlinUI::status_screen() {
 
-  TERN_(HAS_LCD_MENU, ENCODER_RATE_MULTIPLY(false));
+    TERN_(HAS_LCD_MENU, ENCODER_RATE_MULTIPLY(false));
 
-  #if BASIC_PROGRESS_BAR
+    #if BASIC_PROGRESS_BAR
 
-    //
-    // HD44780 implements the following message blinking and
-    // message expiration because Status Line and Progress Bar
-    // share the same line on the display.
-    //
+      //
+      // HD44780 implements the following message blinking and
+      // message expiration because Status Line and Progress Bar
+      // share the same line on the display.
+      //
 
-    #if DISABLED(PROGRESS_MSG_ONCE) || (PROGRESS_MSG_EXPIRE > 0)
-      #define GOT_MS
-      const millis_t ms = millis();
-    #endif
+      #if DISABLED(PROGRESS_MSG_ONCE) || (PROGRESS_MSG_EXPIRE > 0)
+        #define GOT_MS
+        const millis_t ms = millis();
+      #endif
 
-    // If the message will blink rather than expire...
-    #if DISABLED(PROGRESS_MSG_ONCE)
-      if (ELAPSED(ms, progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME))
-        progress_bar_ms = ms;
-    #endif
+      // If the message will blink rather than expire...
+      #if DISABLED(PROGRESS_MSG_ONCE)
+        if (ELAPSED(ms, progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME))
+          progress_bar_ms = ms;
+      #endif
 
-    #if PROGRESS_MSG_EXPIRE > 0
+      #if PROGRESS_MSG_EXPIRE > 0
 
-      // Handle message expire
-      if (expire_status_ms) {
+        // Handle message expire
+        if (expire_status_ms) {
 
-        // Expire the message if a job is active and the bar has ticks
-        if (get_progress_percent() > 2 && !print_job_timer.isPaused()) {
-          if (ELAPSED(ms, expire_status_ms)) {
-            status_message[0] = '\0';
-            expire_status_ms = 0;
+          // Expire the message if a job is active and the bar has ticks
+          if (get_progress_percent() > 2 && !print_job_timer.isPaused()) {
+            if (ELAPSED(ms, expire_status_ms)) {
+              status_message[0] = '\0';
+              expire_status_ms = 0;
+            }
+          }
+          else {
+            // Defer message expiration before bar appears
+            // and during any pause (not just SD)
+            expire_status_ms += LCD_UPDATE_INTERVAL;
           }
         }
-        else {
-          // Defer message expiration before bar appears
-          // and during any pause (not just SD)
-          expire_status_ms += LCD_UPDATE_INTERVAL;
-        }
-      }
 
-    #endif // PROGRESS_MSG_EXPIRE
+      #endif // PROGRESS_MSG_EXPIRE
 
-  #endif // BASIC_PROGRESS_BAR
+    #endif // BASIC_PROGRESS_BAR
 
-  #if HAS_LCD_MENU
-    if (use_click()) {
-      #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
-        next_filament_display = millis() + 5000UL;  // Show status message for 5s
-      #endif
-      goto_screen(menu_main);
-      #if DISABLED(NO_LCD_REINIT)
-        init_lcd(); // May revive the LCD if static electricity killed it
-      #endif
-      return;
-    }
+    #if HAS_LCD_MENU
+      if (use_click()) {
+        #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+          next_filament_display = millis() + 5000UL;  // Show status message for 5s
+        #endif
+        goto_screen(menu_main);
+        #if DISABLED(NO_LCD_REINIT)
+          init_lcd(); // May revive the LCD if static electricity killed it
+        #endif
+        return;
+      }
 
-  #endif
+    #endif
 
-  #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
+    #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
 
-    const int16_t old_frm = feedrate_percentage;
-          int16_t new_frm = old_frm + int16_t(encoderPosition);
+      const int16_t old_frm = feedrate_percentage;
+            int16_t new_frm = old_frm + int16_t(encoderPosition);
 
-    // Dead zone at 100% feedrate
-    if (old_frm == 100) {
-      if (int16_t(encoderPosition) > ENCODER_FEEDRATE_DEADZONE)
-        new_frm -= ENCODER_FEEDRATE_DEADZONE;
-      else if (int16_t(encoderPosition) < -(ENCODER_FEEDRATE_DEADZONE))
-        new_frm += ENCODER_FEEDRATE_DEADZONE;
-      else
-        new_frm = old_frm;
-    }
-    else if ((old_frm < 100 && new_frm > 100) || (old_frm > 100 && new_frm < 100))
-      new_frm = 100;
-
-    LIMIT(new_frm, 10, 999);
-
-    if (old_frm != new_frm) {
-      feedrate_percentage = new_frm;
-      encoderPosition = 0;
-      #if BOTH(HAS_BUZZER, BEEP_ON_FEEDRATE_CHANGE)
-        static millis_t next_beep;
-        #ifndef GOT_MS
-          const millis_t ms = millis();
+      // Dead zone at 100% feedrate
+      if (old_frm == 100) {
+        if (int16_t(encoderPosition) > ENCODER_FEEDRATE_DEADZONE)
+          new_frm -= ENCODER_FEEDRATE_DEADZONE;
+        else if (int16_t(encoderPosition) < -(ENCODER_FEEDRATE_DEADZONE))
+          new_frm += ENCODER_FEEDRATE_DEADZONE;
+        else
+          new_frm = old_frm;
+      }
+      else if ((old_frm < 100 && new_frm > 100) || (old_frm > 100 && new_frm < 100))
+        new_frm = 100;
+
+      LIMIT(new_frm, 10, 999);
+
+      if (old_frm != new_frm) {
+        feedrate_percentage = new_frm;
+        encoderPosition = 0;
+        #if BOTH(HAS_BUZZER, BEEP_ON_FEEDRATE_CHANGE)
+          static millis_t next_beep;
+          #ifndef GOT_MS
+            const millis_t ms = millis();
+          #endif
+          if (ELAPSED(ms, next_beep)) {
+            buzz(FEEDRATE_CHANGE_BEEP_DURATION, FEEDRATE_CHANGE_BEEP_FREQUENCY);
+            next_beep = ms + 500UL;
+          }
         #endif
-        if (ELAPSED(ms, next_beep)) {
-          buzz(FEEDRATE_CHANGE_BEEP_DURATION, FEEDRATE_CHANGE_BEEP_FREQUENCY);
-          next_beep = ms + 500UL;
-        }
-      #endif
-    }
+      }
 
-  #endif // ULTIPANEL_FEEDMULTIPLY
+    #endif // ULTIPANEL_FEEDMULTIPLY
 
-  draw_status_screen();
-}
+    draw_status_screen();
+  }
 
-void MarlinUI::kill_screen(PGM_P lcd_error, PGM_P lcd_component) {
-  init();
-  status_printf_P(1, PSTR(S_FMT ": " S_FMT), lcd_error, lcd_component);
-  TERN_(HAS_LCD_MENU, return_to_status());
+  void MarlinUI::kill_screen(PGM_P lcd_error, PGM_P lcd_component) {
+    init();
+    status_printf_P(1, PSTR(S_FMT ": " S_FMT), lcd_error, lcd_component);
+    TERN_(HAS_LCD_MENU, return_to_status());
 
-  // RED ALERT. RED ALERT.
-  #ifdef LED_BACKLIGHT_TIMEOUT
-    leds.set_color(LEDColorRed());
-    #ifdef NEOPIXEL_BKGD_INDEX_FIRST
-      neo.set_background_color(255, 0, 0, 0);
-      neo.show();
+    // RED ALERT. RED ALERT.
+    #ifdef LED_BACKLIGHT_TIMEOUT
+      leds.set_color(LEDColorRed());
+      #ifdef NEOPIXEL_BKGD_INDEX_FIRST
+        neo.set_background_color(255, 0, 0, 0);
+        neo.show();
+      #endif
     #endif
-  #endif
-
-  draw_kill_screen();
-}
 
-void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
+    draw_kill_screen();
+  }
 
-  TERN_(HAS_LCD_MENU, refresh());
+  void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
-  #if HAS_ENCODER_ACTION
-    if (clear_buttons) buttons = 0;
-    next_button_update_ms = millis() + 500;
-  #else
-    UNUSED(clear_buttons);
-  #endif
+    TERN_(HAS_LCD_MENU, refresh());
 
-  #if HAS_CHIRP
-    chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
-    #if BOTH(HAS_LCD_MENU, USE_BEEPER)
-      for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
-    #elif HAS_LCD_MENU
-      delay(10);
+    #if HAS_ENCODER_ACTION
+      if (clear_buttons) buttons = 0;
+      next_button_update_ms = millis() + 500;
+    #else
+      UNUSED(clear_buttons);
     #endif
-  #endif
-}
-
-////////////////////////////////////////////
-/////////////// Manual Move ////////////////
-////////////////////////////////////////////
-
-#if HAS_LCD_MENU
-
-  ManualMove MarlinUI::manual_move{};
 
-  millis_t ManualMove::start_time = 0;
-  float ManualMove::menu_scale = 1;
-  #if IS_KINEMATIC
-    float ManualMove::offset = 0;
-    xyze_pos_t ManualMove::all_axes_destination = { 0 };
-    bool ManualMove::processing = false;
-  #endif
-  #if MULTI_E_MANUAL
-    int8_t ManualMove::e_index = 0;
-  #endif
-  AxisEnum ManualMove::axis = NO_AXIS_ENUM;
-
-  /**
-   * If a manual move has been posted and its time has arrived, and if the planner
-   * has a space for it, then add a linear move to current_position the planner.
-   *
-   * If any manual move needs to be interrupted, make sure to force a manual move
-   * by setting manual_move.start_time to millis() after updating current_position.
-   *
-   * To post a manual move:
-   *   - Update current_position to the new place you want to go.
-   *   - Set manual_move.axis to an axis like X_AXIS. Use ALL_AXES_ENUM for diagonal moves.
-   *   - Set manual_move.start_time to a point in the future (in ms) when the move should be done.
-   *
-   * For kinematic machines:
-   *   - Set manual_move.offset to modify one axis and post the move.
-   *     This is used to achieve more rapid stepping on kinematic machines.
-   *
-   * Currently used by the _lcd_move_xyz function in menu_motion.cpp
-   * and the ubl_map_move_to_xy funtion in menu_ubl.cpp.
-   */
-  void ManualMove::task() {
-
-    if (processing) return;   // Prevent re-entry from idle() calls
+    #if HAS_CHIRP
+      chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
+      #if BOTH(HAS_LCD_MENU, USE_BEEPER)
+        for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
+      #elif HAS_LCD_MENU
+        delay(10);
+      #endif
+    #endif
+  }
 
-    // Add a manual move to the queue?
-    if (axis != NO_AXIS_ENUM && ELAPSED(millis(), start_time) && !planner.is_full()) {
+  ////////////////////////////////////////////
+  /////////////// Manual Move ////////////////
+  ////////////////////////////////////////////
 
-      const feedRate_t fr_mm_s = (axis <= LOGICAL_AXES) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
+  #if HAS_LCD_MENU
 
-      #if IS_KINEMATIC
+    ManualMove MarlinUI::manual_move{};
 
-        #if HAS_MULTI_EXTRUDER
-          REMEMBER(ae, active_extruder);
-          #if MULTI_E_MANUAL
-            if (axis == E_AXIS) active_extruder = e_index;
+    millis_t ManualMove::start_time = 0;
+    float ManualMove::menu_scale = 1;
+    #if IS_KINEMATIC
+      float ManualMove::offset = 0;
+      xyze_pos_t ManualMove::all_axes_destination = { 0 };
+      bool ManualMove::processing = false;
+    #endif
+    #if MULTI_E_MANUAL
+      int8_t ManualMove::e_index = 0;
+    #endif
+    AxisEnum ManualMove::axis = NO_AXIS_ENUM;
+
+    /**
+     * If a manual move has been posted and its time has arrived, and if the planner
+     * has a space for it, then add a linear move to current_position the planner.
+     *
+     * If any manual move needs to be interrupted, make sure to force a manual move
+     * by setting manual_move.start_time to millis() after updating current_position.
+     *
+     * To post a manual move:
+     *   - Update current_position to the new place you want to go.
+     *   - Set manual_move.axis to an axis like X_AXIS. Use ALL_AXES_ENUM for diagonal moves.
+     *   - Set manual_move.start_time to a point in the future (in ms) when the move should be done.
+     *
+     * For kinematic machines:
+     *   - Set manual_move.offset to modify one axis and post the move.
+     *     This is used to achieve more rapid stepping on kinematic machines.
+     *
+     * Currently used by the _lcd_move_xyz function in menu_motion.cpp
+     * and the ubl_map_move_to_xy funtion in menu_ubl.cpp.
+     */
+    void ManualMove::task() {
+
+      if (processing) return;   // Prevent re-entry from idle() calls
+
+      // Add a manual move to the queue?
+      if (axis != NO_AXIS_ENUM && ELAPSED(millis(), start_time) && !planner.is_full()) {
+
+        const feedRate_t fr_mm_s = (axis <= LOGICAL_AXES) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
+
+        #if IS_KINEMATIC
+
+          #if HAS_MULTI_EXTRUDER
+            REMEMBER(ae, active_extruder);
+            #if MULTI_E_MANUAL
+              if (axis == E_AXIS) active_extruder = e_index;
+            #endif
           #endif
-        #endif
 
-        // Apply a linear offset to a single axis
-        if (axis == ALL_AXES_ENUM)
-          destination = all_axes_destination;
-        else if (axis <= XYZE) {
-          destination = current_position;
-          destination[axis] += offset;
-        }
+          // Apply a linear offset to a single axis
+          if (axis == ALL_AXES_ENUM)
+            destination = all_axes_destination;
+          else if (axis <= XYZE) {
+            destination = current_position;
+            destination[axis] += offset;
+          }
 
-        // Reset for the next move
-        offset = 0;
-        axis = NO_AXIS_ENUM;
+          // Reset for the next move
+          offset = 0;
+          axis = NO_AXIS_ENUM;
 
-        // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
-        // move_to_destination. This will cause idle() to be called, which can then call this function while the
-        // previous invocation is being blocked. Modifications to offset shouldn't be made while
-        // processing is true or the planner will get out of sync.
-        processing = true;
-        prepare_internal_move_to_destination(fr_mm_s);  // will set current_position from destination
-        processing = false;
+          // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
+          // move_to_destination. This will cause idle() to be called, which can then call this function while the
+          // previous invocation is being blocked. Modifications to offset shouldn't be made while
+          // processing is true or the planner will get out of sync.
+          processing = true;
+          prepare_internal_move_to_destination(fr_mm_s);  // will set current_position from destination
+          processing = false;
 
-      #else
+        #else
 
-        // For Cartesian / Core motion simply move to the current_position
-        planner.buffer_line(current_position, fr_mm_s,
-          TERN_(MULTI_E_MANUAL, axis == E_AXIS ? e_index :) active_extruder
-        );
+          // For Cartesian / Core motion simply move to the current_position
+          planner.buffer_line(current_position, fr_mm_s,
+            TERN_(MULTI_E_MANUAL, axis == E_AXIS ? e_index :) active_extruder
+          );
 
-        //SERIAL_ECHOLNPAIR("Add planner.move with Axis ", AS_CHAR(axis_codes[axis]), " at FR ", fr_mm_s);
+          //SERIAL_ECHOLNPAIR("Add planner.move with Axis ", AS_CHAR(axis_codes[axis]), " at FR ", fr_mm_s);
 
-        axis = NO_AXIS_ENUM;
+          axis = NO_AXIS_ENUM;
 
-      #endif
+        #endif
+      }
     }
-  }
 
-  //
-  // Tell ui.update() to start a move to current_position after a short delay.
-  //
-  void ManualMove::soon(const AxisEnum move_axis
-    OPTARG(MULTI_E_MANUAL, const int8_t eindex/*=active_extruder*/)
-  ) {
-    TERN_(MULTI_E_MANUAL, if (move_axis == E_AXIS) e_index = eindex);
-    start_time = millis() + (menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
-    axis = move_axis;
-    //SERIAL_ECHOLNPAIR("Post Move with Axis ", AS_CHAR(axis_codes[axis]), " soon.");
-  }
+    //
+    // Tell ui.update() to start a move to current_position after a short delay.
+    //
+    void ManualMove::soon(const AxisEnum move_axis
+      OPTARG(MULTI_E_MANUAL, const int8_t eindex/*=active_extruder*/)
+    ) {
+      TERN_(MULTI_E_MANUAL, if (move_axis == E_AXIS) e_index = eindex);
+      start_time = millis() + (menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
+      axis = move_axis;
+      //SERIAL_ECHOLNPAIR("Post Move with Axis ", AS_CHAR(axis_codes[axis]), " soon.");
+    }
 
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
 
-    void MarlinUI::external_encoder() {
-      if (external_control && encoderDiff) {
-        ubl.encoder_diff += encoderDiff;  // Encoder for UBL G29 mesh editing
-        encoderDiff = 0;                  // Hide encoder events from the screen handler
-        refresh(LCDVIEW_REDRAW_NOW);      // ...but keep the refresh.
+      void MarlinUI::external_encoder() {
+        if (external_control && encoderDiff) {
+          ubl.encoder_diff += encoderDiff;  // Encoder for UBL G29 mesh editing
+          encoderDiff = 0;                  // Hide encoder events from the screen handler
+          refresh(LCDVIEW_REDRAW_NOW);      // ...but keep the refresh.
+        }
       }
-    }
 
-  #endif
+    #endif
 
-#endif // HAS_LCD_MENU
+  #endif // HAS_LCD_MENU
 
-/**
- * Update the LCD, read encoder buttons, etc.
- *   - Read button states
- *   - Check the SD Card slot state
- *   - Act on RepRap World keypad input
- *   - Update the encoder position
- *   - Apply acceleration to the encoder position
- *   - Do refresh(LCDVIEW_CALL_REDRAW_NOW) on controller events
- *   - Reset the Info Screen timeout if there's any input
- *   - Update status indicators, if any
- *
- *   Run the current LCD menu handler callback function:
- *   - Call the handler only if lcdDrawUpdate != LCDVIEW_NONE
- *   - Before calling the handler, LCDVIEW_CALL_NO_REDRAW => LCDVIEW_NONE
- *   - Call the menu handler. Menu handlers should do the following:
- *     - If a value changes, set lcdDrawUpdate to LCDVIEW_REDRAW_NOW and draw the value
- *       (Encoder events automatically set lcdDrawUpdate for you.)
- *     - if (should_draw()) { redraw }
- *     - Before exiting the handler set lcdDrawUpdate to:
- *       - LCDVIEW_CLEAR_CALL_REDRAW to clear screen and set LCDVIEW_CALL_REDRAW_NEXT.
- *       - LCDVIEW_REDRAW_NOW to draw now (including remaining stripes).
- *       - LCDVIEW_CALL_REDRAW_NEXT to draw now and get LCDVIEW_REDRAW_NOW on the next loop.
- *       - LCDVIEW_CALL_NO_REDRAW to draw now and get LCDVIEW_NONE on the next loop.
- *     - NOTE: For graphical displays menu handlers may be called 2 or more times per loop,
- *             so don't change lcdDrawUpdate without considering this.
- *
- *   After the menu handler callback runs (or not):
- *   - Clear the LCD if lcdDrawUpdate == LCDVIEW_CLEAR_CALL_REDRAW
- *   - Update lcdDrawUpdate for the next loop (i.e., move one state down, usually)
- *
- * This function is only called from the main thread.
- */
+  /**
+   * Update the LCD, read encoder buttons, etc.
+   *   - Read button states
+   *   - Check the SD Card slot state
+   *   - Act on RepRap World keypad input
+   *   - Update the encoder position
+   *   - Apply acceleration to the encoder position
+   *   - Do refresh(LCDVIEW_CALL_REDRAW_NOW) on controller events
+   *   - Reset the Info Screen timeout if there's any input
+   *   - Update status indicators, if any
+   *
+   *   Run the current LCD menu handler callback function:
+   *   - Call the handler only if lcdDrawUpdate != LCDVIEW_NONE
+   *   - Before calling the handler, LCDVIEW_CALL_NO_REDRAW => LCDVIEW_NONE
+   *   - Call the menu handler. Menu handlers should do the following:
+   *     - If a value changes, set lcdDrawUpdate to LCDVIEW_REDRAW_NOW and draw the value
+   *       (Encoder events automatically set lcdDrawUpdate for you.)
+   *     - if (should_draw()) { redraw }
+   *     - Before exiting the handler set lcdDrawUpdate to:
+   *       - LCDVIEW_CLEAR_CALL_REDRAW to clear screen and set LCDVIEW_CALL_REDRAW_NEXT.
+   *       - LCDVIEW_REDRAW_NOW to draw now (including remaining stripes).
+   *       - LCDVIEW_CALL_REDRAW_NEXT to draw now and get LCDVIEW_REDRAW_NOW on the next loop.
+   *       - LCDVIEW_CALL_NO_REDRAW to draw now and get LCDVIEW_NONE on the next loop.
+   *     - NOTE: For graphical displays menu handlers may be called 2 or more times per loop,
+   *             so don't change lcdDrawUpdate without considering this.
+   *
+   *   After the menu handler callback runs (or not):
+   *   - Clear the LCD if lcdDrawUpdate == LCDVIEW_CLEAR_CALL_REDRAW
+   *   - Update lcdDrawUpdate for the next loop (i.e., move one state down, usually)
+   *
+   * This function is only called from the main thread.
+   */
 
-LCDViewAction MarlinUI::lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
-millis_t next_lcd_update_ms;
+  LCDViewAction MarlinUI::lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+  millis_t next_lcd_update_ms;
 
-inline bool can_encode() {
-  return !BUTTON_PRESSED(ENC_EN); // Update encoder only when ENC_EN is not LOW (pressed)
-}
+  inline bool can_encode() {
+    return !BUTTON_PRESSED(ENC_EN); // Update encoder only when ENC_EN is not LOW (pressed)
+  }
 
-void MarlinUI::update() {
+  void MarlinUI::update() {
 
-  static uint16_t max_display_update_time = 0;
-  millis_t ms = millis();
+    static uint16_t max_display_update_time = 0;
+    millis_t ms = millis();
 
-  #ifdef LED_BACKLIGHT_TIMEOUT
-    leds.update_timeout(powersupply_on);
-  #endif
+    #ifdef LED_BACKLIGHT_TIMEOUT
+      leds.update_timeout(powersupply_on);
+    #endif
 
-  #if HAS_LCD_MENU
+    #if HAS_LCD_MENU
 
-    // Handle any queued Move Axis motion
-    manual_move.task();
+      // Handle any queued Move Axis motion
+      manual_move.task();
 
-    // Update button states for button_pressed(), etc.
-    // If the state changes the next update may be delayed 300-500ms.
-    update_buttons();
+      // Update button states for button_pressed(), etc.
+      // If the state changes the next update may be delayed 300-500ms.
+      update_buttons();
 
-    // If the action button is pressed...
-    static bool wait_for_unclick; // = false
+      // If the action button is pressed...
+      static bool wait_for_unclick; // = false
 
-    auto do_click = [&]{
-      wait_for_unclick = true;                        //  - Set debounce flag to ignore continuous clicks
-      lcd_clicked = !wait_for_user;                   //  - Keep the click if not waiting for a user-click
-      wait_for_user = false;                          //  - Any click clears wait for user
-      quick_feedback();                               //  - Always make a click sound
-    };
+      auto do_click = [&]{
+        wait_for_unclick = true;                        //  - Set debounce flag to ignore continuous clicks
+        lcd_clicked = !wait_for_user;                   //  - Keep the click if not waiting for a user-click
+        wait_for_user = false;                          //  - Any click clears wait for user
+        quick_feedback();                               //  - Always make a click sound
+      };
 
-    #if HAS_TOUCH_BUTTONS
-      if (touch_buttons) {
-        reset_status_timeout(ms);
-        if (touch_buttons & (EN_A | EN_B)) {              // Menu arrows, in priority
-          if (ELAPSED(ms, next_button_update_ms)) {
-            encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * epps * encoderDirection;
-            if (touch_buttons & EN_A) encoderDiff *= -1;
-            TERN_(AUTO_BED_LEVELING_UBL, external_encoder());
-            next_button_update_ms = ms + repeat_delay;    // Assume the repeat delay
-            if (!wait_for_unclick) {
-              next_button_update_ms += 250;               // Longer delay on first press
-              wait_for_unclick = true;                    // Avoid Back/Select click while repeating
-              chirp();
+      #if HAS_TOUCH_BUTTONS
+        if (touch_buttons) {
+          reset_status_timeout(ms);
+          if (touch_buttons & (EN_A | EN_B)) {              // Menu arrows, in priority
+            if (ELAPSED(ms, next_button_update_ms)) {
+              encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * epps * encoderDirection;
+              if (touch_buttons & EN_A) encoderDiff *= -1;
+              TERN_(AUTO_BED_LEVELING_UBL, external_encoder());
+              next_button_update_ms = ms + repeat_delay;    // Assume the repeat delay
+              if (!wait_for_unclick) {
+                next_button_update_ms += 250;               // Longer delay on first press
+                wait_for_unclick = true;                    // Avoid Back/Select click while repeating
+                chirp();
+              }
             }
           }
+          else if (!wait_for_unclick && (buttons & EN_C))   // OK button, if not waiting for a debounce release:
+            do_click();
         }
-        else if (!wait_for_unclick && (buttons & EN_C))   // OK button, if not waiting for a debounce release:
-          do_click();
-      }
-      // keep wait_for_unclick value
-    #endif
+        // keep wait_for_unclick value
+      #endif
 
-    if (!touch_buttons) {
-      // Integrated LCD click handling via button_pressed
-      if (!external_control && button_pressed()) {
-        if (!wait_for_unclick) do_click();              // Handle the click
+      if (!touch_buttons) {
+        // Integrated LCD click handling via button_pressed
+        if (!external_control && button_pressed()) {
+          if (!wait_for_unclick) do_click();              // Handle the click
+        }
+        else
+          wait_for_unclick = false;
       }
-      else
-        wait_for_unclick = false;
-    }
 
-    if (LCD_BACK_CLICKED()) {
-      quick_feedback();
-      goto_previous_screen();
-    }
+      if (LCD_BACK_CLICKED()) {
+        quick_feedback();
+        goto_previous_screen();
+      }
 
-  #endif // HAS_LCD_MENU
+    #endif // HAS_LCD_MENU
 
-  if (ELAPSED(ms, next_lcd_update_ms) || TERN0(HAS_MARLINUI_U8GLIB, drawing_screen)) {
+    if (ELAPSED(ms, next_lcd_update_ms) || TERN0(HAS_MARLINUI_U8GLIB, drawing_screen)) {
 
-    next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
+      next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
-    #if HAS_TOUCH_BUTTONS
+      #if HAS_TOUCH_BUTTONS
 
-      if (on_status_screen()) next_lcd_update_ms += (LCD_UPDATE_INTERVAL) * 2;
+        if (on_status_screen()) next_lcd_update_ms += (LCD_UPDATE_INTERVAL) * 2;
 
-      TERN_(HAS_ENCODER_ACTION, touch_buttons = touch.read_buttons());
+        TERN_(HAS_ENCODER_ACTION, touch_buttons = touch.read_buttons());
 
-    #endif
-
-    TERN_(LCD_HAS_STATUS_INDICATORS, update_indicators());
+      #endif
 
-    #if HAS_ENCODER_ACTION
+      TERN_(LCD_HAS_STATUS_INDICATORS, update_indicators());
 
-      TERN_(HAS_SLOW_BUTTONS, slow_buttons = read_slow_buttons()); // Buttons that take too long to read in interrupt context
+      #if HAS_ENCODER_ACTION
 
-      if (TERN0(IS_RRW_KEYPAD, handle_keypad()))
-        reset_status_timeout(ms);
+        TERN_(HAS_SLOW_BUTTONS, slow_buttons = read_slow_buttons()); // Buttons that take too long to read in interrupt context
 
-      uint8_t abs_diff = ABS(encoderDiff);
+        if (TERN0(IS_RRW_KEYPAD, handle_keypad()))
+          reset_status_timeout(ms);
 
-      #if ENCODER_PULSES_PER_STEP > 1
-        // When reversing the encoder direction, a movement step can be missed because
-        // encoderDiff has a non-zero residual value, making the controller unresponsive.
-        // The fix clears the residual value when the encoder is idle.
-        // Also check if past half the threshold to compensate for missed single steps.
-        static int8_t lastEncoderDiff;
+        uint8_t abs_diff = ABS(encoderDiff);
 
-        // Timeout? No decoder change since last check. 10 or 20 times per second.
-        if (encoderDiff == lastEncoderDiff && abs_diff <= epps / 2)   // Same direction & size but not over a half-step?
-          encoderDiff = 0;                                            // Clear residual pulses.
-        else if (WITHIN(abs_diff, epps / 2 + 1, epps - 1)) {          // Past half of threshold?
-          abs_diff = epps;                                            // Treat as a full step size
-          encoderDiff = (encoderDiff < 0 ? -1 : 1) * abs_diff;        // ...in the spin direction.
-        }
-        lastEncoderDiff = encoderDiff;
-      #endif
+        #if ENCODER_PULSES_PER_STEP > 1
+          // When reversing the encoder direction, a movement step can be missed because
+          // encoderDiff has a non-zero residual value, making the controller unresponsive.
+          // The fix clears the residual value when the encoder is idle.
+          // Also check if past half the threshold to compensate for missed single steps.
+          static int8_t lastEncoderDiff;
 
-      const bool encoderPastThreshold = (abs_diff >= epps);
-      if (encoderPastThreshold || lcd_clicked) {
-        if (encoderPastThreshold && TERN1(IS_TFTGLCD_PANEL, !external_control)) {
+          // Timeout? No decoder change since last check. 10 or 20 times per second.
+          if (encoderDiff == lastEncoderDiff && abs_diff <= epps / 2)   // Same direction & size but not over a half-step?
+            encoderDiff = 0;                                            // Clear residual pulses.
+          else if (WITHIN(abs_diff, epps / 2 + 1, epps - 1)) {          // Past half of threshold?
+            abs_diff = epps;                                            // Treat as a full step size
+            encoderDiff = (encoderDiff < 0 ? -1 : 1) * abs_diff;        // ...in the spin direction.
+          }
+          lastEncoderDiff = encoderDiff;
+        #endif
 
-          #if BOTH(HAS_LCD_MENU, ENCODER_RATE_MULTIPLIER)
+        const bool encoderPastThreshold = (abs_diff >= epps);
+        if (encoderPastThreshold || lcd_clicked) {
+          if (encoderPastThreshold && TERN1(IS_TFTGLCD_PANEL, !external_control)) {
 
-            int32_t encoderMultiplier = 1;
+            #if BOTH(HAS_LCD_MENU, ENCODER_RATE_MULTIPLIER)
 
-            if (encoderRateMultiplierEnabled) {
-              const float encoderMovementSteps = float(abs_diff) / epps;
+              int32_t encoderMultiplier = 1;
 
-              if (lastEncoderMovementMillis) {
-                // Note that the rate is always calculated between two passes through the
-                // loop and that the abs of the encoderDiff value is tracked.
-                const float encoderStepRate = encoderMovementSteps / float(ms - lastEncoderMovementMillis) * 1000;
+              if (encoderRateMultiplierEnabled) {
+                const float encoderMovementSteps = float(abs_diff) / epps;
 
-                if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
-                else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
+                if (lastEncoderMovementMillis) {
+                  // Note that the rate is always calculated between two passes through the
+                  // loop and that the abs of the encoderDiff value is tracked.
+                  const float encoderStepRate = encoderMovementSteps / float(ms - lastEncoderMovementMillis) * 1000;
 
-                // Enable to output the encoder steps per second value
-                //#define ENCODER_RATE_MULTIPLIER_DEBUG
-                #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
-                  SERIAL_ECHO_START();
-                  SERIAL_ECHOPAIR("Enc Step Rate: ", encoderStepRate);
-                  SERIAL_ECHOPAIR("  Multiplier: ", encoderMultiplier);
-                  SERIAL_ECHOPAIR("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
-                  SERIAL_ECHOPAIR("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
-                  SERIAL_EOL();
-                #endif
-              }
+                  if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
+                  else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
 
-              lastEncoderMovementMillis = ms;
-            } // encoderRateMultiplierEnabled
+                  // Enable to output the encoder steps per second value
+                  //#define ENCODER_RATE_MULTIPLIER_DEBUG
+                  #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
+                    SERIAL_ECHO_START();
+                    SERIAL_ECHOPAIR("Enc Step Rate: ", encoderStepRate);
+                    SERIAL_ECHOPAIR("  Multiplier: ", encoderMultiplier);
+                    SERIAL_ECHOPAIR("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
+                    SERIAL_ECHOPAIR("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
+                    SERIAL_EOL();
+                  #endif
+                }
 
-          #else
+                lastEncoderMovementMillis = ms;
+              } // encoderRateMultiplierEnabled
 
-            constexpr int32_t encoderMultiplier = 1;
+            #else
 
-          #endif // ENCODER_RATE_MULTIPLIER
+              constexpr int32_t encoderMultiplier = 1;
 
-          if (can_encode()) encoderPosition += (encoderDiff * encoderMultiplier) / epps;
+            #endif // ENCODER_RATE_MULTIPLIER
 
-          encoderDiff = 0;
-        }
+            if (can_encode()) encoderPosition += (encoderDiff * encoderMultiplier) / epps;
 
-        reset_status_timeout(ms);
+            encoderDiff = 0;
+          }
 
-        refresh(LCDVIEW_REDRAW_NOW);
+          reset_status_timeout(ms);
 
-        #ifdef LED_BACKLIGHT_TIMEOUT
-          if (!powersupply_on) leds.reset_timeout(ms);
-        #endif
-      }
+          refresh(LCDVIEW_REDRAW_NOW);
 
-    #endif
+          #ifdef LED_BACKLIGHT_TIMEOUT
+            if (!powersupply_on) leds.reset_timeout(ms);
+          #endif
+        }
 
-    // This runs every ~100ms when idling often enough.
-    // Instead of tracking changes just redraw the Status Screen once per second.
-    if (on_status_screen() && !lcd_status_update_delay--) {
-      lcd_status_update_delay = TERN(HAS_MARLINUI_U8GLIB, 12, 9);
-      if (max_display_update_time) max_display_update_time--;  // Be sure never go to a very big number
-      refresh(LCDVIEW_REDRAW_NOW);
-    }
+      #endif
 
-    #if BOTH(HAS_LCD_MENU, SCROLL_LONG_FILENAMES)
-      // If scrolling of long file names is enabled and we are in the sd card menu,
-      // cause a refresh to occur until all the text has scrolled into view.
-      if (currentScreen == menu_media && !lcd_status_update_delay--) {
-        lcd_status_update_delay = ++filename_scroll_pos >= filename_scroll_max ? 12 : 4; // Long delay at end and start
-        if (filename_scroll_pos > filename_scroll_max) filename_scroll_pos = 0;
+      // This runs every ~100ms when idling often enough.
+      // Instead of tracking changes just redraw the Status Screen once per second.
+      if (on_status_screen() && !lcd_status_update_delay--) {
+        lcd_status_update_delay = TERN(HAS_MARLINUI_U8GLIB, 12, 9);
+        if (max_display_update_time) max_display_update_time--;  // Be sure never go to a very big number
         refresh(LCDVIEW_REDRAW_NOW);
-        reset_status_timeout(ms);
       }
-    #endif
 
-    // Then we want to use only 50% of the time
-    const uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
-
-    if ((should_draw() || drawing_screen) && (!bbr2 || bbr2 > max_display_update_time)) {
-
-      // Change state of drawing flag between screen updates
-      if (!drawing_screen) switch (lcdDrawUpdate) {
-        case LCDVIEW_CALL_NO_REDRAW:
-          refresh(LCDVIEW_NONE);
-          break;
-        case LCDVIEW_CLEAR_CALL_REDRAW:
-        case LCDVIEW_CALL_REDRAW_NEXT:
+      #if BOTH(HAS_LCD_MENU, SCROLL_LONG_FILENAMES)
+        // If scrolling of long file names is enabled and we are in the sd card menu,
+        // cause a refresh to occur until all the text has scrolled into view.
+        if (currentScreen == menu_media && !lcd_status_update_delay--) {
+          lcd_status_update_delay = ++filename_scroll_pos >= filename_scroll_max ? 12 : 4; // Long delay at end and start
+          if (filename_scroll_pos > filename_scroll_max) filename_scroll_pos = 0;
           refresh(LCDVIEW_REDRAW_NOW);
-        case LCDVIEW_REDRAW_NOW:        // set above, or by a handler through LCDVIEW_CALL_REDRAW_NEXT
-        case LCDVIEW_NONE:
-          break;
-      } // switch
+          reset_status_timeout(ms);
+        }
+      #endif
 
-      TERN_(HAS_ADC_BUTTONS, keypad_buttons = 0);
+      // Then we want to use only 50% of the time
+      const uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
+
+      if ((should_draw() || drawing_screen) && (!bbr2 || bbr2 > max_display_update_time)) {
+
+        // Change state of drawing flag between screen updates
+        if (!drawing_screen) switch (lcdDrawUpdate) {
+          case LCDVIEW_CALL_NO_REDRAW:
+            refresh(LCDVIEW_NONE);
+            break;
+          case LCDVIEW_CLEAR_CALL_REDRAW:
+          case LCDVIEW_CALL_REDRAW_NEXT:
+            refresh(LCDVIEW_REDRAW_NOW);
+          case LCDVIEW_REDRAW_NOW:        // set above, or by a handler through LCDVIEW_CALL_REDRAW_NEXT
+          case LCDVIEW_NONE:
+            break;
+        } // switch
+
+        TERN_(HAS_ADC_BUTTONS, keypad_buttons = 0);
+
+        #if HAS_MARLINUI_U8GLIB
+
+          #if ENABLED(LIGHTWEIGHT_UI)
+            const bool in_status = on_status_screen(),
+                       do_u8g_loop = !in_status;
+            lcd_in_status(in_status);
+            if (in_status) status_screen();
+          #else
+            constexpr bool do_u8g_loop = true;
+          #endif
 
-      #if HAS_MARLINUI_U8GLIB
+          if (do_u8g_loop) {
+            if (!drawing_screen) {                // If not already drawing pages
+              u8g.firstPage();                    // Start the first page
+              drawing_screen = first_page = true; // Flag as drawing pages
+            }
+            set_font(FONT_MENU);                  // Setup font for every page draw
+            u8g.setColorIndex(1);                 // And reset the color
+            run_current_screen();                 // Draw and process the current screen
+            first_page = false;
+
+            // The screen handler can clear drawing_screen for an action that changes the screen.
+            // If still drawing and there's another page, update max-time and return now.
+            // The nextPage will already be set up on the next call.
+            if (drawing_screen && (drawing_screen = u8g.nextPage())) {
+              if (on_status_screen())
+                NOLESS(max_display_update_time, millis() - ms);
+              return;
+            }
+          }
 
-        #if ENABLED(LIGHTWEIGHT_UI)
-          const bool in_status = on_status_screen(),
-                     do_u8g_loop = !in_status;
-          lcd_in_status(in_status);
-          if (in_status) status_screen();
         #else
-          constexpr bool do_u8g_loop = true;
-        #endif
-
-        if (do_u8g_loop) {
-          if (!drawing_screen) {                // If not already drawing pages
-            u8g.firstPage();                    // Start the first page
-            drawing_screen = first_page = true; // Flag as drawing pages
-          }
-          set_font(FONT_MENU);                  // Setup font for every page draw
-          u8g.setColorIndex(1);                 // And reset the color
-          run_current_screen();                 // Draw and process the current screen
-          first_page = false;
-
-          // The screen handler can clear drawing_screen for an action that changes the screen.
-          // If still drawing and there's another page, update max-time and return now.
-          // The nextPage will already be set up on the next call.
-          if (drawing_screen && (drawing_screen = u8g.nextPage())) {
-            if (on_status_screen())
-              NOLESS(max_display_update_time, millis() - ms);
-            return;
-          }
-        }
 
-      #else
+          run_current_screen();
 
-        run_current_screen();
+        #endif
 
-      #endif
+        TERN_(HAS_LCD_MENU, lcd_clicked = false);
 
-      TERN_(HAS_LCD_MENU, lcd_clicked = false);
+        // Keeping track of the longest time for an individual LCD update.
+        // Used to do screen throttling when the planner starts to fill up.
+        if (on_status_screen())
+          NOLESS(max_display_update_time, millis() - ms);
+      }
 
-      // Keeping track of the longest time for an individual LCD update.
-      // Used to do screen throttling when the planner starts to fill up.
-      if (on_status_screen())
-        NOLESS(max_display_update_time, millis() - ms);
-    }
+      #if SCREENS_CAN_TIME_OUT
+        // Return to Status Screen after a timeout
+        if (on_status_screen() || defer_return_to_status)
+          reset_status_timeout(ms);
+        else if (ELAPSED(ms, return_to_status_ms))
+          return_to_status();
+      #endif
 
-    #if SCREENS_CAN_TIME_OUT
-      // Return to Status Screen after a timeout
-      if (on_status_screen() || defer_return_to_status)
-        reset_status_timeout(ms);
-      else if (ELAPSED(ms, return_to_status_ms))
-        return_to_status();
-    #endif
+      // Change state of drawing flag between screen updates
+      if (!drawing_screen) switch (lcdDrawUpdate) {
+        case LCDVIEW_CLEAR_CALL_REDRAW:
+          clear_lcd(); break;
+        case LCDVIEW_REDRAW_NOW:
+          refresh(LCDVIEW_NONE);
+        case LCDVIEW_NONE:
+        case LCDVIEW_CALL_REDRAW_NEXT:
+        case LCDVIEW_CALL_NO_REDRAW:
+        default: break;
+      } // switch
 
-    // Change state of drawing flag between screen updates
-    if (!drawing_screen) switch (lcdDrawUpdate) {
-      case LCDVIEW_CLEAR_CALL_REDRAW:
-        clear_lcd(); break;
-      case LCDVIEW_REDRAW_NOW:
-        refresh(LCDVIEW_NONE);
-      case LCDVIEW_NONE:
-      case LCDVIEW_CALL_REDRAW_NEXT:
-      case LCDVIEW_CALL_NO_REDRAW:
-      default: break;
-    } // switch
+    } // ELAPSED(ms, next_lcd_update_ms)
 
-  } // ELAPSED(ms, next_lcd_update_ms)
+    TERN_(HAS_GRAPHICAL_TFT, tft_idle());
+  }
 
-  TERN_(HAS_GRAPHICAL_TFT, tft_idle());
-}
+  #if HAS_ADC_BUTTONS
 
-#if HAS_ADC_BUTTONS
+    typedef struct {
+      uint16_t ADCKeyValueMin, ADCKeyValueMax;
+      uint8_t  ADCKeyNo;
+    } _stADCKeypadTable_;
 
-  typedef struct {
-    uint16_t ADCKeyValueMin, ADCKeyValueMax;
-    uint8_t  ADCKeyNo;
-  } _stADCKeypadTable_;
+    #ifndef ADC_BUTTONS_VALUE_SCALE
+      #define ADC_BUTTONS_VALUE_SCALE       1.0  // for the power voltage equal to the reference voltage
+    #endif
+    #ifndef ADC_BUTTONS_R_PULLUP
+      #define ADC_BUTTONS_R_PULLUP          4.7  // common pull-up resistor in the voltage divider
+    #endif
+    #ifndef ADC_BUTTONS_LEFT_R_PULLDOWN
+      #define ADC_BUTTONS_LEFT_R_PULLDOWN   0.47 // pull-down resistor for LEFT button voltage divider
+    #endif
+    #ifndef ADC_BUTTONS_RIGHT_R_PULLDOWN
+      #define ADC_BUTTONS_RIGHT_R_PULLDOWN  4.7  // pull-down resistor for RIGHT button voltage divider
+    #endif
+    #ifndef ADC_BUTTONS_UP_R_PULLDOWN
+      #define ADC_BUTTONS_UP_R_PULLDOWN     1.0  // pull-down resistor for UP button voltage divider
+    #endif
+    #ifndef ADC_BUTTONS_DOWN_R_PULLDOWN
+      #define ADC_BUTTONS_DOWN_R_PULLDOWN   10.0 // pull-down resistor for DOWN button voltage divider
+    #endif
+    #ifndef ADC_BUTTONS_MIDDLE_R_PULLDOWN
+      #define ADC_BUTTONS_MIDDLE_R_PULLDOWN 2.2  // pull-down resistor for MIDDLE button voltage divider
+    #endif
 
-  #ifndef ADC_BUTTONS_VALUE_SCALE
-    #define ADC_BUTTONS_VALUE_SCALE       1.0  // for the power voltage equal to the reference voltage
-  #endif
-  #ifndef ADC_BUTTONS_R_PULLUP
-    #define ADC_BUTTONS_R_PULLUP          4.7  // common pull-up resistor in the voltage divider
-  #endif
-  #ifndef ADC_BUTTONS_LEFT_R_PULLDOWN
-    #define ADC_BUTTONS_LEFT_R_PULLDOWN   0.47 // pull-down resistor for LEFT button voltage divider
-  #endif
-  #ifndef ADC_BUTTONS_RIGHT_R_PULLDOWN
-    #define ADC_BUTTONS_RIGHT_R_PULLDOWN  4.7  // pull-down resistor for RIGHT button voltage divider
-  #endif
-  #ifndef ADC_BUTTONS_UP_R_PULLDOWN
-    #define ADC_BUTTONS_UP_R_PULLDOWN     1.0  // pull-down resistor for UP button voltage divider
-  #endif
-  #ifndef ADC_BUTTONS_DOWN_R_PULLDOWN
-    #define ADC_BUTTONS_DOWN_R_PULLDOWN   10.0 // pull-down resistor for DOWN button voltage divider
-  #endif
-  #ifndef ADC_BUTTONS_MIDDLE_R_PULLDOWN
-    #define ADC_BUTTONS_MIDDLE_R_PULLDOWN 2.2  // pull-down resistor for MIDDLE button voltage divider
-  #endif
+    // Calculate the ADC value for the voltage divider with specified pull-down resistor value
+    #define ADC_BUTTON_VALUE(r)  int(HAL_ADC_RANGE * (ADC_BUTTONS_VALUE_SCALE) * r / (r + ADC_BUTTONS_R_PULLUP))
+
+    static constexpr uint16_t adc_button_tolerance = HAL_ADC_RANGE *   25 / 1024,
+                                  adc_other_button = HAL_ADC_RANGE * 1000 / 1024;
+    static const _stADCKeypadTable_ stADCKeyTable[] PROGMEM = {
+      // VALUE_MIN, VALUE_MAX, KEY
+      { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F1     }, // F1
+      { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F2     }, // F2
+      { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F3     }, // F3
+      {  ADC_BUTTON_VALUE(ADC_BUTTONS_LEFT_R_PULLDOWN)   - adc_button_tolerance,
+         ADC_BUTTON_VALUE(ADC_BUTTONS_LEFT_R_PULLDOWN)   + adc_button_tolerance, 1 + BLEN_KEYPAD_LEFT   }, // LEFT  ( 272 ...  472)
+      {  ADC_BUTTON_VALUE(ADC_BUTTONS_RIGHT_R_PULLDOWN)  - adc_button_tolerance,
+         ADC_BUTTON_VALUE(ADC_BUTTONS_RIGHT_R_PULLDOWN)  + adc_button_tolerance, 1 + BLEN_KEYPAD_RIGHT  }, // RIGHT (1948 ... 2148)
+      {  ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     - adc_button_tolerance,
+         ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     + adc_button_tolerance, 1 + BLEN_KEYPAD_UP     }, // UP    ( 618 ...  818)
+      {  ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   - adc_button_tolerance,
+         ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   + adc_button_tolerance, 1 + BLEN_KEYPAD_DOWN   }, // DOWN  (2686 ... 2886)
+      {  ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) - adc_button_tolerance,
+         ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) + adc_button_tolerance, 1 + BLEN_KEYPAD_MIDDLE }, // ENTER (1205 ... 1405)
+    };
 
-  // Calculate the ADC value for the voltage divider with specified pull-down resistor value
-  #define ADC_BUTTON_VALUE(r)  int(HAL_ADC_RANGE * (ADC_BUTTONS_VALUE_SCALE) * r / (r + ADC_BUTTONS_R_PULLUP))
-
-  static constexpr uint16_t adc_button_tolerance = HAL_ADC_RANGE *   25 / 1024,
-                                adc_other_button = HAL_ADC_RANGE * 1000 / 1024;
-  static const _stADCKeypadTable_ stADCKeyTable[] PROGMEM = {
-    // VALUE_MIN, VALUE_MAX, KEY
-    { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F1     }, // F1
-    { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F2     }, // F2
-    { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F3     }, // F3
-    {  ADC_BUTTON_VALUE(ADC_BUTTONS_LEFT_R_PULLDOWN)   - adc_button_tolerance,
-       ADC_BUTTON_VALUE(ADC_BUTTONS_LEFT_R_PULLDOWN)   + adc_button_tolerance, 1 + BLEN_KEYPAD_LEFT   }, // LEFT  ( 272 ...  472)
-    {  ADC_BUTTON_VALUE(ADC_BUTTONS_RIGHT_R_PULLDOWN)  - adc_button_tolerance,
-       ADC_BUTTON_VALUE(ADC_BUTTONS_RIGHT_R_PULLDOWN)  + adc_button_tolerance, 1 + BLEN_KEYPAD_RIGHT  }, // RIGHT (1948 ... 2148)
-    {  ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     - adc_button_tolerance,
-       ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     + adc_button_tolerance, 1 + BLEN_KEYPAD_UP     }, // UP    ( 618 ...  818)
-    {  ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   - adc_button_tolerance,
-       ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   + adc_button_tolerance, 1 + BLEN_KEYPAD_DOWN   }, // DOWN  (2686 ... 2886)
-    {  ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) - adc_button_tolerance,
-       ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) + adc_button_tolerance, 1 + BLEN_KEYPAD_MIDDLE }, // ENTER (1205 ... 1405)
-  };
-
-  uint8_t get_ADC_keyValue() {
-    if (thermalManager.ADCKey_count >= 16) {
-      const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw;
-      thermalManager.current_ADCKey_raw = HAL_ADC_RANGE;
-      thermalManager.ADCKey_count = 0;
-      if (currentkpADCValue < adc_other_button)
-        LOOP_L_N(i, ADC_KEY_NUM) {
-          const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
-                         hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
-          if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
-        }
+    uint8_t get_ADC_keyValue() {
+      if (thermalManager.ADCKey_count >= 16) {
+        const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw;
+        thermalManager.current_ADCKey_raw = HAL_ADC_RANGE;
+        thermalManager.ADCKey_count = 0;
+        if (currentkpADCValue < adc_other_button)
+          LOOP_L_N(i, ADC_KEY_NUM) {
+            const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
+                           hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
+            if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
+          }
+      }
+      return 0;
     }
-    return 0;
-  }
 
-#endif // HAS_ADC_BUTTONS
+  #endif // HAS_ADC_BUTTONS
 
-#if HAS_ENCODER_ACTION
+  #if HAS_ENCODER_ACTION
 
-  /**
-   * Read encoder buttons from the hardware registers
-   * Warning: This function is called from interrupt context!
-   */
-  void MarlinUI::update_buttons() {
-    const millis_t now = millis();
-    if (ELAPSED(now, next_button_update_ms)) {
+    /**
+     * Read encoder buttons from the hardware registers
+     * Warning: This function is called from interrupt context!
+     */
+    void MarlinUI::update_buttons() {
+      const millis_t now = millis();
+      if (ELAPSED(now, next_button_update_ms)) {
 
-      #if HAS_DIGITAL_BUTTONS
+        #if HAS_DIGITAL_BUTTONS
 
-        #if ANY_BUTTON(EN1, EN2, ENC, BACK)
+          #if ANY_BUTTON(EN1, EN2, ENC, BACK)
 
-          uint8_t newbutton = 0;
-          if (BUTTON_PRESSED(EN1))                 newbutton |= EN_A;
-          if (BUTTON_PRESSED(EN2))                 newbutton |= EN_B;
-          if (can_encode() && BUTTON_PRESSED(ENC)) newbutton |= EN_C;
-          if (BUTTON_PRESSED(BACK))                newbutton |= EN_D;
+            uint8_t newbutton = 0;
+            if (BUTTON_PRESSED(EN1))                 newbutton |= EN_A;
+            if (BUTTON_PRESSED(EN2))                 newbutton |= EN_B;
+            if (can_encode() && BUTTON_PRESSED(ENC)) newbutton |= EN_C;
+            if (BUTTON_PRESSED(BACK))                newbutton |= EN_D;
 
-        #else
+          #else
 
-          constexpr uint8_t newbutton = 0;
+            constexpr uint8_t newbutton = 0;
 
-        #endif
+          #endif
 
-        //
-        // Directional buttons
-        //
-        #if ANY_BUTTON(UP, DWN, LFT, RT)
+          //
+          // Directional buttons
+          //
+          #if ANY_BUTTON(UP, DWN, LFT, RT)
 
-          const int8_t pulses = epps * encoderDirection;
+            const int8_t pulses = epps * encoderDirection;
 
-          if (BUTTON_PRESSED(UP)) {
-            encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * pulses;
-            next_button_update_ms = now + 300;
-          }
-          else if (BUTTON_PRESSED(DWN)) {
-            encoderDiff = -(ENCODER_STEPS_PER_MENU_ITEM) * pulses;
-            next_button_update_ms = now + 300;
-          }
-          else if (BUTTON_PRESSED(LFT)) {
-            encoderDiff = -pulses;
-            next_button_update_ms = now + 300;
-          }
-          else if (BUTTON_PRESSED(RT)) {
-            encoderDiff = pulses;
-            next_button_update_ms = now + 300;
-          }
+            if (BUTTON_PRESSED(UP)) {
+              encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * pulses;
+              next_button_update_ms = now + 300;
+            }
+            else if (BUTTON_PRESSED(DWN)) {
+              encoderDiff = -(ENCODER_STEPS_PER_MENU_ITEM) * pulses;
+              next_button_update_ms = now + 300;
+            }
+            else if (BUTTON_PRESSED(LFT)) {
+              encoderDiff = -pulses;
+              next_button_update_ms = now + 300;
+            }
+            else if (BUTTON_PRESSED(RT)) {
+              encoderDiff = pulses;
+              next_button_update_ms = now + 300;
+            }
 
-        #endif // UP || DWN || LFT || RT
+          #endif // UP || DWN || LFT || RT
 
-        buttons = (newbutton | TERN0(HAS_SLOW_BUTTONS, slow_buttons)
-          #if BOTH(HAS_TOUCH_BUTTONS, HAS_ENCODER_ACTION)
-            | (touch_buttons & TERN(HAS_ENCODER_WHEEL, ~(EN_A | EN_B), 0xFF))
-          #endif
-        );
+          buttons = (newbutton | TERN0(HAS_SLOW_BUTTONS, slow_buttons)
+            #if BOTH(HAS_TOUCH_BUTTONS, HAS_ENCODER_ACTION)
+              | (touch_buttons & TERN(HAS_ENCODER_WHEEL, ~(EN_A | EN_B), 0xFF))
+            #endif
+          );
 
-      #elif HAS_ADC_BUTTONS
+        #elif HAS_ADC_BUTTONS
 
-        buttons = 0;
+          buttons = 0;
 
-      #endif
+        #endif
 
-      #if HAS_ADC_BUTTONS
-        if (keypad_buttons == 0) {
-          const uint8_t b = get_ADC_keyValue();
-          if (WITHIN(b, 1, 8)) keypad_buttons = _BV(b - 1);
-        }
-      #endif
+        #if HAS_ADC_BUTTONS
+          if (keypad_buttons == 0) {
+            const uint8_t b = get_ADC_keyValue();
+            if (WITHIN(b, 1, 8)) keypad_buttons = _BV(b - 1);
+          }
+        #endif
 
-      #if HAS_SHIFT_ENCODER
-        /**
-         * Set up Rotary Encoder bit values (for two pin encoders to indicate movement).
-         * These values are independent of which pins are used for EN_A / EN_B indications.
-         * The rotary encoder part is also independent of the LCD chipset.
-         */
-        uint8_t val = 0;
-        WRITE(SHIFT_LD_PIN, LOW);
-        WRITE(SHIFT_LD_PIN, HIGH);
-        LOOP_L_N(i, 8) {
-          val >>= 1;
-          if (READ(SHIFT_OUT_PIN)) SBI(val, 7);
-          WRITE(SHIFT_CLK_PIN, HIGH);
-          WRITE(SHIFT_CLK_PIN, LOW);
-        }
-        TERN(REPRAPWORLD_KEYPAD, keypad_buttons, buttons) = ~val;
-      #endif
+        #if HAS_SHIFT_ENCODER
+          /**
+           * Set up Rotary Encoder bit values (for two pin encoders to indicate movement).
+           * These values are independent of which pins are used for EN_A / EN_B indications.
+           * The rotary encoder part is also independent of the LCD chipset.
+           */
+          uint8_t val = 0;
+          WRITE(SHIFT_LD_PIN, LOW);
+          WRITE(SHIFT_LD_PIN, HIGH);
+          LOOP_L_N(i, 8) {
+            val >>= 1;
+            if (READ(SHIFT_OUT_PIN)) SBI(val, 7);
+            WRITE(SHIFT_CLK_PIN, HIGH);
+            WRITE(SHIFT_CLK_PIN, LOW);
+          }
+          TERN(REPRAPWORLD_KEYPAD, keypad_buttons, buttons) = ~val;
+        #endif
 
-      #if IS_TFTGLCD_PANEL
-        next_button_update_ms = now + (LCD_UPDATE_INTERVAL / 2);
-        buttons = slow_buttons;
-        TERN_(AUTO_BED_LEVELING_UBL, external_encoder());
-      #endif
+        #if IS_TFTGLCD_PANEL
+          next_button_update_ms = now + (LCD_UPDATE_INTERVAL / 2);
+          buttons = slow_buttons;
+          TERN_(AUTO_BED_LEVELING_UBL, external_encoder());
+        #endif
 
-    } // next_button_update_ms
+      } // next_button_update_ms
 
-    #if HAS_ENCODER_WHEEL
-      static uint8_t lastEncoderBits;
+      #if HAS_ENCODER_WHEEL
+        static uint8_t lastEncoderBits;
 
-      // Manage encoder rotation
-      #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: encoderDiff += encoderDirection; break; case _E2: encoderDiff -= encoderDirection; }
+        // Manage encoder rotation
+        #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: encoderDiff += encoderDirection; break; case _E2: encoderDiff -= encoderDirection; }
 
-      uint8_t enc = 0;
-      if (buttons & EN_A) enc |= B01;
-      if (buttons & EN_B) enc |= B10;
-      if (enc != lastEncoderBits) {
-        switch (enc) {
-          case ENCODER_PHASE_0: ENCODER_SPIN(ENCODER_PHASE_3, ENCODER_PHASE_1); break;
-          case ENCODER_PHASE_1: ENCODER_SPIN(ENCODER_PHASE_0, ENCODER_PHASE_2); break;
-          case ENCODER_PHASE_2: ENCODER_SPIN(ENCODER_PHASE_1, ENCODER_PHASE_3); break;
-          case ENCODER_PHASE_3: ENCODER_SPIN(ENCODER_PHASE_2, ENCODER_PHASE_0); break;
+        uint8_t enc = 0;
+        if (buttons & EN_A) enc |= B01;
+        if (buttons & EN_B) enc |= B10;
+        if (enc != lastEncoderBits) {
+          switch (enc) {
+            case ENCODER_PHASE_0: ENCODER_SPIN(ENCODER_PHASE_3, ENCODER_PHASE_1); break;
+            case ENCODER_PHASE_1: ENCODER_SPIN(ENCODER_PHASE_0, ENCODER_PHASE_2); break;
+            case ENCODER_PHASE_2: ENCODER_SPIN(ENCODER_PHASE_1, ENCODER_PHASE_3); break;
+            case ENCODER_PHASE_3: ENCODER_SPIN(ENCODER_PHASE_2, ENCODER_PHASE_0); break;
+          }
+          #if BOTH(HAS_LCD_MENU, AUTO_BED_LEVELING_UBL)
+            external_encoder();
+          #endif
+          lastEncoderBits = enc;
         }
-        #if BOTH(HAS_LCD_MENU, AUTO_BED_LEVELING_UBL)
-          external_encoder();
-        #endif
-        lastEncoderBits = enc;
-      }
 
-    #endif // HAS_ENCODER_WHEEL
-  }
+      #endif // HAS_ENCODER_WHEEL
+    }
 
-#endif // HAS_ENCODER_ACTION
+  #endif // HAS_ENCODER_ACTION
 
 #endif // HAS_WIRED_LCD
 

commit f9051e5469cdd99bcb93bc46124e95984c279984
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 27 00:33:44 2021 -0500

    ♻️ Refactor status screen timeout

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 08b214ac56..67e5adc0f0 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -165,8 +165,9 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   #endif
 #endif
 
-#if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
+#if SCREENS_CAN_TIME_OUT
   bool MarlinUI::defer_return_to_status;
+  millis_t MarlinUI::return_to_status_ms = 0;
 #endif
 
 uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
@@ -815,9 +816,6 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
 LCDViewAction MarlinUI::lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
 millis_t next_lcd_update_ms;
-#if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
-  millis_t MarlinUI::return_to_status_ms = 0;
-#endif
 
 inline bool can_encode() {
   return !BUTTON_PRESSED(ENC_EN); // Update encoder only when ENC_EN is not LOW (pressed)
@@ -828,12 +826,6 @@ void MarlinUI::update() {
   static uint16_t max_display_update_time = 0;
   millis_t ms = millis();
 
-  #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
-    #define RESET_STATUS_TIMEOUT() (return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS)
-  #else
-    #define RESET_STATUS_TIMEOUT() NOOP
-  #endif
-
   #ifdef LED_BACKLIGHT_TIMEOUT
     leds.update_timeout(powersupply_on);
   #endif
@@ -859,7 +851,7 @@ void MarlinUI::update() {
 
     #if HAS_TOUCH_BUTTONS
       if (touch_buttons) {
-        RESET_STATUS_TIMEOUT();
+        reset_status_timeout(ms);
         if (touch_buttons & (EN_A | EN_B)) {              // Menu arrows, in priority
           if (ELAPSED(ms, next_button_update_ms)) {
             encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * epps * encoderDirection;
@@ -914,7 +906,7 @@ void MarlinUI::update() {
       TERN_(HAS_SLOW_BUTTONS, slow_buttons = read_slow_buttons()); // Buttons that take too long to read in interrupt context
 
       if (TERN0(IS_RRW_KEYPAD, handle_keypad()))
-        RESET_STATUS_TIMEOUT();
+        reset_status_timeout(ms);
 
       uint8_t abs_diff = ABS(encoderDiff);
 
@@ -980,7 +972,7 @@ void MarlinUI::update() {
           encoderDiff = 0;
         }
 
-        RESET_STATUS_TIMEOUT();
+        reset_status_timeout(ms);
 
         refresh(LCDVIEW_REDRAW_NOW);
 
@@ -1006,7 +998,7 @@ void MarlinUI::update() {
         lcd_status_update_delay = ++filename_scroll_pos >= filename_scroll_max ? 12 : 4; // Long delay at end and start
         if (filename_scroll_pos > filename_scroll_max) filename_scroll_pos = 0;
         refresh(LCDVIEW_REDRAW_NOW);
-        RESET_STATUS_TIMEOUT();
+        reset_status_timeout(ms);
       }
     #endif
 
@@ -1075,10 +1067,10 @@ void MarlinUI::update() {
         NOLESS(max_display_update_time, millis() - ms);
     }
 
-    #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
+    #if SCREENS_CAN_TIME_OUT
       // Return to Status Screen after a timeout
       if (on_status_screen() || defer_return_to_status)
-        RESET_STATUS_TIMEOUT();
+        reset_status_timeout(ms);
       else if (ELAPSED(ms, return_to_status_ms))
         return_to_status();
     #endif

commit a37cc76cb93c4e8c1337ec8ecd8f966b0c33d555
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Fri Jun 25 22:38:27 2021 -0600

    🎨 Fix and improve FTDI Eve Touch UI (#22223)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 9de8941ad9..08b214ac56 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1616,8 +1616,9 @@ void MarlinUI::update() {
 
     if (status) {
       if (old_status < 2) {
-        TERN_(EXTENSIBLE_UI, ExtUI::onMediaInserted()); // ExtUI response
-        #if ENABLED(BROWSE_MEDIA_ON_INSERT)
+        #if ENABLED(EXTENSIBLE_UI)
+          ExtUI::onMediaInserted();
+        #elif ENABLED(BROWSE_MEDIA_ON_INSERT)
           clear_menu_history();
           quick_feedback();
           goto_screen(MEDIA_MENU_GATEWAY);
@@ -1628,8 +1629,9 @@ void MarlinUI::update() {
     }
     else {
       if (old_status < 2) {
-        TERN_(EXTENSIBLE_UI, ExtUI::onMediaRemoved()); // ExtUI response
-        #if PIN_EXISTS(SD_DETECT)
+        #if ENABLED(EXTENSIBLE_UI)
+          ExtUI::onMediaRemoved();
+        #elif PIN_EXISTS(SD_DETECT)
           LCD_MESSAGEPGM(MSG_MEDIA_REMOVED);
           #if HAS_LCD_MENU
             if (!defer_return_to_status) return_to_status();

commit 0bd113b944d041192146692de50e33fe4d6c0fd8
Author: Cytown <cytown@gmail.com>
Date:   Thu Jun 24 00:40:32 2021 +0800

    ✨ Power-off confirm / beep options (#22191)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index d2e26afedf..9de8941ad9 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1494,6 +1494,13 @@ void MarlinUI::update() {
     TERN_(HAS_LCD_MENU, return_to_status());
   }
 
+  #if BOTH(PSU_CONTROL, PS_OFF_CONFIRM)
+    void MarlinUI::poweroff() {
+      queue.inject_P(PSTR("M81"));
+      goto_previous_screen();
+    }
+  #endif
+
   void MarlinUI::flow_fault() {
     LCD_ALERTMESSAGEPGM(MSG_FLOWMETER_FAULT);
     TERN_(HAS_BUZZER, buzz(1000, 440));

commit a3e8bb99e472042c7db0b2d0be8d515ee715cf28
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jun 13 23:08:46 2021 -0400

    🎨 ExtUI "user click" and other tweaks (#22122)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index cff6e19354..d2e26afedf 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -223,6 +223,10 @@ millis_t MarlinUI::next_button_update_ms; // = 0
 
 #endif
 
+#if EITHER(HAS_LCD_MENU, EXTENSIBLE_UI)
+  bool MarlinUI::lcd_clicked;
+#endif
+
 #if HAS_LCD_MENU
   #include "menu/menu.h"
 
@@ -247,14 +251,6 @@ millis_t MarlinUI::next_button_update_ms; // = 0
     uint8_t MarlinUI::repeat_delay;
   #endif
 
-  bool MarlinUI::lcd_clicked;
-
-  bool MarlinUI::use_click() {
-    const bool click = lcd_clicked;
-    lcd_clicked = false;
-    return click;
-  }
-
   #if EITHER(AUTO_BED_LEVELING_UBL, G26_MESH_VALIDATION)
 
     bool MarlinUI::external_control; // = false

commit e60c38b6220678b3b9f3a3b31516852f8d25b3b0
Author: ellensp <ellensp@hotmail.com>
Date:   Wed May 26 11:38:23 2021 +1200

    ♻️ LEDs refactor and extend (#21962)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 044a6642fc..cff6e19354 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -636,8 +636,8 @@ void MarlinUI::kill_screen(PGM_P lcd_error, PGM_P lcd_component) {
   // RED ALERT. RED ALERT.
   #ifdef LED_BACKLIGHT_TIMEOUT
     leds.set_color(LEDColorRed());
-    #ifdef NEOPIXEL_BKGD_LED_INDEX
-      neo.set_pixel_color(NEOPIXEL_BKGD_LED_INDEX, 255, 0, 0, 0);
+    #ifdef NEOPIXEL_BKGD_INDEX_FIRST
+      neo.set_background_color(255, 0, 0, 0);
       neo.show();
     #endif
   #endif

commit dd4990252e891cdfe56cb7d6e3bbe1e6289be649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 24 16:38:57 2021 -0500

    ♻️ Refactor Linear / Logical / Distinct Axes (#21953)
    
    * More patches supporting EXTRUDERS 0
    * Extend types in prep for more axes

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index ba3abc0e2d..044a6642fc 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -712,13 +712,15 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
     // Add a manual move to the queue?
     if (axis != NO_AXIS_ENUM && ELAPSED(millis(), start_time) && !planner.is_full()) {
 
-      const feedRate_t fr_mm_s = (axis <= E_AXIS) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
+      const feedRate_t fr_mm_s = (axis <= LOGICAL_AXES) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
 
       #if IS_KINEMATIC
 
         #if HAS_MULTI_EXTRUDER
           REMEMBER(ae, active_extruder);
-          if (axis == E_AXIS) active_extruder = e_index;
+          #if MULTI_E_MANUAL
+            if (axis == E_AXIS) active_extruder = e_index;
+          #endif
         #endif
 
         // Apply a linear offset to a single axis
@@ -744,7 +746,9 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
       #else
 
         // For Cartesian / Core motion simply move to the current_position
-        planner.buffer_line(current_position, fr_mm_s, axis == E_AXIS ? e_index : active_extruder);
+        planner.buffer_line(current_position, fr_mm_s,
+          TERN_(MULTI_E_MANUAL, axis == E_AXIS ? e_index :) active_extruder
+        );
 
         //SERIAL_ECHOLNPAIR("Add planner.move with Axis ", AS_CHAR(axis_codes[axis]), " at FR ", fr_mm_s);
 

commit 84fd0eff17d089e3f75f6585d4bba47f15c00ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 23 21:33:22 2021 -0500

    🎨 Macros for optional arguments (#21969)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 14959851fa..ba3abc0e2d 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -758,13 +758,9 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
   // Tell ui.update() to start a move to current_position after a short delay.
   //
   void ManualMove::soon(const AxisEnum move_axis
-    #if MULTI_E_MANUAL
-      , const int8_t eindex/*=-1*/
-    #endif
+    OPTARG(MULTI_E_MANUAL, const int8_t eindex/*=active_extruder*/)
   ) {
-    #if MULTI_E_MANUAL
-      if (move_axis == E_AXIS) e_index = eindex >= 0 ? eindex : active_extruder;
-    #endif
+    TERN_(MULTI_E_MANUAL, if (move_axis == E_AXIS) e_index = eindex);
     start_time = millis() + (menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
     axis = move_axis;
     //SERIAL_ECHOLNPAIR("Post Move with Axis ", AS_CHAR(axis_codes[axis]), " soon.");

commit ad30909a2d45a37c3a689a7080ca346f3cb75c5f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 21 08:24:38 2021 -0500

    🎨 Update a condition

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index c99fa41657..14959851fa 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -681,7 +681,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
     xyze_pos_t ManualMove::all_axes_destination = { 0 };
     bool ManualMove::processing = false;
   #endif
-  #if ENABLED(MULTI_E_MANUAL)
+  #if MULTI_E_MANUAL
     int8_t ManualMove::e_index = 0;
   #endif
   AxisEnum ManualMove::axis = NO_AXIS_ENUM;

commit f4951ed56b3fe7b2f85c039677dc9a499d537e8f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 21 08:25:54 2021 -0500

    🎨 Rename all/no axis enums

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 544cc5eb2c..c99fa41657 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -684,7 +684,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
   #if ENABLED(MULTI_E_MANUAL)
     int8_t ManualMove::e_index = 0;
   #endif
-  AxisEnum ManualMove::axis = NO_AXIS_MASK;
+  AxisEnum ManualMove::axis = NO_AXIS_ENUM;
 
   /**
    * If a manual move has been posted and its time has arrived, and if the planner
@@ -695,7 +695,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
    *
    * To post a manual move:
    *   - Update current_position to the new place you want to go.
-   *   - Set manual_move.axis to an axis like X_AXIS. Use ALL_AXES_MASK for diagonal moves.
+   *   - Set manual_move.axis to an axis like X_AXIS. Use ALL_AXES_ENUM for diagonal moves.
    *   - Set manual_move.start_time to a point in the future (in ms) when the move should be done.
    *
    * For kinematic machines:
@@ -710,7 +710,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
     if (processing) return;   // Prevent re-entry from idle() calls
 
     // Add a manual move to the queue?
-    if (axis != NO_AXIS_MASK && ELAPSED(millis(), start_time) && !planner.is_full()) {
+    if (axis != NO_AXIS_ENUM && ELAPSED(millis(), start_time) && !planner.is_full()) {
 
       const feedRate_t fr_mm_s = (axis <= E_AXIS) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
 
@@ -722,7 +722,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
         #endif
 
         // Apply a linear offset to a single axis
-        if (axis == ALL_AXES_MASK)
+        if (axis == ALL_AXES_ENUM)
           destination = all_axes_destination;
         else if (axis <= XYZE) {
           destination = current_position;
@@ -731,7 +731,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
         // Reset for the next move
         offset = 0;
-        axis = NO_AXIS_MASK;
+        axis = NO_AXIS_ENUM;
 
         // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
         // move_to_destination. This will cause idle() to be called, which can then call this function while the
@@ -748,7 +748,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
         //SERIAL_ECHOLNPAIR("Add planner.move with Axis ", AS_CHAR(axis_codes[axis]), " at FR ", fr_mm_s);
 
-        axis = NO_AXIS_MASK;
+        axis = NO_AXIS_ENUM;
 
       #endif
     }

commit 000388b1d9e38a2678e8235a5d4dc3163f853c02
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 20 17:12:18 2021 -0500

    🎨 MULTI_MANUAL => MULTI_E_MANUAL

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 1d312535c9..544cc5eb2c 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -681,7 +681,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
     xyze_pos_t ManualMove::all_axes_destination = { 0 };
     bool ManualMove::processing = false;
   #endif
-  #if ENABLED(MULTI_MANUAL)
+  #if ENABLED(MULTI_E_MANUAL)
     int8_t ManualMove::e_index = 0;
   #endif
   AxisEnum ManualMove::axis = NO_AXIS_MASK;
@@ -758,11 +758,11 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
   // Tell ui.update() to start a move to current_position after a short delay.
   //
   void ManualMove::soon(const AxisEnum move_axis
-    #if MULTI_MANUAL
+    #if MULTI_E_MANUAL
       , const int8_t eindex/*=-1*/
     #endif
   ) {
-    #if MULTI_MANUAL
+    #if MULTI_E_MANUAL
       if (move_axis == E_AXIS) e_index = eindex >= 0 ? eindex : active_extruder;
     #endif
     start_time = millis() + (menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves

commit 49771c4a9ed2afa1e572f82a24b5edb3de120f78
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 19 00:21:34 2021 -0500

    🎨 Flags for homing directions

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index acc3b63ac0..1d312535c9 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -488,12 +488,12 @@ bool MarlinUI::get_blink() {
 
           if (RRK(EN_KEYPAD_MIDDLE))  goto_screen(menu_move);
 
-          #if DISABLED(DELTA) && Z_HOME_DIR < 0
+          #if NONE(DELTA, Z_HOME_TO_MAX)
             if (RRK(EN_KEYPAD_F2))    _reprapworld_keypad_move(Z_AXIS,  1);
           #endif
 
           if (homed) {
-            #if ENABLED(DELTA) || Z_HOME_DIR != -1
+            #if EITHER(DELTA, Z_HOME_TO_MAX)
               if (RRK(EN_KEYPAD_F2))  _reprapworld_keypad_move(Z_AXIS,  1);
             #endif
             if (RRK(EN_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);

commit a6e5492b088add3589aeac168136369f21614e60
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:51:19 2021 -0500

    ♻️ Refactor axis counts and loops

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 4c33b924c4..acc3b63ac0 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -684,7 +684,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
   #if ENABLED(MULTI_MANUAL)
     int8_t ManualMove::e_index = 0;
   #endif
-  AxisEnum ManualMove::axis = NO_AXIS;
+  AxisEnum ManualMove::axis = NO_AXIS_MASK;
 
   /**
    * If a manual move has been posted and its time has arrived, and if the planner
@@ -695,7 +695,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
    *
    * To post a manual move:
    *   - Update current_position to the new place you want to go.
-   *   - Set manual_move.axis to an axis like X_AXIS. Use ALL_AXES for diagonal moves.
+   *   - Set manual_move.axis to an axis like X_AXIS. Use ALL_AXES_MASK for diagonal moves.
    *   - Set manual_move.start_time to a point in the future (in ms) when the move should be done.
    *
    * For kinematic machines:
@@ -710,7 +710,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
     if (processing) return;   // Prevent re-entry from idle() calls
 
     // Add a manual move to the queue?
-    if (axis != NO_AXIS && ELAPSED(millis(), start_time) && !planner.is_full()) {
+    if (axis != NO_AXIS_MASK && ELAPSED(millis(), start_time) && !planner.is_full()) {
 
       const feedRate_t fr_mm_s = (axis <= E_AXIS) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
 
@@ -722,7 +722,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
         #endif
 
         // Apply a linear offset to a single axis
-        if (axis == ALL_AXES)
+        if (axis == ALL_AXES_MASK)
           destination = all_axes_destination;
         else if (axis <= XYZE) {
           destination = current_position;
@@ -731,7 +731,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
         // Reset for the next move
         offset = 0;
-        axis = NO_AXIS;
+        axis = NO_AXIS_MASK;
 
         // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
         // move_to_destination. This will cause idle() to be called, which can then call this function while the
@@ -748,7 +748,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
         //SERIAL_ECHOLNPAIR("Add planner.move with Axis ", AS_CHAR(axis_codes[axis]), " at FR ", fr_mm_s);
 
-        axis = NO_AXIS;
+        axis = NO_AXIS_MASK;
 
       #endif
     }

commit b65cdbed91782c83188706a9c340de9c503cf430
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 8 04:35:35 2021 -0500

    Signal SD completion later (#21840)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index f83d129b2f..4c33b924c4 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1487,7 +1487,7 @@ void MarlinUI::update() {
   void MarlinUI::abort_print() {
     #if ENABLED(SDSUPPORT)
       wait_for_heatup = wait_for_user = false;
-      card.flag.abort_sd_printing = true;
+      card.abortFilePrintSoon();
     #endif
     #ifdef ACTION_ON_CANCEL
       host_action_cancel();

commit f09fa69e867d1cfb18cbad720a5c1e566cb1bab4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 8 01:41:40 2021 -0500

    Add and apply REPEAT_1 macro

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 1b517f7d21..f83d129b2f 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -114,8 +114,8 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   PGM_P MarlinUI::get_preheat_label(const uint8_t m) {
     #define _PDEF(N) static PGMSTR(preheat_##N##_label, PREHEAT_##N##_LABEL);
     #define _PLBL(N) preheat_##N##_label,
-    REPEAT_S(1, INCREMENT(PREHEAT_COUNT), _PDEF);
-    static PGM_P const preheat_labels[PREHEAT_COUNT] PROGMEM = { REPEAT_S(1, INCREMENT(PREHEAT_COUNT), _PLBL) };
+    REPEAT_1(PREHEAT_COUNT, _PDEF);
+    static PGM_P const preheat_labels[PREHEAT_COUNT] PROGMEM = { REPEAT_1(PREHEAT_COUNT, _PLBL) };
     return (PGM_P)pgm_read_ptr(&preheat_labels[m]);
   }
 #endif

commit 2e0a1f1afff71a29e5fb5eb99c509d0de5384087
Author: David <davidtgbe@hotmail.com>
Date:   Wed Apr 28 11:08:21 2021 +0200

    Color UI Move Screen for 320x240 TFT (#21708)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 476caf3225..1b517f7d21 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -757,7 +757,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
   //
   // Tell ui.update() to start a move to current_position after a short delay.
   //
-  void ManualMove::soon(AxisEnum move_axis
+  void ManualMove::soon(const AxisEnum move_axis
     #if MULTI_MANUAL
       , const int8_t eindex/*=-1*/
     #endif

commit 40d789ce18e48e9328e3a4d144b889048b809ca5
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sun Apr 25 21:34:42 2021 -0700

    Fix "continuous" typo (#21701)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 812dac53b7..476caf3225 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -855,7 +855,7 @@ void MarlinUI::update() {
     static bool wait_for_unclick; // = false
 
     auto do_click = [&]{
-      wait_for_unclick = true;                        //  - Set debounce flag to ignore continous clicks
+      wait_for_unclick = true;                        //  - Set debounce flag to ignore continuous clicks
       lcd_clicked = !wait_for_user;                   //  - Keep the click if not waiting for a user-click
       wait_for_user = false;                          //  - Any click clears wait for user
       quick_feedback();                               //  - Always make a click sound

commit 6bb10b189897dcaef5a6da496dfd4f1631689f1b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 20 00:44:19 2021 -0500

    Changes supporting "Prussia3D" MK3 (#21617)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 149da8b54e..812dac53b7 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -112,25 +112,10 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 #if PREHEAT_COUNT
   preheat_t MarlinUI::material_preset[PREHEAT_COUNT];  // Initialized by settings.load()
   PGM_P MarlinUI::get_preheat_label(const uint8_t m) {
-    #ifdef PREHEAT_1_LABEL
-      static PGMSTR(preheat_0_label, PREHEAT_1_LABEL);
-    #endif
-    #ifdef PREHEAT_2_LABEL
-      static PGMSTR(preheat_1_label, PREHEAT_2_LABEL);
-    #endif
-    #ifdef PREHEAT_3_LABEL
-      static PGMSTR(preheat_2_label, PREHEAT_3_LABEL);
-    #endif
-    #ifdef PREHEAT_4_LABEL
-      static PGMSTR(preheat_3_label, PREHEAT_4_LABEL);
-    #endif
-    #ifdef PREHEAT_5_LABEL
-      static PGMSTR(preheat_4_label, PREHEAT_5_LABEL);
-    #endif
-
+    #define _PDEF(N) static PGMSTR(preheat_##N##_label, PREHEAT_##N##_LABEL);
     #define _PLBL(N) preheat_##N##_label,
-    static PGM_P const preheat_labels[PREHEAT_COUNT] PROGMEM = { REPEAT(PREHEAT_COUNT, _PLBL) };
-
+    REPEAT_S(1, INCREMENT(PREHEAT_COUNT), _PDEF);
+    static PGM_P const preheat_labels[PREHEAT_COUNT] PROGMEM = { REPEAT_S(1, INCREMENT(PREHEAT_COUNT), _PLBL) };
     return (PGM_P)pgm_read_ptr(&preheat_labels[m]);
   }
 #endif

commit 1879eede0d2910cac58f2a90b95989ff4531fa6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 7 15:43:07 2021 -0500

    Fix axis char printing

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 4d457dc6aa..149da8b54e 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -761,7 +761,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
         // For Cartesian / Core motion simply move to the current_position
         planner.buffer_line(current_position, fr_mm_s, axis == E_AXIS ? e_index : active_extruder);
 
-        //SERIAL_ECHOLNPAIR("Add planner.move with Axis ", axis, " at FR ", fr_mm_s);
+        //SERIAL_ECHOLNPAIR("Add planner.move with Axis ", AS_CHAR(axis_codes[axis]), " at FR ", fr_mm_s);
 
         axis = NO_AXIS;
 
@@ -782,7 +782,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
     #endif
     start_time = millis() + (menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
     axis = move_axis;
-    //SERIAL_ECHOLNPAIR("Post Move with Axis ", axis, " soon.");
+    //SERIAL_ECHOLNPAIR("Post Move with Axis ", AS_CHAR(axis_codes[axis]), " soon.");
   }
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)

commit ccdbffbf3f599f0860c643647ce6c40f1eb5a4cd
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Mon Mar 29 01:41:56 2021 -0500

    Laser Coolant Flow Meter / Safety Shutdown (#21431)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 8fef36e25a..4d457dc6aa 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1513,6 +1513,12 @@ void MarlinUI::update() {
     TERN_(HAS_LCD_MENU, return_to_status());
   }
 
+  void MarlinUI::flow_fault() {
+    LCD_ALERTMESSAGEPGM(MSG_FLOWMETER_FAULT);
+    TERN_(HAS_BUZZER, buzz(1000, 440));
+    TERN_(HAS_LCD_MENU, return_to_status());
+  }
+
   #if ANY(PARK_HEAD_ON_PAUSE, SDSUPPORT)
     #include "../gcode/queue.h"
   #endif

commit 30e7e2c2766d7dbbe0144344287994f1969dfadd
Author: Martijn Bosgraaf <drywfiltiarn+github@gmail.com>
Date:   Wed Mar 24 18:21:11 2021 +0100

    Extend M106/M107 for better laser module support (#16082)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 4133e04832..8fef36e25a 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -22,6 +22,8 @@
 
 #include "../inc/MarlinConfig.h"
 
+#include "../MarlinCore.h" // for printingIsPaused
+
 #ifdef LED_BACKLIGHT_TIMEOUT
   #include "../feature/leds/leds.h"
 #endif
@@ -39,21 +41,21 @@
 MarlinUI ui;
 
 #if HAS_DISPLAY
-  #include "../module/printcounter.h"
-  #include "../MarlinCore.h"
   #include "../gcode/queue.h"
   #include "fontutils.h"
   #include "../sd/cardreader.h"
 #endif
 
 #if ENABLED(DWIN_CREALITY_LCD)
-  #include "../module/printcounter.h"
-  #include "../MarlinCore.h"
   #include "dwin/e3v2/dwin.h"
 #endif
 
-#if HAS_STATUS_MESSAGE
-  #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80U)
+#if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
+  #define BASIC_PROGRESS_BAR 1
+#endif
+
+#if ANY(HAS_DISPLAY, HAS_STATUS_MESSAGE, BASIC_PROGRESS_BAR)
+  #include "../module/printcounter.h"
 #endif
 
 #if LCD_HAS_WAIT_FOR_MOVE
@@ -535,7 +537,7 @@ bool MarlinUI::get_blink() {
  * This is very display-dependent, so the lcd implementation draws this.
  */
 
-#if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
+#if BASIC_PROGRESS_BAR
   millis_t MarlinUI::progress_bar_ms; // = 0
   #if PROGRESS_MSG_EXPIRE > 0
     millis_t MarlinUI::expire_status_ms; // = 0
@@ -546,7 +548,7 @@ void MarlinUI::status_screen() {
 
   TERN_(HAS_LCD_MENU, ENCODER_RATE_MULTIPLY(false));
 
-  #if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
+  #if BASIC_PROGRESS_BAR
 
     //
     // HD44780 implements the following message blinking and
@@ -586,7 +588,7 @@ void MarlinUI::status_screen() {
 
     #endif // PROGRESS_MSG_EXPIRE
 
-  #endif // LCD_PROGRESS_BAR
+  #endif // BASIC_PROGRESS_BAR
 
   #if HAS_LCD_MENU
     if (use_click()) {
@@ -1353,6 +1355,7 @@ void MarlinUI::update() {
   /**
    * Reset the status message
    */
+
   void MarlinUI::reset_status(const bool no_welcome) {
     #if SERVICE_INTERVAL_1 > 0
       static PGMSTR(service1, "> " SERVICE_NAME_1 "!");
@@ -1438,9 +1441,9 @@ void MarlinUI::update() {
 
   void MarlinUI::finish_status(const bool persist) {
 
-    #if HAS_SPI_LCD
+    #if HAS_WIRED_LCD
 
-      #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE) > 0)
+      #if !(BASIC_PROGRESS_BAR && (PROGRESS_MSG_EXPIRE) > 0)
         UNUSED(persist);
       #endif
 
@@ -1448,7 +1451,7 @@ void MarlinUI::update() {
         const millis_t ms = millis();
       #endif
 
-      #if ENABLED(LCD_PROGRESS_BAR)
+      #if BASIC_PROGRESS_BAR
         progress_bar_ms = ms;
         #if PROGRESS_MSG_EXPIRE > 0
           expire_status_ms = persist ? 0 : ms + PROGRESS_MSG_EXPIRE;
@@ -1462,7 +1465,7 @@ void MarlinUI::update() {
       #if ENABLED(STATUS_MESSAGE_SCROLLING)
         status_scroll_offset = 0;
       #endif
-    #else // HAS_SPI_LCD
+    #else // HAS_WIRED_LCD
       UNUSED(persist);
     #endif
 

commit 930752d46e6aacb484ea89dacae6baf823d78d62
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Wed Mar 24 10:12:57 2021 -0500

    Ender 3 V2 Status Line (#21369)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 0be30efad8..4133e04832 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -44,9 +44,16 @@ MarlinUI ui;
   #include "../gcode/queue.h"
   #include "fontutils.h"
   #include "../sd/cardreader.h"
-  #if EITHER(EXTENSIBLE_UI, DWIN_CREALITY_LCD)
-    #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80U)
-  #endif
+#endif
+
+#if ENABLED(DWIN_CREALITY_LCD)
+  #include "../module/printcounter.h"
+  #include "../MarlinCore.h"
+  #include "dwin/e3v2/dwin.h"
+#endif
+
+#if HAS_STATUS_MESSAGE
+  #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80U)
 #endif
 
 #if LCD_HAS_WAIT_FOR_MOVE
@@ -55,25 +62,24 @@ MarlinUI ui;
 
 constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
 
-#if HAS_WIRED_LCD
-  #if ENABLED(STATUS_MESSAGE_SCROLLING)
-    uint8_t MarlinUI::status_scroll_offset; // = 0
-    constexpr uint8_t MAX_MESSAGE_LENGTH = _MAX(LONG_FILENAME_LENGTH, MAX_LANG_CHARSIZE * 2 * (LCD_WIDTH));
+#if HAS_STATUS_MESSAGE
+  #if HAS_WIRED_LCD
+    #if ENABLED(STATUS_MESSAGE_SCROLLING)
+      uint8_t MarlinUI::status_scroll_offset; // = 0
+      constexpr uint8_t MAX_MESSAGE_LENGTH = _MAX(LONG_FILENAME_LENGTH, MAX_LANG_CHARSIZE * 2 * (LCD_WIDTH));
+    #else
+      constexpr uint8_t MAX_MESSAGE_LENGTH = MAX_LANG_CHARSIZE * (LCD_WIDTH);
+    #endif
   #else
-    constexpr uint8_t MAX_MESSAGE_LENGTH = MAX_LANG_CHARSIZE * (LCD_WIDTH);
+    constexpr uint8_t MAX_MESSAGE_LENGTH = 63;
   #endif
-#elif EITHER(EXTENSIBLE_UI, DWIN_CREALITY_LCD)
-  constexpr uint8_t MAX_MESSAGE_LENGTH = 63;
-#endif
-
-#if EITHER(HAS_WIRED_LCD, EXTENSIBLE_UI)
-  uint8_t MarlinUI::alert_level; // = 0
   char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
+  uint8_t MarlinUI::alert_level; // = 0
 #endif
 
 #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   MarlinUI::progress_t MarlinUI::progress_override; // = 0
-  #if BOTH(LCD_SET_PROGRESS_MANUALLY, USE_M73_REMAINING_TIME)
+  #if ENABLED(USE_M73_REMAINING_TIME)
     uint32_t MarlinUI::remaining_time;
   #endif
 #endif
@@ -1461,6 +1467,7 @@ void MarlinUI::update() {
     #endif
 
     TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
+    TERN_(DWIN_CREALITY_LCD, DWIN_StatusChanged(status_message));
   }
 
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
@@ -1581,7 +1588,7 @@ void MarlinUI::update() {
 
   #endif
 
-#else // !HAS_DISPLAY
+#elif !HAS_STATUS_MESSAGE // && !HAS_DISPLAY
 
   //
   // Send the status line as a host notification
@@ -1596,7 +1603,7 @@ void MarlinUI::update() {
     TERN(HOST_PROMPT_SUPPORT, host_action_notify_P(message), UNUSED(message));
   }
 
-#endif // !HAS_DISPLAY
+#endif // !HAS_DISPLAY && !HAS_STATUS_MESSAGE
 
 #if ENABLED(SDSUPPORT)
 

commit 2d2291d00eab6159de24eb7ff74001b1d6dd29e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 24 05:40:28 2021 -0500

    More IntelliSense-friendly declarations

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 88566713a4..0be30efad8 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -688,7 +688,9 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
     xyze_pos_t ManualMove::all_axes_destination = { 0 };
     bool ManualMove::processing = false;
   #endif
-  TERN_(MULTI_MANUAL, int8_t ManualMove::e_index = 0);
+  #if ENABLED(MULTI_MANUAL)
+    int8_t ManualMove::e_index = 0;
+  #endif
   AxisEnum ManualMove::axis = NO_AXIS;
 
   /**

commit e7c711996bd3080f5e343eff5556736cbf2e2416
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 8 07:37:24 2021 +0100

    Serial refactor. Default 8-bit ECHO to int, not char (#20985)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index eaee08f43b..88566713a4 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -751,7 +751,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
         // For Cartesian / Core motion simply move to the current_position
         planner.buffer_line(current_position, fr_mm_s, axis == E_AXIS ? e_index : active_extruder);
 
-        //SERIAL_ECHOLNPAIR("Add planner.move with Axis ", int(axis), " at FR ", fr_mm_s);
+        //SERIAL_ECHOLNPAIR("Add planner.move with Axis ", axis, " at FR ", fr_mm_s);
 
         axis = NO_AXIS;
 
@@ -772,7 +772,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
     #endif
     start_time = millis() + (menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
     axis = move_axis;
-    //SERIAL_ECHOLNPAIR("Post Move with Axis ", int(axis), " soon.");
+    //SERIAL_ECHOLNPAIR("Post Move with Axis ", axis, " soon.");
   }
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)

commit 6dcb77f7b59ce894bbb1ffec9064681155a3da4b
Author: ellensp <ellensp@hotmail.com>
Date:   Mon Feb 8 15:36:04 2021 +1300

    Fix mini12864 v2.1 + PSU control + NeoPixel backlight (#21021)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index eea697a464..eaee08f43b 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -994,7 +994,7 @@ void MarlinUI::update() {
         refresh(LCDVIEW_REDRAW_NOW);
 
         #ifdef LED_BACKLIGHT_TIMEOUT
-          leds.reset_timeout(ms);
+          if (!powersupply_on) leds.reset_timeout(ms);
         #endif
       }
 

commit d58bbd5da1591dea0386170ba4831c549ac7eb9d
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Thu Feb 4 18:31:46 2021 -0300

    Re-calibrate touch after EEPROM reset, if needed (#20934)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 46db571936..eea697a464 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1652,7 +1652,13 @@ void MarlinUI::update() {
 #endif // SDSUPPORT
 
 #if HAS_LCD_MENU
-  void MarlinUI::reset_settings() { settings.reset(); completion_feedback(); }
+  void MarlinUI::reset_settings() {
+    settings.reset();
+    completion_feedback();
+    #if ENABLED(TOUCH_SCREEN_CALIBRATION)
+      if (touch_calibration.need_calibration()) ui.goto_screen(touch_screen_calibration);
+    #endif
+  }
 #endif
 
 #if ENABLED(EEPROM_SETTINGS)

commit b95f5c5bea26ce50c73df3f30241365f220a623c
Author: ConstantijnCrijnen <43953114+ConstantijnCrijnen@users.noreply.github.com>
Date:   Tue Jan 26 09:30:31 2021 +0100

    Configure / disable PRINTCOUNTER save interval (#20856)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index c3c5d3f094..46db571936 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1495,8 +1495,8 @@ void MarlinUI::update() {
     #ifdef ACTION_ON_CANCEL
       host_action_cancel();
     #endif
+    IF_DISABLED(SDSUPPORT, print_job_timer.stop());
     TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_INFO, PSTR("UI Aborted"), DISMISS_STR));
-    print_job_timer.stop();
     LCD_MESSAGEPGM(MSG_PRINT_ABORTED);
     TERN_(HAS_LCD_MENU, return_to_status());
   }

commit d33fe2378c25d258b02440aef6cc31e36753f98f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 22 15:01:19 2021 -0600

    Move common strings (#20846)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 25f3903ddc..c3c5d3f094 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1528,7 +1528,7 @@ void MarlinUI::update() {
   void MarlinUI::resume_print() {
     reset_status();
     TERN_(PARK_HEAD_ON_PAUSE, wait_for_heatup = wait_for_user = false);
-    if (IS_SD_PAUSED()) queue.inject_P(M24_STR);
+    TERN_(SDSUPPORT, if (IS_SD_PAUSED()) queue.inject_P(M24_STR));
     #ifdef ACTION_ON_RESUME
       host_action_resume();
     #endif

commit c0870d417a68ff4303100f165282d41be9129a5c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 21 03:40:07 2021 -0600

    Move some MarlinCore and MarlinUI code (#20832)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index d13c8e409d..25f3903ddc 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1516,7 +1516,7 @@ void MarlinUI::update() {
     LCD_MESSAGEPGM(MSG_PRINT_PAUSED);
 
     #if ENABLED(PARK_HEAD_ON_PAUSE)
-      TERN_(HAS_WIRED_LCD, lcd_pause_show_message(PAUSE_MESSAGE_PARKING, PAUSE_MODE_PAUSE_PRINT)); // Show message immediately to let user know about pause in progress
+      pause_show_message(PAUSE_MESSAGE_PARKING, PAUSE_MODE_PAUSE_PRINT); // Show message immediately to let user know about pause in progress
       queue.inject_P(PSTR("M25 P\nM24"));
     #elif ENABLED(SDSUPPORT)
       queue.inject_P(PSTR("M25"));

commit 68abaeab19b41824bc151bc0f65e76ce8a2e4916
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jan 20 18:52:06 2021 -0600

    MarlinUI multi-language support (#20725)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index d4e1357e86..d13c8e409d 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -78,6 +78,10 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   #endif
 #endif
 
+#if HAS_MULTI_LANGUAGE
+  uint8_t MarlinUI::language; // Initialized by settings.load()
+#endif
+
 #if ENABLED(SOUND_MENU_ITEM)
   bool MarlinUI::buzzer_enabled = true;
 #endif

commit 6376b683c78ec410ace0765ba91314055b78d927
Author: Marcio Teixeira <mlt4356-github@yahoo.com>
Date:   Thu Jan 14 08:48:29 2021 -0700

    Silence unused parameter warnings

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 430bfcf48e..d4e1357e86 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1450,7 +1450,8 @@ void MarlinUI::update() {
       #if ENABLED(STATUS_MESSAGE_SCROLLING)
         status_scroll_offset = 0;
       #endif
-
+    #else // HAS_SPI_LCD
+      UNUSED(persist);
     #endif
 
     TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));

commit 4a897310252341f203371cb2e99f93bf9c035143
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 12 20:43:52 2021 -0600

    Rotary encoder cleanup (#20753)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index e59b72f47d..430bfcf48e 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -342,7 +342,6 @@ void MarlinUI::init() {
   init_lcd();
 
   #if HAS_DIGITAL_BUTTONS
-
     #if BUTTON_EXISTS(EN1)
       SET_INPUT_PULLUP(BTN_EN1);
     #endif
@@ -352,15 +351,12 @@ void MarlinUI::init() {
     #if BUTTON_EXISTS(ENC)
       SET_INPUT_PULLUP(BTN_ENC);
     #endif
-
     #if BUTTON_EXISTS(ENC_EN)
       SET_INPUT_PULLUP(BTN_ENC_EN);
     #endif
-
     #if BUTTON_EXISTS(BACK)
       SET_INPUT_PULLUP(BTN_BACK);
     #endif
-
     #if BUTTON_EXISTS(UP)
       SET_INPUT(BTN_UP);
     #endif
@@ -373,8 +369,7 @@ void MarlinUI::init() {
     #if BUTTON_EXISTS(RT)
       SET_INPUT(BTN_RT);
     #endif
-
-  #endif // !HAS_DIGITAL_BUTTONS
+  #endif
 
   #if HAS_SHIFT_ENCODER
 
@@ -383,14 +378,14 @@ void MarlinUI::init() {
       SET_OUTPUT(SR_DATA_PIN);
       SET_OUTPUT(SR_CLK_PIN);
 
-    #elif defined(SHIFT_CLK)
+    #elif PIN_EXISTS(SHIFT_CLK)
 
-      SET_OUTPUT(SHIFT_CLK);
-      OUT_WRITE(SHIFT_LD, HIGH);
-      #if defined(SHIFT_EN) && SHIFT_EN >= 0
-        OUT_WRITE(SHIFT_EN, LOW);
+      SET_OUTPUT(SHIFT_CLK_PIN);
+      OUT_WRITE(SHIFT_LD_PIN, HIGH);
+      #if PIN_EXISTS(SHIFT_EN)
+        OUT_WRITE(SHIFT_EN_PIN, LOW);
       #endif
-      SET_INPUT_PULLUP(SHIFT_OUT);
+      SET_INPUT_PULLUP(SHIFT_OUT_PIN);
 
     #endif
 
@@ -830,11 +825,7 @@ millis_t next_lcd_update_ms;
 #endif
 
 inline bool can_encode() {
-  #if BUTTON_EXISTS(ENC_EN)
-    return !BUTTON_PRESSED(ENC_EN);  // Update position only when ENC_EN is HIGH
-  #else
-    return true;
-  #endif
+  return !BUTTON_PRESSED(ENC_EN); // Update encoder only when ENC_EN is not LOW (pressed)
 }
 
 void MarlinUI::update() {
@@ -890,18 +881,17 @@ void MarlinUI::update() {
         else if (!wait_for_unclick && (buttons & EN_C))   // OK button, if not waiting for a debounce release:
           do_click();
       }
-      else // keep wait_for_unclick value
-
-    #endif // HAS_TOUCH_BUTTONS
+      // keep wait_for_unclick value
+    #endif
 
-      {
-        // Integrated LCD click handling via button_pressed
-        if (!external_control && button_pressed()) {
-          if (!wait_for_unclick) do_click();              // Handle the click
-        }
-        else
-          wait_for_unclick = false;
+    if (!touch_buttons) {
+      // Integrated LCD click handling via button_pressed
+      if (!external_control && button_pressed()) {
+        if (!wait_for_unclick) do_click();              // Handle the click
       }
+      else
+        wait_for_unclick = false;
+    }
 
     if (LCD_BACK_CLICKED()) {
       quick_feedback();
@@ -1198,19 +1188,10 @@ void MarlinUI::update() {
         #if ANY_BUTTON(EN1, EN2, ENC, BACK)
 
           uint8_t newbutton = 0;
-
-          #if BUTTON_EXISTS(EN1)
-            if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
-          #endif
-          #if BUTTON_EXISTS(EN2)
-            if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
-          #endif
-          #if BUTTON_EXISTS(ENC)
-            if (can_encode() && BUTTON_PRESSED(ENC)) newbutton |= EN_C;
-          #endif
-          #if BUTTON_EXISTS(BACK)
-            if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;
-          #endif
+          if (BUTTON_PRESSED(EN1))                 newbutton |= EN_A;
+          if (BUTTON_PRESSED(EN2))                 newbutton |= EN_B;
+          if (can_encode() && BUTTON_PRESSED(ENC)) newbutton |= EN_C;
+          if (BUTTON_PRESSED(BACK))                newbutton |= EN_D;
 
         #else
 
@@ -1225,40 +1206,26 @@ void MarlinUI::update() {
 
           const int8_t pulses = epps * encoderDirection;
 
-          if (false) {
-            // for the else-ifs below
+          if (BUTTON_PRESSED(UP)) {
+            encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * pulses;
+            next_button_update_ms = now + 300;
+          }
+          else if (BUTTON_PRESSED(DWN)) {
+            encoderDiff = -(ENCODER_STEPS_PER_MENU_ITEM) * pulses;
+            next_button_update_ms = now + 300;
+          }
+          else if (BUTTON_PRESSED(LFT)) {
+            encoderDiff = -pulses;
+            next_button_update_ms = now + 300;
+          }
+          else if (BUTTON_PRESSED(RT)) {
+            encoderDiff = pulses;
+            next_button_update_ms = now + 300;
           }
-          #if BUTTON_EXISTS(UP)
-            else if (BUTTON_PRESSED(UP)) {
-              encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * pulses;
-              next_button_update_ms = now + 300;
-            }
-          #endif
-          #if BUTTON_EXISTS(DWN)
-            else if (BUTTON_PRESSED(DWN)) {
-              encoderDiff = -(ENCODER_STEPS_PER_MENU_ITEM) * pulses;
-              next_button_update_ms = now + 300;
-            }
-          #endif
-          #if BUTTON_EXISTS(LFT)
-            else if (BUTTON_PRESSED(LFT)) {
-              encoderDiff = -pulses;
-              next_button_update_ms = now + 300;
-            }
-          #endif
-          #if BUTTON_EXISTS(RT)
-            else if (BUTTON_PRESSED(RT)) {
-              encoderDiff = pulses;
-              next_button_update_ms = now + 300;
-            }
-          #endif
 
         #endif // UP || DWN || LFT || RT
 
-        buttons = (newbutton
-          #if HAS_SLOW_BUTTONS
-            | slow_buttons
-          #endif
+        buttons = (newbutton | TERN0(HAS_SLOW_BUTTONS, slow_buttons)
           #if BOTH(HAS_TOUCH_BUTTONS, HAS_ENCODER_ACTION)
             | (touch_buttons & TERN(HAS_ENCODER_WHEEL, ~(EN_A | EN_B), 0xFF))
           #endif
@@ -1284,13 +1251,13 @@ void MarlinUI::update() {
          * The rotary encoder part is also independent of the LCD chipset.
          */
         uint8_t val = 0;
-        WRITE(SHIFT_LD, LOW);
-        WRITE(SHIFT_LD, HIGH);
+        WRITE(SHIFT_LD_PIN, LOW);
+        WRITE(SHIFT_LD_PIN, HIGH);
         LOOP_L_N(i, 8) {
           val >>= 1;
-          if (READ(SHIFT_OUT)) SBI(val, 7);
-          WRITE(SHIFT_CLK, HIGH);
-          WRITE(SHIFT_CLK, LOW);
+          if (READ(SHIFT_OUT_PIN)) SBI(val, 7);
+          WRITE(SHIFT_CLK_PIN, HIGH);
+          WRITE(SHIFT_CLK_PIN, LOW);
         }
         TERN(REPRAPWORLD_KEYPAD, keypad_buttons, buttons) = ~val;
       #endif
@@ -1306,11 +1273,6 @@ void MarlinUI::update() {
     #if HAS_ENCODER_WHEEL
       static uint8_t lastEncoderBits;
 
-      #define encrot0 0
-      #define encrot1 2
-      #define encrot2 3
-      #define encrot3 1
-
       // Manage encoder rotation
       #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: encoderDiff += encoderDirection; break; case _E2: encoderDiff -= encoderDirection; }
 
@@ -1319,10 +1281,10 @@ void MarlinUI::update() {
       if (buttons & EN_B) enc |= B10;
       if (enc != lastEncoderBits) {
         switch (enc) {
-          case encrot0: ENCODER_SPIN(encrot3, encrot1); break;
-          case encrot1: ENCODER_SPIN(encrot0, encrot2); break;
-          case encrot2: ENCODER_SPIN(encrot1, encrot3); break;
-          case encrot3: ENCODER_SPIN(encrot2, encrot0); break;
+          case ENCODER_PHASE_0: ENCODER_SPIN(ENCODER_PHASE_3, ENCODER_PHASE_1); break;
+          case ENCODER_PHASE_1: ENCODER_SPIN(ENCODER_PHASE_0, ENCODER_PHASE_2); break;
+          case ENCODER_PHASE_2: ENCODER_SPIN(ENCODER_PHASE_1, ENCODER_PHASE_3); break;
+          case ENCODER_PHASE_3: ENCODER_SPIN(ENCODER_PHASE_2, ENCODER_PHASE_0); break;
         }
         #if BOTH(HAS_LCD_MENU, AUTO_BED_LEVELING_UBL)
           external_encoder();

commit 1d63fe6542d761b00d3e76296e02f600f0a83c09
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 2 19:01:09 2021 -0600

    Add ALL_AXES manual move for UBL mesh editing
    
    Co-Authored-By: Jason Smith <20053467+sjasonsmith@users.noreply.github.com>
    
    #20620

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 3c2f930e68..e59b72f47d 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -684,8 +684,11 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
   millis_t ManualMove::start_time = 0;
   float ManualMove::menu_scale = 1;
-  TERN_(IS_KINEMATIC, float ManualMove::offset = 0);
-  TERN_(IS_KINEMATIC, bool ManualMove::processing = false);
+  #if IS_KINEMATIC
+    float ManualMove::offset = 0;
+    xyze_pos_t ManualMove::all_axes_destination = { 0 };
+    bool ManualMove::processing = false;
+  #endif
   TERN_(MULTI_MANUAL, int8_t ManualMove::e_index = 0);
   AxisEnum ManualMove::axis = NO_AXIS;
 
@@ -725,8 +728,12 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
         #endif
 
         // Apply a linear offset to a single axis
-        destination = current_position;
-        if (axis <= XYZE) destination[axis] += offset;
+        if (axis == ALL_AXES)
+          destination = all_axes_destination;
+        else if (axis <= XYZE) {
+          destination = current_position;
+          destination[axis] += offset;
+        }
 
         // Reset for the next move
         offset = 0;

commit 9f53738339db172635d38e7a78c87890d7b5a636
Author: Jason Smith <jason.inet@gmail.com>
Date:   Fri Jan 1 18:08:10 2021 -0800

    Fix UBL mesh edit delta moves (#20620)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index fb37643cd2..3c2f930e68 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -687,7 +687,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
   TERN_(IS_KINEMATIC, float ManualMove::offset = 0);
   TERN_(IS_KINEMATIC, bool ManualMove::processing = false);
   TERN_(MULTI_MANUAL, int8_t ManualMove::e_index = 0);
-  uint8_t ManualMove::axis = (uint8_t)NO_AXIS;
+  AxisEnum ManualMove::axis = NO_AXIS;
 
   /**
    * If a manual move has been posted and its time has arrived, and if the planner
@@ -713,14 +713,14 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
     if (processing) return;   // Prevent re-entry from idle() calls
 
     // Add a manual move to the queue?
-    if (axis != (uint8_t)NO_AXIS && ELAPSED(millis(), start_time) && !planner.is_full()) {
+    if (axis != NO_AXIS && ELAPSED(millis(), start_time) && !planner.is_full()) {
 
-      const feedRate_t fr_mm_s = (uint8_t(axis) <= E_AXIS) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
+      const feedRate_t fr_mm_s = (axis <= E_AXIS) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
 
       #if IS_KINEMATIC
 
         #if HAS_MULTI_EXTRUDER
-          const int8_t old_extruder = active_extruder;
+          REMEMBER(ae, active_extruder);
           if (axis == E_AXIS) active_extruder = e_index;
         #endif
 
@@ -730,7 +730,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
         // Reset for the next move
         offset = 0;
-        axis = (uint8_t)NO_AXIS;
+        axis = NO_AXIS;
 
         // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
         // move_to_destination. This will cause idle() to be called, which can then call this function while the
@@ -740,8 +740,6 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
         prepare_internal_move_to_destination(fr_mm_s);  // will set current_position from destination
         processing = false;
 
-        TERN_(HAS_MULTI_EXTRUDER, active_extruder = old_extruder);
-
       #else
 
         // For Cartesian / Core motion simply move to the current_position
@@ -749,7 +747,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
 
         //SERIAL_ECHOLNPAIR("Add planner.move with Axis ", int(axis), " at FR ", fr_mm_s);
 
-        axis = (uint8_t)NO_AXIS;
+        axis = NO_AXIS;
 
       #endif
     }
@@ -767,7 +765,7 @@ void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
       if (move_axis == E_AXIS) e_index = eindex >= 0 ? eindex : active_extruder;
     #endif
     start_time = millis() + (menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
-    axis = (uint8_t)move_axis;
+    axis = move_axis;
     //SERIAL_ECHOLNPAIR("Post Move with Axis ", int(axis), " soon.");
   }
 

commit 31337826a3ed0630baa33e0206a47f267725bd99
Author: ellensp <ellensp@hotmail.com>
Date:   Fri Dec 18 01:05:25 2020 +1300

    Fix ZoneStar LCD 2004 buttons (#20489)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 241d3a1712..fb37643cd2 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -923,7 +923,7 @@ void MarlinUI::update() {
 
       TERN_(HAS_SLOW_BUTTONS, slow_buttons = read_slow_buttons()); // Buttons that take too long to read in interrupt context
 
-      if (TERN0(REPRAPWORLD_KEYPAD, handle_keypad()))
+      if (TERN0(IS_RRW_KEYPAD, handle_keypad()))
         RESET_STATUS_TIMEOUT();
 
       uint8_t abs_diff = ABS(encoderDiff);

commit 6f272e13c5ce132c0bd7fdc2401ceadad5f3b06c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 22 18:44:17 2020 -0600

    Allow Status Message without LCD (#20246)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index acf35afb18..241d3a1712 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1332,59 +1332,16 @@ void MarlinUI::update() {
 
 #endif // HAS_WIRED_LCD
 
-#if HAS_DISPLAY
-
-  #if ENABLED(EXTENSIBLE_UI)
-    #include "extui/ui_api.h"
-  #endif
+#if HAS_STATUS_MESSAGE
 
   ////////////////////////////////////////////
-  /////////////// Status Line ////////////////
+  ////////////// Status Message //////////////
   ////////////////////////////////////////////
 
-  #if ENABLED(STATUS_MESSAGE_SCROLLING)
-    void MarlinUI::advance_status_scroll() {
-      // Advance by one UTF8 code-word
-      if (status_scroll_offset < utf8_strlen(status_message))
-        while (!START_OF_UTF8_CHAR(status_message[++status_scroll_offset]));
-      else
-        status_scroll_offset = 0;
-    }
-    char* MarlinUI::status_and_len(uint8_t &len) {
-      char *out = status_message + status_scroll_offset;
-      len = utf8_strlen(out);
-      return out;
-    }
+  #if ENABLED(EXTENSIBLE_UI)
+    #include "extui/ui_api.h"
   #endif
 
-  void MarlinUI::finish_status(const bool persist) {
-
-    #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE) > 0)
-      UNUSED(persist);
-    #endif
-
-    #if ENABLED(LCD_PROGRESS_BAR) || BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
-      const millis_t ms = millis();
-    #endif
-
-    #if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
-      progress_bar_ms = ms;
-      #if PROGRESS_MSG_EXPIRE > 0
-        expire_status_ms = persist ? 0 : ms + PROGRESS_MSG_EXPIRE;
-      #endif
-    #endif
-
-    #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
-      next_filament_display = ms + 5000UL; // Show status message for 5s
-    #endif
-
-    #if BOTH(HAS_WIRED_LCD, STATUS_MESSAGE_SCROLLING)
-      status_scroll_offset = 0;
-    #endif
-
-    TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
-  }
-
   bool MarlinUI::has_status() { return (status_message[0] != '\0'); }
 
   void MarlinUI::set_status(const char * const message, const bool persist) {
@@ -1414,16 +1371,45 @@ void MarlinUI::update() {
     finish_status(persist);
   }
 
-  #include <stdarg.h>
+  /**
+   * Reset the status message
+   */
+  void MarlinUI::reset_status(const bool no_welcome) {
+    #if SERVICE_INTERVAL_1 > 0
+      static PGMSTR(service1, "> " SERVICE_NAME_1 "!");
+    #endif
+    #if SERVICE_INTERVAL_2 > 0
+      static PGMSTR(service2, "> " SERVICE_NAME_2 "!");
+    #endif
+    #if SERVICE_INTERVAL_3 > 0
+      static PGMSTR(service3, "> " SERVICE_NAME_3 "!");
+    #endif
+    PGM_P msg;
+    if (printingIsPaused())
+      msg = GET_TEXT(MSG_PRINT_PAUSED);
+    #if ENABLED(SDSUPPORT)
+      else if (IS_SD_PRINTING())
+        return set_status(card.longest_filename(), true);
+    #endif
+    else if (print_job_timer.isRunning())
+      msg = GET_TEXT(MSG_PRINTING);
 
-  void MarlinUI::status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
-    if (level < alert_level) return;
-    alert_level = level;
-    va_list args;
-    va_start(args, fmt);
-    vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
-    va_end(args);
-    finish_status(level > 0);
+    #if SERVICE_INTERVAL_1 > 0
+      else if (print_job_timer.needsService(1)) msg = service1;
+    #endif
+    #if SERVICE_INTERVAL_2 > 0
+      else if (print_job_timer.needsService(2)) msg = service2;
+    #endif
+    #if SERVICE_INTERVAL_3 > 0
+      else if (print_job_timer.needsService(3)) msg = service3;
+    #endif
+
+    else if (!no_welcome)
+      msg = GET_TEXT(WELCOME_MSG);
+    else
+      return;
+
+    set_status_P(msg, -1);
   }
 
   void MarlinUI::set_status_P(PGM_P const message, int8_t level) {
@@ -1459,51 +1445,76 @@ void MarlinUI::update() {
     TERN_(HAS_LCD_MENU, return_to_status());
   }
 
-  PGM_P print_paused = GET_TEXT(MSG_PRINT_PAUSED);
+  #include <stdarg.h>
 
-  /**
-   * Reset the status message
-   */
-  void MarlinUI::reset_status(const bool no_welcome) {
-    PGM_P printing = GET_TEXT(MSG_PRINTING);
-    PGM_P welcome  = GET_TEXT(WELCOME_MSG);
-    #if SERVICE_INTERVAL_1 > 0
-      static PGMSTR(service1, "> " SERVICE_NAME_1 "!");
-    #endif
-    #if SERVICE_INTERVAL_2 > 0
-      static PGMSTR(service2, "> " SERVICE_NAME_2 "!");
-    #endif
-    #if SERVICE_INTERVAL_3 > 0
-      static PGMSTR(service3, "> " SERVICE_NAME_3 "!");
-    #endif
-    PGM_P msg;
-    if (printingIsPaused())
-      msg = print_paused;
-    #if ENABLED(SDSUPPORT)
-      else if (IS_SD_PRINTING())
-        return set_status(card.longest_filename(), true);
-    #endif
-    else if (print_job_timer.isRunning())
-      msg = printing;
+  void MarlinUI::status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
+    if (level < alert_level) return;
+    alert_level = level;
+    va_list args;
+    va_start(args, fmt);
+    vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
+    va_end(args);
+    finish_status(level > 0);
+  }
 
-    #if SERVICE_INTERVAL_1 > 0
-      else if (print_job_timer.needsService(1)) msg = service1;
-    #endif
-    #if SERVICE_INTERVAL_2 > 0
-      else if (print_job_timer.needsService(2)) msg = service2;
-    #endif
-    #if SERVICE_INTERVAL_3 > 0
-      else if (print_job_timer.needsService(3)) msg = service3;
-    #endif
+  void MarlinUI::finish_status(const bool persist) {
 
-    else if (!no_welcome)
-      msg = welcome;
-    else
-      return;
+    #if HAS_SPI_LCD
 
-    set_status_P(msg, -1);
+      #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE) > 0)
+        UNUSED(persist);
+      #endif
+
+      #if ENABLED(LCD_PROGRESS_BAR) || BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+        const millis_t ms = millis();
+      #endif
+
+      #if ENABLED(LCD_PROGRESS_BAR)
+        progress_bar_ms = ms;
+        #if PROGRESS_MSG_EXPIRE > 0
+          expire_status_ms = persist ? 0 : ms + PROGRESS_MSG_EXPIRE;
+        #endif
+      #endif
+
+      #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+        next_filament_display = ms + 5000UL; // Show status message for 5s
+      #endif
+
+      #if ENABLED(STATUS_MESSAGE_SCROLLING)
+        status_scroll_offset = 0;
+      #endif
+
+    #endif
+
+    TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
   }
 
+  #if ENABLED(STATUS_MESSAGE_SCROLLING)
+
+    void MarlinUI::advance_status_scroll() {
+      // Advance by one UTF8 code-word
+      if (status_scroll_offset < utf8_strlen(status_message))
+        while (!START_OF_UTF8_CHAR(status_message[++status_scroll_offset]));
+      else
+        status_scroll_offset = 0;
+    }
+
+    char* MarlinUI::status_and_len(uint8_t &len) {
+      char *out = status_message + status_scroll_offset;
+      len = utf8_strlen(out);
+      return out;
+    }
+
+  #endif
+
+#endif
+
+#if HAS_DISPLAY
+
+  #if ENABLED(SDSUPPORT)
+    extern bool wait_for_user, wait_for_heatup;
+  #endif
+
   void MarlinUI::abort_print() {
     #if ENABLED(SDSUPPORT)
       wait_for_heatup = wait_for_user = false;
@@ -1514,7 +1525,7 @@ void MarlinUI::update() {
     #endif
     TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_INFO, PSTR("UI Aborted"), DISMISS_STR));
     print_job_timer.stop();
-    set_status_P(GET_TEXT(MSG_PRINT_ABORTED));
+    LCD_MESSAGEPGM(MSG_PRINT_ABORTED);
     TERN_(HAS_LCD_MENU, return_to_status());
   }
 
@@ -1530,7 +1541,7 @@ void MarlinUI::update() {
 
     TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume")));
 
-    set_status_P(print_paused);
+    LCD_MESSAGEPGM(MSG_PRINT_PAUSED);
 
     #if ENABLED(PARK_HEAD_ON_PAUSE)
       TERN_(HAS_WIRED_LCD, lcd_pause_show_message(PAUSE_MESSAGE_PARKING, PAUSE_MODE_PAUSE_PRINT)); // Show message immediately to let user know about pause in progress
@@ -1615,6 +1626,10 @@ void MarlinUI::update() {
 
 #if ENABLED(SDSUPPORT)
 
+  #if ENABLED(EXTENSIBLE_UI)
+    #include "extui/ui_api.h"
+  #endif
+
   void MarlinUI::media_changed(const uint8_t old_status, const uint8_t status) {
     if (old_status == status) {
       TERN_(EXTENSIBLE_UI, ExtUI::onMediaError()); // Failed to mount/unmount
@@ -1629,7 +1644,7 @@ void MarlinUI::update() {
           quick_feedback();
           goto_screen(MEDIA_MENU_GATEWAY);
         #else
-          set_status_P(GET_TEXT(MSG_MEDIA_INSERTED));
+          LCD_MESSAGEPGM(MSG_MEDIA_INSERTED);
         #endif
       }
     }
@@ -1637,7 +1652,7 @@ void MarlinUI::update() {
       if (old_status < 2) {
         TERN_(EXTENSIBLE_UI, ExtUI::onMediaRemoved()); // ExtUI response
         #if PIN_EXISTS(SD_DETECT)
-          set_status_P(GET_TEXT(MSG_MEDIA_REMOVED));
+          LCD_MESSAGEPGM(MSG_MEDIA_REMOVED);
           #if HAS_LCD_MENU
             if (!defer_return_to_status) return_to_status();
           #endif

commit e19c016c74c9627afe7c4527dfc08d5c77539261
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Sun Nov 22 01:21:43 2020 +0100

    Clear menu history for browse media on insert (#20236)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 9d0ebe27e4..acf35afb18 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -1625,6 +1625,7 @@ void MarlinUI::update() {
       if (old_status < 2) {
         TERN_(EXTENSIBLE_UI, ExtUI::onMediaInserted()); // ExtUI response
         #if ENABLED(BROWSE_MEDIA_ON_INSERT)
+          clear_menu_history();
           quick_feedback();
           goto_screen(MEDIA_MENU_GATEWAY);
         #else

commit ecd8227de0c17427f9f8d76cfc279acbc5a0a188
Author: Thomas Niccolo Reyes <niccoreyes@gmail.com>
Date:   Wed Nov 18 12:30:32 2020 +0800

    Open File Browser on Media Insert (option) (#20151)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 13c85be787..9d0ebe27e4 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -30,6 +30,10 @@
   #include "../feature/host_actions.h"
 #endif
 
+#if ENABLED(BROWSE_MEDIA_ON_INSERT, PASSWORD_ON_SD_PRINT_MENU)
+  #include "../feature/password/password.h"
+#endif
+
 // All displays share the MarlinUI class
 #include "marlinui.h"
 MarlinUI ui;
@@ -1620,7 +1624,12 @@ void MarlinUI::update() {
     if (status) {
       if (old_status < 2) {
         TERN_(EXTENSIBLE_UI, ExtUI::onMediaInserted()); // ExtUI response
-        set_status_P(GET_TEXT(MSG_MEDIA_INSERTED));
+        #if ENABLED(BROWSE_MEDIA_ON_INSERT)
+          quick_feedback();
+          goto_screen(MEDIA_MENU_GATEWAY);
+        #else
+          set_status_P(GET_TEXT(MSG_MEDIA_INSERTED));
+        #endif
       }
     }
     else {

commit ea371618da71dc43e6aee95a8e479c8797867e04
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sun Nov 15 19:39:58 2020 -0300

    Add Touch Calibration screen (#20049)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 457d3cefd7..13c85be787 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -158,7 +158,7 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   #if HAS_SLOW_BUTTONS
     volatile uint8_t MarlinUI::slow_buttons;
   #endif
-  #if HAS_TOUCH_XPT2046
+  #if HAS_TOUCH_BUTTONS
     #include "touch/touch_buttons.h"
     bool MarlinUI::on_edit_screen = false;
   #endif
@@ -241,7 +241,7 @@ millis_t MarlinUI::next_button_update_ms; // = 0
     int8_t MarlinUI::encoderDirection = ENCODERBASE;
   #endif
 
-  #if HAS_TOUCH_XPT2046
+  #if HAS_TOUCH_BUTTONS
     uint8_t MarlinUI::touch_buttons;
     uint8_t MarlinUI::repeat_delay;
   #endif
@@ -862,7 +862,7 @@ void MarlinUI::update() {
       quick_feedback();                               //  - Always make a click sound
     };
 
-    #if HAS_TOUCH_XPT2046
+    #if HAS_TOUCH_BUTTONS
       if (touch_buttons) {
         RESET_STATUS_TIMEOUT();
         if (touch_buttons & (EN_A | EN_B)) {              // Menu arrows, in priority
@@ -883,7 +883,7 @@ void MarlinUI::update() {
       }
       else // keep wait_for_unclick value
 
-    #endif // HAS_TOUCH_XPT2046
+    #endif // HAS_TOUCH_BUTTONS
 
       {
         // Integrated LCD click handling via button_pressed
@@ -905,7 +905,7 @@ void MarlinUI::update() {
 
     next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
 
-    #if HAS_TOUCH_XPT2046
+    #if HAS_TOUCH_BUTTONS
 
       if (on_status_screen()) next_lcd_update_ms += (LCD_UPDATE_INTERVAL) * 2;
 
@@ -1250,7 +1250,7 @@ void MarlinUI::update() {
           #if HAS_SLOW_BUTTONS
             | slow_buttons
           #endif
-          #if BOTH(HAS_TOUCH_XPT2046, HAS_ENCODER_ACTION)
+          #if BOTH(HAS_TOUCH_BUTTONS, HAS_ENCODER_ACTION)
             | (touch_buttons & TERN(HAS_ENCODER_WHEEL, ~(EN_A | EN_B), 0xFF))
           #endif
         );
@@ -1561,7 +1561,7 @@ void MarlinUI::update() {
 
   #endif
 
-  #if HAS_TOUCH_XPT2046
+  #if HAS_TOUCH_BUTTONS
 
     //
     // Screen Click

commit 99c377b4e4d982c4e8afe388351020efd042a543
Author: LinFor <linfor@gmail.com>
Date:   Fri Nov 13 07:49:19 2020 +0300

    Fix UTF filename scroll (#20121)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 17c3c3edfe..457d3cefd7 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -208,10 +208,13 @@ millis_t MarlinUI::next_button_update_ms; // = 0
             filename_scroll_pos = 0;                                       // Reset scroll to the start
             lcd_status_update_delay = 8;                                   // Don't scroll right away
           }
-          outstr += filename_scroll_pos;
+          // Advance byte position corresponding to filename_scroll_pos char position
+          outstr += TERN(UTF_FILENAME_SUPPORT, utf8_byte_pos_by_char_num(outstr, filename_scroll_pos), filename_scroll_pos);
         }
       #else
-        theCard.longFilename[maxlen] = '\0'; // cutoff at screen edge
+        theCard.longFilename[
+          TERN(UTF_FILENAME_SUPPORT, utf8_byte_pos_by_char_num(theCard.longFilename, maxlen), maxlen)
+        ] = '\0'; // cutoff at screen edge
       #endif
     }
     return outstr;
@@ -1006,11 +1009,8 @@ void MarlinUI::update() {
       // If scrolling of long file names is enabled and we are in the sd card menu,
       // cause a refresh to occur until all the text has scrolled into view.
       if (currentScreen == menu_media && !lcd_status_update_delay--) {
-        lcd_status_update_delay = 4;
-        if (++filename_scroll_pos > filename_scroll_max) {
-          filename_scroll_pos = 0;
-          lcd_status_update_delay = 12;
-        }
+        lcd_status_update_delay = ++filename_scroll_pos >= filename_scroll_max ? 12 : 4; // Long delay at end and start
+        if (filename_scroll_pos > filename_scroll_max) filename_scroll_pos = 0;
         refresh(LCDVIEW_REDRAW_NOW);
         RESET_STATUS_TIMEOUT();
       }

commit f8ee6f8b3176b6df7bc3d23119a4bee36c6ff0d8
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Nov 10 22:39:34 2020 -0300

    Fix UI compile issues (#20092)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 1994e4094b..17c3c3edfe 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -262,67 +262,71 @@ millis_t MarlinUI::next_button_update_ms; // = 0
 
   #endif
 
-  void _wrap_string(uint8_t &col, uint8_t &row, const char * const string, read_byte_cb_t cb_read_byte, bool wordwrap/*=false*/) {
-    SETCURSOR(col, row);
-    if (!string) return;
-
-    auto _newline = [&col, &row]{
-      col = 0; row++;                 // Move col to string len (plus space)
-      SETCURSOR(0, row);              // Simulate carriage return
-    };
-
-    uint8_t *p = (uint8_t*)string;
-    wchar_t ch;
-    if (wordwrap) {
-      uint8_t *wrd = nullptr, c = 0;
-      // find the end of the part
-      for (;;) {
-        if (!wrd) wrd = p;            // Get word start /before/ advancing
-        p = get_utf8_value_cb(p, cb_read_byte, &ch);
-        const bool eol = !ch;         // zero ends the string
-        // End or a break between phrases?
-        if (eol || ch == ' ' || ch == '-' || ch == '+' || ch == '.') {
-          if (!c && ch == ' ') { if (wrd) wrd++; continue; } // collapse extra spaces
-          // Past the right and the word is not too long?
-          if (col + c > LCD_WIDTH && col >= (LCD_WIDTH) / 4) _newline(); // should it wrap?
-          c += !eol;                  // +1 so the space will be printed
-          col += c;                   // advance col to new position
-          while (c) {                 // character countdown
-            --c;                      // count down to zero
-            wrd = get_utf8_value_cb(wrd, cb_read_byte, &ch); // get characters again
-            lcd_put_wchar(ch);        // character to the LCD
+  #if !HAS_GRAPHICAL_TFT
+
+    void _wrap_string(uint8_t &col, uint8_t &row, const char * const string, read_byte_cb_t cb_read_byte, bool wordwrap/*=false*/) {
+      SETCURSOR(col, row);
+      if (!string) return;
+
+      auto _newline = [&col, &row]{
+        col = 0; row++;                 // Move col to string len (plus space)
+        SETCURSOR(0, row);              // Simulate carriage return
+      };
+
+      uint8_t *p = (uint8_t*)string;
+      wchar_t ch;
+      if (wordwrap) {
+        uint8_t *wrd = nullptr, c = 0;
+        // find the end of the part
+        for (;;) {
+          if (!wrd) wrd = p;            // Get word start /before/ advancing
+          p = get_utf8_value_cb(p, cb_read_byte, &ch);
+          const bool eol = !ch;         // zero ends the string
+          // End or a break between phrases?
+          if (eol || ch == ' ' || ch == '-' || ch == '+' || ch == '.') {
+            if (!c && ch == ' ') { if (wrd) wrd++; continue; } // collapse extra spaces
+            // Past the right and the word is not too long?
+            if (col + c > LCD_WIDTH && col >= (LCD_WIDTH) / 4) _newline(); // should it wrap?
+            c += !eol;                  // +1 so the space will be printed
+            col += c;                   // advance col to new position
+            while (c) {                 // character countdown
+              --c;                      // count down to zero
+              wrd = get_utf8_value_cb(wrd, cb_read_byte, &ch); // get characters again
+              lcd_put_wchar(ch);        // character to the LCD
+            }
+            if (eol) break;             // all done!
+            wrd = nullptr;              // set up for next word
           }
-          if (eol) break;             // all done!
-          wrd = nullptr;              // set up for next word
+          else c++;                     // count word characters
         }
-        else c++;                     // count word characters
       }
-    }
-    else {
-      for (;;) {
-        p = get_utf8_value_cb(p, cb_read_byte, &ch);
-        if (!ch) break;
-        lcd_put_wchar(ch);
-        col++;
-        if (col >= LCD_WIDTH) _newline();
+      else {
+        for (;;) {
+          p = get_utf8_value_cb(p, cb_read_byte, &ch);
+          if (!ch) break;
+          lcd_put_wchar(ch);
+          col++;
+          if (col >= LCD_WIDTH) _newline();
+        }
       }
     }
-  }
 
-  void MarlinUI::draw_select_screen_prompt(PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
-    const uint8_t plen = utf8_strlen_P(pref), slen = suff ? utf8_strlen_P(suff) : 0;
-    uint8_t col = 0, row = 0;
-    if (!string && plen + slen <= LCD_WIDTH) {
-      col = (LCD_WIDTH - plen - slen) / 2;
-      row = LCD_HEIGHT > 3 ? 1 : 0;
-    }
-    wrap_string_P(col, row, pref, true);
-    if (string) {
-      if (col) { col = 0; row++; } // Move to the start of the next line
-      wrap_string(col, row, string);
+    void MarlinUI::draw_select_screen_prompt(PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
+      const uint8_t plen = utf8_strlen_P(pref), slen = suff ? utf8_strlen_P(suff) : 0;
+      uint8_t col = 0, row = 0;
+      if (!string && plen + slen <= LCD_WIDTH) {
+        col = (LCD_WIDTH - plen - slen) / 2;
+        row = LCD_HEIGHT > 3 ? 1 : 0;
+      }
+      wrap_string_P(col, row, pref, true);
+      if (string) {
+        if (col) { col = 0; row++; } // Move to the start of the next line
+        wrap_string(col, row, string);
+      }
+      if (suff) wrap_string_P(col, row, suff);
     }
-    if (suff) wrap_string_P(col, row, suff);
-  }
+
+  #endif // !HAS_GRAPHICAL_TFT
 
 #endif // HAS_LCD_MENU
 

commit c0b4f4eb47ee9d657581035737383d15b3706b79
Author: Lucas Seiki Oshiro <lucasseikioshiro@gmail.com>
Date:   Tue Oct 27 22:41:12 2020 -0300

    "Sound: ON/OFF" menu item (#19901)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 0a87965721..1994e4094b 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -74,12 +74,17 @@ constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
   #endif
 #endif
 
+#if ENABLED(SOUND_MENU_ITEM)
+  bool MarlinUI::buzzer_enabled = true;
+#endif
+
 #if EITHER(PCA9632_BUZZER, USE_BEEPER)
   #include "../libs/buzzer.h" // for BUZZ() macro
   #if ENABLED(PCA9632_BUZZER)
     #include "../feature/leds/pca9632.h"
   #endif
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
+    if (!buzzer_enabled) return;
     #if ENABLED(PCA9632_BUZZER)
       PCA9632_buzz(duration, freq);
     #elif USE_BEEPER

commit c4f3f67537c65c446cdc8ecf3a46a7a7a32211de
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 25 04:19:51 2020 -0500

    Followup for BTN_ENC_EN

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 9c456c25c9..0a87965721 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -808,6 +808,14 @@ millis_t next_lcd_update_ms;
   millis_t MarlinUI::return_to_status_ms = 0;
 #endif
 
+inline bool can_encode() {
+  #if BUTTON_EXISTS(ENC_EN)
+    return !BUTTON_PRESSED(ENC_EN);  // Update position only when ENC_EN is HIGH
+  #else
+    return true;
+  #endif
+}
+
 void MarlinUI::update() {
 
   static uint16_t max_display_update_time = 0;
@@ -961,9 +969,7 @@ void MarlinUI::update() {
 
           #endif // ENCODER_RATE_MULTIPLIER
 
-          // Update position only when ENC_EN is HIGH
-          if (TERN1(BTN_ENC_EN, !BUTTON_PRESSED(ENC_EN)))
-            encoderPosition += (encoderDiff * encoderMultiplier) / epps;
+          if (can_encode()) encoderPosition += (encoderDiff * encoderMultiplier) / epps;
 
           encoderDiff = 0;
         }
@@ -1182,8 +1188,7 @@ void MarlinUI::update() {
             if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
           #endif
           #if BUTTON_EXISTS(ENC)
-            // Update button only when ENC_EN is HIGH
-            if (TERN1(BTN_ENC_EN, !BUTTON_PRESSED(ENC_EN)) && BUTTON_PRESSED(ENC)) newbutton |= EN_C;
+            if (can_encode() && BUTTON_PRESSED(ENC)) newbutton |= EN_C;
           #endif
           #if BUTTON_EXISTS(BACK)
             if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;

commit 62ba799d72daabb585da5b2b4ff67d45130c7061
Author: Gurmeet Athwal <gurmeet.athwal@gmail.com>
Date:   Sun Oct 25 06:11:52 2020 +0530

    Add 'BTN_ENC_EN' for SKR V1.4 with DOGM (#19796)

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
index 487678eccf..9c456c25c9 100644
--- a/Marlin/src/lcd/marlinui.cpp
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -337,6 +337,10 @@ void MarlinUI::init() {
       SET_INPUT_PULLUP(BTN_ENC);
     #endif
 
+    #if BUTTON_EXISTS(ENC_EN)
+      SET_INPUT_PULLUP(BTN_ENC_EN);
+    #endif
+
     #if BUTTON_EXISTS(BACK)
       SET_INPUT_PULLUP(BTN_BACK);
     #endif
@@ -957,7 +961,10 @@ void MarlinUI::update() {
 
           #endif // ENCODER_RATE_MULTIPLIER
 
-          encoderPosition += (encoderDiff * encoderMultiplier) / epps;
+          // Update position only when ENC_EN is HIGH
+          if (TERN1(BTN_ENC_EN, !BUTTON_PRESSED(ENC_EN)))
+            encoderPosition += (encoderDiff * encoderMultiplier) / epps;
+
           encoderDiff = 0;
         }
 
@@ -1175,7 +1182,8 @@ void MarlinUI::update() {
             if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
           #endif
           #if BUTTON_EXISTS(ENC)
-            if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
+            // Update button only when ENC_EN is HIGH
+            if (TERN1(BTN_ENC_EN, !BUTTON_PRESSED(ENC_EN)) && BUTTON_PRESSED(ENC)) newbutton |= EN_C;
           #endif
           #if BUTTON_EXISTS(BACK)
             if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/lcd/marlinui.cpp b/Marlin/src/lcd/marlinui.cpp
new file mode 100644
index 0000000000..487678eccf
--- /dev/null
+++ b/Marlin/src/lcd/marlinui.cpp
@@ -0,0 +1,1688 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../inc/MarlinConfig.h"
+
+#ifdef LED_BACKLIGHT_TIMEOUT
+  #include "../feature/leds/leds.h"
+#endif
+
+#if ENABLED(HOST_ACTION_COMMANDS)
+  #include "../feature/host_actions.h"
+#endif
+
+// All displays share the MarlinUI class
+#include "marlinui.h"
+MarlinUI ui;
+
+#if HAS_DISPLAY
+  #include "../module/printcounter.h"
+  #include "../MarlinCore.h"
+  #include "../gcode/queue.h"
+  #include "fontutils.h"
+  #include "../sd/cardreader.h"
+  #if EITHER(EXTENSIBLE_UI, DWIN_CREALITY_LCD)
+    #define START_OF_UTF8_CHAR(C) (((C) & 0xC0u) != 0x80U)
+  #endif
+#endif
+
+#if LCD_HAS_WAIT_FOR_MOVE
+  bool MarlinUI::wait_for_move; // = false
+#endif
+
+constexpr uint8_t epps = ENCODER_PULSES_PER_STEP;
+
+#if HAS_WIRED_LCD
+  #if ENABLED(STATUS_MESSAGE_SCROLLING)
+    uint8_t MarlinUI::status_scroll_offset; // = 0
+    constexpr uint8_t MAX_MESSAGE_LENGTH = _MAX(LONG_FILENAME_LENGTH, MAX_LANG_CHARSIZE * 2 * (LCD_WIDTH));
+  #else
+    constexpr uint8_t MAX_MESSAGE_LENGTH = MAX_LANG_CHARSIZE * (LCD_WIDTH);
+  #endif
+#elif EITHER(EXTENSIBLE_UI, DWIN_CREALITY_LCD)
+  constexpr uint8_t MAX_MESSAGE_LENGTH = 63;
+#endif
+
+#if EITHER(HAS_WIRED_LCD, EXTENSIBLE_UI)
+  uint8_t MarlinUI::alert_level; // = 0
+  char MarlinUI::status_message[MAX_MESSAGE_LENGTH + 1];
+#endif
+
+#if ENABLED(LCD_SET_PROGRESS_MANUALLY)
+  MarlinUI::progress_t MarlinUI::progress_override; // = 0
+  #if BOTH(LCD_SET_PROGRESS_MANUALLY, USE_M73_REMAINING_TIME)
+    uint32_t MarlinUI::remaining_time;
+  #endif
+#endif
+
+#if EITHER(PCA9632_BUZZER, USE_BEEPER)
+  #include "../libs/buzzer.h" // for BUZZ() macro
+  #if ENABLED(PCA9632_BUZZER)
+    #include "../feature/leds/pca9632.h"
+  #endif
+  void MarlinUI::buzz(const long duration, const uint16_t freq) {
+    #if ENABLED(PCA9632_BUZZER)
+      PCA9632_buzz(duration, freq);
+    #elif USE_BEEPER
+      buzzer.tone(duration, freq);
+    #endif
+  }
+#endif
+
+#if PREHEAT_COUNT
+  preheat_t MarlinUI::material_preset[PREHEAT_COUNT];  // Initialized by settings.load()
+  PGM_P MarlinUI::get_preheat_label(const uint8_t m) {
+    #ifdef PREHEAT_1_LABEL
+      static PGMSTR(preheat_0_label, PREHEAT_1_LABEL);
+    #endif
+    #ifdef PREHEAT_2_LABEL
+      static PGMSTR(preheat_1_label, PREHEAT_2_LABEL);
+    #endif
+    #ifdef PREHEAT_3_LABEL
+      static PGMSTR(preheat_2_label, PREHEAT_3_LABEL);
+    #endif
+    #ifdef PREHEAT_4_LABEL
+      static PGMSTR(preheat_3_label, PREHEAT_4_LABEL);
+    #endif
+    #ifdef PREHEAT_5_LABEL
+      static PGMSTR(preheat_4_label, PREHEAT_5_LABEL);
+    #endif
+
+    #define _PLBL(N) preheat_##N##_label,
+    static PGM_P const preheat_labels[PREHEAT_COUNT] PROGMEM = { REPEAT(PREHEAT_COUNT, _PLBL) };
+
+    return (PGM_P)pgm_read_ptr(&preheat_labels[m]);
+  }
+#endif
+
+#if HAS_WIRED_LCD
+
+#if HAS_MARLINUI_U8GLIB
+  #include "dogm/marlinui_DOGM.h"
+#endif
+
+#include "lcdprint.h"
+
+#include "../sd/cardreader.h"
+
+#include "../module/temperature.h"
+#include "../module/planner.h"
+#include "../module/motion.h"
+
+#if HAS_LCD_MENU
+  #include "../module/settings.h"
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+  #include "../feature/bedlevel/bedlevel.h"
+#endif
+
+#if HAS_TRINAMIC_CONFIG
+  #include "../feature/tmc_util.h"
+#endif
+
+#if HAS_ADC_BUTTONS
+  #include "../module/thermistor/thermistors.h"
+#endif
+
+#if HAS_POWER_MONITOR
+  #include "../feature/power_monitor.h"
+#endif
+
+#if HAS_ENCODER_ACTION
+  volatile uint8_t MarlinUI::buttons;
+  #if HAS_SLOW_BUTTONS
+    volatile uint8_t MarlinUI::slow_buttons;
+  #endif
+  #if HAS_TOUCH_XPT2046
+    #include "touch/touch_buttons.h"
+    bool MarlinUI::on_edit_screen = false;
+  #endif
+#endif
+
+#if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
+  bool MarlinUI::defer_return_to_status;
+#endif
+
+uint8_t MarlinUI::lcd_status_update_delay = 1; // First update one loop delayed
+
+#if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+  millis_t MarlinUI::next_filament_display; // = 0
+#endif
+
+millis_t MarlinUI::next_button_update_ms; // = 0
+
+#if HAS_MARLINUI_U8GLIB
+  bool MarlinUI::drawing_screen, MarlinUI::first_page; // = false
+#endif
+
+// Encoder Handling
+#if HAS_ENCODER_ACTION
+  uint32_t MarlinUI::encoderPosition;
+  volatile int8_t encoderDiff; // Updated in update_buttons, added to encoderPosition every LCD update
+#endif
+
+#if ENABLED(SDSUPPORT)
+
+  #include "../sd/cardreader.h"
+
+  #if MARLINUI_SCROLL_NAME
+    uint8_t MarlinUI::filename_scroll_pos, MarlinUI::filename_scroll_max;
+  #endif
+
+  const char * MarlinUI::scrolled_filename(CardReader &theCard, const uint8_t maxlen, uint8_t hash, const bool doScroll) {
+    const char *outstr = theCard.longest_filename();
+    if (theCard.longFilename[0]) {
+      #if MARLINUI_SCROLL_NAME
+        if (doScroll) {
+          for (uint8_t l = FILENAME_LENGTH; l--;)
+            hash = ((hash << 1) | (hash >> 7)) ^ theCard.filename[l];      // rotate, xor
+          static uint8_t filename_scroll_hash;
+          if (filename_scroll_hash != hash) {                              // If the hash changed...
+            filename_scroll_hash = hash;                                   // Save the new hash
+            filename_scroll_max = _MAX(0, utf8_strlen(theCard.longFilename) - maxlen); // Update the scroll limit
+            filename_scroll_pos = 0;                                       // Reset scroll to the start
+            lcd_status_update_delay = 8;                                   // Don't scroll right away
+          }
+          outstr += filename_scroll_pos;
+        }
+      #else
+        theCard.longFilename[maxlen] = '\0'; // cutoff at screen edge
+      #endif
+    }
+    return outstr;
+  }
+
+#endif
+
+#if HAS_LCD_MENU
+  #include "menu/menu.h"
+
+  screenFunc_t MarlinUI::currentScreen; // Initialized in CTOR
+  bool MarlinUI::screen_changed;
+
+  #if ENABLED(ENCODER_RATE_MULTIPLIER)
+    bool MarlinUI::encoderRateMultiplierEnabled;
+    millis_t MarlinUI::lastEncoderMovementMillis = 0;
+    void MarlinUI::enable_encoder_multiplier(const bool onoff) {
+      encoderRateMultiplierEnabled = onoff;
+      lastEncoderMovementMillis = 0;
+    }
+  #endif
+
+  #if EITHER(REVERSE_MENU_DIRECTION, REVERSE_SELECT_DIRECTION)
+    int8_t MarlinUI::encoderDirection = ENCODERBASE;
+  #endif
+
+  #if HAS_TOUCH_XPT2046
+    uint8_t MarlinUI::touch_buttons;
+    uint8_t MarlinUI::repeat_delay;
+  #endif
+
+  bool MarlinUI::lcd_clicked;
+
+  bool MarlinUI::use_click() {
+    const bool click = lcd_clicked;
+    lcd_clicked = false;
+    return click;
+  }
+
+  #if EITHER(AUTO_BED_LEVELING_UBL, G26_MESH_VALIDATION)
+
+    bool MarlinUI::external_control; // = false
+
+    void MarlinUI::wait_for_release() {
+      while (button_pressed()) safe_delay(50);
+      safe_delay(50);
+    }
+
+  #endif
+
+  void _wrap_string(uint8_t &col, uint8_t &row, const char * const string, read_byte_cb_t cb_read_byte, bool wordwrap/*=false*/) {
+    SETCURSOR(col, row);
+    if (!string) return;
+
+    auto _newline = [&col, &row]{
+      col = 0; row++;                 // Move col to string len (plus space)
+      SETCURSOR(0, row);              // Simulate carriage return
+    };
+
+    uint8_t *p = (uint8_t*)string;
+    wchar_t ch;
+    if (wordwrap) {
+      uint8_t *wrd = nullptr, c = 0;
+      // find the end of the part
+      for (;;) {
+        if (!wrd) wrd = p;            // Get word start /before/ advancing
+        p = get_utf8_value_cb(p, cb_read_byte, &ch);
+        const bool eol = !ch;         // zero ends the string
+        // End or a break between phrases?
+        if (eol || ch == ' ' || ch == '-' || ch == '+' || ch == '.') {
+          if (!c && ch == ' ') { if (wrd) wrd++; continue; } // collapse extra spaces
+          // Past the right and the word is not too long?
+          if (col + c > LCD_WIDTH && col >= (LCD_WIDTH) / 4) _newline(); // should it wrap?
+          c += !eol;                  // +1 so the space will be printed
+          col += c;                   // advance col to new position
+          while (c) {                 // character countdown
+            --c;                      // count down to zero
+            wrd = get_utf8_value_cb(wrd, cb_read_byte, &ch); // get characters again
+            lcd_put_wchar(ch);        // character to the LCD
+          }
+          if (eol) break;             // all done!
+          wrd = nullptr;              // set up for next word
+        }
+        else c++;                     // count word characters
+      }
+    }
+    else {
+      for (;;) {
+        p = get_utf8_value_cb(p, cb_read_byte, &ch);
+        if (!ch) break;
+        lcd_put_wchar(ch);
+        col++;
+        if (col >= LCD_WIDTH) _newline();
+      }
+    }
+  }
+
+  void MarlinUI::draw_select_screen_prompt(PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
+    const uint8_t plen = utf8_strlen_P(pref), slen = suff ? utf8_strlen_P(suff) : 0;
+    uint8_t col = 0, row = 0;
+    if (!string && plen + slen <= LCD_WIDTH) {
+      col = (LCD_WIDTH - plen - slen) / 2;
+      row = LCD_HEIGHT > 3 ? 1 : 0;
+    }
+    wrap_string_P(col, row, pref, true);
+    if (string) {
+      if (col) { col = 0; row++; } // Move to the start of the next line
+      wrap_string(col, row, string);
+    }
+    if (suff) wrap_string_P(col, row, suff);
+  }
+
+#endif // HAS_LCD_MENU
+
+void MarlinUI::init() {
+
+  init_lcd();
+
+  #if HAS_DIGITAL_BUTTONS
+
+    #if BUTTON_EXISTS(EN1)
+      SET_INPUT_PULLUP(BTN_EN1);
+    #endif
+    #if BUTTON_EXISTS(EN2)
+      SET_INPUT_PULLUP(BTN_EN2);
+    #endif
+    #if BUTTON_EXISTS(ENC)
+      SET_INPUT_PULLUP(BTN_ENC);
+    #endif
+
+    #if BUTTON_EXISTS(BACK)
+      SET_INPUT_PULLUP(BTN_BACK);
+    #endif
+
+    #if BUTTON_EXISTS(UP)
+      SET_INPUT(BTN_UP);
+    #endif
+    #if BUTTON_EXISTS(DWN)
+      SET_INPUT(BTN_DWN);
+    #endif
+    #if BUTTON_EXISTS(LFT)
+      SET_INPUT(BTN_LFT);
+    #endif
+    #if BUTTON_EXISTS(RT)
+      SET_INPUT(BTN_RT);
+    #endif
+
+  #endif // !HAS_DIGITAL_BUTTONS
+
+  #if HAS_SHIFT_ENCODER
+
+    #if ENABLED(SR_LCD_2W_NL) // Non latching 2 wire shift register
+
+      SET_OUTPUT(SR_DATA_PIN);
+      SET_OUTPUT(SR_CLK_PIN);
+
+    #elif defined(SHIFT_CLK)
+
+      SET_OUTPUT(SHIFT_CLK);
+      OUT_WRITE(SHIFT_LD, HIGH);
+      #if defined(SHIFT_EN) && SHIFT_EN >= 0
+        OUT_WRITE(SHIFT_EN, LOW);
+      #endif
+      SET_INPUT_PULLUP(SHIFT_OUT);
+
+    #endif
+
+  #endif // HAS_SHIFT_ENCODER
+
+  #if BOTH(HAS_ENCODER_ACTION, HAS_SLOW_BUTTONS)
+    slow_buttons = 0;
+  #endif
+
+  update_buttons();
+
+  TERN_(HAS_ENCODER_ACTION, encoderDiff = 0);
+}
+
+bool MarlinUI::get_blink() {
+  static uint8_t blink = 0;
+  static millis_t next_blink_ms = 0;
+  millis_t ms = millis();
+  if (ELAPSED(ms, next_blink_ms)) {
+    blink ^= 0xFF;
+    next_blink_ms = ms + 1000 - (LCD_UPDATE_INTERVAL) / 2;
+  }
+  return blink != 0;
+}
+
+////////////////////////////////////////////
+///////////// Keypad Handling //////////////
+////////////////////////////////////////////
+
+#if IS_RRW_KEYPAD && HAS_ENCODER_ACTION
+
+  volatile uint8_t MarlinUI::keypad_buttons;
+
+  #if HAS_LCD_MENU && !HAS_ADC_BUTTONS
+
+    void lcd_move_x();
+    void lcd_move_y();
+    void lcd_move_z();
+
+    void _reprapworld_keypad_move(const AxisEnum axis, const int16_t dir) {
+      ui.manual_move.menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
+      ui.encoderPosition = dir;
+      switch (axis) {
+        case X_AXIS: lcd_move_x(); break;
+        case Y_AXIS: lcd_move_y(); break;
+        case Z_AXIS: lcd_move_z();
+        default: break;
+      }
+    }
+
+  #endif
+
+  bool MarlinUI::handle_keypad() {
+
+    #if HAS_ADC_BUTTONS
+
+      #define ADC_MIN_KEY_DELAY 100
+      if (keypad_buttons) {
+        #if HAS_ENCODER_ACTION
+          refresh(LCDVIEW_REDRAW_NOW);
+          #if HAS_LCD_MENU
+            if (encoderDirection == -(ENCODERBASE)) { // HAS_ADC_BUTTONS forces REVERSE_MENU_DIRECTION, so this indicates menu navigation
+                   if (RRK(EN_KEYPAD_UP))     encoderPosition += ENCODER_STEPS_PER_MENU_ITEM;
+              else if (RRK(EN_KEYPAD_DOWN))   encoderPosition -= ENCODER_STEPS_PER_MENU_ITEM;
+              else if (RRK(EN_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
+              else if (RRK(EN_KEYPAD_RIGHT))  { return_to_status(); quick_feedback(); }
+            }
+            else
+          #endif
+          {
+            #if HAS_LCD_MENU
+                   if (RRK(EN_KEYPAD_UP))     encoderPosition -= epps;
+              else if (RRK(EN_KEYPAD_DOWN))   encoderPosition += epps;
+              else if (RRK(EN_KEYPAD_LEFT))   { MenuItem_back::action(); quick_feedback(); }
+              else if (RRK(EN_KEYPAD_RIGHT))  encoderPosition = 0;
+            #else
+                   if (RRK(EN_KEYPAD_UP)   || RRK(EN_KEYPAD_LEFT))  encoderPosition -= epps;
+              else if (RRK(EN_KEYPAD_DOWN) || RRK(EN_KEYPAD_RIGHT)) encoderPosition += epps;
+            #endif
+          }
+        #endif
+        next_button_update_ms = millis() + ADC_MIN_KEY_DELAY;
+        return true;
+      }
+
+    #else // !HAS_ADC_BUTTONS
+
+      static uint8_t keypad_debounce = 0;
+
+      if (!RRK( EN_KEYPAD_F1    | EN_KEYPAD_F2
+              | EN_KEYPAD_F3    | EN_KEYPAD_DOWN
+              | EN_KEYPAD_RIGHT | EN_KEYPAD_MIDDLE
+              | EN_KEYPAD_UP    | EN_KEYPAD_LEFT )
+      ) {
+        if (keypad_debounce > 0) keypad_debounce--;
+      }
+      else if (!keypad_debounce) {
+        keypad_debounce = 2;
+
+        const bool homed = all_axes_homed();
+
+        #if HAS_LCD_MENU
+
+          if (RRK(EN_KEYPAD_MIDDLE))  goto_screen(menu_move);
+
+          #if DISABLED(DELTA) && Z_HOME_DIR < 0
+            if (RRK(EN_KEYPAD_F2))    _reprapworld_keypad_move(Z_AXIS,  1);
+          #endif
+
+          if (homed) {
+            #if ENABLED(DELTA) || Z_HOME_DIR != -1
+              if (RRK(EN_KEYPAD_F2))  _reprapworld_keypad_move(Z_AXIS,  1);
+            #endif
+            if (RRK(EN_KEYPAD_F3))    _reprapworld_keypad_move(Z_AXIS, -1);
+            if (RRK(EN_KEYPAD_LEFT))  _reprapworld_keypad_move(X_AXIS, -1);
+            if (RRK(EN_KEYPAD_RIGHT)) _reprapworld_keypad_move(X_AXIS,  1);
+            if (RRK(EN_KEYPAD_DOWN))  _reprapworld_keypad_move(Y_AXIS,  1);
+            if (RRK(EN_KEYPAD_UP))    _reprapworld_keypad_move(Y_AXIS, -1);
+          }
+
+        #endif // HAS_LCD_MENU
+
+        if (!homed && RRK(EN_KEYPAD_F1)) queue.inject_P(G28_STR);
+        return true;
+      }
+
+    #endif // !HAS_ADC_BUTTONS
+
+    return false;
+  }
+
+#endif // IS_RRW_KEYPAD && HAS_ENCODER_ACTION
+
+/**
+ * Status Screen
+ *
+ * This is very display-dependent, so the lcd implementation draws this.
+ */
+
+#if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
+  millis_t MarlinUI::progress_bar_ms; // = 0
+  #if PROGRESS_MSG_EXPIRE > 0
+    millis_t MarlinUI::expire_status_ms; // = 0
+  #endif
+#endif
+
+void MarlinUI::status_screen() {
+
+  TERN_(HAS_LCD_MENU, ENCODER_RATE_MULTIPLY(false));
+
+  #if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
+
+    //
+    // HD44780 implements the following message blinking and
+    // message expiration because Status Line and Progress Bar
+    // share the same line on the display.
+    //
+
+    #if DISABLED(PROGRESS_MSG_ONCE) || (PROGRESS_MSG_EXPIRE > 0)
+      #define GOT_MS
+      const millis_t ms = millis();
+    #endif
+
+    // If the message will blink rather than expire...
+    #if DISABLED(PROGRESS_MSG_ONCE)
+      if (ELAPSED(ms, progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME))
+        progress_bar_ms = ms;
+    #endif
+
+    #if PROGRESS_MSG_EXPIRE > 0
+
+      // Handle message expire
+      if (expire_status_ms) {
+
+        // Expire the message if a job is active and the bar has ticks
+        if (get_progress_percent() > 2 && !print_job_timer.isPaused()) {
+          if (ELAPSED(ms, expire_status_ms)) {
+            status_message[0] = '\0';
+            expire_status_ms = 0;
+          }
+        }
+        else {
+          // Defer message expiration before bar appears
+          // and during any pause (not just SD)
+          expire_status_ms += LCD_UPDATE_INTERVAL;
+        }
+      }
+
+    #endif // PROGRESS_MSG_EXPIRE
+
+  #endif // LCD_PROGRESS_BAR
+
+  #if HAS_LCD_MENU
+    if (use_click()) {
+      #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+        next_filament_display = millis() + 5000UL;  // Show status message for 5s
+      #endif
+      goto_screen(menu_main);
+      #if DISABLED(NO_LCD_REINIT)
+        init_lcd(); // May revive the LCD if static electricity killed it
+      #endif
+      return;
+    }
+
+  #endif
+
+  #if ENABLED(ULTIPANEL_FEEDMULTIPLY)
+
+    const int16_t old_frm = feedrate_percentage;
+          int16_t new_frm = old_frm + int16_t(encoderPosition);
+
+    // Dead zone at 100% feedrate
+    if (old_frm == 100) {
+      if (int16_t(encoderPosition) > ENCODER_FEEDRATE_DEADZONE)
+        new_frm -= ENCODER_FEEDRATE_DEADZONE;
+      else if (int16_t(encoderPosition) < -(ENCODER_FEEDRATE_DEADZONE))
+        new_frm += ENCODER_FEEDRATE_DEADZONE;
+      else
+        new_frm = old_frm;
+    }
+    else if ((old_frm < 100 && new_frm > 100) || (old_frm > 100 && new_frm < 100))
+      new_frm = 100;
+
+    LIMIT(new_frm, 10, 999);
+
+    if (old_frm != new_frm) {
+      feedrate_percentage = new_frm;
+      encoderPosition = 0;
+      #if BOTH(HAS_BUZZER, BEEP_ON_FEEDRATE_CHANGE)
+        static millis_t next_beep;
+        #ifndef GOT_MS
+          const millis_t ms = millis();
+        #endif
+        if (ELAPSED(ms, next_beep)) {
+          buzz(FEEDRATE_CHANGE_BEEP_DURATION, FEEDRATE_CHANGE_BEEP_FREQUENCY);
+          next_beep = ms + 500UL;
+        }
+      #endif
+    }
+
+  #endif // ULTIPANEL_FEEDMULTIPLY
+
+  draw_status_screen();
+}
+
+void MarlinUI::kill_screen(PGM_P lcd_error, PGM_P lcd_component) {
+  init();
+  status_printf_P(1, PSTR(S_FMT ": " S_FMT), lcd_error, lcd_component);
+  TERN_(HAS_LCD_MENU, return_to_status());
+
+  // RED ALERT. RED ALERT.
+  #ifdef LED_BACKLIGHT_TIMEOUT
+    leds.set_color(LEDColorRed());
+    #ifdef NEOPIXEL_BKGD_LED_INDEX
+      neo.set_pixel_color(NEOPIXEL_BKGD_LED_INDEX, 255, 0, 0, 0);
+      neo.show();
+    #endif
+  #endif
+
+  draw_kill_screen();
+}
+
+void MarlinUI::quick_feedback(const bool clear_buttons/*=true*/) {
+
+  TERN_(HAS_LCD_MENU, refresh());
+
+  #if HAS_ENCODER_ACTION
+    if (clear_buttons) buttons = 0;
+    next_button_update_ms = millis() + 500;
+  #else
+    UNUSED(clear_buttons);
+  #endif
+
+  #if HAS_CHIRP
+    chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
+    #if BOTH(HAS_LCD_MENU, USE_BEEPER)
+      for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
+    #elif HAS_LCD_MENU
+      delay(10);
+    #endif
+  #endif
+}
+
+////////////////////////////////////////////
+/////////////// Manual Move ////////////////
+////////////////////////////////////////////
+
+#if HAS_LCD_MENU
+
+  ManualMove MarlinUI::manual_move{};
+
+  millis_t ManualMove::start_time = 0;
+  float ManualMove::menu_scale = 1;
+  TERN_(IS_KINEMATIC, float ManualMove::offset = 0);
+  TERN_(IS_KINEMATIC, bool ManualMove::processing = false);
+  TERN_(MULTI_MANUAL, int8_t ManualMove::e_index = 0);
+  uint8_t ManualMove::axis = (uint8_t)NO_AXIS;
+
+  /**
+   * If a manual move has been posted and its time has arrived, and if the planner
+   * has a space for it, then add a linear move to current_position the planner.
+   *
+   * If any manual move needs to be interrupted, make sure to force a manual move
+   * by setting manual_move.start_time to millis() after updating current_position.
+   *
+   * To post a manual move:
+   *   - Update current_position to the new place you want to go.
+   *   - Set manual_move.axis to an axis like X_AXIS. Use ALL_AXES for diagonal moves.
+   *   - Set manual_move.start_time to a point in the future (in ms) when the move should be done.
+   *
+   * For kinematic machines:
+   *   - Set manual_move.offset to modify one axis and post the move.
+   *     This is used to achieve more rapid stepping on kinematic machines.
+   *
+   * Currently used by the _lcd_move_xyz function in menu_motion.cpp
+   * and the ubl_map_move_to_xy funtion in menu_ubl.cpp.
+   */
+  void ManualMove::task() {
+
+    if (processing) return;   // Prevent re-entry from idle() calls
+
+    // Add a manual move to the queue?
+    if (axis != (uint8_t)NO_AXIS && ELAPSED(millis(), start_time) && !planner.is_full()) {
+
+      const feedRate_t fr_mm_s = (uint8_t(axis) <= E_AXIS) ? manual_feedrate_mm_s[axis] : XY_PROBE_FEEDRATE_MM_S;
+
+      #if IS_KINEMATIC
+
+        #if HAS_MULTI_EXTRUDER
+          const int8_t old_extruder = active_extruder;
+          if (axis == E_AXIS) active_extruder = e_index;
+        #endif
+
+        // Apply a linear offset to a single axis
+        destination = current_position;
+        if (axis <= XYZE) destination[axis] += offset;
+
+        // Reset for the next move
+        offset = 0;
+        axis = (uint8_t)NO_AXIS;
+
+        // DELTA and SCARA machines use segmented moves, which could fill the planner during the call to
+        // move_to_destination. This will cause idle() to be called, which can then call this function while the
+        // previous invocation is being blocked. Modifications to offset shouldn't be made while
+        // processing is true or the planner will get out of sync.
+        processing = true;
+        prepare_internal_move_to_destination(fr_mm_s);  // will set current_position from destination
+        processing = false;
+
+        TERN_(HAS_MULTI_EXTRUDER, active_extruder = old_extruder);
+
+      #else
+
+        // For Cartesian / Core motion simply move to the current_position
+        planner.buffer_line(current_position, fr_mm_s, axis == E_AXIS ? e_index : active_extruder);
+
+        //SERIAL_ECHOLNPAIR("Add planner.move with Axis ", int(axis), " at FR ", fr_mm_s);
+
+        axis = (uint8_t)NO_AXIS;
+
+      #endif
+    }
+  }
+
+  //
+  // Tell ui.update() to start a move to current_position after a short delay.
+  //
+  void ManualMove::soon(AxisEnum move_axis
+    #if MULTI_MANUAL
+      , const int8_t eindex/*=-1*/
+    #endif
+  ) {
+    #if MULTI_MANUAL
+      if (move_axis == E_AXIS) e_index = eindex >= 0 ? eindex : active_extruder;
+    #endif
+    start_time = millis() + (menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
+    axis = (uint8_t)move_axis;
+    //SERIAL_ECHOLNPAIR("Post Move with Axis ", int(axis), " soon.");
+  }
+
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+
+    void MarlinUI::external_encoder() {
+      if (external_control && encoderDiff) {
+        ubl.encoder_diff += encoderDiff;  // Encoder for UBL G29 mesh editing
+        encoderDiff = 0;                  // Hide encoder events from the screen handler
+        refresh(LCDVIEW_REDRAW_NOW);      // ...but keep the refresh.
+      }
+    }
+
+  #endif
+
+#endif // HAS_LCD_MENU
+
+/**
+ * Update the LCD, read encoder buttons, etc.
+ *   - Read button states
+ *   - Check the SD Card slot state
+ *   - Act on RepRap World keypad input
+ *   - Update the encoder position
+ *   - Apply acceleration to the encoder position
+ *   - Do refresh(LCDVIEW_CALL_REDRAW_NOW) on controller events
+ *   - Reset the Info Screen timeout if there's any input
+ *   - Update status indicators, if any
+ *
+ *   Run the current LCD menu handler callback function:
+ *   - Call the handler only if lcdDrawUpdate != LCDVIEW_NONE
+ *   - Before calling the handler, LCDVIEW_CALL_NO_REDRAW => LCDVIEW_NONE
+ *   - Call the menu handler. Menu handlers should do the following:
+ *     - If a value changes, set lcdDrawUpdate to LCDVIEW_REDRAW_NOW and draw the value
+ *       (Encoder events automatically set lcdDrawUpdate for you.)
+ *     - if (should_draw()) { redraw }
+ *     - Before exiting the handler set lcdDrawUpdate to:
+ *       - LCDVIEW_CLEAR_CALL_REDRAW to clear screen and set LCDVIEW_CALL_REDRAW_NEXT.
+ *       - LCDVIEW_REDRAW_NOW to draw now (including remaining stripes).
+ *       - LCDVIEW_CALL_REDRAW_NEXT to draw now and get LCDVIEW_REDRAW_NOW on the next loop.
+ *       - LCDVIEW_CALL_NO_REDRAW to draw now and get LCDVIEW_NONE on the next loop.
+ *     - NOTE: For graphical displays menu handlers may be called 2 or more times per loop,
+ *             so don't change lcdDrawUpdate without considering this.
+ *
+ *   After the menu handler callback runs (or not):
+ *   - Clear the LCD if lcdDrawUpdate == LCDVIEW_CLEAR_CALL_REDRAW
+ *   - Update lcdDrawUpdate for the next loop (i.e., move one state down, usually)
+ *
+ * This function is only called from the main thread.
+ */
+
+LCDViewAction MarlinUI::lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW;
+millis_t next_lcd_update_ms;
+#if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS
+  millis_t MarlinUI::return_to_status_ms = 0;
+#endif
+
+void MarlinUI::update() {
+
+  static uint16_t max_display_update_time = 0;
+  millis_t ms = millis();
+
+  #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
+    #define RESET_STATUS_TIMEOUT() (return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS)
+  #else
+    #define RESET_STATUS_TIMEOUT() NOOP
+  #endif
+
+  #ifdef LED_BACKLIGHT_TIMEOUT
+    leds.update_timeout(powersupply_on);
+  #endif
+
+  #if HAS_LCD_MENU
+
+    // Handle any queued Move Axis motion
+    manual_move.task();
+
+    // Update button states for button_pressed(), etc.
+    // If the state changes the next update may be delayed 300-500ms.
+    update_buttons();
+
+    // If the action button is pressed...
+    static bool wait_for_unclick; // = false
+
+    auto do_click = [&]{
+      wait_for_unclick = true;                        //  - Set debounce flag to ignore continous clicks
+      lcd_clicked = !wait_for_user;                   //  - Keep the click if not waiting for a user-click
+      wait_for_user = false;                          //  - Any click clears wait for user
+      quick_feedback();                               //  - Always make a click sound
+    };
+
+    #if HAS_TOUCH_XPT2046
+      if (touch_buttons) {
+        RESET_STATUS_TIMEOUT();
+        if (touch_buttons & (EN_A | EN_B)) {              // Menu arrows, in priority
+          if (ELAPSED(ms, next_button_update_ms)) {
+            encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * epps * encoderDirection;
+            if (touch_buttons & EN_A) encoderDiff *= -1;
+            TERN_(AUTO_BED_LEVELING_UBL, external_encoder());
+            next_button_update_ms = ms + repeat_delay;    // Assume the repeat delay
+            if (!wait_for_unclick) {
+              next_button_update_ms += 250;               // Longer delay on first press
+              wait_for_unclick = true;                    // Avoid Back/Select click while repeating
+              chirp();
+            }
+          }
+        }
+        else if (!wait_for_unclick && (buttons & EN_C))   // OK button, if not waiting for a debounce release:
+          do_click();
+      }
+      else // keep wait_for_unclick value
+
+    #endif // HAS_TOUCH_XPT2046
+
+      {
+        // Integrated LCD click handling via button_pressed
+        if (!external_control && button_pressed()) {
+          if (!wait_for_unclick) do_click();              // Handle the click
+        }
+        else
+          wait_for_unclick = false;
+      }
+
+    if (LCD_BACK_CLICKED()) {
+      quick_feedback();
+      goto_previous_screen();
+    }
+
+  #endif // HAS_LCD_MENU
+
+  if (ELAPSED(ms, next_lcd_update_ms) || TERN0(HAS_MARLINUI_U8GLIB, drawing_screen)) {
+
+    next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;
+
+    #if HAS_TOUCH_XPT2046
+
+      if (on_status_screen()) next_lcd_update_ms += (LCD_UPDATE_INTERVAL) * 2;
+
+      TERN_(HAS_ENCODER_ACTION, touch_buttons = touch.read_buttons());
+
+    #endif
+
+    TERN_(LCD_HAS_STATUS_INDICATORS, update_indicators());
+
+    #if HAS_ENCODER_ACTION
+
+      TERN_(HAS_SLOW_BUTTONS, slow_buttons = read_slow_buttons()); // Buttons that take too long to read in interrupt context
+
+      if (TERN0(REPRAPWORLD_KEYPAD, handle_keypad()))
+        RESET_STATUS_TIMEOUT();
+
+      uint8_t abs_diff = ABS(encoderDiff);
+
+      #if ENCODER_PULSES_PER_STEP > 1
+        // When reversing the encoder direction, a movement step can be missed because
+        // encoderDiff has a non-zero residual value, making the controller unresponsive.
+        // The fix clears the residual value when the encoder is idle.
+        // Also check if past half the threshold to compensate for missed single steps.
+        static int8_t lastEncoderDiff;
+
+        // Timeout? No decoder change since last check. 10 or 20 times per second.
+        if (encoderDiff == lastEncoderDiff && abs_diff <= epps / 2)   // Same direction & size but not over a half-step?
+          encoderDiff = 0;                                            // Clear residual pulses.
+        else if (WITHIN(abs_diff, epps / 2 + 1, epps - 1)) {          // Past half of threshold?
+          abs_diff = epps;                                            // Treat as a full step size
+          encoderDiff = (encoderDiff < 0 ? -1 : 1) * abs_diff;        // ...in the spin direction.
+        }
+        lastEncoderDiff = encoderDiff;
+      #endif
+
+      const bool encoderPastThreshold = (abs_diff >= epps);
+      if (encoderPastThreshold || lcd_clicked) {
+        if (encoderPastThreshold && TERN1(IS_TFTGLCD_PANEL, !external_control)) {
+
+          #if BOTH(HAS_LCD_MENU, ENCODER_RATE_MULTIPLIER)
+
+            int32_t encoderMultiplier = 1;
+
+            if (encoderRateMultiplierEnabled) {
+              const float encoderMovementSteps = float(abs_diff) / epps;
+
+              if (lastEncoderMovementMillis) {
+                // Note that the rate is always calculated between two passes through the
+                // loop and that the abs of the encoderDiff value is tracked.
+                const float encoderStepRate = encoderMovementSteps / float(ms - lastEncoderMovementMillis) * 1000;
+
+                if (encoderStepRate >= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;
+                else if (encoderStepRate >= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;
+
+                // Enable to output the encoder steps per second value
+                //#define ENCODER_RATE_MULTIPLIER_DEBUG
+                #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)
+                  SERIAL_ECHO_START();
+                  SERIAL_ECHOPAIR("Enc Step Rate: ", encoderStepRate);
+                  SERIAL_ECHOPAIR("  Multiplier: ", encoderMultiplier);
+                  SERIAL_ECHOPAIR("  ENCODER_10X_STEPS_PER_SEC: ", ENCODER_10X_STEPS_PER_SEC);
+                  SERIAL_ECHOPAIR("  ENCODER_100X_STEPS_PER_SEC: ", ENCODER_100X_STEPS_PER_SEC);
+                  SERIAL_EOL();
+                #endif
+              }
+
+              lastEncoderMovementMillis = ms;
+            } // encoderRateMultiplierEnabled
+
+          #else
+
+            constexpr int32_t encoderMultiplier = 1;
+
+          #endif // ENCODER_RATE_MULTIPLIER
+
+          encoderPosition += (encoderDiff * encoderMultiplier) / epps;
+          encoderDiff = 0;
+        }
+
+        RESET_STATUS_TIMEOUT();
+
+        refresh(LCDVIEW_REDRAW_NOW);
+
+        #ifdef LED_BACKLIGHT_TIMEOUT
+          leds.reset_timeout(ms);
+        #endif
+      }
+
+    #endif
+
+    // This runs every ~100ms when idling often enough.
+    // Instead of tracking changes just redraw the Status Screen once per second.
+    if (on_status_screen() && !lcd_status_update_delay--) {
+      lcd_status_update_delay = TERN(HAS_MARLINUI_U8GLIB, 12, 9);
+      if (max_display_update_time) max_display_update_time--;  // Be sure never go to a very big number
+      refresh(LCDVIEW_REDRAW_NOW);
+    }
+
+    #if BOTH(HAS_LCD_MENU, SCROLL_LONG_FILENAMES)
+      // If scrolling of long file names is enabled and we are in the sd card menu,
+      // cause a refresh to occur until all the text has scrolled into view.
+      if (currentScreen == menu_media && !lcd_status_update_delay--) {
+        lcd_status_update_delay = 4;
+        if (++filename_scroll_pos > filename_scroll_max) {
+          filename_scroll_pos = 0;
+          lcd_status_update_delay = 12;
+        }
+        refresh(LCDVIEW_REDRAW_NOW);
+        RESET_STATUS_TIMEOUT();
+      }
+    #endif
+
+    // Then we want to use only 50% of the time
+    const uint16_t bbr2 = planner.block_buffer_runtime() >> 1;
+
+    if ((should_draw() || drawing_screen) && (!bbr2 || bbr2 > max_display_update_time)) {
+
+      // Change state of drawing flag between screen updates
+      if (!drawing_screen) switch (lcdDrawUpdate) {
+        case LCDVIEW_CALL_NO_REDRAW:
+          refresh(LCDVIEW_NONE);
+          break;
+        case LCDVIEW_CLEAR_CALL_REDRAW:
+        case LCDVIEW_CALL_REDRAW_NEXT:
+          refresh(LCDVIEW_REDRAW_NOW);
+        case LCDVIEW_REDRAW_NOW:        // set above, or by a handler through LCDVIEW_CALL_REDRAW_NEXT
+        case LCDVIEW_NONE:
+          break;
+      } // switch
+
+      TERN_(HAS_ADC_BUTTONS, keypad_buttons = 0);
+
+      #if HAS_MARLINUI_U8GLIB
+
+        #if ENABLED(LIGHTWEIGHT_UI)
+          const bool in_status = on_status_screen(),
+                     do_u8g_loop = !in_status;
+          lcd_in_status(in_status);
+          if (in_status) status_screen();
+        #else
+          constexpr bool do_u8g_loop = true;
+        #endif
+
+        if (do_u8g_loop) {
+          if (!drawing_screen) {                // If not already drawing pages
+            u8g.firstPage();                    // Start the first page
+            drawing_screen = first_page = true; // Flag as drawing pages
+          }
+          set_font(FONT_MENU);                  // Setup font for every page draw
+          u8g.setColorIndex(1);                 // And reset the color
+          run_current_screen();                 // Draw and process the current screen
+          first_page = false;
+
+          // The screen handler can clear drawing_screen for an action that changes the screen.
+          // If still drawing and there's another page, update max-time and return now.
+          // The nextPage will already be set up on the next call.
+          if (drawing_screen && (drawing_screen = u8g.nextPage())) {
+            if (on_status_screen())
+              NOLESS(max_display_update_time, millis() - ms);
+            return;
+          }
+        }
+
+      #else
+
+        run_current_screen();
+
+      #endif
+
+      TERN_(HAS_LCD_MENU, lcd_clicked = false);
+
+      // Keeping track of the longest time for an individual LCD update.
+      // Used to do screen throttling when the planner starts to fill up.
+      if (on_status_screen())
+        NOLESS(max_display_update_time, millis() - ms);
+    }
+
+    #if HAS_LCD_MENU && LCD_TIMEOUT_TO_STATUS > 0
+      // Return to Status Screen after a timeout
+      if (on_status_screen() || defer_return_to_status)
+        RESET_STATUS_TIMEOUT();
+      else if (ELAPSED(ms, return_to_status_ms))
+        return_to_status();
+    #endif
+
+    // Change state of drawing flag between screen updates
+    if (!drawing_screen) switch (lcdDrawUpdate) {
+      case LCDVIEW_CLEAR_CALL_REDRAW:
+        clear_lcd(); break;
+      case LCDVIEW_REDRAW_NOW:
+        refresh(LCDVIEW_NONE);
+      case LCDVIEW_NONE:
+      case LCDVIEW_CALL_REDRAW_NEXT:
+      case LCDVIEW_CALL_NO_REDRAW:
+      default: break;
+    } // switch
+
+  } // ELAPSED(ms, next_lcd_update_ms)
+
+  TERN_(HAS_GRAPHICAL_TFT, tft_idle());
+}
+
+#if HAS_ADC_BUTTONS
+
+  typedef struct {
+    uint16_t ADCKeyValueMin, ADCKeyValueMax;
+    uint8_t  ADCKeyNo;
+  } _stADCKeypadTable_;
+
+  #ifndef ADC_BUTTONS_VALUE_SCALE
+    #define ADC_BUTTONS_VALUE_SCALE       1.0  // for the power voltage equal to the reference voltage
+  #endif
+  #ifndef ADC_BUTTONS_R_PULLUP
+    #define ADC_BUTTONS_R_PULLUP          4.7  // common pull-up resistor in the voltage divider
+  #endif
+  #ifndef ADC_BUTTONS_LEFT_R_PULLDOWN
+    #define ADC_BUTTONS_LEFT_R_PULLDOWN   0.47 // pull-down resistor for LEFT button voltage divider
+  #endif
+  #ifndef ADC_BUTTONS_RIGHT_R_PULLDOWN
+    #define ADC_BUTTONS_RIGHT_R_PULLDOWN  4.7  // pull-down resistor for RIGHT button voltage divider
+  #endif
+  #ifndef ADC_BUTTONS_UP_R_PULLDOWN
+    #define ADC_BUTTONS_UP_R_PULLDOWN     1.0  // pull-down resistor for UP button voltage divider
+  #endif
+  #ifndef ADC_BUTTONS_DOWN_R_PULLDOWN
+    #define ADC_BUTTONS_DOWN_R_PULLDOWN   10.0 // pull-down resistor for DOWN button voltage divider
+  #endif
+  #ifndef ADC_BUTTONS_MIDDLE_R_PULLDOWN
+    #define ADC_BUTTONS_MIDDLE_R_PULLDOWN 2.2  // pull-down resistor for MIDDLE button voltage divider
+  #endif
+
+  // Calculate the ADC value for the voltage divider with specified pull-down resistor value
+  #define ADC_BUTTON_VALUE(r)  int(HAL_ADC_RANGE * (ADC_BUTTONS_VALUE_SCALE) * r / (r + ADC_BUTTONS_R_PULLUP))
+
+  static constexpr uint16_t adc_button_tolerance = HAL_ADC_RANGE *   25 / 1024,
+                                adc_other_button = HAL_ADC_RANGE * 1000 / 1024;
+  static const _stADCKeypadTable_ stADCKeyTable[] PROGMEM = {
+    // VALUE_MIN, VALUE_MAX, KEY
+    { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F1     }, // F1
+    { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F2     }, // F2
+    { adc_other_button, HAL_ADC_RANGE, 1 + BLEN_KEYPAD_F3     }, // F3
+    {  ADC_BUTTON_VALUE(ADC_BUTTONS_LEFT_R_PULLDOWN)   - adc_button_tolerance,
+       ADC_BUTTON_VALUE(ADC_BUTTONS_LEFT_R_PULLDOWN)   + adc_button_tolerance, 1 + BLEN_KEYPAD_LEFT   }, // LEFT  ( 272 ...  472)
+    {  ADC_BUTTON_VALUE(ADC_BUTTONS_RIGHT_R_PULLDOWN)  - adc_button_tolerance,
+       ADC_BUTTON_VALUE(ADC_BUTTONS_RIGHT_R_PULLDOWN)  + adc_button_tolerance, 1 + BLEN_KEYPAD_RIGHT  }, // RIGHT (1948 ... 2148)
+    {  ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     - adc_button_tolerance,
+       ADC_BUTTON_VALUE(ADC_BUTTONS_UP_R_PULLDOWN)     + adc_button_tolerance, 1 + BLEN_KEYPAD_UP     }, // UP    ( 618 ...  818)
+    {  ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   - adc_button_tolerance,
+       ADC_BUTTON_VALUE(ADC_BUTTONS_DOWN_R_PULLDOWN)   + adc_button_tolerance, 1 + BLEN_KEYPAD_DOWN   }, // DOWN  (2686 ... 2886)
+    {  ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) - adc_button_tolerance,
+       ADC_BUTTON_VALUE(ADC_BUTTONS_MIDDLE_R_PULLDOWN) + adc_button_tolerance, 1 + BLEN_KEYPAD_MIDDLE }, // ENTER (1205 ... 1405)
+  };
+
+  uint8_t get_ADC_keyValue() {
+    if (thermalManager.ADCKey_count >= 16) {
+      const uint16_t currentkpADCValue = thermalManager.current_ADCKey_raw;
+      thermalManager.current_ADCKey_raw = HAL_ADC_RANGE;
+      thermalManager.ADCKey_count = 0;
+      if (currentkpADCValue < adc_other_button)
+        LOOP_L_N(i, ADC_KEY_NUM) {
+          const uint16_t lo = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMin),
+                         hi = pgm_read_word(&stADCKeyTable[i].ADCKeyValueMax);
+          if (WITHIN(currentkpADCValue, lo, hi)) return pgm_read_byte(&stADCKeyTable[i].ADCKeyNo);
+        }
+    }
+    return 0;
+  }
+
+#endif // HAS_ADC_BUTTONS
+
+#if HAS_ENCODER_ACTION
+
+  /**
+   * Read encoder buttons from the hardware registers
+   * Warning: This function is called from interrupt context!
+   */
+  void MarlinUI::update_buttons() {
+    const millis_t now = millis();
+    if (ELAPSED(now, next_button_update_ms)) {
+
+      #if HAS_DIGITAL_BUTTONS
+
+        #if ANY_BUTTON(EN1, EN2, ENC, BACK)
+
+          uint8_t newbutton = 0;
+
+          #if BUTTON_EXISTS(EN1)
+            if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
+          #endif
+          #if BUTTON_EXISTS(EN2)
+            if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
+          #endif
+          #if BUTTON_EXISTS(ENC)
+            if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
+          #endif
+          #if BUTTON_EXISTS(BACK)
+            if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;
+          #endif
+
+        #else
+
+          constexpr uint8_t newbutton = 0;
+
+        #endif
+
+        //
+        // Directional buttons
+        //
+        #if ANY_BUTTON(UP, DWN, LFT, RT)
+
+          const int8_t pulses = epps * encoderDirection;
+
+          if (false) {
+            // for the else-ifs below
+          }
+          #if BUTTON_EXISTS(UP)
+            else if (BUTTON_PRESSED(UP)) {
+              encoderDiff = (ENCODER_STEPS_PER_MENU_ITEM) * pulses;
+              next_button_update_ms = now + 300;
+            }
+          #endif
+          #if BUTTON_EXISTS(DWN)
+            else if (BUTTON_PRESSED(DWN)) {
+              encoderDiff = -(ENCODER_STEPS_PER_MENU_ITEM) * pulses;
+              next_button_update_ms = now + 300;
+            }
+          #endif
+          #if BUTTON_EXISTS(LFT)
+            else if (BUTTON_PRESSED(LFT)) {
+              encoderDiff = -pulses;
+              next_button_update_ms = now + 300;
+            }
+          #endif
+          #if BUTTON_EXISTS(RT)
+            else if (BUTTON_PRESSED(RT)) {
+              encoderDiff = pulses;
+              next_button_update_ms = now + 300;
+            }
+          #endif
+
+        #endif // UP || DWN || LFT || RT
+
+        buttons = (newbutton
+          #if HAS_SLOW_BUTTONS
+            | slow_buttons
+          #endif
+          #if BOTH(HAS_TOUCH_XPT2046, HAS_ENCODER_ACTION)
+            | (touch_buttons & TERN(HAS_ENCODER_WHEEL, ~(EN_A | EN_B), 0xFF))
+          #endif
+        );
+
+      #elif HAS_ADC_BUTTONS
+
+        buttons = 0;
+
+      #endif
+
+      #if HAS_ADC_BUTTONS
+        if (keypad_buttons == 0) {
+          const uint8_t b = get_ADC_keyValue();
+          if (WITHIN(b, 1, 8)) keypad_buttons = _BV(b - 1);
+        }
+      #endif
+
+      #if HAS_SHIFT_ENCODER
+        /**
+         * Set up Rotary Encoder bit values (for two pin encoders to indicate movement).
+         * These values are independent of which pins are used for EN_A / EN_B indications.
+         * The rotary encoder part is also independent of the LCD chipset.
+         */
+        uint8_t val = 0;
+        WRITE(SHIFT_LD, LOW);
+        WRITE(SHIFT_LD, HIGH);
+        LOOP_L_N(i, 8) {
+          val >>= 1;
+          if (READ(SHIFT_OUT)) SBI(val, 7);
+          WRITE(SHIFT_CLK, HIGH);
+          WRITE(SHIFT_CLK, LOW);
+        }
+        TERN(REPRAPWORLD_KEYPAD, keypad_buttons, buttons) = ~val;
+      #endif
+
+      #if IS_TFTGLCD_PANEL
+        next_button_update_ms = now + (LCD_UPDATE_INTERVAL / 2);
+        buttons = slow_buttons;
+        TERN_(AUTO_BED_LEVELING_UBL, external_encoder());
+      #endif
+
+    } // next_button_update_ms
+
+    #if HAS_ENCODER_WHEEL
+      static uint8_t lastEncoderBits;
+
+      #define encrot0 0
+      #define encrot1 2
+      #define encrot2 3
+      #define encrot3 1
+
+      // Manage encoder rotation
+      #define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: encoderDiff += encoderDirection; break; case _E2: encoderDiff -= encoderDirection; }
+
+      uint8_t enc = 0;
+      if (buttons & EN_A) enc |= B01;
+      if (buttons & EN_B) enc |= B10;
+      if (enc != lastEncoderBits) {
+        switch (enc) {
+          case encrot0: ENCODER_SPIN(encrot3, encrot1); break;
+          case encrot1: ENCODER_SPIN(encrot0, encrot2); break;
+          case encrot2: ENCODER_SPIN(encrot1, encrot3); break;
+          case encrot3: ENCODER_SPIN(encrot2, encrot0); break;
+        }
+        #if BOTH(HAS_LCD_MENU, AUTO_BED_LEVELING_UBL)
+          external_encoder();
+        #endif
+        lastEncoderBits = enc;
+      }
+
+    #endif // HAS_ENCODER_WHEEL
+  }
+
+#endif // HAS_ENCODER_ACTION
+
+#endif // HAS_WIRED_LCD
+
+#if HAS_DISPLAY
+
+  #if ENABLED(EXTENSIBLE_UI)
+    #include "extui/ui_api.h"
+  #endif
+
+  ////////////////////////////////////////////
+  /////////////// Status Line ////////////////
+  ////////////////////////////////////////////
+
+  #if ENABLED(STATUS_MESSAGE_SCROLLING)
+    void MarlinUI::advance_status_scroll() {
+      // Advance by one UTF8 code-word
+      if (status_scroll_offset < utf8_strlen(status_message))
+        while (!START_OF_UTF8_CHAR(status_message[++status_scroll_offset]));
+      else
+        status_scroll_offset = 0;
+    }
+    char* MarlinUI::status_and_len(uint8_t &len) {
+      char *out = status_message + status_scroll_offset;
+      len = utf8_strlen(out);
+      return out;
+    }
+  #endif
+
+  void MarlinUI::finish_status(const bool persist) {
+
+    #if !(ENABLED(LCD_PROGRESS_BAR) && (PROGRESS_MSG_EXPIRE) > 0)
+      UNUSED(persist);
+    #endif
+
+    #if ENABLED(LCD_PROGRESS_BAR) || BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+      const millis_t ms = millis();
+    #endif
+
+    #if ENABLED(LCD_PROGRESS_BAR) && !IS_TFTGLCD_PANEL
+      progress_bar_ms = ms;
+      #if PROGRESS_MSG_EXPIRE > 0
+        expire_status_ms = persist ? 0 : ms + PROGRESS_MSG_EXPIRE;
+      #endif
+    #endif
+
+    #if BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+      next_filament_display = ms + 5000UL; // Show status message for 5s
+    #endif
+
+    #if BOTH(HAS_WIRED_LCD, STATUS_MESSAGE_SCROLLING)
+      status_scroll_offset = 0;
+    #endif
+
+    TERN_(EXTENSIBLE_UI, ExtUI::onStatusChanged(status_message));
+  }
+
+  bool MarlinUI::has_status() { return (status_message[0] != '\0'); }
+
+  void MarlinUI::set_status(const char * const message, const bool persist) {
+    if (alert_level) return;
+
+    TERN_(HOST_PROMPT_SUPPORT, host_action_notify(message));
+
+    // Here we have a problem. The message is encoded in UTF8, so
+    // arbitrarily cutting it will be a problem. We MUST be sure
+    // that there is no cutting in the middle of a multibyte character!
+
+    // Get a pointer to the null terminator
+    const char* pend = message + strlen(message);
+
+    //  If length of supplied UTF8 string is greater than
+    // our buffer size, start cutting whole UTF8 chars
+    while ((pend - message) > MAX_MESSAGE_LENGTH) {
+      --pend;
+      while (!START_OF_UTF8_CHAR(*pend)) --pend;
+    };
+
+    // At this point, we have the proper cut point. Use it
+    uint8_t maxLen = pend - message;
+    strncpy(status_message, message, maxLen);
+    status_message[maxLen] = '\0';
+
+    finish_status(persist);
+  }
+
+  #include <stdarg.h>
+
+  void MarlinUI::status_printf_P(const uint8_t level, PGM_P const fmt, ...) {
+    if (level < alert_level) return;
+    alert_level = level;
+    va_list args;
+    va_start(args, fmt);
+    vsnprintf_P(status_message, MAX_MESSAGE_LENGTH, fmt, args);
+    va_end(args);
+    finish_status(level > 0);
+  }
+
+  void MarlinUI::set_status_P(PGM_P const message, int8_t level) {
+    if (level < 0) level = alert_level = 0;
+    if (level < alert_level) return;
+    alert_level = level;
+
+    TERN_(HOST_PROMPT_SUPPORT, host_action_notify_P(message));
+
+    // Since the message is encoded in UTF8 it must
+    // only be cut on a character boundary.
+
+    // Get a pointer to the null terminator
+    PGM_P pend = message + strlen_P(message);
+
+    // If length of supplied UTF8 string is greater than
+    // the buffer size, start cutting whole UTF8 chars
+    while ((pend - message) > MAX_MESSAGE_LENGTH) {
+      --pend;
+      while (!START_OF_UTF8_CHAR(pgm_read_byte(pend))) --pend;
+    };
+
+    // At this point, we have the proper cut point. Use it
+    uint8_t maxLen = pend - message;
+    strncpy_P(status_message, message, maxLen);
+    status_message[maxLen] = '\0';
+
+    finish_status(level > 0);
+  }
+
+  void MarlinUI::set_alert_status_P(PGM_P const message) {
+    set_status_P(message, 1);
+    TERN_(HAS_LCD_MENU, return_to_status());
+  }
+
+  PGM_P print_paused = GET_TEXT(MSG_PRINT_PAUSED);
+
+  /**
+   * Reset the status message
+   */
+  void MarlinUI::reset_status(const bool no_welcome) {
+    PGM_P printing = GET_TEXT(MSG_PRINTING);
+    PGM_P welcome  = GET_TEXT(WELCOME_MSG);
+    #if SERVICE_INTERVAL_1 > 0
+      static PGMSTR(service1, "> " SERVICE_NAME_1 "!");
+    #endif
+    #if SERVICE_INTERVAL_2 > 0
+      static PGMSTR(service2, "> " SERVICE_NAME_2 "!");
+    #endif
+    #if SERVICE_INTERVAL_3 > 0
+      static PGMSTR(service3, "> " SERVICE_NAME_3 "!");
+    #endif
+    PGM_P msg;
+    if (printingIsPaused())
+      msg = print_paused;
+    #if ENABLED(SDSUPPORT)
+      else if (IS_SD_PRINTING())
+        return set_status(card.longest_filename(), true);
+    #endif
+    else if (print_job_timer.isRunning())
+      msg = printing;
+
+    #if SERVICE_INTERVAL_1 > 0
+      else if (print_job_timer.needsService(1)) msg = service1;
+    #endif
+    #if SERVICE_INTERVAL_2 > 0
+      else if (print_job_timer.needsService(2)) msg = service2;
+    #endif
+    #if SERVICE_INTERVAL_3 > 0
+      else if (print_job_timer.needsService(3)) msg = service3;
+    #endif
+
+    else if (!no_welcome)
+      msg = welcome;
+    else
+      return;
+
+    set_status_P(msg, -1);
+  }
+
+  void MarlinUI::abort_print() {
+    #if ENABLED(SDSUPPORT)
+      wait_for_heatup = wait_for_user = false;
+      card.flag.abort_sd_printing = true;
+    #endif
+    #ifdef ACTION_ON_CANCEL
+      host_action_cancel();
+    #endif
+    TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_INFO, PSTR("UI Aborted"), DISMISS_STR));
+    print_job_timer.stop();
+    set_status_P(GET_TEXT(MSG_PRINT_ABORTED));
+    TERN_(HAS_LCD_MENU, return_to_status());
+  }
+
+  #if ANY(PARK_HEAD_ON_PAUSE, SDSUPPORT)
+    #include "../gcode/queue.h"
+  #endif
+
+  void MarlinUI::pause_print() {
+    #if HAS_LCD_MENU
+      synchronize(GET_TEXT(MSG_PAUSING));
+      defer_status_screen();
+    #endif
+
+    TERN_(HOST_PROMPT_SUPPORT, host_prompt_open(PROMPT_PAUSE_RESUME, PSTR("UI Pause"), PSTR("Resume")));
+
+    set_status_P(print_paused);
+
+    #if ENABLED(PARK_HEAD_ON_PAUSE)
+      TERN_(HAS_WIRED_LCD, lcd_pause_show_message(PAUSE_MESSAGE_PARKING, PAUSE_MODE_PAUSE_PRINT)); // Show message immediately to let user know about pause in progress
+      queue.inject_P(PSTR("M25 P\nM24"));
+    #elif ENABLED(SDSUPPORT)
+      queue.inject_P(PSTR("M25"));
+    #elif defined(ACTION_ON_PAUSE)
+      host_action_pause();
+    #endif
+  }
+
+  void MarlinUI::resume_print() {
+    reset_status();
+    TERN_(PARK_HEAD_ON_PAUSE, wait_for_heatup = wait_for_user = false);
+    if (IS_SD_PAUSED()) queue.inject_P(M24_STR);
+    #ifdef ACTION_ON_RESUME
+      host_action_resume();
+    #endif
+    print_job_timer.start(); // Also called by M24
+  }
+
+  #if HAS_PRINT_PROGRESS
+
+    MarlinUI::progress_t MarlinUI::_get_progress() {
+      return (
+        TERN0(LCD_SET_PROGRESS_MANUALLY, (progress_override & PROGRESS_MASK))
+        #if ENABLED(SDSUPPORT)
+          ?: TERN(HAS_PRINT_PROGRESS_PERMYRIAD, card.permyriadDone(), card.percentDone())
+        #endif
+      );
+    }
+
+  #endif
+
+  #if HAS_TOUCH_XPT2046
+
+    //
+    // Screen Click
+    //  - On menu screens move directly to the touched item
+    //  - On menu screens, right side (last 3 cols) acts like a scroll - half up => prev page, half down = next page
+    //  - On select screens (and others) touch the Right Half for +, Left Half for -
+    //  - On edit screens, touch Up Half for -,  Bottom Half to +
+    //
+    void MarlinUI::screen_click(const uint8_t row, const uint8_t col, const uint8_t, const uint8_t) {
+      const millis_t now = millis();
+      if (PENDING(now, next_button_update_ms)) return;
+      next_button_update_ms = now + repeat_delay;    // Assume the repeat delay
+      const int8_t xdir = col < (LCD_WIDTH ) / 2 ? -1 : 1,
+                   ydir = row < (LCD_HEIGHT) / 2 ? -1 : 1;
+      if (on_edit_screen)
+        encoderDiff = epps * ydir;
+      else if (screen_items > 0) {
+        // Last 5 cols act as a scroll :-)
+        if (col > (LCD_WIDTH) - 5)
+          // 2 * LCD_HEIGHT to scroll to bottom of next page. (LCD_HEIGHT would only go 1 item down.)
+          encoderDiff = epps * (encoderLine - encoderTopLine + 2 * (LCD_HEIGHT)) * ydir;
+        else
+          encoderDiff = epps * (row - encoderPosition + encoderTopLine);
+      }
+      else if (!on_status_screen())
+        encoderDiff = epps * xdir;
+    }
+
+  #endif
+
+#else // !HAS_DISPLAY
+
+  //
+  // Send the status line as a host notification
+  //
+  void MarlinUI::set_status(const char * const message, const bool) {
+    TERN(HOST_PROMPT_SUPPORT, host_action_notify(message), UNUSED(message));
+  }
+  void MarlinUI::set_status_P(PGM_P message, const int8_t) {
+    TERN(HOST_PROMPT_SUPPORT, host_action_notify_P(message), UNUSED(message));
+  }
+  void MarlinUI::status_printf_P(const uint8_t, PGM_P const message, ...) {
+    TERN(HOST_PROMPT_SUPPORT, host_action_notify_P(message), UNUSED(message));
+  }
+
+#endif // !HAS_DISPLAY
+
+#if ENABLED(SDSUPPORT)
+
+  void MarlinUI::media_changed(const uint8_t old_status, const uint8_t status) {
+    if (old_status == status) {
+      TERN_(EXTENSIBLE_UI, ExtUI::onMediaError()); // Failed to mount/unmount
+      return;
+    }
+
+    if (status) {
+      if (old_status < 2) {
+        TERN_(EXTENSIBLE_UI, ExtUI::onMediaInserted()); // ExtUI response
+        set_status_P(GET_TEXT(MSG_MEDIA_INSERTED));
+      }
+    }
+    else {
+      if (old_status < 2) {
+        TERN_(EXTENSIBLE_UI, ExtUI::onMediaRemoved()); // ExtUI response
+        #if PIN_EXISTS(SD_DETECT)
+          set_status_P(GET_TEXT(MSG_MEDIA_REMOVED));
+          #if HAS_LCD_MENU
+            if (!defer_return_to_status) return_to_status();
+          #endif
+        #endif
+      }
+    }
+
+    #if PIN_EXISTS(SD_DETECT) && DISABLED(NO_LCD_REINIT)
+      init_lcd(); // Revive a noisy shared SPI LCD
+    #endif
+
+    refresh();
+
+    #if HAS_WIRED_LCD || defined(LED_BACKLIGHT_TIMEOUT)
+      const millis_t ms = millis();
+    #endif
+
+    TERN_(HAS_WIRED_LCD, next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL); // Delay LCD update for SD activity
+
+    #ifdef LED_BACKLIGHT_TIMEOUT
+      leds.reset_timeout(ms);
+    #endif
+  }
+
+#endif // SDSUPPORT
+
+#if HAS_LCD_MENU
+  void MarlinUI::reset_settings() { settings.reset(); completion_feedback(); }
+#endif
+
+#if ENABLED(EEPROM_SETTINGS)
+
+  #if HAS_LCD_MENU
+    void MarlinUI::init_eeprom() {
+      const bool good = settings.init_eeprom();
+      completion_feedback(good);
+      return_to_status();
+    }
+    void MarlinUI::load_settings() {
+      const bool good = settings.load();
+      completion_feedback(good);
+    }
+    void MarlinUI::store_settings() {
+      const bool good = settings.save();
+      completion_feedback(good);
+    }
+  #endif
+
+  #if DISABLED(EEPROM_AUTO_INIT)
+
+    static inline PGM_P eeprom_err(const uint8_t msgid) {
+      switch (msgid) {
+        default:
+        case 0: return GET_TEXT(MSG_ERR_EEPROM_CRC);
+        case 1: return GET_TEXT(MSG_ERR_EEPROM_INDEX);
+        case 2: return GET_TEXT(MSG_ERR_EEPROM_VERSION);
+      }
+    }
+
+    void MarlinUI::eeprom_alert(const uint8_t msgid) {
+      #if HAS_LCD_MENU
+        editable.uint8 = msgid;
+        goto_screen([]{
+          PGM_P const restore_msg = GET_TEXT(MSG_INIT_EEPROM);
+          char msg[utf8_strlen_P(restore_msg) + 1];
+          strcpy_P(msg, restore_msg);
+          MenuItem_confirm::select_screen(
+            GET_TEXT(MSG_BUTTON_RESET), GET_TEXT(MSG_BUTTON_IGNORE),
+            init_eeprom, return_to_status,
+            eeprom_err(editable.uint8), msg, PSTR("?")
+          );
+        });
+      #else
+        set_status_P(eeprom_err(msgid));
+      #endif
+    }
+
+  #endif // EEPROM_AUTO_INIT
+
+#endif // EEPROM_SETTINGS
